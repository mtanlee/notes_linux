n associated with a list operator
is to \fIflat\fR the children in a single list.
.PP
In the former example, the \f(CW\*(C`d\*(C'\fR nodes don't show up 
since \f(CW\*(Aqd\*(Aq\fR is a syntactic token. However, it may happen that changing the status
of \f(CW\*(Aqd\*(Aq\fR to semantic will not suffice.
.PP
When inserting the children, the tree (\f(CW%tree\fR)  node construction
method (\f(CW\*(C`YYBuildAST\*(C'\fR) omits any attribute that is not a reference.
Therefore, when inserting explicit actions, it is necessary to guarantee that 
the returned value is a reference or a semantic token 
to assure the presence of the value in the lists of children of the node.
Certainly you can use this property to prune parts of the tree.
Consider the following example:
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ cat ListWithRefs1.eyp 
\&  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&  %{
\&  use Data::Dumper;
\&  $Data::Dumper::Indent = 1;
\&  %}
\&  %%
\&  S:      \*(Aqc\*(Aq+  D+ 
\&             { 
\&                print Dumper($_[1]);
\&                print $_[1]\->str."\en";
\&                print Dumper($_[2]);
\&                print $_[2]\->str."\en";
\&             } 
\&  ;
\&
\&  D: \*(Aqd\*(Aq
\&  ;
\&
\&  %%
\&
\&  sub Run {
\&    my ($self) = shift;
\&    return $self\->YYParse( yybuildingtree => 1 );
\&  }
.Ve
.PP
To activate the \fItree semantic\fR for lists we use the \f(CW\*(C`yybuildingtree\*(C'\fR
option of \f(CW\*(C`YYParse\*(C'\fR (line 26).
.PP
The execution gives an output like this:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ eyapp ListWithRefs1.eyp; ./use_listwithrefs1.pl
\&  Try input \*(Aqccdd\*(Aq: ccdd
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST\*(Aq );
\&  _PLUS_LIST(TERMINAL,TERMINAL)
\&  $VAR1 = bless( { \*(Aqchildren\*(Aq => [] }, \*(Aq_PLUS_LIST\*(Aq ); _PLUS_LIST
.Ve
.PP
Though \f(CW\*(Aqd\*(Aq\fR was declared semantic the default action 
associated with the production \f(CW\*(C`D: \*(Aqd\*(Aq\*(C'\fR in line 16
returns \f(CW$_[1]\fR (that is, the scalar \f(CW\*(Aqd\*(Aq\fR). Since it is not
a reference it won't be inserted in the list of children of
\&\f(CW\*(C`_PLUS_LIST\*(C'\fR.
.SS "Recovering the Missing Nodes"
.IX Subsection "Recovering the Missing Nodes"
The solution is to be sure that the attribute is a reference:
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ cat \-n ListWithRefs.eyp
\&     1  %semantic token \*(Aqc\*(Aq 
\&     2  %{
\&     3  use Data::Dumper;
\&     4  $Data::Dumper::Indent = 1;
\&     5  %}
\&     6  %%
\&     7  S:  \*(Aqc\*(Aq+  D+ 
\&     8        { 
\&     9           print Dumper($_[1]);
\&    10           print Dumper($_[2]);
\&    11        } 
\&    12  ;
\&    13  
\&    14  D: \*(Aqd\*(Aq
\&    15       {
\&    16         bless { attr => $_[1], children =>[]}, \*(AqDES\*(Aq;
\&    17       }
\&    18  ;
\&    19  
\&    20  %%
\&    21  
\&    22  sub Run {
\&    23    my ($self) = shift;
\&    24    return $self\->YYParse( yybuildingtree => 1 );
\&    25  }
.Ve
.PP
Now the attribute associated with \f(CW\*(C`D\*(C'\fR is a reference 
and appears in the list of children of \f(CW\*(C`_PLUS_LIST\*(C'\fR:
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ eyapp ListWithRefs.eyp; ./use_listwithrefs.pl
\&  Try input \*(Aqccdd\*(Aq: ccdd
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST\*(Aq );
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqDES\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqDES\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST\*(Aq );
.Ve
.ie n .SS "Building a Tree with ""Parse::Eyapp::Node\->new"""
.el .SS "Building a Tree with \f(CWParse::Eyapp::Node\->new\fP"
.IX Subsection "Building a Tree with Parse::Eyapp::Node->new"
The former solution consisting on writing \fIby hand\fR the code to 
build the node may suffice when dealing with a single node.
Writing by hand the code to build a node is a cumbersome task.
Even worst: though the node built in the former example
looks like a \f(CW\*(C`Parse::Eyapp\*(C'\fR node actually isn't. \f(CW\*(C`Parse::Eyapp\*(C'\fR 
nodes always inherit from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR and 
consequently have access to the methods in such package.
The following execution using the debugger illustrates the point:
.PP
.Vb 1
\&  pl@nereida:~/LEyapp/examples$ perl \-wd use_listwithrefs.pl
\&
\&  Loading DB routines from perl5db.pl version 1.28
\&  Editor support available.
\&
\&  Enter h or \`h h\*(Aq for help, or \`man perldebug\*(Aq for more help.
\&
\&  main::(use_listwithrefs.pl:4):  $parser = new ListWithRefs();
\&    DB<1>  f ListWithRefs.eyp
\&  1       2       #line 3 "ListWithRefs.eyp"
\&  3
\&  4:      use Data::Dumper;
\&  5
\&  6       #line 7 "ListWithRefs.eyp"
\&  7       #line 8 "ListWithRefs.eyp"
\&  8
\&  9:                    print Dumper($_[1]);
\&  10:                   print $_[1]\->str."\en";
.Ve
.PP
through the command \f(CW\*(C`f ListWithRefs.eyp\*(C'\fR we inform the debugger
that subsequent commands will refer to such file. Next 
we execute the program up to the semantic action
associated with the production rule \f(CW\*(C`S: \*(Aqc\*(Aq+  D+\*(C'\fR (line 9)
.PP
.Vb 4
\&    DB<2> c 9     # Continue up to line 9 of ListWithRefs.eyp
\&  ccdd
\&  ListWithRefs::CODE(0x84ebe5c)(ListWithRefs.eyp:9):
\&  9:                    print Dumper($_[1]);
.Ve
.PP
Now we are in condition to look at the contents 
of the arguments:
.PP
.Vb 7
\&    DB<3> x $_[2]\->str
\&  0  \*(Aq_PLUS_LIST_2(DES,DES)\*(Aq
\&    DB<4> x $_[2]\->child(0)
\&  0  DES=HASH(0x85c4568)
\&     \*(Aqattr\*(Aq => \*(Aqd\*(Aq
\&     \*(Aqchildren\*(Aq => ARRAY(0x85c458c)
\&          empty array
.Ve
.PP
the \f(CW\*(C`str\*(C'\fR method works with the object \f(CW$_[2]\fR since
\&\f(CW\*(C`_PLUS_LIST_2\*(C'\fR nodes inherit from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR.
However, when we try with the \f(CW\*(C`DES\*(C'\fR node we get an
error:
.PP
.Vb 4
\&    DB<6> x $_[2]\->child(0)\->str
\&  Can\*(Aqt locate object method "str" via package "DES" at \e
\&    (eval 11)[/usr/share/perl/5.8/perl5db.pl:628] line 2, <STDIN> line 1.
\&    DB<7>
.Ve
.PP
More robust than the former solution of building the node \fIby hand\fR
is to use the constructor \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR:
The method \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
is uset to build forests of syntactic trees.
.PP
It receives a  list of terms describing the trees and \- optionally \-
a reference to a subroutine used to set up the attributes
of the just created nodes. After the creation 
of the trees the sub is called by \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
with arguments the list of references to the nodes (in the order
in which they appear in the terms, from left to right).
\&\f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR returns a list of references 
to the just created nodes. In a scalar context returns a reference to the first of such trees.
See an example:
.PP
.Vb 10
\&  ~/LEyapp/examples$ perl \-MParse::Eyapp \-MData::Dumper \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> @t = Parse::Eyapp::Node\->new(\*(AqA(C,D) E(F)\*(Aq, sub { my $i = 0; $_\->{n} = $i++ for @_ })
\&    DB<2> $Data::Dumper::Indent = 0
\&    DB<3> print Dumper($_)."\en" for @t
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 0,\*(Aqchildren\*(Aq => [bless( {\*(Aqn\*(Aq => 1,\*(Aqchildren\*(Aq => []}, \*(AqC\*(Aq ),
\&                                          bless( {\*(Aqn\*(Aq => 2,\*(Aqchildren\*(Aq => []}, \*(AqD\*(Aq )
\&                                         ]
\&                 }, \*(AqA\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 1,\*(Aqchildren\*(Aq => []}, \*(AqC\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 2,\*(Aqchildren\*(Aq => []}, \*(AqD\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 3,\*(Aqchildren\*(Aq => [bless( {\*(Aqn\*(Aq => 4,\*(Aqchildren\*(Aq => []}, \*(AqF\*(Aq )]}, \*(AqE\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 4,\*(Aqchildren\*(Aq => []}, \*(AqF\*(Aq );
.Ve
.PP
See the following example in which the nodes associated with \f(CW\*(Aqd\*(Aq\fR are
explicitly constructed:
.PP
.Vb 10
\&  ~/LEyapp/examples/eyapplanguageref$ cat \-n ListWithRefs2.eyp 
\&     1  %semantic token \*(Aqc\*(Aq 
\&     2  %{
\&     3  use Data::Dumper;
\&     4  $Data::Dumper::Indent = 1;
\&     5  %}
\&     6  %%
\&     7  S:      \*(Aqc\*(Aq+  D+ 
\&     8             { 
\&     9                print Dumper($_[1]);
\&    10                print $_[1]\->str."\en";
\&    11                print Dumper($_[2]);
\&    12                print $_[2]\->str."\en";
\&    13             } 
\&    14  ;
\&    15  
\&    16  D: \*(Aqd\*(Aq.d
\&    17       {
\&    18         Parse::Eyapp::Node\->new(
\&    19           \*(AqDES(TERMINAL)\*(Aq, 
\&    20            sub { 
\&    21              my ($DES, $TERMINAL) = @_;
\&    22              $TERMINAL\->{attr} = $d;
\&    23            }
\&    24         );
\&    25       }
\&    26  ;
\&    27  
\&    28  %%
\&    29  
\&    30  sub Run {
\&    31    my ($self) = shift;
\&    32    return $self\->YYParse( yybuildingtree => 1 );
\&    33  }
.Ve
.PP
To know more about \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
see the section for \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
.PP
When the former eyapp program is executed produces the following
output:
.PP
.Vb 10
\&  $ eyapp ListWithRefs2.eyp; use_listwithrefs2.pl
\&  ccdd
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST_1\*(Aq );
\&  _PLUS_LIST_1(TERMINAL,TERMINAL)
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqDES\*(Aq ),
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqDES\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST_2\*(Aq );
\&  _PLUS_LIST_2(DES(TERMINAL),DES(TERMINAL))
.Ve
.ie n .SS "The ""*"" operator"
.el .SS "The \f(CW*\fP operator"
.IX Subsection "The * operator"
Any list operator operates on the factor to its left.
A list in the right hand side of a production rule
counts as a single symbol.
.PP
Both operators \f(CW\*(C`*\*(C'\fR and \f(CW\*(C`+\*(C'\fR can be used 
with the format
\&\f(CW\*(C`X <* Separator>\*(C'\fR.
In such case they describe lists of \f(CW\*(C`X\*(C'\fRs separated by 
\&\f(CW\*(C`separator\*(C'\fR. See an example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-25 CsBetweenCommansAndD.eyp | cat \-n
\&   1  # CsBetweenCommansAndD.eyp
\&   2
\&   3  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&   4
\&   5  %{
\&   6  sub TERMINAL::info {
\&   7    $_[0]\->attr;
\&   8  }
\&   9  %}
\&  10  %tree
\&  11  %%
\&  12  S:
\&  13      (\*(Aqc\*(Aq <* \*(Aq,\*(Aq> \*(Aqd\*(Aq)*
\&  14        {
\&  15           print "\enNode\en";
\&  16           print $_[1]\->str."\en";
\&  17           print "\enChild 0\en";
\&  18           print $_[1]\->child(0)\->str."\en";
\&  19           print "\enChild 1\en";
\&  20           print $_[1]\->child(1)\->str."\en";
\&  21           $_[1]
\&  22        }
\&  23  ;
\&  24
\&  25  %%
.Ve
.PP
The rule
.PP
.Vb 1
\&                            S: (\*(Aqc\*(Aq <* \*(Aq,\*(Aq> \*(Aqd\*(Aq)*
.Ve
.PP
has only two items in its right hand side: the (separated by commas) list
of \f(CW\*(C`c\*(C'\fRs and the list of \f(CW\*(C`d\*(C'\fRs.  The production rule is equivalent to:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v CsBetweenCommansAndD.eyp
\&  pl@nereida:~/LEyapp/examples$ head \-11 CsBetweenCommansAndD.output | cat \-n
\&   1  Rules:
\&   2  \-\-\-\-\-\-
\&   3  0:      $start \-> S $end
\&   4  1:      STAR\-1 \-> STAR\-1 \*(Aq,\*(Aq \*(Aqc\*(Aq
\&   5  2:      STAR\-1 \-> \*(Aqc\*(Aq
\&   6  3:      STAR\-2 \-> STAR\-1
\&   7  4:      STAR\-2 \-> /* empty */
\&   8  5:      PAREN\-3 \-> STAR\-2 \*(Aqd\*(Aq
\&   9  6:      STAR\-4 \-> STAR\-4 PAREN\-3
\&  10  7:      STAR\-4 \-> /* empty */
\&  11  8:      S \-> STAR\-4
.Ve
.PP
The semantic action associated with \f(CW\*(C`*\*(C'\fR is to return 
a reference to a list with the attributes of the 
matching items.
.PP
When working \-as in the example \-
under a tree creation directive it returns
a node belonging to a class named \f(CW\*(C`_STAR_LIST_#number\*(C'\fR
whose children are the items in the list.
The \f(CW\*(C`#number\*(C'\fR is the ordinal number of the production rule
as it appears in the \f(CW\*(C`.output\*(C'\fR file. The attributes must be 
references or associated with semantic tokens to be included 
in the list. Notice \-in the execution of the former
example  that follows \-
how the node for \f(CW\*(C`PAREN\-3\*(C'\fR has been 
eliminated from the tree. Parenthesis nodes are \- generally \-
obviated:
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples$ use_csbetweencommansandd.pl
\&  c,c,cd
\&
\&  Node
\&  _STAR_LIST_4(_STAR_LIST_1(TERMINAL[c],TERMINAL[c],TERMINAL[c]),TERMINAL[d])
\&
\&  Child 0
\&  _STAR_LIST_1(TERMINAL[c],TERMINAL[c],TERMINAL[c])
\&
\&  Child 1
\&  TERMINAL[d]
.Ve
.PP
Notice that the comma (since it is a syntactic token) has 
also been suppressed.
.SS "Giving Names to Lists"
.IX Subsection "Giving Names to Lists"
To set the name of the node associated with a list operator the
\&\f(CW%name\fR directive must precede the operator as in 
the following example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ sed \-ne \*(Aq1,27p\*(Aq CsBetweenCommansAndDWithNames.eyp | cat \-n
\&   1  # CsBetweenCommansAndDWithNames.eyp
\&   2
\&   3  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&   4
\&   5  %{
\&   6  sub TERMINAL::info {
\&   7    $_[0]\->attr;
\&   8  }
\&   9  %}
\&  10  %tree
\&  11  %%
\&  12  Start: S
\&  13  ;
\&  14  S:
\&  15      (\*(Aqc\*(Aq <%name Cs * \*(Aq,\*(Aq> \*(Aqd\*(Aq) %name Cs_and_d *
\&  16        {
\&  17           print "\enNode\en";
\&  18           print $_[1]\->str."\en";
\&  19           print "\enChild 0\en";
\&  20           print $_[1]\->child(0)\->str."\en";
\&  21           print "\enChild 1\en";
\&  22           print $_[1]\->child(1)\->str."\en";
\&  23           $_[1]
\&  24        }
\&  25  ;
\&  26
\&  27  %%
.Ve
.PP
The grammar describes the language of sequences
.PP
.Vb 1
\&                  c,...,cd c,...,cd c,...,cd ....
.Ve
.PP
The right hand side of the production has only one term which is a list, 
but the factor to which the star applies is itself a list. 
We are naming the term with the name \f(CW\*(C`Cs_and_d\*(C'\fR and the factor with 
the name \f(CW\*(C`Cs\*(C'\fR.
.PP
The execution shows the renamed nodes:
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples/eyapplanguageref$ use_csbetweencommansanddwithnames.pl
\&  c,c,c,cd
\&
\&  Node
\&  Cs_and_d(Cs(TERMINAL[c],TERMINAL[c],TERMINAL[c],TERMINAL[c]),TERMINAL[d])
\&
\&  Child 0
\&  Cs(TERMINAL[c],TERMINAL[c],TERMINAL[c],TERMINAL[c])
\&
\&  Child 1
\&  TERMINAL[d]
.Ve
.SS "Optionals"
.IX Subsection "Optionals"
The \f(CW\*(C`X?\*(C'\fR operator stands for the presence or omission
of \f(CW\*(C`X\*(C'\fR.
.PP
The grammar:
.PP
.Vb 12
\&  pl@nereida:~/LEyapp/examples$ head \-11 List5.yp | cat \-n
\&       1  %semantic token \*(Aqc\*(Aq
\&       2  %tree
\&       3  %%
\&       4  S: \*(Aqc\*(Aq \*(Aqc\*(Aq?
\&       5       {
\&       6         print $_[2]\->str."\en";
\&       7         print $_[2]\->child(0)\->attr."\en" if $_[2]\->children;
\&       8      }
\&       9  ;
\&      10
\&      11  %%
.Ve
.PP
is equivalent to:
.PP
.Vb 8
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v List5
\&  pl@nereida:~/LEyapp/examples$ head \-7 List5.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> S $end
\&  1:      OPTIONAL\-1 \-> \*(Aqc\*(Aq
\&  2:      OPTIONAL\-1 \-> /* empty */
\&  3:      S \-> \*(Aqc\*(Aq OPTIONAL\-1
.Ve
.PP
When \f(CW\*(C`yybuildingtree\*(C'\fR is false the associated attribute 
is a list that will be empty if \s-1CX\s0> does not show up.
.PP
Under the \f(CW%tree\fR directive the action creates an \f(CW\*(C`_OPTIONAL\*(C'\fR
node:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ use_list5.pl
\&  cc
\&  _OPTIONAL_1(TERMINAL)
\&  c
\&  pl@nereida:~/LEyapp/examples$ use_list5.pl
\&  c
\&  _OPTIONAL_1
.Ve
.SS "Parenthesis"
.IX Subsection "Parenthesis"
Any substring on the right hand side of a production rule can be grouped
using a parenthesis. The introduction of a parenthesis implies the introduction
of an additional syntactic variable whose only production 
is the sequence of symbols between the parenthesis. Thus the grammar:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ head \-6 Parenthesis.eyp | cat \-n
\&     1  %%
\&     2  S:
\&     3        (\*(Aqa\*(Aq S ) \*(Aqb\*(Aq  { shift; [ @_ ] }
\&     4      | \*(Aqc\*(Aq
\&     5  ;
\&     6  %%
.Ve
.PP
is equivalent to:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v Parenthesis.eyp; head \-6 Parenthesis.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> S $end
\&  1:      PAREN\-1 \-> \*(Aqa\*(Aq S
\&  2:      S \-> PAREN\-1 \*(Aqb\*(Aq
\&  3:      S \-> \*(Aqc\*(Aq
.Ve
.PP
By default the semantic rule associated with a parenthesis
returns an anonymous list with the attributes of the symbols 
between the parenthesis:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n use_parenthesis.pl
\&       1  #!/usr/bin/perl \-w
\&       2  use Parenthesis;
\&       3  use Data::Dumper;
\&       4
\&       5  $Data::Dumper::Indent = 1;
\&       6  $parser = Parenthesis\->new();
\&       7  print Dumper($parser\->Run);
\&  pl@nereida:~/LEyapp/examples$ use_parenthesis.pl
\&  acb
\&  $VAR1 = [
\&    [ \*(Aqa\*(Aq, \*(Aqc\*(Aq ], \*(Aqb\*(Aq
\&  ];
\&  pl@nereida:~/LEyapp/examples$ use_parenthesis.pl
\&  aacbb
\&  $VAR1 = [
\&    [
\&      \*(Aqa\*(Aq,
\&      [ [ \*(Aqa\*(Aq, \*(Aqc\*(Aq ], \*(Aqb\*(Aq ]
\&    ],
\&    \*(Aqb\*(Aq
\&  ];
.Ve
.PP
when working under a tree directive or when the attribute
\&\f(CW\*(C`buildingtree\*(C'\fR is set via the \f(CW\*(C`YYBuildingtree\*(C'\fR method
the semantic action returns a node with children the attributes
of the symbols between parenthesis. As usual attributes
which aren't references will be skipped from the list of children.
See an example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-23 List2.yp | cat \-n
\&   1  %{
\&   2  use Data::Dumper;
\&   3  %}
\&   4  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq \*(Aqc\*(Aq
\&   5  %tree
\&   6  %%
\&   7  S:
\&   8        (%name AS \*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&   9          {
\&  10            print "S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\en";
\&  11            print "Attribute of the first symbol:\en".Dumper($_[1]);
\&  12            print "Attribute of the second symbol: $_[2]\en";
\&  13            $_[0]\->YYBuildAST(@_[1..$#_]);
\&  14          }
\&  15      | \*(Aqc\*(Aq
\&  16          {
\&  17            print "S \-> \*(Aqc\*(Aq\en";
\&  18            my $r = Parse::Eyapp::Node\->new(qw(C(TERMINAL)), sub { $_[1]\->attr(\*(Aqc\*(Aq) }) ;
\&  19            print Dumper($r);
\&  20            $r;
\&  21          }
\&  22  ;
\&  23  %%
.Ve
.PP
The example shows (line 8)
how to rename a \f(CW\*(C`_PAREN\*(C'\fR node. The \f(CW\*(C`%name CLASSNAME\*(C'\fR goes
after the opening parenthesis.
.PP
The call to \f(CW\*(C`YYBuildAST\*(C'\fR at line 13
with argumetns the attributes of the symbols on the right hand side
returns the node describing the current production rule.
Notice that line 13 can be rewritten as:
.PP
.Vb 1
\&                    goto &Parse::Eyapp::Driver::YYBuildAST;
.Ve
.PP
At line 18 the node for the rule is explicitly created
using \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR. The handler passed as second argument
is responsible for setting the value of the atribute \f(CW\*(C`attr\*(C'\fR
of the just created \f(CW\*(C`TERMINAL\*(C'\fR node.
.PP
Let us see an execution:
.PP
.Vb 11
\&  pl@nereida:~/LEyapp/examples$ use_list2.pl
\&  aacbb
\&  S \-> \*(Aqc\*(Aq
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( {
\&        \*(Aqchildren\*(Aq => [],
\&        \*(Aqattr\*(Aq => \*(Aqc\*(Aq
\&      }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(AqC\*(Aq );
.Ve
.PP
the first reduction occurs by the non recursive rule. The execution
shows the tree built by the call to
\&\f(CW\*(C`Parse::Eyapp::Node\-\*(C'\fRnew>
at line 18.
.PP
The execution continues with the reduction or reverse derivation by the rule
\&\f(CW\*(C`S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\*(C'\fR. The action at lines 9\-14
dumps the attribute associated with \f(CW\*(C`(\*(Aqa\*(Aq S)\*(C'\fR
\&\- or, in other words,  the attribute associated with the variable 
\&\f(CW\*(C`PAREN\-1\*(C'\fR. It also dumps the attribute of \f(CW\*(Aqb\*(Aq\fR:
.PP
.Vb 11
\&  S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&  Attribute of the first symbol:
\&  $VAR1 = bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&        bless( { \*(Aqchildren\*(Aq => [ bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&       ]
\&     }, \*(AqC\*(Aq )
\&    ]
\&  }, \*(AqAS\*(Aq );
\&Attribute of the second symbol: b
.Ve
.PP
The last reduction shown is by the rule:
\&\f(CW\*(C`S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\*(C'\fR:
.PP
.Vb 10
\&  S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&  Attribute of the first symbol:
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( {
\&            \*(Aqchildren\*(Aq => [
\&              bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&              bless( {
\&                \*(Aqchildren\*(Aq => [
\&                  bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&                ]
\&              }, \*(AqC\*(Aq )
\&            ]
\&          }, \*(AqAS\*(Aq ),
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqb\*(Aq, \*(Aqtoken\*(Aq => \*(Aqb\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqS_2\*(Aq )
\&    ]
\&  }, \*(AqAS\*(Aq );
\&  Attribute of the second symbol: b
.Ve
.SS "Actions Inside Parenthesis"
.IX Subsection "Actions Inside Parenthesis"
Though is a practice to avoid, since it clutters
the code, it is certainly permitted to introduce
actions between the parenthesis, as in the example below:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-16 ListAndAction.eyp | cat \-n
\&   1  # ListAndAction.eyp
\&   2  %{
\&   3  my $num = 0;
\&   4  %}
\&   5
\&   6  %%
\&   7  S:      \*(Aqc\*(Aq
\&   8              {
\&   9                print "S \-> c\en"
\&  10              }
\&  11      |    (\*(Aqa\*(Aq {$num++; print "Seen <$num> \*(Aqa\*(Aqs\en"; $_[1] }) S \*(Aqb\*(Aq
\&  12              {
\&  13                print "S \-> (a ) S b\en"
\&  14              }
\&  15  ;
\&  16  %%
.Ve
.PP
This is the output when executing this program with input \f(CW\*(C`aaacbbb\*(C'\fR:
.PP
.Vb 9
\&  pl@nereida:~/LEyapp/examples$ use_listandaction.pl
\&  aaacbbb
\&  Seen <1> \*(Aqa\*(Aqs
\&  Seen <2> \*(Aqa\*(Aqs
\&  Seen <3> \*(Aqa\*(Aqs
\&  S \-> c
\&  S \-> (a ) S b
\&  S \-> (a ) S b
\&  S \-> (a ) S b
.Ve
.SH "NAMES FOR ATTRIBUTES"
.IX Header "NAMES FOR ATTRIBUTES"
Attributes can be referenced by meaningful names using the \fIdot notation\fR
instead of using the classic error-prone positional approach:
.PP
.Vb 5
\&                        rhs:  rhseltwithid *
\&                        rhseltwithid : 
\&                              rhselt \*(Aq.\*(Aq IDENT 
\&                            | \*(Aq$\*(Aq rhselt  
\&                            | rhselt
.Ve
.PP
for example:
.PP
.Vb 1
\&              exp : exp.left \*(Aq\-\*(Aq exp.right  { $left \- $right }
.Ve
.PP
By qualifying the first appearance of the syntactic variable \f(CW\*(C`exp\*(C'\fR
with the notation \f(CW\*(C`exp.left\*(C'\fR we can later refer inside the actions
to the associated attribute using the lexical variable
\&\f(CW$left\fR.
.PP
The \fIdollar notation\fR \f(CW$A\fR can be used as an abbreviation
of \f(CW\*(C`A.A\*(C'\fR.
.SH "DEFAULT ACTIONS"
.IX Header "DEFAULT ACTIONS"
When no action is specified both \f(CW\*(C`yapp\*(C'\fR and \f(CW\*(C`eyapp\*(C'\fR
implicitly insert the semantic action \f(CW\*(C`{ $_[1] }\*(C'\fR. 
In \f(CW\*(C`Parse::Eyapp\*(C'\fR you can modify such behavior using the \f(CW\*(C`%defaultaction { Perl code }\*(C'\fR
directive. The \f(CW\*(C`{ Perl code }\*(C'\fR clause that follows the \f(CW%defaultaction\fR
directive is
executed when reducing by any production for which no explicit
action was specified.
.SS "An Example of Default Action: Translator from Infix to Postfix"
.IX Subsection "An Example of Default Action: Translator from Infix to Postfix"
See an example that translates an infix expression
like \f(CW\*(C`a=b*\-3\*(C'\fR into a postfix expression like \f(CW\*(C`a b 3 NEG * = \*(C'\fR:
.PP
.Vb 5
\& # File Postfix.eyp (See the examples/ directory)
\& %right  \*(Aq=\*(Aq
\& %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\& %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\& %left   NEG
\&
\& %defaultaction { return  "$left $right $op"; }
\&
\& %%
\& line: $exp  { print "$exp\en" }
\& ;
\&
\& exp:        $NUM  { $NUM }
\&         |   $VAR  { $VAR }
\&         |   VAR.left \*(Aq=\*(Aq.op exp.right
\&         |   exp.left \*(Aq+\*(Aq.op exp.right
\&         |   exp.left \*(Aq\-\*(Aq.op exp.right
\&         |   exp.left \*(Aq*\*(Aq.op exp.right
\&         |   exp.left \*(Aq/\*(Aq.op exp.right
\&         |   \*(Aq\-\*(Aq $exp %prec NEG { "$exp NEG" }
\&         |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq { $exp }
\& ;
\&
\& %%
\&
\& # Support subroutines as in the Synopsis example
\& ...
.Ve
.PP
The file containing the \f(CW\*(C`Eyapp\*(C'\fR program must be compiled with \f(CW\*(C`eyapp\*(C'\fR:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> eyapp Postfix.eyp
.Ve
.PP
Next, you have to write a client program:
.PP
.Vb 7
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n usepostfix.pl
\&      1  #!/usr/bin/perl \-w
\&      2  use strict;
\&      3  use Postfix;
\&      4
\&      5  my $parser = new Postfix();
\&      6  $parser\->Run;
.Ve
.PP
Now we can run the client program:
.PP
.Vb 3
\& nereida:~/src/perl/YappWithDefaultAction/examples> usepostfix.pl
\& Write an expression: \-(2*a\-b*\-3)
\& 2 a * b 3 NEG * \- NEG
.Ve
.ie n .SS "Default Actions, %name and ""YYName"""
.el .SS "Default Actions, \f(CW%name\fP and \f(CWYYName\fP"
.IX Subsection "Default Actions, %name and YYName"
In \f(CW\*(C`eyapp\*(C'\fR each production rule has a name.
The name of a rule can be explicitly given by the programmer 
using the \f(CW%name\fR directive. For example, in the piece of code
that follows the name \f(CW\*(C`ASSIGN\*(C'\fR is given to the rule \f(CW\*(C`exp: VAR \*(Aq=\*(Aq exp\*(C'\fR.
.PP
When no explicit name is given the rule has an implicit name.
The implicit name of a rule is shaped by concatenating
the name of the syntactic variable on its left, an underscore 
and the ordinal number of the production rule \f(CW\*(C`Lhs_#\*(C'\fR
as it appears in the \f(CW\*(C`.output\*(C'\fR file.
Avoid giving names matching such pattern to production rules.
The patterns
\&\f(CW\*(C`/${lhs}_\ed+$/\*(C'\fR where \f(CW\*(C`${lhs}\*(C'\fR is the name of the syntactic variable
are reserved for internal use by \f(CW\*(C`eyapp\*(C'\fR.
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n Lhs.eyp
\&   1  # Lhs.eyp
\&   2
\&   3  %right  \*(Aq=\*(Aq
\&   4  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&   5  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&   6  %left   NEG
\&   7
\&   8  %defaultaction {
\&   9    my $self = shift;
\&  10    my $name = $self\->YYName();
\&  11    bless { children => [ grep {ref($_)} @_] }, $name;
\&  12  }
\&  13
\&  14  %%
\&  15  input:
\&  16              /* empty */
\&  17                { [] }
\&  18          |   input line
\&  19                {
\&  20                  push @{$_[1]}, $_[2] if defined($_[2]);
\&  21                  $_[1]
\&  22                }
\&  23  ;
\&  24
\&  25  line:     \*(Aq\en\*(Aq       { }
\&  26          | exp \*(Aq\en\*(Aq   {  $_[1] }
\&  27  ;
\&  28
\&  29  exp:
\&  30              NUM   { $_[1] }
\&  31          |   VAR   { $_[1] }
\&  32          |   %name ASSIGN
\&  33              VAR \*(Aq=\*(Aq exp
\&  34          |   %name PLUS
\&  35              exp \*(Aq+\*(Aq exp
\&  36          |   %name MINUS
\&  37              exp \*(Aq\-\*(Aq exp
\&  38          |   %name TIMES
\&  39              exp \*(Aq*\*(Aq exp
\&  40          |   %name DIV
\&  41              exp \*(Aq/\*(Aq exp
\&  42          |   %name UMINUS
\&  43              \*(Aq\-\*(Aq exp %prec NEG
\&  44          |  \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&  45  ;
.Ve
.PP
Inside a semantic action
the name of the current rule can be recovered 
using the method \f(CW\*(C`YYName\*(C'\fR of the parser object.
.PP
The default action (lines 8\-12) computes as attribute of the left
hand side a reference to an object blessed in the name of the rule.
The object has an attribute \f(CW\*(C`children\*(C'\fR which is a reference 
to the list of children of the node.
The call to \f(CW\*(C`grep\*(C'\fR
.PP
.Vb 1
\&  11    bless { children => [ grep {ref($_)} @_] }, $name;
.Ve
.PP
excludes children that aren't references. Notice that the lexical analyzer 
only returns references for the \f(CW\*(C`NUM\*(C'\fR and \f(CW\*(C`VAR\*(C'\fR terminals:
.PP
.Vb 10
\&  59  sub _Lexer {
\&  60      my($parser)=shift;
\&  61
\&  62      for ($parser\->YYData\->{INPUT}) {
\&  63          s/^[ \et]+//;
\&  64          return(\*(Aq\*(Aq,undef) unless $_;
\&  65          s/^([0\-9]+(?:\e.[0\-9]+)?)//
\&  66                  and return(\*(AqNUM\*(Aq, bless { attr => $1}, \*(AqNUM\*(Aq);
\&  67          s/^([A\-Za\-z][A\-Za\-z0\-9_]*)//
\&  68                  and return(\*(AqVAR\*(Aq,bless {attr => $1}, \*(AqVAR\*(Aq);
\&  69          s/^(.)//s
\&  70                  and return($1, $1);
\&  71      }
\&  72      return(\*(Aq\*(Aq,undef);
\&  73  }
.Ve
.PP
follows the client program:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n uselhs.pl
\&       1  #!/usr/bin/perl \-w
\&       2  use Lhs;
\&       3  use Data::Dumper;
\&       4
\&       5  $parser = new Lhs();
\&       6  my $tree = $parser\->Run;
\&       7  $Data::Dumper::Indent = 1;
\&       8  if (defined($tree)) { print Dumper($tree); }
\&       9  else { print "Cadena no va\*'lida\en"; }
.Ve
.PP
When executed with input \f(CW\*(C`a=(2+3)*b\*(C'\fR the parser produces
the following tree:
.PP
.Vb 1
\&  ASSIGN(TIMES(PLUS(NUM[2],NUM[3]), VAR[b]))
.Ve
.PP
See the result of an execution:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ uselhs.pl
\&  a=(2+3)*b
\&  $VAR1 = [
\&    bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqattr\*(Aq => \*(Aqa\*(Aq }, \*(AqVAR\*(Aq ),
\&        bless( {
\&          \*(Aqchildren\*(Aq => [
\&            bless( {
\&              \*(Aqchildren\*(Aq => [
\&                bless( { \*(Aqattr\*(Aq => \*(Aq2\*(Aq }, \*(AqNUM\*(Aq ),
\&                bless( { \*(Aqattr\*(Aq => \*(Aq3\*(Aq }, \*(AqNUM\*(Aq )
\&              ]
\&            }, \*(AqPLUS\*(Aq ),
\&            bless( { \*(Aqattr\*(Aq => \*(Aqb\*(Aq }, \*(AqVAR\*(Aq )
\&          ]
\&        }, \*(AqTIMES\*(Aq )
\&      ]
\&    }, \*(AqASSIGN\*(Aq )
\&  ];
.Ve
.PP
The name of a production rule can be changed at execution time.
See the following example:
.PP
.Vb 10
\&  $ sed \-n \*(Aq29,50p\*(Aq YYNameDynamic.eyp | cat \-n
\&     1  exp:
\&     2              NUM   { $_[1] }
\&     3          |   VAR   { $_[1] }
\&     4          |   %name ASSIGN
\&     5              VAR \*(Aq=\*(Aq exp
\&     6          |   %name PLUS
\&     7              exp \*(Aq+\*(Aq exp
\&     8          |   %name MINUS
\&     9              exp \*(Aq\-\*(Aq exp
\&    10                {
\&    11                  my $self = shift;
\&    12                  $self\->YYName(\*(AqSUBTRACT\*(Aq); # rename it
\&    13                  $self\->YYBuildAST(@_); # build the node
\&    14                }
\&    15          |   %name TIMES
\&    16              exp \*(Aq*\*(Aq exp
\&    17          |   %name DIV
\&    18              exp \*(Aq/\*(Aq exp
\&    19          |   %name UMINUS
\&    20              \*(Aq\-\*(Aq exp %prec NEG
\&    21          |  \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&    22  ;
.Ve
.PP
When the client program is executed we can see the presence
of the \f(CW\*(C`SUBTRACT\*(C'\fR nodes:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ useyynamedynamic.pl
\&  2\-b
\&  $VAR1 = [
\&    bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( {
\&          \*(Aqattr\*(Aq => \*(Aq2\*(Aq
\&        }, \*(AqNUM\*(Aq ),
\&        bless( {
\&          \*(Aqattr\*(Aq => \*(Aqb\*(Aq
\&        }, \*(AqVAR\*(Aq )
\&      ]
\&    }, \*(AqSUBTRACT\*(Aq )
\&  ];
.Ve
.SH "GRAMMAR REUSE"
.IX Header "GRAMMAR REUSE"
.SS "Reusing Grammars Using Inheritance"
.IX Subsection "Reusing Grammars Using Inheritance"
An method to reuse a grammar is via inheritance. 
The client inherits the generated parser module and expands it 
with methods that inherit or overwrite the actions.
Here is an example. Initially we have this Eyapp grammar:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n NoacInh.eyp
\&     1  %left   \*(Aq+\*(Aq
\&     2  %left   \*(Aq*\*(Aq
\&     3
\&     4  %defaultaction {
\&     5    my $self = shift;
\&     6
\&     7    my $action = $self\->YYName;
\&     8
\&     9    $self\->$action(@_);
\&    10  }
\&    11
\&    12  %%
\&    13  exp:        %name NUM
\&    14                NUM
\&    15          |   %name PLUS
\&    16                exp \*(Aq+\*(Aq exp
\&    17          |   %name TIMES
\&    18                exp \*(Aq*\*(Aq exp
\&    19          |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&    20                { $_[2] }
\&    21  ;
\&    22
\&    23  %%
\&    24
\&    25  sub _Error {
\&    26    my($token)=$_[0]\->YYCurval;
\&    27    my($what)= $token ? "input: \*(Aq$token\*(Aq" : "end of input";
\&    28    my @expected = $_[0]\->YYExpect();
\&    29
\&    30    local $" = \*(Aq, \*(Aq;
\&    31    die "Syntax error near $what. Expected one of these tokens: @expected\en";
\&    32  }
\&    33
\&    34
\&    35  my $x = \*(Aq\*(Aq;
\&    36
\&    37  sub _Lexer {
\&    38    my($parser)=shift;
\&    39
\&    40    for ($x) {
\&    41      s/^\es+//;
\&    42      $_ eq \*(Aq\*(Aq and return(\*(Aq\*(Aq,undef);
\&    43
\&    44      s/^([0\-9]+(?:\e.[0\-9]+)?)//   and return(\*(AqNUM\*(Aq,$1);
\&    45      s/^([A\-Za\-z][A\-Za\-z0\-9_]*)// and return(\*(AqVAR\*(Aq,$1);
\&    46      s/^(.)//s                    and return($1,$1);
\&    47    }
\&    48  }
\&    49
\&    50  sub Run {
\&    51    my($self)=shift;
\&    52    $x = shift;
\&    53    my $debug = shift;
\&    54
\&    55    $self\->YYParse(
\&    56      yylex => \e&_Lexer,
\&    57      yyerror => \e&_Error,
\&    58      yydebug => $debug,
\&    59    );
\&    60  }
.Ve
.PP
The following program defines two classes: \f(CW\*(C`CalcActions\*(C'\fR
that implements the actions for the calculator
and package \f(CW\*(C`PostActions\*(C'\fR that implements the actions
for the infix to postfix translation. This way we have an 
example that reuses the former grammar twice:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n icalcu_and_ipost.pl
\&     1  #!/usr/bin/perl \-w
\&     2  package CalcActions;
\&     3  use strict;
\&     4  use base qw{NoacInh};
\&     5
\&     6  sub NUM {
\&     7    return $_[1];
\&     8  }
\&     9
\&    10  sub PLUS {
\&    11    $_[1]+$_[3];
\&    12  }
\&    13
\&    14  sub TIMES {
\&    15    $_[1]*$_[3];
\&    16  }
\&    17
\&    18  package PostActions;
\&    19  use strict;
\&    20  use base qw{NoacInh};
\&    21
\&    22  sub NUM {
\&    23    return $_[1];
\&    24  }
\&    25
\&    26  sub PLUS {
\&    27    "$_[1] $_[3] +";
\&    28  }
\&    29
\&    30  sub TIMES {
\&    31    "$_[1] $_[3] *";
\&    32  }
\&    33
\&    34  package main;
\&    35  use strict;
\&    36
\&    37  my $calcparser = CalcActions\->new();
\&    38  print "Write an expression: ";
\&    39  my $x = <STDIN>;
\&    40  my $e = $calcparser\->Run($x);
\&    41
\&    42  print "$e\en";
\&    43
\&    44  my $postparser = PostActions\->new();
\&    45  my $p = $postparser\->Run($x);
\&    46
\&    47  print "$p\en";
.Ve
.PP
The subroutine used as default action in \f(CW\*(C`NoacInh.eyp\*(C'\fR is so useful 
that is packed as the Parse::Eyapp::Driver method 
\&\f(CW\*(C`YYDelegateaction\*(C'\fR.
.PP
See files \f(CW\*(C`examples/recycle/NoacYYDelegateaction.eyp\*(C'\fR
and \f(CW\*(C`examples/recycle/icalcu_and_ipost_yydel.pl\*(C'\fR
for an example of use of \f(CW\*(C`YYDelegateaction\*(C'\fR.
.SS "Reusing Grammars by Dynamic Substitution of Semantic Actions"
.IX Subsection "Reusing Grammars by Dynamic Substitution of Semantic Actions"
The methods \f(CW\*(C`YYSetaction\*(C'\fR and \f(CW\*(C`YYAction\*(C'\fR of the parser object provide a way
to selectively substitute some actions of a given grammar.
Let us consider once more a postfix to infix translator:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n PostfixWithActions.eyp
\&     1  # File PostfixWithActions.eyp
\&     2  %right  \*(Aq=\*(Aq
\&     3  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&     4  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&     5  %left   NEG
\&     6
\&     7  %%
\&     8  line: $exp  { print "$exp\en" }
\&     9  ;
\&    10
\&    11  exp:        $NUM
\&    12                  { $NUM }
\&    13          |   $VAR
\&    14                  { $VAR }
\&    15          |   %name ASSIGN
\&    16                VAR.left \*(Aq=\*(Aqexp.right
\&    17                  { "$_[3] &$_[1] ASSIGN"; }
\&    18          |   %name PLUS
\&    19                exp.left \*(Aq+\*(Aqexp.right
\&    20                  { "$_[1] $_[3] PLUS"; }
\&    21          |   %name MINUS
\&    22                exp.left \*(Aq\-\*(Aqexp.right
\&    23                  { "$_[1] $_[3] MINUS"; }
\&    24          |   %name TIMES
\&    25                exp.left \*(Aq*\*(Aqexp.right
\&    26                  { "$_[1] $_[3] TIMES"; }
\&    27          |   %name DIV
\&    28                exp.left \*(Aq/\*(Aqexp.right
\&    29                  { "$_[1] $_[3] DIV"; }
\&    30          |   %name NEG \*(Aq\-\*(Aq $exp %prec NEG
\&    31                  { "$exp NEG" }
\&    32          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq
\&    33                  { $exp }
\&    34  ;
\&    35
\&    36  %%
\&    37
\&    38  sub _Error {
\&    39    my($token)=$_[0]\->YYCurval;
\&    40    my($what)= $token ? "input: \*(Aq$token\*(Aq" : "end of input";
\&    41    my @expected = $_[0]\->YYExpect();
\&    42
\&    43    local $" = \*(Aq, \*(Aq;
\&    44    die "Syntax error near $what. Expected one of these tokens: @expected\en";
\&    45  }
\&    46
\&    47  my $x;
\&    48
\&    49  sub _Lexer {
\&    50    my($parser)=shift;
\&    51
\&    52    for ($x) {
\&    53      s/^\es+//;
\&    54      $_ eq \*(Aq\*(Aq and return(\*(Aq\*(Aq,undef);
\&    55
\&    56      s/^([0\-9]+(?:\e.[0\-9]+)?)//   and return(\*(AqNUM\*(Aq,$1);
\&    57      s/^([A\-Za\-z][A\-Za\-z0\-9_]*)// and return(\*(AqVAR\*(Aq,$1);
\&    58      s/^(.)//s                    and return($1,$1);
\&    59    }
\&    60  }
\&    61
\&    62  sub Run {
\&    63    my($self)=shift;
\&    64    $x = shift;
\&    65    $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&    66      #yydebug => 0xFF
\&    67    );
\&    68  }
.Ve
.PP
The program \f(CW\*(C`rewritepostfixwithactions.pl\*(C'\fR uses the former grammar
to translate infix expressions to postfix expressions.
It also implements a calculator reusing the grammar in
\&\f(CW\*(C`PostfixWithActions.eyp\*(C'\fR. It does so using
the \f(CW\*(C`YYSetaction\*(C'\fR method.
The semantic actions for the productions named
.IP "\(bu" 2
\&\s-1ASSIGN\s0
.IP "\(bu" 2
\&\s-1PLUS\s0
.IP "\(bu" 2
\&\s-1TIMES\s0
.IP "\(bu" 2
\&\s-1DIV\s0
.IP "\(bu" 2
\&\s-1NEG\s0
.PP
are selectively substituted by the appropriate actions, while the other
semantic actions remain unchanged:
.PP
.Vb 10
\&  pl@europa:~/LEyapp/examples/recycle$ cat \-n rewritepostfixwithactions.pl
\&     1  #!/usr/bin/perl
\&     2  use warnings;
\&     3  use PostfixWithActions;
\&     4
\&     5  my $debug = shift || 0;
\&     6  my $pparser = PostfixWithActions\->new();
\&     7  print "Write an expression: ";
\&     8  my $x = <STDIN>;
\&     9
\&    10  # First, trasnlate to postfix ...
\&    11  $pparser\->Run($x, $debug);
\&    12
\&    13  # And then selectively substitute
\&    14  # some semantic actions
\&    15  # to obtain an infix calculator ...
\&    16  my %s;            # symbol table
\&    17  $pparser\->YYSetaction(
\&    18    ASSIGN => sub { $s{$_[1]} = $_[3] },
\&    19    PLUS   => sub { $_[1] + $_[3] },
\&    20    TIMES  => sub { $_[1] * $_[3] },
\&    21    DIV    => sub { $_[1] / $_[3] },
\&    22    NEG    => sub { \-$_[2] },
\&    23  );
\&    24
\&    25  $pparser\->Run($x, $debug);
.Ve
.PP
When running this program the output is:
.PP
.Vb 8
\&  examples/recycle$ ./rewritepostfixwithactions.pl
\&  Write an expression: 2*3+4
\&  2 3 TIMES 4 PLUS
\&  10
\&  examples/recycle$ rewritepostfixwithactions.pl
\&  Write an expression: a = 2*(b = 3+5)
\&  2 3 5 PLUS &b ASSIGN TIMES &a ASSIGN
\&  16
.Ve
.ie n .SH "ABSTRACT SYNTAX TREES: %tree AND %name"
.el .SH "ABSTRACT SYNTAX TREES: \f(CW%tree\fP AND \f(CW%name\fP"
.IX Header "ABSTRACT SYNTAX TREES: %tree AND %name"
.ie n .SS "%tree Default Names"
.el .SS "\f(CW%tree\fP Default Names"
.IX Subsection "%tree Default Names"
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR facilitates the construction of concrete syntax trees and 
abstract syntax trees (abbreviated \s-1AST\s0 from now on) through the \f(CW%tree\fR
directive. Actually, the \f(CW%tree\fR directive is equivalent to a call
to the \f(CW\*(C`YYBuildAST\*(C'\fR method of the parser object.
.PP
Any production production rule \f(CW\*(C`A\->XYZ\*(C'\fR 
can be named using a directive \f(CW\*(C`%name someclass\*(C'\fR.
.PP
When reducing by a production rule \f(CW\*(C`A\->XYZ\*(C'\fR 
the \f(CW%tree\fR directive (i.e., the \f(CW\*(C`YYBuildAST\*(C'\fR method) 
builds an anonymous hash blessed in \f(CW\*(C`someclass\*(C'\fR.
The hash has an attribute \f(CW\*(C`children\*(C'\fR containing the references
to the \s-1AST\s0 trees associated with the symbols in the right hand
side \f(CW\*(C`X\*(C'\fR, C>Y>, etc.
.PP
If no explicit name was given to the production rule,
\&\f(CW\*(C`YYBuildAST\*(C'\fR blesses the node in the class name resulting 
from the concatenation
of the left hand side and the production number. The production number
is the ordinal number of the production as they appear in the associated 
\&\f(CW\*(C`.output\*(C'\fR file (see option \f(CW\*(C`\-v\*(C'\fR of eyapp). For example,
given the grammar:
.PP
.Vb 7
\&  pl@europa:~/LEyapp/examples/eyapplanguageref$ sed \-ne \*(Aq8,27p\*(Aq treewithoutnames.pl
\&  my $grammar = q{
\&    %right  \*(Aq=\*(Aq     # Lowest precedence
\&    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&    %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&    %tree           # Let us build an abstract syntax tree ...
\&
\&    %%
\&    line: exp <+ \*(Aq;\*(Aq>  { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&    ;
\&
\&    exp:
\&         NUM           |   VAR       | VAR \*(Aq=\*(Aq exp
\&      | exp \*(Aq+\*(Aq exp    | exp \*(Aq\-\*(Aq exp |  exp \*(Aq*\*(Aq exp
\&      | exp \*(Aq/\*(Aq exp
\&      | \*(Aq\-\*(Aq exp %prec NEG
\&      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&    ;
\&
\&    %%
.Ve
.PP
The tree produced by the parser when feed with input \f(CW\*(C`a=2*b\*(C'\fR
is:
.PP
.Vb 1
\&  pl@europa:~/LEyapp/examples/eyapplanguageref$ ./treewithoutnames.pl
\&
\&  ************
\&  _PLUS_LIST(exp_6(TERMINAL[a],exp_9(exp_4(TERMINAL[2]),exp_5(TERMINAL[b]))))
\&  ************
.Ve
.PP
If we want to see the correspondence between names and rules we can generate and
check the corresponding file \f(CW\*(C`.output\*(C'\fR setting the \f(CW\*(C`outputfile\*(C'\fR
of \f(CW\*(C`Parse::Eyapp\*(C'\fR:
.PP
.Vb 6
\&  Parse::Eyapp\->new_grammar( # Create the parser package/class
\&    input=>$grammar,
\&    classname=>\*(AqCalc\*(Aq, # The name of the package containing the parser
\&    firstline=>9,      # String $grammar starts at line 9 (for error diagnostics)
\&    outputfile=>\*(Aqtreewithoutnames\*(Aq
\&  );
.Ve
.PP
The grammar with the expanded rules appears in the \f(CW\*(C`.output\*(C'\fR file:
.PP
.Vb 10
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/eyapplanguageref$ sed \-ne \*(Aq28,42p\*(Aq treewithoutnames.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> line $end
\&  1:      PLUS\-1 \-> PLUS\-1 \*(Aq;\*(Aq exp
\&  2:      PLUS\-1 \-> exp
\&  3:      line \-> PLUS\-1
\&  4:      exp \-> NUM
\&  5:      exp \-> VAR
\&  6:      exp \-> VAR \*(Aq=\*(Aq exp
\&  7:      exp \-> exp \*(Aq+\*(Aq exp
\&  8:      exp \-> exp \*(Aq\-\*(Aq exp
\&  9:      exp \-> exp \*(Aq*\*(Aq exp
\&  10:     exp \-> exp \*(Aq/\*(Aq exp
\&  11:     exp \-> \*(Aq\-\*(Aq exp
\&  12:     exp \-> \*(Aq(\*(Aq exp \*(Aq)\*(Aq
.Ve
.PP
We can see now that the node \f(CW\*(C`exp_9\*(C'\fR corresponds to the production \f(CW\*(C`exp \-> exp \*(Aq*\*(Aq exp\*(C'\fR.
Observe also that the Eyapp production:
.PP
.Vb 2
\&                                line: exp <+ \*(Aq;\*(Aq>
\&actually produces the productions:
\&
\&                        1:      PLUS\-1 \-> PLUS\-1 \*(Aq;\*(Aq exp
\&                        2:      PLUS\-1 \-> exp
.Ve
.PP
and that the name of the class associated with the non empty list is \f(CW\*(C`_PLUS_LIST\*(C'\fR.
.ie n .SS "%tree Giving Explicit Names"
.el .SS "\f(CW%tree\fP Giving Explicit Names"
.IX Subsection "%tree Giving Explicit Names"
A production rule can be \fInamed\fR using the \f(CW\*(C`%name IDENTIFIER\*(C'\fR directive.  For
each production rule a namespace/package is created. \fIThe\fR \f(CW\*(C`IDENTIFIER\*(C'\fR 
\&\fIis the name of the associated package\fR.  Therefore, by modifying the former
grammar with additional \f(CW%name\fR directives:
.PP
.Vb 7
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/eyapplanguageref$ sed \-ne \*(Aq8,26p\*(Aq treewithnames.pl
\&  my $grammar = q{
\&    %right  \*(Aq=\*(Aq     # Lowest precedence
\&    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&    %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&    %tree           # Let us build an abstract syntax tree ...
\&
\&    %%
\&    line: exp <%name EXPS + \*(Aq;\*(Aq>  { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&    ;
\&
\&    exp:
\&        %name NUM    NUM           | %name VAR   VAR         | %name ASSIGN VAR \*(Aq=\*(Aq exp
\&      | %name PLUS   exp \*(Aq+\*(Aq exp   | %name MINUS exp \*(Aq\-\*(Aq exp | %name TIMES  exp \*(Aq*\*(Aq exp
\&      | %name DIV    exp \*(Aq/\*(Aq exp
\&      | %name UMINUS \*(Aq\-\*(Aq exp %prec NEG
\&      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&    ;
.Ve
.PP
we are explicitly naming the productions. Thus, all the node instances 
corresponding to the production \f(CW\*(C`exp: VAR \*(Aq=\*(Aq exp\*(C'\fR will belong to the class \f(CW\*(C`ASSIGN\*(C'\fR. 
Now the tree for \f(CW\*(C`a=2*b\*(C'\fR becomes:
.PP
.Vb 1
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/eyapplanguageref$ ./treewithnames.pl
\&
\&  ************
\&  EXPS(ASSIGN(TERMINAL[a],TIMES(NUM(TERMINAL[2]),VAR(TERMINAL[b]))))
\&  ************
.Ve
.PP
Observe how the list has been named \f(CW\*(C`EXPS\*(C'\fR. The \f(CW%name\fR directive prefixes the 
list operator (\f(CW\*(C`[+*?]\*(C'\fR).
.SS "\s-1TERMINAL\s0 Nodes"
.IX Subsection "TERMINAL Nodes"
Nodes named \f(CW\*(C`TERMINAL\*(C'\fR are built from the tokens provided by the lexical
analyzer.  \f(CW\*(C`Parse::Eyapp\*(C'\fR follows the same protocol than Parse::Yapp for
communication between the parser and the lexical analyzer: A couple \f(CW\*(C`($token,
$attribute)\*(C'\fR is returned by the lexical analyzer.  These values are stored
under the keys \f(CW\*(C`token\*(C'\fR and \f(CW\*(C`attr\*(C'\fR.  \f(CW\*(C`TERMINAL\*(C'\fR nodes as all
\&\f(CW\*(C`Parse::Eyapp::Node\*(C'\fR nodes also have the attribute \f(CW\*(C`children\*(C'\fR but is \- almost
always \- empty.
.ie n .SS "Explicit Actions Inside %tree"
.el .SS "Explicit Actions Inside \f(CW%tree\fP"
.IX Subsection "Explicit Actions Inside %tree"
Explicit actions can be specified by the programmer like in this line
from the Parse::Eyapp \s-1SYNOPSIS\s0 example:
.PP
.Vb 1
\&      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }  /* Let us simplify a bit the tree */
.Ve
.PP
Explicit actions receive as arguments the references to the children nodes already 
built. The programmer can influence the shape of the tree by inserting
these explicit actions. In this example the programmer has decided to simplify the 
syntax tree: the nodes associated with the parenthesis are 
discarded and the reference to the subtree containing the proper
expression is returned. Such manoeuvre is called \fIbypassing\fR.
See section \*(L"The  bypass clause and the \f(CW%no\fR bypass directive\*(R"
to know more about \fIautomatic bypassing\fR
.ie n .SS "Explicitly Building Nodes With ""YYBuildAST"""
.el .SS "Explicitly Building Nodes With \f(CWYYBuildAST\fP"
.IX Subsection "Explicitly Building Nodes With YYBuildAST"
Sometimes the best time to decorate a node with some
attributes is just after being built.
In such cases the programmer can take \fImanual control\fR
building the node with \f(CW\*(C`YYBuildAST\*(C'\fR to 
inmediately proceed to decorate it.
.PP
The following example illustrates the situation (see
file \f(CW\*(C`lib/Simple/Types.eyp\*(C'\fR 
inside \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR):
.PP
.Vb 10
\&  $ sed \-n \*(Aq397,408p\*(Aq lib/Simple/Types.eyp
\&  Variable:
\&      %name VAR
\&      ID
\&    | %name  VARARRAY
\&      $ID (\*(Aq[\*(Aq binary \*(Aq]\*(Aq) <%name INDEXSPEC +>
\&        {
\&          my $self = shift;
\&          my $node =  $self\->YYBuildAST(@_);
\&          $node\->{line} = $ID\->[1];# $_[1]\->[1]
\&          return $node;
\&        }
\&  ;
.Ve
.PP
This production rule defines the expression to access an array element 
as an identifier followed by
a non empty list of binary expressions \f(CW\*(C` Variable: ID (\*(Aq[\*(Aq binary \*(Aq]\*(Aq)+\*(C'\fR. 
Furthermore, the node corresponding
to the list of indices has been named \f(CW\*(C`INDEXSPEC\*(C'\fR.
.PP
When no explicit action is
inserted a binary node will be built having as first child the node
corresponding to the identifier \f(CW$ID\fR and as second child the reference 
to the list of binary expressions. The children corresponding to
\&\f(CW\*(Aq[\*(Aq\fR and \f(CW\*(Aq]\*(Aq\fR are discarded since they are \-by default\- \fIsyntactic tokens\fR
(see section \*(L"Syntactic and Semantic tokens\*(R").
However, the programmer wants to decorate
the node being built with a \f(CW\*(C`line\*(C'\fR attribute holding the line number in the source
code where the identifier being used appears. The call to the \f(CW\*(C`Parse::Eyapp::Driver\*(C'\fR
method \f(CW\*(C`YYBuildAST\*(C'\fR does the job of building the node. After
that the node can be decorated and returned.
.PP
Actually, the \f(CW%tree\fR directive is semantically equivalent to:
.PP
.Vb 1
\&                %default action { goto &Parse::Eyapp::Driver::YYBuildAST }
.Ve
.ie n .SS "Returning non References Under %tree"
.el .SS "Returning non References Under \f(CW%tree\fP"
.IX Subsection "Returning non References Under %tree"
When a \fIexplicit user action returns s.t. that is not a reference
no node will be inserted\fR. This fact can be used to suppress nodes
in the \s-1AST\s0 being built. See the following example (file \f(CW\*(C`examples/returnnonode.yp\*(C'\fR):
.PP
.Vb 10
\&  $ sed \-ne \*(Aq1,17p\*(Aq returnnonode.yp | cat \-n
\&     1  %tree
\&     2  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq
\&     3  %%
\&     4  S:    %name EMPTY
\&     5          /* empty */
\&     6      | %name AES
\&     7          S A
\&     8      | %name BES
\&     9          S B
\&    10  ;
\&    11  A : %name A
\&    12        \*(Aqa\*(Aq
\&    13  ;
\&    14  B : %name B
\&    15        \*(Aqb\*(Aq { }
\&    16  ;
\&    17  %%
.Ve
.PP
since the action at line 15 returns \f(CW\*(C`undef\*(C'\fR
the \f(CW\*(C`B : \*(Aqb\*(Aq\*(C'\fR subtree will not be inserted in the \s-1AST:\s0
.PP
.Vb 3
\&  $ usereturnnonode.pl
\&  ababa
\&  AES(BES(AES(BES(AES(EMPTY,A(TERMINAL[a]))),A(TERMINAL[a]))),A(TERMINAL[a]))
.Ve
.PP
Observe the absence of \f(CW\*(C`B\*(C'\fRs and \f(CW\*(Aqb\*(Aq\fRs.
.ie n .SS "Intermediate actions and %tree"
.el .SS "Intermediate actions and \f(CW%tree\fP"
.IX Subsection "Intermediate actions and %tree"
Intermediate actions can be used to change the shape of the \s-1AST \s0(prune it,
decorate it, etc.) but the value returned by them is ignored. The grammar 
below has two intermediate actions. They modify the attributes of the
node to its left and return a reference \f(CW$f\fR to such node (lines 5 and 6):
.PP
.Vb 10
\&  $ sed \-ne \*(Aq1,15p\*(Aq intermediateactiontree.yp | cat \-n
\&     1  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq
\&     2  %tree bypass
\&     3  %%
\&     4  S:    %name EMPTY
\&     5         /* empty */
\&     6      | %name SA
\&     7         S A.f { $f\->{attr} = "A"; $f; } A
\&     8      | %name SB
\&     9         S B.f { $f\->{attr} = "B"; $f; } B
\&    10  ;
\&    11  A : %name A \*(Aqa\*(Aq
\&    12  ;
\&    13  B : %name B \*(Aqb\*(Aq
\&    14  ;
\&    15  %%
.Ve
.PP
See the client program:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n useintermediateactiontree.pl
\&  1  #!/usr/bin/perl \-w
\&  2  use strict;
\&  3  use Parse::Eyapp;
\&  4  use intermediateactiontree;
\&  5
\&  6  { no warnings;
\&  7  *A::info = *B::info = sub { $_[0]{attr} };
\&  8  }
\&  9
\& 10  my $parser = intermediateactiontree\->new();
\& 11  my $t = $parser\->Run;
\& 12  print $t\->str,"\en";
.Ve
.PP
When it runs produces this output:
.PP
.Vb 3
\&  $ useintermediateactiontree.pl
\&  aabbaa
\&  SA(SB(SA(EMPTY,A[A],A[a]),B[B],B[b]),A[A],A[a])
.Ve
.PP
The 
attributes 
of left \f(CW\*(C`A\*(C'\fRs 
have been effectively changed by the intermediate actions
from \f(CW\*(Aqa\*(Aq\fR to \f(CW\*(AqA\*(Aq\fR.
However no further children have been inserted.
.SS "Syntactic and Semantic tokens"
.IX Subsection "Syntactic and Semantic tokens"
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR differences between \f(CW\*(C`syntactic tokens\*(C'\fR
and \f(CW\*(C`semantic tokens\*(C'\fR. By default all tokens
declared using string notation (i.e. between quotes
like \f(CW\*(Aq+\*(Aq\fR, \f(CW\*(Aq=\*(Aq\fR)
are considered \fIsyntactic tokens\fR. Tokens declared by an identifier
(like \f(CW\*(C`NUM\*(C'\fR or \f(CW\*(C`VAR\*(C'\fR) are by default considered
\&\fIsemantic tokens\fR. \fBSyntactic tokens do not yield to nodes in the
syntactic tree\fR. Thus, the first print in the section Parse::Eyapp \s-1SYNOPSIS\s0 example:
.PP
.Vb 10
\&  $ cat \-n synopsis.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp;
\&     4  use Parse::Eyapp::Treeregexp;
\&     5
\&     6  sub TERMINAL::info {
\&     7    $_[0]{attr}
\&     8  }
\&     9
\&    10  my $grammar = q{
\&    11    %right  \*(Aq=\*(Aq     # Lowest precedence
\&    12    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&    13    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&    14    %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&    15    %tree           # Let us build an abstract syntax tree ...
\&    16
\&    17    %%
\&    18    line:
\&    19        exp <%name EXPRESSION_LIST + \*(Aq;\*(Aq>
\&    20          { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&    21    ;
\&    22
\&    23    /* The %name directive defines the name of the class */
\&    24    exp:
\&    25        %name NUM
\&    26        NUM
\&    27      | %name VAR
\&    28        VAR
\&    29      | %name ASSIGN
\&    30        VAR \*(Aq=\*(Aq exp
\&    31      | %name PLUS
\&    32        exp \*(Aq+\*(Aq exp
\&    33      | %name MINUS
\&    34        exp \*(Aq\-\*(Aq exp
\&    35      | %name TIMES
\&    36        exp \*(Aq*\*(Aq exp
\&    37      | %name DIV
\&    38        exp \*(Aq/\*(Aq exp
\&    39      | %name UMINUS
\&    40        \*(Aq\-\*(Aq exp %prec NEG
\&    41      | \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&    42          { $_[2] }  /* Let us simplify a bit the tree */
\&    43    ;
\&    44
\&    45    %%
\&    46    sub _Error { die "Syntax error near ".($_[0]\->YYCurval?$_[0]\->YYCurval:"end of file")."\en" }
\&    47
\&    48    sub _Lexer {
\&    49      my($parser)=shift; # The parser object
\&    50
\&    51      for ($parser\->YYData\->{INPUT}) { # Topicalize
\&    52        m{\eG\es+}gc;
\&    53        $_ eq \*(Aq\*(Aq and return(\*(Aq\*(Aq,undef);
\&    54        m{\eG([0\-9]+(?:\e.[0\-9]+)?)}gc and return(\*(AqNUM\*(Aq,$1);
\&    55        m{\eG([A\-Za\-z][A\-Za\-z0\-9_]*)}gc and return(\*(AqVAR\*(Aq,$1);
\&    56        m{\eG(.)}gcs and return($1,$1);
\&    57      }
\&    58      return(\*(Aq\*(Aq,undef);
\&    59    }
\&    60
\&    61    sub Run {
\&    62        my($self)=shift;
\&    63        $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error, );
\&    64    }
\&    65  }; # end grammar
\&    66
\&    67  our (@all, $uminus);
\&    68
\&    69  Parse::Eyapp\->new_grammar( # Create the parser package/class
\&    70    input=>$grammar,
\&    71    classname=>\*(AqCalc\*(Aq, # The name of the package containing the parser
\&    72    firstline=>7       # String $grammar starts at line 7 (for error diagnostics)
\&    73  );
\&    74  my $parser = Calc\->new();                # Create a parser
\&    75  $parser\->YYData\->{INPUT} = "2*\-3+b*0;\-\-2\en"; # Set the input
\&    76  my $t = $parser\->Run;                    # Parse it!
\&    77  local $Parse::Eyapp::Node::INDENT=2;
\&    78  print "Syntax Tree:",$t\->str;
\&    79
\&    80  # Let us transform the tree. Define the tree\-regular expressions ..
\&    81  my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&    82      { #  Example of support code
\&    83        my %Op = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&    84      }
\&    85      constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM($x), NUM($y))
\&    86        => {
\&    87          my $op = $Op{ref($bin)};
\&    88          $x\->{attr} = eval  "$x\->{attr} $op $y\->{attr}";
\&    89          $_[0] = $NUM[0];
\&    90        }
\&    91      uminus: UMINUS(NUM($x)) => { $x\->{attr} = \-$x\->{attr}; $_[0] = $NUM }
\&    92      zero_times_whatever: TIMES(NUM($x), .) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&    93      whatever_times_zero: TIMES(., NUM($x)) and { $x\->{attr} == 0 } => { $_[0] = $NUM }
\&    94    },
\&    95    OUTPUTFILE=> \*(Aqmain.pm\*(Aq
\&    96  );
\&    97  $p\->generate(); # Create the tranformations
\&    98
\&    99  $t\->s($uminus); # Transform UMINUS nodes
\&   100  $t\->s(@all);    # constant folding and mult. by zero
\&   101
\&   102  local $Parse::Eyapp::Node::INDENT=0;
\&   103  print "\enSyntax Tree after transformations:\en",$t\->str,"\en";
.Ve
.PP
gives as result the following output:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> synopsis.pl
\& Syntax Tree:
\& EXPRESSION_LIST(
\&   PLUS(
\&     TIMES(
\&       NUM(
\&         TERMINAL[2]
\&       ),
\&       UMINUS(
\&         NUM(
\&           TERMINAL[3]
\&         )
\&       ) # UMINUS
\&     ) # TIMES,
\&     TIMES(
\&       VAR(
\&         TERMINAL[b]
\&       ),
\&       NUM(
\&         TERMINAL[0]
\&       )
\&     ) # TIMES
\&   ) # PLUS,
\&   UMINUS(
\&     UMINUS(
\&       NUM(
\&         TERMINAL[2]
\&       )
\&     ) # UMINUS
\&   ) # UMINUS
\& ) # EXPRESSION_LIST
.Ve
.PP
\&\f(CW\*(C`TERMINAL\*(C'\fR nodes corresponding to tokens that were defined by strings like
\&\f(CW\*(Aq=\*(Aq\fR, \f(CW\*(Aq\-\*(Aq\fR, \f(CW\*(Aq+\*(Aq\fR, \f(CW\*(Aq/\*(Aq\fR, \f(CW\*(Aq*\*(Aq\fR, \f(CW\*(Aq(\*(Aq\fR and \f(CW\*(Aq)\*(Aq\fR  do not 
appear in the tree.  \f(CW\*(C`TERMINAL\*(C'\fR nodes corresponding to tokens that were defined
using an identifier, like \f(CW\*(C`NUM\*(C'\fR or \f(CW\*(C`VAR\*(C'\fR are, by default,  \fIsemantic tokens\fR
and appear in the \s-1AST.\s0
.SS "Changing the Status of a Token"
.IX Subsection "Changing the Status of a Token"
The new token declaration directives \f(CW\*(C`%syntactic token\*(C'\fR and
\&\f(CW\*(C`%semantic token\*(C'\fR can change the status of a token.
For example (file \f(CW\*(C`15treewithsyntactictoken.pl\*(C'\fR in the \f(CW\*(C`examples/\*(C'\fR directory), 
given the grammar:
.PP
.Vb 3
\&   %syntactic token b
\&   %semantic token \*(Aqa\*(Aq \*(Aqc\*(Aq
\&   %tree
\&
\&   %%
\&
\&   S: %name ABC
\&        A B C
\&    | %name BC
\&        B C
\&   ;
\&
\&   A: %name A
\&        \*(Aqa\*(Aq
\&   ;
\&
\&   B: %name B
\&        b
\&   ;
\&
\&   C: %name C
\&       \*(Aqc\*(Aq
\&   ;
\&   %%
.Ve
.PP
the tree build for input \f(CW\*(C`abc\*(C'\fR will be 
\&\f(CW\*(C`ABC(A(TERMINAL[a]),B,C(TERMINAL[c]))\*(C'\fR.
.SS "Saving the Information of Syntactic Tokens in their Father"
.IX Subsection "Saving the Information of Syntactic Tokens in their Father"
The reason for the adjective \f(CW%syntactic\fR applied to a token is to 
state that the token influences the shape of the syntax tree
but carries no other information. When the syntax tree is built
the node corresponding to the token is discarded.
.PP
Sometimes the difference between syntactic and semantic 
tokens is blurred. For example the line number associated
with an instance of the syntactic token \f(CW\*(Aq+\*(Aq\fR can be used later
\&\-say during type checking\- to emit a more accurate error
diagnostic. But if the node was discarded the information
about that line number is no longer available.
When building the syntax tree \f(CW\*(C`Parse::Eyapp\*(C'\fR (namely
the method \f(CW\*(C`Parse::Eyapp::YYBuildAST\*(C'\fR) checks 
if the method \f(CW\*(C`TERMINAL::save_attributes\*(C'\fR exists and if so
it will be called when dealing with a \fIsyntactic token\fR. 
The method receives as argument \- additionally
to the reference to the attribute of the token as it
is returned by the lexical analyzer \- a reference
to the node associated with the left hand side of the
production. Here is an example (file \f(CW\*(C`lib/Simple/Types.eyp\*(C'\fR
in \f(CW\*(C`examples/typechecking/Simple\-Types\-XXX.tar.gz\*(C'\fR)
of use:
.PP
.Vb 5
\&              sub TERMINAL::save_attributes {
\&                # $_[0] is a syntactic terminal
\&                # $_[1] is the father.
\&                push @{$_[1]\->{lines}}, $_[0]\->[1]; # save the line number
\&              }
.Ve
.ie n .SS "The  ""bypass"" clause and the ""%no bypass"" directive"
.el .SS "The  \f(CWbypass\fP clause and the \f(CW%no bypass\fP directive"
.IX Subsection "The bypass clause and the %no bypass directive"
The shape of the tree can be also modified using some \f(CW%tree\fR clauses
as \f(CW\*(C`%tree bypass\*(C'\fR which will produce an automatic \fIbypass\fR of any
node with only one child at tree-construction-time.
.PP
A \fIbypass operation\fR consists in \fIreturning the only child 
of the node being visited to the father of the node and re-typing (re-blessing)
the node in the name of the production\fR (if a name was provided).
.PP
A node may have only one child at tree-construction-time for one of
two reasons.
.IP "\(bu" 4
The first occurs when the right hand side of the production
was already unary like in:
.Sp
.Vb 2
\&                           exp:
\&                               %name NUM  NUM
.Ve
.Sp
Here \- if the \f(CW\*(C`bypass\*(C'\fR clause is used \- 
the \f(CW\*(C`NUM\*(C'\fR node will be bypassed and the child \f(CW\*(C`TERMINAL\*(C'\fR built
from the information provided by the lexical analyzer will be renamed/reblessed 
as \f(CW\*(C`NUM\*(C'\fR.
.IP "\(bu" 4
Another reason for a node to be \fIbypassed\fR is  the fact that though the right
hand side of the production may have more than one symbol, 
only one of them is not a syntactic token
like in:
.Sp
.Vb 1
\&                           exp: \*(Aq(\*(Aq exp \*(Aq)\*(Aq
.Ve
.PP
A consequence of the global scope application of \f(CW\*(C`%tree bypass\*(C'\fR
is that undesired bypasses may occur like in
.PP
.Vb 2
\&                           exp : %name UMINUS
\&                                 \*(Aq\-\*(Aq $exp %prec NEG
.Ve
.PP
though the right hand side has two symbols, token \f(CW\*(Aq\-\*(Aq\fR is
a syntactic token and therefore only \f(CW\*(C`exp\*(C'\fR is left. The \fIbypass\fR
operation will be applied when building this node.
This \fIbypass\fR can be avoided applying the \f(CW\*(C`no bypass ID\*(C'\fR directive to the corresponding 
production:
.PP
.Vb 2
\&                           exp : %no bypass UMINUS
\&                                 \*(Aq\-\*(Aq $exp %prec NEG
.Ve
.PP
The following example (file \f(CW\*(C`examples/bypass.pl\*(C'\fR) 
is the equivalent of the Parse::Eyapp \s-1SYNOPSIS\s0 example
but using the \f(CW\*(C`bypass\*(C'\fR clause instead:
.PP
.Vb 2
\& use Parse::Eyapp;
\& use Parse::Eyapp::Treeregexp;
\&
\& sub TERMINAL::info { $_[0]{attr} }
\& { no warnings; *VAR::info = *NUM::info = \e&TERMINAL::info; }
\&
\& my $grammar = q{
\&   %right  \*(Aq=\*(Aq     # Lowest precedence
\&   %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq 
\&   %left   \*(Aq*\*(Aq \*(Aq/\*(Aq 
\&   %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&   %tree bypass    # Let us build an abstract syntax tree ...
\&
\&   %%
\&   line: exp <%name EXPRESSION_LIST + \*(Aq;\*(Aq>  { $_[1] } 
\&   ;
\&
\&   exp:
\&       %name NUM  NUM            | %name VAR   VAR         | %name ASSIGN VAR \*(Aq=\*(Aq exp
\&     | %name PLUS exp \*(Aq+\*(Aq exp    | %name MINUS exp \*(Aq\-\*(Aq exp | %name TIMES  exp \*(Aq*\*(Aq exp
\&     | %name DIV     exp \*(Aq/\*(Aq exp
\&     | %no bypass UMINUS
\&       \*(Aq\-\*(Aq $exp %prec NEG
\&     |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&   ;
\&
\&   %%
\&   # sub _Error, _Lexer and Run like in the synopsis example
\&   # ...
\& }; # end grammar
\&
\& our (@all, $uminus);
\&
\& Parse::Eyapp\->new_grammar( # Create the parser package/class
\&   input=>$grammar,
\&   classname=>\*(AqCalc\*(Aq, # The name of the package containing the parser
\&   firstline=>7       # String $grammar starts at line 7 (for error diagnostics)
\& );
\& my $parser = Calc\->new();                # Create a parser
\& $parser\->YYData\->{INPUT} = "a=2*\-3+b*0\en"; # Set the input
\& my $t = $parser\->Run;                    # Parse it!
\&
\& print "\en************\en".$t\->str."\en************\en";
\&
\& # Let us transform the tree. Define the tree\-regular expressions ..
\& my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&   { #  Example of support code
\&     my %Op = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&   }
\&   constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM, NUM)
\&     => {
\&       my $op = $Op{ref($_[0])};
\&       $NUM[0]\->{attr} = eval  "$NUM[0]\->{attr} $op $NUM[1]\->{attr}";
\&       $_[0] = $NUM[0];
\&     }
\&   zero_times_whatever: TIMES(NUM, .) and { $NUM\->{attr} == 0 } => { $_[0] = $NUM }
\&   whatever_times_zero: TIMES(., NUM) and { $NUM\->{attr} == 0 } => { $_[0] = $NUM }
\&   uminus: UMINUS(NUM) => { $NUM\->{attr} = \-$NUM\->{attr}; $_[0] = $NUM }
\&   },
\&   OUTPUTFILE=> \*(Aqmain.pm\*(Aq
\& );
\& $p\->generate(); # Create the tranformations
\&
\& $t\->s(@all);    # constant folding and mult. by zero
\&
\& print $t\->str,"\en";
.Ve
.PP
when running this example with input \f(CW"a=2*\-3+b*0\en"\fR
we obtain the following output:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> bypass.pl
\&
\& ************
\& EXPRESSION_LIST(ASSIGN(TERMINAL[a],PLUS(TIMES(NUM[2],UMINUS(NUM[3])),TIMES(VAR[b],NUM[0]))))
\& ************
\& EXPRESSION_LIST(ASSIGN(TERMINAL[a],NUM[\-6]))
.Ve
.PP
As you can see the trees are more compact when using the \f(CW\*(C`bypass\*(C'\fR directive.
.ie n .SS "The ""alias"" clause of the %tree directive"
.el .SS "The \f(CWalias\fP clause of the \f(CW%tree\fP directive"
.IX Subsection "The alias clause of the %tree directive"
Access to children in Parse::Eyapp is made through the \f(CW\*(C`child\*(C'\fR and \f(CW\*(C`children\*(C'\fR
methods.
There are occasions however where access by name to the children may be preferable.
The use of the \f(CW\*(C`alias\*(C'\fR clause with the \f(CW%tree\fR directive creates accessors
to the children with names specified by the programmer. The \fIdot and dollar notations\fR
are used for this. When dealing with a production like:
.PP
.Vb 3
\&                       A: 
\&                          %name A_Node
\&                          Node B.bum N.pum $Chip
.Ve
.PP
methods \f(CW\*(C`bum\*(C'\fR, \f(CW\*(C`pum\*(C'\fR and \f(CW\*(C`Chip\*(C'\fR will be created for the class \f(CW\*(C`A_Node\*(C'\fR.
Those methods will provide access to the respective child (first, second and third in
the example). The methods are build at compile-time and therefore later 
transformations of the \s-1AST\s0 modifying the order of the children may 
invalidate the use of these getter-setters.
.PP
The \f(CW%prefix\fR directive used in line 7 of the following example
is equivalent to the use of the \f(CW\*(C`yyprefix\*(C'\fR. The node classes are prefixed
with the specified prefix: \f(CW\*(C`R::S::\*(C'\fR in this example.
.PP
.Vb 10
\& cat \-n alias_and_yyprefix.pl
\&     1  #!/usr/local/bin/perl
\&     2  use warnings;
\&     3  use strict;
\&     4  use Parse::Eyapp;
\&     5
\&     6  my $grammar = q{
\&     7    %prefix R::S::
\&     8
\&     9    %right  \*(Aq=\*(Aq
\&    10    %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    11    %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    12    %left   NEG
\&    13    %tree bypass alias
\&    14
\&    15    %%
\&    16    line: $exp  { $_[1] }
\&    17    ;
\&    18
\&    19    exp:
\&    20        %name NUM
\&    21              $NUM
\&    22      | %name VAR
\&    23              $VAR
\&    24      | %name ASSIGN
\&    25              $VAR \*(Aq=\*(Aq $exp
\&    26      | %name PLUS
\&    27              exp.left \*(Aq+\*(Aq exp.right
\&    28      | %name MINUS
\&    29              exp.left \*(Aq\-\*(Aq exp.right
\&    30      | %name TIMES
\&    31              exp.left \*(Aq*\*(Aq exp.right
\&    32      | %name DIV
\&    33              exp.left \*(Aq/\*(Aq exp.right
\&    34      | %no bypass UMINUS
\&    35              \*(Aq\-\*(Aq $exp %prec NEG
\&    36      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    37    ;
\&    38
\&    39    %%
\&    ..    ....
\&    76  }; # end grammar
\&    77
\&    78
\&    79  Parse::Eyapp\->new_grammar(
\&    80    input=>$grammar,
\&    81    classname=>\*(AqAlias\*(Aq,
\&    82    firstline =>7,
\&    83    outputfile => \*(Aqmain\*(Aq,
\&    84  );
\&    85  my $parser = Alias\->new();
\&    86  $parser\->YYData\->{INPUT} = "a = \-(2*3+5\-1)\en";
\&    87  my $t = $parser\->Run;
\&    88  $Parse::Eyapp::Node::INDENT=0;
\&    89  print $t\->VAR\->str."\en";             # a
\&    90  print "***************\en";
\&    91  print $t\->exp\->exp\->left\->str."\en";  # 2*3+5
\&    92  print "***************\en";
\&    93  print $t\->exp\->exp\->right\->str."\en"; # 1
.Ve
.PP
The tree \f(CW$t\fR for the expression \f(CW"a = \-(2*3+5\-1)\en"\fR is:
.PP
.Vb 9
\&  R::S::ASSIGN(
\&     R::S::TERMINAL,
\&     R::S::UMINUS(
\&       R::S::MINUS(
\&         R::S::PLUS(R::S::TIMES(R::S::NUM,R::S::NUM),R::S::NUM),
\&         R::S::NUM
\&       )
\&     )
\&  )
.Ve
.PP
The \f(CW\*(C`R::S::ASSIGN\*(C'\fR class has methods \f(CW\*(C`VAR\*(C'\fR (see line 89 above)
and \f(CW\*(C`exp\*(C'\fR (see lines 91 and 93) to refer to its two children. 
The result of the execution is:
.PP
.Vb 6
\&  $ alias_and_yyprefix.pl
\&  R::S::TERMINAL
\&  ***************
\&  R::S::PLUS(R::S::TIMES(R::S::NUM,R::S::NUM),R::S::NUM)
\&  ***************
\&  R::S::NUM
.Ve
.PP
As a second example of the use of \f(CW%alias\fR, the \s-1CPAN\s0 module Language::AttributeGrammar provides
\&\s-1AST\s0 decorators from an attribute grammar specification of the \s-1AST.\s0
To work  Language::AttributeGrammar requires named access to the children
of the \s-1AST\s0 nodes. Follows an example (file \f(CW\*(C`examples/CalcwithAttributeGrammar.pl\*(C'\fR)
of a small calculator:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n CalcwithAttributeGrammar.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp;
\&     4  use Data::Dumper;
\&     5  use Language::AttributeGrammar;
\&     6
\&     7  my $grammar = q{
\&     8  %{
\&     9  # use Data::Dumper;
\&    10  %}
\&    11  %right  \*(Aq=\*(Aq
\&    12  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    13  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    14  %left   NEG
\&    15  %tree bypass alias
\&    16
\&    17  %%
\&    18  line: $exp  { $_[1] }
\&    19  ;
\&    20
\&    21  exp:
\&    22      %name NUM
\&    23            $NUM
\&    24          | %name VAR
\&    25            $VAR
\&    26          | %name ASSIGN
\&    27            $VAR \*(Aq=\*(Aq $exp
\&    28          | %name PLUS
\&    29            exp.left \*(Aq+\*(Aq exp.right
\&    30          | %name MINUS
\&    31            exp.left \*(Aq\-\*(Aq exp.right
\&    32          | %name TIMES
\&    33            exp.left \*(Aq*\*(Aq exp.right
\&    34          | %name DIV
\&    35            exp.left \*(Aq/\*(Aq exp.right
\&    36          | %no bypass UMINUS
\&    37            \*(Aq\-\*(Aq $exp %prec NEG
\&    38    |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    39  ;
\&    40
\&    41  %%
\&    42
\&    43  sub _Error {
\&    44          exists $_[0]\->YYData\->{ERRMSG}
\&    45      and do {
\&    46          print $_[0]\->YYData\->{ERRMSG};
\&    47          delete $_[0]\->YYData\->{ERRMSG};
\&    48          return;
\&    49      };
\&    50      print "Syntax error.\en";
\&    51  }
\&    52
\&    53  sub _Lexer {
\&    54      my($parser)=shift;
\&    55
\&    56          $parser\->YYData\->{INPUT}
\&    57      or  $parser\->YYData\->{INPUT} = <STDIN>
\&    58      or  return(\*(Aq\*(Aq,undef);
\&    59
\&    60      $parser\->YYData\->{INPUT}=~s/^\es+//;
\&    61
\&    62      for ($parser\->YYData\->{INPUT}) {
\&    63          s/^([0\-9]+(?:\e.[0\-9]+)?)//
\&    64                  and return(\*(AqNUM\*(Aq,$1);
\&    65          s/^([A\-Za\-z][A\-Za\-z0\-9_]*)//
\&    66                  and return(\*(AqVAR\*(Aq,$1);
\&    67          s/^(.)//s
\&    68                  and return($1,$1);
\&    69      }
\&    70  }
\&    71
\&    72  sub Run {
\&    73      my($self)=shift;
\&    74      $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&    75                      #yydebug =>0xFF
\&    76                    );
\&    77  }
\&    78  }; # end grammar
\&    79
\&    80
\&    81  $Data::Dumper::Indent = 1;
\&    82  Parse::Eyapp\->new_grammar(
\&    83    input=>$grammar,
\&    84    classname=>\*(AqRule6\*(Aq,
\&    85    firstline =>7,
\&    86    outputfile => \*(AqCalc.pm\*(Aq,
\&    87  );
\&    88  my $parser = Rule6\->new();
\&    89  $parser\->YYData\->{INPUT} = "a = \-(2*3+5\-1)\en";
\&    90  my $t = $parser\->Run;
\&    91  print "\en***** Before ******\en";
\&    92  print Dumper($t);
\&    93
\&    94  my $attgram = new Language::AttributeGrammar <<\*(AqEOG\*(Aq;
\&    95
\&    96  # Compute the expression
\&    97  NUM:    $/.val = { $<attr> }
\&    98  TIMES:  $/.val = { $<left>.val * $<right>.val }
\&    99  PLUS:   $/.val = { $<left>.val + $<right>.val }
\&   100  MINUS:  $/.val = { $<left>.val \- $<right>.val }
\&   101  UMINUS: $/.val = { \-$<exp>.val }
\&   102  ASSIGN: $/.val = { $<exp>.val }
\&   103  EOG
\&   104
\&   105  my $res = $attgram\->apply($t, \*(Aqval\*(Aq);
\&   106
\&   107  $Data::Dumper::Indent = 1;
\&   108  print "\en***** After ******\en";
\&   109  print Dumper($t);
\&   110  print Dumper($res);
\&
\& CalcwithAttributeGrammar.pl
.Ve
.PP
The program computes the tree for expression for expression
\&\f(CW\*(C`a = \-(2*3+5\-1)\*(C'\fR which is:
.PP
.Vb 1
\&  ASSIGN(TERMINAL,UMINUS(MINUS(PLUS(TIMES(NUM,NUM),NUM),NUM)))
.Ve
.PP
The children of the binary nodes can be accessed through the \f(CW\*(C`left\*(C'\fR
and \f(CW\*(C`right\*(C'\fR methods.
.SS "About the Encapsulation of Nodes"
.IX Subsection "About the Encapsulation of Nodes"
There is no encapsulation of nodes. The user/client 
knows that they are hashes that can be decorated with new keys/attributes.
All nodes in the \s-1AST\s0 created by \f(CW%tree\fR are \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR nodes.
The only reserved field is \f(CW\*(C`children\*(C'\fR which is a reference to the
array of children. You can always create a \f(CW\*(C`Node\*(C'\fR class 
\&\fIby hand\fR by inheriting from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR.
.SH "SOLVING CONFLICTS WITH THE \fIPOSTPONED CONFLICT\fP STRATEGY"
.IX Header "SOLVING CONFLICTS WITH THE POSTPONED CONFLICT STRATEGY"
Yacc-like parser generators provide ways to solve shift-reduce mechanims
based on token precedence. No mechanisms are provided for the resolution
of reduce-reduce conflicts. The solution for such kind of conflicts is to modify
the grammar. The strategy We present here provides a way to broach conflicts
that can't be solved using static precedences.
.SS "The \fIPostponed Conflict Resolution\fP Strategy"
.IX Subsection "The Postponed Conflict Resolution Strategy"
The \fIpostponed conflict strategy\fR presented here can be used whenever there 
is a shift-reduce or reduce-reduce conflict that can not be solved using static 
precedences.
.SS "\fIPostponed Conflict Resolution\fP: Reduce-Reduce Conflicts"
.IX Subsection "Postponed Conflict Resolution: Reduce-Reduce Conflicts"
Let us assume we have a reduce-reduce conflict between to productions
.PP
.Vb 2
\&                      A \-> alpha .
\&                      B \-> beta .
.Ve
.PP
for some token \f(CW\*(C`@\*(C'\fR. Let also assume that production
.PP
.Vb 1
\&                      A \-> alpha
.Ve
.PP
has name \f(CW\*(C`ruleA\*(C'\fR and production
.PP
.Vb 1
\&                      B \-> beta
.Ve
.PP
has name \f(CW\*(C`ruleB\*(C'\fR.
.PP
The postponed conflict resolution strategy consists
in modifying the conflictive grammar by marking the points where the  conflict occurs
with the new \f(CW%PREC\fR directive. In this case at then end of the involved productions:
.PP
.Vb 2
\&                      A \-> alpha %PREC IsAorB 
\&                      B \-> beta  $PREC IsAorB
.Ve
.PP
The \f(CW\*(C`IsAorB\*(C'\fR identifier is called the \fIconflict name\fR.
.PP
Inside the head section, the programmer associates with the 
conflict name a code
whose mission is to solve the conflict by dynamically changing the
parsing table like this:
.PP
.Vb 2
\&                     %conflict IsAorB {
\&                          my $self = shift;
\&
\&                          if (looks_like_A($self)) {
\&                            $self\->YYSetReduce(\*(Aq@\*(Aq, \*(AqruleA\*(Aq );
\&                          }
\&                          else {
\&                            $self\->YYSetReduce(\*(Aq@\*(Aq, \*(AqruleB\*(Aq );
\&                          }
\&                       }
.Ve
.PP
The code associated with the \fIconflict name\fR
receives the name of \fI conflict handler\fR.
The code of \f(CW\*(C`looks_like_A\*(C'\fR stands for some form of nested parsing
which will decide which production applies.
.SS "Solving the Enumerated versus Range declarations conflict using the Posponed Conflict Resolution Strategy"
.IX Subsection "Solving the Enumerated versus Range declarations conflict using the Posponed Conflict Resolution Strategy"
In file \f(CW\*(C`pascalenumeratedvsrangesolvedviadyn.eyp\*(C'\fR we apply the postponed conflict resolution strategy
to the reduce reduce conflict that arises in Extended Pascal between the declaration of ranges and
the declaration of enumerated types (see section \*(L"Reduce-Reduce conflict: Enumerated versus Range declarations in Extended Pascal\*(R").
Here is the solution:
.PP
.Vb 10
\&  ~/LEyapp/examples/debuggingtut$ cat \-n pascalenumeratedvsrangesolvedviadyn.eyp
\&     1  %{
\&     2  =head1 SYNOPSIS
\&     3  
\&     4  See 
\&     5  
\&     6  =over 2
\&     7  
\&     8  =item * File pascalenumeratedvsrange.eyp in examples/debuggintut/
\&     9  
\&    10  =item * The Bison manual L<http://www.gnu.org/software/bison/manual/html_mono/bison.html>
\&    11  
\&    12  =back
\&    13  
\&    14  Compile it with:
\&    15  
\&    16              eyapp \-b \*(Aq\*(Aq pascalenumeratedvsrangesolvedviadyn.eyp
\&    17  
\&    18  run it with this options:
\&    19  
\&    20              ./pascalenumeratedvsrangesolvedviadyn.pm \-t
\&    21  
\&    22  Try these inputs:
\&    23  
\&    24                  type r = (x) ..  y ;
\&    25                  type r = (x+2)*3 ..  y/2 ;
\&    26                  type e = (x, y, z);
\&    27                  type e = (x);
\&    28  
\&    29  =cut
\&    30  
\&    31  use base q{DebugTail}; 
\&    32  
\&    33  my $ID = qr{[A\-Za\-z][A\-Za\-z0\-9_]*};
\&    34               # Identifiers separated by commas
\&    35  my $IDLIST = qr{ \es*(?:\es*,\es* $ID)* \es* }x;
\&    36               # list followed by a closing par and a semicolon 
\&    37  my $RESTOFLIST = qr{$IDLIST \e) \es* ; }x;
\&    38  %}
\&    39  
\&    40  %namingscheme {
\&    41    #Receives a Parse::Eyapp object describing the grammar
\&    42    my $self = shift;
\&    43  
\&    44    $self\->tokennames(
\&    45      \*(Aq(\*(Aq => \*(AqLP\*(Aq,
\&    46      \*(Aq..\*(Aq => \*(AqDOTDOT\*(Aq,
\&    47      \*(Aq,\*(Aq => \*(AqCOMMA\*(Aq,
\&    48      \*(Aq)\*(Aq => \*(AqRP\*(Aq,
\&    49      \*(Aq+\*(Aq => \*(AqPLUS\*(Aq,
\&    50      \*(Aq\-\*(Aq => \*(AqMINUS\*(Aq,
\&    51      \*(Aq*\*(Aq => \*(AqTIMES\*(Aq,
\&    52      \*(Aq/\*(Aq => \*(AqDIV\*(Aq,
\&    53    );
\&    54  
\&    55    # returns the handler that will give names
\&    56    # to the right hand sides
\&    57    \e&give_rhs_name;
\&    58  }
\&    59  
\&    60  %strict
\&    61  
\&    62  %token ID NUM DOTDOT TYPE
\&    63  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    64  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    65  
\&    66  %tree
\&    67  
\&    68  %%
\&    69  
\&    70  type_decl : TYPE ID \*(Aq=\*(Aq type \*(Aq;\*(Aq
\&    71  ;
\&    72  
\&    73  type : 
\&    74        %name ENUM
\&    75        \*(Aq(\*(Aq id_list \*(Aq)\*(Aq
\&    76      | %name RANGE
\&    77        expr DOTDOT expr
\&    78  ;
\&    79  
\&    80  id_list : 
\&    81        %name EnumID
\&    82        ID rangeORenum
\&    83      | id_list \*(Aq,\*(Aq ID
\&    84  ;
\&    85  
\&    86  expr : \*(Aq(\*(Aq expr \*(Aq)\*(Aq
\&    87      | expr \*(Aq+\*(Aq expr
\&    88      | expr \*(Aq\-\*(Aq expr
\&    89      | expr \*(Aq*\*(Aq expr
\&    90      | expr \*(Aq/\*(Aq expr
\&    91      | %name RangeID
\&    92        ID rangeORenum
\&    93      | NUM
\&    94  ;
\&    95  
\&    96  rangeORenum: /* empty: postponed conflict resolution */
\&    97        {
\&    98            my $parser = shift;
\&    99            if (${$parser\->input()} =~ m{\eG(?= $RESTOFLIST)}gcx) {
\&   100                $parser\->YYSetReduce(\*(Aq)\*(Aq, \*(AqEnumID\*(Aq );
\&   101              }
\&   102              else {
\&   103                $parser\->YYSetReduce(\*(Aq)\*(Aq, \*(AqRangeID\*(Aq );
\&   104              }
\&   105        }
\&   106  ;
\&   107  
\&   108  %%
\&   109  
\&   110  _\|_PACKAGE_\|_\->lexer(
\&   111    sub {
\&   112      my $parser = shift;
\&   113  
\&   114      for (${$parser\->input()}) {    # contextualize
\&   115        m{\eG(\es*)}gc;
\&   116        $parser\->tokenline($1 =~ tr{\en}{});
\&   117  
\&   118        m{\eGtype\eb}gic                 and return (\*(AqTYPE\*(Aq, \*(AqTYPE\*(Aq);
\&   119  
\&   120        m{\eG($ID)}gc                   and return (\*(AqID\*(Aq,  $1);
\&   121  
\&   122        m{\eG([0\-9]+)}gc                and return (\*(AqNUM\*(Aq, $1);
\&   123  
\&   124        m{\eG\e.\e.}gc                    and return (\*(AqDOTDOT\*(Aq,  \*(Aq..\*(Aq);
\&   125  
\&   126        m{\eG(.)}gc                     and return ($1,    $1);
\&   127  
\&   128        return(\*(Aq\*(Aq,undef);
\&   129      }
\&   130    }
\&   131  );
\&   132  
\&   133  unless (caller()) {
\&   134    $Parse::Eyapp::Node::INDENT = 1;
\&   135    my $prompt = << \*(AqEOP\*(Aq;
\&   136  Try this input:
\&   137      type 
\&   138      r
\&   139      =
\&   140      (x)
\&   141      ..
\&   142      y
\&   143      ;
\&   144  
\&   145  Here other inputs you can try:
\&   146  
\&   147      type r = (x+2)*3 ..  y/2 ;
\&   148      type e = (x, y, z);
\&   149      type e = (x);
\&   150  
\&   151  Press CTRL\-D (CTRL\-W in windows) to produce the end\-of\-file
\&   152  EOP
\&   153    _\|_PACKAGE_\|_\->main($prompt); 
\&   154  }
.Ve
.PP
This example also illustrates how to modify the default production
naming schema. Follows the result of several executions:
.PP
.Vb 9
\&  ~/LEyapp/examples/debuggingtut$ ./pascalenumeratedvsrangesolvedviadyn.pm \-t
\&  Try this input:
\&      type 
\&      r
\&      =
\&      (x)
\&      ..
\&      y
\&      ;
\&
\&  Here other inputs you can try:
\&
\&      type r = (x+2)*3 ..  y/2 ;
\&      type e = (x, y, z);
\&      type e = (x);
\&
\&  Press CTRL\-D (CTRL\-W in windows) to produce the end\-of\-file
\&  type r = (x+2)*3 ..  y/2 ;
\&  ^D
\&  type_decl_is_TYPE_ID_type(
\&    TERMINAL[TYPE],
\&    TERMINAL[r],
\&    RANGE(
\&      expr_is_expr_TIMES_expr(
\&        expr_is_LP_expr_RP(
\&          expr_is_expr_PLUS_expr(
\&            RangeID(
\&              TERMINAL[x]
\&            ),
\&            expr_is_NUM(
\&              TERMINAL[2]
\&            )
\&          )
\&        ),
\&        expr_is_NUM(
\&          TERMINAL[3]
\&        )
\&      ),
\&      TERMINAL[..],
\&      expr_is_expr_DIV_expr(
\&        RangeID(
\&          TERMINAL[y]
\&        ),
\&        expr_is_NUM(
\&          TERMINAL[2]
\&        )
\&      )
\&    )
\&  )
\&  ~/LEyapp/examples/debuggingtut$ ./pascalenumeratedvsrangesolvedviadyn.pm \-t
\&  Try this input:
\&      type 
\&      r
\&      =
\&      (x)
\&      ..
\&      y
\&      ;
\&
\&  Here other inputs you can try:
\&
\&      type r = (x+2)*3 ..  y/2 ;
\&      type e = (x, y, z);
\&      type e = (x);
\&
\&  Press CTRL\-D (CTRL\-W in windows) to produce the end\-of\-file
\&  type e = (x);
\&  ^D
\&  type_decl_is_TYPE_ID_type(
\&    TERMINAL[TYPE],
\&    TERMINAL[e],
\&    ENUM(
\&      EnumID(
\&        TERMINAL[x]
\&      )
\&    )
\&  )
.Ve
.SS "\fIPostponed Conflict Resolution\fP: Shift-Reduce Conflicts"
.IX Subsection "Postponed Conflict Resolution: Shift-Reduce Conflicts"
The program in \f(CW\*(C`examples/debuggingtut/DynamicallyChangingTheParser2.eyp\*(C'\fR illustrates how the postponed
conflict strategy is used for shift-reduce conflicts.
This is an extension of the grammar in \f(CW\*(C`examples/debuggingtut/Debug.eyp\*(C'\fR.
The generated language is constituted by sequences like:
.PP
.Vb 1
\&    { D; D; S; S; S; } {D; S} { S }
.Ve
.PP
As you remember the conflict was:
.PP
.Vb 2
\&  ~/LEyapp/examples/debuggingtut$ sed \-ne \*(Aq/^St.*13:/,/^St.*14/p\*(Aq DynamicallyChangingTheParser.output  
\&  State 13:
\&
\&      ds \-> D conflict . \*(Aq;\*(Aq ds   (Rule 6)
\&      ds \-> D conflict .  (Rule 7)
\&
\&      \*(Aq;\*(Aq shift, and go to state 16
\&
\&      \*(Aq;\*(Aq [reduce using rule 7 (ds)]
\&
\&  State 14:
.Ve
.PP
The \f(CW\*(C`conflict\*(C'\fR handler below sets the \s-1LR\s0 action
to reduce by the production with name \f(CW\*(C`D1\*(C'\fR
.PP
.Vb 1
\&                 ds \-> D
.Ve
.PP
in the presence of token \f(CW\*(Aq;\*(Aq\fR if indeed is the last \f(CW\*(AqD\*(Aq\fR, that is, if:
.PP
.Vb 1
\&       ${$self\->input()} =~ m{^\es*;\es*S}
.Ve
.PP
Otherwise we set the \f(CW\*(C`shift\*(C'\fR action via a call to the 
\&\f(CW\*(C`YYSetShift\*(C'\fR method.
.PP
.Vb 10
\&  ~/LEyapp/examples/debuggingtut$ sed \-ne \*(Aq30,$p\*(Aq DynamicallyChangingTheParser.eyp | cat \-n
\&     1  %token D S
\&     2  
\&     3  %tree bypass
\&     4  
\&     5  # Expect just 1 shift\-reduce conflict
\&     6  %expect 1 
\&     7  
\&     8  %%
\&     9  p: %name PROG
\&    10      block +
\&    11  ;
\&    12  
\&    13  block:
\&    14      %name BLOCK_DS
\&    15      \*(Aq{\*(Aq ds \*(Aq;\*(Aq ss \*(Aq}\*(Aq 
\&    16    | %name BLOCK_S
\&    17      \*(Aq{\*(Aq ss \*(Aq}\*(Aq
\&    18  ;
\&    19  
\&    20  ds:
\&    21      %name D2
\&    22      D conflict \*(Aq;\*(Aq ds    
\&    23    | %name D1
\&    24      D conflict        
\&    25  ;
\&    26  
\&    27  ss:
\&    28      %name S2
\&    29      S \*(Aq;\*(Aq ss      
\&    30    | %name S1
\&    31      S       
\&    32  ;
\&    33  
\&    34  conflict:
\&    35        /* empty. This action solves the conflict using dynamic precedence */
\&    36        {
\&    37          my $self = shift;
\&    38  
\&    39          if (${$self\->input()} =~ m{^\es*;\es*S}) {
\&    40            $self\->YYSetReduce(\*(Aq;\*(Aq, \*(AqD1\*(Aq )
\&    41          }
\&    42          else {
\&    43            $self\->YYSetShift(\*(Aq;\*(Aq)
\&    44          }
\&    45  
\&    46          undef; # skip this node in the AST
\&    47        }
\&    48  ;
\&    49  
\&    50  %%
\&    51  
\&    52  my $prompt = \*(AqProvide a statement like "{D; S} {D; D; S}" and press <CR><CTRL\-D>: \*(Aq;
\&    53  _\|_PACKAGE_\|_\->main($prompt) unless caller;
.Ve
.SH "NAMING SCHEMES"
.IX Header "NAMING SCHEMES"
Explicit names can be given to grammar productions
via the \f(CW%name\fR directive. An alternative to explicitly gave 
names to rules is to define a \fInaming scheme\fR via the Eyapp directive
\&\f(CW%namingscheme\fR. This can be helpful when you inherit a large grammar
and want to quickly build a parser. The \s-1ANSI C\s0 parser in 
\&\f(CW\*(C`examples/languages/C/ansic.eyp\*(C'\fR is a good example. Another
example is the Pascal parser in \f(CW\*(C`examples/languages/pascal/pascal.eyp\*(C'\fR.
.PP
The Eyapp directive \f(CW%namingscheme\fR is followed by some Perl code. Such Perl
code must return a reference to a subroutine that will be called each time a new
production right hand side is parsed. The subroutine returns the name for the production.
.PP
The Perl code defining the handler receives a \f(CW\*(C`Parse::Eyapp\*(C'\fR object
that describes the grammar. The code after the \f(CW%namingscheme\fR
directive is evaluated during the early phases of the compilation of the input 
grammar. As an example of how to set a naming scheme, 
see lines 22\-38 below (you can find this example and others in the directory
\&\f(CW\*(C`examples/naming\*(C'\fR of the accompanying distribution):
.PP
.Vb 10
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/naming$ cat \-n GiveNamesToCalc.eyp
\&     1  # GiveNamesToCalc.eyp
\&     2  %right  \*(Aq=\*(Aq
\&     3  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&     4  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&     5  %left   NEG
\&     6  %right  \*(Aq^\*(Aq
\&     7
\&     8  %tree bypass
\&     9
\&    10  %{
\&    11  use base q{Tail};
\&    12
\&    13  sub exp_is_NUM::info {
\&    14    my $self = shift;
\&    15
\&    16    $self\->{attr}[0];
\&    17  }
\&    18
\&    19  *exp_is_VAR::info = *var_is_VAR::info = \e&exp_is_NUM::info;
\&    20  %}
\&    21
\&    22  %namingscheme {
\&    23    #Receives a Parse::Eyapp object describing the grammar
\&    24    my $self = shift;
\&    25
\&    26    $self\->tokennames(
\&    27      \*(Aq=\*(Aq => \*(AqASSIGN\*(Aq,
\&    28      \*(Aq+\*(Aq => \*(AqPLUS\*(Aq,
\&    29      \*(Aq*\*(Aq => \*(AqTIMES\*(Aq,
\&    30      \*(Aq\-\*(Aq => \*(AqMINUS\*(Aq,
\&    31      \*(Aq/\*(Aq => \*(AqDIV\*(Aq,
\&    32      \*(Aq^\*(Aq => \*(AqEXP\*(Aq,
\&    33    );
\&    34
\&    35    # returns the handler that will give names
\&    36    # to the right hand sides
\&    37    \e&give_token_name;
\&    38  }
\&    39  %%
\&    40
\&    41  line:
\&    42      exp
\&    43  ;
\&    44
\&    45  exp:
\&    46      NUM
\&    47    | VAR
\&    48    | var \*(Aq=\*(Aq exp
\&    49    | exp \*(Aq+\*(Aq exp
\&    50    | exp \*(Aq\-\*(Aq exp
\&    51    | exp \*(Aq*\*(Aq exp
\&    52    | exp \*(Aq/\*(Aq exp
\&    53    | %no bypass exp_is_NEG
\&    54       \*(Aq\-\*(Aq exp %prec NEG
\&    55    | exp \*(Aq^\*(Aq exp
\&    56    | \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&    57  ;
\&    58
\&    59  var:
\&    60      VAR
\&    61  ;
\&    62  %%
\&    63
\&    64  unless (caller) {
\&    65    my $t = _\|_PACKAGE_\|_\->main(@ARGV);
\&    66    print $t\->str."\en";
\&    67  }
.Ve
.PP
The example uses a naming scheme that is provided by \f(CW\*(C`Parse::Eyapp\*(C'\fR: \f(CW\*(C`Parse::Eyapp::Grammar::give_token_name\*(C'\fR.
The current provided naming schemes handlers are:
.IP "\(bu" 2
\&\f(CW\*(C`give_default_name\*(C'\fR: The name of the production is the name of the Left Hand Side of the Production Rule
concatenated with an underscore and the index of the production
.IP "\(bu" 2
\&\f(CW\*(C`give_lhs_name\*(C'\fR: The name of the production is the name of the Left Hand Side of the Production Rule (this
is the naming scheme used by the \f(CW%tree\fR directive when no explicit name was given)
.IP "\(bu" 2
\&\f(CW\*(C`give_token_name\*(C'\fR: The name of the production is the Left Hand Side of the Production Rule followed by the 
word \f(CW\*(C`_is_\*(C'\fR followed by the concatenation of the names of the tokens in the right and side (separated by underscores).
.PP
All of these handlers are implemented inside the class \f(CW\*(C`Parse::Eyapp::Grammar\*(C'\fR. There is no need at line 
37 to explicit the class name prefix since the naming scheme code is evaluated inside such class:
.PP
.Vb 10
\&    22  %namingscheme {
\&    23    #Receives a Parse::Eyapp object describing the grammar
\&    24    my $self = shift;
\&    25
\&    26    $self\->tokennames(
\&    27      \*(Aq=\*(Aq => \*(AqASSIGN\*(Aq,
\&    28      \*(Aq+\*(Aq => \*(AqPLUS\*(Aq,
\&    29      \*(Aq*\*(Aq => \*(AqTIMES\*(Aq,
\&    30      \*(Aq\-\*(Aq => \*(AqMINUS\*(Aq,
\&    31      \*(Aq/\*(Aq => \*(AqDIV\*(Aq,
\&    32      \*(Aq^\*(Aq => \*(AqEXP\*(Aq,
\&    33    );
\&    34
\&    35    # returns the handler that will give names
\&    36    # to the right hand sides
\&    37    \e&give_token_name;
\&    38  }
.Ve
.PP
As it is illustrated in this example, the method \f(CW\*(C`tokennames\*(C'\fR of \f(CW\*(C`Parse::Eyapp\*(C'\fR
objects provide a way to give identifier names to tokens that are defined by strings.
When we execute the former module/program (modulino) with input \f(CW\*(C`a=2*\-3\*(C'\fR we got the following
output:
.PP
.Vb 5
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/naming$ eyapp \-b \*(Aq\*(Aq GiveNamesToCalc.eyp
\&  lusasoft@LusaSoft:~/src/perl/Eyapp/examples/naming$ ./GiveNamesToCalc.pm
\&  Expressions. Press CTRL\-D (Unix) or CTRL\-Z (Windows) to finish:
\&  a=2*\-3
\&  line_is_exp(var_is_VAR[a],exp_is_TIMES(exp_is_NUM[2],exp_is_NEG(exp_is_NUM[3])))
.Ve
.PP
For each production rule the handler is called with arguments:
.IP "\(bu" 2
the \f(CW\*(C`Parse::Eyapp\*(C'\fR object,
.IP "\(bu" 2
the production index (inside the grammar),
.IP "\(bu" 2
the left hand side
symbol and a reference to a list with the symbols in the right hand side.
.PP
The following code of some version of \f(CW\*(C`give_token_name\*(C'\fR exemplifies how a
naming scheme handler can be written:
.PP
.Vb 10
\&  lusasoft@LusaSoft:~/src/perl/Eyapp$ sed \-ne \*(Aq101,132p\*(Aq lib/Parse/Eyapp/Grammar.pm | cat \-n
\&     1  sub give_token_name {
\&     2    my ($self, $index, $lhs, $rhs) = @_;
\&     3
\&     4    my @rhs = @$rhs;
\&     5    $rhs = \*(Aq\*(Aq;
\&     6
\&     7    unless (@rhs) { # Empty RHS
\&     8      return $lhs.\*(Aq_is_empty\*(Aq;
\&     9    }
\&    10
\&    11    my $names = $self\->{GRAMMAR}{TOKENNAMES} || {};
\&    12    for (@rhs) {
\&    13      if ($self\->is_token($_)) {
\&    14        s/^\*(Aq(.*)\*(Aq$/$1/;
\&    15        my $name = $names\->{$_} || \*(Aq\*(Aq;
\&    16        unless ($name) {
\&    17          $name = $_ if /^\ew+$/;
\&    18        }
\&    19        $rhs .= "_$name" if $name;
\&    20      }
\&    21    }
\&    22
\&    23    unless ($rhs) { # no \*(Aqword\*(Aq tokens in the RHS
\&    24      for (@rhs) {
\&    25        $rhs .= "_$_" if /^\ew+$/;
\&    26      }
\&    27    }
\&    28
\&    29    # check if another production with such name exists?
\&    30    my $name = $lhs.\*(Aq_is\*(Aq.$rhs;
\&    31    return $name;
\&    32  }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 2529:" 4
.IX Item "Around line 2529:"
Non-ASCII character seen before =encoding in 'va\*'lida\en";'. Assuming \s-1ISO8859\-1\s0
                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::languageintro.3pm              0100644 0001750 0001750 00000321072 12566242262 026506  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::languageintro 3"
.TH Parse::Eyapp::languageintro 3 "2009-11-06" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::languageintro \- Introduction to the Eyapp language
.SH "The Eyapp Language"
.IX Header "The Eyapp Language"
.SS "Eyapp Grammar"
.IX Subsection "Eyapp Grammar"
This section describes the syntax of the Eyapp language using its own notation.
The grammar extends yacc and yapp grammars.
Semicolons have been omitted to save space.
Between C\-like comments you can find an (informal) 
explanation of the language 
associated with the token.
.PP
.Vb 10
\&  eyapp: head body tail ;
\&  symbol: LITERAL  /* A string literal like \*(Aqhello\*(Aq */
\&      |   ident   
\&  ident:  IDENT  /* IDENT is [A\-Za\-z_][A\-Za\-z0\-9_]* */ 
\&  head: headsec \*(Aq%%\*(Aq
\&  headsec:  decl *
\&  decl:  \*(Aq\en\*(Aq      
\&      |   SEMANTIC typedecl symlist \*(Aq\en\*(Aq  /* SEMANTIC  is %semantic\es+token      */
\&      |   SYNTACTIC typedecl symlist \*(Aq\en\*(Aq /* SYNTACTIC is %syntactic\es+token     */
\&      |   TOKEN typedecl symlist \*(Aq\en\*(Aq     /* TOKEN     is %token                 */
\&      |   ASSOC typedecl symlist \*(Aq\en\*(Aq     /* ASSOC     is %(left|right|nonassoc) */
\&      |   START ident \*(Aq\en\*(Aq                /* START     is %start                 */
\&      |   HEADCODE \*(Aq\en\*(Aq                   /* HEADCODE  is %{ Perl code ... %}    */
\&      |   UNION CODE \*(Aq\en\*(Aq                 /* UNION CODE  see yacc/bison          */
\&      |   DEFAULTACTION CODE \*(Aq\en\*(Aq         /* DEFAULTACTION is %defaultaction     */
\&      |   TREE treeclauses? \*(Aq\en\*(Aq          /* TREE      is %tree                  */
\&      |   METATREE \*(Aq\en\*(Aq                   /* METATREE  is %metatree              */
\&      |   TYPE typedecl identlist \*(Aq\en\*(Aq    /* TYPE      is %type                  */
\&      |   EXPECT NUMBER \*(Aq\en\*(Aq              /* EXPECT    is %expect                */
\&                                          /* NUMBER    is \ed+                    */
\&  typedecl:   /* empty */
\&      |       \*(Aq<\*(Aq IDENT \*(Aq>\*(Aq
\&  treeclauses: BYPASS ALIAS? | ALIAS BYPASS?
\&  symlist:    symbol + 
\&  identlist:  ident +
\&  body: rules * \*(Aq%%\*(Aq
\&  rules: IDENT \*(Aq:\*(Aq rhss \*(Aq;\*(Aq  
\&  rhss: rule <+ \*(Aq|\*(Aq>  
\&  rule:   optname rhs (prec epscode)?
\&  rhs:  rhseltwithid *
\&  rhseltwithid : 
\&        rhselt \*(Aq.\*(Aq IDENT 
\&      | \*(Aq$\*(Aq rhselt  
\&      | rhselt
\&  rhselt:     symbol    
\&      | code    
\&      | \*(Aq(\*(Aq optname rhs \*(Aq)\*(Aq 
\&      | rhselt STAR               /* STAR   is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e*  */
\&      | rhselt \*(Aq<\*(Aq STAR symbol \*(Aq>\*(Aq 
\&      | rhselt OPTION             /* OPTION is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e?  */
\&      | rhselt \*(Aq<\*(Aq PLUS symbol \*(Aq>\*(Aq
\&      | rhselt PLUS               /* PLUS   is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e+  */
\&  optname: (NAME IDENT)?          /* NAME is %name */
\&         | NOBYPASS IDENT         /* NOBYPASS is %no\es+bypass */
\&  prec: PREC symbol               /* PREC is %prec */
\&  epscode:  code ?   
\&  code:   
\&      CODE           /* CODE     is { Perl code ... }         */
\&    | BEGINCODE      /* BEGINCODE is %begin { Perl code ... } */
\&  tail:  TAILCODE ?  /* TAILCODE is { Perl code ... } */
.Ve
.PP
The semantic of \f(CW\*(C`Eyapp\*(C'\fR agrees with the semantic of \f(CW\*(C`yacc\*(C'\fR and \f(CW\*(C`yapp\*(C'\fR
for all the common constructions.
.SS "Comments"
.IX Subsection "Comments"
Comments are either Perl style, from \f(CW\*(C`#\*(C'\fR
up to the end of line, or C style, enclosed between  \f(CW\*(C`/*\*(C'\fR and \f(CW\*(C`*/\*(C'\fR.
.SS "Syntactic Variables, Symbolic Tokens and String Literals"
.IX Subsection "Syntactic Variables, Symbolic Tokens and String Literals"
Two kind of symbols may appear inside a Parse::Eyapp program:
\&\fINon-terminal\fR symbols or \fIsyntactic variables\fR, 
called also \fIleft-hand-side\fR symbols
and \fITerminal\fR symbols, called
also \fITokens\fR.
.PP
Tokens are the symbols the lexical analyzer function returns to the parser.
There are two kinds: \fIsymbolic tokens\fR and \fIstring
literals\fR.
.PP
\&\fISyntactic variables\fR and \fIsymbolic tokens\fR identifiers must conform
to the regular expression \f(CW\*(C`[A\-Za\-z][A\-Za\-z0\-9_]*\*(C'\fR.
.PP
When building the syntax tree (i.e. when running under the \f(CW%tree\fR
directive) \fIsymbolic tokens\fR will be considered \fIsemantic tokens\fR (see section
\&\*(L"Syntactic and Semantic tokens\*(R").
.PP
String literals are enclosed in single quotes and can contain almost
anything. They will be received by the parser as double-quoted strings. 
Any special character as \f(CW\*(Aq"\*(Aq\fR, \f(CW\*(Aq$\*(Aq\fR and \f(CW\*(Aq@\*(Aq\fR is escaped.
To have a single quote inside a literal, escape it with '\e'.
.PP
When building the syntax tree (i.e. when running under the \f(CW%tree\fR
directive) \fIstring literals\fR will be considered \fIsyntactic tokens\fR (see section
\&\*(L"Syntactic and Semantic tokens\*(R").
.ie n .SS "Parts of an ""eyapp"" Program"
.el .SS "Parts of an \f(CWeyapp\fP Program"
.IX Subsection "Parts of an eyapp Program"
An Eyapp program has three parts called head, body and tail:
.PP
.Vb 1
\&                                 eyapp: head body tail ;
.Ve
.PP
Each part is separated from the former by the symbol \f(CW\*(C`%%\*(C'\fR:
.PP
.Vb 2
\&                                 head: headsec \*(Aq%%\*(Aq
\&                                 body: rulesec \*(Aq%%\*(Aq
.Ve
.SS "The Head Section"
.IX Subsection "The Head Section"
The head section contains a list of declarations
.PP
.Vb 1
\&                                 headsec:  decl *
.Ve
.PP
There are different kinds of declarations.
.PP
This reference does not 
fully describes all the declarations that are shared with yacc and 
yapp.
.PP
\fIExample of Head Section\fR
.IX Subsection "Example of Head Section"
.PP
In this and the next sections we will describe the basics
of the Eyapp language using the file \f(CW\*(C`examples/Calc.eyp\*(C'\fR 
that accompanies this distribution. This file implements a trivial 
calculator. Here is the header section:
.PP
.Vb 12
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq1,11p\*(Aq Calc.eyp | cat \-n
\&  1  # examples/Calc.eyp
\&  2  %right  \*(Aq=\*(Aq
\&  3  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&  4  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&  5  %left   NEG
\&  6  %right  \*(Aq^\*(Aq
\&  7  %{
\&  8  my %s; # symbol table
\&  9  %}
\& 10
\& 11  %%
.Ve
.PP
\fIDeclarations and Precedence\fR
.IX Subsection "Declarations and Precedence"
.PP
Lines 2\-5 declare several tokens. The usual way to declare
tokens is through the \f(CW%token\fR directive. The declarations 
\&\f(CW%nonassoc\fR, \f(CW%left\fR and \f(CW%right\fR 
not only declare the tokens but also associate a \fIpriority\fR with them.  
Tokens declared in the same line have the same precedence. 
Tokens declared with these directives in lines below have more
precedence than those declared above. Thus, in the example
above
we are saying that \f(CW"+"\fR and \f(CW"\-"\fR have the same precedence
but higher precedence than =. The final effect of \f(CW"\-"\fR
having greater precedence than = will be that an
expression like:
.PP
.Vb 1
\&                        a = 4 \- 5
.Ve
.PP
will be interpreted as
.PP
.Vb 1
\&                        a = (4 \- 5)
.Ve
.PP
and not as
.PP
.Vb 1
\&                        (a = 4) \- 5
.Ve
.PP
The use of the \f(CW%left\fR indicates that \- in case of ambiguity 
and a match between precedences \- the parser must build the tree corresponding
to a left parenthesization. Thus, the expression
.PP
.Vb 1
\&                         4 \- 5 \- 9
.Ve
.PP
will be interpreted as
.PP
.Vb 1
\&                         (4 \- 5) \- 9
.Ve
.PP
\fIHeader Code\fR
.IX Subsection "Header Code"
.PP
Perl code surrounded by \f(CW\*(C`%{\*(C'\fR and \f(CW\*(C`%}\*(C'\fR
can be inserted in the head section. Such code will be inserted in the module
generated by \f(CW\*(C`eyapp\*(C'\fR near the beginning. Therefore, declarations like the
one of the calculator symbol table \f(CW%s\fR
.PP
.Vb 3
\&  7  %{
\&  8  my %s; # symbol table
\&  9  %}
.Ve
.PP
will be visible from almost any point in the file.
.PP
\fIThe Start Symbol of the Grammar\fR
.IX Subsection "The Start Symbol of the Grammar"
.PP
\&\f(CW\*(C`%start IDENT\*(C'\fR declares \f(CW\*(C`IDENT\*(C'\fR as the start symbol of 
the grammar. When \f(CW%start\fR is not
used, the first rule in the body section will be used.
.PP
\fIExpect\fR
.IX Subsection "Expect"
.PP
The \f(CW\*(C`%expect #NUMBER\*(C'\fR directive works as in bison 
and  suppress warnings when the number of Shift/Reduce
conflicts is exactly \f(CW\*(C`#NUMBER\*(C'\fR. See section 
\&\*(L"Solving Ambiguities and Conflicts\*(R" to know more
about Shift/Reduce conflicts.
.PP
\fIType and Union\fR
.IX Subsection "Type and Union"
.PP
C oriented declarations like \f(CW%type\fR and \f(CW%union\fR are
parsed but ignored.
.PP
\fIThe \f(CI%strict\fI Directive\fR
.IX Subsection "The %strict Directive"
.PP
By default, identifiers appearing in the rule section
will be classified as terminal if they don't appear 
in the left hand side of any production rules.
.PP
The directive \f(CW%strict\fR forces the declaration of all tokens. 
The following \f(CW\*(C`eyapp\*(C'\fR program issues a warning:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ cat \-n bugyapp2.eyp
\&       1  %strict
\&       2  %%
\&       3  expr: NUM;
\&       4  %%
\&  pl@nereida:~/LEyapp/examples$ eyapp bugyapp2.eyp
\&  Warning! Non declared token NUM at line 3 of bugyapp2.eyp
.Ve
.PP
To keep silent the compiler declare all tokens using
one of the token declaration directives (\f(CW%token\fR, \f(CW%left\fR, etc.)
.PP
.Vb 8
\&  pl@nereida:~/LEyapp/examples$ cat \-n bugyapp3.eyp
\&       1  %strict
\&       2  %token NUM
\&       3  %%
\&       4  expr: NUM;
\&       5  %%
\&  pl@nereida:~/LEyapp/examples$ eyapp bugyapp3.eyp
\&  pl@nereida:~/LEyapp/examples$
.Ve
.PP
It is a good practice to use \f(CW%strict\fR at the beginning of your grammar.
.PP
\fIDefault Action Directive\fR
.IX Subsection "Default Action Directive"
.PP
In \f(CW\*(C`Parse::Eyapp\*(C'\fR you can modify the default action using the \f(CW\*(C`%defaultaction { Perl code }\*(C'\fR
directive. See section
\&\*(L"Default actions\*(R".
.PP
\fITree Construction Directives\fR
.IX Subsection "Tree Construction Directives"
.PP
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR facilitates the construction of concrete syntax trees and 
abstract syntax trees (abbreviated \s-1AST\s0 from now on) through the \f(CW%tree\fR
\&\f(CW%metatree\fR directives. See section
\&\*(L"Abstract Syntax Trees : \f(CW%tree\fR and \f(CW%name\fR\*(R"
and Parse::Eyapp::translationschemestut.
.PP
\fISyntactic and Semantic Tokens\fR
.IX Subsection "Syntactic and Semantic Tokens"
.PP
The new token declaration directives \f(CW\*(C`%syntactic token\*(C'\fR and
\&\f(CW\*(C`%semantic token\*(C'\fR can change the way \f(CW\*(C`eyapp\*(C'\fR builds the abstract syntax tree.
See section \*(L"Syntactic and Semantic tokens\*(R".
.SS "The Body"
.IX Subsection "The Body"
The body section contains the rules describing the grammar:
.PP
.Vb 3
\&                       body:   rules * \*(Aq%%\*(Aq
\&                       rules:  IDENT \*(Aq:\*(Aq rhss \*(Aq;\*(Aq  
\&                       rhss:   (optname rhs (prec epscode)?) <+ \*(Aq|\*(Aq>
.Ve
.PP
\fIRules\fR
.IX Subsection "Rules"
.PP
A rule is made of a left-hand-side symbol (the \fIsyntactic variable\fR), 
followed by a \f(CW\*(Aq:\*(Aq\fR and one
or more \fIright-hand-sides\fR (or \fIproductions\fR)
 separated by \f(CW\*(Aq|\*(Aq\fR and terminated by a \f(CW\*(Aq;\*(Aq\fR
like in:
.PP
.Vb 5
\&                          exp: 
\&                               exp \*(Aq+\*(Aq exp
\&                            |  exp \*(Aq\-\*(Aq exp
\&                            |  NUM
\&                          ;
.Ve
.PP
A \fIproduction\fR (\fIright hand side\fR) may be empty:
.PP
.Vb 4
\&                          input:   
\&                               /* empty */
\&                            |  input line
\&                          ;
.Ve
.PP
The former two productions can be abbreviated as
.PP
.Vb 3
\&                          input: 
\&                               line *
\&                          ;
.Ve
.PP
The operators \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR and \f(CW\*(C`?\*(C'\fR are presented in section
\&\*(L"Lists and Optionals\*(R".
.PP
A \fIsyntactic variable cannot appear more than once as
a rule name\fR (This differs from yacc).
.PP
\fISemantic Values and Semantic Actions\fR
.IX Subsection "Semantic Values and Semantic Actions"
.PP
In \f(CW\*(C`Parse::Eyapp\*(C'\fR 
a production rule
.PP
.Vb 1
\&                          A \-> X_1 X_2 ... X_n
.Ve
.PP
can be followed by a 
\&\fIsemantic action\fR:
.PP
.Vb 1
\&                    A \-> X_1 X_2 ... X_n { Perl Code }
.Ve
.PP
Such
semantic action is nothing but Perl code that will be treated 
as an anonymous subroutine.  The semantic action associated 
with production rule \f(CW\*(C`A \-> X_1 X_2 ... X_n\*(C'\fR  is executed
after any actions associated with the subtrees of \f(CW\*(C`X_1\*(C'\fR,
\&\f(CW\*(C`X_2\*(C'\fR, ..., \f(CW\*(C`X_n\*(C'\fR.
\&\f(CW\*(C`Eyapp\*(C'\fR parsers build the syntax tree using a left-right
bottom-up traverse of the syntax tree. Each times
the Parser visits the node associated with the 
production \f(CW\*(C`A \-> X_1 X_2 ... X_n\*(C'\fR
the associated semantic action is called. 
Asociated with each symbol
of a Parse::Eyapp grammar there is a scalar \fISemantic Value\fR
or \fIAttribute\fR. The semantic values of terminals are provided
by the lexical analyzer. In the calculator example
(see file \f(CW\*(C`examples/Calc.yp\*(C'\fR in the distribution),
the semantic value associated with an expression
is its numeric value. Thus in the rule:
.PP
.Vb 1
\&                       exp \*(Aq+\*(Aq exp { $_[1] + $_[3] }
.Ve
.PP
\&\f(CW$_[1]\fR refers to the attribute of the first \f(CW\*(C`exp\*(C'\fR, \f(CW$_[2]\fR 
is the attribute associated with \f(CW\*(Aq+\*(Aq\fR, which is the second component of the 
pair provided by the lexical analyzer and \f(CW$_[3]\fR refers to the attribute of 
the second \f(CW\*(C`exp\*(C'\fR.
.PP
When the semantic action/anonymous subroutine is called,
the arguments are as follows:
.IP "\(bu" 4
\&\f(CW$_[1]\fR to \f(CW$_[n]\fR are the attributes of
the symbols \f(CW\*(C`X_1\*(C'\fR, \f(CW\*(C`X_2\*(C'\fR, ..., \f(CW\*(C`X_n\*(C'\fR. 
Just as \f(CW$1\fR to \f(CW$n\fR in yacc,
.IP "\(bu" 4
\&\f(CW$_[0]\fR is the parser object itself.
Having \f(CW$_[0]\fR beeing the parser object itself allows you to call
parser methods. Most yacc macros have been converted into
parser methods. See section 'Methods Available in the Generated Class'
in Parse::Eyapp.
.PP
The returned value will be the attribute associated 
with the left hand side of the production.
.PP
Names can be given to the attributes using the dot notation
(see file \f(CW\*(C`examples/CalcSimple.eyp\*(C'\fR):
.PP
.Vb 1
\&                     exp.left \*(Aq+\*(Aq exp.right { $left + $right }
.Ve
.PP
See section \*(L"Names for attributes\*(R" for more details about the \fIdot\fR and \fIdollar\fR 
notations.
.PP
If no action is specified and no \f(CW%defaultaction\fR is specified
the default action
.PP
.Vb 1
\&                               { $_[1] }
.Ve
.PP
will be executed instead. See section \*(L"Default actions\*(R" to know more.
.PP
\fIActions in Mid-Rule\fR
.IX Subsection "Actions in Mid-Rule"
.PP
Actions can be inserted in the middle of a production like in:
.PP
.Vb 1
\& block: \*(Aq{\*(Aq.bracket { $ids\->begin_scope(); } declaration*.decs statement*.sts \*(Aq}\*(Aq { ... }
.Ve
.PP
A middle production action is managed by inserting a new rule in the grammar and associating
the semantic action with it:
.PP
.Vb 1
\&                     Temp: /* empty */ { $ids\->begin_scope(); }
.Ve
.PP
Middle production actions can refer to the attributes on its left. They count
as one of the components of the production. Thus the program:
.PP
.Vb 5
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq1,4p\*(Aq intermediateaction2.yp
\& %%
\& S:  \*(Aqa\*(Aq { $_[1]x4 }.mid \*(Aqa\*(Aq { print "$_[2], $mid, $_[3]\en"; }
\& ;
\& %%
.Ve
.PP
The auxiliar syntactic variables are named \f(CW\*(C`@#position\-#order\*(C'\fR where \f(CW\*(C`#position\*(C'\fR
is the position of the action in the rhs and \f(CW\*(C`order\*(C'\fR is an ordinal number. See
the \f(CW\*(C`.output\*(C'\fR file for the former example:
.PP
.Vb 7
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ eyapp \-v intermediateaction2.yp
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq1,5p\*(Aq intermediateaction2.output
\& Rules:
\& \-\-\-\-\-\-
\& 0:      $start \-> S $end
\& 1:      S \-> \*(Aqa\*(Aq @1\-1 \*(Aqa\*(Aq
\& 2:      @1\-1 \-> /* empty */
.Ve
.PP
when given input \f(CW\*(C`aa\*(C'\fR the execution will produce as output \f(CW\*(C`aaaa, aaaa, a\*(C'\fR.
.PP
\fIExample of Body Section\fR
.IX Subsection "Example of Body Section"
.PP
Following with the calculator example, the body is:
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq12,48p\*(Aq Calc.eyp | cat \-n
\&  1  start:
\&  2      input { \e%s }
\&  3  ;
\&  4
\&  5  input: line *
\&  6  ;
\&  7
\&  8  line:
\&  9    \*(Aq\en\*(Aq         { undef }
\& 10    | exp \*(Aq\en\*(Aq   { print "$_[1]\en" if defined($_[1]); $_[1] }
\& 11    | error  \*(Aq\en\*(Aq
\& 12        {
\& 13          $_[0]\->YYErrok;
\& 14          undef
\& 15        }
\& 16  ;
\& 17
\& 18  exp:
\& 19      NUM
\& 20    | $VAR                   { $s{$VAR} }
\& 21    | $VAR \*(Aq=\*(Aq $exp          { $s{$VAR} = $exp }
\& 22    | exp.left \*(Aq+\*(Aq exp.right { $left + $right }
\& 23    | exp.left \*(Aq\-\*(Aq exp.right { $left \- $right }
\& 24    | exp.left \*(Aq*\*(Aq exp.right { $left * $right }
\& 25    | exp.left \*(Aq/\*(Aq exp.right
\& 26      {
\& 27         $_[3] and return($_[1] / $_[3]);
\& 28         $_[0]\->YYData\->{ERRMSG} = "Illegal division by zero.\en";
\& 29         $_[0]\->YYError; # Pretend that a syntactic error ocurred: _Error will be called
\& 30         undef
\& 31      }
\& 32    | \*(Aq\-\*(Aq $exp %prec NEG     { \-$exp }
\& 33    | exp.left \*(Aq^\*(Aq exp.right { $left ** $right }
\& 34    | \*(Aq(\*(Aq $exp \*(Aq)\*(Aq           { $exp }
\& 35  ;
\& 36
\& 37  %%
.Ve
.PP
This example does not uses any of the Eyapp extensions (with the exception of the 
\&\fIstar list\fR at line 5) and the dot and dollar notations. 
Please, see the Parse::Yapp pages and elsewhere documentation
on yacc and bison for more information.
.PP
\fISolving Ambiguities and Conflicts\fR
.IX Subsection "Solving Ambiguities and Conflicts"
.PP
When Eyapp analizes a grammar like:
.PP
.Vb 7
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ cat \-n ambiguities.eyp
\&     1  %%
\&     2  exp:
\&     3      NUM
\&     4    | exp \*(Aq\-\*(Aq exp
\&     5  ;
\&     6  %%
.Ve
.PP
it will produce a warning announcing the existence of 
\&\fIshift-reduce\fR conflicts:
.PP
.Vb 7
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ eyapp ambiguities.eyp
\& 1 shift/reduce conflict (see .output file)
\& State 5: reduce by rule 2: exp \-> exp \*(Aq\-\*(Aq exp (default action)
\& State 5: shifts:
\&   to state    3 with \*(Aq\-\*(Aq
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ ls \-ltr | tail \-1
\& \-rw\-rw\-\-\-\-  1 pl users   1082 2007\-02\-06 08:26 ambiguities.output
.Ve
.PP
when \f(CW\*(C`eyapp\*(C'\fR finds warnings automatically produces a \f(CW\*(C`.output\*(C'\fR file
describing the conflict.
.PP
What the warning is saying is that an expression like \f(CW\*(C`exp \*(Aq\-\*(Aq exp\*(C'\fR (rule 2) followed by a
minus \f(CW\*(Aq\-\*(Aq\fR can be worked in more than one way. If we
have an input like \f(CW\*(C`NUM \- NUM \- NUM\*(C'\fR the activity of a \s-1\fILALR\s0\fR\|(1) parser
(the family of parsers to which Eyapp belongs)
consists of a sequence of \fIshift and reduce actions\fR. A \fIshift action\fR
has as consequence the reading of the next token. A \fIreduce action\fR
is finding a production rule that matches and substituting 
the rhs of the production by the lhs.  For input \f(CW\*(C`NUM \- NUM \- NUM\*(C'\fR
the activity will be as follows (the dot is used to indicate where the next 
input token is):
.PP
.Vb 6
\&                           .NUM \- NUM \- NUM # shift
\&                            NUM.\- NUM \- NUM # reduce exp: NUM 
\&                            exp.\- NUM \- NUM # shift
\&                            exp \-.NUM \- NUM # shift
\&                            exp \- NUM.\- NUM # reduce exp: NUM
\&                            exp \- exp.\- NUM # shift/reduce conflict
.Ve
.PP
up this point two different decisions can be taken: the next description can be
.PP
.Vb 1
\&                                  exp.\- NUM # reduce by exp: exp \*(Aq\-\*(Aq exp (rule 2)
.Ve
.PP
or:
.PP
.Vb 1
\&                            exp \- exp \-.NUM # shift \*(Aq\-\*(Aq (to state 3)
.Ve
.PP
that is why it is called a \fIshift-reduce conflict\fR.
.PP
That is also the reason for the precedence declarations in the 
head section. Another kind of conflicts are \fIreduce-reduce conflicts\fR.
They arise when more that rhs can be applied for a reduction
action.
.PP
Eyapp solves the conflicts applying the following rules:
.IP "\(bu" 4
In a shift/reduce conflict, the default is the shift.
.IP "\(bu" 4
In a reduce/reduce conflict, the default is to reduce by the
earlier grammar production (in the input sequence).
.IP "\(bu" 4
The precedences and associativities are associated with tokens in
the declarations section. This is made by a sequence of lines beginning
with one of the directives: \f(CW%left\fR, \f(CW%right\fR, or \f(CW%nonassoc\fR, 
followed by a list of
tokens. All the tokens on the same line
have the same precedence and associativity; 
the lines are listed in order of increasing precedence.
.IP "\(bu" 4
A precedence and associativity is associated with each grammar
production; it is the precedence and associativity of the \fIlast token\fR 
or \fIliteral\fR in the right hand side of the production.
.IP "\(bu" 4
The \f(CW%prec\fR directive can be used when
a rhs is involved in a conflict and has no tokens
inside or it has but the precedence of the last token leads
to an incorrect interpretation. A rhs can be followed by 
an optional \f(CW\*(C`%prec token\*(C'\fR directive
giving the production the precedence of the \f(CW\*(C`token\*(C'\fR
.Sp
.Vb 1
\&                          exp:   \*(Aq\-\*(Aq exp %prec NEG { \-$_[1] }
.Ve
.IP "\(bu" 4
If there is a shift/reduce conflict, and both the grammar production
and the input character have precedence and associativity associated
with them, then the conflict is solved in favor of the action (shift or
reduce) associated with the higher precedence. If the precedences are the
same, then the associativity is used; left associative implies reduce,
right associative implies shift, and nonassociating implies error.
.PP
To solve a shift-reduce conflict between a production \f(CW\*(C`A \-\-> SOMETHING\*(C'\fR
and a token \f(CW\*(Aqa\*(Aq\fR you can follow this procedure:
.ie n .IP "1. Edit the "".output"" file" 4
.el .IP "1. Edit the \f(CW.output\fR file" 4
.IX Item "1. Edit the .output file"
.PD 0
.IP "2. Search for the state where the conflict between the production and the token is. In our example it looks like:" 4
.IX Item "2. Search for the state where the conflict between the production and the token is. In our example it looks like:"
.PD
.Vb 2
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq56,65p\*(Aq ambiguities.output
\& State 5:
\&
\&        exp \-> exp . \*(Aq\-\*(Aq exp    (Rule 2)
\&        exp \-> exp \*(Aq\-\*(Aq exp .    (Rule 2)
\&
\&        \*(Aq\-\*(Aq     shift, and go to state 3
\&
\&        \*(Aq\-\*(Aq     [reduce using rule 2 (exp)]
\&        $default        reduce using rule 2 (exp)
.Ve
.ie n .IP "3. Inside the state there has to be a production of the type ""A \-\-> SOMETHING."" (with the dot at the end) indicating that a reduction must take place. There has to be also another production of the form ""A \-\-> prefix . suffix"", where suffix can \fIstart\fR with the involved token \*(Aqa\*(Aq." 4
.el .IP "3. Inside the state there has to be a production of the type \f(CWA \-\-> SOMETHING.\fR (with the dot at the end) indicating that a reduction must take place. There has to be also another production of the form \f(CWA \-\-> prefix . suffix\fR, where suffix can \fIstart\fR with the involved token \f(CW\*(Aqa\*(Aq\fR." 4
.IX Item "3. Inside the state there has to be a production of the type A --> SOMETHING. (with the dot at the end) indicating that a reduction must take place. There has to be also another production of the form A --> prefix . suffix, where suffix can start with the involved token a."
.PD 0
.ie n .IP "4. Decide what action shift or reduce matches the kind of trees you want. In this example we want ""NUM \- NUM \- NUM"" to produce a tree like ""MINUS(MINUS(NUM, NUM), NUM)"" and not ""MINUS(NUM, MINUS(NUM, NUM))"". We want the conflict in ""exp \- exp.\- NUM"" to be solved in favor of the reduction by ""exp: exp \*(Aq\-\*(Aq exp"". This is achieved by declaring ""%left \*(Aq\-\*(Aq""." 4
.el .IP "4. Decide what action shift or reduce matches the kind of trees you want. In this example we want \f(CWNUM \- NUM \- NUM\fR to produce a tree like \f(CWMINUS(MINUS(NUM, NUM), NUM)\fR and not \f(CWMINUS(NUM, MINUS(NUM, NUM))\fR. We want the conflict in \f(CWexp \- exp.\- NUM\fR to be solved in favor of the reduction by \f(CWexp: exp \*(Aq\-\*(Aq exp\fR. This is achieved by declaring \f(CW%left \*(Aq\-\*(Aq\fR." 4
.IX Item "4. Decide what action shift or reduce matches the kind of trees you want. In this example we want NUM - NUM - NUM to produce a tree like MINUS(MINUS(NUM, NUM), NUM) and not MINUS(NUM, MINUS(NUM, NUM)). We want the conflict in exp - exp.- NUM to be solved in favor of the reduction by exp: exp - exp. This is achieved by declaring %left -."
.PD
.PP
\fIError Recovery\fR
.IX Subsection "Error Recovery"
.PP
The token name \f(CW\*(C`error\*(C'\fR is reserved for error handling. This name can
be used in grammar productions; it suggests places where errors are
expected, and recovery can take place:
.PP
.Vb 8
\&     line:
\&       \*(Aq\en\*(Aq         { undef }
\&       | exp \*(Aq\en\*(Aq   { print "$_[1]\en" if defined($_[1]); $_[1] }
\&       | error  \*(Aq\en\*(Aq
\&           {
\&             $_[0]\->YYErrok;
\&             undef
\&           }
.Ve
.PP
The parser pops its stack until
it enters a state where the token \f(CW\*(C`error\*(C'\fR is legal. It then shifts
the token \f(CW\*(C`error\*(C'\fR and proceeds to discard tokens until finding 
one that is acceptable. In the example
all the tokens until finding a \f(CW\*(Aq\en\*(Aq\fR will be skipped. 
If no special error productions have been specified,
the processing will halt.
.PP
In order to prevent a cascade of error messages, the parser, after
detecting an error, remains in error state until three tokens have been
successfully read and shifted. If an error is detected when the parser
is already in error state, no message is given, and the input token is
quietly deleted. The method \f(CW\*(C`YYErrok\*(C'\fR used in the example 
communicates to the parser
that a satisfactory recovery has been reached 
and that it can safely emit new error
messages.
.PP
You cannot have a literal \fI'error'\fR in your grammar as it would
confuse the driver with the \fIerror\fR token. Use a symbolic token instead.
.SS "The Tail"
.IX Subsection "The Tail"
The tail section contains Perl code. Usually the lexical analyzer and the
Error management subroutines go there. A better practice however is to isolate
both subroutines in a module and use them in the grammar. An example of this is in
files \f(CW\*(C`examples/CalcUsingTail.eyp\*(C'\fR and \f(CW\*(C`examples/Tail.pm\*(C'\fR.
.PP
\fIThe Lexical Analyzer\fR
.IX Subsection "The Lexical Analyzer"
.PP
The Lexical Analyzer 
is called each time the parser needs a new token.
It is called with only one argument (the parser object)
and returns a pair 
containing the next token and its associated attribute.
.PP
The fact that is a method of the parser object means that 
the parser
methods are accesible inside the lexical analyzer.
Specially interesting is the \f(CW\*(C`$_[0]\->YYData\*(C'\fR 
method which provides access to the user data area.
.PP
\&\fIWhen the lexical analyzer reaches the end of input, it must return the
pair\fR \f(CW\*(C`(\*(Aq\*(Aq, undef)\*(C'\fR
.PP
See below how to write a lexical analyzer (file \f(CW\*(C`examples/Calc.eyp\*(C'\fR):
.PP
.Vb 10
\&  1  sub make_lexer {
\&  2    my $input = shift;
\&  3
\&  4    return sub {
\&  5      my $parser = shift;
\&  6
\&  7      for ($$input) {
\&  8        m{\eG[ \et]*}gc;
\&  9        m{\eG([0\-9]+(?:\e.[0\-9]+)?)}gc   and return (\*(AqNUM\*(Aq,$1);
\& 10        m{\eG([A\-Za\-z][A\-Za\-z0\-9_]*)}gc and return (\*(AqVAR\*(Aq,$1);
\& 11        m{\eG\en}gc                      and do { $lineno++; return ("\en", "\en") };
\& 12        m{\eG(.)}gc                     and return ($1,$1);
\& 13
\& 14        return(\*(Aq\*(Aq,undef);
\& 15      }
\& 16    }
\& 17  }
.Ve
.PP
The subroutine \f(CW\*(C`make_lexer\*(C'\fR creates the lexical analyzer as
a closure. The lexer returned by \f(CW\*(C`make_lexer\*(C'\fR is used by the 
\&\f(CW\*(C`YYParse\*(C'\fR method:
.PP
.Vb 9
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq90,97p\*(Aq Calc.eyp | cat \-n
\& 1  sub Run {
\& 2      my($self)=shift;
\& 3      my $input = shift or die "No input given\en";
\& 4
\& 5      return $self\->YYParse( yylex => make_lexer($input), yyerror => \e&_Error,
\& 6        #yydebug =>0x1F
\& 7      );
\& 8  }
.Ve
.PP
\fIThe Error Report Subroutine\fR
.IX Subsection "The Error Report Subroutine"
.PP
The Error Report subroutine is also a parser method, 
and consequently receives as parameter the parser object.
.PP
See the error report subroutine
for the example in \f(CW\*(C`examples/Calc.eyp\*(C'\fR:
.PP
.Vb 10
\&  1  %%
\&  2
\&  3  my $lineno = 1;
\&  4
\&  5  sub _Error {
\&  6    my $parser = shift;
\&  7
\&  8      exists $parser\->YYData\->{ERRMSG}
\&  9    and do {
\& 10        print $parser\->YYData\->{ERRMSG};
\& 11        delete $parser\->YYData\->{ERRMSG};
\& 12        return;
\& 13    };
\& 14    my($token)=$parser\->YYCurval;
\& 15    my($what)= $token ? "input: \*(Aq$token\*(Aq" : "end of input";
\& 16    my @expected = $parser\->YYExpect();
\& 17    local $" = \*(Aq, \*(Aq;
\& 18    print << "ERRMSG";
\& 19
\& 20  Syntax error near $what (lin num $lineno).
\& 21  Expected one of these terminals: @expected
\& 22  ERRMSG
\& 23  }
.Ve
.PP
See the Parse::Yapp pages and elsewhere documentation
on yacc and bison for more information.
.SS "Using an Eyapp Program"
.IX Subsection "Using an Eyapp Program"
The following is an example of a program that uses the calculator explained 
in the two previous sections:
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ cat \-n usecalc.pl
\&  1  #!/usr/bin/perl \-w
\&  2  use strict;
\&  3  use Calc;
\&  4
\&  5  my $parser = Calc\->new();
\&  6  my $input = <<\*(AqEOI\*(Aq;
\&  7  a = 2*3
\&  8  d = 5/(a\-6)
\&  9  b = (a+1)/7
\& 10  c=a*3+4)\-5
\& 11  a = a+1
\& 12  EOI
\& 13  my $t = $parser\->Run(\e$input);
\& 14  print "========= Symbol Table ==============\en";
\& 15  print "$_ = $t\->{$_}\en" for sort keys %$t;
.Ve
.PP
The output for this program is (the input for each output
appear as a Perl comment on the right):
.PP
.Vb 5
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ eyapp Calc.eyp
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ usecalc.pl
\& 6                                              # a = 2*3
\& Illegal division by zero.                      # d = 5/(a\-6)
\& 1                                              # b = (a+1)/7
\&
\& Syntax error near input: \*(Aq)\*(Aq (lin num 4).      # c=a*3+4)\-5
\& Expected one of these terminals: \-, /, ^, *, +,
\&
\& 7                                              # a = a+1
\& ========= Symbol Table ==============
\& a = 7
\& b = 1
\& c = 22
.Ve
.SS "Lists and Optionals"
.IX Subsection "Lists and Optionals"
The elements of a rhs can be one of these:
.PP
.Vb 9
\&  rhselt:     
\&        symbol    
\&      | code    
\&      | \*(Aq(\*(Aq optname rhs \*(Aq)\*(Aq 
\&      | rhselt STAR               /* STAR   is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e*  */
\&      | rhselt \*(Aq<\*(Aq STAR symbol \*(Aq>\*(Aq 
\&      | rhselt OPTION             /* OPTION is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e?  */
\&      | rhselt \*(Aq<\*(Aq PLUS symbol \*(Aq>\*(Aq
\&      | rhselt PLUS               /* PLUS   is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e+  */
.Ve
.PP
The \f(CW\*(C`STAR\*(C'\fR, \f(CW\*(C`OPTION\*(C'\fR and \f(CW\*(C`PLUS\*(C'\fR operators provide a simple mechanism
to express lists:
.IP "\(bu" 4
In Eyapp the \f(CW\*(C`+\*(C'\fR operator indicates one or more repetitions of the element
to the left of \f(CW\*(C`+\*(C'\fR, thus a rule like:
.Sp
.Vb 1
\&                        decls:  decl +
.Ve
.Sp
is the same as:
.Sp
.Vb 2
\&                        decls:  decls decl 
\&                             |  decl
.Ve
.Sp
An additional  symbol may be included  to indicate lists of elements 
separated by such symbol. Thus
.Sp
.Vb 1
\&                       rhss: rule <+ \*(Aq|\*(Aq>
.Ve
.Sp
is equivalent to:
.Sp
.Vb 2
\&                       rhss: rhss \*(Aq|\*(Aq rule 
\&                           | rule
.Ve
.IP "\(bu" 4
The operators \f(CW\*(C`*\*(C'\fR and \f(CW\*(C`?\*(C'\fR have their usual meaning: 0 or more for
\&\f(CW\*(C`*\*(C'\fR and optionality for \f(CW\*(C`?\*(C'\fR. Is legal to parenthesize 
a \f(CW\*(C`rhs\*(C'\fR expression as in:
.Sp
.Vb 1
\&                       optname: (NAME IDENT)?
.Ve
.SS "The Semantic of Lists Operators"
.IX Subsection "The Semantic of Lists Operators"
\fIThe \f(CI\*(C`+\*(C'\fI operator\fR
.IX Subsection "The + operator"
.PP
The grammar:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-12 List3.yp | cat \-n
\&   1  # List3.yp
\&   2  %semantic token \*(Aqc\*(Aq
\&   3  %{
\&   4  use Data::Dumper;
\&   5  %}
\&   6  %%
\&   7  S:      \*(Aqc\*(Aq+  \*(Aqd\*(Aq+
\&   8             {
\&   9                print Dumper($_[1]);
\&  10                print Dumper($_[2]);
\&  11             }
\&  12  ;
.Ve
.PP
Is equivalent to:
.PP
.Vb 9
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v List3.yp | head \-9 List3.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> S $end
\&  1:      PLUS\-1 \-> PLUS\-1 \*(Aqc\*(Aq
\&  2:      PLUS\-1 \-> \*(Aqc\*(Aq
\&  3:      PLUS\-2 \-> PLUS\-2 \*(Aqd\*(Aq
\&  4:      PLUS\-2 \-> \*(Aqd\*(Aq
\&  5:      S \-> PLUS\-1 PLUS\-2
.Ve
.PP
By default, the semantic action associated with a \f(CW\*(C`+\*(C'\fR returns the lists of attributes
to which the \f(CW\*(C`+\*(C'\fR applies:
.PP
.Vb 4
\&  pl@nereida:~/LEyapp/examples$ use_list3.pl
\&  ccdd
\&  $VAR1 = [ \*(Aqc\*(Aq, \*(Aqc\*(Aq ];
\&  $VAR1 = [ \*(Aqd\*(Aq, \*(Aqd\*(Aq ];
.Ve
.PP
The semantic associated with a \f(CW\*(C`+\*(C'\fR changes 
when one of the tree creation directives is active (for instance \f(CW%tree\fR or \f(CW%metatree\fR)
or it has been explicitly requested with a call to the \f(CW\*(C`YYBuildingTree\*(C'\fR method:
.PP
.Vb 1
\&                            $self\->YYBuildingTree(1);
.Ve
.PP
Other ways to change the associated semantic are to use the 
\&\f(CW\*(C`yybuildingtree\*(C'\fR option of \f(CW\*(C`YYParse\*(C'\fR:
.PP
.Vb 4
\&         $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&                           yybuildingtree => 1,
\&                         # yydebug => 0x1F
\&         );
.Ve
.PP
In such case the associated semantic action creates a node labelled
.PP
.Vb 1
\&                     _PLUS_LIST_#number
.Ve
.PP
whose children are the attributes associated with the items in the 
plus list. The \f(CW\*(C`#number\*(C'\fR in \f(CW\*(C`_PLUS_LIST_#number\*(C'\fR is the ordinal
of the production rule as it appears in the \f(CW\*(C`.output\*(C'\fR file.
As it happens when using the \f(CW%tree\fR directive syntactic tokens 
are skipped.
.PP
When executing the example above but under the \f(CW%tree\fR directive
the ouput changes:
.PP
.Vb 4
\&  pl@nereida:~/LEyapp/examples$ head \-3 List3.yp; eyapp List3.yp
\&  # List3.yp
\&  %semantic token \*(Aqc\*(Aq
\&  %tree
\&
\&  pl@nereida:~/LEyapp/examples$ use_list3.pl
\&  ccdd
\&  $VAR1 = bless( {
\&           \*(Aqchildren\*(Aq => [
\&             bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&             bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&           ]
\&         }, \*(Aq_PLUS_LIST_1\*(Aq );
\&  $VAR1 = bless( { \*(Aqchildren\*(Aq => [] }, \*(Aq_PLUS_LIST_2\*(Aq );
.Ve
.PP
The node associated with the list of \f(CW\*(C`d\*(C'\fRs is empty since
terminal \f(CW\*(C`d\*(C'\fR wasn't declared semantic.
.PP
\fIWhen Nodes Dissappear from Lists\fR
.IX Subsection "When Nodes Dissappear from Lists"
.PP
When under the influence of the \f(CW%tree\fR directive
the action associated with a list operator
is to \fIflat\fR the children in a single list.
.PP
In the former example, the \f(CW\*(C`d\*(C'\fR nodes dont show up 
since \f(CW\*(Aqd\*(Aq\fR is a syntactic token. However, it may happen that changing the status
of \f(CW\*(Aqd\*(Aq\fR to semantic will not suffice.
.PP
When inserting the children, the tree (\f(CW%tree\fR)  node construction
method (\f(CW\*(C`YYBuildAST\*(C'\fR) omits any attribute that is not a reference.
Therefore, when inserting explicit actions, it is necessary to guarantee that 
the returned value is a reference or a semantic token 
to assure the presence of the value in the lists of children of the node.
Certainly you can use this property to prune parts of the tree.
Consider the following example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-19 ListWithRefs1.eyp | cat \-n
\&   1  # ListWithRefs.eyp
\&   2  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&   3  %{
\&   4  use Data::Dumper;
\&   5  %}
\&   6  %%
\&   7  S:      \*(Aqc\*(Aq+  D+
\&   8             {
\&   9                print Dumper($_[1]);
\&  10                print $_[1]\->str."\en";
\&  11                print Dumper($_[2]);
\&  12                print $_[2]\->str."\en";
\&  13             }
\&  14  ;
\&  15
\&  16  D: \*(Aqd\*(Aq
\&  17  ;
\&  18
\&  19  %%
.Ve
.PP
To activate the \fItree semantic\fR for lists we use the \f(CW\*(C`yybuildingtree\*(C'\fR
option of \f(CW\*(C`YYParse\*(C'\fR:
.PP
.Vb 8
\&  pl@nereida:~/LEyapp/examples$ tail \-7 ListWithRefs1.eyp | cat \-n
\&       1  sub Run {
\&       2      my($self)=shift;
\&       3      $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&       4        yybuildingtree => 1,
\&       5        #, yydebug => 0x1F
\&       6      );
\&       7  }
.Ve
.PP
The execution gives an ouput like this:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ eyapp ListWithRefs1.eyp; use_listwithrefs1.pl
\&  ccdd
\&  $VAR1 = bless( {
\&                   \*(Aqchildren\*(Aq => [
\&                                   bless( {
\&                                            \*(Aqchildren\*(Aq => [],
\&                                            \*(Aqattr\*(Aq => \*(Aqc\*(Aq,
\&                                            \*(Aqtoken\*(Aq => \*(Aqc\*(Aq
\&                                          }, \*(AqTERMINAL\*(Aq ),
\&                                   bless( {
\&                                            \*(Aqchildren\*(Aq => [],
\&                                            \*(Aqattr\*(Aq => \*(Aqc\*(Aq,
\&                                            \*(Aqtoken\*(Aq => \*(Aqc\*(Aq
\&                                          }, \*(AqTERMINAL\*(Aq )
\&                                 ]
\&                 }, \*(Aq_PLUS_LIST_1\*(Aq );
\&  _PLUS_LIST_1(TERMINAL,TERMINAL)
\&  $VAR1 = bless( {
\&                   \*(Aqchildren\*(Aq => []
\&                 }, \*(Aq_PLUS_LIST_2\*(Aq );
\&  _PLUS_LIST_2
.Ve
.PP
Though \f(CW\*(Aqd\*(Aq\fR was declared semantic the default action 
assoaciated with the production \f(CW\*(C`D: \*(Aqd\*(Aq\*(C'\fR in line 16
returns \f(CW$_[1]\fR (that is, the scalar \f(CW\*(Aqd\*(Aq\fR). Since it is not
a reference it won't be inserted in the list of children of
\&\f(CW\*(C`_PLUS_LIST\*(C'\fR.
.PP
\fIRecovering the Missing Nodes\fR
.IX Subsection "Recovering the Missing Nodes"
.PP
The solution is to be sure that the attribute is a reference:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-22 ListWithRefs.eyp | cat \-n
\&   1  # ListWithRefs.eyp
\&   2  %semantic token \*(Aqc\*(Aq
\&   3  %{
\&   4  use Data::Dumper;
\&   5  %}
\&   6  %%
\&   7  S:      \*(Aqc\*(Aq+  D+
\&   8             {
\&   9                print Dumper($_[1]);
\&  10                print $_[1]\->str."\en";
\&  11                print Dumper($_[2]);
\&  12                print $_[2]\->str."\en";
\&  13             }
\&  14  ;
\&  15
\&  16  D: \*(Aqd\*(Aq
\&  17       {
\&  18         bless { attr => $_[1], children =>[]}, \*(AqDES\*(Aq;
\&  19       }
\&  20  ;
\&  21
\&  22  %%
.Ve
.PP
Now the attribute associated with \f(CW\*(C`D\*(C'\fR is a reference 
and appears in the list of children of \f(CW\*(C`_PLUS_LIST\*(C'\fR:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ eyapp ListWithRefs.eyp; use_listwithrefs.pl
\&  ccdd
\&  $VAR1 = bless( {
\&                   \*(Aqchildren\*(Aq => [
\&                                   bless( {
\&                                            \*(Aqchildren\*(Aq => [],
\&                                            \*(Aqattr\*(Aq => \*(Aqc\*(Aq,
\&                                            \*(Aqtoken\*(Aq => \*(Aqc\*(Aq
\&                                          }, \*(AqTERMINAL\*(Aq ),
\&                                   bless( {
\&                                            \*(Aqchildren\*(Aq => [],
\&                                            \*(Aqattr\*(Aq => \*(Aqc\*(Aq,
\&                                            \*(Aqtoken\*(Aq => \*(Aqc\*(Aq
\&                                          }, \*(AqTERMINAL\*(Aq )
\&                                 ]
\&                 }, \*(Aq_PLUS_LIST_1\*(Aq );
\&  _PLUS_LIST_1(TERMINAL,TERMINAL)
\&  $VAR1 = bless( {
\&                   \*(Aqchildren\*(Aq => [
\&                                   bless( {
\&                                            \*(Aqchildren\*(Aq => [],
\&                                            \*(Aqattr\*(Aq => \*(Aqd\*(Aq
\&                                          }, \*(AqDES\*(Aq ),
\&                                   bless( {
\&                                            \*(Aqchildren\*(Aq => [],
\&                                            \*(Aqattr\*(Aq => \*(Aqd\*(Aq
\&                                          }, \*(AqDES\*(Aq )
\&                                 ]
\&                 }, \*(Aq_PLUS_LIST_2\*(Aq );
\&  _PLUS_LIST_2(DES,DES)
.Ve
.PP
\fIBuilding a Tree with \f(CI\*(C`Parse::Eyapp::Node\->new\*(C'\fI\fR
.IX Subsection "Building a Tree with Parse::Eyapp::Node->new"
.PP
The former solution consisting on writing \fIby hand\fR the code to 
build the node may suffice when dealing with a single node.
Writing by hand the code to build a node is a cumbersome task.
Even worst: though the node built in the former example
looks like a \f(CW\*(C`Parse::Eyapp\*(C'\fR node actually isn't. \f(CW\*(C`Parse::Eyapp\*(C'\fR 
nodes always inherit from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR and 
consequently have access to the methods in such package.
Thefollowing execution using the debugger illustrates the point:
.PP
.Vb 1
\&  pl@nereida:~/LEyapp/examples$ perl \-wd use_listwithrefs.pl
\&
\&  Loading DB routines from perl5db.pl version 1.28
\&  Editor support available.
\&
\&  Enter h or \`h h\*(Aq for help, or \`man perldebug\*(Aq for more help.
\&
\&  main::(use_listwithrefs.pl:4):  $parser = new ListWithRefs();
\&    DB<1>  f ListWithRefs.eyp
\&  1       2       #line 3 "ListWithRefs.eyp"
\&  3
\&  4:      use Data::Dumper;
\&  5
\&  6       #line 7 "ListWithRefs.eyp"
\&  7       #line 8 "ListWithRefs.eyp"
\&  8
\&  9:                    print Dumper($_[1]);
\&  10:                   print $_[1]\->str."\en";
.Ve
.PP
through the command \f(CW\*(C`f ListWithRefs.eyp\*(C'\fR we inform the debugger
that subsequent commands will refer to such file. Next 
we execute the program up to the semantic action
associated with the production rule \f(CW\*(C`S: \*(Aqc\*(Aq+  D+\*(C'\fR (line 9)
.PP
.Vb 4
\&    DB<2> c 9     # Continue up to line 9 of ListWithRefs.eyp
\&  ccdd
\&  ListWithRefs::CODE(0x84ebe5c)(ListWithRefs.eyp:9):
\&  9:                    print Dumper($_[1]);
.Ve
.PP
Now we are in condition to look at the contents 
of the arguments:
.PP
.Vb 7
\&    DB<3> x $_[2]\->str
\&  0  \*(Aq_PLUS_LIST_2(DES,DES)\*(Aq
\&    DB<4> x $_[2]\->child(0)
\&  0  DES=HASH(0x85c4568)
\&     \*(Aqattr\*(Aq => \*(Aqd\*(Aq
\&     \*(Aqchildren\*(Aq => ARRAY(0x85c458c)
\&          empty array
.Ve
.PP
the \f(CW\*(C`str\*(C'\fR method works with the object \f(CW$_[2]\fR since
\&\f(CW\*(C`_PLUS_LIST_2\*(C'\fR nodes inherit from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR.
However, when we try with the \f(CW\*(C`DES\*(C'\fR node we get an
error:
.PP
.Vb 4
\&    DB<6> x $_[2]\->child(0)\->str
\&  Can\*(Aqt locate object method "str" via package "DES" at \e
\&    (eval 11)[/usr/share/perl/5.8/perl5db.pl:628] line 2, <STDIN> line 1.
\&    DB<7>
.Ve
.PP
More robust than the former solution of building the node \fIby hand\fR
is to use the constructor \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR:
The method \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
is uset to build forests of syntactic trees.
.PP
It receives a  list of terms describing the trees and \- optionally \-
a reference to a subroutine used to set up the attributes
of the just created nodes. After the creation 
of the trees the sub is called by \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
with arguments the list of references to the nodes (in the order
in which they appear in the terms, from left to right).
\&\f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR returns a list of references 
to the jsut created nodes. In a scalar context returns a reference to the first of such trees.
See an example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ perl \-MParse::Eyapp \-MData::Dumper \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> @t = Parse::Eyapp::Node\->new(\*(AqA(C,D) E(F)\*(Aq, sub { my $i = 0; $_\->{n} = $i++ for @_ })
\&    DB<2> $Data::Dumper::Indent = 0
\&    DB<3> print Dumper($_)."\en" for @t
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 0,\*(Aqchildren\*(Aq => [bless( {\*(Aqn\*(Aq => 1,\*(Aqchildren\*(Aq => []}, \*(AqC\*(Aq ),
\&                                          bless( {\*(Aqn\*(Aq => 2,\*(Aqchildren\*(Aq => []}, \*(AqD\*(Aq )
\&                                         ]
\&                 }, \*(AqA\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 1,\*(Aqchildren\*(Aq => []}, \*(AqC\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 2,\*(Aqchildren\*(Aq => []}, \*(AqD\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 3,\*(Aqchildren\*(Aq => [bless( {\*(Aqn\*(Aq => 4,\*(Aqchildren\*(Aq => []}, \*(AqF\*(Aq )]}, \*(AqE\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 4,\*(Aqchildren\*(Aq => []}, \*(AqF\*(Aq );
.Ve
.PP
See the following example in which the nodes associated with \f(CW\*(Aqd\*(Aq\fR are
explictly constructed:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-28 ListWithRefs2.eyp| cat \-n
\&   1  # ListWithRefs2.eyp
\&   2  %semantic token \*(Aqc\*(Aq
\&   3  %{
\&   4  use Data::Dumper;
\&   5  %}
\&   6  %%
\&   7  S:  \*(Aqc\*(Aq+  D+
\&   8        {
\&   9           print Dumper($_[1]);
\&  10           print $_[1]\->str."\en";
\&  11           print Dumper($_[2]);
\&  12           print $_[2]\->str."\en";
\&  13        }
\&  14  ;
\&  15
\&  16  D: \*(Aqd\*(Aq.d
\&  17       {
\&  18         Parse::Eyapp::Node\->new(
\&  19           \*(AqDES(TERMINAL)\*(Aq,
\&  20            sub {
\&  21              my ($DES, $TERMINAL) = @_;
\&  22              $TERMINAL\->{attr} = $d;
\&  23            }
\&  24         );
\&  25       }
\&  26  ;
\&  27
\&  28  %%
.Ve
.PP
To know more about \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
see the Parse::Eyapp::Node section about \f(CW\*(C`new\*(C'\fR
.PP
When the former eyapp program is executed produces the following
output:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ eyapp ListWithRefs2.eyp; use_listwithrefs2.pl
\&  ccdd
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST_1\*(Aq );
\&  _PLUS_LIST_1(TERMINAL,TERMINAL)
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqDES\*(Aq ),
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqDES\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST_2\*(Aq );
\&  _PLUS_LIST_2(DES(TERMINAL),DES(TERMINAL))
.Ve
.PP
\fIThe \f(CI\*(C`*\*(C'\fI operator\fR
.IX Subsection "The * operator"
.PP
Any list operator operates on the factor to its left.
A list in the right hand side of a production rule
counts as a single symbol.
.PP
Both operators \f(CW\*(C`*\*(C'\fR and \f(CW\*(C`+\*(C'\fR can be used 
with the format
\&\f(CW\*(C`X <* Separator>\*(C'\fR.
In such case they describe lists of \f(CW\*(C`X\*(C'\fRs separated by 
\&\f(CW\*(C`separator\*(C'\fR. See an example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-25 CsBetweenCommansAndD.eyp | cat \-n
\&   1  # CsBetweenCommansAndD.eyp
\&   2
\&   3  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&   4
\&   5  %{
\&   6  sub TERMINAL::info {
\&   7    $_[0]\->attr;
\&   8  }
\&   9  %}
\&  10  %tree
\&  11  %%
\&  12  S:
\&  13      (\*(Aqc\*(Aq <* \*(Aq,\*(Aq> \*(Aqd\*(Aq)*
\&  14        {
\&  15           print "\enNode\en";
\&  16           print $_[1]\->str."\en";
\&  17           print "\enChild 0\en";
\&  18           print $_[1]\->child(0)\->str."\en";
\&  19           print "\enChild 1\en";
\&  20           print $_[1]\->child(1)\->str."\en";
\&  21           $_[1]
\&  22        }
\&  23  ;
\&  24
\&  25  %%
.Ve
.PP
The rule
.PP
.Vb 1
\&                            S: (\*(Aqc\*(Aq <* \*(Aq,\*(Aq> \*(Aqd\*(Aq)*
.Ve
.PP
has only two items in its right hand side: the (separated by commas) list
of \f(CW\*(C`c\*(C'\fRs and the list of \f(CW\*(C`d\*(C'\fRs.  The production rule is equivalent to:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v CsBetweenCommansAndD.eyp
\&  pl@nereida:~/LEyapp/examples$ head \-11 CsBetweenCommansAndD.output | cat \-n
\&   1  Rules:
\&   2  \-\-\-\-\-\-
\&   3  0:      $start \-> S $end
\&   4  1:      STAR\-1 \-> STAR\-1 \*(Aq,\*(Aq \*(Aqc\*(Aq
\&   5  2:      STAR\-1 \-> \*(Aqc\*(Aq
\&   6  3:      STAR\-2 \-> STAR\-1
\&   7  4:      STAR\-2 \-> /* empty */
\&   8  5:      PAREN\-3 \-> STAR\-2 \*(Aqd\*(Aq
\&   9  6:      STAR\-4 \-> STAR\-4 PAREN\-3
\&  10  7:      STAR\-4 \-> /* empty */
\&  11  8:      S \-> STAR\-4
.Ve
.PP
The semantic action associated with \f(CW\*(C`*\*(C'\fR is to return 
a reference to a list with the attributes of the 
matching items.
.PP
When working \-as in the example \-
under a tree creation directive it returns
a node belonging to a class named \f(CW\*(C`_STAR_LIST_#number\*(C'\fR
whose children are the items in the list.
The \f(CW\*(C`#number\*(C'\fR is the ordinal number of the production rule
as it appears in the \f(CW\*(C`.output\*(C'\fR file. The attributes must be 
references or associated with semantic tokens to be included 
in the list. Notice \-in the execution of the former
example  that follows \-
how the node for \f(CW\*(C`PAREN\-3\*(C'\fR has been 
eliminated from the tree. Parenthesis nodes are \- generally \-
obivated:
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples$ use_csbetweencommansandd.pl
\&  c,c,cd
\&
\&  Node
\&  _STAR_LIST_4(_STAR_LIST_1(TERMINAL[c],TERMINAL[c],TERMINAL[c]),TERMINAL[d])
\&
\&  Child 0
\&  _STAR_LIST_1(TERMINAL[c],TERMINAL[c],TERMINAL[c])
\&
\&  Child 1
\&  TERMINAL[d]
.Ve
.PP
Notice that the comma (since it is a syntactic token) has 
also been supressed.
.PP
\fIGiving Names to Lists\fR
.IX Subsection "Giving Names to Lists"
.PP
To set the name of the node associated with a list operator the
\&\f(CW%name\fR directive must precede the operator as in 
the following example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ sed \-ne \*(Aq1,27p\*(Aq CsBetweenCommansAndDWithNames.eyp | cat \-n
\&   1  # CsBetweenCommansAndDWithNames.eyp
\&   2
\&   3  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&   4
\&   5  %{
\&   6  sub TERMINAL::info {
\&   7    $_[0]\->attr;
\&   8  }
\&   9  %}
\&  10  %tree
\&  11  %%
\&  12  Start: S
\&  13  ;
\&  14  S:
\&  15      (\*(Aqc\*(Aq <%name Cs * \*(Aq,\*(Aq> \*(Aqd\*(Aq) %name Cs_and_d *
\&  16        {
\&  17           print "\enNode\en";
\&  18           print $_[1]\->str."\en";
\&  19           print "\enChild 0\en";
\&  20           print $_[1]\->child(0)\->str."\en";
\&  21           print "\enChild 1\en";
\&  22           print $_[1]\->child(1)\->str."\en";
\&  23           $_[1]
\&  24        }
\&  25  ;
\&  26
\&  27  %%
.Ve
.PP
The execution shows the renamed nodes:
.PP
pl@nereida:~/LEyapp/examples$ use_csbetweencommansanddwithnames.pl
c,c,c,cd
.PP
.Vb 2
\&  Node
\&  Cs_and_d(Cs(TERMINAL[c],TERMINAL[c],TERMINAL[c],TERMINAL[c]),TERMINAL[d])
\&
\&  Child 0
\&  Cs(TERMINAL[c],TERMINAL[c],TERMINAL[c],TERMINAL[c])
\&
\&  Child 1
\&  TERMINAL[d]
.Ve
.PP
\fIOptionals\fR
.IX Subsection "Optionals"
.PP
The \f(CW\*(C`X?\*(C'\fR operator stands for the presence or omission
of \f(CW\*(C`X\*(C'\fR.
.PP
The grammar:
.PP
.Vb 12
\&  pl@nereida:~/LEyapp/examples$ head \-11 List5.yp | cat \-n
\&       1  %semantic token \*(Aqc\*(Aq
\&       2  %tree
\&       3  %%
\&       4  S: \*(Aqc\*(Aq \*(Aqc\*(Aq?
\&       5       {
\&       6         print $_[2]\->str."\en";
\&       7         print $_[2]\->child(0)\->attr."\en" if $_[2]\->children;
\&       8      }
\&       9  ;
\&      10
\&      11  %%
.Ve
.PP
is equivalent to:
.PP
.Vb 8
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v List5
\&  pl@nereida:~/LEyapp/examples$ head \-7 List5.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> S $end
\&  1:      OPTIONAL\-1 \-> \*(Aqc\*(Aq
\&  2:      OPTIONAL\-1 \-> /* empty */
\&  3:      S \-> \*(Aqc\*(Aq OPTIONAL\-1
.Ve
.PP
When \f(CW\*(C`yybuildingtree\*(C'\fR is false the associated attribute 
is a list that will be empty if \s-1CX\s0> does not show up.
.PP
Under the \f(CW%tree\fR directive the action creates an c<_OPTIONAL>
node:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ use_list5.pl
\&  cc
\&  _OPTIONAL_1(TERMINAL)
\&  c
\&  pl@nereida:~/LEyapp/examples$ use_list5.pl
\&  c
\&  _OPTIONAL_1
.Ve
.PP
\fIParenthesis\fR
.IX Subsection "Parenthesis"
.PP
Any substring on the right hand side of a production rule can be grouped
using a parenthesis. The introduction of a parenthesis implies the introduction
of an additional syntactic variable whose only production 
is the sequence of symbols between the parenthesis. Thus the grammar:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ head \-6 Parenthesis.eyp | cat \-n
\&     1  %%
\&     2  S:
\&     3        (\*(Aqa\*(Aq S ) \*(Aqb\*(Aq  { shift; [ @_ ] }
\&     4      | \*(Aqc\*(Aq
\&     5  ;
\&     6  %%
.Ve
.PP
is equivalent to:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v Parenthesis.eyp; head \-6 Parenthesis.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> S $end
\&  1:      PAREN\-1 \-> \*(Aqa\*(Aq S
\&  2:      S \-> PAREN\-1 \*(Aqb\*(Aq
\&  3:      S \-> \*(Aqc\*(Aq
.Ve
.PP
By default the semantic rule associated with a parenthesis
returns an anonymous list with the attributes of the symbols 
between the parenthesis:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n use_parenthesis.pl
\&       1  #!/usr/bin/perl \-w
\&       2  use Parenthesis;
\&       3  use Data::Dumper;
\&       4
\&       5  $Data::Dumper::Indent = 1;
\&       6  $parser = Parenthesis\->new();
\&       7  print Dumper($parser\->Run);
\&  pl@nereida:~/LEyapp/examples$ use_parenthesis.pl
\&  acb
\&  $VAR1 = [
\&    [ \*(Aqa\*(Aq, \*(Aqc\*(Aq ], \*(Aqb\*(Aq
\&  ];
\&  pl@nereida:~/LEyapp/examples$ use_parenthesis.pl
\&  aacbb
\&  $VAR1 = [
\&    [
\&      \*(Aqa\*(Aq,
\&      [ [ \*(Aqa\*(Aq, \*(Aqc\*(Aq ], \*(Aqb\*(Aq ]
\&    ],
\&    \*(Aqb\*(Aq
\&  ];
.Ve
.PP
when working under a tree directive or when the attribute
\&\f(CW\*(C`buildingtree\*(C'\fR is set via the\f(CW\*(C`YYBuildingtree\*(C'\fR method
the semantic action returns a node with children the attributes
of the symbols between parenthesis. As usual attributes
which aren't references will be skipped from the list of children.
See an example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-23 List2.yp | cat \-n
\&   1  %{
\&   2  use Data::Dumper;
\&   3  %}
\&   4  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq \*(Aqc\*(Aq
\&   5  %tree
\&   6  %%
\&   7  S:
\&   8        (%name AS \*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&   9          {
\&  10            print "S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\en";
\&  11            print "Attribute of the first symbol:\en".Dumper($_[1]);
\&  12            print "Attribute of the second symbol: $_[2]\en";
\&  13            $_[0]\->YYBuildAST(@_[1..$#_]);
\&  14          }
\&  15      | \*(Aqc\*(Aq
\&  16          {
\&  17            print "S \-> \*(Aqc\*(Aq\en";
\&  18            my $r = Parse::Eyapp::Node\->new(qw(C(TERMINAL)), sub { $_[1]\->attr(\*(Aqc\*(Aq) }) ;
\&  19            print Dumper($r);
\&  20            $r;
\&  21          }
\&  22  ;
\&  23  %%
.Ve
.PP
The example shows (line 8)
how to rename a \f(CW\*(C`_PAREN\*(C'\fR node. The \f(CW\*(C`%name CLASSNAME\*(C'\fR goes
after the opening parenthesis.
.PP
The call to \f(CW\*(C`YYBuildAST\*(C'\fR at line 13
with argumetns the attributes of the symbols on the right hand side
returns the node describing the current production rule.
Notice that line 13 can be rewritten as:
.PP
.Vb 1
\&                    goto &Parse::Eyapp::Driver::YYBuildAST;
.Ve
.PP
At line 18 the node for the rule is explictly created
using \f(CW\*(C`Parse::Eyapp::Node\-\*(C'\fRnew>. The handler passed as second argument
is responsible for setting the value of the atribute \f(CW\*(C`attr\*(C'\fR
of the just created \f(CW\*(C`TERMINAL\*(C'\fR node.
.PP
Let us see an execution:
.PP
.Vb 11
\&  pl@nereida:~/LEyapp/examples$ use_list2.pl
\&  aacbb
\&  S \-> \*(Aqc\*(Aq
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( {
\&        \*(Aqchildren\*(Aq => [],
\&        \*(Aqattr\*(Aq => \*(Aqc\*(Aq
\&      }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(AqC\*(Aq );
.Ve
.PP
the first reduction occurs by the non recursive rule. The execution
shows the tree built by the call to
\&\f(CW\*(C`Parse::Eyapp::Node\-\*(C'\fRnew>
at line 18.
.PP
The execution continues with the reduction or antiderivation by the rule
\&\f(CW\*(C`S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\*(C'\fR. The action at lines 9\-14
dumps the attribute associated with \f(CW\*(C`(\*(Aqa\*(Aq S)\*(C'\fR
\&\- or, in other words,  the attribute associated with the variable 
\&\f(CW\*(C`PAREN\-1\*(C'\fR. It also dumps the attribute of \f(CW\*(Aqb\*(Aq\fR:
.PP
.Vb 11
\&  S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&  Attribute of the first symbol:
\&  $VAR1 = bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&        bless( { \*(Aqchildren\*(Aq => [ bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&       ]
\&     }, \*(AqC\*(Aq )
\&    ]
\&  }, \*(AqAS\*(Aq );
\&Attribute of the second symbol: b
.Ve
.PP
The last reduction shown is by the rule:
\&\f(CW\*(C`S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\*(C'\fR:
.PP
.Vb 10
\&  S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&  Attribute of the first symbol:
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( {
\&            \*(Aqchildren\*(Aq => [
\&              bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&              bless( {
\&                \*(Aqchildren\*(Aq => [
\&                  bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&                ]
\&              }, \*(AqC\*(Aq )
\&            ]
\&          }, \*(AqAS\*(Aq ),
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqb\*(Aq, \*(Aqtoken\*(Aq => \*(Aqb\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqS_2\*(Aq )
\&    ]
\&  }, \*(AqAS\*(Aq );
\&  Attribute of the second symbol: b
.Ve
.PP
\fIActions Inside Parenthesis\fR
.IX Subsection "Actions Inside Parenthesis"
.PP
Though is a practice to avoid, since it clutters
the code, it is certainly permitted to introduce
actions between the parenthesis, as in the example below:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-16 ListAndAction.eyp | cat \-n
\&   1  # ListAndAction.eyp
\&   2  %{
\&   3  my $num = 0;
\&   4  %}
\&   5
\&   6  %%
\&   7  S:      \*(Aqc\*(Aq
\&   8              {
\&   9                print "S \-> c\en"
\&  10              }
\&  11      |    (\*(Aqa\*(Aq {$num++; print "Seen <$num> \*(Aqa\*(Aqs\en"; $_[1] }) S \*(Aqb\*(Aq
\&  12              {
\&  13                print "S \-> (a ) S b\en"
\&  14              }
\&  15  ;
\&  16  %%
.Ve
.PP
This is the output when executing this program with input \f(CW\*(C`aaacbbb\*(C'\fR:
.PP
.Vb 9
\&  pl@nereida:~/LEyapp/examples$ use_listandaction.pl
\&  aaacbbb
\&  Seen <1> \*(Aqa\*(Aqs
\&  Seen <2> \*(Aqa\*(Aqs
\&  Seen <3> \*(Aqa\*(Aqs
\&  S \-> c
\&  S \-> (a ) S b
\&  S \-> (a ) S b
\&  S \-> (a ) S b
.Ve
.SS "Names for attributes"
.IX Subsection "Names for attributes"
Attributes can be referenced by meaningful names instead
of the classic error-prone positional approach using the \fIdot notation\fR:
.PP
.Vb 5
\&                        rhs:  rhseltwithid *
\&                        rhseltwithid : 
\&                              rhselt \*(Aq.\*(Aq IDENT 
\&                            | \*(Aq$\*(Aq rhselt  
\&                            | rhselt
.Ve
.PP
for example:
.PP
.Vb 1
\&              exp : exp.left \*(Aq\-\*(Aq exp.right  { $left \- $right }
.Ve
.PP
By qualifying the first appearance of the syntactic variable \f(CW\*(C`exp\*(C'\fR
with the notation \f(CW\*(C`exp.left\*(C'\fR we can later refer inside the actions
to the associated attribute using the lexical variable
\&\f(CW$left\fR.
.PP
The \fIdolar notation\fR \f(CW$A\fR can be used as an abbreviation
of \f(CW\*(C`A.A\*(C'\fR.
.SS "Default actions"
.IX Subsection "Default actions"
When no action is specified both \f(CW\*(C`yapp\*(C'\fR and \f(CW\*(C`eyapp\*(C'\fR
implicitly insert the semantic action \f(CW\*(C`{ $_[1] }\*(C'\fR. 
In \f(CW\*(C`Parse::Eyapp\*(C'\fR you can modify such behavior using the \f(CW\*(C`%defaultaction { Perl code }\*(C'\fR
directive. The \f(CW\*(C`{ Perl code }\*(C'\fR clause that follows the \f(CW%defaultaction\fR
directive is
executed when reducing by any production for which no explicit
action was specified.
.PP
\fITranslator from Infix to Postfix\fR
.IX Subsection "Translator from Infix to Postfix"
.PP
See an example that translates an infix expression
like \f(CW\*(C`a=b*\-3\*(C'\fR into a postfix expression like \f(CW\*(C`a b 3 NEG * = \*(C'\fR:
.PP
.Vb 5
\& # File Postfix.eyp (See the examples/ directory)
\& %right  \*(Aq=\*(Aq
\& %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\& %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\& %left   NEG
\&
\& %defaultaction { return  "$left $right $op"; }
\&
\& %%
\& line: $exp  { print "$exp\en" }
\& ;
\&
\& exp:        $NUM  { $NUM }
\&         |   $VAR  { $VAR }
\&         |   VAR.left \*(Aq=\*(Aq.op exp.right
\&         |   exp.left \*(Aq+\*(Aq.op exp.right
\&         |   exp.left \*(Aq\-\*(Aq.op exp.right
\&         |   exp.left \*(Aq*\*(Aq.op exp.right
\&         |   exp.left \*(Aq/\*(Aq.op exp.right
\&         |   \*(Aq\-\*(Aq $exp %prec NEG { "$exp NEG" }
\&         |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq { $exp }
\& ;
\&
\& %%
\&
\& # Support subroutines as in the Synopsis example
\& ...
.Ve
.PP
The file containing the \f(CW\*(C`Eyapp\*(C'\fR program must be compiled with \f(CW\*(C`eyapp\*(C'\fR:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> eyapp Postfix.eyp
.Ve
.PP
Next, you have to write a client program:
.PP
.Vb 7
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n usepostfix.pl
\&      1  #!/usr/bin/perl \-w
\&      2  use strict;
\&      3  use Postfix;
\&      4
\&      5  my $parser = new Postfix();
\&      6  $parser\->Run;
.Ve
.PP
Now we can run the client program:
.PP
.Vb 3
\& nereida:~/src/perl/YappWithDefaultAction/examples> usepostfix.pl
\& Write an expression: \-(2*a\-b*\-3)
\& 2 a * b 3 NEG * \- NEG
.Ve
.PP
\fIDefault Actions, \f(CI%name\fI and \f(CI\*(C`YYName\*(C'\fI\fR
.IX Subsection "Default Actions, %name and YYName"
.PP
In \f(CW\*(C`eyapp\*(C'\fR each production rule has a name.
The name of a rule can be explicitly given by the programmer 
using the \f(CW%name\fR directive. For example, in the piece of code
that follows the name \f(CW\*(C`ASSIGN\*(C'\fR is given to the rule \f(CW\*(C`exp: VAR \*(Aq=\*(Aq exp\*(C'\fR.
.PP
When no explicit name is given the rule has an implicit name.
The implicit name of a rule is shaped by concatenating
the name of the syntactic variable on its left, an underscore 
and the ordinal number of the production rule \f(CW\*(C`Lhs_#\*(C'\fR
as it appears in the \f(CW\*(C`.output\*(C'\fR file.
Avoid giving names matching such pattern to production rules.
The patterns
\&\f(CW\*(C`/${lhs}_\ed+$/\*(C'\fR where \f(CW\*(C`${lhs}\*(C'\fR is the name of the syntactic variable
are reserved for internal use by \f(CW\*(C`eyapp\*(C'\fR.
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n Lhs.eyp
\&   1  # Lhs.eyp
\&   2
\&   3  %right  \*(Aq=\*(Aq
\&   4  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&   5  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&   6  %left   NEG
\&   7
\&   8  %defaultaction {
\&   9    my $self = shift;
\&  10    my $name = $self\->YYName();
\&  11    bless { children => [ grep {ref($_)} @_] }, $name;
\&  12  }
\&  13
\&  14  %%
\&  15  input:
\&  16              /* empty */
\&  17                { [] }
\&  18          |   input line
\&  19                {
\&  20                  push @{$_[1]}, $_[2] if defined($_[2]);
\&  21                  $_[1]
\&  22                }
\&  23  ;
\&  24
\&  25  line:     \*(Aq\en\*(Aq       { }
\&  26          | exp \*(Aq\en\*(Aq   {  $_[1] }
\&  27  ;
\&  28
\&  29  exp:
\&  30              NUM   { $_[1] }
\&  31          |   VAR   { $_[1] }
\&  32          |   %name ASSIGN
\&  33              VAR \*(Aq=\*(Aq exp
\&  34          |   %name PLUS
\&  35              exp \*(Aq+\*(Aq exp
\&  36          |   %name MINUS
\&  37              exp \*(Aq\-\*(Aq exp
\&  38          |   %name TIMES
\&  39              exp \*(Aq*\*(Aq exp
\&  40          |   %name DIV
\&  41              exp \*(Aq/\*(Aq exp
\&  42          |   %name UMINUS
\&  43              \*(Aq\-\*(Aq exp %prec NEG
\&  44          |  \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&  45  ;
.Ve
.PP
Inside a semantic action
the name of the current rule can be recovered 
using the method \f(CW\*(C`YYName\*(C'\fR of the parser object.
.PP
The default action (lines 8\-12) computes as attribute of the left
hand side a reference to an object blessed in the name of the rule.
The object has an attribute \f(CW\*(C`children\*(C'\fR which is a reference 
to the list of children of the node.
The call to \f(CW\*(C`grep\*(C'\fR
.PP
.Vb 1
\&  11    bless { children => [ grep {ref($_)} @_] }, $name;
.Ve
.PP
excludes children that aren't references. Notice that the lexical analyzer 
only returns references for the \f(CW\*(C`NUM\*(C'\fR and \f(CW\*(C`VAR\*(C'\fR terminals:
.PP
.Vb 10
\&  59  sub _Lexer {
\&  60      my($parser)=shift;
\&  61
\&  62      for ($parser\->YYData\->{INPUT}) {
\&  63          s/^[ \et]+//;
\&  64          return(\*(Aq\*(Aq,undef) unless $_;
\&  65          s/^([0\-9]+(?:\e.[0\-9]+)?)//
\&  66                  and return(\*(AqNUM\*(Aq, bless { attr => $1}, \*(AqNUM\*(Aq);
\&  67          s/^([A\-Za\-z][A\-Za\-z0\-9_]*)//
\&  68                  and return(\*(AqVAR\*(Aq,bless {attr => $1}, \*(AqVAR\*(Aq);
\&  69          s/^(.)//s
\&  70                  and return($1, $1);
\&  71      }
\&  72      return(\*(Aq\*(Aq,undef);
\&  73  }
.Ve
.PP
follows the client program:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n uselhs.pl
\&       1  #!/usr/bin/perl \-w
\&       2  use Lhs;
\&       3  use Data::Dumper;
\&       4
\&       5  $parser = new Lhs();
\&       6  my $tree = $parser\->Run;
\&       7  $Data::Dumper::Indent = 1;
\&       8  if (defined($tree)) { print Dumper($tree); }
\&       9  else { print "Cadena no va\*'lida\en"; }
.Ve
.PP
When executed with input \f(CW\*(C`a=(2+3)*b\*(C'\fR the parser produces
the following tree:
.PP
.Vb 1
\&  ASSIGN(TIMES(PLUS(NUM[2],NUM[3]), VAR[b]))
.Ve
.PP
See the result of an execution:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ uselhs.pl
\&  a=(2+3)*b
\&  $VAR1 = [
\&    bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqattr\*(Aq => \*(Aqa\*(Aq }, \*(AqVAR\*(Aq ),
\&        bless( {
\&          \*(Aqchildren\*(Aq => [
\&            bless( {
\&              \*(Aqchildren\*(Aq => [
\&                bless( { \*(Aqattr\*(Aq => \*(Aq2\*(Aq }, \*(AqNUM\*(Aq ),
\&                bless( { \*(Aqattr\*(Aq => \*(Aq3\*(Aq }, \*(AqNUM\*(Aq )
\&              ]
\&            }, \*(AqPLUS\*(Aq ),
\&            bless( { \*(Aqattr\*(Aq => \*(Aqb\*(Aq }, \*(AqVAR\*(Aq )
\&          ]
\&        }, \*(AqTIMES\*(Aq )
\&      ]
\&    }, \*(AqASSIGN\*(Aq )
\&  ];
.Ve
.PP
The name of a production rule can be changed at execution time.
See the following example:
.PP
.Vb 10
\&  29  exp:
\&  30              NUM   { $_[1] }
\&  31          |   VAR   { $_[1] }
\&  32          |   %name ASSIGN
\&  33              VAR \*(Aq=\*(Aq exp
\&  34          |   %name PLUS
\&  35              exp \*(Aq+\*(Aq exp
\&  36          |   %name MINUS
\&  37              exp \*(Aq\-\*(Aq exp
\&  38                {
\&  39                  my $self = shift;
\&  40                  $self\->YYName(\*(AqSUBSTRACT\*(Aq); # rename it
\&  41                  $self\->YYBuildAST(@_); # build the node
\&  42                }
\&  43          |   %name TIMES
\&  44              exp \*(Aq*\*(Aq exp
\&  45          |   %name DIV
\&  46              exp \*(Aq/\*(Aq exp
\&  47          |   %name UMINUS
\&  48              \*(Aq\-\*(Aq exp %prec NEG
\&  49          |  \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&  50  ;
.Ve
.PP
When the client program is executed we can see the presence
of the \f(CW\*(C`SUBSTRACT\*(C'\fR nodes:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ useyynamedynamic.pl
\&  2\-b
\&  $VAR1 = [
\&    bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( {
\&          \*(Aqattr\*(Aq => \*(Aq2\*(Aq
\&        }, \*(AqNUM\*(Aq ),
\&        bless( {
\&          \*(Aqattr\*(Aq => \*(Aqb\*(Aq
\&        }, \*(AqVAR\*(Aq )
\&      ]
\&    }, \*(AqSUBSTRACT\*(Aq )
\&  ];
.Ve
.ie n .SS "Abstract Syntax Trees : %tree and %name"
.el .SS "Abstract Syntax Trees : \f(CW%tree\fP and \f(CW%name\fP"
.IX Subsection "Abstract Syntax Trees : %tree and %name"
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR facilitates the construction of concrete syntax trees and 
abstract syntax trees (abbreviated \s-1AST\s0 from now on) through the \f(CW%tree\fR
directive. 
Nodes in the \s-1AST\s0 are blessed in the production
\&\f(CW\*(C`name\*(C'\fR. 
By default the name of a production is the concatenation
of the left hand side and the production number. The production number
is the ordinal number of the production as they appear in the associated 
\&\f(CW\*(C`.output\*(C'\fR file (see option \f(CW\*(C`\-v\*(C'\fR of eyapp). For example,
given the grammar:
.PP
.Vb 7
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq9,28p\*(Aq treewithoutnames.pl
\& my $grammar = q{
\&   %right  \*(Aq=\*(Aq     # Lowest precedence
\&   %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&   %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&   %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&   %tree           # Let us build an abstract syntax tree ...
\&
\&   %%
\&   line: exp <+ \*(Aq;\*(Aq>  { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&   ;
\&
\&   exp:
\&        NUM           |   VAR       | VAR \*(Aq=\*(Aq exp
\&     | exp \*(Aq+\*(Aq exp    | exp \*(Aq\-\*(Aq exp |  exp \*(Aq*\*(Aq exp
\&     | exp \*(Aq/\*(Aq exp
\&     | \*(Aq\-\*(Aq exp %prec NEG
\&     |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&   ;
.Ve
.PP
The tree produced by the parser when feed with input \f(CW\*(C`a=2*b\*(C'\fR
is:
.PP
.Vb 1
\& _PLUS_LIST(exp_6(TERMINAL[a],exp_9(exp_4(TERMINAL[2]),exp_5(TERMINAL[b]))))
.Ve
.PP
If we want to see the correspondence between names and rules we can generate and
check the corresponding file \f(CW\*(C`.output\*(C'\fR:
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq28,42p\*(Aq treewithoutnames.output
\& Rules:
\& \-\-\-\-\-\-
\& 0:      $start \-> line $end
\& 1:      PLUS\-1 \-> PLUS\-1 \*(Aq;\*(Aq exp
\& 2:      PLUS\-1 \-> exp
\& 3:      line \-> PLUS\-1
\& 4:      exp \-> NUM
\& 5:      exp \-> VAR
\& 6:      exp \-> VAR \*(Aq=\*(Aq exp
\& 7:      exp \-> exp \*(Aq+\*(Aq exp
\& 8:      exp \-> exp \*(Aq\-\*(Aq exp
\& 9:      exp \-> exp \*(Aq*\*(Aq exp
\& 10:     exp \-> exp \*(Aq/\*(Aq exp
\& 11:     exp \-> \*(Aq\-\*(Aq exp
\& 12:     exp \-> \*(Aq(\*(Aq exp \*(Aq)\*(Aq
.Ve
.PP
We can see now that the node \f(CW\*(C`exp_9\*(C'\fR corresponds to the production \f(CW\*(C`exp \-> exp \*(Aq*\*(Aq exp\*(C'\fR.
Observe also that the Eyapp production:
.PP
.Vb 2
\&                                line: exp <+ \*(Aq;\*(Aq>
\&actually produces the productions:
\&
\&                        1:      PLUS\-1 \-> PLUS\-1 \*(Aq;\*(Aq exp
\&                        2:      PLUS\-1 \-> exp
.Ve
.PP
and that the name of the class associated with the non empty list is \f(CW\*(C`_PLUS_LIST\*(C'\fR.
.PP
A production rule can be 
\&\fInamed\fR using the \f(CW\*(C`%name IDENTIFIER\*(C'\fR directive. 
For each production rule a 
namespace/package is created. \fIThe\fR \f(CW\*(C`IDENTIFIER\*(C'\fR
\&\fIis the name of the associated package\fR.
Therefore, by modifying the former grammar with 
additional \f(CW%name\fR directives:
.PP
.Vb 7
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq8,26p\*(Aq treewithnames.pl
\& my $grammar = q{
\&   %right  \*(Aq=\*(Aq     # Lowest precedence
\&   %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&   %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&   %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&   %tree           # Let us build an abstract syntax tree ...
\&
\&   %%
\&   line: exp <%name EXPS + \*(Aq;\*(Aq>  { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&   ;
\&
\&   exp:
\&       %name NUM    NUM           | %name VAR   VAR         | %name ASSIGN VAR \*(Aq=\*(Aq exp
\&     | %name PLUS   exp \*(Aq+\*(Aq exp   | %name MINUS exp \*(Aq\-\*(Aq exp | %name TIMES  exp \*(Aq*\*(Aq exp
\&     | %name DIV    exp \*(Aq/\*(Aq exp
\&     | %name UMINUS \*(Aq\-\*(Aq exp %prec NEG
\&     |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&   ;
.Ve
.PP
we are explictly naming the productions. Thus, all the node instances 
corresponding to the 
production \f(CW\*(C`exp: VAR \*(Aq=\*(Aq exp\*(C'\fR will belong to the class \f(CW\*(C`ASSIGN\*(C'\fR. Now 
the tree for \f(CW\*(C`a=2*b\*(C'\fR becomes:
.PP
.Vb 1
\&          EXPS(ASSIGN(TERMINAL[a],TIMES(NUM(TERMINAL[2]),VAR(TERMINAL[b]))))
.Ve
.PP
Observe how the list has been named \f(CW\*(C`EXPS\*(C'\fR. The \f(CW%name\fR directive prefixes the 
list operator (\f(CW\*(C`[+*?]\*(C'\fR).
.PP
\fIAbout the Encapsulation of Nodes\fR
.IX Subsection "About the Encapsulation of Nodes"
.PP
There is no encapsulation of nodes. The user/client 
knows that they are hashes that can be decorated with new keys/attributes.
All nodes in the \s-1AST\s0 created by \f(CW%tree\fR are \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR nodes.
The only reserved field is \f(CW\*(C`children\*(C'\fR which is a reference to the
array of children. You can always create a \f(CW\*(C`Node\*(C'\fR class 
\&\fIby hand\fR by inheriting from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR. See 
section 'Compiling with eyapp and treereg' in Parse::Eyapp for an example.
.PP
\fI\s-1TERMINAL\s0 Nodes\fR
.IX Subsection "TERMINAL Nodes"
.PP
Nodes named \f(CW\*(C`TERMINAL\*(C'\fR are built from the
tokens provided by the lexical analyzer. 
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR follows the same protocol
than Parse::Yapp for communication between the parser and the lexical analyzer:
A couple \f(CW\*(C`($token, $attribute)\*(C'\fR is returned by the lexical analyzer.
These values are stored under the keys \f(CW\*(C`token\*(C'\fR and \f(CW\*(C`attr\*(C'\fR.
\&\f(CW\*(C`TERMINAL\*(C'\fR nodes as all \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR nodes
also have the attribute \f(CW\*(C`children\*(C'\fR but is \- almost always \- empty.
.PP
\fIExplicit Actions Inside \f(CI%tree\fI\fR
.IX Subsection "Explicit Actions Inside %tree"
.PP
Explicit actions can be specified by the programmer like in this line
from the Parse::Eyapp \f(CW\*(C`SYNOPSIS\*(C'\fR example:
.PP
.Vb 1
\&      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }  /* Let us simplify a bit the tree */
.Ve
.PP
Explicit actions receive as arguments the references to the children nodes already 
built. The programmer can influence the shape of the tree by inserting
these explicit actions. In this example the programmer has decided to simplify the 
syntax tree: the nodes associated with the parenthesis are 
discarded and the reference to the subtree containing the proper
expression is returned. Such manoeuvre is called \fIbypassing\fR.
See section \*(L"The  bypass clause and the \f(CW%no\fR bypass directive\*(R"
to know more about \fIautomatic bypassing\fR
.PP
\fIExplicitly Building Nodes With \f(CI\*(C`YYBuildAST\*(C'\fI\fR
.IX Subsection "Explicitly Building Nodes With YYBuildAST"
.PP
Sometimes the best time to decorate a node with some
attributes is just after being built.
In such cases the programmer can take \fImanual control\fR
building the node with \f(CW\*(C`YYBuildAST\*(C'\fR to 
inmediately proceed to decorate it.
.PP
The following example illustrates the situation:
.PP
.Vb 9
\& Variable:
\&     %name  VARARRAY
\&     $ID (\*(Aq[\*(Aq binary \*(Aq]\*(Aq) <%name INDEXSPEC +>
\&       {
\&         my $self = shift;
\&         my $node =  $self\->YYBuildAST(@_);
\&         $node\->{line} = $ID\->[1];
\&         return $node;
\&       }
.Ve
.PP
This production rule defines the expression to access an array element 
as an identifier followed by
a non empty list of binary expressions \f(CW\*(C` Variable: ID (\*(Aq[\*(Aq binary \*(Aq]\*(Aq)+\*(C'\fR. 
Furthermore, the node corresponding
to the list of indices has been named \f(CW\*(C`INDEXSPEC\*(C'\fR.
.PP
When no explicit action is
inserted a binary node will be built having as first child the node
corresponding to the identifier \f(CW$ID\fR and as second child the reference 
to the list of binary expressions. The children corresponding to
\&\f(CW\*(Aq[\*(Aq\fR and \f(CW\*(Aq]\*(Aq\fR are discarded since they are \-by default\- \fIsyntactic tokens\fR
(see section \*(L"Syntactic and Semantic tokens\*(R").
However, the programmer wants to decorate
the node being built with a \f(CW\*(C`line\*(C'\fR attribute holding the line number in the source
code where the identifier being used appears. The call to the \f(CW\*(C`Parse::Eyapp::Driver\*(C'\fR
method \f(CW\*(C`YYBuildAST\*(C'\fR does the job of building the node. After
that the node can be decorated and returned.
.PP
Actually, the \f(CW%tree\fR directive is semantically equivalent to:
.PP
.Vb 1
\&                %default action { goto &Parse::Eyapp::Driver::YYBuildAST }
.Ve
.PP
\fIReturning non References Under \f(CI%tree\fI\fR
.IX Subsection "Returning non References Under %tree"
.PP
When a \fIexplicit user action returns s.t. that is not a reference
no node will be inserted\fR. This fact can be used to supress nodes
in the \s-1AST\s0 being built. See the following example (file \f(CW\*(C`examples/returnnonode.yp\*(C'\fR):
.PP
.Vb 12
\& nereida:~/src/perl/YappWithDefaultAction/examples> sed \-ne \*(Aq1,11p\*(Aq returnnonode.yp | cat \-n
\&  1  %tree
\&  2  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq
\&  3  %%
\&  4  S:  /* empty */
\&  5      | S A
\&  6      | S B
\&  7  ;
\&  8  A : \*(Aqa\*(Aq
\&  9  ;
\& 10  B : \*(Aqb\*(Aq { }
\& 11  ;
.Ve
.PP
since the action at line 10 returns \f(CW\*(C`undef\*(C'\fR
the \f(CW\*(C`B : \*(Aqb\*(Aq\*(C'\fR subtree will not be inserted in the \s-1AST:\s0
.PP
.Vb 3
\& nereida:~/src/perl/YappWithDefaultAction/examples> usereturnnonode.pl
\& ababa
\& S_2(S_3(S_2(S_3(S_2(S_1,A_4(TERMINAL[a]))),A_4(TERMINAL[a]))),A_4(TERMINAL[a]))
.Ve
.PP
Observe the absence of \f(CW\*(C`B\*(C'\fRs and \f(CW\*(Aqb\*(Aq\fRs.
.PP
\fIIntermediate actions and \f(CI%tree\fI\fR
.IX Subsection "Intermediate actions and %tree"
.PP
Intermediate actions can be used to change the shape of the \s-1AST \s0(prune it,
decorate it, etc.) but the value returned by them is ignored. The grammar 
below has two intermediate actions. They modify the attributes of the
node to its left and return a reference \f(CW$f\fR to such node (lines 5 and 6):
.PP
.Vb 12
\& nereida:~/src/perl/YappWithDefaultAction/examples> \e
\&          sed \-ne \*(Aq1,10p\*(Aq intermediateactiontree.yp | cat \-n
\&  1  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq
\&  2  %tree bypass
\&  3  %%
\&  4  S:    /* empty */
\&  5      | S A.f { $f\->{attr} = "A"; $f; } A
\&  6      | S B.f { $f\->{attr} = "B"; $f; } B
\&  7  ;
\&  8  A : %name A \*(Aqa\*(Aq
\&  9  ;
\& 10  B : %name B \*(Aqb\*(Aq
.Ve
.PP
See the client program running:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n useintermediateactiontree.pl
\&  1  #!/usr/bin/perl \-w
\&  2  use strict;
\&  3  use Parse::Eyapp;
\&  4  use intermediateactiontree;
\&  5
\&  6  { no warnings;
\&  7  *A::info = *B::info = sub { $_[0]{attr} };
\&  8  }
\&  9
\& 10  my $parser = intermediateactiontree\->new();
\& 11  my $t = $parser\->Run;
\& 12  print $t\->str,"\en";
\& nereida:~/src/perl/YappWithDefaultAction/examples> useintermediateactiontree.pl
\& aabbaa
\& S_2(S_4(S_2(S_1,A[A],A[a]),B[B],B[b]),A[A],A[a])
.Ve
.PP
The 
attributes 
of left \f(CW\*(C`A\*(C'\fRs 
have been effectively changed by the intermediate actions
from \f(CW\*(Aqa\*(Aq\fR to \f(CW\*(AqA\*(Aq\fR.
However no further children have been inserted.
.PP
\fISyntactic and Semantic tokens\fR
.IX Subsection "Syntactic and Semantic tokens"
.PP
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR diferences between \f(CW\*(C`syntactic tokens\*(C'\fR
and \f(CW\*(C`semantic tokens\*(C'\fR. By default all tokens
declared using string notation (i.e. between quotes
like \f(CW\*(Aq+\*(Aq\fR, \f(CW\*(Aq=\*(Aq\fR)
are considered \fIsyntactic tokens\fR. Tokens declared by an identifier
(like \f(CW\*(C`NUM\*(C'\fR or \f(CW\*(C`VAR\*(C'\fR) are by default considered
\&\fIsemantic tokens\fR. \fBSyntactic tokens do not yield to nodes in the
syntactic tree\fR. Thus, the first print in the former Parse::Eyapp \f(CW\*(C`/SYNOPSIS\*(C'\fR example:
.PP
.Vb 4
\&              $parser\->YYData\->{INPUT} = "2*\-3+b*0;\-\-2\en"; 
\&              my $t = $parser\->Run;                    
\&              local $Parse::Eyapp::Node::INDENT=2;
\&              print "Syntax Tree:",$t\->str;
.Ve
.PP
gives as result the following output:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> synopsis.pl
\& Syntax Tree:
\& EXPRESION_LIST(
\&   PLUS(
\&     TIMES(
\&       NUM(
\&         TERMINAL[2]
\&       ),
\&       UMINUS(
\&         NUM(
\&           TERMINAL[3]
\&         )
\&       ) # UMINUS
\&     ) # TIMES,
\&     TIMES(
\&       VAR(
\&         TERMINAL[b]
\&       ),
\&       NUM(
\&         TERMINAL[0]
\&       )
\&     ) # TIMES
\&   ) # PLUS,
\&   UMINUS(
\&     UMINUS(
\&       NUM(
\&         TERMINAL[2]
\&       )
\&     ) # UMINUS
\&   ) # UMINUS
\& ) # EXPRESION_LIST
.Ve
.PP
\&\f(CW\*(C`TERMINAL\*(C'\fR nodes corresponding to tokens that were defined by strings like
\&\f(CW\*(Aq=\*(Aq\fR, \f(CW\*(Aq\-\*(Aq\fR, \f(CW\*(Aq+\*(Aq\fR, \f(CW\*(Aq/\*(Aq\fR, \f(CW\*(Aq*\*(Aq\fR, \f(CW\*(Aq(\*(Aq\fR and \f(CW\*(Aq)\*(Aq\fR  do not 
appear in the tree.  \f(CW\*(C`TERMINAL\*(C'\fR nodes corresponding to tokens that were defined
using an identifer, like \f(CW\*(C`NUM\*(C'\fR or \f(CW\*(C`VAR\*(C'\fR are, by default,  \fIsemantic tokens\fR
and appear in the \s-1AST.\s0
.PP
\fIChanging the Status of a Token\fR
.IX Subsection "Changing the Status of a Token"
.PP
The new token declaration directives \f(CW\*(C`%syntactic token\*(C'\fR and
\&\f(CW\*(C`%semantic token\*(C'\fR can change the status of a token.
For example (file \f(CW\*(C`15treewithsyntactictoken.pl\*(C'\fR in the \f(CW\*(C`examples/\*(C'\fR directory), 
given the grammar:
.PP
.Vb 3
\&   %syntactic token b
\&   %semantic token \*(Aqa\*(Aq \*(Aqc\*(Aq
\&   %tree
\&
\&   %%
\&
\&   S: %name ABC
\&        A B C
\&    | %name BC
\&        B C
\&   ;
\&
\&   A: %name A
\&        \*(Aqa\*(Aq
\&   ;
\&
\&   B: %name B
\&        b
\&   ;
\&
\&   C: %name C
\&       \*(Aqc\*(Aq
\&   ;
\&   %%
.Ve
.PP
the tree build for input \f(CW\*(C`abc\*(C'\fR will be 
\&\f(CW\*(C`ABC(A(TERMINAL[a]),B,C(TERMINAL[c]))\*(C'\fR.
.PP
\fISaving the Information of Syntactic Tokens in their Father\fR
.IX Subsection "Saving the Information of Syntactic Tokens in their Father"
.PP
The reason for the adjective \f(CW%syntactic\fR applied to a token is to 
state that the token influences the shape of the syntax tree
but carries no other information. When the syntax tree is built
the node corresponding to the token is discarded.
.PP
Sometimes the difference between syntactic and semantic 
tokens is blurred. For example the line number associated
with an instance of the syntactic token \f(CW\*(Aq+\*(Aq\fR can be used later
\&\-say during type checking\- to emit a more accurate error
diagnostic. But if the node was discarded the information
about that line number is no longer available.
When building the syntax tree \f(CW\*(C`Parse::Eyapp\*(C'\fR (namely
the method \f(CW\*(C`Parse::Eyapp::YYBuildAST\*(C'\fR) checks 
if the method \f(CW\*(C`TERMINAL::save_attributes\*(C'\fR exists and if so
it will be called when dealing with a \fIsyntactic token\fR. 
The method receives as argument \- additionally
to the reference to the attribute of the token as it
is returned by the lexical analyzer \- a reference
to the node associated with the left hand side of the
production. Here is an example (file \f(CW\*(C`examples/Types.eyp\*(C'\fR)
of use:
.PP
.Vb 5
\&              sub TERMINAL::save_attributes {
\&                # $_[0] is a syntactic terminal
\&                # $_[1] is the father.
\&                push @{$_[1]\->{lines}}, $_[0]\->[1]; # save the line number
\&              }
.Ve
.PP
\fIThe  \f(CI\*(C`bypass\*(C'\fI clause and the \f(CI\*(C`%no bypass\*(C'\fI directive\fR
.IX Subsection "The bypass clause and the %no bypass directive"
.PP
The shape of the tree can be also modified using some \f(CW%tree\fR clauses
as \f(CW\*(C`%tree bypass\*(C'\fR which will produce an automatic \fIbypass\fR of any
node with only one child at tree-construction-time.
.PP
A \fIbypass operation\fR consists in \fIreturning the only child 
of the node being visited to the father of the node and re-typing (re-blessing)
the node in the name of the production\fR (if a name was provided).
.PP
A node may have only one child at tree-construction-time for one of
two reasons.
.IP "\(bu" 4
The first occurs when the right hand side of the production
was already unary like in:
.Sp
.Vb 2
\&                           exp:
\&                               %name NUM  NUM
.Ve
.Sp
Here \- if the \f(CW\*(C`bypass\*(C'\fR clause is used \- 
the \f(CW\*(C`NUM\*(C'\fR node will be bypassed and the child \f(CW\*(C`TERMINAL\*(C'\fR built
from the information provided by the lexical analyzer will be renamed/reblessed 
as \f(CW\*(C`NUM\*(C'\fR.
.IP "\(bu" 4
Another reason for a node to be \fIbypassed\fR is  the fact that though the right
hand side of the production may have more than one symbol, 
only one of them is not a syntactic token
like in:
.Sp
.Vb 1
\&                           exp: \*(Aq(\*(Aq exp \*(Aq)\*(Aq
.Ve
.PP
A consequence of the global scope application of \f(CW\*(C`%tree bypass\*(C'\fR
is that undesired bypasses may occur like in
.PP
.Vb 2
\&                           exp : %name UMINUS
\&                                 \*(Aq\-\*(Aq $exp %prec NEG
.Ve
.PP
though the right hand side has two symbols, token \f(CW\*(Aq\-\*(Aq\fR is
a syntactic token and therefore only \f(CW\*(C`exp\*(C'\fR is left. The \fIbypass\fR
operation will be applied when building this node.
This \fIbypass\fR can be avoided applying the \f(CW\*(C`no bypass ID\*(C'\fR directive to the corresponding 
production:
.PP
.Vb 2
\&                           exp : %no bypass UMINUS
\&                                 \*(Aq\-\*(Aq $exp %prec NEG
.Ve
.PP
The following example (file \f(CW\*(C`examples/bypass.pl\*(C'\fR) 
is the equivalent of the Parse::Eyapp \f(CW\*(C`/SYNOPSIS\*(C'\fR example
but using the \f(CW\*(C`bypass\*(C'\fR clause instead:
.PP
.Vb 2
\& use Parse::Eyapp;
\& use Parse::Eyapp::Treeregexp;
\&
\& sub TERMINAL::info { $_[0]{attr} }
\& { no warnings; *VAR::info = *NUM::info = \e&TERMINAL::info; }
\&
\& my $grammar = q{
\&   %right  \*(Aq=\*(Aq     # Lowest precedence
\&   %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq 
\&   %left   \*(Aq*\*(Aq \*(Aq/\*(Aq 
\&   %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&   %tree bypass    # Let us build an abstract syntax tree ...
\&
\&   %%
\&   line: exp <%name EXPRESION_LIST + \*(Aq;\*(Aq>  { $_[1] } 
\&   ;
\&
\&   exp:
\&       %name NUM  NUM            | %name VAR   VAR         | %name ASSIGN VAR \*(Aq=\*(Aq exp
\&     | %name PLUS exp \*(Aq+\*(Aq exp    | %name MINUS exp \*(Aq\-\*(Aq exp | %name TIMES  exp \*(Aq*\*(Aq exp
\&     | %name DIV     exp \*(Aq/\*(Aq exp
\&     | %no bypass UMINUS
\&       \*(Aq\-\*(Aq $exp %prec NEG
\&     |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&   ;
\&
\&   %%
\&   # sub _Error, _Lexer and Run like in the synopsis example
\&   # ...
\& }; # end grammar
\&
\& our (@all, $uminus);
\&
\& Parse::Eyapp\->new_grammar( # Create the parser package/class
\&   input=>$grammar,
\&   classname=>\*(AqCalc\*(Aq, # The name of the package containing the parser
\&   firstline=>7       # String $grammar starts at line 7 (for error diagnostics)
\& );
\& my $parser = Calc\->new();                # Create a parser
\& $parser\->YYData\->{INPUT} = "a=2*\-3+b*0\en"; # Set the input
\& my $t = $parser\->Run;                    # Parse it!
\&
\& print "\en************\en".$t\->str."\en************\en";
\&
\& # Let us transform the tree. Define the tree\-regular expressions ..
\& my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&   { #  Example of support code
\&     my %Op = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&   }
\&   constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM, NUM)
\&     => {
\&       my $op = $Op{ref($_[0])};
\&       $NUM[0]\->{attr} = eval  "$NUM[0]\->{attr} $op $NUM[1]\->{attr}";
\&       $_[0] = $NUM[0];
\&     }
\&   zero_times_whatever: TIMES(NUM, .) and { $NUM\->{attr} == 0 } => { $_[0] = $NUM }
\&   whatever_times_zero: TIMES(., NUM) and { $NUM\->{attr} == 0 } => { $_[0] = $NUM }
\&   uminus: UMINUS(NUM) => { $NUM\->{attr} = \-$NUM\->{attr}; $_[0] = $NUM }
\&   },
\&   OUTPUTFILE=> \*(Aqmain.pm\*(Aq
\& );
\& $p\->generate(); # Create the tranformations
\&
\& $t\->s(@all);    # constant folding and mult. by zero
\&
\& print $t\->str,"\en";
.Ve
.PP
when running this example with input \f(CW"a=2*\-3+b*0\en"\fR
we obtain the following output:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> bypass.pl
\&
\& ************
\& EXPRESION_LIST(ASSIGN(TERMINAL[a],PLUS(TIMES(NUM[2],UMINUS(NUM[3])),TIMES(VAR[b],NUM[0]))))
\& ************
\& EXPRESION_LIST(ASSIGN(TERMINAL[a],NUM[\-6]))
.Ve
.PP
As you can see the trees are more compact when using the \f(CW\*(C`bypass\*(C'\fR directive.
.PP
\fIThe \f(CI\*(C`alias\*(C'\fI clause of the \f(CI%tree\fI directive\fR
.IX Subsection "The alias clause of the %tree directive"
.PP
Access to children in Parse::Eyapp is made through the \f(CW\*(C`child\*(C'\fR and \f(CW\*(C`children\*(C'\fR
methods.
There are occasions however where access by name to the children may be preferable.
The use of the \f(CW\*(C`alias\*(C'\fR clause with the \f(CW%tree\fR directive creates accessors
to the children with names specified by the programmer. The \fIdot and dolar notations\fR
are used for this. When dealing with a production like:
.PP
.Vb 3
\&                       A: 
\&                          %name A_Node
\&                          Node B.bum N.pum $Chip
.Ve
.PP
methods \f(CW\*(C`bum\*(C'\fR, \f(CW\*(C`pum\*(C'\fR and \f(CW\*(C`Chip\*(C'\fR will be created for the class \f(CW\*(C`A_Node\*(C'\fR.
Those methods wil provide access to the respective child (first, second and third in
the example). The methods are build at compile-time and therefore later 
transformations of the \s-1AST\s0 modifying the order of the children may 
invalidate the use of these getter-setters.
.PP
As an example, the \s-1CPAN\s0 module Language::AttributeGrammar provides
\&\s-1AST\s0 decorators from an attribute grammar specification of the \s-1AST.\s0
To work  Language::AttributeGrammar requires named access to the children
of the \s-1AST\s0 nodes. Follows an example (file \f(CW\*(C`examples/CalcwithAttributeGrammar.pl\*(C'\fR)
of a small calculator:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n CalcwithAttributeGrammar.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp;
\&     4  use Data::Dumper;
\&     5  use Language::AttributeGrammar;
\&     6
\&     7  my $grammar = q{
\&     8  %{
\&     9  # use Data::Dumper;
\&    10  %}
\&    11  %right  \*(Aq=\*(Aq
\&    12  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    13  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    14  %left   NEG
\&    15  %tree bypass alias
\&    16
\&    17  %%
\&    18  line: $exp  { $_[1] }
\&    19  ;
\&    20
\&    21  exp:
\&    22      %name NUM
\&    23            $NUM
\&    24          | %name VAR
\&    25            $VAR
\&    26          | %name ASSIGN
\&    27            $VAR \*(Aq=\*(Aq $exp
\&    28          | %name PLUS
\&    29            exp.left \*(Aq+\*(Aq exp.right
\&    30          | %name MINUS
\&    31            exp.left \*(Aq\-\*(Aq exp.right
\&    32          | %name TIMES
\&    33            exp.left \*(Aq*\*(Aq exp.right
\&    34          | %name DIV
\&    35            exp.left \*(Aq/\*(Aq exp.right
\&    36          | %no bypass UMINUS
\&    37            \*(Aq\-\*(Aq $exp %prec NEG
\&    38    |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    39  ;
\&    40
\&    41  %%
\&    42
\&    43  sub _Error {
\&    44          exists $_[0]\->YYData\->{ERRMSG}
\&    45      and do {
\&    46          print $_[0]\->YYData\->{ERRMSG};
\&    47          delete $_[0]\->YYData\->{ERRMSG};
\&    48          return;
\&    49      };
\&    50      print "Syntax error.\en";
\&    51  }
\&    52
\&    53  sub _Lexer {
\&    54      my($parser)=shift;
\&    55
\&    56          $parser\->YYData\->{INPUT}
\&    57      or  $parser\->YYData\->{INPUT} = <STDIN>
\&    58      or  return(\*(Aq\*(Aq,undef);
\&    59
\&    60      $parser\->YYData\->{INPUT}=~s/^\es+//;
\&    61
\&    62      for ($parser\->YYData\->{INPUT}) {
\&    63          s/^([0\-9]+(?:\e.[0\-9]+)?)//
\&    64                  and return(\*(AqNUM\*(Aq,$1);
\&    65          s/^([A\-Za\-z][A\-Za\-z0\-9_]*)//
\&    66                  and return(\*(AqVAR\*(Aq,$1);
\&    67          s/^(.)//s
\&    68                  and return($1,$1);
\&    69      }
\&    70  }
\&    71
\&    72  sub Run {
\&    73      my($self)=shift;
\&    74      $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&    75                      #yydebug =>0xFF
\&    76                    );
\&    77  }
\&    78  }; # end grammar
\&    79
\&    80
\&    81  $Data::Dumper::Indent = 1;
\&    82  Parse::Eyapp\->new_grammar(
\&    83    input=>$grammar,
\&    84    classname=>\*(AqRule6\*(Aq,
\&    85    firstline =>7,
\&    86    outputfile => \*(AqCalc.pm\*(Aq,
\&    87  );
\&    88  my $parser = Rule6\->new();
\&    89  $parser\->YYData\->{INPUT} = "a = \-(2*3+5\-1)\en";
\&    90  my $t = $parser\->Run;
\&    91  print "\en***** Before ******\en";
\&    92  print Dumper($t);
\&    93
\&    94  my $attgram = new Language::AttributeGrammar <<\*(AqEOG\*(Aq;
\&    95
\&    96  # Compute the expression
\&    97  NUM:    $/.val = { $<attr> }
\&    98  TIMES:  $/.val = { $<left>.val * $<right>.val }
\&    99  PLUS:   $/.val = { $<left>.val + $<right>.val }
\&   100  MINUS:  $/.val = { $<left>.val \- $<right>.val }
\&   101  UMINUS: $/.val = { \-$<exp>.val }
\&   102  ASSIGN: $/.val = { $<exp>.val }
\&   103  EOG
\&   104
\&   105  my $res = $attgram\->apply($t, \*(Aqval\*(Aq);
\&   106
\&   107  $Data::Dumper::Indent = 1;
\&   108  print "\en***** After ******\en";
\&   109  print Dumper($t);
\&   110  print Dumper($res);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debugingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/MatchingTrees.pdf>
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1),
.IP "\(bu" 4
Man pages of \fIbison\fR\|(1),
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Special thanks to 
my family and Larry Wall.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 1804:" 4
.IX Item "Around line 1804:"
Non-ASCII character seen before =encoding in 'va\*'lida\en";'. Assuming \s-1UTF\-8\s0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::languageintro5.16.3pm          0100644 0001750 0001750 00000320344 12566242265 027024  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::languageintro 3"
.TH Parse::Eyapp::languageintro 3 "2009-11-06" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::languageintro \- Introduction to the Eyapp language
.SH "The Eyapp Language"
.IX Header "The Eyapp Language"
.SS "Eyapp Grammar"
.IX Subsection "Eyapp Grammar"
This section describes the syntax of the Eyapp language using its own notation.
The grammar extends yacc and yapp grammars.
Semicolons have been omitted to save space.
Between C\-like comments you can find an (informal) 
explanation of the language 
associated with the token.
.PP
.Vb 10
\&  eyapp: head body tail ;
\&  symbol: LITERAL  /* A string literal like \*(Aqhello\*(Aq */
\&      |   ident   
\&  ident:  IDENT  /* IDENT is [A\-Za\-z_][A\-Za\-z0\-9_]* */ 
\&  head: headsec \*(Aq%%\*(Aq
\&  headsec:  decl *
\&  decl:  \*(Aq\en\*(Aq      
\&      |   SEMANTIC typedecl symlist \*(Aq\en\*(Aq  /* SEMANTIC  is %semantic\es+token      */
\&      |   SYNTACTIC typedecl symlist \*(Aq\en\*(Aq /* SYNTACTIC is %syntactic\es+token     */
\&      |   TOKEN typedecl symlist \*(Aq\en\*(Aq     /* TOKEN     is %token                 */
\&      |   ASSOC typedecl symlist \*(Aq\en\*(Aq     /* ASSOC     is %(left|right|nonassoc) */
\&      |   START ident \*(Aq\en\*(Aq                /* START     is %start                 */
\&      |   HEADCODE \*(Aq\en\*(Aq                   /* HEADCODE  is %{ Perl code ... %}    */
\&      |   UNION CODE \*(Aq\en\*(Aq                 /* UNION CODE  see yacc/bison          */
\&      |   DEFAULTACTION CODE \*(Aq\en\*(Aq         /* DEFAULTACTION is %defaultaction     */
\&      |   TREE treeclauses? \*(Aq\en\*(Aq          /* TREE      is %tree                  */
\&      |   METATREE \*(Aq\en\*(Aq                   /* METATREE  is %metatree              */
\&      |   TYPE typedecl identlist \*(Aq\en\*(Aq    /* TYPE      is %type                  */
\&      |   EXPECT NUMBER \*(Aq\en\*(Aq              /* EXPECT    is %expect                */
\&                                          /* NUMBER    is \ed+                    */
\&  typedecl:   /* empty */
\&      |       \*(Aq<\*(Aq IDENT \*(Aq>\*(Aq
\&  treeclauses: BYPASS ALIAS? | ALIAS BYPASS?
\&  symlist:    symbol + 
\&  identlist:  ident +
\&  body: rules * \*(Aq%%\*(Aq
\&  rules: IDENT \*(Aq:\*(Aq rhss \*(Aq;\*(Aq  
\&  rhss: rule <+ \*(Aq|\*(Aq>  
\&  rule:   optname rhs (prec epscode)?
\&  rhs:  rhseltwithid *
\&  rhseltwithid : 
\&        rhselt \*(Aq.\*(Aq IDENT 
\&      | \*(Aq$\*(Aq rhselt  
\&      | rhselt
\&  rhselt:     symbol    
\&      | code    
\&      | \*(Aq(\*(Aq optname rhs \*(Aq)\*(Aq 
\&      | rhselt STAR               /* STAR   is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e*  */
\&      | rhselt \*(Aq<\*(Aq STAR symbol \*(Aq>\*(Aq 
\&      | rhselt OPTION             /* OPTION is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e?  */
\&      | rhselt \*(Aq<\*(Aq PLUS symbol \*(Aq>\*(Aq
\&      | rhselt PLUS               /* PLUS   is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e+  */
\&  optname: (NAME IDENT)?          /* NAME is %name */
\&         | NOBYPASS IDENT         /* NOBYPASS is %no\es+bypass */
\&  prec: PREC symbol               /* PREC is %prec */
\&  epscode:  code ?   
\&  code:   
\&      CODE           /* CODE     is { Perl code ... }         */
\&    | BEGINCODE      /* BEGINCODE is %begin { Perl code ... } */
\&  tail:  TAILCODE ?  /* TAILCODE is { Perl code ... } */
.Ve
.PP
The semantic of \f(CW\*(C`Eyapp\*(C'\fR agrees with the semantic of \f(CW\*(C`yacc\*(C'\fR and \f(CW\*(C`yapp\*(C'\fR
for all the common constructions.
.SS "Comments"
.IX Subsection "Comments"
Comments are either Perl style, from \f(CW\*(C`#\*(C'\fR
up to the end of line, or C style, enclosed between  \f(CW\*(C`/*\*(C'\fR and \f(CW\*(C`*/\*(C'\fR.
.SS "Syntactic Variables, Symbolic Tokens and String Literals"
.IX Subsection "Syntactic Variables, Symbolic Tokens and String Literals"
Two kind of symbols may appear inside a Parse::Eyapp program:
\&\fINon-terminal\fR symbols or \fIsyntactic variables\fR, 
called also \fIleft-hand-side\fR symbols
and \fITerminal\fR symbols, called
also \fITokens\fR.
.PP
Tokens are the symbols the lexical analyzer function returns to the parser.
There are two kinds: \fIsymbolic tokens\fR and \fIstring
literals\fR.
.PP
\&\fISyntactic variables\fR and \fIsymbolic tokens\fR identifiers must conform
to the regular expression \f(CW\*(C`[A\-Za\-z][A\-Za\-z0\-9_]*\*(C'\fR.
.PP
When building the syntax tree (i.e. when running under the \f(CW%tree\fR
directive) \fIsymbolic tokens\fR will be considered \fIsemantic tokens\fR (see section
\&\*(L"Syntactic and Semantic tokens\*(R").
.PP
String literals are enclosed in single quotes and can contain almost
anything. They will be received by the parser as double-quoted strings. 
Any special character as \f(CW\*(Aq"\*(Aq\fR, \f(CW\*(Aq$\*(Aq\fR and \f(CW\*(Aq@\*(Aq\fR is escaped.
To have a single quote inside a literal, escape it with '\e'.
.PP
When building the syntax tree (i.e. when running under the \f(CW%tree\fR
directive) \fIstring literals\fR will be considered \fIsyntactic tokens\fR (see section
\&\*(L"Syntactic and Semantic tokens\*(R").
.ie n .SS "Parts of an ""eyapp"" Program"
.el .SS "Parts of an \f(CWeyapp\fP Program"
.IX Subsection "Parts of an eyapp Program"
An Eyapp program has three parts called head, body and tail:
.PP
.Vb 1
\&                                 eyapp: head body tail ;
.Ve
.PP
Each part is separated from the former by the symbol \f(CW\*(C`%%\*(C'\fR:
.PP
.Vb 2
\&                                 head: headsec \*(Aq%%\*(Aq
\&                                 body: rulesec \*(Aq%%\*(Aq
.Ve
.SS "The Head Section"
.IX Subsection "The Head Section"
The head section contains a list of declarations
.PP
.Vb 1
\&                                 headsec:  decl *
.Ve
.PP
There are different kinds of declarations.
.PP
This reference does not 
fully describes all the declarations that are shared with yacc and 
yapp.
.PP
\fIExample of Head Section\fR
.IX Subsection "Example of Head Section"
.PP
In this and the next sections we will describe the basics
of the Eyapp language using the file \f(CW\*(C`examples/Calc.eyp\*(C'\fR 
that accompanies this distribution. This file implements a trivial 
calculator. Here is the header section:
.PP
.Vb 12
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq1,11p\*(Aq Calc.eyp | cat \-n
\&  1  # examples/Calc.eyp
\&  2  %right  \*(Aq=\*(Aq
\&  3  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&  4  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&  5  %left   NEG
\&  6  %right  \*(Aq^\*(Aq
\&  7  %{
\&  8  my %s; # symbol table
\&  9  %}
\& 10
\& 11  %%
.Ve
.PP
\fIDeclarations and Precedence\fR
.IX Subsection "Declarations and Precedence"
.PP
Lines 2\-5 declare several tokens. The usual way to declare
tokens is through the \f(CW%token\fR directive. The declarations 
\&\f(CW%nonassoc\fR, \f(CW%left\fR and \f(CW%right\fR 
not only declare the tokens but also associate a \fIpriority\fR with them.  
Tokens declared in the same line have the same precedence. 
Tokens declared with these directives in lines below have more
precedence than those declared above. Thus, in the example
above
we are saying that \f(CW"+"\fR and \f(CW"\-"\fR have the same precedence
but higher precedence than =. The final effect of \f(CW"\-"\fR
having greater precedence than = will be that an
expression like:
.PP
.Vb 1
\&                        a = 4 \- 5
.Ve
.PP
will be interpreted as
.PP
.Vb 1
\&                        a = (4 \- 5)
.Ve
.PP
and not as
.PP
.Vb 1
\&                        (a = 4) \- 5
.Ve
.PP
The use of the \f(CW%left\fR indicates that \- in case of ambiguity 
and a match between precedences \- the parser must build the tree corresponding
to a left parenthesization. Thus, the expression
.PP
.Vb 1
\&                         4 \- 5 \- 9
.Ve
.PP
will be interpreted as
.PP
.Vb 1
\&                         (4 \- 5) \- 9
.Ve
.PP
\fIHeader Code\fR
.IX Subsection "Header Code"
.PP
Perl code surrounded by \f(CW\*(C`%{\*(C'\fR and \f(CW\*(C`%}\*(C'\fR
can be inserted in the head section. Such code will be inserted in the module
generated by \f(CW\*(C`eyapp\*(C'\fR near the beginning. Therefore, declarations like the
one of the calculator symbol table \f(CW%s\fR
.PP
.Vb 3
\&  7  %{
\&  8  my %s; # symbol table
\&  9  %}
.Ve
.PP
will be visible from almost any point in the file.
.PP
\fIThe Start Symbol of the Grammar\fR
.IX Subsection "The Start Symbol of the Grammar"
.PP
\&\f(CW\*(C`%start IDENT\*(C'\fR declares \f(CW\*(C`IDENT\*(C'\fR as the start symbol of 
the grammar. When \f(CW%start\fR is not
used, the first rule in the body section will be used.
.PP
\fIExpect\fR
.IX Subsection "Expect"
.PP
The \f(CW\*(C`%expect #NUMBER\*(C'\fR directive works as in bison 
and  suppress warnings when the number of Shift/Reduce
conflicts is exactly \f(CW\*(C`#NUMBER\*(C'\fR. See section 
\&\*(L"Solving Ambiguities and Conflicts\*(R" to know more
about Shift/Reduce conflicts.
.PP
\fIType and Union\fR
.IX Subsection "Type and Union"
.PP
C oriented declarations like \f(CW%type\fR and \f(CW%union\fR are
parsed but ignored.
.PP
\fIThe \f(CI%strict\fI Directive\fR
.IX Subsection "The %strict Directive"
.PP
By default, identifiers appearing in the rule section
will be classified as terminal if they don't appear 
in the left hand side of any production rules.
.PP
The directive \f(CW%strict\fR forces the declaration of all tokens. 
The following \f(CW\*(C`eyapp\*(C'\fR program issues a warning:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ cat \-n bugyapp2.eyp
\&       1  %strict
\&       2  %%
\&       3  expr: NUM;
\&       4  %%
\&  pl@nereida:~/LEyapp/examples$ eyapp bugyapp2.eyp
\&  Warning! Non declared token NUM at line 3 of bugyapp2.eyp
.Ve
.PP
To keep silent the compiler declare all tokens using
one of the token declaration directives (\f(CW%token\fR, \f(CW%left\fR, etc.)
.PP
.Vb 8
\&  pl@nereida:~/LEyapp/examples$ cat \-n bugyapp3.eyp
\&       1  %strict
\&       2  %token NUM
\&       3  %%
\&       4  expr: NUM;
\&       5  %%
\&  pl@nereida:~/LEyapp/examples$ eyapp bugyapp3.eyp
\&  pl@nereida:~/LEyapp/examples$
.Ve
.PP
It is a good practice to use \f(CW%strict\fR at the beginning of your grammar.
.PP
\fIDefault Action Directive\fR
.IX Subsection "Default Action Directive"
.PP
In \f(CW\*(C`Parse::Eyapp\*(C'\fR you can modify the default action using the \f(CW\*(C`%defaultaction { Perl code }\*(C'\fR
directive. See section
\&\*(L"Default actions\*(R".
.PP
\fITree Construction Directives\fR
.IX Subsection "Tree Construction Directives"
.PP
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR facilitates the construction of concrete syntax trees and 
abstract syntax trees (abbreviated \s-1AST\s0 from now on) through the \f(CW%tree\fR
\&\f(CW%metatree\fR directives. See section
\&\*(L"Abstract Syntax Trees : \f(CW%tree\fR and \f(CW%name\fR\*(R"
and Parse::Eyapp::translationschemestut.
.PP
\fISyntactic and Semantic Tokens\fR
.IX Subsection "Syntactic and Semantic Tokens"
.PP
The new token declaration directives \f(CW\*(C`%syntactic token\*(C'\fR and
\&\f(CW\*(C`%semantic token\*(C'\fR can change the way \f(CW\*(C`eyapp\*(C'\fR builds the abstract syntax tree.
See section \*(L"Syntactic and Semantic tokens\*(R".
.SS "The Body"
.IX Subsection "The Body"
The body section contains the rules describing the grammar:
.PP
.Vb 3
\&                       body:   rules * \*(Aq%%\*(Aq
\&                       rules:  IDENT \*(Aq:\*(Aq rhss \*(Aq;\*(Aq  
\&                       rhss:   (optname rhs (prec epscode)?) <+ \*(Aq|\*(Aq>
.Ve
.PP
\fIRules\fR
.IX Subsection "Rules"
.PP
A rule is made of a left-hand-side symbol (the \fIsyntactic variable\fR), 
followed by a \f(CW\*(Aq:\*(Aq\fR and one
or more \fIright-hand-sides\fR (or \fIproductions\fR)
 separated by \f(CW\*(Aq|\*(Aq\fR and terminated by a \f(CW\*(Aq;\*(Aq\fR
like in:
.PP
.Vb 5
\&                          exp: 
\&                               exp \*(Aq+\*(Aq exp
\&                            |  exp \*(Aq\-\*(Aq exp
\&                            |  NUM
\&                          ;
.Ve
.PP
A \fIproduction\fR (\fIright hand side\fR) may be empty:
.PP
.Vb 4
\&                          input:   
\&                               /* empty */
\&                            |  input line
\&                          ;
.Ve
.PP
The former two productions can be abbreviated as
.PP
.Vb 3
\&                          input: 
\&                               line *
\&                          ;
.Ve
.PP
The operators \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR and \f(CW\*(C`?\*(C'\fR are presented in section
\&\*(L"Lists and Optionals\*(R".
.PP
A \fIsyntactic variable cannot appear more than once as
a rule name\fR (This differs from yacc).
.PP
\fISemantic Values and Semantic Actions\fR
.IX Subsection "Semantic Values and Semantic Actions"
.PP
In \f(CW\*(C`Parse::Eyapp\*(C'\fR 
a production rule
.PP
.Vb 1
\&                          A \-> X_1 X_2 ... X_n
.Ve
.PP
can be followed by a 
\&\fIsemantic action\fR:
.PP
.Vb 1
\&                    A \-> X_1 X_2 ... X_n { Perl Code }
.Ve
.PP
Such
semantic action is nothing but Perl code that will be treated 
as an anonymous subroutine.  The semantic action associated 
with production rule \f(CW\*(C`A \-> X_1 X_2 ... X_n\*(C'\fR  is executed
after any actions associated with the subtrees of \f(CW\*(C`X_1\*(C'\fR,
\&\f(CW\*(C`X_2\*(C'\fR, ..., \f(CW\*(C`X_n\*(C'\fR.
\&\f(CW\*(C`Eyapp\*(C'\fR parsers build the syntax tree using a left-right
bottom-up traverse of the syntax tree. Each times
the Parser visits the node associated with the 
production \f(CW\*(C`A \-> X_1 X_2 ... X_n\*(C'\fR
the associated semantic action is called. 
Asociated with each symbol
of a Parse::Eyapp grammar there is a scalar \fISemantic Value\fR
or \fIAttribute\fR. The semantic values of terminals are provided
by the lexical analyzer. In the calculator example
(see file \f(CW\*(C`examples/Calc.yp\*(C'\fR in the distribution),
the semantic value associated with an expression
is its numeric value. Thus in the rule:
.PP
.Vb 1
\&                       exp \*(Aq+\*(Aq exp { $_[1] + $_[3] }
.Ve
.PP
\&\f(CW$_[1]\fR refers to the attribute of the first \f(CW\*(C`exp\*(C'\fR, \f(CW$_[2]\fR 
is the attribute associated with \f(CW\*(Aq+\*(Aq\fR, which is the second component of the 
pair provided by the lexical analyzer and \f(CW$_[3]\fR refers to the attribute of 
the second \f(CW\*(C`exp\*(C'\fR.
.PP
When the semantic action/anonymous subroutine is called,
the arguments are as follows:
.IP "\(bu" 4
\&\f(CW$_[1]\fR to \f(CW$_[n]\fR are the attributes of
the symbols \f(CW\*(C`X_1\*(C'\fR, \f(CW\*(C`X_2\*(C'\fR, ..., \f(CW\*(C`X_n\*(C'\fR. 
Just as \f(CW$1\fR to \f(CW$n\fR in yacc,
.IP "\(bu" 4
\&\f(CW$_[0]\fR is the parser object itself.
Having \f(CW$_[0]\fR beeing the parser object itself allows you to call
parser methods. Most yacc macros have been converted into
parser methods. See section 'Methods Available in the Generated Class'
in Parse::Eyapp.
.PP
The returned value will be the attribute associated 
with the left hand side of the production.
.PP
Names can be given to the attributes using the dot notation
(see file \f(CW\*(C`examples/CalcSimple.eyp\*(C'\fR):
.PP
.Vb 1
\&                     exp.left \*(Aq+\*(Aq exp.right { $left + $right }
.Ve
.PP
See section \*(L"Names for attributes\*(R" for more details about the \fIdot\fR and \fIdollar\fR 
notations.
.PP
If no action is specified and no \f(CW%defaultaction\fR is specified
the default action
.PP
.Vb 1
\&                               { $_[1] }
.Ve
.PP
will be executed instead. See section \*(L"Default actions\*(R" to know more.
.PP
\fIActions in Mid-Rule\fR
.IX Subsection "Actions in Mid-Rule"
.PP
Actions can be inserted in the middle of a production like in:
.PP
.Vb 1
\& block: \*(Aq{\*(Aq.bracket { $ids\->begin_scope(); } declaration*.decs statement*.sts \*(Aq}\*(Aq { ... }
.Ve
.PP
A middle production action is managed by inserting a new rule in the grammar and associating
the semantic action with it:
.PP
.Vb 1
\&                     Temp: /* empty */ { $ids\->begin_scope(); }
.Ve
.PP
Middle production actions can refer to the attributes on its left. They count
as one of the components of the production. Thus the program:
.PP
.Vb 5
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq1,4p\*(Aq intermediateaction2.yp
\& %%
\& S:  \*(Aqa\*(Aq { $_[1]x4 }.mid \*(Aqa\*(Aq { print "$_[2], $mid, $_[3]\en"; }
\& ;
\& %%
.Ve
.PP
The auxiliar syntactic variables are named \f(CW\*(C`@#position\-#order\*(C'\fR where \f(CW\*(C`#position\*(C'\fR
is the position of the action in the rhs and \f(CW\*(C`order\*(C'\fR is an ordinal number. See
the \f(CW\*(C`.output\*(C'\fR file for the former example:
.PP
.Vb 7
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ eyapp \-v intermediateaction2.yp
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq1,5p\*(Aq intermediateaction2.output
\& Rules:
\& \-\-\-\-\-\-
\& 0:      $start \-> S $end
\& 1:      S \-> \*(Aqa\*(Aq @1\-1 \*(Aqa\*(Aq
\& 2:      @1\-1 \-> /* empty */
.Ve
.PP
when given input \f(CW\*(C`aa\*(C'\fR the execution will produce as output \f(CW\*(C`aaaa, aaaa, a\*(C'\fR.
.PP
\fIExample of Body Section\fR
.IX Subsection "Example of Body Section"
.PP
Following with the calculator example, the body is:
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq12,48p\*(Aq Calc.eyp | cat \-n
\&  1  start:
\&  2      input { \e%s }
\&  3  ;
\&  4
\&  5  input: line *
\&  6  ;
\&  7
\&  8  line:
\&  9    \*(Aq\en\*(Aq         { undef }
\& 10    | exp \*(Aq\en\*(Aq   { print "$_[1]\en" if defined($_[1]); $_[1] }
\& 11    | error  \*(Aq\en\*(Aq
\& 12        {
\& 13          $_[0]\->YYErrok;
\& 14          undef
\& 15        }
\& 16  ;
\& 17
\& 18  exp:
\& 19      NUM
\& 20    | $VAR                   { $s{$VAR} }
\& 21    | $VAR \*(Aq=\*(Aq $exp          { $s{$VAR} = $exp }
\& 22    | exp.left \*(Aq+\*(Aq exp.right { $left + $right }
\& 23    | exp.left \*(Aq\-\*(Aq exp.right { $left \- $right }
\& 24    | exp.left \*(Aq*\*(Aq exp.right { $left * $right }
\& 25    | exp.left \*(Aq/\*(Aq exp.right
\& 26      {
\& 27         $_[3] and return($_[1] / $_[3]);
\& 28         $_[0]\->YYData\->{ERRMSG} = "Illegal division by zero.\en";
\& 29         $_[0]\->YYError; # Pretend that a syntactic error ocurred: _Error will be called
\& 30         undef
\& 31      }
\& 32    | \*(Aq\-\*(Aq $exp %prec NEG     { \-$exp }
\& 33    | exp.left \*(Aq^\*(Aq exp.right { $left ** $right }
\& 34    | \*(Aq(\*(Aq $exp \*(Aq)\*(Aq           { $exp }
\& 35  ;
\& 36
\& 37  %%
.Ve
.PP
This example does not uses any of the Eyapp extensions (with the exception of the 
\&\fIstar list\fR at line 5) and the dot and dollar notations. 
Please, see the Parse::Yapp pages and elsewhere documentation
on yacc and bison for more information.
.PP
\fISolving Ambiguities and Conflicts\fR
.IX Subsection "Solving Ambiguities and Conflicts"
.PP
When Eyapp analizes a grammar like:
.PP
.Vb 7
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ cat \-n ambiguities.eyp
\&     1  %%
\&     2  exp:
\&     3      NUM
\&     4    | exp \*(Aq\-\*(Aq exp
\&     5  ;
\&     6  %%
.Ve
.PP
it will produce a warning announcing the existence of 
\&\fIshift-reduce\fR conflicts:
.PP
.Vb 7
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ eyapp ambiguities.eyp
\& 1 shift/reduce conflict (see .output file)
\& State 5: reduce by rule 2: exp \-> exp \*(Aq\-\*(Aq exp (default action)
\& State 5: shifts:
\&   to state    3 with \*(Aq\-\*(Aq
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ ls \-ltr | tail \-1
\& \-rw\-rw\-\-\-\-  1 pl users   1082 2007\-02\-06 08:26 ambiguities.output
.Ve
.PP
when \f(CW\*(C`eyapp\*(C'\fR finds warnings automatically produces a \f(CW\*(C`.output\*(C'\fR file
describing the conflict.
.PP
What the warning is saying is that an expression like \f(CW\*(C`exp \*(Aq\-\*(Aq exp\*(C'\fR (rule 2) followed by a
minus \f(CW\*(Aq\-\*(Aq\fR can be worked in more than one way. If we
have an input like \f(CW\*(C`NUM \- NUM \- NUM\*(C'\fR the activity of a \s-1\fILALR\s0\fR\|(1) parser
(the family of parsers to which Eyapp belongs)
consists of a sequence of \fIshift and reduce actions\fR. A \fIshift action\fR
has as consequence the reading of the next token. A \fIreduce action\fR
is finding a production rule that matches and substituting 
the rhs of the production by the lhs.  For input \f(CW\*(C`NUM \- NUM \- NUM\*(C'\fR
the activity will be as follows (the dot is used to indicate where the next 
input token is):
.PP
.Vb 6
\&                           .NUM \- NUM \- NUM # shift
\&                            NUM.\- NUM \- NUM # reduce exp: NUM 
\&                            exp.\- NUM \- NUM # shift
\&                            exp \-.NUM \- NUM # shift
\&                            exp \- NUM.\- NUM # reduce exp: NUM
\&                            exp \- exp.\- NUM # shift/reduce conflict
.Ve
.PP
up this point two different decisions can be taken: the next description can be
.PP
.Vb 1
\&                                  exp.\- NUM # reduce by exp: exp \*(Aq\-\*(Aq exp (rule 2)
.Ve
.PP
or:
.PP
.Vb 1
\&                            exp \- exp \-.NUM # shift \*(Aq\-\*(Aq (to state 3)
.Ve
.PP
that is why it is called a \fIshift-reduce conflict\fR.
.PP
That is also the reason for the precedence declarations in the 
head section. Another kind of conflicts are \fIreduce-reduce conflicts\fR.
They arise when more that rhs can be applied for a reduction
action.
.PP
Eyapp solves the conflicts applying the following rules:
.IP "\(bu" 4
In a shift/reduce conflict, the default is the shift.
.IP "\(bu" 4
In a reduce/reduce conflict, the default is to reduce by the
earlier grammar production (in the input sequence).
.IP "\(bu" 4
The precedences and associativities are associated with tokens in
the declarations section. This is made by a sequence of lines beginning
with one of the directives: \f(CW%left\fR, \f(CW%right\fR, or \f(CW%nonassoc\fR, 
followed by a list of
tokens. All the tokens on the same line
have the same precedence and associativity; 
the lines are listed in order of increasing precedence.
.IP "\(bu" 4
A precedence and associativity is associated with each grammar
production; it is the precedence and associativity of the \fIlast token\fR 
or \fIliteral\fR in the right hand side of the production.
.IP "\(bu" 4
The \f(CW%prec\fR directive can be used when
a rhs is involved in a conflict and has no tokens
inside or it has but the precedence of the last token leads
to an incorrect interpretation. A rhs can be followed by 
an optional \f(CW\*(C`%prec token\*(C'\fR directive
giving the production the precedence of the \f(CW\*(C`token\*(C'\fR
.Sp
.Vb 1
\&                          exp:   \*(Aq\-\*(Aq exp %prec NEG { \-$_[1] }
.Ve
.IP "\(bu" 4
If there is a shift/reduce conflict, and both the grammar production
and the input character have precedence and associativity associated
with them, then the conflict is solved in favor of the action (shift or
reduce) associated with the higher precedence. If the precedences are the
same, then the associativity is used; left associative implies reduce,
right associative implies shift, and nonassociating implies error.
.PP
To solve a shift-reduce conflict between a production \f(CW\*(C`A \-\-> SOMETHING\*(C'\fR
and a token \f(CW\*(Aqa\*(Aq\fR you can follow this procedure:
.ie n .IP "1. Edit the "".output"" file" 4
.el .IP "1. Edit the \f(CW.output\fR file" 4
.IX Item "1. Edit the .output file"
.PD 0
.IP "2. Search for the state where the conflict between the production and the token is. In our example it looks like:" 4
.IX Item "2. Search for the state where the conflict between the production and the token is. In our example it looks like:"
.PD
.Vb 2
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq56,65p\*(Aq ambiguities.output
\& State 5:
\&
\&        exp \-> exp . \*(Aq\-\*(Aq exp    (Rule 2)
\&        exp \-> exp \*(Aq\-\*(Aq exp .    (Rule 2)
\&
\&        \*(Aq\-\*(Aq     shift, and go to state 3
\&
\&        \*(Aq\-\*(Aq     [reduce using rule 2 (exp)]
\&        $default        reduce using rule 2 (exp)
.Ve
.ie n .IP "3. Inside the state there has to be a production of the type ""A \-\-> SOMETHING."" (with the dot at the end) indicating that a reduction must take place. There has to be also another production of the form ""A \-\-> prefix . suffix"", where suffix can \fIstart\fR with the involved token \*(Aqa\*(Aq." 4
.el .IP "3. Inside the state there has to be a production of the type \f(CWA \-\-> SOMETHING.\fR (with the dot at the end) indicating that a reduction must take place. There has to be also another production of the form \f(CWA \-\-> prefix . suffix\fR, where suffix can \fIstart\fR with the involved token \f(CW\*(Aqa\*(Aq\fR." 4
.IX Item "3. Inside the state there has to be a production of the type A --> SOMETHING. (with the dot at the end) indicating that a reduction must take place. There has to be also another production of the form A --> prefix . suffix, where suffix can start with the involved token a."
.PD 0
.ie n .IP "4. Decide what action shift or reduce matches the kind of trees you want. In this example we want ""NUM \- NUM \- NUM"" to produce a tree like ""MINUS(MINUS(NUM, NUM), NUM)"" and not ""MINUS(NUM, MINUS(NUM, NUM))"". We want the conflict in ""exp \- exp.\- NUM"" to be solved in favor of the reduction by ""exp: exp \*(Aq\-\*(Aq exp"". This is achieved by declaring ""%left \*(Aq\-\*(Aq""." 4
.el .IP "4. Decide what action shift or reduce matches the kind of trees you want. In this example we want \f(CWNUM \- NUM \- NUM\fR to produce a tree like \f(CWMINUS(MINUS(NUM, NUM), NUM)\fR and not \f(CWMINUS(NUM, MINUS(NUM, NUM))\fR. We want the conflict in \f(CWexp \- exp.\- NUM\fR to be solved in favor of the reduction by \f(CWexp: exp \*(Aq\-\*(Aq exp\fR. This is achieved by declaring \f(CW%left \*(Aq\-\*(Aq\fR." 4
.IX Item "4. Decide what action shift or reduce matches the kind of trees you want. In this example we want NUM - NUM - NUM to produce a tree like MINUS(MINUS(NUM, NUM), NUM) and not MINUS(NUM, MINUS(NUM, NUM)). We want the conflict in exp - exp.- NUM to be solved in favor of the reduction by exp: exp - exp. This is achieved by declaring %left -."
.PD
.PP
\fIError Recovery\fR
.IX Subsection "Error Recovery"
.PP
The token name \f(CW\*(C`error\*(C'\fR is reserved for error handling. This name can
be used in grammar productions; it suggests places where errors are
expected, and recovery can take place:
.PP
.Vb 8
\&     line:
\&       \*(Aq\en\*(Aq         { undef }
\&       | exp \*(Aq\en\*(Aq   { print "$_[1]\en" if defined($_[1]); $_[1] }
\&       | error  \*(Aq\en\*(Aq
\&           {
\&             $_[0]\->YYErrok;
\&             undef
\&           }
.Ve
.PP
The parser pops its stack until
it enters a state where the token \f(CW\*(C`error\*(C'\fR is legal. It then shifts
the token \f(CW\*(C`error\*(C'\fR and proceeds to discard tokens until finding 
one that is acceptable. In the example
all the tokens until finding a \f(CW\*(Aq\en\*(Aq\fR will be skipped. 
If no special error productions have been specified,
the processing will halt.
.PP
In order to prevent a cascade of error messages, the parser, after
detecting an error, remains in error state until three tokens have been
successfully read and shifted. If an error is detected when the parser
is already in error state, no message is given, and the input token is
quietly deleted. The method \f(CW\*(C`YYErrok\*(C'\fR used in the example 
communicates to the parser
that a satisfactory recovery has been reached 
and that it can safely emit new error
messages.
.PP
You cannot have a literal \fI'error'\fR in your grammar as it would
confuse the driver with the \fIerror\fR token. Use a symbolic token instead.
.SS "The Tail"
.IX Subsection "The Tail"
The tail section contains Perl code. Usually the lexical analyzer and the
Error management subroutines go there. A better practice however is to isolate
both subroutines in a module and use them in the grammar. An example of this is in
files \f(CW\*(C`examples/CalcUsingTail.eyp\*(C'\fR and \f(CW\*(C`examples/Tail.pm\*(C'\fR.
.PP
\fIThe Lexical Analyzer\fR
.IX Subsection "The Lexical Analyzer"
.PP
The Lexical Analyzer 
is called each time the parser needs a new token.
It is called with only one argument (the parser object)
and returns a pair 
containing the next token and its associated attribute.
.PP
The fact that is a method of the parser object means that 
the parser
methods are accesible inside the lexical analyzer.
Specially interesting is the \f(CW\*(C`$_[0]\->YYData\*(C'\fR 
method which provides access to the user data area.
.PP
\&\fIWhen the lexical analyzer reaches the end of input, it must return the
pair\fR \f(CW\*(C`(\*(Aq\*(Aq, undef)\*(C'\fR
.PP
See below how to write a lexical analyzer (file \f(CW\*(C`examples/Calc.eyp\*(C'\fR):
.PP
.Vb 10
\&  1  sub make_lexer {
\&  2    my $input = shift;
\&  3
\&  4    return sub {
\&  5      my $parser = shift;
\&  6
\&  7      for ($$input) {
\&  8        m{\eG[ \et]*}gc;
\&  9        m{\eG([0\-9]+(?:\e.[0\-9]+)?)}gc   and return (\*(AqNUM\*(Aq,$1);
\& 10        m{\eG([A\-Za\-z][A\-Za\-z0\-9_]*)}gc and return (\*(AqVAR\*(Aq,$1);
\& 11        m{\eG\en}gc                      and do { $lineno++; return ("\en", "\en") };
\& 12        m{\eG(.)}gc                     and return ($1,$1);
\& 13
\& 14        return(\*(Aq\*(Aq,undef);
\& 15      }
\& 16    }
\& 17  }
.Ve
.PP
The subroutine \f(CW\*(C`make_lexer\*(C'\fR creates the lexical analyzer as
a closure. The lexer returned by \f(CW\*(C`make_lexer\*(C'\fR is used by the 
\&\f(CW\*(C`YYParse\*(C'\fR method:
.PP
.Vb 9
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq90,97p\*(Aq Calc.eyp | cat \-n
\& 1  sub Run {
\& 2      my($self)=shift;
\& 3      my $input = shift or die "No input given\en";
\& 4
\& 5      return $self\->YYParse( yylex => make_lexer($input), yyerror => \e&_Error,
\& 6        #yydebug =>0x1F
\& 7      );
\& 8  }
.Ve
.PP
\fIThe Error Report Subroutine\fR
.IX Subsection "The Error Report Subroutine"
.PP
The Error Report subroutine is also a parser method, 
and consequently receives as parameter the parser object.
.PP
See the error report subroutine
for the example in \f(CW\*(C`examples/Calc.eyp\*(C'\fR:
.PP
.Vb 10
\&  1  %%
\&  2
\&  3  my $lineno = 1;
\&  4
\&  5  sub _Error {
\&  6    my $parser = shift;
\&  7
\&  8      exists $parser\->YYData\->{ERRMSG}
\&  9    and do {
\& 10        print $parser\->YYData\->{ERRMSG};
\& 11        delete $parser\->YYData\->{ERRMSG};
\& 12        return;
\& 13    };
\& 14    my($token)=$parser\->YYCurval;
\& 15    my($what)= $token ? "input: \*(Aq$token\*(Aq" : "end of input";
\& 16    my @expected = $parser\->YYExpect();
\& 17    local $" = \*(Aq, \*(Aq;
\& 18    print << "ERRMSG";
\& 19
\& 20  Syntax error near $what (lin num $lineno).
\& 21  Expected one of these terminals: @expected
\& 22  ERRMSG
\& 23  }
.Ve
.PP
See the Parse::Yapp pages and elsewhere documentation
on yacc and bison for more information.
.SS "Using an Eyapp Program"
.IX Subsection "Using an Eyapp Program"
The following is an example of a program that uses the calculator explained 
in the two previous sections:
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ cat \-n usecalc.pl
\&  1  #!/usr/bin/perl \-w
\&  2  use strict;
\&  3  use Calc;
\&  4
\&  5  my $parser = Calc\->new();
\&  6  my $input = <<\*(AqEOI\*(Aq;
\&  7  a = 2*3
\&  8  d = 5/(a\-6)
\&  9  b = (a+1)/7
\& 10  c=a*3+4)\-5
\& 11  a = a+1
\& 12  EOI
\& 13  my $t = $parser\->Run(\e$input);
\& 14  print "========= Symbol Table ==============\en";
\& 15  print "$_ = $t\->{$_}\en" for sort keys %$t;
.Ve
.PP
The output for this program is (the input for each output
appear as a Perl comment on the right):
.PP
.Vb 5
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ eyapp Calc.eyp
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ usecalc.pl
\& 6                                              # a = 2*3
\& Illegal division by zero.                      # d = 5/(a\-6)
\& 1                                              # b = (a+1)/7
\&
\& Syntax error near input: \*(Aq)\*(Aq (lin num 4).      # c=a*3+4)\-5
\& Expected one of these terminals: \-, /, ^, *, +,
\&
\& 7                                              # a = a+1
\& ========= Symbol Table ==============
\& a = 7
\& b = 1
\& c = 22
.Ve
.SS "Lists and Optionals"
.IX Subsection "Lists and Optionals"
The elements of a rhs can be one of these:
.PP
.Vb 9
\&  rhselt:     
\&        symbol    
\&      | code    
\&      | \*(Aq(\*(Aq optname rhs \*(Aq)\*(Aq 
\&      | rhselt STAR               /* STAR   is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e*  */
\&      | rhselt \*(Aq<\*(Aq STAR symbol \*(Aq>\*(Aq 
\&      | rhselt OPTION             /* OPTION is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e?  */
\&      | rhselt \*(Aq<\*(Aq PLUS symbol \*(Aq>\*(Aq
\&      | rhselt PLUS               /* PLUS   is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e+  */
.Ve
.PP
The \f(CW\*(C`STAR\*(C'\fR, \f(CW\*(C`OPTION\*(C'\fR and \f(CW\*(C`PLUS\*(C'\fR operators provide a simple mechanism
to express lists:
.IP "\(bu" 4
In Eyapp the \f(CW\*(C`+\*(C'\fR operator indicates one or more repetitions of the element
to the left of \f(CW\*(C`+\*(C'\fR, thus a rule like:
.Sp
.Vb 1
\&                        decls:  decl +
.Ve
.Sp
is the same as:
.Sp
.Vb 2
\&                        decls:  decls decl 
\&                             |  decl
.Ve
.Sp
An additional  symbol may be included  to indicate lists of elements 
separated by such symbol. Thus
.Sp
.Vb 1
\&                       rhss: rule <+ \*(Aq|\*(Aq>
.Ve
.Sp
is equivalent to:
.Sp
.Vb 2
\&                       rhss: rhss \*(Aq|\*(Aq rule 
\&                           | rule
.Ve
.IP "\(bu" 4
The operators \f(CW\*(C`*\*(C'\fR and \f(CW\*(C`?\*(C'\fR have their usual meaning: 0 or more for
\&\f(CW\*(C`*\*(C'\fR and optionality for \f(CW\*(C`?\*(C'\fR. Is legal to parenthesize 
a \f(CW\*(C`rhs\*(C'\fR expression as in:
.Sp
.Vb 1
\&                       optname: (NAME IDENT)?
.Ve
.SS "The Semantic of Lists Operators"
.IX Subsection "The Semantic of Lists Operators"
\fIThe \f(CI\*(C`+\*(C'\fI operator\fR
.IX Subsection "The + operator"
.PP
The grammar:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-12 List3.yp | cat \-n
\&   1  # List3.yp
\&   2  %semantic token \*(Aqc\*(Aq
\&   3  %{
\&   4  use Data::Dumper;
\&   5  %}
\&   6  %%
\&   7  S:      \*(Aqc\*(Aq+  \*(Aqd\*(Aq+
\&   8             {
\&   9                print Dumper($_[1]);
\&  10                print Dumper($_[2]);
\&  11             }
\&  12  ;
.Ve
.PP
Is equivalent to:
.PP
.Vb 9
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v List3.yp | head \-9 List3.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> S $end
\&  1:      PLUS\-1 \-> PLUS\-1 \*(Aqc\*(Aq
\&  2:      PLUS\-1 \-> \*(Aqc\*(Aq
\&  3:      PLUS\-2 \-> PLUS\-2 \*(Aqd\*(Aq
\&  4:      PLUS\-2 \-> \*(Aqd\*(Aq
\&  5:      S \-> PLUS\-1 PLUS\-2
.Ve
.PP
By default, the semantic action associated with a \f(CW\*(C`+\*(C'\fR returns the lists of attributes
to which the \f(CW\*(C`+\*(C'\fR applies:
.PP
.Vb 4
\&  pl@nereida:~/LEyapp/examples$ use_list3.pl
\&  ccdd
\&  $VAR1 = [ \*(Aqc\*(Aq, \*(Aqc\*(Aq ];
\&  $VAR1 = [ \*(Aqd\*(Aq, \*(Aqd\*(Aq ];
.Ve
.PP
The semantic associated with a \f(CW\*(C`+\*(C'\fR changes 
when one of the tree creation directives is active (for instance \f(CW%tree\fR or \f(CW%metatree\fR)
or it has been explicitly requested with a call to the \f(CW\*(C`YYBuildingTree\*(C'\fR method:
.PP
.Vb 1
\&                            $self\->YYBuildingTree(1);
.Ve
.PP
Other ways to change the associated semantic are to use the 
\&\f(CW\*(C`yybuildingtree\*(C'\fR option of \f(CW\*(C`YYParse\*(C'\fR:
.PP
.Vb 4
\&         $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&                           yybuildingtree => 1,
\&                         # yydebug => 0x1F
\&         );
.Ve
.PP
In such case the associated semantic action creates a node labelled
.PP
.Vb 1
\&                     _PLUS_LIST_#number
.Ve
.PP
whose children are the attributes associated with the items in the 
plus list. The \f(CW\*(C`#number\*(C'\fR in \f(CW\*(C`_PLUS_LIST_#number\*(C'\fR is the ordinal
of the production rule as it appears in the \f(CW\*(C`.output\*(C'\fR file.
As it happens when using the \f(CW%tree\fR directive syntactic tokens 
are skipped.
.PP
When executing the example above but under the \f(CW%tree\fR directive
the ouput changes:
.PP
.Vb 4
\&  pl@nereida:~/LEyapp/examples$ head \-3 List3.yp; eyapp List3.yp
\&  # List3.yp
\&  %semantic token \*(Aqc\*(Aq
\&  %tree
\&
\&  pl@nereida:~/LEyapp/examples$ use_list3.pl
\&  ccdd
\&  $VAR1 = bless( {
\&           \*(Aqchildren\*(Aq => [
\&             bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&             bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&           ]
\&         }, \*(Aq_PLUS_LIST_1\*(Aq );
\&  $VAR1 = bless( { \*(Aqchildren\*(Aq => [] }, \*(Aq_PLUS_LIST_2\*(Aq );
.Ve
.PP
The node associated with the list of \f(CW\*(C`d\*(C'\fRs is empty since
terminal \f(CW\*(C`d\*(C'\fR wasn't declared semantic.
.PP
\fIWhen Nodes Dissappear from Lists\fR
.IX Subsection "When Nodes Dissappear from Lists"
.PP
When under the influence of the \f(CW%tree\fR directive
the action associated with a list operator
is to \fIflat\fR the children in a single list.
.PP
In the former example, the \f(CW\*(C`d\*(C'\fR nodes dont show up 
since \f(CW\*(Aqd\*(Aq\fR is a syntactic token. However, it may happen that changing the status
of \f(CW\*(Aqd\*(Aq\fR to semantic will not suffice.
.PP
When inserting the children, the tree (\f(CW%tree\fR)  node construction
method (\f(CW\*(C`YYBuildAST\*(C'\fR) omits any attribute that is not a reference.
Therefore, when inserting explicit actions, it is necessary to guarantee that 
the returned value is a reference or a semantic token 
to assure the presence of the value in the lists of children of the node.
Certainly you can use this property to prune parts of the tree.
Consider the following example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-19 ListWithRefs1.eyp | cat \-n
\&   1  # ListWithRefs.eyp
\&   2  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&   3  %{
\&   4  use Data::Dumper;
\&   5  %}
\&   6  %%
\&   7  S:      \*(Aqc\*(Aq+  D+
\&   8             {
\&   9                print Dumper($_[1]);
\&  10                print $_[1]\->str."\en";
\&  11                print Dumper($_[2]);
\&  12                print $_[2]\->str."\en";
\&  13             }
\&  14  ;
\&  15
\&  16  D: \*(Aqd\*(Aq
\&  17  ;
\&  18
\&  19  %%
.Ve
.PP
To activate the \fItree semantic\fR for lists we use the \f(CW\*(C`yybuildingtree\*(C'\fR
option of \f(CW\*(C`YYParse\*(C'\fR:
.PP
.Vb 8
\&  pl@nereida:~/LEyapp/examples$ tail \-7 ListWithRefs1.eyp | cat \-n
\&       1  sub Run {
\&       2      my($self)=shift;
\&       3      $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&       4        yybuildingtree => 1,
\&       5        #, yydebug => 0x1F
\&       6      );
\&       7  }
.Ve
.PP
The execution gives an ouput like this:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ eyapp ListWithRefs1.eyp; use_listwithrefs1.pl
\&  ccdd
\&  $VAR1 = bless( {
\&                   \*(Aqchildren\*(Aq => [
\&                                   bless( {
\&                                            \*(Aqchildren\*(Aq => [],
\&                                            \*(Aqattr\*(Aq => \*(Aqc\*(Aq,
\&                                            \*(Aqtoken\*(Aq => \*(Aqc\*(Aq
\&                                          }, \*(AqTERMINAL\*(Aq ),
\&                                   bless( {
\&                                            \*(Aqchildren\*(Aq => [],
\&                                            \*(Aqattr\*(Aq => \*(Aqc\*(Aq,
\&                                            \*(Aqtoken\*(Aq => \*(Aqc\*(Aq
\&                                          }, \*(AqTERMINAL\*(Aq )
\&                                 ]
\&                 }, \*(Aq_PLUS_LIST_1\*(Aq );
\&  _PLUS_LIST_1(TERMINAL,TERMINAL)
\&  $VAR1 = bless( {
\&                   \*(Aqchildren\*(Aq => []
\&                 }, \*(Aq_PLUS_LIST_2\*(Aq );
\&  _PLUS_LIST_2
.Ve
.PP
Though \f(CW\*(Aqd\*(Aq\fR was declared semantic the default action 
assoaciated with the production \f(CW\*(C`D: \*(Aqd\*(Aq\*(C'\fR in line 16
returns \f(CW$_[1]\fR (that is, the scalar \f(CW\*(Aqd\*(Aq\fR). Since it is not
a reference it won't be inserted in the list of children of
\&\f(CW\*(C`_PLUS_LIST\*(C'\fR.
.PP
\fIRecovering the Missing Nodes\fR
.IX Subsection "Recovering the Missing Nodes"
.PP
The solution is to be sure that the attribute is a reference:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-22 ListWithRefs.eyp | cat \-n
\&   1  # ListWithRefs.eyp
\&   2  %semantic token \*(Aqc\*(Aq
\&   3  %{
\&   4  use Data::Dumper;
\&   5  %}
\&   6  %%
\&   7  S:      \*(Aqc\*(Aq+  D+
\&   8             {
\&   9                print Dumper($_[1]);
\&  10                print $_[1]\->str."\en";
\&  11                print Dumper($_[2]);
\&  12                print $_[2]\->str."\en";
\&  13             }
\&  14  ;
\&  15
\&  16  D: \*(Aqd\*(Aq
\&  17       {
\&  18         bless { attr => $_[1], children =>[]}, \*(AqDES\*(Aq;
\&  19       }
\&  20  ;
\&  21
\&  22  %%
.Ve
.PP
Now the attribute associated with \f(CW\*(C`D\*(C'\fR is a reference 
and appears in the list of children of \f(CW\*(C`_PLUS_LIST\*(C'\fR:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ eyapp ListWithRefs.eyp; use_listwithrefs.pl
\&  ccdd
\&  $VAR1 = bless( {
\&                   \*(Aqchildren\*(Aq => [
\&                                   bless( {
\&                                            \*(Aqchildren\*(Aq => [],
\&                                            \*(Aqattr\*(Aq => \*(Aqc\*(Aq,
\&                                            \*(Aqtoken\*(Aq => \*(Aqc\*(Aq
\&                                          }, \*(AqTERMINAL\*(Aq ),
\&                                   bless( {
\&                                            \*(Aqchildren\*(Aq => [],
\&                                            \*(Aqattr\*(Aq => \*(Aqc\*(Aq,
\&                                            \*(Aqtoken\*(Aq => \*(Aqc\*(Aq
\&                                          }, \*(AqTERMINAL\*(Aq )
\&                                 ]
\&                 }, \*(Aq_PLUS_LIST_1\*(Aq );
\&  _PLUS_LIST_1(TERMINAL,TERMINAL)
\&  $VAR1 = bless( {
\&                   \*(Aqchildren\*(Aq => [
\&                                   bless( {
\&                                            \*(Aqchildren\*(Aq => [],
\&                                            \*(Aqattr\*(Aq => \*(Aqd\*(Aq
\&                                          }, \*(AqDES\*(Aq ),
\&                                   bless( {
\&                                            \*(Aqchildren\*(Aq => [],
\&                                            \*(Aqattr\*(Aq => \*(Aqd\*(Aq
\&                                          }, \*(AqDES\*(Aq )
\&                                 ]
\&                 }, \*(Aq_PLUS_LIST_2\*(Aq );
\&  _PLUS_LIST_2(DES,DES)
.Ve
.PP
\fIBuilding a Tree with \f(CI\*(C`Parse::Eyapp::Node\->new\*(C'\fI\fR
.IX Subsection "Building a Tree with Parse::Eyapp::Node->new"
.PP
The former solution consisting on writing \fIby hand\fR the code to 
build the node may suffice when dealing with a single node.
Writing by hand the code to build a node is a cumbersome task.
Even worst: though the node built in the former example
looks like a \f(CW\*(C`Parse::Eyapp\*(C'\fR node actually isn't. \f(CW\*(C`Parse::Eyapp\*(C'\fR 
nodes always inherit from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR and 
consequently have access to the methods in such package.
Thefollowing execution using the debugger illustrates the point:
.PP
.Vb 1
\&  pl@nereida:~/LEyapp/examples$ perl \-wd use_listwithrefs.pl
\&
\&  Loading DB routines from perl5db.pl version 1.28
\&  Editor support available.
\&
\&  Enter h or \`h h\*(Aq for help, or \`man perldebug\*(Aq for more help.
\&
\&  main::(use_listwithrefs.pl:4):  $parser = new ListWithRefs();
\&    DB<1>  f ListWithRefs.eyp
\&  1       2       #line 3 "ListWithRefs.eyp"
\&  3
\&  4:      use Data::Dumper;
\&  5
\&  6       #line 7 "ListWithRefs.eyp"
\&  7       #line 8 "ListWithRefs.eyp"
\&  8
\&  9:                    print Dumper($_[1]);
\&  10:                   print $_[1]\->str."\en";
.Ve
.PP
through the command \f(CW\*(C`f ListWithRefs.eyp\*(C'\fR we inform the debugger
that subsequent commands will refer to such file. Next 
we execute the program up to the semantic action
associated with the production rule \f(CW\*(C`S: \*(Aqc\*(Aq+  D+\*(C'\fR (line 9)
.PP
.Vb 4
\&    DB<2> c 9     # Continue up to line 9 of ListWithRefs.eyp
\&  ccdd
\&  ListWithRefs::CODE(0x84ebe5c)(ListWithRefs.eyp:9):
\&  9:                    print Dumper($_[1]);
.Ve
.PP
Now we are in condition to look at the contents 
of the arguments:
.PP
.Vb 7
\&    DB<3> x $_[2]\->str
\&  0  \*(Aq_PLUS_LIST_2(DES,DES)\*(Aq
\&    DB<4> x $_[2]\->child(0)
\&  0  DES=HASH(0x85c4568)
\&     \*(Aqattr\*(Aq => \*(Aqd\*(Aq
\&     \*(Aqchildren\*(Aq => ARRAY(0x85c458c)
\&          empty array
.Ve
.PP
the \f(CW\*(C`str\*(C'\fR method works with the object \f(CW$_[2]\fR since
\&\f(CW\*(C`_PLUS_LIST_2\*(C'\fR nodes inherit from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR.
However, when we try with the \f(CW\*(C`DES\*(C'\fR node we get an
error:
.PP
.Vb 4
\&    DB<6> x $_[2]\->child(0)\->str
\&  Can\*(Aqt locate object method "str" via package "DES" at \e
\&    (eval 11)[/usr/share/perl/5.8/perl5db.pl:628] line 2, <STDIN> line 1.
\&    DB<7>
.Ve
.PP
More robust than the former solution of building the node \fIby hand\fR
is to use the constructor \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR:
The method \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
is uset to build forests of syntactic trees.
.PP
It receives a  list of terms describing the trees and \- optionally \-
a reference to a subroutine used to set up the attributes
of the just created nodes. After the creation 
of the trees the sub is called by \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
with arguments the list of references to the nodes (in the order
in which they appear in the terms, from left to right).
\&\f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR returns a list of references 
to the jsut created nodes. In a scalar context returns a reference to the first of such trees.
See an example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ perl \-MParse::Eyapp \-MData::Dumper \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> @t = Parse::Eyapp::Node\->new(\*(AqA(C,D) E(F)\*(Aq, sub { my $i = 0; $_\->{n} = $i++ for @_ })
\&    DB<2> $Data::Dumper::Indent = 0
\&    DB<3> print Dumper($_)."\en" for @t
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 0,\*(Aqchildren\*(Aq => [bless( {\*(Aqn\*(Aq => 1,\*(Aqchildren\*(Aq => []}, \*(AqC\*(Aq ),
\&                                          bless( {\*(Aqn\*(Aq => 2,\*(Aqchildren\*(Aq => []}, \*(AqD\*(Aq )
\&                                         ]
\&                 }, \*(AqA\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 1,\*(Aqchildren\*(Aq => []}, \*(AqC\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 2,\*(Aqchildren\*(Aq => []}, \*(AqD\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 3,\*(Aqchildren\*(Aq => [bless( {\*(Aqn\*(Aq => 4,\*(Aqchildren\*(Aq => []}, \*(AqF\*(Aq )]}, \*(AqE\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 4,\*(Aqchildren\*(Aq => []}, \*(AqF\*(Aq );
.Ve
.PP
See the following example in which the nodes associated with \f(CW\*(Aqd\*(Aq\fR are
explictly constructed:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-28 ListWithRefs2.eyp| cat \-n
\&   1  # ListWithRefs2.eyp
\&   2  %semantic token \*(Aqc\*(Aq
\&   3  %{
\&   4  use Data::Dumper;
\&   5  %}
\&   6  %%
\&   7  S:  \*(Aqc\*(Aq+  D+
\&   8        {
\&   9           print Dumper($_[1]);
\&  10           print $_[1]\->str."\en";
\&  11           print Dumper($_[2]);
\&  12           print $_[2]\->str."\en";
\&  13        }
\&  14  ;
\&  15
\&  16  D: \*(Aqd\*(Aq.d
\&  17       {
\&  18         Parse::Eyapp::Node\->new(
\&  19           \*(AqDES(TERMINAL)\*(Aq,
\&  20            sub {
\&  21              my ($DES, $TERMINAL) = @_;
\&  22              $TERMINAL\->{attr} = $d;
\&  23            }
\&  24         );
\&  25       }
\&  26  ;
\&  27
\&  28  %%
.Ve
.PP
To know more about \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
see the Parse::Eyapp::Node section about \f(CW\*(C`new\*(C'\fR
.PP
When the former eyapp program is executed produces the following
output:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ eyapp ListWithRefs2.eyp; use_listwithrefs2.pl
\&  ccdd
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST_1\*(Aq );
\&  _PLUS_LIST_1(TERMINAL,TERMINAL)
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqDES\*(Aq ),
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqDES\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST_2\*(Aq );
\&  _PLUS_LIST_2(DES(TERMINAL),DES(TERMINAL))
.Ve
.PP
\fIThe \f(CI\*(C`*\*(C'\fI operator\fR
.IX Subsection "The * operator"
.PP
Any list operator operates on the factor to its left.
A list in the right hand side of a production rule
counts as a single symbol.
.PP
Both operators \f(CW\*(C`*\*(C'\fR and \f(CW\*(C`+\*(C'\fR can be used 
with the format
\&\f(CW\*(C`X <* Separator>\*(C'\fR.
In such case they describe lists of \f(CW\*(C`X\*(C'\fRs separated by 
\&\f(CW\*(C`separator\*(C'\fR. See an example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-25 CsBetweenCommansAndD.eyp | cat \-n
\&   1  # CsBetweenCommansAndD.eyp
\&   2
\&   3  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&   4
\&   5  %{
\&   6  sub TERMINAL::info {
\&   7    $_[0]\->attr;
\&   8  }
\&   9  %}
\&  10  %tree
\&  11  %%
\&  12  S:
\&  13      (\*(Aqc\*(Aq <* \*(Aq,\*(Aq> \*(Aqd\*(Aq)*
\&  14        {
\&  15           print "\enNode\en";
\&  16           print $_[1]\->str."\en";
\&  17           print "\enChild 0\en";
\&  18           print $_[1]\->child(0)\->str."\en";
\&  19           print "\enChild 1\en";
\&  20           print $_[1]\->child(1)\->str."\en";
\&  21           $_[1]
\&  22        }
\&  23  ;
\&  24
\&  25  %%
.Ve
.PP
The rule
.PP
.Vb 1
\&                            S: (\*(Aqc\*(Aq <* \*(Aq,\*(Aq> \*(Aqd\*(Aq)*
.Ve
.PP
has only two items in its right hand side: the (separated by commas) list
of \f(CW\*(C`c\*(C'\fRs and the list of \f(CW\*(C`d\*(C'\fRs.  The production rule is equivalent to:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v CsBetweenCommansAndD.eyp
\&  pl@nereida:~/LEyapp/examples$ head \-11 CsBetweenCommansAndD.output | cat \-n
\&   1  Rules:
\&   2  \-\-\-\-\-\-
\&   3  0:      $start \-> S $end
\&   4  1:      STAR\-1 \-> STAR\-1 \*(Aq,\*(Aq \*(Aqc\*(Aq
\&   5  2:      STAR\-1 \-> \*(Aqc\*(Aq
\&   6  3:      STAR\-2 \-> STAR\-1
\&   7  4:      STAR\-2 \-> /* empty */
\&   8  5:      PAREN\-3 \-> STAR\-2 \*(Aqd\*(Aq
\&   9  6:      STAR\-4 \-> STAR\-4 PAREN\-3
\&  10  7:      STAR\-4 \-> /* empty */
\&  11  8:      S \-> STAR\-4
.Ve
.PP
The semantic action associated with \f(CW\*(C`*\*(C'\fR is to return 
a reference to a list with the attributes of the 
matching items.
.PP
When working \-as in the example \-
under a tree creation directive it returns
a node belonging to a class named \f(CW\*(C`_STAR_LIST_#number\*(C'\fR
whose children are the items in the list.
The \f(CW\*(C`#number\*(C'\fR is the ordinal number of the production rule
as it appears in the \f(CW\*(C`.output\*(C'\fR file. The attributes must be 
references or associated with semantic tokens to be included 
in the list. Notice \-in the execution of the former
example  that follows \-
how the node for \f(CW\*(C`PAREN\-3\*(C'\fR has been 
eliminated from the tree. Parenthesis nodes are \- generally \-
obivated:
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples$ use_csbetweencommansandd.pl
\&  c,c,cd
\&
\&  Node
\&  _STAR_LIST_4(_STAR_LIST_1(TERMINAL[c],TERMINAL[c],TERMINAL[c]),TERMINAL[d])
\&
\&  Child 0
\&  _STAR_LIST_1(TERMINAL[c],TERMINAL[c],TERMINAL[c])
\&
\&  Child 1
\&  TERMINAL[d]
.Ve
.PP
Notice that the comma (since it is a syntactic token) has 
also been supressed.
.PP
\fIGiving Names to Lists\fR
.IX Subsection "Giving Names to Lists"
.PP
To set the name of the node associated with a list operator the
\&\f(CW%name\fR directive must precede the operator as in 
the following example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ sed \-ne \*(Aq1,27p\*(Aq CsBetweenCommansAndDWithNames.eyp | cat \-n
\&   1  # CsBetweenCommansAndDWithNames.eyp
\&   2
\&   3  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&   4
\&   5  %{
\&   6  sub TERMINAL::info {
\&   7    $_[0]\->attr;
\&   8  }
\&   9  %}
\&  10  %tree
\&  11  %%
\&  12  Start: S
\&  13  ;
\&  14  S:
\&  15      (\*(Aqc\*(Aq <%name Cs * \*(Aq,\*(Aq> \*(Aqd\*(Aq) %name Cs_and_d *
\&  16        {
\&  17           print "\enNode\en";
\&  18           print $_[1]\->str."\en";
\&  19           print "\enChild 0\en";
\&  20           print $_[1]\->child(0)\->str."\en";
\&  21           print "\enChild 1\en";
\&  22           print $_[1]\->child(1)\->str."\en";
\&  23           $_[1]
\&  24        }
\&  25  ;
\&  26
\&  27  %%
.Ve
.PP
The execution shows the renamed nodes:
.PP
pl@nereida:~/LEyapp/examples$ use_csbetweencommansanddwithnames.pl
c,c,c,cd
.PP
.Vb 2
\&  Node
\&  Cs_and_d(Cs(TERMINAL[c],TERMINAL[c],TERMINAL[c],TERMINAL[c]),TERMINAL[d])
\&
\&  Child 0
\&  Cs(TERMINAL[c],TERMINAL[c],TERMINAL[c],TERMINAL[c])
\&
\&  Child 1
\&  TERMINAL[d]
.Ve
.PP
\fIOptionals\fR
.IX Subsection "Optionals"
.PP
The \f(CW\*(C`X?\*(C'\fR operator stands for the presence or omission
of \f(CW\*(C`X\*(C'\fR.
.PP
The grammar:
.PP
.Vb 12
\&  pl@nereida:~/LEyapp/examples$ head \-11 List5.yp | cat \-n
\&       1  %semantic token \*(Aqc\*(Aq
\&       2  %tree
\&       3  %%
\&       4  S: \*(Aqc\*(Aq \*(Aqc\*(Aq?
\&       5       {
\&       6         print $_[2]\->str."\en";
\&       7         print $_[2]\->child(0)\->attr."\en" if $_[2]\->children;
\&       8      }
\&       9  ;
\&      10
\&      11  %%
.Ve
.PP
is equivalent to:
.PP
.Vb 8
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v List5
\&  pl@nereida:~/LEyapp/examples$ head \-7 List5.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> S $end
\&  1:      OPTIONAL\-1 \-> \*(Aqc\*(Aq
\&  2:      OPTIONAL\-1 \-> /* empty */
\&  3:      S \-> \*(Aqc\*(Aq OPTIONAL\-1
.Ve
.PP
When \f(CW\*(C`yybuildingtree\*(C'\fR is false the associated attribute 
is a list that will be empty if \s-1CX\s0> does not show up.
.PP
Under the \f(CW%tree\fR directive the action creates an c<_OPTIONAL>
node:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ use_list5.pl
\&  cc
\&  _OPTIONAL_1(TERMINAL)
\&  c
\&  pl@nereida:~/LEyapp/examples$ use_list5.pl
\&  c
\&  _OPTIONAL_1
.Ve
.PP
\fIParenthesis\fR
.IX Subsection "Parenthesis"
.PP
Any substring on the right hand side of a production rule can be grouped
using a parenthesis. The introduction of a parenthesis implies the introduction
of an additional syntactic variable whose only production 
is the sequence of symbols between the parenthesis. Thus the grammar:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ head \-6 Parenthesis.eyp | cat \-n
\&     1  %%
\&     2  S:
\&     3        (\*(Aqa\*(Aq S ) \*(Aqb\*(Aq  { shift; [ @_ ] }
\&     4      | \*(Aqc\*(Aq
\&     5  ;
\&     6  %%
.Ve
.PP
is equivalent to:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v Parenthesis.eyp; head \-6 Parenthesis.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> S $end
\&  1:      PAREN\-1 \-> \*(Aqa\*(Aq S
\&  2:      S \-> PAREN\-1 \*(Aqb\*(Aq
\&  3:      S \-> \*(Aqc\*(Aq
.Ve
.PP
By default the semantic rule associated with a parenthesis
returns an anonymous list with the attributes of the symbols 
between the parenthesis:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n use_parenthesis.pl
\&       1  #!/usr/bin/perl \-w
\&       2  use Parenthesis;
\&       3  use Data::Dumper;
\&       4
\&       5  $Data::Dumper::Indent = 1;
\&       6  $parser = Parenthesis\->new();
\&       7  print Dumper($parser\->Run);
\&  pl@nereida:~/LEyapp/examples$ use_parenthesis.pl
\&  acb
\&  $VAR1 = [
\&    [ \*(Aqa\*(Aq, \*(Aqc\*(Aq ], \*(Aqb\*(Aq
\&  ];
\&  pl@nereida:~/LEyapp/examples$ use_parenthesis.pl
\&  aacbb
\&  $VAR1 = [
\&    [
\&      \*(Aqa\*(Aq,
\&      [ [ \*(Aqa\*(Aq, \*(Aqc\*(Aq ], \*(Aqb\*(Aq ]
\&    ],
\&    \*(Aqb\*(Aq
\&  ];
.Ve
.PP
when working under a tree directive or when the attribute
\&\f(CW\*(C`buildingtree\*(C'\fR is set via the\f(CW\*(C`YYBuildingtree\*(C'\fR method
the semantic action returns a node with children the attributes
of the symbols between parenthesis. As usual attributes
which aren't references will be skipped from the list of children.
See an example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-23 List2.yp | cat \-n
\&   1  %{
\&   2  use Data::Dumper;
\&   3  %}
\&   4  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq \*(Aqc\*(Aq
\&   5  %tree
\&   6  %%
\&   7  S:
\&   8        (%name AS \*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&   9          {
\&  10            print "S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\en";
\&  11            print "Attribute of the first symbol:\en".Dumper($_[1]);
\&  12            print "Attribute of the second symbol: $_[2]\en";
\&  13            $_[0]\->YYBuildAST(@_[1..$#_]);
\&  14          }
\&  15      | \*(Aqc\*(Aq
\&  16          {
\&  17            print "S \-> \*(Aqc\*(Aq\en";
\&  18            my $r = Parse::Eyapp::Node\->new(qw(C(TERMINAL)), sub { $_[1]\->attr(\*(Aqc\*(Aq) }) ;
\&  19            print Dumper($r);
\&  20            $r;
\&  21          }
\&  22  ;
\&  23  %%
.Ve
.PP
The example shows (line 8)
how to rename a \f(CW\*(C`_PAREN\*(C'\fR node. The \f(CW\*(C`%name CLASSNAME\*(C'\fR goes
after the opening parenthesis.
.PP
The call to \f(CW\*(C`YYBuildAST\*(C'\fR at line 13
with argumetns the attributes of the symbols on the right hand side
returns the node describing the current production rule.
Notice that line 13 can be rewritten as:
.PP
.Vb 1
\&                    goto &Parse::Eyapp::Driver::YYBuildAST;
.Ve
.PP
At line 18 the node for the rule is explictly created
using \f(CW\*(C`Parse::Eyapp::Node\-\*(C'\fRnew>. The handler passed as second argument
is responsible for setting the value of the atribute \f(CW\*(C`attr\*(C'\fR
of the just created \f(CW\*(C`TERMINAL\*(C'\fR node.
.PP
Let us see an execution:
.PP
.Vb 11
\&  pl@nereida:~/LEyapp/examples$ use_list2.pl
\&  aacbb
\&  S \-> \*(Aqc\*(Aq
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( {
\&        \*(Aqchildren\*(Aq => [],
\&        \*(Aqattr\*(Aq => \*(Aqc\*(Aq
\&      }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(AqC\*(Aq );
.Ve
.PP
the first reduction occurs by the non recursive rule. The execution
shows the tree built by the call to
\&\f(CW\*(C`Parse::Eyapp::Node\-\*(C'\fRnew>
at line 18.
.PP
The execution continues with the reduction or antiderivation by the rule
\&\f(CW\*(C`S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\*(C'\fR. The action at lines 9\-14
dumps the attribute associated with \f(CW\*(C`(\*(Aqa\*(Aq S)\*(C'\fR
\&\- or, in other words,  the attribute associated with the variable 
\&\f(CW\*(C`PAREN\-1\*(C'\fR. It also dumps the attribute of \f(CW\*(Aqb\*(Aq\fR:
.PP
.Vb 11
\&  S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&  Attribute of the first symbol:
\&  $VAR1 = bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&        bless( { \*(Aqchildren\*(Aq => [ bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&       ]
\&     }, \*(AqC\*(Aq )
\&    ]
\&  }, \*(AqAS\*(Aq );
\&Attribute of the second symbol: b
.Ve
.PP
The last reduction shown is by the rule:
\&\f(CW\*(C`S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\*(C'\fR:
.PP
.Vb 10
\&  S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&  Attribute of the first symbol:
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( {
\&            \*(Aqchildren\*(Aq => [
\&              bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&              bless( {
\&                \*(Aqchildren\*(Aq => [
\&                  bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&                ]
\&              }, \*(AqC\*(Aq )
\&            ]
\&          }, \*(AqAS\*(Aq ),
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqb\*(Aq, \*(Aqtoken\*(Aq => \*(Aqb\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqS_2\*(Aq )
\&    ]
\&  }, \*(AqAS\*(Aq );
\&  Attribute of the second symbol: b
.Ve
.PP
\fIActions Inside Parenthesis\fR
.IX Subsection "Actions Inside Parenthesis"
.PP
Though is a practice to avoid, since it clutters
the code, it is certainly permitted to introduce
actions between the parenthesis, as in the example below:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-16 ListAndAction.eyp | cat \-n
\&   1  # ListAndAction.eyp
\&   2  %{
\&   3  my $num = 0;
\&   4  %}
\&   5
\&   6  %%
\&   7  S:      \*(Aqc\*(Aq
\&   8              {
\&   9                print "S \-> c\en"
\&  10              }
\&  11      |    (\*(Aqa\*(Aq {$num++; print "Seen <$num> \*(Aqa\*(Aqs\en"; $_[1] }) S \*(Aqb\*(Aq
\&  12              {
\&  13                print "S \-> (a ) S b\en"
\&  14              }
\&  15  ;
\&  16  %%
.Ve
.PP
This is the output when executing this program with input \f(CW\*(C`aaacbbb\*(C'\fR:
.PP
.Vb 9
\&  pl@nereida:~/LEyapp/examples$ use_listandaction.pl
\&  aaacbbb
\&  Seen <1> \*(Aqa\*(Aqs
\&  Seen <2> \*(Aqa\*(Aqs
\&  Seen <3> \*(Aqa\*(Aqs
\&  S \-> c
\&  S \-> (a ) S b
\&  S \-> (a ) S b
\&  S \-> (a ) S b
.Ve
.SS "Names for attributes"
.IX Subsection "Names for attributes"
Attributes can be referenced by meaningful names instead
of the classic error-prone positional approach using the \fIdot notation\fR:
.PP
.Vb 5
\&                        rhs:  rhseltwithid *
\&                        rhseltwithid : 
\&                              rhselt \*(Aq.\*(Aq IDENT 
\&                            | \*(Aq$\*(Aq rhselt  
\&                            | rhselt
.Ve
.PP
for example:
.PP
.Vb 1
\&              exp : exp.left \*(Aq\-\*(Aq exp.right  { $left \- $right }
.Ve
.PP
By qualifying the first appearance of the syntactic variable \f(CW\*(C`exp\*(C'\fR
with the notation \f(CW\*(C`exp.left\*(C'\fR we can later refer inside the actions
to the associated attribute using the lexical variable
\&\f(CW$left\fR.
.PP
The \fIdolar notation\fR \f(CW$A\fR can be used as an abbreviation
of \f(CW\*(C`A.A\*(C'\fR.
.SS "Default actions"
.IX Subsection "Default actions"
When no action is specified both \f(CW\*(C`yapp\*(C'\fR and \f(CW\*(C`eyapp\*(C'\fR
implicitly insert the semantic action \f(CW\*(C`{ $_[1] }\*(C'\fR. 
In \f(CW\*(C`Parse::Eyapp\*(C'\fR you can modify such behavior using the \f(CW\*(C`%defaultaction { Perl code }\*(C'\fR
directive. The \f(CW\*(C`{ Perl code }\*(C'\fR clause that follows the \f(CW%defaultaction\fR
directive is
executed when reducing by any production for which no explicit
action was specified.
.PP
\fITranslator from Infix to Postfix\fR
.IX Subsection "Translator from Infix to Postfix"
.PP
See an example that translates an infix expression
like \f(CW\*(C`a=b*\-3\*(C'\fR into a postfix expression like \f(CW\*(C`a b 3 NEG * = \*(C'\fR:
.PP
.Vb 5
\& # File Postfix.eyp (See the examples/ directory)
\& %right  \*(Aq=\*(Aq
\& %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\& %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\& %left   NEG
\&
\& %defaultaction { return  "$left $right $op"; }
\&
\& %%
\& line: $exp  { print "$exp\en" }
\& ;
\&
\& exp:        $NUM  { $NUM }
\&         |   $VAR  { $VAR }
\&         |   VAR.left \*(Aq=\*(Aq.op exp.right
\&         |   exp.left \*(Aq+\*(Aq.op exp.right
\&         |   exp.left \*(Aq\-\*(Aq.op exp.right
\&         |   exp.left \*(Aq*\*(Aq.op exp.right
\&         |   exp.left \*(Aq/\*(Aq.op exp.right
\&         |   \*(Aq\-\*(Aq $exp %prec NEG { "$exp NEG" }
\&         |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq { $exp }
\& ;
\&
\& %%
\&
\& # Support subroutines as in the Synopsis example
\& ...
.Ve
.PP
The file containing the \f(CW\*(C`Eyapp\*(C'\fR program must be compiled with \f(CW\*(C`eyapp\*(C'\fR:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> eyapp Postfix.eyp
.Ve
.PP
Next, you have to write a client program:
.PP
.Vb 7
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n usepostfix.pl
\&      1  #!/usr/bin/perl \-w
\&      2  use strict;
\&      3  use Postfix;
\&      4
\&      5  my $parser = new Postfix();
\&      6  $parser\->Run;
.Ve
.PP
Now we can run the client program:
.PP
.Vb 3
\& nereida:~/src/perl/YappWithDefaultAction/examples> usepostfix.pl
\& Write an expression: \-(2*a\-b*\-3)
\& 2 a * b 3 NEG * \- NEG
.Ve
.PP
\fIDefault Actions, \f(CI%name\fI and \f(CI\*(C`YYName\*(C'\fI\fR
.IX Subsection "Default Actions, %name and YYName"
.PP
In \f(CW\*(C`eyapp\*(C'\fR each production rule has a name.
The name of a rule can be explicitly given by the programmer 
using the \f(CW%name\fR directive. For example, in the piece of code
that follows the name \f(CW\*(C`ASSIGN\*(C'\fR is given to the rule \f(CW\*(C`exp: VAR \*(Aq=\*(Aq exp\*(C'\fR.
.PP
When no explicit name is given the rule has an implicit name.
The implicit name of a rule is shaped by concatenating
the name of the syntactic variable on its left, an underscore 
and the ordinal number of the production rule \f(CW\*(C`Lhs_#\*(C'\fR
as it appears in the \f(CW\*(C`.output\*(C'\fR file.
Avoid giving names matching such pattern to production rules.
The patterns
\&\f(CW\*(C`/${lhs}_\ed+$/\*(C'\fR where \f(CW\*(C`${lhs}\*(C'\fR is the name of the syntactic variable
are reserved for internal use by \f(CW\*(C`eyapp\*(C'\fR.
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n Lhs.eyp
\&   1  # Lhs.eyp
\&   2
\&   3  %right  \*(Aq=\*(Aq
\&   4  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&   5  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&   6  %left   NEG
\&   7
\&   8  %defaultaction {
\&   9    my $self = shift;
\&  10    my $name = $self\->YYName();
\&  11    bless { children => [ grep {ref($_)} @_] }, $name;
\&  12  }
\&  13
\&  14  %%
\&  15  input:
\&  16              /* empty */
\&  17                { [] }
\&  18          |   input line
\&  19                {
\&  20                  push @{$_[1]}, $_[2] if defined($_[2]);
\&  21                  $_[1]
\&  22                }
\&  23  ;
\&  24
\&  25  line:     \*(Aq\en\*(Aq       { }
\&  26          | exp \*(Aq\en\*(Aq   {  $_[1] }
\&  27  ;
\&  28
\&  29  exp:
\&  30              NUM   { $_[1] }
\&  31          |   VAR   { $_[1] }
\&  32          |   %name ASSIGN
\&  33              VAR \*(Aq=\*(Aq exp
\&  34          |   %name PLUS
\&  35              exp \*(Aq+\*(Aq exp
\&  36          |   %name MINUS
\&  37              exp \*(Aq\-\*(Aq exp
\&  38          |   %name TIMES
\&  39              exp \*(Aq*\*(Aq exp
\&  40          |   %name DIV
\&  41              exp \*(Aq/\*(Aq exp
\&  42          |   %name UMINUS
\&  43              \*(Aq\-\*(Aq exp %prec NEG
\&  44          |  \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&  45  ;
.Ve
.PP
Inside a semantic action
the name of the current rule can be recovered 
using the method \f(CW\*(C`YYName\*(C'\fR of the parser object.
.PP
The default action (lines 8\-12) computes as attribute of the left
hand side a reference to an object blessed in the name of the rule.
The object has an attribute \f(CW\*(C`children\*(C'\fR which is a reference 
to the list of children of the node.
The call to \f(CW\*(C`grep\*(C'\fR
.PP
.Vb 1
\&  11    bless { children => [ grep {ref($_)} @_] }, $name;
.Ve
.PP
excludes children that aren't references. Notice that the lexical analyzer 
only returns references for the \f(CW\*(C`NUM\*(C'\fR and \f(CW\*(C`VAR\*(C'\fR terminals:
.PP
.Vb 10
\&  59  sub _Lexer {
\&  60      my($parser)=shift;
\&  61
\&  62      for ($parser\->YYData\->{INPUT}) {
\&  63          s/^[ \et]+//;
\&  64          return(\*(Aq\*(Aq,undef) unless $_;
\&  65          s/^([0\-9]+(?:\e.[0\-9]+)?)//
\&  66                  and return(\*(AqNUM\*(Aq, bless { attr => $1}, \*(AqNUM\*(Aq);
\&  67          s/^([A\-Za\-z][A\-Za\-z0\-9_]*)//
\&  68                  and return(\*(AqVAR\*(Aq,bless {attr => $1}, \*(AqVAR\*(Aq);
\&  69          s/^(.)//s
\&  70                  and return($1, $1);
\&  71      }
\&  72      return(\*(Aq\*(Aq,undef);
\&  73  }
.Ve
.PP
follows the client program:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n uselhs.pl
\&       1  #!/usr/bin/perl \-w
\&       2  use Lhs;
\&       3  use Data::Dumper;
\&       4
\&       5  $parser = new Lhs();
\&       6  my $tree = $parser\->Run;
\&       7  $Data::Dumper::Indent = 1;
\&       8  if (defined($tree)) { print Dumper($tree); }
\&       9  else { print "Cadena no vA\*~Xlida\en"; }
.Ve
.PP
When executed with input \f(CW\*(C`a=(2+3)*b\*(C'\fR the parser produces
the following tree:
.PP
.Vb 1
\&  ASSIGN(TIMES(PLUS(NUM[2],NUM[3]), VAR[b]))
.Ve
.PP
See the result of an execution:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ uselhs.pl
\&  a=(2+3)*b
\&  $VAR1 = [
\&    bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqattr\*(Aq => \*(Aqa\*(Aq }, \*(AqVAR\*(Aq ),
\&        bless( {
\&          \*(Aqchildren\*(Aq => [
\&            bless( {
\&              \*(Aqchildren\*(Aq => [
\&                bless( { \*(Aqattr\*(Aq => \*(Aq2\*(Aq }, \*(AqNUM\*(Aq ),
\&                bless( { \*(Aqattr\*(Aq => \*(Aq3\*(Aq }, \*(AqNUM\*(Aq )
\&              ]
\&            }, \*(AqPLUS\*(Aq ),
\&            bless( { \*(Aqattr\*(Aq => \*(Aqb\*(Aq }, \*(AqVAR\*(Aq )
\&          ]
\&        }, \*(AqTIMES\*(Aq )
\&      ]
\&    }, \*(AqASSIGN\*(Aq )
\&  ];
.Ve
.PP
The name of a production rule can be changed at execution time.
See the following example:
.PP
.Vb 10
\&  29  exp:
\&  30              NUM   { $_[1] }
\&  31          |   VAR   { $_[1] }
\&  32          |   %name ASSIGN
\&  33              VAR \*(Aq=\*(Aq exp
\&  34          |   %name PLUS
\&  35              exp \*(Aq+\*(Aq exp
\&  36          |   %name MINUS
\&  37              exp \*(Aq\-\*(Aq exp
\&  38                {
\&  39                  my $self = shift;
\&  40                  $self\->YYName(\*(AqSUBSTRACT\*(Aq); # rename it
\&  41                  $self\->YYBuildAST(@_); # build the node
\&  42                }
\&  43          |   %name TIMES
\&  44              exp \*(Aq*\*(Aq exp
\&  45          |   %name DIV
\&  46              exp \*(Aq/\*(Aq exp
\&  47          |   %name UMINUS
\&  48              \*(Aq\-\*(Aq exp %prec NEG
\&  49          |  \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&  50  ;
.Ve
.PP
When the client program is executed we can see the presence
of the \f(CW\*(C`SUBSTRACT\*(C'\fR nodes:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ useyynamedynamic.pl
\&  2\-b
\&  $VAR1 = [
\&    bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( {
\&          \*(Aqattr\*(Aq => \*(Aq2\*(Aq
\&        }, \*(AqNUM\*(Aq ),
\&        bless( {
\&          \*(Aqattr\*(Aq => \*(Aqb\*(Aq
\&        }, \*(AqVAR\*(Aq )
\&      ]
\&    }, \*(AqSUBSTRACT\*(Aq )
\&  ];
.Ve
.ie n .SS "Abstract Syntax Trees : %tree and %name"
.el .SS "Abstract Syntax Trees : \f(CW%tree\fP and \f(CW%name\fP"
.IX Subsection "Abstract Syntax Trees : %tree and %name"
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR facilitates the construction of concrete syntax trees and 
abstract syntax trees (abbreviated \s-1AST\s0 from now on) through the \f(CW%tree\fR
directive. 
Nodes in the \s-1AST\s0 are blessed in the production
\&\f(CW\*(C`name\*(C'\fR. 
By default the name of a production is the concatenation
of the left hand side and the production number. The production number
is the ordinal number of the production as they appear in the associated 
\&\f(CW\*(C`.output\*(C'\fR file (see option \f(CW\*(C`\-v\*(C'\fR of eyapp). For example,
given the grammar:
.PP
.Vb 7
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq9,28p\*(Aq treewithoutnames.pl
\& my $grammar = q{
\&   %right  \*(Aq=\*(Aq     # Lowest precedence
\&   %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&   %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&   %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&   %tree           # Let us build an abstract syntax tree ...
\&
\&   %%
\&   line: exp <+ \*(Aq;\*(Aq>  { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&   ;
\&
\&   exp:
\&        NUM           |   VAR       | VAR \*(Aq=\*(Aq exp
\&     | exp \*(Aq+\*(Aq exp    | exp \*(Aq\-\*(Aq exp |  exp \*(Aq*\*(Aq exp
\&     | exp \*(Aq/\*(Aq exp
\&     | \*(Aq\-\*(Aq exp %prec NEG
\&     |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&   ;
.Ve
.PP
The tree produced by the parser when feed with input \f(CW\*(C`a=2*b\*(C'\fR
is:
.PP
.Vb 1
\& _PLUS_LIST(exp_6(TERMINAL[a],exp_9(exp_4(TERMINAL[2]),exp_5(TERMINAL[b]))))
.Ve
.PP
If we want to see the correspondence between names and rules we can generate and
check the corresponding file \f(CW\*(C`.output\*(C'\fR:
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq28,42p\*(Aq treewithoutnames.output
\& Rules:
\& \-\-\-\-\-\-
\& 0:      $start \-> line $end
\& 1:      PLUS\-1 \-> PLUS\-1 \*(Aq;\*(Aq exp
\& 2:      PLUS\-1 \-> exp
\& 3:      line \-> PLUS\-1
\& 4:      exp \-> NUM
\& 5:      exp \-> VAR
\& 6:      exp \-> VAR \*(Aq=\*(Aq exp
\& 7:      exp \-> exp \*(Aq+\*(Aq exp
\& 8:      exp \-> exp \*(Aq\-\*(Aq exp
\& 9:      exp \-> exp \*(Aq*\*(Aq exp
\& 10:     exp \-> exp \*(Aq/\*(Aq exp
\& 11:     exp \-> \*(Aq\-\*(Aq exp
\& 12:     exp \-> \*(Aq(\*(Aq exp \*(Aq)\*(Aq
.Ve
.PP
We can see now that the node \f(CW\*(C`exp_9\*(C'\fR corresponds to the production \f(CW\*(C`exp \-> exp \*(Aq*\*(Aq exp\*(C'\fR.
Observe also that the Eyapp production:
.PP
.Vb 2
\&                                line: exp <+ \*(Aq;\*(Aq>
\&actually produces the productions:
\&
\&                        1:      PLUS\-1 \-> PLUS\-1 \*(Aq;\*(Aq exp
\&                        2:      PLUS\-1 \-> exp
.Ve
.PP
and that the name of the class associated with the non empty list is \f(CW\*(C`_PLUS_LIST\*(C'\fR.
.PP
A production rule can be 
\&\fInamed\fR using the \f(CW\*(C`%name IDENTIFIER\*(C'\fR directive. 
For each production rule a 
namespace/package is created. \fIThe\fR \f(CW\*(C`IDENTIFIER\*(C'\fR
\&\fIis the name of the associated package\fR.
Therefore, by modifying the former grammar with 
additional \f(CW%name\fR directives:
.PP
.Vb 7
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq8,26p\*(Aq treewithnames.pl
\& my $grammar = q{
\&   %right  \*(Aq=\*(Aq     # Lowest precedence
\&   %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&   %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&   %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&   %tree           # Let us build an abstract syntax tree ...
\&
\&   %%
\&   line: exp <%name EXPS + \*(Aq;\*(Aq>  { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&   ;
\&
\&   exp:
\&       %name NUM    NUM           | %name VAR   VAR         | %name ASSIGN VAR \*(Aq=\*(Aq exp
\&     | %name PLUS   exp \*(Aq+\*(Aq exp   | %name MINUS exp \*(Aq\-\*(Aq exp | %name TIMES  exp \*(Aq*\*(Aq exp
\&     | %name DIV    exp \*(Aq/\*(Aq exp
\&     | %name UMINUS \*(Aq\-\*(Aq exp %prec NEG
\&     |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&   ;
.Ve
.PP
we are explictly naming the productions. Thus, all the node instances 
corresponding to the 
production \f(CW\*(C`exp: VAR \*(Aq=\*(Aq exp\*(C'\fR will belong to the class \f(CW\*(C`ASSIGN\*(C'\fR. Now 
the tree for \f(CW\*(C`a=2*b\*(C'\fR becomes:
.PP
.Vb 1
\&          EXPS(ASSIGN(TERMINAL[a],TIMES(NUM(TERMINAL[2]),VAR(TERMINAL[b]))))
.Ve
.PP
Observe how the list has been named \f(CW\*(C`EXPS\*(C'\fR. The \f(CW%name\fR directive prefixes the 
list operator (\f(CW\*(C`[+*?]\*(C'\fR).
.PP
\fIAbout the Encapsulation of Nodes\fR
.IX Subsection "About the Encapsulation of Nodes"
.PP
There is no encapsulation of nodes. The user/client 
knows that they are hashes that can be decorated with new keys/attributes.
All nodes in the \s-1AST\s0 created by \f(CW%tree\fR are \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR nodes.
The only reserved field is \f(CW\*(C`children\*(C'\fR which is a reference to the
array of children. You can always create a \f(CW\*(C`Node\*(C'\fR class 
\&\fIby hand\fR by inheriting from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR. See 
section 'Compiling with eyapp and treereg' in Parse::Eyapp for an example.
.PP
\fI\s-1TERMINAL\s0 Nodes\fR
.IX Subsection "TERMINAL Nodes"
.PP
Nodes named \f(CW\*(C`TERMINAL\*(C'\fR are built from the
tokens provided by the lexical analyzer. 
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR follows the same protocol
than Parse::Yapp for communication between the parser and the lexical analyzer:
A couple \f(CW\*(C`($token, $attribute)\*(C'\fR is returned by the lexical analyzer.
These values are stored under the keys \f(CW\*(C`token\*(C'\fR and \f(CW\*(C`attr\*(C'\fR.
\&\f(CW\*(C`TERMINAL\*(C'\fR nodes as all \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR nodes
also have the attribute \f(CW\*(C`children\*(C'\fR but is \- almost always \- empty.
.PP
\fIExplicit Actions Inside \f(CI%tree\fI\fR
.IX Subsection "Explicit Actions Inside %tree"
.PP
Explicit actions can be specified by the programmer like in this line
from the Parse::Eyapp \f(CW\*(C`SYNOPSIS\*(C'\fR example:
.PP
.Vb 1
\&      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }  /* Let us simplify a bit the tree */
.Ve
.PP
Explicit actions receive as arguments the references to the children nodes already 
built. The programmer can influence the shape of the tree by inserting
these explicit actions. In this example the programmer has decided to simplify the 
syntax tree: the nodes associated with the parenthesis are 
discarded and the reference to the subtree containing the proper
expression is returned. Such manoeuvre is called \fIbypassing\fR.
See section \*(L"The  bypass clause and the \f(CW%no\fR bypass directive\*(R"
to know more about \fIautomatic bypassing\fR
.PP
\fIExplicitly Building Nodes With \f(CI\*(C`YYBuildAST\*(C'\fI\fR
.IX Subsection "Explicitly Building Nodes With YYBuildAST"
.PP
Sometimes the best time to decorate a node with some
attributes is just after being built.
In such cases the programmer can take \fImanual control\fR
building the node with \f(CW\*(C`YYBuildAST\*(C'\fR to 
inmediately proceed to decorate it.
.PP
The following example illustrates the situation:
.PP
.Vb 9
\& Variable:
\&     %name  VARARRAY
\&     $ID (\*(Aq[\*(Aq binary \*(Aq]\*(Aq) <%name INDEXSPEC +>
\&       {
\&         my $self = shift;
\&         my $node =  $self\->YYBuildAST(@_);
\&         $node\->{line} = $ID\->[1];
\&         return $node;
\&       }
.Ve
.PP
This production rule defines the expression to access an array element 
as an identifier followed by
a non empty list of binary expressions \f(CW\*(C` Variable: ID (\*(Aq[\*(Aq binary \*(Aq]\*(Aq)+\*(C'\fR. 
Furthermore, the node corresponding
to the list of indices has been named \f(CW\*(C`INDEXSPEC\*(C'\fR.
.PP
When no explicit action is
inserted a binary node will be built having as first child the node
corresponding to the identifier \f(CW$ID\fR and as second child the reference 
to the list of binary expressions. The children corresponding to
\&\f(CW\*(Aq[\*(Aq\fR and \f(CW\*(Aq]\*(Aq\fR are discarded since they are \-by default\- \fIsyntactic tokens\fR
(see section \*(L"Syntactic and Semantic tokens\*(R").
However, the programmer wants to decorate
the node being built with a \f(CW\*(C`line\*(C'\fR attribute holding the line number in the source
code where the identifier being used appears. The call to the \f(CW\*(C`Parse::Eyapp::Driver\*(C'\fR
method \f(CW\*(C`YYBuildAST\*(C'\fR does the job of building the node. After
that the node can be decorated and returned.
.PP
Actually, the \f(CW%tree\fR directive is semantically equivalent to:
.PP
.Vb 1
\&                %default action { goto &Parse::Eyapp::Driver::YYBuildAST }
.Ve
.PP
\fIReturning non References Under \f(CI%tree\fI\fR
.IX Subsection "Returning non References Under %tree"
.PP
When a \fIexplicit user action returns s.t. that is not a reference
no node will be inserted\fR. This fact can be used to supress nodes
in the \s-1AST\s0 being built. See the following example (file \f(CW\*(C`examples/returnnonode.yp\*(C'\fR):
.PP
.Vb 12
\& nereida:~/src/perl/YappWithDefaultAction/examples> sed \-ne \*(Aq1,11p\*(Aq returnnonode.yp | cat \-n
\&  1  %tree
\&  2  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq
\&  3  %%
\&  4  S:  /* empty */
\&  5      | S A
\&  6      | S B
\&  7  ;
\&  8  A : \*(Aqa\*(Aq
\&  9  ;
\& 10  B : \*(Aqb\*(Aq { }
\& 11  ;
.Ve
.PP
since the action at line 10 returns \f(CW\*(C`undef\*(C'\fR
the \f(CW\*(C`B : \*(Aqb\*(Aq\*(C'\fR subtree will not be inserted in the \s-1AST:\s0
.PP
.Vb 3
\& nereida:~/src/perl/YappWithDefaultAction/examples> usereturnnonode.pl
\& ababa
\& S_2(S_3(S_2(S_3(S_2(S_1,A_4(TERMINAL[a]))),A_4(TERMINAL[a]))),A_4(TERMINAL[a]))
.Ve
.PP
Observe the absence of \f(CW\*(C`B\*(C'\fRs and \f(CW\*(Aqb\*(Aq\fRs.
.PP
\fIIntermediate actions and \f(CI%tree\fI\fR
.IX Subsection "Intermediate actions and %tree"
.PP
Intermediate actions can be used to change the shape of the \s-1AST\s0 (prune it,
decorate it, etc.) but the value returned by them is ignored. The grammar 
below has two intermediate actions. They modify the attributes of the
node to its left and return a reference \f(CW$f\fR to such node (lines 5 and 6):
.PP
.Vb 12
\& nereida:~/src/perl/YappWithDefaultAction/examples> \e
\&          sed \-ne \*(Aq1,10p\*(Aq intermediateactiontree.yp | cat \-n
\&  1  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq
\&  2  %tree bypass
\&  3  %%
\&  4  S:    /* empty */
\&  5      | S A.f { $f\->{attr} = "A"; $f; } A
\&  6      | S B.f { $f\->{attr} = "B"; $f; } B
\&  7  ;
\&  8  A : %name A \*(Aqa\*(Aq
\&  9  ;
\& 10  B : %name B \*(Aqb\*(Aq
.Ve
.PP
See the client program running:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n useintermediateactiontree.pl
\&  1  #!/usr/bin/perl \-w
\&  2  use strict;
\&  3  use Parse::Eyapp;
\&  4  use intermediateactiontree;
\&  5
\&  6  { no warnings;
\&  7  *A::info = *B::info = sub { $_[0]{attr} };
\&  8  }
\&  9
\& 10  my $parser = intermediateactiontree\->new();
\& 11  my $t = $parser\->Run;
\& 12  print $t\->str,"\en";
\& nereida:~/src/perl/YappWithDefaultAction/examples> useintermediateactiontree.pl
\& aabbaa
\& S_2(S_4(S_2(S_1,A[A],A[a]),B[B],B[b]),A[A],A[a])
.Ve
.PP
The 
attributes 
of left \f(CW\*(C`A\*(C'\fRs 
have been effectively changed by the intermediate actions
from \f(CW\*(Aqa\*(Aq\fR to \f(CW\*(AqA\*(Aq\fR.
However no further children have been inserted.
.PP
\fISyntactic and Semantic tokens\fR
.IX Subsection "Syntactic and Semantic tokens"
.PP
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR diferences between \f(CW\*(C`syntactic tokens\*(C'\fR
and \f(CW\*(C`semantic tokens\*(C'\fR. By default all tokens
declared using string notation (i.e. between quotes
like \f(CW\*(Aq+\*(Aq\fR, \f(CW\*(Aq=\*(Aq\fR)
are considered \fIsyntactic tokens\fR. Tokens declared by an identifier
(like \f(CW\*(C`NUM\*(C'\fR or \f(CW\*(C`VAR\*(C'\fR) are by default considered
\&\fIsemantic tokens\fR. \fBSyntactic tokens do not yield to nodes in the
syntactic tree\fR. Thus, the first print in the former Parse::Eyapp \f(CW\*(C`/SYNOPSIS\*(C'\fR example:
.PP
.Vb 4
\&              $parser\->YYData\->{INPUT} = "2*\-3+b*0;\-\-2\en"; 
\&              my $t = $parser\->Run;                    
\&              local $Parse::Eyapp::Node::INDENT=2;
\&              print "Syntax Tree:",$t\->str;
.Ve
.PP
gives as result the following output:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> synopsis.pl
\& Syntax Tree:
\& EXPRESION_LIST(
\&   PLUS(
\&     TIMES(
\&       NUM(
\&         TERMINAL[2]
\&       ),
\&       UMINUS(
\&         NUM(
\&           TERMINAL[3]
\&         )
\&       ) # UMINUS
\&     ) # TIMES,
\&     TIMES(
\&       VAR(
\&         TERMINAL[b]
\&       ),
\&       NUM(
\&         TERMINAL[0]
\&       )
\&     ) # TIMES
\&   ) # PLUS,
\&   UMINUS(
\&     UMINUS(
\&       NUM(
\&         TERMINAL[2]
\&       )
\&     ) # UMINUS
\&   ) # UMINUS
\& ) # EXPRESION_LIST
.Ve
.PP
\&\f(CW\*(C`TERMINAL\*(C'\fR nodes corresponding to tokens that were defined by strings like
\&\f(CW\*(Aq=\*(Aq\fR, \f(CW\*(Aq\-\*(Aq\fR, \f(CW\*(Aq+\*(Aq\fR, \f(CW\*(Aq/\*(Aq\fR, \f(CW\*(Aq*\*(Aq\fR, \f(CW\*(Aq(\*(Aq\fR and \f(CW\*(Aq)\*(Aq\fR  do not 
appear in the tree.  \f(CW\*(C`TERMINAL\*(C'\fR nodes corresponding to tokens that were defined
using an identifer, like \f(CW\*(C`NUM\*(C'\fR or \f(CW\*(C`VAR\*(C'\fR are, by default,  \fIsemantic tokens\fR
and appear in the \s-1AST\s0.
.PP
\fIChanging the Status of a Token\fR
.IX Subsection "Changing the Status of a Token"
.PP
The new token declaration directives \f(CW\*(C`%syntactic token\*(C'\fR and
\&\f(CW\*(C`%semantic token\*(C'\fR can change the status of a token.
For example (file \f(CW\*(C`15treewithsyntactictoken.pl\*(C'\fR in the \f(CW\*(C`examples/\*(C'\fR directory), 
given the grammar:
.PP
.Vb 3
\&   %syntactic token b
\&   %semantic token \*(Aqa\*(Aq \*(Aqc\*(Aq
\&   %tree
\&
\&   %%
\&
\&   S: %name ABC
\&        A B C
\&    | %name BC
\&        B C
\&   ;
\&
\&   A: %name A
\&        \*(Aqa\*(Aq
\&   ;
\&
\&   B: %name B
\&        b
\&   ;
\&
\&   C: %name C
\&       \*(Aqc\*(Aq
\&   ;
\&   %%
.Ve
.PP
the tree build for input \f(CW\*(C`abc\*(C'\fR will be 
\&\f(CW\*(C`ABC(A(TERMINAL[a]),B,C(TERMINAL[c]))\*(C'\fR.
.PP
\fISaving the Information of Syntactic Tokens in their Father\fR
.IX Subsection "Saving the Information of Syntactic Tokens in their Father"
.PP
The reason for the adjective \f(CW%syntactic\fR applied to a token is to 
state that the token influences the shape of the syntax tree
but carries no other information. When the syntax tree is built
the node corresponding to the token is discarded.
.PP
Sometimes the difference between syntactic and semantic 
tokens is blurred. For example the line number associated
with an instance of the syntactic token \f(CW\*(Aq+\*(Aq\fR can be used later
\&\-say during type checking\- to emit a more accurate error
diagnostic. But if the node was discarded the information
about that line number is no longer available.
When building the syntax tree \f(CW\*(C`Parse::Eyapp\*(C'\fR (namely
the method \f(CW\*(C`Parse::Eyapp::YYBuildAST\*(C'\fR) checks 
if the method \f(CW\*(C`TERMINAL::save_attributes\*(C'\fR exists and if so
it will be called when dealing with a \fIsyntactic token\fR. 
The method receives as argument \- additionally
to the reference to the attribute of the token as it
is returned by the lexical analyzer \- a reference
to the node associated with the left hand side of the
production. Here is an example (file \f(CW\*(C`examples/Types.eyp\*(C'\fR)
of use:
.PP
.Vb 5
\&              sub TERMINAL::save_attributes {
\&                # $_[0] is a syntactic terminal
\&                # $_[1] is the father.
\&                push @{$_[1]\->{lines}}, $_[0]\->[1]; # save the line number
\&              }
.Ve
.PP
\fIThe  \f(CI\*(C`bypass\*(C'\fI clause and the \f(CI\*(C`%no bypass\*(C'\fI directive\fR
.IX Subsection "The  bypass clause and the %no bypass directive"
.PP
The shape of the tree can be also modified using some \f(CW%tree\fR clauses
as \f(CW\*(C`%tree bypass\*(C'\fR which will produce an automatic \fIbypass\fR of any
node with only one child at tree-construction-time.
.PP
A \fIbypass operation\fR consists in \fIreturning the only child 
of the node being visited to the father of the node and re-typing (re-blessing)
the node in the name of the production\fR (if a name was provided).
.PP
A node may have only one child at tree-construction-time for one of
two reasons.
.IP "\(bu" 4
The first occurs when the right hand side of the production
was already unary like in:
.Sp
.Vb 2
\&                           exp:
\&                               %name NUM  NUM
.Ve
.Sp
Here \- if the \f(CW\*(C`bypass\*(C'\fR clause is used \- 
the \f(CW\*(C`NUM\*(C'\fR node will be bypassed and the child \f(CW\*(C`TERMINAL\*(C'\fR built
from the information provided by the lexical analyzer will be renamed/reblessed 
as \f(CW\*(C`NUM\*(C'\fR.
.IP "\(bu" 4
Another reason for a node to be \fIbypassed\fR is  the fact that though the right
hand side of the production may have more than one symbol, 
only one of them is not a syntactic token
like in:
.Sp
.Vb 1
\&                           exp: \*(Aq(\*(Aq exp \*(Aq)\*(Aq
.Ve
.PP
A consequence of the global scope application of \f(CW\*(C`%tree bypass\*(C'\fR
is that undesired bypasses may occur like in
.PP
.Vb 2
\&                           exp : %name UMINUS
\&                                 \*(Aq\-\*(Aq $exp %prec NEG
.Ve
.PP
though the right hand side has two symbols, token \f(CW\*(Aq\-\*(Aq\fR is
a syntactic token and therefore only \f(CW\*(C`exp\*(C'\fR is left. The \fIbypass\fR
operation will be applied when building this node.
This \fIbypass\fR can be avoided applying the \f(CW\*(C`no bypass ID\*(C'\fR directive to the corresponding 
production:
.PP
.Vb 2
\&                           exp : %no bypass UMINUS
\&                                 \*(Aq\-\*(Aq $exp %prec NEG
.Ve
.PP
The following example (file \f(CW\*(C`examples/bypass.pl\*(C'\fR) 
is the equivalent of the Parse::Eyapp \f(CW\*(C`/SYNOPSIS\*(C'\fR example
but using the \f(CW\*(C`bypass\*(C'\fR clause instead:
.PP
.Vb 2
\& use Parse::Eyapp;
\& use Parse::Eyapp::Treeregexp;
\&
\& sub TERMINAL::info { $_[0]{attr} }
\& { no warnings; *VAR::info = *NUM::info = \e&TERMINAL::info; }
\&
\& my $grammar = q{
\&   %right  \*(Aq=\*(Aq     # Lowest precedence
\&   %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq 
\&   %left   \*(Aq*\*(Aq \*(Aq/\*(Aq 
\&   %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&   %tree bypass    # Let us build an abstract syntax tree ...
\&
\&   %%
\&   line: exp <%name EXPRESION_LIST + \*(Aq;\*(Aq>  { $_[1] } 
\&   ;
\&
\&   exp:
\&       %name NUM  NUM            | %name VAR   VAR         | %name ASSIGN VAR \*(Aq=\*(Aq exp
\&     | %name PLUS exp \*(Aq+\*(Aq exp    | %name MINUS exp \*(Aq\-\*(Aq exp | %name TIMES  exp \*(Aq*\*(Aq exp
\&     | %name DIV     exp \*(Aq/\*(Aq exp
\&     | %no bypass UMINUS
\&       \*(Aq\-\*(Aq $exp %prec NEG
\&     |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&   ;
\&
\&   %%
\&   # sub _Error, _Lexer and Run like in the synopsis example
\&   # ...
\& }; # end grammar
\&
\& our (@all, $uminus);
\&
\& Parse::Eyapp\->new_grammar( # Create the parser package/class
\&   input=>$grammar,
\&   classname=>\*(AqCalc\*(Aq, # The name of the package containing the parser
\&   firstline=>7       # String $grammar starts at line 7 (for error diagnostics)
\& );
\& my $parser = Calc\->new();                # Create a parser
\& $parser\->YYData\->{INPUT} = "a=2*\-3+b*0\en"; # Set the input
\& my $t = $parser\->Run;                    # Parse it!
\&
\& print "\en************\en".$t\->str."\en************\en";
\&
\& # Let us transform the tree. Define the tree\-regular expressions ..
\& my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&   { #  Example of support code
\&     my %Op = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&   }
\&   constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM, NUM)
\&     => {
\&       my $op = $Op{ref($_[0])};
\&       $NUM[0]\->{attr} = eval  "$NUM[0]\->{attr} $op $NUM[1]\->{attr}";
\&       $_[0] = $NUM[0];
\&     }
\&   zero_times_whatever: TIMES(NUM, .) and { $NUM\->{attr} == 0 } => { $_[0] = $NUM }
\&   whatever_times_zero: TIMES(., NUM) and { $NUM\->{attr} == 0 } => { $_[0] = $NUM }
\&   uminus: UMINUS(NUM) => { $NUM\->{attr} = \-$NUM\->{attr}; $_[0] = $NUM }
\&   },
\&   OUTPUTFILE=> \*(Aqmain.pm\*(Aq
\& );
\& $p\->generate(); # Create the tranformations
\&
\& $t\->s(@all);    # constant folding and mult. by zero
\&
\& print $t\->str,"\en";
.Ve
.PP
when running this example with input \f(CW"a=2*\-3+b*0\en"\fR
we obtain the following output:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> bypass.pl
\&
\& ************
\& EXPRESION_LIST(ASSIGN(TERMINAL[a],PLUS(TIMES(NUM[2],UMINUS(NUM[3])),TIMES(VAR[b],NUM[0]))))
\& ************
\& EXPRESION_LIST(ASSIGN(TERMINAL[a],NUM[\-6]))
.Ve
.PP
As you can see the trees are more compact when using the \f(CW\*(C`bypass\*(C'\fR directive.
.PP
\fIThe \f(CI\*(C`alias\*(C'\fI clause of the \f(CI%tree\fI directive\fR
.IX Subsection "The alias clause of the %tree directive"
.PP
Access to children in Parse::Eyapp is made through the \f(CW\*(C`child\*(C'\fR and \f(CW\*(C`children\*(C'\fR
methods.
There are occasions however where access by name to the children may be preferable.
The use of the \f(CW\*(C`alias\*(C'\fR clause with the \f(CW%tree\fR directive creates accessors
to the children with names specified by the programmer. The \fIdot and dolar notations\fR
are used for this. When dealing with a production like:
.PP
.Vb 3
\&                       A: 
\&                          %name A_Node
\&                          Node B.bum N.pum $Chip
.Ve
.PP
methods \f(CW\*(C`bum\*(C'\fR, \f(CW\*(C`pum\*(C'\fR and \f(CW\*(C`Chip\*(C'\fR will be created for the class \f(CW\*(C`A_Node\*(C'\fR.
Those methods wil provide access to the respective child (first, second and third in
the example). The methods are build at compile-time and therefore later 
transformations of the \s-1AST\s0 modifying the order of the children may 
invalidate the use of these getter-setters.
.PP
As an example, the \s-1CPAN\s0 module Language::AttributeGrammar provides
\&\s-1AST\s0 decorators from an attribute grammar specification of the \s-1AST\s0.
To work  Language::AttributeGrammar requires named access to the children
of the \s-1AST\s0 nodes. Follows an example (file \f(CW\*(C`examples/CalcwithAttributeGrammar.pl\*(C'\fR)
of a small calculator:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n CalcwithAttributeGrammar.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp;
\&     4  use Data::Dumper;
\&     5  use Language::AttributeGrammar;
\&     6
\&     7  my $grammar = q{
\&     8  %{
\&     9  # use Data::Dumper;
\&    10  %}
\&    11  %right  \*(Aq=\*(Aq
\&    12  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    13  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    14  %left   NEG
\&    15  %tree bypass alias
\&    16
\&    17  %%
\&    18  line: $exp  { $_[1] }
\&    19  ;
\&    20
\&    21  exp:
\&    22      %name NUM
\&    23            $NUM
\&    24          | %name VAR
\&    25            $VAR
\&    26          | %name ASSIGN
\&    27            $VAR \*(Aq=\*(Aq $exp
\&    28          | %name PLUS
\&    29            exp.left \*(Aq+\*(Aq exp.right
\&    30          | %name MINUS
\&    31            exp.left \*(Aq\-\*(Aq exp.right
\&    32          | %name TIMES
\&    33            exp.left \*(Aq*\*(Aq exp.right
\&    34          | %name DIV
\&    35            exp.left \*(Aq/\*(Aq exp.right
\&    36          | %no bypass UMINUS
\&    37            \*(Aq\-\*(Aq $exp %prec NEG
\&    38    |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    39  ;
\&    40
\&    41  %%
\&    42
\&    43  sub _Error {
\&    44          exists $_[0]\->YYData\->{ERRMSG}
\&    45      and do {
\&    46          print $_[0]\->YYData\->{ERRMSG};
\&    47          delete $_[0]\->YYData\->{ERRMSG};
\&    48          return;
\&    49      };
\&    50      print "Syntax error.\en";
\&    51  }
\&    52
\&    53  sub _Lexer {
\&    54      my($parser)=shift;
\&    55
\&    56          $parser\->YYData\->{INPUT}
\&    57      or  $parser\->YYData\->{INPUT} = <STDIN>
\&    58      or  return(\*(Aq\*(Aq,undef);
\&    59
\&    60      $parser\->YYData\->{INPUT}=~s/^\es+//;
\&    61
\&    62      for ($parser\->YYData\->{INPUT}) {
\&    63          s/^([0\-9]+(?:\e.[0\-9]+)?)//
\&    64                  and return(\*(AqNUM\*(Aq,$1);
\&    65          s/^([A\-Za\-z][A\-Za\-z0\-9_]*)//
\&    66                  and return(\*(AqVAR\*(Aq,$1);
\&    67          s/^(.)//s
\&    68                  and return($1,$1);
\&    69      }
\&    70  }
\&    71
\&    72  sub Run {
\&    73      my($self)=shift;
\&    74      $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&    75                      #yydebug =>0xFF
\&    76                    );
\&    77  }
\&    78  }; # end grammar
\&    79
\&    80
\&    81  $Data::Dumper::Indent = 1;
\&    82  Parse::Eyapp\->new_grammar(
\&    83    input=>$grammar,
\&    84    classname=>\*(AqRule6\*(Aq,
\&    85    firstline =>7,
\&    86    outputfile => \*(AqCalc.pm\*(Aq,
\&    87  );
\&    88  my $parser = Rule6\->new();
\&    89  $parser\->YYData\->{INPUT} = "a = \-(2*3+5\-1)\en";
\&    90  my $t = $parser\->Run;
\&    91  print "\en***** Before ******\en";
\&    92  print Dumper($t);
\&    93
\&    94  my $attgram = new Language::AttributeGrammar <<\*(AqEOG\*(Aq;
\&    95
\&    96  # Compute the expression
\&    97  NUM:    $/.val = { $<attr> }
\&    98  TIMES:  $/.val = { $<left>.val * $<right>.val }
\&    99  PLUS:   $/.val = { $<left>.val + $<right>.val }
\&   100  MINUS:  $/.val = { $<left>.val \- $<right>.val }
\&   101  UMINUS: $/.val = { \-$<exp>.val }
\&   102  ASSIGN: $/.val = { $<exp>.val }
\&   103  EOG
\&   104
\&   105  my $res = $attgram\->apply($t, \*(Aqval\*(Aq);
\&   106
\&   107  $Data::Dumper::Indent = 1;
\&   108  print "\en***** After ******\en";
\&   109  print Dumper($t);
\&   110  print Dumper($res);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debugingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/MatchingTrees.pdf>
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1),
.IP "\(bu" 4
Man pages of \fIbison\fR\|(1),
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html <http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE\s0 (\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04\s0
(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601\s0
(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Special thanks to 
my family and Larry Wall.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.
                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::languageintro5.18.3pm          0100644 0001750 0001750 00000321072 12566242262 027022  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::languageintro 3"
.TH Parse::Eyapp::languageintro 3 "2009-11-06" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::languageintro \- Introduction to the Eyapp language
.SH "The Eyapp Language"
.IX Header "The Eyapp Language"
.SS "Eyapp Grammar"
.IX Subsection "Eyapp Grammar"
This section describes the syntax of the Eyapp language using its own notation.
The grammar extends yacc and yapp grammars.
Semicolons have been omitted to save space.
Between C\-like comments you can find an (informal) 
explanation of the language 
associated with the token.
.PP
.Vb 10
\&  eyapp: head body tail ;
\&  symbol: LITERAL  /* A string literal like \*(Aqhello\*(Aq */
\&      |   ident   
\&  ident:  IDENT  /* IDENT is [A\-Za\-z_][A\-Za\-z0\-9_]* */ 
\&  head: headsec \*(Aq%%\*(Aq
\&  headsec:  decl *
\&  decl:  \*(Aq\en\*(Aq      
\&      |   SEMANTIC typedecl symlist \*(Aq\en\*(Aq  /* SEMANTIC  is %semantic\es+token      */
\&      |   SYNTACTIC typedecl symlist \*(Aq\en\*(Aq /* SYNTACTIC is %syntactic\es+token     */
\&      |   TOKEN typedecl symlist \*(Aq\en\*(Aq     /* TOKEN     is %token                 */
\&      |   ASSOC typedecl symlist \*(Aq\en\*(Aq     /* ASSOC     is %(left|right|nonassoc) */
\&      |   START ident \*(Aq\en\*(Aq                /* START     is %start                 */
\&      |   HEADCODE \*(Aq\en\*(Aq                   /* HEADCODE  is %{ Perl code ... %}    */
\&      |   UNION CODE \*(Aq\en\*(Aq                 /* UNION CODE  see yacc/bison          */
\&      |   DEFAULTACTION CODE \*(Aq\en\*(Aq         /* DEFAULTACTION is %defaultaction     */
\&      |   TREE treeclauses? \*(Aq\en\*(Aq          /* TREE      is %tree                  */
\&      |   METATREE \*(Aq\en\*(Aq                   /* METATREE  is %metatree              */
\&      |   TYPE typedecl identlist \*(Aq\en\*(Aq    /* TYPE      is %type                  */
\&      |   EXPECT NUMBER \*(Aq\en\*(Aq              /* EXPECT    is %expect                */
\&                                          /* NUMBER    is \ed+                    */
\&  typedecl:   /* empty */
\&      |       \*(Aq<\*(Aq IDENT \*(Aq>\*(Aq
\&  treeclauses: BYPASS ALIAS? | ALIAS BYPASS?
\&  symlist:    symbol + 
\&  identlist:  ident +
\&  body: rules * \*(Aq%%\*(Aq
\&  rules: IDENT \*(Aq:\*(Aq rhss \*(Aq;\*(Aq  
\&  rhss: rule <+ \*(Aq|\*(Aq>  
\&  rule:   optname rhs (prec epscode)?
\&  rhs:  rhseltwithid *
\&  rhseltwithid : 
\&        rhselt \*(Aq.\*(Aq IDENT 
\&      | \*(Aq$\*(Aq rhselt  
\&      | rhselt
\&  rhselt:     symbol    
\&      | code    
\&      | \*(Aq(\*(Aq optname rhs \*(Aq)\*(Aq 
\&      | rhselt STAR               /* STAR   is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e*  */
\&      | rhselt \*(Aq<\*(Aq STAR symbol \*(Aq>\*(Aq 
\&      | rhselt OPTION             /* OPTION is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e?  */
\&      | rhselt \*(Aq<\*(Aq PLUS symbol \*(Aq>\*(Aq
\&      | rhselt PLUS               /* PLUS   is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e+  */
\&  optname: (NAME IDENT)?          /* NAME is %name */
\&         | NOBYPASS IDENT         /* NOBYPASS is %no\es+bypass */
\&  prec: PREC symbol               /* PREC is %prec */
\&  epscode:  code ?   
\&  code:   
\&      CODE           /* CODE     is { Perl code ... }         */
\&    | BEGINCODE      /* BEGINCODE is %begin { Perl code ... } */
\&  tail:  TAILCODE ?  /* TAILCODE is { Perl code ... } */
.Ve
.PP
The semantic of \f(CW\*(C`Eyapp\*(C'\fR agrees with the semantic of \f(CW\*(C`yacc\*(C'\fR and \f(CW\*(C`yapp\*(C'\fR
for all the common constructions.
.SS "Comments"
.IX Subsection "Comments"
Comments are either Perl style, from \f(CW\*(C`#\*(C'\fR
up to the end of line, or C style, enclosed between  \f(CW\*(C`/*\*(C'\fR and \f(CW\*(C`*/\*(C'\fR.
.SS "Syntactic Variables, Symbolic Tokens and String Literals"
.IX Subsection "Syntactic Variables, Symbolic Tokens and String Literals"
Two kind of symbols may appear inside a Parse::Eyapp program:
\&\fINon-terminal\fR symbols or \fIsyntactic variables\fR, 
called also \fIleft-hand-side\fR symbols
and \fITerminal\fR symbols, called
also \fITokens\fR.
.PP
Tokens are the symbols the lexical analyzer function returns to the parser.
There are two kinds: \fIsymbolic tokens\fR and \fIstring
literals\fR.
.PP
\&\fISyntactic variables\fR and \fIsymbolic tokens\fR identifiers must conform
to the regular expression \f(CW\*(C`[A\-Za\-z][A\-Za\-z0\-9_]*\*(C'\fR.
.PP
When building the syntax tree (i.e. when running under the \f(CW%tree\fR
directive) \fIsymbolic tokens\fR will be considered \fIsemantic tokens\fR (see section
\&\*(L"Syntactic and Semantic tokens\*(R").
.PP
String literals are enclosed in single quotes and can contain almost
anything. They will be received by the parser as double-quoted strings. 
Any special character as \f(CW\*(Aq"\*(Aq\fR, \f(CW\*(Aq$\*(Aq\fR and \f(CW\*(Aq@\*(Aq\fR is escaped.
To have a single quote inside a literal, escape it with '\e'.
.PP
When building the syntax tree (i.e. when running under the \f(CW%tree\fR
directive) \fIstring literals\fR will be considered \fIsyntactic tokens\fR (see section
\&\*(L"Syntactic and Semantic tokens\*(R").
.ie n .SS "Parts of an ""eyapp"" Program"
.el .SS "Parts of an \f(CWeyapp\fP Program"
.IX Subsection "Parts of an eyapp Program"
An Eyapp program has three parts called head, body and tail:
.PP
.Vb 1
\&                                 eyapp: head body tail ;
.Ve
.PP
Each part is separated from the former by the symbol \f(CW\*(C`%%\*(C'\fR:
.PP
.Vb 2
\&                                 head: headsec \*(Aq%%\*(Aq
\&                                 body: rulesec \*(Aq%%\*(Aq
.Ve
.SS "The Head Section"
.IX Subsection "The Head Section"
The head section contains a list of declarations
.PP
.Vb 1
\&                                 headsec:  decl *
.Ve
.PP
There are different kinds of declarations.
.PP
This reference does not 
fully describes all the declarations that are shared with yacc and 
yapp.
.PP
\fIExample of Head Section\fR
.IX Subsection "Example of Head Section"
.PP
In this and the next sections we will describe the basics
of the Eyapp language using the file \f(CW\*(C`examples/Calc.eyp\*(C'\fR 
that accompanies this distribution. This file implements a trivial 
calculator. Here is the header section:
.PP
.Vb 12
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq1,11p\*(Aq Calc.eyp | cat \-n
\&  1  # examples/Calc.eyp
\&  2  %right  \*(Aq=\*(Aq
\&  3  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&  4  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&  5  %left   NEG
\&  6  %right  \*(Aq^\*(Aq
\&  7  %{
\&  8  my %s; # symbol table
\&  9  %}
\& 10
\& 11  %%
.Ve
.PP
\fIDeclarations and Precedence\fR
.IX Subsection "Declarations and Precedence"
.PP
Lines 2\-5 declare several tokens. The usual way to declare
tokens is through the \f(CW%token\fR directive. The declarations 
\&\f(CW%nonassoc\fR, \f(CW%left\fR and \f(CW%right\fR 
not only declare the tokens but also associate a \fIpriority\fR with them.  
Tokens declared in the same line have the same precedence. 
Tokens declared with these directives in lines below have more
precedence than those declared above. Thus, in the example
above
we are saying that \f(CW"+"\fR and \f(CW"\-"\fR have the same precedence
but higher precedence than =. The final effect of \f(CW"\-"\fR
having greater precedence than = will be that an
expression like:
.PP
.Vb 1
\&                        a = 4 \- 5
.Ve
.PP
will be interpreted as
.PP
.Vb 1
\&                        a = (4 \- 5)
.Ve
.PP
and not as
.PP
.Vb 1
\&                        (a = 4) \- 5
.Ve
.PP
The use of the \f(CW%left\fR indicates that \- in case of ambiguity 
and a match between precedences \- the parser must build the tree corresponding
to a left parenthesization. Thus, the expression
.PP
.Vb 1
\&                         4 \- 5 \- 9
.Ve
.PP
will be interpreted as
.PP
.Vb 1
\&                         (4 \- 5) \- 9
.Ve
.PP
\fIHeader Code\fR
.IX Subsection "Header Code"
.PP
Perl code surrounded by \f(CW\*(C`%{\*(C'\fR and \f(CW\*(C`%}\*(C'\fR
can be inserted in the head section. Such code will be inserted in the module
generated by \f(CW\*(C`eyapp\*(C'\fR near the beginning. Therefore, declarations like the
one of the calculator symbol table \f(CW%s\fR
.PP
.Vb 3
\&  7  %{
\&  8  my %s; # symbol table
\&  9  %}
.Ve
.PP
will be visible from almost any point in the file.
.PP
\fIThe Start Symbol of the Grammar\fR
.IX Subsection "The Start Symbol of the Grammar"
.PP
\&\f(CW\*(C`%start IDENT\*(C'\fR declares \f(CW\*(C`IDENT\*(C'\fR as the start symbol of 
the grammar. When \f(CW%start\fR is not
used, the first rule in the body section will be used.
.PP
\fIExpect\fR
.IX Subsection "Expect"
.PP
The \f(CW\*(C`%expect #NUMBER\*(C'\fR directive works as in bison 
and  suppress warnings when the number of Shift/Reduce
conflicts is exactly \f(CW\*(C`#NUMBER\*(C'\fR. See section 
\&\*(L"Solving Ambiguities and Conflicts\*(R" to know more
about Shift/Reduce conflicts.
.PP
\fIType and Union\fR
.IX Subsection "Type and Union"
.PP
C oriented declarations like \f(CW%type\fR and \f(CW%union\fR are
parsed but ignored.
.PP
\fIThe \f(CI%strict\fI Directive\fR
.IX Subsection "The %strict Directive"
.PP
By default, identifiers appearing in the rule section
will be classified as terminal if they don't appear 
in the left hand side of any production rules.
.PP
The directive \f(CW%strict\fR forces the declaration of all tokens. 
The following \f(CW\*(C`eyapp\*(C'\fR program issues a warning:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ cat \-n bugyapp2.eyp
\&       1  %strict
\&       2  %%
\&       3  expr: NUM;
\&       4  %%
\&  pl@nereida:~/LEyapp/examples$ eyapp bugyapp2.eyp
\&  Warning! Non declared token NUM at line 3 of bugyapp2.eyp
.Ve
.PP
To keep silent the compiler declare all tokens using
one of the token declaration directives (\f(CW%token\fR, \f(CW%left\fR, etc.)
.PP
.Vb 8
\&  pl@nereida:~/LEyapp/examples$ cat \-n bugyapp3.eyp
\&       1  %strict
\&       2  %token NUM
\&       3  %%
\&       4  expr: NUM;
\&       5  %%
\&  pl@nereida:~/LEyapp/examples$ eyapp bugyapp3.eyp
\&  pl@nereida:~/LEyapp/examples$
.Ve
.PP
It is a good practice to use \f(CW%strict\fR at the beginning of your grammar.
.PP
\fIDefault Action Directive\fR
.IX Subsection "Default Action Directive"
.PP
In \f(CW\*(C`Parse::Eyapp\*(C'\fR you can modify the default action using the \f(CW\*(C`%defaultaction { Perl code }\*(C'\fR
directive. See section
\&\*(L"Default actions\*(R".
.PP
\fITree Construction Directives\fR
.IX Subsection "Tree Construction Directives"
.PP
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR facilitates the construction of concrete syntax trees and 
abstract syntax trees (abbreviated \s-1AST\s0 from now on) through the \f(CW%tree\fR
\&\f(CW%metatree\fR directives. See section
\&\*(L"Abstract Syntax Trees : \f(CW%tree\fR and \f(CW%name\fR\*(R"
and Parse::Eyapp::translationschemestut.
.PP
\fISyntactic and Semantic Tokens\fR
.IX Subsection "Syntactic and Semantic Tokens"
.PP
The new token declaration directives \f(CW\*(C`%syntactic token\*(C'\fR and
\&\f(CW\*(C`%semantic token\*(C'\fR can change the way \f(CW\*(C`eyapp\*(C'\fR builds the abstract syntax tree.
See section \*(L"Syntactic and Semantic tokens\*(R".
.SS "The Body"
.IX Subsection "The Body"
The body section contains the rules describing the grammar:
.PP
.Vb 3
\&                       body:   rules * \*(Aq%%\*(Aq
\&                       rules:  IDENT \*(Aq:\*(Aq rhss \*(Aq;\*(Aq  
\&                       rhss:   (optname rhs (prec epscode)?) <+ \*(Aq|\*(Aq>
.Ve
.PP
\fIRules\fR
.IX Subsection "Rules"
.PP
A rule is made of a left-hand-side symbol (the \fIsyntactic variable\fR), 
followed by a \f(CW\*(Aq:\*(Aq\fR and one
or more \fIright-hand-sides\fR (or \fIproductions\fR)
 separated by \f(CW\*(Aq|\*(Aq\fR and terminated by a \f(CW\*(Aq;\*(Aq\fR
like in:
.PP
.Vb 5
\&                          exp: 
\&                               exp \*(Aq+\*(Aq exp
\&                            |  exp \*(Aq\-\*(Aq exp
\&                            |  NUM
\&                          ;
.Ve
.PP
A \fIproduction\fR (\fIright hand side\fR) may be empty:
.PP
.Vb 4
\&                          input:   
\&                               /* empty */
\&                            |  input line
\&                          ;
.Ve
.PP
The former two productions can be abbreviated as
.PP
.Vb 3
\&                          input: 
\&                               line *
\&                          ;
.Ve
.PP
The operators \f(CW\*(C`*\*(C'\fR, \f(CW\*(C`+\*(C'\fR and \f(CW\*(C`?\*(C'\fR are presented in section
\&\*(L"Lists and Optionals\*(R".
.PP
A \fIsyntactic variable cannot appear more than once as
a rule name\fR (This differs from yacc).
.PP
\fISemantic Values and Semantic Actions\fR
.IX Subsection "Semantic Values and Semantic Actions"
.PP
In \f(CW\*(C`Parse::Eyapp\*(C'\fR 
a production rule
.PP
.Vb 1
\&                          A \-> X_1 X_2 ... X_n
.Ve
.PP
can be followed by a 
\&\fIsemantic action\fR:
.PP
.Vb 1
\&                    A \-> X_1 X_2 ... X_n { Perl Code }
.Ve
.PP
Such
semantic action is nothing but Perl code that will be treated 
as an anonymous subroutine.  The semantic action associated 
with production rule \f(CW\*(C`A \-> X_1 X_2 ... X_n\*(C'\fR  is executed
after any actions associated with the subtrees of \f(CW\*(C`X_1\*(C'\fR,
\&\f(CW\*(C`X_2\*(C'\fR, ..., \f(CW\*(C`X_n\*(C'\fR.
\&\f(CW\*(C`Eyapp\*(C'\fR parsers build the syntax tree using a left-right
bottom-up traverse of the syntax tree. Each times
the Parser visits the node associated with the 
production \f(CW\*(C`A \-> X_1 X_2 ... X_n\*(C'\fR
the associated semantic action is called. 
Asociated with each symbol
of a Parse::Eyapp grammar there is a scalar \fISemantic Value\fR
or \fIAttribute\fR. The semantic values of terminals are provided
by the lexical analyzer. In the calculator example
(see file \f(CW\*(C`examples/Calc.yp\*(C'\fR in the distribution),
the semantic value associated with an expression
is its numeric value. Thus in the rule:
.PP
.Vb 1
\&                       exp \*(Aq+\*(Aq exp { $_[1] + $_[3] }
.Ve
.PP
\&\f(CW$_[1]\fR refers to the attribute of the first \f(CW\*(C`exp\*(C'\fR, \f(CW$_[2]\fR 
is the attribute associated with \f(CW\*(Aq+\*(Aq\fR, which is the second component of the 
pair provided by the lexical analyzer and \f(CW$_[3]\fR refers to the attribute of 
the second \f(CW\*(C`exp\*(C'\fR.
.PP
When the semantic action/anonymous subroutine is called,
the arguments are as follows:
.IP "\(bu" 4
\&\f(CW$_[1]\fR to \f(CW$_[n]\fR are the attributes of
the symbols \f(CW\*(C`X_1\*(C'\fR, \f(CW\*(C`X_2\*(C'\fR, ..., \f(CW\*(C`X_n\*(C'\fR. 
Just as \f(CW$1\fR to \f(CW$n\fR in yacc,
.IP "\(bu" 4
\&\f(CW$_[0]\fR is the parser object itself.
Having \f(CW$_[0]\fR beeing the parser object itself allows you to call
parser methods. Most yacc macros have been converted into
parser methods. See section 'Methods Available in the Generated Class'
in Parse::Eyapp.
.PP
The returned value will be the attribute associated 
with the left hand side of the production.
.PP
Names can be given to the attributes using the dot notation
(see file \f(CW\*(C`examples/CalcSimple.eyp\*(C'\fR):
.PP
.Vb 1
\&                     exp.left \*(Aq+\*(Aq exp.right { $left + $right }
.Ve
.PP
See section \*(L"Names for attributes\*(R" for more details about the \fIdot\fR and \fIdollar\fR 
notations.
.PP
If no action is specified and no \f(CW%defaultaction\fR is specified
the default action
.PP
.Vb 1
\&                               { $_[1] }
.Ve
.PP
will be executed instead. See section \*(L"Default actions\*(R" to know more.
.PP
\fIActions in Mid-Rule\fR
.IX Subsection "Actions in Mid-Rule"
.PP
Actions can be inserted in the middle of a production like in:
.PP
.Vb 1
\& block: \*(Aq{\*(Aq.bracket { $ids\->begin_scope(); } declaration*.decs statement*.sts \*(Aq}\*(Aq { ... }
.Ve
.PP
A middle production action is managed by inserting a new rule in the grammar and associating
the semantic action with it:
.PP
.Vb 1
\&                     Temp: /* empty */ { $ids\->begin_scope(); }
.Ve
.PP
Middle production actions can refer to the attributes on its left. They count
as one of the components of the production. Thus the program:
.PP
.Vb 5
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq1,4p\*(Aq intermediateaction2.yp
\& %%
\& S:  \*(Aqa\*(Aq { $_[1]x4 }.mid \*(Aqa\*(Aq { print "$_[2], $mid, $_[3]\en"; }
\& ;
\& %%
.Ve
.PP
The auxiliar syntactic variables are named \f(CW\*(C`@#position\-#order\*(C'\fR where \f(CW\*(C`#position\*(C'\fR
is the position of the action in the rhs and \f(CW\*(C`order\*(C'\fR is an ordinal number. See
the \f(CW\*(C`.output\*(C'\fR file for the former example:
.PP
.Vb 7
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ eyapp \-v intermediateaction2.yp
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq1,5p\*(Aq intermediateaction2.output
\& Rules:
\& \-\-\-\-\-\-
\& 0:      $start \-> S $end
\& 1:      S \-> \*(Aqa\*(Aq @1\-1 \*(Aqa\*(Aq
\& 2:      @1\-1 \-> /* empty */
.Ve
.PP
when given input \f(CW\*(C`aa\*(C'\fR the execution will produce as output \f(CW\*(C`aaaa, aaaa, a\*(C'\fR.
.PP
\fIExample of Body Section\fR
.IX Subsection "Example of Body Section"
.PP
Following with the calculator example, the body is:
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq12,48p\*(Aq Calc.eyp | cat \-n
\&  1  start:
\&  2      input { \e%s }
\&  3  ;
\&  4
\&  5  input: line *
\&  6  ;
\&  7
\&  8  line:
\&  9    \*(Aq\en\*(Aq         { undef }
\& 10    | exp \*(Aq\en\*(Aq   { print "$_[1]\en" if defined($_[1]); $_[1] }
\& 11    | error  \*(Aq\en\*(Aq
\& 12        {
\& 13          $_[0]\->YYErrok;
\& 14          undef
\& 15        }
\& 16  ;
\& 17
\& 18  exp:
\& 19      NUM
\& 20    | $VAR                   { $s{$VAR} }
\& 21    | $VAR \*(Aq=\*(Aq $exp          { $s{$VAR} = $exp }
\& 22    | exp.left \*(Aq+\*(Aq exp.right { $left + $right }
\& 23    | exp.left \*(Aq\-\*(Aq exp.right { $left \- $right }
\& 24    | exp.left \*(Aq*\*(Aq exp.right { $left * $right }
\& 25    | exp.left \*(Aq/\*(Aq exp.right
\& 26      {
\& 27         $_[3] and return($_[1] / $_[3]);
\& 28         $_[0]\->YYData\->{ERRMSG} = "Illegal division by zero.\en";
\& 29         $_[0]\->YYError; # Pretend that a syntactic error ocurred: _Error will be called
\& 30         undef
\& 31      }
\& 32    | \*(Aq\-\*(Aq $exp %prec NEG     { \-$exp }
\& 33    | exp.left \*(Aq^\*(Aq exp.right { $left ** $right }
\& 34    | \*(Aq(\*(Aq $exp \*(Aq)\*(Aq           { $exp }
\& 35  ;
\& 36
\& 37  %%
.Ve
.PP
This example does not uses any of the Eyapp extensions (with the exception of the 
\&\fIstar list\fR at line 5) and the dot and dollar notations. 
Please, see the Parse::Yapp pages and elsewhere documentation
on yacc and bison for more information.
.PP
\fISolving Ambiguities and Conflicts\fR
.IX Subsection "Solving Ambiguities and Conflicts"
.PP
When Eyapp analizes a grammar like:
.PP
.Vb 7
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ cat \-n ambiguities.eyp
\&     1  %%
\&     2  exp:
\&     3      NUM
\&     4    | exp \*(Aq\-\*(Aq exp
\&     5  ;
\&     6  %%
.Ve
.PP
it will produce a warning announcing the existence of 
\&\fIshift-reduce\fR conflicts:
.PP
.Vb 7
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ eyapp ambiguities.eyp
\& 1 shift/reduce conflict (see .output file)
\& State 5: reduce by rule 2: exp \-> exp \*(Aq\-\*(Aq exp (default action)
\& State 5: shifts:
\&   to state    3 with \*(Aq\-\*(Aq
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ ls \-ltr | tail \-1
\& \-rw\-rw\-\-\-\-  1 pl users   1082 2007\-02\-06 08:26 ambiguities.output
.Ve
.PP
when \f(CW\*(C`eyapp\*(C'\fR finds warnings automatically produces a \f(CW\*(C`.output\*(C'\fR file
describing the conflict.
.PP
What the warning is saying is that an expression like \f(CW\*(C`exp \*(Aq\-\*(Aq exp\*(C'\fR (rule 2) followed by a
minus \f(CW\*(Aq\-\*(Aq\fR can be worked in more than one way. If we
have an input like \f(CW\*(C`NUM \- NUM \- NUM\*(C'\fR the activity of a \s-1\fILALR\s0\fR\|(1) parser
(the family of parsers to which Eyapp belongs)
consists of a sequence of \fIshift and reduce actions\fR. A \fIshift action\fR
has as consequence the reading of the next token. A \fIreduce action\fR
is finding a production rule that matches and substituting 
the rhs of the production by the lhs.  For input \f(CW\*(C`NUM \- NUM \- NUM\*(C'\fR
the activity will be as follows (the dot is used to indicate where the next 
input token is):
.PP
.Vb 6
\&                           .NUM \- NUM \- NUM # shift
\&                            NUM.\- NUM \- NUM # reduce exp: NUM 
\&                            exp.\- NUM \- NUM # shift
\&                            exp \-.NUM \- NUM # shift
\&                            exp \- NUM.\- NUM # reduce exp: NUM
\&                            exp \- exp.\- NUM # shift/reduce conflict
.Ve
.PP
up this point two different decisions can be taken: the next description can be
.PP
.Vb 1
\&                                  exp.\- NUM # reduce by exp: exp \*(Aq\-\*(Aq exp (rule 2)
.Ve
.PP
or:
.PP
.Vb 1
\&                            exp \- exp \-.NUM # shift \*(Aq\-\*(Aq (to state 3)
.Ve
.PP
that is why it is called a \fIshift-reduce conflict\fR.
.PP
That is also the reason for the precedence declarations in the 
head section. Another kind of conflicts are \fIreduce-reduce conflicts\fR.
They arise when more that rhs can be applied for a reduction
action.
.PP
Eyapp solves the conflicts applying the following rules:
.IP "\(bu" 4
In a shift/reduce conflict, the default is the shift.
.IP "\(bu" 4
In a reduce/reduce conflict, the default is to reduce by the
earlier grammar production (in the input sequence).
.IP "\(bu" 4
The precedences and associativities are associated with tokens in
the declarations section. This is made by a sequence of lines beginning
with one of the directives: \f(CW%left\fR, \f(CW%right\fR, or \f(CW%nonassoc\fR, 
followed by a list of
tokens. All the tokens on the same line
have the same precedence and associativity; 
the lines are listed in order of increasing precedence.
.IP "\(bu" 4
A precedence and associativity is associated with each grammar
production; it is the precedence and associativity of the \fIlast token\fR 
or \fIliteral\fR in the right hand side of the production.
.IP "\(bu" 4
The \f(CW%prec\fR directive can be used when
a rhs is involved in a conflict and has no tokens
inside or it has but the precedence of the last token leads
to an incorrect interpretation. A rhs can be followed by 
an optional \f(CW\*(C`%prec token\*(C'\fR directive
giving the production the precedence of the \f(CW\*(C`token\*(C'\fR
.Sp
.Vb 1
\&                          exp:   \*(Aq\-\*(Aq exp %prec NEG { \-$_[1] }
.Ve
.IP "\(bu" 4
If there is a shift/reduce conflict, and both the grammar production
and the input character have precedence and associativity associated
with them, then the conflict is solved in favor of the action (shift or
reduce) associated with the higher precedence. If the precedences are the
same, then the associativity is used; left associative implies reduce,
right associative implies shift, and nonassociating implies error.
.PP
To solve a shift-reduce conflict between a production \f(CW\*(C`A \-\-> SOMETHING\*(C'\fR
and a token \f(CW\*(Aqa\*(Aq\fR you can follow this procedure:
.ie n .IP "1. Edit the "".output"" file" 4
.el .IP "1. Edit the \f(CW.output\fR file" 4
.IX Item "1. Edit the .output file"
.PD 0
.IP "2. Search for the state where the conflict between the production and the token is. In our example it looks like:" 4
.IX Item "2. Search for the state where the conflict between the production and the token is. In our example it looks like:"
.PD
.Vb 2
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq56,65p\*(Aq ambiguities.output
\& State 5:
\&
\&        exp \-> exp . \*(Aq\-\*(Aq exp    (Rule 2)
\&        exp \-> exp \*(Aq\-\*(Aq exp .    (Rule 2)
\&
\&        \*(Aq\-\*(Aq     shift, and go to state 3
\&
\&        \*(Aq\-\*(Aq     [reduce using rule 2 (exp)]
\&        $default        reduce using rule 2 (exp)
.Ve
.ie n .IP "3. Inside the state there has to be a production of the type ""A \-\-> SOMETHING."" (with the dot at the end) indicating that a reduction must take place. There has to be also another production of the form ""A \-\-> prefix . suffix"", where suffix can \fIstart\fR with the involved token \*(Aqa\*(Aq." 4
.el .IP "3. Inside the state there has to be a production of the type \f(CWA \-\-> SOMETHING.\fR (with the dot at the end) indicating that a reduction must take place. There has to be also another production of the form \f(CWA \-\-> prefix . suffix\fR, where suffix can \fIstart\fR with the involved token \f(CW\*(Aqa\*(Aq\fR." 4
.IX Item "3. Inside the state there has to be a production of the type A --> SOMETHING. (with the dot at the end) indicating that a reduction must take place. There has to be also another production of the form A --> prefix . suffix, where suffix can start with the involved token a."
.PD 0
.ie n .IP "4. Decide what action shift or reduce matches the kind of trees you want. In this example we want ""NUM \- NUM \- NUM"" to produce a tree like ""MINUS(MINUS(NUM, NUM), NUM)"" and not ""MINUS(NUM, MINUS(NUM, NUM))"". We want the conflict in ""exp \- exp.\- NUM"" to be solved in favor of the reduction by ""exp: exp \*(Aq\-\*(Aq exp"". This is achieved by declaring ""%left \*(Aq\-\*(Aq""." 4
.el .IP "4. Decide what action shift or reduce matches the kind of trees you want. In this example we want \f(CWNUM \- NUM \- NUM\fR to produce a tree like \f(CWMINUS(MINUS(NUM, NUM), NUM)\fR and not \f(CWMINUS(NUM, MINUS(NUM, NUM))\fR. We want the conflict in \f(CWexp \- exp.\- NUM\fR to be solved in favor of the reduction by \f(CWexp: exp \*(Aq\-\*(Aq exp\fR. This is achieved by declaring \f(CW%left \*(Aq\-\*(Aq\fR." 4
.IX Item "4. Decide what action shift or reduce matches the kind of trees you want. In this example we want NUM - NUM - NUM to produce a tree like MINUS(MINUS(NUM, NUM), NUM) and not MINUS(NUM, MINUS(NUM, NUM)). We want the conflict in exp - exp.- NUM to be solved in favor of the reduction by exp: exp - exp. This is achieved by declaring %left -."
.PD
.PP
\fIError Recovery\fR
.IX Subsection "Error Recovery"
.PP
The token name \f(CW\*(C`error\*(C'\fR is reserved for error handling. This name can
be used in grammar productions; it suggests places where errors are
expected, and recovery can take place:
.PP
.Vb 8
\&     line:
\&       \*(Aq\en\*(Aq         { undef }
\&       | exp \*(Aq\en\*(Aq   { print "$_[1]\en" if defined($_[1]); $_[1] }
\&       | error  \*(Aq\en\*(Aq
\&           {
\&             $_[0]\->YYErrok;
\&             undef
\&           }
.Ve
.PP
The parser pops its stack until
it enters a state where the token \f(CW\*(C`error\*(C'\fR is legal. It then shifts
the token \f(CW\*(C`error\*(C'\fR and proceeds to discard tokens until finding 
one that is acceptable. In the example
all the tokens until finding a \f(CW\*(Aq\en\*(Aq\fR will be skipped. 
If no special error productions have been specified,
the processing will halt.
.PP
In order to prevent a cascade of error messages, the parser, after
detecting an error, remains in error state until three tokens have been
successfully read and shifted. If an error is detected when the parser
is already in error state, no message is given, and the input token is
quietly deleted. The method \f(CW\*(C`YYErrok\*(C'\fR used in the example 
communicates to the parser
that a satisfactory recovery has been reached 
and that it can safely emit new error
messages.
.PP
You cannot have a literal \fI'error'\fR in your grammar as it would
confuse the driver with the \fIerror\fR token. Use a symbolic token instead.
.SS "The Tail"
.IX Subsection "The Tail"
The tail section contains Perl code. Usually the lexical analyzer and the
Error management subroutines go there. A better practice however is to isolate
both subroutines in a module and use them in the grammar. An example of this is in
files \f(CW\*(C`examples/CalcUsingTail.eyp\*(C'\fR and \f(CW\*(C`examples/Tail.pm\*(C'\fR.
.PP
\fIThe Lexical Analyzer\fR
.IX Subsection "The Lexical Analyzer"
.PP
The Lexical Analyzer 
is called each time the parser needs a new token.
It is called with only one argument (the parser object)
and returns a pair 
containing the next token and its associated attribute.
.PP
The fact that is a method of the parser object means that 
the parser
methods are accesible inside the lexical analyzer.
Specially interesting is the \f(CW\*(C`$_[0]\->YYData\*(C'\fR 
method which provides access to the user data area.
.PP
\&\fIWhen the lexical analyzer reaches the end of input, it must return the
pair\fR \f(CW\*(C`(\*(Aq\*(Aq, undef)\*(C'\fR
.PP
See below how to write a lexical analyzer (file \f(CW\*(C`examples/Calc.eyp\*(C'\fR):
.PP
.Vb 10
\&  1  sub make_lexer {
\&  2    my $input = shift;
\&  3
\&  4    return sub {
\&  5      my $parser = shift;
\&  6
\&  7      for ($$input) {
\&  8        m{\eG[ \et]*}gc;
\&  9        m{\eG([0\-9]+(?:\e.[0\-9]+)?)}gc   and return (\*(AqNUM\*(Aq,$1);
\& 10        m{\eG([A\-Za\-z][A\-Za\-z0\-9_]*)}gc and return (\*(AqVAR\*(Aq,$1);
\& 11        m{\eG\en}gc                      and do { $lineno++; return ("\en", "\en") };
\& 12        m{\eG(.)}gc                     and return ($1,$1);
\& 13
\& 14        return(\*(Aq\*(Aq,undef);
\& 15      }
\& 16    }
\& 17  }
.Ve
.PP
The subroutine \f(CW\*(C`make_lexer\*(C'\fR creates the lexical analyzer as
a closure. The lexer returned by \f(CW\*(C`make_lexer\*(C'\fR is used by the 
\&\f(CW\*(C`YYParse\*(C'\fR method:
.PP
.Vb 9
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq90,97p\*(Aq Calc.eyp | cat \-n
\& 1  sub Run {
\& 2      my($self)=shift;
\& 3      my $input = shift or die "No input given\en";
\& 4
\& 5      return $self\->YYParse( yylex => make_lexer($input), yyerror => \e&_Error,
\& 6        #yydebug =>0x1F
\& 7      );
\& 8  }
.Ve
.PP
\fIThe Error Report Subroutine\fR
.IX Subsection "The Error Report Subroutine"
.PP
The Error Report subroutine is also a parser method, 
and consequently receives as parameter the parser object.
.PP
See the error report subroutine
for the example in \f(CW\*(C`examples/Calc.eyp\*(C'\fR:
.PP
.Vb 10
\&  1  %%
\&  2
\&  3  my $lineno = 1;
\&  4
\&  5  sub _Error {
\&  6    my $parser = shift;
\&  7
\&  8      exists $parser\->YYData\->{ERRMSG}
\&  9    and do {
\& 10        print $parser\->YYData\->{ERRMSG};
\& 11        delete $parser\->YYData\->{ERRMSG};
\& 12        return;
\& 13    };
\& 14    my($token)=$parser\->YYCurval;
\& 15    my($what)= $token ? "input: \*(Aq$token\*(Aq" : "end of input";
\& 16    my @expected = $parser\->YYExpect();
\& 17    local $" = \*(Aq, \*(Aq;
\& 18    print << "ERRMSG";
\& 19
\& 20  Syntax error near $what (lin num $lineno).
\& 21  Expected one of these terminals: @expected
\& 22  ERRMSG
\& 23  }
.Ve
.PP
See the Parse::Yapp pages and elsewhere documentation
on yacc and bison for more information.
.SS "Using an Eyapp Program"
.IX Subsection "Using an Eyapp Program"
The following is an example of a program that uses the calculator explained 
in the two previous sections:
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ cat \-n usecalc.pl
\&  1  #!/usr/bin/perl \-w
\&  2  use strict;
\&  3  use Calc;
\&  4
\&  5  my $parser = Calc\->new();
\&  6  my $input = <<\*(AqEOI\*(Aq;
\&  7  a = 2*3
\&  8  d = 5/(a\-6)
\&  9  b = (a+1)/7
\& 10  c=a*3+4)\-5
\& 11  a = a+1
\& 12  EOI
\& 13  my $t = $parser\->Run(\e$input);
\& 14  print "========= Symbol Table ==============\en";
\& 15  print "$_ = $t\->{$_}\en" for sort keys %$t;
.Ve
.PP
The output for this program is (the input for each output
appear as a Perl comment on the right):
.PP
.Vb 5
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ eyapp Calc.eyp
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ usecalc.pl
\& 6                                              # a = 2*3
\& Illegal division by zero.                      # d = 5/(a\-6)
\& 1                                              # b = (a+1)/7
\&
\& Syntax error near input: \*(Aq)\*(Aq (lin num 4).      # c=a*3+4)\-5
\& Expected one of these terminals: \-, /, ^, *, +,
\&
\& 7                                              # a = a+1
\& ========= Symbol Table ==============
\& a = 7
\& b = 1
\& c = 22
.Ve
.SS "Lists and Optionals"
.IX Subsection "Lists and Optionals"
The elements of a rhs can be one of these:
.PP
.Vb 9
\&  rhselt:     
\&        symbol    
\&      | code    
\&      | \*(Aq(\*(Aq optname rhs \*(Aq)\*(Aq 
\&      | rhselt STAR               /* STAR   is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e*  */
\&      | rhselt \*(Aq<\*(Aq STAR symbol \*(Aq>\*(Aq 
\&      | rhselt OPTION             /* OPTION is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e?  */
\&      | rhselt \*(Aq<\*(Aq PLUS symbol \*(Aq>\*(Aq
\&      | rhselt PLUS               /* PLUS   is (%name\es*([A\-Za\-z_]\ew*)\es*)?\e+  */
.Ve
.PP
The \f(CW\*(C`STAR\*(C'\fR, \f(CW\*(C`OPTION\*(C'\fR and \f(CW\*(C`PLUS\*(C'\fR operators provide a simple mechanism
to express lists:
.IP "\(bu" 4
In Eyapp the \f(CW\*(C`+\*(C'\fR operator indicates one or more repetitions of the element
to the left of \f(CW\*(C`+\*(C'\fR, thus a rule like:
.Sp
.Vb 1
\&                        decls:  decl +
.Ve
.Sp
is the same as:
.Sp
.Vb 2
\&                        decls:  decls decl 
\&                             |  decl
.Ve
.Sp
An additional  symbol may be included  to indicate lists of elements 
separated by such symbol. Thus
.Sp
.Vb 1
\&                       rhss: rule <+ \*(Aq|\*(Aq>
.Ve
.Sp
is equivalent to:
.Sp
.Vb 2
\&                       rhss: rhss \*(Aq|\*(Aq rule 
\&                           | rule
.Ve
.IP "\(bu" 4
The operators \f(CW\*(C`*\*(C'\fR and \f(CW\*(C`?\*(C'\fR have their usual meaning: 0 or more for
\&\f(CW\*(C`*\*(C'\fR and optionality for \f(CW\*(C`?\*(C'\fR. Is legal to parenthesize 
a \f(CW\*(C`rhs\*(C'\fR expression as in:
.Sp
.Vb 1
\&                       optname: (NAME IDENT)?
.Ve
.SS "The Semantic of Lists Operators"
.IX Subsection "The Semantic of Lists Operators"
\fIThe \f(CI\*(C`+\*(C'\fI operator\fR
.IX Subsection "The + operator"
.PP
The grammar:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-12 List3.yp | cat \-n
\&   1  # List3.yp
\&   2  %semantic token \*(Aqc\*(Aq
\&   3  %{
\&   4  use Data::Dumper;
\&   5  %}
\&   6  %%
\&   7  S:      \*(Aqc\*(Aq+  \*(Aqd\*(Aq+
\&   8             {
\&   9                print Dumper($_[1]);
\&  10                print Dumper($_[2]);
\&  11             }
\&  12  ;
.Ve
.PP
Is equivalent to:
.PP
.Vb 9
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v List3.yp | head \-9 List3.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> S $end
\&  1:      PLUS\-1 \-> PLUS\-1 \*(Aqc\*(Aq
\&  2:      PLUS\-1 \-> \*(Aqc\*(Aq
\&  3:      PLUS\-2 \-> PLUS\-2 \*(Aqd\*(Aq
\&  4:      PLUS\-2 \-> \*(Aqd\*(Aq
\&  5:      S \-> PLUS\-1 PLUS\-2
.Ve
.PP
By default, the semantic action associated with a \f(CW\*(C`+\*(C'\fR returns the lists of attributes
to which the \f(CW\*(C`+\*(C'\fR applies:
.PP
.Vb 4
\&  pl@nereida:~/LEyapp/examples$ use_list3.pl
\&  ccdd
\&  $VAR1 = [ \*(Aqc\*(Aq, \*(Aqc\*(Aq ];
\&  $VAR1 = [ \*(Aqd\*(Aq, \*(Aqd\*(Aq ];
.Ve
.PP
The semantic associated with a \f(CW\*(C`+\*(C'\fR changes 
when one of the tree creation directives is active (for instance \f(CW%tree\fR or \f(CW%metatree\fR)
or it has been explicitly requested with a call to the \f(CW\*(C`YYBuildingTree\*(C'\fR method:
.PP
.Vb 1
\&                            $self\->YYBuildingTree(1);
.Ve
.PP
Other ways to change the associated semantic are to use the 
\&\f(CW\*(C`yybuildingtree\*(C'\fR option of \f(CW\*(C`YYParse\*(C'\fR:
.PP
.Vb 4
\&         $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&                           yybuildingtree => 1,
\&                         # yydebug => 0x1F
\&         );
.Ve
.PP
In such case the associated semantic action creates a node labelled
.PP
.Vb 1
\&                     _PLUS_LIST_#number
.Ve
.PP
whose children are the attributes associated with the items in the 
plus list. The \f(CW\*(C`#number\*(C'\fR in \f(CW\*(C`_PLUS_LIST_#number\*(C'\fR is the ordinal
of the production rule as it appears in the \f(CW\*(C`.output\*(C'\fR file.
As it happens when using the \f(CW%tree\fR directive syntactic tokens 
are skipped.
.PP
When executing the example above but under the \f(CW%tree\fR directive
the ouput changes:
.PP
.Vb 4
\&  pl@nereida:~/LEyapp/examples$ head \-3 List3.yp; eyapp List3.yp
\&  # List3.yp
\&  %semantic token \*(Aqc\*(Aq
\&  %tree
\&
\&  pl@nereida:~/LEyapp/examples$ use_list3.pl
\&  ccdd
\&  $VAR1 = bless( {
\&           \*(Aqchildren\*(Aq => [
\&             bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&             bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&           ]
\&         }, \*(Aq_PLUS_LIST_1\*(Aq );
\&  $VAR1 = bless( { \*(Aqchildren\*(Aq => [] }, \*(Aq_PLUS_LIST_2\*(Aq );
.Ve
.PP
The node associated with the list of \f(CW\*(C`d\*(C'\fRs is empty since
terminal \f(CW\*(C`d\*(C'\fR wasn't declared semantic.
.PP
\fIWhen Nodes Dissappear from Lists\fR
.IX Subsection "When Nodes Dissappear from Lists"
.PP
When under the influence of the \f(CW%tree\fR directive
the action associated with a list operator
is to \fIflat\fR the children in a single list.
.PP
In the former example, the \f(CW\*(C`d\*(C'\fR nodes dont show up 
since \f(CW\*(Aqd\*(Aq\fR is a syntactic token. However, it may happen that changing the status
of \f(CW\*(Aqd\*(Aq\fR to semantic will not suffice.
.PP
When inserting the children, the tree (\f(CW%tree\fR)  node construction
method (\f(CW\*(C`YYBuildAST\*(C'\fR) omits any attribute that is not a reference.
Therefore, when inserting explicit actions, it is necessary to guarantee that 
the returned value is a reference or a semantic token 
to assure the presence of the value in the lists of children of the node.
Certainly you can use this property to prune parts of the tree.
Consider the following example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-19 ListWithRefs1.eyp | cat \-n
\&   1  # ListWithRefs.eyp
\&   2  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&   3  %{
\&   4  use Data::Dumper;
\&   5  %}
\&   6  %%
\&   7  S:      \*(Aqc\*(Aq+  D+
\&   8             {
\&   9                print Dumper($_[1]);
\&  10                print $_[1]\->str."\en";
\&  11                print Dumper($_[2]);
\&  12                print $_[2]\->str."\en";
\&  13             }
\&  14  ;
\&  15
\&  16  D: \*(Aqd\*(Aq
\&  17  ;
\&  18
\&  19  %%
.Ve
.PP
To activate the \fItree semantic\fR for lists we use the \f(CW\*(C`yybuildingtree\*(C'\fR
option of \f(CW\*(C`YYParse\*(C'\fR:
.PP
.Vb 8
\&  pl@nereida:~/LEyapp/examples$ tail \-7 ListWithRefs1.eyp | cat \-n
\&       1  sub Run {
\&       2      my($self)=shift;
\&       3      $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&       4        yybuildingtree => 1,
\&       5        #, yydebug => 0x1F
\&       6      );
\&       7  }
.Ve
.PP
The execution gives an ouput like this:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ eyapp ListWithRefs1.eyp; use_listwithrefs1.pl
\&  ccdd
\&  $VAR1 = bless( {
\&                   \*(Aqchildren\*(Aq => [
\&                                   bless( {
\&                                            \*(Aqchildren\*(Aq => [],
\&                                            \*(Aqattr\*(Aq => \*(Aqc\*(Aq,
\&                                            \*(Aqtoken\*(Aq => \*(Aqc\*(Aq
\&                                          }, \*(AqTERMINAL\*(Aq ),
\&                                   bless( {
\&                                            \*(Aqchildren\*(Aq => [],
\&                                            \*(Aqattr\*(Aq => \*(Aqc\*(Aq,
\&                                            \*(Aqtoken\*(Aq => \*(Aqc\*(Aq
\&                                          }, \*(AqTERMINAL\*(Aq )
\&                                 ]
\&                 }, \*(Aq_PLUS_LIST_1\*(Aq );
\&  _PLUS_LIST_1(TERMINAL,TERMINAL)
\&  $VAR1 = bless( {
\&                   \*(Aqchildren\*(Aq => []
\&                 }, \*(Aq_PLUS_LIST_2\*(Aq );
\&  _PLUS_LIST_2
.Ve
.PP
Though \f(CW\*(Aqd\*(Aq\fR was declared semantic the default action 
assoaciated with the production \f(CW\*(C`D: \*(Aqd\*(Aq\*(C'\fR in line 16
returns \f(CW$_[1]\fR (that is, the scalar \f(CW\*(Aqd\*(Aq\fR). Since it is not
a reference it won't be inserted in the list of children of
\&\f(CW\*(C`_PLUS_LIST\*(C'\fR.
.PP
\fIRecovering the Missing Nodes\fR
.IX Subsection "Recovering the Missing Nodes"
.PP
The solution is to be sure that the attribute is a reference:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-22 ListWithRefs.eyp | cat \-n
\&   1  # ListWithRefs.eyp
\&   2  %semantic token \*(Aqc\*(Aq
\&   3  %{
\&   4  use Data::Dumper;
\&   5  %}
\&   6  %%
\&   7  S:      \*(Aqc\*(Aq+  D+
\&   8             {
\&   9                print Dumper($_[1]);
\&  10                print $_[1]\->str."\en";
\&  11                print Dumper($_[2]);
\&  12                print $_[2]\->str."\en";
\&  13             }
\&  14  ;
\&  15
\&  16  D: \*(Aqd\*(Aq
\&  17       {
\&  18         bless { attr => $_[1], children =>[]}, \*(AqDES\*(Aq;
\&  19       }
\&  20  ;
\&  21
\&  22  %%
.Ve
.PP
Now the attribute associated with \f(CW\*(C`D\*(C'\fR is a reference 
and appears in the list of children of \f(CW\*(C`_PLUS_LIST\*(C'\fR:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ eyapp ListWithRefs.eyp; use_listwithrefs.pl
\&  ccdd
\&  $VAR1 = bless( {
\&                   \*(Aqchildren\*(Aq => [
\&                                   bless( {
\&                                            \*(Aqchildren\*(Aq => [],
\&                                            \*(Aqattr\*(Aq => \*(Aqc\*(Aq,
\&                                            \*(Aqtoken\*(Aq => \*(Aqc\*(Aq
\&                                          }, \*(AqTERMINAL\*(Aq ),
\&                                   bless( {
\&                                            \*(Aqchildren\*(Aq => [],
\&                                            \*(Aqattr\*(Aq => \*(Aqc\*(Aq,
\&                                            \*(Aqtoken\*(Aq => \*(Aqc\*(Aq
\&                                          }, \*(AqTERMINAL\*(Aq )
\&                                 ]
\&                 }, \*(Aq_PLUS_LIST_1\*(Aq );
\&  _PLUS_LIST_1(TERMINAL,TERMINAL)
\&  $VAR1 = bless( {
\&                   \*(Aqchildren\*(Aq => [
\&                                   bless( {
\&                                            \*(Aqchildren\*(Aq => [],
\&                                            \*(Aqattr\*(Aq => \*(Aqd\*(Aq
\&                                          }, \*(AqDES\*(Aq ),
\&                                   bless( {
\&                                            \*(Aqchildren\*(Aq => [],
\&                                            \*(Aqattr\*(Aq => \*(Aqd\*(Aq
\&                                          }, \*(AqDES\*(Aq )
\&                                 ]
\&                 }, \*(Aq_PLUS_LIST_2\*(Aq );
\&  _PLUS_LIST_2(DES,DES)
.Ve
.PP
\fIBuilding a Tree with \f(CI\*(C`Parse::Eyapp::Node\->new\*(C'\fI\fR
.IX Subsection "Building a Tree with Parse::Eyapp::Node->new"
.PP
The former solution consisting on writing \fIby hand\fR the code to 
build the node may suffice when dealing with a single node.
Writing by hand the code to build a node is a cumbersome task.
Even worst: though the node built in the former example
looks like a \f(CW\*(C`Parse::Eyapp\*(C'\fR node actually isn't. \f(CW\*(C`Parse::Eyapp\*(C'\fR 
nodes always inherit from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR and 
consequently have access to the methods in such package.
Thefollowing execution using the debugger illustrates the point:
.PP
.Vb 1
\&  pl@nereida:~/LEyapp/examples$ perl \-wd use_listwithrefs.pl
\&
\&  Loading DB routines from perl5db.pl version 1.28
\&  Editor support available.
\&
\&  Enter h or \`h h\*(Aq for help, or \`man perldebug\*(Aq for more help.
\&
\&  main::(use_listwithrefs.pl:4):  $parser = new ListWithRefs();
\&    DB<1>  f ListWithRefs.eyp
\&  1       2       #line 3 "ListWithRefs.eyp"
\&  3
\&  4:      use Data::Dumper;
\&  5
\&  6       #line 7 "ListWithRefs.eyp"
\&  7       #line 8 "ListWithRefs.eyp"
\&  8
\&  9:                    print Dumper($_[1]);
\&  10:                   print $_[1]\->str."\en";
.Ve
.PP
through the command \f(CW\*(C`f ListWithRefs.eyp\*(C'\fR we inform the debugger
that subsequent commands will refer to such file. Next 
we execute the program up to the semantic action
associated with the production rule \f(CW\*(C`S: \*(Aqc\*(Aq+  D+\*(C'\fR (line 9)
.PP
.Vb 4
\&    DB<2> c 9     # Continue up to line 9 of ListWithRefs.eyp
\&  ccdd
\&  ListWithRefs::CODE(0x84ebe5c)(ListWithRefs.eyp:9):
\&  9:                    print Dumper($_[1]);
.Ve
.PP
Now we are in condition to look at the contents 
of the arguments:
.PP
.Vb 7
\&    DB<3> x $_[2]\->str
\&  0  \*(Aq_PLUS_LIST_2(DES,DES)\*(Aq
\&    DB<4> x $_[2]\->child(0)
\&  0  DES=HASH(0x85c4568)
\&     \*(Aqattr\*(Aq => \*(Aqd\*(Aq
\&     \*(Aqchildren\*(Aq => ARRAY(0x85c458c)
\&          empty array
.Ve
.PP
the \f(CW\*(C`str\*(C'\fR method works with the object \f(CW$_[2]\fR since
\&\f(CW\*(C`_PLUS_LIST_2\*(C'\fR nodes inherit from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR.
However, when we try with the \f(CW\*(C`DES\*(C'\fR node we get an
error:
.PP
.Vb 4
\&    DB<6> x $_[2]\->child(0)\->str
\&  Can\*(Aqt locate object method "str" via package "DES" at \e
\&    (eval 11)[/usr/share/perl/5.8/perl5db.pl:628] line 2, <STDIN> line 1.
\&    DB<7>
.Ve
.PP
More robust than the former solution of building the node \fIby hand\fR
is to use the constructor \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR:
The method \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
is uset to build forests of syntactic trees.
.PP
It receives a  list of terms describing the trees and \- optionally \-
a reference to a subroutine used to set up the attributes
of the just created nodes. After the creation 
of the trees the sub is called by \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
with arguments the list of references to the nodes (in the order
in which they appear in the terms, from left to right).
\&\f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR returns a list of references 
to the jsut created nodes. In a scalar context returns a reference to the first of such trees.
See an example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ perl \-MParse::Eyapp \-MData::Dumper \-wde 0
\&  main::(\-e:1):   0
\&    DB<1> @t = Parse::Eyapp::Node\->new(\*(AqA(C,D) E(F)\*(Aq, sub { my $i = 0; $_\->{n} = $i++ for @_ })
\&    DB<2> $Data::Dumper::Indent = 0
\&    DB<3> print Dumper($_)."\en" for @t
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 0,\*(Aqchildren\*(Aq => [bless( {\*(Aqn\*(Aq => 1,\*(Aqchildren\*(Aq => []}, \*(AqC\*(Aq ),
\&                                          bless( {\*(Aqn\*(Aq => 2,\*(Aqchildren\*(Aq => []}, \*(AqD\*(Aq )
\&                                         ]
\&                 }, \*(AqA\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 1,\*(Aqchildren\*(Aq => []}, \*(AqC\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 2,\*(Aqchildren\*(Aq => []}, \*(AqD\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 3,\*(Aqchildren\*(Aq => [bless( {\*(Aqn\*(Aq => 4,\*(Aqchildren\*(Aq => []}, \*(AqF\*(Aq )]}, \*(AqE\*(Aq );
\&  $VAR1 = bless( {\*(Aqn\*(Aq => 4,\*(Aqchildren\*(Aq => []}, \*(AqF\*(Aq );
.Ve
.PP
See the following example in which the nodes associated with \f(CW\*(Aqd\*(Aq\fR are
explictly constructed:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-28 ListWithRefs2.eyp| cat \-n
\&   1  # ListWithRefs2.eyp
\&   2  %semantic token \*(Aqc\*(Aq
\&   3  %{
\&   4  use Data::Dumper;
\&   5  %}
\&   6  %%
\&   7  S:  \*(Aqc\*(Aq+  D+
\&   8        {
\&   9           print Dumper($_[1]);
\&  10           print $_[1]\->str."\en";
\&  11           print Dumper($_[2]);
\&  12           print $_[2]\->str."\en";
\&  13        }
\&  14  ;
\&  15
\&  16  D: \*(Aqd\*(Aq.d
\&  17       {
\&  18         Parse::Eyapp::Node\->new(
\&  19           \*(AqDES(TERMINAL)\*(Aq,
\&  20            sub {
\&  21              my ($DES, $TERMINAL) = @_;
\&  22              $TERMINAL\->{attr} = $d;
\&  23            }
\&  24         );
\&  25       }
\&  26  ;
\&  27
\&  28  %%
.Ve
.PP
To know more about \f(CW\*(C`Parse::Eyapp::Node\->new\*(C'\fR
see the Parse::Eyapp::Node section about \f(CW\*(C`new\*(C'\fR
.PP
When the former eyapp program is executed produces the following
output:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ eyapp ListWithRefs2.eyp; use_listwithrefs2.pl
\&  ccdd
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq, \*(Aqtoken\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST_1\*(Aq );
\&  _PLUS_LIST_1(TERMINAL,TERMINAL)
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqDES\*(Aq ),
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqd\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqDES\*(Aq )
\&    ]
\&  }, \*(Aq_PLUS_LIST_2\*(Aq );
\&  _PLUS_LIST_2(DES(TERMINAL),DES(TERMINAL))
.Ve
.PP
\fIThe \f(CI\*(C`*\*(C'\fI operator\fR
.IX Subsection "The * operator"
.PP
Any list operator operates on the factor to its left.
A list in the right hand side of a production rule
counts as a single symbol.
.PP
Both operators \f(CW\*(C`*\*(C'\fR and \f(CW\*(C`+\*(C'\fR can be used 
with the format
\&\f(CW\*(C`X <* Separator>\*(C'\fR.
In such case they describe lists of \f(CW\*(C`X\*(C'\fRs separated by 
\&\f(CW\*(C`separator\*(C'\fR. See an example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-25 CsBetweenCommansAndD.eyp | cat \-n
\&   1  # CsBetweenCommansAndD.eyp
\&   2
\&   3  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&   4
\&   5  %{
\&   6  sub TERMINAL::info {
\&   7    $_[0]\->attr;
\&   8  }
\&   9  %}
\&  10  %tree
\&  11  %%
\&  12  S:
\&  13      (\*(Aqc\*(Aq <* \*(Aq,\*(Aq> \*(Aqd\*(Aq)*
\&  14        {
\&  15           print "\enNode\en";
\&  16           print $_[1]\->str."\en";
\&  17           print "\enChild 0\en";
\&  18           print $_[1]\->child(0)\->str."\en";
\&  19           print "\enChild 1\en";
\&  20           print $_[1]\->child(1)\->str."\en";
\&  21           $_[1]
\&  22        }
\&  23  ;
\&  24
\&  25  %%
.Ve
.PP
The rule
.PP
.Vb 1
\&                            S: (\*(Aqc\*(Aq <* \*(Aq,\*(Aq> \*(Aqd\*(Aq)*
.Ve
.PP
has only two items in its right hand side: the (separated by commas) list
of \f(CW\*(C`c\*(C'\fRs and the list of \f(CW\*(C`d\*(C'\fRs.  The production rule is equivalent to:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v CsBetweenCommansAndD.eyp
\&  pl@nereida:~/LEyapp/examples$ head \-11 CsBetweenCommansAndD.output | cat \-n
\&   1  Rules:
\&   2  \-\-\-\-\-\-
\&   3  0:      $start \-> S $end
\&   4  1:      STAR\-1 \-> STAR\-1 \*(Aq,\*(Aq \*(Aqc\*(Aq
\&   5  2:      STAR\-1 \-> \*(Aqc\*(Aq
\&   6  3:      STAR\-2 \-> STAR\-1
\&   7  4:      STAR\-2 \-> /* empty */
\&   8  5:      PAREN\-3 \-> STAR\-2 \*(Aqd\*(Aq
\&   9  6:      STAR\-4 \-> STAR\-4 PAREN\-3
\&  10  7:      STAR\-4 \-> /* empty */
\&  11  8:      S \-> STAR\-4
.Ve
.PP
The semantic action associated with \f(CW\*(C`*\*(C'\fR is to return 
a reference to a list with the attributes of the 
matching items.
.PP
When working \-as in the example \-
under a tree creation directive it returns
a node belonging to a class named \f(CW\*(C`_STAR_LIST_#number\*(C'\fR
whose children are the items in the list.
The \f(CW\*(C`#number\*(C'\fR is the ordinal number of the production rule
as it appears in the \f(CW\*(C`.output\*(C'\fR file. The attributes must be 
references or associated with semantic tokens to be included 
in the list. Notice \-in the execution of the former
example  that follows \-
how the node for \f(CW\*(C`PAREN\-3\*(C'\fR has been 
eliminated from the tree. Parenthesis nodes are \- generally \-
obivated:
.PP
.Vb 2
\&  pl@nereida:~/LEyapp/examples$ use_csbetweencommansandd.pl
\&  c,c,cd
\&
\&  Node
\&  _STAR_LIST_4(_STAR_LIST_1(TERMINAL[c],TERMINAL[c],TERMINAL[c]),TERMINAL[d])
\&
\&  Child 0
\&  _STAR_LIST_1(TERMINAL[c],TERMINAL[c],TERMINAL[c])
\&
\&  Child 1
\&  TERMINAL[d]
.Ve
.PP
Notice that the comma (since it is a syntactic token) has 
also been supressed.
.PP
\fIGiving Names to Lists\fR
.IX Subsection "Giving Names to Lists"
.PP
To set the name of the node associated with a list operator the
\&\f(CW%name\fR directive must precede the operator as in 
the following example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ sed \-ne \*(Aq1,27p\*(Aq CsBetweenCommansAndDWithNames.eyp | cat \-n
\&   1  # CsBetweenCommansAndDWithNames.eyp
\&   2
\&   3  %semantic token \*(Aqc\*(Aq \*(Aqd\*(Aq
\&   4
\&   5  %{
\&   6  sub TERMINAL::info {
\&   7    $_[0]\->attr;
\&   8  }
\&   9  %}
\&  10  %tree
\&  11  %%
\&  12  Start: S
\&  13  ;
\&  14  S:
\&  15      (\*(Aqc\*(Aq <%name Cs * \*(Aq,\*(Aq> \*(Aqd\*(Aq) %name Cs_and_d *
\&  16        {
\&  17           print "\enNode\en";
\&  18           print $_[1]\->str."\en";
\&  19           print "\enChild 0\en";
\&  20           print $_[1]\->child(0)\->str."\en";
\&  21           print "\enChild 1\en";
\&  22           print $_[1]\->child(1)\->str."\en";
\&  23           $_[1]
\&  24        }
\&  25  ;
\&  26
\&  27  %%
.Ve
.PP
The execution shows the renamed nodes:
.PP
pl@nereida:~/LEyapp/examples$ use_csbetweencommansanddwithnames.pl
c,c,c,cd
.PP
.Vb 2
\&  Node
\&  Cs_and_d(Cs(TERMINAL[c],TERMINAL[c],TERMINAL[c],TERMINAL[c]),TERMINAL[d])
\&
\&  Child 0
\&  Cs(TERMINAL[c],TERMINAL[c],TERMINAL[c],TERMINAL[c])
\&
\&  Child 1
\&  TERMINAL[d]
.Ve
.PP
\fIOptionals\fR
.IX Subsection "Optionals"
.PP
The \f(CW\*(C`X?\*(C'\fR operator stands for the presence or omission
of \f(CW\*(C`X\*(C'\fR.
.PP
The grammar:
.PP
.Vb 12
\&  pl@nereida:~/LEyapp/examples$ head \-11 List5.yp | cat \-n
\&       1  %semantic token \*(Aqc\*(Aq
\&       2  %tree
\&       3  %%
\&       4  S: \*(Aqc\*(Aq \*(Aqc\*(Aq?
\&       5       {
\&       6         print $_[2]\->str."\en";
\&       7         print $_[2]\->child(0)\->attr."\en" if $_[2]\->children;
\&       8      }
\&       9  ;
\&      10
\&      11  %%
.Ve
.PP
is equivalent to:
.PP
.Vb 8
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v List5
\&  pl@nereida:~/LEyapp/examples$ head \-7 List5.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> S $end
\&  1:      OPTIONAL\-1 \-> \*(Aqc\*(Aq
\&  2:      OPTIONAL\-1 \-> /* empty */
\&  3:      S \-> \*(Aqc\*(Aq OPTIONAL\-1
.Ve
.PP
When \f(CW\*(C`yybuildingtree\*(C'\fR is false the associated attribute 
is a list that will be empty if \s-1CX\s0> does not show up.
.PP
Under the \f(CW%tree\fR directive the action creates an c<_OPTIONAL>
node:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ use_list5.pl
\&  cc
\&  _OPTIONAL_1(TERMINAL)
\&  c
\&  pl@nereida:~/LEyapp/examples$ use_list5.pl
\&  c
\&  _OPTIONAL_1
.Ve
.PP
\fIParenthesis\fR
.IX Subsection "Parenthesis"
.PP
Any substring on the right hand side of a production rule can be grouped
using a parenthesis. The introduction of a parenthesis implies the introduction
of an additional syntactic variable whose only production 
is the sequence of symbols between the parenthesis. Thus the grammar:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ head \-6 Parenthesis.eyp | cat \-n
\&     1  %%
\&     2  S:
\&     3        (\*(Aqa\*(Aq S ) \*(Aqb\*(Aq  { shift; [ @_ ] }
\&     4      | \*(Aqc\*(Aq
\&     5  ;
\&     6  %%
.Ve
.PP
is equivalent to:
.PP
.Vb 7
\&  pl@nereida:~/LEyapp/examples$ eyapp \-v Parenthesis.eyp; head \-6 Parenthesis.output
\&  Rules:
\&  \-\-\-\-\-\-
\&  0:      $start \-> S $end
\&  1:      PAREN\-1 \-> \*(Aqa\*(Aq S
\&  2:      S \-> PAREN\-1 \*(Aqb\*(Aq
\&  3:      S \-> \*(Aqc\*(Aq
.Ve
.PP
By default the semantic rule associated with a parenthesis
returns an anonymous list with the attributes of the symbols 
between the parenthesis:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n use_parenthesis.pl
\&       1  #!/usr/bin/perl \-w
\&       2  use Parenthesis;
\&       3  use Data::Dumper;
\&       4
\&       5  $Data::Dumper::Indent = 1;
\&       6  $parser = Parenthesis\->new();
\&       7  print Dumper($parser\->Run);
\&  pl@nereida:~/LEyapp/examples$ use_parenthesis.pl
\&  acb
\&  $VAR1 = [
\&    [ \*(Aqa\*(Aq, \*(Aqc\*(Aq ], \*(Aqb\*(Aq
\&  ];
\&  pl@nereida:~/LEyapp/examples$ use_parenthesis.pl
\&  aacbb
\&  $VAR1 = [
\&    [
\&      \*(Aqa\*(Aq,
\&      [ [ \*(Aqa\*(Aq, \*(Aqc\*(Aq ], \*(Aqb\*(Aq ]
\&    ],
\&    \*(Aqb\*(Aq
\&  ];
.Ve
.PP
when working under a tree directive or when the attribute
\&\f(CW\*(C`buildingtree\*(C'\fR is set via the\f(CW\*(C`YYBuildingtree\*(C'\fR method
the semantic action returns a node with children the attributes
of the symbols between parenthesis. As usual attributes
which aren't references will be skipped from the list of children.
See an example:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-23 List2.yp | cat \-n
\&   1  %{
\&   2  use Data::Dumper;
\&   3  %}
\&   4  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq \*(Aqc\*(Aq
\&   5  %tree
\&   6  %%
\&   7  S:
\&   8        (%name AS \*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&   9          {
\&  10            print "S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\en";
\&  11            print "Attribute of the first symbol:\en".Dumper($_[1]);
\&  12            print "Attribute of the second symbol: $_[2]\en";
\&  13            $_[0]\->YYBuildAST(@_[1..$#_]);
\&  14          }
\&  15      | \*(Aqc\*(Aq
\&  16          {
\&  17            print "S \-> \*(Aqc\*(Aq\en";
\&  18            my $r = Parse::Eyapp::Node\->new(qw(C(TERMINAL)), sub { $_[1]\->attr(\*(Aqc\*(Aq) }) ;
\&  19            print Dumper($r);
\&  20            $r;
\&  21          }
\&  22  ;
\&  23  %%
.Ve
.PP
The example shows (line 8)
how to rename a \f(CW\*(C`_PAREN\*(C'\fR node. The \f(CW\*(C`%name CLASSNAME\*(C'\fR goes
after the opening parenthesis.
.PP
The call to \f(CW\*(C`YYBuildAST\*(C'\fR at line 13
with argumetns the attributes of the symbols on the right hand side
returns the node describing the current production rule.
Notice that line 13 can be rewritten as:
.PP
.Vb 1
\&                    goto &Parse::Eyapp::Driver::YYBuildAST;
.Ve
.PP
At line 18 the node for the rule is explictly created
using \f(CW\*(C`Parse::Eyapp::Node\-\*(C'\fRnew>. The handler passed as second argument
is responsible for setting the value of the atribute \f(CW\*(C`attr\*(C'\fR
of the just created \f(CW\*(C`TERMINAL\*(C'\fR node.
.PP
Let us see an execution:
.PP
.Vb 11
\&  pl@nereida:~/LEyapp/examples$ use_list2.pl
\&  aacbb
\&  S \-> \*(Aqc\*(Aq
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( {
\&        \*(Aqchildren\*(Aq => [],
\&        \*(Aqattr\*(Aq => \*(Aqc\*(Aq
\&      }, \*(AqTERMINAL\*(Aq )
\&    ]
\&  }, \*(AqC\*(Aq );
.Ve
.PP
the first reduction occurs by the non recursive rule. The execution
shows the tree built by the call to
\&\f(CW\*(C`Parse::Eyapp::Node\-\*(C'\fRnew>
at line 18.
.PP
The execution continues with the reduction or antiderivation by the rule
\&\f(CW\*(C`S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\*(C'\fR. The action at lines 9\-14
dumps the attribute associated with \f(CW\*(C`(\*(Aqa\*(Aq S)\*(C'\fR
\&\- or, in other words,  the attribute associated with the variable 
\&\f(CW\*(C`PAREN\-1\*(C'\fR. It also dumps the attribute of \f(CW\*(Aqb\*(Aq\fR:
.PP
.Vb 11
\&  S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&  Attribute of the first symbol:
\&  $VAR1 = bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&        bless( { \*(Aqchildren\*(Aq => [ bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&       ]
\&     }, \*(AqC\*(Aq )
\&    ]
\&  }, \*(AqAS\*(Aq );
\&Attribute of the second symbol: b
.Ve
.PP
The last reduction shown is by the rule:
\&\f(CW\*(C`S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq\*(C'\fR:
.PP
.Vb 10
\&  S \-> (\*(Aqa\*(Aq S )\*(Aqb\*(Aq
\&  Attribute of the first symbol:
\&  $VAR1 = bless( {
\&    \*(Aqchildren\*(Aq => [
\&      bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&      bless( {
\&        \*(Aqchildren\*(Aq => [
\&          bless( {
\&            \*(Aqchildren\*(Aq => [
\&              bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqa\*(Aq, \*(Aqtoken\*(Aq => \*(Aqa\*(Aq }, \*(AqTERMINAL\*(Aq ),
\&              bless( {
\&                \*(Aqchildren\*(Aq => [
\&                  bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqc\*(Aq }, \*(AqTERMINAL\*(Aq )
\&                ]
\&              }, \*(AqC\*(Aq )
\&            ]
\&          }, \*(AqAS\*(Aq ),
\&          bless( { \*(Aqchildren\*(Aq => [], \*(Aqattr\*(Aq => \*(Aqb\*(Aq, \*(Aqtoken\*(Aq => \*(Aqb\*(Aq }, \*(AqTERMINAL\*(Aq )
\&        ]
\&      }, \*(AqS_2\*(Aq )
\&    ]
\&  }, \*(AqAS\*(Aq );
\&  Attribute of the second symbol: b
.Ve
.PP
\fIActions Inside Parenthesis\fR
.IX Subsection "Actions Inside Parenthesis"
.PP
Though is a practice to avoid, since it clutters
the code, it is certainly permitted to introduce
actions between the parenthesis, as in the example below:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ head \-16 ListAndAction.eyp | cat \-n
\&   1  # ListAndAction.eyp
\&   2  %{
\&   3  my $num = 0;
\&   4  %}
\&   5
\&   6  %%
\&   7  S:      \*(Aqc\*(Aq
\&   8              {
\&   9                print "S \-> c\en"
\&  10              }
\&  11      |    (\*(Aqa\*(Aq {$num++; print "Seen <$num> \*(Aqa\*(Aqs\en"; $_[1] }) S \*(Aqb\*(Aq
\&  12              {
\&  13                print "S \-> (a ) S b\en"
\&  14              }
\&  15  ;
\&  16  %%
.Ve
.PP
This is the output when executing this program with input \f(CW\*(C`aaacbbb\*(C'\fR:
.PP
.Vb 9
\&  pl@nereida:~/LEyapp/examples$ use_listandaction.pl
\&  aaacbbb
\&  Seen <1> \*(Aqa\*(Aqs
\&  Seen <2> \*(Aqa\*(Aqs
\&  Seen <3> \*(Aqa\*(Aqs
\&  S \-> c
\&  S \-> (a ) S b
\&  S \-> (a ) S b
\&  S \-> (a ) S b
.Ve
.SS "Names for attributes"
.IX Subsection "Names for attributes"
Attributes can be referenced by meaningful names instead
of the classic error-prone positional approach using the \fIdot notation\fR:
.PP
.Vb 5
\&                        rhs:  rhseltwithid *
\&                        rhseltwithid : 
\&                              rhselt \*(Aq.\*(Aq IDENT 
\&                            | \*(Aq$\*(Aq rhselt  
\&                            | rhselt
.Ve
.PP
for example:
.PP
.Vb 1
\&              exp : exp.left \*(Aq\-\*(Aq exp.right  { $left \- $right }
.Ve
.PP
By qualifying the first appearance of the syntactic variable \f(CW\*(C`exp\*(C'\fR
with the notation \f(CW\*(C`exp.left\*(C'\fR we can later refer inside the actions
to the associated attribute using the lexical variable
\&\f(CW$left\fR.
.PP
The \fIdolar notation\fR \f(CW$A\fR can be used as an abbreviation
of \f(CW\*(C`A.A\*(C'\fR.
.SS "Default actions"
.IX Subsection "Default actions"
When no action is specified both \f(CW\*(C`yapp\*(C'\fR and \f(CW\*(C`eyapp\*(C'\fR
implicitly insert the semantic action \f(CW\*(C`{ $_[1] }\*(C'\fR. 
In \f(CW\*(C`Parse::Eyapp\*(C'\fR you can modify such behavior using the \f(CW\*(C`%defaultaction { Perl code }\*(C'\fR
directive. The \f(CW\*(C`{ Perl code }\*(C'\fR clause that follows the \f(CW%defaultaction\fR
directive is
executed when reducing by any production for which no explicit
action was specified.
.PP
\fITranslator from Infix to Postfix\fR
.IX Subsection "Translator from Infix to Postfix"
.PP
See an example that translates an infix expression
like \f(CW\*(C`a=b*\-3\*(C'\fR into a postfix expression like \f(CW\*(C`a b 3 NEG * = \*(C'\fR:
.PP
.Vb 5
\& # File Postfix.eyp (See the examples/ directory)
\& %right  \*(Aq=\*(Aq
\& %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\& %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\& %left   NEG
\&
\& %defaultaction { return  "$left $right $op"; }
\&
\& %%
\& line: $exp  { print "$exp\en" }
\& ;
\&
\& exp:        $NUM  { $NUM }
\&         |   $VAR  { $VAR }
\&         |   VAR.left \*(Aq=\*(Aq.op exp.right
\&         |   exp.left \*(Aq+\*(Aq.op exp.right
\&         |   exp.left \*(Aq\-\*(Aq.op exp.right
\&         |   exp.left \*(Aq*\*(Aq.op exp.right
\&         |   exp.left \*(Aq/\*(Aq.op exp.right
\&         |   \*(Aq\-\*(Aq $exp %prec NEG { "$exp NEG" }
\&         |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq { $exp }
\& ;
\&
\& %%
\&
\& # Support subroutines as in the Synopsis example
\& ...
.Ve
.PP
The file containing the \f(CW\*(C`Eyapp\*(C'\fR program must be compiled with \f(CW\*(C`eyapp\*(C'\fR:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> eyapp Postfix.eyp
.Ve
.PP
Next, you have to write a client program:
.PP
.Vb 7
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n usepostfix.pl
\&      1  #!/usr/bin/perl \-w
\&      2  use strict;
\&      3  use Postfix;
\&      4
\&      5  my $parser = new Postfix();
\&      6  $parser\->Run;
.Ve
.PP
Now we can run the client program:
.PP
.Vb 3
\& nereida:~/src/perl/YappWithDefaultAction/examples> usepostfix.pl
\& Write an expression: \-(2*a\-b*\-3)
\& 2 a * b 3 NEG * \- NEG
.Ve
.PP
\fIDefault Actions, \f(CI%name\fI and \f(CI\*(C`YYName\*(C'\fI\fR
.IX Subsection "Default Actions, %name and YYName"
.PP
In \f(CW\*(C`eyapp\*(C'\fR each production rule has a name.
The name of a rule can be explicitly given by the programmer 
using the \f(CW%name\fR directive. For example, in the piece of code
that follows the name \f(CW\*(C`ASSIGN\*(C'\fR is given to the rule \f(CW\*(C`exp: VAR \*(Aq=\*(Aq exp\*(C'\fR.
.PP
When no explicit name is given the rule has an implicit name.
The implicit name of a rule is shaped by concatenating
the name of the syntactic variable on its left, an underscore 
and the ordinal number of the production rule \f(CW\*(C`Lhs_#\*(C'\fR
as it appears in the \f(CW\*(C`.output\*(C'\fR file.
Avoid giving names matching such pattern to production rules.
The patterns
\&\f(CW\*(C`/${lhs}_\ed+$/\*(C'\fR where \f(CW\*(C`${lhs}\*(C'\fR is the name of the syntactic variable
are reserved for internal use by \f(CW\*(C`eyapp\*(C'\fR.
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n Lhs.eyp
\&   1  # Lhs.eyp
\&   2
\&   3  %right  \*(Aq=\*(Aq
\&   4  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&   5  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&   6  %left   NEG
\&   7
\&   8  %defaultaction {
\&   9    my $self = shift;
\&  10    my $name = $self\->YYName();
\&  11    bless { children => [ grep {ref($_)} @_] }, $name;
\&  12  }
\&  13
\&  14  %%
\&  15  input:
\&  16              /* empty */
\&  17                { [] }
\&  18          |   input line
\&  19                {
\&  20                  push @{$_[1]}, $_[2] if defined($_[2]);
\&  21                  $_[1]
\&  22                }
\&  23  ;
\&  24
\&  25  line:     \*(Aq\en\*(Aq       { }
\&  26          | exp \*(Aq\en\*(Aq   {  $_[1] }
\&  27  ;
\&  28
\&  29  exp:
\&  30              NUM   { $_[1] }
\&  31          |   VAR   { $_[1] }
\&  32          |   %name ASSIGN
\&  33              VAR \*(Aq=\*(Aq exp
\&  34          |   %name PLUS
\&  35              exp \*(Aq+\*(Aq exp
\&  36          |   %name MINUS
\&  37              exp \*(Aq\-\*(Aq exp
\&  38          |   %name TIMES
\&  39              exp \*(Aq*\*(Aq exp
\&  40          |   %name DIV
\&  41              exp \*(Aq/\*(Aq exp
\&  42          |   %name UMINUS
\&  43              \*(Aq\-\*(Aq exp %prec NEG
\&  44          |  \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&  45  ;
.Ve
.PP
Inside a semantic action
the name of the current rule can be recovered 
using the method \f(CW\*(C`YYName\*(C'\fR of the parser object.
.PP
The default action (lines 8\-12) computes as attribute of the left
hand side a reference to an object blessed in the name of the rule.
The object has an attribute \f(CW\*(C`children\*(C'\fR which is a reference 
to the list of children of the node.
The call to \f(CW\*(C`grep\*(C'\fR
.PP
.Vb 1
\&  11    bless { children => [ grep {ref($_)} @_] }, $name;
.Ve
.PP
excludes children that aren't references. Notice that the lexical analyzer 
only returns references for the \f(CW\*(C`NUM\*(C'\fR and \f(CW\*(C`VAR\*(C'\fR terminals:
.PP
.Vb 10
\&  59  sub _Lexer {
\&  60      my($parser)=shift;
\&  61
\&  62      for ($parser\->YYData\->{INPUT}) {
\&  63          s/^[ \et]+//;
\&  64          return(\*(Aq\*(Aq,undef) unless $_;
\&  65          s/^([0\-9]+(?:\e.[0\-9]+)?)//
\&  66                  and return(\*(AqNUM\*(Aq, bless { attr => $1}, \*(AqNUM\*(Aq);
\&  67          s/^([A\-Za\-z][A\-Za\-z0\-9_]*)//
\&  68                  and return(\*(AqVAR\*(Aq,bless {attr => $1}, \*(AqVAR\*(Aq);
\&  69          s/^(.)//s
\&  70                  and return($1, $1);
\&  71      }
\&  72      return(\*(Aq\*(Aq,undef);
\&  73  }
.Ve
.PP
follows the client program:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n uselhs.pl
\&       1  #!/usr/bin/perl \-w
\&       2  use Lhs;
\&       3  use Data::Dumper;
\&       4
\&       5  $parser = new Lhs();
\&       6  my $tree = $parser\->Run;
\&       7  $Data::Dumper::Indent = 1;
\&       8  if (defined($tree)) { print Dumper($tree); }
\&       9  else { print "Cadena no va\*'lida\en"; }
.Ve
.PP
When executed with input \f(CW\*(C`a=(2+3)*b\*(C'\fR the parser produces
the following tree:
.PP
.Vb 1
\&  ASSIGN(TIMES(PLUS(NUM[2],NUM[3]), VAR[b]))
.Ve
.PP
See the result of an execution:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ uselhs.pl
\&  a=(2+3)*b
\&  $VAR1 = [
\&    bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( { \*(Aqattr\*(Aq => \*(Aqa\*(Aq }, \*(AqVAR\*(Aq ),
\&        bless( {
\&          \*(Aqchildren\*(Aq => [
\&            bless( {
\&              \*(Aqchildren\*(Aq => [
\&                bless( { \*(Aqattr\*(Aq => \*(Aq2\*(Aq }, \*(AqNUM\*(Aq ),
\&                bless( { \*(Aqattr\*(Aq => \*(Aq3\*(Aq }, \*(AqNUM\*(Aq )
\&              ]
\&            }, \*(AqPLUS\*(Aq ),
\&            bless( { \*(Aqattr\*(Aq => \*(Aqb\*(Aq }, \*(AqVAR\*(Aq )
\&          ]
\&        }, \*(AqTIMES\*(Aq )
\&      ]
\&    }, \*(AqASSIGN\*(Aq )
\&  ];
.Ve
.PP
The name of a production rule can be changed at execution time.
See the following example:
.PP
.Vb 10
\&  29  exp:
\&  30              NUM   { $_[1] }
\&  31          |   VAR   { $_[1] }
\&  32          |   %name ASSIGN
\&  33              VAR \*(Aq=\*(Aq exp
\&  34          |   %name PLUS
\&  35              exp \*(Aq+\*(Aq exp
\&  36          |   %name MINUS
\&  37              exp \*(Aq\-\*(Aq exp
\&  38                {
\&  39                  my $self = shift;
\&  40                  $self\->YYName(\*(AqSUBSTRACT\*(Aq); # rename it
\&  41                  $self\->YYBuildAST(@_); # build the node
\&  42                }
\&  43          |   %name TIMES
\&  44              exp \*(Aq*\*(Aq exp
\&  45          |   %name DIV
\&  46              exp \*(Aq/\*(Aq exp
\&  47          |   %name UMINUS
\&  48              \*(Aq\-\*(Aq exp %prec NEG
\&  49          |  \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&  50  ;
.Ve
.PP
When the client program is executed we can see the presence
of the \f(CW\*(C`SUBSTRACT\*(C'\fR nodes:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ useyynamedynamic.pl
\&  2\-b
\&  $VAR1 = [
\&    bless( {
\&      \*(Aqchildren\*(Aq => [
\&        bless( {
\&          \*(Aqattr\*(Aq => \*(Aq2\*(Aq
\&        }, \*(AqNUM\*(Aq ),
\&        bless( {
\&          \*(Aqattr\*(Aq => \*(Aqb\*(Aq
\&        }, \*(AqVAR\*(Aq )
\&      ]
\&    }, \*(AqSUBSTRACT\*(Aq )
\&  ];
.Ve
.ie n .SS "Abstract Syntax Trees : %tree and %name"
.el .SS "Abstract Syntax Trees : \f(CW%tree\fP and \f(CW%name\fP"
.IX Subsection "Abstract Syntax Trees : %tree and %name"
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR facilitates the construction of concrete syntax trees and 
abstract syntax trees (abbreviated \s-1AST\s0 from now on) through the \f(CW%tree\fR
directive. 
Nodes in the \s-1AST\s0 are blessed in the production
\&\f(CW\*(C`name\*(C'\fR. 
By default the name of a production is the concatenation
of the left hand side and the production number. The production number
is the ordinal number of the production as they appear in the associated 
\&\f(CW\*(C`.output\*(C'\fR file (see option \f(CW\*(C`\-v\*(C'\fR of eyapp). For example,
given the grammar:
.PP
.Vb 7
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq9,28p\*(Aq treewithoutnames.pl
\& my $grammar = q{
\&   %right  \*(Aq=\*(Aq     # Lowest precedence
\&   %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&   %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&   %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&   %tree           # Let us build an abstract syntax tree ...
\&
\&   %%
\&   line: exp <+ \*(Aq;\*(Aq>  { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&   ;
\&
\&   exp:
\&        NUM           |   VAR       | VAR \*(Aq=\*(Aq exp
\&     | exp \*(Aq+\*(Aq exp    | exp \*(Aq\-\*(Aq exp |  exp \*(Aq*\*(Aq exp
\&     | exp \*(Aq/\*(Aq exp
\&     | \*(Aq\-\*(Aq exp %prec NEG
\&     |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&   ;
.Ve
.PP
The tree produced by the parser when feed with input \f(CW\*(C`a=2*b\*(C'\fR
is:
.PP
.Vb 1
\& _PLUS_LIST(exp_6(TERMINAL[a],exp_9(exp_4(TERMINAL[2]),exp_5(TERMINAL[b]))))
.Ve
.PP
If we want to see the correspondence between names and rules we can generate and
check the corresponding file \f(CW\*(C`.output\*(C'\fR:
.PP
.Vb 10
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq28,42p\*(Aq treewithoutnames.output
\& Rules:
\& \-\-\-\-\-\-
\& 0:      $start \-> line $end
\& 1:      PLUS\-1 \-> PLUS\-1 \*(Aq;\*(Aq exp
\& 2:      PLUS\-1 \-> exp
\& 3:      line \-> PLUS\-1
\& 4:      exp \-> NUM
\& 5:      exp \-> VAR
\& 6:      exp \-> VAR \*(Aq=\*(Aq exp
\& 7:      exp \-> exp \*(Aq+\*(Aq exp
\& 8:      exp \-> exp \*(Aq\-\*(Aq exp
\& 9:      exp \-> exp \*(Aq*\*(Aq exp
\& 10:     exp \-> exp \*(Aq/\*(Aq exp
\& 11:     exp \-> \*(Aq\-\*(Aq exp
\& 12:     exp \-> \*(Aq(\*(Aq exp \*(Aq)\*(Aq
.Ve
.PP
We can see now that the node \f(CW\*(C`exp_9\*(C'\fR corresponds to the production \f(CW\*(C`exp \-> exp \*(Aq*\*(Aq exp\*(C'\fR.
Observe also that the Eyapp production:
.PP
.Vb 2
\&                                line: exp <+ \*(Aq;\*(Aq>
\&actually produces the productions:
\&
\&                        1:      PLUS\-1 \-> PLUS\-1 \*(Aq;\*(Aq exp
\&                        2:      PLUS\-1 \-> exp
.Ve
.PP
and that the name of the class associated with the non empty list is \f(CW\*(C`_PLUS_LIST\*(C'\fR.
.PP
A production rule can be 
\&\fInamed\fR using the \f(CW\*(C`%name IDENTIFIER\*(C'\fR directive. 
For each production rule a 
namespace/package is created. \fIThe\fR \f(CW\*(C`IDENTIFIER\*(C'\fR
\&\fIis the name of the associated package\fR.
Therefore, by modifying the former grammar with 
additional \f(CW%name\fR directives:
.PP
.Vb 7
\& pl@nereida:~/src/perl/YappWithDefaultAction/examples$ sed \-ne \*(Aq8,26p\*(Aq treewithnames.pl
\& my $grammar = q{
\&   %right  \*(Aq=\*(Aq     # Lowest precedence
\&   %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq # + and \- have more precedence than = Disambiguate a\-b\-c as (a\-b)\-c
\&   %left   \*(Aq*\*(Aq \*(Aq/\*(Aq # * and / have more precedence than + Disambiguate a/b/c as (a/b)/c
\&   %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&   %tree           # Let us build an abstract syntax tree ...
\&
\&   %%
\&   line: exp <%name EXPS + \*(Aq;\*(Aq>  { $_[1] } /* list of expressions separated by \*(Aq;\*(Aq */
\&   ;
\&
\&   exp:
\&       %name NUM    NUM           | %name VAR   VAR         | %name ASSIGN VAR \*(Aq=\*(Aq exp
\&     | %name PLUS   exp \*(Aq+\*(Aq exp   | %name MINUS exp \*(Aq\-\*(Aq exp | %name TIMES  exp \*(Aq*\*(Aq exp
\&     | %name DIV    exp \*(Aq/\*(Aq exp
\&     | %name UMINUS \*(Aq\-\*(Aq exp %prec NEG
\&     |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }
\&   ;
.Ve
.PP
we are explictly naming the productions. Thus, all the node instances 
corresponding to the 
production \f(CW\*(C`exp: VAR \*(Aq=\*(Aq exp\*(C'\fR will belong to the class \f(CW\*(C`ASSIGN\*(C'\fR. Now 
the tree for \f(CW\*(C`a=2*b\*(C'\fR becomes:
.PP
.Vb 1
\&          EXPS(ASSIGN(TERMINAL[a],TIMES(NUM(TERMINAL[2]),VAR(TERMINAL[b]))))
.Ve
.PP
Observe how the list has been named \f(CW\*(C`EXPS\*(C'\fR. The \f(CW%name\fR directive prefixes the 
list operator (\f(CW\*(C`[+*?]\*(C'\fR).
.PP
\fIAbout the Encapsulation of Nodes\fR
.IX Subsection "About the Encapsulation of Nodes"
.PP
There is no encapsulation of nodes. The user/client 
knows that they are hashes that can be decorated with new keys/attributes.
All nodes in the \s-1AST\s0 created by \f(CW%tree\fR are \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR nodes.
The only reserved field is \f(CW\*(C`children\*(C'\fR which is a reference to the
array of children. You can always create a \f(CW\*(C`Node\*(C'\fR class 
\&\fIby hand\fR by inheriting from \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR. See 
section 'Compiling with eyapp and treereg' in Parse::Eyapp for an example.
.PP
\fI\s-1TERMINAL\s0 Nodes\fR
.IX Subsection "TERMINAL Nodes"
.PP
Nodes named \f(CW\*(C`TERMINAL\*(C'\fR are built from the
tokens provided by the lexical analyzer. 
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR follows the same protocol
than Parse::Yapp for communication between the parser and the lexical analyzer:
A couple \f(CW\*(C`($token, $attribute)\*(C'\fR is returned by the lexical analyzer.
These values are stored under the keys \f(CW\*(C`token\*(C'\fR and \f(CW\*(C`attr\*(C'\fR.
\&\f(CW\*(C`TERMINAL\*(C'\fR nodes as all \f(CW\*(C`Parse::Eyapp::Node\*(C'\fR nodes
also have the attribute \f(CW\*(C`children\*(C'\fR but is \- almost always \- empty.
.PP
\fIExplicit Actions Inside \f(CI%tree\fI\fR
.IX Subsection "Explicit Actions Inside %tree"
.PP
Explicit actions can be specified by the programmer like in this line
from the Parse::Eyapp \f(CW\*(C`SYNOPSIS\*(C'\fR example:
.PP
.Vb 1
\&      |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq  { $_[2] }  /* Let us simplify a bit the tree */
.Ve
.PP
Explicit actions receive as arguments the references to the children nodes already 
built. The programmer can influence the shape of the tree by inserting
these explicit actions. In this example the programmer has decided to simplify the 
syntax tree: the nodes associated with the parenthesis are 
discarded and the reference to the subtree containing the proper
expression is returned. Such manoeuvre is called \fIbypassing\fR.
See section \*(L"The  bypass clause and the \f(CW%no\fR bypass directive\*(R"
to know more about \fIautomatic bypassing\fR
.PP
\fIExplicitly Building Nodes With \f(CI\*(C`YYBuildAST\*(C'\fI\fR
.IX Subsection "Explicitly Building Nodes With YYBuildAST"
.PP
Sometimes the best time to decorate a node with some
attributes is just after being built.
In such cases the programmer can take \fImanual control\fR
building the node with \f(CW\*(C`YYBuildAST\*(C'\fR to 
inmediately proceed to decorate it.
.PP
The following example illustrates the situation:
.PP
.Vb 9
\& Variable:
\&     %name  VARARRAY
\&     $ID (\*(Aq[\*(Aq binary \*(Aq]\*(Aq) <%name INDEXSPEC +>
\&       {
\&         my $self = shift;
\&         my $node =  $self\->YYBuildAST(@_);
\&         $node\->{line} = $ID\->[1];
\&         return $node;
\&       }
.Ve
.PP
This production rule defines the expression to access an array element 
as an identifier followed by
a non empty list of binary expressions \f(CW\*(C` Variable: ID (\*(Aq[\*(Aq binary \*(Aq]\*(Aq)+\*(C'\fR. 
Furthermore, the node corresponding
to the list of indices has been named \f(CW\*(C`INDEXSPEC\*(C'\fR.
.PP
When no explicit action is
inserted a binary node will be built having as first child the node
corresponding to the identifier \f(CW$ID\fR and as second child the reference 
to the list of binary expressions. The children corresponding to
\&\f(CW\*(Aq[\*(Aq\fR and \f(CW\*(Aq]\*(Aq\fR are discarded since they are \-by default\- \fIsyntactic tokens\fR
(see section \*(L"Syntactic and Semantic tokens\*(R").
However, the programmer wants to decorate
the node being built with a \f(CW\*(C`line\*(C'\fR attribute holding the line number in the source
code where the identifier being used appears. The call to the \f(CW\*(C`Parse::Eyapp::Driver\*(C'\fR
method \f(CW\*(C`YYBuildAST\*(C'\fR does the job of building the node. After
that the node can be decorated and returned.
.PP
Actually, the \f(CW%tree\fR directive is semantically equivalent to:
.PP
.Vb 1
\&                %default action { goto &Parse::Eyapp::Driver::YYBuildAST }
.Ve
.PP
\fIReturning non References Under \f(CI%tree\fI\fR
.IX Subsection "Returning non References Under %tree"
.PP
When a \fIexplicit user action returns s.t. that is not a reference
no node will be inserted\fR. This fact can be used to supress nodes
in the \s-1AST\s0 being built. See the following example (file \f(CW\*(C`examples/returnnonode.yp\*(C'\fR):
.PP
.Vb 12
\& nereida:~/src/perl/YappWithDefaultAction/examples> sed \-ne \*(Aq1,11p\*(Aq returnnonode.yp | cat \-n
\&  1  %tree
\&  2  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq
\&  3  %%
\&  4  S:  /* empty */
\&  5      | S A
\&  6      | S B
\&  7  ;
\&  8  A : \*(Aqa\*(Aq
\&  9  ;
\& 10  B : \*(Aqb\*(Aq { }
\& 11  ;
.Ve
.PP
since the action at line 10 returns \f(CW\*(C`undef\*(C'\fR
the \f(CW\*(C`B : \*(Aqb\*(Aq\*(C'\fR subtree will not be inserted in the \s-1AST:\s0
.PP
.Vb 3
\& nereida:~/src/perl/YappWithDefaultAction/examples> usereturnnonode.pl
\& ababa
\& S_2(S_3(S_2(S_3(S_2(S_1,A_4(TERMINAL[a]))),A_4(TERMINAL[a]))),A_4(TERMINAL[a]))
.Ve
.PP
Observe the absence of \f(CW\*(C`B\*(C'\fRs and \f(CW\*(Aqb\*(Aq\fRs.
.PP
\fIIntermediate actions and \f(CI%tree\fI\fR
.IX Subsection "Intermediate actions and %tree"
.PP
Intermediate actions can be used to change the shape of the \s-1AST \s0(prune it,
decorate it, etc.) but the value returned by them is ignored. The grammar 
below has two intermediate actions. They modify the attributes of the
node to its left and return a reference \f(CW$f\fR to such node (lines 5 and 6):
.PP
.Vb 12
\& nereida:~/src/perl/YappWithDefaultAction/examples> \e
\&          sed \-ne \*(Aq1,10p\*(Aq intermediateactiontree.yp | cat \-n
\&  1  %semantic token \*(Aqa\*(Aq \*(Aqb\*(Aq
\&  2  %tree bypass
\&  3  %%
\&  4  S:    /* empty */
\&  5      | S A.f { $f\->{attr} = "A"; $f; } A
\&  6      | S B.f { $f\->{attr} = "B"; $f; } B
\&  7  ;
\&  8  A : %name A \*(Aqa\*(Aq
\&  9  ;
\& 10  B : %name B \*(Aqb\*(Aq
.Ve
.PP
See the client program running:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> cat \-n useintermediateactiontree.pl
\&  1  #!/usr/bin/perl \-w
\&  2  use strict;
\&  3  use Parse::Eyapp;
\&  4  use intermediateactiontree;
\&  5
\&  6  { no warnings;
\&  7  *A::info = *B::info = sub { $_[0]{attr} };
\&  8  }
\&  9
\& 10  my $parser = intermediateactiontree\->new();
\& 11  my $t = $parser\->Run;
\& 12  print $t\->str,"\en";
\& nereida:~/src/perl/YappWithDefaultAction/examples> useintermediateactiontree.pl
\& aabbaa
\& S_2(S_4(S_2(S_1,A[A],A[a]),B[B],B[b]),A[A],A[a])
.Ve
.PP
The 
attributes 
of left \f(CW\*(C`A\*(C'\fRs 
have been effectively changed by the intermediate actions
from \f(CW\*(Aqa\*(Aq\fR to \f(CW\*(AqA\*(Aq\fR.
However no further children have been inserted.
.PP
\fISyntactic and Semantic tokens\fR
.IX Subsection "Syntactic and Semantic tokens"
.PP
\&\f(CW\*(C`Parse::Eyapp\*(C'\fR diferences between \f(CW\*(C`syntactic tokens\*(C'\fR
and \f(CW\*(C`semantic tokens\*(C'\fR. By default all tokens
declared using string notation (i.e. between quotes
like \f(CW\*(Aq+\*(Aq\fR, \f(CW\*(Aq=\*(Aq\fR)
are considered \fIsyntactic tokens\fR. Tokens declared by an identifier
(like \f(CW\*(C`NUM\*(C'\fR or \f(CW\*(C`VAR\*(C'\fR) are by default considered
\&\fIsemantic tokens\fR. \fBSyntactic tokens do not yield to nodes in the
syntactic tree\fR. Thus, the first print in the former Parse::Eyapp \f(CW\*(C`/SYNOPSIS\*(C'\fR example:
.PP
.Vb 4
\&              $parser\->YYData\->{INPUT} = "2*\-3+b*0;\-\-2\en"; 
\&              my $t = $parser\->Run;                    
\&              local $Parse::Eyapp::Node::INDENT=2;
\&              print "Syntax Tree:",$t\->str;
.Ve
.PP
gives as result the following output:
.PP
.Vb 10
\& nereida:~/src/perl/YappWithDefaultAction/examples> synopsis.pl
\& Syntax Tree:
\& EXPRESION_LIST(
\&   PLUS(
\&     TIMES(
\&       NUM(
\&         TERMINAL[2]
\&       ),
\&       UMINUS(
\&         NUM(
\&           TERMINAL[3]
\&         )
\&       ) # UMINUS
\&     ) # TIMES,
\&     TIMES(
\&       VAR(
\&         TERMINAL[b]
\&       ),
\&       NUM(
\&         TERMINAL[0]
\&       )
\&     ) # TIMES
\&   ) # PLUS,
\&   UMINUS(
\&     UMINUS(
\&       NUM(
\&         TERMINAL[2]
\&       )
\&     ) # UMINUS
\&   ) # UMINUS
\& ) # EXPRESION_LIST
.Ve
.PP
\&\f(CW\*(C`TERMINAL\*(C'\fR nodes corresponding to tokens that were defined by strings like
\&\f(CW\*(Aq=\*(Aq\fR, \f(CW\*(Aq\-\*(Aq\fR, \f(CW\*(Aq+\*(Aq\fR, \f(CW\*(Aq/\*(Aq\fR, \f(CW\*(Aq*\*(Aq\fR, \f(CW\*(Aq(\*(Aq\fR and \f(CW\*(Aq)\*(Aq\fR  do not 
appear in the tree.  \f(CW\*(C`TERMINAL\*(C'\fR nodes corresponding to tokens that were defined
using an identifer, like \f(CW\*(C`NUM\*(C'\fR or \f(CW\*(C`VAR\*(C'\fR are, by default,  \fIsemantic tokens\fR
and appear in the \s-1AST.\s0
.PP
\fIChanging the Status of a Token\fR
.IX Subsection "Changing the Status of a Token"
.PP
The new token declaration directives \f(CW\*(C`%syntactic token\*(C'\fR and
\&\f(CW\*(C`%semantic token\*(C'\fR can change the status of a token.
For example (file \f(CW\*(C`15treewithsyntactictoken.pl\*(C'\fR in the \f(CW\*(C`examples/\*(C'\fR directory), 
given the grammar:
.PP
.Vb 3
\&   %syntactic token b
\&   %semantic token \*(Aqa\*(Aq \*(Aqc\*(Aq
\&   %tree
\&
\&   %%
\&
\&   S: %name ABC
\&        A B C
\&    | %name BC
\&        B C
\&   ;
\&
\&   A: %name A
\&        \*(Aqa\*(Aq
\&   ;
\&
\&   B: %name B
\&        b
\&   ;
\&
\&   C: %name C
\&       \*(Aqc\*(Aq
\&   ;
\&   %%
.Ve
.PP
the tree build for input \f(CW\*(C`abc\*(C'\fR will be 
\&\f(CW\*(C`ABC(A(TERMINAL[a]),B,C(TERMINAL[c]))\*(C'\fR.
.PP
\fISaving the Information of Syntactic Tokens in their Father\fR
.IX Subsection "Saving the Information of Syntactic Tokens in their Father"
.PP
The reason for the adjective \f(CW%syntactic\fR applied to a token is to 
state that the token influences the shape of the syntax tree
but carries no other information. When the syntax tree is built
the node corresponding to the token is discarded.
.PP
Sometimes the difference between syntactic and semantic 
tokens is blurred. For example the line number associated
with an instance of the syntactic token \f(CW\*(Aq+\*(Aq\fR can be used later
\&\-say during type checking\- to emit a more accurate error
diagnostic. But if the node was discarded the information
about that line number is no longer available.
When building the syntax tree \f(CW\*(C`Parse::Eyapp\*(C'\fR (namely
the method \f(CW\*(C`Parse::Eyapp::YYBuildAST\*(C'\fR) checks 
if the method \f(CW\*(C`TERMINAL::save_attributes\*(C'\fR exists and if so
it will be called when dealing with a \fIsyntactic token\fR. 
The method receives as argument \- additionally
to the reference to the attribute of the token as it
is returned by the lexical analyzer \- a reference
to the node associated with the left hand side of the
production. Here is an example (file \f(CW\*(C`examples/Types.eyp\*(C'\fR)
of use:
.PP
.Vb 5
\&              sub TERMINAL::save_attributes {
\&                # $_[0] is a syntactic terminal
\&                # $_[1] is the father.
\&                push @{$_[1]\->{lines}}, $_[0]\->[1]; # save the line number
\&              }
.Ve
.PP
\fIThe  \f(CI\*(C`bypass\*(C'\fI clause and the \f(CI\*(C`%no bypass\*(C'\fI directive\fR
.IX Subsection "The bypass clause and the %no bypass directive"
.PP
The shape of the tree can be also modified using some \f(CW%tree\fR clauses
as \f(CW\*(C`%tree bypass\*(C'\fR which will produce an automatic \fIbypass\fR of any
node with only one child at tree-construction-time.
.PP
A \fIbypass operation\fR consists in \fIreturning the only child 
of the node being visited to the father of the node and re-typing (re-blessing)
the node in the name of the production\fR (if a name was provided).
.PP
A node may have only one child at tree-construction-time for one of
two reasons.
.IP "\(bu" 4
The first occurs when the right hand side of the production
was already unary like in:
.Sp
.Vb 2
\&                           exp:
\&                               %name NUM  NUM
.Ve
.Sp
Here \- if the \f(CW\*(C`bypass\*(C'\fR clause is used \- 
the \f(CW\*(C`NUM\*(C'\fR node will be bypassed and the child \f(CW\*(C`TERMINAL\*(C'\fR built
from the information provided by the lexical analyzer will be renamed/reblessed 
as \f(CW\*(C`NUM\*(C'\fR.
.IP "\(bu" 4
Another reason for a node to be \fIbypassed\fR is  the fact that though the right
hand side of the production may have more than one symbol, 
only one of them is not a syntactic token
like in:
.Sp
.Vb 1
\&                           exp: \*(Aq(\*(Aq exp \*(Aq)\*(Aq
.Ve
.PP
A consequence of the global scope application of \f(CW\*(C`%tree bypass\*(C'\fR
is that undesired bypasses may occur like in
.PP
.Vb 2
\&                           exp : %name UMINUS
\&                                 \*(Aq\-\*(Aq $exp %prec NEG
.Ve
.PP
though the right hand side has two symbols, token \f(CW\*(Aq\-\*(Aq\fR is
a syntactic token and therefore only \f(CW\*(C`exp\*(C'\fR is left. The \fIbypass\fR
operation will be applied when building this node.
This \fIbypass\fR can be avoided applying the \f(CW\*(C`no bypass ID\*(C'\fR directive to the corresponding 
production:
.PP
.Vb 2
\&                           exp : %no bypass UMINUS
\&                                 \*(Aq\-\*(Aq $exp %prec NEG
.Ve
.PP
The following example (file \f(CW\*(C`examples/bypass.pl\*(C'\fR) 
is the equivalent of the Parse::Eyapp \f(CW\*(C`/SYNOPSIS\*(C'\fR example
but using the \f(CW\*(C`bypass\*(C'\fR clause instead:
.PP
.Vb 2
\& use Parse::Eyapp;
\& use Parse::Eyapp::Treeregexp;
\&
\& sub TERMINAL::info { $_[0]{attr} }
\& { no warnings; *VAR::info = *NUM::info = \e&TERMINAL::info; }
\&
\& my $grammar = q{
\&   %right  \*(Aq=\*(Aq     # Lowest precedence
\&   %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq 
\&   %left   \*(Aq*\*(Aq \*(Aq/\*(Aq 
\&   %left   NEG     # Disambiguate \-a\-b as (\-a)\-b and not as \-(a\-b)
\&   %tree bypass    # Let us build an abstract syntax tree ...
\&
\&   %%
\&   line: exp <%name EXPRESION_LIST + \*(Aq;\*(Aq>  { $_[1] } 
\&   ;
\&
\&   exp:
\&       %name NUM  NUM            | %name VAR   VAR         | %name ASSIGN VAR \*(Aq=\*(Aq exp
\&     | %name PLUS exp \*(Aq+\*(Aq exp    | %name MINUS exp \*(Aq\-\*(Aq exp | %name TIMES  exp \*(Aq*\*(Aq exp
\&     | %name DIV     exp \*(Aq/\*(Aq exp
\&     | %no bypass UMINUS
\&       \*(Aq\-\*(Aq $exp %prec NEG
\&     |   \*(Aq(\*(Aq exp \*(Aq)\*(Aq
\&   ;
\&
\&   %%
\&   # sub _Error, _Lexer and Run like in the synopsis example
\&   # ...
\& }; # end grammar
\&
\& our (@all, $uminus);
\&
\& Parse::Eyapp\->new_grammar( # Create the parser package/class
\&   input=>$grammar,
\&   classname=>\*(AqCalc\*(Aq, # The name of the package containing the parser
\&   firstline=>7       # String $grammar starts at line 7 (for error diagnostics)
\& );
\& my $parser = Calc\->new();                # Create a parser
\& $parser\->YYData\->{INPUT} = "a=2*\-3+b*0\en"; # Set the input
\& my $t = $parser\->Run;                    # Parse it!
\&
\& print "\en************\en".$t\->str."\en************\en";
\&
\& # Let us transform the tree. Define the tree\-regular expressions ..
\& my $p = Parse::Eyapp::Treeregexp\->new( STRING => q{
\&   { #  Example of support code
\&     my %Op = (PLUS=>\*(Aq+\*(Aq, MINUS => \*(Aq\-\*(Aq, TIMES=>\*(Aq*\*(Aq, DIV => \*(Aq/\*(Aq);
\&   }
\&   constantfold: /TIMES|PLUS|DIV|MINUS/:bin(NUM, NUM)
\&     => {
\&       my $op = $Op{ref($_[0])};
\&       $NUM[0]\->{attr} = eval  "$NUM[0]\->{attr} $op $NUM[1]\->{attr}";
\&       $_[0] = $NUM[0];
\&     }
\&   zero_times_whatever: TIMES(NUM, .) and { $NUM\->{attr} == 0 } => { $_[0] = $NUM }
\&   whatever_times_zero: TIMES(., NUM) and { $NUM\->{attr} == 0 } => { $_[0] = $NUM }
\&   uminus: UMINUS(NUM) => { $NUM\->{attr} = \-$NUM\->{attr}; $_[0] = $NUM }
\&   },
\&   OUTPUTFILE=> \*(Aqmain.pm\*(Aq
\& );
\& $p\->generate(); # Create the tranformations
\&
\& $t\->s(@all);    # constant folding and mult. by zero
\&
\& print $t\->str,"\en";
.Ve
.PP
when running this example with input \f(CW"a=2*\-3+b*0\en"\fR
we obtain the following output:
.PP
.Vb 1
\& nereida:~/src/perl/YappWithDefaultAction/examples> bypass.pl
\&
\& ************
\& EXPRESION_LIST(ASSIGN(TERMINAL[a],PLUS(TIMES(NUM[2],UMINUS(NUM[3])),TIMES(VAR[b],NUM[0]))))
\& ************
\& EXPRESION_LIST(ASSIGN(TERMINAL[a],NUM[\-6]))
.Ve
.PP
As you can see the trees are more compact when using the \f(CW\*(C`bypass\*(C'\fR directive.
.PP
\fIThe \f(CI\*(C`alias\*(C'\fI clause of the \f(CI%tree\fI directive\fR
.IX Subsection "The alias clause of the %tree directive"
.PP
Access to children in Parse::Eyapp is made through the \f(CW\*(C`child\*(C'\fR and \f(CW\*(C`children\*(C'\fR
methods.
There are occasions however where access by name to the children may be preferable.
The use of the \f(CW\*(C`alias\*(C'\fR clause with the \f(CW%tree\fR directive creates accessors
to the children with names specified by the programmer. The \fIdot and dolar notations\fR
are used for this. When dealing with a production like:
.PP
.Vb 3
\&                       A: 
\&                          %name A_Node
\&                          Node B.bum N.pum $Chip
.Ve
.PP
methods \f(CW\*(C`bum\*(C'\fR, \f(CW\*(C`pum\*(C'\fR and \f(CW\*(C`Chip\*(C'\fR will be created for the class \f(CW\*(C`A_Node\*(C'\fR.
Those methods wil provide access to the respective child (first, second and third in
the example). The methods are build at compile-time and therefore later 
transformations of the \s-1AST\s0 modifying the order of the children may 
invalidate the use of these getter-setters.
.PP
As an example, the \s-1CPAN\s0 module Language::AttributeGrammar provides
\&\s-1AST\s0 decorators from an attribute grammar specification of the \s-1AST.\s0
To work  Language::AttributeGrammar requires named access to the children
of the \s-1AST\s0 nodes. Follows an example (file \f(CW\*(C`examples/CalcwithAttributeGrammar.pl\*(C'\fR)
of a small calculator:
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n CalcwithAttributeGrammar.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Parse::Eyapp;
\&     4  use Data::Dumper;
\&     5  use Language::AttributeGrammar;
\&     6
\&     7  my $grammar = q{
\&     8  %{
\&     9  # use Data::Dumper;
\&    10  %}
\&    11  %right  \*(Aq=\*(Aq
\&    12  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    13  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    14  %left   NEG
\&    15  %tree bypass alias
\&    16
\&    17  %%
\&    18  line: $exp  { $_[1] }
\&    19  ;
\&    20
\&    21  exp:
\&    22      %name NUM
\&    23            $NUM
\&    24          | %name VAR
\&    25            $VAR
\&    26          | %name ASSIGN
\&    27            $VAR \*(Aq=\*(Aq $exp
\&    28          | %name PLUS
\&    29            exp.left \*(Aq+\*(Aq exp.right
\&    30          | %name MINUS
\&    31            exp.left \*(Aq\-\*(Aq exp.right
\&    32          | %name TIMES
\&    33            exp.left \*(Aq*\*(Aq exp.right
\&    34          | %name DIV
\&    35            exp.left \*(Aq/\*(Aq exp.right
\&    36          | %no bypass UMINUS
\&    37            \*(Aq\-\*(Aq $exp %prec NEG
\&    38    |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq  { $_[2] } /* Let us simplify a bit the tree */
\&    39  ;
\&    40
\&    41  %%
\&    42
\&    43  sub _Error {
\&    44          exists $_[0]\->YYData\->{ERRMSG}
\&    45      and do {
\&    46          print $_[0]\->YYData\->{ERRMSG};
\&    47          delete $_[0]\->YYData\->{ERRMSG};
\&    48          return;
\&    49      };
\&    50      print "Syntax error.\en";
\&    51  }
\&    52
\&    53  sub _Lexer {
\&    54      my($parser)=shift;
\&    55
\&    56          $parser\->YYData\->{INPUT}
\&    57      or  $parser\->YYData\->{INPUT} = <STDIN>
\&    58      or  return(\*(Aq\*(Aq,undef);
\&    59
\&    60      $parser\->YYData\->{INPUT}=~s/^\es+//;
\&    61
\&    62      for ($parser\->YYData\->{INPUT}) {
\&    63          s/^([0\-9]+(?:\e.[0\-9]+)?)//
\&    64                  and return(\*(AqNUM\*(Aq,$1);
\&    65          s/^([A\-Za\-z][A\-Za\-z0\-9_]*)//
\&    66                  and return(\*(AqVAR\*(Aq,$1);
\&    67          s/^(.)//s
\&    68                  and return($1,$1);
\&    69      }
\&    70  }
\&    71
\&    72  sub Run {
\&    73      my($self)=shift;
\&    74      $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error,
\&    75                      #yydebug =>0xFF
\&    76                    );
\&    77  }
\&    78  }; # end grammar
\&    79
\&    80
\&    81  $Data::Dumper::Indent = 1;
\&    82  Parse::Eyapp\->new_grammar(
\&    83    input=>$grammar,
\&    84    classname=>\*(AqRule6\*(Aq,
\&    85    firstline =>7,
\&    86    outputfile => \*(AqCalc.pm\*(Aq,
\&    87  );
\&    88  my $parser = Rule6\->new();
\&    89  $parser\->YYData\->{INPUT} = "a = \-(2*3+5\-1)\en";
\&    90  my $t = $parser\->Run;
\&    91  print "\en***** Before ******\en";
\&    92  print Dumper($t);
\&    93
\&    94  my $attgram = new Language::AttributeGrammar <<\*(AqEOG\*(Aq;
\&    95
\&    96  # Compute the expression
\&    97  NUM:    $/.val = { $<attr> }
\&    98  TIMES:  $/.val = { $<left>.val * $<right>.val }
\&    99  PLUS:   $/.val = { $<left>.val + $<right>.val }
\&   100  MINUS:  $/.val = { $<left>.val \- $<right>.val }
\&   101  UMINUS: $/.val = { \-$<exp>.val }
\&   102  ASSIGN: $/.val = { $<exp>.val }
\&   103  EOG
\&   104
\&   105  my $res = $attgram\->apply($t, \*(Aqval\*(Aq);
\&   106
\&   107  $Data::Dumper::Indent = 1;
\&   108  print "\en***** After ******\en";
\&   109  print Dumper($t);
\&   110  print Dumper($res);
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debugingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/MatchingTrees.pdf>
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1),
.IP "\(bu" 4
Man pages of \fIbison\fR\|(1),
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Special thanks to 
my family and Larry Wall.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 1804:" 4
.IX Item "Around line 1804:"
Non-ASCII character seen before =encoding in 'va\*'lida\en";'. Assuming \s-1UTF\-8\s0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::translationschemestut.3pm      0100644 0001750 0001750 00000052127 12566242261 030313  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::translationschemestut 3"
.TH Parse::Eyapp::translationschemestut 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::translationschemestut \- Introduction to Translation Schemes in Eyapp
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
A \fItranslation scheme\fR 
scheme is a context free grammar where the right hand sides of the productions 
have been augmented with semantic actions (i.e. with chunks of Perl code):
.PP
.Vb 1
\&                                A \-> alpha { action(@_) } beta
.Ve
.PP
The analyzer generated by \f(CW\*(C`Parse::Eyapp\*(C'\fR executes \f(CW\*(C`action()\*(C'\fR after all the semantic actions
associated with \f(CW\*(C`alpha\*(C'\fR have been executed and before the execution of any of the semantic 
actions associated with \f(CW\*(C`beta\*(C'\fR.
.PP
In a translation scheme the embedded actions modify the attributes
associated with the symbols of the grammar.
.PP
.Vb 1
\&                                A \-> alpha { action(@_) } beta
.Ve
.PP
\&\fIeach symbol on the right hand side
of a production rule has an associated scalar attribute\fR. In ordinary \f(CW\*(C`eyapp\*(C'\fR 
programs the attributes of the symbol
to the left of \f(CW\*(C`action\*(C'\fR are passed as arguments to \f(CW\*(C`action\*(C'\fR (in the example, those of \f(CW\*(C`alpha\*(C'\fR). 
These arguments are preceded by a reference to the syntax analyzer object.
There is no way inside an ordinary \f(CW\*(C`eyapp\*(C'\fR program for an intermediate \f(CW\*(C`action\*(C'\fR to 
access the attributes of the symbols
on its right, i.e. those associated with the symbols of \f(CW\*(C`beta\*(C'\fR. This restriction is lifted 
if you  use the \f(CW%metatree\fR directive.
.PP
Eyapp allows through the \f(CW%metatree\fR directive
the creation of \fITranslation Schemes\fR where the actions have access to 
almost any node of the syntax tree.
.PP
When using the \f(CW%metatree\fR directive semantic actions aren't immediately executed. Instead they are 
inserted as nodes of the syntax tree. The main difference with ordinary nodes
being that the attribute of such a \f(CW\*(C`CODE\*(C'\fR node is a reference to the anonymous 
subroutine representing the semantic action.
The tree is later traversed in depth-first order using the \f(CW\*(C`$t\->translation_scheme\*(C'\fR
method: each time a \f(CW\*(C`CODE\*(C'\fR node
is visited  the action is executed.
.PP
The following example parses a tiny subset of a typical
\&\fItyped language\fR and decorates the syntax tree with a new 
attribute \f(CW\*(C`t\*(C'\fR holding the type of each declared variable:
.PP
.Vb 4
\& use strict; # File examples/trans_scheme_simple_decls4.pl
\& use Data::Dumper;
\& use Parse::Eyapp;
\& our %s; # symbol table
\&
\& my $ts = q{ 
\&   %token FLOAT INTEGER NAME
\&
\&   %{
\&   our %s;
\&   %}
\&
\&   %metatree
\&
\&   %%
\&   Dl:  D <* \*(Aq;\*(Aq>
\&   ;
\&
\&   D : $T { $L\->{t} = $T\->{t} } $L
\&   ;
\&
\&   T : FLOAT    { $lhs\->{t} = "FLOAT" }
\&     | INTEGER  { $lhs\->{t} = "INTEGER" }
\&   ;
\&
\&   L : $NAME
\&         { $NAME\->{t} = $lhs\->{t}; $s{$NAME\->{attr}} = $NAME }
\&     | $NAME { $NAME\->{t} = $lhs\->{t}; $L\->{t} = $lhs\->{t} } \*(Aq,\*(Aq $L
\&         { $s{$NAME\->{attr}} = $NAME }
\&   ;
\&   %%
\& }; # end $ts
\&
\& sub Error { die "Error sinta\*'ctico\en"; }
\&
\& { # Closure of $input, %reserved_words and $validchars
\&   my $input = "";
\&   my %reserved_words = ();
\&   my $validchars = "";
\&
\&   sub parametrize_\|_scanner {
\&     $input = shift;
\&     %reserved_words = %{shift()};
\&     $validchars = shift;
\&   }
\&
\&   sub scanner {
\&     $input =~ m{\eG\es+}gc;                     # skip whites
\&     if ($input =~ m{\eG([a\-z_A_Z]\ew*)\eb}gc) {
\&       my $w = uc($1);                 # upper case the word
\&       return ($w, $w) if exists $reserved_words{$w};
\&       return (\*(AqNAME\*(Aq, $1);            # not a reserved word
\&     }
\&     return ($1, $1) if ($input =~ m/\eG([$validchars])/gc);
\&     die "Not valid token: $1\en" if ($input =~ m/\eG(\eS)/gc);
\&     return (\*(Aq\*(Aq, undef); # end of file
\&   }
\& } # end closure
\&
\& Parse::Eyapp\->new_grammar(input=>$ts,classname=>\*(Aqmain\*(Aq,outputfile=>\*(AqTypes.pm\*(Aq);
\& my $parser = main\->new(yylex => \e&scanner, yyerror => \e&Error); 
\&
\& parametrize_\|_scanner(
\&   "float x,y;\eninteger a,b\en",
\&   { INTEGER => \*(AqINTEGER\*(Aq, FLOAT => \*(AqFLOAT\*(Aq},
\&   ",;"
\& );
\&
\& my $t = $parser\->YYParse() or die "Syntax Error analyzing input";
\&
\& $t\->translation_scheme;
\&
\& $Data::Dumper::Indent = 1;
\& $Data::Dumper::Terse = 1;
\& $Data::Dumper::Deepcopy  = 1;
\& $Data::Dumper::Deparse = 1;
\& print Dumper($t);
\& print Dumper(\e%s);
.Ve
.PP
Inside a Translation Scheme the lexical variable \f(CW$lhs\fR refers to the attribute
of the father.
.SH "EXECUTION STAGES OF A TRANSLATION SCHEME"
.IX Header "EXECUTION STAGES OF A TRANSLATION SCHEME"
The execution of a Translation Scheme can be divided in the following stages:
.IP "1. During the first stage the grammar is analyzed and the parser is built:" 4
.IX Item "1. During the first stage the grammar is analyzed and the parser is built:"
.Vb 1
\& Parse::Eyapp\->new_grammar(input=>$ts,classname=>\*(Aqmain\*(Aq,outputfile=>\*(AqTypes.pm\*(Aq);
.Ve
.Sp
This stage is called \fIClass Construction Time\fR
.IP "2. A parser conforming to the generated grammar is built" 4
.IX Item "2. A parser conforming to the generated grammar is built"
.Vb 1
\&  my $parser = main\->new(yylex => \e&scanner, yyerror => \e&Error);
.Ve
.Sp
This stage is called  \fIParser Construction Time\fR
.IP "3. The next phase is \fITree construction time\fR. The input is set and the tree is built:" 4
.IX Item "3. The next phase is Tree construction time. The input is set and the tree is built:"
.Vb 5
\& parametrize_\|_scanner(
\&    "float x,y;\eninteger a,b\en",
\&    { INTEGER => \*(AqINTEGER\*(Aq, FLOAT => \*(AqFLOAT\*(Aq},
\&    ",;"
\&  );
\&
\&  my $t = $parser\->YYParse() or die "Syntax Error analyzing input";
.Ve
.ie n .IP "4. The last stage is \fIExecution Time\fR. The tree is traversed in depth first order and the ""CODE"" nodes are executed." 4
.el .IP "4. The last stage is \fIExecution Time\fR. The tree is traversed in depth first order and the \f(CWCODE\fR nodes are executed." 4
.IX Item "4. The last stage is Execution Time. The tree is traversed in depth first order and the CODE nodes are executed."
.Vb 1
\&                           $t\->translation_scheme;
.Ve
.PP
This combination of bottom-up parsing with depth first traversing
leads to a semantic behavior similar to recursive top-down parsers
but with two advantages:
.IP "\(bu" 4
The grammar can be left-recursive
.IP "\(bu" 4
At the time of executing the action the syntax tree is already built, therefore we can refer
to nodes on the right side of the action like in:
.Sp
.Vb 1
\&                      D : $T { $L\->{t} = $T\->{t} } $L
.Ve
.ie n .SH "THE %begin DIRECTIVE"
.el .SH "THE \f(CW%begin\fP DIRECTIVE"
.IX Header "THE %begin DIRECTIVE"
The \f(CW\*(C`%begin { code }\*(C'\fR directive  can be used when
building a translation scheme, i.e. when under the 
control of the \f(CW%metatree\fR directive.
It indicates that such \f(CW\*(C`{ code }\*(C'\fR will be executed at \fItree
construction time\fR. Therefore the code receives as arguments
the references to the nodes of the branch than is being built.
Usually \fIbegin code\fR assist in the construction of the tree.
Line 39 of the following code shows an example.
The action \f(CW\*(C`{ $exp }\*(C'\fR simplifies the syntax tree
bypassing the parenthesis node. The example also illustrates
the combined use of default actions and 
translation schemes.
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n trans_scheme_default_action.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Data::Dumper;
\&     4  use Parse::Eyapp;
\&     5  use IO::Interactive qw(is_interactive);
\&     6
\&     7  my $translationscheme = q{
\&     8  %{
\&     9  # head code is available at tree construction time
\&    10  use Data::Dumper;
\&    11  our %sym; # symbol table
\&    12  %}
\&    13
\&    14  %defaultaction {
\&    15     $lhs\->{n} = eval " $left\->{n} $_[2]\->{attr} $right\->{n} "
\&    16  }
\&    17
\&    18  %metatree
\&    19
\&    20  %right   \*(Aq=\*(Aq
\&    21  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    22  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    23
\&    24  %%
\&    25  line:       %name EXP
\&    26                exp <+ \*(Aq;\*(Aq> /* Expressions separated by semicolons */
\&    27                  { $lhs\->{n} = $_[1]\->Last_child\->{n} }
\&    28  ;
\&    29
\&    30  exp:
\&    31              %name PLUS
\&    32                exp.left \*(Aq+\*(Aq exp.right
\&    33          |   %name MINUS
\&    34                exp.left \*(Aq\-\*(Aq exp.right
\&    35          |   %name TIMES
\&    36                exp.left \*(Aq*\*(Aq exp.right
\&    37          |   %name DIV
\&    38                exp.left \*(Aq/\*(Aq exp.right
\&    39          |   %name NUM
\&    40                $NUM
\&    41                  { $lhs\->{n} = $NUM\->{attr} }
\&    42          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq  %begin { $exp }
\&    43          |   %name VAR
\&    44                $VAR
\&    45                  { $lhs\->{n} = $sym{$VAR\->{attr}}\->{n} }
\&    46          |   %name ASSIGN
\&    47                $VAR \*(Aq=\*(Aq $exp
\&    48                  { $lhs\->{n} = $sym{$VAR\->{attr}}\->{n} = $exp\->{n} }
\&    49
\&    50  ;
\&    51
\&    52  %%
\&    53  # tail code is available at tree construction time
\&    54  sub _Error {
\&    55    die "Syntax error.\en";
\&    56  }
\&    57
\&    58  sub _Lexer {
\&    59      my($parser)=shift;
\&    60
\&    61      for ($parser\->YYData\->{INPUT}) {
\&    62          s/^\es+//;
\&    63          $_ or  return(\*(Aq\*(Aq,undef);
\&    64          s/^([0\-9]+(?:\e.[0\-9]+)?)// and return(\*(AqNUM\*(Aq,$1);
\&    65          s/^([A\-Za\-z][A\-Za\-z0\-9_]*)// and return(\*(AqVAR\*(Aq,$1);
\&    66          s/^(.)// and return($1,$1);
\&    67      }
\&    68      return(\*(Aq\*(Aq,undef);
\&    69  }
\&    70
\&    71  sub Run {
\&    72      my($self)=shift;
\&    73      return $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error );
\&    74  }
\&    75  }; # end translation scheme
\&    76
\&    77  sub TERMINAL::info { $_[0]\->attr }
\&    78
\&    79  my $p = Parse::Eyapp\->new_grammar(
\&    80    input=>$translationscheme,
\&    81    classname=>\*(Aqmain\*(Aq,
\&    82    firstline => 6,
\&    83    outputfile => \*(Aqmain.pm\*(Aq);
\&    84  die $p\->qtables() if $p\->Warnings;
\&    85  my $parser = main\->new();
\&    86  print "Write a sequence of arithmetic expressions: " if is_interactive();
\&    87  $parser\->YYData\->{INPUT} = <>;
\&    88  my $t = $parser\->Run() or die "Syntax Error analyzing input";
\&    89  $t\->translation_scheme;
\&    90
\&    91  $Parse::Eyapp::Node::INDENT = 2;
\&    92  my $treestring = $t\->str;
\&    93
\&    94  $Data::Dumper::Indent = 1;
\&    95  $Data::Dumper::Terse = 1;
\&    96  $Data::Dumper::Deepcopy  = 1;
\&    97  our %sym;
\&    98  my $symboltable = Dumper(\e%sym);
\&    99
\&   100  print <<"EOR";
\&   101  ***********Tree*************
\&   102  $treestring
\&   103  ******Symbol table**********
\&   104  $symboltable
\&   105  ************Result**********
\&   106  $t\->{n}
\&   107
\&   108  EOR
.Ve
.PP
When executed with input \f(CW\*(C`a=2*3;b=a*a\*(C'\fR
the program produces an output similar to this:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples$ trans_scheme_default_action.pl
\&  Write a sequence of arithmetic expressions: a=2*3;b=a*a
\&  ***********Tree*************
\&
\&  EXP(
\&    _PLUS_LIST(
\&      ASSIGN(
\&        TERMINAL[a],
\&        TERMINAL[=],
\&        TIMES(
\&          NUM(TERMINAL[2], CODE),
\&          TERMINAL[*],
\&          NUM(TERMINAL[3], CODE),
\&          CODE
\&        ) # TIMES,
\&        CODE
\&      ) # ASSIGN,
\&      ASSIGN(
\&        TERMINAL[b],
\&        TERMINAL[=],
\&        TIMES(
\&          VAR(TERMINAL[a], CODE),
\&          TERMINAL[*],
\&          VAR(TERMINAL[a], CODE),
\&          CODE
\&        ) # TIMES,
\&        CODE
\&      ) # ASSIGN
\&    ) # _PLUS_LIST,
\&    CODE
\&  ) # EXP
\&  ******Symbol table**********
\&  {
\&    \*(Aqa\*(Aq => {
\&      \*(Aqn\*(Aq => 6
\&    },
\&    \*(Aqb\*(Aq => {
\&      \*(Aqn\*(Aq => 36
\&    }
\&  }
\&
\&  ************Result**********
\&  36
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 81:" 4
.IX Item "Around line 81:"
Non-ASCII character seen before =encoding in 'sinta\*'ctico\en";'. Assuming \s-1UTF\-8\s0
                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::translationschemestut5.16.3pm  0100644 0001750 0001750 00000051446 12566242264 030633  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::translationschemestut 3"
.TH Parse::Eyapp::translationschemestut 3 "2012-03-23" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::translationschemestut \- Introduction to Translation Schemes in Eyapp
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
A \fItranslation scheme\fR 
scheme is a context free grammar where the right hand sides of the productions 
have been augmented with semantic actions (i.e. with chunks of Perl code):
.PP
.Vb 1
\&                                A \-> alpha { action(@_) } beta
.Ve
.PP
The analyzer generated by \f(CW\*(C`Parse::Eyapp\*(C'\fR executes \f(CW\*(C`action()\*(C'\fR after all the semantic actions
associated with \f(CW\*(C`alpha\*(C'\fR have been executed and before the execution of any of the semantic 
actions associated with \f(CW\*(C`beta\*(C'\fR.
.PP
In a translation scheme the embedded actions modify the attributes
associated with the symbols of the grammar.
.PP
.Vb 1
\&                                A \-> alpha { action(@_) } beta
.Ve
.PP
\&\fIeach symbol on the right hand side
of a production rule has an associated scalar attribute\fR. In ordinary \f(CW\*(C`eyapp\*(C'\fR 
programs the attributes of the symbol
to the left of \f(CW\*(C`action\*(C'\fR are passed as arguments to \f(CW\*(C`action\*(C'\fR (in the example, those of \f(CW\*(C`alpha\*(C'\fR). 
These arguments are preceded by a reference to the syntax analyzer object.
There is no way inside an ordinary \f(CW\*(C`eyapp\*(C'\fR program for an intermediate \f(CW\*(C`action\*(C'\fR to 
access the attributes of the symbols
on its right, i.e. those associated with the symbols of \f(CW\*(C`beta\*(C'\fR. This restriction is lifted 
if you  use the \f(CW%metatree\fR directive.
.PP
Eyapp allows through the \f(CW%metatree\fR directive
the creation of \fITranslation Schemes\fR where the actions have access to 
almost any node of the syntax tree.
.PP
When using the \f(CW%metatree\fR directive semantic actions aren't immediately executed. Instead they are 
inserted as nodes of the syntax tree. The main difference with ordinary nodes
being that the attribute of such a \f(CW\*(C`CODE\*(C'\fR node is a reference to the anonymous 
subroutine representing the semantic action.
The tree is later traversed in depth-first order using the \f(CW\*(C`$t\->translation_scheme\*(C'\fR
method: each time a \f(CW\*(C`CODE\*(C'\fR node
is visited  the action is executed.
.PP
The following example parses a tiny subset of a typical
\&\fItyped language\fR and decorates the syntax tree with a new 
attribute \f(CW\*(C`t\*(C'\fR holding the type of each declared variable:
.PP
.Vb 4
\& use strict; # File examples/trans_scheme_simple_decls4.pl
\& use Data::Dumper;
\& use Parse::Eyapp;
\& our %s; # symbol table
\&
\& my $ts = q{ 
\&   %token FLOAT INTEGER NAME
\&
\&   %{
\&   our %s;
\&   %}
\&
\&   %metatree
\&
\&   %%
\&   Dl:  D <* \*(Aq;\*(Aq>
\&   ;
\&
\&   D : $T { $L\->{t} = $T\->{t} } $L
\&   ;
\&
\&   T : FLOAT    { $lhs\->{t} = "FLOAT" }
\&     | INTEGER  { $lhs\->{t} = "INTEGER" }
\&   ;
\&
\&   L : $NAME
\&         { $NAME\->{t} = $lhs\->{t}; $s{$NAME\->{attr}} = $NAME }
\&     | $NAME { $NAME\->{t} = $lhs\->{t}; $L\->{t} = $lhs\->{t} } \*(Aq,\*(Aq $L
\&         { $s{$NAME\->{attr}} = $NAME }
\&   ;
\&   %%
\& }; # end $ts
\&
\& sub Error { die "Error sintA\*~Xctico\en"; }
\&
\& { # Closure of $input, %reserved_words and $validchars
\&   my $input = "";
\&   my %reserved_words = ();
\&   my $validchars = "";
\&
\&   sub parametrize_\|_scanner {
\&     $input = shift;
\&     %reserved_words = %{shift()};
\&     $validchars = shift;
\&   }
\&
\&   sub scanner {
\&     $input =~ m{\eG\es+}gc;                     # skip whites
\&     if ($input =~ m{\eG([a\-z_A_Z]\ew*)\eb}gc) {
\&       my $w = uc($1);                 # upper case the word
\&       return ($w, $w) if exists $reserved_words{$w};
\&       return (\*(AqNAME\*(Aq, $1);            # not a reserved word
\&     }
\&     return ($1, $1) if ($input =~ m/\eG([$validchars])/gc);
\&     die "Not valid token: $1\en" if ($input =~ m/\eG(\eS)/gc);
\&     return (\*(Aq\*(Aq, undef); # end of file
\&   }
\& } # end closure
\&
\& Parse::Eyapp\->new_grammar(input=>$ts,classname=>\*(Aqmain\*(Aq,outputfile=>\*(AqTypes.pm\*(Aq);
\& my $parser = main\->new(yylex => \e&scanner, yyerror => \e&Error); 
\&
\& parametrize_\|_scanner(
\&   "float x,y;\eninteger a,b\en",
\&   { INTEGER => \*(AqINTEGER\*(Aq, FLOAT => \*(AqFLOAT\*(Aq},
\&   ",;"
\& );
\&
\& my $t = $parser\->YYParse() or die "Syntax Error analyzing input";
\&
\& $t\->translation_scheme;
\&
\& $Data::Dumper::Indent = 1;
\& $Data::Dumper::Terse = 1;
\& $Data::Dumper::Deepcopy  = 1;
\& $Data::Dumper::Deparse = 1;
\& print Dumper($t);
\& print Dumper(\e%s);
.Ve
.PP
Inside a Translation Scheme the lexical variable \f(CW$lhs\fR refers to the attribute
of the father.
.SH "EXECUTION STAGES OF A TRANSLATION SCHEME"
.IX Header "EXECUTION STAGES OF A TRANSLATION SCHEME"
The execution of a Translation Scheme can be divided in the following stages:
.IP "1. During the first stage the grammar is analyzed and the parser is built:" 4
.IX Item "1. During the first stage the grammar is analyzed and the parser is built:"
.Vb 1
\& Parse::Eyapp\->new_grammar(input=>$ts,classname=>\*(Aqmain\*(Aq,outputfile=>\*(AqTypes.pm\*(Aq);
.Ve
.Sp
This stage is called \fIClass Construction Time\fR
.IP "2. A parser conforming to the generated grammar is built" 4
.IX Item "2. A parser conforming to the generated grammar is built"
.Vb 1
\&  my $parser = main\->new(yylex => \e&scanner, yyerror => \e&Error);
.Ve
.Sp
This stage is called  \fIParser Construction Time\fR
.IP "3. The next phase is \fITree construction time\fR. The input is set and the tree is built:" 4
.IX Item "3. The next phase is Tree construction time. The input is set and the tree is built:"
.Vb 5
\& parametrize_\|_scanner(
\&    "float x,y;\eninteger a,b\en",
\&    { INTEGER => \*(AqINTEGER\*(Aq, FLOAT => \*(AqFLOAT\*(Aq},
\&    ",;"
\&  );
\&
\&  my $t = $parser\->YYParse() or die "Syntax Error analyzing input";
.Ve
.ie n .IP "4. The last stage is \fIExecution Time\fR. The tree is traversed in depth first order and the ""CODE"" nodes are executed." 4
.el .IP "4. The last stage is \fIExecution Time\fR. The tree is traversed in depth first order and the \f(CWCODE\fR nodes are executed." 4
.IX Item "4. The last stage is Execution Time. The tree is traversed in depth first order and the CODE nodes are executed."
.Vb 1
\&                           $t\->translation_scheme;
.Ve
.PP
This combination of bottom-up parsing with depth first traversing
leads to a semantic behavior similar to recursive top-down parsers
but with two advantages:
.IP "\(bu" 4
The grammar can be left-recursive
.IP "\(bu" 4
At the time of executing the action the syntax tree is already built, therefore we can refer
to nodes on the right side of the action like in:
.Sp
.Vb 1
\&                      D : $T { $L\->{t} = $T\->{t} } $L
.Ve
.ie n .SH "THE %begin DIRECTIVE"
.el .SH "THE \f(CW%begin\fP DIRECTIVE"
.IX Header "THE %begin DIRECTIVE"
The \f(CW\*(C`%begin { code }\*(C'\fR directive  can be used when
building a translation scheme, i.e. when under the 
control of the \f(CW%metatree\fR directive.
It indicates that such \f(CW\*(C`{ code }\*(C'\fR will be executed at \fItree
construction time\fR. Therefore the code receives as arguments
the references to the nodes of the branch than is being built.
Usually \fIbegin code\fR assist in the construction of the tree.
Line 39 of the following code shows an example.
The action \f(CW\*(C`{ $exp }\*(C'\fR simplifies the syntax tree
bypassing the parenthesis node. The example also illustrates
the combined use of default actions and 
translation schemes.
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n trans_scheme_default_action.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Data::Dumper;
\&     4  use Parse::Eyapp;
\&     5  use IO::Interactive qw(is_interactive);
\&     6
\&     7  my $translationscheme = q{
\&     8  %{
\&     9  # head code is available at tree construction time
\&    10  use Data::Dumper;
\&    11  our %sym; # symbol table
\&    12  %}
\&    13
\&    14  %defaultaction {
\&    15     $lhs\->{n} = eval " $left\->{n} $_[2]\->{attr} $right\->{n} "
\&    16  }
\&    17
\&    18  %metatree
\&    19
\&    20  %right   \*(Aq=\*(Aq
\&    21  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    22  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    23
\&    24  %%
\&    25  line:       %name EXP
\&    26                exp <+ \*(Aq;\*(Aq> /* Expressions separated by semicolons */
\&    27                  { $lhs\->{n} = $_[1]\->Last_child\->{n} }
\&    28  ;
\&    29
\&    30  exp:
\&    31              %name PLUS
\&    32                exp.left \*(Aq+\*(Aq exp.right
\&    33          |   %name MINUS
\&    34                exp.left \*(Aq\-\*(Aq exp.right
\&    35          |   %name TIMES
\&    36                exp.left \*(Aq*\*(Aq exp.right
\&    37          |   %name DIV
\&    38                exp.left \*(Aq/\*(Aq exp.right
\&    39          |   %name NUM
\&    40                $NUM
\&    41                  { $lhs\->{n} = $NUM\->{attr} }
\&    42          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq  %begin { $exp }
\&    43          |   %name VAR
\&    44                $VAR
\&    45                  { $lhs\->{n} = $sym{$VAR\->{attr}}\->{n} }
\&    46          |   %name ASSIGN
\&    47                $VAR \*(Aq=\*(Aq $exp
\&    48                  { $lhs\->{n} = $sym{$VAR\->{attr}}\->{n} = $exp\->{n} }
\&    49
\&    50  ;
\&    51
\&    52  %%
\&    53  # tail code is available at tree construction time
\&    54  sub _Error {
\&    55    die "Syntax error.\en";
\&    56  }
\&    57
\&    58  sub _Lexer {
\&    59      my($parser)=shift;
\&    60
\&    61      for ($parser\->YYData\->{INPUT}) {
\&    62          s/^\es+//;
\&    63          $_ or  return(\*(Aq\*(Aq,undef);
\&    64          s/^([0\-9]+(?:\e.[0\-9]+)?)// and return(\*(AqNUM\*(Aq,$1);
\&    65          s/^([A\-Za\-z][A\-Za\-z0\-9_]*)// and return(\*(AqVAR\*(Aq,$1);
\&    66          s/^(.)// and return($1,$1);
\&    67      }
\&    68      return(\*(Aq\*(Aq,undef);
\&    69  }
\&    70
\&    71  sub Run {
\&    72      my($self)=shift;
\&    73      return $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error );
\&    74  }
\&    75  }; # end translation scheme
\&    76
\&    77  sub TERMINAL::info { $_[0]\->attr }
\&    78
\&    79  my $p = Parse::Eyapp\->new_grammar(
\&    80    input=>$translationscheme,
\&    81    classname=>\*(Aqmain\*(Aq,
\&    82    firstline => 6,
\&    83    outputfile => \*(Aqmain.pm\*(Aq);
\&    84  die $p\->qtables() if $p\->Warnings;
\&    85  my $parser = main\->new();
\&    86  print "Write a sequence of arithmetic expressions: " if is_interactive();
\&    87  $parser\->YYData\->{INPUT} = <>;
\&    88  my $t = $parser\->Run() or die "Syntax Error analyzing input";
\&    89  $t\->translation_scheme;
\&    90
\&    91  $Parse::Eyapp::Node::INDENT = 2;
\&    92  my $treestring = $t\->str;
\&    93
\&    94  $Data::Dumper::Indent = 1;
\&    95  $Data::Dumper::Terse = 1;
\&    96  $Data::Dumper::Deepcopy  = 1;
\&    97  our %sym;
\&    98  my $symboltable = Dumper(\e%sym);
\&    99
\&   100  print <<"EOR";
\&   101  ***********Tree*************
\&   102  $treestring
\&   103  ******Symbol table**********
\&   104  $symboltable
\&   105  ************Result**********
\&   106  $t\->{n}
\&   107
\&   108  EOR
.Ve
.PP
When executed with input \f(CW\*(C`a=2*3;b=a*a\*(C'\fR
the program produces an output similar to this:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples$ trans_scheme_default_action.pl
\&  Write a sequence of arithmetic expressions: a=2*3;b=a*a
\&  ***********Tree*************
\&
\&  EXP(
\&    _PLUS_LIST(
\&      ASSIGN(
\&        TERMINAL[a],
\&        TERMINAL[=],
\&        TIMES(
\&          NUM(TERMINAL[2], CODE),
\&          TERMINAL[*],
\&          NUM(TERMINAL[3], CODE),
\&          CODE
\&        ) # TIMES,
\&        CODE
\&      ) # ASSIGN,
\&      ASSIGN(
\&        TERMINAL[b],
\&        TERMINAL[=],
\&        TIMES(
\&          VAR(TERMINAL[a], CODE),
\&          TERMINAL[*],
\&          VAR(TERMINAL[a], CODE),
\&          CODE
\&        ) # TIMES,
\&        CODE
\&      ) # ASSIGN
\&    ) # _PLUS_LIST,
\&    CODE
\&  ) # EXP
\&  ******Symbol table**********
\&  {
\&    \*(Aqa\*(Aq => {
\&      \*(Aqn\*(Aq => 6
\&    },
\&    \*(Aqb\*(Aq => {
\&      \*(Aqn\*(Aq => 36
\&    }
\&  }
\&
\&  ************Result**********
\&  36
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at http://code.google.com/p/parse\-eyapp/ <http://code.google.com/p/parse-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html <http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/ocamlyacc-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE\s0 (\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04\s0
(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601\s0
(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\s0\*(R" in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.
                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Eyapp::translationschemestut5.18.3pm  0100644 0001750 0001750 00000052127 12566242261 030627  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Eyapp::translationschemestut 3"
.TH Parse::Eyapp::translationschemestut 3 "2012-03-23" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Eyapp::translationschemestut \- Introduction to Translation Schemes in Eyapp
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
A \fItranslation scheme\fR 
scheme is a context free grammar where the right hand sides of the productions 
have been augmented with semantic actions (i.e. with chunks of Perl code):
.PP
.Vb 1
\&                                A \-> alpha { action(@_) } beta
.Ve
.PP
The analyzer generated by \f(CW\*(C`Parse::Eyapp\*(C'\fR executes \f(CW\*(C`action()\*(C'\fR after all the semantic actions
associated with \f(CW\*(C`alpha\*(C'\fR have been executed and before the execution of any of the semantic 
actions associated with \f(CW\*(C`beta\*(C'\fR.
.PP
In a translation scheme the embedded actions modify the attributes
associated with the symbols of the grammar.
.PP
.Vb 1
\&                                A \-> alpha { action(@_) } beta
.Ve
.PP
\&\fIeach symbol on the right hand side
of a production rule has an associated scalar attribute\fR. In ordinary \f(CW\*(C`eyapp\*(C'\fR 
programs the attributes of the symbol
to the left of \f(CW\*(C`action\*(C'\fR are passed as arguments to \f(CW\*(C`action\*(C'\fR (in the example, those of \f(CW\*(C`alpha\*(C'\fR). 
These arguments are preceded by a reference to the syntax analyzer object.
There is no way inside an ordinary \f(CW\*(C`eyapp\*(C'\fR program for an intermediate \f(CW\*(C`action\*(C'\fR to 
access the attributes of the symbols
on its right, i.e. those associated with the symbols of \f(CW\*(C`beta\*(C'\fR. This restriction is lifted 
if you  use the \f(CW%metatree\fR directive.
.PP
Eyapp allows through the \f(CW%metatree\fR directive
the creation of \fITranslation Schemes\fR where the actions have access to 
almost any node of the syntax tree.
.PP
When using the \f(CW%metatree\fR directive semantic actions aren't immediately executed. Instead they are 
inserted as nodes of the syntax tree. The main difference with ordinary nodes
being that the attribute of such a \f(CW\*(C`CODE\*(C'\fR node is a reference to the anonymous 
subroutine representing the semantic action.
The tree is later traversed in depth-first order using the \f(CW\*(C`$t\->translation_scheme\*(C'\fR
method: each time a \f(CW\*(C`CODE\*(C'\fR node
is visited  the action is executed.
.PP
The following example parses a tiny subset of a typical
\&\fItyped language\fR and decorates the syntax tree with a new 
attribute \f(CW\*(C`t\*(C'\fR holding the type of each declared variable:
.PP
.Vb 4
\& use strict; # File examples/trans_scheme_simple_decls4.pl
\& use Data::Dumper;
\& use Parse::Eyapp;
\& our %s; # symbol table
\&
\& my $ts = q{ 
\&   %token FLOAT INTEGER NAME
\&
\&   %{
\&   our %s;
\&   %}
\&
\&   %metatree
\&
\&   %%
\&   Dl:  D <* \*(Aq;\*(Aq>
\&   ;
\&
\&   D : $T { $L\->{t} = $T\->{t} } $L
\&   ;
\&
\&   T : FLOAT    { $lhs\->{t} = "FLOAT" }
\&     | INTEGER  { $lhs\->{t} = "INTEGER" }
\&   ;
\&
\&   L : $NAME
\&         { $NAME\->{t} = $lhs\->{t}; $s{$NAME\->{attr}} = $NAME }
\&     | $NAME { $NAME\->{t} = $lhs\->{t}; $L\->{t} = $lhs\->{t} } \*(Aq,\*(Aq $L
\&         { $s{$NAME\->{attr}} = $NAME }
\&   ;
\&   %%
\& }; # end $ts
\&
\& sub Error { die "Error sinta\*'ctico\en"; }
\&
\& { # Closure of $input, %reserved_words and $validchars
\&   my $input = "";
\&   my %reserved_words = ();
\&   my $validchars = "";
\&
\&   sub parametrize_\|_scanner {
\&     $input = shift;
\&     %reserved_words = %{shift()};
\&     $validchars = shift;
\&   }
\&
\&   sub scanner {
\&     $input =~ m{\eG\es+}gc;                     # skip whites
\&     if ($input =~ m{\eG([a\-z_A_Z]\ew*)\eb}gc) {
\&       my $w = uc($1);                 # upper case the word
\&       return ($w, $w) if exists $reserved_words{$w};
\&       return (\*(AqNAME\*(Aq, $1);            # not a reserved word
\&     }
\&     return ($1, $1) if ($input =~ m/\eG([$validchars])/gc);
\&     die "Not valid token: $1\en" if ($input =~ m/\eG(\eS)/gc);
\&     return (\*(Aq\*(Aq, undef); # end of file
\&   }
\& } # end closure
\&
\& Parse::Eyapp\->new_grammar(input=>$ts,classname=>\*(Aqmain\*(Aq,outputfile=>\*(AqTypes.pm\*(Aq);
\& my $parser = main\->new(yylex => \e&scanner, yyerror => \e&Error); 
\&
\& parametrize_\|_scanner(
\&   "float x,y;\eninteger a,b\en",
\&   { INTEGER => \*(AqINTEGER\*(Aq, FLOAT => \*(AqFLOAT\*(Aq},
\&   ",;"
\& );
\&
\& my $t = $parser\->YYParse() or die "Syntax Error analyzing input";
\&
\& $t\->translation_scheme;
\&
\& $Data::Dumper::Indent = 1;
\& $Data::Dumper::Terse = 1;
\& $Data::Dumper::Deepcopy  = 1;
\& $Data::Dumper::Deparse = 1;
\& print Dumper($t);
\& print Dumper(\e%s);
.Ve
.PP
Inside a Translation Scheme the lexical variable \f(CW$lhs\fR refers to the attribute
of the father.
.SH "EXECUTION STAGES OF A TRANSLATION SCHEME"
.IX Header "EXECUTION STAGES OF A TRANSLATION SCHEME"
The execution of a Translation Scheme can be divided in the following stages:
.IP "1. During the first stage the grammar is analyzed and the parser is built:" 4
.IX Item "1. During the first stage the grammar is analyzed and the parser is built:"
.Vb 1
\& Parse::Eyapp\->new_grammar(input=>$ts,classname=>\*(Aqmain\*(Aq,outputfile=>\*(AqTypes.pm\*(Aq);
.Ve
.Sp
This stage is called \fIClass Construction Time\fR
.IP "2. A parser conforming to the generated grammar is built" 4
.IX Item "2. A parser conforming to the generated grammar is built"
.Vb 1
\&  my $parser = main\->new(yylex => \e&scanner, yyerror => \e&Error);
.Ve
.Sp
This stage is called  \fIParser Construction Time\fR
.IP "3. The next phase is \fITree construction time\fR. The input is set and the tree is built:" 4
.IX Item "3. The next phase is Tree construction time. The input is set and the tree is built:"
.Vb 5
\& parametrize_\|_scanner(
\&    "float x,y;\eninteger a,b\en",
\&    { INTEGER => \*(AqINTEGER\*(Aq, FLOAT => \*(AqFLOAT\*(Aq},
\&    ",;"
\&  );
\&
\&  my $t = $parser\->YYParse() or die "Syntax Error analyzing input";
.Ve
.ie n .IP "4. The last stage is \fIExecution Time\fR. The tree is traversed in depth first order and the ""CODE"" nodes are executed." 4
.el .IP "4. The last stage is \fIExecution Time\fR. The tree is traversed in depth first order and the \f(CWCODE\fR nodes are executed." 4
.IX Item "4. The last stage is Execution Time. The tree is traversed in depth first order and the CODE nodes are executed."
.Vb 1
\&                           $t\->translation_scheme;
.Ve
.PP
This combination of bottom-up parsing with depth first traversing
leads to a semantic behavior similar to recursive top-down parsers
but with two advantages:
.IP "\(bu" 4
The grammar can be left-recursive
.IP "\(bu" 4
At the time of executing the action the syntax tree is already built, therefore we can refer
to nodes on the right side of the action like in:
.Sp
.Vb 1
\&                      D : $T { $L\->{t} = $T\->{t} } $L
.Ve
.ie n .SH "THE %begin DIRECTIVE"
.el .SH "THE \f(CW%begin\fP DIRECTIVE"
.IX Header "THE %begin DIRECTIVE"
The \f(CW\*(C`%begin { code }\*(C'\fR directive  can be used when
building a translation scheme, i.e. when under the 
control of the \f(CW%metatree\fR directive.
It indicates that such \f(CW\*(C`{ code }\*(C'\fR will be executed at \fItree
construction time\fR. Therefore the code receives as arguments
the references to the nodes of the branch than is being built.
Usually \fIbegin code\fR assist in the construction of the tree.
Line 39 of the following code shows an example.
The action \f(CW\*(C`{ $exp }\*(C'\fR simplifies the syntax tree
bypassing the parenthesis node. The example also illustrates
the combined use of default actions and 
translation schemes.
.PP
.Vb 10
\&  pl@nereida:~/LEyapp/examples$ cat \-n trans_scheme_default_action.pl
\&     1  #!/usr/bin/perl \-w
\&     2  use strict;
\&     3  use Data::Dumper;
\&     4  use Parse::Eyapp;
\&     5  use IO::Interactive qw(is_interactive);
\&     6
\&     7  my $translationscheme = q{
\&     8  %{
\&     9  # head code is available at tree construction time
\&    10  use Data::Dumper;
\&    11  our %sym; # symbol table
\&    12  %}
\&    13
\&    14  %defaultaction {
\&    15     $lhs\->{n} = eval " $left\->{n} $_[2]\->{attr} $right\->{n} "
\&    16  }
\&    17
\&    18  %metatree
\&    19
\&    20  %right   \*(Aq=\*(Aq
\&    21  %left   \*(Aq\-\*(Aq \*(Aq+\*(Aq
\&    22  %left   \*(Aq*\*(Aq \*(Aq/\*(Aq
\&    23
\&    24  %%
\&    25  line:       %name EXP
\&    26                exp <+ \*(Aq;\*(Aq> /* Expressions separated by semicolons */
\&    27                  { $lhs\->{n} = $_[1]\->Last_child\->{n} }
\&    28  ;
\&    29
\&    30  exp:
\&    31              %name PLUS
\&    32                exp.left \*(Aq+\*(Aq exp.right
\&    33          |   %name MINUS
\&    34                exp.left \*(Aq\-\*(Aq exp.right
\&    35          |   %name TIMES
\&    36                exp.left \*(Aq*\*(Aq exp.right
\&    37          |   %name DIV
\&    38                exp.left \*(Aq/\*(Aq exp.right
\&    39          |   %name NUM
\&    40                $NUM
\&    41                  { $lhs\->{n} = $NUM\->{attr} }
\&    42          |   \*(Aq(\*(Aq $exp \*(Aq)\*(Aq  %begin { $exp }
\&    43          |   %name VAR
\&    44                $VAR
\&    45                  { $lhs\->{n} = $sym{$VAR\->{attr}}\->{n} }
\&    46          |   %name ASSIGN
\&    47                $VAR \*(Aq=\*(Aq $exp
\&    48                  { $lhs\->{n} = $sym{$VAR\->{attr}}\->{n} = $exp\->{n} }
\&    49
\&    50  ;
\&    51
\&    52  %%
\&    53  # tail code is available at tree construction time
\&    54  sub _Error {
\&    55    die "Syntax error.\en";
\&    56  }
\&    57
\&    58  sub _Lexer {
\&    59      my($parser)=shift;
\&    60
\&    61      for ($parser\->YYData\->{INPUT}) {
\&    62          s/^\es+//;
\&    63          $_ or  return(\*(Aq\*(Aq,undef);
\&    64          s/^([0\-9]+(?:\e.[0\-9]+)?)// and return(\*(AqNUM\*(Aq,$1);
\&    65          s/^([A\-Za\-z][A\-Za\-z0\-9_]*)// and return(\*(AqVAR\*(Aq,$1);
\&    66          s/^(.)// and return($1,$1);
\&    67      }
\&    68      return(\*(Aq\*(Aq,undef);
\&    69  }
\&    70
\&    71  sub Run {
\&    72      my($self)=shift;
\&    73      return $self\->YYParse( yylex => \e&_Lexer, yyerror => \e&_Error );
\&    74  }
\&    75  }; # end translation scheme
\&    76
\&    77  sub TERMINAL::info { $_[0]\->attr }
\&    78
\&    79  my $p = Parse::Eyapp\->new_grammar(
\&    80    input=>$translationscheme,
\&    81    classname=>\*(Aqmain\*(Aq,
\&    82    firstline => 6,
\&    83    outputfile => \*(Aqmain.pm\*(Aq);
\&    84  die $p\->qtables() if $p\->Warnings;
\&    85  my $parser = main\->new();
\&    86  print "Write a sequence of arithmetic expressions: " if is_interactive();
\&    87  $parser\->YYData\->{INPUT} = <>;
\&    88  my $t = $parser\->Run() or die "Syntax Error analyzing input";
\&    89  $t\->translation_scheme;
\&    90
\&    91  $Parse::Eyapp::Node::INDENT = 2;
\&    92  my $treestring = $t\->str;
\&    93
\&    94  $Data::Dumper::Indent = 1;
\&    95  $Data::Dumper::Terse = 1;
\&    96  $Data::Dumper::Deepcopy  = 1;
\&    97  our %sym;
\&    98  my $symboltable = Dumper(\e%sym);
\&    99
\&   100  print <<"EOR";
\&   101  ***********Tree*************
\&   102  $treestring
\&   103  ******Symbol table**********
\&   104  $symboltable
\&   105  ************Result**********
\&   106  $t\->{n}
\&   107
\&   108  EOR
.Ve
.PP
When executed with input \f(CW\*(C`a=2*3;b=a*a\*(C'\fR
the program produces an output similar to this:
.PP
.Vb 3
\&  pl@nereida:~/LEyapp/examples$ trans_scheme_default_action.pl
\&  Write a sequence of arithmetic expressions: a=2*3;b=a*a
\&  ***********Tree*************
\&
\&  EXP(
\&    _PLUS_LIST(
\&      ASSIGN(
\&        TERMINAL[a],
\&        TERMINAL[=],
\&        TIMES(
\&          NUM(TERMINAL[2], CODE),
\&          TERMINAL[*],
\&          NUM(TERMINAL[3], CODE),
\&          CODE
\&        ) # TIMES,
\&        CODE
\&      ) # ASSIGN,
\&      ASSIGN(
\&        TERMINAL[b],
\&        TERMINAL[=],
\&        TIMES(
\&          VAR(TERMINAL[a], CODE),
\&          TERMINAL[*],
\&          VAR(TERMINAL[a], CODE),
\&          CODE
\&        ) # TIMES,
\&        CODE
\&      ) # ASSIGN
\&    ) # _PLUS_LIST,
\&    CODE
\&  ) # EXP
\&  ******Symbol table**********
\&  {
\&    \*(Aqa\*(Aq => {
\&      \*(Aqn\*(Aq => 6
\&    },
\&    \*(Aqb\*(Aq => {
\&      \*(Aqn\*(Aq => 36
\&    }
\&  }
\&
\&  ************Result**********
\&  36
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The project home is at <http://code.google.com/p/parse\-eyapp/>.
Use a subversion client to anonymously check out the latest project source code:
.Sp
.Vb 1
\&   svn checkout http://parse\-eyapp.googlecode.com/svn/trunk/ parse\-eyapp\-read\-only
.Ve
.IP "\(bu" 4
The tutorial \fIParsing Strings and Trees with\fR \f(CW\*(C`Parse::Eyapp\*(C'\fR
(An Introduction to Compiler Construction in seven pages) in
<http://nereida.deioc.ull.es/~pl/eyapsimple/>
.IP "\(bu" 4
Parse::Eyapp, 
Parse::Eyapp::eyapplanguageref, 
Parse::Eyapp::debuggingtut,
Parse::Eyapp::defaultactionsintro,
Parse::Eyapp::translationschemestut,
Parse::Eyapp::Driver,
Parse::Eyapp::Node,
Parse::Eyapp::YATW,
Parse::Eyapp::Treeregexp,
Parse::Eyapp::Scope,
Parse::Eyapp::Base,
Parse::Eyapp::datagenerationtut
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/languageintro.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/debuggingtut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/eyapplanguageref.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Treeregexp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Node.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/YATW.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Eyapp.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/Base.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/translationschemestut.pdf>
.IP "\(bu" 4
The pdf file in <http://nereida.deioc.ull.es/~pl/perlexamples/treematchingtut.pdf>
.IP "\(bu" 4
perldoc eyapp,
.IP "\(bu" 4
perldoc treereg,
.IP "\(bu" 4
perldoc vgg,
.IP "\(bu" 4
The Syntax Highlight file for vim at <http://www.vim.org/scripts/script.php?script_id=2453>
and <http://nereida.deioc.ull.es/~vim/>
.IP "\(bu" 4
\&\fIAnalisis Lexico y Sintactico\fR, (Notes for a course in compiler 
construction) by  Casiano Rodriguez-Leon. 
Available at  <http://nereida.deioc.ull.es/~pl/perlexamples/>
Is the more complete and reliable source for Parse::Eyapp. However is in Spanish.
.IP "\(bu" 4
Parse::Yapp,
.IP "\(bu" 4
Man pages of \fIyacc\fR\|(1) and
\&\fIbison\fR\|(1),
<http://www.delorie.com/gnu/docs/bison/bison.html>
.IP "\(bu" 4
Language::AttributeGrammar
.IP "\(bu" 4
Parse::RecDescent.
.IP "\(bu" 4
HOP::Parser
.IP "\(bu" 4
HOP::Lexer
.IP "\(bu" 4
ocamlyacc tutorial at 
<http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex\-ocamlyacc/ocamlyacc\-tutorial/ocamlyacc\-tutorial.html>
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "\(bu" 4
The classic Dragon's book \fICompilers: Principles, Techniques, and Tools\fR 
by Alfred V. Aho, Ravi Sethi and
Jeffrey D. Ullman (Addison-Wesley 1986)
.IP "\(bu" 4
\&\fI\s-1CS2121:\s0 The Implementation and Power of Programming Languages\fR
(See <http://www.cs.man.ac.uk/~pjj>, <http://www.cs.man.ac.uk/~pjj/complang/g2lr.html> 
and <http://www.cs.man.ac.uk/~pjj/cs2121/ho/ho.html>) by 
Pete Jinks
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
.IP "\(bu" 2
Hal Finkel <http://www.halssoftware.com/>
.IP "\(bu" 2
G. Williams <http://kasei.us/>
.IP "\(bu" 2
Thomas L. Shinnick <http://search.cpan.org/~tshinnic/>
.IP "\(bu" 2
Frank Leray
.SH "AUTHOR"
.IX Header "AUTHOR"
Casiano Rodriguez-Leon (casiano@ull.es)
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
This work has been supported by \s-1CEE \s0(\s-1FEDER\s0) and the Spanish Ministry of
\&\fIEducacion y Ciencia\fR through \fIPlan Nacional I+D+I\fR number \s-1TIN2005\-08818\-C04\-04
\&\s0(\s-1ULL::OPLINK\s0 project <http://www.oplink.ull.es/>). 
Support from Gobierno de Canarias was through \s-1GC02210601
\&\s0(\fIGrupos Consolidados\fR).
The University of La Laguna has also supported my work in many ways
and for many years.
.PP
A large percentage of  code is verbatim taken from Parse::Yapp 1.05.
The author of Parse::Yapp is Francois Desarmenien.
.PP
I wish to thank Francois Desarmenien for his Parse::Yapp module, 
to my students at La Laguna and to the Perl Community. Thanks to 
the people who have contributed to improve the module (see \*(L"\s-1CONTRIBUTORS\*(R"\s0 in Parse::Eyapp).
Thanks to Larry Wall for giving us Perl.
Special thanks to Juana.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2006\-2008 Casiano Rodriguez-Leon (casiano@ull.es). All rights reserved.
.PP
Parse::Yapp copyright is of Francois Desarmenien, all rights reserved. 1998\-2001
.PP
These modules are free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 81:" 4
.IX Item "Around line 81:"
Non-ASCII character seen before =encoding in 'sinta\*'ctico\en";'. Assuming \s-1UTF\-8\s0
                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Method::Signatures.3pm                0100644 0001750 0001750 00000021617 12566242536 026143  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Method::Signatures 3"
.TH Parse::Method::Signatures 3 "2014-01-12" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Method::Signatures \- Perl6 like method signature parser
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Inspired by Perl6::Signature but streamlined to just support the subset
deemed useful for TryCatch and MooseX::Method::Signatures.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Document the parameter return types.
.IP "\(bu" 4
Probably lots of other things
.SH "METHODS"
.IX Header "METHODS"
There are only two public methods to this module, both of which should be
called as class methods. Both methods accept  either a single (non-ref) scalar
as the value for the \*(L"input\*(R" attribute, or normal new style arguments (hash
or hash-ref).
.SS "signature"
.IX Subsection "signature"
.Vb 1
\& my $sig = Parse::Method::Signatures\->signature( \*(Aq(Str $foo)\*(Aq )
.Ve
.PP
Attempts to parse the (bracketed) method signature. Returns a value or croaks
on error.
.SS "param"
.IX Subsection "param"
.Vb 1
\&  my $param = Parse::Method::Signatures\->param( \*(AqStr $foo where { length($_) < 10 }\*(Aq)
.Ve
.PP
Attempts to parse the specification for a single parameter. Returns value or
croaks on error.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
All the attributes on this class are read-only.
.SS "input"
.IX Subsection "input"
\&\fBType:\fR Str
.PP
The string to parse.
.SS "offset"
.IX Subsection "offset"
\&\fBType:\fR Int
.PP
Offset into \*(L"input\*(R" at which to start parsing. Useful for using with
Devel::Declare linestring
.SS "signature_class"
.IX Subsection "signature_class"
\&\fBDefault:\fR Parse::Method::Signatures::Sig
.PP
\&\fBType:\fR Str (loaded on demand class name)
.SS "param_class"
.IX Subsection "param_class"
\&\fBDefault:\fR Parse::Method::Signatures::Param
.PP
\&\fBType:\fR Str (loaded on demand class name)
.SS "type_constraint_class"
.IX Subsection "type_constraint_class"
\&\fBDefault:\fR Parse::Method::Signatures::TypeConstraint
.PP
\&\fBType:\fR Str (loaded on demand class name)
.PP
Class that is used to turn the parsed type constraint into an actual
Moose::Meta::TypeConstraint object.
.SS "from_namespace"
.IX Subsection "from_namespace"
\&\fBType:\fR ClassName
.PP
Let this module know which package it is parsing signatures form. This is
entirely optional, and the only effect is has is on parsing type constraints.
.PP
If this attribute is set it is passed to \*(L"type_constraint_class\*(R" which can
use it to introspect the package (commonly for MooseX::Types exported
types). See
\&\*(L"find_registered_constraint\*(R" in Parse::Method::Signature::TypeConstraints for
more details.
.SS "type_constraint_callback"
.IX Subsection "type_constraint_callback"
\&\fBType:\fR CodeRef
.PP
Passed to the constructor of \*(L"type_constraint_class\*(R". Default implementation
of this callback asks Moose for a type constrain matching the name passed in.
If you have more complex requirements, such as parsing types created by
MooseX::Types then you will want a callback similar to this:
.PP
.Vb 7
\& # my $target_package defined elsewhere.
\& my $tc_cb = sub {
\&   my ($pms_tc, $name) = @_;
\&   my $code = $target_package\->can($name);
\&   $code ? eval { $code\->() } 
\&         : $pms_tc\->find_registered_constraint($name);
\& }
.Ve
.PP
Note that the above example is better provided by providing the
\&\*(L"from_namespace\*(R" attribute.
.SH "CAVEATS"
.IX Header "CAVEATS"
Like Perl6::Signature, the parsing of certain constructs is currently only a
\&'best effort' \- specifically default values and where code blocks might not
successfully for certain complex cases. Patches/Failing tests welcome.
.PP
Additionally, default value specifications are not evaluated which means that
no such lexical or similar errors will not be produced by this module.
Constant folding will also not be performed.
.PP
There are certain constructs that are simply too much hassle to avoid when the
work around is simple. Currently the only cases that are known to parse wrong
are when using anonymous variables (i.e. just sigils) in unpacked arrays. Take
the following example:
.PP
.Vb 1
\& method foo (ArrayRef [$, $], $some_value_we_care_about) {
.Ve
.PP
In this case the \f(CW$]\fR is treated as one of perl's magic variables
(specifically, the patch level of the Perl interpreter) rather than a \f(CW\*(C`$\*(C'\fR
followed by a \f(CW\*(C`]\*(C'\fR as was almost certainly intended. The work around for this
is simple: introduce a space between the characters:
.PP
.Vb 1
\& method foo (ArrayRef [ $, $ ], $some_value_we_care_about) {
.Ve
.PP
The same applies
.SH "AUTHOR"
.IX Header "AUTHOR"
Ash Berlin <ash@cpan.org>.
.PP
Thanks to Florian Ragwitz <rafl@debian.org>.
.PP
Many thanks to Piers Cawley to showing me the way to refactor my spaghetti
code into something more manageable.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Devel::Declare which is used by most modules that use this (currently by
all modules known to the author.)
.PP
<http://github.com/ashb/trycatch/tree>.
.SH "LICENSE"
.IX Header "LICENSE"
Licensed under the same terms as Perl itself.
.PP
This distribution copyright 2008\-2009, Ash Berlin <ash@cpan.org>
                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Method::Signatures5.16.3pm            0100644 0001750 0001750 00000021276 12566242526 026455  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Method::Signatures 3"
.TH Parse::Method::Signatures 3 "2011-09-09" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Method::Signatures \- Perl6 like method signature parser
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Inspired by Perl6::Signature but streamlined to just support the subset
deemed useful for TryCatch and MooseX::Method::Signatures.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Document the parameter return types.
.IP "\(bu" 4
Probably lots of other things
.SH "METHODS"
.IX Header "METHODS"
There are only two public methods to this module, both of which should be
called as class methods. Both methods accept  either a single (non-ref) scalar
as the value for the \*(L"input\*(R" attribute, or normal new style arguments (hash
or hash-ref).
.SS "signature"
.IX Subsection "signature"
.Vb 1
\& my $sig = Parse::Method::Signatures\->signature( \*(Aq(Str $foo)\*(Aq )
.Ve
.PP
Attempts to parse the (bracketed) method signature. Returns a value or croaks
on error.
.SS "param"
.IX Subsection "param"
.Vb 1
\&  my $param = Parse::Method::Signatures\->param( \*(AqStr $foo where { length($_) < 10 }\*(Aq)
.Ve
.PP
Attempts to parse the specification for a single parameter. Returns value or
croaks on error.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
All the attributes on this class are read-only.
.SS "input"
.IX Subsection "input"
\&\fBType:\fR Str
.PP
The string to parse.
.SS "offset"
.IX Subsection "offset"
\&\fBType:\fR Int
.PP
Offset into \*(L"input\*(R" at which to start parsing. Useful for using with
Devel::Declare linestring
.SS "signature_class"
.IX Subsection "signature_class"
\&\fBDefault:\fR Parse::Method::Signatures::Sig
.PP
\&\fBType:\fR Str (loaded on demand class name)
.SS "param_class"
.IX Subsection "param_class"
\&\fBDefault:\fR Parse::Method::Signatures::Param
.PP
\&\fBType:\fR Str (loaded on demand class name)
.SS "type_constraint_class"
.IX Subsection "type_constraint_class"
\&\fBDefault:\fR Parse::Method::Signatures::TypeConstraint
.PP
\&\fBType:\fR Str (loaded on demand class name)
.PP
Class that is used to turn the parsed type constraint into an actual
Moose::Meta::TypeConstraint object.
.SS "from_namespace"
.IX Subsection "from_namespace"
\&\fBType:\fR ClassName
.PP
Let this module know which package it is parsing signatures form. This is
entirely optional, and the only effect is has is on parsing type constraints.
.PP
If this attribute is set it is passed to \*(L"type_constraint_class\*(R" which can
use it to introspect the package (commmonly for MooseX::Types exported
types). See
\&\*(L"find_registered_constraint\*(R" in Parse::Method::Signature::TypeConstraints for
more details.
.SS "type_constraint_callback"
.IX Subsection "type_constraint_callback"
\&\fBType:\fR CodeRef
.PP
Passed to the constructor of \*(L"type_constraint_class\*(R". Default implementation
of this callback asks Moose for a type constrain matching the name passed in.
If you have more complex requirements, such as parsing types created by
MooseX::Types then you will want a callback similar to this:
.PP
.Vb 7
\& # my $target_package defined elsewhere.
\& my $tc_cb = sub {
\&   my ($pms_tc, $name) = @_;
\&   my $code = $target_package\->can($name);
\&   $code ? eval { $code\->() } 
\&         : $pms_tc\->find_registered_constraint($name);
\& }
.Ve
.PP
Note that the above example is better provided by providing the
\&\*(L"from_namespace\*(R" attribute.
.SH "CAVEATS"
.IX Header "CAVEATS"
Like Perl6::Signature, the parsing of certain constructs is currently only a
\&'best effort' \- specifically default values and where code blocks might not
successfully for certain complex cases. Patches/Failing tests welcome.
.PP
Additionally, default value specifications are not evaluated which means that
no such lexical or similar errors will not be produced by this module.
Constant folding will also not be performed.
.PP
There are certain constructs that are simply too much hassle to avoid when the
work around is simple. Currently the only cases that are known to parse wrong
are when using anonymous variables (i.e. just sigils) in unpacked arrays. Take
the following example:
.PP
.Vb 1
\& method foo (ArrayRef [$, $], $some_value_we_care_about) {
.Ve
.PP
In this case the \f(CW$]\fR is treated as one of perl's magic variables
(specifically, the patch level of the Perl interpreter) rather than a \f(CW\*(C`$\*(C'\fR
followed by a \f(CW\*(C`]\*(C'\fR as was almost certainly intended. The work around for this
is simple: introduce a space between the charcters:
.PP
.Vb 1
\& method foo (ArrayRef [ $, $ ], $some_value_we_care_about) {
.Ve
.PP
The same applies
.SH "AUTHOR"
.IX Header "AUTHOR"
Ash Berlin <ash@cpan.org>.
.PP
Thanks to Florian Ragwitz <rafl@debian.org>.
.PP
Many thanks to Piers Cawley to showing me the way to refactor my spaghetti
code into something more manageable.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Devel::Declare which is used by most modules that use this (currently by
all modules known to the author.)
.PP
<http://github.com/ashb/trycatch/tree>.
.SH "LICENSE"
.IX Header "LICENSE"
Licensed under the same terms as Perl itself.
.PP
This distribution copyright 2008\-2009, Ash Berlin <ash@cpan.org>
                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Method::Signatures5.18.3pm            0100644 0001750 0001750 00000021617 12566242536 026457  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Method::Signatures 3"
.TH Parse::Method::Signatures 3 "2014-01-12" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Method::Signatures \- Perl6 like method signature parser
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Inspired by Perl6::Signature but streamlined to just support the subset
deemed useful for TryCatch and MooseX::Method::Signatures.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Document the parameter return types.
.IP "\(bu" 4
Probably lots of other things
.SH "METHODS"
.IX Header "METHODS"
There are only two public methods to this module, both of which should be
called as class methods. Both methods accept  either a single (non-ref) scalar
as the value for the \*(L"input\*(R" attribute, or normal new style arguments (hash
or hash-ref).
.SS "signature"
.IX Subsection "signature"
.Vb 1
\& my $sig = Parse::Method::Signatures\->signature( \*(Aq(Str $foo)\*(Aq )
.Ve
.PP
Attempts to parse the (bracketed) method signature. Returns a value or croaks
on error.
.SS "param"
.IX Subsection "param"
.Vb 1
\&  my $param = Parse::Method::Signatures\->param( \*(AqStr $foo where { length($_) < 10 }\*(Aq)
.Ve
.PP
Attempts to parse the specification for a single parameter. Returns value or
croaks on error.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
All the attributes on this class are read-only.
.SS "input"
.IX Subsection "input"
\&\fBType:\fR Str
.PP
The string to parse.
.SS "offset"
.IX Subsection "offset"
\&\fBType:\fR Int
.PP
Offset into \*(L"input\*(R" at which to start parsing. Useful for using with
Devel::Declare linestring
.SS "signature_class"
.IX Subsection "signature_class"
\&\fBDefault:\fR Parse::Method::Signatures::Sig
.PP
\&\fBType:\fR Str (loaded on demand class name)
.SS "param_class"
.IX Subsection "param_class"
\&\fBDefault:\fR Parse::Method::Signatures::Param
.PP
\&\fBType:\fR Str (loaded on demand class name)
.SS "type_constraint_class"
.IX Subsection "type_constraint_class"
\&\fBDefault:\fR Parse::Method::Signatures::TypeConstraint
.PP
\&\fBType:\fR Str (loaded on demand class name)
.PP
Class that is used to turn the parsed type constraint into an actual
Moose::Meta::TypeConstraint object.
.SS "from_namespace"
.IX Subsection "from_namespace"
\&\fBType:\fR ClassName
.PP
Let this module know which package it is parsing signatures form. This is
entirely optional, and the only effect is has is on parsing type constraints.
.PP
If this attribute is set it is passed to \*(L"type_constraint_class\*(R" which can
use it to introspect the package (commonly for MooseX::Types exported
types). See
\&\*(L"find_registered_constraint\*(R" in Parse::Method::Signature::TypeConstraints for
more details.
.SS "type_constraint_callback"
.IX Subsection "type_constraint_callback"
\&\fBType:\fR CodeRef
.PP
Passed to the constructor of \*(L"type_constraint_class\*(R". Default implementation
of this callback asks Moose for a type constrain matching the name passed in.
If you have more complex requirements, such as parsing types created by
MooseX::Types then you will want a callback similar to this:
.PP
.Vb 7
\& # my $target_package defined elsewhere.
\& my $tc_cb = sub {
\&   my ($pms_tc, $name) = @_;
\&   my $code = $target_package\->can($name);
\&   $code ? eval { $code\->() } 
\&         : $pms_tc\->find_registered_constraint($name);
\& }
.Ve
.PP
Note that the above example is better provided by providing the
\&\*(L"from_namespace\*(R" attribute.
.SH "CAVEATS"
.IX Header "CAVEATS"
Like Perl6::Signature, the parsing of certain constructs is currently only a
\&'best effort' \- specifically default values and where code blocks might not
successfully for certain complex cases. Patches/Failing tests welcome.
.PP
Additionally, default value specifications are not evaluated which means that
no such lexical or similar errors will not be produced by this module.
Constant folding will also not be performed.
.PP
There are certain constructs that are simply too much hassle to avoid when the
work around is simple. Currently the only cases that are known to parse wrong
are when using anonymous variables (i.e. just sigils) in unpacked arrays. Take
the following example:
.PP
.Vb 1
\& method foo (ArrayRef [$, $], $some_value_we_care_about) {
.Ve
.PP
In this case the \f(CW$]\fR is treated as one of perl's magic variables
(specifically, the patch level of the Perl interpreter) rather than a \f(CW\*(C`$\*(C'\fR
followed by a \f(CW\*(C`]\*(C'\fR as was almost certainly intended. The work around for this
is simple: introduce a space between the characters:
.PP
.Vb 1
\& method foo (ArrayRef [ $, $ ], $some_value_we_care_about) {
.Ve
.PP
The same applies
.SH "AUTHOR"
.IX Header "AUTHOR"
Ash Berlin <ash@cpan.org>.
.PP
Thanks to Florian Ragwitz <rafl@debian.org>.
.PP
Many thanks to Piers Cawley to showing me the way to refactor my spaghetti
code into something more manageable.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Devel::Declare which is used by most modules that use this (currently by
all modules known to the author.)
.PP
<http://github.com/ashb/trycatch/tree>.
.SH "LICENSE"
.IX Header "LICENSE"
Licensed under the same terms as Perl itself.
.PP
This distribution copyright 2008\-2009, Ash Berlin <ash@cpan.org>
                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Method::Signatures::Param.3pm         0100644 0001750 0001750 00000014123 12566242536 027302  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Method::Signatures::Param 3"
.TH Parse::Method::Signatures::Param 3 "2013-02-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Method::Signatures::Param \- a parsed parameter from a signature
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
All attributes of this class are read-only.
.SS "required"
.IX Subsection "required"
Is this parameter required (true) or optional (false)?
.SS "sigil"
.IX Subsection "sigil"
The effective sigil ('$', '@' or '%') of this parameter.
.SS "type_constraints"
.IX Subsection "type_constraints"
.RS 4
\&\fBType:\fR Parse::Method::Signatures::TypeConstraint
.Sp
\&\fBPredicate:\fR has_type_constraints
.RE
.PP
Representation of the type constraint for this parameter. Most commonly you
will just call \*(L"meta_type_constraint\*(R" and not access this attribute directly.
.SS "default_value"
.IX Subsection "default_value"
.RS 4
\&\fBType:\fR Str
.Sp
\&\fBPredicate:\fR has_default_value
.RE
.PP
A string that should be eval'd or injected to get the default value for this
parameter. For example:
.PP
.Vb 1
\& $name = \*(Aqbar\*(Aq
.Ve
.PP
Would give a default_value of \*(L"'bar'\*(R".
.SS "constraints"
.IX Subsection "constraints"
.RS 4
\&\fBType:\fR ArrayRef[Str]
.Sp
\&\fBPredicate:\fR has_constraints
.RE
.PP
\&\f(CW\*(C`where\*(C'\fR constraints for this type. Each member of the array a the string
(including enclosing braces) of the where constraint block.
.SS "param_traits"
.IX Subsection "param_traits"
.RS 4
\&\fBType:\fR ArrayRef[ Tupple[Str,Str] ]
.Sp
\&\fBPredicate:\fR has_traits
.RE
.PP
Traits that this parameter is declared to have. For instance
.PP
.Vb 1
\& $foo does coerce
.Ve
.PP
would have a trait of
.PP
.Vb 1
\& [\*(Aqdoes\*(Aq, \*(Aqcoerce\*(Aq]
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "to_string"
.IX Subsection "to_string"
.SS "meta_type_constraint"
.IX Subsection "meta_type_constraint"
Get the Moose::Meta::TypeConstraint for this parameter. Check first that the
type has a type constraint:
.PP
.Vb 1
\& $tc = $param\->meta_type_constraint if $param\->has_type_constraints;
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Parse::Method::Signatures.
.SH "AUTHORS"
.IX Header "AUTHORS"
Ash Berlin <ash@cpan.org>.
.PP
Florian Ragwitz <rafl@debian.org>.
.SH "LICENSE"
.IX Header "LICENSE"
Licensed under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Method::Signatures::Param5.16.3pm     0100644 0001750 0001750 00000013602 12566242526 027614  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Method::Signatures::Param 3"
.TH Parse::Method::Signatures::Param 3 "2011-09-09" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Method::Signatures::Param \- a parsed parameter from a signature
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
All attributes of this class are read-only.
.SS "required"
.IX Subsection "required"
Is this parameter required (true) or optional (false)?
.SS "sigil"
.IX Subsection "sigil"
The effective sigil ('$', '@' or '%') of this parameter.
.SS "type_constraints"
.IX Subsection "type_constraints"
.RS 4
\&\fBType:\fR Parse::Method::Signatures::TypeConstraint
.Sp
\&\fBPredicate:\fR has_type_constraints
.RE
.PP
Representation of the type constraint for this parameter. Most commonly you
will just call \*(L"meta_type_constraint\*(R" and not access this attribute directly.
.SS "default_value"
.IX Subsection "default_value"
.RS 4
\&\fBType:\fR Str
.Sp
\&\fBPredicate:\fR has_default_value
.RE
.PP
A string that should be eval'd or injected to get the default value for this
parameter. For example:
.PP
.Vb 1
\& $name = \*(Aqbar\*(Aq
.Ve
.PP
Would give a default_value of \*(L"'bar'\*(R".
.SS "constraints"
.IX Subsection "constraints"
.RS 4
\&\fBType:\fR ArrayRef[Str]
.Sp
\&\fBPredicate:\fR has_constraints
.RE
.PP
\&\f(CW\*(C`where\*(C'\fR constraints for this type. Each member of the array a the string
(including enclosing braces) of the where constraint block.
.SS "param_traits"
.IX Subsection "param_traits"
.RS 4
\&\fBType:\fR ArrayRef[ Tupple[Str,Str] ]
.Sp
\&\fBPredicate:\fR has_traits
.RE
.PP
Traits that this parameter is declared to have. For instance
.PP
.Vb 1
\& $foo does coerce
.Ve
.PP
would have a trait of
.PP
.Vb 1
\& [\*(Aqdoes\*(Aq, \*(Aqcoerce\*(Aq]
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "to_string"
.IX Subsection "to_string"
.SS "meta_type_constraint"
.IX Subsection "meta_type_constraint"
Get the Moose::Meta::TypeConstraint for this parameter. Check first that the
type has a type constraint:
.PP
.Vb 1
\& $tc = $param\->meta_type_constraint if $param\->has_type_constraints;
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Parse::Method::Signatures.
.SH "AUTHORS"
.IX Header "AUTHORS"
Ash Berlin <ash@cpan.org>.
.PP
Florian Ragwitz <rafl@debian.org>.
.SH "LICENSE"
.IX Header "LICENSE"
Licensed under the same terms as Perl itself.
                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Method::Signatures::Param5.18.3pm     0100644 0001750 0001750 00000014123 12566242536 027616  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Method::Signatures::Param 3"
.TH Parse::Method::Signatures::Param 3 "2013-02-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Method::Signatures::Param \- a parsed parameter from a signature
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
All attributes of this class are read-only.
.SS "required"
.IX Subsection "required"
Is this parameter required (true) or optional (false)?
.SS "sigil"
.IX Subsection "sigil"
The effective sigil ('$', '@' or '%') of this parameter.
.SS "type_constraints"
.IX Subsection "type_constraints"
.RS 4
\&\fBType:\fR Parse::Method::Signatures::TypeConstraint
.Sp
\&\fBPredicate:\fR has_type_constraints
.RE
.PP
Representation of the type constraint for this parameter. Most commonly you
will just call \*(L"meta_type_constraint\*(R" and not access this attribute directly.
.SS "default_value"
.IX Subsection "default_value"
.RS 4
\&\fBType:\fR Str
.Sp
\&\fBPredicate:\fR has_default_value
.RE
.PP
A string that should be eval'd or injected to get the default value for this
parameter. For example:
.PP
.Vb 1
\& $name = \*(Aqbar\*(Aq
.Ve
.PP
Would give a default_value of \*(L"'bar'\*(R".
.SS "constraints"
.IX Subsection "constraints"
.RS 4
\&\fBType:\fR ArrayRef[Str]
.Sp
\&\fBPredicate:\fR has_constraints
.RE
.PP
\&\f(CW\*(C`where\*(C'\fR constraints for this type. Each member of the array a the string
(including enclosing braces) of the where constraint block.
.SS "param_traits"
.IX Subsection "param_traits"
.RS 4
\&\fBType:\fR ArrayRef[ Tupple[Str,Str] ]
.Sp
\&\fBPredicate:\fR has_traits
.RE
.PP
Traits that this parameter is declared to have. For instance
.PP
.Vb 1
\& $foo does coerce
.Ve
.PP
would have a trait of
.PP
.Vb 1
\& [\*(Aqdoes\*(Aq, \*(Aqcoerce\*(Aq]
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "to_string"
.IX Subsection "to_string"
.SS "meta_type_constraint"
.IX Subsection "meta_type_constraint"
Get the Moose::Meta::TypeConstraint for this parameter. Check first that the
type has a type constraint:
.PP
.Vb 1
\& $tc = $param\->meta_type_constraint if $param\->has_type_constraints;
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Parse::Method::Signatures.
.SH "AUTHORS"
.IX Header "AUTHORS"
Ash Berlin <ash@cpan.org>.
.PP
Florian Ragwitz <rafl@debian.org>.
.SH "LICENSE"
.IX Header "LICENSE"
Licensed under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Method::Signatures::Sig.3pm           0100644 0001750 0001750 00000011737 12566242536 026774  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Method::Signatures::Sig 3"
.TH Parse::Method::Signatures::Sig 3 "2013-02-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Method::Signatures::Sig \- Method Signature
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Represents the parsed method signature.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "invocant"
.IX Subsection "invocant"
.SS "named_params"
.IX Subsection "named_params"
A ParamCollection representing the name parameters of this signature.
.SS "positional_params"
.IX Subsection "positional_params"
A ParamCollection representing the positional parameters of this signature.
.SH "METHODS"
.IX Header "METHODS"
.SS "has_named_params"
.IX Subsection "has_named_params"
Predicate returning true if this signature has named parameters.
.SS "has_positional_params"
.IX Subsection "has_positional_params"
Predicate returning true if this signature has positional parameters.
.SS "named_param"
.IX Subsection "named_param"
Returns the Param with the specified name.
.SS "to_string"
.IX Subsection "to_string"
Returns a string representation of this signature.
.SH "LICENSE"
.IX Header "LICENSE"
Licensed under the same terms as Perl itself.
                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Method::Signatures::Sig5.16.3pm       0100644 0001750 0001750 00000011416 12566242526 027277  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Method::Signatures::Sig 3"
.TH Parse::Method::Signatures::Sig 3 "2011-09-09" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Method::Signatures::Sig \- Method Signature
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Represents the parsed method signature.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "invocant"
.IX Subsection "invocant"
.SS "named_params"
.IX Subsection "named_params"
A ParamCollection representing the name parameters of this signature.
.SS "positional_params"
.IX Subsection "positional_params"
A ParamCollection representing the positional parameters of this signature.
.SH "METHODS"
.IX Header "METHODS"
.SS "has_named_params"
.IX Subsection "has_named_params"
Predicate returning true if this signature has named parameters.
.SS "has_positional_params"
.IX Subsection "has_positional_params"
Predicate returning true if this signature has positional parameters.
.SS "named_param"
.IX Subsection "named_param"
Returns the Param with the specified name.
.SS "to_string"
.IX Subsection "to_string"
Returns a string representation of this signature.
.SH "LICENSE"
.IX Header "LICENSE"
Licensed under the same terms as Perl itself.
                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Method::Signatures::Sig5.18.3pm       0100644 0001750 0001750 00000011737 12566242536 027310  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Method::Signatures::Sig 3"
.TH Parse::Method::Signatures::Sig 3 "2013-02-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Method::Signatures::Sig \- Method Signature
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Represents the parsed method signature.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "invocant"
.IX Subsection "invocant"
.SS "named_params"
.IX Subsection "named_params"
A ParamCollection representing the name parameters of this signature.
.SS "positional_params"
.IX Subsection "positional_params"
A ParamCollection representing the positional parameters of this signature.
.SH "METHODS"
.IX Header "METHODS"
.SS "has_named_params"
.IX Subsection "has_named_params"
Predicate returning true if this signature has named parameters.
.SS "has_positional_params"
.IX Subsection "has_positional_params"
Predicate returning true if this signature has positional parameters.
.SS "named_param"
.IX Subsection "named_param"
Returns the Param with the specified name.
.SS "to_string"
.IX Subsection "to_string"
Returns a string representation of this signature.
.SH "LICENSE"
.IX Header "LICENSE"
Licensed under the same terms as Perl itself.
                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::Method::Signatures::TypeConstraint.3pm0100644 0001750 0001750 00000013372 12566242536 031235  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Method::Signatures::TypeConstraint 3"
.TH Parse::Method::Signatures::TypeConstraint 3 "2013-02-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Method::Signatures::TypeConstraint \- turn parsed TC data into Moose TC object
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Class used to turn \s-1PPI\s0 elements into Moose::Meta::TypeConstraint objects.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "tc"
.IX Subsection "tc"
.RS 4
\&\fBLazy Build.\fR
.RE
.PP
The Moose::Meta::TypeConstraint object for this type constraint, built when
requested. \*(L"tc_callback\*(R" will be called for each individual component type in
turn.
.SS "tc_callback"
.IX Subsection "tc_callback"
.RS 4
\&\fBType:\fR CodeRef
.Sp
\&\fBDefault:\fR \*(L"find_registered_constraint\*(R"
.RE
.PP
Callback used to turn type names into type objects. See
\&\*(L"type_constraint_callback\*(R" in Parse::Method::Signatures for more details and an
example.
.SS "from_namespace"
.IX Subsection "from_namespace"
.RS 4
\&\fBType:\fR ClassName
.RE
.PP
If provided, then the default \f(CW\*(C`tc_callback\*(C'\fR will search for MooseX::Types
in this package.
.SH "METHODS"
.IX Header "METHODS"
.SS "find_registered_constraint"
.IX Subsection "find_registered_constraint"
Will search for an imported MooseX::Types in \*(L"from_namespace\*(R" (if
provided). Failing that it will ask the Moose::Meta::TypeConstraint::Registry
for a type with the given name.
.PP
If all else fails, it will simple return the type as a string, so that Moose's
auto-vivification of classnames to type will work.
.SS "to_string"
.IX Subsection "to_string"
String representation of the type constraint, approximately as parsed.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Parse::Method::Signatures, MooseX::Types, MooseX::Types::Util.
.SH "AUTHORS"
.IX Header "AUTHORS"
Florian Ragwitz <rafl@debian.org>.
.PP
Ash Berlin <ash@cpan.org>.
.SH "LICENSE"
.IX Header "LICENSE"
Licensed under the same terms as Perl itself.
                                                                                                                                                                                                                                                                      Parse::Method::Signatures::TypeConstraint5.16.3pm                                                   0100644 0001750 0001750 00000013051 12566242526 031461  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Method::Signatures::TypeConstraint 3"
.TH Parse::Method::Signatures::TypeConstraint 3 "2011-09-09" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Method::Signatures::TypeConstraint \- turn parsed TC data into Moose TC object
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Class used to turn \s-1PPI\s0 elements into Moose::Meta::TypeConstraint objects.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "tc"
.IX Subsection "tc"
.RS 4
\&\fBLazy Build.\fR
.RE
.PP
The Moose::Meta::TypeConstraint object for this type constraint, built when
requested. \*(L"tc_callback\*(R" will be called for each individual component type in
turn.
.SS "tc_callback"
.IX Subsection "tc_callback"
.RS 4
\&\fBType:\fR CodeRef
.Sp
\&\fBDefault:\fR \*(L"find_registered_constraint\*(R"
.RE
.PP
Callback used to turn type names into type objects. See
\&\*(L"type_constraint_callback\*(R" in Parse::Method::Signatures for more details and an
example.
.SS "from_namespace"
.IX Subsection "from_namespace"
.RS 4
\&\fBType:\fR ClassName
.RE
.PP
If provided, then the default \f(CW\*(C`tc_callback\*(C'\fR will search for MooseX::Types
in this package.
.SH "METHODS"
.IX Header "METHODS"
.SS "find_registered_constraint"
.IX Subsection "find_registered_constraint"
Will search for an imported MooseX::Types in \*(L"from_namespace\*(R" (if
provided). Failing that it will ask the Moose::Meta::TypeConstraint::Registry
for a type with the given name.
.PP
If all else fails, it will simple return the type as a string, so that Moose's
auto-vivification of classnames to type will work.
.SS "to_string"
.IX Subsection "to_string"
String representation of the type constraint, approximately as parsed.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Parse::Method::Signatures, MooseX::Types, MooseX::Types::Util.
.SH "AUTHORS"
.IX Header "AUTHORS"
Florian Ragwitz <rafl@debian.org>.
.PP
Ash Berlin <ash@cpan.org>.
.SH "LICENSE"
.IX Header "LICENSE"
Licensed under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Parse::Method::Signatures::TypeConstraint5.18.3pm                                                   0100644 0001750 0001750 00000013372 12566242536 031472  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3                                                                                                                 .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::Method::Signatures::TypeConstraint 3"
.TH Parse::Method::Signatures::TypeConstraint 3 "2013-02-28" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::Method::Signatures::TypeConstraint \- turn parsed TC data into Moose TC object
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Class used to turn \s-1PPI\s0 elements into Moose::Meta::TypeConstraint objects.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "tc"
.IX Subsection "tc"
.RS 4
\&\fBLazy Build.\fR
.RE
.PP
The Moose::Meta::TypeConstraint object for this type constraint, built when
requested. \*(L"tc_callback\*(R" will be called for each individual component type in
turn.
.SS "tc_callback"
.IX Subsection "tc_callback"
.RS 4
\&\fBType:\fR CodeRef
.Sp
\&\fBDefault:\fR \*(L"find_registered_constraint\*(R"
.RE
.PP
Callback used to turn type names into type objects. See
\&\*(L"type_constraint_callback\*(R" in Parse::Method::Signatures for more details and an
example.
.SS "from_namespace"
.IX Subsection "from_namespace"
.RS 4
\&\fBType:\fR ClassName
.RE
.PP
If provided, then the default \f(CW\*(C`tc_callback\*(C'\fR will search for MooseX::Types
in this package.
.SH "METHODS"
.IX Header "METHODS"
.SS "find_registered_constraint"
.IX Subsection "find_registered_constraint"
Will search for an imported MooseX::Types in \*(L"from_namespace\*(R" (if
provided). Failing that it will ask the Moose::Meta::TypeConstraint::Registry
for a type with the given name.
.PP
If all else fails, it will simple return the type as a string, so that Moose's
auto-vivification of classnames to type will work.
.SS "to_string"
.IX Subsection "to_string"
String representation of the type constraint, approximately as parsed.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Parse::Method::Signatures, MooseX::Types, MooseX::Types::Util.
.SH "AUTHORS"
.IX Header "AUTHORS"
Florian Ragwitz <rafl@debian.org>.
.PP
Ash Berlin <ash@cpan.org>.
.SH "LICENSE"
.IX Header "LICENSE"
Licensed under the same terms as Perl itself.
                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::RecDescent.3pm                        0100644 0001750 0001750 00000371331 12566242207 024505  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::RecDescent 3"
.TH Parse::RecDescent 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::RecDescent \- Generate Recursive\-Descent Parsers
.SH "VERSION"
.IX Header "VERSION"
This document describes version 1.967009 of Parse::RecDescent
released March 16th, 2012.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Parse::RecDescent;
\&
\& # Generate a parser from the specification in $grammar:
\&
\&     $parser = new Parse::RecDescent ($grammar);
\&
\& # Generate a parser from the specification in $othergrammar
\&
\&     $anotherparser = new Parse::RecDescent ($othergrammar);
\&
\&
\& # Parse $text using rule \*(Aqstartrule\*(Aq (which must be
\& # defined in $grammar):
\&
\&    $parser\->startrule($text);
\&
\&
\& # Parse $text using rule \*(Aqotherrule\*(Aq (which must also
\& # be defined in $grammar):
\&
\&     $parser\->otherrule($text);
\&
\&
\& # Change the universal token prefix pattern
\& # before building a grammar
\& # (the default is: \*(Aq\es*\*(Aq):
\&
\&    $Parse::RecDescent::skip = \*(Aq[ \et]+\*(Aq;
\&
\&
\& # Replace productions of existing rules (or create new ones)
\& # with the productions defined in $newgrammar:
\&
\&    $parser\->Replace($newgrammar);
\&
\&
\& # Extend existing rules (or create new ones)
\& # by adding extra productions defined in $moregrammar:
\&
\&    $parser\->Extend($moregrammar);
\&
\&
\& # Global flags (useful as command line arguments under \-s):
\&
\&    $::RD_ERRORS       # unless undefined, report fatal errors
\&    $::RD_WARN         # unless undefined, also report non\-fatal problems
\&    $::RD_HINT         # if defined, also suggestion remedies
\&    $::RD_TRACE        # if defined, also trace parsers\*(Aq behaviour
\&    $::RD_AUTOSTUB     # if defined, generates "stubs" for undefined rules
\&    $::RD_AUTOACTION   # if defined, appends specified action to productions
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Overview"
.IX Subsection "Overview"
Parse::RecDescent incrementally generates top-down recursive-descent text
parsers from simple \fIyacc\fR\-like grammar specifications. It provides:
.IP "\(bu" 4
Regular expressions or literal strings as terminals (tokens),
.IP "\(bu" 4
Multiple (non-contiguous) productions for any rule,
.IP "\(bu" 4
Repeated and optional subrules within productions,
.IP "\(bu" 4
Full access to Perl within actions specified as part of the grammar,
.IP "\(bu" 4
Simple automated error reporting during parser generation and parsing,
.IP "\(bu" 4
The ability to commit to, uncommit to, or reject particular
productions during a parse,
.IP "\(bu" 4
The ability to pass data up and down the parse tree (\*(L"down\*(R" via subrule
argument lists, \*(L"up\*(R" via subrule return values)
.IP "\(bu" 4
Incremental extension of the parsing grammar (even during a parse),
.IP "\(bu" 4
Precompilation of parser objects,
.IP "\(bu" 4
User-definable reduce-reduce conflict resolution via
\&\*(L"scoring\*(R" of matching productions.
.ie n .SS "Using ""Parse::RecDescent"""
.el .SS "Using \f(CWParse::RecDescent\fP"
.IX Subsection "Using Parse::RecDescent"
Parser objects are created by calling \f(CW\*(C`Parse::RecDescent::new\*(C'\fR, passing in a
grammar specification (see the following subsections). If the grammar is
correct, \f(CW\*(C`new\*(C'\fR returns a blessed reference which can then be used to initiate
parsing through any rule specified in the original grammar. A typical sequence
looks like this:
.PP
.Vb 3
\&    $grammar = q {
\&        # GRAMMAR SPECIFICATION HERE
\&         };
\&
\&    $parser = new Parse::RecDescent ($grammar) or die "Bad grammar!\en";
\&
\&    # acquire $text
\&
\&    defined $parser\->startrule($text) or print "Bad text!\en";
.Ve
.PP
The rule through which parsing is initiated must be explicitly defined
in the grammar (i.e. for the above example, the grammar must include a
rule of the form: \*(L"startrule: <subrules>\*(R".
.PP
If the starting rule succeeds, its value (see below)
is returned. Failure to generate the original parser or failure to match a text
is indicated by returning \f(CW\*(C`undef\*(C'\fR. Note that it's easy to set up grammars
that can succeed, but which return a value of 0, \*(L"0\*(R", or "".  So don't be
tempted to write:
.PP
.Vb 1
\&    $parser\->startrule($text) or print "Bad text!\en";
.Ve
.PP
Normally, the parser has no effect on the original text. So in the
previous example the value of \f(CW$text\fR would be unchanged after having
been parsed.
.PP
If, however, the text to be matched is passed by reference:
.PP
.Vb 1
\&    $parser\->startrule(\e$text)
.Ve
.PP
then any text which was consumed during the match will be removed from the
start of \f(CW$text\fR.
.SS "Rules"
.IX Subsection "Rules"
In the grammar from which the parser is built, rules are specified by
giving an identifier (which must satisfy /[A\-Za\-z]\ew*/), followed by a
colon \fIon the same line\fR, followed by one or more productions,
separated by single vertical bars. The layout of the productions
is entirely free-format:
.PP
.Vb 3
\&    rule1:  production1
\&     |  production2 |
\&    production3 | production4
.Ve
.PP
At any point in the grammar previously defined rules may be extended with
additional productions. This is achieved by redeclaring the rule with the new
productions. Thus:
.PP
.Vb 3
\&    rule1: a | b | c
\&    rule2: d | e | f
\&    rule1: g | h
.Ve
.PP
is exactly equivalent to:
.PP
.Vb 2
\&    rule1: a | b | c | g | h
\&    rule2: d | e | f
.Ve
.PP
Each production in a rule consists of zero or more items, each of which
may be either: the name of another rule to be matched (a \*(L"subrule\*(R"),
a pattern or string literal to be matched directly (a \*(L"token\*(R"), a
block of Perl code to be executed (an \*(L"action\*(R"), a special instruction
to the parser (a \*(L"directive\*(R"), or a standard Perl comment (which is
ignored).
.PP
A rule matches a text if one of its productions matches. A production
matches if each of its items match consecutive substrings of the
text. The productions of a rule being matched are tried in the same
order that they appear in the original grammar, and the first matching
production terminates the match attempt (successfully). If all
productions are tried and none matches, the match attempt fails.
.PP
Note that this behaviour is quite different from the \*(L"prefer the longer match\*(R"
behaviour of \fIyacc\fR. For example, if \fIyacc\fR were parsing the rule:
.PP
.Vb 2
\&    seq : \*(AqA\*(Aq \*(AqB\*(Aq
\&    | \*(AqA\*(Aq \*(AqB\*(Aq \*(AqC\*(Aq
.Ve
.PP
upon matching \*(L"\s-1AB\*(R"\s0 it would look ahead to see if a 'C' is next and, if
so, will match the second production in preference to the first. In
other words, \fIyacc\fR effectively tries all the productions of a rule
breadth-first in parallel, and selects the \*(L"best\*(R" match, where \*(L"best\*(R"
means longest (note that this is a gross simplification of the true
behaviour of \fIyacc\fR but it will do for our purposes).
.PP
In contrast, \f(CW\*(C`Parse::RecDescent\*(C'\fR tries each production depth-first in
sequence, and selects the \*(L"best\*(R" match, where \*(L"best\*(R" means first. This is
the fundamental difference between \*(L"bottom-up\*(R" and \*(L"recursive descent\*(R"
parsing.
.PP
Each successfully matched item in a production is assigned a value,
which can be accessed in subsequent actions within the same
production (or, in some cases, as the return value of a successful
subrule call). Unsuccessful items don't have an associated value,
since the failure of an item causes the entire surrounding production
to immediately fail. The following sections describe the various types
of items and their success values.
.SS "Subrules"
.IX Subsection "Subrules"
A subrule which appears in a production is an instruction to the parser to
attempt to match the named rule at that point in the text being
parsed. If the named subrule is not defined when requested the
production containing it immediately fails (unless it was \*(L"autostubbed\*(R" \- see
Autostubbing).
.PP
A rule may (recursively) call itself as a subrule, but \fInot\fR as the
left-most item in any of its productions (since such recursions are usually
non-terminating).
.PP
The value associated with a subrule is the value associated with its
\&\f(CW$return\fR variable (see \*(L"Actions\*(R" below), or with the last successfully
matched item in the subrule match.
.PP
Subrules may also be specified with a trailing repetition specifier,
indicating that they are to be (greedily) matched the specified number
of times. The available specifiers are:
.PP
.Vb 7
\&    subrule(?)  # Match one\-or\-zero times
\&    subrule(s)  # Match one\-or\-more times
\&    subrule(s?) # Match zero\-or\-more times
\&    subrule(N)  # Match exactly N times for integer N > 0
\&    subrule(N..M)   # Match between N and M times
\&    subrule(..M)    # Match between 1 and M times
\&    subrule(N..)    # Match at least N times
.Ve
.PP
Repeated subrules keep matching until either the subrule fails to
match, or it has matched the minimal number of times but fails to
consume any of the parsed text (this second condition prevents the
subrule matching forever in some cases).
.PP
Since a repeated subrule may match many instances of the subrule itself, the
value associated with it is not a simple scalar, but rather a reference to a
list of scalars, each of which is the value associated with one of the
individual subrule matches. In other words in the rule:
.PP
.Vb 1
\&    program: statement(s)
.Ve
.PP
the value associated with the repeated subrule \*(L"statement(s)\*(R" is a reference
to an array containing the values matched by each call to the individual
subrule \*(L"statement\*(R".
.PP
Repetition modifiers may include a separator pattern:
.PP
.Vb 1
\&    program: statement(s /;/)
.Ve
.PP
specifying some sequence of characters to be skipped between each repetition.
This is really just a shorthand for the <leftop:...> directive
(see below).
.SS "Tokens"
.IX Subsection "Tokens"
If a quote-delimited string or a Perl regex appears in a production,
the parser attempts to match that string or pattern at that point in
the text. For example:
.PP
.Vb 1
\&    typedef: "typedef" typename identifier \*(Aq;\*(Aq
\&
\&    identifier: /[A\-Za\-z_][A\-Za\-z0\-9_]*/
.Ve
.PP
As in regular Perl, a single quoted string is uninterpolated, whilst
a double-quoted string or a pattern is interpolated (at the time
of matching, \fInot\fR when the parser is constructed). Hence, it is
possible to define rules in which tokens can be set at run-time:
.PP
.Vb 1
\&    typedef: "$::typedefkeyword" typename identifier \*(Aq;\*(Aq
\&
\&    identifier: /$::identpat/
.Ve
.PP
Note that, since each rule is implemented inside a special namespace
belonging to its parser, it is necessary to explicitly quantify
variables from the main package.
.PP
Regex tokens can be specified using just slashes as delimiters
or with the explicit \f(CW\*(C`m<delimiter>......<delimiter>\*(C'\fR syntax:
.PP
.Vb 1
\&    typedef: "typedef" typename identifier \*(Aq;\*(Aq
\&
\&    typename: /[A\-Za\-z_][A\-Za\-z0\-9_]*/
\&
\&    identifier: m{[A\-Za\-z_][A\-Za\-z0\-9_]*}
.Ve
.PP
A regex of either type can also have any valid trailing parameter(s)
(that is, any of [cgimsox]):
.PP
.Vb 1
\&    typedef: "typedef" typename identifier \*(Aq;\*(Aq
\&
\&    identifier: / [a\-z_]        # LEADING ALPHA OR UNDERSCORE
\&          [a\-z0\-9_]*    # THEN DIGITS ALSO ALLOWED
\&        /ix     # CASE/SPACE/COMMENT INSENSITIVE
.Ve
.PP
The value associated with any successfully matched token is a string
containing the actual text which was matched by the token.
.PP
It is important to remember that, since each grammar is specified in a
Perl string, all instances of the universal escape character '\e' within
a grammar must be \*(L"doubled\*(R", so that they interpolate to single '\e's when
the string is compiled. For example, to use the grammar:
.PP
.Vb 3
\&    word:       /\eS+/ | backslash
\&    line:       prefix word(s) "\en"
\&    backslash:  \*(Aq\e\e\*(Aq
.Ve
.PP
the following code is required:
.PP
.Vb 1
\&    $parser = new Parse::RecDescent (q{
\&
\&        word:   /\e\eS+/ | backslash
\&        line:   prefix word(s) "\e\en"
\&        backslash:  \*(Aq\e\e\e\e\*(Aq
\&
\&    });
.Ve
.SS "Anonymous subrules"
.IX Subsection "Anonymous subrules"
Parentheses introduce a nested scope that is very like a call to an anonymous
subrule. Hence they are useful for \*(L"in-lining\*(R" subroutine calls, and other
kinds of grouping behaviour. For example, instead of:
.PP
.Vb 2
\&    word:       /\eS+/ | backslash
\&    line:       prefix word(s) "\en"
.Ve
.PP
you could write:
.PP
.Vb 1
\&    line:       prefix ( /\eS+/ | backslash )(s) "\en"
.Ve
.PP
and get exactly the same effects.
.PP
Parentheses are also use for collecting unrepeated alternations within a
single production.
.PP
.Vb 1
\&    secret_identity: "Mr" ("Incredible"|"Fantastic"|"Sheen") ", Esq."
.Ve
.SS "Terminal Separators"
.IX Subsection "Terminal Separators"
For the purpose of matching, each terminal in a production is considered
to be preceded by a \*(L"prefix\*(R" \- a pattern which must be
matched before a token match is attempted. By default, the
prefix is optional whitespace (which always matches, at
least trivially), but this default may be reset in any production.
.PP
The variable \f(CW$Parse::RecDescent::skip\fR stores the universal
prefix, which is the default for all terminal matches in all parsers
built with \f(CW\*(C`Parse::RecDescent\*(C'\fR.
.PP
If you want to change the universal prefix using
\&\f(CW$Parse::RecDescent::skip\fR, be careful to set it \fIbefore\fR creating
the grammar object, because it is applied statically (when a grammar
is built) rather than dynamically (when the grammar is used).
Alternatively you can provide a global \f(CW\*(C`<skip:...>\*(C'\fR directive
in your grammar before any rules (described later).
.PP
The prefix for an individual production can be altered
by using the \f(CW\*(C`<skip:...>\*(C'\fR directive (described later).
Setting this directive in the top-level rule is an alternative approach
to setting \f(CW$Parse::RecDescent::skip\fR before creating the object, but
in this case you don't get the intended skipping behaviour if you
directly invoke methods different from the top-level rule.
.SS "Actions"
.IX Subsection "Actions"
An action is a block of Perl code which is to be executed (as the
block of a \f(CW\*(C`do\*(C'\fR statement) when the parser reaches that point in a
production. The action executes within a special namespace belonging to
the active parser, so care must be taken in correctly qualifying variable
names (see also \*(L"Start-up Actions\*(R" below).
.PP
The action is considered to succeed if the final value of the block
is defined (that is, if the implied \f(CW\*(C`do\*(C'\fR statement evaluates to a
defined value \- \fIeven one which would be treated as \*(L"false\*(R"\fR). Note
that the value associated with a successful action is also the final
value in the block.
.PP
An action will \fIfail\fR if its last evaluated value is \f(CW\*(C`undef\*(C'\fR. This is
surprisingly easy to accomplish by accident. For instance, here's an
infuriating case of an action that makes its production fail, but only
when debugging \fIisn't\fR activated:
.PP
.Vb 4
\&    description: name rank serial_number
\&        { print "Got $item[2] $item[1] ($item[3])\en"
\&        if $::debugging
\&        }
.Ve
.PP
If \f(CW$debugging\fR is false, no statement in the block is executed, so
the final value is \f(CW\*(C`undef\*(C'\fR, and the entire production fails. The solution is:
.PP
.Vb 5
\&    description: name rank serial_number
\&        { print "Got $item[2] $item[1] ($item[3])\en"
\&        if $::debugging;
\&          1;
\&        }
.Ve
.PP
Within an action, a number of useful parse-time variables are
available in the special parser namespace (there are other variables
also accessible, but meddling with them will probably just break your
parser. As a general rule, if you avoid referring to unqualified
variables \- especially those starting with an underscore \- inside an action,
things should be okay):
.ie n .IP "@item and %item" 4
.el .IP "\f(CW@item\fR and \f(CW%item\fR" 4
.IX Item "@item and %item"
The array slice \f(CW@item[1..$#item]\fR stores the value associated with each item
(that is, each subrule, token, or action) in the current production. The
analogy is to \f(CW$1\fR, \f(CW$2\fR, etc. in a \fIyacc\fR grammar.
Note that, for obvious reasons, \f(CW@item\fR only contains the
values of items \fIbefore\fR the current point in the production.
.Sp
The first element (\f(CW$item[0]\fR) stores the name of the current rule
being matched.
.Sp
\&\f(CW@item\fR is a standard Perl array, so it can also be indexed with negative
numbers, representing the number of items \fIback\fR from the current position in
the parse:
.Sp
.Vb 3
\&    stuff: /various/ bits \*(Aqand\*(Aq pieces "then" data \*(Aqend\*(Aq
\&        { print $item[\-2] }  # PRINTS data
\&             # (EASIER THAN: $item[6])
.Ve
.Sp
The \f(CW%item\fR hash complements the <@item> array, providing named
access to the same item values:
.Sp
.Vb 3
\&    stuff: /various/ bits \*(Aqand\*(Aq pieces "then" data \*(Aqend\*(Aq
\&        { print $item{data}  # PRINTS data
\&             # (EVEN EASIER THAN USING @item)
.Ve
.Sp
The results of named subrules are stored in the hash under each
subrule's name (including the repetition specifier, if any),
whilst all other items are stored under a \*(L"named
positional\*(R" key that indictates their ordinal position within their item
type: _\|_STRING\fIn\fR_\|_, _\|_PATTERN\fIn\fR_\|_, _\|_DIRECTIVE\fIn\fR_\|_, _\|_ACTION\fIn\fR_\|_:
.Sp
.Vb 6
\&    stuff: /various/ bits \*(Aqand\*(Aq pieces "then" data \*(Aqend\*(Aq { save }
\&        { print $item{_\|_PATTERN1_\|_}, # PRINTS \*(Aqvarious\*(Aq
\&        $item{_\|_STRING2_\|_},  # PRINTS \*(Aqthen\*(Aq
\&        $item{_\|_ACTION1_\|_},  # PRINTS RETURN
\&                 # VALUE OF save
\&        }
.Ve
.Sp
If you want proper \fInamed\fR access to patterns or literals, you need to turn
them into separate rules:
.Sp
.Vb 3
\&    stuff: various bits \*(Aqand\*(Aq pieces "then" data \*(Aqend\*(Aq
\&        { print $item{various}  # PRINTS various
\&        }
\&
\&    various: /various/
.Ve
.Sp
The special entry \f(CW$item{_\|_RULE_\|_}\fR stores the name of the current
rule (i.e. the same value as \f(CW$item[0]\fR.
.Sp
The advantage of using \f(CW%item\fR, instead of \f(CW@items\fR is that it
removes the need to track items positions that may change as a grammar
evolves. For example, adding an interim \f(CW\*(C`<skip>\*(C'\fR directive
of action can silently ruin a trailing action, by moving an \f(CW@item\fR
element \*(L"down\*(R" the array one place. In contrast, the named entry
of \f(CW%item\fR is unaffected by such an insertion.
.Sp
A limitation of the \f(CW%item\fR hash is that it only records the \fIlast\fR
value of a particular subrule. For example:
.Sp
.Vb 2
\&    range: \*(Aq(\*(Aq number \*(Aq..\*(Aq number )\*(Aq
\&        { $return = $item{number} }
.Ve
.Sp
will return only the value corresponding to the \fIsecond\fR match of the
\&\f(CW\*(C`number\*(C'\fR subrule. In other words, successive calls to a subrule
overwrite the corresponding entry in \f(CW%item\fR. Once again, the
solution is to rename each subrule in its own rule:
.Sp
.Vb 2
\&    range: \*(Aq(\*(Aq from_num \*(Aq..\*(Aq to_num \*(Aq)\*(Aq
\&        { $return = $item{from_num} }
\&
\&    from_num: number
\&    to_num:   number
.Ve
.ie n .IP "@arg and %arg" 4
.el .IP "\f(CW@arg\fR and \f(CW%arg\fR" 4
.IX Item "@arg and %arg"
The array \f(CW@arg\fR and the hash \f(CW%arg\fR store any arguments passed to
the rule from some other rule (see \*(L"Subrule argument lists\*(R"). Changes
to the elements of either variable do not propagate back to the calling
rule (data can be passed back from a subrule via the \f(CW$return\fR
variable \- see next item).
.ie n .IP "$return" 4
.el .IP "\f(CW$return\fR" 4
.IX Item "$return"
If a value is assigned to \f(CW$return\fR within an action, that value is
returned if the production containing the action eventually matches
successfully. Note that setting \f(CW$return\fR \fIdoesn't\fR cause the current
production to succeed. It merely tells it what to return if it \fIdoes\fR succeed.
Hence \f(CW$return\fR is analogous to \f(CW$$\fR in a \fIyacc\fR grammar.
.Sp
If \f(CW$return\fR is not assigned within a production, the value of the
last component of the production (namely: \f(CW$item[$#item]\fR) is
returned if the production succeeds.
.ie n .IP "$commit" 4
.el .IP "\f(CW$commit\fR" 4
.IX Item "$commit"
The current state of commitment to the current production (see \*(L"Directives\*(R"
below).
.ie n .IP "$skip" 4
.el .IP "\f(CW$skip\fR" 4
.IX Item "$skip"
The current terminal prefix (see \*(L"Directives\*(R" below).
.ie n .IP "$text" 4
.el .IP "\f(CW$text\fR" 4
.IX Item "$text"
The remaining (unparsed) text. Changes to \f(CW$text\fR \fIdo not
propagate\fR out of unsuccessful productions, but \fIdo\fR survive
successful productions. Hence it is possible to dynamically alter the
text being parsed \- for example, to provide a \f(CW\*(C`#include\*(C'\fR\-like facility:
.Sp
.Vb 2
\&    hash_include: \*(Aq#include\*(Aq filename
\&        { $text = ::loadfile($item[2]) . $text }
\&
\&    filename: \*(Aq<\*(Aq /[a\-z0\-9._\-]+/i \*(Aq>\*(Aq  { $return = $item[2] }
\&    | \*(Aq"\*(Aq /[a\-z0\-9._\-]+/i \*(Aq"\*(Aq  { $return = $item[2] }
.Ve
.ie n .IP "$thisline and $prevline" 4
.el .IP "\f(CW$thisline\fR and \f(CW$prevline\fR" 4
.IX Item "$thisline and $prevline"
\&\f(CW$thisline\fR stores the current line number within the current parse
(starting from 1). \f(CW$prevline\fR stores the line number for the last
character which was already successfully parsed (this will be different from
\&\f(CW$thisline\fR at the end of each line).
.Sp
For efficiency, \f(CW$thisline\fR and \f(CW$prevline\fR are actually tied
hashes, and only recompute the required line number when the variable's
value is used.
.Sp
Assignment to \f(CW$thisline\fR adjusts the line number calculator, so that
it believes that the current line number is the value being assigned. Note
that this adjustment will be reflected in all subsequent line numbers
calculations.
.Sp
Modifying the value of the variable \f(CW$text\fR (as in the previous
\&\f(CW\*(C`hash_include\*(C'\fR example, for instance) will confuse the line
counting mechanism. To prevent this, you should call
\&\f(CW\*(C`Parse::RecDescent::LineCounter::resync($thisline)\*(C'\fR \fIimmediately\fR
after any assignment to the variable \f(CW$text\fR (or, at least, before the
next attempt to use \f(CW$thisline\fR).
.Sp
Note that if a production fails after assigning to or
resync'ing \f(CW$thisline\fR, the parser's line counter mechanism will
usually be corrupted.
.Sp
Also see the entry for \f(CW@itempos\fR.
.Sp
The line number can be set to values other than 1, by calling the start
rule with a second argument. For example:
.Sp
.Vb 1
\&    $parser = new Parse::RecDescent ($grammar);
\&
\&    $parser\->input($text, 10);  # START LINE NUMBERS AT 10
.Ve
.ie n .IP "$thiscolumn and $prevcolumn" 4
.el .IP "\f(CW$thiscolumn\fR and \f(CW$prevcolumn\fR" 4
.IX Item "$thiscolumn and $prevcolumn"
\&\f(CW$thiscolumn\fR stores the current column number within the current line
being parsed (starting from 1). \f(CW$prevcolumn\fR stores the column number
of the last character which was actually successfully parsed. Usually
\&\f(CW\*(C`$prevcolumn == $thiscolumn\-1\*(C'\fR, but not at the end of lines.
.Sp
For efficiency, \f(CW$thiscolumn\fR and \f(CW$prevcolumn\fR are
actually tied hashes, and only recompute the required column number
when the variable's value is used.
.Sp
Assignment to \f(CW$thiscolumn\fR or \f(CW$prevcolumn\fR is a fatal error.
.Sp
Modifying the value of the variable \f(CW$text\fR (as in the previous
\&\f(CW\*(C`hash_include\*(C'\fR example, for instance) may confuse the column
counting mechanism.
.Sp
Note that \f(CW$thiscolumn\fR reports the column number \fIbefore\fR any
whitespace that might be skipped before reading a token. Hence
if you wish to know where a token started (and ended) use something like this:
.Sp
.Vb 2
\&    rule: token1 token2 startcol token3 endcol token4
\&        { print "token3: columns $item[3] to $item[5]"; }
\&
\&    startcol: \*(Aq\*(Aq { $thiscolumn }    # NEED THE \*(Aq\*(Aq TO STEP PAST TOKEN SEP
\&    endcol:  { $prevcolumn }
.Ve
.Sp
Also see the entry for \f(CW@itempos\fR.
.ie n .IP "$thisoffset and $prevoffset" 4
.el .IP "\f(CW$thisoffset\fR and \f(CW$prevoffset\fR" 4
.IX Item "$thisoffset and $prevoffset"
\&\f(CW$thisoffset\fR stores the offset of the current parsing position
within the complete text
being parsed (starting from 0). \f(CW$prevoffset\fR stores the offset
of the last character which was actually successfully parsed. In all
cases \f(CW\*(C`$prevoffset == $thisoffset\-1\*(C'\fR.
.Sp
For efficiency, \f(CW$thisoffset\fR and \f(CW$prevoffset\fR are
actually tied hashes, and only recompute the required offset
when the variable's value is used.
.Sp
Assignment to \f(CW$thisoffset\fR or <$prevoffset> is a fatal error.
.Sp
Modifying the value of the variable \f(CW$text\fR will \fInot\fR affect the
offset counting mechanism.
.Sp
Also see the entry for \f(CW@itempos\fR.
.ie n .IP "@itempos" 4
.el .IP "\f(CW@itempos\fR" 4
.IX Item "@itempos"
The array \f(CW@itempos\fR stores a hash reference corresponding to
each element of \f(CW@item\fR. The elements of the hash provide the
following:
.Sp
.Vb 6
\&    $itempos[$n]{offset}{from}  # VALUE OF $thisoffset BEFORE $item[$n]
\&    $itempos[$n]{offset}{to}    # VALUE OF $prevoffset AFTER $item[$n]
\&    $itempos[$n]{line}{from}    # VALUE OF $thisline BEFORE $item[$n]
\&    $itempos[$n]{line}{to}  # VALUE OF $prevline AFTER $item[$n]
\&    $itempos[$n]{column}{from}  # VALUE OF $thiscolumn BEFORE $item[$n]
\&    $itempos[$n]{column}{to}    # VALUE OF $prevcolumn AFTER $item[$n]
.Ve
.Sp
Note that the various \f(CW\*(C`$itempos[$n]...{from}\*(C'\fR values record the
appropriate value \fIafter\fR any token prefix has been skipped.
.Sp
Hence, instead of the somewhat tedious and error-prone:
.Sp
.Vb 9
\&    rule: startcol token1 endcol
\&      startcol token2 endcol
\&      startcol token3 endcol
\&        { print "token1: columns $item[1]
\&              to $item[3]
\&         token2: columns $item[4]
\&              to $item[6]
\&         token3: columns $item[7]
\&              to $item[9]" }
\&
\&    startcol: \*(Aq\*(Aq { $thiscolumn }    # NEED THE \*(Aq\*(Aq TO STEP PAST TOKEN SEP
\&    endcol:  { $prevcolumn }
.Ve
.Sp
it is possible to write:
.Sp
.Vb 7
\&    rule: token1 token2 token3
\&        { print "token1: columns $itempos[1]{column}{from}
\&              to $itempos[1]{column}{to}
\&         token2: columns $itempos[2]{column}{from}
\&              to $itempos[2]{column}{to}
\&         token3: columns $itempos[3]{column}{from}
\&              to $itempos[3]{column}{to}" }
.Ve
.Sp
Note however that (in the current implementation) the use of \f(CW@itempos\fR
anywhere in a grammar implies that item positioning information is
collected \fIeverywhere\fR during the parse. Depending on the grammar
and the size of the text to be parsed, this may be prohibitively
expensive and the explicit use of \f(CW$thisline\fR, \f(CW$thiscolumn\fR, etc. may
be a better choice.
.ie n .IP "$thisparser" 4
.el .IP "\f(CW$thisparser\fR" 4
.IX Item "$thisparser"
A reference to the \f(CW\*(C`Parse::RecDescent\*(C'\fR object through which
parsing was initiated.
.Sp
The value of \f(CW$thisparser\fR propagates down the subrules of a parse
but not back up. Hence, you can invoke subrules from another parser
for the scope of the current rule as follows:
.Sp
.Vb 4
\&    rule: subrule1 subrule2
\&    | { $thisparser = $::otherparser } <reject>
\&    | subrule3 subrule4
\&    | subrule5
.Ve
.Sp
The result is that the production calls \*(L"subrule1\*(R" and \*(L"subrule2\*(R" of
the current parser, and the remaining productions call the named subrules
from \f(CW$::otherparser\fR. Note, however that \*(L"Bad Things\*(R" will happen if
\&\f(CW\*(C`::otherparser\*(C'\fR isn't a blessed reference and/or doesn't have methods
with the same names as the required subrules!
.ie n .IP "$thisrule" 4
.el .IP "\f(CW$thisrule\fR" 4
.IX Item "$thisrule"
A reference to the \f(CW\*(C`Parse::RecDescent::Rule\*(C'\fR object corresponding to the
rule currently being matched.
.ie n .IP "$thisprod" 4
.el .IP "\f(CW$thisprod\fR" 4
.IX Item "$thisprod"
A reference to the \f(CW\*(C`Parse::RecDescent::Production\*(C'\fR object
corresponding to the production currently being matched.
.ie n .IP "$score and $score_return" 4
.el .IP "\f(CW$score\fR and \f(CW$score_return\fR" 4
.IX Item "$score and $score_return"
\&\f(CW$score\fR stores the best production score to date, as specified by
an earlier \f(CW\*(C`<score:...>\*(C'\fR directive. \f(CW$score_return\fR stores
the corresponding return value for the successful production.
.Sp
See \*(L"Scored productions\*(R".
.PP
\&\fBWarning:\fR the parser relies on the information in the various \f(CW\*(C`this...\*(C'\fR
objects in some non-obvious ways. Tinkering with the other members of
these objects will probably cause Bad Things to happen, unless you
\&\fIreally\fR know what you're doing. The only exception to this advice is
that the use of \f(CW\*(C`$this...\->{local}\*(C'\fR is always safe.
.SS "Start-up Actions"
.IX Subsection "Start-up Actions"
Any actions which appear \fIbefore\fR the first rule definition in a
grammar are treated as \*(L"start-up\*(R" actions. Each such action is
stripped of its outermost brackets and then evaluated (in the parser's
special namespace) just before the rules of the grammar are first
compiled.
.PP
The main use of start-up actions is to declare local variables within the
parser's special namespace:
.PP
.Vb 1
\&    { my $lastitem = \*(Aq???\*(Aq; }
\&
\&    list: item(s)   { $return = $lastitem }
\&
\&    item: book  { $lastitem = \*(Aqbook\*(Aq; }
\&      bell  { $lastitem = \*(Aqbell\*(Aq; }
\&      candle    { $lastitem = \*(Aqcandle\*(Aq; }
.Ve
.PP
but start-up actions can be used to execute \fIany\fR valid Perl code
within a parser's special namespace.
.PP
Start-up actions can appear within a grammar extension or replacement
(that is, a partial grammar installed via \f(CW\*(C`Parse::RecDescent::Extend()\*(C'\fR or
\&\f(CW\*(C`Parse::RecDescent::Replace()\*(C'\fR \- see \*(L"Incremental Parsing\*(R"), and will be
executed before the new grammar is installed. Note, however, that a
particular start-up action is only ever executed once.
.SS "Autoactions"
.IX Subsection "Autoactions"
It is sometimes desirable to be able to specify a default action to be
taken at the end of every production (for example, in order to easily
build a parse tree). If the variable \f(CW$::RD_AUTOACTION\fR is defined
when \f(CW\*(C`Parse::RecDescent::new()\*(C'\fR is called, the contents of that
variable are treated as a specification of an action which is to appended
to each production in the corresponding grammar.
.PP
Alternatively, you can hard-code the autoaction within a grammar, using the
\&\f(CW\*(C`<autoaction:...>\*(C'\fR directive.
.PP
So, for example, to construct a simple parse tree you could write:
.PP
.Vb 1
\&    $::RD_AUTOACTION = q { [@item] };
\&
\&    parser = Parse::RecDescent\->new(q{
\&    expression: and_expr \*(Aq||\*(Aq expression | and_expr
\&    and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&    not_expr:   \*(Aq!\*(Aq brack_expr       | brack_expr
\&    brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&    identifier: /[a\-z]+/i
\&    });
.Ve
.PP
or:
.PP
.Vb 2
\&    parser = Parse::RecDescent\->new(q{
\&    <autoaction: { [@item] } >
\&
\&    expression: and_expr \*(Aq||\*(Aq expression | and_expr
\&    and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&    not_expr:   \*(Aq!\*(Aq brack_expr       | brack_expr
\&    brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&    identifier: /[a\-z]+/i
\&    });
.Ve
.PP
Either of these is equivalent to:
.PP
.Vb 5
\&    parser = new Parse::RecDescent (q{
\&    expression: and_expr \*(Aq||\*(Aq expression
\&        { [@item] }
\&      | and_expr
\&        { [@item] }
\&
\&    and_expr:   not_expr \*(Aq&&\*(Aq and_expr
\&        { [@item] }
\&    |   not_expr
\&        { [@item] }
\&
\&    not_expr:   \*(Aq!\*(Aq brack_expr
\&        { [@item] }
\&    |   brack_expr
\&        { [@item] }
\&
\&    brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq
\&        { [@item] }
\&      | identifier
\&        { [@item] }
\&
\&    identifier: /[a\-z]+/i
\&        { [@item] }
\&    });
.Ve
.PP
Alternatively, we could take an object-oriented approach, use different
classes for each node (and also eliminating redundant intermediate nodes):
.PP
.Vb 2
\&    $::RD_AUTOACTION = q
\&      { $#item==1 ? $item[1] : "$item[0]_node"\->new(@item[1..$#item]) };
\&
\&    parser = Parse::RecDescent\->new(q{
\&        expression: and_expr \*(Aq||\*(Aq expression | and_expr
\&        and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&        not_expr:   \*(Aq!\*(Aq brack_expr           | brack_expr
\&        brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&        identifier: /[a\-z]+/i
\&    });
.Ve
.PP
or:
.PP
.Vb 4
\&    parser = Parse::RecDescent\->new(q{
\&        <autoaction:
\&          $#item==1 ? $item[1] : "$item[0]_node"\->new(@item[1..$#item])
\&        >
\&
\&        expression: and_expr \*(Aq||\*(Aq expression | and_expr
\&        and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&        not_expr:   \*(Aq!\*(Aq brack_expr           | brack_expr
\&        brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&        identifier: /[a\-z]+/i
\&    });
.Ve
.PP
which are equivalent to:
.PP
.Vb 4
\&    parser = Parse::RecDescent\->new(q{
\&        expression: and_expr \*(Aq||\*(Aq expression
\&            { "expression_node"\->new(@item[1..3]) }
\&        | and_expr
\&
\&        and_expr:   not_expr \*(Aq&&\*(Aq and_expr
\&            { "and_expr_node"\->new(@item[1..3]) }
\&        |   not_expr
\&
\&        not_expr:   \*(Aq!\*(Aq brack_expr
\&            { "not_expr_node"\->new(@item[1..2]) }
\&        |   brack_expr
\&
\&        brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq
\&            { "brack_expr_node"\->new(@item[1..3]) }
\&        | identifier
\&
\&        identifier: /[a\-z]+/i
\&            { "identifer_node"\->new(@item[1]) }
\&    });
.Ve
.PP
Note that, if a production already ends in an action, no autoaction is appended
to it. For example, in this version:
.PP
.Vb 2
\&    $::RD_AUTOACTION = q
\&      { $#item==1 ? $item[1] : "$item[0]_node"\->new(@item[1..$#item]) };
\&
\&    parser = Parse::RecDescent\->new(q{
\&        expression: and_expr \*(Aq&&\*(Aq expression | and_expr
\&        and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&        not_expr:   \*(Aq!\*(Aq brack_expr           | brack_expr
\&        brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&        identifier: /[a\-z]+/i
\&            { \*(Aqterminal_node\*(Aq\->new($item[1]) }
\&    });
.Ve
.PP
each \f(CW\*(C`identifier\*(C'\fR match produces a \f(CW\*(C`terminal_node\*(C'\fR object, \fInot\fR an
\&\f(CW\*(C`identifier_node\*(C'\fR object.
.PP
A level 1 warning is issued each time an \*(L"autoaction\*(R" is added to
some production.
.SS "Autotrees"
.IX Subsection "Autotrees"
A commonly needed autoaction is one that builds a parse-tree. It is moderately
tricky to set up such an action (which must treat terminals differently from
non-terminals), so Parse::RecDescent simplifies the process by providing the
\&\f(CW\*(C`<autotree>\*(C'\fR directive.
.PP
If this directive appears at the start of grammar, it causes
Parse::RecDescent to insert autoactions at the end of any rule except
those which already end in an action. The action inserted depends on whether
the production is an intermediate rule (two or more items), or a terminal
of the grammar (i.e. a single pattern or string item).
.PP
So, for example, the following grammar:
.PP
.Vb 1
\&    <autotree>
\&
\&    file    : command(s)
\&    command : get | set | vet
\&    get : \*(Aqget\*(Aq ident \*(Aq;\*(Aq
\&    set : \*(Aqset\*(Aq ident \*(Aqto\*(Aq value \*(Aq;\*(Aq
\&    vet : \*(Aqcheck\*(Aq ident \*(Aqis\*(Aq value \*(Aq;\*(Aq
\&    ident   : /\ew+/
\&    value   : /\ed+/
.Ve
.PP
is equivalent to:
.PP
.Vb 7
\&    file    : command(s)        { bless \e%item, $item[0] }
\&    command : get       { bless \e%item, $item[0] }
\&    | set           { bless \e%item, $item[0] }
\&    | vet           { bless \e%item, $item[0] }
\&    get : \*(Aqget\*(Aq ident \*(Aq;\*(Aq   { bless \e%item, $item[0] }
\&    set : \*(Aqset\*(Aq ident \*(Aqto\*(Aq value \*(Aq;\*(Aq    { bless \e%item, $item[0] }
\&    vet : \*(Aqcheck\*(Aq ident \*(Aqis\*(Aq value \*(Aq;\*(Aq  { bless \e%item, $item[0] }
\&
\&    ident   : /\ew+/  { bless {_\|_VALUE_\|_=>$item[1]}, $item[0] }
\&    value   : /\ed+/  { bless {_\|_VALUE_\|_=>$item[1]}, $item[0] }
.Ve
.PP
Note that each node in the tree is blessed into a class of the same name
as the rule itself. This makes it easy to build object-oriented
processors for the parse-trees that the grammar produces. Note too that
the last two rules produce special objects with the single attribute
\&'_\|_VALUE_\|_'. This is because they consist solely of a single terminal.
.PP
This autoaction-ed grammar would then produce a parse tree in a data
structure like this:
.PP
.Vb 10
\&    {
\&      file => {
\&        command => {
\&         [ get => {
\&            identifier => { _\|_VALUE_\|_ => \*(Aqa\*(Aq },
\&              },
\&           set => {
\&            identifier => { _\|_VALUE_\|_ => \*(Aqb\*(Aq },
\&            value      => { _\|_VALUE_\|_ => \*(Aq7\*(Aq },
\&              },
\&           vet => {
\&            identifier => { _\|_VALUE_\|_ => \*(Aqb\*(Aq },
\&            value      => { _\|_VALUE_\|_ => \*(Aq7\*(Aq },
\&              },
\&          ],
\&           },
\&      }
\&    }
.Ve
.PP
(except, of course, that each nested hash would also be blessed into
the appropriate class).
.PP
You can also specify a base class for the \f(CW\*(C`<autotree>\*(C'\fR directive.
The supplied prefix will be prepended to the rule names when creating
tree nodes.  The following are equivalent:
.PP
.Vb 2
\&    <autotree:MyBase::Class>
\&    <autotree:MyBase::Class::>
.Ve
.PP
And will produce a root node blessed into the \f(CW\*(C`MyBase::Class::file\*(C'\fR
package in the example above.
.SS "Autostubbing"
.IX Subsection "Autostubbing"
Normally, if a subrule appears in some production, but no rule of that
name is ever defined in the grammar, the production which refers to the
non-existent subrule fails immediately. This typically occurs as a
result of misspellings, and is a sufficiently common occurance that a
warning is generated for such situations.
.PP
However, when prototyping a grammar it is sometimes useful to be
able to use subrules before a proper specification of them is
really possible.  For example, a grammar might include a section like:
.PP
.Vb 1
\&    function_call: identifier \*(Aq(\*(Aq arg(s?) \*(Aq)\*(Aq
\&
\&    identifier: /[a\-z]\ew*/i
.Ve
.PP
where the possible format of an argument is sufficiently complex that
it is not worth specifying in full until the general function call
syntax has been debugged. In this situation it is convenient to leave
the real rule \f(CW\*(C`arg\*(C'\fR undefined and just slip in a placeholder (or
\&\*(L"stub\*(R"):
.PP
.Vb 1
\&    arg: \*(Aqarg\*(Aq
.Ve
.PP
so that the function call syntax can be tested with dummy input such as:
.PP
.Vb 4
\&    f0()
\&    f1(arg)
\&    f2(arg arg)
\&    f3(arg arg arg)
.Ve
.PP
et cetera.
.PP
Early in prototyping, many such \*(L"stubs\*(R" may be required, so
\&\f(CW\*(C`Parse::RecDescent\*(C'\fR provides a means of automating their definition.
If the variable \f(CW$::RD_AUTOSTUB\fR is defined when a parser is built, a
subrule reference to any non-existent rule (say, \f(CW\*(C`subrule\*(C'\fR), will
cause a \*(L"stub\*(R" rule to be automatically defined in the generated
parser.  If \f(CW\*(C`$::RD_AUTOSTUB eq \*(Aq1\*(Aq\*(C'\fR or is false, a stub rule of the
form:
.PP
.Vb 1
\&    subrule: \*(Aqsubrule\*(Aq
.Ve
.PP
will be generated.  The special-case for a value of \f(CW\*(Aq1\*(Aq\fR is to allow
the use of the \fBperl \-s\fR with \fB\-RD_AUTOSTUB\fR without generating
\&\f(CW\*(C`subrule: \*(Aq1\*(Aq\*(C'\fR per below. If \f(CW$::RD_AUTOSTUB\fR is true, a stub rule
of the form:
.PP
.Vb 1
\&    subrule: $::RD_AUTOSTUB
.Ve
.PP
will be generated.  \f(CW$::RD_AUTOSTUB\fR must contain a valid production
item, no checking is performed.  No lazy evaluation of
\&\f(CW$::RD_AUTOSTUB\fR is performed, it is evaluated at the time the Parser
is generated.
.PP
Hence, with \f(CW$::RD_AUTOSTUB\fR defined, it is possible to only
partially specify a grammar, and then \*(L"fake\*(R" matches of the
unspecified (sub)rules by just typing in their name, or a literal
value that was assigned to \f(CW$::RD_AUTOSTUB\fR.
.SS "Look-ahead"
.IX Subsection "Look-ahead"
If a subrule, token, or action is prefixed by \*(L"...\*(R", then it is
treated as a \*(L"look-ahead\*(R" request. That means that the current production can
(as usual) only succeed if the specified item is matched, but that the matching
\&\fIdoes not consume any of the text being parsed\fR. This is very similar to the
\&\f(CW\*(C`/(?=...)/\*(C'\fR look-ahead construct in Perl patterns. Thus, the rule:
.PP
.Vb 1
\&    inner_word: word ...word
.Ve
.PP
will match whatever the subrule \*(L"word\*(R" matches, provided that match is followed
by some more text which subrule \*(L"word\*(R" would also match (although this
second substring is not actually consumed by \*(L"inner_word\*(R")
.PP
Likewise, a \*(L"...!\*(R" prefix, causes the following item to succeed (without
consuming any text) if and only if it would normally fail. Hence, a
rule such as:
.PP
.Vb 1
\&    identifier: ...!keyword ...!\*(Aq_\*(Aq /[A\-Za\-z_]\ew*/
.Ve
.PP
matches a string of characters which satisfies the pattern
\&\f(CW\*(C`/[A\-Za\-z_]\ew*/\*(C'\fR, but only if the same sequence of characters would
not match either subrule \*(L"keyword\*(R" or the literal token '_'.
.PP
Sequences of look-ahead prefixes accumulate, multiplying their positive and/or
negative senses. Hence:
.PP
.Vb 1
\&    inner_word: word ...!......!word
.Ve
.PP
is exactly equivalent the the original example above (a warning is issued in
cases like these, since they often indicate something left out, or
misunderstood).
.PP
Note that actions can also be treated as look-aheads. In such cases,
the state of the parser text (in the local variable \f(CW$text\fR)
\&\fIafter\fR the look-ahead action is guaranteed to be identical to its
state \fIbefore\fR the action, regardless of how it's changed \fIwithin\fR
the action (unless you actually undefine \f(CW$text\fR, in which case you
get the disaster you deserve :\-).
.SS "Directives"
.IX Subsection "Directives"
Directives are special pre-defined actions which may be used to alter
the behaviour of the parser. There are currently twenty-three directives:
\&\f(CW\*(C`<commit>\*(C'\fR,
\&\f(CW\*(C`<uncommit>\*(C'\fR,
\&\f(CW\*(C`<reject>\*(C'\fR,
\&\f(CW\*(C`<score>\*(C'\fR,
\&\f(CW\*(C`<autoscore>\*(C'\fR,
\&\f(CW\*(C`<skip>\*(C'\fR,
\&\f(CW\*(C`<resync>\*(C'\fR,
\&\f(CW\*(C`<error>\*(C'\fR,
\&\f(CW\*(C`<warn>\*(C'\fR,
\&\f(CW\*(C`<hint>\*(C'\fR,
\&\f(CW\*(C`<trace_build>\*(C'\fR,
\&\f(CW\*(C`<trace_parse>\*(C'\fR,
\&\f(CW\*(C`<nocheck>\*(C'\fR,
\&\f(CW\*(C`<rulevar>\*(C'\fR,
\&\f(CW\*(C`<matchrule>\*(C'\fR,
\&\f(CW\*(C`<leftop>\*(C'\fR,
\&\f(CW\*(C`<rightop>\*(C'\fR,
\&\f(CW\*(C`<defer>\*(C'\fR,
\&\f(CW\*(C`<nocheck>\*(C'\fR,
\&\f(CW\*(C`<perl_quotelike>\*(C'\fR,
\&\f(CW\*(C`<perl_codeblock>\*(C'\fR,
\&\f(CW\*(C`<perl_variable>\*(C'\fR,
and \f(CW\*(C`<token>\*(C'\fR.
.IP "Committing and uncommitting" 4
.IX Item "Committing and uncommitting"
The \f(CW\*(C`<commit>\*(C'\fR and \f(CW\*(C`<uncommit>\*(C'\fR directives permit the recursive
descent of the parse tree to be pruned (or \*(L"cut\*(R") for efficiency.
Within a rule, a \f(CW\*(C`<commit>\*(C'\fR directive instructs the rule to ignore subsequent
productions if the current production fails. For example:
.Sp
.Vb 3
\&    command: \*(Aqfind\*(Aq <commit> filename
\&       | \*(Aqopen\*(Aq <commit> filename
\&       | \*(Aqmove\*(Aq filename filename
.Ve
.Sp
Clearly, if the leading token 'find' is matched in the first production but that
production fails for some other reason, then the remaining
productions cannot possibly match. The presence of the
\&\f(CW\*(C`<commit>\*(C'\fR causes the \*(L"command\*(R" rule to fail immediately if
an invalid \*(L"find\*(R" command is found, and likewise if an invalid \*(L"open\*(R"
command is encountered.
.Sp
It is also possible to revoke a previous commitment. For example:
.Sp
.Vb 5
\&    if_statement: \*(Aqif\*(Aq <commit> condition
\&        \*(Aqthen\*(Aq block <uncommit>
\&        \*(Aqelse\*(Aq block
\&        | \*(Aqif\*(Aq <commit> condition
\&        \*(Aqthen\*(Aq block
.Ve
.Sp
In this case, a failure to find an \*(L"else\*(R" block in the first
production shouldn't preclude trying the second production, but a
failure to find a \*(L"condition\*(R" certainly should.
.Sp
As a special case, any production in which the \fIfirst\fR item is an
\&\f(CW\*(C`<uncommit>\*(C'\fR immediately revokes a preceding \f(CW\*(C`<commit>\*(C'\fR
(even though the production would not otherwise have been tried). For
example, in the rule:
.Sp
.Vb 5
\&    request: \*(Aqexplain\*(Aq expression
\&           | \*(Aqexplain\*(Aq <commit> keyword
\&           | \*(Aqsave\*(Aq
\&           | \*(Aqquit\*(Aq
\&           | <uncommit> term \*(Aq?\*(Aq
.Ve
.Sp
if the text being matched was \*(L"explain?\*(R", and the first two
productions failed, then the \f(CW\*(C`<commit>\*(C'\fR in production two would cause
productions three and four to be skipped, but the leading
\&\f(CW\*(C`<uncommit>\*(C'\fR in the production five would allow that production to
attempt a match.
.Sp
Note in the preceding example, that the \f(CW\*(C`<commit>\*(C'\fR was only placed
in production two. If production one had been:
.Sp
.Vb 1
\&    request: \*(Aqexplain\*(Aq <commit> expression
.Ve
.Sp
then production two would be (inappropriately) skipped if a leading
\&\*(L"explain...\*(R" was encountered.
.Sp
Both \f(CW\*(C`<commit>\*(C'\fR and \f(CW\*(C`<uncommit>\*(C'\fR directives always succeed, and their value
is always 1.
.IP "Rejecting a production" 4
.IX Item "Rejecting a production"
The \f(CW\*(C`<reject>\*(C'\fR directive immediately causes the current production
to fail (it is exactly equivalent to, but more obvious than, the
action \f(CW\*(C`{undef}\*(C'\fR). A \f(CW\*(C`<reject>\*(C'\fR is useful when it is desirable to get
the side effects of the actions in one production, without prejudicing a match
by some other production later in the rule. For example, to insert
tracing code into the parse:
.Sp
.Vb 1
\&    complex_rule: { print "In complex rule...\en"; } <reject>
\&
\&    complex_rule: simple_rule \*(Aq+\*(Aq \*(Aqi\*(Aq \*(Aq*\*(Aq simple_rule
\&        | \*(Aqi\*(Aq \*(Aq*\*(Aq simple_rule
\&        | simple_rule
.Ve
.Sp
It is also possible to specify a conditional rejection, using the
form \f(CW\*(C`<reject:\f(CIcondition\f(CW>\*(C'\fR, which only rejects if the
specified condition is true. This form of rejection is exactly
equivalent to the action \f(CW\*(C`{(\f(CIcondition\f(CW)?undef:1}>\*(C'\fR.
For example:
.Sp
.Vb 4
\&    command: save_command
\&       | restore_command
\&       | <reject: defined $::tolerant> { exit }
\&       | <error: Unknown command. Ignored.>
.Ve
.Sp
A \f(CW\*(C`<reject>\*(C'\fR directive never succeeds (and hence has no
associated value). A conditional rejection may succeed (if its
condition is not satisfied), in which case its value is 1.
.Sp
As an extra optimization, \f(CW\*(C`Parse::RecDescent\*(C'\fR ignores any production
which \fIbegins\fR with an unconditional \f(CW\*(C`<reject>\*(C'\fR directive,
since any such production can never successfully match or have any
useful side-effects. A level 1 warning is issued in all such cases.
.Sp
Note that productions beginning with conditional
\&\f(CW\*(C`<reject:...>\*(C'\fR directives are \fInever\fR \*(L"optimized away\*(R" in
this manner, even if they are always guaranteed to fail (for example:
\&\f(CW\*(C`<reject:1>\*(C'\fR)
.Sp
Due to the way grammars are parsed, there is a minor restriction on the
condition of a conditional \f(CW\*(C`<reject:...>\*(C'\fR: it cannot
contain any raw '<' or '>' characters. For example:
.Sp
.Vb 1
\&    line: cmd <reject: $thiscolumn > max> data
.Ve
.Sp
results in an error when a parser is built from this grammar (since the
grammar parser has no way of knowing whether the first > is a \*(L"less than\*(R"
or the end of the \f(CW\*(C`<reject:...>\*(C'\fR.
.Sp
To overcome this problem, put the condition inside a do{} block:
.Sp
.Vb 1
\&    line: cmd <reject: do{$thiscolumn > max}> data
.Ve
.Sp
Note that the same problem may occur in other directives that take
arguments. The same solution will work in all cases.
.IP "Skipping between terminals" 4
.IX Item "Skipping between terminals"
The \f(CW\*(C`<skip>\*(C'\fR directive enables the terminal prefix used in
a production to be changed. For example:
.Sp
.Vb 1
\&    OneLiner: Command <skip:\*(Aq[ \et]*\*(Aq> Arg(s) /;/
.Ve
.Sp
causes only blanks and tabs to be skipped before terminals in the \f(CW\*(C`Arg\*(C'\fR
subrule (and any of \fIits\fR subrules>, and also before the final \f(CW\*(C`/;/\*(C'\fR terminal.
Once the production is complete, the previous terminal prefix is
reinstated. Note that this implies that distinct productions of a rule
must reset their terminal prefixes individually.
.Sp
The \f(CW\*(C`<skip>\*(C'\fR directive evaluates to the \fIprevious\fR terminal prefix,
so it's easy to reinstate a prefix later in a production:
.Sp
.Vb 1
\&    Command: <skip:","> CSV(s) <skip:$item[1]> Modifier
.Ve
.Sp
The value specified after the colon is interpolated into a pattern, so all of
the following are equivalent (though their efficiency increases down the list):
.Sp
.Vb 1
\&    <skip: "$colon|$comma">   # ASSUMING THE VARS HOLD THE OBVIOUS VALUES
\&
\&    <skip: \*(Aq:|,\*(Aq>
\&
\&    <skip: q{[:,]}>
\&
\&    <skip: qr/[:,]/>
.Ve
.Sp
There is no way of directly setting the prefix for
an entire rule, except as follows:
.Sp
.Vb 3
\&    Rule: <skip: \*(Aq[ \et]*\*(Aq> Prod1
\&        | <skip: \*(Aq[ \et]*\*(Aq> Prod2a Prod2b
\&        | <skip: \*(Aq[ \et]*\*(Aq> Prod3
.Ve
.Sp
or, better:
.Sp
.Vb 6
\&    Rule: <skip: \*(Aq[ \et]*\*(Aq>
\&    (
\&        Prod1
\&      | Prod2a Prod2b
\&      | Prod3
\&    )
.Ve
.Sp
The skip pattern is passed down to subrules, so setting the skip for
the top-level rule as described above actually sets the prefix for the
entire grammar (provided that you only call the method corresponding
to the top-level rule itself). Alternatively, or if you have more than
one top-level rule in your grammar, you can provide a global
\&\f(CW\*(C`<skip>\*(C'\fR directive prior to defining any rules in the
grammar. These are the preferred alternatives to setting
\&\f(CW$Parse::RecDescent::skip\fR.
.Sp
Additionally, using \f(CW\*(C`<skip>\*(C'\fR actually allows you to have
a completely dynamic skipping behaviour. For example:
.Sp
.Vb 1
\&   Rule_with_dynamic_skip: <skip: $::skip_pattern> Rule
.Ve
.Sp
Then you can set \f(CW$::skip_pattern\fR before invoking
\&\f(CW\*(C`Rule_with_dynamic_skip\*(C'\fR and have it skip whatever you specified.
.Sp
\&\fBNote: Up to release 1.51 of Parse::RecDescent, an entirely different
mechanism was used for specifying terminal prefixes. The current method
is not backwards-compatible with that early approach. The current approach
is stable and will not to change again.\fR
.IP "Resynchronization" 4
.IX Item "Resynchronization"
The \f(CW\*(C`<resync>\*(C'\fR directive provides a visually distinctive
means of consuming some of the text being parsed, usually to skip an
erroneous input. In its simplest form \f(CW\*(C`<resync>\*(C'\fR simply
consumes text up to and including the next newline (\f(CW"\en"\fR)
character, succeeding only if the newline is found, in which case it
causes its surrounding rule to return zero on success.
.Sp
In other words, a \f(CW\*(C`<resync>\*(C'\fR is exactly equivalent to the token
\&\f(CW\*(C`/[^\en]*\en/\*(C'\fR followed by the action \f(CW\*(C`{\ $return\ =\ 0\ }\*(C'\fR (except that
productions beginning with a \f(CW\*(C`<resync>\*(C'\fR are ignored when generating
error messages). A typical use might be:
.Sp
.Vb 1
\&    script : command(s)
\&
\&    command: save_command
\&       | restore_command
\&       | <resync> # TRY NEXT LINE, IF POSSIBLE
.Ve
.Sp
It is also possible to explicitly specify a resynchronization
pattern, using the \f(CW\*(C`<resync:\f(CIpattern\f(CW>\*(C'\fR variant. This version
succeeds only if the specified pattern matches (and consumes) the
parsed text. In other words, \f(CW\*(C`<resync:\f(CIpattern\f(CW>\*(C'\fR is exactly
equivalent to the token \f(CW\*(C`/\f(CIpattern\f(CW/\*(C'\fR (followed by a \f(CW\*(C`{\ $return\ =\ 0\ }\*(C'\fR
action). For example, if commands were terminated by newlines or semi-colons:
.Sp
.Vb 3
\&    command: save_command
\&       | restore_command
\&       | <resync:[^;\en]*[;\en]>
.Ve
.Sp
The value of a successfully matched \f(CW\*(C`<resync>\*(C'\fR directive (of either
type) is the text that it consumed. Note, however, that since the
directive also sets \f(CW$return\fR, a production consisting of a lone
\&\f(CW\*(C`<resync>\*(C'\fR succeeds but returns the value zero (which a calling rule
may find useful to distinguish between \*(L"true\*(R" matches and \*(L"tolerant\*(R" matches).
Remember that returning a zero value indicates that the rule \fIsucceeded\fR (since
only an \f(CW\*(C`undef\*(C'\fR denotes failure within \f(CW\*(C`Parse::RecDescent\*(C'\fR parsers.
.IP "Error handling" 4
.IX Item "Error handling"
The \f(CW\*(C`<error>\*(C'\fR directive provides automatic or user-defined
generation of error messages during a parse. In its simplest form
\&\f(CW\*(C`<error>\*(C'\fR prepares an error message based on
the mismatch between the last item expected and the text which cause
it to fail. For example, given the rule:
.Sp
.Vb 3
\&    McCoy: curse \*(Aq,\*(Aq name \*(Aq, I\*(Aqm a doctor, not a\*(Aq a_profession \*(Aq!\*(Aq
\&     | pronoun \*(Aqdead,\*(Aq name \*(Aq!\*(Aq
\&     | <error>
.Ve
.Sp
the following strings would produce the following messages:
.RS 4
.ie n .IP """Amen, Jim!""" 4
.el .IP "``Amen, Jim!''" 4
.IX Item "Amen, Jim!"
.Vb 2
\&       ERROR (line 1): Invalid McCoy: Expected curse or pronoun
\&           not found
.Ve
.ie n .IP """Dammit, Jim, I'm a doctor!""" 4
.el .IP "``Dammit, Jim, I'm a doctor!''" 4
.IX Item "Dammit, Jim, I'm a doctor!"
.Vb 2
\&       ERROR (line 1): Invalid McCoy: Expected ", I\*(Aqm a doctor, not a"
\&           but found ", I\*(Aqm a doctor!" instead
.Ve
.ie n .IP """He's dead,\en""" 4
.el .IP "``He's dead,\en''" 4
.IX Item "He's dead,n"
.Vb 1
\&       ERROR (line 2): Invalid McCoy: Expected name not found
.Ve
.ie n .IP """He's alive!""" 4
.el .IP "``He's alive!''" 4
.IX Item "He's alive!"
.Vb 2
\&       ERROR (line 1): Invalid McCoy: Expected \*(Aqdead,\*(Aq but found
\&           "alive!" instead
.Ve
.ie n .IP """Dammit, Jim, I'm a doctor, not a pointy-eared Vulcan!""" 4
.el .IP "``Dammit, Jim, I'm a doctor, not a pointy-eared Vulcan!''" 4
.IX Item "Dammit, Jim, I'm a doctor, not a pointy-eared Vulcan!"
.Vb 2
\&       ERROR (line 1): Invalid McCoy: Expected a profession but found
\&           "pointy\-eared Vulcan!" instead
.Ve
.RE
.RS 4
.Sp
Note that, when autogenerating error messages, all underscores in any
rule name used in a message are replaced by single spaces (for example
\&\*(L"a_production\*(R" becomes \*(L"a production\*(R"). Judicious choice of rule
names can therefore considerably improve the readability of automatic
error messages (as well as the maintainability of the original
grammar).
.Sp
If the automatically generated error is not sufficient, it is possible to
provide an explicit message as part of the error directive. For example:
.Sp
.Vb 3
\&    Spock: "Fascinating \*(Aq,\*(Aq (name | \*(AqCaptain\*(Aq) \*(Aq.\*(Aq
\&     | "Highly illogical, doctor."
\&     | <error: He never said that!>
.Ve
.Sp
which would result in \fIall\fR failures to parse a \*(L"Spock\*(R" subrule printing the
following message:
.Sp
.Vb 1
\&       ERROR (line <N>): Invalid Spock:  He never said that!
.Ve
.Sp
The error message is treated as a \*(L"qq{...}\*(R" string and interpolated
when the error is generated (\fInot\fR when the directive is specified!).
Hence:
.Sp
.Vb 1
\&    <error: Mystical error near "$text">
.Ve
.Sp
would correctly insert the ambient text string which caused the error.
.Sp
There are two other forms of error directive: \f(CW\*(C`<error?>\*(C'\fR and
\&\f(CW\*(C`<error?:\ msg>\*(C'\fR. These behave just like \f(CW\*(C`<error>\*(C'\fR
and \f(CW\*(C`<error:\ msg>\*(C'\fR respectively, except that they are
only triggered if the rule is \*(L"committed\*(R" at the time they are
encountered. For example:
.Sp
.Vb 3
\&    Scotty: "Ya kenna change the Laws of Phusics," <commit> name
\&      | name <commit> \*(Aq,\*(Aq \*(Aqshe\*(Aqs goanta blaw!\*(Aq
\&      | <error?>
.Ve
.Sp
will only generate an error for a string beginning with \*(L"Ya kenna
change the Laws o' Phusics,\*(R" or a valid name, but which still fails to match the
corresponding production. That is, \f(CW\*(C`$parser\->Scotty("Aye, Cap\*(Aqain")\*(C'\fR will
fail silently (since neither production will \*(L"commit\*(R" the rule on that
input), whereas \f(CW\*(C`$parser\->Scotty("Mr\ Spock,\ ah\ jest\ kenna\ do\*(Aqut!")\*(C'\fR
will fail with the error message:
.Sp
.Vb 2
\&       ERROR (line 1): Invalid Scotty: expected \*(Aqshe\*(Aqs goanta blaw!\*(Aq
\&           but found \*(AqI jest kenna do\*(Aqut!\*(Aq instead.
.Ve
.Sp
since in that case the second production would commit after matching
the leading name.
.Sp
Note that to allow this behaviour, all \f(CW\*(C`<error>\*(C'\fR directives which are
the first item in a production automatically uncommit the rule just
long enough to allow their production to be attempted (that is, when
their production fails, the commitment is reinstated so that
subsequent productions are skipped).
.Sp
In order to \fIpermanently\fR uncommit the rule before an error message,
it is necessary to put an explicit \f(CW\*(C`<uncommit>\*(C'\fR before the
\&\f(CW\*(C`<error>\*(C'\fR. For example:
.Sp
.Vb 5
\&    line: \*(AqKirk:\*(Aq  <commit> Kirk
\&    | \*(AqSpock:\*(Aq <commit> Spock
\&    | \*(AqMcCoy:\*(Aq <commit> McCoy
\&    | <uncommit> <error?> <reject>
\&    | <resync>
.Ve
.Sp
Error messages generated by the various \f(CW\*(C`<error...>\*(C'\fR directives
are not displayed immediately. Instead, they are \*(L"queued\*(R" in a buffer and
are only displayed once parsing ultimately fails. Moreover,
\&\f(CW\*(C`<error...>\*(C'\fR directives that cause one production of a rule
to fail are automatically removed from the message queue
if another production subsequently causes the entire rule to succeed.
This means that you can put
\&\f(CW\*(C`<error...>\*(C'\fR directives wherever useful diagnosis can be done,
and only those associated with actual parser failure will ever be
displayed. Also see \*(L"\s-1GOTCHAS\*(R"\s0.
.Sp
As a general rule, the most useful diagnostics are usually generated
either at the very lowest level within the grammar, or at the very
highest. A good rule of thumb is to identify those subrules which
consist mainly (or entirely) of terminals, and then put an
\&\f(CW\*(C`<error...>\*(C'\fR directive at the end of any other rule which calls
one or more of those subrules.
.Sp
There is one other situation in which the output of the various types of
error directive is suppressed; namely, when the rule containing them
is being parsed as part of a \*(L"look-ahead\*(R" (see \*(L"Look-ahead\*(R"). In this
case, the error directive will still cause the rule to fail, but will do
so silently.
.Sp
An unconditional \f(CW\*(C`<error>\*(C'\fR directive always fails (and hence has no
associated value). This means that encountering such a directive
always causes the production containing it to fail. Hence an
\&\f(CW\*(C`<error>\*(C'\fR directive will inevitably be the last (useful) item of a
rule (a level 3 warning is issued if a production contains items after an unconditional
\&\f(CW\*(C`<error>\*(C'\fR directive).
.Sp
An \f(CW\*(C`<error?>\*(C'\fR directive will \fIsucceed\fR (that is: fail to fail :\-), if
the current rule is uncommitted when the directive is encountered. In
that case the directive's associated value is zero. Hence, this type
of error directive \fIcan\fR be used before the end of a
production. For example:
.Sp
.Vb 3
\&    command: \*(Aqdo\*(Aq <commit> something
\&       | \*(Aqreport\*(Aq <commit> something
\&       | <error?: Syntax error> <error: Unknown command>
.Ve
.Sp
\&\fBWarning:\fR The \f(CW\*(C`<error?>\*(C'\fR directive does \fInot\fR mean \*(L"always fail (but
do so silently unless committed)\*(R". It actually means "only fail (and report) if
committed, otherwise \fIsucceed\fR\*(L". To achieve the \*(R"fail silently if uncommitted"
semantics, it is necessary to use:
.Sp
.Vb 2
\&    rule: item <commit> item(s)
\&    | <error?> <reject>  # FAIL SILENTLY UNLESS COMMITTED
.Ve
.Sp
However, because people seem to expect a lone \f(CW\*(C`<error?>\*(C'\fR directive
to work like this:
.Sp
.Vb 3
\&    rule: item <commit> item(s)
\&    | <error?: Error message if committed>
\&    | <error:  Error message if uncommitted>
.Ve
.Sp
Parse::RecDescent automatically appends a
\&\f(CW\*(C`<reject>\*(C'\fR directive if the \f(CW\*(C`<error?>\*(C'\fR directive
is the only item in a production. A level 2 warning (see below)
is issued when this happens.
.Sp
The level of error reporting during both parser construction and
parsing is controlled by the presence or absence of four global
variables: \f(CW$::RD_ERRORS\fR, \f(CW$::RD_WARN\fR, \f(CW$::RD_HINT\fR, and
<$::RD_TRACE>. If \f(CW$::RD_ERRORS\fR is defined (and, by default, it is)
then fatal errors are reported.
.Sp
Whenever \f(CW$::RD_WARN\fR is defined, certain non-fatal problems are also reported.
.Sp
Warnings have an associated \*(L"level\*(R": 1, 2, or 3. The higher the level,
the more serious the warning. The value of the corresponding global
variable (\f(CW$::RD_WARN\fR) determines the \fIlowest\fR level of warning to
be displayed. Hence, to see \fIall\fR warnings, set \f(CW$::RD_WARN\fR to 1.
To see only the most serious warnings set \f(CW$::RD_WARN\fR to 3.
By default \f(CW$::RD_WARN\fR is initialized to 3, ensuring that serious but
non-fatal errors are automatically reported.
.Sp
There is also a grammar directive to turn on warnings from within the
grammar: \f(CW\*(C`<warn>\*(C'\fR. It takes an optional argument, which specifies
the warning level: \f(CW\*(C`<warn: 2>\*(C'\fR.
.Sp
See \fI\*(L"\s-1DIAGNOSTICS\*(R"\s0\fR for a list of the varous error and warning messages
that Parse::RecDescent generates when these two variables are defined.
.Sp
Defining any of the remaining variables (which are not defined by
default) further increases the amount of information reported.
Defining \f(CW$::RD_HINT\fR causes the parser generator to offer
more detailed analyses and hints on both errors and warnings.
Note that setting \f(CW$::RD_HINT\fR at any point automagically
sets \f(CW$::RD_WARN\fR to 1. There is also a \f(CW\*(C`<hint>\*(C'\fR directive, which can
be hard-coded into a grammar.
.Sp
Defining \f(CW$::RD_TRACE\fR causes the parser generator and the parser to
report their progress to \s-1STDERR\s0 in excruciating detail (although, without hints
unless \f(CW$::RD_HINT\fR is separately defined). This detail
can be moderated in only one respect: if \f(CW$::RD_TRACE\fR has an
integer value (\fIN\fR) greater than 1, only the \fIN\fR characters of
the \*(L"current parsing context\*(R" (that is, where in the input string we
are at any point in the parse) is reported at any time.
.Sp
\&\f(CW$::RD_TRACE\fR is mainly useful for debugging a grammar that isn't
behaving as you expected it to. To this end, if \f(CW$::RD_TRACE\fR is
defined when a parser is built, any actual parser code which is
generated is also written to a file named \*(L"\s-1RD_TRACE\*(R"\s0 in the local
directory.
.Sp
There are two directives associated with the \f(CW$::RD_TRACE\fR variable.
If a grammar contains a \f(CW\*(C`<trace_build>\*(C'\fR directive anywhere in its
specification, \f(CW$::RD_TRACE\fR is turned on during the parser construction
phase.  If a grammar contains a \f(CW\*(C`<trace_parse>\*(C'\fR directive anywhere in its
specification, \f(CW$::RD_TRACE\fR is turned on during any parse the parser
performs.
.Sp
Note that the four variables belong to the \*(L"main\*(R" package, which
makes them easier to refer to in the code controlling the parser, and
also makes it easy to turn them into command line flags (\*(L"\-RD_ERRORS\*(R",
\&\*(L"\-RD_WARN\*(R", \*(L"\-RD_HINT\*(R", \*(L"\-RD_TRACE\*(R") under \fBperl \-s\fR.
.Sp
The corresponding directives are useful to \*(L"hardwire\*(R" the various
debugging features into a particular grammar (rather than having to set
and reset external variables).
.RE
.IP "Redirecting diagnostics" 4
.IX Item "Redirecting diagnostics"
The diagnostics provided by the tracing mechanism always go to \s-1STDERR.\s0
If you need them to go elsewhere, localize and reopen \s-1STDERR\s0 prior to the
parse.
.Sp
For example:
.Sp
.Vb 2
\&    {
\&        local *STDERR = IO::File\->new(">$filename") or die $!;
\&
\&        my $result = $parser\->startrule($text);
\&    }
.Ve
.IP "Consistency checks" 4
.IX Item "Consistency checks"
Whenever a parser is build, Parse::RecDescent carries out a number of
(potentially expensive) consistency checks. These include: verifying that the
grammar is not left-recursive and that no rules have been left undefined.
.Sp
These checks are important safeguards during development, but unnecessary
overheads when the grammar is stable and ready to be deployed. So
Parse::RecDescent provides a directive to disable them: \f(CW\*(C`<nocheck>\*(C'\fR.
.Sp
If a grammar contains a \f(CW\*(C`<nocheck>\*(C'\fR directive anywhere in its
specification, the extra compile-time checks are by-passed.
.IP "Specifying local variables" 4
.IX Item "Specifying local variables"
It is occasionally convenient to specify variables which are local
to a single rule. This may be achieved by including a
\&\f(CW\*(C`<rulevar:...>\*(C'\fR directive anywhere in the rule. For example:
.Sp
.Vb 1
\&    markup: <rulevar: $tag>
\&
\&    markup: tag {($tag=$item[1]) =~ s/^<|>$//g} body[$tag]
.Ve
.Sp
The example \f(CW\*(C`<rulevar: $tag>\*(C'\fR directive causes a \*(L"my\*(R" variable named
\&\f(CW$tag\fR to be declared at the start of the subroutine implementing the
\&\f(CW\*(C`markup\*(C'\fR rule (that is, \fIbefore\fR the first production, regardless of
where in the rule it is specified).
.Sp
Specifically, any directive of the form:
\&\f(CW\*(C`<rulevar:\f(CItext\f(CW>\*(C'\fR causes a line of the form \f(CW\*(C`my \f(CItext\f(CW;\*(C'\fR
to be added at the beginning of the rule subroutine, immediately after
the definitions of the following local variables:
.Sp
.Vb 4
\&    $thisparser $commit
\&    $thisrule   @item
\&    $thisline   @arg
\&    $text   %arg
.Ve
.Sp
This means that the following \f(CW\*(C`<rulevar>\*(C'\fR directives work
as expected:
.Sp
.Vb 1
\&    <rulevar: $count = 0 >
\&
\&    <rulevar: $firstarg = $arg[0] || \*(Aq\*(Aq >
\&
\&    <rulevar: $myItems = \e@item >
\&
\&    <rulevar: @context = ( $thisline, $text, @arg ) >
\&
\&    <rulevar: ($name,$age) = $arg{"name","age"} >
.Ve
.Sp
If a variable that is also visible to subrules is required, it needs
to be \f(CW\*(C`local\*(C'\fR'd, not \f(CW\*(C`my\*(C'\fR'd. \f(CW\*(C`rulevar\*(C'\fR defaults to \f(CW\*(C`my\*(C'\fR, but if \f(CW\*(C`local\*(C'\fR
is explicitly specified:
.Sp
.Vb 1
\&    <rulevar: local $count = 0 >
.Ve
.Sp
then a \f(CW\*(C`local\*(C'\fR\-ized variable is declared instead, and will be available
within subrules.
.Sp
Note however that, because all such variables are \*(L"my\*(R" variables, their
values \fIdo not persist\fR between match attempts on a given rule. To
preserve values between match attempts, values can be stored within the
\&\*(L"local\*(R" member of the \f(CW$thisrule\fR object:
.Sp
.Vb 6
\&    countedrule: { $thisrule\->{"local"}{"count"}++ }
\&         <reject>
\&       | subrule1
\&       | subrule2
\&       | <reject: $thisrule\->{"local"}{"count"} == 1>
\&         subrule3
.Ve
.Sp
When matching a rule, each \f(CW\*(C`<rulevar>\*(C'\fR directive is matched as
if it were an unconditional \f(CW\*(C`<reject>\*(C'\fR directive (that is, it
causes any production in which it appears to immediately fail to match).
For this reason (and to improve readability) it is usual to specify any
\&\f(CW\*(C`<rulevar>\*(C'\fR directive in a separate production at the start of
the rule (this has the added advantage that it enables
\&\f(CW\*(C`Parse::RecDescent\*(C'\fR to optimize away such productions, just as it does
for the \f(CW\*(C`<reject>\*(C'\fR directive).
.IP "Dynamically matched rules" 4
.IX Item "Dynamically matched rules"
Because regexes and double-quoted strings are interpolated, it is relatively
easy to specify productions with \*(L"context sensitive\*(R" tokens. For example:
.Sp
.Vb 1
\&    command:  keyword  body  "end $item[1]"
.Ve
.Sp
which ensures that a command block is bounded by a
"\fI<keyword>\fR...end \fI<same keyword>\fR" pair.
.Sp
Building productions in which subrules are context sensitive is also possible,
via the \f(CW\*(C`<matchrule:...>\*(C'\fR directive. This directive behaves
identically to a subrule item, except that the rule which is invoked to match
it is determined by the string specified after the colon. For example, we could
rewrite the \f(CW\*(C`command\*(C'\fR rule like this:
.Sp
.Vb 1
\&    command:  keyword  <matchrule:body>  "end $item[1]"
.Ve
.Sp
Whatever appears after the colon in the directive is treated as an interpolated
string (that is, as if it appeared in \f(CW\*(C`qq{...}\*(C'\fR operator) and the value of
that interpolated string is the name of the subrule to be matched.
.Sp
Of course, just putting a constant string like \f(CW\*(C`body\*(C'\fR in a
\&\f(CW\*(C`<matchrule:...>\*(C'\fR directive is of little interest or benefit.
The power of directive is seen when we use a string that interpolates
to something interesting. For example:
.Sp
.Vb 1
\&    command:    keyword <matchrule:$item[1]_body> "end $item[1]"
\&
\&    keyword:    \*(Aqwhile\*(Aq | \*(Aqif\*(Aq | \*(Aqfunction\*(Aq
\&
\&    while_body: condition block
\&
\&    if_body:    condition block (\*(Aqelse\*(Aq block)(?)
\&
\&    function_body:  arglist block
.Ve
.Sp
Now the \f(CW\*(C`command\*(C'\fR rule selects how to proceed on the basis of the keyword
that is found. It is as if \f(CW\*(C`command\*(C'\fR were declared:
.Sp
.Vb 3
\&    command:    \*(Aqwhile\*(Aq    while_body    "end while"
\&       |    \*(Aqif\*(Aq       if_body   "end if"
\&       |    \*(Aqfunction\*(Aq function_body "end function"
.Ve
.Sp
When a \f(CW\*(C`<matchrule:...>\*(C'\fR directive is used as a repeated
subrule, the rule name expression is \*(L"late-bound\*(R". That is, the name of
the rule to be called is re-evaluated \fIeach time\fR a match attempt is
made. Hence, the following grammar:
.Sp
.Vb 1
\&    { $::species = \*(Aqdogs\*(Aq }
\&
\&    pair:   \*(Aqtwo\*(Aq <matchrule:$::species>(s)
\&
\&    dogs:   /dogs/ { $::species = \*(Aqcats\*(Aq }
\&
\&    cats:   /cats/
.Ve
.Sp
will match the string \*(L"two dogs cats cats\*(R" completely, whereas it will
only match the string \*(L"two dogs dogs dogs\*(R" up to the eighth letter. If
the rule name were \*(L"early bound\*(R" (that is, evaluated only the first
time the directive is encountered in a production), the reverse
behaviour would be expected.
.Sp
Note that the \f(CW\*(C`matchrule\*(C'\fR directive takes a string that is to be treated
as a rule name, \fInot\fR as a rule invocation. That is,
it's like a Perl symbolic reference, not an \f(CW\*(C`eval\*(C'\fR. Just as you can say:
.Sp
.Vb 1
\&    $subname = \*(Aqfoo\*(Aq;
\&
\&    # and later...
\&
\&    &{$foo}(@args);
.Ve
.Sp
but not:
.Sp
.Vb 1
\&    $subname = \*(Aqfoo(@args)\*(Aq;
\&
\&    # and later...
\&
\&    &{$foo};
.Ve
.Sp
likewise you can say:
.Sp
.Vb 1
\&    $rulename = \*(Aqfoo\*(Aq;
\&
\&    # and in the grammar...
\&
\&    <matchrule:$rulename>[@args]
.Ve
.Sp
but not:
.Sp
.Vb 1
\&    $rulename = \*(Aqfoo[@args]\*(Aq;
\&
\&    # and in the grammar...
\&
\&    <matchrule:$rulename>
.Ve
.IP "Deferred actions" 4
.IX Item "Deferred actions"
The \f(CW\*(C`<defer:...>\*(C'\fR directive is used to specify an action to be
performed when (and only if!) the current production ultimately succeeds.
.Sp
Whenever a \f(CW\*(C`<defer:...>\*(C'\fR directive appears, the code it specifies
is converted to a closure (an anonymous subroutine reference) which is
queued within the active parser object. Note that,
because the deferred code is converted to a closure, the values of any
\&\*(L"local\*(R" variable (such as \f(CW$text\fR, <@item>, etc.) are preserved
until the deferred code is actually executed.
.Sp
If the parse ultimately succeeds
\&\fIand\fR the production in which the \f(CW\*(C`<defer:...>\*(C'\fR directive was
evaluated formed part of the successful parse, then the deferred code is
executed immediately before the parse returns. If however the production
which queued a deferred action fails, or one of the higher-level
rules which called that production fails, then the deferred action is
removed from the queue, and hence is never executed.
.Sp
For example, given the grammar:
.Sp
.Vb 2
\&    sentence: noun trans noun
\&    | noun intrans
\&
\&    noun:     \*(Aqthe dog\*(Aq
\&        { print "$item[1]\et(noun)\en" }
\&    |     \*(Aqthe meat\*(Aq
\&        { print "$item[1]\et(noun)\en" }
\&
\&    trans:    \*(Aqate\*(Aq
\&        { print "$item[1]\et(transitive)\en" }
\&
\&    intrans:  \*(Aqate\*(Aq
\&        { print "$item[1]\et(intransitive)\en" }
\&       |  \*(Aqbarked\*(Aq
\&        { print "$item[1]\et(intransitive)\en" }
.Ve
.Sp
then parsing the sentence \f(CW"the dog ate"\fR would produce the output:
.Sp
.Vb 4
\&    the dog  (noun)
\&    ate  (transitive)
\&    the dog  (noun)
\&    ate  (intransitive)
.Ve
.Sp
This is because, even though the first production of \f(CW\*(C`sentence\*(C'\fR
ultimately fails, its initial subrules \f(CW\*(C`noun\*(C'\fR and \f(CW\*(C`trans\*(C'\fR do match,
and hence they execute their associated actions.
Then the second production of \f(CW\*(C`sentence\*(C'\fR succeeds, causing the
actions of the subrules \f(CW\*(C`noun\*(C'\fR and \f(CW\*(C`intrans\*(C'\fR to be executed as well.
.Sp
On the other hand, if the actions were replaced by \f(CW\*(C`<defer:...>\*(C'\fR
directives:
.Sp
.Vb 2
\&    sentence: noun trans noun
\&    | noun intrans
\&
\&    noun:     \*(Aqthe dog\*(Aq
\&        <defer: print "$item[1]\et(noun)\en" >
\&    |     \*(Aqthe meat\*(Aq
\&        <defer: print "$item[1]\et(noun)\en" >
\&
\&    trans:    \*(Aqate\*(Aq
\&        <defer: print "$item[1]\et(transitive)\en" >
\&
\&    intrans:  \*(Aqate\*(Aq
\&        <defer: print "$item[1]\et(intransitive)\en" >
\&       |  \*(Aqbarked\*(Aq
\&        <defer: print "$item[1]\et(intransitive)\en" >
.Ve
.Sp
the output would be:
.Sp
.Vb 2
\&    the dog  (noun)
\&    ate  (intransitive)
.Ve
.Sp
since deferred actions are only executed if they were evaluated in
a production which ultimately contributes to the successful parse.
.Sp
In this case, even though the first production of \f(CW\*(C`sentence\*(C'\fR caused
the subrules \f(CW\*(C`noun\*(C'\fR and \f(CW\*(C`trans\*(C'\fR to match, that production ultimately
failed and so the deferred actions queued by those subrules were subsequently
disgarded. The second production then succeeded, causing the entire
parse to succeed, and so the deferred actions queued by the (second) match of
the \f(CW\*(C`noun\*(C'\fR subrule and the subsequent match of \f(CW\*(C`intrans\*(C'\fR \fIare\fR preserved and
eventually executed.
.Sp
Deferred actions provide a means of improving the performance of a parser,
by only executing those actions which are part of the final parse-tree
for the input data.
.Sp
Alternatively, deferred actions can be viewed as a mechanism for building
(and executing) a
customized subroutine corresponding to the given input data, much in the
same way that autoactions (see \*(L"Autoactions\*(R") can be used to build a
customized data structure for specific input.
.Sp
Whether or not the action it specifies is ever executed,
a \f(CW\*(C`<defer:...>\*(C'\fR directive always succeeds, returning the
number of deferred actions currently queued at that point.
.IP "Parsing Perl" 4
.IX Item "Parsing Perl"
Parse::RecDescent provides limited support for parsing subsets of Perl,
namely: quote-like operators, Perl variables, and complete code blocks.
.Sp
The \f(CW\*(C`<perl_quotelike>\*(C'\fR directive can be used to parse any Perl
quote-like operator: \f(CW\*(Aqa string\*(Aq\fR, \f(CW\*(C`m/a pattern/\*(C'\fR, \f(CW\*(C`tr{ans}{lation}\*(C'\fR,
etc.  It does this by calling \fIText::Balanced::quotelike()\fR.
.Sp
If a quote-like operator is found, a reference to an array of eight elements
is returned. Those elements are identical to the last eight elements returned
by \fIText::Balanced::extract_quotelike()\fR in an array context, namely:
.RS 4
.IP "[0]" 4
.IX Item "[0]"
the name of the quotelike operator \*(-- 'q', 'qq', 'm', 's', 'tr' \*(-- if the
operator was named; otherwise \f(CW\*(C`undef\*(C'\fR,
.IP "[1]" 4
.IX Item "[1]"
the left delimiter of the first block of the operation,
.IP "[2]" 4
.IX Item "[2]"
the text of the first block of the operation
(that is, the contents of
a quote, the regex of a match, or substitution or the target list of a
translation),
.IP "[3]" 4
.IX Item "[3]"
the right delimiter of the first block of the operation,
.IP "[4]" 4
.IX Item "[4]"
the left delimiter of the second block of the operation if there is one
(that is, if it is a \f(CW\*(C`s\*(C'\fR, \f(CW\*(C`tr\*(C'\fR, or \f(CW\*(C`y\*(C'\fR); otherwise \f(CW\*(C`undef\*(C'\fR,
.IP "[5]" 4
.IX Item "[5]"
the text of the second block of the operation if there is one
(that is, the replacement of a substitution or the translation list
of a translation); otherwise \f(CW\*(C`undef\*(C'\fR,
.IP "[6]" 4
.IX Item "[6]"
the right delimiter of the second block of the operation (if any);
otherwise \f(CW\*(C`undef\*(C'\fR,
.IP "[7]" 4
.IX Item "[7]"
the trailing modifiers on the operation (if any); otherwise \f(CW\*(C`undef\*(C'\fR.
.RE
.RS 4
.Sp
If a quote-like expression is not found, the directive fails with the usual
\&\f(CW\*(C`undef\*(C'\fR value.
.Sp
The \f(CW\*(C`<perl_variable>\*(C'\fR directive can be used to parse any Perl
variable: \f(CW$scalar\fR, \f(CW@array\fR, \f(CW%hash\fR, \f(CW$ref\fR\->{field}[$index], etc.
It does this by calling \fIText::Balanced::extract_variable()\fR.
.Sp
If the directive matches text representing a valid Perl variable
specification, it returns that text. Otherwise it fails with the usual
\&\f(CW\*(C`undef\*(C'\fR value.
.Sp
The \f(CW\*(C`<perl_codeblock>\*(C'\fR directive can be used to parse curly-brace-delimited block of Perl code, such as: { \f(CW$a\fR = 1; f() =~ m/pat/; }.
It does this by calling \fIText::Balanced::extract_codeblock()\fR.
.Sp
If the directive matches text representing a valid Perl code block,
it returns that text. Otherwise it fails with the usual \f(CW\*(C`undef\*(C'\fR value.
.Sp
You can also tell it what kind of brackets to use as the outermost
delimiters. For example:
.Sp
.Vb 1
\&    arglist: <perl_codeblock ()>
.Ve
.Sp
causes an arglist to match a perl code block whose outermost delimiters
are \f(CW\*(C`(...)\*(C'\fR (rather than the default \f(CW\*(C`{...}\*(C'\fR).
.RE
.IP "Constructing tokens" 4
.IX Item "Constructing tokens"
Eventually, Parse::RecDescent will be able to parse tokenized input, as
well as ordinary strings. In preparation for this joyous day, the
\&\f(CW\*(C`<token:...>\*(C'\fR directive has been provided.
This directive creates a token which will be suitable for
input to a Parse::RecDescent parser (when it eventually supports
tokenized input).
.Sp
The text of the token is the value of the
immediately preceding item in the production. A
\&\f(CW\*(C`<token:...>\*(C'\fR directive always succeeds with a return
value which is the hash reference that is the new token. It also
sets the return value for the production to that hash ref.
.Sp
The \f(CW\*(C`<token:...>\*(C'\fR directive makes it easy to build
a Parse::RecDescent\-compatible lexer in Parse::RecDescent:
.Sp
.Vb 3
\&    my $lexer = new Parse::RecDescent q
\&    {
\&    lex:    token(s)
\&
\&    token:  /a\eb/          <token:INDEF>
\&         |  /the\eb/        <token:DEF>
\&         |  /fly\eb/        <token:NOUN,VERB>
\&         |  /[a\-z]+/i { lc $item[1] }  <token:ALPHA>
\&         |  <error: Unknown token>
\&
\&    };
.Ve
.Sp
which will eventually be able to be used with a regular Parse::RecDescent
grammar:
.Sp
.Vb 3
\&    my $parser = new Parse::RecDescent q
\&    {
\&    startrule: subrule1 subrule 2
\&
\&    # ETC...
\&    };
.Ve
.Sp
either with a pre-lexing phase:
.Sp
.Vb 1
\&    $parser\->startrule( $lexer\->lex($data) );
.Ve
.Sp
or with a lex-on-demand approach:
.Sp
.Vb 1
\&    $parser\->startrule( sub{$lexer\->token(\e$data)} );
.Ve
.Sp
But at present, only the \f(CW\*(C`<token:...>\*(C'\fR directive is
actually implemented. The rest is vapourware.
.IP "Specifying operations" 4
.IX Item "Specifying operations"
One of the commonest requirements when building a parser is to specify
binary operators. Unfortunately, in a normal grammar, the rules for
such things are awkward:
.Sp
.Vb 2
\&    disjunction:    conjunction (\*(Aqor\*(Aq conjunction)(s?)
\&        { $return = [ $item[1], @{$item[2]} ] }
\&
\&    conjunction:    atom (\*(Aqand\*(Aq atom)(s?)
\&        { $return = [ $item[1], @{$item[2]} ] }
.Ve
.Sp
or inefficient:
.Sp
.Vb 4
\&    disjunction:    conjunction \*(Aqor\*(Aq disjunction
\&        { $return = [ $item[1], @{$item[2]} ] }
\&       |    conjunction
\&        { $return = [ $item[1] ] }
\&
\&    conjunction:    atom \*(Aqand\*(Aq conjunction
\&        { $return = [ $item[1], @{$item[2]} ] }
\&       |    atom
\&        { $return = [ $item[1] ] }
.Ve
.Sp
and either way is ugly and hard to get right.
.Sp
The \f(CW\*(C`<leftop:...>\*(C'\fR and \f(CW\*(C`<rightop:...>\*(C'\fR directives provide an
easier way of specifying such operations. Using \f(CW\*(C`<leftop:...>\*(C'\fR the
above examples become:
.Sp
.Vb 2
\&    disjunction:    <leftop: conjunction \*(Aqor\*(Aq conjunction>
\&    conjunction:    <leftop: atom \*(Aqand\*(Aq atom>
.Ve
.Sp
The \f(CW\*(C`<leftop:...>\*(C'\fR directive specifies a left-associative binary operator.
It is specified around three other grammar elements
(typically subrules or terminals), which match the left operand,
the operator itself, and the right operand respectively.
.Sp
A \f(CW\*(C`<leftop:...>\*(C'\fR directive such as:
.Sp
.Vb 1
\&    disjunction:    <leftop: conjunction \*(Aqor\*(Aq conjunction>
.Ve
.Sp
is converted to the following:
.Sp
.Vb 2
\&    disjunction:    ( conjunction (\*(Aqor\*(Aq conjunction)(s?)
\&        { $return = [ $item[1], @{$item[2]} ] } )
.Ve
.Sp
In other words, a \f(CW\*(C`<leftop:...>\*(C'\fR directive matches the left operand followed by zero
or more repetitions of both the operator and the right operand. It then
flattens the matched items into an anonymous array which becomes the
(single) value of the entire \f(CW\*(C`<leftop:...>\*(C'\fR directive.
.Sp
For example, an \f(CW\*(C`<leftop:...>\*(C'\fR directive such as:
.Sp
.Vb 1
\&    output:  <leftop: ident \*(Aq<<\*(Aq expr >
.Ve
.Sp
when given a string such as:
.Sp
.Vb 1
\&    cout << var << "str" << 3
.Ve
.Sp
would match, and \f(CW$item[1]\fR would be set to:
.Sp
.Vb 1
\&    [ \*(Aqcout\*(Aq, \*(Aqvar\*(Aq, \*(Aq"str"\*(Aq, \*(Aq3\*(Aq ]
.Ve
.Sp
In other words:
.Sp
.Vb 1
\&    output:  <leftop: ident \*(Aq<<\*(Aq expr >
.Ve
.Sp
is equivalent to a left-associative operator:
.Sp
.Vb 5
\&    output:  ident          { $return = [$item[1]]   }
\&          |  ident \*(Aq<<\*(Aq expr        { $return = [@item[1,3]]     }
\&          |  ident \*(Aq<<\*(Aq expr \*(Aq<<\*(Aq expr      { $return = [@item[1,3,5]]   }
\&          |  ident \*(Aq<<\*(Aq expr \*(Aq<<\*(Aq expr \*(Aq<<\*(Aq expr    { $return = [@item[1,3,5,7]] }
\&          #  ...etc...
.Ve
.Sp
Similarly, the \f(CW\*(C`<rightop:...>\*(C'\fR directive takes a left operand, an operator, and a right operand:
.Sp
.Vb 1
\&    assign:  <rightop: var \*(Aq=\*(Aq expr >
.Ve
.Sp
and converts them to:
.Sp
.Vb 2
\&    assign:  ( (var \*(Aq=\*(Aq {$return=$item[1]})(s?) expr
\&        { $return = [ @{$item[1]}, $item[2] ] } )
.Ve
.Sp
which is equivalent to a right-associative operator:
.Sp
.Vb 5
\&    assign:  expr       { $return = [$item[1]]       }
\&          |  var \*(Aq=\*(Aq expr       { $return = [@item[1,3]]     }
\&          |  var \*(Aq=\*(Aq var \*(Aq=\*(Aq expr   { $return = [@item[1,3,5]]   }
\&          |  var \*(Aq=\*(Aq var \*(Aq=\*(Aq var \*(Aq=\*(Aq expr   { $return = [@item[1,3,5,7]] }
\&          #  ...etc...
.Ve
.Sp
Note that for both the \f(CW\*(C`<leftop:...>\*(C'\fR and \f(CW\*(C`<rightop:...>\*(C'\fR directives, the directive does not normally
return the operator itself, just a list of the operands involved. This is
particularly handy for specifying lists:
.Sp
.Vb 2
\&    list: \*(Aq(\*(Aq <leftop: list_item \*(Aq,\*(Aq list_item> \*(Aq)\*(Aq
\&        { $return = $item[2] }
.Ve
.Sp
There is, however, a problem: sometimes the operator is itself significant.
For example, in a Perl list a comma and a \f(CW\*(C`=>\*(C'\fR are both
valid separators, but the \f(CW\*(C`=>\*(C'\fR has additional stringification semantics.
Hence it's important to know which was used in each case.
.Sp
To solve this problem the
\&\f(CW\*(C`<leftop:...>\*(C'\fR and \f(CW\*(C`<rightop:...>\*(C'\fR directives
\&\fIdo\fR return the operator(s) as well, under two circumstances.
The first case is where the operator is specified as a subrule. In that instance,
whatever the operator matches is returned (on the assumption that if the operator
is important enough to have its own subrule, then it's important enough to return).
.Sp
The second case is where the operator is specified as a regular
expression. In that case, if the first bracketed subpattern of the
regular expression matches, that matching value is returned (this is analogous to
the behaviour of the Perl \f(CW\*(C`split\*(C'\fR function, except that only the first subpattern
is returned).
.Sp
In other words, given the input:
.Sp
.Vb 1
\&    ( a=>1, b=>2 )
.Ve
.Sp
the specifications:
.Sp
.Vb 1
\&    list:      \*(Aq(\*(Aq  <leftop: list_item separator list_item>  \*(Aq)\*(Aq
\&
\&    separator: \*(Aq,\*(Aq | \*(Aq=>\*(Aq
.Ve
.Sp
or:
.Sp
.Vb 1
\&    list:      \*(Aq(\*(Aq  <leftop: list_item /(,|=>)/ list_item>  \*(Aq)\*(Aq
.Ve
.Sp
cause the list separators to be interleaved with the operands in the
anonymous array in \f(CW$item[2]\fR:
.Sp
.Vb 1
\&    [ \*(Aqa\*(Aq, \*(Aq=>\*(Aq, \*(Aq1\*(Aq, \*(Aq,\*(Aq, \*(Aqb\*(Aq, \*(Aq=>\*(Aq, \*(Aq2\*(Aq ]
.Ve
.Sp
But the following version:
.Sp
.Vb 1
\&    list:      \*(Aq(\*(Aq  <leftop: list_item /,|=>/ list_item>  \*(Aq)\*(Aq
.Ve
.Sp
returns only the operators:
.Sp
.Vb 1
\&    [ \*(Aqa\*(Aq, \*(Aq1\*(Aq, \*(Aqb\*(Aq, \*(Aq2\*(Aq ]
.Ve
.Sp
Of course, none of the above specifications handle the case of an empty
list, since the \f(CW\*(C`<leftop:...>\*(C'\fR and \f(CW\*(C`<rightop:...>\*(C'\fR directives
require at least a single right or left operand to match. To specify
that the operator can match \*(L"trivially\*(R",
it's necessary to add a \f(CW\*(C`(s?)\*(C'\fR qualifier to the directive:
.Sp
.Vb 1
\&    list:      \*(Aq(\*(Aq  <leftop: list_item /(,|=>)/ list_item>(s?)  \*(Aq)\*(Aq
.Ve
.Sp
Note that in almost all the above examples, the first and third arguments
of the \f(CW\*(C`<leftop:...>\*(C'\fR directive were the same subrule. That is because
\&\f(CW\*(C`<leftop:...>\*(C'\fR's are frequently used to specify \*(L"separated\*(R" lists of the
same type of item. To make such lists easier to specify, the following
syntax:
.Sp
.Vb 1
\&    list:   element(s /,/)
.Ve
.Sp
is exactly equivalent to:
.Sp
.Vb 1
\&    list:   <leftop: element /,/ element>
.Ve
.Sp
Note that the separator must be specified as a raw pattern (i.e.
not a string or subrule).
.IP "Scored productions" 4
.IX Item "Scored productions"
By default, Parse::RecDescent grammar rules always accept the first
production that matches the input. But if two or more productions may
potentially match the same input, choosing the first that does so may
not be optimal.
.Sp
For example, if you were parsing the sentence \*(L"time flies like an arrow\*(R",
you might use a rule like this:
.Sp
.Vb 3
\&    sentence: verb noun preposition article noun { [@item] }
\&    | adjective noun verb article noun   { [@item] }
\&    | noun verb preposition article noun { [@item] }
.Ve
.Sp
Each of these productions matches the sentence, but the third one
is the most likely interpretation. However, if the sentence had been
\&\*(L"fruit flies like a banana\*(R", then the second production is probably
the right match.
.Sp
To cater for such situtations, the \f(CW\*(C`<score:...>\*(C'\fR can be used.
The directive is equivalent to an unconditional \f(CW\*(C`<reject>\*(C'\fR,
except that it allows you to specify a \*(L"score\*(R" for the current
production. If that score is numerically greater than the best
score of any preceding production, the current production is cached for later
consideration. If no later production matches, then the cached
production is treated as having matched, and the value of the
item immediately before its \f(CW\*(C`<score:...>\*(C'\fR directive is returned as the
result.
.Sp
In other words, by putting a \f(CW\*(C`<score:...>\*(C'\fR directive at the end of
each production, you can select which production matches using
criteria other than specification order. For example:
.Sp
.Vb 3
\&    sentence: verb noun preposition article noun { [@item] } <score: sensible(@item)>
\&    | adjective noun verb article noun   { [@item] } <score: sensible(@item)>
\&    | noun verb preposition article noun { [@item] } <score: sensible(@item)>
.Ve
.Sp
Now, when each production reaches its respective \f(CW\*(C`<score:...>\*(C'\fR
directive, the subroutine \f(CW\*(C`sensible\*(C'\fR will be called to evaluate the
matched items (somehow). Once all productions have been tried, the
one which \f(CW\*(C`sensible\*(C'\fR scored most highly will be the one that is
accepted as a match for the rule.
.Sp
The variable \f(CW$score\fR always holds the current best score of any production,
and the variable \f(CW$score_return\fR holds the corresponding return value.
.Sp
As another example, the following grammar matches lines that may be
separated by commas, colons, or semi-colons. This can be tricky if
a colon-separated line also contains commas, or vice versa. The grammar
resolves the ambiguity by selecting the rule that results in the
fewest fields:
.Sp
.Vb 3
\&    line: seplist[sep=>\*(Aq,\*(Aq]  <score: \-@{$item[1]}>
\&    | seplist[sep=>\*(Aq:\*(Aq]  <score: \-@{$item[1]}>
\&    | seplist[sep=>" "]  <score: \-@{$item[1]}>
\&
\&    seplist: <skip:""> <leftop: /[^$arg{sep}]*/ "$arg{sep}" /[^$arg{sep}]*/>
.Ve
.Sp
Note the use of negation within the \f(CW\*(C`<score:...>\*(C'\fR directive
to ensure that the seplist with the most items gets the lowest score.
.Sp
As the above examples indicate, it is often the case that all productions
in a rule use exactly the same \f(CW\*(C`<score:...>\*(C'\fR directive. It is
tedious to have to repeat this identical directive in every production, so
Parse::RecDescent also provides the \f(CW\*(C`<autoscore:...>\*(C'\fR directive.
.Sp
If an \f(CW\*(C`<autoscore:...>\*(C'\fR directive appears in any
production of a rule, the code it specifies is used as the scoring
code for every production of that rule, except productions that already
end with an explicit \f(CW\*(C`<score:...>\*(C'\fR directive. Thus the rules above could
be rewritten:
.Sp
.Vb 4
\&    line: <autoscore: \-@{$item[1]}>
\&    line: seplist[sep=>\*(Aq,\*(Aq]
\&    | seplist[sep=>\*(Aq:\*(Aq]
\&    | seplist[sep=>" "]
\&
\&
\&    sentence: <autoscore: sensible(@item)>
\&    | verb noun preposition article noun { [@item] }
\&    | adjective noun verb article noun   { [@item] }
\&    | noun verb preposition article noun { [@item] }
.Ve
.Sp
Note that the \f(CW\*(C`<autoscore:...>\*(C'\fR directive itself acts as an
unconditional \f(CW\*(C`<reject>\*(C'\fR, and (like the \f(CW\*(C`<rulevar:...>\*(C'\fR
directive) is pruned at compile-time wherever possible.
.IP "Dispensing with grammar checks" 4
.IX Item "Dispensing with grammar checks"
During the compilation phase of parser construction, Parse::RecDescent performs
a small number of checks on the grammar it's given. Specifically it checks that
the grammar is not left-recursive, that there are no \*(L"insatiable\*(R" constructs of
the form:
.Sp
.Vb 1
\&    rule: subrule(s) subrule
.Ve
.Sp
and that there are no rules missing (i.e. referred to, but never defined).
.Sp
These checks are important during development, but can slow down parser
construction in stable code. So Parse::RecDescent provides the
<nocheck> directive to turn them off. The directive can only appear
before the first rule definition, and switches off checking throughout the rest
of the current grammar.
.Sp
Typically, this directive would be added when a parser has been thoroughly
tested and is ready for release.
.SS "Subrule argument lists"
.IX Subsection "Subrule argument lists"
It is occasionally useful to pass data to a subrule which is being invoked. For
example, consider the following grammar fragment:
.PP
.Vb 1
\&    classdecl: keyword decl
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      # WHATEVER
.Ve
.PP
The \f(CW\*(C`decl\*(C'\fR rule might wish to know which of the two keywords was used
(since it may affect some aspect of the way the subsequent declaration
is interpreted). \f(CW\*(C`Parse::RecDescent\*(C'\fR allows the grammar designer to
pass data into a rule, by placing that data in an \fIargument list\fR
(that is, in square brackets) immediately after any subrule item in a
production. Hence, we could pass the keyword to \f(CW\*(C`decl\*(C'\fR as follows:
.PP
.Vb 1
\&    classdecl: keyword decl[ $item[1] ]
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      # WHATEVER
.Ve
.PP
The argument list can consist of any number (including zero!) of comma-separated
Perl expressions. In other words, it looks exactly like a Perl anonymous
array reference. For example, we could pass the keyword, the name of the
surrounding rule, and the literal 'keyword' to \f(CW\*(C`decl\*(C'\fR like so:
.PP
.Vb 1
\&    classdecl: keyword decl[$item[1],$item[0],\*(Aqkeyword\*(Aq]
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      # WHATEVER
.Ve
.PP
Within the rule to which the data is passed (\f(CW\*(C`decl\*(C'\fR in the above examples)
that data is available as the elements of a local variable \f(CW@arg\fR. Hence
\&\f(CW\*(C`decl\*(C'\fR might report its intentions as follows:
.PP
.Vb 1
\&    classdecl: keyword decl[$item[1],$item[0],\*(Aqkeyword\*(Aq]
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      { print "Declaring $arg[0] (a $arg[2])\en";
\&         print "(this rule called by $arg[1])" }
.Ve
.PP
Subrule argument lists can also be interpreted as hashes, simply by using
the local variable \f(CW%arg\fR instead of \f(CW@arg\fR. Hence we could rewrite the
previous example:
.PP
.Vb 3
\&    classdecl: keyword decl[keyword => $item[1],
\&        caller  => $item[0],
\&        type    => \*(Aqkeyword\*(Aq]
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      { print "Declaring $arg{keyword} (a $arg{type})\en";
\&         print "(this rule called by $arg{caller})" }
.Ve
.PP
Both \f(CW@arg\fR and \f(CW%arg\fR are always available, so the grammar designer may
choose whichever convention (or combination of conventions) suits best.
.PP
Subrule argument lists are also useful for creating \*(L"rule templates\*(R"
(especially when used in conjunction with the \f(CW\*(C`<matchrule:...>\*(C'\fR
directive). For example, the subrule:
.PP
.Vb 4
\&    list:     <matchrule:$arg{rule}> /$arg{sep}/ list[%arg]
\&        { $return = [ $item[1], @{$item[3]} ] }
\&    |     <matchrule:$arg{rule}>
\&        { $return = [ $item[1]] }
.Ve
.PP
is a handy template for the common problem of matching a separated list.
For example:
.PP
.Vb 1
\&    function: \*(Aqfunc\*(Aq name \*(Aq(\*(Aq list[rule=>\*(Aqparam\*(Aq,sep=>\*(Aq;\*(Aq] \*(Aq)\*(Aq
\&
\&    param:    list[rule=>\*(Aqname\*(Aq,sep=>\*(Aq,\*(Aq] \*(Aq:\*(Aq typename
\&
\&    name:     /\ew+/
\&
\&    typename: name
.Ve
.PP
When a subrule argument list is used with a repeated subrule, the argument list
goes \fIbefore\fR the repetition specifier:
.PP
.Vb 1
\&    list:   /some|many/ thing[ $item[1] ](s)
.Ve
.PP
The argument list is \*(L"late bound\*(R". That is, it is re-evaluated for every
repetition of the repeated subrule.
This means that each repeated attempt to match the subrule may be
passed a completely different set of arguments if the value of the
expression in the argument list changes between attempts. So, for
example, the grammar:
.PP
.Vb 1
\&    { $::species = \*(Aqdogs\*(Aq }
\&
\&    pair:   \*(Aqtwo\*(Aq animal[$::species](s)
\&
\&    animal: /$arg[0]/ { $::species = \*(Aqcats\*(Aq }
.Ve
.PP
will match the string \*(L"two dogs cats cats\*(R" completely, whereas
it will only match the string \*(L"two dogs dogs dogs\*(R" up to the
eighth letter. If the value of the argument list were \*(L"early bound\*(R"
(that is, evaluated only the first time a repeated subrule match is
attempted), one would expect the matching behaviours to be reversed.
.PP
Of course, it is possible to effectively \*(L"early bind\*(R" such argument lists
by passing them a value which does not change on each repetition. For example:
.PP
.Vb 1
\&    { $::species = \*(Aqdogs\*(Aq }
\&
\&    pair:   \*(Aqtwo\*(Aq { $::species } animal[$item[2]](s)
\&
\&    animal: /$arg[0]/ { $::species = \*(Aqcats\*(Aq }
.Ve
.PP
Arguments can also be passed to the start rule, simply by appending them
to the argument list with which the start rule is called (\fIafter\fR the
\&\*(L"line number\*(R" parameter). For example, given:
.PP
.Vb 1
\&    $parser = new Parse::RecDescent ( $grammar );
\&
\&    $parser\->data($text, 1, "str", 2, \e@arr);
\&
\&    #         ^^^^^  ^  ^^^^^^^^^^^^^^^
\&    #       |    |     |
\&    # TEXT TO BE PARSED  |     |
\&    # STARTING LINE NUMBER     |
\&    # ELEMENTS OF @arg WHICH IS PASSED TO RULE data
.Ve
.PP
then within the productions of the rule \f(CW\*(C`data\*(C'\fR, the array \f(CW@arg\fR will contain
\&\f(CW\*(C`("str", 2, \e@arr)\*(C'\fR.
.SS "Alternations"
.IX Subsection "Alternations"
Alternations are implicit (unnamed) rules defined as part of a production. An
alternation is defined as a series of '|'\-separated productions inside a
pair of round brackets. For example:
.PP
.Vb 1
\&    character: \*(Aqthe\*(Aq ( good | bad | ugly ) /dude/
.Ve
.PP
Every alternation implicitly defines a new subrule, whose
automatically-generated name indicates its origin:
\&\*(L"_alternation_<I>_of_production_<P>_of_rule<R>\*(R" for the appropriate
values of <I>, <P>, and <R>. A call to this implicit subrule is then
inserted in place of the brackets. Hence the above example is merely a
convenient short-hand for:
.PP
.Vb 3
\&    character: \*(Aqthe\*(Aq
\&       _alternation_1_of_production_1_of_rule_character
\&       /dude/
\&
\&    _alternation_1_of_production_1_of_rule_character:
\&       good | bad | ugly
.Ve
.PP
Since alternations are parsed by recursively calling the parser generator,
any type(s) of item can appear in an alternation. For example:
.PP
.Vb 5
\&    character: \*(Aqthe\*(Aq ( \*(Aqhigh\*(Aq "plains"  # Silent, with poncho
\&         | /no[\- ]name/ # Silent, no poncho
\&         | vengeance_seeking    # Poncho\-optional
\&         | <error>
\&         ) drifter
.Ve
.PP
In this case, if an error occurred, the automatically generated
message would be:
.PP
.Vb 3
\&    ERROR (line <N>): Invalid implicit subrule: Expected
\&          \*(Aqhigh\*(Aq or /no[\- ]name/ or generic,
\&          but found "pacifist" instead
.Ve
.PP
Since every alternation actually has a name, it's even possible
to extend or replace them:
.PP
.Vb 4
\&    parser\->Replace(
\&    "_alternation_1_of_production_1_of_rule_character:
\&        \*(Aqgeneric Eastwood\*(Aq"
\&        );
.Ve
.PP
More importantly, since alternations are a form of subrule, they can be given
repetition specifiers:
.PP
.Vb 1
\&    character: \*(Aqthe\*(Aq ( good | bad | ugly )(?) /dude/
.Ve
.SS "Incremental Parsing"
.IX Subsection "Incremental Parsing"
\&\f(CW\*(C`Parse::RecDescent\*(C'\fR provides two methods \- \f(CW\*(C`Extend\*(C'\fR and \f(CW\*(C`Replace\*(C'\fR \- which
can be used to alter the grammar matched by a parser. Both methods
take the same argument as \f(CW\*(C`Parse::RecDescent::new\*(C'\fR, namely a
grammar specification string
.PP
\&\f(CW\*(C`Parse::RecDescent::Extend\*(C'\fR interprets the grammar specification and adds any
productions it finds to the end of the rules for which they are specified. For
example:
.PP
.Vb 2
\&    $add = "name: \*(AqJimmy\-Bob\*(Aq | \*(AqBobby\-Jim\*(Aq\endesc: colour /necks?/";
\&    parser\->Extend($add);
.Ve
.PP
adds two productions to the rule \*(L"name\*(R" (creating it if necessary) and one
production to the rule \*(L"desc\*(R".
.PP
\&\f(CW\*(C`Parse::RecDescent::Replace\*(C'\fR is identical, except that it first resets are
rule specified in the additional grammar, removing any existing productions.
Hence after:
.PP
.Vb 2
\&    $add = "name: \*(AqJimmy\-Bob\*(Aq | \*(AqBobby\-Jim\*(Aq\endesc: colour /necks?/";
\&    parser\->Replace($add);
.Ve
.PP
are are \fIonly\fR valid \*(L"name\*(R"s and the one possible description.
.PP
A more interesting use of the \f(CW\*(C`Extend\*(C'\fR and \f(CW\*(C`Replace\*(C'\fR methods is to call them
inside the action of an executing parser. For example:
.PP
.Vb 3
\&    typedef: \*(Aqtypedef\*(Aq type_name identifier \*(Aq;\*(Aq
\&           { $thisparser\->Extend("type_name: \*(Aq$item[3]\*(Aq") }
\&       | <error>
\&
\&    identifier: ...!type_name /[A\-Za\-z_]w*/
.Ve
.PP
which automatically prevents type names from being typedef'd, or:
.PP
.Vb 6
\&    command: \*(Aqmap\*(Aq key_name \*(Aqto\*(Aq abort_key
\&           { $thisparser\->Replace("abort_key: \*(Aq$item[2]\*(Aq") }
\&       | \*(Aqmap\*(Aq key_name \*(Aqto\*(Aq key_name
\&           { map_key($item[2],$item[4]) }
\&       | abort_key
\&           { exit if confirm("abort?") }
\&
\&    abort_key: \*(Aqq\*(Aq
\&
\&    key_name: ...!abort_key /[A\-Za\-z]/
.Ve
.PP
which allows the user to change the abort key binding, but not to unbind it.
.PP
The careful use of such constructs makes it possible to reconfigure a
a running parser, eliminating the need for semantic feedback by
providing syntactic feedback instead. However, as currently implemented,
\&\f(CW\*(C`Replace()\*(C'\fR and \f(CW\*(C`Extend()\*(C'\fR have to regenerate and re\-\f(CW\*(C`eval\*(C'\fR the
entire parser whenever they are called. This makes them quite slow for
large grammars.
.PP
In such cases, the judicious use of an interpolated regex is likely to
be far more efficient:
.PP
.Vb 3
\&    typedef: \*(Aqtypedef\*(Aq type_name/ identifier \*(Aq;\*(Aq
\&           { $thisparser\->{local}{type_name} .= "|$item[3]" }
\&       | <error>
\&
\&    identifier: ...!type_name /[A\-Za\-z_]w*/
\&
\&    type_name: /$thisparser\->{local}{type_name}/
.Ve
.SS "Precompiling parsers"
.IX Subsection "Precompiling parsers"
Normally Parse::RecDescent builds a parser from a grammar at run-time.
That approach simplifies the design and implementation of parsing code,
but has the disadvantage that it slows the parsing process down \- you
have to wait for Parse::RecDescent to build the parser every time the
program runs. Long or complex grammars can be particularly slow to
build, leading to unacceptable delays at start-up.
.PP
To overcome this, the module provides a way of \*(L"pre-building\*(R" a parser
object and saving it in a separate module. That module can then be used
to create clones of the original parser.
.PP
A grammar may be precompiled using the \f(CW\*(C`Precompile\*(C'\fR class method.
For example, to precompile a grammar stored in the scalar \f(CW$grammar\fR,
and produce a class named PreGrammar in a module file named PreGrammar.pm,
you could use:
.PP
.Vb 1
\&    use Parse::RecDescent;
\&
\&    Parse::RecDescent\->Precompile([$options_hashref], $grammar, "PreGrammar");
.Ve
.PP
The first required argument is the grammar string, the second is the
name of the class to be built. The name of the module file is
generated automatically by appending \*(L".pm\*(R" to the last element of the
class name. Thus
.PP
.Vb 1
\&    Parse::RecDescent\->Precompile($grammar, "My::New::Parser");
.Ve
.PP
would produce a module file named Parser.pm.
.PP
An optional hash reference may be supplied as the first argument to
\&\f(CW\*(C`Precompile\*(C'\fR.  This argument is currently \s-1EXPERIMENTAL,\s0 and may change
in a future release of Parse::RecDescent.  The only supported option
is currently \f(CW\*(C`\-standalone\*(C'\fR, see \*(L"Standalone Precompiled Parsers\*(R".
.PP
It is somewhat tedious to have to write a small Perl program just to
generate a precompiled grammar class, so Parse::RecDescent has some special
magic that allows you to do the job directly from the command-line.
.PP
If your grammar is specified in a file named \fIgrammar\fR, you can generate
a class named Yet::Another::Grammar like so:
.PP
.Vb 1
\&    > perl \-MParse::RecDescent \- grammar Yet::Another::Grammar
.Ve
.PP
This would produce a file named \fIGrammar.pm\fR containing the full
definition of a class called Yet::Another::Grammar. Of course, to use
that class, you would need to put the \fIGrammar.pm\fR file in a
directory named \fIYet/Another\fR, somewhere in your Perl include path.
.PP
Having created the new class, it's very easy to use it to build
a parser. You simply \f(CW\*(C`use\*(C'\fR the new module, and then call its
\&\f(CW\*(C`new\*(C'\fR method to create a parser object. For example:
.PP
.Vb 2
\&    use Yet::Another::Grammar;
\&    my $parser = Yet::Another::Grammar\->new();
.Ve
.PP
The effect of these two lines is exactly the same as:
.PP
.Vb 1
\&    use Parse::RecDescent;
\&
\&    open GRAMMAR_FILE, "grammar" or die;
\&    local $/;
\&    my $grammar = <GRAMMAR_FILE>;
\&
\&    my $parser = Parse::RecDescent\->new($grammar);
.Ve
.PP
only considerably faster.
.PP
Note however that the parsers produced by either approach are exactly
the same, so whilst precompilation has an effect on \fIset-up\fR speed,
it has no effect on \fIparsing\fR speed. RecDescent 2.0 will address that
problem.
.PP
\fIStandalone Precompiled Parsers\fR
.IX Subsection "Standalone Precompiled Parsers"
.PP
Until version 1.967003 of Parse::RecDescent, parser modules built with
\&\f(CW\*(C`Precompile\*(C'\fR were dependent on Parse::RecDescent.  Future
Parse::RecDescent releases with different internal implementations
would break pre-existing precompiled parsers.
.PP
Version 1.967_005 added the ability for Parse::RecDescent to include
itself in the resulting .pm file if you pass the boolean option
\&\f(CW\*(C`\-standalone\*(C'\fR to \f(CW\*(C`Precompile\*(C'\fR:
.PP
.Vb 2
\&    Parse::RecDescent\->Precompile({ \-standalone = 1, },
\&        $grammar, "My::New::Parser");
.Ve
.PP
Parse::RecDescent is included as Parse::RecDescent::_Runtime in order
to avoid conflicts between an installed version of Parse::RecDescent
and a precompiled, standalone parser made with another version of
Parse::RecDescent.  This renaming is experimental, and is subject to
change in future versions.
.PP
Precompiled parsers remain dependent on Parse::RecDescent by default,
as this feature is still considered experimental.  In the future,
standalone parsers will become the default.
.SH "GOTCHAS"
.IX Header "GOTCHAS"
This section describes common mistakes that grammar writers seem to
make on a regular basis.
.SS "1. Expecting an error to always invalidate a parse"
.IX Subsection "1. Expecting an error to always invalidate a parse"
A common mistake when using error messages is to write the grammar like this:
.PP
.Vb 1
\&    file: line(s)
\&
\&    line: line_type_1
\&    | line_type_2
\&    | line_type_3
\&    | <error>
.Ve
.PP
The expectation seems to be that any line that is not of type 1, 2 or 3 will
invoke the \f(CW\*(C`<error>\*(C'\fR directive and thereby cause the parse to fail.
.PP
Unfortunately, that only happens if the error occurs in the very first line.
The first rule states that a \f(CW\*(C`file\*(C'\fR is matched by one or more lines, so if
even a single line succeeds, the first rule is completely satisfied and the
parse as a whole succeeds. That means that any error messages generated by
subsequent failures in the \f(CW\*(C`line\*(C'\fR rule are quietly ignored.
.PP
Typically what's really needed is this:
.PP
.Vb 1
\&    file: line(s) eofile    { $return = $item[1] }
\&
\&    line: line_type_1
\&    | line_type_2
\&    | line_type_3
\&    | <error>
\&
\&    eofile: /^\eZ/
.Ve
.PP
The addition of the \f(CW\*(C`eofile\*(C'\fR subrule  to the first production means that
a file only matches a series of successful \f(CW\*(C`line\*(C'\fR matches \fIthat consume the
complete input text\fR. If any input text remains after the lines are matched,
there must have been an error in the last \f(CW\*(C`line\*(C'\fR. In that case the \f(CW\*(C`eofile\*(C'\fR
rule will fail, causing the entire \f(CW\*(C`file\*(C'\fR rule to fail too.
.PP
Note too that \f(CW\*(C`eofile\*(C'\fR must match \f(CW\*(C`/^\eZ/\*(C'\fR (end-of-text), \fInot\fR
\&\f(CW\*(C`/^\ecZ/\*(C'\fR or \f(CW\*(C`/^\ecD/\*(C'\fR (end-of-file).
.PP
And don't forget the action at the end of the production. If you just
write:
.PP
.Vb 1
\&    file: line(s) eofile
.Ve
.PP
then the value returned by the \f(CW\*(C`file\*(C'\fR rule will be the value of its
last item: \f(CW\*(C`eofile\*(C'\fR. Since \f(CW\*(C`eofile\*(C'\fR always returns an empty string
on success, that will cause the \f(CW\*(C`file\*(C'\fR rule to return that empty
string. Apart from returning the wrong value, returning an empty string
will trip up code such as:
.PP
.Vb 1
\&    $parser\->file($filetext) || die;
.Ve
.PP
(since "" is false).
.PP
Remember that Parse::RecDescent returns undef on failure,
so the only safe test for failure is:
.PP
.Vb 1
\&    defined($parser\->file($filetext)) || die;
.Ve
.ie n .SS "2. Using a ""return"" in an action"
.el .SS "2. Using a \f(CWreturn\fP in an action"
.IX Subsection "2. Using a return in an action"
An action is like a \f(CW\*(C`do\*(C'\fR block inside the subroutine implementing the
surrounding rule. So if you put a \f(CW\*(C`return\*(C'\fR statement in an action:
.PP
.Vb 3
\&    range: \*(Aq(\*(Aq start \*(Aq..\*(Aq end )\*(Aq
\&        { return $item{end} }
\&       /\es+/
.Ve
.PP
that subroutine will immediately return, without checking the rest of
the items in the current production (e.g. the \f(CW\*(C`/\es+/\*(C'\fR) and without
setting up the necessary data structures to tell the parser that the
rule has succeeded.
.PP
The correct way to set a return value in an action is to set the \f(CW$return\fR
variable:
.PP
.Vb 3
\&    range: \*(Aq(\*(Aq start \*(Aq..\*(Aq end )\*(Aq
\&                { $return = $item{end} }
\&           /\es+/
.Ve
.ie n .SS "2. Setting $Parse::RecDescent::skip at parse time"
.el .SS "2. Setting \f(CW$Parse::RecDescent::skip\fP at parse time"
.IX Subsection "2. Setting $Parse::RecDescent::skip at parse time"
If you want to change the default skipping behaviour (see
\&\*(L"Terminal Separators\*(R" and the \f(CW\*(C`<skip:...>\*(C'\fR directive) by setting
\&\f(CW$Parse::RecDescent::skip\fR you have to remember to set this variable
\&\fIbefore\fR creating the grammar object.
.PP
For example, you might want to skip all Perl-like comments with this
regular expression:
.PP
.Vb 6
\&   my $skip_spaces_and_comments = qr/
\&         (?mxs:
\&            \es+         # either spaces
\&            | \e# .*?$   # or a dash and whatever up to the end of line
\&         )*             # repeated at will (in whatever order)
\&      /;
.Ve
.PP
And then:
.PP
.Vb 1
\&   my $parser1 = Parse::RecDescent\->new($grammar);
\&
\&   $Parse::RecDescent::skip = $skip_spaces_and_comments;
\&
\&   my $parser2 = Parse::RecDescent\->new($grammar);
\&
\&   $parser1\->parse($text); # this does not cope with comments
\&   $parser2\->parse($text); # this skips comments correctly
.Ve
.PP
The two parsers behave differently, because any skipping behaviour
specified via \f(CW$Parse::RecDescent::skip\fR is hard-coded when the
grammar object is built, not at parse time.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
Diagnostics are intended to be self-explanatory (particularly if you
use \fB\-RD_HINT\fR (under \fBperl \-s\fR) or define \f(CW$::RD_HINT\fR inside the program).
.PP
\&\f(CW\*(C`Parse::RecDescent\*(C'\fR currently diagnoses the following:
.IP "\(bu" 4
Invalid regular expressions used as pattern terminals (fatal error).
.IP "\(bu" 4
Invalid Perl code in code blocks (fatal error).
.IP "\(bu" 4
Lookahead used in the wrong place or in a nonsensical way (fatal error).
.IP "\(bu" 4
\&\*(L"Obvious\*(R" cases of left-recursion (fatal error).
.IP "\(bu" 4
Missing or extra components in a \f(CW\*(C`<leftop>\*(C'\fR or \f(CW\*(C`<rightop>\*(C'\fR
directive.
.IP "\(bu" 4
Unrecognisable components in the grammar specification (fatal error).
.IP "\(bu" 4
\&\*(L"Orphaned\*(R" rule components specified before the first rule (fatal error)
or after an \f(CW\*(C`<error>\*(C'\fR directive (level 3 warning).
.IP "\(bu" 4
Missing rule definitions (this only generates a level 3 warning, since you
may be providing them later via \f(CW\*(C`Parse::RecDescent::Extend()\*(C'\fR).
.IP "\(bu" 4
Instances where greedy repetition behaviour will almost certainly
cause the failure of a production (a level 3 warning \- see
\&\*(L"ON-GOING \s-1ISSUES AND FUTURE DIRECTIONS\*(R"\s0 below).
.IP "\(bu" 4
Attempts to define rules named 'Replace' or 'Extend', which cannot be
called directly through the parser object because of the predefined
meaning of \f(CW\*(C`Parse::RecDescent::Replace\*(C'\fR and
\&\f(CW\*(C`Parse::RecDescent::Extend\*(C'\fR. (Only a level 2 warning is generated, since
such rules \fIcan\fR still be used as subrules).
.IP "\(bu" 4
Productions which consist of a single \f(CW\*(C`<error?>\*(C'\fR
directive, and which therefore may succeed unexpectedly
(a level 2 warning, since this might conceivably be the desired effect).
.IP "\(bu" 4
Multiple consecutive lookahead specifiers (a level 1 warning only, since their
effects simply accumulate).
.IP "\(bu" 4
Productions which start with a \f(CW\*(C`<reject>\*(C'\fR or \f(CW\*(C`<rulevar:...>\*(C'\fR
directive. Such productions are optimized away (a level 1 warning).
.IP "\(bu" 4
Rules which are autogenerated under \f(CW$::AUTOSTUB\fR (a level 1 warning).
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
Jeremy T. Braun (JTBRAUN@CPAN.org) [current maintainer]
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
There are undoubtedly serious bugs lurking somewhere in this much code :\-)
Bug reports, test cases and other feedback are most welcome.
.PP
Ongoing annoyances include:
.IP "\(bu" 4
There's no support for parsing directly from an input stream.
If and when the Perl Gods give us regular expressions on streams,
this should be trivial (ahem!) to implement.
.IP "\(bu" 4
The parser generator can get confused if actions aren't properly
closed or if they contain particularly nasty Perl syntax errors
(especially unmatched curly brackets).
.IP "\(bu" 4
The generator only detects the most obvious form of left recursion
(potential recursion on the first subrule in a rule). More subtle
forms of left recursion (for example, through the second item in a
rule after a \*(L"zero\*(R" match of a preceding \*(L"zero-or-more\*(R" repetition,
or after a match of a subrule with an empty production) are not found.
.IP "\(bu" 4
Instead of complaining about left-recursion, the generator should
silently transform the grammar to remove it. Don't expect this
feature any time soon as it would require a more sophisticated
approach to parser generation than is currently used.
.IP "\(bu" 4
The generated parsers don't always run as fast as might be wished.
.IP "\(bu" 4
The meta-parser should be bootstrapped using \f(CW\*(C`Parse::RecDescent\*(C'\fR :\-)
.SH "ON-GOING ISSUES AND FUTURE DIRECTIONS"
.IX Header "ON-GOING ISSUES AND FUTURE DIRECTIONS"
.IP "1." 4
Repetitions are \*(L"incorrigibly greedy\*(R" in that they will eat everything they can
and won't backtrack if that behaviour causes a production to fail needlessly.
So, for example:
.Sp
.Vb 1
\&    rule: subrule(s) subrule
.Ve
.Sp
will \fInever\fR succeed, because the repetition will eat all the
subrules it finds, leaving none to match the second item. Such
constructions are relatively rare (and \f(CW\*(C`Parse::RecDescent::new\*(C'\fR generates a
warning whenever they occur) so this may not be a problem, especially
since the insatiable behaviour can be overcome \*(L"manually\*(R" by writing:
.Sp
.Vb 1
\&    rule: penultimate_subrule(s) subrule
\&
\&    penultimate_subrule: subrule ...subrule
.Ve
.Sp
The issue is that this construction is exactly twice as expensive as the
original, whereas backtracking would add only 1/\fIN\fR to the cost (for
matching \fIN\fR repetitions of \f(CW\*(C`subrule\*(C'\fR). I would welcome feedback on
the need for backtracking; particularly on cases where the lack of it
makes parsing performance problematical.
.IP "2." 4
Having opened that can of worms, it's also necessary to consider whether there
is a need for non-greedy repetition specifiers. Again, it's possible (at some
cost) to manually provide the required functionality:
.Sp
.Vb 1
\&    rule: nongreedy_subrule(s) othersubrule
\&
\&    nongreedy_subrule: subrule ...!othersubrule
.Ve
.Sp
Overall, the issue is whether the benefit of this extra functionality
outweighs the drawbacks of further complicating the (currently
minimalist) grammar specification syntax, and (worse) introducing more overhead
into the generated parsers.
.IP "3." 4
An \f(CW\*(C`<autocommit>\*(C'\fR directive would be nice. That is, it would be useful to be
able to say:
.Sp
.Vb 7
\&    command: <autocommit>
\&    command: \*(Aqfind\*(Aq name
\&       | \*(Aqfind\*(Aq address
\&       | \*(Aqdo\*(Aq command \*(Aqat\*(Aq time \*(Aqif\*(Aq condition
\&       | \*(Aqdo\*(Aq command \*(Aqat\*(Aq time
\&       | \*(Aqdo\*(Aq command
\&       | unusual_command
.Ve
.Sp
and have the generator work out that this should be \*(L"pruned\*(R" thus:
.Sp
.Vb 9
\&    command: \*(Aqfind\*(Aq name
\&       | \*(Aqfind\*(Aq <commit> address
\&       | \*(Aqdo\*(Aq <commit> command <uncommit>
\&        \*(Aqat\*(Aq time
\&        \*(Aqif\*(Aq <commit> condition
\&       | \*(Aqdo\*(Aq <commit> command <uncommit>
\&        \*(Aqat\*(Aq <commit> time
\&       | \*(Aqdo\*(Aq <commit> command
\&       | unusual_command
.Ve
.Sp
There are several issues here. Firstly, should the
\&\f(CW\*(C`<autocommit>\*(C'\fR automatically install an \f(CW\*(C`<uncommit>\*(C'\fR
at the start of the last production (on the grounds that the \*(L"command\*(R"
rule doesn't know whether an \*(L"unusual_command\*(R" might start with \*(L"find\*(R"
or \*(L"do\*(R") or should the \*(L"unusual_command\*(R" subgraph be analysed (to see
if it \fImight\fR be viable after a \*(L"find\*(R" or \*(L"do\*(R")?
.Sp
The second issue is how regular expressions should be treated. The simplest
approach would be simply to uncommit before them (on the grounds that they
\&\fImight\fR match). Better efficiency would be obtained by analyzing all preceding
literal tokens to determine whether the pattern would match them.
.Sp
Overall, the issues are: can such automated \*(L"pruning\*(R" approach a hand-tuned
version sufficiently closely to warrant the extra set-up expense, and (more
importantly) is the problem important enough to even warrant the non-trivial
effort of building an automated solution?
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Source Code Repository"
.IX Subsection "Source Code Repository"
<http://github.com/jtbraun/Parse\-RecDescent>
.SS "Mailing List"
.IX Subsection "Mailing List"
Visit <http://www.perlfoundation.org/perl5/index.cgi?parse_recdescent> to sign up for the mailing list.
.PP
<http://www.PerlMonks.org> is also a good place to ask
questions. Previous posts about Parse::RecDescent can typically be
found with this search:
<http://perlmonks.org/index.pl?node=recdescent>.
.SS "\s-1FAQ\s0"
.IX Subsection "FAQ"
Visit Parse::RecDescent::FAQ for answers to frequently (and not so
frequently) asked questions about Parse::RecDescent.
.SS "View/Report Bugs"
.IX Subsection "View/Report Bugs"
To view the current bug list or report a new issue visit
<https://rt.cpan.org/Public/Dist/Display.html?Name=Parse\-RecDescent>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Grammars provides Parse::RecDescent style parsing using native
Perl 5.10 regular expressions.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 1997\-2007, Damian Conway \f(CW\*(C`<DCONWAY@CPAN.org>\*(C'\fR. All rights
reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
\&\s-1BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE \*(L"AS IS\*(R" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.\s0
.PP
\&\s-1IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE \s0(\s-1INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE\s0), \s-1EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.\s0
                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::RecDescent5.16.3pm                    0100644 0001750 0001750 00000374020 12566242212 025011  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::RecDescent 3"
.TH Parse::RecDescent 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::RecDescent \- Generate Recursive\-Descent Parsers
.SH "VERSION"
.IX Header "VERSION"
This document describes version 1.967009 of Parse::RecDescent
released March 16th, 2012.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Parse::RecDescent;
\&
\& # Generate a parser from the specification in $grammar:
\&
\&     $parser = new Parse::RecDescent ($grammar);
\&
\& # Generate a parser from the specification in $othergrammar
\&
\&     $anotherparser = new Parse::RecDescent ($othergrammar);
\&
\&
\& # Parse $text using rule \*(Aqstartrule\*(Aq (which must be
\& # defined in $grammar):
\&
\&    $parser\->startrule($text);
\&
\&
\& # Parse $text using rule \*(Aqotherrule\*(Aq (which must also
\& # be defined in $grammar):
\&
\&     $parser\->otherrule($text);
\&
\&
\& # Change the universal token prefix pattern
\& # before building a grammar
\& # (the default is: \*(Aq\es*\*(Aq):
\&
\&    $Parse::RecDescent::skip = \*(Aq[ \et]+\*(Aq;
\&
\&
\& # Replace productions of existing rules (or create new ones)
\& # with the productions defined in $newgrammar:
\&
\&    $parser\->Replace($newgrammar);
\&
\&
\& # Extend existing rules (or create new ones)
\& # by adding extra productions defined in $moregrammar:
\&
\&    $parser\->Extend($moregrammar);
\&
\&
\& # Global flags (useful as command line arguments under \-s):
\&
\&    $::RD_ERRORS       # unless undefined, report fatal errors
\&    $::RD_WARN         # unless undefined, also report non\-fatal problems
\&    $::RD_HINT         # if defined, also suggestion remedies
\&    $::RD_TRACE        # if defined, also trace parsers\*(Aq behaviour
\&    $::RD_AUTOSTUB     # if defined, generates "stubs" for undefined rules
\&    $::RD_AUTOACTION   # if defined, appends specified action to productions
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Overview"
.IX Subsection "Overview"
Parse::RecDescent incrementally generates top-down recursive-descent text
parsers from simple \fIyacc\fR\-like grammar specifications. It provides:
.IP "\(bu" 4
Regular expressions or literal strings as terminals (tokens),
.IP "\(bu" 4
Multiple (non-contiguous) productions for any rule,
.IP "\(bu" 4
Repeated and optional subrules within productions,
.IP "\(bu" 4
Full access to Perl within actions specified as part of the grammar,
.IP "\(bu" 4
Simple automated error reporting during parser generation and parsing,
.IP "\(bu" 4
The ability to commit to, uncommit to, or reject particular
productions during a parse,
.IP "\(bu" 4
The ability to pass data up and down the parse tree (\*(L"down\*(R" via subrule
argument lists, \*(L"up\*(R" via subrule return values)
.IP "\(bu" 4
Incremental extension of the parsing grammar (even during a parse),
.IP "\(bu" 4
Precompilation of parser objects,
.IP "\(bu" 4
User-definable reduce-reduce conflict resolution via
\&\*(L"scoring\*(R" of matching productions.
.ie n .SS "Using ""Parse::RecDescent"""
.el .SS "Using \f(CWParse::RecDescent\fP"
.IX Subsection "Using Parse::RecDescent"
Parser objects are created by calling \f(CW\*(C`Parse::RecDescent::new\*(C'\fR, passing in a
grammar specification (see the following subsections). If the grammar is
correct, \f(CW\*(C`new\*(C'\fR returns a blessed reference which can then be used to initiate
parsing through any rule specified in the original grammar. A typical sequence
looks like this:
.PP
.Vb 3
\&    $grammar = q {
\&        # GRAMMAR SPECIFICATION HERE
\&         };
\&
\&    $parser = new Parse::RecDescent ($grammar) or die "Bad grammar!\en";
\&
\&    # acquire $text
\&
\&    defined $parser\->startrule($text) or print "Bad text!\en";
.Ve
.PP
The rule through which parsing is initiated must be explicitly defined
in the grammar (i.e. for the above example, the grammar must include a
rule of the form: \*(L"startrule: <subrules>\*(R".
.PP
If the starting rule succeeds, its value (see below)
is returned. Failure to generate the original parser or failure to match a text
is indicated by returning \f(CW\*(C`undef\*(C'\fR. Note that it's easy to set up grammars
that can succeed, but which return a value of 0, \*(L"0\*(R", or "".  So don't be
tempted to write:
.PP
.Vb 1
\&    $parser\->startrule($text) or print "Bad text!\en";
.Ve
.PP
Normally, the parser has no effect on the original text. So in the
previous example the value of \f(CW$text\fR would be unchanged after having
been parsed.
.PP
If, however, the text to be matched is passed by reference:
.PP
.Vb 1
\&    $parser\->startrule(\e$text)
.Ve
.PP
then any text which was consumed during the match will be removed from the
start of \f(CW$text\fR.
.SS "Rules"
.IX Subsection "Rules"
In the grammar from which the parser is built, rules are specified by
giving an identifier (which must satisfy /[A\-Za\-z]\ew*/), followed by a
colon \fIon the same line\fR, followed by one or more productions,
separated by single vertical bars. The layout of the productions
is entirely free-format:
.PP
.Vb 3
\&    rule1:  production1
\&     |  production2 |
\&    production3 | production4
.Ve
.PP
At any point in the grammar previously defined rules may be extended with
additional productions. This is achieved by redeclaring the rule with the new
productions. Thus:
.PP
.Vb 3
\&    rule1: a | b | c
\&    rule2: d | e | f
\&    rule1: g | h
.Ve
.PP
is exactly equivalent to:
.PP
.Vb 2
\&    rule1: a | b | c | g | h
\&    rule2: d | e | f
.Ve
.PP
Each production in a rule consists of zero or more items, each of which
may be either: the name of another rule to be matched (a \*(L"subrule\*(R"),
a pattern or string literal to be matched directly (a \*(L"token\*(R"), a
block of Perl code to be executed (an \*(L"action\*(R"), a special instruction
to the parser (a \*(L"directive\*(R"), or a standard Perl comment (which is
ignored).
.PP
A rule matches a text if one of its productions matches. A production
matches if each of its items match consecutive substrings of the
text. The productions of a rule being matched are tried in the same
order that they appear in the original grammar, and the first matching
production terminates the match attempt (successfully). If all
productions are tried and none matches, the match attempt fails.
.PP
Note that this behaviour is quite different from the \*(L"prefer the longer match\*(R"
behaviour of \fIyacc\fR. For example, if \fIyacc\fR were parsing the rule:
.PP
.Vb 2
\&    seq : \*(AqA\*(Aq \*(AqB\*(Aq
\&    | \*(AqA\*(Aq \*(AqB\*(Aq \*(AqC\*(Aq
.Ve
.PP
upon matching \*(L"\s-1AB\s0\*(R" it would look ahead to see if a 'C' is next and, if
so, will match the second production in preference to the first. In
other words, \fIyacc\fR effectively tries all the productions of a rule
breadth-first in parallel, and selects the \*(L"best\*(R" match, where \*(L"best\*(R"
means longest (note that this is a gross simplification of the true
behaviour of \fIyacc\fR but it will do for our purposes).
.PP
In contrast, \f(CW\*(C`Parse::RecDescent\*(C'\fR tries each production depth-first in
sequence, and selects the \*(L"best\*(R" match, where \*(L"best\*(R" means first. This is
the fundamental difference between \*(L"bottom-up\*(R" and \*(L"recursive descent\*(R"
parsing.
.PP
Each successfully matched item in a production is assigned a value,
which can be accessed in subsequent actions within the same
production (or, in some cases, as the return value of a successful
subrule call). Unsuccessful items don't have an associated value,
since the failure of an item causes the entire surrounding production
to immediately fail. The following sections describe the various types
of items and their success values.
.SS "Subrules"
.IX Subsection "Subrules"
A subrule which appears in a production is an instruction to the parser to
attempt to match the named rule at that point in the text being
parsed. If the named subrule is not defined when requested the
production containing it immediately fails (unless it was \*(L"autostubbed\*(R" \- see
Autostubbing).
.PP
A rule may (recursively) call itself as a subrule, but \fInot\fR as the
left-most item in any of its productions (since such recursions are usually
non-terminating).
.PP
The value associated with a subrule is the value associated with its
\&\f(CW$return\fR variable (see \*(L"Actions\*(R" below), or with the last successfully
matched item in the subrule match.
.PP
Subrules may also be specified with a trailing repetition specifier,
indicating that they are to be (greedily) matched the specified number
of times. The available specifiers are:
.PP
.Vb 7
\&    subrule(?)  # Match one\-or\-zero times
\&    subrule(s)  # Match one\-or\-more times
\&    subrule(s?) # Match zero\-or\-more times
\&    subrule(N)  # Match exactly N times for integer N > 0
\&    subrule(N..M)   # Match between N and M times
\&    subrule(..M)    # Match between 1 and M times
\&    subrule(N..)    # Match at least N times
.Ve
.PP
Repeated subrules keep matching until either the subrule fails to
match, or it has matched the minimal number of times but fails to
consume any of the parsed text (this second condition prevents the
subrule matching forever in some cases).
.PP
Since a repeated subrule may match many instances of the subrule itself, the
value associated with it is not a simple scalar, but rather a reference to a
list of scalars, each of which is the value associated with one of the
individual subrule matches. In other words in the rule:
.PP
.Vb 1
\&    program: statement(s)
.Ve
.PP
the value associated with the repeated subrule \*(L"statement(s)\*(R" is a reference
to an array containing the values matched by each call to the individual
subrule \*(L"statement\*(R".
.PP
Repetition modifiers may include a separator pattern:
.PP
.Vb 1
\&    program: statement(s /;/)
.Ve
.PP
specifying some sequence of characters to be skipped between each repetition.
This is really just a shorthand for the <leftop:...> directive
(see below).
.SS "Tokens"
.IX Subsection "Tokens"
If a quote-delimited string or a Perl regex appears in a production,
the parser attempts to match that string or pattern at that point in
the text. For example:
.PP
.Vb 1
\&    typedef: "typedef" typename identifier \*(Aq;\*(Aq
\&
\&    identifier: /[A\-Za\-z_][A\-Za\-z0\-9_]*/
.Ve
.PP
As in regular Perl, a single quoted string is uninterpolated, whilst
a double-quoted string or a pattern is interpolated (at the time
of matching, \fInot\fR when the parser is constructed). Hence, it is
possible to define rules in which tokens can be set at run-time:
.PP
.Vb 1
\&    typedef: "$::typedefkeyword" typename identifier \*(Aq;\*(Aq
\&
\&    identifier: /$::identpat/
.Ve
.PP
Note that, since each rule is implemented inside a special namespace
belonging to its parser, it is necessary to explicitly quantify
variables from the main package.
.PP
Regex tokens can be specified using just slashes as delimiters
or with the explicit \f(CW\*(C`m<delimiter>......<delimiter>\*(C'\fR syntax:
.PP
.Vb 1
\&    typedef: "typedef" typename identifier \*(Aq;\*(Aq
\&
\&    typename: /[A\-Za\-z_][A\-Za\-z0\-9_]*/
\&
\&    identifier: m{[A\-Za\-z_][A\-Za\-z0\-9_]*}
.Ve
.PP
A regex of either type can also have any valid trailing parameter(s)
(that is, any of [cgimsox]):
.PP
.Vb 1
\&    typedef: "typedef" typename identifier \*(Aq;\*(Aq
\&
\&    identifier: / [a\-z_]        # LEADING ALPHA OR UNDERSCORE
\&          [a\-z0\-9_]*    # THEN DIGITS ALSO ALLOWED
\&        /ix     # CASE/SPACE/COMMENT INSENSITIVE
.Ve
.PP
The value associated with any successfully matched token is a string
containing the actual text which was matched by the token.
.PP
It is important to remember that, since each grammar is specified in a
Perl string, all instances of the universal escape character '\e' within
a grammar must be \*(L"doubled\*(R", so that they interpolate to single '\e's when
the string is compiled. For example, to use the grammar:
.PP
.Vb 3
\&    word:       /\eS+/ | backslash
\&    line:       prefix word(s) "\en"
\&    backslash:  \*(Aq\e\e\*(Aq
.Ve
.PP
the following code is required:
.PP
.Vb 1
\&    $parser = new Parse::RecDescent (q{
\&
\&        word:   /\e\eS+/ | backslash
\&        line:   prefix word(s) "\e\en"
\&        backslash:  \*(Aq\e\e\e\e\*(Aq
\&
\&    });
.Ve
.SS "Anonymous subrules"
.IX Subsection "Anonymous subrules"
Parentheses introduce a nested scope that is very like a call to an anonymous
subrule. Hence they are useful for \*(L"in-lining\*(R" subroutine calls, and other
kinds of grouping behaviour. For example, instead of:
.PP
.Vb 2
\&    word:       /\eS+/ | backslash
\&    line:       prefix word(s) "\en"
.Ve
.PP
you could write:
.PP
.Vb 1
\&    line:       prefix ( /\eS+/ | backslash )(s) "\en"
.Ve
.PP
and get exactly the same effects.
.PP
Parentheses are also use for collecting unrepeated alternations within a
single production.
.PP
.Vb 1
\&    secret_identity: "Mr" ("Incredible"|"Fantastic"|"Sheen") ", Esq."
.Ve
.SS "Terminal Separators"
.IX Subsection "Terminal Separators"
For the purpose of matching, each terminal in a production is considered
to be preceded by a \*(L"prefix\*(R" \- a pattern which must be
matched before a token match is attempted. By default, the
prefix is optional whitespace (which always matches, at
least trivially), but this default may be reset in any production.
.PP
The variable \f(CW$Parse::RecDescent::skip\fR stores the universal
prefix, which is the default for all terminal matches in all parsers
built with \f(CW\*(C`Parse::RecDescent\*(C'\fR.
.PP
If you want to change the universal prefix using
\&\f(CW$Parse::RecDescent::skip\fR, be careful to set it \fIbefore\fR creating
the grammar object, because it is applied statically (when a grammar
is built) rather than dynamically (when the grammar is used).
Alternatively you can provide a global \f(CW\*(C`<skip:...>\*(C'\fR directive
in your grammar before any rules (described later).
.PP
The prefix for an individual production can be altered
by using the \f(CW\*(C`<skip:...>\*(C'\fR directive (described later).
Setting this directive in the top-level rule is an alternative approach
to setting \f(CW$Parse::RecDescent::skip\fR before creating the object, but
in this case you don't get the intended skipping behaviour if you
directly invoke methods different from the top-level rule.
.SS "Actions"
.IX Subsection "Actions"
An action is a block of Perl code which is to be executed (as the
block of a \f(CW\*(C`do\*(C'\fR statement) when the parser reaches that point in a
production. The action executes within a special namespace belonging to
the active parser, so care must be taken in correctly qualifying variable
names (see also \*(L"Start-up Actions\*(R" below).
.PP
The action is considered to succeed if the final value of the block
is defined (that is, if the implied \f(CW\*(C`do\*(C'\fR statement evaluates to a
defined value \- \fIeven one which would be treated as \*(L"false\*(R"\fR). Note
that the value associated with a successful action is also the final
value in the block.
.PP
An action will \fIfail\fR if its last evaluated value is \f(CW\*(C`undef\*(C'\fR. This is
surprisingly easy to accomplish by accident. For instance, here's an
infuriating case of an action that makes its production fail, but only
when debugging \fIisn't\fR activated:
.PP
.Vb 4
\&    description: name rank serial_number
\&        { print "Got $item[2] $item[1] ($item[3])\en"
\&        if $::debugging
\&        }
.Ve
.PP
If \f(CW$debugging\fR is false, no statement in the block is executed, so
the final value is \f(CW\*(C`undef\*(C'\fR, and the entire production fails. The solution is:
.PP
.Vb 5
\&    description: name rank serial_number
\&        { print "Got $item[2] $item[1] ($item[3])\en"
\&        if $::debugging;
\&          1;
\&        }
.Ve
.PP
Within an action, a number of useful parse-time variables are
available in the special parser namespace (there are other variables
also accessible, but meddling with them will probably just break your
parser. As a general rule, if you avoid referring to unqualified
variables \- especially those starting with an underscore \- inside an action,
things should be okay):
.ie n .IP "@item and %item" 4
.el .IP "\f(CW@item\fR and \f(CW%item\fR" 4
.IX Item "@item and %item"
The array slice \f(CW@item[1..$#item]\fR stores the value associated with each item
(that is, each subrule, token, or action) in the current production. The
analogy is to \f(CW$1\fR, \f(CW$2\fR, etc. in a \fIyacc\fR grammar.
Note that, for obvious reasons, \f(CW@item\fR only contains the
values of items \fIbefore\fR the current point in the production.
.Sp
The first element (\f(CW$item[0]\fR) stores the name of the current rule
being matched.
.Sp
\&\f(CW@item\fR is a standard Perl array, so it can also be indexed with negative
numbers, representing the number of items \fIback\fR from the current position in
the parse:
.Sp
.Vb 3
\&    stuff: /various/ bits \*(Aqand\*(Aq pieces "then" data \*(Aqend\*(Aq
\&        { print $item[\-2] }  # PRINTS data
\&             # (EASIER THAN: $item[6])
.Ve
.Sp
The \f(CW%item\fR hash complements the <@item> array, providing named
access to the same item values:
.Sp
.Vb 3
\&    stuff: /various/ bits \*(Aqand\*(Aq pieces "then" data \*(Aqend\*(Aq
\&        { print $item{data}  # PRINTS data
\&             # (EVEN EASIER THAN USING @item)
.Ve
.Sp
The results of named subrules are stored in the hash under each
subrule's name (including the repetition specifier, if any),
whilst all other items are stored under a \*(L"named
positional\*(R" key that indictates their ordinal position within their item
type: _\|_STRING\fIn\fR_\|_, _\|_PATTERN\fIn\fR_\|_, _\|_DIRECTIVE\fIn\fR_\|_, _\|_ACTION\fIn\fR_\|_:
.Sp
.Vb 6
\&    stuff: /various/ bits \*(Aqand\*(Aq pieces "then" data \*(Aqend\*(Aq { save }
\&        { print $item{_\|_PATTERN1_\|_}, # PRINTS \*(Aqvarious\*(Aq
\&        $item{_\|_STRING2_\|_},  # PRINTS \*(Aqthen\*(Aq
\&        $item{_\|_ACTION1_\|_},  # PRINTS RETURN
\&                 # VALUE OF save
\&        }
.Ve
.Sp
If you want proper \fInamed\fR access to patterns or literals, you need to turn
them into separate rules:
.Sp
.Vb 3
\&    stuff: various bits \*(Aqand\*(Aq pieces "then" data \*(Aqend\*(Aq
\&        { print $item{various}  # PRINTS various
\&        }
\&
\&    various: /various/
.Ve
.Sp
The special entry \f(CW$item{_\|_RULE_\|_}\fR stores the name of the current
rule (i.e. the same value as \f(CW$item[0]\fR.
.Sp
The advantage of using \f(CW%item\fR, instead of \f(CW@items\fR is that it
removes the need to track items positions that may change as a grammar
evolves. For example, adding an interim \f(CW\*(C`<skip>\*(C'\fR directive
of action can silently ruin a trailing action, by moving an \f(CW@item\fR
element \*(L"down\*(R" the array one place. In contrast, the named entry
of \f(CW%item\fR is unaffected by such an insertion.
.Sp
A limitation of the \f(CW%item\fR hash is that it only records the \fIlast\fR
value of a particular subrule. For example:
.Sp
.Vb 2
\&    range: \*(Aq(\*(Aq number \*(Aq..\*(Aq number )\*(Aq
\&        { $return = $item{number} }
.Ve
.Sp
will return only the value corresponding to the \fIsecond\fR match of the
\&\f(CW\*(C`number\*(C'\fR subrule. In other words, successive calls to a subrule
overwrite the corresponding entry in \f(CW%item\fR. Once again, the
solution is to rename each subrule in its own rule:
.Sp
.Vb 2
\&    range: \*(Aq(\*(Aq from_num \*(Aq..\*(Aq to_num \*(Aq)\*(Aq
\&        { $return = $item{from_num} }
\&
\&    from_num: number
\&    to_num:   number
.Ve
.ie n .IP "@arg and %arg" 4
.el .IP "\f(CW@arg\fR and \f(CW%arg\fR" 4
.IX Item "@arg and %arg"
The array \f(CW@arg\fR and the hash \f(CW%arg\fR store any arguments passed to
the rule from some other rule (see \*(L"Subrule argument lists\*(R"). Changes
to the elements of either variable do not propagate back to the calling
rule (data can be passed back from a subrule via the \f(CW$return\fR
variable \- see next item).
.ie n .IP "$return" 4
.el .IP "\f(CW$return\fR" 4
.IX Item "$return"
If a value is assigned to \f(CW$return\fR within an action, that value is
returned if the production containing the action eventually matches
successfully. Note that setting \f(CW$return\fR \fIdoesn't\fR cause the current
production to succeed. It merely tells it what to return if it \fIdoes\fR succeed.
Hence \f(CW$return\fR is analogous to \f(CW$$\fR in a \fIyacc\fR grammar.
.Sp
If \f(CW$return\fR is not assigned within a production, the value of the
last component of the production (namely: \f(CW$item[$#item]\fR) is
returned if the production succeeds.
.ie n .IP "$commit" 4
.el .IP "\f(CW$commit\fR" 4
.IX Item "$commit"
The current state of commitment to the current production (see \*(L"Directives\*(R"
below).
.ie n .IP "$skip" 4
.el .IP "\f(CW$skip\fR" 4
.IX Item "$skip"
The current terminal prefix (see \*(L"Directives\*(R" below).
.ie n .IP "$text" 4
.el .IP "\f(CW$text\fR" 4
.IX Item "$text"
The remaining (unparsed) text. Changes to \f(CW$text\fR \fIdo not
propagate\fR out of unsuccessful productions, but \fIdo\fR survive
successful productions. Hence it is possible to dynamically alter the
text being parsed \- for example, to provide a \f(CW\*(C`#include\*(C'\fR\-like facility:
.Sp
.Vb 2
\&    hash_include: \*(Aq#include\*(Aq filename
\&        { $text = ::loadfile($item[2]) . $text }
\&
\&    filename: \*(Aq<\*(Aq /[a\-z0\-9._\-]+/i \*(Aq>\*(Aq  { $return = $item[2] }
\&    | \*(Aq"\*(Aq /[a\-z0\-9._\-]+/i \*(Aq"\*(Aq  { $return = $item[2] }
.Ve
.ie n .IP "$thisline and $prevline" 4
.el .IP "\f(CW$thisline\fR and \f(CW$prevline\fR" 4
.IX Item "$thisline and $prevline"
\&\f(CW$thisline\fR stores the current line number within the current parse
(starting from 1). \f(CW$prevline\fR stores the line number for the last
character which was already successfully parsed (this will be different from
\&\f(CW$thisline\fR at the end of each line).
.Sp
For efficiency, \f(CW$thisline\fR and \f(CW$prevline\fR are actually tied
hashes, and only recompute the required line number when the variable's
value is used.
.Sp
Assignment to \f(CW$thisline\fR adjusts the line number calculator, so that
it believes that the current line number is the value being assigned. Note
that this adjustment will be reflected in all subsequent line numbers
calculations.
.Sp
Modifying the value of the variable \f(CW$text\fR (as in the previous
\&\f(CW\*(C`hash_include\*(C'\fR example, for instance) will confuse the line
counting mechanism. To prevent this, you should call
\&\f(CW\*(C`Parse::RecDescent::LineCounter::resync($thisline)\*(C'\fR \fIimmediately\fR
after any assignment to the variable \f(CW$text\fR (or, at least, before the
next attempt to use \f(CW$thisline\fR).
.Sp
Note that if a production fails after assigning to or
resync'ing \f(CW$thisline\fR, the parser's line counter mechanism will
usually be corrupted.
.Sp
Also see the entry for \f(CW@itempos\fR.
.Sp
The line number can be set to values other than 1, by calling the start
rule with a second argument. For example:
.Sp
.Vb 1
\&    $parser = new Parse::RecDescent ($grammar);
\&
\&    $parser\->input($text, 10);  # START LINE NUMBERS AT 10
.Ve
.ie n .IP "$thiscolumn and $prevcolumn" 4
.el .IP "\f(CW$thiscolumn\fR and \f(CW$prevcolumn\fR" 4
.IX Item "$thiscolumn and $prevcolumn"
\&\f(CW$thiscolumn\fR stores the current column number within the current line
being parsed (starting from 1). \f(CW$prevcolumn\fR stores the column number
of the last character which was actually successfully parsed. Usually
\&\f(CW\*(C`$prevcolumn == $thiscolumn\-1\*(C'\fR, but not at the end of lines.
.Sp
For efficiency, \f(CW$thiscolumn\fR and \f(CW$prevcolumn\fR are
actually tied hashes, and only recompute the required column number
when the variable's value is used.
.Sp
Assignment to \f(CW$thiscolumn\fR or \f(CW$prevcolumn\fR is a fatal error.
.Sp
Modifying the value of the variable \f(CW$text\fR (as in the previous
\&\f(CW\*(C`hash_include\*(C'\fR example, for instance) may confuse the column
counting mechanism.
.Sp
Note that \f(CW$thiscolumn\fR reports the column number \fIbefore\fR any
whitespace that might be skipped before reading a token. Hence
if you wish to know where a token started (and ended) use something like this:
.Sp
.Vb 2
\&    rule: token1 token2 startcol token3 endcol token4
\&        { print "token3: columns $item[3] to $item[5]"; }
\&
\&    startcol: \*(Aq\*(Aq { $thiscolumn }    # NEED THE \*(Aq\*(Aq TO STEP PAST TOKEN SEP
\&    endcol:  { $prevcolumn }
.Ve
.Sp
Also see the entry for \f(CW@itempos\fR.
.ie n .IP "$thisoffset and $prevoffset" 4
.el .IP "\f(CW$thisoffset\fR and \f(CW$prevoffset\fR" 4
.IX Item "$thisoffset and $prevoffset"
\&\f(CW$thisoffset\fR stores the offset of the current parsing position
within the complete text
being parsed (starting from 0). \f(CW$prevoffset\fR stores the offset
of the last character which was actually successfully parsed. In all
cases \f(CW\*(C`$prevoffset == $thisoffset\-1\*(C'\fR.
.Sp
For efficiency, \f(CW$thisoffset\fR and \f(CW$prevoffset\fR are
actually tied hashes, and only recompute the required offset
when the variable's value is used.
.Sp
Assignment to \f(CW$thisoffset\fR or <$prevoffset> is a fatal error.
.Sp
Modifying the value of the variable \f(CW$text\fR will \fInot\fR affect the
offset counting mechanism.
.Sp
Also see the entry for \f(CW@itempos\fR.
.ie n .IP "@itempos" 4
.el .IP "\f(CW@itempos\fR" 4
.IX Item "@itempos"
The array \f(CW@itempos\fR stores a hash reference corresponding to
each element of \f(CW@item\fR. The elements of the hash provide the
following:
.Sp
.Vb 6
\&    $itempos[$n]{offset}{from}  # VALUE OF $thisoffset BEFORE $item[$n]
\&    $itempos[$n]{offset}{to}    # VALUE OF $prevoffset AFTER $item[$n]
\&    $itempos[$n]{line}{from}    # VALUE OF $thisline BEFORE $item[$n]
\&    $itempos[$n]{line}{to}  # VALUE OF $prevline AFTER $item[$n]
\&    $itempos[$n]{column}{from}  # VALUE OF $thiscolumn BEFORE $item[$n]
\&    $itempos[$n]{column}{to}    # VALUE OF $prevcolumn AFTER $item[$n]
.Ve
.Sp
Note that the various \f(CW\*(C`$itempos[$n]...{from}\*(C'\fR values record the
appropriate value \fIafter\fR any token prefix has been skipped.
.Sp
Hence, instead of the somewhat tedious and error-prone:
.Sp
.Vb 9
\&    rule: startcol token1 endcol
\&      startcol token2 endcol
\&      startcol token3 endcol
\&        { print "token1: columns $item[1]
\&              to $item[3]
\&         token2: columns $item[4]
\&              to $item[6]
\&         token3: columns $item[7]
\&              to $item[9]" }
\&
\&    startcol: \*(Aq\*(Aq { $thiscolumn }    # NEED THE \*(Aq\*(Aq TO STEP PAST TOKEN SEP
\&    endcol:  { $prevcolumn }
.Ve
.Sp
it is possible to write:
.Sp
.Vb 7
\&    rule: token1 token2 token3
\&        { print "token1: columns $itempos[1]{column}{from}
\&              to $itempos[1]{column}{to}
\&         token2: columns $itempos[2]{column}{from}
\&              to $itempos[2]{column}{to}
\&         token3: columns $itempos[3]{column}{from}
\&              to $itempos[3]{column}{to}" }
.Ve
.Sp
Note however that (in the current implementation) the use of \f(CW@itempos\fR
anywhere in a grammar implies that item positioning information is
collected \fIeverywhere\fR during the parse. Depending on the grammar
and the size of the text to be parsed, this may be prohibitively
expensive and the explicit use of \f(CW$thisline\fR, \f(CW$thiscolumn\fR, etc. may
be a better choice.
.ie n .IP "$thisparser" 4
.el .IP "\f(CW$thisparser\fR" 4
.IX Item "$thisparser"
A reference to the \f(CW\*(C`Parse::RecDescent\*(C'\fR object through which
parsing was initiated.
.Sp
The value of \f(CW$thisparser\fR propagates down the subrules of a parse
but not back up. Hence, you can invoke subrules from another parser
for the scope of the current rule as follows:
.Sp
.Vb 4
\&    rule: subrule1 subrule2
\&    | { $thisparser = $::otherparser } <reject>
\&    | subrule3 subrule4
\&    | subrule5
.Ve
.Sp
The result is that the production calls \*(L"subrule1\*(R" and \*(L"subrule2\*(R" of
the current parser, and the remaining productions call the named subrules
from \f(CW$::otherparser\fR. Note, however that \*(L"Bad Things\*(R" will happen if
\&\f(CW\*(C`::otherparser\*(C'\fR isn't a blessed reference and/or doesn't have methods
with the same names as the required subrules!
.ie n .IP "$thisrule" 4
.el .IP "\f(CW$thisrule\fR" 4
.IX Item "$thisrule"
A reference to the \f(CW\*(C`Parse::RecDescent::Rule\*(C'\fR object corresponding to the
rule currently being matched.
.ie n .IP "$thisprod" 4
.el .IP "\f(CW$thisprod\fR" 4
.IX Item "$thisprod"
A reference to the \f(CW\*(C`Parse::RecDescent::Production\*(C'\fR object
corresponding to the production currently being matched.
.ie n .IP "$score and $score_return" 4
.el .IP "\f(CW$score\fR and \f(CW$score_return\fR" 4
.IX Item "$score and $score_return"
\&\f(CW$score\fR stores the best production score to date, as specified by
an earlier \f(CW\*(C`<score:...>\*(C'\fR directive. \f(CW$score_return\fR stores
the corresponding return value for the successful production.
.Sp
See \*(L"Scored productions\*(R".
.PP
\&\fBWarning:\fR the parser relies on the information in the various \f(CW\*(C`this...\*(C'\fR
objects in some non-obvious ways. Tinkering with the other members of
these objects will probably cause Bad Things to happen, unless you
\&\fIreally\fR know what you're doing. The only exception to this advice is
that the use of \f(CW\*(C`$this...\->{local}\*(C'\fR is always safe.
.SS "Start-up Actions"
.IX Subsection "Start-up Actions"
Any actions which appear \fIbefore\fR the first rule definition in a
grammar are treated as \*(L"start-up\*(R" actions. Each such action is
stripped of its outermost brackets and then evaluated (in the parser's
special namespace) just before the rules of the grammar are first
compiled.
.PP
The main use of start-up actions is to declare local variables within the
parser's special namespace:
.PP
.Vb 1
\&    { my $lastitem = \*(Aq???\*(Aq; }
\&
\&    list: item(s)   { $return = $lastitem }
\&
\&    item: book  { $lastitem = \*(Aqbook\*(Aq; }
\&      bell  { $lastitem = \*(Aqbell\*(Aq; }
\&      candle    { $lastitem = \*(Aqcandle\*(Aq; }
.Ve
.PP
but start-up actions can be used to execute \fIany\fR valid Perl code
within a parser's special namespace.
.PP
Start-up actions can appear within a grammar extension or replacement
(that is, a partial grammar installed via \f(CW\*(C`Parse::RecDescent::Extend()\*(C'\fR or
\&\f(CW\*(C`Parse::RecDescent::Replace()\*(C'\fR \- see \*(L"Incremental Parsing\*(R"), and will be
executed before the new grammar is installed. Note, however, that a
particular start-up action is only ever executed once.
.SS "Autoactions"
.IX Subsection "Autoactions"
It is sometimes desirable to be able to specify a default action to be
taken at the end of every production (for example, in order to easily
build a parse tree). If the variable \f(CW$::RD_AUTOACTION\fR is defined
when \f(CW\*(C`Parse::RecDescent::new()\*(C'\fR is called, the contents of that
variable are treated as a specification of an action which is to appended
to each production in the corresponding grammar.
.PP
Alternatively, you can hard-code the autoaction within a grammar, using the
\&\f(CW\*(C`<autoaction:...>\*(C'\fR directive.
.PP
So, for example, to construct a simple parse tree you could write:
.PP
.Vb 1
\&    $::RD_AUTOACTION = q { [@item] };
\&
\&    parser = Parse::RecDescent\->new(q{
\&    expression: and_expr \*(Aq||\*(Aq expression | and_expr
\&    and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&    not_expr:   \*(Aq!\*(Aq brack_expr       | brack_expr
\&    brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&    identifier: /[a\-z]+/i
\&    });
.Ve
.PP
or:
.PP
.Vb 2
\&    parser = Parse::RecDescent\->new(q{
\&    <autoaction: { [@item] } >
\&
\&    expression: and_expr \*(Aq||\*(Aq expression | and_expr
\&    and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&    not_expr:   \*(Aq!\*(Aq brack_expr       | brack_expr
\&    brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&    identifier: /[a\-z]+/i
\&    });
.Ve
.PP
Either of these is equivalent to:
.PP
.Vb 5
\&    parser = new Parse::RecDescent (q{
\&    expression: and_expr \*(Aq||\*(Aq expression
\&        { [@item] }
\&      | and_expr
\&        { [@item] }
\&
\&    and_expr:   not_expr \*(Aq&&\*(Aq and_expr
\&        { [@item] }
\&    |   not_expr
\&        { [@item] }
\&
\&    not_expr:   \*(Aq!\*(Aq brack_expr
\&        { [@item] }
\&    |   brack_expr
\&        { [@item] }
\&
\&    brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq
\&        { [@item] }
\&      | identifier
\&        { [@item] }
\&
\&    identifier: /[a\-z]+/i
\&        { [@item] }
\&    });
.Ve
.PP
Alternatively, we could take an object-oriented approach, use different
classes for each node (and also eliminating redundant intermediate nodes):
.PP
.Vb 2
\&    $::RD_AUTOACTION = q
\&      { $#item==1 ? $item[1] : "$item[0]_node"\->new(@item[1..$#item]) };
\&
\&    parser = Parse::RecDescent\->new(q{
\&        expression: and_expr \*(Aq||\*(Aq expression | and_expr
\&        and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&        not_expr:   \*(Aq!\*(Aq brack_expr           | brack_expr
\&        brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&        identifier: /[a\-z]+/i
\&    });
.Ve
.PP
or:
.PP
.Vb 4
\&    parser = Parse::RecDescent\->new(q{
\&        <autoaction:
\&          $#item==1 ? $item[1] : "$item[0]_node"\->new(@item[1..$#item])
\&        >
\&
\&        expression: and_expr \*(Aq||\*(Aq expression | and_expr
\&        and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&        not_expr:   \*(Aq!\*(Aq brack_expr           | brack_expr
\&        brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&        identifier: /[a\-z]+/i
\&    });
.Ve
.PP
which are equivalent to:
.PP
.Vb 4
\&    parser = Parse::RecDescent\->new(q{
\&        expression: and_expr \*(Aq||\*(Aq expression
\&            { "expression_node"\->new(@item[1..3]) }
\&        | and_expr
\&
\&        and_expr:   not_expr \*(Aq&&\*(Aq and_expr
\&            { "and_expr_node"\->new(@item[1..3]) }
\&        |   not_expr
\&
\&        not_expr:   \*(Aq!\*(Aq brack_expr
\&            { "not_expr_node"\->new(@item[1..2]) }
\&        |   brack_expr
\&
\&        brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq
\&            { "brack_expr_node"\->new(@item[1..3]) }
\&        | identifier
\&
\&        identifier: /[a\-z]+/i
\&            { "identifer_node"\->new(@item[1]) }
\&    });
.Ve
.PP
Note that, if a production already ends in an action, no autoaction is appended
to it. For example, in this version:
.PP
.Vb 2
\&    $::RD_AUTOACTION = q
\&      { $#item==1 ? $item[1] : "$item[0]_node"\->new(@item[1..$#item]) };
\&
\&    parser = Parse::RecDescent\->new(q{
\&        expression: and_expr \*(Aq&&\*(Aq expression | and_expr
\&        and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&        not_expr:   \*(Aq!\*(Aq brack_expr           | brack_expr
\&        brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&        identifier: /[a\-z]+/i
\&            { \*(Aqterminal_node\*(Aq\->new($item[1]) }
\&    });
.Ve
.PP
each \f(CW\*(C`identifier\*(C'\fR match produces a \f(CW\*(C`terminal_node\*(C'\fR object, \fInot\fR an
\&\f(CW\*(C`identifier_node\*(C'\fR object.
.PP
A level 1 warning is issued each time an \*(L"autoaction\*(R" is added to
some production.
.SS "Autotrees"
.IX Subsection "Autotrees"
A commonly needed autoaction is one that builds a parse-tree. It is moderately
tricky to set up such an action (which must treat terminals differently from
non-terminals), so Parse::RecDescent simplifies the process by providing the
\&\f(CW\*(C`<autotree>\*(C'\fR directive.
.PP
If this directive appears at the start of grammar, it causes
Parse::RecDescent to insert autoactions at the end of any rule except
those which already end in an action. The action inserted depends on whether
the production is an intermediate rule (two or more items), or a terminal
of the grammar (i.e. a single pattern or string item).
.PP
So, for example, the following grammar:
.PP
.Vb 1
\&    <autotree>
\&
\&    file    : command(s)
\&    command : get | set | vet
\&    get : \*(Aqget\*(Aq ident \*(Aq;\*(Aq
\&    set : \*(Aqset\*(Aq ident \*(Aqto\*(Aq value \*(Aq;\*(Aq
\&    vet : \*(Aqcheck\*(Aq ident \*(Aqis\*(Aq value \*(Aq;\*(Aq
\&    ident   : /\ew+/
\&    value   : /\ed+/
.Ve
.PP
is equivalent to:
.PP
.Vb 7
\&    file    : command(s)        { bless \e%item, $item[0] }
\&    command : get       { bless \e%item, $item[0] }
\&    | set           { bless \e%item, $item[0] }
\&    | vet           { bless \e%item, $item[0] }
\&    get : \*(Aqget\*(Aq ident \*(Aq;\*(Aq   { bless \e%item, $item[0] }
\&    set : \*(Aqset\*(Aq ident \*(Aqto\*(Aq value \*(Aq;\*(Aq    { bless \e%item, $item[0] }
\&    vet : \*(Aqcheck\*(Aq ident \*(Aqis\*(Aq value \*(Aq;\*(Aq  { bless \e%item, $item[0] }
\&
\&    ident   : /\ew+/  { bless {_\|_VALUE_\|_=>$item[1]}, $item[0] }
\&    value   : /\ed+/  { bless {_\|_VALUE_\|_=>$item[1]}, $item[0] }
.Ve
.PP
Note that each node in the tree is blessed into a class of the same name
as the rule itself. This makes it easy to build object-oriented
processors for the parse-trees that the grammar produces. Note too that
the last two rules produce special objects with the single attribute
\&'_\|_VALUE_\|_'. This is because they consist solely of a single terminal.
.PP
This autoaction-ed grammar would then produce a parse tree in a data
structure like this:
.PP
.Vb 10
\&    {
\&      file => {
\&        command => {
\&         [ get => {
\&            identifier => { _\|_VALUE_\|_ => \*(Aqa\*(Aq },
\&              },
\&           set => {
\&            identifier => { _\|_VALUE_\|_ => \*(Aqb\*(Aq },
\&            value      => { _\|_VALUE_\|_ => \*(Aq7\*(Aq },
\&              },
\&           vet => {
\&            identifier => { _\|_VALUE_\|_ => \*(Aqb\*(Aq },
\&            value      => { _\|_VALUE_\|_ => \*(Aq7\*(Aq },
\&              },
\&          ],
\&           },
\&      }
\&    }
.Ve
.PP
(except, of course, that each nested hash would also be blessed into
the appropriate class).
.PP
You can also specify a base class for the \f(CW\*(C`<autotree>\*(C'\fR directive.
The supplied prefix will be prepended to the rule names when creating
tree nodes.  The following are equivalent:
.PP
.Vb 2
\&    <autotree:MyBase::Class>
\&    <autotree:MyBase::Class::>
.Ve
.PP
And will produce a root node blessed into the \f(CW\*(C`MyBase::Class::file\*(C'\fR
package in the example above.
.SS "Autostubbing"
.IX Subsection "Autostubbing"
Normally, if a subrule appears in some production, but no rule of that
name is ever defined in the grammar, the production which refers to the
non-existent subrule fails immediately. This typically occurs as a
result of misspellings, and is a sufficiently common occurance that a
warning is generated for such situations.
.PP
However, when prototyping a grammar it is sometimes useful to be
able to use subrules before a proper specification of them is
really possible.  For example, a grammar might include a section like:
.PP
.Vb 1
\&    function_call: identifier \*(Aq(\*(Aq arg(s?) \*(Aq)\*(Aq
\&
\&    identifier: /[a\-z]\ew*/i
.Ve
.PP
where the possible format of an argument is sufficiently complex that
it is not worth specifying in full until the general function call
syntax has been debugged. In this situation it is convenient to leave
the real rule \f(CW\*(C`arg\*(C'\fR undefined and just slip in a placeholder (or
\&\*(L"stub\*(R"):
.PP
.Vb 1
\&    arg: \*(Aqarg\*(Aq
.Ve
.PP
so that the function call syntax can be tested with dummy input such as:
.PP
.Vb 4
\&    f0()
\&    f1(arg)
\&    f2(arg arg)
\&    f3(arg arg arg)
.Ve
.PP
et cetera.
.PP
Early in prototyping, many such \*(L"stubs\*(R" may be required, so
\&\f(CW\*(C`Parse::RecDescent\*(C'\fR provides a means of automating their definition.
If the variable \f(CW$::RD_AUTOSTUB\fR is defined when a parser is built, a
subrule reference to any non-existent rule (say, \f(CW\*(C`subrule\*(C'\fR), will
cause a \*(L"stub\*(R" rule to be automatically defined in the generated
parser.  If \f(CW\*(C`$::RD_AUTOSTUB eq \*(Aq1\*(Aq\*(C'\fR or is false, a stub rule of the
form:
.PP
.Vb 1
\&    subrule: \*(Aqsubrule\*(Aq
.Ve
.PP
will be generated.  The special-case for a value of \f(CW\*(Aq1\*(Aq\fR is to allow
the use of the \fBperl \-s\fR with \fB\-RD_AUTOSTUB\fR without generating
\&\f(CW\*(C`subrule: \*(Aq1\*(Aq\*(C'\fR per below. If \f(CW$::RD_AUTOSTUB\fR is true, a stub rule
of the form:
.PP
.Vb 1
\&    subrule: $::RD_AUTOSTUB
.Ve
.PP
will be generated.  \f(CW$::RD_AUTOSTUB\fR must contain a valid production
item, no checking is performed.  No lazy evaluation of
\&\f(CW$::RD_AUTOSTUB\fR is performed, it is evaluated at the time the Parser
is generated.
.PP
Hence, with \f(CW$::RD_AUTOSTUB\fR defined, it is possible to only
partially specify a grammar, and then \*(L"fake\*(R" matches of the
unspecified (sub)rules by just typing in their name, or a literal
value that was assigned to \f(CW$::RD_AUTOSTUB\fR.
.SS "Look-ahead"
.IX Subsection "Look-ahead"
If a subrule, token, or action is prefixed by \*(L"...\*(R", then it is
treated as a \*(L"look-ahead\*(R" request. That means that the current production can
(as usual) only succeed if the specified item is matched, but that the matching
\&\fIdoes not consume any of the text being parsed\fR. This is very similar to the
\&\f(CW\*(C`/(?=...)/\*(C'\fR look-ahead construct in Perl patterns. Thus, the rule:
.PP
.Vb 1
\&    inner_word: word ...word
.Ve
.PP
will match whatever the subrule \*(L"word\*(R" matches, provided that match is followed
by some more text which subrule \*(L"word\*(R" would also match (although this
second substring is not actually consumed by \*(L"inner_word\*(R")
.PP
Likewise, a \*(L"...!\*(R" prefix, causes the following item to succeed (without
consuming any text) if and only if it would normally fail. Hence, a
rule such as:
.PP
.Vb 1
\&    identifier: ...!keyword ...!\*(Aq_\*(Aq /[A\-Za\-z_]\ew*/
.Ve
.PP
matches a string of characters which satisfies the pattern
\&\f(CW\*(C`/[A\-Za\-z_]\ew*/\*(C'\fR, but only if the same sequence of characters would
not match either subrule \*(L"keyword\*(R" or the literal token '_'.
.PP
Sequences of look-ahead prefixes accumulate, multiplying their positive and/or
negative senses. Hence:
.PP
.Vb 1
\&    inner_word: word ...!......!word
.Ve
.PP
is exactly equivalent the the original example above (a warning is issued in
cases like these, since they often indicate something left out, or
misunderstood).
.PP
Note that actions can also be treated as look-aheads. In such cases,
the state of the parser text (in the local variable \f(CW$text\fR)
\&\fIafter\fR the look-ahead action is guaranteed to be identical to its
state \fIbefore\fR the action, regardless of how it's changed \fIwithin\fR
the action (unless you actually undefine \f(CW$text\fR, in which case you
get the disaster you deserve :\-).
.SS "Directives"
.IX Subsection "Directives"
Directives are special pre-defined actions which may be used to alter
the behaviour of the parser. There are currently twenty-three directives:
\&\f(CW\*(C`<commit>\*(C'\fR,
\&\f(CW\*(C`<uncommit>\*(C'\fR,
\&\f(CW\*(C`<reject>\*(C'\fR,
\&\f(CW\*(C`<score>\*(C'\fR,
\&\f(CW\*(C`<autoscore>\*(C'\fR,
\&\f(CW\*(C`<skip>\*(C'\fR,
\&\f(CW\*(C`<resync>\*(C'\fR,
\&\f(CW\*(C`<error>\*(C'\fR,
\&\f(CW\*(C`<warn>\*(C'\fR,
\&\f(CW\*(C`<hint>\*(C'\fR,
\&\f(CW\*(C`<trace_build>\*(C'\fR,
\&\f(CW\*(C`<trace_parse>\*(C'\fR,
\&\f(CW\*(C`<nocheck>\*(C'\fR,
\&\f(CW\*(C`<rulevar>\*(C'\fR,
\&\f(CW\*(C`<matchrule>\*(C'\fR,
\&\f(CW\*(C`<leftop>\*(C'\fR,
\&\f(CW\*(C`<rightop>\*(C'\fR,
\&\f(CW\*(C`<defer>\*(C'\fR,
\&\f(CW\*(C`<nocheck>\*(C'\fR,
\&\f(CW\*(C`<perl_quotelike>\*(C'\fR,
\&\f(CW\*(C`<perl_codeblock>\*(C'\fR,
\&\f(CW\*(C`<perl_variable>\*(C'\fR,
and \f(CW\*(C`<token>\*(C'\fR.
.IP "Committing and uncommitting" 4
.IX Item "Committing and uncommitting"
The \f(CW\*(C`<commit>\*(C'\fR and \f(CW\*(C`<uncommit>\*(C'\fR directives permit the recursive
descent of the parse tree to be pruned (or \*(L"cut\*(R") for efficiency.
Within a rule, a \f(CW\*(C`<commit>\*(C'\fR directive instructs the rule to ignore subsequent
productions if the current production fails. For example:
.Sp
.Vb 3
\&    command: \*(Aqfind\*(Aq <commit> filename
\&       | \*(Aqopen\*(Aq <commit> filename
\&       | \*(Aqmove\*(Aq filename filename
.Ve
.Sp
Clearly, if the leading token 'find' is matched in the first production but that
production fails for some other reason, then the remaining
productions cannot possibly match. The presence of the
\&\f(CW\*(C`<commit>\*(C'\fR causes the \*(L"command\*(R" rule to fail immediately if
an invalid \*(L"find\*(R" command is found, and likewise if an invalid \*(L"open\*(R"
command is encountered.
.Sp
It is also possible to revoke a previous commitment. For example:
.Sp
.Vb 5
\&    if_statement: \*(Aqif\*(Aq <commit> condition
\&        \*(Aqthen\*(Aq block <uncommit>
\&        \*(Aqelse\*(Aq block
\&        | \*(Aqif\*(Aq <commit> condition
\&        \*(Aqthen\*(Aq block
.Ve
.Sp
In this case, a failure to find an \*(L"else\*(R" block in the first
production shouldn't preclude trying the second production, but a
failure to find a \*(L"condition\*(R" certainly should.
.Sp
As a special case, any production in which the \fIfirst\fR item is an
\&\f(CW\*(C`<uncommit>\*(C'\fR immediately revokes a preceding \f(CW\*(C`<commit>\*(C'\fR
(even though the production would not otherwise have been tried). For
example, in the rule:
.Sp
.Vb 5
\&    request: \*(Aqexplain\*(Aq expression
\&           | \*(Aqexplain\*(Aq <commit> keyword
\&           | \*(Aqsave\*(Aq
\&           | \*(Aqquit\*(Aq
\&           | <uncommit> term \*(Aq?\*(Aq
.Ve
.Sp
if the text being matched was \*(L"explain?\*(R", and the first two
productions failed, then the \f(CW\*(C`<commit>\*(C'\fR in production two would cause
productions three and four to be skipped, but the leading
\&\f(CW\*(C`<uncommit>\*(C'\fR in the production five would allow that production to
attempt a match.
.Sp
Note in the preceding example, that the \f(CW\*(C`<commit>\*(C'\fR was only placed
in production two. If production one had been:
.Sp
.Vb 1
\&    request: \*(Aqexplain\*(Aq <commit> expression
.Ve
.Sp
then production two would be (inappropriately) skipped if a leading
\&\*(L"explain...\*(R" was encountered.
.Sp
Both \f(CW\*(C`<commit>\*(C'\fR and \f(CW\*(C`<uncommit>\*(C'\fR directives always succeed, and their value
is always 1.
.IP "Rejecting a production" 4
.IX Item "Rejecting a production"
The \f(CW\*(C`<reject>\*(C'\fR directive immediately causes the current production
to fail (it is exactly equivalent to, but more obvious than, the
action \f(CW\*(C`{undef}\*(C'\fR). A \f(CW\*(C`<reject>\*(C'\fR is useful when it is desirable to get
the side effects of the actions in one production, without prejudicing a match
by some other production later in the rule. For example, to insert
tracing code into the parse:
.Sp
.Vb 1
\&    complex_rule: { print "In complex rule...\en"; } <reject>
\&
\&    complex_rule: simple_rule \*(Aq+\*(Aq \*(Aqi\*(Aq \*(Aq*\*(Aq simple_rule
\&        | \*(Aqi\*(Aq \*(Aq*\*(Aq simple_rule
\&        | simple_rule
.Ve
.Sp
It is also possible to specify a conditional rejection, using the
form \f(CW\*(C`<reject:\f(CIcondition\f(CW>\*(C'\fR, which only rejects if the
specified condition is true. This form of rejection is exactly
equivalent to the action \f(CW\*(C`{(\f(CIcondition\f(CW)?undef:1}>\*(C'\fR.
For example:
.Sp
.Vb 4
\&    command: save_command
\&       | restore_command
\&       | <reject: defined $::tolerant> { exit }
\&       | <error: Unknown command. Ignored.>
.Ve
.Sp
A \f(CW\*(C`<reject>\*(C'\fR directive never succeeds (and hence has no
associated value). A conditional rejection may succeed (if its
condition is not satisfied), in which case its value is 1.
.Sp
As an extra optimization, \f(CW\*(C`Parse::RecDescent\*(C'\fR ignores any production
which \fIbegins\fR with an unconditional \f(CW\*(C`<reject>\*(C'\fR directive,
since any such production can never successfully match or have any
useful side-effects. A level 1 warning is issued in all such cases.
.Sp
Note that productions beginning with conditional
\&\f(CW\*(C`<reject:...>\*(C'\fR directives are \fInever\fR \*(L"optimized away\*(R" in
this manner, even if they are always guaranteed to fail (for example:
\&\f(CW\*(C`<reject:1>\*(C'\fR)
.Sp
Due to the way grammars are parsed, there is a minor restriction on the
condition of a conditional \f(CW\*(C`<reject:...>\*(C'\fR: it cannot
contain any raw '<' or '>' characters. For example:
.Sp
.Vb 1
\&    line: cmd <reject: $thiscolumn > max> data
.Ve
.Sp
results in an error when a parser is built from this grammar (since the
grammar parser has no way of knowing whether the first > is a \*(L"less than\*(R"
or the end of the \f(CW\*(C`<reject:...>\*(C'\fR.
.Sp
To overcome this problem, put the condition inside a do{} block:
.Sp
.Vb 1
\&    line: cmd <reject: do{$thiscolumn > max}> data
.Ve
.Sp
Note that the same problem may occur in other directives that take
arguments. The same solution will work in all cases.
.IP "Skipping between terminals" 4
.IX Item "Skipping between terminals"
The \f(CW\*(C`<skip>\*(C'\fR directive enables the terminal prefix used in
a production to be changed. For example:
.Sp
.Vb 1
\&    OneLiner: Command <skip:\*(Aq[ \et]*\*(Aq> Arg(s) /;/
.Ve
.Sp
causes only blanks and tabs to be skipped before terminals in the \f(CW\*(C`Arg\*(C'\fR
subrule (and any of \fIits\fR subrules>, and also before the final \f(CW\*(C`/;/\*(C'\fR terminal.
Once the production is complete, the previous terminal prefix is
reinstated. Note that this implies that distinct productions of a rule
must reset their terminal prefixes individually.
.Sp
The \f(CW\*(C`<skip>\*(C'\fR directive evaluates to the \fIprevious\fR terminal prefix,
so it's easy to reinstate a prefix later in a production:
.Sp
.Vb 1
\&    Command: <skip:","> CSV(s) <skip:$item[1]> Modifier
.Ve
.Sp
The value specified after the colon is interpolated into a pattern, so all of
the following are equivalent (though their efficiency increases down the list):
.Sp
.Vb 1
\&    <skip: "$colon|$comma">   # ASSUMING THE VARS HOLD THE OBVIOUS VALUES
\&
\&    <skip: \*(Aq:|,\*(Aq>
\&
\&    <skip: q{[:,]}>
\&
\&    <skip: qr/[:,]/>
.Ve
.Sp
There is no way of directly setting the prefix for
an entire rule, except as follows:
.Sp
.Vb 3
\&    Rule: <skip: \*(Aq[ \et]*\*(Aq> Prod1
\&        | <skip: \*(Aq[ \et]*\*(Aq> Prod2a Prod2b
\&        | <skip: \*(Aq[ \et]*\*(Aq> Prod3
.Ve
.Sp
or, better:
.Sp
.Vb 6
\&    Rule: <skip: \*(Aq[ \et]*\*(Aq>
\&    (
\&        Prod1
\&      | Prod2a Prod2b
\&      | Prod3
\&    )
.Ve
.Sp
The skip pattern is passed down to subrules, so setting the skip for
the top-level rule as described above actually sets the prefix for the
entire grammar (provided that you only call the method corresponding
to the top-level rule itself). Alternatively, or if you have more than
one top-level rule in your grammar, you can provide a global
\&\f(CW\*(C`<skip>\*(C'\fR directive prior to defining any rules in the
grammar. These are the preferred alternatives to setting
\&\f(CW$Parse::RecDescent::skip\fR.
.Sp
Additionally, using \f(CW\*(C`<skip>\*(C'\fR actually allows you to have
a completely dynamic skipping behaviour. For example:
.Sp
.Vb 1
\&   Rule_with_dynamic_skip: <skip: $::skip_pattern> Rule
.Ve
.Sp
Then you can set \f(CW$::skip_pattern\fR before invoking
\&\f(CW\*(C`Rule_with_dynamic_skip\*(C'\fR and have it skip whatever you specified.
.Sp
\&\fBNote: Up to release 1.51 of Parse::RecDescent, an entirely different
mechanism was used for specifying terminal prefixes. The current method
is not backwards-compatible with that early approach. The current approach
is stable and will not to change again.\fR
.IP "Resynchronization" 4
.IX Item "Resynchronization"
The \f(CW\*(C`<resync>\*(C'\fR directive provides a visually distinctive
means of consuming some of the text being parsed, usually to skip an
erroneous input. In its simplest form \f(CW\*(C`<resync>\*(C'\fR simply
consumes text up to and including the next newline (\f(CW"\en"\fR)
character, succeeding only if the newline is found, in which case it
causes its surrounding rule to return zero on success.
.Sp
In other words, a \f(CW\*(C`<resync>\*(C'\fR is exactly equivalent to the token
\&\f(CW\*(C`/[^\en]*\en/\*(C'\fR followed by the action \f(CW\*(C`{\ $return\ =\ 0\ }\*(C'\fR (except that
productions beginning with a \f(CW\*(C`<resync>\*(C'\fR are ignored when generating
error messages). A typical use might be:
.Sp
.Vb 1
\&    script : command(s)
\&
\&    command: save_command
\&       | restore_command
\&       | <resync> # TRY NEXT LINE, IF POSSIBLE
.Ve
.Sp
It is also possible to explicitly specify a resynchronization
pattern, using the \f(CW\*(C`<resync:\f(CIpattern\f(CW>\*(C'\fR variant. This version
succeeds only if the specified pattern matches (and consumes) the
parsed text. In other words, \f(CW\*(C`<resync:\f(CIpattern\f(CW>\*(C'\fR is exactly
equivalent to the token \f(CW\*(C`/\f(CIpattern\f(CW/\*(C'\fR (followed by a \f(CW\*(C`{\ $return\ =\ 0\ }\*(C'\fR
action). For example, if commands were terminated by newlines or semi-colons:
.Sp
.Vb 3
\&    command: save_command
\&       | restore_command
\&       | <resync:[^;\en]*[;\en]>
.Ve
.Sp
The value of a successfully matched \f(CW\*(C`<resync>\*(C'\fR directive (of either
type) is the text that it consumed. Note, however, that since the
directive also sets \f(CW$return\fR, a production consisting of a lone
\&\f(CW\*(C`<resync>\*(C'\fR succeeds but returns the value zero (which a calling rule
may find useful to distinguish between \*(L"true\*(R" matches and \*(L"tolerant\*(R" matches).
Remember that returning a zero value indicates that the rule \fIsucceeded\fR (since
only an \f(CW\*(C`undef\*(C'\fR denotes failure within \f(CW\*(C`Parse::RecDescent\*(C'\fR parsers.
.IP "Error handling" 4
.IX Item "Error handling"
The \f(CW\*(C`<error>\*(C'\fR directive provides automatic or user-defined
generation of error messages during a parse. In its simplest form
\&\f(CW\*(C`<error>\*(C'\fR prepares an error message based on
the mismatch between the last item expected and the text which cause
it to fail. For example, given the rule:
.Sp
.Vb 3
\&    McCoy: curse \*(Aq,\*(Aq name \*(Aq, I\*(Aqm a doctor, not a\*(Aq a_profession \*(Aq!\*(Aq
\&     | pronoun \*(Aqdead,\*(Aq name \*(Aq!\*(Aq
\&     | <error>
.Ve
.Sp
the following strings would produce the following messages:
.RS 4
.ie n .IP """Amen, Jim!""" 4
.el .IP "``Amen, Jim!''" 4
.IX Item "Amen, Jim!"
.Vb 2
\&       ERROR (line 1): Invalid McCoy: Expected curse or pronoun
\&           not found
.Ve
.ie n .IP """Dammit, Jim, I'm a doctor!""" 4
.el .IP "``Dammit, Jim, I'm a doctor!''" 4
.IX Item "Dammit, Jim, I'm a doctor!"
.Vb 2
\&       ERROR (line 1): Invalid McCoy: Expected ", I\*(Aqm a doctor, not a"
\&           but found ", I\*(Aqm a doctor!" instead
.Ve
.ie n .IP """He's dead,\en""" 4
.el .IP "``He's dead,\en''" 4
.IX Item "He's dead,n"
.Vb 1
\&       ERROR (line 2): Invalid McCoy: Expected name not found
.Ve
.ie n .IP """He's alive!""" 4
.el .IP "``He's alive!''" 4
.IX Item "He's alive!"
.Vb 2
\&       ERROR (line 1): Invalid McCoy: Expected \*(Aqdead,\*(Aq but found
\&           "alive!" instead
.Ve
.ie n .IP """Dammit, Jim, I'm a doctor, not a pointy-eared Vulcan!""" 4
.el .IP "``Dammit, Jim, I'm a doctor, not a pointy-eared Vulcan!''" 4
.IX Item "Dammit, Jim, I'm a doctor, not a pointy-eared Vulcan!"
.Vb 2
\&       ERROR (line 1): Invalid McCoy: Expected a profession but found
\&           "pointy\-eared Vulcan!" instead
.Ve
.RE
.RS 4
.Sp
Note that, when autogenerating error messages, all underscores in any
rule name used in a message are replaced by single spaces (for example
\&\*(L"a_production\*(R" becomes \*(L"a production\*(R"). Judicious choice of rule
names can therefore considerably improve the readability of automatic
error messages (as well as the maintainability of the original
grammar).
.Sp
If the automatically generated error is not sufficient, it is possible to
provide an explicit message as part of the error directive. For example:
.Sp
.Vb 3
\&    Spock: "Fascinating \*(Aq,\*(Aq (name | \*(AqCaptain\*(Aq) \*(Aq.\*(Aq
\&     | "Highly illogical, doctor."
\&     | <error: He never said that!>
.Ve
.Sp
which would result in \fIall\fR failures to parse a \*(L"Spock\*(R" subrule printing the
following message:
.Sp
.Vb 1
\&       ERROR (line <N>): Invalid Spock:  He never said that!
.Ve
.Sp
The error message is treated as a \*(L"qq{...}\*(R" string and interpolated
when the error is generated (\fInot\fR when the directive is specified!).
Hence:
.Sp
.Vb 1
\&    <error: Mystical error near "$text">
.Ve
.Sp
would correctly insert the ambient text string which caused the error.
.Sp
There are two other forms of error directive: \f(CW\*(C`<error?>\*(C'\fR and
\&\f(CW\*(C`<error?:\ msg>\*(C'\fR. These behave just like \f(CW\*(C`<error>\*(C'\fR
and \f(CW\*(C`<error:\ msg>\*(C'\fR respectively, except that they are
only triggered if the rule is \*(L"committed\*(R" at the time they are
encountered. For example:
.Sp
.Vb 3
\&    Scotty: "Ya kenna change the Laws of Phusics," <commit> name
\&      | name <commit> \*(Aq,\*(Aq \*(Aqshe\*(Aqs goanta blaw!\*(Aq
\&      | <error?>
.Ve
.Sp
will only generate an error for a string beginning with \*(L"Ya kenna
change the Laws o' Phusics,\*(R" or a valid name, but which still fails to match the
corresponding production. That is, \f(CW\*(C`$parser\->Scotty("Aye, Cap\*(Aqain")\*(C'\fR will
fail silently (since neither production will \*(L"commit\*(R" the rule on that
input), whereas \f(CW\*(C`$parser\->Scotty("Mr\ Spock,\ ah\ jest\ kenna\ do\*(Aqut!")\*(C'\fR
will fail with the error message:
.Sp
.Vb 2
\&       ERROR (line 1): Invalid Scotty: expected \*(Aqshe\*(Aqs goanta blaw!\*(Aq
\&           but found \*(AqI jest kenna do\*(Aqut!\*(Aq instead.
.Ve
.Sp
since in that case the second production would commit after matching
the leading name.
.Sp
Note that to allow this behaviour, all \f(CW\*(C`<error>\*(C'\fR directives which are
the first item in a production automatically uncommit the rule just
long enough to allow their production to be attempted (that is, when
their production fails, the commitment is reinstated so that
subsequent productions are skipped).
.Sp
In order to \fIpermanently\fR uncommit the rule before an error message,
it is necessary to put an explicit \f(CW\*(C`<uncommit>\*(C'\fR before the
\&\f(CW\*(C`<error>\*(C'\fR. For example:
.Sp
.Vb 5
\&    line: \*(AqKirk:\*(Aq  <commit> Kirk
\&    | \*(AqSpock:\*(Aq <commit> Spock
\&    | \*(AqMcCoy:\*(Aq <commit> McCoy
\&    | <uncommit> <error?> <reject>
\&    | <resync>
.Ve
.Sp
Error messages generated by the various \f(CW\*(C`<error...>\*(C'\fR directives
are not displayed immediately. Instead, they are \*(L"queued\*(R" in a buffer and
are only displayed once parsing ultimately fails. Moreover,
\&\f(CW\*(C`<error...>\*(C'\fR directives that cause one production of a rule
to fail are automatically removed from the message queue
if another production subsequently causes the entire rule to succeed.
This means that you can put
\&\f(CW\*(C`<error...>\*(C'\fR directives wherever useful diagnosis can be done,
and only those associated with actual parser failure will ever be
displayed. Also see \*(L"\s-1GOTCHAS\s0\*(R".
.Sp
As a general rule, the most useful diagnostics are usually generated
either at the very lowest level within the grammar, or at the very
highest. A good rule of thumb is to identify those subrules which
consist mainly (or entirely) of terminals, and then put an
\&\f(CW\*(C`<error...>\*(C'\fR directive at the end of any other rule which calls
one or more of those subrules.
.Sp
There is one other situation in which the output of the various types of
error directive is suppressed; namely, when the rule containing them
is being parsed as part of a \*(L"look-ahead\*(R" (see \*(L"Look-ahead\*(R"). In this
case, the error directive will still cause the rule to fail, but will do
so silently.
.Sp
An unconditional \f(CW\*(C`<error>\*(C'\fR directive always fails (and hence has no
associated value). This means that encountering such a directive
always causes the production containing it to fail. Hence an
\&\f(CW\*(C`<error>\*(C'\fR directive will inevitably be the last (useful) item of a
rule (a level 3 warning is issued if a production contains items after an unconditional
\&\f(CW\*(C`<error>\*(C'\fR directive).
.Sp
An \f(CW\*(C`<error?>\*(C'\fR directive will \fIsucceed\fR (that is: fail to fail :\-), if
the current rule is uncommitted when the directive is encountered. In
that case the directive's associated value is zero. Hence, this type
of error directive \fIcan\fR be used before the end of a
production. For example:
.Sp
.Vb 3
\&    command: \*(Aqdo\*(Aq <commit> something
\&       | \*(Aqreport\*(Aq <commit> something
\&       | <error?: Syntax error> <error: Unknown command>
.Ve
.Sp
\&\fBWarning:\fR The \f(CW\*(C`<error?>\*(C'\fR directive does \fInot\fR mean \*(L"always fail (but
do so silently unless committed)\*(R". It actually means "only fail (and report) if
committed, otherwise \fIsucceed\fR\*(L". To achieve the \*(R"fail silently if uncommitted"
semantics, it is necessary to use:
.Sp
.Vb 2
\&    rule: item <commit> item(s)
\&    | <error?> <reject>  # FAIL SILENTLY UNLESS COMMITTED
.Ve
.Sp
However, because people seem to expect a lone \f(CW\*(C`<error?>\*(C'\fR directive
to work like this:
.Sp
.Vb 3
\&    rule: item <commit> item(s)
\&    | <error?: Error message if committed>
\&    | <error:  Error message if uncommitted>
.Ve
.Sp
Parse::RecDescent automatically appends a
\&\f(CW\*(C`<reject>\*(C'\fR directive if the \f(CW\*(C`<error?>\*(C'\fR directive
is the only item in a production. A level 2 warning (see below)
is issued when this happens.
.Sp
The level of error reporting during both parser construction and
parsing is controlled by the presence or absence of four global
variables: \f(CW$::RD_ERRORS\fR, \f(CW$::RD_WARN\fR, \f(CW$::RD_HINT\fR, and
<$::RD_TRACE>. If \f(CW$::RD_ERRORS\fR is defined (and, by default, it is)
then fatal errors are reported.
.Sp
Whenever \f(CW$::RD_WARN\fR is defined, certain non-fatal problems are also reported.
.Sp
Warnings have an associated \*(L"level\*(R": 1, 2, or 3. The higher the level,
the more serious the warning. The value of the corresponding global
variable (\f(CW$::RD_WARN\fR) determines the \fIlowest\fR level of warning to
be displayed. Hence, to see \fIall\fR warnings, set \f(CW$::RD_WARN\fR to 1.
To see only the most serious warnings set \f(CW$::RD_WARN\fR to 3.
By default \f(CW$::RD_WARN\fR is initialized to 3, ensuring that serious but
non-fatal errors are automatically reported.
.Sp
There is also a grammar directive to turn on warnings from within the
grammar: \f(CW\*(C`<warn>\*(C'\fR. It takes an optional argument, which specifies
the warning level: \f(CW\*(C`<warn: 2>\*(C'\fR.
.Sp
See \fI\*(L"\s-1DIAGNOSTICS\s0\*(R"\fR for a list of the varous error and warning messages
that Parse::RecDescent generates when these two variables are defined.
.Sp
Defining any of the remaining variables (which are not defined by
default) further increases the amount of information reported.
Defining \f(CW$::RD_HINT\fR causes the parser generator to offer
more detailed analyses and hints on both errors and warnings.
Note that setting \f(CW$::RD_HINT\fR at any point automagically
sets \f(CW$::RD_WARN\fR to 1. There is also a \f(CW\*(C`<hint>\*(C'\fR directive, which can
be hard-coded into a grammar.
.Sp
Defining \f(CW$::RD_TRACE\fR causes the parser generator and the parser to
report their progress to \s-1STDERR\s0 in excruciating detail (although, without hints
unless \f(CW$::RD_HINT\fR is separately defined). This detail
can be moderated in only one respect: if \f(CW$::RD_TRACE\fR has an
integer value (\fIN\fR) greater than 1, only the \fIN\fR characters of
the \*(L"current parsing context\*(R" (that is, where in the input string we
are at any point in the parse) is reported at any time.
.Sp
\&\f(CW$::RD_TRACE\fR is mainly useful for debugging a grammar that isn't
behaving as you expected it to. To this end, if \f(CW$::RD_TRACE\fR is
defined when a parser is built, any actual parser code which is
generated is also written to a file named \*(L"\s-1RD_TRACE\s0\*(R" in the local
directory.
.Sp
There are two directives associated with the \f(CW$::RD_TRACE\fR variable.
If a grammar contains a \f(CW\*(C`<trace_build>\*(C'\fR directive anywhere in its
specification, \f(CW$::RD_TRACE\fR is turned on during the parser construction
phase.  If a grammar contains a \f(CW\*(C`<trace_parse>\*(C'\fR directive anywhere in its
specification, \f(CW$::RD_TRACE\fR is turned on during any parse the parser
performs.
.Sp
Note that the four variables belong to the \*(L"main\*(R" package, which
makes them easier to refer to in the code controlling the parser, and
also makes it easy to turn them into command line flags (\*(L"\-RD_ERRORS\*(R",
\&\*(L"\-RD_WARN\*(R", \*(L"\-RD_HINT\*(R", \*(L"\-RD_TRACE\*(R") under \fBperl \-s\fR.
.Sp
The corresponding directives are useful to \*(L"hardwire\*(R" the various
debugging features into a particular grammar (rather than having to set
and reset external variables).
.RE
.IP "Redirecting diagnostics" 4
.IX Item "Redirecting diagnostics"
The diagnostics provided by the tracing mechanism always go to \s-1STDERR\s0.
If you need them to go elsewhere, localize and reopen \s-1STDERR\s0 prior to the
parse.
.Sp
For example:
.Sp
.Vb 2
\&    {
\&        local *STDERR = IO::File\->new(">$filename") or die $!;
\&
\&        my $result = $parser\->startrule($text);
\&    }
.Ve
.IP "Consistency checks" 4
.IX Item "Consistency checks"
Whenever a parser is build, Parse::RecDescent carries out a number of
(potentially expensive) consistency checks. These include: verifying that the
grammar is not left-recursive and that no rules have been left undefined.
.Sp
These checks are important safeguards during development, but unnecessary
overheads when the grammar is stable and ready to be deployed. So
Parse::RecDescent provides a directive to disable them: \f(CW\*(C`<nocheck>\*(C'\fR.
.Sp
If a grammar contains a \f(CW\*(C`<nocheck>\*(C'\fR directive anywhere in its
specification, the extra compile-time checks are by-passed.
.IP "Specifying local variables" 4
.IX Item "Specifying local variables"
It is occasionally convenient to specify variables which are local
to a single rule. This may be achieved by including a
\&\f(CW\*(C`<rulevar:...>\*(C'\fR directive anywhere in the rule. For example:
.Sp
.Vb 1
\&    markup: <rulevar: $tag>
\&
\&    markup: tag {($tag=$item[1]) =~ s/^<|>$//g} body[$tag]
.Ve
.Sp
The example \f(CW\*(C`<rulevar: $tag>\*(C'\fR directive causes a \*(L"my\*(R" variable named
\&\f(CW$tag\fR to be declared at the start of the subroutine implementing the
\&\f(CW\*(C`markup\*(C'\fR rule (that is, \fIbefore\fR the first production, regardless of
where in the rule it is specified).
.Sp
Specifically, any directive of the form:
\&\f(CW\*(C`<rulevar:\f(CItext\f(CW>\*(C'\fR causes a line of the form \f(CW\*(C`my \f(CItext\f(CW;\*(C'\fR
to be added at the beginning of the rule subroutine, immediately after
the definitions of the following local variables:
.Sp
.Vb 4
\&    $thisparser $commit
\&    $thisrule   @item
\&    $thisline   @arg
\&    $text   %arg
.Ve
.Sp
This means that the following \f(CW\*(C`<rulevar>\*(C'\fR directives work
as expected:
.Sp
.Vb 1
\&    <rulevar: $count = 0 >
\&
\&    <rulevar: $firstarg = $arg[0] || \*(Aq\*(Aq >
\&
\&    <rulevar: $myItems = \e@item >
\&
\&    <rulevar: @context = ( $thisline, $text, @arg ) >
\&
\&    <rulevar: ($name,$age) = $arg{"name","age"} >
.Ve
.Sp
If a variable that is also visible to subrules is required, it needs
to be \f(CW\*(C`local\*(C'\fR'd, not \f(CW\*(C`my\*(C'\fR'd. \f(CW\*(C`rulevar\*(C'\fR defaults to \f(CW\*(C`my\*(C'\fR, but if \f(CW\*(C`local\*(C'\fR
is explicitly specified:
.Sp
.Vb 1
\&    <rulevar: local $count = 0 >
.Ve
.Sp
then a \f(CW\*(C`local\*(C'\fR\-ized variable is declared instead, and will be available
within subrules.
.Sp
Note however that, because all such variables are \*(L"my\*(R" variables, their
values \fIdo not persist\fR between match attempts on a given rule. To
preserve values between match attempts, values can be stored within the
\&\*(L"local\*(R" member of the \f(CW$thisrule\fR object:
.Sp
.Vb 6
\&    countedrule: { $thisrule\->{"local"}{"count"}++ }
\&         <reject>
\&       | subrule1
\&       | subrule2
\&       | <reject: $thisrule\->{"local"}{"count"} == 1>
\&         subrule3
.Ve
.Sp
When matching a rule, each \f(CW\*(C`<rulevar>\*(C'\fR directive is matched as
if it were an unconditional \f(CW\*(C`<reject>\*(C'\fR directive (that is, it
causes any production in which it appears to immediately fail to match).
For this reason (and to improve readability) it is usual to specify any
\&\f(CW\*(C`<rulevar>\*(C'\fR directive in a separate production at the start of
the rule (this has the added advantage that it enables
\&\f(CW\*(C`Parse::RecDescent\*(C'\fR to optimize away such productions, just as it does
for the \f(CW\*(C`<reject>\*(C'\fR directive).
.IP "Dynamically matched rules" 4
.IX Item "Dynamically matched rules"
Because regexes and double-quoted strings are interpolated, it is relatively
easy to specify productions with \*(L"context sensitive\*(R" tokens. For example:
.Sp
.Vb 1
\&    command:  keyword  body  "end $item[1]"
.Ve
.Sp
which ensures that a command block is bounded by a
"\fI<keyword>\fR...end \fI<same keyword>\fR" pair.
.Sp
Building productions in which subrules are context sensitive is also possible,
via the \f(CW\*(C`<matchrule:...>\*(C'\fR directive. This directive behaves
identically to a subrule item, except that the rule which is invoked to match
it is determined by the string specified after the colon. For example, we could
rewrite the \f(CW\*(C`command\*(C'\fR rule like this:
.Sp
.Vb 1
\&    command:  keyword  <matchrule:body>  "end $item[1]"
.Ve
.Sp
Whatever appears after the colon in the directive is treated as an interpolated
string (that is, as if it appeared in \f(CW\*(C`qq{...}\*(C'\fR operator) and the value of
that interpolated string is the name of the subrule to be matched.
.Sp
Of course, just putting a constant string like \f(CW\*(C`body\*(C'\fR in a
\&\f(CW\*(C`<matchrule:...>\*(C'\fR directive is of little interest or benefit.
The power of directive is seen when we use a string that interpolates
to something interesting. For example:
.Sp
.Vb 1
\&    command:    keyword <matchrule:$item[1]_body> "end $item[1]"
\&
\&    keyword:    \*(Aqwhile\*(Aq | \*(Aqif\*(Aq | \*(Aqfunction\*(Aq
\&
\&    while_body: condition block
\&
\&    if_body:    condition block (\*(Aqelse\*(Aq block)(?)
\&
\&    function_body:  arglist block
.Ve
.Sp
Now the \f(CW\*(C`command\*(C'\fR rule selects how to proceed on the basis of the keyword
that is found. It is as if \f(CW\*(C`command\*(C'\fR were declared:
.Sp
.Vb 3
\&    command:    \*(Aqwhile\*(Aq    while_body    "end while"
\&       |    \*(Aqif\*(Aq       if_body   "end if"
\&       |    \*(Aqfunction\*(Aq function_body "end function"
.Ve
.Sp
When a \f(CW\*(C`<matchrule:...>\*(C'\fR directive is used as a repeated
subrule, the rule name expression is \*(L"late-bound\*(R". That is, the name of
the rule to be called is re-evaluated \fIeach time\fR a match attempt is
made. Hence, the following grammar:
.Sp
.Vb 1
\&    { $::species = \*(Aqdogs\*(Aq }
\&
\&    pair:   \*(Aqtwo\*(Aq <matchrule:$::species>(s)
\&
\&    dogs:   /dogs/ { $::species = \*(Aqcats\*(Aq }
\&
\&    cats:   /cats/
.Ve
.Sp
will match the string \*(L"two dogs cats cats\*(R" completely, whereas it will
only match the string \*(L"two dogs dogs dogs\*(R" up to the eighth letter. If
the rule name were \*(L"early bound\*(R" (that is, evaluated only the first
time the directive is encountered in a production), the reverse
behaviour would be expected.
.Sp
Note that the \f(CW\*(C`matchrule\*(C'\fR directive takes a string that is to be treated
as a rule name, \fInot\fR as a rule invocation. That is,
it's like a Perl symbolic reference, not an \f(CW\*(C`eval\*(C'\fR. Just as you can say:
.Sp
.Vb 1
\&    $subname = \*(Aqfoo\*(Aq;
\&
\&    # and later...
\&
\&    &{$foo}(@args);
.Ve
.Sp
but not:
.Sp
.Vb 1
\&    $subname = \*(Aqfoo(@args)\*(Aq;
\&
\&    # and later...
\&
\&    &{$foo};
.Ve
.Sp
likewise you can say:
.Sp
.Vb 1
\&    $rulename = \*(Aqfoo\*(Aq;
\&
\&    # and in the grammar...
\&
\&    <matchrule:$rulename>[@args]
.Ve
.Sp
but not:
.Sp
.Vb 1
\&    $rulename = \*(Aqfoo[@args]\*(Aq;
\&
\&    # and in the grammar...
\&
\&    <matchrule:$rulename>
.Ve
.IP "Deferred actions" 4
.IX Item "Deferred actions"
The \f(CW\*(C`<defer:...>\*(C'\fR directive is used to specify an action to be
performed when (and only if!) the current production ultimately succeeds.
.Sp
Whenever a \f(CW\*(C`<defer:...>\*(C'\fR directive appears, the code it specifies
is converted to a closure (an anonymous subroutine reference) which is
queued within the active parser object. Note that,
because the deferred code is converted to a closure, the values of any
\&\*(L"local\*(R" variable (such as \f(CW$text\fR, <@item>, etc.) are preserved
until the deferred code is actually executed.
.Sp
If the parse ultimately succeeds
\&\fIand\fR the production in which the \f(CW\*(C`<defer:...>\*(C'\fR directive was
evaluated formed part of the successful parse, then the deferred code is
executed immediately before the parse returns. If however the production
which queued a deferred action fails, or one of the higher-level
rules which called that production fails, then the deferred action is
removed from the queue, and hence is never executed.
.Sp
For example, given the grammar:
.Sp
.Vb 2
\&    sentence: noun trans noun
\&    | noun intrans
\&
\&    noun:     \*(Aqthe dog\*(Aq
\&        { print "$item[1]\et(noun)\en" }
\&    |     \*(Aqthe meat\*(Aq
\&        { print "$item[1]\et(noun)\en" }
\&
\&    trans:    \*(Aqate\*(Aq
\&        { print "$item[1]\et(transitive)\en" }
\&
\&    intrans:  \*(Aqate\*(Aq
\&        { print "$item[1]\et(intransitive)\en" }
\&       |  \*(Aqbarked\*(Aq
\&        { print "$item[1]\et(intransitive)\en" }
.Ve
.Sp
then parsing the sentence \f(CW"the dog ate"\fR would produce the output:
.Sp
.Vb 4
\&    the dog  (noun)
\&    ate  (transitive)
\&    the dog  (noun)
\&    ate  (intransitive)
.Ve
.Sp
This is because, even though the first production of \f(CW\*(C`sentence\*(C'\fR
ultimately fails, its initial subrules \f(CW\*(C`noun\*(C'\fR and \f(CW\*(C`trans\*(C'\fR do match,
and hence they execute their associated actions.
Then the second production of \f(CW\*(C`sentence\*(C'\fR succeeds, causing the
actions of the subrules \f(CW\*(C`noun\*(C'\fR and \f(CW\*(C`intrans\*(C'\fR to be executed as well.
.Sp
On the other hand, if the actions were replaced by \f(CW\*(C`<defer:...>\*(C'\fR
directives:
.Sp
.Vb 2
\&    sentence: noun trans noun
\&    | noun intrans
\&
\&    noun:     \*(Aqthe dog\*(Aq
\&        <defer: print "$item[1]\et(noun)\en" >
\&    |     \*(Aqthe meat\*(Aq
\&        <defer: print "$item[1]\et(noun)\en" >
\&
\&    trans:    \*(Aqate\*(Aq
\&        <defer: print "$item[1]\et(transitive)\en" >
\&
\&    intrans:  \*(Aqate\*(Aq
\&        <defer: print "$item[1]\et(intransitive)\en" >
\&       |  \*(Aqbarked\*(Aq
\&        <defer: print "$item[1]\et(intransitive)\en" >
.Ve
.Sp
the output would be:
.Sp
.Vb 2
\&    the dog  (noun)
\&    ate  (intransitive)
.Ve
.Sp
since deferred actions are only executed if they were evaluated in
a production which ultimately contributes to the successful parse.
.Sp
In this case, even though the first production of \f(CW\*(C`sentence\*(C'\fR caused
the subrules \f(CW\*(C`noun\*(C'\fR and \f(CW\*(C`trans\*(C'\fR to match, that production ultimately
failed and so the deferred actions queued by those subrules were subsequently
disgarded. The second production then succeeded, causing the entire
parse to succeed, and so the deferred actions queued by the (second) match of
the \f(CW\*(C`noun\*(C'\fR subrule and the subsequent match of \f(CW\*(C`intrans\*(C'\fR \fIare\fR preserved and
eventually executed.
.Sp
Deferred actions provide a means of improving the performance of a parser,
by only executing those actions which are part of the final parse-tree
for the input data.
.Sp
Alternatively, deferred actions can be viewed as a mechanism for building
(and executing) a
customized subroutine corresponding to the given input data, much in the
same way that autoactions (see \*(L"Autoactions\*(R") can be used to build a
customized data structure for specific input.
.Sp
Whether or not the action it specifies is ever executed,
a \f(CW\*(C`<defer:...>\*(C'\fR directive always succeeds, returning the
number of deferred actions currently queued at that point.
.IP "Parsing Perl" 4
.IX Item "Parsing Perl"
Parse::RecDescent provides limited support for parsing subsets of Perl,
namely: quote-like operators, Perl variables, and complete code blocks.
.Sp
The \f(CW\*(C`<perl_quotelike>\*(C'\fR directive can be used to parse any Perl
quote-like operator: \f(CW\*(Aqa string\*(Aq\fR, \f(CW\*(C`m/a pattern/\*(C'\fR, \f(CW\*(C`tr{ans}{lation}\*(C'\fR,
etc.  It does this by calling \fIText::Balanced::quotelike()\fR.
.Sp
If a quote-like operator is found, a reference to an array of eight elements
is returned. Those elements are identical to the last eight elements returned
by \fIText::Balanced::extract_quotelike()\fR in an array context, namely:
.RS 4
.IP "[0]" 4
.IX Item "[0]"
the name of the quotelike operator \*(-- 'q', 'qq', 'm', 's', 'tr' \*(-- if the
operator was named; otherwise \f(CW\*(C`undef\*(C'\fR,
.IP "[1]" 4
.IX Item "[1]"
the left delimiter of the first block of the operation,
.IP "[2]" 4
.IX Item "[2]"
the text of the first block of the operation
(that is, the contents of
a quote, the regex of a match, or substitution or the target list of a
translation),
.IP "[3]" 4
.IX Item "[3]"
the right delimiter of the first block of the operation,
.IP "[4]" 4
.IX Item "[4]"
the left delimiter of the second block of the operation if there is one
(that is, if it is a \f(CW\*(C`s\*(C'\fR, \f(CW\*(C`tr\*(C'\fR, or \f(CW\*(C`y\*(C'\fR); otherwise \f(CW\*(C`undef\*(C'\fR,
.IP "[5]" 4
.IX Item "[5]"
the text of the second block of the operation if there is one
(that is, the replacement of a substitution or the translation list
of a translation); otherwise \f(CW\*(C`undef\*(C'\fR,
.IP "[6]" 4
.IX Item "[6]"
the right delimiter of the second block of the operation (if any);
otherwise \f(CW\*(C`undef\*(C'\fR,
.IP "[7]" 4
.IX Item "[7]"
the trailing modifiers on the operation (if any); otherwise \f(CW\*(C`undef\*(C'\fR.
.RE
.RS 4
.Sp
If a quote-like expression is not found, the directive fails with the usual
\&\f(CW\*(C`undef\*(C'\fR value.
.Sp
The \f(CW\*(C`<perl_variable>\*(C'\fR directive can be used to parse any Perl
variable: \f(CW$scalar\fR, \f(CW@array\fR, \f(CW%hash\fR, \f(CW$ref\fR\->{field}[$index], etc.
It does this by calling \fIText::Balanced::extract_variable()\fR.
.Sp
If the directive matches text representing a valid Perl variable
specification, it returns that text. Otherwise it fails with the usual
\&\f(CW\*(C`undef\*(C'\fR value.
.Sp
The \f(CW\*(C`<perl_codeblock>\*(C'\fR directive can be used to parse curly-brace-delimited block of Perl code, such as: { \f(CW$a\fR = 1; f() =~ m/pat/; }.
It does this by calling \fIText::Balanced::extract_codeblock()\fR.
.Sp
If the directive matches text representing a valid Perl code block,
it returns that text. Otherwise it fails with the usual \f(CW\*(C`undef\*(C'\fR value.
.Sp
You can also tell it what kind of brackets to use as the outermost
delimiters. For example:
.Sp
.Vb 1
\&    arglist: <perl_codeblock ()>
.Ve
.Sp
causes an arglist to match a perl code block whose outermost delimiters
are \f(CW\*(C`(...)\*(C'\fR (rather than the default \f(CW\*(C`{...}\*(C'\fR).
.RE
.IP "Constructing tokens" 4
.IX Item "Constructing tokens"
Eventually, Parse::RecDescent will be able to parse tokenized input, as
well as ordinary strings. In preparation for this joyous day, the
\&\f(CW\*(C`<token:...>\*(C'\fR directive has been provided.
This directive creates a token which will be suitable for
input to a Parse::RecDescent parser (when it eventually supports
tokenized input).
.Sp
The text of the token is the value of the
immediately preceding item in the production. A
\&\f(CW\*(C`<token:...>\*(C'\fR directive always succeeds with a return
value which is the hash reference that is the new token. It also
sets the return value for the production to that hash ref.
.Sp
The \f(CW\*(C`<token:...>\*(C'\fR directive makes it easy to build
a Parse::RecDescent\-compatible lexer in Parse::RecDescent:
.Sp
.Vb 3
\&    my $lexer = new Parse::RecDescent q
\&    {
\&    lex:    token(s)
\&
\&    token:  /a\eb/          <token:INDEF>
\&         |  /the\eb/        <token:DEF>
\&         |  /fly\eb/        <token:NOUN,VERB>
\&         |  /[a\-z]+/i { lc $item[1] }  <token:ALPHA>
\&         |  <error: Unknown token>
\&
\&    };
.Ve
.Sp
which will eventually be able to be used with a regular Parse::RecDescent
grammar:
.Sp
.Vb 3
\&    my $parser = new Parse::RecDescent q
\&    {
\&    startrule: subrule1 subrule 2
\&
\&    # ETC...
\&    };
.Ve
.Sp
either with a pre-lexing phase:
.Sp
.Vb 1
\&    $parser\->startrule( $lexer\->lex($data) );
.Ve
.Sp
or with a lex-on-demand approach:
.Sp
.Vb 1
\&    $parser\->startrule( sub{$lexer\->token(\e$data)} );
.Ve
.Sp
But at present, only the \f(CW\*(C`<token:...>\*(C'\fR directive is
actually implemented. The rest is vapourware.
.IP "Specifying operations" 4
.IX Item "Specifying operations"
One of the commonest requirements when building a parser is to specify
binary operators. Unfortunately, in a normal grammar, the rules for
such things are awkward:
.Sp
.Vb 2
\&    disjunction:    conjunction (\*(Aqor\*(Aq conjunction)(s?)
\&        { $return = [ $item[1], @{$item[2]} ] }
\&
\&    conjunction:    atom (\*(Aqand\*(Aq atom)(s?)
\&        { $return = [ $item[1], @{$item[2]} ] }
.Ve
.Sp
or inefficient:
.Sp
.Vb 4
\&    disjunction:    conjunction \*(Aqor\*(Aq disjunction
\&        { $return = [ $item[1], @{$item[2]} ] }
\&       |    conjunction
\&        { $return = [ $item[1] ] }
\&
\&    conjunction:    atom \*(Aqand\*(Aq conjunction
\&        { $return = [ $item[1], @{$item[2]} ] }
\&       |    atom
\&        { $return = [ $item[1] ] }
.Ve
.Sp
and either way is ugly and hard to get right.
.Sp
The \f(CW\*(C`<leftop:...>\*(C'\fR and \f(CW\*(C`<rightop:...>\*(C'\fR directives provide an
easier way of specifying such operations. Using \f(CW\*(C`<leftop:...>\*(C'\fR the
above examples become:
.Sp
.Vb 2
\&    disjunction:    <leftop: conjunction \*(Aqor\*(Aq conjunction>
\&    conjunction:    <leftop: atom \*(Aqand\*(Aq atom>
.Ve
.Sp
The \f(CW\*(C`<leftop:...>\*(C'\fR directive specifies a left-associative binary operator.
It is specified around three other grammar elements
(typically subrules or terminals), which match the left operand,
the operator itself, and the right operand respectively.
.Sp
A \f(CW\*(C`<leftop:...>\*(C'\fR directive such as:
.Sp
.Vb 1
\&    disjunction:    <leftop: conjunction \*(Aqor\*(Aq conjunction>
.Ve
.Sp
is converted to the following:
.Sp
.Vb 2
\&    disjunction:    ( conjunction (\*(Aqor\*(Aq conjunction)(s?)
\&        { $return = [ $item[1], @{$item[2]} ] } )
.Ve
.Sp
In other words, a \f(CW\*(C`<leftop:...>\*(C'\fR directive matches the left operand followed by zero
or more repetitions of both the operator and the right operand. It then
flattens the matched items into an anonymous array which becomes the
(single) value of the entire \f(CW\*(C`<leftop:...>\*(C'\fR directive.
.Sp
For example, an \f(CW\*(C`<leftop:...>\*(C'\fR directive such as:
.Sp
.Vb 1
\&    output:  <leftop: ident \*(Aq<<\*(Aq expr >
.Ve
.Sp
when given a string such as:
.Sp
.Vb 1
\&    cout << var << "str" << 3
.Ve
.Sp
would match, and \f(CW$item[1]\fR would be set to:
.Sp
.Vb 1
\&    [ \*(Aqcout\*(Aq, \*(Aqvar\*(Aq, \*(Aq"str"\*(Aq, \*(Aq3\*(Aq ]
.Ve
.Sp
In other words:
.Sp
.Vb 1
\&    output:  <leftop: ident \*(Aq<<\*(Aq expr >
.Ve
.Sp
is equivalent to a left-associative operator:
.Sp
.Vb 5
\&    output:  ident          { $return = [$item[1]]   }
\&          |  ident \*(Aq<<\*(Aq expr        { $return = [@item[1,3]]     }
\&          |  ident \*(Aq<<\*(Aq expr \*(Aq<<\*(Aq expr      { $return = [@item[1,3,5]]   }
\&          |  ident \*(Aq<<\*(Aq expr \*(Aq<<\*(Aq expr \*(Aq<<\*(Aq expr    { $return = [@item[1,3,5,7]] }
\&          #  ...etc...
.Ve
.Sp
Similarly, the \f(CW\*(C`<rightop:...>\*(C'\fR directive takes a left operand, an operator, and a right operand:
.Sp
.Vb 1
\&    assign:  <rightop: var \*(Aq=\*(Aq expr >
.Ve
.Sp
and converts them to:
.Sp
.Vb 2
\&    assign:  ( (var \*(Aq=\*(Aq {$return=$item[1]})(s?) expr
\&        { $return = [ @{$item[1]}, $item[2] ] } )
.Ve
.Sp
which is equivalent to a right-associative operator:
.Sp
.Vb 5
\&    assign:  expr       { $return = [$item[1]]       }
\&          |  var \*(Aq=\*(Aq expr       { $return = [@item[1,3]]     }
\&          |  var \*(Aq=\*(Aq var \*(Aq=\*(Aq expr   { $return = [@item[1,3,5]]   }
\&          |  var \*(Aq=\*(Aq var \*(Aq=\*(Aq var \*(Aq=\*(Aq expr   { $return = [@item[1,3,5,7]] }
\&          #  ...etc...
.Ve
.Sp
Note that for both the \f(CW\*(C`<leftop:...>\*(C'\fR and \f(CW\*(C`<rightop:...>\*(C'\fR directives, the directive does not normally
return the operator itself, just a list of the operands involved. This is
particularly handy for specifying lists:
.Sp
.Vb 2
\&    list: \*(Aq(\*(Aq <leftop: list_item \*(Aq,\*(Aq list_item> \*(Aq)\*(Aq
\&        { $return = $item[2] }
.Ve
.Sp
There is, however, a problem: sometimes the operator is itself significant.
For example, in a Perl list a comma and a \f(CW\*(C`=>\*(C'\fR are both
valid separators, but the \f(CW\*(C`=>\*(C'\fR has additional stringification semantics.
Hence it's important to know which was used in each case.
.Sp
To solve this problem the
\&\f(CW\*(C`<leftop:...>\*(C'\fR and \f(CW\*(C`<rightop:...>\*(C'\fR directives
\&\fIdo\fR return the operator(s) as well, under two circumstances.
The first case is where the operator is specified as a subrule. In that instance,
whatever the operator matches is returned (on the assumption that if the operator
is important enough to have its own subrule, then it's important enough to return).
.Sp
The second case is where the operator is specified as a regular
expression. In that case, if the first bracketed subpattern of the
regular expression matches, that matching value is returned (this is analogous to
the behaviour of the Perl \f(CW\*(C`split\*(C'\fR function, except that only the first subpattern
is returned).
.Sp
In other words, given the input:
.Sp
.Vb 1
\&    ( a=>1, b=>2 )
.Ve
.Sp
the specifications:
.Sp
.Vb 1
\&    list:      \*(Aq(\*(Aq  <leftop: list_item separator list_item>  \*(Aq)\*(Aq
\&
\&    separator: \*(Aq,\*(Aq | \*(Aq=>\*(Aq
.Ve
.Sp
or:
.Sp
.Vb 1
\&    list:      \*(Aq(\*(Aq  <leftop: list_item /(,|=>)/ list_item>  \*(Aq)\*(Aq
.Ve
.Sp
cause the list separators to be interleaved with the operands in the
anonymous array in \f(CW$item[2]\fR:
.Sp
.Vb 1
\&    [ \*(Aqa\*(Aq, \*(Aq=>\*(Aq, \*(Aq1\*(Aq, \*(Aq,\*(Aq, \*(Aqb\*(Aq, \*(Aq=>\*(Aq, \*(Aq2\*(Aq ]
.Ve
.Sp
But the following version:
.Sp
.Vb 1
\&    list:      \*(Aq(\*(Aq  <leftop: list_item /,|=>/ list_item>  \*(Aq)\*(Aq
.Ve
.Sp
returns only the operators:
.Sp
.Vb 1
\&    [ \*(Aqa\*(Aq, \*(Aq1\*(Aq, \*(Aqb\*(Aq, \*(Aq2\*(Aq ]
.Ve
.Sp
Of course, none of the above specifications handle the case of an empty
list, since the \f(CW\*(C`<leftop:...>\*(C'\fR and \f(CW\*(C`<rightop:...>\*(C'\fR directives
require at least a single right or left operand to match. To specify
that the operator can match \*(L"trivially\*(R",
it's necessary to add a \f(CW\*(C`(s?)\*(C'\fR qualifier to the directive:
.Sp
.Vb 1
\&    list:      \*(Aq(\*(Aq  <leftop: list_item /(,|=>)/ list_item>(s?)  \*(Aq)\*(Aq
.Ve
.Sp
Note that in almost all the above examples, the first and third arguments
of the \f(CW\*(C`<leftop:...>\*(C'\fR directive were the same subrule. That is because
\&\f(CW\*(C`<leftop:...>\*(C'\fR's are frequently used to specify \*(L"separated\*(R" lists of the
same type of item. To make such lists easier to specify, the following
syntax:
.Sp
.Vb 1
\&    list:   element(s /,/)
.Ve
.Sp
is exactly equivalent to:
.Sp
.Vb 1
\&    list:   <leftop: element /,/ element>
.Ve
.Sp
Note that the separator must be specified as a raw pattern (i.e.
not a string or subrule).
.IP "Scored productions" 4
.IX Item "Scored productions"
By default, Parse::RecDescent grammar rules always accept the first
production that matches the input. But if two or more productions may
potentially match the same input, choosing the first that does so may
not be optimal.
.Sp
For example, if you were parsing the sentence \*(L"time flies like an arrow\*(R",
you might use a rule like this:
.Sp
.Vb 3
\&    sentence: verb noun preposition article noun { [@item] }
\&    | adjective noun verb article noun   { [@item] }
\&    | noun verb preposition article noun { [@item] }
.Ve
.Sp
Each of these productions matches the sentence, but the third one
is the most likely interpretation. However, if the sentence had been
\&\*(L"fruit flies like a banana\*(R", then the second production is probably
the right match.
.Sp
To cater for such situtations, the \f(CW\*(C`<score:...>\*(C'\fR can be used.
The directive is equivalent to an unconditional \f(CW\*(C`<reject>\*(C'\fR,
except that it allows you to specify a \*(L"score\*(R" for the current
production. If that score is numerically greater than the best
score of any preceding production, the current production is cached for later
consideration. If no later production matches, then the cached
production is treated as having matched, and the value of the
item immediately before its \f(CW\*(C`<score:...>\*(C'\fR directive is returned as the
result.
.Sp
In other words, by putting a \f(CW\*(C`<score:...>\*(C'\fR directive at the end of
each production, you can select which production matches using
criteria other than specification order. For example:
.Sp
.Vb 3
\&    sentence: verb noun preposition article noun { [@item] } <score: sensible(@item)>
\&    | adjective noun verb article noun   { [@item] } <score: sensible(@item)>
\&    | noun verb preposition article noun { [@item] } <score: sensible(@item)>
.Ve
.Sp
Now, when each production reaches its respective \f(CW\*(C`<score:...>\*(C'\fR
directive, the subroutine \f(CW\*(C`sensible\*(C'\fR will be called to evaluate the
matched items (somehow). Once all productions have been tried, the
one which \f(CW\*(C`sensible\*(C'\fR scored most highly will be the one that is
accepted as a match for the rule.
.Sp
The variable \f(CW$score\fR always holds the current best score of any production,
and the variable \f(CW$score_return\fR holds the corresponding return value.
.Sp
As another example, the following grammar matches lines that may be
separated by commas, colons, or semi-colons. This can be tricky if
a colon-separated line also contains commas, or vice versa. The grammar
resolves the ambiguity by selecting the rule that results in the
fewest fields:
.Sp
.Vb 3
\&    line: seplist[sep=>\*(Aq,\*(Aq]  <score: \-@{$item[1]}>
\&    | seplist[sep=>\*(Aq:\*(Aq]  <score: \-@{$item[1]}>
\&    | seplist[sep=>" "]  <score: \-@{$item[1]}>
\&
\&    seplist: <skip:""> <leftop: /[^$arg{sep}]*/ "$arg{sep}" /[^$arg{sep}]*/>
.Ve
.Sp
Note the use of negation within the \f(CW\*(C`<score:...>\*(C'\fR directive
to ensure that the seplist with the most items gets the lowest score.
.Sp
As the above examples indicate, it is often the case that all productions
in a rule use exactly the same \f(CW\*(C`<score:...>\*(C'\fR directive. It is
tedious to have to repeat this identical directive in every production, so
Parse::RecDescent also provides the \f(CW\*(C`<autoscore:...>\*(C'\fR directive.
.Sp
If an \f(CW\*(C`<autoscore:...>\*(C'\fR directive appears in any
production of a rule, the code it specifies is used as the scoring
code for every production of that rule, except productions that already
end with an explicit \f(CW\*(C`<score:...>\*(C'\fR directive. Thus the rules above could
be rewritten:
.Sp
.Vb 4
\&    line: <autoscore: \-@{$item[1]}>
\&    line: seplist[sep=>\*(Aq,\*(Aq]
\&    | seplist[sep=>\*(Aq:\*(Aq]
\&    | seplist[sep=>" "]
\&
\&
\&    sentence: <autoscore: sensible(@item)>
\&    | verb noun preposition article noun { [@item] }
\&    | adjective noun verb article noun   { [@item] }
\&    | noun verb preposition article noun { [@item] }
.Ve
.Sp
Note that the \f(CW\*(C`<autoscore:...>\*(C'\fR directive itself acts as an
unconditional \f(CW\*(C`<reject>\*(C'\fR, and (like the \f(CW\*(C`<rulevar:...>\*(C'\fR
directive) is pruned at compile-time wherever possible.
.IP "Dispensing with grammar checks" 4
.IX Item "Dispensing with grammar checks"
During the compilation phase of parser construction, Parse::RecDescent performs
a small number of checks on the grammar it's given. Specifically it checks that
the grammar is not left-recursive, that there are no \*(L"insatiable\*(R" constructs of
the form:
.Sp
.Vb 1
\&    rule: subrule(s) subrule
.Ve
.Sp
and that there are no rules missing (i.e. referred to, but never defined).
.Sp
These checks are important during development, but can slow down parser
construction in stable code. So Parse::RecDescent provides the
<nocheck> directive to turn them off. The directive can only appear
before the first rule definition, and switches off checking throughout the rest
of the current grammar.
.Sp
Typically, this directive would be added when a parser has been thoroughly
tested and is ready for release.
.SS "Subrule argument lists"
.IX Subsection "Subrule argument lists"
It is occasionally useful to pass data to a subrule which is being invoked. For
example, consider the following grammar fragment:
.PP
.Vb 1
\&    classdecl: keyword decl
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      # WHATEVER
.Ve
.PP
The \f(CW\*(C`decl\*(C'\fR rule might wish to know which of the two keywords was used
(since it may affect some aspect of the way the subsequent declaration
is interpreted). \f(CW\*(C`Parse::RecDescent\*(C'\fR allows the grammar designer to
pass data into a rule, by placing that data in an \fIargument list\fR
(that is, in square brackets) immediately after any subrule item in a
production. Hence, we could pass the keyword to \f(CW\*(C`decl\*(C'\fR as follows:
.PP
.Vb 1
\&    classdecl: keyword decl[ $item[1] ]
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      # WHATEVER
.Ve
.PP
The argument list can consist of any number (including zero!) of comma-separated
Perl expressions. In other words, it looks exactly like a Perl anonymous
array reference. For example, we could pass the keyword, the name of the
surrounding rule, and the literal 'keyword' to \f(CW\*(C`decl\*(C'\fR like so:
.PP
.Vb 1
\&    classdecl: keyword decl[$item[1],$item[0],\*(Aqkeyword\*(Aq]
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      # WHATEVER
.Ve
.PP
Within the rule to which the data is passed (\f(CW\*(C`decl\*(C'\fR in the above examples)
that data is available as the elements of a local variable \f(CW@arg\fR. Hence
\&\f(CW\*(C`decl\*(C'\fR might report its intentions as follows:
.PP
.Vb 1
\&    classdecl: keyword decl[$item[1],$item[0],\*(Aqkeyword\*(Aq]
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      { print "Declaring $arg[0] (a $arg[2])\en";
\&         print "(this rule called by $arg[1])" }
.Ve
.PP
Subrule argument lists can also be interpreted as hashes, simply by using
the local variable \f(CW%arg\fR instead of \f(CW@arg\fR. Hence we could rewrite the
previous example:
.PP
.Vb 3
\&    classdecl: keyword decl[keyword => $item[1],
\&        caller  => $item[0],
\&        type    => \*(Aqkeyword\*(Aq]
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      { print "Declaring $arg{keyword} (a $arg{type})\en";
\&         print "(this rule called by $arg{caller})" }
.Ve
.PP
Both \f(CW@arg\fR and \f(CW%arg\fR are always available, so the grammar designer may
choose whichever convention (or combination of conventions) suits best.
.PP
Subrule argument lists are also useful for creating \*(L"rule templates\*(R"
(especially when used in conjunction with the \f(CW\*(C`<matchrule:...>\*(C'\fR
directive). For example, the subrule:
.PP
.Vb 4
\&    list:     <matchrule:$arg{rule}> /$arg{sep}/ list[%arg]
\&        { $return = [ $item[1], @{$item[3]} ] }
\&    |     <matchrule:$arg{rule}>
\&        { $return = [ $item[1]] }
.Ve
.PP
is a handy template for the common problem of matching a separated list.
For example:
.PP
.Vb 1
\&    function: \*(Aqfunc\*(Aq name \*(Aq(\*(Aq list[rule=>\*(Aqparam\*(Aq,sep=>\*(Aq;\*(Aq] \*(Aq)\*(Aq
\&
\&    param:    list[rule=>\*(Aqname\*(Aq,sep=>\*(Aq,\*(Aq] \*(Aq:\*(Aq typename
\&
\&    name:     /\ew+/
\&
\&    typename: name
.Ve
.PP
When a subrule argument list is used with a repeated subrule, the argument list
goes \fIbefore\fR the repetition specifier:
.PP
.Vb 1
\&    list:   /some|many/ thing[ $item[1] ](s)
.Ve
.PP
The argument list is \*(L"late bound\*(R". That is, it is re-evaluated for every
repetition of the repeated subrule.
This means that each repeated attempt to match the subrule may be
passed a completely different set of arguments if the value of the
expression in the argument list changes between attempts. So, for
example, the grammar:
.PP
.Vb 1
\&    { $::species = \*(Aqdogs\*(Aq }
\&
\&    pair:   \*(Aqtwo\*(Aq animal[$::species](s)
\&
\&    animal: /$arg[0]/ { $::species = \*(Aqcats\*(Aq }
.Ve
.PP
will match the string \*(L"two dogs cats cats\*(R" completely, whereas
it will only match the string \*(L"two dogs dogs dogs\*(R" up to the
eighth letter. If the value of the argument list were \*(L"early bound\*(R"
(that is, evaluated only the first time a repeated subrule match is
attempted), one would expect the matching behaviours to be reversed.
.PP
Of course, it is possible to effectively \*(L"early bind\*(R" such argument lists
by passing them a value which does not change on each repetition. For example:
.PP
.Vb 1
\&    { $::species = \*(Aqdogs\*(Aq }
\&
\&    pair:   \*(Aqtwo\*(Aq { $::species } animal[$item[2]](s)
\&
\&    animal: /$arg[0]/ { $::species = \*(Aqcats\*(Aq }
.Ve
.PP
Arguments can also be passed to the start rule, simply by appending them
to the argument list with which the start rule is called (\fIafter\fR the
\&\*(L"line number\*(R" parameter). For example, given:
.PP
.Vb 1
\&    $parser = new Parse::RecDescent ( $grammar );
\&
\&    $parser\->data($text, 1, "str", 2, \e@arr);
\&
\&    #         ^^^^^  ^  ^^^^^^^^^^^^^^^
\&    #       |    |     |
\&    # TEXT TO BE PARSED  |     |
\&    # STARTING LINE NUMBER     |
\&    # ELEMENTS OF @arg WHICH IS PASSED TO RULE data
.Ve
.PP
then within the productions of the rule \f(CW\*(C`data\*(C'\fR, the array \f(CW@arg\fR will contain
\&\f(CW\*(C`("str", 2, \e@arr)\*(C'\fR.
.SS "Alternations"
.IX Subsection "Alternations"
Alternations are implicit (unnamed) rules defined as part of a production. An
alternation is defined as a series of '|'\-separated productions inside a
pair of round brackets. For example:
.PP
.Vb 1
\&    character: \*(Aqthe\*(Aq ( good | bad | ugly ) /dude/
.Ve
.PP
Every alternation implicitly defines a new subrule, whose
automatically-generated name indicates its origin:
\&\*(L"_alternation_<I>_of_production_<P>_of_rule<R>\*(R" for the appropriate
values of <I>, <P>, and <R>. A call to this implicit subrule is then
inserted in place of the brackets. Hence the above example is merely a
convenient short-hand for:
.PP
.Vb 3
\&    character: \*(Aqthe\*(Aq
\&       _alternation_1_of_production_1_of_rule_character
\&       /dude/
\&
\&    _alternation_1_of_production_1_of_rule_character:
\&       good | bad | ugly
.Ve
.PP
Since alternations are parsed by recursively calling the parser generator,
any type(s) of item can appear in an alternation. For example:
.PP
.Vb 5
\&    character: \*(Aqthe\*(Aq ( \*(Aqhigh\*(Aq "plains"  # Silent, with poncho
\&         | /no[\- ]name/ # Silent, no poncho
\&         | vengeance_seeking    # Poncho\-optional
\&         | <error>
\&         ) drifter
.Ve
.PP
In this case, if an error occurred, the automatically generated
message would be:
.PP
.Vb 3
\&    ERROR (line <N>): Invalid implicit subrule: Expected
\&          \*(Aqhigh\*(Aq or /no[\- ]name/ or generic,
\&          but found "pacifist" instead
.Ve
.PP
Since every alternation actually has a name, it's even possible
to extend or replace them:
.PP
.Vb 4
\&    parser\->Replace(
\&    "_alternation_1_of_production_1_of_rule_character:
\&        \*(Aqgeneric Eastwood\*(Aq"
\&        );
.Ve
.PP
More importantly, since alternations are a form of subrule, they can be given
repetition specifiers:
.PP
.Vb 1
\&    character: \*(Aqthe\*(Aq ( good | bad | ugly )(?) /dude/
.Ve
.SS "Incremental Parsing"
.IX Subsection "Incremental Parsing"
\&\f(CW\*(C`Parse::RecDescent\*(C'\fR provides two methods \- \f(CW\*(C`Extend\*(C'\fR and \f(CW\*(C`Replace\*(C'\fR \- which
can be used to alter the grammar matched by a parser. Both methods
take the same argument as \f(CW\*(C`Parse::RecDescent::new\*(C'\fR, namely a
grammar specification string
.PP
\&\f(CW\*(C`Parse::RecDescent::Extend\*(C'\fR interprets the grammar specification and adds any
productions it finds to the end of the rules for which they are specified. For
example:
.PP
.Vb 2
\&    $add = "name: \*(AqJimmy\-Bob\*(Aq | \*(AqBobby\-Jim\*(Aq\endesc: colour /necks?/";
\&    parser\->Extend($add);
.Ve
.PP
adds two productions to the rule \*(L"name\*(R" (creating it if necessary) and one
production to the rule \*(L"desc\*(R".
.PP
\&\f(CW\*(C`Parse::RecDescent::Replace\*(C'\fR is identical, except that it first resets are
rule specified in the additional grammar, removing any existing productions.
Hence after:
.PP
.Vb 2
\&    $add = "name: \*(AqJimmy\-Bob\*(Aq | \*(AqBobby\-Jim\*(Aq\endesc: colour /necks?/";
\&    parser\->Replace($add);
.Ve
.PP
are are \fIonly\fR valid \*(L"name\*(R"s and the one possible description.
.PP
A more interesting use of the \f(CW\*(C`Extend\*(C'\fR and \f(CW\*(C`Replace\*(C'\fR methods is to call them
inside the action of an executing parser. For example:
.PP
.Vb 3
\&    typedef: \*(Aqtypedef\*(Aq type_name identifier \*(Aq;\*(Aq
\&           { $thisparser\->Extend("type_name: \*(Aq$item[3]\*(Aq") }
\&       | <error>
\&
\&    identifier: ...!type_name /[A\-Za\-z_]w*/
.Ve
.PP
which automatically prevents type names from being typedef'd, or:
.PP
.Vb 6
\&    command: \*(Aqmap\*(Aq key_name \*(Aqto\*(Aq abort_key
\&           { $thisparser\->Replace("abort_key: \*(Aq$item[2]\*(Aq") }
\&       | \*(Aqmap\*(Aq key_name \*(Aqto\*(Aq key_name
\&           { map_key($item[2],$item[4]) }
\&       | abort_key
\&           { exit if confirm("abort?") }
\&
\&    abort_key: \*(Aqq\*(Aq
\&
\&    key_name: ...!abort_key /[A\-Za\-z]/
.Ve
.PP
which allows the user to change the abort key binding, but not to unbind it.
.PP
The careful use of such constructs makes it possible to reconfigure a
a running parser, eliminating the need for semantic feedback by
providing syntactic feedback instead. However, as currently implemented,
\&\f(CW\*(C`Replace()\*(C'\fR and \f(CW\*(C`Extend()\*(C'\fR have to regenerate and re\-\f(CW\*(C`eval\*(C'\fR the
entire parser whenever they are called. This makes them quite slow for
large grammars.
.PP
In such cases, the judicious use of an interpolated regex is likely to
be far more efficient:
.PP
.Vb 3
\&    typedef: \*(Aqtypedef\*(Aq type_name/ identifier \*(Aq;\*(Aq
\&           { $thisparser\->{local}{type_name} .= "|$item[3]" }
\&       | <error>
\&
\&    identifier: ...!type_name /[A\-Za\-z_]w*/
\&
\&    type_name: /$thisparser\->{local}{type_name}/
.Ve
.SS "Precompiling parsers"
.IX Subsection "Precompiling parsers"
Normally Parse::RecDescent builds a parser from a grammar at run-time.
That approach simplifies the design and implementation of parsing code,
but has the disadvantage that it slows the parsing process down \- you
have to wait for Parse::RecDescent to build the parser every time the
program runs. Long or complex grammars can be particularly slow to
build, leading to unacceptable delays at start-up.
.PP
To overcome this, the module provides a way of \*(L"pre-building\*(R" a parser
object and saving it in a separate module. That module can then be used
to create clones of the original parser.
.PP
A grammar may be precompiled using the \f(CW\*(C`Precompile\*(C'\fR class method.
For example, to precompile a grammar stored in the scalar \f(CW$grammar\fR,
and produce a class named PreGrammar in a module file named PreGrammar.pm,
you could use:
.PP
.Vb 1
\&    use Parse::RecDescent;
\&
\&    Parse::RecDescent\->Precompile([$options_hashref], $grammar, "PreGrammar");
.Ve
.PP
The first required argument is the grammar string, the second is the
name of the class to be built. The name of the module file is
generated automatically by appending \*(L".pm\*(R" to the last element of the
class name. Thus
.PP
.Vb 1
\&    Parse::RecDescent\->Precompile($grammar, "My::New::Parser");
.Ve
.PP
would produce a module file named Parser.pm.
.PP
An optional hash reference may be supplied as the first argument to
\&\f(CW\*(C`Precompile\*(C'\fR.  This argument is currently \s-1EXPERIMENTAL\s0, and may change
in a future release of Parse::RecDescent.  The only supported option
is currently \f(CW\*(C`\-standalone\*(C'\fR, see \*(L"Standalone Precompiled Parsers\*(R".
.PP
It is somewhat tedious to have to write a small Perl program just to
generate a precompiled grammar class, so Parse::RecDescent has some special
magic that allows you to do the job directly from the command-line.
.PP
If your grammar is specified in a file named \fIgrammar\fR, you can generate
a class named Yet::Another::Grammar like so:
.PP
.Vb 1
\&    > perl \-MParse::RecDescent \- grammar Yet::Another::Grammar
.Ve
.PP
This would produce a file named \fIGrammar.pm\fR containing the full
definition of a class called Yet::Another::Grammar. Of course, to use
that class, you would need to put the \fIGrammar.pm\fR file in a
directory named \fIYet/Another\fR, somewhere in your Perl include path.
.PP
Having created the new class, it's very easy to use it to build
a parser. You simply \f(CW\*(C`use\*(C'\fR the new module, and then call its
\&\f(CW\*(C`new\*(C'\fR method to create a parser object. For example:
.PP
.Vb 2
\&    use Yet::Another::Grammar;
\&    my $parser = Yet::Another::Grammar\->new();
.Ve
.PP
The effect of these two lines is exactly the same as:
.PP
.Vb 1
\&    use Parse::RecDescent;
\&
\&    open GRAMMAR_FILE, "grammar" or die;
\&    local $/;
\&    my $grammar = <GRAMMAR_FILE>;
\&
\&    my $parser = Parse::RecDescent\->new($grammar);
.Ve
.PP
only considerably faster.
.PP
Note however that the parsers produced by either approach are exactly
the same, so whilst precompilation has an effect on \fIset-up\fR speed,
it has no effect on \fIparsing\fR speed. RecDescent 2.0 will address that
problem.
.PP
\fIStandalone Precompiled Parsers\fR
.IX Subsection "Standalone Precompiled Parsers"
.PP
Until version 1.967003 of Parse::RecDescent, parser modules built with
\&\f(CW\*(C`Precompile\*(C'\fR were dependent on Parse::RecDescent.  Future
Parse::RecDescent releases with different internal implementations
would break pre-existing precompiled parsers.
.PP
Version 1.967_005 added the ability for Parse::RecDescent to include
itself in the resulting .pm file if you pass the boolean option
\&\f(CW\*(C`\-standalone\*(C'\fR to \f(CW\*(C`Precompile\*(C'\fR:
.PP
.Vb 2
\&    Parse::RecDescent\->Precompile({ \-standalone = 1, },
\&        $grammar, "My::New::Parser");
.Ve
.PP
Parse::RecDescent is included as Parse::RecDescent::_Runtime in order
to avoid conflicts between an installed version of Parse::RecDescent
and a precompiled, standalone parser made with another version of
Parse::RecDescent.  This renaming is experimental, and is subject to
change in future versions.
.PP
Precompiled parsers remain dependent on Parse::RecDescent by default,
as this feature is still considered experimental.  In the future,
standalone parsers will become the default.
.SH "GOTCHAS"
.IX Header "GOTCHAS"
This section describes common mistakes that grammar writers seem to
make on a regular basis.
.SS "1. Expecting an error to always invalidate a parse"
.IX Subsection "1. Expecting an error to always invalidate a parse"
A common mistake when using error messages is to write the grammar like this:
.PP
.Vb 1
\&    file: line(s)
\&
\&    line: line_type_1
\&    | line_type_2
\&    | line_type_3
\&    | <error>
.Ve
.PP
The expectation seems to be that any line that is not of type 1, 2 or 3 will
invoke the \f(CW\*(C`<error>\*(C'\fR directive and thereby cause the parse to fail.
.PP
Unfortunately, that only happens if the error occurs in the very first line.
The first rule states that a \f(CW\*(C`file\*(C'\fR is matched by one or more lines, so if
even a single line succeeds, the first rule is completely satisfied and the
parse as a whole succeeds. That means that any error messages generated by
subsequent failures in the \f(CW\*(C`line\*(C'\fR rule are quietly ignored.
.PP
Typically what's really needed is this:
.PP
.Vb 1
\&    file: line(s) eofile    { $return = $item[1] }
\&
\&    line: line_type_1
\&    | line_type_2
\&    | line_type_3
\&    | <error>
\&
\&    eofile: /^\eZ/
.Ve
.PP
The addition of the \f(CW\*(C`eofile\*(C'\fR subrule  to the first production means that
a file only matches a series of successful \f(CW\*(C`line\*(C'\fR matches \fIthat consume the
complete input text\fR. If any input text remains after the lines are matched,
there must have been an error in the last \f(CW\*(C`line\*(C'\fR. In that case the \f(CW\*(C`eofile\*(C'\fR
rule will fail, causing the entire \f(CW\*(C`file\*(C'\fR rule to fail too.
.PP
Note too that \f(CW\*(C`eofile\*(C'\fR must match \f(CW\*(C`/^\eZ/\*(C'\fR (end-of-text), \fInot\fR
\&\f(CW\*(C`/^\ecZ/\*(C'\fR or \f(CW\*(C`/^\ecD/\*(C'\fR (end-of-file).
.PP
And don't forget the action at the end of the production. If you just
write:
.PP
.Vb 1
\&    file: line(s) eofile
.Ve
.PP
then the value returned by the \f(CW\*(C`file\*(C'\fR rule will be the value of its
last item: \f(CW\*(C`eofile\*(C'\fR. Since \f(CW\*(C`eofile\*(C'\fR always returns an empty string
on success, that will cause the \f(CW\*(C`file\*(C'\fR rule to return that empty
string. Apart from returning the wrong value, returning an empty string
will trip up code such as:
.PP
.Vb 1
\&    $parser\->file($filetext) || die;
.Ve
.PP
(since "" is false).
.PP
Remember that Parse::RecDescent returns undef on failure,
so the only safe test for failure is:
.PP
.Vb 1
\&    defined($parser\->file($filetext)) || die;
.Ve
.ie n .SS "2. Using a ""return"" in an action"
.el .SS "2. Using a \f(CWreturn\fP in an action"
.IX Subsection "2. Using a return in an action"
An action is like a \f(CW\*(C`do\*(C'\fR block inside the subroutine implementing the
surrounding rule. So if you put a \f(CW\*(C`return\*(C'\fR statement in an action:
.PP
.Vb 3
\&    range: \*(Aq(\*(Aq start \*(Aq..\*(Aq end )\*(Aq
\&        { return $item{end} }
\&       /\es+/
.Ve
.PP
that subroutine will immediately return, without checking the rest of
the items in the current production (e.g. the \f(CW\*(C`/\es+/\*(C'\fR) and without
setting up the necessary data structures to tell the parser that the
rule has succeeded.
.PP
The correct way to set a return value in an action is to set the \f(CW$return\fR
variable:
.PP
.Vb 3
\&    range: \*(Aq(\*(Aq start \*(Aq..\*(Aq end )\*(Aq
\&                { $return = $item{end} }
\&           /\es+/
.Ve
.ie n .SS "2. Setting $Parse::RecDescent::skip at parse time"
.el .SS "2. Setting \f(CW$Parse::RecDescent::skip\fP at parse time"
.IX Subsection "2. Setting $Parse::RecDescent::skip at parse time"
If you want to change the default skipping behaviour (see
\&\*(L"Terminal Separators\*(R" and the \f(CW\*(C`<skip:...>\*(C'\fR directive) by setting
\&\f(CW$Parse::RecDescent::skip\fR you have to remember to set this variable
\&\fIbefore\fR creating the grammar object.
.PP
For example, you might want to skip all Perl-like comments with this
regular expression:
.PP
.Vb 6
\&   my $skip_spaces_and_comments = qr/
\&         (?mxs:
\&            \es+         # either spaces
\&            | \e# .*?$   # or a dash and whatever up to the end of line
\&         )*             # repeated at will (in whatever order)
\&      /;
.Ve
.PP
And then:
.PP
.Vb 1
\&   my $parser1 = Parse::RecDescent\->new($grammar);
\&
\&   $Parse::RecDescent::skip = $skip_spaces_and_comments;
\&
\&   my $parser2 = Parse::RecDescent\->new($grammar);
\&
\&   $parser1\->parse($text); # this does not cope with comments
\&   $parser2\->parse($text); # this skips comments correctly
.Ve
.PP
The two parsers behave differently, because any skipping behaviour
specified via \f(CW$Parse::RecDescent::skip\fR is hard-coded when the
grammar object is built, not at parse time.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
Diagnostics are intended to be self-explanatory (particularly if you
use \fB\-RD_HINT\fR (under \fBperl \-s\fR) or define \f(CW$::RD_HINT\fR inside the program).
.PP
\&\f(CW\*(C`Parse::RecDescent\*(C'\fR currently diagnoses the following:
.IP "\(bu" 4
Invalid regular expressions used as pattern terminals (fatal error).
.IP "\(bu" 4
Invalid Perl code in code blocks (fatal error).
.IP "\(bu" 4
Lookahead used in the wrong place or in a nonsensical way (fatal error).
.IP "\(bu" 4
\&\*(L"Obvious\*(R" cases of left-recursion (fatal error).
.IP "\(bu" 4
Missing or extra components in a \f(CW\*(C`<leftop>\*(C'\fR or \f(CW\*(C`<rightop>\*(C'\fR
directive.
.IP "\(bu" 4
Unrecognisable components in the grammar specification (fatal error).
.IP "\(bu" 4
\&\*(L"Orphaned\*(R" rule components specified before the first rule (fatal error)
or after an \f(CW\*(C`<error>\*(C'\fR directive (level 3 warning).
.IP "\(bu" 4
Missing rule definitions (this only generates a level 3 warning, since you
may be providing them later via \f(CW\*(C`Parse::RecDescent::Extend()\*(C'\fR).
.IP "\(bu" 4
Instances where greedy repetition behaviour will almost certainly
cause the failure of a production (a level 3 warning \- see
\&\*(L"ON-GOING \s-1ISSUES\s0 \s-1AND\s0 \s-1FUTURE\s0 \s-1DIRECTIONS\s0\*(R" below).
.IP "\(bu" 4
Attempts to define rules named 'Replace' or 'Extend', which cannot be
called directly through the parser object because of the predefined
meaning of \f(CW\*(C`Parse::RecDescent::Replace\*(C'\fR and
\&\f(CW\*(C`Parse::RecDescent::Extend\*(C'\fR. (Only a level 2 warning is generated, since
such rules \fIcan\fR still be used as subrules).
.IP "\(bu" 4
Productions which consist of a single \f(CW\*(C`<error?>\*(C'\fR
directive, and which therefore may succeed unexpectedly
(a level 2 warning, since this might conceivably be the desired effect).
.IP "\(bu" 4
Multiple consecutive lookahead specifiers (a level 1 warning only, since their
effects simply accumulate).
.IP "\(bu" 4
Productions which start with a \f(CW\*(C`<reject>\*(C'\fR or \f(CW\*(C`<rulevar:...>\*(C'\fR
directive. Such productions are optimized away (a level 1 warning).
.IP "\(bu" 4
Rules which are autogenerated under \f(CW$::AUTOSTUB\fR (a level 1 warning).
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
Jeremy T. Braun (JTBRAUN@CPAN.org) [current maintainer]
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
There are undoubtedly serious bugs lurking somewhere in this much code :\-)
Bug reports, test cases and other feedback are most welcome.
.PP
Ongoing annoyances include:
.IP "\(bu" 4
There's no support for parsing directly from an input stream.
If and when the Perl Gods give us regular expressions on streams,
this should be trivial (ahem!) to implement.
.IP "\(bu" 4
The parser generator can get confused if actions aren't properly
closed or if they contain particularly nasty Perl syntax errors
(especially unmatched curly brackets).
.IP "\(bu" 4
The generator only detects the most obvious form of left recursion
(potential recursion on the first subrule in a rule). More subtle
forms of left recursion (for example, through the second item in a
rule after a \*(L"zero\*(R" match of a preceding \*(L"zero-or-more\*(R" repetition,
or after a match of a subrule with an empty production) are not found.
.IP "\(bu" 4
Instead of complaining about left-recursion, the generator should
silently transform the grammar to remove it. Don't expect this
feature any time soon as it would require a more sophisticated
approach to parser generation than is currently used.
.IP "\(bu" 4
The generated parsers don't always run as fast as might be wished.
.IP "\(bu" 4
The meta-parser should be bootstrapped using \f(CW\*(C`Parse::RecDescent\*(C'\fR :\-)
.SH "ON-GOING ISSUES AND FUTURE DIRECTIONS"
.IX Header "ON-GOING ISSUES AND FUTURE DIRECTIONS"
.IP "1." 4
Repetitions are \*(L"incorrigibly greedy\*(R" in that they will eat everything they can
and won't backtrack if that behaviour causes a production to fail needlessly.
So, for example:
.Sp
.Vb 1
\&    rule: subrule(s) subrule
.Ve
.Sp
will \fInever\fR succeed, because the repetition will eat all the
subrules it finds, leaving none to match the second item. Such
constructions are relatively rare (and \f(CW\*(C`Parse::RecDescent::new\*(C'\fR generates a
warning whenever they occur) so this may not be a problem, especially
since the insatiable behaviour can be overcome \*(L"manually\*(R" by writing:
.Sp
.Vb 1
\&    rule: penultimate_subrule(s) subrule
\&
\&    penultimate_subrule: subrule ...subrule
.Ve
.Sp
The issue is that this construction is exactly twice as expensive as the
original, whereas backtracking would add only 1/\fIN\fR to the cost (for
matching \fIN\fR repetitions of \f(CW\*(C`subrule\*(C'\fR). I would welcome feedback on
the need for backtracking; particularly on cases where the lack of it
makes parsing performance problematical.
.IP "2." 4
Having opened that can of worms, it's also necessary to consider whether there
is a need for non-greedy repetition specifiers. Again, it's possible (at some
cost) to manually provide the required functionality:
.Sp
.Vb 1
\&    rule: nongreedy_subrule(s) othersubrule
\&
\&    nongreedy_subrule: subrule ...!othersubrule
.Ve
.Sp
Overall, the issue is whether the benefit of this extra functionality
outweighs the drawbacks of further complicating the (currently
minimalist) grammar specification syntax, and (worse) introducing more overhead
into the generated parsers.
.IP "3." 4
An \f(CW\*(C`<autocommit>\*(C'\fR directive would be nice. That is, it would be useful to be
able to say:
.Sp
.Vb 7
\&    command: <autocommit>
\&    command: \*(Aqfind\*(Aq name
\&       | \*(Aqfind\*(Aq address
\&       | \*(Aqdo\*(Aq command \*(Aqat\*(Aq time \*(Aqif\*(Aq condition
\&       | \*(Aqdo\*(Aq command \*(Aqat\*(Aq time
\&       | \*(Aqdo\*(Aq command
\&       | unusual_command
.Ve
.Sp
and have the generator work out that this should be \*(L"pruned\*(R" thus:
.Sp
.Vb 9
\&    command: \*(Aqfind\*(Aq name
\&       | \*(Aqfind\*(Aq <commit> address
\&       | \*(Aqdo\*(Aq <commit> command <uncommit>
\&        \*(Aqat\*(Aq time
\&        \*(Aqif\*(Aq <commit> condition
\&       | \*(Aqdo\*(Aq <commit> command <uncommit>
\&        \*(Aqat\*(Aq <commit> time
\&       | \*(Aqdo\*(Aq <commit> command
\&       | unusual_command
.Ve
.Sp
There are several issues here. Firstly, should the
\&\f(CW\*(C`<autocommit>\*(C'\fR automatically install an \f(CW\*(C`<uncommit>\*(C'\fR
at the start of the last production (on the grounds that the \*(L"command\*(R"
rule doesn't know whether an \*(L"unusual_command\*(R" might start with \*(L"find\*(R"
or \*(L"do\*(R") or should the \*(L"unusual_command\*(R" subgraph be analysed (to see
if it \fImight\fR be viable after a \*(L"find\*(R" or \*(L"do\*(R")?
.Sp
The second issue is how regular expressions should be treated. The simplest
approach would be simply to uncommit before them (on the grounds that they
\&\fImight\fR match). Better efficiency would be obtained by analyzing all preceding
literal tokens to determine whether the pattern would match them.
.Sp
Overall, the issues are: can such automated \*(L"pruning\*(R" approach a hand-tuned
version sufficiently closely to warrant the extra set-up expense, and (more
importantly) is the problem important enough to even warrant the non-trivial
effort of building an automated solution?
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Source Code Repository"
.IX Subsection "Source Code Repository"
http://github.com/jtbraun/Parse\-RecDescent <http://github.com/jtbraun/Parse-RecDescent>
.SS "Mailing List"
.IX Subsection "Mailing List"
Visit <http://www.perlfoundation.org/perl5/index.cgi?parse_recdescent> to sign up for the mailing list.
.PP
<http://www.PerlMonks.org> is also a good place to ask
questions. Previous posts about Parse::RecDescent can typically be
found with this search:
<http://perlmonks.org/index.pl?node=recdescent>.
.SS "\s-1FAQ\s0"
.IX Subsection "FAQ"
Visit Parse::RecDescent::FAQ for answers to frequently (and not so
frequently) asked questions about Parse::RecDescent.
.SS "View/Report Bugs"
.IX Subsection "View/Report Bugs"
To view the current bug list or report a new issue visit
https://rt.cpan.org/Public/Dist/Display.html?Name=Parse\-RecDescent <https://rt.cpan.org/Public/Dist/Display.html?Name=Parse-RecDescent>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Grammars provides Parse::RecDescent style parsing using native
Perl 5.10 regular expressions.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 1997\-2007, Damian Conway \f(CW\*(C`<DCONWAY@CPAN.org>\*(C'\fR. All rights
reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
\&\s-1BECAUSE\s0 \s-1THIS\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1LICENSED\s0 \s-1FREE\s0 \s-1OF\s0 \s-1CHARGE\s0, \s-1THERE\s0 \s-1IS\s0 \s-1NO\s0 \s-1WARRANTY\s0
\&\s-1FOR\s0 \s-1THE\s0 \s-1SOFTWARE\s0, \s-1TO\s0 \s-1THE\s0 \s-1EXTENT\s0 \s-1PERMITTED\s0 \s-1BY\s0 \s-1APPLICABLE\s0 \s-1LAW\s0. \s-1EXCEPT\s0 \s-1WHEN\s0
\&\s-1OTHERWISE\s0 \s-1STATED\s0 \s-1IN\s0 \s-1WRITING\s0 \s-1THE\s0 \s-1COPYRIGHT\s0 \s-1HOLDERS\s0 \s-1AND/OR\s0 \s-1OTHER\s0 \s-1PARTIES\s0
\&\s-1PROVIDE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \*(L"\s-1AS\s0 \s-1IS\s0\*(R" \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0, \s-1EITHER\s0
\&\s-1EXPRESSED\s0 \s-1OR\s0 \s-1IMPLIED\s0, \s-1INCLUDING\s0, \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0, \s-1THE\s0 \s-1IMPLIED\s0
\&\s-1WARRANTIES\s0 \s-1OF\s0 \s-1MERCHANTABILITY\s0 \s-1AND\s0 \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0. \s-1THE\s0
\&\s-1ENTIRE\s0 \s-1RISK\s0 \s-1AS\s0 \s-1TO\s0 \s-1THE\s0 \s-1QUALITY\s0 \s-1AND\s0 \s-1PERFORMANCE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1IS\s0 \s-1WITH\s0
\&\s-1YOU\s0. \s-1SHOULD\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1PROVE\s0 \s-1DEFECTIVE\s0, \s-1YOU\s0 \s-1ASSUME\s0 \s-1THE\s0 \s-1COST\s0 \s-1OF\s0 \s-1ALL\s0
\&\s-1NECESSARY\s0 \s-1SERVICING\s0, \s-1REPAIR\s0, \s-1OR\s0 \s-1CORRECTION\s0.
.PP
\&\s-1IN\s0 \s-1NO\s0 \s-1EVENT\s0 \s-1UNLESS\s0 \s-1REQUIRED\s0 \s-1BY\s0 \s-1APPLICABLE\s0 \s-1LAW\s0 \s-1OR\s0 \s-1AGREED\s0 \s-1TO\s0 \s-1IN\s0 \s-1WRITING\s0
\&\s-1WILL\s0 \s-1ANY\s0 \s-1COPYRIGHT\s0 \s-1HOLDER\s0, \s-1OR\s0 \s-1ANY\s0 \s-1OTHER\s0 \s-1PARTY\s0 \s-1WHO\s0 \s-1MAY\s0 \s-1MODIFY\s0 \s-1AND/OR\s0
\&\s-1REDISTRIBUTE\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1AS\s0 \s-1PERMITTED\s0 \s-1BY\s0 \s-1THE\s0 \s-1ABOVE\s0 \s-1LICENCE\s0, \s-1BE\s0
\&\s-1LIABLE\s0 \s-1TO\s0 \s-1YOU\s0 \s-1FOR\s0 \s-1DAMAGES\s0, \s-1INCLUDING\s0 \s-1ANY\s0 \s-1GENERAL\s0, \s-1SPECIAL\s0, \s-1INCIDENTAL\s0,
\&\s-1OR\s0 \s-1CONSEQUENTIAL\s0 \s-1DAMAGES\s0 \s-1ARISING\s0 \s-1OUT\s0 \s-1OF\s0 \s-1THE\s0 \s-1USE\s0 \s-1OR\s0 \s-1INABILITY\s0 \s-1TO\s0 \s-1USE\s0
\&\s-1THE\s0 \s-1SOFTWARE\s0 (\s-1INCLUDING\s0 \s-1BUT\s0 \s-1NOT\s0 \s-1LIMITED\s0 \s-1TO\s0 \s-1LOSS\s0 \s-1OF\s0 \s-1DATA\s0 \s-1OR\s0 \s-1DATA\s0 \s-1BEING\s0
\&\s-1RENDERED\s0 \s-1INACCURATE\s0 \s-1OR\s0 \s-1LOSSES\s0 \s-1SUSTAINED\s0 \s-1BY\s0 \s-1YOU\s0 \s-1OR\s0 \s-1THIRD\s0 \s-1PARTIES\s0 \s-1OR\s0 A
\&\s-1FAILURE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SOFTWARE\s0 \s-1TO\s0 \s-1OPERATE\s0 \s-1WITH\s0 \s-1ANY\s0 \s-1OTHER\s0 \s-1SOFTWARE\s0), \s-1EVEN\s0 \s-1IF\s0
\&\s-1SUCH\s0 \s-1HOLDER\s0 \s-1OR\s0 \s-1OTHER\s0 \s-1PARTY\s0 \s-1HAS\s0 \s-1BEEN\s0 \s-1ADVISED\s0 \s-1OF\s0 \s-1THE\s0 \s-1POSSIBILITY\s0 \s-1OF\s0
\&\s-1SUCH\s0 \s-1DAMAGES\s0.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Parse::RecDescent5.18.3pm                    0100644 0001750 0001750 00000371331 12566242207 025021  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parse::RecDescent 3"
.TH Parse::RecDescent 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Parse::RecDescent \- Generate Recursive\-Descent Parsers
.SH "VERSION"
.IX Header "VERSION"
This document describes version 1.967009 of Parse::RecDescent
released March 16th, 2012.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Parse::RecDescent;
\&
\& # Generate a parser from the specification in $grammar:
\&
\&     $parser = new Parse::RecDescent ($grammar);
\&
\& # Generate a parser from the specification in $othergrammar
\&
\&     $anotherparser = new Parse::RecDescent ($othergrammar);
\&
\&
\& # Parse $text using rule \*(Aqstartrule\*(Aq (which must be
\& # defined in $grammar):
\&
\&    $parser\->startrule($text);
\&
\&
\& # Parse $text using rule \*(Aqotherrule\*(Aq (which must also
\& # be defined in $grammar):
\&
\&     $parser\->otherrule($text);
\&
\&
\& # Change the universal token prefix pattern
\& # before building a grammar
\& # (the default is: \*(Aq\es*\*(Aq):
\&
\&    $Parse::RecDescent::skip = \*(Aq[ \et]+\*(Aq;
\&
\&
\& # Replace productions of existing rules (or create new ones)
\& # with the productions defined in $newgrammar:
\&
\&    $parser\->Replace($newgrammar);
\&
\&
\& # Extend existing rules (or create new ones)
\& # by adding extra productions defined in $moregrammar:
\&
\&    $parser\->Extend($moregrammar);
\&
\&
\& # Global flags (useful as command line arguments under \-s):
\&
\&    $::RD_ERRORS       # unless undefined, report fatal errors
\&    $::RD_WARN         # unless undefined, also report non\-fatal problems
\&    $::RD_HINT         # if defined, also suggestion remedies
\&    $::RD_TRACE        # if defined, also trace parsers\*(Aq behaviour
\&    $::RD_AUTOSTUB     # if defined, generates "stubs" for undefined rules
\&    $::RD_AUTOACTION   # if defined, appends specified action to productions
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Overview"
.IX Subsection "Overview"
Parse::RecDescent incrementally generates top-down recursive-descent text
parsers from simple \fIyacc\fR\-like grammar specifications. It provides:
.IP "\(bu" 4
Regular expressions or literal strings as terminals (tokens),
.IP "\(bu" 4
Multiple (non-contiguous) productions for any rule,
.IP "\(bu" 4
Repeated and optional subrules within productions,
.IP "\(bu" 4
Full access to Perl within actions specified as part of the grammar,
.IP "\(bu" 4
Simple automated error reporting during parser generation and parsing,
.IP "\(bu" 4
The ability to commit to, uncommit to, or reject particular
productions during a parse,
.IP "\(bu" 4
The ability to pass data up and down the parse tree (\*(L"down\*(R" via subrule
argument lists, \*(L"up\*(R" via subrule return values)
.IP "\(bu" 4
Incremental extension of the parsing grammar (even during a parse),
.IP "\(bu" 4
Precompilation of parser objects,
.IP "\(bu" 4
User-definable reduce-reduce conflict resolution via
\&\*(L"scoring\*(R" of matching productions.
.ie n .SS "Using ""Parse::RecDescent"""
.el .SS "Using \f(CWParse::RecDescent\fP"
.IX Subsection "Using Parse::RecDescent"
Parser objects are created by calling \f(CW\*(C`Parse::RecDescent::new\*(C'\fR, passing in a
grammar specification (see the following subsections). If the grammar is
correct, \f(CW\*(C`new\*(C'\fR returns a blessed reference which can then be used to initiate
parsing through any rule specified in the original grammar. A typical sequence
looks like this:
.PP
.Vb 3
\&    $grammar = q {
\&        # GRAMMAR SPECIFICATION HERE
\&         };
\&
\&    $parser = new Parse::RecDescent ($grammar) or die "Bad grammar!\en";
\&
\&    # acquire $text
\&
\&    defined $parser\->startrule($text) or print "Bad text!\en";
.Ve
.PP
The rule through which parsing is initiated must be explicitly defined
in the grammar (i.e. for the above example, the grammar must include a
rule of the form: \*(L"startrule: <subrules>\*(R".
.PP
If the starting rule succeeds, its value (see below)
is returned. Failure to generate the original parser or failure to match a text
is indicated by returning \f(CW\*(C`undef\*(C'\fR. Note that it's easy to set up grammars
that can succeed, but which return a value of 0, \*(L"0\*(R", or "".  So don't be
tempted to write:
.PP
.Vb 1
\&    $parser\->startrule($text) or print "Bad text!\en";
.Ve
.PP
Normally, the parser has no effect on the original text. So in the
previous example the value of \f(CW$text\fR would be unchanged after having
been parsed.
.PP
If, however, the text to be matched is passed by reference:
.PP
.Vb 1
\&    $parser\->startrule(\e$text)
.Ve
.PP
then any text which was consumed during the match will be removed from the
start of \f(CW$text\fR.
.SS "Rules"
.IX Subsection "Rules"
In the grammar from which the parser is built, rules are specified by
giving an identifier (which must satisfy /[A\-Za\-z]\ew*/), followed by a
colon \fIon the same line\fR, followed by one or more productions,
separated by single vertical bars. The layout of the productions
is entirely free-format:
.PP
.Vb 3
\&    rule1:  production1
\&     |  production2 |
\&    production3 | production4
.Ve
.PP
At any point in the grammar previously defined rules may be extended with
additional productions. This is achieved by redeclaring the rule with the new
productions. Thus:
.PP
.Vb 3
\&    rule1: a | b | c
\&    rule2: d | e | f
\&    rule1: g | h
.Ve
.PP
is exactly equivalent to:
.PP
.Vb 2
\&    rule1: a | b | c | g | h
\&    rule2: d | e | f
.Ve
.PP
Each production in a rule consists of zero or more items, each of which
may be either: the name of another rule to be matched (a \*(L"subrule\*(R"),
a pattern or string literal to be matched directly (a \*(L"token\*(R"), a
block of Perl code to be executed (an \*(L"action\*(R"), a special instruction
to the parser (a \*(L"directive\*(R"), or a standard Perl comment (which is
ignored).
.PP
A rule matches a text if one of its productions matches. A production
matches if each of its items match consecutive substrings of the
text. The productions of a rule being matched are tried in the same
order that they appear in the original grammar, and the first matching
production terminates the match attempt (successfully). If all
productions are tried and none matches, the match attempt fails.
.PP
Note that this behaviour is quite different from the \*(L"prefer the longer match\*(R"
behaviour of \fIyacc\fR. For example, if \fIyacc\fR were parsing the rule:
.PP
.Vb 2
\&    seq : \*(AqA\*(Aq \*(AqB\*(Aq
\&    | \*(AqA\*(Aq \*(AqB\*(Aq \*(AqC\*(Aq
.Ve
.PP
upon matching \*(L"\s-1AB\*(R"\s0 it would look ahead to see if a 'C' is next and, if
so, will match the second production in preference to the first. In
other words, \fIyacc\fR effectively tries all the productions of a rule
breadth-first in parallel, and selects the \*(L"best\*(R" match, where \*(L"best\*(R"
means longest (note that this is a gross simplification of the true
behaviour of \fIyacc\fR but it will do for our purposes).
.PP
In contrast, \f(CW\*(C`Parse::RecDescent\*(C'\fR tries each production depth-first in
sequence, and selects the \*(L"best\*(R" match, where \*(L"best\*(R" means first. This is
the fundamental difference between \*(L"bottom-up\*(R" and \*(L"recursive descent\*(R"
parsing.
.PP
Each successfully matched item in a production is assigned a value,
which can be accessed in subsequent actions within the same
production (or, in some cases, as the return value of a successful
subrule call). Unsuccessful items don't have an associated value,
since the failure of an item causes the entire surrounding production
to immediately fail. The following sections describe the various types
of items and their success values.
.SS "Subrules"
.IX Subsection "Subrules"
A subrule which appears in a production is an instruction to the parser to
attempt to match the named rule at that point in the text being
parsed. If the named subrule is not defined when requested the
production containing it immediately fails (unless it was \*(L"autostubbed\*(R" \- see
Autostubbing).
.PP
A rule may (recursively) call itself as a subrule, but \fInot\fR as the
left-most item in any of its productions (since such recursions are usually
non-terminating).
.PP
The value associated with a subrule is the value associated with its
\&\f(CW$return\fR variable (see \*(L"Actions\*(R" below), or with the last successfully
matched item in the subrule match.
.PP
Subrules may also be specified with a trailing repetition specifier,
indicating that they are to be (greedily) matched the specified number
of times. The available specifiers are:
.PP
.Vb 7
\&    subrule(?)  # Match one\-or\-zero times
\&    subrule(s)  # Match one\-or\-more times
\&    subrule(s?) # Match zero\-or\-more times
\&    subrule(N)  # Match exactly N times for integer N > 0
\&    subrule(N..M)   # Match between N and M times
\&    subrule(..M)    # Match between 1 and M times
\&    subrule(N..)    # Match at least N times
.Ve
.PP
Repeated subrules keep matching until either the subrule fails to
match, or it has matched the minimal number of times but fails to
consume any of the parsed text (this second condition prevents the
subrule matching forever in some cases).
.PP
Since a repeated subrule may match many instances of the subrule itself, the
value associated with it is not a simple scalar, but rather a reference to a
list of scalars, each of which is the value associated with one of the
individual subrule matches. In other words in the rule:
.PP
.Vb 1
\&    program: statement(s)
.Ve
.PP
the value associated with the repeated subrule \*(L"statement(s)\*(R" is a reference
to an array containing the values matched by each call to the individual
subrule \*(L"statement\*(R".
.PP
Repetition modifiers may include a separator pattern:
.PP
.Vb 1
\&    program: statement(s /;/)
.Ve
.PP
specifying some sequence of characters to be skipped between each repetition.
This is really just a shorthand for the <leftop:...> directive
(see below).
.SS "Tokens"
.IX Subsection "Tokens"
If a quote-delimited string or a Perl regex appears in a production,
the parser attempts to match that string or pattern at that point in
the text. For example:
.PP
.Vb 1
\&    typedef: "typedef" typename identifier \*(Aq;\*(Aq
\&
\&    identifier: /[A\-Za\-z_][A\-Za\-z0\-9_]*/
.Ve
.PP
As in regular Perl, a single quoted string is uninterpolated, whilst
a double-quoted string or a pattern is interpolated (at the time
of matching, \fInot\fR when the parser is constructed). Hence, it is
possible to define rules in which tokens can be set at run-time:
.PP
.Vb 1
\&    typedef: "$::typedefkeyword" typename identifier \*(Aq;\*(Aq
\&
\&    identifier: /$::identpat/
.Ve
.PP
Note that, since each rule is implemented inside a special namespace
belonging to its parser, it is necessary to explicitly quantify
variables from the main package.
.PP
Regex tokens can be specified using just slashes as delimiters
or with the explicit \f(CW\*(C`m<delimiter>......<delimiter>\*(C'\fR syntax:
.PP
.Vb 1
\&    typedef: "typedef" typename identifier \*(Aq;\*(Aq
\&
\&    typename: /[A\-Za\-z_][A\-Za\-z0\-9_]*/
\&
\&    identifier: m{[A\-Za\-z_][A\-Za\-z0\-9_]*}
.Ve
.PP
A regex of either type can also have any valid trailing parameter(s)
(that is, any of [cgimsox]):
.PP
.Vb 1
\&    typedef: "typedef" typename identifier \*(Aq;\*(Aq
\&
\&    identifier: / [a\-z_]        # LEADING ALPHA OR UNDERSCORE
\&          [a\-z0\-9_]*    # THEN DIGITS ALSO ALLOWED
\&        /ix     # CASE/SPACE/COMMENT INSENSITIVE
.Ve
.PP
The value associated with any successfully matched token is a string
containing the actual text which was matched by the token.
.PP
It is important to remember that, since each grammar is specified in a
Perl string, all instances of the universal escape character '\e' within
a grammar must be \*(L"doubled\*(R", so that they interpolate to single '\e's when
the string is compiled. For example, to use the grammar:
.PP
.Vb 3
\&    word:       /\eS+/ | backslash
\&    line:       prefix word(s) "\en"
\&    backslash:  \*(Aq\e\e\*(Aq
.Ve
.PP
the following code is required:
.PP
.Vb 1
\&    $parser = new Parse::RecDescent (q{
\&
\&        word:   /\e\eS+/ | backslash
\&        line:   prefix word(s) "\e\en"
\&        backslash:  \*(Aq\e\e\e\e\*(Aq
\&
\&    });
.Ve
.SS "Anonymous subrules"
.IX Subsection "Anonymous subrules"
Parentheses introduce a nested scope that is very like a call to an anonymous
subrule. Hence they are useful for \*(L"in-lining\*(R" subroutine calls, and other
kinds of grouping behaviour. For example, instead of:
.PP
.Vb 2
\&    word:       /\eS+/ | backslash
\&    line:       prefix word(s) "\en"
.Ve
.PP
you could write:
.PP
.Vb 1
\&    line:       prefix ( /\eS+/ | backslash )(s) "\en"
.Ve
.PP
and get exactly the same effects.
.PP
Parentheses are also use for collecting unrepeated alternations within a
single production.
.PP
.Vb 1
\&    secret_identity: "Mr" ("Incredible"|"Fantastic"|"Sheen") ", Esq."
.Ve
.SS "Terminal Separators"
.IX Subsection "Terminal Separators"
For the purpose of matching, each terminal in a production is considered
to be preceded by a \*(L"prefix\*(R" \- a pattern which must be
matched before a token match is attempted. By default, the
prefix is optional whitespace (which always matches, at
least trivially), but this default may be reset in any production.
.PP
The variable \f(CW$Parse::RecDescent::skip\fR stores the universal
prefix, which is the default for all terminal matches in all parsers
built with \f(CW\*(C`Parse::RecDescent\*(C'\fR.
.PP
If you want to change the universal prefix using
\&\f(CW$Parse::RecDescent::skip\fR, be careful to set it \fIbefore\fR creating
the grammar object, because it is applied statically (when a grammar
is built) rather than dynamically (when the grammar is used).
Alternatively you can provide a global \f(CW\*(C`<skip:...>\*(C'\fR directive
in your grammar before any rules (described later).
.PP
The prefix for an individual production can be altered
by using the \f(CW\*(C`<skip:...>\*(C'\fR directive (described later).
Setting this directive in the top-level rule is an alternative approach
to setting \f(CW$Parse::RecDescent::skip\fR before creating the object, but
in this case you don't get the intended skipping behaviour if you
directly invoke methods different from the top-level rule.
.SS "Actions"
.IX Subsection "Actions"
An action is a block of Perl code which is to be executed (as the
block of a \f(CW\*(C`do\*(C'\fR statement) when the parser reaches that point in a
production. The action executes within a special namespace belonging to
the active parser, so care must be taken in correctly qualifying variable
names (see also \*(L"Start-up Actions\*(R" below).
.PP
The action is considered to succeed if the final value of the block
is defined (that is, if the implied \f(CW\*(C`do\*(C'\fR statement evaluates to a
defined value \- \fIeven one which would be treated as \*(L"false\*(R"\fR). Note
that the value associated with a successful action is also the final
value in the block.
.PP
An action will \fIfail\fR if its last evaluated value is \f(CW\*(C`undef\*(C'\fR. This is
surprisingly easy to accomplish by accident. For instance, here's an
infuriating case of an action that makes its production fail, but only
when debugging \fIisn't\fR activated:
.PP
.Vb 4
\&    description: name rank serial_number
\&        { print "Got $item[2] $item[1] ($item[3])\en"
\&        if $::debugging
\&        }
.Ve
.PP
If \f(CW$debugging\fR is false, no statement in the block is executed, so
the final value is \f(CW\*(C`undef\*(C'\fR, and the entire production fails. The solution is:
.PP
.Vb 5
\&    description: name rank serial_number
\&        { print "Got $item[2] $item[1] ($item[3])\en"
\&        if $::debugging;
\&          1;
\&        }
.Ve
.PP
Within an action, a number of useful parse-time variables are
available in the special parser namespace (there are other variables
also accessible, but meddling with them will probably just break your
parser. As a general rule, if you avoid referring to unqualified
variables \- especially those starting with an underscore \- inside an action,
things should be okay):
.ie n .IP "@item and %item" 4
.el .IP "\f(CW@item\fR and \f(CW%item\fR" 4
.IX Item "@item and %item"
The array slice \f(CW@item[1..$#item]\fR stores the value associated with each item
(that is, each subrule, token, or action) in the current production. The
analogy is to \f(CW$1\fR, \f(CW$2\fR, etc. in a \fIyacc\fR grammar.
Note that, for obvious reasons, \f(CW@item\fR only contains the
values of items \fIbefore\fR the current point in the production.
.Sp
The first element (\f(CW$item[0]\fR) stores the name of the current rule
being matched.
.Sp
\&\f(CW@item\fR is a standard Perl array, so it can also be indexed with negative
numbers, representing the number of items \fIback\fR from the current position in
the parse:
.Sp
.Vb 3
\&    stuff: /various/ bits \*(Aqand\*(Aq pieces "then" data \*(Aqend\*(Aq
\&        { print $item[\-2] }  # PRINTS data
\&             # (EASIER THAN: $item[6])
.Ve
.Sp
The \f(CW%item\fR hash complements the <@item> array, providing named
access to the same item values:
.Sp
.Vb 3
\&    stuff: /various/ bits \*(Aqand\*(Aq pieces "then" data \*(Aqend\*(Aq
\&        { print $item{data}  # PRINTS data
\&             # (EVEN EASIER THAN USING @item)
.Ve
.Sp
The results of named subrules are stored in the hash under each
subrule's name (including the repetition specifier, if any),
whilst all other items are stored under a \*(L"named
positional\*(R" key that indictates their ordinal position within their item
type: _\|_STRING\fIn\fR_\|_, _\|_PATTERN\fIn\fR_\|_, _\|_DIRECTIVE\fIn\fR_\|_, _\|_ACTION\fIn\fR_\|_:
.Sp
.Vb 6
\&    stuff: /various/ bits \*(Aqand\*(Aq pieces "then" data \*(Aqend\*(Aq { save }
\&        { print $item{_\|_PATTERN1_\|_}, # PRINTS \*(Aqvarious\*(Aq
\&        $item{_\|_STRING2_\|_},  # PRINTS \*(Aqthen\*(Aq
\&        $item{_\|_ACTION1_\|_},  # PRINTS RETURN
\&                 # VALUE OF save
\&        }
.Ve
.Sp
If you want proper \fInamed\fR access to patterns or literals, you need to turn
them into separate rules:
.Sp
.Vb 3
\&    stuff: various bits \*(Aqand\*(Aq pieces "then" data \*(Aqend\*(Aq
\&        { print $item{various}  # PRINTS various
\&        }
\&
\&    various: /various/
.Ve
.Sp
The special entry \f(CW$item{_\|_RULE_\|_}\fR stores the name of the current
rule (i.e. the same value as \f(CW$item[0]\fR.
.Sp
The advantage of using \f(CW%item\fR, instead of \f(CW@items\fR is that it
removes the need to track items positions that may change as a grammar
evolves. For example, adding an interim \f(CW\*(C`<skip>\*(C'\fR directive
of action can silently ruin a trailing action, by moving an \f(CW@item\fR
element \*(L"down\*(R" the array one place. In contrast, the named entry
of \f(CW%item\fR is unaffected by such an insertion.
.Sp
A limitation of the \f(CW%item\fR hash is that it only records the \fIlast\fR
value of a particular subrule. For example:
.Sp
.Vb 2
\&    range: \*(Aq(\*(Aq number \*(Aq..\*(Aq number )\*(Aq
\&        { $return = $item{number} }
.Ve
.Sp
will return only the value corresponding to the \fIsecond\fR match of the
\&\f(CW\*(C`number\*(C'\fR subrule. In other words, successive calls to a subrule
overwrite the corresponding entry in \f(CW%item\fR. Once again, the
solution is to rename each subrule in its own rule:
.Sp
.Vb 2
\&    range: \*(Aq(\*(Aq from_num \*(Aq..\*(Aq to_num \*(Aq)\*(Aq
\&        { $return = $item{from_num} }
\&
\&    from_num: number
\&    to_num:   number
.Ve
.ie n .IP "@arg and %arg" 4
.el .IP "\f(CW@arg\fR and \f(CW%arg\fR" 4
.IX Item "@arg and %arg"
The array \f(CW@arg\fR and the hash \f(CW%arg\fR store any arguments passed to
the rule from some other rule (see \*(L"Subrule argument lists\*(R"). Changes
to the elements of either variable do not propagate back to the calling
rule (data can be passed back from a subrule via the \f(CW$return\fR
variable \- see next item).
.ie n .IP "$return" 4
.el .IP "\f(CW$return\fR" 4
.IX Item "$return"
If a value is assigned to \f(CW$return\fR within an action, that value is
returned if the production containing the action eventually matches
successfully. Note that setting \f(CW$return\fR \fIdoesn't\fR cause the current
production to succeed. It merely tells it what to return if it \fIdoes\fR succeed.
Hence \f(CW$return\fR is analogous to \f(CW$$\fR in a \fIyacc\fR grammar.
.Sp
If \f(CW$return\fR is not assigned within a production, the value of the
last component of the production (namely: \f(CW$item[$#item]\fR) is
returned if the production succeeds.
.ie n .IP "$commit" 4
.el .IP "\f(CW$commit\fR" 4
.IX Item "$commit"
The current state of commitment to the current production (see \*(L"Directives\*(R"
below).
.ie n .IP "$skip" 4
.el .IP "\f(CW$skip\fR" 4
.IX Item "$skip"
The current terminal prefix (see \*(L"Directives\*(R" below).
.ie n .IP "$text" 4
.el .IP "\f(CW$text\fR" 4
.IX Item "$text"
The remaining (unparsed) text. Changes to \f(CW$text\fR \fIdo not
propagate\fR out of unsuccessful productions, but \fIdo\fR survive
successful productions. Hence it is possible to dynamically alter the
text being parsed \- for example, to provide a \f(CW\*(C`#include\*(C'\fR\-like facility:
.Sp
.Vb 2
\&    hash_include: \*(Aq#include\*(Aq filename
\&        { $text = ::loadfile($item[2]) . $text }
\&
\&    filename: \*(Aq<\*(Aq /[a\-z0\-9._\-]+/i \*(Aq>\*(Aq  { $return = $item[2] }
\&    | \*(Aq"\*(Aq /[a\-z0\-9._\-]+/i \*(Aq"\*(Aq  { $return = $item[2] }
.Ve
.ie n .IP "$thisline and $prevline" 4
.el .IP "\f(CW$thisline\fR and \f(CW$prevline\fR" 4
.IX Item "$thisline and $prevline"
\&\f(CW$thisline\fR stores the current line number within the current parse
(starting from 1). \f(CW$prevline\fR stores the line number for the last
character which was already successfully parsed (this will be different from
\&\f(CW$thisline\fR at the end of each line).
.Sp
For efficiency, \f(CW$thisline\fR and \f(CW$prevline\fR are actually tied
hashes, and only recompute the required line number when the variable's
value is used.
.Sp
Assignment to \f(CW$thisline\fR adjusts the line number calculator, so that
it believes that the current line number is the value being assigned. Note
that this adjustment will be reflected in all subsequent line numbers
calculations.
.Sp
Modifying the value of the variable \f(CW$text\fR (as in the previous
\&\f(CW\*(C`hash_include\*(C'\fR example, for instance) will confuse the line
counting mechanism. To prevent this, you should call
\&\f(CW\*(C`Parse::RecDescent::LineCounter::resync($thisline)\*(C'\fR \fIimmediately\fR
after any assignment to the variable \f(CW$text\fR (or, at least, before the
next attempt to use \f(CW$thisline\fR).
.Sp
Note that if a production fails after assigning to or
resync'ing \f(CW$thisline\fR, the parser's line counter mechanism will
usually be corrupted.
.Sp
Also see the entry for \f(CW@itempos\fR.
.Sp
The line number can be set to values other than 1, by calling the start
rule with a second argument. For example:
.Sp
.Vb 1
\&    $parser = new Parse::RecDescent ($grammar);
\&
\&    $parser\->input($text, 10);  # START LINE NUMBERS AT 10
.Ve
.ie n .IP "$thiscolumn and $prevcolumn" 4
.el .IP "\f(CW$thiscolumn\fR and \f(CW$prevcolumn\fR" 4
.IX Item "$thiscolumn and $prevcolumn"
\&\f(CW$thiscolumn\fR stores the current column number within the current line
being parsed (starting from 1). \f(CW$prevcolumn\fR stores the column number
of the last character which was actually successfully parsed. Usually
\&\f(CW\*(C`$prevcolumn == $thiscolumn\-1\*(C'\fR, but not at the end of lines.
.Sp
For efficiency, \f(CW$thiscolumn\fR and \f(CW$prevcolumn\fR are
actually tied hashes, and only recompute the required column number
when the variable's value is used.
.Sp
Assignment to \f(CW$thiscolumn\fR or \f(CW$prevcolumn\fR is a fatal error.
.Sp
Modifying the value of the variable \f(CW$text\fR (as in the previous
\&\f(CW\*(C`hash_include\*(C'\fR example, for instance) may confuse the column
counting mechanism.
.Sp
Note that \f(CW$thiscolumn\fR reports the column number \fIbefore\fR any
whitespace that might be skipped before reading a token. Hence
if you wish to know where a token started (and ended) use something like this:
.Sp
.Vb 2
\&    rule: token1 token2 startcol token3 endcol token4
\&        { print "token3: columns $item[3] to $item[5]"; }
\&
\&    startcol: \*(Aq\*(Aq { $thiscolumn }    # NEED THE \*(Aq\*(Aq TO STEP PAST TOKEN SEP
\&    endcol:  { $prevcolumn }
.Ve
.Sp
Also see the entry for \f(CW@itempos\fR.
.ie n .IP "$thisoffset and $prevoffset" 4
.el .IP "\f(CW$thisoffset\fR and \f(CW$prevoffset\fR" 4
.IX Item "$thisoffset and $prevoffset"
\&\f(CW$thisoffset\fR stores the offset of the current parsing position
within the complete text
being parsed (starting from 0). \f(CW$prevoffset\fR stores the offset
of the last character which was actually successfully parsed. In all
cases \f(CW\*(C`$prevoffset == $thisoffset\-1\*(C'\fR.
.Sp
For efficiency, \f(CW$thisoffset\fR and \f(CW$prevoffset\fR are
actually tied hashes, and only recompute the required offset
when the variable's value is used.
.Sp
Assignment to \f(CW$thisoffset\fR or <$prevoffset> is a fatal error.
.Sp
Modifying the value of the variable \f(CW$text\fR will \fInot\fR affect the
offset counting mechanism.
.Sp
Also see the entry for \f(CW@itempos\fR.
.ie n .IP "@itempos" 4
.el .IP "\f(CW@itempos\fR" 4
.IX Item "@itempos"
The array \f(CW@itempos\fR stores a hash reference corresponding to
each element of \f(CW@item\fR. The elements of the hash provide the
following:
.Sp
.Vb 6
\&    $itempos[$n]{offset}{from}  # VALUE OF $thisoffset BEFORE $item[$n]
\&    $itempos[$n]{offset}{to}    # VALUE OF $prevoffset AFTER $item[$n]
\&    $itempos[$n]{line}{from}    # VALUE OF $thisline BEFORE $item[$n]
\&    $itempos[$n]{line}{to}  # VALUE OF $prevline AFTER $item[$n]
\&    $itempos[$n]{column}{from}  # VALUE OF $thiscolumn BEFORE $item[$n]
\&    $itempos[$n]{column}{to}    # VALUE OF $prevcolumn AFTER $item[$n]
.Ve
.Sp
Note that the various \f(CW\*(C`$itempos[$n]...{from}\*(C'\fR values record the
appropriate value \fIafter\fR any token prefix has been skipped.
.Sp
Hence, instead of the somewhat tedious and error-prone:
.Sp
.Vb 9
\&    rule: startcol token1 endcol
\&      startcol token2 endcol
\&      startcol token3 endcol
\&        { print "token1: columns $item[1]
\&              to $item[3]
\&         token2: columns $item[4]
\&              to $item[6]
\&         token3: columns $item[7]
\&              to $item[9]" }
\&
\&    startcol: \*(Aq\*(Aq { $thiscolumn }    # NEED THE \*(Aq\*(Aq TO STEP PAST TOKEN SEP
\&    endcol:  { $prevcolumn }
.Ve
.Sp
it is possible to write:
.Sp
.Vb 7
\&    rule: token1 token2 token3
\&        { print "token1: columns $itempos[1]{column}{from}
\&              to $itempos[1]{column}{to}
\&         token2: columns $itempos[2]{column}{from}
\&              to $itempos[2]{column}{to}
\&         token3: columns $itempos[3]{column}{from}
\&              to $itempos[3]{column}{to}" }
.Ve
.Sp
Note however that (in the current implementation) the use of \f(CW@itempos\fR
anywhere in a grammar implies that item positioning information is
collected \fIeverywhere\fR during the parse. Depending on the grammar
and the size of the text to be parsed, this may be prohibitively
expensive and the explicit use of \f(CW$thisline\fR, \f(CW$thiscolumn\fR, etc. may
be a better choice.
.ie n .IP "$thisparser" 4
.el .IP "\f(CW$thisparser\fR" 4
.IX Item "$thisparser"
A reference to the \f(CW\*(C`Parse::RecDescent\*(C'\fR object through which
parsing was initiated.
.Sp
The value of \f(CW$thisparser\fR propagates down the subrules of a parse
but not back up. Hence, you can invoke subrules from another parser
for the scope of the current rule as follows:
.Sp
.Vb 4
\&    rule: subrule1 subrule2
\&    | { $thisparser = $::otherparser } <reject>
\&    | subrule3 subrule4
\&    | subrule5
.Ve
.Sp
The result is that the production calls \*(L"subrule1\*(R" and \*(L"subrule2\*(R" of
the current parser, and the remaining productions call the named subrules
from \f(CW$::otherparser\fR. Note, however that \*(L"Bad Things\*(R" will happen if
\&\f(CW\*(C`::otherparser\*(C'\fR isn't a blessed reference and/or doesn't have methods
with the same names as the required subrules!
.ie n .IP "$thisrule" 4
.el .IP "\f(CW$thisrule\fR" 4
.IX Item "$thisrule"
A reference to the \f(CW\*(C`Parse::RecDescent::Rule\*(C'\fR object corresponding to the
rule currently being matched.
.ie n .IP "$thisprod" 4
.el .IP "\f(CW$thisprod\fR" 4
.IX Item "$thisprod"
A reference to the \f(CW\*(C`Parse::RecDescent::Production\*(C'\fR object
corresponding to the production currently being matched.
.ie n .IP "$score and $score_return" 4
.el .IP "\f(CW$score\fR and \f(CW$score_return\fR" 4
.IX Item "$score and $score_return"
\&\f(CW$score\fR stores the best production score to date, as specified by
an earlier \f(CW\*(C`<score:...>\*(C'\fR directive. \f(CW$score_return\fR stores
the corresponding return value for the successful production.
.Sp
See \*(L"Scored productions\*(R".
.PP
\&\fBWarning:\fR the parser relies on the information in the various \f(CW\*(C`this...\*(C'\fR
objects in some non-obvious ways. Tinkering with the other members of
these objects will probably cause Bad Things to happen, unless you
\&\fIreally\fR know what you're doing. The only exception to this advice is
that the use of \f(CW\*(C`$this...\->{local}\*(C'\fR is always safe.
.SS "Start-up Actions"
.IX Subsection "Start-up Actions"
Any actions which appear \fIbefore\fR the first rule definition in a
grammar are treated as \*(L"start-up\*(R" actions. Each such action is
stripped of its outermost brackets and then evaluated (in the parser's
special namespace) just before the rules of the grammar are first
compiled.
.PP
The main use of start-up actions is to declare local variables within the
parser's special namespace:
.PP
.Vb 1
\&    { my $lastitem = \*(Aq???\*(Aq; }
\&
\&    list: item(s)   { $return = $lastitem }
\&
\&    item: book  { $lastitem = \*(Aqbook\*(Aq; }
\&      bell  { $lastitem = \*(Aqbell\*(Aq; }
\&      candle    { $lastitem = \*(Aqcandle\*(Aq; }
.Ve
.PP
but start-up actions can be used to execute \fIany\fR valid Perl code
within a parser's special namespace.
.PP
Start-up actions can appear within a grammar extension or replacement
(that is, a partial grammar installed via \f(CW\*(C`Parse::RecDescent::Extend()\*(C'\fR or
\&\f(CW\*(C`Parse::RecDescent::Replace()\*(C'\fR \- see \*(L"Incremental Parsing\*(R"), and will be
executed before the new grammar is installed. Note, however, that a
particular start-up action is only ever executed once.
.SS "Autoactions"
.IX Subsection "Autoactions"
It is sometimes desirable to be able to specify a default action to be
taken at the end of every production (for example, in order to easily
build a parse tree). If the variable \f(CW$::RD_AUTOACTION\fR is defined
when \f(CW\*(C`Parse::RecDescent::new()\*(C'\fR is called, the contents of that
variable are treated as a specification of an action which is to appended
to each production in the corresponding grammar.
.PP
Alternatively, you can hard-code the autoaction within a grammar, using the
\&\f(CW\*(C`<autoaction:...>\*(C'\fR directive.
.PP
So, for example, to construct a simple parse tree you could write:
.PP
.Vb 1
\&    $::RD_AUTOACTION = q { [@item] };
\&
\&    parser = Parse::RecDescent\->new(q{
\&    expression: and_expr \*(Aq||\*(Aq expression | and_expr
\&    and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&    not_expr:   \*(Aq!\*(Aq brack_expr       | brack_expr
\&    brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&    identifier: /[a\-z]+/i
\&    });
.Ve
.PP
or:
.PP
.Vb 2
\&    parser = Parse::RecDescent\->new(q{
\&    <autoaction: { [@item] } >
\&
\&    expression: and_expr \*(Aq||\*(Aq expression | and_expr
\&    and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&    not_expr:   \*(Aq!\*(Aq brack_expr       | brack_expr
\&    brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&    identifier: /[a\-z]+/i
\&    });
.Ve
.PP
Either of these is equivalent to:
.PP
.Vb 5
\&    parser = new Parse::RecDescent (q{
\&    expression: and_expr \*(Aq||\*(Aq expression
\&        { [@item] }
\&      | and_expr
\&        { [@item] }
\&
\&    and_expr:   not_expr \*(Aq&&\*(Aq and_expr
\&        { [@item] }
\&    |   not_expr
\&        { [@item] }
\&
\&    not_expr:   \*(Aq!\*(Aq brack_expr
\&        { [@item] }
\&    |   brack_expr
\&        { [@item] }
\&
\&    brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq
\&        { [@item] }
\&      | identifier
\&        { [@item] }
\&
\&    identifier: /[a\-z]+/i
\&        { [@item] }
\&    });
.Ve
.PP
Alternatively, we could take an object-oriented approach, use different
classes for each node (and also eliminating redundant intermediate nodes):
.PP
.Vb 2
\&    $::RD_AUTOACTION = q
\&      { $#item==1 ? $item[1] : "$item[0]_node"\->new(@item[1..$#item]) };
\&
\&    parser = Parse::RecDescent\->new(q{
\&        expression: and_expr \*(Aq||\*(Aq expression | and_expr
\&        and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&        not_expr:   \*(Aq!\*(Aq brack_expr           | brack_expr
\&        brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&        identifier: /[a\-z]+/i
\&    });
.Ve
.PP
or:
.PP
.Vb 4
\&    parser = Parse::RecDescent\->new(q{
\&        <autoaction:
\&          $#item==1 ? $item[1] : "$item[0]_node"\->new(@item[1..$#item])
\&        >
\&
\&        expression: and_expr \*(Aq||\*(Aq expression | and_expr
\&        and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&        not_expr:   \*(Aq!\*(Aq brack_expr           | brack_expr
\&        brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&        identifier: /[a\-z]+/i
\&    });
.Ve
.PP
which are equivalent to:
.PP
.Vb 4
\&    parser = Parse::RecDescent\->new(q{
\&        expression: and_expr \*(Aq||\*(Aq expression
\&            { "expression_node"\->new(@item[1..3]) }
\&        | and_expr
\&
\&        and_expr:   not_expr \*(Aq&&\*(Aq and_expr
\&            { "and_expr_node"\->new(@item[1..3]) }
\&        |   not_expr
\&
\&        not_expr:   \*(Aq!\*(Aq brack_expr
\&            { "not_expr_node"\->new(@item[1..2]) }
\&        |   brack_expr
\&
\&        brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq
\&            { "brack_expr_node"\->new(@item[1..3]) }
\&        | identifier
\&
\&        identifier: /[a\-z]+/i
\&            { "identifer_node"\->new(@item[1]) }
\&    });
.Ve
.PP
Note that, if a production already ends in an action, no autoaction is appended
to it. For example, in this version:
.PP
.Vb 2
\&    $::RD_AUTOACTION = q
\&      { $#item==1 ? $item[1] : "$item[0]_node"\->new(@item[1..$#item]) };
\&
\&    parser = Parse::RecDescent\->new(q{
\&        expression: and_expr \*(Aq&&\*(Aq expression | and_expr
\&        and_expr:   not_expr \*(Aq&&\*(Aq and_expr   | not_expr
\&        not_expr:   \*(Aq!\*(Aq brack_expr           | brack_expr
\&        brack_expr: \*(Aq(\*(Aq expression \*(Aq)\*(Aq       | identifier
\&        identifier: /[a\-z]+/i
\&            { \*(Aqterminal_node\*(Aq\->new($item[1]) }
\&    });
.Ve
.PP
each \f(CW\*(C`identifier\*(C'\fR match produces a \f(CW\*(C`terminal_node\*(C'\fR object, \fInot\fR an
\&\f(CW\*(C`identifier_node\*(C'\fR object.
.PP
A level 1 warning is issued each time an \*(L"autoaction\*(R" is added to
some production.
.SS "Autotrees"
.IX Subsection "Autotrees"
A commonly needed autoaction is one that builds a parse-tree. It is moderately
tricky to set up such an action (which must treat terminals differently from
non-terminals), so Parse::RecDescent simplifies the process by providing the
\&\f(CW\*(C`<autotree>\*(C'\fR directive.
.PP
If this directive appears at the start of grammar, it causes
Parse::RecDescent to insert autoactions at the end of any rule except
those which already end in an action. The action inserted depends on whether
the production is an intermediate rule (two or more items), or a terminal
of the grammar (i.e. a single pattern or string item).
.PP
So, for example, the following grammar:
.PP
.Vb 1
\&    <autotree>
\&
\&    file    : command(s)
\&    command : get | set | vet
\&    get : \*(Aqget\*(Aq ident \*(Aq;\*(Aq
\&    set : \*(Aqset\*(Aq ident \*(Aqto\*(Aq value \*(Aq;\*(Aq
\&    vet : \*(Aqcheck\*(Aq ident \*(Aqis\*(Aq value \*(Aq;\*(Aq
\&    ident   : /\ew+/
\&    value   : /\ed+/
.Ve
.PP
is equivalent to:
.PP
.Vb 7
\&    file    : command(s)        { bless \e%item, $item[0] }
\&    command : get       { bless \e%item, $item[0] }
\&    | set           { bless \e%item, $item[0] }
\&    | vet           { bless \e%item, $item[0] }
\&    get : \*(Aqget\*(Aq ident \*(Aq;\*(Aq   { bless \e%item, $item[0] }
\&    set : \*(Aqset\*(Aq ident \*(Aqto\*(Aq value \*(Aq;\*(Aq    { bless \e%item, $item[0] }
\&    vet : \*(Aqcheck\*(Aq ident \*(Aqis\*(Aq value \*(Aq;\*(Aq  { bless \e%item, $item[0] }
\&
\&    ident   : /\ew+/  { bless {_\|_VALUE_\|_=>$item[1]}, $item[0] }
\&    value   : /\ed+/  { bless {_\|_VALUE_\|_=>$item[1]}, $item[0] }
.Ve
.PP
Note that each node in the tree is blessed into a class of the same name
as the rule itself. This makes it easy to build object-oriented
processors for the parse-trees that the grammar produces. Note too that
the last two rules produce special objects with the single attribute
\&'_\|_VALUE_\|_'. This is because they consist solely of a single terminal.
.PP
This autoaction-ed grammar would then produce a parse tree in a data
structure like this:
.PP
.Vb 10
\&    {
\&      file => {
\&        command => {
\&         [ get => {
\&            identifier => { _\|_VALUE_\|_ => \*(Aqa\*(Aq },
\&              },
\&           set => {
\&            identifier => { _\|_VALUE_\|_ => \*(Aqb\*(Aq },
\&            value      => { _\|_VALUE_\|_ => \*(Aq7\*(Aq },
\&              },
\&           vet => {
\&            identifier => { _\|_VALUE_\|_ => \*(Aqb\*(Aq },
\&            value      => { _\|_VALUE_\|_ => \*(Aq7\*(Aq },
\&              },
\&          ],
\&           },
\&      }
\&    }
.Ve
.PP
(except, of course, that each nested hash would also be blessed into
the appropriate class).
.PP
You can also specify a base class for the \f(CW\*(C`<autotree>\*(C'\fR directive.
The supplied prefix will be prepended to the rule names when creating
tree nodes.  The following are equivalent:
.PP
.Vb 2
\&    <autotree:MyBase::Class>
\&    <autotree:MyBase::Class::>
.Ve
.PP
And will produce a root node blessed into the \f(CW\*(C`MyBase::Class::file\*(C'\fR
package in the example above.
.SS "Autostubbing"
.IX Subsection "Autostubbing"
Normally, if a subrule appears in some production, but no rule of that
name is ever defined in the grammar, the production which refers to the
non-existent subrule fails immediately. This typically occurs as a
result of misspellings, and is a sufficiently common occurance that a
warning is generated for such situations.
.PP
However, when prototyping a grammar it is sometimes useful to be
able to use subrules before a proper specification of them is
really possible.  For example, a grammar might include a section like:
.PP
.Vb 1
\&    function_call: identifier \*(Aq(\*(Aq arg(s?) \*(Aq)\*(Aq
\&
\&    identifier: /[a\-z]\ew*/i
.Ve
.PP
where the possible format of an argument is sufficiently complex that
it is not worth specifying in full until the general function call
syntax has been debugged. In this situation it is convenient to leave
the real rule \f(CW\*(C`arg\*(C'\fR undefined and just slip in a placeholder (or
\&\*(L"stub\*(R"):
.PP
.Vb 1
\&    arg: \*(Aqarg\*(Aq
.Ve
.PP
so that the function call syntax can be tested with dummy input such as:
.PP
.Vb 4
\&    f0()
\&    f1(arg)
\&    f2(arg arg)
\&    f3(arg arg arg)
.Ve
.PP
et cetera.
.PP
Early in prototyping, many such \*(L"stubs\*(R" may be required, so
\&\f(CW\*(C`Parse::RecDescent\*(C'\fR provides a means of automating their definition.
If the variable \f(CW$::RD_AUTOSTUB\fR is defined when a parser is built, a
subrule reference to any non-existent rule (say, \f(CW\*(C`subrule\*(C'\fR), will
cause a \*(L"stub\*(R" rule to be automatically defined in the generated
parser.  If \f(CW\*(C`$::RD_AUTOSTUB eq \*(Aq1\*(Aq\*(C'\fR or is false, a stub rule of the
form:
.PP
.Vb 1
\&    subrule: \*(Aqsubrule\*(Aq
.Ve
.PP
will be generated.  The special-case for a value of \f(CW\*(Aq1\*(Aq\fR is to allow
the use of the \fBperl \-s\fR with \fB\-RD_AUTOSTUB\fR without generating
\&\f(CW\*(C`subrule: \*(Aq1\*(Aq\*(C'\fR per below. If \f(CW$::RD_AUTOSTUB\fR is true, a stub rule
of the form:
.PP
.Vb 1
\&    subrule: $::RD_AUTOSTUB
.Ve
.PP
will be generated.  \f(CW$::RD_AUTOSTUB\fR must contain a valid production
item, no checking is performed.  No lazy evaluation of
\&\f(CW$::RD_AUTOSTUB\fR is performed, it is evaluated at the time the Parser
is generated.
.PP
Hence, with \f(CW$::RD_AUTOSTUB\fR defined, it is possible to only
partially specify a grammar, and then \*(L"fake\*(R" matches of the
unspecified (sub)rules by just typing in their name, or a literal
value that was assigned to \f(CW$::RD_AUTOSTUB\fR.
.SS "Look-ahead"
.IX Subsection "Look-ahead"
If a subrule, token, or action is prefixed by \*(L"...\*(R", then it is
treated as a \*(L"look-ahead\*(R" request. That means that the current production can
(as usual) only succeed if the specified item is matched, but that the matching
\&\fIdoes not consume any of the text being parsed\fR. This is very similar to the
\&\f(CW\*(C`/(?=...)/\*(C'\fR look-ahead construct in Perl patterns. Thus, the rule:
.PP
.Vb 1
\&    inner_word: word ...word
.Ve
.PP
will match whatever the subrule \*(L"word\*(R" matches, provided that match is followed
by some more text which subrule \*(L"word\*(R" would also match (although this
second substring is not actually consumed by \*(L"inner_word\*(R")
.PP
Likewise, a \*(L"...!\*(R" prefix, causes the following item to succeed (without
consuming any text) if and only if it would normally fail. Hence, a
rule such as:
.PP
.Vb 1
\&    identifier: ...!keyword ...!\*(Aq_\*(Aq /[A\-Za\-z_]\ew*/
.Ve
.PP
matches a string of characters which satisfies the pattern
\&\f(CW\*(C`/[A\-Za\-z_]\ew*/\*(C'\fR, but only if the same sequence of characters would
not match either subrule \*(L"keyword\*(R" or the literal token '_'.
.PP
Sequences of look-ahead prefixes accumulate, multiplying their positive and/or
negative senses. Hence:
.PP
.Vb 1
\&    inner_word: word ...!......!word
.Ve
.PP
is exactly equivalent the the original example above (a warning is issued in
cases like these, since they often indicate something left out, or
misunderstood).
.PP
Note that actions can also be treated as look-aheads. In such cases,
the state of the parser text (in the local variable \f(CW$text\fR)
\&\fIafter\fR the look-ahead action is guaranteed to be identical to its
state \fIbefore\fR the action, regardless of how it's changed \fIwithin\fR
the action (unless you actually undefine \f(CW$text\fR, in which case you
get the disaster you deserve :\-).
.SS "Directives"
.IX Subsection "Directives"
Directives are special pre-defined actions which may be used to alter
the behaviour of the parser. There are currently twenty-three directives:
\&\f(CW\*(C`<commit>\*(C'\fR,
\&\f(CW\*(C`<uncommit>\*(C'\fR,
\&\f(CW\*(C`<reject>\*(C'\fR,
\&\f(CW\*(C`<score>\*(C'\fR,
\&\f(CW\*(C`<autoscore>\*(C'\fR,
\&\f(CW\*(C`<skip>\*(C'\fR,
\&\f(CW\*(C`<resync>\*(C'\fR,
\&\f(CW\*(C`<error>\*(C'\fR,
\&\f(CW\*(C`<warn>\*(C'\fR,
\&\f(CW\*(C`<hint>\*(C'\fR,
\&\f(CW\*(C`<trace_build>\*(C'\fR,
\&\f(CW\*(C`<trace_parse>\*(C'\fR,
\&\f(CW\*(C`<nocheck>\*(C'\fR,
\&\f(CW\*(C`<rulevar>\*(C'\fR,
\&\f(CW\*(C`<matchrule>\*(C'\fR,
\&\f(CW\*(C`<leftop>\*(C'\fR,
\&\f(CW\*(C`<rightop>\*(C'\fR,
\&\f(CW\*(C`<defer>\*(C'\fR,
\&\f(CW\*(C`<nocheck>\*(C'\fR,
\&\f(CW\*(C`<perl_quotelike>\*(C'\fR,
\&\f(CW\*(C`<perl_codeblock>\*(C'\fR,
\&\f(CW\*(C`<perl_variable>\*(C'\fR,
and \f(CW\*(C`<token>\*(C'\fR.
.IP "Committing and uncommitting" 4
.IX Item "Committing and uncommitting"
The \f(CW\*(C`<commit>\*(C'\fR and \f(CW\*(C`<uncommit>\*(C'\fR directives permit the recursive
descent of the parse tree to be pruned (or \*(L"cut\*(R") for efficiency.
Within a rule, a \f(CW\*(C`<commit>\*(C'\fR directive instructs the rule to ignore subsequent
productions if the current production fails. For example:
.Sp
.Vb 3
\&    command: \*(Aqfind\*(Aq <commit> filename
\&       | \*(Aqopen\*(Aq <commit> filename
\&       | \*(Aqmove\*(Aq filename filename
.Ve
.Sp
Clearly, if the leading token 'find' is matched in the first production but that
production fails for some other reason, then the remaining
productions cannot possibly match. The presence of the
\&\f(CW\*(C`<commit>\*(C'\fR causes the \*(L"command\*(R" rule to fail immediately if
an invalid \*(L"find\*(R" command is found, and likewise if an invalid \*(L"open\*(R"
command is encountered.
.Sp
It is also possible to revoke a previous commitment. For example:
.Sp
.Vb 5
\&    if_statement: \*(Aqif\*(Aq <commit> condition
\&        \*(Aqthen\*(Aq block <uncommit>
\&        \*(Aqelse\*(Aq block
\&        | \*(Aqif\*(Aq <commit> condition
\&        \*(Aqthen\*(Aq block
.Ve
.Sp
In this case, a failure to find an \*(L"else\*(R" block in the first
production shouldn't preclude trying the second production, but a
failure to find a \*(L"condition\*(R" certainly should.
.Sp
As a special case, any production in which the \fIfirst\fR item is an
\&\f(CW\*(C`<uncommit>\*(C'\fR immediately revokes a preceding \f(CW\*(C`<commit>\*(C'\fR
(even though the production would not otherwise have been tried). For
example, in the rule:
.Sp
.Vb 5
\&    request: \*(Aqexplain\*(Aq expression
\&           | \*(Aqexplain\*(Aq <commit> keyword
\&           | \*(Aqsave\*(Aq
\&           | \*(Aqquit\*(Aq
\&           | <uncommit> term \*(Aq?\*(Aq
.Ve
.Sp
if the text being matched was \*(L"explain?\*(R", and the first two
productions failed, then the \f(CW\*(C`<commit>\*(C'\fR in production two would cause
productions three and four to be skipped, but the leading
\&\f(CW\*(C`<uncommit>\*(C'\fR in the production five would allow that production to
attempt a match.
.Sp
Note in the preceding example, that the \f(CW\*(C`<commit>\*(C'\fR was only placed
in production two. If production one had been:
.Sp
.Vb 1
\&    request: \*(Aqexplain\*(Aq <commit> expression
.Ve
.Sp
then production two would be (inappropriately) skipped if a leading
\&\*(L"explain...\*(R" was encountered.
.Sp
Both \f(CW\*(C`<commit>\*(C'\fR and \f(CW\*(C`<uncommit>\*(C'\fR directives always succeed, and their value
is always 1.
.IP "Rejecting a production" 4
.IX Item "Rejecting a production"
The \f(CW\*(C`<reject>\*(C'\fR directive immediately causes the current production
to fail (it is exactly equivalent to, but more obvious than, the
action \f(CW\*(C`{undef}\*(C'\fR). A \f(CW\*(C`<reject>\*(C'\fR is useful when it is desirable to get
the side effects of the actions in one production, without prejudicing a match
by some other production later in the rule. For example, to insert
tracing code into the parse:
.Sp
.Vb 1
\&    complex_rule: { print "In complex rule...\en"; } <reject>
\&
\&    complex_rule: simple_rule \*(Aq+\*(Aq \*(Aqi\*(Aq \*(Aq*\*(Aq simple_rule
\&        | \*(Aqi\*(Aq \*(Aq*\*(Aq simple_rule
\&        | simple_rule
.Ve
.Sp
It is also possible to specify a conditional rejection, using the
form \f(CW\*(C`<reject:\f(CIcondition\f(CW>\*(C'\fR, which only rejects if the
specified condition is true. This form of rejection is exactly
equivalent to the action \f(CW\*(C`{(\f(CIcondition\f(CW)?undef:1}>\*(C'\fR.
For example:
.Sp
.Vb 4
\&    command: save_command
\&       | restore_command
\&       | <reject: defined $::tolerant> { exit }
\&       | <error: Unknown command. Ignored.>
.Ve
.Sp
A \f(CW\*(C`<reject>\*(C'\fR directive never succeeds (and hence has no
associated value). A conditional rejection may succeed (if its
condition is not satisfied), in which case its value is 1.
.Sp
As an extra optimization, \f(CW\*(C`Parse::RecDescent\*(C'\fR ignores any production
which \fIbegins\fR with an unconditional \f(CW\*(C`<reject>\*(C'\fR directive,
since any such production can never successfully match or have any
useful side-effects. A level 1 warning is issued in all such cases.
.Sp
Note that productions beginning with conditional
\&\f(CW\*(C`<reject:...>\*(C'\fR directives are \fInever\fR \*(L"optimized away\*(R" in
this manner, even if they are always guaranteed to fail (for example:
\&\f(CW\*(C`<reject:1>\*(C'\fR)
.Sp
Due to the way grammars are parsed, there is a minor restriction on the
condition of a conditional \f(CW\*(C`<reject:...>\*(C'\fR: it cannot
contain any raw '<' or '>' characters. For example:
.Sp
.Vb 1
\&    line: cmd <reject: $thiscolumn > max> data
.Ve
.Sp
results in an error when a parser is built from this grammar (since the
grammar parser has no way of knowing whether the first > is a \*(L"less than\*(R"
or the end of the \f(CW\*(C`<reject:...>\*(C'\fR.
.Sp
To overcome this problem, put the condition inside a do{} block:
.Sp
.Vb 1
\&    line: cmd <reject: do{$thiscolumn > max}> data
.Ve
.Sp
Note that the same problem may occur in other directives that take
arguments. The same solution will work in all cases.
.IP "Skipping between terminals" 4
.IX Item "Skipping between terminals"
The \f(CW\*(C`<skip>\*(C'\fR directive enables the terminal prefix used in
a production to be changed. For example:
.Sp
.Vb 1
\&    OneLiner: Command <skip:\*(Aq[ \et]*\*(Aq> Arg(s) /;/
.Ve
.Sp
causes only blanks and tabs to be skipped before terminals in the \f(CW\*(C`Arg\*(C'\fR
subrule (and any of \fIits\fR subrules>, and also before the final \f(CW\*(C`/;/\*(C'\fR terminal.
Once the production is complete, the previous terminal prefix is
reinstated. Note that this implies that distinct productions of a rule
must reset their terminal prefixes individually.
.Sp
The \f(CW\*(C`<skip>\*(C'\fR directive evaluates to the \fIprevious\fR terminal prefix,
so it's easy to reinstate a prefix later in a production:
.Sp
.Vb 1
\&    Command: <skip:","> CSV(s) <skip:$item[1]> Modifier
.Ve
.Sp
The value specified after the colon is interpolated into a pattern, so all of
the following are equivalent (though their efficiency increases down the list):
.Sp
.Vb 1
\&    <skip: "$colon|$comma">   # ASSUMING THE VARS HOLD THE OBVIOUS VALUES
\&
\&    <skip: \*(Aq:|,\*(Aq>
\&
\&    <skip: q{[:,]}>
\&
\&    <skip: qr/[:,]/>
.Ve
.Sp
There is no way of directly setting the prefix for
an entire rule, except as follows:
.Sp
.Vb 3
\&    Rule: <skip: \*(Aq[ \et]*\*(Aq> Prod1
\&        | <skip: \*(Aq[ \et]*\*(Aq> Prod2a Prod2b
\&        | <skip: \*(Aq[ \et]*\*(Aq> Prod3
.Ve
.Sp
or, better:
.Sp
.Vb 6
\&    Rule: <skip: \*(Aq[ \et]*\*(Aq>
\&    (
\&        Prod1
\&      | Prod2a Prod2b
\&      | Prod3
\&    )
.Ve
.Sp
The skip pattern is passed down to subrules, so setting the skip for
the top-level rule as described above actually sets the prefix for the
entire grammar (provided that you only call the method corresponding
to the top-level rule itself). Alternatively, or if you have more than
one top-level rule in your grammar, you can provide a global
\&\f(CW\*(C`<skip>\*(C'\fR directive prior to defining any rules in the
grammar. These are the preferred alternatives to setting
\&\f(CW$Parse::RecDescent::skip\fR.
.Sp
Additionally, using \f(CW\*(C`<skip>\*(C'\fR actually allows you to have
a completely dynamic skipping behaviour. For example:
.Sp
.Vb 1
\&   Rule_with_dynamic_skip: <skip: $::skip_pattern> Rule
.Ve
.Sp
Then you can set \f(CW$::skip_pattern\fR before invoking
\&\f(CW\*(C`Rule_with_dynamic_skip\*(C'\fR and have it skip whatever you specified.
.Sp
\&\fBNote: Up to release 1.51 of Parse::RecDescent, an entirely different
mechanism was used for specifying terminal prefixes. The current method
is not backwards-compatible with that early approach. The current approach
is stable and will not to change again.\fR
.IP "Resynchronization" 4
.IX Item "Resynchronization"
The \f(CW\*(C`<resync>\*(C'\fR directive provides a visually distinctive
means of consuming some of the text being parsed, usually to skip an
erroneous input. In its simplest form \f(CW\*(C`<resync>\*(C'\fR simply
consumes text up to and including the next newline (\f(CW"\en"\fR)
character, succeeding only if the newline is found, in which case it
causes its surrounding rule to return zero on success.
.Sp
In other words, a \f(CW\*(C`<resync>\*(C'\fR is exactly equivalent to the token
\&\f(CW\*(C`/[^\en]*\en/\*(C'\fR followed by the action \f(CW\*(C`{\ $return\ =\ 0\ }\*(C'\fR (except that
productions beginning with a \f(CW\*(C`<resync>\*(C'\fR are ignored when generating
error messages). A typical use might be:
.Sp
.Vb 1
\&    script : command(s)
\&
\&    command: save_command
\&       | restore_command
\&       | <resync> # TRY NEXT LINE, IF POSSIBLE
.Ve
.Sp
It is also possible to explicitly specify a resynchronization
pattern, using the \f(CW\*(C`<resync:\f(CIpattern\f(CW>\*(C'\fR variant. This version
succeeds only if the specified pattern matches (and consumes) the
parsed text. In other words, \f(CW\*(C`<resync:\f(CIpattern\f(CW>\*(C'\fR is exactly
equivalent to the token \f(CW\*(C`/\f(CIpattern\f(CW/\*(C'\fR (followed by a \f(CW\*(C`{\ $return\ =\ 0\ }\*(C'\fR
action). For example, if commands were terminated by newlines or semi-colons:
.Sp
.Vb 3
\&    command: save_command
\&       | restore_command
\&       | <resync:[^;\en]*[;\en]>
.Ve
.Sp
The value of a successfully matched \f(CW\*(C`<resync>\*(C'\fR directive (of either
type) is the text that it consumed. Note, however, that since the
directive also sets \f(CW$return\fR, a production consisting of a lone
\&\f(CW\*(C`<resync>\*(C'\fR succeeds but returns the value zero (which a calling rule
may find useful to distinguish between \*(L"true\*(R" matches and \*(L"tolerant\*(R" matches).
Remember that returning a zero value indicates that the rule \fIsucceeded\fR (since
only an \f(CW\*(C`undef\*(C'\fR denotes failure within \f(CW\*(C`Parse::RecDescent\*(C'\fR parsers.
.IP "Error handling" 4
.IX Item "Error handling"
The \f(CW\*(C`<error>\*(C'\fR directive provides automatic or user-defined
generation of error messages during a parse. In its simplest form
\&\f(CW\*(C`<error>\*(C'\fR prepares an error message based on
the mismatch between the last item expected and the text which cause
it to fail. For example, given the rule:
.Sp
.Vb 3
\&    McCoy: curse \*(Aq,\*(Aq name \*(Aq, I\*(Aqm a doctor, not a\*(Aq a_profession \*(Aq!\*(Aq
\&     | pronoun \*(Aqdead,\*(Aq name \*(Aq!\*(Aq
\&     | <error>
.Ve
.Sp
the following strings would produce the following messages:
.RS 4
.ie n .IP """Amen, Jim!""" 4
.el .IP "``Amen, Jim!''" 4
.IX Item "Amen, Jim!"
.Vb 2
\&       ERROR (line 1): Invalid McCoy: Expected curse or pronoun
\&           not found
.Ve
.ie n .IP """Dammit, Jim, I'm a doctor!""" 4
.el .IP "``Dammit, Jim, I'm a doctor!''" 4
.IX Item "Dammit, Jim, I'm a doctor!"
.Vb 2
\&       ERROR (line 1): Invalid McCoy: Expected ", I\*(Aqm a doctor, not a"
\&           but found ", I\*(Aqm a doctor!" instead
.Ve
.ie n .IP """He's dead,\en""" 4
.el .IP "``He's dead,\en''" 4
.IX Item "He's dead,n"
.Vb 1
\&       ERROR (line 2): Invalid McCoy: Expected name not found
.Ve
.ie n .IP """He's alive!""" 4
.el .IP "``He's alive!''" 4
.IX Item "He's alive!"
.Vb 2
\&       ERROR (line 1): Invalid McCoy: Expected \*(Aqdead,\*(Aq but found
\&           "alive!" instead
.Ve
.ie n .IP """Dammit, Jim, I'm a doctor, not a pointy-eared Vulcan!""" 4
.el .IP "``Dammit, Jim, I'm a doctor, not a pointy-eared Vulcan!''" 4
.IX Item "Dammit, Jim, I'm a doctor, not a pointy-eared Vulcan!"
.Vb 2
\&       ERROR (line 1): Invalid McCoy: Expected a profession but found
\&           "pointy\-eared Vulcan!" instead
.Ve
.RE
.RS 4
.Sp
Note that, when autogenerating error messages, all underscores in any
rule name used in a message are replaced by single spaces (for example
\&\*(L"a_production\*(R" becomes \*(L"a production\*(R"). Judicious choice of rule
names can therefore considerably improve the readability of automatic
error messages (as well as the maintainability of the original
grammar).
.Sp
If the automatically generated error is not sufficient, it is possible to
provide an explicit message as part of the error directive. For example:
.Sp
.Vb 3
\&    Spock: "Fascinating \*(Aq,\*(Aq (name | \*(AqCaptain\*(Aq) \*(Aq.\*(Aq
\&     | "Highly illogical, doctor."
\&     | <error: He never said that!>
.Ve
.Sp
which would result in \fIall\fR failures to parse a \*(L"Spock\*(R" subrule printing the
following message:
.Sp
.Vb 1
\&       ERROR (line <N>): Invalid Spock:  He never said that!
.Ve
.Sp
The error message is treated as a \*(L"qq{...}\*(R" string and interpolated
when the error is generated (\fInot\fR when the directive is specified!).
Hence:
.Sp
.Vb 1
\&    <error: Mystical error near "$text">
.Ve
.Sp
would correctly insert the ambient text string which caused the error.
.Sp
There are two other forms of error directive: \f(CW\*(C`<error?>\*(C'\fR and
\&\f(CW\*(C`<error?:\ msg>\*(C'\fR. These behave just like \f(CW\*(C`<error>\*(C'\fR
and \f(CW\*(C`<error:\ msg>\*(C'\fR respectively, except that they are
only triggered if the rule is \*(L"committed\*(R" at the time they are
encountered. For example:
.Sp
.Vb 3
\&    Scotty: "Ya kenna change the Laws of Phusics," <commit> name
\&      | name <commit> \*(Aq,\*(Aq \*(Aqshe\*(Aqs goanta blaw!\*(Aq
\&      | <error?>
.Ve
.Sp
will only generate an error for a string beginning with \*(L"Ya kenna
change the Laws o' Phusics,\*(R" or a valid name, but which still fails to match the
corresponding production. That is, \f(CW\*(C`$parser\->Scotty("Aye, Cap\*(Aqain")\*(C'\fR will
fail silently (since neither production will \*(L"commit\*(R" the rule on that
input), whereas \f(CW\*(C`$parser\->Scotty("Mr\ Spock,\ ah\ jest\ kenna\ do\*(Aqut!")\*(C'\fR
will fail with the error message:
.Sp
.Vb 2
\&       ERROR (line 1): Invalid Scotty: expected \*(Aqshe\*(Aqs goanta blaw!\*(Aq
\&           but found \*(AqI jest kenna do\*(Aqut!\*(Aq instead.
.Ve
.Sp
since in that case the second production would commit after matching
the leading name.
.Sp
Note that to allow this behaviour, all \f(CW\*(C`<error>\*(C'\fR directives which are
the first item in a production automatically uncommit the rule just
long enough to allow their production to be attempted (that is, when
their production fails, the commitment is reinstated so that
subsequent productions are skipped).
.Sp
In order to \fIpermanently\fR uncommit the rule before an error message,
it is necessary to put an explicit \f(CW\*(C`<uncommit>\*(C'\fR before the
\&\f(CW\*(C`<error>\*(C'\fR. For example:
.Sp
.Vb 5
\&    line: \*(AqKirk:\*(Aq  <commit> Kirk
\&    | \*(AqSpock:\*(Aq <commit> Spock
\&    | \*(AqMcCoy:\*(Aq <commit> McCoy
\&    | <uncommit> <error?> <reject>
\&    | <resync>
.Ve
.Sp
Error messages generated by the various \f(CW\*(C`<error...>\*(C'\fR directives
are not displayed immediately. Instead, they are \*(L"queued\*(R" in a buffer and
are only displayed once parsing ultimately fails. Moreover,
\&\f(CW\*(C`<error...>\*(C'\fR directives that cause one production of a rule
to fail are automatically removed from the message queue
if another production subsequently causes the entire rule to succeed.
This means that you can put
\&\f(CW\*(C`<error...>\*(C'\fR directives wherever useful diagnosis can be done,
and only those associated with actual parser failure will ever be
displayed. Also see \*(L"\s-1GOTCHAS\*(R"\s0.
.Sp
As a general rule, the most useful diagnostics are usually generated
either at the very lowest level within the grammar, or at the very
highest. A good rule of thumb is to identify those subrules which
consist mainly (or entirely) of terminals, and then put an
\&\f(CW\*(C`<error...>\*(C'\fR directive at the end of any other rule which calls
one or more of those subrules.
.Sp
There is one other situation in which the output of the various types of
error directive is suppressed; namely, when the rule containing them
is being parsed as part of a \*(L"look-ahead\*(R" (see \*(L"Look-ahead\*(R"). In this
case, the error directive will still cause the rule to fail, but will do
so silently.
.Sp
An unconditional \f(CW\*(C`<error>\*(C'\fR directive always fails (and hence has no
associated value). This means that encountering such a directive
always causes the production containing it to fail. Hence an
\&\f(CW\*(C`<error>\*(C'\fR directive will inevitably be the last (useful) item of a
rule (a level 3 warning is issued if a production contains items after an unconditional
\&\f(CW\*(C`<error>\*(C'\fR directive).
.Sp
An \f(CW\*(C`<error?>\*(C'\fR directive will \fIsucceed\fR (that is: fail to fail :\-), if
the current rule is uncommitted when the directive is encountered. In
that case the directive's associated value is zero. Hence, this type
of error directive \fIcan\fR be used before the end of a
production. For example:
.Sp
.Vb 3
\&    command: \*(Aqdo\*(Aq <commit> something
\&       | \*(Aqreport\*(Aq <commit> something
\&       | <error?: Syntax error> <error: Unknown command>
.Ve
.Sp
\&\fBWarning:\fR The \f(CW\*(C`<error?>\*(C'\fR directive does \fInot\fR mean \*(L"always fail (but
do so silently unless committed)\*(R". It actually means "only fail (and report) if
committed, otherwise \fIsucceed\fR\*(L". To achieve the \*(R"fail silently if uncommitted"
semantics, it is necessary to use:
.Sp
.Vb 2
\&    rule: item <commit> item(s)
\&    | <error?> <reject>  # FAIL SILENTLY UNLESS COMMITTED
.Ve
.Sp
However, because people seem to expect a lone \f(CW\*(C`<error?>\*(C'\fR directive
to work like this:
.Sp
.Vb 3
\&    rule: item <commit> item(s)
\&    | <error?: Error message if committed>
\&    | <error:  Error message if uncommitted>
.Ve
.Sp
Parse::RecDescent automatically appends a
\&\f(CW\*(C`<reject>\*(C'\fR directive if the \f(CW\*(C`<error?>\*(C'\fR directive
is the only item in a production. A level 2 warning (see below)
is issued when this happens.
.Sp
The level of error reporting during both parser construction and
parsing is controlled by the presence or absence of four global
variables: \f(CW$::RD_ERRORS\fR, \f(CW$::RD_WARN\fR, \f(CW$::RD_HINT\fR, and
<$::RD_TRACE>. If \f(CW$::RD_ERRORS\fR is defined (and, by default, it is)
then fatal errors are reported.
.Sp
Whenever \f(CW$::RD_WARN\fR is defined, certain non-fatal problems are also reported.
.Sp
Warnings have an associated \*(L"level\*(R": 1, 2, or 3. The higher the level,
the more serious the warning. The value of the corresponding global
variable (\f(CW$::RD_WARN\fR) determines the \fIlowest\fR level of warning to
be displayed. Hence, to see \fIall\fR warnings, set \f(CW$::RD_WARN\fR to 1.
To see only the most serious warnings set \f(CW$::RD_WARN\fR to 3.
By default \f(CW$::RD_WARN\fR is initialized to 3, ensuring that serious but
non-fatal errors are automatically reported.
.Sp
There is also a grammar directive to turn on warnings from within the
grammar: \f(CW\*(C`<warn>\*(C'\fR. It takes an optional argument, which specifies
the warning level: \f(CW\*(C`<warn: 2>\*(C'\fR.
.Sp
See \fI\*(L"\s-1DIAGNOSTICS\*(R"\s0\fR for a list of the varous error and warning messages
that Parse::RecDescent generates when these two variables are defined.
.Sp
Defining any of the remaining variables (which are not defined by
default) further increases the amount of information reported.
Defining \f(CW$::RD_HINT\fR causes the parser generator to offer
more detailed analyses and hints on both errors and warnings.
Note that setting \f(CW$::RD_HINT\fR at any point automagically
sets \f(CW$::RD_WARN\fR to 1. There is also a \f(CW\*(C`<hint>\*(C'\fR directive, which can
be hard-coded into a grammar.
.Sp
Defining \f(CW$::RD_TRACE\fR causes the parser generator and the parser to
report their progress to \s-1STDERR\s0 in excruciating detail (although, without hints
unless \f(CW$::RD_HINT\fR is separately defined). This detail
can be moderated in only one respect: if \f(CW$::RD_TRACE\fR has an
integer value (\fIN\fR) greater than 1, only the \fIN\fR characters of
the \*(L"current parsing context\*(R" (that is, where in the input string we
are at any point in the parse) is reported at any time.
.Sp
\&\f(CW$::RD_TRACE\fR is mainly useful for debugging a grammar that isn't
behaving as you expected it to. To this end, if \f(CW$::RD_TRACE\fR is
defined when a parser is built, any actual parser code which is
generated is also written to a file named \*(L"\s-1RD_TRACE\*(R"\s0 in the local
directory.
.Sp
There are two directives associated with the \f(CW$::RD_TRACE\fR variable.
If a grammar contains a \f(CW\*(C`<trace_build>\*(C'\fR directive anywhere in its
specification, \f(CW$::RD_TRACE\fR is turned on during the parser construction
phase.  If a grammar contains a \f(CW\*(C`<trace_parse>\*(C'\fR directive anywhere in its
specification, \f(CW$::RD_TRACE\fR is turned on during any parse the parser
performs.
.Sp
Note that the four variables belong to the \*(L"main\*(R" package, which
makes them easier to refer to in the code controlling the parser, and
also makes it easy to turn them into command line flags (\*(L"\-RD_ERRORS\*(R",
\&\*(L"\-RD_WARN\*(R", \*(L"\-RD_HINT\*(R", \*(L"\-RD_TRACE\*(R") under \fBperl \-s\fR.
.Sp
The corresponding directives are useful to \*(L"hardwire\*(R" the various
debugging features into a particular grammar (rather than having to set
and reset external variables).
.RE
.IP "Redirecting diagnostics" 4
.IX Item "Redirecting diagnostics"
The diagnostics provided by the tracing mechanism always go to \s-1STDERR.\s0
If you need them to go elsewhere, localize and reopen \s-1STDERR\s0 prior to the
parse.
.Sp
For example:
.Sp
.Vb 2
\&    {
\&        local *STDERR = IO::File\->new(">$filename") or die $!;
\&
\&        my $result = $parser\->startrule($text);
\&    }
.Ve
.IP "Consistency checks" 4
.IX Item "Consistency checks"
Whenever a parser is build, Parse::RecDescent carries out a number of
(potentially expensive) consistency checks. These include: verifying that the
grammar is not left-recursive and that no rules have been left undefined.
.Sp
These checks are important safeguards during development, but unnecessary
overheads when the grammar is stable and ready to be deployed. So
Parse::RecDescent provides a directive to disable them: \f(CW\*(C`<nocheck>\*(C'\fR.
.Sp
If a grammar contains a \f(CW\*(C`<nocheck>\*(C'\fR directive anywhere in its
specification, the extra compile-time checks are by-passed.
.IP "Specifying local variables" 4
.IX Item "Specifying local variables"
It is occasionally convenient to specify variables which are local
to a single rule. This may be achieved by including a
\&\f(CW\*(C`<rulevar:...>\*(C'\fR directive anywhere in the rule. For example:
.Sp
.Vb 1
\&    markup: <rulevar: $tag>
\&
\&    markup: tag {($tag=$item[1]) =~ s/^<|>$//g} body[$tag]
.Ve
.Sp
The example \f(CW\*(C`<rulevar: $tag>\*(C'\fR directive causes a \*(L"my\*(R" variable named
\&\f(CW$tag\fR to be declared at the start of the subroutine implementing the
\&\f(CW\*(C`markup\*(C'\fR rule (that is, \fIbefore\fR the first production, regardless of
where in the rule it is specified).
.Sp
Specifically, any directive of the form:
\&\f(CW\*(C`<rulevar:\f(CItext\f(CW>\*(C'\fR causes a line of the form \f(CW\*(C`my \f(CItext\f(CW;\*(C'\fR
to be added at the beginning of the rule subroutine, immediately after
the definitions of the following local variables:
.Sp
.Vb 4
\&    $thisparser $commit
\&    $thisrule   @item
\&    $thisline   @arg
\&    $text   %arg
.Ve
.Sp
This means that the following \f(CW\*(C`<rulevar>\*(C'\fR directives work
as expected:
.Sp
.Vb 1
\&    <rulevar: $count = 0 >
\&
\&    <rulevar: $firstarg = $arg[0] || \*(Aq\*(Aq >
\&
\&    <rulevar: $myItems = \e@item >
\&
\&    <rulevar: @context = ( $thisline, $text, @arg ) >
\&
\&    <rulevar: ($name,$age) = $arg{"name","age"} >
.Ve
.Sp
If a variable that is also visible to subrules is required, it needs
to be \f(CW\*(C`local\*(C'\fR'd, not \f(CW\*(C`my\*(C'\fR'd. \f(CW\*(C`rulevar\*(C'\fR defaults to \f(CW\*(C`my\*(C'\fR, but if \f(CW\*(C`local\*(C'\fR
is explicitly specified:
.Sp
.Vb 1
\&    <rulevar: local $count = 0 >
.Ve
.Sp
then a \f(CW\*(C`local\*(C'\fR\-ized variable is declared instead, and will be available
within subrules.
.Sp
Note however that, because all such variables are \*(L"my\*(R" variables, their
values \fIdo not persist\fR between match attempts on a given rule. To
preserve values between match attempts, values can be stored within the
\&\*(L"local\*(R" member of the \f(CW$thisrule\fR object:
.Sp
.Vb 6
\&    countedrule: { $thisrule\->{"local"}{"count"}++ }
\&         <reject>
\&       | subrule1
\&       | subrule2
\&       | <reject: $thisrule\->{"local"}{"count"} == 1>
\&         subrule3
.Ve
.Sp
When matching a rule, each \f(CW\*(C`<rulevar>\*(C'\fR directive is matched as
if it were an unconditional \f(CW\*(C`<reject>\*(C'\fR directive (that is, it
causes any production in which it appears to immediately fail to match).
For this reason (and to improve readability) it is usual to specify any
\&\f(CW\*(C`<rulevar>\*(C'\fR directive in a separate production at the start of
the rule (this has the added advantage that it enables
\&\f(CW\*(C`Parse::RecDescent\*(C'\fR to optimize away such productions, just as it does
for the \f(CW\*(C`<reject>\*(C'\fR directive).
.IP "Dynamically matched rules" 4
.IX Item "Dynamically matched rules"
Because regexes and double-quoted strings are interpolated, it is relatively
easy to specify productions with \*(L"context sensitive\*(R" tokens. For example:
.Sp
.Vb 1
\&    command:  keyword  body  "end $item[1]"
.Ve
.Sp
which ensures that a command block is bounded by a
"\fI<keyword>\fR...end \fI<same keyword>\fR" pair.
.Sp
Building productions in which subrules are context sensitive is also possible,
via the \f(CW\*(C`<matchrule:...>\*(C'\fR directive. This directive behaves
identically to a subrule item, except that the rule which is invoked to match
it is determined by the string specified after the colon. For example, we could
rewrite the \f(CW\*(C`command\*(C'\fR rule like this:
.Sp
.Vb 1
\&    command:  keyword  <matchrule:body>  "end $item[1]"
.Ve
.Sp
Whatever appears after the colon in the directive is treated as an interpolated
string (that is, as if it appeared in \f(CW\*(C`qq{...}\*(C'\fR operator) and the value of
that interpolated string is the name of the subrule to be matched.
.Sp
Of course, just putting a constant string like \f(CW\*(C`body\*(C'\fR in a
\&\f(CW\*(C`<matchrule:...>\*(C'\fR directive is of little interest or benefit.
The power of directive is seen when we use a string that interpolates
to something interesting. For example:
.Sp
.Vb 1
\&    command:    keyword <matchrule:$item[1]_body> "end $item[1]"
\&
\&    keyword:    \*(Aqwhile\*(Aq | \*(Aqif\*(Aq | \*(Aqfunction\*(Aq
\&
\&    while_body: condition block
\&
\&    if_body:    condition block (\*(Aqelse\*(Aq block)(?)
\&
\&    function_body:  arglist block
.Ve
.Sp
Now the \f(CW\*(C`command\*(C'\fR rule selects how to proceed on the basis of the keyword
that is found. It is as if \f(CW\*(C`command\*(C'\fR were declared:
.Sp
.Vb 3
\&    command:    \*(Aqwhile\*(Aq    while_body    "end while"
\&       |    \*(Aqif\*(Aq       if_body   "end if"
\&       |    \*(Aqfunction\*(Aq function_body "end function"
.Ve
.Sp
When a \f(CW\*(C`<matchrule:...>\*(C'\fR directive is used as a repeated
subrule, the rule name expression is \*(L"late-bound\*(R". That is, the name of
the rule to be called is re-evaluated \fIeach time\fR a match attempt is
made. Hence, the following grammar:
.Sp
.Vb 1
\&    { $::species = \*(Aqdogs\*(Aq }
\&
\&    pair:   \*(Aqtwo\*(Aq <matchrule:$::species>(s)
\&
\&    dogs:   /dogs/ { $::species = \*(Aqcats\*(Aq }
\&
\&    cats:   /cats/
.Ve
.Sp
will match the string \*(L"two dogs cats cats\*(R" completely, whereas it will
only match the string \*(L"two dogs dogs dogs\*(R" up to the eighth letter. If
the rule name were \*(L"early bound\*(R" (that is, evaluated only the first
time the directive is encountered in a production), the reverse
behaviour would be expected.
.Sp
Note that the \f(CW\*(C`matchrule\*(C'\fR directive takes a string that is to be treated
as a rule name, \fInot\fR as a rule invocation. That is,
it's like a Perl symbolic reference, not an \f(CW\*(C`eval\*(C'\fR. Just as you can say:
.Sp
.Vb 1
\&    $subname = \*(Aqfoo\*(Aq;
\&
\&    # and later...
\&
\&    &{$foo}(@args);
.Ve
.Sp
but not:
.Sp
.Vb 1
\&    $subname = \*(Aqfoo(@args)\*(Aq;
\&
\&    # and later...
\&
\&    &{$foo};
.Ve
.Sp
likewise you can say:
.Sp
.Vb 1
\&    $rulename = \*(Aqfoo\*(Aq;
\&
\&    # and in the grammar...
\&
\&    <matchrule:$rulename>[@args]
.Ve
.Sp
but not:
.Sp
.Vb 1
\&    $rulename = \*(Aqfoo[@args]\*(Aq;
\&
\&    # and in the grammar...
\&
\&    <matchrule:$rulename>
.Ve
.IP "Deferred actions" 4
.IX Item "Deferred actions"
The \f(CW\*(C`<defer:...>\*(C'\fR directive is used to specify an action to be
performed when (and only if!) the current production ultimately succeeds.
.Sp
Whenever a \f(CW\*(C`<defer:...>\*(C'\fR directive appears, the code it specifies
is converted to a closure (an anonymous subroutine reference) which is
queued within the active parser object. Note that,
because the deferred code is converted to a closure, the values of any
\&\*(L"local\*(R" variable (such as \f(CW$text\fR, <@item>, etc.) are preserved
until the deferred code is actually executed.
.Sp
If the parse ultimately succeeds
\&\fIand\fR the production in which the \f(CW\*(C`<defer:...>\*(C'\fR directive was
evaluated formed part of the successful parse, then the deferred code is
executed immediately before the parse returns. If however the production
which queued a deferred action fails, or one of the higher-level
rules which called that production fails, then the deferred action is
removed from the queue, and hence is never executed.
.Sp
For example, given the grammar:
.Sp
.Vb 2
\&    sentence: noun trans noun
\&    | noun intrans
\&
\&    noun:     \*(Aqthe dog\*(Aq
\&        { print "$item[1]\et(noun)\en" }
\&    |     \*(Aqthe meat\*(Aq
\&        { print "$item[1]\et(noun)\en" }
\&
\&    trans:    \*(Aqate\*(Aq
\&        { print "$item[1]\et(transitive)\en" }
\&
\&    intrans:  \*(Aqate\*(Aq
\&        { print "$item[1]\et(intransitive)\en" }
\&       |  \*(Aqbarked\*(Aq
\&        { print "$item[1]\et(intransitive)\en" }
.Ve
.Sp
then parsing the sentence \f(CW"the dog ate"\fR would produce the output:
.Sp
.Vb 4
\&    the dog  (noun)
\&    ate  (transitive)
\&    the dog  (noun)
\&    ate  (intransitive)
.Ve
.Sp
This is because, even though the first production of \f(CW\*(C`sentence\*(C'\fR
ultimately fails, its initial subrules \f(CW\*(C`noun\*(C'\fR and \f(CW\*(C`trans\*(C'\fR do match,
and hence they execute their associated actions.
Then the second production of \f(CW\*(C`sentence\*(C'\fR succeeds, causing the
actions of the subrules \f(CW\*(C`noun\*(C'\fR and \f(CW\*(C`intrans\*(C'\fR to be executed as well.
.Sp
On the other hand, if the actions were replaced by \f(CW\*(C`<defer:...>\*(C'\fR
directives:
.Sp
.Vb 2
\&    sentence: noun trans noun
\&    | noun intrans
\&
\&    noun:     \*(Aqthe dog\*(Aq
\&        <defer: print "$item[1]\et(noun)\en" >
\&    |     \*(Aqthe meat\*(Aq
\&        <defer: print "$item[1]\et(noun)\en" >
\&
\&    trans:    \*(Aqate\*(Aq
\&        <defer: print "$item[1]\et(transitive)\en" >
\&
\&    intrans:  \*(Aqate\*(Aq
\&        <defer: print "$item[1]\et(intransitive)\en" >
\&       |  \*(Aqbarked\*(Aq
\&        <defer: print "$item[1]\et(intransitive)\en" >
.Ve
.Sp
the output would be:
.Sp
.Vb 2
\&    the dog  (noun)
\&    ate  (intransitive)
.Ve
.Sp
since deferred actions are only executed if they were evaluated in
a production which ultimately contributes to the successful parse.
.Sp
In this case, even though the first production of \f(CW\*(C`sentence\*(C'\fR caused
the subrules \f(CW\*(C`noun\*(C'\fR and \f(CW\*(C`trans\*(C'\fR to match, that production ultimately
failed and so the deferred actions queued by those subrules were subsequently
disgarded. The second production then succeeded, causing the entire
parse to succeed, and so the deferred actions queued by the (second) match of
the \f(CW\*(C`noun\*(C'\fR subrule and the subsequent match of \f(CW\*(C`intrans\*(C'\fR \fIare\fR preserved and
eventually executed.
.Sp
Deferred actions provide a means of improving the performance of a parser,
by only executing those actions which are part of the final parse-tree
for the input data.
.Sp
Alternatively, deferred actions can be viewed as a mechanism for building
(and executing) a
customized subroutine corresponding to the given input data, much in the
same way that autoactions (see \*(L"Autoactions\*(R") can be used to build a
customized data structure for specific input.
.Sp
Whether or not the action it specifies is ever executed,
a \f(CW\*(C`<defer:...>\*(C'\fR directive always succeeds, returning the
number of deferred actions currently queued at that point.
.IP "Parsing Perl" 4
.IX Item "Parsing Perl"
Parse::RecDescent provides limited support for parsing subsets of Perl,
namely: quote-like operators, Perl variables, and complete code blocks.
.Sp
The \f(CW\*(C`<perl_quotelike>\*(C'\fR directive can be used to parse any Perl
quote-like operator: \f(CW\*(Aqa string\*(Aq\fR, \f(CW\*(C`m/a pattern/\*(C'\fR, \f(CW\*(C`tr{ans}{lation}\*(C'\fR,
etc.  It does this by calling \fIText::Balanced::quotelike()\fR.
.Sp
If a quote-like operator is found, a reference to an array of eight elements
is returned. Those elements are identical to the last eight elements returned
by \fIText::Balanced::extract_quotelike()\fR in an array context, namely:
.RS 4
.IP "[0]" 4
.IX Item "[0]"
the name of the quotelike operator \*(-- 'q', 'qq', 'm', 's', 'tr' \*(-- if the
operator was named; otherwise \f(CW\*(C`undef\*(C'\fR,
.IP "[1]" 4
.IX Item "[1]"
the left delimiter of the first block of the operation,
.IP "[2]" 4
.IX Item "[2]"
the text of the first block of the operation
(that is, the contents of
a quote, the regex of a match, or substitution or the target list of a
translation),
.IP "[3]" 4
.IX Item "[3]"
the right delimiter of the first block of the operation,
.IP "[4]" 4
.IX Item "[4]"
the left delimiter of the second block of the operation if there is one
(that is, if it is a \f(CW\*(C`s\*(C'\fR, \f(CW\*(C`tr\*(C'\fR, or \f(CW\*(C`y\*(C'\fR); otherwise \f(CW\*(C`undef\*(C'\fR,
.IP "[5]" 4
.IX Item "[5]"
the text of the second block of the operation if there is one
(that is, the replacement of a substitution or the translation list
of a translation); otherwise \f(CW\*(C`undef\*(C'\fR,
.IP "[6]" 4
.IX Item "[6]"
the right delimiter of the second block of the operation (if any);
otherwise \f(CW\*(C`undef\*(C'\fR,
.IP "[7]" 4
.IX Item "[7]"
the trailing modifiers on the operation (if any); otherwise \f(CW\*(C`undef\*(C'\fR.
.RE
.RS 4
.Sp
If a quote-like expression is not found, the directive fails with the usual
\&\f(CW\*(C`undef\*(C'\fR value.
.Sp
The \f(CW\*(C`<perl_variable>\*(C'\fR directive can be used to parse any Perl
variable: \f(CW$scalar\fR, \f(CW@array\fR, \f(CW%hash\fR, \f(CW$ref\fR\->{field}[$index], etc.
It does this by calling \fIText::Balanced::extract_variable()\fR.
.Sp
If the directive matches text representing a valid Perl variable
specification, it returns that text. Otherwise it fails with the usual
\&\f(CW\*(C`undef\*(C'\fR value.
.Sp
The \f(CW\*(C`<perl_codeblock>\*(C'\fR directive can be used to parse curly-brace-delimited block of Perl code, such as: { \f(CW$a\fR = 1; f() =~ m/pat/; }.
It does this by calling \fIText::Balanced::extract_codeblock()\fR.
.Sp
If the directive matches text representing a valid Perl code block,
it returns that text. Otherwise it fails with the usual \f(CW\*(C`undef\*(C'\fR value.
.Sp
You can also tell it what kind of brackets to use as the outermost
delimiters. For example:
.Sp
.Vb 1
\&    arglist: <perl_codeblock ()>
.Ve
.Sp
causes an arglist to match a perl code block whose outermost delimiters
are \f(CW\*(C`(...)\*(C'\fR (rather than the default \f(CW\*(C`{...}\*(C'\fR).
.RE
.IP "Constructing tokens" 4
.IX Item "Constructing tokens"
Eventually, Parse::RecDescent will be able to parse tokenized input, as
well as ordinary strings. In preparation for this joyous day, the
\&\f(CW\*(C`<token:...>\*(C'\fR directive has been provided.
This directive creates a token which will be suitable for
input to a Parse::RecDescent parser (when it eventually supports
tokenized input).
.Sp
The text of the token is the value of the
immediately preceding item in the production. A
\&\f(CW\*(C`<token:...>\*(C'\fR directive always succeeds with a return
value which is the hash reference that is the new token. It also
sets the return value for the production to that hash ref.
.Sp
The \f(CW\*(C`<token:...>\*(C'\fR directive makes it easy to build
a Parse::RecDescent\-compatible lexer in Parse::RecDescent:
.Sp
.Vb 3
\&    my $lexer = new Parse::RecDescent q
\&    {
\&    lex:    token(s)
\&
\&    token:  /a\eb/          <token:INDEF>
\&         |  /the\eb/        <token:DEF>
\&         |  /fly\eb/        <token:NOUN,VERB>
\&         |  /[a\-z]+/i { lc $item[1] }  <token:ALPHA>
\&         |  <error: Unknown token>
\&
\&    };
.Ve
.Sp
which will eventually be able to be used with a regular Parse::RecDescent
grammar:
.Sp
.Vb 3
\&    my $parser = new Parse::RecDescent q
\&    {
\&    startrule: subrule1 subrule 2
\&
\&    # ETC...
\&    };
.Ve
.Sp
either with a pre-lexing phase:
.Sp
.Vb 1
\&    $parser\->startrule( $lexer\->lex($data) );
.Ve
.Sp
or with a lex-on-demand approach:
.Sp
.Vb 1
\&    $parser\->startrule( sub{$lexer\->token(\e$data)} );
.Ve
.Sp
But at present, only the \f(CW\*(C`<token:...>\*(C'\fR directive is
actually implemented. The rest is vapourware.
.IP "Specifying operations" 4
.IX Item "Specifying operations"
One of the commonest requirements when building a parser is to specify
binary operators. Unfortunately, in a normal grammar, the rules for
such things are awkward:
.Sp
.Vb 2
\&    disjunction:    conjunction (\*(Aqor\*(Aq conjunction)(s?)
\&        { $return = [ $item[1], @{$item[2]} ] }
\&
\&    conjunction:    atom (\*(Aqand\*(Aq atom)(s?)
\&        { $return = [ $item[1], @{$item[2]} ] }
.Ve
.Sp
or inefficient:
.Sp
.Vb 4
\&    disjunction:    conjunction \*(Aqor\*(Aq disjunction
\&        { $return = [ $item[1], @{$item[2]} ] }
\&       |    conjunction
\&        { $return = [ $item[1] ] }
\&
\&    conjunction:    atom \*(Aqand\*(Aq conjunction
\&        { $return = [ $item[1], @{$item[2]} ] }
\&       |    atom
\&        { $return = [ $item[1] ] }
.Ve
.Sp
and either way is ugly and hard to get right.
.Sp
The \f(CW\*(C`<leftop:...>\*(C'\fR and \f(CW\*(C`<rightop:...>\*(C'\fR directives provide an
easier way of specifying such operations. Using \f(CW\*(C`<leftop:...>\*(C'\fR the
above examples become:
.Sp
.Vb 2
\&    disjunction:    <leftop: conjunction \*(Aqor\*(Aq conjunction>
\&    conjunction:    <leftop: atom \*(Aqand\*(Aq atom>
.Ve
.Sp
The \f(CW\*(C`<leftop:...>\*(C'\fR directive specifies a left-associative binary operator.
It is specified around three other grammar elements
(typically subrules or terminals), which match the left operand,
the operator itself, and the right operand respectively.
.Sp
A \f(CW\*(C`<leftop:...>\*(C'\fR directive such as:
.Sp
.Vb 1
\&    disjunction:    <leftop: conjunction \*(Aqor\*(Aq conjunction>
.Ve
.Sp
is converted to the following:
.Sp
.Vb 2
\&    disjunction:    ( conjunction (\*(Aqor\*(Aq conjunction)(s?)
\&        { $return = [ $item[1], @{$item[2]} ] } )
.Ve
.Sp
In other words, a \f(CW\*(C`<leftop:...>\*(C'\fR directive matches the left operand followed by zero
or more repetitions of both the operator and the right operand. It then
flattens the matched items into an anonymous array which becomes the
(single) value of the entire \f(CW\*(C`<leftop:...>\*(C'\fR directive.
.Sp
For example, an \f(CW\*(C`<leftop:...>\*(C'\fR directive such as:
.Sp
.Vb 1
\&    output:  <leftop: ident \*(Aq<<\*(Aq expr >
.Ve
.Sp
when given a string such as:
.Sp
.Vb 1
\&    cout << var << "str" << 3
.Ve
.Sp
would match, and \f(CW$item[1]\fR would be set to:
.Sp
.Vb 1
\&    [ \*(Aqcout\*(Aq, \*(Aqvar\*(Aq, \*(Aq"str"\*(Aq, \*(Aq3\*(Aq ]
.Ve
.Sp
In other words:
.Sp
.Vb 1
\&    output:  <leftop: ident \*(Aq<<\*(Aq expr >
.Ve
.Sp
is equivalent to a left-associative operator:
.Sp
.Vb 5
\&    output:  ident          { $return = [$item[1]]   }
\&          |  ident \*(Aq<<\*(Aq expr        { $return = [@item[1,3]]     }
\&          |  ident \*(Aq<<\*(Aq expr \*(Aq<<\*(Aq expr      { $return = [@item[1,3,5]]   }
\&          |  ident \*(Aq<<\*(Aq expr \*(Aq<<\*(Aq expr \*(Aq<<\*(Aq expr    { $return = [@item[1,3,5,7]] }
\&          #  ...etc...
.Ve
.Sp
Similarly, the \f(CW\*(C`<rightop:...>\*(C'\fR directive takes a left operand, an operator, and a right operand:
.Sp
.Vb 1
\&    assign:  <rightop: var \*(Aq=\*(Aq expr >
.Ve
.Sp
and converts them to:
.Sp
.Vb 2
\&    assign:  ( (var \*(Aq=\*(Aq {$return=$item[1]})(s?) expr
\&        { $return = [ @{$item[1]}, $item[2] ] } )
.Ve
.Sp
which is equivalent to a right-associative operator:
.Sp
.Vb 5
\&    assign:  expr       { $return = [$item[1]]       }
\&          |  var \*(Aq=\*(Aq expr       { $return = [@item[1,3]]     }
\&          |  var \*(Aq=\*(Aq var \*(Aq=\*(Aq expr   { $return = [@item[1,3,5]]   }
\&          |  var \*(Aq=\*(Aq var \*(Aq=\*(Aq var \*(Aq=\*(Aq expr   { $return = [@item[1,3,5,7]] }
\&          #  ...etc...
.Ve
.Sp
Note that for both the \f(CW\*(C`<leftop:...>\*(C'\fR and \f(CW\*(C`<rightop:...>\*(C'\fR directives, the directive does not normally
return the operator itself, just a list of the operands involved. This is
particularly handy for specifying lists:
.Sp
.Vb 2
\&    list: \*(Aq(\*(Aq <leftop: list_item \*(Aq,\*(Aq list_item> \*(Aq)\*(Aq
\&        { $return = $item[2] }
.Ve
.Sp
There is, however, a problem: sometimes the operator is itself significant.
For example, in a Perl list a comma and a \f(CW\*(C`=>\*(C'\fR are both
valid separators, but the \f(CW\*(C`=>\*(C'\fR has additional stringification semantics.
Hence it's important to know which was used in each case.
.Sp
To solve this problem the
\&\f(CW\*(C`<leftop:...>\*(C'\fR and \f(CW\*(C`<rightop:...>\*(C'\fR directives
\&\fIdo\fR return the operator(s) as well, under two circumstances.
The first case is where the operator is specified as a subrule. In that instance,
whatever the operator matches is returned (on the assumption that if the operator
is important enough to have its own subrule, then it's important enough to return).
.Sp
The second case is where the operator is specified as a regular
expression. In that case, if the first bracketed subpattern of the
regular expression matches, that matching value is returned (this is analogous to
the behaviour of the Perl \f(CW\*(C`split\*(C'\fR function, except that only the first subpattern
is returned).
.Sp
In other words, given the input:
.Sp
.Vb 1
\&    ( a=>1, b=>2 )
.Ve
.Sp
the specifications:
.Sp
.Vb 1
\&    list:      \*(Aq(\*(Aq  <leftop: list_item separator list_item>  \*(Aq)\*(Aq
\&
\&    separator: \*(Aq,\*(Aq | \*(Aq=>\*(Aq
.Ve
.Sp
or:
.Sp
.Vb 1
\&    list:      \*(Aq(\*(Aq  <leftop: list_item /(,|=>)/ list_item>  \*(Aq)\*(Aq
.Ve
.Sp
cause the list separators to be interleaved with the operands in the
anonymous array in \f(CW$item[2]\fR:
.Sp
.Vb 1
\&    [ \*(Aqa\*(Aq, \*(Aq=>\*(Aq, \*(Aq1\*(Aq, \*(Aq,\*(Aq, \*(Aqb\*(Aq, \*(Aq=>\*(Aq, \*(Aq2\*(Aq ]
.Ve
.Sp
But the following version:
.Sp
.Vb 1
\&    list:      \*(Aq(\*(Aq  <leftop: list_item /,|=>/ list_item>  \*(Aq)\*(Aq
.Ve
.Sp
returns only the operators:
.Sp
.Vb 1
\&    [ \*(Aqa\*(Aq, \*(Aq1\*(Aq, \*(Aqb\*(Aq, \*(Aq2\*(Aq ]
.Ve
.Sp
Of course, none of the above specifications handle the case of an empty
list, since the \f(CW\*(C`<leftop:...>\*(C'\fR and \f(CW\*(C`<rightop:...>\*(C'\fR directives
require at least a single right or left operand to match. To specify
that the operator can match \*(L"trivially\*(R",
it's necessary to add a \f(CW\*(C`(s?)\*(C'\fR qualifier to the directive:
.Sp
.Vb 1
\&    list:      \*(Aq(\*(Aq  <leftop: list_item /(,|=>)/ list_item>(s?)  \*(Aq)\*(Aq
.Ve
.Sp
Note that in almost all the above examples, the first and third arguments
of the \f(CW\*(C`<leftop:...>\*(C'\fR directive were the same subrule. That is because
\&\f(CW\*(C`<leftop:...>\*(C'\fR's are frequently used to specify \*(L"separated\*(R" lists of the
same type of item. To make such lists easier to specify, the following
syntax:
.Sp
.Vb 1
\&    list:   element(s /,/)
.Ve
.Sp
is exactly equivalent to:
.Sp
.Vb 1
\&    list:   <leftop: element /,/ element>
.Ve
.Sp
Note that the separator must be specified as a raw pattern (i.e.
not a string or subrule).
.IP "Scored productions" 4
.IX Item "Scored productions"
By default, Parse::RecDescent grammar rules always accept the first
production that matches the input. But if two or more productions may
potentially match the same input, choosing the first that does so may
not be optimal.
.Sp
For example, if you were parsing the sentence \*(L"time flies like an arrow\*(R",
you might use a rule like this:
.Sp
.Vb 3
\&    sentence: verb noun preposition article noun { [@item] }
\&    | adjective noun verb article noun   { [@item] }
\&    | noun verb preposition article noun { [@item] }
.Ve
.Sp
Each of these productions matches the sentence, but the third one
is the most likely interpretation. However, if the sentence had been
\&\*(L"fruit flies like a banana\*(R", then the second production is probably
the right match.
.Sp
To cater for such situtations, the \f(CW\*(C`<score:...>\*(C'\fR can be used.
The directive is equivalent to an unconditional \f(CW\*(C`<reject>\*(C'\fR,
except that it allows you to specify a \*(L"score\*(R" for the current
production. If that score is numerically greater than the best
score of any preceding production, the current production is cached for later
consideration. If no later production matches, then the cached
production is treated as having matched, and the value of the
item immediately before its \f(CW\*(C`<score:...>\*(C'\fR directive is returned as the
result.
.Sp
In other words, by putting a \f(CW\*(C`<score:...>\*(C'\fR directive at the end of
each production, you can select which production matches using
criteria other than specification order. For example:
.Sp
.Vb 3
\&    sentence: verb noun preposition article noun { [@item] } <score: sensible(@item)>
\&    | adjective noun verb article noun   { [@item] } <score: sensible(@item)>
\&    | noun verb preposition article noun { [@item] } <score: sensible(@item)>
.Ve
.Sp
Now, when each production reaches its respective \f(CW\*(C`<score:...>\*(C'\fR
directive, the subroutine \f(CW\*(C`sensible\*(C'\fR will be called to evaluate the
matched items (somehow). Once all productions have been tried, the
one which \f(CW\*(C`sensible\*(C'\fR scored most highly will be the one that is
accepted as a match for the rule.
.Sp
The variable \f(CW$score\fR always holds the current best score of any production,
and the variable \f(CW$score_return\fR holds the corresponding return value.
.Sp
As another example, the following grammar matches lines that may be
separated by commas, colons, or semi-colons. This can be tricky if
a colon-separated line also contains commas, or vice versa. The grammar
resolves the ambiguity by selecting the rule that results in the
fewest fields:
.Sp
.Vb 3
\&    line: seplist[sep=>\*(Aq,\*(Aq]  <score: \-@{$item[1]}>
\&    | seplist[sep=>\*(Aq:\*(Aq]  <score: \-@{$item[1]}>
\&    | seplist[sep=>" "]  <score: \-@{$item[1]}>
\&
\&    seplist: <skip:""> <leftop: /[^$arg{sep}]*/ "$arg{sep}" /[^$arg{sep}]*/>
.Ve
.Sp
Note the use of negation within the \f(CW\*(C`<score:...>\*(C'\fR directive
to ensure that the seplist with the most items gets the lowest score.
.Sp
As the above examples indicate, it is often the case that all productions
in a rule use exactly the same \f(CW\*(C`<score:...>\*(C'\fR directive. It is
tedious to have to repeat this identical directive in every production, so
Parse::RecDescent also provides the \f(CW\*(C`<autoscore:...>\*(C'\fR directive.
.Sp
If an \f(CW\*(C`<autoscore:...>\*(C'\fR directive appears in any
production of a rule, the code it specifies is used as the scoring
code for every production of that rule, except productions that already
end with an explicit \f(CW\*(C`<score:...>\*(C'\fR directive. Thus the rules above could
be rewritten:
.Sp
.Vb 4
\&    line: <autoscore: \-@{$item[1]}>
\&    line: seplist[sep=>\*(Aq,\*(Aq]
\&    | seplist[sep=>\*(Aq:\*(Aq]
\&    | seplist[sep=>" "]
\&
\&
\&    sentence: <autoscore: sensible(@item)>
\&    | verb noun preposition article noun { [@item] }
\&    | adjective noun verb article noun   { [@item] }
\&    | noun verb preposition article noun { [@item] }
.Ve
.Sp
Note that the \f(CW\*(C`<autoscore:...>\*(C'\fR directive itself acts as an
unconditional \f(CW\*(C`<reject>\*(C'\fR, and (like the \f(CW\*(C`<rulevar:...>\*(C'\fR
directive) is pruned at compile-time wherever possible.
.IP "Dispensing with grammar checks" 4
.IX Item "Dispensing with grammar checks"
During the compilation phase of parser construction, Parse::RecDescent performs
a small number of checks on the grammar it's given. Specifically it checks that
the grammar is not left-recursive, that there are no \*(L"insatiable\*(R" constructs of
the form:
.Sp
.Vb 1
\&    rule: subrule(s) subrule
.Ve
.Sp
and that there are no rules missing (i.e. referred to, but never defined).
.Sp
These checks are important during development, but can slow down parser
construction in stable code. So Parse::RecDescent provides the
<nocheck> directive to turn them off. The directive can only appear
before the first rule definition, and switches off checking throughout the rest
of the current grammar.
.Sp
Typically, this directive would be added when a parser has been thoroughly
tested and is ready for release.
.SS "Subrule argument lists"
.IX Subsection "Subrule argument lists"
It is occasionally useful to pass data to a subrule which is being invoked. For
example, consider the following grammar fragment:
.PP
.Vb 1
\&    classdecl: keyword decl
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      # WHATEVER
.Ve
.PP
The \f(CW\*(C`decl\*(C'\fR rule might wish to know which of the two keywords was used
(since it may affect some aspect of the way the subsequent declaration
is interpreted). \f(CW\*(C`Parse::RecDescent\*(C'\fR allows the grammar designer to
pass data into a rule, by placing that data in an \fIargument list\fR
(that is, in square brackets) immediately after any subrule item in a
production. Hence, we could pass the keyword to \f(CW\*(C`decl\*(C'\fR as follows:
.PP
.Vb 1
\&    classdecl: keyword decl[ $item[1] ]
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      # WHATEVER
.Ve
.PP
The argument list can consist of any number (including zero!) of comma-separated
Perl expressions. In other words, it looks exactly like a Perl anonymous
array reference. For example, we could pass the keyword, the name of the
surrounding rule, and the literal 'keyword' to \f(CW\*(C`decl\*(C'\fR like so:
.PP
.Vb 1
\&    classdecl: keyword decl[$item[1],$item[0],\*(Aqkeyword\*(Aq]
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      # WHATEVER
.Ve
.PP
Within the rule to which the data is passed (\f(CW\*(C`decl\*(C'\fR in the above examples)
that data is available as the elements of a local variable \f(CW@arg\fR. Hence
\&\f(CW\*(C`decl\*(C'\fR might report its intentions as follows:
.PP
.Vb 1
\&    classdecl: keyword decl[$item[1],$item[0],\*(Aqkeyword\*(Aq]
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      { print "Declaring $arg[0] (a $arg[2])\en";
\&         print "(this rule called by $arg[1])" }
.Ve
.PP
Subrule argument lists can also be interpreted as hashes, simply by using
the local variable \f(CW%arg\fR instead of \f(CW@arg\fR. Hence we could rewrite the
previous example:
.PP
.Vb 3
\&    classdecl: keyword decl[keyword => $item[1],
\&        caller  => $item[0],
\&        type    => \*(Aqkeyword\*(Aq]
\&
\&    keyword:   \*(Aqstruct\*(Aq | \*(Aqclass\*(Aq;
\&
\&    decl:      { print "Declaring $arg{keyword} (a $arg{type})\en";
\&         print "(this rule called by $arg{caller})" }
.Ve
.PP
Both \f(CW@arg\fR and \f(CW%arg\fR are always available, so the grammar designer may
choose whichever convention (or combination of conventions) suits best.
.PP
Subrule argument lists are also useful for creating \*(L"rule templates\*(R"
(especially when used in conjunction with the \f(CW\*(C`<matchrule:...>\*(C'\fR
directive). For example, the subrule:
.PP
.Vb 4
\&    list:     <matchrule:$arg{rule}> /$arg{sep}/ list[%arg]
\&        { $return = [ $item[1], @{$item[3]} ] }
\&    |     <matchrule:$arg{rule}>
\&        { $return = [ $item[1]] }
.Ve
.PP
is a handy template for the common problem of matching a separated list.
For example:
.PP
.Vb 1
\&    function: \*(Aqfunc\*(Aq name \*(Aq(\*(Aq list[rule=>\*(Aqparam\*(Aq,sep=>\*(Aq;\*(Aq] \*(Aq)\*(Aq
\&
\&    param:    list[rule=>\*(Aqname\*(Aq,sep=>\*(Aq,\*(Aq] \*(Aq:\*(Aq typename
\&
\&    name:     /\ew+/
\&
\&    typename: name
.Ve
.PP
When a subrule argument list is used with a repeated subrule, the argument list
goes \fIbefore\fR the repetition specifier:
.PP
.Vb 1
\&    list:   /some|many/ thing[ $item[1] ](s)
.Ve
.PP
The argument list is \*(L"late bound\*(R". That is, it is re-evaluated for every
repetition of the repeated subrule.
This means that each repeated attempt to match the subrule may be
passed a completely different set of arguments if the value of the
expression in the argument list changes between attempts. So, for
example, the grammar:
.PP
.Vb 1
\&    { $::species = \*(Aqdogs\*(Aq }
\&
\&    pair:   \*(Aqtwo\*(Aq animal[$::species](s)
\&
\&    animal: /$arg[0]/ { $::species = \*(Aqcats\*(Aq }
.Ve
.PP
will match the string \*(L"two dogs cats cats\*(R" completely, whereas
it will only match the string \*(L"two dogs dogs dogs\*(R" up to the
eighth letter. If the value of the argument list were \*(L"early bound\*(R"
(that is, evaluated only the first time a repeated subrule match is
attempted), one would expect the matching behaviours to be reversed.
.PP
Of course, it is possible to effectively \*(L"early bind\*(R" such argument lists
by passing them a value which does not change on each repetition. For example:
.PP
.Vb 1
\&    { $::species = \*(Aqdogs\*(Aq }
\&
\&    pair:   \*(Aqtwo\*(Aq { $::species } animal[$item[2]](s)
\&
\&    animal: /$arg[0]/ { $::species = \*(Aqcats\*(Aq }
.Ve
.PP
Arguments can also be passed to the start rule, simply by appending them
to the argument list with which the start rule is called (\fIafter\fR the
\&\*(L"line number\*(R" parameter). For example, given:
.PP
.Vb 1
\&    $parser = new Parse::RecDescent ( $grammar );
\&
\&    $parser\->data($text, 1, "str", 2, \e@arr);
\&
\&    #         ^^^^^  ^  ^^^^^^^^^^^^^^^
\&    #       |    |     |
\&    # TEXT TO BE PARSED  |     |
\&    # STARTING LINE NUMBER     |
\&    # ELEMENTS OF @arg WHICH IS PASSED TO RULE data
.Ve
.PP
then within the productions of the rule \f(CW\*(C`data\*(C'\fR, the array \f(CW@arg\fR will contain
\&\f(CW\*(C`("str", 2, \e@arr)\*(C'\fR.
.SS "Alternations"
.IX Subsection "Alternations"
Alternations are implicit (unnamed) rules defined as part of a production. An
alternation is defined as a series of '|'\-separated productions inside a
pair of round brackets. For example:
.PP
.Vb 1
\&    character: \*(Aqthe\*(Aq ( good | bad | ugly ) /dude/
.Ve
.PP
Every alternation implicitly defines a new subrule, whose
automatically-generated name indicates its origin:
\&\*(L"_alternation_<I>_of_production_<P>_of_rule<R>\*(R" for the appropriate
values of <I>, <P>, and <R>. A call to this implicit subrule is then
inserted in place of the brackets. Hence the above example is merely a
convenient short-hand for:
.PP
.Vb 3
\&    character: \*(Aqthe\*(Aq
\&       _alternation_1_of_production_1_of_rule_character
\&       /dude/
\&
\&    _alternation_1_of_production_1_of_rule_character:
\&       good | bad | ugly
.Ve
.PP
Since alternations are parsed by recursively calling the parser generator,
any type(s) of item can appear in an alternation. For example:
.PP
.Vb 5
\&    character: \*(Aqthe\*(Aq ( \*(Aqhigh\*(Aq "plains"  # Silent, with poncho
\&         | /no[\- ]name/ # Silent, no poncho
\&         | vengeance_seeking    # Poncho\-optional
\&         | <error>
\&         ) drifter
.Ve
.PP
In this case, if an error occurred, the automatically generated
message would be:
.PP
.Vb 3
\&    ERROR (line <N>): Invalid implicit subrule: Expected
\&          \*(Aqhigh\*(Aq or /no[\- ]name/ or generic,
\&          but found "pacifist" instead
.Ve
.PP
Since every alternation actually has a name, it's even possible
to extend or replace them:
.PP
.Vb 4
\&    parser\->Replace(
\&    "_alternation_1_of_production_1_of_rule_character:
\&        \*(Aqgeneric Eastwood\*(Aq"
\&        );
.Ve
.PP
More importantly, since alternations are a form of subrule, they can be given
repetition specifiers:
.PP
.Vb 1
\&    character: \*(Aqthe\*(Aq ( good | bad | ugly )(?) /dude/
.Ve
.SS "Incremental Parsing"
.IX Subsection "Incremental Parsing"
\&\f(CW\*(C`Parse::RecDescent\*(C'\fR provides two methods \- \f(CW\*(C`Extend\*(C'\fR and \f(CW\*(C`Replace\*(C'\fR \- which
can be used to alter the grammar matched by a parser. Both methods
take the same argument as \f(CW\*(C`Parse::RecDescent::new\*(C'\fR, namely a
grammar specification string
.PP
\&\f(CW\*(C`Parse::RecDescent::Extend\*(C'\fR interprets the grammar specification and adds any
productions it finds to the end of the rules for which they are specified. For
example:
.PP
.Vb 2
\&    $add = "name: \*(AqJimmy\-Bob\*(Aq | \*(AqBobby\-Jim\*(Aq\endesc: colour /necks?/";
\&    parser\->Extend($add);
.Ve
.PP
adds two productions to the rule \*(L"name\*(R" (creating it if necessary) and one
production to the rule \*(L"desc\*(R".
.PP
\&\f(CW\*(C`Parse::RecDescent::Replace\*(C'\fR is identical, except that it first resets are
rule specified in the additional grammar, removing any existing productions.
Hence after:
.PP
.Vb 2
\&    $add = "name: \*(AqJimmy\-Bob\*(Aq | \*(AqBobby\-Jim\*(Aq\endesc: colour /necks?/";
\&    parser\->Replace($add);
.Ve
.PP
are are \fIonly\fR valid \*(L"name\*(R"s and the one possible description.
.PP
A more interesting use of the \f(CW\*(C`Extend\*(C'\fR and \f(CW\*(C`Replace\*(C'\fR methods is to call them
inside the action of an executing parser. For example:
.PP
.Vb 3
\&    typedef: \*(Aqtypedef\*(Aq type_name identifier \*(Aq;\*(Aq
\&           { $thisparser\->Extend("type_name: \*(Aq$item[3]\*(Aq") }
\&       | <error>
\&
\&    identifier: ...!type_name /[A\-Za\-z_]w*/
.Ve
.PP
which automatically prevents type names from being typedef'd, or:
.PP
.Vb 6
\&    command: \*(Aqmap\*(Aq key_name \*(Aqto\*(Aq abort_key
\&           { $thisparser\->Replace("abort_key: \*(Aq$item[2]\*(Aq") }
\&       | \*(Aqmap\*(Aq key_name \*(Aqto\*(Aq key_name
\&           { map_key($item[2],$item[4]) }
\&       | abort_key
\&           { exit if confirm("abort?") }
\&
\&    abort_key: \*(Aqq\*(Aq
\&
\&    key_name: ...!abort_key /[A\-Za\-z]/
.Ve
.PP
which allows the user to change the abort key binding, but not to unbind it.
.PP
The careful use of such constructs makes it possible to reconfigure a
a running parser, eliminating the need for semantic feedback by
providing syntactic feedback instead. However, as currently implemented,
\&\f(CW\*(C`Replace()\*(C'\fR and \f(CW\*(C`Extend()\*(C'\fR have to regenerate and re\-\f(CW\*(C`eval\*(C'\fR the
entire parser whenever they are called. This makes them quite slow for
large grammars.
.PP
In such cases, the judicious use of an interpolated regex is likely to
be far more efficient:
.PP
.Vb 3
\&    typedef: \*(Aqtypedef\*(Aq type_name/ identifier \*(Aq;\*(Aq
\&           { $thisparser\->{local}{type_name} .= "|$item[3]" }
\&       | <error>
\&
\&    identifier: ...!type_name /[A\-Za\-z_]w*/
\&
\&    type_name: /$thisparser\->{local}{type_name}/
.Ve
.SS "Precompiling parsers"
.IX Subsection "Precompiling parsers"
Normally Parse::RecDescent builds a parser from a grammar at run-time.
That approach simplifies the design and implementation of parsing code,
but has the disadvantage that it slows the parsing process down \- you
have to wait for Parse::RecDescent to build the parser every time the
program runs. Long or complex grammars can be particularly slow to
build, leading to unacceptable delays at start-up.
.PP
To overcome this, the module provides a way of \*(L"pre-building\*(R" a parser
object and saving it in a separate module. That module can then be used
to create clones of the original parser.
.PP
A grammar may be precompiled using the \f(CW\*(C`Precompile\*(C'\fR class method.
For example, to precompile a grammar stored in the scalar \f(CW$grammar\fR,
and produce a class named PreGrammar in a module file named PreGrammar.pm,
you could use:
.PP
.Vb 1
\&    use Parse::RecDescent;
\&
\&    Parse::RecDescent\->Precompile([$options_hashref], $grammar, "PreGrammar");
.Ve
.PP
The first required argument is the grammar string, the second is the
name of the class to be built. The name of the module file is
generated automatically by appending \*(L".pm\*(R" to the last element of the
class name. Thus
.PP
.Vb 1
\&    Parse::RecDescent\->Precompile($grammar, "My::New::Parser");
.Ve
.PP
would produce a module file named Parser.pm.
.PP
An optional hash reference may be supplied as the first argument to
\&\f(CW\*(C`Precompile\*(C'\fR.  This argument is currently \s-1EXPERIMENTAL,\s0 and may change
in a future release of Parse::RecDescent.  The only supported option
is currently \f(CW\*(C`\-standalone\*(C'\fR, see \*(L"Standalone Precompiled Parsers\*(R".
.PP
It is somewhat tedious to have to write a small Perl program just to
generate a precompiled grammar class, so Parse::RecDescent has some special
magic that allows you to do the job directly from the command-line.
.PP
If your grammar is specified in a file named \fIgrammar\fR, you can generate
a class named Yet::Another::Grammar like so:
.PP
.Vb 1
\&    > perl \-MParse::RecDescent \- grammar Yet::Another::Grammar
.Ve
.PP
This would produce a file named \fIGrammar.pm\fR containing the full
definition of a class called Yet::Another::Grammar. Of course, to use
that class, you would need to put the \fIGrammar.pm\fR file in a
directory named \fIYet/Another\fR, somewhere in your Perl include path.
.PP
Having created the new class, it's very easy to use it to build
a parser. You simply \f(CW\*(C`use\*(C'\fR the new module, and then call its
\&\f(CW\*(C`new\*(C'\fR method to create a parser object. For example:
.PP
.Vb 2
\&    use Yet::Another::Grammar;
\&    my $parser = Yet::Another::Grammar\->new();
.Ve
.PP
The effect of these two lines is exactly the same as:
.PP
.Vb 1
\&    use Parse::RecDescent;
\&
\&    open GRAMMAR_FILE, "grammar" or die;
\&    local $/;
\&    my $grammar = <GRAMMAR_FILE>;
\&
\&    my $parser = Parse::RecDescent\->new($grammar);
.Ve
.PP
only considerably faster.
.PP
Note however that the parsers produced by either approach are exactly
the same, so whilst precompilation has an effect on \fIset-up\fR speed,
it has no effect on \fIparsing\fR speed. RecDescent 2.0 will address that
problem.
.PP
\fIStandalone Precompiled Parsers\fR
.IX Subsection "Standalone Precompiled Parsers"
.PP
Until version 1.967003 of Parse::RecDescent, parser modules built with
\&\f(CW\*(C`Precompile\*(C'\fR were dependent on Parse::RecDescent.  Future
Parse::RecDescent releases with different internal implementations
would break pre-existing precompiled parsers.
.PP
Version 1.967_005 added the ability for Parse::RecDescent to include
itself in the resulting .pm file if you pass the boolean option
\&\f(CW\*(C`\-standalone\*(C'\fR to \f(CW\*(C`Precompile\*(C'\fR:
.PP
.Vb 2
\&    Parse::RecDescent\->Precompile({ \-standalone = 1, },
\&        $grammar, "My::New::Parser");
.Ve
.PP
Parse::RecDescent is included as Parse::RecDescent::_Runtime in order
to avoid conflicts between an installed version of Parse::RecDescent
and a precompiled, standalone parser made with another version of
Parse::RecDescent.  This renaming is experimental, and is subject to
change in future versions.
.PP
Precompiled parsers remain dependent on Parse::RecDescent by default,
as this feature is still considered experimental.  In the future,
standalone parsers will become the default.
.SH "GOTCHAS"
.IX Header "GOTCHAS"
This section describes common mistakes that grammar writers seem to
make on a regular basis.
.SS "1. Expecting an error to always invalidate a parse"
.IX Subsection "1. Expecting an error to always invalidate a parse"
A common mistake when using error messages is to write the grammar like this:
.PP
.Vb 1
\&    file: line(s)
\&
\&    line: line_type_1
\&    | line_type_2
\&    | line_type_3
\&    | <error>
.Ve
.PP
The expectation seems to be that any line that is not of type 1, 2 or 3 will
invoke the \f(CW\*(C`<error>\*(C'\fR directive and thereby cause the parse to fail.
.PP
Unfortunately, that only happens if the error occurs in the very first line.
The first rule states that a \f(CW\*(C`file\*(C'\fR is matched by one or more lines, so if
even a single line succeeds, the first rule is completely satisfied and the
parse as a whole succeeds. That means that any error messages generated by
subsequent failures in the \f(CW\*(C`line\*(C'\fR rule are quietly ignored.
.PP
Typically what's really needed is this:
.PP
.Vb 1
\&    file: line(s) eofile    { $return = $item[1] }
\&
\&    line: line_type_1
\&    | line_type_2
\&    | line_type_3
\&    | <error>
\&
\&    eofile: /^\eZ/
.Ve
.PP
The addition of the \f(CW\*(C`eofile\*(C'\fR subrule  to the first production means that
a file only matches a series of successful \f(CW\*(C`line\*(C'\fR matches \fIthat consume the
complete input text\fR. If any input text remains after the lines are matched,
there must have been an error in the last \f(CW\*(C`line\*(C'\fR. In that case the \f(CW\*(C`eofile\*(C'\fR
rule will fail, causing the entire \f(CW\*(C`file\*(C'\fR rule to fail too.
.PP
Note too that \f(CW\*(C`eofile\*(C'\fR must match \f(CW\*(C`/^\eZ/\*(C'\fR (end-of-text), \fInot\fR
\&\f(CW\*(C`/^\ecZ/\*(C'\fR or \f(CW\*(C`/^\ecD/\*(C'\fR (end-of-file).
.PP
And don't forget the action at the end of the production. If you just
write:
.PP
.Vb 1
\&    file: line(s) eofile
.Ve
.PP
then the value returned by the \f(CW\*(C`file\*(C'\fR rule will be the value of its
last item: \f(CW\*(C`eofile\*(C'\fR. Since \f(CW\*(C`eofile\*(C'\fR always returns an empty string
on success, that will cause the \f(CW\*(C`file\*(C'\fR rule to return that empty
string. Apart from returning the wrong value, returning an empty string
will trip up code such as:
.PP
.Vb 1
\&    $parser\->file($filetext) || die;
.Ve
.PP
(since "" is false).
.PP
Remember that Parse::RecDescent returns undef on failure,
so the only safe test for failure is:
.PP
.Vb 1
\&    defined($parser\->file($filetext)) || die;
.Ve
.ie n .SS "2. Using a ""return"" in an action"
.el .SS "2. Using a \f(CWreturn\fP in an action"
.IX Subsection "2. Using a return in an action"
An action is like a \f(CW\*(C`do\*(C'\fR block inside the subroutine implementing the
surrounding rule. So if you put a \f(CW\*(C`return\*(C'\fR statement in an action:
.PP
.Vb 3
\&    range: \*(Aq(\*(Aq start \*(Aq..\*(Aq end )\*(Aq
\&        { return $item{end} }
\&       /\es+/
.Ve
.PP
that subroutine will immediately return, without checking the rest of
the items in the current production (e.g. the \f(CW\*(C`/\es+/\*(C'\fR) and without
setting up the necessary data structures to tell the parser that the
rule has succeeded.
.PP
The correct way to set a return value in an action is to set the \f(CW$return\fR
variable:
.PP
.Vb 3
\&    range: \*(Aq(\*(Aq start \*(Aq..\*(Aq end )\*(Aq
\&                { $return = $item{end} }
\&           /\es+/
.Ve
.ie n .SS "2. Setting $Parse::RecDescent::skip at parse time"
.el .SS "2. Setting \f(CW$Parse::RecDescent::skip\fP at parse time"
.IX Subsection "2. Setting $Parse::RecDescent::skip at parse time"
If you want to change the default skipping behaviour (see
\&\*(L"Terminal Separators\*(R" and the \f(CW\*(C`<skip:...>\*(C'\fR directive) by setting
\&\f(CW$Parse::RecDescent::skip\fR you have to remember to set this variable
\&\fIbefore\fR creating the grammar object.
.PP
For example, you might want to skip all Perl-like comments with this
regular expression:
.PP
.Vb 6
\&   my $skip_spaces_and_comments = qr/
\&         (?mxs:
\&            \es+         # either spaces
\&            | \e# .*?$   # or a dash and whatever up to the end of line
\&         )*             # repeated at will (in whatever order)
\&      /;
.Ve
.PP
And then:
.PP
.Vb 1
\&   my $parser1 = Parse::RecDescent\->new($grammar);
\&
\&   $Parse::RecDescent::skip = $skip_spaces_and_comments;
\&
\&   my $parser2 = Parse::RecDescent\->new($grammar);
\&
\&   $parser1\->parse($text); # this does not cope with comments
\&   $parser2\->parse($text); # this skips comments correctly
.Ve
.PP
The two parsers behave differently, because any skipping behaviour
specified via \f(CW$Parse::RecDescent::skip\fR is hard-coded when the
grammar object is built, not at parse time.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
Diagnostics are intended to be self-explanatory (particularly if you
use \fB\-RD_HINT\fR (under \fBperl \-s\fR) or define \f(CW$::RD_HINT\fR inside the program).
.PP
\&\f(CW\*(C`Parse::RecDescent\*(C'\fR currently diagnoses the following:
.IP "\(bu" 4
Invalid regular expressions used as pattern terminals (fatal error).
.IP "\(bu" 4
Invalid Perl code in code blocks (fatal error).
.IP "\(bu" 4
Lookahead used in the wrong place or in a nonsensical way (fatal error).
.IP "\(bu" 4
\&\*(L"Obvious\*(R" cases of left-recursion (fatal error).
.IP "\(bu" 4
Missing or extra components in a \f(CW\*(C`<leftop>\*(C'\fR or \f(CW\*(C`<rightop>\*(C'\fR
directive.
.IP "\(bu" 4
Unrecognisable components in the grammar specification (fatal error).
.IP "\(bu" 4
\&\*(L"Orphaned\*(R" rule components specified before the first rule (fatal error)
or after an \f(CW\*(C`<error>\*(C'\fR directive (level 3 warning).
.IP "\(bu" 4
Missing rule definitions (this only generates a level 3 warning, since you
may be providing them later via \f(CW\*(C`Parse::RecDescent::Extend()\*(C'\fR).
.IP "\(bu" 4
Instances where greedy repetition behaviour will almost certainly
cause the failure of a production (a level 3 warning \- see
\&\*(L"ON-GOING \s-1ISSUES AND FUTURE DIRECTIONS\*(R"\s0 below).
.IP "\(bu" 4
Attempts to define rules named 'Replace' or 'Extend', which cannot be
called directly through the parser object because of the predefined
meaning of \f(CW\*(C`Parse::RecDescent::Replace\*(C'\fR and
\&\f(CW\*(C`Parse::RecDescent::Extend\*(C'\fR. (Only a level 2 warning is generated, since
such rules \fIcan\fR still be used as subrules).
.IP "\(bu" 4
Productions which consist of a single \f(CW\*(C`<error?>\*(C'\fR
directive, and which therefore may succeed unexpectedly
(a level 2 warning, since this might conceivably be the desired effect).
.IP "\(bu" 4
Multiple consecutive lookahead specifiers (a level 1 warning only, since their
effects simply accumulate).
.IP "\(bu" 4
Productions which start with a \f(CW\*(C`<reject>\*(C'\fR or \f(CW\*(C`<rulevar:...>\*(C'\fR
directive. Such productions are optimized away (a level 1 warning).
.IP "\(bu" 4
Rules which are autogenerated under \f(CW$::AUTOSTUB\fR (a level 1 warning).
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
Jeremy T. Braun (JTBRAUN@CPAN.org) [current maintainer]
.SH "BUGS AND IRRITATIONS"
.IX Header "BUGS AND IRRITATIONS"
There are undoubtedly serious bugs lurking somewhere in this much code :\-)
Bug reports, test cases and other feedback are most welcome.
.PP
Ongoing annoyances include:
.IP "\(bu" 4
There's no support for parsing directly from an input stream.
If and when the Perl Gods give us regular expressions on streams,
this should be trivial (ahem!) to implement.
.IP "\(bu" 4
The parser generator can get confused if actions aren't properly
closed or if they contain particularly nasty Perl syntax errors
(especially unmatched curly brackets).
.IP "\(bu" 4
The generator only detects the most obvious form of left recursion
(potential recursion on the first subrule in a rule). More subtle
forms of left recursion (for example, through the second item in a
rule after a \*(L"zero\*(R" match of a preceding \*(L"zero-or-more\*(R" repetition,
or after a match of a subrule with an empty production) are not found.
.IP "\(bu" 4
Instead of complaining about left-recursion, the generator should
silently transform the grammar to remove it. Don't expect this
feature any time soon as it would require a more sophisticated
approach to parser generation than is currently used.
.IP "\(bu" 4
The generated parsers don't always run as fast as might be wished.
.IP "\(bu" 4
The meta-parser should be bootstrapped using \f(CW\*(C`Parse::RecDescent\*(C'\fR :\-)
.SH "ON-GOING ISSUES AND FUTURE DIRECTIONS"
.IX Header "ON-GOING ISSUES AND FUTURE DIRECTIONS"
.IP "1." 4
Repetitions are \*(L"incorrigibly greedy\*(R" in that they will eat everything they can
and won't backtrack if that behaviour causes a production to fail needlessly.
So, for example:
.Sp
.Vb 1
\&    rule: subrule(s) subrule
.Ve
.Sp
will \fInever\fR succeed, because the repetition will eat all the
subrules it finds, leaving none to match the second item. Such
constructions are relatively rare (and \f(CW\*(C`Parse::RecDescent::new\*(C'\fR generates a
warning whenever they occur) so this may not be a problem, especially
since the insatiable behaviour can be overcome \*(L"manually\*(R" by writing:
.Sp
.Vb 1
\&    rule: penultimate_subrule(s) subrule
\&
\&    penultimate_subrule: subrule ...subrule
.Ve
.Sp
The issue is that this construction is exactly twice as expensive as the
original, whereas backtracking would add only 1/\fIN\fR to the cost (for
matching \fIN\fR repetitions of \f(CW\*(C`subrule\*(C'\fR). I would welcome feedback on
the need for backtracking; particularly on cases where the lack of it
makes parsing performance problematical.
.IP "2." 4
Having opened that can of worms, it's also necessary to consider whether there
is a need for non-greedy repetition specifiers. Again, it's possible (at some
cost) to manually provide the required functionality:
.Sp
.Vb 1
\&    rule: nongreedy_subrule(s) othersubrule
\&
\&    nongreedy_subrule: subrule ...!othersubrule
.Ve
.Sp
Overall, the issue is whether the benefit of this extra functionality
outweighs the drawbacks of further complicating the (currently
minimalist) grammar specification syntax, and (worse) introducing more overhead
into the generated parsers.
.IP "3." 4
An \f(CW\*(C`<autocommit>\*(C'\fR directive would be nice. That is, it would be useful to be
able to say:
.Sp
.Vb 7
\&    command: <autocommit>
\&    command: \*(Aqfind\*(Aq name
\&       | \*(Aqfind\*(Aq address
\&       | \*(Aqdo\*(Aq command \*(Aqat\*(Aq time \*(Aqif\*(Aq condition
\&       | \*(Aqdo\*(Aq command \*(Aqat\*(Aq time
\&       | \*(Aqdo\*(Aq command
\&       | unusual_command
.Ve
.Sp
and have the generator work out that this should be \*(L"pruned\*(R" thus:
.Sp
.Vb 9
\&    command: \*(Aqfind\*(Aq name
\&       | \*(Aqfind\*(Aq <commit> address
\&       | \*(Aqdo\*(Aq <commit> command <uncommit>
\&        \*(Aqat\*(Aq time
\&        \*(Aqif\*(Aq <commit> condition
\&       | \*(Aqdo\*(Aq <commit> command <uncommit>
\&        \*(Aqat\*(Aq <commit> time
\&       | \*(Aqdo\*(Aq <commit> command
\&       | unusual_command
.Ve
.Sp
There are several issues here. Firstly, should the
\&\f(CW\*(C`<autocommit>\*(C'\fR automatically install an \f(CW\*(C`<uncommit>\*(C'\fR
at the start of the last production (on the grounds that the \*(L"command\*(R"
rule doesn't know whether an \*(L"unusual_command\*(R" might start with \*(L"find\*(R"
or \*(L"do\*(R") or should the \*(L"unusual_command\*(R" subgraph be analysed (to see
if it \fImight\fR be viable after a \*(L"find\*(R" or \*(L"do\*(R")?
.Sp
The second issue is how regular expressions should be treated. The simplest
approach would be simply to uncommit before them (on the grounds that they
\&\fImight\fR match). Better efficiency would be obtained by analyzing all preceding
literal tokens to determine whether the pattern would match them.
.Sp
Overall, the issues are: can such automated \*(L"pruning\*(R" approach a hand-tuned
version sufficiently closely to warrant the extra set-up expense, and (more
importantly) is the problem important enough to even warrant the non-trivial
effort of building an automated solution?
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Source Code Repository"
.IX Subsection "Source Code Repository"
<http://github.com/jtbraun/Parse\-RecDescent>
.SS "Mailing List"
.IX Subsection "Mailing List"
Visit <http://www.perlfoundation.org/perl5/index.cgi?parse_recdescent> to sign up for the mailing list.
.PP
<http://www.PerlMonks.org> is also a good place to ask
questions. Previous posts about Parse::RecDescent can typically be
found with this search:
<http://perlmonks.org/index.pl?node=recdescent>.
.SS "\s-1FAQ\s0"
.IX Subsection "FAQ"
Visit Parse::RecDescent::FAQ for answers to frequently (and not so
frequently) asked questions about Parse::RecDescent.
.SS "View/Report Bugs"
.IX Subsection "View/Report Bugs"
To view the current bug list or report a new issue visit
<https://rt.cpan.org/Public/Dist/Display.html?Name=Parse\-RecDescent>.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Regexp::Grammars provides Parse::RecDescent style parsing using native
Perl 5.10 regular expressions.
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 1997\-2007, Damian Conway \f(CW\*(C`<DCONWAY@CPAN.org>\*(C'\fR. All rights
reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
\&\s-1BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE \*(L"AS IS\*(R" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR, OR CORRECTION.\s0
.PP
\&\s-1IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
THE SOFTWARE \s0(\s-1INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE\s0), \s-1EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.\s0
                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Path::Class.3pm                              0100644 0001750 0001750 00000023277 12566242307 023361  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Path::Class 3"
.TH Path::Class 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Path::Class \- Cross\-platform path specification manipulation
.SH "VERSION"
.IX Header "VERSION"
version 0.33
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Path::Class;
\&  
\&  my $dir  = dir(\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq);       # Path::Class::Dir object
\&  my $file = file(\*(Aqbob\*(Aq, \*(Aqfile.txt\*(Aq); # Path::Class::File object
\&  
\&  # Stringifies to \*(Aqfoo/bar\*(Aq on Unix, \*(Aqfoo\ebar\*(Aq on Windows, etc.
\&  print "dir: $dir\en";
\&  
\&  # Stringifies to \*(Aqbob/file.txt\*(Aq on Unix, \*(Aqbob\efile.txt\*(Aq on Windows
\&  print "file: $file\en";
\&  
\&  my $subdir  = $dir\->subdir(\*(Aqbaz\*(Aq);  # foo/bar/baz
\&  my $parent  = $subdir\->parent;      # foo/bar
\&  my $parent2 = $parent\->parent;      # foo
\&  
\&  my $dir2 = $file\->dir;              # bob
\&
\&  # Work with foreign paths
\&  use Path::Class qw(foreign_file foreign_dir);
\&  my $file = foreign_file(\*(AqMac\*(Aq, \*(Aq:foo:file.txt\*(Aq);
\&  print $file\->dir;                   # :foo:
\&  print $file\->as_foreign(\*(AqWin32\*(Aq);   # foo\efile.txt
\&  
\&  # Interact with the underlying filesystem:
\&  
\&  # $dir_handle is an IO::Dir object
\&  my $dir_handle = $dir\->open or die "Can\*(Aqt read $dir: $!";
\&  
\&  # $file_handle is an IO::File object
\&  my $file_handle = $file\->open($mode) or die "Can\*(Aqt read $file: $!";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Path::Class\*(C'\fR is a module for manipulation of file and directory
specifications (strings describing their locations, like
\&\f(CW\*(Aq/home/ken/foo.txt\*(Aq\fR or \f(CW\*(AqC:\eWindows\eFoo.txt\*(Aq\fR) in a cross-platform
manner.  It supports pretty much every platform Perl runs on,
including Unix, Windows, Mac, \s-1VMS,\s0 Epoc, Cygwin, \s-1OS/2,\s0 and NetWare.
.PP
The well-known module File::Spec also provides this service, but
it's sort of awkward to use well, so people sometimes avoid it, or use
it in a way that won't actually work properly on platforms
significantly different than the ones they've tested their code on.
.PP
In fact, \f(CW\*(C`Path::Class\*(C'\fR uses \f(CW\*(C`File::Spec\*(C'\fR internally, wrapping all
the unsightly details so you can concentrate on your application code.
Whereas \f(CW\*(C`File::Spec\*(C'\fR provides functions for some common path
manipulations, \f(CW\*(C`Path::Class\*(C'\fR provides an object-oriented model of the
world of path specifications and their underlying semantics.
\&\f(CW\*(C`File::Spec\*(C'\fR doesn't create any objects, and its classes represent
the different ways in which paths must be manipulated on various
platforms (not a very intuitive concept).  \f(CW\*(C`Path::Class\*(C'\fR creates
objects representing files and directories, and provides methods that
relate them to each other.  For instance, the following \f(CW\*(C`File::Spec\*(C'\fR
code:
.PP
.Vb 3
\& my $absolute = File::Spec\->file_name_is_absolute(
\&                  File::Spec\->catfile( @dirs, $file )
\&                );
.Ve
.PP
can be written using \f(CW\*(C`Path::Class\*(C'\fR as
.PP
.Vb 1
\& my $absolute = Path::Class::File\->new( @dirs, $file )\->is_absolute;
.Ve
.PP
or even as
.PP
.Vb 1
\& my $absolute = file( @dirs, $file )\->is_absolute;
.Ve
.PP
Similar readability improvements should happen all over the place when
using \f(CW\*(C`Path::Class\*(C'\fR.
.PP
Using \f(CW\*(C`Path::Class\*(C'\fR can help solve real problems in your code too \-
for instance, how many people actually take the \*(L"volume\*(R" (like \f(CW\*(C`C:\*(C'\fR
on Windows) into account when writing \f(CW\*(C`File::Spec\*(C'\fR\-using code?  I
thought not.  But if you use \f(CW\*(C`Path::Class\*(C'\fR, your file and directory objects
will know what volumes they refer to and do the right thing.
.PP
The guts of the \f(CW\*(C`Path::Class\*(C'\fR code live in the Path::Class::File
and Path::Class::Dir modules, so please see those
modules' documentation for more details about how to use them.
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
The following functions are exported by default.
.IP "file" 4
.IX Item "file"
A synonym for \f(CW\*(C`Path::Class::File\->new\*(C'\fR.
.IP "dir" 4
.IX Item "dir"
A synonym for \f(CW\*(C`Path::Class::Dir\->new\*(C'\fR.
.PP
If you would like to prevent their export, you may explicitly pass an
empty list to perl's \f(CW\*(C`use\*(C'\fR, i.e. \f(CW\*(C`use Path::Class ()\*(C'\fR.
.PP
The following are exported only on demand.
.IP "foreign_file" 4
.IX Item "foreign_file"
A synonym for \f(CW\*(C`Path::Class::File\->new_foreign\*(C'\fR.
.IP "foreign_dir" 4
.IX Item "foreign_dir"
A synonym for \f(CW\*(C`Path::Class::Dir\->new_foreign\*(C'\fR.
.IP "tempdir" 4
.IX Item "tempdir"
Create a new Path::Class::Dir instance pointed to temporary directory.
.Sp
.Vb 1
\&  my $temp = Path::Class::tempdir(CLEANUP => 1);
.Ve
.Sp
A synonym for \f(CW\*(C`Path::Class::Dir\->new(File::Temp::tempdir(@_))\*(C'\fR.
.SH "Notes on Cross-Platform Compatibility"
.IX Header "Notes on Cross-Platform Compatibility"
Although it is much easier to write cross-platform-friendly code with
this module than with \f(CW\*(C`File::Spec\*(C'\fR, there are still some issues to be
aware of.
.IP "\(bu" 4
On some platforms, notably \s-1VMS\s0 and some older versions of \s-1DOS \s0(I think),
all filenames must have an extension.  Thus if you create a file
called \fIfoo/bar\fR and then ask for a list of files in the directory
\&\fIfoo\fR, you may find a file called \fIbar.\fR instead of the \fIbar\fR you
were expecting.  Thus it might be a good idea to use an extension in
the first place.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ken Williams, KWILLIAMS@cpan.org
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) Ken Williams.  All rights reserved.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Path::Class::Dir, Path::Class::File, File::Spec
                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Path::Class5.16.3pm                          0100644 0001750 0001750 00000022444 12566242311 023661  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Path::Class 3"
.TH Path::Class 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Path::Class \- Cross\-platform path specification manipulation
.SH "VERSION"
.IX Header "VERSION"
version 0.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Path::Class;
\&  
\&  my $dir  = dir(\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq);       # Path::Class::Dir object
\&  my $file = file(\*(Aqbob\*(Aq, \*(Aqfile.txt\*(Aq); # Path::Class::File object
\&  
\&  # Stringifies to \*(Aqfoo/bar\*(Aq on Unix, \*(Aqfoo\ebar\*(Aq on Windows, etc.
\&  print "dir: $dir\en";
\&  
\&  # Stringifies to \*(Aqbob/file.txt\*(Aq on Unix, \*(Aqbob\efile.txt\*(Aq on Windows
\&  print "file: $file\en";
\&  
\&  my $subdir  = $dir\->subdir(\*(Aqbaz\*(Aq);  # foo/bar/baz
\&  my $parent  = $subdir\->parent;      # foo/bar
\&  my $parent2 = $parent\->parent;      # foo
\&  
\&  my $dir2 = $file\->dir;              # bob
\&
\&  # Work with foreign paths
\&  use Path::Class qw(foreign_file foreign_dir);
\&  my $file = foreign_file(\*(AqMac\*(Aq, \*(Aq:foo:file.txt\*(Aq);
\&  print $file\->dir;                   # :foo:
\&  print $file\->as_foreign(\*(AqWin32\*(Aq);   # foo\efile.txt
\&  
\&  # Interact with the underlying filesystem:
\&  
\&  # $dir_handle is an IO::Dir object
\&  my $dir_handle = $dir\->open or die "Can\*(Aqt read $dir: $!";
\&  
\&  # $file_handle is an IO::File object
\&  my $file_handle = $file\->open($mode) or die "Can\*(Aqt read $file: $!";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Path::Class\*(C'\fR is a module for manipulation of file and directory
specifications (strings describing their locations, like
\&\f(CW\*(Aq/home/ken/foo.txt\*(Aq\fR or \f(CW\*(AqC:\eWindows\eFoo.txt\*(Aq\fR) in a cross-platform
manner.  It supports pretty much every platform Perl runs on,
including Unix, Windows, Mac, \s-1VMS\s0, Epoc, Cygwin, \s-1OS/2\s0, and NetWare.
.PP
The well-known module \f(CW\*(C`File::Spec\*(C'\fR also provides this service, but
it's sort of awkward to use well, so people sometimes avoid it, or use
it in a way that won't actually work properly on platforms
significantly different than the ones they've tested their code on.
.PP
In fact, \f(CW\*(C`Path::Class\*(C'\fR uses \f(CW\*(C`File::Spec\*(C'\fR internally, wrapping all
the unsightly details so you can concentrate on your application code.
Whereas \f(CW\*(C`File::Spec\*(C'\fR provides functions for some common path
manipulations, \f(CW\*(C`Path::Class\*(C'\fR provides an object-oriented model of the
world of path specifications and their underlying semantics.
\&\f(CW\*(C`File::Spec\*(C'\fR doesn't create any objects, and its classes represent
the different ways in which paths must be manipulated on various
platforms (not a very intuitive concept).  \f(CW\*(C`Path::Class\*(C'\fR creates
objects representing files and directories, and provides methods that
relate them to each other.  For instance, the following \f(CW\*(C`File::Spec\*(C'\fR
code:
.PP
.Vb 3
\& my $absolute = File::Spec\->file_name_is_absolute(
\&                  File::Spec\->catfile( @dirs, $file )
\&                );
.Ve
.PP
can be written using \f(CW\*(C`Path::Class\*(C'\fR as
.PP
.Vb 1
\& my $absolute = Path::Class::File\->new( @dirs, $file )\->is_absolute;
.Ve
.PP
or even as
.PP
.Vb 1
\& my $absolute = file( @dirs, $file )\->is_absolute;
.Ve
.PP
Similar readability improvements should happen all over the place when
using \f(CW\*(C`Path::Class\*(C'\fR.
.PP
Using \f(CW\*(C`Path::Class\*(C'\fR can help solve real problems in your code too \-
for instance, how many people actually take the \*(L"volume\*(R" (like \f(CW\*(C`C:\*(C'\fR
on Windows) into account when writing \f(CW\*(C`File::Spec\*(C'\fR\-using code?  I
thought not.  But if you use \f(CW\*(C`Path::Class\*(C'\fR, your file and directory objects
will know what volumes they refer to and do the right thing.
.PP
The guts of the \f(CW\*(C`Path::Class\*(C'\fR code live in the \f(CW\*(C`Path::Class::File\*(C'\fR
and \f(CW\*(C`Path::Class::Dir\*(C'\fR modules, so please see those
modules' documentation for more details about how to use them.
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
The following functions are exported by default.
.IP "file" 4
.IX Item "file"
A synonym for \f(CW\*(C`Path::Class::File\->new\*(C'\fR.
.IP "dir" 4
.IX Item "dir"
A synonym for \f(CW\*(C`Path::Class::Dir\->new\*(C'\fR.
.PP
If you would like to prevent their export, you may explicitly pass an
empty list to perl's \f(CW\*(C`use\*(C'\fR, i.e. \f(CW\*(C`use Path::Class ()\*(C'\fR.
.PP
The following are exported only on demand.
.IP "foreign_file" 4
.IX Item "foreign_file"
A synonym for \f(CW\*(C`Path::Class::File\->new_foreign\*(C'\fR.
.IP "foreign_dir" 4
.IX Item "foreign_dir"
A synonym for \f(CW\*(C`Path::Class::Dir\->new_foreign\*(C'\fR.
.SH "Notes on Cross-Platform Compatibility"
.IX Header "Notes on Cross-Platform Compatibility"
Although it is much easier to write cross-platform-friendly code with
this module than with \f(CW\*(C`File::Spec\*(C'\fR, there are still some issues to be
aware of.
.IP "\(bu" 4
On some platforms, notably \s-1VMS\s0 and some older versions of \s-1DOS\s0 (I think),
all filenames must have an extension.  Thus if you create a file
called \fIfoo/bar\fR and then ask for a list of files in the directory
\&\fIfoo\fR, you may find a file called \fIbar.\fR instead of the \fIbar\fR you
were expecting.  Thus it might be a good idea to use an extension in
the first place.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ken Williams, KWILLIAMS@cpan.org
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) Ken Williams.  All rights reserved.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Path::Class::Dir, Path::Class::File, File::Spec
                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Path::Class5.18.3pm                          0100644 0001750 0001750 00000023277 12566242307 023675  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Path::Class 3"
.TH Path::Class 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Path::Class \- Cross\-platform path specification manipulation
.SH "VERSION"
.IX Header "VERSION"
version 0.33
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Path::Class;
\&  
\&  my $dir  = dir(\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq);       # Path::Class::Dir object
\&  my $file = file(\*(Aqbob\*(Aq, \*(Aqfile.txt\*(Aq); # Path::Class::File object
\&  
\&  # Stringifies to \*(Aqfoo/bar\*(Aq on Unix, \*(Aqfoo\ebar\*(Aq on Windows, etc.
\&  print "dir: $dir\en";
\&  
\&  # Stringifies to \*(Aqbob/file.txt\*(Aq on Unix, \*(Aqbob\efile.txt\*(Aq on Windows
\&  print "file: $file\en";
\&  
\&  my $subdir  = $dir\->subdir(\*(Aqbaz\*(Aq);  # foo/bar/baz
\&  my $parent  = $subdir\->parent;      # foo/bar
\&  my $parent2 = $parent\->parent;      # foo
\&  
\&  my $dir2 = $file\->dir;              # bob
\&
\&  # Work with foreign paths
\&  use Path::Class qw(foreign_file foreign_dir);
\&  my $file = foreign_file(\*(AqMac\*(Aq, \*(Aq:foo:file.txt\*(Aq);
\&  print $file\->dir;                   # :foo:
\&  print $file\->as_foreign(\*(AqWin32\*(Aq);   # foo\efile.txt
\&  
\&  # Interact with the underlying filesystem:
\&  
\&  # $dir_handle is an IO::Dir object
\&  my $dir_handle = $dir\->open or die "Can\*(Aqt read $dir: $!";
\&  
\&  # $file_handle is an IO::File object
\&  my $file_handle = $file\->open($mode) or die "Can\*(Aqt read $file: $!";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Path::Class\*(C'\fR is a module for manipulation of file and directory
specifications (strings describing their locations, like
\&\f(CW\*(Aq/home/ken/foo.txt\*(Aq\fR or \f(CW\*(AqC:\eWindows\eFoo.txt\*(Aq\fR) in a cross-platform
manner.  It supports pretty much every platform Perl runs on,
including Unix, Windows, Mac, \s-1VMS,\s0 Epoc, Cygwin, \s-1OS/2,\s0 and NetWare.
.PP
The well-known module File::Spec also provides this service, but
it's sort of awkward to use well, so people sometimes avoid it, or use
it in a way that won't actually work properly on platforms
significantly different than the ones they've tested their code on.
.PP
In fact, \f(CW\*(C`Path::Class\*(C'\fR uses \f(CW\*(C`File::Spec\*(C'\fR internally, wrapping all
the unsightly details so you can concentrate on your application code.
Whereas \f(CW\*(C`File::Spec\*(C'\fR provides functions for some common path
manipulations, \f(CW\*(C`Path::Class\*(C'\fR provides an object-oriented model of the
world of path specifications and their underlying semantics.
\&\f(CW\*(C`File::Spec\*(C'\fR doesn't create any objects, and its classes represent
the different ways in which paths must be manipulated on various
platforms (not a very intuitive concept).  \f(CW\*(C`Path::Class\*(C'\fR creates
objects representing files and directories, and provides methods that
relate them to each other.  For instance, the following \f(CW\*(C`File::Spec\*(C'\fR
code:
.PP
.Vb 3
\& my $absolute = File::Spec\->file_name_is_absolute(
\&                  File::Spec\->catfile( @dirs, $file )
\&                );
.Ve
.PP
can be written using \f(CW\*(C`Path::Class\*(C'\fR as
.PP
.Vb 1
\& my $absolute = Path::Class::File\->new( @dirs, $file )\->is_absolute;
.Ve
.PP
or even as
.PP
.Vb 1
\& my $absolute = file( @dirs, $file )\->is_absolute;
.Ve
.PP
Similar readability improvements should happen all over the place when
using \f(CW\*(C`Path::Class\*(C'\fR.
.PP
Using \f(CW\*(C`Path::Class\*(C'\fR can help solve real problems in your code too \-
for instance, how many people actually take the \*(L"volume\*(R" (like \f(CW\*(C`C:\*(C'\fR
on Windows) into account when writing \f(CW\*(C`File::Spec\*(C'\fR\-using code?  I
thought not.  But if you use \f(CW\*(C`Path::Class\*(C'\fR, your file and directory objects
will know what volumes they refer to and do the right thing.
.PP
The guts of the \f(CW\*(C`Path::Class\*(C'\fR code live in the Path::Class::File
and Path::Class::Dir modules, so please see those
modules' documentation for more details about how to use them.
.SS "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
The following functions are exported by default.
.IP "file" 4
.IX Item "file"
A synonym for \f(CW\*(C`Path::Class::File\->new\*(C'\fR.
.IP "dir" 4
.IX Item "dir"
A synonym for \f(CW\*(C`Path::Class::Dir\->new\*(C'\fR.
.PP
If you would like to prevent their export, you may explicitly pass an
empty list to perl's \f(CW\*(C`use\*(C'\fR, i.e. \f(CW\*(C`use Path::Class ()\*(C'\fR.
.PP
The following are exported only on demand.
.IP "foreign_file" 4
.IX Item "foreign_file"
A synonym for \f(CW\*(C`Path::Class::File\->new_foreign\*(C'\fR.
.IP "foreign_dir" 4
.IX Item "foreign_dir"
A synonym for \f(CW\*(C`Path::Class::Dir\->new_foreign\*(C'\fR.
.IP "tempdir" 4
.IX Item "tempdir"
Create a new Path::Class::Dir instance pointed to temporary directory.
.Sp
.Vb 1
\&  my $temp = Path::Class::tempdir(CLEANUP => 1);
.Ve
.Sp
A synonym for \f(CW\*(C`Path::Class::Dir\->new(File::Temp::tempdir(@_))\*(C'\fR.
.SH "Notes on Cross-Platform Compatibility"
.IX Header "Notes on Cross-Platform Compatibility"
Although it is much easier to write cross-platform-friendly code with
this module than with \f(CW\*(C`File::Spec\*(C'\fR, there are still some issues to be
aware of.
.IP "\(bu" 4
On some platforms, notably \s-1VMS\s0 and some older versions of \s-1DOS \s0(I think),
all filenames must have an extension.  Thus if you create a file
called \fIfoo/bar\fR and then ask for a list of files in the directory
\&\fIfoo\fR, you may find a file called \fIbar.\fR instead of the \fIbar\fR you
were expecting.  Thus it might be a good idea to use an extension in
the first place.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ken Williams, KWILLIAMS@cpan.org
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) Ken Williams.  All rights reserved.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Path::Class::Dir, Path::Class::File, File::Spec
                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Path::Class::Dir.3pm                         0100644 0001750 0001750 00000065077 12566242307 024210  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Path::Class::Dir 3"
.TH Path::Class::Dir 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Path::Class::Dir \- Objects representing directories
.SH "VERSION"
.IX Header "VERSION"
version 0.33
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Path::Class;  # Exports dir() by default
\&  
\&  my $dir = dir(\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq);       # Path::Class::Dir object
\&  my $dir = Path::Class::Dir\->new(\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq);  # Same thing
\&  
\&  # Stringifies to \*(Aqfoo/bar\*(Aq on Unix, \*(Aqfoo\ebar\*(Aq on Windows, etc.
\&  print "dir: $dir\en";
\&  
\&  if ($dir\->is_absolute) { ... }
\&  if ($dir\->is_relative) { ... }
\&  
\&  my $v = $dir\->volume; # Could be \*(AqC:\*(Aq on Windows, empty string
\&                        # on Unix, \*(AqMacintosh HD:\*(Aq on Mac OS
\&  
\&  $dir\->cleanup; # Perform logical cleanup of pathname
\&  $dir\->resolve; # Perform physical cleanup of pathname
\&  
\&  my $file = $dir\->file(\*(Aqfile.txt\*(Aq); # A file in this directory
\&  my $subdir = $dir\->subdir(\*(Aqgeorge\*(Aq); # A subdirectory
\&  my $parent = $dir\->parent; # The parent directory, \*(Aqfoo\*(Aq
\&  
\&  my $abs = $dir\->absolute; # Transform to absolute path
\&  my $rel = $abs\->relative; # Transform to relative path
\&  my $rel = $abs\->relative(\*(Aq/foo\*(Aq); # Relative to /foo
\&  
\&  print $dir\->as_foreign(\*(AqMac\*(Aq);   # :foo:bar:
\&  print $dir\->as_foreign(\*(AqWin32\*(Aq); #  foo\ebar
\&
\&  # Iterate with IO::Dir methods:
\&  my $handle = $dir\->open;
\&  while (my $file = $handle\->read) {
\&    $file = $dir\->file($file);  # Turn into Path::Class::File object
\&    ...
\&  }
\&  
\&  # Iterate with Path::Class methods:
\&  while (my $file = $dir\->next) {
\&    # $file is a Path::Class::File or Path::Class::Dir object
\&    ...
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Path::Class::Dir\*(C'\fR class contains functionality for manipulating
directory names in a cross-platform way.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$dir = Path::Class::Dir\->new( <dir1>, <dir2>, ... )" 4
.el .IP "\f(CW$dir\fR = Path::Class::Dir\->new( <dir1>, <dir2>, ... )" 4
.IX Item "$dir = Path::Class::Dir->new( <dir1>, <dir2>, ... )"
.PD 0
.ie n .IP "$dir = dir( <dir1>, <dir2>, ... )" 4
.el .IP "\f(CW$dir\fR = dir( <dir1>, <dir2>, ... )" 4
.IX Item "$dir = dir( <dir1>, <dir2>, ... )"
.PD
Creates a new \f(CW\*(C`Path::Class::Dir\*(C'\fR object and returns it.  The
arguments specify names of directories which will be joined to create
a single directory object.  A volume may also be specified as the
first argument, or as part of the first argument.  You can use
platform-neutral syntax:
.Sp
.Vb 1
\&  my $dir = dir( \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq );
.Ve
.Sp
or platform-native syntax:
.Sp
.Vb 1
\&  my $dir = dir( \*(Aqfoo/bar/baz\*(Aq );
.Ve
.Sp
or a mixture of the two:
.Sp
.Vb 1
\&  my $dir = dir( \*(Aqfoo/bar\*(Aq, \*(Aqbaz\*(Aq );
.Ve
.Sp
All three of the above examples create relative paths.  To create an
absolute path, either use the platform native syntax for doing so:
.Sp
.Vb 1
\&  my $dir = dir( \*(Aq/var/tmp\*(Aq );
.Ve
.Sp
or use an empty string as the first argument:
.Sp
.Vb 1
\&  my $dir = dir( \*(Aq\*(Aq, \*(Aqvar\*(Aq, \*(Aqtmp\*(Aq );
.Ve
.Sp
If the second form seems awkward, that's somewhat intentional \- paths
like \f(CW\*(C`/var/tmp\*(C'\fR or \f(CW\*(C`\eWindows\*(C'\fR aren't cross-platform concepts in the
first place (many non-Unix platforms don't have a notion of a \*(L"root
directory\*(R"), so they probably shouldn't appear in your code if you're
trying to be cross-platform.  The first form is perfectly natural,
because paths like this may come from config files, user input, or
whatever.
.Sp
As a special case, since it doesn't otherwise mean anything useful and
it's convenient to define this way, \f(CW\*(C`Path::Class::Dir\->new()\*(C'\fR (or
\&\f(CW\*(C`dir()\*(C'\fR) refers to the current directory (\f(CW\*(C`File::Spec\->curdir\*(C'\fR).
To get the current directory as an absolute path, do \f(CW\*(C`dir()\->absolute\*(C'\fR.
.Sp
Finally, as another special case \f(CW\*(C`dir(undef)\*(C'\fR will return undef,
since that's usually an accident on the part of the caller, and
returning the root directory would be a nasty surprise just asking for
trouble a few lines later.
.ie n .IP "$dir\->stringify" 4
.el .IP "\f(CW$dir\fR\->stringify" 4
.IX Item "$dir->stringify"
This method is called internally when a \f(CW\*(C`Path::Class::Dir\*(C'\fR object is
used in a string context, so the following are equivalent:
.Sp
.Vb 2
\&  $string = $dir\->stringify;
\&  $string = "$dir";
.Ve
.ie n .IP "$dir\->volume" 4
.el .IP "\f(CW$dir\fR\->volume" 4
.IX Item "$dir->volume"
Returns the volume (e.g. \f(CW\*(C`C:\*(C'\fR on Windows, \f(CW\*(C`Macintosh HD:\*(C'\fR on Mac \s-1OS,\s0
etc.) of the directory object, if any.  Otherwise, returns the empty
string.
.ie n .IP "$dir\->basename" 4
.el .IP "\f(CW$dir\fR\->basename" 4
.IX Item "$dir->basename"
Returns the last directory name of the path as a string.
.ie n .IP "$dir\->is_dir" 4
.el .IP "\f(CW$dir\fR\->is_dir" 4
.IX Item "$dir->is_dir"
Returns a boolean value indicating whether this object represents a
directory.  Not surprisingly, Path::Class::File objects always
return false, and \f(CW\*(C`Path::Class::Dir\*(C'\fR objects always return true.
.ie n .IP "$dir\->is_absolute" 4
.el .IP "\f(CW$dir\fR\->is_absolute" 4
.IX Item "$dir->is_absolute"
Returns true or false depending on whether the directory refers to an
absolute path specifier (like \f(CW\*(C`/usr/local\*(C'\fR or \f(CW\*(C`\eWindows\*(C'\fR).
.ie n .IP "$dir\->is_relative" 4
.el .IP "\f(CW$dir\fR\->is_relative" 4
.IX Item "$dir->is_relative"
Returns true or false depending on whether the directory refers to a
relative path specifier (like \f(CW\*(C`lib/foo\*(C'\fR or \f(CW\*(C`./dir\*(C'\fR).
.ie n .IP "$dir\->cleanup" 4
.el .IP "\f(CW$dir\fR\->cleanup" 4
.IX Item "$dir->cleanup"
Performs a logical cleanup of the file path.  For instance:
.Sp
.Vb 2
\&  my $dir = dir(\*(Aq/foo//baz/./foo\*(Aq)\->cleanup;
\&  # $dir now represents \*(Aq/foo/baz/foo\*(Aq;
.Ve
.ie n .IP "$dir\->resolve" 4
.el .IP "\f(CW$dir\fR\->resolve" 4
.IX Item "$dir->resolve"
Performs a physical cleanup of the file path.  For instance:
.Sp
.Vb 2
\&  my $dir = dir(\*(Aq/foo//baz/../foo\*(Aq)\->resolve;
\&  # $dir now represents \*(Aq/foo/foo\*(Aq, assuming no symlinks
.Ve
.Sp
This actually consults the filesystem to verify the validity of the
path.
.ie n .IP "$file = $dir\->file( <dir1>, <dir2>, ..., <file> )" 4
.el .IP "\f(CW$file\fR = \f(CW$dir\fR\->file( <dir1>, <dir2>, ..., <file> )" 4
.IX Item "$file = $dir->file( <dir1>, <dir2>, ..., <file> )"
Returns a Path::Class::File object representing an entry in \f(CW$dir\fR
or one of its subdirectories.  Internally, this just calls \f(CW\*(C`Path::Class::File\->new( @_ )\*(C'\fR.
.ie n .IP "$subdir = $dir\->subdir( <dir1>, <dir2>, ... )" 4
.el .IP "\f(CW$subdir\fR = \f(CW$dir\fR\->subdir( <dir1>, <dir2>, ... )" 4
.IX Item "$subdir = $dir->subdir( <dir1>, <dir2>, ... )"
Returns a new \f(CW\*(C`Path::Class::Dir\*(C'\fR object representing a subdirectory
of \f(CW$dir\fR.
.ie n .IP "$parent = $dir\->parent" 4
.el .IP "\f(CW$parent\fR = \f(CW$dir\fR\->parent" 4
.IX Item "$parent = $dir->parent"
Returns the parent directory of \f(CW$dir\fR.  Note that this is the
\&\fIlogical\fR parent, not necessarily the physical parent.  It really
means we just chop off entries from the end of the directory list
until we cain't chop no more.  If the directory is relative, we start
using the relative forms of parent directories.
.Sp
The following code demonstrates the behavior on absolute and relative
directories:
.Sp
.Vb 5
\&  $dir = dir(\*(Aq/foo/bar\*(Aq);
\&  for (1..6) {
\&    print "Absolute: $dir\en";
\&    $dir = $dir\->parent;
\&  }
\&  
\&  $dir = dir(\*(Aqfoo/bar\*(Aq);
\&  for (1..6) {
\&    print "Relative: $dir\en";
\&    $dir = $dir\->parent;
\&  }
\&  
\&  ########### Output on Unix ################
\&  Absolute: /foo/bar
\&  Absolute: /foo
\&  Absolute: /
\&  Absolute: /
\&  Absolute: /
\&  Absolute: /
\&  Relative: foo/bar
\&  Relative: foo
\&  Relative: .
\&  Relative: ..
\&  Relative: ../..
\&  Relative: ../../..
.Ve
.ie n .IP "@list = $dir\->children" 4
.el .IP "\f(CW@list\fR = \f(CW$dir\fR\->children" 4
.IX Item "@list = $dir->children"
Returns a list of Path::Class::File and/or \f(CW\*(C`Path::Class::Dir\*(C'\fR
objects listed in this directory, or in scalar context the number of
such objects.  Obviously, it is necessary for \f(CW$dir\fR to
exist and be readable in order to find its children.
.Sp
Note that the children are returned as subdirectories of \f(CW$dir\fR,
i.e. the children of \fIfoo\fR will be \fIfoo/bar\fR and \fIfoo/baz\fR, not
\&\fIbar\fR and \fIbaz\fR.
.Sp
Ordinarily \f(CW\*(C`children()\*(C'\fR will not include the \fIself\fR and \fIparent\fR
entries \f(CW\*(C`.\*(C'\fR and \f(CW\*(C`..\*(C'\fR (or their equivalents on non-Unix systems),
because that's like I'm-my-own-grandpa business.  If you do want all
directory entries including these special ones, pass a true value for
the \f(CW\*(C`all\*(C'\fR parameter:
.Sp
.Vb 2
\&  @c = $dir\->children(); # Just the children
\&  @c = $dir\->children(all => 1); # All entries
.Ve
.Sp
In addition, there's a \f(CW\*(C`no_hidden\*(C'\fR parameter that will exclude all
normally \*(L"hidden\*(R" entries \- on Unix this means excluding all entries
that begin with a dot (\f(CW\*(C`.\*(C'\fR):
.Sp
.Vb 1
\&  @c = $dir\->children(no_hidden => 1); # Just normally\-visible entries
.Ve
.ie n .IP "$abs = $dir\->absolute" 4
.el .IP "\f(CW$abs\fR = \f(CW$dir\fR\->absolute" 4
.IX Item "$abs = $dir->absolute"
Returns a \f(CW\*(C`Path::Class::Dir\*(C'\fR object representing \f(CW$dir\fR as an
absolute path.  An optional argument, given as either a string or a
\&\f(CW\*(C`Path::Class::Dir\*(C'\fR object, specifies the directory to use as the base
of relativity \- otherwise the current working directory will be used.
.ie n .IP "$rel = $dir\->relative" 4
.el .IP "\f(CW$rel\fR = \f(CW$dir\fR\->relative" 4
.IX Item "$rel = $dir->relative"
Returns a \f(CW\*(C`Path::Class::Dir\*(C'\fR object representing \f(CW$dir\fR as a
relative path.  An optional argument, given as either a string or a
\&\f(CW\*(C`Path::Class::Dir\*(C'\fR object, specifies the directory to use as the base
of relativity \- otherwise the current working directory will be used.
.ie n .IP "$boolean = $dir\->subsumes($other)" 4
.el .IP "\f(CW$boolean\fR = \f(CW$dir\fR\->subsumes($other)" 4
.IX Item "$boolean = $dir->subsumes($other)"
Returns true if this directory spec subsumes the other spec, and false
otherwise.  Think of \*(L"subsumes\*(R" as \*(L"contains\*(R", but we only look at the
\&\fIspecs\fR, not whether \f(CW$dir\fR actually contains \f(CW$other\fR on the
filesystem.
.Sp
The \f(CW$other\fR argument may be a \f(CW\*(C`Path::Class::Dir\*(C'\fR object, a
Path::Class::File object, or a string.  In the latter case, we
assume it's a directory.
.Sp
.Vb 5
\&  # Examples:
\&  dir(\*(Aqfoo/bar\*(Aq )\->subsumes(dir(\*(Aqfoo/bar/baz\*(Aq))  # True
\&  dir(\*(Aq/foo/bar\*(Aq)\->subsumes(dir(\*(Aq/foo/bar/baz\*(Aq)) # True
\&  dir(\*(Aqfoo/bar\*(Aq )\->subsumes(dir(\*(Aqbar/baz\*(Aq))      # False
\&  dir(\*(Aq/foo/bar\*(Aq)\->subsumes(dir(\*(Aqfoo/bar\*(Aq))      # False
.Ve
.ie n .IP "$boolean = $dir\->contains($other)" 4
.el .IP "\f(CW$boolean\fR = \f(CW$dir\fR\->contains($other)" 4
.IX Item "$boolean = $dir->contains($other)"
Returns true if this directory actually contains \f(CW$other\fR on the
filesystem.  \f(CW$other\fR doesn't have to be a direct child of \f(CW$dir\fR,
it just has to be subsumed.
.ie n .IP "$foreign = $dir\->as_foreign($type)" 4
.el .IP "\f(CW$foreign\fR = \f(CW$dir\fR\->as_foreign($type)" 4
.IX Item "$foreign = $dir->as_foreign($type)"
Returns a \f(CW\*(C`Path::Class::Dir\*(C'\fR object representing \f(CW$dir\fR as it would
be specified on a system of type \f(CW$type\fR.  Known types include
\&\f(CW\*(C`Unix\*(C'\fR, \f(CW\*(C`Win32\*(C'\fR, \f(CW\*(C`Mac\*(C'\fR, \f(CW\*(C`VMS\*(C'\fR, and \f(CW\*(C`OS2\*(C'\fR, i.e. anything for which
there is a subclass of \f(CW\*(C`File::Spec\*(C'\fR.
.Sp
Any generated objects (subdirectories, files, parents, etc.) will also
retain this type.
.ie n .IP "$foreign = Path::Class::Dir\->new_foreign($type, @args)" 4
.el .IP "\f(CW$foreign\fR = Path::Class::Dir\->new_foreign($type, \f(CW@args\fR)" 4
.IX Item "$foreign = Path::Class::Dir->new_foreign($type, @args)"
Returns a \f(CW\*(C`Path::Class::Dir\*(C'\fR object representing \f(CW$dir\fR as it would
be specified on a system of type \f(CW$type\fR.  Known types include
\&\f(CW\*(C`Unix\*(C'\fR, \f(CW\*(C`Win32\*(C'\fR, \f(CW\*(C`Mac\*(C'\fR, \f(CW\*(C`VMS\*(C'\fR, and \f(CW\*(C`OS2\*(C'\fR, i.e. anything for which
there is a subclass of \f(CW\*(C`File::Spec\*(C'\fR.
.Sp
The arguments in \f(CW@args\fR are the same as they would be specified in
\&\f(CW\*(C`new()\*(C'\fR.
.ie n .IP "@list = $dir\->dir_list([\s-1OFFSET,\s0 [\s-1LENGTH\s0]])" 4
.el .IP "\f(CW@list\fR = \f(CW$dir\fR\->dir_list([\s-1OFFSET,\s0 [\s-1LENGTH\s0]])" 4
.IX Item "@list = $dir->dir_list([OFFSET, [LENGTH]])"
Returns the list of strings internally representing this directory
structure.  Each successive member of the list is understood to be an
entry in its predecessor's directory list.  By contract, \f(CW\*(C`Path::Class\->new( $dir\->dir_list )\*(C'\fR should be equivalent to \f(CW$dir\fR.
.Sp
The semantics of this method are similar to Perl's \f(CW\*(C`splice\*(C'\fR or
\&\f(CW\*(C`substr\*(C'\fR functions; they return \f(CW\*(C`LENGTH\*(C'\fR elements starting at
\&\f(CW\*(C`OFFSET\*(C'\fR.  If \f(CW\*(C`LENGTH\*(C'\fR is omitted, returns all the elements starting
at \f(CW\*(C`OFFSET\*(C'\fR up to the end of the list.  If \f(CW\*(C`LENGTH\*(C'\fR is negative,
returns the elements from \f(CW\*(C`OFFSET\*(C'\fR onward except for \f(CW\*(C`\-LENGTH\*(C'\fR
elements at the end.  If \f(CW\*(C`OFFSET\*(C'\fR is negative, it counts backward
\&\f(CW\*(C`OFFSET\*(C'\fR elements from the end of the list.  If \f(CW\*(C`OFFSET\*(C'\fR and
\&\f(CW\*(C`LENGTH\*(C'\fR are both omitted, the entire list is returned.
.Sp
In a scalar context, \f(CW\*(C`dir_list()\*(C'\fR with no arguments returns the
number of entries in the directory list; \f(CW\*(C`dir_list(OFFSET)\*(C'\fR returns
the single element at that offset; \f(CW\*(C`dir_list(OFFSET, LENGTH)\*(C'\fR returns
the final element that would have been returned in a list context.
.ie n .IP "$dir\->components" 4
.el .IP "\f(CW$dir\fR\->components" 4
.IX Item "$dir->components"
Identical to c<\fIdir_list()\fR>.  It exists because there's an analogous
method \f(CW\*(C`dir_list()\*(C'\fR in the \f(CW\*(C`Path::Class::File\*(C'\fR class that also
returns the basename string, so this method lets someone call
\&\f(CW\*(C`components()\*(C'\fR without caring whether the object is a file or a
directory.
.ie n .IP "$fh = $dir\->\fIopen()\fR" 4
.el .IP "\f(CW$fh\fR = \f(CW$dir\fR\->\fIopen()\fR" 4
.IX Item "$fh = $dir->open()"
Passes \f(CW$dir\fR to \f(CW\*(C`IO::Dir\->open\*(C'\fR and returns the result as an
IO::Dir object.  If the opening fails, \f(CW\*(C`undef\*(C'\fR is returned and
\&\f(CW$!\fR is set.
.ie n .IP "$dir\->mkpath($verbose, $mode)" 4
.el .IP "\f(CW$dir\fR\->mkpath($verbose, \f(CW$mode\fR)" 4
.IX Item "$dir->mkpath($verbose, $mode)"
Passes all arguments, including \f(CW$dir\fR, to \f(CW\*(C`File::Path::mkpath()\*(C'\fR and returns the result (a list of all directories created).
.ie n .IP "$dir\->rmtree($verbose, $cautious)" 4
.el .IP "\f(CW$dir\fR\->rmtree($verbose, \f(CW$cautious\fR)" 4
.IX Item "$dir->rmtree($verbose, $cautious)"
Passes all arguments, including \f(CW$dir\fR, to \f(CW\*(C`File::Path::rmtree()\*(C'\fR and returns the result (the number of files successfully deleted).
.ie n .IP "$dir\->\fIremove()\fR" 4
.el .IP "\f(CW$dir\fR\->\fIremove()\fR" 4
.IX Item "$dir->remove()"
Removes the directory, which must be empty.  Returns a boolean value
indicating whether or not the directory was successfully removed.
This method is mainly provided for consistency with
\&\f(CW\*(C`Path::Class::File\*(C'\fR's \f(CW\*(C`remove()\*(C'\fR method.
.ie n .IP "$dir\->tempfile(...)" 4
.el .IP "\f(CW$dir\fR\->tempfile(...)" 4
.IX Item "$dir->tempfile(...)"
An interface to File::Temp's \f(CW\*(C`tempfile()\*(C'\fR function.  Just like
that function, if you call this in a scalar context, the return value
is the filehandle and the file is \f(CW\*(C`unlink\*(C'\fRed as soon as possible
(which is immediately on Unix-like platforms).  If called in a list
context, the return values are the filehandle and the filename.
.Sp
The given directory is passed as the \f(CW\*(C`DIR\*(C'\fR parameter.
.Sp
Here's an example of pretty good usage which doesn't allow race
conditions, won't leave yucky tempfiles around on your filesystem,
etc.:
.Sp
.Vb 4
\&  my $fh = $dir\->tempfile;
\&  print $fh "Here\*(Aqs some data...\en";
\&  seek($fh, 0, 0);
\&  while (<$fh>) { do something... }
.Ve
.Sp
Or in combination with a \f(CW\*(C`fork\*(C'\fR:
.Sp
.Vb 8
\&  my $fh = $dir\->tempfile;
\&  print $fh "Here\*(Aqs some more data...\en";
\&  seek($fh, 0, 0);
\&  if ($pid=fork()) {
\&    wait;
\&  } else {
\&    something($_) while <$fh>;
\&  }
.Ve
.ie n .IP "$dir_or_file = $dir\->\fInext()\fR" 4
.el .IP "\f(CW$dir_or_file\fR = \f(CW$dir\fR\->\fInext()\fR" 4
.IX Item "$dir_or_file = $dir->next()"
A convenient way to iterate through directory contents.  The first
time \f(CW\*(C`next()\*(C'\fR is called, it will \f(CW\*(C`open()\*(C'\fR the directory and read the
first item from it, returning the result as a \f(CW\*(C`Path::Class::Dir\*(C'\fR or
Path::Class::File object (depending, of course, on its actual
type).  Each subsequent call to \f(CW\*(C`next()\*(C'\fR will simply iterate over the
directory's contents, until there are no more items in the directory,
and then the undefined value is returned.  For example, to iterate
over all the regular files in a directory:
.Sp
.Vb 5
\&  while (my $file = $dir\->next) {
\&    next unless \-f $file;
\&    my $fh = $file\->open(\*(Aqr\*(Aq) or die "Can\*(Aqt read $file: $!";
\&    ...
\&  }
.Ve
.Sp
If an error occurs when opening the directory (for instance, it
doesn't exist or isn't readable), \f(CW\*(C`next()\*(C'\fR will throw an exception
with the value of \f(CW$!\fR.
.ie n .IP "$dir\->traverse( sub { ... }, @args )" 4
.el .IP "\f(CW$dir\fR\->traverse( sub { ... }, \f(CW@args\fR )" 4
.IX Item "$dir->traverse( sub { ... }, @args )"
Calls the given callback for the root, passing it a continuation
function which, when called, will call this recursively on each of its
children. The callback function should be of the form:
.Sp
.Vb 4
\&  sub {
\&    my ($child, $cont, @args) = @_;
\&    # ...
\&  }
.Ve
.Sp
For instance, to calculate the number of files in a directory, you
can do this:
.Sp
.Vb 4
\&  my $nfiles = $dir\->traverse(sub {
\&    my ($child, $cont) = @_;
\&    return sum($cont\->(), ($child\->is_dir ? 0 : 1));
\&  });
.Ve
.Sp
or to calculate the maximum depth of a directory:
.Sp
.Vb 4
\&  my $depth = $dir\->traverse(sub {
\&    my ($child, $cont, $depth) = @_;
\&    return max($cont\->($depth + 1), $depth);
\&  }, 0);
.Ve
.Sp
You can also choose not to call the callback in certain situations:
.Sp
.Vb 6
\&  $dir\->traverse(sub {
\&    my ($child, $cont) = @_;
\&    return if \-l $child; # don\*(Aqt follow symlinks
\&    # do something with $child
\&    return $cont\->();
\&  });
.Ve
.ie n .IP "$dir\->traverse_if( sub { ... }, sub { ... }, @args )" 4
.el .IP "\f(CW$dir\fR\->traverse_if( sub { ... }, sub { ... }, \f(CW@args\fR )" 4
.IX Item "$dir->traverse_if( sub { ... }, sub { ... }, @args )"
traverse with additional \*(L"should I visit this child\*(R" callback.
Particularly useful in case examined tree contains inaccessible
directories.
.Sp
Canonical example:
.Sp
.Vb 11
\&  $dir\->traverse_if(
\&    sub {
\&       my ($child, $cont) = @_;
\&       # do something with $child
\&       return $cont\->();
\&    }, 
\&    sub {
\&       my ($child) = @_;
\&       # Process only readable items
\&       return \-r $child;
\&    });
.Ve
.Sp
Second callback gets single parameter: child. Only children for
which it returns true will be processed by the first callback.
.Sp
Remaining parameters are interpreted as in traverse, in particular
\&\f(CW\*(C`traverse_if(callback, sub { 1 }, @args\*(C'\fR is equivalent to
\&\f(CW\*(C`traverse(callback, @args)\*(C'\fR.
.ie n .IP "$dir\->recurse( callback => sub {...} )" 4
.el .IP "\f(CW$dir\fR\->recurse( callback => sub {...} )" 4
.IX Item "$dir->recurse( callback => sub {...} )"
Iterates through this directory and all of its children, and all of
its children's children, etc., calling the \f(CW\*(C`callback\*(C'\fR subroutine for
each entry.  This is a lot like what the File::Find module does,
and of course \f(CW\*(C`File::Find\*(C'\fR will work fine on Path::Class objects,
but the advantage of the \f(CW\*(C`recurse()\*(C'\fR method is that it will also feed
your callback routine \f(CW\*(C`Path::Class\*(C'\fR objects rather than just pathname
strings.
.Sp
The \f(CW\*(C`recurse()\*(C'\fR method requires a \f(CW\*(C`callback\*(C'\fR parameter specifying
the subroutine to invoke for each entry.  It will be passed the
\&\f(CW\*(C`Path::Class\*(C'\fR object as its first argument.
.Sp
\&\f(CW\*(C`recurse()\*(C'\fR also accepts two boolean parameters, \f(CW\*(C`depthfirst\*(C'\fR and
\&\f(CW\*(C`preorder\*(C'\fR that control the order of recursion.  The default is a
preorder, breadth-first search, i.e. \f(CW\*(C`depthfirst => 0, preorder => 1\*(C'\fR.
At the time of this writing, all combinations of these two parameters
are supported \fIexcept\fR \f(CW\*(C`depthfirst => 0, preorder => 0\*(C'\fR.
.Sp
\&\f(CW\*(C`callback\*(C'\fR is normally not required to return any value. If it
returns special constant \f(CW\*(C`Path::Class::Entity::PRUNE()\*(C'\fR (more easily
available as \f(CW\*(C`$item\-\*(C'\fR\s-1PRUNE\s0>),  no children of analyzed
item will be analyzed (mostly as if you set \f(CW\*(C`$File::Find::prune=1\*(C'\fR). Of course
pruning is available only in \f(CW\*(C`preorder\*(C'\fR, in postorder return value
has no effect.
.ie n .IP "$st = $file\->\fIstat()\fR" 4
.el .IP "\f(CW$st\fR = \f(CW$file\fR\->\fIstat()\fR" 4
.IX Item "$st = $file->stat()"
Invokes \f(CW\*(C`File::stat::stat()\*(C'\fR on this directory and returns a
\&\f(CW\*(C`File::stat\*(C'\fR object representing the result.
.ie n .IP "$st = $file\->\fIlstat()\fR" 4
.el .IP "\f(CW$st\fR = \f(CW$file\fR\->\fIlstat()\fR" 4
.IX Item "$st = $file->lstat()"
Same as \f(CW\*(C`stat()\*(C'\fR, but if \f(CW$file\fR is a symbolic link, \f(CW\*(C`lstat()\*(C'\fR
stats the link instead of the directory the link points to.
.ie n .IP "$class = $file\->\fIfile_class()\fR" 4
.el .IP "\f(CW$class\fR = \f(CW$file\fR\->\fIfile_class()\fR" 4
.IX Item "$class = $file->file_class()"
Returns the class which should be used to create file objects.
.Sp
Generally overridden whenever this class is subclassed.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ken Williams, kwilliams@cpan.org
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Path::Class, Path::Class::File, File::Spec
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Path::Class::Dir5.16.3pm                     0100644 0001750 0001750 00000061122 12566242311 024500  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Path::Class::Dir 3"
.TH Path::Class::Dir 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Path::Class::Dir \- Objects representing directories
.SH "VERSION"
.IX Header "VERSION"
version 0.26
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Path::Class qw(dir);  # Export a short constructor
\&  
\&  my $dir = dir(\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq);       # Path::Class::Dir object
\&  my $dir = Path::Class::Dir\->new(\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq);  # Same thing
\&  
\&  # Stringifies to \*(Aqfoo/bar\*(Aq on Unix, \*(Aqfoo\ebar\*(Aq on Windows, etc.
\&  print "dir: $dir\en";
\&  
\&  if ($dir\->is_absolute) { ... }
\&  if ($dir\->is_relative) { ... }
\&  
\&  my $v = $dir\->volume; # Could be \*(AqC:\*(Aq on Windows, empty string
\&                        # on Unix, \*(AqMacintosh HD:\*(Aq on Mac OS
\&  
\&  $dir\->cleanup; # Perform logical cleanup of pathname
\&  $dir\->resolve; # Perform physical cleanup of pathname
\&  
\&  my $file = $dir\->file(\*(Aqfile.txt\*(Aq); # A file in this directory
\&  my $subdir = $dir\->subdir(\*(Aqgeorge\*(Aq); # A subdirectory
\&  my $parent = $dir\->parent; # The parent directory, \*(Aqfoo\*(Aq
\&  
\&  my $abs = $dir\->absolute; # Transform to absolute path
\&  my $rel = $abs\->relative; # Transform to relative path
\&  my $rel = $abs\->relative(\*(Aq/foo\*(Aq); # Relative to /foo
\&  
\&  print $dir\->as_foreign(\*(AqMac\*(Aq);   # :foo:bar:
\&  print $dir\->as_foreign(\*(AqWin32\*(Aq); #  foo\ebar
\&
\&  # Iterate with IO::Dir methods:
\&  my $handle = $dir\->open;
\&  while (my $file = $handle\->read) {
\&    $file = $dir\->file($file);  # Turn into Path::Class::File object
\&    ...
\&  }
\&  
\&  # Iterate with Path::Class methods:
\&  while (my $file = $dir\->next) {
\&    # $file is a Path::Class::File or Path::Class::Dir object
\&    ...
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Path::Class::Dir\*(C'\fR class contains functionality for manipulating
directory names in a cross-platform way.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$dir = Path::Class::Dir\->new( <dir1>, <dir2>, ... )" 4
.el .IP "\f(CW$dir\fR = Path::Class::Dir\->new( <dir1>, <dir2>, ... )" 4
.IX Item "$dir = Path::Class::Dir->new( <dir1>, <dir2>, ... )"
.PD 0
.ie n .IP "$dir = dir( <dir1>, <dir2>, ... )" 4
.el .IP "\f(CW$dir\fR = dir( <dir1>, <dir2>, ... )" 4
.IX Item "$dir = dir( <dir1>, <dir2>, ... )"
.PD
Creates a new \f(CW\*(C`Path::Class::Dir\*(C'\fR object and returns it.  The
arguments specify names of directories which will be joined to create
a single directory object.  A volume may also be specified as the
first argument, or as part of the first argument.  You can use
platform-neutral syntax:
.Sp
.Vb 1
\&  my $dir = dir( \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq );
.Ve
.Sp
or platform-native syntax:
.Sp
.Vb 1
\&  my $dir = dir( \*(Aqfoo/bar/baz\*(Aq );
.Ve
.Sp
or a mixture of the two:
.Sp
.Vb 1
\&  my $dir = dir( \*(Aqfoo/bar\*(Aq, \*(Aqbaz\*(Aq );
.Ve
.Sp
All three of the above examples create relative paths.  To create an
absolute path, either use the platform native syntax for doing so:
.Sp
.Vb 1
\&  my $dir = dir( \*(Aq/var/tmp\*(Aq );
.Ve
.Sp
or use an empty string as the first argument:
.Sp
.Vb 1
\&  my $dir = dir( \*(Aq\*(Aq, \*(Aqvar\*(Aq, \*(Aqtmp\*(Aq );
.Ve
.Sp
If the second form seems awkward, that's somewhat intentional \- paths
like \f(CW\*(C`/var/tmp\*(C'\fR or \f(CW\*(C`\eWindows\*(C'\fR aren't cross-platform concepts in the
first place (many non-Unix platforms don't have a notion of a \*(L"root
directory\*(R"), so they probably shouldn't appear in your code if you're
trying to be cross-platform.  The first form is perfectly natural,
because paths like this may come from config files, user input, or
whatever.
.Sp
As a special case, since it doesn't otherwise mean anything useful and
it's convenient to define this way, \f(CW\*(C`Path::Class::Dir\->new()\*(C'\fR (or
\&\f(CW\*(C`dir()\*(C'\fR) refers to the current directory (\f(CW\*(C`File::Spec\->curdir\*(C'\fR).
To get the current directory as an absolute path, do \f(CW\*(C`dir()\->absolute\*(C'\fR.
.Sp
Finally, as another special case \f(CW\*(C`dir(undef)\*(C'\fR will return undef,
since that's usually an accident on the part of the caller, and
returning the root directory would be a nasty surprise just asking for
trouble a few lines later.
.ie n .IP "$dir\->stringify" 4
.el .IP "\f(CW$dir\fR\->stringify" 4
.IX Item "$dir->stringify"
This method is called internally when a \f(CW\*(C`Path::Class::Dir\*(C'\fR object is
used in a string context, so the following are equivalent:
.Sp
.Vb 2
\&  $string = $dir\->stringify;
\&  $string = "$dir";
.Ve
.ie n .IP "$dir\->volume" 4
.el .IP "\f(CW$dir\fR\->volume" 4
.IX Item "$dir->volume"
Returns the volume (e.g. \f(CW\*(C`C:\*(C'\fR on Windows, \f(CW\*(C`Macintosh HD:\*(C'\fR on Mac \s-1OS\s0,
etc.) of the directory object, if any.  Otherwise, returns the empty
string.
.ie n .IP "$dir\->is_dir" 4
.el .IP "\f(CW$dir\fR\->is_dir" 4
.IX Item "$dir->is_dir"
Returns a boolean value indicating whether this object represents a
directory.  Not surprisingly, \f(CW\*(C`Path::Class::File\*(C'\fR objects always
return false, and \f(CW\*(C`Path::Class::Dir\*(C'\fR objects always return true.
.ie n .IP "$dir\->is_absolute" 4
.el .IP "\f(CW$dir\fR\->is_absolute" 4
.IX Item "$dir->is_absolute"
Returns true or false depending on whether the directory refers to an
absolute path specifier (like \f(CW\*(C`/usr/local\*(C'\fR or \f(CW\*(C`\eWindows\*(C'\fR).
.ie n .IP "$dir\->is_relative" 4
.el .IP "\f(CW$dir\fR\->is_relative" 4
.IX Item "$dir->is_relative"
Returns true or false depending on whether the directory refers to a
relative path specifier (like \f(CW\*(C`lib/foo\*(C'\fR or \f(CW\*(C`./dir\*(C'\fR).
.ie n .IP "$dir\->cleanup" 4
.el .IP "\f(CW$dir\fR\->cleanup" 4
.IX Item "$dir->cleanup"
Performs a logical cleanup of the file path.  For instance:
.Sp
.Vb 2
\&  my $dir = dir(\*(Aq/foo//baz/./foo\*(Aq)\->cleanup;
\&  # $dir now represents \*(Aq/foo/baz/foo\*(Aq;
.Ve
.ie n .IP "$dir\->resolve" 4
.el .IP "\f(CW$dir\fR\->resolve" 4
.IX Item "$dir->resolve"
Performs a physical cleanup of the file path.  For instance:
.Sp
.Vb 2
\&  my $dir = dir(\*(Aq/foo//baz/../foo\*(Aq)\->resolve;
\&  # $dir now represents \*(Aq/foo/foo\*(Aq, assuming no symlinks
.Ve
.Sp
This actually consults the filesystem to verify the validity of the
path.
.ie n .IP "$file = $dir\->file( <dir1>, <dir2>, ..., <file> )" 4
.el .IP "\f(CW$file\fR = \f(CW$dir\fR\->file( <dir1>, <dir2>, ..., <file> )" 4
.IX Item "$file = $dir->file( <dir1>, <dir2>, ..., <file> )"
Returns a \f(CW\*(C`Path::Class::File\*(C'\fR object representing an entry in \f(CW$dir\fR
or one of its subdirectories.  Internally, this just calls \f(CW\*(C`Path::Class::File\->new( @_ )\*(C'\fR.
.ie n .IP "$subdir = $dir\->subdir( <dir1>, <dir2>, ... )" 4
.el .IP "\f(CW$subdir\fR = \f(CW$dir\fR\->subdir( <dir1>, <dir2>, ... )" 4
.IX Item "$subdir = $dir->subdir( <dir1>, <dir2>, ... )"
Returns a new \f(CW\*(C`Path::Class::Dir\*(C'\fR object representing a subdirectory
of \f(CW$dir\fR.
.ie n .IP "$parent = $dir\->parent" 4
.el .IP "\f(CW$parent\fR = \f(CW$dir\fR\->parent" 4
.IX Item "$parent = $dir->parent"
Returns the parent directory of \f(CW$dir\fR.  Note that this is the
\&\fIlogical\fR parent, not necessarily the physical parent.  It really
means we just chop off entries from the end of the directory list
until we cain't chop no more.  If the directory is relative, we start
using the relative forms of parent directories.
.Sp
The following code demonstrates the behavior on absolute and relative
directories:
.Sp
.Vb 5
\&  $dir = dir(\*(Aq/foo/bar\*(Aq);
\&  for (1..6) {
\&    print "Absolute: $dir\en";
\&    $dir = $dir\->parent;
\&  }
\&  
\&  $dir = dir(\*(Aqfoo/bar\*(Aq);
\&  for (1..6) {
\&    print "Relative: $dir\en";
\&    $dir = $dir\->parent;
\&  }
\&  
\&  ########### Output on Unix ################
\&  Absolute: /foo/bar
\&  Absolute: /foo
\&  Absolute: /
\&  Absolute: /
\&  Absolute: /
\&  Absolute: /
\&  Relative: foo/bar
\&  Relative: foo
\&  Relative: .
\&  Relative: ..
\&  Relative: ../..
\&  Relative: ../../..
.Ve
.ie n .IP "@list = $dir\->children" 4
.el .IP "\f(CW@list\fR = \f(CW$dir\fR\->children" 4
.IX Item "@list = $dir->children"
Returns a list of \f(CW\*(C`Path::Class::File\*(C'\fR and/or \f(CW\*(C`Path::Class::Dir\*(C'\fR
objects listed in this directory, or in scalar context the number of
such objects.  Obviously, it is necessary for \f(CW$dir\fR to
exist and be readable in order to find its children.
.Sp
Note that the children are returned as subdirectories of \f(CW$dir\fR,
i.e. the children of \fIfoo\fR will be \fIfoo/bar\fR and \fIfoo/baz\fR, not
\&\fIbar\fR and \fIbaz\fR.
.Sp
Ordinarily \f(CW\*(C`children()\*(C'\fR will not include the \fIself\fR and \fIparent\fR
entries \f(CW\*(C`.\*(C'\fR and \f(CW\*(C`..\*(C'\fR (or their equivalents on non-Unix systems),
because that's like I'm-my-own-grandpa business.  If you do want all
directory entries including these special ones, pass a true value for
the \f(CW\*(C`all\*(C'\fR parameter:
.Sp
.Vb 2
\&  @c = $dir\->children(); # Just the children
\&  @c = $dir\->children(all => 1); # All entries
.Ve
.Sp
In addition, there's a \f(CW\*(C`no_hidden\*(C'\fR parameter that will exclude all
normally \*(L"hidden\*(R" entries \- on Unix this means excluding all entries
that begin with a dot (\f(CW\*(C`.\*(C'\fR):
.Sp
.Vb 1
\&  @c = $dir\->children(no_hidden => 1); # Just normally\-visible entries
.Ve
.ie n .IP "$abs = $dir\->absolute" 4
.el .IP "\f(CW$abs\fR = \f(CW$dir\fR\->absolute" 4
.IX Item "$abs = $dir->absolute"
Returns a \f(CW\*(C`Path::Class::Dir\*(C'\fR object representing \f(CW$dir\fR as an
absolute path.  An optional argument, given as either a string or a
\&\f(CW\*(C`Path::Class::Dir\*(C'\fR object, specifies the directory to use as the base
of relativity \- otherwise the current working directory will be used.
.ie n .IP "$rel = $dir\->relative" 4
.el .IP "\f(CW$rel\fR = \f(CW$dir\fR\->relative" 4
.IX Item "$rel = $dir->relative"
Returns a \f(CW\*(C`Path::Class::Dir\*(C'\fR object representing \f(CW$dir\fR as a
relative path.  An optional argument, given as either a string or a
\&\f(CW\*(C`Path::Class::Dir\*(C'\fR object, specifies the directory to use as the base
of relativity \- otherwise the current working directory will be used.
.ie n .IP "$boolean = $dir\->subsumes($other)" 4
.el .IP "\f(CW$boolean\fR = \f(CW$dir\fR\->subsumes($other)" 4
.IX Item "$boolean = $dir->subsumes($other)"
Returns true if this directory spec subsumes the other spec, and false
otherwise.  Think of \*(L"subsumes\*(R" as \*(L"contains\*(R", but we only look at the
\&\fIspecs\fR, not whether \f(CW$dir\fR actually contains \f(CW$other\fR on the
filesystem.
.Sp
The \f(CW$other\fR argument may be a \f(CW\*(C`Path::Class::Dir\*(C'\fR object, a
\&\f(CW\*(C`Path::Class::File\*(C'\fR object, or a string.  In the latter case, we
assume it's a directory.
.Sp
.Vb 5
\&  # Examples:
\&  dir(\*(Aqfoo/bar\*(Aq )\->subsumes(dir(\*(Aqfoo/bar/baz\*(Aq))  # True
\&  dir(\*(Aq/foo/bar\*(Aq)\->subsumes(dir(\*(Aq/foo/bar/baz\*(Aq)) # True
\&  dir(\*(Aqfoo/bar\*(Aq )\->subsumes(dir(\*(Aqbar/baz\*(Aq))      # False
\&  dir(\*(Aq/foo/bar\*(Aq)\->subsumes(dir(\*(Aqfoo/bar\*(Aq))      # False
.Ve
.ie n .IP "$boolean = $dir\->contains($other)" 4
.el .IP "\f(CW$boolean\fR = \f(CW$dir\fR\->contains($other)" 4
.IX Item "$boolean = $dir->contains($other)"
Returns true if this directory actually contains \f(CW$other\fR on the
filesystem.  \f(CW$other\fR doesn't have to be a direct child of \f(CW$dir\fR,
it just has to be subsumed.
.ie n .IP "$foreign = $dir\->as_foreign($type)" 4
.el .IP "\f(CW$foreign\fR = \f(CW$dir\fR\->as_foreign($type)" 4
.IX Item "$foreign = $dir->as_foreign($type)"
Returns a \f(CW\*(C`Path::Class::Dir\*(C'\fR object representing \f(CW$dir\fR as it would
be specified on a system of type \f(CW$type\fR.  Known types include
\&\f(CW\*(C`Unix\*(C'\fR, \f(CW\*(C`Win32\*(C'\fR, \f(CW\*(C`Mac\*(C'\fR, \f(CW\*(C`VMS\*(C'\fR, and \f(CW\*(C`OS2\*(C'\fR, i.e. anything for which
there is a subclass of \f(CW\*(C`File::Spec\*(C'\fR.
.Sp
Any generated objects (subdirectories, files, parents, etc.) will also
retain this type.
.ie n .IP "$foreign = Path::Class::Dir\->new_foreign($type, @args)" 4
.el .IP "\f(CW$foreign\fR = Path::Class::Dir\->new_foreign($type, \f(CW@args\fR)" 4
.IX Item "$foreign = Path::Class::Dir->new_foreign($type, @args)"
Returns a \f(CW\*(C`Path::Class::Dir\*(C'\fR object representing \f(CW$dir\fR as it would
be specified on a system of type \f(CW$type\fR.  Known types include
\&\f(CW\*(C`Unix\*(C'\fR, \f(CW\*(C`Win32\*(C'\fR, \f(CW\*(C`Mac\*(C'\fR, \f(CW\*(C`VMS\*(C'\fR, and \f(CW\*(C`OS2\*(C'\fR, i.e. anything for which
there is a subclass of \f(CW\*(C`File::Spec\*(C'\fR.
.Sp
The arguments in \f(CW@args\fR are the same as they would be specified in
\&\f(CW\*(C`new()\*(C'\fR.
.ie n .IP "@list = $dir\->dir_list([\s-1OFFSET\s0, [\s-1LENGTH\s0]])" 4
.el .IP "\f(CW@list\fR = \f(CW$dir\fR\->dir_list([\s-1OFFSET\s0, [\s-1LENGTH\s0]])" 4
.IX Item "@list = $dir->dir_list([OFFSET, [LENGTH]])"
Returns the list of strings internally representing this directory
structure.  Each successive member of the list is understood to be an
entry in its predecessor's directory list.  By contract, \f(CW\*(C`Path::Class\->new( $dir\->dir_list )\*(C'\fR should be equivalent to \f(CW$dir\fR.
.Sp
The semantics of this method are similar to Perl's \f(CW\*(C`splice\*(C'\fR or
\&\f(CW\*(C`substr\*(C'\fR functions; they return \f(CW\*(C`LENGTH\*(C'\fR elements starting at
\&\f(CW\*(C`OFFSET\*(C'\fR.  If \f(CW\*(C`LENGTH\*(C'\fR is omitted, returns all the elements starting
at \f(CW\*(C`OFFSET\*(C'\fR up to the end of the list.  If \f(CW\*(C`LENGTH\*(C'\fR is negative,
returns the elements from \f(CW\*(C`OFFSET\*(C'\fR onward except for \f(CW\*(C`\-LENGTH\*(C'\fR
elements at the end.  If \f(CW\*(C`OFFSET\*(C'\fR is negative, it counts backward
\&\f(CW\*(C`OFFSET\*(C'\fR elements from the end of the list.  If \f(CW\*(C`OFFSET\*(C'\fR and
\&\f(CW\*(C`LENGTH\*(C'\fR are both omitted, the entire list is returned.
.Sp
In a scalar context, \f(CW\*(C`dir_list()\*(C'\fR with no arguments returns the
number of entries in the directory list; \f(CW\*(C`dir_list(OFFSET)\*(C'\fR returns
the single element at that offset; \f(CW\*(C`dir_list(OFFSET, LENGTH)\*(C'\fR returns
the final element that would have been returned in a list context.
.ie n .IP "$fh = $dir\->\fIopen()\fR" 4
.el .IP "\f(CW$fh\fR = \f(CW$dir\fR\->\fIopen()\fR" 4
.IX Item "$fh = $dir->open()"
Passes \f(CW$dir\fR to \f(CW\*(C`IO::Dir\->open\*(C'\fR and returns the result as an
\&\f(CW\*(C`IO::Dir\*(C'\fR object.  If the opening fails, \f(CW\*(C`undef\*(C'\fR is returned and
\&\f(CW$!\fR is set.
.ie n .IP "$dir\->mkpath($verbose, $mode)" 4
.el .IP "\f(CW$dir\fR\->mkpath($verbose, \f(CW$mode\fR)" 4
.IX Item "$dir->mkpath($verbose, $mode)"
Passes all arguments, including \f(CW$dir\fR, to \f(CW\*(C`File::Path::mkpath()\*(C'\fR and returns the result (a list of all directories created).
.ie n .IP "$dir\->rmtree($verbose, $cautious)" 4
.el .IP "\f(CW$dir\fR\->rmtree($verbose, \f(CW$cautious\fR)" 4
.IX Item "$dir->rmtree($verbose, $cautious)"
Passes all arguments, including \f(CW$dir\fR, to \f(CW\*(C`File::Path::rmtree()\*(C'\fR and returns the result (the number of files successfully deleted).
.ie n .IP "$dir\->\fIremove()\fR" 4
.el .IP "\f(CW$dir\fR\->\fIremove()\fR" 4
.IX Item "$dir->remove()"
Removes the directory, which must be empty.  Returns a boolean value
indicating whether or not the directory was successfully removed.
This method is mainly provided for consistency with
\&\f(CW\*(C`Path::Class::File\*(C'\fR's \f(CW\*(C`remove()\*(C'\fR method.
.ie n .IP "$dir\->tempfile(...)" 4
.el .IP "\f(CW$dir\fR\->tempfile(...)" 4
.IX Item "$dir->tempfile(...)"
An interface to \f(CW\*(C`File::Temp\*(C'\fR's \f(CW\*(C`tempfile()\*(C'\fR function.  Just like
that function, if you call this in a scalar context, the return value
is the filehandle and the file is \f(CW\*(C`unlink\*(C'\fRed as soon as possible
(which is immediately on Unix-like platforms).  If called in a list
context, the return values are th