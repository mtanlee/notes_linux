e is returned by default. (See \*(L"FetchHashKeyName\*(R"
attribute.) If the \f(CW$slice\fR hash is \fInot\fR empty, then it is used as a slice to
select individual columns by name. The values of the hash should be set to 1.
The key names of the returned hashes match the letter case of the names in the
parameter hash, regardless of the \*(L"FetchHashKeyName\*(R" attribute.
.PP
For example, to fetch all fields of every row as a hash ref:
.PP
.Vb 1
\&  $tbl_ary_ref = $sth\->fetchall_arrayref({});
.Ve
.PP
To fetch only the fields called \*(L"foo\*(R" and \*(L"bar\*(R" of every row as a hash ref
(with keys named \*(L"foo\*(R" and \*(L"\s-1BAR\s0\*(R", regardless of the original capitalization):
.PP
.Vb 1
\&  $tbl_ary_ref = $sth\->fetchall_arrayref({ foo=>1, BAR=>1 });
.Ve
.PP
Those two examples both return a reference to an array of hash refs.
.PP
If \f(CW$slice\fR is a \fIreference to a hash reference\fR, that hash is used to select
and rename columns. The keys are 0\-based column index numbers and the values
are the corresponding keys for the returned row hashes.
.PP
For example, to fetch only the first and second columns of every row as a hash
ref (with keys named \*(L"k\*(R" and \*(L"v\*(R" regardless of their original names):
.PP
.Vb 1
\&  $tbl_ary_ref = $sth\->fetchall_arrayref( \e{ 0 => \*(Aqk\*(Aq, 1 => \*(Aqv\*(Aq } );
.Ve
.PP
If \f(CW$max_rows\fR is defined and greater than or equal to zero then it
is used to limit the number of rows fetched before returning.
\&\fIfetchall_arrayref()\fR can then be called again to fetch more rows.
This is especially useful when you need the better performance of
\&\fIfetchall_arrayref()\fR but don't have enough memory to fetch and return
all the rows in one go.
.PP
Here's an example (assumes RaiseError is enabled):
.PP
.Vb 6
\&  my $rows = []; # cache for batches of rows
\&  while( my $row = ( shift(@$rows) || # get row from cache, or reload cache:
\&                     shift(@{$rows=$sth\->fetchall_arrayref(undef,10_000)||[]}) )
\&  ) {
\&    ...
\&  }
.Ve
.PP
That \fImight\fR be the fastest way to fetch and process lots of rows using the \s-1DBI\s0,
but it depends on the relative cost of method calls vs memory allocation.
.PP
A standard \f(CW\*(C`while\*(C'\fR loop with column binding is often faster because
the cost of allocating memory for the batch of rows is greater than
the saving by reducing method calls. It's possible that the \s-1DBI\s0 may
provide a way to reuse the memory of a previous batch in future, which
would then shift the balance back towards \fIfetchall_arrayref()\fR.
.PP
\fI\f(CI\*(C`fetchall_hashref\*(C'\fI\fR
.IX Subsection "fetchall_hashref"
.PP
.Vb 1
\&  $hash_ref = $sth\->fetchall_hashref($key_field);
.Ve
.PP
The \f(CW\*(C`fetchall_hashref\*(C'\fR method can be used to fetch all the data to be
returned from a prepared and executed statement handle. It returns a reference
to a hash containing a key for each distinct value of the \f(CW$key_field\fR column
that was fetched. For each key the corresponding value is a reference to a hash
containing all the selected columns and their values, as returned by
\&\f(CW\*(C`fetchrow_hashref()\*(C'\fR.
.PP
If there are no rows to return, \f(CW\*(C`fetchall_hashref\*(C'\fR returns a reference
to an empty hash. If an error occurs, \f(CW\*(C`fetchall_hashref\*(C'\fR returns the
data fetched thus far, which may be none.  You should check
\&\f(CW\*(C`$sth\->err\*(C'\fR afterwards (or use the \f(CW\*(C`RaiseError\*(C'\fR attribute) to
discover if the data is complete or was truncated due to an error.
.PP
The \f(CW$key_field\fR parameter provides the name of the field that holds the
value to be used for the key for the returned hash.  For example:
.PP
.Vb 5
\&  $dbh\->{FetchHashKeyName} = \*(AqNAME_lc\*(Aq;
\&  $sth = $dbh\->prepare("SELECT FOO, BAR, ID, NAME, BAZ FROM TABLE");
\&  $sth\->execute;
\&  $hash_ref = $sth\->fetchall_hashref(\*(Aqid\*(Aq);
\&  print "Name for id 42 is $hash_ref\->{42}\->{name}\en";
.Ve
.PP
The \f(CW$key_field\fR parameter can also be specified as an integer column
number (counting from 1).  If \f(CW$key_field\fR doesn't match any column in
the statement, as a name first then as a number, then an error is
returned.
.PP
For queries returning more than one 'key' column, you can specify
multiple column names by passing \f(CW$key_field\fR as a reference to an
array containing one or more key column names (or index numbers).
For example:
.PP
.Vb 4
\&  $sth = $dbh\->prepare("SELECT foo, bar, baz FROM table");
\&  $sth\->execute;
\&  $hash_ref = $sth\->fetchall_hashref( [ qw(foo bar) ] );
\&  print "For foo 42 and bar 38, baz is $hash_ref\->{42}\->{38}\->{baz}\en";
.Ve
.PP
The \fIfetchall_hashref()\fR method is normally used only where the key
fields values for each row are unique.  If multiple rows are returned
with the same values for the key fields then later rows overwrite
earlier ones.
.PP
\fI\f(CI\*(C`finish\*(C'\fI\fR
.IX Subsection "finish"
.PP
.Vb 1
\&  $rc  = $sth\->finish;
.Ve
.PP
Indicate that no more data will be fetched from this statement handle
before it is either executed again or destroyed.  You almost certainly
do \fInot\fR need to call this method.
.PP
Adding calls to \f(CW\*(C`finish\*(C'\fR after loop that fetches all rows is a common mistake,
don't do it, it can mask genuine problems like uncaught fetch errors.
.PP
When all the data has been fetched from a \f(CW\*(C`SELECT\*(C'\fR statement, the driver will
automatically call \f(CW\*(C`finish\*(C'\fR for you. So you should \fInot\fR call it explicitly
\&\fIexcept\fR when you know that you've not fetched all the data from a statement
handle \fIand\fR the handle won't be destroyed soon.
.PP
The most common example is when you only want to fetch just one row,
but in that case the \f(CW\*(C`selectrow_*\*(C'\fR methods are usually better anyway.
.PP
Consider a query like:
.PP
.Vb 1
\&  SELECT foo FROM table WHERE bar=? ORDER BY baz
.Ve
.PP
on a very large table. When executed, the database server will have to use
temporary buffer space to store the sorted rows. If, after executing
the handle and selecting just a few rows, the handle won't be re-executed for
some time and won't be destroyed, the \f(CW\*(C`finish\*(C'\fR method can be used to tell
the server that the buffer space can be freed.
.PP
Calling \f(CW\*(C`finish\*(C'\fR resets the \*(L"Active\*(R" attribute for the statement.  It
may also make some statement handle attributes (such as \f(CW\*(C`NAME\*(C'\fR and \f(CW\*(C`TYPE\*(C'\fR)
unavailable if they have not already been accessed (and thus cached).
.PP
The \f(CW\*(C`finish\*(C'\fR method does not affect the transaction status of the
database connection.  It has nothing to do with transactions. It's mostly an
internal \*(L"housekeeping\*(R" method that is rarely needed.
See also \*(L"disconnect\*(R" and the \*(L"Active\*(R" attribute.
.PP
The \f(CW\*(C`finish\*(C'\fR method should have been called \f(CW\*(C`discard_pending_rows\*(C'\fR.
.PP
\fI\f(CI\*(C`rows\*(C'\fI\fR
.IX Subsection "rows"
.PP
.Vb 1
\&  $rv = $sth\->rows;
.Ve
.PP
Returns the number of rows affected by the last row affecting command,
or \-1 if the number of rows is not known or not available.
.PP
Generally, you can only rely on a row count after a \fInon\fR\-\f(CW\*(C`SELECT\*(C'\fR
\&\f(CW\*(C`execute\*(C'\fR (for some specific operations like \f(CW\*(C`UPDATE\*(C'\fR and \f(CW\*(C`DELETE\*(C'\fR), or
after fetching all the rows of a \f(CW\*(C`SELECT\*(C'\fR statement.
.PP
For \f(CW\*(C`SELECT\*(C'\fR statements, it is generally not possible to know how many
rows will be returned except by fetching them all.  Some drivers will
return the number of rows the application has fetched so far, but
others may return \-1 until all rows have been fetched.  So use of the
\&\f(CW\*(C`rows\*(C'\fR method or \f(CW$DBI::rows\fR with \f(CW\*(C`SELECT\*(C'\fR statements is not
recommended.
.PP
One alternative method to get a row count for a \f(CW\*(C`SELECT\*(C'\fR is to execute a
\&\*(L"\s-1SELECT\s0 \s-1COUNT\s0(*) \s-1FROM\s0 ...\*(R" \s-1SQL\s0 statement with the same \*(L"...\*(R" as your
query and then fetch the row count from that.
.PP
\fI\f(CI\*(C`bind_col\*(C'\fI\fR
.IX Subsection "bind_col"
.PP
.Vb 3
\&  $rc = $sth\->bind_col($column_number, \e$var_to_bind);
\&  $rc = $sth\->bind_col($column_number, \e$var_to_bind, \e%attr );
\&  $rc = $sth\->bind_col($column_number, \e$var_to_bind, $bind_type );
.Ve
.PP
Binds a Perl variable and/or some attributes to an output column
(field) of a \f(CW\*(C`SELECT\*(C'\fR statement.  Column numbers count up from 1.
You do not need to bind output columns in order to fetch data.
For maximum portability between drivers, \fIbind_col()\fR should be called
after \fIexecute()\fR and not before.
See also \*(L"bind_columns\*(R" for an example.
.PP
The binding is performed at a low level using Perl aliasing.
Whenever a row is fetched from the database \f(CW$var_to_bind\fR appears
to be automatically updated simply because it now refers to the same
memory location as the corresponding column value.  This makes using
bound variables very efficient.
Binding a tied variable doesn't work, currently.
.PP
The \*(L"bind_param\*(R" method
performs a similar, but opposite, function for input variables.
.PP
\&\fBData Types for Column Binding\fR
.PP
The \f(CW\*(C`\e%attr\*(C'\fR parameter can be used to hint at the data type
formatting the column should have. For example, you can use:
.PP
.Vb 1
\&  $sth\->bind_col(1, undef, { TYPE => SQL_DATETIME });
.Ve
.PP
to specify that you'd like the column (which presumably is some
kind of datetime type) to be returned in the standard format for
\&\s-1SQL_DATETIME\s0, which is '\s-1YYYY\-MM\-DD\s0 \s-1HH:MM:SS\s0', rather than the
native formatting the database would normally use.
.PP
There's no \f(CW$var_to_bind\fR in that example to emphasize the point
that \fIbind_col()\fR works on the underlying column and not just
a particular bound variable.
.PP
As a short-cut for the common case, the data type can be passed
directly, in place of the \f(CW\*(C`\e%attr\*(C'\fR hash reference. This example is
equivalent to the one above:
.PP
.Vb 1
\&  $sth\->bind_col(1, undef, SQL_DATETIME);
.Ve
.PP
The \f(CW\*(C`TYPE\*(C'\fR value indicates the standard (non-driver-specific) type for
this parameter. To specify the driver-specific type, the driver may
support a driver-specific attribute, such as \f(CW\*(C`{ ora_type => 97 }\*(C'\fR.
.PP
The \s-1SQL_DATETIME\s0 and other related constants can be imported using
.PP
.Vb 1
\&  use DBI qw(:sql_types);
.Ve
.PP
See \*(L"\s-1DBI\s0 Constants\*(R" for more information.
.PP
Few drivers support specifying a data type via a \f(CW\*(C`bind_col\*(C'\fR call
(most will simply ignore the data type). Fewer still allow the data
type to be altered once set.
.PP
The \s-1TYPE\s0 attribute for \fIbind_col()\fR was first specified in \s-1DBI\s0 1.41.
.PP
From \s-1DBI\s0 1.611, drivers can use the \f(CW\*(C`TYPE\*(C'\fR attribute to attempt to
cast the bound scalar to a perl type which more closely matches
\&\f(CW\*(C`TYPE\*(C'\fR. At present \s-1DBI\s0 supports \f(CW\*(C`SQL_INTEGER\*(C'\fR, \f(CW\*(C`SQL_DOUBLE\*(C'\fR and
\&\f(CW\*(C`SQL_NUMERIC\*(C'\fR. See \*(L"sql_type_cast\*(R" for details of how types are
cast.
.PP
\&\fBOther attributes for Column Binding\fR
.PP
The \f(CW\*(C`\e%attr\*(C'\fR parameter may also contain the following attributes:
.ie n .IP """StrictlyTyped""" 4
.el .IP "\f(CWStrictlyTyped\fR" 4
.IX Item "StrictlyTyped"
If a \f(CW\*(C`TYPE\*(C'\fR attribute is passed to bind_col, then the driver will
attempt to change the bound perl scalar to match the type more
closely. If the bound value cannot be cast to the requested \f(CW\*(C`TYPE\*(C'\fR
then by default it is left untouched and no error is generated. If you
specify \f(CW\*(C`StrictlyTyped\*(C'\fR as 1 and the cast fails, this will generate
an error.
.Sp
This attribute was first added in \s-1DBI\s0 1.611. When 1.611 was released
few drivers actually supported this attribute but DBD::Oracle and
\&\s-1DBD::ODBC\s0 should from versions 1.24.
.ie n .IP """DiscardString""" 4
.el .IP "\f(CWDiscardString\fR" 4
.IX Item "DiscardString"
When the \f(CW\*(C`TYPE\*(C'\fR attribute is passed to \*(L"bind_col\*(R" and the driver
successfully casts the bound perl scalar to a non-string type
then if \f(CW\*(C`DiscardString\*(C'\fR is set to 1, the string portion of the
scalar will be discarded. By default, \f(CW\*(C`DiscardString\*(C'\fR is not set.
.Sp
This attribute was first added in \s-1DBI\s0 1.611. When 1.611 was released
few drivers actually supported this attribute but DBD::Oracle and
\&\s-1DBD::ODBC\s0 should from versions 1.24.
.PP
\fI\f(CI\*(C`bind_columns\*(C'\fI\fR
.IX Subsection "bind_columns"
.PP
.Vb 1
\&  $rc = $sth\->bind_columns(@list_of_refs_to_vars_to_bind);
.Ve
.PP
Calls \*(L"bind_col\*(R" for each column of the \f(CW\*(C`SELECT\*(C'\fR statement.
.PP
The list of references should have the same number of elements as the number of
columns in the \f(CW\*(C`SELECT\*(C'\fR statement. If it doesn't then \f(CW\*(C`bind_columns\*(C'\fR will
bind the elements given, up to the number of columns, and then return an error.
.PP
For maximum portability between drivers, \fIbind_columns()\fR should be called
after \fIexecute()\fR and not before.
.PP
For example:
.PP
.Vb 4
\&  $dbh\->{RaiseError} = 1; # do this, or check every call for errors
\&  $sth = $dbh\->prepare(q{ SELECT region, sales FROM sales_by_region });
\&  $sth\->execute;
\&  my ($region, $sales);
\&
\&  # Bind Perl variables to columns:
\&  $rv = $sth\->bind_columns(\e$region, \e$sales);
\&
\&  # you can also use Perl\*(Aqs \e(...) syntax (see perlref docs):
\&  #     $sth\->bind_columns(\e($region, $sales));
\&
\&  # Column binding is the most efficient way to fetch data
\&  while ($sth\->fetch) {
\&      print "$region: $sales\en";
\&  }
.Ve
.PP
For compatibility with old scripts, the first parameter will be
ignored if it is \f(CW\*(C`undef\*(C'\fR or a hash reference.
.PP
Here's a more fancy example that binds columns to the values \fIinside\fR
a hash (thanks to H.Merijn Brand):
.PP
.Vb 6
\&  $sth\->execute;
\&  my %row;
\&  $sth\->bind_columns( \e( @row{ @{$sth\->{NAME_lc} } } ));
\&  while ($sth\->fetch) {
\&      print "$row{region}: $row{sales}\en";
\&  }
.Ve
.PP
\fI\f(CI\*(C`dump_results\*(C'\fI\fR
.IX Subsection "dump_results"
.PP
.Vb 1
\&  $rows = $sth\->dump_results($maxlen, $lsep, $fsep, $fh);
.Ve
.PP
Fetches all the rows from \f(CW$sth\fR, calls \f(CW\*(C`DBI::neat_list\*(C'\fR for each row, and
prints the results to \f(CW$fh\fR (defaults to \f(CW\*(C`STDOUT\*(C'\fR) separated by \f(CW$lsep\fR
(default \f(CW"\en"\fR). \f(CW$fsep\fR defaults to \f(CW", "\fR and \f(CW$maxlen\fR defaults to 35.
.PP
This method is designed as a handy utility for prototyping and
testing queries. Since it uses \*(L"neat_list\*(R" to
format and edit the string for reading by humans, it is not recommended
for data transfer applications.
.SS "Statement Handle Attributes"
.IX Subsection "Statement Handle Attributes"
This section describes attributes specific to statement handles. Most
of these attributes are read-only.
.PP
Changes to these statement handle attributes do not affect any other
existing or future statement handles.
.PP
Attempting to set or get the value of an unknown attribute generates a warning,
except for private driver specific attributes (which all have names
starting with a lowercase letter).
.PP
Example:
.PP
.Vb 1
\&  ... = $h\->{NUM_OF_FIELDS};    # get/read
.Ve
.PP
Some drivers cannot provide valid values for some or all of these
attributes until after \f(CW\*(C`$sth\->execute\*(C'\fR has been successfully
called. Typically the attribute will be \f(CW\*(C`undef\*(C'\fR in these situations.
.PP
Some attributes, like \s-1NAME\s0, are not appropriate to some types of
statement, like \s-1SELECT\s0. Typically the attribute will be \f(CW\*(C`undef\*(C'\fR
in these situations.
.PP
For drivers which support stored procedures and multiple result sets
(see \*(L"more_results\*(R") these attributes relate to the \fIcurrent\fR result set.
.PP
See also \*(L"finish\*(R" to learn more about the effect it
may have on some attributes.
.PP
\fI\f(CI\*(C`NUM_OF_FIELDS\*(C'\fI\fR
.IX Subsection "NUM_OF_FIELDS"
.PP
Type: integer, read-only
.PP
Number of fields (columns) in the data the prepared statement may return.
Statements that don't return rows of data, like \f(CW\*(C`DELETE\*(C'\fR and \f(CW\*(C`CREATE\*(C'\fR
set \f(CW\*(C`NUM_OF_FIELDS\*(C'\fR to 0 (though it may be undef in some drivers).
.PP
\fI\f(CI\*(C`NUM_OF_PARAMS\*(C'\fI\fR
.IX Subsection "NUM_OF_PARAMS"
.PP
Type: integer, read-only
.PP
The number of parameters (placeholders) in the prepared statement.
See \s-1SUBSTITUTION\s0 \s-1VARIABLES\s0 below for more details.
.PP
\fI\f(CI\*(C`NAME\*(C'\fI\fR
.IX Subsection "NAME"
.PP
Type: array-ref, read-only
.PP
Returns a reference to an array of field names for each column. The
names may contain spaces but should not be truncated or have any
trailing space. Note that the names have the letter case (upper, lower
or mixed) as returned by the driver being used. Portable applications
should use \*(L"NAME_lc\*(R" or \*(L"NAME_uc\*(R".
.PP
.Vb 1
\&  print "First column name: $sth\->{NAME}\->[0]\en";
.Ve
.PP
Also note that the name returned for (aggregate) functions like \f(CWcount(*)\fR
or \f(CW\*(C`max(c_foo)\*(C'\fR is determined by the database server and not by \f(CW\*(C`DBI\*(C'\fR or
the \f(CW\*(C`DBD\*(C'\fR backend.
.PP
\fI\f(CI\*(C`NAME_lc\*(C'\fI\fR
.IX Subsection "NAME_lc"
.PP
Type: array-ref, read-only
.PP
Like \*(L"\s-1NAME\s0\*(R" but always returns lowercase names.
.PP
\fI\f(CI\*(C`NAME_uc\*(C'\fI\fR
.IX Subsection "NAME_uc"
.PP
Type: array-ref, read-only
.PP
Like \*(L"\s-1NAME\s0\*(R" but always returns uppercase names.
.PP
\fI\f(CI\*(C`NAME_hash\*(C'\fI\fR
.IX Subsection "NAME_hash"
.PP
Type: hash-ref, read-only
.PP
\fI\f(CI\*(C`NAME_lc_hash\*(C'\fI\fR
.IX Subsection "NAME_lc_hash"
.PP
Type: hash-ref, read-only
.PP
\fI\f(CI\*(C`NAME_uc_hash\*(C'\fI\fR
.IX Subsection "NAME_uc_hash"
.PP
Type: hash-ref, read-only
.PP
The \f(CW\*(C`NAME_hash\*(C'\fR, \f(CW\*(C`NAME_lc_hash\*(C'\fR, and \f(CW\*(C`NAME_uc_hash\*(C'\fR attributes
return column name information as a reference to a hash.
.PP
The keys of the hash are the names of the columns.  The letter case of
the keys corresponds to the letter case returned by the \f(CW\*(C`NAME\*(C'\fR,
\&\f(CW\*(C`NAME_lc\*(C'\fR, and \f(CW\*(C`NAME_uc\*(C'\fR attributes respectively (as described above).
.PP
The value of each hash entry is the perl index number of the
corresponding column (counting from 0). For example:
.PP
.Vb 4
\&  $sth = $dbh\->prepare("select Id, Name from table");
\&  $sth\->execute;
\&  @row = $sth\->fetchrow_array;
\&  print "Name $row[ $sth\->{NAME_lc_hash}{name} ]\en";
.Ve
.PP
\fI\f(CI\*(C`TYPE\*(C'\fI\fR
.IX Subsection "TYPE"
.PP
Type: array-ref, read-only
.PP
Returns a reference to an array of integer values for each
column. The value indicates the data type of the corresponding column.
.PP
The values correspond to the international standards (\s-1ANSI\s0 X3.135
and \s-1ISO/IEC\s0 9075) which, in general terms, means \s-1ODBC\s0. Driver-specific
types that don't exactly match standard types should generally return
the same values as an \s-1ODBC\s0 driver supplied by the makers of the
database. That might include private type numbers in ranges the vendor
has officially registered with the \s-1ISO\s0 working group:
.PP
.Vb 1
\&  ftp://sqlstandards.org/SC32/SQL_Registry/
.Ve
.PP
Where there's no vendor-supplied \s-1ODBC\s0 driver to be compatible with,
the \s-1DBI\s0 driver can use type numbers in the range that is now
officially reserved for use by the \s-1DBI:\s0 \-9999 to \-9000.
.PP
All possible values for \f(CW\*(C`TYPE\*(C'\fR should have at least one entry in the
output of the \f(CW\*(C`type_info_all\*(C'\fR method (see \*(L"type_info_all\*(R").
.PP
\fI\f(CI\*(C`PRECISION\*(C'\fI\fR
.IX Subsection "PRECISION"
.PP
Type: array-ref, read-only
.PP
Returns a reference to an array of integer values for each column.
.PP
For numeric columns, the value is the maximum number of digits
(without considering a sign character or decimal point). Note that
the \*(L"display size\*(R" for floating point types (\s-1REAL\s0, \s-1FLOAT\s0, \s-1DOUBLE\s0)
can be up to 7 characters greater than the precision (for the
sign + decimal point + the letter E + a sign + 2 or 3 digits).
.PP
For any character type column the value is the \s-1OCTET_LENGTH\s0,
in other words the number of bytes, not characters.
.PP
(More recent standards refer to this as \s-1COLUMN_SIZE\s0 but we stick
with \s-1PRECISION\s0 for backwards compatibility.)
.PP
\fI\f(CI\*(C`SCALE\*(C'\fI\fR
.IX Subsection "SCALE"
.PP
Type: array-ref, read-only
.PP
Returns a reference to an array of integer values for each column.
\&\s-1NULL\s0 (\f(CW\*(C`undef\*(C'\fR) values indicate columns where scale is not applicable.
.PP
\fI\f(CI\*(C`NULLABLE\*(C'\fI\fR
.IX Subsection "NULLABLE"
.PP
Type: array-ref, read-only
.PP
Returns a reference to an array indicating the possibility of each
column returning a null.  Possible values are \f(CW0\fR
(or an empty string) = no, \f(CW1\fR = yes, \f(CW2\fR = unknown.
.PP
.Vb 1
\&  print "First column may return NULL\en" if $sth\->{NULLABLE}\->[0];
.Ve
.PP
\fI\f(CI\*(C`CursorName\*(C'\fI\fR
.IX Subsection "CursorName"
.PP
Type: string, read-only
.PP
Returns the name of the cursor associated with the statement handle, if
available. If not available or if the database driver does not support the
\&\f(CW"where current of ..."\fR \s-1SQL\s0 syntax, then it returns \f(CW\*(C`undef\*(C'\fR.
.PP
\fI\f(CI\*(C`Database\*(C'\fI\fR
.IX Subsection "Database"
.PP
Type: dbh, read-only
.PP
Returns the parent \f(CW$dbh\fR of the statement handle.
.PP
\fI\f(CI\*(C`Statement\*(C'\fI\fR
.IX Subsection "Statement"
.PP
Type: string, read-only
.PP
Returns the statement string passed to the \*(L"prepare\*(R" method.
.PP
\fI\f(CI\*(C`ParamValues\*(C'\fI\fR
.IX Subsection "ParamValues"
.PP
Type: hash ref, read-only
.PP
Returns a reference to a hash containing the values currently bound
to placeholders.  The keys of the hash are the 'names' of the
placeholders, typically integers starting at 1.  Returns undef if
not supported by the driver.
.PP
See \*(L"ShowErrorStatement\*(R" for an example of how this is used.
.PP
* Keys:
.PP
If the driver supports \f(CW\*(C`ParamValues\*(C'\fR but no values have been bound
yet then the driver should return a hash with placeholders names
in the keys but all the values undef, but some drivers may return
a ref to an empty hash because they can't pre-determine the names.
.PP
It is possible that the keys in the hash returned by \f(CW\*(C`ParamValues\*(C'\fR
are not exactly the same as those implied by the prepared statement.
For example, DBD::Oracle translates '\f(CW\*(C`?\*(C'\fR' placeholders into '\f(CW\*(C`:pN\*(C'\fR'
where N is a sequence number starting at 1.
.PP
* Values:
.PP
It is possible that the values in the hash returned by \f(CW\*(C`ParamValues\*(C'\fR
are not \fIexactly\fR the same as those passed to \fIbind_param()\fR or \fIexecute()\fR.
The driver may have slightly modified values in some way based on the
\&\s-1TYPE\s0 the value was bound with. For example a floating point value
bound as an \s-1SQL_INTEGER\s0 type may be returned as an integer.
The values returned by \f(CW\*(C`ParamValues\*(C'\fR can be passed to another
\&\fIbind_param()\fR method with the same \s-1TYPE\s0 and will be seen by the
database as the same value. See also \*(L"ParamTypes\*(R" below.
.PP
The \f(CW\*(C`ParamValues\*(C'\fR attribute was added in \s-1DBI\s0 1.28.
.PP
\fI\f(CI\*(C`ParamTypes\*(C'\fI\fR
.IX Subsection "ParamTypes"
.PP
Type: hash ref, read-only
.PP
Returns a reference to a hash containing the type information
currently bound to placeholders.
Returns undef if not supported by the driver.
.PP
* Keys:
.PP
See \*(L"ParamValues\*(R" above.
.PP
* Values:
.PP
The hash values are hashrefs of type information in the same form as that
passed to the various \fIbind_param()\fR methods (See \*(L"bind_param\*(R" for the format
and values).
.PP
It is possible that the values in the hash returned by \f(CW\*(C`ParamTypes\*(C'\fR
are not exactly the same as those passed to \fIbind_param()\fR or \fIexecute()\fR.
Param attributes specified using the abbreviated form, like this:
.PP
.Vb 1
\&    $sth\->bind_param(1, SQL_INTEGER);
.Ve
.PP
are returned in the expanded form, as if called like this:
.PP
.Vb 1
\&    $sth\->bind_param(1, { TYPE => SQL_INTEGER });
.Ve
.PP
The driver may have modified the type information in some way based
on the bound values, other hints provided by the \fIprepare()\fR'd
\&\s-1SQL\s0 statement, or alternate type mappings required by the driver or target
database system. The driver may also add private keys (with names beginning
with the drivers reserved prefix, e.g., odbc_xxx).
.PP
* Example:
.PP
The keys and values in the returned hash can be passed to the various
\&\fIbind_param()\fR methods to effectively reproduce a previous param binding.
For example:
.PP
.Vb 7
\&  # assuming $sth1 is a previously prepared statement handle
\&  my $sth2 = $dbh\->prepare( $sth1\->{Statement} );
\&  my $ParamValues = $sth1\->{ParamValues} || {};
\&  my $ParamTypes  = $sth1\->{ParamTypes}  || {};
\&  $sth2\->bind_param($_, $ParamValues\->{$_} $ParamTypes\->{$_})
\&    for keys %{ {%$ParamValues, %$ParamTypes} };
\&  $sth2\->execute();
.Ve
.PP
The \f(CW\*(C`ParamTypes\*(C'\fR attribute was added in \s-1DBI\s0 1.49. Implementation
is the responsibility of individual drivers; the \s-1DBI\s0 layer default
implementation simply returns undef.
.PP
\fI\f(CI\*(C`ParamArrays\*(C'\fI\fR
.IX Subsection "ParamArrays"
.PP
Type: hash ref, read-only
.PP
Returns a reference to a hash containing the values currently bound to
placeholders with \*(L"execute_array\*(R" or \*(L"bind_param_array\*(R".  The
keys of the hash are the 'names' of the placeholders, typically
integers starting at 1.  Returns undef if not supported by the driver
or no arrays of parameters are bound.
.PP
Each key value is an array reference containing a list of the bound
parameters for that column.
.PP
For example:
.PP
.Vb 8
\&  $sth = $dbh\->prepare("INSERT INTO staff (id, name) values (?,?)");
\&  $sth\->execute_array({},[1,2], [\*(Aqfred\*(Aq,\*(Aqdave\*(Aq]);
\&  if ($sth\->{ParamArrays}) {
\&      foreach $param (keys %{$sth\->{ParamArrays}}) {
\&          printf "Parameters for %s : %s\en", $param,
\&          join(",", @{$sth\->{ParamArrays}\->{$param}});
\&      }
\&  }
.Ve
.PP
It is possible that the values in the hash returned by \f(CW\*(C`ParamArrays\*(C'\fR
are not \fIexactly\fR the same as those passed to \*(L"bind_param_array\*(R" or
\&\*(L"execute_array\*(R".  The driver may have slightly modified values in some
way based on the \s-1TYPE\s0 the value was bound with. For example a floating
point value bound as an \s-1SQL_INTEGER\s0 type may be returned as an
integer.
.PP
It is also possible that the keys in the hash returned by
\&\f(CW\*(C`ParamArrays\*(C'\fR are not exactly the same as those implied by the
prepared statement.  For example, DBD::Oracle translates '\f(CW\*(C`?\*(C'\fR'
placeholders into '\f(CW\*(C`:pN\*(C'\fR' where N is a sequence number starting at 1.
.PP
\fI\f(CI\*(C`RowsInCache\*(C'\fI\fR
.IX Subsection "RowsInCache"
.PP
Type: integer, read-only
.PP
If the driver supports a local row cache for \f(CW\*(C`SELECT\*(C'\fR statements, then
this attribute holds the number of un-fetched rows in the cache. If the
driver doesn't, then it returns \f(CW\*(C`undef\*(C'\fR. Note that some drivers pre-fetch
rows on execute, whereas others wait till the first fetch.
.PP
See also the \*(L"RowCacheSize\*(R" database handle attribute.
.SH "FURTHER INFORMATION"
.IX Header "FURTHER INFORMATION"
.SS "Catalog Methods"
.IX Subsection "Catalog Methods"
An application can retrieve metadata information from the \s-1DBMS\s0 by issuing
appropriate queries on the views of the Information Schema. Unfortunately,
\&\f(CW\*(C`INFORMATION_SCHEMA\*(C'\fR views are seldom supported by the \s-1DBMS\s0.
Special methods (catalog methods) are available to return result sets
for a small but important portion of that metadata:
.PP
.Vb 5
\&  column_info
\&  foreign_key_info
\&  primary_key_info
\&  table_info
\&  statistics_info
.Ve
.PP
All catalog methods accept arguments in order to restrict the result sets.
Passing \f(CW\*(C`undef\*(C'\fR to an optional argument does not constrain the search for
that argument.
However, an empty string ('') is treated as a regular search criteria
and will only match an empty value.
.PP
\&\fBNote\fR: \s-1SQL/CLI\s0 and \s-1ODBC\s0 differ in the handling of empty strings. An
empty string will not restrict the result set in \s-1SQL/CLI\s0.
.PP
Most arguments in the catalog methods accept only \fIordinary values\fR, e.g.
the arguments of \f(CW\*(C`primary_key_info()\*(C'\fR.
Such arguments are treated as a literal string, i.e. the case is significant
and quote characters are taken literally.
.PP
Some arguments in the catalog methods accept \fIsearch patterns\fR (strings
containing '_' and/or '%'), e.g. the \f(CW$table\fR argument of \f(CW\*(C`column_info()\*(C'\fR.
Passing '%' is equivalent to leaving the argument \f(CW\*(C`undef\*(C'\fR.
.PP
\&\fBCaveat\fR: The underscore ('_') is valid and often used in \s-1SQL\s0 identifiers.
Passing such a value to a search pattern argument may return more rows than
expected!
To include pattern characters as literals, they must be preceded by an
escape character which can be achieved with
.PP
.Vb 2
\&  $esc = $dbh\->get_info( 14 );  # SQL_SEARCH_PATTERN_ESCAPE
\&  $search_pattern =~ s/([_%])/$esc$1/g;
.Ve
.PP
The \s-1ODBC\s0 and \s-1SQL/CLI\s0 specifications define a way to change the default
behaviour described above: All arguments (except \fIlist value arguments\fR)
are treated as \fIidentifier\fR if the \f(CW\*(C`SQL_ATTR_METADATA_ID\*(C'\fR attribute is
set to \f(CW\*(C`SQL_TRUE\*(C'\fR.
\&\fIQuoted identifiers\fR are very similar to \fIordinary values\fR, i.e. their
body (the string within the quotes) is interpreted literally.
\&\fIUnquoted identifiers\fR are compared in \s-1UPPERCASE\s0.
.PP
The \s-1DBI\s0 (currently) does not support the \f(CW\*(C`SQL_ATTR_METADATA_ID\*(C'\fR attribute,
i.e. it behaves like an \s-1ODBC\s0 driver where \f(CW\*(C`SQL_ATTR_METADATA_ID\*(C'\fR is set to
\&\f(CW\*(C`SQL_FALSE\*(C'\fR.
.SS "Transactions"
.IX Subsection "Transactions"
Transactions are a fundamental part of any robust database system. They
protect against errors and database corruption by ensuring that sets of
related changes to the database take place in atomic (indivisible,
all-or-nothing) units.
.PP
This section applies to databases that support transactions and where
\&\f(CW\*(C`AutoCommit\*(C'\fR is off.  See \*(L"AutoCommit\*(R" for details of using \f(CW\*(C`AutoCommit\*(C'\fR
with various types of databases.
.PP
The recommended way to implement robust transactions in Perl
applications is to use \f(CW\*(C`RaiseError\*(C'\fR and \f(CW\*(C`eval\ {\ ...\ }\*(C'\fR
(which is very fast, unlike \f(CW\*(C`eval\ "..."\*(C'\fR). For example:
.PP
.Vb 10
\&  $dbh\->{AutoCommit} = 0;  # enable transactions, if possible
\&  $dbh\->{RaiseError} = 1;
\&  eval {
\&      foo(...)        # do lots of work here
\&      bar(...)        # including inserts
\&      baz(...)        # and updates
\&      $dbh\->commit;   # commit the changes if we get this far
\&  };
\&  if ($@) {
\&      warn "Transaction aborted because $@";
\&      # now rollback to undo the incomplete changes
\&      # but do it in an eval{} as it may also fail
\&      eval { $dbh\->rollback };
\&      # add other application on\-error\-clean\-up code here
\&  }
.Ve
.PP
If the \f(CW\*(C`RaiseError\*(C'\fR attribute is not set, then \s-1DBI\s0 calls would need to be
manually checked for errors, typically like this:
.PP
.Vb 1
\&  $h\->method(@args) or die $h\->errstr;
.Ve
.PP
With \f(CW\*(C`RaiseError\*(C'\fR set, the \s-1DBI\s0 will automatically \f(CW\*(C`die\*(C'\fR if any \s-1DBI\s0 method
call on that handle (or a child handle) fails, so you don't have to
test the return value of each method call. See \*(L"RaiseError\*(R" for more
details.
.PP
A major advantage of the \f(CW\*(C`eval\*(C'\fR approach is that the transaction will be
properly rolled back if \fIany\fR code (not just \s-1DBI\s0 calls) in the inner
application dies for any reason. The major advantage of using the
\&\f(CW\*(C`$h\->{RaiseError}\*(C'\fR attribute is that all \s-1DBI\s0 calls will be checked
automatically. Both techniques are strongly recommended.
.PP
After calling \f(CW\*(C`commit\*(C'\fR or \f(CW\*(C`rollback\*(C'\fR many drivers will not let you
fetch from a previously active \f(CW\*(C`SELECT\*(C'\fR statement handle that's a child
of the same database handle. A typical way round this is to connect the
the database twice and use one connection for \f(CW\*(C`SELECT\*(C'\fR statements.
.PP
See \*(L"AutoCommit\*(R" and \*(L"disconnect\*(R" for other important information
about transactions.
.SS "Handling \s-1BLOB\s0 / \s-1LONG\s0 / Memo Fields"
.IX Subsection "Handling BLOB / LONG / Memo Fields"
Many databases support \*(L"blob\*(R" (binary large objects), \*(L"long\*(R", or similar
datatypes for holding very long strings or large amounts of binary
data in a single field. Some databases support variable length long
values over 2,000,000,000 bytes in length.
.PP
Since values of that size can't usually be held in memory, and because
databases can't usually know in advance the length of the longest long
that will be returned from a \f(CW\*(C`SELECT\*(C'\fR statement (unlike other data
types), some special handling is required.
.PP
In this situation, the value of the \f(CW\*(C`$h\->{LongReadLen}\*(C'\fR
attribute is used to determine how much buffer space to allocate
when fetching such fields.  The \f(CW\*(C`$h\->{LongTruncOk}\*(C'\fR attribute
is used to determine how to behave if a fetched value can't fit
into the buffer.
.PP
See the description of \*(L"LongReadLen\*(R" for more information.
.PP
When trying to insert long or binary values, placeholders should be used
since there are often limits on the maximum size of an \f(CW\*(C`INSERT\*(C'\fR
statement and the \*(L"quote\*(R" method generally can't cope with binary
data.  See \*(L"Placeholders and Bind Values\*(R".
.SS "Simple Examples"
.IX Subsection "Simple Examples"
Here's a complete example program to select and fetch some data:
.PP
.Vb 3
\&  my $data_source = "dbi::DriverName:db_name";
\&  my $dbh = DBI\->connect($data_source, $user, $password)
\&      or die "Can\*(Aqt connect to $data_source: $DBI::errstr";
\&
\&  my $sth = $dbh\->prepare( q{
\&          SELECT name, phone
\&          FROM mytelbook
\&  }) or die "Can\*(Aqt prepare statement: $DBI::errstr";
\&
\&  my $rc = $sth\->execute
\&      or die "Can\*(Aqt execute statement: $DBI::errstr";
\&
\&  print "Query will return $sth\->{NUM_OF_FIELDS} fields.\en\en";
\&  print "Field names: @{ $sth\->{NAME} }\en";
\&
\&  while (($name, $phone) = $sth\->fetchrow_array) {
\&      print "$name: $phone\en";
\&  }
\&  # check for problems which may have terminated the fetch early
\&  die $sth\->errstr if $sth\->err;
\&
\&  $dbh\->disconnect;
.Ve
.PP
Here's a complete example program to insert some data from a file.
(This example uses \f(CW\*(C`RaiseError\*(C'\fR to avoid needing to check each call).
.PP
.Vb 3
\&  my $dbh = DBI\->connect("dbi:DriverName:db_name", $user, $password, {
\&      RaiseError => 1, AutoCommit => 0
\&  });
\&
\&  my $sth = $dbh\->prepare( q{
\&      INSERT INTO table (name, phone) VALUES (?, ?)
\&  });
\&
\&  open FH, "<phone.csv" or die "Unable to open phone.csv: $!";
\&  while (<FH>) {
\&      chomp;
\&      my ($name, $phone) = split /,/;
\&      $sth\->execute($name, $phone);
\&  }
\&  close FH;
\&
\&  $dbh\->commit;
\&  $dbh\->disconnect;
.Ve
.PP
Here's how to convert fetched NULLs (undefined values) into empty strings:
.PP
.Vb 5
\&  while($row = $sth\->fetchrow_arrayref) {
\&    # this is a fast and simple way to deal with nulls:
\&    foreach (@$row) { $_ = \*(Aq\*(Aq unless defined }
\&    print "@$row\en";
\&  }
.Ve
.PP
The \f(CW\*(C`q{...}\*(C'\fR style quoting used in these examples avoids clashing with
quotes that may be used in the \s-1SQL\s0 statement. Use the double-quote like
\&\f(CW\*(C`qq{...}\*(C'\fR operator if you want to interpolate variables into the string.
See \*(L"Quote and Quote-like Operators\*(R" in perlop for more details.
.SS "Threads and Thread Safety"
.IX Subsection "Threads and Thread Safety"
Perl 5.7 and later support a new threading model called iThreads.
(The old \*(L"5.005 style\*(R" threads are not supported by the \s-1DBI\s0.)
.PP
In the iThreads model each thread has it's own copy of the perl
interpreter.  When a new thread is created the original perl
interpreter is 'cloned' to create a new copy for the new thread.
.PP
If the \s-1DBI\s0 and drivers are loaded and handles created before the
thread is created then it will get a cloned copy of the \s-1DBI\s0, the
drivers and the handles.
.PP
However, the internal pointer data within the handles will refer
to the \s-1DBI\s0 and drivers in the original interpreter. Using those
handles in the new interpreter thread is not safe, so the \s-1DBI\s0 detects
this and croaks on any method call using handles that don't belong
to the current thread (except for \s-1DESTROY\s0).
.PP
Because of this (possibly temporary) restriction, newly created
threads must make their own connections to the database. Handles
can't be shared across threads.
.PP
But \s-1BEWARE\s0, some underlying database APIs (the code the \s-1DBD\s0 driver
uses to talk to the database, often supplied by the database vendor)
are not thread safe. If it's not thread safe, then allowing more
than one thread to enter the code at the same time may cause
subtle/serious problems. In some cases allowing more than
one thread to enter the code, even if \fInot\fR at the same time,
can cause problems. You have been warned.
.PP
Using \s-1DBI\s0 with perl threads is not yet recommended for production
environments. For more information see
<http://www.perlmonks.org/index.pl?node_id=288022>
.PP
Note: There is a bug in perl 5.8.2 when configured with threads
and debugging enabled (bug #24463) which causes a \s-1DBI\s0 test to fail.
.SS "Signal Handling and Canceling Operations"
.IX Subsection "Signal Handling and Canceling Operations"
[The following only applies to systems with unix-like signal handling.
I'd welcome additions for other systems, especially Windows.]
.PP
The first thing to say is that signal handling in Perl versions less
than 5.8 is \fInot\fR safe. There is always a small risk of Perl
crashing and/or core dumping when, or after, handling a signal
because the signal could arrive and be handled while internal data
structures are being changed. If the signal handling code
used those same internal data structures it could cause all manner
of subtle and not-so-subtle problems.  The risk was reduced with
5.4.4 but was still present in all perls up through 5.8.0.
.PP
Beginning in perl 5.8.0 perl implements 'safe' signal handling if
your system has the \s-1POSIX\s0 \fIsigaction()\fR routine. Now when a signal
is delivered perl just makes a note of it but does \fInot\fR run the
\&\f(CW%SIG\fR handler. The handling is 'deferred' until a 'safe' moment.
.PP
Although this change made signal handling safe, it also lead to
a problem with signals being deferred for longer than you'd like.
If a signal arrived while executing a system call, such as waiting
for data on a network connection, the signal is noted and then the
system call that was executing returns with an \s-1EINTR\s0 error code
to indicate that it was interrupted. All fine so far.
.PP
The problem comes when the code that made the system call sees the
\&\s-1EINTR\s0 code and decides it's going to call it again. Perl doesn't
do that, but database code sometimes does. If that happens then the
signal handler doesn't get called until later. Maybe much later.
.PP
Fortunately there are ways around this which we'll discuss below.
Unfortunately they make signals unsafe again.
.PP
The two most common uses of signals in relation to the \s-1DBI\s0 are for
canceling operations when the user types Ctrl-C (interrupt), and for
implementing a timeout using \f(CW\*(C`alarm()\*(C'\fR and \f(CW$SIG{ALRM}\fR.
.IP "Cancel" 4
.IX Item "Cancel"
The \s-1DBI\s0 provides a \f(CW\*(C`cancel\*(C'\fR method for statement handles. The
\&\f(CW\*(C`cancel\*(C'\fR method should abort the current operation and is designed
to be called from a signal handler.  For example:
.Sp
.Vb 1
\&  $SIG{INT} = sub { $sth\->cancel };
.Ve
.Sp
However, few drivers implement this (the \s-1DBI\s0 provides a default
method that just returns \f(CW\*(C`undef\*(C'\fR) and, even if implemented, there
is still a possibility that the statement handle, and even the
parent database handle, will not be usable afterwards.
.Sp
If \f(CW\*(C`cancel\*(C'\fR returns true, then it has successfully
invoked the database engine's own cancel function.  If it returns false,
then \f(CW\*(C`cancel\*(C'\fR failed. If it returns \f(CW\*(C`undef\*(C'\fR, then the database
driver does not have cancel implemented \- very few do.
.IP "Timeout" 4
.IX Item "Timeout"
The traditional way to implement a timeout is to set \f(CW$SIG{ALRM}\fR
to refer to some code that will be executed when an \s-1ALRM\s0 signal
arrives and then to call alarm($seconds) to schedule an \s-1ALRM\s0 signal
to be delivered \f(CW$seconds\fR in the future. For example:
.Sp
.Vb 12
\&  eval {
\&    local $SIG{ALRM} = sub { die "TIMEOUT\en" }; # N.B. \en required
\&    eval {
\&      alarm($seconds);
\&      ... code to execute with timeout here (which may die) ...
\&    };
\&    # outer eval catches alarm that might fire JUST before this alarm(0)
\&    alarm(0);  # cancel alarm (if code ran fast)
\&    die "$@" if $@;
\&  };
\&  if ( $@ eq "TIMEOUT\en" ) { ... }
\&  elsif ($@) { ... } # some other error
.Ve
.Sp
The first (outer) eval is used to avoid the unlikely but possible
chance that the \*(L"code to execute\*(R" dies and the alarm fires before it
is cancelled. Without the outer eval, if this happened your program
will die if you have no \s-1ALRM\s0 handler or a non-local alarm handler
will be called.
.Sp
Unfortunately, as described above, this won't always work as expected,
depending on your perl version and the underlying database code.
.Sp
With Oracle for instance (DBD::Oracle), if the system which hosts
the database is down the \s-1DBI\-\s0>\fIconnect()\fR call will hang for several
minutes before returning an error.
.PP
The solution on these systems is to use the \f(CW\*(C`POSIX::sigaction()\*(C'\fR
routine to gain low level access to how the signal handler is installed.
.PP
The code would look something like this (for the DBD-Oracle \fIconnect()\fR):
.PP
.Vb 1
\&   use POSIX qw(:signal_h);
\&
\&   my $mask = POSIX::SigSet\->new( SIGALRM ); # signals to mask in the handler
\&   my $action = POSIX::SigAction\->new(
\&       sub { die "connect timeout\en" },        # the handler code ref
\&       $mask,
\&       # not using (perl 5.8.2 and later) \*(Aqsafe\*(Aq switch or sa_flags
\&   );
\&   my $oldaction = POSIX::SigAction\->new();
\&   sigaction( SIGALRM, $action, $oldaction );
\&   my $dbh;
\&   eval {
\&      eval {
\&        alarm(5); # seconds before time out
\&        $dbh = DBI\->connect("dbi:Oracle:$dsn" ... );
\&      };
\&      alarm(0); # cancel alarm (if connect worked fast)
\&      die "$@\en" if $@; # connect died
\&   };
\&   sigaction( SIGALRM, $oldaction );  # restore original signal handler
\&   if ( $@ ) {
\&     if ($@ eq "connect timeout\en") {...}
\&     else { # connect died }
\&   }
.Ve
.PP
See previous example for the reasoning around the double eval.
.PP
Similar techniques can be used for canceling statement execution.
.PP
Unfortunately, this solution is somewhat messy, and it does \fInot\fR work with
perl versions less than perl 5.8 where \f(CW\*(C`POSIX::sigaction()\*(C'\fR appears to be broken.
.PP
For a cleaner implementation that works across perl versions, see Lincoln Baxter's
Sys::SigAction module at http://search.cpan.org/~lbaxter/Sys\-SigAction/ <http://search.cpan.org/~lbaxter/Sys-SigAction/>.
The documentation for Sys::SigAction includes an longer discussion
of this problem, and a DBD::Oracle test script.
.PP
Be sure to read all the signal handling sections of the perlipc manual.
.PP
And finally, two more points to keep firmly in mind. Firstly,
remember that what we've done here is essentially revert to old
style \fIunsafe\fR handling of these signals. So do as little as
possible in the handler.  Ideally just \fIdie()\fR. Secondly, the handles
in use at the time the signal is handled may not be safe to use
afterwards.
.SS "Subclassing the \s-1DBI\s0"
.IX Subsection "Subclassing the DBI"
\&\s-1DBI\s0 can be subclassed and extended just like any other object
oriented module.  Before we talk about how to do that, it's important
to be clear about the various \s-1DBI\s0 classes and how they work together.
.PP
By default \f(CW\*(C`$dbh = DBI\->connect(...)\*(C'\fR returns a \f(CW$dbh\fR blessed
into the \f(CW\*(C`DBI::db\*(C'\fR class.  And the \f(CW\*(C`$dbh\->prepare\*(C'\fR method
returns an \f(CW$sth\fR blessed into the \f(CW\*(C`DBI::st\*(C'\fR class (actually it
simply changes the last four characters of the calling handle class
to be \f(CW\*(C`::st\*(C'\fR).
.PP
The leading '\f(CW\*(C`DBI\*(C'\fR' is known as the 'root class' and the extra
\&'\f(CW\*(C`::db\*(C'\fR' or '\f(CW\*(C`::st\*(C'\fR' are the 'handle type suffixes'. If you want
to subclass the \s-1DBI\s0 you'll need to put your overriding methods into
the appropriate classes.  For example, if you want to use a root class
of \f(CW\*(C`MySubDBI\*(C'\fR and override the \fIdo()\fR, \fIprepare()\fR and \fIexecute()\fR methods,
then your \fIdo()\fR and \fIprepare()\fR methods should be in the \f(CW\*(C`MySubDBI::db\*(C'\fR
class and the \fIexecute()\fR method should be in the \f(CW\*(C`MySubDBI::st\*(C'\fR class.
.PP
To setup the inheritance hierarchy the \f(CW@ISA\fR variable in \f(CW\*(C`MySubDBI::db\*(C'\fR
should include \f(CW\*(C`DBI::db\*(C'\fR and the \f(CW@ISA\fR variable in \f(CW\*(C`MySubDBI::st\*(C'\fR
should include \f(CW\*(C`DBI::st\*(C'\fR.  The \f(CW\*(C`MySubDBI\*(C'\fR root class itself isn't
currently used for anything visible and so, apart from setting \f(CW@ISA\fR
to include \f(CW\*(C`DBI\*(C'\fR, it can be left empty.
.PP
So, having put your overriding methods into the right classes, and
setup the inheritance hierarchy, how do you get the \s-1DBI\s0 to use them?
You have two choices, either a static method call using the name
of your subclass:
.PP
.Vb 1
\&  $dbh = MySubDBI\->connect(...);
.Ve
.PP
or specifying a \f(CW\*(C`RootClass\*(C'\fR attribute:
.PP
.Vb 1
\&  $dbh = DBI\->connect(..., { RootClass => \*(AqMySubDBI\*(Aq });
.Ve
.PP
If both forms are used then the attribute takes precedence.
.PP
The only differences between the two are that using an explicit
RootClass attribute will a) make the \s-1DBI\s0 automatically attempt to load
a module by that name if the class doesn't exist, and b) won't call
your \fIMySubDBI::connect()\fR method, if you have one.
.PP
When subclassing is being used then, after a successful new
connect, the \s-1DBI\-\s0>connect method automatically calls:
.PP
.Vb 1
\&  $dbh\->connected($dsn, $user, $pass, \e%attr);
.Ve
.PP
The default method does nothing. The call is made just to simplify
any post-connection setup that your subclass may want to perform.
The parameters are the same as passed to \s-1DBI\-\s0>connect.
If your subclass supplies a connected method, it should be part of the
MySubDBI::db package.
.PP
One more thing to note: you must let the \s-1DBI\s0 do the handle creation.  If you
want to override the \fIconnect()\fR method in your *::dr class then it must still
call SUPER::connect to get a \f(CW$dbh\fR to work with. Similarly, an overridden
\&\fIprepare()\fR method in *::db must still call SUPER::prepare to get a \f(CW$sth\fR.
If you try to create your own handles using \fIbless()\fR then you'll find the \s-1DBI\s0
will reject them with an \*(L"is not a \s-1DBI\s0 handle (has no magic)\*(R" error.
.PP
Here's a brief example of a \s-1DBI\s0 subclass.  A more thorough example
can be found in \fIt/subclass.t\fR in the \s-1DBI\s0 distribution.
.PP
.Vb 1
\&  package MySubDBI;
\&
\&  use strict;
\&
\&  use DBI;
\&  use vars qw(@ISA);
\&  @ISA = qw(DBI);
\&
\&  package MySubDBI::db;
\&  use vars qw(@ISA);
\&  @ISA = qw(DBI::db);
\&
\&  sub prepare {
\&    my ($dbh, @args) = @_;
\&    my $sth = $dbh\->SUPER::prepare(@args)
\&        or return;
\&    $sth\->{private_mysubdbi_info} = { foo => \*(Aqbar\*(Aq };
\&    return $sth;
\&  }
\&
\&  package MySubDBI::st;
\&  use vars qw(@ISA);
\&  @ISA = qw(DBI::st);
\&
\&  sub fetch {
\&    my ($sth, @args) = @_;
\&    my $row = $sth\->SUPER::fetch(@args)
\&        or return;
\&    do_something_magical_with_row_data($row)
\&        or return $sth\->set_err(1234, "The magic failed", undef, "fetch");
\&    return $row;
\&  }
.Ve
.PP
When calling a SUPER::method that returns a handle, be careful to
check the return value before trying to do other things with it in
your overridden method. This is especially important if you want to
set a hash attribute on the handle, as Perl's autovivification will
bite you by (in)conveniently creating an unblessed hashref, which your
method will then return with usually baffling results later on like
the error \*(L"dbih_getcom handle \s-1HASH\s0(0xa4451a8) is not a \s-1DBI\s0 handle (has
no magic\*(R".  It's best to check right after the call and return undef
immediately on error, just like \s-1DBI\s0 would and just like the example
above.
.PP
If your method needs to record an error it should call the \fIset_err()\fR
method with the error code and error string, as shown in the example
above. The error code and error string will be recorded in the
handle and available via \f(CW\*(C`$h\->err\*(C'\fR and \f(CW$DBI::errstr\fR etc.
The \fIset_err()\fR method always returns an undef or empty list as
appropriate. Since your method should nearly always return an undef
or empty list as soon as an error is detected it's handy to simply
return what \fIset_err()\fR returns, as shown in the example above.
.PP
If the handle has \f(CW\*(C`RaiseError\*(C'\fR, \f(CW\*(C`PrintError\*(C'\fR, or \f(CW\*(C`HandleError\*(C'\fR
etc. set then the \fIset_err()\fR method will honour them. This means
that if \f(CW\*(C`RaiseError\*(C'\fR is set then \fIset_err()\fR won't return in the
normal way but will 'throw an exception' that can be caught with
an \f(CW\*(C`eval\*(C'\fR block.
.PP
You can stash private data into \s-1DBI\s0 handles
via \f(CW\*(C`$h\->{private_..._*}\*(C'\fR.  See the entry under \*(L"\s-1ATTRIBUTES\s0
\&\s-1COMMON\s0 \s-1TO\s0 \s-1ALL\s0 \s-1HANDLES\s0\*(R" for info and important caveats.
.SH "TRACING"
.IX Header "TRACING"
The \s-1DBI\s0 has a powerful tracing mechanism built in. It enables you
to see what's going on 'behind the scenes', both within the \s-1DBI\s0 and
the drivers you're using.
.SS "Trace Settings"
.IX Subsection "Trace Settings"
Which details are written to the trace output is controlled by a
combination of a \fItrace level\fR, an integer from 0 to 15, and a set
of \fItrace flags\fR that are either on or off. Together these are known
as the \fItrace settings\fR and are stored together in a single integer.
For normal use you only need to set the trace level, and generally
only to a value between 1 and 4.
.PP
Each handle has it's own trace settings, and so does the \s-1DBI\s0.
When you call a method the \s-1DBI\s0 merges the handles settings into its
own for the duration of the call: the trace flags of the handle are
\&\s-1OR\s0'd into the trace flags of the \s-1DBI\s0, and if the handle has a higher
trace level then the \s-1DBI\s0 trace level is raised to match it.
The previous \s-1DBI\s0 trace settings are restored when the called method
returns.
.SS "Trace Levels"
.IX Subsection "Trace Levels"
Trace \fIlevels\fR are as follows:
.PP
.Vb 8
\&  0 \- Trace disabled.
\&  1 \- Trace top\-level DBI method calls returning with results or errors.
\&  2 \- As above, adding tracing of top\-level method entry with parameters.
\&  3 \- As above, adding some high\-level information from the driver
\&      and some internal information from the DBI.
\&  4 \- As above, adding more detailed information from the driver.
\&      This is the first level to trace all the rows being fetched.
\&  5 to 15 \- As above but with more and more internal information.
.Ve
.PP
Trace level 1 is best for a simple overview of what's happening.
Trace levels 2 thru 4 a good choice for general purpose tracing.
Levels 5 and above are best reserved for investigating a specific
problem, when you need to see \*(L"inside\*(R" the driver and \s-1DBI\s0.
.PP
The trace output is detailed and typically very useful. Much of the
trace output is formatted using the \*(L"neat\*(R" function, so strings
in the trace output may be edited and truncated by that function.
.SS "Trace Flags"
.IX Subsection "Trace Flags"
Trace \fIflags\fR are used to enable tracing of specific activities
within the \s-1DBI\s0 and drivers. The \s-1DBI\s0 defines some trace flags and
drivers can define others. \s-1DBI\s0 trace flag names begin with a capital
letter and driver specific names begin with a lowercase letter, as
usual.
.PP
Currently the \s-1DBI\s0 only defines two trace flags:
.PP
.Vb 10
\&  ALL \- turn on all DBI and driver flags (not recommended)
\&  SQL \- trace SQL statements executed
\&        (not yet implemented in DBI but implemented in some DBDs)
\&  CON \- trace connection process
\&  ENC \- trace encoding (unicode translations etc)
\&        (not yet implemented in DBI but implemented in some DBDs)
\&  DBD \- trace only DBD messages
\&        (not implemented by all DBDs yet)
\&  TXN \- trace transactions
\&        (not implemented in all DBDs yet)
.Ve
.PP
The \*(L"parse_trace_flags\*(R" and \*(L"parse_trace_flag\*(R" methods are used
to convert trace flag names into the corresponding integer bit flags.
.SS "Enabling Trace"
.IX Subsection "Enabling Trace"
The \f(CW\*(C`$h\->trace\*(C'\fR method sets the trace settings for a handle
and \f(CW\*(C`DBI\->trace\*(C'\fR does the same for the \s-1DBI\s0.
.PP
In addition to the \*(L"trace\*(R" method, you can enable the same trace
information, and direct the output to a file, by setting the
\&\f(CW\*(C`DBI_TRACE\*(C'\fR environment variable before starting Perl.
See \*(L"\s-1DBI_TRACE\s0\*(R" for more information.
.PP
Finally, you can set, or get, the trace settings for a handle using
the \f(CW\*(C`TraceLevel\*(C'\fR attribute.
.PP
All of those methods use \fIparse_trace_flags()\fR and so allow you set
both the trace level and multiple trace flags by using a string
containing the trace level and/or flag names separated by vertical
bar ("\f(CW\*(C`|\*(C'\fR\*(L") or comma (\*(R"\f(CW\*(C`,\*(C'\fR") characters. For example:
.PP
.Vb 1
\&  local $h\->{TraceLevel} = "3|SQL|foo";
.Ve
.SS "Trace Output"
.IX Subsection "Trace Output"
Initially trace output is written to \f(CW\*(C`STDERR\*(C'\fR.  Both the
\&\f(CW\*(C`$h\->trace\*(C'\fR and \f(CW\*(C`DBI\->trace\*(C'\fR methods take an optional
\&\f(CW$trace_file\fR parameter, which may be either the name of a file to be
opened by \s-1DBI\s0 in append mode, or a reference to an existing writable
(possibly layered) filehandle. If \f(CW$trace_file\fR is a filename,
and can be opened in append mode, or \f(CW$trace_file\fR is a writable
filehandle, then \fIall\fR trace output (currently including that from
other handles) is redirected to that file. A warning is generated
if \f(CW$trace_file\fR can't be opened or is not writable.
.PP
Further calls to \fItrace()\fR without \f(CW$trace_file\fR do not alter where
the trace output is sent. If \f(CW$trace_file\fR is undefined, then
trace output is sent to \f(CW\*(C`STDERR\*(C'\fR and, if the prior trace was opened with
\&\f(CW$trace_file\fR as a filename, the previous trace file is closed; if \f(CW$trace_file\fR was
a filehandle, the filehandle is \fBnot\fR closed.
.PP
\&\fB\s-1NOTE\s0\fR: If \f(CW$trace_file\fR is specified as a filehandle, the filehandle
should not be closed until all \s-1DBI\s0 operations are completed, or the
application has reset the trace file via another call to
\&\f(CW\*(C`trace()\*(C'\fR that changes the trace file.
.SS "Tracing to Layered Filehandles"
.IX Subsection "Tracing to Layered Filehandles"
\&\fB\s-1NOTE\s0\fR:
.IP "\(bu" 4
Tied filehandles are not currently supported, as
tie operations are not available to the PerlIO
methods used by the \s-1DBI\s0.
.IP "\(bu" 4
PerlIO layer support requires Perl version 5.8 or higher.
.PP
As of version 5.8, Perl provides the ability to layer various
\&\*(L"disciplines\*(R" on an open filehandle via the PerlIO module.
.PP
A simple example of using PerlIO layers is to use a scalar as the output:
.PP
.Vb 3
\&    my $scalar = \*(Aq\*(Aq;
\&    open( my $fh, "+>:scalar", \e$scalar );
\&    $dbh\->trace( 2, $fh );
.Ve
.PP
Now all trace output is simply appended to \f(CW$scalar\fR.
.PP
A more complex application of tracing to a layered filehandle is the
use of a custom layer (\fIRefer to \fRPerlio::via \fIfor details
on creating custom PerlIO layers.\fR). Consider an application with the
following logger module:
.PP
.Vb 1
\&    package MyFancyLogger;
\&
\&    sub new
\&    {
\&        my $self = {};
\&        my $fh;
\&        open $fh, \*(Aq>\*(Aq, \*(Aqfancylog.log\*(Aq;
\&        $self\->{_fh} = $fh;
\&        $self\->{_buf} = \*(Aq\*(Aq;
\&        return bless $self, shift;
\&    }
\&
\&    sub log
\&    {
\&        my $self = shift;
\&        return unless exists $self\->{_fh};
\&        my $fh = $self\->{_fh};
\&        $self\->{_buf} .= shift;
\&    #
\&    # DBI feeds us pieces at a time, so accumulate a complete line
\&    # before outputing
\&    #
\&        print $fh "At ", scalar localtime(), \*(Aq:\*(Aq, $self\->{_buf}, "\en" and
\&        $self\->{_buf} = \*(Aq\*(Aq
\&            if $self\->{_buf}=~tr/\en//;
\&    }
\&
\&    sub close {
\&        my $self = shift;
\&        return unless exists $self\->{_fh};
\&        my $fh = $self\->{_fh};
\&        print $fh "At ", scalar localtime(), \*(Aq:\*(Aq, $self\->{_buf}, "\en" and
\&        $self\->{_buf} = \*(Aq\*(Aq
\&            if $self\->{_buf};
\&        close $fh;
\&        delete $self\->{_fh};
\&    }
\&
\&    1;
.Ve
.PP
To redirect \s-1DBI\s0 traces to this logger requires creating
a package for the layer:
.PP
.Vb 1
\&    package PerlIO::via::MyFancyLogLayer;
\&
\&    sub PUSHED
\&    {
\&        my ($class,$mode,$fh) = @_;
\&        my $logger;
\&        return bless \e$logger,$class;
\&    }
\&
\&    sub OPEN {
\&        my ($self, $path, $mode, $fh) = @_;
\&        #
\&        # $path is actually our logger object
\&        #
\&        $$self = $path;
\&        return 1;
\&    }
\&
\&    sub WRITE
\&    {
\&        my ($self, $buf, $fh) = @_;
\&        $$self\->log($buf);
\&        return length($buf);
\&    }
\&
\&    sub CLOSE {
\&        my $self = shift;
\&        $$self\->close();
\&        return 0;
\&    }
\&
\&    1;
.Ve
.PP
The application can then cause \s-1DBI\s0 traces to be routed to the
logger using
.PP
.Vb 1
\&    use PerlIO::via::MyFancyLogLayer;
\&
\&    open my $fh, \*(Aq>:via(MyFancyLogLayer)\*(Aq, MyFancyLogger\->new();
\&
\&    $dbh\->trace(\*(AqSQL\*(Aq, $fh);
.Ve
.PP
Now all trace output will be processed by MyFancyLogger's
\&\fIlog()\fR method.
.SS "Trace Content"
.IX Subsection "Trace Content"
Many of the values embedded in trace output are formatted using the \fIneat()\fR
utility function. This means they may be quoted, sanitized, and possibly
truncated if longer than \f(CW$DBI::neat_maxlen\fR. See \*(L"neat\*(R" for more details.
.SS "Tracing Tips"
.IX Subsection "Tracing Tips"
You can add tracing to your own application code using the \*(L"trace_msg\*(R" method.
.PP
It can sometimes be handy to compare trace files from two different runs of the
same script. However using a tool like \f(CW\*(C`diff\*(C'\fR on the original log output
doesn't work well because the trace file is full of object addresses that may
differ on each run.
.PP
The \s-1DBI\s0 includes a handy utility called dbilogstrip that can be used to
\&'normalize' the log content. It can be used as a filter like this:
.PP
.Vb 3
\&    DBI_TRACE=2 perl yourscript.pl ...args1... 2>&1 | dbilogstrip > dbitrace1.log
\&    DBI_TRACE=2 perl yourscript.pl ...args2... 2>&1 | dbilogstrip > dbitrace2.log
\&    diff \-u dbitrace1.log dbitrace2.log
.Ve
.PP
See dbilogstrip for more information.
.SH "DBI ENVIRONMENT VARIABLES"
.IX Header "DBI ENVIRONMENT VARIABLES"
The \s-1DBI\s0 module recognizes a number of environment variables, but most of
them should not be used most of the time.
It is better to be explicit about what you are doing to avoid the need
for environment variables, especially in a web serving system where web
servers are stingy about which environment variables are available.
.SS "\s-1DBI_DSN\s0"
.IX Subsection "DBI_DSN"
The \s-1DBI_DSN\s0 environment variable is used by \s-1DBI\-\s0>connect if you do not
specify a data source when you issue the connect.
It should have a format such as \*(L"dbi:Driver:databasename\*(R".
.SS "\s-1DBI_DRIVER\s0"
.IX Subsection "DBI_DRIVER"
The \s-1DBI_DRIVER\s0 environment variable is used to fill in the database
driver name in \s-1DBI\-\s0>connect if the data source string starts \*(L"dbi::\*(R"
(thereby omitting the driver).
If \s-1DBI_DSN\s0 omits the driver name, \s-1DBI_DRIVER\s0 can fill the gap.
.SS "\s-1DBI_AUTOPROXY\s0"
.IX Subsection "DBI_AUTOPROXY"
The \s-1DBI_AUTOPROXY\s0 environment variable takes a string value that starts
\&\*(L"dbi:Proxy:\*(R" and is typically followed by \*(L"hostname=...;port=...\*(R".
It is used to alter the behaviour of \s-1DBI\-\s0>connect.
For full details, see DBI::Proxy documentation.
.SS "\s-1DBI_USER\s0"
.IX Subsection "DBI_USER"
The \s-1DBI_USER\s0 environment variable takes a string value that is used as
the user name if the \s-1DBI\-\s0>connect call is given undef (as distinct from
an empty string) as the username argument.
Be wary of the security implications of using this.
.SS "\s-1DBI_PASS\s0"
.IX Subsection "DBI_PASS"
The \s-1DBI_PASS\s0 environment variable takes a string value that is used as
the password if the \s-1DBI\-\s0>connect call is given undef (as distinct from
an empty string) as the password argument.
Be extra wary of the security implications of using this.
.SS "\s-1DBI_DBNAME\s0 (obsolete)"
.IX Subsection "DBI_DBNAME (obsolete)"
The \s-1DBI_DBNAME\s0 environment variable takes a string value that is used only when the
obsolescent style of \s-1DBI\-\s0>connect (with driver name as fourth parameter) is used, and
when no value is provided for the first (database name) argument.
.SS "\s-1DBI_TRACE\s0"
.IX Subsection "DBI_TRACE"
The \s-1DBI_TRACE\s0 environment variable specifies the global default
trace settings for the \s-1DBI\s0 at startup. Can also be used to direct
trace output to a file. When the \s-1DBI\s0 is loaded it does:
.PP
.Vb 1
\&  DBI\->trace(split /=/, $ENV{DBI_TRACE}, 2) if $ENV{DBI_TRACE};
.Ve
.PP
So if \f(CW\*(C`DBI_TRACE\*(C'\fR contains an "\f(CW\*(C`=\*(C'\fR" character then what follows
it is used as the name of the file to append the trace to.
.PP
output appended to that file. If the name begins with a number
followed by an equal sign (\f(CW\*(C`=\*(C'\fR), then the number and the equal sign are
stripped off from the name, and the number is used to set the trace
level. For example:
.PP
.Vb 1
\&  DBI_TRACE=1=dbitrace.log perl your_test_script.pl
.Ve
.PP
On Unix-like systems using a Bourne-like shell, you can do this easily
on the command line:
.PP
.Vb 1
\&  DBI_TRACE=2 perl your_test_script.pl
.Ve
.PP
See \*(L"\s-1TRACING\s0\*(R" for more information.
.SS "\s-1PERL_DBI_DEBUG\s0 (obsolete)"
.IX Subsection "PERL_DBI_DEBUG (obsolete)"
An old variable that should no longer be used; equivalent to \s-1DBI_TRACE\s0.
.SS "\s-1DBI_PROFILE\s0"
.IX Subsection "DBI_PROFILE"
The \s-1DBI_PROFILE\s0 environment variable can be used to enable profiling
of \s-1DBI\s0 method calls. See DBI::Profile for more information.
.SS "\s-1DBI_PUREPERL\s0"
.IX Subsection "DBI_PUREPERL"
The \s-1DBI_PUREPERL\s0 environment variable can be used to enable the
use of DBI::PurePerl.  See DBI::PurePerl for more information.
.SH "WARNING AND ERROR MESSAGES"
.IX Header "WARNING AND ERROR MESSAGES"
.SS "Fatal Errors"
.IX Subsection "Fatal Errors"
.ie n .IP "Can't call method ""prepare"" without a package or object reference" 4
.el .IP "Can't call method ``prepare'' without a package or object reference" 4
.IX Item "Can't call method prepare without a package or object reference"
The \f(CW$dbh\fR handle you're using to call \f(CW\*(C`prepare\*(C'\fR is probably undefined because
the preceding \f(CW\*(C`connect\*(C'\fR failed. You should always check the return status of
\&\s-1DBI\s0 methods, or use the \*(L"RaiseError\*(R" attribute.
.ie n .IP "Can't call method ""execute"" without a package or object reference" 4
.el .IP "Can't call method ``execute'' without a package or object reference" 4
.IX Item "Can't call method execute without a package or object reference"
The \f(CW$sth\fR handle you're using to call \f(CW\*(C`execute\*(C'\fR is probably undefined because
the preceding \f(CW\*(C`prepare\*(C'\fR failed. You should always check the return status of
\&\s-1DBI\s0 methods, or use the \*(L"RaiseError\*(R" attribute.
.IP "\s-1DBI/DBD\s0 internal version mismatch" 4
.IX Item "DBI/DBD internal version mismatch"
The \s-1DBD\s0 driver module was built with a different version of \s-1DBI\s0 than
the one currently being used.  You should rebuild the \s-1DBD\s0 module under
the current version of \s-1DBI\s0.
.Sp
(Some rare platforms require \*(L"static linking\*(R". On those platforms, there
may be an old \s-1DBI\s0 or \s-1DBD\s0 driver version actually embedded in the Perl
executable being used.)
.IP "\s-1DBD\s0 driver has not implemented the AutoCommit attribute" 4
.IX Item "DBD driver has not implemented the AutoCommit attribute"
The \s-1DBD\s0 driver implementation is incomplete. Consult the author.
.ie n .IP "Can't [sg]et %s\->{%s}: unrecognised attribute" 4
.el .IP "Can't [sg]et \f(CW%s\fR\->{%s}: unrecognised attribute" 4
.IX Item "Can't [sg]et %s->{%s}: unrecognised attribute"
You attempted to set or get an unknown attribute of a handle.  Make
sure you have spelled the attribute name correctly; case is significant
(e.g., \*(L"Autocommit\*(R" is not the same as \*(L"AutoCommit\*(R").
.SH "Pure-Perl DBI"
.IX Header "Pure-Perl DBI"
A pure-perl emulation of the \s-1DBI\s0 is included in the distribution
for people using pure-perl drivers who, for whatever reason, can't
install the compiled \s-1DBI\s0. See DBI::PurePerl.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.SS "Driver and Database Documentation"
.IX Subsection "Driver and Database Documentation"
Refer to the documentation for the \s-1DBD\s0 driver that you are using.
.PP
Refer to the \s-1SQL\s0 Language Reference Manual for the database engine that you are using.
.SS "\s-1ODBC\s0 and \s-1SQL/CLI\s0 Standards Reference Information"
.IX Subsection "ODBC and SQL/CLI Standards Reference Information"
More detailed information about the semantics of certain \s-1DBI\s0 methods
that are based on \s-1ODBC\s0 and \s-1SQL/CLI\s0 standards is available on-line
via microsoft.com, for \s-1ODBC\s0, and www.jtc1sc32.org for the \s-1SQL/CLI\s0
standard:
.PP
.Vb 9
\& DBI method        ODBC function     SQL/CLI Working Draft
\& \-\-\-\-\-\-\-\-\-\-        \-\-\-\-\-\-\-\-\-\-\-\-\-     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& column_info       SQLColumns        Page 124
\& foreign_key_info  SQLForeignKeys    Page 163
\& get_info          SQLGetInfo        Page 214
\& primary_key_info  SQLPrimaryKeys    Page 254
\& table_info        SQLTables         Page 294
\& type_info         SQLGetTypeInfo    Page 239
\& statistics_info   SQLStatistics
.Ve
.PP
To find documentation on the \s-1ODBC\s0 function you can use
the \s-1MSDN\s0 search facility at:
.PP
.Vb 1
\&    http://msdn.microsoft.com/Search
.Ve
.PP
and search for something like \f(CW"SQLColumns returns"\fR.
.PP
And for \s-1SQL/CLI\s0 standard information on SQLColumns you'd read page 124 of
the (very large) \s-1SQL/CLI\s0 Working Draft available from:
.PP
.Vb 1
\&  http://jtc1sc32.org/doc/N0701\-0750/32N0744T.pdf
.Ve
.SS "Standards Reference Information"
.IX Subsection "Standards Reference Information"
A hyperlinked, browsable version of the \s-1BNF\s0 syntax for \s-1SQL92\s0 (plus
Oracle 7 \s-1SQL\s0 and \s-1PL/SQL\s0) is available here:
.PP
.Vb 1
\&  http://cui.unige.ch/db\-research/Enseignement/analyseinfo/SQL92/BNFindex.html
.Ve
.PP
A \s-1BNF\s0 syntax for \s-1SQL3\s0 is available here:
.PP
.Vb 1
\&  http://www.sqlstandards.org/SC32/WG3/Progression_Documents/Informal_working_drafts/iso\-9075\-2\-1999.bnf
.Ve
.PP
The following links provide further useful information about \s-1SQL\s0.
Some of these are rather dated now but may still be useful.
.PP
.Vb 3
\&  http://www.jcc.com/SQLPages/jccs_sql.htm
\&  http://www.contrib.andrew.cmu.edu/~shadow/sql.html
\&  http://www.altavista.com/query?q=sql+tutorial
.Ve
.SS "Books and Articles"
.IX Subsection "Books and Articles"
Programming the Perl \s-1DBI\s0, by Alligator Descartes and Tim Bunce.
<http://books.perl.org/book/154>
.PP
Programming Perl 3rd Ed. by Larry Wall, Tom Christiansen & Jon Orwant.
<http://books.perl.org/book/134>
.PP
Learning Perl by Randal Schwartz.
<http://books.perl.org/book/101>
.PP
Details of many other books related to perl can be found at <http://books.perl.org>
.SS "Perl Modules"
.IX Subsection "Perl Modules"
Index of \s-1DBI\s0 related modules available from \s-1CPAN:\s0
.PP
.Vb 2
\& http://search.cpan.org/search?mode=module&query=DBIx%3A%3A
\& http://search.cpan.org/search?mode=doc&query=DBI
.Ve
.PP
For a good comparison of RDBMS-OO mappers and some OO-RDBMS mappers
(including Class::DBI, Alzabo, and DBIx::RecordSet in the former
category and Tangram and \s-1SPOPS\s0 in the latter) see the Perl
Object-Oriented Persistence project pages at:
.PP
.Vb 1
\& http://poop.sourceforge.net
.Ve
.PP
A similar page for Java toolkits can be found at:
.PP
.Vb 1
\& http://c2.com/cgi\-bin/wiki?ObjectRelationalToolComparison
.Ve
.SS "Mailing List"
.IX Subsection "Mailing List"
The \fIdbi-users\fR mailing list is the primary means of communication among
users of the \s-1DBI\s0 and its related modules. For details send email to:
.PP
.Vb 1
\& dbi\-users\-help@perl.org
.Ve
.PP
There are typically between 700 and 900 messages per month.  You have
to subscribe in order to be able to post. However you can opt for a
\&'post\-only' subscription.
.PP
Mailing list archives (of variable quality) are held at:
.PP
.Vb 3
\& http://groups.google.com/groups?group=perl.dbi.users
\& http://www.xray.mpe.mpg.de/mailing\-lists/dbi/
\& http://www.mail\-archive.com/dbi\-users%40perl.org/
.Ve
.SS "Assorted Related \s-1WWW\s0 Links"
.IX Subsection "Assorted Related WWW Links"
The \s-1DBI\s0 \*(L"Home Page\*(R":
.PP
.Vb 1
\& http://dbi.perl.org/
.Ve
.PP
Other \s-1DBI\s0 related links:
.PP
.Vb 7
\& http://tegan.deltanet.com/~phlip/DBUIdoc.html
\& http://dc.pm.org/perl_db.html
\& http://wdvl.com/Authoring/DB/Intro/toc.html
\& http://www.hotwired.com/webmonkey/backend/tutorials/tutorial1.html
\& http://bumppo.net/lists/macperl/1999/06/msg00197.html
\& http://www.perlmonks.org/?node=DBI%20recipes
\& http://www.perlmonks.org/?node=Speeding%20up%20the%20DBI
.Ve
.PP
Other database related links:
.PP
.Vb 3
\& http://www.jcc.com/sql_stnd.html
\& http://cuiwww.unige.ch/OSG/info/FreeDB/FreeDB.home.html
\& http://www.connectionstrings.com/
.Ve
.PP
Security, especially the \*(L"\s-1SQL\s0 Injection\*(R" attack:
.PP
.Vb 7
\& http://www.ngssoftware.com/research/papers.html
\& http://www.ngssoftware.com/papers/advanced_sql_injection.pdf
\& http://www.ngssoftware.com/papers/more_advanced_sql_injection.pdf
\& http://www.esecurityplanet.com/trends/article.php/2243461
\& http://www.spidynamics.com/papers/SQLInjectionWhitePaper.pdf
\& http://www.imperva.com/application_defense_center/white_papers/blind_sql_server_injection.html
\& http://online.securityfocus.com/infocus/1644
.Ve
.PP
Commercial and Data Warehouse Links
.PP
.Vb 6
\& http://www.dwinfocenter.org
\& http://www.datawarehouse.com
\& http://www.datamining.org
\& http://www.olapcouncil.org
\& http://www.idwa.org
\& http://www.knowledgecenters.org/dwcenter.asp
.Ve
.PP
Recommended Perl Programming Links
.PP
.Vb 1
\& http://language.perl.com/style/
.Ve
.SS "\s-1FAQ\s0"
.IX Subsection "FAQ"
See http://faq.dbi\-support.com/ <http://faq.dbi-support.com/>
.SH "AUTHORS"
.IX Header "AUTHORS"
\&\s-1DBI\s0 by Tim Bunce, <http://www.tim.bunce.name>
.PP
This pod text by Tim Bunce, J. Douglas Dunlop, Jonathan Leffler and others.
Perl by Larry Wall and the \f(CW\*(C`perl5\-porters\*(C'\fR.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
The \s-1DBI\s0 module is Copyright (c) 1994\-2012 Tim Bunce. Ireland.
All rights reserved.
.PP
You may distribute under the terms of either the \s-1GNU\s0 General Public
License or the Artistic License, as specified in the Perl 5.10.0 \s-1README\s0 file.
.SH "SUPPORT / WARRANTY"
.IX Header "SUPPORT / WARRANTY"
The \s-1DBI\s0 is free Open Source software. \s-1IT\s0 \s-1COMES\s0 \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0.
.SS "Support"
.IX Subsection "Support"
My consulting company, Data Plan Services, offers annual and
multi-annual support contracts for the \s-1DBI\s0. These provide sustained
support for \s-1DBI\s0 development, and sustained value for you in return.
Contact me for details.
.SS "Sponsor Enhancements"
.IX Subsection "Sponsor Enhancements"
The \s-1DBI\s0 Roadmap is available at <http://search.cpan.org/~timb/DBI/Roadmap.pod>
.PP
If your company would benefit from a specific new \s-1DBI\s0 feature,
please consider sponsoring its development.  Work is performed
rapidly, and usually on a fixed-price payment-on-delivery basis.
Contact me for details.
.PP
Using such targeted financing allows you to contribute to \s-1DBI\s0
development, and rapidly get something specific and valuable in return.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
I would like to acknowledge the valuable contributions of the many
people I have worked with on the \s-1DBI\s0 project, especially in the early
years (1992\-1994). In no particular order: Kevin Stock, Buzz Moschetti,
Kurt Andersen, Ted Lemon, William Hails, Garth Kennedy, Michael Peppler,
Neil S. Briscoe, Jeff Urlwin, David J. Hughes, Jeff Stander,
Forrest D Whitcher, Larry Wall, Jeff Fried, Roy Johnson, Paul Hudson,
Georg Rehfeld, Steve Sizemore, Ron Pool, Jon Meek, Tom Christiansen,
Steve Baumgarten, Randal Schwartz, and a whole lot more.
.PP
Then, of course, there are the poor souls who have struggled through
untold and undocumented obstacles to actually implement \s-1DBI\s0 drivers.
Among their ranks are Jochen Wiedmann, Alligator Descartes, Jonathan
Leffler, Jeff Urlwin, Michael Peppler, Henrik Tougaard, Edwin Pratomo,
Davide Migliavacca, Jan Pazdziora, Peter Haworth, Edmund Mergl, Steve
Williams, Thomas Lowery, and Phlip Plumlee. Without them, the \s-1DBI\s0 would
not be the practical reality it is today.  I'm also especially grateful
to Alligator Descartes for starting work on the first edition of the
\&\*(L"Programming the Perl \s-1DBI\s0\*(R" book and letting me jump on board.
.PP
The \s-1DBI\s0 and DBD::Oracle were originally developed while I was Technical
Director (\s-1CTO\s0) of Ingeneering in the \s-1UK\s0 (<http://www.ig.co.uk>) (formerly known as the
Paul Ingram Group).  So I'd especially like to thank Paul for his generosity
and vision in supporting this work for many years.
.PP
A couple of specific \s-1DBI\s0 features have been sponsored by enlightened companies:
.PP
The development of the \fIswap_inner_handle()\fR method was sponsored by BizRate.com (<http://BizRate.com>)
.PP
The development of DBD::Gofer and related modules was sponsored by
Shopzilla.com (<http://Shopzilla.com>), where I currently work.
.SH "CONTRIBUTING"
.IX Header "CONTRIBUTING"
As you can see above, many people have contributed to the \s-1DBI\s0 and
drivers in many ways over many years.
.PP
If you'd like to help then see <http://dbi.perl.org/contributing>
and <http://search.cpan.org/~timb/DBI/Roadmap.pod>
.PP
If you'd like the \s-1DBI\s0 to do something new or different then a good way
to make that happen is to do it yourself and send me a patch to the
source code that shows the changes. (But read \*(L"Speak before you patch\*(R"
below.)
.SS "Browsing the source code repository"
.IX Subsection "Browsing the source code repository"
Use http://svn.perl.org/modules/dbi/trunk (basic)
or  http://svn.perl.org/viewcvs/modules/ (more useful)
.SS "How to create a patch using Subversion"
.IX Subsection "How to create a patch using Subversion"
The \s-1DBI\s0 source code is maintained using Subversion (a replacement
for \s-1CVS\s0, see <http://subversion.tigris.org/>). To access the source
you'll need to install a Subversion client. Then, to get the source
code, do:
.PP
.Vb 1
\&  svn checkout http://svn.perl.org/modules/dbi/trunk
.Ve
.PP
If it prompts for a username and password use your perl.org account
if you have one, else just 'guest' and 'guest'. The source code will
be in a new subdirectory called \f(CW\*(C`trunk\*(C'\fR.
.PP
To keep informed about changes to the source you can send an empty email
to svn\-commit\-modules\-dbi\-subscribe@perl.org after which you'll get an email
with the change log message and diff of each change checked-in to the source.
.PP
After making your changes you can generate a patch file, but before
you do, make sure your source is still up to date using:
.PP
.Vb 1
\&  svn update
.Ve
.PP
If you get any conflicts reported you'll need to fix them first.
Then generate the patch file from within the \f(CW\*(C`trunk\*(C'\fR directory using:
.PP
.Vb 1
\&  svn diff > foo.patch
.Ve
.PP
Read the patch file, as a sanity check, and then email it to dbi\-dev@perl.org.
.SS "How to create a patch without Subversion"
.IX Subsection "How to create a patch without Subversion"
Unpack a fresh copy of the distribution:
.PP
.Vb 1
\&  tar xfz DBI\-1.40.tar.gz
.Ve
.PP
Rename the newly created top level directory:
.PP
.Vb 1
\&  mv DBI\-1.40 DBI\-1.40.your_foo
.Ve
.PP
Edit the contents of \s-1DBI\-1\s0.40.your_foo/* till it does what you want.
.PP
Test your changes and then remove all temporary files:
.PP
.Vb 1
\&  make test && make distclean
.Ve
.PP
Go back to the directory you originally unpacked the distribution:
.PP
.Vb 1
\&  cd ..
.Ve
.PP
Unpack \fIanother\fR copy of the original distribution you started with:
.PP
.Vb 1
\&  tar xfz DBI\-1.40.tar.gz
.Ve
.PP
Then create a patch file by performing a recursive \f(CW\*(C`diff\*(C'\fR on the two
top level directories:
.PP
.Vb 1
\&  diff \-r \-u DBI\-1.40 DBI\-1.40.your_foo > DBI\-1.40.your_foo.patch
.Ve
.SS "Speak before you patch"
.IX Subsection "Speak before you patch"
For anything non-trivial or possibly controversial it's a good idea
to discuss (on dbi\-dev@perl.org) the changes you propose before
actually spending time working on them. Otherwise you run the risk
of them being rejected because they don't fit into some larger plans
you may not be aware of.
.SH "TRANSLATIONS"
.IX Header "TRANSLATIONS"
A German translation of this manual (possibly slightly out of date) is
available, thanks to O'Reilly, at:
.PP
.Vb 1
\&  http://www.oreilly.de/catalog/perldbiger/
.Ve
.PP
Some other translations:
.PP
.Vb 2
\& http://cronopio.net/perl/                              \- Spanish
\& http://member.nifty.ne.jp/hippo2000/dbimemo.htm        \- Japanese
.Ve
.SH "TRAINING"
.IX Header "TRAINING"
References to \s-1DBI\s0 related training resources. No recommendation implied.
.PP
.Vb 2
\&  http://www.treepax.co.uk/
\&  http://www.keller.com/dbweb/
.Ve
.PP
(If you offer professional \s-1DBI\s0 related training services,
please send me your details so I can add them here.)
.SH "OTHER RELATED WORK AND PERL MODULES"
.IX Header "OTHER RELATED WORK AND PERL MODULES"
.IP "Apache::DBI by E.Mergl@bawue.de" 4
.IX Item "Apache::DBI by E.Mergl@bawue.de"
To be used with the Apache daemon together with an embedded Perl
interpreter like \f(CW\*(C`mod_perl\*(C'\fR. Establishes a database connection which
remains open for the lifetime of the \s-1HTTP\s0 daemon. This way the \s-1CGI\s0
connect and disconnect for every database access becomes superfluous.
.IP "\s-1SQL\s0 Parser" 4
.IX Item "SQL Parser"
See also the SQL::Statement module, \s-1SQL\s0 parser and engine.
                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI5.18.3pm                                  0100644 0001750 0001750 00001101223 12566241601 022206  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI 3"
.TH DBI 3 "2014-01-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI \- Database independent interface for Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use DBI;
\&
\&  @driver_names = DBI\->available_drivers;
\&  %drivers      = DBI\->installed_drivers;
\&  @data_sources = DBI\->data_sources($driver_name, \e%attr);
\&
\&  $dbh = DBI\->connect($data_source, $username, $auth, \e%attr);
\&
\&  $rv  = $dbh\->do($statement);
\&  $rv  = $dbh\->do($statement, \e%attr);
\&  $rv  = $dbh\->do($statement, \e%attr, @bind_values);
\&
\&  $ary_ref  = $dbh\->selectall_arrayref($statement);
\&  $hash_ref = $dbh\->selectall_hashref($statement, $key_field);
\&
\&  $ary_ref  = $dbh\->selectcol_arrayref($statement);
\&  $ary_ref  = $dbh\->selectcol_arrayref($statement, \e%attr);
\&
\&  @row_ary  = $dbh\->selectrow_array($statement);
\&  $ary_ref  = $dbh\->selectrow_arrayref($statement);
\&  $hash_ref = $dbh\->selectrow_hashref($statement);
\&
\&  $sth = $dbh\->prepare($statement);
\&  $sth = $dbh\->prepare_cached($statement);
\&
\&  $rc = $sth\->bind_param($p_num, $bind_value);
\&  $rc = $sth\->bind_param($p_num, $bind_value, $bind_type);
\&  $rc = $sth\->bind_param($p_num, $bind_value, \e%attr);
\&
\&  $rv = $sth\->execute;
\&  $rv = $sth\->execute(@bind_values);
\&  $rv = $sth\->execute_array(\e%attr, ...);
\&
\&  $rc = $sth\->bind_col($col_num, \e$col_variable);
\&  $rc = $sth\->bind_columns(@list_of_refs_to_vars_to_bind);
\&
\&  @row_ary  = $sth\->fetchrow_array;
\&  $ary_ref  = $sth\->fetchrow_arrayref;
\&  $hash_ref = $sth\->fetchrow_hashref;
\&
\&  $ary_ref  = $sth\->fetchall_arrayref;
\&  $ary_ref  = $sth\->fetchall_arrayref( $slice, $max_rows );
\&
\&  $hash_ref = $sth\->fetchall_hashref( $key_field );
\&
\&  $rv  = $sth\->rows;
\&
\&  $rc  = $dbh\->begin_work;
\&  $rc  = $dbh\->commit;
\&  $rc  = $dbh\->rollback;
\&
\&  $quoted_string = $dbh\->quote($string);
\&
\&  $rc  = $h\->err;
\&  $str = $h\->errstr;
\&  $rv  = $h\->state;
\&
\&  $rc  = $dbh\->disconnect;
.Ve
.PP
\&\fIThe synopsis above only lists the major methods and parameters.\fR
.SS "\s-1GETTING HELP\s0"
.IX Subsection "GETTING HELP"
\fIGeneral\fR
.IX Subsection "General"
.PP
Before asking any questions, reread this document, consult the
archives and read the \s-1DBI FAQ.\s0 The archives are listed
at the end of this document and on the \s-1DBI\s0 home page <http://dbi.perl.org/support/>
.PP
You might also like to read the Advanced \s-1DBI\s0 Tutorial at
<http://www.slideshare.net/Tim.Bunce/dbi\-advanced\-tutorial\-2007>
.PP
To help you make the best use of the dbi-users mailing list,
and any other lists or forums you may use, I recommend that you read
\&\*(L"Getting Answers\*(R" by Mike Ash: <http://mikeash.com/getting_answers.html>.
.PP
\fIMailing Lists\fR
.IX Subsection "Mailing Lists"
.PP
If you have questions about \s-1DBI,\s0 or \s-1DBD\s0 driver modules, you can get
help from the \fIdbi\-users@perl.org\fR mailing list. This is the best way to get
help. You don't have to subscribe to the list in order to post, though I'd
recommend it. You can get help on subscribing and using the list by emailing
\&\fIdbi\-users\-help@perl.org\fR.
.PP
Please note that Tim Bunce does not maintain the mailing lists or the
web pages (generous volunteers do that).  So please don't send mail
directly to him; he just doesn't have the time to answer questions
personally. The \fIdbi-users\fR mailing list has lots of experienced
people who should be able to help you if you need it. If you do email
Tim he is very likely to just forward it to the mailing list.
.PP
\fIOnline\fR
.IX Subsection "Online"
.PP
StackOverflow has a \s-1DBI\s0 tag <http://stackoverflow.com/questions/tagged/dbi>
with over 400 questions.
.PP
The \s-1DBI\s0 home page at <http://dbi.perl.org/> and the \s-1DBI FAQ\s0
at <http://faq.dbi\-support.com/> may be worth a visit.
They include links to other resources, but \fIare rather out-dated\fR.
.PP
I don't recommend the \s-1DBI\s0 cpanforum (at http://www.cpanforum.com/dist/DBI)
because relatively few people read it compared with dbi\-users@perl.org.
.PP
\fIReporting a Bug\fR
.IX Subsection "Reporting a Bug"
.PP
If you think you've found a bug then please read
\&\*(L"How to Report Bugs Effectively\*(R" by Simon Tatham:
<http://www.chiark.greenend.org.uk/~sgtatham/bugs.html>.
.PP
Your problem is most likely related to the specific \s-1DBD\s0 driver module you're
using. If that's the case then click on the 'Bugs' link on the <http://metacpan.org>
page for your driver. Only submit a bug report against the \s-1DBI\s0 itself if you're
sure that your issue isn't related to the driver you're using.
.SS "\s-1NOTES\s0"
.IX Subsection "NOTES"
This is the \s-1DBI\s0 specification that corresponds to \s-1DBI\s0 version 1.631
(see DBI::Changes for details).
.PP
The \s-1DBI\s0 is evolving at a steady pace, so it's good to check that
you have the latest copy.
.PP
The significant user-visible changes in each release are documented
in the DBI::Changes module so you can read them by executing
\&\f(CW\*(C`perldoc DBI::Changes\*(C'\fR.
.PP
Some \s-1DBI\s0 changes require changes in the drivers, but the drivers
can take some time to catch up. Newer versions of the \s-1DBI\s0 have
added features that may not yet be supported by the drivers you
use.  Talk to the authors of your drivers if you need a new feature
that is not yet supported.
.PP
Features added after \s-1DBI 1.21 \s0(February 2002) are marked in the
text with the version number of the \s-1DBI\s0 release they first appeared in.
.PP
Extensions to the \s-1DBI API\s0 often use the \f(CW\*(C`DBIx::*\*(C'\fR namespace.
See \*(L"Naming Conventions and Name Space\*(R". \s-1DBI\s0 extension modules
can be found at <https://metacpan.org/search?q=DBIx>.  And all modules
related to the \s-1DBI\s0 can be found at <https://metacpan.org/search?q=DBI>.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \s-1DBI\s0 is a database access module for the Perl programming language.  It defines
a set of methods, variables, and conventions that provide a consistent
database interface, independent of the actual database being used.
.PP
It is important to remember that the \s-1DBI\s0 is just an interface.
The \s-1DBI\s0 is a layer
of \*(L"glue\*(R" between an application and one or more database \fIdriver\fR
modules.  It is the driver modules which do most of the real work. The \s-1DBI\s0
provides a standard interface and framework for the drivers to operate
within.
.PP
This document often uses terms like \fIreferences\fR, \fIobjects\fR,
\&\fImethods\fR.  If you're not familiar with those terms then it would
be a good idea to read at least the following perl manuals first:
perlreftut, perldsc, perllol, and perlboot.
.SS "Architecture of a \s-1DBI\s0 Application"
.IX Subsection "Architecture of a DBI Application"
.Vb 11
\&             |<\- Scope of DBI \->|
\&                  .\-.   .\-\-\-\-\-\-\-\-\-\-\-\-\-\-.   .\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&  .\-\-\-\-\-\-\-.       | |\-\-\-| XYZ Driver   |\-\-\-| XYZ Engine  |
\&  | Perl  |       | |   \`\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq   \`\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&  | script|  |A|  |D|   .\-\-\-\-\-\-\-\-\-\-\-\-\-\-.   .\-\-\-\-\-\-\-\-\-\-\-\-\-.
\&  | using |\-\-|P|\-\-|B|\-\-\-|Oracle Driver |\-\-\-|Oracle Engine|
\&  | DBI   |  |I|  |I|   \`\-\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq   \`\-\-\-\-\-\-\-\-\-\-\-\-\-\*(Aq
\&  | API   |       | |...
\&  |methods|       | |... Other drivers
\&  \`\-\-\-\-\-\-\-\*(Aq       | |...
\&                  \`\-\*(Aq
.Ve
.PP
The \s-1API,\s0 or Application Programming Interface, defines the
call interface and variables for Perl scripts to use. The \s-1API\s0
is implemented by the Perl \s-1DBI\s0 extension.
.PP
The \s-1DBI \s0\*(L"dispatches\*(R" the method calls to the appropriate driver for
actual execution.  The \s-1DBI\s0 is also responsible for the dynamic loading
of drivers, error checking and handling, providing default
implementations for methods, and many other non-database specific duties.
.PP
Each driver
contains implementations of the \s-1DBI\s0 methods using the
private interface functions of the corresponding database engine.  Only authors
of sophisticated/multi\-database applications or generic library
functions need be concerned with drivers.
.SS "Notation and Conventions"
.IX Subsection "Notation and Conventions"
The following conventions are used in this document:
.PP
.Vb 11
\&  $dbh    Database handle object
\&  $sth    Statement handle object
\&  $drh    Driver handle object (rarely seen or used in applications)
\&  $h      Any of the handle types above ($dbh, $sth, or $drh)
\&  $rc     General Return Code  (boolean: true=ok, false=error)
\&  $rv     General Return Value (typically an integer)
\&  @ary    List of values returned from the database, typically a row of data
\&  $rows   Number of rows processed (if available, else \-1)
\&  $fh     A filehandle
\&  undef   NULL values are represented by undefined values in Perl
\&  \e%attr  Reference to a hash of attribute values passed to methods
.Ve
.PP
Note that Perl will automatically destroy database and statement handle objects
if all references to them are deleted.
.SS "Outline Usage"
.IX Subsection "Outline Usage"
To use \s-1DBI,\s0
first you need to load the \s-1DBI\s0 module:
.PP
.Vb 2
\&  use DBI;
\&  use strict;
.Ve
.PP
(The \f(CW\*(C`use strict;\*(C'\fR isn't required but is strongly recommended.)
.PP
Then you need to \*(L"connect\*(R" to your data source and get a \fIhandle\fR for that
connection:
.PP
.Vb 2
\&  $dbh = DBI\->connect($dsn, $user, $password,
\&                      { RaiseError => 1, AutoCommit => 0 });
.Ve
.PP
Since connecting can be expensive, you generally just connect at the
start of your program and disconnect at the end.
.PP
Explicitly defining the required \f(CW\*(C`AutoCommit\*(C'\fR behaviour is strongly
recommended and may become mandatory in a later version.  This
determines whether changes are automatically committed to the
database when executed, or need to be explicitly committed later.
.PP
The \s-1DBI\s0 allows an application to \*(L"prepare\*(R" statements for later
execution.  A prepared statement is identified by a statement handle
held in a Perl variable.
We'll call the Perl variable \f(CW$sth\fR in our examples.
.PP
The typical method call sequence for a \f(CW\*(C`SELECT\*(C'\fR statement is:
.PP
.Vb 4
\&  prepare,
\&    execute, fetch, fetch, ...
\&    execute, fetch, fetch, ...
\&    execute, fetch, fetch, ...
.Ve
.PP
for example:
.PP
.Vb 1
\&  $sth = $dbh\->prepare("SELECT foo, bar FROM table WHERE baz=?");
\&
\&  $sth\->execute( $baz );
\&
\&  while ( @row = $sth\->fetchrow_array ) {
\&    print "@row\en";
\&  }
.Ve
.PP
The typical method call sequence for a \fInon\fR\-\f(CW\*(C`SELECT\*(C'\fR statement is:
.PP
.Vb 4
\&  prepare,
\&    execute,
\&    execute,
\&    execute.
.Ve
.PP
for example:
.PP
.Vb 1
\&  $sth = $dbh\->prepare("INSERT INTO table(foo,bar,baz) VALUES (?,?,?)");
\&
\&  while(<CSV>) {
\&    chomp;
\&    my ($foo,$bar,$baz) = split /,/;
\&        $sth\->execute( $foo, $bar, $baz );
\&  }
.Ve
.PP
The \f(CW\*(C`do()\*(C'\fR method can be used for non repeated \fInon\fR\-\f(CW\*(C`SELECT\*(C'\fR statement
(or with drivers that don't support placeholders):
.PP
.Vb 1
\&  $rows_affected = $dbh\->do("UPDATE your_table SET foo = foo + 1");
.Ve
.PP
To commit your changes to the database (when \*(L"AutoCommit\*(R" is off):
.PP
.Vb 1
\&  $dbh\->commit;  # or call $dbh\->rollback; to undo changes
.Ve
.PP
Finally, when you have finished working with the data source, you should
\&\*(L"disconnect\*(R" from it:
.PP
.Vb 1
\&  $dbh\->disconnect;
.Ve
.SS "General Interface Rules & Caveats"
.IX Subsection "General Interface Rules & Caveats"
The \s-1DBI\s0 does not have a concept of a \*(L"current session\*(R". Every session
has a handle object (i.e., a \f(CW$dbh\fR) returned from the \f(CW\*(C`connect\*(C'\fR method.
That handle object is used to invoke database related methods.
.PP
Most data is returned to the Perl script as strings. (Null values are
returned as \f(CW\*(C`undef\*(C'\fR.)  This allows arbitrary precision numeric data to be
handled without loss of accuracy.  Beware that Perl may not preserve
the same accuracy when the string is used as a number.
.PP
Dates and times are returned as character strings in the current
default format of the corresponding database engine.  Time zone effects
are database/driver dependent.
.PP
Perl supports binary data in Perl strings, and the \s-1DBI\s0 will pass binary
data to and from the driver without change. It is up to the driver
implementors to decide how they wish to handle such binary data.
.PP
Perl supports two kinds of strings: Unicode (utf8 internally) and non-Unicode
(defaults to iso\-8859\-1 if forced to assume an encoding).  Drivers should
accept both kinds of strings and, if required, convert them to the character
set of the database being used. Similarly, when fetching from the database
character data that isn't iso\-8859\-1 the driver should convert it into utf8.
.PP
Multiple \s-1SQL\s0 statements may not be combined in a single statement
handle (\f(CW$sth\fR), although some databases and drivers do support this
(notably Sybase and \s-1SQL\s0 Server).
.PP
Non-sequential record reads are not supported in this version of the \s-1DBI.\s0
In other words, records can only be fetched in the order that the
database returned them, and once fetched they are forgotten.
.PP
Positioned updates and deletes are not directly supported by the \s-1DBI.\s0
See the description of the \f(CW\*(C`CursorName\*(C'\fR attribute for an alternative.
.PP
Individual driver implementors are free to provide any private
functions and/or handle attributes that they feel are useful.
Private driver functions can be invoked using the \s-1DBI \s0\f(CW\*(C`func()\*(C'\fR method.
Private driver attributes are accessed just like standard attributes.
.PP
Many methods have an optional \f(CW\*(C`\e%attr\*(C'\fR parameter which can be used to
pass information to the driver implementing the method. Except where
specifically documented, the \f(CW\*(C`\e%attr\*(C'\fR parameter can only be used to pass
driver specific hints. In general, you can ignore \f(CW\*(C`\e%attr\*(C'\fR parameters
or pass it as \f(CW\*(C`undef\*(C'\fR.
.SS "Naming Conventions and Name Space"
.IX Subsection "Naming Conventions and Name Space"
The \s-1DBI\s0 package and all packages below it (\f(CW\*(C`DBI::*\*(C'\fR) are reserved for
use by the \s-1DBI.\s0 Extensions and related modules use the \f(CW\*(C`DBIx::\*(C'\fR
namespace (see <http://www.perl.com/CPAN/modules/by\-module/DBIx/>).
Package names beginning with \f(CW\*(C`DBD::\*(C'\fR are reserved for use
by \s-1DBI\s0 database drivers.  All environment variables used by the \s-1DBI\s0
or by individual DBDs begin with "\f(CW\*(C`DBI_\*(C'\fR\*(L" or \*(R"\f(CW\*(C`DBD_\*(C'\fR".
.PP
The letter case used for attribute names is significant and plays an
important part in the portability of \s-1DBI\s0 scripts.  The case of the
attribute name is used to signify who defined the meaning of that name
and its values.
.PP
.Vb 5
\&  Case of name  Has a meaning defined by
\&  \-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  UPPER_CASE    Standards, e.g.,  X/Open, ISO SQL92 etc (portable)
\&  MixedCase     DBI API (portable), underscores are not used.
\&  lower_case    Driver or database engine specific (non\-portable)
.Ve
.PP
It is of the utmost importance that Driver developers only use
lowercase attribute names when defining private attributes. Private
attribute names must be prefixed with the driver name or suitable
abbreviation (e.g., "\f(CW\*(C`ora_\*(C'\fR\*(L" for Oracle, \*(R"\f(CW\*(C`ing_\*(C'\fR" for Ingres, etc).
.SS "\s-1SQL \- A\s0 Query Language"
.IX Subsection "SQL - A Query Language"
Most \s-1DBI\s0 drivers require applications to use a dialect of \s-1SQL
\&\s0(Structured Query Language) to interact with the database engine.
The \*(L"Standards Reference Information\*(R" section provides links
to useful information about \s-1SQL.\s0
.PP
The \s-1DBI\s0 itself does not mandate or require any particular language to
be used; it is language independent. In \s-1ODBC\s0 terms, the \s-1DBI\s0 is in
\&\*(L"pass-thru\*(R" mode, although individual drivers might not be. The only requirement
is that queries and other statements must be expressed as a single
string of characters passed as the first argument to the \*(L"prepare\*(R" or
\&\*(L"do\*(R" methods.
.PP
For an interesting diversion on the \fIreal\fR history of \s-1RDBMS\s0 and \s-1SQL,\s0
from the people who made it happen, see:
.PP
.Vb 1
\&  http://www.mcjones.org/System_R/SQL_Reunion_95/sqlr95.html
.Ve
.PP
Follow the \*(L"Full Contents\*(R" then \*(L"Intergalactic dataspeak\*(R" links for the
\&\s-1SQL\s0 history.
.SS "Placeholders and Bind Values"
.IX Subsection "Placeholders and Bind Values"
Some drivers support placeholders and bind values.
\&\fIPlaceholders\fR, also called parameter markers, are used to indicate
values in a database statement that will be supplied later,
before the prepared statement is executed.  For example, an application
might use the following to insert a row of data into the \s-1SALES\s0 table:
.PP
.Vb 1
\&  INSERT INTO sales (product_code, qty, price) VALUES (?, ?, ?)
.Ve
.PP
or the following, to select the description for a product:
.PP
.Vb 1
\&  SELECT description FROM products WHERE product_code = ?
.Ve
.PP
The \f(CW\*(C`?\*(C'\fR characters are the placeholders.  The association of actual
values with placeholders is known as \fIbinding\fR, and the values are
referred to as \fIbind values\fR.
Note that the \f(CW\*(C`?\*(C'\fR is not enclosed in quotation marks, even when the
placeholder represents a string.
.PP
Some drivers also allow placeholders like \f(CW\*(C`:\*(C'\fR\fIname\fR and \f(CW\*(C`:\*(C'\fR\fIN\fR (e.g.,
\&\f(CW\*(C`:1\*(C'\fR, \f(CW\*(C`:2\*(C'\fR, and so on) in addition to \f(CW\*(C`?\*(C'\fR, but their use is not portable.
.PP
If the \f(CW\*(C`:\*(C'\fR\fIN\fR form of placeholder is supported by the driver you're using,
then you should be able to use either \*(L"bind_param\*(R" or \*(L"execute\*(R" to bind
values. Check your driver documentation.
.PP
With most drivers, placeholders can't be used for any element of a
statement that would prevent the database server from validating the
statement and creating a query execution plan for it. For example:
.PP
.Vb 2
\&  "SELECT name, age FROM ?"         # wrong (will probably fail)
\&  "SELECT name, ?   FROM people"    # wrong (but may not \*(Aqfail\*(Aq)
.Ve
.PP
Also, placeholders can only represent single scalar values.
For example, the following
statement won't work as expected for more than one value:
.PP
.Vb 2
\&  "SELECT name, age FROM people WHERE name IN (?)"    # wrong
\&  "SELECT name, age FROM people WHERE name IN (?,?)"  # two names
.Ve
.PP
When using placeholders with the \s-1SQL \s0\f(CW\*(C`LIKE\*(C'\fR qualifier, you must
remember that the placeholder substitutes for the whole string.
So you should use "\f(CW\*(C`... LIKE ? ...\*(C'\fR" and include any wildcard
characters in the value that you bind to the placeholder.
.PP
\&\fB\s-1NULL\s0 Values\fR
.PP
Undefined values, or \f(CW\*(C`undef\*(C'\fR, are used to indicate \s-1NULL\s0 values.
You can insert and update columns with a \s-1NULL\s0 value as you would a
non-NULL value.  These examples insert and update the column
\&\f(CW\*(C`age\*(C'\fR with a \s-1NULL\s0 value:
.PP
.Vb 4
\&  $sth = $dbh\->prepare(qq{
\&    INSERT INTO people (fullname, age) VALUES (?, ?)
\&  });
\&  $sth\->execute("Joe Bloggs", undef);
\&
\&  $sth = $dbh\->prepare(qq{
\&    UPDATE people SET age = ? WHERE fullname = ?
\&  });
\&  $sth\->execute(undef, "Joe Bloggs");
.Ve
.PP
However, care must be taken when trying to use \s-1NULL\s0 values in a
\&\f(CW\*(C`WHERE\*(C'\fR clause.  Consider:
.PP
.Vb 1
\&  SELECT fullname FROM people WHERE age = ?
.Ve
.PP
Binding an \f(CW\*(C`undef\*(C'\fR (\s-1NULL\s0) to the placeholder will \fInot\fR select rows
which have a \s-1NULL \s0\f(CW\*(C`age\*(C'\fR!  At least for database engines that
conform to the \s-1SQL\s0 standard.  Refer to the \s-1SQL\s0 manual for your database
engine or any \s-1SQL\s0 book for the reasons for this.  To explicitly select
NULLs you have to say "\f(CW\*(C`WHERE age IS NULL\*(C'\fR".
.PP
A common issue is to have a code fragment handle a value that could be
either \f(CW\*(C`defined\*(C'\fR or \f(CW\*(C`undef\*(C'\fR (non-NULL or \s-1NULL\s0) at runtime.
A simple technique is to prepare the appropriate statement as needed,
and substitute the placeholder for non-NULL cases:
.PP
.Vb 5
\&  $sql_clause = defined $age? "age = ?" : "age IS NULL";
\&  $sth = $dbh\->prepare(qq{
\&    SELECT fullname FROM people WHERE $sql_clause
\&  });
\&  $sth\->execute(defined $age ? $age : ());
.Ve
.PP
The following technique illustrates qualifying a \f(CW\*(C`WHERE\*(C'\fR clause with
several columns, whose associated values (\f(CW\*(C`defined\*(C'\fR or \f(CW\*(C`undef\*(C'\fR) are
in a hash \f(CW%h:\fR
.PP
.Vb 10
\&  for my $col ("age", "phone", "email") {
\&    if (defined $h{$col}) {
\&      push @sql_qual, "$col = ?";
\&      push @sql_bind, $h{$col};
\&    }
\&    else {
\&      push @sql_qual, "$col IS NULL";
\&    }
\&  }
\&  $sql_clause = join(" AND ", @sql_qual);
\&  $sth = $dbh\->prepare(qq{
\&      SELECT fullname FROM people WHERE $sql_clause
\&  });
\&  $sth\->execute(@sql_bind);
.Ve
.PP
The techniques above call prepare for the \s-1SQL\s0 statement with each call to
execute.  Because calls to \fIprepare()\fR can be expensive, performance
can suffer when an application iterates many times over statements
like the above.
.PP
A better solution is a single \f(CW\*(C`WHERE\*(C'\fR clause that supports both
\&\s-1NULL\s0 and non-NULL comparisons.  Its \s-1SQL\s0 statement would need to be
prepared only once for all cases, thus improving performance.
Several examples of \f(CW\*(C`WHERE\*(C'\fR clauses that support this are presented
below.  But each example lacks portability, robustness, or simplicity.
Whether an example is supported on your database engine depends on
what \s-1SQL\s0 extensions it provides, and where it supports the \f(CW\*(C`?\*(C'\fR
placeholder in a statement.
.PP
.Vb 7
\&  0)  age = ?
\&  1)  NVL(age, xx) = NVL(?, xx)
\&  2)  ISNULL(age, xx) = ISNULL(?, xx)
\&  3)  DECODE(age, ?, 1, 0) = 1
\&  4)  age = ? OR (age IS NULL AND ? IS NULL)
\&  5)  age = ? OR (age IS NULL AND SP_ISNULL(?) = 1)
\&  6)  age = ? OR (age IS NULL AND ? = 1)
.Ve
.PP
Statements formed with the above \f(CW\*(C`WHERE\*(C'\fR clauses require execute
statements as follows.  The arguments are required, whether their
values are \f(CW\*(C`defined\*(C'\fR or \f(CW\*(C`undef\*(C'\fR.
.PP
.Vb 3
\&  0,1,2,3)  $sth\->execute($age);
\&  4,5)      $sth\->execute($age, $age);
\&  6)        $sth\->execute($age, defined($age) ? 0 : 1);
.Ve
.PP
Example 0 should not work (as mentioned earlier), but may work on
a few database engines anyway (e.g. Sybase).  Example 0 is part
of examples 4, 5, and 6, so if example 0 works, these other
examples may work, even if the engine does not properly support
the right hand side of the \f(CW\*(C`OR\*(C'\fR expression.
.PP
Examples 1 and 2 are not robust: they require that you provide a
valid column value xx (e.g. '~') which is not present in any row.
That means you must have some notion of what data won't be stored
in the column, and expect clients to adhere to that.
.PP
Example 5 requires that you provide a stored procedure (\s-1SP_ISNULL\s0
in this example) that acts as a function: it checks whether a value
is null, and returns 1 if it is, or 0 if not.
.PP
Example 6, the least simple, is probably the most portable, i.e., it
should work with most, if not all, database engines.
.PP
Here is a table that indicates which examples above are known to
work on various database engines:
.PP
.Vb 10
\&                   \-\-\-\-\-Examples\-\-\-\-\-\-
\&                   0  1  2  3  4  5  6
\&                   \-  \-  \-  \-  \-  \-  \-
\&  Oracle 9         N  Y  N  Y  Y  ?  Y
\&  Informix IDS 9   N  N  N  Y  N  Y  Y
\&  MS SQL           N  N  Y  N  Y  ?  Y
\&  Sybase           Y  N  N  N  N  N  Y
\&  AnyData,DBM,CSV  Y  N  N  N  Y  Y* Y
\&  SQLite 3.3       N  N  N  N  Y  N  N
\&  MSAccess         N  N  N  N  Y  N  Y
.Ve
.PP
* Works only because Example 0 works.
.PP
\&\s-1DBI\s0 provides a sample perl script that will test the examples above
on your database engine and tell you which ones work.  It is located
in the \fIex/\fR subdirectory of the \s-1DBI\s0 source distribution, or here:
<https://github.com/perl5\-dbi/dbi/blob/master/ex/perl_dbi_nulls_test.pl>
Please use the script to help us fill-in and maintain this table.
.PP
\&\fBPerformance\fR
.PP
Without using placeholders, the insert statement shown previously would have to
contain the literal values to be inserted and would have to be
re-prepared and re-executed for each row. With placeholders, the insert
statement only needs to be prepared once. The bind values for each row
can be given to the \f(CW\*(C`execute\*(C'\fR method each time it's called. By avoiding
the need to re-prepare the statement for each row, the application
typically runs many times faster. Here's an example:
.PP
.Vb 9
\&  my $sth = $dbh\->prepare(q{
\&    INSERT INTO sales (product_code, qty, price) VALUES (?, ?, ?)
\&  }) or die $dbh\->errstr;
\&  while (<>) {
\&      chomp;
\&      my ($product_code, $qty, $price) = split /,/;
\&      $sth\->execute($product_code, $qty, $price) or die $dbh\->errstr;
\&  }
\&  $dbh\->commit or die $dbh\->errstr;
.Ve
.PP
See \*(L"execute\*(R" and \*(L"bind_param\*(R" for more details.
.PP
The \f(CW\*(C`q{...}\*(C'\fR style quoting used in this example avoids clashing with
quotes that may be used in the \s-1SQL\s0 statement. Use the double-quote like
\&\f(CW\*(C`qq{...}\*(C'\fR operator if you want to interpolate variables into the string.
See \*(L"Quote and Quote-like Operators\*(R" in perlop for more details.
.PP
See also the \*(L"bind_columns\*(R" method, which is used to associate Perl
variables with the output columns of a \f(CW\*(C`SELECT\*(C'\fR statement.
.SH "THE DBI PACKAGE AND CLASS"
.IX Header "THE DBI PACKAGE AND CLASS"
In this section, we cover the \s-1DBI\s0 class methods, utility functions,
and the dynamic attributes associated with generic \s-1DBI\s0 handles.
.SS "\s-1DBI\s0 Constants"
.IX Subsection "DBI Constants"
Constants representing the values of the \s-1SQL\s0 standard types can be
imported individually by name, or all together by importing the
special \f(CW\*(C`:sql_types\*(C'\fR tag.
.PP
The names and values of all the defined \s-1SQL\s0 standard types can be
produced like this:
.PP
.Vb 3
\&  foreach (@{ $DBI::EXPORT_TAGS{sql_types} }) {
\&    printf "%s=%d\en", $_, &{"DBI::$_"};
\&  }
.Ve
.PP
These constants are defined by \s-1SQL/CLI, ODBC\s0 or both.
\&\f(CW\*(C`SQL_BIGINT\*(C'\fR has conflicting codes in \s-1SQL/CLI\s0 and \s-1ODBC,
DBI\s0 uses the \s-1ODBC\s0 one.
.PP
See the \*(L"type_info\*(R", \*(L"type_info_all\*(R", and \*(L"bind_param\*(R" methods
for possible uses.
.PP
Note that just because the \s-1DBI\s0 defines a named constant for a given
data type doesn't mean that drivers will support that data type.
.SS "\s-1DBI\s0 Class Methods"
.IX Subsection "DBI Class Methods"
The following methods are provided by the \s-1DBI\s0 class:
.PP
\fI\f(CI\*(C`parse_dsn\*(C'\fI\fR
.IX Subsection "parse_dsn"
.PP
.Vb 2
\&  ($scheme, $driver, $attr_string, $attr_hash, $driver_dsn) = DBI\->parse_dsn($dsn)
\&      or die "Can\*(Aqt parse DBI DSN \*(Aq$dsn\*(Aq";
.Ve
.PP
Breaks apart a \s-1DBI\s0 Data Source Name (\s-1DSN\s0) and returns the individual
parts. If \f(CW$dsn\fR doesn't contain a valid \s-1DSN\s0 then \fIparse_dsn()\fR returns
an empty list.
.PP
\&\f(CW$scheme\fR is the first part of the \s-1DSN\s0 and is currently always 'dbi'.
\&\f(CW$driver\fR is the driver name, possibly defaulted to \f(CW$ENV\fR{\s-1DBI_DRIVER\s0},
and may be undefined.  \f(CW$attr_string\fR is the contents of the optional attribute
string, which may be undefined.  If \f(CW$attr_string\fR is not empty then \f(CW$attr_hash\fR
is a reference to a hash containing the parsed attribute names and values.
\&\f(CW$driver_dsn\fR is the last part of the \s-1DBI DSN\s0 string. For example:
.PP
.Vb 7
\&  ($scheme, $driver, $attr_string, $attr_hash, $driver_dsn)
\&      = DBI\->parse_dsn("DBI:MyDriver(RaiseError=>1):db=test;port=42");
\&  $scheme      = \*(Aqdbi\*(Aq;
\&  $driver      = \*(AqMyDriver\*(Aq;
\&  $attr_string = \*(AqRaiseError=>1\*(Aq;
\&  $attr_hash   = { \*(AqRaiseError\*(Aq => \*(Aq1\*(Aq };
\&  $driver_dsn  = \*(Aqdb=test;port=42\*(Aq;
.Ve
.PP
The \fIparse_dsn()\fR method was added in \s-1DBI 1.43.\s0
.PP
\fI\f(CI\*(C`connect\*(C'\fI\fR
.IX Subsection "connect"
.PP
.Vb 4
\&  $dbh = DBI\->connect($data_source, $username, $password)
\&            or die $DBI::errstr;
\&  $dbh = DBI\->connect($data_source, $username, $password, \e%attr)
\&            or die $DBI::errstr;
.Ve
.PP
Establishes a database connection, or session, to the requested \f(CW$data_source\fR.
Returns a database handle object if the connection succeeds. Use
\&\f(CW\*(C`$dbh\->disconnect\*(C'\fR to terminate the connection.
.PP
If the connect fails (see below), it returns \f(CW\*(C`undef\*(C'\fR and sets both \f(CW$DBI::err\fR
and \f(CW$DBI::errstr\fR. (It does \fInot\fR explicitly set \f(CW$!\fR.) You should generally
test the return status of \f(CW\*(C`connect\*(C'\fR and \f(CW\*(C`print $DBI::errstr\*(C'\fR if it has failed.
.PP
Multiple simultaneous connections to multiple databases through multiple
drivers can be made via the \s-1DBI.\s0 Simply make one \f(CW\*(C`connect\*(C'\fR call for each
database and keep a copy of each returned database handle.
.PP
The \f(CW$data_source\fR value must begin with "\f(CW\*(C`dbi:\*(C'\fR\fIdriver_name\fR\f(CW\*(C`:\*(C'\fR".
The \fIdriver_name\fR specifies the driver that will be used to make the
connection. (Letter case is significant.)
.PP
As a convenience, if the \f(CW$data_source\fR parameter is undefined or empty,
the \s-1DBI\s0 will substitute the value of the environment variable \f(CW\*(C`DBI_DSN\*(C'\fR.
If just the \fIdriver_name\fR part is empty (i.e., the \f(CW$data_source\fR
prefix is "\f(CW\*(C`dbi::\*(C'\fR"), the environment variable \f(CW\*(C`DBI_DRIVER\*(C'\fR is
used. If neither variable is set, then \f(CW\*(C`connect\*(C'\fR dies.
.PP
Examples of \f(CW$data_source\fR values are:
.PP
.Vb 3
\&  dbi:DriverName:database_name
\&  dbi:DriverName:database_name@hostname:port
\&  dbi:DriverName:database=database_name;host=hostname;port=port
.Ve
.PP
There is \fIno standard\fR for the text following the driver name. Each
driver is free to use whatever syntax it wants. The only requirement the
\&\s-1DBI\s0 makes is that all the information is supplied in a single string.
You must consult the documentation for the drivers you are using for a
description of the syntax they require.
.PP
It is recommended that drivers support the \s-1ODBC\s0 style, shown in the
last example above. It is also recommended that they support the
three common names '\f(CW\*(C`host\*(C'\fR', '\f(CW\*(C`port\*(C'\fR', and '\f(CW\*(C`database\*(C'\fR' (plus '\f(CW\*(C`db\*(C'\fR'
as an alias for \f(CW\*(C`database\*(C'\fR). This simplifies automatic construction
of basic DSNs: \f(CW"dbi:$driver:database=$db;host=$host;port=$port"\fR.
Drivers should aim to 'do something reasonable' when given a \s-1DSN\s0
in this form, but if any part is meaningless for that driver (such
as 'port' for Informix) it should generate an error if that part
is not empty.
.PP
If the environment variable \f(CW\*(C`DBI_AUTOPROXY\*(C'\fR is defined (and the
driver in \f(CW$data_source\fR is not "\f(CW\*(C`Proxy\*(C'\fR") then the connect request
will automatically be changed to:
.PP
.Vb 1
\&  $ENV{DBI_AUTOPROXY};dsn=$data_source
.Ve
.PP
\&\f(CW\*(C`DBI_AUTOPROXY\*(C'\fR is typically set as "\f(CW\*(C`dbi:Proxy:hostname=...;port=...\*(C'\fR".
If \f(CW$ENV\fR{\s-1DBI_AUTOPROXY\s0} doesn't begin with '\f(CW\*(C`dbi:\*(C'\fR' then \*(L"dbi:Proxy:\*(R"
will be prepended to it first.  See the DBD::Proxy documentation
for more details.
.PP
If \f(CW$username\fR or \f(CW$password\fR are undefined (rather than just empty),
then the \s-1DBI\s0 will substitute the values of the \f(CW\*(C`DBI_USER\*(C'\fR and \f(CW\*(C`DBI_PASS\*(C'\fR
environment variables, respectively.  The \s-1DBI\s0 will warn if the
environment variables are not defined.  However, the everyday use
of these environment variables is not recommended for security
reasons. The mechanism is primarily intended to simplify testing.
See below for alternative way to specify the username and password.
.PP
\&\f(CW\*(C`DBI\->connect\*(C'\fR automatically installs the driver if it has not been
installed yet. Driver installation either returns a valid driver
handle, or it \fIdies\fR with an error message that includes the string
"\f(CW\*(C`install_driver\*(C'\fR" and the underlying problem. So \f(CW\*(C`DBI\->connect\*(C'\fR
will die
on a driver installation failure and will only return \f(CW\*(C`undef\*(C'\fR on a
connect failure, in which case \f(CW$DBI::errstr\fR will hold the error message.
Use \f(CW\*(C`eval { ... }\*(C'\fR if you need to catch the "\f(CW\*(C`install_driver\*(C'\fR" error.
.PP
The \f(CW$data_source\fR argument (with the "\f(CW\*(C`dbi:...:\*(C'\fR" prefix removed) and the
\&\f(CW$username\fR and \f(CW$password\fR arguments are then passed to the driver for
processing. The \s-1DBI\s0 does not define any interpretation for the
contents of these fields.  The driver is free to interpret the
\&\f(CW$data_source\fR, \f(CW$username\fR, and \f(CW$password\fR fields in any way, and supply
whatever defaults are appropriate for the engine being accessed.
(Oracle, for example, uses the \s-1ORACLE_SID\s0 and \s-1TWO_TASK\s0 environment
variables if no \f(CW$data_source\fR is specified.)
.PP
The \f(CW\*(C`AutoCommit\*(C'\fR and \f(CW\*(C`PrintError\*(C'\fR attributes for each connection
default to \*(L"on\*(R". (See \*(L"AutoCommit\*(R" and \*(L"PrintError\*(R" for more information.)
However, it is strongly recommended that you explicitly define \f(CW\*(C`AutoCommit\*(C'\fR
rather than rely on the default. The \f(CW\*(C`PrintWarn\*(C'\fR attribute defaults to true.
.PP
The \f(CW\*(C`\e%attr\*(C'\fR parameter can be used to alter the default settings of
\&\f(CW\*(C`PrintError\*(C'\fR, \f(CW\*(C`RaiseError\*(C'\fR, \f(CW\*(C`AutoCommit\*(C'\fR, and other attributes. For example:
.PP
.Vb 4
\&  $dbh = DBI\->connect($data_source, $user, $pass, {
\&        PrintError => 0,
\&        AutoCommit => 0
\&  });
.Ve
.PP
The username and password can also be specified using the attributes
\&\f(CW\*(C`Username\*(C'\fR and \f(CW\*(C`Password\*(C'\fR, in which case they take precedence
over the \f(CW$username\fR and \f(CW$password\fR parameters.
.PP
You can also define connection attribute values within the \f(CW$data_source\fR
parameter. For example:
.PP
.Vb 1
\&  dbi:DriverName(PrintWarn=>0,PrintError=>0,Taint=>1):...
.Ve
.PP
Individual attributes values specified in this way take precedence over
any conflicting values specified via the \f(CW\*(C`\e%attr\*(C'\fR parameter to \f(CW\*(C`connect\*(C'\fR.
.PP
The \f(CW\*(C`dbi_connect_method\*(C'\fR attribute can be used to specify which driver
method should be called to establish the connection. The only useful
values are 'connect', 'connect_cached', or some specialized case like
\&'Apache::DBI::connect' (which is automatically the default when running
within Apache).
.PP
Where possible, each session (\f(CW$dbh\fR) is independent from the transactions
in other sessions. This is useful when you need to hold cursors open
across transactions\*(--for example, if you use one session for your long lifespan
cursors (typically read-only) and another for your short update
transactions.
.PP
For compatibility with old \s-1DBI\s0 scripts, the driver can be specified by
passing its name as the fourth argument to \f(CW\*(C`connect\*(C'\fR (instead of \f(CW\*(C`\e%attr\*(C'\fR):
.PP
.Vb 1
\&  $dbh = DBI\->connect($data_source, $user, $pass, $driver);
.Ve
.PP
In this \*(L"old-style\*(R" form of \f(CW\*(C`connect\*(C'\fR, the \f(CW$data_source\fR should not start
with "\f(CW\*(C`dbi:driver_name:\*(C'\fR". (If it does, the embedded driver_name
will be ignored). Also note that in this older form of \f(CW\*(C`connect\*(C'\fR,
the \f(CW\*(C`$dbh\->{AutoCommit}\*(C'\fR attribute is \fIundefined\fR, the
\&\f(CW\*(C`$dbh\->{PrintError}\*(C'\fR attribute is off, and the old \f(CW\*(C`DBI_DBNAME\*(C'\fR
environment variable is
checked if \f(CW\*(C`DBI_DSN\*(C'\fR is not defined. Beware that this \*(L"old-style\*(R"
\&\f(CW\*(C`connect\*(C'\fR will soon be withdrawn in a future version of \s-1DBI.\s0
.PP
\fI\f(CI\*(C`connect_cached\*(C'\fI\fR
.IX Subsection "connect_cached"
.PP
.Vb 4
\&  $dbh = DBI\->connect_cached($data_source, $username, $password)
\&            or die $DBI::errstr;
\&  $dbh = DBI\->connect_cached($data_source, $username, $password, \e%attr)
\&            or die $DBI::errstr;
.Ve
.PP
\&\f(CW\*(C`connect_cached\*(C'\fR is like \*(L"connect\*(R", except that the database handle
returned is also
stored in a hash associated with the given parameters. If another call
is made to \f(CW\*(C`connect_cached\*(C'\fR with the same parameter values, then the
corresponding cached \f(CW$dbh\fR will be returned if it is still valid.
The cached database handle is replaced with a new connection if it
has been disconnected or if the \f(CW\*(C`ping\*(C'\fR method fails.
.PP
Note that the behaviour of this method differs in several respects from the
behaviour of persistent connections implemented by Apache::DBI.
However, if Apache::DBI is loaded then \f(CW\*(C`connect_cached\*(C'\fR will use it.
.PP
Caching connections can be useful in some applications, but it can
also cause problems, such as too many connections, and so should
be used with care. In particular, avoid changing the attributes of
a database handle created via \fIconnect_cached()\fR because it will affect
other code that may be using the same handle. When \fIconnect_cached()\fR
returns a handle the attributes will be reset to their initial values.
This can cause problems, especially with the \f(CW\*(C`AutoCommit\*(C'\fR attribute.
.PP
Also, to ensure that the attributes passed are always the same, avoid passing
references inline. For example, the \f(CW\*(C`Callbacks\*(C'\fR attribute is specified as a
hash reference. Be sure to declare it external to the call to
\&\fIconnect_cached()\fR, such that the hash reference is not re-created on every
call. A package-level lexical works well:
.PP
.Vb 4
\&  package MyDBH;
\&  my $cb = {
\&      \*(Aqconnect_cached.reused\*(Aq => sub { delete $_[4]\->{AutoCommit} },
\&  };
\&
\&  sub dbh {
\&      DBI\->connect_cached( $dsn, $username, $auth, { Callbacks => $cb });
\&  }
.Ve
.PP
Where multiple separate parts of a program are using \fIconnect_cached()\fR
to connect to the same database with the same (initial) attributes
it is a good idea to add a private attribute to the \fIconnect_cached()\fR
call to effectively limit the scope of the caching. For example:
.PP
.Vb 1
\&  DBI\->connect_cached(..., { private_foo_cachekey => "Bar", ... });
.Ve
.PP
Handles returned from that \fIconnect_cached()\fR call will only be returned
by other \fIconnect_cached()\fR call elsewhere in the code if those other
calls also pass in the same attribute values, including the private one.
(I've used \f(CW\*(C`private_foo_cachekey\*(C'\fR here as an example, you can use
any attribute name with a \f(CW\*(C`private_\*(C'\fR prefix.)
.PP
Taking that one step further, you can limit a particular \fIconnect_cached()\fR
call to return handles unique to that one place in the code by setting the
private attribute to a unique value for that place:
.PP
.Vb 1
\&  DBI\->connect_cached(..., { private_foo_cachekey => _\|_FILE_\|_._\|_LINE_\|_, ... });
.Ve
.PP
By using a private attribute you still get connection caching for
the individual calls to \fIconnect_cached()\fR but, by making separate
database connections for separate parts of the code, the database
handles are isolated from any attribute changes made to other handles.
.PP
The cache can be accessed (and cleared) via the \*(L"CachedKids\*(R" attribute:
.PP
.Vb 2
\&  my $CachedKids_hashref = $dbh\->{Driver}\->{CachedKids};
\&  %$CachedKids_hashref = () if $CachedKids_hashref;
.Ve
.PP
\fI\f(CI\*(C`available_drivers\*(C'\fI\fR
.IX Subsection "available_drivers"
.PP
.Vb 2
\&  @ary = DBI\->available_drivers;
\&  @ary = DBI\->available_drivers($quiet);
.Ve
.PP
Returns a list of all available drivers by searching for \f(CW\*(C`DBD::*\*(C'\fR modules
through the directories in \f(CW@INC\fR. By default, a warning is given if
some drivers are hidden by others of the same name in earlier
directories. Passing a true value for \f(CW$quiet\fR will inhibit the warning.
.PP
\fI\f(CI\*(C`installed_drivers\*(C'\fI\fR
.IX Subsection "installed_drivers"
.PP
.Vb 1
\&  %drivers = DBI\->installed_drivers();
.Ve
.PP
Returns a list of driver name and driver handle pairs for all drivers
\&'installed' (loaded) into the current process.  The driver name does not
include the '\s-1DBD::\s0' prefix.
.PP
To get a list of all drivers available in your perl installation you can use
\&\*(L"available_drivers\*(R".
.PP
Added in \s-1DBI 1.49.\s0
.PP
\fI\f(CI\*(C`installed_versions\*(C'\fI\fR
.IX Subsection "installed_versions"
.PP
.Vb 3
\&  DBI\->installed_versions;
\&  @ary  = DBI\->installed_versions;
\&  $hash = DBI\->installed_versions;
.Ve
.PP
Calls \fIavailable_drivers()\fR and attempts to load each of them in turn
using \fIinstall_driver()\fR.  For each load that succeeds the driver
name and version number are added to a hash. When running under
DBI::PurePerl drivers which appear not be pure-perl are ignored.
.PP
When called in array context the list of successfully loaded drivers
is returned (without the '\s-1DBD::\s0' prefix).
.PP
When called in scalar context an extra entry for the \f(CW\*(C`DBI\*(C'\fR is added (and
\&\f(CW\*(C`DBI::PurePerl\*(C'\fR if appropriate) and a reference to the hash is returned.
.PP
When called in a void context the \fIinstalled_versions()\fR method will
print out a formatted list of the hash contents, one per line, along with some
other information about the \s-1DBI\s0 version and \s-1OS.\s0
.PP
Due to the potentially high memory cost and unknown risks of loading
in an unknown number of drivers that just happen to be installed
on the system, this method is not recommended for general use.
Use \fIavailable_drivers()\fR instead.
.PP
The \fIinstalled_versions()\fR method is primarily intended as a quick
way to see from the command line what's installed. For example:
.PP
.Vb 1
\&  perl \-MDBI \-e \*(AqDBI\->installed_versions\*(Aq
.Ve
.PP
The \fIinstalled_versions()\fR method was added in \s-1DBI 1.38.\s0
.PP
\fI\f(CI\*(C`data_sources\*(C'\fI\fR
.IX Subsection "data_sources"
.PP
.Vb 2
\&  @ary = DBI\->data_sources($driver);
\&  @ary = DBI\->data_sources($driver, \e%attr);
.Ve
.PP
Returns a list of data sources (databases) available via the named
driver.  If \f(CW$driver\fR is empty or \f(CW\*(C`undef\*(C'\fR, then the value of the
\&\f(CW\*(C`DBI_DRIVER\*(C'\fR environment variable is used.
.PP
The driver will be loaded if it hasn't been already. Note that if the
driver loading fails then \fIdata_sources()\fR \fIdies\fR with an error message
that includes the string "\f(CW\*(C`install_driver\*(C'\fR" and the underlying problem.
.PP
Data sources are returned in a form suitable for passing to the
\&\*(L"connect\*(R" method (that is, they will include the "\f(CW\*(C`dbi:$driver:\*(C'\fR" prefix).
.PP
Note that many drivers have no way of knowing what data sources might
be available for it. These drivers return an empty or incomplete list
or may require driver-specific attributes.
.PP
There is also a \fIdata_sources()\fR method defined for database handles.
.PP
\fI\f(CI\*(C`trace\*(C'\fI\fR
.IX Subsection "trace"
.PP
.Vb 4
\&  DBI\->trace($trace_setting)
\&  DBI\->trace($trace_setting, $trace_filename)
\&  DBI\->trace($trace_setting, $trace_filehandle)
\&  $trace_setting = DBI\->trace;
.Ve
.PP
The \f(CW\*(C`DBI\->trace\*(C'\fR method sets the \fIglobal default\fR trace
settings and returns the \fIprevious\fR trace settings. It can also
be used to change where the trace output is sent.
.PP
There's a similar method, \f(CW\*(C`$h\->trace\*(C'\fR, which sets the trace
settings for the specific handle it's called on.
.PP
See the \*(L"\s-1TRACING\*(R"\s0 section for full details about the \s-1DBI\s0's powerful
tracing facilities.
.PP
\fI\f(CI\*(C`visit_handles\*(C'\fI\fR
.IX Subsection "visit_handles"
.PP
.Vb 2
\&  DBI\->visit_handles( $coderef );
\&  DBI\->visit_handles( $coderef, $info );
.Ve
.PP
Where \f(CW$coderef\fR is a reference to a subroutine and \f(CW$info\fR is an arbitrary value
which, if undefined, defaults to a reference to an empty hash. Returns \f(CW$info\fR.
.PP
For each installed driver handle, if any, \f(CW$coderef\fR is invoked as:
.PP
.Vb 1
\&  $coderef\->($driver_handle, $info);
.Ve
.PP
If the execution of \f(CW$coderef\fR returns a true value then \*(L"visit_child_handles\*(R"
is called on that child handle and passed the returned value as \f(CW$info\fR.
.PP
For example:
.PP
.Vb 5
\&  my $info = $dbh\->{Driver}\->visit_child_handles(sub {
\&      my ($h, $info) = @_;
\&      ++$info\->{ $h\->{Type} }; # count types of handles (dr/db/st)
\&      return $info; # visit kids
\&  });
.Ve
.PP
See also \*(L"visit_child_handles\*(R".
.SS "\s-1DBI\s0 Utility Functions"
.IX Subsection "DBI Utility Functions"
In addition to the \s-1DBI\s0 methods listed in the previous section,
the \s-1DBI\s0 package also provides several utility functions.
.PP
These can be imported into your code by listing them in
the \f(CW\*(C`use\*(C'\fR statement. For example:
.PP
.Vb 1
\&  use DBI qw(neat data_diff);
.Ve
.PP
Alternatively, all these utility functions (except hash) can be
imported using the \f(CW\*(C`:utils\*(C'\fR import tag. For example:
.PP
.Vb 1
\&  use DBI qw(:utils);
.Ve
.PP
\fI\f(CI\*(C`data_string_desc\*(C'\fI\fR
.IX Subsection "data_string_desc"
.PP
.Vb 1
\&  $description = data_string_desc($string);
.Ve
.PP
Returns an informal description of the string. For example:
.PP
.Vb 5
\&  UTF8 off, ASCII, 42 characters 42 bytes
\&  UTF8 off, non\-ASCII, 42 characters 42 bytes
\&  UTF8 on, non\-ASCII, 4 characters 6 bytes
\&  UTF8 on but INVALID encoding, non\-ASCII, 4 characters 6 bytes
\&  UTF8 off, undef
.Ve
.PP
The initial \f(CW\*(C`UTF8\*(C'\fR on/off refers to Perl's internal SvUTF8 flag.
If \f(CW$string\fR has the SvUTF8 flag set but the sequence of bytes it
contains are not a valid \s-1UTF\-8\s0 encoding then \fIdata_string_desc()\fR
will report \f(CW\*(C`UTF8 on but INVALID encoding\*(C'\fR.
.PP
The \f(CW\*(C`ASCII\*(C'\fR vs \f(CW\*(C`non\-ASCII\*(C'\fR portion shows \f(CW\*(C`ASCII\*(C'\fR if \fIall\fR the
characters in the string are \s-1ASCII \s0(have code points <= 127).
.PP
The \fIdata_string_desc()\fR function was added in \s-1DBI 1.46.\s0
.PP
\fI\f(CI\*(C`data_string_diff\*(C'\fI\fR
.IX Subsection "data_string_diff"
.PP
.Vb 1
\&  $diff = data_string_diff($a, $b);
.Ve
.PP
Returns an informal description of the first character difference
between the strings. If both \f(CW$a\fR and \f(CW$b\fR contain the same sequence
of characters then \fIdata_string_diff()\fR returns an empty string.
For example:
.PP
.Vb 6
\& Params a & b     Result
\& \-\-\-\-\-\-\-\-\-\-\-\-     \-\-\-\-\-\-
\& \*(Aqaaa\*(Aq, \*(Aqaaa\*(Aq     \*(Aq\*(Aq
\& \*(Aqaaa\*(Aq, \*(Aqabc\*(Aq     \*(AqStrings differ at index 2: a[2]=a, b[2]=b\*(Aq
\& \*(Aqaaa\*(Aq, undef     \*(AqString b is undef, string a has 3 characters\*(Aq
\& \*(Aqaaa\*(Aq, \*(Aqaa\*(Aq      \*(AqString b truncated after 2 characters\*(Aq
.Ve
.PP
Unicode characters are reported in \f(CW\*(C`\ex{XXXX}\*(C'\fR format. Unicode
code points in the range U+0800 to U+08FF are unassigned and most
likely to occur due to double-encoding. Characters in this range
are reported as \f(CW\*(C`\ex{08XX}=\*(AqC\*(Aq\*(C'\fR where \f(CW\*(C`C\*(C'\fR is the corresponding
latin\-1 character.
.PP
The \fIdata_string_diff()\fR function only considers logical \fIcharacters\fR
and not the underlying encoding. See \*(L"data_diff\*(R" for an alternative.
.PP
The \fIdata_string_diff()\fR function was added in \s-1DBI 1.46.\s0
.PP
\fI\f(CI\*(C`data_diff\*(C'\fI\fR
.IX Subsection "data_diff"
.PP
.Vb 2
\&  $diff = data_diff($a, $b);
\&  $diff = data_diff($a, $b, $logical);
.Ve
.PP
Returns an informal description of the difference between two strings.
It calls \*(L"data_string_desc\*(R" and \*(L"data_string_diff\*(R"
and returns the combined results as a multi-line string.
.PP
For example, \f(CW\*(C`data_diff("abc", "ab\ex{263a}")\*(C'\fR will return:
.PP
.Vb 3
\&  a: UTF8 off, ASCII, 3 characters 3 bytes
\&  b: UTF8 on, non\-ASCII, 3 characters 5 bytes
\&  Strings differ at index 2: a[2]=c, b[2]=\ex{263A}
.Ve
.PP
If \f(CW$a\fR and \f(CW$b\fR are identical in both the characters they contain \fIand\fR
their physical encoding then \fIdata_diff()\fR returns an empty string.
If \f(CW$logical\fR is true then physical encoding differences are ignored
(but are still reported if there is a difference in the characters).
.PP
The \fIdata_diff()\fR function was added in \s-1DBI 1.46.\s0
.PP
\fI\f(CI\*(C`neat\*(C'\fI\fR
.IX Subsection "neat"
.PP
.Vb 2
\&  $str = neat($value);
\&  $str = neat($value, $maxlen);
.Ve
.PP
Return a string containing a neat (and tidy) representation of the
supplied value.
.PP
Strings will be quoted, although internal quotes will \fInot\fR be escaped.
Values known to be numeric will be unquoted. Undefined (\s-1NULL\s0) values
will be shown as \f(CW\*(C`undef\*(C'\fR (without quotes).
.PP
If the string is flagged internally as utf8 then double quotes will
be used, otherwise single quotes are used and unprintable characters
will be replaced by dot (.).
.PP
For result strings longer than \f(CW$maxlen\fR the result string will be
truncated to \f(CW\*(C`$maxlen\-4\*(C'\fR and "\f(CW\*(C`...\*(Aq\*(C'\fR" will be appended.  If \f(CW$maxlen\fR is 0
or \f(CW\*(C`undef\*(C'\fR, it defaults to \f(CW$DBI::neat_maxlen\fR which, in turn, defaults to 400.
.PP
This function is designed to format values for human consumption.
It is used internally by the \s-1DBI\s0 for \*(L"trace\*(R" output. It should
typically \fInot\fR be used for formatting values for database use.
(See also \*(L"quote\*(R".)
.PP
\fI\f(CI\*(C`neat_list\*(C'\fI\fR
.IX Subsection "neat_list"
.PP
.Vb 1
\&  $str = neat_list(\e@listref, $maxlen, $field_sep);
.Ve
.PP
Calls \f(CW\*(C`neat\*(C'\fR on each element of the list and returns a string
containing the results joined with \f(CW$field_sep\fR. \f(CW$field_sep\fR defaults
to \f(CW", "\fR.
.PP
\fI\f(CI\*(C`looks_like_number\*(C'\fI\fR
.IX Subsection "looks_like_number"
.PP
.Vb 1
\&  @bool = looks_like_number(@array);
.Ve
.PP
Returns true for each element that looks like a number.
Returns false for each element that does not look like a number.
Returns \f(CW\*(C`undef\*(C'\fR for each element that is undefined or empty.
.PP
\fI\f(CI\*(C`hash\*(C'\fI\fR
.IX Subsection "hash"
.PP
.Vb 1
\&  $hash_value = DBI::hash($buffer, $type);
.Ve
.PP
Return a 32\-bit integer 'hash' value corresponding to the contents of \f(CW$buffer\fR.
The \f(CW$type\fR parameter selects which kind of hash algorithm should be used.
.PP
For the technically curious, type 0 (which is the default if \f(CW$type\fR
isn't specified) is based on the Perl 5.1 hash except that the value
is forced to be negative (for obscure historical reasons).
Type 1 is the better \*(L"Fowler / Noll / Vo\*(R" (\s-1FNV\s0) hash. See
<http://www.isthe.com/chongo/tech/comp/fnv/> for more information.
Both types are implemented in C and are very fast.
.PP
This function doesn't have much to do with databases, except that
it can be handy to store hash values in a database.
.PP
\fI\f(CI\*(C`sql_type_cast\*(C'\fI\fR
.IX Subsection "sql_type_cast"
.PP
.Vb 1
\&  $sts = DBI::sql_type_cast($sv, $sql_type, $flags);
.Ve
.PP
sql_type_cast attempts to cast \f(CW$sv\fR to the \s-1SQL\s0 type (see \s-1DBI\s0
Constants) specified in \f(CW$sql_type\fR. At present only the \s-1SQL\s0 types
\&\f(CW\*(C`SQL_INTEGER\*(C'\fR, \f(CW\*(C`SQL_DOUBLE\*(C'\fR and \f(CW\*(C`SQL_NUMERIC\*(C'\fR are supported.
.PP
For \f(CW\*(C`SQL_INTEGER\*(C'\fR the effect is similar to using the value in an expression
that requires an integer. It gives the perl scalar an 'integer aspect'.
(Technically the value gains an \s-1IV,\s0 or possibly a \s-1UV\s0 or \s-1NV\s0 if the value is too
large for an \s-1IV.\s0)
.PP
For \f(CW\*(C`SQL_DOUBLE\*(C'\fR the effect is similar to using the value in an expression
that requires a general numeric value. It gives the perl scalar a 'numeric
aspect'.  (Technically the value gains an \s-1NV.\s0)
.PP
\&\f(CW\*(C`SQL_NUMERIC\*(C'\fR is similar to \f(CW\*(C`SQL_INTEGER\*(C'\fR or \f(CW\*(C`SQL_DOUBLE\*(C'\fR but more
general and more cautious.  It will look at the string first and if it
looks like an integer (that will fit in an \s-1IV\s0 or \s-1UV\s0) it will act like
\&\f(CW\*(C`SQL_INTEGER\*(C'\fR, if it looks like a floating point value it will act
like \f(CW\*(C`SQL_DOUBLE\*(C'\fR, if it looks like neither then it will do nothing \-
and thereby avoid the warnings that would be generated by
\&\f(CW\*(C`SQL_INTEGER\*(C'\fR and \f(CW\*(C`SQL_DOUBLE\*(C'\fR when given non-numeric data.
.PP
\&\f(CW$flags\fR may be:
.ie n .IP """DBIstcf_DISCARD_STRING""" 4
.el .IP "\f(CWDBIstcf_DISCARD_STRING\fR" 4
.IX Item "DBIstcf_DISCARD_STRING"
If this flag is specified then when the driver successfully casts the
bound perl scalar to a non-string type then the string portion of the
scalar will be discarded.
.ie n .IP """DBIstcf_STRICT""" 4
.el .IP "\f(CWDBIstcf_STRICT\fR" 4
.IX Item "DBIstcf_STRICT"
If \f(CW$sv\fR cannot be cast to the requested \f(CW$sql_type\fR then by default
it is left untouched and no error is generated. If you specify
\&\f(CW\*(C`DBIstcf_STRICT\*(C'\fR and the cast fails, this will generate an error.
.PP
The returned \f(CW$sts\fR value is:
.PP
.Vb 5
\&  \-2 sql_type is not handled
\&  \-1 sv is undef so unchanged
\&   0 sv could not be cast cleanly and DBIstcf_STRICT was used
\&   1 sv could not be cast and DBIstcf_STRICT was not used
\&   2 sv was cast successfully
.Ve
.PP
This method is exported by the :utils tag and was introduced in \s-1DBI
1.611.\s0
.SS "\s-1DBI\s0 Dynamic Attributes"
.IX Subsection "DBI Dynamic Attributes"
Dynamic attributes are always associated with the \fIlast handle used\fR
(that handle is represented by \f(CW$h\fR in the descriptions below).
.PP
Where an attribute is equivalent to a method call, then refer to
the method call for all related documentation.
.PP
Warning: these attributes are provided as a convenience but they
do have limitations. Specifically, they have a short lifespan:
because they are associated with
the last handle used, they should only be used \fIimmediately\fR after
calling the method that \*(L"sets\*(R" them.
If in any doubt, use the corresponding method call.
.PP
\fI\f(CI$DBI::err\fI\fR
.IX Subsection "$DBI::err"
.PP
Equivalent to \f(CW\*(C`$h\->err\*(C'\fR.
.PP
\fI\f(CI$DBI::errstr\fI\fR
.IX Subsection "$DBI::errstr"
.PP
Equivalent to \f(CW\*(C`$h\->errstr\*(C'\fR.
.PP
\fI\f(CI$DBI::state\fI\fR
.IX Subsection "$DBI::state"
.PP
Equivalent to \f(CW\*(C`$h\->state\*(C'\fR.
.PP
\fI\f(CI$DBI::rows\fI\fR
.IX Subsection "$DBI::rows"
.PP
Equivalent to \f(CW\*(C`$h\->rows\*(C'\fR. Please refer to the documentation
for the \*(L"rows\*(R" method.
.PP
\fI\f(CI$DBI::lasth\fI\fR
.IX Subsection "$DBI::lasth"
.PP
Returns the \s-1DBI\s0 object handle used for the most recent \s-1DBI\s0 method call.
If the last \s-1DBI\s0 method call was a \s-1DESTROY\s0 then \f(CW$DBI::lasth\fR will return
the handle of the parent of the destroyed handle, if there is one.
.SH "METHODS COMMON TO ALL HANDLES"
.IX Header "METHODS COMMON TO ALL HANDLES"
The following methods can be used by all types of \s-1DBI\s0 handles.
.PP
\fI\f(CI\*(C`err\*(C'\fI\fR
.IX Subsection "err"
.PP
.Vb 1
\&  $rv = $h\->err;
.Ve
.PP
Returns the \fInative\fR database engine error code from the last driver
method called. The code is typically an integer but you should not
assume that.
.PP
The \s-1DBI\s0 resets \f(CW$h\fR\->err to undef before almost all \s-1DBI\s0 method calls, so the
value only has a short lifespan. Also, for most drivers, the statement
handles share the same error variable as the parent database handle,
so calling a method on one handle may reset the error on the
related handles.
.PP
(Methods which don't reset err before being called include \fIerr()\fR and \fIerrstr()\fR,
obviously, \fIstate()\fR, \fIrows()\fR, \fIfunc()\fR, \fItrace()\fR, \fItrace_msg()\fR, \fIping()\fR, and the
tied hash attribute \s-1\fIFETCH\s0()\fR and \s-1\fISTORE\s0()\fR methods.)
.PP
If you need to test for specific error conditions \fIand\fR have your program be
portable to different database engines, then you'll need to determine what the
corresponding error codes are for all those engines and test for all of them.
.PP
The \s-1DBI\s0 uses the value of \f(CW$DBI::stderr\fR as the \f(CW\*(C`err\*(C'\fR value for internal errors.
Drivers should also do likewise.  The default value for \f(CW$DBI::stderr\fR is 2000000000.
.PP
A driver may return \f(CW0\fR from \fIerr()\fR to indicate a warning condition
after a method call. Similarly, a driver may return an empty string
to indicate a 'success with information' condition. In both these
cases the value is false but not undef. The \fIerrstr()\fR and \fIstate()\fR
methods may be used to retrieve extra information in these cases.
.PP
See \*(L"set_err\*(R" for more information.
.PP
\fI\f(CI\*(C`errstr\*(C'\fI\fR
.IX Subsection "errstr"
.PP
.Vb 1
\&  $str = $h\->errstr;
.Ve
.PP
Returns the native database engine error message from the last \s-1DBI\s0
method called. This has the same lifespan issues as the \*(L"err\*(R" method
described above.
.PP
The returned string may contain multiple messages separated by
newline characters.
.PP
The \fIerrstr()\fR method should not be used to test for errors, use \fIerr()\fR
for that, because drivers may return 'success with information' or
warning messages via \fIerrstr()\fR for methods that have not 'failed'.
.PP
See \*(L"set_err\*(R" for more information.
.PP
\fI\f(CI\*(C`state\*(C'\fI\fR
.IX Subsection "state"
.PP
.Vb 1
\&  $str = $h\->state;
.Ve
.PP
Returns a state code in the standard \s-1SQLSTATE\s0 five character format.
Note that the specific success code \f(CW00000\fR is translated to any empty string
(false). If the driver does not support \s-1SQLSTATE \s0(and most don't),
then \fIstate()\fR will return \f(CW\*(C`S1000\*(C'\fR (General Error) for all errors.
.PP
The driver is free to return any value via \f(CW\*(C`state\*(C'\fR, e.g., warning
codes, even if it has not declared an error by returning a true value
via the \*(L"err\*(R" method described above.
.PP
The \fIstate()\fR method should not be used to test for errors, use \fIerr()\fR
for that, because drivers may return a 'success with information' or
warning state code via \fIstate()\fR for methods that have not 'failed'.
.PP
\fI\f(CI\*(C`set_err\*(C'\fI\fR
.IX Subsection "set_err"
.PP
.Vb 4
\&  $rv = $h\->set_err($err, $errstr);
\&  $rv = $h\->set_err($err, $errstr, $state);
\&  $rv = $h\->set_err($err, $errstr, $state, $method);
\&  $rv = $h\->set_err($err, $errstr, $state, $method, $rv);
.Ve
.PP
Set the \f(CW\*(C`err\*(C'\fR, \f(CW\*(C`errstr\*(C'\fR, and \f(CW\*(C`state\*(C'\fR values for the handle.
This method is typically only used by \s-1DBI\s0 drivers and \s-1DBI\s0 subclasses.
.PP
If the \*(L"HandleSetErr\*(R" attribute holds a reference to a subroutine
it is called first. The subroutine can alter the \f(CW$err\fR, \f(CW$errstr\fR, \f(CW$state\fR,
and \f(CW$method\fR values. See \*(L"HandleSetErr\*(R" for full details.
If the subroutine returns a true value then the handle \f(CW\*(C`err\*(C'\fR,
\&\f(CW\*(C`errstr\*(C'\fR, and \f(CW\*(C`state\*(C'\fR values are not altered and \fIset_err()\fR returns
an empty list (it normally returns \f(CW$rv\fR which defaults to undef, see below).
.PP
Setting \f(CW\*(C`err\*(C'\fR to a \fItrue\fR value indicates an error and will trigger
the normal \s-1DBI\s0 error handling mechanisms, such as \f(CW\*(C`RaiseError\*(C'\fR and
\&\f(CW\*(C`HandleError\*(C'\fR, if they are enabled, when execution returns from
the \s-1DBI\s0 back to the application.
.PP
Setting \f(CW\*(C`err\*(C'\fR to \f(CW""\fR indicates an 'information' state, and setting
it to \f(CW"0"\fR indicates a 'warning' state. Setting \f(CW\*(C`err\*(C'\fR to \f(CW\*(C`undef\*(C'\fR
also sets \f(CW\*(C`errstr\*(C'\fR to undef, and \f(CW\*(C`state\*(C'\fR to \f(CW""\fR, irrespective
of the values of the \f(CW$errstr\fR and \f(CW$state\fR parameters.
.PP
The \f(CW$method\fR parameter provides an alternate method name for the
\&\f(CW\*(C`RaiseError\*(C'\fR/\f(CW\*(C`PrintError\*(C'\fR/\f(CW\*(C`PrintWarn\*(C'\fR error string instead of
the fairly unhelpful '\f(CW\*(C`set_err\*(C'\fR'.
.PP
The \f(CW\*(C`set_err\*(C'\fR method normally returns undef.  The \f(CW$rv\fR parameter
provides an alternate return value.
.PP
Some special rules apply if the \f(CW\*(C`err\*(C'\fR or \f(CW\*(C`errstr\*(C'\fR
values for the handle are \fIalready\fR set...
.PP
If \f(CW\*(C`errstr\*(C'\fR is true then: "\f(CW\*(C` [err was %s now %s]\*(C'\fR" is appended if \f(CW$err\fR is
true and \f(CW\*(C`err\*(C'\fR is already true and the new err value differs from the original
one. Similarly "\f(CW\*(C` [state was %s now %s]\*(C'\fR" is appended if \f(CW$state\fR is true and \f(CW\*(C`state\*(C'\fR is
already true and the new state value differs from the original one. Finally
"\f(CW\*(C`\en\*(C'\fR" and the new \f(CW$errstr\fR are appended if \f(CW$errstr\fR differs from the existing
errstr value. Obviously the \f(CW%s\fR's above are replaced by the corresponding values.
.PP
The handle \f(CW\*(C`err\*(C'\fR value is set to \f(CW$err\fR if: \f(CW$err\fR is true; or handle
\&\f(CW\*(C`err\*(C'\fR value is undef; or \f(CW$err\fR is defined and the length is greater
than the handle \f(CW\*(C`err\*(C'\fR length. The effect is that an 'information'
state only overrides undef; a 'warning' overrides undef or 'information',
and an 'error' state overrides anything.
.PP
The handle \f(CW\*(C`state\*(C'\fR value is set to \f(CW$state\fR if \f(CW$state\fR is true and
the handle \f(CW\*(C`err\*(C'\fR value was set (by the rules above).
.PP
Support for warning and information states was added in \s-1DBI 1.41.\s0
.PP
\fI\f(CI\*(C`trace\*(C'\fI\fR
.IX Subsection "trace"
.PP
.Vb 3
\&  $h\->trace($trace_settings);
\&  $h\->trace($trace_settings, $trace_filename);
\&  $trace_settings = $h\->trace;
.Ve
.PP
The \fItrace()\fR method is used to alter the trace settings for a handle
(and any future children of that handle).  It can also be used to
change where the trace output is sent.
.PP
There's a similar method, \f(CW\*(C`DBI\->trace\*(C'\fR, which sets the global
default trace settings.
.PP
See the \*(L"\s-1TRACING\*(R"\s0 section for full details about the \s-1DBI\s0's powerful
tracing facilities.
.PP
\fI\f(CI\*(C`trace_msg\*(C'\fI\fR
.IX Subsection "trace_msg"
.PP
.Vb 2
\&  $h\->trace_msg($message_text);
\&  $h\->trace_msg($message_text, $min_level);
.Ve
.PP
Writes \f(CW$message_text\fR to the trace file if the trace level is
greater than or equal to \f(CW$min_level\fR (which defaults to 1).
Can also be called as \f(CW\*(C`DBI\->trace_msg($msg)\*(C'\fR.
.PP
See \*(L"\s-1TRACING\*(R"\s0 for more details.
.PP
\fI\f(CI\*(C`func\*(C'\fI\fR
.IX Subsection "func"
.PP
.Vb 1
\&  $h\->func(@func_arguments, $func_name) or die ...;
.Ve
.PP
The \f(CW\*(C`func\*(C'\fR method can be used to call private non-standard and
non-portable methods implemented by the driver. Note that the function
name is given as the \fIlast\fR argument.
.PP
It's also important to note that the \fIfunc()\fR method does not clear
a previous error ($DBI::err etc.) and it does not trigger automatic
error detection (RaiseError etc.) so you must check the return
status and/or \f(CW$h\fR\->err to detect errors.
.PP
(This method is not directly related to calling stored procedures.
Calling stored procedures is currently not defined by the \s-1DBI.\s0
Some drivers, such as DBD::Oracle, support it in non-portable ways.
See driver documentation for more details.)
.PP
See also \fIinstall_method()\fR in \s-1DBI::DBD\s0 for how you can avoid needing to
use \fIfunc()\fR and gain direct access to driver-private methods.
.PP
\fI\f(CI\*(C`can\*(C'\fI\fR
.IX Subsection "can"
.PP
.Vb 1
\&  $is_implemented = $h\->can($method_name);
.Ve
.PP
Returns true if \f(CW$method_name\fR is implemented by the driver or a
default method is provided by the \s-1DBI\s0's driver base class.
It returns false where a driver hasn't implemented a method and the
default method is provided by the \s-1DBI\s0's driver base class is just an empty stub.
.PP
\fI\f(CI\*(C`parse_trace_flags\*(C'\fI\fR
.IX Subsection "parse_trace_flags"
.PP
.Vb 1
\&  $trace_settings_integer = $h\->parse_trace_flags($trace_settings);
.Ve
.PP
Parses a string containing trace settings and returns the corresponding
integer value used internally by the \s-1DBI\s0 and drivers.
.PP
The \f(CW$trace_settings\fR argument is a string containing a trace level
between 0 and 15 and/or trace flag names separated by vertical bar
("\f(CW\*(C`|\*(C'\fR\*(L") or comma (\*(R"\f(CW\*(C`,\*(C'\fR") characters. For example: \f(CW"SQL|3|foo"\fR.
.PP
It uses the \fIparse_trace_flag()\fR method, described below, to process
the individual trace flag names.
.PP
The \fIparse_trace_flags()\fR method was added in \s-1DBI 1.42.\s0
.PP
\fI\f(CI\*(C`parse_trace_flag\*(C'\fI\fR
.IX Subsection "parse_trace_flag"
.PP
.Vb 1
\&  $bit_flag = $h\->parse_trace_flag($trace_flag_name);
.Ve
.PP
Returns the bit flag corresponding to the trace flag name in
\&\f(CW$trace_flag_name\fR.  Drivers are expected to override this method and
check if \f(CW$trace_flag_name\fR is a driver specific trace flags and, if
not, then call the \s-1DBI\s0's default \fIparse_trace_flag()\fR.
.PP
The \fIparse_trace_flag()\fR method was added in \s-1DBI 1.42.\s0
.PP
\fI\f(CI\*(C`private_attribute_info\*(C'\fI\fR
.IX Subsection "private_attribute_info"
.PP
.Vb 1
\&  $hash_ref = $h\->private_attribute_info();
.Ve
.PP
Returns a reference to a hash whose keys are the names of driver-private
handle attributes available for the kind of handle (driver, database, statement)
that the method was called on.
.PP
For example, the return value when called with a DBD::Sybase \f(CW$dbh\fR could look like this:
.PP
.Vb 6
\&  {
\&      syb_dynamic_supported => undef,
\&      syb_oc_version => undef,
\&      syb_server_version => undef,
\&      syb_server_version_string => undef,
\&  }
.Ve
.PP
and when called with a DBD::Sybase \f(CW$sth\fR they could look like this:
.PP
.Vb 5
\&  {
\&      syb_types => undef,
\&      syb_proc_status => undef,
\&      syb_result_type => undef,
\&  }
.Ve
.PP
The values should be undef. Meanings may be assigned to particular values in future.
.PP
\fI\f(CI\*(C`swap_inner_handle\*(C'\fI\fR
.IX Subsection "swap_inner_handle"
.PP
.Vb 2
\&  $rc = $h1\->swap_inner_handle( $h2 );
\&  $rc = $h1\->swap_inner_handle( $h2, $allow_reparent );
.Ve
.PP
Brain transplants for handles. You don't need to know about this
unless you want to become a handle surgeon.
.PP
A \s-1DBI\s0 handle is a reference to a tied hash. A tied hash has an
\&\fIinner\fR hash that actually holds the contents.  The \fIswap_inner_handle()\fR
method swaps the inner hashes between two handles. The \f(CW$h1\fR and \f(CW$h2\fR
handles still point to the same tied hashes, but what those hashes
are tied to has been swapped.  In effect \f(CW$h1\fR \fIbecomes\fR \f(CW$h2\fR and
vice-versa. This is powerful stuff, expect problems. Use with care.
.PP
As a small safety measure, the two handles, \f(CW$h1\fR and \f(CW$h2\fR, have to
share the same parent unless \f(CW$allow_reparent\fR is true.
.PP
The \fIswap_inner_handle()\fR method was added in \s-1DBI 1.44.\s0
.PP
Here's a quick kind of 'diagram' as a worked example to help think about what's
happening:
.PP
.Vb 4
\&    Original state:
\&            dbh1o \-> dbh1i
\&            sthAo \-> sthAi(dbh1i)
\&            dbh2o \-> dbh2i
\&
\&    swap_inner_handle dbh1o with dbh2o:
\&            dbh2o \-> dbh1i
\&            sthAo \-> sthAi(dbh1i)
\&            dbh1o \-> dbh2i
\&
\&    create new sth from dbh1o:
\&            dbh2o \-> dbh1i
\&            sthAo \-> sthAi(dbh1i)
\&            dbh1o \-> dbh2i
\&            sthBo \-> sthBi(dbh2i)
\&
\&    swap_inner_handle sthAo with sthBo:
\&            dbh2o \-> dbh1i
\&            sthBo \-> sthAi(dbh1i)
\&            dbh1o \-> dbh2i
\&            sthAo \-> sthBi(dbh2i)
.Ve
.PP
\fI\f(CI\*(C`visit_child_handles\*(C'\fI\fR
.IX Subsection "visit_child_handles"
.PP
.Vb 2
\&  $h\->visit_child_handles( $coderef );
\&  $h\->visit_child_handles( $coderef, $info );
.Ve
.PP
Where \f(CW$coderef\fR is a reference to a subroutine and \f(CW$info\fR is an arbitrary value
which, if undefined, defaults to a reference to an empty hash. Returns \f(CW$info\fR.
.PP
For each child handle of \f(CW$h\fR, if any, \f(CW$coderef\fR is invoked as:
.PP
.Vb 1
\&  $coderef\->($child_handle, $info);
.Ve
.PP
If the execution of \f(CW$coderef\fR returns a true value then \f(CW\*(C`visit_child_handles\*(C'\fR
is called on that child handle and passed the returned value as \f(CW$info\fR.
.PP
For example:
.PP
.Vb 7
\&  # count database connections with names (DSN) matching a pattern
\&  my $connections = 0;
\&  $dbh\->{Driver}\->visit_child_handles(sub {
\&      my ($h, $info) = @_;
\&      ++$connections if $h\->{Name} =~ /foo/;
\&      return 0; # don\*(Aqt visit kids
\&  })
.Ve
.PP
See also \*(L"visit_handles\*(R".
.SH "ATTRIBUTES COMMON TO ALL HANDLES"
.IX Header "ATTRIBUTES COMMON TO ALL HANDLES"
These attributes are common to all types of \s-1DBI\s0 handles.
.PP
Some attributes are inherited by child handles. That is, the value
of an inherited attribute in a newly created statement handle is the
same as the value in the parent database handle. Changes to attributes
in the new statement handle do not affect the parent database handle
and changes to the database handle do not affect existing statement
handles, only future ones.
.PP
Attempting to set or get the value of an unknown attribute generates a warning,
except for private driver specific attributes (which all have names
starting with a lowercase letter).
.PP
Example:
.PP
.Vb 2
\&  $h\->{AttributeName} = ...;    # set/write
\&  ... = $h\->{AttributeName};    # get/read
.Ve
.PP
\fI\f(CI\*(C`Warn\*(C'\fI\fR
.IX Subsection "Warn"
.PP
Type: boolean, inherited
.PP
The \f(CW\*(C`Warn\*(C'\fR attribute enables useful warnings for certain bad
practices. It is enabled by default and should only be disabled in
rare circumstances.  Since warnings are generated using the Perl
\&\f(CW\*(C`warn\*(C'\fR function, they can be intercepted using the Perl \f(CW$SIG{_\|_WARN_\|_}\fR
hook.
.PP
The \f(CW\*(C`Warn\*(C'\fR attribute is not related to the \f(CW\*(C`PrintWarn\*(C'\fR attribute.
.PP
\fI\f(CI\*(C`Active\*(C'\fI\fR
.IX Subsection "Active"
.PP
Type: boolean, read-only
.PP
The \f(CW\*(C`Active\*(C'\fR attribute is true if the handle object is \*(L"active\*(R". This is rarely used in
applications. The exact meaning of active is somewhat vague at the
moment. For a database handle it typically means that the handle is
connected to a database (\f(CW\*(C`$dbh\->disconnect\*(C'\fR sets \f(CW\*(C`Active\*(C'\fR off).  For
a statement handle it typically means that the handle is a \f(CW\*(C`SELECT\*(C'\fR
that may have more data to fetch. (Fetching all the data or calling \f(CW\*(C`$sth\->finish\*(C'\fR
sets \f(CW\*(C`Active\*(C'\fR off.)
.PP
\fI\f(CI\*(C`Executed\*(C'\fI\fR
.IX Subsection "Executed"
.PP
Type: boolean
.PP
The \f(CW\*(C`Executed\*(C'\fR attribute is true if the handle object has been \*(L"executed\*(R".
Currently only the \f(CW$dbh\fR \fIdo()\fR method and the \f(CW$sth\fR \fIexecute()\fR, \fIexecute_array()\fR,
and \fIexecute_for_fetch()\fR methods set the \f(CW\*(C`Executed\*(C'\fR attribute.
.PP
When it's set on a handle it is also set on the parent handle at the
same time. So calling \fIexecute()\fR on a \f(CW$sth\fR also sets the \f(CW\*(C`Executed\*(C'\fR
attribute on the parent \f(CW$dbh\fR.
.PP
The \f(CW\*(C`Executed\*(C'\fR attribute for a database handle is cleared by the \fIcommit()\fR and
\&\fIrollback()\fR methods (even if they fail). The \f(CW\*(C`Executed\*(C'\fR attribute of a
statement handle is not cleared by the \s-1DBI\s0 under any circumstances and so acts
as a permanent record of whether the statement handle was ever used.
.PP
The \f(CW\*(C`Executed\*(C'\fR attribute was added in \s-1DBI 1.41.\s0
.PP
\fI\f(CI\*(C`Kids\*(C'\fI\fR
.IX Subsection "Kids"
.PP
Type: integer, read-only
.PP
For a driver handle, \f(CW\*(C`Kids\*(C'\fR is the number of currently existing database
handles that were created from that driver handle.  For a database
handle, \f(CW\*(C`Kids\*(C'\fR is the number of currently existing statement handles that
were created from that database handle.
For a statement handle, the value is zero.
.PP
\fI\f(CI\*(C`ActiveKids\*(C'\fI\fR
.IX Subsection "ActiveKids"
.PP
Type: integer, read-only
.PP
Like \f(CW\*(C`Kids\*(C'\fR, but only counting those that are \f(CW\*(C`Active\*(C'\fR (as above).
.PP
\fI\f(CI\*(C`CachedKids\*(C'\fI\fR
.IX Subsection "CachedKids"
.PP
Type: hash ref
.PP
For a database handle, \f(CW\*(C`CachedKids\*(C'\fR returns a reference to the cache (hash) of
statement handles created by the \*(L"prepare_cached\*(R" method.  For a
driver handle, returns a reference to the cache (hash) of
database handles created by the \*(L"connect_cached\*(R" method.
.PP
\fI\f(CI\*(C`Type\*(C'\fI\fR
.IX Subsection "Type"
.PP
Type: scalar, read-only
.PP
The \f(CW\*(C`Type\*(C'\fR attribute identifies the type of a \s-1DBI\s0 handle.  Returns
\&\*(L"dr\*(R" for driver handles, \*(L"db\*(R" for database handles and \*(L"st\*(R" for
statement handles.
.PP
\fI\f(CI\*(C`ChildHandles\*(C'\fI\fR
.IX Subsection "ChildHandles"
.PP
Type: array ref
.PP
The ChildHandles attribute contains a reference to an array of all the
handles created by this handle which are still accessible.  The
contents of the array are weak-refs and will become undef when the
handle goes out of scope.
.PP
\&\f(CW\*(C`ChildHandles\*(C'\fR returns undef if your perl version does not support weak
references (check the Scalar::Util module).  The referenced
array returned should be treated as read-only.
.PP
For example, to enumerate all driver handles, database handles and
statement handles:
.PP
.Vb 6
\&    sub show_child_handles {
\&        my ($h, $level) = @_;
\&        printf "%sh %s %s\en", $h\->{Type}, "\et" x $level, $h;
\&        show_child_handles($_, $level + 1)
\&            for (grep { defined } @{$h\->{ChildHandles}});
\&    }
\&
\&    my %drivers = DBI\->installed_drivers();
\&    show_child_handles($_, 0) for (values %drivers);
.Ve
.PP
\fI\f(CI\*(C`CompatMode\*(C'\fI\fR
.IX Subsection "CompatMode"
.PP
Type: boolean, inherited
.PP
The \f(CW\*(C`CompatMode\*(C'\fR attribute is used by emulation layers (such as
Oraperl) to enable compatible behaviour in the underlying driver
(e.g., DBD::Oracle) for this handle. Not normally set by application code.
.PP
It also has the effect of disabling the 'quick \s-1FETCH\s0' of attribute
values from the handles attribute cache. So all attribute values
are handled by the drivers own \s-1FETCH\s0 method. This makes them slightly
slower but is useful for special-purpose drivers like DBD::Multiplex.
.PP
\fI\f(CI\*(C`InactiveDestroy\*(C'\fI\fR
.IX Subsection "InactiveDestroy"
.PP
Type: boolean
.PP
The default value, false, means a handle will be fully destroyed
as normal when the last reference to it is removed, just as you'd expect.
.PP
If set true then the handle will be treated by the \s-1DESTROY\s0 as if it was no
longer Active, and so the \fIdatabase engine\fR related effects of DESTROYing a
handle will be skipped.  Think of the name as meaning 'treat the handle as
not-Active in the \s-1DESTROY\s0 method'.
.PP
For a database handle, this attribute does not disable an \fIexplicit\fR
call to the disconnect method, only the implicit call from \s-1DESTROY\s0
that happens if the handle is still marked as \f(CW\*(C`Active\*(C'\fR.
.PP
This attribute is specifically designed for use in Unix applications
that \*(L"fork\*(R" child processes.  For some drivers, when the child process exits
the destruction of inherited handles cause the corresponding handles in the
parent process to cease working.
.PP
Either the parent or the child process, but not both, should set
\&\f(CW\*(C`InactiveDestroy\*(C'\fR true on all their shared handles. Alternatively the
\&\*(L"AutoInactiveDestroy\*(R" can be set in the parent on connect.
.PP
To help tracing applications using fork the process id is shown in
the trace log whenever a \s-1DBI\s0 or handle \fItrace()\fR method is called.
The process id also shown for \fIevery\fR method call if the \s-1DBI\s0 trace
level (not handle trace level) is set high enough to show the trace
from the \s-1DBI\s0's method dispatcher, e.g. >= 9.
.PP
\fI\f(CI\*(C`AutoInactiveDestroy\*(C'\fI\fR
.IX Subsection "AutoInactiveDestroy"
.PP
Type: boolean, inherited
.PP
The \*(L"InactiveDestroy\*(R" attribute, described above, needs to be explicitly set
in the child process after a \fIfork()\fR. This is a problem if the code that performs
the \fIfork()\fR is not under your control, perhaps in a third-party module.
Use \f(CW\*(C`AutoInactiveDestroy\*(C'\fR to get around this situation.
.PP
If set true, the \s-1DESTROY\s0 method will check the process id of the handle and, if
different from the current process id, it will set the \fIInactiveDestroy\fR attribute.
.PP
This is the example it's designed to deal with:
.PP
.Vb 4
\&    my $dbh = DBI\->connect(...);
\&    some_code_that_forks(); # Perhaps without your knowledge
\&    # Child process dies, destroying the inherited dbh
\&    $dbh\->do(...); # Breaks because parent $dbh is now broken
.Ve
.PP
The \f(CW\*(C`AutoInactiveDestroy\*(C'\fR attribute was added in \s-1DBI 1.614.\s0
.PP
\fI\f(CI\*(C`PrintWarn\*(C'\fI\fR
.IX Subsection "PrintWarn"
.PP
Type: boolean, inherited
.PP
The \f(CW\*(C`PrintWarn\*(C'\fR attribute controls the printing of warnings recorded
by the driver.  When set to a true value (the default) the \s-1DBI\s0 will check method
calls to see if a warning condition has been set. If so, the \s-1DBI\s0
will effectively do a \f(CW\*(C`warn("$class $method warning: $DBI::errstr")\*(C'\fR
where \f(CW$class\fR is the driver class and \f(CW$method\fR is the name of
the method which failed. E.g.,
.PP
.Vb 1
\&  DBD::Oracle::db execute warning: ... warning text here ...
.Ve
.PP
If desired, the warnings can be caught and processed using a \f(CW$SIG{_\|_WARN_\|_}\fR
handler or modules like CGI::Carp and CGI::ErrorWrap.
.PP
See also \*(L"set_err\*(R" for how warnings are recorded and \*(L"HandleSetErr\*(R"
for how to influence it.
.PP
Fetching the full details of warnings can require an extra round-trip
to the database server for some drivers. In which case the driver
may opt to only fetch the full details of warnings if the \f(CW\*(C`PrintWarn\*(C'\fR
attribute is true. If \f(CW\*(C`PrintWarn\*(C'\fR is false then these drivers should
still indicate the fact that there were warnings by setting the
warning string to, for example: \*(L"3 warnings\*(R".
.PP
\fI\f(CI\*(C`PrintError\*(C'\fI\fR
.IX Subsection "PrintError"
.PP
Type: boolean, inherited
.PP
The \f(CW\*(C`PrintError\*(C'\fR attribute can be used to force errors to generate warnings (using
\&\f(CW\*(C`warn\*(C'\fR) in addition to returning error codes in the normal way.  When set
\&\*(L"on\*(R", any method which results in an error occurring will cause the \s-1DBI\s0 to
effectively do a \f(CW\*(C`warn("$class $method failed: $DBI::errstr")\*(C'\fR where \f(CW$class\fR
is the driver class and \f(CW$method\fR is the name of the method which failed. E.g.,
.PP
.Vb 1
\&  DBD::Oracle::db prepare failed: ... error text here ...
.Ve
.PP
By default, \f(CW\*(C`DBI\->connect\*(C'\fR sets \f(CW\*(C`PrintError\*(C'\fR \*(L"on\*(R".
.PP
If desired, the warnings can be caught and processed using a \f(CW$SIG{_\|_WARN_\|_}\fR
handler or modules like CGI::Carp and CGI::ErrorWrap.
.PP
\fI\f(CI\*(C`RaiseError\*(C'\fI\fR
.IX Subsection "RaiseError"
.PP
Type: boolean, inherited
.PP
The \f(CW\*(C`RaiseError\*(C'\fR attribute can be used to force errors to raise exceptions rather
than simply return error codes in the normal way. It is \*(L"off\*(R" by default.
When set \*(L"on\*(R", any method which results in an error will cause
the \s-1DBI\s0 to effectively do a \f(CW\*(C`die("$class $method failed: $DBI::errstr")\*(C'\fR,
where \f(CW$class\fR is the driver class and \f(CW$method\fR is the name of the method
that failed. E.g.,
.PP
.Vb 1
\&  DBD::Oracle::db prepare failed: ... error text here ...
.Ve
.PP
If you turn \f(CW\*(C`RaiseError\*(C'\fR on then you'd normally turn \f(CW\*(C`PrintError\*(C'\fR off.
If \f(CW\*(C`PrintError\*(C'\fR is also on, then the \f(CW\*(C`PrintError\*(C'\fR is done first (naturally).
.PP
Typically \f(CW\*(C`RaiseError\*(C'\fR is used in conjunction with \f(CW\*(C`eval { ... }\*(C'\fR
to catch the exception that's been thrown and followed by an
\&\f(CW\*(C`if ($@) { ... }\*(C'\fR block to handle the caught exception.
For example:
.PP
.Vb 10
\&  eval {
\&    ...
\&    $sth\->execute();
\&    ...
\&  };
\&  if ($@) {
\&    # $sth\->err and $DBI::err will be true if error was from DBI
\&    warn $@; # print the error
\&    ... # do whatever you need to deal with the error
\&  }
.Ve
.PP
In that eval block the \f(CW$DBI::lasth\fR variable can be useful for
diagnosis and reporting if you can't be sure which handle triggered
the error.  For example, \f(CW$DBI::lasth\fR\->{Type} and \f(CW$DBI::lasth\fR\->{Statement}.
.PP
See also \*(L"Transactions\*(R".
.PP
If you want to temporarily turn \f(CW\*(C`RaiseError\*(C'\fR off (inside a library function
that is likely to fail, for example), the recommended way is like this:
.PP
.Vb 4
\&  {
\&    local $h\->{RaiseError};  # localize and turn off for this block
\&    ...
\&  }
.Ve
.PP
The original value will automatically and reliably be restored by Perl,
regardless of how the block is exited.
The same logic applies to other attributes, including \f(CW\*(C`PrintError\*(C'\fR.
.PP
\fI\f(CI\*(C`HandleError\*(C'\fI\fR
.IX Subsection "HandleError"
.PP
Type: code ref, inherited
.PP
The \f(CW\*(C`HandleError\*(C'\fR attribute can be used to provide your own alternative behaviour
in case of errors. If set to a reference to a subroutine then that
subroutine is called when an error is detected (at the same point that
\&\f(CW\*(C`RaiseError\*(C'\fR and \f(CW\*(C`PrintError\*(C'\fR are handled).
.PP
The subroutine is called with three parameters: the error message
string that \f(CW\*(C`RaiseError\*(C'\fR and \f(CW\*(C`PrintError\*(C'\fR would use,
the \s-1DBI\s0 handle being used, and the first value being returned by
the method that failed (typically undef).
.PP
If the subroutine returns a false value then the \f(CW\*(C`RaiseError\*(C'\fR
and/or \f(CW\*(C`PrintError\*(C'\fR attributes are checked and acted upon as normal.
.PP
For example, to \f(CW\*(C`die\*(C'\fR with a full stack trace for any error:
.PP
.Vb 2
\&  use Carp;
\&  $h\->{HandleError} = sub { confess(shift) };
.Ve
.PP
Or to turn errors into exceptions:
.PP
.Vb 2
\&  use Exception; # or your own favourite exception module
\&  $h\->{HandleError} = sub { Exception\->new(\*(AqDBI\*(Aq)\->raise($_[0]) };
.Ve
.PP
It is possible to 'stack' multiple HandleError handlers by using
closures:
.PP
.Vb 7
\&  sub your_subroutine {
\&    my $previous_handler = $h\->{HandleError};
\&    $h\->{HandleError} = sub {
\&      return 1 if $previous_handler and &$previous_handler(@_);
\&      ... your code here ...
\&    };
\&  }
.Ve
.PP
Using a \f(CW\*(C`my\*(C'\fR inside a subroutine to store the previous \f(CW\*(C`HandleError\*(C'\fR
value is important.  See perlsub and perlref for more information
about \fIclosures\fR.
.PP
It is possible for \f(CW\*(C`HandleError\*(C'\fR to alter the error message that
will be used by \f(CW\*(C`RaiseError\*(C'\fR and \f(CW\*(C`PrintError\*(C'\fR if it returns false.
It can do that by altering the value of \f(CW$_\fR[0]. This example appends
a stack trace to all errors and, unlike the previous example using
Carp::confess, this will work \f(CW\*(C`PrintError\*(C'\fR as well as \f(CW\*(C`RaiseError\*(C'\fR:
.PP
.Vb 1
\&  $h\->{HandleError} = sub { $_[0]=Carp::longmess($_[0]); 0; };
.Ve
.PP
It is also possible for \f(CW\*(C`HandleError\*(C'\fR to hide an error, to a limited
degree, by using \*(L"set_err\*(R" to reset \f(CW$DBI::err\fR and \f(CW$DBI::errstr\fR,
and altering the return value of the failed method. For example:
.PP
.Vb 7
\&  $h\->{HandleError} = sub {
\&    return 0 unless $_[0] =~ /^\eS+ fetchrow_arrayref failed:/;
\&    return 0 unless $_[1]\->err == 1234; # the error to \*(Aqhide\*(Aq
\&    $h\->set_err(undef,undef);   # turn off the error
\&    $_[2] = [ ... ];    # supply alternative return value
\&    return 1;
\&  };
.Ve
.PP
This only works for methods which return a single value and is hard
to make reliable (avoiding infinite loops, for example) and so isn't
recommended for general use!  If you find a \fIgood\fR use for it then
please let me know.
.PP
\fI\f(CI\*(C`HandleSetErr\*(C'\fI\fR
.IX Subsection "HandleSetErr"
.PP
Type: code ref, inherited
.PP
The \f(CW\*(C`HandleSetErr\*(C'\fR attribute can be used to intercept
the setting of handle \f(CW\*(C`err\*(C'\fR, \f(CW\*(C`errstr\*(C'\fR, and \f(CW\*(C`state\*(C'\fR values.
If set to a reference to a subroutine then that subroutine is called
whenever \fIset_err()\fR is called, typically by the driver or a subclass.
.PP
The subroutine is called with five arguments, the first five that
were passed to \fIset_err()\fR: the handle, the \f(CW\*(C`err\*(C'\fR, \f(CW\*(C`errstr\*(C'\fR, and
\&\f(CW\*(C`state\*(C'\fR values being set, and the method name. These can be altered
by changing the values in the \f(CW@_\fR array. The return value affects
\&\fIset_err()\fR behaviour, see \*(L"set_err\*(R" for details.
.PP
It is possible to 'stack' multiple HandleSetErr handlers by using
closures. See \*(L"HandleError\*(R" for an example.
.PP
The \f(CW\*(C`HandleSetErr\*(C'\fR and \f(CW\*(C`HandleError\*(C'\fR subroutines differ in subtle
but significant ways. HandleError is only invoked at the point where
the \s-1DBI\s0 is about to return to the application with \f(CW\*(C`err\*(C'\fR set true.
It's not invoked by the failure of a method that's been called by
another \s-1DBI\s0 method.  HandleSetErr, on the other hand, is called
whenever \fIset_err()\fR is called with a defined \f(CW\*(C`err\*(C'\fR value, even if false.
So it's not just for errors, despite the name, but also warn and info states.
The \fIset_err()\fR method, and thus HandleSetErr, may be called multiple
times within a method and is usually invoked from deep within driver code.
.PP
In theory a driver can use the return value from HandleSetErr via
\&\fIset_err()\fR to decide whether to continue or not. If \fIset_err()\fR returns
an empty list, indicating that the HandleSetErr code has 'handled'
the 'error', the driver could then continue instead of failing (if
that's a reasonable thing to do).  This isn't excepted to be
common and any such cases should be clearly marked in the driver
documentation and discussed on the dbi-dev mailing list.
.PP
The \f(CW\*(C`HandleSetErr\*(C'\fR attribute was added in \s-1DBI 1.41.\s0
.PP
\fI\f(CI\*(C`ErrCount\*(C'\fI\fR
.IX Subsection "ErrCount"
.PP
Type: unsigned integer
.PP
The \f(CW\*(C`ErrCount\*(C'\fR attribute is incremented whenever the \fIset_err()\fR
method records an error. It isn't incremented by warnings or
information states. It is not reset by the \s-1DBI\s0 at any time.
.PP
The \f(CW\*(C`ErrCount\*(C'\fR attribute was added in \s-1DBI 1.41.\s0 Older drivers may
not have been updated to use \fIset_err()\fR to record errors and so this
attribute may not be incremented when using them.
.PP
\fI\f(CI\*(C`ShowErrorStatement\*(C'\fI\fR
.IX Subsection "ShowErrorStatement"
.PP
Type: boolean, inherited
.PP
The \f(CW\*(C`ShowErrorStatement\*(C'\fR attribute can be used to cause the relevant
Statement text to be appended to the error messages generated by
the \f(CW\*(C`RaiseError\*(C'\fR, \f(CW\*(C`PrintError\*(C'\fR, and \f(CW\*(C`PrintWarn\*(C'\fR attributes.
Only applies to errors on statement handles
plus the \fIprepare()\fR, \fIdo()\fR, and the various \f(CW\*(C`select*()\*(C'\fR database handle methods.
(The exact format of the appended text is subject to change.)
.PP
If \f(CW\*(C`$h\->{ParamValues}\*(C'\fR returns a hash reference of parameter
(placeholder) values then those are formatted and appended to the
end of the Statement text in the error message.
.PP
\fI\f(CI\*(C`TraceLevel\*(C'\fI\fR
.IX Subsection "TraceLevel"
.PP
Type: integer, inherited
.PP
The \f(CW\*(C`TraceLevel\*(C'\fR attribute can be used as an alternative to the
\&\*(L"trace\*(R" method to set the \s-1DBI\s0 trace level and trace flags for a
specific handle.  See \*(L"\s-1TRACING\*(R"\s0 for more details.
.PP
The \f(CW\*(C`TraceLevel\*(C'\fR attribute is especially useful combined with
\&\f(CW\*(C`local\*(C'\fR to alter the trace settings for just a single block of code.
.PP
\fI\f(CI\*(C`FetchHashKeyName\*(C'\fI\fR
.IX Subsection "FetchHashKeyName"
.PP
Type: string, inherited
.PP
The \f(CW\*(C`FetchHashKeyName\*(C'\fR attribute is used to specify whether the \fIfetchrow_hashref()\fR
method should perform case conversion on the field names used for
the hash keys. For historical reasons it defaults to '\f(CW\*(C`NAME\*(C'\fR' but
it is recommended to set it to '\f(CW\*(C`NAME_lc\*(C'\fR' (convert to lower case)
or '\f(CW\*(C`NAME_uc\*(C'\fR' (convert to upper case) according to your preference.
It can only be set for driver and database handles.  For statement
handles the value is frozen when \fIprepare()\fR is called.
.PP
\fI\f(CI\*(C`ChopBlanks\*(C'\fI\fR
.IX Subsection "ChopBlanks"
.PP
Type: boolean, inherited
.PP
The \f(CW\*(C`ChopBlanks\*(C'\fR attribute can be used to control the trimming of trailing space
characters from fixed width character (\s-1CHAR\s0) fields. No other field
types are affected, even where field values have trailing spaces.
.PP
The default is false (although it is possible that the default may change).
Applications that need specific behaviour should set the attribute as
needed.
.PP
Drivers are not required to support this attribute, but any driver which
does not support it must arrange to return \f(CW\*(C`undef\*(C'\fR as the attribute value.
.PP
\fI\f(CI\*(C`LongReadLen\*(C'\fI\fR
.IX Subsection "LongReadLen"
.PP
Type: unsigned integer, inherited
.PP
The \f(CW\*(C`LongReadLen\*(C'\fR attribute may be used to control the maximum
length of 'long' type fields (\s-1LONG, BLOB, CLOB, MEMO,\s0 etc.) which the driver will
read from the database automatically when it fetches each row of data.
.PP
The \f(CW\*(C`LongReadLen\*(C'\fR attribute only relates to fetching and reading
long values; it is not involved in inserting or updating them.
.PP
A value of 0 means not to automatically fetch any long data.
Drivers may return undef or an empty string for long fields when
\&\f(CW\*(C`LongReadLen\*(C'\fR is 0.
.PP
The default is typically 0 (zero) or 80 bytes but may vary between drivers.
Applications fetching long fields should set this value to slightly
larger than the longest long field value to be fetched.
.PP
Some databases return some long types encoded as pairs of hex digits.
For these types, \f(CW\*(C`LongReadLen\*(C'\fR relates to the underlying data
length and not the doubled-up length of the encoded string.
.PP
Changing the value of \f(CW\*(C`LongReadLen\*(C'\fR for a statement handle after it
has been \f(CW\*(C`prepare\*(C'\fR'd will typically have no effect, so it's common to
set \f(CW\*(C`LongReadLen\*(C'\fR on the \f(CW$dbh\fR before calling \f(CW\*(C`prepare\*(C'\fR.
.PP
For most drivers the value used here has a direct effect on the
memory used by the statement handle while it's active, so don't be
too generous. If you can't be sure what value to use you could
execute an extra select statement to determine the longest value.
For example:
.PP
.Vb 7
\&  $dbh\->{LongReadLen} = $dbh\->selectrow_array(qq{
\&      SELECT MAX(OCTET_LENGTH(long_column_name))
\&      FROM table WHERE ...
\&  });
\&  $sth = $dbh\->prepare(qq{
\&      SELECT long_column_name, ... FROM table WHERE ...
\&  });
.Ve
.PP
You may need to take extra care if the table can be modified between
the first select and the second being executed. You may also need to
use a different function if \s-1\fIOCTET_LENGTH\s0()\fR does not work for long
types in your database. For example, for Sybase use \s-1\fIDATALENGTH\s0()\fR and
for Oracle use \s-1\fILENGTHB\s0()\fR.
.PP
See also \*(L"LongTruncOk\*(R" for information on truncation of long types.
.PP
\fI\f(CI\*(C`LongTruncOk\*(C'\fI\fR
.IX Subsection "LongTruncOk"
.PP
Type: boolean, inherited
.PP
The \f(CW\*(C`LongTruncOk\*(C'\fR attribute may be used to control the effect of
fetching a long field value which has been truncated (typically
because it's longer than the value of the \f(CW\*(C`LongReadLen\*(C'\fR attribute).
.PP
By default, \f(CW\*(C`LongTruncOk\*(C'\fR is false and so fetching a long value that
needs to be truncated will cause the fetch to fail.
(Applications should always be sure to
check for errors after a fetch loop in case an error, such as a divide
by zero or long field truncation, caused the fetch to terminate
prematurely.)
.PP
If a fetch fails due to a long field truncation when \f(CW\*(C`LongTruncOk\*(C'\fR is
false, many drivers will allow you to continue fetching further rows.
.PP
See also \*(L"LongReadLen\*(R".
.PP
\fI\f(CI\*(C`TaintIn\*(C'\fI\fR
.IX Subsection "TaintIn"
.PP
Type: boolean, inherited
.PP
If the \f(CW\*(C`TaintIn\*(C'\fR attribute is set to a true value \fIand\fR Perl is running in
taint mode (e.g., started with the \f(CW\*(C`\-T\*(C'\fR option), then all the arguments
to most \s-1DBI\s0 method calls are checked for being tainted. \fIThis may change.\fR
.PP
The attribute defaults to off, even if Perl is in taint mode.
See perlsec for more about taint mode.  If Perl is not
running in taint mode, this attribute has no effect.
.PP
When fetching data that you trust you can turn off the TaintIn attribute,
for that statement handle, for the duration of the fetch loop.
.PP
The \f(CW\*(C`TaintIn\*(C'\fR attribute was added in \s-1DBI 1.31.\s0
.PP
\fI\f(CI\*(C`TaintOut\*(C'\fI\fR
.IX Subsection "TaintOut"
.PP
Type: boolean, inherited
.PP
If the \f(CW\*(C`TaintOut\*(C'\fR attribute is set to a true value \fIand\fR Perl is running in
taint mode (e.g., started with the \f(CW\*(C`\-T\*(C'\fR option), then most data fetched
from the database is considered tainted. \fIThis may change.\fR
.PP
The attribute defaults to off, even if Perl is in taint mode.
See perlsec for more about taint mode.  If Perl is not
running in taint mode, this attribute has no effect.
.PP
When fetching data that you trust you can turn off the TaintOut attribute,
for that statement handle, for the duration of the fetch loop.
.PP
Currently only fetched data is tainted. It is possible that the results
of other \s-1DBI\s0 method calls, and the value of fetched attributes, may
also be tainted in future versions. That change may well break your
applications unless you take great care now. If you use \s-1DBI\s0 Taint mode,
please report your experience and any suggestions for changes.
.PP
The \f(CW\*(C`TaintOut\*(C'\fR attribute was added in \s-1DBI 1.31.\s0
.PP
\fI\f(CI\*(C`Taint\*(C'\fI\fR
.IX Subsection "Taint"
.PP
Type: boolean, inherited
.PP
The \f(CW\*(C`Taint\*(C'\fR attribute is a shortcut for \*(L"TaintIn\*(R" and \*(L"TaintOut\*(R" (it is also present
for backwards compatibility).
.PP
Setting this attribute sets both \*(L"TaintIn\*(R" and \*(L"TaintOut\*(R", and retrieving
it returns a true value if and only if \*(L"TaintIn\*(R" and \*(L"TaintOut\*(R" are
both set to true values.
.PP
\fI\f(CI\*(C`Profile\*(C'\fI\fR
.IX Subsection "Profile"
.PP
Type: inherited
.PP
The \f(CW\*(C`Profile\*(C'\fR attribute enables the collection and reporting of
method call timing statistics.  See the DBI::Profile module
documentation for \fImuch\fR more detail.
.PP
The \f(CW\*(C`Profile\*(C'\fR attribute was added in \s-1DBI 1.24.\s0
.PP
\fI\f(CI\*(C`ReadOnly\*(C'\fI\fR
.IX Subsection "ReadOnly"
.PP
Type: boolean, inherited
.PP
An application can set the \f(CW\*(C`ReadOnly\*(C'\fR attribute of a handle to a true value to
indicate that it will not be attempting to make any changes using that handle
or any children of it.
.PP
Note that the exact definition of 'read only' is rather fuzzy.
For more details see the documentation for the driver you're using.
.PP
If the driver can make the handle truly read-only then it should
(unless doing so would have unpleasant side effect, like changing the
consistency level from per-statement to per-session).
Otherwise the attribute is simply advisory.
.PP
A driver can set the \f(CW\*(C`ReadOnly\*(C'\fR attribute itself to indicate that the data it
is connected to cannot be changed for some reason.
.PP
If the driver cannot ensure the \f(CW\*(C`ReadOnly\*(C'\fR attribute is adhered to it
will record a warning.  In this case reading the \f(CW\*(C`ReadOnly\*(C'\fR attribute
back after it is set true will return true even if the underlying
driver cannot ensure this (so any application knows the application
declared itself ReadOnly).
.PP
Library modules and proxy drivers can use the attribute to influence
their behavior.  For example, the DBD::Gofer driver considers the
\&\f(CW\*(C`ReadOnly\*(C'\fR attribute when making a decision about whether to retry an
operation that failed.
.PP
The attribute should be set to 1 or 0 (or undef). Other values are reserved.
.PP
\fI\f(CI\*(C`Callbacks\*(C'\fI\fR
.IX Subsection "Callbacks"
.PP
Type: hash ref
.PP
The \s-1DBI\s0 callback mechanism lets you intercept, and optionally replace, any
method call on a \s-1DBI\s0 handle. At the extreme, it lets you become a puppet
master, deceiving the application in any way you want.
.PP
The \f(CW\*(C`Callbacks\*(C'\fR attribute is a hash reference where the keys are \s-1DBI\s0 method
names and the values are code references. For each key naming a method, the
\&\s-1DBI\s0 will execute the associated code reference before executing the method.
.PP
The arguments to the code reference will be the same as to the method,
including the invocant (a database handle or statement handle). For example,
say that to callback to some code on a call to \f(CW\*(C`prepare()\*(C'\fR:
.PP
.Vb 6
\&  $dbh\->{Callbacks} = {
\&      prepare => sub {
\&          my ($dbh, $query, $attrs) = @_;
\&          print "Preparing q{$query}\en"
\&      },
\&  };
.Ve
.PP
The callback would then be executed when you called the \f(CW\*(C`prepare()\*(C'\fR method:
.PP
.Vb 1
\&  $dbh\->prepare(\*(AqSELECT 1\*(Aq);
.Ve
.PP
And the output of course would be:
.PP
.Vb 1
\&  Preparing q{SELECT 1}
.Ve
.PP
Because callbacks are executed \fIbefore\fR the methods
they're associated with, you can modify the arguments before they're passed on
to the method call. For example, to make sure that all calls to \f(CW\*(C`prepare()\*(C'\fR
are immediately prepared by DBD::Pg, add a callback that makes sure that
the \f(CW\*(C`pg_prepare_now\*(C'\fR attribute is always set:
.PP
.Vb 9
\&  my $dbh = DBI\->connect($dsn, $username, $auth, {
\&      Callbacks => {
\&          prepare => sub {
\&              $_[2] ||= {};
\&              $_[2]\->{pg_prepare_now} = 1;
\&              return; # must return nothing
\&          },
\&      }
\&  });
.Ve
.PP
Note that we are editing the contents of \f(CW@_\fR directly. In this case we've
created the attributes hash if it's not passed to the \f(CW\*(C`prepare\*(C'\fR call.
.PP
You can also prevent the associated method from ever executing. While a
callback executes, \f(CW$_\fR holds the method name. (This allows multiple callbacks
to share the same code reference and still know what method was called.)
To prevent the method from
executing, simply \f(CW\*(C`undef $_\*(C'\fR. For example, if you wanted to disable calls to
\&\f(CW\*(C`ping()\*(C'\fR, you could do this:
.PP
.Vb 8
\&  $dbh\->{Callbacks} = {
\&      ping => sub {
\&          # tell dispatch to not call the method:
\&          undef $_;
\&          # return this value instead:
\&          return "42 bells";
\&      }
\&  };
.Ve
.PP
As with other attributes, Callbacks can be specified on a handle or via the
attributes to \f(CW\*(C`connect()\*(C'\fR. Callbacks can also be applied to a statement
methods on a statement handle. For example:
.PP
.Vb 5
\&  $sth\->{Callbacks} = {
\&      execute => sub {
\&          print "Executing ", shift\->{Statement}, "\en";
\&      }
\&  };
.Ve
.PP
The \f(CW\*(C`Callbacks\*(C'\fR attribute of a database handle isn't copied to any statement
handles it creates. So setting callbacks for a statement handle requires you to
set the \f(CW\*(C`Callbacks\*(C'\fR attribute on the statement handle yourself, as in the
example above, or use the special \f(CW\*(C`ChildCallbacks\*(C'\fR key described below.
.PP
\&\fBSpecial Keys in Callbacks Attribute\fR
.PP
In addition to \s-1DBI\s0 handle method names, the \f(CW\*(C`Callbacks\*(C'\fR hash reference
supports four additional keys.
.PP
The first is the \f(CW\*(C`ChildCallbacks\*(C'\fR key. When a statement handle is created from
a database handle the \f(CW\*(C`ChildCallbacks\*(C'\fR key of the database handle's
\&\f(CW\*(C`Callbacks\*(C'\fR attribute, if any, becomes the new \f(CW\*(C`Callbacks\*(C'\fR attribute of the
statement handle.
This allows you to define callbacks for all statement handles created from a
database handle. For example, if you wanted to count how many times \f(CW\*(C`execute\*(C'\fR
was called in your application, you could write:
.PP
.Vb 8
\&  my $exec_count = 0;
\&  my $dbh = DBI\->connect( $dsn, $username, $auth, {
\&      Callbacks => {
\&          ChildCallbacks => {
\&              execute => sub { $exec_count++; return; }
\&          }
\&      }
\&  });
\&
\&  END {
\&      print "The execute method was called $exec_count times\en";
\&  }
.Ve
.PP
The other three special keys are \f(CW\*(C`connect_cached.new\*(C'\fR,
\&\f(CW\*(C`connect_cached.connected\*(C'\fR, and \f(CW\*(C`connect_cached.reused\*(C'\fR. These keys define
callbacks that are called when \f(CW\*(C`connect_cached()\*(C'\fR is called, but allow
different behaviors depending on whether a new handle is created or a handle
is returned. The callback is invoked with these arguments:
\&\f(CW\*(C`$dbh, $dsn, $user, $auth, $attr\*(C'\fR.
.PP
For example, some applications uses \f(CW\*(C`connect_cached()\*(C'\fR to connect with
\&\f(CW\*(C`AutoCommit\*(C'\fR enabled and then disable \f(CW\*(C`AutoCommit\*(C'\fR temporarily for
transactions. If \f(CW\*(C`connect_cached()\*(C'\fR is called during a transaction, perhaps in
a utility method, then it might select the same cached handle and then force
\&\f(CW\*(C`AutoCommit\*(C'\fR on, forcing a commit of the transaction. See the \*(L"connect_cached\*(R"
documentation for one way to deal with that. Here we'll describe an alternative
approach using a callback.
.PP
Because the \f(CW\*(C`connect_cached.new\*(C'\fR and \f(CW\*(C`connect_cached.reused\*(C'\fR callbacks are
invoked before \f(CW\*(C`connect_cached()\*(C'\fR has applied the connect attributes, you can
use them to edit the attributes that will be applied. To prevent a cached
handle from having its transactions committed before it's returned, you can
eliminate the \f(CW\*(C`AutoCommit\*(C'\fR attribute in a \f(CW\*(C`connect_cached.reused\*(C'\fR callback,
like so:
.PP
.Vb 3
\&  my $cb = {
\&      \*(Aqconnect_cached.reused\*(Aq => sub { delete $_[4]\->{AutoCommit} },
\&  };
\&
\&  sub dbh {
\&      my $self = shift;
\&      DBI\->connect_cached( $dsn, $username, $auth, {
\&          PrintError => 0,
\&          RaiseError => 1,
\&          AutoCommit => 1,
\&          Callbacks  => $cb,
\&      });
\&  }
.Ve
.PP
The upshot is that new database handles are created with \f(CW\*(C`AutoCommit\*(C'\fR
enabled, while cached database handles are left in whatever transaction state
they happened to be in when retrieved from the cache.
.PP
Note that we've also used a lexical for the callbacks hash reference. This is
because \f(CW\*(C`connect_cached()\*(C'\fR returns a new database handle if any of the
attributes passed to is have changed. If we used an inline hash reference,
\&\f(CW\*(C`connect_cached()\*(C'\fR would return a new database handle every time. Which would
rather defeat the purpose.
.PP
A more common application for callbacks is setting connection state only when
a new connection is made (by \fIconnect()\fR or \fIconnect_cached()\fR). Adding a callback
to the connected method (when using \f(CW\*(C`connect\*(C'\fR) or via
\&\f(CW\*(C`connect_cached.connected\*(C'\fR (when useing \fIconnect_cached()\fR>) makes this easy.
The \fIconnected()\fR method is a no-op by default (unless you subclass the \s-1DBI\s0 and
change it). The \s-1DBI\s0 calls it to indicate that a new connection has been made
and the connection attributes have all been set. You can give it a bit of
added functionality by applying a callback to it. For example, to make sure
that MySQL understands your application's ANSI-compliant \s-1SQL,\s0 set it up like
so:
.PP
.Vb 10
\&  my $dbh = DBI\->connect($dsn, $username, $auth, {
\&      Callbacks => {
\&          connected => sub {
\&              shift\->do(q{
\&                  SET SESSION sql_mode=\*(Aqansi,strict_trans_tables,no_auto_value_on_zero\*(Aq;
\&              });
\&              return;
\&          },
\&      }
\&  });
.Ve
.PP
If you're using \f(CW\*(C`connect_cached()\*(C'\fR, use the \f(CW\*(C`connect_cached.connected\*(C'\fR
callback, instead. This is because \f(CW\*(C`connected()\*(C'\fR is called for both new and
reused database handles, but you want to execute a callback only the when a
new database handle is returned. For example, to set the time zone on
connection to a PostgreSQL database, try this:
.PP
.Vb 5
\&  my $cb = {
\&      \*(Aqconnect_cached.connected\*(Aq => sub {
\&          shift\->do(\*(AqSET timezone = UTC\*(Aq);
\&      }
\&  };
\&
\&  sub dbh {
\&      my $self = shift;
\&      DBI\->connect_cached( $dsn, $username, $auth, { Callbacks => $cb });
\&  }
.Ve
.PP
One significant limitation with callbacks is that there can only be one per
method per handle. This means it's easy for one use of callbacks to interfere
with, or typically simply overwrite, another use of callbacks. For this reason
modules using callbacks should document the fact clearly so application authors
can tell if use of callbacks by the module will clash with use of callbacks by
the application.
.PP
You might be able to work around this issue by taking a copy of the original
callback and calling it within your own. For example:
.PP
.Vb 8
\&  my $prev_cb = $h\->{Callbacks}{method_name};
\&  $h\->{Callbacks}{method_name} = sub {
\&    if ($prev_cb) {
\&        my @result = $prev_cb\->(@_);
\&        return @result if not $_; # $prev_cb vetoed call
\&    }
\&    ... your callback logic here ...
\&  };
.Ve
.PP
\fI\f(CI\*(C`private_your_module_name_*\*(C'\fI\fR
.IX Subsection "private_your_module_name_*"
.PP
The \s-1DBI\s0 provides a way to store extra information in a \s-1DBI\s0 handle as
\&\*(L"private\*(R" attributes. The \s-1DBI\s0 will allow you to store and retrieve any
attribute which has a name starting with "\f(CW\*(C`private_\*(C'\fR".
.PP
It is \fIstrongly\fR recommended that you use just \fIone\fR private
attribute (e.g., use a hash ref) \fIand\fR give it a long and unambiguous
name that includes the module or application name that the attribute
relates to (e.g., "\f(CW\*(C`private_YourFullModuleName_thingy\*(C'\fR").
.PP
Because of the way the Perl tie mechanism works you cannot reliably
use the \f(CW\*(C`||=\*(C'\fR operator directly to initialise the attribute, like this:
.PP
.Vb 1
\&  my $foo = $dbh\->{private_yourmodname_foo} ||= { ... }; # WRONG
.Ve
.PP
you should use a two step approach like this:
.PP
.Vb 2
\&  my $foo = $dbh\->{private_yourmodname_foo};
\&  $foo ||= $dbh\->{private_yourmodname_foo} = { ... };
.Ve
.PP
This attribute is primarily of interest to people sub-classing \s-1DBI,\s0
or for applications to piggy-back extra information onto \s-1DBI\s0 handles.
.SH "DBI DATABASE HANDLE OBJECTS"
.IX Header "DBI DATABASE HANDLE OBJECTS"
This section covers the methods and attributes associated with
database handles.
.SS "Database Handle Methods"
.IX Subsection "Database Handle Methods"
The following methods are specified for \s-1DBI\s0 database handles:
.PP
\fI\f(CI\*(C`clone\*(C'\fI\fR
.IX Subsection "clone"
.PP
.Vb 1
\&  $new_dbh = $dbh\->clone(\e%attr);
.Ve
.PP
The \f(CW\*(C`clone\*(C'\fR method duplicates the \f(CW$dbh\fR connection by connecting
with the same parameters ($dsn, \f(CW$user\fR, \f(CW$password\fR) as originally used.
.PP
The attributes for the cloned connect are the same as those used
for the \fIoriginal\fR connect, with any other attributes in \f(CW\*(C`\e%attr\*(C'\fR
merged over them.  Effectively the same as doing:
.PP
.Vb 1
\&  %attributes_used = ( %original_attributes, %attr );
.Ve
.PP
If \e%attr is not given then it defaults to a hash containing all
the attributes in the attribute cache of \f(CW$dbh\fR excluding any non-code
references, plus the main boolean attributes (RaiseError, PrintError,
AutoCommit, etc.). \fIThis behaviour is unreliable and so use of clone without
an argument is deprecated and may cause a warning in a future release.\fR
.PP
The clone method can be used even if the database handle is disconnected.
.PP
The \f(CW\*(C`clone\*(C'\fR method was added in \s-1DBI 1.33.\s0
.PP
\fI\f(CI\*(C`data_sources\*(C'\fI\fR
.IX Subsection "data_sources"
.PP
.Vb 2
\&  @ary = $dbh\->data_sources();
\&  @ary = $dbh\->data_sources(\e%attr);
.Ve
.PP
Returns a list of data sources (databases) available via the \f(CW$dbh\fR
driver's \fIdata_sources()\fR method, plus any extra data sources that
the driver can discover via the connected \f(CW$dbh\fR. Typically the extra
data sources are other databases managed by the same server process
that the \f(CW$dbh\fR is connected to.
.PP
Data sources are returned in a form suitable for passing to the
\&\*(L"connect\*(R" method (that is, they will include the "\f(CW\*(C`dbi:$driver:\*(C'\fR" prefix).
.PP
The \fIdata_sources()\fR method, for a \f(CW$dbh\fR, was added in \s-1DBI 1.38.\s0
.PP
\fI\f(CI\*(C`do\*(C'\fI\fR
.IX Subsection "do"
.PP
.Vb 3
\&  $rows = $dbh\->do($statement)           or die $dbh\->errstr;
\&  $rows = $dbh\->do($statement, \e%attr)   or die $dbh\->errstr;
\&  $rows = $dbh\->do($statement, \e%attr, @bind_values) or die ...
.Ve
.PP
Prepare and execute a single statement. Returns the number of rows
affected or \f(CW\*(C`undef\*(C'\fR on error. A return value of \f(CW\*(C`\-1\*(C'\fR means the
number of rows is not known, not applicable, or not available.
.PP
This method is typically most useful for \fInon\fR\-\f(CW\*(C`SELECT\*(C'\fR statements that
either cannot be prepared in advance (due to a limitation of the
driver) or do not need to be executed repeatedly. It should not
be used for \f(CW\*(C`SELECT\*(C'\fR statements because it does not return a statement
handle (so you can't fetch any data).
.PP
The default \f(CW\*(C`do\*(C'\fR method is logically similar to:
.PP
.Vb 7
\&  sub do {
\&      my($dbh, $statement, $attr, @bind_values) = @_;
\&      my $sth = $dbh\->prepare($statement, $attr) or return undef;
\&      $sth\->execute(@bind_values) or return undef;
\&      my $rows = $sth\->rows;
\&      ($rows == 0) ? "0E0" : $rows; # always return true if no error
\&  }
.Ve
.PP
For example:
.PP
.Vb 4
\&  my $rows_deleted = $dbh\->do(q{
\&      DELETE FROM table
\&      WHERE status = ?
\&  }, undef, \*(AqDONE\*(Aq) or die $dbh\->errstr;
.Ve
.PP
Using placeholders and \f(CW@bind_values\fR with the \f(CW\*(C`do\*(C'\fR method can be
useful because it avoids the need to correctly quote any variables
in the \f(CW$statement\fR. But if you'll be executing the statement many
times then it's more efficient to \f(CW\*(C`prepare\*(C'\fR it once and call
\&\f(CW\*(C`execute\*(C'\fR many times instead.
.PP
The \f(CW\*(C`q{...}\*(C'\fR style quoting used in this example avoids clashing with
quotes that may be used in the \s-1SQL\s0 statement. Use the double-quote-like
\&\f(CW\*(C`qq{...}\*(C'\fR operator if you want to interpolate variables into the string.
See \*(L"Quote and Quote-like Operators\*(R" in perlop for more details.
.PP
Note drivers are free to avoid the overhead of creating an \s-1DBI\s0
statement handle for \fIdo()\fR, especially if there are no parameters. In
this case error handlers, if invoked during \fIdo()\fR, will be passed the
database handle.
.PP
\fI\f(CI\*(C`last_insert_id\*(C'\fI\fR
.IX Subsection "last_insert_id"
.PP
.Vb 2
\&  $rv = $dbh\->last_insert_id($catalog, $schema, $table, $field);
\&  $rv = $dbh\->last_insert_id($catalog, $schema, $table, $field, \e%attr);
.Ve
.PP
Returns a value 'identifying' the row just inserted, if possible.
Typically this would be a value assigned by the database server
to a column with an \fIauto_increment\fR or \fIserial\fR type.
Returns undef if the driver does not support the method or can't
determine the value.
.PP
The \f(CW$catalog\fR, \f(CW$schema\fR, \f(CW$table\fR, and \f(CW$field\fR parameters may be required
for some drivers (see below).  If you don't know the parameter values
and your driver does not need them, then use \f(CW\*(C`undef\*(C'\fR for each.
.PP
There are several caveats to be aware of with this method if you want
to use it for portable applications:
.PP
\&\fB*\fR For some drivers the value may only available immediately after
the insert statement has executed (e.g., mysql, Informix).
.PP
\&\fB*\fR For some drivers the \f(CW$catalog\fR, \f(CW$schema\fR, \f(CW$table\fR, and \f(CW$field\fR parameters
are required, for others they are ignored (e.g., mysql).
.PP
\&\fB*\fR Drivers may return an indeterminate value if no insert has
been performed yet.
.PP
\&\fB*\fR For some drivers the value may only be available if placeholders
have \fInot\fR been used (e.g., Sybase, \s-1MS SQL\s0). In this case the value
returned would be from the last non-placeholder insert statement.
.PP
\&\fB*\fR Some drivers may need driver-specific hints about how to get
the value. For example, being told the name of the database 'sequence'
object that holds the value. Any such hints are passed as driver-specific
attributes in the \e%attr parameter.
.PP
\&\fB*\fR If the underlying database offers nothing better, then some
drivers may attempt to implement this method by executing
"\f(CW\*(C`select max($field) from $table\*(C'\fR". Drivers using any approach
like this should issue a warning if \f(CW\*(C`AutoCommit\*(C'\fR is true because
it is generally unsafe \- another process may have modified the table
between your insert and the select. For situations where you know
it is safe, such as when you have locked the table, you can silence
the warning by passing \f(CW\*(C`Warn\*(C'\fR => 0 in \e%attr.
.PP
\&\fB*\fR If no insert has been performed yet, or the last insert failed,
then the value is implementation defined.
.PP
Given all the caveats above, it's clear that this method must be
used with care.
.PP
The \f(CW\*(C`last_insert_id\*(C'\fR method was added in \s-1DBI 1.38.\s0
.PP
\fI\f(CI\*(C`selectrow_array\*(C'\fI\fR
.IX Subsection "selectrow_array"
.PP
.Vb 3
\&  @row_ary = $dbh\->selectrow_array($statement);
\&  @row_ary = $dbh\->selectrow_array($statement, \e%attr);
\&  @row_ary = $dbh\->selectrow_array($statement, \e%attr, @bind_values);
.Ve
.PP
This utility method combines \*(L"prepare\*(R", \*(L"execute\*(R" and
\&\*(L"fetchrow_array\*(R" into a single call. If called in a list context, it
returns the first row of data from the statement.  The \f(CW$statement\fR
parameter can be a previously prepared statement handle, in which case
the \f(CW\*(C`prepare\*(C'\fR is skipped.
.PP
If any method fails, and \*(L"RaiseError\*(R" is not set, \f(CW\*(C`selectrow_array\*(C'\fR
will return an empty list.
.PP
If called in a scalar context for a statement handle that has more
than one column, it is undefined whether the driver will return
the value of the first column or the last. So don't do that.
Also, in a scalar context, an \f(CW\*(C`undef\*(C'\fR is returned if there are no
more rows or if an error occurred. That \f(CW\*(C`undef\*(C'\fR can't be distinguished
from an \f(CW\*(C`undef\*(C'\fR returned because the first field value was \s-1NULL.\s0
For these reasons you should exercise some caution if you use
\&\f(CW\*(C`selectrow_array\*(C'\fR in a scalar context, or just don't do that.
.PP
\fI\f(CI\*(C`selectrow_arrayref\*(C'\fI\fR
.IX Subsection "selectrow_arrayref"
.PP
.Vb 3
\&  $ary_ref = $dbh\->selectrow_arrayref($statement);
\&  $ary_ref = $dbh\->selectrow_arrayref($statement, \e%attr);
\&  $ary_ref = $dbh\->selectrow_arrayref($statement, \e%attr, @bind_values);
.Ve
.PP
This utility method combines \*(L"prepare\*(R", \*(L"execute\*(R" and
\&\*(L"fetchrow_arrayref\*(R" into a single call. It returns the first row of
data from the statement.  The \f(CW$statement\fR parameter can be a previously
prepared statement handle, in which case the \f(CW\*(C`prepare\*(C'\fR is skipped.
.PP
If any method fails, and \*(L"RaiseError\*(R" is not set, \f(CW\*(C`selectrow_array\*(C'\fR
will return undef.
.PP
\fI\f(CI\*(C`selectrow_hashref\*(C'\fI\fR
.IX Subsection "selectrow_hashref"
.PP
.Vb 3
\&  $hash_ref = $dbh\->selectrow_hashref($statement);
\&  $hash_ref = $dbh\->selectrow_hashref($statement, \e%attr);
\&  $hash_ref = $dbh\->selectrow_hashref($statement, \e%attr, @bind_values);
.Ve
.PP
This utility method combines \*(L"prepare\*(R", \*(L"execute\*(R" and
\&\*(L"fetchrow_hashref\*(R" into a single call. It returns the first row of
data from the statement.  The \f(CW$statement\fR parameter can be a previously
prepared statement handle, in which case the \f(CW\*(C`prepare\*(C'\fR is skipped.
.PP
If any method fails, and \*(L"RaiseError\*(R" is not set, \f(CW\*(C`selectrow_hashref\*(C'\fR
will return undef.
.PP
\fI\f(CI\*(C`selectall_arrayref\*(C'\fI\fR
.IX Subsection "selectall_arrayref"
.PP
.Vb 3
\&  $ary_ref = $dbh\->selectall_arrayref($statement);
\&  $ary_ref = $dbh\->selectall_arrayref($statement, \e%attr);
\&  $ary_ref = $dbh\->selectall_arrayref($statement, \e%attr, @bind_values);
.Ve
.PP
This utility method combines \*(L"prepare\*(R", \*(L"execute\*(R" and
\&\*(L"fetchall_arrayref\*(R" into a single call. It returns a reference to an
array containing a reference to an array (or hash, see below) for each row of
data fetched.
.PP
The \f(CW$statement\fR parameter can be a previously prepared statement handle,
in which case the \f(CW\*(C`prepare\*(C'\fR is skipped. This is recommended if the
statement is going to be executed many times.
.PP
If \*(L"RaiseError\*(R" is not set and any method except \f(CW\*(C`fetchall_arrayref\*(C'\fR
fails then \f(CW\*(C`selectall_arrayref\*(C'\fR will return \f(CW\*(C`undef\*(C'\fR; if
\&\f(CW\*(C`fetchall_arrayref\*(C'\fR fails then it will return with whatever data
has been fetched thus far. You should check \f(CW\*(C`$dbh\->err\*(C'\fR
afterwards (or use the \f(CW\*(C`RaiseError\*(C'\fR attribute) to discover if the data is
complete or was truncated due to an error.
.PP
The \*(L"fetchall_arrayref\*(R" method called by \f(CW\*(C`selectall_arrayref\*(C'\fR
supports a \f(CW$max_rows\fR parameter. You can specify a value for \f(CW$max_rows\fR
by including a '\f(CW\*(C`MaxRows\*(C'\fR' attribute in \e%attr. In which case \fIfinish()\fR
is called for you after \fIfetchall_arrayref()\fR returns.
.PP
The \*(L"fetchall_arrayref\*(R" method called by \f(CW\*(C`selectall_arrayref\*(C'\fR
also supports a \f(CW$slice\fR parameter. You can specify a value for \f(CW$slice\fR by
including a '\f(CW\*(C`Slice\*(C'\fR' or '\f(CW\*(C`Columns\*(C'\fR' attribute in \e%attr. The only
difference between the two is that if \f(CW\*(C`Slice\*(C'\fR is not defined and
\&\f(CW\*(C`Columns\*(C'\fR is an array ref, then the array is assumed to contain column
index values (which count from 1), rather than perl array index values.
In which case the array is copied and each value decremented before
passing to \f(CW\*(C`/fetchall_arrayref\*(C'\fR.
.PP
You may often want to fetch an array of rows where each row is stored as a
hash. That can be done simple using:
.PP
.Vb 7
\&  my $emps = $dbh\->selectall_arrayref(
\&      "SELECT ename FROM emp ORDER BY ename",
\&      { Slice => {} }
\&  );
\&  foreach my $emp ( @$emps ) {
\&      print "Employee: $emp\->{ename}\en";
\&  }
.Ve
.PP
Or, to fetch into an array instead of an array ref:
.PP
.Vb 1
\&  @result = @{ $dbh\->selectall_arrayref($sql, { Slice => {} }) };
.Ve
.PP
See \*(L"fetchall_arrayref\*(R" method for more details.
.PP
\fI\f(CI\*(C`selectall_hashref\*(C'\fI\fR
.IX Subsection "selectall_hashref"
.PP
.Vb 3
\&  $hash_ref = $dbh\->selectall_hashref($statement, $key_field);
\&  $hash_ref = $dbh\->selectall_hashref($statement, $key_field, \e%attr);
\&  $hash_ref = $dbh\->selectall_hashref($statement, $key_field, \e%attr, @bind_values);
.Ve
.PP
This utility method combines \*(L"prepare\*(R", \*(L"execute\*(R" and
\&\*(L"fetchall_hashref\*(R" into a single call. It returns a reference to a
hash containing one entry, at most, for each row, as returned by \fIfetchall_hashref()\fR.
.PP
The \f(CW$statement\fR parameter can be a previously prepared statement handle,
in which case the \f(CW\*(C`prepare\*(C'\fR is skipped.  This is recommended if the
statement is going to be executed many times.
.PP
The \f(CW$key_field\fR parameter defines which column, or columns, are used as keys
in the returned hash. It can either be the name of a single field, or a
reference to an array containing multiple field names. Using multiple names
yields a tree of nested hashes.
.PP
If a row has the same key as an earlier row then it replaces the earlier row.
.PP
If any method except \f(CW\*(C`fetchrow_hashref\*(C'\fR fails, and \*(L"RaiseError\*(R" is not set,
\&\f(CW\*(C`selectall_hashref\*(C'\fR will return \f(CW\*(C`undef\*(C'\fR.  If \f(CW\*(C`fetchrow_hashref\*(C'\fR fails and
\&\*(L"RaiseError\*(R" is not set, then it will return with whatever data it
has fetched thus far. \f(CW$DBI::err\fR should be checked to catch that.
.PP
See \fIfetchall_hashref()\fR for more details.
.PP
\fI\f(CI\*(C`selectcol_arrayref\*(C'\fI\fR
.IX Subsection "selectcol_arrayref"
.PP
.Vb 3
\&  $ary_ref = $dbh\->selectcol_arrayref($statement);
\&  $ary_ref = $dbh\->selectcol_arrayref($statement, \e%attr);
\&  $ary_ref = $dbh\->selectcol_arrayref($statement, \e%attr, @bind_values);
.Ve
.PP
This utility method combines \*(L"prepare\*(R", \*(L"execute\*(R", and fetching one
column from all the rows, into a single call. It returns a reference to
an array containing the values of the first column from each row.
.PP
The \f(CW$statement\fR parameter can be a previously prepared statement handle,
in which case the \f(CW\*(C`prepare\*(C'\fR is skipped. This is recommended if the
statement is going to be executed many times.
.PP
If any method except \f(CW\*(C`fetch\*(C'\fR fails, and \*(L"RaiseError\*(R" is not set,
\&\f(CW\*(C`selectcol_arrayref\*(C'\fR will return \f(CW\*(C`undef\*(C'\fR.  If \f(CW\*(C`fetch\*(C'\fR fails and
\&\*(L"RaiseError\*(R" is not set, then it will return with whatever data it
has fetched thus far. \f(CW$DBI::err\fR should be checked to catch that.
.PP
The \f(CW\*(C`selectcol_arrayref\*(C'\fR method defaults to pushing a single column
value (the first) from each row into the result array. However, it can
also push another column, or even multiple columns per row, into the
result array. This behaviour can be specified via a '\f(CW\*(C`Columns\*(C'\fR'
attribute which must be a ref to an array containing the column number
or numbers to use. For example:
.PP
.Vb 3
\&  # get array of id and name pairs:
\&  my $ary_ref = $dbh\->selectcol_arrayref("select id, name from table", { Columns=>[1,2] });
\&  my %hash = @$ary_ref; # build hash from key\-value pairs so $hash{$id} => name
.Ve
.PP
You can specify a maximum number of rows to fetch by including a
\&'\f(CW\*(C`MaxRows\*(C'\fR' attribute in \e%attr.
.PP
\fI\f(CI\*(C`prepare\*(C'\fI\fR
.IX Subsection "prepare"
.PP
.Vb 2
\&  $sth = $dbh\->prepare($statement)          or die $dbh\->errstr;
\&  $sth = $dbh\->prepare($statement, \e%attr)  or die $dbh\->errstr;
.Ve
.PP
Prepares a statement for later execution by the database
engine and returns a reference to a statement handle object.
.PP
The returned statement handle can be used to get attributes of the
statement and invoke the \*(L"execute\*(R" method. See \*(L"Statement Handle Methods\*(R".
.PP
Drivers for engines without the concept of preparing a
statement will typically just store the statement in the returned
handle and process it when \f(CW\*(C`$sth\->execute\*(C'\fR is called. Such drivers are
unlikely to give much useful information about the
statement, such as \f(CW\*(C`$sth\->{NUM_OF_FIELDS}\*(C'\fR, until after \f(CW\*(C`$sth\->execute\*(C'\fR
has been called. Portable applications should take this into account.
.PP
In general, \s-1DBI\s0 drivers do not parse the contents of the statement
(other than simply counting any \*(L"Placeholders\*(R"). The statement is
passed directly to the database engine, sometimes known as pass-thru
mode. This has advantages and disadvantages. On the plus side, you can
access all the functionality of the engine being used. On the downside,
you're limited if you're using a simple engine, and you need to take extra care if
writing applications intended to be portable between engines.
.PP
Portable applications should not assume that a new statement can be
prepared and/or executed while still fetching results from a previous
statement.
.PP
Some command-line \s-1SQL\s0 tools use statement terminators, like a semicolon,
to indicate the end of a statement. Such terminators should not normally
be used with the \s-1DBI.\s0
.PP
\fI\f(CI\*(C`prepare_cached\*(C'\fI\fR
.IX Subsection "prepare_cached"
.PP
.Vb 3
\&  $sth = $dbh\->prepare_cached($statement)
\&  $sth = $dbh\->prepare_cached($statement, \e%attr)
\&  $sth = $dbh\->prepare_cached($statement, \e%attr, $if_active)
.Ve
.PP
Like \*(L"prepare\*(R" except that the statement handle returned will be
stored in a hash associated with the \f(CW$dbh\fR. If another call is made to
\&\f(CW\*(C`prepare_cached\*(C'\fR with the same \f(CW$statement\fR and \f(CW%attr\fR parameter values,
then the corresponding cached \f(CW$sth\fR will be returned without contacting the
database server.
.PP
The \f(CW$if_active\fR parameter lets you adjust the behaviour if an
already cached statement handle is still Active.  There are several
alternatives:
.ie n .IP "\fB0\fR: A warning will be generated, and \fIfinish()\fR will be called on the statement handle before it is returned.  This is the default behaviour if $if_active is not passed." 4
.el .IP "\fB0\fR: A warning will be generated, and \fIfinish()\fR will be called on the statement handle before it is returned.  This is the default behaviour if \f(CW$if_active\fR is not passed." 4
.IX Item "0: A warning will be generated, and finish() will be called on the statement handle before it is returned. This is the default behaviour if $if_active is not passed."
.PD 0
.IP "\fB1\fR: \fIfinish()\fR will be called on the statement handle, but the warning is suppressed." 4
.IX Item "1: finish() will be called on the statement handle, but the warning is suppressed."
.IP "\fB2\fR: Disables any checking." 4
.IX Item "2: Disables any checking."
.IP "\fB3\fR: The existing active statement handle will be removed from the cache and a new statement handle prepared and cached in its place. This is the safest option because it doesn't affect the state of the old handle, it just removes it from the cache. [Added in \s-1DBI 1.40\s0]" 4
.IX Item "3: The existing active statement handle will be removed from the cache and a new statement handle prepared and cached in its place. This is the safest option because it doesn't affect the state of the old handle, it just removes it from the cache. [Added in DBI 1.40]"
.PD
.PP
Here are some examples of \f(CW\*(C`prepare_cached\*(C'\fR:
.PP
.Vb 10
\&  sub insert_hash {
\&    my ($table, $field_values) = @_;
\&    # sort to keep field order, and thus sql, stable for prepare_cached
\&    my @fields = sort keys %$field_values;
\&    my @values = @{$field_values}{@fields};
\&    my $sql = sprintf "insert into %s (%s) values (%s)",
\&        $table, join(",", @fields), join(",", ("?")x@fields);
\&    my $sth = $dbh\->prepare_cached($sql);
\&    return $sth\->execute(@values);
\&  }
\&
\&  sub search_hash {
\&    my ($table, $field_values) = @_;
\&    # sort to keep field order, and thus sql, stable for prepare_cached
\&    my @fields = sort keys %$field_values;
\&    my @values = @{$field_values}{@fields};
\&    my $qualifier = "";
\&    $qualifier = "where ".join(" and ", map { "$_=?" } @fields) if @fields;
\&    $sth = $dbh\->prepare_cached("SELECT * FROM $table $qualifier");
\&    return $dbh\->selectall_arrayref($sth, {}, @values);
\&  }
.Ve
.PP
\&\fICaveat emptor:\fR This caching can be useful in some applications,
but it can also cause problems and should be used with care. Here
is a contrived case where caching would cause a significant problem:
.PP
.Vb 3
\&  my $sth = $dbh\->prepare_cached(\*(AqSELECT * FROM foo WHERE bar=?\*(Aq);
\&  $sth\->execute(...);
\&  while (my $data = $sth\->fetchrow_hashref) {
\&
\&    # later, in some other code called within the loop...
\&    my $sth2 = $dbh\->prepare_cached(\*(AqSELECT * FROM foo WHERE bar=?\*(Aq);
\&    $sth2\->execute(...);
\&    while (my $data2 = $sth2\->fetchrow_arrayref) {
\&      do_stuff(...);
\&    }
\&  }
.Ve
.PP
In this example, since both handles are preparing the exact same statement,
\&\f(CW$sth2\fR will not be its own statement handle, but a duplicate of \f(CW$sth\fR
returned from the cache. The results will certainly not be what you expect.
Typically the inner fetch loop will work normally, fetching all
the records and terminating when there are no more, but now that \f(CW$sth\fR
is the same as \f(CW$sth2\fR the outer fetch loop will also terminate.
.PP
You'll know if you run into this problem because \fIprepare_cached()\fR
will generate a warning by default (when \f(CW$if_active\fR is false).
.PP
The cache used by \fIprepare_cached()\fR is keyed by both the statement
and any attributes so you can also avoid this issue by doing something
like:
.PP
.Vb 1
\&  $sth = $dbh\->prepare_cached("...", { dbi_dummy => _\|_FILE_\|_._\|_LINE_\|_ });
.Ve
.PP
which will ensure that prepare_cached only returns statements cached
by that line of code in that source file.
.PP
If you'd like the cache to managed intelligently, you can tie the
hashref returned by \f(CW\*(C`CachedKids\*(C'\fR to an appropriate caching module,
such as Tie::Cache::LRU:
.PP
.Vb 3
\&  my $cache;
\&  tie %$cache, \*(AqTie::Cache::LRU\*(Aq, 500;
\&  $dbh\->{CachedKids} = $cache;
.Ve
.PP
\fI\f(CI\*(C`commit\*(C'\fI\fR
.IX Subsection "commit"
.PP
.Vb 1
\&  $rc  = $dbh\->commit     or die $dbh\->errstr;
.Ve
.PP
Commit (make permanent) the most recent series of database changes
if the database supports transactions and AutoCommit is off.
.PP
If \f(CW\*(C`AutoCommit\*(C'\fR is on, then calling
\&\f(CW\*(C`commit\*(C'\fR will issue a \*(L"commit ineffective with AutoCommit\*(R" warning.
.PP
See also \*(L"Transactions\*(R" in the \*(L"\s-1FURTHER INFORMATION\*(R"\s0 section below.
.PP
\fI\f(CI\*(C`rollback\*(C'\fI\fR
.IX Subsection "rollback"
.PP
.Vb 1
\&  $rc  = $dbh\->rollback   or die $dbh\->errstr;
.Ve
.PP
Rollback (undo) the most recent series of uncommitted database
changes if the database supports transactions and AutoCommit is off.
.PP
If \f(CW\*(C`AutoCommit\*(C'\fR is on, then calling
\&\f(CW\*(C`rollback\*(C'\fR will issue a \*(L"rollback ineffective with AutoCommit\*(R" warning.
.PP
See also \*(L"Transactions\*(R" in the \*(L"\s-1FURTHER INFORMATION\*(R"\s0 section below.
.PP
\fI\f(CI\*(C`begin_work\*(C'\fI\fR
.IX Subsection "begin_work"
.PP
.Vb 1
\&  $rc  = $dbh\->begin_work   or die $dbh\->errstr;
.Ve
.PP
Enable transactions (by turning \f(CW\*(C`AutoCommit\*(C'\fR off) until the next call
to \f(CW\*(C`commit\*(C'\fR or \f(CW\*(C`rollback\*(C'\fR. After the next \f(CW\*(C`commit\*(C'\fR or \f(CW\*(C`rollback\*(C'\fR,
\&\f(CW\*(C`AutoCommit\*(C'\fR will automatically be turned on again.
.PP
If \f(CW\*(C`AutoCommit\*(C'\fR is already off when \f(CW\*(C`begin_work\*(C'\fR is called then
it does nothing except return an error. If the driver does not support
transactions then when \f(CW\*(C`begin_work\*(C'\fR attempts to set \f(CW\*(C`AutoCommit\*(C'\fR off
the driver will trigger a fatal error.
.PP
See also \*(L"Transactions\*(R" in the \*(L"\s-1FURTHER INFORMATION\*(R"\s0 section below.
.PP
\fI\f(CI\*(C`disconnect\*(C'\fI\fR
.IX Subsection "disconnect"
.PP
.Vb 1
\&  $rc = $dbh\->disconnect  or warn $dbh\->errstr;
.Ve
.PP
Disconnects the database from the database handle. \f(CW\*(C`disconnect\*(C'\fR is typically only used
before exiting the program. The handle is of little use after disconnecting.
.PP
The transaction behaviour of the \f(CW\*(C`disconnect\*(C'\fR method is, sadly,
undefined.  Some database systems (such as Oracle and Ingres) will
automatically commit any outstanding changes, but others (such as
Informix) will rollback any outstanding changes.  Applications not
using \f(CW\*(C`AutoCommit\*(C'\fR should explicitly call \f(CW\*(C`commit\*(C'\fR or \f(CW\*(C`rollback\*(C'\fR before
calling \f(CW\*(C`disconnect\*(C'\fR.
.PP
The database is automatically disconnected by the \f(CW\*(C`DESTROY\*(C'\fR method if
still connected when there are no longer any references to the handle.
The \f(CW\*(C`DESTROY\*(C'\fR method for each driver should implicitly call \f(CW\*(C`rollback\*(C'\fR to
undo any uncommitted changes. This is vital behaviour to ensure that
incomplete transactions don't get committed simply because Perl calls
\&\f(CW\*(C`DESTROY\*(C'\fR on every object before exiting. Also, do not rely on the order
of object destruction during \*(L"global destruction\*(R", as it is undefined.
.PP
Generally, if you want your changes to be committed or rolled back when
you disconnect, then you should explicitly call \*(L"commit\*(R" or \*(L"rollback\*(R"
before disconnecting.
.PP
If you disconnect from a database while you still have active
statement handles (e.g., \s-1SELECT\s0 statement handles that may have
more data to fetch), you will get a warning. The warning may indicate
that a fetch loop terminated early, perhaps due to an uncaught error.
To avoid the warning call the \f(CW\*(C`finish\*(C'\fR method on the active handles.
.PP
\fI\f(CI\*(C`ping\*(C'\fI\fR
.IX Subsection "ping"
.PP
.Vb 1
\&  $rc = $dbh\->ping;
.Ve
.PP
Attempts to determine, in a reasonably efficient way, if the database
server is still running and the connection to it is still working.
Individual drivers should implement this function in the most suitable
manner for their database engine.
.PP
The current \fIdefault\fR implementation always returns true without
actually doing anything. Actually, it returns "\f(CW\*(C`0 but true\*(C'\fR" which is
true but zero. That way you can tell if the return value is genuine or
just the default. Drivers should override this method with one that
does the right thing for their type of database.
.PP
Few applications would have direct use for this method. See the specialized
Apache::DBI module for one example usage.
.PP
\fI\f(CI\*(C`get_info\*(C'\fI\fR
.IX Subsection "get_info"
.PP
.Vb 1
\&  $value = $dbh\->get_info( $info_type );
.Ve
.PP
Returns information about the implementation, i.e. driver and data
source capabilities, restrictions etc. It returns \f(CW\*(C`undef\*(C'\fR for
unknown or unimplemented information types. For example:
.PP
.Vb 2
\&  $database_version  = $dbh\->get_info(  18 ); # SQL_DBMS_VER
\&  $max_select_tables = $dbh\->get_info( 106 ); # SQL_MAXIMUM_TABLES_IN_SELECT
.Ve
.PP
See \*(L"Standards Reference Information\*(R" for more detailed information
about the information types and their meanings and possible return values.
.PP
The DBI::Const::GetInfoType module exports a \f(CW%GetInfoType\fR hash that
can be used to map info type names to numbers. For example:
.PP
.Vb 1
\&  $database_version = $dbh\->get_info( $GetInfoType{SQL_DBMS_VER} );
.Ve
.PP
The names are a merging of the \s-1ANSI\s0 and \s-1ODBC\s0 standards (which differ
in some cases). See DBI::Const::GetInfoType for more details.
.PP
Because some \s-1DBI\s0 methods make use of \fIget_info()\fR, drivers are strongly
encouraged to support \fIat least\fR the following very minimal set
of information types to ensure the \s-1DBI\s0 itself works properly:
.PP
.Vb 7
\& Type  Name                        Example A     Example B
\& \-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   17  SQL_DBMS_NAME               \*(AqACCESS\*(Aq      \*(AqOracle\*(Aq
\&   18  SQL_DBMS_VER                \*(Aq03.50.0000\*(Aq  \*(Aq08.01.0721 ...\*(Aq
\&   29  SQL_IDENTIFIER_QUOTE_CHAR   \*(Aq\`\*(Aq           \*(Aq"\*(Aq
\&   41  SQL_CATALOG_NAME_SEPARATOR  \*(Aq.\*(Aq           \*(Aq@\*(Aq
\&  114  SQL_CATALOG_LOCATION        1             2
.Ve
.PP
\fI\f(CI\*(C`table_info\*(C'\fI\fR
.IX Subsection "table_info"
.PP
.Vb 2
\&  $sth = $dbh\->table_info( $catalog, $schema, $table, $type );
\&  $sth = $dbh\->table_info( $catalog, $schema, $table, $type, \e%attr );
\&
\&  # then $sth\->fetchall_arrayref or $sth\->fetchall_hashref etc
.Ve
.PP
Returns an active statement handle that can be used to fetch
information about tables and views that exist in the database.
.PP
The arguments \f(CW$catalog\fR, \f(CW$schema\fR and \f(CW$table\fR may accept search patterns
according to the database/driver, for example: \f(CW$table\fR = '%FOO%';
Remember that the underscore character ('\f(CW\*(C`_\*(C'\fR') is a search pattern
that means match any character, so 'FOO_%' is the same as 'FOO%'
and 'FOO_BAR%' will match names like '\s-1FOO1BAR\s0'.
.PP
The value of \f(CW$type\fR is a comma-separated list of one or more types of
tables to be returned in the result set. Each value may optionally be
quoted, e.g.:
.PP
.Vb 2
\&  $type = "TABLE";
\&  $type = "\*(AqTABLE\*(Aq,\*(AqVIEW\*(Aq";
.Ve
.PP
In addition the following special cases may also be supported by some drivers:
.IP "\(bu" 4
If the value of \f(CW$catalog\fR is '%' and \f(CW$schema\fR and \f(CW$table\fR name
are empty strings, the result set contains a list of catalog names.
For example:
.Sp
.Vb 1
\&  $sth = $dbh\->table_info(\*(Aq%\*(Aq, \*(Aq\*(Aq, \*(Aq\*(Aq);
.Ve
.IP "\(bu" 4
If the value of \f(CW$schema\fR is '%' and \f(CW$catalog\fR and \f(CW$table\fR are empty
strings, the result set contains a list of schema names.
.IP "\(bu" 4
If the value of \f(CW$type\fR is '%' and \f(CW$catalog\fR, \f(CW$schema\fR, and \f(CW$table\fR are all
empty strings, the result set contains a list of table types.
.PP
If your driver doesn't support one or more of the selection filter
parameters then you may get back more than you asked for and can
do the filtering yourself.
.PP
This method can be expensive, and can return a large amount of data.
(For example, small Oracle installation returns over 2000 rows.)
So it's a good idea to use the filters to limit the data as much as possible.
.PP
The statement handle returned has at least the following fields in the
order show below. Other fields, after these, may also be present.
.PP
\&\fB\s-1TABLE_CAT\s0\fR: Table catalog identifier. This field is \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) if not
applicable to the data source, which is usually the case. This field
is empty if not applicable to the table.
.PP
\&\fB\s-1TABLE_SCHEM\s0\fR: The name of the schema containing the \s-1TABLE_NAME\s0 value.
This field is \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) if not applicable to data source, and
empty if not applicable to the table.
.PP
\&\fB\s-1TABLE_NAME\s0\fR: Name of the table (or view, synonym, etc).
.PP
\&\fB\s-1TABLE_TYPE\s0\fR: One of the following: \*(L"\s-1TABLE\*(R", \*(L"VIEW\*(R", \*(L"SYSTEM TABLE\*(R",
\&\*(L"GLOBAL TEMPORARY\*(R", \*(L"LOCAL TEMPORARY\*(R", \*(L"ALIAS\*(R", \*(L"SYNONYM\*(R"\s0 or a type
identifier that is specific to the data
source.
.PP
\&\fB\s-1REMARKS\s0\fR: A description of the table. May be \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR).
.PP
Note that \f(CW\*(C`table_info\*(C'\fR might not return records for all tables.
Applications can use any valid table regardless of whether it's
returned by \f(CW\*(C`table_info\*(C'\fR.
.PP
See also \*(L"tables\*(R", \*(L"Catalog Methods\*(R" and
\&\*(L"Standards Reference Information\*(R".
.PP
\fI\f(CI\*(C`column_info\*(C'\fI\fR
.IX Subsection "column_info"
.PP
.Vb 1
\&  $sth = $dbh\->column_info( $catalog, $schema, $table, $column );
\&
\&  # then $sth\->fetchall_arrayref or $sth\->fetchall_hashref etc
.Ve
.PP
Returns an active statement handle that can be used to fetch
information about columns in specified tables.
.PP
The arguments \f(CW$schema\fR, \f(CW$table\fR and \f(CW$column\fR may accept search patterns
according to the database/driver, for example: \f(CW$table\fR = '%FOO%';
.PP
Note: The support for the selection criteria is driver specific. If the
driver doesn't support one or more of them then you may get back more
than you asked for and can do the filtering yourself.
.PP
Note: If your driver does not support column_info an undef is
returned.  This is distinct from asking for something which does not
exist in a driver which supports column_info as a valid statement
handle to an empty result-set will be returned in this case.
.PP
If the arguments don't match any tables then you'll still get a statement
handle, it'll just return no rows.
.PP
The statement handle returned has at least the following fields in the
order shown below. Other fields, after these, may also be present.
.PP
\&\fB\s-1TABLE_CAT\s0\fR: The catalog identifier.
This field is \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) if not applicable to the data source,
which is often the case.  This field is empty if not applicable to the
table.
.PP
\&\fB\s-1TABLE_SCHEM\s0\fR: The schema identifier.
This field is \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) if not applicable to the data source,
and empty if not applicable to the table.
.PP
\&\fB\s-1TABLE_NAME\s0\fR: The table identifier.
Note: A driver may provide column metadata not only for base tables, but
also for derived objects like \s-1SYNONYMS\s0 etc.
.PP
\&\fB\s-1COLUMN_NAME\s0\fR: The column identifier.
.PP
\&\fB\s-1DATA_TYPE\s0\fR: The concise data type code.
.PP
\&\fB\s-1TYPE_NAME\s0\fR: A data source dependent data type name.
.PP
\&\fB\s-1COLUMN_SIZE\s0\fR: The column size.
This is the maximum length in characters for character data types,
the number of digits or bits for numeric data types or the length
in the representation of temporal types.
See the relevant specifications for detailed information.
.PP
\&\fB\s-1BUFFER_LENGTH\s0\fR: The length in bytes of transferred data.
.PP
\&\fB\s-1DECIMAL_DIGITS\s0\fR: The total number of significant digits to the right of
the decimal point.
.PP
\&\fB\s-1NUM_PREC_RADIX\s0\fR: The radix for numeric precision.
The value is 10 or 2 for numeric data types and \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) if not
applicable.
.PP
\&\fB\s-1NULLABLE\s0\fR: Indicates if a column can accept NULLs.
The following values are defined:
.PP
.Vb 3
\&  SQL_NO_NULLS          0
\&  SQL_NULLABLE          1
\&  SQL_NULLABLE_UNKNOWN  2
.Ve
.PP
\&\fB\s-1REMARKS\s0\fR: A description of the column.
.PP
\&\fB\s-1COLUMN_DEF\s0\fR: The default value of the column, in a format that can be used
directly in an \s-1SQL\s0 statement.
.PP
Note that this may be an expression and not simply the text used for the
default value in the original \s-1CREATE TABLE\s0 statement. For example, given:
.PP
.Vb 2
\&    col1 char(30) default current_user    \-\- a \*(Aqfunction\*(Aq
\&    col2 char(30) default \*(Aqstring\*(Aq        \-\- a string literal
.Ve
.PP
where \*(L"current_user\*(R" is the name of a function, the corresponding \f(CW\*(C`COLUMN_DEF\*(C'\fR
values would be:
.PP
.Vb 5
\&    Database        col1                     col2
\&    \-\-\-\-\-\-\-\-        \-\-\-\-                     \-\-\-\-
\&    Oracle:         current_user             \*(Aqstring\*(Aq
\&    Postgres:       "current_user"()         \*(Aqstring\*(Aq::text
\&    MS SQL:         (user_name())            (\*(Aqstring\*(Aq)
.Ve
.PP
\&\fB\s-1SQL_DATA_TYPE\s0\fR: The \s-1SQL\s0 data type.
.PP
\&\fB\s-1SQL_DATETIME_SUB\s0\fR: The subtype code for datetime and interval data types.
.PP
\&\fB\s-1CHAR_OCTET_LENGTH\s0\fR: The maximum length in bytes of a character or binary
data type column.
.PP
\&\fB\s-1ORDINAL_POSITION\s0\fR: The column sequence number (starting with 1).
.PP
\&\fB\s-1IS_NULLABLE\s0\fR: Indicates if the column can accept NULLs.
Possible values are: '\s-1NO\s0', '\s-1YES\s0' and ''.
.PP
\&\s-1SQL/CLI\s0 defines the following additional columns:
.PP
.Vb 10
\&  CHAR_SET_CAT
\&  CHAR_SET_SCHEM
\&  CHAR_SET_NAME
\&  COLLATION_CAT
\&  COLLATION_SCHEM
\&  COLLATION_NAME
\&  UDT_CAT
\&  UDT_SCHEM
\&  UDT_NAME
\&  DOMAIN_CAT
\&  DOMAIN_SCHEM
\&  DOMAIN_NAME
\&  SCOPE_CAT
\&  SCOPE_SCHEM
\&  SCOPE_NAME
\&  MAX_CARDINALITY
\&  DTD_IDENTIFIER
\&  IS_SELF_REF
.Ve
.PP
Drivers capable of supplying any of those values should do so in
the corresponding column and supply undef values for the others.
.PP
Drivers wishing to provide extra database/driver specific information
should do so in extra columns beyond all those listed above, and
use lowercase field names with the driver-specific prefix (i.e.,
\&'ora_...'). Applications accessing such fields should do so by name
and not by column number.
.PP
The result set is ordered by \s-1TABLE_CAT, TABLE_SCHEM, TABLE_NAME\s0
and \s-1ORDINAL_POSITION.\s0
.PP
Note: There is some overlap with statement handle attributes (in perl) and
SQLDescribeCol (in \s-1ODBC\s0). However, SQLColumns provides more metadata.
.PP
See also \*(L"Catalog Methods\*(R" and \*(L"Standards Reference Information\*(R".
.PP
\fI\f(CI\*(C`primary_key_info\*(C'\fI\fR
.IX Subsection "primary_key_info"
.PP
.Vb 1
\&  $sth = $dbh\->primary_key_info( $catalog, $schema, $table );
\&
\&  # then $sth\->fetchall_arrayref or $sth\->fetchall_hashref etc
.Ve
.PP
Returns an active statement handle that can be used to fetch information
about columns that make up the primary key for a table.
The arguments don't accept search patterns (unlike \fItable_info()\fR).
.PP
The statement handle will return one row per column, ordered by
\&\s-1TABLE_CAT, TABLE_SCHEM, TABLE_NAME,\s0 and \s-1KEY_SEQ.\s0
If there is no primary key then the statement handle will fetch no rows.
.PP
Note: The support for the selection criteria, such as \f(CW$catalog\fR, is
driver specific.  If the driver doesn't support catalogs and/or
schemas, it may ignore these criteria.
.PP
The statement handle returned has at least the following fields in the
order shown below. Other fields, after these, may also be present.
.PP
\&\fB\s-1TABLE_CAT\s0\fR: The catalog identifier.
This field is \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) if not applicable to the data source,
which is often the case.  This field is empty if not applicable to the
table.
.PP
\&\fB\s-1TABLE_SCHEM\s0\fR: The schema identifier.
This field is \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) if not applicable to the data source,
and empty if not applicable to the table.
.PP
\&\fB\s-1TABLE_NAME\s0\fR: The table identifier.
.PP
\&\fB\s-1COLUMN_NAME\s0\fR: The column identifier.
.PP
\&\fB\s-1KEY_SEQ\s0\fR: The column sequence number (starting with 1).
Note: This field is named \fB\s-1ORDINAL_POSITION\s0\fR in \s-1SQL/CLI.\s0
.PP
\&\fB\s-1PK_NAME\s0\fR: The primary key constraint identifier.
This field is \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) if not applicable to the data source.
.PP
See also \*(L"Catalog Methods\*(R" and \*(L"Standards Reference Information\*(R".
.PP
\fI\f(CI\*(C`primary_key\*(C'\fI\fR
.IX Subsection "primary_key"
.PP
.Vb 1
\&  @key_column_names = $dbh\->primary_key( $catalog, $schema, $table );
.Ve
.PP
Simple interface to the \fIprimary_key_info()\fR method. Returns a list of
the column names that comprise the primary key of the specified table.
The list is in primary key column sequence order.
If there is no primary key then an empty list is returned.
.PP
\fI\f(CI\*(C`foreign_key_info\*(C'\fI\fR
.IX Subsection "foreign_key_info"
.PP
.Vb 2
\&  $sth = $dbh\->foreign_key_info( $pk_catalog, $pk_schema, $pk_table
\&                               , $fk_catalog, $fk_schema, $fk_table );
\&
\&  $sth = $dbh\->foreign_key_info( $pk_catalog, $pk_schema, $pk_table
\&                               , $fk_catalog, $fk_schema, $fk_table
\&                               , \e%attr );
\&
\&  # then $sth\->fetchall_arrayref or $sth\->fetchall_hashref etc
.Ve
.PP
Returns an active statement handle that can be used to fetch information
about foreign keys in and/or referencing the specified table(s).
The arguments don't accept search patterns (unlike \fItable_info()\fR).
.PP
\&\f(CW$pk_catalog\fR, \f(CW$pk_schema\fR, \f(CW$pk_table\fR
identify the primary (unique) key table (\fB\s-1PKT\s0\fR).
.PP
\&\f(CW$fk_catalog\fR, \f(CW$fk_schema\fR, \f(CW$fk_table\fR
identify the foreign key table (\fB\s-1FKT\s0\fR).
.PP
If both \fB\s-1PKT\s0\fR and \fB\s-1FKT\s0\fR are given, the function returns the foreign key, if
any, in table \fB\s-1FKT\s0\fR that refers to the primary (unique) key of table \fB\s-1PKT\s0\fR.
(Note: In \s-1SQL/CLI,\s0 the result is implementation-defined.)
.PP
If only \fB\s-1PKT\s0\fR is given, then the result set contains the primary key
of that table and all foreign keys that refer to it.
.PP
If only \fB\s-1FKT\s0\fR is given, then the result set contains all foreign keys
in that table and the primary keys to which they refer.
(Note: In \s-1SQL/CLI,\s0 the result includes unique keys too.)
.PP
For example:
.PP
.Vb 3
\&  $sth = $dbh\->foreign_key_info( undef, $user, \*(Aqmaster\*(Aq);
\&  $sth = $dbh\->foreign_key_info( undef, undef,   undef , undef, $user, \*(Aqdetail\*(Aq);
\&  $sth = $dbh\->foreign_key_info( undef, $user, \*(Aqmaster\*(Aq, undef, $user, \*(Aqdetail\*(Aq);
\&
\&  # then $sth\->fetchall_arrayref or $sth\->fetchall_hashref etc
.Ve
.PP
Note: The support for the selection criteria, such as \f(CW$catalog\fR, is
driver specific.  If the driver doesn't support catalogs and/or
schemas, it may ignore these criteria.
.PP
The statement handle returned has the following fields in the order shown below.
Because \s-1ODBC\s0 never includes unique keys, they define different columns in the
result set than \s-1SQL/CLI. SQL/CLI\s0 column names are shown in parentheses.
.PP
\&\fB\s-1PKTABLE_CAT    \s0( \s-1UK_TABLE_CAT      \s0)\fR:
The primary (unique) key table catalog identifier.
This field is \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) if not applicable to the data source,
which is often the case.  This field is empty if not applicable to the
table.
.PP
\&\fB\s-1PKTABLE_SCHEM  \s0( \s-1UK_TABLE_SCHEM    \s0)\fR:
The primary (unique) key table schema identifier.
This field is \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) if not applicable to the data source,
and empty if not applicable to the table.
.PP
\&\fB\s-1PKTABLE_NAME   \s0( \s-1UK_TABLE_NAME     \s0)\fR:
The primary (unique) key table identifier.
.PP
\&\fB\s-1PKCOLUMN_NAME  \s0(\s-1UK_COLUMN_NAME    \s0)\fR:
The primary (unique) key column identifier.
.PP
\&\fB\s-1FKTABLE_CAT    \s0( \s-1FK_TABLE_CAT      \s0)\fR:
The foreign key table catalog identifier.
This field is \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) if not applicable to the data source,
which is often the case.  This field is empty if not applicable to the
table.
.PP
\&\fB\s-1FKTABLE_SCHEM  \s0( \s-1FK_TABLE_SCHEM    \s0)\fR:
The foreign key table schema identifier.
This field is \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) if not applicable to the data source,
and empty if not applicable to the table.
.PP
\&\fB\s-1FKTABLE_NAME   \s0( \s-1FK_TABLE_NAME     \s0)\fR:
The foreign key table identifier.
.PP
\&\fB\s-1FKCOLUMN_NAME  \s0( \s-1FK_COLUMN_NAME    \s0)\fR:
The foreign key column identifier.
.PP
\&\fB\s-1KEY_SEQ        \s0( \s-1ORDINAL_POSITION  \s0)\fR:
The column sequence number (starting with 1).
.PP
\&\fB\s-1UPDATE_RULE    \s0( \s-1UPDATE_RULE       \s0)\fR:
The referential action for the \s-1UPDATE\s0 rule.
The following codes are defined:
.PP
.Vb 5
\&  CASCADE              0
\&  RESTRICT             1
\&  SET NULL             2
\&  NO ACTION            3
\&  SET DEFAULT          4
.Ve
.PP
\&\fB\s-1DELETE_RULE    \s0( \s-1DELETE_RULE       \s0)\fR:
The referential action for the \s-1DELETE\s0 rule.
The codes are the same as for \s-1UPDATE_RULE.\s0
.PP
\&\fB\s-1FK_NAME        \s0( \s-1FK_NAME           \s0)\fR:
The foreign key name.
.PP
\&\fB\s-1PK_NAME        \s0( \s-1UK_NAME           \s0)\fR:
The primary (unique) key name.
.PP
\&\fB\s-1DEFERRABILITY  \s0( \s-1DEFERABILITY      \s0)\fR:
The deferrability of the foreign key constraint.
The following codes are defined:
.PP
.Vb 3
\&  INITIALLY DEFERRED   5
\&  INITIALLY IMMEDIATE  6
\&  NOT DEFERRABLE       7
.Ve
.PP
\&\fB               ( \s-1UNIQUE_OR_PRIMARY \s0)\fR:
This column is necessary if a driver includes all candidate (i.e. primary and
alternate) keys in the result set (as specified by \s-1SQL/CLI\s0).
The value of this column is \s-1UNIQUE\s0 if the foreign key references an alternate
key and \s-1PRIMARY\s0 if the foreign key references a primary key, or it
may be undefined if the driver doesn't have access to the information.
.PP
See also \*(L"Catalog Methods\*(R" and \*(L"Standards Reference Information\*(R".
.PP
\fI\f(CI\*(C`statistics_info\*(C'\fI\fR
.IX Subsection "statistics_info"
.PP
\&\fBWarning:\fR This method is experimental and may change.
.PP
.Vb 1
\&  $sth = $dbh\->statistics_info( $catalog, $schema, $table, $unique_only, $quick );
\&
\&  # then $sth\->fetchall_arrayref or $sth\->fetchall_hashref etc
.Ve
.PP
Returns an active statement handle that can be used to fetch statistical
information about a table and its indexes.
.PP
The arguments don't accept search patterns (unlike \*(L"table_info\*(R").
.PP
If the boolean argument \f(CW$unique_only\fR is true, only \s-1UNIQUE\s0 indexes will be
returned in the result set, otherwise all indexes will be returned.
.PP
If the boolean argument \f(CW$quick\fR is set, the actual statistical information
columns (\s-1CARDINALITY\s0 and \s-1PAGES\s0) will only be returned if they are readily
available from the server, and might not be current.  Some databases may
return stale statistics or no statistics at all with this flag set.
.PP
The statement handle will return at most one row per column name per index,
plus at most one row for the entire table itself, ordered by \s-1NON_UNIQUE, TYPE,
INDEX_QUALIFIER, INDEX_NAME,\s0 and \s-1ORDINAL_POSITION.\s0
.PP
Note: The support for the selection criteria, such as \f(CW$catalog\fR, is
driver specific.  If the driver doesn't support catalogs and/or
schemas, it may ignore these criteria.
.PP
The statement handle returned has at least the following fields in the
order shown below. Other fields, after these, may also be present.
.PP
\&\fB\s-1TABLE_CAT\s0\fR: The catalog identifier.
This field is \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) if not applicable to the data source,
which is often the case.  This field is empty if not applicable to the
table.
.PP
\&\fB\s-1TABLE_SCHEM\s0\fR: The schema identifier.
This field is \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) if not applicable to the data source,
and empty if not applicable to the table.
.PP
\&\fB\s-1TABLE_NAME\s0\fR: The table identifier.
.PP
\&\fB\s-1NON_UNIQUE\s0\fR: Unique index indicator.
Returns 0 for unique indexes, 1 for non-unique indexes
.PP
\&\fB\s-1INDEX_QUALIFIER\s0\fR: Index qualifier identifier.
The identifier that is used to qualify the index name when doing a
\&\f(CW\*(C`DROP INDEX\*(C'\fR; \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) is returned if an index qualifier is not
supported by the data source.
If a non-NULL (defined) value is returned in this column, it must be used
to qualify the index name on a \f(CW\*(C`DROP INDEX\*(C'\fR statement; otherwise,
the \s-1TABLE_SCHEM\s0 should be used to qualify the index name.
.PP
\&\fB\s-1INDEX_NAME\s0\fR: The index identifier.
.PP
\&\fB\s-1TYPE\s0\fR: The type of information being returned.  Can be any of the
following values: 'table', 'btree', 'clustered', 'content', 'hashed',
or 'other'.
.PP
In the case that this field is 'table', all fields
other than \s-1TABLE_CAT, TABLE_SCHEM, TABLE_NAME, TYPE,
CARDINALITY,\s0 and \s-1PAGES\s0 will be \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR).
.PP
\&\fB\s-1ORDINAL_POSITION\s0\fR: Column sequence number (starting with 1).
.PP
\&\fB\s-1COLUMN_NAME\s0\fR: The column identifier.
.PP
\&\fB\s-1ASC_OR_DESC\s0\fR: Column sort sequence.
\&\f(CW\*(C`A\*(C'\fR for Ascending, \f(CW\*(C`D\*(C'\fR for Descending, or \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) if
not supported for this index.
.PP
\&\fB\s-1CARDINALITY\s0\fR: Cardinality of the table or index.
For indexes, this is the number of unique values in the index.
For tables, this is the number of rows in the table.
If not supported, the value will be \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR).
.PP
\&\fB\s-1PAGES\s0\fR: Number of storage pages used by this table or index.
If not supported, the value will be \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR).
.PP
\&\fB\s-1FILTER_CONDITION\s0\fR: The index filter condition as a string.
If the index is not a filtered index, or it cannot be determined
whether the index is a filtered index, this value is \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR).
If the index is a filtered index, but the filter condition
cannot be determined, this value is the empty string \f(CW\*(Aq\*(Aq\fR.
Otherwise it will be the literal filter condition as a string,
such as \f(CW\*(C`SALARY <= 4500\*(C'\fR.
.PP
See also \*(L"Catalog Methods\*(R" and \*(L"Standards Reference Information\*(R".
.PP
\fI\f(CI\*(C`tables\*(C'\fI\fR
.IX Subsection "tables"
.PP
.Vb 2
\&  @names = $dbh\->tables( $catalog, $schema, $table, $type );
\&  @names = $dbh\->tables;        # deprecated
.Ve
.PP
Simple interface to \fItable_info()\fR. Returns a list of matching
table names, possibly including a catalog/schema prefix.
.PP
See \*(L"table_info\*(R" for a description of the parameters.
.PP
If \f(CW\*(C`$dbh\->get_info(29)\*(C'\fR returns true (29 is \s-1SQL_IDENTIFIER_QUOTE_CHAR\s0)
then the table names are constructed and quoted by \*(L"quote_identifier\*(R"
to ensure they are usable even if they contain whitespace or reserved
words etc. This means that the table names returned will include
quote characters.
.PP
\fI\f(CI\*(C`type_info_all\*(C'\fI\fR
.IX Subsection "type_info_all"
.PP
.Vb 1
\&  $type_info_all = $dbh\->type_info_all;
.Ve
.PP
Returns a reference to an array which holds information about each data
type variant supported by the database and driver. The array and its
contents should be treated as read-only.
.PP
The first item is a reference to an 'index' hash of \f(CW\*(C`Name =\*(C'\fR> \f(CW\*(C`Index\*(C'\fR pairs.
The items following that are references to arrays, one per supported data
type variant. The leading index hash defines the names and order of the
fields within the arrays that follow it.
For example:
.PP
.Vb 10
\&  $type_info_all = [
\&    {   TYPE_NAME         => 0,
\&        DATA_TYPE         => 1,
\&        COLUMN_SIZE       => 2,     # was PRECISION originally
\&        LITERAL_PREFIX    => 3,
\&        LITERAL_SUFFIX    => 4,
\&        CREATE_PARAMS     => 5,
\&        NULLABLE          => 6,
\&        CASE_SENSITIVE    => 7,
\&        SEARCHABLE        => 8,
\&        UNSIGNED_ATTRIBUTE=> 9,
\&        FIXED_PREC_SCALE  => 10,    # was MONEY originally
\&        AUTO_UNIQUE_VALUE => 11,    # was AUTO_INCREMENT originally
\&        LOCAL_TYPE_NAME   => 12,
\&        MINIMUM_SCALE     => 13,
\&        MAXIMUM_SCALE     => 14,
\&        SQL_DATA_TYPE     => 15,
\&        SQL_DATETIME_SUB  => 16,
\&        NUM_PREC_RADIX    => 17,
\&        INTERVAL_PRECISION=> 18,
\&    },
\&    [ \*(AqVARCHAR\*(Aq, SQL_VARCHAR,
\&        undef, "\*(Aq","\*(Aq", undef,0, 1,1,0,0,0,undef,1,255, undef
\&    ],
\&    [ \*(AqINTEGER\*(Aq, SQL_INTEGER,
\&        undef,  "", "", undef,0, 0,1,0,0,0,undef,0,  0, 10
\&    ],
\&  ];
.Ve
.PP
More than one row may have the same value in the \f(CW\*(C`DATA_TYPE\*(C'\fR
field if there are different ways to spell the type name and/or there
are variants of the type with different attributes (e.g., with and
without \f(CW\*(C`AUTO_UNIQUE_VALUE\*(C'\fR set, with and without \f(CW\*(C`UNSIGNED_ATTRIBUTE\*(C'\fR, etc).
.PP
The rows are ordered by \f(CW\*(C`DATA_TYPE\*(C'\fR first and then by how closely each
type maps to the corresponding \s-1ODBC SQL\s0 data type, closest first.
.PP
The meaning of the fields is described in the documentation for
the \*(L"type_info\*(R" method.
.PP
An 'index' hash is provided so you don't need to rely on index
values defined above.  However, using \s-1DBD::ODBC\s0 with some old \s-1ODBC\s0
drivers may return older names, shown as comments in the example above.
Another issue with the index hash is that the lettercase of the
keys is not defined. It is usually uppercase, as show here, but
drivers may return names with any lettercase.
.PP
Drivers are also free to return extra driver-specific columns of
information \- though it's recommended that they start at column
index 50 to leave room for expansion of the \s-1DBI/ODBC\s0 specification.
.PP
The \fItype_info_all()\fR method is not normally used directly.
The \*(L"type_info\*(R" method provides a more usable and useful interface
to the data.
.PP
\fI\f(CI\*(C`type_info\*(C'\fI\fR
.IX Subsection "type_info"
.PP
.Vb 1
\&  @type_info = $dbh\->type_info($data_type);
.Ve
.PP
Returns a list of hash references holding information about one or more
variants of \f(CW$data_type\fR. The list is ordered by \f(CW\*(C`DATA_TYPE\*(C'\fR first and
then by how closely each type maps to the corresponding \s-1ODBC SQL\s0 data
type, closest first.  If called in a scalar context then only the first
(best) element is returned.
.PP
If \f(CW$data_type\fR is undefined or \f(CW\*(C`SQL_ALL_TYPES\*(C'\fR, then the list will
contain hashes for all data type variants supported by the database and driver.
.PP
If \f(CW$data_type\fR is an array reference then \f(CW\*(C`type_info\*(C'\fR returns the
information for the \fIfirst\fR type in the array that has any matches.
.PP
The keys of the hash follow the same letter case conventions as the
rest of the \s-1DBI \s0(see \*(L"Naming Conventions and Name Space\*(R"). The
following uppercase items should always exist, though may be undef:
.IP "\s-1TYPE_NAME \s0(string)" 4
.IX Item "TYPE_NAME (string)"
Data type name for use in \s-1CREATE TABLE\s0 statements etc.
.IP "\s-1DATA_TYPE \s0(integer)" 4
.IX Item "DATA_TYPE (integer)"
\&\s-1SQL\s0 data type number.
.IP "\s-1COLUMN_SIZE \s0(integer)" 4
.IX Item "COLUMN_SIZE (integer)"
For numeric types, this is either the total number of digits (if the
\&\s-1NUM_PREC_RADIX\s0 value is 10) or the total number of bits allowed in the
column (if \s-1NUM_PREC_RADIX\s0 is 2).
.Sp
For string types, this is the maximum size of the string in characters.
.Sp
For date and interval types, this is the maximum number of characters
needed to display the value.
.IP "\s-1LITERAL_PREFIX \s0(string)" 4
.IX Item "LITERAL_PREFIX (string)"
Characters used to prefix a literal. A typical prefix is "\f(CW\*(C`\*(Aq\*(C'\fR\*(L" for characters,
or possibly \*(R"\f(CW\*(C`0x\*(C'\fR" for binary values passed as hexadecimal.  \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) is
returned for data types for which this is not applicable.
.IP "\s-1LITERAL_SUFFIX \s0(string)" 4
.IX Item "LITERAL_SUFFIX (string)"
Characters used to suffix a literal. Typically "\f(CW\*(C`\*(Aq\*(C'\fR" for characters.
\&\s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) is returned for data types where this is not applicable.
.IP "\s-1CREATE_PARAMS \s0(string)" 4
.IX Item "CREATE_PARAMS (string)"
Parameter names for data type definition. For example, \f(CW\*(C`CREATE_PARAMS\*(C'\fR for a
\&\f(CW\*(C`DECIMAL\*(C'\fR would be "\f(CW\*(C`precision,scale\*(C'\fR" if the \s-1DECIMAL\s0 type should be
declared as \f(CW\*(C`DECIMAL(\*(C'\fR\fIprecision,scale\fR\f(CW\*(C`)\*(C'\fR where \fIprecision\fR and \fIscale\fR
are integer values.  For a \f(CW\*(C`VARCHAR\*(C'\fR it would be "\f(CW\*(C`max length\*(C'\fR".
\&\s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) is returned for data types for which this is not applicable.
.IP "\s-1NULLABLE \s0(integer)" 4
.IX Item "NULLABLE (integer)"
Indicates whether the data type accepts a \s-1NULL\s0 value:
\&\f(CW0\fR or an empty string = no, \f(CW1\fR = yes, \f(CW2\fR = unknown.
.IP "\s-1CASE_SENSITIVE \s0(boolean)" 4
.IX Item "CASE_SENSITIVE (boolean)"
Indicates whether the data type is case sensitive in collations and
comparisons.
.IP "\s-1SEARCHABLE \s0(integer)" 4
.IX Item "SEARCHABLE (integer)"
Indicates how the data type can be used in a \s-1WHERE\s0 clause, as
follows:
.Sp
.Vb 4
\&  0 \- Cannot be used in a WHERE clause
\&  1 \- Only with a LIKE predicate
\&  2 \- All comparison operators except LIKE
\&  3 \- Can be used in a WHERE clause with any comparison operator
.Ve
.IP "\s-1UNSIGNED_ATTRIBUTE \s0(boolean)" 4
.IX Item "UNSIGNED_ATTRIBUTE (boolean)"
Indicates whether the data type is unsigned.  \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) is returned
for data types for which this is not applicable.
.IP "\s-1FIXED_PREC_SCALE \s0(boolean)" 4
.IX Item "FIXED_PREC_SCALE (boolean)"
Indicates whether the data type always has the same precision and scale
(such as a money type).  \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) is returned for data types
for which
this is not applicable.
.IP "\s-1AUTO_UNIQUE_VALUE \s0(boolean)" 4
.IX Item "AUTO_UNIQUE_VALUE (boolean)"
Indicates whether a column of this data type is automatically set to a
unique value whenever a new row is inserted.  \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) is returned
for data types for which this is not applicable.
.IP "\s-1LOCAL_TYPE_NAME \s0(string)" 4
.IX Item "LOCAL_TYPE_NAME (string)"
Localized version of the \f(CW\*(C`TYPE_NAME\*(C'\fR for use in dialog with users.
\&\s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) is returned if a localized name is not available (in which
case \f(CW\*(C`TYPE_NAME\*(C'\fR should be used).
.IP "\s-1MINIMUM_SCALE \s0(integer)" 4
.IX Item "MINIMUM_SCALE (integer)"
The minimum scale of the data type. If a data type has a fixed scale,
then \f(CW\*(C`MAXIMUM_SCALE\*(C'\fR holds the same value.  \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) is returned for
data types for which this is not applicable.
.IP "\s-1MAXIMUM_SCALE \s0(integer)" 4
.IX Item "MAXIMUM_SCALE (integer)"
The maximum scale of the data type. If a data type has a fixed scale,
then \f(CW\*(C`MINIMUM_SCALE\*(C'\fR holds the same value.  \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) is returned for
data types for which this is not applicable.
.IP "\s-1SQL_DATA_TYPE \s0(integer)" 4
.IX Item "SQL_DATA_TYPE (integer)"
This column is the same as the \f(CW\*(C`DATA_TYPE\*(C'\fR column, except for interval
and datetime data types.  For interval and datetime data types, the
\&\f(CW\*(C`SQL_DATA_TYPE\*(C'\fR field will return \f(CW\*(C`SQL_INTERVAL\*(C'\fR or \f(CW\*(C`SQL_DATETIME\*(C'\fR, and the
\&\f(CW\*(C`SQL_DATETIME_SUB\*(C'\fR field below will return the subcode for the specific
interval or datetime data type. If this field is \s-1NULL,\s0 then the driver
does not support or report on interval or datetime subtypes.
.IP "\s-1SQL_DATETIME_SUB \s0(integer)" 4
.IX Item "SQL_DATETIME_SUB (integer)"
For interval or datetime data types, where the \f(CW\*(C`SQL_DATA_TYPE\*(C'\fR
field above is \f(CW\*(C`SQL_INTERVAL\*(C'\fR or \f(CW\*(C`SQL_DATETIME\*(C'\fR, this field will
hold the \fIsubcode\fR for the specific interval or datetime data type.
Otherwise it will be \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR).
.Sp
Although not mentioned explicitly in the standards, it seems there
is a simple relationship between these values:
.Sp
.Vb 1
\&  DATA_TYPE == (10 * SQL_DATA_TYPE) + SQL_DATETIME_SUB
.Ve
.IP "\s-1NUM_PREC_RADIX \s0(integer)" 4
.IX Item "NUM_PREC_RADIX (integer)"
The radix value of the data type. For approximate numeric types,
\&\f(CW\*(C`NUM_PREC_RADIX\*(C'\fR
contains the value 2 and \f(CW\*(C`COLUMN_SIZE\*(C'\fR holds the number of bits. For
exact numeric types, \f(CW\*(C`NUM_PREC_RADIX\*(C'\fR contains the value 10 and \f(CW\*(C`COLUMN_SIZE\*(C'\fR holds
the number of decimal digits. \s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) is returned either for data types
for which this is not applicable or if the driver cannot report this information.
.IP "\s-1INTERVAL_PRECISION \s0(integer)" 4
.IX Item "INTERVAL_PRECISION (integer)"
The interval leading precision for interval types. \s-1NULL\s0 is returned
either for data types for which this is not applicable or if the driver
cannot report this information.
.PP
For example, to find the type name for the fields in a select statement
you can do:
.PP
.Vb 1
\&  @names = map { scalar $dbh\->type_info($_)\->{TYPE_NAME} } @{ $sth\->{TYPE} }
.Ve
.PP
Since \s-1DBI\s0 and \s-1ODBC\s0 drivers vary in how they map their types into the
\&\s-1ISO\s0 standard types you may need to search for more than one type.
Here's an example looking for a usable type to store a date:
.PP
.Vb 1
\&  $my_date_type = $dbh\->type_info( [ SQL_DATE, SQL_TIMESTAMP ] );
.Ve
.PP
Similarly, to more reliably find a type to store small integers, you could
use a list starting with \f(CW\*(C`SQL_SMALLINT\*(C'\fR, \f(CW\*(C`SQL_INTEGER\*(C'\fR, \f(CW\*(C`SQL_DECIMAL\*(C'\fR, etc.
.PP
See also \*(L"Standards Reference Information\*(R".
.PP
\fI\f(CI\*(C`quote\*(C'\fI\fR
.IX Subsection "quote"
.PP
.Vb 2
\&  $sql = $dbh\->quote($value);
\&  $sql = $dbh\->quote($value, $data_type);
.Ve
.PP
Quote a string literal for use as a literal value in an \s-1SQL\s0 statement,
by escaping any special characters (such as quotation marks)
contained within the string and adding the required type of outer
quotation marks.
.PP
.Vb 2
\&  $sql = sprintf "SELECT foo FROM bar WHERE baz = %s",
\&                $dbh\->quote("Don\*(Aqt");
.Ve
.PP
For most database types, at least those that conform to \s-1SQL\s0 standards, quote
would return \f(CW\*(AqDon\*(Aq\*(Aqt\*(Aq\fR (including the outer quotation marks). For others it
may return something like \f(CW\*(AqDon\e\*(Aqt\*(Aq\fR
.PP
An undefined \f(CW$value\fR value will be returned as the string \f(CW\*(C`NULL\*(C'\fR (without
single quotation marks) to match how NULLs are represented in \s-1SQL.\s0
.PP
If \f(CW$data_type\fR is supplied, it is used to try to determine the required
quoting behaviour by using the information returned by \*(L"type_info\*(R".
As a special case, the standard numeric types are optimized to return
\&\f(CW$value\fR without calling \f(CW\*(C`type_info\*(C'\fR.
.PP
Quote will probably \fInot\fR be able to deal with all possible input
(such as binary data or data containing newlines), and is not related in
any way with escaping or quoting shell meta-characters.
.PP
It is valid for the \fIquote()\fR method to return an \s-1SQL\s0 expression that
evaluates to the desired string. For example:
.PP
.Vb 1
\&  $quoted = $dbh\->quote("one\entwo\e0three")
.Ve
.PP
may return something like:
.PP
.Vb 1
\&  CONCAT(\*(Aqone\*(Aq, CHAR(12), \*(Aqtwo\*(Aq, CHAR(0), \*(Aqthree\*(Aq)
.Ve
.PP
The \fIquote()\fR method should \fInot\fR be used with \*(L"Placeholders and
Bind Values\*(R".
.PP
\fI\f(CI\*(C`quote_identifier\*(C'\fI\fR
.IX Subsection "quote_identifier"
.PP
.Vb 2
\&  $sql = $dbh\->quote_identifier( $name );
\&  $sql = $dbh\->quote_identifier( $catalog, $schema, $table, \e%attr );
.Ve
.PP
Quote an identifier (table name etc.) for use in an \s-1SQL\s0 statement,
by escaping any special characters (such as double quotation marks)
it contains and adding the required type of outer quotation marks.
.PP
Undefined names are ignored and the remainder are quoted and then
joined together, typically with a dot (\f(CW\*(C`.\*(C'\fR) character. For example:
.PP
.Vb 1
\&  $id = $dbh\->quote_identifier( undef, \*(AqHer schema\*(Aq, \*(AqMy table\*(Aq );
.Ve
.PP
would, for most database types, return \f(CW"Her schema"."My table"\fR
(including all the double quotation marks).
.PP
If three names are supplied then the first is assumed to be a
catalog name and special rules may be applied based on what \*(L"get_info\*(R"
returns for \s-1SQL_CATALOG_NAME_SEPARATOR \s0(41) and \s-1SQL_CATALOG_LOCATION \s0(114).
For example, for Oracle:
.PP
.Vb 1
\&  $id = $dbh\->quote_identifier( \*(Aqlink\*(Aq, \*(Aqschema\*(Aq, \*(Aqtable\*(Aq );
.Ve
.PP
would return \f(CW"schema"."table"@"link"\fR.
.PP
\fI\f(CI\*(C`take_imp_data\*(C'\fI\fR
.IX Subsection "take_imp_data"
.PP
.Vb 1
\&  $imp_data = $dbh\->take_imp_data;
.Ve
.PP
Leaves the \f(CW$dbh\fR in an almost dead, zombie-like, state and returns
a binary string of raw implementation data from the driver which
describes the current database connection. Effectively it detaches
the underlying database \s-1API\s0 connection data from the \s-1DBI\s0 handle.
After calling \fItake_imp_data()\fR, all other methods except \f(CW\*(C`DESTROY\*(C'\fR
will generate a warning and return undef.
.PP
Why would you want to do this? You don't, forget I even mentioned it.
Unless, that is, you're implementing something advanced like a
multi-threaded connection pool. See DBI::Pool.
.PP
The returned \f(CW$imp_data\fR can be passed as a \f(CW\*(C`dbi_imp_data\*(C'\fR attribute
to a later \fIconnect()\fR call, even in a separate thread in the same
process, where the driver can use it to 'adopt' the existing
connection that the implementation data was taken from.
.PP
Some things to keep in mind...
.PP
\&\fB*\fR the \f(CW$imp_data\fR holds the only reference to the underlying
database \s-1API\s0 connection data. That connection is still 'live' and
won't be cleaned up properly unless the \f(CW$imp_data\fR is used to create
a new \f(CW$dbh\fR which is then allowed to \fIdisconnect()\fR normally.
.PP
\&\fB*\fR using the same \f(CW$imp_data\fR to create more than one other new
\&\f(CW$dbh\fR at a time may well lead to unpleasant problems. Don't do that.
.PP
Any child statement handles are effectively destroyed when \fItake_imp_data()\fR is
called.
.PP
The \f(CW\*(C`take_imp_data\*(C'\fR method was added in \s-1DBI 1.36\s0 but wasn't useful till 1.49.
.SS "Database Handle Attributes"
.IX Subsection "Database Handle Attributes"
This section describes attributes specific to database handles.
.PP
Changes to these database handle attributes do not affect any other
existing or future database handles.
.PP
Attempting to set or get the value of an unknown attribute generates a warning,
except for private driver-specific attributes (which all have names
starting with a lowercase letter).
.PP
Example:
.PP
.Vb 2
\&  $h\->{AutoCommit} = ...;       # set/write
\&  ... = $h\->{AutoCommit};       # get/read
.Ve
.PP
\fI\f(CI\*(C`AutoCommit\*(C'\fI\fR
.IX Subsection "AutoCommit"
.PP
Type: boolean
.PP
If true, then database changes cannot be rolled-back (undone).  If false,
then database changes automatically occur within a \*(L"transaction\*(R", which
must either be committed or rolled back using the \f(CW\*(C`commit\*(C'\fR or \f(CW\*(C`rollback\*(C'\fR
methods.
.PP
Drivers should always default to \f(CW\*(C`AutoCommit\*(C'\fR mode (an unfortunate
choice largely forced on the \s-1DBI\s0 by \s-1ODBC\s0 and \s-1JDBC\s0 conventions.)
.PP
Attempting to set \f(CW\*(C`AutoCommit\*(C'\fR to an unsupported value is a fatal error.
This is an important feature of the \s-1DBI.\s0 Applications that need
full transaction behaviour can set \f(CW\*(C`$dbh\->{AutoCommit} = 0\*(C'\fR (or
set \f(CW\*(C`AutoCommit\*(C'\fR to 0 via \*(L"connect\*(R")
without having to check that the value was assigned successfully.
.PP
For the purposes of this description, we can divide databases into three
categories:
.PP
.Vb 3
\&  Databases which don\*(Aqt support transactions at all.
\&  Databases in which a transaction is always active.
\&  Databases in which a transaction must be explicitly started (C<\*(AqBEGIN WORK\*(Aq>).
.Ve
.PP
\&\fB* Databases which don't support transactions at all\fR
.PP
For these databases, attempting to turn \f(CW\*(C`AutoCommit\*(C'\fR off is a fatal error.
\&\f(CW\*(C`commit\*(C'\fR and \f(CW\*(C`rollback\*(C'\fR both issue warnings about being ineffective while
\&\f(CW\*(C`AutoCommit\*(C'\fR is in effect.
.PP
\&\fB* Databases in which a transaction is always active\fR
.PP
These are typically mainstream commercial relational databases with
\&\*(L"\s-1ANSI\s0 standard\*(R" transaction behaviour.
If \f(CW\*(C`AutoCommit\*(C'\fR is off, then changes to the database won't have any
lasting effect unless \*(L"commit\*(R" is called (but see also
\&\*(L"disconnect\*(R"). If \*(L"rollback\*(R" is called then any changes since the
last commit are undone.
.PP
If \f(CW\*(C`AutoCommit\*(C'\fR is on, then the effect is the same as if the \s-1DBI\s0
called \f(CW\*(C`commit\*(C'\fR automatically after every successful database
operation. So calling \f(CW\*(C`commit\*(C'\fR or \f(CW\*(C`rollback\*(C'\fR explicitly while
\&\f(CW\*(C`AutoCommit\*(C'\fR is on would be ineffective because the changes would
have already been committed.
.PP
Changing \f(CW\*(C`AutoCommit\*(C'\fR from off to on will trigger a \*(L"commit\*(R".
.PP
For databases which don't support a specific auto-commit mode, the
driver has to commit each statement automatically using an explicit
\&\f(CW\*(C`COMMIT\*(C'\fR after it completes successfully (and roll it back using an
explicit \f(CW\*(C`ROLLBACK\*(C'\fR if it fails).  The error information reported to the
application will correspond to the statement which was executed, unless
it succeeded and the commit or rollback failed.
.PP
\&\fB* Databases in which a transaction must be explicitly started\fR
.PP
For these databases, the intention is to have them act like databases in
which a transaction is always active (as described above).
.PP
To do this, the driver will automatically begin an explicit transaction
when \f(CW\*(C`AutoCommit\*(C'\fR is turned off, or after a \*(L"commit\*(R" or
\&\*(L"rollback\*(R" (or when the application issues the next database
operation after one of those events).
.PP
In this way, the application does not have to treat these databases
as a special case.
.PP
See \*(L"commit\*(R", \*(L"disconnect\*(R" and \*(L"Transactions\*(R" for other important
notes about transactions.
.PP
\fI\f(CI\*(C`Driver\*(C'\fI\fR
.IX Subsection "Driver"
.PP
Type: handle
.PP
Holds the handle of the parent driver. The only recommended use for this
is to find the name of the driver using:
.PP
.Vb 1
\&  $dbh\->{Driver}\->{Name}
.Ve
.PP
\fI\f(CI\*(C`Name\*(C'\fI\fR
.IX Subsection "Name"
.PP
Type: string
.PP
Holds the \*(L"name\*(R" of the database. Usually (and recommended to be) the
same as the "\f(CW\*(C`dbi:DriverName:...\*(C'\fR\*(L" string used to connect to the database,
but with the leading \*(R"\f(CW\*(C`dbi:DriverName:\*(C'\fR" removed.
.PP
\fI\f(CI\*(C`Statement\*(C'\fI\fR
.IX Subsection "Statement"
.PP
Type: string, read-only
.PP
Returns the statement string passed to the most recent \*(L"prepare\*(R" or
\&\*(L"do\*(R" method called in this database handle, even if that method
failed. This is especially useful where \f(CW\*(C`RaiseError\*(C'\fR is enabled and
the exception handler checks $@ and sees that a 'prepare' method call
failed.
.PP
\fI\f(CI\*(C`RowCacheSize\*(C'\fI\fR
.IX Subsection "RowCacheSize"
.PP
Type: integer
.PP
A hint to the driver indicating the size of the local row cache that the
application would like the driver to use for future \f(CW\*(C`SELECT\*(C'\fR statements.
If a row cache is not implemented, then setting \f(CW\*(C`RowCacheSize\*(C'\fR is ignored
and getting the value returns \f(CW\*(C`undef\*(C'\fR.
.PP
Some \f(CW\*(C`RowCacheSize\*(C'\fR values have special meaning, as follows:
.PP
.Vb 4
\&  0 \- Automatically determine a reasonable cache size for each C<SELECT>
\&  1 \- Disable the local row cache
\& >1 \- Cache this many rows
\& <0 \- Cache as many rows that will fit into this much memory for each C<SELECT>.
.Ve
.PP
Note that large cache sizes may require a very large amount of memory
(\fIcached rows * maximum size of row\fR). Also, a large cache will cause
a longer delay not only for the first fetch, but also whenever the
cache needs refilling.
.PP
See also the \*(L"RowsInCache\*(R" statement handle attribute.
.PP
\fI\f(CI\*(C`Username\*(C'\fI\fR
.IX Subsection "Username"
.PP
Type: string
.PP
Returns the username used to connect to the database.
.SH "DBI STATEMENT HANDLE OBJECTS"
.IX Header "DBI STATEMENT HANDLE OBJECTS"
This section lists the methods and attributes associated with \s-1DBI\s0
statement handles.
.SS "Statement Handle Methods"
.IX Subsection "Statement Handle Methods"
The \s-1DBI\s0 defines the following methods for use on \s-1DBI\s0 statement handles:
.PP
\fI\f(CI\*(C`bind_param\*(C'\fI\fR
.IX Subsection "bind_param"
.PP
.Vb 3
\&  $sth\->bind_param($p_num, $bind_value)
\&  $sth\->bind_param($p_num, $bind_value, \e%attr)
\&  $sth\->bind_param($p_num, $bind_value, $bind_type)
.Ve
.PP
The \f(CW\*(C`bind_param\*(C'\fR method takes a copy of \f(CW$bind_value\fR and associates it
(binds it) with a placeholder, identified by \f(CW$p_num\fR, embedded in
the prepared statement. Placeholders are indicated with question
mark character (\f(CW\*(C`?\*(C'\fR). For example:
.PP
.Vb 5
\&  $dbh\->{RaiseError} = 1;        # save having to check each method call
\&  $sth = $dbh\->prepare("SELECT name, age FROM people WHERE name LIKE ?");
\&  $sth\->bind_param(1, "John%");  # placeholders are numbered from 1
\&  $sth\->execute;
\&  DBI::dump_results($sth);
.Ve
.PP
See \*(L"Placeholders and Bind Values\*(R" for more information.
.PP
\&\fBData Types for Placeholders\fR
.PP
The \f(CW\*(C`\e%attr\*(C'\fR parameter can be used to hint at the data type the
placeholder should have. This is rarely needed. Typically, the driver is only
interested in knowing if the placeholder should be bound as a number or a string.
.PP
.Vb 1
\&  $sth\->bind_param(1, $value, { TYPE => SQL_INTEGER });
.Ve
.PP
As a short-cut for the common case, the data type can be passed
directly, in place of the \f(CW\*(C`\e%attr\*(C'\fR hash reference. This example is
equivalent to the one above:
.PP
.Vb 1
\&  $sth\->bind_param(1, $value, SQL_INTEGER);
.Ve
.PP
The \f(CW\*(C`TYPE\*(C'\fR value indicates the standard (non-driver-specific) type for
this parameter. To specify the driver-specific type, the driver may
support a driver-specific attribute, such as \f(CW\*(C`{ ora_type => 97 }\*(C'\fR.
.PP
The \s-1SQL_INTEGER\s0 and other related constants can be imported using
.PP
.Vb 1
\&  use DBI qw(:sql_types);
.Ve
.PP
See \*(L"\s-1DBI\s0 Constants\*(R" for more information.
.PP
The data type is 'sticky' in that bind values passed to \fIexecute()\fR are bound
with the data type specified by earlier \fIbind_param()\fR calls, if any.
Portable applications should not rely on being able to change the data type
after the first \f(CW\*(C`bind_param\*(C'\fR call.
.PP
Perl only has string and number scalar data types. All database types
that aren't numbers are bound as strings and must be in a format the
database will understand except where the \fIbind_param()\fR \s-1TYPE\s0 attribute
specifies a type that implies a particular format. For example, given:
.PP
.Vb 1
\&  $sth\->bind_param(1, $value, SQL_DATETIME);
.Ve
.PP
the driver should expect \f(CW$value\fR to be in the \s-1ODBC\s0 standard \s-1SQL_DATETIME\s0
format, which is '\s-1YYYY\-MM\-DD HH:MM:SS\s0'. Similarly for \s-1SQL_DATE, SQL_TIME\s0 etc.
.PP
As an alternative to specifying the data type in the \f(CW\*(C`bind_param\*(C'\fR call,
you can let the driver pass the value as the default type (\f(CW\*(C`VARCHAR\*(C'\fR).
You can then use an \s-1SQL\s0 function to convert the type within the statement.
For example:
.PP
.Vb 1
\&  INSERT INTO price(code, price) VALUES (?, CONVERT(MONEY,?))
.Ve
.PP
The \f(CW\*(C`CONVERT\*(C'\fR function used here is just an example. The actual function
and syntax will vary between different databases and is non-portable.
.PP
See also \*(L"Placeholders and Bind Values\*(R" for more information.
.PP
\fI\f(CI\*(C`bind_param_inout\*(C'\fI\fR
.IX Subsection "bind_param_inout"
.PP
.Vb 3
\&  $rc = $sth\->bind_param_inout($p_num, \e$bind_value, $max_len)  or die $sth\->errstr;
\&  $rv = $sth\->bind_param_inout($p_num, \e$bind_value, $max_len, \e%attr)     or ...
\&  $rv = $sth\->bind_param_inout($p_num, \e$bind_value, $max_len, $bind_type) or ...
.Ve
.PP
This method acts like \*(L"bind_param\*(R", but also enables values to be
updated by the statement. The statement is typically
a call to a stored procedure. The \f(CW$bind_value\fR must be passed as a
reference to the actual value to be used.
.PP
Note that unlike \*(L"bind_param\*(R", the \f(CW$bind_value\fR variable is not
copied when \f(CW\*(C`bind_param_inout\*(C'\fR is called. Instead, the value in the
variable is read at the time \*(L"execute\*(R" is called.
.PP
The additional \f(CW$max_len\fR parameter specifies the minimum amount of
memory to allocate to \f(CW$bind_value\fR for the new value. If the value
returned from the database is too
big to fit, then the execution should fail. If unsure what value to use,
pick a generous length, i.e., a length larger than the longest value that would ever be
returned.  The only cost of using a larger value than needed is wasted memory.
.PP
Undefined values or \f(CW\*(C`undef\*(C'\fR are used to indicate null values.
See also \*(L"Placeholders and Bind Values\*(R" for more information.
.PP
\fI\f(CI\*(C`bind_param_array\*(C'\fI\fR
.IX Subsection "bind_param_array"
.PP
.Vb 3
\&  $rc = $sth\->bind_param_array($p_num, $array_ref_or_value)
\&  $rc = $sth\->bind_param_array($p_num, $array_ref_or_value, \e%attr)
\&  $rc = $sth\->bind_param_array($p_num, $array_ref_or_value, $bind_type)
.Ve
.PP
The \f(CW\*(C`bind_param_array\*(C'\fR method is used to bind an array of values
to a placeholder embedded in the prepared statement which is to be executed
with \*(L"execute_array\*(R". For example:
.PP
.Vb 6
\&  $dbh\->{RaiseError} = 1;        # save having to check each method call
\&  $sth = $dbh\->prepare("INSERT INTO staff (first_name, last_name, dept) VALUES(?, ?, ?)");
\&  $sth\->bind_param_array(1, [ \*(AqJohn\*(Aq, \*(AqMary\*(Aq, \*(AqTim\*(Aq ]);
\&  $sth\->bind_param_array(2, [ \*(AqBooth\*(Aq, \*(AqTodd\*(Aq, \*(AqRobinson\*(Aq ]);
\&  $sth\->bind_param_array(3, "SALES"); # scalar will be reused for each row
\&  $sth\->execute_array( { ArrayTupleStatus => \emy @tuple_status } );
.Ve
.PP
The \f(CW%attr\fR ($bind_type) argument is the same as defined for \*(L"bind_param\*(R".
Refer to \*(L"bind_param\*(R" for general details on using placeholders.
.PP
(Note that \fIbind_param_array()\fR can \fInot\fR be used to expand a
placeholder into a list of values for a statement like \*(L"\s-1SELECT\s0 foo
\&\s-1WHERE\s0 bar \s-1IN \s0(?)\*(R".  A placeholder can only ever represent one value
per execution.)
.PP
Scalar values, including \f(CW\*(C`undef\*(C'\fR, may also be bound by
\&\f(CW\*(C`bind_param_array\*(C'\fR. In which case the same value will be used for each
\&\*(L"execute\*(R" call. Driver-specific implementations may behave
differently, e.g., when binding to a stored procedure call, some
databases may permit mixing scalars and arrays as arguments.
.PP
The default implementation provided by \s-1DBI \s0(for drivers that have
not implemented array binding) is to iteratively call \*(L"execute\*(R" for
each parameter tuple provided in the bound arrays.  Drivers may
provide more optimized implementations using whatever bulk operation
support the database \s-1API\s0 provides. The default driver behaviour should
match the default \s-1DBI\s0 behaviour, but always consult your driver
documentation as there may be driver specific issues to consider.
.PP
Note that the default implementation currently only supports non-data
returning statements (\s-1INSERT, UPDATE,\s0 but not \s-1SELECT\s0). Also,
\&\f(CW\*(C`bind_param_array\*(C'\fR and \*(L"bind_param\*(R" cannot be mixed in the same
statement execution, and \f(CW\*(C`bind_param_array\*(C'\fR must be used with
\&\*(L"execute_array\*(R"; using \f(CW\*(C`bind_param_array\*(C'\fR will have no effect
for \*(L"execute\*(R".
.PP
The \f(CW\*(C`bind_param_array\*(C'\fR method was added in \s-1DBI 1.22.\s0
.PP
\fI\f(CI\*(C`execute\*(C'\fI\fR
.IX Subsection "execute"
.PP
.Vb 2
\&  $rv = $sth\->execute                or die $sth\->errstr;
\&  $rv = $sth\->execute(@bind_values)  or die $sth\->errstr;
.Ve
.PP
Perform whatever processing is necessary to execute the prepared
statement.  An \f(CW\*(C`undef\*(C'\fR is returned if an error occurs.  A successful
\&\f(CW\*(C`execute\*(C'\fR always returns true regardless of the number of rows affected,
even if it's zero (see below). It is always important to check the
return status of \f(CW\*(C`execute\*(C'\fR (and most other \s-1DBI\s0 methods) for errors
if you're not using \*(L"RaiseError\*(R".
.PP
For a \fInon\fR\-\f(CW\*(C`SELECT\*(C'\fR statement, \f(CW\*(C`execute\*(C'\fR returns the number of rows
affected, if known. If no rows were affected, then \f(CW\*(C`execute\*(C'\fR returns
"\f(CW0E0\fR", which Perl will treat as 0 but will regard as true. Note that it
is \fInot\fR an error for no rows to be affected by a statement. If the
number of rows affected is not known, then \f(CW\*(C`execute\*(C'\fR returns \-1.
.PP
For \f(CW\*(C`SELECT\*(C'\fR statements, execute simply \*(L"starts\*(R" the query within the
database engine. Use one of the fetch methods to retrieve the data after
calling \f(CW\*(C`execute\*(C'\fR.  The \f(CW\*(C`execute\*(C'\fR method does \fInot\fR return the number of
rows that will be returned by the query (because most databases can't
tell in advance), it simply returns a true value.
.PP
You can tell if the statement was a \f(CW\*(C`SELECT\*(C'\fR statement by checking if
\&\f(CW\*(C`$sth\->{NUM_OF_FIELDS}\*(C'\fR is greater than zero after calling \f(CW\*(C`execute\*(C'\fR.
.PP
If any arguments are given, then \f(CW\*(C`execute\*(C'\fR will effectively call
\&\*(L"bind_param\*(R" for each value before executing the statement.  Values
bound in this way are usually treated as \f(CW\*(C`SQL_VARCHAR\*(C'\fR types unless
the driver can determine the correct type (which is rare), or unless
\&\f(CW\*(C`bind_param\*(C'\fR (or \f(CW\*(C`bind_param_inout\*(C'\fR) has already been used to
specify the type.
.PP
Note that passing \f(CW\*(C`execute\*(C'\fR an empty array is the same as passing no arguments
at all, which will execute the statement with previously bound values.
That's probably not what you want.
.PP
If \fIexecute()\fR is called on a statement handle that's still active
($sth\->{Active} is true) then it should effectively call \fIfinish()\fR
to tidy up the previous execution results before starting this new
execution.
.PP
\fI\f(CI\*(C`execute_array\*(C'\fI\fR
.IX Subsection "execute_array"
.PP
.Vb 2
\&  $tuples = $sth\->execute_array(\e%attr) or die $sth\->errstr;
\&  $tuples = $sth\->execute_array(\e%attr, @bind_values) or die $sth\->errstr;
\&
\&  ($tuples, $rows) = $sth\->execute_array(\e%attr) or die $sth\->errstr;
\&  ($tuples, $rows) = $sth\->execute_array(\e%attr, @bind_values) or die $sth\->errstr;
.Ve
.PP
Execute the prepared statement once for each parameter tuple
(group of values) provided either in the \f(CW@bind_values\fR, or by prior
calls to \*(L"bind_param_array\*(R", or via a reference passed in \e%attr.
.PP
When called in scalar context the \fIexecute_array()\fR method returns the
number of tuples executed, or \f(CW\*(C`undef\*(C'\fR if an error occurred.  Like
\&\fIexecute()\fR, a successful \fIexecute_array()\fR always returns true regardless
of the number of tuples executed, even if it's zero. If there were any
errors the ArrayTupleStatus array can be used to discover which tuples
failed and with what errors.
.PP
When called in list context the \fIexecute_array()\fR method returns two scalars;
\&\f(CW$tuples\fR is the same as calling \fIexecute_array()\fR in scalar context and \f(CW$rows\fR is
the number of rows affected for each tuple, if available or
\&\-1 if the driver cannot determine this. \s-1NOTE,\s0 some drivers cannot determine
the number of rows affected per tuple but can provide the number of rows
affected for the batch.
If you are doing an update operation the returned rows affected may not be what
you expect if, for instance, one or more of the tuples affected the same row
multiple times.  Some drivers may not yet support list context, in which case
\&\f(CW$rows\fR will be undef, or may not be able to provide the number of rows affected
when performing this batch operation, in which case \f(CW$rows\fR will be \-1.
.PP
Bind values for the tuples to be executed may be supplied row-wise
by an \f(CW\*(C`ArrayTupleFetch\*(C'\fR attribute, or else column-wise in the
\&\f(CW@bind_values\fR argument, or else column-wise by prior calls to
\&\*(L"bind_param_array\*(R".
.PP
Where column-wise binding is used (via the \f(CW@bind_values\fR argument
or calls to \fIbind_param_array()\fR) the maximum number of elements in
any one of the bound value arrays determines the number of tuples
executed. Placeholders with fewer values in their parameter arrays
are treated as if padded with undef (\s-1NULL\s0) values.
.PP
If a scalar value is bound, instead of an array reference, it is
treated as a \fIvariable\fR length array with all elements having the
same value. It does not influence the number of tuples executed,
so if all bound arrays have zero elements then zero tuples will
be executed. If \fIall\fR bound values are scalars then one tuple
will be executed, making \fIexecute_array()\fR act just like \fIexecute()\fR.
.PP
The \f(CW\*(C`ArrayTupleFetch\*(C'\fR attribute can be used to specify a reference
to a subroutine that will be called to provide the bind values for
each tuple execution. The subroutine should return an reference to
an array which contains the appropriate number of bind values, or
return an undef if there is no more data to execute.
.PP
As a convenience, the \f(CW\*(C`ArrayTupleFetch\*(C'\fR attribute can also be
used to specify a statement handle. In which case the \fIfetchrow_arrayref()\fR
method will be called on the given statement handle in order to
provide the bind values for each tuple execution.
.PP
The values specified via \fIbind_param_array()\fR or the \f(CW@bind_values\fR
parameter may be either scalars, or arrayrefs.  If any \f(CW@bind_values\fR
are given, then \f(CW\*(C`execute_array\*(C'\fR will effectively call \*(L"bind_param_array\*(R"
for each value before executing the statement.  Values bound in
this way are usually treated as \f(CW\*(C`SQL_VARCHAR\*(C'\fR types unless the
driver can determine the correct type (which is rare), or unless
\&\f(CW\*(C`bind_param\*(C'\fR, \f(CW\*(C`bind_param_inout\*(C'\fR, \f(CW\*(C`bind_param_array\*(C'\fR, or
\&\f(CW\*(C`bind_param_inout_array\*(C'\fR has already been used to specify the type.
See \*(L"bind_param_array\*(R" for details.
.PP
The \f(CW\*(C`ArrayTupleStatus\*(C'\fR attribute can be used to specify a
reference to an array which will receive the execute status of each
executed parameter tuple. Note the \f(CW\*(C`ArrayTupleStatus\*(C'\fR attribute was
mandatory until \s-1DBI 1.38.\s0
.PP
For tuples which are successfully executed, the element at the same
ordinal position in the status array is the resulting rowcount (or \-1
if unknown).
If the execution of a tuple causes an error, then the corresponding
status array element will be set to a reference to an array containing
\&\*(L"err\*(R", \*(L"errstr\*(R" and \*(L"state\*(R" set by the failed execution.
.PP
If \fBany\fR tuple execution returns an error, \f(CW\*(C`execute_array\*(C'\fR will
return \f(CW\*(C`undef\*(C'\fR. In that case, the application should inspect the
status array to determine which parameter tuples failed.
Some databases may not continue executing tuples beyond the first
failure. In this case the status array will either hold fewer
elements, or the elements beyond the failure will be undef.
.PP
If all parameter tuples are successfully executed, \f(CW\*(C`execute_array\*(C'\fR
returns the number tuples executed.  If no tuples were executed,
then \fIexecute_array()\fR returns "\f(CW0E0\fR", just like \fIexecute()\fR does,
which Perl will treat as 0 but will regard as true.
.PP
For example:
.PP
.Vb 10
\&  $sth = $dbh\->prepare("INSERT INTO staff (first_name, last_name) VALUES (?, ?)");
\&  my $tuples = $sth\->execute_array(
\&      { ArrayTupleStatus => \emy @tuple_status },
\&      \e@first_names,
\&      \e@last_names,
\&  );
\&  if ($tuples) {
\&      print "Successfully inserted $tuples records\en";
\&  }
\&  else {
\&      for my $tuple (0..@last_names\-1) {
\&          my $status = $tuple_status[$tuple];
\&          $status = [0, "Skipped"] unless defined $status;
\&          next unless ref $status;
\&          printf "Failed to insert (%s, %s): %s\en",
\&              $first_names[$tuple], $last_names[$tuple], $status\->[1];
\&      }
\&  }
.Ve
.PP
Support for data returning statements such as \s-1SELECT\s0 is driver-specific
and subject to change. At present, the default implementation
provided by \s-1DBI\s0 only supports non-data returning statements.
.PP
Transaction semantics when using array binding are driver and
database specific.  If \f(CW\*(C`AutoCommit\*(C'\fR is on, the default \s-1DBI\s0
implementation will cause each parameter tuple to be individually
committed (or rolled back in the event of an error). If \f(CW\*(C`AutoCommit\*(C'\fR
is off, the application is responsible for explicitly committing
the entire set of bound parameter tuples.  Note that different
drivers and databases may have different behaviours when some
parameter tuples cause failures. In some cases, the driver or
database may automatically rollback the effect of all prior parameter
tuples that succeeded in the transaction; other drivers or databases
may retain the effect of prior successfully executed parameter
tuples. Be sure to check your driver and database for its specific
behaviour.
.PP
Note that, in general, performance will usually be better with
\&\f(CW\*(C`AutoCommit\*(C'\fR turned off, and using explicit \f(CW\*(C`commit\*(C'\fR after each
\&\f(CW\*(C`execute_array\*(C'\fR call.
.PP
The \f(CW\*(C`execute_array\*(C'\fR method was added in \s-1DBI 1.22,\s0 and ArrayTupleFetch
was added in 1.36.
.PP
\fI\f(CI\*(C`execute_for_fetch\*(C'\fI\fR
.IX Subsection "execute_for_fetch"
.PP
.Vb 2
\&  $tuples = $sth\->execute_for_fetch($fetch_tuple_sub);
\&  $tuples = $sth\->execute_for_fetch($fetch_tuple_sub, \e@tuple_status);
\&
\&  ($tuples, $rows) = $sth\->execute_for_fetch($fetch_tuple_sub);
\&  ($tuples, $rows) = $sth\->execute_for_fetch($fetch_tuple_sub, \e@tuple_status);
.Ve
.PP
The \fIexecute_for_fetch()\fR method is used to perform bulk operations and
although it is most often used via the \fIexecute_array()\fR method you can
use it directly. The main difference between execute_array and
execute_for_fetch is the former does column or row-wise binding and
the latter uses row-wise binding.
.PP
The fetch subroutine, referenced by \f(CW$fetch_tuple_sub\fR, is expected
to return a reference to an array (known as a 'tuple') or undef.
.PP
The \fIexecute_for_fetch()\fR method calls \f(CW$fetch_tuple_sub\fR, without any
parameters, until it returns a false value. Each tuple returned is
used to provide bind values for an \f(CW$sth\fR\->execute(@$tuple) call.
.PP
In scalar context \fIexecute_for_fetch()\fR returns \f(CW\*(C`undef\*(C'\fR if there were any
errors and the number of tuples executed otherwise. Like \fIexecute()\fR and
\&\fIexecute_array()\fR a zero is returned as \*(L"0E0\*(R" so \fIexecute_for_fetch()\fR is
only false on error.  If there were any errors the \f(CW@tuple_status\fR array
can be used to discover which tuples failed and with what errors.
.PP
When called in list context \fIexecute_for_fetch()\fR returns two scalars;
\&\f(CW$tuples\fR is the same as calling \fIexecute_for_fetch()\fR in scalar context and \f(CW$rows\fR is
the sum of the number of rows affected for each tuple, if available or \-1
if the driver cannot determine this.
If you are doing an update operation the returned rows affected may not be what
you expect if, for instance, one or more of the tuples affected the same row
multiple times.  Some drivers may not yet support list context, in which case
\&\f(CW$rows\fR will be undef, or may not be able to provide the number of rows affected
when performing this batch operation, in which case \f(CW$rows\fR will be \-1.
.PP
If \e@tuple_status is passed then the execute_for_fetch method uses
it to return status information. The tuple_status array holds one
element per tuple. If the corresponding \fIexecute()\fR did not fail then
the element holds the return value from \fIexecute()\fR, which is typically
a row count. If the \fIexecute()\fR did fail then the element holds a
reference to an array containing ($sth\->err, \f(CW$sth\fR\->errstr, \f(CW$sth\fR\->state).
.PP
If the driver detects an error that it knows means no further tuples can be
executed then it may return, with an error status, even though \f(CW$fetch_tuple_sub\fR
may still have more tuples to be executed.
.PP
Although each tuple returned by \f(CW$fetch_tuple_sub\fR is effectively used
to call \f(CW$sth\fR\->execute(@$tuple_array_ref) the exact timing may vary.
Drivers are free to accumulate sets of tuples to pass to the
database server in bulk group operations for more efficient execution.
However, the \f(CW$fetch_tuple_sub\fR is specifically allowed to return
the same array reference each time (which is what \fIfetchrow_arrayref()\fR
usually does).
.PP
For example:
.PP
.Vb 2
\&  my $sel = $dbh1\->prepare("select foo, bar from table1");
\&  $sel\->execute;
\&
\&  my $ins = $dbh2\->prepare("insert into table2 (foo, bar) values (?,?)");
\&  my $fetch_tuple_sub = sub { $sel\->fetchrow_arrayref };
\&
\&  my @tuple_status;
\&  $rc = $ins\->execute_for_fetch($fetch_tuple_sub, \e@tuple_status);
\&  my @errors = grep { ref $_ } @tuple_status;
.Ve
.PP
Similarly, if you already have an array containing the data rows
to be processed you'd use a subroutine to shift off and return
each array ref in turn:
.PP
.Vb 1
\&  $ins\->execute_for_fetch( sub { shift @array_of_arrays }, \e@tuple_status);
.Ve
.PP
The \f(CW\*(C`execute_for_fetch\*(C'\fR method was added in \s-1DBI 1.38.\s0
.PP
\fI\f(CI\*(C`fetchrow_arrayref\*(C'\fI\fR
.IX Subsection "fetchrow_arrayref"
.PP
.Vb 2
\&  $ary_ref = $sth\->fetchrow_arrayref;
\&  $ary_ref = $sth\->fetch;    # alias
.Ve
.PP
Fetches the next row of data and returns a reference to an array
holding the field values.  Null fields are returned as \f(CW\*(C`undef\*(C'\fR
values in the array.
This is the fastest way to fetch data, particularly if used with
\&\f(CW\*(C`$sth\->bind_columns\*(C'\fR.
.PP
If there are no more rows or if an error occurs, then \f(CW\*(C`fetchrow_arrayref\*(C'\fR
returns an \f(CW\*(C`undef\*(C'\fR. You should check \f(CW\*(C`$sth\->err\*(C'\fR afterwards (or use the
\&\f(CW\*(C`RaiseError\*(C'\fR attribute) to discover if the \f(CW\*(C`undef\*(C'\fR returned was due to an
error.
.PP
Note that the same array reference is returned for each fetch, so don't
store the reference and then use it after a later fetch.  Also, the
elements of the array are also reused for each row, so take care if you
want to take a reference to an element. See also \*(L"bind_columns\*(R".
.PP
\fI\f(CI\*(C`fetchrow_array\*(C'\fI\fR
.IX Subsection "fetchrow_array"
.PP
.Vb 1
\& @ary = $sth\->fetchrow_array;
.Ve
.PP
An alternative to \f(CW\*(C`fetchrow_arrayref\*(C'\fR. Fetches the next row of data
and returns it as a list containing the field values.  Null fields
are returned as \f(CW\*(C`undef\*(C'\fR values in the list.
.PP
If there are no more rows or if an error occurs, then \f(CW\*(C`fetchrow_array\*(C'\fR
returns an empty list. You should check \f(CW\*(C`$sth\->err\*(C'\fR afterwards (or use
the \f(CW\*(C`RaiseError\*(C'\fR attribute) to discover if the empty list returned was
due to an error.
.PP
If called in a scalar context for a statement handle that has more
than one column, it is undefined whether the driver will return
the value of the first column or the last. So don't do that.
Also, in a scalar context, an \f(CW\*(C`undef\*(C'\fR is returned if there are no
more rows or if an error occurred. That \f(CW\*(C`undef\*(C'\fR can't be distinguished
from an \f(CW\*(C`undef\*(C'\fR returned because the first field value was \s-1NULL.\s0
For these reasons you should exercise some caution if you use
\&\f(CW\*(C`fetchrow_array\*(C'\fR in a scalar context.
.PP
\fI\f(CI\*(C`fetchrow_hashref\*(C'\fI\fR
.IX Subsection "fetchrow_hashref"
.PP
.Vb 2
\& $hash_ref = $sth\->fetchrow_hashref;
\& $hash_ref = $sth\->fetchrow_hashref($name);
.Ve
.PP
An alternative to \f(CW\*(C`fetchrow_arrayref\*(C'\fR. Fetches the next row of data
and returns it as a reference to a hash containing field name and field
value pairs.  Null fields are returned as \f(CW\*(C`undef\*(C'\fR values in the hash.
.PP
If there are no more rows or if an error occurs, then \f(CW\*(C`fetchrow_hashref\*(C'\fR
returns an \f(CW\*(C`undef\*(C'\fR. You should check \f(CW\*(C`$sth\->err\*(C'\fR afterwards (or use the
\&\f(CW\*(C`RaiseError\*(C'\fR attribute) to discover if the \f(CW\*(C`undef\*(C'\fR returned was due to an
error.
.PP
The optional \f(CW$name\fR parameter specifies the name of the statement handle
attribute. For historical reasons it defaults to "\f(CW\*(C`NAME\*(C'\fR\*(L", however using
either \*(R"\f(CW\*(C`NAME_lc\*(C'\fR\*(L" or \*(R"\f(CW\*(C`NAME_uc\*(C'\fR" is recommended for portability.
.PP
The keys of the hash are the same names returned by \f(CW\*(C`$sth\->{$name}\*(C'\fR. If
more than one field has the same name, there will only be one entry in the
returned hash for those fields, so statements like "\f(CW\*(C`select foo, foo from bar\*(C'\fR"
will return only a single key from \f(CW\*(C`fetchrow_hashref\*(C'\fR. In these cases use
column aliases or \f(CW\*(C`fetchrow_arrayref\*(C'\fR.  Note that it is the database server
(and not the \s-1DBD\s0 implementation) which provides the \fIname\fR for fields
containing functions like "\f(CWcount(*)\fR\*(L" or \*(R"\f(CW\*(C`max(c_foo)\*(C'\fR" and they may clash
with existing column names (most databases don't care about duplicate column
names in a result-set). If you want these to return as unique names that are
the same across databases, use \fIaliases\fR, as in "\f(CW\*(C`select count(*) as cnt\*(C'\fR\*(L"
or \*(R"\f(CW\*(C`select max(c_foo) mx_foo, ...\*(C'\fR" depending on the syntax your database
supports.
.PP
Because of the extra work \f(CW\*(C`fetchrow_hashref\*(C'\fR and Perl have to perform, it
is not as efficient as \f(CW\*(C`fetchrow_arrayref\*(C'\fR or \f(CW\*(C`fetchrow_array\*(C'\fR.
.PP
By default a reference to a new hash is returned for each row.
It is likely that a future version of the \s-1DBI\s0 will support an
attribute which will enable the same hash to be reused for each
row. This will give a significant performance boost, but it won't
be enabled by default because of the risk of breaking old code.
.PP
\fI\f(CI\*(C`fetchall_arrayref\*(C'\fI\fR
.IX Subsection "fetchall_arrayref"
.PP
.Vb 3
\&  $tbl_ary_ref = $sth\->fetchall_arrayref;
\&  $tbl_ary_ref = $sth\->fetchall_arrayref( $slice );
\&  $tbl_ary_ref = $sth\->fetchall_arrayref( $slice, $max_rows  );
.Ve
.PP
The \f(CW\*(C`fetchall_arrayref\*(C'\fR method can be used to fetch all the data to be
returned from a prepared and executed statement handle. It returns a
reference to an array that contains one reference per row.
.PP
If called on an \fIinactive\fR statement handle, \f(CW\*(C`fetchall_arrayref\*(C'\fR returns undef.
.PP
If there are no rows left to return from an \fIactive\fR statement handle, \f(CW\*(C`fetchall_arrayref\*(C'\fR returns a reference
to an empty array. If an error occurs, \f(CW\*(C`fetchall_arrayref\*(C'\fR returns the
data fetched thus far, which may be none.  You should check \f(CW\*(C`$sth\->err\*(C'\fR
afterwards (or use the \f(CW\*(C`RaiseError\*(C'\fR attribute) to discover if the data is
complete or was truncated due to an error.
.PP
If \f(CW$slice\fR is an array reference, \f(CW\*(C`fetchall_arrayref\*(C'\fR uses \*(L"fetchrow_arrayref\*(R"
to fetch each row as an array ref. If the \f(CW$slice\fR array is not empty
then it is used as a slice to select individual columns by perl array
index number (starting at 0, unlike column and parameter numbers which
start at 1).
.PP
With no parameters, or if \f(CW$slice\fR is undefined, \f(CW\*(C`fetchall_arrayref\*(C'\fR
acts as if passed an empty array ref.
.PP
For example, to fetch just the first column of every row:
.PP
.Vb 1
\&  $tbl_ary_ref = $sth\->fetchall_arrayref([0]);
.Ve
.PP
To fetch the second to last and last column of every row:
.PP
.Vb 1
\&  $tbl_ary_ref = $sth\->fetchall_arrayref([\-2,\-1]);
.Ve
.PP
Those two examples both return a reference to an array of array refs.
.PP
If \f(CW$slice\fR is a hash reference, \f(CW\*(C`fetchall_arrayref\*(C'\fR fetches each row as a hash
reference. If the \f(CW$slice\fR hash is empty then the keys in the hashes have
whatever name lettercase is returned by default. (See \*(L"FetchHashKeyName\*(R"
attribute.) If the \f(CW$slice\fR hash is \fInot\fR empty, then it is used as a slice to
select individual columns by name. The values of the hash should be set to 1.
The key names of the returned hashes match the letter case of the names in the
parameter hash, regardless of the \*(L"FetchHashKeyName\*(R" attribute.
.PP
For example, to fetch all fields of every row as a hash ref:
.PP
.Vb 1
\&  $tbl_ary_ref = $sth\->fetchall_arrayref({});
.Ve
.PP
To fetch only the fields called \*(L"foo\*(R" and \*(L"bar\*(R" of every row as a hash ref
(with keys named \*(L"foo\*(R" and \*(L"\s-1BAR\*(R",\s0 regardless of the original capitalization):
.PP
.Vb 1
\&  $tbl_ary_ref = $sth\->fetchall_arrayref({ foo=>1, BAR=>1 });
.Ve
.PP
Those two examples both return a reference to an array of hash refs.
.PP
If \f(CW$slice\fR is a \fIreference to a hash reference\fR, that hash is used to select
and rename columns. The keys are 0\-based column index numbers and the values
are the corresponding keys for the returned row hashes.
.PP
For example, to fetch only the first and second columns of every row as a hash
ref (with keys named \*(L"k\*(R" and \*(L"v\*(R" regardless of their original names):
.PP
.Vb 1
\&  $tbl_ary_ref = $sth\->fetchall_arrayref( \e{ 0 => \*(Aqk\*(Aq, 1 => \*(Aqv\*(Aq } );
.Ve
.PP
If \f(CW$max_rows\fR is defined and greater than or equal to zero then it
is used to limit the number of rows fetched before returning.
\&\fIfetchall_arrayref()\fR can then be called again to fetch more rows.
This is especially useful when you need the better performance of
\&\fIfetchall_arrayref()\fR but don't have enough memory to fetch and return
all the rows in one go.
.PP
Here's an example (assumes RaiseError is enabled):
.PP
.Vb 6
\&  my $rows = []; # cache for batches of rows
\&  while( my $row = ( shift(@$rows) || # get row from cache, or reload cache:
\&                     shift(@{$rows=$sth\->fetchall_arrayref(undef,10_000)||[]}) )
\&  ) {
\&    ...
\&  }
.Ve
.PP
That \fImight\fR be the fastest way to fetch and process lots of rows using the \s-1DBI,\s0
but it depends on the relative cost of method calls vs memory allocation.
.PP
A standard \f(CW\*(C`while\*(C'\fR loop with column binding is often faster because
the cost of allocating memory for the batch of rows is greater than
the saving by reducing method calls. It's possible that the \s-1DBI\s0 may
provide a way to reuse the memory of a previous batch in future, which
would then shift the balance back towards \fIfetchall_arrayref()\fR.
.PP
\fI\f(CI\*(C`fetchall_hashref\*(C'\fI\fR
.IX Subsection "fetchall_hashref"
.PP
.Vb 1
\&  $hash_ref = $sth\->fetchall_hashref($key_field);
.Ve
.PP
The \f(CW\*(C`fetchall_hashref\*(C'\fR method can be used to fetch all the data to be
returned from a prepared and executed statement handle. It returns a reference
to a hash containing a key for each distinct value of the \f(CW$key_field\fR column
that was fetched. For each key the corresponding value is a reference to a hash
containing all the selected columns and their values, as returned by
\&\f(CW\*(C`fetchrow_hashref()\*(C'\fR.
.PP
If there are no rows to return, \f(CW\*(C`fetchall_hashref\*(C'\fR returns a reference
to an empty hash. If an error occurs, \f(CW\*(C`fetchall_hashref\*(C'\fR returns the
data fetched thus far, which may be none.  You should check
\&\f(CW\*(C`$sth\->err\*(C'\fR afterwards (or use the \f(CW\*(C`RaiseError\*(C'\fR attribute) to
discover if the data is complete or was truncated due to an error.
.PP
The \f(CW$key_field\fR parameter provides the name of the field that holds the
value to be used for the key for the returned hash.  For example:
.PP
.Vb 5
\&  $dbh\->{FetchHashKeyName} = \*(AqNAME_lc\*(Aq;
\&  $sth = $dbh\->prepare("SELECT FOO, BAR, ID, NAME, BAZ FROM TABLE");
\&  $sth\->execute;
\&  $hash_ref = $sth\->fetchall_hashref(\*(Aqid\*(Aq);
\&  print "Name for id 42 is $hash_ref\->{42}\->{name}\en";
.Ve
.PP
The \f(CW$key_field\fR parameter can also be specified as an integer column
number (counting from 1).  If \f(CW$key_field\fR doesn't match any column in
the statement, as a name first then as a number, then an error is
returned.
.PP
For queries returning more than one 'key' column, you can specify
multiple column names by passing \f(CW$key_field\fR as a reference to an
array containing one or more key column names (or index numbers).
For example:
.PP
.Vb 4
\&  $sth = $dbh\->prepare("SELECT foo, bar, baz FROM table");
\&  $sth\->execute;
\&  $hash_ref = $sth\->fetchall_hashref( [ qw(foo bar) ] );
\&  print "For foo 42 and bar 38, baz is $hash_ref\->{42}\->{38}\->{baz}\en";
.Ve
.PP
The \fIfetchall_hashref()\fR method is normally used only where the key
fields values for each row are unique.  If multiple rows are returned
with the same values for the key fields then later rows overwrite
earlier ones.
.PP
\fI\f(CI\*(C`finish\*(C'\fI\fR
.IX Subsection "finish"
.PP
.Vb 1
\&  $rc  = $sth\->finish;
.Ve
.PP
Indicate that no more data will be fetched from this statement handle
before it is either executed again or destroyed.  You almost certainly
do \fInot\fR need to call this method.
.PP
Adding calls to \f(CW\*(C`finish\*(C'\fR after loop that fetches all rows is a common mistake,
don't do it, it can mask genuine problems like uncaught fetch errors.
.PP
When all the data has been fetched from a \f(CW\*(C`SELECT\*(C'\fR statement, the driver will
automatically call \f(CW\*(C`finish\*(C'\fR for you. So you should \fInot\fR call it explicitly
\&\fIexcept\fR when you know that you've not fetched all the data from a statement
handle \fIand\fR the handle won't be destroyed soon.
.PP
The most common example is when you only want to fetch just one row,
but in that case the \f(CW\*(C`selectrow_*\*(C'\fR methods are usually better anyway.
.PP
Consider a query like:
.PP
.Vb 1
\&  SELECT foo FROM table WHERE bar=? ORDER BY baz
.Ve
.PP
on a very large table. When executed, the database server will have to use
temporary buffer space to store the sorted rows. If, after executing
the handle and selecting just a few rows, the handle won't be re-executed for
some time and won't be destroyed, the \f(CW\*(C`finish\*(C'\fR method can be used to tell
the server that the buffer space can be freed.
.PP
Calling \f(CW\*(C`finish\*(C'\fR resets the \*(L"Active\*(R" attribute for the statement.  It
may also make some statement handle attributes (such as \f(CW\*(C`NAME\*(C'\fR and \f(CW\*(C`TYPE\*(C'\fR)
unavailable if they have not already been accessed (and thus cached).
.PP
The \f(CW\*(C`finish\*(C'\fR method does not affect the transaction status of the
database connection.  It has nothing to do with transactions. It's mostly an
internal \*(L"housekeeping\*(R" method that is rarely needed.
See also \*(L"disconnect\*(R" and the \*(L"Active\*(R" attribute.
.PP
The \f(CW\*(C`finish\*(C'\fR method should have been called \f(CW\*(C`discard_pending_rows\*(C'\fR.
.PP
\fI\f(CI\*(C`rows\*(C'\fI\fR
.IX Subsection "rows"
.PP
.Vb 1
\&  $rv = $sth\->rows;
.Ve
.PP
Returns the number of rows affected by the last row affecting command,
or \-1 if the number of rows is not known or not available.
.PP
Generally, you can only rely on a row count after a \fInon\fR\-\f(CW\*(C`SELECT\*(C'\fR
\&\f(CW\*(C`execute\*(C'\fR (for some specific operations like \f(CW\*(C`UPDATE\*(C'\fR and \f(CW\*(C`DELETE\*(C'\fR), or
after fetching all the rows of a \f(CW\*(C`SELECT\*(C'\fR statement.
.PP
For \f(CW\*(C`SELECT\*(C'\fR statements, it is generally not possible to know how many
rows will be returned except by fetching them all.  Some drivers will
return the number of rows the application has fetched so far, but
others may return \-1 until all rows have been fetched.  So use of the
\&\f(CW\*(C`rows\*(C'\fR method or \f(CW$DBI::rows\fR with \f(CW\*(C`SELECT\*(C'\fR statements is not
recommended.
.PP
One alternative method to get a row count for a \f(CW\*(C`SELECT\*(C'\fR is to execute a
\&\*(L"\s-1SELECT COUNT\s0(*) \s-1FROM ...\*(R" SQL\s0 statement with the same \*(L"...\*(R" as your
query and then fetch the row count from that.
.PP
\fI\f(CI\*(C`bind_col\*(C'\fI\fR
.IX Subsection "bind_col"
.PP
.Vb 3
\&  $rc = $sth\->bind_col($column_number, \e$var_to_bind);
\&  $rc = $sth\->bind_col($column_number, \e$var_to_bind, \e%attr );
\&  $rc = $sth\->bind_col($column_number, \e$var_to_bind, $bind_type );
.Ve
.PP
Binds a Perl variable and/or some attributes to an output column
(field) of a \f(CW\*(C`SELECT\*(C'\fR statement.  Column numbers count up from 1.
You do not need to bind output columns in order to fetch data.
For maximum portability between drivers, \fIbind_col()\fR should be called
after \fIexecute()\fR and not before.
See also \*(L"bind_columns\*(R" for an example.
.PP
The binding is performed at a low level using Perl aliasing.
Whenever a row is fetched from the database \f(CW$var_to_bind\fR appears
to be automatically updated simply because it now refers to the same
memory location as the corresponding column value.  This makes using
bound variables very efficient.
Binding a tied variable doesn't work, currently.
.PP
The \*(L"bind_param\*(R" method
performs a similar, but opposite, function for input variables.
.PP
\&\fBData Types for Column Binding\fR
.PP
The \f(CW\*(C`\e%attr\*(C'\fR parameter can be used to hint at the data type
formatting the column should have. For example, you can use:
.PP
.Vb 1
\&  $sth\->bind_col(1, undef, { TYPE => SQL_DATETIME });
.Ve
.PP
to specify that you'd like the column (which presumably is some
kind of datetime type) to be returned in the standard format for
\&\s-1SQL_DATETIME,\s0 which is '\s-1YYYY\-MM\-DD HH:MM:SS\s0', rather than the
native formatting the database would normally use.
.PP
There's no \f(CW$var_to_bind\fR in that example to emphasize the point
that \fIbind_col()\fR works on the underlying column and not just
a particular bound variable.
.PP
As a short-cut for the common case, the data type can be passed
directly, in place of the \f(CW\*(C`\e%attr\*(C'\fR hash reference. This example is
equivalent to the one above:
.PP
.Vb 1
\&  $sth\->bind_col(1, undef, SQL_DATETIME);
.Ve
.PP
The \f(CW\*(C`TYPE\*(C'\fR value indicates the standard (non-driver-specific) type for
this parameter. To specify the driver-specific type, the driver may
support a driver-specific attribute, such as \f(CW\*(C`{ ora_type => 97 }\*(C'\fR.
.PP
The \s-1SQL_DATETIME\s0 and other related constants can be imported using
.PP
.Vb 1
\&  use DBI qw(:sql_types);
.Ve
.PP
See \*(L"\s-1DBI\s0 Constants\*(R" for more information.
.PP
Few drivers support specifying a data type via a \f(CW\*(C`bind_col\*(C'\fR call
(most will simply ignore the data type). Fewer still allow the data
type to be altered once set. If you do set a column type the type
should remain sticky through further calls to bind_col for the same
column if the type is not overridden (this is important for instance
when you are using a slice in fetchall_arrayref).
.PP
The \s-1TYPE\s0 attribute for \fIbind_col()\fR was first specified in \s-1DBI 1.41.\s0
.PP
From \s-1DBI 1.611,\s0 drivers can use the \f(CW\*(C`TYPE\*(C'\fR attribute to attempt to
cast the bound scalar to a perl type which more closely matches
\&\f(CW\*(C`TYPE\*(C'\fR. At present \s-1DBI\s0 supports \f(CW\*(C`SQL_INTEGER\*(C'\fR, \f(CW\*(C`SQL_DOUBLE\*(C'\fR and
\&\f(CW\*(C`SQL_NUMERIC\*(C'\fR. See \*(L"sql_type_cast\*(R" for details of how types are
cast.
.PP
\&\fBOther attributes for Column Binding\fR
.PP
The \f(CW\*(C`\e%attr\*(C'\fR parameter may also contain the following attributes:
.ie n .IP """StrictlyTyped""" 4
.el .IP "\f(CWStrictlyTyped\fR" 4
.IX Item "StrictlyTyped"
If a \f(CW\*(C`TYPE\*(C'\fR attribute is passed to bind_col, then the driver will
attempt to change the bound perl scalar to match the type more
closely. If the bound value cannot be cast to the requested \f(CW\*(C`TYPE\*(C'\fR
then by default it is left untouched and no error is generated. If you
specify \f(CW\*(C`StrictlyTyped\*(C'\fR as 1 and the cast fails, this will generate
an error.
.Sp
This attribute was first added in \s-1DBI 1.611.\s0 When 1.611 was released
few drivers actually supported this attribute but DBD::Oracle and
\&\s-1DBD::ODBC\s0 should from versions 1.24.
.ie n .IP """DiscardString""" 4
.el .IP "\f(CWDiscardString\fR" 4
.IX Item "DiscardString"
When the \f(CW\*(C`TYPE\*(C'\fR attribute is passed to \*(L"bind_col\*(R" and the driver
successfully casts the bound perl scalar to a non-string type
then if \f(CW\*(C`DiscardString\*(C'\fR is set to 1, the string portion of the
scalar will be discarded. By default, \f(CW\*(C`DiscardString\*(C'\fR is not set.
.Sp
This attribute was first added in \s-1DBI 1.611.\s0 When 1.611 was released
few drivers actually supported this attribute but DBD::Oracle and
\&\s-1DBD::ODBC\s0 should from versions 1.24.
.PP
\fI\f(CI\*(C`bind_columns\*(C'\fI\fR
.IX Subsection "bind_columns"
.PP
.Vb 1
\&  $rc = $sth\->bind_columns(@list_of_refs_to_vars_to_bind);
.Ve
.PP
Calls \*(L"bind_col\*(R" for each column of the \f(CW\*(C`SELECT\*(C'\fR statement.
.PP
The list of references should have the same number of elements as the number of
columns in the \f(CW\*(C`SELECT\*(C'\fR statement. If it doesn't then \f(CW\*(C`bind_columns\*(C'\fR will
bind the elements given, up to the number of columns, and then return an error.
.PP
For maximum portability between drivers, \fIbind_columns()\fR should be called
after \fIexecute()\fR and not before.
.PP
For example:
.PP
.Vb 4
\&  $dbh\->{RaiseError} = 1; # do this, or check every call for errors
\&  $sth = $dbh\->prepare(q{ SELECT region, sales FROM sales_by_region });
\&  $sth\->execute;
\&  my ($region, $sales);
\&
\&  # Bind Perl variables to columns:
\&  $rv = $sth\->bind_columns(\e$region, \e$sales);
\&
\&  # you can also use Perl\*(Aqs \e(...) syntax (see perlref docs):
\&  #     $sth\->bind_columns(\e($region, $sales));
\&
\&  # Column binding is the most efficient way to fetch data
\&  while ($sth\->fetch) {
\&      print "$region: $sales\en";
\&  }
.Ve
.PP
For compatibility with old scripts, the first parameter will be
ignored if it is \f(CW\*(C`undef\*(C'\fR or a hash reference.
.PP
Here's a more fancy example that binds columns to the values \fIinside\fR
a hash (thanks to H.Merijn Brand):
.PP
.Vb 6
\&  $sth\->execute;
\&  my %row;
\&  $sth\->bind_columns( \e( @row{ @{$sth\->{NAME_lc} } } ));
\&  while ($sth\->fetch) {
\&      print "$row{region}: $row{sales}\en";
\&  }
.Ve
.PP
\fI\f(CI\*(C`dump_results\*(C'\fI\fR
.IX Subsection "dump_results"
.PP
.Vb 1
\&  $rows = $sth\->dump_results($maxlen, $lsep, $fsep, $fh);
.Ve
.PP
Fetches all the rows from \f(CW$sth\fR, calls \f(CW\*(C`DBI::neat_list\*(C'\fR for each row, and
prints the results to \f(CW$fh\fR (defaults to \f(CW\*(C`STDOUT\*(C'\fR) separated by \f(CW$lsep\fR
(default \f(CW"\en"\fR). \f(CW$fsep\fR defaults to \f(CW", "\fR and \f(CW$maxlen\fR defaults to 35.
.PP
This method is designed as a handy utility for prototyping and
testing queries. Since it uses \*(L"neat_list\*(R" to
format and edit the string for reading by humans, it is not recommended
for data transfer applications.
.SS "Statement Handle Attributes"
.IX Subsection "Statement Handle Attributes"
This section describes attributes specific to statement handles. Most
of these attributes are read-only.
.PP
Changes to these statement handle attributes do not affect any other
existing or future statement handles.
.PP
Attempting to set or get the value of an unknown attribute generates a warning,
except for private driver specific attributes (which all have names
starting with a lowercase letter).
.PP
Example:
.PP
.Vb 1
\&  ... = $h\->{NUM_OF_FIELDS};    # get/read
.Ve
.PP
Some drivers cannot provide valid values for some or all of these
attributes until after \f(CW\*(C`$sth\->execute\*(C'\fR has been successfully
called. Typically the attribute will be \f(CW\*(C`undef\*(C'\fR in these situations.
.PP
Some attributes, like \s-1NAME,\s0 are not appropriate to some types of
statement, like \s-1SELECT.\s0 Typically the attribute will be \f(CW\*(C`undef\*(C'\fR
in these situations.
.PP
For drivers which support stored procedures and multiple result sets
(see \*(L"more_results\*(R") these attributes relate to the \fIcurrent\fR result set.
.PP
See also \*(L"finish\*(R" to learn more about the effect it
may have on some attributes.
.PP
\fI\f(CI\*(C`NUM_OF_FIELDS\*(C'\fI\fR
.IX Subsection "NUM_OF_FIELDS"
.PP
Type: integer, read-only
.PP
Number of fields (columns) in the data the prepared statement may return.
Statements that don't return rows of data, like \f(CW\*(C`DELETE\*(C'\fR and \f(CW\*(C`CREATE\*(C'\fR
set \f(CW\*(C`NUM_OF_FIELDS\*(C'\fR to 0 (though it may be undef in some drivers).
.PP
\fI\f(CI\*(C`NUM_OF_PARAMS\*(C'\fI\fR
.IX Subsection "NUM_OF_PARAMS"
.PP
Type: integer, read-only
.PP
The number of parameters (placeholders) in the prepared statement.
See \s-1SUBSTITUTION VARIABLES\s0 below for more details.
.PP
\fI\f(CI\*(C`NAME\*(C'\fI\fR
.IX Subsection "NAME"
.PP
Type: array-ref, read-only
.PP
Returns a reference to an array of field names for each column. The
names may contain spaces but should not be truncated or have any
trailing space. Note that the names have the letter case (upper, lower
or mixed) as returned by the driver being used. Portable applications
should use \*(L"NAME_lc\*(R" or \*(L"NAME_uc\*(R".
.PP
.Vb 1
\&  print "First column name: $sth\->{NAME}\->[0]\en";
.Ve
.PP
Also note that the name returned for (aggregate) functions like \f(CWcount(*)\fR
or \f(CW\*(C`max(c_foo)\*(C'\fR is determined by the database server and not by \f(CW\*(C`DBI\*(C'\fR or
the \f(CW\*(C`DBD\*(C'\fR backend.
.PP
\fI\f(CI\*(C`NAME_lc\*(C'\fI\fR
.IX Subsection "NAME_lc"
.PP
Type: array-ref, read-only
.PP
Like \f(CW\*(C`/NAME\*(C'\fR but always returns lowercase names.
.PP
\fI\f(CI\*(C`NAME_uc\*(C'\fI\fR
.IX Subsection "NAME_uc"
.PP
Type: array-ref, read-only
.PP
Like \f(CW\*(C`/NAME\*(C'\fR but always returns uppercase names.
.PP
\fI\f(CI\*(C`NAME_hash\*(C'\fI\fR
.IX Subsection "NAME_hash"
.PP
Type: hash-ref, read-only
.PP
\fI\f(CI\*(C`NAME_lc_hash\*(C'\fI\fR
.IX Subsection "NAME_lc_hash"
.PP
Type: hash-ref, read-only
.PP
\fI\f(CI\*(C`NAME_uc_hash\*(C'\fI\fR
.IX Subsection "NAME_uc_hash"
.PP
Type: hash-ref, read-only
.PP
The \f(CW\*(C`NAME_hash\*(C'\fR, \f(CW\*(C`NAME_lc_hash\*(C'\fR, and \f(CW\*(C`NAME_uc_hash\*(C'\fR attributes
return column name information as a reference to a hash.
.PP
The keys of the hash are the names of the columns.  The letter case of
the keys corresponds to the letter case returned by the \f(CW\*(C`NAME\*(C'\fR,
\&\f(CW\*(C`NAME_lc\*(C'\fR, and \f(CW\*(C`NAME_uc\*(C'\fR attributes respectively (as described above).
.PP
The value of each hash entry is the perl index number of the
corresponding column (counting from 0). For example:
.PP
.Vb 4
\&  $sth = $dbh\->prepare("select Id, Name from table");
\&  $sth\->execute;
\&  @row = $sth\->fetchrow_array;
\&  print "Name $row[ $sth\->{NAME_lc_hash}{name} ]\en";
.Ve
.PP
\fI\f(CI\*(C`TYPE\*(C'\fI\fR
.IX Subsection "TYPE"
.PP
Type: array-ref, read-only
.PP
Returns a reference to an array of integer values for each
column. The value indicates the data type of the corresponding column.
.PP
The values correspond to the international standards (\s-1ANSI X3.135\s0
and \s-1ISO/IEC 9075\s0) which, in general terms, means \s-1ODBC.\s0 Driver-specific
types that don't exactly match standard types should generally return
the same values as an \s-1ODBC\s0 driver supplied by the makers of the
database. That might include private type numbers in ranges the vendor
has officially registered with the \s-1ISO\s0 working group:
.PP
.Vb 1
\&  ftp://sqlstandards.org/SC32/SQL_Registry/
.Ve
.PP
Where there's no vendor-supplied \s-1ODBC\s0 driver to be compatible with,
the \s-1DBI\s0 driver can use type numbers in the range that is now
officially reserved for use by the \s-1DBI: \-9999\s0 to \-9000.
.PP
All possible values for \f(CW\*(C`TYPE\*(C'\fR should have at least one entry in the
output of the \f(CW\*(C`type_info_all\*(C'\fR method (see \*(L"type_info_all\*(R").
.PP
\fI\f(CI\*(C`PRECISION\*(C'\fI\fR
.IX Subsection "PRECISION"
.PP
Type: array-ref, read-only
.PP
Returns a reference to an array of integer values for each column.
.PP
For numeric columns, the value is the maximum number of digits
(without considering a sign character or decimal point). Note that
the \*(L"display size\*(R" for floating point types (\s-1REAL, FLOAT, DOUBLE\s0)
can be up to 7 characters greater than the precision (for the
sign + decimal point + the letter E + a sign + 2 or 3 digits).
.PP
For any character type column the value is the \s-1OCTET_LENGTH,\s0
in other words the number of bytes, not characters.
.PP
(More recent standards refer to this as \s-1COLUMN_SIZE\s0 but we stick
with \s-1PRECISION\s0 for backwards compatibility.)
.PP
\fI\f(CI\*(C`SCALE\*(C'\fI\fR
.IX Subsection "SCALE"
.PP
Type: array-ref, read-only
.PP
Returns a reference to an array of integer values for each column.
\&\s-1NULL \s0(\f(CW\*(C`undef\*(C'\fR) values indicate columns where scale is not applicable.
.PP
\fI\f(CI\*(C`NULLABLE\*(C'\fI\fR
.IX Subsection "NULLABLE"
.PP
Type: array-ref, read-only
.PP
Returns a reference to an array indicating the possibility of each
column returning a null.  Possible values are \f(CW0\fR
(or an empty string) = no, \f(CW1\fR = yes, \f(CW2\fR = unknown.
.PP
.Vb 1
\&  print "First column may return NULL\en" if $sth\->{NULLABLE}\->[0];
.Ve
.PP
\fI\f(CI\*(C`CursorName\*(C'\fI\fR
.IX Subsection "CursorName"
.PP
Type: string, read-only
.PP
Returns the name of the cursor associated with the statement handle, if
available. If not available or if the database driver does not support the
\&\f(CW"where current of ..."\fR \s-1SQL\s0 syntax, then it returns \f(CW\*(C`undef\*(C'\fR.
.PP
\fI\f(CI\*(C`Database\*(C'\fI\fR
.IX Subsection "Database"
.PP
Type: dbh, read-only
.PP
Returns the parent \f(CW$dbh\fR of the statement handle.
.PP
\fI\f(CI\*(C`Statement\*(C'\fI\fR
.IX Subsection "Statement"
.PP
Type: string, read-only
.PP
Returns the statement string passed to the \*(L"prepare\*(R" method.
.PP
\fI\f(CI\*(C`ParamValues\*(C'\fI\fR
.IX Subsection "ParamValues"
.PP
Type: hash ref, read-only
.PP
Returns a reference to a hash containing the values currently bound
to placeholders.  The keys of the hash are the 'names' of the
placeholders, typically integers starting at 1.  Returns undef if
not supported by the driver.
.PP
See \*(L"ShowErrorStatement\*(R" for an example of how this is used.
.PP
* Keys:
.PP
If the driver supports \f(CW\*(C`ParamValues\*(C'\fR but no values have been bound
yet then the driver should return a hash with placeholders names
in the keys but all the values undef, but some drivers may return
a ref to an empty hash because they can't pre-determine the names.
.PP
It is possible that the keys in the hash returned by \f(CW\*(C`ParamValues\*(C'\fR
are not exactly the same as those implied by the prepared statement.
For example, DBD::Oracle translates '\f(CW\*(C`?\*(C'\fR' placeholders into '\f(CW\*(C`:pN\*(C'\fR'
where N is a sequence number starting at 1.
.PP
* Values:
.PP
It is possible that the values in the hash returned by \f(CW\*(C`ParamValues\*(C'\fR
are not \fIexactly\fR the same as those passed to \fIbind_param()\fR or \fIexecute()\fR.
The driver may have slightly modified values in some way based on the
\&\s-1TYPE\s0 the value was bound with. For example a floating point value
bound as an \s-1SQL_INTEGER\s0 type may be returned as an integer.
The values returned by \f(CW\*(C`ParamValues\*(C'\fR can be passed to another
\&\fIbind_param()\fR method with the same \s-1TYPE\s0 and will be seen by the
database as the same value. See also \*(L"ParamTypes\*(R" below.
.PP
The \f(CW\*(C`ParamValues\*(C'\fR attribute was added in \s-1DBI 1.28.\s0
.PP
\fI\f(CI\*(C`ParamTypes\*(C'\fI\fR
.IX Subsection "ParamTypes"
.PP
Type: hash ref, read-only
.PP
Returns a reference to a hash containing the type information
currently bound to placeholders.
Returns undef if not supported by the driver.
.PP
* Keys:
.PP
See \*(L"ParamValues\*(R" above.
.PP
* Values:
.PP
The hash values are hashrefs of type information in the same form as that
passed to the various \fIbind_param()\fR methods (See \*(L"bind_param\*(R" for the format
and values).
.PP
It is possible that the values in the hash returned by \f(CW\*(C`ParamTypes\*(C'\fR
are not exactly the same as those passed to \fIbind_param()\fR or \fIexecute()\fR.
Param attributes specified using the abbreviated form, like this:
.PP
.Vb 1
\&    $sth\->bind_param(1, SQL_INTEGER);
.Ve
.PP
are returned in the expanded form, as if called like this:
.PP
.Vb 1
\&    $sth\->bind_param(1, { TYPE => SQL_INTEGER });
.Ve
.PP
The driver may have modified the type information in some way based
on the bound values, other hints provided by the \fIprepare()\fR'd
\&\s-1SQL\s0 statement, or alternate type mappings required by the driver or target
database system. The driver may also add private keys (with names beginning
with the drivers reserved prefix, e.g., odbc_xxx).
.PP
* Example:
.PP
The keys and values in the returned hash can be passed to the various
\&\fIbind_param()\fR methods to effectively reproduce a previous param binding.
For example:
.PP
.Vb 7
\&  # assuming $sth1 is a previously prepared statement handle
\&  my $sth2 = $dbh\->prepare( $sth1\->{Statement} );
\&  my $ParamValues = $sth1\->{ParamValues} || {};
\&  my $ParamTypes  = $sth1\->{ParamTypes}  || {};
\&  $sth2\->bind_param($_, $ParamValues\->{$_} $ParamTypes\->{$_})
\&    for keys %{ {%$ParamValues, %$ParamTypes} };
\&  $sth2\->execute();
.Ve
.PP
The \f(CW\*(C`ParamTypes\*(C'\fR attribute was added in \s-1DBI 1.49.\s0 Implementation
is the responsibility of individual drivers; the \s-1DBI\s0 layer default
implementation simply returns undef.
.PP
\fI\f(CI\*(C`ParamArrays\*(C'\fI\fR
.IX Subsection "ParamArrays"
.PP
Type: hash ref, read-only
.PP
Returns a reference to a hash containing the values currently bound to
placeholders with \*(L"execute_array\*(R" or \*(L"bind_param_array\*(R".  The
keys of the hash are the 'names' of the placeholders, typically
integers starting at 1.  Returns undef if not supported by the driver
or no arrays of parameters are bound.
.PP
Each key value is an array reference containing a list of the bound
parameters for that column.
.PP
For example:
.PP
.Vb 8
\&  $sth = $dbh\->prepare("INSERT INTO staff (id, name) values (?,?)");
\&  $sth\->execute_array({},[1,2], [\*(Aqfred\*(Aq,\*(Aqdave\*(Aq]);
\&  if ($sth\->{ParamArrays}) {
\&      foreach $param (keys %{$sth\->{ParamArrays}}) {
\&          printf "Parameters for %s : %s\en", $param,
\&          join(",", @{$sth\->{ParamArrays}\->{$param}});
\&      }
\&  }
.Ve
.PP
It is possible that the values in the hash returned by \f(CW\*(C`ParamArrays\*(C'\fR
are not \fIexactly\fR the same as those passed to \*(L"bind_param_array\*(R" or
\&\*(L"execute_array\*(R".  The driver may have slightly modified values in some
way based on the \s-1TYPE\s0 the value was bound with. For example a floating
point value bound as an \s-1SQL_INTEGER\s0 type may be returned as an
integer.
.PP
It is also possible that the keys in the hash returned by
\&\f(CW\*(C`ParamArrays\*(C'\fR are not exactly the same as those implied by the
prepared statement.  For example, DBD::Oracle translates '\f(CW\*(C`?\*(C'\fR'
placeholders into '\f(CW\*(C`:pN\*(C'\fR' where N is a sequence number starting at 1.
.PP
\fI\f(CI\*(C`RowsInCache\*(C'\fI\fR
.IX Subsection "RowsInCache"
.PP
Type: integer, read-only
.PP
If the driver supports a local row cache for \f(CW\*(C`SELECT\*(C'\fR statements, then
this attribute holds the number of un-fetched rows in the cache. If the
driver doesn't, then it returns \f(CW\*(C`undef\*(C'\fR. Note that some drivers pre-fetch
rows on execute, whereas others wait till the first fetch.
.PP
See also the \*(L"RowCacheSize\*(R" database handle attribute.
.SH "FURTHER INFORMATION"
.IX Header "FURTHER INFORMATION"
.SS "Catalog Methods"
.IX Subsection "Catalog Methods"
An application can retrieve metadata information from the \s-1DBMS\s0 by issuing
appropriate queries on the views of the Information Schema. Unfortunately,
\&\f(CW\*(C`INFORMATION_SCHEMA\*(C'\fR views are seldom supported by the \s-1DBMS.\s0
Special methods (catalog methods) are available to return result sets
for a small but important portion of that metadata:
.PP
.Vb 5
\&  column_info
\&  foreign_key_info
\&  primary_key_info
\&  table_info
\&  statistics_info
.Ve
.PP
All catalog methods accept arguments in order to restrict the result sets.
Passing \f(CW\*(C`undef\*(C'\fR to an optional argument does not constrain the search for
that argument.
However, an empty string ('') is treated as a regular search criteria
and will only match an empty value.
.PP
\&\fBNote\fR: \s-1SQL/CLI\s0 and \s-1ODBC\s0 differ in the handling of empty strings. An
empty string will not restrict the result set in \s-1SQL/CLI.\s0
.PP
Most arguments in the catalog methods accept only \fIordinary values\fR, e.g.
the arguments of \f(CW\*(C`primary_key_info()\*(C'\fR.
Such arguments are treated as a literal string, i.e. the case is significant
and quote characters are taken literally.
.PP
Some arguments in the catalog methods accept \fIsearch patterns\fR (strings
containing '_' and/or '%'), e.g. the \f(CW$table\fR argument of \f(CW\*(C`column_info()\*(C'\fR.
Passing '%' is equivalent to leaving the argument \f(CW\*(C`undef\*(C'\fR.
.PP
\&\fBCaveat\fR: The underscore ('_') is valid and often used in \s-1SQL\s0 identifiers.
Passing such a value to a search pattern argument may return more rows than
expected!
To include pattern characters as literals, they must be preceded by an
escape character which can be achieved with
.PP
.Vb 2
\&  $esc = $dbh\->get_info( 14 );  # SQL_SEARCH_PATTERN_ESCAPE
\&  $search_pattern =~ s/([_%])/$esc$1/g;
.Ve
.PP
The \s-1ODBC\s0 and \s-1SQL/CLI\s0 specifications define a way to change the default
behaviour described above: All arguments (except \fIlist value arguments\fR)
are treated as \fIidentifier\fR if the \f(CW\*(C`SQL_ATTR_METADATA_ID\*(C'\fR attribute is
set to \f(CW\*(C`SQL_TRUE\*(C'\fR.
\&\fIQuoted identifiers\fR are very similar to \fIordinary values\fR, i.e. their
body (the string within the quotes) is interpreted literally.
\&\fIUnquoted identifiers\fR are compared in \s-1UPPERCASE.\s0
.PP
The \s-1DBI \s0(currently) does not support the \f(CW\*(C`SQL_ATTR_METADATA_ID\*(C'\fR attribute,
i.e. it behaves like an \s-1ODBC\s0 driver where \f(CW\*(C`SQL_ATTR_METADATA_ID\*(C'\fR is set to
\&\f(CW\*(C`SQL_FALSE\*(C'\fR.
.SS "Transactions"
.IX Subsection "Transactions"
Transactions are a fundamental part of any robust database system. They
protect against errors and database corruption by ensuring that sets of
related changes to the database take place in atomic (indivisible,
all-or-nothing) units.
.PP
This section applies to databases that support transactions and where
\&\f(CW\*(C`AutoCommit\*(C'\fR is off.  See \*(L"AutoCommit\*(R" for details of using \f(CW\*(C`AutoCommit\*(C'\fR
with various types of databases.
.PP
The recommended way to implement robust transactions in Perl
applications is to use \f(CW\*(C`RaiseError\*(C'\fR and \f(CW\*(C`eval\ {\ ...\ }\*(C'\fR
(which is very fast, unlike \f(CW\*(C`eval\ "..."\*(C'\fR). For example:
.PP
.Vb 10
\&  $dbh\->{AutoCommit} = 0;  # enable transactions, if possible
\&  $dbh\->{RaiseError} = 1;
\&  eval {
\&      foo(...)        # do lots of work here
\&      bar(...)        # including inserts
\&      baz(...)        # and updates
\&      $dbh\->commit;   # commit the changes if we get this far
\&  };
\&  if ($@) {
\&      warn "Transaction aborted because $@";
\&      # now rollback to undo the incomplete changes
\&      # but do it in an eval{} as it may also fail
\&      eval { $dbh\->rollback };
\&      # add other application on\-error\-clean\-up code here
\&  }
.Ve
.PP
If the \f(CW\*(C`RaiseError\*(C'\fR attribute is not set, then \s-1DBI\s0 calls would need to be
manually checked for errors, typically like this:
.PP
.Vb 1
\&  $h\->method(@args) or die $h\->errstr;
.Ve
.PP
With \f(CW\*(C`RaiseError\*(C'\fR set, the \s-1DBI\s0 will automatically \f(CW\*(C`die\*(C'\fR if any \s-1DBI\s0 method
call on that handle (or a child handle) fails, so you don't have to
test the return value of each method call. See \*(L"RaiseError\*(R" for more
details.
.PP
A major advantage of the \f(CW\*(C`eval\*(C'\fR approach is that the transaction will be
properly rolled back if \fIany\fR code (not just \s-1DBI\s0 calls) in the inner
application dies for any reason. The major advantage of using the
\&\f(CW\*(C`$h\->{RaiseError}\*(C'\fR attribute is that all \s-1DBI\s0 calls will be checked
automatically. Both techniques are strongly recommended.
.PP
After calling \f(CW\*(C`commit\*(C'\fR or \f(CW\*(C`rollback\*(C'\fR many drivers will not let you
fetch from a previously active \f(CW\*(C`SELECT\*(C'\fR statement handle that's a child
of the same database handle. A typical way round this is to connect the
the database twice and use one connection for \f(CW\*(C`SELECT\*(C'\fR statements.
.PP
See \*(L"AutoCommit\*(R" and \*(L"disconnect\*(R" for other important information
about transactions.
.SS "Handling \s-1BLOB / LONG /\s0 Memo Fields"
.IX Subsection "Handling BLOB / LONG / Memo Fields"
Many databases support \*(L"blob\*(R" (binary large objects), \*(L"long\*(R", or similar
datatypes for holding very long strings or large amounts of binary
data in a single field. Some databases support variable length long
values over 2,000,000,000 bytes in length.
.PP
Since values of that size can't usually be held in memory, and because
databases can't usually know in advance the length of the longest long
that will be returned from a \f(CW\*(C`SELECT\*(C'\fR statement (unlike other data
types), some special handling is required.
.PP
In this situation, the value of the \f(CW\*(C`$h\->{LongReadLen}\*(C'\fR
attribute is used to determine how much buffer space to allocate
when fetching such fields.  The \f(CW\*(C`$h\->{LongTruncOk}\*(C'\fR attribute
is used to determine how to behave if a fetched value can't fit
into the buffer.
.PP
See the description of \*(L"LongReadLen\*(R" for more information.
.PP
When trying to insert long or binary values, placeholders should be used
since there are often limits on the maximum size of an \f(CW\*(C`INSERT\*(C'\fR
statement and the \*(L"quote\*(R" method generally can't cope with binary
data.  See \*(L"Placeholders and Bind Values\*(R".
.SS "Simple Examples"
.IX Subsection "Simple Examples"
Here's a complete example program to select and fetch some data:
.PP
.Vb 3
\&  my $data_source = "dbi::DriverName:db_name";
\&  my $dbh = DBI\->connect($data_source, $user, $password)
\&      or die "Can\*(Aqt connect to $data_source: $DBI::errstr";
\&
\&  my $sth = $dbh\->prepare( q{
\&          SELECT name, phone
\&          FROM mytelbook
\&  }) or die "Can\*(Aqt prepare statement: $DBI::errstr";
\&
\&  my $rc = $sth\->execute
\&      or die "Can\*(Aqt execute statement: $DBI::errstr";
\&
\&  print "Query will return $sth\->{NUM_OF_FIELDS} fields.\en\en";
\&  print "Field names: @{ $sth\->{NAME} }\en";
\&
\&  while (($name, $phone) = $sth\->fetchrow_array) {
\&      print "$name: $phone\en";
\&  }
\&  # check for problems which may have terminated the fetch early
\&  die $sth\->errstr if $sth\->err;
\&
\&  $dbh\->disconnect;
.Ve
.PP
Here's a complete example program to insert some data from a file.
(This example uses \f(CW\*(C`RaiseError\*(C'\fR to avoid needing to check each call).
.PP
.Vb 3
\&  my $dbh = DBI\->connect("dbi:DriverName:db_name", $user, $password, {
\&      RaiseError => 1, AutoCommit => 0
\&  });
\&
\&  my $sth = $dbh\->prepare( q{
\&      INSERT INTO table (name, phone) VALUES (?, ?)
\&  });
\&
\&  open FH, "<phone.csv" or die "Unable to open phone.csv: $!";
\&  while (<FH>) {
\&      chomp;
\&      my ($name, $phone) = split /,/;
\&      $sth\->execute($name, $phone);
\&  }
\&  close FH;
\&
\&  $dbh\->commit;
\&  $dbh\->disconnect;
.Ve
.PP
Here's how to convert fetched NULLs (undefined values) into empty strings:
.PP
.Vb 5
\&  while($row = $sth\->fetchrow_arrayref) {
\&    # this is a fast and simple way to deal with nulls:
\&    foreach (@$row) { $_ = \*(Aq\*(Aq unless defined }
\&    print "@$row\en";
\&  }
.Ve
.PP
The \f(CW\*(C`q{...}\*(C'\fR style quoting used in these examples avoids clashing with
quotes that may be used in the \s-1SQL\s0 statement. Use the double-quote like
\&\f(CW\*(C`qq{...}\*(C'\fR operator if you want to interpolate variables into the string.
See \*(L"Quote and Quote-like Operators\*(R" in perlop for more details.
.SS "Threads and Thread Safety"
.IX Subsection "Threads and Thread Safety"
Perl 5.7 and later support a new threading model called iThreads.
(The old \*(L"5.005 style\*(R" threads are not supported by the \s-1DBI.\s0)
.PP
In the iThreads model each thread has its own copy of the perl
interpreter.  When a new thread is created the original perl
interpreter is 'cloned' to create a new copy for the new thread.
.PP
If the \s-1DBI\s0 and drivers are loaded and handles created before the
thread is created then it will get a cloned copy of the \s-1DBI,\s0 the
drivers and the handles.
.PP
However, the internal pointer data within the handles will refer
to the \s-1DBI\s0 and drivers in the original interpreter. Using those
handles in the new interpreter thread is not safe, so the \s-1DBI\s0 detects
this and croaks on any method call using handles that don't belong
to the current thread (except for \s-1DESTROY\s0).
.PP
Because of this (possibly temporary) restriction, newly created
threads must make their own connections to the database. Handles
can't be shared across threads.
.PP
But \s-1BEWARE,\s0 some underlying database APIs (the code the \s-1DBD\s0 driver
uses to talk to the database, often supplied by the database vendor)
are not thread safe. If it's not thread safe, then allowing more
than one thread to enter the code at the same time may cause
subtle/serious problems. In some cases allowing more than
one thread to enter the code, even if \fInot\fR at the same time,
can cause problems. You have been warned.
.PP
Using \s-1DBI\s0 with perl threads is not yet recommended for production
environments. For more information see
<http://www.perlmonks.org/index.pl?node_id=288022>
.PP
Note: There is a bug in perl 5.8.2 when configured with threads
and debugging enabled (bug #24463) which causes a \s-1DBI\s0 test to fail.
.SS "Signal Handling and Canceling Operations"
.IX Subsection "Signal Handling and Canceling Operations"
[The following only applies to systems with unix-like signal handling.
I'd welcome additions for other systems, especially Windows.]
.PP
The first thing to say is that signal handling in Perl versions less
than 5.8 is \fInot\fR safe. There is always a small risk of Perl
crashing and/or core dumping when, or after, handling a signal
because the signal could arrive and be handled while internal data
structures are being changed. If the signal handling code
used those same internal data structures it could cause all manner
of subtle and not-so-subtle problems.  The risk was reduced with
5.4.4 but was still present in all perls up through 5.8.0.
.PP
Beginning in perl 5.8.0 perl implements 'safe' signal handling if
your system has the \s-1POSIX\s0 \fIsigaction()\fR routine. Now when a signal
is delivered perl just makes a note of it but does \fInot\fR run the
\&\f(CW%SIG\fR handler. The handling is 'deferred' until a 'safe' moment.
.PP
Although this change made signal handling safe, it also lead to
a problem with signals being deferred for longer than you'd like.
If a signal arrived while executing a system call, such as waiting
for data on a network connection, the signal is noted and then the
system call that was executing returns with an \s-1EINTR\s0 error code
to indicate that it was interrupted. All fine so far.
.PP
The problem comes when the code that made the system call sees the
\&\s-1EINTR\s0 code and decides it's going to call it again. Perl doesn't
do that, but database code sometimes does. If that happens then the
signal handler doesn't get called until later. Maybe much later.
.PP
Fortunately there are ways around this which we'll discuss below.
Unfortunately they make signals unsafe again.
.PP
The two most common uses of signals in relation to the \s-1DBI\s0 are for
canceling operations when the user types Ctrl-C (interrupt), and for
implementing a timeout using \f(CW\*(C`alarm()\*(C'\fR and \f(CW$SIG{ALRM}\fR.
.IP "Cancel" 4
.IX Item "Cancel"
The \s-1DBI\s0 provides a \f(CW\*(C`cancel\*(C'\fR method for statement handles. The
\&\f(CW\*(C`cancel\*(C'\fR method should abort the current operation and is designed
to be called from a signal handler.  For example:
.Sp
.Vb 1
\&  $SIG{INT} = sub { $sth\->cancel };
.Ve
.Sp
However, few drivers implement this (the \s-1DBI\s0 provides a default
method that just returns \f(CW\*(C`undef\*(C'\fR) and, even if implemented, there
is still a possibility that the statement handle, and even the
parent database handle, will not be usable afterwards.
.Sp
If \f(CW\*(C`cancel\*(C'\fR returns true, then it has successfully
invoked the database engine's own cancel function.  If it returns false,
then \f(CW\*(C`cancel\*(C'\fR failed. If it returns \f(CW\*(C`undef\*(C'\fR, then the database
driver does not have cancel implemented \- very few do.
.IP "Timeout" 4
.IX Item "Timeout"
The traditional way to implement a timeout is to set \f(CW$SIG{ALRM}\fR
to refer to some code that will be executed when an \s-1ALRM\s0 signal
arrives and then to call alarm($seconds) to schedule an \s-1ALRM\s0 signal
to be delivered \f(CW$seconds\fR in the future. For example:
.Sp
.Vb 12
\&  eval {
\&    local $SIG{ALRM} = sub { die "TIMEOUT\en" }; # N.B. \en required
\&    eval {
\&      alarm($seconds);
\&      ... code to execute with timeout here (which may die) ...
\&    };
\&    # outer eval catches alarm that might fire JUST before this alarm(0)
\&    alarm(0);  # cancel alarm (if code ran fast)
\&    die "$@" if $@;
\&  };
\&  if ( $@ eq "TIMEOUT\en" ) { ... }
\&  elsif ($@) { ... } # some other error
.Ve
.Sp
The first (outer) eval is used to avoid the unlikely but possible
chance that the \*(L"code to execute\*(R" dies and the alarm fires before it
is cancelled. Without the outer eval, if this happened your program
will die if you have no \s-1ALRM\s0 handler or a non-local alarm handler
will be called.
.Sp
Unfortunately, as described above, this won't always work as expected,
depending on your perl version and the underlying database code.
.Sp
With Oracle for instance (DBD::Oracle), if the system which hosts
the database is down the \s-1DBI\-\s0>\fIconnect()\fR call will hang for several
minutes before returning an error.
.PP
The solution on these systems is to use the \f(CW\*(C`POSIX::sigaction()\*(C'\fR
routine to gain low level access to how the signal handler is installed.
.PP
The code would look something like this (for the DBD-Oracle \fIconnect()\fR):
.PP
.Vb 1
\&   use POSIX qw(:signal_h);
\&
\&   my $mask = POSIX::SigSet\->new( SIGALRM ); # signals to mask in the handler
\&   my $action = POSIX::SigAction\->new(
\&       sub { die "connect timeout\en" },        # the handler code ref
\&       $mask,
\&       # not using (perl 5.8.2 and later) \*(Aqsafe\*(Aq switch or sa_flags
\&   );
\&   my $oldaction = POSIX::SigAction\->new();
\&   sigaction( SIGALRM, $action, $oldaction );
\&   my $dbh;
\&   eval {
\&      eval {
\&        alarm(5); # seconds before time out
\&        $dbh = DBI\->connect("dbi:Oracle:$dsn" ... );
\&      };
\&      alarm(0); # cancel alarm (if connect worked fast)
\&      die "$@\en" if $@; # connect died
\&   };
\&   sigaction( SIGALRM, $oldaction );  # restore original signal handler
\&   if ( $@ ) {
\&     if ($@ eq "connect timeout\en") {...}
\&     else { # connect died }
\&   }
.Ve
.PP
See previous example for the reasoning around the double eval.
.PP
Similar techniques can be used for canceling statement execution.
.PP
Unfortunately, this solution is somewhat messy, and it does \fInot\fR work with
perl versions less than perl 5.8 where \f(CW\*(C`POSIX::sigaction()\*(C'\fR appears to be broken.
.PP
For a cleaner implementation that works across perl versions, see Lincoln Baxter's
Sys::SigAction module at <http://search.cpan.org/~lbaxter/Sys\-SigAction/>.
The documentation for Sys::SigAction includes an longer discussion
of this problem, and a DBD::Oracle test script.
.PP
Be sure to read all the signal handling sections of the perlipc manual.
.PP
And finally, two more points to keep firmly in mind. Firstly,
remember that what we've done here is essentially revert to old
style \fIunsafe\fR handling of these signals. So do as little as
possible in the handler.  Ideally just \fIdie()\fR. Secondly, the handles
in use at the time the signal is handled may not be safe to use
afterwards.
.SS "Subclassing the \s-1DBI\s0"
.IX Subsection "Subclassing the DBI"
\&\s-1DBI\s0 can be subclassed and extended just like any other object
oriented module.  Before we talk about how to do that, it's important
to be clear about the various \s-1DBI\s0 classes and how they work together.
.PP
By default \f(CW\*(C`$dbh = DBI\->connect(...)\*(C'\fR returns a \f(CW$dbh\fR blessed
into the \f(CW\*(C`DBI::db\*(C'\fR class.  And the \f(CW\*(C`$dbh\->prepare\*(C'\fR method
returns an \f(CW$sth\fR blessed into the \f(CW\*(C`DBI::st\*(C'\fR class (actually it
simply changes the last four characters of the calling handle class
to be \f(CW\*(C`::st\*(C'\fR).
.PP
The leading '\f(CW\*(C`DBI\*(C'\fR' is known as the 'root class' and the extra
\&'\f(CW\*(C`::db\*(C'\fR' or '\f(CW\*(C`::st\*(C'\fR' are the 'handle type suffixes'. If you want
to subclass the \s-1DBI\s0 you'll need to put your overriding methods into
the appropriate classes.  For example, if you want to use a root class
of \f(CW\*(C`MySubDBI\*(C'\fR and override the \fIdo()\fR, \fIprepare()\fR and \fIexecute()\fR methods,
then your \fIdo()\fR and \fIprepare()\fR methods should be in the \f(CW\*(C`MySubDBI::db\*(C'\fR
class and the \fIexecute()\fR method should be in the \f(CW\*(C`MySubDBI::st\*(C'\fR class.
.PP
To setup the inheritance hierarchy the \f(CW@ISA\fR variable in \f(CW\*(C`MySubDBI::db\*(C'\fR
should include \f(CW\*(C`DBI::db\*(C'\fR and the \f(CW@ISA\fR variable in \f(CW\*(C`MySubDBI::st\*(C'\fR
should include \f(CW\*(C`DBI::st\*(C'\fR.  The \f(CW\*(C`MySubDBI\*(C'\fR root class itself isn't
currently used for anything visible and so, apart from setting \f(CW@ISA\fR
to include \f(CW\*(C`DBI\*(C'\fR, it can be left empty.
.PP
So, having put your overriding methods into the right classes, and
setup the inheritance hierarchy, how do you get the \s-1DBI\s0 to use them?
You have two choices, either a static method call using the name
of your subclass:
.PP
.Vb 1
\&  $dbh = MySubDBI\->connect(...);
.Ve
.PP
or specifying a \f(CW\*(C`RootClass\*(C'\fR attribute:
.PP
.Vb 1
\&  $dbh = DBI\->connect(..., { RootClass => \*(AqMySubDBI\*(Aq });
.Ve
.PP
If both forms are used then the attribute takes precedence.
.PP
The only differences between the two are that using an explicit
RootClass attribute will a) make the \s-1DBI\s0 automatically attempt to load
a module by that name if the class doesn't exist, and b) won't call
your \fIMySubDBI::connect()\fR method, if you have one.
.PP
When subclassing is being used then, after a successful new
connect, the \s-1DBI\-\s0>connect method automatically calls:
.PP
.Vb 1
\&  $dbh\->connected($dsn, $user, $pass, \e%attr);
.Ve
.PP
The default method does nothing. The call is made just to simplify
any post-connection setup that your subclass may want to perform.
The parameters are the same as passed to \s-1DBI\-\s0>connect.
If your subclass supplies a connected method, it should be part of the
MySubDBI::db package.
.PP
One more thing to note: you must let the \s-1DBI\s0 do the handle creation.  If you
want to override the \fIconnect()\fR method in your *::dr class then it must still
call SUPER::connect to get a \f(CW$dbh\fR to work with. Similarly, an overridden
\&\fIprepare()\fR method in *::db must still call SUPER::prepare to get a \f(CW$sth\fR.
If you try to create your own handles using \fIbless()\fR then you'll find the \s-1DBI\s0
will reject them with an \*(L"is not a \s-1DBI\s0 handle (has no magic)\*(R" error.
.PP
Here's a brief example of a \s-1DBI\s0 subclass.  A more thorough example
can be found in \fIt/subclass.t\fR in the \s-1DBI\s0 distribution.
.PP
.Vb 1
\&  package MySubDBI;
\&
\&  use strict;
\&
\&  use DBI;
\&  use vars qw(@ISA);
\&  @ISA = qw(DBI);
\&
\&  package MySubDBI::db;
\&  use vars qw(@ISA);
\&  @ISA = qw(DBI::db);
\&
\&  sub prepare {
\&    my ($dbh, @args) = @_;
\&    my $sth = $dbh\->SUPER::prepare(@args)
\&        or return;
\&    $sth\->{private_mysubdbi_info} = { foo => \*(Aqbar\*(Aq };
\&    return $sth;
\&  }
\&
\&  package MySubDBI::st;
\&  use vars qw(@ISA);
\&  @ISA = qw(DBI::st);
\&
\&  sub fetch {
\&    my ($sth, @args) = @_;
\&    my $row = $sth\->SUPER::fetch(@args)
\&        or return;
\&    do_something_magical_with_row_data($row)
\&        or return $sth\->set_err(1234, "The magic failed", undef, "fetch");
\&    return $row;
\&  }
.Ve
.PP
When calling a SUPER::method that returns a handle, be careful to
check the return value before trying to do other things with it in
your overridden method. This is especially important if you want to
set a hash attribute on the handle, as Perl's autovivification will
bite you by (in)conveniently creating an unblessed hashref, which your
method will then return with usually baffling results later on like
the error \*(L"dbih_getcom handle \s-1HASH\s0(0xa4451a8) is not a \s-1DBI\s0 handle (has
no magic\*(R".  It's best to check right after the call and return undef
immediately on error, just like \s-1DBI\s0 would and just like the example
above.
.PP
If your method needs to record an error it should call the \fIset_err()\fR
method with the error code and error string, as shown in the example
above. The error code and error string will be recorded in the
handle and available via \f(CW\*(C`$h\->err\*(C'\fR and \f(CW$DBI::errstr\fR etc.
The \fIset_err()\fR method always returns an undef or empty list as
appropriate. Since your method should nearly always return an undef
or empty list as soon as an error is detected it's handy to simply
return what \fIset_err()\fR returns, as shown in the example above.
.PP
If the handle has \f(CW\*(C`RaiseError\*(C'\fR, \f(CW\*(C`PrintError\*(C'\fR, or \f(CW\*(C`HandleError\*(C'\fR
etc. set then the \fIset_err()\fR method will honour them. This means
that if \f(CW\*(C`RaiseError\*(C'\fR is set then \fIset_err()\fR won't return in the
normal way but will 'throw an exception' that can be caught with
an \f(CW\*(C`eval\*(C'\fR block.
.PP
You can stash private data into \s-1DBI\s0 handles
via \f(CW\*(C`$h\->{private_..._*}\*(C'\fR.  See the entry under \*(L"\s-1ATTRIBUTES
COMMON TO ALL HANDLES\*(R"\s0 for info and important caveats.
.SH "TRACING"
.IX Header "TRACING"
The \s-1DBI\s0 has a powerful tracing mechanism built in. It enables you
to see what's going on 'behind the scenes', both within the \s-1DBI\s0 and
the drivers you're using.
.SS "Trace Settings"
.IX Subsection "Trace Settings"
Which details are written to the trace output is controlled by a
combination of a \fItrace level\fR, an integer from 0 to 15, and a set
of \fItrace flags\fR that are either on or off. Together these are known
as the \fItrace settings\fR and are stored together in a single integer.
For normal use you only need to set the trace level, and generally
only to a value between 1 and 4.
.PP
Each handle has its own trace settings, and so does the \s-1DBI.\s0
When you call a method the \s-1DBI\s0 merges the handles settings into its
own for the duration of the call: the trace flags of the handle are
\&\s-1OR\s0'd into the trace flags of the \s-1DBI,\s0 and if the handle has a higher
trace level then the \s-1DBI\s0 trace level is raised to match it.
The previous \s-1DBI\s0 trace settings are restored when the called method
returns.
.SS "Trace Levels"
.IX Subsection "Trace Levels"
Trace \fIlevels\fR are as follows:
.PP
.Vb 8
\&  0 \- Trace disabled.
\&  1 \- Trace top\-level DBI method calls returning with results or errors.
\&  2 \- As above, adding tracing of top\-level method entry with parameters.
\&  3 \- As above, adding some high\-level information from the driver
\&      and some internal information from the DBI.
\&  4 \- As above, adding more detailed information from the driver.
\&      This is the first level to trace all the rows being fetched.
\&  5 to 15 \- As above but with more and more internal information.
.Ve
.PP
Trace level 1 is best for a simple overview of what's happening.
Trace levels 2 thru 4 a good choice for general purpose tracing.
Levels 5 and above are best reserved for investigating a specific
problem, when you need to see \*(L"inside\*(R" the driver and \s-1DBI.\s0
.PP
The trace output is detailed and typically very useful. Much of the
trace output is formatted using the \*(L"neat\*(R" function, so strings
in the trace output may be edited and truncated by that function.
.SS "Trace Flags"
.IX Subsection "Trace Flags"
Trace \fIflags\fR are used to enable tracing of specific activities
within the \s-1DBI\s0 and drivers. The \s-1DBI\s0 defines some trace flags and
drivers can define others. \s-1DBI\s0 trace flag names begin with a capital
letter and driver specific names begin with a lowercase letter, as
usual.
.PP
Currently the \s-1DBI\s0 defines these trace flags:
.PP
.Vb 10
\&  ALL \- turn on all DBI and driver flags (not recommended)
\&  SQL \- trace SQL statements executed
\&        (not yet implemented in DBI but implemented in some DBDs)
\&  CON \- trace connection process
\&  ENC \- trace encoding (unicode translations etc)
\&        (not yet implemented in DBI but implemented in some DBDs)
\&  DBD \- trace only DBD messages
\&        (not implemented by all DBDs yet)
\&  TXN \- trace transactions
\&        (not implemented in all DBDs yet)
.Ve
.PP
The \*(L"parse_trace_flags\*(R" and \*(L"parse_trace_flag\*(R" methods are used
to convert trace flag names into the corresponding integer bit flags.
.SS "Enabling Trace"
.IX Subsection "Enabling Trace"
The \f(CW\*(C`$h\->trace\*(C'\fR method sets the trace settings for a handle
and \f(CW\*(C`DBI\->trace\*(C'\fR does the same for the \s-1DBI.\s0
.PP
In addition to the \*(L"trace\*(R" method, you can enable the same trace
information, and direct the output to a file, by setting the
\&\f(CW\*(C`DBI_TRACE\*(C'\fR environment variable before starting Perl.
See \*(L"\s-1DBI_TRACE\*(R"\s0 for more information.
.PP
Finally, you can set, or get, the trace settings for a handle using
the \f(CW\*(C`TraceLevel\*(C'\fR attribute.
.PP
All of those methods use \fIparse_trace_flags()\fR and so allow you set
both the trace level and multiple trace flags by using a string
containing the trace level and/or flag names separated by vertical
bar ("\f(CW\*(C`|\*(C'\fR\*(L") or comma (\*(R"\f(CW\*(C`,\*(C'\fR") characters. For example:
.PP
.Vb 1
\&  local $h\->{TraceLevel} = "3|SQL|foo";
.Ve
.SS "Trace Output"
.IX Subsection "Trace Output"
Initially trace output is written to \f(CW\*(C`STDERR\*(C'\fR.  Both the
\&\f(CW\*(C`$h\->trace\*(C'\fR and \f(CW\*(C`DBI\->trace\*(C'\fR methods take an optional
\&\f(CW$trace_file\fR parameter, which may be either the name of a file to be
opened by \s-1DBI\s0 in append mode, or a reference to an existing writable
(possibly layered) filehandle. If \f(CW$trace_file\fR is a filename,
and can be opened in append mode, or \f(CW$trace_file\fR is a writable
filehandle, then \fIall\fR trace output (currently including that from
other handles) is redirected to that file. A warning is generated
if \f(CW$trace_file\fR can't be opened or is not writable.
.PP
Further calls to \fItrace()\fR without \f(CW$trace_file\fR do not alter where
the trace output is sent. If \f(CW$trace_file\fR is undefined, then
trace output is sent to \f(CW\*(C`STDERR\*(C'\fR and, if the prior trace was opened with
\&\f(CW$trace_file\fR as a filename, the previous trace file is closed; if \f(CW$trace_file\fR was
a filehandle, the filehandle is \fBnot\fR closed.
.PP
\&\fB\s-1NOTE\s0\fR: If \f(CW$trace_file\fR is specified as a filehandle, the filehandle
should not be closed until all \s-1DBI\s0 operations are completed, or the
application has reset the trace file via another call to
\&\f(CW\*(C`trace()\*(C'\fR that changes the trace file.
.SS "Tracing to Layered Filehandles"
.IX Subsection "Tracing to Layered Filehandles"
\&\fB\s-1NOTE\s0\fR:
.IP "\(bu" 4
Tied filehandles are not currently supported, as
tie operations are not available to the PerlIO
methods used by the \s-1DBI.\s0
.IP "\(bu" 4
PerlIO layer support requires Perl version 5.8 or higher.
.PP
As of version 5.8, Perl provides the ability to layer various
\&\*(L"disciplines\*(R" on an open filehandle via the PerlIO module.
.PP
A simple example of using PerlIO layers is to use a scalar as the output:
.PP
.Vb 3
\&    my $scalar = \*(Aq\*(Aq;
\&    open( my $fh, "+>:scalar", \e$scalar );
\&    $dbh\->trace( 2, $fh );
.Ve
.PP
Now all trace output is simply appended to \f(CW$scalar\fR.
.PP
A more complex application of tracing to a layered filehandle is the
use of a custom layer (\fIRefer to \fRPerlio::via \fIfor details
on creating custom PerlIO layers.\fR). Consider an application with the
following logger module:
.PP
.Vb 1
\&    package MyFancyLogger;
\&
\&    sub new
\&    {
\&        my $self = {};
\&        my $fh;
\&        open $fh, \*(Aq>\*(Aq, \*(Aqfancylog.log\*(Aq;
\&        $self\->{_fh} = $fh;
\&        $self\->{_buf} = \*(Aq\*(Aq;
\&        return bless $self, shift;
\&    }
\&
\&    sub log
\&    {
\&        my $self = shift;
\&        return unless exists $self\->{_fh};
\&        my $fh = $self\->{_fh};
\&        $self\->{_buf} .= shift;
\&    #
\&    # DBI feeds us pieces at a time, so accumulate a complete line
\&    # before outputing
\&    #
\&        print $fh "At ", scalar localtime(), \*(Aq:\*(Aq, $self\->{_buf}, "\en" and
\&        $self\->{_buf} = \*(Aq\*(Aq
\&            if $self\->{_buf}=~tr/\en//;
\&    }
\&
\&    sub close {
\&        my $self = shift;
\&        return unless exists $self\->{_fh};
\&        my $fh = $self\->{_fh};
\&        print $fh "At ", scalar localtime(), \*(Aq:\*(Aq, $self\->{_buf}, "\en" and
\&        $self\->{_buf} = \*(Aq\*(Aq
\&            if $self\->{_buf};
\&        close $fh;
\&        delete $self\->{_fh};
\&    }
\&
\&    1;
.Ve
.PP
To redirect \s-1DBI\s0 traces to this logger requires creating
a package for the layer:
.PP
.Vb 1
\&    package PerlIO::via::MyFancyLogLayer;
\&
\&    sub PUSHED
\&    {
\&        my ($class,$mode,$fh) = @_;
\&        my $logger;
\&        return bless \e$logger,$class;
\&    }
\&
\&    sub OPEN {
\&        my ($self, $path, $mode, $fh) = @_;
\&        #
\&        # $path is actually our logger object
\&        #
\&        $$self = $path;
\&        return 1;
\&    }
\&
\&    sub WRITE
\&    {
\&        my ($self, $buf, $fh) = @_;
\&        $$self\->log($buf);
\&        return length($buf);
\&    }
\&
\&    sub CLOSE {
\&        my $self = shift;
\&        $$self\->close();
\&        return 0;
\&    }
\&
\&    1;
.Ve
.PP
The application can then cause \s-1DBI\s0 traces to be routed to the
logger using
.PP
.Vb 1
\&    use PerlIO::via::MyFancyLogLayer;
\&
\&    open my $fh, \*(Aq>:via(MyFancyLogLayer)\*(Aq, MyFancyLogger\->new();
\&
\&    $dbh\->trace(\*(AqSQL\*(Aq, $fh);
.Ve
.PP
Now all trace output will be processed by MyFancyLogger's
\&\fIlog()\fR method.
.SS "Trace Content"
.IX Subsection "Trace Content"
Many of the values embedded in trace output are formatted using the \fIneat()\fR
utility function. This means they may be quoted, sanitized, and possibly
truncated if longer than \f(CW$DBI::neat_maxlen\fR. See \*(L"neat\*(R" for more details.
.SS "Tracing Tips"
.IX Subsection "Tracing Tips"
You can add tracing to your own application code using the \*(L"trace_msg\*(R" method.
.PP
It can sometimes be handy to compare trace files from two different runs of the
same script. However using a tool like \f(CW\*(C`diff\*(C'\fR on the original log output
doesn't work well because the trace file is full of object addresses that may
differ on each run.
.PP
The \s-1DBI\s0 includes a handy utility called dbilogstrip that can be used to
\&'normalize' the log content. It can be used as a filter like this:
.PP
.Vb 3
\&    DBI_TRACE=2 perl yourscript.pl ...args1... 2>&1 | dbilogstrip > dbitrace1.log
\&    DBI_TRACE=2 perl yourscript.pl ...args2... 2>&1 | dbilogstrip > dbitrace2.log
\&    diff \-u dbitrace1.log dbitrace2.log
.Ve
.PP
See dbilogstrip for more information.
.SH "DBI ENVIRONMENT VARIABLES"
.IX Header "DBI ENVIRONMENT VARIABLES"
The \s-1DBI\s0 module recognizes a number of environment variables, but most of
them should not be used most of the time.
It is better to be explicit about what you are doing to avoid the need
for environment variables, especially in a web serving system where web
servers are stingy about which environment variables are available.
.SS "\s-1DBI_DSN\s0"
.IX Subsection "DBI_DSN"
The \s-1DBI_DSN\s0 environment variable is used by \s-1DBI\-\s0>connect if you do not
specify a data source when you issue the connect.
It should have a format such as \*(L"dbi:Driver:databasename\*(R".
.SS "\s-1DBI_DRIVER\s0"
.IX Subsection "DBI_DRIVER"
The \s-1DBI_DRIVER\s0 environment variable is used to fill in the database
driver name in \s-1DBI\-\s0>connect if the data source string starts \*(L"dbi::\*(R"
(thereby omitting the driver).
If \s-1DBI_DSN\s0 omits the driver name, \s-1DBI_DRIVER\s0 can fill the gap.
.SS "\s-1DBI_AUTOPROXY\s0"
.IX Subsection "DBI_AUTOPROXY"
The \s-1DBI_AUTOPROXY\s0 environment variable takes a string value that starts
\&\*(L"dbi:Proxy:\*(R" and is typically followed by \*(L"hostname=...;port=...\*(R".
It is used to alter the behaviour of \s-1DBI\-\s0>connect.
For full details, see DBI::Proxy documentation.
.SS "\s-1DBI_USER\s0"
.IX Subsection "DBI_USER"
The \s-1DBI_USER\s0 environment variable takes a string value that is used as
the user name if the \s-1DBI\-\s0>connect call is given undef (as distinct from
an empty string) as the username argument.
Be wary of the security implications of using this.
.SS "\s-1DBI_PASS\s0"
.IX Subsection "DBI_PASS"
The \s-1DBI_PASS\s0 environment variable takes a string value that is used as
the password if the \s-1DBI\-\s0>connect call is given undef (as distinct from
an empty string) as the password argument.
Be extra wary of the security implications of using this.
.SS "\s-1DBI_DBNAME \s0(obsolete)"
.IX Subsection "DBI_DBNAME (obsolete)"
The \s-1DBI_DBNAME\s0 environment variable takes a string value that is used only when the
obsolescent style of \s-1DBI\-\s0>connect (with driver name as fourth parameter) is used, and
when no value is provided for the first (database name) argument.
.SS "\s-1DBI_TRACE\s0"
.IX Subsection "DBI_TRACE"
The \s-1DBI_TRACE\s0 environment variable specifies the global default
trace settings for the \s-1DBI\s0 at startup. Can also be used to direct
trace output to a file. When the \s-1DBI\s0 is loaded it does:
.PP
.Vb 1
\&  DBI\->trace(split /=/, $ENV{DBI_TRACE}, 2) if $ENV{DBI_TRACE};
.Ve
.PP
So if \f(CW\*(C`DBI_TRACE\*(C'\fR contains an "\f(CW\*(C`=\*(C'\fR" character then what follows
it is used as the name of the file to append the trace to.
.PP
output appended to that file. If the name begins with a number
followed by an equal sign (\f(CW\*(C`=\*(C'\fR), then the number and the equal sign are
stripped off from the name, and the number is used to set the trace
level. For example:
.PP
.Vb 1
\&  DBI_TRACE=1=dbitrace.log perl your_test_script.pl
.Ve
.PP
On Unix-like systems using a Bourne-like shell, you can do this easily
on the command line:
.PP
.Vb 1
\&  DBI_TRACE=2 perl your_test_script.pl
.Ve
.PP
See \*(L"\s-1TRACING\*(R"\s0 for more information.
.SS "\s-1PERL_DBI_DEBUG \s0(obsolete)"
.IX Subsection "PERL_DBI_DEBUG (obsolete)"
An old variable that should no longer be used; equivalent to \s-1DBI_TRACE.\s0
.SS "\s-1DBI_PROFILE\s0"
.IX Subsection "DBI_PROFILE"
The \s-1DBI_PROFILE\s0 environment variable can be used to enable profiling
of \s-1DBI\s0 method calls. See DBI::Profile for more information.
.SS "\s-1DBI_PUREPERL\s0"
.IX Subsection "DBI_PUREPERL"
The \s-1DBI_PUREPERL\s0 environment variable can be used to enable the
use of DBI::PurePerl.  See DBI::PurePerl for more information.
.SH "WARNING AND ERROR MESSAGES"
.IX Header "WARNING AND ERROR MESSAGES"
.SS "Fatal Errors"
.IX Subsection "Fatal Errors"
.ie n .IP "Can't call method ""prepare"" without a package or object reference" 4
.el .IP "Can't call method ``prepare'' without a package or object reference" 4
.IX Item "Can't call method prepare without a package or object reference"
The \f(CW$dbh\fR handle you're using to call \f(CW\*(C`prepare\*(C'\fR is probably undefined because
the preceding \f(CW\*(C`connect\*(C'\fR failed. You should always check the return status of
\&\s-1DBI\s0 methods, or use the \*(L"RaiseError\*(R" attribute.
.ie n .IP "Can't call method ""execute"" without a package or object reference" 4
.el .IP "Can't call method ``execute'' without a package or object reference" 4
.IX Item "Can't call method execute without a package or object reference"
The \f(CW$sth\fR handle you're using to call \f(CW\*(C`execute\*(C'\fR is probably undefined because
the preceding \f(CW\*(C`prepare\*(C'\fR failed. You should always check the return status of
\&\s-1DBI\s0 methods, or use the \*(L"RaiseError\*(R" attribute.
.IP "\s-1DBI/DBD\s0 internal version mismatch" 4
.IX Item "DBI/DBD internal version mismatch"
The \s-1DBD\s0 driver module was built with a different version of \s-1DBI\s0 than
the one currently being used.  You should rebuild the \s-1DBD\s0 module under
the current version of \s-1DBI.\s0
.Sp
(Some rare platforms require \*(L"static linking\*(R". On those platforms, there
may be an old \s-1DBI\s0 or \s-1DBD\s0 driver version actually embedded in the Perl
executable being used.)
.IP "\s-1DBD\s0 driver has not implemented the AutoCommit attribute" 4
.IX Item "DBD driver has not implemented the AutoCommit attribute"
The \s-1DBD\s0 driver implementation is incomplete. Consult the author.
.ie n .IP "Can't [sg]et %s\->{%s}: unrecognised attribute" 4
.el .IP "Can't [sg]et \f(CW%s\fR\->{%s}: unrecognised attribute" 4
.IX Item "Can't [sg]et %s->{%s}: unrecognised attribute"
You attempted to set or get an unknown attribute of a handle.  Make
sure you have spelled the attribute name correctly; case is significant
(e.g., \*(L"Autocommit\*(R" is not the same as \*(L"AutoCommit\*(R").
.SH "Pure-Perl DBI"
.IX Header "Pure-Perl DBI"
A pure-perl emulation of the \s-1DBI\s0 is included in the distribution
for people using pure-perl drivers who, for whatever reason, can't
install the compiled \s-1DBI.\s0 See DBI::PurePerl.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.SS "Driver and Database Documentation"
.IX Subsection "Driver and Database Documentation"
Refer to the documentation for the \s-1DBD\s0 driver that you are using.
.PP
Refer to the \s-1SQL\s0 Language Reference Manual for the database engine that you are using.
.SS "\s-1ODBC\s0 and \s-1SQL/CLI\s0 Standards Reference Information"
.IX Subsection "ODBC and SQL/CLI Standards Reference Information"
More detailed information about the semantics of certain \s-1DBI\s0 methods
that are based on \s-1ODBC\s0 and \s-1SQL/CLI\s0 standards is available on-line
via microsoft.com, for \s-1ODBC,\s0 and www.jtc1sc32.org for the \s-1SQL/CLI\s0
standard:
.PP
.Vb 9
\& DBI method        ODBC function     SQL/CLI Working Draft
\& \-\-\-\-\-\-\-\-\-\-        \-\-\-\-\-\-\-\-\-\-\-\-\-     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& column_info       SQLColumns        Page 124
\& foreign_key_info  SQLForeignKeys    Page 163
\& get_info          SQLGetInfo        Page 214
\& primary_key_info  SQLPrimaryKeys    Page 254
\& table_info        SQLTables         Page 294
\& type_info         SQLGetTypeInfo    Page 239
\& statistics_info   SQLStatistics
.Ve
.PP
To find documentation on the \s-1ODBC\s0 function you can use
the \s-1MSDN\s0 search facility at:
.PP
.Vb 1
\&    http://msdn.microsoft.com/Search
.Ve
.PP
and search for something like \f(CW"SQLColumns returns"\fR.
.PP
And for \s-1SQL/CLI\s0 standard information on SQLColumns you'd read page 124 of
the (very large) \s-1SQL/CLI\s0 Working Draft available from:
.PP
.Vb 1
\&  http://jtc1sc32.org/doc/N0701\-0750/32N0744T.pdf
.Ve
.SS "Standards Reference Information"
.IX Subsection "Standards Reference Information"
A hyperlinked, browsable version of the \s-1BNF\s0 syntax for \s-1SQL92 \s0(plus
Oracle 7 \s-1SQL\s0 and \s-1PL/SQL\s0) is available here:
.PP
.Vb 1
\&  http://cui.unige.ch/db\-research/Enseignement/analyseinfo/SQL92/BNFindex.html
.Ve
.PP
A \s-1BNF\s0 syntax for \s-1SQL3\s0 is available here:
.PP
.Vb 1
\&  http://www.sqlstandards.org/SC32/WG3/Progression_Documents/Informal_working_drafts/iso\-9075\-2\-1999.bnf
.Ve
.PP
The following links provide further useful information about \s-1SQL.\s0
Some of these are rather dated now but may still be useful.
.PP
.Vb 3
\&  http://www.jcc.com/SQLPages/jccs_sql.htm
\&  http://www.contrib.andrew.cmu.edu/~shadow/sql.html
\&  http://www.altavista.com/query?q=sql+tutorial
.Ve
.SS "Books and Articles"
.IX Subsection "Books and Articles"
Programming the Perl \s-1DBI,\s0 by Alligator Descartes and Tim Bunce.
<http://books.perl.org/book/154>
.PP
Programming Perl 3rd Ed. by Larry Wall, Tom Christiansen & Jon Orwant.
<http://books.perl.org/book/134>
.PP
Learning Perl by Randal Schwartz.
<http://books.perl.org/book/101>
.PP
Details of many other books related to perl can be found at <http://books.perl.org>
.SS "Perl Modules"
.IX Subsection "Perl Modules"
Index of \s-1DBI\s0 related modules available from \s-1CPAN:\s0
.PP
.Vb 3
\& https://metacpan.org/search?q=DBD%3A%3A
\& https://metacpan.org/search?q=DBIx%3A%3A
\& https://metacpan.org/search?q=DBI
.Ve
.PP
For a good comparison of RDBMS-OO mappers and some OO-RDBMS mappers
(including Class::DBI, Alzabo, and DBIx::RecordSet in the former
category and Tangram and \s-1SPOPS\s0 in the latter) see the Perl
Object-Oriented Persistence project pages at:
.PP
.Vb 1
\& http://poop.sourceforge.net
.Ve
.PP
A similar page for Java toolkits can be found at:
.PP
.Vb 1
\& http://c2.com/cgi\-bin/wiki?ObjectRelationalToolComparison
.Ve
.SS "Mailing List"
.IX Subsection "Mailing List"
The \fIdbi-users\fR mailing list is the primary means of communication among
users of the \s-1DBI\s0 and its related modules. For details send email to:
.PP
.Vb 1
\& dbi\-users\-help@perl.org
.Ve
.PP
There are typically between 700 and 900 messages per month.  You have
to subscribe in order to be able to post. However you can opt for a
\&'post\-only' subscription.
.PP
Mailing list archives (of variable quality) are held at:
.PP
.Vb 3
\& http://groups.google.com/groups?group=perl.dbi.users
\& http://www.xray.mpe.mpg.de/mailing\-lists/dbi/
\& http://www.mail\-archive.com/dbi\-users%40perl.org/
.Ve
.SS "Assorted Related \s-1WWW\s0 Links"
.IX Subsection "Assorted Related WWW Links"
The \s-1DBI \s0\*(L"Home Page\*(R":
.PP
.Vb 1
\& http://dbi.perl.org/
.Ve
.PP
Other \s-1DBI\s0 related links:
.PP
.Vb 7
\& http://tegan.deltanet.com/~phlip/DBUIdoc.html
\& http://dc.pm.org/perl_db.html
\& http://wdvl.com/Authoring/DB/Intro/toc.html
\& http://www.hotwired.com/webmonkey/backend/tutorials/tutorial1.html
\& http://bumppo.net/lists/macperl/1999/06/msg00197.html
\& http://www.perlmonks.org/?node=DBI%20recipes
\& http://www.perlmonks.org/?node=Speeding%20up%20the%20DBI
.Ve
.PP
Other database related links:
.PP
.Vb 3
\& http://www.jcc.com/sql_stnd.html
\& http://cuiwww.unige.ch/OSG/info/FreeDB/FreeDB.home.html
\& http://www.connectionstrings.com/
.Ve
.PP
Security, especially the \*(L"\s-1SQL\s0 Injection\*(R" attack:
.PP
.Vb 7
\& http://www.ngssoftware.com/research/papers.html
\& http://www.ngssoftware.com/papers/advanced_sql_injection.pdf
\& http://www.ngssoftware.com/papers/more_advanced_sql_injection.pdf
\& http://www.esecurityplanet.com/trends/article.php/2243461
\& http://www.spidynamics.com/papers/SQLInjectionWhitePaper.pdf
\& http://www.imperva.com/application_defense_center/white_papers/blind_sql_server_injection.html
\& http://online.securityfocus.com/infocus/1644
.Ve
.PP
Commercial and Data Warehouse Links
.PP
.Vb 6
\& http://www.dwinfocenter.org
\& http://www.datawarehouse.com
\& http://www.datamining.org
\& http://www.olapcouncil.org
\& http://www.idwa.org
\& http://www.knowledgecenters.org/dwcenter.asp
.Ve
.PP
Recommended Perl Programming Links
.PP
.Vb 1
\& http://language.perl.com/style/
.Ve
.SS "\s-1FAQ\s0"
.IX Subsection "FAQ"
See <http://faq.dbi\-support.com/>
.SH "AUTHORS"
.IX Header "AUTHORS"
\&\s-1DBI\s0 by Tim Bunce, <http://www.tim.bunce.name>
.PP
This pod text by Tim Bunce, J. Douglas Dunlop, Jonathan Leffler and others.
Perl by Larry Wall and the \f(CW\*(C`perl5\-porters\*(C'\fR.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
The \s-1DBI\s0 module is Copyright (c) 1994\-2012 Tim Bunce. Ireland.
All rights reserved.
.PP
You may distribute under the terms of either the \s-1GNU\s0 General Public
License or the Artistic License, as specified in the Perl 5.10.0 \s-1README\s0 file.
.SH "SUPPORT / WARRANTY"
.IX Header "SUPPORT / WARRANTY"
The \s-1DBI\s0 is free Open Source software. \s-1IT COMES WITHOUT WARRANTY OF ANY KIND.\s0
.SS "Support"
.IX Subsection "Support"
My consulting company, Data Plan Services, offers annual and
multi-annual support contracts for the \s-1DBI.\s0 These provide sustained
support for \s-1DBI\s0 development, and sustained value for you in return.
Contact me for details.
.SS "Sponsor Enhancements"
.IX Subsection "Sponsor Enhancements"
If your company would benefit from a specific new \s-1DBI\s0 feature,
please consider sponsoring its development.  Work is performed
rapidly, and usually on a fixed-price payment-on-delivery basis.
Contact me for details.
.PP
Using such targeted financing allows you to contribute to \s-1DBI\s0
development, and rapidly get something specific and valuable in return.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
I would like to acknowledge the valuable contributions of the many
people I have worked with on the \s-1DBI\s0 project, especially in the early
years (1992\-1994). In no particular order: Kevin Stock, Buzz Moschetti,
Kurt Andersen, Ted Lemon, William Hails, Garth Kennedy, Michael Peppler,
Neil S. Briscoe, Jeff Urlwin, David J. Hughes, Jeff Stander,
Forrest D Whitcher, Larry Wall, Jeff Fried, Roy Johnson, Paul Hudson,
Georg Rehfeld, Steve Sizemore, Ron Pool, Jon Meek, Tom Christiansen,
Steve Baumgarten, Randal Schwartz, and a whole lot more.
.PP
Then, of course, there are the poor souls who have struggled through
untold and undocumented obstacles to actually implement \s-1DBI\s0 drivers.
Among their ranks are Jochen Wiedmann, Alligator Descartes, Jonathan
Leffler, Jeff Urlwin, Michael Peppler, Henrik Tougaard, Edwin Pratomo,
Davide Migliavacca, Jan Pazdziora, Peter Haworth, Edmund Mergl, Steve
Williams, Thomas Lowery, and Phlip Plumlee. Without them, the \s-1DBI\s0 would
not be the practical reality it is today.  I'm also especially grateful
to Alligator Descartes for starting work on the first edition of the
\&\*(L"Programming the Perl \s-1DBI\*(R"\s0 book and letting me jump on board.
.PP
The \s-1DBI\s0 and DBD::Oracle were originally developed while I was Technical
Director (\s-1CTO\s0) of the Paul Ingram Group in the \s-1UK. \s0 So I'd especially like
to thank Paul for his generosity and vision in supporting this work for many years.
.PP
A couple of specific \s-1DBI\s0 features have been sponsored by enlightened companies:
.PP
The development of the \fIswap_inner_handle()\fR method was sponsored by BizRate.com (<http://BizRate.com>)
.PP
The development of DBD::Gofer and related modules was sponsored by
Shopzilla.com (<http://Shopzilla.com>), where I currently work.
.SH "CONTRIBUTING"
.IX Header "CONTRIBUTING"
As you can see above, many people have contributed to the \s-1DBI\s0 and
drivers in many ways over many years.
.PP
If you'd like to help then see <http://dbi.perl.org/contributing>.
.PP
If you'd like the \s-1DBI\s0 to do something new or different then a good way
to make that happen is to do it yourself and send me a patch to the
source code that shows the changes. (But read \*(L"Speak before you patch\*(R"
below.)
.SS "Browsing the source code repository"
.IX Subsection "Browsing the source code repository"
Use https://github.com/perl5\-dbi/dbi
.SS "How to create a patch using Git"
.IX Subsection "How to create a patch using Git"
The \s-1DBI\s0 source code is maintained using Git.  To access the source
you'll need to install a Git client. Then, to get the source code, do:
.PP
.Vb 1
\&  git clone https://github.com/perl5\-dbi/dbi.git DBI\-git
.Ve
.PP
The source code will now be available in the new subdirectory \f(CW\*(C`DBI\-git\*(C'\fR.
.PP
When you want to synchronize later, issue the command
.PP
.Vb 1
\&  git pull \-\-all
.Ve
.PP
Make your changes, test them, test them again until everything passes.
If there are no tests for the new feature you added or a behaviour change,
the change should include a new test. Then commit the changes. Either use
.PP
.Vb 1
\&  git gui
.Ve
.PP
or
.PP
.Vb 1
\&  git commit \-a \-m \*(AqMessage to my changes\*(Aq
.Ve
.PP
If you get any conflicts reported you'll need to fix them first.
.PP
Then generate the patch file to be mailed:
.PP
.Vb 1
\&  git format\-patch \-1 \-\-attach
.Ve
.PP
which will create a file 0001\-*.patch (where * relates to the commit message).
Read the patch file, as a sanity check, and then email it to dbi\-dev@perl.org.
.PP
If you have a github <https://github.com> account, you can also fork the
repository, commit your changes to the forked repository and then do a
pull request.
.SS "How to create a patch without Git"
.IX Subsection "How to create a patch without Git"
Unpack a fresh copy of the distribution:
.PP
.Vb 2
\&  wget http://cpan.metacpan.org/authors/id/T/TI/TIMB/DBI\-1.627.tar.gz
\&  tar xfz DBI\-1.627.tar.gz
.Ve
.PP
Rename the newly created top level directory:
.PP
.Vb 1
\&  mv DBI\-1.627 DBI\-1.627.your_foo
.Ve
.PP
Edit the contents of \s-1DBI\-1.627\s0.your_foo/* till it does what you want.
.PP
Test your changes and then remove all temporary files:
.PP
.Vb 1
\&  make test && make distclean
.Ve
.PP
Go back to the directory you originally unpacked the distribution:
.PP
.Vb 1
\&  cd ..
.Ve
.PP
Unpack \fIanother\fR copy of the original distribution you started with:
.PP
.Vb 1
\&  tar xfz DBI\-1.627.tar.gz
.Ve
.PP
Then create a patch file by performing a recursive \f(CW\*(C`diff\*(C'\fR on the two
top level directories:
.PP
.Vb 1
\&  diff \-purd DBI\-1.627 DBI\-1.627.your_foo > DBI\-1.627.your_foo.patch
.Ve
.SS "Speak before you patch"
.IX Subsection "Speak before you patch"
For anything non-trivial or possibly controversial it's a good idea
to discuss (on dbi\-dev@perl.org) the changes you propose before
actually spending time working on them. Otherwise you run the risk
of them being rejected because they don't fit into some larger plans
you may not be aware of.
.PP
You can also reach the developers on \s-1IRC \s0(chat). If they are on-line,
the most likely place to talk to them is the #dbi channel on irc.perl.org
.SH "TRANSLATIONS"
.IX Header "TRANSLATIONS"
A German translation of this manual (possibly slightly out of date) is
available, thanks to O'Reilly, at:
.PP
.Vb 1
\&  http://www.oreilly.de/catalog/perldbiger/
.Ve
.PP
Some other translations:
.PP
.Vb 2
\& http://cronopio.net/perl/                              \- Spanish
\& http://member.nifty.ne.jp/hippo2000/dbimemo.htm        \- Japanese
.Ve
.SH "TRAINING"
.IX Header "TRAINING"
References to \s-1DBI\s0 related training resources. No recommendation implied.
.PP
.Vb 2
\&  http://www.treepax.co.uk/
\&  http://www.keller.com/dbweb/
.Ve
.PP
(If you offer professional \s-1DBI\s0 related training services,
please send me your details so I can add them here.)
.SH "OTHER RELATED WORK AND PERL MODULES"
.IX Header "OTHER RELATED WORK AND PERL MODULES"
.IP "Apache::DBI by E.Mergl@bawue.de" 4
.IX Item "Apache::DBI by E.Mergl@bawue.de"
To be used with the Apache daemon together with an embedded Perl
interpreter like \f(CW\*(C`mod_perl\*(C'\fR. Establishes a database connection which
remains open for the lifetime of the \s-1HTTP\s0 daemon. This way the \s-1CGI\s0
connect and disconnect for every database access becomes superfluous.
.IP "\s-1SQL\s0 Parser" 4
.IX Item "SQL Parser"
See also the SQL::Statement module, \s-1SQL\s0 parser and engine.
                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::Const::GetInfo::ANSI.3pm                0100644 0001750 0001750 00000012067 12566241601 025372  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::Const::GetInfo::ANSI 3"
.TH DBI::Const::GetInfo::ANSI 3 "2013-06-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::Const::GetInfo::ANSI \- ISO/IEC SQL/CLI Constants for GetInfo
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  The API for this module is private and subject to change.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Information requested by \fIGetInfo()\fR.
.PP
See: A.1 C header file \s-1SQLCLI.H,\s0 Page 316, 317.
.PP
The \s-1API\s0 for this module is private and subject to change.
.SH "REFERENCES"
.IX Header "REFERENCES"
.Vb 2
\&  ISO/IEC FCD 9075\-3:200x Information technology \- Database Languages \-
\&  SQL \- Part 3: Call\-Level Interface (SQL/CLI)
\&
\&  SC32 N00744 = WG3:VIE\-005 = H2\-2002\-007
\&
\&  Date: 2002\-01\-15
.Ve
.ie n .SS "%ReturnTypes"
.el .SS "\f(CW%ReturnTypes\fP"
.IX Subsection "%ReturnTypes"
See: Codes and data types for implementation information (Table 28), Page 85, 86.
.PP
Mapped to \s-1ODBC\s0 datatype names.
.ie n .SS "%ReturnValues"
.el .SS "\f(CW%ReturnValues\fP"
.IX Subsection "%ReturnValues"
See: A.1 C header file \s-1SQLCLI.H,\s0 Page 317, 318.
.SH "TODO"
.IX Header "TODO"
Corrections, e.g.:
.PP
.Vb 1
\&  SQL_TRANSACTION_ISOLATION_OPTION vs. SQL_TRANSACTION_ISOLATION
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::Const::GetInfo::ANSI5.16.3pm            0100644 0001750 0001750 00000011546 12566241577 025721  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::Const::GetInfo::ANSI 3"
.TH DBI::Const::GetInfo::ANSI 3 "2007-01-24" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::Const::GetInfo::ANSI \- ISO/IEC SQL/CLI Constants for GetInfo
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  The API for this module is private and subject to change.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Information requested by \fIGetInfo()\fR.
.PP
See: A.1 C header file \s-1SQLCLI\s0.H, Page 316, 317.
.PP
The \s-1API\s0 for this module is private and subject to change.
.SH "REFERENCES"
.IX Header "REFERENCES"
.Vb 2
\&  ISO/IEC FCD 9075\-3:200x Information technology \- Database Languages \-
\&  SQL \- Part 3: Call\-Level Interface (SQL/CLI)
\&
\&  SC32 N00744 = WG3:VIE\-005 = H2\-2002\-007
\&
\&  Date: 2002\-01\-15
.Ve
.ie n .SS "%ReturnTypes"
.el .SS "\f(CW%ReturnTypes\fP"
.IX Subsection "%ReturnTypes"
See: Codes and data types for implementation information (Table 28), Page 85, 86.
.PP
Mapped to \s-1ODBC\s0 datatype names.
.ie n .SS "%ReturnValues"
.el .SS "\f(CW%ReturnValues\fP"
.IX Subsection "%ReturnValues"
See: A.1 C header file \s-1SQLCLI\s0.H, Page 317, 318.
.SH "TODO"
.IX Header "TODO"
Corrections, e.g.:
.PP
.Vb 1
\&  SQL_TRANSACTION_ISOLATION_OPTION vs. SQL_TRANSACTION_ISOLATION
.Ve
                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::Const::GetInfo::ANSI5.18.3pm            0100644 0001750 0001750 00000012067 12566241601 025706  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::Const::GetInfo::ANSI 3"
.TH DBI::Const::GetInfo::ANSI 3 "2013-06-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::Const::GetInfo::ANSI \- ISO/IEC SQL/CLI Constants for GetInfo
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  The API for this module is private and subject to change.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Information requested by \fIGetInfo()\fR.
.PP
See: A.1 C header file \s-1SQLCLI.H,\s0 Page 316, 317.
.PP
The \s-1API\s0 for this module is private and subject to change.
.SH "REFERENCES"
.IX Header "REFERENCES"
.Vb 2
\&  ISO/IEC FCD 9075\-3:200x Information technology \- Database Languages \-
\&  SQL \- Part 3: Call\-Level Interface (SQL/CLI)
\&
\&  SC32 N00744 = WG3:VIE\-005 = H2\-2002\-007
\&
\&  Date: 2002\-01\-15
.Ve
.ie n .SS "%ReturnTypes"
.el .SS "\f(CW%ReturnTypes\fP"
.IX Subsection "%ReturnTypes"
See: Codes and data types for implementation information (Table 28), Page 85, 86.
.PP
Mapped to \s-1ODBC\s0 datatype names.
.ie n .SS "%ReturnValues"
.el .SS "\f(CW%ReturnValues\fP"
.IX Subsection "%ReturnValues"
See: A.1 C header file \s-1SQLCLI.H,\s0 Page 317, 318.
.SH "TODO"
.IX Header "TODO"
Corrections, e.g.:
.PP
.Vb 1
\&  SQL_TRANSACTION_ISOLATION_OPTION vs. SQL_TRANSACTION_ISOLATION
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::Const::GetInfo::ODBC.3pm                0100644 0001750 0001750 00000011641 12566241601 025344  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::Const::GetInfo::ODBC 3"
.TH DBI::Const::GetInfo::ODBC 3 "2013-06-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::Const::GetInfo::ODBC \- ODBC Constants for GetInfo
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& The API for this module is private and subject to change.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Information requested by \fIGetInfo()\fR.
.PP
The \s-1API\s0 for this module is private and subject to change.
.SH "REFERENCES"
.IX Header "REFERENCES"
.Vb 2
\&  MDAC SDK 2.6
\&  ODBC version number (0x0351)
\&
\&  sql.h
\&  sqlext.h
.Ve
.ie n .SS "%ReturnTypes"
.el .SS "\f(CW%ReturnTypes\fP"
.IX Subsection "%ReturnTypes"
See: mk:@MSITStore:X:\edm\ecli\emdac\esdk26\eDocs\eodbc.chm::/htm/odbcsqlgetinfo.htm
.PP
.Vb 2
\&  =>     : alias
\&  => !!! : edited
.Ve
.ie n .SS "%ReturnValues"
.el .SS "\f(CW%ReturnValues\fP"
.IX Subsection "%ReturnValues"
See: sql.h, sqlext.h
Edited:
  \s-1SQL_TXN_ISOLATION_OPTION\s0
.SH "TODO"
.IX Header "TODO"
.Vb 3
\&  Corrections?
\&  SQL_NULL_COLLATION: ODBC vs ANSI
\&  Unique values for $ReturnValues{...}?, e.g. SQL_FILE_USAGE
.Ve
                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::Const::GetInfo::ODBC5.16.3pm            0100644 0001750 0001750 00000011320 12566241577 025664  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::Const::GetInfo::ODBC 3"
.TH DBI::Const::GetInfo::ODBC 3 "2008-06-02" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::Const::GetInfo::ODBC \- ODBC Constants for GetInfo
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& The API for this module is private and subject to change.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Information requested by \fIGetInfo()\fR.
.PP
The \s-1API\s0 for this module is private and subject to change.
.SH "REFERENCES"
.IX Header "REFERENCES"
.Vb 2
\&  MDAC SDK 2.6
\&  ODBC version number (0x0351)
\&
\&  sql.h
\&  sqlext.h
.Ve
.ie n .SS "%ReturnTypes"
.el .SS "\f(CW%ReturnTypes\fP"
.IX Subsection "%ReturnTypes"
See: mk:@MSITStore:X:\edm\ecli\emdac\esdk26\eDocs\eodbc.chm::/htm/odbcsqlgetinfo.htm
.PP
.Vb 2
\&  =>     : alias
\&  => !!! : edited
.Ve
.ie n .SS "%ReturnValues"
.el .SS "\f(CW%ReturnValues\fP"
.IX Subsection "%ReturnValues"
See: sql.h, sqlext.h
Edited:
  \s-1SQL_TXN_ISOLATION_OPTION\s0
.SH "TODO"
.IX Header "TODO"
.Vb 3
\&  Corrections?
\&  SQL_NULL_COLLATION: ODBC vs ANSI
\&  Unique values for $ReturnValues{...}?, e.g. SQL_FILE_USAGE
.Ve
                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::Const::GetInfo::ODBC5.18.3pm            0100644 0001750 0001750 00000011641 12566241601 025660  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::Const::GetInfo::ODBC 3"
.TH DBI::Const::GetInfo::ODBC 3 "2013-06-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::Const::GetInfo::ODBC \- ODBC Constants for GetInfo
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& The API for this module is private and subject to change.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Information requested by \fIGetInfo()\fR.
.PP
The \s-1API\s0 for this module is private and subject to change.
.SH "REFERENCES"
.IX Header "REFERENCES"
.Vb 2
\&  MDAC SDK 2.6
\&  ODBC version number (0x0351)
\&
\&  sql.h
\&  sqlext.h
.Ve
.ie n .SS "%ReturnTypes"
.el .SS "\f(CW%ReturnTypes\fP"
.IX Subsection "%ReturnTypes"
See: mk:@MSITStore:X:\edm\ecli\emdac\esdk26\eDocs\eodbc.chm::/htm/odbcsqlgetinfo.htm
.PP
.Vb 2
\&  =>     : alias
\&  => !!! : edited
.Ve
.ie n .SS "%ReturnValues"
.el .SS "\f(CW%ReturnValues\fP"
.IX Subsection "%ReturnValues"
See: sql.h, sqlext.h
Edited:
  \s-1SQL_TXN_ISOLATION_OPTION\s0
.SH "TODO"
.IX Header "TODO"
.Vb 3
\&  Corrections?
\&  SQL_NULL_COLLATION: ODBC vs ANSI
\&  Unique values for $ReturnValues{...}?, e.g. SQL_FILE_USAGE
.Ve
                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::Const::GetInfoReturn.3pm                0100644 0001750 0001750 00000010344 12566241601 025727  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::Const::GetInfoReturn 3"
.TH DBI::Const::GetInfoReturn 3 "2013-06-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::Const::GetInfoReturn \- Data and functions for describing GetInfo results
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The interface to this module is undocumented and liable to change.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Data and functions for describing GetInfo results
                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::Const::GetInfoReturn5.16.3pm            0100644 0001750 0001750 00000010023 12566241600 026232  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::Const::GetInfoReturn 3"
.TH DBI::Const::GetInfoReturn 3 "2007-01-24" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::Const::GetInfoReturn \- Data and functions for describing GetInfo results
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The interface to this module is undocumented and liable to change.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Data and functions for describing GetInfo results
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::Const::GetInfoReturn5.18.3pm            0100644 0001750 0001750 00000010344 12566241601 026243  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::Const::GetInfoReturn 3"
.TH DBI::Const::GetInfoReturn 3 "2013-06-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::Const::GetInfoReturn \- Data and functions for describing GetInfo results
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The interface to this module is undocumented and liable to change.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Data and functions for describing GetInfo results
                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::Const::GetInfoType.3pm                  0100644 0001750 0001750 00000010673 12566241601 025376  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::Const::GetInfoType 3"
.TH DBI::Const::GetInfoType 3 "2013-06-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::Const::GetInfoType \- Data describing GetInfo type codes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use DBI::Const::GetInfoType;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Imports a \f(CW%GetInfoType\fR hash which maps names for GetInfo Type Codes
into their corresponding numeric values. For example:
.PP
.Vb 1
\&  $database_version = $dbh\->get_info( $GetInfoType{SQL_DBMS_VER} );
.Ve
.PP
The interface to this module is new and nothing beyond what is
written here is guaranteed.
                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::Const::GetInfoType5.16.3pm              0100644 0001750 0001750 00000010352 12566241577 025716  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::Const::GetInfoType 3"
.TH DBI::Const::GetInfoType 3 "2007-01-24" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::Const::GetInfoType \- Data describing GetInfo type codes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use DBI::Const::GetInfoType;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Imports a \f(CW%GetInfoType\fR hash which maps names for GetInfo Type Codes
into their corresponding numeric values. For example:
.PP
.Vb 1
\&  $database_version = $dbh\->get_info( $GetInfoType{SQL_DBMS_VER} );
.Ve
.PP
The interface to this module is new and nothing beyond what is
written here is guaranteed.
                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::Const::GetInfoType5.18.3pm              0100644 0001750 0001750 00000010673 12566241601 025712  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::Const::GetInfoType 3"
.TH DBI::Const::GetInfoType 3 "2013-06-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::Const::GetInfoType \- Data describing GetInfo type codes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use DBI::Const::GetInfoType;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Imports a \f(CW%GetInfoType\fR hash which maps names for GetInfo Type Codes
into their corresponding numeric values. For example:
.PP
.Vb 1
\&  $database_version = $dbh\->get_info( $GetInfoType{SQL_DBMS_VER} );
.Ve
.PP
The interface to this module is new and nothing beyond what is
written here is guaranteed.
                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::DBD.3pm                                 0100644 0001750 0001750 00000430645 12566241602 022405  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::DBD 3"
.TH DBI::DBD 3 "2013-06-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::DBD \- Perl DBI Database Driver Writer's Guide
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  perldoc DBI::DBD
.Ve
.SS "Version and volatility"
.IX Subsection "Version and volatility"
This document is \fIstill\fR a minimal draft which is in need of further work.
.PP
The changes will occur both because the \fB\s-1DBI\s0\fR specification is changing
and hence the requirements on \fB\s-1DBD\s0\fR drivers change, and because feedback
from people reading this document will suggest improvements to it.
.PP
Please read the \fB\s-1DBI\s0\fR documentation first and fully, including the \fB\s-1DBI\s0\fR \s-1FAQ.\s0
Then reread the \fB\s-1DBI\s0\fR specification again as you're reading this. It'll help.
.PP
This document is a patchwork of contributions from various authors.
More contributions (preferably as patches) are very welcome.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document is primarily intended to help people writing new
database drivers for the Perl Database Interface (Perl \s-1DBI\s0).
It may also help others interested in discovering why the internals of
a \fB\s-1DBD\s0\fR driver are written the way they are.
.PP
This is a guide.  Few (if any) of the statements in it are completely
authoritative under all possible circumstances.  This means you will
need to use judgement in applying the guidelines in this document.
If in \fIany\fR doubt at all, please do contact the \fIdbi-dev\fR mailing list
(details given below) where Tim Bunce and other driver authors can help.
.SH "CREATING A NEW DRIVER"
.IX Header "CREATING A NEW DRIVER"
The first rule for creating a new database driver for the Perl \s-1DBI\s0 is
very simple: \fB\s-1DON\s0'T!\fR
.PP
There is usually a driver already available for the database you want
to use, almost regardless of which database you choose. Very often, the
database will provide an \s-1ODBC\s0 driver interface, so you can often use
\&\fB\s-1DBD::ODBC\s0\fR to access the database. This is typically less convenient
on a Unix box than on a Microsoft Windows box, but there are numerous
options for \s-1ODBC\s0 driver managers on Unix too, and very often the \s-1ODBC\s0
driver is provided by the database supplier.
.PP
Before deciding that you need to write a driver, do your homework to
ensure that you are not wasting your energies.
.PP
[As of December 2002, the consensus is that if you need an \s-1ODBC\s0 driver
manager on Unix, then the unixODBC driver (available from
<http://www.unixodbc.org/>) is the way to go.]
.PP
The second rule for creating a new database driver for the Perl \s-1DBI\s0 is
also very simple: \fBDon't \*(-- get someone else to do it for you!\fR
.PP
Nevertheless, there are occasions when it is necessary to write a new
driver, often to use a proprietary language or \s-1API\s0 to access the
database more swiftly, or more comprehensively, than an \s-1ODBC\s0 driver can.
Then you should read this document very carefully, but with a suitably
sceptical eye.
.PP
If there is something in here that does not make any sense, question it.
You might be right that the information is bogus, but don't come to that
conclusion too quickly.
.SS "URLs and mailing lists"
.IX Subsection "URLs and mailing lists"
The primary web-site for locating \fB\s-1DBI\s0\fR software and information is
.PP
.Vb 1
\&  http://dbi.perl.org/
.Ve
.PP
There are two main and one auxiliary mailing lists for people working
with \fB\s-1DBI\s0\fR.  The primary lists are \fIdbi\-users@perl.org\fR for general users
of \fB\s-1DBI\s0\fR and \fB\s-1DBD\s0\fR drivers, and \fIdbi\-dev@perl.org\fR mainly for \fB\s-1DBD\s0\fR driver
writers (don't join the \fIdbi-dev\fR list unless you have a good reason).
The auxiliary list is \fIdbi\-announce@perl.org\fR for announcing new
releases of \fB\s-1DBI\s0\fR or \fB\s-1DBD\s0\fR drivers.
.PP
You can join these lists by accessing the web-site <http://dbi.perl.org/>.
The lists are closed so you cannot send email to any of the lists
unless you join the list first.
.PP
You should also consider monitoring the \fIcomp.lang.perl.*\fR newsgroups,
especially \fIcomp.lang.perl.modules\fR.
.SS "The Cheetah book"
.IX Subsection "The Cheetah book"
The definitive book on Perl \s-1DBI\s0 is the Cheetah book, so called because
of the picture on the cover. Its proper title is '\fIProgramming the
Perl \s-1DBI:\s0 Database programming with Perl\fR' by Alligator Descartes
and Tim Bunce, published by O'Reilly Associates, February 2000, \s-1ISBN
1\-56592\-699\-4.\s0 Buy it now if you have not already done so, and read it.
.SS "Locating drivers"
.IX Subsection "Locating drivers"
Before writing a new driver, it is in your interests to find out
whether there already is a driver for your database.  If there is such
a driver, it would be much easier to make use of it than to write your
own!
.PP
The primary web-site for locating Perl software is
<http://search.cpan.org/>.  You should look under the various
modules listings for the software you are after. For example:
.PP
.Vb 1
\&  http://search.cpan.org/modlist/Database_Interfaces
.Ve
.PP
Follow the \fB\s-1DBD::\s0\fR and \fBDBIx::\fR links at the top to see those subsets.
.PP
See the \fB\s-1DBI\s0\fR docs for information on \fB\s-1DBI\s0\fR web sites and mailing lists.
.SS "Registering a new driver"
.IX Subsection "Registering a new driver"
Before going through any official registration process, you will need
to establish that there is no driver already in the works. You'll do
that by asking the \fB\s-1DBI\s0\fR mailing lists whether there is such a driver
available, or whether anybody is working on one.
.PP
When you get the go ahead, you will need to establish the name of the
driver and a prefix for the driver. Typically, the name is based on the
name of the database software it uses, and the prefix is a contraction
of that. Hence, \fBDBD::Oracle\fR has the name \fIOracle\fR and the prefix
\&'\fIora_\fR'. The prefix must be lowercase and contain no underscores other
than the one at the end.
.PP
This information will be recorded in the \fB\s-1DBI\s0\fR module. Apart from
documentation purposes, registration is a prerequisite for
installing private methods.
.PP
If you are writing a driver which will not be distributed on \s-1CPAN,\s0 then
you should choose a prefix beginning with '\fIx_\fR', to avoid potential
prefix collisions with drivers registered in the future. Thus, if you
wrote a non-CPAN distributed driver called \fBDBD::CustomDB\fR, the prefix
might be '\fIx_cdb_\fR'.
.PP
This document assumes you are writing a driver called \fBDBD::Driver\fR, and
that the prefix '\fIdrv_\fR' is assigned to the driver.
.SS "Two styles of database driver"
.IX Subsection "Two styles of database driver"
There are two distinct styles of database driver that can be written to
work with the Perl \s-1DBI.\s0
.PP
Your driver can be written in pure Perl, requiring no C compiler.
When feasible, this is the best solution, but most databases are not
written in such a way that this can be done. Some examples of pure
Perl drivers are \fBDBD::File\fR and \fB\s-1DBD::CSV\s0\fR.
.PP
Alternatively, and most commonly, your driver will need to use some C
code to gain access to the database. This will be classified as a C/XS
driver.
.SS "What code will you write?"
.IX Subsection "What code will you write?"
There are a number of files that need to be written for either a pure
Perl driver or a C/XS driver. There are no extra files needed only by
a pure Perl driver, but there are several extra files needed only by a
C/XS driver.
.PP
\fIFiles common to pure Perl and C/XS drivers\fR
.IX Subsection "Files common to pure Perl and C/XS drivers"
.PP
Assuming that your driver is called \fBDBD::Driver\fR, these files are:
.IP "\(bu" 4
\&\fIMakefile.PL\fR
.IP "\(bu" 4
\&\fI\s-1META\s0.yml\fR
.IP "\(bu" 4
\&\fI\s-1README\s0\fR
.IP "\(bu" 4
\&\fI\s-1MANIFEST\s0\fR
.IP "\(bu" 4
\&\fIDriver.pm\fR
.IP "\(bu" 4
\&\fIlib/Bundle/DBD/Driver.pm\fR
.IP "\(bu" 4
\&\fIlib/DBD/Driver/Summary.pm\fR
.IP "\(bu" 4
\&\fIt/*.t\fR
.PP
The first four files are mandatory. \fIMakefile.PL\fR is used to control
how the driver is built and installed. The \fI\s-1README\s0\fR file tells people
who download the file about how to build the module and any prerequisite
software that must be installed. The \fI\s-1MANIFEST\s0\fR file is used by the
standard Perl module distribution mechanism. It lists all the source
files that need to be distributed with your module. \fIDriver.pm\fR is what
is loaded by the \fB\s-1DBI\s0\fR code; it contains the methods peculiar to your
driver.
.PP
Although the \fI\s-1META\s0.yml\fR file is not \fBrequired\fR you are advised to
create one. Of particular importance are the \fIbuild_requires\fR and
\&\fIconfigure_requires\fR attributes which newer \s-1CPAN\s0 modules understand.
You use these to tell the \s-1CPAN\s0 module (and \s-1CPANPLUS\s0) that your build
and configure mechanisms require \s-1DBI.\s0 The best reference for \s-1META\s0.yml
(at the time of writing) is
<http://module\-build.sourceforge.net/META\-spec\-v1.4.html>. You can find
a reasonable example of a \fI\s-1META\s0.yml\fR in \s-1DBD::ODBC.\s0
.PP
The \fIlib/Bundle/DBD/Driver.pm\fR file allows you to specify other Perl
modules on which yours depends in a format that allows someone to type a
simple command and ensure that all the pre-requisites are in place as
well as building your driver.
.PP
The \fIlib/DBD/Driver/Summary.pm\fR file contains (an updated version of) the
information that was included \- or that would have been included \- in
the appendices of the Cheetah book as a summary of the abilities of your
driver and the associated database.
.PP
The files in the \fIt\fR subdirectory are unit tests for your driver.
You should write your tests as stringently as possible, while taking
into account the diversity of installations that you can encounter:
.IP "\(bu" 4
Your tests should not casually modify operational databases.
.IP "\(bu" 4
You should never damage existing tables in a database.
.IP "\(bu" 4
You should code your tests to use a constrained name space within the
database. For example, the tables (and all other named objects) that are
created could all begin with '\fIdbd_drv_\fR'.
.IP "\(bu" 4
At the end of a test run, there should be no testing objects left behind
in the database.
.IP "\(bu" 4
If you create any databases, you should remove them.
.IP "\(bu" 4
If your database supports temporary tables that are automatically
removed at the end of a session, then exploit them as often as possible.
.IP "\(bu" 4
Try to make your tests independent of each other. If you have a
test \fIt/t11dowhat.t\fR that depends upon the successful running
of \fIt/t10thingamy.t\fR, people cannot run the single test case
\&\fIt/t11dowhat.t\fR. Further, running \fIt/t11dowhat.t\fR twice in a row is
likely to fail (at least, if \fIt/t11dowhat.t\fR modifies the database at
all) because the database at the start of the second run is not what you
saw at the start of the first run.
.IP "\(bu" 4
Document in your \fI\s-1README\s0\fR file what you do, and what privileges people
need to do it.
.IP "\(bu" 4
You can, and probably should, sequence your tests by including a test
number before an abbreviated version of the test name; the tests are run
in the order in which the names are expanded by shell-style globbing.
.IP "\(bu" 4
It is in your interests to ensure that your tests work as widely
as possible.
.PP
Many drivers also install sub-modules \fBDBD::Driver::SubModule\fR
for any of a variety of different reasons, such as to support
the metadata methods (see the discussion of \*(L"\s-1METADATA METHODS\*(R"\s0
below). Such sub-modules are conventionally stored in the directory
\&\fIlib/DBD/Driver\fR. The module itself would usually be in a file
\&\fISubModule.pm\fR. All such sub-modules should themselves be version
stamped (see the discussions far below).
.PP
\fIExtra files needed by C/XS drivers\fR
.IX Subsection "Extra files needed by C/XS drivers"
.PP
The software for a C/XS driver will typically contain at least four
extra files that are not relevant to a pure Perl driver.
.IP "\(bu" 4
\&\fIDriver.xs\fR
.IP "\(bu" 4
\&\fIDriver.h\fR
.IP "\(bu" 4
\&\fIdbdimp.h\fR
.IP "\(bu" 4
\&\fIdbdimp.c\fR
.PP
The \fIDriver.xs\fR file is used to generate C code that Perl can call to gain
access to the C functions you write that will, in turn, call down onto
your database software.
.PP
The \fIDriver.h\fR header is a stylized header that ensures you can access the
necessary Perl and \fB\s-1DBI\s0\fR macros, types, and function declarations.
.PP
The \fIdbdimp.h\fR is used to specify which functions have been implemented by
your driver.
.PP
The \fIdbdimp.c\fR file is where you write the C code that does the real work
of translating between Perl-ish data types and what the database expects
to use and return.
.PP
There are some (mainly small, but very important) differences between
the contents of \fIMakefile.PL\fR and \fIDriver.pm\fR for pure Perl and C/XS
drivers, so those files are described both in the section on creating a
pure Perl driver and in the section on creating a C/XS driver.
.PP
Obviously, you can add extra source code files to the list.
.SS "Requirements on a driver and driver writer"
.IX Subsection "Requirements on a driver and driver writer"
To be remotely useful, your driver must be implemented in a format that
allows it to be distributed via \s-1CPAN,\s0 the Comprehensive Perl Archive
Network (<http://www.cpan.org/> and <http://search.cpan.org>).
Of course, it is easier if you do not have to meet this criterion, but
you will not be able to ask for much help if you do not do so, and
no-one is likely to want to install your module if they have to learn a
new installation mechanism.
.SH "CREATING A PURE PERL DRIVER"
.IX Header "CREATING A PURE PERL DRIVER"
Writing a pure Perl driver is surprisingly simple. However, there are
some problems you should be aware of. The best option is of course
picking up an existing driver and carefully modifying one method
after the other.
.PP
Also look carefully at \fBDBD::AnyData\fR and \fBDBD::Template\fR.
.PP
As an example we take a look at the \fBDBD::File\fR driver, a driver for
accessing plain files as tables, which is part of the \fB\s-1DBD::CSV\s0\fR package.
.PP
The minimal set of files we have to implement are \fIMakefile.PL\fR,
\&\fI\s-1README\s0\fR, \fI\s-1MANIFEST\s0\fR and \fIDriver.pm\fR.
.SS "Pure Perl version of Makefile.PL"
.IX Subsection "Pure Perl version of Makefile.PL"
You typically start with writing \fIMakefile.PL\fR, a Makefile
generator. The contents of this file are described in detail in
the ExtUtils::MakeMaker man pages. It is definitely a good idea
if you start reading them. At least you should know about the
variables \fI\s-1CONFIGURE\s0\fR, \fI\s-1DEFINED\s0\fR, \fI\s-1PM\s0\fR, \fI\s-1DIR\s0\fR, \fI\s-1EXE_FILES\s0\fR,
\&\fI\s-1INC\s0\fR, \fI\s-1LIBS\s0\fR, \fI\s-1LINKTYPE\s0\fR, \fI\s-1NAME\s0\fR, \fI\s-1OPTIMIZE\s0\fR, \fI\s-1PL_FILES\s0\fR,
\&\fI\s-1VERSION\s0\fR, \fI\s-1VERSION_FROM\s0\fR, \fIclean\fR, \fIdepend\fR, \fIrealclean\fR from
the ExtUtils::MakeMaker man page: these are used in almost any
\&\fIMakefile.PL\fR.
.PP
Additionally read the section on \fIOverriding MakeMaker Methods\fR and the
descriptions of the \fIdistcheck\fR, \fIdisttest\fR and \fIdist\fR targets: They
will definitely be useful for you.
.PP
Of special importance for \fB\s-1DBI\s0\fR drivers is the \fIpostamble\fR method from
the ExtUtils::MM_Unix man page.
.PP
For Emacs users, I recommend the \fIlibscan\fR method, which removes
Emacs backup files (file names which end with a tilde '~') from lists of
files.
.PP
Now an example, I use the word \f(CW\*(C`Driver\*(C'\fR wherever you should insert
your driver's name:
.PP
.Vb 1
\&  # \-*\- perl \-*\-
\&
\&  use ExtUtils::MakeMaker;
\&
\&  WriteMakefile(
\&      dbd_edit_mm_attribs( {
\&          \*(AqNAME\*(Aq         => \*(AqDBD::Driver\*(Aq,
\&          \*(AqVERSION_FROM\*(Aq => \*(AqDriver.pm\*(Aq,
\&          \*(AqINC\*(Aq          => \*(Aq\*(Aq,
\&          \*(Aqdist\*(Aq         => { \*(AqSUFFIX\*(Aq   => \*(Aq.gz\*(Aq,
\&                              \*(AqCOMPRESS\*(Aq => \*(Aqgzip \-9f\*(Aq },
\&          \*(Aqrealclean\*(Aq    => { FILES => \*(Aq*.xsi\*(Aq },
\&          \*(AqPREREQ_PM\*(Aq    => \*(Aq1.03\*(Aq,
\&          \*(AqCONFIGURE\*(Aq    => sub {
\&              eval {require DBI::DBD;};
\&              if ($@) {
\&                  warn $@;
\&                  exit 0;
\&              }
\&              my $dbi_arch_dir = dbd_dbi_arch_dir();
\&              if (exists($opts{INC})) {
\&                  return {INC => "$opts{INC} \-I$dbi_arch_dir"};
\&              } else {
\&                  return {INC => "\-I$dbi_arch_dir"};
\&              }
\&          }
\&      },
\&      { create_pp_tests => 1})
\&  );
\&
\&  package MY;
\&  sub postamble { return main::dbd_postamble(@_); }
\&  sub libscan {
\&      my ($self, $path) = @_;
\&      ($path =~ m/\e~$/) ? undef : $path;
\&  }
.Ve
.PP
Note the calls to \f(CW\*(C`dbd_edit_mm_attribs()\*(C'\fR and \f(CW\*(C`dbd_postamble()\*(C'\fR.
.PP
The second hash reference in the call to \f(CW\*(C`dbd_edit_mm_attribs()\*(C'\fR
(containing \f(CW\*(C`create_pp_tests()\*(C'\fR) is optional; you should not use it
unless your driver is a pure Perl driver (that is, it does not use C and
\&\s-1XS\s0 code). Therefore, the call to \f(CW\*(C`dbd_edit_mm_attribs()\*(C'\fR is not
relevant for C/XS drivers and may be omitted; simply use the (single)
hash reference containing \s-1NAME\s0 etc as the only argument to \f(CW\*(C`WriteMakefile()\*(C'\fR.
.PP
Note that the \f(CW\*(C`dbd_edit_mm_attribs()\*(C'\fR code will fail if you do not have a
\&\fIt\fR sub-directory containing at least one test case.
.PP
\&\fI\s-1PREREQ_PM\s0\fR tells MakeMaker that \s-1DBI \s0(version 1.03 in this case) is
required for this module. This will issue a warning that \s-1DBI 1.03\s0 is
missing if someone attempts to install your \s-1DBD\s0 without \s-1DBI 1.03.\s0 See
\&\fI\s-1CONFIGURE\s0\fR below for why this does not work reliably in stopping cpan
testers failing your module if \s-1DBI\s0 is not installed.
.PP
\&\fI\s-1CONFIGURE\s0\fR is a subroutine called by MakeMaker during
\&\f(CW\*(C`WriteMakefile\*(C'\fR.  By putting the \f(CW\*(C`require DBI::DBD\*(C'\fR in this section
we can attempt to load \s-1DBI::DBD\s0 but if it is missing we exit with
success. As we exit successfully without creating a Makefile when
\&\s-1DBI::DBD\s0 is missing cpan testers will not report a failure. This may
seem at odds with \fI\s-1PREREQ_PM\s0\fR but \fI\s-1PREREQ_PM\s0\fR does not cause
\&\f(CW\*(C`WriteMakefile\*(C'\fR to fail (unless you also specify \s-1PREREQ_FATAL\s0 which
is strongly discouraged by MakeMaker) so \f(CW\*(C`WriteMakefile\*(C'\fR would
continue to call \f(CW\*(C`dbd_dbi_arch_dir\*(C'\fR and fail.
.PP
All drivers must use \f(CW\*(C`dbd_postamble()\*(C'\fR or risk running into problems.
.PP
Note the specification of \fI\s-1VERSION_FROM\s0\fR; the named file
(\fIDriver.pm\fR) will be scanned for the first line that looks like an
assignment to \fI\f(CI$VERSION\fI\fR, and the subsequent text will be used to
determine the version number.  Note the commentary in
ExtUtils::MakeMaker on the subject of correctly formatted version
numbers.
.PP
If your driver depends upon external software (it usually will), you
will need to add code to ensure that your environment is workable
before the call to \f(CW\*(C`WriteMakefile()\*(C'\fR. If you need to check for the
existence of an external library and perhaps modify \fI\s-1INC\s0\fR to include
the paths to where the external library header files are located and
you cannot find the library or header files make sure you output a
message saying they cannot be found but \f(CW\*(C`exit 0\*(C'\fR (success) \fBbefore\fR
calling \f(CW\*(C`WriteMakefile\*(C'\fR or \s-1CPAN\s0 testers will fail your module if the
external library is not found.
.PP
A full-fledged \fIMakefile.PL\fR can be quite large (for example, the
files for \fBDBD::Oracle\fR and \fBDBD::Informix\fR are both over 1000 lines
long, and the Informix one uses \- and creates \- auxiliary modules
too).
.PP
See also ExtUtils::MakeMaker and ExtUtils::MM_Unix. Consider using
CPAN::MakeMaker in place of \fIExtUtils::MakeMaker\fR.
.SS "\s-1README\s0"
.IX Subsection "README"
The \s-1README\s0 file should describe what the driver is for, the
pre-requisites for the build process, the actual build process, how to
report errors, and who to report them to.
.PP
Users will find ways of breaking the driver build and test process
which you would never even have dreamed to be possible in your worst
nightmares. Therefore, you need to write this document defensively,
precisely and concisely.
.PP
As always, use the \fI\s-1README\s0\fR from one of the established drivers as a basis
for your own; the version in \fBDBD::Informix\fR is worth a look as it has
been quite successful in heading off problems.
.IP "\(bu" 4
Note that users will have versions of Perl and \fB\s-1DBI\s0\fR that are both older
and newer than you expected, but this will seldom cause much trouble.
When it does, it will be because you are using features of \fB\s-1DBI\s0\fR that are
not supported in the version they are using.
.IP "\(bu" 4
Note that users will have versions of the database software that are
both older and newer than you expected. You will save yourself time in
the long run if you can identify the range of versions which have been
tested and warn about versions which are not known to be \s-1OK.\s0
.IP "\(bu" 4
Note that many people trying to install your driver will not be experts
in the database software.
.IP "\(bu" 4
Note that many people trying to install your driver will not be experts
in C or Perl.
.SS "\s-1MANIFEST\s0"
.IX Subsection "MANIFEST"
The \fI\s-1MANIFEST\s0\fR will be used by the Makefile's dist target to build the
distribution tar file that is uploaded to \s-1CPAN.\s0 It should list every
file that you want to include in your distribution, one per line.
.SS "lib/Bundle/DBD/Driver.pm"
.IX Subsection "lib/Bundle/DBD/Driver.pm"
The \s-1CPAN\s0 module provides an extremely powerful bundle mechanism that
allows you to specify pre-requisites for your driver.
.PP
The primary pre-requisite is \fBBundle::DBI\fR; you may want or need to add
some more. With the bundle set up correctly, the user can type:
.PP
.Vb 1
\&        perl \-MCPAN \-e \*(Aqinstall Bundle::DBD::Driver\*(Aq
.Ve
.PP
and Perl will download, compile, test and install all the Perl modules
needed to build your driver.
.PP
The prerequisite modules are listed in the \f(CW\*(C`CONTENTS\*(C'\fR section, with the
official name of the module followed by a dash and an informal name or
description.
.IP "\(bu" 4
Listing \fBBundle::DBI\fR as the main pre-requisite simplifies life.
.IP "\(bu" 4
Don't forget to list your driver.
.IP "\(bu" 4
Note that unless the \s-1DBMS\s0 is itself a Perl module, you cannot list it as
a pre-requisite in this file.
.IP "\(bu" 4
You should keep the version of the bundle the same as the version of
your driver.
.IP "\(bu" 4
You should add configuration management, copyright, and licencing
information at the top.
.PP
A suitable skeleton for this file is shown below.
.PP
.Vb 1
\&  package Bundle::DBD::Driver;
\&
\&  $VERSION = \*(Aq0.01\*(Aq;
\&
\&  1;
\&
\&  _\|_END_\|_
\&
\&  =head1 NAME
\&
\&  Bundle::DBD::Driver \- A bundle to install all DBD::Driver related modules
\&
\&  =head1 SYNOPSIS
\&
\&  C<perl \-MCPAN \-e \*(Aqinstall Bundle::DBD::Driver\*(Aq>
\&
\&  =head1 CONTENTS
\&
\&  Bundle::DBI  \- Bundle for DBI by TIMB (Tim Bunce)
\&
\&  DBD::Driver  \- DBD::Driver by YOU (Your Name)
\&
\&  =head1 DESCRIPTION
\&
\&  This bundle includes all the modules used by the Perl Database
\&  Interface (DBI) driver for Driver (DBD::Driver), assuming the
\&  use of DBI version 1.13 or later, created by Tim Bunce.
\&
\&  If you\*(Aqve not previously used the CPAN module to install any
\&  bundles, you will be interrogated during its setup phase.
\&  But when you\*(Aqve done it once, it remembers what you told it.
\&  You could start by running:
\&
\&    C<perl \-MCPAN \-e \*(Aqinstall Bundle::CPAN\*(Aq>
\&
\&  =head1 SEE ALSO
\&
\&  Bundle::DBI
\&
\&  =head1 AUTHOR
\&
\&  Your Name E<lt>F<you@yourdomain.com>E<gt>
\&
\&  =head1 THANKS
\&
\&  This bundle was created by ripping off Bundle::libnet created by
\&  Graham Barr E<lt>F<gbarr@ti.com>E<gt>, and radically simplified
\&  with some information from Jochen Wiedmann E<lt>F<joe@ispsoft.de>E<gt>.
\&  The template was then included in the DBI::DBD documentation by
\&  Jonathan Leffler E<lt>F<jleffler@informix.com>E<gt>.
\&
\&  =cut
.Ve
.SS "lib/DBD/Driver/Summary.pm"
.IX Subsection "lib/DBD/Driver/Summary.pm"
There is no substitute for taking the summary file from a driver that
was documented in the Perl book (such as \fBDBD::Oracle\fR or \fBDBD::Informix\fR or
\&\fB\s-1DBD::ODBC\s0\fR, to name but three), and adapting it to describe the
facilities available via \fBDBD::Driver\fR when accessing the Driver database.
.SS "Pure Perl version of Driver.pm"
.IX Subsection "Pure Perl version of Driver.pm"
The \fIDriver.pm\fR file defines the Perl module \fBDBD::Driver\fR for your driver.
It will define a package \fBDBD::Driver\fR along with some version information,
some variable definitions, and a function \f(CW\*(C`driver()\*(C'\fR which will have a more
or less standard structure.
.PP
It will also define three sub-packages of \fBDBD::Driver\fR:
.IP "DBD::Driver::dr" 4
.IX Item "DBD::Driver::dr"
with methods \f(CW\*(C`connect()\*(C'\fR, \f(CW\*(C`data_sources()\*(C'\fR and \f(CW\*(C`disconnect_all()\*(C'\fR;
.IP "DBD::Driver::db" 4
.IX Item "DBD::Driver::db"
with methods such as \f(CW\*(C`prepare()\*(C'\fR;
.IP "DBD::Driver::st" 4
.IX Item "DBD::Driver::st"
with methods such as \f(CW\*(C`execute()\*(C'\fR and \f(CW\*(C`fetch()\*(C'\fR.
.PP
The \fIDriver.pm\fR file will also contain the documentation specific to
\&\fBDBD::Driver\fR in the format used by perldoc.
.PP
In a pure Perl driver, the \fIDriver.pm\fR file is the core of the
implementation. You will need to provide all the key methods needed by \fB\s-1DBI\s0\fR.
.PP
Now let's take a closer look at an excerpt of \fIFile.pm\fR as an example.
We ignore things that are common to any module (even non-DBI modules)
or really specific to the \fBDBD::File\fR package.
.PP
\fIThe DBD::Driver package\fR
.IX Subsection "The DBD::Driver package"
.PP
The header
.IX Subsection "The header"
.PP
.Vb 1
\&  package DBD::File;
\&
\&  use strict;
\&  use vars qw($VERSION $drh);
\&
\&  $VERSION = "1.23.00"  # Version number of DBD::File
.Ve
.PP
This is where the version number of your driver is specified, and is
where \fIMakefile.PL\fR looks for this information. Please ensure that any
other modules added with your driver are also version stamped so that
\&\s-1CPAN\s0 does not get confused.
.PP
It is recommended that you use a two-part (1.23) or three-part (1.23.45)
version number. Also consider the \s-1CPAN\s0 system, which gets confused and
considers version 1.10 to precede version 1.9, so that using a raw \s-1CVS,
RCS\s0 or \s-1SCCS\s0 version number is probably not appropriate (despite being
very common).
.PP
For Subversion you could use:
.PP
.Vb 1
\&  $VERSION = "12.012346";
.Ve
.PP
(use lots of leading zeros on the second portion so if you move the code to a
shared repository like svn.perl.org the much larger revision numbers won't
cause a problem, at least not for a few years).  For \s-1RCS\s0 or \s-1CVS\s0 you can use:
.PP
.Vb 1
\&  $VERSION = "11.22";
.Ve
.PP
which pads out the fractional part with leading zeros so all is well
(so long as you don't go past x.99)
.PP
.Vb 1
\&  $drh = undef;         # holds driver handle once initialized
.Ve
.PP
This is where the driver handle will be stored, once created.
Note that you may assume there is only one handle for your driver.
.PP
The driver constructor
.IX Subsection "The driver constructor"
.PP
The \f(CW\*(C`driver()\*(C'\fR method is the driver handle constructor. Note that
the \f(CW\*(C`driver()\*(C'\fR method is in the \fBDBD::Driver\fR package, not in
one of the sub-packages \fBDBD::Driver::dr\fR, \fBDBD::Driver::db\fR, or
\&\fBDBD::Driver::db\fR.
.PP
.Vb 4
\&  sub driver
\&  {
\&      return $drh if $drh;      # already created \- return same one
\&      my ($class, $attr) = @_;
\&
\&      $class .= "::dr";
\&
\&      DBD::Driver::db\->install_method(\*(Aqdrv_example_dbh_method\*(Aq);
\&      DBD::Driver::st\->install_method(\*(Aqdrv_example_sth_method\*(Aq);
\&
\&      # not a \*(Aqmy\*(Aq since we use it above to prevent multiple drivers
\&      $drh = DBI::_new_drh($class, {
\&              \*(AqName\*(Aq        => \*(AqFile\*(Aq,
\&              \*(AqVersion\*(Aq     => $VERSION,
\&              \*(AqAttribution\*(Aq => \*(AqDBD::File by Jochen Wiedmann\*(Aq,
\&          })
\&          or return undef;
\&
\&      return $drh;
\&  }
.Ve
.PP
This is a reasonable example of how \fB\s-1DBI\s0\fR implements its handles. There
are three kinds: \fBdriver handles\fR (typically stored in \fI\f(CI$drh\fI\fR; from
now on called \fIdrh\fR or \fI\f(CI$drh\fI\fR), \fBdatabase handles\fR (from now on
called \fIdbh\fR or \fI\f(CI$dbh\fI\fR) and \fBstatement handles\fR (from now on called
\&\fIsth\fR or \fI\f(CI$sth\fI\fR).
.PP
The prototype of \f(CW\*(C`DBI::_new_drh()\*(C'\fR is
.PP
.Vb 1
\&  $drh = DBI::_new_drh($class, $public_attrs, $private_attrs);
.Ve
.PP
with the following arguments:
.ie n .IP "\fI\fI$class\fI\fR" 4
.el .IP "\fI\f(CI$class\fI\fR" 4
.IX Item "$class"
is typically the class for your driver, (for example, \*(L"DBD::File::dr\*(R"),
passed as the first argument to the \f(CW\*(C`driver()\*(C'\fR method.
.ie n .IP "\fI\fI$public_attrs\fI\fR" 4
.el .IP "\fI\f(CI$public_attrs\fI\fR" 4
.IX Item "$public_attrs"
is a hash ref to attributes like \fIName\fR, \fIVersion\fR, and \fIAttribution\fR.
These are processed and used by \fB\s-1DBI\s0\fR. You had better not make any
assumptions about them nor should you add private attributes here.
.ie n .IP "\fI\fI$private_attrs\fI\fR" 4
.el .IP "\fI\f(CI$private_attrs\fI\fR" 4
.IX Item "$private_attrs"
This is another (optional) hash ref with your private attributes.
\&\fB\s-1DBI\s0\fR will store them and otherwise leave them alone.
.PP
The \f(CW\*(C`DBI::_new_drh()\*(C'\fR method and the \f(CW\*(C`driver()\*(C'\fR method both return \f(CW\*(C`undef\*(C'\fR
for failure (in which case you must look at \fI\f(CI$DBI::err\fI\fR and \fI\f(CI$DBI::errstr\fI\fR
for the failure information, because you have no driver handle to use).
.PP
Using \fIinstall_method()\fR to expose driver-private methods
.IX Subsection "Using install_method() to expose driver-private methods"
.PP
.Vb 1
\&    DBD::Foo::db\->install_method($method_name, \e%attr);
.Ve
.PP
Installs the driver-private method named by \f(CW$method_name\fR into the
\&\s-1DBI\s0 method dispatcher so it can be called directly, avoiding the
need to use the \fIfunc()\fR method.
.PP
It is called as a static method on the driver class to which the
method belongs. The method name must begin with the corresponding
registered driver-private prefix. For example, for DBD::Oracle
\&\f(CW$method_name\fR must being with '\f(CW\*(C`ora_\*(C'\fR', and for DBD::AnyData it
must begin with '\f(CW\*(C`ad_\*(C'\fR'.
.PP
The \f(CW\*(C`\e%attr\*(C'\fR attributes can be used to provide fine control over how the \s-1DBI\s0
dispatcher handles the dispatching of the method. However it's undocumented
at the moment. See the IMA_* #define's in \s-1DBI\s0.xs and the O=>0x000x values in
the initialization of \f(CW%DBI::DBI_methods\fR in \s-1DBI\s0.pm.  (Volunteers to polish up
and document the interface are very welcome to get in touch via dbi\-dev@perl.org).
.PP
Methods installed using install_method default to the standard error
handling behaviour for \s-1DBI\s0 methods: clearing err and errstr before
calling the method, and checking for errors to trigger RaiseError
etc. on return. This differs from the default behaviour of \fIfunc()\fR.
.PP
Note for driver authors: The DBD::Foo::xx\->install_method call won't
work until the class-hierarchy has been setup. Normally the \s-1DBI\s0
looks after that just after the driver is loaded. This means
\&\fIinstall_method()\fR can't be called at the time the driver is loaded
unless the class-hierarchy is set up first. The way to do that is
to call the \fIsetup_driver()\fR method:
.PP
.Vb 1
\&    DBI\->setup_driver(\*(AqDBD::Foo\*(Aq);
.Ve
.PP
before using \fIinstall_method()\fR.
.PP
The \s-1CLONE\s0 special subroutine
.IX Subsection "The CLONE special subroutine"
.PP
Also needed here, in the \fBDBD::Driver\fR package, is a \f(CW\*(C`CLONE()\*(C'\fR method
that will be called by perl when an interpreter is cloned. All your
\&\f(CW\*(C`CLONE()\*(C'\fR method needs to do, currently, is clear the cached \fI\f(CI$drh\fI\fR so
the new interpreter won't start using the cached \fI\f(CI$drh\fI\fR from the old
interpreter:
.PP
.Vb 3
\&  sub CLONE {
\&    undef $drh;
\&  }
.Ve
.PP
See <http://search.cpan.org/dist/perl/pod/perlmod.pod#Making_your_module_threadsafe>
for details.
.PP
\fIThe DBD::Driver::dr package\fR
.IX Subsection "The DBD::Driver::dr package"
.PP
The next lines of code look as follows:
.PP
.Vb 1
\&  package DBD::Driver::dr; # ====== DRIVER ======
\&
\&  $DBD::Driver::dr::imp_data_size = 0;
.Ve
.PP
Note that no \fI\f(CI@ISA\fI\fR is needed here, or for the other \fBDBD::Driver::*\fR
classes, because the \fB\s-1DBI\s0\fR takes care of that for you when the driver is
loaded.
.PP
.Vb 2
\& *FIX ME* Explain what the imp_data_size is, so that implementors aren\*(Aqt
\& practicing cargo\-cult programming.
.Ve
.PP
The database handle constructor
.IX Subsection "The database handle constructor"
.PP
The database handle constructor is the driver's (hence the changed
namespace) \f(CW\*(C`connect()\*(C'\fR method:
.PP
.Vb 3
\&  sub connect
\&  {
\&      my ($drh, $dr_dsn, $user, $auth, $attr) = @_;
\&
\&      # Some database specific verifications, default settings
\&      # and the like can go here. This should only include
\&      # syntax checks or similar stuff where it\*(Aqs legal to
\&      # \*(Aqdie\*(Aq in case of errors.
\&      # For example, many database packages requires specific
\&      # environment variables to be set; this could be where you
\&      # validate that they are set, or default them if they are not set.
\&
\&      my $driver_prefix = "drv_"; # the assigned prefix for this driver
\&
\&      # Process attributes from the DSN; we assume ODBC syntax
\&      # here, that is, the DSN looks like var1=val1;...;varN=valN
\&      foreach my $var ( split /;/, $dr_dsn ) {
\&          my ($attr_name, $attr_value) = split \*(Aq=\*(Aq, $var, 2;
\&          return $drh\->set_err($DBI::stderr, "Can\*(Aqt parse DSN part \*(Aq$var\*(Aq")
\&              unless defined $attr_value;
\&
\&          # add driver prefix to attribute name if it doesn\*(Aqt have it already
\&          $attr_name = $driver_prefix.$attr_name
\&              unless $attr_name =~ /^$driver_prefix/o;
\&
\&          # Store attribute into %$attr, replacing any existing value.
\&          # The DBI will STORE() these into $dbh after we\*(Aqve connected
\&          $attr\->{$attr_name} = $attr_value;
\&      }
\&
\&      # Get the attributes we\*(Aqll use to connect.
\&      # We use delete here because these no need to STORE them
\&      my $db = delete $attr\->{drv_database} || delete $attr\->{drv_db}
\&          or return $drh\->set_err($DBI::stderr, "No database name given in DSN \*(Aq$dr_dsn\*(Aq");
\&      my $host = delete $attr\->{drv_host} || \*(Aqlocalhost\*(Aq;
\&      my $port = delete $attr\->{drv_port} || 123456;
\&
\&      # Assume you can attach to your database via drv_connect:
\&      my $connection = drv_connect($db, $host, $port, $user, $auth)
\&          or return $drh\->set_err($DBI::stderr, "Can\*(Aqt connect to $dr_dsn: ...");
\&
\&      # create a \*(Aqblank\*(Aq dbh (call superclass constructor)
\&      my ($outer, $dbh) = DBI::_new_dbh($drh, { Name => $dr_dsn });
\&
\&      $dbh\->STORE(\*(AqActive\*(Aq, 1 );
\&      $dbh\->{drv_connection} = $connection;
\&
\&      return $outer;
\&  }
.Ve
.PP
This is mostly the same as in the \fIdriver handle constructor\fR above.
The arguments are described in \s-1DBI\s0.
.PP
The constructor \f(CW\*(C`DBI::_new_dbh()\*(C'\fR is called, returning a database handle.
The constructor's prototype is:
.PP
.Vb 1
\&  ($outer, $inner) = DBI::_new_dbh($drh, $public_attr, $private_attr);
.Ve
.PP
with similar arguments to those in the \fIdriver handle constructor\fR,
except that the \fI\f(CI$class\fI\fR is replaced by \fI\f(CI$drh\fI\fR. The \fIName\fR attribute
is a standard \fB\s-1DBI\s0\fR attribute (see \*(L"Database Handle Attributes\*(R" in \s-1DBI\s0).
.PP
In scalar context, only the outer handle is returned.
.PP
Note the use of the \f(CW\*(C`STORE()\*(C'\fR method for setting the \fIdbh\fR attributes.
That's because within the driver code, the handle object you have is
the 'inner' handle of a tied hash, not the outer handle that the
users of your driver have.
.PP
Because you have the inner handle, tie magic doesn't get invoked
when you get or set values in the hash. This is often very handy for
speed when you want to get or set simple non-special driver-specific
attributes.
.PP
However, some attribute values, such as those handled by the \fB\s-1DBI\s0\fR like
\&\fIPrintError\fR, don't actually exist in the hash and must be read via
\&\f(CW\*(C`$h\->FETCH($attrib)\*(C'\fR and set via \f(CW\*(C`$h\->STORE($attrib, $value)\*(C'\fR.
If in any doubt, use these methods.
.PP
The \fIdata_sources()\fR method
.IX Subsection "The data_sources() method"
.PP
The \f(CW\*(C`data_sources()\*(C'\fR method must populate and return a list of valid data
sources, prefixed with the "\fIdbi:Driver\fR" incantation that allows them to
be used in the first argument of the \f(CW\*(C`DBI\->connect()\*(C'\fR method.
An example of this might be scanning the \fI\f(CI$HOME\fI/.odbcini\fR file on Unix
for \s-1ODBC\s0 data sources (DSNs).
.PP
As a trivial example, consider a fixed list of data sources:
.PP
.Vb 11
\&  sub data_sources
\&  {
\&      my($drh, $attr) = @_;
\&      my(@list) = ();
\&      # You need more sophisticated code than this to set @list...
\&      push @list, "dbi:Driver:abc";
\&      push @list, "dbi:Driver:def";
\&      push @list, "dbi:Driver:ghi";
\&      # End of code to set @list
\&      return @list;
\&  }
.Ve
.PP
The \fIdisconnect_all()\fR method
.IX Subsection "The disconnect_all() method"
.PP
If you need to release any resources when the driver is unloaded, you
can provide a disconnect_all method.
.PP
Other driver handle methods
.IX Subsection "Other driver handle methods"
.PP
If you need any other driver handle methods, they can follow here.
.PP
Error handling
.IX Subsection "Error handling"
.PP
It is quite likely that something fails in the connect method.
With \fBDBD::File\fR for example, you might catch an error when setting the
current directory to something not existent by using the
(driver-specific) \fIf_dir\fR attribute.
.PP
To report an error, you use the \f(CW\*(C`set_err()\*(C'\fR method:
.PP
.Vb 1
\&  $h\->set_err($err, $errmsg, $state);
.Ve
.PP
This will ensure that the error is recorded correctly and that
\&\fIRaiseError\fR and \fIPrintError\fR etc are handled correctly.
.PP
Typically you'll always use the method instance, aka your method's first
argument.
.PP
As \f(CW\*(C`set_err()\*(C'\fR always returns \f(CW\*(C`undef\*(C'\fR your error handling code can
usually be simplified to something like this:
.PP
.Vb 1
\&  return $h\->set_err($err, $errmsg, $state) if ...;
.Ve
.PP
\fIThe DBD::Driver::db package\fR
.IX Subsection "The DBD::Driver::db package"
.PP
.Vb 1
\&  package DBD::Driver::db; # ====== DATABASE ======
\&
\&  $DBD::Driver::db::imp_data_size = 0;
.Ve
.PP
The statement handle constructor
.IX Subsection "The statement handle constructor"
.PP
There's nothing much new in the statement handle constructor, which
is the \f(CW\*(C`prepare()\*(C'\fR method:
.PP
.Vb 3
\&  sub prepare
\&  {
\&      my ($dbh, $statement, @attribs) = @_;
\&
\&      # create a \*(Aqblank\*(Aq sth
\&      my ($outer, $sth) = DBI::_new_sth($dbh, { Statement => $statement });
\&
\&      $sth\->STORE(\*(AqNUM_OF_PARAMS\*(Aq, ($statement =~ tr/?//));
\&
\&      $sth\->{drv_params} = [];
\&
\&      return $outer;
\&  }
.Ve
.PP
This is still the same \*(-- check the arguments and call the super class
constructor \f(CW\*(C`DBI::_new_sth()\*(C'\fR. Again, in scalar context, only the outer
handle is returned. The \fIStatement\fR attribute should be cached as
shown.
.PP
Note the prefix \fIdrv_\fR in the attribute names: it is required that
all your private attributes use a lowercase prefix unique to your driver.
As mentioned earlier in this document, the \fB\s-1DBI\s0\fR contains a registry of
known driver prefixes and may one day warn about unknown attributes
that don't have a registered prefix.
.PP
Note that we parse the statement here in order to set the attribute
\&\fI\s-1NUM_OF_PARAMS\s0\fR. The technique illustrated is not very reliable; it can
be confused by question marks appearing in quoted strings, delimited
identifiers or in \s-1SQL\s0 comments that are part of the \s-1SQL\s0 statement. We
could set \fI\s-1NUM_OF_PARAMS\s0\fR in the \f(CW\*(C`execute()\*(C'\fR method instead because
the \fB\s-1DBI\s0\fR specification explicitly allows a driver to defer this, but then
the user could not call \f(CW\*(C`bind_param()\*(C'\fR.
.PP
Transaction handling
.IX Subsection "Transaction handling"
.PP
Pure Perl drivers will rarely support transactions. Thus your \f(CW\*(C`commit()\*(C'\fR
and \f(CW\*(C`rollback()\*(C'\fR methods will typically be quite simple:
.PP
.Vb 8
\&  sub commit
\&  {
\&      my ($dbh) = @_;
\&      if ($dbh\->FETCH(\*(AqWarn\*(Aq)) {
\&          warn("Commit ineffective while AutoCommit is on");
\&      }
\&      0;
\&  }
\&
\&  sub rollback {
\&      my ($dbh) = @_;
\&      if ($dbh\->FETCH(\*(AqWarn\*(Aq)) {
\&          warn("Rollback ineffective while AutoCommit is on");
\&      }
\&      0;
\&  }
.Ve
.PP
Or even simpler, just use the default methods provided by the \fB\s-1DBI\s0\fR that
do nothing except return \f(CW\*(C`undef\*(C'\fR.
.PP
The \fB\s-1DBI\s0\fR's default \f(CW\*(C`begin_work()\*(C'\fR method can be used by inheritance.
.PP
The \s-1\fISTORE\s0()\fR and \s-1\fIFETCH\s0()\fR methods
.IX Subsection "The STORE() and FETCH() methods"
.PP
These methods (that we have already used, see above) are called for
you, whenever the user does a:
.PP
.Vb 1
\&  $dbh\->{$attr} = $val;
.Ve
.PP
or, respectively,
.PP
.Vb 1
\&  $val = $dbh\->{$attr};
.Ve
.PP
See perltie for details on tied hash refs to understand why these
methods are required.
.PP
The \fB\s-1DBI\s0\fR will handle most attributes for you, in particular attributes
like \fIRaiseError\fR or \fIPrintError\fR. All you have to do is handle your
driver's private attributes and any attributes, like \fIAutoCommit\fR and
\&\fIChopBlanks\fR, that the \fB\s-1DBI\s0\fR can't handle for you.
.PP
A good example might look like this:
.PP
.Vb 10
\&  sub STORE
\&  {
\&      my ($dbh, $attr, $val) = @_;
\&      if ($attr eq \*(AqAutoCommit\*(Aq) {
\&          # AutoCommit is currently the only standard attribute we have
\&          # to consider.
\&          if (!$val) { die "Can\*(Aqt disable AutoCommit"; }
\&          return 1;
\&      }
\&      if ($attr =~ m/^drv_/) {
\&          # Handle only our private attributes here
\&          # Note that we could trigger arbitrary actions.
\&          # Ideally we should warn about unknown attributes.
\&          $dbh\->{$attr} = $val; # Yes, we are allowed to do this,
\&          return 1;             # but only for our private attributes
\&      }
\&      # Else pass up to DBI to handle for us
\&      $dbh\->SUPER::STORE($attr, $val);
\&  }
\&
\&  sub FETCH
\&  {
\&      my ($dbh, $attr) = @_;
\&      if ($attr eq \*(AqAutoCommit\*(Aq) { return 1; }
\&      if ($attr =~ m/^drv_/) {
\&          # Handle only our private attributes here
\&          # Note that we could trigger arbitrary actions.
\&          return $dbh\->{$attr}; # Yes, we are allowed to do this,
\&                                # but only for our private attributes
\&      }
\&      # Else pass up to DBI to handle
\&      $dbh\->SUPER::FETCH($attr);
\&  }
.Ve
.PP
The \fB\s-1DBI\s0\fR will actually store and fetch driver-specific attributes (with all
lowercase names) without warning or error, so there's actually no need to
implement driver-specific any code in your \f(CW\*(C`FETCH()\*(C'\fR and \f(CW\*(C`STORE()\*(C'\fR
methods unless you need extra logic/checks, beyond getting or setting
the value.
.PP
Unless your driver documentation indicates otherwise, the return value of
the \f(CW\*(C`STORE()\*(C'\fR method is unspecified and the caller shouldn't use that value.
.PP
Other database handle methods
.IX Subsection "Other database handle methods"
.PP
As with the driver package, other database handle methods may follow here.
In particular you should consider a (possibly empty) \f(CW\*(C`disconnect()\*(C'\fR
method and possibly a \f(CW\*(C`quote()\*(C'\fR method if \fB\s-1DBI\s0\fR's default isn't correct for
you. You may also need the \f(CW\*(C`type_info_all()\*(C'\fR and \f(CW\*(C`get_info()\*(C'\fR methods,
as described elsewhere in this document.
.PP
Where reasonable use \f(CW\*(C`$h\->SUPER::foo()\*(C'\fR to call the \fB\s-1DBI\s0\fR's method in
some or all cases and just wrap your custom behavior around that.
.PP
If you want to use private trace flags you'll probably want to be
able to set them by name. To do that you'll need to define a
\&\f(CW\*(C`parse_trace_flag()\*(C'\fR method (note that's \*(L"parse_trace_flag\*(R", singular,
not \*(L"parse_trace_flags\*(R", plural).
.PP
.Vb 9
\&  sub parse_trace_flag {
\&      my ($h, $name) = @_;
\&      return 0x01000000 if $name eq \*(Aqfoo\*(Aq;
\&      return 0x02000000 if $name eq \*(Aqbar\*(Aq;
\&      return 0x04000000 if $name eq \*(Aqbaz\*(Aq;
\&      return 0x08000000 if $name eq \*(Aqboo\*(Aq;
\&      return 0x10000000 if $name eq \*(Aqbop\*(Aq;
\&      return $h\->SUPER::parse_trace_flag($name);
\&  }
.Ve
.PP
All private flag names must be lowercase, and all private flags
must be in the top 8 of the 32 bits.
.PP
\fIThe DBD::Driver::st package\fR
.IX Subsection "The DBD::Driver::st package"
.PP
This package follows the same pattern the others do:
.PP
.Vb 1
\&  package DBD::Driver::st;
\&
\&  $DBD::Driver::st::imp_data_size = 0;
.Ve
.PP
The \fIexecute()\fR and \fIbind_param()\fR methods
.IX Subsection "The execute() and bind_param() methods"
.PP
This is perhaps the most difficult method because we have to consider
parameter bindings here. In addition to that, there are a number of
statement attributes which must be set for inherited \fB\s-1DBI\s0\fR methods to
function correctly (see \*(L"Statement attributes\*(R" below).
.PP
We present a simplified implementation by using the \fIdrv_params\fR
attribute from above:
.PP
.Vb 12
\&  sub bind_param
\&  {
\&      my ($sth, $pNum, $val, $attr) = @_;
\&      my $type = (ref $attr) ? $attr\->{TYPE} : $attr;
\&      if ($type) {
\&          my $dbh = $sth\->{Database};
\&          $val = $dbh\->quote($sth, $type);
\&      }
\&      my $params = $sth\->{drv_params};
\&      $params\->[$pNum\-1] = $val;
\&      1;
\&  }
\&
\&  sub execute
\&  {
\&      my ($sth, @bind_values) = @_;
\&
\&      # start of by finishing any previous execution if still active
\&      $sth\->finish if $sth\->FETCH(\*(AqActive\*(Aq);
\&
\&      my $params = (@bind_values) ?
\&          \e@bind_values : $sth\->{drv_params};
\&      my $numParam = $sth\->FETCH(\*(AqNUM_OF_PARAMS\*(Aq);
\&      return $sth\->set_err($DBI::stderr, "Wrong number of parameters")
\&          if @$params != $numParam;
\&      my $statement = $sth\->{\*(AqStatement\*(Aq};
\&      for (my $i = 0;  $i < $numParam;  $i++) {
\&          $statement =~ s/?/$params\->[$i]/; # XXX doesn\*(Aqt deal with quoting etc!
\&      }
\&      # Do anything ... we assume that an array ref of rows is
\&      # created and store it:
\&      $sth\->{\*(Aqdrv_data\*(Aq} = $data;
\&      $sth\->{\*(Aqdrv_rows\*(Aq} = @$data; # number of rows
\&      $sth\->STORE(\*(AqNUM_OF_FIELDS\*(Aq) = $numFields;
\&      $sth\->{Active} = 1;
\&      @$data || \*(Aq0E0\*(Aq;
\&  }
.Ve
.PP
There are a number of things you should note here.
.PP
We initialize the \fI\s-1NUM_OF_FIELDS\s0\fR and \fIActive\fR attributes here,
because they are essential for \f(CW\*(C`bind_columns()\*(C'\fR to work.
.PP
We use attribute \f(CW\*(C`$sth\->{Statement}\*(C'\fR which we created
within \f(CW\*(C`prepare()\*(C'\fR. The attribute \f(CW\*(C`$sth\->{Database}\*(C'\fR, which is
nothing else than the \fIdbh\fR, was automatically created by \fB\s-1DBI\s0\fR.
.PP
Finally, note that (as specified in the \fB\s-1DBI\s0\fR specification) we return the
string \f(CW\*(Aq0E0\*(Aq\fR instead of the number 0, so that the result tests true but
equal to zero.
.PP
.Vb 1
\&  $sth\->execute() or die $sth\->errstr;
.Ve
.PP
The \fIexecute_array()\fR, \fIexecute_for_fetch()\fR and \fIbind_param_array()\fR methods
.IX Subsection "The execute_array(), execute_for_fetch() and bind_param_array() methods"
.PP
In general, \s-1DBD\s0's only need to implement \f(CW\*(C`execute_for_fetch()\*(C'\fR and
\&\f(CW\*(C`bind_param_array\*(C'\fR. \s-1DBI\s0's default \f(CW\*(C`execute_array()\*(C'\fR will invoke the
\&\s-1DBD\s0's \f(CW\*(C`execute_for_fetch()\*(C'\fR as needed.
.PP
The following sequence describes the interaction between
\&\s-1DBI \s0\f(CW\*(C`execute_array\*(C'\fR and a \s-1DBD\s0's \f(CW\*(C`execute_for_fetch\*(C'\fR:
.IP "1." 4
App calls \f(CW\*(C`$sth\->execute_array(\e%attrs, @array_of_arrays)\*(C'\fR
.IP "2." 4
If \f(CW@array_of_arrays\fR was specified, \s-1DBI\s0 processes \f(CW@array_of_arrays\fR by calling
\&\s-1DBD\s0's \f(CW\*(C`bind_param_array()\*(C'\fR. Alternately, App may have directly called
\&\f(CW\*(C`bind_param_array()\*(C'\fR
.IP "3." 4
\&\s-1DBD\s0 validates and binds each array
.IP "4." 4
\&\s-1DBI\s0 retrieves the validated param arrays from \s-1DBD\s0's ParamArray attribute
.IP "5." 4
\&\s-1DBI\s0 calls \s-1DBD\s0's \f(CW\*(C`execute_for_fetch($fetch_tuple_sub, \e@tuple_status)\*(C'\fR,
where \f(CW&$fetch_tuple_sub\fR is a closure to iterate over the
returned ParamArray values, and \f(CW\*(C`\e@tuple_status\*(C'\fR is an array to receive
the disposition status of each tuple.
.IP "6." 4
\&\s-1DBD\s0 iteratively calls \f(CW&$fetch_tuple_sub\fR to retrieve parameter tuples
to be added to its bulk database operation/request.
.IP "7." 4
when \s-1DBD\s0 reaches the limit of tuples it can handle in a single database
operation/request, or the \f(CW&$fetch_tuple_sub\fR indicates no more
tuples by returning undef, the \s-1DBD\s0 executes the bulk operation, and
reports the disposition of each tuple in \e@tuple_status.
.IP "8." 4
\&\s-1DBD\s0 repeats steps 6 and 7 until all tuples are processed.
.PP
E.g., here's the essence of DBD::Oracle's execute_for_fetch:
.PP
.Vb 10
\&       while (1) {
\&           my @tuple_batch;
\&           for (my $i = 0; $i < $batch_size; $i++) {
\&                push @tuple_batch, [ @{$fetch_tuple_sub\->() || last} ];
\&           }
\&           last unless @tuple_batch;
\&           my $res = ora_execute_array($sth, \e@tuple_batch,
\&              scalar(@tuple_batch), $tuple_batch_status);
\&           push @$tuple_status, @$tuple_batch_status;
\&       }
.Ve
.PP
Note that \s-1DBI\s0's default \fIexecute_array()\fR/\fIexecute_for_fetch()\fR implementation
requires the use of positional (i.e., '?') placeholders. Drivers
which \fBrequire\fR named placeholders must either emulate positional
placeholders (e.g., see DBD::Oracle), or must implement their own
\&\fIexecute_array()\fR/\fIexecute_for_fetch()\fR methods to properly sequence bound
parameter arrays.
.PP
Fetching data
.IX Subsection "Fetching data"
.PP
Only one method needs to be written for fetching data, \f(CW\*(C`fetchrow_arrayref()\*(C'\fR.
The other methods, \f(CW\*(C`fetchrow_array()\*(C'\fR, \f(CW\*(C`fetchall_arrayref()\*(C'\fR, etc, as well
as the database handle's \f(CW\*(C`select*\*(C'\fR methods are part of \fB\s-1DBI\s0\fR, and call
\&\f(CW\*(C`fetchrow_arrayref()\*(C'\fR as necessary.
.PP
.Vb 10
\&  sub fetchrow_arrayref
\&  {
\&      my ($sth) = @_;
\&      my $data = $sth\->{drv_data};
\&      my $row = shift @$data;
\&      if (!$row) {
\&          $sth\->STORE(Active => 0); # mark as no longer active
\&          return undef;
\&      }
\&      if ($sth\->FETCH(\*(AqChopBlanks\*(Aq)) {
\&          map { $_ =~ s/\es+$//; } @$row;
\&      }
\&      return $sth\->_set_fbav($row);
\&  }
\&  *fetch = \e&fetchrow_arrayref; # required alias for fetchrow_arrayref
.Ve
.PP
Note the use of the method \f(CW\*(C`_set_fbav()\*(C'\fR \*(-- this is required so that
\&\f(CW\*(C`bind_col()\*(C'\fR and \f(CW\*(C`bind_columns()\*(C'\fR work.
.PP
If an error occurs which leaves the \fI\f(CI$sth\fI\fR in a state where remaining rows
can't be fetched then \fIActive\fR should be turned off before the method returns.
.PP
The \f(CW\*(C`rows()\*(C'\fR method for this driver can be implemented like this:
.PP
.Vb 1
\&  sub rows { shift\->{drv_rows} }
.Ve
.PP
because it knows in advance how many rows it has fetched.
Alternatively you could delete that method and so fallback
to the \fB\s-1DBI\s0\fR's own method which does the right thing based
on the number of calls to \f(CW\*(C`_set_fbav()\*(C'\fR.
.PP
The more_results method
.IX Subsection "The more_results method"
.PP
If your driver doesn't support multiple result sets, then don't even implement this method.
.PP
Otherwise, this method needs to get the statement handle ready to fetch results
from the next result set, if there is one. Typically you'd start with:
.PP
.Vb 1
\&    $sth\->finish;
.Ve
.PP
then you should delete all the attributes from the attribute cache that may no
longer be relevant for the new result set:
.PP
.Vb 2
\&    delete $sth\->{$_}
\&        for qw(NAME TYPE PRECISION SCALE ...);
.Ve
.PP
for drivers written in C use:
.PP
.Vb 6
\&    hv_delete((HV*)SvRV(sth), "NAME", 4, G_DISCARD);
\&    hv_delete((HV*)SvRV(sth), "NULLABLE", 8, G_DISCARD);
\&    hv_delete((HV*)SvRV(sth), "NUM_OF_FIELDS", 13, G_DISCARD);
\&    hv_delete((HV*)SvRV(sth), "PRECISION", 9, G_DISCARD);
\&    hv_delete((HV*)SvRV(sth), "SCALE", 5, G_DISCARD);
\&    hv_delete((HV*)SvRV(sth), "TYPE", 4, G_DISCARD);
.Ve
.PP
Don't forget to also delete, or update, any driver-private attributes that may
not be correct for the next resultset.
.PP
The \s-1NUM_OF_FIELDS\s0 attribute is a special case. It should be set using \s-1STORE:\s0
.PP
.Vb 2
\&    $sth\->STORE(NUM_OF_FIELDS => 0); /* for DBI <= 1.53 */
\&    $sth\->STORE(NUM_OF_FIELDS => $new_value);
.Ve
.PP
for drivers written in C use this incantation:
.PP
.Vb 5
\&    /* Adjust NUM_OF_FIELDS \- which also adjusts the row buffer size */
\&    DBIc_NUM_FIELDS(imp_sth) = 0; /* for DBI <= 1.53 */
\&    DBIc_STATE(imp_xxh)\->set_attr_k(sth, sv_2mortal(newSVpvn("NUM_OF_FIELDS",13)), 0,
\&        sv_2mortal(newSViv(mysql_num_fields(imp_sth\->result)))
\&    );
.Ve
.PP
For \s-1DBI\s0 versions prior to 1.54 you'll also need to explicitly adjust the
number of elements in the row buffer array (\f(CW\*(C`DBIc_FIELDS_AV(imp_sth)\*(C'\fR)
to match the new result set. Fill any new values with \fInewSV\fR\|(0) not &sv_undef.
Alternatively you could free DBIc_FIELDS_AV(imp_sth) and set it to null,
but that would mean \fIbind_columns()\fR wouldn't work across result sets.
.PP
Statement attributes
.IX Subsection "Statement attributes"
.PP
The main difference between \fIdbh\fR and \fIsth\fR attributes is, that you
should implement a lot of attributes here that are required by
the \fB\s-1DBI\s0\fR, such as \fI\s-1NAME\s0\fR, \fI\s-1NULLABLE\s0\fR, \fI\s-1TYPE\s0\fR, etc. See
\&\*(L"Statement Handle Attributes\*(R" in \s-1DBI\s0 for a complete list.
.PP
Pay attention to attributes which are marked as read only, such as
\&\fI\s-1NUM_OF_PARAMS\s0\fR. These attributes can only be set the first time
a statement is executed. If a statement is prepared, then executed
multiple times, warnings may be generated.
.PP
You can protect against these warnings, and prevent the recalculation
of attributes which might be expensive to calculate (such as the
\&\fI\s-1NAME\s0\fR and \fINAME_*\fR attributes):
.PP
.Vb 3
\&    my $storedNumParams = $sth\->FETCH(\*(AqNUM_OF_PARAMS\*(Aq);
\&    if (!defined $storedNumParams or $storedNumFields < 0) {
\&        $sth\->STORE(\*(AqNUM_OF_PARAMS\*(Aq) = $numParams;
\&
\&        # Set other useful attributes that only need to be set once
\&        # for a statement, like $sth\->{NAME} and $sth\->{TYPE}
\&    }
.Ve
.PP
One particularly important attribute to set correctly (mentioned in
\&\*(L"\s-1ATTRIBUTES COMMON TO ALL HANDLES\*(R"\s0 in \s-1DBI\s0 is \fIActive\fR. Many \fB\s-1DBI\s0\fR methods,
including \f(CW\*(C`bind_columns()\*(C'\fR, depend on this attribute.
.PP
Besides that the \f(CW\*(C`STORE()\*(C'\fR and \f(CW\*(C`FETCH()\*(C'\fR methods are mainly the same
as above for \fIdbh\fR's.
.PP
Other statement methods
.IX Subsection "Other statement methods"
.PP
A trivial \f(CW\*(C`finish()\*(C'\fR method to discard stored data, reset any attributes
(such as \fIActive\fR) and do \f(CW\*(C`$sth\->SUPER::finish()\*(C'\fR.
.PP
If you've defined a \f(CW\*(C`parse_trace_flag()\*(C'\fR method in \fB::db\fR you'll also want
it in \fB::st\fR, so just alias it in:
.PP
.Vb 1
\&  *parse_trace_flag = \e&DBD::foo:db::parse_trace_flag;
.Ve
.PP
And perhaps some other methods that are not part of the \fB\s-1DBI\s0\fR
specification, in particular to make metadata available.
Remember that they must have names that begin with your drivers
registered prefix so they can be installed using \f(CW\*(C`install_method()\*(C'\fR.
.PP
If \f(CW\*(C`DESTROY()\*(C'\fR is called on a statement handle that's still active
(\f(CW\*(C`$sth\->{Active}\*(C'\fR is true) then it should effectively call \f(CW\*(C`finish()\*(C'\fR.
.PP
.Vb 4
\&    sub DESTROY {
\&        my $sth = shift;
\&        $sth\->finish if $sth\->FETCH(\*(AqActive\*(Aq);
\&    }
.Ve
.SS "Tests"
.IX Subsection "Tests"
The test process should conform as closely as possibly to the Perl
standard test harness.
.PP
In particular, most (all) of the tests should be run in the \fIt\fR sub-directory,
and should simply produce an \f(CW\*(C`ok\*(C'\fR when run under \f(CW\*(C`make test\*(C'\fR.
For details on how this is done, see the Camel book and the section in
Chapter 7, \*(L"The Standard Perl Library\*(R" on Test::Harness.
.PP
The tests may need to adapt to the type of database which is being used
for testing, and to the privileges of the user testing the driver. For
example, the \fBDBD::Informix\fR test code has to adapt in a number of
places to the type of database to which it is connected as different
Informix databases have different capabilities: some of the tests are
for databases without transaction logs; others are for databases with a
transaction log; some versions of the server have support for blobs, or
stored procedures, or user-defined data types, and others do not.
.PP
When a complete file of tests must be skipped, you can provide a reason
in a pseudo-comment:
.PP
.Vb 5
\&    if ($no_transactions_available)
\&    {
\&        print "1..0 # Skip: No transactions available\en";
\&        exit 0;
\&    }
.Ve
.PP
Consider downloading the \fBDBD::Informix\fR code and look at the code in
\&\fIDBD/Informix/TestHarness.pm\fR which is used throughout the
\&\fBDBD::Informix\fR tests in the \fIt\fR sub-directory.
.SH "CREATING A C/XS DRIVER"
.IX Header "CREATING A C/XS DRIVER"
Please also see the section under \*(L"\s-1CREATING A PURE PERL DRIVER\*(R"\s0
regarding the creation of the \fIMakefile.PL\fR.
.PP
Creating a new C/XS driver from scratch will always be a daunting task.
You can and should greatly simplify your task by taking a good
reference driver implementation and modifying that to match the
database product for which you are writing a driver.
.PP
The de facto reference driver has been the one for \fBDBD::Oracle\fR written
by Tim Bunce, who is also the author of the \fB\s-1DBI\s0\fR package. The \fBDBD::Oracle\fR
module is a good example of a driver implemented around a C\-level \s-1API.\s0
.PP
Nowadays it it seems better to base on \fB\s-1DBD::ODBC\s0\fR, another driver
maintained by Tim and Jeff Urlwin, because it offers a lot of metadata
and seems to become the guideline for the future development. (Also as
\&\fBDBD::Oracle\fR digs deeper into the Oracle 8 \s-1OCI\s0 interface it'll get even
more hairy than it is now.)
.PP
The \fBDBD::Informix\fR driver is one driver implemented using embedded \s-1SQL\s0
instead of a function-based \s-1API.
\&\s0\fBDBD::Ingres\fR may also be worth a look.
.SS "C/XS version of Driver.pm"
.IX Subsection "C/XS version of Driver.pm"
A lot of the code in the \fIDriver.pm\fR file is very similar to the code for pure Perl modules
\&\- see above.  However,
there are also some subtle (and not so subtle) differences, including:
.IP "\(bu" 8
The variables \fI\f(CI$DBD::Driver::\fI{dr|db|st}::imp_data_size\fR are not defined
here, but in the \s-1XS\s0 code, because they declare the size of certain
C structures.
.IP "\(bu" 8
Some methods are typically moved to the \s-1XS\s0 code, in particular
\&\f(CW\*(C`prepare()\*(C'\fR, \f(CW\*(C`execute()\*(C'\fR, \f(CW\*(C`disconnect()\*(C'\fR, \f(CW\*(C`disconnect_all()\*(C'\fR and the
\&\f(CW\*(C`STORE()\*(C'\fR and \f(CW\*(C`FETCH()\*(C'\fR methods.
.IP "\(bu" 8
Other methods are still part of \fIDriver.pm\fR, but have callbacks to
the \s-1XS\s0 code.
.IP "\(bu" 8
If the driver-specific parts of the \fIimp_drh_t\fR structure need to be
formally initialized (which does not seem to be a common requirement),
then you need to add a call to an appropriate \s-1XS\s0 function in the driver
method of \f(CW\*(C`DBD::Driver::driver()\*(C'\fR, and you define the corresponding function
in \fIDriver.xs\fR, and you define the C code in \fIdbdimp.c\fR and the prototype in
\&\fIdbdimp.h\fR.
.Sp
For example, \fBDBD::Informix\fR has such a requirement, and adds the
following call after the call to \f(CW\*(C`_new_drh()\*(C'\fR in \fIInformix.pm\fR:
.Sp
.Vb 1
\&  DBD::Informix::dr::driver_init($drh);
.Ve
.Sp
and the following code in \fIInformix.xs\fR:
.Sp
.Vb 6
\&  # Initialize the DBD::Informix driver data structure
\&  void
\&  driver_init(drh)
\&      SV *drh
\&      CODE:
\&      ST(0) = dbd_ix_dr_driver_init(drh) ? &sv_yes : &sv_no;
.Ve
.Sp
and the code in \fIdbdimp.h\fR declares:
.Sp
.Vb 1
\&  extern int dbd_ix_dr_driver_init(SV *drh);
.Ve
.Sp
and the code in \fIdbdimp.ec\fR (equivalent to \fIdbdimp.c\fR) defines:
.Sp
.Vb 11
\&  /* Formally initialize the DBD::Informix driver structure */
\&  int
\&  dbd_ix_dr_driver(SV *drh)
\&  {
\&      D_imp_drh(drh);
\&      imp_drh\->n_connections = 0;       /* No active connections */
\&      imp_drh\->current_connection = 0;  /* No current connection */
\&      imp_drh\->multipleconnections = (ESQLC_VERSION >= 600) ? True : False;
\&      dbd_ix_link_newhead(&imp_drh\->head);  /* Empty linked list of connections */
\&      return 1;
\&  }
.Ve
.Sp
\&\fBDBD::Oracle\fR has a similar requirement but gets around it by checking
whether the private data part of the driver handle is all zeroed out,
rather than add extra functions.
.PP
Now let's take a closer look at an excerpt from \fIOracle.pm\fR (revised
heavily to remove idiosyncrasies) as an example, ignoring things that
were already discussed for pure Perl drivers.
.PP
\fIThe connect method\fR
.IX Subsection "The connect method"
.PP
The connect method is the database handle constructor.
You could write either of two versions of this method: either one which
takes connection attributes (new code) and one which ignores them (old
code only).
.PP
If you ignore the connection attributes, then you omit all mention of
the \fI\f(CI$auth\fI\fR variable (which is a reference to a hash of attributes), and
the \s-1XS\s0 system manages the differences for you.
.PP
.Vb 3
\&  sub connect
\&  {
\&      my ($drh, $dbname, $user, $auth, $attr) = @_;
\&
\&      # Some database specific verifications, default settings
\&      # and the like following here. This should only include
\&      # syntax checks or similar stuff where it\*(Aqs legal to
\&      # \*(Aqdie\*(Aq in case of errors.
\&
\&      my $dbh = DBI::_new_dbh($drh, {
\&              \*(AqName\*(Aq   => $dbname,
\&          })
\&          or return undef;
\&
\&      # Call the driver\-specific function _login in Driver.xs file which
\&      # calls the DBMS\-specific function(s) to connect to the database,
\&      # and populate internal handle data.
\&      DBD::Driver::db::_login($dbh, $dbname, $user, $auth, $attr)
\&          or return undef;
\&
\&      $dbh;
\&  }
.Ve
.PP
This is mostly the same as in the pure Perl case, the exception being
the use of the private \f(CW\*(C`_login()\*(C'\fR callback, which is the function
that will really connect to the database. It is implemented in
\&\fIDriver.xst\fR (you should not implement it) and calls
\&\f(CW\*(C`dbd_db_login6()\*(C'\fR or \f(CW\*(C`dbd_db_login6_sv\*(C'\fR from \fIdbdimp.c\fR. See below
for details.
.PP
If your driver has driver-specific attributes which may be passed in the
connect method and hence end up in \f(CW$attr\fR in \f(CW\*(C`dbd_db_login6\*(C'\fR then it
is best to delete any you process so \s-1DBI\s0 does not send them again
via \s-1STORE\s0 after connect. You can do this in C like this:
.PP
.Vb 2
\&  DBD_ATTRIB_DELETE(attr, "my_attribute_name",
\&                    strlen("my_attribute_name"));
.Ve
.PP
However, prior to \s-1DBI\s0 subversion version 11605 (and fixed post 1.607)
\&\s-1DBD_ATTRIB_DELETE\s0 segfaulted so if you cannot guarantee the \s-1DBI\s0 version
will be post 1.607 you need to use:
.PP
.Vb 2
\&  hv_delete((HV*)SvRV(attr), "my_attribute_name",
\&                     strlen("my_attribute_name"), G_DISCARD);
\&
\& *FIX ME* Discuss removing attributes in Perl code.
.Ve
.PP
\fIThe disconnect_all method\fR
.IX Subsection "The disconnect_all method"
.PP
.Vb 1
\& *FIX ME* T.B.S
.Ve
.PP
\fIThe data_sources method\fR
.IX Subsection "The data_sources method"
.PP
If your \f(CW\*(C`data_sources()\*(C'\fR method can be implemented in pure Perl, then do
so because it is easier than doing it in \s-1XS\s0 code (see the section above
for pure Perl drivers).
.PP
If your \f(CW\*(C`data_sources()\*(C'\fR method must call onto compiled functions, then
you will need to define \fIdbd_dr_data_sources\fR in your \fIdbdimp.h\fR file, which
will trigger \fIDriver.xst\fR (in \fB\s-1DBI\s0\fR v1.33 or greater) to generate the \s-1XS\s0
code that calls your actual C function (see the discussion below for
details) and you do not code anything in \fIDriver.pm\fR to handle it.
.PP
\fIThe prepare method\fR
.IX Subsection "The prepare method"
.PP
The prepare method is the statement handle constructor, and most of it
is not new. Like the \f(CW\*(C`connect()\*(C'\fR method, it now has a C callback:
.PP
.Vb 2
\&  package DBD::Driver::db; # ====== DATABASE ======
\&  use strict;
\&
\&  sub prepare
\&  {
\&      my ($dbh, $statement, $attribs) = @_;
\&
\&      # create a \*(Aqblank\*(Aq sth
\&      my $sth = DBI::_new_sth($dbh, {
\&          \*(AqStatement\*(Aq => $statement,
\&          })
\&          or return undef;
\&
\&      # Call the driver\-specific function _prepare in Driver.xs file
\&      # which calls the DBMS\-specific function(s) to prepare a statement
\&      # and populate internal handle data.
\&      DBD::Driver::st::_prepare($sth, $statement, $attribs)
\&          or return undef;
\&      $sth;
\&  }
.Ve
.PP
\fIThe execute method\fR
.IX Subsection "The execute method"
.PP
.Vb 1
\& *FIX ME* T.B.S
.Ve
.PP
\fIThe fetchrow_arrayref method\fR
.IX Subsection "The fetchrow_arrayref method"
.PP
.Vb 1
\& *FIX ME* T.B.S
.Ve
.PP
\fIOther methods?\fR
.IX Subsection "Other methods?"
.PP
.Vb 1
\& *FIX ME* T.B.S
.Ve
.SS "Driver.xs"
.IX Subsection "Driver.xs"
\&\fIDriver.xs\fR should look something like this:
.PP
.Vb 1
\&  #include "Driver.h"
\&
\&  DBISTATE_DECLARE;
\&
\&  INCLUDE: Driver.xsi
\&
\&  MODULE = DBD::Driver    PACKAGE = DBD::Driver::dr
\&
\&  /* Non\-standard drh XS methods following here, if any.       */
\&  /* If none (the usual case), omit the MODULE line above too. */
\&
\&  MODULE = DBD::Driver    PACKAGE = DBD::Driver::db
\&
\&  /* Non\-standard dbh XS methods following here, if any.       */
\&  /* Currently this includes things like _list_tables from     */
\&  /* DBD::mSQL and DBD::mysql.                                 */
\&
\&  MODULE = DBD::Driver    PACKAGE = DBD::Driver::st
\&
\&  /* Non\-standard sth XS methods following here, if any.       */
\&  /* In particular this includes things like _list_fields from */
\&  /* DBD::mSQL and DBD::mysql for accessing metadata.          */
.Ve
.PP
Note especially the include of \fIDriver.xsi\fR here: \fB\s-1DBI\s0\fR inserts stub
functions for almost all private methods here which will typically do
much work for you.
.PP
Wherever you really have to implement something, it will call a private
function in \fIdbdimp.c\fR, and this is what you have to implement.
.PP
You need to set up an extra routine if your driver needs to export
constants of its own, analogous to the \s-1SQL\s0 types available when you say:
.PP
.Vb 1
\&  use DBI qw(:sql_types);
\&
\& *FIX ME* T.B.S
.Ve
.SS "Driver.h"
.IX Subsection "Driver.h"
\&\fIDriver.h\fR is very simple and the operational contents should look like this:
.PP
.Vb 2
\&  #ifndef DRIVER_H_INCLUDED
\&  #define DRIVER_H_INCLUDED
\&
\&  #define NEED_DBIXS_VERSION 93    /* 93 for DBI versions 1.00 to 1.51+ */
\&  #define PERL_NO_GET_CONTEXT      /* if used require DBI 1.51+ */
\&
\&  #include <DBIXS.h>      /* installed by the DBI module  */
\&
\&  #include "dbdimp.h"
\&
\&  #include "dbivport.h"   /* see below                    */
\&
\&  #include <dbd_xsh.h>    /* installed by the DBI module  */
\&
\&  #endif /* DRIVER_H_INCLUDED */
.Ve
.PP
The \fI\s-1DBIXS\s0.h\fR header defines most of the interesting information that
the writer of a driver needs.
.PP
The file \fIdbd_xsh.h\fR header provides prototype declarations for the C
functions that you might decide to implement. Note that you should
normally only define one of \f(CW\*(C`dbd_db_login()\*(C'\fR, \f(CW\*(C`dbd_db_login6()\*(C'\fR or
\&\f(CW\*(C`dbd_db_login6_sv\*(C'\fR unless you are intent on supporting really old
versions of \fB\s-1DBI\s0\fR (prior to \fB\s-1DBI\s0\fR 1.06) as well as modern
versions. The only standard, \fB\s-1DBI\s0\fR\-mandated functions that you need
write are those specified in the \fIdbd_xsh.h\fR header. You might also
add extra driver-specific functions in \fIDriver.xs\fR.
.PP
The \fIdbivport.h\fR file should be \fIcopied\fR from the latest \fB\s-1DBI\s0\fR release
into your distribution each time you modify your driver. Its job is to
allow you to enhance your code to work with the latest \fB\s-1DBI\s0\fR \s-1API\s0 while
still allowing your driver to be compiled and used with older versions
of the \fB\s-1DBI\s0\fR (for example, when the \f(CW\*(C`DBIh_SET_ERR_CHAR()\*(C'\fR macro was added
to \fB\s-1DBI\s0\fR 1.41, an emulation of it was added to \fIdbivport.h\fR). This makes
users happy and your life easier. Always read the notes in \fIdbivport.h\fR
to check for any limitations in the emulation that you should be aware
of.
.PP
With \fB\s-1DBI\s0\fR v1.51 or better I recommend that the driver defines
\&\fI\s-1PERL_NO_GET_CONTEXT\s0\fR before \fI\s-1DBIXS\s0.h\fR is included. This can significantly
improve efficiency when running under a thread enabled perl. (Remember that
the standard perl in most Linux distributions is built with threads enabled.
So is ActiveState perl for Windows, and perl built for Apache mod_perl2.)
If you do this there are some things to keep in mind:
.IP "\(bu" 4
If \fI\s-1PERL_NO_GET_CONTEXT\s0\fR is defined, then every function that calls the Perl
\&\s-1API\s0 will need to start out with a \f(CW\*(C`dTHX;\*(C'\fR declaration.
.IP "\(bu" 4
You'll know which functions need this, because the C compiler will
complain that the undeclared identifier \f(CW\*(C`my_perl\*(C'\fR is used if \fIand only if\fR
the perl you are using to develop and test your driver has threads enabled.
.IP "\(bu" 4
If you don't remember to test with a thread-enabled perl before making
a release it's likely that you'll get failure reports from users who are.
.IP "\(bu" 4
For driver private functions it is possible to gain even more
efficiency by replacing \f(CW\*(C`dTHX;\*(C'\fR with \f(CW\*(C`pTHX_\*(C'\fR prepended to the
parameter list and then \f(CW\*(C`aTHX_\*(C'\fR prepended to the argument list where
the function is called.
.PP
See \*(L"How multiple interpreters and concurrency are supported\*(R" in perlguts for
additional information about \fI\s-1PERL_NO_GET_CONTEXT\s0\fR.
.SS "Implementation header dbdimp.h"
.IX Subsection "Implementation header dbdimp.h"
This header file has two jobs:
.PP
First it defines data structures for your private part of the handles.
.PP
Second it defines macros that rename the generic names like
\&\f(CW\*(C`dbd_db_login()\*(C'\fR to database specific names like \f(CW\*(C`ora_db_login()\*(C'\fR. This
avoids name clashes and enables use of different drivers when you work
with a statically linked perl.
.PP
It also will have the important task of disabling \s-1XS\s0 methods that you
don't want to implement.
.PP
Finally, the macros will also be used to select alternate
implementations of some functions. For example, the \f(CW\*(C`dbd_db_login()\*(C'\fR
function is not passed the attribute hash.
.PP
Since \fB\s-1DBI\s0\fR v1.06, if a \f(CW\*(C`dbd_db_login6()\*(C'\fR macro is defined (for a function
with 6 arguments), it will be used instead with the attribute hash
passed as the sixth argument.
.PP
Since \fB\s-1DBI\s0\fR post v1.607, if a \f(CW\*(C`dbd_db_login6_sv()\*(C'\fR macro is defined (for
a function like dbd_db_login6 but with scalar pointers for the dbname,
username and password), it will be used instead. This will allow your
login6 function to see if there are any Unicode characters in the
dbname.
.PP
People used to just pick Oracle's \fIdbdimp.c\fR and use the same names,
structures and types. I strongly recommend against that. At first glance
this saves time, but your implementation will be less readable. It was
just hell when I had to separate \fB\s-1DBI\s0\fR specific parts, Oracle specific
parts, mSQL specific parts and mysql specific parts in \fBDBD::mysql\fR's
\&\fIdbdimp.h\fR and \fIdbdimp.c\fR. (\fBDBD::mysql\fR was a port of \fBDBD::mSQL\fR
which was based on \fBDBD::Oracle\fR.) [Seconded, based on the experience
taking \fBDBD::Informix\fR apart, even though the version inherited in 1996
was only based on \fBDBD::Oracle\fR.]
.PP
This part of the driver is \fIyour exclusive part\fR. Rewrite it from
scratch, so it will be clean and short: in other words, a better piece
of code. (Of course keep an eye on other people's work.)
.PP
.Vb 4
\&  struct imp_drh_st {
\&      dbih_drc_t com;           /* MUST be first element in structure   */
\&      /* Insert your driver handle attributes here */
\&  };
\&
\&  struct imp_dbh_st {
\&      dbih_dbc_t com;           /* MUST be first element in structure   */
\&      /* Insert your database handle attributes here */
\&  };
\&
\&  struct imp_sth_st {
\&      dbih_stc_t com;           /* MUST be first element in structure   */
\&      /* Insert your statement handle attributes here */
\&  };
\&
\&  /*  Rename functions for avoiding name clashes; prototypes are  */
\&  /*  in dbd_xsh.h                                                */
\&  #define dbd_init            drv_dr_init
\&  #define dbd_db_login6_sv    drv_db_login_sv
\&  #define dbd_db_do           drv_db_do
\&  ... many more here ...
.Ve
.PP
These structures implement your private part of the handles.
.PP
You \fIhave\fR to use the name \f(CW\*(C`imp_dbh_{dr|db|st}\*(C'\fR and the first field
\&\fImust\fR be of type \fIdbih_drc_t|_dbc_t|_stc_t\fR and \fImust\fR be called
\&\f(CW\*(C`com\*(C'\fR.
.PP
You should never access these fields directly, except by using the
\&\fI\fIDBIc_xxx()\fI\fR macros below.
.SS "Implementation source dbdimp.c"
.IX Subsection "Implementation source dbdimp.c"
Conventionally, \fIdbdimp.c\fR is the main implementation file (but
\&\fBDBD::Informix\fR calls the file \fIdbdimp.ec\fR). This section includes a
short note on each function that is used in the \fIDriver.xsi\fR template
and thus \fIhas\fR to be implemented.
.PP
Of course, you will probably also need to implement other support
functions, which should usually be file static if they are placed in
\&\fIdbdimp.c\fR. If they are placed in other files, you need to list those
files in \fIMakefile.PL\fR (and \fI\s-1MANIFEST\s0\fR) to handle them correctly.
.PP
It is wise to adhere to a namespace convention for your functions to
avoid conflicts. For example, for a driver with prefix \fIdrv_\fR, you
might call externally visible functions \fIdbd_drv_xxxx\fR. You should also
avoid non-constant global variables as much as possible to improve the
support for threading.
.PP
Since Perl requires support for function prototypes (\s-1ANSI\s0 or \s-1ISO\s0 or
Standard C), you should write your code using function prototypes too.
.PP
It is possible to use either the unmapped names such as \f(CW\*(C`dbd_init()\*(C'\fR or
the mapped names such as \f(CW\*(C`dbd_ix_dr_init()\*(C'\fR in the \fIdbdimp.c\fR file.
\&\fBDBD::Informix\fR uses the mapped names which makes it easier to identify
where to look for linkage problems at runtime (which will report errors
using the mapped names).
.PP
Most other drivers, and in particular \fBDBD::Oracle\fR, use the unmapped
names in the source code which makes it a little easier to compare code
between drivers and eases discussions on the \fIdbi-dev\fR mailing list.
The majority of the code fragments here will use the unmapped names.
.PP
Ultimately, you should provide implementations for most of the
functions listed in the \fIdbd_xsh.h\fR header. The exceptions are
optional functions (such as \f(CW\*(C`dbd_st_rows()\*(C'\fR) and those functions with
alternative signatures, such as \f(CW\*(C`dbd_db_login6_sv\*(C'\fR,
\&\f(CW\*(C`dbd_db_login6()\*(C'\fR and \fI\fIdbd_db_login()\fI\fR. Then you should only
implement one of the alternatives, and generally the newer one of the
alternatives.
.PP
\fIThe dbd_init method\fR
.IX Subsection "The dbd_init method"
.PP
.Vb 1
\&  #include "Driver.h"
\&
\&  DBISTATE_DECLARE;
\&
\&  void dbd_init(dbistate_t* dbistate)
\&  {
\&      DBISTATE_INIT;  /*  Initialize the DBI macros  */
\&  }
.Ve
.PP
The \f(CW\*(C`dbd_init()\*(C'\fR function will be called when your driver is first
loaded; the bootstrap command in \f(CW\*(C`DBD::Driver::dr::driver()\*(C'\fR triggers this,
and the call is generated in the \fI\s-1BOOT\s0\fR section of \fIDriver.xst\fR.
These statements are needed to allow your driver to use the \fB\s-1DBI\s0\fR macros.
They will include your private header file \fIdbdimp.h\fR in turn.
Note that \fI\s-1DBISTATE_INIT\s0\fR requires the name of the argument to \f(CW\*(C`dbd_init()\*(C'\fR
to be called \f(CW\*(C`dbistate()\*(C'\fR.
.PP
\fIThe dbd_drv_error method\fR
.IX Subsection "The dbd_drv_error method"
.PP
You need a function to record errors so \fB\s-1DBI\s0\fR can access them properly.
You can call it whatever you like, but we'll call it \f(CW\*(C`dbd_drv_error()\*(C'\fR
here.
.PP
The argument list depends on your database software; different systems
provide different ways to get at error information.
.PP
.Vb 2
\&  static void dbd_drv_error(SV *h, int rc, const char *what)
\&  {
.Ve
.PP
Note that \fIh\fR is a generic handle, may it be a driver handle, a
database or a statement handle.
.PP
.Vb 1
\&      D_imp_xxh(h);
.Ve
.PP
This macro will declare and initialize a variable \fIimp_xxh\fR with
a pointer to your private handle pointer. You may cast this to
to \fIimp_drh_t\fR, \fIimp_dbh_t\fR or \fIimp_sth_t\fR.
.PP
To record the error correctly, equivalent to the \f(CW\*(C`set_err()\*(C'\fR method,
use one of the \f(CW\*(C`DBIh_SET_ERR_CHAR(...)\*(C'\fR or \f(CW\*(C`DBIh_SET_ERR_SV(...)\*(C'\fR macros,
which were added in \fB\s-1DBI\s0\fR 1.41:
.PP
.Vb 2
\&  DBIh_SET_ERR_SV(h, imp_xxh, err, errstr, state, method);
\&  DBIh_SET_ERR_CHAR(h, imp_xxh, err_c, err_i, errstr, state, method);
.Ve
.PP
For \f(CW\*(C`DBIh_SET_ERR_SV\*(C'\fR the \fIerr\fR, \fIerrstr\fR, \fIstate\fR, and \fImethod\fR
parameters are \f(CW\*(C`SV*\*(C'\fR (use &sv_undef instead of \s-1NULL\s0).
.PP
For \f(CW\*(C`DBIh_SET_ERR_CHAR\*(C'\fR the \fIerr_c\fR, \fIerrstr\fR, \fIstate\fR, \fImethod\fR
parameters are \f(CW\*(C`char*\*(C'\fR.
.PP
The \fIerr_i\fR parameter is an \f(CW\*(C`IV\*(C'\fR that's used instead of \fIerr_c\fR if
\&\fIerr_c\fR is \f(CW\*(C`Null\*(C'\fR.
.PP
The \fImethod\fR parameter can be ignored.
.PP
The \f(CW\*(C`DBIh_SET_ERR_CHAR\*(C'\fR macro is usually the simplest to use when you
just have an integer error code and an error message string:
.PP
.Vb 1
\&  DBIh_SET_ERR_CHAR(h, imp_xxh, Nullch, rc, what, Nullch, Nullch);
.Ve
.PP
As you can see, any parameters that aren't relevant to you can be \f(CW\*(C`Null\*(C'\fR.
.PP
To make drivers compatible with \fB\s-1DBI\s0\fR < 1.41 you should be using \fIdbivport.h\fR
as described in \*(L"Driver.h\*(R" above.
.PP
The (obsolete) macros such as \f(CW\*(C`DBIh_EVENT2\*(C'\fR should be removed from drivers.
.PP
The names \f(CW\*(C`dbis\*(C'\fR and \f(CW\*(C`DBIS\*(C'\fR, which were used in previous versions of
this document, should be replaced with the \f(CW\*(C`DBIc_DBISTATE(imp_xxh)\*(C'\fR macro.
.PP
The name \f(CW\*(C`DBILOGFP\*(C'\fR, which was also used in previous versions of this
document, should be replaced by \f(CW\*(C`DBIc_LOGPIO(imp_xxh)\*(C'\fR.
.PP
Your code should not call the C \f(CW\*(C`<stdio.h>\*(C'\fR I/O functions; you
should use \f(CW\*(C`PerlIO_printf()\*(C'\fR as shown:
.PP
.Vb 3
\&      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
\&          PerlIO_printf(DBIc_LOGPIO(imp_xxh), "foobar %s: %s\en",
\&              foo, neatsvpv(errstr,0));
.Ve
.PP
That's the first time we see how tracing works within a \fB\s-1DBI\s0\fR driver. Make
use of this as often as you can, but don't output anything at a trace
level less than 3. Levels 1 and 2 are reserved for the \fB\s-1DBI\s0\fR.
.PP
You can define up to 8 private trace flags using the top 8 bits
of \f(CW\*(C`DBIc_TRACE_FLAGS(imp)\*(C'\fR, that is: \f(CW0xFF000000\fR. See the
\&\f(CW\*(C`parse_trace_flag()\*(C'\fR method elsewhere in this document.
.PP
\fIThe dbd_dr_data_sources method\fR
.IX Subsection "The dbd_dr_data_sources method"
.PP
This method is optional; the support for it was added in \fB\s-1DBI\s0\fR v1.33.
.PP
As noted in the discussion of \fIDriver.pm\fR, if the data sources
can be determined by pure Perl code, do it that way. If, as in
\&\fBDBD::Informix\fR, the information is obtained by a C function call, then
you need to define a function that matches the prototype:
.PP
.Vb 1
\&  extern AV *dbd_dr_data_sources(SV *drh, imp_drh_t *imp_drh, SV *attrs);
.Ve
.PP
An outline implementation for \fBDBD::Informix\fR follows, assuming that the
\&\f(CW\*(C`sqgetdbs()\*(C'\fR function call shown will return up to 100 databases names,
with the pointers to each name in the array dbsname and the name strings
themselves being stores in dbsarea.
.PP
.Vb 7
\&  AV *dbd_dr_data_sources(SV *drh, imp_drh_t *imp_drh, SV *attr)
\&  {
\&      int ndbs;
\&      int i;
\&      char *dbsname[100];
\&      char  dbsarea[10000];
\&      AV *av = Nullav;
\&
\&      if (sqgetdbs(&ndbs, dbsname, 100, dbsarea, sizeof(dbsarea)) == 0)
\&      {
\&          av = NewAV();
\&          av_extend(av, (I32)ndbs);
\&          sv_2mortal((SV *)av);
\&          for (i = 0; i < ndbs; i++)
\&            av_store(av, i, newSVpvf("dbi:Informix:%s", dbsname[i]));
\&      }
\&      return(av);
\&  }
.Ve
.PP
The actual \fBDBD::Informix\fR implementation has a number of extra lines of
code, logs function entry and exit, reports the error from \f(CW\*(C`sqgetdbs()\*(C'\fR,
and uses \f(CW\*(C`#define\*(C'\fR'd constants for the array sizes.
.PP
\fIThe dbd_db_login6 method\fR
.IX Subsection "The dbd_db_login6 method"
.PP
.Vb 2
\&  int dbd_db_login6_sv(SV* dbh, imp_dbh_t* imp_dbh, SV* dbname,
\&                       SV* user, SV* auth, SV *attr);
\&
\&  or
\&
\&  int dbd_db_login6(SV* dbh, imp_dbh_t* imp_dbh, char* dbname,
\&                   char* user, char* auth, SV *attr);
.Ve
.PP
This function will really connect to the database. The argument \fIdbh\fR
is the database handle. \fIimp_dbh\fR is the pointer to the handles private
data, as is \fIimp_xxx\fR in \f(CW\*(C`dbd_drv_error()\*(C'\fR above. The arguments
\&\fIdbname\fR, \fIuser\fR, \fIauth\fR and \fIattr\fR correspond to the arguments of
the driver handle's \f(CW\*(C`connect()\*(C'\fR method.
.PP
You will quite often use database specific attributes here, that are
specified in the \s-1DSN. I\s0 recommend you parse the \s-1DSN \s0(using Perl) within
the \f(CW\*(C`connect()\*(C'\fR method and pass the segments of the \s-1DSN\s0 via the
attributes parameter through \f(CW\*(C`_login()\*(C'\fR to \f(CW\*(C`dbd_db_login6()\*(C'\fR.
.PP
Here's how you fetch them; as an example we use \fIhostname\fR attribute,
which can be up to 12 characters long excluding null terminator:
.PP
.Vb 3
\&  SV** svp;
\&  STRLEN len;
\&  char* hostname;
\&
\&  if ( (svp = DBD_ATTRIB_GET_SVP(attr, "drv_hostname", 12)) && SvTRUE(*svp)) {
\&      hostname = SvPV(*svp, len);
\&      DBD_ATTRIB_DELETE(attr, "drv_hostname", 12); /* avoid later STORE */
\&  } else {
\&      hostname = "localhost";
\&  }
.Ve
.PP
If you handle any driver specific attributes in the dbd_db_login6
method you probably want to delete them from \f(CW\*(C`attr\*(C'\fR (as above with
\&\s-1DBD_ATTRIB_DELETE\s0). If you don't delete your handled attributes \s-1DBI\s0
will call \f(CW\*(C`STORE\*(C'\fR for each attribute after the connect/login and this
is at best redundant for attributes you have already processed.
.PP
\&\fBNote: Until revision 11605 (post \s-1DBI 1.607\s0), there was a problem with
\&\s-1DBD_ATTRIBUTE_DELETE\s0 so unless you require a \s-1DBI\s0 version after 1.607
you need to replace each \s-1DBD_ATTRIBUTE_DELETE\s0 call with:\fR
.PP
.Vb 1
\&  hv_delete((HV*)SvRV(attr), key, key_len, G_DISCARD)
.Ve
.PP
Note that you can also obtain standard attributes such as \fIAutoCommit\fR and
\&\fIChopBlanks\fR from the attributes parameter, using \f(CW\*(C`DBD_ATTRIB_GET_IV\*(C'\fR for
integer attributes.
.PP
If, for example, your database does not support transactions but
\&\fIAutoCommit\fR is set off (requesting transaction support), then you can
emulate a 'failure to connect'.
.PP
Now you should really connect to the database. In general, if the
connection fails, it is best to ensure that all allocated resources are
released so that the handle does not need to be destroyed separately. If
you are successful (and possibly even if you fail but you have allocated
some resources), you should use the following macros:
.PP
.Vb 1
\&  DBIc_IMPSET_on(imp_dbh);
.Ve
.PP
This indicates that the driver (implementor) has allocated resources in
the \fIimp_dbh\fR structure and that the implementors private \f(CW\*(C`dbd_db_destroy()\*(C'\fR
function should be called when the handle is destroyed.
.PP
.Vb 1
\&  DBIc_ACTIVE_on(imp_dbh);
.Ve
.PP
This indicates that the handle has an active connection to the server
and that the \f(CW\*(C`dbd_db_disconnect()\*(C'\fR function should be called before the
handle is destroyed.
.PP
Note that if you do need to fail, you should report errors via the \fIdrh\fR
or \fIimp_drh\fR rather than via \fIdbh\fR or \fIimp_dbh\fR because \fIimp_dbh\fR will be
destroyed by the failure, so errors recorded in that handle will not be
visible to \fB\s-1DBI\s0\fR, and hence not the user either.
.PP
Note too, that the function is passed \fIdbh\fR and \fIimp_dbh\fR, and there
is a macro \f(CW\*(C`D_imp_drh_from_dbh\*(C'\fR which can recover the \fIimp_drh\fR from
the \fIimp_dbh\fR. However, there is no \fB\s-1DBI\s0\fR macro to provide you with the
\&\fIdrh\fR given either the \fIimp_dbh\fR or the \fIdbh\fR or the \fIimp_drh\fR (and
there's no way to recover the \fIdbh\fR given just the \fIimp_dbh\fR).
.PP
This suggests that, despite the above notes about \f(CW\*(C`dbd_drv_error()\*(C'\fR
taking an \f(CW\*(C`SV *\*(C'\fR, it may be better to have two error routines, one
taking \fIimp_dbh\fR and one taking \fIimp_drh\fR instead. With care, you can
factor most of the formatting code out so that these are small routines
calling a common error formatter. See the code in \fBDBD::Informix\fR
1.05.00 for more information.
.PP
The \f(CW\*(C`dbd_db_login6()\*(C'\fR function should return \fI\s-1TRUE\s0\fR for success,
\&\fI\s-1FALSE\s0\fR otherwise.
.PP
Drivers implemented long ago may define the five-argument function
\&\f(CW\*(C`dbd_db_login()\*(C'\fR instead of \f(CW\*(C`dbd_db_login6()\*(C'\fR. The missing argument is
the attributes. There are ways to work around the missing attributes,
but they are ungainly; it is much better to use the 6\-argument form.
Even later drivers will use \f(CW\*(C`dbd_db_login6_sv()\*(C'\fR which provides the
dbname, username and password as SVs.
.PP
\fIThe dbd_db_commit and dbd_db_rollback methods\fR
.IX Subsection "The dbd_db_commit and dbd_db_rollback methods"
.PP
.Vb 2
\&  int dbd_db_commit(SV *dbh, imp_dbh_t *imp_dbh);
\&  int dbd_db_rollback(SV* dbh, imp_dbh_t* imp_dbh);
.Ve
.PP
These are used for commit and rollback. They should return \fI\s-1TRUE\s0\fR for
success, \fI\s-1FALSE\s0\fR for error.
.PP
The arguments \fIdbh\fR and \fIimp_dbh\fR are the same as for \f(CW\*(C`dbd_db_login6()\*(C'\fR
above; I will omit describing them in what follows, as they appear
always.
.PP
These functions should return \fI\s-1TRUE\s0\fR for success, \fI\s-1FALSE\s0\fR otherwise.
.PP
\fIThe dbd_db_disconnect method\fR
.IX Subsection "The dbd_db_disconnect method"
.PP
This is your private part of the \f(CW\*(C`disconnect()\*(C'\fR method. Any \fIdbh\fR with
the \fI\s-1ACTIVE\s0\fR flag on must be disconnected. (Note that you have to set
it in \f(CW\*(C`dbd_db_connect()\*(C'\fR above.)
.PP
.Vb 1
\&  int dbd_db_disconnect(SV* dbh, imp_dbh_t* imp_dbh);
.Ve
.PP
The database handle will return \fI\s-1TRUE\s0\fR for success, \fI\s-1FALSE\s0\fR otherwise.
In any case it should do a:
.PP
.Vb 1
\&  DBIc_ACTIVE_off(imp_dbh);
.Ve
.PP
before returning so \fB\s-1DBI\s0\fR knows that \f(CW\*(C`dbd_db_disconnect()\*(C'\fR was executed.
.PP
Note that there's nothing to stop a \fIdbh\fR being \fIdisconnected\fR while
it still have active children. If your database \s-1API\s0 reacts badly to
trying to use an \fIsth\fR in this situation then you'll need to add code
like this to all \fIsth\fR methods:
.PP
.Vb 2
\&  if (!DBIc_ACTIVE(DBIc_PARENT_COM(imp_sth)))
\&    return 0;
.Ve
.PP
Alternatively, you can add code to your driver to keep explicit track of
the statement handles that exist for each database handle and arrange
to destroy those handles before disconnecting from the database. There
is code to do this in \fBDBD::Informix\fR. Similar comments apply to the
driver handle keeping track of all the database handles.
.PP
Note that the code which destroys the subordinate handles should only
release the associated database resources and mark the handles inactive;
it does not attempt to free the actual handle structures.
.PP
This function should return \fI\s-1TRUE\s0\fR for success, \fI\s-1FALSE\s0\fR otherwise, but
it is not clear what anything can do about a failure.
.PP
\fIThe dbd_db_discon_all method\fR
.IX Subsection "The dbd_db_discon_all method"
.PP
.Vb 1
\&  int dbd_discon_all (SV *drh, imp_drh_t *imp_drh);
.Ve
.PP
This function may be called at shutdown time. It should make
best-efforts to disconnect all database handles \- if possible. Some
databases don't support that, in which case you can do nothing
but return 'success'.
.PP
This function should return \fI\s-1TRUE\s0\fR for success, \fI\s-1FALSE\s0\fR otherwise, but
it is not clear what anything can do about a failure.
.PP
\fIThe dbd_db_destroy method\fR
.IX Subsection "The dbd_db_destroy method"
.PP
This is your private part of the database handle destructor. Any \fIdbh\fR with
the \fI\s-1IMPSET\s0\fR flag on must be destroyed, so that you can safely free
resources. (Note that you have to set it in \f(CW\*(C`dbd_db_connect()\*(C'\fR above.)
.PP
.Vb 4
\&  void dbd_db_destroy(SV* dbh, imp_dbh_t* imp_dbh)
\&  {
\&      DBIc_IMPSET_off(imp_dbh);
\&  }
.Ve
.PP
The \fB\s-1DBI\s0\fR \fIDriver.xst\fR code will have called \f(CW\*(C`dbd_db_disconnect()\*(C'\fR for you,
if the handle is still 'active', before calling \f(CW\*(C`dbd_db_destroy()\*(C'\fR.
.PP
Before returning the function must switch \fI\s-1IMPSET\s0\fR to off, so \fB\s-1DBI\s0\fR knows
that the destructor was called.
.PP
A \fB\s-1DBI\s0\fR handle doesn't keep references to its children. But children
do keep references to their parents. So a database handle won't be
\&\f(CW\*(C`DESTROY\*(C'\fR'd until all its children have been \f(CW\*(C`DESTROY\*(C'\fR'd.
.PP
\fIThe dbd_db_STORE_attrib method\fR
.IX Subsection "The dbd_db_STORE_attrib method"
.PP
This function handles
.PP
.Vb 1
\&  $dbh\->{$key} = $value;
.Ve
.PP
Its prototype is:
.PP
.Vb 2
\&  int dbd_db_STORE_attrib(SV* dbh, imp_dbh_t* imp_dbh, SV* keysv,
\&                          SV* valuesv);
.Ve
.PP
You do not handle all attributes; on the contrary, you should not handle
\&\fB\s-1DBI\s0\fR attributes here: leave this to \fB\s-1DBI\s0\fR. (There are two exceptions,
\&\fIAutoCommit\fR and \fIChopBlanks\fR, which you should care about.)
.PP
The return value is \fI\s-1TRUE\s0\fR if you have handled the attribute or \fI\s-1FALSE\s0\fR
otherwise. If you are handling an attribute and something fails, you
should call \f(CW\*(C`dbd_drv_error()\*(C'\fR, so \fB\s-1DBI\s0\fR can raise exceptions, if desired.
If \f(CW\*(C`dbd_drv_error()\*(C'\fR returns, however, you have a problem: the user will
never know about the error, because he typically will not check
\&\f(CW\*(C`$dbh\->errstr()\*(C'\fR.
.PP
I cannot recommend a general way of going on, if \f(CW\*(C`dbd_drv_error()\*(C'\fR returns,
but there are examples where even the \fB\s-1DBI\s0\fR specification expects that
you \f(CW\*(C`croak()\*(C'\fR. (See the \fIAutoCommit\fR method in \s-1DBI\s0.)
.PP
If you have to store attributes, you should either use your private
data structure \fIimp_xxx\fR, the handle hash (via \f(CW\*(C`(HV*)SvRV(dbh)\*(C'\fR), or use
the private \fIimp_data\fR.
.PP
The first is best for internal C values like integers or pointers and
where speed is important within the driver. The handle hash is best for
values the user may want to get/set via driver-specific attributes.
The private \fIimp_data\fR is an additional \f(CW\*(C`SV\*(C'\fR attached to the handle. You
could think of it as an unnamed handle attribute. It's not normally used.
.PP
\fIThe dbd_db_FETCH_attrib method\fR
.IX Subsection "The dbd_db_FETCH_attrib method"
.PP
This is the counterpart of \f(CW\*(C`dbd_db_STORE_attrib()\*(C'\fR, needed for:
.PP
.Vb 1
\&  $value = $dbh\->{$key};
.Ve
.PP
Its prototype is:
.PP
.Vb 1
\&  SV* dbd_db_FETCH_attrib(SV* dbh, imp_dbh_t* imp_dbh, SV* keysv);
.Ve
.PP
Unlike all previous methods this returns an \f(CW\*(C`SV\*(C'\fR with the value. Note
that you should normally execute \f(CW\*(C`sv_2mortal()\*(C'\fR, if you return a nonconstant
value. (Constant values are \f(CW&sv_undef\fR, \f(CW&sv_no\fR and \f(CW&sv_yes\fR.)
.PP
Note, that \fB\s-1DBI\s0\fR implements a caching algorithm for attribute values.
If you think, that an attribute may be fetched, you store it in the
\&\fIdbh\fR itself:
.PP
.Vb 2
\&  if (cacheit) /* cache value for later DBI \*(Aqquick\*(Aq fetch? */
\&      hv_store((HV*)SvRV(dbh), key, kl, cachesv, 0);
.Ve
.PP
\fIThe dbd_st_prepare method\fR
.IX Subsection "The dbd_st_prepare method"
.PP
This is the private part of the \f(CW\*(C`prepare()\*(C'\fR method. Note that you
\&\fBmust not\fR really execute the statement here. You may, however,
preparse and validate the statement, or do similar things.
.PP
.Vb 2
\&  int dbd_st_prepare(SV* sth, imp_sth_t* imp_sth, char* statement,
\&                     SV* attribs);
.Ve
.PP
A typical, simple, possibility is to do nothing and rely on the perl
\&\f(CW\*(C`prepare()\*(C'\fR code that set the \fIStatement\fR attribute on the handle. This
attribute can then be used by \f(CW\*(C`dbd_st_execute()\*(C'\fR.
.PP
If the driver supports placeholders then the \fI\s-1NUM_OF_PARAMS\s0\fR attribute
must be set correctly by \f(CW\*(C`dbd_st_prepare()\*(C'\fR:
.PP
.Vb 1
\&  DBIc_NUM_PARAMS(imp_sth) = ...
.Ve
.PP
If you can, you should also setup attributes like \fI\s-1NUM_OF_FIELDS\s0\fR, \fI\s-1NAME\s0\fR,
etc. here, but \fB\s-1DBI\s0\fR doesn't require that \- they can be deferred until
\&\fIexecute()\fR is called. However, if you do, document it.
.PP
In any case you should set the \fI\s-1IMPSET\s0\fR flag, as you did in
\&\f(CW\*(C`dbd_db_connect()\*(C'\fR above:
.PP
.Vb 1
\&  DBIc_IMPSET_on(imp_sth);
.Ve
.PP
\fIThe dbd_st_execute method\fR
.IX Subsection "The dbd_st_execute method"
.PP
This is where a statement will really be executed.
.PP
.Vb 1
\&  int dbd_st_execute(SV* sth, imp_sth_t* imp_sth);
.Ve
.PP
\&\f(CW\*(C`dbd_st_execute\*(C'\fR should return \-2 for any error, \-1 if the number of
rows affected is unknown else it should be the number of affected
(updated, inserted) rows.
.PP
Note that you must be aware a statement may be executed repeatedly.
Also, you should not expect that \f(CW\*(C`finish()\*(C'\fR will be called between two
executions, so you might need code, like the following, near the start
of the function:
.PP
.Vb 2
\&  if (DBIc_ACTIVE(imp_sth))
\&      dbd_st_finish(h, imp_sth);
.Ve
.PP
If your driver supports the binding of parameters (it should!), but the
database doesn't, you must do it here. This can be done as follows:
.PP
.Vb 4
\&  SV *svp;
\&  char* statement = DBD_ATTRIB_GET_PV(h, "Statement", 9, svp, "");
\&  int numParam = DBIc_NUM_PARAMS(imp_sth);
\&  int i;
\&
\&  for (i = 0; i < numParam; i++)
\&  {
\&      char* value = dbd_db_get_param(sth, imp_sth, i);
\&      /* It is your drivers task to implement dbd_db_get_param,    */
\&      /* it must be setup as a counterpart of dbd_bind_ph.         */
\&      /* Look for \*(Aq?\*(Aq and replace it with \*(Aqvalue\*(Aq.  Difficult      */
\&      /* task, note that you may have question marks inside        */
\&      /* quotes and comments the like ...  :\-(                     */
\&      /* See DBD::mysql for an example. (Don\*(Aqt look too deep into  */
\&      /* the example, you will notice where I was lazy ...)        */
\&  }
.Ve
.PP
The next thing is to really execute the statement.
.PP
Note that you must set the attributes \fI\s-1NUM_OF_FIELDS\s0\fR, \fI\s-1NAME\s0\fR, etc
when the statement is successfully executed if the driver has not
already done so: they may be used even before a potential \f(CW\*(C`fetchrow()\*(C'\fR.
In particular you have to tell \fB\s-1DBI\s0\fR the number of fields that the
statement has, because it will be used by \fB\s-1DBI\s0\fR internally. Thus the
function will typically ends with:
.PP
.Vb 4
\&  if (isSelectStatement) {
\&      DBIc_NUM_FIELDS(imp_sth) = numFields;
\&      DBIc_ACTIVE_on(imp_sth);
\&  }
.Ve
.PP
It is important that the \fI\s-1ACTIVE\s0\fR flag only be set for \f(CW\*(C`SELECT\*(C'\fR
statements (or any other statements that can return many
values from the database using a cursor-like mechanism). See
\&\f(CW\*(C`dbd_db_connect()\*(C'\fR above for more explanations.
.PP
There plans for a preparse function to be provided by \fB\s-1DBI\s0\fR, but this has
not reached fruition yet.
Meantime, if you want to know how ugly it can get, try looking at the
\&\f(CW\*(C`dbd_ix_preparse()\*(C'\fR in \fBDBD::Informix\fR \fIdbdimp.ec\fR and the related
functions in \fIiustoken.c\fR and \fIsqltoken.c\fR.
.PP
\fIThe dbd_st_fetch method\fR
.IX Subsection "The dbd_st_fetch method"
.PP
This function fetches a row of data. The row is stored in in an array,
of \f(CW\*(C`SV\*(C'\fR's that \fB\s-1DBI\s0\fR prepares for you. This has two advantages: it is fast
(you even reuse the \f(CW\*(C`SV\*(C'\fR's, so they don't have to be created after the
first \f(CW\*(C`fetchrow()\*(C'\fR), and it guarantees that \fB\s-1DBI\s0\fR handles \f(CW\*(C`bind_cols()\*(C'\fR for
you.
.PP
What you do is the following:
.PP
.Vb 6
\&  AV* av;
\&  int numFields = DBIc_NUM_FIELDS(imp_sth); /* Correct, if NUM_FIELDS
\&      is constant for this statement. There are drivers where this is
\&      not the case! */
\&  int chopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);
\&  int i;
\&
\&  if (!fetch_new_row_of_data(...)) {
\&      ... /* check for error or end\-of\-data */
\&      DBIc_ACTIVE_off(imp_sth); /* turn off Active flag automatically */
\&      return Nullav;
\&  }
\&  /* get the fbav (field buffer array value) for this row       */
\&  /* it is very important to only call this after you know      */
\&  /* that you have a row of data to return.                     */
\&  av = DBIc_DBISTATE(imp_sth)\->get_fbav(imp_sth);
\&  for (i = 0; i < numFields; i++) {
\&      SV* sv = fetch_a_field(..., i);
\&      if (chopBlanks && SvOK(sv) && type_is_blank_padded(field_type[i])) {
\&          /*  Remove white space from end (only) of sv  */
\&      }
\&      sv_setsv(AvARRAY(av)[i], sv); /* Note: (re)use! */
\&  }
\&  return av;
.Ve
.PP
There's no need to use a \f(CW\*(C`fetch_a_field()\*(C'\fR function returning an \f(CW\*(C`SV*\*(C'\fR.
It's more common to use your database \s-1API\s0 functions to fetch the
data as character strings and use code like this:
.PP
.Vb 1
\&  sv_setpvn(AvARRAY(av)[i], char_ptr, char_count);
.Ve
.PP
\&\f(CW\*(C`NULL\*(C'\fR values must be returned as \f(CW\*(C`undef\*(C'\fR. You can use code like this:
.PP
.Vb 1
\&  SvOK_off(AvARRAY(av)[i]);
.Ve
.PP
The function returns the \f(CW\*(C`AV\*(C'\fR prepared by \fB\s-1DBI\s0\fR for success or \f(CW\*(C`Nullav\*(C'\fR
otherwise.
.PP
.Vb 3
\& *FIX ME* Discuss what happens when there\*(Aqs no more data to fetch.
\& Are errors permitted if another fetch occurs after the first fetch
\& that reports no more data. (Permitted, not required.)
.Ve
.PP
If an error occurs which leaves the \fI\f(CI$sth\fI\fR in a state where remaining
rows can't be fetched then \fIActive\fR should be turned off before the
method returns.
.PP
\fIThe dbd_st_finish3 method\fR
.IX Subsection "The dbd_st_finish3 method"
.PP
The \f(CW\*(C`$sth\->finish()\*(C'\fR method can be called if the user wishes to
indicate that no more rows will be fetched even if the database has more
rows to offer, and the \fB\s-1DBI\s0\fR code can call the function when handles are
being destroyed. See the \fB\s-1DBI\s0\fR specification for more background details.
.PP
In both circumstances, the \fB\s-1DBI\s0\fR code ends up calling the
\&\f(CW\*(C`dbd_st_finish3()\*(C'\fR method (if you provide a mapping for
\&\f(CW\*(C`dbd_st_finish3()\*(C'\fR in \fIdbdimp.h\fR), or \f(CW\*(C`dbd_st_finish()\*(C'\fR otherwise.
The difference is that \f(CW\*(C`dbd_st_finish3()\*(C'\fR takes a third argument which
is an \f(CW\*(C`int\*(C'\fR with the value 1 if it is being called from a \f(CW\*(C`destroy()\*(C'\fR
method and 0 otherwise.
.PP
Note that \fB\s-1DBI\s0\fR v1.32 and earlier test on \f(CW\*(C`dbd_db_finish3()\*(C'\fR to call
\&\f(CW\*(C`dbd_st_finish3()\*(C'\fR; if you provide \f(CW\*(C`dbd_st_finish3()\*(C'\fR, either define
\&\f(CW\*(C`dbd_db_finish3()\*(C'\fR too, or insist on \fB\s-1DBI\s0\fR v1.33 or later.
.PP
All it \fIneeds\fR to do is turn off the \fIActive\fR flag for the \fIsth\fR.
It will only be called by \fIDriver.xst\fR code, if the driver has set \fI\s-1ACTIVE\s0\fR
to on for the \fIsth\fR.
.PP
Outline example:
.PP
.Vb 8
\&  int dbd_st_finish3(SV* sth, imp_sth_t* imp_sth, int from_destroy) {
\&      if (DBIc_ACTIVE(imp_sth))
\&      {
\&          /* close cursor or equivalent action */
\&          DBIc_ACTIVE_off(imp_sth);
\&      }
\&      return 1;
\&  }
.Ve
.PP
The from_destroy parameter is true if \f(CW\*(C`dbd_st_finish3()\*(C'\fR is being called
from \f(CW\*(C`DESTROY()\*(C'\fR \- and so the statement is about to be destroyed.
For many drivers there is no point in doing anything more than turning off
the \fIActive\fR flag in this case.
.PP
The function returns \fI\s-1TRUE\s0\fR for success, \fI\s-1FALSE\s0\fR otherwise, but there isn't
a lot anyone can do to recover if there is an error.
.PP
\fIThe dbd_st_destroy method\fR
.IX Subsection "The dbd_st_destroy method"
.PP
This function is the private part of the statement handle destructor.
.PP
.Vb 4
\&  void dbd_st_destroy(SV* sth, imp_sth_t* imp_sth) {
\&      ... /* any clean\-up that\*(Aqs needed */
\&      DBIc_IMPSET_off(imp_sth); /* let DBI know we\*(Aqve done it   */
\&  }
.Ve
.PP
The \fB\s-1DBI\s0\fR \fIDriver.xst\fR code will call \f(CW\*(C`dbd_st_finish()\*(C'\fR for you, if the
\&\fIsth\fR has the \fI\s-1ACTIVE\s0\fR flag set, before calling \f(CW\*(C`dbd_st_destroy()\*(C'\fR.
.PP
\fIThe dbd_st_STORE_attrib and dbd_st_FETCH_attrib methods\fR
.IX Subsection "The dbd_st_STORE_attrib and dbd_st_FETCH_attrib methods"
.PP
These functions correspond to \f(CW\*(C`dbd_db_STORE()\*(C'\fR and \f(CW\*(C`dbd_db_FETCH()\*(C'\fR attrib
above, except that they are for statement handles.
See above.
.PP
.Vb 3
\&  int dbd_st_STORE_attrib(SV* sth, imp_sth_t* imp_sth, SV* keysv,
\&                          SV* valuesv);
\&  SV* dbd_st_FETCH_attrib(SV* sth, imp_sth_t* imp_sth, SV* keysv);
.Ve
.PP
\fIThe dbd_bind_ph method\fR
.IX Subsection "The dbd_bind_ph method"
.PP
This function is internally used by the \f(CW\*(C`bind_param()\*(C'\fR method, the
\&\f(CW\*(C`bind_param_inout()\*(C'\fR method and by the \fB\s-1DBI\s0\fR \fIDriver.xst\fR code if
\&\f(CW\*(C`execute()\*(C'\fR is called with any bind parameters.
.PP
.Vb 3
\&  int dbd_bind_ph (SV *sth, imp_sth_t *imp_sth, SV *param,
\&                   SV *value, IV sql_type, SV *attribs,
\&                   int is_inout, IV maxlen);
.Ve
.PP
The \fIparam\fR argument holds an \f(CW\*(C`IV\*(C'\fR with the parameter number (1, 2, ...).
The \fIvalue\fR argument is the parameter value and \fIsql_type\fR is its type.
.PP
If your driver does not support \f(CW\*(C`bind_param_inout()\*(C'\fR then you should
ignore \fImaxlen\fR and croak if \fIis_inout\fR is \fI\s-1TRUE\s0\fR.
.PP
If your driver \fIdoes\fR support \f(CW\*(C`bind_param_inout()\*(C'\fR then you should
note that \fIvalue\fR is the \f(CW\*(C`SV\*(C'\fR \fIafter\fR dereferencing the reference
passed to \f(CW\*(C`bind_param_inout()\*(C'\fR.
.PP
In drivers of simple databases the function will, for example, store
the value in a parameter array and use it later in \f(CW\*(C`dbd_st_execute()\*(C'\fR.
See the \fBDBD::mysql\fR driver for an example.
.PP
\fIImplementing bind_param_inout support\fR
.IX Subsection "Implementing bind_param_inout support"
.PP
To provide support for parameters bound by reference rather than by
value, the driver must do a number of things.  First, and most
importantly, it must note the references and stash them in its own
driver structure.  Secondly, when a value is bound to a column, the
driver must discard any previous reference bound to the column.  On
each execute, the driver must evaluate the references and internally
bind the values resulting from the references.  This is only applicable
if the user writes:
.PP
.Vb 1
\&  $sth\->execute;
.Ve
.PP
If the user writes:
.PP
.Vb 1
\&  $sth\->execute(@values);
.Ve
.PP
then \fB\s-1DBI\s0\fR automatically calls the binding code for each element of
\&\fI\f(CI@values\fI\fR.  These calls are indistinguishable from explicit user calls to
\&\f(CW\*(C`bind_param()\*(C'\fR.
.SS "C/XS version of Makefile.PL"
.IX Subsection "C/XS version of Makefile.PL"
The \fIMakefile.PL\fR file for a C/XS driver is similar to the code needed
for a pure Perl driver, but there are a number of extra bits of
information needed by the build system.
.PP
For example, the attributes list passed to \f(CW\*(C`WriteMakefile()\*(C'\fR needs
to specify the object files that need to be compiled and built into
the shared object (\s-1DLL\s0). This is often, but not necessarily, just
\&\fIdbdimp.o\fR (unless that should be \fIdbdimp.obj\fR because you're building
on \s-1MS\s0 Windows).
.PP
Note that you can reliably determine the extension of the object files
from the \fI\f(CI$Config\fI{obj_ext}\fR values, and there are many other useful pieces
of configuration information lurking in that hash.
You get access to it with:
.PP
.Vb 1
\&    use Config;
.Ve
.SS "Methods which do not need to be written"
.IX Subsection "Methods which do not need to be written"
The \fB\s-1DBI\s0\fR code implements the majority of the methods which are accessed
using the notation \f(CW\*(C`DBI\->function()\*(C'\fR, the only exceptions being
\&\f(CW\*(C`DBI\->connect()\*(C'\fR and \f(CW\*(C`DBI\->data_sources()\*(C'\fR which require
support from the driver.
.PP
The \fB\s-1DBI\s0\fR code implements the following documented driver, database and
statement functions which do not need to be written by the \fB\s-1DBD\s0\fR driver
writer.
.ie n .IP "$dbh\->\fIdo()\fR" 4
.el .IP "\f(CW$dbh\fR\->\fIdo()\fR" 4
.IX Item "$dbh->do()"
The default implementation of this function prepares, executes and
destroys the statement.  This can be replaced if there is a better
way to implement this, such as \f(CW\*(C`EXECUTE IMMEDIATE\*(C'\fR which can
sometimes be used if there are no parameters.
.ie n .IP "$h\->\fIerrstr()\fR" 4
.el .IP "\f(CW$h\fR\->\fIerrstr()\fR" 4
.IX Item "$h->errstr()"
.PD 0
.ie n .IP "$h\->\fIerr()\fR" 4
.el .IP "\f(CW$h\fR\->\fIerr()\fR" 4
.IX Item "$h->err()"
.ie n .IP "$h\->\fIstate()\fR" 4
.el .IP "\f(CW$h\fR\->\fIstate()\fR" 4
.IX Item "$h->state()"
.ie n .IP "$h\->\fItrace()\fR" 4
.el .IP "\f(CW$h\fR\->\fItrace()\fR" 4
.IX Item "$h->trace()"
.PD
The \fB\s-1DBD\s0\fR driver does not need to worry about these routines at all.
.ie n .IP "$h\->{ChopBlanks}" 4
.el .IP "\f(CW$h\fR\->{ChopBlanks}" 4
.IX Item "$h->{ChopBlanks}"
This attribute needs to be honored during \f(CW\*(C`fetch()\*(C'\fR operations, but does
not need to be handled by the attribute handling code.
.ie n .IP "$h\->{RaiseError}" 4
.el .IP "\f(CW$h\fR\->{RaiseError}" 4
.IX Item "$h->{RaiseError}"
The \fB\s-1DBD\s0\fR driver does not need to worry about this attribute at all.
.ie n .IP "$h\->{PrintError}" 4
.el .IP "\f(CW$h\fR\->{PrintError}" 4
.IX Item "$h->{PrintError}"
The \fB\s-1DBD\s0\fR driver does not need to worry about this attribute at all.
.ie n .IP "$sth\->\fIbind_col()\fR" 4
.el .IP "\f(CW$sth\fR\->\fIbind_col()\fR" 4
.IX Item "$sth->bind_col()"
Assuming the driver uses the \f(CW\*(C`DBIc_DBISTATE(imp_xxh)\->get_fbav()\*(C'\fR
function (C drivers, see below), or the \f(CW\*(C`$sth\->_set_fbav($data)\*(C'\fR
method (Perl drivers) the driver does not need to do anything about this
routine.
.ie n .IP "$sth\->\fIbind_columns()\fR" 4
.el .IP "\f(CW$sth\fR\->\fIbind_columns()\fR" 4
.IX Item "$sth->bind_columns()"
Regardless of whether the driver uses
\&\f(CW\*(C`DBIc_DBISTATE(imp_xxh)\->get_fbav()\*(C'\fR, the driver does not need
to do anything about this routine as it simply iteratively calls
\&\f(CW\*(C`$sth\->bind_col()\*(C'\fR.
.PP
The \fB\s-1DBI\s0\fR code implements a default implementation of the following
functions which do not need to be written by the \fB\s-1DBD\s0\fR driver writer
unless the default implementation is incorrect for the Driver.
.ie n .IP "$dbh\->\fIquote()\fR" 4
.el .IP "\f(CW$dbh\fR\->\fIquote()\fR" 4
.IX Item "$dbh->quote()"
This should only be written if the database does not accept the \s-1ANSI
SQL\s0 standard for quoting strings, with the string enclosed in single
quotes and any embedded single quotes replaced by two consecutive
single quotes.
.Sp
For the two argument form of quote, you need to implement the
\&\f(CW\*(C`type_info()\*(C'\fR method to provide the information that quote needs.
.ie n .IP "$dbh\->\fIping()\fR" 4
.el .IP "\f(CW$dbh\fR\->\fIping()\fR" 4
.IX Item "$dbh->ping()"
This should be implemented as a simple efficient way to determine
whether the connection to the database is still alive. Typically
code like this:
.Sp
.Vb 9
\&  sub ping {
\&      my $dbh = shift;
\&      $sth = $dbh\->prepare_cached(q{
\&          select * from A_TABLE_NAME where 1=0
\&      }) or return 0;
\&      $sth\->execute or return 0;
\&      $sth\->finish;
\&      return 1;
\&  }
.Ve
.Sp
where \fIA_TABLE_NAME\fR is the name of a table that always exists (such as a
database system catalogue).
.ie n .IP "$drh\->default_user" 4
.el .IP "\f(CW$drh\fR\->default_user" 4
.IX Item "$drh->default_user"
The default implementation of default_user will get the database
username and password fields from \f(CW$ENV{DBI_USER}\fR and
\&\f(CW$ENV{DBI_PASS}\fR. You can override this method. It is called as
follows:
.Sp
.Vb 1
\&  ($user, $pass) = $drh\->default_user($user, $pass, $attr)
.Ve
.SH "METADATA METHODS"
.IX Header "METADATA METHODS"
The exposition above ignores the \fB\s-1DBI\s0\fR MetaData methods.
The metadata methods are all associated with a database handle.
.SS "Using DBI::DBD::Metadata"
.IX Subsection "Using DBI::DBD::Metadata"
The \fBDBI::DBD::Metadata\fR module is a good semi-automatic way for the
developer of a \fB\s-1DBD\s0\fR module to write the \f(CW\*(C`get_info()\*(C'\fR and \f(CW\*(C`type_info()\*(C'\fR
functions quickly and accurately.
.PP
\fIGenerating the get_info method\fR
.IX Subsection "Generating the get_info method"
.PP
Prior to \fB\s-1DBI\s0\fR v1.33, this existed as the method \f(CW\*(C`write_getinfo_pm()\*(C'\fR
in the \fB\s-1DBI::DBD\s0\fR module. From \fB\s-1DBI\s0\fR v1.33, it exists as the method
\&\f(CW\*(C`write_getinfo_pm()\*(C'\fR in the \fBDBI::DBD::Metadata\fR module. This
discussion assumes you have \fB\s-1DBI\s0\fR v1.33 or later.
.PP
You examine the documentation for \f(CW\*(C`write_getinfo_pm()\*(C'\fR using:
.PP
.Vb 1
\&    perldoc DBI::DBD::Metadata
.Ve
.PP
To use it, you need a Perl \fB\s-1DBI\s0\fR driver for your database which implements
the \f(CW\*(C`get_info()\*(C'\fR method. In practice, this means you need to install
\&\fB\s-1DBD::ODBC\s0\fR, an \s-1ODBC\s0 driver manager, and an \s-1ODBC\s0 driver for your
database.
.PP
With the pre-requisites in place, you might type:
.PP
.Vb 2
\&    perl \-MDBI::DBD::Metadata \-we \e
\&       "write_getinfo_pm (qw{ dbi:ODBC:foo_db username password Driver })"
.Ve
.PP
The procedure writes to standard output the code that should be added to
your \fIDriver.pm\fR file and the code that should be written to
\&\fIlib/DBD/Driver/GetInfo.pm\fR.
.PP
You should review the output to ensure that it is sensible.
.PP
\fIGenerating the type_info method\fR
.IX Subsection "Generating the type_info method"
.PP
Given the idea of the \f(CW\*(C`write_getinfo_pm()\*(C'\fR method, it was not hard
to devise a parallel method, \f(CW\*(C`write_typeinfo_pm()\*(C'\fR, which does the
analogous job for the \fB\s-1DBI\s0\fR \f(CW\*(C`type_info_all()\*(C'\fR metadata method. The
\&\f(CW\*(C`write_typeinfo_pm()\*(C'\fR method was added to \fB\s-1DBI\s0\fR v1.33.
.PP
You examine the documentation for \f(CW\*(C`write_typeinfo_pm()\*(C'\fR using:
.PP
.Vb 1
\&    perldoc DBI::DBD::Metadata
.Ve
.PP
The setup is exactly analogous to the mechanism described in
\&\*(L"Generating the get_info method\*(R".
.PP
With the pre-requisites in place, you might type:
.PP
.Vb 2
\&    perl \-MDBI::DBD::Metadata \-we \e
\&       "write_typeinfo (qw{ dbi:ODBC:foo_db username password Driver })"
.Ve
.PP
The procedure writes to standard output the code that should be added to
your \fIDriver.pm\fR file and the code that should be written to
\&\fIlib/DBD/Driver/TypeInfo.pm\fR.
.PP
You should review the output to ensure that it is sensible.
.SS "Writing DBD::Driver::db::get_info"
.IX Subsection "Writing DBD::Driver::db::get_info"
If you use the \fBDBI::DBD::Metadata\fR module, then the code you need is
generated for you.
.PP
If you decide not to use the \fBDBI::DBD::Metadata\fR module, you
should probably borrow the code from a driver that has done so (eg
\&\fBDBD::Informix\fR from version 1.05 onwards) and crib the code from
there, or look at the code that generates that module and follow
that. The method in \fIDriver.pm\fR will be very simple; the method in
\&\fIlib/DBD/Driver/GetInfo.pm\fR is not very much more complex unless your
\&\s-1DBMS\s0 itself is much more complex.
.PP
Note that some of the \fB\s-1DBI\s0\fR utility methods rely on information from the
\&\f(CW\*(C`get_info()\*(C'\fR method to perform their operations correctly. See, for
example, the \f(CW\*(C`quote_identifier()\*(C'\fR and quote methods, discussed below.
.SS "Writing DBD::Driver::db::type_info_all"
.IX Subsection "Writing DBD::Driver::db::type_info_all"
If you use the \f(CW\*(C`DBI::DBD::Metadata\*(C'\fR module, then the code you need is
generated for you.
.PP
If you decide not to use the \f(CW\*(C`DBI::DBD::Metadata\*(C'\fR module, you
should probably borrow the code from a driver that has done so (eg
\&\f(CW\*(C`DBD::Informix\*(C'\fR from version 1.05 onwards) and crib the code from
there, or look at the code that generates that module and follow
that. The method in \fIDriver.pm\fR will be very simple; the method in
\&\fIlib/DBD/Driver/TypeInfo.pm\fR is not very much more complex unless your
\&\s-1DBMS\s0 itself is much more complex.
.SS "Writing DBD::Driver::db::type_info"
.IX Subsection "Writing DBD::Driver::db::type_info"
The guidelines on writing this method are still not really clear.
No sample implementation is available.
.SS "Writing DBD::Driver::db::table_info"
.IX Subsection "Writing DBD::Driver::db::table_info"
.Vb 2
\& *FIX ME* The guidelines on writing this method have not been written yet.
\& No sample implementation is available.
.Ve
.SS "Writing DBD::Driver::db::column_info"
.IX Subsection "Writing DBD::Driver::db::column_info"
.Vb 2
\& *FIX ME* The guidelines on writing this method have not been written yet.
\& No sample implementation is available.
.Ve
.SS "Writing DBD::Driver::db::primary_key_info"
.IX Subsection "Writing DBD::Driver::db::primary_key_info"
.Vb 2
\& *FIX ME* The guidelines on writing this method have not been written yet.
\& No sample implementation is available.
.Ve
.SS "Writing DBD::Driver::db::primary_key"
.IX Subsection "Writing DBD::Driver::db::primary_key"
.Vb 2
\& *FIX ME* The guidelines on writing this method have not been written yet.
\& No sample implementation is available.
.Ve
.SS "Writing DBD::Driver::db::foreign_key_info"
.IX Subsection "Writing DBD::Driver::db::foreign_key_info"
.Vb 2
\& *FIX ME* The guidelines on writing this method have not been written yet.
\& No sample implementation is available.
.Ve
.SS "Writing DBD::Driver::db::tables"
.IX Subsection "Writing DBD::Driver::db::tables"
This method generates an array of names in a format suitable for being
embedded in \s-1SQL\s0 statements in places where a table name is expected.
.PP
If your database hews close enough to the \s-1SQL\s0 standard or if you have
implemented an appropriate \f(CW\*(C`table_info()\*(C'\fR function and and the appropriate
\&\f(CW\*(C`quote_identifier()\*(C'\fR function, then the \fB\s-1DBI\s0\fR default version of this method
will work for your driver too.
.PP
Otherwise, you have to write a function yourself, such as:
.PP
.Vb 12
\&    sub tables
\&    {
\&        my($dbh, $cat, $sch, $tab, $typ) = @_;
\&        my(@res);
\&        my($sth) = $dbh\->table_info($cat, $sch, $tab, $typ);
\&        my(@arr);
\&        while (@arr = $sth\->fetchrow_array)
\&        {
\&            push @res, $dbh\->quote_identifier($arr[0], $arr[1], $arr[2]);
\&        }
\&        return @res;
\&    }
.Ve
.PP
See also the default implementation in \fI\s-1DBI\s0.pm\fR.
.SS "Writing DBD::Driver::db::quote"
.IX Subsection "Writing DBD::Driver::db::quote"
This method takes a value and converts it into a string suitable for
embedding in an \s-1SQL\s0 statement as a string literal.
.PP
If your \s-1DBMS\s0 accepts the \s-1SQL\s0 standard notation for strings (single
quotes around the string as a whole with any embedded single quotes
doubled up), then you do not need to write this method as \fB\s-1DBI\s0\fR provides a
default method that does it for you.
.PP
If your \s-1DBMS\s0 uses an alternative notation or escape mechanism, then you
need to provide an equivalent function. For example, suppose your \s-1DBMS\s0
used C notation with double quotes around the string and backslashes
escaping both double quotes and backslashes themselves. Then you might
write the function as:
.PP
.Vb 6
\&    sub quote
\&    {
\&        my($dbh, $str) = @_;
\&        $str =~ s/["\e\e]/\e\e$&/gmo;
\&        return qq{"$str"};
\&    }
.Ve
.PP
Handling newlines and other control characters is left as an exercise
for the reader.
.PP
This sample method ignores the \fI\f(CI$data_type\fI\fR indicator which is the
optional second argument to the method.
.SS "Writing DBD::Driver::db::quote_identifier"
.IX Subsection "Writing DBD::Driver::db::quote_identifier"
This method is called to ensure that the name of the given table (or
other database object) can be embedded into an \s-1SQL\s0 statement without
danger of misinterpretation. The result string should be usable in the
text of an \s-1SQL\s0 statement as the identifier for a table.
.PP
If your \s-1DBMS\s0 accepts the \s-1SQL\s0 standard notation for quoted identifiers
(which uses double quotes around the identifier as a whole, with any
embedded double quotes doubled up) and accepts \fI\*(L"schema\*(R".\*(L"identifier\*(R"\fR
(and \fI\*(L"catalog\*(R".\*(L"schema\*(R".\*(L"identifier\*(R"\fR when a catalog is specified), then
you do not need to write this method as \fB\s-1DBI\s0\fR provides a default method
that does it for you.
.PP
In fact, even if your \s-1DBMS\s0 does not handle exactly that notation but
you have implemented the \f(CW\*(C`get_info()\*(C'\fR method and it gives the correct
responses, then it will work for you. If your database is fussier, then
you need to implement your own version of the function.
.PP
For example, \fBDBD::Informix\fR has to deal with an environment variable
\&\fI\s-1DELIMIDENT\s0\fR. If it is not set, then the \s-1DBMS\s0 treats names enclosed in
double quotes as strings rather than names, which is usually a syntax
error. Additionally, the catalog portion of the name is separated from
the schema and table by a different delimiter (colon instead of dot),
and the catalog portion is never enclosed in quotes. (Fortunately,
valid strings for the catalog will never contain weird characters that
might need to be escaped, unless you count dots, dashes, slashes and
at-signs as weird.) Finally, an Informix database can contain objects
that cannot be accessed because they were created by a user with the
\&\fI\s-1DELIMIDENT\s0\fR environment variable set, but the current user does not
have it set. By design choice, the \f(CW\*(C`quote_identifier()\*(C'\fR method encloses
those identifiers in double quotes anyway, which generally triggers a
syntax error, and the metadata methods which generate lists of tables
etc omit those identifiers from the result sets.
.PP
.Vb 10
\&    sub quote_identifier
\&    {
\&        my($dbh, $cat, $sch, $obj) = @_;
\&        my($rv) = "";
\&        my($qq) = (defined $ENV{DELIMIDENT}) ? \*(Aq"\*(Aq : \*(Aq\*(Aq;
\&        $rv .= qq{$cat:} if (defined $cat);
\&        if (defined $sch)
\&        {
\&            if ($sch !~ m/^\ew+$/o)
\&            {
\&                $qq = \*(Aq"\*(Aq;
\&                $sch =~ s/$qq/$qq$qq/gm;
\&            }
\&            $rv .= qq{$qq$sch$qq.};
\&        }
\&        if (defined $obj)
\&        {
\&            if ($obj !~ m/^\ew+$/o)
\&            {
\&                $qq = \*(Aq"\*(Aq;
\&                $obj =~ s/$qq/$qq$qq/gm;
\&            }
\&            $rv .= qq{$qq$obj$qq};
\&        }
\&        return $rv;
\&    }
.Ve
.PP
Handling newlines and other control characters is left as an exercise
for the reader.
.PP
Note that there is an optional fourth parameter to this function which
is a reference to a hash of attributes; this sample implementation
ignores that.
.PP
This sample implementation also ignores the single-argument variant of
the method.
.SH "TRACING"
.IX Header "TRACING"
Tracing in \s-1DBI\s0 is controlled with a combination of a trace level and a
set of flags which together are known as the trace settings. The trace
settings are stored in a single integer and divided into levels and
flags by a set of masks (\f(CW\*(C`DBIc_TRACE_LEVEL_MASK\*(C'\fR and
\&\f(CW\*(C`DBIc_TRACE_FLAGS_MASK\*(C'\fR).
.PP
Each handle has it's own trace settings and so does the \s-1DBI.\s0 When you
call a method the \s-1DBI\s0 merges the handles settings into its own for the
duration of the call: the trace flags of the handle are \s-1OR\s0'd into the
trace flags of the \s-1DBI,\s0 and if the handle has a higher trace level
then the \s-1DBI\s0 trace level is raised to match it. The previous \s-1DBI\s0 trace
settings are restored when the called method returns.
.SS "Trace Level"
.IX Subsection "Trace Level"
The trace level is the first 4 bits of the trace settings (masked by
\&\f(CW\*(C`DBIc_TRACE_FLAGS_MASK\*(C'\fR) and represents trace levels of 1 to 15. Do
not output anything at trace levels less than 3 as they are reserved
for \s-1DBI.\s0
.PP
For advice on what to output at each level see \*(L"Trace Levels\*(R" in
\&\s-1DBI\s0.
.PP
To test for a trace level you can use the \f(CW\*(C`DBIc_TRACE_LEVEL\*(C'\fR macro
like this:
.PP
.Vb 3
\&  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {
\&      PerlIO_printf(DBIc_LOGPIO(imp_xxh), "foobar");
\&  }
.Ve
.PP
Also \fBnote\fR the use of PerlIO_printf which you should always use for
tracing and never the C \f(CW\*(C`stdio.h\*(C'\fR I/O functions.
.SS "Trace Flags"
.IX Subsection "Trace Flags"
Trace flags are used to enable tracing of specific activities within
the \s-1DBI\s0 and drivers. The \s-1DBI\s0 defines some trace flags and drivers can
define others. \s-1DBI\s0 trace flag names begin with a capital letter and
driver specific names begin with a lowercase letter. For a list of \s-1DBI\s0
defined trace flags see \*(L"Trace Flags\*(R" in \s-1DBI\s0.
.PP
If you want to use private trace flags you'll probably want to be able
to set them by name. Drivers are expected to override the
parse_trace_flag (note the singular) and check if \f(CW$trace_flag_name\fR is
a driver specific trace flags and, if not, then call the DBIs default
\&\fIparse_trace_flag()\fR. To do that you'll need to define a
\&\fIparse_trace_flag()\fR method like this:
.PP
.Vb 9
\&  sub parse_trace_flag {
\&      my ($h, $name) = @_;
\&      return 0x01000000 if $name eq \*(Aqfoo\*(Aq;
\&      return 0x02000000 if $name eq \*(Aqbar\*(Aq;
\&      return 0x04000000 if $name eq \*(Aqbaz\*(Aq;
\&      return 0x08000000 if $name eq \*(Aqboo\*(Aq;
\&      return 0x10000000 if $name eq \*(Aqbop\*(Aq;
\&      return $h\->SUPER::parse_trace_flag($name);
\&  }
.Ve
.PP
All private flag names must be lowercase, and all private flags must
be in the top 8 of the 32 bits of \f(CW\*(C`DBIc_TRACE_FLAGS(imp)\*(C'\fR i.e.,
0xFF000000.
.PP
If you've defined a \fIparse_trace_flag()\fR method in ::db you'll also want
it in ::st, so just alias it in:
.PP
.Vb 1
\&  *parse_trace_flag = \e&DBD::foo:db::parse_trace_flag;
.Ve
.PP
You may want to act on the current '\s-1SQL\s0' trace flag that \s-1DBI\s0 defines
to output \s-1SQL\s0 prepared/executed as \s-1DBI\s0 currently does not do \s-1SQL\s0
tracing.
.SS "Trace Macros"
.IX Subsection "Trace Macros"
Access to the trace level and trace flags is via a set of macros.
.PP
.Vb 4
\&  DBIc_TRACE_SETTINGS(imp) returns the trace settings
\&  DBIc_TRACE_LEVEL(imp) returns the trace level
\&  DBIc_TRACE_FLAGS(imp) returns the trace flags
\&  DBIc_TRACE(imp, flags, flaglevel, level)
\&
\&  e.g.,
\&
\&  DBIc_TRACE(imp, 0, 0, 4)
\&    if level >= 4
\&
\&  DBIc_TRACE(imp, DBDtf_FOO, 2, 4)
\&    if tracing DBDtf_FOO & level>=2 or level>=4
\&
\&  DBIc_TRACE(imp, DBDtf_FOO, 2, 0)
\&    as above but never trace just due to level
.Ve
.SH "WRITING AN EMULATION LAYER FOR AN OLD PERL INTERFACE"
.IX Header "WRITING AN EMULATION LAYER FOR AN OLD PERL INTERFACE"
Study \fIOraperl.pm\fR (supplied with \fBDBD::Oracle\fR) and \fIIngperl.pm\fR (supplied
with \fBDBD::Ingres\fR) and the corresponding \fIdbdimp.c\fR files for ideas.
.PP
Note that the emulation code sets \f(CW\*(C`$dbh\->{CompatMode} = 1;\*(C'\fR for each
connection so that the internals of the driver can implement behaviour
compatible with the old interface when dealing with those handles.
.SS "Setting emulation perl variables"
.IX Subsection "Setting emulation perl variables"
For example, ingperl has a \fI\f(CI$sql_rowcount\fI\fR variable. Rather than try
to manually update this in \fIIngperl.pm\fR it can be done faster in C code.
In \f(CW\*(C`dbd_init()\*(C'\fR:
.PP
.Vb 1
\&  sql_rowcount = perl_get_sv("Ingperl::sql_rowcount", GV_ADDMULTI);
.Ve
.PP
In the relevant places do:
.PP
.Vb 2
\&  if (DBIc_COMPAT(imp_sth))     /* only do this for compatibility mode handles */
\&      sv_setiv(sql_rowcount, the_row_count);
.Ve
.SH "OTHER MISCELLANEOUS INFORMATION"
.IX Header "OTHER MISCELLANEOUS INFORMATION"
.SS "The imp_xyz_t types"
.IX Subsection "The imp_xyz_t types"
Any handle has a corresponding C structure filled with private data.
Some of this data is reserved for use by \fB\s-1DBI\s0\fR (except for using the
DBIc macros below), some is for you. See the description of the
\&\fIdbdimp.h\fR file above for examples. Most functions in \fIdbdimp.c\fR
are passed both the handle \f(CW\*(C`xyz\*(C'\fR and a pointer to \f(CW\*(C`imp_xyz\*(C'\fR. In
rare cases, however, you may use the following macros:
.IP "D_imp_dbh(dbh)" 4
.IX Item "D_imp_dbh(dbh)"
Given a function argument \fIdbh\fR, declare a variable \fIimp_dbh\fR and
initialize it with a pointer to the handles private data. Note: This
must be a part of the function header, because it declares a variable.
.IP "D_imp_sth(sth)" 4
.IX Item "D_imp_sth(sth)"
Likewise for statement handles.
.IP "D_imp_xxx(h)" 4
.IX Item "D_imp_xxx(h)"
Given any handle, declare a variable \fIimp_xxx\fR and initialize it
with a pointer to the handles private data. It is safe, for example,
to cast \fIimp_xxx\fR to \f(CW\*(C`imp_dbh_t*\*(C'\fR, if \f(CW\*(C`DBIc_TYPE(imp_xxx) == DBIt_DB\*(C'\fR.
(You can also call \f(CW\*(C`sv_derived_from(h, "DBI::db")\*(C'\fR, but that's much
slower.)
.IP "D_imp_dbh_from_sth" 4
.IX Item "D_imp_dbh_from_sth"
Given a \fIimp_sth\fR, declare a variable \fIimp_dbh\fR and initialize it with a
pointer to the parent database handle's implementors structure.
.SS "Using DBIc_IMPSET_on"
.IX Subsection "Using DBIc_IMPSET_on"
The driver code which initializes a handle should use \f(CW\*(C`DBIc_IMPSET_on()\*(C'\fR
as soon as its state is such that the cleanup code must be called.
When this happens is determined by your driver code.
.PP
\&\fBFailure to call this can lead to corruption of data structures.\fR
.PP
For example, \fBDBD::Informix\fR maintains a linked list of database
handles in the driver, and within each handle, a linked list of
statements. Once a statement is added to the linked list, it is crucial
that it is cleaned up (removed from the list). When \fI\fIDBIc_IMPSET_on()\fI\fR
was being called too late, it was able to cause all sorts of problems.
.SS "Using \fIDBIc_is()\fP, \fIDBIc_has()\fP, \fIDBIc_on()\fP and \fIDBIc_off()\fP"
.IX Subsection "Using DBIc_is(), DBIc_has(), DBIc_on() and DBIc_off()"
Once upon a long time ago, the only way of handling the internal \fB\s-1DBI\s0\fR
boolean flags/attributes was through macros such as:
.PP
.Vb 2
\&  DBIc_WARN       DBIc_WARN_on        DBIc_WARN_off
\&  DBIc_COMPAT     DBIc_COMPAT_on      DBIc_COMPAT_off
.Ve
.PP
Each of these took an \fIimp_xxh\fR pointer as an argument.
.PP
Since then, new attributes have been added such as \fIChopBlanks\fR,
\&\fIRaiseError\fR and \fIPrintError\fR, and these do not have the full set of
macros. The approved method for handling these is now the four macros:
.PP
.Vb 5
\&  DBIc_is(imp, flag)
\&  DBIc_has(imp, flag)       an alias for DBIc_is
\&  DBIc_on(imp, flag)
\&  DBIc_off(imp, flag)
\&  DBIc_set(imp, flag, on)   set if on is true, else clear
.Ve
.PP
Consequently, the \f(CW\*(C`DBIc_XXXXX\*(C'\fR family of macros is now mostly deprecated
and new drivers should avoid using them, even though the older drivers
will probably continue to do so for quite a while yet. However...
.PP
There is an \fIimportant exception\fR to that. The \fI\s-1ACTIVE\s0\fR and \fI\s-1IMPSET\s0\fR
flags should be set via the \f(CW\*(C`DBIc_ACTIVE_on()\*(C'\fR and \f(CW\*(C`DBIc_IMPSET_on()\*(C'\fR macros,
and unset via the \f(CW\*(C`DBIc_ACTIVE_off()\*(C'\fR and \f(CW\*(C`DBIc_IMPSET_off()\*(C'\fR macros.
.SS "Using the \fIget_fbav()\fP method"
.IX Subsection "Using the get_fbav() method"
\&\fB\s-1THIS IS CRITICAL\s0 for C/XS drivers\fR.
.PP
The \f(CW\*(C`$sth\->bind_col()\*(C'\fR and \f(CW\*(C`$sth\->bind_columns()\*(C'\fR documented
in the \fB\s-1DBI\s0\fR specification do not have to be implemented by the driver
writer because \fB\s-1DBI\s0\fR takes care of the details for you.
.PP
However, the key to ensuring that bound columns work is to call the
function \f(CW\*(C`DBIc_DBISTATE(imp_xxh)\->get_fbav()\*(C'\fR in the code which
fetches a row of data.
.PP
This returns an \f(CW\*(C`AV\*(C'\fR, and each element of the \f(CW\*(C`AV\*(C'\fR contains the \f(CW\*(C`SV\*(C'\fR which
should be set to contain the returned data.
.PP
The pure Perl equivalent is the \f(CW\*(C`$sth\->_set_fbav($data)\*(C'\fR method, as
described in the part on pure Perl drivers.
.SS "Casting strings to Perl types based on a \s-1SQL\s0 type"
.IX Subsection "Casting strings to Perl types based on a SQL type"
\&\s-1DBI\s0 from 1.611 (and \s-1DBIXS_REVISION 13606\s0) defines the
sql_type_cast_svpv method which may be used to cast a string
representation of a value to a more specific Perl type based on a \s-1SQL\s0
type. You should consider using this method when processing bound
column data as it provides some support for the \s-1TYPE\s0 bind_col
attribute which is rarely used in drivers.
.PP
.Vb 1
\&  int sql_type_cast_svpv(pTHX_ SV *sv, int sql_type, U32 flags, void *v)
.Ve
.PP
\&\f(CW\*(C`sv\*(C'\fR is what you would like cast, \f(CW\*(C`sql_type\*(C'\fR is one of the \s-1DBI\s0 defined
\&\s-1SQL\s0 types (e.g., \f(CW\*(C`SQL_INTEGER\*(C'\fR) and \f(CW\*(C`flags\*(C'\fR is a bitmask as follows:
.IP "DBIstcf_STRICT" 4
.IX Item "DBIstcf_STRICT"
If set this indicates you want an error state returned if the cast
cannot be performed.
.IP "DBIstcf_DISCARD_STRING" 4
.IX Item "DBIstcf_DISCARD_STRING"
If set and the pv portion of the \f(CW\*(C`sv\*(C'\fR is cast then this will cause
sv's pv to be freed up.
.PP
sql_type_cast_svpv returns the following states:
.PP
.Vb 5
\& \-2 sql_type is not handled \- sv not changed
\& \-1 sv is undef, sv not changed
\&  0 sv could not be cast cleanly and DBIstcf_STRICT was specified
\&  1 sv could not be case cleanly and DBIstcf_STRICT was not specified
\&  2 sv was cast ok
.Ve
.PP
The current implementation of sql_type_cast_svpv supports
\&\f(CW\*(C`SQL_INTEGER\*(C'\fR, \f(CW\*(C`SQL_DOUBLE\*(C'\fR and \f(CW\*(C`SQL_NUMERIC\*(C'\fR. \f(CW\*(C`SQL_INTEGER\*(C'\fR uses
sv_2iv and hence may set \s-1IV, UV\s0 or \s-1NV\s0 depending on the
number. \f(CW\*(C`SQL_DOUBLE\*(C'\fR uses sv_2nv so may set \s-1NV\s0 and \f(CW\*(C`SQL_NUMERIC\*(C'\fR
will set \s-1IV\s0 or \s-1UV\s0 or \s-1NV.\s0
.PP
DBIstcf_STRICT should be implemented as the StrictlyTyped attribute
and DBIstcf_DISCARD_STRING implemented as the DiscardString attribute
to the bind_col method and both default to off.
.PP
See DBD::Oracle for an example of how this is used.
.SH "SUBCLASSING DBI DRIVERS"
.IX Header "SUBCLASSING DBI DRIVERS"
This is definitely an open subject. It can be done, as demonstrated by
the \fBDBD::File\fR driver, but it is not as simple as one might think.
.PP
(Note that this topic is different from subclassing the \fB\s-1DBI\s0\fR. For an
example of that, see the \fIt/subclass.t\fR file supplied with the \fB\s-1DBI\s0\fR.)
.PP
The main problem is that the \fIdbh\fR's and \fIsth\fR's that your \f(CW\*(C`connect()\*(C'\fR and
\&\f(CW\*(C`prepare()\*(C'\fR methods return are not instances of your \fBDBD::Driver::db\fR
or \fBDBD::Driver::st\fR packages, they are not even derived from it.
Instead they are instances of the \fBDBI::db\fR or \fBDBI::st\fR classes or
a derived subclass. Thus, if you write a method \f(CW\*(C`mymethod()\*(C'\fR and do a
.PP
.Vb 1
\&  $dbh\->mymethod()
.Ve
.PP
then the autoloader will search for that method in the package \fBDBI::db\fR.
Of course you can instead to a
.PP
.Vb 1
\&  $dbh\->func(\*(Aqmymethod\*(Aq)
.Ve
.PP
and that will indeed work, even if \f(CW\*(C`mymethod()\*(C'\fR is inherited, but not
without additional work. Setting \fI\f(CI@ISA\fI\fR is not sufficient.
.SS "Overwriting methods"
.IX Subsection "Overwriting methods"
The first problem is, that the \f(CW\*(C`connect()\*(C'\fR method has no idea of
subclasses. For example, you cannot implement base class and subclass
in the same file: The \f(CW\*(C`install_driver()\*(C'\fR method wants to do a
.PP
.Vb 1
\&  require DBD::Driver;
.Ve
.PP
In particular, your subclass \fBhas\fR to be a separate driver, from
the view of \fB\s-1DBI\s0\fR, and you cannot share driver handles.
.PP
Of course that's not much of a problem. You should even be able
to inherit the base classes \f(CW\*(C`connect()\*(C'\fR method. But you cannot
simply overwrite the method, unless you do something like this,
quoted from \fB\s-1DBD::CSV\s0\fR:
.PP
.Vb 2
\&  sub connect ($$;$$$) {
\&      my ($drh, $dbname, $user, $auth, $attr) = @_;
\&
\&      my $this = $drh\->DBD::File::dr::connect($dbname, $user, $auth, $attr);
\&      if (!exists($this\->{csv_tables})) {
\&          $this\->{csv_tables} = {};
\&      }
\&
\&      $this;
\&  }
.Ve
.PP
Note that we cannot do a
.PP
.Vb 1
\&  $drh\->SUPER::connect($dbname, $user, $auth, $attr);
.Ve
.PP
as we would usually do in a an \s-1OO\s0 environment, because \fI\f(CI$drh\fI\fR is an instance
of \fBDBI::dr\fR. And note, that the \f(CW\*(C`connect()\*(C'\fR method of \fBDBD::File\fR is
able to handle subclass attributes. See the description of Pure Perl
drivers above.
.PP
It is essential that you always call superclass method in the above
manner. However, that should do.
.SS "Attribute handling"
.IX Subsection "Attribute handling"
Fortunately the \fB\s-1DBI\s0\fR specifications allow a simple, but still
performant way of handling attributes. The idea is based on the
convention that any driver uses a prefix \fIdriver_\fR for its private
methods. Thus it's always clear whether to pass attributes to the super
class or not. For example, consider this \f(CW\*(C`STORE()\*(C'\fR method from the
\&\fB\s-1DBD::CSV\s0\fR class:
.PP
.Vb 8
\&  sub STORE {
\&      my ($dbh, $attr, $val) = @_;
\&      if ($attr !~ /^driver_/) {
\&          return $dbh\->DBD::File::db::STORE($attr, $val);
\&      }
\&      if ($attr eq \*(Aqdriver_foo\*(Aq) {
\&      ...
\&  }
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan Leffler <jleffler@us.ibm.com> (previously <jleffler@informix.com>),
Jochen Wiedmann <joe@ispsoft.de>,
Steffen Goeldner <sgoeldner@cpan.org>,
and Tim Bunce <dbi\-users@perl.org>.
                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::DBD5.16.3pm                             0100644 0001750 0001750 00000430723 12566241600 022712  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::DBD 3"
.TH DBI::DBD 3 "2012-02-04" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::DBD \- Perl DBI Database Driver Writer's Guide
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  perldoc DBI::DBD
.Ve
.SS "Version and volatility"
.IX Subsection "Version and volatility"
This document is \fIstill\fR a minimal draft which is in need of further work.
.PP
The changes will occur both because the \fB\s-1DBI\s0\fR specification is changing
and hence the requirements on \fB\s-1DBD\s0\fR drivers change, and because feedback
from people reading this document will suggest improvements to it.
.PP
Please read the \fB\s-1DBI\s0\fR documentation first and fully, including the \fB\s-1DBI\s0\fR \s-1FAQ\s0.
Then reread the \fB\s-1DBI\s0\fR specification again as you're reading this. It'll help.
.PP
This document is a patchwork of contributions from various authors.
More contributions (preferably as patches) are very welcome.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document is primarily intended to help people writing new
database drivers for the Perl Database Interface (Perl \s-1DBI\s0).
It may also help others interested in discovering why the internals of
a \fB\s-1DBD\s0\fR driver are written the way they are.
.PP
This is a guide.  Few (if any) of the statements in it are completely
authoritative under all possible circumstances.  This means you will
need to use judgement in applying the guidelines in this document.
If in \fIany\fR doubt at all, please do contact the \fIdbi-dev\fR mailing list
(details given below) where Tim Bunce and other driver authors can help.
.SH "CREATING A NEW DRIVER"
.IX Header "CREATING A NEW DRIVER"
The first rule for creating a new database driver for the Perl \s-1DBI\s0 is
very simple: \fB\s-1DON\s0'T!\fR
.PP
There is usually a driver already available for the database you want
to use, almost regardless of which database you choose. Very often, the
database will provide an \s-1ODBC\s0 driver interface, so you can often use
\&\fB\s-1DBD::ODBC\s0\fR to access the database. This is typically less convenient
on a Unix box than on a Microsoft Windows box, but there are numerous
options for \s-1ODBC\s0 driver managers on Unix too, and very often the \s-1ODBC\s0
driver is provided by the database supplier.
.PP
Before deciding that you need to write a driver, do your homework to
ensure that you are not wasting your energies.
.PP
[As of December 2002, the consensus is that if you need an \s-1ODBC\s0 driver
manager on Unix, then the unixODBC driver (available from
<http://www.unixodbc.org/>) is the way to go.]
.PP
The second rule for creating a new database driver for the Perl \s-1DBI\s0 is
also very simple: \fBDon't \*(-- get someone else to do it for you!\fR
.PP
Nevertheless, there are occasions when it is necessary to write a new
driver, often to use a proprietary language or \s-1API\s0 to access the
database more swiftly, or more comprehensively, than an \s-1ODBC\s0 driver can.
Then you should read this document very carefully, but with a suitably
sceptical eye.
.PP
If there is something in here that does not make any sense, question it.
You might be right that the information is bogus, but don't come to that
conclusion too quickly.
.SS "URLs and mailing lists"
.IX Subsection "URLs and mailing lists"
The primary web-site for locating \fB\s-1DBI\s0\fR software and information is
.PP
.Vb 1
\&  http://dbi.perl.org/
.Ve
.PP
There are two main and one auxiliary mailing lists for people working
with \fB\s-1DBI\s0\fR.  The primary lists are \fIdbi\-users@perl.org\fR for general users
of \fB\s-1DBI\s0\fR and \fB\s-1DBD\s0\fR drivers, and \fIdbi\-dev@perl.org\fR mainly for \fB\s-1DBD\s0\fR driver
writers (don't join the \fIdbi-dev\fR list unless you have a good reason).
The auxiliary list is \fIdbi\-announce@perl.org\fR for announcing new
releases of \fB\s-1DBI\s0\fR or \fB\s-1DBD\s0\fR drivers.
.PP
You can join these lists by accessing the web-site <http://dbi.perl.org/>.
The lists are closed so you cannot send email to any of the lists
unless you join the list first.
.PP
You should also consider monitoring the \fIcomp.lang.perl.*\fR newsgroups,
especially \fIcomp.lang.perl.modules\fR.
.SS "The Cheetah book"
.IX Subsection "The Cheetah book"
The definitive book on Perl \s-1DBI\s0 is the Cheetah book, so called because
of the picture on the cover. Its proper title is '\fIProgramming the
Perl \s-1DBI:\s0 Database programming with Perl\fR' by Alligator Descartes
and Tim Bunce, published by O'Reilly Associates, February 2000, \s-1ISBN\s0
1\-56592\-699\-4. Buy it now if you have not already done so, and read it.
.SS "Locating drivers"
.IX Subsection "Locating drivers"
Before writing a new driver, it is in your interests to find out
whether there already is a driver for your database.  If there is such
a driver, it would be much easier to make use of it than to write your
own!
.PP
The primary web-site for locating Perl software is
<http://search.cpan.org/>.  You should look under the various
modules listings for the software you are after. For example:
.PP
.Vb 1
\&  http://search.cpan.org/modlist/Database_Interfaces
.Ve
.PP
Follow the \fB\s-1DBD::\s0\fR and \fBDBIx::\fR links at the top to see those subsets.
.PP
See the \fB\s-1DBI\s0\fR docs for information on \fB\s-1DBI\s0\fR web sites and mailing lists.
.SS "Registering a new driver"
.IX Subsection "Registering a new driver"
Before going through any official registration process, you will need
to establish that there is no driver already in the works. You'll do
that by asking the \fB\s-1DBI\s0\fR mailing lists whether there is such a driver
available, or whether anybody is working on one.
.PP
When you get the go ahead, you will need to establish the name of the
driver and a prefix for the driver. Typically, the name is based on the
name of the database software it uses, and the prefix is a contraction
of that. Hence, \fBDBD::Oracle\fR has the name \fIOracle\fR and the prefix
\&'\fIora_\fR'. The prefix must be lowercase and contain no underscores other
than the one at the end.
.PP
This information will be recorded in the \fB\s-1DBI\s0\fR module. Apart from
documentation purposes, registration is a prerequisite for
installing private methods.
.PP
If you are writing a driver which will not be distributed on \s-1CPAN\s0, then
you should choose a prefix beginning with '\fIx_\fR', to avoid potential
prefix collisions with drivers registered in the future. Thus, if you
wrote a non-CPAN distributed driver called \fBDBD::CustomDB\fR, the prefix
might be '\fIx_cdb_\fR'.
.PP
This document assumes you are writing a driver called \fBDBD::Driver\fR, and
that the prefix '\fIdrv_\fR' is assigned to the driver.
.SS "Two styles of database driver"
.IX Subsection "Two styles of database driver"
There are two distinct styles of database driver that can be written to
work with the Perl \s-1DBI\s0.
.PP
Your driver can be written in pure Perl, requiring no C compiler.
When feasible, this is the best solution, but most databases are not
written in such a way that this can be done. Some examples of pure
Perl drivers are \fBDBD::File\fR and \fB\s-1DBD::CSV\s0\fR.
.PP
Alternatively, and most commonly, your driver will need to use some C
code to gain access to the database. This will be classified as a C/XS
driver.
.SS "What code will you write?"
.IX Subsection "What code will you write?"
There are a number of files that need to be written for either a pure
Perl driver or a C/XS driver. There are no extra files needed only by
a pure Perl driver, but there are several extra files needed only by a
C/XS driver.
.PP
\fIFiles common to pure Perl and C/XS drivers\fR
.IX Subsection "Files common to pure Perl and C/XS drivers"
.PP
Assuming that your driver is called \fBDBD::Driver\fR, these files are:
.IP "\(bu" 4
\&\fIMakefile.PL\fR
.IP "\(bu" 4
\&\fI\s-1META\s0.yml\fR
.IP "\(bu" 4
\&\fI\s-1README\s0\fR
.IP "\(bu" 4
\&\fI\s-1MANIFEST\s0\fR
.IP "\(bu" 4
\&\fIDriver.pm\fR
.IP "\(bu" 4
\&\fIlib/Bundle/DBD/Driver.pm\fR
.IP "\(bu" 4
\&\fIlib/DBD/Driver/Summary.pm\fR
.IP "\(bu" 4
\&\fIt/*.t\fR
.PP
The first four files are mandatory. \fIMakefile.PL\fR is used to control
how the driver is built and installed. The \fI\s-1README\s0\fR file tells people
who download the file about how to build the module and any prerequisite
software that must be installed. The \fI\s-1MANIFEST\s0\fR file is used by the
standard Perl module distribution mechanism. It lists all the source
files that need to be distributed with your module. \fIDriver.pm\fR is what
is loaded by the \fB\s-1DBI\s0\fR code; it contains the methods peculiar to your
driver.
.PP
Although the \fI\s-1META\s0.yml\fR file is not \fBrequired\fR you are advised to
create one. Of particular importance are the \fIbuild_requires\fR and
\&\fIconfigure_requires\fR attributes which newer \s-1CPAN\s0 modules understand.
You use these to tell the \s-1CPAN\s0 module (and \s-1CPANPLUS\s0) that your build
and configure mechanisms require \s-1DBI\s0. The best reference for \s-1META\s0.yml
(at the time of writing) is
http://module\-build.sourceforge.net/META\-spec\-v1.4.html <http://module-build.sourceforge.net/META-spec-v1.4.html>. You can find
a reasonable example of a \fI\s-1META\s0.yml\fR in \s-1DBD::ODBC\s0.
.PP
The \fIlib/Bundle/DBD/Driver.pm\fR file allows you to specify other Perl
modules on which yours depends in a format that allows someone to type a
simple command and ensure that all the pre-requisites are in place as
well as building your driver.
.PP
The \fIlib/DBD/Driver/Summary.pm\fR file contains (an updated version of) the
information that was included \- or that would have been included \- in
the appendices of the Cheetah book as a summary of the abilities of your
driver and the associated database.
.PP
The files in the \fIt\fR subdirectory are unit tests for your driver.
You should write your tests as stringently as possible, while taking
into account the diversity of installations that you can encounter:
.IP "\(bu" 4
Your tests should not casually modify operational databases.
.IP "\(bu" 4
You should never damage existing tables in a database.
.IP "\(bu" 4
You should code your tests to use a constrained name space within the
database. For example, the tables (and all other named objects) that are
created could all begin with '\fIdbd_drv_\fR'.
.IP "\(bu" 4
At the end of a test run, there should be no testing objects left behind
in the database.
.IP "\(bu" 4
If you create any databases, you should remove them.
.IP "\(bu" 4
If your database supports temporary tables that are automatically
removed at the end of a session, then exploit them as often as possible.
.IP "\(bu" 4
Try to make your tests independent of each other. If you have a
test \fIt/t11dowhat.t\fR that depends upon the successful running
of \fIt/t10thingamy.t\fR, people cannot run the single test case
\&\fIt/t11dowhat.t\fR. Further, running \fIt/t11dowhat.t\fR twice in a row is
likely to fail (at least, if \fIt/t11dowhat.t\fR modifies the database at
all) because the database at the start of the second run is not what you
saw at the start of the first run.
.IP "\(bu" 4
Document in your \fI\s-1README\s0\fR file what you do, and what privileges people
need to do it.
.IP "\(bu" 4
You can, and probably should, sequence your tests by including a test
number before an abbreviated version of the test name; the tests are run
in the order in which the names are expanded by shell-style globbing.
.IP "\(bu" 4
It is in your interests to ensure that your tests work as widely
as possible.
.PP
Many drivers also install sub-modules \fBDBD::Driver::SubModule\fR
for any of a variety of different reasons, such as to support
the metadata methods (see the discussion of \*(L"\s-1METADATA\s0 \s-1METHODS\s0\*(R"
below). Such sub-modules are conventionally stored in the directory
\&\fIlib/DBD/Driver\fR. The module itself would usually be in a file
\&\fISubModule.pm\fR. All such sub-modules should themselves be version
stamped (see the discussions far below).
.PP
\fIExtra files needed by C/XS drivers\fR
.IX Subsection "Extra files needed by C/XS drivers"
.PP
The software for a C/XS driver will typically contain at least four
extra files that are not relevant to a pure Perl driver.
.IP "\(bu" 4
\&\fIDriver.xs\fR
.IP "\(bu" 4
\&\fIDriver.h\fR
.IP "\(bu" 4
\&\fIdbdimp.h\fR
.IP "\(bu" 4
\&\fIdbdimp.c\fR
.PP
The \fIDriver.xs\fR file is used to generate C code that Perl can call to gain
access to the C functions you write that will, in turn, call down onto
your database software.
.PP
The \fIDriver.h\fR header is a stylized header that ensures you can access the
necessary Perl and \fB\s-1DBI\s0\fR macros, types, and function declarations.
.PP
The \fIdbdimp.h\fR is used to specify which functions have been implemented by
your driver.
.PP
The \fIdbdimp.c\fR file is where you write the C code that does the real work
of translating between Perl-ish data types and what the database expects
to use and return.
.PP
There are some (mainly small, but very important) differences between
the contents of \fIMakefile.PL\fR and \fIDriver.pm\fR for pure Perl and C/XS
drivers, so those files are described both in the section on creating a
pure Perl driver and in the section on creating a C/XS driver.
.PP
Obviously, you can add extra source code files to the list.
.SS "Requirements on a driver and driver writer"
.IX Subsection "Requirements on a driver and driver writer"
To be remotely useful, your driver must be implemented in a format that
allows it to be distributed via \s-1CPAN\s0, the Comprehensive Perl Archive
Network (<http://www.cpan.org/> and <http://search.cpan.org>).
Of course, it is easier if you do not have to meet this criterion, but
you will not be able to ask for much help if you do not do so, and
no-one is likely to want to install your module if they have to learn a
new installation mechanism.
.SH "CREATING A PURE PERL DRIVER"
.IX Header "CREATING A PURE PERL DRIVER"
Writing a pure Perl driver is surprisingly simple. However, there are
some problems you should be aware of. The best option is of course
picking up an existing driver and carefully modifying one method
after the other.
.PP
Also look carefully at \fBDBD::AnyData\fR and \fBDBD::Template\fR.
.PP
As an example we take a look at the \fBDBD::File\fR driver, a driver for
accessing plain files as tables, which is part of the \fB\s-1DBD::CSV\s0\fR package.
.PP
The minimal set of files we have to implement are \fIMakefile.PL\fR,
\&\fI\s-1README\s0\fR, \fI\s-1MANIFEST\s0\fR and \fIDriver.pm\fR.
.SS "Pure Perl version of Makefile.PL"
.IX Subsection "Pure Perl version of Makefile.PL"
You typically start with writing \fIMakefile.PL\fR, a Makefile
generator. The contents of this file are described in detail in
the ExtUtils::MakeMaker man pages. It is definitely a good idea
if you start reading them. At least you should know about the
variables \fI\s-1CONFIGURE\s0\fR, \fI\s-1DEFINED\s0\fR, \fI\s-1PM\s0\fR, \fI\s-1DIR\s0\fR, \fI\s-1EXE_FILES\s0\fR,
\&\fI\s-1INC\s0\fR, \fI\s-1LIBS\s0\fR, \fI\s-1LINKTYPE\s0\fR, \fI\s-1NAME\s0\fR, \fI\s-1OPTIMIZE\s0\fR, \fI\s-1PL_FILES\s0\fR,
\&\fI\s-1VERSION\s0\fR, \fI\s-1VERSION_FROM\s0\fR, \fIclean\fR, \fIdepend\fR, \fIrealclean\fR from
the ExtUtils::MakeMaker man page: these are used in almost any
\&\fIMakefile.PL\fR.
.PP
Additionally read the section on \fIOverriding MakeMaker Methods\fR and the
descriptions of the \fIdistcheck\fR, \fIdisttest\fR and \fIdist\fR targets: They
will definitely be useful for you.
.PP
Of special importance for \fB\s-1DBI\s0\fR drivers is the \fIpostamble\fR method from
the ExtUtils::MM_Unix man page.
.PP
For Emacs users, I recommend the \fIlibscan\fR method, which removes
Emacs backup files (file names which end with a tilde '~') from lists of
files.
.PP
Now an example, I use the word \f(CW\*(C`Driver\*(C'\fR wherever you should insert
your driver's name:
.PP
.Vb 1
\&  # \-*\- perl \-*\-
\&
\&  use ExtUtils::MakeMaker;
\&
\&  WriteMakefile(
\&      dbd_edit_mm_attribs( {
\&          \*(AqNAME\*(Aq         => \*(AqDBD::Driver\*(Aq,
\&          \*(AqVERSION_FROM\*(Aq => \*(AqDriver.pm\*(Aq,
\&          \*(AqINC\*(Aq          => \*(Aq\*(Aq,
\&          \*(Aqdist\*(Aq         => { \*(AqSUFFIX\*(Aq   => \*(Aq.gz\*(Aq,
\&                              \*(AqCOMPRESS\*(Aq => \*(Aqgzip \-9f\*(Aq },
\&          \*(Aqrealclean\*(Aq    => { FILES => \*(Aq*.xsi\*(Aq },
\&          \*(AqPREREQ_PM\*(Aq    => \*(Aq1.03\*(Aq,
\&          \*(AqCONFIGURE\*(Aq    => sub {
\&              eval {require DBI::DBD;};
\&              if ($@) {
\&                  warn $@;
\&                  exit 0;
\&              }
\&              my $dbi_arch_dir = dbd_dbi_arch_dir();
\&              if (exists($opts{INC})) {
\&                  return {INC => "$opts{INC} \-I$dbi_arch_dir"};
\&              } else {
\&                  return {INC => "\-I$dbi_arch_dir"};
\&              }
\&          }
\&      },
\&      { create_pp_tests => 1})
\&  );
\&
\&  package MY;
\&  sub postamble { return main::dbd_postamble(@_); }
\&  sub libscan {
\&      my ($self, $path) = @_;
\&      ($path =~ m/\e~$/) ? undef : $path;
\&  }
.Ve
.PP
Note the calls to \f(CW\*(C`dbd_edit_mm_attribs()\*(C'\fR and \f(CW\*(C`dbd_postamble()\*(C'\fR.
.PP
The second hash reference in the call to \f(CW\*(C`dbd_edit_mm_attribs()\*(C'\fR
(containing \f(CW\*(C`create_pp_tests()\*(C'\fR) is optional; you should not use it
unless your driver is a pure Perl driver (that is, it does not use C and
\&\s-1XS\s0 code). Therefore, the call to \f(CW\*(C`dbd_edit_mm_attribs()\*(C'\fR is not
relevant for C/XS drivers and may be omitted; simply use the (single)
hash reference containing \s-1NAME\s0 etc as the only argument to \f(CW\*(C`WriteMakefile()\*(C'\fR.
.PP
Note that the \f(CW\*(C`dbd_edit_mm_attribs()\*(C'\fR code will fail if you do not have a
\&\fIt\fR sub-directory containing at least one test case.
.PP
\&\fI\s-1PREREQ_PM\s0\fR tells MakeMaker that \s-1DBI\s0 (version 1.03 in this case) is
required for this module. This will issue a warning that \s-1DBI\s0 1.03 is
missing if someone attempts to install your \s-1DBD\s0 without \s-1DBI\s0 1.03. See
\&\fI\s-1CONFIGURE\s0\fR below for why this does not work reliably in stopping cpan
testers failing your module if \s-1DBI\s0 is not installed.
.PP
\&\fI\s-1CONFIGURE\s0\fR is a subroutine called by MakeMaker during
\&\f(CW\*(C`WriteMakefile\*(C'\fR.  By putting the \f(CW\*(C`require DBI::DBD\*(C'\fR in this section
we can attempt to load \s-1DBI::DBD\s0 but if it is missing we exit with
success. As we exit successfully without creating a Makefile when
\&\s-1DBI::DBD\s0 is missing cpan testers will not report a failure. This may
seem at odds with \fI\s-1PREREQ_PM\s0\fR but \fI\s-1PREREQ_PM\s0\fR does not cause
\&\f(CW\*(C`WriteMakefile\*(C'\fR to fail (unless you also specify \s-1PREREQ_FATAL\s0 which
is strongly discouraged by MakeMaker) so \f(CW\*(C`WriteMakefile\*(C'\fR would
continue to call \f(CW\*(C`dbd_dbi_arch_dir\*(C'\fR and fail.
.PP
All drivers must use \f(CW\*(C`dbd_postamble()\*(C'\fR or risk running into problems.
.PP
Note the specification of \fI\s-1VERSION_FROM\s0\fR; the named file
(\fIDriver.pm\fR) will be scanned for the first line that looks like an
assignment to \fI\f(CI$VERSION\fI\fR, and the subsequent text will be used to
determine the version number.  Note the commentary in
ExtUtils::MakeMaker on the subject of correctly formatted version
numbers.
.PP
If your driver depends upon external software (it usually will), you
will need to add code to ensure that your environment is workable
before the call to \f(CW\*(C`WriteMakefile()\*(C'\fR. If you need to check for the
existence of an external library and perhaps modify \fI\s-1INC\s0\fR to include
the paths to where the external library header files are located and
you cannot find the library or header files make sure you output a
message saying they cannot be found but \f(CW\*(C`exit 0\*(C'\fR (success) \fBbefore\fR
calling \f(CW\*(C`WriteMakefile\*(C'\fR or \s-1CPAN\s0 testers will fail your module if the
external library is not found.
.PP
A full-fledged \fIMakefile.PL\fR can be quite large (for example, the
files for \fBDBD::Oracle\fR and \fBDBD::Informix\fR are both over 1000 lines
long, and the Informix one uses \- and creates \- auxiliary modules
too).
.PP
See also ExtUtils::MakeMaker and ExtUtils::MM_Unix. Consider using
CPAN::MakeMaker in place of \fIExtUtils::MakeMaker\fR.
.SS "\s-1README\s0"
.IX Subsection "README"
The \s-1README\s0 file should describe what the driver is for, the
pre-requisites for the build process, the actual build process, how to
report errors, and who to report them to.
.PP
Users will find ways of breaking the driver build and test process
which you would never even have dreamed to be possible in your worst
nightmares. Therefore, you need to write this document defensively,
precisely and concisely.
.PP
As always, use the \fI\s-1README\s0\fR from one of the established drivers as a basis
for your own; the version in \fBDBD::Informix\fR is worth a look as it has
been quite successful in heading off problems.
.IP "\(bu" 4
Note that users will have versions of Perl and \fB\s-1DBI\s0\fR that are both older
and newer than you expected, but this will seldom cause much trouble.
When it does, it will be because you are using features of \fB\s-1DBI\s0\fR that are
not supported in the version they are using.
.IP "\(bu" 4
Note that users will have versions of the database software that are
both older and newer than you expected. You will save yourself time in
the long run if you can identify the range of versions which have been
tested and warn about versions which are not known to be \s-1OK\s0.
.IP "\(bu" 4
Note that many people trying to install your driver will not be experts
in the database software.
.IP "\(bu" 4
Note that many people trying to install your driver will not be experts
in C or Perl.
.SS "\s-1MANIFEST\s0"
.IX Subsection "MANIFEST"
The \fI\s-1MANIFEST\s0\fR will be used by the Makefile's dist target to build the
distribution tar file that is uploaded to \s-1CPAN\s0. It should list every
file that you want to include in your distribution, one per line.
.SS "lib/Bundle/DBD/Driver.pm"
.IX Subsection "lib/Bundle/DBD/Driver.pm"
The \s-1CPAN\s0 module provides an extremely powerful bundle mechanism that
allows you to specify pre-requisites for your driver.
.PP
The primary pre-requisite is \fBBundle::DBI\fR; you may want or need to add
some more. With the bundle set up correctly, the user can type:
.PP
.Vb 1
\&        perl \-MCPAN \-e \*(Aqinstall Bundle::DBD::Driver\*(Aq
.Ve
.PP
and Perl will download, compile, test and install all the Perl modules
needed to build your driver.
.PP
The prerequisite modules are listed in the \f(CW\*(C`CONTENTS\*(C'\fR section, with the
official name of the module followed by a dash and an informal name or
description.
.IP "\(bu" 4
Listing \fBBundle::DBI\fR as the main pre-requisite simplifies life.
.IP "\(bu" 4
Don't forget to list your driver.
.IP "\(bu" 4
Note that unless the \s-1DBMS\s0 is itself a Perl module, you cannot list it as
a pre-requisite in this file.
.IP "\(bu" 4
You should keep the version of the bundle the same as the version of
your driver.
.IP "\(bu" 4
You should add configuration management, copyright, and licencing
information at the top.
.PP
A suitable skeleton for this file is shown below.
.PP
.Vb 1
\&  package Bundle::DBD::Driver;
\&
\&  $VERSION = \*(Aq0.01\*(Aq;
\&
\&  1;
\&
\&  _\|_END_\|_
\&
\&  =head1 NAME
\&
\&  Bundle::DBD::Driver \- A bundle to install all DBD::Driver related modules
\&
\&  =head1 SYNOPSIS
\&
\&  C<perl \-MCPAN \-e \*(Aqinstall Bundle::DBD::Driver\*(Aq>
\&
\&  =head1 CONTENTS
\&
\&  Bundle::DBI  \- Bundle for DBI by TIMB (Tim Bunce)
\&
\&  DBD::Driver  \- DBD::Driver by YOU (Your Name)
\&
\&  =head1 DESCRIPTION
\&
\&  This bundle includes all the modules used by the Perl Database
\&  Interface (DBI) driver for Driver (DBD::Driver), assuming the
\&  use of DBI version 1.13 or later, created by Tim Bunce.
\&
\&  If you\*(Aqve not previously used the CPAN module to install any
\&  bundles, you will be interrogated during its setup phase.
\&  But when you\*(Aqve done it once, it remembers what you told it.
\&  You could start by running:
\&
\&    C<perl \-MCPAN \-e \*(Aqinstall Bundle::CPAN\*(Aq>
\&
\&  =head1 SEE ALSO
\&
\&  Bundle::DBI
\&
\&  =head1 AUTHOR
\&
\&  Your Name E<lt>F<you@yourdomain.com>E<gt>
\&
\&  =head1 THANKS
\&
\&  This bundle was created by ripping off Bundle::libnet created by
\&  Graham Barr E<lt>F<gbarr@ti.com>E<gt>, and radically simplified
\&  with some information from Jochen Wiedmann E<lt>F<joe@ispsoft.de>E<gt>.
\&  The template was then included in the DBI::DBD documentation by
\&  Jonathan Leffler E<lt>F<jleffler@informix.com>E<gt>.
\&
\&  =cut
.Ve
.SS "lib/DBD/Driver/Summary.pm"
.IX Subsection "lib/DBD/Driver/Summary.pm"
There is no substitute for taking the summary file from a driver that
was documented in the Perl book (such as \fBDBD::Oracle\fR or \fBDBD::Informix\fR or
\&\fB\s-1DBD::ODBC\s0\fR, to name but three), and adapting it to describe the
facilities available via \fBDBD::Driver\fR when accessing the Driver database.
.SS "Pure Perl version of Driver.pm"
.IX Subsection "Pure Perl version of Driver.pm"
The \fIDriver.pm\fR file defines the Perl module \fBDBD::Driver\fR for your driver.
It will define a package \fBDBD::Driver\fR along with some version information,
some variable definitions, and a function \f(CW\*(C`driver()\*(C'\fR which will have a more
or less standard structure.
.PP
It will also define three sub-packages of \fBDBD::Driver\fR:
.IP "DBD::Driver::dr" 4
.IX Item "DBD::Driver::dr"
with methods \f(CW\*(C`connect()\*(C'\fR, \f(CW\*(C`data_sources()\*(C'\fR and \f(CW\*(C`disconnect_all()\*(C'\fR;
.IP "DBD::Driver::db" 4
.IX Item "DBD::Driver::db"
with methods such as \f(CW\*(C`prepare()\*(C'\fR;
.IP "DBD::Driver::st" 4
.IX Item "DBD::Driver::st"
with methods such as \f(CW\*(C`execute()\*(C'\fR and \f(CW\*(C`fetch()\*(C'\fR.
.PP
The \fIDriver.pm\fR file will also contain the documentation specific to
\&\fBDBD::Driver\fR in the format used by perldoc.
.PP
In a pure Perl driver, the \fIDriver.pm\fR file is the core of the
implementation. You will need to provide all the key methods needed by \fB\s-1DBI\s0\fR.
.PP
Now let's take a closer look at an excerpt of \fIFile.pm\fR as an example.
We ignore things that are common to any module (even non-DBI modules)
or really specific to the \fBDBD::File\fR package.
.PP
\fIThe DBD::Driver package\fR
.IX Subsection "The DBD::Driver package"
.PP
The header
.IX Subsection "The header"
.PP
.Vb 1
\&  package DBD::File;
\&
\&  use strict;
\&  use vars qw($VERSION $drh);
\&
\&  $VERSION = "1.23.00"  # Version number of DBD::File
.Ve
.PP
This is where the version number of your driver is specified, and is
where \fIMakefile.PL\fR looks for this information. Please ensure that any
other modules added with your driver are also version stamped so that
\&\s-1CPAN\s0 does not get confused.
.PP
It is recommended that you use a two-part (1.23) or three-part (1.23.45)
version number. Also consider the \s-1CPAN\s0 system, which gets confused and
considers version 1.10 to precede version 1.9, so that using a raw \s-1CVS\s0,
\&\s-1RCS\s0 or \s-1SCCS\s0 version number is probably not appropriate (despite being
very common).
.PP
For Subversion you could use:
.PP
.Vb 1
\&  $VERSION = sprintf("12.%06d", q$Revision: 12345 $ =~ /(\ed+)/o);
.Ve
.PP
(use lots of leading zeros on the second portion so if you move the code to a
shared repository like svn.perl.org the much larger revision numbers won't
cause a problem, at least not for a few years).  For \s-1RCS\s0 or \s-1CVS\s0 you can use:
.PP
.Vb 1
\&  $VERSION = sprintf "%d.%02d", \*(Aq$Revision: 11.21 $ \*(Aq =~ /(\ed+)\e.(\ed+)/;
.Ve
.PP
which pads out the fractional part with leading zeros so all is well
(so long as you don't go past x.99)
.PP
.Vb 1
\&  $drh = undef;         # holds driver handle once initialized
.Ve
.PP
This is where the driver handle will be stored, once created.
Note that you may assume there is only one handle for your driver.
.PP
The driver constructor
.IX Subsection "The driver constructor"
.PP
The \f(CW\*(C`driver()\*(C'\fR method is the driver handle constructor. Note that
the \f(CW\*(C`driver()\*(C'\fR method is in the \fBDBD::Driver\fR package, not in
one of the sub-packages \fBDBD::Driver::dr\fR, \fBDBD::Driver::db\fR, or
\&\fBDBD::Driver::db\fR.
.PP
.Vb 4
\&  sub driver
\&  {
\&      return $drh if $drh;      # already created \- return same one
\&      my ($class, $attr) = @_;
\&
\&      $class .= "::dr";
\&
\&      DBD::Driver::db\->install_method(\*(Aqdrv_example_dbh_method\*(Aq);
\&      DBD::Driver::st\->install_method(\*(Aqdrv_example_sth_method\*(Aq);
\&
\&      # not a \*(Aqmy\*(Aq since we use it above to prevent multiple drivers
\&      $drh = DBI::_new_drh($class, {
\&              \*(AqName\*(Aq        => \*(AqFile\*(Aq,
\&              \*(AqVersion\*(Aq     => $VERSION,
\&              \*(AqAttribution\*(Aq => \*(AqDBD::File by Jochen Wiedmann\*(Aq,
\&          })
\&          or return undef;
\&
\&      return $drh;
\&  }
.Ve
.PP
This is a reasonable example of how \fB\s-1DBI\s0\fR implements its handles. There
are three kinds: \fBdriver handles\fR (typically stored in \fI\f(CI$drh\fI\fR; from
now on called \fIdrh\fR or \fI\f(CI$drh\fI\fR), \fBdatabase handles\fR (from now on
called \fIdbh\fR or \fI\f(CI$dbh\fI\fR) and \fBstatement handles\fR (from now on called
\&\fIsth\fR or \fI\f(CI$sth\fI\fR).
.PP
The prototype of \f(CW\*(C`DBI::_new_drh()\*(C'\fR is
.PP
.Vb 1
\&  $drh = DBI::_new_drh($class, $public_attrs, $private_attrs);
.Ve
.PP
with the following arguments:
.ie n .IP "\fI\fI$class\fI\fR" 4
.el .IP "\fI\f(CI$class\fI\fR" 4
.IX Item "$class"
is typically the class for your driver, (for example, \*(L"DBD::File::dr\*(R"),
passed as the first argument to the \f(CW\*(C`driver()\*(C'\fR method.
.ie n .IP "\fI\fI$public_attrs\fI\fR" 4
.el .IP "\fI\f(CI$public_attrs\fI\fR" 4
.IX Item "$public_attrs"
is a hash ref to attributes like \fIName\fR, \fIVersion\fR, and \fIAttribution\fR.
These are processed and used by \fB\s-1DBI\s0\fR. You had better not make any
assumptions about them nor should you add private attributes here.
.ie n .IP "\fI\fI$private_attrs\fI\fR" 4
.el .IP "\fI\f(CI$private_attrs\fI\fR" 4
.IX Item "$private_attrs"
This is another (optional) hash ref with your private attributes.
\&\fB\s-1DBI\s0\fR will store them and otherwise leave them alone.
.PP
The \f(CW\*(C`DBI::_new_drh()\*(C'\fR method and the \f(CW\*(C`driver()\*(C'\fR method both return \f(CW\*(C`undef\*(C'\fR
for failure (in which case you must look at \fI\f(CI$DBI::err\fI\fR and \fI\f(CI$DBI::errstr\fI\fR
for the failure information, because you have no driver handle to use).
.PP
Using \fIinstall_method()\fR to expose driver-private methods
.IX Subsection "Using install_method() to expose driver-private methods"
.PP
.Vb 1
\&    DBD::Foo::db\->install_method($method_name, \e%attr);
.Ve
.PP
Installs the driver-private method named by \f(CW$method_name\fR into the
\&\s-1DBI\s0 method dispatcher so it can be called directly, avoiding the
need to use the \fIfunc()\fR method.
.PP
It is called as a static method on the driver class to which the
method belongs. The method name must begin with the corresponding
registered driver-private prefix. For example, for DBD::Oracle
\&\f(CW$method_name\fR must being with '\f(CW\*(C`ora_\*(C'\fR', and for DBD::AnyData it
must begin with '\f(CW\*(C`ad_\*(C'\fR'.
.PP
The \f(CW\*(C`\e%attr\*(C'\fR attributes can be used to provide fine control over how the \s-1DBI\s0
dispatcher handles the dispatching of the method. However it's undocumented
at the moment. See the IMA_* #define's in \s-1DBI\s0.xs and the O=>0x000x values in
the initialization of \f(CW%DBI::DBI_methods\fR in \s-1DBI\s0.pm.  (Volunteers to polish up
and document the interface are very welcome to get in touch via dbi\-dev@perl.org).
.PP
Methods installed using install_method default to the standard error
handling behaviour for \s-1DBI\s0 methods: clearing err and errstr before
calling the method, and checking for errors to trigger RaiseError 
etc. on return. This differs from the default behaviour of \fIfunc()\fR.
.PP
Note for driver authors: The DBD::Foo::xx\->install_method call won't
work until the class-hierarchy has been setup. Normally the \s-1DBI\s0
looks after that just after the driver is loaded. This means
\&\fIinstall_method()\fR can't be called at the time the driver is loaded
unless the class-hierarchy is set up first. The way to do that is
to call the \fIsetup_driver()\fR method:
.PP
.Vb 1
\&    DBI\->setup_driver(\*(AqDBD::Foo\*(Aq);
.Ve
.PP
before using \fIinstall_method()\fR.
.PP
The \s-1CLONE\s0 special subroutine
.IX Subsection "The CLONE special subroutine"
.PP
Also needed here, in the \fBDBD::Driver\fR package, is a \f(CW\*(C`CLONE()\*(C'\fR method
that will be called by perl when an interpreter is cloned. All your
\&\f(CW\*(C`CLONE()\*(C'\fR method needs to do, currently, is clear the cached \fI\f(CI$drh\fI\fR so
the new interpreter won't start using the cached \fI\f(CI$drh\fI\fR from the old
interpreter:
.PP
.Vb 3
\&  sub CLONE {
\&    undef $drh;
\&  }
.Ve
.PP
See <http://search.cpan.org/dist/perl/pod/perlmod.pod#Making_your_module_threadsafe>
for details.
.PP
\fIThe DBD::Driver::dr package\fR
.IX Subsection "The DBD::Driver::dr package"
.PP
The next lines of code look as follows:
.PP
.Vb 1
\&  package DBD::Driver::dr; # ====== DRIVER ======
\&
\&  $DBD::Driver::dr::imp_data_size = 0;
.Ve
.PP
Note that no \fI\f(CI@ISA\fI\fR is needed here, or for the other \fBDBD::Driver::*\fR
classes, because the \fB\s-1DBI\s0\fR takes care of that for you when the driver is
loaded.
.PP
.Vb 2
\& *FIX ME* Explain what the imp_data_size is, so that implementors aren\*(Aqt
\& practicing cargo\-cult programming.
.Ve
.PP
The database handle constructor
.IX Subsection "The database handle constructor"
.PP
The database handle constructor is the driver's (hence the changed
namespace) \f(CW\*(C`connect()\*(C'\fR method:
.PP
.Vb 3
\&  sub connect
\&  {
\&      my ($drh, $dr_dsn, $user, $auth, $attr) = @_;
\&
\&      # Some database specific verifications, default settings
\&      # and the like can go here. This should only include
\&      # syntax checks or similar stuff where it\*(Aqs legal to
\&      # \*(Aqdie\*(Aq in case of errors.
\&      # For example, many database packages requires specific
\&      # environment variables to be set; this could be where you
\&      # validate that they are set, or default them if they are not set.
\&
\&      my $driver_prefix = "drv_"; # the assigned prefix for this driver
\&
\&      # Process attributes from the DSN; we assume ODBC syntax
\&      # here, that is, the DSN looks like var1=val1;...;varN=valN
\&      foreach my $var ( split /;/, $dr_dsn ) {
\&          my ($attr_name, $attr_value) = split \*(Aq=\*(Aq, $var, 2;
\&          return $drh\->set_err($DBI::stderr, "Can\*(Aqt parse DSN part \*(Aq$var\*(Aq")
\&              unless defined $attr_value;
\&
\&          # add driver prefix to attribute name if it doesn\*(Aqt have it already
\&          $attr_name = $driver_prefix.$attr_name
\&              unless $attr_name =~ /^$driver_prefix/o;
\&
\&          # Store attribute into %$attr, replacing any existing value.
\&          # The DBI will STORE() these into $dbh after we\*(Aqve connected
\&          $attr\->{$attr_name} = $attr_value;
\&      }
\&
\&      # Get the attributes we\*(Aqll use to connect.
\&      # We use delete here because these no need to STORE them
\&      my $db = delete $attr\->{drv_database} || delete $attr\->{drv_db}
\&          or return $drh\->set_err($DBI::stderr, "No database name given in DSN \*(Aq$dr_dsn\*(Aq");
\&      my $host = delete $attr\->{drv_host} || \*(Aqlocalhost\*(Aq;
\&      my $port = delete $attr\->{drv_port} || 123456;
\&
\&      # Assume you can attach to your database via drv_connect:
\&      my $connection = drv_connect($db, $host, $port, $user, $auth)
\&          or return $drh\->set_err($DBI::stderr, "Can\*(Aqt connect to $dr_dsn: ...");
\&
\&      # create a \*(Aqblank\*(Aq dbh (call superclass constructor)
\&      my ($outer, $dbh) = DBI::_new_dbh($drh, { Name => $dr_dsn });
\&
\&      $dbh\->STORE(\*(AqActive\*(Aq, 1 );
\&      $dbh\->{drv_connection} = $connection;
\&
\&      return $outer;
\&  }
.Ve
.PP
This is mostly the same as in the \fIdriver handle constructor\fR above.
The arguments are described in \s-1DBI\s0.
.PP
The constructor \f(CW\*(C`DBI::_new_dbh()\*(C'\fR is called, returning a database handle.
The constructor's prototype is:
.PP
.Vb 1
\&  ($outer, $inner) = DBI::_new_dbh($drh, $public_attr, $private_attr);
.Ve
.PP
with similar arguments to those in the \fIdriver handle constructor\fR,
except that the \fI\f(CI$class\fI\fR is replaced by \fI\f(CI$drh\fI\fR. The \fIName\fR attribute
is a standard \fB\s-1DBI\s0\fR attribute (see \*(L"Database Handle Attributes\*(R" in \s-1DBI\s0).
.PP
In scalar context, only the outer handle is returned.
.PP
Note the use of the \f(CW\*(C`STORE()\*(C'\fR method for setting the \fIdbh\fR attributes.
That's because within the driver code, the handle object you have is
the 'inner' handle of a tied hash, not the outer handle that the
users of your driver have.
.PP
Because you have the inner handle, tie magic doesn't get invoked
when you get or set values in the hash. This is often very handy for
speed when you want to get or set simple non-special driver-specific
attributes.
.PP
However, some attribute values, such as those handled by the \fB\s-1DBI\s0\fR like
\&\fIPrintError\fR, don't actually exist in the hash and must be read via
\&\f(CW\*(C`$h\->FETCH($attrib)\*(C'\fR and set via \f(CW\*(C`$h\->STORE($attrib, $value)\*(C'\fR.
If in any doubt, use these methods.
.PP
The \fIdata_sources()\fR method
.IX Subsection "The data_sources() method"
.PP
The \f(CW\*(C`data_sources()\*(C'\fR method must populate and return a list of valid data
sources, prefixed with the "\fIdbi:Driver\fR" incantation that allows them to
be used in the first argument of the \f(CW\*(C`DBI\->connect()\*(C'\fR method.
An example of this might be scanning the \fI\f(CI$HOME\fI/.odbcini\fR file on Unix
for \s-1ODBC\s0 data sources (DSNs).
.PP
As a trivial example, consider a fixed list of data sources:
.PP
.Vb 11
\&  sub data_sources
\&  {
\&      my($drh, $attr) = @_;
\&      my(@list) = ();
\&      # You need more sophisticated code than this to set @list...
\&      push @list, "dbi:Driver:abc";
\&      push @list, "dbi:Driver:def";
\&      push @list, "dbi:Driver:ghi";
\&      # End of code to set @list
\&      return @list;
\&  }
.Ve
.PP
The \fIdisconnect_all()\fR method
.IX Subsection "The disconnect_all() method"
.PP
If you need to release any resources when the driver is unloaded, you
can provide a disconnect_all method.
.PP
Other driver handle methods
.IX Subsection "Other driver handle methods"
.PP
If you need any other driver handle methods, they can follow here.
.PP
Error handling
.IX Subsection "Error handling"
.PP
It is quite likely that something fails in the connect method.
With \fBDBD::File\fR for example, you might catch an error when setting the
current directory to something not existent by using the
(driver-specific) \fIf_dir\fR attribute.
.PP
To report an error, you use the \f(CW\*(C`set_err()\*(C'\fR method:
.PP
.Vb 1
\&  $h\->set_err($err, $errmsg, $state);
.Ve
.PP
This will ensure that the error is recorded correctly and that
\&\fIRaiseError\fR and \fIPrintError\fR etc are handled correctly.
.PP
Typically you'll always use the method instance, aka your method's first
argument.
.PP
As \f(CW\*(C`set_err()\*(C'\fR always returns \f(CW\*(C`undef\*(C'\fR your error handling code can
usually be simplified to something like this:
.PP
.Vb 1
\&  return $h\->set_err($err, $errmsg, $state) if ...;
.Ve
.PP
\fIThe DBD::Driver::db package\fR
.IX Subsection "The DBD::Driver::db package"
.PP
.Vb 1
\&  package DBD::Driver::db; # ====== DATABASE ======
\&
\&  $DBD::Driver::db::imp_data_size = 0;
.Ve
.PP
The statement handle constructor
.IX Subsection "The statement handle constructor"
.PP
There's nothing much new in the statement handle constructor, which
is the \f(CW\*(C`prepare()\*(C'\fR method:
.PP
.Vb 3
\&  sub prepare
\&  {
\&      my ($dbh, $statement, @attribs) = @_;
\&
\&      # create a \*(Aqblank\*(Aq sth
\&      my ($outer, $sth) = DBI::_new_sth($dbh, { Statement => $statement });
\&
\&      $sth\->STORE(\*(AqNUM_OF_PARAMS\*(Aq, ($statement =~ tr/?//));
\&
\&      $sth\->{drv_params} = [];
\&
\&      return $outer;
\&  }
.Ve
.PP
This is still the same \*(-- check the arguments and call the super class
constructor \f(CW\*(C`DBI::_new_sth()\*(C'\fR. Again, in scalar context, only the outer
handle is returned. The \fIStatement\fR attribute should be cached as
shown.
.PP
Note the prefix \fIdrv_\fR in the attribute names: it is required that
all your private attributes use a lowercase prefix unique to your driver.
As mentioned earlier in this document, the \fB\s-1DBI\s0\fR contains a registry of
known driver prefixes and may one day warn about unknown attributes
that don't have a registered prefix.
.PP
Note that we parse the statement here in order to set the attribute
\&\fI\s-1NUM_OF_PARAMS\s0\fR. The technique illustrated is not very reliable; it can
be confused by question marks appearing in quoted strings, delimited
identifiers or in \s-1SQL\s0 comments that are part of the \s-1SQL\s0 statement. We
could set \fI\s-1NUM_OF_PARAMS\s0\fR in the \f(CW\*(C`execute()\*(C'\fR method instead because
the \fB\s-1DBI\s0\fR specification explicitly allows a driver to defer this, but then
the user could not call \f(CW\*(C`bind_param()\*(C'\fR.
.PP
Transaction handling
.IX Subsection "Transaction handling"
.PP
Pure Perl drivers will rarely support transactions. Thus your \f(CW\*(C`commit()\*(C'\fR
and \f(CW\*(C`rollback()\*(C'\fR methods will typically be quite simple:
.PP
.Vb 8
\&  sub commit
\&  {
\&      my ($dbh) = @_;
\&      if ($dbh\->FETCH(\*(AqWarn\*(Aq)) {
\&          warn("Commit ineffective while AutoCommit is on");
\&      }
\&      0;
\&  }
\&
\&  sub rollback {
\&      my ($dbh) = @_;
\&      if ($dbh\->FETCH(\*(AqWarn\*(Aq)) {
\&          warn("Rollback ineffective while AutoCommit is on");
\&      }
\&      0;
\&  }
.Ve
.PP
Or even simpler, just use the default methods provided by the \fB\s-1DBI\s0\fR that
do nothing except return \f(CW\*(C`undef\*(C'\fR.
.PP
The \fB\s-1DBI\s0\fR's default \f(CW\*(C`begin_work()\*(C'\fR method can be used by inheritance.
.PP
The \s-1\fISTORE\s0()\fR and \s-1\fIFETCH\s0()\fR methods
.IX Subsection "The STORE() and FETCH() methods"
.PP
These methods (that we have already used, see above) are called for
you, whenever the user does a:
.PP
.Vb 1
\&  $dbh\->{$attr} = $val;
.Ve
.PP
or, respectively,
.PP
.Vb 1
\&  $val = $dbh\->{$attr};
.Ve
.PP
See perltie for details on tied hash refs to understand why these
methods are required.
.PP
The \fB\s-1DBI\s0\fR will handle most attributes for you, in particular attributes
like \fIRaiseError\fR or \fIPrintError\fR. All you have to do is handle your
driver's private attributes and any attributes, like \fIAutoCommit\fR and
\&\fIChopBlanks\fR, that the \fB\s-1DBI\s0\fR can't handle for you.
.PP
A good example might look like this:
.PP
.Vb 10
\&  sub STORE
\&  {
\&      my ($dbh, $attr, $val) = @_;
\&      if ($attr eq \*(AqAutoCommit\*(Aq) {
\&          # AutoCommit is currently the only standard attribute we have
\&          # to consider.
\&          if (!$val) { die "Can\*(Aqt disable AutoCommit"; }
\&          return 1;
\&      }
\&      if ($attr =~ m/^drv_/) {
\&          # Handle only our private attributes here
\&          # Note that we could trigger arbitrary actions.
\&          # Ideally we should warn about unknown attributes.
\&          $dbh\->{$attr} = $val; # Yes, we are allowed to do this,
\&          return 1;             # but only for our private attributes
\&      }
\&      # Else pass up to DBI to handle for us
\&      $dbh\->SUPER::STORE($attr, $val);
\&  }
\&
\&  sub FETCH
\&  {
\&      my ($dbh, $attr) = @_;
\&      if ($attr eq \*(AqAutoCommit\*(Aq) { return 1; }
\&      if ($attr =~ m/^drv_/) {
\&          # Handle only our private attributes here
\&          # Note that we could trigger arbitrary actions.
\&          return $dbh\->{$attr}; # Yes, we are allowed to do this,
\&                                # but only for our private attributes
\&      }
\&      # Else pass up to DBI to handle
\&      $dbh\->SUPER::FETCH($attr);
\&  }
.Ve
.PP
The \fB\s-1DBI\s0\fR will actually store and fetch driver-specific attributes (with all
lowercase names) without warning or error, so there's actually no need to
implement driver-specific any code in your \f(CW\*(C`FETCH()\*(C'\fR and \f(CW\*(C`STORE()\*(C'\fR
methods unless you need extra logic/checks, beyond getting or setting
the value.
.PP
Unless your driver documentation indicates otherwise, the return value of
the \f(CW\*(C`STORE()\*(C'\fR method is unspecified and the caller shouldn't use that value.
.PP
Other database handle methods
.IX Subsection "Other database handle methods"
.PP
As with the driver package, other database handle methods may follow here.
In particular you should consider a (possibly empty) \f(CW\*(C`disconnect()\*(C'\fR
method and possibly a \f(CW\*(C`quote()\*(C'\fR method if \fB\s-1DBI\s0\fR's default isn't correct for
you. You may also need the \f(CW\*(C`type_info_all()\*(C'\fR and \f(CW\*(C`get_info()\*(C'\fR methods,
as described elsewhere in this document.
.PP
Where reasonable use \f(CW\*(C`$h\->SUPER::foo()\*(C'\fR to call the \fB\s-1DBI\s0\fR's method in
some or all cases and just wrap your custom behavior around that.
.PP
If you want to use private trace flags you'll probably want to be
able to set them by name. To do that you'll need to define a
\&\f(CW\*(C`parse_trace_flag()\*(C'\fR method (note that's \*(L"parse_trace_flag\*(R", singular,
not \*(L"parse_trace_flags\*(R", plural).
.PP
.Vb 9
\&  sub parse_trace_flag {
\&      my ($h, $name) = @_;
\&      return 0x01000000 if $name eq \*(Aqfoo\*(Aq;
\&      return 0x02000000 if $name eq \*(Aqbar\*(Aq;
\&      return 0x04000000 if $name eq \*(Aqbaz\*(Aq;
\&      return 0x08000000 if $name eq \*(Aqboo\*(Aq;
\&      return 0x10000000 if $name eq \*(Aqbop\*(Aq;
\&      return $h\->SUPER::parse_trace_flag($name);
\&  }
.Ve
.PP
All private flag names must be lowercase, and all private flags
must be in the top 8 of the 32 bits.
.PP
\fIThe DBD::Driver::st package\fR
.IX Subsection "The DBD::Driver::st package"
.PP
This package follows the same pattern the others do:
.PP
.Vb 1
\&  package DBD::Driver::st;
\&
\&  $DBD::Driver::st::imp_data_size = 0;
.Ve
.PP
The \fIexecute()\fR and \fIbind_param()\fR methods
.IX Subsection "The execute() and bind_param() methods"
.PP
This is perhaps the most difficult method because we have to consider
parameter bindings here. In addition to that, there are a number of
statement attributes which must be set for inherited \fB\s-1DBI\s0\fR methods to
function correctly (see \*(L"Statement attributes\*(R" below).
.PP
We present a simplified implementation by using the \fIdrv_params\fR
attribute from above:
.PP
.Vb 12
\&  sub bind_param
\&  {
\&      my ($sth, $pNum, $val, $attr) = @_;
\&      my $type = (ref $attr) ? $attr\->{TYPE} : $attr;
\&      if ($type) {
\&          my $dbh = $sth\->{Database};
\&          $val = $dbh\->quote($sth, $type);
\&      }
\&      my $params = $sth\->{drv_params};
\&      $params\->[$pNum\-1] = $val;
\&      1;
\&  }
\&
\&  sub execute
\&  {
\&      my ($sth, @bind_values) = @_;
\&
\&      # start of by finishing any previous execution if still active
\&      $sth\->finish if $sth\->FETCH(\*(AqActive\*(Aq);
\&
\&      my $params = (@bind_values) ?
\&          \e@bind_values : $sth\->{drv_params};
\&      my $numParam = $sth\->FETCH(\*(AqNUM_OF_PARAMS\*(Aq);
\&      return $sth\->set_err($DBI::stderr, "Wrong number of parameters")
\&          if @$params != $numParam;
\&      my $statement = $sth\->{\*(AqStatement\*(Aq};
\&      for (my $i = 0;  $i < $numParam;  $i++) {
\&          $statement =~ s/?/$params\->[$i]/; # XXX doesn\*(Aqt deal with quoting etc!
\&      }
\&      # Do anything ... we assume that an array ref of rows is
\&      # created and store it:
\&      $sth\->{\*(Aqdrv_data\*(Aq} = $data;
\&      $sth\->{\*(Aqdrv_rows\*(Aq} = @$data; # number of rows
\&      $sth\->STORE(\*(AqNUM_OF_FIELDS\*(Aq) = $numFields;
\&      $sth\->{Active} = 1;
\&      @$data || \*(Aq0E0\*(Aq;
\&  }
.Ve
.PP
There are a number of things you should note here.
.PP
We initialize the \fI\s-1NUM_OF_FIELDS\s0\fR and \fIActive\fR attributes here,
because they are essential for \f(CW\*(C`bind_columns()\*(C'\fR to work.
.PP
We use attribute \f(CW\*(C`$sth\->{Statement}\*(C'\fR which we created
within \f(CW\*(C`prepare()\*(C'\fR. The attribute \f(CW\*(C`$sth\->{Database}\*(C'\fR, which is
nothing else than the \fIdbh\fR, was automatically created by \fB\s-1DBI\s0\fR.
.PP
Finally, note that (as specified in the \fB\s-1DBI\s0\fR specification) we return the
string \f(CW\*(Aq0E0\*(Aq\fR instead of the number 0, so that the result tests true but
equal to zero.
.PP
.Vb 1
\&  $sth\->execute() or die $sth\->errstr;
.Ve
.PP
The \fIexecute_array()\fR, \fIexecute_for_fetch()\fR and \fIbind_param_array()\fR methods
.IX Subsection "The execute_array(), execute_for_fetch() and bind_param_array() methods"
.PP
In general, \s-1DBD\s0's only need to implement \f(CW\*(C`execute_for_fetch()\*(C'\fR and
\&\f(CW\*(C`bind_param_array\*(C'\fR. \s-1DBI\s0's default \f(CW\*(C`execute_array()\*(C'\fR will invoke the
\&\s-1DBD\s0's \f(CW\*(C`execute_for_fetch()\*(C'\fR as needed.
.PP
The following sequence describes the interaction between
\&\s-1DBI\s0 \f(CW\*(C`execute_array\*(C'\fR and a \s-1DBD\s0's \f(CW\*(C`execute_for_fetch\*(C'\fR:
.IP "1." 4
App calls \f(CW\*(C`$sth\->execute_array(\e%attrs, @array_of_arrays)\*(C'\fR
.IP "2." 4
If \f(CW@array_of_arrays\fR was specified, \s-1DBI\s0 processes \f(CW@array_of_arrays\fR by calling
\&\s-1DBD\s0's \f(CW\*(C`bind_param_array()\*(C'\fR. Alternately, App may have directly called
\&\f(CW\*(C`bind_param_array()\*(C'\fR
.IP "3." 4
\&\s-1DBD\s0 validates and binds each array
.IP "4." 4
\&\s-1DBI\s0 retrieves the validated param arrays from \s-1DBD\s0's ParamArray attribute
.IP "5." 4
\&\s-1DBI\s0 calls \s-1DBD\s0's \f(CW\*(C`execute_for_fetch($fetch_tuple_sub, \e@tuple_status)\*(C'\fR,
where \f(CW&$fetch_tuple_sub\fR is a closure to iterate over the
returned ParamArray values, and \f(CW\*(C`\e@tuple_status\*(C'\fR is an array to receive
the disposition status of each tuple.
.IP "6." 4
\&\s-1DBD\s0 iteratively calls \f(CW&$fetch_tuple_sub\fR to retrieve parameter tuples
to be added to its bulk database operation/request.
.IP "7." 4
when \s-1DBD\s0 reaches the limit of tuples it can handle in a single database
operation/request, or the \f(CW&$fetch_tuple_sub\fR indicates no more
tuples by returning undef, the \s-1DBD\s0 executes the bulk operation, and
reports the disposition of each tuple in \e@tuple_status.
.IP "8." 4
\&\s-1DBD\s0 repeats steps 6 and 7 until all tuples are processed.
.PP
E.g., here's the essence of DBD::Oracle's execute_for_fetch:
.PP
.Vb 10
\&       while (1) {
\&           my @tuple_batch;
\&           for (my $i = 0; $i < $batch_size; $i++) {
\&                push @tuple_batch, [ @{$fetch_tuple_sub\->() || last} ];
\&           }
\&           last unless @tuple_batch;
\&           my $res = ora_execute_array($sth, \e@tuple_batch,
\&              scalar(@tuple_batch), $tuple_batch_status);
\&           push @$tuple_status, @$tuple_batch_status;
\&       }
.Ve
.PP
Note that \s-1DBI\s0's default \fIexecute_array()\fR/\fIexecute_for_fetch()\fR implementation
requires the use of positional (i.e., '?') placeholders. Drivers
which \fBrequire\fR named placeholders must either emulate positional
placeholders (e.g., see DBD::Oracle), or must implement their own
\&\fIexecute_array()\fR/\fIexecute_for_fetch()\fR methods to properly sequence bound
parameter arrays.
.PP
Fetching data
.IX Subsection "Fetching data"
.PP
Only one method needs to be written for fetching data, \f(CW\*(C`fetchrow_arrayref()\*(C'\fR.
The other methods, \f(CW\*(C`fetchrow_array()\*(C'\fR, \f(CW\*(C`fetchall_arrayref()\*(C'\fR, etc, as well
as the database handle's \f(CW\*(C`select*\*(C'\fR methods are part of \fB\s-1DBI\s0\fR, and call
\&\f(CW\*(C`fetchrow_arrayref()\*(C'\fR as necessary.
.PP
.Vb 10
\&  sub fetchrow_arrayref
\&  {
\&      my ($sth) = @_;
\&      my $data = $sth\->{drv_data};
\&      my $row = shift @$data;
\&      if (!$row) {
\&          $sth\->STORE(Active => 0); # mark as no longer active
\&          return undef;
\&      }
\&      if ($sth\->FETCH(\*(AqChopBlanks\*(Aq)) {
\&          map { $_ =~ s/\es+$//; } @$row;
\&      }
\&      return $sth\->_set_fbav($row);
\&  }
\&  *fetch = \e&fetchrow_arrayref; # required alias for fetchrow_arrayref
.Ve
.PP
Note the use of the method \f(CW\*(C`_set_fbav()\*(C'\fR \*(-- this is required so that
\&\f(CW\*(C`bind_col()\*(C'\fR and \f(CW\*(C`bind_columns()\*(C'\fR work.
.PP
If an error occurs which leaves the \fI\f(CI$sth\fI\fR in a state where remaining rows
can't be fetched then \fIActive\fR should be turned off before the method returns.
.PP
The \f(CW\*(C`rows()\*(C'\fR method for this driver can be implemented like this:
.PP
.Vb 1
\&  sub rows { shift\->{drv_rows} }
.Ve
.PP
because it knows in advance how many rows it has fetched.
Alternatively you could delete that method and so fallback
to the \fB\s-1DBI\s0\fR's own method which does the right thing based
on the number of calls to \f(CW\*(C`_set_fbav()\*(C'\fR.
.PP
The more_results method
.IX Subsection "The more_results method"
.PP
If your driver doesn't support multiple result sets, then don't even implement this method.
.PP
Otherwise, this method needs to get the statement handle ready to fetch results
from the next result set, if there is one. Typically you'd start with:
.PP
.Vb 1
\&    $sth\->finish;
.Ve
.PP
then you should delete all the attributes from the attribute cache that may no
longer be relevant for the new result set:
.PP
.Vb 2
\&    delete $sth\->{$_}
\&        for qw(NAME TYPE PRECISION SCALE ...);
.Ve
.PP
for drivers written in C use:
.PP
.Vb 6
\&    hv_delete((HV*)SvRV(sth), "NAME", 4, G_DISCARD);
\&    hv_delete((HV*)SvRV(sth), "NULLABLE", 8, G_DISCARD);
\&    hv_delete((HV*)SvRV(sth), "NUM_OF_FIELDS", 13, G_DISCARD);
\&    hv_delete((HV*)SvRV(sth), "PRECISION", 9, G_DISCARD);
\&    hv_delete((HV*)SvRV(sth), "SCALE", 5, G_DISCARD);
\&    hv_delete((HV*)SvRV(sth), "TYPE", 4, G_DISCARD);
.Ve
.PP
Don't forget to also delete, or update, any driver-private attributes that may
not be correct for the next resultset.
.PP
The \s-1NUM_OF_FIELDS\s0 attribute is a special case. It should be set using \s-1STORE:\s0
.PP
.Vb 2
\&    $sth\->STORE(NUM_OF_FIELDS => 0); /* for DBI <= 1.53 */
\&    $sth\->STORE(NUM_OF_FIELDS => $new_value);
.Ve
.PP
for drivers written in C use this incantation:
.PP
.Vb 5
\&    /* Adjust NUM_OF_FIELDS \- which also adjusts the row buffer size */
\&    DBIc_NUM_FIELDS(imp_sth) = 0; /* for DBI <= 1.53 */
\&    DBIc_STATE(imp_xxh)\->set_attr_k(sth, sv_2mortal(newSVpvn("NUM_OF_FIELDS",13)), 0,
\&        sv_2mortal(newSViv(mysql_num_fields(imp_sth\->result)))
\&    );
.Ve
.PP
For \s-1DBI\s0 versions prior to 1.54 you'll also need to explicitly adjust the
number of elements in the row buffer array (\f(CW\*(C`DBIc_FIELDS_AV(imp_sth)\*(C'\fR)
to match the new result set. Fill any new values with \fInewSV\fR\|(0) not &sv_undef.
Alternatively you could free DBIc_FIELDS_AV(imp_sth) and set it to null,
but that would mean \fIbind_columns()\fR wouldn't work across result sets.
.PP
Statement attributes
.IX Subsection "Statement attributes"
.PP
The main difference between \fIdbh\fR and \fIsth\fR attributes is, that you
should implement a lot of attributes here that are required by
the \fB\s-1DBI\s0\fR, such as \fI\s-1NAME\s0\fR, \fI\s-1NULLABLE\s0\fR, \fI\s-1TYPE\s0\fR, etc. See
\&\*(L"Statement Handle Attributes\*(R" in \s-1DBI\s0 for a complete list.
.PP
Pay attention to attributes which are marked as read only, such as
\&\fI\s-1NUM_OF_PARAMS\s0\fR. These attributes can only be set the first time
a statement is executed. If a statement is prepared, then executed
multiple times, warnings may be generated.
.PP
You can protect against these warnings, and prevent the recalculation
of attributes which might be expensive to calculate (such as the
\&\fI\s-1NAME\s0\fR and \fINAME_*\fR attributes):
.PP
.Vb 3
\&    my $storedNumParams = $sth\->FETCH(\*(AqNUM_OF_PARAMS\*(Aq);
\&    if (!defined $storedNumParams or $storedNumFields < 0) {
\&        $sth\->STORE(\*(AqNUM_OF_PARAMS\*(Aq) = $numParams;
\&
\&        # Set other useful attributes that only need to be set once
\&        # for a statement, like $sth\->{NAME} and $sth\->{TYPE}
\&    }
.Ve
.PP
One particularly important attribute to set correctly (mentioned in
\&\*(L"\s-1ATTRIBUTES\s0 \s-1COMMON\s0 \s-1TO\s0 \s-1ALL\s0 \s-1HANDLES\s0\*(R" in \s-1DBI\s0 is \fIActive\fR. Many \fB\s-1DBI\s0\fR methods,
including \f(CW\*(C`bind_columns()\*(C'\fR, depend on this attribute.
.PP
Besides that the \f(CW\*(C`STORE()\*(C'\fR and \f(CW\*(C`FETCH()\*(C'\fR methods are mainly the same
as above for \fIdbh\fR's.
.PP
Other statement methods
.IX Subsection "Other statement methods"
.PP
A trivial \f(CW\*(C`finish()\*(C'\fR method to discard stored data, reset any attributes
(such as \fIActive\fR) and do \f(CW\*(C`$sth\->SUPER::finish()\*(C'\fR.
.PP
If you've defined a \f(CW\*(C`parse_trace_flag()\*(C'\fR method in \fB::db\fR you'll also want
it in \fB::st\fR, so just alias it in:
.PP
.Vb 1
\&  *parse_trace_flag = \e&DBD::foo:db::parse_trace_flag;
.Ve
.PP
And perhaps some other methods that are not part of the \fB\s-1DBI\s0\fR
specification, in particular to make metadata available.
Remember that they must have names that begin with your drivers
registered prefix so they can be installed using \f(CW\*(C`install_method()\*(C'\fR.
.PP
If \f(CW\*(C`DESTROY()\*(C'\fR is called on a statement handle that's still active
(\f(CW\*(C`$sth\->{Active}\*(C'\fR is true) then it should effectively call \f(CW\*(C`finish()\*(C'\fR.
.PP
.Vb 4
\&    sub DESTROY {
\&        my $sth = shift;
\&        $sth\->finish if $sth\->FETCH(\*(AqActive\*(Aq);
\&    }
.Ve
.SS "Tests"
.IX Subsection "Tests"
The test process should conform as closely as possibly to the Perl
standard test harness.
.PP
In particular, most (all) of the tests should be run in the \fIt\fR sub-directory,
and should simply produce an \f(CW\*(C`ok\*(C'\fR when run under \f(CW\*(C`make test\*(C'\fR.
For details on how this is done, see the Camel book and the section in
Chapter 7, \*(L"The Standard Perl Library\*(R" on Test::Harness.
.PP
The tests may need to adapt to the type of database which is being used
for testing, and to the privileges of the user testing the driver. For
example, the \fBDBD::Informix\fR test code has to adapt in a number of
places to the type of database to which it is connected as different
Informix databases have different capabilities: some of the tests are
for databases without transaction logs; others are for databases with a
transaction log; some versions of the server have support for blobs, or
stored procedures, or user-defined data types, and others do not.
.PP
When a complete file of tests must be skipped, you can provide a reason
in a pseudo-comment:
.PP
.Vb 5
\&    if ($no_transactions_available)
\&    {
\&        print "1..0 # Skip: No transactions available\en";
\&        exit 0;
\&    }
.Ve
.PP
Consider downloading the \fBDBD::Informix\fR code and look at the code in
\&\fIDBD/Informix/TestHarness.pm\fR which is used throughout the
\&\fBDBD::Informix\fR tests in the \fIt\fR sub-directory.
.SH "CREATING A C/XS DRIVER"
.IX Header "CREATING A C/XS DRIVER"
Please also see the section under \*(L"\s-1CREATING\s0 A \s-1PURE\s0 \s-1PERL\s0 \s-1DRIVER\s0\*(R"
regarding the creation of the \fIMakefile.PL\fR.
.PP
Creating a new C/XS driver from scratch will always be a daunting task.
You can and should greatly simplify your task by taking a good
reference driver implementation and modifying that to match the
database product for which you are writing a driver.
.PP
The de facto reference driver has been the one for \fBDBD::Oracle\fR written
by Tim Bunce, who is also the author of the \fB\s-1DBI\s0\fR package. The \fBDBD::Oracle\fR
module is a good example of a driver implemented around a C\-level \s-1API\s0.
.PP
Nowadays it it seems better to base on \fB\s-1DBD::ODBC\s0\fR, another driver
maintained by Tim and Jeff Urlwin, because it offers a lot of metadata
and seems to become the guideline for the future development. (Also as
\&\fBDBD::Oracle\fR digs deeper into the Oracle 8 \s-1OCI\s0 interface it'll get even
more hairy than it is now.)
.PP
The \fBDBD::Informix\fR driver is one driver implemented using embedded \s-1SQL\s0
instead of a function-based \s-1API\s0.
\&\fBDBD::Ingres\fR may also be worth a look.
.SS "C/XS version of Driver.pm"
.IX Subsection "C/XS version of Driver.pm"
A lot of the code in the \fIDriver.pm\fR file is very similar to the code for pure Perl modules
\&\- see above.  However,
there are also some subtle (and not so subtle) differences, including:
.IP "\(bu" 8
The variables \fI\f(CI$DBD::Driver::\fI{dr|db|st}::imp_data_size\fR are not defined
here, but in the \s-1XS\s0 code, because they declare the size of certain
C structures.
.IP "\(bu" 8
Some methods are typically moved to the \s-1XS\s0 code, in particular
\&\f(CW\*(C`prepare()\*(C'\fR, \f(CW\*(C`execute()\*(C'\fR, \f(CW\*(C`disconnect()\*(C'\fR, \f(CW\*(C`disconnect_all()\*(C'\fR and the
\&\f(CW\*(C`STORE()\*(C'\fR and \f(CW\*(C`FETCH()\*(C'\fR methods.
.IP "\(bu" 8
Other methods are still part of \fIDriver.pm\fR, but have callbacks to
the \s-1XS\s0 code.
.IP "\(bu" 8
If the driver-specific parts of the \fIimp_drh_t\fR structure need to be
formally initialized (which does not seem to be a common requirement),
then you need to add a call to an appropriate \s-1XS\s0 function in the driver
method of \f(CW\*(C`DBD::Driver::driver()\*(C'\fR, and you define the corresponding function
in \fIDriver.xs\fR, and you define the C code in \fIdbdimp.c\fR and the prototype in
\&\fIdbdimp.h\fR.
.Sp
For example, \fBDBD::Informix\fR has such a requirement, and adds the
following call after the call to \f(CW\*(C`_new_drh()\*(C'\fR in \fIInformix.pm\fR:
.Sp
.Vb 1
\&  DBD::Informix::dr::driver_init($drh);
.Ve
.Sp
and the following code in \fIInformix.xs\fR:
.Sp
.Vb 6
\&  # Initialize the DBD::Informix driver data structure
\&  void
\&  driver_init(drh)
\&      SV *drh
\&      CODE:
\&      ST(0) = dbd_ix_dr_driver_init(drh) ? &sv_yes : &sv_no;
.Ve
.Sp
and the code in \fIdbdimp.h\fR declares:
.Sp
.Vb 1
\&  extern int dbd_ix_dr_driver_init(SV *drh);
.Ve
.Sp
and the code in \fIdbdimp.ec\fR (equivalent to \fIdbdimp.c\fR) defines:
.Sp
.Vb 11
\&  /* Formally initialize the DBD::Informix driver structure */
\&  int
\&  dbd_ix_dr_driver(SV *drh)
\&  {
\&      D_imp_drh(drh);
\&      imp_drh\->n_connections = 0;       /* No active connections */
\&      imp_drh\->current_connection = 0;  /* No current connection */
\&      imp_drh\->multipleconnections = (ESQLC_VERSION >= 600) ? True : False;
\&      dbd_ix_link_newhead(&imp_drh\->head);  /* Empty linked list of connections */
\&      return 1;
\&  }
.Ve
.Sp
\&\fBDBD::Oracle\fR has a similar requirement but gets around it by checking
whether the private data part of the driver handle is all zeroed out,
rather than add extra functions.
.PP
Now let's take a closer look at an excerpt from \fIOracle.pm\fR (revised
heavily to remove idiosyncrasies) as an example, ignoring things that
were already discussed for pure Perl drivers.
.PP
\fIThe connect method\fR
.IX Subsection "The connect method"
.PP
The connect method is the database handle constructor.
You could write either of two versions of this method: either one which
takes connection attributes (new code) and one which ignores them (old
code only).
.PP
If you ignore the connection attributes, then you omit all mention of
the \fI\f(CI$auth\fI\fR variable (which is a reference to a hash of attributes), and
the \s-1XS\s0 system manages the differences for you.
.PP
.Vb 3
\&  sub connect
\&  {
\&      my ($drh, $dbname, $user, $auth, $attr) = @_;
\&
\&      # Some database specific verifications, default settings
\&      # and the like following here. This should only include
\&      # syntax checks or similar stuff where it\*(Aqs legal to
\&      # \*(Aqdie\*(Aq in case of errors.
\&
\&      my $dbh = DBI::_new_dbh($drh, {
\&              \*(AqName\*(Aq   => $dbname,
\&          })
\&          or return undef;
\&
\&      # Call the driver\-specific function _login in Driver.xs file which
\&      # calls the DBMS\-specific function(s) to connect to the database,
\&      # and populate internal handle data.
\&      DBD::Driver::db::_login($dbh, $dbname, $user, $auth, $attr)
\&          or return undef;
\&
\&      $dbh;
\&  }
.Ve
.PP
This is mostly the same as in the pure Perl case, the exception being
the use of the private \f(CW\*(C`_login()\*(C'\fR callback, which is the function
that will really connect to the database. It is implemented in
\&\fIDriver.xst\fR (you should not implement it) and calls
\&\f(CW\*(C`dbd_db_login6()\*(C'\fR or \f(CW\*(C`dbd_db_login6_sv\*(C'\fR from \fIdbdimp.c\fR. See below
for details.
.PP
If your driver has driver-specific attributes which may be passed in the
connect method and hence end up in \f(CW$attr\fR in \f(CW\*(C`dbd_db_login6\*(C'\fR then it
is best to delete any you process so \s-1DBI\s0 does not send them again
via \s-1STORE\s0 after connect. You can do this in C like this:
.PP
.Vb 2
\&  DBD_ATTRIB_DELETE(attr, "my_attribute_name",
\&                    strlen("my_attribute_name"));
.Ve
.PP
However, prior to \s-1DBI\s0 subversion version 11605 (and fixed post 1.607)
\&\s-1DBD_ATTRIB_DELETE\s0 segfaulted so if you cannot guarantee the \s-1DBI\s0 version
will be post 1.607 you need to use:
.PP
.Vb 2
\&  hv_delete((HV*)SvRV(attr), "my_attribute_name",
\&                     strlen("my_attribute_name"), G_DISCARD);
\&
\& *FIX ME* Discuss removing attributes in Perl code.
.Ve
.PP
\fIThe disconnect_all method\fR
.IX Subsection "The disconnect_all method"
.PP
.Vb 1
\& *FIX ME* T.B.S
.Ve
.PP
\fIThe data_sources method\fR
.IX Subsection "The data_sources method"
.PP
If your \f(CW\*(C`data_sources()\*(C'\fR method can be implemented in pure Perl, then do
so because it is easier than doing it in \s-1XS\s0 code (see the section above
for pure Perl drivers).
.PP
If your \f(CW\*(C`data_sources()\*(C'\fR method must call onto compiled functions, then
you will need to define \fIdbd_dr_data_sources\fR in your \fIdbdimp.h\fR file, which
will trigger \fIDriver.xst\fR (in \fB\s-1DBI\s0\fR v1.33 or greater) to generate the \s-1XS\s0
code that calls your actual C function (see the discussion below for
details) and you do not code anything in \fIDriver.pm\fR to handle it.
.PP
\fIThe prepare method\fR
.IX Subsection "The prepare method"
.PP
The prepare method is the statement handle constructor, and most of it
is not new. Like the \f(CW\*(C`connect()\*(C'\fR method, it now has a C callback:
.PP
.Vb 2
\&  package DBD::Driver::db; # ====== DATABASE ======
\&  use strict;
\&
\&  sub prepare
\&  {
\&      my ($dbh, $statement, $attribs) = @_;
\&
\&      # create a \*(Aqblank\*(Aq sth
\&      my $sth = DBI::_new_sth($dbh, {
\&          \*(AqStatement\*(Aq => $statement,
\&          })
\&          or return undef;
\&
\&      # Call the driver\-specific function _prepare in Driver.xs file
\&      # which calls the DBMS\-specific function(s) to prepare a statement
\&      # and populate internal handle data.
\&      DBD::Driver::st::_prepare($sth, $statement, $attribs)
\&          or return undef;
\&      $sth;
\&  }
.Ve
.PP
\fIThe execute method\fR
.IX Subsection "The execute method"
.PP
.Vb 1
\& *FIX ME* T.B.S
.Ve
.PP
\fIThe fetchrow_arrayref method\fR
.IX Subsection "The fetchrow_arrayref method"
.PP
.Vb 1
\& *FIX ME* T.B.S
.Ve
.PP
\fIOther methods?\fR
.IX Subsection "Other methods?"
.PP
.Vb 1
\& *FIX ME* T.B.S
.Ve
.SS "Driver.xs"
.IX Subsection "Driver.xs"
\&\fIDriver.xs\fR should look something like this:
.PP
.Vb 1
\&  #include "Driver.h"
\&
\&  DBISTATE_DECLARE;
\&
\&  INCLUDE: Driver.xsi
\&
\&  MODULE = DBD::Driver    PACKAGE = DBD::Driver::dr
\&
\&  /* Non\-standard drh XS methods following here, if any.       */
\&  /* If none (the usual case), omit the MODULE line above too. */
\&
\&  MODULE = DBD::Driver    PACKAGE = DBD::Driver::db
\&
\&  /* Non\-standard dbh XS methods following here, if any.       */
\&  /* Currently this includes things like _list_tables from     */
\&  /* DBD::mSQL and DBD::mysql.                                 */
\&
\&  MODULE = DBD::Driver    PACKAGE = DBD::Driver::st
\&
\&  /* Non\-standard sth XS methods following here, if any.       */
\&  /* In particular this includes things like _list_fields from */
\&  /* DBD::mSQL and DBD::mysql for accessing metadata.          */
.Ve
.PP
Note especially the include of \fIDriver.xsi\fR here: \fB\s-1DBI\s0\fR inserts stub
functions for almost all private methods here which will typically do
much work for you.
.PP
Wherever you really have to implement something, it will call a private
function in \fIdbdimp.c\fR, and this is what you have to implement.
.PP
You need to set up an extra routine if your driver needs to export
constants of its own, analogous to the \s-1SQL\s0 types available when you say:
.PP
.Vb 1
\&  use DBI qw(:sql_types);
\&
\& *FIX ME* T.B.S
.Ve
.SS "Driver.h"
.IX Subsection "Driver.h"
\&\fIDriver.h\fR is very simple and the operational contents should look like this:
.PP
.Vb 2
\&  #ifndef DRIVER_H_INCLUDED
\&  #define DRIVER_H_INCLUDED
\&
\&  #define NEED_DBIXS_VERSION 93    /* 93 for DBI versions 1.00 to 1.51+ */
\&  #define PERL_NO_GET_CONTEXT      /* if used require DBI 1.51+ */
\&
\&  #include <DBIXS.h>      /* installed by the DBI module  */
\&
\&  #include "dbdimp.h"
\&
\&  #include "dbivport.h"   /* see below                    */
\&
\&  #include <dbd_xsh.h>    /* installed by the DBI module  */
\&
\&  #endif /* DRIVER_H_INCLUDED */
.Ve
.PP
The \fI\s-1DBIXS\s0.h\fR header defines most of the interesting information that
the writer of a driver needs.
.PP
The file \fIdbd_xsh.h\fR header provides prototype declarations for the C
functions that you might decide to implement. Note that you should
normally only define one of \f(CW\*(C`dbd_db_login()\*(C'\fR, \f(CW\*(C`dbd_db_login6()\*(C'\fR or
\&\f(CW\*(C`dbd_db_login6_sv\*(C'\fR unless you are intent on supporting really old
versions of \fB\s-1DBI\s0\fR (prior to \fB\s-1DBI\s0\fR 1.06) as well as modern
versions. The only standard, \fB\s-1DBI\s0\fR\-mandated functions that you need
write are those specified in the \fIdbd_xsh.h\fR header. You might also
add extra driver-specific functions in \fIDriver.xs\fR.
.PP
The \fIdbivport.h\fR file should be \fIcopied\fR from the latest \fB\s-1DBI\s0\fR release
into your distribution each time you modify your driver. Its job is to
allow you to enhance your code to work with the latest \fB\s-1DBI\s0\fR \s-1API\s0 while
still allowing your driver to be compiled and used with older versions
of the \fB\s-1DBI\s0\fR (for example, when the \f(CW\*(C`DBIh_SET_ERR_CHAR()\*(C'\fR macro was added
to \fB\s-1DBI\s0\fR 1.41, an emulation of it was added to \fIdbivport.h\fR). This makes
users happy and your life easier. Always read the notes in \fIdbivport.h\fR
to check for any limitations in the emulation that you should be aware
of.
.PP
With \fB\s-1DBI\s0\fR v1.51 or better I recommend that the driver defines
\&\fI\s-1PERL_NO_GET_CONTEXT\s0\fR before \fI\s-1DBIXS\s0.h\fR is included. This can significantly
improve efficiency when running under a thread enabled perl. (Remember that
the standard perl in most Linux distributions is built with threads enabled.
So is ActiveState perl for Windows, and perl built for Apache mod_perl2.)
If you do this there are some things to keep in mind:
.IP "\(bu" 4
If \fI\s-1PERL_NO_GET_CONTEXT\s0\fR is defined, then every function that calls the Perl
\&\s-1API\s0 will need to start out with a \f(CW\*(C`dTHX;\*(C'\fR declaration.
.IP "\(bu" 4
You'll know which functions need this, because the C compiler will
complain that the undeclared identifier \f(CW\*(C`my_perl\*(C'\fR is used if \fIand only if\fR
the perl you are using to develop and test your driver has threads enabled.
.IP "\(bu" 4
If you don't remember to test with a thread-enabled perl before making
a release it's likely that you'll get failure reports from users who are.
.IP "\(bu" 4
For driver private functions it is possible to gain even more
efficiency by replacing \f(CW\*(C`dTHX;\*(C'\fR with \f(CW\*(C`pTHX_\*(C'\fR prepended to the
parameter list and then \f(CW\*(C`aTHX_\*(C'\fR prepended to the argument list where
the function is called.
.PP
See \*(L"How multiple interpreters and concurrency are supported\*(R" in perlguts for
additional information about \fI\s-1PERL_NO_GET_CONTEXT\s0\fR.
.SS "Implementation header dbdimp.h"
.IX Subsection "Implementation header dbdimp.h"
This header file has two jobs:
.PP
First it defines data structures for your private part of the handles.
.PP
Second it defines macros that rename the generic names like
\&\f(CW\*(C`dbd_db_login()\*(C'\fR to database specific names like \f(CW\*(C`ora_db_login()\*(C'\fR. This
avoids name clashes and enables use of different drivers when you work
with a statically linked perl.
.PP
It also will have the important task of disabling \s-1XS\s0 methods that you
don't want to implement.
.PP
Finally, the macros will also be used to select alternate
implementations of some functions. For example, the \f(CW\*(C`dbd_db_login()\*(C'\fR
function is not passed the attribute hash.
.PP
Since \fB\s-1DBI\s0\fR v1.06, if a \f(CW\*(C`dbd_db_login6()\*(C'\fR macro is defined (for a function
with 6 arguments), it will be used instead with the attribute hash
passed as the sixth argument.
.PP
Since \fB\s-1DBI\s0\fR post v1.607, if a \f(CW\*(C`dbd_db_login6_sv()\*(C'\fR macro is defined (for
a function like dbd_db_login6 but with scalar pointers for the dbname,
username and password), it will be used instead. This will allow your
login6 function to see if there are any Unicode characters in the
dbname.
.PP
People used to just pick Oracle's \fIdbdimp.c\fR and use the same names,
structures and types. I strongly recommend against that. At first glance
this saves time, but your implementation will be less readable. It was
just hell when I had to separate \fB\s-1DBI\s0\fR specific parts, Oracle specific
parts, mSQL specific parts and mysql specific parts in \fBDBD::mysql\fR's
\&\fIdbdimp.h\fR and \fIdbdimp.c\fR. (\fBDBD::mysql\fR was a port of \fBDBD::mSQL\fR
which was based on \fBDBD::Oracle\fR.) [Seconded, based on the experience
taking \fBDBD::Informix\fR apart, even though the version inherited in 1996
was only based on \fBDBD::Oracle\fR.]
.PP
This part of the driver is \fIyour exclusive part\fR. Rewrite it from
scratch, so it will be clean and short: in other words, a better piece
of code. (Of course keep an eye on other people's work.)
.PP
.Vb 4
\&  struct imp_drh_st {
\&      dbih_drc_t com;           /* MUST be first element in structure   */
\&      /* Insert your driver handle attributes here */
\&  };
\&
\&  struct imp_dbh_st {
\&      dbih_dbc_t com;           /* MUST be first element in structure   */
\&      /* Insert your database handle attributes here */
\&  };
\&
\&  struct imp_sth_st {
\&      dbih_stc_t com;           /* MUST be first element in structure   */
\&      /* Insert your statement handle attributes here */
\&  };
\&
\&  /*  Rename functions for avoiding name clashes; prototypes are  */
\&  /*  in dbd_xsh.h                                                */
\&  #define dbd_init            drv_dr_init
\&  #define dbd_db_login6_sv    drv_db_login_sv
\&  #define dbd_db_do           drv_db_do
\&  ... many more here ...
.Ve
.PP
These structures implement your private part of the handles.
.PP
You \fIhave\fR to use the name \f(CW\*(C`imp_dbh_{dr|db|st}\*(C'\fR and the first field
\&\fImust\fR be of type \fIdbih_drc_t|_dbc_t|_stc_t\fR and \fImust\fR be called
\&\f(CW\*(C`com\*(C'\fR.
.PP
You should never access these fields directly, except by using the
\&\fI\fIDBIc_xxx()\fI\fR macros below.
.SS "Implementation source dbdimp.c"
.IX Subsection "Implementation source dbdimp.c"
Conventionally, \fIdbdimp.c\fR is the main implementation file (but
\&\fBDBD::Informix\fR calls the file \fIdbdimp.ec\fR). This section includes a
short note on each function that is used in the \fIDriver.xsi\fR template
and thus \fIhas\fR to be implemented.
.PP
Of course, you will probably also need to implement other support
functions, which should usually be file static if they are placed in
\&\fIdbdimp.c\fR. If they are placed in other files, you need to list those
files in \fIMakefile.PL\fR (and \fI\s-1MANIFEST\s0\fR) to handle them correctly.
.PP
It is wise to adhere to a namespace convention for your functions to
avoid conflicts. For example, for a driver with prefix \fIdrv_\fR, you
might call externally visible functions \fIdbd_drv_xxxx\fR. You should also
avoid non-constant global variables as much as possible to improve the
support for threading.
.PP
Since Perl requires support for function prototypes (\s-1ANSI\s0 or \s-1ISO\s0 or
Standard C), you should write your code using function prototypes too.
.PP
It is possible to use either the unmapped names such as \f(CW\*(C`dbd_init()\*(C'\fR or
the mapped names such as \f(CW\*(C`dbd_ix_dr_init()\*(C'\fR in the \fIdbdimp.c\fR file.
\&\fBDBD::Informix\fR uses the mapped names which makes it easier to identify
where to look for linkage problems at runtime (which will report errors
using the mapped names).
.PP
Most other drivers, and in particular \fBDBD::Oracle\fR, use the unmapped
names in the source code which makes it a little easier to compare code
between drivers and eases discussions on the \fIdbi-dev\fR mailing list.
The majority of the code fragments here will use the unmapped names.
.PP
Ultimately, you should provide implementations for most of the
functions listed in the \fIdbd_xsh.h\fR header. The exceptions are
optional functions (such as \f(CW\*(C`dbd_st_rows()\*(C'\fR) and those functions with
alternative signatures, such as \f(CW\*(C`dbd_db_login6_sv\*(C'\fR,
\&\f(CW\*(C`dbd_db_login6()\*(C'\fR and \fI\fIdbd_db_login()\fI\fR. Then you should only
implement one of the alternatives, and generally the newer one of the
alternatives.
.PP
\fIThe dbd_init method\fR
.IX Subsection "The dbd_init method"
.PP
.Vb 1
\&  #include "Driver.h"
\&
\&  DBISTATE_DECLARE;
\&
\&  void dbd_init(dbistate_t* dbistate)
\&  {
\&      DBISTATE_INIT;  /*  Initialize the DBI macros  */
\&  }
.Ve
.PP
The \f(CW\*(C`dbd_init()\*(C'\fR function will be called when your driver is first
loaded; the bootstrap command in \f(CW\*(C`DBD::Driver::dr::driver()\*(C'\fR triggers this,
and the call is generated in the \fI\s-1BOOT\s0\fR section of \fIDriver.xst\fR.
These statements are needed to allow your driver to use the \fB\s-1DBI\s0\fR macros.
They will include your private header file \fIdbdimp.h\fR in turn.
Note that \fI\s-1DBISTATE_INIT\s0\fR requires the name of the argument to \f(CW\*(C`dbd_init()\*(C'\fR
to be called \f(CW\*(C`dbistate()\*(C'\fR.
.PP
\fIThe dbd_drv_error method\fR
.IX Subsection "The dbd_drv_error method"
.PP
You need a function to record errors so \fB\s-1DBI\s0\fR can access them properly.
You can call it whatever you like, but we'll call it \f(CW\*(C`dbd_drv_error()\*(C'\fR
here.
.PP
The argument list depends on your database software; different systems
provide different ways to get at error information.
.PP
.Vb 2
\&  static void dbd_drv_error(SV *h, int rc, const char *what)
\&  {
.Ve
.PP
Note that \fIh\fR is a generic handle, may it be a driver handle, a
database or a statement handle.
.PP
.Vb 1
\&      D_imp_xxh(h);
.Ve
.PP
This macro will declare and initialize a variable \fIimp_xxh\fR with
a pointer to your private handle pointer. You may cast this to
to \fIimp_drh_t\fR, \fIimp_dbh_t\fR or \fIimp_sth_t\fR.
.PP
To record the error correctly, equivalent to the \f(CW\*(C`set_err()\*(C'\fR method,
use one of the \f(CW\*(C`DBIh_SET_ERR_CHAR(...)\*(C'\fR or \f(CW\*(C`DBIh_SET_ERR_SV(...)\*(C'\fR macros,
which were added in \fB\s-1DBI\s0\fR 1.41:
.PP
.Vb 2
\&  DBIh_SET_ERR_SV(h, imp_xxh, err, errstr, state, method);
\&  DBIh_SET_ERR_CHAR(h, imp_xxh, err_c, err_i, errstr, state, method);
.Ve
.PP
For \f(CW\*(C`DBIh_SET_ERR_SV\*(C'\fR the \fIerr\fR, \fIerrstr\fR, \fIstate\fR, and \fImethod\fR
parameters are \f(CW\*(C`SV*\*(C'\fR (use &sv_undef instead of \s-1NULL\s0).
.PP
For \f(CW\*(C`DBIh_SET_ERR_CHAR\*(C'\fR the \fIerr_c\fR, \fIerrstr\fR, \fIstate\fR, \fImethod\fR
parameters are \f(CW\*(C`char*\*(C'\fR.
.PP
The \fIerr_i\fR parameter is an \f(CW\*(C`IV\*(C'\fR that's used instead of \fIerr_c\fR if
\&\fIerr_c\fR is \f(CW\*(C`Null\*(C'\fR.
.PP
The \fImethod\fR parameter can be ignored.
.PP
The \f(CW\*(C`DBIh_SET_ERR_CHAR\*(C'\fR macro is usually the simplest to use when you
just have an integer error code and an error message string:
.PP
.Vb 1
\&  DBIh_SET_ERR_CHAR(h, imp_xxh, Nullch, rc, what, Nullch, Nullch);
.Ve
.PP
As you can see, any parameters that aren't relevant to you can be \f(CW\*(C`Null\*(C'\fR.
.PP
To make drivers compatible with \fB\s-1DBI\s0\fR < 1.41 you should be using \fIdbivport.h\fR
as described in \*(L"Driver.h\*(R" above.
.PP
The (obsolete) macros such as \f(CW\*(C`DBIh_EVENT2\*(C'\fR should be removed from drivers.
.PP
The names \f(CW\*(C`dbis\*(C'\fR and \f(CW\*(C`DBIS\*(C'\fR, which were used in previous versions of
this document, should be replaced with the \f(CW\*(C`DBIc_DBISTATE(imp_xxh)\*(C'\fR macro.
.PP
The name \f(CW\*(C`DBILOGFP\*(C'\fR, which was also used in previous versions of this
document, should be replaced by \f(CW\*(C`DBIc_LOGPIO(imp_xxh)\*(C'\fR.
.PP
Your code should not call the C \f(CW\*(C`<stdio.h>\*(C'\fR I/O functions; you
should use \f(CW\*(C`PerlIO_printf()\*(C'\fR as shown:
.PP
.Vb 3
\&      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
\&          PerlIO_printf(DBIc_LOGPIO(imp_xxh), "foobar %s: %s\en",
\&              foo, neatsvpv(errstr,0));
.Ve
.PP
That's the first time we see how tracing works within a \fB\s-1DBI\s0\fR driver. Make
use of this as often as you can, but don't output anything at a trace
level less than 3. Levels 1 and 2 are reserved for the \fB\s-1DBI\s0\fR.
.PP
You can define up to 8 private trace flags using the top 8 bits
of \f(CW\*(C`DBIc_TRACE_FLAGS(imp)\*(C'\fR, that is: \f(CW0xFF000000\fR. See the
\&\f(CW\*(C`parse_trace_flag()\*(C'\fR method elsewhere in this document.
.PP
\fIThe dbd_dr_data_sources method\fR
.IX Subsection "The dbd_dr_data_sources method"
.PP
This method is optional; the support for it was added in \fB\s-1DBI\s0\fR v1.33.
.PP
As noted in the discussion of \fIDriver.pm\fR, if the data sources
can be determined by pure Perl code, do it that way. If, as in
\&\fBDBD::Informix\fR, the information is obtained by a C function call, then
you need to define a function that matches the prototype:
.PP
.Vb 1
\&  extern AV *dbd_dr_data_sources(SV *drh, imp_drh_t *imp_drh, SV *attrs);
.Ve
.PP
An outline implementation for \fBDBD::Informix\fR follows, assuming that the
\&\f(CW\*(C`sqgetdbs()\*(C'\fR function call shown will return up to 100 databases names,
with the pointers to each name in the array dbsname and the name strings
themselves being stores in dbsarea.
.PP
.Vb 7
\&  AV *dbd_dr_data_sources(SV *drh, imp_drh_t *imp_drh, SV *attr)
\&  {
\&      int ndbs;
\&      int i;
\&      char *dbsname[100];
\&      char  dbsarea[10000];
\&      AV *av = Nullav;
\&
\&      if (sqgetdbs(&ndbs, dbsname, 100, dbsarea, sizeof(dbsarea)) == 0)
\&      {
\&          av = NewAV();
\&          av_extend(av, (I32)ndbs);
\&          sv_2mortal((SV *)av);
\&          for (i = 0; i < ndbs; i++)
\&            av_store(av, i, newSVpvf("dbi:Informix:%s", dbsname[i]));
\&      }
\&      return(av);
\&  }
.Ve
.PP
The actual \fBDBD::Informix\fR implementation has a number of extra lines of
code, logs function entry and exit, reports the error from \f(CW\*(C`sqgetdbs()\*(C'\fR,
and uses \f(CW\*(C`#define\*(C'\fR'd constants for the array sizes.
.PP
\fIThe dbd_db_login6 method\fR
.IX Subsection "The dbd_db_login6 method"
.PP
.Vb 2
\&  int dbd_db_login6_sv(SV* dbh, imp_dbh_t* imp_dbh, SV* dbname,
\&                       SV* user, SV* auth, SV *attr);
\&
\&  or
\&
\&  int dbd_db_login6(SV* dbh, imp_dbh_t* imp_dbh, char* dbname,
\&                   char* user, char* auth, SV *attr);
.Ve
.PP
This function will really connect to the database. The argument \fIdbh\fR
is the database handle. \fIimp_dbh\fR is the pointer to the handles private
data, as is \fIimp_xxx\fR in \f(CW\*(C`dbd_drv_error()\*(C'\fR above. The arguments
\&\fIdbname\fR, \fIuser\fR, \fIauth\fR and \fIattr\fR correspond to the arguments of
the driver handle's \f(CW\*(C`connect()\*(C'\fR method.
.PP
You will quite often use database specific attributes here, that are
specified in the \s-1DSN\s0. I recommend you parse the \s-1DSN\s0 (using Perl) within
the \f(CW\*(C`connect()\*(C'\fR method and pass the segments of the \s-1DSN\s0 via the
attributes parameter through \f(CW\*(C`_login()\*(C'\fR to \f(CW\*(C`dbd_db_login6()\*(C'\fR.
.PP
Here's how you fetch them; as an example we use \fIhostname\fR attribute,
which can be up to 12 characters long excluding null terminator:
.PP
.Vb 3
\&  SV** svp;
\&  STRLEN len;
\&  char* hostname;
\&
\&  if ( (svp = DBD_ATTRIB_GET_SVP(attr, "drv_hostname", 12)) && SvTRUE(*svp)) {
\&      hostname = SvPV(*svp, len);
\&      DBD_ATTRIB_DELETE(attr, "drv_hostname", 12); /* avoid later STORE */
\&  } else {
\&      hostname = "localhost";
\&  }
.Ve
.PP
If you handle any driver specific attributes in the dbd_db_login6
method you probably want to delete them from \f(CW\*(C`attr\*(C'\fR (as above with
\&\s-1DBD_ATTRIB_DELETE\s0). If you don't delete your handled attributes \s-1DBI\s0
will call \f(CW\*(C`STORE\*(C'\fR for each attribute after the connect/login and this
is at best redundant for attributes you have already processed.
.PP
\&\fBNote: Until revision 11605 (post \s-1DBI\s0 1.607), there was a problem with
\&\s-1DBD_ATTRIBUTE_DELETE\s0 so unless you require a \s-1DBI\s0 version after 1.607
you need to replace each \s-1DBD_ATTRIBUTE_DELETE\s0 call with:\fR
.PP
.Vb 1
\&  hv_delete((HV*)SvRV(attr), key, key_len, G_DISCARD)
.Ve
.PP
Note that you can also obtain standard attributes such as \fIAutoCommit\fR and
\&\fIChopBlanks\fR from the attributes parameter, using \f(CW\*(C`DBD_ATTRIB_GET_IV\*(C'\fR for
integer attributes.
.PP
If, for example, your database does not support transactions but
\&\fIAutoCommit\fR is set off (requesting transaction support), then you can
emulate a 'failure to connect'.
.PP
Now you should really connect to the database. In general, if the
connection fails, it is best to ensure that all allocated resources are
released so that the handle does not need to be destroyed separately. If
you are successful (and possibly even if you fail but you have allocated
some resources), you should use the following macros:
.PP
.Vb 1
\&  DBIc_IMPSET_on(imp_dbh);
.Ve
.PP
This indicates that the driver (implementor) has allocated resources in
the \fIimp_dbh\fR structure and that the implementors private \f(CW\*(C`dbd_db_destroy()\*(C'\fR
function should be called when the handle is destroyed.
.PP
.Vb 1
\&  DBIc_ACTIVE_on(imp_dbh);
.Ve
.PP
This indicates that the handle has an active connection to the server
and that the \f(CW\*(C`dbd_db_disconnect()\*(C'\fR function should be called before the
handle is destroyed.
.PP
Note that if you do need to fail, you should report errors via the \fIdrh\fR
or \fIimp_drh\fR rather than via \fIdbh\fR or \fIimp_dbh\fR because \fIimp_dbh\fR will be
destroyed by the failure, so errors recorded in that handle will not be
visible to \fB\s-1DBI\s0\fR, and hence not the user either.
.PP
Note too, that the function is passed \fIdbh\fR and \fIimp_dbh\fR, and there
is a macro \f(CW\*(C`D_imp_drh_from_dbh\*(C'\fR which can recover the \fIimp_drh\fR from
the \fIimp_dbh\fR. However, there is no \fB\s-1DBI\s0\fR macro to provide you with the
\&\fIdrh\fR given either the \fIimp_dbh\fR or the \fIdbh\fR or the \fIimp_drh\fR (and
there's no way to recover the \fIdbh\fR given just the \fIimp_dbh\fR).
.PP
This suggests that, despite the above notes about \f(CW\*(C`dbd_drv_error()\*(C'\fR
taking an \f(CW\*(C`SV *\*(C'\fR, it may be better to have two error routines, one
taking \fIimp_dbh\fR and one taking \fIimp_drh\fR instead. With care, you can
factor most of the formatting code out so that these are small routines
calling a common error formatter. See the code in \fBDBD::Informix\fR
1.05.00 for more information.
.PP
The \f(CW\*(C`dbd_db_login6()\*(C'\fR function should return \fI\s-1TRUE\s0\fR for success,
\&\fI\s-1FALSE\s0\fR otherwise.
.PP
Drivers implemented long ago may define the five-argument function
\&\f(CW\*(C`dbd_db_login()\*(C'\fR instead of \f(CW\*(C`dbd_db_login6()\*(C'\fR. The missing argument is
the attributes. There are ways to work around the missing attributes,
but they are ungainly; it is much better to use the 6\-argument form.
Even later drivers will use \f(CW\*(C`dbd_db_login6_sv()\*(C'\fR which provides the
dbname, username and password as SVs.
.PP
\fIThe dbd_db_commit and dbd_db_rollback methods\fR
.IX Subsection "The dbd_db_commit and dbd_db_rollback methods"
.PP
.Vb 2
\&  int dbd_db_commit(SV *dbh, imp_dbh_t *imp_dbh);
\&  int dbd_db_rollback(SV* dbh, imp_dbh_t* imp_dbh);
.Ve
.PP
These are used for commit and rollback. They should return \fI\s-1TRUE\s0\fR for
success, \fI\s-1FALSE\s0\fR for error.
.PP
The arguments \fIdbh\fR and \fIimp_dbh\fR are the same as for \f(CW\*(C`dbd_db_login6()\*(C'\fR
above; I will omit describing them in what follows, as they appear
always.
.PP
These functions should return \fI\s-1TRUE\s0\fR for success, \fI\s-1FALSE\s0\fR otherwise.
.PP
\fIThe dbd_db_disconnect method\fR
.IX Subsection "The dbd_db_disconnect method"
.PP
This is your private part of the \f(CW\*(C`disconnect()\*(C'\fR method. Any \fIdbh\fR with
the \fI\s-1ACTIVE\s0\fR flag on must be disconnected. (Note that you have to set
it in \f(CW\*(C`dbd_db_connect()\*(C'\fR above.)
.PP
.Vb 1
\&  int dbd_db_disconnect(SV* dbh, imp_dbh_t* imp_dbh);
.Ve
.PP
The database handle will return \fI\s-1TRUE\s0\fR for success, \fI\s-1FALSE\s0\fR otherwise.
In any case it should do a:
.PP
.Vb 1
\&  DBIc_ACTIVE_off(imp_dbh);
.Ve
.PP
before returning so \fB\s-1DBI\s0\fR knows that \f(CW\*(C`dbd_db_disconnect()\*(C'\fR was executed.
.PP
Note that there's nothing to stop a \fIdbh\fR being \fIdisconnected\fR while
it still have active children. If your database \s-1API\s0 reacts badly to
trying to use an \fIsth\fR in this situation then you'll need to add code
like this to all \fIsth\fR methods:
.PP
.Vb 2
\&  if (!DBIc_ACTIVE(DBIc_PARENT_COM(imp_sth)))
\&    return 0;
.Ve
.PP
Alternatively, you can add code to your driver to keep explicit track of
the statement handles that exist for each database handle and arrange
to destroy those handles before disconnecting from the database. There
is code to do this in \fBDBD::Informix\fR. Similar comments apply to the
driver handle keeping track of all the database handles.
.PP
Note that the code which destroys the subordinate handles should only
release the associated database resources and mark the handles inactive;
it does not attempt to free the actual handle structures.
.PP
This function should return \fI\s-1TRUE\s0\fR for success, \fI\s-1FALSE\s0\fR otherwise, but
it is not clear what anything can do about a failure.
.PP
\fIThe dbd_db_discon_all method\fR
.IX Subsection "The dbd_db_discon_all method"
.PP
.Vb 1
\&  int dbd_discon_all (SV *drh, imp_drh_t *imp_drh);
.Ve
.PP
This function may be called at shutdown time. It should make
best-efforts to disconnect all database handles \- if possible. Some
databases don't support that, in which case you can do nothing
but return 'success'.
.PP
This function should return \fI\s-1TRUE\s0\fR for success, \fI\s-1FALSE\s0\fR otherwise, but
it is not clear what anything can do about a failure.
.PP
\fIThe dbd_db_destroy method\fR
.IX Subsection "The dbd_db_destroy method"
.PP
This is your private part of the database handle destructor. Any \fIdbh\fR with
the \fI\s-1IMPSET\s0\fR flag on must be destroyed, so that you can safely free
resources. (Note that you have to set it in \f(CW\*(C`dbd_db_connect()\*(C'\fR above.)
.PP
.Vb 4
\&  void dbd_db_destroy(SV* dbh, imp_dbh_t* imp_dbh)
\&  {
\&      DBIc_IMPSET_off(imp_dbh);
\&  }
.Ve
.PP
The \fB\s-1DBI\s0\fR \fIDriver.xst\fR code will have called \f(CW\*(C`dbd_db_disconnect()\*(C'\fR for you,
if the handle is still 'active', before calling \f(CW\*(C`dbd_db_destroy()\*(C'\fR.
.PP
Before returning the function must switch \fI\s-1IMPSET\s0\fR to off, so \fB\s-1DBI\s0\fR knows
that the destructor was called.
.PP
A \fB\s-1DBI\s0\fR handle doesn't keep references to its children. But children
do keep references to their parents. So a database handle won't be
\&\f(CW\*(C`DESTROY\*(C'\fR'd until all its children have been \f(CW\*(C`DESTROY\*(C'\fR'd.
.PP
\fIThe dbd_db_STORE_attrib method\fR
.IX Subsection "The dbd_db_STORE_attrib method"
.PP
This function handles
.PP
.Vb 1
\&  $dbh\->{$key} = $value;
.Ve
.PP
Its prototype is:
.PP
.Vb 2
\&  int dbd_db_STORE_attrib(SV* dbh, imp_dbh_t* imp_dbh, SV* keysv,
\&                          SV* valuesv);
.Ve
.PP
You do not handle all attributes; on the contrary, you should not handle
\&\fB\s-1DBI\s0\fR attributes here: leave this to \fB\s-1DBI\s0\fR. (There are two exceptions,
\&\fIAutoCommit\fR and \fIChopBlanks\fR, which you should care about.)
.PP
The return value is \fI\s-1TRUE\s0\fR if you have handled the attribute or \fI\s-1FALSE\s0\fR
otherwise. If you are handling an attribute and something fails, you
should call \f(CW\*(C`dbd_drv_error()\*(C'\fR, so \fB\s-1DBI\s0\fR can raise exceptions, if desired.
If \f(CW\*(C`dbd_drv_error()\*(C'\fR returns, however, you have a problem: the user will
never know about the error, because he typically will not check
\&\f(CW\*(C`$dbh\->errstr()\*(C'\fR.
.PP
I cannot recommend a general way of going on, if \f(CW\*(C`dbd_drv_error()\*(C'\fR returns,
but there are examples where even the \fB\s-1DBI\s0\fR specification expects that
you \f(CW\*(C`croak()\*(C'\fR. (See the \fIAutoCommit\fR method in \s-1DBI\s0.)
.PP
If you have to store attributes, you should either use your private
data structure \fIimp_xxx\fR, the handle hash (via \f(CW\*(C`(HV*)SvRV(dbh)\*(C'\fR), or use
the private \fIimp_data\fR.
.PP
The first is best for internal C values like integers or pointers and
where speed is important within the driver. The handle hash is best for
values the user may want to get/set via driver-specific attributes.
The private \fIimp_data\fR is an additional \f(CW\*(C`SV\*(C'\fR attached to the handle. You
could think of it as an unnamed handle attribute. It's not normally used.
.PP
\fIThe dbd_db_FETCH_attrib method\fR
.IX Subsection "The dbd_db_FETCH_attrib method"
.PP
This is the counterpart of \f(CW\*(C`dbd_db_STORE_attrib()\*(C'\fR, needed for:
.PP
.Vb 1
\&  $value = $dbh\->{$key};
.Ve
.PP
Its prototype is:
.PP
.Vb 1
\&  SV* dbd_db_FETCH_attrib(SV* dbh, imp_dbh_t* imp_dbh, SV* keysv);
.Ve
.PP
Unlike all previous methods this returns an \f(CW\*(C`SV\*(C'\fR with the value. Note
that you should normally execute \f(CW\*(C`sv_2mortal()\*(C'\fR, if you return a nonconstant
value. (Constant values are \f(CW&sv_undef\fR, \f(CW&sv_no\fR and \f(CW&sv_yes\fR.)
.PP
Note, that \fB\s-1DBI\s0\fR implements a caching algorithm for attribute values.
If you think, that an attribute may be fetched, you store it in the
\&\fIdbh\fR itself:
.PP
.Vb 2
\&  if (cacheit) /* cache value for later DBI \*(Aqquick\*(Aq fetch? */
\&      hv_store((HV*)SvRV(dbh), key, kl, cachesv, 0);
.Ve
.PP
\fIThe dbd_st_prepare method\fR
.IX Subsection "The dbd_st_prepare method"
.PP
This is the private part of the \f(CW\*(C`prepare()\*(C'\fR method. Note that you
\&\fBmust not\fR really execute the statement here. You may, however,
preparse and validate the statement, or do similar things.
.PP
.Vb 2
\&  int dbd_st_prepare(SV* sth, imp_sth_t* imp_sth, char* statement,
\&                     SV* attribs);
.Ve
.PP
A typical, simple, possibility is to do nothing and rely on the perl
\&\f(CW\*(C`prepare()\*(C'\fR code that set the \fIStatement\fR attribute on the handle. This
attribute can then be used by \f(CW\*(C`dbd_st_execute()\*(C'\fR.
.PP
If the driver supports placeholders then the \fI\s-1NUM_OF_PARAMS\s0\fR attribute
must be set correctly by \f(CW\*(C`dbd_st_prepare()\*(C'\fR:
.PP
.Vb 1
\&  DBIc_NUM_PARAMS(imp_sth) = ...
.Ve
.PP
If you can, you should also setup attributes like \fI\s-1NUM_OF_FIELDS\s0\fR, \fI\s-1NAME\s0\fR,
etc. here, but \fB\s-1DBI\s0\fR doesn't require that \- they can be deferred until
\&\fIexecute()\fR is called. However, if you do, document it.
.PP
In any case you should set the \fI\s-1IMPSET\s0\fR flag, as you did in
\&\f(CW\*(C`dbd_db_connect()\*(C'\fR above:
.PP
.Vb 1
\&  DBIc_IMPSET_on(imp_sth);
.Ve
.PP
\fIThe dbd_st_execute method\fR
.IX Subsection "The dbd_st_execute method"
.PP
This is where a statement will really be executed.
.PP
.Vb 1
\&  int dbd_st_execute(SV* sth, imp_sth_t* imp_sth);
.Ve
.PP
\&\f(CW\*(C`dbd_st_execute\*(C'\fR should return \-2 for any error, \-1 if the number of
rows affected is unknown else it should be the number of affected
(updated, inserted) rows.
.PP
Note that you must be aware a statement may be executed repeatedly.
Also, you should not expect that \f(CW\*(C`finish()\*(C'\fR will be called between two
executions, so you might need code, like the following, near the start
of the function:
.PP
.Vb 2
\&  if (DBIc_ACTIVE(imp_sth))
\&      dbd_st_finish(h, imp_sth);
.Ve
.PP
If your driver supports the binding of parameters (it should!), but the
database doesn't, you must do it here. This can be done as follows:
.PP
.Vb 4
\&  SV *svp;
\&  char* statement = DBD_ATTRIB_GET_PV(h, "Statement", 9, svp, "");
\&  int numParam = DBIc_NUM_PARAMS(imp_sth);
\&  int i;
\&
\&  for (i = 0; i < numParam; i++)
\&  {
\&      char* value = dbd_db_get_param(sth, imp_sth, i);
\&      /* It is your drivers task to implement dbd_db_get_param,    */
\&      /* it must be setup as a counterpart of dbd_bind_ph.         */
\&      /* Look for \*(Aq?\*(Aq and replace it with \*(Aqvalue\*(Aq.  Difficult      */
\&      /* task, note that you may have question marks inside        */
\&      /* quotes and comments the like ...  :\-(                     */
\&      /* See DBD::mysql for an example. (Don\*(Aqt look too deep into  */
\&      /* the example, you will notice where I was lazy ...)        */
\&  }
.Ve
.PP
The next thing is to really execute the statement.
.PP
Note that you must set the attributes \fI\s-1NUM_OF_FIELDS\s0\fR, \fI\s-1NAME\s0\fR, etc
when the statement is successfully executed if the driver has not
already done so: they may be used even before a potential \f(CW\*(C`fetchrow()\*(C'\fR.
In particular you have to tell \fB\s-1DBI\s0\fR the number of fields that the
statement has, because it will be used by \fB\s-1DBI\s0\fR internally. Thus the
function will typically ends with:
.PP
.Vb 4
\&  if (isSelectStatement) {
\&      DBIc_NUM_FIELDS(imp_sth) = numFields;
\&      DBIc_ACTIVE_on(imp_sth);
\&  }
.Ve
.PP
It is important that the \fI\s-1ACTIVE\s0\fR flag only be set for \f(CW\*(C`SELECT\*(C'\fR
statements (or any other statements that can return many
values from the database using a cursor-like mechanism). See
\&\f(CW\*(C`dbd_db_connect()\*(C'\fR above for more explanations.
.PP
There plans for a preparse function to be provided by \fB\s-1DBI\s0\fR, but this has
not reached fruition yet.
Meantime, if you want to know how ugly it can get, try looking at the
\&\f(CW\*(C`dbd_ix_preparse()\*(C'\fR in \fBDBD::Informix\fR \fIdbdimp.ec\fR and the related
functions in \fIiustoken.c\fR and \fIsqltoken.c\fR.
.PP
\fIThe dbd_st_fetch method\fR
.IX Subsection "The dbd_st_fetch method"
.PP
This function fetches a row of data. The row is stored in in an array,
of \f(CW\*(C`SV\*(C'\fR's that \fB\s-1DBI\s0\fR prepares for you. This has two advantages: it is fast
(you even reuse the \f(CW\*(C`SV\*(C'\fR's, so they don't have to be created after the
first \f(CW\*(C`fetchrow()\*(C'\fR), and it guarantees that \fB\s-1DBI\s0\fR handles \f(CW\*(C`bind_cols()\*(C'\fR for
you.
.PP
What you do is the following:
.PP
.Vb 6
\&  AV* av;
\&  int numFields = DBIc_NUM_FIELDS(imp_sth); /* Correct, if NUM_FIELDS
\&      is constant for this statement. There are drivers where this is
\&      not the case! */
\&  int chopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);
\&  int i;
\&
\&  if (!fetch_new_row_of_data(...)) {
\&      ... /* check for error or end\-of\-data */
\&      DBIc_ACTIVE_off(imp_sth); /* turn off Active flag automatically */
\&      return Nullav;
\&  }
\&  /* get the fbav (field buffer array value) for this row       */
\&  /* it is very important to only call this after you know      */
\&  /* that you have a row of data to return.                     */
\&  av = DBIc_DBISTATE(imp_sth)\->get_fbav(imp_sth);
\&  for (i = 0; i < numFields; i++) {
\&      SV* sv = fetch_a_field(..., i);
\&      if (chopBlanks && SvOK(sv) && type_is_blank_padded(field_type[i])) {
\&          /*  Remove white space from end (only) of sv  */
\&      }
\&      sv_setsv(AvARRAY(av)[i], sv); /* Note: (re)use! */
\&  }
\&  return av;
.Ve
.PP
There's no need to use a \f(CW\*(C`fetch_a_field()\*(C'\fR function returning an \f(CW\*(C`SV*\*(C'\fR.
It's more common to use your database \s-1API\s0 functions to fetch the
data as character strings and use code like this:
.PP
.Vb 1
\&  sv_setpvn(AvARRAY(av)[i], char_ptr, char_count);
.Ve
.PP
\&\f(CW\*(C`NULL\*(C'\fR values must be returned as \f(CW\*(C`undef\*(C'\fR. You can use code like this:
.PP
.Vb 1
\&  SvOK_off(AvARRAY(av)[i]);
.Ve
.PP
The function returns the \f(CW\*(C`AV\*(C'\fR prepared by \fB\s-1DBI\s0\fR for success or \f(CW\*(C`Nullav\*(C'\fR
otherwise.
.PP
.Vb 3
\& *FIX ME* Discuss what happens when there\*(Aqs no more data to fetch.
\& Are errors permitted if another fetch occurs after the first fetch
\& that reports no more data. (Permitted, not required.)
.Ve
.PP
If an error occurs which leaves the \fI\f(CI$sth\fI\fR in a state where remaining
rows can't be fetched then \fIActive\fR should be turned off before the
method returns.
.PP
\fIThe dbd_st_finish3 method\fR
.IX Subsection "The dbd_st_finish3 method"
.PP
The \f(CW\*(C`$sth\->finish()\*(C'\fR method can be called if the user wishes to
indicate that no more rows will be fetched even if the database has more
rows to offer, and the \fB\s-1DBI\s0\fR code can call the function when handles are
being destroyed. See the \fB\s-1DBI\s0\fR specification for more background details.
.PP
In both circumstances, the \fB\s-1DBI\s0\fR code ends up calling the
\&\f(CW\*(C`dbd_st_finish3()\*(C'\fR method (if you provide a mapping for
\&\f(CW\*(C`dbd_st_finish3()\*(C'\fR in \fIdbdimp.h\fR), or \f(CW\*(C`dbd_st_finish()\*(C'\fR otherwise.
The difference is that \f(CW\*(C`dbd_st_finish3()\*(C'\fR takes a third argument which
is an \f(CW\*(C`int\*(C'\fR with the value 1 if it is being called from a \f(CW\*(C`destroy()\*(C'\fR
method and 0 otherwise.
.PP
Note that \fB\s-1DBI\s0\fR v1.32 and earlier test on \f(CW\*(C`dbd_db_finish3()\*(C'\fR to call
\&\f(CW\*(C`dbd_st_finish3()\*(C'\fR; if you provide \f(CW\*(C`dbd_st_finish3()\*(C'\fR, either define
\&\f(CW\*(C`dbd_db_finish3()\*(C'\fR too, or insist on \fB\s-1DBI\s0\fR v1.33 or later.
.PP
All it \fIneeds\fR to do is turn off the \fIActive\fR flag for the \fIsth\fR.
It will only be called by \fIDriver.xst\fR code, if the driver has set \fI\s-1ACTIVE\s0\fR
to on for the \fIsth\fR.
.PP
Outline example:
.PP
.Vb 8
\&  int dbd_st_finish3(SV* sth, imp_sth_t* imp_sth, int from_destroy) {
\&      if (DBIc_ACTIVE(imp_sth))
\&      {
\&          /* close cursor or equivalent action */
\&          DBIc_ACTIVE_off(imp_sth);
\&      }
\&      return 1;
\&  }
.Ve
.PP
The from_destroy parameter is true if \f(CW\*(C`dbd_st_finish3()\*(C'\fR is being called
from \f(CW\*(C`DESTROY()\*(C'\fR \- and so the statement is about to be destroyed.
For many drivers there is no point in doing anything more than turning off
the \fIActive\fR flag in this case.
.PP
The function returns \fI\s-1TRUE\s0\fR for success, \fI\s-1FALSE\s0\fR otherwise, but there isn't
a lot anyone can do to recover if there is an error.
.PP
\fIThe dbd_st_destroy method\fR
.IX Subsection "The dbd_st_destroy method"
.PP
This function is the private part of the statement handle destructor.
.PP
.Vb 4
\&  void dbd_st_destroy(SV* sth, imp_sth_t* imp_sth) {
\&      ... /* any clean\-up that\*(Aqs needed */
\&      DBIc_IMPSET_off(imp_sth); /* let DBI know we\*(Aqve done it   */
\&  }
.Ve
.PP
The \fB\s-1DBI\s0\fR \fIDriver.xst\fR code will call \f(CW\*(C`dbd_st_finish()\*(C'\fR for you, if the
\&\fIsth\fR has the \fI\s-1ACTIVE\s0\fR flag set, before calling \f(CW\*(C`dbd_st_destroy()\*(C'\fR.
.PP
\fIThe dbd_st_STORE_attrib and dbd_st_FETCH_attrib methods\fR
.IX Subsection "The dbd_st_STORE_attrib and dbd_st_FETCH_attrib methods"
.PP
These functions correspond to \f(CW\*(C`dbd_db_STORE()\*(C'\fR and \f(CW\*(C`dbd_db_FETCH()\*(C'\fR attrib
above, except that they are for statement handles.
See above.
.PP
.Vb 3
\&  int dbd_st_STORE_attrib(SV* sth, imp_sth_t* imp_sth, SV* keysv,
\&                          SV* valuesv);
\&  SV* dbd_st_FETCH_attrib(SV* sth, imp_sth_t* imp_sth, SV* keysv);
.Ve
.PP
\fIThe dbd_bind_ph method\fR
.IX Subsection "The dbd_bind_ph method"
.PP
This function is internally used by the \f(CW\*(C`bind_param()\*(C'\fR method, the
\&\f(CW\*(C`bind_param_inout()\*(C'\fR method and by the \fB\s-1DBI\s0\fR \fIDriver.xst\fR code if
\&\f(CW\*(C`execute()\*(C'\fR is called with any bind parameters.
.PP
.Vb 3
\&  int dbd_bind_ph (SV *sth, imp_sth_t *imp_sth, SV *param,
\&                   SV *value, IV sql_type, SV *attribs,
\&                   int is_inout, IV maxlen);
.Ve
.PP
The \fIparam\fR argument holds an \f(CW\*(C`IV\*(C'\fR with the parameter number (1, 2, ...).
The \fIvalue\fR argument is the parameter value and \fIsql_type\fR is its type.
.PP
If your driver does not support \f(CW\*(C`bind_param_inout()\*(C'\fR then you should
ignore \fImaxlen\fR and croak if \fIis_inout\fR is \fI\s-1TRUE\s0\fR.
.PP
If your driver \fIdoes\fR support \f(CW\*(C`bind_param_inout()\*(C'\fR then you should
note that \fIvalue\fR is the \f(CW\*(C`SV\*(C'\fR \fIafter\fR dereferencing the reference
passed to \f(CW\*(C`bind_param_inout()\*(C'\fR.
.PP
In drivers of simple databases the function will, for example, store
the value in a parameter array and use it later in \f(CW\*(C`dbd_st_execute()\*(C'\fR.
See the \fBDBD::mysql\fR driver for an example.
.PP
\fIImplementing bind_param_inout support\fR
.IX Subsection "Implementing bind_param_inout support"
.PP
To provide support for parameters bound by reference rather than by
value, the driver must do a number of things.  First, and most
importantly, it must note the references and stash them in its own
driver structure.  Secondly, when a value is bound to a column, the
driver must discard any previous reference bound to the column.  On
each execute, the driver must evaluate the references and internally
bind the values resulting from the references.  This is only applicable
if the user writes:
.PP
.Vb 1
\&  $sth\->execute;
.Ve
.PP
If the user writes:
.PP
.Vb 1
\&  $sth\->execute(@values);
.Ve
.PP
then \fB\s-1DBI\s0\fR automatically calls the binding code for each element of
\&\fI\f(CI@values\fI\fR.  These calls are indistinguishable from explicit user calls to
\&\f(CW\*(C`bind_param()\*(C'\fR.
.SS "C/XS version of Makefile.PL"
.IX Subsection "C/XS version of Makefile.PL"
The \fIMakefile.PL\fR file for a C/XS driver is similar to the code needed
for a pure Perl driver, but there are a number of extra bits of
information needed by the build system.
.PP
For example, the attributes list passed to \f(CW\*(C`WriteMakefile()\*(C'\fR needs
to specify the object files that need to be compiled and built into
the shared object (\s-1DLL\s0). This is often, but not necessarily, just
\&\fIdbdimp.o\fR (unless that should be \fIdbdimp.obj\fR because you're building
on \s-1MS\s0 Windows).
.PP
Note that you can reliably determine the extension of the object files
from the \fI\f(CI$Config\fI{obj_ext}\fR values, and there are many other useful pieces
of configuration information lurking in that hash.
You get access to it with:
.PP
.Vb 1
\&    use Config;
.Ve
.SS "Methods which do not need to be written"
.IX Subsection "Methods which do not need to be written"
The \fB\s-1DBI\s0\fR code implements the majority of the methods which are accessed
using the notation \f(CW\*(C`DBI\->function()\*(C'\fR, the only exceptions being
\&\f(CW\*(C`DBI\->connect()\*(C'\fR and \f(CW\*(C`DBI\->data_sources()\*(C'\fR which require
support from the driver.
.PP
The \fB\s-1DBI\s0\fR code implements the following documented driver, database and
statement functions which do not need to be written by the \fB\s-1DBD\s0\fR driver
writer.
.ie n .IP "$dbh\->\fIdo()\fR" 4
.el .IP "\f(CW$dbh\fR\->\fIdo()\fR" 4
.IX Item "$dbh->do()"
The default implementation of this function prepares, executes and
destroys the statement.  This can be replaced if there is a better
way to implement this, such as \f(CW\*(C`EXECUTE IMMEDIATE\*(C'\fR which can
sometimes be used if there are no parameters.
.ie n .IP "$h\->\fIerrstr()\fR" 4
.el .IP "\f(CW$h\fR\->\fIerrstr()\fR" 4
.IX Item "$h->errstr()"
.PD 0
.ie n .IP "$h\->\fIerr()\fR" 4
.el .IP "\f(CW$h\fR\->\fIerr()\fR" 4
.IX Item "$h->err()"
.ie n .IP "$h\->\fIstate()\fR" 4
.el .IP "\f(CW$h\fR\->\fIstate()\fR" 4
.IX Item "$h->state()"
.ie n .IP "$h\->\fItrace()\fR" 4
.el .IP "\f(CW$h\fR\->\fItrace()\fR" 4
.IX Item "$h->trace()"
.PD
The \fB\s-1DBD\s0\fR driver does not need to worry about these routines at all.
.ie n .IP "$h\->{ChopBlanks}" 4
.el .IP "\f(CW$h\fR\->{ChopBlanks}" 4
.IX Item "$h->{ChopBlanks}"
This attribute needs to be honored during \f(CW\*(C`fetch()\*(C'\fR operations, but does
not need to be handled by the attribute handling code.
.ie n .IP "$h\->{RaiseError}" 4
.el .IP "\f(CW$h\fR\->{RaiseError}" 4
.IX Item "$h->{RaiseError}"
The \fB\s-1DBD\s0\fR driver does not need to worry about this attribute at all.
.ie n .IP "$h\->{PrintError}" 4
.el .IP "\f(CW$h\fR\->{PrintError}" 4
.IX Item "$h->{PrintError}"
The \fB\s-1DBD\s0\fR driver does not need to worry about this attribute at all.
.ie n .IP "$sth\->\fIbind_col()\fR" 4
.el .IP "\f(CW$sth\fR\->\fIbind_col()\fR" 4
.IX Item "$sth->bind_col()"
Assuming the driver uses the \f(CW\*(C`DBIc_DBISTATE(imp_xxh)\->get_fbav()\*(C'\fR
function (C drivers, see below), or the \f(CW\*(C`$sth\->_set_fbav($data)\*(C'\fR
method (Perl drivers) the driver does not need to do anything about this
routine.
.ie n .IP "$sth\->\fIbind_columns()\fR" 4
.el .IP "\f(CW$sth\fR\->\fIbind_columns()\fR" 4
.IX Item "$sth->bind_columns()"
Regardless of whether the driver uses
\&\f(CW\*(C`DBIc_DBISTATE(imp_xxh)\->get_fbav()\*(C'\fR, the driver does not need
to do anything about this routine as it simply iteratively calls
\&\f(CW\*(C`$sth\->bind_col()\*(C'\fR.
.PP
The \fB\s-1DBI\s0\fR code implements a default implementation of the following
functions which do not need to be written by the \fB\s-1DBD\s0\fR driver writer
unless the default implementation is incorrect for the Driver.
.ie n .IP "$dbh\->\fIquote()\fR" 4
.el .IP "\f(CW$dbh\fR\->\fIquote()\fR" 4
.IX Item "$dbh->quote()"
This should only be written if the database does not accept the \s-1ANSI\s0
\&\s-1SQL\s0 standard for quoting strings, with the string enclosed in single
quotes and any embedded single quotes replaced by two consecutive
single quotes.
.Sp
For the two argument form of quote, you need to implement the
\&\f(CW\*(C`type_info()\*(C'\fR method to provide the information that quote needs.
.ie n .IP "$dbh\->\fIping()\fR" 4
.el .IP "\f(CW$dbh\fR\->\fIping()\fR" 4
.IX Item "$dbh->ping()"
This should be implemented as a simple efficient way to determine
whether the connection to the database is still alive. Typically
code like this:
.Sp
.Vb 9
\&  sub ping {
\&      my $dbh = shift;
\&      $sth = $dbh\->prepare_cached(q{
\&          select * from A_TABLE_NAME where 1=0
\&      }) or return 0;
\&      $sth\->execute or return 0;
\&      $sth\->finish;
\&      return 1;
\&  }
.Ve
.Sp
where \fIA_TABLE_NAME\fR is the name of a table that always exists (such as a
database system catalogue).
.ie n .IP "$drh\->default_user" 4
.el .IP "\f(CW$drh\fR\->default_user" 4
.IX Item "$drh->default_user"
The default implementation of default_user will get the database
username and password fields from \f(CW$ENV{DBI_USER}\fR and
\&\f(CW$ENV{DBI_PASS}\fR. You can override this method. It is called as
follows:
.Sp
.Vb 1
\&  ($user, $pass) = $drh\->default_user($user, $pass, $attr)
.Ve
.SH "METADATA METHODS"
.IX Header "METADATA METHODS"
The exposition above ignores the \fB\s-1DBI\s0\fR MetaData methods.
The metadata methods are all associated with a database handle.
.SS "Using DBI::DBD::Metadata"
.IX Subsection "Using DBI::DBD::Metadata"
The \fBDBI::DBD::Metadata\fR module is a good semi-automatic way for the
developer of a \fB\s-1DBD\s0\fR module to write the \f(CW\*(C`get_info()\*(C'\fR and \f(CW\*(C`type_info()\*(C'\fR
functions quickly and accurately.
.PP
\fIGenerating the get_info method\fR
.IX Subsection "Generating the get_info method"
.PP
Prior to \fB\s-1DBI\s0\fR v1.33, this existed as the method \f(CW\*(C`write_getinfo_pm()\*(C'\fR
in the \fB\s-1DBI::DBD\s0\fR module. From \fB\s-1DBI\s0\fR v1.33, it exists as the method
\&\f(CW\*(C`write_getinfo_pm()\*(C'\fR in the \fBDBI::DBD::Metadata\fR module. This
discussion assumes you have \fB\s-1DBI\s0\fR v1.33 or later.
.PP
You examine the documentation for \f(CW\*(C`write_getinfo_pm()\*(C'\fR using:
.PP
.Vb 1
\&    perldoc DBI::DBD::Metadata
.Ve
.PP
To use it, you need a Perl \fB\s-1DBI\s0\fR driver for your database which implements
the \f(CW\*(C`get_info()\*(C'\fR method. In practice, this means you need to install
\&\fB\s-1DBD::ODBC\s0\fR, an \s-1ODBC\s0 driver manager, and an \s-1ODBC\s0 driver for your
database.
.PP
With the pre-requisites in place, you might type:
.PP
.Vb 2
\&    perl \-MDBI::DBD::Metadata \-we \e
\&       "write_getinfo_pm (qw{ dbi:ODBC:foo_db username password Driver })"
.Ve
.PP
The procedure writes to standard output the code that should be added to
your \fIDriver.pm\fR file and the code that should be written to
\&\fIlib/DBD/Driver/GetInfo.pm\fR.
.PP
You should review the output to ensure that it is sensible.
.PP
\fIGenerating the type_info method\fR
.IX Subsection "Generating the type_info method"
.PP
Given the idea of the \f(CW\*(C`write_getinfo_pm()\*(C'\fR method, it was not hard
to devise a parallel method, \f(CW\*(C`write_typeinfo_pm()\*(C'\fR, which does the
analogous job for the \fB\s-1DBI\s0\fR \f(CW\*(C`type_info_all()\*(C'\fR metadata method. The
\&\f(CW\*(C`write_typeinfo_pm()\*(C'\fR method was added to \fB\s-1DBI\s0\fR v1.33.
.PP
You examine the documentation for \f(CW\*(C`write_typeinfo_pm()\*(C'\fR using:
.PP
.Vb 1
\&    perldoc DBI::DBD::Metadata
.Ve
.PP
The setup is exactly analogous to the mechanism described in
\&\*(L"Generating the get_info method\*(R".
.PP
With the pre-requisites in place, you might type:
.PP
.Vb 2
\&    perl \-MDBI::DBD::Metadata \-we \e
\&       "write_typeinfo (qw{ dbi:ODBC:foo_db username password Driver })"
.Ve
.PP
The procedure writes to standard output the code that should be added to
your \fIDriver.pm\fR file and the code that should be written to
\&\fIlib/DBD/Driver/TypeInfo.pm\fR.
.PP
You should review the output to ensure that it is sensible.
.SS "Writing DBD::Driver::db::get_info"
.IX Subsection "Writing DBD::Driver::db::get_info"
If you use the \fBDBI::DBD::Metadata\fR module, then the code you need is
generated for you.
.PP
If you decide not to use the \fBDBI::DBD::Metadata\fR module, you
should probably borrow the code from a driver that has done so (eg
\&\fBDBD::Informix\fR from version 1.05 onwards) and crib the code from
there, or look at the code that generates that module and follow
that. The method in \fIDriver.pm\fR will be very simple; the method in
\&\fIlib/DBD/Driver/GetInfo.pm\fR is not very much more complex unless your
\&\s-1DBMS\s0 itself is much more complex.
.PP
Note that some of the \fB\s-1DBI\s0\fR utility methods rely on information from the
\&\f(CW\*(C`get_info()\*(C'\fR method to perform their operations correctly. See, for
example, the \f(CW\*(C`quote_identifier()\*(C'\fR and quote methods, discussed below.
.SS "Writing DBD::Driver::db::type_info_all"
.IX Subsection "Writing DBD::Driver::db::type_info_all"
If you use the \f(CW\*(C`DBI::DBD::Metadata\*(C'\fR module, then the code you need is
generated for you.
.PP
If you decide not to use the \f(CW\*(C`DBI::DBD::Metadata\*(C'\fR module, you
should probably borrow the code from a driver that has done so (eg
\&\f(CW\*(C`DBD::Informix\*(C'\fR from version 1.05 onwards) and crib the code from
there, or look at the code that generates that module and follow
that. The method in \fIDriver.pm\fR will be very simple; the method in
\&\fIlib/DBD/Driver/TypeInfo.pm\fR is not very much more complex unless your
\&\s-1DBMS\s0 itself is much more complex.
.SS "Writing DBD::Driver::db::type_info"
.IX Subsection "Writing DBD::Driver::db::type_info"
The guidelines on writing this method are still not really clear.
No sample implementation is available.
.SS "Writing DBD::Driver::db::table_info"
.IX Subsection "Writing DBD::Driver::db::table_info"
.Vb 2
\& *FIX ME* The guidelines on writing this method have not been written yet.
\& No sample implementation is available.
.Ve
.SS "Writing DBD::Driver::db::column_info"
.IX Subsection "Writing DBD::Driver::db::column_info"
.Vb 2
\& *FIX ME* The guidelines on writing this method have not been written yet.
\& No sample implementation is available.
.Ve
.SS "Writing DBD::Driver::db::primary_key_info"
.IX Subsection "Writing DBD::Driver::db::primary_key_info"
.Vb 2
\& *FIX ME* The guidelines on writing this method have not been written yet.
\& No sample implementation is available.
.Ve
.SS "Writing DBD::Driver::db::primary_key"
.IX Subsection "Writing DBD::Driver::db::primary_key"
.Vb 2
\& *FIX ME* The guidelines on writing this method have not been written yet.
\& No sample implementation is available.
.Ve
.SS "Writing DBD::Driver::db::foreign_key_info"
.IX Subsection "Writing DBD::Driver::db::foreign_key_info"
.Vb 2
\& *FIX ME* The guidelines on writing this method have not been written yet.
\& No sample implementation is available.
.Ve
.SS "Writing DBD::Driver::db::tables"
.IX Subsection "Writing DBD::Driver::db::tables"
This method generates an array of names in a format suitable for being
embedded in \s-1SQL\s0 statements in places where a table name is expected.
.PP
If your database hews close enough to the \s-1SQL\s0 standard or if you have
implemented an appropriate \f(CW\*(C`table_info()\*(C'\fR function and and the appropriate
\&\f(CW\*(C`quote_identifier()\*(C'\fR function, then the \fB\s-1DBI\s0\fR default version of this method
will work for your driver too.
.PP
Otherwise, you have to write a function yourself, such as:
.PP
.Vb 12
\&    sub tables
\&    {
\&        my($dbh, $cat, $sch, $tab, $typ) = @_;
\&        my(@res);
\&        my($sth) = $dbh\->table_info($cat, $sch, $tab, $typ);
\&        my(@arr);
\&        while (@arr = $sth\->fetchrow_array)
\&        {
\&            push @res, $dbh\->quote_identifier($arr[0], $arr[1], $arr[2]);
\&        }
\&        return @res;
\&    }
.Ve
.PP
See also the default implementation in \fI\s-1DBI\s0.pm\fR.
.SS "Writing DBD::Driver::db::quote"
.IX Subsection "Writing DBD::Driver::db::quote"
This method takes a value and converts it into a string suitable for
embedding in an \s-1SQL\s0 statement as a string literal.
.PP
If your \s-1DBMS\s0 accepts the \s-1SQL\s0 standard notation for strings (single
quotes around the string as a whole with any embedded single quotes
doubled up), then you do not need to write this method as \fB\s-1DBI\s0\fR provides a
default method that does it for you.
.PP
If your \s-1DBMS\s0 uses an alternative notation or escape mechanism, then you
need to provide an equivalent function. For example, suppose your \s-1DBMS\s0
used C notation with double quotes around the string and backslashes
escaping both double quotes and backslashes themselves. Then you might
write the function as:
.PP
.Vb 6
\&    sub quote
\&    {
\&        my($dbh, $str) = @_;
\&        $str =~ s/["\e\e]/\e\e$&/gmo;
\&        return qq{"$str"};
\&    }
.Ve
.PP
Handling newlines and other control characters is left as an exercise
for the reader.
.PP
This sample method ignores the \fI\f(CI$data_type\fI\fR indicator which is the
optional second argument to the method.
.SS "Writing DBD::Driver::db::quote_identifier"
.IX Subsection "Writing DBD::Driver::db::quote_identifier"
This method is called to ensure that the name of the given table (or
other database object) can be embedded into an \s-1SQL\s0 statement without
danger of misinterpretation. The result string should be usable in the
text of an \s-1SQL\s0 statement as the identifier for a table.
.PP
If your \s-1DBMS\s0 accepts the \s-1SQL\s0 standard notation for quoted identifiers
(which uses double quotes around the identifier as a whole, with any
embedded double quotes doubled up) and accepts \fI\*(L"schema\*(R".\*(L"identifier\*(R"\fR
(and \fI\*(L"catalog\*(R".\*(L"schema\*(R".\*(L"identifier\*(R"\fR when a catalog is specified), then
you do not need to write this method as \fB\s-1DBI\s0\fR provides a default method
that does it for you.
.PP
In fact, even if your \s-1DBMS\s0 does not handle exactly that notation but
you have implemented the \f(CW\*(C`get_info()\*(C'\fR method and it gives the correct
responses, then it will work for you. If your database is fussier, then
you need to implement your own version of the function.
.PP
For example, \fBDBD::Informix\fR has to deal with an environment variable
\&\fI\s-1DELIMIDENT\s0\fR. If it is not set, then the \s-1DBMS\s0 treats names enclosed in
double quotes as strings rather than names, which is usually a syntax
error. Additionally, the catalog portion of the name is separated from
the schema and table by a different delimiter (colon instead of dot),
and the catalog portion is never enclosed in quotes. (Fortunately,
valid strings for the catalog will never contain weird characters that
might need to be escaped, unless you count dots, dashes, slashes and
at-signs as weird.) Finally, an Informix database can contain objects
that cannot be accessed because they were created by a user with the
\&\fI\s-1DELIMIDENT\s0\fR environment variable set, but the current user does not
have it set. By design choice, the \f(CW\*(C`quote_identifier()\*(C'\fR method encloses
those identifiers in double quotes anyway, which generally triggers a
syntax error, and the metadata methods which generate lists of tables
etc omit those identifiers from the result sets.
.PP
.Vb 10
\&    sub quote_identifier
\&    {
\&        my($dbh, $cat, $sch, $obj) = @_;
\&        my($rv) = "";
\&        my($qq) = (defined $ENV{DELIMIDENT}) ? \*(Aq"\*(Aq : \*(Aq\*(Aq;
\&        $rv .= qq{$cat:} if (defined $cat);
\&        if (defined $sch)
\&        {
\&            if ($sch !~ m/^\ew+$/o)
\&            {
\&                $qq = \*(Aq"\*(Aq;
\&                $sch =~ s/$qq/$qq$qq/gm;
\&            }
\&            $rv .= qq{$qq$sch$qq.};
\&        }
\&        if (defined $obj)
\&        {
\&            if ($obj !~ m/^\ew+$/o)
\&            {
\&                $qq = \*(Aq"\*(Aq;
\&                $obj =~ s/$qq/$qq$qq/gm;
\&            }
\&            $rv .= qq{$qq$obj$qq};
\&        }
\&        return $rv;
\&    }
.Ve
.PP
Handling newlines and other control characters is left as an exercise
for the reader.
.PP
Note that there is an optional fourth parameter to this function which
is a reference to a hash of attributes; this sample implementation
ignores that.
.PP
This sample implementation also ignores the single-argument variant of
the method.
.SH "TRACING"
.IX Header "TRACING"
Tracing in \s-1DBI\s0 is controlled with a combination of a trace level and a
set of flags which together are known as the trace settings. The trace
settings are stored in a single integer and divided into levels and
flags by a set of masks (\f(CW\*(C`DBIc_TRACE_LEVEL_MASK\*(C'\fR and
\&\f(CW\*(C`DBIc_TRACE_FLAGS_MASK\*(C'\fR).
.PP
Each handle has it's own trace settings and so does the \s-1DBI\s0. When you
call a method the \s-1DBI\s0 merges the handles settings into its own for the
duration of the call: the trace flags of the handle are \s-1OR\s0'd into the
trace flags of the \s-1DBI\s0, and if the handle has a higher trace level
then the \s-1DBI\s0 trace level is raised to match it. The previous \s-1DBI\s0 trace
settings are restored when the called method returns.
.SS "Trace Level"
.IX Subsection "Trace Level"
The trace level is the first 4 bits of the trace settings (masked by
\&\f(CW\*(C`DBIc_TRACE_FLAGS_MASK\*(C'\fR) and represents trace levels of 1 to 15. Do
not output anything at trace levels less than 3 as they are reserved
for \s-1DBI\s0.
.PP
For advice on what to output at each level see \*(L"Trace Levels\*(R" in
\&\s-1DBI\s0.
.PP
To test for a trace level you can use the \f(CW\*(C`DBIc_TRACE_LEVEL\*(C'\fR macro
like this:
.PP
.Vb 3
\&  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {
\&      PerlIO_printf(DBIc_LOGPIO(imp_xxh), "foobar");
\&  }
.Ve
.PP
Also \fBnote\fR the use of PerlIO_printf which you should always use for
tracing and never the C \f(CW\*(C`stdio.h\*(C'\fR I/O functions.
.SS "Trace Flags"
.IX Subsection "Trace Flags"
Trace flags are used to enable tracing of specific activities within
the \s-1DBI\s0 and drivers. The \s-1DBI\s0 defines some trace flags and drivers can
define others. \s-1DBI\s0 trace flag names begin with a capital letter and
driver specific names begin with a lowercase letter. For a list of \s-1DBI\s0
defined trace flags see \*(L"Trace Flags\*(R" in \s-1DBI\s0.
.PP
If you want to use private trace flags you'll probably want to be able
to set them by name. Drivers are expected to override the
parse_trace_flag (note the singular) and check if \f(CW$trace_flag_name\fR is
a driver specific trace flags and, if not, then call the DBIs default
\&\fIparse_trace_flag()\fR. To do that you'll need to define a
\&\fIparse_trace_flag()\fR method like this:
.PP
.Vb 9
\&  sub parse_trace_flag {
\&      my ($h, $name) = @_;
\&      return 0x01000000 if $name eq \*(Aqfoo\*(Aq;
\&      return 0x02000000 if $name eq \*(Aqbar\*(Aq;
\&      return 0x04000000 if $name eq \*(Aqbaz\*(Aq;
\&      return 0x08000000 if $name eq \*(Aqboo\*(Aq;
\&      return 0x10000000 if $name eq \*(Aqbop\*(Aq;
\&      return $h\->SUPER::parse_trace_flag($name);
\&  }
.Ve
.PP
All private flag names must be lowercase, and all private flags must
be in the top 8 of the 32 bits of \f(CW\*(C`DBIc_TRACE_FLAGS(imp)\*(C'\fR i.e.,
0xFF000000.
.PP
If you've defined a \fIparse_trace_flag()\fR method in ::db you'll also want
it in ::st, so just alias it in:
.PP
.Vb 1
\&  *parse_trace_flag = \e&DBD::foo:db::parse_trace_flag;
.Ve
.PP
You may want to act on the current '\s-1SQL\s0' trace flag that \s-1DBI\s0 defines
to output \s-1SQL\s0 prepared/executed as \s-1DBI\s0 currently does not do \s-1SQL\s0
tracing.
.SS "Trace Macros"
.IX Subsection "Trace Macros"
Access to the trace level and trace flags is via a set of macros.
.PP
.Vb 4
\&  DBIc_TRACE_SETTINGS(imp) returns the trace settings
\&  DBIc_TRACE_LEVEL(imp) returns the trace level
\&  DBIc_TRACE_FLAGS(imp) returns the trace flags
\&  DBIc_TRACE(imp, flags, flaglevel, level)
\&
\&  e.g.,
\&
\&  DBIc_TRACE(imp, 0, 0, 4)
\&    if level >= 4
\&
\&  DBIc_TRACE(imp, DBDtf_FOO, 2, 4)
\&    if tracing DBDtf_FOO & level>=2 or level>=4
\&
\&  DBIc_TRACE(imp, DBDtf_FOO, 2, 0)
\&    as above but never trace just due to level
.Ve
.SH "WRITING AN EMULATION LAYER FOR AN OLD PERL INTERFACE"
.IX Header "WRITING AN EMULATION LAYER FOR AN OLD PERL INTERFACE"
Study \fIOraperl.pm\fR (supplied with \fBDBD::Oracle\fR) and \fIIngperl.pm\fR (supplied
with \fBDBD::Ingres\fR) and the corresponding \fIdbdimp.c\fR files for ideas.
.PP
Note that the emulation code sets \f(CW\*(C`$dbh\->{CompatMode} = 1;\*(C'\fR for each
connection so that the internals of the driver can implement behaviour
compatible with the old interface when dealing with those handles.
.SS "Setting emulation perl variables"
.IX Subsection "Setting emulation perl variables"
For example, ingperl has a \fI\f(CI$sql_rowcount\fI\fR variable. Rather than try
to manually update this in \fIIngperl.pm\fR it can be done faster in C code.
In \f(CW\*(C`dbd_init()\*(C'\fR:
.PP
.Vb 1
\&  sql_rowcount = perl_get_sv("Ingperl::sql_rowcount", GV_ADDMULTI);
.Ve
.PP
In the relevant places do:
.PP
.Vb 2
\&  if (DBIc_COMPAT(imp_sth))     /* only do this for compatibility mode handles */
\&      sv_setiv(sql_rowcount, the_row_count);
.Ve
.SH "OTHER MISCELLANEOUS INFORMATION"
.IX Header "OTHER MISCELLANEOUS INFORMATION"
.SS "The imp_xyz_t types"
.IX Subsection "The imp_xyz_t types"
Any handle has a corresponding C structure filled with private data.
Some of this data is reserved for use by \fB\s-1DBI\s0\fR (except for using the
DBIc macros below), some is for you. See the description of the
\&\fIdbdimp.h\fR file above for examples. Most functions in \fIdbdimp.c\fR
are passed both the handle \f(CW\*(C`xyz\*(C'\fR and a pointer to \f(CW\*(C`imp_xyz\*(C'\fR. In
rare cases, however, you may use the following macros:
.IP "D_imp_dbh(dbh)" 4
.IX Item "D_imp_dbh(dbh)"
Given a function argument \fIdbh\fR, declare a variable \fIimp_dbh\fR and
initialize it with a pointer to the handles private data. Note: This
must be a part of the function header, because it declares a variable.
.IP "D_imp_sth(sth)" 4
.IX Item "D_imp_sth(sth)"
Likewise for statement handles.
.IP "D_imp_xxx(h)" 4
.IX Item "D_imp_xxx(h)"
Given any handle, declare a variable \fIimp_xxx\fR and initialize it
with a pointer to the handles private data. It is safe, for example,
to cast \fIimp_xxx\fR to \f(CW\*(C`imp_dbh_t*\*(C'\fR, if \f(CW\*(C`DBIc_TYPE(imp_xxx) == DBIt_DB\*(C'\fR.
(You can also call \f(CW\*(C`sv_derived_from(h, "DBI::db")\*(C'\fR, but that's much
slower.)
.IP "D_imp_dbh_from_sth" 4
.IX Item "D_imp_dbh_from_sth"
Given a \fIimp_sth\fR, declare a variable \fIimp_dbh\fR and initialize it with a
pointer to the parent database handle's implementors structure.
.SS "Using DBIc_IMPSET_on"
.IX Subsection "Using DBIc_IMPSET_on"
The driver code which initializes a handle should use \f(CW\*(C`DBIc_IMPSET_on()\*(C'\fR
as soon as its state is such that the cleanup code must be called.
When this happens is determined by your driver code.
.PP
\&\fBFailure to call this can lead to corruption of data structures.\fR
.PP
For example, \fBDBD::Informix\fR maintains a linked list of database
handles in the driver, and within each handle, a linked list of
statements. Once a statement is added to the linked list, it is crucial
that it is cleaned up (removed from the list). When \fI\fIDBIc_IMPSET_on()\fI\fR
was being called too late, it was able to cause all sorts of problems.
.SS "Using \fIDBIc_is()\fP, \fIDBIc_has()\fP, \fIDBIc_on()\fP and \fIDBIc_off()\fP"
.IX Subsection "Using DBIc_is(), DBIc_has(), DBIc_on() and DBIc_off()"
Once upon a long time ago, the only way of handling the internal \fB\s-1DBI\s0\fR
boolean flags/attributes was through macros such as:
.PP
.Vb 2
\&  DBIc_WARN       DBIc_WARN_on        DBIc_WARN_off
\&  DBIc_COMPAT     DBIc_COMPAT_on      DBIc_COMPAT_off
.Ve
.PP
Each of these took an \fIimp_xxh\fR pointer as an argument.
.PP
Since then, new attributes have been added such as \fIChopBlanks\fR,
\&\fIRaiseError\fR and \fIPrintError\fR, and these do not have the full set of
macros. The approved method for handling these is now the four macros:
.PP
.Vb 5
\&  DBIc_is(imp, flag)
\&  DBIc_has(imp, flag)       an alias for DBIc_is
\&  DBIc_on(imp, flag)
\&  DBIc_off(imp, flag)
\&  DBIc_set(imp, flag, on)   set if on is true, else clear
.Ve
.PP
Consequently, the \f(CW\*(C`DBIc_XXXXX\*(C'\fR family of macros is now mostly deprecated
and new drivers should avoid using them, even though the older drivers
will probably continue to do so for quite a while yet. However...
.PP
There is an \fIimportant exception\fR to that. The \fI\s-1ACTIVE\s0\fR and \fI\s-1IMPSET\s0\fR
flags should be set via the \f(CW\*(C`DBIc_ACTIVE_on()\*(C'\fR and \f(CW\*(C`DBIc_IMPSET_on()\*(C'\fR macros,
and unset via the \f(CW\*(C`DBIc_ACTIVE_off()\*(C'\fR and \f(CW\*(C`DBIc_IMPSET_off()\*(C'\fR macros.
.SS "Using the \fIget_fbav()\fP method"
.IX Subsection "Using the get_fbav() method"
\&\fB\s-1THIS\s0 \s-1IS\s0 \s-1CRITICAL\s0 for C/XS drivers\fR.
.PP
The \f(CW\*(C`$sth\->bind_col()\*(C'\fR and \f(CW\*(C`$sth\->bind_columns()\*(C'\fR documented
in the \fB\s-1DBI\s0\fR specification do not have to be implemented by the driver
writer because \fB\s-1DBI\s0\fR takes care of the details for you.
.PP
However, the key to ensuring that bound columns work is to call the
function \f(CW\*(C`DBIc_DBISTATE(imp_xxh)\->get_fbav()\*(C'\fR in the code which
fetches a row of data.
.PP
This returns an \f(CW\*(C`AV\*(C'\fR, and each element of the \f(CW\*(C`AV\*(C'\fR contains the \f(CW\*(C`SV\*(C'\fR which
should be set to contain the returned data.
.PP
The pure Perl equivalent is the \f(CW\*(C`$sth\->_set_fbav($data)\*(C'\fR method, as
described in the part on pure Perl drivers.
.SS "Casting strings to Perl types based on a \s-1SQL\s0 type"
.IX Subsection "Casting strings to Perl types based on a SQL type"
\&\s-1DBI\s0 from 1.611 (and \s-1DBIXS_REVISION\s0 13606) defines the
sql_type_cast_svpv method which may be used to cast a string
representation of a value to a more specific Perl type based on a \s-1SQL\s0
type. You should consider using this method when processing bound
column data as it provides some support for the \s-1TYPE\s0 bind_col
attribute which is rarely used in drivers.
.PP
.Vb 1
\&  int sql_type_cast_svpv(pTHX_ SV *sv, int sql_type, U32 flags, void *v)
.Ve
.PP
\&\f(CW\*(C`sv\*(C'\fR is what you would like cast, \f(CW\*(C`sql_type\*(C'\fR is one of the \s-1DBI\s0 defined
\&\s-1SQL\s0 types (e.g., \f(CW\*(C`SQL_INTEGER\*(C'\fR) and \f(CW\*(C`flags\*(C'\fR is a bitmask as follows:
.IP "DBIstcf_STRICT" 4
.IX Item "DBIstcf_STRICT"
If set this indicates you want an error state returned if the cast
cannot be performed.
.IP "DBIstcf_DISCARD_STRING" 4
.IX Item "DBIstcf_DISCARD_STRING"
If set and the pv portion of the \f(CW\*(C`sv\*(C'\fR is cast then this will cause
sv's pv to be freed up.
.PP
sql_type_cast_svpv returns the following states:
.PP
.Vb 5
\& \-2 sql_type is not handled \- sv not changed
\& \-1 sv is undef, sv not changed
\&  0 sv could not be cast cleanly and DBIstcf_STRICT was specified
\&  1 sv could not be case cleanly and DBIstcf_STRICT was not specified
\&  2 sv was cast ok
.Ve
.PP
The current implementation of sql_type_cast_svpv supports
\&\f(CW\*(C`SQL_INTEGER\*(C'\fR, \f(CW\*(C`SQL_DOUBLE\*(C'\fR and \f(CW\*(C`SQL_NUMERIC\*(C'\fR. \f(CW\*(C`SQL_INTEGER\*(C'\fR uses
sv_2iv and hence may set \s-1IV\s0, \s-1UV\s0 or \s-1NV\s0 depending on the
number. \f(CW\*(C`SQL_DOUBLE\*(C'\fR uses sv_2nv so may set \s-1NV\s0 and \f(CW\*(C`SQL_NUMERIC\*(C'\fR
will set \s-1IV\s0 or \s-1UV\s0 or \s-1NV\s0.
.PP
DBIstcf_STRICT should be implemented as the StrictlyTyped attribute
and DBIstcf_DISCARD_STRING implemented as the DiscardString attribute
to the bind_col method and both default to off.
.PP
See DBD::Oracle for an example of how this is used.
.SH "SUBCLASSING DBI DRIVERS"
.IX Header "SUBCLASSING DBI DRIVERS"
This is definitely an open subject. It can be done, as demonstrated by
the \fBDBD::File\fR driver, but it is not as simple as one might think.
.PP
(Note that this topic is different from subclassing the \fB\s-1DBI\s0\fR. For an
example of that, see the \fIt/subclass.t\fR file supplied with the \fB\s-1DBI\s0\fR.)
.PP
The main problem is that the \fIdbh\fR's and \fIsth\fR's that your \f(CW\*(C`connect()\*(C'\fR and
\&\f(CW\*(C`prepare()\*(C'\fR methods return are not instances of your \fBDBD::Driver::db\fR
or \fBDBD::Driver::st\fR packages, they are not even derived from it.
Instead they are instances of the \fBDBI::db\fR or \fBDBI::st\fR classes or
a derived subclass. Thus, if you write a method \f(CW\*(C`mymethod()\*(C'\fR and do a
.PP
.Vb 1
\&  $dbh\->mymethod()
.Ve
.PP
then the autoloader will search for that method in the package \fBDBI::db\fR.
Of course you can instead to a
.PP
.Vb 1
\&  $dbh\->func(\*(Aqmymethod\*(Aq)
.Ve
.PP
and that will indeed work, even if \f(CW\*(C`mymethod()\*(C'\fR is inherited, but not
without additional work. Setting \fI\f(CI@ISA\fI\fR is not sufficient.
.SS "Overwriting methods"
.IX Subsection "Overwriting methods"
The first problem is, that the \f(CW\*(C`connect()\*(C'\fR method has no idea of
subclasses. For example, you cannot implement base class and subclass
in the same file: The \f(CW\*(C`install_driver()\*(C'\fR method wants to do a
.PP
.Vb 1
\&  require DBD::Driver;
.Ve
.PP
In particular, your subclass \fBhas\fR to be a separate driver, from
the view of \fB\s-1DBI\s0\fR, and you cannot share driver handles.
.PP
Of course that's not much of a problem. You should even be able
to inherit the base classes \f(CW\*(C`connect()\*(C'\fR method. But you cannot
simply overwrite the method, unless you do something like this,
quoted from \fB\s-1DBD::CSV\s0\fR:
.PP
.Vb 2
\&  sub connect ($$;$$$) {
\&      my ($drh, $dbname, $user, $auth, $attr) = @_;
\&
\&      my $this = $drh\->DBD::File::dr::connect($dbname, $user, $auth, $attr);
\&      if (!exists($this\->{csv_tables})) {
\&          $this\->{csv_tables} = {};
\&      }
\&
\&      $this;
\&  }
.Ve
.PP
Note that we cannot do a
.PP
.Vb 1
\&  $drh\->SUPER::connect($dbname, $user, $auth, $attr);
.Ve
.PP
as we would usually do in a an \s-1OO\s0 environment, because \fI\f(CI$drh\fI\fR is an instance
of \fBDBI::dr\fR. And note, that the \f(CW\*(C`connect()\*(C'\fR method of \fBDBD::File\fR is
able to handle subclass attributes. See the description of Pure Perl
drivers above.
.PP
It is essential that you always call superclass method in the above
manner. However, that should do.
.SS "Attribute handling"
.IX Subsection "Attribute handling"
Fortunately the \fB\s-1DBI\s0\fR specifications allow a simple, but still
performant way of handling attributes. The idea is based on the
convention that any driver uses a prefix \fIdriver_\fR for its private
methods. Thus it's always clear whether to pass attributes to the super
class or not. For example, consider this \f(CW\*(C`STORE()\*(C'\fR method from the
\&\fB\s-1DBD::CSV\s0\fR class:
.PP
.Vb 8
\&  sub STORE {
\&      my ($dbh, $attr, $val) = @_;
\&      if ($attr !~ /^driver_/) {
\&          return $dbh\->DBD::File::db::STORE($attr, $val);
\&      }
\&      if ($attr eq \*(Aqdriver_foo\*(Aq) {
\&      ...
\&  }
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan Leffler <jleffler@us.ibm.com> (previously <jleffler@informix.com>),
Jochen Wiedmann <joe@ispsoft.de>,
Steffen Goeldner <sgoeldner@cpan.org>,
and Tim Bunce <dbi\-users@perl.org>.
                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::DBD5.18.3pm                             0100644 0001750 0001750 00000430645 12566241602 022721  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::DBD 3"
.TH DBI::DBD 3 "2013-06-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::DBD \- Perl DBI Database Driver Writer's Guide
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  perldoc DBI::DBD
.Ve
.SS "Version and volatility"
.IX Subsection "Version and volatility"
This document is \fIstill\fR a minimal draft which is in need of further work.
.PP
The changes will occur both because the \fB\s-1DBI\s0\fR specification is changing
and hence the requirements on \fB\s-1DBD\s0\fR drivers change, and because feedback
from people reading this document will suggest improvements to it.
.PP
Please read the \fB\s-1DBI\s0\fR documentation first and fully, including the \fB\s-1DBI\s0\fR \s-1FAQ.\s0
Then reread the \fB\s-1DBI\s0\fR specification again as you're reading this. It'll help.
.PP
This document is a patchwork of contributions from various authors.
More contributions (preferably as patches) are very welcome.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document is primarily intended to help people writing new
database drivers for the Perl Database Interface (Perl \s-1DBI\s0).
It may also help others interested in discovering why the internals of
a \fB\s-1DBD\s0\fR driver are written the way they are.
.PP
This is a guide.  Few (if any) of the statements in it are completely
authoritative under all possible circumstances.  This means you will
need to use judgement in applying the guidelines in this document.
If in \fIany\fR doubt at all, please do contact the \fIdbi-dev\fR mailing list
(details given below) where Tim Bunce and other driver authors can help.
.SH "CREATING A NEW DRIVER"
.IX Header "CREATING A NEW DRIVER"
The first rule for creating a new database driver for the Perl \s-1DBI\s0 is
very simple: \fB\s-1DON\s0'T!\fR
.PP
There is usually a driver already available for the database you want
to use, almost regardless of which database you choose. Very often, the
database will provide an \s-1ODBC\s0 driver interface, so you can often use
\&\fB\s-1DBD::ODBC\s0\fR to access the database. This is typically less convenient
on a Unix box than on a Microsoft Windows box, but there are numerous
options for \s-1ODBC\s0 driver managers on Unix too, and very often the \s-1ODBC\s0
driver is provided by the database supplier.
.PP
Before deciding that you need to write a driver, do your homework to
ensure that you are not wasting your energies.
.PP
[As of December 2002, the consensus is that if you need an \s-1ODBC\s0 driver
manager on Unix, then the unixODBC driver (available from
<http://www.unixodbc.org/>) is the way to go.]
.PP
The second rule for creating a new database driver for the Perl \s-1DBI\s0 is
also very simple: \fBDon't \*(-- get someone else to do it for you!\fR
.PP
Nevertheless, there are occasions when it is necessary to write a new
driver, often to use a proprietary language or \s-1API\s0 to access the
database more swiftly, or more comprehensively, than an \s-1ODBC\s0 driver can.
Then you should read this document very carefully, but with a suitably
sceptical eye.
.PP
If there is something in here that does not make any sense, question it.
You might be right that the information is bogus, but don't come to that
conclusion too quickly.
.SS "URLs and mailing lists"
.IX Subsection "URLs and mailing lists"
The primary web-site for locating \fB\s-1DBI\s0\fR software and information is
.PP
.Vb 1
\&  http://dbi.perl.org/
.Ve
.PP
There are two main and one auxiliary mailing lists for people working
with \fB\s-1DBI\s0\fR.  The primary lists are \fIdbi\-users@perl.org\fR for general users
of \fB\s-1DBI\s0\fR and \fB\s-1DBD\s0\fR drivers, and \fIdbi\-dev@perl.org\fR mainly for \fB\s-1DBD\s0\fR driver
writers (don't join the \fIdbi-dev\fR list unless you have a good reason).
The auxiliary list is \fIdbi\-announce@perl.org\fR for announcing new
releases of \fB\s-1DBI\s0\fR or \fB\s-1DBD\s0\fR drivers.
.PP
You can join these lists by accessing the web-site <http://dbi.perl.org/>.
The lists are closed so you cannot send email to any of the lists
unless you join the list first.
.PP
You should also consider monitoring the \fIcomp.lang.perl.*\fR newsgroups,
especially \fIcomp.lang.perl.modules\fR.
.SS "The Cheetah book"
.IX Subsection "The Cheetah book"
The definitive book on Perl \s-1DBI\s0 is the Cheetah book, so called because
of the picture on the cover. Its proper title is '\fIProgramming the
Perl \s-1DBI:\s0 Database programming with Perl\fR' by Alligator Descartes
and Tim Bunce, published by O'Reilly Associates, February 2000, \s-1ISBN
1\-56592\-699\-4.\s0 Buy it now if you have not already done so, and read it.
.SS "Locating drivers"
.IX Subsection "Locating drivers"
Before writing a new driver, it is in your interests to find out
whether there already is a driver for your database.  If there is such
a driver, it would be much easier to make use of it than to write your
own!
.PP
The primary web-site for locating Perl software is
<http://search.cpan.org/>.  You should look under the various
modules listings for the software you are after. For example:
.PP
.Vb 1
\&  http://search.cpan.org/modlist/Database_Interfaces
.Ve
.PP
Follow the \fB\s-1DBD::\s0\fR and \fBDBIx::\fR links at the top to see those subsets.
.PP
See the \fB\s-1DBI\s0\fR docs for information on \fB\s-1DBI\s0\fR web sites and mailing lists.
.SS "Registering a new driver"
.IX Subsection "Registering a new driver"
Before going through any official registration process, you will need
to establish that there is no driver already in the works. You'll do
that by asking the \fB\s-1DBI\s0\fR mailing lists whether there is such a driver
available, or whether anybody is working on one.
.PP
When you get the go ahead, you will need to establish the name of the
driver and a prefix for the driver. Typically, the name is based on the
name of the database software it uses, and the prefix is a contraction
of that. Hence, \fBDBD::Oracle\fR has the name \fIOracle\fR and the prefix
\&'\fIora_\fR'. The prefix must be lowercase and contain no underscores other
than the one at the end.
.PP
This information will be recorded in the \fB\s-1DBI\s0\fR module. Apart from
documentation purposes, registration is a prerequisite for
installing private methods.
.PP
If you are writing a driver which will not be distributed on \s-1CPAN,\s0 then
you should choose a prefix beginning with '\fIx_\fR', to avoid potential
prefix collisions with drivers registered in the future. Thus, if you
wrote a non-CPAN distributed driver called \fBDBD::CustomDB\fR, the prefix
might be '\fIx_cdb_\fR'.
.PP
This document assumes you are writing a driver called \fBDBD::Driver\fR, and
that the prefix '\fIdrv_\fR' is assigned to the driver.
.SS "Two styles of database driver"
.IX Subsection "Two styles of database driver"
There are two distinct styles of database driver that can be written to
work with the Perl \s-1DBI.\s0
.PP
Your driver can be written in pure Perl, requiring no C compiler.
When feasible, this is the best solution, but most databases are not
written in such a way that this can be done. Some examples of pure
Perl drivers are \fBDBD::File\fR and \fB\s-1DBD::CSV\s0\fR.
.PP
Alternatively, and most commonly, your driver will need to use some C
code to gain access to the database. This will be classified as a C/XS
driver.
.SS "What code will you write?"
.IX Subsection "What code will you write?"
There are a number of files that need to be written for either a pure
Perl driver or a C/XS driver. There are no extra files needed only by
a pure Perl driver, but there are several extra files needed only by a
C/XS driver.
.PP
\fIFiles common to pure Perl and C/XS drivers\fR
.IX Subsection "Files common to pure Perl and C/XS drivers"
.PP
Assuming that your driver is called \fBDBD::Driver\fR, these files are:
.IP "\(bu" 4
\&\fIMakefile.PL\fR
.IP "\(bu" 4
\&\fI\s-1META\s0.yml\fR
.IP "\(bu" 4
\&\fI\s-1README\s0\fR
.IP "\(bu" 4
\&\fI\s-1MANIFEST\s0\fR
.IP "\(bu" 4
\&\fIDriver.pm\fR
.IP "\(bu" 4
\&\fIlib/Bundle/DBD/Driver.pm\fR
.IP "\(bu" 4
\&\fIlib/DBD/Driver/Summary.pm\fR
.IP "\(bu" 4
\&\fIt/*.t\fR
.PP
The first four files are mandatory. \fIMakefile.PL\fR is used to control
how the driver is built and installed. The \fI\s-1README\s0\fR file tells people
who download the file about how to build the module and any prerequisite
software that must be installed. The \fI\s-1MANIFEST\s0\fR file is used by the
standard Perl module distribution mechanism. It lists all the source
files that need to be distributed with your module. \fIDriver.pm\fR is what
is loaded by the \fB\s-1DBI\s0\fR code; it contains the methods peculiar to your
driver.
.PP
Although the \fI\s-1META\s0.yml\fR file is not \fBrequired\fR you are advised to
create one. Of particular importance are the \fIbuild_requires\fR and
\&\fIconfigure_requires\fR attributes which newer \s-1CPAN\s0 modules understand.
You use these to tell the \s-1CPAN\s0 module (and \s-1CPANPLUS\s0) that your build
and configure mechanisms require \s-1DBI.\s0 The best reference for \s-1META\s0.yml
(at the time of writing) is
<http://module\-build.sourceforge.net/META\-spec\-v1.4.html>. You can find
a reasonable example of a \fI\s-1META\s0.yml\fR in \s-1DBD::ODBC.\s0
.PP
The \fIlib/Bundle/DBD/Driver.pm\fR file allows you to specify other Perl
modules on which yours depends in a format that allows someone to type a
simple command and ensure that all the pre-requisites are in place as
well as building your driver.
.PP
The \fIlib/DBD/Driver/Summary.pm\fR file contains (an updated version of) the
information that was included \- or that would have been included \- in
the appendices of the Cheetah book as a summary of the abilities of your
driver and the associated database.
.PP
The files in the \fIt\fR subdirectory are unit tests for your driver.
You should write your tests as stringently as possible, while taking
into account the diversity of installations that you can encounter:
.IP "\(bu" 4
Your tests should not casually modify operational databases.
.IP "\(bu" 4
You should never damage existing tables in a database.
.IP "\(bu" 4
You should code your tests to use a constrained name space within the
database. For example, the tables (and all other named objects) that are
created could all begin with '\fIdbd_drv_\fR'.
.IP "\(bu" 4
At the end of a test run, there should be no testing objects left behind
in the database.
.IP "\(bu" 4
If you create any databases, you should remove them.
.IP "\(bu" 4
If your database supports temporary tables that are automatically
removed at the end of a session, then exploit them as often as possible.
.IP "\(bu" 4
Try to make your tests independent of each other. If you have a
test \fIt/t11dowhat.t\fR that depends upon the successful running
of \fIt/t10thingamy.t\fR, people cannot run the single test case
\&\fIt/t11dowhat.t\fR. Further, running \fIt/t11dowhat.t\fR twice in a row is
likely to fail (at least, if \fIt/t11dowhat.t\fR modifies the database at
all) because the database at the start of the second run is not what you
saw at the start of the first run.
.IP "\(bu" 4
Document in your \fI\s-1README\s0\fR file what you do, and what privileges people
need to do it.
.IP "\(bu" 4
You can, and probably should, sequence your tests by including a test
number before an abbreviated version of the test name; the tests are run
in the order in which the names are expanded by shell-style globbing.
.IP "\(bu" 4
It is in your interests to ensure that your tests work as widely
as possible.
.PP
Many drivers also install sub-modules \fBDBD::Driver::SubModule\fR
for any of a variety of different reasons, such as to support
the metadata methods (see the discussion of \*(L"\s-1METADATA METHODS\*(R"\s0
below). Such sub-modules are conventionally stored in the directory
\&\fIlib/DBD/Driver\fR. The module itself would usually be in a file
\&\fISubModule.pm\fR. All such sub-modules should themselves be version
stamped (see the discussions far below).
.PP
\fIExtra files needed by C/XS drivers\fR
.IX Subsection "Extra files needed by C/XS drivers"
.PP
The software for a C/XS driver will typically contain at least four
extra files that are not relevant to a pure Perl driver.
.IP "\(bu" 4
\&\fIDriver.xs\fR
.IP "\(bu" 4
\&\fIDriver.h\fR
.IP "\(bu" 4
\&\fIdbdimp.h\fR
.IP "\(bu" 4
\&\fIdbdimp.c\fR
.PP
The \fIDriver.xs\fR file is used to generate C code that Perl can call to gain
access to the C functions you write that will, in turn, call down onto
your database software.
.PP
The \fIDriver.h\fR header is a stylized header that ensures you can access the
necessary Perl and \fB\s-1DBI\s0\fR macros, types, and function declarations.
.PP
The \fIdbdimp.h\fR is used to specify which functions have been implemented by
your driver.
.PP
The \fIdbdimp.c\fR file is where you write the C code that does the real work
of translating between Perl-ish data types and what the database expects
to use and return.
.PP
There are some (mainly small, but very important) differences between
the contents of \fIMakefile.PL\fR and \fIDriver.pm\fR for pure Perl and C/XS
drivers, so those files are described both in the section on creating a
pure Perl driver and in the section on creating a C/XS driver.
.PP
Obviously, you can add extra source code files to the list.
.SS "Requirements on a driver and driver writer"
.IX Subsection "Requirements on a driver and driver writer"
To be remotely useful, your driver must be implemented in a format that
allows it to be distributed via \s-1CPAN,\s0 the Comprehensive Perl Archive
Network (<http://www.cpan.org/> and <http://search.cpan.org>).
Of course, it is easier if you do not have to meet this criterion, but
you will not be able to ask for much help if you do not do so, and
no-one is likely to want to install your module if they have to learn a
new installation mechanism.
.SH "CREATING A PURE PERL DRIVER"
.IX Header "CREATING A PURE PERL DRIVER"
Writing a pure Perl driver is surprisingly simple. However, there are
some problems you should be aware of. The best option is of course
picking up an existing driver and carefully modifying one method
after the other.
.PP
Also look carefully at \fBDBD::AnyData\fR and \fBDBD::Template\fR.
.PP
As an example we take a look at the \fBDBD::File\fR driver, a driver for
accessing plain files as tables, which is part of the \fB\s-1DBD::CSV\s0\fR package.
.PP
The minimal set of files we have to implement are \fIMakefile.PL\fR,
\&\fI\s-1README\s0\fR, \fI\s-1MANIFEST\s0\fR and \fIDriver.pm\fR.
.SS "Pure Perl version of Makefile.PL"
.IX Subsection "Pure Perl version of Makefile.PL"
You typically start with writing \fIMakefile.PL\fR, a Makefile
generator. The contents of this file are described in detail in
the ExtUtils::MakeMaker man pages. It is definitely a good idea
if you start reading them. At least you should know about the
variables \fI\s-1CONFIGURE\s0\fR, \fI\s-1DEFINED\s0\fR, \fI\s-1PM\s0\fR, \fI\s-1DIR\s0\fR, \fI\s-1EXE_FILES\s0\fR,
\&\fI\s-1INC\s0\fR, \fI\s-1LIBS\s0\fR, \fI\s-1LINKTYPE\s0\fR, \fI\s-1NAME\s0\fR, \fI\s-1OPTIMIZE\s0\fR, \fI\s-1PL_FILES\s0\fR,
\&\fI\s-1VERSION\s0\fR, \fI\s-1VERSION_FROM\s0\fR, \fIclean\fR, \fIdepend\fR, \fIrealclean\fR from
the ExtUtils::MakeMaker man page: these are used in almost any
\&\fIMakefile.PL\fR.
.PP
Additionally read the section on \fIOverriding MakeMaker Methods\fR and the
descriptions of the \fIdistcheck\fR, \fIdisttest\fR and \fIdist\fR targets: They
will definitely be useful for you.
.PP
Of special importance for \fB\s-1DBI\s0\fR drivers is the \fIpostamble\fR method from
the ExtUtils::MM_Unix man page.
.PP
For Emacs users, I recommend the \fIlibscan\fR method, which removes
Emacs backup files (file names which end with a tilde '~') from lists of
files.
.PP
Now an example, I use the word \f(CW\*(C`Driver\*(C'\fR wherever you should insert
your driver's name:
.PP
.Vb 1
\&  # \-*\- perl \-*\-
\&
\&  use ExtUtils::MakeMaker;
\&
\&  WriteMakefile(
\&      dbd_edit_mm_attribs( {
\&          \*(AqNAME\*(Aq         => \*(AqDBD::Driver\*(Aq,
\&          \*(AqVERSION_FROM\*(Aq => \*(AqDriver.pm\*(Aq,
\&          \*(AqINC\*(Aq          => \*(Aq\*(Aq,
\&          \*(Aqdist\*(Aq         => { \*(AqSUFFIX\*(Aq   => \*(Aq.gz\*(Aq,
\&                              \*(AqCOMPRESS\*(Aq => \*(Aqgzip \-9f\*(Aq },
\&          \*(Aqrealclean\*(Aq    => { FILES => \*(Aq*.xsi\*(Aq },
\&          \*(AqPREREQ_PM\*(Aq    => \*(Aq1.03\*(Aq,
\&          \*(AqCONFIGURE\*(Aq    => sub {
\&              eval {require DBI::DBD;};
\&              if ($@) {
\&                  warn $@;
\&                  exit 0;
\&              }
\&              my $dbi_arch_dir = dbd_dbi_arch_dir();
\&              if (exists($opts{INC})) {
\&                  return {INC => "$opts{INC} \-I$dbi_arch_dir"};
\&              } else {
\&                  return {INC => "\-I$dbi_arch_dir"};
\&              }
\&          }
\&      },
\&      { create_pp_tests => 1})
\&  );
\&
\&  package MY;
\&  sub postamble { return main::dbd_postamble(@_); }
\&  sub libscan {
\&      my ($self, $path) = @_;
\&      ($path =~ m/\e~$/) ? undef : $path;
\&  }
.Ve
.PP
Note the calls to \f(CW\*(C`dbd_edit_mm_attribs()\*(C'\fR and \f(CW\*(C`dbd_postamble()\*(C'\fR.
.PP
The second hash reference in the call to \f(CW\*(C`dbd_edit_mm_attribs()\*(C'\fR
(containing \f(CW\*(C`create_pp_tests()\*(C'\fR) is optional; you should not use it
unless your driver is a pure Perl driver (that is, it does not use C and
\&\s-1XS\s0 code). Therefore, the call to \f(CW\*(C`dbd_edit_mm_attribs()\*(C'\fR is not
relevant for C/XS drivers and may be omitted; simply use the (single)
hash reference containing \s-1NAME\s0 etc as the only argument to \f(CW\*(C`WriteMakefile()\*(C'\fR.
.PP
Note that the \f(CW\*(C`dbd_edit_mm_attribs()\*(C'\fR code will fail if you do not have a
\&\fIt\fR sub-directory containing at least one test case.
.PP
\&\fI\s-1PREREQ_PM\s0\fR tells MakeMaker that \s-1DBI \s0(version 1.03 in this case) is
required for this module. This will issue a warning that \s-1DBI 1.03\s0 is
missing if someone attempts to install your \s-1DBD\s0 without \s-1DBI 1.03.\s0 See
\&\fI\s-1CONFIGURE\s0\fR below for why this does not work reliably in stopping cpan
testers failing your module if \s-1DBI\s0 is not installed.
.PP
\&\fI\s-1CONFIGURE\s0\fR is a subroutine called by MakeMaker during
\&\f(CW\*(C`WriteMakefile\*(C'\fR.  By putting the \f(CW\*(C`require DBI::DBD\*(C'\fR in this section
we can attempt to load \s-1DBI::DBD\s0 but if it is missing we exit with
success. As we exit successfully without creating a Makefile when
\&\s-1DBI::DBD\s0 is missing cpan testers will not report a failure. This may
seem at odds with \fI\s-1PREREQ_PM\s0\fR but \fI\s-1PREREQ_PM\s0\fR does not cause
\&\f(CW\*(C`WriteMakefile\*(C'\fR to fail (unless you also specify \s-1PREREQ_FATAL\s0 which
is strongly discouraged by MakeMaker) so \f(CW\*(C`WriteMakefile\*(C'\fR would
continue to call \f(CW\*(C`dbd_dbi_arch_dir\*(C'\fR and fail.
.PP
All drivers must use \f(CW\*(C`dbd_postamble()\*(C'\fR or risk running into problems.
.PP
Note the specification of \fI\s-1VERSION_FROM\s0\fR; the named file
(\fIDriver.pm\fR) will be scanned for the first line that looks like an
assignment to \fI\f(CI$VERSION\fI\fR, and the subsequent text will be used to
determine the version number.  Note the commentary in
ExtUtils::MakeMaker on the subject of correctly formatted version
numbers.
.PP
If your driver depends upon external software (it usually will), you
will need to add code to ensure that your environment is workable
before the call to \f(CW\*(C`WriteMakefile()\*(C'\fR. If you need to check for the
existence of an external library and perhaps modify \fI\s-1INC\s0\fR to include
the paths to where the external library header files are located and
you cannot find the library or header files make sure you output a
message saying they cannot be found but \f(CW\*(C`exit 0\*(C'\fR (success) \fBbefore\fR
calling \f(CW\*(C`WriteMakefile\*(C'\fR or \s-1CPAN\s0 testers will fail your module if the
external library is not found.
.PP
A full-fledged \fIMakefile.PL\fR can be quite large (for example, the
files for \fBDBD::Oracle\fR and \fBDBD::Informix\fR are both over 1000 lines
long, and the Informix one uses \- and creates \- auxiliary modules
too).
.PP
See also ExtUtils::MakeMaker and ExtUtils::MM_Unix. Consider using
CPAN::MakeMaker in place of \fIExtUtils::MakeMaker\fR.
.SS "\s-1README\s0"
.IX Subsection "README"
The \s-1README\s0 file should describe what the driver is for, the
pre-requisites for the build process, the actual build process, how to
report errors, and who to report them to.
.PP
Users will find ways of breaking the driver build and test process
which you would never even have dreamed to be possible in your worst
nightmares. Therefore, you need to write this document defensively,
precisely and concisely.
.PP
As always, use the \fI\s-1README\s0\fR from one of the established drivers as a basis
for your own; the version in \fBDBD::Informix\fR is worth a look as it has
been quite successful in heading off problems.
.IP "\(bu" 4
Note that users will have versions of Perl and \fB\s-1DBI\s0\fR that are both older
and newer than you expected, but this will seldom cause much trouble.
When it does, it will be because you are using features of \fB\s-1DBI\s0\fR that are
not supported in the version they are using.
.IP "\(bu" 4
Note that users will have versions of the database software that are
both older and newer than you expected. You will save yourself time in
the long run if you can identify the range of versions which have been
tested and warn about versions which are not known to be \s-1OK.\s0
.IP "\(bu" 4
Note that many people trying to install your driver will not be experts
in the database software.
.IP "\(bu" 4
Note that many people trying to install your driver will not be experts
in C or Perl.
.SS "\s-1MANIFEST\s0"
.IX Subsection "MANIFEST"
The \fI\s-1MANIFEST\s0\fR will be used by the Makefile's dist target to build the
distribution tar file that is uploaded to \s-1CPAN.\s0 It should list every
file that you want to include in your distribution, one per line.
.SS "lib/Bundle/DBD/Driver.pm"
.IX Subsection "lib/Bundle/DBD/Driver.pm"
The \s-1CPAN\s0 module provides an extremely powerful bundle mechanism that
allows you to specify pre-requisites for your driver.
.PP
The primary pre-requisite is \fBBundle::DBI\fR; you may want or need to add
some more. With the bundle set up correctly, the user can type:
.PP
.Vb 1
\&        perl \-MCPAN \-e \*(Aqinstall Bundle::DBD::Driver\*(Aq
.Ve
.PP
and Perl will download, compile, test and install all the Perl modules
needed to build your driver.
.PP
The prerequisite modules are listed in the \f(CW\*(C`CONTENTS\*(C'\fR section, with the
official name of the module followed by a dash and an informal name or
description.
.IP "\(bu" 4
Listing \fBBundle::DBI\fR as the main pre-requisite simplifies life.
.IP "\(bu" 4
Don't forget to list your driver.
.IP "\(bu" 4
Note that unless the \s-1DBMS\s0 is itself a Perl module, you cannot list it as
a pre-requisite in this file.
.IP "\(bu" 4
You should keep the version of the bundle the same as the version of
your driver.
.IP "\(bu" 4
You should add configuration management, copyright, and licencing
information at the top.
.PP
A suitable skeleton for this file is shown below.
.PP
.Vb 1
\&  package Bundle::DBD::Driver;
\&
\&  $VERSION = \*(Aq0.01\*(Aq;
\&
\&  1;
\&
\&  _\|_END_\|_
\&
\&  =head1 NAME
\&
\&  Bundle::DBD::Driver \- A bundle to install all DBD::Driver related modules
\&
\&  =head1 SYNOPSIS
\&
\&  C<perl \-MCPAN \-e \*(Aqinstall Bundle::DBD::Driver\*(Aq>
\&
\&  =head1 CONTENTS
\&
\&  Bundle::DBI  \- Bundle for DBI by TIMB (Tim Bunce)
\&
\&  DBD::Driver  \- DBD::Driver by YOU (Your Name)
\&
\&  =head1 DESCRIPTION
\&
\&  This bundle includes all the modules used by the Perl Database
\&  Interface (DBI) driver for Driver (DBD::Driver), assuming the
\&  use of DBI version 1.13 or later, created by Tim Bunce.
\&
\&  If you\*(Aqve not previously used the CPAN module to install any
\&  bundles, you will be interrogated during its setup phase.
\&  But when you\*(Aqve done it once, it remembers what you told it.
\&  You could start by running:
\&
\&    C<perl \-MCPAN \-e \*(Aqinstall Bundle::CPAN\*(Aq>
\&
\&  =head1 SEE ALSO
\&
\&  Bundle::DBI
\&
\&  =head1 AUTHOR
\&
\&  Your Name E<lt>F<you@yourdomain.com>E<gt>
\&
\&  =head1 THANKS
\&
\&  This bundle was created by ripping off Bundle::libnet created by
\&  Graham Barr E<lt>F<gbarr@ti.com>E<gt>, and radically simplified
\&  with some information from Jochen Wiedmann E<lt>F<joe@ispsoft.de>E<gt>.
\&  The template was then included in the DBI::DBD documentation by
\&  Jonathan Leffler E<lt>F<jleffler@informix.com>E<gt>.
\&
\&  =cut
.Ve
.SS "lib/DBD/Driver/Summary.pm"
.IX Subsection "lib/DBD/Driver/Summary.pm"
There is no substitute for taking the summary file from a driver that
was documented in the Perl book (such as \fBDBD::Oracle\fR or \fBDBD::Informix\fR or
\&\fB\s-1DBD::ODBC\s0\fR, to name but three), and adapting it to describe the
facilities available via \fBDBD::Driver\fR when accessing the Driver database.
.SS "Pure Perl version of Driver.pm"
.IX Subsection "Pure Perl version of Driver.pm"
The \fIDriver.pm\fR file defines the Perl module \fBDBD::Driver\fR for your driver.
It will define a package \fBDBD::Driver\fR along with some version information,
some variable definitions, and a function \f(CW\*(C`driver()\*(C'\fR which will have a more
or less standard structure.
.PP
It will also define three sub-packages of \fBDBD::Driver\fR:
.IP "DBD::Driver::dr" 4
.IX Item "DBD::Driver::dr"
with methods \f(CW\*(C`connect()\*(C'\fR, \f(CW\*(C`data_sources()\*(C'\fR and \f(CW\*(C`disconnect_all()\*(C'\fR;
.IP "DBD::Driver::db" 4
.IX Item "DBD::Driver::db"
with methods such as \f(CW\*(C`prepare()\*(C'\fR;
.IP "DBD::Driver::st" 4
.IX Item "DBD::Driver::st"
with methods such as \f(CW\*(C`execute()\*(C'\fR and \f(CW\*(C`fetch()\*(C'\fR.
.PP
The \fIDriver.pm\fR file will also contain the documentation specific to
\&\fBDBD::Driver\fR in the format used by perldoc.
.PP
In a pure Perl driver, the \fIDriver.pm\fR file is the core of the
implementation. You will need to provide all the key methods needed by \fB\s-1DBI\s0\fR.
.PP
Now let's take a closer look at an excerpt of \fIFile.pm\fR as an example.
We ignore things that are common to any module (even non-DBI modules)
or really specific to the \fBDBD::File\fR package.
.PP
\fIThe DBD::Driver package\fR
.IX Subsection "The DBD::Driver package"
.PP
The header
.IX Subsection "The header"
.PP
.Vb 1
\&  package DBD::File;
\&
\&  use strict;
\&  use vars qw($VERSION $drh);
\&
\&  $VERSION = "1.23.00"  # Version number of DBD::File
.Ve
.PP
This is where the version number of your driver is specified, and is
where \fIMakefile.PL\fR looks for this information. Please ensure that any
other modules added with your driver are also version stamped so that
\&\s-1CPAN\s0 does not get confused.
.PP
It is recommended that you use a two-part (1.23) or three-part (1.23.45)
version number. Also consider the \s-1CPAN\s0 system, which gets confused and
considers version 1.10 to precede version 1.9, so that using a raw \s-1CVS,
RCS\s0 or \s-1SCCS\s0 version number is probably not appropriate (despite being
very common).
.PP
For Subversion you could use:
.PP
.Vb 1
\&  $VERSION = "12.012346";
.Ve
.PP
(use lots of leading zeros on the second portion so if you move the code to a
shared repository like svn.perl.org the much larger revision numbers won't
cause a problem, at least not for a few years).  For \s-1RCS\s0 or \s-1CVS\s0 you can use:
.PP
.Vb 1
\&  $VERSION = "11.22";
.Ve
.PP
which pads out the fractional part with leading zeros so all is well
(so long as you don't go past x.99)
.PP
.Vb 1
\&  $drh = undef;         # holds driver handle once initialized
.Ve
.PP
This is where the driver handle will be stored, once created.
Note that you may assume there is only one handle for your driver.
.PP
The driver constructor
.IX Subsection "The driver constructor"
.PP
The \f(CW\*(C`driver()\*(C'\fR method is the driver handle constructor. Note that
the \f(CW\*(C`driver()\*(C'\fR method is in the \fBDBD::Driver\fR package, not in
one of the sub-packages \fBDBD::Driver::dr\fR, \fBDBD::Driver::db\fR, or
\&\fBDBD::Driver::db\fR.
.PP
.Vb 4
\&  sub driver
\&  {
\&      return $drh if $drh;      # already created \- return same one
\&      my ($class, $attr) = @_;
\&
\&      $class .= "::dr";
\&
\&      DBD::Driver::db\->install_method(\*(Aqdrv_example_dbh_method\*(Aq);
\&      DBD::Driver::st\->install_method(\*(Aqdrv_example_sth_method\*(Aq);
\&
\&      # not a \*(Aqmy\*(Aq since we use it above to prevent multiple drivers
\&      $drh = DBI::_new_drh($class, {
\&              \*(AqName\*(Aq        => \*(AqFile\*(Aq,
\&              \*(AqVersion\*(Aq     => $VERSION,
\&              \*(AqAttribution\*(Aq => \*(AqDBD::File by Jochen Wiedmann\*(Aq,
\&          })
\&          or return undef;
\&
\&      return $drh;
\&  }
.Ve
.PP
This is a reasonable example of how \fB\s-1DBI\s0\fR implements its handles. There
are three kinds: \fBdriver handles\fR (typically stored in \fI\f(CI$drh\fI\fR; from
now on called \fIdrh\fR or \fI\f(CI$drh\fI\fR), \fBdatabase handles\fR (from now on
called \fIdbh\fR or \fI\f(CI$dbh\fI\fR) and \fBstatement handles\fR (from now on called
\&\fIsth\fR or \fI\f(CI$sth\fI\fR).
.PP
The prototype of \f(CW\*(C`DBI::_new_drh()\*(C'\fR is
.PP
.Vb 1
\&  $drh = DBI::_new_drh($class, $public_attrs, $private_attrs);
.Ve
.PP
with the following arguments:
.ie n .IP "\fI\fI$class\fI\fR" 4
.el .IP "\fI\f(CI$class\fI\fR" 4
.IX Item "$class"
is typically the class for your driver, (for example, \*(L"DBD::File::dr\*(R"),
passed as the first argument to the \f(CW\*(C`driver()\*(C'\fR method.
.ie n .IP "\fI\fI$public_attrs\fI\fR" 4
.el .IP "\fI\f(CI$public_attrs\fI\fR" 4
.IX Item "$public_attrs"
is a hash ref to attributes like \fIName\fR, \fIVersion\fR, and \fIAttribution\fR.
These are processed and used by \fB\s-1DBI\s0\fR. You had better not make any
assumptions about them nor should you add private attributes here.
.ie n .IP "\fI\fI$private_attrs\fI\fR" 4
.el .IP "\fI\f(CI$private_attrs\fI\fR" 4
.IX Item "$private_attrs"
This is another (optional) hash ref with your private attributes.
\&\fB\s-1DBI\s0\fR will store them and otherwise leave them alone.
.PP
The \f(CW\*(C`DBI::_new_drh()\*(C'\fR method and the \f(CW\*(C`driver()\*(C'\fR method both return \f(CW\*(C`undef\*(C'\fR
for failure (in which case you must look at \fI\f(CI$DBI::err\fI\fR and \fI\f(CI$DBI::errstr\fI\fR
for the failure information, because you have no driver handle to use).
.PP
Using \fIinstall_method()\fR to expose driver-private methods
.IX Subsection "Using install_method() to expose driver-private methods"
.PP
.Vb 1
\&    DBD::Foo::db\->install_method($method_name, \e%attr);
.Ve
.PP
Installs the driver-private method named by \f(CW$method_name\fR into the
\&\s-1DBI\s0 method dispatcher so it can be called directly, avoiding the
need to use the \fIfunc()\fR method.
.PP
It is called as a static method on the driver class to which the
method belongs. The method name must begin with the corresponding
registered driver-private prefix. For example, for DBD::Oracle
\&\f(CW$method_name\fR must being with '\f(CW\*(C`ora_\*(C'\fR', and for DBD::AnyData it
must begin with '\f(CW\*(C`ad_\*(C'\fR'.
.PP
The \f(CW\*(C`\e%attr\*(C'\fR attributes can be used to provide fine control over how the \s-1DBI\s0
dispatcher handles the dispatching of the method. However it's undocumented
at the moment. See the IMA_* #define's in \s-1DBI\s0.xs and the O=>0x000x values in
the initialization of \f(CW%DBI::DBI_methods\fR in \s-1DBI\s0.pm.  (Volunteers to polish up
and document the interface are very welcome to get in touch via dbi\-dev@perl.org).
.PP
Methods installed using install_method default to the standard error
handling behaviour for \s-1DBI\s0 methods: clearing err and errstr before
calling the method, and checking for errors to trigger RaiseError
etc. on return. This differs from the default behaviour of \fIfunc()\fR.
.PP
Note for driver authors: The DBD::Foo::xx\->install_method call won't
work until the class-hierarchy has been setup. Normally the \s-1DBI\s0
looks after that just after the driver is loaded. This means
\&\fIinstall_method()\fR can't be called at the time the driver is loaded
unless the class-hierarchy is set up first. The way to do that is
to call the \fIsetup_driver()\fR method:
.PP
.Vb 1
\&    DBI\->setup_driver(\*(AqDBD::Foo\*(Aq);
.Ve
.PP
before using \fIinstall_method()\fR.
.PP
The \s-1CLONE\s0 special subroutine
.IX Subsection "The CLONE special subroutine"
.PP
Also needed here, in the \fBDBD::Driver\fR package, is a \f(CW\*(C`CLONE()\*(C'\fR method
that will be called by perl when an interpreter is cloned. All your
\&\f(CW\*(C`CLONE()\*(C'\fR method needs to do, currently, is clear the cached \fI\f(CI$drh\fI\fR so
the new interpreter won't start using the cached \fI\f(CI$drh\fI\fR from the old
interpreter:
.PP
.Vb 3
\&  sub CLONE {
\&    undef $drh;
\&  }
.Ve
.PP
See <http://search.cpan.org/dist/perl/pod/perlmod.pod#Making_your_module_threadsafe>
for details.
.PP
\fIThe DBD::Driver::dr package\fR
.IX Subsection "The DBD::Driver::dr package"
.PP
The next lines of code look as follows:
.PP
.Vb 1
\&  package DBD::Driver::dr; # ====== DRIVER ======
\&
\&  $DBD::Driver::dr::imp_data_size = 0;
.Ve
.PP
Note that no \fI\f(CI@ISA\fI\fR is needed here, or for the other \fBDBD::Driver::*\fR
classes, because the \fB\s-1DBI\s0\fR takes care of that for you when the driver is
loaded.
.PP
.Vb 2
\& *FIX ME* Explain what the imp_data_size is, so that implementors aren\*(Aqt
\& practicing cargo\-cult programming.
.Ve
.PP
The database handle constructor
.IX Subsection "The database handle constructor"
.PP
The database handle constructor is the driver's (hence the changed
namespace) \f(CW\*(C`connect()\*(C'\fR method:
.PP
.Vb 3
\&  sub connect
\&  {
\&      my ($drh, $dr_dsn, $user, $auth, $attr) = @_;
\&
\&      # Some database specific verifications, default settings
\&      # and the like can go here. This should only include
\&      # syntax checks or similar stuff where it\*(Aqs legal to
\&      # \*(Aqdie\*(Aq in case of errors.
\&      # For example, many database packages requires specific
\&      # environment variables to be set; this could be where you
\&      # validate that they are set, or default them if they are not set.
\&
\&      my $driver_prefix = "drv_"; # the assigned prefix for this driver
\&
\&      # Process attributes from the DSN; we assume ODBC syntax
\&      # here, that is, the DSN looks like var1=val1;...;varN=valN
\&      foreach my $var ( split /;/, $dr_dsn ) {
\&          my ($attr_name, $attr_value) = split \*(Aq=\*(Aq, $var, 2;
\&          return $drh\->set_err($DBI::stderr, "Can\*(Aqt parse DSN part \*(Aq$var\*(Aq")
\&              unless defined $attr_value;
\&
\&          # add driver prefix to attribute name if it doesn\*(Aqt have it already
\&          $attr_name = $driver_prefix.$attr_name
\&              unless $attr_name =~ /^$driver_prefix/o;
\&
\&          # Store attribute into %$attr, replacing any existing value.
\&          # The DBI will STORE() these into $dbh after we\*(Aqve connected
\&          $attr\->{$attr_name} = $attr_value;
\&      }
\&
\&      # Get the attributes we\*(Aqll use to connect.
\&      # We use delete here because these no need to STORE them
\&      my $db = delete $attr\->{drv_database} || delete $attr\->{drv_db}
\&          or return $drh\->set_err($DBI::stderr, "No database name given in DSN \*(Aq$dr_dsn\*(Aq");
\&      my $host = delete $attr\->{drv_host} || \*(Aqlocalhost\*(Aq;
\&      my $port = delete $attr\->{drv_port} || 123456;
\&
\&      # Assume you can attach to your database via drv_connect:
\&      my $connection = drv_connect($db, $host, $port, $user, $auth)
\&          or return $drh\->set_err($DBI::stderr, "Can\*(Aqt connect to $dr_dsn: ...");
\&
\&      # create a \*(Aqblank\*(Aq dbh (call superclass constructor)
\&      my ($outer, $dbh) = DBI::_new_dbh($drh, { Name => $dr_dsn });
\&
\&      $dbh\->STORE(\*(AqActive\*(Aq, 1 );
\&      $dbh\->{drv_connection} = $connection;
\&
\&      return $outer;
\&  }
.Ve
.PP
This is mostly the same as in the \fIdriver handle constructor\fR above.
The arguments are described in \s-1DBI\s0.
.PP
The constructor \f(CW\*(C`DBI::_new_dbh()\*(C'\fR is called, returning a database handle.
The constructor's prototype is:
.PP
.Vb 1
\&  ($outer, $inner) = DBI::_new_dbh($drh, $public_attr, $private_attr);
.Ve
.PP
with similar arguments to those in the \fIdriver handle constructor\fR,
except that the \fI\f(CI$class\fI\fR is replaced by \fI\f(CI$drh\fI\fR. The \fIName\fR attribute
is a standard \fB\s-1DBI\s0\fR attribute (see \*(L"Database Handle Attributes\*(R" in \s-1DBI\s0).
.PP
In scalar context, only the outer handle is returned.
.PP
Note the use of the \f(CW\*(C`STORE()\*(C'\fR method for setting the \fIdbh\fR attributes.
That's because within the driver code, the handle object you have is
the 'inner' handle of a tied hash, not the outer handle that the
users of your driver have.
.PP
Because you have the inner handle, tie magic doesn't get invoked
when you get or set values in the hash. This is often very handy for
speed when you want to get or set simple non-special driver-specific
attributes.
.PP
However, some attribute values, such as those handled by the \fB\s-1DBI\s0\fR like
\&\fIPrintError\fR, don't actually exist in the hash and must be read via
\&\f(CW\*(C`$h\->FETCH($attrib)\*(C'\fR and set via \f(CW\*(C`$h\->STORE($attrib, $value)\*(C'\fR.
If in any doubt, use these methods.
.PP
The \fIdata_sources()\fR method
.IX Subsection "The data_sources() method"
.PP
The \f(CW\*(C`data_sources()\*(C'\fR method must populate and return a list of valid data
sources, prefixed with the "\fIdbi:Driver\fR" incantation that allows them to
be used in the first argument of the \f(CW\*(C`DBI\->connect()\*(C'\fR method.
An example of this might be scanning the \fI\f(CI$HOME\fI/.odbcini\fR file on Unix
for \s-1ODBC\s0 data sources (DSNs).
.PP
As a trivial example, consider a fixed list of data sources:
.PP
.Vb 11
\&  sub data_sources
\&  {
\&      my($drh, $attr) = @_;
\&      my(@list) = ();
\&      # You need more sophisticated code than this to set @list...
\&      push @list, "dbi:Driver:abc";
\&      push @list, "dbi:Driver:def";
\&      push @list, "dbi:Driver:ghi";
\&      # End of code to set @list
\&      return @list;
\&  }
.Ve
.PP
The \fIdisconnect_all()\fR method
.IX Subsection "The disconnect_all() method"
.PP
If you need to release any resources when the driver is unloaded, you
can provide a disconnect_all method.
.PP
Other driver handle methods
.IX Subsection "Other driver handle methods"
.PP
If you need any other driver handle methods, they can follow here.
.PP
Error handling
.IX Subsection "Error handling"
.PP
It is quite likely that something fails in the connect method.
With \fBDBD::File\fR for example, you might catch an error when setting the
current directory to something not existent by using the
(driver-specific) \fIf_dir\fR attribute.
.PP
To report an error, you use the \f(CW\*(C`set_err()\*(C'\fR method:
.PP
.Vb 1
\&  $h\->set_err($err, $errmsg, $state);
.Ve
.PP
This will ensure that the error is recorded correctly and that
\&\fIRaiseError\fR and \fIPrintError\fR etc are handled correctly.
.PP
Typically you'll always use the method instance, aka your method's first
argument.
.PP
As \f(CW\*(C`set_err()\*(C'\fR always returns \f(CW\*(C`undef\*(C'\fR your error handling code can
usually be simplified to something like this:
.PP
.Vb 1
\&  return $h\->set_err($err, $errmsg, $state) if ...;
.Ve
.PP
\fIThe DBD::Driver::db package\fR
.IX Subsection "The DBD::Driver::db package"
.PP
.Vb 1
\&  package DBD::Driver::db; # ====== DATABASE ======
\&
\&  $DBD::Driver::db::imp_data_size = 0;
.Ve
.PP
The statement handle constructor
.IX Subsection "The statement handle constructor"
.PP
There's nothing much new in the statement handle constructor, which
is the \f(CW\*(C`prepare()\*(C'\fR method:
.PP
.Vb 3
\&  sub prepare
\&  {
\&      my ($dbh, $statement, @attribs) = @_;
\&
\&      # create a \*(Aqblank\*(Aq sth
\&      my ($outer, $sth) = DBI::_new_sth($dbh, { Statement => $statement });
\&
\&      $sth\->STORE(\*(AqNUM_OF_PARAMS\*(Aq, ($statement =~ tr/?//));
\&
\&      $sth\->{drv_params} = [];
\&
\&      return $outer;
\&  }
.Ve
.PP
This is still the same \*(-- check the arguments and call the super class
constructor \f(CW\*(C`DBI::_new_sth()\*(C'\fR. Again, in scalar context, only the outer
handle is returned. The \fIStatement\fR attribute should be cached as
shown.
.PP
Note the prefix \fIdrv_\fR in the attribute names: it is required that
all your private attributes use a lowercase prefix unique to your driver.
As mentioned earlier in this document, the \fB\s-1DBI\s0\fR contains a registry of
known driver prefixes and may one day warn about unknown attributes
that don't have a registered prefix.
.PP
Note that we parse the statement here in order to set the attribute
\&\fI\s-1NUM_OF_PARAMS\s0\fR. The technique illustrated is not very reliable; it can
be confused by question marks appearing in quoted strings, delimited
identifiers or in \s-1SQL\s0 comments that are part of the \s-1SQL\s0 statement. We
could set \fI\s-1NUM_OF_PARAMS\s0\fR in the \f(CW\*(C`execute()\*(C'\fR method instead because
the \fB\s-1DBI\s0\fR specification explicitly allows a driver to defer this, but then
the user could not call \f(CW\*(C`bind_param()\*(C'\fR.
.PP
Transaction handling
.IX Subsection "Transaction handling"
.PP
Pure Perl drivers will rarely support transactions. Thus your \f(CW\*(C`commit()\*(C'\fR
and \f(CW\*(C`rollback()\*(C'\fR methods will typically be quite simple:
.PP
.Vb 8
\&  sub commit
\&  {
\&      my ($dbh) = @_;
\&      if ($dbh\->FETCH(\*(AqWarn\*(Aq)) {
\&          warn("Commit ineffective while AutoCommit is on");
\&      }
\&      0;
\&  }
\&
\&  sub rollback {
\&      my ($dbh) = @_;
\&      if ($dbh\->FETCH(\*(AqWarn\*(Aq)) {
\&          warn("Rollback ineffective while AutoCommit is on");
\&      }
\&      0;
\&  }
.Ve
.PP
Or even simpler, just use the default methods provided by the \fB\s-1DBI\s0\fR that
do nothing except return \f(CW\*(C`undef\*(C'\fR.
.PP
The \fB\s-1DBI\s0\fR's default \f(CW\*(C`begin_work()\*(C'\fR method can be used by inheritance.
.PP
The \s-1\fISTORE\s0()\fR and \s-1\fIFETCH\s0()\fR methods
.IX Subsection "The STORE() and FETCH() methods"
.PP
These methods (that we have already used, see above) are called for
you, whenever the user does a:
.PP
.Vb 1
\&  $dbh\->{$attr} = $val;
.Ve
.PP
or, respectively,
.PP
.Vb 1
\&  $val = $dbh\->{$attr};
.Ve
.PP
See perltie for details on tied hash refs to understand why these
methods are required.
.PP
The \fB\s-1DBI\s0\fR will handle most attributes for you, in particular attributes
like \fIRaiseError\fR or \fIPrintError\fR. All you have to do is handle your
driver's private attributes and any attributes, like \fIAutoCommit\fR and
\&\fIChopBlanks\fR, that the \fB\s-1DBI\s0\fR can't handle for you.
.PP
A good example might look like this:
.PP
.Vb 10
\&  sub STORE
\&  {
\&      my ($dbh, $attr, $val) = @_;
\&      if ($attr eq \*(AqAutoCommit\*(Aq) {
\&          # AutoCommit is currently the only standard attribute we have
\&          # to consider.
\&          if (!$val) { die "Can\*(Aqt disable AutoCommit"; }
\&          return 1;
\&      }
\&      if ($attr =~ m/^drv_/) {
\&          # Handle only our private attributes here
\&          # Note that we could trigger arbitrary actions.
\&          # Ideally we should warn about unknown attributes.
\&          $dbh\->{$attr} = $val; # Yes, we are allowed to do this,
\&          return 1;             # but only for our private attributes
\&      }
\&      # Else pass up to DBI to handle for us
\&      $dbh\->SUPER::STORE($attr, $val);
\&  }
\&
\&  sub FETCH
\&  {
\&      my ($dbh, $attr) = @_;
\&      if ($attr eq \*(AqAutoCommit\*(Aq) { return 1; }
\&      if ($attr =~ m/^drv_/) {
\&          # Handle only our private attributes here
\&          # Note that we could trigger arbitrary actions.
\&          return $dbh\->{$attr}; # Yes, we are allowed to do this,
\&                                # but only for our private attributes
\&      }
\&      # Else pass up to DBI to handle
\&      $dbh\->SUPER::FETCH($attr);
\&  }
.Ve
.PP
The \fB\s-1DBI\s0\fR will actually store and fetch driver-specific attributes (with all
lowercase names) without warning or error, so there's actually no need to
implement driver-specific any code in your \f(CW\*(C`FETCH()\*(C'\fR and \f(CW\*(C`STORE()\*(C'\fR
methods unless you need extra logic/checks, beyond getting or setting
the value.
.PP
Unless your driver documentation indicates otherwise, the return value of
the \f(CW\*(C`STORE()\*(C'\fR method is unspecified and the caller shouldn't use that value.
.PP
Other database handle methods
.IX Subsection "Other database handle methods"
.PP
As with the driver package, other database handle methods may follow here.
In particular you should consider a (possibly empty) \f(CW\*(C`disconnect()\*(C'\fR
method and possibly a \f(CW\*(C`quote()\*(C'\fR method if \fB\s-1DBI\s0\fR's default isn't correct for
you. You may also need the \f(CW\*(C`type_info_all()\*(C'\fR and \f(CW\*(C`get_info()\*(C'\fR methods,
as described elsewhere in this document.
.PP
Where reasonable use \f(CW\*(C`$h\->SUPER::foo()\*(C'\fR to call the \fB\s-1DBI\s0\fR's method in
some or all cases and just wrap your custom behavior around that.
.PP
If you want to use private trace flags you'll probably want to be
able to set them by name. To do that you'll need to define a
\&\f(CW\*(C`parse_trace_flag()\*(C'\fR method (note that's \*(L"parse_trace_flag\*(R", singular,
not \*(L"parse_trace_flags\*(R", plural).
.PP
.Vb 9
\&  sub parse_trace_flag {
\&      my ($h, $name) = @_;
\&      return 0x01000000 if $name eq \*(Aqfoo\*(Aq;
\&      return 0x02000000 if $name eq \*(Aqbar\*(Aq;
\&      return 0x04000000 if $name eq \*(Aqbaz\*(Aq;
\&      return 0x08000000 if $name eq \*(Aqboo\*(Aq;
\&      return 0x10000000 if $name eq \*(Aqbop\*(Aq;
\&      return $h\->SUPER::parse_trace_flag($name);
\&  }
.Ve
.PP
All private flag names must be lowercase, and all private flags
must be in the top 8 of the 32 bits.
.PP
\fIThe DBD::Driver::st package\fR
.IX Subsection "The DBD::Driver::st package"
.PP
This package follows the same pattern the others do:
.PP
.Vb 1
\&  package DBD::Driver::st;
\&
\&  $DBD::Driver::st::imp_data_size = 0;
.Ve
.PP
The \fIexecute()\fR and \fIbind_param()\fR methods
.IX Subsection "The execute() and bind_param() methods"
.PP
This is perhaps the most difficult method because we have to consider
parameter bindings here. In addition to that, there are a number of
statement attributes which must be set for inherited \fB\s-1DBI\s0\fR methods to
function correctly (see \*(L"Statement attributes\*(R" below).
.PP
We present a simplified implementation by using the \fIdrv_params\fR
attribute from above:
.PP
.Vb 12
\&  sub bind_param
\&  {
\&      my ($sth, $pNum, $val, $attr) = @_;
\&      my $type = (ref $attr) ? $attr\->{TYPE} : $attr;
\&      if ($type) {
\&          my $dbh = $sth\->{Database};
\&          $val = $dbh\->quote($sth, $type);
\&      }
\&      my $params = $sth\->{drv_params};
\&      $params\->[$pNum\-1] = $val;
\&      1;
\&  }
\&
\&  sub execute
\&  {
\&      my ($sth, @bind_values) = @_;
\&
\&      # start of by finishing any previous execution if still active
\&      $sth\->finish if $sth\->FETCH(\*(AqActive\*(Aq);
\&
\&      my $params = (@bind_values) ?
\&          \e@bind_values : $sth\->{drv_params};
\&      my $numParam = $sth\->FETCH(\*(AqNUM_OF_PARAMS\*(Aq);
\&      return $sth\->set_err($DBI::stderr, "Wrong number of parameters")
\&          if @$params != $numParam;
\&      my $statement = $sth\->{\*(AqStatement\*(Aq};
\&      for (my $i = 0;  $i < $numParam;  $i++) {
\&          $statement =~ s/?/$params\->[$i]/; # XXX doesn\*(Aqt deal with quoting etc!
\&      }
\&      # Do anything ... we assume that an array ref of rows is
\&      # created and store it:
\&      $sth\->{\*(Aqdrv_data\*(Aq} = $data;
\&      $sth\->{\*(Aqdrv_rows\*(Aq} = @$data; # number of rows
\&      $sth\->STORE(\*(AqNUM_OF_FIELDS\*(Aq) = $numFields;
\&      $sth\->{Active} = 1;
\&      @$data || \*(Aq0E0\*(Aq;
\&  }
.Ve
.PP
There are a number of things you should note here.
.PP
We initialize the \fI\s-1NUM_OF_FIELDS\s0\fR and \fIActive\fR attributes here,
because they are essential for \f(CW\*(C`bind_columns()\*(C'\fR to work.
.PP
We use attribute \f(CW\*(C`$sth\->{Statement}\*(C'\fR which we created
within \f(CW\*(C`prepare()\*(C'\fR. The attribute \f(CW\*(C`$sth\->{Database}\*(C'\fR, which is
nothing else than the \fIdbh\fR, was automatically created by \fB\s-1DBI\s0\fR.
.PP
Finally, note that (as specified in the \fB\s-1DBI\s0\fR specification) we return the
string \f(CW\*(Aq0E0\*(Aq\fR instead of the number 0, so that the result tests true but
equal to zero.
.PP
.Vb 1
\&  $sth\->execute() or die $sth\->errstr;
.Ve
.PP
The \fIexecute_array()\fR, \fIexecute_for_fetch()\fR and \fIbind_param_array()\fR methods
.IX Subsection "The execute_array(), execute_for_fetch() and bind_param_array() methods"
.PP
In general, \s-1DBD\s0's only need to implement \f(CW\*(C`execute_for_fetch()\*(C'\fR and
\&\f(CW\*(C`bind_param_array\*(C'\fR. \s-1DBI\s0's default \f(CW\*(C`execute_array()\*(C'\fR will invoke the
\&\s-1DBD\s0's \f(CW\*(C`execute_for_fetch()\*(C'\fR as needed.
.PP
The following sequence describes the interaction between
\&\s-1DBI \s0\f(CW\*(C`execute_array\*(C'\fR and a \s-1DBD\s0's \f(CW\*(C`execute_for_fetch\*(C'\fR:
.IP "1." 4
App calls \f(CW\*(C`$sth\->execute_array(\e%attrs, @array_of_arrays)\*(C'\fR
.IP "2." 4
If \f(CW@array_of_arrays\fR was specified, \s-1DBI\s0 processes \f(CW@array_of_arrays\fR by calling
\&\s-1DBD\s0's \f(CW\*(C`bind_param_array()\*(C'\fR. Alternately, App may have directly called
\&\f(CW\*(C`bind_param_array()\*(C'\fR
.IP "3." 4
\&\s-1DBD\s0 validates and binds each array
.IP "4." 4
\&\s-1DBI\s0 retrieves the validated param arrays from \s-1DBD\s0's ParamArray attribute
.IP "5." 4
\&\s-1DBI\s0 calls \s-1DBD\s0's \f(CW\*(C`execute_for_fetch($fetch_tuple_sub, \e@tuple_status)\*(C'\fR,
where \f(CW&$fetch_tuple_sub\fR is a closure to iterate over the
returned ParamArray values, and \f(CW\*(C`\e@tuple_status\*(C'\fR is an array to receive
the disposition status of each tuple.
.IP "6." 4
\&\s-1DBD\s0 iteratively calls \f(CW&$fetch_tuple_sub\fR to retrieve parameter tuples
to be added to its bulk database operation/request.
.IP "7." 4
when \s-1DBD\s0 reaches the limit of tuples it can handle in a single database
operation/request, or the \f(CW&$fetch_tuple_sub\fR indicates no more
tuples by returning undef, the \s-1DBD\s0 executes the bulk operation, and
reports the disposition of each tuple in \e@tuple_status.
.IP "8." 4
\&\s-1DBD\s0 repeats steps 6 and 7 until all tuples are processed.
.PP
E.g., here's the essence of DBD::Oracle's execute_for_fetch:
.PP
.Vb 10
\&       while (1) {
\&           my @tuple_batch;
\&           for (my $i = 0; $i < $batch_size; $i++) {
\&                push @tuple_batch, [ @{$fetch_tuple_sub\->() || last} ];
\&           }
\&           last unless @tuple_batch;
\&           my $res = ora_execute_array($sth, \e@tuple_batch,
\&              scalar(@tuple_batch), $tuple_batch_status);
\&           push @$tuple_status, @$tuple_batch_status;
\&       }
.Ve
.PP
Note that \s-1DBI\s0's default \fIexecute_array()\fR/\fIexecute_for_fetch()\fR implementation
requires the use of positional (i.e., '?') placeholders. Drivers
which \fBrequire\fR named placeholders must either emulate positional
placeholders (e.g., see DBD::Oracle), or must implement their own
\&\fIexecute_array()\fR/\fIexecute_for_fetch()\fR methods to properly sequence bound
parameter arrays.
.PP
Fetching data
.IX Subsection "Fetching data"
.PP
Only one method needs to be written for fetching data, \f(CW\*(C`fetchrow_arrayref()\*(C'\fR.
The other methods, \f(CW\*(C`fetchrow_array()\*(C'\fR, \f(CW\*(C`fetchall_arrayref()\*(C'\fR, etc, as well
as the database handle's \f(CW\*(C`select*\*(C'\fR methods are part of \fB\s-1DBI\s0\fR, and call
\&\f(CW\*(C`fetchrow_arrayref()\*(C'\fR as necessary.
.PP
.Vb 10
\&  sub fetchrow_arrayref
\&  {
\&      my ($sth) = @_;
\&      my $data = $sth\->{drv_data};
\&      my $row = shift @$data;
\&      if (!$row) {
\&          $sth\->STORE(Active => 0); # mark as no longer active
\&          return undef;
\&      }
\&      if ($sth\->FETCH(\*(AqChopBlanks\*(Aq)) {
\&          map { $_ =~ s/\es+$//; } @$row;
\&      }
\&      return $sth\->_set_fbav($row);
\&  }
\&  *fetch = \e&fetchrow_arrayref; # required alias for fetchrow_arrayref
.Ve
.PP
Note the use of the method \f(CW\*(C`_set_fbav()\*(C'\fR \*(-- this is required so that
\&\f(CW\*(C`bind_col()\*(C'\fR and \f(CW\*(C`bind_columns()\*(C'\fR work.
.PP
If an error occurs which leaves the \fI\f(CI$sth\fI\fR in a state where remaining rows
can't be fetched then \fIActive\fR should be turned off before the method returns.
.PP
The \f(CW\*(C`rows()\*(C'\fR method for this driver can be implemented like this:
.PP
.Vb 1
\&  sub rows { shift\->{drv_rows} }
.Ve
.PP
because it knows in advance how many rows it has fetched.
Alternatively you could delete that method and so fallback
to the \fB\s-1DBI\s0\fR's own method which does the right thing based
on the number of calls to \f(CW\*(C`_set_fbav()\*(C'\fR.
.PP
The more_results method
.IX Subsection "The more_results method"
.PP
If your driver doesn't support multiple result sets, then don't even implement this method.
.PP
Otherwise, this method needs to get the statement handle ready to fetch results
from the next result set, if there is one. Typically you'd start with:
.PP
.Vb 1
\&    $sth\->finish;
.Ve
.PP
then you should delete all the attributes from the attribute cache that may no
longer be relevant for the new result set:
.PP
.Vb 2
\&    delete $sth\->{$_}
\&        for qw(NAME TYPE PRECISION SCALE ...);
.Ve
.PP
for drivers written in C use:
.PP
.Vb 6
\&    hv_delete((HV*)SvRV(sth), "NAME", 4, G_DISCARD);
\&    hv_delete((HV*)SvRV(sth), "NULLABLE", 8, G_DISCARD);
\&    hv_delete((HV*)SvRV(sth), "NUM_OF_FIELDS", 13, G_DISCARD);
\&    hv_delete((HV*)SvRV(sth), "PRECISION", 9, G_DISCARD);
\&    hv_delete((HV*)SvRV(sth), "SCALE", 5, G_DISCARD);
\&    hv_delete((HV*)SvRV(sth), "TYPE", 4, G_DISCARD);
.Ve
.PP
Don't forget to also delete, or update, any driver-private attributes that may
not be correct for the next resultset.
.PP
The \s-1NUM_OF_FIELDS\s0 attribute is a special case. It should be set using \s-1STORE:\s0
.PP
.Vb 2
\&    $sth\->STORE(NUM_OF_FIELDS => 0); /* for DBI <= 1.53 */
\&    $sth\->STORE(NUM_OF_FIELDS => $new_value);
.Ve
.PP
for drivers written in C use this incantation:
.PP
.Vb 5
\&    /* Adjust NUM_OF_FIELDS \- which also adjusts the row buffer size */
\&    DBIc_NUM_FIELDS(imp_sth) = 0; /* for DBI <= 1.53 */
\&    DBIc_STATE(imp_xxh)\->set_attr_k(sth, sv_2mortal(newSVpvn("NUM_OF_FIELDS",13)), 0,
\&        sv_2mortal(newSViv(mysql_num_fields(imp_sth\->result)))
\&    );
.Ve
.PP
For \s-1DBI\s0 versions prior to 1.54 you'll also need to explicitly adjust the
number of elements in the row buffer array (\f(CW\*(C`DBIc_FIELDS_AV(imp_sth)\*(C'\fR)
to match the new result set. Fill any new values with \fInewSV\fR\|(0) not &sv_undef.
Alternatively you could free DBIc_FIELDS_AV(imp_sth) and set it to null,
but that would mean \fIbind_columns()\fR wouldn't work across result sets.
.PP
Statement attributes
.IX Subsection "Statement attributes"
.PP
The main difference between \fIdbh\fR and \fIsth\fR attributes is, that you
should implement a lot of attributes here that are required by
the \fB\s-1DBI\s0\fR, such as \fI\s-1NAME\s0\fR, \fI\s-1NULLABLE\s0\fR, \fI\s-1TYPE\s0\fR, etc. See
\&\*(L"Statement Handle Attributes\*(R" in \s-1DBI\s0 for a complete list.
.PP
Pay attention to attributes which are marked as read only, such as
\&\fI\s-1NUM_OF_PARAMS\s0\fR. These attributes can only be set the first time
a statement is executed. If a statement is prepared, then executed
multiple times, warnings may be generated.
.PP
You can protect against these warnings, and prevent the recalculation
of attributes which might be expensive to calculate (such as the
\&\fI\s-1NAME\s0\fR and \fINAME_*\fR attributes):
.PP
.Vb 3
\&    my $storedNumParams = $sth\->FETCH(\*(AqNUM_OF_PARAMS\*(Aq);
\&    if (!defined $storedNumParams or $storedNumFields < 0) {
\&        $sth\->STORE(\*(AqNUM_OF_PARAMS\*(Aq) = $numParams;
\&
\&        # Set other useful attributes that only need to be set once
\&        # for a statement, like $sth\->{NAME} and $sth\->{TYPE}
\&    }
.Ve
.PP
One particularly important attribute to set correctly (mentioned in
\&\*(L"\s-1ATTRIBUTES COMMON TO ALL HANDLES\*(R"\s0 in \s-1DBI\s0 is \fIActive\fR. Many \fB\s-1DBI\s0\fR methods,
including \f(CW\*(C`bind_columns()\*(C'\fR, depend on this attribute.
.PP
Besides that the \f(CW\*(C`STORE()\*(C'\fR and \f(CW\*(C`FETCH()\*(C'\fR methods are mainly the same
as above for \fIdbh\fR's.
.PP
Other statement methods
.IX Subsection "Other statement methods"
.PP
A trivial \f(CW\*(C`finish()\*(C'\fR method to discard stored data, reset any attributes
(such as \fIActive\fR) and do \f(CW\*(C`$sth\->SUPER::finish()\*(C'\fR.
.PP
If you've defined a \f(CW\*(C`parse_trace_flag()\*(C'\fR method in \fB::db\fR you'll also want
it in \fB::st\fR, so just alias it in:
.PP
.Vb 1
\&  *parse_trace_flag = \e&DBD::foo:db::parse_trace_flag;
.Ve
.PP
And perhaps some other methods that are not part of the \fB\s-1DBI\s0\fR
specification, in particular to make metadata available.
Remember that they must have names that begin with your drivers
registered prefix so they can be installed using \f(CW\*(C`install_method()\*(C'\fR.
.PP
If \f(CW\*(C`DESTROY()\*(C'\fR is called on a statement handle that's still active
(\f(CW\*(C`$sth\->{Active}\*(C'\fR is true) then it should effectively call \f(CW\*(C`finish()\*(C'\fR.
.PP
.Vb 4
\&    sub DESTROY {
\&        my $sth = shift;
\&        $sth\->finish if $sth\->FETCH(\*(AqActive\*(Aq);
\&    }
.Ve
.SS "Tests"
.IX Subsection "Tests"
The test process should conform as closely as possibly to the Perl
standard test harness.
.PP
In particular, most (all) of the tests should be run in the \fIt\fR sub-directory,
and should simply produce an \f(CW\*(C`ok\*(C'\fR when run under \f(CW\*(C`make test\*(C'\fR.
For details on how this is done, see the Camel book and the section in
Chapter 7, \*(L"The Standard Perl Library\*(R" on Test::Harness.
.PP
The tests may need to adapt to the type of database which is being used
for testing, and to the privileges of the user testing the driver. For
example, the \fBDBD::Informix\fR test code has to adapt in a number of
places to the type of database to which it is connected as different
Informix databases have different capabilities: some of the tests are
for databases without transaction logs; others are for databases with a
transaction log; some versions of the server have support for blobs, or
stored procedures, or user-defined data types, and others do not.
.PP
When a complete file of tests must be skipped, you can provide a reason
in a pseudo-comment:
.PP
.Vb 5
\&    if ($no_transactions_available)
\&    {
\&        print "1..0 # Skip: No transactions available\en";
\&        exit 0;
\&    }
.Ve
.PP
Consider downloading the \fBDBD::Informix\fR code and look at the code in
\&\fIDBD/Informix/TestHarness.pm\fR which is used throughout the
\&\fBDBD::Informix\fR tests in the \fIt\fR sub-directory.
.SH "CREATING A C/XS DRIVER"
.IX Header "CREATING A C/XS DRIVER"
Please also see the section under \*(L"\s-1CREATING A PURE PERL DRIVER\*(R"\s0
regarding the creation of the \fIMakefile.PL\fR.
.PP
Creating a new C/XS driver from scratch will always be a daunting task.
You can and should greatly simplify your task by taking a good
reference driver implementation and modifying that to match the
database product for which you are writing a driver.
.PP
The de facto reference driver has been the one for \fBDBD::Oracle\fR written
by Tim Bunce, who is also the author of the \fB\s-1DBI\s0\fR package. The \fBDBD::Oracle\fR
module is a good example of a driver implemented around a C\-level \s-1API.\s0
.PP
Nowadays it it seems better to base on \fB\s-1DBD::ODBC\s0\fR, another driver
maintained by Tim and Jeff Urlwin, because it offers a lot of metadata
and seems to become the guideline for the future development. (Also as
\&\fBDBD::Oracle\fR digs deeper into the Oracle 8 \s-1OCI\s0 interface it'll get even
more hairy than it is now.)
.PP
The \fBDBD::Informix\fR driver is one driver implemented using embedded \s-1SQL\s0
instead of a function-based \s-1API.
\&\s0\fBDBD::Ingres\fR may also be worth a look.
.SS "C/XS version of Driver.pm"
.IX Subsection "C/XS version of Driver.pm"
A lot of the code in the \fIDriver.pm\fR file is very similar to the code for pure Perl modules
\&\- see above.  However,
there are also some subtle (and not so subtle) differences, including:
.IP "\(bu" 8
The variables \fI\f(CI$DBD::Driver::\fI{dr|db|st}::imp_data_size\fR are not defined
here, but in the \s-1XS\s0 code, because they declare the size of certain
C structures.
.IP "\(bu" 8
Some methods are typically moved to the \s-1XS\s0 code, in particular
\&\f(CW\*(C`prepare()\*(C'\fR, \f(CW\*(C`execute()\*(C'\fR, \f(CW\*(C`disconnect()\*(C'\fR, \f(CW\*(C`disconnect_all()\*(C'\fR and the
\&\f(CW\*(C`STORE()\*(C'\fR and \f(CW\*(C`FETCH()\*(C'\fR methods.
.IP "\(bu" 8
Other methods are still part of \fIDriver.pm\fR, but have callbacks to
the \s-1XS\s0 code.
.IP "\(bu" 8
If the driver-specific parts of the \fIimp_drh_t\fR structure need to be
formally initialized (which does not seem to be a common requirement),
then you need to add a call to an appropriate \s-1XS\s0 function in the driver
method of \f(CW\*(C`DBD::Driver::driver()\*(C'\fR, and you define the corresponding function
in \fIDriver.xs\fR, and you define the C code in \fIdbdimp.c\fR and the prototype in
\&\fIdbdimp.h\fR.
.Sp
For example, \fBDBD::Informix\fR has such a requirement, and adds the
following call after the call to \f(CW\*(C`_new_drh()\*(C'\fR in \fIInformix.pm\fR:
.Sp
.Vb 1
\&  DBD::Informix::dr::driver_init($drh);
.Ve
.Sp
and the following code in \fIInformix.xs\fR:
.Sp
.Vb 6
\&  # Initialize the DBD::Informix driver data structure
\&  void
\&  driver_init(drh)
\&      SV *drh
\&      CODE:
\&      ST(0) = dbd_ix_dr_driver_init(drh) ? &sv_yes : &sv_no;
.Ve
.Sp
and the code in \fIdbdimp.h\fR declares:
.Sp
.Vb 1
\&  extern int dbd_ix_dr_driver_init(SV *drh);
.Ve
.Sp
and the code in \fIdbdimp.ec\fR (equivalent to \fIdbdimp.c\fR) defines:
.Sp
.Vb 11
\&  /* Formally initialize the DBD::Informix driver structure */
\&  int
\&  dbd_ix_dr_driver(SV *drh)
\&  {
\&      D_imp_drh(drh);
\&      imp_drh\->n_connections = 0;       /* No active connections */
\&      imp_drh\->current_connection = 0;  /* No current connection */
\&      imp_drh\->multipleconnections = (ESQLC_VERSION >= 600) ? True : False;
\&      dbd_ix_link_newhead(&imp_drh\->head);  /* Empty linked list of connections */
\&      return 1;
\&  }
.Ve
.Sp
\&\fBDBD::Oracle\fR has a similar requirement but gets around it by checking
whether the private data part of the driver handle is all zeroed out,
rather than add extra functions.
.PP
Now let's take a closer look at an excerpt from \fIOracle.pm\fR (revised
heavily to remove idiosyncrasies) as an example, ignoring things that
were already discussed for pure Perl drivers.
.PP
\fIThe connect method\fR
.IX Subsection "The connect method"
.PP
The connect method is the database handle constructor.
You could write either of two versions of this method: either one which
takes connection attributes (new code) and one which ignores them (old
code only).
.PP
If you ignore the connection attributes, then you omit all mention of
the \fI\f(CI$auth\fI\fR variable (which is a reference to a hash of attributes), and
the \s-1XS\s0 system manages the differences for you.
.PP
.Vb 3
\&  sub connect
\&  {
\&      my ($drh, $dbname, $user, $auth, $attr) = @_;
\&
\&      # Some database specific verifications, default settings
\&      # and the like following here. This should only include
\&      # syntax checks or similar stuff where it\*(Aqs legal to
\&      # \*(Aqdie\*(Aq in case of errors.
\&
\&      my $dbh = DBI::_new_dbh($drh, {
\&              \*(AqName\*(Aq   => $dbname,
\&          })
\&          or return undef;
\&
\&      # Call the driver\-specific function _login in Driver.xs file which
\&      # calls the DBMS\-specific function(s) to connect to the database,
\&      # and populate internal handle data.
\&      DBD::Driver::db::_login($dbh, $dbname, $user, $auth, $attr)
\&          or return undef;
\&
\&      $dbh;
\&  }
.Ve
.PP
This is mostly the same as in the pure Perl case, the exception being
the use of the private \f(CW\*(C`_login()\*(C'\fR callback, which is the function
that will really connect to the database. It is implemented in
\&\fIDriver.xst\fR (you should not implement it) and calls
\&\f(CW\*(C`dbd_db_login6()\*(C'\fR or \f(CW\*(C`dbd_db_login6_sv\*(C'\fR from \fIdbdimp.c\fR. See below
for details.
.PP
If your driver has driver-specific attributes which may be passed in the
connect method and hence end up in \f(CW$attr\fR in \f(CW\*(C`dbd_db_login6\*(C'\fR then it
is best to delete any you process so \s-1DBI\s0 does not send them again
via \s-1STORE\s0 after connect. You can do this in C like this:
.PP
.Vb 2
\&  DBD_ATTRIB_DELETE(attr, "my_attribute_name",
\&                    strlen("my_attribute_name"));
.Ve
.PP
However, prior to \s-1DBI\s0 subversion version 11605 (and fixed post 1.607)
\&\s-1DBD_ATTRIB_DELETE\s0 segfaulted so if you cannot guarantee the \s-1DBI\s0 version
will be post 1.607 you need to use:
.PP
.Vb 2
\&  hv_delete((HV*)SvRV(attr), "my_attribute_name",
\&                     strlen("my_attribute_name"), G_DISCARD);
\&
\& *FIX ME* Discuss removing attributes in Perl code.
.Ve
.PP
\fIThe disconnect_all method\fR
.IX Subsection "The disconnect_all method"
.PP
.Vb 1
\& *FIX ME* T.B.S
.Ve
.PP
\fIThe data_sources method\fR
.IX Subsection "The data_sources method"
.PP
If your \f(CW\*(C`data_sources()\*(C'\fR method can be implemented in pure Perl, then do
so because it is easier than doing it in \s-1XS\s0 code (see the section above
for pure Perl drivers).
.PP
If your \f(CW\*(C`data_sources()\*(C'\fR method must call onto compiled functions, then
you will need to define \fIdbd_dr_data_sources\fR in your \fIdbdimp.h\fR file, which
will trigger \fIDriver.xst\fR (in \fB\s-1DBI\s0\fR v1.33 or greater) to generate the \s-1XS\s0
code that calls your actual C function (see the discussion below for
details) and you do not code anything in \fIDriver.pm\fR to handle it.
.PP
\fIThe prepare method\fR
.IX Subsection "The prepare method"
.PP
The prepare method is the statement handle constructor, and most of it
is not new. Like the \f(CW\*(C`connect()\*(C'\fR method, it now has a C callback:
.PP
.Vb 2
\&  package DBD::Driver::db; # ====== DATABASE ======
\&  use strict;
\&
\&  sub prepare
\&  {
\&      my ($dbh, $statement, $attribs) = @_;
\&
\&      # create a \*(Aqblank\*(Aq sth
\&      my $sth = DBI::_new_sth($dbh, {
\&          \*(AqStatement\*(Aq => $statement,
\&          })
\&          or return undef;
\&
\&      # Call the driver\-specific function _prepare in Driver.xs file
\&      # which calls the DBMS\-specific function(s) to prepare a statement
\&      # and populate internal handle data.
\&      DBD::Driver::st::_prepare($sth, $statement, $attribs)
\&          or return undef;
\&      $sth;
\&  }
.Ve
.PP
\fIThe execute method\fR
.IX Subsection "The execute method"
.PP
.Vb 1
\& *FIX ME* T.B.S
.Ve
.PP
\fIThe fetchrow_arrayref method\fR
.IX Subsection "The fetchrow_arrayref method"
.PP
.Vb 1
\& *FIX ME* T.B.S
.Ve
.PP
\fIOther methods?\fR
.IX Subsection "Other methods?"
.PP
.Vb 1
\& *FIX ME* T.B.S
.Ve
.SS "Driver.xs"
.IX Subsection "Driver.xs"
\&\fIDriver.xs\fR should look something like this:
.PP
.Vb 1
\&  #include "Driver.h"
\&
\&  DBISTATE_DECLARE;
\&
\&  INCLUDE: Driver.xsi
\&
\&  MODULE = DBD::Driver    PACKAGE = DBD::Driver::dr
\&
\&  /* Non\-standard drh XS methods following here, if any.       */
\&  /* If none (the usual case), omit the MODULE line above too. */
\&
\&  MODULE = DBD::Driver    PACKAGE = DBD::Driver::db
\&
\&  /* Non\-standard dbh XS methods following here, if any.       */
\&  /* Currently this includes things like _list_tables from     */
\&  /* DBD::mSQL and DBD::mysql.                                 */
\&
\&  MODULE = DBD::Driver    PACKAGE = DBD::Driver::st
\&
\&  /* Non\-standard sth XS methods following here, if any.       */
\&  /* In particular this includes things like _list_fields from */
\&  /* DBD::mSQL and DBD::mysql for accessing metadata.          */
.Ve
.PP
Note especially the include of \fIDriver.xsi\fR here: \fB\s-1DBI\s0\fR inserts stub
functions for almost all private methods here which will typically do
much work for you.
.PP
Wherever you really have to implement something, it will call a private
function in \fIdbdimp.c\fR, and this is what you have to implement.
.PP
You need to set up an extra routine if your driver needs to export
constants of its own, analogous to the \s-1SQL\s0 types available when you say:
.PP
.Vb 1
\&  use DBI qw(:sql_types);
\&
\& *FIX ME* T.B.S
.Ve
.SS "Driver.h"
.IX Subsection "Driver.h"
\&\fIDriver.h\fR is very simple and the operational contents should look like this:
.PP
.Vb 2
\&  #ifndef DRIVER_H_INCLUDED
\&  #define DRIVER_H_INCLUDED
\&
\&  #define NEED_DBIXS_VERSION 93    /* 93 for DBI versions 1.00 to 1.51+ */
\&  #define PERL_NO_GET_CONTEXT      /* if used require DBI 1.51+ */
\&
\&  #include <DBIXS.h>      /* installed by the DBI module  */
\&
\&  #include "dbdimp.h"
\&
\&  #include "dbivport.h"   /* see below                    */
\&
\&  #include <dbd_xsh.h>    /* installed by the DBI module  */
\&
\&  #endif /* DRIVER_H_INCLUDED */
.Ve
.PP
The \fI\s-1DBIXS\s0.h\fR header defines most of the interesting information that
the writer of a driver needs.
.PP
The file \fIdbd_xsh.h\fR header provides prototype declarations for the C
functions that you might decide to implement. Note that you should
normally only define one of \f(CW\*(C`dbd_db_login()\*(C'\fR, \f(CW\*(C`dbd_db_login6()\*(C'\fR or
\&\f(CW\*(C`dbd_db_login6_sv\*(C'\fR unless you are intent on supporting really old
versions of \fB\s-1DBI\s0\fR (prior to \fB\s-1DBI\s0\fR 1.06) as well as modern
versions. The only standard, \fB\s-1DBI\s0\fR\-mandated functions that you need
write are those specified in the \fIdbd_xsh.h\fR header. You might also
add extra driver-specific functions in \fIDriver.xs\fR.
.PP
The \fIdbivport.h\fR file should be \fIcopied\fR from the latest \fB\s-1DBI\s0\fR release
into your distribution each time you modify your driver. Its job is to
allow you to enhance your code to work with the latest \fB\s-1DBI\s0\fR \s-1API\s0 while
still allowing your driver to be compiled and used with older versions
of the \fB\s-1DBI\s0\fR (for example, when the \f(CW\*(C`DBIh_SET_ERR_CHAR()\*(C'\fR macro was added
to \fB\s-1DBI\s0\fR 1.41, an emulation of it was added to \fIdbivport.h\fR). This makes
users happy and your life easier. Always read the notes in \fIdbivport.h\fR
to check for any limitations in the emulation that you should be aware
of.
.PP
With \fB\s-1DBI\s0\fR v1.51 or better I recommend that the driver defines
\&\fI\s-1PERL_NO_GET_CONTEXT\s0\fR before \fI\s-1DBIXS\s0.h\fR is included. This can significantly
improve efficiency when running under a thread enabled perl. (Remember that
the standard perl in most Linux distributions is built with threads enabled.
So is ActiveState perl for Windows, and perl built for Apache mod_perl2.)
If you do this there are some things to keep in mind:
.IP "\(bu" 4
If \fI\s-1PERL_NO_GET_CONTEXT\s0\fR is defined, then every function that calls the Perl
\&\s-1API\s0 will need to start out with a \f(CW\*(C`dTHX;\*(C'\fR declaration.
.IP "\(bu" 4
You'll know which functions need this, because the C compiler will
complain that the undeclared identifier \f(CW\*(C`my_perl\*(C'\fR is used if \fIand only if\fR
the perl you are using to develop and test your driver has threads enabled.
.IP "\(bu" 4
If you don't remember to test with a thread-enabled perl before making
a release it's likely that you'll get failure reports from users who are.
.IP "\(bu" 4
For driver private functions it is possible to gain even more
efficiency by replacing \f(CW\*(C`dTHX;\*(C'\fR with \f(CW\*(C`pTHX_\*(C'\fR prepended to the
parameter list and then \f(CW\*(C`aTHX_\*(C'\fR prepended to the argument list where
the function is called.
.PP
See \*(L"How multiple interpreters and concurrency are supported\*(R" in perlguts for
additional information about \fI\s-1PERL_NO_GET_CONTEXT\s0\fR.
.SS "Implementation header dbdimp.h"
.IX Subsection "Implementation header dbdimp.h"
This header file has two jobs:
.PP
First it defines data structures for your private part of the handles.
.PP
Second it defines macros that rename the generic names like
\&\f(CW\*(C`dbd_db_login()\*(C'\fR to database specific names like \f(CW\*(C`ora_db_login()\*(C'\fR. This
avoids name clashes and enables use of different drivers when you work
with a statically linked perl.
.PP
It also will have the important task of disabling \s-1XS\s0 methods that you
don't want to implement.
.PP
Finally, the macros will also be used to select alternate
implementations of some functions. For example, the \f(CW\*(C`dbd_db_login()\*(C'\fR
function is not passed the attribute hash.
.PP
Since \fB\s-1DBI\s0\fR v1.06, if a \f(CW\*(C`dbd_db_login6()\*(C'\fR macro is defined (for a function
with 6 arguments), it will be used instead with the attribute hash
passed as the sixth argument.
.PP
Since \fB\s-1DBI\s0\fR post v1.607, if a \f(CW\*(C`dbd_db_login6_sv()\*(C'\fR macro is defined (for
a function like dbd_db_login6 but with scalar pointers for the dbname,
username and password), it will be used instead. This will allow your
login6 function to see if there are any Unicode characters in the
dbname.
.PP
People used to just pick Oracle's \fIdbdimp.c\fR and use the same names,
structures and types. I strongly recommend against that. At first glance
this saves time, but your implementation will be less readable. It was
just hell when I had to separate \fB\s-1DBI\s0\fR specific parts, Oracle specific
parts, mSQL specific parts and mysql specific parts in \fBDBD::mysql\fR's
\&\fIdbdimp.h\fR and \fIdbdimp.c\fR. (\fBDBD::mysql\fR was a port of \fBDBD::mSQL\fR
which was based on \fBDBD::Oracle\fR.) [Seconded, based on the experience
taking \fBDBD::Informix\fR apart, even though the version inherited in 1996
was only based on \fBDBD::Oracle\fR.]
.PP
This part of the driver is \fIyour exclusive part\fR. Rewrite it from
scratch, so it will be clean and short: in other words, a better piece
of code. (Of course keep an eye on other people's work.)
.PP
.Vb 4
\&  struct imp_drh_st {
\&      dbih_drc_t com;           /* MUST be first element in structure   */
\&      /* Insert your driver handle attributes here */
\&  };
\&
\&  struct imp_dbh_st {
\&      dbih_dbc_t com;           /* MUST be first element in structure   */
\&      /* Insert your database handle attributes here */
\&  };
\&
\&  struct imp_sth_st {
\&      dbih_stc_t com;           /* MUST be first element in structure   */
\&      /* Insert your statement handle attributes here */
\&  };
\&
\&  /*  Rename functions for avoiding name clashes; prototypes are  */
\&  /*  in dbd_xsh.h                                                */
\&  #define dbd_init            drv_dr_init
\&  #define dbd_db_login6_sv    drv_db_login_sv
\&  #define dbd_db_do           drv_db_do
\&  ... many more here ...
.Ve
.PP
These structures implement your private part of the handles.
.PP
You \fIhave\fR to use the name \f(CW\*(C`imp_dbh_{dr|db|st}\*(C'\fR and the first field
\&\fImust\fR be of type \fIdbih_drc_t|_dbc_t|_stc_t\fR and \fImust\fR be called
\&\f(CW\*(C`com\*(C'\fR.
.PP
You should never access these fields directly, except by using the
\&\fI\fIDBIc_xxx()\fI\fR macros below.
.SS "Implementation source dbdimp.c"
.IX Subsection "Implementation source dbdimp.c"
Conventionally, \fIdbdimp.c\fR is the main implementation file (but
\&\fBDBD::Informix\fR calls the file \fIdbdimp.ec\fR). This section includes a
short note on each function that is used in the \fIDriver.xsi\fR template
and thus \fIhas\fR to be implemented.
.PP
Of course, you will probably also need to implement other support
functions, which should usually be file static if they are placed in
\&\fIdbdimp.c\fR. If they are placed in other files, you need to list those
files in \fIMakefile.PL\fR (and \fI\s-1MANIFEST\s0\fR) to handle them correctly.
.PP
It is wise to adhere to a namespace convention for your functions to
avoid conflicts. For example, for a driver with prefix \fIdrv_\fR, you
might call externally visible functions \fIdbd_drv_xxxx\fR. You should also
avoid non-constant global variables as much as possible to improve the
support for threading.
.PP
Since Perl requires support for function prototypes (\s-1ANSI\s0 or \s-1ISO\s0 or
Standard C), you should write your code using function prototypes too.
.PP
It is possible to use either the unmapped names such as \f(CW\*(C`dbd_init()\*(C'\fR or
the mapped names such as \f(CW\*(C`dbd_ix_dr_init()\*(C'\fR in the \fIdbdimp.c\fR file.
\&\fBDBD::Informix\fR uses the mapped names which makes it easier to identify
where to look for linkage problems at runtime (which will report errors
using the mapped names).
.PP
Most other drivers, and in particular \fBDBD::Oracle\fR, use the unmapped
names in the source code which makes it a little easier to compare code
between drivers and eases discussions on the \fIdbi-dev\fR mailing list.
The majority of the code fragments here will use the unmapped names.
.PP
Ultimately, you should provide implementations for most of the
functions listed in the \fIdbd_xsh.h\fR header. The exceptions are
optional functions (such as \f(CW\*(C`dbd_st_rows()\*(C'\fR) and those functions with
alternative signatures, such as \f(CW\*(C`dbd_db_login6_sv\*(C'\fR,
\&\f(CW\*(C`dbd_db_login6()\*(C'\fR and \fI\fIdbd_db_login()\fI\fR. Then you should only
implement one of the alternatives, and generally the newer one of the
alternatives.
.PP
\fIThe dbd_init method\fR
.IX Subsection "The dbd_init method"
.PP
.Vb 1
\&  #include "Driver.h"
\&
\&  DBISTATE_DECLARE;
\&
\&  void dbd_init(dbistate_t* dbistate)
\&  {
\&      DBISTATE_INIT;  /*  Initialize the DBI macros  */
\&  }
.Ve
.PP
The \f(CW\*(C`dbd_init()\*(C'\fR function will be called when your driver is first
loaded; the bootstrap command in \f(CW\*(C`DBD::Driver::dr::driver()\*(C'\fR triggers this,
and the call is generated in the \fI\s-1BOOT\s0\fR section of \fIDriver.xst\fR.
These statements are needed to allow your driver to use the \fB\s-1DBI\s0\fR macros.
They will include your private header file \fIdbdimp.h\fR in turn.
Note that \fI\s-1DBISTATE_INIT\s0\fR requires the name of the argument to \f(CW\*(C`dbd_init()\*(C'\fR
to be called \f(CW\*(C`dbistate()\*(C'\fR.
.PP
\fIThe dbd_drv_error method\fR
.IX Subsection "The dbd_drv_error method"
.PP
You need a function to record errors so \fB\s-1DBI\s0\fR can access them properly.
You can call it whatever you like, but we'll call it \f(CW\*(C`dbd_drv_error()\*(C'\fR
here.
.PP
The argument list depends on your database software; different systems
provide different ways to get at error information.
.PP
.Vb 2
\&  static void dbd_drv_error(SV *h, int rc, const char *what)
\&  {
.Ve
.PP
Note that \fIh\fR is a generic handle, may it be a driver handle, a
database or a statement handle.
.PP
.Vb 1
\&      D_imp_xxh(h);
.Ve
.PP
This macro will declare and initialize a variable \fIimp_xxh\fR with
a pointer to your private handle pointer. You may cast this to
to \fIimp_drh_t\fR, \fIimp_dbh_t\fR or \fIimp_sth_t\fR.
.PP
To record the error correctly, equivalent to the \f(CW\*(C`set_err()\*(C'\fR method,
use one of the \f(CW\*(C`DBIh_SET_ERR_CHAR(...)\*(C'\fR or \f(CW\*(C`DBIh_SET_ERR_SV(...)\*(C'\fR macros,
which were added in \fB\s-1DBI\s0\fR 1.41:
.PP
.Vb 2
\&  DBIh_SET_ERR_SV(h, imp_xxh, err, errstr, state, method);
\&  DBIh_SET_ERR_CHAR(h, imp_xxh, err_c, err_i, errstr, state, method);
.Ve
.PP
For \f(CW\*(C`DBIh_SET_ERR_SV\*(C'\fR the \fIerr\fR, \fIerrstr\fR, \fIstate\fR, and \fImethod\fR
parameters are \f(CW\*(C`SV*\*(C'\fR (use &sv_undef instead of \s-1NULL\s0).
.PP
For \f(CW\*(C`DBIh_SET_ERR_CHAR\*(C'\fR the \fIerr_c\fR, \fIerrstr\fR, \fIstate\fR, \fImethod\fR
parameters are \f(CW\*(C`char*\*(C'\fR.
.PP
The \fIerr_i\fR parameter is an \f(CW\*(C`IV\*(C'\fR that's used instead of \fIerr_c\fR if
\&\fIerr_c\fR is \f(CW\*(C`Null\*(C'\fR.
.PP
The \fImethod\fR parameter can be ignored.
.PP
The \f(CW\*(C`DBIh_SET_ERR_CHAR\*(C'\fR macro is usually the simplest to use when you
just have an integer error code and an error message string:
.PP
.Vb 1
\&  DBIh_SET_ERR_CHAR(h, imp_xxh, Nullch, rc, what, Nullch, Nullch);
.Ve
.PP
As you can see, any parameters that aren't relevant to you can be \f(CW\*(C`Null\*(C'\fR.
.PP
To make drivers compatible with \fB\s-1DBI\s0\fR < 1.41 you should be using \fIdbivport.h\fR
as described in \*(L"Driver.h\*(R" above.
.PP
The (obsolete) macros such as \f(CW\*(C`DBIh_EVENT2\*(C'\fR should be removed from drivers.
.PP
The names \f(CW\*(C`dbis\*(C'\fR and \f(CW\*(C`DBIS\*(C'\fR, which were used in previous versions of
this document, should be replaced with the \f(CW\*(C`DBIc_DBISTATE(imp_xxh)\*(C'\fR macro.
.PP
The name \f(CW\*(C`DBILOGFP\*(C'\fR, which was also used in previous versions of this
document, should be replaced by \f(CW\*(C`DBIc_LOGPIO(imp_xxh)\*(C'\fR.
.PP
Your code should not call the C \f(CW\*(C`<stdio.h>\*(C'\fR I/O functions; you
should use \f(CW\*(C`PerlIO_printf()\*(C'\fR as shown:
.PP
.Vb 3
\&      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)
\&          PerlIO_printf(DBIc_LOGPIO(imp_xxh), "foobar %s: %s\en",
\&              foo, neatsvpv(errstr,0));
.Ve
.PP
That's the first time we see how tracing works within a \fB\s-1DBI\s0\fR driver. Make
use of this as often as you can, but don't output anything at a trace
level less than 3. Levels 1 and 2 are reserved for the \fB\s-1DBI\s0\fR.
.PP
You can define up to 8 private trace flags using the top 8 bits
of \f(CW\*(C`DBIc_TRACE_FLAGS(imp)\*(C'\fR, that is: \f(CW0xFF000000\fR. See the
\&\f(CW\*(C`parse_trace_flag()\*(C'\fR method elsewhere in this document.
.PP
\fIThe dbd_dr_data_sources method\fR
.IX Subsection "The dbd_dr_data_sources method"
.PP
This method is optional; the support for it was added in \fB\s-1DBI\s0\fR v1.33.
.PP
As noted in the discussion of \fIDriver.pm\fR, if the data sources
can be determined by pure Perl code, do it that way. If, as in
\&\fBDBD::Informix\fR, the information is obtained by a C function call, then
you need to define a function that matches the prototype:
.PP
.Vb 1
\&  extern AV *dbd_dr_data_sources(SV *drh, imp_drh_t *imp_drh, SV *attrs);
.Ve
.PP
An outline implementation for \fBDBD::Informix\fR follows, assuming that the
\&\f(CW\*(C`sqgetdbs()\*(C'\fR function call shown will return up to 100 databases names,
with the pointers to each name in the array dbsname and the name strings
themselves being stores in dbsarea.
.PP
.Vb 7
\&  AV *dbd_dr_data_sources(SV *drh, imp_drh_t *imp_drh, SV *attr)
\&  {
\&      int ndbs;
\&      int i;
\&      char *dbsname[100];
\&      char  dbsarea[10000];
\&      AV *av = Nullav;
\&
\&      if (sqgetdbs(&ndbs, dbsname, 100, dbsarea, sizeof(dbsarea)) == 0)
\&      {
\&          av = NewAV();
\&          av_extend(av, (I32)ndbs);
\&          sv_2mortal((SV *)av);
\&          for (i = 0; i < ndbs; i++)
\&            av_store(av, i, newSVpvf("dbi:Informix:%s", dbsname[i]));
\&      }
\&      return(av);
\&  }
.Ve
.PP
The actual \fBDBD::Informix\fR implementation has a number of extra lines of
code, logs function entry and exit, reports the error from \f(CW\*(C`sqgetdbs()\*(C'\fR,
and uses \f(CW\*(C`#define\*(C'\fR'd constants for the array sizes.
.PP
\fIThe dbd_db_login6 method\fR
.IX Subsection "The dbd_db_login6 method"
.PP
.Vb 2
\&  int dbd_db_login6_sv(SV* dbh, imp_dbh_t* imp_dbh, SV* dbname,
\&                       SV* user, SV* auth, SV *attr);
\&
\&  or
\&
\&  int dbd_db_login6(SV* dbh, imp_dbh_t* imp_dbh, char* dbname,
\&                   char* user, char* auth, SV *attr);
.Ve
.PP
This function will really connect to the database. The argument \fIdbh\fR
is the database handle. \fIimp_dbh\fR is the pointer to the handles private
data, as is \fIimp_xxx\fR in \f(CW\*(C`dbd_drv_error()\*(C'\fR above. The arguments
\&\fIdbname\fR, \fIuser\fR, \fIauth\fR and \fIattr\fR correspond to the arguments of
the driver handle's \f(CW\*(C`connect()\*(C'\fR method.
.PP
You will quite often use database specific attributes here, that are
specified in the \s-1DSN. I\s0 recommend you parse the \s-1DSN \s0(using Perl) within
the \f(CW\*(C`connect()\*(C'\fR method and pass the segments of the \s-1DSN\s0 via the
attributes parameter through \f(CW\*(C`_login()\*(C'\fR to \f(CW\*(C`dbd_db_login6()\*(C'\fR.
.PP
Here's how you fetch them; as an example we use \fIhostname\fR attribute,
which can be up to 12 characters long excluding null terminator:
.PP
.Vb 3
\&  SV** svp;
\&  STRLEN len;
\&  char* hostname;
\&
\&  if ( (svp = DBD_ATTRIB_GET_SVP(attr, "drv_hostname", 12)) && SvTRUE(*svp)) {
\&      hostname = SvPV(*svp, len);
\&      DBD_ATTRIB_DELETE(attr, "drv_hostname", 12); /* avoid later STORE */
\&  } else {
\&      hostname = "localhost";
\&  }
.Ve
.PP
If you handle any driver specific attributes in the dbd_db_login6
method you probably want to delete them from \f(CW\*(C`attr\*(C'\fR (as above with
\&\s-1DBD_ATTRIB_DELETE\s0). If you don't delete your handled attributes \s-1DBI\s0
will call \f(CW\*(C`STORE\*(C'\fR for each attribute after the connect/login and this
is at best redundant for attributes you have already processed.
.PP
\&\fBNote: Until revision 11605 (post \s-1DBI 1.607\s0), there was a problem with
\&\s-1DBD_ATTRIBUTE_DELETE\s0 so unless you require a \s-1DBI\s0 version after 1.607
you need to replace each \s-1DBD_ATTRIBUTE_DELETE\s0 call with:\fR
.PP
.Vb 1
\&  hv_delete((HV*)SvRV(attr), key, key_len, G_DISCARD)
.Ve
.PP
Note that you can also obtain standard attributes such as \fIAutoCommit\fR and
\&\fIChopBlanks\fR from the attributes parameter, using \f(CW\*(C`DBD_ATTRIB_GET_IV\*(C'\fR for
integer attributes.
.PP
If, for example, your database does not support transactions but
\&\fIAutoCommit\fR is set off (requesting transaction support), then you can
emulate a 'failure to connect'.
.PP
Now you should really connect to the database. In general, if the
connection fails, it is best to ensure that all allocated resources are
released so that the handle does not need to be destroyed separately. If
you are successful (and possibly even if you fail but you have allocated
some resources), you should use the following macros:
.PP
.Vb 1
\&  DBIc_IMPSET_on(imp_dbh);
.Ve
.PP
This indicates that the driver (implementor) has allocated resources in
the \fIimp_dbh\fR structure and that the implementors private \f(CW\*(C`dbd_db_destroy()\*(C'\fR
function should be called when the handle is destroyed.
.PP
.Vb 1
\&  DBIc_ACTIVE_on(imp_dbh);
.Ve
.PP
This indicates that the handle has an active connection to the server
and that the \f(CW\*(C`dbd_db_disconnect()\*(C'\fR function should be called before the
handle is destroyed.
.PP
Note that if you do need to fail, you should report errors via the \fIdrh\fR
or \fIimp_drh\fR rather than via \fIdbh\fR or \fIimp_dbh\fR because \fIimp_dbh\fR will be
destroyed by the failure, so errors recorded in that handle will not be
visible to \fB\s-1DBI\s0\fR, and hence not the user either.
.PP
Note too, that the function is passed \fIdbh\fR and \fIimp_dbh\fR, and there
is a macro \f(CW\*(C`D_imp_drh_from_dbh\*(C'\fR which can recover the \fIimp_drh\fR from
the \fIimp_dbh\fR. However, there is no \fB\s-1DBI\s0\fR macro to provide you with the
\&\fIdrh\fR given either the \fIimp_dbh\fR or the \fIdbh\fR or the \fIimp_drh\fR (and
there's no way to recover the \fIdbh\fR given just the \fIimp_dbh\fR).
.PP
This suggests that, despite the above notes about \f(CW\*(C`dbd_drv_error()\*(C'\fR
taking an \f(CW\*(C`SV *\*(C'\fR, it may be better to have two error routines, one
taking \fIimp_dbh\fR and one taking \fIimp_drh\fR instead. With care, you can
factor most of the formatting code out so that these are small routines
calling a common error formatter. See the code in \fBDBD::Informix\fR
1.05.00 for more information.
.PP
The \f(CW\*(C`dbd_db_login6()\*(C'\fR function should return \fI\s-1TRUE\s0\fR for success,
\&\fI\s-1FALSE\s0\fR otherwise.
.PP
Drivers implemented long ago may define the five-argument function
\&\f(CW\*(C`dbd_db_login()\*(C'\fR instead of \f(CW\*(C`dbd_db_login6()\*(C'\fR. The missing argument is
the attributes. There are ways to work around the missing attributes,
but they are ungainly; it is much better to use the 6\-argument form.
Even later drivers will use \f(CW\*(C`dbd_db_login6_sv()\*(C'\fR which provides the
dbname, username and password as SVs.
.PP
\fIThe dbd_db_commit and dbd_db_rollback methods\fR
.IX Subsection "The dbd_db_commit and dbd_db_rollback methods"
.PP
.Vb 2
\&  int dbd_db_commit(SV *dbh, imp_dbh_t *imp_dbh);
\&  int dbd_db_rollback(SV* dbh, imp_dbh_t* imp_dbh);
.Ve
.PP
These are used for commit and rollback. They should return \fI\s-1TRUE\s0\fR for
success, \fI\s-1FALSE\s0\fR for error.
.PP
The arguments \fIdbh\fR and \fIimp_dbh\fR are the same as for \f(CW\*(C`dbd_db_login6()\*(C'\fR
above; I will omit describing them in what follows, as they appear
always.
.PP
These functions should return \fI\s-1TRUE\s0\fR for success, \fI\s-1FALSE\s0\fR otherwise.
.PP
\fIThe dbd_db_disconnect method\fR
.IX Subsection "The dbd_db_disconnect method"
.PP
This is your private part of the \f(CW\*(C`disconnect()\*(C'\fR method. Any \fIdbh\fR with
the \fI\s-1ACTIVE\s0\fR flag on must be disconnected. (Note that you have to set
it in \f(CW\*(C`dbd_db_connect()\*(C'\fR above.)
.PP
.Vb 1
\&  int dbd_db_disconnect(SV* dbh, imp_dbh_t* imp_dbh);
.Ve
.PP
The database handle will return \fI\s-1TRUE\s0\fR for success, \fI\s-1FALSE\s0\fR otherwise.
In any case it should do a:
.PP
.Vb 1
\&  DBIc_ACTIVE_off(imp_dbh);
.Ve
.PP
before returning so \fB\s-1DBI\s0\fR knows that \f(CW\*(C`dbd_db_disconnect()\*(C'\fR was executed.
.PP
Note that there's nothing to stop a \fIdbh\fR being \fIdisconnected\fR while
it still have active children. If your database \s-1API\s0 reacts badly to
trying to use an \fIsth\fR in this situation then you'll need to add code
like this to all \fIsth\fR methods:
.PP
.Vb 2
\&  if (!DBIc_ACTIVE(DBIc_PARENT_COM(imp_sth)))
\&    return 0;
.Ve
.PP
Alternatively, you can add code to your driver to keep explicit track of
the statement handles that exist for each database handle and arrange
to destroy those handles before disconnecting from the database. There
is code to do this in \fBDBD::Informix\fR. Similar comments apply to the
driver handle keeping track of all the database handles.
.PP
Note that the code which destroys the subordinate handles should only
release the associated database resources and mark the handles inactive;
it does not attempt to free the actual handle structures.
.PP
This function should return \fI\s-1TRUE\s0\fR for success, \fI\s-1FALSE\s0\fR otherwise, but
it is not clear what anything can do about a failure.
.PP
\fIThe dbd_db_discon_all method\fR
.IX Subsection "The dbd_db_discon_all method"
.PP
.Vb 1
\&  int dbd_discon_all (SV *drh, imp_drh_t *imp_drh);
.Ve
.PP
This function may be called at shutdown time. It should make
best-efforts to disconnect all database handles \- if possible. Some
databases don't support that, in which case you can do nothing
but return 'success'.
.PP
This function should return \fI\s-1TRUE\s0\fR for success, \fI\s-1FALSE\s0\fR otherwise, but
it is not clear what anything can do about a failure.
.PP
\fIThe dbd_db_destroy method\fR
.IX Subsection "The dbd_db_destroy method"
.PP
This is your private part of the database handle destructor. Any \fIdbh\fR with
the \fI\s-1IMPSET\s0\fR flag on must be destroyed, so that you can safely free
resources. (Note that you have to set it in \f(CW\*(C`dbd_db_connect()\*(C'\fR above.)
.PP
.Vb 4
\&  void dbd_db_destroy(SV* dbh, imp_dbh_t* imp_dbh)
\&  {
\&      DBIc_IMPSET_off(imp_dbh);
\&  }
.Ve
.PP
The \fB\s-1DBI\s0\fR \fIDriver.xst\fR code will have called \f(CW\*(C`dbd_db_disconnect()\*(C'\fR for you,
if the handle is still 'active', before calling \f(CW\*(C`dbd_db_destroy()\*(C'\fR.
.PP
Before returning the function must switch \fI\s-1IMPSET\s0\fR to off, so \fB\s-1DBI\s0\fR knows
that the destructor was called.
.PP
A \fB\s-1DBI\s0\fR handle doesn't keep references to its children. But children
do keep references to their parents. So a database handle won't be
\&\f(CW\*(C`DESTROY\*(C'\fR'd until all its children have been \f(CW\*(C`DESTROY\*(C'\fR'd.
.PP
\fIThe dbd_db_STORE_attrib method\fR
.IX Subsection "The dbd_db_STORE_attrib method"
.PP
This function handles
.PP
.Vb 1
\&  $dbh\->{$key} = $value;
.Ve
.PP
Its prototype is:
.PP
.Vb 2
\&  int dbd_db_STORE_attrib(SV* dbh, imp_dbh_t* imp_dbh, SV* keysv,
\&                          SV* valuesv);
.Ve
.PP
You do not handle all attributes; on the contrary, you should not handle
\&\fB\s-1DBI\s0\fR attributes here: leave this to \fB\s-1DBI\s0\fR. (There are two exceptions,
\&\fIAutoCommit\fR and \fIChopBlanks\fR, which you should care about.)
.PP
The return value is \fI\s-1TRUE\s0\fR if you have handled the attribute or \fI\s-1FALSE\s0\fR
otherwise. If you are handling an attribute and something fails, you
should call \f(CW\*(C`dbd_drv_error()\*(C'\fR, so \fB\s-1DBI\s0\fR can raise exceptions, if desired.
If \f(CW\*(C`dbd_drv_error()\*(C'\fR returns, however, you have a problem: the user will
never know about the error, because he typically will not check
\&\f(CW\*(C`$dbh\->errstr()\*(C'\fR.
.PP
I cannot recommend a general way of going on, if \f(CW\*(C`dbd_drv_error()\*(C'\fR returns,
but there are examples where even the \fB\s-1DBI\s0\fR specification expects that
you \f(CW\*(C`croak()\*(C'\fR. (See the \fIAutoCommit\fR method in \s-1DBI\s0.)
.PP
If you have to store attributes, you should either use your private
data structure \fIimp_xxx\fR, the handle hash (via \f(CW\*(C`(HV*)SvRV(dbh)\*(C'\fR), or use
the private \fIimp_data\fR.
.PP
The first is best for internal C values like integers or pointers and
where speed is important within the driver. The handle hash is best for
values the user may want to get/set via driver-specific attributes.
The private \fIimp_data\fR is an additional \f(CW\*(C`SV\*(C'\fR attached to the handle. You
could think of it as an unnamed handle attribute. It's not normally used.
.PP
\fIThe dbd_db_FETCH_attrib method\fR
.IX Subsection "The dbd_db_FETCH_attrib method"
.PP
This is the counterpart of \f(CW\*(C`dbd_db_STORE_attrib()\*(C'\fR, needed for:
.PP
.Vb 1
\&  $value = $dbh\->{$key};
.Ve
.PP
Its prototype is:
.PP
.Vb 1
\&  SV* dbd_db_FETCH_attrib(SV* dbh, imp_dbh_t* imp_dbh, SV* keysv);
.Ve
.PP
Unlike all previous methods this returns an \f(CW\*(C`SV\*(C'\fR with the value. Note
that you should normally execute \f(CW\*(C`sv_2mortal()\*(C'\fR, if you return a nonconstant
value. (Constant values are \f(CW&sv_undef\fR, \f(CW&sv_no\fR and \f(CW&sv_yes\fR.)
.PP
Note, that \fB\s-1DBI\s0\fR implements a caching algorithm for attribute values.
If you think, that an attribute may be fetched, you store it in the
\&\fIdbh\fR itself:
.PP
.Vb 2
\&  if (cacheit) /* cache value for later DBI \*(Aqquick\*(Aq fetch? */
\&      hv_store((HV*)SvRV(dbh), key, kl, cachesv, 0);
.Ve
.PP
\fIThe dbd_st_prepare method\fR
.IX Subsection "The dbd_st_prepare method"
.PP
This is the private part of the \f(CW\*(C`prepare()\*(C'\fR method. Note that you
\&\fBmust not\fR really execute the statement here. You may, however,
preparse and validate the statement, or do similar things.
.PP
.Vb 2
\&  int dbd_st_prepare(SV* sth, imp_sth_t* imp_sth, char* statement,
\&                     SV* attribs);
.Ve
.PP
A typical, simple, possibility is to do nothing and rely on the perl
\&\f(CW\*(C`prepare()\*(C'\fR code that set the \fIStatement\fR attribute on the handle. This
attribute can then be used by \f(CW\*(C`dbd_st_execute()\*(C'\fR.
.PP
If the driver supports placeholders then the \fI\s-1NUM_OF_PARAMS\s0\fR attribute
must be set correctly by \f(CW\*(C`dbd_st_prepare()\*(C'\fR:
.PP
.Vb 1
\&  DBIc_NUM_PARAMS(imp_sth) = ...
.Ve
.PP
If you can, you should also setup attributes like \fI\s-1NUM_OF_FIELDS\s0\fR, \fI\s-1NAME\s0\fR,
etc. here, but \fB\s-1DBI\s0\fR doesn't require that \- they can be deferred until
\&\fIexecute()\fR is called. However, if you do, document it.
.PP
In any case you should set the \fI\s-1IMPSET\s0\fR flag, as you did in
\&\f(CW\*(C`dbd_db_connect()\*(C'\fR above:
.PP
.Vb 1
\&  DBIc_IMPSET_on(imp_sth);
.Ve
.PP
\fIThe dbd_st_execute method\fR
.IX Subsection "The dbd_st_execute method"
.PP
This is where a statement will really be executed.
.PP
.Vb 1
\&  int dbd_st_execute(SV* sth, imp_sth_t* imp_sth);
.Ve
.PP
\&\f(CW\*(C`dbd_st_execute\*(C'\fR should return \-2 for any error, \-1 if the number of
rows affected is unknown else it should be the number of affected
(updated, inserted) rows.
.PP
Note that you must be aware a statement may be executed repeatedly.
Also, you should not expect that \f(CW\*(C`finish()\*(C'\fR will be called between two
executions, so you might need code, like the following, near the start
of the function:
.PP
.Vb 2
\&  if (DBIc_ACTIVE(imp_sth))
\&      dbd_st_finish(h, imp_sth);
.Ve
.PP
If your driver supports the binding of parameters (it should!), but the
database doesn't, you must do it here. This can be done as follows:
.PP
.Vb 4
\&  SV *svp;
\&  char* statement = DBD_ATTRIB_GET_PV(h, "Statement", 9, svp, "");
\&  int numParam = DBIc_NUM_PARAMS(imp_sth);
\&  int i;
\&
\&  for (i = 0; i < numParam; i++)
\&  {
\&      char* value = dbd_db_get_param(sth, imp_sth, i);
\&      /* It is your drivers task to implement dbd_db_get_param,    */
\&      /* it must be setup as a counterpart of dbd_bind_ph.         */
\&      /* Look for \*(Aq?\*(Aq and replace it with \*(Aqvalue\*(Aq.  Difficult      */
\&      /* task, note that you may have question marks inside        */
\&      /* quotes and comments the like ...  :\-(                     */
\&      /* See DBD::mysql for an example. (Don\*(Aqt look too deep into  */
\&      /* the example, you will notice where I was lazy ...)        */
\&  }
.Ve
.PP
The next thing is to really execute the statement.
.PP
Note that you must set the attributes \fI\s-1NUM_OF_FIELDS\s0\fR, \fI\s-1NAME\s0\fR, etc
when the statement is successfully executed if the driver has not
already done so: they may be used even before a potential \f(CW\*(C`fetchrow()\*(C'\fR.
In particular you have to tell \fB\s-1DBI\s0\fR the number of fields that the
statement has, because it will be used by \fB\s-1DBI\s0\fR internally. Thus the
function will typically ends with:
.PP
.Vb 4
\&  if (isSelectStatement) {
\&      DBIc_NUM_FIELDS(imp_sth) = numFields;
\&      DBIc_ACTIVE_on(imp_sth);
\&  }
.Ve
.PP
It is important that the \fI\s-1ACTIVE\s0\fR flag only be set for \f(CW\*(C`SELECT\*(C'\fR
statements (or any other statements that can return many
values from the database using a cursor-like mechanism). See
\&\f(CW\*(C`dbd_db_connect()\*(C'\fR above for more explanations.
.PP
There plans for a preparse function to be provided by \fB\s-1DBI\s0\fR, but this has
not reached fruition yet.
Meantime, if you want to know how ugly it can get, try looking at the
\&\f(CW\*(C`dbd_ix_preparse()\*(C'\fR in \fBDBD::Informix\fR \fIdbdimp.ec\fR and the related
functions in \fIiustoken.c\fR and \fIsqltoken.c\fR.
.PP
\fIThe dbd_st_fetch method\fR
.IX Subsection "The dbd_st_fetch method"
.PP
This function fetches a row of data. The row is stored in in an array,
of \f(CW\*(C`SV\*(C'\fR's that \fB\s-1DBI\s0\fR prepares for you. This has two advantages: it is fast
(you even reuse the \f(CW\*(C`SV\*(C'\fR's, so they don't have to be created after the
first \f(CW\*(C`fetchrow()\*(C'\fR), and it guarantees that \fB\s-1DBI\s0\fR handles \f(CW\*(C`bind_cols()\*(C'\fR for
you.
.PP
What you do is the following:
.PP
.Vb 6
\&  AV* av;
\&  int numFields = DBIc_NUM_FIELDS(imp_sth); /* Correct, if NUM_FIELDS
\&      is constant for this statement. There are drivers where this is
\&      not the case! */
\&  int chopBlanks = DBIc_is(imp_sth, DBIcf_ChopBlanks);
\&  int i;
\&
\&  if (!fetch_new_row_of_data(...)) {
\&      ... /* check for error or end\-of\-data */
\&      DBIc_ACTIVE_off(imp_sth); /* turn off Active flag automatically */
\&      return Nullav;
\&  }
\&  /* get the fbav (field buffer array value) for this row       */
\&  /* it is very important to only call this after you know      */
\&  /* that you have a row of data to return.                     */
\&  av = DBIc_DBISTATE(imp_sth)\->get_fbav(imp_sth);
\&  for (i = 0; i < numFields; i++) {
\&      SV* sv = fetch_a_field(..., i);
\&      if (chopBlanks && SvOK(sv) && type_is_blank_padded(field_type[i])) {
\&          /*  Remove white space from end (only) of sv  */
\&      }
\&      sv_setsv(AvARRAY(av)[i], sv); /* Note: (re)use! */
\&  }
\&  return av;
.Ve
.PP
There's no need to use a \f(CW\*(C`fetch_a_field()\*(C'\fR function returning an \f(CW\*(C`SV*\*(C'\fR.
It's more common to use your database \s-1API\s0 functions to fetch the
data as character strings and use code like this:
.PP
.Vb 1
\&  sv_setpvn(AvARRAY(av)[i], char_ptr, char_count);
.Ve
.PP
\&\f(CW\*(C`NULL\*(C'\fR values must be returned as \f(CW\*(C`undef\*(C'\fR. You can use code like this:
.PP
.Vb 1
\&  SvOK_off(AvARRAY(av)[i]);
.Ve
.PP
The function returns the \f(CW\*(C`AV\*(C'\fR prepared by \fB\s-1DBI\s0\fR for success or \f(CW\*(C`Nullav\*(C'\fR
otherwise.
.PP
.Vb 3
\& *FIX ME* Discuss what happens when there\*(Aqs no more data to fetch.
\& Are errors permitted if another fetch occurs after the first fetch
\& that reports no more data. (Permitted, not required.)
.Ve
.PP
If an error occurs which leaves the \fI\f(CI$sth\fI\fR in a state where remaining
rows can't be fetched then \fIActive\fR should be turned off before the
method returns.
.PP
\fIThe dbd_st_finish3 method\fR
.IX Subsection "The dbd_st_finish3 method"
.PP
The \f(CW\*(C`$sth\->finish()\*(C'\fR method can be called if the user wishes to
indicate that no more rows will be fetched even if the database has more
rows to offer, and the \fB\s-1DBI\s0\fR code can call the function when handles are
being destroyed. See the \fB\s-1DBI\s0\fR specification for more background details.
.PP
In both circumstances, the \fB\s-1DBI\s0\fR code ends up calling the
\&\f(CW\*(C`dbd_st_finish3()\*(C'\fR method (if you provide a mapping for
\&\f(CW\*(C`dbd_st_finish3()\*(C'\fR in \fIdbdimp.h\fR), or \f(CW\*(C`dbd_st_finish()\*(C'\fR otherwise.
The difference is that \f(CW\*(C`dbd_st_finish3()\*(C'\fR takes a third argument which
is an \f(CW\*(C`int\*(C'\fR with the value 1 if it is being called from a \f(CW\*(C`destroy()\*(C'\fR
method and 0 otherwise.
.PP
Note that \fB\s-1DBI\s0\fR v1.32 and earlier test on \f(CW\*(C`dbd_db_finish3()\*(C'\fR to call
\&\f(CW\*(C`dbd_st_finish3()\*(C'\fR; if you provide \f(CW\*(C`dbd_st_finish3()\*(C'\fR, either define
\&\f(CW\*(C`dbd_db_finish3()\*(C'\fR too, or insist on \fB\s-1DBI\s0\fR v1.33 or later.
.PP
All it \fIneeds\fR to do is turn off the \fIActive\fR flag for the \fIsth\fR.
It will only be called by \fIDriver.xst\fR code, if the driver has set \fI\s-1ACTIVE\s0\fR
to on for the \fIsth\fR.
.PP
Outline example:
.PP
.Vb 8
\&  int dbd_st_finish3(SV* sth, imp_sth_t* imp_sth, int from_destroy) {
\&      if (DBIc_ACTIVE(imp_sth))
\&      {
\&          /* close cursor or equivalent action */
\&          DBIc_ACTIVE_off(imp_sth);
\&      }
\&      return 1;
\&  }
.Ve
.PP
The from_destroy parameter is true if \f(CW\*(C`dbd_st_finish3()\*(C'\fR is being called
from \f(CW\*(C`DESTROY()\*(C'\fR \- and so the statement is about to be destroyed.
For many drivers there is no point in doing anything more than turning off
the \fIActive\fR flag in this case.
.PP
The function returns \fI\s-1TRUE\s0\fR for success, \fI\s-1FALSE\s0\fR otherwise, but there isn't
a lot anyone can do to recover if there is an error.
.PP
\fIThe dbd_st_destroy method\fR
.IX Subsection "The dbd_st_destroy method"
.PP
This function is the private part of the statement handle destructor.
.PP
.Vb 4
\&  void dbd_st_destroy(SV* sth, imp_sth_t* imp_sth) {
\&      ... /* any clean\-up that\*(Aqs needed */
\&      DBIc_IMPSET_off(imp_sth); /* let DBI know we\*(Aqve done it   */
\&  }
.Ve
.PP
The \fB\s-1DBI\s0\fR \fIDriver.xst\fR code will call \f(CW\*(C`dbd_st_finish()\*(C'\fR for you, if the
\&\fIsth\fR has the \fI\s-1ACTIVE\s0\fR flag set, before calling \f(CW\*(C`dbd_st_destroy()\*(C'\fR.
.PP
\fIThe dbd_st_STORE_attrib and dbd_st_FETCH_attrib methods\fR
.IX Subsection "The dbd_st_STORE_attrib and dbd_st_FETCH_attrib methods"
.PP
These functions correspond to \f(CW\*(C`dbd_db_STORE()\*(C'\fR and \f(CW\*(C`dbd_db_FETCH()\*(C'\fR attrib
above, except that they are for statement handles.
See above.
.PP
.Vb 3
\&  int dbd_st_STORE_attrib(SV* sth, imp_sth_t* imp_sth, SV* keysv,
\&                          SV* valuesv);
\&  SV* dbd_st_FETCH_attrib(SV* sth, imp_sth_t* imp_sth, SV* keysv);
.Ve
.PP
\fIThe dbd_bind_ph method\fR
.IX Subsection "The dbd_bind_ph method"
.PP
This function is internally used by the \f(CW\*(C`bind_param()\*(C'\fR method, the
\&\f(CW\*(C`bind_param_inout()\*(C'\fR method and by the \fB\s-1DBI\s0\fR \fIDriver.xst\fR code if
\&\f(CW\*(C`execute()\*(C'\fR is called with any bind parameters.
.PP
.Vb 3
\&  int dbd_bind_ph (SV *sth, imp_sth_t *imp_sth, SV *param,
\&                   SV *value, IV sql_type, SV *attribs,
\&                   int is_inout, IV maxlen);
.Ve
.PP
The \fIparam\fR argument holds an \f(CW\*(C`IV\*(C'\fR with the parameter number (1, 2, ...).
The \fIvalue\fR argument is the parameter value and \fIsql_type\fR is its type.
.PP
If your driver does not support \f(CW\*(C`bind_param_inout()\*(C'\fR then you should
ignore \fImaxlen\fR and croak if \fIis_inout\fR is \fI\s-1TRUE\s0\fR.
.PP
If your driver \fIdoes\fR support \f(CW\*(C`bind_param_inout()\*(C'\fR then you should
note that \fIvalue\fR is the \f(CW\*(C`SV\*(C'\fR \fIafter\fR dereferencing the reference
passed to \f(CW\*(C`bind_param_inout()\*(C'\fR.
.PP
In drivers of simple databases the function will, for example, store
the value in a parameter array and use it later in \f(CW\*(C`dbd_st_execute()\*(C'\fR.
See the \fBDBD::mysql\fR driver for an example.
.PP
\fIImplementing bind_param_inout support\fR
.IX Subsection "Implementing bind_param_inout support"
.PP
To provide support for parameters bound by reference rather than by
value, the driver must do a number of things.  First, and most
importantly, it must note the references and stash them in its own
driver structure.  Secondly, when a value is bound to a column, the
driver must discard any previous reference bound to the column.  On
each execute, the driver must evaluate the references and internally
bind the values resulting from the references.  This is only applicable
if the user writes:
.PP
.Vb 1
\&  $sth\->execute;
.Ve
.PP
If the user writes:
.PP
.Vb 1
\&  $sth\->execute(@values);
.Ve
.PP
then \fB\s-1DBI\s0\fR automatically calls the binding code for each element of
\&\fI\f(CI@values\fI\fR.  These calls are indistinguishable from explicit user calls to
\&\f(CW\*(C`bind_param()\*(C'\fR.
.SS "C/XS version of Makefile.PL"
.IX Subsection "C/XS version of Makefile.PL"
The \fIMakefile.PL\fR file for a C/XS driver is similar to the code needed
for a pure Perl driver, but there are a number of extra bits of
information needed by the build system.
.PP
For example, the attributes list passed to \f(CW\*(C`WriteMakefile()\*(C'\fR needs
to specify the object files that need to be compiled and built into
the shared object (\s-1DLL\s0). This is often, but not necessarily, just
\&\fIdbdimp.o\fR (unless that should be \fIdbdimp.obj\fR because you're building
on \s-1MS\s0 Windows).
.PP
Note that you can reliably determine the extension of the object files
from the \fI\f(CI$Config\fI{obj_ext}\fR values, and there are many other useful pieces
of configuration information lurking in that hash.
You get access to it with:
.PP
.Vb 1
\&    use Config;
.Ve
.SS "Methods which do not need to be written"
.IX Subsection "Methods which do not need to be written"
The \fB\s-1DBI\s0\fR code implements the majority of the methods which are accessed
using the notation \f(CW\*(C`DBI\->function()\*(C'\fR, the only exceptions being
\&\f(CW\*(C`DBI\->connect()\*(C'\fR and \f(CW\*(C`DBI\->data_sources()\*(C'\fR which require
support from the driver.
.PP
The \fB\s-1DBI\s0\fR code implements the following documented driver, database and
statement functions which do not need to be written by the \fB\s-1DBD\s0\fR driver
writer.
.ie n .IP "$dbh\->\fIdo()\fR" 4
.el .IP "\f(CW$dbh\fR\->\fIdo()\fR" 4
.IX Item "$dbh->do()"
The default implementation of this function prepares, executes and
destroys the statement.  This can be replaced if there is a better
way to implement this, such as \f(CW\*(C`EXECUTE IMMEDIATE\*(C'\fR which can
sometimes be used if there are no parameters.
.ie n .IP "$h\->\fIerrstr()\fR" 4
.el .IP "\f(CW$h\fR\->\fIerrstr()\fR" 4
.IX Item "$h->errstr()"
.PD 0
.ie n .IP "$h\->\fIerr()\fR" 4
.el .IP "\f(CW$h\fR\->\fIerr()\fR" 4
.IX Item "$h->err()"
.ie n .IP "$h\->\fIstate()\fR" 4
.el .IP "\f(CW$h\fR\->\fIstate()\fR" 4
.IX Item "$h->state()"
.ie n .IP "$h\->\fItrace()\fR" 4
.el .IP "\f(CW$h\fR\->\fItrace()\fR" 4
.IX Item "$h->trace()"
.PD
The \fB\s-1DBD\s0\fR driver does not need to worry about these routines at all.
.ie n .IP "$h\->{ChopBlanks}" 4
.el .IP "\f(CW$h\fR\->{ChopBlanks}" 4
.IX Item "$h->{ChopBlanks}"
This attribute needs to be honored during \f(CW\*(C`fetch()\*(C'\fR operations, but does
not need to be handled by the attribute handling code.
.ie n .IP "$h\->{RaiseError}" 4
.el .IP "\f(CW$h\fR\->{RaiseError}" 4
.IX Item "$h->{RaiseError}"
The \fB\s-1DBD\s0\fR driver does not need to worry about this attribute at all.
.ie n .IP "$h\->{PrintError}" 4
.el .IP "\f(CW$h\fR\->{PrintError}" 4
.IX Item "$h->{PrintError}"
The \fB\s-1DBD\s0\fR driver does not need to worry about this attribute at all.
.ie n .IP "$sth\->\fIbind_col()\fR" 4
.el .IP "\f(CW$sth\fR\->\fIbind_col()\fR" 4
.IX Item "$sth->bind_col()"
Assuming the driver uses the \f(CW\*(C`DBIc_DBISTATE(imp_xxh)\->get_fbav()\*(C'\fR
function (C drivers, see below), or the \f(CW\*(C`$sth\->_set_fbav($data)\*(C'\fR
method (Perl drivers) the driver does not need to do anything about this
routine.
.ie n .IP "$sth\->\fIbind_columns()\fR" 4
.el .IP "\f(CW$sth\fR\->\fIbind_columns()\fR" 4
.IX Item "$sth->bind_columns()"
Regardless of whether the driver uses
\&\f(CW\*(C`DBIc_DBISTATE(imp_xxh)\->get_fbav()\*(C'\fR, the driver does not need
to do anything about this routine as it simply iteratively calls
\&\f(CW\*(C`$sth\->bind_col()\*(C'\fR.
.PP
The \fB\s-1DBI\s0\fR code implements a default implementation of the following
functions which do not need to be written by the \fB\s-1DBD\s0\fR driver writer
unless the default implementation is incorrect for the Driver.
.ie n .IP "$dbh\->\fIquote()\fR" 4
.el .IP "\f(CW$dbh\fR\->\fIquote()\fR" 4
.IX Item "$dbh->quote()"
This should only be written if the database does not accept the \s-1ANSI
SQL\s0 standard for quoting strings, with the string enclosed in single
quotes and any embedded single quotes replaced by two consecutive
single quotes.
.Sp
For the two argument form of quote, you need to implement the
\&\f(CW\*(C`type_info()\*(C'\fR method to provide the information that quote needs.
.ie n .IP "$dbh\->\fIping()\fR" 4
.el .IP "\f(CW$dbh\fR\->\fIping()\fR" 4
.IX Item "$dbh->ping()"
This should be implemented as a simple efficient way to determine
whether the connection to the database is still alive. Typically
code like this:
.Sp
.Vb 9
\&  sub ping {
\&      my $dbh = shift;
\&      $sth = $dbh\->prepare_cached(q{
\&          select * from A_TABLE_NAME where 1=0
\&      }) or return 0;
\&      $sth\->execute or return 0;
\&      $sth\->finish;
\&      return 1;
\&  }
.Ve
.Sp
where \fIA_TABLE_NAME\fR is the name of a table that always exists (such as a
database system catalogue).
.ie n .IP "$drh\->default_user" 4
.el .IP "\f(CW$drh\fR\->default_user" 4
.IX Item "$drh->default_user"
The default implementation of default_user will get the database
username and password fields from \f(CW$ENV{DBI_USER}\fR and
\&\f(CW$ENV{DBI_PASS}\fR. You can override this method. It is called as
follows:
.Sp
.Vb 1
\&  ($user, $pass) = $drh\->default_user($user, $pass, $attr)
.Ve
.SH "METADATA METHODS"
.IX Header "METADATA METHODS"
The exposition above ignores the \fB\s-1DBI\s0\fR MetaData methods.
The metadata methods are all associated with a database handle.
.SS "Using DBI::DBD::Metadata"
.IX Subsection "Using DBI::DBD::Metadata"
The \fBDBI::DBD::Metadata\fR module is a good semi-automatic way for the
developer of a \fB\s-1DBD\s0\fR module to write the \f(CW\*(C`get_info()\*(C'\fR and \f(CW\*(C`type_info()\*(C'\fR
functions quickly and accurately.
.PP
\fIGenerating the get_info method\fR
.IX Subsection "Generating the get_info method"
.PP
Prior to \fB\s-1DBI\s0\fR v1.33, this existed as the method \f(CW\*(C`write_getinfo_pm()\*(C'\fR
in the \fB\s-1DBI::DBD\s0\fR module. From \fB\s-1DBI\s0\fR v1.33, it exists as the method
\&\f(CW\*(C`write_getinfo_pm()\*(C'\fR in the \fBDBI::DBD::Metadata\fR module. This
discussion assumes you have \fB\s-1DBI\s0\fR v1.33 or later.
.PP
You examine the documentation for \f(CW\*(C`write_getinfo_pm()\*(C'\fR using:
.PP
.Vb 1
\&    perldoc DBI::DBD::Metadata
.Ve
.PP
To use it, you need a Perl \fB\s-1DBI\s0\fR driver for your database which implements
the \f(CW\*(C`get_info()\*(C'\fR method. In practice, this means you need to install
\&\fB\s-1DBD::ODBC\s0\fR, an \s-1ODBC\s0 driver manager, and an \s-1ODBC\s0 driver for your
database.
.PP
With the pre-requisites in place, you might type:
.PP
.Vb 2
\&    perl \-MDBI::DBD::Metadata \-we \e
\&       "write_getinfo_pm (qw{ dbi:ODBC:foo_db username password Driver })"
.Ve
.PP
The procedure writes to standard output the code that should be added to
your \fIDriver.pm\fR file and the code that should be written to
\&\fIlib/DBD/Driver/GetInfo.pm\fR.
.PP
You should review the output to ensure that it is sensible.
.PP
\fIGenerating the type_info method\fR
.IX Subsection "Generating the type_info method"
.PP
Given the idea of the \f(CW\*(C`write_getinfo_pm()\*(C'\fR method, it was not hard
to devise a parallel method, \f(CW\*(C`write_typeinfo_pm()\*(C'\fR, which does the
analogous job for the \fB\s-1DBI\s0\fR \f(CW\*(C`type_info_all()\*(C'\fR metadata method. The
\&\f(CW\*(C`write_typeinfo_pm()\*(C'\fR method was added to \fB\s-1DBI\s0\fR v1.33.
.PP
You examine the documentation for \f(CW\*(C`write_typeinfo_pm()\*(C'\fR using:
.PP
.Vb 1
\&    perldoc DBI::DBD::Metadata
.Ve
.PP
The setup is exactly analogous to the mechanism described in
\&\*(L"Generating the get_info method\*(R".
.PP
With the pre-requisites in place, you might type:
.PP
.Vb 2
\&    perl \-MDBI::DBD::Metadata \-we \e
\&       "write_typeinfo (qw{ dbi:ODBC:foo_db username password Driver })"
.Ve
.PP
The procedure writes to standard output the code that should be added to
your \fIDriver.pm\fR file and the code that should be written to
\&\fIlib/DBD/Driver/TypeInfo.pm\fR.
.PP
You should review the output to ensure that it is sensible.
.SS "Writing DBD::Driver::db::get_info"
.IX Subsection "Writing DBD::Driver::db::get_info"
If you use the \fBDBI::DBD::Metadata\fR module, then the code you need is
generated for you.
.PP
If you decide not to use the \fBDBI::DBD::Metadata\fR module, you
should probably borrow the code from a driver that has done so (eg
\&\fBDBD::Informix\fR from version 1.05 onwards) and crib the code from
there, or look at the code that generates that module and follow
that. The method in \fIDriver.pm\fR will be very simple; the method in
\&\fIlib/DBD/Driver/GetInfo.pm\fR is not very much more complex unless your
\&\s-1DBMS\s0 itself is much more complex.
.PP
Note that some of the \fB\s-1DBI\s0\fR utility methods rely on information from the
\&\f(CW\*(C`get_info()\*(C'\fR method to perform their operations correctly. See, for
example, the \f(CW\*(C`quote_identifier()\*(C'\fR and quote methods, discussed below.
.SS "Writing DBD::Driver::db::type_info_all"
.IX Subsection "Writing DBD::Driver::db::type_info_all"
If you use the \f(CW\*(C`DBI::DBD::Metadata\*(C'\fR module, then the code you need is
generated for you.
.PP
If you decide not to use the \f(CW\*(C`DBI::DBD::Metadata\*(C'\fR module, you
should probably borrow the code from a driver that has done so (eg
\&\f(CW\*(C`DBD::Informix\*(C'\fR from version 1.05 onwards) and crib the code from
there, or look at the code that generates that module and follow
that. The method in \fIDriver.pm\fR will be very simple; the method in
\&\fIlib/DBD/Driver/TypeInfo.pm\fR is not very much more complex unless your
\&\s-1DBMS\s0 itself is much more complex.
.SS "Writing DBD::Driver::db::type_info"
.IX Subsection "Writing DBD::Driver::db::type_info"
The guidelines on writing this method are still not really clear.
No sample implementation is available.
.SS "Writing DBD::Driver::db::table_info"
.IX Subsection "Writing DBD::Driver::db::table_info"
.Vb 2
\& *FIX ME* The guidelines on writing this method have not been written yet.
\& No sample implementation is available.
.Ve
.SS "Writing DBD::Driver::db::column_info"
.IX Subsection "Writing DBD::Driver::db::column_info"
.Vb 2
\& *FIX ME* The guidelines on writing this method have not been written yet.
\& No sample implementation is available.
.Ve
.SS "Writing DBD::Driver::db::primary_key_info"
.IX Subsection "Writing DBD::Driver::db::primary_key_info"
.Vb 2
\& *FIX ME* The guidelines on writing this method have not been written yet.
\& No sample implementation is available.
.Ve
.SS "Writing DBD::Driver::db::primary_key"
.IX Subsection "Writing DBD::Driver::db::primary_key"
.Vb 2
\& *FIX ME* The guidelines on writing this method have not been written yet.
\& No sample implementation is available.
.Ve
.SS "Writing DBD::Driver::db::foreign_key_info"
.IX Subsection "Writing DBD::Driver::db::foreign_key_info"
.Vb 2
\& *FIX ME* The guidelines on writing this method have not been written yet.
\& No sample implementation is available.
.Ve
.SS "Writing DBD::Driver::db::tables"
.IX Subsection "Writing DBD::Driver::db::tables"
This method generates an array of names in a format suitable for being
embedded in \s-1SQL\s0 statements in places where a table name is expected.
.PP
If your database hews close enough to the \s-1SQL\s0 standard or if you have
implemented an appropriate \f(CW\*(C`table_info()\*(C'\fR function and and the appropriate
\&\f(CW\*(C`quote_identifier()\*(C'\fR function, then the \fB\s-1DBI\s0\fR default version of this method
will work for your driver too.
.PP
Otherwise, you have to write a function yourself, such as:
.PP
.Vb 12
\&    sub tables
\&    {
\&        my($dbh, $cat, $sch, $tab, $typ) = @_;
\&        my(@res);
\&        my($sth) = $dbh\->table_info($cat, $sch, $tab, $typ);
\&        my(@arr);
\&        while (@arr = $sth\->fetchrow_array)
\&        {
\&            push @res, $dbh\->quote_identifier($arr[0], $arr[1], $arr[2]);
\&        }
\&        return @res;
\&    }
.Ve
.PP
See also the default implementation in \fI\s-1DBI\s0.pm\fR.
.SS "Writing DBD::Driver::db::quote"
.IX Subsection "Writing DBD::Driver::db::quote"
This method takes a value and converts it into a string suitable for
embedding in an \s-1SQL\s0 statement as a string literal.
.PP
If your \s-1DBMS\s0 accepts the \s-1SQL\s0 standard notation for strings (single
quotes around the string as a whole with any embedded single quotes
doubled up), then you do not need to write this method as \fB\s-1DBI\s0\fR provides a
default method that does it for you.
.PP
If your \s-1DBMS\s0 uses an alternative notation or escape mechanism, then you
need to provide an equivalent function. For example, suppose your \s-1DBMS\s0
used C notation with double quotes around the string and backslashes
escaping both double quotes and backslashes themselves. Then you might
write the function as:
.PP
.Vb 6
\&    sub quote
\&    {
\&        my($dbh, $str) = @_;
\&        $str =~ s/["\e\e]/\e\e$&/gmo;
\&        return qq{"$str"};
\&    }
.Ve
.PP
Handling newlines and other control characters is left as an exercise
for the reader.
.PP
This sample method ignores the \fI\f(CI$data_type\fI\fR indicator which is the
optional second argument to the method.
.SS "Writing DBD::Driver::db::quote_identifier"
.IX Subsection "Writing DBD::Driver::db::quote_identifier"
This method is called to ensure that the name of the given table (or
other database object) can be embedded into an \s-1SQL\s0 statement without
danger of misinterpretation. The result string should be usable in the
text of an \s-1SQL\s0 statement as the identifier for a table.
.PP
If your \s-1DBMS\s0 accepts the \s-1SQL\s0 standard notation for quoted identifiers
(which uses double quotes around the identifier as a whole, with any
embedded double quotes doubled up) and accepts \fI\*(L"schema\*(R".\*(L"identifier\*(R"\fR
(and \fI\*(L"catalog\*(R".\*(L"schema\*(R".\*(L"identifier\*(R"\fR when a catalog is specified), then
you do not need to write this method as \fB\s-1DBI\s0\fR provides a default method
that does it for you.
.PP
In fact, even if your \s-1DBMS\s0 does not handle exactly that notation but
you have implemented the \f(CW\*(C`get_info()\*(C'\fR method and it gives the correct
responses, then it will work for you. If your database is fussier, then
you need to implement your own version of the function.
.PP
For example, \fBDBD::Informix\fR has to deal with an environment variable
\&\fI\s-1DELIMIDENT\s0\fR. If it is not set, then the \s-1DBMS\s0 treats names enclosed in
double quotes as strings rather than names, which is usually a syntax
error. Additionally, the catalog portion of the name is separated from
the schema and table by a different delimiter (colon instead of dot),
and the catalog portion is never enclosed in quotes. (Fortunately,
valid strings for the catalog will never contain weird characters that
might need to be escaped, unless you count dots, dashes, slashes and
at-signs as weird.) Finally, an Informix database can contain objects
that cannot be accessed because they were created by a user with the
\&\fI\s-1DELIMIDENT\s0\fR environment variable set, but the current user does not
have it set. By design choice, the \f(CW\*(C`quote_identifier()\*(C'\fR method encloses
those identifiers in double quotes anyway, which generally triggers a
syntax error, and the metadata methods which generate lists of tables
etc omit those identifiers from the result sets.
.PP
.Vb 10
\&    sub quote_identifier
\&    {
\&        my($dbh, $cat, $sch, $obj) = @_;
\&        my($rv) = "";
\&        my($qq) = (defined $ENV{DELIMIDENT}) ? \*(Aq"\*(Aq : \*(Aq\*(Aq;
\&        $rv .= qq{$cat:} if (defined $cat);
\&        if (defined $sch)
\&        {
\&            if ($sch !~ m/^\ew+$/o)
\&            {
\&                $qq = \*(Aq"\*(Aq;
\&                $sch =~ s/$qq/$qq$qq/gm;
\&            }
\&            $rv .= qq{$qq$sch$qq.};
\&        }
\&        if (defined $obj)
\&        {
\&            if ($obj !~ m/^\ew+$/o)
\&            {
\&                $qq = \*(Aq"\*(Aq;
\&                $obj =~ s/$qq/$qq$qq/gm;
\&            }
\&            $rv .= qq{$qq$obj$qq};
\&        }
\&        return $rv;
\&    }
.Ve
.PP
Handling newlines and other control characters is left as an exercise
for the reader.
.PP
Note that there is an optional fourth parameter to this function which
is a reference to a hash of attributes; this sample implementation
ignores that.
.PP
This sample implementation also ignores the single-argument variant of
the method.
.SH "TRACING"
.IX Header "TRACING"
Tracing in \s-1DBI\s0 is controlled with a combination of a trace level and a
set of flags which together are known as the trace settings. The trace
settings are stored in a single integer and divided into levels and
flags by a set of masks (\f(CW\*(C`DBIc_TRACE_LEVEL_MASK\*(C'\fR and
\&\f(CW\*(C`DBIc_TRACE_FLAGS_MASK\*(C'\fR).
.PP
Each handle has it's own trace settings and so does the \s-1DBI.\s0 When you
call a method the \s-1DBI\s0 merges the handles settings into its own for the
duration of the call: the trace flags of the handle are \s-1OR\s0'd into the
trace flags of the \s-1DBI,\s0 and if the handle has a higher trace level
then the \s-1DBI\s0 trace level is raised to match it. The previous \s-1DBI\s0 trace
settings are restored when the called method returns.
.SS "Trace Level"
.IX Subsection "Trace Level"
The trace level is the first 4 bits of the trace settings (masked by
\&\f(CW\*(C`DBIc_TRACE_FLAGS_MASK\*(C'\fR) and represents trace levels of 1 to 15. Do
not output anything at trace levels less than 3 as they are reserved
for \s-1DBI.\s0
.PP
For advice on what to output at each level see \*(L"Trace Levels\*(R" in
\&\s-1DBI\s0.
.PP
To test for a trace level you can use the \f(CW\*(C`DBIc_TRACE_LEVEL\*(C'\fR macro
like this:
.PP
.Vb 3
\&  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2) {
\&      PerlIO_printf(DBIc_LOGPIO(imp_xxh), "foobar");
\&  }
.Ve
.PP
Also \fBnote\fR the use of PerlIO_printf which you should always use for
tracing and never the C \f(CW\*(C`stdio.h\*(C'\fR I/O functions.
.SS "Trace Flags"
.IX Subsection "Trace Flags"
Trace flags are used to enable tracing of specific activities within
the \s-1DBI\s0 and drivers. The \s-1DBI\s0 defines some trace flags and drivers can
define others. \s-1DBI\s0 trace flag names begin with a capital letter and
driver specific names begin with a lowercase letter. For a list of \s-1DBI\s0
defined trace flags see \*(L"Trace Flags\*(R" in \s-1DBI\s0.
.PP
If you want to use private trace flags you'll probably want to be able
to set them by name. Drivers are expected to override the
parse_trace_flag (note the singular) and check if \f(CW$trace_flag_name\fR is
a driver specific trace flags and, if not, then call the DBIs default
\&\fIparse_trace_flag()\fR. To do that you'll need to define a
\&\fIparse_trace_flag()\fR method like this:
.PP
.Vb 9
\&  sub parse_trace_flag {
\&      my ($h, $name) = @_;
\&      return 0x01000000 if $name eq \*(Aqfoo\*(Aq;
\&      return 0x02000000 if $name eq \*(Aqbar\*(Aq;
\&      return 0x04000000 if $name eq \*(Aqbaz\*(Aq;
\&      return 0x08000000 if $name eq \*(Aqboo\*(Aq;
\&      return 0x10000000 if $name eq \*(Aqbop\*(Aq;
\&      return $h\->SUPER::parse_trace_flag($name);
\&  }
.Ve
.PP
All private flag names must be lowercase, and all private flags must
be in the top 8 of the 32 bits of \f(CW\*(C`DBIc_TRACE_FLAGS(imp)\*(C'\fR i.e.,
0xFF000000.
.PP
If you've defined a \fIparse_trace_flag()\fR method in ::db you'll also want
it in ::st, so just alias it in:
.PP
.Vb 1
\&  *parse_trace_flag = \e&DBD::foo:db::parse_trace_flag;
.Ve
.PP
You may want to act on the current '\s-1SQL\s0' trace flag that \s-1DBI\s0 defines
to output \s-1SQL\s0 prepared/executed as \s-1DBI\s0 currently does not do \s-1SQL\s0
tracing.
.SS "Trace Macros"
.IX Subsection "Trace Macros"
Access to the trace level and trace flags is via a set of macros.
.PP
.Vb 4
\&  DBIc_TRACE_SETTINGS(imp) returns the trace settings
\&  DBIc_TRACE_LEVEL(imp) returns the trace level
\&  DBIc_TRACE_FLAGS(imp) returns the trace flags
\&  DBIc_TRACE(imp, flags, flaglevel, level)
\&
\&  e.g.,
\&
\&  DBIc_TRACE(imp, 0, 0, 4)
\&    if level >= 4
\&
\&  DBIc_TRACE(imp, DBDtf_FOO, 2, 4)
\&    if tracing DBDtf_FOO & level>=2 or level>=4
\&
\&  DBIc_TRACE(imp, DBDtf_FOO, 2, 0)
\&    as above but never trace just due to level
.Ve
.SH "WRITING AN EMULATION LAYER FOR AN OLD PERL INTERFACE"
.IX Header "WRITING AN EMULATION LAYER FOR AN OLD PERL INTERFACE"
Study \fIOraperl.pm\fR (supplied with \fBDBD::Oracle\fR) and \fIIngperl.pm\fR (supplied
with \fBDBD::Ingres\fR) and the corresponding \fIdbdimp.c\fR files for ideas.
.PP
Note that the emulation code sets \f(CW\*(C`$dbh\->{CompatMode} = 1;\*(C'\fR for each
connection so that the internals of the driver can implement behaviour
compatible with the old interface when dealing with those handles.
.SS "Setting emulation perl variables"
.IX Subsection "Setting emulation perl variables"
For example, ingperl has a \fI\f(CI$sql_rowcount\fI\fR variable. Rather than try
to manually update this in \fIIngperl.pm\fR it can be done faster in C code.
In \f(CW\*(C`dbd_init()\*(C'\fR:
.PP
.Vb 1
\&  sql_rowcount = perl_get_sv("Ingperl::sql_rowcount", GV_ADDMULTI);
.Ve
.PP
In the relevant places do:
.PP
.Vb 2
\&  if (DBIc_COMPAT(imp_sth))     /* only do this for compatibility mode handles */
\&      sv_setiv(sql_rowcount, the_row_count);
.Ve
.SH "OTHER MISCELLANEOUS INFORMATION"
.IX Header "OTHER MISCELLANEOUS INFORMATION"
.SS "The imp_xyz_t types"
.IX Subsection "The imp_xyz_t types"
Any handle has a corresponding C structure filled with private data.
Some of this data is reserved for use by \fB\s-1DBI\s0\fR (except for using the
DBIc macros below), some is for you. See the description of the
\&\fIdbdimp.h\fR file above for examples. Most functions in \fIdbdimp.c\fR
are passed both the handle \f(CW\*(C`xyz\*(C'\fR and a pointer to \f(CW\*(C`imp_xyz\*(C'\fR. In
rare cases, however, you may use the following macros:
.IP "D_imp_dbh(dbh)" 4
.IX Item "D_imp_dbh(dbh)"
Given a function argument \fIdbh\fR, declare a variable \fIimp_dbh\fR and
initialize it with a pointer to the handles private data. Note: This
must be a part of the function header, because it declares a variable.
.IP "D_imp_sth(sth)" 4
.IX Item "D_imp_sth(sth)"
Likewise for statement handles.
.IP "D_imp_xxx(h)" 4
.IX Item "D_imp_xxx(h)"
Given any handle, declare a variable \fIimp_xxx\fR and initialize it
with a pointer to the handles private data. It is safe, for example,
to cast \fIimp_xxx\fR to \f(CW\*(C`imp_dbh_t*\*(C'\fR, if \f(CW\*(C`DBIc_TYPE(imp_xxx) == DBIt_DB\*(C'\fR.
(You can also call \f(CW\*(C`sv_derived_from(h, "DBI::db")\*(C'\fR, but that's much
slower.)
.IP "D_imp_dbh_from_sth" 4
.IX Item "D_imp_dbh_from_sth"
Given a \fIimp_sth\fR, declare a variable \fIimp_dbh\fR and initialize it with a
pointer to the parent database handle's implementors structure.
.SS "Using DBIc_IMPSET_on"
.IX Subsection "Using DBIc_IMPSET_on"
The driver code which initializes a handle should use \f(CW\*(C`DBIc_IMPSET_on()\*(C'\fR
as soon as its state is such that the cleanup code must be called.
When this happens is determined by your driver code.
.PP
\&\fBFailure to call this can lead to corruption of data structures.\fR
.PP
For example, \fBDBD::Informix\fR maintains a linked list of database
handles in the driver, and within each handle, a linked list of
statements. Once a statement is added to the linked list, it is crucial
that it is cleaned up (removed from the list). When \fI\fIDBIc_IMPSET_on()\fI\fR
was being called too late, it was able to cause all sorts of problems.
.SS "Using \fIDBIc_is()\fP, \fIDBIc_has()\fP, \fIDBIc_on()\fP and \fIDBIc_off()\fP"
.IX Subsection "Using DBIc_is(), DBIc_has(), DBIc_on() and DBIc_off()"
Once upon a long time ago, the only way of handling the internal \fB\s-1DBI\s0\fR
boolean flags/attributes was through macros such as:
.PP
.Vb 2
\&  DBIc_WARN       DBIc_WARN_on        DBIc_WARN_off
\&  DBIc_COMPAT     DBIc_COMPAT_on      DBIc_COMPAT_off
.Ve
.PP
Each of these took an \fIimp_xxh\fR pointer as an argument.
.PP
Since then, new attributes have been added such as \fIChopBlanks\fR,
\&\fIRaiseError\fR and \fIPrintError\fR, and these do not have the full set of
macros. The approved method for handling these is now the four macros:
.PP
.Vb 5
\&  DBIc_is(imp, flag)
\&  DBIc_has(imp, flag)       an alias for DBIc_is
\&  DBIc_on(imp, flag)
\&  DBIc_off(imp, flag)
\&  DBIc_set(imp, flag, on)   set if on is true, else clear
.Ve
.PP
Consequently, the \f(CW\*(C`DBIc_XXXXX\*(C'\fR family of macros is now mostly deprecated
and new drivers should avoid using them, even though the older drivers
will probably continue to do so for quite a while yet. However...
.PP
There is an \fIimportant exception\fR to that. The \fI\s-1ACTIVE\s0\fR and \fI\s-1IMPSET\s0\fR
flags should be set via the \f(CW\*(C`DBIc_ACTIVE_on()\*(C'\fR and \f(CW\*(C`DBIc_IMPSET_on()\*(C'\fR macros,
and unset via the \f(CW\*(C`DBIc_ACTIVE_off()\*(C'\fR and \f(CW\*(C`DBIc_IMPSET_off()\*(C'\fR macros.
.SS "Using the \fIget_fbav()\fP method"
.IX Subsection "Using the get_fbav() method"
\&\fB\s-1THIS IS CRITICAL\s0 for C/XS drivers\fR.
.PP
The \f(CW\*(C`$sth\->bind_col()\*(C'\fR and \f(CW\*(C`$sth\->bind_columns()\*(C'\fR documented
in the \fB\s-1DBI\s0\fR specification do not have to be implemented by the driver
writer because \fB\s-1DBI\s0\fR takes care of the details for you.
.PP
However, the key to ensuring that bound columns work is to call the
function \f(CW\*(C`DBIc_DBISTATE(imp_xxh)\->get_fbav()\*(C'\fR in the code which
fetches a row of data.
.PP
This returns an \f(CW\*(C`AV\*(C'\fR, and each element of the \f(CW\*(C`AV\*(C'\fR contains the \f(CW\*(C`SV\*(C'\fR which
should be set to contain the returned data.
.PP
The pure Perl equivalent is the \f(CW\*(C`$sth\->_set_fbav($data)\*(C'\fR method, as
described in the part on pure Perl drivers.
.SS "Casting strings to Perl types based on a \s-1SQL\s0 type"
.IX Subsection "Casting strings to Perl types based on a SQL type"
\&\s-1DBI\s0 from 1.611 (and \s-1DBIXS_REVISION 13606\s0) defines the
sql_type_cast_svpv method which may be used to cast a string
representation of a value to a more specific Perl type based on a \s-1SQL\s0
type. You should consider using this method when processing bound
column data as it provides some support for the \s-1TYPE\s0 bind_col
attribute which is rarely used in drivers.
.PP
.Vb 1
\&  int sql_type_cast_svpv(pTHX_ SV *sv, int sql_type, U32 flags, void *v)
.Ve
.PP
\&\f(CW\*(C`sv\*(C'\fR is what you would like cast, \f(CW\*(C`sql_type\*(C'\fR is one of the \s-1DBI\s0 defined
\&\s-1SQL\s0 types (e.g., \f(CW\*(C`SQL_INTEGER\*(C'\fR) and \f(CW\*(C`flags\*(C'\fR is a bitmask as follows:
.IP "DBIstcf_STRICT" 4
.IX Item "DBIstcf_STRICT"
If set this indicates you want an error state returned if the cast
cannot be performed.
.IP "DBIstcf_DISCARD_STRING" 4
.IX Item "DBIstcf_DISCARD_STRING"
If set and the pv portion of the \f(CW\*(C`sv\*(C'\fR is cast then this will cause
sv's pv to be freed up.
.PP
sql_type_cast_svpv returns the following states:
.PP
.Vb 5
\& \-2 sql_type is not handled \- sv not changed
\& \-1 sv is undef, sv not changed
\&  0 sv could not be cast cleanly and DBIstcf_STRICT was specified
\&  1 sv could not be case cleanly and DBIstcf_STRICT was not specified
\&  2 sv was cast ok
.Ve
.PP
The current implementation of sql_type_cast_svpv supports
\&\f(CW\*(C`SQL_INTEGER\*(C'\fR, \f(CW\*(C`SQL_DOUBLE\*(C'\fR and \f(CW\*(C`SQL_NUMERIC\*(C'\fR. \f(CW\*(C`SQL_INTEGER\*(C'\fR uses
sv_2iv and hence may set \s-1IV, UV\s0 or \s-1NV\s0 depending on the
number. \f(CW\*(C`SQL_DOUBLE\*(C'\fR uses sv_2nv so may set \s-1NV\s0 and \f(CW\*(C`SQL_NUMERIC\*(C'\fR
will set \s-1IV\s0 or \s-1UV\s0 or \s-1NV.\s0
.PP
DBIstcf_STRICT should be implemented as the StrictlyTyped attribute
and DBIstcf_DISCARD_STRING implemented as the DiscardString attribute
to the bind_col method and both default to off.
.PP
See DBD::Oracle for an example of how this is used.
.SH "SUBCLASSING DBI DRIVERS"
.IX Header "SUBCLASSING DBI DRIVERS"
This is definitely an open subject. It can be done, as demonstrated by
the \fBDBD::File\fR driver, but it is not as simple as one might think.
.PP
(Note that this topic is different from subclassing the \fB\s-1DBI\s0\fR. For an
example of that, see the \fIt/subclass.t\fR file supplied with the \fB\s-1DBI\s0\fR.)
.PP
The main problem is that the \fIdbh\fR's and \fIsth\fR's that your \f(CW\*(C`connect()\*(C'\fR and
\&\f(CW\*(C`prepare()\*(C'\fR methods return are not instances of your \fBDBD::Driver::db\fR
or \fBDBD::Driver::st\fR packages, they are not even derived from it.
Instead they are instances of the \fBDBI::db\fR or \fBDBI::st\fR classes or
a derived subclass. Thus, if you write a method \f(CW\*(C`mymethod()\*(C'\fR and do a
.PP
.Vb 1
\&  $dbh\->mymethod()
.Ve
.PP
then the autoloader will search for that method in the package \fBDBI::db\fR.
Of course you can instead to a
.PP
.Vb 1
\&  $dbh\->func(\*(Aqmymethod\*(Aq)
.Ve
.PP
and that will indeed work, even if \f(CW\*(C`mymethod()\*(C'\fR is inherited, but not
without additional work. Setting \fI\f(CI@ISA\fI\fR is not sufficient.
.SS "Overwriting methods"
.IX Subsection "Overwriting methods"
The first problem is, that the \f(CW\*(C`connect()\*(C'\fR method has no idea of
subclasses. For example, you cannot implement base class and subclass
in the same file: The \f(CW\*(C`install_driver()\*(C'\fR method wants to do a
.PP
.Vb 1
\&  require DBD::Driver;
.Ve
.PP
In particular, your subclass \fBhas\fR to be a separate driver, from
the view of \fB\s-1DBI\s0\fR, and you cannot share driver handles.
.PP
Of course that's not much of a problem. You should even be able
to inherit the base classes \f(CW\*(C`connect()\*(C'\fR method. But you cannot
simply overwrite the method, unless you do something like this,
quoted from \fB\s-1DBD::CSV\s0\fR:
.PP
.Vb 2
\&  sub connect ($$;$$$) {
\&      my ($drh, $dbname, $user, $auth, $attr) = @_;
\&
\&      my $this = $drh\->DBD::File::dr::connect($dbname, $user, $auth, $attr);
\&      if (!exists($this\->{csv_tables})) {
\&          $this\->{csv_tables} = {};
\&      }
\&
\&      $this;
\&  }
.Ve
.PP
Note that we cannot do a
.PP
.Vb 1
\&  $drh\->SUPER::connect($dbname, $user, $auth, $attr);
.Ve
.PP
as we would usually do in a an \s-1OO\s0 environment, because \fI\f(CI$drh\fI\fR is an instance
of \fBDBI::dr\fR. And note, that the \f(CW\*(C`connect()\*(C'\fR method of \fBDBD::File\fR is
able to handle subclass attributes. See the description of Pure Perl
drivers above.
.PP
It is essential that you always call superclass method in the above
manner. However, that should do.
.SS "Attribute handling"
.IX Subsection "Attribute handling"
Fortunately the \fB\s-1DBI\s0\fR specifications allow a simple, but still
performant way of handling attributes. The idea is based on the
convention that any driver uses a prefix \fIdriver_\fR for its private
methods. Thus it's always clear whether to pass attributes to the super
class or not. For example, consider this \f(CW\*(C`STORE()\*(C'\fR method from the
\&\fB\s-1DBD::CSV\s0\fR class:
.PP
.Vb 8
\&  sub STORE {
\&      my ($dbh, $attr, $val) = @_;
\&      if ($attr !~ /^driver_/) {
\&          return $dbh\->DBD::File::db::STORE($attr, $val);
\&      }
\&      if ($attr eq \*(Aqdriver_foo\*(Aq) {
\&      ...
\&  }
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan Leffler <jleffler@us.ibm.com> (previously <jleffler@informix.com>),
Jochen Wiedmann <joe@ispsoft.de>,
Steffen Goeldner <sgoeldner@cpan.org>,
and Tim Bunce <dbi\-users@perl.org>.
                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::DBD::Metadata.3pm                       0100644 0001750 0001750 00000022137 12566241600 024221  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::DBD::Metadata 3"
.TH DBI::DBD::Metadata 3 "2013-06-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::DBD::Metadata \- Generate the code and data for some DBI metadata methods
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The idea is to extract metadata information from a good quality
\&\s-1ODBC\s0 driver and use it to generate code and data to use in your own
\&\s-1DBI\s0 driver for the same database.
.PP
To generate code to support the get_info method:
.PP
.Vb 1
\&  perl \-MDBI::DBD::Metadata \-e "write_getinfo_pm(\*(Aqdbi:ODBC:dsn\-name\*(Aq,\*(Aquser\*(Aq,\*(Aqpass\*(Aq,\*(AqDriver\*(Aq)"
\&
\&  perl \-MDBI::DBD::Metadata \-e write_getinfo_pm dbi:ODBC:foo_db username password Driver
.Ve
.PP
To generate code to support the type_info method:
.PP
.Vb 1
\&  perl \-MDBI::DBD::Metadata \-e "write_typeinfo_pm(\*(Aqdbi:ODBC:dsn\-name\*(Aq,\*(Aquser\*(Aq,\*(Aqpass\*(Aq,\*(AqDriver\*(Aq)"
\&
\&  perl \-MDBI::DBD::Metadata \-e write_typeinfo_pm dbi:ODBC:dsn\-name user pass Driver
.Ve
.PP
Where \f(CW\*(C`dbi:ODBC:dsn\-name\*(C'\fR is the connection to use to extract the
data, and \f(CW\*(C`Driver\*(C'\fR is the name of the driver you want the code
generated for (the driver name gets embedded into the output in
numerous places).
.SH "Generating a GetInfo package for a driver"
.IX Header "Generating a GetInfo package for a driver"
The \f(CW\*(C`write_getinfo_pm\*(C'\fR in the DBI::DBD::Metadata module generates a
DBD::Driver::GetInfo package on standard output.
.PP
This method generates a DBD::Driver::GetInfo package from the data
source you specified in the parameter list or in the environment
variable \s-1DBI_DSN.\s0
DBD::Driver::GetInfo should help a \s-1DBD\s0 author implement the \s-1DBI\s0
\&\fIget_info()\fR method.
Because you are just creating this package, it is very unlikely that
DBD::Driver already provides a good implementation for \fIget_info()\fR.
Thus you will probably connect via \s-1DBD::ODBC.\s0
.PP
Once you are sure that it is producing reasonably sane data, you should
typically redirect the standard output to lib/DBD/Driver/GetInfo.pm, and
then hand edit the result.
Do not forget to update your Makefile.PL and \s-1MANIFEST\s0 to include this as
an extra \s-1PM\s0 file that should be installed.
.PP
If you connect via \s-1DBD::ODBC,\s0 you should use version 0.38 or greater;
.PP
Please take a critical look at the data returned!
\&\s-1ODBC\s0 drivers vary dramatically in their quality.
.PP
The generator assumes that most values are static and places these
values directly in the \f(CW%info\fR hash.
A few examples show the use of \s-1CODE\s0 references and the implementation
via subroutines.
It is very likely that you will have to write additional subroutines for
values depending on the session state or server version, e.g.
\&\s-1SQL_DBMS_VER.\s0
.PP
A possible implementation of \fIDBD::Driver::db::get_info()\fR may look like:
.PP
.Vb 7
\&  sub get_info {
\&    my($dbh, $info_type) = @_;
\&    require DBD::Driver::GetInfo;
\&    my $v = $DBD::Driver::GetInfo::info{int($info_type)};
\&    $v = $v\->($dbh) if ref $v eq \*(AqCODE\*(Aq;
\&    return $v;
\&  }
.Ve
.PP
Please replace Driver (or \*(L"<foo>\*(R") with the name of your driver.
Note that this stub function is generated for you by write_getinfo_pm
function, but you must manually transfer the code to Driver.pm.
.SH "Generating a TypeInfo package for a driver"
.IX Header "Generating a TypeInfo package for a driver"
The \f(CW\*(C`write_typeinfo_pm\*(C'\fR function in the DBI::DBD::Metadata module generates
on standard output the data needed for a driver's type_info_all method.
It also provides default implementations of the type_info_all
method for inclusion in the driver's main implementation file.
.PP
The driver parameter is the name of the driver for which the methods
will be generated; for the sake of examples, this will be \*(L"Driver\*(R".
Typically, the dsn parameter will be of the form \*(L"dbi:ODBC:odbc_dsn\*(R",
where the odbc_dsn is a \s-1DSN\s0 for one of the driver's databases.
The user and pass parameters are the other optional connection
parameters that will be provided to the \s-1DBI\s0 connect method.
.PP
Once you are sure that it is producing reasonably sane data, you should
typically redirect the standard output to lib/DBD/Driver/TypeInfo.pm,
and then hand edit the result if necessary.
Do not forget to update your Makefile.PL and \s-1MANIFEST\s0 to include this as
an extra \s-1PM\s0 file that should be installed.
.PP
Please take a critical look at the data returned!
\&\s-1ODBC\s0 drivers vary dramatically in their quality.
.PP
The generator assumes that all the values are static and places these
values directly in the \f(CW%info\fR hash.
.PP
A possible implementation of \fIDBD::Driver::type_info_all()\fR may look like:
.PP
.Vb 5
\&  sub type_info_all {
\&    my ($dbh) = @_;
\&    require DBD::Driver::TypeInfo;
\&    return [ @$DBD::Driver::TypeInfo::type_info_all ];
\&  }
.Ve
.PP
Please replace Driver (or \*(L"<foo>\*(R") with the name of your driver.
Note that this stub function is generated for you by the write_typeinfo_pm
function, but you must manually transfer the code to Driver.pm.
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan Leffler <jleffler@us.ibm.com> (previously <jleffler@informix.com>),
Jochen Wiedmann <joe@ispsoft.de>,
Steffen Goeldner <sgoeldner@cpan.org>,
and Tim Bunce <dbi\-users@perl.org>.
                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::DBD::Metadata5.16.3pm                   0100644 0001750 0001750 00000021616 12566241577 024551  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::DBD::Metadata 3"
.TH DBI::DBD::Metadata 3 "2010-07-02" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::DBD::Metadata \- Generate the code and data for some DBI metadata methods
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The idea is to extract metadata information from a good quality
\&\s-1ODBC\s0 driver and use it to generate code and data to use in your own
\&\s-1DBI\s0 driver for the same database.
.PP
To generate code to support the get_info method:
.PP
.Vb 1
\&  perl \-MDBI::DBD::Metadata \-e "write_getinfo_pm(\*(Aqdbi:ODBC:dsn\-name\*(Aq,\*(Aquser\*(Aq,\*(Aqpass\*(Aq,\*(AqDriver\*(Aq)"
\&
\&  perl \-MDBI::DBD::Metadata \-e write_getinfo_pm dbi:ODBC:foo_db username password Driver
.Ve
.PP
To generate code to support the type_info method:
.PP
.Vb 1
\&  perl \-MDBI::DBD::Metadata \-e "write_typeinfo_pm(\*(Aqdbi:ODBC:dsn\-name\*(Aq,\*(Aquser\*(Aq,\*(Aqpass\*(Aq,\*(AqDriver\*(Aq)"
\&
\&  perl \-MDBI::DBD::Metadata \-e write_typeinfo_pm dbi:ODBC:dsn\-name user pass Driver
.Ve
.PP
Where \f(CW\*(C`dbi:ODBC:dsn\-name\*(C'\fR is the connection to use to extract the
data, and \f(CW\*(C`Driver\*(C'\fR is the name of the driver you want the code
generated for (the driver name gets embedded into the output in
numerous places).
.SH "Generating a GetInfo package for a driver"
.IX Header "Generating a GetInfo package for a driver"
The \f(CW\*(C`write_getinfo_pm\*(C'\fR in the DBI::DBD::Metadata module generates a
DBD::Driver::GetInfo package on standard output.
.PP
This method generates a DBD::Driver::GetInfo package from the data
source you specified in the parameter list or in the environment
variable \s-1DBI_DSN\s0.
DBD::Driver::GetInfo should help a \s-1DBD\s0 author implement the \s-1DBI\s0
\&\fIget_info()\fR method.
Because you are just creating this package, it is very unlikely that
DBD::Driver already provides a good implementation for \fIget_info()\fR.
Thus you will probably connect via \s-1DBD::ODBC\s0.
.PP
Once you are sure that it is producing reasonably sane data, you should
typically redirect the standard output to lib/DBD/Driver/GetInfo.pm, and
then hand edit the result.
Do not forget to update your Makefile.PL and \s-1MANIFEST\s0 to include this as
an extra \s-1PM\s0 file that should be installed.
.PP
If you connect via \s-1DBD::ODBC\s0, you should use version 0.38 or greater;
.PP
Please take a critical look at the data returned!
\&\s-1ODBC\s0 drivers vary dramatically in their quality.
.PP
The generator assumes that most values are static and places these
values directly in the \f(CW%info\fR hash.
A few examples show the use of \s-1CODE\s0 references and the implementation
via subroutines.
It is very likely that you will have to write additional subroutines for
values depending on the session state or server version, e.g.
\&\s-1SQL_DBMS_VER\s0.
.PP
A possible implementation of \fIDBD::Driver::db::get_info()\fR may look like:
.PP
.Vb 7
\&  sub get_info {
\&    my($dbh, $info_type) = @_;
\&    require DBD::Driver::GetInfo;
\&    my $v = $DBD::Driver::GetInfo::info{int($info_type)};
\&    $v = $v\->($dbh) if ref $v eq \*(AqCODE\*(Aq;
\&    return $v;
\&  }
.Ve
.PP
Please replace Driver (or \*(L"<foo>\*(R") with the name of your driver.
Note that this stub function is generated for you by write_getinfo_pm
function, but you must manually transfer the code to Driver.pm.
.SH "Generating a TypeInfo package for a driver"
.IX Header "Generating a TypeInfo package for a driver"
The \f(CW\*(C`write_typeinfo_pm\*(C'\fR function in the DBI::DBD::Metadata module generates
on standard output the data needed for a driver's type_info_all method.
It also provides default implementations of the type_info_all
method for inclusion in the driver's main implementation file.
.PP
The driver parameter is the name of the driver for which the methods
will be generated; for the sake of examples, this will be \*(L"Driver\*(R".
Typically, the dsn parameter will be of the form \*(L"dbi:ODBC:odbc_dsn\*(R",
where the odbc_dsn is a \s-1DSN\s0 for one of the driver's databases.
The user and pass parameters are the other optional connection
parameters that will be provided to the \s-1DBI\s0 connect method.
.PP
Once you are sure that it is producing reasonably sane data, you should
typically redirect the standard output to lib/DBD/Driver/TypeInfo.pm,
and then hand edit the result if necessary.
Do not forget to update your Makefile.PL and \s-1MANIFEST\s0 to include this as
an extra \s-1PM\s0 file that should be installed.
.PP
Please take a critical look at the data returned!
\&\s-1ODBC\s0 drivers vary dramatically in their quality.
.PP
The generator assumes that all the values are static and places these
values directly in the \f(CW%info\fR hash.
.PP
A possible implementation of \fIDBD::Driver::type_info_all()\fR may look like:
.PP
.Vb 5
\&  sub type_info_all {
\&    my ($dbh) = @_;
\&    require DBD::Driver::TypeInfo;
\&    return [ @$DBD::Driver::TypeInfo::type_info_all ];
\&  }
.Ve
.PP
Please replace Driver (or \*(L"<foo>\*(R") with the name of your driver.
Note that this stub function is generated for you by the write_typeinfo_pm
function, but you must manually transfer the code to Driver.pm.
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan Leffler <jleffler@us.ibm.com> (previously <jleffler@informix.com>),
Jochen Wiedmann <joe@ispsoft.de>,
Steffen Goeldner <sgoeldner@cpan.org>,
and Tim Bunce <dbi\-users@perl.org>.
                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::DBD::Metadata5.18.3pm                   0100644 0001750 0001750 00000022137 12566241600 024535  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::DBD::Metadata 3"
.TH DBI::DBD::Metadata 3 "2013-06-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::DBD::Metadata \- Generate the code and data for some DBI metadata methods
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The idea is to extract metadata information from a good quality
\&\s-1ODBC\s0 driver and use it to generate code and data to use in your own
\&\s-1DBI\s0 driver for the same database.
.PP
To generate code to support the get_info method:
.PP
.Vb 1
\&  perl \-MDBI::DBD::Metadata \-e "write_getinfo_pm(\*(Aqdbi:ODBC:dsn\-name\*(Aq,\*(Aquser\*(Aq,\*(Aqpass\*(Aq,\*(AqDriver\*(Aq)"
\&
\&  perl \-MDBI::DBD::Metadata \-e write_getinfo_pm dbi:ODBC:foo_db username password Driver
.Ve
.PP
To generate code to support the type_info method:
.PP
.Vb 1
\&  perl \-MDBI::DBD::Metadata \-e "write_typeinfo_pm(\*(Aqdbi:ODBC:dsn\-name\*(Aq,\*(Aquser\*(Aq,\*(Aqpass\*(Aq,\*(AqDriver\*(Aq)"
\&
\&  perl \-MDBI::DBD::Metadata \-e write_typeinfo_pm dbi:ODBC:dsn\-name user pass Driver
.Ve
.PP
Where \f(CW\*(C`dbi:ODBC:dsn\-name\*(C'\fR is the connection to use to extract the
data, and \f(CW\*(C`Driver\*(C'\fR is the name of the driver you want the code
generated for (the driver name gets embedded into the output in
numerous places).
.SH "Generating a GetInfo package for a driver"
.IX Header "Generating a GetInfo package for a driver"
The \f(CW\*(C`write_getinfo_pm\*(C'\fR in the DBI::DBD::Metadata module generates a
DBD::Driver::GetInfo package on standard output.
.PP
This method generates a DBD::Driver::GetInfo package from the data
source you specified in the parameter list or in the environment
variable \s-1DBI_DSN.\s0
DBD::Driver::GetInfo should help a \s-1DBD\s0 author implement the \s-1DBI\s0
\&\fIget_info()\fR method.
Because you are just creating this package, it is very unlikely that
DBD::Driver already provides a good implementation for \fIget_info()\fR.
Thus you will probably connect via \s-1DBD::ODBC.\s0
.PP
Once you are sure that it is producing reasonably sane data, you should
typically redirect the standard output to lib/DBD/Driver/GetInfo.pm, and
then hand edit the result.
Do not forget to update your Makefile.PL and \s-1MANIFEST\s0 to include this as
an extra \s-1PM\s0 file that should be installed.
.PP
If you connect via \s-1DBD::ODBC,\s0 you should use version 0.38 or greater;
.PP
Please take a critical look at the data returned!
\&\s-1ODBC\s0 drivers vary dramatically in their quality.
.PP
The generator assumes that most values are static and places these
values directly in the \f(CW%info\fR hash.
A few examples show the use of \s-1CODE\s0 references and the implementation
via subroutines.
It is very likely that you will have to write additional subroutines for
values depending on the session state or server version, e.g.
\&\s-1SQL_DBMS_VER.\s0
.PP
A possible implementation of \fIDBD::Driver::db::get_info()\fR may look like:
.PP
.Vb 7
\&  sub get_info {
\&    my($dbh, $info_type) = @_;
\&    require DBD::Driver::GetInfo;
\&    my $v = $DBD::Driver::GetInfo::info{int($info_type)};
\&    $v = $v\->($dbh) if ref $v eq \*(AqCODE\*(Aq;
\&    return $v;
\&  }
.Ve
.PP
Please replace Driver (or \*(L"<foo>\*(R") with the name of your driver.
Note that this stub function is generated for you by write_getinfo_pm
function, but you must manually transfer the code to Driver.pm.
.SH "Generating a TypeInfo package for a driver"
.IX Header "Generating a TypeInfo package for a driver"
The \f(CW\*(C`write_typeinfo_pm\*(C'\fR function in the DBI::DBD::Metadata module generates
on standard output the data needed for a driver's type_info_all method.
It also provides default implementations of the type_info_all
method for inclusion in the driver's main implementation file.
.PP
The driver parameter is the name of the driver for which the methods
will be generated; for the sake of examples, this will be \*(L"Driver\*(R".
Typically, the dsn parameter will be of the form \*(L"dbi:ODBC:odbc_dsn\*(R",
where the odbc_dsn is a \s-1DSN\s0 for one of the driver's databases.
The user and pass parameters are the other optional connection
parameters that will be provided to the \s-1DBI\s0 connect method.
.PP
Once you are sure that it is producing reasonably sane data, you should
typically redirect the standard output to lib/DBD/Driver/TypeInfo.pm,
and then hand edit the result if necessary.
Do not forget to update your Makefile.PL and \s-1MANIFEST\s0 to include this as
an extra \s-1PM\s0 file that should be installed.
.PP
Please take a critical look at the data returned!
\&\s-1ODBC\s0 drivers vary dramatically in their quality.
.PP
The generator assumes that all the values are static and places these
values directly in the \f(CW%info\fR hash.
.PP
A possible implementation of \fIDBD::Driver::type_info_all()\fR may look like:
.PP
.Vb 5
\&  sub type_info_all {
\&    my ($dbh) = @_;
\&    require DBD::Driver::TypeInfo;
\&    return [ @$DBD::Driver::TypeInfo::type_info_all ];
\&  }
.Ve
.PP
Please replace Driver (or \*(L"<foo>\*(R") with the name of your driver.
Note that this stub function is generated for you by the write_typeinfo_pm
function, but you must manually transfer the code to Driver.pm.
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan Leffler <jleffler@us.ibm.com> (previously <jleffler@informix.com>),
Jochen Wiedmann <joe@ispsoft.de>,
Steffen Goeldner <sgoeldner@cpan.org>,
and Tim Bunce <dbi\-users@perl.org>.
                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::DBD::SqlEngine.3pm                      0100644 0001750 0001750 00000054670 12566241601 024376  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::DBD::SqlEngine 3"
.TH DBI::DBD::SqlEngine 3 "2013-06-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::DBD::SqlEngine \- Base class for DBI drivers without their own SQL engine
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package DBD::myDriver;
\&
\&    use base qw(DBI::DBD::SqlEngine);
\&
\&    sub driver
\&    {
\&        ...
\&        my $drh = $proto\->SUPER::driver($attr);
\&        ...
\&        return $drh\->{class};
\&        }
\&
\&    package DBD::myDriver::dr;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::dr);
\&
\&    sub data_sources { ... }
\&    ...
\&
\&    package DBD::myDriver::db;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::db);
\&
\&    sub init_valid_attributes { ... }
\&    sub init_default_attributes { ... }
\&    sub set_versions { ... }
\&    sub validate_STORE_attr { my ($dbh, $attrib, $value) = @_; ... }
\&    sub validate_FETCH_attr { my ($dbh, $attrib) = @_; ... }
\&    sub get_myd_versions { ... }
\&    sub get_avail_tables { ... }
\&
\&    package DBD::myDriver::st;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::st);
\&
\&    sub FETCH { ... }
\&    sub STORE { ... }
\&
\&    package DBD::myDriver::Statement;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::Statement);
\&
\&    sub open_table { ... }
\&
\&    package DBD::myDriver::Table;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::Table);
\&
\&    sub new { ... }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBI::DBD::SqlEngine abstracts the usage of \s-1SQL\s0 engines from the
\&\s-1DBD. DBD\s0 authors can concentrate on the data retrieval they want to
provide.
.PP
It is strongly recommended that you read DBD::File::Developers and
DBD::File::Roadmap, because many of the DBD::File \s-1API\s0 is provided
by DBI::DBD::SqlEngine.
.PP
Currently the \s-1API\s0 of DBI::DBD::SqlEngine is experimental and will
likely change in the near future to provide the table meta data basics
like DBD::File.
.SS "Metadata"
.IX Subsection "Metadata"
The following attributes are handled by \s-1DBI\s0 itself and not by
DBI::DBD::SqlEngine, thus they all work as expected:
.PP
.Vb 10
\&    Active
\&    ActiveKids
\&    CachedKids
\&    CompatMode             (Not used)
\&    InactiveDestroy
\&    AutoInactiveDestroy
\&    Kids
\&    PrintError
\&    RaiseError
\&    Warn                   (Not used)
.Ve
.PP
\fIThe following \s-1DBI\s0 attributes are handled by DBI::DBD::SqlEngine:\fR
.IX Subsection "The following DBI attributes are handled by DBI::DBD::SqlEngine:"
.PP
AutoCommit
.IX Subsection "AutoCommit"
.PP
Always on.
.PP
ChopBlanks
.IX Subsection "ChopBlanks"
.PP
Works.
.PP
\s-1NUM_OF_FIELDS\s0
.IX Subsection "NUM_OF_FIELDS"
.PP
Valid after \f(CW\*(C`$sth\->execute\*(C'\fR.
.PP
\s-1NUM_OF_PARAMS\s0
.IX Subsection "NUM_OF_PARAMS"
.PP
Valid after \f(CW\*(C`$sth\->prepare\*(C'\fR.
.PP
\s-1NAME\s0
.IX Subsection "NAME"
.PP
Valid after \f(CW\*(C`$sth\->execute\*(C'\fR; probably undef for Non-Select statements.
.PP
\s-1NULLABLE\s0
.IX Subsection "NULLABLE"
.PP
Not really working, always returns an array ref of ones, as \s-1DBD::CSV\s0
does not verify input data. Valid after \f(CW\*(C`$sth\->execute\*(C'\fR; undef for
non-select statements.
.PP
\fIThe following \s-1DBI\s0 attributes and methods are not supported:\fR
.IX Subsection "The following DBI attributes and methods are not supported:"
.IP "bind_param_inout" 4
.IX Item "bind_param_inout"
.PD 0
.IP "CursorName" 4
.IX Item "CursorName"
.IP "LongReadLen" 4
.IX Item "LongReadLen"
.IP "LongTruncOk" 4
.IX Item "LongTruncOk"
.PD
.PP
\fIDBI::DBD::SqlEngine specific attributes\fR
.IX Subsection "DBI::DBD::SqlEngine specific attributes"
.PP
In addition to the \s-1DBI\s0 attributes, you can use the following dbh
attributes:
.PP
sql_engine_version
.IX Subsection "sql_engine_version"
.PP
Contains the module version of this driver (\fBreadonly\fR)
.PP
sql_nano_version
.IX Subsection "sql_nano_version"
.PP
Contains the module version of DBI::SQL::Nano (\fBreadonly\fR)
.PP
sql_statement_version
.IX Subsection "sql_statement_version"
.PP
Contains the module version of SQL::Statement, if available (\fBreadonly\fR)
.PP
sql_handler
.IX Subsection "sql_handler"
.PP
Contains the \s-1SQL\s0 Statement engine, either DBI::SQL::Nano or SQL::Statement
(\fBreadonly\fR).
.PP
sql_parser_object
.IX Subsection "sql_parser_object"
.PP
Contains an instantiated instance of SQL::Parser (\fBreadonly\fR).
This is filled when used first time (only when used with SQL::Statement).
.PP
sql_sponge_driver
.IX Subsection "sql_sponge_driver"
.PP
Contains an internally used DBD::Sponge handle (\fBreadonly\fR).
.PP
sql_valid_attrs
.IX Subsection "sql_valid_attrs"
.PP
Contains the list of valid attributes for each DBI::DBD::SqlEngine based
driver (\fBreadonly\fR).
.PP
sql_readonly_attrs
.IX Subsection "sql_readonly_attrs"
.PP
Contains the list of those attributes which are readonly (\fBreadonly\fR).
.PP
sql_identifier_case
.IX Subsection "sql_identifier_case"
.PP
Contains how DBI::DBD::SqlEngine deals with non-quoted \s-1SQL\s0 identifiers:
.PP
.Vb 5
\&  * SQL_IC_UPPER (1) means all identifiers are internally converted
\&    into upper\-cased pendants
\&  * SQL_IC_LOWER (2) means all identifiers are internally converted
\&    into lower\-cased pendants
\&  * SQL_IC_MIXED (4) means all identifiers are taken as they are
.Ve
.PP
These conversions happen if (and only if) no existing identifier matches.
Once existing identifier is used as known.
.PP
The \s-1SQL\s0 statement execution classes doesn't have to care, so don't expect
\&\f(CW\*(C`sql_identifier_case\*(C'\fR affects column names in statements like
.PP
.Vb 1
\&  SELECT * FROM foo
.Ve
.PP
sql_quoted_identifier_case
.IX Subsection "sql_quoted_identifier_case"
.PP
Contains how DBI::DBD::SqlEngine deals with quoted \s-1SQL\s0 identifiers
(\fBreadonly\fR). It's fixated to \s-1SQL_IC_SENSITIVE \\fIs0\fR\|(3), which is interpreted
as \s-1SQL_IC_MIXED.\s0
.PP
sql_flags
.IX Subsection "sql_flags"
.PP
Contains additional flags to instantiate an SQL::Parser. Because an
SQL::Parser is instantiated only once, it's recommended to set this flag
before any statement is executed.
.PP
sql_dialect
.IX Subsection "sql_dialect"
.PP
Controls the dialect understood by SQL::Parser. Possible values (delivery
state of SQL::Statement):
.PP
.Vb 3
\&  * ANSI
\&  * CSV
\&  * AnyData
.Ve
.PP
Defaults to \*(L"\s-1CSV\*(R". \s0 Because an SQL::Parser is instantiated only once and
SQL::Parser doesn't allow to modify the dialect once instantiated,
it's strongly recommended to set this flag before any statement is
executed (best place is connect attribute hash).
.PP
sql_engine_in_gofer
.IX Subsection "sql_engine_in_gofer"
.PP
This value has a true value in case of this driver is operated via
DBD::Gofer. The impact of being operated via Gofer is a read-only
driver (not read-only databases!), so you cannot modify any attributes
later \- neither any table settings. \fBBut\fR you won't get an error in
cases you modify table attributes, so please carefully watch
\&\f(CW\*(C`sql_engine_in_gofer\*(C'\fR.
.PP
sql_meta
.IX Subsection "sql_meta"
.PP
Private data area which contains information about the tables this
module handles. Table meta data might not be available until the
table has been accessed for the first time e.g., by issuing a select
on it however it is possible to pre-initialize attributes for each table
you use.
.PP
DBI::DBD::SqlEngine recognizes the (public) attributes \f(CW\*(C`col_names\*(C'\fR,
\&\f(CW\*(C`table_name\*(C'\fR, \f(CW\*(C`readonly\*(C'\fR, \f(CW\*(C`sql_data_source\*(C'\fR and \f(CW\*(C`sql_identifier_case\*(C'\fR.
Be very careful when modifying attributes you do not know, the consequence
might be a destroyed or corrupted table.
.PP
While \f(CW\*(C`sql_meta\*(C'\fR is a private and readonly attribute (which means, you
cannot modify it's values), derived drivers might provide restricted
write access through another attribute. Well known accessors are
\&\f(CW\*(C`csv_tables\*(C'\fR for \s-1DBD::CSV\s0, \f(CW\*(C`ad_tables\*(C'\fR for DBD::AnyData and
\&\f(CW\*(C`dbm_tables\*(C'\fR for \s-1DBD::DBM\s0.
.PP
sql_table_source
.IX Subsection "sql_table_source"
.PP
Controls the class which will be used for fetching available tables.
.PP
See \*(L"DBI::DBD::SqlEngine::TableSource\*(R" for details.
.PP
sql_data_source
.IX Subsection "sql_data_source"
.PP
Contains the class name to be used for opening tables.
.PP
See \*(L"DBI::DBD::SqlEngine::DataSource\*(R" for details.
.SS "Driver private methods"
.IX Subsection "Driver private methods"
\fIDefault \s-1DBI\s0 methods\fR
.IX Subsection "Default DBI methods"
.PP
data_sources
.IX Subsection "data_sources"
.PP
The \f(CW\*(C`data_sources\*(C'\fR method returns a list of subdirectories of the current
directory in the form \*(L"dbi:CSV:f_dir=$dirname\*(R".
.PP
If you want to read the subdirectories of another directory, use
.PP
.Vb 2
\&    my ($drh)  = DBI\->install_driver ("CSV");
\&    my (@list) = $drh\->data_sources (f_dir => "/usr/local/csv_data");
.Ve
.PP
list_tables
.IX Subsection "list_tables"
.PP
This method returns a list of file names inside \f(CW$dbh\fR\->{f_dir}.
Example:
.PP
.Vb 2
\&    my ($dbh)  = DBI\->connect ("dbi:CSV:f_dir=/usr/local/csv_data");
\&    my (@list) = $dbh\->func ("list_tables");
.Ve
.PP
Note that the list includes all files contained in the directory, even
those that have non-valid table names, from the view of \s-1SQL.\s0
.PP
\fIAdditional methods\fR
.IX Subsection "Additional methods"
.PP
The following methods are only available via their documented name when
DBI::DBD::SQlEngine is used directly. Because this is only reasonable for
testing purposes, the real names must be used instead. Those names can be
computed by replacing the \f(CW\*(C`sql_\*(C'\fR in the method name with the driver prefix.
.PP
sql_versions
.IX Subsection "sql_versions"
.PP
Signature:
.PP
.Vb 5
\&  sub sql_versions (;$) {
\&    my ($table_name) = @_;
\&    $table_name ||= ".";
\&    ...
\&    }
.Ve
.PP
Returns the versions of the driver, including the \s-1DBI\s0 version, the Perl
version, DBI::PurePerl version (if DBI::PurePerl is active) and the version
of the \s-1SQL\s0 engine in use.
.PP
.Vb 8
\&    my $dbh = DBI\->connect ("dbi:File:");
\&    my $sql_versions = $dbh\->func( "sql_versions" );
\&    print "$sql_versions\en";
\&    _\|_END_\|_
\&    # DBI::DBD::SqlEngine  0.05 using SQL::Statement 1.402
\&    # DBI                  1.623
\&    # OS                   netbsd (6.99.12)
\&    # Perl                 5.016002 (x86_64\-netbsd\-thread\-multi)
.Ve
.PP
Called in list context, sql_versions will return an array containing each
line as single entry.
.PP
Some drivers might use the optional (table name) argument and modify
version information related to the table (e.g. \s-1DBD::DBM\s0 provides storage
backend information for the requested table, when it has a table name).
.PP
sql_get_meta
.IX Subsection "sql_get_meta"
.PP
Signature:
.PP
.Vb 5
\&    sub sql_get_meta ($$)
\&    {
\&        my ($table_name, $attrib) = @_;
\&        ...
\&    }
.Ve
.PP
Returns the value of a meta attribute set for a specific table, if any.
See sql_meta for the possible attributes.
.PP
A table name of \f(CW"."\fR (single dot) is interpreted as the default table.
This will retrieve the appropriate attribute globally from the dbh.
This has the same restrictions as \f(CW\*(C`$dbh\->{$attrib}\*(C'\fR.
.PP
sql_set_meta
.IX Subsection "sql_set_meta"
.PP
Signature:
.PP
.Vb 5
\&    sub sql_set_meta ($$$)
\&    {
\&        my ($table_name, $attrib, $value) = @_;
\&        ...
\&    }
.Ve
.PP
Sets the value of a meta attribute set for a specific table.
See sql_meta for the possible attributes.
.PP
A table name of \f(CW"."\fR (single dot) is interpreted as the default table
which will set the specified attribute globally for the dbh.
This has the same restrictions as \f(CW\*(C`$dbh\->{$attrib} = $value\*(C'\fR.
.PP
sql_clear_meta
.IX Subsection "sql_clear_meta"
.PP
Signature:
.PP
.Vb 5
\&    sub sql_clear_meta ($)
\&    {
\&        my ($table_name) = @_;
\&        ...
\&    }
.Ve
.PP
Clears the table specific meta information in the private storage of the
dbh.
.SS "Extensibility"
.IX Subsection "Extensibility"
\fIDBI::DBD::SqlEngine::TableSource\fR
.IX Subsection "DBI::DBD::SqlEngine::TableSource"
.PP
Provides data sources and table information on database driver and database
handle level.
.PP
.Vb 1
\&  package DBI::DBD::SqlEngine::TableSource;
\&
\&  sub data_sources ($;$)
\&  {
\&    my ( $class, $drh, $attrs ) = @_;
\&    ...
\&  }
\&
\&  sub avail_tables
\&  {
\&    my ( $class, $drh ) = @_;
\&    ...
\&  }
.Ve
.PP
The \f(CW\*(C`data_sources\*(C'\fR method is called when the user invokes any of the
following:
.PP
.Vb 2
\&  @ary = DBI\->data_sources($driver);
\&  @ary = DBI\->data_sources($driver, \e%attr);
\&  
\&  @ary = $dbh\->data_sources();
\&  @ary = $dbh\->data_sources(\e%attr);
.Ve
.PP
The \f(CW\*(C`avail_tables\*(C'\fR method is called when the user invokes any of the
following:
.PP
.Vb 1
\&  @names = $dbh\->tables( $catalog, $schema, $table, $type );
\&  
\&  $sth = $dbh\->table_info( $catalog, $schema, $table, $type );
\&  $sth = $dbh\->table_info( $catalog, $schema, $table, $type, \e%attr );
\&
\&  $dbh\->func( "list_tables" );
.Ve
.PP
Every time where an \f(CW\*(C`\e%attr\*(C'\fR argument can be specified, this \f(CW\*(C`\e%attr\*(C'\fR
object's \f(CW\*(C`sql_table_source\*(C'\fR attribute is preferred over the \f(CW$dbh\fR
attribute or the driver default, eg.
.PP
.Vb 6
\&  @ary = DBI\->data_sources("dbi:CSV:", {
\&    f_dir => "/your/csv/tables",
\&    # note: this class doesn\*(Aqt comes with DBI
\&    sql_table_source => "DBD::File::Archive::Tar::TableSource",
\&    # scan tarballs instead of directories
\&  });
.Ve
.PP
When you're going to implement such a DBD::File::Archive::Tar::TableSource
class, remember to add correct attributes (including \f(CW\*(C`sql_table_source\*(C'\fR
and \f(CW\*(C`sql_data_source\*(C'\fR) to the returned \s-1DSN\s0's.
.PP
\fIDBI::DBD::SqlEngine::DataSource\fR
.IX Subsection "DBI::DBD::SqlEngine::DataSource"
.PP
Provides base functionality for dealing with tables. It is primarily
designed for allowing transparent access to files on disk or already
opened (file\-)streams (eg. for \s-1DBD::CSV\s0).
.PP
Derived classes shall be restricted to similar functionality, too (eg.
opening streams from an archive, transparently compress/uncompress
log files before parsing them,
.PP
.Vb 1
\&  package DBI::DBD::SqlEngine::DataSource;
\&
\&  sub complete_table_name ($$;$)
\&  {
\&    my ( $self, $meta, $table, $respect_case ) = @_;
\&    ...
\&  }
.Ve
.PP
The method \f(CW\*(C`complete_table_name\*(C'\fR is called when first setting up the
\&\fImeta information\fR for a table:
.PP
.Vb 1
\&  "SELECT user.id, user.name, user.shell FROM user WHERE ..."
.Ve
.PP
results in opening the table \f(CW\*(C`user\*(C'\fR. First step of the table open
process is completing the name. Let's imagine you're having a \s-1DBD::CSV\s0
handle with following settings:
.PP
.Vb 3
\&  $dbh\->{sql_identifier_case} = SQL_IC_LOWER;
\&  $dbh\->{f_ext} = \*(Aq.lst\*(Aq;
\&  $dbh\->{f_dir} = \*(Aq/data/web/adrmgr\*(Aq;
.Ve
.PP
Those settings will result in looking for files matching
\&\f(CW\*(C`[Uu][Ss][Ee][Rr](\e.lst)?$\*(C'\fR in \f(CW\*(C`/data/web/adrmgr/\*(C'\fR. The scanning of the
directory \f(CW\*(C`/data/web/adrmgr/\*(C'\fR and the pattern match check will be done
in \f(CW\*(C`DBD::File::DataSource::File\*(C'\fR by the \f(CW\*(C`complete_table_name\*(C'\fR method.
.PP
If you intend to provide other sources of data streams than files, in
addition to provide an appropriate \f(CW\*(C`complete_table_name\*(C'\fR method, a method
to open the resource is required:
.PP
.Vb 1
\&  package DBI::DBD::SqlEngine::DataSource;
\&
\&  sub open_data ($)
\&  {
\&    my ( $self, $meta, $attrs, $flags ) = @_;
\&    ...
\&  }
.Ve
.PP
After the method \f(CW\*(C`open_data\*(C'\fR has been run successfully, the table's meta
information are in a state which allowes the table's data accessor methods
will be able to fetch/store row information. Implementation details heavily
depends on the table implementation, whereby the most famous is surely
DBD::File::Table.
.SH "SQL ENGINES"
.IX Header "SQL ENGINES"
DBI::DBD::SqlEngine currently supports two \s-1SQL\s0 engines:
SQL::Statement and
DBI::SQL::Nano::Statement_. DBI::SQL::Nano supports a
\&\fIvery\fR limited subset of \s-1SQL\s0 statements, but it might be faster for some
very simple tasks. SQL::Statement in contrast supports a much larger subset
of \s-1ANSI SQL.\s0
.PP
To use SQL::Statement, you need at least version 1.401 of
SQL::Statement and the environment variable \f(CW\*(C`DBI_SQL_NANO\*(C'\fR must not
be set to a true value.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc DBI::DBD::SqlEngine
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=DBI>
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=SQL\-Statement>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/DBI>
<http://annocpan.org/dist/SQL\-Statement>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/DBI>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/DBI/>
.SS "Where can I go for more help?"
.IX Subsection "Where can I go for more help?"
For questions about installation or usage, please ask on the
dbi\-dev@perl.org mailing list.
.PP
If you have a bug report, patch or suggestion, please open
a new report ticket on \s-1CPAN,\s0 if there is not already one for
the issue you want to report. Of course, you can mail any of the
module maintainers, but it is less likely to be missed if
it is reported on \s-1RT.\s0
.PP
Report tickets should contain a detailed description of the bug or
enhancement request you want to report and at least an easy way to
verify/reproduce the issue and any supplied fix. Patches are always
welcome, too.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to Tim Bunce, Martin Evans and H.Merijn Brand for their continued
support while developing DBD::File, \s-1DBD::DBM\s0 and DBD::AnyData.
Their support, hints and feedback helped to design and implement this
module.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module is currently maintained by
.PP
H.Merijn Brand < h.m.brand at xs4all.nl > and
Jens Rehsack  < rehsack at googlemail.com >
.PP
The original authors are Jochen Wiedmann and Jeff Zucker.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
.Vb 3
\& Copyright (C) 2009\-2013 by H.Merijn Brand & Jens Rehsack
\& Copyright (C) 2004\-2009 by Jeff Zucker
\& Copyright (C) 1998\-2004 by Jochen Wiedmann
.Ve
.PP
All rights reserved.
.PP
You may freely distribute and/or modify this module under the terms of
either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License, as
specified in the Perl \s-1README\s0 file.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1DBI\s0, DBD::File, DBD::AnyData and DBD::Sys.
                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::DBD::SqlEngine5.16.3pm                  0100644 0001750 0001750 00000030666 12566241600 024706  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::DBD::SqlEngine 3"
.TH DBI::DBD::SqlEngine 3 "2012-04-20" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::DBD::SqlEngine \- Base class for DBI drivers without their own SQL engine
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package DBD::myDriver;
\&
\&    use base qw(DBI::DBD::SqlEngine);
\&
\&    sub driver
\&    {
\&        ...
\&        my $drh = $proto\->SUPER::driver($attr);
\&        ...
\&        return $drh\->{class};
\&        }
\&
\&    package DBD::myDriver::dr;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::dr);
\&
\&    sub data_sources { ... }
\&    ...
\&
\&    package DBD::myDriver::db;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::db);
\&
\&    sub init_valid_attributes { ... }
\&    sub init_default_attributes { ... }
\&    sub set_versions { ... }
\&    sub validate_STORE_attr { my ($dbh, $attrib, $value) = @_; ... }
\&    sub validate_FETCH_attr { my ($dbh, $attrib) = @_; ... }
\&    sub get_myd_versions { ... }
\&    sub get_avail_tables { ... }
\&
\&    package DBD::myDriver::st;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::st);
\&
\&    sub FETCH { ... }
\&    sub STORE { ... }
\&
\&    package DBD::myDriver::Statement;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::Statement);
\&
\&    sub open_table { ... }
\&
\&    package DBD::myDriver::Table;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::Table);
\&
\&    sub new { ... }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBI::DBD::SqlEngine abstracts the usage of \s-1SQL\s0 engines from the
\&\s-1DBD\s0. \s-1DBD\s0 authors can concentrate on the data retrieval they want to
provide.
.PP
It is strongly recommended that you read DBD::File::Developers and
DBD::File::Roadmap, because many of the DBD::File \s-1API\s0 is provided
by DBI::DBD::SqlEngine.
.PP
Currently the \s-1API\s0 of DBI::DBD::SqlEngine is experimental and will
likely change in the near future to provide the table meta data basics
like DBD::File.
.SS "Metadata"
.IX Subsection "Metadata"
The following attributes are handled by \s-1DBI\s0 itself and not by
DBI::DBD::SqlEngine, thus they all work as expected:
.PP
.Vb 10
\&    Active
\&    ActiveKids
\&    CachedKids
\&    CompatMode             (Not used)
\&    InactiveDestroy
\&    AutoInactiveDestroy
\&    Kids
\&    PrintError
\&    RaiseError
\&    Warn                   (Not used)
.Ve
.PP
\fIThe following \s-1DBI\s0 attributes are handled by DBI::DBD::SqlEngine:\fR
.IX Subsection "The following DBI attributes are handled by DBI::DBD::SqlEngine:"
.PP
AutoCommit
.IX Subsection "AutoCommit"
.PP
Always on.
.PP
ChopBlanks
.IX Subsection "ChopBlanks"
.PP
Works.
.PP
\s-1NUM_OF_FIELDS\s0
.IX Subsection "NUM_OF_FIELDS"
.PP
Valid after \f(CW\*(C`$sth\->execute\*(C'\fR.
.PP
\s-1NUM_OF_PARAMS\s0
.IX Subsection "NUM_OF_PARAMS"
.PP
Valid after \f(CW\*(C`$sth\->prepare\*(C'\fR.
.PP
\s-1NAME\s0
.IX Subsection "NAME"
.PP
Valid after \f(CW\*(C`$sth\->execute\*(C'\fR; probably undef for Non-Select statements.
.PP
\s-1NULLABLE\s0
.IX Subsection "NULLABLE"
.PP
Not really working, always returns an array ref of ones, as \s-1DBD::CSV\s0
does not verify input data. Valid after \f(CW\*(C`$sth\->execute\*(C'\fR; undef for
non-select statements.
.PP
\fIThe following \s-1DBI\s0 attributes and methods are not supported:\fR
.IX Subsection "The following DBI attributes and methods are not supported:"
.IP "bind_param_inout" 4
.IX Item "bind_param_inout"
.PD 0
.IP "CursorName" 4
.IX Item "CursorName"
.IP "LongReadLen" 4
.IX Item "LongReadLen"
.IP "LongTruncOk" 4
.IX Item "LongTruncOk"
.PD
.PP
\fIDBI::DBD::SqlEngine specific attributes\fR
.IX Subsection "DBI::DBD::SqlEngine specific attributes"
.PP
In addition to the \s-1DBI\s0 attributes, you can use the following dbh
attributes:
.PP
sql_engine_version
.IX Subsection "sql_engine_version"
.PP
Contains the module version of this driver (\fBreadonly\fR)
.PP
sql_nano_version
.IX Subsection "sql_nano_version"
.PP
Contains the module version of DBI::SQL::Nano (\fBreadonly\fR)
.PP
sql_statement_version
.IX Subsection "sql_statement_version"
.PP
Contains the module version of SQL::Statement, if available (\fBreadonly\fR)
.PP
sql_handler
.IX Subsection "sql_handler"
.PP
Contains the \s-1SQL\s0 Statement engine, either DBI::SQL::Nano or SQL::Statement
(\fBreadonly\fR).
.PP
sql_parser_object
.IX Subsection "sql_parser_object"
.PP
Contains an instantiated instance of SQL::Parser (\fBreadonly\fR).
This is filled when used first time (only when used with SQL::Statement).
.PP
sql_sponge_driver
.IX Subsection "sql_sponge_driver"
.PP
Contains an internally used DBD::Sponge handle (\fBreadonly\fR).
.PP
sql_valid_attrs
.IX Subsection "sql_valid_attrs"
.PP
Contains the list of valid attributes for each DBI::DBD::SqlEngine based
driver (\fBreadonly\fR).
.PP
sql_readonly_attrs
.IX Subsection "sql_readonly_attrs"
.PP
Contains the list of those attributes which are readonly (\fBreadonly\fR).
.PP
sql_identifier_case
.IX Subsection "sql_identifier_case"
.PP
Contains how DBI::DBD::SqlEngine deals with non-quoted \s-1SQL\s0 identifiers:
.PP
.Vb 5
\&  * SQL_IC_UPPER (1) means all identifiers are internally converted
\&    into upper\-cased pendants
\&  * SQL_IC_LOWER (2) means all identifiers are internally converted
\&    into lower\-cased pendants
\&  * SQL_IC_MIXED (4) means all identifiers are taken as they are
.Ve
.PP
These conversions happen if (and only if) no existing identifier matches.
Once existing identifier is used as known.
.PP
The \s-1SQL\s0 statement execution classes doesn't have to care, so don't expect
\&\f(CW\*(C`sql_identifier_case\*(C'\fR affects column names in statements like
.PP
.Vb 1
\&  SELECT * FROM foo
.Ve
.PP
sql_quoted_identifier_case
.IX Subsection "sql_quoted_identifier_case"
.PP
Contains how DBI::DBD::SqlEngine deals with quoted \s-1SQL\s0 identifiers
(\fBreadonly\fR). It's fixated to \s-1SQL_IC_SENSITIVE\s0 (3), which is interpreted
as \s-1SQL_IC_MIXED\s0.
.PP
sql_flags
.IX Subsection "sql_flags"
.PP
Contains additional flags to instantiate an SQL::Parser. Because an
SQL::Parser is instantiated only once, it's recommended to set this flag
before any statement is executed.
.PP
sql_dialect
.IX Subsection "sql_dialect"
.PP
Controls the dialect understood by SQL::Parser. Possible values (delivery
state of SQL::Statement):
.PP
.Vb 3
\&  * ANSI
\&  * CSV
\&  * AnyData
.Ve
.PP
Defaults to \*(L"\s-1CSV\s0\*(R".  Because an SQL::Parser is instantiated only once and
SQL::Parser doesn't allow to modify the dialect once instantiated,
it's strongly recommended to set this flag before any statement is
executed (best place is connect attribute hash).
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc DBI::DBD::SqlEngine
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT:\s0 \s-1CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=DBI>
http://rt.cpan.org/NoAuth/Bugs.html?Dist=SQL\-Statement <http://rt.cpan.org/NoAuth/Bugs.html?Dist=SQL-Statement>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/DBI>
http://annocpan.org/dist/SQL\-Statement <http://annocpan.org/dist/SQL-Statement>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/DBI>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/DBI/>
.SS "Where can I go for more help?"
.IX Subsection "Where can I go for more help?"
For questions about installation or usage, please ask on the
dbi\-dev@perl.org mailing list.
.PP
If you have a bug report, patch or suggestion, please open
a new report ticket on \s-1CPAN\s0, if there is not already one for
the issue you want to report. Of course, you can mail any of the
module maintainers, but it is less likely to be missed if
it is reported on \s-1RT\s0.
.PP
Report tickets should contain a detailed description of the bug or
enhancement request you want to report and at least an easy way to
verify/reproduce the issue and any supplied fix. Patches are always
welcome, too.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to Tim Bunce, Martin Evans and H.Merijn Brand for their continued
support while developing DBD::File, \s-1DBD::DBM\s0 and DBD::AnyData.
Their support, hints and feedback helped to design and implement this
module.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module is currently maintained by
.PP
H.Merijn Brand < h.m.brand at xs4all.nl > and
Jens Rehsack  < rehsack at googlemail.com >
.PP
The original authors are Jochen Wiedmann and Jeff Zucker.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
.Vb 3
\& Copyright (C) 2009\-2010 by H.Merijn Brand & Jens Rehsack
\& Copyright (C) 2004\-2009 by Jeff Zucker
\& Copyright (C) 1998\-2004 by Jochen Wiedmann
.Ve
.PP
All rights reserved.
.PP
You may freely distribute and/or modify this module under the terms of
either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License, as
specified in the Perl \s-1README\s0 file.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1DBI\s0, DBD::File, DBD::AnyData and DBD::Sys.
                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::DBD::SqlEngine5.18.3pm                  0100644 0001750 0001750 00000054670 12566241601 024712  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::DBD::SqlEngine 3"
.TH DBI::DBD::SqlEngine 3 "2013-06-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::DBD::SqlEngine \- Base class for DBI drivers without their own SQL engine
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package DBD::myDriver;
\&
\&    use base qw(DBI::DBD::SqlEngine);
\&
\&    sub driver
\&    {
\&        ...
\&        my $drh = $proto\->SUPER::driver($attr);
\&        ...
\&        return $drh\->{class};
\&        }
\&
\&    package DBD::myDriver::dr;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::dr);
\&
\&    sub data_sources { ... }
\&    ...
\&
\&    package DBD::myDriver::db;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::db);
\&
\&    sub init_valid_attributes { ... }
\&    sub init_default_attributes { ... }
\&    sub set_versions { ... }
\&    sub validate_STORE_attr { my ($dbh, $attrib, $value) = @_; ... }
\&    sub validate_FETCH_attr { my ($dbh, $attrib) = @_; ... }
\&    sub get_myd_versions { ... }
\&    sub get_avail_tables { ... }
\&
\&    package DBD::myDriver::st;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::st);
\&
\&    sub FETCH { ... }
\&    sub STORE { ... }
\&
\&    package DBD::myDriver::Statement;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::Statement);
\&
\&    sub open_table { ... }
\&
\&    package DBD::myDriver::Table;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::Table);
\&
\&    sub new { ... }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBI::DBD::SqlEngine abstracts the usage of \s-1SQL\s0 engines from the
\&\s-1DBD. DBD\s0 authors can concentrate on the data retrieval they want to
provide.
.PP
It is strongly recommended that you read DBD::File::Developers and
DBD::File::Roadmap, because many of the DBD::File \s-1API\s0 is provided
by DBI::DBD::SqlEngine.
.PP
Currently the \s-1API\s0 of DBI::DBD::SqlEngine is experimental and will
likely change in the near future to provide the table meta data basics
like DBD::File.
.SS "Metadata"
.IX Subsection "Metadata"
The following attributes are handled by \s-1DBI\s0 itself and not by
DBI::DBD::SqlEngine, thus they all work as expected:
.PP
.Vb 10
\&    Active
\&    ActiveKids
\&    CachedKids
\&    CompatMode             (Not used)
\&    InactiveDestroy
\&    AutoInactiveDestroy
\&    Kids
\&    PrintError
\&    RaiseError
\&    Warn                   (Not used)
.Ve
.PP
\fIThe following \s-1DBI\s0 attributes are handled by DBI::DBD::SqlEngine:\fR
.IX Subsection "The following DBI attributes are handled by DBI::DBD::SqlEngine:"
.PP
AutoCommit
.IX Subsection "AutoCommit"
.PP
Always on.
.PP
ChopBlanks
.IX Subsection "ChopBlanks"
.PP
Works.
.PP
\s-1NUM_OF_FIELDS\s0
.IX Subsection "NUM_OF_FIELDS"
.PP
Valid after \f(CW\*(C`$sth\->execute\*(C'\fR.
.PP
\s-1NUM_OF_PARAMS\s0
.IX Subsection "NUM_OF_PARAMS"
.PP
Valid after \f(CW\*(C`$sth\->prepare\*(C'\fR.
.PP
\s-1NAME\s0
.IX Subsection "NAME"
.PP
Valid after \f(CW\*(C`$sth\->execute\*(C'\fR; probably undef for Non-Select statements.
.PP
\s-1NULLABLE\s0
.IX Subsection "NULLABLE"
.PP
Not really working, always returns an array ref of ones, as \s-1DBD::CSV\s0
does not verify input data. Valid after \f(CW\*(C`$sth\->execute\*(C'\fR; undef for
non-select statements.
.PP
\fIThe following \s-1DBI\s0 attributes and methods are not supported:\fR
.IX Subsection "The following DBI attributes and methods are not supported:"
.IP "bind_param_inout" 4
.IX Item "bind_param_inout"
.PD 0
.IP "CursorName" 4
.IX Item "CursorName"
.IP "LongReadLen" 4
.IX Item "LongReadLen"
.IP "LongTruncOk" 4
.IX Item "LongTruncOk"
.PD
.PP
\fIDBI::DBD::SqlEngine specific attributes\fR
.IX Subsection "DBI::DBD::SqlEngine specific attributes"
.PP
In addition to the \s-1DBI\s0 attributes, you can use the following dbh
attributes:
.PP
sql_engine_version
.IX Subsection "sql_engine_version"
.PP
Contains the module version of this driver (\fBreadonly\fR)
.PP
sql_nano_version
.IX Subsection "sql_nano_version"
.PP
Contains the module version of DBI::SQL::Nano (\fBreadonly\fR)
.PP
sql_statement_version
.IX Subsection "sql_statement_version"
.PP
Contains the module version of SQL::Statement, if available (\fBreadonly\fR)
.PP
sql_handler
.IX Subsection "sql_handler"
.PP
Contains the \s-1SQL\s0 Statement engine, either DBI::SQL::Nano or SQL::Statement
(\fBreadonly\fR).
.PP
sql_parser_object
.IX Subsection "sql_parser_object"
.PP
Contains an instantiated instance of SQL::Parser (\fBreadonly\fR).
This is filled when used first time (only when used with SQL::Statement).
.PP
sql_sponge_driver
.IX Subsection "sql_sponge_driver"
.PP
Contains an internally used DBD::Sponge handle (\fBreadonly\fR).
.PP
sql_valid_attrs
.IX Subsection "sql_valid_attrs"
.PP
Contains the list of valid attributes for each DBI::DBD::SqlEngine based
driver (\fBreadonly\fR).
.PP
sql_readonly_attrs
.IX Subsection "sql_readonly_attrs"
.PP
Contains the list of those attributes which are readonly (\fBreadonly\fR).
.PP
sql_identifier_case
.IX Subsection "sql_identifier_case"
.PP
Contains how DBI::DBD::SqlEngine deals with non-quoted \s-1SQL\s0 identifiers:
.PP
.Vb 5
\&  * SQL_IC_UPPER (1) means all identifiers are internally converted
\&    into upper\-cased pendants
\&  * SQL_IC_LOWER (2) means all identifiers are internally converted
\&    into lower\-cased pendants
\&  * SQL_IC_MIXED (4) means all identifiers are taken as they are
.Ve
.PP
These conversions happen if (and only if) no existing identifier matches.
Once existing identifier is used as known.
.PP
The \s-1SQL\s0 statement execution classes doesn't have to care, so don't expect
\&\f(CW\*(C`sql_identifier_case\*(C'\fR affects column names in statements like
.PP
.Vb 1
\&  SELECT * FROM foo
.Ve
.PP
sql_quoted_identifier_case
.IX Subsection "sql_quoted_identifier_case"
.PP
Contains how DBI::DBD::SqlEngine deals with quoted \s-1SQL\s0 identifiers
(\fBreadonly\fR). It's fixated to \s-1SQL_IC_SENSITIVE \\fIs0\fR\|(3), which is interpreted
as \s-1SQL_IC_MIXED.\s0
.PP
sql_flags
.IX Subsection "sql_flags"
.PP
Contains additional flags to instantiate an SQL::Parser. Because an
SQL::Parser is instantiated only once, it's recommended to set this flag
before any statement is executed.
.PP
sql_dialect
.IX Subsection "sql_dialect"
.PP
Controls the dialect understood by SQL::Parser. Possible values (delivery
state of SQL::Statement):
.PP
.Vb 3
\&  * ANSI
\&  * CSV
\&  * AnyData
.Ve
.PP
Defaults to \*(L"\s-1CSV\*(R". \s0 Because an SQL::Parser is instantiated only once and
SQL::Parser doesn't allow to modify the dialect once instantiated,
it's strongly recommended to set this flag before any statement is
executed (best place is connect attribute hash).
.PP
sql_engine_in_gofer
.IX Subsection "sql_engine_in_gofer"
.PP
This value has a true value in case of this driver is operated via
DBD::Gofer. The impact of being operated via Gofer is a read-only
driver (not read-only databases!), so you cannot modify any attributes
later \- neither any table settings. \fBBut\fR you won't get an error in
cases you modify table attributes, so please carefully watch
\&\f(CW\*(C`sql_engine_in_gofer\*(C'\fR.
.PP
sql_meta
.IX Subsection "sql_meta"
.PP
Private data area which contains information about the tables this
module handles. Table meta data might not be available until the
table has been accessed for the first time e.g., by issuing a select
on it however it is possible to pre-initialize attributes for each table
you use.
.PP
DBI::DBD::SqlEngine recognizes the (public) attributes \f(CW\*(C`col_names\*(C'\fR,
\&\f(CW\*(C`table_name\*(C'\fR, \f(CW\*(C`readonly\*(C'\fR, \f(CW\*(C`sql_data_source\*(C'\fR and \f(CW\*(C`sql_identifier_case\*(C'\fR.
Be very careful when modifying attributes you do not know, the consequence
might be a destroyed or corrupted table.
.PP
While \f(CW\*(C`sql_meta\*(C'\fR is a private and readonly attribute (which means, you
cannot modify it's values), derived drivers might provide restricted
write access through another attribute. Well known accessors are
\&\f(CW\*(C`csv_tables\*(C'\fR for \s-1DBD::CSV\s0, \f(CW\*(C`ad_tables\*(C'\fR for DBD::AnyData and
\&\f(CW\*(C`dbm_tables\*(C'\fR for \s-1DBD::DBM\s0.
.PP
sql_table_source
.IX Subsection "sql_table_source"
.PP
Controls the class which will be used for fetching available tables.
.PP
See \*(L"DBI::DBD::SqlEngine::TableSource\*(R" for details.
.PP
sql_data_source
.IX Subsection "sql_data_source"
.PP
Contains the class name to be used for opening tables.
.PP
See \*(L"DBI::DBD::SqlEngine::DataSource\*(R" for details.
.SS "Driver private methods"
.IX Subsection "Driver private methods"
\fIDefault \s-1DBI\s0 methods\fR
.IX Subsection "Default DBI methods"
.PP
data_sources
.IX Subsection "data_sources"
.PP
The \f(CW\*(C`data_sources\*(C'\fR method returns a list of subdirectories of the current
directory in the form \*(L"dbi:CSV:f_dir=$dirname\*(R".
.PP
If you want to read the subdirectories of another directory, use
.PP
.Vb 2
\&    my ($drh)  = DBI\->install_driver ("CSV");
\&    my (@list) = $drh\->data_sources (f_dir => "/usr/local/csv_data");
.Ve
.PP
list_tables
.IX Subsection "list_tables"
.PP
This method returns a list of file names inside \f(CW$dbh\fR\->{f_dir}.
Example:
.PP
.Vb 2
\&    my ($dbh)  = DBI\->connect ("dbi:CSV:f_dir=/usr/local/csv_data");
\&    my (@list) = $dbh\->func ("list_tables");
.Ve
.PP
Note that the list includes all files contained in the directory, even
those that have non-valid table names, from the view of \s-1SQL.\s0
.PP
\fIAdditional methods\fR
.IX Subsection "Additional methods"
.PP
The following methods are only available via their documented name when
DBI::DBD::SQlEngine is used directly. Because this is only reasonable for
testing purposes, the real names must be used instead. Those names can be
computed by replacing the \f(CW\*(C`sql_\*(C'\fR in the method name with the driver prefix.
.PP
sql_versions
.IX Subsection "sql_versions"
.PP
Signature:
.PP
.Vb 5
\&  sub sql_versions (;$) {
\&    my ($table_name) = @_;
\&    $table_name ||= ".";
\&    ...
\&    }
.Ve
.PP
Returns the versions of the driver, including the \s-1DBI\s0 version, the Perl
version, DBI::PurePerl version (if DBI::PurePerl is active) and the version
of the \s-1SQL\s0 engine in use.
.PP
.Vb 8
\&    my $dbh = DBI\->connect ("dbi:File:");
\&    my $sql_versions = $dbh\->func( "sql_versions" );
\&    print "$sql_versions\en";
\&    _\|_END_\|_
\&    # DBI::DBD::SqlEngine  0.05 using SQL::Statement 1.402
\&    # DBI                  1.623
\&    # OS                   netbsd (6.99.12)
\&    # Perl                 5.016002 (x86_64\-netbsd\-thread\-multi)
.Ve
.PP
Called in list context, sql_versions will return an array containing each
line as single entry.
.PP
Some drivers might use the optional (table name) argument and modify
version information related to the table (e.g. \s-1DBD::DBM\s0 provides storage
backend information for the requested table, when it has a table name).
.PP
sql_get_meta
.IX Subsection "sql_get_meta"
.PP
Signature:
.PP
.Vb 5
\&    sub sql_get_meta ($$)
\&    {
\&        my ($table_name, $attrib) = @_;
\&        ...
\&    }
.Ve
.PP
Returns the value of a meta attribute set for a specific table, if any.
See sql_meta for the possible attributes.
.PP
A table name of \f(CW"."\fR (single dot) is interpreted as the default table.
This will retrieve the appropriate attribute globally from the dbh.
This has the same restrictions as \f(CW\*(C`$dbh\->{$attrib}\*(C'\fR.
.PP
sql_set_meta
.IX Subsection "sql_set_meta"
.PP
Signature:
.PP
.Vb 5
\&    sub sql_set_meta ($$$)
\&    {
\&        my ($table_name, $attrib, $value) = @_;
\&        ...
\&    }
.Ve
.PP
Sets the value of a meta attribute set for a specific table.
See sql_meta for the possible attributes.
.PP
A table name of \f(CW"."\fR (single dot) is interpreted as the default table
which will set the specified attribute globally for the dbh.
This has the same restrictions as \f(CW\*(C`$dbh\->{$attrib} = $value\*(C'\fR.
.PP
sql_clear_meta
.IX Subsection "sql_clear_meta"
.PP
Signature:
.PP
.Vb 5
\&    sub sql_clear_meta ($)
\&    {
\&        my ($table_name) = @_;
\&        ...
\&    }
.Ve
.PP
Clears the table specific meta information in the private storage of the
dbh.
.SS "Extensibility"
.IX Subsection "Extensibility"
\fIDBI::DBD::SqlEngine::TableSource\fR
.IX Subsection "DBI::DBD::SqlEngine::TableSource"
.PP
Provides data sources and table information on database driver and database
handle level.
.PP
.Vb 1
\&  package DBI::DBD::SqlEngine::TableSource;
\&
\&  sub data_sources ($;$)
\&  {
\&    my ( $class, $drh, $attrs ) = @_;
\&    ...
\&  }
\&
\&  sub avail_tables
\&  {
\&    my ( $class, $drh ) = @_;
\&    ...
\&  }
.Ve
.PP
The \f(CW\*(C`data_sources\*(C'\fR method is called when the user invokes any of the
following:
.PP
.Vb 2
\&  @ary = DBI\->data_sources($driver);
\&  @ary = DBI\->data_sources($driver, \e%attr);
\&  
\&  @ary = $dbh\->data_sources();
\&  @ary = $dbh\->data_sources(\e%attr);
.Ve
.PP
The \f(CW\*(C`avail_tables\*(C'\fR method is called when the user invokes any of the
following:
.PP
.Vb 1
\&  @names = $dbh\->tables( $catalog, $schema, $table, $type );
\&  
\&  $sth = $dbh\->table_info( $catalog, $schema, $table, $type );
\&  $sth = $dbh\->table_info( $catalog, $schema, $table, $type, \e%attr );
\&
\&  $dbh\->func( "list_tables" );
.Ve
.PP
Every time where an \f(CW\*(C`\e%attr\*(C'\fR argument can be specified, this \f(CW\*(C`\e%attr\*(C'\fR
object's \f(CW\*(C`sql_table_source\*(C'\fR attribute is preferred over the \f(CW$dbh\fR
attribute or the driver default, eg.
.PP
.Vb 6
\&  @ary = DBI\->data_sources("dbi:CSV:", {
\&    f_dir => "/your/csv/tables",
\&    # note: this class doesn\*(Aqt comes with DBI
\&    sql_table_source => "DBD::File::Archive::Tar::TableSource",
\&    # scan tarballs instead of directories
\&  });
.Ve
.PP
When you're going to implement such a DBD::File::Archive::Tar::TableSource
class, remember to add correct attributes (including \f(CW\*(C`sql_table_source\*(C'\fR
and \f(CW\*(C`sql_data_source\*(C'\fR) to the returned \s-1DSN\s0's.
.PP
\fIDBI::DBD::SqlEngine::DataSource\fR
.IX Subsection "DBI::DBD::SqlEngine::DataSource"
.PP
Provides base functionality for dealing with tables. It is primarily
designed for allowing transparent access to files on disk or already
opened (file\-)streams (eg. for \s-1DBD::CSV\s0).
.PP
Derived classes shall be restricted to similar functionality, too (eg.
opening streams from an archive, transparently compress/uncompress
log files before parsing them,
.PP
.Vb 1
\&  package DBI::DBD::SqlEngine::DataSource;
\&
\&  sub complete_table_name ($$;$)
\&  {
\&    my ( $self, $meta, $table, $respect_case ) = @_;
\&    ...
\&  }
.Ve
.PP
The method \f(CW\*(C`complete_table_name\*(C'\fR is called when first setting up the
\&\fImeta information\fR for a table:
.PP
.Vb 1
\&  "SELECT user.id, user.name, user.shell FROM user WHERE ..."
.Ve
.PP
results in opening the table \f(CW\*(C`user\*(C'\fR. First step of the table open
process is completing the name. Let's imagine you're having a \s-1DBD::CSV\s0
handle with following settings:
.PP
.Vb 3
\&  $dbh\->{sql_identifier_case} = SQL_IC_LOWER;
\&  $dbh\->{f_ext} = \*(Aq.lst\*(Aq;
\&  $dbh\->{f_dir} = \*(Aq/data/web/adrmgr\*(Aq;
.Ve
.PP
Those settings will result in looking for files matching
\&\f(CW\*(C`[Uu][Ss][Ee][Rr](\e.lst)?$\*(C'\fR in \f(CW\*(C`/data/web/adrmgr/\*(C'\fR. The scanning of the
directory \f(CW\*(C`/data/web/adrmgr/\*(C'\fR and the pattern match check will be done
in \f(CW\*(C`DBD::File::DataSource::File\*(C'\fR by the \f(CW\*(C`complete_table_name\*(C'\fR method.
.PP
If you intend to provide other sources of data streams than files, in
addition to provide an appropriate \f(CW\*(C`complete_table_name\*(C'\fR method, a method
to open the resource is required:
.PP
.Vb 1
\&  package DBI::DBD::SqlEngine::DataSource;
\&
\&  sub open_data ($)
\&  {
\&    my ( $self, $meta, $attrs, $flags ) = @_;
\&    ...
\&  }
.Ve
.PP
After the method \f(CW\*(C`open_data\*(C'\fR has been run successfully, the table's meta
information are in a state which allowes the table's data accessor methods
will be able to fetch/store row information. Implementation details heavily
depends on the table implementation, whereby the most famous is surely
DBD::File::Table.
.SH "SQL ENGINES"
.IX Header "SQL ENGINES"
DBI::DBD::SqlEngine currently supports two \s-1SQL\s0 engines:
SQL::Statement and
DBI::SQL::Nano::Statement_. DBI::SQL::Nano supports a
\&\fIvery\fR limited subset of \s-1SQL\s0 statements, but it might be faster for some
very simple tasks. SQL::Statement in contrast supports a much larger subset
of \s-1ANSI SQL.\s0
.PP
To use SQL::Statement, you need at least version 1.401 of
SQL::Statement and the environment variable \f(CW\*(C`DBI_SQL_NANO\*(C'\fR must not
be set to a true value.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc DBI::DBD::SqlEngine
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT: CPAN\s0's request tracker
.Sp
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=DBI>
<http://rt.cpan.org/NoAuth/Bugs.html?Dist=SQL\-Statement>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
<http://annocpan.org/dist/DBI>
<http://annocpan.org/dist/SQL\-Statement>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
<http://cpanratings.perl.org/d/DBI>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
<http://search.cpan.org/dist/DBI/>
.SS "Where can I go for more help?"
.IX Subsection "Where can I go for more help?"
For questions about installation or usage, please ask on the
dbi\-dev@perl.org mailing list.
.PP
If you have a bug report, patch or suggestion, please open
a new report ticket on \s-1CPAN,\s0 if there is not already one for
the issue you want to report. Of course, you can mail any of the
module maintainers, but it is less likely to be missed if
it is reported on \s-1RT.\s0
.PP
Report tickets should contain a detailed description of the bug or
enhancement request you want to report and at least an easy way to
verify/reproduce the issue and any supplied fix. Patches are always
welcome, too.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Thanks to Tim Bunce, Martin Evans and H.Merijn Brand for their continued
support while developing DBD::File, \s-1DBD::DBM\s0 and DBD::AnyData.
Their support, hints and feedback helped to design and implement this
module.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module is currently maintained by
.PP
H.Merijn Brand < h.m.brand at xs4all.nl > and
Jens Rehsack  < rehsack at googlemail.com >
.PP
The original authors are Jochen Wiedmann and Jeff Zucker.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
.Vb 3
\& Copyright (C) 2009\-2013 by H.Merijn Brand & Jens Rehsack
\& Copyright (C) 2004\-2009 by Jeff Zucker
\& Copyright (C) 1998\-2004 by Jochen Wiedmann
.Ve
.PP
All rights reserved.
.PP
You may freely distribute and/or modify this module under the terms of
either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License, as
specified in the Perl \s-1README\s0 file.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1DBI\s0, DBD::File, DBD::AnyData and DBD::Sys.
                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::DBD::SqlEngine::Developers.3pm          0100644 0001750 0001750 00000110466 12566241601 026607  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::DBD::SqlEngine::Developers 3"
.TH DBI::DBD::SqlEngine::Developers 3 "2013-05-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::DBD::SqlEngine::Developers \- Developers documentation for DBI::DBD::SqlEngine
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package DBD::myDriver;
\&
\&    use base qw(DBI::DBD::SqlEngine);
\&
\&    sub driver
\&    {
\&        ...
\&        my $drh = $proto\->SUPER::driver($attr);
\&        ...
\&        return $drh\->{class};
\&    }
\&
\&    sub CLONE { ... }
\&
\&    package DBD::myDriver::dr;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::dr);
\&
\&    sub data_sources { ... }
\&    ...
\&
\&    package DBD::myDriver::db;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::db);
\&
\&    sub init_valid_attributes { ... }
\&    sub init_default_attributes { ... }
\&    sub set_versions { ... }
\&    sub validate_STORE_attr { my ($dbh, $attrib, $value) = @_; ... }
\&    sub validate_FETCH_attr { my ($dbh, $attrib) = @_; ... }
\&    sub get_myd_versions { ... }
\&    sub get_avail_tables { ... }
\&
\&    package DBD::myDriver::st;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::st);
\&
\&    sub FETCH { ... }
\&    sub STORE { ... }
\&
\&    package DBD::myDriver::Statement;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::Statement);
\&
\&    sub open_table { ... }
\&
\&    package DBD::myDriver::Table;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::Table);
\&
\&    my %reset_on_modify = (
\&                            myd_abc => "myd_foo",
\&                            myd_mno => "myd_bar",
\&                          );
\&    _\|_PACKAGE_\|_\->register_reset_on_modify( \e%reset_on_modify );
\&    my %compat_map = (
\&                       abc => \*(Aqfoo_abc\*(Aq,
\&                       xyz => \*(Aqfoo_xyz\*(Aq,
\&                     );
\&    _\|_PACKAGE_\|_\->register_compat_map( \e%compat_map );
\&
\&    sub bootstrap_table_meta { ... }
\&    sub init_table_meta { ... }
\&    sub table_meta_attr_changed { ... }
\&    sub open_data { ... }
\&
\&    sub new { ... }
\&
\&    sub fetch_row { ... }
\&    sub push_row { ... }
\&    sub push_names { ... }
\&    sub seek { ... }
\&    sub truncate { ... }
\&    sub drop { ... }
\&
\&    # optimize the SQL engine by add one or more of
\&    sub update_current_row { ... }
\&    # or
\&    sub update_specific_row { ... }
\&    # or
\&    sub update_one_row { ... }
\&    # or
\&    sub insert_new_row { ... }
\&    # or
\&    sub delete_current_row { ... }
\&    # or
\&    sub delete_one_row { ... }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes the interface of DBI::DBD::SqlEngine for \s-1DBD\s0
developers who write DBI::DBD::SqlEngine based \s-1DBI\s0 drivers. It supplements
\&\s-1DBI::DBD\s0 and DBI::DBD::SqlEngine::HowTo, which you should read first.
.SH "CLASSES"
.IX Header "CLASSES"
Each \s-1DBI\s0 driver must provide a package global \f(CW\*(C`driver\*(C'\fR method and
three \s-1DBI\s0 related classes:
.IP "DBI::DBD::SqlEngine::dr" 4
.IX Item "DBI::DBD::SqlEngine::dr"
Driver package, contains the methods \s-1DBI\s0 calls indirectly via \s-1DBI\s0
interface:
.Sp
.Vb 1
\&  DBI\->connect (\*(AqDBI:DBM:\*(Aq, undef, undef, {})
\&
\&  # invokes
\&  package DBD::DBM::dr;
\&  @DBD::DBM::dr::ISA = qw(DBI::DBD::SqlEngine::dr);
\&
\&  sub connect ($$;$$$)
\&  {
\&      ...
\&  }
.Ve
.Sp
Similar for \f(CW\*(C`data_sources ()\*(C'\fR and \f(CW\*(C`disconnect_all()\*(C'\fR.
.Sp
Pure Perl \s-1DBI\s0 drivers derived from DBI::DBD::SqlEngine usually don't need to
override any of the methods provided through the DBD::XXX::dr package.
However if you need additional initialization not fitting in
\&\f(CW\*(C`init_valid_attributes()\*(C'\fR and \f(CW\*(C`init_default_attributes()\*(C'\fR of you're ::db
class, the connect method might be the final place to be modified.
.IP "DBI::DBD::SqlEngine::db" 4
.IX Item "DBI::DBD::SqlEngine::db"
Contains the methods which are called through \s-1DBI\s0 database handles
(\f(CW$dbh\fR). e.g.,
.Sp
.Vb 3
\&  $sth = $dbh\->prepare ("select * from foo");
\&  # returns the f_encoding setting for table foo
\&  $dbh\->csv_get_meta ("foo", "f_encoding");
.Ve
.Sp
DBI::DBD::SqlEngine provides the typical methods required here. Developers who
write \s-1DBI\s0 drivers based on DBI::DBD::SqlEngine need to override the methods
\&\f(CW\*(C`set_versions\*(C'\fR and \f(CW\*(C`init_valid_attributes\*(C'\fR.
.IP "DBI::DBD::SqlEngine::TieMeta;" 4
.IX Item "DBI::DBD::SqlEngine::TieMeta;"
Provides the tie-magic for \f(CW\*(C`$dbh\->{$drv_pfx . "_meta"}\*(C'\fR. Routes
\&\f(CW\*(C`STORE\*(C'\fR through \f(CW\*(C`$drv\->set_sql_engine_meta()\*(C'\fR and \f(CW\*(C`FETCH\*(C'\fR through
\&\f(CW\*(C`$drv\->get_sql_engine_meta()\*(C'\fR. \f(CW\*(C`DELETE\*(C'\fR is not supported, you have
to execute a \f(CW\*(C`DROP TABLE\*(C'\fR statement, where applicable.
.IP "DBI::DBD::SqlEngine::TieTables;" 4
.IX Item "DBI::DBD::SqlEngine::TieTables;"
Provides the tie-magic for tables in \f(CW\*(C`$dbh\->{$drv_pfx . "_meta"}\*(C'\fR.
Routes \f(CW\*(C`STORE\*(C'\fR though \f(CW\*(C`$tblClass\->set_table_meta_attr()\*(C'\fR and \f(CW\*(C`FETCH\*(C'\fR
though \f(CW\*(C`$tblClass\->get_table_meta_attr()\*(C'\fR. \f(CW\*(C`DELETE\*(C'\fR removes an
attribute from the \fImeta object\fR retrieved by
\&\f(CW\*(C`$tblClass\->get_table_meta()\*(C'\fR.
.IP "DBI::DBD::SqlEngine::st" 4
.IX Item "DBI::DBD::SqlEngine::st"
Contains the methods to deal with prepared statement handles. e.g.,
.Sp
.Vb 1
\&  $sth\->execute () or die $sth\->errstr;
.Ve
.IP "DBI::DBD::SqlEngine::TableSource;" 4
.IX Item "DBI::DBD::SqlEngine::TableSource;"
Base class for 3rd party table sources:
.Sp
.Vb 1
\&  $dbh\->{sql_table_source} = "DBD::Foo::TableSource";
.Ve
.IP "DBI::DBD::SqlEngine::DataSource;" 4
.IX Item "DBI::DBD::SqlEngine::DataSource;"
Base class for 3rd party data sources:
.Sp
.Vb 1
\&  $dbh\->{sql_data_source} = "DBD::Foo::DataSource";
.Ve
.IP "DBI::DBD::SqlEngine::Statement;" 4
.IX Item "DBI::DBD::SqlEngine::Statement;"
Base class for derived drivers statement engine. Implements \f(CW\*(C`open_table\*(C'\fR.
.IP "DBI::DBD::SqlEngine::Table;" 4
.IX Item "DBI::DBD::SqlEngine::Table;"
Contains tailoring between \s-1SQL\s0 engine's requirements and
\&\f(CW\*(C`DBI::DBD::SqlEngine\*(C'\fR magic for finding the right tables and storage.
Builds bridges between \f(CW\*(C`sql_meta\*(C'\fR handling of \f(CW\*(C`DBI::DBD::SqlEngine::db\*(C'\fR,
table initialization for \s-1SQL\s0 engines and \fImeta object\fR's attribute
management for derived drivers.
.SS "DBI::DBD::SqlEngine"
.IX Subsection "DBI::DBD::SqlEngine"
This is the main package containing the routines to initialize
DBI::DBD::SqlEngine based \s-1DBI\s0 drivers. Primarily the
\&\f(CW\*(C`DBI::DBD::SqlEngine::driver\*(C'\fR method is invoked, either directly
from \s-1DBI\s0 when the driver is initialized or from the derived class.
.PP
.Vb 1
\&  package DBD::DBM;
\&
\&  use base qw( DBI::DBD::SqlEngine );
\&
\&  sub driver
\&  {
\&      my ( $class, $attr ) = @_;
\&      ...
\&      my $drh = $class\->SUPER::driver( $attr );
\&      ...
\&      return $drh;
\&  }
.Ve
.PP
It is not necessary to implement your own driver method as long as
additional initialization (e.g. installing more private driver
methods) is not required.  You do not need to call \f(CW\*(C`setup_driver\*(C'\fR
as DBI::DBD::SqlEngine takes care of it.
.SS "DBI::DBD::SqlEngine::dr"
.IX Subsection "DBI::DBD::SqlEngine::dr"
The driver package contains the methods \s-1DBI\s0 calls indirectly via the \s-1DBI\s0
interface (see \*(L"\s-1DBI\s0 Class Methods\*(R" in \s-1DBI\s0).
.PP
DBI::DBD::SqlEngine based \s-1DBI\s0 drivers usually do not need to implement anything here,
it is enough to do the basic initialization:
.PP
.Vb 1
\&  package DBD:XXX::dr;
\&
\&  @DBD::XXX::dr::ISA = qw (DBI::DBD::SqlEngine::dr);
\&  $DBD::XXX::dr::imp_data_size     = 0;
\&  $DBD::XXX::dr::data_sources_attr = undef;
\&  $DBD::XXX::ATTRIBUTION = "DBD::XXX $DBD::XXX::VERSION by Hans Mustermann";
.Ve
.PP
\fIMethods provided by \f(CI\*(C`DBI::DBD::SqlEngine::dr\*(C'\fI:\fR
.IX Subsection "Methods provided by DBI::DBD::SqlEngine::dr:"
.IP "connect" 4
.IX Item "connect"
Supervises the driver bootstrap when calling
.Sp
.Vb 1
\&  DBI\->connect( "dbi:Foo", , , { ... } );
.Ve
.Sp
First it instantiates a new driver using \f(CW\*(C`DBI::_new_dbh\*(C'\fR. After that,
initial bootstrap of the newly instantiated driver is done by
.Sp
.Vb 1
\&  $dbh\->func( 0, "init_default_attributes" );
.Ve
.Sp
The first argument (\f(CW0\fR) signals that this is the very first call to
\&\f(CW\*(C`init_default_attributes\*(C'\fR. Modern drivers understand that and do early
stage setup here after calling
.Sp
.Vb 2
\&  package DBD::Foo::db;
\&  our @DBD::Foo::db::ISA = qw(DBI::DBD::SqlEngine::db);
\&  
\&  sub init_default_attributes
\&  {
\&    my ($dbh, $phase) = @_;
\&    $dbh\->SUPER::init_default_attributes($phase);
\&    ...; # own setup code, maybe separated by phases
\&  }
.Ve
.Sp
When the \f(CW$phase\fR argument is passed down until
\&\f(CW\*(C`DBI::DBD::SqlEngine::db::init_default_attributes\*(C'\fR, \f(CW\*(C`connect()\*(C'\fR recognizes
a \fImodern\fR driver and initializes the attributes from \fI\s-1DSN\s0\fR and \fI\f(CI$attr\fI\fR
arguments passed via \f(CW\*(C`DBI\->connect( $dsn, $user, $pass, \e%attr )\*(C'\fR.
.Sp
At the end of the attribute initialization after \fIphase 0\fR, \f(CW\*(C`connect()\*(C'\fR
invoked \f(CW\*(C`init_default_attributes\*(C'\fR again for \fIphase 1\fR:
.Sp
.Vb 1
\&  $dbh\->func( 1, "init_default_attributes" );
.Ve
.IP "data_sources" 4
.IX Item "data_sources"
Returns a list of \fI\s-1DSN\s0\fR's using the \f(CW\*(C`data_sources\*(C'\fR method of the
class specified in \f(CW\*(C`$dbh\->{sql_table_source}\*(C'\fR or via \f(CW\*(C`\e%attr\*(C'\fR:
.Sp
.Vb 2
\&  @ary = DBI\->data_sources($driver);
\&  @ary = DBI\->data_sources($driver, \e%attr);
.Ve
.IP "disconnect_all" 4
.IX Item "disconnect_all"
\&\f(CW\*(C`DBI::DBD::SqlEngine\*(C'\fR doesn't have an overall driver cache, so nothing
happens here at all.
.SS "DBI::DBD::SqlEngine::db"
.IX Subsection "DBI::DBD::SqlEngine::db"
This package defines the database methods, which are called via the \s-1DBI\s0
database handle \f(CW$dbh\fR.
.PP
\fIMethods provided by \f(CI\*(C`DBI::DBD::SqlEngine::db\*(C'\fI:\fR
.IX Subsection "Methods provided by DBI::DBD::SqlEngine::db:"
.IP "ping" 4
.IX Item "ping"
Simply returns the content of the \f(CW\*(C`Active\*(C'\fR attribute. Override
when your driver needs more complicated actions here.
.IP "prepare" 4
.IX Item "prepare"
Prepares a new \s-1SQL\s0 statement to execute. Returns a statement handle,
\&\f(CW$sth\fR \- instance of the DBD:XXX::st. It is neither required nor
recommended to override this method.
.IP "validate_FETCH_attr" 4
.IX Item "validate_FETCH_attr"
Called by \f(CW\*(C`FETCH\*(C'\fR to allow inherited drivers do their own attribute
name validation. Calling convention is similar to \f(CW\*(C`FETCH\*(C'\fR and the
return value is the approved attribute name.
.Sp
.Vb 1
\&    return $validated_attribute_name;
.Ve
.Sp
In case of validation fails (e.g. accessing private attribute or similar),
\&\f(CW\*(C`validate_FETCH_attr\*(C'\fR is permitted to throw an exception.
.IP "\s-1FETCH\s0" 4
.IX Item "FETCH"
Fetches an attribute of a \s-1DBI\s0 database object. Private handle attributes
must have a prefix (this is mandatory). If a requested attribute is
detected as a private attribute without a valid prefix, the driver prefix
(written as \f(CW$drv_prefix\fR) is added.
.Sp
The driver prefix is extracted from the attribute name and verified against
\&\f(CW\*(C`$dbh\->{ $drv_prefix . "valid_attrs" }\*(C'\fR (when it exists). If the
requested attribute value is not listed as a valid attribute, this method
croaks. If the attribute is valid and readonly (listed in \f(CW\*(C`$dbh\->{
$drv_prefix . "readonly_attrs" }\*(C'\fR when it exists), a real copy of the
attribute value is returned. So it's not possible to modify
\&\f(CW\*(C`f_valid_attrs\*(C'\fR from outside of DBI::DBD::SqlEngine::db or a derived class.
.IP "validate_STORE_attr" 4
.IX Item "validate_STORE_attr"
Called by \f(CW\*(C`STORE\*(C'\fR to allow inherited drivers do their own attribute
name validation. Calling convention is similar to \f(CW\*(C`STORE\*(C'\fR and the
return value is the approved attribute name followed by the approved
new value.
.Sp
.Vb 1
\&    return ($validated_attribute_name, $validated_attribute_value);
.Ve
.Sp
In case of validation fails (e.g. accessing private attribute or similar),
\&\f(CW\*(C`validate_STORE_attr\*(C'\fR is permitted to throw an exception
(\f(CW\*(C`DBI::DBD::SqlEngine::db::validate_STORE_attr\*(C'\fR throws an exception when
someone tries to assign value other than \f(CW\*(C`SQL_IC_UPPER .. SQL_IC_MIXED\*(C'\fR
to \f(CW\*(C`$dbh\->{sql_identifier_case}\*(C'\fR or
\&\f(CW\*(C`$dbh\->{sql_quoted_identifier_case}\*(C'\fR).
.IP "\s-1STORE\s0" 4
.IX Item "STORE"
Stores a database private attribute. Private handle attributes must have a
prefix (this is mandatory). If a requested attribute is detected as a private
attribute without a valid prefix, the driver prefix (written as
\&\f(CW$drv_prefix\fR) is added. If the database handle has an attribute
\&\f(CW\*(C`${drv_prefix}_valid_attrs\*(C'\fR \- for attribute names which are not listed in
that hash, this method croaks. If the database handle has an attribute
\&\f(CW\*(C`${drv_prefix}_readonly_attrs\*(C'\fR, only attributes which are not listed there
can be stored (once they are initialized). Trying to overwrite such an
immutable attribute forces this method to croak.
.Sp
An example of a valid attributes list can be found in
\&\f(CW\*(C`DBI::DBD::SqlEngine::db::init_valid_attributes\*(C'\fR.
.IP "set_versions" 4
.IX Item "set_versions"
This method sets the attributes \f(CW\*(C`f_version\*(C'\fR, \f(CW\*(C`sql_nano_version\*(C'\fR,
\&\f(CW\*(C`sql_statement_version\*(C'\fR and (if not prohibited by a restrictive
\&\f(CW\*(C`${prefix}_valid_attrs\*(C'\fR) \f(CW\*(C`${prefix}_version\*(C'\fR.
.Sp
This method is called at the end of the \f(CW\*(C`connect ()\*(C'\fR phase.
.Sp
When overriding this method, do not forget to invoke the superior one.
.IP "init_valid_attributes" 4
.IX Item "init_valid_attributes"
This method is called after the database handle is instantiated as the
first attribute initialization.
.Sp
\&\f(CW\*(C`DBI::DBD::SqlEngine::db::init_valid_attributes\*(C'\fR initializes the
attributes \f(CW\*(C`sql_valid_attrs\*(C'\fR and \f(CW\*(C`sql_readonly_attrs\*(C'\fR.
.Sp
When overriding this method, do not forget to invoke the superior one,
preferably before doing anything else.
.IP "init_default_attributes" 4
.IX Item "init_default_attributes"
This method is called after the database handle is instantiated to
initialize the default attributes. It expects one argument: \f(CW$phase\fR.
If \f(CW$phase\fR is not given, \f(CW\*(C`connect\*(C'\fR of \f(CW\*(C`DBI::DBD::SqlEngine::dr\*(C'\fR
expects this is an old-fashioned driver which isn't capable of multi-phased
initialization.
.Sp
\&\f(CW\*(C`DBI::DBD::SqlEngine::db::init_default_attributes\*(C'\fR initializes the
attributes \f(CW\*(C`sql_identifier_case\*(C'\fR, \f(CW\*(C`sql_quoted_identifier_case\*(C'\fR,
\&\f(CW\*(C`sql_handler\*(C'\fR, \f(CW\*(C`sql_init_order\*(C'\fR, \f(CW\*(C`sql_meta\*(C'\fR, \f(CW\*(C`sql_engine_version\*(C'\fR,
\&\f(CW\*(C`sql_nano_version\*(C'\fR and \f(CW\*(C`sql_statement_version\*(C'\fR when SQL::Statement
is available.
.Sp
It sets \f(CW\*(C`sql_init_order\*(C'\fR to the given \f(CW$phase\fR.
.Sp
When the derived implementor class provides the attribute to validate
attributes (e.g. \f(CW\*(C`$dbh\->{dbm_valid_attrs} = {...};\*(C'\fR) or the attribute
containing the immutable attributes (e.g.  \f(CW\*(C`$dbh\->{dbm_readonly_attrs}
= {...};\*(C'\fR), the attributes \f(CW\*(C`drv_valid_attrs\*(C'\fR, \f(CW\*(C`drv_readonly_attrs\*(C'\fR and
\&\f(CW\*(C`drv_version\*(C'\fR are added (when available) to the list of valid and
immutable attributes (where \f(CW\*(C`drv_\*(C'\fR is interpreted as the driver prefix).
.IP "get_versions" 4
.IX Item "get_versions"
This method is called by the code injected into the instantiated driver to
provide the user callable driver method \f(CW\*(C`${prefix}versions\*(C'\fR (e.g.
\&\f(CW\*(C`dbm_versions\*(C'\fR, \f(CW\*(C`csv_versions\*(C'\fR, ...).
.Sp
The DBI::DBD::SqlEngine implementation returns all version information known by
DBI::DBD::SqlEngine (e.g. \s-1DBI\s0 version, Perl version, DBI::DBD::SqlEngine version and
the \s-1SQL\s0 handler version).
.Sp
\&\f(CW\*(C`get_versions\*(C'\fR takes the \f(CW$dbh\fR as the first argument and optionally a
second argument containing a table name. The second argument is not
evaluated in \f(CW\*(C`DBI::DBD::SqlEngine::db::get_versions\*(C'\fR itself \- but
might be in the future.
.Sp
If the derived implementor class provides a method named
\&\f(CW\*(C`get_${drv_prefix}versions\*(C'\fR, this is invoked and the return value of
it is associated to the derived driver name:
.Sp
.Vb 4
\&    if (my $dgv = $dbh\->{ImplementorClass}\->can ("get_" . $drv_prefix . "versions") {
\&        (my $derived_driver = $dbh\->{ImplementorClass}) =~ s/::db$//;
\&        $versions{$derived_driver} = &$dgv ($dbh, $table);
\&    }
.Ve
.Sp
Override it to add more version information about your module, (e.g.
some kind of parser version in case of \s-1DBD::CSV, ...\s0), if one line is not
enough room to provide all relevant information.
.IP "sql_parser_object" 4
.IX Item "sql_parser_object"
Returns a SQL::Parser instance, when \f(CW\*(C`sql_handler\*(C'\fR is set to
\&\*(L"SQL::Statement\*(R". The parser instance is stored in \f(CW\*(C`sql_parser_object\*(C'\fR.
.Sp
It is not recommended to override this method.
.IP "disconnect" 4
.IX Item "disconnect"
Disconnects from a database. All local table information is discarded and
the \f(CW\*(C`Active\*(C'\fR attribute is set to 0.
.IP "type_info_all" 4
.IX Item "type_info_all"
Returns information about all the types supported by DBI::DBD::SqlEngine.
.IP "table_info" 4
.IX Item "table_info"
Returns a statement handle which is prepared to deliver information about
all known tables.
.IP "list_tables" 4
.IX Item "list_tables"
Returns a list of all known table names.
.IP "quote" 4
.IX Item "quote"
Quotes a string for use in \s-1SQL\s0 statements.
.IP "commit" 4
.IX Item "commit"
Warns about a useless call (if warnings enabled) and returns.
DBI::DBD::SqlEngine is typically a driver which commits every action
instantly when executed.
.IP "rollback" 4
.IX Item "rollback"
Warns about a useless call (if warnings enabled) and returns.
DBI::DBD::SqlEngine is typically a driver which commits every action
instantly when executed.
.PP
\fIAttributes used by \f(CI\*(C`DBI::DBD::SqlEngine::db\*(C'\fI:\fR
.IX Subsection "Attributes used by DBI::DBD::SqlEngine::db:"
.PP
This section describes attributes which are important to developers of \s-1DBI\s0
Database Drivers derived from \f(CW\*(C`DBI::DBD::SqlEngine\*(C'\fR.
.IP "sql_init_order" 4
.IX Item "sql_init_order"
This attribute contains a hash with priorities as key and an array
containing the \f(CW$dbh\fR attributes to be initialized during before/after
other attributes.
.Sp
\&\f(CW\*(C`DBI::DBD::SqlEngine\*(C'\fR initializes following attributes:
.Sp
.Vb 4
\&  $dbh\->{sql_init_order} = {
\&       0 => [qw( Profile RaiseError PrintError AutoCommit )],
\&      90 => [ "sql_meta", $dbh\->{$drv_pfx_meta} ? $dbh\->{$drv_pfx_meta} : () ]
\&  }
.Ve
.Sp
The default priority of not listed attribute keys is \f(CW50\fR. It is well
known that a lot of attributes needed to be set before some table settings
are initialized. For example, for \s-1DBD::DBM\s0, when using
.Sp
.Vb 11
\&  my $dbh = DBI\->connect( "dbi:DBM:", undef, undef, {
\&      f_dir => "/path/to/dbm/databases",
\&      dbm_type => "BerkeleyDB",
\&      dbm_mldbm => "JSON", # use MLDBM::Serializer::JSON
\&      dbm_tables => {
\&          quick => {
\&              dbm_type => "GDBM_File",
\&              dbm_MLDBM => "FreezeThaw"
\&          }
\&      }
\&  });
.Ve
.Sp
This defines a known table \f(CW\*(C`quick\*(C'\fR which uses the GDBM_File backend and
FreezeThaw as serializer instead of the overall default BerkeleyDB and
\&\s-1JSON\s0. \fBBut\fR all files containing the table data have to be searched in
\&\f(CW\*(C`$dbh\->{f_dir}\*(C'\fR, which requires \f(CW\*(C`$dbh\->{f_dir}\*(C'\fR must be initialized
before \f(CW\*(C`$dbh\->{sql_meta}\->{quick}\*(C'\fR is initialized by
\&\f(CW\*(C`bootstrap_table_meta\*(C'\fR method of \*(L"DBI::DBD::SqlEngine::Table\*(R" to get
\&\f(CW\*(C`$dbh\->{sql_meta}\->{quick}\->{f_dir}\*(C'\fR being initialized properly.
.IP "sql_init_phase" 4
.IX Item "sql_init_phase"
This attribute is only set during the initialization steps of the \s-1DBI\s0
Database Driver. It contains the value of the currently run initialization
phase. Currently supported phases are \fIphase 0\fR and \fIphase 1\fR. This
attribute is set in \f(CW\*(C`init_default_attributes\*(C'\fR and removed in \f(CW\*(C`init_done\*(C'\fR.
.IP "sql_engine_in_gofer" 4
.IX Item "sql_engine_in_gofer"
This value has a true value in case of this driver is operated via
DBD::Gofer. The impact of being operated via Gofer is a read-only
driver (not read-only databases!), so you cannot modify any attributes
later \- neither any table settings. \fBBut\fR you won't get an error in
cases you modify table attributes, so please carefully watch
\&\f(CW\*(C`sql_engine_in_gofer\*(C'\fR.
.IP "sql_table_source" 4
.IX Item "sql_table_source"
Names a class which is responsible for delivering \fIdata sources\fR and
\&\fIavailable tables\fR (Database Driver related). \fIdata sources\fR here
refers to \*(L"data_sources\*(R" in \s-1DBI\s0, not \f(CW\*(C`sql_data_source\*(C'\fR.
.Sp
See \*(L"DBI::DBD::SqlEngine::TableSource\*(R" for details.
.IP "sql_data_source" 4
.IX Item "sql_data_source"
Name a class which is responsible for handling table resources open
and completing table names requested via \s-1SQL\s0 statements.
.Sp
See \*(L"DBI::DBD::SqlEngine::DataSource\*(R" for details.
.IP "sql_dialect" 4
.IX Item "sql_dialect"
Controls the dialect understood by SQL::Parser. Possible values (delivery
state of SQL::Statement):
.Sp
.Vb 3
\&  * ANSI
\&  * CSV
\&  * AnyData
.Ve
.Sp
Defaults to \*(L"\s-1CSV\*(R". \s0 Because an SQL::Parser is instantiated only once and
SQL::Parser doesn't allow to modify the dialect once instantiated,
it's strongly recommended to set this flag before any statement is
executed (best place is connect attribute hash).
.SS "DBI::DBD::SqlEngine::st"
.IX Subsection "DBI::DBD::SqlEngine::st"
Contains the methods to deal with prepared statement handles:
.IP "bind_param" 4
.IX Item "bind_param"
Common routine to bind placeholders to a statement for execution. It
is dangerous to override this method without detailed knowledge about
the DBI::DBD::SqlEngine internal storage structure.
.IP "execute" 4
.IX Item "execute"
Executes a previously prepared statement (with placeholders, if any).
.IP "finish" 4
.IX Item "finish"
Finishes a statement handle, discards all buffered results. The prepared
statement is not discarded so the statement can be executed again.
.IP "fetch" 4
.IX Item "fetch"
Fetches the next row from the result-set. This method may be rewritten
in a later version and if it's overridden in a derived class, the
derived implementation should not rely on the storage details.
.IP "fetchrow_arrayref" 4
.IX Item "fetchrow_arrayref"
Alias for \f(CW\*(C`fetch\*(C'\fR.
.IP "\s-1FETCH\s0" 4
.IX Item "FETCH"
Fetches statement handle attributes. Supported attributes (for full overview
see \*(L"Statement Handle Attributes\*(R" in \s-1DBI\s0) are \f(CW\*(C`NAME\*(C'\fR, \f(CW\*(C`TYPE\*(C'\fR, \f(CW\*(C`PRECISION\*(C'\fR
and \f(CW\*(C`NULLABLE\*(C'\fR. Each column is returned as \f(CW\*(C`NULLABLE\*(C'\fR which might be wrong
depending on the derived backend storage.  If the statement handle has
private attributes, they can be fetched using this method, too. \fBNote\fR that
statement attributes are not associated with any table used in this statement.
.Sp
This method usually requires extending in a derived implementation.
See \s-1DBD::CSV\s0 or \s-1DBD::DBM\s0 for some example.
.IP "\s-1STORE\s0" 4
.IX Item "STORE"
Allows storing of statement private attributes. No special handling is
currently implemented here.
.IP "rows" 4
.IX Item "rows"
Returns the number of rows affected by the last execute. This method might
return \f(CW\*(C`undef\*(C'\fR.
.SS "DBI::DBD::SqlEngine::TableSource"
.IX Subsection "DBI::DBD::SqlEngine::TableSource"
Provides data sources and table information on database driver and database
handle level.
.PP
.Vb 1
\&  package DBI::DBD::SqlEngine::TableSource;
\&
\&  sub data_sources ($;$)
\&  {
\&    my ( $class, $drh, $attrs ) = @_;
\&    ...
\&  }
\&
\&  sub avail_tables
\&  {
\&    my ( $class, $drh ) = @_;
\&    ...
\&  }
.Ve
.PP
The \f(CW\*(C`data_sources\*(C'\fR method is called when the user invokes any of the
following:
.PP
.Vb 2
\&  @ary = DBI\->data_sources($driver);
\&  @ary = DBI\->data_sources($driver, \e%attr);
\&  
\&  @ary = $dbh\->data_sources();
\&  @ary = $dbh\->data_sources(\e%attr);
.Ve
.PP
The \f(CW\*(C`avail_tables\*(C'\fR method is called when the user invokes any of the
following:
.PP
.Vb 1
\&  @names = $dbh\->tables( $catalog, $schema, $table, $type );
\&  
\&  $sth = $dbh\->table_info( $catalog, $schema, $table, $type );
\&  $sth = $dbh\->table_info( $catalog, $schema, $table, $type, \e%attr );
\&
\&  $dbh\->func( "list_tables" );
.Ve
.PP
Every time where an \f(CW\*(C`\e%attr\*(C'\fR argument can be specified, this \f(CW\*(C`\e%attr\*(C'\fR
object's \f(CW\*(C`sql_table_source\*(C'\fR attribute is preferred over the \f(CW$dbh\fR
attribute or the driver default.
.SS "DBI::DBD::SqlEngine::DataSource"
.IX Subsection "DBI::DBD::SqlEngine::DataSource"
Provides base functionality for dealing with tables. It is primarily
designed for allowing transparent access to files on disk or already
opened (file\-)streams (e.g. for \s-1DBD::CSV\s0).
.PP
Derived classes shall be restricted to similar functionality, too (e.g.
opening streams from an archive, transparently compress/uncompress
log files before parsing them,
.PP
.Vb 1
\&  package DBI::DBD::SqlEngine::DataSource;
\&
\&  sub complete_table_name ($$;$)
\&  {
\&    my ( $self, $meta, $table, $respect_case ) = @_;
\&    ...
\&  }
.Ve
.PP
The method \f(CW\*(C`complete_table_name\*(C'\fR is called when first setting up the
\&\fImeta information\fR for a table:
.PP
.Vb 1
\&  "SELECT user.id, user.name, user.shell FROM user WHERE ..."
.Ve
.PP
results in opening the table \f(CW\*(C`user\*(C'\fR. First step of the table open
process is completing the name. Let's imagine you're having a \s-1DBD::CSV\s0
handle with following settings:
.PP
.Vb 3
\&  $dbh\->{sql_identifier_case} = SQL_IC_LOWER;
\&  $dbh\->{f_ext} = \*(Aq.lst\*(Aq;
\&  $dbh\->{f_dir} = \*(Aq/data/web/adrmgr\*(Aq;
.Ve
.PP
Those settings will result in looking for files matching
\&\f(CW\*(C`[Uu][Ss][Ee][Rr](\e.lst)?$\*(C'\fR in \f(CW\*(C`/data/web/adrmgr/\*(C'\fR. The scanning of the
directory \f(CW\*(C`/data/web/adrmgr/\*(C'\fR and the pattern match check will be done
in \f(CW\*(C`DBD::File::DataSource::File\*(C'\fR by the \f(CW\*(C`complete_table_name\*(C'\fR method.
.PP
If you intend to provide other sources of data streams than files, in
addition to provide an appropriate \f(CW\*(C`complete_table_name\*(C'\fR method, a method
to open the resource is required:
.PP
.Vb 1
\&  package DBI::DBD::SqlEngine::DataSource;
\&
\&  sub open_data ($)
\&  {
\&    my ( $self, $meta, $attrs, $flags ) = @_;
\&    ...
\&  }
.Ve
.PP
After the method \f(CW\*(C`open_data\*(C'\fR has been run successfully, the table's meta
information are in a state which allows the table's data accessor methods
will be able to fetch/store row information. Implementation details heavily
depends on the table implementation, whereby the most famous is surely
DBD::File::Table.
.SS "DBI::DBD::SqlEngine::Statement"
.IX Subsection "DBI::DBD::SqlEngine::Statement"
Derives from DBI::SQL::Nano::Statement for unified naming when deriving
new drivers. No additional feature is provided from here.
.SS "DBI::DBD::SqlEngine::Table"
.IX Subsection "DBI::DBD::SqlEngine::Table"
Derives from DBI::SQL::Nano::Table for unified naming when deriving
new drivers.
.PP
You should consult the documentation of \f(CW\*(C`SQL::Eval::Table\*(C'\fR (see
SQL::Eval) to get more information about the abstract methods of the
table's base class you have to override and a description of the table
meta information expected by the \s-1SQL\s0 engines.
.IP "bootstrap_table_meta" 4
.IX Item "bootstrap_table_meta"
Initializes a table meta structure. Can be safely overridden in a
derived class, as long as the \f(CW\*(C`SUPER\*(C'\fR method is called at the end
of the overridden method.
.Sp
It copies the following attributes from the database into the table meta data
\&\f(CW\*(C`$dbh\->{ReadOnly}\*(C'\fR into \f(CW\*(C`$meta\->{readonly}\*(C'\fR, \f(CW\*(C`sql_identifier_case\*(C'\fR
and \f(CW\*(C`sql_data_source\*(C'\fR and makes them sticky to the table.
.Sp
This method should be called before you attempt to map between file
name and table name to ensure the correct directory, extension etc. are
used.
.IP "init_table_meta" 4
.IX Item "init_table_meta"
Initializes more attributes of the table meta data \- usually more
expensive ones (e.g. those which require class instantiations) \- when
the file name and the table name could mapped.
.IP "get_table_meta" 4
.IX Item "get_table_meta"
Returns the table meta data. If there are none for the required table,
a new one is initialized. When after bootstrapping a new \fItable_meta\fR
and completing the table name a
mapping can be established between an existing \fItable_meta\fR and the
new bootstrapped one, the already existing is used and a mapping
shortcut between the recent used table name and the already known
table name is hold in \f(CW\*(C`$dbh\->{sql_meta_map}\*(C'\fR.  When it fails,
nothing is returned. On success, the name of the table and the meta data
structure is returned.
.IP "get_table_meta_attr" 4
.IX Item "get_table_meta_attr"
Returns a single attribute from the table meta data. If the attribute
name appears in \f(CW%compat_map\fR, the attribute name is updated from
there.
.IP "set_table_meta_attr" 4
.IX Item "set_table_meta_attr"
Sets a single attribute in the table meta data. If the attribute
name appears in \f(CW%compat_map\fR, the attribute name is updated from
there.
.IP "table_meta_attr_changed" 4
.IX Item "table_meta_attr_changed"
Called when an attribute of the meta data is modified.
.Sp
If the modified attribute requires to reset a calculated attribute, the
calculated attribute is reset (deleted from meta data structure) and
the \fIinitialized\fR flag is removed, too. The decision is made based on
\&\f(CW%register_reset_on_modify\fR.
.IP "register_reset_on_modify" 4
.IX Item "register_reset_on_modify"
Allows \f(CW\*(C`set_table_meta_attr\*(C'\fR to reset meta attributes when special
attributes are modified. For DBD::File, modifying one of \f(CW\*(C`f_file\*(C'\fR, \f(CW\*(C`f_dir\*(C'\fR,
\&\f(CW\*(C`f_ext\*(C'\fR or \f(CW\*(C`f_lockfile\*(C'\fR will reset \f(CW\*(C`f_fqfn\*(C'\fR. \s-1DBD::DBM\s0 extends the
list for \f(CW\*(C`dbm_type\*(C'\fR and \f(CW\*(C`dbm_mldbm\*(C'\fR to reset the value of \f(CW\*(C`dbm_tietype\*(C'\fR.
.Sp
If your \s-1DBD\s0 has calculated values in the meta data area, then call
\&\f(CW\*(C`register_reset_on_modify\*(C'\fR:
.Sp
.Vb 2
\&    my %reset_on_modify = ( "xxx_foo" => "xxx_bar" );
\&    _\|_PACKAGE_\|_\->register_reset_on_modify( \e%reset_on_modify );
.Ve
.IP "register_compat_map" 4
.IX Item "register_compat_map"
Allows \f(CW\*(C`get_table_meta_attr\*(C'\fR and \f(CW\*(C`set_table_meta_attr\*(C'\fR to update the
attribute name to the current favored one:
.Sp
.Vb 3
\&    # from DBD::DBM
\&    my %compat_map = ( "dbm_ext" => "f_ext" );
\&    _\|_PACKAGE_\|_\->register_compat_map( \e%compat_map );
.Ve
.IP "open_data" 4
.IX Item "open_data"
Called to open the table's data storage. This is silently forwarded
to \f(CW\*(C`$meta\->{sql_data_source}\->open_data()\*(C'\fR.
.Sp
After this is done, a derived class might add more steps in an overridden
\&\f(CW\*(C`open_file\*(C'\fR method.
.IP "new" 4
.IX Item "new"
Instantiates the table. This is done in 3 steps:
.Sp
.Vb 3
\& 1. get the table meta data
\& 2. open the data file
\& 3. bless the table data structure using inherited constructor new
.Ve
.Sp
It is not recommended to override the constructor of the table class.
Find a reasonable place to add you extensions in one of the above four
methods.
.SH "AUTHOR"
.IX Header "AUTHOR"
The module DBI::DBD::SqlEngine is currently maintained by
.PP
H.Merijn Brand < h.m.brand at xs4all.nl > and
Jens Rehsack  < rehsack at googlemail.com >
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2010 by H.Merijn Brand & Jens Rehsack
.PP
All rights reserved.
.PP
You may freely distribute and/or modify this module under the terms of
either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License, as
specified in the Perl \s-1README\s0 file.
                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::DBD::SqlEngine::Developers5.16.3pm      0100644 0001750 0001750 00000045213 12566241600 027115  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::DBD::SqlEngine::Developers 3"
.TH DBI::DBD::SqlEngine::Developers 3 "2010-08-30" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::DBD::SqlEngine::Developers \- Developers documentation for DBI::DBD::SqlEngine
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package DBD::myDriver;
\&
\&    use base qw(DBI::DBD::SqlEngine);
\&
\&    sub driver
\&    {
\&        ...
\&        my $drh = $proto\->SUPER::driver($attr);
\&        ...
\&        return $drh\->{class};
\&    }
\&
\&    sub CLONE { ... }
\&
\&    package DBD::myDriver::dr;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::dr);
\&
\&    sub data_sources { ... }
\&    ...
\&
\&    package DBD::myDriver::db;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::db);
\&
\&    sub init_valid_attributes { ... }
\&    sub init_default_attributes { ... }
\&    sub set_versions { ... }
\&    sub validate_STORE_attr { my ($dbh, $attrib, $value) = @_; ... }
\&    sub validate_FETCH_attr { my ($dbh, $attrib) = @_; ... }
\&    sub get_myd_versions { ... }
\&    sub get_avail_tables { ... }
\&
\&    package DBD::myDriver::st;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::st);
\&
\&    sub FETCH { ... }
\&    sub STORE { ... }
\&
\&    package DBD::myDriver::Statement;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::Statement);
\&
\&    sub open_table { ... }
\&
\&    package DBD::myDriver::Table;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::Table);
\&
\&    sub new { ... }
\&
\&    sub fetch_row { ... }
\&    sub push_row { ... }
\&    sub push_names { ... }
\&    sub seek { ... }
\&    sub truncate { ... }
\&    sub drop { ... }
\&
\&    # optimize the SQL engine by add one or more of
\&    sub update_current_row { ... }
\&    # or
\&    sub update_specific_row { ... }
\&    # or
\&    sub update_one_row { ... }
\&    # or
\&    sub insert_new_row { ... }
\&    # or
\&    sub delete_current_row { ... }
\&    # or
\&    sub delete_one_row { ... }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes the interface of DBI::DBD::SqlEngine for \s-1DBD\s0
developers who write DBI::DBD::SqlEngine based \s-1DBI\s0 drivers. It supplements
\&\s-1DBI::DBD\s0 and DBI::DBD::SqlEngine::HowTo, which you should read first.
.SH "CLASSES"
.IX Header "CLASSES"
Each \s-1DBI\s0 driver must provide a package global \f(CW\*(C`driver\*(C'\fR method and
three \s-1DBI\s0 related classes:
.IP "DBI::DBD::SqlEngine::dr" 4
.IX Item "DBI::DBD::SqlEngine::dr"
Driver package, contains the methods \s-1DBI\s0 calls indirectly via \s-1DBI\s0
interface:
.Sp
.Vb 1
\&  DBI\->connect (\*(AqDBI:DBM:\*(Aq, undef, undef, {})
\&
\&  # invokes
\&  package DBD::DBM::dr;
\&  @DBD::DBM::dr::ISA = qw(DBI::DBD::SqlEngine::dr);
\&
\&  sub connect ($$;$$$)
\&  {
\&      ...
\&  }
.Ve
.Sp
Similar for \f(CW\*(C`data_sources ()\*(C'\fR and \f(CW\*(C`disconnect_all()\*(C'\fR.
.Sp
Pure Perl \s-1DBI\s0 drivers derived from DBI::DBD::SqlEngine do not usually need to
override any of the methods provided through the DBD::XXX::dr package
however if you need additional initialization in the connect method
you may need to.
.IP "DBI::DBD::SqlEngine::db" 4
.IX Item "DBI::DBD::SqlEngine::db"
Contains the methods which are called through \s-1DBI\s0 database handles
(\f(CW$dbh\fR). e.g.,
.Sp
.Vb 3
\&  $sth = $dbh\->prepare ("select * from foo");
\&  # returns the f_encoding setting for table foo
\&  $dbh\->csv_get_meta ("foo", "f_encoding");
.Ve
.Sp
DBI::DBD::SqlEngine provides the typical methods required here. Developers who
write \s-1DBI\s0 drivers based on DBI::DBD::SqlEngine need to override the methods
\&\f(CW\*(C`set_versions\*(C'\fR and \f(CW\*(C`init_valid_attributes\*(C'\fR.
.IP "DBI::DBD::SqlEngine::st" 4
.IX Item "DBI::DBD::SqlEngine::st"
Contains the methods to deal with prepared statement handles. e.g.,
.Sp
.Vb 1
\&  $sth\->execute () or die $sth\->errstr;
.Ve
.SS "DBI::DBD::SqlEngine"
.IX Subsection "DBI::DBD::SqlEngine"
This is the main package containing the routines to initialize
DBI::DBD::SqlEngine based \s-1DBI\s0 drivers. Primarily the
\&\f(CW\*(C`DBI::DBD::SqlEngine::driver\*(C'\fR method is invoked, either directly
from \s-1DBI\s0 when the driver is initialized or from the derived class.
.PP
.Vb 1
\&  package DBD::DBM;
\&
\&  use base qw( DBI::DBD::SqlEngine );
\&
\&  sub driver
\&  {
\&      my ( $class, $attr ) = @_;
\&      ...
\&      my $drh = $class\->SUPER::driver( $attr );
\&      ...
\&      return $drh;
\&  }
.Ve
.PP
It is not necessary to implement your own driver method as long as
additional initialization (e.g. installing more private driver
methods) is not required.  You do not need to call \f(CW\*(C`setup_driver\*(C'\fR
as DBI::DBD::SqlEngine takes care of it.
.SS "DBI::DBD::SqlEngine::dr"
.IX Subsection "DBI::DBD::SqlEngine::dr"
The driver package contains the methods \s-1DBI\s0 calls indirectly via the \s-1DBI\s0
interface (see \*(L"\s-1DBI\s0 Class Methods\*(R" in \s-1DBI\s0).
.PP
DBI::DBD::SqlEngine based \s-1DBI\s0 drivers usually do not need to implement anything here,
it is enough to do the basic initialization:
.PP
.Vb 1
\&  package DBD:XXX::dr;
\&
\&  @DBD::XXX::dr::ISA = qw (DBI::DBD::SqlEngine::dr);
\&  $DBD::XXX::dr::imp_data_size     = 0;
\&  $DBD::XXX::dr::data_sources_attr = undef;
\&  $DBD::XXX::ATTRIBUTION = "DBD::XXX $DBD::XXX::VERSION by Hans Mustermann";
.Ve
.SS "DBI::DBD::SqlEngine::db"
.IX Subsection "DBI::DBD::SqlEngine::db"
This package defines the database methods, which are called via the \s-1DBI\s0
database handle \f(CW$dbh\fR.
.PP
Methods provided by DBI::DBD::SqlEngine:
.IP "ping" 4
.IX Item "ping"
Simply returns the content of the \f(CW\*(C`Active\*(C'\fR attribute. Override
when your driver needs more complicated actions here.
.IP "prepare" 4
.IX Item "prepare"
Prepares a new \s-1SQL\s0 statement to execute. Returns a statement handle,
\&\f(CW$sth\fR \- instance of the DBD:XXX::st. It is neither required nor
recommended to override this method.
.IP "\s-1FETCH\s0" 4
.IX Item "FETCH"
Fetches an attribute of a \s-1DBI\s0 database object. Private handle attributes
must have a prefix (this is mandatory). If a requested attribute is
detected as a private attribute without a valid prefix, the driver prefix
(written as \f(CW$drv_prefix\fR) is added.
.Sp
The driver prefix is extracted from the attribute name and verified against
\&\f(CW\*(C`$dbh\->{ $drv_prefix . "valid_attrs" }\*(C'\fR (when it exists). If the
requested attribute value is not listed as a valid attribute, this method
croaks. If the attribute is valid and readonly (listed in \f(CW\*(C`$dbh\->{
$drv_prefix . "readonly_attrs" }\*(C'\fR when it exists), a real copy of the
attribute value is returned. So it's not possible to modify
\&\f(CW\*(C`f_valid_attrs\*(C'\fR from outside of DBI::DBD::SqlEngine::db or a derived class.
.IP "\s-1STORE\s0" 4
.IX Item "STORE"
Stores a database private attribute. Private handle attributes must have a
prefix (this is mandatory). If a requested attribute is detected as a private
attribute without a valid prefix, the driver prefix (written as
\&\f(CW$drv_prefix\fR) is added. If the database handle has an attribute
\&\f(CW\*(C`${drv_prefix}_valid_attrs\*(C'\fR \- for attribute names which are not listed in
that hash, this method croaks. If the database handle has an attribute
\&\f(CW\*(C`${drv_prefix}_readonly_attrs\*(C'\fR, only attributes which are not listed there
can be stored (once they are initialized). Trying to overwrite such an
immutable attribute forces this method to croak.
.Sp
An example of a valid attributes list can be found in
\&\f(CW\*(C`DBI::DBD::SqlEngine::db::init_valid_attributes\*(C'\fR.
.IP "set_versions" 4
.IX Item "set_versions"
This method sets the attributes \f(CW\*(C`f_version\*(C'\fR, \f(CW\*(C`sql_nano_version\*(C'\fR,
\&\f(CW\*(C`sql_statement_version\*(C'\fR and (if not prohibited by a restrictive
\&\f(CW\*(C`${prefix}_valid_attrs\*(C'\fR) \f(CW\*(C`${prefix}_version\*(C'\fR.
.Sp
This method is called at the end of the \f(CW\*(C`connect ()\*(C'\fR phase.
.Sp
When overriding this method, do not forget to invoke the superior one.
.IP "init_valid_attributes" 4
.IX Item "init_valid_attributes"
This method is called after the database handle is instantiated as the
first attribute initialization.
.Sp
\&\f(CW\*(C`DBI::DBD::SqlEngine::db::init_valid_attributes\*(C'\fR initializes the
attributes \f(CW\*(C`sql_valid_attrs\*(C'\fR and \f(CW\*(C`sql_readonly_attrs\*(C'\fR.
.Sp
When overriding this method, do not forget to invoke the superior one,
preferably before doing anything else.
.IP "init_default_attributes" 4
.IX Item "init_default_attributes"
This method is called after the database handle is instantiated to
initialize the default attributes.
.Sp
\&\f(CW\*(C`DBI::DBD::SqlEngine::db::init_default_attributes\*(C'\fR initializes the
attributes \f(CW\*(C`sql_identifier_case\*(C'\fR, \f(CW\*(C`sql_quoted_identifier_case\*(C'\fR,
\&\f(CW\*(C`sql_handler\*(C'\fR, \f(CW\*(C`sql_engine_version\*(C'\fR, \f(CW\*(C`sql_nano_version\*(C'\fR and
\&\f(CW\*(C`sql_statement_version\*(C'\fR when SQL::Statement is available.
.Sp
When the derived implementor class provides the attribute to validate
attributes (e.g. \f(CW\*(C`$dbh\->{dbm_valid_attrs} = {...};\*(C'\fR) or the attribute
containing the immutable attributes (e.g.  \f(CW\*(C`$dbh\->{dbm_readonly_attrs}
= {...};\*(C'\fR), the attributes \f(CW\*(C`drv_valid_attrs\*(C'\fR, \f(CW\*(C`drv_readonly_attrs\*(C'\fR and
\&\f(CW\*(C`drv_version\*(C'\fR are added (when available) to the list of valid and
immutable attributes (where \f(CW\*(C`drv_\*(C'\fR is interpreted as the driver prefix).
.IP "get_versions" 4
.IX Item "get_versions"
This method is called by the code injected into the instantiated driver to
provide the user callable driver method \f(CW\*(C`${prefix}versions\*(C'\fR (e.g.
\&\f(CW\*(C`dbm_versions\*(C'\fR, \f(CW\*(C`csv_versions\*(C'\fR, ...).
.Sp
The DBI::DBD::SqlEngine implementation returns all version information known by
DBI::DBD::SqlEngine (e.g. \s-1DBI\s0 version, Perl version, DBI::DBD::SqlEngine version and
the \s-1SQL\s0 handler version).
.Sp
\&\f(CW\*(C`get_versions\*(C'\fR takes the \f(CW$dbh\fR as the first argument and optionally a
second argument containing a table name. The second argument is not
evaluated in \f(CW\*(C`DBI::DBD::SqlEngine::db::get_versions\*(C'\fR itself \- but
might be in the future.
.Sp
If the derived implementor class provides a method named
\&\f(CW\*(C`get_${drv_prefix}versions\*(C'\fR, this is invoked and the return value of
it is associated to the derived driver name:
.Sp
.Vb 4
\&    if (my $dgv = $dbh\->{ImplementorClass}\->can ("get_" . $drv_prefix . "versions") {
\&        (my $derived_driver = $dbh\->{ImplementorClass}) =~ s/::db$//;
\&        $versions{$derived_driver} = &$dgv ($dbh, $table);
\&    }
.Ve
.Sp
Override it to add more version information about your module, (e.g.
some kind of parser version in case of \s-1DBD::CSV\s0, ...), if one line is not
enough room to provide all relevant information.
.IP "sql_parser_object" 4
.IX Item "sql_parser_object"
Returns a SQL::Parser instance, when \f(CW\*(C`sql_handler\*(C'\fR is set to
\&\*(L"SQL::Statement\*(R". The parser instance is stored in \f(CW\*(C`sql_parser_object\*(C'\fR.
.Sp
It is not recommended to override this method.
.IP "disconnect" 4
.IX Item "disconnect"
Disconnects from a database. All local table information is discarded and
the \f(CW\*(C`Active\*(C'\fR attribute is set to 0.
.IP "type_info_all" 4
.IX Item "type_info_all"
Returns information about all the types supported by DBI::DBD::SqlEngine.
.IP "table_info" 4
.IX Item "table_info"
Returns a statement handle which is prepared to deliver information about
all known tables.
.IP "list_tables" 4
.IX Item "list_tables"
Returns a list of all known table names.
.IP "quote" 4
.IX Item "quote"
Quotes a string for use in \s-1SQL\s0 statements.
.IP "commit" 4
.IX Item "commit"
Warns about a useless call (if warnings enabled) and returns.
DBI::DBD::SqlEngine is typically a driver which commits every action instantly when
executed.
.IP "rollback" 4
.IX Item "rollback"
Warns about a useless call (if warnings enabled) and returns.
DBI::DBD::SqlEngine is typically a driver which commits every action instantly when
executed.
.SS "DBI::DBD::SqlEngine::st"
.IX Subsection "DBI::DBD::SqlEngine::st"
Contains the methods to deal with prepared statement handles:
.IP "bind_param" 4
.IX Item "bind_param"
Common routine to bind placeholders to a statement for execution. It
is dangerous to override this method without detailed knowledge about
the DBI::DBD::SqlEngine internal storage structure.
.IP "execute" 4
.IX Item "execute"
Executes a previously prepared statement (with placeholders, if any).
.IP "finish" 4
.IX Item "finish"
Finishes a statement handle, discards all buffered results. The prepared
statement is not discarded so the statement can be executed again.
.IP "fetch" 4
.IX Item "fetch"
Fetches the next row from the result-set. This method may be rewritten
in a later version and if it's overridden in a derived class, the
derived implementation should not rely on the storage details.
.IP "fetchrow_arrayref" 4
.IX Item "fetchrow_arrayref"
Alias for \f(CW\*(C`fetch\*(C'\fR.
.IP "\s-1FETCH\s0" 4
.IX Item "FETCH"
Fetches statement handle attributes. Supported attributes (for full overview
see \*(L"Statement Handle Attributes\*(R" in \s-1DBI\s0) are \f(CW\*(C`NAME\*(C'\fR, \f(CW\*(C`TYPE\*(C'\fR, \f(CW\*(C`PRECISION\*(C'\fR
and \f(CW\*(C`NULLABLE\*(C'\fR. Each column is returned as \f(CW\*(C`NULLABLE\*(C'\fR which might be wrong
depending on the derived backend storage.  If the statement handle has
private attributes, they can be fetched using this method, too. \fBNote\fR that
statement attributes are not associated with any table used in this statement.
.Sp
This method usually requires extending in a derived implementation.
See \s-1DBD::CSV\s0 or \s-1DBD::DBM\s0 for some example.
.IP "\s-1STORE\s0" 4
.IX Item "STORE"
Allows storing of statement private attributes. No special handling is
currently implemented here.
.IP "rows" 4
.IX Item "rows"
Returns the number of rows affected by the last execute. This method might
return \f(CW\*(C`undef\*(C'\fR.
.SS "DBI::DBD::SqlEngine::Statement"
.IX Subsection "DBI::DBD::SqlEngine::Statement"
Derives from DBI::SQL::Nano::Statement for unified naming when deriving
new drivers. No additional feature is provided from here.
.SS "DBI::DBD::SqlEngine::Table"
.IX Subsection "DBI::DBD::SqlEngine::Table"
Derives from DBI::SQL::Nano::Table for unified naming when deriving
new drivers. No additional feature is provided from here.
.PP
You should consult the documentation of \f(CW\*(C`SQL::Eval::Table\*(C'\fR (see
SQL::Eval) to get more information about the abstract methods of the
table's base class you have to override and a description of the table
meta information expected by the \s-1SQL\s0 engines.
.SH "AUTHOR"
.IX Header "AUTHOR"
The module DBI::DBD::SqlEngine is currently maintained by
.PP
H.Merijn Brand < h.m.brand at xs4all.nl > and
Jens Rehsack  < rehsack at googlemail.com >
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2010 by H.Merijn Brand & Jens Rehsack
.PP
All rights reserved.
.PP
You may freely distribute and/or modify this module under the terms of
either the \s-1GNU\s0 General Public License (\s-1GPL\s0) or the Artistic License, as
specified in the Perl \s-1README\s0 file.
                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/DBI::DBD::SqlEngine::Developers5.18.3pm      0100644 0001750 0001750 00000110466 12566241601 027123  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBI::DBD::SqlEngine::Developers 3"
.TH DBI::DBD::SqlEngine::Developers 3 "2013-05-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBI::DBD::SqlEngine::Developers \- Developers documentation for DBI::DBD::SqlEngine
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package DBD::myDriver;
\&
\&    use base qw(DBI::DBD::SqlEngine);
\&
\&    sub driver
\&    {
\&        ...
\&        my $drh = $proto\->SUPER::driver($attr);
\&        ...
\&        return $drh\->{class};
\&    }
\&
\&    sub CLONE { ... }
\&
\&    package DBD::myDriver::dr;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::dr);
\&
\&    sub data_sources { ... }
\&    ...
\&
\&    package DBD::myDriver::db;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::db);
\&
\&    sub init_valid_attributes { ... }
\&    sub init_default_attributes { ... }
\&    sub set_versions { ... }
\&    sub validate_STORE_attr { my ($dbh, $attrib, $value) = @_; ... }
\&    sub validate_FETCH_attr { my ($dbh, $attrib) = @_; ... }
\&    sub get_myd_versions { ... }
\&    sub get_avail_tables { ... }
\&
\&    package DBD::myDriver::st;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::st);
\&
\&    sub FETCH { ... }
\&    sub STORE { ... }
\&
\&    package DBD::myDriver::Statement;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::Statement);
\&
\&    sub open_table { ... }
\&
\&    package DBD::myDriver::Table;
\&
\&    @ISA = qw(DBI::DBD::SqlEngine::Table);
\&
\&    my %reset_on_modify = (
\&                            myd_abc => "myd_foo",
\&                            myd_mno => "myd_bar",
\&                          );
\&    _\|_PACKAGE_\|_\->register_reset_on_modify( \e%reset_on_modify );
\&    my %compat_map = (
\&                       abc => \*(Aqfoo_abc\*(Aq,
\&                       xyz => \*(Aqfoo_xyz\*(Aq,
\&                     );
\&    _\|_PACKAGE_\|_\->register_compat_map( \e%compat_map );
\&
\&    sub bootstrap_table_meta { ... }
\&    sub init_table_meta { ... }
\&    sub table_meta_attr_changed { ... }
\&    sub open_data { ... }
\&
\&    sub new { ... }
\&
\&    sub fetch_row { ... }
\&    sub push_row { ... }
\&    sub push_names { ... }
\&    sub seek { ... }
\&    sub truncate { ... }
\&    sub drop { ... }
\&
\&    # optimize the SQL engine by add one or more of
\&    sub update_current_row { ... }
\&    # or
\&    sub update_specific_row { ... }
\&    # or
\&    sub update_one_row { ... }
\&    # or
\&    sub insert_new_row { ... }
\&    # or
\&    sub delete_current_row { ... }
\&    # or
\&    sub delete_one_row { ... }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes the interface of DBI::DBD::SqlEngine for \s-1DBD\s0
developers who write DBI::DBD::SqlEngine based \s-1DBI\s0 drivers. It supplements
\&\s-1DBI::DBD\s0 and DBI::DBD::SqlEngine::HowTo, which you should read first.
.SH "CLASSES"
.IX Header "CLASSES"
Each \s-1DBI\s0 driver must provide a package global \f(CW\*(C`driver\*(C'\fR method and
three \s-1DBI\s0 related classes:
.IP "DBI::DBD::SqlEngine::dr" 4
.IX Item "DBI::DBD::SqlEngine::dr"
Driver package, contains the methods \s-1DBI\s0 calls indirectly via \s-1DBI\s0
interface:
.Sp
.Vb 1
\&  DBI\->connect (\*(AqDBI:DBM:\*(Aq, undef, undef, {})
\&
\&  # invokes
\&  package DBD::DBM::dr;
\&  @DBD::DBM::dr::ISA = qw(DBI::DBD::SqlEngine::dr);
\&
\&  sub connect ($$;$$$)
\&  {
\&      ...
\&  }
.Ve
.Sp
Similar for \f(CW\*(C`data_sources ()\*(C'\fR and \f(CW\*(C`disconnect_all()\*(C'\fR.
.Sp
Pure Perl \s-1DBI\s0 drivers derived from DBI::DBD::SqlEngine usually don't need to
override any of the methods provided through the DBD::XXX::dr package.
However if you need additional initialization not fitting in
\&\f(CW\*(C`init_valid_attributes()\*(C'\fR and \f(CW\*(C`init_default_attributes()\*(C'\fR of you're ::db
class, the connect method might be the final place to be modified.
.IP "DBI::DBD::SqlEngine::db" 4
.IX Item "DBI::DBD::SqlEngine::db"
Contains the methods which are called through \s-1DBI\s0 database handles
(\f(CW$dbh\fR). e.g.,
.Sp
.Vb 3
\&  $sth = $dbh\->prepare ("select * from foo");
\&  # returns the f_encoding setting for table foo
\&  $dbh\->csv_get_meta ("foo", "f_encoding");
.Ve
.Sp
DBI::DBD::SqlEngine provides the typical methods required here. Developers who
write \s-1DBI\s0 drivers based on DBI::DBD::SqlEngine need to override the methods
\&\f(CW\*(C`set_versions\*(C'\fR and \f(CW\*(C`init_valid_attributes\*(C'\fR.
.IP "DBI::DBD::SqlEngine::TieMeta;" 4
.IX Item "DBI::DBD::SqlEngine::TieMeta;"
Provides the tie-magic for \f(CW\*(C`$dbh\->{$drv_pfx . "_meta"}\*(C'\fR. Routes
\&\f(CW\*(C`STORE\*(C'\fR through \f(CW\*(C`$drv\->set_sql_engine_meta()\*(C'\fR and \f(CW\*(C`FETCH\*(C'\fR through
\&\f(CW\*(C`$drv\->get_sql_engine_meta()\*(C'\fR. \f(CW\*(C`DELETE\*(C'\fR is not supported, you have
to execute a \f(CW\*(C`DROP TABLE\*(C'\fR statement, where applicable.
.IP "DBI::DBD::SqlEngine::TieTables;" 4
.IX Item "DBI::DBD::SqlEngine::TieTables;"
Provides the tie-magic for tables in \f(CW\*(C`$dbh\->{$drv_pfx . "_meta"}\*(C'\fR.
Routes \f(CW\*(C`STORE\*(C'\fR though \f(CW\*(C`$tblClass\->set_table_meta_attr()\*(C'\fR and \f(CW\*(C`FETCH\*(C'\fR
though \f(CW\*(C`$tblClass\->get_table_meta_attr()\*(C'\fR. \f(CW\*(C`DELETE\*(C'\fR removes an
attribute from the \fImeta object\fR retrieved by
\&\f(CW\*(C`$tblClass\->get_table_meta()\*(C'\fR.
.IP "DBI::DBD::SqlEngine::st" 4
.IX Item "DBI::DBD::SqlEngine::st"
Contains the methods to deal with prepared statement handles. e.g.,
.Sp
.Vb 1
\&  $sth\->execute () or die $sth\->errstr;
.Ve
.IP "DBI::DBD::SqlEngine::TableSource;" 4
.IX Item "DBI::DBD::SqlEngine::TableSource;"
Base class for 3rd party table sources:
.Sp
.Vb 1
\&  $dbh\->{sql_table_source} = "DBD::Foo::TableSource";
.Ve
.IP "DBI::DBD::SqlEngine::DataSource;" 4
.IX Item "DBI::DBD::SqlEngine::DataSource;"
Base class for 3rd party data sources:
.Sp
.Vb 1
\&  $dbh\->{sql_data_source} = "DBD::Foo::DataSource";
.Ve
.IP "DBI::DBD::SqlEngine::Statement;" 4
.IX Item "DBI::DBD::SqlEngine::Statement;"
Base class for derived drivers statement engine. Implements \f(CW\*(C`open_table\*(C'\fR.
.IP "DBI::DBD::SqlEngine::Table;" 4
.IX Item "DBI::DBD::SqlEngine::Table;"
Contains tailoring between \s-1SQL\s0 engine's requirements and
\&\f(CW\*(C`DBI::DBD::SqlEngine\*(C'\fR magic for finding the right tables and storage.
Builds bridges between \f(CW\*(C`sql_meta\*(C'\fR handling of \f(CW\*(C`DBI::DBD::SqlEngine::db\*(C'\fR,
table initialization for \s-1SQL\s0 engines and \fImeta object\fR's attribute
management for derived drivers.
.SS "DBI::DBD::SqlEngine"
.IX Subsection "DBI::DBD::SqlEngine"
This is the main package containing the routines to initialize
DBI::DBD::SqlEngine based \s-1DBI\s0 drivers. Primarily the
\&\f(CW\*(C`DBI::DBD::SqlEngine::driver\*(C'\fR method is invoked, either directly
from \s-1DBI\s0 when the driver is initialized or from the derived class.
.PP
.Vb 1
\&  package DBD::DBM;
\&
\&  use base qw( DBI::DBD::SqlEngine );
\&
\&  sub driver
\&  {
\&      my ( $class, $attr ) = @_;
\&      ...
\&      my $drh = $class\->SUPER::driver( $attr );
\&      ...
\&      return $drh;
\&  }
.Ve
.PP
It is not necessary to implement your own driver method as long as
additional initialization (e.g. installing more private driver
methods) is not required.  You do not need to call \f(CW\*(C`setup_driver\*(C'\fR
as DBI::DBD::SqlEngine takes care of it.
.SS "DBI::DBD::SqlEngine::dr"
.IX Subsection "DBI::DBD::SqlEngine::dr"
The driver package contains the methods \s-1DBI\s0 calls indirectly via the \s-1DBI\s0
interface (see \*(L"\s-1DBI\s0 Class Methods\*(R" in \s-1DBI\s0).
.PP
DBI::DBD::SqlEngine based \s-1DBI\s0 drivers usually do not need to implement anything here,
it is enough to do the basic initialization:
.PP
.Vb 1
\&  package DBD:XXX::dr;
\&
\&  @DBD::XXX::dr::ISA = qw (DBI::DBD::SqlEngine::dr);
\&  $DBD::XXX::dr::imp_data_size     = 0;
\&  $DBD::XXX::dr::data_sources_attr = undef;
\&  $DBD::XXX::ATTRIBUTION = "DBD::XXX $DBD::XXX::VERSION by Hans Mustermann";
.Ve
.PP
\fIMethods provided by \f(CI\*(C`DBI::DBD::SqlEngine::dr\*(C'\fI:\fR
.IX Subsection "Methods provided by DBI::DBD::SqlEngine::dr:"
.IP "connect" 4
.IX Item "connect"
Supervises the driver bootstrap when calling
.Sp
.Vb 1
\&  DBI\->connect( "dbi:Foo", , , { ... } );
.Ve
.Sp
First it instantiates a new driver using \f(CW\*(C`DBI::_new_dbh\*(C'\fR. After that,
initial bootstrap of the newly instantiated driver is done by
.Sp
.Vb 1
\&  $dbh\->func( 0, "init_default_attributes" );
.Ve
.Sp
The first argument (\f(CW0\fR) signals that this is the very first call to
\&\f(CW\*(C`init_default_attributes\*(C'\fR. Modern drivers understand that and do early
stage setup here after calling
.Sp
.Vb 2
\&  package DBD::Foo::db;
\&  our @DBD::Foo::db::ISA = qw(DBI::DBD::SqlEngine::db);
\&  
\&  sub init_default_attributes
\&  {
\&    my ($dbh, $phase) = @_;
\&    $dbh\->SUPER::init_default_attributes($phase);
\&    ...; # own setup code, maybe separated by phases
\&  }
.Ve
.Sp
When the \f(CW$phase\fR argument is passed down until
\&\f(CW\*(C`DBI::DBD::SqlEngine::db::init_default_attributes\*(C'\fR, \f(CW\*(C`connect()\*(C'\fR recognizes
a \fImodern\fR driver and initializes the attributes from \fI\s-1DSN\s0\fR and \fI\f(CI$attr\fI\fR
arguments passed via \f(CW\*(C`DBI\->connect( $dsn, $user, $pass, \e%attr )\*(C'\fR.
.Sp
At the end of the attribute initialization after \fIphase 0\fR, \f(CW\*(C`connect()\*(C'\fR
invoked \f(CW\*(C`init_default_attributes\*(C'\fR again for \fIphase 1\fR:
.Sp
.Vb 1
\&  $dbh\->func( 1, "init_default_attributes" );
.Ve
.IP "data_sources" 4
.IX Item "data_sources"
Returns a list of \fI\s-1DSN\s0\fR's using the \f(CW\*(C`data_sources\*(C'\fR method of the
class specified in \f(CW\*(C`$dbh\->{sql_table_source}\*(C'\fR or via \f(CW\*(C`\e%attr\*(C'\fR:
.Sp
.Vb 2
\&  @ary = DBI\->data_sources($driver);
\&  @ary = DBI\->data_sources($driver, \e%attr);
.Ve
.IP "disconnect_all" 4
.IX Item "disconnect_all"
\&\f(CW\*(C`DBI::DBD::SqlEngine\*(C'\fR doesn't have an overall driver cache, so nothing
happens here at all.
.SS "DBI::DBD::SqlEngine::db"
.IX Subsection "DBI::DBD::SqlEngine::db"
This package defines the database methods, which are called via the \s-1DBI\s0
database handle \f(CW$dbh\fR.
.PP
\fIMethods provided by \f(CI\*(C`DBI::DBD::SqlEngine::db\*(C'\fI:\fR
.IX Subsection "Methods provided by DBI::DBD::SqlEngine::db:"
.IP "ping" 4
.IX Item "ping"
Simply returns the content of the \f(CW\*(C`Active\*(C'\fR attribute. Override
when your driver needs more complicated actions here.
.IP "prepare" 4
.IX Item "prepare"
Prepares a new \s-1SQL\s0 statement to execute. Returns a statement handle,
\&\f(CW$sth\fR \- instance of the DBD:XXX::st. It is neither required nor
recommended to override this method.
.IP "validate_FETCH_attr" 4
.IX Item "validate_FETCH_attr"
Called by \f(CW\*(C`FETCH\*(C'\fR to allow inherited drivers do their own attribute
name validation. Calling convention is similar to \f(CW\*(C`FETCH\*(C'\fR and the
return value is the approved attribute name.
.Sp
.Vb 1
\&    return $validated_attribute_name;
.Ve
.Sp
In case of validation fails (e.g. accessing private attribute or similar),
\&\f(CW\*(C`validate_FETCH_attr\*(C'\fR is permitted to throw an exception.
.IP "\s-1FETCH\s0" 4
.IX Item "FETCH"
Fetches an attribute of a \s-1DBI\s0 database object. Private handle attributes
must have a prefix (this is mandatory). If a requested attribute is
detected as a private attribute without a valid prefix, the driver prefix
(written as \f(CW$drv_prefix\fR) is added.
.Sp
The driver prefix is extracted from the attribute name and verified against
\&\f(CW\*(C`$dbh\->{ $drv_prefix . "valid_attrs" }\*(C'\fR (when it exists). If the
requested attribute value is not listed as a valid attribute, this method
croaks. If the attribute is valid and readonly (listed in \f(CW\*(C`$dbh\->{
$drv_prefix . "readonly_attrs" }\*(C'\fR when it exists), a real copy of the
attribute value is returned. So it's not possible to modify
\&\f(CW\*(C`f_valid_attrs\*(C'\fR from outside of DBI::DBD::SqlEngine::db or a derived class.
.IP "validate_STORE_attr" 4
.IX Item "validate_STORE_attr"
Called by \f(CW\*(C`STORE\*(C'\fR to allow inherited drivers do their own attribute
name validation. Calling convention is similar to \f(CW\*(C`STORE\*(C'\fR and the
return value is the approved attribute name followed by the approved
new value.
.Sp
.Vb 1
\&    return ($validated_attribute_name, $validated_attribute_value);
.Ve
.Sp
In case of validation fails (e.g. accessing private attribute or similar),
\&\f(CW\*(C`validate_STORE_attr\*(C'\fR is permitted to throw an exception
(\f(CW\*(C`DBI::DBD::SqlEngine::db::validate_STORE_attr\*(C'\fR throws an exception when
someone tries to assign value other than \f(CW\*(C`SQL_IC_UPPER .. SQL_IC_MIXED\*(C'\fR
to \f(CW\*(C`$dbh\->{sql_identifier_case}\*(C'\fR or
\&\f(CW\*(C`$dbh\->{sql_quoted_identifier_case}\*(C'\fR).
.IP "\s-1STORE\s0" 4
.IX Item "STORE"
Stores a database private attribute. Private handle attributes must have a
prefix (this is mandatory). If a requested attribute is detected as a private
attribute without a valid prefix, the driver prefix (written as
\&\f(CW$drv_prefix\fR) is added. If the database handle has an attribute
\&\f(CW\*(C`${drv_prefix}_valid_attrs\*(C'\fR \- for attribute names which are not listed in
that hash, this method croaks. If the database handle has an attribute
\&\f(CW\*(C`${drv_prefix}_readonly_attrs\*(C'\fR, only attributes which are not listed there
can be stored (once they are initialized). Trying to overwrite such an
immutable attribute forces this method to croak.
.Sp
An example of a valid attributes list can be found in
\&\f(CW\*(C`DBI::DBD::SqlEngine::db::init_valid_attributes\*(C'\fR.
.IP "set_versions" 4
.IX Item "set_versions"
This method sets the attributes \f(CW\*(C`f_version\*(C'\fR, \f(CW\*(C`sql_nano_version\*(C'\fR,
\&\f(CW\*(C`sql_statement_version\*(C'\fR and (if not prohibited by a restrictive
\&\f(CW\*(C`${prefix}_valid_attrs\*(C'\fR) \f(CW\*(C`${prefix}_version\*(C'\fR.
.Sp
This method is called at the end of the \f(CW\*(C`connect ()\*(C'\fR phase.
.Sp
When overriding this method, do not forget to invoke the superior one.
.IP "init_valid_attributes" 4
.IX Item "init_valid_attributes"
This method is called after the database handle is instantiated as the
first attribute initialization.
.Sp
\&\f(CW\*(C`DBI::DBD::SqlEngine::db::init_valid_attributes\*(C'\fR initializes the
attributes \f(CW\*(C`sql_valid_attrs\*(C'\fR and \f(CW\*(C`sql_readonly_attrs\*(C'\fR.
.Sp
When overriding this method, do not forget to invoke the superior one,
preferably before doing anything else.
.IP "init_default_attributes" 4
.IX Item "init_default_attributes"
This method is called after the database handle is instantiated to
initialize the default attributes. It expects one argument: \f(CW$phase\fR.
If \f(CW$phase\fR is not given, \f(CW\*(C`connect\*(C'\fR of \f(CW\*(C`DBI::DBD::SqlEngine::dr\*(C'\fR
expects this is an old-fashioned driver which isn't capable of multi-phased
initialization.
.Sp
\&\f(CW\*(C`DBI::DBD::SqlEngine::db::init_default_attributes\*(C'\fR initializes the
attributes \f(CW\*(C`sql_identifier_case\*(C'\fR, \f(CW\*(C`sql_quoted_identifier_case\*(C'\fR,
\&\f(CW\*(C`sql_handler\*(C'\fR, \f(CW\*(C`sql_init_order\*(C'\fR, \f(CW\*(C`sql_meta\*(C'\fR, \f(CW\*(C`sql_engine_version\*(C'\fR,
\&\f(CW\*(C`sql_nano_version\*(C'\fR and \f(CW\*(C`sql_statement_version\*(C'\fR when SQL::Statement
is available.
.Sp
It sets \f(CW\*(C`sql_init_order\*(C'\fR to the given \f(CW$phase\fR.
.Sp
When the derived implementor class provides the attribute to validate
attributes (e.g. \f(CW\*(C`$dbh\->{dbm_valid_attrs} = {...};\*(C'\fR) or the attribute
containing the immutable attributes (e.g.  \f(CW\*(C`$dbh\->{dbm_readonly_attrs}
= {...};\*(C'\fR), the attributes \f(CW\*(C`drv_valid_attrs\*(C'\fR, \f(CW\*(C`drv_readonly_attrs\*(C'\fR and
\&\f(CW\*(C`drv_version\*(C'\fR are added (when available) to the list of valid and
immutable attributes (where \f(CW\*(C`drv_\*(C'\fR is interpreted as the driver prefix).
.IP "get_versions" 4
.IX Item "get_versions"
This method is called by the code injected into the instantiated driver to
provide the user callable driver method \f(CW\*(C`${prefix}versions\*(C'\fR (e.g.
\&\f(CW\*(C`dbm_versions\*(C'\fR, \f(CW\*(C`csv_versions\*(C'\fR, ...).
.Sp
The DBI::DBD::SqlEngine implementation returns all version information known by
DBI::DBD::SqlEngine (e.g. \s-1DBI\s0 version, Perl version, DBI::DBD::SqlEngine version and
the \s-1SQL\s0 handler version).
.Sp
\&\f(CW\*(C`get_versions\*(C'\fR takes the \f(CW$dbh\fR as the first argument and optionally a
second argument containing a table name. The second argument is not
evaluated in \f(CW\*(C`DBI::DBD::SqlEngine::db::get_versions\*(C'\fR itself \- but
might be in the future.
.Sp
If the derived implementor class provides a method named
\&\f(CW\*(C`get_${drv_prefix}versions\*(C'\fR, this is invoked and the return value of
it is associated to the derived driver name:
.Sp
.Vb 4
\&    if (my $dgv = $dbh\->{ImplementorClass}\->can ("get_" . $drv_prefix . "versions") {
\&        (my $derived_driver = $dbh\->{ImplementorClass}) =~ s/::db$//;
\&        $versions{$derived_driver} = &$dgv ($dbh, $table);
\&    }
.Ve
.Sp
Override it to add more version information about your module, (e.g.
some kind of parser version in case of \s-1DBD::CSV, ...\s0), if one line is not
enough room to provide all relevant information.
.IP "sql_parser_object" 4
.IX Item "sql_parser_object"
Returns a SQL::Parser instance, when \f(CW\*(C`sql_handler\*(C'\fR is set to
\&\*(L"SQL::Statement\*(R". The parser instance is stored in \f(CW\*(C`sql_parser_object\*(C'\fR.
.Sp
It is not recommended to override this method.
.IP "disconnect" 4
.IX Item "disconnect"
Disconnects from a database. All local table information is discarded and
the \f(CW\*(C`Active\*(C'\fR attribute is set to 0.
.IP "type_info_all" 4
.IX Item "type_info_all"
Returns information about all the types supported by DBI::DBD::SqlEngine.
.IP "table_info" 4
.IX Item "table_info"
Returns a statement handle which is prepared to deliver information about
all known tables.
.IP "list_tables" 4
.IX Item "list_tables"
Returns a list of all known table names.
.IP "quote" 4
.IX Item "quote"
Quotes a string for use in \s-1SQL\s0 statements.
.IP "commit" 4
.IX Item "commit"
Warns about a useless call (if warnings enabled) and returns.
DBI::DBD::SqlEngine is typically a driver which commits every action
instantly when executed.
.IP "rollback" 4
.IX Item "rollback"
Warns about a useless call (if warnings enabled) and returns.
DBI::DBD::SqlEngine is typically a driver which commits every action
instantly when executed.
.PP
\fIAttributes used by \f(CI\*(C`DBI::DBD::SqlEngine::db\*(C'\fI:\fR
.IX Subsection "Attributes used by DBI::DBD::SqlEngine::db:"
.PP
This section describes attributes which are important to developers of \s-1DBI\s0
Database Drivers derived from \f(CW\*(C`DBI::DBD::SqlEngine\*(C'\fR.
.IP "sql_init_order" 4
.IX Item "sql_init_order"
This attribute contains a hash with priorities as key and an array
containi