    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "autodie::hints 3pm"
.TH autodie::hints 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
autodie::hints \- Provide hints about user subroutines to autodie
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    package Your::Module;
\&
\&    our %DOES = ( \*(Aqautodie::hints::provider\*(Aq => 1 );
\&
\&    sub AUTODIE_HINTS {
\&        return {
\&            foo => { scalar => HINTS, list => SOME_HINTS },
\&            bar => { scalar => HINTS, list => MORE_HINTS },
\&        }
\&    }
\&
\&    # Later, in your main program...
\&
\&    use Your::Module qw(foo bar);
\&    use autodie      qw(:default foo bar);
\&
\&    foo();         # succeeds or dies based on scalar hints
\&
\&    # Alternatively, hints can be set on subroutines we\*(Aqve
\&    # imported.
\&
\&    use autodie::hints;
\&    use Some::Module qw(think_positive);
\&
\&    BEGIN {
\&        autodie::hints\->set_hints_for(
\&            \e&think_positive,
\&            {
\&                fail => sub { $_[0] <= 0 }
\&            }
\&        )
\&    }
\&    use autodie qw(think_positive);
\&
\&    think_positive(...);    # Returns positive or dies.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Introduction"
.IX Subsection "Introduction"
The autodie pragma is very smart when it comes to working with
Perl's built-in functions.  The behaviour for these functions are
fixed, and \f(CW\*(C`autodie\*(C'\fR knows exactly how they try to signal failure.
.PP
But what about user-defined subroutines from modules?  If you use
\&\f(CW\*(C`autodie\*(C'\fR on a user-defined subroutine then it assumes the following
behaviour to demonstrate failure:
.IP "\(bu" 4
A false value, in scalar context
.IP "\(bu" 4
An empty list, in list context
.IP "\(bu" 4
A list containing a single undef, in list context
.PP
All other return values (including the list of the single zero, and the
list containing a single empty string) are considered successful.  However,
real-world code isn't always that easy.  Perhaps the code you're working
with returns a string containing the word \*(L"\s-1FAIL\*(R"\s0 upon failure, or a
two element list containing \f(CW\*(C`(undef, "human error message")\*(C'\fR.  To make
autodie work with these sorts of subroutines, we have
the \fIhinting interface\fR.
.PP
The hinting interface allows \fIhints\fR to be provided to \f(CW\*(C`autodie\*(C'\fR
on how it should detect failure from user-defined subroutines.  While
these \fIcan\fR be provided by the end-user of \f(CW\*(C`autodie\*(C'\fR, they are ideally
written into the module itself, or into a helper module or sub-class
of \f(CW\*(C`autodie\*(C'\fR itself.
.SS "What are hints?"
.IX Subsection "What are hints?"
A \fIhint\fR is a subroutine or value that is checked against the
return value of an autodying subroutine.  If the match returns true,
\&\f(CW\*(C`autodie\*(C'\fR considers the subroutine to have failed.
.PP
If the hint provided is a subroutine, then \f(CW\*(C`autodie\*(C'\fR will pass
the complete return value to that subroutine.  If the hint is
any other value, then \f(CW\*(C`autodie\*(C'\fR will smart-match against the
value provided.  In Perl 5.8.x there is no smart-match operator, and as such
only subroutine hints are supported in these versions.
.PP
Hints can be provided for both scalar and list contexts.  Note
that an autodying subroutine will never see a void context, as
\&\f(CW\*(C`autodie\*(C'\fR always needs to capture the return value for examination.
Autodying subroutines called in void context act as if they're called
in a scalar context, but their return value is discarded after it
has been checked.
.SS "Example hints"
.IX Subsection "Example hints"
Hints may consist of scalars, array references, regular expressions and
subroutine references.  You can specify different hints for how
failure should be identified in scalar and list contexts.
.PP
These examples apply for use in the \f(CW\*(C`AUTODIE_HINTS\*(C'\fR subroutine and when
calling \f(CW\*(C`autodie::hints\-\*(C'\fR\fIset_hints_for()\fR>.
.PP
The most common context-specific hints are:
.PP
.Vb 2
\&        # Scalar failures always return undef:
\&            {  scalar => undef  }
\&
\&        # Scalar failures return any false value [default expectation]:
\&            {  scalar => sub { ! $_[0] }  }
\&
\&        # Scalar failures always return zero explicitly:
\&            {  scalar => \*(Aq0\*(Aq  }
\&
\&        # List failures always return an empty list:
\&            {  list => []  }
\&
\&        # List failures return () or (undef) [default expectation]:
\&            {  list => sub { ! @_ || @_ == 1 && !defined $_[0] }  }
\&
\&        # List failures return () or a single false value:
\&            {  list => sub { ! @_ || @_ == 1 && !$_[0] }  }
\&
\&        # List failures return (undef, "some string")
\&            {  list => sub { @_ == 2 && !defined $_[0] }  }
\&
\&        # Unsuccessful foo() returns \*(AqFAIL\*(Aq or \*(Aq_FAIL\*(Aq in scalar context,
\&        #                    returns (\-1) in list context...
\&        autodie::hints\->set_hints_for(
\&            \e&foo,
\&            {
\&                scalar => qr/^ _? FAIL $/xms,
\&                list   => [\-1],
\&            }
\&        );
\&
\&        # Unsuccessful foo() returns 0 in all contexts...
\&        autodie::hints\->set_hints_for(
\&            \e&foo,
\&            {
\&                scalar => 0,
\&                list   => [0],
\&            }
\&        );
.Ve
.PP
This \*(L"in all contexts\*(R" construction is very common, and can be
abbreviated, using the 'fail' key.  This sets both the \f(CW\*(C`scalar\*(C'\fR
and \f(CW\*(C`list\*(C'\fR hints to the same value:
.PP
.Vb 7
\&        # Unsuccessful foo() returns 0 in all contexts...
\&        autodie::hints\->set_hints_for(
\&            \e&foo,
\&            {
\&                fail => sub { @_ == 1 and defined $_[0] and $_[0] == 0 }
\&            }
\&        );
\&
\&        # Unsuccessful think_positive() returns negative number on failure...
\&        autodie::hints\->set_hints_for(
\&            \e&think_positive,
\&            {
\&                fail => sub { $_[0] < 0 }
\&            }
\&        );
\&
\&        # Unsuccessful my_system() returns non\-zero on failure...
\&        autodie::hints\->set_hints_for(
\&            \e&my_system,
\&            {
\&                fail => sub { $_[0] != 0 }
\&            }
\&        );
.Ve
.SH "Manually setting hints from within your program"
.IX Header "Manually setting hints from within your program"
If you are using a module which returns something special on failure, then
you can manually create hints for each of the desired subroutines.  Once
the hints are specified, they are available for all files and modules loaded
thereafter, thus you can move this work into a module and it will still
work.
.PP
.Vb 2
\&        use Some::Module qw(foo bar);
\&        use autodie::hints;
\&
\&        autodie::hints\->set_hints_for(
\&                \e&foo,
\&                {
\&                        scalar => SCALAR_HINT,
\&                        list   => LIST_HINT,
\&                }
\&        );
\&        autodie::hints\->set_hints_for(
\&                \e&bar,
\&                { fail => SOME_HINT, }
\&        );
.Ve
.PP
It is possible to pass either a subroutine reference (recommended) or a fully
qualified subroutine name as the first argument.  This means you can set hints
on modules that \fImight\fR get loaded:
.PP
.Vb 4
\&        use autodie::hints;
\&        autodie::hints\->set_hints_for(
\&                \*(AqSome::Module:bar\*(Aq, { fail => SCALAR_HINT, }
\&        );
.Ve
.PP
This technique is most useful when you have a project that uses a
lot of third-party modules.  You can define all your possible hints
in one-place.  This can even be in a sub-class of autodie.  For
example:
.PP
.Vb 1
\&        package my::autodie;
\&
\&        use parent qw(autodie);
\&        use autodie::hints;
\&
\&        autodie::hints\->set_hints_for(...);
\&
\&        1;
.Ve
.PP
You can now \f(CW\*(C`use my::autodie\*(C'\fR, which will work just like the standard
\&\f(CW\*(C`autodie\*(C'\fR, but is now aware of any hints that you've set.
.SH "Adding hints to your module"
.IX Header "Adding hints to your module"
\&\f(CW\*(C`autodie\*(C'\fR provides a passive interface to allow you to declare hints for
your module.  These hints will be found and used by \f(CW\*(C`autodie\*(C'\fR if it
is loaded, but otherwise have no effect (or dependencies) without autodie.
To set these, your module needs to declare that it \fIdoes\fR the
\&\f(CW\*(C`autodie::hints::provider\*(C'\fR role.  This can be done by writing your
own \f(CW\*(C`DOES\*(C'\fR method, using a system such as \f(CW\*(C`Class::DOES\*(C'\fR to handle
the heavy-lifting for you, or declaring a \f(CW%DOES\fR package variable
with a \f(CW\*(C`autodie::hints::provider\*(C'\fR key and a corresponding true value.
.PP
Note that checking for a \f(CW%DOES\fR hash is an \f(CW\*(C`autodie\*(C'\fR\-only
short-cut.  Other modules do not use this mechanism for checking
roles, although you can use the \f(CW\*(C`Class::DOES\*(C'\fR module from the
\&\s-1CPAN\s0 to allow it.
.PP
In addition, you must define a \f(CW\*(C`AUTODIE_HINTS\*(C'\fR subroutine that returns
a hash-reference containing the hints for your subroutines:
.PP
.Vb 1
\&        package Your::Module;
\&
\&        # We can use the Class::DOES from the CPAN to declare adherence
\&        # to a role.
\&
\&        use Class::DOES \*(Aqautodie::hints::provider\*(Aq => 1;
\&
\&        # Alternatively, we can declare the role in %DOES.  Note that
\&        # this is an autodie specific optimisation, although Class::DOES
\&        # can be used to promote this to a true role declaration.
\&
\&        our %DOES = ( \*(Aqautodie::hints::provider\*(Aq => 1 );
\&
\&        # Finally, we must define the hints themselves.
\&
\&        sub AUTODIE_HINTS {
\&            return {
\&                foo => { scalar => HINTS, list => SOME_HINTS },
\&                bar => { scalar => HINTS, list => MORE_HINTS },
\&                baz => { fail => HINTS },
\&            }
\&        }
.Ve
.PP
This allows your code to set hints without relying on \f(CW\*(C`autodie\*(C'\fR and
\&\f(CW\*(C`autodie::hints\*(C'\fR being loaded, or even installed.  In this way your
code can do the right thing when \f(CW\*(C`autodie\*(C'\fR is installed, but does not
need to depend upon it to function.
.SH "Insisting on hints"
.IX Header "Insisting on hints"
When a user-defined subroutine is wrapped by \f(CW\*(C`autodie\*(C'\fR, it will
use hints if they are available, and otherwise reverts to the
\&\fIdefault behaviour\fR described in the introduction of this document.
This can be problematic if we expect a hint to exist, but (for
whatever reason) it has not been loaded.
.PP
We can ask autodie to \fIinsist\fR that a hint be used by prefixing
an exclamation mark to the start of the subroutine name.  A lone
exclamation mark indicates that \fIall\fR subroutines after it must
have hints declared.
.PP
.Vb 2
\&        # foo() and bar() must have their hints defined
\&        use autodie qw( !foo !bar baz );
\&
\&        # Everything must have hints (recommended).
\&        use autodie qw( ! foo bar baz );
\&
\&        # bar() and baz() must have their hints defined
\&        use autodie qw( foo ! bar baz );
\&
\&        # Enable autodie for all of Perl\*(Aqs supported built\-ins,
\&        # as well as for foo(), bar() and baz().  Everything must
\&        # have hints.
\&        use autodie qw( ! :all foo bar baz );
.Ve
.PP
If hints are not available for the specified subroutines, this will cause a
compile-time error.  Insisting on hints for Perl's built-in functions
(eg, \f(CW\*(C`open\*(C'\fR and \f(CW\*(C`close\*(C'\fR) is always successful.
.PP
Insisting on hints is \fIstrongly\fR recommended.
.SH "Diagnostics"
.IX Header "Diagnostics"
.IP "Attempts to set_hints_for unidentifiable subroutine" 4
.IX Item "Attempts to set_hints_for unidentifiable subroutine"
You've called \f(CW\*(C`autodie::hints\->set_hints_for()\*(C'\fR using a subroutine
reference, but that reference could not be resolved back to a
subroutine name.  It may be an anonymous subroutine (which can't
be made autodying), or may lack a name for other reasons.
.Sp
If you receive this error with a subroutine that has a real name,
then you may have found a bug in autodie.  See \*(L"\s-1BUGS\*(R"\s0 in autodie
for how to report this.
.ie n .IP "fail hints cannot be provided with either scalar or list hints for %s" 4
.el .IP "fail hints cannot be provided with either scalar or list hints for \f(CW%s\fR" 4
.IX Item "fail hints cannot be provided with either scalar or list hints for %s"
When defining hints, you can either supply both \f(CW\*(C`list\*(C'\fR and
\&\f(CW\*(C`scalar\*(C'\fR keywords, \fIor\fR you can provide a single \f(CW\*(C`fail\*(C'\fR keyword.
You can't mix and match them.
.ie n .IP "%s hint missing for %s" 4
.el .IP "\f(CW%s\fR hint missing for \f(CW%s\fR" 4
.IX Item "%s hint missing for %s"
You've provided either a \f(CW\*(C`scalar\*(C'\fR hint without supplying
a \f(CW\*(C`list\*(C'\fR hint, or vice-versa.  You \fImust\fR supply both \f(CW\*(C`scalar\*(C'\fR
and \f(CW\*(C`list\*(C'\fR hints, \fIor\fR a single \f(CW\*(C`fail\*(C'\fR hint.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.IP "\(bu" 4
Dr Damian Conway for suggesting the hinting interface and providing the
example usage.
.IP "\(bu" 4
Jacinta Richardson for translating much of my ideas into this
documentation.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright 2009, Paul Fenwick <pjf@perltraining.com.au>
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software.  You may distribute it under the
same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
autodie, Class::DOES
                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/autouse.3pm                                  0100644 0001750 0001750 00000014406 12566207465 023000  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "autouse 3pm"
.TH autouse 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
autouse \- postpone load of modules until a function is used
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use autouse \*(AqCarp\*(Aq => qw(carp croak);
\&  carp "this carp was predeclared and autoused ";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
If the module \f(CW\*(C`Module\*(C'\fR is already loaded, then the declaration
.PP
.Vb 1
\&  use autouse \*(AqModule\*(Aq => qw(func1 func2($;$));
.Ve
.PP
is equivalent to
.PP
.Vb 1
\&  use Module qw(func1 func2);
.Ve
.PP
if \f(CW\*(C`Module\*(C'\fR defines \fIfunc2()\fR with prototype \f(CW\*(C`($;$)\*(C'\fR, and \fIfunc1()\fR has
no prototypes.  (At least if \f(CW\*(C`Module\*(C'\fR uses \f(CW\*(C`Exporter\*(C'\fR's \f(CW\*(C`import\*(C'\fR,
otherwise it is a fatal error.)
.PP
If the module \f(CW\*(C`Module\*(C'\fR is not loaded yet, then the above declaration
declares functions \fIfunc1()\fR and \fIfunc2()\fR in the current package.  When
these functions are called, they load the package \f(CW\*(C`Module\*(C'\fR if needed,
and substitute themselves with the correct definitions.
.SH "WARNING"
.IX Header "WARNING"
Using \f(CW\*(C`autouse\*(C'\fR will move important steps of your program's execution
from compile time to runtime.  This can
.IP "\(bu" 4
Break the execution of your program if the module you \f(CW\*(C`autouse\*(C'\fRd has
some initialization which it expects to be done early.
.IP "\(bu" 4
hide bugs in your code since important checks (like correctness of
prototypes) is moved from compile time to runtime.  In particular, if
the prototype you specified on \f(CW\*(C`autouse\*(C'\fR line is wrong, you will not
find it out until the corresponding function is executed.  This will be
very unfortunate for functions which are not always called (note that
for such functions \f(CW\*(C`autouse\*(C'\fRing gives biggest win, for a workaround
see below).
.PP
To alleviate the second problem (partially) it is advised to write
your scripts like this:
.PP
.Vb 3
\&  use Module;
\&  use autouse Module => qw(carp($) croak(&$));
\&  carp "this carp was predeclared and autoused ";
.Ve
.PP
The first line ensures that the errors in your argument specification
are found early.  When you ship your application you should comment
out the first line, since it makes the second one useless.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ilya Zakharevich (ilya@math.ohio\-state.edu)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1).
                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/autouse5.16.3pm                              0100644 0001750 0001750 00000014065 12566207442 023306  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "autouse 3pm"
.TH autouse 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
autouse \- postpone load of modules until a function is used
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use autouse \*(AqCarp\*(Aq => qw(carp croak);
\&  carp "this carp was predeclared and autoused ";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
If the module \f(CW\*(C`Module\*(C'\fR is already loaded, then the declaration
.PP
.Vb 1
\&  use autouse \*(AqModule\*(Aq => qw(func1 func2($;$));
.Ve
.PP
is equivalent to
.PP
.Vb 1
\&  use Module qw(func1 func2);
.Ve
.PP
if \f(CW\*(C`Module\*(C'\fR defines \fIfunc2()\fR with prototype \f(CW\*(C`($;$)\*(C'\fR, and \fIfunc1()\fR has
no prototypes.  (At least if \f(CW\*(C`Module\*(C'\fR uses \f(CW\*(C`Exporter\*(C'\fR's \f(CW\*(C`import\*(C'\fR,
otherwise it is a fatal error.)
.PP
If the module \f(CW\*(C`Module\*(C'\fR is not loaded yet, then the above declaration
declares functions \fIfunc1()\fR and \fIfunc2()\fR in the current package.  When
these functions are called, they load the package \f(CW\*(C`Module\*(C'\fR if needed,
and substitute themselves with the correct definitions.
.SH "WARNING"
.IX Header "WARNING"
Using \f(CW\*(C`autouse\*(C'\fR will move important steps of your program's execution
from compile time to runtime.  This can
.IP "\(bu" 4
Break the execution of your program if the module you \f(CW\*(C`autouse\*(C'\fRd has
some initialization which it expects to be done early.
.IP "\(bu" 4
hide bugs in your code since important checks (like correctness of
prototypes) is moved from compile time to runtime.  In particular, if
the prototype you specified on \f(CW\*(C`autouse\*(C'\fR line is wrong, you will not
find it out until the corresponding function is executed.  This will be
very unfortunate for functions which are not always called (note that
for such functions \f(CW\*(C`autouse\*(C'\fRing gives biggest win, for a workaround
see below).
.PP
To alleviate the second problem (partially) it is advised to write
your scripts like this:
.PP
.Vb 3
\&  use Module;
\&  use autouse Module => qw(carp($) croak(&$));
\&  carp "this carp was predeclared and autoused ";
.Ve
.PP
The first line ensures that the errors in your argument specification
are found early.  When you ship your application you should comment
out the first line, since it makes the second one useless.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ilya Zakharevich (ilya@math.ohio\-state.edu)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1).
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/autouse5.18.3pm                              0100644 0001750 0001750 00000014406 12566207465 023314  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "autouse 3pm"
.TH autouse 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
autouse \- postpone load of modules until a function is used
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use autouse \*(AqCarp\*(Aq => qw(carp croak);
\&  carp "this carp was predeclared and autoused ";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
If the module \f(CW\*(C`Module\*(C'\fR is already loaded, then the declaration
.PP
.Vb 1
\&  use autouse \*(AqModule\*(Aq => qw(func1 func2($;$));
.Ve
.PP
is equivalent to
.PP
.Vb 1
\&  use Module qw(func1 func2);
.Ve
.PP
if \f(CW\*(C`Module\*(C'\fR defines \fIfunc2()\fR with prototype \f(CW\*(C`($;$)\*(C'\fR, and \fIfunc1()\fR has
no prototypes.  (At least if \f(CW\*(C`Module\*(C'\fR uses \f(CW\*(C`Exporter\*(C'\fR's \f(CW\*(C`import\*(C'\fR,
otherwise it is a fatal error.)
.PP
If the module \f(CW\*(C`Module\*(C'\fR is not loaded yet, then the above declaration
declares functions \fIfunc1()\fR and \fIfunc2()\fR in the current package.  When
these functions are called, they load the package \f(CW\*(C`Module\*(C'\fR if needed,
and substitute themselves with the correct definitions.
.SH "WARNING"
.IX Header "WARNING"
Using \f(CW\*(C`autouse\*(C'\fR will move important steps of your program's execution
from compile time to runtime.  This can
.IP "\(bu" 4
Break the execution of your program if the module you \f(CW\*(C`autouse\*(C'\fRd has
some initialization which it expects to be done early.
.IP "\(bu" 4
hide bugs in your code since important checks (like correctness of
prototypes) is moved from compile time to runtime.  In particular, if
the prototype you specified on \f(CW\*(C`autouse\*(C'\fR line is wrong, you will not
find it out until the corresponding function is executed.  This will be
very unfortunate for functions which are not always called (note that
for such functions \f(CW\*(C`autouse\*(C'\fRing gives biggest win, for a workaround
see below).
.PP
To alleviate the second problem (partially) it is advised to write
your scripts like this:
.PP
.Vb 3
\&  use Module;
\&  use autouse Module => qw(carp($) croak(&$));
\&  carp "this carp was predeclared and autoused ";
.Ve
.PP
The first line ensures that the errors in your argument specification
are found early.  When you ship your application you should comment
out the first line, since it makes the second one useless.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ilya Zakharevich (ilya@math.ohio\-state.edu)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1).
                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/backtrace.3                                  0100644 0001750 0001750 00000006312 12566166140 022664  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2007 Apple Inc.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of Apple Inc. ("Apple") nor the names of its
.\"    contributors may be used to endorse or promote products derived from
.\"    this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY APPLE AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"
.Dd February 15, 2007
.Dt backtrace 3
.Os "Mac OS X"
.Sh NAME
.Nm backtrace ,
.Nm backtrace_symbols ,
.Nm backtrace_symbols_fd
.Nd call stack backtrace and display functions
.Sh SYNOPSIS
.In execinfo.h
.Ft int
.Fo backtrace
.Fa "void** array"
.Fa "int size"
.Fc
.Ft char**
.Fo backtrace_symbols
.Fa "void* const* array"
.Fa "int size"
.Fc
.Ft void
.Fo backtrace_symbols_fd
.Fa "void* const* array"
.Fa "int size"
.Fa "int fd"
.Fc
.Sh DESCRIPTION
These routines provide a mechanism to examine the current thread's call stack.
.Pp
.Fn backtrace
writes the function return addresses of the current call stack to the array of
pointers referenced by
.Fa array .
At most,
.Fa size
pointers are written.  The number of pointers actually written to
.Fa array
is returned.
.Pp
.Fn backtrace_symbols
attempts to transform a call stack obtained by
.Fn backtrace
into an array of human-readable strings using
.Fn dladdr .
The array of strings returned has
.Fa size
elements.  It is allocated using
.Fn malloc
and should be released using
.Fn free .
There is no need to free the individual strings in the array.
.Pp
.Fn backtrace_symbols_fd
performs the same operation as
.Fn backtrace_symbols ,
but the resulting strings are immediately written to the file descriptor
.Fa fd ,
and are not returned.
.Sh EXAMPLE
.Pp
    #include <execinfo.h>
    #include <stdio.h>
    ...
    void* callstack[128];
    int i, frames = backtrace(callstack, 128);
    char** strs = backtrace_symbols(callstack, frames);
    for (i = 0; i < frames; ++i) {
        printf("%s\\n", strs[i]);
    }
    free(strs);
    ...
.Pp
.Sh HISTORY
These functions first appeared in
Mac OS X 10.5.
.Sh SEE ALSO
.Xr dladdr 3 ,
.Xr malloc 3
                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/backtrace_symbols.3                          0120777 0001750 0001750 00000000000 12620245063 026425  2backtrace.3                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/backtrace_symbols_fd.3                       0120777 0001750 0001750 00000000000 12620245063 027076  2backtrace.3                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bareword::filehandles.3pm                    0100644 0001750 0001750 00000012457 12566242361 025501  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bareword::filehandles 3"
.TH bareword::filehandles 3 "2011-03-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
bareword::filehandles \- disables bareword filehandles
.SH "VERSION"
.IX Header "VERSION"
version 0.003
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    no bareword::filehandles;
\&
\&    open FH, $file            # dies
\&    open my $fh, $file;       # doesn\*(Aqt die
\&
\&    print FH $string          # dies
\&    print STDERR $string      # doesn\*(Aqt die
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module lexically disables the use of bareword filehandles with
builtin functions, except for the special builitin filehandles \f(CW\*(C`STDIN\*(C'\fR,
\&\f(CW\*(C`STDOUT\*(C'\fR, \f(CW\*(C`STDERR\*(C'\fR, \f(CW\*(C`ARGV\*(C'\fR, \f(CW\*(C`ARGVOUT\*(C'\fR and \f(CW\*(C`DATA\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
.SS "unimport"
.IX Subsection "unimport"
Disables bareword filehandles for the remainder of the scope being
compiled.
.SS "import"
.IX Subsection "import"
Enables bareword filehandles for the remainder of the scope being
compiled.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlfunc,
B::Hooks::OP::Check.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dagfinn Ilmari Mannsa\*oker <ilmari@ilmari.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2011 by Dagfinn Ilmari Mannsa\*oker.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bareword::filehandles5.18.3pm                0100644 0001750 0001750 00000012457 12566242361 026015  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bareword::filehandles 3"
.TH bareword::filehandles 3 "2011-03-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
bareword::filehandles \- disables bareword filehandles
.SH "VERSION"
.IX Header "VERSION"
version 0.003
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    no bareword::filehandles;
\&
\&    open FH, $file            # dies
\&    open my $fh, $file;       # doesn\*(Aqt die
\&
\&    print FH $string          # dies
\&    print STDERR $string      # doesn\*(Aqt die
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module lexically disables the use of bareword filehandles with
builtin functions, except for the special builitin filehandles \f(CW\*(C`STDIN\*(C'\fR,
\&\f(CW\*(C`STDOUT\*(C'\fR, \f(CW\*(C`STDERR\*(C'\fR, \f(CW\*(C`ARGV\*(C'\fR, \f(CW\*(C`ARGVOUT\*(C'\fR and \f(CW\*(C`DATA\*(C'\fR.
.SH "METHODS"
.IX Header "METHODS"
.SS "unimport"
.IX Subsection "unimport"
Disables bareword filehandles for the remainder of the scope being
compiled.
.SS "import"
.IX Subsection "import"
Enables bareword filehandles for the remainder of the scope being
compiled.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlfunc,
B::Hooks::OP::Check.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dagfinn Ilmari Mannsa\*oker <ilmari@ilmari.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2011 by Dagfinn Ilmari Mannsa\*oker.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/barrier.3                                    0100644 0001750 0001750 00000001572 12566165766 022413  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd May 26, 2004
.Dt BARRIER 3
.Os Darwin
.Sh NAME
.Nm OSMemoryBarrier
.Nd memory barrier to order loads and stores
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In libkern/OSAtomic.h
.Ft void
.Fn OSMemoryBarrier "void"
.Sh DESCRIPTION
.Fn OSMemoryBarrier
strictly orders memory accesses in a weakly ordered memory model such as with
ARM, by creating a barrier.
All loads and stores executed in sequential program order before the barrier will complete with respect to the memory coherence mechanism, before any load or store executed after the barrier. Used with an atomic operation, the barrier can be used to create custom synchronization protocols as an alternative to the spinlock or queue/dequeue operations. Note that this barrier does not order uncached loads and stores. On a uniprocessor, the barrier operation is typically optimized into a no-op.
.Sh SEE ALSO
.Xr atomic 3 ,
.Xr spinlock 3
                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/base.3pm                                     0100644 0001750 0001750 00000014655 12566207465 022233  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "base 3pm"
.TH base 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
base \- Establish an ISA relationship with base classes at compile time
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package Baz;
\&    use base qw(Foo Bar);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Unless you are using the \f(CW\*(C`fields\*(C'\fR pragma, consider this module discouraged
in favor of the lighter-weight \f(CW\*(C`parent\*(C'\fR.
.PP
Allows you to both load one or more modules, while setting up inheritance from
those modules at the same time.  Roughly similar in effect to
.PP
.Vb 6
\&    package Baz;
\&    BEGIN {
\&        require Foo;
\&        require Bar;
\&        push @ISA, qw(Foo Bar);
\&    }
.Ve
.PP
When \f(CW\*(C`base\*(C'\fR tries to \f(CW\*(C`require\*(C'\fR a module, it will not die if it cannot find
the module's file, but will die on any other error.  After all this, should
your base class be empty, containing no symbols, \f(CW\*(C`base\*(C'\fR will die. This is
useful for inheriting from classes in the same file as yourself but where
the filename does not match the base module name, like so:
.PP
.Vb 3
\&        # in Bar.pm
\&        package Foo;
\&        sub exclaim { "I can have such a thing?!" }
\&
\&        package Bar;
\&        use base "Foo";
.Ve
.PP
There is no \fIFoo.pm\fR, but because \f(CW\*(C`Foo\*(C'\fR defines a symbol (the \f(CW\*(C`exclaim\*(C'\fR
subroutine), \f(CW\*(C`base\*(C'\fR will not die when the \f(CW\*(C`require\*(C'\fR fails to load \fIFoo.pm\fR.
.PP
\&\f(CW\*(C`base\*(C'\fR will also initialize the fields if one of the base classes has it.
Multiple inheritance of fields is \fB\s-1NOT\s0\fR supported, if two or more base classes
each have inheritable fields the 'base' pragma will croak. See fields
for a description of this feature.
.PP
The base class' \f(CW\*(C`import\*(C'\fR method is \fBnot\fR called.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Base class package ""%s"" is empty." 4
.el .IP "Base class package ``%s'' is empty." 4
.IX Item "Base class package %s is empty."
base.pm was unable to require the base package, because it was not
found in your path.
.IP "Class 'Foo' tried to inherit from itself" 4
.IX Item "Class 'Foo' tried to inherit from itself"
Attempting to inherit from yourself generates a warning.
.Sp
.Vb 2
\&    package Foo;
\&    use base \*(AqFoo\*(Aq;
.Ve
.SH "HISTORY"
.IX Header "HISTORY"
This module was introduced with Perl 5.004_04.
.SH "CAVEATS"
.IX Header "CAVEATS"
Due to the limitations of the implementation, you must use
base \fIbefore\fR you declare any of your own fields.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
fields
                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/base5.16.3pm                                 0100644 0001750 0001750 00000014334 12566207442 022532  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "base 3pm"
.TH base 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
base \- Establish an ISA relationship with base classes at compile time
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package Baz;
\&    use base qw(Foo Bar);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Unless you are using the \f(CW\*(C`fields\*(C'\fR pragma, consider this module discouraged
in favor of the lighter-weight \f(CW\*(C`parent\*(C'\fR.
.PP
Allows you to both load one or more modules, while setting up inheritance from
those modules at the same time.  Roughly similar in effect to
.PP
.Vb 6
\&    package Baz;
\&    BEGIN {
\&        require Foo;
\&        require Bar;
\&        push @ISA, qw(Foo Bar);
\&    }
.Ve
.PP
When \f(CW\*(C`base\*(C'\fR tries to \f(CW\*(C`require\*(C'\fR a module, it will not die if it cannot find
the module's file, but will die on any other error.  After all this, should
your base class be empty, containing no symbols, \f(CW\*(C`base\*(C'\fR will die. This is
useful for inheriting from classes in the same file as yourself but where
the filename does not match the base module name, like so:
.PP
.Vb 3
\&        # in Bar.pm
\&        package Foo;
\&        sub exclaim { "I can have such a thing?!" }
\&
\&        package Bar;
\&        use base "Foo";
.Ve
.PP
There is no \fIFoo.pm\fR, but because \f(CW\*(C`Foo\*(C'\fR defines a symbol (the \f(CW\*(C`exclaim\*(C'\fR
subroutine), \f(CW\*(C`base\*(C'\fR will not die when the \f(CW\*(C`require\*(C'\fR fails to load \fIFoo.pm\fR.
.PP
\&\f(CW\*(C`base\*(C'\fR will also initialize the fields if one of the base classes has it.
Multiple inheritance of fields is \fB\s-1NOT\s0\fR supported, if two or more base classes
each have inheritable fields the 'base' pragma will croak. See fields
for a description of this feature.
.PP
The base class' \f(CW\*(C`import\*(C'\fR method is \fBnot\fR called.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Base class package ""%s"" is empty." 4
.el .IP "Base class package ``%s'' is empty." 4
.IX Item "Base class package %s is empty."
base.pm was unable to require the base package, because it was not
found in your path.
.IP "Class 'Foo' tried to inherit from itself" 4
.IX Item "Class 'Foo' tried to inherit from itself"
Attempting to inherit from yourself generates a warning.
.Sp
.Vb 2
\&    package Foo;
\&    use base \*(AqFoo\*(Aq;
.Ve
.SH "HISTORY"
.IX Header "HISTORY"
This module was introduced with Perl 5.004_04.
.SH "CAVEATS"
.IX Header "CAVEATS"
Due to the limitations of the implementation, you must use
base \fIbefore\fR you declare any of your own fields.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
fields
                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/base5.18.3pm                                 0100644 0001750 0001750 00000014655 12566207465 022547  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "base 3pm"
.TH base 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
base \- Establish an ISA relationship with base classes at compile time
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    package Baz;
\&    use base qw(Foo Bar);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Unless you are using the \f(CW\*(C`fields\*(C'\fR pragma, consider this module discouraged
in favor of the lighter-weight \f(CW\*(C`parent\*(C'\fR.
.PP
Allows you to both load one or more modules, while setting up inheritance from
those modules at the same time.  Roughly similar in effect to
.PP
.Vb 6
\&    package Baz;
\&    BEGIN {
\&        require Foo;
\&        require Bar;
\&        push @ISA, qw(Foo Bar);
\&    }
.Ve
.PP
When \f(CW\*(C`base\*(C'\fR tries to \f(CW\*(C`require\*(C'\fR a module, it will not die if it cannot find
the module's file, but will die on any other error.  After all this, should
your base class be empty, containing no symbols, \f(CW\*(C`base\*(C'\fR will die. This is
useful for inheriting from classes in the same file as yourself but where
the filename does not match the base module name, like so:
.PP
.Vb 3
\&        # in Bar.pm
\&        package Foo;
\&        sub exclaim { "I can have such a thing?!" }
\&
\&        package Bar;
\&        use base "Foo";
.Ve
.PP
There is no \fIFoo.pm\fR, but because \f(CW\*(C`Foo\*(C'\fR defines a symbol (the \f(CW\*(C`exclaim\*(C'\fR
subroutine), \f(CW\*(C`base\*(C'\fR will not die when the \f(CW\*(C`require\*(C'\fR fails to load \fIFoo.pm\fR.
.PP
\&\f(CW\*(C`base\*(C'\fR will also initialize the fields if one of the base classes has it.
Multiple inheritance of fields is \fB\s-1NOT\s0\fR supported, if two or more base classes
each have inheritable fields the 'base' pragma will croak. See fields
for a description of this feature.
.PP
The base class' \f(CW\*(C`import\*(C'\fR method is \fBnot\fR called.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "Base class package ""%s"" is empty." 4
.el .IP "Base class package ``%s'' is empty." 4
.IX Item "Base class package %s is empty."
base.pm was unable to require the base package, because it was not
found in your path.
.IP "Class 'Foo' tried to inherit from itself" 4
.IX Item "Class 'Foo' tried to inherit from itself"
Attempting to inherit from yourself generates a warning.
.Sp
.Vb 2
\&    package Foo;
\&    use base \*(AqFoo\*(Aq;
.Ve
.SH "HISTORY"
.IX Header "HISTORY"
This module was introduced with Perl 5.004_04.
.SH "CAVEATS"
.IX Header "CAVEATS"
Due to the limitations of the implementation, you must use
base \fIbefore\fR you declare any of your own fields.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
fields
                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/basename.3                                   0100644 0001750 0001750 00000006217 12566166140 022524  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"
.\" Copyright (c) 1997 Todd C. Miller <Todd.Miller@courtesan.com>
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. The name of the author may not be used to endorse or promote products
.\"    derived from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
.\" INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
.\" AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
.\" THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
.\" EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
.\" PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
.\" OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
.\" WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
.\" OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
.\" ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.\" $OpenBSD: basename.3,v 1.12 2000/04/18 03:01:25 aaron Exp $
.\" $FreeBSD: src/lib/libc/gen/basename.3,v 1.7 2004/07/02 23:52:10 ru Exp $
.\"
.Dd August 17, 1997
.Dt BASENAME 3
.Os
.Sh NAME
.Nm basename
.Nd extract the base portion of a pathname
.Sh SYNOPSIS
.In libgen.h
.Ft char *
.Fo basename
.Fa "char *path"
.Fc
.Sh DESCRIPTION
The
.Fn basename
function
returns the last component from the pathname pointed to by
.Fa path ,
deleting any trailing
.Sq \&/
characters.
If
.Fa path
consists entirely of
.Sq \&/
characters, a pointer to the string
.Qq \&/
is returned.
If
.Fa path
is a null pointer or the empty string, a pointer to the string
.Qq \&.
is returned.
.Sh RETURN VALUES
On successful completion,
.Fn basename
returns a pointer to the last component of
.Fa path .
.Pp
If
.Fn basename
fails, a null pointer is returned and the global variable
.Va errno
is set to indicate the error.
.Sh ERRORS
The following error codes may be set in
.Va errno :
.Bl -tag -width Er
.It Bq Er ENAMETOOLONG
The path component to be returned was larger than
.Dv MAXPATHLEN .
.El
.Sh WARNINGS
The
.Fn basename
function
returns a pointer to internal static storage space
that will be overwritten by subsequent calls.
The function may modify the string pointed to by
.Fa path .
.Sh LEGACY SYNOPSIS
.Fd #include <libgen.h>
.Pp
.Ft char *
.br
.Fo basename
.Fa "const char *path"
.Fc ;
.Pp
In legacy mode,
.Fa path
will not be changed.
.Sh SEE ALSO
.Xr basename 1 ,
.Xr dirname 1 ,
.Xr dirname 3 ,
.Xr compat 5
.Sh STANDARDS
The
.Fn basename
function conforms to
.St -xpg4.2 .
.Sh HISTORY
The
.Fn basename
function first appeared in
.Ox 2.2
and
.Fx 4.2 .
.Sh AUTHORS
.An "Todd C. Miller" Aq Todd.Miller@courtesan.com
                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/baudrate.3x                                  0100644 0001750 0001750 00000013220 12566174422 022722  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"***************************************************************************
.\" Copyright (c) 1998-2003,2007 Free Software Foundation, Inc.              *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, to any person obtaining a  *
.\" copy of this software and associated documentation files (the            *
.\" "Software"), to deal in the Software without restriction, including      *
.\" without limitation the rights to use, copy, modify, merge, publish,      *
.\" distribute, distribute with modifications, sublicense, and/or sell       *
.\" copies of the Software, and to permit persons to whom the Software is    *
.\" furnished to do so, subject to the following conditions:                 *
.\"                                                                          *
.\" The above copyright notice and this permission notice shall be included  *
.\" in all copies or substantial portions of the Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained in this notice, the name(s) of the above copyright   *
.\" holders shall not be used in advertising or otherwise to promote the     *
.\" sale, use or other dealings in this Software without prior written       *
.\" authorization.                                                           *
.\"***************************************************************************
.\"
.\" $Id: curs_termattrs.3x,v 1.10 2007/06/02 20:40:07 tom Exp $
.TH curs_termattrs 3X ""
.SH NAME
\fBbaudrate\fR,
\fBerasechar\fR,
\fBerasewchar\fR,
\fBhas_ic\fR,
\fBhas_il\fR,
\fBkillchar\fR,
\fBkillwchar\fR,
\fBlongname\fR,
\fBterm_attrs\fR,
\fBtermattrs\fR,
\fBtermname\fR - \fBcurses\fR environment query routines
.SH SYNOPSIS
\fB#include <curses.h>\fR
.PP
\fBint baudrate(void);\fR
.br
\fBchar erasechar(void);\fR
.br
\fBint erasewchar(wchar_t *\fR\fIch\fR\fB);\fR
.br
\fBbool has_ic(void);\fR
.br
\fBbool has_il(void);\fR
.br
\fBchar killchar(void);\fR
.br
\fBint killwchar(wchar_t *\fR\fIch\fR\fB);\fR
.br
\fBchar *longname(void);\fR
.br
\fBattr_t term_attrs(void);\fR
.br
\fBchtype termattrs(void);\fR
.br
\fBchar *termname(void);\fR
.br
.SH DESCRIPTION
The \fBbaudrate\fR routine returns the output speed of the terminal.  The
number returned is in bits per second, for example \fB9600\fR, and is an
integer.
.PP
The \fBerasechar\fR routine returns the user's current erase character.
.PP
The \fBerasewchar\fR routine stores the current erase character
in the location referenced by \fIch\fR.
If no erase character has been defined, the routine fails
and the location referenced by \fIch\fR is not changed.
.PP
The \fBhas_ic\fR routine is true if the terminal has insert- and delete-
character capabilities.
.PP
The \fBhas_il\fR routine is true if the terminal has insert- and delete-line
capabilities, or can simulate them using scrolling regions.  This might
be used to determine if it would be appropriate to turn on physical
scrolling using \fBscrollok\fR.
.PP
The \fBkillchar\fR routine returns the user's current line kill character.
.PP
The \fBkillwchar\fR routine stores the current line-kill character
in the location referenced by \fIch\fR.
If no line-kill character has been defined,
the routine fails and the location referenced by \fIch\fR is not changed.
.PP
The \fBlongname\fR routine returns a pointer to a static area
containing a verbose description of the current terminal.  The maximum
length of a verbose description is 128 characters.  It is defined only
after the call to \fBinitscr\fR or \fBnewterm\fR.  The area is
overwritten by each call to \fBnewterm\fR and is not restored by
\fBset_term\fR, so the value should be saved between calls to
\fBnewterm\fR if \fBlongname\fR is going to be used with multiple
terminals.
.PP
If a given terminal does not support a video attribute that an
application program is trying to use, \fBcurses\fR may substitute a
different video attribute for it.
The \fBtermattrs\fR and \fBterm_attrs\fR functions
return a logical \fBOR\fR of all video attributes supported by the
terminal using \fIA_\fR and \fIWA_\fR constants respectively.
This information is useful when a \fBcurses\fR program
needs complete control over the appearance of the screen.
.PP
The \fBtermname\fR routine returns the terminal name used by \fBsetupterm\fR.
.SH RETURN VALUE
\fBlongname\fR and \fBtermname\fR return \fBNULL\fR on error.
.PP
Routines that return an integer return \fBERR\fR upon failure and \fBOK\fR
(SVr4 only specifies "an integer value other than \fBERR\fR") upon successful
completion.
.SH NOTES
Note that \fBtermattrs\fR may be a macro.
.SH PORTABILITY
The XSI Curses standard, Issue 4 describes these functions.  It changes the
return type of \fBtermattrs\fR to the new type \fBattr_t\fR.
Most versions of curses truncate the result returned by \fBtermname\fR to
14 characters.
.SH SEE ALSO
\fBcurses\fR(3X), \fBcurs_initscr\fR(3X), \fBcurs_outopts\fR(3X)
.\"#
.\"# The following sets edit modes for GNU EMACS
.\"# Local Variables:
.\"# mode:nroff
.\"# fill-column:79
.\"# End:
                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bcmp.3                                       0100644 0001750 0001750 00000004776 12566166140 021702  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 1990, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" Chris Torek.
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @(#)bcmp.3	8.1 (Berkeley) 6/4/93
.\" $FreeBSD: src/lib/libc/string/bcmp.3,v 1.11 2007/01/09 00:28:11 imp Exp $
.\"
.Dd June 4, 1993
.Dt BCMP 3
.Os
.Sh NAME
.Nm bcmp
.Nd compare byte string
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In strings.h
.Ft int
.Fn bcmp "const void *s1" "const void *s2" "size_t n"
.Sh DESCRIPTION
The
.Fn bcmp
function
compares byte string
.Fa s1
against byte string
.Fa s2 ,
returning zero if they are identical, non-zero otherwise.
Both strings are assumed to be
.Fa n
bytes long.
Zero-length strings are always identical.
.Pp
The strings may overlap.
.Sh SEE ALSO
.Xr memcmp 3 ,
.Xr strcasecmp 3 ,
.Xr strcmp 3 ,
.Xr strcoll 3 ,
.Xr strxfrm 3
.Sh HISTORY
A
.Fn bcmp
function first appeared in
.Bx 4.2 .
Its prototype existed previously in
.In string.h
before it was moved to
.In strings.h
for
.St -p1003.1-2001
compliance.
  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bcopy.3                                      0100644 0001750 0001750 00000004751 12566166140 022066  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 1990, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" Chris Torek.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @(#)bcopy.3	8.1 (Berkeley) 6/4/93
.\" $FreeBSD: src/lib/libc/string/bcopy.3,v 1.10 2007/01/09 00:28:11 imp Exp $
.\"
.Dd June 4, 1993
.Dt BCOPY 3
.Os
.Sh NAME
.Nm bcopy
.Nd copy byte string
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In strings.h
.Ft void
.Fn bcopy "const void *src" "void *dst" "size_t len"
.Sh DESCRIPTION
The
.Fn bcopy
function
copies
.Fa len
bytes from string
.Fa src
to string
.Fa dst .
The two strings may overlap.
If
.Fa len
is zero, no bytes are copied.
.Sh SEE ALSO
.Xr memccpy 3 ,
.Xr memcpy 3 ,
.Xr memmove 3 ,
.Xr strcpy 3 ,
.Xr strncpy 3
.Sh HISTORY
A
.Fn bcopy
function appeared in
.Bx 4.2 .
Its prototype existed previously in
.In string.h
before it was moved to
.In strings.h
for
.St -p1003.1-2001
compliance.
.Pp
.Fn bcopy
was deprecated in
.St -p1003.1-2001
and removed in
.St -p1003.1-2008 .
                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/beep.3x                                      0100644 0001750 0001750 00000006465 12566174416 022066  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"***************************************************************************
.\" Copyright (c) 1998-2003,2005 Free Software Foundation, Inc.              *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, to any person obtaining a  *
.\" copy of this software and associated documentation files (the            *
.\" "Software"), to deal in the Software without restriction, including      *
.\" without limitation the rights to use, copy, modify, merge, publish,      *
.\" distribute, distribute with modifications, sublicense, and/or sell       *
.\" copies of the Software, and to permit persons to whom the Software is    *
.\" furnished to do so, subject to the following conditions:                 *
.\"                                                                          *
.\" The above copyright notice and this permission notice shall be included  *
.\" in all copies or substantial portions of the Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained in this notice, the name(s) of the above copyright   *
.\" holders shall not be used in advertising or otherwise to promote the     *
.\" sale, use or other dealings in this Software without prior written       *
.\" authorization.                                                           *
.\"***************************************************************************
.\"
.\" $Id: curs_beep.3x,v 1.10 2005/01/08 17:55:51 tom Exp $
.TH curs_beep 3X ""
.SH NAME
\fBbeep\fR, \fBflash\fR - \fBcurses\fR bell and screen flash routines
.SH SYNOPSIS
\fB#include <curses.h>\fR
.PP
\fBint beep(void);\fR
.br
\fBint flash(void);\fR
.br
.SH DESCRIPTION
The \fBbeep\fR and \fBflash\fR routines are used to alert the terminal user.
The routine \fBbeep\fR sounds an audible alarm on the terminal, if possible;
otherwise it flashes the screen (visible bell).  The routine \fBflash\fR
flashes the screen, and if that is not possible, sounds the alert.  If neither
alert is possible, nothing happens.  Nearly all terminals have an audible alert
(bell or beep), but only some can flash the screen.
.SH RETURN VALUE
These routines return \fBOK\fR if they succeed in beeping or flashing,
\fBERR\fR otherwise.
.SH EXTENSIONS
SVr4's beep and flash routines always returned \fBOK\fR, so it was not
possible to tell when the beep or flash failed.
.SH PORTABILITY
These functions are described in the XSI Curses standard, Issue 4.
Like SVr4, it specifies that they always return \fBOK\fR.
.SH SEE ALSO
\fBcurses\fR(3X)
.\"#
.\"# The following sets edit modes for GNU EMACS
.\"# Local Variables:
.\"# mode:nroff
.\"# fill-column:79
.\"# End:
                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_alloc_t.3                                0120777 0001750 0001750 00000000000 12620245063 025443  2lber-encode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_bvarray_add.3                            0120777 0001750 0001750 00000000000 12620245063 026213  2lber-types.3                                                                                        ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_bvarray_free.3                           0120777 0001750 0001750 00000000000 12620245063 026404  2lber-types.3                                                                                        ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_bvdup.3                                  0120777 0001750 0001750 00000000000 12620245063 025055  2lber-types.3                                                                                        ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_bvecadd.3                                0120777 0001750 0001750 00000000000 12620245063 025325  2lber-types.3                                                                                        ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_bvecfree.3                               0120777 0001750 0001750 00000000000 12620245063 025516  2lber-types.3                                                                                        ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_bvfree.3                                 0120777 0001750 0001750 00000000000 12620245063 025206  2lber-types.3                                                                                        ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_bvstr.3                                  0120777 0001750 0001750 00000000000 12620245063 025075  2lber-types.3                                                                                        ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_bvstrdup.3                               0120777 0001750 0001750 00000000000 12620245063 025606  2lber-types.3                                                                                        ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_dupbv.3                                  0120777 0001750 0001750 00000000000 12620245063 025055  2lber-types.3                                                                                        ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_first_element.3                          0120777 0001750 0001750 00000000000 12620245063 026654  2lber-decode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_flush.3                                  0120777 0001750 0001750 00000000000 12620245063 025147  2lber-encode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_free.3                                   0120777 0001750 0001750 00000000000 12620245063 024656  2lber-types.3                                                                                        ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_get_bitstring.3                          0120777 0001750 0001750 00000000000 12620245063 026660  2lber-decode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_get_boolean.3                            0120777 0001750 0001750 00000000000 12620245063 026272  2lber-decode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_get_enum.3                               0120777 0001750 0001750 00000000000 12620245063 025617  2lber-decode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_get_int.3                                0120777 0001750 0001750 00000000000 12620245063 025445  2lber-decode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_get_next.3                               0120777 0001750 0001750 00000000000 12620245063 025631  2lber-decode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_get_null.3                               0120777 0001750 0001750 00000000000 12620245063 025625  2lber-decode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_get_stringa.3                            0120777 0001750 0001750 00000000000 12620245063 026322  2lber-decode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_get_stringb.3                            0120777 0001750 0001750 00000000000 12620245063 026323  2lber-decode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_next_element.3                           0120777 0001750 0001750 00000000000 12620245063 026503  2lber-decode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_peek_tag.3                               0120777 0001750 0001750 00000000000 12620245063 025573  2lber-decode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_printf.3                                 0120777 0001750 0001750 00000000000 12620245063 025330  2lber-encode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_put_enum.3                               0120777 0001750 0001750 00000000000 12620245063 025662  2lber-encode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_put_int.3                                0120777 0001750 0001750 00000000000 12620245063 025510  2lber-encode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_put_null.3                               0120777 0001750 0001750 00000000000 12620245063 025670  2lber-encode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_put_ostring.3                            0120777 0001750 0001750 00000000000 12620245063 026403  2lber-encode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_put_seq.3                                0120777 0001750 0001750 00000000000 12620245063 025506  2lber-encode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_put_set.3                                0120777 0001750 0001750 00000000000 12620245063 025511  2lber-encode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_put_string.3                             0120777 0001750 0001750 00000000000 12620245063 026224  2lber-encode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_scanf.3                                  0120777 0001750 0001750 00000000000 12620245063 025106  2lber-decode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_skip_tag.3                               0120777 0001750 0001750 00000000000 12620245063 025615  2lber-decode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_start_set.3                              0120777 0001750 0001750 00000000000 12620245063 026036  2lber-encode.3                                                                                       ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ber_str2bv.3                                 0120777 0001750 0001750 00000000000 12620245063 025157  2lber-types.3                                                                                        ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bigint.3pm                                   0100644 0001750 0001750 00000042244 12566207465 022570  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bigint 3pm"
.TH bigint 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
bigint \- Transparent BigInteger support for Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use bigint;
\&
\&  $x = 2 + 4.5,"\en";                    # BigInt 6
\&  print 2 ** 512,"\en";                  # really is what you think it is
\&  print inf + 42,"\en";                  # inf
\&  print NaN * 7,"\en";                   # NaN
\&  print hex("0x1234567890123490"),"\en"; # Perl v5.10.0 or later
\&
\&  {
\&    no bigint;
\&    print 2 ** 256,"\en";                # a normal Perl scalar now
\&  }
\&
\&  # Import into current package:
\&  use bigint qw/hex oct/;
\&  print hex("0x1234567890123490"),"\en";
\&  print oct("01234567890123490"),"\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (including basic math operations) except the range operator \f(CW\*(C`..\*(C'\fR
are overloaded. Integer constants are created as proper BigInts.
.PP
Floating point constants are truncated to integer. All parts and results of
expressions are also truncated.
.PP
Unlike integer, this pragma creates integer constants that are only
limited in their size by the available memory and \s-1CPU\s0 time.
.SS "use integer vs. use bigint"
.IX Subsection "use integer vs. use bigint"
There is one small difference between \f(CW\*(C`use integer\*(C'\fR and \f(CW\*(C`use bigint\*(C'\fR: the
former will not affect assignments to variables and the return value of
some functions. \f(CW\*(C`bigint\*(C'\fR truncates these results to integer too:
.PP
.Vb 8
\&        # perl \-Minteger \-wle \*(Aqprint 3.2\*(Aq
\&        3.2
\&        # perl \-Minteger \-wle \*(Aqprint 3.2 + 0\*(Aq
\&        3
\&        # perl \-Mbigint \-wle \*(Aqprint 3.2\*(Aq
\&        3
\&        # perl \-Mbigint \-wle \*(Aqprint 3.2 + 0\*(Aq
\&        3
\&
\&        # perl \-Mbigint \-wle \*(Aqprint exp(1) + 0\*(Aq
\&        2
\&        # perl \-Mbigint \-wle \*(Aqprint exp(1)\*(Aq
\&        2
\&        # perl \-Minteger \-wle \*(Aqprint exp(1)\*(Aq
\&        2.71828182845905
\&        # perl \-Minteger \-wle \*(Aqprint exp(1) + 0\*(Aq
\&        2
.Ve
.PP
In practice this makes seldom a difference as \fBparts and results\fR of
expressions will be truncated anyway, but this can, for instance, affect the
return value of subroutines:
.PP
.Vb 2
\&    sub three_integer { use integer; return 3.2; } 
\&    sub three_bigint { use bigint; return 3.2; }
\&
\&    print three_integer(), " ", three_bigint(),"\en";    # prints "3.2 3"
.Ve
.SS "Options"
.IX Subsection "Options"
bigint recognizes some options that can be passed while loading it via use.
The options can (currently) be either a single letter form, or the long form.
The following options exist:
.IP "a or accuracy" 2
.IX Item "a or accuracy"
This sets the accuracy for all math operations. The argument must be greater
than or equal to zero. See Math::BigInt's \fIbround()\fR function for details.
.Sp
.Vb 1
\&        perl \-Mbigint=a,2 \-le \*(Aqprint 12345+1\*(Aq
.Ve
.Sp
Note that setting precision and accuracy at the same time is not possible.
.IP "p or precision" 2
.IX Item "p or precision"
This sets the precision for all math operations. The argument can be any
integer. Negative values mean a fixed number of digits after the dot, and
are <B>ignored</B> since all operations happen in integer space.
A positive value rounds to this digit left from the dot. 0 or 1 mean round to
integer and are ignore like negative values.
.Sp
See Math::BigInt's \fIbfround()\fR function for details.
.Sp
.Vb 1
\&        perl \-Mbignum=p,5 \-le \*(Aqprint 123456789+123\*(Aq
.Ve
.Sp
Note that setting precision and accuracy at the same time is not possible.
.IP "t or trace" 2
.IX Item "t or trace"
This enables a trace mode and is primarily for debugging bigint or
Math::BigInt.
.IP "hex" 2
.IX Item "hex"
Override the built-in \fIhex()\fR method with a version that can handle big
integers. This overrides it by exporting it to the current package. Under
Perl v5.10.0 and higher, this is not so necessary, as \fIhex()\fR is lexically
overridden in the current scope whenever the bigint pragma is active.
.IP "oct" 2
.IX Item "oct"
Override the built-in \fIoct()\fR method with a version that can handle big
integers. This overrides it by exporting it to the current package. Under
Perl v5.10.0 and higher, this is not so necessary, as \fIoct()\fR is lexically
overridden in the current scope whenever the bigint pragma is active.
.IP "l, lib, try or only" 2
.IX Item "l, lib, try or only"
Load a different math lib, see \*(L"Math Library\*(R".
.Sp
.Vb 3
\&        perl \-Mbigint=lib,GMP \-e \*(Aqprint 2 ** 512\*(Aq
\&        perl \-Mbigint=try,GMP \-e \*(Aqprint 2 ** 512\*(Aq
\&        perl \-Mbigint=only,GMP \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
Currently there is no way to specify more than one library on the command
line. This means the following does not work:
.Sp
.Vb 1
\&        perl \-Mbignum=l,GMP,Pari \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
This will be hopefully fixed soon ;)
.IP "v or version" 2
.IX Item "v or version"
This prints out the name and version of all modules used and then exits.
.Sp
.Vb 1
\&        perl \-Mbigint=v
.Ve
.SS "Math Library"
.IX Subsection "Math Library"
Math with the numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent to saying:
.PP
.Vb 1
\&        use bigint lib => \*(AqCalc\*(Aq;
.Ve
.PP
You can change this by using:
.PP
.Vb 1
\&        use bignum lib => \*(AqGMP\*(Aq;
.Ve
.PP
The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:
.PP
.Vb 1
\&        use bigint lib => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
Using \f(CW\*(C`lib\*(C'\fR warns if none of the specified libraries can be found and
Math::BigInt did fall back to one of the default libraries.
To suppress this warning, use \f(CW\*(C`try\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum try => \*(AqGMP\*(Aq;
.Ve
.PP
If you want the code to die instead of falling back, use \f(CW\*(C`only\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum only => \*(AqGMP\*(Aq;
.Ve
.PP
Please see respective module documentation for further details.
.SS "Internal Format"
.IX Subsection "Internal Format"
The numbers are stored as objects, and their internals might change at anytime,
especially between math operations. The objects also might belong to different
classes, like Math::BigInt, or Math::BigInt::Lite. Mixing them together, even
with normal scalars is not extraordinary, but normal and expected.
.PP
You should not depend on the internal format, all accesses must go through
accessor methods. E.g. looking at \f(CW$x\fR\->{sign} is not a good idea since there
is no guaranty that the object in question has such a hash key, nor is a hash
underneath at all.
.SS "Sign"
.IX Subsection "Sign"
The sign is either '+', '\-', 'NaN', '+inf' or '\-inf'.
You can access it with the \fIsign()\fR method.
.PP
A sign of 'NaN' is used to represent the result when input arguments are not
numbers or as a result of 0/0. '+inf' and '\-inf' represent plus respectively
minus infinity. You will get '+inf' when dividing a positive number by 0, and
\&'\-inf' when dividing any negative number by 0.
.SS "Method calls"
.IX Subsection "Method calls"
Since all numbers are now objects, you can use all functions that are part of
the BigInt \s-1API.\s0 You can only use the \fIbxxx()\fR notation, and not the \fIfxxx()\fR
notation, though.
.PP
But a warning is in order. When using the following to make a copy of a number,
only a shallow copy will be made.
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $x = $y = 7;
.Ve
.PP
Using the copy or the original with overloaded math is okay, e.g. the
following work:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x + 1, " ", $y,"\en";     # prints 10 9
.Ve
.PP
but calling any method that modifies the number directly will result in
\&\fBboth\fR the original and the copy being destroyed:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x\->badd(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->binc(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->bmul(2), " ", $y,"\en";        # prints 18 18
.Ve
.PP
Using methods that do not modify, but testthe contents works:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $z = 9 if $x\->is_zero();                # works fine
.Ve
.PP
See the documentation about the copy constructor and \f(CW\*(C`=\*(C'\fR in overload, as
well as the documentation in BigInt for further details.
.SS "Methods"
.IX Subsection "Methods"
.IP "\fIinf()\fR" 2
.IX Item "inf()"
A shortcut to return Math::BigInt\->\fIbinf()\fR. Useful because Perl does not always
handle bareword \f(CW\*(C`inf\*(C'\fR properly.
.IP "\fINaN()\fR" 2
.IX Item "NaN()"
A shortcut to return Math::BigInt\->\fIbnan()\fR. Useful because Perl does not always
handle bareword \f(CW\*(C`NaN\*(C'\fR properly.
.IP "e" 2
.IX Item "e"
.Vb 1
\&        # perl \-Mbigint=e \-wle \*(Aqprint e\*(Aq
.Ve
.Sp
Returns Euler's number \f(CW\*(C`e\*(C'\fR, aka \fIexp\fR\|(1). Note that under bigint, this is
truncated to an integer, and hence simple '2'.
.IP "\s-1PI\s0" 2
.IX Item "PI"
.Vb 1
\&        # perl \-Mbigint=PI \-wle \*(Aqprint PI\*(Aq
.Ve
.Sp
Returns \s-1PI.\s0 Note that under bigint, this is truncated to an integer, and hence
simple '3'.
.IP "\fIbexp()\fR" 2
.IX Item "bexp()"
.Vb 1
\&        bexp($power,$accuracy);
.Ve
.Sp
Returns Euler's number \f(CW\*(C`e\*(C'\fR raised to the appropriate power, to
the wanted accuracy.
.Sp
Note that under bigint, the result is truncated to an integer.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbigint=bexp \-wle \*(Aqprint bexp(1,80)\*(Aq
.Ve
.IP "\fIbpi()\fR" 2
.IX Item "bpi()"
.Vb 1
\&        bpi($accuracy);
.Ve
.Sp
Returns \s-1PI\s0 to the wanted accuracy. Note that under bigint, this is truncated
to an integer, and hence simple '3'.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbigint=bpi \-wle \*(Aqprint bpi(80)\*(Aq
.Ve
.IP "\fIupgrade()\fR" 2
.IX Item "upgrade()"
Return the class that numbers are upgraded to, is in fact returning
\&\f(CW$Math::BigInt::upgrade\fR.
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
.Vb 1
\&        use bigint;
\&
\&        print "in effect\en" if bigint::in_effect;       # true
\&        {
\&          no bigint;
\&          print "in effect\en" if bigint::in_effect;     # false
\&        }
.Ve
.Sp
Returns true or false if \f(CW\*(C`bigint\*(C'\fR is in effect in the current scope.
.Sp
This method only works on Perl v5.9.4 or later.
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "ranges" 2
.IX Item "ranges"
Perl does not allow overloading of ranges, so you can neither safely use
ranges with bigint endpoints, nor is the iterator variable a bigint.
.Sp
.Vb 7
\&        use 5.010;
\&        for my $i (12..13) {
\&          for my $j (20..21) {
\&            say $i ** $j;  # produces a floating\-point number,
\&                           # not a big integer
\&          }
\&        }
.Ve
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
This method only works on Perl v5.9.4 or later.
.IP "\fIhex()\fR/\fIoct()\fR" 2
.IX Item "hex()/oct()"
\&\f(CW\*(C`bigint\*(C'\fR overrides these routines with versions that can also handle
big integer values. Under Perl prior to version v5.9.4, however, this
will not happen unless you specifically ask for it with the two
import tags \*(L"hex\*(R" and \*(L"oct\*(R" \- and then it will be global and cannot be
disabled inside a scope with \*(L"no bigint\*(R":
.Sp
.Vb 1
\&        use bigint qw/hex oct/;
\&
\&        print hex("0x1234567890123456");
\&        {
\&                no bigint;
\&                print hex("0x1234567890123456");
\&        }
.Ve
.Sp
The second call to \fIhex()\fR will warn about a non-portable constant.
.Sp
Compare this to:
.Sp
.Vb 1
\&        use bigint;
\&
\&        # will warn only under Perl older than v5.9.4
\&        print hex("0x1234567890123456");
.Ve
.SH "MODULES USED"
.IX Header "MODULES USED"
\&\f(CW\*(C`bigint\*(C'\fR is just a thin wrapper around various modules of the Math::BigInt
family. Think of it as the head of the family, who runs the shop, and orders
the others to do the work.
.PP
The following modules are currently used by bigint:
.PP
.Vb 2
\&        Math::BigInt::Lite      (for speed, and only if it is loadable)
\&        Math::BigInt
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Some cool command line examples to impress the Python crowd ;) You might want
to compare them to the results under \-Mbignum or \-Mbigrat:
.PP
.Vb 9
\&        perl \-Mbigint \-le \*(Aqprint sqrt(33)\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 2*255\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 4.5+2*255\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 3/7 + 5/7 + 8/3\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 123\->is_odd()\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint log(2)\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 2 ** 0.5\*(Aq
\&        perl \-Mbigint=a,65 \-le \*(Aqprint 2 ** 0.2\*(Aq
\&        perl \-Mbignum=a,65,l,GMP \-le \*(Aqprint 7 ** 7777\*(Aq
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Especially bigrat as in \f(CW\*(C`perl \-Mbigrat \-le \*(Aqprint 1/3+1/4\*(Aq\*(C'\fR and
bignum as in \f(CW\*(C`perl \-Mbignum \-le \*(Aqprint sqrt(2)\*(Aq\*(C'\fR.
.PP
Math::BigInt, Math::BigRat and Math::Big as well
as Math::BigInt::Pari and  Math::BigInt::GMP.
.SH "AUTHORS"
.IX Header "AUTHORS"
(C) by Tels <http://bloodgate.com/> in early 2002 \- 2007.
                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bigint5.16.3pm                               0100644 0001750 0001750 00000040713 12566207442 023074  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bigint 3pm"
.TH bigint 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
bigint \- Transparent BigInteger support for Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use bigint;
\&
\&  $x = 2 + 4.5,"\en";                    # BigInt 6
\&  print 2 ** 512,"\en";                  # really is what you think it is
\&  print inf + 42,"\en";                  # inf
\&  print NaN * 7,"\en";                   # NaN
\&  print hex("0x1234567890123490"),"\en"; # Perl v5.9.4 or later
\&
\&  {
\&    no bigint;
\&    print 2 ** 256,"\en";                # a normal Perl scalar now
\&  }
\&
\&  # Note that this will be global:
\&  use bigint qw/hex oct/;
\&  print hex("0x1234567890123490"),"\en";
\&  print oct("01234567890123490"),"\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (including basic math operations) are overloaded. Integer
constants are created as proper BigInts.
.PP
Floating point constants are truncated to integer. All parts and results of
expressions are also truncated.
.PP
Unlike integer, this pragma creates integer constants that are only
limited in their size by the available memory and \s-1CPU\s0 time.
.SS "use integer vs. use bigint"
.IX Subsection "use integer vs. use bigint"
There is one small difference between \f(CW\*(C`use integer\*(C'\fR and \f(CW\*(C`use bigint\*(C'\fR: the
former will not affect assignments to variables and the return value of
some functions. \f(CW\*(C`bigint\*(C'\fR truncates these results to integer too:
.PP
.Vb 8
\&        # perl \-Minteger \-wle \*(Aqprint 3.2\*(Aq
\&        3.2
\&        # perl \-Minteger \-wle \*(Aqprint 3.2 + 0\*(Aq
\&        3
\&        # perl \-Mbigint \-wle \*(Aqprint 3.2\*(Aq
\&        3
\&        # perl \-Mbigint \-wle \*(Aqprint 3.2 + 0\*(Aq
\&        3
\&
\&        # perl \-Mbigint \-wle \*(Aqprint exp(1) + 0\*(Aq
\&        2
\&        # perl \-Mbigint \-wle \*(Aqprint exp(1)\*(Aq
\&        2
\&        # perl \-Minteger \-wle \*(Aqprint exp(1)\*(Aq
\&        2.71828182845905
\&        # perl \-Minteger \-wle \*(Aqprint exp(1) + 0\*(Aq
\&        2
.Ve
.PP
In practice this makes seldom a difference as \fBparts and results\fR of
expressions will be truncated anyway, but this can, for instance, affect the
return value of subroutines:
.PP
.Vb 2
\&    sub three_integer { use integer; return 3.2; } 
\&    sub three_bigint { use bigint; return 3.2; }
\& 
\&    print three_integer(), " ", three_bigint(),"\en";    # prints "3.2 3"
.Ve
.SS "Options"
.IX Subsection "Options"
bigint recognizes some options that can be passed while loading it via use.
The options can (currently) be either a single letter form, or the long form.
The following options exist:
.IP "a or accuracy" 2
.IX Item "a or accuracy"
This sets the accuracy for all math operations. The argument must be greater
than or equal to zero. See Math::BigInt's \fIbround()\fR function for details.
.Sp
.Vb 1
\&        perl \-Mbigint=a,2 \-le \*(Aqprint 12345+1\*(Aq
.Ve
.Sp
Note that setting precision and accuracy at the same time is not possible.
.IP "p or precision" 2
.IX Item "p or precision"
This sets the precision for all math operations. The argument can be any
integer. Negative values mean a fixed number of digits after the dot, and
are <B>ignored</B> since all operations happen in integer space.
A positive value rounds to this digit left from the dot. 0 or 1 mean round to
integer and are ignore like negative values.
.Sp
See Math::BigInt's \fIbfround()\fR function for details.
.Sp
.Vb 1
\&        perl \-Mbignum=p,5 \-le \*(Aqprint 123456789+123\*(Aq
.Ve
.Sp
Note that setting precision and accuracy at the same time is not possible.
.IP "t or trace" 2
.IX Item "t or trace"
This enables a trace mode and is primarily for debugging bigint or
Math::BigInt.
.IP "hex" 2
.IX Item "hex"
Override the built-in \fIhex()\fR method with a version that can handle big
integers. Note that under Perl v5.9.4 or ealier, this will be global
and cannot be disabled with \*(L"no bigint;\*(R".
.IP "oct" 2
.IX Item "oct"
Override the built-in \fIoct()\fR method with a version that can handle big
integers. Note that under Perl v5.9.4 or ealier, this will be global
and cannot be disabled with \*(L"no bigint;\*(R".
.IP "l, lib, try or only" 2
.IX Item "l, lib, try or only"
Load a different math lib, see \*(L"Math Library\*(R".
.Sp
.Vb 3
\&        perl \-Mbigint=lib,GMP \-e \*(Aqprint 2 ** 512\*(Aq
\&        perl \-Mbigint=try,GMP \-e \*(Aqprint 2 ** 512\*(Aq
\&        perl \-Mbigint=only,GMP \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
Currently there is no way to specify more than one library on the command
line. This means the following does not work:
.Sp
.Vb 1
\&        perl \-Mbignum=l,GMP,Pari \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
This will be hopefully fixed soon ;)
.IP "v or version" 2
.IX Item "v or version"
This prints out the name and version of all modules used and then exits.
.Sp
.Vb 1
\&        perl \-Mbigint=v
.Ve
.SS "Math Library"
.IX Subsection "Math Library"
Math with the numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent to saying:
.PP
.Vb 1
\&        use bigint lib => \*(AqCalc\*(Aq;
.Ve
.PP
You can change this by using:
.PP
.Vb 1
\&        use bignum lib => \*(AqGMP\*(Aq;
.Ve
.PP
The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:
.PP
.Vb 1
\&        use bigint lib => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
Using \f(CW\*(C`lib\*(C'\fR warns if none of the specified libraries can be found and
Math::BigInt did fall back to one of the default libraries.
To suppress this warning, use \f(CW\*(C`try\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum try => \*(AqGMP\*(Aq;
.Ve
.PP
If you want the code to die instead of falling back, use \f(CW\*(C`only\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum only => \*(AqGMP\*(Aq;
.Ve
.PP
Please see respective module documentation for further details.
.SS "Internal Format"
.IX Subsection "Internal Format"
The numbers are stored as objects, and their internals might change at anytime,
especially between math operations. The objects also might belong to different
classes, like Math::BigInt, or Math::BigInt::Lite. Mixing them together, even
with normal scalars is not extraordinary, but normal and expected.
.PP
You should not depend on the internal format, all accesses must go through
accessor methods. E.g. looking at \f(CW$x\fR\->{sign} is not a good idea since there
is no guaranty that the object in question has such a hash key, nor is a hash
underneath at all.
.SS "Sign"
.IX Subsection "Sign"
The sign is either '+', '\-', 'NaN', '+inf' or '\-inf'.
You can access it with the \fIsign()\fR method.
.PP
A sign of 'NaN' is used to represent the result when input arguments are not
numbers or as a result of 0/0. '+inf' and '\-inf' represent plus respectively
minus infinity. You will get '+inf' when dividing a positive number by 0, and
\&'\-inf' when dividing any negative number by 0.
.SS "Methods"
.IX Subsection "Methods"
Since all numbers are now objects, you can use all functions that are part of
the BigInt \s-1API\s0. You can only use the \fIbxxx()\fR notation, and not the \fIfxxx()\fR
notation, though.
.IP "\fIinf()\fR" 2
.IX Item "inf()"
A shortcut to return Math::BigInt\->\fIbinf()\fR. Useful because Perl does not always
handle bareword \f(CW\*(C`inf\*(C'\fR properly.
.IP "\fINaN()\fR" 2
.IX Item "NaN()"
A shortcut to return Math::BigInt\->\fIbnan()\fR. Useful because Perl does not always
handle bareword \f(CW\*(C`NaN\*(C'\fR properly.
.IP "e" 2
.IX Item "e"
.Vb 1
\&        # perl \-Mbigint=e \-wle \*(Aqprint e\*(Aq
.Ve
.Sp
Returns Euler's number \f(CW\*(C`e\*(C'\fR, aka \fIexp\fR\|(1). Note that under bigint, this is
truncated to an integer, and hence simple '2'.
.IP "\s-1PI\s0" 2
.IX Item "PI"
.Vb 1
\&        # perl \-Mbigint=PI \-wle \*(Aqprint PI\*(Aq
.Ve
.Sp
Returns \s-1PI\s0. Note that under bigint, this is truncated to an integer, and hence
simple '3'.
.IP "\fIbexp()\fR" 2
.IX Item "bexp()"
.Vb 1
\&        bexp($power,$accuracy);
.Ve
.Sp
Returns Euler's number \f(CW\*(C`e\*(C'\fR raised to the appropriate power, to
the wanted accuracy.
.Sp
Note that under bigint, the result is truncated to an integer.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbigint=bexp \-wle \*(Aqprint bexp(1,80)\*(Aq
.Ve
.IP "\fIbpi()\fR" 2
.IX Item "bpi()"
.Vb 1
\&        bpi($accuracy);
.Ve
.Sp
Returns \s-1PI\s0 to the wanted accuracy. Note that under bigint, this is truncated
to an integer, and hence simple '3'.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbigint=bpi \-wle \*(Aqprint bpi(80)\*(Aq
.Ve
.IP "\fIupgrade()\fR" 2
.IX Item "upgrade()"
Return the class that numbers are upgraded to, is in fact returning
\&\f(CW$Math::BigInt::upgrade\fR.
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
.Vb 1
\&        use bigint;
\&
\&        print "in effect\en" if bigint::in_effect;       # true
\&        {
\&          no bigint;
\&          print "in effect\en" if bigint::in_effect;     # false
\&        }
.Ve
.Sp
Returns true or false if \f(CW\*(C`bigint\*(C'\fR is in effect in the current scope.
.Sp
This method only works on Perl v5.9.4 or later.
.SS "\s-1MATH\s0 \s-1LIBRARY\s0"
.IX Subsection "MATH LIBRARY"
Math with the numbers is done (by default) by a module called
.SS "Caveat"
.IX Subsection "Caveat"
But a warning is in order. When using the following to make a copy of a number,
only a shallow copy will be made.
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $x = $y = 7;
.Ve
.PP
Using the copy or the original with overloaded math is okay, e.g. the
following work:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x + 1, " ", $y,"\en";     # prints 10 9
.Ve
.PP
but calling any method that modifies the number directly will result in
\&\fBboth\fR the original and the copy being destroyed:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x\->badd(1), " ", $y,"\en";        # prints 10 10
\&        
\&        $x = 9; $y = $x;
\&        print $x\->binc(1), " ", $y,"\en";        # prints 10 10
\&        
\&        $x = 9; $y = $x;
\&        print $x\->bmul(2), " ", $y,"\en";        # prints 18 18
.Ve
.PP
Using methods that do not modify, but testthe contents works:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $z = 9 if $x\->is_zero();                # works fine
.Ve
.PP
See the documentation about the copy constructor and \f(CW\*(C`=\*(C'\fR in overload, as
well as the documentation in BigInt for further details.
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
This method only works on Perl v5.9.4 or later.
.IP "\fIhex()\fR/\fIoct()\fR" 2
.IX Item "hex()/oct()"
\&\f(CW\*(C`bigint\*(C'\fR overrides these routines with versions that can also handle
big integer values. Under Perl prior to version v5.9.4, however, this
will not happen unless you specifically ask for it with the two
import tags \*(L"hex\*(R" and \*(L"oct\*(R" \- and then it will be global and cannot be
disabled inside a scope with \*(L"no bigint\*(R":
.Sp
.Vb 1
\&        use bigint qw/hex oct/;
\&
\&        print hex("0x1234567890123456");
\&        {
\&                no bigint;
\&                print hex("0x1234567890123456");
\&        }
.Ve
.Sp
The second call to \fIhex()\fR will warn about a non-portable constant.
.Sp
Compare this to:
.Sp
.Vb 1
\&        use bigint;
\&
\&        # will warn only under Perl older than v5.9.4
\&        print hex("0x1234567890123456");
.Ve
.SH "MODULES USED"
.IX Header "MODULES USED"
\&\f(CW\*(C`bigint\*(C'\fR is just a thin wrapper around various modules of the Math::BigInt
family. Think of it as the head of the family, who runs the shop, and orders
the others to do the work.
.PP
The following modules are currently used by bigint:
.PP
.Vb 2
\&        Math::BigInt::Lite      (for speed, and only if it is loadable)
\&        Math::BigInt
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Some cool command line examples to impress the Python crowd ;) You might want
to compare them to the results under \-Mbignum or \-Mbigrat:
.PP
.Vb 9
\&        perl \-Mbigint \-le \*(Aqprint sqrt(33)\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 2*255\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 4.5+2*255\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 3/7 + 5/7 + 8/3\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 123\->is_odd()\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint log(2)\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 2 ** 0.5\*(Aq
\&        perl \-Mbigint=a,65 \-le \*(Aqprint 2 ** 0.2\*(Aq
\&        perl \-Mbignum=a,65,l,GMP \-le \*(Aqprint 7 ** 7777\*(Aq
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Especially bigrat as in \f(CW\*(C`perl \-Mbigrat \-le \*(Aqprint 1/3+1/4\*(Aq\*(C'\fR and
bignum as in \f(CW\*(C`perl \-Mbignum \-le \*(Aqprint sqrt(2)\*(Aq\*(C'\fR.
.PP
Math::BigInt, Math::BigRat and Math::Big as well
as Math::BigInt::BitVect, Math::BigInt::Pari and  Math::BigInt::GMP.
.SH "AUTHORS"
.IX Header "AUTHORS"
(C) by Tels <http://bloodgate.com/> in early 2002 \- 2007.
                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bigint5.18.3pm                               0100644 0001750 0001750 00000042244 12566207465 023104  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bigint 3pm"
.TH bigint 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
bigint \- Transparent BigInteger support for Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use bigint;
\&
\&  $x = 2 + 4.5,"\en";                    # BigInt 6
\&  print 2 ** 512,"\en";                  # really is what you think it is
\&  print inf + 42,"\en";                  # inf
\&  print NaN * 7,"\en";                   # NaN
\&  print hex("0x1234567890123490"),"\en"; # Perl v5.10.0 or later
\&
\&  {
\&    no bigint;
\&    print 2 ** 256,"\en";                # a normal Perl scalar now
\&  }
\&
\&  # Import into current package:
\&  use bigint qw/hex oct/;
\&  print hex("0x1234567890123490"),"\en";
\&  print oct("01234567890123490"),"\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (including basic math operations) except the range operator \f(CW\*(C`..\*(C'\fR
are overloaded. Integer constants are created as proper BigInts.
.PP
Floating point constants are truncated to integer. All parts and results of
expressions are also truncated.
.PP
Unlike integer, this pragma creates integer constants that are only
limited in their size by the available memory and \s-1CPU\s0 time.
.SS "use integer vs. use bigint"
.IX Subsection "use integer vs. use bigint"
There is one small difference between \f(CW\*(C`use integer\*(C'\fR and \f(CW\*(C`use bigint\*(C'\fR: the
former will not affect assignments to variables and the return value of
some functions. \f(CW\*(C`bigint\*(C'\fR truncates these results to integer too:
.PP
.Vb 8
\&        # perl \-Minteger \-wle \*(Aqprint 3.2\*(Aq
\&        3.2
\&        # perl \-Minteger \-wle \*(Aqprint 3.2 + 0\*(Aq
\&        3
\&        # perl \-Mbigint \-wle \*(Aqprint 3.2\*(Aq
\&        3
\&        # perl \-Mbigint \-wle \*(Aqprint 3.2 + 0\*(Aq
\&        3
\&
\&        # perl \-Mbigint \-wle \*(Aqprint exp(1) + 0\*(Aq
\&        2
\&        # perl \-Mbigint \-wle \*(Aqprint exp(1)\*(Aq
\&        2
\&        # perl \-Minteger \-wle \*(Aqprint exp(1)\*(Aq
\&        2.71828182845905
\&        # perl \-Minteger \-wle \*(Aqprint exp(1) + 0\*(Aq
\&        2
.Ve
.PP
In practice this makes seldom a difference as \fBparts and results\fR of
expressions will be truncated anyway, but this can, for instance, affect the
return value of subroutines:
.PP
.Vb 2
\&    sub three_integer { use integer; return 3.2; } 
\&    sub three_bigint { use bigint; return 3.2; }
\&
\&    print three_integer(), " ", three_bigint(),"\en";    # prints "3.2 3"
.Ve
.SS "Options"
.IX Subsection "Options"
bigint recognizes some options that can be passed while loading it via use.
The options can (currently) be either a single letter form, or the long form.
The following options exist:
.IP "a or accuracy" 2
.IX Item "a or accuracy"
This sets the accuracy for all math operations. The argument must be greater
than or equal to zero. See Math::BigInt's \fIbround()\fR function for details.
.Sp
.Vb 1
\&        perl \-Mbigint=a,2 \-le \*(Aqprint 12345+1\*(Aq
.Ve
.Sp
Note that setting precision and accuracy at the same time is not possible.
.IP "p or precision" 2
.IX Item "p or precision"
This sets the precision for all math operations. The argument can be any
integer. Negative values mean a fixed number of digits after the dot, and
are <B>ignored</B> since all operations happen in integer space.
A positive value rounds to this digit left from the dot. 0 or 1 mean round to
integer and are ignore like negative values.
.Sp
See Math::BigInt's \fIbfround()\fR function for details.
.Sp
.Vb 1
\&        perl \-Mbignum=p,5 \-le \*(Aqprint 123456789+123\*(Aq
.Ve
.Sp
Note that setting precision and accuracy at the same time is not possible.
.IP "t or trace" 2
.IX Item "t or trace"
This enables a trace mode and is primarily for debugging bigint or
Math::BigInt.
.IP "hex" 2
.IX Item "hex"
Override the built-in \fIhex()\fR method with a version that can handle big
integers. This overrides it by exporting it to the current package. Under
Perl v5.10.0 and higher, this is not so necessary, as \fIhex()\fR is lexically
overridden in the current scope whenever the bigint pragma is active.
.IP "oct" 2
.IX Item "oct"
Override the built-in \fIoct()\fR method with a version that can handle big
integers. This overrides it by exporting it to the current package. Under
Perl v5.10.0 and higher, this is not so necessary, as \fIoct()\fR is lexically
overridden in the current scope whenever the bigint pragma is active.
.IP "l, lib, try or only" 2
.IX Item "l, lib, try or only"
Load a different math lib, see \*(L"Math Library\*(R".
.Sp
.Vb 3
\&        perl \-Mbigint=lib,GMP \-e \*(Aqprint 2 ** 512\*(Aq
\&        perl \-Mbigint=try,GMP \-e \*(Aqprint 2 ** 512\*(Aq
\&        perl \-Mbigint=only,GMP \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
Currently there is no way to specify more than one library on the command
line. This means the following does not work:
.Sp
.Vb 1
\&        perl \-Mbignum=l,GMP,Pari \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
This will be hopefully fixed soon ;)
.IP "v or version" 2
.IX Item "v or version"
This prints out the name and version of all modules used and then exits.
.Sp
.Vb 1
\&        perl \-Mbigint=v
.Ve
.SS "Math Library"
.IX Subsection "Math Library"
Math with the numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent to saying:
.PP
.Vb 1
\&        use bigint lib => \*(AqCalc\*(Aq;
.Ve
.PP
You can change this by using:
.PP
.Vb 1
\&        use bignum lib => \*(AqGMP\*(Aq;
.Ve
.PP
The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:
.PP
.Vb 1
\&        use bigint lib => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
Using \f(CW\*(C`lib\*(C'\fR warns if none of the specified libraries can be found and
Math::BigInt did fall back to one of the default libraries.
To suppress this warning, use \f(CW\*(C`try\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum try => \*(AqGMP\*(Aq;
.Ve
.PP
If you want the code to die instead of falling back, use \f(CW\*(C`only\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum only => \*(AqGMP\*(Aq;
.Ve
.PP
Please see respective module documentation for further details.
.SS "Internal Format"
.IX Subsection "Internal Format"
The numbers are stored as objects, and their internals might change at anytime,
especially between math operations. The objects also might belong to different
classes, like Math::BigInt, or Math::BigInt::Lite. Mixing them together, even
with normal scalars is not extraordinary, but normal and expected.
.PP
You should not depend on the internal format, all accesses must go through
accessor methods. E.g. looking at \f(CW$x\fR\->{sign} is not a good idea since there
is no guaranty that the object in question has such a hash key, nor is a hash
underneath at all.
.SS "Sign"
.IX Subsection "Sign"
The sign is either '+', '\-', 'NaN', '+inf' or '\-inf'.
You can access it with the \fIsign()\fR method.
.PP
A sign of 'NaN' is used to represent the result when input arguments are not
numbers or as a result of 0/0. '+inf' and '\-inf' represent plus respectively
minus infinity. You will get '+inf' when dividing a positive number by 0, and
\&'\-inf' when dividing any negative number by 0.
.SS "Method calls"
.IX Subsection "Method calls"
Since all numbers are now objects, you can use all functions that are part of
the BigInt \s-1API.\s0 You can only use the \fIbxxx()\fR notation, and not the \fIfxxx()\fR
notation, though.
.PP
But a warning is in order. When using the following to make a copy of a number,
only a shallow copy will be made.
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $x = $y = 7;
.Ve
.PP
Using the copy or the original with overloaded math is okay, e.g. the
following work:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x + 1, " ", $y,"\en";     # prints 10 9
.Ve
.PP
but calling any method that modifies the number directly will result in
\&\fBboth\fR the original and the copy being destroyed:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x\->badd(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->binc(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->bmul(2), " ", $y,"\en";        # prints 18 18
.Ve
.PP
Using methods that do not modify, but testthe contents works:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $z = 9 if $x\->is_zero();                # works fine
.Ve
.PP
See the documentation about the copy constructor and \f(CW\*(C`=\*(C'\fR in overload, as
well as the documentation in BigInt for further details.
.SS "Methods"
.IX Subsection "Methods"
.IP "\fIinf()\fR" 2
.IX Item "inf()"
A shortcut to return Math::BigInt\->\fIbinf()\fR. Useful because Perl does not always
handle bareword \f(CW\*(C`inf\*(C'\fR properly.
.IP "\fINaN()\fR" 2
.IX Item "NaN()"
A shortcut to return Math::BigInt\->\fIbnan()\fR. Useful because Perl does not always
handle bareword \f(CW\*(C`NaN\*(C'\fR properly.
.IP "e" 2
.IX Item "e"
.Vb 1
\&        # perl \-Mbigint=e \-wle \*(Aqprint e\*(Aq
.Ve
.Sp
Returns Euler's number \f(CW\*(C`e\*(C'\fR, aka \fIexp\fR\|(1). Note that under bigint, this is
truncated to an integer, and hence simple '2'.
.IP "\s-1PI\s0" 2
.IX Item "PI"
.Vb 1
\&        # perl \-Mbigint=PI \-wle \*(Aqprint PI\*(Aq
.Ve
.Sp
Returns \s-1PI.\s0 Note that under bigint, this is truncated to an integer, and hence
simple '3'.
.IP "\fIbexp()\fR" 2
.IX Item "bexp()"
.Vb 1
\&        bexp($power,$accuracy);
.Ve
.Sp
Returns Euler's number \f(CW\*(C`e\*(C'\fR raised to the appropriate power, to
the wanted accuracy.
.Sp
Note that under bigint, the result is truncated to an integer.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbigint=bexp \-wle \*(Aqprint bexp(1,80)\*(Aq
.Ve
.IP "\fIbpi()\fR" 2
.IX Item "bpi()"
.Vb 1
\&        bpi($accuracy);
.Ve
.Sp
Returns \s-1PI\s0 to the wanted accuracy. Note that under bigint, this is truncated
to an integer, and hence simple '3'.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbigint=bpi \-wle \*(Aqprint bpi(80)\*(Aq
.Ve
.IP "\fIupgrade()\fR" 2
.IX Item "upgrade()"
Return the class that numbers are upgraded to, is in fact returning
\&\f(CW$Math::BigInt::upgrade\fR.
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
.Vb 1
\&        use bigint;
\&
\&        print "in effect\en" if bigint::in_effect;       # true
\&        {
\&          no bigint;
\&          print "in effect\en" if bigint::in_effect;     # false
\&        }
.Ve
.Sp
Returns true or false if \f(CW\*(C`bigint\*(C'\fR is in effect in the current scope.
.Sp
This method only works on Perl v5.9.4 or later.
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "ranges" 2
.IX Item "ranges"
Perl does not allow overloading of ranges, so you can neither safely use
ranges with bigint endpoints, nor is the iterator variable a bigint.
.Sp
.Vb 7
\&        use 5.010;
\&        for my $i (12..13) {
\&          for my $j (20..21) {
\&            say $i ** $j;  # produces a floating\-point number,
\&                           # not a big integer
\&          }
\&        }
.Ve
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
This method only works on Perl v5.9.4 or later.
.IP "\fIhex()\fR/\fIoct()\fR" 2
.IX Item "hex()/oct()"
\&\f(CW\*(C`bigint\*(C'\fR overrides these routines with versions that can also handle
big integer values. Under Perl prior to version v5.9.4, however, this
will not happen unless you specifically ask for it with the two
import tags \*(L"hex\*(R" and \*(L"oct\*(R" \- and then it will be global and cannot be
disabled inside a scope with \*(L"no bigint\*(R":
.Sp
.Vb 1
\&        use bigint qw/hex oct/;
\&
\&        print hex("0x1234567890123456");
\&        {
\&                no bigint;
\&                print hex("0x1234567890123456");
\&        }
.Ve
.Sp
The second call to \fIhex()\fR will warn about a non-portable constant.
.Sp
Compare this to:
.Sp
.Vb 1
\&        use bigint;
\&
\&        # will warn only under Perl older than v5.9.4
\&        print hex("0x1234567890123456");
.Ve
.SH "MODULES USED"
.IX Header "MODULES USED"
\&\f(CW\*(C`bigint\*(C'\fR is just a thin wrapper around various modules of the Math::BigInt
family. Think of it as the head of the family, who runs the shop, and orders
the others to do the work.
.PP
The following modules are currently used by bigint:
.PP
.Vb 2
\&        Math::BigInt::Lite      (for speed, and only if it is loadable)
\&        Math::BigInt
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Some cool command line examples to impress the Python crowd ;) You might want
to compare them to the results under \-Mbignum or \-Mbigrat:
.PP
.Vb 9
\&        perl \-Mbigint \-le \*(Aqprint sqrt(33)\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 2*255\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 4.5+2*255\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 3/7 + 5/7 + 8/3\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 123\->is_odd()\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint log(2)\*(Aq
\&        perl \-Mbigint \-le \*(Aqprint 2 ** 0.5\*(Aq
\&        perl \-Mbigint=a,65 \-le \*(Aqprint 2 ** 0.2\*(Aq
\&        perl \-Mbignum=a,65,l,GMP \-le \*(Aqprint 7 ** 7777\*(Aq
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Especially bigrat as in \f(CW\*(C`perl \-Mbigrat \-le \*(Aqprint 1/3+1/4\*(Aq\*(C'\fR and
bignum as in \f(CW\*(C`perl \-Mbignum \-le \*(Aqprint sqrt(2)\*(Aq\*(C'\fR.
.PP
Math::BigInt, Math::BigRat and Math::Big as well
as Math::BigInt::Pari and  Math::BigInt::GMP.
.SH "AUTHORS"
.IX Header "AUTHORS"
(C) by Tels <http://bloodgate.com/> in early 2002 \- 2007.
                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bignum.3pm                                   0100644 0001750 0001750 00000045321 12566207465 022574  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bignum 3pm"
.TH bignum 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
bignum \- Transparent BigNumber support for Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use bignum;
\&
\&  $x = 2 + 4.5,"\en";                    # BigFloat 6.5
\&  print 2 ** 512 * 0.1,"\en";            # really is what you think it is
\&  print inf * inf,"\en";                 # prints inf
\&  print NaN * 3,"\en";                   # prints NaN
\&
\&  {
\&    no bignum;
\&    print 2 ** 256,"\en";                # a normal Perl scalar now
\&  }
\&
\&  # for older Perls, import into current package:
\&  use bignum qw/hex oct/;
\&  print hex("0x1234567890123490"),"\en";
\&  print oct("01234567890123490"),"\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (including basic math operations) are overloaded. Integer and
floating-point constants are created as proper BigInts or BigFloats,
respectively.
.PP
If you do
.PP
.Vb 1
\&        use bignum;
.Ve
.PP
at the top of your script, Math::BigFloat and Math::BigInt will be loaded
and any constant number will be converted to an object (Math::BigFloat for
floats like 3.1415 and Math::BigInt for integers like 1234).
.PP
So, the following line:
.PP
.Vb 1
\&        $x = 1234;
.Ve
.PP
creates actually a Math::BigInt and stores a reference to in \f(CW$x\fR.
This happens transparently and behind your back, so to speak.
.PP
You can see this with the following:
.PP
.Vb 1
\&        perl \-Mbignum \-le \*(Aqprint ref(1234)\*(Aq
.Ve
.PP
Don't worry if it says Math::BigInt::Lite, bignum and friends will use Lite
if it is installed since it is faster for some operations. It will be
automatically upgraded to BigInt whenever necessary:
.PP
.Vb 1
\&        perl \-Mbignum \-le \*(Aqprint ref(2**255)\*(Aq
.Ve
.PP
This also means it is a bad idea to check for some specific package, since
the actual contents of \f(CW$x\fR might be something unexpected. Due to the
transparent way of bignum \f(CW\*(C`ref()\*(C'\fR should not be necessary, anyway.
.PP
Since Math::BigInt and BigFloat also overload the normal math operations,
the following line will still work:
.PP
.Vb 1
\&        perl \-Mbignum \-le \*(Aqprint ref(1234+1234)\*(Aq
.Ve
.PP
Since numbers are actually objects, you can call all the usual methods from
BigInt/BigFloat on them. This even works to some extent on expressions:
.PP
.Vb 4
\&        perl \-Mbignum \-le \*(Aq$x = 1234; print $x\->bdec()\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 1234\->copy()\->binc();\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 1234\->copy()\->binc\->badd(6);\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint +(1234)\->copy()\->binc()\*(Aq
.Ve
.PP
(Note that print doesn't do what you expect if the expression starts with
\&'(' hence the \f(CW\*(C`+\*(C'\fR)
.PP
You can even chain the operations together as usual:
.PP
.Vb 2
\&        perl \-Mbignum \-le \*(Aqprint 1234\->copy()\->binc\->badd(6);\*(Aq
\&        1241
.Ve
.PP
Under bignum (or bigint or bigrat), Perl will \*(L"upgrade\*(R" the numbers
appropriately. This means that:
.PP
.Vb 2
\&        perl \-Mbignum \-le \*(Aqprint 1234+4.5\*(Aq
\&        1238.5
.Ve
.PP
will work correctly. These mixed cases don't do always work when using
Math::BigInt or Math::BigFloat alone, or at least not in the way normal Perl
scalars work.
.PP
If you do want to work with large integers like under \f(CW\*(C`use integer;\*(C'\fR, try
\&\f(CW\*(C`use bigint;\*(C'\fR:
.PP
.Vb 2
\&        perl \-Mbigint \-le \*(Aqprint 1234.5+4.5\*(Aq
\&        1238
.Ve
.PP
There is also \f(CW\*(C`use bigrat;\*(C'\fR which gives you big rationals:
.PP
.Vb 2
\&        perl \-Mbigrat \-le \*(Aqprint 1234+4.1\*(Aq
\&        12381/10
.Ve
.PP
The entire upgrading/downgrading is still experimental and might not work
as you expect or may even have bugs. You might get errors like this:
.PP
.Vb 2
\&        Can\*(Aqt use an undefined value as an ARRAY reference at
\&        /usr/local/lib/perl5/5.8.0/Math/BigInt/Calc.pm line 864
.Ve
.PP
This means somewhere a routine got a BigFloat/Lite but expected a BigInt (or
vice versa) and the upgrade/downgrad path was missing. This is a bug, please
report it so that we can fix it.
.PP
You might consider using just Math::BigInt or Math::BigFloat, since they
allow you finer control over what get's done in which module/space. For
instance, simple loop counters will be Math::BigInts under \f(CW\*(C`use bignum;\*(C'\fR and
this is slower than keeping them as Perl scalars:
.PP
.Vb 1
\&    perl \-Mbignum \-le \*(Aqfor ($i = 0; $i < 10; $i++) { print ref($i); }\*(Aq
.Ve
.PP
Please note the following does not work as expected (prints nothing), since
overloading of '..' is not yet possible in Perl (as of v5.8.0):
.PP
.Vb 1
\&    perl \-Mbignum \-le \*(Aqfor (1..2) { print ref($_); }\*(Aq
.Ve
.SS "Options"
.IX Subsection "Options"
bignum recognizes some options that can be passed while loading it via use.
The options can (currently) be either a single letter form, or the long form.
The following options exist:
.IP "a or accuracy" 2
.IX Item "a or accuracy"
This sets the accuracy for all math operations. The argument must be greater
than or equal to zero. See Math::BigInt's \fIbround()\fR function for details.
.Sp
.Vb 1
\&        perl \-Mbignum=a,50 \-le \*(Aqprint sqrt(20)\*(Aq
.Ve
.Sp
Note that setting precision and accuracy at the same time is not possible.
.IP "p or precision" 2
.IX Item "p or precision"
This sets the precision for all math operations. The argument can be any
integer. Negative values mean a fixed number of digits after the dot, while
a positive value rounds to this digit left from the dot. 0 or 1 mean round to
integer. See Math::BigInt's \fIbfround()\fR function for details.
.Sp
.Vb 1
\&        perl \-Mbignum=p,\-50 \-le \*(Aqprint sqrt(20)\*(Aq
.Ve
.Sp
Note that setting precision and accuracy at the same time is not possible.
.IP "t or trace" 2
.IX Item "t or trace"
This enables a trace mode and is primarily for debugging bignum or
Math::BigInt/Math::BigFloat.
.IP "l or lib" 2
.IX Item "l or lib"
Load a different math lib, see \*(L"Math Library\*(R".
.Sp
.Vb 1
\&        perl \-Mbignum=l,GMP \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
Currently there is no way to specify more than one library on the command
line. This means the following does not work:
.Sp
.Vb 1
\&        perl \-Mbignum=l,GMP,Pari \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
This will be hopefully fixed soon ;)
.IP "hex" 2
.IX Item "hex"
Override the built-in \fIhex()\fR method with a version that can handle big
numbers. This overrides it by exporting it to the current package. Under
Perl v5.10.0 and higher, this is not so necessary, as \fIhex()\fR is lexically
overridden in the current scope whenever the bignum pragma is active.
.IP "oct" 2
.IX Item "oct"
Override the built-in \fIoct()\fR method with a version that can handle big
numbers. This overrides it by exporting it to the current package. Under
Perl v5.10.0 and higher, this is not so necessary, as \fIoct()\fR is lexically
overridden in the current scope whenever the bigint pragma is active.
.IP "v or version" 2
.IX Item "v or version"
This prints out the name and version of all modules used and then exits.
.Sp
.Vb 1
\&        perl \-Mbignum=v
.Ve
.SS "Methods"
.IX Subsection "Methods"
Beside \fIimport()\fR and \s-1\fIAUTOLOAD\s0()\fR there are only a few other methods.
.PP
Since all numbers are now objects, you can use all functions that are part of
the BigInt or BigFloat \s-1API.\s0 It is wise to use only the \fIbxxx()\fR notation, and not
the \fIfxxx()\fR notation, though. This makes it possible that the underlying object
might morph into a different class than BigFloat.
.SS "Caveats"
.IX Subsection "Caveats"
But a warning is in order. When using the following to make a copy of a number,
only a shallow copy will be made.
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $x = $y = 7;
.Ve
.PP
If you want to make a real copy, use the following:
.PP
.Vb 1
\&        $y = $x\->copy();
.Ve
.PP
Using the copy or the original with overloaded math is okay, e.g. the
following work:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x + 1, " ", $y,"\en";     # prints 10 9
.Ve
.PP
but calling any method that modifies the number directly will result in
\&\fBboth\fR the original and the copy being destroyed:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x\->badd(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->binc(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->bmul(2), " ", $y,"\en";        # prints 18 18
.Ve
.PP
Using methods that do not modify, but test the contents works:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $z = 9 if $x\->is_zero();                # works fine
.Ve
.PP
See the documentation about the copy constructor and \f(CW\*(C`=\*(C'\fR in overload, as
well as the documentation in BigInt for further details.
.IP "\fIinf()\fR" 2
.IX Item "inf()"
A shortcut to return Math::BigInt\->\fIbinf()\fR. Useful because Perl does not always
handle bareword \f(CW\*(C`inf\*(C'\fR properly.
.IP "\fINaN()\fR" 2
.IX Item "NaN()"
A shortcut to return Math::BigInt\->\fIbnan()\fR. Useful because Perl does not always
handle bareword \f(CW\*(C`NaN\*(C'\fR properly.
.IP "e" 2
.IX Item "e"
.Vb 1
\&        # perl \-Mbignum=e \-wle \*(Aqprint e\*(Aq
.Ve
.Sp
Returns Euler's number \f(CW\*(C`e\*(C'\fR, aka \fIexp\fR\|(1).
.IP "\s-1\fIPI\s0()\fR" 2
.IX Item "PI()"
.Vb 1
\&        # perl \-Mbignum=PI \-wle \*(Aqprint PI\*(Aq
.Ve
.Sp
Returns \s-1PI.\s0
.IP "\fIbexp()\fR" 2
.IX Item "bexp()"
.Vb 1
\&        bexp($power,$accuracy);
.Ve
.Sp
Returns Euler's number \f(CW\*(C`e\*(C'\fR raised to the appropriate power, to
the wanted accuracy.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbignum=bexp \-wle \*(Aqprint bexp(1,80)\*(Aq
.Ve
.IP "\fIbpi()\fR" 2
.IX Item "bpi()"
.Vb 1
\&        bpi($accuracy);
.Ve
.Sp
Returns \s-1PI\s0 to the wanted accuracy.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbignum=bpi \-wle \*(Aqprint bpi(80)\*(Aq
.Ve
.IP "\fIupgrade()\fR" 2
.IX Item "upgrade()"
Return the class that numbers are upgraded to, is in fact returning
\&\f(CW$Math::BigInt::upgrade\fR.
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
.Vb 1
\&        use bignum;
\&
\&        print "in effect\en" if bignum::in_effect;       # true
\&        {
\&          no bignum;
\&          print "in effect\en" if bignum::in_effect;     # false
\&        }
.Ve
.Sp
Returns true or false if \f(CW\*(C`bignum\*(C'\fR is in effect in the current scope.
.Sp
This method only works on Perl v5.9.4 or later.
.SS "Math Library"
.IX Subsection "Math Library"
Math with the numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent to saying:
.PP
.Vb 1
\&        use bignum lib => \*(AqCalc\*(Aq;
.Ve
.PP
You can change this by using:
.PP
.Vb 1
\&        use bignum lib => \*(AqGMP\*(Aq;
.Ve
.PP
The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:
.PP
.Vb 1
\&        use bignum lib => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
Please see respective module documentation for further details.
.PP
Using \f(CW\*(C`lib\*(C'\fR warns if none of the specified libraries can be found and
Math::BigInt did fall back to one of the default libraries.
To suppress this warning, use \f(CW\*(C`try\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum try => \*(AqGMP\*(Aq;
.Ve
.PP
If you want the code to die instead of falling back, use \f(CW\*(C`only\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum only => \*(AqGMP\*(Aq;
.Ve
.SS "\s-1INTERNAL FORMAT\s0"
.IX Subsection "INTERNAL FORMAT"
The numbers are stored as objects, and their internals might change at anytime,
especially between math operations. The objects also might belong to different
classes, like Math::BigInt, or Math::BigFLoat. Mixing them together, even
with normal scalars is not extraordinary, but normal and expected.
.PP
You should not depend on the internal format, all accesses must go through
accessor methods. E.g. looking at \f(CW$x\fR\->{sign} is not a bright idea since there
is no guaranty that the object in question has such a hashkey, nor is a hash
underneath at all.
.SS "\s-1SIGN\s0"
.IX Subsection "SIGN"
The sign is either '+', '\-', 'NaN', '+inf' or '\-inf' and stored separately.
You can access it with the \fIsign()\fR method.
.PP
A sign of 'NaN' is used to represent the result when input arguments are not
numbers or as a result of 0/0. '+inf' and '\-inf' represent plus respectively
minus infinity. You will get '+inf' when dividing a positive number by 0, and
\&'\-inf' when dividing any negative number by 0.
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
This method only works on Perl v5.9.4 or later.
.IP "\fIhex()\fR/\fIoct()\fR" 2
.IX Item "hex()/oct()"
\&\f(CW\*(C`bigint\*(C'\fR overrides these routines with versions that can also handle
big integer values. Under Perl prior to version v5.9.4, however, this
will not happen unless you specifically ask for it with the two
import tags \*(L"hex\*(R" and \*(L"oct\*(R" \- and then it will be global and cannot be
disabled inside a scope with \*(L"no bigint\*(R":
.Sp
.Vb 1
\&        use bigint qw/hex oct/;
\&
\&        print hex("0x1234567890123456");
\&        {
\&                no bigint;
\&                print hex("0x1234567890123456");
\&        }
.Ve
.Sp
The second call to \fIhex()\fR will warn about a non-portable constant.
.Sp
Compare this to:
.Sp
.Vb 1
\&        use bigint;
\&
\&        # will warn only under older than v5.9.4
\&        print hex("0x1234567890123456");
.Ve
.SH "MODULES USED"
.IX Header "MODULES USED"
\&\f(CW\*(C`bignum\*(C'\fR is just a thin wrapper around various modules of the Math::BigInt
family. Think of it as the head of the family, who runs the shop, and orders
the others to do the work.
.PP
The following modules are currently used by bignum:
.PP
.Vb 3
\&        Math::BigInt::Lite      (for speed, and only if it is loadable)
\&        Math::BigInt
\&        Math::BigFloat
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Some cool command line examples to impress the Python crowd ;)
.PP
.Vb 10
\&        perl \-Mbignum \-le \*(Aqprint sqrt(33)\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 2*255\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 4.5+2*255\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 3/7 + 5/7 + 8/3\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 123\->is_odd()\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint log(2)\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint exp(1)\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 2 ** 0.5\*(Aq
\&        perl \-Mbignum=a,65 \-le \*(Aqprint 2 ** 0.2\*(Aq
\&        perl \-Mbignum=a,65,l,GMP \-le \*(Aqprint 7 ** 7777\*(Aq
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Especially bigrat as in \f(CW\*(C`perl \-Mbigrat \-le \*(Aqprint 1/3+1/4\*(Aq\*(C'\fR.
.PP
Math::BigFloat, Math::BigInt, Math::BigRat and Math::Big as well
as Math::BigInt::Pari and  Math::BigInt::GMP.
.SH "AUTHORS"
.IX Header "AUTHORS"
(C) by Tels <http://bloodgate.com/> in early 2002 \- 2007.
                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bignum5.16.3pm                               0100644 0001750 0001750 00000044524 12566207442 023105  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bignum 3pm"
.TH bignum 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
bignum \- Transparent BigNumber support for Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use bignum;
\&
\&  $x = 2 + 4.5,"\en";                    # BigFloat 6.5
\&  print 2 ** 512 * 0.1,"\en";            # really is what you think it is
\&  print inf * inf,"\en";                 # prints inf
\&  print NaN * 3,"\en";                   # prints NaN
\&
\&  {
\&    no bignum;
\&    print 2 ** 256,"\en";                # a normal Perl scalar now
\&  }
\&
\&  # for older Perls, note that this will be global:
\&  use bignum qw/hex oct/;
\&  print hex("0x1234567890123490"),"\en";
\&  print oct("01234567890123490"),"\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (including basic math operations) are overloaded. Integer and
floating-point constants are created as proper BigInts or BigFloats,
respectively.
.PP
If you do
.PP
.Vb 1
\&        use bignum;
.Ve
.PP
at the top of your script, Math::BigFloat and Math::BigInt will be loaded
and any constant number will be converted to an object (Math::BigFloat for
floats like 3.1415 and Math::BigInt for integers like 1234).
.PP
So, the following line:
.PP
.Vb 1
\&        $x = 1234;
.Ve
.PP
creates actually a Math::BigInt and stores a reference to in \f(CW$x\fR.
This happens transparently and behind your back, so to speak.
.PP
You can see this with the following:
.PP
.Vb 1
\&        perl \-Mbignum \-le \*(Aqprint ref(1234)\*(Aq
.Ve
.PP
Don't worry if it says Math::BigInt::Lite, bignum and friends will use Lite
if it is installed since it is faster for some operations. It will be
automatically upgraded to BigInt whenever necessary:
.PP
.Vb 1
\&        perl \-Mbignum \-le \*(Aqprint ref(2**255)\*(Aq
.Ve
.PP
This also means it is a bad idea to check for some specific package, since
the actual contents of \f(CW$x\fR might be something unexpected. Due to the
transparent way of bignum \f(CW\*(C`ref()\*(C'\fR should not be necessary, anyway.
.PP
Since Math::BigInt and BigFloat also overload the normal math operations,
the following line will still work:
.PP
.Vb 1
\&        perl \-Mbignum \-le \*(Aqprint ref(1234+1234)\*(Aq
.Ve
.PP
Since numbers are actually objects, you can call all the usual methods from
BigInt/BigFloat on them. This even works to some extent on expressions:
.PP
.Vb 4
\&        perl \-Mbignum \-le \*(Aq$x = 1234; print $x\->bdec()\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 1234\->copy()\->binc();\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 1234\->copy()\->binc\->badd(6);\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint +(1234)\->copy()\->binc()\*(Aq
.Ve
.PP
(Note that print doesn't do what you expect if the expression starts with
\&'(' hence the \f(CW\*(C`+\*(C'\fR)
.PP
You can even chain the operations together as usual:
.PP
.Vb 2
\&        perl \-Mbignum \-le \*(Aqprint 1234\->copy()\->binc\->badd(6);\*(Aq
\&        1241
.Ve
.PP
Under bignum (or bigint or bigrat), Perl will \*(L"upgrade\*(R" the numbers
appropriately. This means that:
.PP
.Vb 2
\&        perl \-Mbignum \-le \*(Aqprint 1234+4.5\*(Aq
\&        1238.5
.Ve
.PP
will work correctly. These mixed cases don't do always work when using
Math::BigInt or Math::BigFloat alone, or at least not in the way normal Perl
scalars work.
.PP
If you do want to work with large integers like under \f(CW\*(C`use integer;\*(C'\fR, try
\&\f(CW\*(C`use bigint;\*(C'\fR:
.PP
.Vb 2
\&        perl \-Mbigint \-le \*(Aqprint 1234.5+4.5\*(Aq
\&        1238
.Ve
.PP
There is also \f(CW\*(C`use bigrat;\*(C'\fR which gives you big rationals:
.PP
.Vb 2
\&        perl \-Mbigrat \-le \*(Aqprint 1234+4.1\*(Aq
\&        12381/10
.Ve
.PP
The entire upgrading/downgrading is still experimental and might not work
as you expect or may even have bugs. You might get errors like this:
.PP
.Vb 2
\&        Can\*(Aqt use an undefined value as an ARRAY reference at
\&        /usr/local/lib/perl5/5.8.0/Math/BigInt/Calc.pm line 864
.Ve
.PP
This means somewhere a routine got a BigFloat/Lite but expected a BigInt (or
vice versa) and the upgrade/downgrad path was missing. This is a bug, please
report it so that we can fix it.
.PP
You might consider using just Math::BigInt or Math::BigFloat, since they
allow you finer control over what get's done in which module/space. For
instance, simple loop counters will be Math::BigInts under \f(CW\*(C`use bignum;\*(C'\fR and
this is slower than keeping them as Perl scalars:
.PP
.Vb 1
\&    perl \-Mbignum \-le \*(Aqfor ($i = 0; $i < 10; $i++) { print ref($i); }\*(Aq
.Ve
.PP
Please note the following does not work as expected (prints nothing), since
overloading of '..' is not yet possible in Perl (as of v5.8.0):
.PP
.Vb 1
\&    perl \-Mbignum \-le \*(Aqfor (1..2) { print ref($_); }\*(Aq
.Ve
.SS "Options"
.IX Subsection "Options"
bignum recognizes some options that can be passed while loading it via use.
The options can (currently) be either a single letter form, or the long form.
The following options exist:
.IP "a or accuracy" 2
.IX Item "a or accuracy"
This sets the accuracy for all math operations. The argument must be greater
than or equal to zero. See Math::BigInt's \fIbround()\fR function for details.
.Sp
.Vb 1
\&        perl \-Mbignum=a,50 \-le \*(Aqprint sqrt(20)\*(Aq
.Ve
.Sp
Note that setting precision and accuracy at the same time is not possible.
.IP "p or precision" 2
.IX Item "p or precision"
This sets the precision for all math operations. The argument can be any
integer. Negative values mean a fixed number of digits after the dot, while
a positive value rounds to this digit left from the dot. 0 or 1 mean round to
integer. See Math::BigInt's \fIbfround()\fR function for details.
.Sp
.Vb 1
\&        perl \-Mbignum=p,\-50 \-le \*(Aqprint sqrt(20)\*(Aq
.Ve
.Sp
Note that setting precision and accuracy at the same time is not possible.
.IP "t or trace" 2
.IX Item "t or trace"
This enables a trace mode and is primarily for debugging bignum or
Math::BigInt/Math::BigFloat.
.IP "l or lib" 2
.IX Item "l or lib"
Load a different math lib, see \*(L"Math Library\*(R".
.Sp
.Vb 1
\&        perl \-Mbignum=l,GMP \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
Currently there is no way to specify more than one library on the command
line. This means the following does not work:
.Sp
.Vb 1
\&        perl \-Mbignum=l,GMP,Pari \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
This will be hopefully fixed soon ;)
.IP "hex" 2
.IX Item "hex"
Override the built-in \fIhex()\fR method with a version that can handle big
integers. Note that under Perl older than v5.9.4, this will be global
and cannot be disabled with \*(L"no bigint;\*(R".
.IP "oct" 2
.IX Item "oct"
Override the built-in \fIoct()\fR method with a version that can handle big
integers. Note that under Perl older than v5.9.4, this will be global
and cannot be disabled with \*(L"no bigint;\*(R".
.IP "v or version" 2
.IX Item "v or version"
This prints out the name and version of all modules used and then exits.
.Sp
.Vb 1
\&        perl \-Mbignum=v
.Ve
.SS "Methods"
.IX Subsection "Methods"
Beside \fIimport()\fR and \s-1\fIAUTOLOAD\s0()\fR there are only a few other methods.
.PP
Since all numbers are now objects, you can use all functions that are part of
the BigInt or BigFloat \s-1API\s0. It is wise to use only the \fIbxxx()\fR notation, and not
the \fIfxxx()\fR notation, though. This makes it possible that the underlying object
might morph into a different class than BigFloat.
.SS "Caveats"
.IX Subsection "Caveats"
But a warning is in order. When using the following to make a copy of a number,
only a shallow copy will be made.
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $x = $y = 7;
.Ve
.PP
If you want to make a real copy, use the following:
.PP
.Vb 1
\&        $y = $x\->copy();
.Ve
.PP
Using the copy or the original with overloaded math is okay, e.g. the
following work:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x + 1, " ", $y,"\en";     # prints 10 9
.Ve
.PP
but calling any method that modifies the number directly will result in
\&\fBboth\fR the original and the copy being destroyed:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x\->badd(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->binc(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->bmul(2), " ", $y,"\en";        # prints 18 18
.Ve
.PP
Using methods that do not modify, but test the contents works:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $z = 9 if $x\->is_zero();                # works fine
.Ve
.PP
See the documentation about the copy constructor and \f(CW\*(C`=\*(C'\fR in overload, as
well as the documentation in BigInt for further details.
.IP "\fIinf()\fR" 2
.IX Item "inf()"
A shortcut to return Math::BigInt\->\fIbinf()\fR. Useful because Perl does not always
handle bareword \f(CW\*(C`inf\*(C'\fR properly.
.IP "\fINaN()\fR" 2
.IX Item "NaN()"
A shortcut to return Math::BigInt\->\fIbnan()\fR. Useful because Perl does not always
handle bareword \f(CW\*(C`NaN\*(C'\fR properly.
.IP "e" 2
.IX Item "e"
.Vb 1
\&        # perl \-Mbignum=e \-wle \*(Aqprint e\*(Aq
.Ve
.Sp
Returns Euler's number \f(CW\*(C`e\*(C'\fR, aka \fIexp\fR\|(1).
.IP "\s-1\fIPI\s0()\fR" 2
.IX Item "PI()"
.Vb 1
\&        # perl \-Mbignum=PI \-wle \*(Aqprint PI\*(Aq
.Ve
.Sp
Returns \s-1PI\s0.
.IP "\fIbexp()\fR" 2
.IX Item "bexp()"
.Vb 1
\&        bexp($power,$accuracy);
.Ve
.Sp
Returns Euler's number \f(CW\*(C`e\*(C'\fR raised to the appropriate power, to
the wanted accuracy.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbignum=bexp \-wle \*(Aqprint bexp(1,80)\*(Aq
.Ve
.IP "\fIbpi()\fR" 2
.IX Item "bpi()"
.Vb 1
\&        bpi($accuracy);
.Ve
.Sp
Returns \s-1PI\s0 to the wanted accuracy.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbignum=bpi \-wle \*(Aqprint bpi(80)\*(Aq
.Ve
.IP "\fIupgrade()\fR" 2
.IX Item "upgrade()"
Return the class that numbers are upgraded to, is in fact returning
\&\f(CW$Math::BigInt::upgrade\fR.
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
.Vb 1
\&        use bignum;
\&
\&        print "in effect\en" if bignum::in_effect;       # true
\&        {
\&          no bignum;
\&          print "in effect\en" if bignum::in_effect;     # false
\&        }
.Ve
.Sp
Returns true or false if \f(CW\*(C`bignum\*(C'\fR is in effect in the current scope.
.Sp
This method only works on Perl v5.9.4 or later.
.SS "Math Library"
.IX Subsection "Math Library"
Math with the numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent to saying:
.PP
.Vb 1
\&        use bignum lib => \*(AqCalc\*(Aq;
.Ve
.PP
You can change this by using:
.PP
.Vb 1
\&        use bignum lib => \*(AqGMP\*(Aq;
.Ve
.PP
The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:
.PP
.Vb 1
\&        use bignum lib => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
Please see respective module documentation for further details.
.PP
Using \f(CW\*(C`lib\*(C'\fR warns if none of the specified libraries can be found and
Math::BigInt did fall back to one of the default libraries.
To suppress this warning, use \f(CW\*(C`try\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum try => \*(AqGMP\*(Aq;
.Ve
.PP
If you want the code to die instead of falling back, use \f(CW\*(C`only\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum only => \*(AqGMP\*(Aq;
.Ve
.SS "\s-1INTERNAL\s0 \s-1FORMAT\s0"
.IX Subsection "INTERNAL FORMAT"
The numbers are stored as objects, and their internals might change at anytime,
especially between math operations. The objects also might belong to different
classes, like Math::BigInt, or Math::BigFLoat. Mixing them together, even
with normal scalars is not extraordinary, but normal and expected.
.PP
You should not depend on the internal format, all accesses must go through
accessor methods. E.g. looking at \f(CW$x\fR\->{sign} is not a bright idea since there
is no guaranty that the object in question has such a hashkey, nor is a hash
underneath at all.
.SS "\s-1SIGN\s0"
.IX Subsection "SIGN"
The sign is either '+', '\-', 'NaN', '+inf' or '\-inf' and stored separately.
You can access it with the \fIsign()\fR method.
.PP
A sign of 'NaN' is used to represent the result when input arguments are not
numbers or as a result of 0/0. '+inf' and '\-inf' represent plus respectively
minus infinity. You will get '+inf' when dividing a positive number by 0, and
\&'\-inf' when dividing any negative number by 0.
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
This method only works on Perl v5.9.4 or later.
.IP "\fIhex()\fR/\fIoct()\fR" 2
.IX Item "hex()/oct()"
\&\f(CW\*(C`bigint\*(C'\fR overrides these routines with versions that can also handle
big integer values. Under Perl prior to version v5.9.4, however, this
will not happen unless you specifically ask for it with the two
import tags \*(L"hex\*(R" and \*(L"oct\*(R" \- and then it will be global and cannot be
disabled inside a scope with \*(L"no bigint\*(R":
.Sp
.Vb 1
\&        use bigint qw/hex oct/;
\&
\&        print hex("0x1234567890123456");
\&        {
\&                no bigint;
\&                print hex("0x1234567890123456");
\&        }
.Ve
.Sp
The second call to \fIhex()\fR will warn about a non-portable constant.
.Sp
Compare this to:
.Sp
.Vb 1
\&        use bigint;
\&
\&        # will warn only under older than v5.9.4
\&        print hex("0x1234567890123456");
.Ve
.SH "MODULES USED"
.IX Header "MODULES USED"
\&\f(CW\*(C`bignum\*(C'\fR is just a thin wrapper around various modules of the Math::BigInt
family. Think of it as the head of the family, who runs the shop, and orders
the others to do the work.
.PP
The following modules are currently used by bignum:
.PP
.Vb 3
\&        Math::BigInt::Lite      (for speed, and only if it is loadable)
\&        Math::BigInt
\&        Math::BigFloat
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Some cool command line examples to impress the Python crowd ;)
.PP
.Vb 10
\&        perl \-Mbignum \-le \*(Aqprint sqrt(33)\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 2*255\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 4.5+2*255\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 3/7 + 5/7 + 8/3\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 123\->is_odd()\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint log(2)\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint exp(1)\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 2 ** 0.5\*(Aq
\&        perl \-Mbignum=a,65 \-le \*(Aqprint 2 ** 0.2\*(Aq
\&        perl \-Mbignum=a,65,l,GMP \-le \*(Aqprint 7 ** 7777\*(Aq
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Especially bigrat as in \f(CW\*(C`perl \-Mbigrat \-le \*(Aqprint 1/3+1/4\*(Aq\*(C'\fR.
.PP
Math::BigFloat, Math::BigInt, Math::BigRat and Math::Big as well
as Math::BigInt::BitVect, Math::BigInt::Pari and  Math::BigInt::GMP.
.SH "AUTHORS"
.IX Header "AUTHORS"
(C) by Tels <http://bloodgate.com/> in early 2002 \- 2007.
                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bignum5.18.3pm                               0100644 0001750 0001750 00000045321 12566207465 023110  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bignum 3pm"
.TH bignum 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
bignum \- Transparent BigNumber support for Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use bignum;
\&
\&  $x = 2 + 4.5,"\en";                    # BigFloat 6.5
\&  print 2 ** 512 * 0.1,"\en";            # really is what you think it is
\&  print inf * inf,"\en";                 # prints inf
\&  print NaN * 3,"\en";                   # prints NaN
\&
\&  {
\&    no bignum;
\&    print 2 ** 256,"\en";                # a normal Perl scalar now
\&  }
\&
\&  # for older Perls, import into current package:
\&  use bignum qw/hex oct/;
\&  print hex("0x1234567890123490"),"\en";
\&  print oct("01234567890123490"),"\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (including basic math operations) are overloaded. Integer and
floating-point constants are created as proper BigInts or BigFloats,
respectively.
.PP
If you do
.PP
.Vb 1
\&        use bignum;
.Ve
.PP
at the top of your script, Math::BigFloat and Math::BigInt will be loaded
and any constant number will be converted to an object (Math::BigFloat for
floats like 3.1415 and Math::BigInt for integers like 1234).
.PP
So, the following line:
.PP
.Vb 1
\&        $x = 1234;
.Ve
.PP
creates actually a Math::BigInt and stores a reference to in \f(CW$x\fR.
This happens transparently and behind your back, so to speak.
.PP
You can see this with the following:
.PP
.Vb 1
\&        perl \-Mbignum \-le \*(Aqprint ref(1234)\*(Aq
.Ve
.PP
Don't worry if it says Math::BigInt::Lite, bignum and friends will use Lite
if it is installed since it is faster for some operations. It will be
automatically upgraded to BigInt whenever necessary:
.PP
.Vb 1
\&        perl \-Mbignum \-le \*(Aqprint ref(2**255)\*(Aq
.Ve
.PP
This also means it is a bad idea to check for some specific package, since
the actual contents of \f(CW$x\fR might be something unexpected. Due to the
transparent way of bignum \f(CW\*(C`ref()\*(C'\fR should not be necessary, anyway.
.PP
Since Math::BigInt and BigFloat also overload the normal math operations,
the following line will still work:
.PP
.Vb 1
\&        perl \-Mbignum \-le \*(Aqprint ref(1234+1234)\*(Aq
.Ve
.PP
Since numbers are actually objects, you can call all the usual methods from
BigInt/BigFloat on them. This even works to some extent on expressions:
.PP
.Vb 4
\&        perl \-Mbignum \-le \*(Aq$x = 1234; print $x\->bdec()\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 1234\->copy()\->binc();\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 1234\->copy()\->binc\->badd(6);\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint +(1234)\->copy()\->binc()\*(Aq
.Ve
.PP
(Note that print doesn't do what you expect if the expression starts with
\&'(' hence the \f(CW\*(C`+\*(C'\fR)
.PP
You can even chain the operations together as usual:
.PP
.Vb 2
\&        perl \-Mbignum \-le \*(Aqprint 1234\->copy()\->binc\->badd(6);\*(Aq
\&        1241
.Ve
.PP
Under bignum (or bigint or bigrat), Perl will \*(L"upgrade\*(R" the numbers
appropriately. This means that:
.PP
.Vb 2
\&        perl \-Mbignum \-le \*(Aqprint 1234+4.5\*(Aq
\&        1238.5
.Ve
.PP
will work correctly. These mixed cases don't do always work when using
Math::BigInt or Math::BigFloat alone, or at least not in the way normal Perl
scalars work.
.PP
If you do want to work with large integers like under \f(CW\*(C`use integer;\*(C'\fR, try
\&\f(CW\*(C`use bigint;\*(C'\fR:
.PP
.Vb 2
\&        perl \-Mbigint \-le \*(Aqprint 1234.5+4.5\*(Aq
\&        1238
.Ve
.PP
There is also \f(CW\*(C`use bigrat;\*(C'\fR which gives you big rationals:
.PP
.Vb 2
\&        perl \-Mbigrat \-le \*(Aqprint 1234+4.1\*(Aq
\&        12381/10
.Ve
.PP
The entire upgrading/downgrading is still experimental and might not work
as you expect or may even have bugs. You might get errors like this:
.PP
.Vb 2
\&        Can\*(Aqt use an undefined value as an ARRAY reference at
\&        /usr/local/lib/perl5/5.8.0/Math/BigInt/Calc.pm line 864
.Ve
.PP
This means somewhere a routine got a BigFloat/Lite but expected a BigInt (or
vice versa) and the upgrade/downgrad path was missing. This is a bug, please
report it so that we can fix it.
.PP
You might consider using just Math::BigInt or Math::BigFloat, since they
allow you finer control over what get's done in which module/space. For
instance, simple loop counters will be Math::BigInts under \f(CW\*(C`use bignum;\*(C'\fR and
this is slower than keeping them as Perl scalars:
.PP
.Vb 1
\&    perl \-Mbignum \-le \*(Aqfor ($i = 0; $i < 10; $i++) { print ref($i); }\*(Aq
.Ve
.PP
Please note the following does not work as expected (prints nothing), since
overloading of '..' is not yet possible in Perl (as of v5.8.0):
.PP
.Vb 1
\&    perl \-Mbignum \-le \*(Aqfor (1..2) { print ref($_); }\*(Aq
.Ve
.SS "Options"
.IX Subsection "Options"
bignum recognizes some options that can be passed while loading it via use.
The options can (currently) be either a single letter form, or the long form.
The following options exist:
.IP "a or accuracy" 2
.IX Item "a or accuracy"
This sets the accuracy for all math operations. The argument must be greater
than or equal to zero. See Math::BigInt's \fIbround()\fR function for details.
.Sp
.Vb 1
\&        perl \-Mbignum=a,50 \-le \*(Aqprint sqrt(20)\*(Aq
.Ve
.Sp
Note that setting precision and accuracy at the same time is not possible.
.IP "p or precision" 2
.IX Item "p or precision"
This sets the precision for all math operations. The argument can be any
integer. Negative values mean a fixed number of digits after the dot, while
a positive value rounds to this digit left from the dot. 0 or 1 mean round to
integer. See Math::BigInt's \fIbfround()\fR function for details.
.Sp
.Vb 1
\&        perl \-Mbignum=p,\-50 \-le \*(Aqprint sqrt(20)\*(Aq
.Ve
.Sp
Note that setting precision and accuracy at the same time is not possible.
.IP "t or trace" 2
.IX Item "t or trace"
This enables a trace mode and is primarily for debugging bignum or
Math::BigInt/Math::BigFloat.
.IP "l or lib" 2
.IX Item "l or lib"
Load a different math lib, see \*(L"Math Library\*(R".
.Sp
.Vb 1
\&        perl \-Mbignum=l,GMP \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
Currently there is no way to specify more than one library on the command
line. This means the following does not work:
.Sp
.Vb 1
\&        perl \-Mbignum=l,GMP,Pari \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
This will be hopefully fixed soon ;)
.IP "hex" 2
.IX Item "hex"
Override the built-in \fIhex()\fR method with a version that can handle big
numbers. This overrides it by exporting it to the current package. Under
Perl v5.10.0 and higher, this is not so necessary, as \fIhex()\fR is lexically
overridden in the current scope whenever the bignum pragma is active.
.IP "oct" 2
.IX Item "oct"
Override the built-in \fIoct()\fR method with a version that can handle big
numbers. This overrides it by exporting it to the current package. Under
Perl v5.10.0 and higher, this is not so necessary, as \fIoct()\fR is lexically
overridden in the current scope whenever the bigint pragma is active.
.IP "v or version" 2
.IX Item "v or version"
This prints out the name and version of all modules used and then exits.
.Sp
.Vb 1
\&        perl \-Mbignum=v
.Ve
.SS "Methods"
.IX Subsection "Methods"
Beside \fIimport()\fR and \s-1\fIAUTOLOAD\s0()\fR there are only a few other methods.
.PP
Since all numbers are now objects, you can use all functions that are part of
the BigInt or BigFloat \s-1API.\s0 It is wise to use only the \fIbxxx()\fR notation, and not
the \fIfxxx()\fR notation, though. This makes it possible that the underlying object
might morph into a different class than BigFloat.
.SS "Caveats"
.IX Subsection "Caveats"
But a warning is in order. When using the following to make a copy of a number,
only a shallow copy will be made.
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $x = $y = 7;
.Ve
.PP
If you want to make a real copy, use the following:
.PP
.Vb 1
\&        $y = $x\->copy();
.Ve
.PP
Using the copy or the original with overloaded math is okay, e.g. the
following work:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x + 1, " ", $y,"\en";     # prints 10 9
.Ve
.PP
but calling any method that modifies the number directly will result in
\&\fBboth\fR the original and the copy being destroyed:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x\->badd(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->binc(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->bmul(2), " ", $y,"\en";        # prints 18 18
.Ve
.PP
Using methods that do not modify, but test the contents works:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $z = 9 if $x\->is_zero();                # works fine
.Ve
.PP
See the documentation about the copy constructor and \f(CW\*(C`=\*(C'\fR in overload, as
well as the documentation in BigInt for further details.
.IP "\fIinf()\fR" 2
.IX Item "inf()"
A shortcut to return Math::BigInt\->\fIbinf()\fR. Useful because Perl does not always
handle bareword \f(CW\*(C`inf\*(C'\fR properly.
.IP "\fINaN()\fR" 2
.IX Item "NaN()"
A shortcut to return Math::BigInt\->\fIbnan()\fR. Useful because Perl does not always
handle bareword \f(CW\*(C`NaN\*(C'\fR properly.
.IP "e" 2
.IX Item "e"
.Vb 1
\&        # perl \-Mbignum=e \-wle \*(Aqprint e\*(Aq
.Ve
.Sp
Returns Euler's number \f(CW\*(C`e\*(C'\fR, aka \fIexp\fR\|(1).
.IP "\s-1\fIPI\s0()\fR" 2
.IX Item "PI()"
.Vb 1
\&        # perl \-Mbignum=PI \-wle \*(Aqprint PI\*(Aq
.Ve
.Sp
Returns \s-1PI.\s0
.IP "\fIbexp()\fR" 2
.IX Item "bexp()"
.Vb 1
\&        bexp($power,$accuracy);
.Ve
.Sp
Returns Euler's number \f(CW\*(C`e\*(C'\fR raised to the appropriate power, to
the wanted accuracy.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbignum=bexp \-wle \*(Aqprint bexp(1,80)\*(Aq
.Ve
.IP "\fIbpi()\fR" 2
.IX Item "bpi()"
.Vb 1
\&        bpi($accuracy);
.Ve
.Sp
Returns \s-1PI\s0 to the wanted accuracy.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbignum=bpi \-wle \*(Aqprint bpi(80)\*(Aq
.Ve
.IP "\fIupgrade()\fR" 2
.IX Item "upgrade()"
Return the class that numbers are upgraded to, is in fact returning
\&\f(CW$Math::BigInt::upgrade\fR.
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
.Vb 1
\&        use bignum;
\&
\&        print "in effect\en" if bignum::in_effect;       # true
\&        {
\&          no bignum;
\&          print "in effect\en" if bignum::in_effect;     # false
\&        }
.Ve
.Sp
Returns true or false if \f(CW\*(C`bignum\*(C'\fR is in effect in the current scope.
.Sp
This method only works on Perl v5.9.4 or later.
.SS "Math Library"
.IX Subsection "Math Library"
Math with the numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent to saying:
.PP
.Vb 1
\&        use bignum lib => \*(AqCalc\*(Aq;
.Ve
.PP
You can change this by using:
.PP
.Vb 1
\&        use bignum lib => \*(AqGMP\*(Aq;
.Ve
.PP
The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:
.PP
.Vb 1
\&        use bignum lib => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
Please see respective module documentation for further details.
.PP
Using \f(CW\*(C`lib\*(C'\fR warns if none of the specified libraries can be found and
Math::BigInt did fall back to one of the default libraries.
To suppress this warning, use \f(CW\*(C`try\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum try => \*(AqGMP\*(Aq;
.Ve
.PP
If you want the code to die instead of falling back, use \f(CW\*(C`only\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum only => \*(AqGMP\*(Aq;
.Ve
.SS "\s-1INTERNAL FORMAT\s0"
.IX Subsection "INTERNAL FORMAT"
The numbers are stored as objects, and their internals might change at anytime,
especially between math operations. The objects also might belong to different
classes, like Math::BigInt, or Math::BigFLoat. Mixing them together, even
with normal scalars is not extraordinary, but normal and expected.
.PP
You should not depend on the internal format, all accesses must go through
accessor methods. E.g. looking at \f(CW$x\fR\->{sign} is not a bright idea since there
is no guaranty that the object in question has such a hashkey, nor is a hash
underneath at all.
.SS "\s-1SIGN\s0"
.IX Subsection "SIGN"
The sign is either '+', '\-', 'NaN', '+inf' or '\-inf' and stored separately.
You can access it with the \fIsign()\fR method.
.PP
A sign of 'NaN' is used to represent the result when input arguments are not
numbers or as a result of 0/0. '+inf' and '\-inf' represent plus respectively
minus infinity. You will get '+inf' when dividing a positive number by 0, and
\&'\-inf' when dividing any negative number by 0.
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
This method only works on Perl v5.9.4 or later.
.IP "\fIhex()\fR/\fIoct()\fR" 2
.IX Item "hex()/oct()"
\&\f(CW\*(C`bigint\*(C'\fR overrides these routines with versions that can also handle
big integer values. Under Perl prior to version v5.9.4, however, this
will not happen unless you specifically ask for it with the two
import tags \*(L"hex\*(R" and \*(L"oct\*(R" \- and then it will be global and cannot be
disabled inside a scope with \*(L"no bigint\*(R":
.Sp
.Vb 1
\&        use bigint qw/hex oct/;
\&
\&        print hex("0x1234567890123456");
\&        {
\&                no bigint;
\&                print hex("0x1234567890123456");
\&        }
.Ve
.Sp
The second call to \fIhex()\fR will warn about a non-portable constant.
.Sp
Compare this to:
.Sp
.Vb 1
\&        use bigint;
\&
\&        # will warn only under older than v5.9.4
\&        print hex("0x1234567890123456");
.Ve
.SH "MODULES USED"
.IX Header "MODULES USED"
\&\f(CW\*(C`bignum\*(C'\fR is just a thin wrapper around various modules of the Math::BigInt
family. Think of it as the head of the family, who runs the shop, and orders
the others to do the work.
.PP
The following modules are currently used by bignum:
.PP
.Vb 3
\&        Math::BigInt::Lite      (for speed, and only if it is loadable)
\&        Math::BigInt
\&        Math::BigFloat
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Some cool command line examples to impress the Python crowd ;)
.PP
.Vb 10
\&        perl \-Mbignum \-le \*(Aqprint sqrt(33)\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 2*255\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 4.5+2*255\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 3/7 + 5/7 + 8/3\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 123\->is_odd()\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint log(2)\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint exp(1)\*(Aq
\&        perl \-Mbignum \-le \*(Aqprint 2 ** 0.5\*(Aq
\&        perl \-Mbignum=a,65 \-le \*(Aqprint 2 ** 0.2\*(Aq
\&        perl \-Mbignum=a,65,l,GMP \-le \*(Aqprint 7 ** 7777\*(Aq
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Especially bigrat as in \f(CW\*(C`perl \-Mbigrat \-le \*(Aqprint 1/3+1/4\*(Aq\*(C'\fR.
.PP
Math::BigFloat, Math::BigInt, Math::BigRat and Math::Big as well
as Math::BigInt::Pari and  Math::BigInt::GMP.
.SH "AUTHORS"
.IX Header "AUTHORS"
(C) by Tels <http://bloodgate.com/> in early 2002 \- 2007.
                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bigrat.3pm                                   0100644 0001750 0001750 00000033703 12566207465 022564  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bigrat 3pm"
.TH bigrat 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
bigrat \- Transparent BigNumber/BigRational support for Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use bigrat;
\&
\&  print 2 + 4.5,"\en";                   # BigFloat 6.5
\&  print 1/3 + 1/4,"\en";                 # produces 7/12
\&
\&  {
\&    no bigrat;
\&    print 1/3,"\en";                     # 0.33333...
\&  }
\&
\&  # Import into current package:
\&  use bigrat qw/hex oct/;
\&  print hex("0x1234567890123490"),"\en";
\&  print oct("01234567890123490"),"\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (including basic math operations) are overloaded. Integer and
floating-point constants are created as proper BigInts or BigFloats,
respectively.
.PP
Other than bignum, this module upgrades to Math::BigRat, meaning that
instead of 2.5 you will get 2+1/2 as output.
.SS "Modules Used"
.IX Subsection "Modules Used"
\&\f(CW\*(C`bigrat\*(C'\fR is just a thin wrapper around various modules of the Math::BigInt
family. Think of it as the head of the family, who runs the shop, and orders
the others to do the work.
.PP
The following modules are currently used by bignum:
.PP
.Vb 4
\&        Math::BigInt::Lite      (for speed, and only if it is loadable)
\&        Math::BigInt
\&        Math::BigFloat
\&        Math::BigRat
.Ve
.SS "Math Library"
.IX Subsection "Math Library"
Math with the numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent to saying:
.PP
.Vb 1
\&        use bigrat lib => \*(AqCalc\*(Aq;
.Ve
.PP
You can change this by using:
.PP
.Vb 1
\&        use bignum lib => \*(AqGMP\*(Aq;
.Ve
.PP
The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:
.PP
.Vb 1
\&        use bigrat lib => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
Using \f(CW\*(C`lib\*(C'\fR warns if none of the specified libraries can be found and
Math::BigInt did fall back to one of the default libraries.
To suppress this warning, use \f(CW\*(C`try\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum try => \*(AqGMP\*(Aq;
.Ve
.PP
If you want the code to die instead of falling back, use \f(CW\*(C`only\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum only => \*(AqGMP\*(Aq;
.Ve
.PP
Please see respective module documentation for further details.
.SS "Sign"
.IX Subsection "Sign"
The sign is either '+', '\-', 'NaN', '+inf' or '\-inf'.
.PP
A sign of 'NaN' is used to represent the result when input arguments are not
numbers or as a result of 0/0. '+inf' and '\-inf' represent plus respectively
minus infinity. You will get '+inf' when dividing a positive number by 0, and
\&'\-inf' when dividing any negative number by 0.
.SS "Methods"
.IX Subsection "Methods"
Since all numbers are not objects, you can use all functions that are part of
the BigInt or BigFloat \s-1API.\s0 It is wise to use only the \fIbxxx()\fR notation, and not
the \fIfxxx()\fR notation, though. This makes you independent on the fact that the
underlying object might morph into a different class than BigFloat.
.IP "\fIinf()\fR" 2
.IX Item "inf()"
A shortcut to return Math::BigInt\->\fIbinf()\fR. Useful because Perl does not always
handle bareword \f(CW\*(C`inf\*(C'\fR properly.
.IP "\fINaN()\fR" 2
.IX Item "NaN()"
A shortcut to return Math::BigInt\->\fIbnan()\fR. Useful because Perl does not always
handle bareword \f(CW\*(C`NaN\*(C'\fR properly.
.IP "e" 2
.IX Item "e"
.Vb 1
\&        # perl \-Mbigrat=e \-wle \*(Aqprint e\*(Aq
.Ve
.Sp
Returns Euler's number \f(CW\*(C`e\*(C'\fR, aka \fIexp\fR\|(1).
.IP "\s-1PI\s0" 2
.IX Item "PI"
.Vb 1
\&        # perl \-Mbigrat=PI \-wle \*(Aqprint PI\*(Aq
.Ve
.Sp
Returns \s-1PI.\s0
.IP "\fIbexp()\fR" 2
.IX Item "bexp()"
.Vb 1
\&        bexp($power,$accuracy);
.Ve
.Sp
Returns Euler's number \f(CW\*(C`e\*(C'\fR raised to the appropriate power, to
the wanted accuracy.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbigrat=bexp \-wle \*(Aqprint bexp(1,80)\*(Aq
.Ve
.IP "\fIbpi()\fR" 2
.IX Item "bpi()"
.Vb 1
\&        bpi($accuracy);
.Ve
.Sp
Returns \s-1PI\s0 to the wanted accuracy.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbigrat=bpi \-wle \*(Aqprint bpi(80)\*(Aq
.Ve
.IP "\fIupgrade()\fR" 2
.IX Item "upgrade()"
Return the class that numbers are upgraded to, is in fact returning
\&\f(CW$Math::BigInt::upgrade\fR.
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
.Vb 1
\&        use bigrat;
\&
\&        print "in effect\en" if bigrat::in_effect;       # true
\&        {
\&          no bigrat;
\&          print "in effect\en" if bigrat::in_effect;     # false
\&        }
.Ve
.Sp
Returns true or false if \f(CW\*(C`bigrat\*(C'\fR is in effect in the current scope.
.Sp
This method only works on Perl v5.9.4 or later.
.SS "\s-1MATH LIBRARY\s0"
.IX Subsection "MATH LIBRARY"
Math with the numbers is done (by default) by a module called
.SS "Caveat"
.IX Subsection "Caveat"
But a warning is in order. When using the following to make a copy of a number,
only a shallow copy will be made.
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $x = $y = 7;
.Ve
.PP
If you want to make a real copy, use the following:
.PP
.Vb 1
\&        $y = $x\->copy();
.Ve
.PP
Using the copy or the original with overloaded math is okay, e.g. the
following work:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x + 1, " ", $y,"\en";     # prints 10 9
.Ve
.PP
but calling any method that modifies the number directly will result in
\&\fBboth\fR the original and the copy being destroyed:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x\->badd(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->binc(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->bmul(2), " ", $y,"\en";        # prints 18 18
.Ve
.PP
Using methods that do not modify, but testthe contents works:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $z = 9 if $x\->is_zero();                # works fine
.Ve
.PP
See the documentation about the copy constructor and \f(CW\*(C`=\*(C'\fR in overload, as
well as the documentation in BigInt for further details.
.SS "Options"
.IX Subsection "Options"
bignum recognizes some options that can be passed while loading it via use.
The options can (currently) be either a single letter form, or the long form.
The following options exist:
.IP "a or accuracy" 2
.IX Item "a or accuracy"
This sets the accuracy for all math operations. The argument must be greater
than or equal to zero. See Math::BigInt's \fIbround()\fR function for details.
.Sp
.Vb 1
\&        perl \-Mbigrat=a,50 \-le \*(Aqprint sqrt(20)\*(Aq
.Ve
.Sp
Note that setting precision and accuracy at the same time is not possible.
.IP "p or precision" 2
.IX Item "p or precision"
This sets the precision for all math operations. The argument can be any
integer. Negative values mean a fixed number of digits after the dot, while
a positive value rounds to this digit left from the dot. 0 or 1 mean round to
integer. See Math::BigInt's \fIbfround()\fR function for details.
.Sp
.Vb 1
\&        perl \-Mbigrat=p,\-50 \-le \*(Aqprint sqrt(20)\*(Aq
.Ve
.Sp
Note that setting precision and accuracy at the same time is not possible.
.IP "t or trace" 2
.IX Item "t or trace"
This enables a trace mode and is primarily for debugging bignum or
Math::BigInt/Math::BigFloat.
.IP "l or lib" 2
.IX Item "l or lib"
Load a different math lib, see \*(L"\s-1MATH LIBRARY\*(R"\s0.
.Sp
.Vb 1
\&        perl \-Mbigrat=l,GMP \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
Currently there is no way to specify more than one library on the command
line. This means the following does not work:
.Sp
.Vb 1
\&        perl \-Mbignum=l,GMP,Pari \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
This will be hopefully fixed soon ;)
.IP "hex" 2
.IX Item "hex"
Override the built-in \fIhex()\fR method with a version that can handle big
numbers. This overrides it by exporting it to the current package. Under
Perl v5.10.0 and higher, this is not so necessary, as \fIhex()\fR is lexically
overridden in the current scope whenever the bigrat pragma is active.
.IP "oct" 2
.IX Item "oct"
Override the built-in \fIoct()\fR method with a version that can handle big
numbers. This overrides it by exporting it to the current package. Under
Perl v5.10.0 and higher, this is not so necessary, as \fIoct()\fR is lexically
overridden in the current scope whenever the bigrat pragma is active.
.IP "v or version" 2
.IX Item "v or version"
This prints out the name and version of all modules used and then exits.
.Sp
.Vb 1
\&        perl \-Mbigrat=v
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
This method only works on Perl v5.9.4 or later.
.IP "\fIhex()\fR/\fIoct()\fR" 2
.IX Item "hex()/oct()"
\&\f(CW\*(C`bigint\*(C'\fR overrides these routines with versions that can also handle
big integer values. Under Perl prior to version v5.9.4, however, this
will not happen unless you specifically ask for it with the two
import tags \*(L"hex\*(R" and \*(L"oct\*(R" \- and then it will be global and cannot be
disabled inside a scope with \*(L"no bigint\*(R":
.Sp
.Vb 1
\&        use bigint qw/hex oct/;
\&
\&        print hex("0x1234567890123456");
\&        {
\&                no bigint;
\&                print hex("0x1234567890123456");
\&        }
.Ve
.Sp
The second call to \fIhex()\fR will warn about a non-portable constant.
.Sp
Compare this to:
.Sp
.Vb 1
\&        use bigint;
\&
\&        # will warn only under Perl older than v5.9.4
\&        print hex("0x1234567890123456");
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 6
\&        perl \-Mbigrat \-le \*(Aqprint sqrt(33)\*(Aq
\&        perl \-Mbigrat \-le \*(Aqprint 2*255\*(Aq
\&        perl \-Mbigrat \-le \*(Aqprint 4.5+2*255\*(Aq
\&        perl \-Mbigrat \-le \*(Aqprint 3/7 + 5/7 + 8/3\*(Aq
\&        perl \-Mbigrat \-le \*(Aqprint 12\->is_odd()\*(Aq;
\&        perl \-Mbignum=l,GMP \-le \*(Aqprint 7 ** 7777\*(Aq
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Especially bignum.
.PP
Math::BigFloat, Math::BigInt, Math::BigRat and Math::Big as well
as Math::BigInt::Pari and  Math::BigInt::GMP.
.SH "AUTHORS"
.IX Header "AUTHORS"
(C) by Tels <http://bloodgate.com/> in early 2002 \- 2007.
                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bigrat5.16.3pm                               0100644 0001750 0001750 00000033156 12566207443 023074  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bigrat 3pm"
.TH bigrat 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
bigrat \- Transparent BigNumber/BigRational support for Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use bigrat;
\&
\&  print 2 + 4.5,"\en";                   # BigFloat 6.5
\&  print 1/3 + 1/4,"\en";                 # produces 7/12
\&
\&  {
\&    no bigrat;
\&    print 1/3,"\en";                     # 0.33333...
\&  }
\&
\&  # Note that this will make hex() and oct() be globally overridden:
\&  use bigrat qw/hex oct/;
\&  print hex("0x1234567890123490"),"\en";
\&  print oct("01234567890123490"),"\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (including basic math operations) are overloaded. Integer and
floating-point constants are created as proper BigInts or BigFloats,
respectively.
.PP
Other than bignum, this module upgrades to Math::BigRat, meaning that
instead of 2.5 you will get 2+1/2 as output.
.SS "Modules Used"
.IX Subsection "Modules Used"
\&\f(CW\*(C`bigrat\*(C'\fR is just a thin wrapper around various modules of the Math::BigInt
family. Think of it as the head of the family, who runs the shop, and orders
the others to do the work.
.PP
The following modules are currently used by bignum:
.PP
.Vb 4
\&        Math::BigInt::Lite      (for speed, and only if it is loadable)
\&        Math::BigInt
\&        Math::BigFloat
\&        Math::BigRat
.Ve
.SS "Math Library"
.IX Subsection "Math Library"
Math with the numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent to saying:
.PP
.Vb 1
\&        use bigrat lib => \*(AqCalc\*(Aq;
.Ve
.PP
You can change this by using:
.PP
.Vb 1
\&        use bignum lib => \*(AqGMP\*(Aq;
.Ve
.PP
The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:
.PP
.Vb 1
\&        use bigrat lib => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
Using \f(CW\*(C`lib\*(C'\fR warns if none of the specified libraries can be found and
Math::BigInt did fall back to one of the default libraries.
To suppress this warning, use \f(CW\*(C`try\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum try => \*(AqGMP\*(Aq;
.Ve
.PP
If you want the code to die instead of falling back, use \f(CW\*(C`only\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum only => \*(AqGMP\*(Aq;
.Ve
.PP
Please see respective module documentation for further details.
.SS "Sign"
.IX Subsection "Sign"
The sign is either '+', '\-', 'NaN', '+inf' or '\-inf'.
.PP
A sign of 'NaN' is used to represent the result when input arguments are not
numbers or as a result of 0/0. '+inf' and '\-inf' represent plus respectively
minus infinity. You will get '+inf' when dividing a positive number by 0, and
\&'\-inf' when dividing any negative number by 0.
.SS "Methods"
.IX Subsection "Methods"
Since all numbers are not objects, you can use all functions that are part of
the BigInt or BigFloat \s-1API\s0. It is wise to use only the \fIbxxx()\fR notation, and not
the \fIfxxx()\fR notation, though. This makes you independent on the fact that the
underlying object might morph into a different class than BigFloat.
.IP "\fIinf()\fR" 2
.IX Item "inf()"
A shortcut to return Math::BigInt\->\fIbinf()\fR. Useful because Perl does not always
handle bareword \f(CW\*(C`inf\*(C'\fR properly.
.IP "\fINaN()\fR" 2
.IX Item "NaN()"
A shortcut to return Math::BigInt\->\fIbnan()\fR. Useful because Perl does not always
handle bareword \f(CW\*(C`NaN\*(C'\fR properly.
.IP "e" 2
.IX Item "e"
.Vb 1
\&        # perl \-Mbigrat=e \-wle \*(Aqprint e\*(Aq
.Ve
.Sp
Returns Euler's number \f(CW\*(C`e\*(C'\fR, aka \fIexp\fR\|(1).
.IP "\s-1PI\s0" 2
.IX Item "PI"
.Vb 1
\&        # perl \-Mbigrat=PI \-wle \*(Aqprint PI\*(Aq
.Ve
.Sp
Returns \s-1PI\s0.
.IP "\fIbexp()\fR" 2
.IX Item "bexp()"
.Vb 1
\&        bexp($power,$accuracy);
.Ve
.Sp
Returns Euler's number \f(CW\*(C`e\*(C'\fR raised to the appropriate power, to
the wanted accuracy.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbigrat=bexp \-wle \*(Aqprint bexp(1,80)\*(Aq
.Ve
.IP "\fIbpi()\fR" 2
.IX Item "bpi()"
.Vb 1
\&        bpi($accuracy);
.Ve
.Sp
Returns \s-1PI\s0 to the wanted accuracy.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbigrat=bpi \-wle \*(Aqprint bpi(80)\*(Aq
.Ve
.IP "\fIupgrade()\fR" 2
.IX Item "upgrade()"
Return the class that numbers are upgraded to, is in fact returning
\&\f(CW$Math::BigInt::upgrade\fR.
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
.Vb 1
\&        use bigrat;
\&
\&        print "in effect\en" if bigrat::in_effect;       # true
\&        {
\&          no bigrat;
\&          print "in effect\en" if bigrat::in_effect;     # false
\&        }
.Ve
.Sp
Returns true or false if \f(CW\*(C`bigrat\*(C'\fR is in effect in the current scope.
.Sp
This method only works on Perl v5.9.4 or later.
.SS "\s-1MATH\s0 \s-1LIBRARY\s0"
.IX Subsection "MATH LIBRARY"
Math with the numbers is done (by default) by a module called
.SS "Caveat"
.IX Subsection "Caveat"
But a warning is in order. When using the following to make a copy of a number,
only a shallow copy will be made.
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $x = $y = 7;
.Ve
.PP
If you want to make a real copy, use the following:
.PP
.Vb 1
\&        $y = $x\->copy();
.Ve
.PP
Using the copy or the original with overloaded math is okay, e.g. the
following work:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x + 1, " ", $y,"\en";     # prints 10 9
.Ve
.PP
but calling any method that modifies the number directly will result in
\&\fBboth\fR the original and the copy being destroyed:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x\->badd(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->binc(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->bmul(2), " ", $y,"\en";        # prints 18 18
.Ve
.PP
Using methods that do not modify, but testthe contents works:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $z = 9 if $x\->is_zero();                # works fine
.Ve
.PP
See the documentation about the copy constructor and \f(CW\*(C`=\*(C'\fR in overload, as
well as the documentation in BigInt for further details.
.SS "Options"
.IX Subsection "Options"
bignum recognizes some options that can be passed while loading it via use.
The options can (currently) be either a single letter form, or the long form.
The following options exist:
.IP "a or accuracy" 2
.IX Item "a or accuracy"
This sets the accuracy for all math operations. The argument must be greater
than or equal to zero. See Math::BigInt's \fIbround()\fR function for details.
.Sp
.Vb 1
\&        perl \-Mbigrat=a,50 \-le \*(Aqprint sqrt(20)\*(Aq
.Ve
.Sp
Note that setting precision and accuracy at the same time is not possible.
.IP "p or precision" 2
.IX Item "p or precision"
This sets the precision for all math operations. The argument can be any
integer. Negative values mean a fixed number of digits after the dot, while
a positive value rounds to this digit left from the dot. 0 or 1 mean round to
integer. See Math::BigInt's \fIbfround()\fR function for details.
.Sp
.Vb 1
\&        perl \-Mbigrat=p,\-50 \-le \*(Aqprint sqrt(20)\*(Aq
.Ve
.Sp
Note that setting precision and accuracy at the same time is not possible.
.IP "t or trace" 2
.IX Item "t or trace"
This enables a trace mode and is primarily for debugging bignum or
Math::BigInt/Math::BigFloat.
.IP "l or lib" 2
.IX Item "l or lib"
Load a different math lib, see \*(L"\s-1MATH\s0 \s-1LIBRARY\s0\*(R".
.Sp
.Vb 1
\&        perl \-Mbigrat=l,GMP \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
Currently there is no way to specify more than one library on the command
line. This means the following does not work:
.Sp
.Vb 1
\&        perl \-Mbignum=l,GMP,Pari \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
This will be hopefully fixed soon ;)
.IP "hex" 2
.IX Item "hex"
Override the built-in \fIhex()\fR method with a version that can handle big
integers. Note that under Perl v5.9.4 or ealier, this will be global
and cannot be disabled with \*(L"no bigint;\*(R".
.IP "oct" 2
.IX Item "oct"
Override the built-in \fIoct()\fR method with a version that can handle big
integers. Note that under Perl v5.9.4 or earlier, this will be global
and cannot be disabled with \*(L"no bigint;\*(R".
.IP "v or version" 2
.IX Item "v or version"
This prints out the name and version of all modules used and then exits.
.Sp
.Vb 1
\&        perl \-Mbigrat=v
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
This method only works on Perl v5.9.4 or later.
.IP "\fIhex()\fR/\fIoct()\fR" 2
.IX Item "hex()/oct()"
\&\f(CW\*(C`bigint\*(C'\fR overrides these routines with versions that can also handle
big integer values. Under Perl prior to version v5.9.4, however, this
will not happen unless you specifically ask for it with the two
import tags \*(L"hex\*(R" and \*(L"oct\*(R" \- and then it will be global and cannot be
disabled inside a scope with \*(L"no bigint\*(R":
.Sp
.Vb 1
\&        use bigint qw/hex oct/;
\&
\&        print hex("0x1234567890123456");
\&        {
\&                no bigint;
\&                print hex("0x1234567890123456");
\&        }
.Ve
.Sp
The second call to \fIhex()\fR will warn about a non-portable constant.
.Sp
Compare this to:
.Sp
.Vb 1
\&        use bigint;
\&
\&        # will warn only under Perl older than v5.9.4
\&        print hex("0x1234567890123456");
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 6
\&        perl \-Mbigrat \-le \*(Aqprint sqrt(33)\*(Aq
\&        perl \-Mbigrat \-le \*(Aqprint 2*255\*(Aq
\&        perl \-Mbigrat \-le \*(Aqprint 4.5+2*255\*(Aq
\&        perl \-Mbigrat \-le \*(Aqprint 3/7 + 5/7 + 8/3\*(Aq
\&        perl \-Mbigrat \-le \*(Aqprint 12\->is_odd()\*(Aq;
\&        perl \-Mbignum=l,GMP \-le \*(Aqprint 7 ** 7777\*(Aq
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Especially bignum.
.PP
Math::BigFloat, Math::BigInt, Math::BigRat and Math::Big as well
as Math::BigInt::BitVect, Math::BigInt::Pari and  Math::BigInt::GMP.
.SH "AUTHORS"
.IX Header "AUTHORS"
(C) by Tels <http://bloodgate.com/> in early 2002 \- 2007.
                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bigrat5.18.3pm                               0100644 0001750 0001750 00000033703 12566207465 023100  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bigrat 3pm"
.TH bigrat 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
bigrat \- Transparent BigNumber/BigRational support for Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use bigrat;
\&
\&  print 2 + 4.5,"\en";                   # BigFloat 6.5
\&  print 1/3 + 1/4,"\en";                 # produces 7/12
\&
\&  {
\&    no bigrat;
\&    print 1/3,"\en";                     # 0.33333...
\&  }
\&
\&  # Import into current package:
\&  use bigrat qw/hex oct/;
\&  print hex("0x1234567890123490"),"\en";
\&  print oct("01234567890123490"),"\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
All operators (including basic math operations) are overloaded. Integer and
floating-point constants are created as proper BigInts or BigFloats,
respectively.
.PP
Other than bignum, this module upgrades to Math::BigRat, meaning that
instead of 2.5 you will get 2+1/2 as output.
.SS "Modules Used"
.IX Subsection "Modules Used"
\&\f(CW\*(C`bigrat\*(C'\fR is just a thin wrapper around various modules of the Math::BigInt
family. Think of it as the head of the family, who runs the shop, and orders
the others to do the work.
.PP
The following modules are currently used by bignum:
.PP
.Vb 4
\&        Math::BigInt::Lite      (for speed, and only if it is loadable)
\&        Math::BigInt
\&        Math::BigFloat
\&        Math::BigRat
.Ve
.SS "Math Library"
.IX Subsection "Math Library"
Math with the numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent to saying:
.PP
.Vb 1
\&        use bigrat lib => \*(AqCalc\*(Aq;
.Ve
.PP
You can change this by using:
.PP
.Vb 1
\&        use bignum lib => \*(AqGMP\*(Aq;
.Ve
.PP
The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:
.PP
.Vb 1
\&        use bigrat lib => \*(AqFoo,Math::BigInt::Bar\*(Aq;
.Ve
.PP
Using \f(CW\*(C`lib\*(C'\fR warns if none of the specified libraries can be found and
Math::BigInt did fall back to one of the default libraries.
To suppress this warning, use \f(CW\*(C`try\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum try => \*(AqGMP\*(Aq;
.Ve
.PP
If you want the code to die instead of falling back, use \f(CW\*(C`only\*(C'\fR instead:
.PP
.Vb 1
\&        use bignum only => \*(AqGMP\*(Aq;
.Ve
.PP
Please see respective module documentation for further details.
.SS "Sign"
.IX Subsection "Sign"
The sign is either '+', '\-', 'NaN', '+inf' or '\-inf'.
.PP
A sign of 'NaN' is used to represent the result when input arguments are not
numbers or as a result of 0/0. '+inf' and '\-inf' represent plus respectively
minus infinity. You will get '+inf' when dividing a positive number by 0, and
\&'\-inf' when dividing any negative number by 0.
.SS "Methods"
.IX Subsection "Methods"
Since all numbers are not objects, you can use all functions that are part of
the BigInt or BigFloat \s-1API.\s0 It is wise to use only the \fIbxxx()\fR notation, and not
the \fIfxxx()\fR notation, though. This makes you independent on the fact that the
underlying object might morph into a different class than BigFloat.
.IP "\fIinf()\fR" 2
.IX Item "inf()"
A shortcut to return Math::BigInt\->\fIbinf()\fR. Useful because Perl does not always
handle bareword \f(CW\*(C`inf\*(C'\fR properly.
.IP "\fINaN()\fR" 2
.IX Item "NaN()"
A shortcut to return Math::BigInt\->\fIbnan()\fR. Useful because Perl does not always
handle bareword \f(CW\*(C`NaN\*(C'\fR properly.
.IP "e" 2
.IX Item "e"
.Vb 1
\&        # perl \-Mbigrat=e \-wle \*(Aqprint e\*(Aq
.Ve
.Sp
Returns Euler's number \f(CW\*(C`e\*(C'\fR, aka \fIexp\fR\|(1).
.IP "\s-1PI\s0" 2
.IX Item "PI"
.Vb 1
\&        # perl \-Mbigrat=PI \-wle \*(Aqprint PI\*(Aq
.Ve
.Sp
Returns \s-1PI.\s0
.IP "\fIbexp()\fR" 2
.IX Item "bexp()"
.Vb 1
\&        bexp($power,$accuracy);
.Ve
.Sp
Returns Euler's number \f(CW\*(C`e\*(C'\fR raised to the appropriate power, to
the wanted accuracy.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbigrat=bexp \-wle \*(Aqprint bexp(1,80)\*(Aq
.Ve
.IP "\fIbpi()\fR" 2
.IX Item "bpi()"
.Vb 1
\&        bpi($accuracy);
.Ve
.Sp
Returns \s-1PI\s0 to the wanted accuracy.
.Sp
Example:
.Sp
.Vb 1
\&        # perl \-Mbigrat=bpi \-wle \*(Aqprint bpi(80)\*(Aq
.Ve
.IP "\fIupgrade()\fR" 2
.IX Item "upgrade()"
Return the class that numbers are upgraded to, is in fact returning
\&\f(CW$Math::BigInt::upgrade\fR.
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
.Vb 1
\&        use bigrat;
\&
\&        print "in effect\en" if bigrat::in_effect;       # true
\&        {
\&          no bigrat;
\&          print "in effect\en" if bigrat::in_effect;     # false
\&        }
.Ve
.Sp
Returns true or false if \f(CW\*(C`bigrat\*(C'\fR is in effect in the current scope.
.Sp
This method only works on Perl v5.9.4 or later.
.SS "\s-1MATH LIBRARY\s0"
.IX Subsection "MATH LIBRARY"
Math with the numbers is done (by default) by a module called
.SS "Caveat"
.IX Subsection "Caveat"
But a warning is in order. When using the following to make a copy of a number,
only a shallow copy will be made.
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $x = $y = 7;
.Ve
.PP
If you want to make a real copy, use the following:
.PP
.Vb 1
\&        $y = $x\->copy();
.Ve
.PP
Using the copy or the original with overloaded math is okay, e.g. the
following work:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x + 1, " ", $y,"\en";     # prints 10 9
.Ve
.PP
but calling any method that modifies the number directly will result in
\&\fBboth\fR the original and the copy being destroyed:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        print $x\->badd(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->binc(1), " ", $y,"\en";        # prints 10 10
\&
\&        $x = 9; $y = $x;
\&        print $x\->bmul(2), " ", $y,"\en";        # prints 18 18
.Ve
.PP
Using methods that do not modify, but testthe contents works:
.PP
.Vb 2
\&        $x = 9; $y = $x;
\&        $z = 9 if $x\->is_zero();                # works fine
.Ve
.PP
See the documentation about the copy constructor and \f(CW\*(C`=\*(C'\fR in overload, as
well as the documentation in BigInt for further details.
.SS "Options"
.IX Subsection "Options"
bignum recognizes some options that can be passed while loading it via use.
The options can (currently) be either a single letter form, or the long form.
The following options exist:
.IP "a or accuracy" 2
.IX Item "a or accuracy"
This sets the accuracy for all math operations. The argument must be greater
than or equal to zero. See Math::BigInt's \fIbround()\fR function for details.
.Sp
.Vb 1
\&        perl \-Mbigrat=a,50 \-le \*(Aqprint sqrt(20)\*(Aq
.Ve
.Sp
Note that setting precision and accuracy at the same time is not possible.
.IP "p or precision" 2
.IX Item "p or precision"
This sets the precision for all math operations. The argument can be any
integer. Negative values mean a fixed number of digits after the dot, while
a positive value rounds to this digit left from the dot. 0 or 1 mean round to
integer. See Math::BigInt's \fIbfround()\fR function for details.
.Sp
.Vb 1
\&        perl \-Mbigrat=p,\-50 \-le \*(Aqprint sqrt(20)\*(Aq
.Ve
.Sp
Note that setting precision and accuracy at the same time is not possible.
.IP "t or trace" 2
.IX Item "t or trace"
This enables a trace mode and is primarily for debugging bignum or
Math::BigInt/Math::BigFloat.
.IP "l or lib" 2
.IX Item "l or lib"
Load a different math lib, see \*(L"\s-1MATH LIBRARY\*(R"\s0.
.Sp
.Vb 1
\&        perl \-Mbigrat=l,GMP \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
Currently there is no way to specify more than one library on the command
line. This means the following does not work:
.Sp
.Vb 1
\&        perl \-Mbignum=l,GMP,Pari \-e \*(Aqprint 2 ** 512\*(Aq
.Ve
.Sp
This will be hopefully fixed soon ;)
.IP "hex" 2
.IX Item "hex"
Override the built-in \fIhex()\fR method with a version that can handle big
numbers. This overrides it by exporting it to the current package. Under
Perl v5.10.0 and higher, this is not so necessary, as \fIhex()\fR is lexically
overridden in the current scope whenever the bigrat pragma is active.
.IP "oct" 2
.IX Item "oct"
Override the built-in \fIoct()\fR method with a version that can handle big
numbers. This overrides it by exporting it to the current package. Under
Perl v5.10.0 and higher, this is not so necessary, as \fIoct()\fR is lexically
overridden in the current scope whenever the bigrat pragma is active.
.IP "v or version" 2
.IX Item "v or version"
This prints out the name and version of all modules used and then exits.
.Sp
.Vb 1
\&        perl \-Mbigrat=v
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
.IP "\fIin_effect()\fR" 2
.IX Item "in_effect()"
This method only works on Perl v5.9.4 or later.
.IP "\fIhex()\fR/\fIoct()\fR" 2
.IX Item "hex()/oct()"
\&\f(CW\*(C`bigint\*(C'\fR overrides these routines with versions that can also handle
big integer values. Under Perl prior to version v5.9.4, however, this
will not happen unless you specifically ask for it with the two
import tags \*(L"hex\*(R" and \*(L"oct\*(R" \- and then it will be global and cannot be
disabled inside a scope with \*(L"no bigint\*(R":
.Sp
.Vb 1
\&        use bigint qw/hex oct/;
\&
\&        print hex("0x1234567890123456");
\&        {
\&                no bigint;
\&                print hex("0x1234567890123456");
\&        }
.Ve
.Sp
The second call to \fIhex()\fR will warn about a non-portable constant.
.Sp
Compare this to:
.Sp
.Vb 1
\&        use bigint;
\&
\&        # will warn only under Perl older than v5.9.4
\&        print hex("0x1234567890123456");
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 6
\&        perl \-Mbigrat \-le \*(Aqprint sqrt(33)\*(Aq
\&        perl \-Mbigrat \-le \*(Aqprint 2*255\*(Aq
\&        perl \-Mbigrat \-le \*(Aqprint 4.5+2*255\*(Aq
\&        perl \-Mbigrat \-le \*(Aqprint 3/7 + 5/7 + 8/3\*(Aq
\&        perl \-Mbigrat \-le \*(Aqprint 12\->is_odd()\*(Aq;
\&        perl \-Mbignum=l,GMP \-le \*(Aqprint 7 ** 7777\*(Aq
.Ve
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Especially bignum.
.PP
Math::BigFloat, Math::BigInt, Math::BigRat and Math::Big as well
as Math::BigInt::Pari and  Math::BigInt::GMP.
.SH "AUTHORS"
.IX Header "AUTHORS"
(C) by Tels <http://bloodgate.com/> in early 2002 \- 2007.
                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bindresvport.3                               0100644 0001750 0001750 00000004111 12566167025 023464  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" @(#)bindresvport.3n	2.2 88/08/02 4.0 RPCSRC; from 1.7 88/03/14 SMI
.\" $NetBSD: bindresvport.3,v 1.8 2000/07/05 15:45:33 msaitoh Exp $
.\" $FreeBSD: src/lib/libc/rpc/bindresvport.3,v 1.15 2002/12/18 12:45:10 ru Exp $
.\"
.Dd November 22, 1987
.Dt BINDRESVPORT 3
.Os
.Sh NAME
.Nm bindresvport ,
.Nm bindresvport_sa
.Nd bind a socket to a privileged IP port
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In sys/types.h
.In rpc/rpc.h
.Ft int
.Fn bindresvport "int sd" "struct sockaddr_in *sin"
.Ft int
.Fn bindresvport_sa "int sd" "struct sockaddr *sa"
.Sh DESCRIPTION
The
.Fn bindresvport
and
.Fn bindresvport_sa
functions
are used to bind a socket descriptor to a privileged
.Tn IP
port, that is, a
port number in the range 0-1023.
.Pp
If
.Fa sin
is a pointer to a
.Ft "struct sockaddr_in"
then the appropriate fields in the structure should be defined.
Note that
.Fa sin->sin_family
must be initialized to the address family of the socket, passed by
.Fa sd .
If
.Fa sin->sin_port
is
.Sq 0
then an anonymous port (in the range 600-1023) will be
chosen, and if
.Xr bind 2
is successful, the
.Fa sin->sin_port
will be updated to contain the allocated port.
.Pp
If
.Fa sin
is the
.Dv NULL
pointer,
an anonymous port will be allocated (as above).
However, there is no way for
.Fn bindresvport
to return the allocated port in this case.
.Pp
Only root can bind to a privileged port; this call will fail for any
other users.
.Pp
Function prototype of
.Fn bindresvport
is biased to
.Dv AF_INET
socket.
The
.Fn bindresvport_sa
function
acts exactly the same, with more neutral function prototype.
Note that both functions behave exactly the same, and
both support
.Dv AF_INET6
sockets as well as
.Dv AF_INET
sockets.
.Sh RETURN VALUES
.Rv -std bindresvport
.Sh ERRORS
.Bl -tag -width Er
.It Bq Er EPFNOSUPPORT
If second argument was supplied,
and address family did not match between arguments.
.El
.Pp
The
.Fn bindresvport
function
may also fail and set
.Va errno
for any of the errors specified for the calls
.Xr bind 2 ,
.Xr getsockopt 2 ,
or
.Xr setsockopt 2 .
.Sh SEE ALSO
.Xr bind 2 ,
.Xr getsockopt 2 ,
.Xr setsockopt 2 ,
.Xr ip 4
                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bio.3ssl                                     0100644 0001750 0001750 00000013507 12566201144 022236  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bio 3"
.TH bio 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
bio \- I/O abstraction
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/bio.h>
.Ve
.PP
\&\s-1TBA\s0
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A \s-1BIO\s0 is an I/O abstraction, it hides many of the underlying I/O
details from an application. If an application uses a \s-1BIO\s0 for its
I/O it can transparently handle \s-1SSL\s0 connections, unencrypted network
connections and file I/O.
.PP
There are two type of \s-1BIO,\s0 a source/sink \s-1BIO\s0 and a filter \s-1BIO.\s0
.PP
As its name implies a source/sink \s-1BIO\s0 is a source and/or sink of data,
examples include a socket \s-1BIO\s0 and a file \s-1BIO.\s0
.PP
A filter \s-1BIO\s0 takes data from one \s-1BIO\s0 and passes it through to
another, or the application. The data may be left unmodified (for
example a message digest \s-1BIO\s0) or translated (for example an
encryption \s-1BIO\s0). The effect of a filter \s-1BIO\s0 may change according
to the I/O operation it is performing: for example an encryption
\&\s-1BIO\s0 will encrypt data if it is being written to and decrypt data
if it is being read from.
.PP
BIOs can be joined together to form a chain (a single \s-1BIO\s0 is a chain
with one component). A chain normally consist of one source/sink
\&\s-1BIO\s0 and one or more filter BIOs. Data read from or written to the
first \s-1BIO\s0 then traverses the chain to the end (normally a source/sink
\&\s-1BIO\s0).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIBIO_ctrl\fR\|(3),
\&\fIBIO_f_base64\fR\|(3), \fIBIO_f_buffer\fR\|(3),
\&\fIBIO_f_cipher\fR\|(3), \fIBIO_f_md\fR\|(3),
\&\fIBIO_f_null\fR\|(3), \fIBIO_f_ssl\fR\|(3),
\&\fIBIO_find_type\fR\|(3), \fIBIO_new\fR\|(3),
\&\fIBIO_new_bio_pair\fR\|(3),
\&\fIBIO_push\fR\|(3), \fIBIO_read\fR\|(3),
\&\fIBIO_s_accept\fR\|(3), \fIBIO_s_bio\fR\|(3),
\&\fIBIO_s_connect\fR\|(3), \fIBIO_s_fd\fR\|(3),
\&\fIBIO_s_file\fR\|(3), \fIBIO_s_mem\fR\|(3),
\&\fIBIO_s_null\fR\|(3), \fIBIO_s_socket\fR\|(3),
\&\fIBIO_set_callback\fR\|(3),
\&\fIBIO_should_retry\fR\|(3)
                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bit_alloc.3                                  0120777 0001750 0001750 00000000000 12620245063 024754  2bitstring.3                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bit_clear.3                                  0120777 0001750 0001750 00000000000 12620245063 024750  2bitstring.3                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bit_decl.3                                   0120777 0001750 0001750 00000000000 12620245063 024571  2bitstring.3                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bit_ffs.3                                    0120777 0001750 0001750 00000000000 12620245063 024440  2bitstring.3                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bit_nclear.3                                 0120777 0001750 0001750 00000000000 12620245063 025126  2bitstring.3                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bit_nset.3                                   0120777 0001750 0001750 00000000000 12620245063 024633  2bitstring.3                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bit_set.3                                    0120777 0001750 0001750 00000000000 12620245063 024455  2bitstring.3                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bit_test.3                                   0120777 0001750 0001750 00000000000 12620245063 024641  2bitstring.3                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bitstr_size.3                                0120777 0001750 0001750 00000000000 12620245063 025365  2bitstring.3                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bitstring.3                                  0100644 0001750 0001750 00000011625 12566166140 022755  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"	$NetBSD: bitstring.3,v 1.4 1994/11/30 15:24:31 jtc Exp $
.\"
.\" Copyright (c) 1989, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" Paul Vixie.
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @(#)bitstring.3	8.1 (Berkeley) 7/19/93
.\"
.Dd July 19, 1993
.Dt BITSTRING 3
.Os BSD 4
.Sh NAME
.Nm bit_alloc ,
.Nm bit_clear ,
.Nm bit_decl ,
.Nm bit_ffs ,
.Nm bit_nclear ,
.Nm bit_nset,
.Nm bit_set ,
.Nm bitstr_size ,
.Nm bit_test
.Nd bit-string manipulation macros
.Sh SYNOPSIS
.Fd #include <bitstring.h>
.Ft bitstr_t *
.Fn bit_alloc "int nbits"
.Fn bit_decl "bitstr_t *name" "int nbits"
.Fn bit_clear "bitstr_t *name" "int bit"
.Fn bit_ffc "bitstr_t *name" "int nbits" "int *value"
.Fn bit_ffs "bitstr_t *name" "int nbits" "int *value"
.Fn bit_nclear "bitstr_t *name" "int start" "int stop"
.Fn bit_nset "bitstr_t *name" "int start" "int stop"
.Fn bit_set "bitstr_t *name" "int bit"
.Ft int
.Fn bitstr_size "int nbits"
.Ft int
.Fn bit_test "bitstr_t *name" "int bit"
.Sh DESCRIPTION
These macros operate on strings of bits.
.Pp
The macro
.Fn bit_alloc
returns a pointer of type
.Dq Fa "bitstr_t *"
to sufficient space to store
.Fa nbits
bits, or
.Dv NULL
if no space is available.
.Pp
The macro
.Fn bit_decl
allocates sufficient space to store
.Fa nbits
bits on the stack.
.Pp
The macro
.Fn bitstr_size
returns the number of elements of type
.Fa bitstr_t
necessary to store
.Fa nbits
bits.
This is useful for copying bit strings.
.Pp
The macros
.Fn bit_clear
and
.Fn bit_set
clear or set the zero-based numbered bit
.Fa bit ,
in the bit string
.Ar name .
.Pp
The
.Fn bit_nset
and
.Fn bit_nclear
macros
set or clear the zero-based numbered bits from
.Fa start
to
.Fa stop
in the bit string
.Ar name .
.Pp
The
.Fn bit_test
macro
evaluates to non-zero if the zero-based numbered bit
.Fa bit
of bit string
.Fa name
is set, and zero otherwise.
.Pp
The
.Fn bit_ffs
macro
stores in the location referenced by
.Fa value
the zero-based number of the first bit set in the array of
.Fa nbits
bits referenced by
.Fa name .
If no bits are set, the location referenced by
.Fa value
is set to \-1.
.Pp
The macro
.Fn bit_ffc
stores in the location referenced by
.Fa value
the zero-based number of the first bit not set in the array of
.Fa nbits
bits referenced by
.Fa name .
If all bits are set, the location referenced by
.Fa value
is set to \-1.
.Pp
The macros
.Fn bit_clear ,
.Fn bit_set
and
.Fn bit_test
will evaluate the
.Fa bit
argument more than once, so avoid using pre- or post-, increment or decrement.
The arguments to the other macros are evaluated only once and may safely
have side effects.
.Sh EXAMPLE
.Bd -literal -offset indent
#include <limits.h>
#include <bitstring.h>

...
#define	LPR_BUSY_BIT		0
#define	LPR_FORMAT_BIT		1
#define	LPR_DOWNLOAD_BIT	2
...
#define	LPR_AVAILABLE_BIT	9
#define	LPR_MAX_BITS		10

make_lpr_available()
{
	bitstr_t bit_decl(bitlist, LPR_MAX_BITS);
	...
	bit_nclear(bitlist, 0, LPR_MAX_BITS - 1);
	...
	if (!bit_test(bitlist, LPR_BUSY_BIT)) {
		bit_clear(bitlist, LPR_FORMAT_BIT);
		bit_clear(bitlist, LPR_DOWNLOAD_BIT);
		bit_set(bitlist, LPR_AVAILABLE_BIT);
	}
}
.Ed
.Sh SEE ALSO
.Xr malloc 3
.Sh HISTORY
The
.Nm bitstring
functions first appeared in 4.4BSD.
                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bkgd.3x                                      0100644 0001750 0001750 00000010654 12566174416 022055  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"***************************************************************************
.\" Copyright (c) 1998-2002,2003 Free Software Foundation, Inc.              *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, to any person obtaining a  *
.\" copy of this software and associated documentation files (the            *
.\" "Software"), to deal in the Software without restriction, including      *
.\" without limitation the rights to use, copy, modify, merge, publish,      *
.\" distribute, distribute with modifications, sublicense, and/or sell       *
.\" copies of the Software, and to permit persons to whom the Software is    *
.\" furnished to do so, subject to the following conditions:                 *
.\"                                                                          *
.\" The above copyright notice and this permission notice shall be included  *
.\" in all copies or substantial portions of the Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained in this notice, the name(s) of the above copyright   *
.\" holders shall not be used in advertising or otherwise to promote the     *
.\" sale, use or other dealings in this Software without prior written       *
.\" authorization.                                                           *
.\"***************************************************************************
.\"
.\" $Id: curs_bkgd.3x,v 1.19 2003/12/27 18:50:40 tom Exp $
.TH curs_bkgd 3X ""
.SH NAME
\fBbkgdset\fR, \fBwbkgdset\fR,
\fBbkgd\fR, \fBwbkgd\fR,
\fBgetbkgd\fR - \fBcurses\fR window background manipulation routines
.SH SYNOPSIS
\fB#include <curses.h>\fR
.PP
\fBvoid bkgdset(chtype ch);\fR
.br
\fBvoid wbkgdset(WINDOW *win, chtype ch);\fR
.br
\fBint bkgd(chtype ch);\fR
.br
\fBint wbkgd(WINDOW *win, chtype ch);\fR
.br
\fBchtype getbkgd(WINDOW *win);\fR
.br
.SH DESCRIPTION
The \fBbkgdset\fR and \fBwbkgdset\fR routines manipulate the
background of the named window.
The window background is a \fBchtype\fR consisting of
any combination of attributes (i.e., rendition) and a character.
The attribute part of the background is combined (OR'ed) with all non-blank
characters that are written into the window with \fBwaddch\fR.  Both
the character and attribute parts of the background are combined with
the blank characters.  The background becomes a property of the
character and moves with the character through any scrolling and
insert/delete line/character operations.
.PP
To the extent possible on a particular terminal,
the attribute part of the background is displayed
as the graphic rendition of the character put on the screen.
.PP
The \fBbkgd\fR and \fBwbkgd\fR functions
set the background property of the current or specified window
and then apply this setting to every character position in that window:
.PP
.RS
The rendition of every character on the screen is changed to
the new background rendition.
.PP
Wherever the former background character
appears, it is changed to the new background character.
.RE
.PP
The \fBgetbkgd\fR function returns the given window's current background
character/attribute pair.
.SH RETURN VALUE
The routines \fBbkgd\fR and \fBwbkgd\fR return the integer \fBOK\fR.
The SVr4.0 manual says "or a non-negative integer if \fBimmedok\fR is set",
but this appears to be an error.
.SH NOTES
Note that \fBbkgdset\fR and \fBbkgd\fR may be macros.
.SH PORTABILITY
These functions are described in the XSI Curses standard, Issue 4.
It specifies that \fBbkgd\fR and \fBwbkgd\fR return \fBERR\fR on failure.
but gives no failure conditions.
.SH SEE ALSO
\fBcurses\fR(3X),
\fBcurs_addch\fR(3X),
\fBcurs_attr\fR(3X),
\fBcurs_outopts\fR(3X)
.\"#
.\"# The following sets edit modes for GNU EMACS
.\"# Local Variables:
.\"# mode:nroff
.\"# fill-column:79
.\"# End:
                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bkgdset.3x                                   0100644 0001750 0001750 00000010654 12566174416 022571  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"***************************************************************************
.\" Copyright (c) 1998-2002,2003 Free Software Foundation, Inc.              *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, to any person obtaining a  *
.\" copy of this software and associated documentation files (the            *
.\" "Software"), to deal in the Software without restriction, including      *
.\" without limitation the rights to use, copy, modify, merge, publish,      *
.\" distribute, distribute with modifications, sublicense, and/or sell       *
.\" copies of the Software, and to permit persons to whom the Software is    *
.\" furnished to do so, subject to the following conditions:                 *
.\"                                                                          *
.\" The above copyright notice and this permission notice shall be included  *
.\" in all copies or substantial portions of the Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained in this notice, the name(s) of the above copyright   *
.\" holders shall not be used in advertising or otherwise to promote the     *
.\" sale, use or other dealings in this Software without prior written       *
.\" authorization.                                                           *
.\"***************************************************************************
.\"
.\" $Id: curs_bkgd.3x,v 1.19 2003/12/27 18:50:40 tom Exp $
.TH curs_bkgd 3X ""
.SH NAME
\fBbkgdset\fR, \fBwbkgdset\fR,
\fBbkgd\fR, \fBwbkgd\fR,
\fBgetbkgd\fR - \fBcurses\fR window background manipulation routines
.SH SYNOPSIS
\fB#include <curses.h>\fR
.PP
\fBvoid bkgdset(chtype ch);\fR
.br
\fBvoid wbkgdset(WINDOW *win, chtype ch);\fR
.br
\fBint bkgd(chtype ch);\fR
.br
\fBint wbkgd(WINDOW *win, chtype ch);\fR
.br
\fBchtype getbkgd(WINDOW *win);\fR
.br
.SH DESCRIPTION
The \fBbkgdset\fR and \fBwbkgdset\fR routines manipulate the
background of the named window.
The window background is a \fBchtype\fR consisting of
any combination of attributes (i.e., rendition) and a character.
The attribute part of the background is combined (OR'ed) with all non-blank
characters that are written into the window with \fBwaddch\fR.  Both
the character and attribute parts of the background are combined with
the blank characters.  The background becomes a property of the
character and moves with the character through any scrolling and
insert/delete line/character operations.
.PP
To the extent possible on a particular terminal,
the attribute part of the background is displayed
as the graphic rendition of the character put on the screen.
.PP
The \fBbkgd\fR and \fBwbkgd\fR functions
set the background property of the current or specified window
and then apply this setting to every character position in that window:
.PP
.RS
The rendition of every character on the screen is changed to
the new background rendition.
.PP
Wherever the former background character
appears, it is changed to the new background character.
.RE
.PP
The \fBgetbkgd\fR function returns the given window's current background
character/attribute pair.
.SH RETURN VALUE
The routines \fBbkgd\fR and \fBwbkgd\fR return the integer \fBOK\fR.
The SVr4.0 manual says "or a non-negative integer if \fBimmedok\fR is set",
but this appears to be an error.
.SH NOTES
Note that \fBbkgdset\fR and \fBbkgd\fR may be macros.
.SH PORTABILITY
These functions are described in the XSI Curses standard, Issue 4.
It specifies that \fBbkgd\fR and \fBwbkgd\fR return \fBERR\fR on failure.
but gives no failure conditions.
.SH SEE ALSO
\fBcurses\fR(3X),
\fBcurs_addch\fR(3X),
\fBcurs_attr\fR(3X),
\fBcurs_outopts\fR(3X)
.\"#
.\"# The following sets edit modes for GNU EMACS
.\"# Local Variables:
.\"# mode:nroff
.\"# fill-column:79
.\"# End:
                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bkgrnd.3x                                    0100644 0001750 0001750 00000011066 12566174416 022413  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"***************************************************************************
.\" Copyright (c) 2002-2004,2006 Free Software Foundation, Inc.              *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, to any person obtaining a  *
.\" copy of this software and associated documentation files (the            *
.\" "Software"), to deal in the Software without restriction, including      *
.\" without limitation the rights to use, copy, modify, merge, publish,      *
.\" distribute, distribute with modifications, sublicense, and/or sell       *
.\" copies of the Software, and to permit persons to whom the Software is    *
.\" furnished to do so, subject to the following conditions:                 *
.\"                                                                          *
.\" The above copyright notice and this permission notice shall be included  *
.\" in all copies or substantial portions of the Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained in this notice, the name(s) of the above copyright   *
.\" holders shall not be used in advertising or otherwise to promote the     *
.\" sale, use or other dealings in this Software without prior written       *
.\" authorization.                                                           *
.\"***************************************************************************
.\"
.\" $Id: curs_bkgrnd.3x,v 1.3 2006/02/25 21:49:19 tom Exp $
.TH curs_bkgrnd 3X ""
.SH NAME
\fBbkgrnd\fR,
\fBwbkgrnd\fR,
\fBbkgrndset\fR,
\fBwbkgrndset\fR,
\fBgetbkgrnd\fR,
\fBwgetbkgrnd\fR \- \fBcurses\fR window complex background manipulation routines
.SH SYNOPSIS
.PP
.B #include <curses.h>
.sp
\fBint bkgrnd(\fR\fB const cchar_t *\fR\fIwch\fR\fB);\fR
.br
\fBint wbkgrnd(\fR\fB WINDOW *\fR\fIwin\fR\fB, const cchar_t *\fR\fIwch\fR\fB);\fR
.br
\fBvoid bkgrndset(const cchar_t *\fR\fIwch\fR \fB);\fR
.br
\fBvoid wbkgrndset(WINDOW *\fR\fIwin\fR\fB, const cchar_t *\fR\fIwch\fR\fB);\fR
.br
\fBint getbkgrnd(cchar_t *\fR\fIwch\fR\fB);\fR
.br
\fBint wgetbkgrnd(WINDOW *\fR\fIwin\fR\fB, cchar_t *\fR\fIwch\fR\fB);\fR
.br
.SH DESCRIPTION
The \fBbkgrndset\fR and \fBwbkgrndset\fR routines manipulate the
background of the named window.
The window background is a \fBcchar_t\fR consisting of
any combination of attributes (i.e., rendition) and a complex character.
The attribute part of the background is combined (OR'ed) with all non-blank
characters that are written into the window with \fBwaddch\fR.  Both
the character and attribute parts of the background are combined with
the blank characters.
The background becomes a property of the
character and moves with the character through any scrolling and
insert/delete line/character operations.
.PP
To the extent possible on a
particular terminal, the attribute part of the background is displayed
as the graphic rendition of the character put on the screen.
.PP
The \fBbkgrnd\fR and \fBwbkgrnd\fR functions
set the background property of the current or specified window
and then apply this setting to every character position in that window:
.RS
.PP
The rendition of every character on the screen is changed to
the new background rendition.
.PP
Wherever the former background character
appears, it is changed to the new background character.
.RE
.PP
The \fBgetbkgrnd\fR function returns the given window's current background
character/attribute pair via the \fBwch\fR pointer.
.
.SH NOTES
Note that
\fBbkgrnd\fR,
\fBbkgrndset\fR, and
\fBgetbkgrnd\fR
may be macros.
.SH RETURN VALUES
The \fBbkgrndset\fR and \fBwbkgrndset\fR routines do not return a value.
.PP
Upon successful completion, the other functions return \fBOK\fR.
Otherwise, they return \fBERR\fR.
A null window pointer is treated as an error.
.SH SEE ALSO
\fBcurses\fR(3X),
\fBcurs_bkgd\fR(3X)
.\"#
.\"# The following sets edit modes for GNU EMACS
.\"# Local Variables:
.\"# mode:nroff
.\"# fill-column:79
.\"# End:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bkgrndset.3x                                 0100644 0001750 0001750 00000011066 12566174416 023127  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"***************************************************************************
.\" Copyright (c) 2002-2004,2006 Free Software Foundation, Inc.              *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, to any person obtaining a  *
.\" copy of this software and associated documentation files (the            *
.\" "Software"), to deal in the Software without restriction, including      *
.\" without limitation the rights to use, copy, modify, merge, publish,      *
.\" distribute, distribute with modifications, sublicense, and/or sell       *
.\" copies of the Software, and to permit persons to whom the Software is    *
.\" furnished to do so, subject to the following conditions:                 *
.\"                                                                          *
.\" The above copyright notice and this permission notice shall be included  *
.\" in all copies or substantial portions of the Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained in this notice, the name(s) of the above copyright   *
.\" holders shall not be used in advertising or otherwise to promote the     *
.\" sale, use or other dealings in this Software without prior written       *
.\" authorization.                                                           *
.\"***************************************************************************
.\"
.\" $Id: curs_bkgrnd.3x,v 1.3 2006/02/25 21:49:19 tom Exp $
.TH curs_bkgrnd 3X ""
.SH NAME
\fBbkgrnd\fR,
\fBwbkgrnd\fR,
\fBbkgrndset\fR,
\fBwbkgrndset\fR,
\fBgetbkgrnd\fR,
\fBwgetbkgrnd\fR \- \fBcurses\fR window complex background manipulation routines
.SH SYNOPSIS
.PP
.B #include <curses.h>
.sp
\fBint bkgrnd(\fR\fB const cchar_t *\fR\fIwch\fR\fB);\fR
.br
\fBint wbkgrnd(\fR\fB WINDOW *\fR\fIwin\fR\fB, const cchar_t *\fR\fIwch\fR\fB);\fR
.br
\fBvoid bkgrndset(const cchar_t *\fR\fIwch\fR \fB);\fR
.br
\fBvoid wbkgrndset(WINDOW *\fR\fIwin\fR\fB, const cchar_t *\fR\fIwch\fR\fB);\fR
.br
\fBint getbkgrnd(cchar_t *\fR\fIwch\fR\fB);\fR
.br
\fBint wgetbkgrnd(WINDOW *\fR\fIwin\fR\fB, cchar_t *\fR\fIwch\fR\fB);\fR
.br
.SH DESCRIPTION
The \fBbkgrndset\fR and \fBwbkgrndset\fR routines manipulate the
background of the named window.
The window background is a \fBcchar_t\fR consisting of
any combination of attributes (i.e., rendition) and a complex character.
The attribute part of the background is combined (OR'ed) with all non-blank
characters that are written into the window with \fBwaddch\fR.  Both
the character and attribute parts of the background are combined with
the blank characters.
The background becomes a property of the
character and moves with the character through any scrolling and
insert/delete line/character operations.
.PP
To the extent possible on a
particular terminal, the attribute part of the background is displayed
as the graphic rendition of the character put on the screen.
.PP
The \fBbkgrnd\fR and \fBwbkgrnd\fR functions
set the background property of the current or specified window
and then apply this setting to every character position in that window:
.RS
.PP
The rendition of every character on the screen is changed to
the new background rendition.
.PP
Wherever the former background character
appears, it is changed to the new background character.
.RE
.PP
The \fBgetbkgrnd\fR function returns the given window's current background
character/attribute pair via the \fBwch\fR pointer.
.
.SH NOTES
Note that
\fBbkgrnd\fR,
\fBbkgrndset\fR, and
\fBgetbkgrnd\fR
may be macros.
.SH RETURN VALUES
The \fBbkgrndset\fR and \fBwbkgrndset\fR routines do not return a value.
.PP
Upon successful completion, the other functions return \fBOK\fR.
Otherwise, they return \fBERR\fR.
A null window pointer is treated as an error.
.SH SEE ALSO
\fBcurses\fR(3X),
\fBcurs_bkgd\fR(3X)
.\"#
.\"# The following sets edit modes for GNU EMACS
.\"# Local Variables:
.\"# mode:nroff
.\"# fill-column:79
.\"# End:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/blib.3pm                                     0100644 0001750 0001750 00000011263 12566207465 022221  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "blib 3pm"
.TH blib 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
blib \- Use MakeMaker's uninstalled version of a package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& perl \-Mblib script [args...]
\&
\& perl \-Mblib=dir script [args...]
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Looks for MakeMaker-like \fI'blib'\fR directory structure starting in
\&\fIdir\fR (or current directory) and working back up to five levels of '..'.
.PP
Intended for use on command line with \fB\-M\fR option as a way of testing
arbitrary scripts against an uninstalled version of a package.
.PP
However it is possible to :
.PP
.Vb 3
\& use blib;
\& or
\& use blib \*(Aq..\*(Aq;
.Ve
.PP
etc. if you really must.
.SH "BUGS"
.IX Header "BUGS"
Pollutes global name space for development only task.
.SH "AUTHOR"
.IX Header "AUTHOR"
Nick Ing-Simmons nik@tiuk.ti.com
                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/blib5.16.3pm                                 0100644 0001750 0001750 00000010742 12566207443 022530  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "blib 3pm"
.TH blib 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
blib \- Use MakeMaker's uninstalled version of a package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& perl \-Mblib script [args...]
\&
\& perl \-Mblib=dir script [args...]
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Looks for MakeMaker-like \fI'blib'\fR directory structure starting in
\&\fIdir\fR (or current directory) and working back up to five levels of '..'.
.PP
Intended for use on command line with \fB\-M\fR option as a way of testing
arbitrary scripts against an uninstalled version of a package.
.PP
However it is possible to :
.PP
.Vb 3
\& use blib;
\& or
\& use blib \*(Aq..\*(Aq;
.Ve
.PP
etc. if you really must.
.SH "BUGS"
.IX Header "BUGS"
Pollutes global name space for development only task.
.SH "AUTHOR"
.IX Header "AUTHOR"
Nick Ing-Simmons nik@tiuk.ti.com
                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/blib5.18.3pm                                 0100644 0001750 0001750 00000011263 12566207465 022535  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "blib 3pm"
.TH blib 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
blib \- Use MakeMaker's uninstalled version of a package
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& perl \-Mblib script [args...]
\&
\& perl \-Mblib=dir script [args...]
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Looks for MakeMaker-like \fI'blib'\fR directory structure starting in
\&\fIdir\fR (or current directory) and working back up to five levels of '..'.
.PP
Intended for use on command line with \fB\-M\fR option as a way of testing
arbitrary scripts against an uninstalled version of a package.
.PP
However it is possible to :
.PP
.Vb 3
\& use blib;
\& or
\& use blib \*(Aq..\*(Aq;
.Ve
.PP
etc. if you really must.
.SH "BUGS"
.IX Header "BUGS"
Pollutes global name space for development only task.
.SH "AUTHOR"
.IX Header "AUTHOR"
Nick Ing-Simmons nik@tiuk.ti.com
                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/blowfish.3ssl                                0100644 0001750 0001750 00000022127 12566201144 023300  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "blowfish 3"
.TH blowfish 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
blowfish, BF_set_key, BF_encrypt, BF_decrypt, BF_ecb_encrypt, BF_cbc_encrypt,
BF_cfb64_encrypt, BF_ofb64_encrypt, BF_options \- Blowfish encryption
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/blowfish.h>
\&
\& void BF_set_key(BF_KEY *key, int len, const unsigned char *data);
\&
\& void BF_ecb_encrypt(const unsigned char *in, unsigned char *out,
\&         BF_KEY *key, int enc);
\& void BF_cbc_encrypt(const unsigned char *in, unsigned char *out,
\&         long length, BF_KEY *schedule, unsigned char *ivec, int enc);
\& void BF_cfb64_encrypt(const unsigned char *in, unsigned char *out,
\&         long length, BF_KEY *schedule, unsigned char *ivec, int *num,
\&         int enc);
\& void BF_ofb64_encrypt(const unsigned char *in, unsigned char *out,
\&         long length, BF_KEY *schedule, unsigned char *ivec, int *num);
\& const char *BF_options(void);
\&
\& void BF_encrypt(BF_LONG *data,const BF_KEY *key);
\& void BF_decrypt(BF_LONG *data,const BF_KEY *key);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This library implements the Blowfish cipher, which was invented and described
by Counterpane (see http://www.counterpane.com/blowfish.html ).
.PP
Blowfish is a block cipher that operates on 64 bit (8 byte) blocks of data.
It uses a variable size key, but typically, 128 bit (16 byte) keys are
considered good for strong encryption.  Blowfish can be used in the same
modes as \s-1DES \s0(see \fIdes_modes\fR\|(7)).  Blowfish is currently one
of the faster block ciphers.  It is quite a bit faster than \s-1DES,\s0 and much
faster than \s-1IDEA\s0 or \s-1RC2.\s0
.PP
Blowfish consists of a key setup phase and the actual encryption or decryption
phase.
.PP
\&\fIBF_set_key()\fR sets up the \fB\s-1BF_KEY\s0\fR \fBkey\fR using the \fBlen\fR bytes long key
at \fBdata\fR.
.PP
\&\fIBF_ecb_encrypt()\fR is the basic Blowfish encryption and decryption function.
It encrypts or decrypts the first 64 bits of \fBin\fR using the key \fBkey\fR,
putting the result in \fBout\fR.  \fBenc\fR decides if encryption (\fB\s-1BF_ENCRYPT\s0\fR)
or decryption (\fB\s-1BF_DECRYPT\s0\fR) shall be performed.  The vector pointed at by
\&\fBin\fR and \fBout\fR must be 64 bits in length, no less.  If they are larger,
everything after the first 64 bits is ignored.
.PP
The mode functions \fIBF_cbc_encrypt()\fR, \fIBF_cfb64_encrypt()\fR and \fIBF_ofb64_encrypt()\fR
all operate on variable length data.  They all take an initialization vector
\&\fBivec\fR which needs to be passed along into the next call of the same function 
for the same message.  \fBivec\fR may be initialized with anything, but the
recipient needs to know what it was initialized with, or it won't be able
to decrypt.  Some programs and protocols simplify this, like \s-1SSH,\s0 where
\&\fBivec\fR is simply initialized to zero.
\&\fIBF_cbc_encrypt()\fR operates on data that is a multiple of 8 bytes long, while
\&\fIBF_cfb64_encrypt()\fR and \fIBF_ofb64_encrypt()\fR are used to encrypt an variable
number of bytes (the amount does not have to be an exact multiple of 8).  The
purpose of the latter two is to simulate stream ciphers, and therefore, they
need the parameter \fBnum\fR, which is a pointer to an integer where the current
offset in \fBivec\fR is stored between calls.  This integer must be initialized
to zero when \fBivec\fR is initialized.
.PP
\&\fIBF_cbc_encrypt()\fR is the Cipher Block Chaining function for Blowfish.  It
encrypts or decrypts the 64 bits chunks of \fBin\fR using the key \fBschedule\fR,
putting the result in \fBout\fR.  \fBenc\fR decides if encryption (\s-1BF_ENCRYPT\s0) or
decryption (\s-1BF_DECRYPT\s0) shall be performed.  \fBivec\fR must point at an 8 byte
long initialization vector.
.PP
\&\fIBF_cfb64_encrypt()\fR is the \s-1CFB\s0 mode for Blowfish with 64 bit feedback.
It encrypts or decrypts the bytes in \fBin\fR using the key \fBschedule\fR,
putting the result in \fBout\fR.  \fBenc\fR decides if encryption (\fB\s-1BF_ENCRYPT\s0\fR)
or decryption (\fB\s-1BF_DECRYPT\s0\fR) shall be performed.  \fBivec\fR must point at an
8 byte long initialization vector. \fBnum\fR must point at an integer which must
be initially zero.
.PP
\&\fIBF_ofb64_encrypt()\fR is the \s-1OFB\s0 mode for Blowfish with 64 bit feedback.
It uses the same parameters as \fIBF_cfb64_encrypt()\fR, which must be initialized
the same way.
.PP
\&\fIBF_encrypt()\fR and \fIBF_decrypt()\fR are the lowest level functions for Blowfish
encryption.  They encrypt/decrypt the first 64 bits of the vector pointed by
\&\fBdata\fR, using the key \fBkey\fR.  These functions should not be used unless you
implement 'modes' of Blowfish.  The alternative is to use \fIBF_ecb_encrypt()\fR.
If you still want to use these functions, you should be aware that they take
each 32\-bit chunk in host-byte order, which is little-endian on little-endian
platforms and big-endian on big-endian ones.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
None of the functions presented here return any value.
.SH "NOTE"
.IX Header "NOTE"
Applications should use the higher level functions
\&\fIEVP_EncryptInit\fR\|(3) etc. instead of calling the
blowfish functions directly.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIdes_modes\fR\|(7)
.SH "HISTORY"
.IX Header "HISTORY"
The Blowfish functions are available in all versions of SSLeay and OpenSSL.
                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn.3ssl                                      0100644 0001750 0001750 00000026311 12566201145 022062  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bn 3"
.TH bn 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
bn \- multiprecision integer arithmetics
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/bn.h>
\&
\& BIGNUM *BN_new(void);
\& void BN_free(BIGNUM *a);
\& void BN_init(BIGNUM *);
\& void BN_clear(BIGNUM *a);
\& void BN_clear_free(BIGNUM *a);
\&
\& BN_CTX *BN_CTX_new(void);
\& void BN_CTX_init(BN_CTX *c);
\& void BN_CTX_free(BN_CTX *c);
\&
\& BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b);
\& BIGNUM *BN_dup(const BIGNUM *a);
\&
\& BIGNUM *BN_swap(BIGNUM *a, BIGNUM *b);
\&
\& int BN_num_bytes(const BIGNUM *a);
\& int BN_num_bits(const BIGNUM *a);
\& int BN_num_bits_word(BN_ULONG w);
\&
\& void BN_set_negative(BIGNUM *a, int n);
\& int  BN_is_negative(const BIGNUM *a);
\&
\& int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
\& int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
\& int BN_mul(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);
\& int BN_sqr(BIGNUM *r, BIGNUM *a, BN_CTX *ctx);
\& int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *a, const BIGNUM *d,
\&         BN_CTX *ctx);
\& int BN_mod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
\& int BN_nnmod(BIGNUM *rem, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
\& int BN_mod_add(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,
\&         BN_CTX *ctx);
\& int BN_mod_sub(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,
\&         BN_CTX *ctx);
\& int BN_mod_mul(BIGNUM *ret, BIGNUM *a, BIGNUM *b, const BIGNUM *m,
\&         BN_CTX *ctx);
\& int BN_mod_sqr(BIGNUM *ret, BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
\& int BN_exp(BIGNUM *r, BIGNUM *a, BIGNUM *p, BN_CTX *ctx);
\& int BN_mod_exp(BIGNUM *r, BIGNUM *a, const BIGNUM *p,
\&         const BIGNUM *m, BN_CTX *ctx);
\& int BN_gcd(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);
\&
\& int BN_add_word(BIGNUM *a, BN_ULONG w);
\& int BN_sub_word(BIGNUM *a, BN_ULONG w);
\& int BN_mul_word(BIGNUM *a, BN_ULONG w);
\& BN_ULONG BN_div_word(BIGNUM *a, BN_ULONG w);
\& BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w);
\&
\& int BN_cmp(BIGNUM *a, BIGNUM *b);
\& int BN_ucmp(BIGNUM *a, BIGNUM *b);
\& int BN_is_zero(BIGNUM *a);
\& int BN_is_one(BIGNUM *a);
\& int BN_is_word(BIGNUM *a, BN_ULONG w);
\& int BN_is_odd(BIGNUM *a);
\&
\& int BN_zero(BIGNUM *a);
\& int BN_one(BIGNUM *a);
\& const BIGNUM *BN_value_one(void);
\& int BN_set_word(BIGNUM *a, unsigned long w);
\& unsigned long BN_get_word(BIGNUM *a);
\&
\& int BN_rand(BIGNUM *rnd, int bits, int top, int bottom);
\& int BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom);
\& int BN_rand_range(BIGNUM *rnd, BIGNUM *range);
\& int BN_pseudo_rand_range(BIGNUM *rnd, BIGNUM *range);
\&
\& BIGNUM *BN_generate_prime(BIGNUM *ret, int bits,int safe, BIGNUM *add,
\&         BIGNUM *rem, void (*callback)(int, int, void *), void *cb_arg);
\& int BN_is_prime(const BIGNUM *p, int nchecks,
\&         void (*callback)(int, int, void *), BN_CTX *ctx, void *cb_arg);
\&
\& int BN_set_bit(BIGNUM *a, int n);
\& int BN_clear_bit(BIGNUM *a, int n);
\& int BN_is_bit_set(const BIGNUM *a, int n);
\& int BN_mask_bits(BIGNUM *a, int n);
\& int BN_lshift(BIGNUM *r, const BIGNUM *a, int n);
\& int BN_lshift1(BIGNUM *r, BIGNUM *a);
\& int BN_rshift(BIGNUM *r, BIGNUM *a, int n);
\& int BN_rshift1(BIGNUM *r, BIGNUM *a);
\&
\& int BN_bn2bin(const BIGNUM *a, unsigned char *to);
\& BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret);
\& char *BN_bn2hex(const BIGNUM *a);
\& char *BN_bn2dec(const BIGNUM *a);
\& int BN_hex2bn(BIGNUM **a, const char *str);
\& int BN_dec2bn(BIGNUM **a, const char *str);
\& int BN_print(BIO *fp, const BIGNUM *a);
\& int BN_print_fp(FILE *fp, const BIGNUM *a);
\& int BN_bn2mpi(const BIGNUM *a, unsigned char *to);
\& BIGNUM *BN_mpi2bn(unsigned char *s, int len, BIGNUM *ret);
\&
\& BIGNUM *BN_mod_inverse(BIGNUM *r, BIGNUM *a, const BIGNUM *n,
\&     BN_CTX *ctx);
\&
\& BN_RECP_CTX *BN_RECP_CTX_new(void);
\& void BN_RECP_CTX_init(BN_RECP_CTX *recp);
\& void BN_RECP_CTX_free(BN_RECP_CTX *recp);
\& int BN_RECP_CTX_set(BN_RECP_CTX *recp, const BIGNUM *m, BN_CTX *ctx);
\& int BN_mod_mul_reciprocal(BIGNUM *r, BIGNUM *a, BIGNUM *b,
\&        BN_RECP_CTX *recp, BN_CTX *ctx);
\&
\& BN_MONT_CTX *BN_MONT_CTX_new(void);
\& void BN_MONT_CTX_init(BN_MONT_CTX *ctx);
\& void BN_MONT_CTX_free(BN_MONT_CTX *mont);
\& int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *m, BN_CTX *ctx);
\& BN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from);
\& int BN_mod_mul_montgomery(BIGNUM *r, BIGNUM *a, BIGNUM *b,
\&         BN_MONT_CTX *mont, BN_CTX *ctx);
\& int BN_from_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,
\&         BN_CTX *ctx);
\& int BN_to_montgomery(BIGNUM *r, BIGNUM *a, BN_MONT_CTX *mont,
\&         BN_CTX *ctx);
\&
\& BN_BLINDING *BN_BLINDING_new(const BIGNUM *A, const BIGNUM *Ai,
\&        BIGNUM *mod);
\& void BN_BLINDING_free(BN_BLINDING *b);
\& int BN_BLINDING_update(BN_BLINDING *b,BN_CTX *ctx);
\& int BN_BLINDING_convert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);
\& int BN_BLINDING_invert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);
\& int BN_BLINDING_convert_ex(BIGNUM *n, BIGNUM *r, BN_BLINDING *b,
\&        BN_CTX *ctx);
\& int BN_BLINDING_invert_ex(BIGNUM *n,const BIGNUM *r,BN_BLINDING *b,
\&        BN_CTX *ctx);
\& unsigned long BN_BLINDING_get_thread_id(const BN_BLINDING *);
\& void BN_BLINDING_set_thread_id(BN_BLINDING *, unsigned long);
\& unsigned long BN_BLINDING_get_flags(const BN_BLINDING *);
\& void BN_BLINDING_set_flags(BN_BLINDING *, unsigned long);
\& BN_BLINDING *BN_BLINDING_create_param(BN_BLINDING *b,
\&        const BIGNUM *e, BIGNUM *m, BN_CTX *ctx,
\&        int (*bn_mod_exp)(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
\&                          const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx),
\&        BN_MONT_CTX *m_ctx);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Big Number library is part of libcrypto.  It performs arithmetic operations
on integers of arbitrary size. It was written for use in public key cryptography,
such as \s-1RSA\s0 and Diffie-Hellman.
.PP
It uses dynamic memory allocation for storing its data structures.
That means that there is no limit on the size of the numbers
manipulated by these functions, but return values must always be
checked in case a memory allocation error has occurred.
.PP
The basic object in this library is a \fB\s-1BIGNUM\s0\fR. It is used to hold a
single large integer. This type should be considered opaque and fields
should not be modified or accessed directly.
.PP
The creation of \fB\s-1BIGNUM\s0\fR objects is described in \fIBN_new\fR\|(3);
\&\fIBN_add\fR\|(3) describes most of the arithmetic operations.
Comparison is described in \fIBN_cmp\fR\|(3); \fIBN_zero\fR\|(3)
describes certain assignments, \fIBN_rand\fR\|(3) the generation of
random numbers, \fIBN_generate_prime\fR\|(3) deals with prime
numbers and \fIBN_set_bit\fR\|(3) with bit operations. The conversion
of \fB\s-1BIGNUM\s0\fRs to external formats is described in \fIBN_bn2bin\fR\|(3).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIbn_internal\fR\|(3),
\&\fIdh\fR\|(3), \fIerr\fR\|(3), \fIrand\fR\|(3), \fIrsa\fR\|(3),
\&\fIBN_new\fR\|(3), \fIBN_CTX_new\fR\|(3),
\&\fIBN_copy\fR\|(3), \fIBN_swap\fR\|(3), \fIBN_num_bytes\fR\|(3),
\&\fIBN_add\fR\|(3), \fIBN_add_word\fR\|(3),
\&\fIBN_cmp\fR\|(3), \fIBN_zero\fR\|(3), \fIBN_rand\fR\|(3),
\&\fIBN_generate_prime\fR\|(3), \fIBN_set_bit\fR\|(3),
\&\fIBN_bn2bin\fR\|(3), \fIBN_mod_inverse\fR\|(3),
\&\fIBN_mod_mul_reciprocal\fR\|(3),
\&\fIBN_mod_mul_montgomery\fR\|(3),
\&\fIBN_BLINDING_new\fR\|(3)
                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_add_words.3ssl                            0120777 0001750 0001750 00000000000 12620245063 027203  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_check_top.3ssl                            0120777 0001750 0001750 00000000000 12620245063 027174  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_cmp_words.3ssl                            0120777 0001750 0001750 00000000000 12620245063 027232  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_div_words.3ssl                            0120777 0001750 0001750 00000000000 12620245063 027235  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_dump.3ssl                                 0120777 0001750 0001750 00000000000 12620245063 026202  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_expand.3ssl                               0120777 0001750 0001750 00000000000 12620245063 026514  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_expand2.3ssl                              0120777 0001750 0001750 00000000000 12620245063 026576  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_fix_top.3ssl                              0120777 0001750 0001750 00000000000 12620245063 026705  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_internal.3ssl                             0100644 0001750 0001750 00000035331 12566201145 023760  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bn_internal 3"
.TH bn_internal 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
bn_mul_words, bn_mul_add_words, bn_sqr_words, bn_div_words,
bn_add_words, bn_sub_words, bn_mul_comba4, bn_mul_comba8,
bn_sqr_comba4, bn_sqr_comba8, bn_cmp_words, bn_mul_normal,
bn_mul_low_normal, bn_mul_recursive, bn_mul_part_recursive,
bn_mul_low_recursive, bn_mul_high, bn_sqr_normal, bn_sqr_recursive,
bn_expand, bn_wexpand, bn_expand2, bn_fix_top, bn_check_top,
BN_print, bn_dump, bn_set_max, bn_set_high, bn_set_low \- BIGNUM
library internal functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/bn.h>
\&
\& BN_ULONG bn_mul_words(BN_ULONG *rp, BN_ULONG *ap, int num, BN_ULONG w);
\& BN_ULONG bn_mul_add_words(BN_ULONG *rp, BN_ULONG *ap, int num,
\&   BN_ULONG w);
\& void     bn_sqr_words(BN_ULONG *rp, BN_ULONG *ap, int num);
\& BN_ULONG bn_div_words(BN_ULONG h, BN_ULONG l, BN_ULONG d);
\& BN_ULONG bn_add_words(BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,
\&   int num);
\& BN_ULONG bn_sub_words(BN_ULONG *rp, BN_ULONG *ap, BN_ULONG *bp,
\&   int num);
\&
\& void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);
\& void bn_mul_comba8(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b);
\& void bn_sqr_comba4(BN_ULONG *r, BN_ULONG *a);
\& void bn_sqr_comba8(BN_ULONG *r, BN_ULONG *a);
\&
\& int bn_cmp_words(BN_ULONG *a, BN_ULONG *b, int n);
\&
\& void bn_mul_normal(BN_ULONG *r, BN_ULONG *a, int na, BN_ULONG *b,
\&   int nb);
\& void bn_mul_low_normal(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n);
\& void bn_mul_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, int n2,
\&   int dna,int dnb,BN_ULONG *tmp);
\& void bn_mul_part_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b,
\&   int n, int tna,int tnb, BN_ULONG *tmp);
\& void bn_mul_low_recursive(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b,
\&   int n2, BN_ULONG *tmp);
\& void bn_mul_high(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b, BN_ULONG *l,
\&   int n2, BN_ULONG *tmp);
\&
\& void bn_sqr_normal(BN_ULONG *r, BN_ULONG *a, int n, BN_ULONG *tmp);
\& void bn_sqr_recursive(BN_ULONG *r, BN_ULONG *a, int n2, BN_ULONG *tmp);
\&
\& void mul(BN_ULONG r, BN_ULONG a, BN_ULONG w, BN_ULONG c);
\& void mul_add(BN_ULONG r, BN_ULONG a, BN_ULONG w, BN_ULONG c);
\& void sqr(BN_ULONG r0, BN_ULONG r1, BN_ULONG a);
\&
\& BIGNUM *bn_expand(BIGNUM *a, int bits);
\& BIGNUM *bn_wexpand(BIGNUM *a, int n);
\& BIGNUM *bn_expand2(BIGNUM *a, int n);
\& void bn_fix_top(BIGNUM *a);
\&
\& void bn_check_top(BIGNUM *a);
\& void BN_print(BIGNUM *a);
\& void bn_dump(BN_ULONG *d, int n);
\& void bn_set_max(BIGNUM *a);
\& void bn_set_high(BIGNUM *r, BIGNUM *a, int n);
\& void bn_set_low(BIGNUM *r, BIGNUM *a, int n);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This page documents the internal functions used by the OpenSSL
\&\fB\s-1BIGNUM\s0\fR implementation. They are described here to facilitate
debugging and extending the library. They are \fInot\fR to be used by
applications.
.SS "The \s-1BIGNUM\s0 structure"
.IX Subsection "The BIGNUM structure"
.Vb 1
\& typedef struct bignum_st BIGNUM;
\&
\& struct bignum_st
\&        {
\&        BN_ULONG *d;    /* Pointer to an array of \*(AqBN_BITS2\*(Aq bit chunks. */
\&        int top;        /* Index of last used d +1. */
\&        /* The next are internal book keeping for bn_expand. */
\&        int dmax;       /* Size of the d array. */
\&        int neg;        /* one if the number is negative */
\&        int flags;
\&        };
.Ve
.PP
The integer value is stored in \fBd\fR, a \fImalloc()\fRed array of words (\fB\s-1BN_ULONG\s0\fR),
least significant word first. A \fB\s-1BN_ULONG\s0\fR can be either 16, 32 or 64 bits
in size, depending on the 'number of bits' (\fB\s-1BITS2\s0\fR) specified in
\&\f(CW\*(C`openssl/bn.h\*(C'\fR.
.PP
\&\fBdmax\fR is the size of the \fBd\fR array that has been allocated.  \fBtop\fR
is the number of words being used, so for a value of 4, bn.d[0]=4 and
bn.top=1.  \fBneg\fR is 1 if the number is negative.  When a \fB\s-1BIGNUM\s0\fR is
\&\fB0\fR, the \fBd\fR field can be \fB\s-1NULL\s0\fR and \fBtop\fR == \fB0\fR.
.PP
\&\fBflags\fR is a bit field of flags which are defined in \f(CW\*(C`openssl/bn.h\*(C'\fR. The 
flags begin with \fB\s-1BN_FLG_\s0\fR. The macros BN_set_flags(b,n) and 
BN_get_flags(b,n) exist to enable or fetch flag(s) \fBn\fR from \fB\s-1BIGNUM\s0\fR
structure \fBb\fR.
.PP
Various routines in this library require the use of temporary
\&\fB\s-1BIGNUM\s0\fR variables during their execution.  Since dynamic memory
allocation to create \fB\s-1BIGNUM\s0\fRs is rather expensive when used in
conjunction with repeated subroutine calls, the \fB\s-1BN_CTX\s0\fR structure is
used.  This structure contains \fB\s-1BN_CTX_NUM\s0\fR \fB\s-1BIGNUM\s0\fRs, see
\&\fIBN_CTX_start\fR\|(3).
.SS "Low-level arithmetic operations"
.IX Subsection "Low-level arithmetic operations"
These functions are implemented in C and for several platforms in
assembly language:
.PP
bn_mul_words(\fBrp\fR, \fBap\fR, \fBnum\fR, \fBw\fR) operates on the \fBnum\fR word
arrays \fBrp\fR and \fBap\fR.  It computes \fBap\fR * \fBw\fR, places the result
in \fBrp\fR, and returns the high word (carry).
.PP
bn_mul_add_words(\fBrp\fR, \fBap\fR, \fBnum\fR, \fBw\fR) operates on the \fBnum\fR
word arrays \fBrp\fR and \fBap\fR.  It computes \fBap\fR * \fBw\fR + \fBrp\fR, places
the result in \fBrp\fR, and returns the high word (carry).
.PP
bn_sqr_words(\fBrp\fR, \fBap\fR, \fBn\fR) operates on the \fBnum\fR word array
\&\fBap\fR and the 2*\fBnum\fR word array \fBap\fR.  It computes \fBap\fR * \fBap\fR
word-wise, and places the low and high bytes of the result in \fBrp\fR.
.PP
bn_div_words(\fBh\fR, \fBl\fR, \fBd\fR) divides the two word number (\fBh\fR,\fBl\fR)
by \fBd\fR and returns the result.
.PP
bn_add_words(\fBrp\fR, \fBap\fR, \fBbp\fR, \fBnum\fR) operates on the \fBnum\fR word
arrays \fBap\fR, \fBbp\fR and \fBrp\fR.  It computes \fBap\fR + \fBbp\fR, places the
result in \fBrp\fR, and returns the high word (carry).
.PP
bn_sub_words(\fBrp\fR, \fBap\fR, \fBbp\fR, \fBnum\fR) operates on the \fBnum\fR word
arrays \fBap\fR, \fBbp\fR and \fBrp\fR.  It computes \fBap\fR \- \fBbp\fR, places the
result in \fBrp\fR, and returns the carry (1 if \fBbp\fR > \fBap\fR, 0
otherwise).
.PP
bn_mul_comba4(\fBr\fR, \fBa\fR, \fBb\fR) operates on the 4 word arrays \fBa\fR and
\&\fBb\fR and the 8 word array \fBr\fR.  It computes \fBa\fR*\fBb\fR and places the
result in \fBr\fR.
.PP
bn_mul_comba8(\fBr\fR, \fBa\fR, \fBb\fR) operates on the 8 word arrays \fBa\fR and
\&\fBb\fR and the 16 word array \fBr\fR.  It computes \fBa\fR*\fBb\fR and places the
result in \fBr\fR.
.PP
bn_sqr_comba4(\fBr\fR, \fBa\fR, \fBb\fR) operates on the 4 word arrays \fBa\fR and
\&\fBb\fR and the 8 word array \fBr\fR.
.PP
bn_sqr_comba8(\fBr\fR, \fBa\fR, \fBb\fR) operates on the 8 word arrays \fBa\fR and
\&\fBb\fR and the 16 word array \fBr\fR.
.PP
The following functions are implemented in C:
.PP
bn_cmp_words(\fBa\fR, \fBb\fR, \fBn\fR) operates on the \fBn\fR word arrays \fBa\fR
and \fBb\fR.  It returns 1, 0 and \-1 if \fBa\fR is greater than, equal and
less than \fBb\fR.
.PP
bn_mul_normal(\fBr\fR, \fBa\fR, \fBna\fR, \fBb\fR, \fBnb\fR) operates on the \fBna\fR
word array \fBa\fR, the \fBnb\fR word array \fBb\fR and the \fBna\fR+\fBnb\fR word
array \fBr\fR.  It computes \fBa\fR*\fBb\fR and places the result in \fBr\fR.
.PP
bn_mul_low_normal(\fBr\fR, \fBa\fR, \fBb\fR, \fBn\fR) operates on the \fBn\fR word
arrays \fBr\fR, \fBa\fR and \fBb\fR.  It computes the \fBn\fR low words of
\&\fBa\fR*\fBb\fR and places the result in \fBr\fR.
.PP
bn_mul_recursive(\fBr\fR, \fBa\fR, \fBb\fR, \fBn2\fR, \fBdna\fR, \fBdnb\fR, \fBt\fR) operates
on the word arrays \fBa\fR and \fBb\fR of length \fBn2\fR+\fBdna\fR and \fBn2\fR+\fBdnb\fR
(\fBdna\fR and \fBdnb\fR are currently allowed to be 0 or negative) and the 2*\fBn2\fR
word arrays \fBr\fR and \fBt\fR.  \fBn2\fR must be a power of 2.  It computes
\&\fBa\fR*\fBb\fR and places the result in \fBr\fR.
.PP
bn_mul_part_recursive(\fBr\fR, \fBa\fR, \fBb\fR, \fBn\fR, \fBtna\fR, \fBtnb\fR, \fBtmp\fR)
operates on the word arrays \fBa\fR and \fBb\fR of length \fBn\fR+\fBtna\fR and
\&\fBn\fR+\fBtnb\fR and the 4*\fBn\fR word arrays \fBr\fR and \fBtmp\fR.
.PP
bn_mul_low_recursive(\fBr\fR, \fBa\fR, \fBb\fR, \fBn2\fR, \fBtmp\fR) operates on the
\&\fBn2\fR word arrays \fBr\fR and \fBtmp\fR and the \fBn2\fR/2 word arrays \fBa\fR
and \fBb\fR.
.PP
bn_mul_high(\fBr\fR, \fBa\fR, \fBb\fR, \fBl\fR, \fBn2\fR, \fBtmp\fR) operates on the
\&\fBn2\fR word arrays \fBr\fR, \fBa\fR, \fBb\fR and \fBl\fR (?) and the 3*\fBn2\fR word
array \fBtmp\fR.
.PP
\&\fIBN_mul()\fR calls \fIbn_mul_normal()\fR, or an optimized implementation if the
factors have the same size: \fIbn_mul_comba8()\fR is used if they are 8
words long, \fIbn_mul_recursive()\fR if they are larger than
\&\fB\s-1BN_MULL_SIZE_NORMAL\s0\fR and the size is an exact multiple of the word
size, and \fIbn_mul_part_recursive()\fR for others that are larger than
\&\fB\s-1BN_MULL_SIZE_NORMAL\s0\fR.
.PP
bn_sqr_normal(\fBr\fR, \fBa\fR, \fBn\fR, \fBtmp\fR) operates on the \fBn\fR word array
\&\fBa\fR and the 2*\fBn\fR word arrays \fBtmp\fR and \fBr\fR.
.PP
The implementations use the following macros which, depending on the
architecture, may use \*(L"long long\*(R" C operations or inline assembler.
They are defined in \f(CW\*(C`bn_lcl.h\*(C'\fR.
.PP
mul(\fBr\fR, \fBa\fR, \fBw\fR, \fBc\fR) computes \fBw\fR*\fBa\fR+\fBc\fR and places the
low word of the result in \fBr\fR and the high word in \fBc\fR.
.PP
mul_add(\fBr\fR, \fBa\fR, \fBw\fR, \fBc\fR) computes \fBw\fR*\fBa\fR+\fBr\fR+\fBc\fR and
places the low word of the result in \fBr\fR and the high word in \fBc\fR.
.PP
sqr(\fBr0\fR, \fBr1\fR, \fBa\fR) computes \fBa\fR*\fBa\fR and places the low word
of the result in \fBr0\fR and the high word in \fBr1\fR.
.SS "Size changes"
.IX Subsection "Size changes"
\&\fIbn_expand()\fR ensures that \fBb\fR has enough space for a \fBbits\fR bit
number.  \fIbn_wexpand()\fR ensures that \fBb\fR has enough space for an
\&\fBn\fR word number.  If the number has to be expanded, both macros
call \fIbn_expand2()\fR, which allocates a new \fBd\fR array and copies the
data.  They return \fB\s-1NULL\s0\fR on error, \fBb\fR otherwise.
.PP
The \fIbn_fix_top()\fR macro reduces \fBa\->top\fR to point to the most
significant non-zero word plus one when \fBa\fR has shrunk.
.SS "Debugging"
.IX Subsection "Debugging"
\&\fIbn_check_top()\fR verifies that \f(CW\*(C`((a)\->top >= 0 && (a)\->top
<= (a)\->dmax)\*(C'\fR.  A violation will cause the program to abort.
.PP
\&\fIBN_print()\fR prints \fBa\fR to stderr. \fIbn_dump()\fR prints \fBn\fR words at \fBd\fR
(in reverse order, i.e. most significant word first) to stderr.
.PP
\&\fIbn_set_max()\fR makes \fBa\fR a static number with a \fBdmax\fR of its current size.
This is used by \fIbn_set_low()\fR and \fIbn_set_high()\fR to make \fBr\fR a read-only
\&\fB\s-1BIGNUM\s0\fR that contains the \fBn\fR low or high words of \fBa\fR.
.PP
If \fB\s-1BN_DEBUG\s0\fR is not defined, \fIbn_check_top()\fR, \fIBN_print()\fR, \fIbn_dump()\fR
and \fIbn_set_max()\fR are defined as empty macros.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIbn\fR\|(3)
                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_mul_add_words.3ssl                        0120777 0001750 0001750 00000000000 12620245063 030060  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_mul_comba4.3ssl                           0120777 0001750 0001750 00000000000 12620245063 027257  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_mul_comba8.3ssl                           0120777 0001750 0001750 00000000000 12620245063 027263  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_mul_high.3ssl                             0120777 0001750 0001750 00000000000 12620245063 027031  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_mul_low_normal.3ssl                       0120777 0001750 0001750 00000000000 12620245063 030263  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_mul_low_recursive.3ssl                    0120777 0001750 0001750 00000000000 12620245063 031002  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_mul_normal.3ssl                           0120777 0001750 0001750 00000000000 12620245063 027402  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_mul_part_recursive.3ssl                   0120777 0001750 0001750 00000000000 12620245063 031147  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_mul_recursive.3ssl                        0120777 0001750 0001750 00000000000 12620245063 030121  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_mul_words.3ssl                            0120777 0001750 0001750 00000000000 12620245063 027250  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_set_high.3ssl                             0120777 0001750 0001750 00000000000 12620245063 027027  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_set_low.3ssl                              0120777 0001750 0001750 00000000000 12620245063 026711  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_set_max.3ssl                              0120777 0001750 0001750 00000000000 12620245063 026675  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_sqr_comba4.3ssl                           0120777 0001750 0001750 00000000000 12620245063 027267  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_sqr_comba8.3ssl                           0120777 0001750 0001750 00000000000 12620245063 027273  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_sqr_normal.3ssl                           0120777 0001750 0001750 00000000000 12620245063 027412  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_sqr_recursive.3ssl                        0120777 0001750 0001750 00000000000 12620245063 030131  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_sqr_words.3ssl                            0120777 0001750 0001750 00000000000 12620245063 027260  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_sub_words.3ssl                            0120777 0001750 0001750 00000000000 12620245063 027244  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bn_wexpand.3ssl                              0120777 0001750 0001750 00000000000 12620245063 026703  2bn_internal.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/border.3x                                    0100644 0001750 0001750 00000013027 12566174416 022420  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"***************************************************************************
.\" Copyright (c) 1998-2006,2007 Free Software Foundation, Inc.              *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, to any person obtaining a  *
.\" copy of this software and associated documentation files (the            *
.\" "Software"), to deal in the Software without restriction, including      *
.\" without limitation the rights to use, copy, modify, merge, publish,      *
.\" distribute, distribute with modifications, sublicense, and/or sell       *
.\" copies of the Software, and to permit persons to whom the Software is    *
.\" furnished to do so, subject to the following conditions:                 *
.\"                                                                          *
.\" The above copyright notice and this permission notice shall be included  *
.\" in all copies or substantial portions of the Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained in this notice, the name(s) of the above copyright   *
.\" holders shall not be used in advertising or otherwise to promote the     *
.\" sale, use or other dealings in this Software without prior written       *
.\" authorization.                                                           *
.\"***************************************************************************
.\"
.\" $Id: curs_border.3x,v 1.19 2007/02/24 16:15:38 tom Exp $
.TH curs_border 3X ""
.na
.hy 0
.SH NAME
\fBborder\fR,
\fBwborder\fR,
\fBbox\fR,
\fBhline\fR,
\fBwhline\fR,
\fBvline\fR,
\fBwvline\fR,
\fBmvhline\fR,
\fBmvwhline\fR,
\fBmvvline\fR,
\fBmvwvline\fR - create \fBcurses\fR borders, horizontal and vertical lines
.ad
.hy
.SH SYNOPSIS
\fB#include <curses.h>\fR
.br
\fBint border(chtype ls, chtype rs, chtype ts, chtype bs,\fR
   \fBchtype tl, chtype tr, chtype bl, chtype br);\fR
.br
\fBint wborder(WINDOW *win, chtype ls, chtype rs,\fR
   \fBchtype ts, chtype bs, chtype tl, chtype tr,\fR
   \fBchtype bl, chtype br);\fR
.br
\fBint box(WINDOW *win, chtype verch, chtype horch);\fR
.br
\fBint hline(chtype ch, int n);\fR
.br
\fBint whline(WINDOW *win, chtype ch, int n);\fR
.br
\fBint vline(chtype ch, int n);\fR
.br
\fBint wvline(WINDOW *win, chtype ch, int n);\fR
.br
\fBint mvhline(int y, int x, chtype ch, int n);\fR
.br
\fBint mvwhline(WINDOW *, int y, int x, chtype ch, int n);\fR
.br
\fBint mvvline(int y, int x, chtype ch, int n);\fR
.br
\fBint mvwvline(WINDOW *, int y, int x, chtype ch, int n);\fR
.br
.SH DESCRIPTION
The \fBborder\fR, \fBwborder\fR and \fBbox\fR routines
draw a box around the edges of a window.
Other than the window, each argument is a character with attributes:
.sp
.RS
\fIls\fR - left side,
.br
\fIrs\fR - right side,
.br
\fIts\fR - top side,
.br
\fIbs\fR - bottom side,
.br
\fItl\fR - top left-hand corner,
.br
\fItr\fR - top right-hand corner,
.br
\fIbl\fR - bottom left-hand corner, and
.br
\fIbr\fR - bottom right-hand corner.
.RE
.PP
If any of these arguments is zero, then the corresponding
default values (defined in \fBcurses.h\fR) are used instead:
.sp
.RS
\fBACS_VLINE\fR,
.br
\fBACS_VLINE\fR,
.br
\fBACS_HLINE\fR,
.br
\fBACS_HLINE\fR,
.br
\fBACS_ULCORNER\fR,
.br
\fBACS_URCORNER\fR,
.br
\fBACS_LLCORNER\fR,
.br
\fBACS_LRCORNER\fR.
.RE
.PP
\fBbox(\fR\fIwin\fR\fB, \fR\fIverch\fR\fB, \fR\fIhorch\fR\fB)\fR is a shorthand
for the following call: \fBwborder(\fR\fIwin\fR\fB,\fR \fIverch\fR\fB,\fR
\fIverch\fR\fB,\fR \fIhorch\fR\fB,\fR \fIhorch\fR\fB, 0, 0, 0, 0)\fR.
.PP
The \fBhline\fR and \fBwhline\fR functions draw a horizontal (left to right)
line using \fIch\fR starting at the current cursor position in the window.  The
current cursor position is not changed.  The line is at most \fIn\fR characters
long, or as many as fit into the window.
.PP
The \fBvline\fR and \fBwvline\fR functions draw a vertical (top to bottom) line
using \fIch\fR starting at the current cursor position in the window.  The
current cursor position is not changed.  The line is at most \fIn\fR characters
long, or as many as fit into the window.
.SH RETURN VALUE
All routines return the integer \fBOK\fR.  The SVr4.0 manual says "or a
non-negative integer if \fBimmedok\fR is set", but this appears to be an error.
.PP
X/Open does not define any error conditions.
This implementation returns an error
if the window pointer is null.
.SH NOTES
The borders generated by these functions are \fIinside\fR borders (this
is also true of SVr4 curses, though the fact is not documented).
.PP
Note that \fBborder\fR and \fBbox\fR may be macros.
.SH PORTABILITY
These functions are described in the XSI Curses standard, Issue 4.
The standard specifies that they return \fBERR\fR on failure,
but specifies no error conditions.
.SH SEE ALSO
\fBcurses\fR(3X), \fBcurs_outopts\fR(3X).
.\"#
.\"# The following sets edit modes for GNU EMACS
.\"# Local Variables:
.\"# mode:nroff
.\"# fill-column:79
.\"# End:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/border_set.3x                                0100644 0001750 0001750 00000014616 12566174416 023300  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"***************************************************************************
.\" Copyright (c) 2002-2004,2005 Free Software Foundation, Inc.              *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, to any person obtaining a  *
.\" copy of this software and associated documentation files (the            *
.\" "Software"), to deal in the Software without restriction, including      *
.\" without limitation the rights to use, copy, modify, merge, publish,      *
.\" distribute, distribute with modifications, sublicense, and/or sell       *
.\" copies of the Software, and to permit persons to whom the Software is    *
.\" furnished to do so, subject to the following conditions:                 *
.\"                                                                          *
.\" The above copyright notice and this permission notice shall be included  *
.\" in all copies or substantial portions of the Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained in this notice, the name(s) of the above copyright   *
.\" holders shall not be used in advertising or otherwise to promote the     *
.\" sale, use or other dealings in this Software without prior written       *
.\" authorization.                                                           *
.\"***************************************************************************
.\"
.\" $Id: curs_border_set.3x,v 1.6 2005/05/15 16:17:37 tom Exp $
.TH curs_border_set 3X ""
.na
.hy 0
.SH NAME
\fBborder_set\fR,
\fBwborder_set\fR,
\fBbox_set\fR,
\fBhline_set\fR,
\fBwhline_set\fR,
\fBmvhline_set\fR,
\fBmvwhline_set\fR,
\fBvline_set\fR,
\fBwvline_set\fR,
\fBmvvline_set\fR,
\fBmvwvline_set\fR \- create \fBcurses\fR borders or lines using complex characters and renditions
.ad
.hy
.SH SYNOPSIS
.PP
\fB#include <curses.h>\fR
.sp
\fBint border_set(\fR
   \fBconst cchar_t *\fR\fIls\fR, \fBconst cchar_t *\fR\fIrs\fR,
   \fBconst cchar_t *\fR\fIts\fR, \fBconst cchar_t *\fR\fIbs\fR,
   \fBconst cchar_t *\fR\fItl\fR, \fBconst cchar_t *\fR\fItr\fR,
   \fBconst cchar_t *\fR\fIbl\fR, \fBconst cchar_t *\fR\fIbr\fR
\fB);\fR
.br
\fBint wborder_set(\fR
   \fBWINDOW *win\fR,
   \fBconst cchar_t *\fR\fIls\fR, \fBconst cchar_t *\fR\fIrs\fR,
   \fBconst cchar_t *\fR\fIts\fR, \fBconst cchar_t *\fR\fIbs\fR,
   \fBconst cchar_t *\fR\fItl\fR, \fBconst cchar_t *\fR\fItr\fR,
   \fBconst cchar_t *\fR\fIbl\fR, \fBconst cchar_t *\fR\fIbr\fR\fB);\fR
.br
\fBint box_set(\fR
   \fBWINDOW *win\fR,
   \fBconst cchar_t *\fR\fIverch\fR,
   \fBconst cchar_t *\fR\fIhorch\fR\fB);\fR
.br
\fBint hline_set(\fR
   \fBconst cchar_t *\fR\fIwch\fR, \fBint \fR\fIn\fR\fB);\fR
.br
\fBint whline_set(\fR
   \fBWINDOW *\fR\fIwin\fR,
   \fBconst cchar_t *\fR\fIwch\fR, \fBint \fR\fIn\fR\fB);\fR
.br
\fBint mvhline_set(\fR
   \fBint \fR\fIy\fR, \fBint \fR\fIx\fR,
   \fBconst cchar_t *\fR\fIwch\fR, \fBint \fR\fIn\fR\fB);\fR
.br
\fBint mvwhline_set(\fR
   \fBWINDOW *\fR\fIwin\fR,
   \fBint \fR\fIy\fR, \fBint \fR\fIx\fR,
   \fBconst cchar_t *\fR\fIwch\fR, \fBint \fR\fIn\fR\fB);\fR
.br
\fBint vline_set(\fR
   \fBconst cchar_t *\fR\fIwch\fR, \fBint \fR\fIn\fR\fB);\fR
.br
\fBint wvline_set(\fR
   \fBWINDOW *\fR\fIwin\fR,
   \fBconst cchar_t *\fR\fIwch\fR, \fBint \fR\fIn\fR\fB);\fR
.br
\fBint mvvline_set(\fR
   \fBint \fR\fIy\fR, \fBint \fR\fIx\fR,
   \fBconst cchar_t *\fR\fIwch\fR, \fBint \fR\fIn\fR\fB);\fR
.br
\fBint mvwvline_set(\fR
   \fBWINDOW *\fR\fIwin\fR,
   \fBint \fR\fIy\fR, \fBint \fR\fIx\fR,
   \fBconst cchar_t *\fR\fIwch\fR, \fBint \fR\fIn\fR\fB);\fR
.br
.SH DESCRIPTION
.PP
The
\fBborder_set\fR
and
\fBwborder_set\fR
functions draw a border around the edges of the current or specified window.
These functions do not change the cursor position, and do not wrap.
.PP
Other than the window, each argument is a complex character with attributes:
.RS
\fIls\fR - left side,
.br
\fIrs\fR - right side,
.br
\fIts\fR - top side,
.br
\fIbs\fR - bottom side,
.br
\fItl\fR - top left-hand corner,
.br
\fItr\fR - top right-hand corner,
.br
\fIbl\fR - bottom left-hand corner, and
.br
\fIbr\fR - bottom right-hand corner.
.RE
.PP
If any of these arguments is zero, then the corresponding
default values (defined in \fBcurses.h\fR) are used instead:
.RS
\fBWACS_VLINE\fR,
.br
\fBWACS_VLINE\fR,
.br
\fBWACS_HLINE\fR,
.br
\fBWACS_HLINE\fR,
.br
\fBWACS_ULCORNER\fR,
.br
\fBWACS_URCORNER\fR,
.br
\fBWACS_LLCORNER\fR, and
.br
\fBWACS_LRCORNER\fR.
.RE
.PP
\fBbox_set(\fR\fIwin\fR, \fIverch\fR\fB, \fR\fIhorch\fR\fB);\fR
is a shorthand for the following call:
.PP
\fBwborder_set(\fR\fIwin\fR\fB, \fR\fIverch\fR\fB, \fR\fIverch\fR\fB,\fR
    \fIhorch\fR\fB, \fR\fIhorch\fR\fB, NULL, NULL, NULL, NULL);\fR
.PP
The
\fB*line_set\fR
functions use
\fIwch\fR
to draw a line starting at the current cursor position in the window.
The line is at most \fIn\fR characters long or as many as fit into the window.
The current cursor position is not changed.
.PP
The
\fBhline_set\fR,
\fBmvhline_set\fR,
\fBmvwhline_set\fR, and
\fBwhline_set\fR
functions draw a line proceeding toward the last column of the same line.
.PP
The
\fBvline_set\fR,
\fBmvvline_set\fR,
\fBmvwvline_set\fR, and
\fBwvline_set\fR
functions draw a line proceeding toward the last line of the window.
.br
.SH NOTES
.PP
Note that
\fBborder_set\fR,
\fBhline_set\fR,
\fBmvhline_set\fR,
\fBmvvline_set\fR,
\fBmvwhline_set\fR,
\fBmvwvline_set\fR, and
\fBvline_set\fR
may be macros.
.br
.SH RETURN VALUES
.PP
Upon successful completion, these functions return
\fBOK\fR.
Otherwise, they return
\fBERR\fR.
.PP
Functions using a window parameter return an error if it is null.
.SH SEE ALSO
\fBncurses\fR(3X),
\fBcurs_border\fR(3X),
\fBcurs_outopts\fR(3X)
.\"#
.\"# The following sets edit modes for GNU EMACS
.\"# Local Variables:
.\"# mode:nroff
.\"# fill-column:79
.\"# End:
                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bottom_panel.3x                              0100644 0001750 0001750 00000017314 12566174426 023632  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"***************************************************************************
.\" Copyright (c) 1998-2006,2007 Free Software Foundation, Inc.              *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, to any person obtaining a  *
.\" copy of this software and associated documentation files (the            *
.\" "Software"), to deal in the Software without restriction, including      *
.\" without limitation the rights to use, copy, modify, merge, publish,      *
.\" distribute, distribute with modifications, sublicense, and/or sell       *
.\" copies of the Software, and to permit persons to whom the Software is    *
.\" furnished to do so, subject to the following conditions:                 *
.\"                                                                          *
.\" The above copyright notice and this permission notice shall be included  *
.\" in all copies or substantial portions of the Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained in this notice, the name(s) of the above copyright   *
.\" holders shall not be used in advertising or otherwise to promote the     *
.\" sale, use or other dealings in this Software without prior written       *
.\" authorization.                                                           *
.\"***************************************************************************
.\"
.\" $Id: panel.3x,v 1.14 2007/05/12 20:45:20 tom Exp $
.TH panel 3X ""
.ds n 5
.ds d /usr/share/terminfo
.SH NAME
panel - panel stack extension for curses
.SH SYNOPSIS
\fB#include <panel.h>\fR
.P
\fBcc [flags] sourcefiles -lpanel -lncurses\fR
.P
\fBPANEL *new_panel(WINDOW *win)\fR
.br
\fBint bottom_panel(PANEL *pan)\fR
.br
\fBint top_panel(PANEL *pan)\fR
.br
\fBint show_panel(PANEL *pan)\fR
.br
\fBvoid update_panels();\fR
.br
\fBint hide_panel(PANEL *pan)\fR
.br
\fBWINDOW *panel_window(const PANEL *pan)\fR
.br
\fBint replace_panel(PANEL *pan, WINDOW *window)\fR
.br
\fBint move_panel(PANEL *pan, int starty, int startx)\fR
.br
\fBint panel_hidden(const PANEL *pan)\fR
.br
\fBPANEL *panel_above(const PANEL *pan)\fR
.br
\fBPANEL *panel_below(const PANEL *pan)\fR
.br
\fBint set_panel_userptr(PANEL *pan, const void *ptr)\fR
.br
\fBconst void *panel_userptr(const PANEL *pan)\fR
.br
\fBint del_panel(PANEL *pan)\fR
.br
.SH DESCRIPTION
Panels are \fBcurses\fR(3X) windows with the added feature of
depth.  Panel functions allow the use of stacked windows and ensure
the proper portions of each window and the curses \fBstdscr\fR window are
hidden or displayed when panels are added, moved, modified or removed.
The set of currently visible panels is the stack of panels.  The
\fBstdscr\fR window is beneath all panels, and is not considered part
of the stack.
.P
A window is associated with every panel. The panel routines enable
you to create, move, hide, and show panels, as well as position a
panel at any desired location in the stack.
.P
Panel routines are a functional layer added to \fBcurses\fR(3X), make only
high-level curses calls, and work anywhere terminfo curses does.
.SH FUNCTIONS
.TP
.B new_panel(win)
allocates  a  \fBPANEL\fR structure, associates it with
\fBwin\fR, places the panel on the top of the stack  (causes  it
to  be  displayed above any other panel) and returns a
pointer to the new panel.
.TP
.B update_panels()
refreshes the virtual screen to reflect the relations between the
panels in the stack, but does not call doupdate() to refresh the
physical screen.  Use this function and not wrefresh or wnoutrefresh.
update_panels() may be called more than once before a call to
doupdate(), but doupdate() is the function responsible for updating
the physical screen.
.TP
.B del_panel(pan)
removes the given panel from the  stack and deallocates the
\fBPANEL\fR structure (but not its associated window).
.TP
.B hide_panel(pan)
removes the given panel from the panel stack and thus hides it from
view. The \fBPANEL\fR structure is not lost, merely removed from the stack.
.TP
.B panel_hidden(pan)
returns TRUE if the panel is in the panel stack,
FALSE if it is not.
If the panel is a null pointer, return ERR.
.TP
.B show_panel(pan)
makes a hidden panel visible by placing it on top of the panels in the
panel stack. See COMPATIBILITY below.
.TP
.B top_panel(pan)
puts the given visible panel on top of all panels in the stack.  See
COMPATIBILITY below.
.TP
.B bottom_panel(pan)
puts panel at the bottom of all panels.
.TP
.B move_panel(pan,starty,startx)
moves the given panel window so that its upper-left corner is at
\fBstarty\fR, \fBstartx\fR.  It does not change the position of the
panel in the stack.  Be sure to use this function, not \fBmvwin()\fR,
to move a panel window.
.TP
.B replace_panel(pan,window)
replaces the current window of panel with \fBwindow\fR (useful, for
example if you want to resize a panel; if you're using \fBncurses\fR,
you can call \fBreplace_panel\fR on the output of \fBwresize\fR(3X)).
It does not change the position of the panel in the stack.
.TP
.B panel_above(pan)
returns a pointer to the panel above pan.  If the panel argument is
\fB(PANEL *)0\fR, it returns a pointer to the bottom panel in the stack.
.TP
.B panel_below(pan)
returns a pointer to the panel just below pan.  If the panel argument
is \fB(PANEL *)0\fR, it returns a pointer to the top panel in the stack.
.TP
.B set_panel_userptr(pan,ptr)
sets the panel's user pointer.
.TP
.B panel_userptr(pan)
returns the user pointer for a given panel.
.TP
.B panel_window(pan)
returns a pointer to the window of the given panel.
.SH DIAGNOSTICS
Each routine that returns a pointer returns \fBNULL\fR if an error
occurs. Each routine that returns an int value returns \fBOK\fR if it
executes successfully and \fBERR\fR if not.
.SH COMPATIBILITY
Reasonable care has been taken to  ensure  compatibility
with  the  native  panel facility introduced in SVr3.2 (inspection of
the SVr4 manual pages suggests the programming interface is unchanged).
The \fBPANEL\fR data structures are merely  similar. The  programmer
is cautioned not to directly use \fBPANEL\fR fields.
.P
The functions \fBshow_panel()\fR and \fBtop_panel()\fR are identical
in this implementation, and work equally well with displayed or hidden
panels.  In the native System V implementation, \fBshow_panel()\fR is
intended for making a hidden panel visible (at the top of the stack)
and \fBtop_panel()\fR is intended for making an already-visible panel
move to the top of the stack. You are cautioned to use the correct
function to ensure compatibility with native panel libraries.
.SH NOTE
In your library list, libpanel.a should be before libncurses.a; that is,
you want to say `-lpanel -lncurses', not the other way around (which would
usually give a link-error).
.SH FILES
.P
panel.h
interface for the panels library
.P
libpanel.a
the panels library itself
.SH SEE ALSO
\fBcurses\fR(3X)
.PP
This describes \fBncurses\fR
version 5.7 (patch 20081102).
.SH AUTHOR
Originally written by Warren Tucker <wht@n4hgf.mt-park.ga.us>,
primarily to assist in porting u386mon to systems without a native
panels library.  Repackaged for ncurses by Zeyd ben-Halim.
                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/box.3x                                       0100644 0001750 0001750 00000013027 12566174416 021733  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"***************************************************************************
.\" Copyright (c) 1998-2006,2007 Free Software Foundation, Inc.              *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, to any person obtaining a  *
.\" copy of this software and associated documentation files (the            *
.\" "Software"), to deal in the Software without restriction, including      *
.\" without limitation the rights to use, copy, modify, merge, publish,      *
.\" distribute, distribute with modifications, sublicense, and/or sell       *
.\" copies of the Software, and to permit persons to whom the Software is    *
.\" furnished to do so, subject to the following conditions:                 *
.\"                                                                          *
.\" The above copyright notice and this permission notice shall be included  *
.\" in all copies or substantial portions of the Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained in this notice, the name(s) of the above copyright   *
.\" holders shall not be used in advertising or otherwise to promote the     *
.\" sale, use or other dealings in this Software without prior written       *
.\" authorization.                                                           *
.\"***************************************************************************
.\"
.\" $Id: curs_border.3x,v 1.19 2007/02/24 16:15:38 tom Exp $
.TH curs_border 3X ""
.na
.hy 0
.SH NAME
\fBborder\fR,
\fBwborder\fR,
\fBbox\fR,
\fBhline\fR,
\fBwhline\fR,
\fBvline\fR,
\fBwvline\fR,
\fBmvhline\fR,
\fBmvwhline\fR,
\fBmvvline\fR,
\fBmvwvline\fR - create \fBcurses\fR borders, horizontal and vertical lines
.ad
.hy
.SH SYNOPSIS
\fB#include <curses.h>\fR
.br
\fBint border(chtype ls, chtype rs, chtype ts, chtype bs,\fR
   \fBchtype tl, chtype tr, chtype bl, chtype br);\fR
.br
\fBint wborder(WINDOW *win, chtype ls, chtype rs,\fR
   \fBchtype ts, chtype bs, chtype tl, chtype tr,\fR
   \fBchtype bl, chtype br);\fR
.br
\fBint box(WINDOW *win, chtype verch, chtype horch);\fR
.br
\fBint hline(chtype ch, int n);\fR
.br
\fBint whline(WINDOW *win, chtype ch, int n);\fR
.br
\fBint vline(chtype ch, int n);\fR
.br
\fBint wvline(WINDOW *win, chtype ch, int n);\fR
.br
\fBint mvhline(int y, int x, chtype ch, int n);\fR
.br
\fBint mvwhline(WINDOW *, int y, int x, chtype ch, int n);\fR
.br
\fBint mvvline(int y, int x, chtype ch, int n);\fR
.br
\fBint mvwvline(WINDOW *, int y, int x, chtype ch, int n);\fR
.br
.SH DESCRIPTION
The \fBborder\fR, \fBwborder\fR and \fBbox\fR routines
draw a box around the edges of a window.
Other than the window, each argument is a character with attributes:
.sp
.RS
\fIls\fR - left side,
.br
\fIrs\fR - right side,
.br
\fIts\fR - top side,
.br
\fIbs\fR - bottom side,
.br
\fItl\fR - top left-hand corner,
.br
\fItr\fR - top right-hand corner,
.br
\fIbl\fR - bottom left-hand corner, and
.br
\fIbr\fR - bottom right-hand corner.
.RE
.PP
If any of these arguments is zero, then the corresponding
default values (defined in \fBcurses.h\fR) are used instead:
.sp
.RS
\fBACS_VLINE\fR,
.br
\fBACS_VLINE\fR,
.br
\fBACS_HLINE\fR,
.br
\fBACS_HLINE\fR,
.br
\fBACS_ULCORNER\fR,
.br
\fBACS_URCORNER\fR,
.br
\fBACS_LLCORNER\fR,
.br
\fBACS_LRCORNER\fR.
.RE
.PP
\fBbox(\fR\fIwin\fR\fB, \fR\fIverch\fR\fB, \fR\fIhorch\fR\fB)\fR is a shorthand
for the following call: \fBwborder(\fR\fIwin\fR\fB,\fR \fIverch\fR\fB,\fR
\fIverch\fR\fB,\fR \fIhorch\fR\fB,\fR \fIhorch\fR\fB, 0, 0, 0, 0)\fR.
.PP
The \fBhline\fR and \fBwhline\fR functions draw a horizontal (left to right)
line using \fIch\fR starting at the current cursor position in the window.  The
current cursor position is not changed.  The line is at most \fIn\fR characters
long, or as many as fit into the window.
.PP
The \fBvline\fR and \fBwvline\fR functions draw a vertical (top to bottom) line
using \fIch\fR starting at the current cursor position in the window.  The
current cursor position is not changed.  The line is at most \fIn\fR characters
long, or as many as fit into the window.
.SH RETURN VALUE
All routines return the integer \fBOK\fR.  The SVr4.0 manual says "or a
non-negative integer if \fBimmedok\fR is set", but this appears to be an error.
.PP
X/Open does not define any error conditions.
This implementation returns an error
if the window pointer is null.
.SH NOTES
The borders generated by these functions are \fIinside\fR borders (this
is also true of SVr4 curses, though the fact is not documented).
.PP
Note that \fBborder\fR and \fBbox\fR may be macros.
.SH PORTABILITY
These functions are described in the XSI Curses standard, Issue 4.
The standard specifies that they return \fBERR\fR on failure,
but specifies no error conditions.
.SH SEE ALSO
\fBcurses\fR(3X), \fBcurs_outopts\fR(3X).
.\"#
.\"# The following sets edit modes for GNU EMACS
.\"# Local Variables:
.\"# mode:nroff
.\"# fill-column:79
.\"# End:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/box_set.3x                                   0100644 0001750 0001750 00000014616 12566174416 022613  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"***************************************************************************
.\" Copyright (c) 2002-2004,2005 Free Software Foundation, Inc.              *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, to any person obtaining a  *
.\" copy of this software and associated documentation files (the            *
.\" "Software"), to deal in the Software without restriction, including      *
.\" without limitation the rights to use, copy, modify, merge, publish,      *
.\" distribute, distribute with modifications, sublicense, and/or sell       *
.\" copies of the Software, and to permit persons to whom the Software is    *
.\" furnished to do so, subject to the following conditions:                 *
.\"                                                                          *
.\" The above copyright notice and this permission notice shall be included  *
.\" in all copies or substantial portions of the Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained in this notice, the name(s) of the above copyright   *
.\" holders shall not be used in advertising or otherwise to promote the     *
.\" sale, use or other dealings in this Software without prior written       *
.\" authorization.                                                           *
.\"***************************************************************************
.\"
.\" $Id: curs_border_set.3x,v 1.6 2005/05/15 16:17:37 tom Exp $
.TH curs_border_set 3X ""
.na
.hy 0
.SH NAME
\fBborder_set\fR,
\fBwborder_set\fR,
\fBbox_set\fR,
\fBhline_set\fR,
\fBwhline_set\fR,
\fBmvhline_set\fR,
\fBmvwhline_set\fR,
\fBvline_set\fR,
\fBwvline_set\fR,
\fBmvvline_set\fR,
\fBmvwvline_set\fR \- create \fBcurses\fR borders or lines using complex characters and renditions
.ad
.hy
.SH SYNOPSIS
.PP
\fB#include <curses.h>\fR
.sp
\fBint border_set(\fR
   \fBconst cchar_t *\fR\fIls\fR, \fBconst cchar_t *\fR\fIrs\fR,
   \fBconst cchar_t *\fR\fIts\fR, \fBconst cchar_t *\fR\fIbs\fR,
   \fBconst cchar_t *\fR\fItl\fR, \fBconst cchar_t *\fR\fItr\fR,
   \fBconst cchar_t *\fR\fIbl\fR, \fBconst cchar_t *\fR\fIbr\fR
\fB);\fR
.br
\fBint wborder_set(\fR
   \fBWINDOW *win\fR,
   \fBconst cchar_t *\fR\fIls\fR, \fBconst cchar_t *\fR\fIrs\fR,
   \fBconst cchar_t *\fR\fIts\fR, \fBconst cchar_t *\fR\fIbs\fR,
   \fBconst cchar_t *\fR\fItl\fR, \fBconst cchar_t *\fR\fItr\fR,
   \fBconst cchar_t *\fR\fIbl\fR, \fBconst cchar_t *\fR\fIbr\fR\fB);\fR
.br
\fBint box_set(\fR
   \fBWINDOW *win\fR,
   \fBconst cchar_t *\fR\fIverch\fR,
   \fBconst cchar_t *\fR\fIhorch\fR\fB);\fR
.br
\fBint hline_set(\fR
   \fBconst cchar_t *\fR\fIwch\fR, \fBint \fR\fIn\fR\fB);\fR
.br
\fBint whline_set(\fR
   \fBWINDOW *\fR\fIwin\fR,
   \fBconst cchar_t *\fR\fIwch\fR, \fBint \fR\fIn\fR\fB);\fR
.br
\fBint mvhline_set(\fR
   \fBint \fR\fIy\fR, \fBint \fR\fIx\fR,
   \fBconst cchar_t *\fR\fIwch\fR, \fBint \fR\fIn\fR\fB);\fR
.br
\fBint mvwhline_set(\fR
   \fBWINDOW *\fR\fIwin\fR,
   \fBint \fR\fIy\fR, \fBint \fR\fIx\fR,
   \fBconst cchar_t *\fR\fIwch\fR, \fBint \fR\fIn\fR\fB);\fR
.br
\fBint vline_set(\fR
   \fBconst cchar_t *\fR\fIwch\fR, \fBint \fR\fIn\fR\fB);\fR
.br
\fBint wvline_set(\fR
   \fBWINDOW *\fR\fIwin\fR,
   \fBconst cchar_t *\fR\fIwch\fR, \fBint \fR\fIn\fR\fB);\fR
.br
\fBint mvvline_set(\fR
   \fBint \fR\fIy\fR, \fBint \fR\fIx\fR,
   \fBconst cchar_t *\fR\fIwch\fR, \fBint \fR\fIn\fR\fB);\fR
.br
\fBint mvwvline_set(\fR
   \fBWINDOW *\fR\fIwin\fR,
   \fBint \fR\fIy\fR, \fBint \fR\fIx\fR,
   \fBconst cchar_t *\fR\fIwch\fR, \fBint \fR\fIn\fR\fB);\fR
.br
.SH DESCRIPTION
.PP
The
\fBborder_set\fR
and
\fBwborder_set\fR
functions draw a border around the edges of the current or specified window.
These functions do not change the cursor position, and do not wrap.
.PP
Other than the window, each argument is a complex character with attributes:
.RS
\fIls\fR - left side,
.br
\fIrs\fR - right side,
.br
\fIts\fR - top side,
.br
\fIbs\fR - bottom side,
.br
\fItl\fR - top left-hand corner,
.br
\fItr\fR - top right-hand corner,
.br
\fIbl\fR - bottom left-hand corner, and
.br
\fIbr\fR - bottom right-hand corner.
.RE
.PP
If any of these arguments is zero, then the corresponding
default values (defined in \fBcurses.h\fR) are used instead:
.RS
\fBWACS_VLINE\fR,
.br
\fBWACS_VLINE\fR,
.br
\fBWACS_HLINE\fR,
.br
\fBWACS_HLINE\fR,
.br
\fBWACS_ULCORNER\fR,
.br
\fBWACS_URCORNER\fR,
.br
\fBWACS_LLCORNER\fR, and
.br
\fBWACS_LRCORNER\fR.
.RE
.PP
\fBbox_set(\fR\fIwin\fR, \fIverch\fR\fB, \fR\fIhorch\fR\fB);\fR
is a shorthand for the following call:
.PP
\fBwborder_set(\fR\fIwin\fR\fB, \fR\fIverch\fR\fB, \fR\fIverch\fR\fB,\fR
    \fIhorch\fR\fB, \fR\fIhorch\fR\fB, NULL, NULL, NULL, NULL);\fR
.PP
The
\fB*line_set\fR
functions use
\fIwch\fR
to draw a line starting at the current cursor position in the window.
The line is at most \fIn\fR characters long or as many as fit into the window.
The current cursor position is not changed.
.PP
The
\fBhline_set\fR,
\fBmvhline_set\fR,
\fBmvwhline_set\fR, and
\fBwhline_set\fR
functions draw a line proceeding toward the last column of the same line.
.PP
The
\fBvline_set\fR,
\fBmvvline_set\fR,
\fBmvwvline_set\fR, and
\fBwvline_set\fR
functions draw a line proceeding toward the last line of the window.
.br
.SH NOTES
.PP
Note that
\fBborder_set\fR,
\fBhline_set\fR,
\fBmvhline_set\fR,
\fBmvvline_set\fR,
\fBmvwhline_set\fR,
\fBmvwvline_set\fR, and
\fBvline_set\fR
may be macros.
.br
.SH RETURN VALUES
.PP
Upon successful completion, these functions return
\fBOK\fR.
Otherwise, they return
\fBERR\fR.
.PP
Functions using a window parameter return an error if it is null.
.SH SEE ALSO
\fBncurses\fR(3X),
\fBcurs_border\fR(3X),
\fBcurs_outopts\fR(3X)
.\"#
.\"# The following sets edit modes for GNU EMACS
.\"# Local Variables:
.\"# mode:nroff
.\"# fill-column:79
.\"# End:
                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bsd_signal.3                                 0100644 0001750 0001750 00000006116 12566166140 023054  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2002 Apple Computer, Inc.  All rights reserved.
.\"
.\" @APPLE_LICENSE_HEADER_START@
.\"
.\" The contents of this file constitute Original Code as defined in and
.\" are subject to the Apple Public Source License Version 1.1 (the
.\" "License").  You may not use this file except in compliance with the
.\" License.  Please obtain a copy of the License at
.\" http://www.apple.com/publicsource and read it before using this file.
.\"
.\" This Original Code and all software distributed under the License are
.\" distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
.\" EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
.\" INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
.\" FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
.\" License for the specific language governing rights and limitations
.\" under the License.
.\"
.\" @APPLE_LICENSE_HEADER_END@
.\"
.Dd December 20, 2003
.Dt BSD_SIGNAL 3
.Os
.Sh NAME
.Nm bsd_signal
.Nd simplified signal facilities
.Sh SYNOPSIS
.In signal.h
.\" The following is Quite Ugly, but syntactically correct.  Don't try to
.\" fix it.
.Ft void \*(lp*
.Fn bsd_signal "int sig" "void \*(lp*func\*(rp\*(lpint\*(rp\*(rp\*(rp\*(lpint"
.Pp
or in an equivalent but easier to read typedef'd version:
.Ft typedef "void \*(lp*sig_t\*(rp \*(lpint\*(rp" ;
.Ft sig_t
.Fn bsd_signal "int sig" "sig_t func"
.Sh DESCRIPTION
The
.Fn bsd_signal
function provides a partially compatible interface for programs written
to historical system interfaces (see USAGE below).
.Pp
The function call
.Fn bsd_signal sig func
has the effect as if implemented as:
.Bd -literal -offset indent
void (*bsd_signal(int sig, void (*func)(int)))(int)
{
    struct sigaction act, oact;

    act.sa_handler = func;
    act.sa_flags = SA_RESTART;
    sigemptyset(&act.sa_mask);
    sigaddset(&act.sa_mask, sig);
    if (sigaction(sig, &act, &oact) == -1)
	return(SIG_ERR);
    return(oact.sa_handler);
}
.Ed
.Pp
The handler function should be declared:
.Pp
.D1 Fn "void func" "int sig"
.Pp
where
.Fa sig
is the signal number.
The behavior is undefined if
.Fn func
is a function that takes more than one argument, or an argument of a
different type.
.Sh RETURN VALUES
Upon successful completion,
.Fn bsd_signal
returns the previous action for
.Fa sig .
Otherwise,
.Er SIG_ERR
is returned and
.Va errno
is set to indicate the error.
.Sh ERRORS
Refer to
.Xr sigaction 2 .
.Sh USAGE
This function is a direct replacement for the
.Bx
.Xr signal(3)
function for simple applications that are installing a single-argument signal
handler function.
If a
.Bx
signal handler function is being installed that expects more than one
argument, the application has to be modified to use
.Xr sigaction 2 .
The
.Fn bsd_signal
function differs from
.Xr signal 3
in that the
.Dv SA_RESTART
flag is set and the
.Dv SA_RESETHAND
will be clear when
.Fn bsd_signal
is used.
The state of these flags is not specified for
.Xr signal 3 .
.Sh SEE ALSO
.Xr sigaction 2 ,
.Xr sigaddset 3 ,
.Xr sigemptyset 3 ,
.Xr signal 3
.Sh STANDARDS
The
.Fn bsd_signal
function conforms to
.St -p1003.1-2001 .
                                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bsearch.3                                    0100644 0001750 0001750 00000006715 12566166140 022363  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 1990, 1991, 1993, 1994
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" the American National Standards Committee X3, on Information
.\" Processing Systems.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @(#)bsearch.3	8.3 (Berkeley) 4/19/94
.\" $FreeBSD: src/lib/libc/stdlib/bsearch.3,v 1.9 2007/01/09 00:28:09 imp Exp $
.\"
.Dd May 20, 2008
.Dt BSEARCH 3
.Os
.Sh NAME
.Nm bsearch ,
.Nm bsearch_b
.Nd binary search of a sorted table
.Sh SYNOPSIS
.In stdlib.h
.Ft void *
.Fn bsearch "const void *key" "const void *base" "size_t nel" "size_t width" "int (*compar) (const void *, const void *)"
.Ft void *
.Fn bsearch_b "const void *key" "const void *base" "size_t nel" "size_t width" "int (^compar) (const void *, const void *)"
.Sh DESCRIPTION
The
.Fn bsearch
function searches an array of
.Fa nel
objects, the initial member of which is
pointed to by
.Fa base ,
for a member that matches the object pointed to by
.Fa key .
The size (in bytes) of each member of the array is specified by
.Fa width .
.Pp
The contents of the array should be in ascending sorted order according
to the comparison function referenced by
.Fa compar .
The
.Fa compar
routine
is expected to have
two arguments which point to the
.Fa key
object and to an array member, in that order.
It should return an integer which is
less than, equal to, or greater than zero if the
.Fa key
object is found, respectively, to be less than, to match, or be
greater than the array member.
.Pp
The
.Fn bsearch_b
function is like
.Fn bsearch
except the callback
.Fa compar
is a block pointer instead of a function pointer.
.Sh RETURN VALUES
The
.Fn bsearch
and
.Fn bsearch_b
functions
returns a pointer to a matching member of the array, or a null
pointer if no match is found.
If two members compare as equal, which member is matched is unspecified.
.Sh SEE ALSO
.Xr db 3 ,
.Xr lsearch 3 ,
.Xr qsort 3
.\" .Xr tsearch 3
.Sh STANDARDS
The
.Fn bsearch
function conforms to
.St -isoC .
                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bsearch_b.3                                  0120777 0001750 0001750 00000000000 12620245063 024336  2bsearch.3                                                                                           ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bstring.3                                    0100644 0001750 0001750 00000006726 12566166140 022426  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 1990, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" Chris Torek.
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @(#)bstring.3	8.1 (Berkeley) 6/4/93
.\" $FreeBSD: src/lib/libc/string/bstring.3,v 1.8 2007/01/09 00:28:11 imp Exp $
.\"
.Dd June 4, 1993
.Dt BSTRING 3
.Os
.Sh NAME
.Nm bcmp ,
.Nm bcopy ,
.Nm bzero ,
.Nm memccpy ,
.Nm memchr ,
.Nm memcmp ,
.Nm memcpy ,
.Nm memmove ,
.Nm memset
.Nd byte string operations
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In strings.h
.Ft int
.Fo bcmp
.Fa "const void *s1"
.Fa "const void *s2"
.Fa "size_t n"
.Fc
.Ft void
.Fo bcopy
.Fa "const void *s1"
.Fa "void *s2"
.Fa "size_t n"
.Fc
.Ft void
.Fo bzero
.Fa "void *s"
.Fa "size_t n"
.Fc
.In string.h
.Ft void *
.Fo memccpy
.Fa "void *restrict s1"
.Fa "const void *restrict s2"
.Fa "int c"
.Fa "size_t n"
.Fc
.Ft void *
.Fo memchr
.Fa "const void *s"
.Fa "int c"
.Fa "size_t n"
.Fc
.Ft int
.Fo memcmp
.Fa "const void *s1"
.Fa "const void *s2"
.Fa "size_t n"
.Fc
.Ft void *
.Fo memcpy
.Fa "void *restrict s1"
.Fa "const void *restrict s2"
.Fa "size_t n"
.Fc
.Ft void *
.Fo memmove
.Fa "void *s1"
.Fa "const void *s2"
.Fa "size_t n"
.Fc
.Ft void *
.Fo memset
.Fa "void *s"
.Fa "int c"
.Fa "size_t n"
.Fc
.Sh DESCRIPTION
These functions operate on variable length strings of bytes.
They do not check for terminating null bytes, as the routines
listed in
.Xr string 3
do.
.Pp
See the specific manual pages for more information.
.Sh LEGACY SYNOPSIS
.Fd #include <string.h>
.Pp
The include file
.In string.h
is necessary and sufficient for all functions.
.Sh SEE ALSO
.Xr bcmp 3 ,
.Xr bcopy 3 ,
.Xr bzero 3 ,
.Xr memccpy 3 ,
.Xr memchr 3 ,
.Xr memcmp 3 ,
.Xr memcpy 3 ,
.Xr memmove 3 ,
.Xr memset 3 ,
.Xr compat 5
.Sh STANDARDS
The functions
.Fn memchr ,
.Fn memcmp ,
.Fn memcpy ,
.Fn memmove ,
and
.Fn memset
conform to
.St -isoC .
.Sh HISTORY
The functions
.Fn bzero
and
.Fn memccpy
appeared in
.Bx 4.3 ;
the functions
.Fn bcmp ,
.Fn bcopy ,
appeared in
.Bx 4.2 .
                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/btowc.3                                      0100644 0001750 0001750 00000005443 12566166140 022067  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2002 Tim J. Robbins
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\" $FreeBSD: src/lib/libc/locale/btowc.3,v 1.2 2002/11/10 11:14:58 tjr Exp $
.\"
.Dd August 3, 2002
.Dt BTOWC 3
.Os
.Sh NAME
.Nm btowc ,
.Nm btowc_l ,
.Nm wctob ,
.Nm wctob_l
.Nd "convert between wide and single-byte characters"
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In stdio.h
.In wchar.h
.Ft wint_t
.Fo btowc
.Fa "int c"
.Fc
.Ft int
.Fo wctob
.Fa "wint_t c"
.Fc
.In wchar.h
.In xlocale.h
.Ft wint_t
.Fo btowc_l
.Fa "int c"
.Fa "locale_t loc"
.Fc
.Ft int
.Fo wctob_l
.Fa "wint_t c"
.Fa "locale_t loc"
.Fc
.Sh DESCRIPTION
The
.Fn btowc
function converts a single-byte character into a corresponding wide character.
If the character is
.Dv EOF
or not valid in the initial shift state,
.Fn btowc
returns
.Dv WEOF .
.Pp
The
.Fn wctob
function converts a wide character into a corresponding single-byte character.
If the wide character is
.Dv WEOF
or not able to be represented as a single byte in the initial shift state,
.Fn wctob
returns
.Dv WEOF .
.Pp
While the
.Fn btowc
and
.Fn wctob
functions use the current locale, the
.Fn btowc_l
and
.Fn wctob_l
functions may be passed locales directly. See
.Xr xlocale 3
for more information.
.Sh LEGACY SYNOPSIS
.Pp
The include file
.In stdio.h
is not necessary for these functions.
.Sh SEE ALSO
.Xr mbrtowc 3 ,
.Xr multibyte 3 ,
.Xr wcrtomb 3 ,
.Xr xlocale 3 ,
.Xr compat 5
.Sh STANDARDS
The
.Fn btowc
and
.Fn wctob
functions conform to
.St -p1003.1-2001 .
.Sh HISTORY
The
.Fn btowc
and
.Fn wctob
functions first appeared in
.Fx 5.0 .
                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/btowc_l.3                                    0120777 0001750 0001750 00000000000 12620245063 023566  2btowc.3                                                                                             ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/btree.3                                      0100644 0001750 0001750 00000020233 12566166140 022044  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 1990, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"	@(#)btree.3	8.4 (Berkeley) 8/18/94
.\" $FreeBSD: src/lib/libc/db/man/btree.3,v 1.9 2007/01/09 00:27:51 imp Exp $
.\"
.Dd August 18, 1994
.Dt BTREE 3
.Os
.Sh NAME
.Nm btree
.Nd "btree database access method"
.Sh SYNOPSIS
.In sys/types.h
.In db.h
.Sh DESCRIPTION
The routine
.Fn dbopen
is the library interface to database files.
One of the supported file formats is
.Nm
files.
The general description of the database access methods is in
.Xr dbopen 3 ,
this manual page describes only the
.Nm
specific information.
.Pp
The
.Nm
data structure is a sorted, balanced tree structure storing
associated key/data pairs.
.Pp
The
.Nm
access method specific data structure provided to
.Fn dbopen
is defined in the
.In db.h
include file as follows:
.Bd -literal
typedef struct {
	u_long flags;
	u_int cachesize;
	int maxkeypage;
	int minkeypage;
	u_int psize;
	int (*compare)(const DBT *key1, const DBT *key2);
	size_t (*prefix)(const DBT *key1, const DBT *key2);
	int lorder;
} BTREEINFO;
.Ed
.Pp
The elements of this structure are as follows:
.Bl -tag -width indent
.It Va flags
The flag value is specified by
.Em or Ns 'ing
any of the following values:
.Bl -tag -width indent
.It Dv R_DUP
Permit duplicate keys in the tree, i.e., permit insertion if the key to be
inserted already exists in the tree.
The default behavior, as described in
.Xr dbopen 3 ,
is to overwrite a matching key when inserting a new key or to fail if
the
.Dv R_NOOVERWRITE
flag is specified.
The
.Dv R_DUP
flag is overridden by the
.Dv R_NOOVERWRITE
flag, and if the
.Dv R_NOOVERWRITE
flag is specified, attempts to insert duplicate keys into
the tree will fail.
.Pp
If the database contains duplicate keys, the order of retrieval of
key/data pairs is undefined if the
.Va get
routine is used, however,
.Va seq
routine calls with the
.Dv R_CURSOR
flag set will always return the logical
.Dq first
of any group of duplicate keys.
.El
.It Va cachesize
A suggested maximum size (in bytes) of the memory cache.
This value is
.Em only
advisory, and the access method will allocate more memory rather than fail.
Since every search examines the root page of the tree, caching the most
recently used pages substantially improves access time.
In addition, physical writes are delayed as long as possible, so a moderate
cache can reduce the number of I/O operations significantly.
Obviously, using a cache increases (but only increases) the likelihood of
corruption or lost data if the system crashes while a tree is being modified.
If
.Va cachesize
is 0 (no size is specified) a default cache is used.
.It Va maxkeypage
The maximum number of keys which will be stored on any single page.
Not currently implemented.
.\" The maximum number of keys which will be stored on any single page.
.\" Because of the way the
.\" .Nm
.\" data structure works,
.\" .Va maxkeypage
.\" must always be greater than or equal to 2.
.\" If
.\" .Va maxkeypage
.\" is 0 (no maximum number of keys is specified) the page fill factor is
.\" made as large as possible (which is almost invariably what is wanted).
.It Va minkeypage
The minimum number of keys which will be stored on any single page.
This value is used to determine which keys will be stored on overflow
pages, i.e., if a key or data item is longer than the pagesize divided
by the minkeypage value, it will be stored on overflow pages instead
of in the page itself.
If
.Va minkeypage
is 0 (no minimum number of keys is specified) a value of 2 is used.
.It Va psize
Page size is the size (in bytes) of the pages used for nodes in the tree.
The minimum page size is 512 bytes and the maximum page size is 64K.
If
.Va psize
is 0 (no page size is specified) a page size is chosen based on the
underlying file system I/O block size.
.It Va compare
Compare is the key comparison function.
It must return an integer less than, equal to, or greater than zero if the
first key argument is considered to be respectively less than, equal to,
or greater than the second key argument.
The same comparison function must be used on a given tree every time it
is opened.
If
.Va compare
is
.Dv NULL
(no comparison function is specified), the keys are compared
lexically, with shorter keys considered less than longer keys.
.It Va prefix
The
.Va prefix
element
is the prefix comparison function.
If specified, this routine must return the number of bytes of the second key
argument which are necessary to determine that it is greater than the first
key argument.
If the keys are equal, the key length should be returned.
Note, the usefulness of this routine is very data dependent, but, in some
data sets can produce significantly reduced tree sizes and search times.
If
.Va prefix
is
.Dv NULL
(no prefix function is specified),
.Em and
no comparison function is specified, a default lexical comparison routine
is used.
If
.Va prefix
is
.Dv NULL
and a comparison routine is specified, no prefix comparison is
done.
.It Va lorder
The byte order for integers in the stored database metadata.
The number should represent the order as an integer; for example,
big endian order would be the number 4,321.
If
.Va lorder
is 0 (no order is specified) the current host order is used.
.El
.Pp
If the file already exists (and the
.Dv O_TRUNC
flag is not specified), the
values specified for the
.Va flags , lorder
and
.Va psize
arguments
are ignored
in favor of the values used when the tree was created.
.Pp
Forward sequential scans of a tree are from the least key to the greatest.
.Pp
Space freed up by deleting key/data pairs from the tree is never reclaimed,
although it is normally made available for reuse.
This means that the
.Nm
storage structure is grow-only.
The only solutions are to avoid excessive deletions, or to create a fresh
tree periodically from a scan of an existing one.
.Pp
Searches, insertions, and deletions in a
.Nm
will all complete in
O lg base N where base is the average fill factor.
Often, inserting ordered data into
.Nm Ns s
results in a low fill factor.
This implementation has been modified to make ordered insertion the best
case, resulting in a much better than normal page fill factor.
.Sh ERRORS
The
.Nm
access method routines may fail and set
.Va errno
for any of the errors specified for the library routine
.Xr dbopen 3 .
.Sh SEE ALSO
.Xr dbopen 3 ,
.Xr hash 3 ,
.Xr mpool 3 ,
.Xr recno 3
.Rs
.%T "The Ubiquitous B-tree"
.%A Douglas Comer
.%J "ACM Comput. Surv. 11"
.%N 2
.%D June 1979
.%P 121-138
.Re
.Rs
.%A Bayer
.%A Unterauer
.%T "Prefix B-trees"
.%J "ACM Transactions on Database Systems"
.%N 1
.%V Vol. 2
.%D March 1977
.%P 11-26
.Re
.Rs
.%B "The Art of Computer Programming Vol. 3: Sorting and Searching"
.%A D. E. Knuth
.%D 1968
.%P 471-480
.Re
.Sh BUGS
Only big and little endian byte order is supported.
                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/buffer.3ssl                                  0100644 0001750 0001750 00000014250 12566201146 022734  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "buffer 3"
.TH buffer 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
BUF_MEM_new, BUF_MEM_free, BUF_MEM_grow, BUF_strdup \- simple
character arrays structure
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/buffer.h>
\&
\& BUF_MEM *BUF_MEM_new(void);
\&
\& void   BUF_MEM_free(BUF_MEM *a);
\&
\& int    BUF_MEM_grow(BUF_MEM *str, int len);
\&
\& char * BUF_strdup(const char *str);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The buffer library handles simple character arrays. Buffers are used for
various purposes in the library, most notably memory BIOs.
.PP
The library uses the \s-1BUF_MEM\s0 structure defined in buffer.h:
.PP
.Vb 6
\& typedef struct buf_mem_st
\& {
\&        int length;     /* current number of bytes */
\&        char *data;
\&        int max;        /* size of buffer */
\& } BUF_MEM;
.Ve
.PP
\&\fBlength\fR is the current size of the buffer in bytes, \fBmax\fR is the amount of
memory allocated to the buffer. There are three functions which handle these
and one \*(L"miscellaneous\*(R" function.
.PP
\&\fIBUF_MEM_new()\fR allocates a new buffer of zero size.
.PP
\&\fIBUF_MEM_free()\fR frees up an already existing buffer. The data is zeroed
before freeing up in case the buffer contains sensitive data.
.PP
\&\fIBUF_MEM_grow()\fR changes the size of an already existing buffer to
\&\fBlen\fR. Any data already in the buffer is preserved if it increases in
size.
.PP
\&\fIBUF_strdup()\fR copies a null terminated string into a block of allocated
memory and returns a pointer to the allocated block.
Unlike the standard C library \fIstrdup()\fR this function uses \fIOPENSSL_malloc()\fR and so
should be used in preference to the standard library \fIstrdup()\fR because it can
be used for memory leak checking or replacing the \fImalloc()\fR function.
.PP
The memory allocated from \fIBUF_strdup()\fR should be freed up using the \fIOPENSSL_free()\fR
function.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIBUF_MEM_new()\fR returns the buffer or \s-1NULL\s0 on error.
.PP
\&\fIBUF_MEM_free()\fR has no return value.
.PP
\&\fIBUF_MEM_grow()\fR returns zero on error or the new size (i.e. \fBlen\fR).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIbio\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIBUF_MEM_new()\fR, \fIBUF_MEM_free()\fR and \fIBUF_MEM_grow()\fR are available in all
versions of SSLeay and OpenSSL. \fIBUF_strdup()\fR was added in SSLeay 0.8.
                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/byteorder.3                                  0100644 0001750 0001750 00000006140 12566166140 022743  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 1983, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @(#)byteorder.3	8.1 (Berkeley) 6/4/93
.\" $FreeBSD: src/lib/libc/net/byteorder.3,v 1.8 2001/10/01 16:08:55 ru Exp $
.\"
.Dd June 4, 1993
.Dt BYTEORDER 3
.Os
.Sh NAME
.Nm htonl ,
.Nm htons ,
.Nm ntohl ,
.Nm ntohs
.Nd convert values between host and network byte order
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In arpa/inet.h
.Ft uint32_t
.Fn htonl "uint32_t hostlong"
.Ft uint16_t
.Fn htons "uint16_t hostshort"
.Ft uint32_t
.Fn ntohl "uint32_t netlong"
.Ft uint16_t
.Fn ntohs "uint16_t netshort"
.Sh DESCRIPTION
These routines convert 16 and 32 bit quantities between network
byte order and host byte order.
(Network byte order is big endian, or most significant byte first.)
On machines which have a byte order which is the same as the network
order, routines are defined as null macros.
.Pp
These routines are most often used in conjunction with Internet
addresses and ports as returned by
.Xr gethostbyname 3
and
.Xr getservent 3 .
.Sh SEE ALSO
.Xr gethostbyname 3 ,
.Xr getservent 3
.Sh STANDARDS
The
.Nm byteorder
functions are expected to conform with IEEE Std POSIX.1-200x
.Pq Dq POSIX.1 .
.Sh HISTORY
The
.Nm byteorder
functions appeared in
.Bx 4.2 .
.Sh BUGS
On the
.Tn VAX
bytes are handled backwards from most everyone else in
the world.  This is not expected to be fixed in the near future.
                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bytes.3pm                                    0100644 0001750 0001750 00000015421 12566207465 022437  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bytes 3pm"
.TH bytes 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
bytes \- Perl pragma to force byte semantics rather than character semantics
.SH "NOTICE"
.IX Header "NOTICE"
This pragma reflects early attempts to incorporate Unicode into perl and
has since been superseded. It breaks encapsulation (i.e. it exposes the
innards of how the perl executable currently happens to store a string),
and use of this module for anything other than debugging purposes is
strongly discouraged. If you feel that the functions here within might be
useful for your application, this possibly indicates a mismatch between
your mental model of Perl Unicode and the current reality. In that case,
you may wish to read some of the perl Unicode documentation:
perluniintro, perlunitut, perlunifaq and perlunicode.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&    use bytes;
\&    ... chr(...);       # or bytes::chr
\&    ... index(...);     # or bytes::index
\&    ... length(...);    # or bytes::length
\&    ... ord(...);       # or bytes::ord
\&    ... rindex(...);    # or bytes::rindex
\&    ... substr(...);    # or bytes::substr
\&    no bytes;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`use bytes\*(C'\fR pragma disables character semantics for the rest of the
lexical scope in which it appears.  \f(CW\*(C`no bytes\*(C'\fR can be used to reverse
the effect of \f(CW\*(C`use bytes\*(C'\fR within the current lexical scope.
.PP
Perl normally assumes character semantics in the presence of character
data (i.e. data that has come from a source that has been marked as
being of a particular character encoding). When \f(CW\*(C`use bytes\*(C'\fR is in
effect, the encoding is temporarily ignored, and each string is treated
as a series of bytes.
.PP
As an example, when Perl sees \f(CW\*(C`$x = chr(400)\*(C'\fR, it encodes the character
in \s-1UTF\-8\s0 and stores it in \f(CW$x\fR. Then it is marked as character data, so,
for instance, \f(CW\*(C`length $x\*(C'\fR returns \f(CW1\fR. However, in the scope of the
\&\f(CW\*(C`bytes\*(C'\fR pragma, \f(CW$x\fR is treated as a series of bytes \- the bytes that make
up the \s-1UTF8\s0 encoding \- and \f(CW\*(C`length $x\*(C'\fR returns \f(CW2\fR:
.PP
.Vb 8
\&    $x = chr(400);
\&    print "Length is ", length $x, "\en";     # "Length is 1"
\&    printf "Contents are %vd\en", $x;         # "Contents are 400"
\&    { 
\&        use bytes; # or "require bytes; bytes::length()"
\&        print "Length is ", length $x, "\en"; # "Length is 2"
\&        printf "Contents are %vd\en", $x;     # "Contents are 198.144"
\&    }
.Ve
.PP
\&\fIchr()\fR, \fIord()\fR, \fIsubstr()\fR, \fIindex()\fR and \fIrindex()\fR behave similarly.
.PP
For more on the implications and differences between character
semantics and byte semantics, see perluniintro and perlunicode.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
\&\fIbytes::substr()\fR does not work as an \fIlvalue()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perluniintro, perlunicode, utf8
                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bytes5.16.3pm                                0100644 0001750 0001750 00000015100 12566207443 022737  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bytes 3pm"
.TH bytes 3pm "2013-02-26" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
bytes \- Perl pragma to force byte semantics rather than character semantics
.SH "NOTICE"
.IX Header "NOTICE"
This pragma reflects early attempts to incorporate Unicode into perl and
has since been superseded. It breaks encapsulation (i.e. it exposes the
innards of how the perl executable currently happens to store a string),
and use of this module for anything other than debugging purposes is
strongly discouraged. If you feel that the functions here within might be
useful for your application, this possibly indicates a mismatch between
your mental model of Perl Unicode and the current reality. In that case,
you may wish to read some of the perl Unicode documentation:
perluniintro, perlunitut, perlunifaq and perlunicode.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&    use bytes;
\&    ... chr(...);       # or bytes::chr
\&    ... index(...);     # or bytes::index
\&    ... length(...);    # or bytes::length
\&    ... ord(...);       # or bytes::ord
\&    ... rindex(...);    # or bytes::rindex
\&    ... substr(...);    # or bytes::substr
\&    no bytes;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`use bytes\*(C'\fR pragma disables character semantics for the rest of the
lexical scope in which it appears.  \f(CW\*(C`no bytes\*(C'\fR can be used to reverse
the effect of \f(CW\*(C`use bytes\*(C'\fR within the current lexical scope.
.PP
Perl normally assumes character semantics in the presence of character
data (i.e. data that has come from a source that has been marked as
being of a particular character encoding). When \f(CW\*(C`use bytes\*(C'\fR is in
effect, the encoding is temporarily ignored, and each string is treated
as a series of bytes.
.PP
As an example, when Perl sees \f(CW\*(C`$x = chr(400)\*(C'\fR, it encodes the character
in \s-1UTF\-8\s0 and stores it in \f(CW$x\fR. Then it is marked as character data, so,
for instance, \f(CW\*(C`length $x\*(C'\fR returns \f(CW1\fR. However, in the scope of the
\&\f(CW\*(C`bytes\*(C'\fR pragma, \f(CW$x\fR is treated as a series of bytes \- the bytes that make
up the \s-1UTF8\s0 encoding \- and \f(CW\*(C`length $x\*(C'\fR returns \f(CW2\fR:
.PP
.Vb 8
\&    $x = chr(400);
\&    print "Length is ", length $x, "\en";     # "Length is 1"
\&    printf "Contents are %vd\en", $x;         # "Contents are 400"
\&    { 
\&        use bytes; # or "require bytes; bytes::length()"
\&        print "Length is ", length $x, "\en"; # "Length is 2"
\&        printf "Contents are %vd\en", $x;     # "Contents are 198.144"
\&    }
.Ve
.PP
\&\fIchr()\fR, \fIord()\fR, \fIsubstr()\fR, \fIindex()\fR and \fIrindex()\fR behave similarly.
.PP
For more on the implications and differences between character
semantics and byte semantics, see perluniintro and perlunicode.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
\&\fIbytes::substr()\fR does not work as an \fIlvalue()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perluniintro, perlunicode, utf8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bytes5.18.3pm                                0100644 0001750 0001750 00000015421 12566207465 022753  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bytes 3pm"
.TH bytes 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
bytes \- Perl pragma to force byte semantics rather than character semantics
.SH "NOTICE"
.IX Header "NOTICE"
This pragma reflects early attempts to incorporate Unicode into perl and
has since been superseded. It breaks encapsulation (i.e. it exposes the
innards of how the perl executable currently happens to store a string),
and use of this module for anything other than debugging purposes is
strongly discouraged. If you feel that the functions here within might be
useful for your application, this possibly indicates a mismatch between
your mental model of Perl Unicode and the current reality. In that case,
you may wish to read some of the perl Unicode documentation:
perluniintro, perlunitut, perlunifaq and perlunicode.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\&    use bytes;
\&    ... chr(...);       # or bytes::chr
\&    ... index(...);     # or bytes::index
\&    ... length(...);    # or bytes::length
\&    ... ord(...);       # or bytes::ord
\&    ... rindex(...);    # or bytes::rindex
\&    ... substr(...);    # or bytes::substr
\&    no bytes;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`use bytes\*(C'\fR pragma disables character semantics for the rest of the
lexical scope in which it appears.  \f(CW\*(C`no bytes\*(C'\fR can be used to reverse
the effect of \f(CW\*(C`use bytes\*(C'\fR within the current lexical scope.
.PP
Perl normally assumes character semantics in the presence of character
data (i.e. data that has come from a source that has been marked as
being of a particular character encoding). When \f(CW\*(C`use bytes\*(C'\fR is in
effect, the encoding is temporarily ignored, and each string is treated
as a series of bytes.
.PP
As an example, when Perl sees \f(CW\*(C`$x = chr(400)\*(C'\fR, it encodes the character
in \s-1UTF\-8\s0 and stores it in \f(CW$x\fR. Then it is marked as character data, so,
for instance, \f(CW\*(C`length $x\*(C'\fR returns \f(CW1\fR. However, in the scope of the
\&\f(CW\*(C`bytes\*(C'\fR pragma, \f(CW$x\fR is treated as a series of bytes \- the bytes that make
up the \s-1UTF8\s0 encoding \- and \f(CW\*(C`length $x\*(C'\fR returns \f(CW2\fR:
.PP
.Vb 8
\&    $x = chr(400);
\&    print "Length is ", length $x, "\en";     # "Length is 1"
\&    printf "Contents are %vd\en", $x;         # "Contents are 400"
\&    { 
\&        use bytes; # or "require bytes; bytes::length()"
\&        print "Length is ", length $x, "\en"; # "Length is 2"
\&        printf "Contents are %vd\en", $x;     # "Contents are 198.144"
\&    }
.Ve
.PP
\&\fIchr()\fR, \fIord()\fR, \fIsubstr()\fR, \fIindex()\fR and \fIrindex()\fR behave similarly.
.PP
For more on the implications and differences between character
semantics and byte semantics, see perluniintro and perlunicode.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
\&\fIbytes::substr()\fR does not work as an \fIlvalue()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perluniintro, perlunicode, utf8
                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/bzero.3                                      0100644 0001750 0001750 00000004601 12566166140 022065  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 1990, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" Chris Torek.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"	@(#)bzero.3	8.1 (Berkeley) 6/4/93
.\" $FreeBSD: src/lib/libc/string/bzero.3,v 1.10 2007/01/09 00:28:11 imp Exp $
.\"
.Dd June 4, 1993
.Dt BZERO 3
.Os
.Sh NAME
.Nm bzero
.Nd write zeroes to a byte string
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In strings.h
.Ft void
.Fn bzero "void *s" "size_t n"
.Sh DESCRIPTION
The
.Fn bzero
function
writes
.Fa n
zeroed bytes to the string
.Fa s .
If
.Fa n
is zero,
.Fn bzero
does nothing.
.Sh SEE ALSO
.Xr memset 3 ,
.Xr swab 3
.Sh HISTORY
A
.Fn bzero
function
appeared in
.Bx 4.3 .
Its prototype existed previously in
.In string.h
before it was moved to
.In strings.h
for
.St -p1003.1-2001
compliance.
.Pp
.Fn bzero
was deprecated in
.St -p1003.1-2001
and removed in
.St -p1003.1-2008 .
                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cabs.3                                       0100644 0001750 0001750 00000005554 12566165764 021677  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2006 Apple Computer
.\"
.Dd December 11, 2006
.Dt CABS 3
.Os BSD 4
.Sh NAME
.Nm cabs
.Nd complex norm (absolute value) function
.br
.Nm carg
.Nd complex argument function
.Sh SYNOPSIS
.Fd #include <complex.h>
.Ft double
.Fn cabs "double complex z"
.Ft long double
.Fn cabsl "long double complex z"
.Ft float
.Fn cabsf "float complex z"
.Ft double
.Fn carg "double complex z"
.Ft long double
.Fn cargl "long double complex z"
.Ft float
.Fn cargf "float complex z"
.Sh DESCRIPTION
.Fn cabs "z"
computes the norm (absolute value) of the complex floating-point number
.Fa z .
.Pp
.Fn carg "z"
computes the argument (also called phase angle) of the complex floating-point number
.Fa z ,
with a branch cut on the negative real axis.  The result is in
the range
.Bq -\*(Pi , \*(Pi ,
and has the same sign as the imaginary part of
.Fa z .
.Sh EXAMPLES
The function foo defined in the example below applies a non-linear rotation to the
complex plane, such that points near the origin are not much affected, and points
far from the origin are rotated by about pi/2.
.Pp
This is accomplished by using cabs and carg to convert to polar coordinates, then
computing the transformation in that coordinate system, and finally converting back
to the usual rectangular coordinate system.
.Bd -literal -offset indent
#include <complex.h>
#include <math.h>

double complex foo(double complex z) {
  // get the polar coordinates of z
  double r = cabs(z);
  double theta = carg(z);

  // add a value dependent on r to theta
  theta += atan(r);

  // now change back to rectangular coordinates and
  // return the new complex number
  return r*cos(theta) + r*sin(theta)*I;
}
.Ed
.Sh SPECIAL VALUES
.Fn cabs "x + yi" ,
.Fn cabs "y + xi" ,
and
.Fn cabs "x - yi"
are equivalent.  This is used to abbreviate the specification of special values.
.Pp
.Fn cabs "x  0i"
is equivalent to
.Fn fabs "x" .
.Pp
.Fn cabs "inf + yi"
returns inf even if y is a NaN.
.Pp
.Fn cabs "x + NaN i"
returns NaN, for finite x.
.Pp
.Fn cabs "NaN + NaN i"
returns NaN.
.Pp
.Fn carg "-0  0i"
returns pi.
.Pp
.Fn carg "+0  0i"
returns 0.
.Pp
.Fn carg "x  0i"
returns pi for x < 0.
.Pp
.Fn carg "x  0i"
returns 0 for x > 0.
.Pp
.Fn carg "0 + yi"
returns -pi/2 for y < 0.
.Pp
.Fn carg "0 + yi"
returns +pi/2 for y > 0.
.Pp
.Fn carg "-inf  yi"
returns pi for finite y > 0.
.Pp
.Fn carg "+inf  yi"
returns 0 for finite y > 0.
.Pp
.Fn carg "x  inf i"
returns pi/2 for finite x.
.Pp
.Fn carg "-inf  inf i"
returns 3*pi/4.
.Pp
.Fn carg "+inf  inf i"
returns pi/4.
.Pp
.Fn carg "x + yi"
returns NaN if either of x or y is NaN.
.Sh NOTES
.Fn cabs
and
.Fn carg
are fully specified in terms of real functions:
.Bd -literal -offset indent
cabs(x + iy) = hypot(x,y)
.br
carg(x + iy) = atan2(y,x).
.Ed
.Sh SEE ALSO
.Xr hypot 3 ,
.Xr atan2 3 ,
.Xr fabs 3 ,
.Xr complex 3
.Sh STANDARDS
The
.Fn cabs
and
.Fn carg
functions conform to ISO/IEC 9899:2011.                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cabsf.3                                      0100644 0001750 0001750 00000000017 12566165764 022032  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/cabs.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cabsl.3                                      0100644 0001750 0001750 00000000017 12566165764 022040  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/cabs.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cache.3                                      0100644 0001750 0001750 00000003065 12566165766 022027  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd September 21, 2006
.Dt CACHE 3
.Os Darwin
.Sh NAME
.Nm sys_cache_control ,
.Nm sys_icache_invalidate ,
.Nm sys_dcache_flush
.Nd cache control
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In libkern/OSCacheControl.h
.Ft int
.Fn sys_cache_control "int function" "void *start" "size_t len"
.Ft void
.Fn sys_icache_invalidate "void *start" "size_t len"
.Ft void
.Fn sys_dcache_flush "void *start" "size_t len"
.Sh DESCRIPTION
.Pp
These functions operate on every cache line containing one of the 
.Fa len
bytes of memory pointed to by
.Fa start .
Normally the operations apply to every
processor in the system, but the exact semantics of these
operations is platform dependent.  They should be used with caution.
.Pp
.Fn sys_cache_control
performs the operation specified by
.Fa function .
Refer to the header file for a list of currently supported functions.
.Pp
.Fn sys_icache_invalidate
prepares memory for execution, typically by invalidating the instruction
cache for the indicated range.  This should be called
after writing machine instructions to memory, and before
executing them.  On IA32 processors this function is a NOP, because
their instruction caches are coherent.
.Pp
.Fn sys_dcache_flush
writes modified data cache lines to main memory,
and then invalidates all lines in the range being operated on.
It can be useful when dealing with cache incoherent
devices or DMA.
.Sh RETURN VALUES
.Fn sys_cache_control
returns zero on success, ENOTSUP if
.Fa function
is not valid.
.Sh SEE ALSO
.Xr atomic 3 ,
.Xr barrier 3
.Sh HISTORY
These functions first appeared in Mac OS 10.5 (Leopard).                                                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cache_callbacks.3                            0100644 0001750 0001750 00000004475 12566166453 024026  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2009 Apple Inc. All rights reserved.
.Dd May 7, 2009
.Dt cache_callbacks 3
.Os Darwin
.Sh NAME
.Nm cache_callbacks
.Nd Pre-defined cache callbacks used to configure a cache
.Sh SYNOPSIS
.Fd #include <cache.h>
.Fd #include <cache_callbacks.h>
.Ft uintptr_t 
.Fo cache_key_hash_cb_cstring
.Fa "void *key, void *unused"
.Fc
.Ft uintptr_t 
.Fo cache_key_hash_cb_integer
.Fa "void *key, void *unused"
.Fc
.Ft bool 
.Fo cache_key_is_equal_cb_cstring
.Fa "void *key1, void *key2, void *unused"
.Fc
.Ft bool 
.Fo cache_key_is_equal_cb_integer
.Fa "void *key1, void *key2, void *unused"
.Fc
.Ft void 
.Fo cache_release_cb_free
.Fa "void *key_or_value, void *unused"
.Fc
.Ft void 
.Fo cache_value_make_purgeable_cb
.Fa "void *value, void *unused"
.Fc
.Ft bool 
.Fo cache_value_make_nonpurgeable_cb
.Fa "void *value, void *unused"
.Fc
.Ft uintptr_t 
.Fo cache_hash_byte_string
.Fa "const char *data, size_t bytes"
.Fc
.Sh DESCRIPTION
.Pp
These functions are intended to be used as callbacks to configure how a cache functions.
They should be set in the cache_attributes_t passed into 
.Xr cache_create .  They support common key types and offer support for using purgeable
memory to allocate cache values.
.Pp
.Fn cache_key_hash_cb_cstring
A 
.Fn key_hash_cb
function for NULL-terminated cstring keys.
.Pp
.Fn cache_key_hash_cb_integer
A 
.Fn key_hash_cb
function for integer keys.
.Pp 
.Fn cache_key_is_equal_cb_cstring
A 
.Fn key_is_equal_cb
function for cstring keys.
.Pp
.Fn cache_key_is_equal_cb_integer
A 
.Fn key_is_equal_cb
function for integer keys.
.Pp
.Fn cache_release_cb_free
Can be used for 
.Fn key_release_cb 
or
.Fn value_release_cb
for keys/values allocated from 
.Xr malloc 
and family.
.Pp
.Fn cache_value_make_purgeable_cb
Can be used for
.Fn value_make_purgeable 
with values allocated from the purgeable malloc zone (see malloc/malloc.h).  Calls
.Fn malloc_make_purgeable 
on 
.Fa value
when it is unreferenced in order to reduce paging under memory pressure.
.Pp
.Fn value_make_purgeable 
with values allocated from the purgeable malloc zone (see malloc/malloc.h).  Calls
.Fn malloc_make_purgeable 
on 
.Fa value
when it is unreferenced in order to reduce paging under memory pressure.
.Pp
.Fn cache_hash_byte_string
Calculates a hash from a bytes string
.Fa data
of length 
.Fa bytes .
.Sh SEE ALSO
.Xr libcache 3
.Xr cache_create 3
                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cache_create.3                               0100644 0001750 0001750 00000007142 12566166453 023344  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2009 Apple Inc. All rights reserved.
.Dd May 7, 2009
.Dt cache_create 3
.Os Darwin
.Sh NAME
.Nm cache_create
.Nd Creates an in memory cache
.Sh SYNOPSIS
.Fd #include <cache.h>
.Ft int
.Fo cache_create
.Fa "const char *name, cache_attributes_t *attrs, cache_t **cache_out"
.Fc
.Ft int
.Fo cache_destroy
.Fa "cache_t *cache"
.Fc
.Sh DESCRIPTION
.Pp
.Fn cache_create
Creates a cache using attributes 
.Fa attrs
(see below) and name
.Fa name
and if successful stores it in 
.Fa cache_out .
.Fa name
is a NULL-terminated cstring in reverse-DNS form (e.g. "com.mycompany.imagecache") and 
is used for debugging and performance tools.  It must not be NULL.
.Pp
.Fn cache_destroy
Removes all unreferenced values in 
.Fa cache 
and deallocates it.
.Sh CACHE ATTRIBUTES
Cache attributes are callbacks passed to 
.Fn cache_create 
to support different types of keys and values and to configure cache behavior.  The cache
framework provides preexisting 
.Xr cache_callbacks 3
functions that can be used for these callbacks to support
common key and value types
.Bd -literal
typedef struct cache_attributes_s {
    uint32_t version;
    cache_key_hash_cb_t key_hash_cb;                               
    cache_key_is_equal_cb_t key_is_equal_cb;                        
    
    cache_key_retain_cb_t  key_retain_cb;
    cache_release_cb_t key_release_cb;
    cache_release_cb_t value_release_cb;                           
    
    cache_value_make_nonpurgeable_cb_t value_make_nonpurgeable_cb; 
    cache_value_make_purgeable_cb_t value_make_purgeable_cb;       
    
    void *user_data;
    cache_value_retain_cb_t value_retain_cb;
} cache_attributes_t;
#define CACHE_ATTRIBUTES_VERSION_2 2 
.Ed
.Bl -tag -width XXXvalue_make_nonpurgeable_cb
.It key_hash_cb 
Calculates a hash value using key
.It key_is_equal_cb 
Determines if two keys are equal
.It key_retain_cb 
Called when a key is added to a cache using 
.Fn cache_set_and_retain 
to allow key to be copied, or retained if it is a reference-counted object.
.It key_release_cb 
Called when a key is removed or evicted from a cache to allow the key
to be deallocated, or released if it is a reference-counted object.
.It value_retain_cb 
Called when a value is added to a cache using 
.Fn cache_set_and_retain
to allow value to be retained if it is a reference-counted object.
.It value_release_cb 
Called when a value is removed or evicted from a cache to allow the key
to be deallocated, or released if it is a reference-counted object.
.It value_make_nonpurgeable_cb 
Called when a value is referenced using
.Fn cache_get_and_retain
to allow it to be made nonpurgeable or uncompressed.
.It value_make_purgeable_cb 
Called when a value is unreferenced to allow it to be made purgeable or
compressed.
.It version 
Attributes version number used for binary compatibility.
.It user_data 
This value will be passed to all other callbacks for this cache.  May be NULL.
.El
.Sh RETURN VALUES
All functions return 0 for success and non-zero for failure.
.Sh EXAMPLE
The following example uses pre-existing 
.Xr cache_callbacks 3
to create a cache with cstring keys and 
.Xr malloc 3
allocated values.  The 
.Bd -literal
#include <cache.h>
#include <cache_callbcaks.h>

cache_t *im_cache;
cache_attributes_t attrs = {
    .version = CACHE_ATTRIBUTES_VERSION_2,
    .key_hash_cb = cache_key_hash_cb_cstring,
    .key_is_equal_cb = cache_key_is_equal_cb_cstring,
    .key_retain_cb = my_copy_string,
    .key_release_cb = cache_release_cb_free,
    .value_release_cb = cache_release_cb_free,
};
cache_create("com.acme.im_cache", &attrs, &im_cache);
.Ed
.Sh SEE ALSO
.Xr cache 3
.Xr cache_set_and_retain 3
.Xr cache_callbacks 3
                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cache_destroy.3                              0100644 0001750 0001750 00000007142 12566166453 023572  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2009 Apple Inc. All rights reserved.
.Dd May 7, 2009
.Dt cache_create 3
.Os Darwin
.Sh NAME
.Nm cache_create
.Nd Creates an in memory cache
.Sh SYNOPSIS
.Fd #include <cache.h>
.Ft int
.Fo cache_create
.Fa "const char *name, cache_attributes_t *attrs, cache_t **cache_out"
.Fc
.Ft int
.Fo cache_destroy
.Fa "cache_t *cache"
.Fc
.Sh DESCRIPTION
.Pp
.Fn cache_create
Creates a cache using attributes 
.Fa attrs
(see below) and name
.Fa name
and if successful stores it in 
.Fa cache_out .
.Fa name
is a NULL-terminated cstring in reverse-DNS form (e.g. "com.mycompany.imagecache") and 
is used for debugging and performance tools.  It must not be NULL.
.Pp
.Fn cache_destroy
Removes all unreferenced values in 
.Fa cache 
and deallocates it.
.Sh CACHE ATTRIBUTES
Cache attributes are callbacks passed to 
.Fn cache_create 
to support different types of keys and values and to configure cache behavior.  The cache
framework provides preexisting 
.Xr cache_callbacks 3
functions that can be used for these callbacks to support
common key and value types
.Bd -literal
typedef struct cache_attributes_s {
    uint32_t version;
    cache_key_hash_cb_t key_hash_cb;                               
    cache_key_is_equal_cb_t key_is_equal_cb;                        
    
    cache_key_retain_cb_t  key_retain_cb;
    cache_release_cb_t key_release_cb;
    cache_release_cb_t value_release_cb;                           
    
    cache_value_make_nonpurgeable_cb_t value_make_nonpurgeable_cb; 
    cache_value_make_purgeable_cb_t value_make_purgeable_cb;       
    
    void *user_data;
    cache_value_retain_cb_t value_retain_cb;
} cache_attributes_t;
#define CACHE_ATTRIBUTES_VERSION_2 2 
.Ed
.Bl -tag -width XXXvalue_make_nonpurgeable_cb
.It key_hash_cb 
Calculates a hash value using key
.It key_is_equal_cb 
Determines if two keys are equal
.It key_retain_cb 
Called when a key is added to a cache using 
.Fn cache_set_and_retain 
to allow key to be copied, or retained if it is a reference-counted object.
.It key_release_cb 
Called when a key is removed or evicted from a cache to allow the key
to be deallocated, or released if it is a reference-counted object.
.It value_retain_cb 
Called when a value is added to a cache using 
.Fn cache_set_and_retain
to allow value to be retained if it is a reference-counted object.
.It value_release_cb 
Called when a value is removed or evicted from a cache to allow the key
to be deallocated, or released if it is a reference-counted object.
.It value_make_nonpurgeable_cb 
Called when a value is referenced using
.Fn cache_get_and_retain
to allow it to be made nonpurgeable or uncompressed.
.It value_make_purgeable_cb 
Called when a value is unreferenced to allow it to be made purgeable or
compressed.
.It version 
Attributes version number used for binary compatibility.
.It user_data 
This value will be passed to all other callbacks for this cache.  May be NULL.
.El
.Sh RETURN VALUES
All functions return 0 for success and non-zero for failure.
.Sh EXAMPLE
The following example uses pre-existing 
.Xr cache_callbacks 3
to create a cache with cstring keys and 
.Xr malloc 3
allocated values.  The 
.Bd -literal
#include <cache.h>
#include <cache_callbcaks.h>

cache_t *im_cache;
cache_attributes_t attrs = {
    .version = CACHE_ATTRIBUTES_VERSION_2,
    .key_hash_cb = cache_key_hash_cb_cstring,
    .key_is_equal_cb = cache_key_is_equal_cb_cstring,
    .key_retain_cb = my_copy_string,
    .key_release_cb = cache_release_cb_free,
    .value_release_cb = cache_release_cb_free,
};
cache_create("com.acme.im_cache", &attrs, &im_cache);
.Ed
.Sh SEE ALSO
.Xr cache 3
.Xr cache_set_and_retain 3
.Xr cache_callbacks 3
                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cache_get_and_retain.3                       0100644 0001750 0001750 00000005111 12566166453 025036  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2009 Apple Inc. All rights reserved.
.Dd May 7, 2009
.Dt cache_set_and_retain 3
.Os Darwin
.Sh NAME
.Nm cache_set_and_retain ,
.Nm cache_get_and_retain ,
.Nm cache_release_value ,
.Nm cache_remove 
.Nd Routines used to manage cached values
.Sh SYNOPSIS
.Fd #include <cache.h>
.Ft int
.Fo cache_set_and_retain
.Fa "cache_t *cache, void *key, void *value, size_t cost"
.Fc
.Ft int
.Fo cache_get_and_retain
.Fa "cache_t *cache, void *key, void **value_out"
.Fc
.Ft int
.Fo cache_release_value
.Fa "cache_t *cache, void *value"
.Fc
.Ft int
.Fo cache_remove
.Fa "cache_t *cache, void *key"
.Fc
.Sh DESCRIPTION
These routines are used to manipulate values added to an in memory cache created by 
.Xr cache_create 3 .
.Pp
.Fn cache_set_and_retain
Adds
.Fa value 
with 
.Fa cost 
to 
.Fa cache 
and associates it with 
.Fa key .
The caller retains a
reference to value that will prevent value from being evicted from the cache
until value is released in  
.Fn cache_release_value .
.Pp
.Fn cache_get_and_retain
Fetches value for 
.Fa key
from 
.Fa cache 
and places value in 
.Fa value_out .
The caller retains a reference to value that will prevent value from being evicted from the cache
until value is release in 
.Fn cache_release_value .
.Pp
.Fn cache_release_value
Releases a reference on 
.Fa value
back to 
.Fa cache
so that value may be evicted.  Signals that the client is not actively using 
.Fa value 
and will use 
.Fn cache_get_and_retain
before using again.
.Pp
.Fn cache_remove
Removes the value associated with 
.Fa key
from 
.Fa cache .
Note that if the value is referenced by a client, the value will not be finalized until the reference is released using
.Fn cache_release_value .
.Sh RETURN VALUES
All functions return 0 for success and non-zero for failure.  The value ENOENT (see errno.h) indicates that a key or value passed as an argument does not exist in the cache.  EINVAL is used for invalid arguments.
.Sh EXAMPLE
The following example attempts to fetch a value from a cache using a key.  If the value is not present in the cache then it is created and added to the cache.  The value is then used and released back to
the cache to allow the cache to evict it when needed.
.Bd -literal -offset indent
cache_t *mycache;
cache_create("com.mycompany.mycache", &cache_attributes, &mycache);

void *mykey = my_create_key();
void *myvalue = NULL;

if (cache_get_and_retain(mycache, mykey, &myvalue) != 0) {
    myvalue = my_create_value_from_key(mykey);
    cache_set_and_retain(mycache, mykey, myvalue, 0);
}

my_use_value(value);
cache_release_value(mycache, myvalue);
.Ed
.Sh SEE ALSO
.Xr cache 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cache_release_value.3                        0100644 0001750 0001750 00000005111 12566166453 024707  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2009 Apple Inc. All rights reserved.
.Dd May 7, 2009
.Dt cache_set_and_retain 3
.Os Darwin
.Sh NAME
.Nm cache_set_and_retain ,
.Nm cache_get_and_retain ,
.Nm cache_release_value ,
.Nm cache_remove 
.Nd Routines used to manage cached values
.Sh SYNOPSIS
.Fd #include <cache.h>
.Ft int
.Fo cache_set_and_retain
.Fa "cache_t *cache, void *key, void *value, size_t cost"
.Fc
.Ft int
.Fo cache_get_and_retain
.Fa "cache_t *cache, void *key, void **value_out"
.Fc
.Ft int
.Fo cache_release_value
.Fa "cache_t *cache, void *value"
.Fc
.Ft int
.Fo cache_remove
.Fa "cache_t *cache, void *key"
.Fc
.Sh DESCRIPTION
These routines are used to manipulate values added to an in memory cache created by 
.Xr cache_create 3 .
.Pp
.Fn cache_set_and_retain
Adds
.Fa value 
with 
.Fa cost 
to 
.Fa cache 
and associates it with 
.Fa key .
The caller retains a
reference to value that will prevent value from being evicted from the cache
until value is released in  
.Fn cache_release_value .
.Pp
.Fn cache_get_and_retain
Fetches value for 
.Fa key
from 
.Fa cache 
and places value in 
.Fa value_out .
The caller retains a reference to value that will prevent value from being evicted from the cache
until value is release in 
.Fn cache_release_value .
.Pp
.Fn cache_release_value
Releases a reference on 
.Fa value
back to 
.Fa cache
so that value may be evicted.  Signals that the client is not actively using 
.Fa value 
and will use 
.Fn cache_get_and_retain
before using again.
.Pp
.Fn cache_remove
Removes the value associated with 
.Fa key
from 
.Fa cache .
Note that if the value is referenced by a client, the value will not be finalized until the reference is released using
.Fn cache_release_value .
.Sh RETURN VALUES
All functions return 0 for success and non-zero for failure.  The value ENOENT (see errno.h) indicates that a key or value passed as an argument does not exist in the cache.  EINVAL is used for invalid arguments.
.Sh EXAMPLE
The following example attempts to fetch a value from a cache using a key.  If the value is not present in the cache then it is created and added to the cache.  The value is then used and released back to
the cache to allow the cache to evict it when needed.
.Bd -literal -offset indent
cache_t *mycache;
cache_create("com.mycompany.mycache", &cache_attributes, &mycache);

void *mykey = my_create_key();
void *myvalue = NULL;

if (cache_get_and_retain(mycache, mykey, &myvalue) != 0) {
    myvalue = my_create_value_from_key(mykey);
    cache_set_and_retain(mycache, mykey, myvalue, 0);
}

my_use_value(value);
cache_release_value(mycache, myvalue);
.Ed
.Sh SEE ALSO
.Xr cache 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cache_remove.3                               0100644 0001750 0001750 00000005111 12566166453 023370  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2009 Apple Inc. All rights reserved.
.Dd May 7, 2009
.Dt cache_set_and_retain 3
.Os Darwin
.Sh NAME
.Nm cache_set_and_retain ,
.Nm cache_get_and_retain ,
.Nm cache_release_value ,
.Nm cache_remove 
.Nd Routines used to manage cached values
.Sh SYNOPSIS
.Fd #include <cache.h>
.Ft int
.Fo cache_set_and_retain
.Fa "cache_t *cache, void *key, void *value, size_t cost"
.Fc
.Ft int
.Fo cache_get_and_retain
.Fa "cache_t *cache, void *key, void **value_out"
.Fc
.Ft int
.Fo cache_release_value
.Fa "cache_t *cache, void *value"
.Fc
.Ft int
.Fo cache_remove
.Fa "cache_t *cache, void *key"
.Fc
.Sh DESCRIPTION
These routines are used to manipulate values added to an in memory cache created by 
.Xr cache_create 3 .
.Pp
.Fn cache_set_and_retain
Adds
.Fa value 
with 
.Fa cost 
to 
.Fa cache 
and associates it with 
.Fa key .
The caller retains a
reference to value that will prevent value from being evicted from the cache
until value is released in  
.Fn cache_release_value .
.Pp
.Fn cache_get_and_retain
Fetches value for 
.Fa key
from 
.Fa cache 
and places value in 
.Fa value_out .
The caller retains a reference to value that will prevent value from being evicted from the cache
until value is release in 
.Fn cache_release_value .
.Pp
.Fn cache_release_value
Releases a reference on 
.Fa value
back to 
.Fa cache
so that value may be evicted.  Signals that the client is not actively using 
.Fa value 
and will use 
.Fn cache_get_and_retain
before using again.
.Pp
.Fn cache_remove
Removes the value associated with 
.Fa key
from 
.Fa cache .
Note that if the value is referenced by a client, the value will not be finalized until the reference is released using
.Fn cache_release_value .
.Sh RETURN VALUES
All functions return 0 for success and non-zero for failure.  The value ENOENT (see errno.h) indicates that a key or value passed as an argument does not exist in the cache.  EINVAL is used for invalid arguments.
.Sh EXAMPLE
The following example attempts to fetch a value from a cache using a key.  If the value is not present in the cache then it is created and added to the cache.  The value is then used and released back to
the cache to allow the cache to evict it when needed.
.Bd -literal -offset indent
cache_t *mycache;
cache_create("com.mycompany.mycache", &cache_attributes, &mycache);

void *mykey = my_create_key();
void *myvalue = NULL;

if (cache_get_and_retain(mycache, mykey, &myvalue) != 0) {
    myvalue = my_create_value_from_key(mykey);
    cache_set_and_retain(mycache, mykey, myvalue, 0);
}

my_use_value(value);
cache_release_value(mycache, myvalue);
.Ed
.Sh SEE ALSO
.Xr cache 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cache_set_and_retain.3                       0100644 0001750 0001750 00000005111 12566166453 025052  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2009 Apple Inc. All rights reserved.
.Dd May 7, 2009
.Dt cache_set_and_retain 3
.Os Darwin
.Sh NAME
.Nm cache_set_and_retain ,
.Nm cache_get_and_retain ,
.Nm cache_release_value ,
.Nm cache_remove 
.Nd Routines used to manage cached values
.Sh SYNOPSIS
.Fd #include <cache.h>
.Ft int
.Fo cache_set_and_retain
.Fa "cache_t *cache, void *key, void *value, size_t cost"
.Fc
.Ft int
.Fo cache_get_and_retain
.Fa "cache_t *cache, void *key, void **value_out"
.Fc
.Ft int
.Fo cache_release_value
.Fa "cache_t *cache, void *value"
.Fc
.Ft int
.Fo cache_remove
.Fa "cache_t *cache, void *key"
.Fc
.Sh DESCRIPTION
These routines are used to manipulate values added to an in memory cache created by 
.Xr cache_create 3 .
.Pp
.Fn cache_set_and_retain
Adds
.Fa value 
with 
.Fa cost 
to 
.Fa cache 
and associates it with 
.Fa key .
The caller retains a
reference to value that will prevent value from being evicted from the cache
until value is released in  
.Fn cache_release_value .
.Pp
.Fn cache_get_and_retain
Fetches value for 
.Fa key
from 
.Fa cache 
and places value in 
.Fa value_out .
The caller retains a reference to value that will prevent value from being evicted from the cache
until value is release in 
.Fn cache_release_value .
.Pp
.Fn cache_release_value
Releases a reference on 
.Fa value
back to 
.Fa cache
so that value may be evicted.  Signals that the client is not actively using 
.Fa value 
and will use 
.Fn cache_get_and_retain
before using again.
.Pp
.Fn cache_remove
Removes the value associated with 
.Fa key
from 
.Fa cache .
Note that if the value is referenced by a client, the value will not be finalized until the reference is released using
.Fn cache_release_value .
.Sh RETURN VALUES
All functions return 0 for success and non-zero for failure.  The value ENOENT (see errno.h) indicates that a key or value passed as an argument does not exist in the cache.  EINVAL is used for invalid arguments.
.Sh EXAMPLE
The following example attempts to fetch a value from a cache using a key.  If the value is not present in the cache then it is created and added to the cache.  The value is then used and released back to
the cache to allow the cache to evict it when needed.
.Bd -literal -offset indent
cache_t *mycache;
cache_create("com.mycompany.mycache", &cache_attributes, &mycache);

void *mykey = my_create_key();
void *myvalue = NULL;

if (cache_get_and_retain(mycache, mykey, &myvalue) != 0) {
    myvalue = my_create_value_from_key(mykey);
    cache_set_and_retain(mycache, mykey, myvalue, 0);
}

my_use_value(value);
cache_release_value(mycache, myvalue);
.Ed
.Sh SEE ALSO
.Xr cache 3
                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cacos.3                                      0100644 0001750 0001750 00000003067 12566165764 022054  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2006 Apple Computer
.\"
.Dd December 11, 2006
.Dt CACOS 3
.Os BSD 4
.Sh NAME
.Nm cacos
.Nd complex inverse cosine function
.Sh SYNOPSIS
.Ft double complex
.Fn cacos "double complex z"
.Ft long double complex
.Fn cacosl "long double complex z"
.Ft float complex
.Fn cacosf "float complex z"
.Sh DESCRIPTION
.Fn cacos "z"
computes the inverse cosine of the complex floating-point number
.Fa z ,
with branch cuts outside the interval
.Bq -1,1
along the real axis.
.Pp
.Fn cacos
returns values in a strip of the complex plane with unbounded imaginary part, and real part in the interval
.Bq 0, Pi .
.Pp
For all complex floating point numbers z, cacos(conj(z)) = conj(cacos(z)).
.Sh SPECIAL VALUES
The conjugate symmetry of cacos() is used to abbreviate the specification of special values.
.Pp
.Fn cacos "0 + 0i"
returns Pi/2 - 0i.
.Pp
.Fn cacos "0 + NaN i"
returns Pi/2 + NaN i.
.Pp
.Fn cacos "x + inf i"
returns Pi/2 - inf i, for finite x.
.Pp
.Fn cacos "x + NaN i"
returns NaN + NaN i, for finite nonzero x.
.Pp
.Fn cacos "-inf + yi"
returns Pi - inf i, for finite positive-signed y.
.Pp
.Fn cacos "inf + yi"
returns 0 - inf i, for finite positive-signed y.
.Pp
.Fn cacos "-inf + inf i"
returns 3Pi/4 - inf i.
.Pp
.Fn cacos "inf + inf i"
returns Pi/4 - inf i.
.Pp
.Fn cacos "inf + NaN i"
returns NaN + inf i.
.Pp
.Fn cacos "NaN + yi"
returns NaN + NaN i, for finite y.
.Pp
.Fn cacos "NaN + inf i"
returns NaN - inf i.
.Pp
.Fn cacos "NaN + NaN i"
returns NaN + NaN i.
.Sh NOTES
.Sh SEE ALSO
.Xr complex 3
.Sh STANDARDS
The
.Fn cacos
function conforms to ISO/IEC 9899:2011.                                                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cacosf.3                                     0100644 0001750 0001750 00000000020 12566165764 022204  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/cacos.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cacosh.3                                     0100644 0001750 0001750 00000003103 12566165764 022213  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2006 Apple Computer
.\"
.Dd December 11, 2006
.Dt CACOSH 3
.Os BSD 4
.Sh NAME
.Nm cacosh
.Nd complex inverse hyperbolic cosine function
.Sh SYNOPSIS
.Ft double complex
.Fn cacosh "double complex z"
.Ft long double complex
.Fn cacoshl "long double complex z"
.Ft float complex
.Fn cacoshf "float complex z"
.Sh DESCRIPTION
.Fn cacosh "z"
computes the inverse hyperbolic cosine of the complex floating-point number
.Fa z ,
with a branch cut on the interval
.Bq -inf, 1
along the real axis.
.Pp
.Fn cacosh
returns values in a half-strip of the complex plane with positive real part and imaginary part in the interval
.Bq -Pi , Pi .
.Pp
For all complex floating point numbers z, cacosh(conj(z)) = conj(cacosh(z)).
.Sh SPECIAL VALUES
The conjugate symmetry of cacosh() is used to abbreviate the specification of special values.
.Pp
.Fn cacosh "0 + 0i"
returns 0 + Pi/2 i.
.Pp
.Fn cacosh "x + inf i"
returns inf + Pi/2 i, for finite x.
.Pp
.Fn cacosh "x + NaN i"
returns NaN + NaN i, for finite nonzero x.
.Pp
.Fn cacosh "-inf + yi"
returns inf + Pi i, for finite positive-signed y.
.Pp
.Fn cacosh "inf + yi"
returns inf + 0i, for finite positive-signed y.
.Pp
.Fn cacosh "-inf + inf i"
returns inf + 3Pi/4 i.
.Pp
.Fn cacosh "inf + inf i"
returns inf + Pi/4 i.
.Pp
.Fn cacosh "inf + NaN i"
returns inf + NaN i.
.Pp
.Fn cacosh "NaN + yi"
returns NaN + NaN i, for finite y.
.Pp
.Fn cacosh "NaN + inf i"
returns inf + NaN i.
.Pp
.Fn cacosh "NaN + NaN i"
returns NaN + NaN i.
.Sh NOTES
.Sh SEE ALSO
.Xr ccosh 3
.Xr complex 3
.Sh STANDARDS
The
.Fn cacosh
function conforms to ISO/IEC 9899:2011.                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cacoshf.3                                    0100644 0001750 0001750 00000000021 12566165764 022355  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/cacosh.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cacoshl.3                                    0100644 0001750 0001750 00000000021 12566165764 022363  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/cacosh.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cacosl.3                                     0100644 0001750 0001750 00000000020 12566165764 022212  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/cacos.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/calloc.3                                     0120777 0001750 0001750 00000000000 12620245063 023523  2malloc.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/callrpc.3                                    0100644 0001750 0001750 00000073141 12566167025 022374  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"	from: @(#)rpc.3n	2.4 88/08/08 4.0 RPCSRC; from 1.19 88/06/24 SMI
.\"	$Id: rpc.3,v 1.1 1999/04/13 23:15:37 wsanchez Exp $
.\"
.TH RPC 3N "16 February 1988"
.SH NAME
rpc \- library routines for remote procedure calls
.SH SYNOPSIS AND DESCRIPTION
These routines allow C programs to make procedure
calls on other machines across the network.
First, the client calls a procedure to send a
data packet to the server.
Upon receipt of the packet, the server calls a dispatch routine
to perform the requested service, and then sends back a
reply.
Finally, the procedure call returns to the client.
.LP
Routines that are used for Secure RPC (DES authentication) are described in
.BR rpc_secure (3N).
Secure RPC can be used only if DES encryption is available.
.LP
.ft B
.nf
.sp .5
#include <rpc/rpc.h>
.fi
.ft R
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
auth_destroy(auth)
\s-1AUTH\s0 *auth;
.fi
.ft R
.IP
A macro that destroys the authentication information associated with
.IR auth .
Destruction usually involves deallocation of private data
structures. The use of
.I auth
is undefined after calling
.BR auth_destroy(\|) .
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authnone_create(\|)
.fi
.ft R
.IP
Create and returns an
.SM RPC
authentication handle that passes nonusable authentication
information with each remote procedure call. This is the
default authentication used by
.SM RPC.
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create(host, uid, gid, len, aup_gids)
char *host;
int uid, gid, len, *aup.gids;
.fi
.ft R
.IP
Create and return an
.SM RPC
authentication handle that contains
.UX
authentication information.
The parameter
.I host
is the name of the machine on which the information was
created;
.I uid
is the user's user
.SM ID ;
.I gid
is the user's current group
.SM ID ;
.I len
and
.I aup_gids
refer to a counted array of groups to which the user belongs.
It is easy to impersonate a user.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create_default(\|)
.fi
.ft R
.IP
Calls
.B authunix_create(\|)
with the appropriate parameters.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
char *host;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Call the remote procedure associated with
.IR prognum ,
.IR versnum ,
and
.I procnum
on the machine,
.IR host .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results.
This routine returns zero if it succeeds, or the value of
.B "enum clnt_stat"
cast to an integer if it fails.
The routine
.B clnt_perrno(\|)
is handy for translating failure statuses into messages.
.IP
Warning: calling remote procedures with this routine
uses
.SM UDP/IP
as a transport; see
.B clntudp_create(\|)
for restrictions.
You do not have control of timeouts or authentication using
this routine.
.br
.if t .ne 16
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_broadcast(prognum, versnum, procnum, inproc, in, outproc, out, eachresult)
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
resultproc_t eachresult;
.fi
.ft R
.IP
Like
.BR callrpc(\|) ,
except the call message is broadcast to all locally
connected broadcast nets. Each time it receives a
response, this routine calls
.BR eachresult(\|) ,
whose form is:
.IP
.RS 1i
.ft B
.nf
eachresult(out, addr)
char *out;
struct sockaddr_in *addr;
.ft R
.fi
.RE
.IP
where
.I out
is the same as
.I out
passed to
.BR clnt_broadcast(\|) ,
except that the remote procedure's output is decoded there;
.I addr
points to the address of the machine that sent the results.
If
.B eachresult(\|)
returns zero,
.B clnt_broadcast(\|)
waits for more replies; otherwise it returns with appropriate
status.
.IP
Warning: broadcast sockets are limited in size to the
maximum transfer unit of the data link. For ethernet,
this value is 1500 bytes.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_call(clnt, procnum, inproc, in, outproc, out, tout)
\s-1CLIENT\s0 *clnt;
u_long
procnum;
xdrproc_t inproc, outproc;
char *in, *out;
struct timeval tout;
.fi
.ft R
.IP
A macro that calls the remote procedure
.I procnum
associated with the client handle,
.IR clnt ,
which is obtained with an
.SM RPC
client creation routine such as
.BR clnt_create(\|) .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results;
.I tout
is the time allowed for results to come back.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
clnt_destroy(clnt)
\s-1CLIENT\s0 *clnt;
.fi
.ft R
.IP
A macro that destroys the client's
.SM RPC
handle. Destruction usually involves deallocation
of private data structures, including
.I clnt
itself.  Use of
.I clnt
is undefined after calling
.BR clnt_destroy(\|) .
If the
.SM RPC
library opened the associated socket, it will close it also.
Otherwise, the socket remains open.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnt_create(host, prog, vers, proto)
char *host;
u_long prog, vers;
char *proto;
.fi
.ft R
.IP
Generic client creation routine.
.I host
identifies the name of the remote host where the server
is located.
.I proto
indicates which kind of transport protocol to use. The
currently supported values for this field are \(lqudp\(rq
and \(lqtcp\(rq.
Default timeouts are set, but can be modified using
.BR clnt_control(\|) .
.IP
Warning: Using
.SM UDP
has its shortcomings.  Since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes of encoded data,
this transport cannot be used for procedures that take
large arguments or return huge results.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
bool_t
clnt_control(cl, req, info)
\s-1CLIENT\s0 *cl;
char *info;
.fi
.ft R
.IP
A macro used to change or retrieve various information
about a client object.
.I req
indicates the type of operation, and
.I info
is a pointer to the information. For both
.SM UDP
and
.SM TCP\s0,
the supported values of
.I req
and their argument types and what they do are:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_TIMEOUT\s0	struct timeval	set total timeout
.SM CLGET_TIMEOUT\s0	struct timeval	get total timeout
.fi
.IP
Note: if you set the timeout using
.BR clnt_control(\|) ,
the timeout parameter passed to
.B clnt_call(\|)
will be ignored in all future calls.
.IP
.nf
.SM CLGET_SERVER_ADDR\s0	struct sockaddr_in 	get server's address
.fi
.br
.IP
The following operations are valid for
.SM UDP
only:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_RETRY_TIMEOUT\s0		struct timeval	set the retry timeout
.SM CLGET_RETRY_TIMEOUT\s0		struct timeval	get the retry timeout
.fi
.br
.IP
The retry timeout is the time that
.SM "UDP RPC"
waits for the server to reply before
retransmitting the request.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
clnt_freeres(clnt, outproc, out)
\s-1CLIENT\s0 *clnt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the results of an
.SM RPC
call.  The
parameter
.I out
is the address of the results, and
.I outproc
is the
.SM XDR
routine describing the results.
This routine returns one if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
void
clnt_geterr(clnt, errp)
\s-1CLIENT\s0 *clnt;
struct rpc_err *errp;
.fi
.ft R
.IP
A macro that copies the error structure out of the client
handle
to the structure at address
.IR errp .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_pcreateerror(s)
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating
why a client
.SM RPC
handle could not be created.
The message is prepended with string
.I s
and a colon.
Used when a
.BR clnt_create(\|) ,
.BR clntraw_create(\|) ,
.BR clnttcp_create(\|) ,
or
.B clntudp_create(\|)
call fails.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_perrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Print a message to standard error corresponding
to the condition indicated by
.IR stat .
Used after
.BR callrpc(\|) .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
clnt_perror(clnt, s)
\s-1CLIENT\s0 *clnt;
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating why an
.SM RPC
call failed;
.I clnt
is the handle used to do the call.
The message is prepended with string
.I s
and a colon.
Used after
.BR clnt_call(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_spcreateerror
char *s;
.fi
.ft R
.IP
Like
.BR clnt_pcreateerror(\|) ,
except that it returns a string
instead of printing to the standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_sperrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Take the same arguments as
.BR clnt_perrno(\|) ,
but instead of sending a message to the standard error
indicating why an
.SM RPC
call failed, return a pointer to a string which contains
the message.  The string ends with a
.SM NEWLINE\s0.
.IP
.B clnt_sperrno(\|)
is used instead of
.B clnt_perrno(\|)
if the program does not have a standard error (as a program
running as a server quite likely does not), or if the
programmer
does not want the message to be output with
.BR printf ,
or if a message format different than that supported by
.B clnt_perrno(\|)
is to be used.
Note: unlike
.B clnt_sperror(\|)
and
.BR clnt_spcreaterror(\|) ,
.B clnt_sperrno(\|)
returns pointer to static data, but the
result will not get overwritten on each call.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
char *
clnt_sperror(rpch, s)
\s-1CLIENT\s0 *rpch;
char *s;
.fi
.ft R
.IP
Like
.BR clnt_perror(\|) ,
except that (like
.BR clnt_sperrno(\|) )
it returns a string instead of printing to standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntraw_create(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum .
The transport used to pass messages to the service is
actually a buffer within the process's address space, so the
corresponding
.SM RPC
server should live in the same address space; see
.BR svcraw_create(\|) .
This allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads, such as round trip times, without any
kernel interference. This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnttcp_create(addr, prognum, versnum, sockp, sendsz, recvsz)
struct sockaddr_in *addr;
u_long prognum, versnum;
int *sockp;
u_int sendsz, recvsz;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses
.SM TCP/IP
as a transport. The remote program is located at Internet
address
.IR *addr .
If
.\"The following in-line font conversion is necessary for the hyphen indicator
\fB\%addr\->sin_port\fR
is zero, then it is set to the actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
the user may specify the size of the send and receive buffers
with the parameters
.I sendsz
and
.IR recvsz ;
values of zero choose suitable defaults.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_create(addr, prognum, versnum, wait, sockp)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
Warning: since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes
of encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_bufcreate(addr, prognum, versnum, wait, sockp, sendsize, recosize)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
unsigned int sendsize;
unsigned int recosize;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
on
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.BR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
This allows the user to specify the maximun packet size for sending and receiving 
.SM UDP\s0-based
.SM RPC
messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
get_myaddress(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
Stuff the machine's
.SM IP
address into
.IR *addr ,
without consulting the library routines that deal with
.BR /etc/hosts .
The port number is always set to
.BR htons(\s-1PMAPPORT\s0) .
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
struct pmaplist *
pmap_getmaps(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns a list of the current
.SM RPC
program-to-port mappings
on the host located at
.SM IP
address
.IR *addr .
This routine can return
.SM NULL .
The command
.RB ` "rpcinfo \-p" '
uses this routine.
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
u_short
pmap_getport(addr, prognum, versnum, protocol)
struct sockaddr_in *addr;
u_long prognum, versnum, protocol;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns the port number
on which waits a service that supports program number
.IR prognum ,
version
.IR versnum ,
and speaks the transport protocol associated with
.IR protocol .
The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
A return value of zero means that the mapping does not exist
or that
the
.SM RPC
system failured to contact the remote
.B portmap
service.  In the latter case, the global variable
.B rpc_createerr(\|)
contains the
.SM RPC
status.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
enum clnt_stat
pmap_rmtcall(addr, prognum, versnum, procnum, inproc, in, outproc, out, tout, portp)
struct sockaddr_in *addr;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
struct timeval tout;
u_long *portp;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which instructs
.B portmap
on the host at
.SM IP
address
.I *addr
to make an
.SM RPC
call on your behalf to a procedure on that host.
The parameter
.I *portp
will be modified to the program's port number if the
procedure
succeeds. The definitions of other parameters are discussed
in
.B callrpc(\|)
and
.BR clnt_call(\|) .
This procedure should be used for a \(lqping\(rq and nothing
else.
See also
.BR clnt_broadcast(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
pmap_set(prognum, versnum, protocol, port)
u_long prognum, versnum, protocol;
u_short port;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which establishes a mapping between the triple
.RI [ prognum , versnum , protocol\fR]
and
.I port
on the machine's
.B portmap
service. The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
This routine returns one if it succeeds, zero otherwise.
Automatically done by
.BR svc_register(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
pmap_unset(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which destroys all mapping between the triple
.RI [ prognum , versnum , *\fR]
and
.B ports
on the machine's
.B portmap
service. This routine returns one if it succeeds, zero
otherwise.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
u_long prognum, versnum, procnum;
char *(*procname) (\|) ;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Register procedure
.I procname
with the
.SM RPC
service package.  If a request arrives for program
.IR prognum ,
version
.IR versnum ,
and procedure
.IR procnum ,
.I procname
is called with a pointer to its parameter(s);
.I progname
should return a pointer to its static result(s);
.I inproc
is used to decode the parameters while
.I outproc
is used to encode the results.
This routine returns zero if the registration succeeded, \-1
otherwise.
.IP
Warning: remote procedures registered in this form
are accessed using the
.SM UDP/IP
transport; see
.B svcudp_create(\|)
for restrictions.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
struct rpc_createerr     rpc_createerr;
.fi
.ft R
.IP
A global variable whose value is set by any
.SM RPC
client creation routine
that does not succeed.  Use the routine
.B clnt_pcreateerror(\|)
to print the reason why.
.if t .ne 7
.LP
.ft B
.nf
.sp .5
svc_destroy(xprt)
\s-1SVCXPRT\s0 *
xprt;
.fi
.ft R
.IP
A macro that destroys the
.SM RPC
service transport handle,
.IR xprt .
Destruction usually involves deallocation
of private data structures, including
.I xprt
itself.  Use of
.I xprt
is undefined after calling this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
fd_set svc_fdset;
.fi
.ft R
.IP
A global variable reflecting the
.SM RPC
service side's
read file descriptor bit mask; it is suitable as a parameter
to the
.B select
system call. This is only of interest
if a service implementor does not call
.BR svc_run(\|) ,
but rather does his own asynchronous event processing.
This variable is read-only (do not pass its address to
.BR select !),
yet it may change after calls to
.B svc_getreqset(\|)
or any creation routines.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
int svc_fds;
.fi
.ft R
.IP
Similar to
.BR svc_fedset(\|) ,
but limited to 32 descriptors. This
interface is obsoleted by
.BR svc_fdset(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_freeargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the arguments to a service procedure
using
.BR svc_getargs(\|) .
This routine returns 1 if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
svc_getargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that decodes the arguments of an
.SM RPC
request
associated with the
.SM RPC
service transport handle,
.IR xprt .
The parameter
.I in
is the address where the arguments will be placed;
.I inproc
is the
.SM XDR
routine used to decode the arguments.
This routine returns one if decoding succeeds, and zero
otherwise.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
struct sockaddr_in *
svc_getcaller(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
The approved way of getting the network address of the caller
of a procedure associated with the
.SM RPC
service transport handle,
.IR xprt .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_getreqset(rdfds)
fd_set *rdfds;
.fi
.ft R
.IP
This routine is only of interest if a service implementor
does not call
.BR svc_run(\|) ,
but instead implements custom asynchronous event processing.
It is called when the
.B select
system call has determined that an
.SM RPC
request has arrived on some
.SM RPC
.B socket(s) ;
.I rdfds
is the resultant read file descriptor bit mask.
The routine returns when all sockets associated with the
value of
.I rdfds
have been serviced.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_getreq(rdfds)
int rdfds;
.fi
.ft R
.IP
Similar to
.BR svc_getreqset(\|) ,
but limited to 32 descriptors. This interface is obsoleted by
.BR svc_getreqset(\|) .
.br
.if t .ne 17
.LP
.ft B
.nf
.sp .5
svc_register(xprt, prognum, versnum, dispatch, protocol)
\s-1SVCXPRT\s0 *xprt;
u_long prognum, versnum;
void (*dispatch) (\|);
u_long protocol;
.fi
.ft R
.IP
Associates
.I prognum
and
.I versnum
with the service dispatch procedure,
.IR dispatch .
If
.I protocol
is zero, the service is not registered with the
.B portmap
service.  If
.I protocol
is non-zero, then a mapping of the triple
.RI [ prognum , versnum , protocol\fR]
to
\fB\%xprt\->xp_port\fR
is established with the local
.B portmap
service (generally
.I protocol
is zero,
.B
.SM IPPROTO_UDP
or 
.B
.SM IPPROTO_TCP
).
The procedure
.I dispatch
has the following form:
.RS 1i
.ft B
.nf
dispatch(request, xprt)
struct svc_req *request;
\s-1SVCXPRT\s0 *xprt;
.ft R
.fi
.RE
.IP
The
.B svc_register(\|)
routine returns one if it succeeds, and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_run(\|)
.fi
.ft R
.IP
This routine never returns. It waits for
.SM RPC
requests to arrive, and calls the appropriate service
procedure using
.B svc_getreq(\|)
when one arrives. This procedure is usually waiting for a
.B select(\|)
system call to return.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_sendreply(xprt, outproc, out)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
Called by an
.SM RPC
service's dispatch routine to send the results of a
remote procedure call.  The parameter
.I xprt
is the request's associated transport handle;
.I outproc
is the
.SM XDR
routine which is used to encode the results; and
.I out
is the address of the results.
This routine returns one if it succeeds, zero otherwise.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svc_unregister(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
Remove all mapping of the double
.RI [ prognum , versnum ]
to dispatch routines, and of the triple
.RI [ prognum , versnum , *\fR]
to port number.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
svcerr_auth(xprt, why)
\s-1SVCXPRT\s0 *xprt;
enum auth_stat why;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to an authentication error.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_decode(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that cannot successfully
decode its parameters. See also
.BR svc_getargs(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noproc(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that does not implement
the procedure number that the caller requests.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noprog(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired program is not registered with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_progvers(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired version of a program is not registered
with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_systemerr(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine when it detects a system
error
not covered by any particular protocol.
For example, if a service can no longer allocate storage,
it may call this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
svcerr_weakauth(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to insufficient
authentication parameters.  The routine calls
.BR "svcerr_auth(xprt, \s-1AUTH_TOOWEAK\s0)" .
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcraw_create(\|)
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
service transport, to which it returns a pointer.  The
transport
is really a buffer within the process's address space,
so the corresponding
.SM RPC
client should live in the same
address space;
see
.BR clntraw_create(\|) .
This routine allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads (such as round trip times), without any kernel
interference.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svctcp_create(sock, send_buf_size, recv_buf_size)
int sock;
u_int send_buf_size, recv_buf_size;
.fi
.ft R
.IP
This routine creates a
.SM TCP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.BR \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM TCP
port, then this routine binds it to an arbitrary port.  Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails. Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
users may specify the size of buffers; values of zero
choose suitable defaults.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcfd_create(fd, sendsize, recvsize)
int fd;
u_int sendsize;
u_int recvsize;
.fi
.ft R
.IP
Create a service on top of any open descriptor. Typically,
this
descriptor is a connected socket for a stream protocol such
as
.SM TCP\s0.
.I sendsize
and
.I recvsize
indicate sizes for the send and receive buffers.  If they are
zero, a reasonable default is chosen.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcudp_bufcreate(sock, sendsize, recosize)
int sock;
.fi
.ft R
.IP
This routine creates a
.SM UDP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.B \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM UDP
port, then this routine binds it to an arbitrary port. Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails.
.IP
This allows the user to specify the maximun packet size for sending and 
receiving
.SM UDP\s0-based
.SM RPC messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_accepted_reply(xdrs, ar)
\s-1XDR\s0 *xdrs;
struct accepted_reply *ar;
.fi
.ft R
.IP
Used for encoding
.SM RPC
reply messages. This routine is useful for users who
wish to generate
\s-1RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_authunix_parms(xdrs, aupp)
\s-1XDR\s0 *xdrs;
struct authunix_parms *aupp;
.fi
.ft R
.IP
Used for describing
.SM UNIX
credentials. This routine is useful for users
who wish to generate these credentials without using the
.SM RPC
authentication package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
xdr_callhdr(xdrs, chdr)
\s-1XDR\s0 *xdrs;
struct rpc_msg *chdr;
.fi
.ft R
.IP
Used for describing
.SM RPC
call header messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_callmsg(xdrs, cmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *cmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
call messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_opaque_auth(xdrs, ap)
\s-1XDR\s0 *xdrs;
struct opaque_auth *ap;
.fi
.ft R
.IP
Used for describing
.SM RPC
authentication information messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmap(xdrs, regs)
\s-1XDR\s0 *xdrs;
struct pmap *regs;
.fi
.ft R
.IP
Used for describing parameters to various
.B portmap
procedures, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmaplist(xdrs, rp)
\s-1XDR\s0 *xdrs;
struct pmaplist **rp;
.fi
.ft R
.IP
Used for describing a list of port mappings, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_rejected_reply(xdrs, rr)
\s-1XDR\s0 *xdrs;
struct rejected_reply *rr;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_replymsg(xdrs, rmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *rmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC
style messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_register(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
After
.SM RPC
service transport handles are created,
they should register themselves with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_unregister(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Before an
.SM RPC
service transport handle is destroyed,
it should unregister itself with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.SH SEE ALSO
.BR rpc_secure (3N),
.BR xdr (3N)
.br
The following manuals:
.RS
.ft I
Remote Procedure Calls: Protocol Specification
.br
Remote Procedure Call Programming Guide
.br
rpcgen Programming Guide
.br
.ft R
.RE
.IR "\s-1RPC\s0: Remote Procedure Call Protocol Specification" ,
.SM RFC1050, Sun Microsystems, Inc.,
.SM USC-ISI\s0.

                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/can_change_color.3x                          0100644 0001750 0001750 00000025775 12566174416 024424  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"***************************************************************************
.\" Copyright (c) 1998-2004,2005 Free Software Foundation, Inc.              *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, to any person obtaining a  *
.\" copy of this software and associated documentation files (the            *
.\" "Software"), to deal in the Software without restriction, including      *
.\" without limitation the rights to use, copy, modify, merge, publish,      *
.\" distribute, distribute with modifications, sublicense, and/or sell       *
.\" copies of the Software, and to permit persons to whom the Software is    *
.\" furnished to do so, subject to the following conditions:                 *
.\"                                                                          *
.\" The above copyright notice and this permission notice shall be included  *
.\" in all copies or substantial portions of the Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained in this notice, the name(s) of the above copyright   *
.\" holders shall not be used in advertising or otherwise to promote the     *
.\" sale, use or other dealings in this Software without prior written       *
.\" authorization.                                                           *
.\"***************************************************************************
.\"
.\" $Id: curs_color.3x,v 1.28 2005/12/18 00:00:37 tom Exp $
.TH curs_color 3X ""
.na
.hy 0
.SH NAME
\fBstart_color\fR,
\fBinit_pair\fR,
\fBinit_color\fR,
\fBhas_colors\fR,
\fBcan_change_color\fR,
\fBcolor_content\fR,
\fBpair_content\fR,
\fBCOLOR_PAIR\fR - \fBcurses\fR color manipulation routines
.ad
.hy
.SH SYNOPSIS
\fB# include <curses.h>\fR
.br
\fBint start_color(void);\fR
.br
\fBint init_pair(short pair, short f, short b);\fR
.br
\fBint init_color(short color, short r, short g, short b);\fR
.br
\fBbool has_colors(void);\fR
.br
\fBbool can_change_color(void);\fR
.br
\fBint color_content(short color, short *r, short *g, short *b);\fR
.br
\fBint pair_content(short pair, short *f, short *b);\fR
.br
.SH DESCRIPTION
.SS Overview
\fBcurses\fR support color attributes on terminals with that capability.  To
use these routines \fBstart_color\fR must be called, usually right after
\fBinitscr\fR.  Colors are always used in pairs (referred to as color-pairs).
A color-pair consists of a foreground color (for characters) and a background
color (for the blank field on which the characters are displayed).  A
programmer initializes a color-pair with the routine \fBinit_pair\fR.  After it
has been initialized, \fBCOLOR_PAIR\fR(\fIn\fR), a macro defined in
\fB<curses.h>\fR, can be used as a new video attribute.
.PP
If a terminal is capable of redefining colors, the programmer can use the
routine \fBinit_color\fR to change the definition of a color.  The routines
\fBhas_colors\fR and \fBcan_change_color\fR return \fBTRUE\fR or \fBFALSE\fR,
depending on whether the terminal has color capabilities and whether the
programmer can change the colors.  The routine \fBcolor_content\fR allows a
programmer to extract the amounts of red, green, and blue components in an
initialized color.  The routine \fBpair_content\fR allows a programmer to find
out how a given color-pair is currently defined.
.SS Routine Descriptions
The \fBstart_color\fR routine requires no arguments.  It must be
called if the programmer wants to use colors, and before any other
color manipulation routine is called.  It is good practice to call
this routine right after \fBinitscr\fR.  \fBstart_color\fR initializes
eight basic colors (black, red, green, yellow, blue, magenta, cyan,
and white), and two global variables, \fBCOLORS\fR and
\fBCOLOR_PAIRS\fR (respectively defining the maximum number of colors
and color-pairs the terminal can support).  It also restores the
colors on the terminal to the values they had when the terminal was
just turned on.
.PP
The \fBinit_pair\fR routine changes the definition of a color-pair.  It takes
three arguments: the number of the color-pair to be changed, the foreground
color number, and the background color number.
For portable applications:
.TP 5
-
The value of the first argument
must be between \fB1\fR and \fBCOLOR_PAIRS-1\fR.
.TP 5
-
The value of the second and
third arguments must be between 0 and \fBCOLORS\fR.
Color pair 0 is assumed to be white on black,
but is actually whatever the terminal implements before color is initialized.
It cannot be modified by the application.
.PP
If the color-pair was previously
initialized, the screen is refreshed and all occurrences of that color-pair
are changed to the new definition.
.PP
As an extension, ncurses allows you to set color pair 0 via
the \fBassume_default_colors\fR routine, or to specify the use of
default colors (color number \fB-1\fR) if you first invoke the
\fBuse_default_colors\fR routine.
.PP
The \fBinit_color\fR routine changes the definition of a color.  It takes four
arguments: the number of the color to be changed followed by three RGB values
(for the amounts of red, green, and blue components).  The value of the first
argument must be between \fB0\fR and \fBCOLORS\fR.  (See the section
\fBColors\fR for the default color index.)  Each of the last three arguments
must be a value between 0 and 1000.  When \fBinit_color\fR is used, all
occurrences of that color on the screen immediately change to the new
definition.
.PP
The \fBhas_colors\fR routine requires no arguments.  It returns \fBTRUE\fR if
the terminal can manipulate colors; otherwise, it returns \fBFALSE\fR.  This
routine facilitates writing terminal-independent programs.  For example, a
programmer can use it to decide whether to use color or some other video
attribute.
.PP
The \fBcan_change_color\fR routine requires no arguments.  It returns
\fBTRUE\fR if the terminal supports colors and can change their definitions;
other, it returns \fBFALSE\fR.  This routine facilitates writing
terminal-independent programs.
.PP
The \fBcolor_content\fR routine gives programmers a way to find the intensity
of the red, green, and blue (RGB) components in a color.  It requires four
arguments: the color number, and three addresses of \fBshort\fRs for storing
the information about the amounts of red, green, and blue components in the
given color.  The value of the first argument must be between 0 and
\fBCOLORS\fR.  The values that are stored at the addresses pointed to by the
last three arguments are between 0 (no component) and 1000 (maximum amount of
component).
.PP
The \fBpair_content\fR routine allows programmers to find out what colors a
given color-pair consists of.  It requires three arguments: the color-pair
number, and two addresses of \fBshort\fRs for storing the foreground and the
background color numbers.  The value of the first argument must be between 1
and \fBCOLOR_PAIRS-1\fR.  The values that are stored at the addresses pointed
to by the second and third arguments are between 0 and \fBCOLORS\fR.
.SS Colors
In \fB<curses.h>\fR the following macros are defined.  These are the default
colors.  \fBcurses\fR also assumes that \fBCOLOR_BLACK\fR is the default
background color for all terminals.
.PP
.nf
      \fBCOLOR_BLACK\fR
      \fBCOLOR_RED\fR
      \fBCOLOR_GREEN\fR
      \fBCOLOR_YELLOW\fR
      \fBCOLOR_BLUE\fR
      \fBCOLOR_MAGENTA\fR
      \fBCOLOR_CYAN\fR
      \fBCOLOR_WHITE\fR
.fi
.SH RETURN VALUE
The routines \fBcan_change_color()\fR and \fBhas_colors()\fR return \fBTRUE\fR
or \fBFALSE\fR.
.PP
All other routines return the integer \fBERR\fR upon failure and an \fBOK\fR
(SVr4 specifies only "an integer value other than \fBERR\fR") upon successful
completion.
.PP
X/Open defines no error conditions.
This implementation will return \fBERR\fR on attempts to
use color values outside the range 0 to COLORS-1
(except for the default colors extension),
or use color pairs outside the range 0 to COLOR_PAIR-1.
Color values used in \fBinit_color\fP must be in the range 0 to 1000.
An error is returned from all functions
if the terminal has not been initialized.
An error is returned from secondary functions such as \fBinit_pair\fP
if \fBstart_color\fP was not called.
.RS
.TP 5
\fBinit_color\fP
returns an error if the terminal does not support
this feature, e.g., if the \fIinitialize_color\fP capability is absent
from the terminal description.
.TP 5
\fBstart_color\fP
returns an error
If the color table cannot be allocated.
.RE
.SH NOTES
In the \fIncurses\fR implementation, there is a separate color activation flag,
color palette, color pairs table, and associated COLORS and COLOR_PAIRS counts
for each screen; the \fBstart_color\fR function only affects the current
screen.  The SVr4/XSI interface is not really designed with this in mind, and
historical implementations may use a single shared color palette.
.PP
Note that setting an implicit background color via a color pair affects only
character cells that a character write operation explicitly touches.  To change
the background color used when parts of a window are blanked by erasing or
scrolling operations, see \fBcurs_bkgd\fR(3X).
.PP
Several caveats apply on 386 and 486 machines with VGA-compatible graphics:
.TP 5
-
COLOR_YELLOW is actually brown.  To get yellow, use COLOR_YELLOW combined with
the \fBA_BOLD\fR attribute.
.TP 5
-
The A_BLINK attribute should in theory cause the background to go bright.  This
often fails to work, and even some cards for which it mostly works (such as the
Paradise and compatibles) do the wrong thing when you try to set a bright
"yellow" background (you get a blinking yellow foreground instead).
.TP 5
-
Color RGB values are not settable.
.SH PORTABILITY
This implementation satisfies XSI Curses's minimum maximums
for \fBCOLORS\fR and \fBCOLOR_PAIRS\fR.
.PP
The \fBinit_pair\fP routine accepts negative values of foreground
and background color to support the \fBuse_default_colors\fP extension,
but only if that routine has been first invoked.
.PP
The assumption that \fBCOLOR_BLACK\fR is the default
background color for all terminals can be modified using the
\fBassume_default_colors\fP extension.
.PP
This implementation checks the pointers,
e.g., for the values returned by
\fBcolor_content\fP and \fBpair_content\fP,
and will treat those as optional parameters when null.
.SH SEE ALSO
\fBcurses\fR(3X),
\fBcurs_initscr\fR(3X),
\fBcurs_attr\fR(3X),
\fBdefault_colors\fR(3X)
.\"#
.\"# The following sets edit modes for GNU EMACS
.\"# Local Variables:
.\"# mode:nroff
.\"# fill-column:79
.\"# End:
   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/carg.3                                       0100644 0001750 0001750 00000000017 12566165764 021670  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/cabs.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cargf.3                                      0100644 0001750 0001750 00000000017 12566165764 022036  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/cabs.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cargl.3                                      0100644 0001750 0001750 00000000017 12566165764 022044  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/cabs.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/casin.3                                      0100644 0001750 0001750 00000002474 12566165764 022062  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2006 Apple Computer
.\"
.Dd December 11, 2006
.Dt CASIN 3
.Os BSD 4
.Sh NAME
.Nm casin
.Nd complex inverse sine function
.br
.Nm catan
.Nd complex inverse tangent function
.Sh SYNOPSIS
.Fd #include <complex.h>
.Ft double complex
.Fn casin "double complex z"
.Ft long double complex
.Fn casinl "long double complex z"
.Ft float complex
.Fn casinf "float complex z"
.Ft double complex
.Fn catan "double complex z"
.Ft long double complex
.Fn catanl "long double complex z"
.Ft float complex
.Fn catanf "float complex z"
.Sh DESCRIPTION
.Fn casin "z"
computes the inverse sine of the complex floating-point number
.Fa z ,
with branch cuts outside the interval
.Bq -1, 1
on the real axis.
.Pp
.Fn ctan "z"
computes the inverse tangent of the complex floating-point number
.Fa z ,
with branch cuts outside the interval
.Bq -i, i
on the imaginary axis.
.Pp
Both functions return values in a strip of the complex plane with unbounded imaginary part, and real part in the interval
.Bq -Pi/2, Pi/2 .
.Sh NOTES
casin and catan are defined in terms of the complex inverse hyperbolic functions as follows:
.Bd -literal -offset indent
casin(z) = -i * casinh(i*z),
.br
catan(z) = -i * catanh(i*z).
.Ed
.Sh SEE ALSO
.Xr casinh 3
.Xr catanh 3
.Xr complex 3
.Sh STANDARDS
The
.Fn casin
and
.Fn catan
functions conform to ISO/IEC 9899:2011.                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/casinf.3                                     0100644 0001750 0001750 00000000020 12566165764 022211  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/casin.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/casinh.3                                     0100644 0001750 0001750 00000003014 12566165764 022221  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2006 Apple Computer
.\"
.Dd December 11, 2006
.Dt CASINH 3
.Os BSD 4
.Sh NAME
.Nm casinh
.Nd complex inverse hyperbolic sine function
.Sh SYNOPSIS
.Ft double complex
.Fn casinh "double complex z"
.Ft long double complex
.Fn casinhl "long double complex z"
.Ft float complex
.Fn casinhf "float complex z"
.Sh DESCRIPTION
.Fn casinh "z"
computes the inverse hyperbolic sine of the complex floating-point number
.Fa z ,
with branch cuts outside the interval
.Bq -i, i
along the imaginary axis.
.Pp
.Fn casinh
returns values in a strip of the complex plane with imaginary part in the interval
.Bq -Pi/2 , Pi/2 .
.Pp
For all complex floating point numbers z,
.Bd -literal -offset indent
casinh(conj(z)) = conj(casinh(z)).
casinh(-z) = -casinh(z)
.Ed
.Sh SPECIAL VALUES
The symmetries of casinh() are used to abbreviate the specification of special values.
.Pp
.Fn casinh "0 + 0i"
returns 0 + 0 i.
.Pp
.Fn casinh "x + inf i"
returns inf + Pi/2 i, for finite positive-signed x.
.Pp
.Fn casinh "x + NaN i"
returns NaN + NaN i, for finite x.
.Pp
.Fn casinh "inf + yi"
returns inf + 0i, for finite positive-signed y.
.Pp
.Fn casinh "inf + inf i"
returns inf + Pi/4 i.
.Pp
.Fn casinh "inf + NaN i"
returns inf + NaN i.
.Pp
.Fn casinh "NaN + 0i"
returns NaN + 0i.
.Pp
.Fn casinh "NaN + yi"
returns NaN + NaN i, for finite y.
.Pp
.Fn casinh "NaN + inf i"
returns inf + NaN i.
.Pp
.Fn casinh "NaN + NaN i"
returns NaN + NaN i.
.Sh NOTES
.Sh SEE ALSO
.Xr csinh 3
.Xr complex 3
.Sh STANDARDS
The
.Fn casinh
function conforms to ISO/IEC 9899:2011.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/casinhf.3                                    0100644 0001750 0001750 00000000021 12566165764 022362  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/casinh.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/casinhl.3                                    0100644 0001750 0001750 00000000021 12566165764 022370  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/casinh.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/casinl.3                                     0100644 0001750 0001750 00000000020 12566165764 022217  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/casin.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/catan.3                                      0100644 0001750 0001750 00000000020 12566165764 022034  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/casin.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/catanf.3                                     0100644 0001750 0001750 00000000020 12566165764 022202  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/casin.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/catanh.3                                     0100644 0001750 0001750 00000003140 12566165764 022212  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2006 Apple Computer
.\"
.Dd December 11, 2006
.Dt CATANH 3
.Os BSD 4
.Sh NAME
.Nm catanh
.Nd complex inverse hyperbolic tangent function
.Sh SYNOPSIS
.Ft double complex
.Fn catanh "double complex z"
.Ft long double complex
.Fn catanhl "long double complex z"
.Ft float complex
.Fn catanhf "float complex z"
.Sh DESCRIPTION
.Fn catanh "z"
computes the inverse hyperbolic tangent of the complex floating-point number
.Fa z ,
with branch cuts outside the interval
.Bq -1, 1
along the real axis.
.Pp
.Fn catanh
returns values in a strip of the complex plane with imaginary part in the interval
.Bq -Pi/2 , Pi/2 .
.Pp
For all complex floating point numbers z,
.Bd -literal -offset indent
catanh(conj(z)) = conj(catanh(z)).
catanh(-z) = -catanh(z)
.Ed
.Sh SPECIAL VALUES
The symmetries of catanh() are used to abbreviate the specification of special values.
.Pp
.Fn catanh "0 + 0i"
returns 0 + 0 i.
.Pp
.Fn catanh "0 + NaN i"
returns 0 + NaN i.
.Pp
.Fn catanh "1 + 0i"
returns inf + 0i and raises the divide-by-zero flag.
.Pp
.Fn catanh "x + inf i"
returns 0 + Pi/2 i, for finite positive-signed x.
.Pp
.Fn catanh "x + NaN i"
returns NaN + NaN i, for non-zero finite x.
.Pp
.Fn catanh "inf + yi"
returns 0 + Pi/2 i, for finite positive-signed y.
.Pp
.Fn catanh "inf + inf i"
returns 0 + Pi/2 i.
.Pp
.Fn catanh "inf + NaN i"
returns 0 + NaN i.
.Pp
.Fn catanh "NaN + yi"
returns NaN + NaN i, for finite y.
.Pp
.Fn catanh "NaN + inf i"
returns 0 + Pi/2 i.
.Pp
.Fn catanh "NaN + NaN i"
returns NaN + NaN i.
.Sh NOTES
.Sh SEE ALSO
.Xr ctanh 3
.Xr complex 3
.Sh STANDARDS
The
.Fn catanh
function conforms to ISO/IEC 9899:2011.                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/catanhf.3                                    0100644 0001750 0001750 00000000021 12566165764 022353  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/catanh.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/catanhl.3                                    0100644 0001750 0001750 00000000021 12566165764 022361  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/catanh.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/catanl.3                                     0100644 0001750 0001750 00000000020 12566165764 022210  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/casin.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/catclose.3                                   0100644 0001750 0001750 00000004471 12566166140 022546  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 1994 Winning Strategies, Inc.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"      This product includes software developed by Winning Strategies, Inc.
.\" 4. The name of the author may not be used to endorse or promote products
.\"    derived from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
.\" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
.\" IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
.\" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
.\" NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
.\" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.\" $FreeBSD: src/lib/libc/nls/catclose.3,v 1.15 2005/02/27 16:30:16 phantom Exp $
.Dd February 12, 2005
.Dt CATCLOSE 3
.Os
.Sh NAME
.Nm catclose
.Nd close message catalog
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In nl_types.h
.Ft int
.Fn catclose "nl_catd catd"
.Sh DESCRIPTION
The
.Fn catclose
function closes the message catalog specified by the argument
.Fa catd .
.Sh RETURN VALUES
.Rv -std catclose
.Sh ERRORS
.Bl -tag -width Er
.It Bq Er EBADF
An invalid message catalog descriptor was passed by the
.Fa catd
argument.
.El
.Sh SEE ALSO
.Xr gencat 1 ,
.Xr catgets 3 ,
.Xr catopen 3
.Sh STANDARDS
The
.Fn catclose
function conforms to
.St -p1003.1-2001 .
                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/catgets.3                                    0100644 0001750 0001750 00000005422 12566166140 022400  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 1994 Winning Strategies, Inc.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"      This product includes software developed by Winning Strategies, Inc.
.\" 4. The name of the author may not be used to endorse or promote products
.\"    derived from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
.\" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
.\" IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
.\" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
.\" NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
.\" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.\" $FreeBSD: src/lib/libc/nls/catgets.3,v 1.13 2005/06/15 19:04:04 ru Exp $
.Dd February 12, 2005
.Dt CATGETS 3
.Os
.Sh NAME
.Nm catgets
.Nd retrieve string from message catalog
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In nl_types.h
.Ft char *
.Fn catgets "nl_catd catd" "int set_id" "int msg_id" "const char *s"
.Sh DESCRIPTION
The
.Fn catgets
function attempts to retrieve message
.Fa msg_id
of set
.Fa set_id
from the message catalog referenced by the descriptor
.Fa catd .
The argument
.Fa s
points to a default message which is returned if the function
is unable to retrieve the specified message.
.Sh RETURN VALUES
If the specified message was retrieved successfully,
.Fn catgets
returns a pointer to an internal buffer containing the message string;
otherwise it returns
.Fa s .
.Sh ERRORS
.Bl -tag -width Er
.It Bq Er EBADF
The
.Fa catd
argument is not a valid message catalog descriptor.
.It Bq Er EBADMSG
The message identified by
.Fa set_id
and
.Fa msg_id
is not in the message catalog.
.El
.Sh SEE ALSO
.Xr gencat 1 ,
.Xr catclose 3 ,
.Xr catopen 3
.Sh STANDARDS
The
.Fn catgets
function conforms to
.St -p1003.1-2001 .
                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/catopen.3                                    0100644 0001750 0001750 00000010236 12566166141 022377  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 1994 Winning Strategies, Inc.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"      This product includes software developed by Winning Strategies, Inc.
.\" 4. The name of the author may not be used to endorse or promote products
.\"    derived from this software without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
.\" OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
.\" IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
.\" INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
.\" NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
.\" DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
.\" THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
.\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
.\" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
.\"
.\" $FreeBSD: src/lib/libc/nls/catopen.3,v 1.17 2005/02/27 16:30:16 phantom Exp $
.Dd February 12, 2005
.Dt CATOPEN 3
.Os
.Sh NAME
.Nm catopen
.Nd open message catalog
.Sh LIBRARY
.Lb libc
.Sh SYNOPSIS
.In nl_types.h
.Ft nl_catd
.Fn catopen "const char *name" "int oflag"
.Sh DESCRIPTION
The
.Fn catopen
function opens the message catalog specified by
.Fa name
and returns a message catalog descriptor.
If
.Fa name
contains a
.Sq /
then
.Fa name
specifies the full pathname for the message catalog, otherwise the value
of the environment variable
.Ev NLSPATH
is used with
the following substitutions:
.Bl -tag -width XXX
.It \&%N
The value of the
.Fa name
argument.
.It \&%L
The value of the
.Ev LANG
environment variable or the
.Dv LC_MESSAGES
category (see below).
.It \&%l
The language element from the
.Ev LANG
environment variable or from the
.Dv LC_MESSAGES
category.
.It \&%t
The territory element from the
.Ev LANG
environment variable or from the
.Dv LC_MESSAGES
category.
.It \&%c
The codeset element from the
.Ev LANG
environment variable or from the
.Dv LC_MESSAGES
category.
.It \&%%
A single % character.
.El
.Pp
An empty string is substituted for undefined values.
.Pp
Path names templates defined in
.Ev NLSPATH
are separated by colons
.No ( Sq \&: ) .
A leading or two adjacent colons
is equivalent to specifying %N.
.Pp
If the
.Fa oflag
argument is set to the
.Dv NL_CAT_LOCALE
constant,
.Dv LC_MESSAGES
locale category used to open the message catalog; using
.Dv NL_CAT_LOCALE
conforms to the
.St -xpg4
standard.
You can specify 0 for compatibility with
.St -xpg3 ;
when
.Fa oflag
is set to 0, the
.Ev LANG
environment variable
determines the message catalog locale.
.Pp
A message catalog descriptor
remains valid in a process until that process closes it, or
until a successful call to one of the
.Xr exec 3
function.
.Sh RETURN VALUES
Upon successful completion,
.Fn catopen
returns a message catalog descriptor.
Otherwise, (nl_catd) -1 is returned and
.Va errno
is set to indicate the error.
.Sh ERRORS
.Bl -tag -width Er
.It Bq Er EINVAL
Argument
.Fa name
does not point to a valid message catalog, or catalog is corrupt.
.It Bq Er ENAMETOOLONG
An entire path to the message catalog exceeded 1024 characters.
.It Bq Er ENOENT
The named message catalog does not exists, or the
.Fa name
argument points to an empty string.
.It Bq Er ENOMEM
Insufficient memory is available.
.El
.Sh SEE ALSO
.Xr gencat 1 ,
.Xr catclose 3 ,
.Xr catgets 3 ,
.Xr setlocale 3
.Sh STANDARDS
The
.Fn catopen
function conforms to
.St -p1003.1-2001 .
                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cbreak.3x                                    0100644 0001750 0001750 00000026165 12566174417 022402  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"***************************************************************************
.\" Copyright (c) 1998-2003,2005 Free Software Foundation, Inc.              *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, to any person obtaining a  *
.\" copy of this software and associated documentation files (the            *
.\" "Software"), to deal in the Software without restriction, including      *
.\" without limitation the rights to use, copy, modify, merge, publish,      *
.\" distribute, distribute with modifications, sublicense, and/or sell       *
.\" copies of the Software, and to permit persons to whom the Software is    *
.\" furnished to do so, subject to the following conditions:                 *
.\"                                                                          *
.\" The above copyright notice and this permission notice shall be included  *
.\" in all copies or substantial portions of the Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained in this notice, the name(s) of the above copyright   *
.\" holders shall not be used in advertising or otherwise to promote the     *
.\" sale, use or other dealings in this Software without prior written       *
.\" authorization.                                                           *
.\"***************************************************************************
.\"
.\" $Id: curs_inopts.3x,v 1.13 2005/05/15 16:18:07 tom Exp $
.TH curs_inopts 3X ""
.na
.hy 0
.SH NAME
\fBcbreak\fR,
\fBnocbreak\fR,
\fBecho\fR,
\fBnoecho\fR,
\fBhalfdelay\fR,
\fBintrflush\fR,
\fBkeypad\fR,
\fBmeta\fR,
\fBnodelay\fR,
\fBnotimeout\fR,
\fBraw\fR,
\fBnoraw\fR,
\fBnoqiflush\fR,
\fBqiflush\fR,
\fBtimeout\fR,
\fBwtimeout\fR,
\fBtypeahead\fR - \fBcurses\fR input options
.ad
.hy
.SH SYNOPSIS
\fB#include <curses.h>\fR
.PP
\fBint cbreak(void);\fR
.br
\fBint nocbreak(void);\fR
.br
\fBint echo(void);\fR
.br
\fBint noecho(void);\fR
.br
\fBint halfdelay(int tenths);\fR
.br
\fBint intrflush(WINDOW *win, bool bf);\fR
.br
\fBint keypad(WINDOW *win, bool bf);\fR
.br
\fBint meta(WINDOW *win, bool bf);\fR
.br
\fBint nodelay(WINDOW *win, bool bf);\fR
.br
\fBint raw(void);\fR
.br
\fBint noraw(void);\fR
.br
\fBvoid noqiflush(void);\fR
.br
\fBvoid qiflush(void);\fR
.br
\fBint notimeout(WINDOW *win, bool bf);\fR
.br
\fBvoid timeout(int delay);\fR
.br
\fBvoid wtimeout(WINDOW *win, int delay);\fR
.br
\fBint typeahead(int fd);\fR
.br
.SH DESCRIPTION
Normally, the tty driver buffers typed characters until a newline or carriage
return is typed.  The \fBcbreak\fR routine disables line buffering and
erase/kill character-processing (interrupt and flow control characters are
unaffected), making characters typed by the user immediately available to the
program.  The \fBnocbreak\fR routine returns the terminal to normal (cooked)
mode.
.PP
Initially the terminal may or may not be in \fBcbreak\fR mode, as the mode is
inherited; therefore, a program should call \fBcbreak\fR or \fBnocbreak\fR
explicitly.  Most interactive programs using \fBcurses\fR set the \fBcbreak\fR
mode.  Note that \fBcbreak\fR overrides \fBraw\fR.
[See \fBcurs_getch\fR(3X) for a
discussion of how these routines interact with \fBecho\fR and \fBnoecho\fR.]
.PP
The \fBecho\fR and \fBnoecho\fR routines control whether characters typed by
the user are echoed by \fBgetch\fR as they are typed.  Echoing by the tty
driver is always disabled, but initially \fBgetch\fR is in echo mode, so
characters typed are echoed.  Authors of most interactive programs prefer to do
their own echoing in a controlled area of the screen, or not to echo at all, so
they disable echoing by calling \fBnoecho\fR.
[See \fBcurs_getch\fR(3X) for a
discussion of how these routines interact with \fBcbreak\fR and
\fBnocbreak\fR.]
.PP
The \fBhalfdelay\fR routine is used for half-delay mode, which is similar to
\fBcbreak\fR mode in that characters typed by the user are immediately
available to the program.  However, after blocking for \fItenths\fR tenths of
seconds, ERR is returned if nothing has been typed.  The value of \fBtenths\fR
must be a number between 1 and 255.  Use \fBnocbreak\fR to leave half-delay
mode.
.PP
If the \fBintrflush\fR option is enabled, (\fIbf\fR is \fBTRUE\fR), when an
interrupt key is pressed on the keyboard (interrupt, break, quit) all output in
the tty driver queue will be flushed, giving the effect of faster response to
the interrupt, but causing \fBcurses\fR to have the wrong idea of what is on
the screen.  Disabling (\fIbf\fR is \fBFALSE\fR), the option prevents the
flush.  The default for the option is inherited from the tty driver settings.
The window argument is ignored.
.PP
The \fBkeypad\fR option enables the keypad of the user's terminal.  If
enabled (\fIbf\fR is \fBTRUE\fR), the user can press a function key
(such as an arrow key) and \fBwgetch\fR returns a single value
representing the function key, as in \fBKEY_LEFT\fR.  If disabled
(\fIbf\fR is \fBFALSE\fR), \fBcurses\fR does not treat function keys
specially and the program has to interpret the escape sequences
itself.  If the keypad in the terminal can be turned on (made to
transmit) and off (made to work locally), turning on this option
causes the terminal keypad to be turned on when \fBwgetch\fR is
called.  The default value for keypad is false.
.PP
Initially, whether the terminal returns 7 or 8 significant bits on
input depends on the control mode of the tty driver [see termio(7)].
To force 8 bits to be returned, invoke \fBmeta\fR(\fIwin\fR,
\fBTRUE\fR); this is equivalent, under POSIX, to setting the CS8 flag
on the terminal.  To force 7 bits to be returned, invoke
\fBmeta\fR(\fIwin\fR, \fBFALSE\fR); this is equivalent, under POSIX,
to setting the CS7 flag on the terminal.  The window argument,
\fIwin\fR, is always ignored.  If the terminfo capabilities \fBsmm\fR
(meta_on) and \fBrmm\fR (meta_off) are defined for the terminal,
\fBsmm\fR is sent to the terminal when \fBmeta\fR(\fIwin\fR,
\fBTRUE\fR) is called and \fBrmm\fR is sent when \fBmeta\fR(\fIwin\fR,
\fBFALSE\fR) is called.
.PP
The \fBnodelay\fR option causes \fBgetch\fR to be a non-blocking call.
If no input is ready, \fBgetch\fR returns \fBERR\fR.  If disabled
(\fIbf\fR is \fBFALSE\fR), \fBgetch\fR waits until a key is pressed.
.PP
While interpreting an input escape sequence, \fBwgetch\fR sets a timer
while waiting for the next character.  If \fBnotimeout(\fR\fIwin\fR,
\fBTRUE\fR) is called, then \fBwgetch\fR does not set a timer.  The
purpose of the timeout is to differentiate between sequences received
from a function key and those typed by a user.
.PP
The \fBraw\fR and \fBnoraw\fR routines place the terminal into or out of raw
mode.  Raw mode is similar to \fBcbreak\fR mode, in that characters typed are
immediately passed through to the user program.  The differences are that in
raw mode, the interrupt, quit, suspend, and flow control characters are all
passed through uninterpreted, instead of generating a signal.  The behavior of
the BREAK key depends on other bits in the tty driver that are not set by
\fBcurses\fR.
.PP
When the \fBnoqiflush\fR routine is used, normal flush of input and
output queues associated with the \fBINTR\fR, \fBQUIT\fR and
\fBSUSP\fR characters will not be done [see termio(7)].  When
\fBqiflush\fR is called, the queues will be flushed when these control
characters are read.  You may want to call \fBnoqiflush()\fR in a signal
handler if you want output to continue as though the interrupt
had not occurred, after the handler exits.
.PP
The \fBtimeout\fR and \fBwtimeout\fR routines set blocking or
non-blocking read for a given window.  If \fIdelay\fR is negative,
blocking read is used (i.e., waits indefinitely for
input).  If \fIdelay\fR is zero, then non-blocking read is used
(i.e., read returns \fBERR\fR if no input is waiting).  If
\fIdelay\fR is positive, then read blocks for \fIdelay\fR
milliseconds, and returns \fBERR\fR if there is still no input.
Hence, these routines provide the same functionality as \fBnodelay\fR,
plus the additional capability of being able to block for only
\fIdelay\fR milliseconds (where \fIdelay\fR is positive).
.PP
The \fBcurses\fR library does ``line-breakout optimization'' by looking for
typeahead periodically while updating the screen.  If input is found,
and it is coming from a tty, the current update is postponed until
\fBrefresh\fR or \fBdoupdate\fR is called again.  This allows faster
response to commands typed in advance.  Normally, the input FILE
pointer passed to \fBnewterm\fR, or \fBstdin\fR in the case that
\fBinitscr\fR was used, will be used to do this typeahead checking.
The \fBtypeahead\fR routine specifies that the file descriptor
\fIfd\fR is to be used to check for typeahead instead.  If \fIfd\fR is
-1, then no typeahead checking is done.
.SH RETURN VALUE
All routines that return an integer return \fBERR\fR upon failure and OK (SVr4
specifies only "an integer value other than \fBERR\fR") upon successful
completion, unless otherwise noted in the preceding routine descriptions.
.PP
X/Open does not define any error conditions.
In this implementation,
functions with a window parameter will return an error if it is null.
Any function will also return an error if the terminal was not initialized.
Also,
.RS
.TP 5
\fBhalfdelay\fP
returns an error
if its parameter is outside the range 1..255.
.RE
.SH PORTABILITY
These functions are described in the XSI Curses standard, Issue 4.
.PP
The ncurses library obeys the XPG4 standard and the historical practice of the
AT&T curses implementations, in that the echo bit is cleared when curses
initializes the terminal state.  BSD curses differed from this slightly; it
left the echo bit on at initialization, but the BSD \fBraw\fR call turned it
off as a side-effect.  For best portability, set echo or noecho explicitly
just after initialization, even if your program remains in cooked mode.
.SH NOTES
Note that \fBecho\fR, \fBnoecho\fR, \fBhalfdelay\fR, \fBintrflush\fR,
\fBmeta\fR, \fBnodelay\fR, \fBnotimeout\fR, \fBnoqiflush\fR,
\fBqiflush\fR, \fBtimeout\fR, and \fBwtimeout\fR may be macros.
.PP
The \fBnoraw\fR and \fBnocbreak\fR calls follow historical practice in that
they attempt to restore to normal (`cooked') mode from raw and cbreak modes
respectively.  Mixing raw/noraw and cbreak/nocbreak calls leads to tty driver
control states that are hard to predict or understand; it is not recommended.
.SH SEE ALSO
\fBcurses\fR(3X), \fBcurs_getch\fR(3X), \fBcurs_initscr\fR(3X), \fBtermio\fR(7)
.\"#
.\"# The following sets edit modes for GNU EMACS
.\"# Local Variables:
.\"# mode:nroff
.\"# fill-column:79
.\"# End:
                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cbrt.3                                       0100644 0001750 0001750 00000004605 12566165764 021715  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 1985, 1991 Regents of the University of California.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     from: @(#)sqrt.3	6.4 (Berkeley) 5/6/91
.\"	$Id: cbrt.3,v 1.4 2004/12/20 21:35:44 scp Exp $
.\"
.Dd December 11, 2006
.Dt CBRT 3
.Os
.Sh NAME
.Nm cbrt
.Nd cube root function
.Sh SYNOPSIS
.Fd #include <math.h>
.Ft double
.Fn cbrt "double x"
.Ft long double
.Fn cbrtl "long double x"
.Ft float
.Fn cbrtf "float x"
.Sh DESCRIPTION
The
.Fn cbrt
function computes
the cube root of
.Ar x .
.Sh SPECIAL VALUES
.Fn cbrt "0"
returns 0.
.Pp
.Fn cbrt "infinity"
returns infinity.
.Sh SEE ALSO
.Xr math 3 ,
.Xr sqrt 3
.Sh STANDARDS
The
.Fn cbrt
function conforms to ISO/IEC 9899:2011.
                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cbrtf.3                                      0100644 0001750 0001750 00000000017 12566165764 022054  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/cbrt.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cbrtl.3                                      0100644 0001750 0001750 00000000017 12566165764 022062  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/cbrt.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ccos.3                                       0100644 0001750 0001750 00000000017 12566165764 021703  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/csin.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ccosf.3                                      0100644 0001750 0001750 00000000017 12566165764 022051  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/csin.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ccosh.3                                      0100644 0001750 0001750 00000002773 12566165764 022066  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2006 Apple Computer
.\"
.Dd December 11, 2006
.Dt CCOSH 3
.Os BSD 4
.Sh NAME
.Nm ccosh
.Nd complex hyperbolic cosine function
.Sh SYNOPSIS
.Ft double complex
.Fn ccosh "double complex z"
.Ft long double complex
.Fn ccoshl "long double complex z"
.Ft float complex
.Fn ccoshf "float complex z"
.Sh DESCRIPTION
.Fn ccos "z"
computes the hyperbolic cosine of the complex floating-point number
.Fa z .
.Pp
For all complex floating point numbers z,
.Bd -literal -offset indent
ccosh(conj(z)) = conj(ccosh(z)),
.br
ccosh(-z) = ccosh(z).
.Ed
.Sh SPECIAL VALUES
The symmetries of ccosh() are used to abbreviate the specification of special values.
.Pp
.Fn ccosh "0 + 0i"
returns 1 + 0i.
.Pp
.Fn ccosh "0 + inf i"
returns NaN + 0i, and raises the invalid flag.
.Pp
.Fn ccosh "0 + NaN i"
returns NaN + 0i.
.Pp
.Fn ccosh "x + inf i"
returns NaN + NaN i, and raises the invalid flag, for finite nonzero x.
.Pp
.Fn ccosh "x + NaN i"
returns NaN + NaN i, for finite nonzero x.
.Pp
.Fn ccosh "inf + 0i"
returns inf + 0i.
.Pp
.Fn ccosh "inf + yi"
returns inf * cis(y), for finite positive y, where cis(y) = cos(y) + i*sin(y).
.Pp
.Fn ccosh "inf + inf i"
returns inf + NaN i, and raises the invalid flag.
.Pp
.Fn ccosh "inf + NaN i"
returns inf + NaN i.
.Pp
.Fn ccosh "NaN + 0i"
returns NaN + 0i.
.Pp
.Fn ccosh "NaN + yi"
returns NaN + NaN i, for nonzero numbers y.
.Pp
.Fn ccosh "NaN + NaN i"
returns NaN + NaN i.
.Sh NOTES
.Sh SEE ALSO
.Xr ccos 3
.Xr complex 3
.Sh STANDARDS
The
.Fn ccosh
function conforms to ISO/IEC 9899:2011.     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ccoshf.3                                     0100644 0001750 0001750 00000000020 12566165764 022213  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/ccosh.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ccoshl.3                                     0100644 0001750 0001750 00000000020 12566165764 022221  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/ccosh.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ccosl.3                                      0100644 0001750 0001750 00000000017 12566165764 022057  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/csin.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ceil.3                                       0100644 0001750 0001750 00000005634 12566165764 021702  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 1985, 1991 The Regents of the University of California.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     from: @(#)floor.3	6.5 (Berkeley) 4/19/91
.\"	$Id: ceil.3,v 1.4 2004/12/20 21:35:44 scp Exp $
.\"
.Dd December 11, 2006
.Dt CEIL 3
.Os
.Sh NAME
.Nm ceil
.Nd round to smallest integral value not less than x
.Sh SYNOPSIS
.Fd #include <math.h>
.Ft double
.Fn ceil "double x"
.br
.Ft long double
.Fn ceill "long double x"
.br
.Ft float
.Fn ceilf "float x"
.Sh DESCRIPTION
The
.Fn ceil
functions return the smallest integral value 
greater than or equal to
.Fa x .
.Sh SPECIAL VALUES
.Fn ceil "0"
returns 0.
.Pp
.Fn ceil "infinity"
returns infinity.
.Sh VECTOR OPERATIONS
If you need to apply the 
.Fn ceil
function to SIMD vectors or arrays, using the following functions provided
by the Accelerate.framework may give significantly better performance:
.Pp
.Fd #include <Accelerate/Accelerate.h>
.Pp
.Ft vFloat
.Fn vceilf "vFloat x" ;
.br
.Ft void
.Fn vvceilf "float *y" "const float *x" "const int *n" ;
.br
.Ft void
.Fn vvceil "double *y" "const double *x" "const int *n" ;
.Sh SEE ALSO
.Xr floor 3 ,
.Xr round 3 ,
.Xr trunc 3 ,
.Xr math 3
.Sh STANDARDS
The
.Fn ceil
functions conform to ISO/IEC 9899:2011.
                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ceilf.3                                      0100644 0001750 0001750 00000000017 12566165764 022036  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/ceil.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ceill.3                                      0100644 0001750 0001750 00000000017 12566165764 022044  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/ceil.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cexp.3                                       0100644 0001750 0001750 00000002761 12566165764 021723  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Copyright (c) 2006 Apple Computer
.\"
.Dd December 11, 2006
.Dt CEXP 3
.Os BSD 4
.Sh NAME
.Nm cexp
.Nd complex exponential function
.Sh SYNOPSIS
.Fd #include <complex.h>
.Ft double complex
.Fn cexp "double complex z"
.Ft long double complex
.Fn cexpl "long double complex z"
.Ft float complex
.Fn cexpf "float complex z"
.Sh DESCRIPTION
.Fn cexp "z"
returns the complex exponential of
.Fa z .
.Pp
cexp(conj(z)) = conj(cexp(z)), for all complex floating-point numbers z.
.Sh SPECIAL VALUES
The conjugate symmetry of cexp() is used to abbreviate the specification of special values.
.Pp
.Fn cexp "0 + 0i"
returns 1 + 0i.
.Pp
.Fn cexp "x + inf i"
returns NaN + NaN i, and raises the invalid flag, for finite
.Fa x .
.Pp
.Fn cexp "x + NaN i"
returns NaN + NaN i, for finite
.Fa x .
.Pp
.Fn cexp "inf + 0i"
returns inf + 0i.
.Pp
For the following two cases, cis(y) denotes cos(y) + I*sin(y).
.Pp
.Fn cexp "-inf + yi"
returns 0*cis(y), for finite
.Fa y .
.Pp
.Fn cexp "inf + yi"
returns inf*cis(y), for finite nonzero
.Fa y .
.Pp
.Fn cexp "-inf + inf i"
returns -0 + 0i.
.Pp
.Fn cexp "inf + inf i"
returns -inf + NaN i, and raises the invalid flag.
.Pp
.Fn cexp "-inf + NaN i"
returns -0 + 0i.
.Pp
.Fn cexp "inf + NaN i"
returns -inf + NaN i.
.Pp
.Fn cexp "NaN + 0i"
returns NaN + 0i.
.Pp
.Fn cexp "NaN + yi"
returns NaN + NaN i for all nonzero numbers y.
.Pp
.Fn cexp "NaN + NaN i"
returns NaN + NaN i.
.Pp
.Sh SEE ALSO
.Xr exp 3
.Xr clog 3
.Xr complex 3
.Sh STANDARDS
The
.Fn cexp
function conforms to ISO/IEC 9899:2011.               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cexpf.3                                      0100644 0001750 0001750 00000000017 12566165764 022061  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/cexp.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cexpl.3                                      0100644 0001750 0001750 00000000017 12566165764 022067  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/cexp.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cfgetispeed.3                                0120777 0001750 0001750 00000000000 12620245063 025316  2tcsetattr.3                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cfgetospeed.3                                0120777 0001750 0001750 00000000000 12620245063 025324  2tcsetattr.3                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cfmakeraw.3                                  0120777 0001750 0001750 00000000000 12620245063 024774  2tcsetattr.3                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cfsetispeed.3                                0120777 0001750 0001750 00000000000 12620245063 025332  2tcsetattr.3                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cfsetospeed.3                                0120777 0001750 0001750 00000000000 12620245063 025340  2tcsetattr.3                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cfsetspeed.3                                 0120777 0001750 0001750 00000000000 12620245063 025161  2tcsetattr.3                                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cgetcap.3                                    0120777 0001750 0001750 00000000000 12620245063 023670  2getcap.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cgetclose.3                                  0120777 0001750 0001750 00000000000 12620245063 024232  2getcap.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cgetent.3                                    0120777 0001750 0001750 00000000000 12620245063 023713  2getcap.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cgetfirst.3                                  0120777 0001750 0001750 00000000000 12620245063 024254  2getcap.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cgetmatch.3                                  0120777 0001750 0001750 00000000000 12620245063 024221  2getcap.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cgetnext.3                                   0120777 0001750 0001750 00000000000 12620245063 024103  2getcap.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cgetnum.3                                    0120777 0001750 0001750 00000000000 12620245063 023724  2getcap.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cgetset.3                                    0120777 0001750 0001750 00000000000 12620245063 023720  2getcap.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cgetstr.3                                    0120777 0001750 0001750 00000000000 12620245063 023735  2getcap.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cgetustr.3                                   0120777 0001750 0001750 00000000000 12620245063 024122  2getcap.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/charnames.3pm                                0100644 0001750 0001750 00000057353 12566207465 023264  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "charnames 3pm"
.TH charnames 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
charnames \- access to Unicode character names and named character sequences; also define character names
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use charnames \*(Aq:full\*(Aq;
\& print "\eN{GREEK SMALL LETTER SIGMA} is called sigma.\en";
\& print "\eN{LATIN CAPITAL LETTER E WITH VERTICAL LINE BELOW}",
\&       " is an officially named sequence of two Unicode characters\en";
\&
\& use charnames \*(Aq:loose\*(Aq;
\& print "\eN{Greek small\-letter  sigma}",
\&        "can be used to ignore case, underscores, most blanks,"
\&        "and when you aren\*(Aqt sure if the official name has hyphens\en";
\&
\& use charnames \*(Aq:short\*(Aq;
\& print "\eN{greek:Sigma} is an upper\-case sigma.\en";
\&
\& use charnames qw(cyrillic greek);
\& print "\eN{sigma} is Greek sigma, and \eN{be} is Cyrillic b.\en";
\&
\& use utf8;
\& use charnames ":full", ":alias" => {
\&   e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE",
\&   mychar => 0xE8000,  # Private use area
\&   "XXXXXXX" => "BICYCLIST"
\& };
\& print "\eN{e_ACUTE} is a small letter e with an acute.\en";
\& print "\eN{mychar} allows me to name private use characters.\en";
\& print "And I can create synonyms in other languages,",
\&       " such as \eN{XXXXXXX} for "BICYCLIST (U+1F6B4)\en";
\&
\& use charnames ();
\& print charnames::viacode(0x1234); # prints "ETHIOPIC SYLLABLE SEE"
\& printf "%04X", charnames::vianame("GOTHIC LETTER AHSA"); # prints
\&                                                          # "10330"
\& print charnames::vianame("LATIN CAPITAL LETTER A"); # prints 65 on
\&                                                     # ASCII platforms;
\&                                                     # 193 on EBCDIC
\& print charnames::string_vianame("LATIN CAPITAL LETTER A"); # prints "A"
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pragma \f(CW\*(C`use charnames\*(C'\fR is used to gain access to the names of the
Unicode characters and named character sequences, and to allow you to define
your own character and character sequence names.
.PP
All forms of the pragma enable use of the following 3 functions:
.IP "\(bu" 4
"charnames::string_vianame(\fIname\fR)" for run-time lookup of a
either a character name or a named character sequence, returning its string
representation
.IP "\(bu" 4
"charnames::vianame(\fIname\fR)" for run-time lookup of a
character name (but not a named character sequence) to get its ordinal value
(code point)
.IP "\(bu" 4
"charnames::viacode(\fIcode\fR)" for run-time lookup of a code point to get its
Unicode name.
.PP
Starting in Perl v5.16, any occurrence of \f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR sequences
in a double-quotish string automatically loads this module with arguments
\&\f(CW\*(C`:full\*(C'\fR and \f(CW\*(C`:short\*(C'\fR (described below) if it hasn't already been loaded with
different arguments, in order to compile the named Unicode character into
position in the string.  Prior to v5.16, an explicit \f(CW\*(C`use\ charnames\*(C'\fR was
required to enable this usage.  (However, prior to v5.16, the form \f(CW"use\ charnames\ ();"\fR did not enable \f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR.)
.PP
Note that \f(CW\*(C`\eN{U+\f(CI...\f(CW}\*(C'\fR, where the \fI...\fR is a hexadecimal number,
also inserts a character into a string.
The character it inserts is the one whose code point
(ordinal value) is equal to the number.  For example, \f(CW"\eN{U+263a}"\fR is
the Unicode (white background, black foreground) smiley face
equivalent to \f(CW"\eN{WHITE SMILING FACE}"\fR.
Also note, \f(CW\*(C`\eN{\f(CI...\f(CW}\*(C'\fR can mean a regex quantifier instead of a character
name, when the \fI...\fR is a number (or comma separated pair of numbers
(see \*(L"\s-1QUANTIFIERS\*(R"\s0 in perlreref), and is not related to this pragma.
.PP
The \f(CW\*(C`charnames\*(C'\fR pragma supports arguments \f(CW\*(C`:full\*(C'\fR, \f(CW\*(C`:loose\*(C'\fR, \f(CW\*(C`:short\*(C'\fR,
script names and customized aliases.
.PP
If \f(CW\*(C`:full\*(C'\fR is present, for expansion of
\&\f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR, the string \fI\s-1CHARNAME\s0\fR is first looked up in the list of
standard Unicode character names.
.PP
\&\f(CW\*(C`:loose\*(C'\fR is a variant of \f(CW\*(C`:full\*(C'\fR which allows \fI\s-1CHARNAME\s0\fR to be less
precisely specified.  Details are in \*(L"\s-1LOOSE MATCHES\*(R"\s0.
.PP
If \f(CW\*(C`:short\*(C'\fR is present, and
\&\fI\s-1CHARNAME\s0\fR has the form \f(CW\*(C`\f(CISCRIPT\f(CW:\f(CICNAME\f(CW\*(C'\fR, then \fI\s-1CNAME\s0\fR is looked up
as a letter in script \fI\s-1SCRIPT\s0\fR, as described in the next paragraph.
Or, if \f(CW\*(C`use charnames\*(C'\fR is used
with script name arguments, then for \f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR the name
\&\fI\s-1CHARNAME\s0\fR is looked up as a letter in the given scripts (in the
specified order). Customized aliases can override these, and are explained in
\&\*(L"\s-1CUSTOM ALIASES\*(R"\s0.
.PP
For lookup of \fI\s-1CHARNAME\s0\fR inside a given script \fI\s-1SCRIPTNAME\s0\fR,
this pragma looks in the table of standard Unicode names for the names
.PP
.Vb 3
\&  SCRIPTNAME CAPITAL LETTER CHARNAME
\&  SCRIPTNAME SMALL LETTER CHARNAME
\&  SCRIPTNAME LETTER CHARNAME
.Ve
.PP
If \fI\s-1CHARNAME\s0\fR is all lowercase,
then the \f(CW\*(C`CAPITAL\*(C'\fR variant is ignored, otherwise the \f(CW\*(C`SMALL\*(C'\fR variant
is ignored, and both \fI\s-1CHARNAME\s0\fR and \fI\s-1SCRIPTNAME\s0\fR are converted to all
uppercase for look-up.  Other than that, both of them follow loose rules if \f(CW\*(C`:loose\*(C'\fR is also specified; strict otherwise.
.PP
Note that \f(CW\*(C`\eN{...}\*(C'\fR is compile-time; it's a special form of string
constant used inside double-quotish strings; this means that you cannot
use variables inside the \f(CW\*(C`\eN{...}\*(C'\fR.  If you want similar run-time
functionality, use
\&\fIcharnames::string_vianame()\fR.
.PP
Note, starting in Perl 5.18, the name \f(CW\*(C`BELL\*(C'\fR refers to the Unicode character
U+1F514, instead of the traditional U+0007.  For the latter, use \f(CW\*(C`ALERT\*(C'\fR
or \f(CW\*(C`BEL\*(C'\fR.
.PP
It is a syntax error to use \f(CW\*(C`\eN{NAME}\*(C'\fR where \f(CW\*(C`NAME\*(C'\fR is unknown.
.PP
For \f(CW\*(C`\eN{NAME}\*(C'\fR, it is a fatal error if \f(CW\*(C`use bytes\*(C'\fR is in effect and the
input name is that of a character that won't fit into a byte (i.e., whose
ordinal is above 255).
.PP
Otherwise, any string that includes a \f(CW\*(C`\eN{\f(CIcharname\f(CW}\*(C'\fR or
\&\f(CW\*(C`\eN{U+\f(CIcode\ point\f(CW}\*(C'\fR will automatically have Unicode semantics (see
\&\*(L"Byte and Character Semantics\*(R" in perlunicode).
.SH "LOOSE MATCHES"
.IX Header "LOOSE MATCHES"
By specifying \f(CW\*(C`:loose\*(C'\fR, Unicode's loose character name
matching <http://www.unicode.org/reports/tr44#Matching_Rules> rules are
selected instead of the strict exact match used otherwise.
That means that \fI\s-1CHARNAME\s0\fR doesn't have to be so precisely specified.
Upper/lower case doesn't matter (except with scripts as mentioned above), nor
do any underscores, and the only hyphens that matter are those at the
beginning or end of a word in the name (with one exception:  the hyphen in
U+1180 \f(CW\*(C`HANGUL JUNGSEONG O\-E\*(C'\fR does matter).
Also, blanks not adjacent to hyphens don't matter.
The official Unicode names are quite variable as to where they use hyphens
versus spaces to separate word-like units, and this option allows you to not
have to care as much.
The reason non-medial hyphens matter is because of cases like
U+0F60 \f(CW\*(C`TIBETAN LETTER \-A\*(C'\fR versus U+0F68 \f(CW\*(C`TIBETAN LETTER A\*(C'\fR.
The hyphen here is significant, as is the space before it, and so both must be
included.
.PP
\&\f(CW\*(C`:loose\*(C'\fR slows down look-ups by a factor of 2 to 3 versus
\&\f(CW\*(C`:full\*(C'\fR, but the trade-off may be worth it to you.  Each individual look-up
takes very little time, and the results are cached, so the speed difference
would become a factor only in programs that do look-ups of many different
spellings, and probably only when those look-ups are through \f(CW\*(C`vianame()\*(C'\fR and
\&\f(CW\*(C`string_vianame()\*(C'\fR, since \f(CW\*(C`\eN{...}\*(C'\fR look-ups are done at compile time.
.SH "ALIASES"
.IX Header "ALIASES"
Starting in Unicode 6.1 and Perl v5.16, Unicode defines many abbreviations and
names that were formerly Perl extensions, and some additional ones that Perl
did not previously accept.  The list is getting too long to reproduce here,
but you can get the complete list from the Unicode web site:
<http://www.unicode.org/Public/UNIDATA/NameAliases.txt>.
.PP
Earlier versions of Perl accepted almost all the 6.1 names.  These were most
extensively documented in the v5.14 version of this pod:
<http://perldoc.perl.org/5.14.0/charnames.html#ALIASES>.
.SH "CUSTOM ALIASES"
.IX Header "CUSTOM ALIASES"
You can add customized aliases to standard (\f(CW\*(C`:full\*(C'\fR) Unicode naming
conventions.  The aliases override any standard definitions, so, if
you're twisted enough, you can change \f(CW"\eN{LATIN CAPITAL LETTER A}"\fR to
mean \f(CW"B"\fR, etc.
.PP
Aliases must begin with a character that is alphabetic.  After that, each may
contain any combination of word (\f(CW\*(C`\ew\*(C'\fR) characters, \s-1SPACE \s0(U+0020),
HYPHEN-MINUS (U+002D), \s-1LEFT PARENTHESIS \s0(U+0028), \s-1RIGHT PARENTHESIS \s0(U+0029),
and NO-BREAK \s-1SPACE \s0(U+00A0).  These last three should never have been allowed
in names, and are retained for backwards compatibility only; they may be
deprecated and removed in future releases of Perl, so don't use them for new
names.  (More precisely, the first character of a name you specify must be
something that matches all of \f(CW\*(C`\ep{ID_Start}\*(C'\fR, \f(CW\*(C`\ep{Alphabetic}\*(C'\fR, and
\&\f(CW\*(C`\ep{Gc=Letter}\*(C'\fR.  This makes sure it is what any reasonable person would view
as an alphabetic character.  And, the continuation characters that match \f(CW\*(C`\ew\*(C'\fR
must also match \f(CW\*(C`\ep{ID_Continue}\*(C'\fR.)  Starting with Perl v5.18, any Unicode
characters meeting the above criteria may be used; prior to that only
Latin1\-range characters were acceptable.
.PP
An alias can map to either an official Unicode character name (not a loose
matched name) or to a
numeric code point (ordinal).  The latter is useful for assigning names
to code points in Unicode private use areas such as U+E800 through
U+F8FF.
A numeric code point must be a non-negative integer or a string beginning
with \f(CW"U+"\fR or \f(CW"0x"\fR with the remainder considered to be a
hexadecimal integer.  A literal numeric constant must be unsigned; it
will be interpreted as hex if it has a leading zero or contains
non-decimal hex digits; otherwise it will be interpreted as decimal.
.PP
Aliases are added either by the use of anonymous hashes:
.PP
.Vb 5
\&    use charnames ":alias" => {
\&        e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE",
\&        mychar1 => 0xE8000,
\&        };
\&    my $str = "\eN{e_ACUTE}";
.Ve
.PP
or by using a file containing aliases:
.PP
.Vb 1
\&    use charnames ":alias" => "pro";
.Ve
.PP
This will try to read \f(CW"unicore/pro_alias.pl"\fR from the \f(CW@INC\fR path. This
file should return a list in plain perl:
.PP
.Vb 10
\&    (
\&    A_GRAVE         => "LATIN CAPITAL LETTER A WITH GRAVE",
\&    A_CIRCUM        => "LATIN CAPITAL LETTER A WITH CIRCUMFLEX",
\&    A_DIAERES       => "LATIN CAPITAL LETTER A WITH DIAERESIS",
\&    A_TILDE         => "LATIN CAPITAL LETTER A WITH TILDE",
\&    A_BREVE         => "LATIN CAPITAL LETTER A WITH BREVE",
\&    A_RING          => "LATIN CAPITAL LETTER A WITH RING ABOVE",
\&    A_MACRON        => "LATIN CAPITAL LETTER A WITH MACRON",
\&    mychar2         => "U+E8001",
\&    );
.Ve
.PP
Both these methods insert \f(CW":full"\fR automatically as the first argument (if no
other argument is given), and you can give the \f(CW":full"\fR explicitly as
well, like
.PP
.Vb 1
\&    use charnames ":full", ":alias" => "pro";
.Ve
.PP
\&\f(CW":loose"\fR has no effect with these.  Input names must match exactly, using
\&\f(CW":full"\fR rules.
.PP
Also, both these methods currently allow only single characters to be named.
To name a sequence of characters, use a
custom translator (described below).
.SH "charnames::string_vianame(\fIname\fP)"
.IX Header "charnames::string_vianame(name)"
This is a runtime equivalent to \f(CW\*(C`\eN{...}\*(C'\fR.  \fIname\fR can be any expression
that evaluates to a name accepted by \f(CW\*(C`\eN{...}\*(C'\fR under the \f(CW\*(C`:full\*(C'\fR
option to \f(CW\*(C`charnames\*(C'\fR.  In addition, any other options for the
controlling \f(CW"use charnames"\fR in the same scope apply, like \f(CW\*(C`:loose\*(C'\fR or any
script list, \f(CW\*(C`:short\*(C'\fR option, or custom aliases you may have defined.
.PP
The only differences are due to the fact that \f(CW\*(C`string_vianame\*(C'\fR is run-time
and \f(CW\*(C`\eN{}\*(C'\fR is compile time.  You can't interpolate inside a \f(CW\*(C`\eN{}\*(C'\fR, (so
\&\f(CW\*(C`\eN{$variable}\*(C'\fR doesn't work); and if the input name is unknown,
\&\f(CW\*(C`string_vianame\*(C'\fR returns \f(CW\*(C`undef\*(C'\fR instead of it being a syntax error.
.SH "charnames::vianame(\fIname\fP)"
.IX Header "charnames::vianame(name)"
This is similar to \f(CW\*(C`string_vianame\*(C'\fR.  The main difference is that under most
circumstances, \f(CW\*(C`vianame\*(C'\fR returns an ordinal code
point, whereas \f(CW\*(C`string_vianame\*(C'\fR returns a string.  For example,
.PP
.Vb 1
\&   printf "U+%04X", charnames::vianame("FOUR TEARDROP\-SPOKED ASTERISK");
.Ve
.PP
prints \*(L"U+2722\*(R".
.PP
This leads to the other two differences.  Since a single code point is
returned, the function can't handle named character sequences, as these are
composed of multiple characters (it returns \f(CW\*(C`undef\*(C'\fR for these.  And, the code
point can be that of any
character, even ones that aren't legal under the \f(CW\*(C`use\ bytes\*(C'\fR pragma,
.PP
See \*(L"\s-1BUGS\*(R"\s0 for the circumstances in which the behavior differs
from  that described above.
.SH "charnames::viacode(\fIcode\fP)"
.IX Header "charnames::viacode(code)"
Returns the full name of the character indicated by the numeric code.
For example,
.PP
.Vb 1
\&    print charnames::viacode(0x2722);
.Ve
.PP
prints \*(L"\s-1FOUR\s0 TEARDROP-SPOKED \s-1ASTERISK\*(R".\s0
.PP
The name returned is the \*(L"best\*(R" (defined below) official name or alias
for the code point, if
available; otherwise your custom alias for it, if defined; otherwise \f(CW\*(C`undef\*(C'\fR.
This means that your alias will only be returned for code points that don't
have an official Unicode name (nor alias) such as private use code points.
.PP
If you define more than one name for the code point, it is indeterminate
which one will be returned.
.PP
As mentioned, the function returns \f(CW\*(C`undef\*(C'\fR if no name is known for the code
point.  In Unicode the proper name for these is the empty string, which
\&\f(CW\*(C`undef\*(C'\fR stringifies to.  (If you ask for a code point past the legal
Unicode maximum of U+10FFFF that you haven't assigned an alias to, you
get \f(CW\*(C`undef\*(C'\fR plus a warning.)
.PP
The input number must be a non-negative integer, or a string beginning
with \f(CW"U+"\fR or \f(CW"0x"\fR with the remainder considered to be a
hexadecimal integer.  A literal numeric constant must be unsigned; it
will be interpreted as hex if it has a leading zero or contains
non-decimal hex digits; otherwise it will be interpreted as decimal.
.PP
As mentioned above under \*(L"\s-1ALIASES\*(R"\s0, Unicode 6.1 defines extra names
(synonyms or aliases) for some code points, most of which were already
available as Perl extensions.  All these are accepted by \f(CW\*(C`\eN{...}\*(C'\fR and the
other functions in this module, but \f(CW\*(C`viacode\*(C'\fR has to choose which one
name to return for a given input code point, so it returns the \*(L"best\*(R" name.
To understand how this works, it is helpful to know more about the Unicode
name properties.  All code points actually have only a single name, which
(starting in Unicode 2.0) can never change once a character has been assigned
to the code point.  But mistakes have been made in assigning names, for
example sometimes a clerical error was made during the publishing of the
Standard which caused words to be misspelled, and there was no way to correct
those.  The Name_Alias property was eventually created to handle these
situations.  If a name was wrong, a corrected synonym would be published for
it, using Name_Alias.  \f(CW\*(C`viacode\*(C'\fR will return that corrected synonym as the
\&\*(L"best\*(R" name for a code point.  (It is even possible, though it hasn't happened
yet, that the correction itself will need to be corrected, and so another
Name_Alias can be created for that code point; \f(CW\*(C`viacode\*(C'\fR will return the
most recent correction.)
.PP
The Unicode name for each of the control characters (such as \s-1LINE FEED\s0) is the
empty string.  However almost all had names assigned by other standards, such
as the \s-1ASCII\s0 Standard, or were in common use.  \f(CW\*(C`viacode\*(C'\fR returns these names
as the \*(L"best\*(R" ones available.  Unicode 6.1 has created Name_Aliases for each
of them, including alternate names, like \s-1NEW LINE.  \s0\f(CW\*(C`viacode\*(C'\fR uses the
original name, \*(L"\s-1LINE FEED\*(R"\s0 in preference to the alternate.  Similarly the
name returned for U+FEFF is \*(L"\s-1ZERO WIDTH\s0 NO-BREAK \s-1SPACE\*(R",\s0 not \*(L"\s-1BYTE ORDER
MARK\*(R".\s0
.PP
Until Unicode 6.1, the 4 control characters U+0080, U+0081, U+0084, and U+0099
did not have names nor aliases.
To preserve backwards compatibility, any alias you define for these code
points will be returned by this function, in preference to the official name.
.PP
Some code points also have abbreviated names, such as \*(L"\s-1LF\*(R"\s0 or \*(L"\s-1NL\*(R".
\&\s0\f(CW\*(C`viacode\*(C'\fR never returns these.
.PP
Because a name correction may be added in future Unicode releases, the name
that \f(CW\*(C`viacode\*(C'\fR returns may change as a result.  This is a rare event, but it
does happen.
.SH "CUSTOM TRANSLATORS"
.IX Header "CUSTOM TRANSLATORS"
The mechanism of translation of \f(CW\*(C`\eN{...}\*(C'\fR escapes is general and not
hardwired into \fIcharnames.pm\fR.  A module can install custom
translations (inside the scope which \f(CW\*(C`use\*(C'\fRs the module) with the
following magic incantation:
.PP
.Vb 4
\&    sub import {
\&        shift;
\&        $^H{charnames} = \e&translator;
\&    }
.Ve
.PP
Here \fItranslator()\fR is a subroutine which takes \fI\s-1CHARNAME\s0\fR as an
argument, and returns text to insert into the string instead of the
\&\f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR escape.
.PP
This is the only way you can create a custom named sequence of code points.
.PP
Since the text to insert should be different
in \f(CW\*(C`bytes\*(C'\fR mode and out of it, the function should check the current
state of \f(CW\*(C`bytes\*(C'\fR\-flag as in:
.PP
.Vb 9
\&    use bytes ();                      # for $bytes::hint_bits
\&    sub translator {
\&        if ($^H & $bytes::hint_bits) {
\&            return bytes_translator(@_);
\&        }
\&        else {
\&            return utf8_translator(@_);
\&        }
\&    }
.Ve
.PP
See \*(L"\s-1CUSTOM ALIASES\*(R"\s0 above for restrictions on \fI\s-1CHARNAME\s0\fR.
.PP
Of course, \f(CW\*(C`vianame\*(C'\fR, \f(CW\*(C`viacode\*(C'\fR, and \f(CW\*(C`string_vianame\*(C'\fR would need to be
overridden as well.
.SH "BUGS"
.IX Header "BUGS"
\&\fIvianame()\fR normally returns an ordinal code point, but when the input name is of
the form \f(CW\*(C`U+...\*(C'\fR, it returns a chr instead.  In this case, if \f(CW\*(C`use bytes\*(C'\fR is
in effect and the character won't fit into a byte, it returns \f(CW\*(C`undef\*(C'\fR and
raises a warning.
.PP
Since evaluation of the translation function (see \*(L"\s-1CUSTOM
TRANSLATORS\*(R"\s0) happens in the middle of compilation (of a string
literal), the translation function should not do any \f(CW\*(C`eval\*(C'\fRs or
\&\f(CW\*(C`require\*(C'\fRs.  This restriction should be lifted (but is low priority) in
a future version of Perl.
                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/charnames5.16.3pm                            0100644 0001750 0001750 00000055563 12566207443 023573  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "charnames 3pm"
.TH charnames 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
charnames \- access to Unicode character names and named character sequences; also define character names
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use charnames \*(Aq:full\*(Aq;
\& print "\eN{GREEK SMALL LETTER SIGMA} is called sigma.\en";
\& print "\eN{LATIN CAPITAL LETTER E WITH VERTICAL LINE BELOW}",
\&       " is an officially named sequence of two Unicode characters\en";
\&
\& use charnames \*(Aq:loose\*(Aq;
\& print "\eN{Greek small\-letter  sigma}",
\&        "can be used to ignore case, underscores, most blanks,"
\&        "and when you aren\*(Aqt sure if the official name has hyphens\en";
\&
\& use charnames \*(Aq:short\*(Aq;
\& print "\eN{greek:Sigma} is an upper\-case sigma.\en";
\&
\& use charnames qw(cyrillic greek);
\& print "\eN{sigma} is Greek sigma, and \eN{be} is Cyrillic b.\en";
\&
\& use charnames ":full", ":alias" => {
\&   e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE",
\&   mychar => 0xE8000,  # Private use area
\& };
\& print "\eN{e_ACUTE} is a small letter e with an acute.\en";
\& print "\eN{mychar} allows me to name private use characters.\en";
\&
\& use charnames ();
\& print charnames::viacode(0x1234); # prints "ETHIOPIC SYLLABLE SEE"
\& printf "%04X", charnames::vianame("GOTHIC LETTER AHSA"); # prints
\&                                                          # "10330"
\& print charnames::vianame("LATIN CAPITAL LETTER A"); # prints 65 on
\&                                                     # ASCII platforms;
\&                                                     # 193 on EBCDIC
\& print charnames::string_vianame("LATIN CAPITAL LETTER A"); # prints "A"
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pragma \f(CW\*(C`use charnames\*(C'\fR is used to gain access to the names of the
Unicode characters and named character sequences, and to allow you to define
your own character and character sequence names.
.PP
All forms of the pragma enable use of the following 3 functions:
.IP "\(bu" 4
"charnames::string_vianame(\fIname\fR)" for run-time lookup of a
either a character name or a named character sequence, returning its string
representation
.IP "\(bu" 4
"charnames::vianame(\fIname\fR)" for run-time lookup of a
character name (but not a named character sequence) to get its ordinal value
(code point)
.IP "\(bu" 4
"charnames::viacode(\fIcode\fR)" for run-time lookup of a code point to get its
Unicode name.
.PP
Starting in Perl v5.16, any occurrence of \f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR sequences
in a double-quotish string automatically loads this module with arguments
\&\f(CW\*(C`:full\*(C'\fR and \f(CW\*(C`:short\*(C'\fR (described below) if it hasn't already been loaded with
different arguments, in order to compile the named Unicode character into
position in the string.  Prior to v5.16, an explicit \f(CW\*(C`use\ charnames\*(C'\fR was
required to enable this usage.  (However, prior to v5.16, the form \f(CW"use\ charnames\ ();"\fR did not enable \f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR.)
.PP
Note that \f(CW\*(C`\eN{U+\f(CI...\f(CW}\*(C'\fR, where the \fI...\fR is a hexadecimal number,
also inserts a character into a string.
The character it inserts is the one whose code point
(ordinal value) is equal to the number.  For example, \f(CW"\eN{U+263a}"\fR is
the Unicode (white background, black foreground) smiley face
equivalent to \f(CW"\eN{WHITE SMILING FACE}"\fR.
Also note, \f(CW\*(C`\eN{\f(CI...\f(CW}\*(C'\fR can mean a regex quantifier instead of a character
name, when the \fI...\fR is a number (or comma separated pair of numbers
(see \*(L"\s-1QUANTIFIERS\s0\*(R" in perlreref), and is not related to this pragma.
.PP
The \f(CW\*(C`charnames\*(C'\fR pragma supports arguments \f(CW\*(C`:full\*(C'\fR, \f(CW\*(C`:loose\*(C'\fR, \f(CW\*(C`:short\*(C'\fR,
script names and customized aliases.
.PP
If \f(CW\*(C`:full\*(C'\fR is present, for expansion of
\&\f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR, the string \fI\s-1CHARNAME\s0\fR is first looked up in the list of
standard Unicode character names.
.PP
\&\f(CW\*(C`:loose\*(C'\fR is a variant of \f(CW\*(C`:full\*(C'\fR which allows \fI\s-1CHARNAME\s0\fR to be less
precisely specified.  Details are in \*(L"\s-1LOOSE\s0 \s-1MATCHES\s0\*(R".
.PP
If \f(CW\*(C`:short\*(C'\fR is present, and
\&\fI\s-1CHARNAME\s0\fR has the form \f(CW\*(C`\f(CISCRIPT\f(CW:\f(CICNAME\f(CW\*(C'\fR, then \fI\s-1CNAME\s0\fR is looked up
as a letter in script \fI\s-1SCRIPT\s0\fR, as described in the next paragraph.
Or, if \f(CW\*(C`use charnames\*(C'\fR is used
with script name arguments, then for \f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR the name
\&\fI\s-1CHARNAME\s0\fR is looked up as a letter in the given scripts (in the
specified order). Customized aliases can override these, and are explained in
\&\*(L"\s-1CUSTOM\s0 \s-1ALIASES\s0\*(R".
.PP
For lookup of \fI\s-1CHARNAME\s0\fR inside a given script \fI\s-1SCRIPTNAME\s0\fR,
this pragma looks in the table of standard Unicode names for the names
.PP
.Vb 3
\&  SCRIPTNAME CAPITAL LETTER CHARNAME
\&  SCRIPTNAME SMALL LETTER CHARNAME
\&  SCRIPTNAME LETTER CHARNAME
.Ve
.PP
If \fI\s-1CHARNAME\s0\fR is all lowercase,
then the \f(CW\*(C`CAPITAL\*(C'\fR variant is ignored, otherwise the \f(CW\*(C`SMALL\*(C'\fR variant
is ignored, and both \fI\s-1CHARNAME\s0\fR and \fI\s-1SCRIPTNAME\s0\fR are converted to all
uppercase for look-up.  Other than that, both of them follow loose rules if \f(CW\*(C`:loose\*(C'\fR is also specified; strict otherwise.
.PP
Note that \f(CW\*(C`\eN{...}\*(C'\fR is compile-time; it's a special form of string
constant used inside double-quotish strings; this means that you cannot
use variables inside the \f(CW\*(C`\eN{...}\*(C'\fR.  If you want similar run-time
functionality, use
\&\fIcharnames::string_vianame()\fR.
.PP
Since Unicode 6.0, it is deprecated to use \f(CW\*(C`BELL\*(C'\fR.  Instead use \f(CW\*(C`ALERT\*(C'\fR (but
\&\f(CW\*(C`BEL\*(C'\fR will continue to work).
.PP
If the input name is unknown, \f(CW\*(C`\eN{NAME}\*(C'\fR raises a warning and
substitutes the Unicode \s-1REPLACEMENT\s0 \s-1CHARACTER\s0 (U+FFFD).
.PP
For \f(CW\*(C`\eN{NAME}\*(C'\fR, it is a fatal error if \f(CW\*(C`use bytes\*(C'\fR is in effect and the
input name is that of a character that won't fit into a byte (i.e., whose
ordinal is above 255).
.PP
Otherwise, any string that includes a \f(CW\*(C`\eN{\f(CIcharname\f(CW}\*(C'\fR or
\&\f(CW\*(C`\eN{U+\f(CIcode\ point\f(CW}\*(C'\fR will automatically have Unicode semantics (see
\&\*(L"Byte and Character Semantics\*(R" in perlunicode).
.SH "LOOSE MATCHES"
.IX Header "LOOSE MATCHES"
By specifying \f(CW\*(C`:loose\*(C'\fR, Unicode's loose character name
matching <http://www.unicode.org/reports/tr44#Matching_Rules> rules are
selected instead of the strict exact match used otherwise.
That means that \fI\s-1CHARNAME\s0\fR doesn't have to be so precisely specified.
Upper/lower case doesn't matter (except with scripts as mentioned above), nor
do any underscores, and the only hyphens that matter are those at the
beginning or end of a word in the name (with one exception:  the hyphen in
U+1180 \f(CW\*(C`HANGUL JUNGSEONG O\-E\*(C'\fR does matter).
Also, blanks not adjacent to hyphens don't matter.
The official Unicode names are quite variable as to where they use hyphens
versus spaces to separate word-like units, and this option allows you to not
have to care as much.
The reason non-medial hyphens matter is because of cases like
U+0F60 \f(CW\*(C`TIBETAN LETTER \-A\*(C'\fR versus U+0F68 \f(CW\*(C`TIBETAN LETTER A\*(C'\fR.
The hyphen here is significant, as is the space before it, and so both must be
included.
.PP
\&\f(CW\*(C`:loose\*(C'\fR slows down look-ups by a factor of 2 to 3 versus
\&\f(CW\*(C`:full\*(C'\fR, but the trade-off may be worth it to you.  Each individual look-up
takes very little time, and the results are cached, so the speed difference
would become a factor only in programs that do look-ups of many different
spellings, and probably only when those look-ups are through \fIvianame()\fR and
\&\fIstring_vianame()\fR, since \f(CW\*(C`\eN{...}\*(C'\fR look-ups are done at compile time.
.SH "ALIASES"
.IX Header "ALIASES"
Starting in Unicode 6.1 and Perl v5.16, Unicode defines many abbreviations and
names that were formerly Perl extensions, and some additional ones that Perl
did not previously accept.  The list is getting too long to reproduce here,
but you can get the complete list from the Unicode web site:
<http://www.unicode.org/Public/UNIDATA/NameAliases.txt>.
.PP
Earlier versions of Perl accepted almost all the 6.1 names.  These were most
extensively documented in the v5.14 version of this pod:
<http://perldoc.perl.org/5.14.0/charnames.html#ALIASES>.
.SH "CUSTOM ALIASES"
.IX Header "CUSTOM ALIASES"
You can add customized aliases to standard (\f(CW\*(C`:full\*(C'\fR) Unicode naming
conventions.  The aliases override any standard definitions, so, if
you're twisted enough, you can change \f(CW"\eN{LATIN CAPITAL LETTER A}"\fR to
mean \f(CW"B"\fR, etc.
.PP
Note that an alias should not be something that is a legal curly
brace-enclosed quantifier (see \*(L"\s-1QUANTIFIERS\s0\*(R" in perlreref).  For example
\&\f(CW\*(C`\eN{123}\*(C'\fR means to match 123 non-newline characters, and is not treated as a
charnames alias.  Aliases are discouraged from beginning with anything
other than an alphabetic character and from containing anything other
than alphanumerics, spaces, dashes, parentheses, and underscores.
Currently they must be \s-1ASCII\s0.
.PP
An alias can map to either an official Unicode character name (not a loose
matched name) or to a
numeric code point (ordinal).  The latter is useful for assigning names
to code points in Unicode private use areas such as U+E800 through
U+F8FF.
A numeric code point must be a non-negative integer or a string beginning
with \f(CW"U+"\fR or \f(CW"0x"\fR with the remainder considered to be a
hexadecimal integer.  A literal numeric constant must be unsigned; it
will be interpreted as hex if it has a leading zero or contains
non-decimal hex digits; otherwise it will be interpreted as decimal.
.PP
Aliases are added either by the use of anonymous hashes:
.PP
.Vb 5
\&    use charnames ":alias" => {
\&        e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE",
\&        mychar1 => 0xE8000,
\&        };
\&    my $str = "\eN{e_ACUTE}";
.Ve
.PP
or by using a file containing aliases:
.PP
.Vb 1
\&    use charnames ":alias" => "pro";
.Ve
.PP
This will try to read \f(CW"unicore/pro_alias.pl"\fR from the \f(CW@INC\fR path. This
file should return a list in plain perl:
.PP
.Vb 10
\&    (
\&    A_GRAVE         => "LATIN CAPITAL LETTER A WITH GRAVE",
\&    A_CIRCUM        => "LATIN CAPITAL LETTER A WITH CIRCUMFLEX",
\&    A_DIAERES       => "LATIN CAPITAL LETTER A WITH DIAERESIS",
\&    A_TILDE         => "LATIN CAPITAL LETTER A WITH TILDE",
\&    A_BREVE         => "LATIN CAPITAL LETTER A WITH BREVE",
\&    A_RING          => "LATIN CAPITAL LETTER A WITH RING ABOVE",
\&    A_MACRON        => "LATIN CAPITAL LETTER A WITH MACRON",
\&    mychar2         => "U+E8001",
\&    );
.Ve
.PP
Both these methods insert \f(CW":full"\fR automatically as the first argument (if no
other argument is given), and you can give the \f(CW":full"\fR explicitly as
well, like
.PP
.Vb 1
\&    use charnames ":full", ":alias" => "pro";
.Ve
.PP
\&\f(CW":loose"\fR has no effect with these.  Input names must match exactly, using
\&\f(CW":full"\fR rules.
.PP
Also, both these methods currently allow only single characters to be named.
To name a sequence of characters, use a
custom translator (described below).
.SH "charnames::string_vianame(\fIname\fP)"
.IX Header "charnames::string_vianame(name)"
This is a runtime equivalent to \f(CW\*(C`\eN{...}\*(C'\fR.  \fIname\fR can be any expression
that evaluates to a name accepted by \f(CW\*(C`\eN{...}\*(C'\fR under the \f(CW\*(C`:full\*(C'\fR
option to \f(CW\*(C`charnames\*(C'\fR.  In addition, any other options for the
controlling \f(CW"use charnames"\fR in the same scope apply, like \f(CW\*(C`:loose\*(C'\fR or any
script list, \f(CW\*(C`:short\*(C'\fR option, or custom aliases you may have defined.
.PP
The only difference is that if the input name is unknown, \f(CW\*(C`string_vianame\*(C'\fR
returns \f(CW\*(C`undef\*(C'\fR instead of the \s-1REPLACEMENT\s0 \s-1CHARACTER\s0 and does not raise a
warning message.
.SH "charnames::vianame(\fIname\fP)"
.IX Header "charnames::vianame(name)"
This is similar to \f(CW\*(C`string_vianame\*(C'\fR.  The main difference is that under most
circumstances, vianame returns an ordinal code
point, whereas \f(CW\*(C`string_vianame\*(C'\fR returns a string.  For example,
.PP
.Vb 1
\&   printf "U+%04X", charnames::vianame("FOUR TEARDROP\-SPOKED ASTERISK");
.Ve
.PP
prints \*(L"U+2722\*(R".
.PP
This leads to the other two differences.  Since a single code point is
returned, the function can't handle named character sequences, as these are
composed of multiple characters (it returns \f(CW\*(C`undef\*(C'\fR for these.  And, the code
point can be that of any
character, even ones that aren't legal under the \f(CW\*(C`use\ bytes\*(C'\fR pragma,
.PP
See \*(L"\s-1BUGS\s0\*(R" for the circumstances in which the behavior differs
from  that described above.
.SH "charnames::viacode(\fIcode\fP)"
.IX Header "charnames::viacode(code)"
Returns the full name of the character indicated by the numeric code.
For example,
.PP
.Vb 1
\&    print charnames::viacode(0x2722);
.Ve
.PP
prints \*(L"\s-1FOUR\s0 TEARDROP-SPOKED \s-1ASTERISK\s0\*(R".
.PP
The name returned is the \*(L"best\*(R" (defined below) official name or alias
for the code point, if
available; otherwise your custom alias for it, if defined; otherwise \f(CW\*(C`undef\*(C'\fR.
This means that your alias will only be returned for code points that don't
have an official Unicode name (nor alias) such as private use code points.
.PP
If you define more than one name for the code point, it is indeterminate
which one will be returned.
.PP
As mentioned, the function returns \f(CW\*(C`undef\*(C'\fR if no name is known for the code
point.  In Unicode the proper name of these is the empty string, which
\&\f(CW\*(C`undef\*(C'\fR stringifies to.  (If you ask for a code point past the legal
Unicode maximum of U+10FFFF that you haven't assigned an alias to, you
get \f(CW\*(C`undef\*(C'\fR plus a warning.)
.PP
The input number must be a non-negative integer, or a string beginning
with \f(CW"U+"\fR or \f(CW"0x"\fR with the remainder considered to be a
hexadecimal integer.  A literal numeric constant must be unsigned; it
will be interpreted as hex if it has a leading zero or contains
non-decimal hex digits; otherwise it will be interpreted as decimal.
.PP
As mentioned above under \*(L"\s-1ALIASES\s0\*(R", Unicode 6.1 defines extra names
(synonyms or aliases) for some code points, most of which were already
available as Perl extensions.  All these are accepted by \f(CW\*(C`\eN{...}\*(C'\fR and the
other functions in this module, but \f(CW\*(C`viacode\*(C'\fR has to choose which one
name to return for a given input code point, so it returns the \*(L"best\*(R" name.
To understand how this works, it is helpful to know more about the Unicode
name properties.  All code points actually have only a single name, which
(starting in Unicode 2.0) can never change once a character has been assigned
to the code point.  But mistakes have been made in assigning names, for
example sometimes a clerical error was made during the publishing of the
Standard which caused words to be misspelled, and there was no way to correct
those.  The Name_Alias property was eventually created to handle these
situations.  If a name was wrong, a corrected synonym would be published for
it, using Name_Alias.  \f(CW\*(C`viacode\*(C'\fR will return that corrected synonym as the
\&\*(L"best\*(R" name for a code point.  (It is even possible, though it hasn't happened
yet, that the correction itself will need to be corrected, and so another
Name_Alias can be created for that code point; \f(CW\*(C`viacode\*(C'\fR will return the
most recent correction.)
.PP
The Unicode name for each of the control characters (such as \s-1LINE\s0 \s-1FEED\s0) is the
empty string.  However almost all had names assigned by other standards, such
as the \s-1ASCII\s0 Standard, or were in common use.  \f(CW\*(C`viacode\*(C'\fR returns these names
as the \*(L"best\*(R" ones available.  Unicode 6.1 has created Name_Aliases for each
of them, including alternate names, like \s-1NEW\s0 \s-1LINE\s0.  \f(CW\*(C`viacode\*(C'\fR uses the
original name, \*(L"\s-1LINE\s0 \s-1FEED\s0\*(R" in preference to the alternate.  Similarly the
name returned for U+FEFF is \*(L"\s-1ZERO\s0 \s-1WIDTH\s0 NO-BREAK \s-1SPACE\s0\*(R", not \*(L"\s-1BYTE\s0 \s-1ORDER\s0
\&\s-1MARK\s0\*(R".
.PP
Until Unicode 6.1, the 4 control characters U+0080, U+0081, U+0084, and U+0099
did not have names nor aliases.
To preserve backwards compatibility, any alias you define for these code
points will be returned by this function, in preference to the official name.
.PP
Some code points also have abbreviated names, such as \*(L"\s-1LF\s0\*(R" or \*(L"\s-1NL\s0\*(R".
\&\f(CW\*(C`viacode\*(C'\fR never returns these.
.PP
Because a name correction may be added in future Unicode releases, the name
that \f(CW\*(C`viacode\*(C'\fR returns may change as a result.  This is a rare event, but it
does happen.
.SH "CUSTOM TRANSLATORS"
.IX Header "CUSTOM TRANSLATORS"
The mechanism of translation of \f(CW\*(C`\eN{...}\*(C'\fR escapes is general and not
hardwired into \fIcharnames.pm\fR.  A module can install custom
translations (inside the scope which \f(CW\*(C`use\*(C'\fRs the module) with the
following magic incantation:
.PP
.Vb 4
\&    sub import {
\&        shift;
\&        $^H{charnames} = \e&translator;
\&    }
.Ve
.PP
Here \fItranslator()\fR is a subroutine which takes \fI\s-1CHARNAME\s0\fR as an
argument, and returns text to insert into the string instead of the
\&\f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR escape.
.PP
This is the only way you can create a custom named sequence of code points.
.PP
Since the text to insert should be different
in \f(CW\*(C`bytes\*(C'\fR mode and out of it, the function should check the current
state of \f(CW\*(C`bytes\*(C'\fR\-flag as in:
.PP
.Vb 9
\&    use bytes ();                      # for $bytes::hint_bits
\&    sub translator {
\&        if ($^H & $bytes::hint_bits) {
\&            return bytes_translator(@_);
\&        }
\&        else {
\&            return utf8_translator(@_);
\&        }
\&    }
.Ve
.PP
See \*(L"\s-1CUSTOM\s0 \s-1ALIASES\s0\*(R" above for restrictions on \fI\s-1CHARNAME\s0\fR.
.PP
Of course, \f(CW\*(C`vianame\*(C'\fR, \f(CW\*(C`viacode\*(C'\fR, and \f(CW\*(C`string_vianame\*(C'\fR would need to be
overridden as well.
.SH "BUGS"
.IX Header "BUGS"
\&\fIvianame()\fR normally returns an ordinal code point, but when the input name is of
the form \f(CW\*(C`U+...\*(C'\fR, it returns a chr instead.  In this case, if \f(CW\*(C`use bytes\*(C'\fR is
in effect and the character won't fit into a byte, it returns \f(CW\*(C`undef\*(C'\fR and
raises a warning.
.PP
Names must be \s-1ASCII\s0 characters only, which means that you are out of luck if
you want to create aliases in a language where some or all the characters of
the desired aliases are non-ASCII.
.PP
Since evaluation of the translation function (see \*(L"\s-1CUSTOM\s0
\&\s-1TRANSLATORS\s0\*(R") happens in the middle of compilation (of a string
literal), the translation function should not do any \f(CW\*(C`eval\*(C'\fRs or
\&\f(CW\*(C`require\*(C'\fRs.  This restriction should be lifted (but is low priority) in
a future version of Perl.
                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/charnames5.18.3pm                            0100644 0001750 0001750 00000057353 12566207465 023600  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "charnames 3pm"
.TH charnames 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
charnames \- access to Unicode character names and named character sequences; also define character names
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use charnames \*(Aq:full\*(Aq;
\& print "\eN{GREEK SMALL LETTER SIGMA} is called sigma.\en";
\& print "\eN{LATIN CAPITAL LETTER E WITH VERTICAL LINE BELOW}",
\&       " is an officially named sequence of two Unicode characters\en";
\&
\& use charnames \*(Aq:loose\*(Aq;
\& print "\eN{Greek small\-letter  sigma}",
\&        "can be used to ignore case, underscores, most blanks,"
\&        "and when you aren\*(Aqt sure if the official name has hyphens\en";
\&
\& use charnames \*(Aq:short\*(Aq;
\& print "\eN{greek:Sigma} is an upper\-case sigma.\en";
\&
\& use charnames qw(cyrillic greek);
\& print "\eN{sigma} is Greek sigma, and \eN{be} is Cyrillic b.\en";
\&
\& use utf8;
\& use charnames ":full", ":alias" => {
\&   e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE",
\&   mychar => 0xE8000,  # Private use area
\&   "XXXXXXX" => "BICYCLIST"
\& };
\& print "\eN{e_ACUTE} is a small letter e with an acute.\en";
\& print "\eN{mychar} allows me to name private use characters.\en";
\& print "And I can create synonyms in other languages,",
\&       " such as \eN{XXXXXXX} for "BICYCLIST (U+1F6B4)\en";
\&
\& use charnames ();
\& print charnames::viacode(0x1234); # prints "ETHIOPIC SYLLABLE SEE"
\& printf "%04X", charnames::vianame("GOTHIC LETTER AHSA"); # prints
\&                                                          # "10330"
\& print charnames::vianame("LATIN CAPITAL LETTER A"); # prints 65 on
\&                                                     # ASCII platforms;
\&                                                     # 193 on EBCDIC
\& print charnames::string_vianame("LATIN CAPITAL LETTER A"); # prints "A"
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pragma \f(CW\*(C`use charnames\*(C'\fR is used to gain access to the names of the
Unicode characters and named character sequences, and to allow you to define
your own character and character sequence names.
.PP
All forms of the pragma enable use of the following 3 functions:
.IP "\(bu" 4
"charnames::string_vianame(\fIname\fR)" for run-time lookup of a
either a character name or a named character sequence, returning its string
representation
.IP "\(bu" 4
"charnames::vianame(\fIname\fR)" for run-time lookup of a
character name (but not a named character sequence) to get its ordinal value
(code point)
.IP "\(bu" 4
"charnames::viacode(\fIcode\fR)" for run-time lookup of a code point to get its
Unicode name.
.PP
Starting in Perl v5.16, any occurrence of \f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR sequences
in a double-quotish string automatically loads this module with arguments
\&\f(CW\*(C`:full\*(C'\fR and \f(CW\*(C`:short\*(C'\fR (described below) if it hasn't already been loaded with
different arguments, in order to compile the named Unicode character into
position in the string.  Prior to v5.16, an explicit \f(CW\*(C`use\ charnames\*(C'\fR was
required to enable this usage.  (However, prior to v5.16, the form \f(CW"use\ charnames\ ();"\fR did not enable \f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR.)
.PP
Note that \f(CW\*(C`\eN{U+\f(CI...\f(CW}\*(C'\fR, where the \fI...\fR is a hexadecimal number,
also inserts a character into a string.
The character it inserts is the one whose code point
(ordinal value) is equal to the number.  For example, \f(CW"\eN{U+263a}"\fR is
the Unicode (white background, black foreground) smiley face
equivalent to \f(CW"\eN{WHITE SMILING FACE}"\fR.
Also note, \f(CW\*(C`\eN{\f(CI...\f(CW}\*(C'\fR can mean a regex quantifier instead of a character
name, when the \fI...\fR is a number (or comma separated pair of numbers
(see \*(L"\s-1QUANTIFIERS\*(R"\s0 in perlreref), and is not related to this pragma.
.PP
The \f(CW\*(C`charnames\*(C'\fR pragma supports arguments \f(CW\*(C`:full\*(C'\fR, \f(CW\*(C`:loose\*(C'\fR, \f(CW\*(C`:short\*(C'\fR,
script names and customized aliases.
.PP
If \f(CW\*(C`:full\*(C'\fR is present, for expansion of
\&\f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR, the string \fI\s-1CHARNAME\s0\fR is first looked up in the list of
standard Unicode character names.
.PP
\&\f(CW\*(C`:loose\*(C'\fR is a variant of \f(CW\*(C`:full\*(C'\fR which allows \fI\s-1CHARNAME\s0\fR to be less
precisely specified.  Details are in \*(L"\s-1LOOSE MATCHES\*(R"\s0.
.PP
If \f(CW\*(C`:short\*(C'\fR is present, and
\&\fI\s-1CHARNAME\s0\fR has the form \f(CW\*(C`\f(CISCRIPT\f(CW:\f(CICNAME\f(CW\*(C'\fR, then \fI\s-1CNAME\s0\fR is looked up
as a letter in script \fI\s-1SCRIPT\s0\fR, as described in the next paragraph.
Or, if \f(CW\*(C`use charnames\*(C'\fR is used
with script name arguments, then for \f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR the name
\&\fI\s-1CHARNAME\s0\fR is looked up as a letter in the given scripts (in the
specified order). Customized aliases can override these, and are explained in
\&\*(L"\s-1CUSTOM ALIASES\*(R"\s0.
.PP
For lookup of \fI\s-1CHARNAME\s0\fR inside a given script \fI\s-1SCRIPTNAME\s0\fR,
this pragma looks in the table of standard Unicode names for the names
.PP
.Vb 3
\&  SCRIPTNAME CAPITAL LETTER CHARNAME
\&  SCRIPTNAME SMALL LETTER CHARNAME
\&  SCRIPTNAME LETTER CHARNAME
.Ve
.PP
If \fI\s-1CHARNAME\s0\fR is all lowercase,
then the \f(CW\*(C`CAPITAL\*(C'\fR variant is ignored, otherwise the \f(CW\*(C`SMALL\*(C'\fR variant
is ignored, and both \fI\s-1CHARNAME\s0\fR and \fI\s-1SCRIPTNAME\s0\fR are converted to all
uppercase for look-up.  Other than that, both of them follow loose rules if \f(CW\*(C`:loose\*(C'\fR is also specified; strict otherwise.
.PP
Note that \f(CW\*(C`\eN{...}\*(C'\fR is compile-time; it's a special form of string
constant used inside double-quotish strings; this means that you cannot
use variables inside the \f(CW\*(C`\eN{...}\*(C'\fR.  If you want similar run-time
functionality, use
\&\fIcharnames::string_vianame()\fR.
.PP
Note, starting in Perl 5.18, the name \f(CW\*(C`BELL\*(C'\fR refers to the Unicode character
U+1F514, instead of the traditional U+0007.  For the latter, use \f(CW\*(C`ALERT\*(C'\fR
or \f(CW\*(C`BEL\*(C'\fR.
.PP
It is a syntax error to use \f(CW\*(C`\eN{NAME}\*(C'\fR where \f(CW\*(C`NAME\*(C'\fR is unknown.
.PP
For \f(CW\*(C`\eN{NAME}\*(C'\fR, it is a fatal error if \f(CW\*(C`use bytes\*(C'\fR is in effect and the
input name is that of a character that won't fit into a byte (i.e., whose
ordinal is above 255).
.PP
Otherwise, any string that includes a \f(CW\*(C`\eN{\f(CIcharname\f(CW}\*(C'\fR or
\&\f(CW\*(C`\eN{U+\f(CIcode\ point\f(CW}\*(C'\fR will automatically have Unicode semantics (see
\&\*(L"Byte and Character Semantics\*(R" in perlunicode).
.SH "LOOSE MATCHES"
.IX Header "LOOSE MATCHES"
By specifying \f(CW\*(C`:loose\*(C'\fR, Unicode's loose character name
matching <http://www.unicode.org/reports/tr44#Matching_Rules> rules are
selected instead of the strict exact match used otherwise.
That means that \fI\s-1CHARNAME\s0\fR doesn't have to be so precisely specified.
Upper/lower case doesn't matter (except with scripts as mentioned above), nor
do any underscores, and the only hyphens that matter are those at the
beginning or end of a word in the name (with one exception:  the hyphen in
U+1180 \f(CW\*(C`HANGUL JUNGSEONG O\-E\*(C'\fR does matter).
Also, blanks not adjacent to hyphens don't matter.
The official Unicode names are quite variable as to where they use hyphens
versus spaces to separate word-like units, and this option allows you to not
have to care as much.
The reason non-medial hyphens matter is because of cases like
U+0F60 \f(CW\*(C`TIBETAN LETTER \-A\*(C'\fR versus U+0F68 \f(CW\*(C`TIBETAN LETTER A\*(C'\fR.
The hyphen here is significant, as is the space before it, and so both must be
included.
.PP
\&\f(CW\*(C`:loose\*(C'\fR slows down look-ups by a factor of 2 to 3 versus
\&\f(CW\*(C`:full\*(C'\fR, but the trade-off may be worth it to you.  Each individual look-up
takes very little time, and the results are cached, so the speed difference
would become a factor only in programs that do look-ups of many different
spellings, and probably only when those look-ups are through \f(CW\*(C`vianame()\*(C'\fR and
\&\f(CW\*(C`string_vianame()\*(C'\fR, since \f(CW\*(C`\eN{...}\*(C'\fR look-ups are done at compile time.
.SH "ALIASES"
.IX Header "ALIASES"
Starting in Unicode 6.1 and Perl v5.16, Unicode defines many abbreviations and
names that were formerly Perl extensions, and some additional ones that Perl
did not previously accept.  The list is getting too long to reproduce here,
but you can get the complete list from the Unicode web site:
<http://www.unicode.org/Public/UNIDATA/NameAliases.txt>.
.PP
Earlier versions of Perl accepted almost all the 6.1 names.  These were most
extensively documented in the v5.14 version of this pod:
<http://perldoc.perl.org/5.14.0/charnames.html#ALIASES>.
.SH "CUSTOM ALIASES"
.IX Header "CUSTOM ALIASES"
You can add customized aliases to standard (\f(CW\*(C`:full\*(C'\fR) Unicode naming
conventions.  The aliases override any standard definitions, so, if
you're twisted enough, you can change \f(CW"\eN{LATIN CAPITAL LETTER A}"\fR to
mean \f(CW"B"\fR, etc.
.PP
Aliases must begin with a character that is alphabetic.  After that, each may
contain any combination of word (\f(CW\*(C`\ew\*(C'\fR) characters, \s-1SPACE \s0(U+0020),
HYPHEN-MINUS (U+002D), \s-1LEFT PARENTHESIS \s0(U+0028), \s-1RIGHT PARENTHESIS \s0(U+0029),
and NO-BREAK \s-1SPACE \s0(U+00A0).  These last three should never have been allowed
in names, and are retained for backwards compatibility only; they may be
deprecated and removed in future releases of Perl, so don't use them for new
names.  (More precisely, the first character of a name you specify must be
something that matches all of \f(CW\*(C`\ep{ID_Start}\*(C'\fR, \f(CW\*(C`\ep{Alphabetic}\*(C'\fR, and
\&\f(CW\*(C`\ep{Gc=Letter}\*(C'\fR.  This makes sure it is what any reasonable person would view
as an alphabetic character.  And, the continuation characters that match \f(CW\*(C`\ew\*(C'\fR
must also match \f(CW\*(C`\ep{ID_Continue}\*(C'\fR.)  Starting with Perl v5.18, any Unicode
characters meeting the above criteria may be used; prior to that only
Latin1\-range characters were acceptable.
.PP
An alias can map to either an official Unicode character name (not a loose
matched name) or to a
numeric code point (ordinal).  The latter is useful for assigning names
to code points in Unicode private use areas such as U+E800 through
U+F8FF.
A numeric code point must be a non-negative integer or a string beginning
with \f(CW"U+"\fR or \f(CW"0x"\fR with the remainder considered to be a
hexadecimal integer.  A literal numeric constant must be unsigned; it
will be interpreted as hex if it has a leading zero or contains
non-decimal hex digits; otherwise it will be interpreted as decimal.
.PP
Aliases are added either by the use of anonymous hashes:
.PP
.Vb 5
\&    use charnames ":alias" => {
\&        e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE",
\&        mychar1 => 0xE8000,
\&        };
\&    my $str = "\eN{e_ACUTE}";
.Ve
.PP
or by using a file containing aliases:
.PP
.Vb 1
\&    use charnames ":alias" => "pro";
.Ve
.PP
This will try to read \f(CW"unicore/pro_alias.pl"\fR from the \f(CW@INC\fR path. This
file should return a list in plain perl:
.PP
.Vb 10
\&    (
\&    A_GRAVE         => "LATIN CAPITAL LETTER A WITH GRAVE",
\&    A_CIRCUM        => "LATIN CAPITAL LETTER A WITH CIRCUMFLEX",
\&    A_DIAERES       => "LATIN CAPITAL LETTER A WITH DIAERESIS",
\&    A_TILDE         => "LATIN CAPITAL LETTER A WITH TILDE",
\&    A_BREVE         => "LATIN CAPITAL LETTER A WITH BREVE",
\&    A_RING          => "LATIN CAPITAL LETTER A WITH RING ABOVE",
\&    A_MACRON        => "LATIN CAPITAL LETTER A WITH MACRON",
\&    mychar2         => "U+E8001",
\&    );
.Ve
.PP
Both these methods insert \f(CW":full"\fR automatically as the first argument (if no
other argument is given), and you can give the \f(CW":full"\fR explicitly as
well, like
.PP
.Vb 1
\&    use charnames ":full", ":alias" => "pro";
.Ve
.PP
\&\f(CW":loose"\fR has no effect with these.  Input names must match exactly, using
\&\f(CW":full"\fR rules.
.PP
Also, both these methods currently allow only single characters to be named.
To name a sequence of characters, use a
custom translator (described below).
.SH "charnames::string_vianame(\fIname\fP)"
.IX Header "charnames::string_vianame(name)"
This is a runtime equivalent to \f(CW\*(C`\eN{...}\*(C'\fR.  \fIname\fR can be any expression
that evaluates to a name accepted by \f(CW\*(C`\eN{...}\*(C'\fR under the \f(CW\*(C`:full\*(C'\fR
option to \f(CW\*(C`charnames\*(C'\fR.  In addition, any other options for the
controlling \f(CW"use charnames"\fR in the same scope apply, like \f(CW\*(C`:loose\*(C'\fR or any
script list, \f(CW\*(C`:short\*(C'\fR option, or custom aliases you may have defined.
.PP
The only differences are due to the fact that \f(CW\*(C`string_vianame\*(C'\fR is run-time
and \f(CW\*(C`\eN{}\*(C'\fR is compile time.  You can't interpolate inside a \f(CW\*(C`\eN{}\*(C'\fR, (so
\&\f(CW\*(C`\eN{$variable}\*(C'\fR doesn't work); and if the input name is unknown,
\&\f(CW\*(C`string_vianame\*(C'\fR returns \f(CW\*(C`undef\*(C'\fR instead of it being a syntax error.
.SH "charnames::vianame(\fIname\fP)"
.IX Header "charnames::vianame(name)"
This is similar to \f(CW\*(C`string_vianame\*(C'\fR.  The main difference is that under most
circumstances, \f(CW\*(C`vianame\*(C'\fR returns an ordinal code
point, whereas \f(CW\*(C`string_vianame\*(C'\fR returns a string.  For example,
.PP
.Vb 1
\&   printf "U+%04X", charnames::vianame("FOUR TEARDROP\-SPOKED ASTERISK");
.Ve
.PP
prints \*(L"U+2722\*(R".
.PP
This leads to the other two differences.  Since a single code point is
returned, the function can't handle named character sequences, as these are
composed of multiple characters (it returns \f(CW\*(C`undef\*(C'\fR for these.  And, the code
point can be that of any
character, even ones that aren't legal under the \f(CW\*(C`use\ bytes\*(C'\fR pragma,
.PP
See \*(L"\s-1BUGS\*(R"\s0 for the circumstances in which the behavior differs
from  that described above.
.SH "charnames::viacode(\fIcode\fP)"
.IX Header "charnames::viacode(code)"
Returns the full name of the character indicated by the numeric code.
For example,
.PP
.Vb 1
\&    print charnames::viacode(0x2722);
.Ve
.PP
prints \*(L"\s-1FOUR\s0 TEARDROP-SPOKED \s-1ASTERISK\*(R".\s0
.PP
The name returned is the \*(L"best\*(R" (defined below) official name or alias
for the code point, if
available; otherwise your custom alias for it, if defined; otherwise \f(CW\*(C`undef\*(C'\fR.
This means that your alias will only be returned for code points that don't
have an official Unicode name (nor alias) such as private use code points.
.PP
If you define more than one name for the code point, it is indeterminate
which one will be returned.
.PP
As mentioned, the function returns \f(CW\*(C`undef\*(C'\fR if no name is known for the code
point.  In Unicode the proper name for these is the empty string, which
\&\f(CW\*(C`undef\*(C'\fR stringifies to.  (If you ask for a code point past the legal
Unicode maximum of U+10FFFF that you haven't assigned an alias to, you
get \f(CW\*(C`undef\*(C'\fR plus a warning.)
.PP
The input number must be a non-negative integer, or a string beginning
with \f(CW"U+"\fR or \f(CW"0x"\fR with the remainder considered to be a
hexadecimal integer.  A literal numeric constant must be unsigned; it
will be interpreted as hex if it has a leading zero or contains
non-decimal hex digits; otherwise it will be interpreted as decimal.
.PP
As mentioned above under \*(L"\s-1ALIASES\*(R"\s0, Unicode 6.1 defines extra names
(synonyms or aliases) for some code points, most of which were already
available as Perl extensions.  All these are accepted by \f(CW\*(C`\eN{...}\*(C'\fR and the
other functions in this module, but \f(CW\*(C`viacode\*(C'\fR has to choose which one
name to return for a given input code point, so it returns the \*(L"best\*(R" name.
To understand how this works, it is helpful to know more about the Unicode
name properties.  All code points actually have only a single name, which
(starting in Unicode 2.0) can never change once a character has been assigned
to the code point.  But mistakes have been made in assigning names, for
example sometimes a clerical error was made during the publishing of the
Standard which caused words to be misspelled, and there was no way to correct
those.  The Name_Alias property was eventually created to handle these
situations.  If a name was wrong, a corrected synonym would be published for
it, using Name_Alias.  \f(CW\*(C`viacode\*(C'\fR will return that corrected synonym as the
\&\*(L"best\*(R" name for a code point.  (It is even possible, though it hasn't happened
yet, that the correction itself will need to be corrected, and so another
Name_Alias can be created for that code point; \f(CW\*(C`viacode\*(C'\fR will return the
most recent correction.)
.PP
The Unicode name for each of the control characters (such as \s-1LINE FEED\s0) is the
empty string.  However almost all had names assigned by other standards, such
as the \s-1ASCII\s0 Standard, or were in common use.  \f(CW\*(C`viacode\*(C'\fR returns these names
as the \*(L"best\*(R" ones available.  Unicode 6.1 has created Name_Aliases for each
of them, including alternate names, like \s-1NEW LINE.  \s0\f(CW\*(C`viacode\*(C'\fR uses the
original name, \*(L"\s-1LINE FEED\*(R"\s0 in preference to the alternate.  Similarly the
name returned for U+FEFF is \*(L"\s-1ZERO WIDTH\s0 NO-BREAK \s-1SPACE\*(R",\s0 not \*(L"\s-1BYTE ORDER
MARK\*(R".\s0
.PP
Until Unicode 6.1, the 4 control characters U+0080, U+0081, U+0084, and U+0099
did not have names nor aliases.
To preserve backwards compatibility, any alias you define for these code
points will be returned by this function, in preference to the official name.
.PP
Some code points also have abbreviated names, such as \*(L"\s-1LF\*(R"\s0 or \*(L"\s-1NL\*(R".
\&\s0\f(CW\*(C`viacode\*(C'\fR never returns these.
.PP
Because a name correction may be added in future Unicode releases, the name
that \f(CW\*(C`viacode\*(C'\fR returns may change as a result.  This is a rare event, but it
does happen.
.SH "CUSTOM TRANSLATORS"
.IX Header "CUSTOM TRANSLATORS"
The mechanism of translation of \f(CW\*(C`\eN{...}\*(C'\fR escapes is general and not
hardwired into \fIcharnames.pm\fR.  A module can install custom
translations (inside the scope which \f(CW\*(C`use\*(C'\fRs the module) with the
following magic incantation:
.PP
.Vb 4
\&    sub import {
\&        shift;
\&        $^H{charnames} = \e&translator;
\&    }
.Ve
.PP
Here \fItranslator()\fR is a subroutine which takes \fI\s-1CHARNAME\s0\fR as an
argument, and returns text to insert into the string instead of the
\&\f(CW\*(C`\eN{\f(CICHARNAME\f(CW}\*(C'\fR escape.
.PP
This is the only way you can create a custom named sequence of code points.
.PP
Since the text to insert should be different
in \f(CW\*(C`bytes\*(C'\fR mode and out of it, the function should check the current
state of \f(CW\*(C`bytes\*(C'\fR\-flag as in:
.PP
.Vb 9
\&    use bytes ();                      # for $bytes::hint_bits
\&    sub translator {
\&        if ($^H & $bytes::hint_bits) {
\&            return bytes_translator(@_);
\&        }
\&        else {
\&            return utf8_translator(@_);
\&        }
\&    }
.Ve
.PP
See \*(L"\s-1CUSTOM ALIASES\*(R"\s0 above for restrictions on \fI\s-1CHARNAME\s0\fR.
.PP
Of course, \f(CW\*(C`vianame\*(C'\fR, \f(CW\*(C`viacode\*(C'\fR, and \f(CW\*(C`string_vianame\*(C'\fR would need to be
overridden as well.
.SH "BUGS"
.IX Header "BUGS"
\&\fIvianame()\fR normally returns an ordinal code point, but when the input name is of
the form \f(CW\*(C`U+...\*(C'\fR, it returns a chr instead.  In this case, if \f(CW\*(C`use bytes\*(C'\fR is
in effect and the character won't fit into a byte, it returns \f(CW\*(C`undef\*(C'\fR and
raises a warning.
.PP
Since evaluation of the translation function (see \*(L"\s-1CUSTOM
TRANSLATORS\*(R"\s0) happens in the middle of compilation (of a string
literal), the translation function should not do any \f(CW\*(C`eval\*(C'\fRs or
\&\f(CW\*(C`require\*(C'\fRs.  This restriction should be lifted (but is low priority) in
a future version of Perl.
                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/check_int32_add.3                            0100644 0001750 0001750 00000007557 12566166265 023675  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 20, 2007
.Dt CHECK_INT32_ADD 3
.Os
.Sh NAME
.Nm check_int32_add ,
.Nm check_uint32_add ,
.Nm check_int64_add ,
.Nm check_uint64_add ,
.Nm check_int32_sub ,
.Nm check_uint32_sub ,
.Nm check_int64_sub ,
.Nm check_uint64_sub ,
.Nm check_int32_mul ,
.Nm check_uint32_mul ,
.Nm check_int64_mul ,
.Nm check_uint64_mul ,
.Nm check_int32_div ,
.Nm check_uint32_div ,
.Nm check_int64_div ,
.Nm check_uint64_div ,
.Nd detect overflow in arithmetic
.Sh SYNOPSIS
.In checkint.h
.Ft int32_t
.Fo check_int32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Sh DESCRIPTION
The
.Fn check_<type>_<operation> "x" "y" "err" 
family of functions perform the specified arithmetic operation (addition, subtraction, 
multiplication, or division) with the left operand of
.Fa x
and right operand of
.Fa y 
and return the arithmetic result with the specified type.   
.Pp
Either operand 
.Fa x
or 
.Fa y
(or both) can be of any type that is compatible to signed or unsigned
8-bit, 16-bit, 32-bit, or 64-bit integers.
.Pp
The
.Fa err
argument is 
.Em or Ns 'ed
by flags in the function to indicate if an overflow has occurred. 
The possible flag values are:
.Pp
.Bd -literal -offset indent -compact
CHECKINT_NO_ERROR		no overflow has occurred
CHECKINT_OVERFLOW_ERROR		overflow has occurred
CHECKINT_TYPE_ERROR		operand is of an incompatible type
.Ed
.Pp
The
.Fa err
argument is not cleared in calls to the 
.Fn check_<type>_<operation> "x" "y" "err" 
functions.  Detected overflow persists in the 
.Fa err
argument until
.Fa err
is reset to CHECKINT_NO_ERROR.
.Sh RETURN VALUES
If successful, the
.Fn check_<type>_<operation> 
functions will return the arithmetic result of performing the operation with left operand
.Fa x
and right operand
.Fa y 
(even when overflow error occurs). 
.Pp
If any other error occurs, the return value is -1
and the argument
.Fa err
will be set to indicate the error.
.Sh EXAMPLES
.Bd -literal -offset indent
/* Create a variable to store overflow flag */
int32_t err = CHECKINT_NO_ERROR;
/* Use checkint API to perform an arithmetic operation and
 * store result in variable. */
int32_t arithmetic_result = check_int32_add(UINT_MAX, 1, &err);
/* Check status of overflow flag */
if (err & CHECKINT_OVERFLOW_ERROR) {
    /* Perform overflow resolution code */
    fprintf(stderr, "Overflow detected!\\n");
}
/* Check for type error */
else if (err & CHECKINT_TYPE_ERROR) {
    /* Deal with incompatible types error */
    fprintf(stderr, "Incompatible types!\\n");
}
/* Reset overflow flag for next operation */
err = CHECKINT_NO_ERROR;
 
.Ed
.Sh ERRORS
The 
.Fn check_<type>_<operation> 
functions may fail if:
.Pp
.Bd -literal -offset indent -compact
[CHECKINT_TYPE_ERROR]		operand is of an incompatible type
.Ed
.Sh HISTORY
The
.Fn checkint
API was introduced in Mac OS X 10.5.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/check_int32_div.3                            0100644 0001750 0001750 00000007557 12566166265 023727  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 20, 2007
.Dt CHECK_INT32_ADD 3
.Os
.Sh NAME
.Nm check_int32_add ,
.Nm check_uint32_add ,
.Nm check_int64_add ,
.Nm check_uint64_add ,
.Nm check_int32_sub ,
.Nm check_uint32_sub ,
.Nm check_int64_sub ,
.Nm check_uint64_sub ,
.Nm check_int32_mul ,
.Nm check_uint32_mul ,
.Nm check_int64_mul ,
.Nm check_uint64_mul ,
.Nm check_int32_div ,
.Nm check_uint32_div ,
.Nm check_int64_div ,
.Nm check_uint64_div ,
.Nd detect overflow in arithmetic
.Sh SYNOPSIS
.In checkint.h
.Ft int32_t
.Fo check_int32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Sh DESCRIPTION
The
.Fn check_<type>_<operation> "x" "y" "err" 
family of functions perform the specified arithmetic operation (addition, subtraction, 
multiplication, or division) with the left operand of
.Fa x
and right operand of
.Fa y 
and return the arithmetic result with the specified type.   
.Pp
Either operand 
.Fa x
or 
.Fa y
(or both) can be of any type that is compatible to signed or unsigned
8-bit, 16-bit, 32-bit, or 64-bit integers.
.Pp
The
.Fa err
argument is 
.Em or Ns 'ed
by flags in the function to indicate if an overflow has occurred. 
The possible flag values are:
.Pp
.Bd -literal -offset indent -compact
CHECKINT_NO_ERROR		no overflow has occurred
CHECKINT_OVERFLOW_ERROR		overflow has occurred
CHECKINT_TYPE_ERROR		operand is of an incompatible type
.Ed
.Pp
The
.Fa err
argument is not cleared in calls to the 
.Fn check_<type>_<operation> "x" "y" "err" 
functions.  Detected overflow persists in the 
.Fa err
argument until
.Fa err
is reset to CHECKINT_NO_ERROR.
.Sh RETURN VALUES
If successful, the
.Fn check_<type>_<operation> 
functions will return the arithmetic result of performing the operation with left operand
.Fa x
and right operand
.Fa y 
(even when overflow error occurs). 
.Pp
If any other error occurs, the return value is -1
and the argument
.Fa err
will be set to indicate the error.
.Sh EXAMPLES
.Bd -literal -offset indent
/* Create a variable to store overflow flag */
int32_t err = CHECKINT_NO_ERROR;
/* Use checkint API to perform an arithmetic operation and
 * store result in variable. */
int32_t arithmetic_result = check_int32_add(UINT_MAX, 1, &err);
/* Check status of overflow flag */
if (err & CHECKINT_OVERFLOW_ERROR) {
    /* Perform overflow resolution code */
    fprintf(stderr, "Overflow detected!\\n");
}
/* Check for type error */
else if (err & CHECKINT_TYPE_ERROR) {
    /* Deal with incompatible types error */
    fprintf(stderr, "Incompatible types!\\n");
}
/* Reset overflow flag for next operation */
err = CHECKINT_NO_ERROR;
 
.Ed
.Sh ERRORS
The 
.Fn check_<type>_<operation> 
functions may fail if:
.Pp
.Bd -literal -offset indent -compact
[CHECKINT_TYPE_ERROR]		operand is of an incompatible type
.Ed
.Sh HISTORY
The
.Fn checkint
API was introduced in Mac OS X 10.5.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/check_int32_mul.3                            0100644 0001750 0001750 00000007557 12566166265 023742  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 20, 2007
.Dt CHECK_INT32_ADD 3
.Os
.Sh NAME
.Nm check_int32_add ,
.Nm check_uint32_add ,
.Nm check_int64_add ,
.Nm check_uint64_add ,
.Nm check_int32_sub ,
.Nm check_uint32_sub ,
.Nm check_int64_sub ,
.Nm check_uint64_sub ,
.Nm check_int32_mul ,
.Nm check_uint32_mul ,
.Nm check_int64_mul ,
.Nm check_uint64_mul ,
.Nm check_int32_div ,
.Nm check_uint32_div ,
.Nm check_int64_div ,
.Nm check_uint64_div ,
.Nd detect overflow in arithmetic
.Sh SYNOPSIS
.In checkint.h
.Ft int32_t
.Fo check_int32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Sh DESCRIPTION
The
.Fn check_<type>_<operation> "x" "y" "err" 
family of functions perform the specified arithmetic operation (addition, subtraction, 
multiplication, or division) with the left operand of
.Fa x
and right operand of
.Fa y 
and return the arithmetic result with the specified type.   
.Pp
Either operand 
.Fa x
or 
.Fa y
(or both) can be of any type that is compatible to signed or unsigned
8-bit, 16-bit, 32-bit, or 64-bit integers.
.Pp
The
.Fa err
argument is 
.Em or Ns 'ed
by flags in the function to indicate if an overflow has occurred. 
The possible flag values are:
.Pp
.Bd -literal -offset indent -compact
CHECKINT_NO_ERROR		no overflow has occurred
CHECKINT_OVERFLOW_ERROR		overflow has occurred
CHECKINT_TYPE_ERROR		operand is of an incompatible type
.Ed
.Pp
The
.Fa err
argument is not cleared in calls to the 
.Fn check_<type>_<operation> "x" "y" "err" 
functions.  Detected overflow persists in the 
.Fa err
argument until
.Fa err
is reset to CHECKINT_NO_ERROR.
.Sh RETURN VALUES
If successful, the
.Fn check_<type>_<operation> 
functions will return the arithmetic result of performing the operation with left operand
.Fa x
and right operand
.Fa y 
(even when overflow error occurs). 
.Pp
If any other error occurs, the return value is -1
and the argument
.Fa err
will be set to indicate the error.
.Sh EXAMPLES
.Bd -literal -offset indent
/* Create a variable to store overflow flag */
int32_t err = CHECKINT_NO_ERROR;
/* Use checkint API to perform an arithmetic operation and
 * store result in variable. */
int32_t arithmetic_result = check_int32_add(UINT_MAX, 1, &err);
/* Check status of overflow flag */
if (err & CHECKINT_OVERFLOW_ERROR) {
    /* Perform overflow resolution code */
    fprintf(stderr, "Overflow detected!\\n");
}
/* Check for type error */
else if (err & CHECKINT_TYPE_ERROR) {
    /* Deal with incompatible types error */
    fprintf(stderr, "Incompatible types!\\n");
}
/* Reset overflow flag for next operation */
err = CHECKINT_NO_ERROR;
 
.Ed
.Sh ERRORS
The 
.Fn check_<type>_<operation> 
functions may fail if:
.Pp
.Bd -literal -offset indent -compact
[CHECKINT_TYPE_ERROR]		operand is of an incompatible type
.Ed
.Sh HISTORY
The
.Fn checkint
API was introduced in Mac OS X 10.5.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/check_int32_sub.3                            0100644 0001750 0001750 00000007557 12566166265 023736  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 20, 2007
.Dt CHECK_INT32_ADD 3
.Os
.Sh NAME
.Nm check_int32_add ,
.Nm check_uint32_add ,
.Nm check_int64_add ,
.Nm check_uint64_add ,
.Nm check_int32_sub ,
.Nm check_uint32_sub ,
.Nm check_int64_sub ,
.Nm check_uint64_sub ,
.Nm check_int32_mul ,
.Nm check_uint32_mul ,
.Nm check_int64_mul ,
.Nm check_uint64_mul ,
.Nm check_int32_div ,
.Nm check_uint32_div ,
.Nm check_int64_div ,
.Nm check_uint64_div ,
.Nd detect overflow in arithmetic
.Sh SYNOPSIS
.In checkint.h
.Ft int32_t
.Fo check_int32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Sh DESCRIPTION
The
.Fn check_<type>_<operation> "x" "y" "err" 
family of functions perform the specified arithmetic operation (addition, subtraction, 
multiplication, or division) with the left operand of
.Fa x
and right operand of
.Fa y 
and return the arithmetic result with the specified type.   
.Pp
Either operand 
.Fa x
or 
.Fa y
(or both) can be of any type that is compatible to signed or unsigned
8-bit, 16-bit, 32-bit, or 64-bit integers.
.Pp
The
.Fa err
argument is 
.Em or Ns 'ed
by flags in the function to indicate if an overflow has occurred. 
The possible flag values are:
.Pp
.Bd -literal -offset indent -compact
CHECKINT_NO_ERROR		no overflow has occurred
CHECKINT_OVERFLOW_ERROR		overflow has occurred
CHECKINT_TYPE_ERROR		operand is of an incompatible type
.Ed
.Pp
The
.Fa err
argument is not cleared in calls to the 
.Fn check_<type>_<operation> "x" "y" "err" 
functions.  Detected overflow persists in the 
.Fa err
argument until
.Fa err
is reset to CHECKINT_NO_ERROR.
.Sh RETURN VALUES
If successful, the
.Fn check_<type>_<operation> 
functions will return the arithmetic result of performing the operation with left operand
.Fa x
and right operand
.Fa y 
(even when overflow error occurs). 
.Pp
If any other error occurs, the return value is -1
and the argument
.Fa err
will be set to indicate the error.
.Sh EXAMPLES
.Bd -literal -offset indent
/* Create a variable to store overflow flag */
int32_t err = CHECKINT_NO_ERROR;
/* Use checkint API to perform an arithmetic operation and
 * store result in variable. */
int32_t arithmetic_result = check_int32_add(UINT_MAX, 1, &err);
/* Check status of overflow flag */
if (err & CHECKINT_OVERFLOW_ERROR) {
    /* Perform overflow resolution code */
    fprintf(stderr, "Overflow detected!\\n");
}
/* Check for type error */
else if (err & CHECKINT_TYPE_ERROR) {
    /* Deal with incompatible types error */
    fprintf(stderr, "Incompatible types!\\n");
}
/* Reset overflow flag for next operation */
err = CHECKINT_NO_ERROR;
 
.Ed
.Sh ERRORS
The 
.Fn check_<type>_<operation> 
functions may fail if:
.Pp
.Bd -literal -offset indent -compact
[CHECKINT_TYPE_ERROR]		operand is of an incompatible type
.Ed
.Sh HISTORY
The
.Fn checkint
API was introduced in Mac OS X 10.5.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/check_int64_add.3                            0100644 0001750 0001750 00000007557 12566166265 023702  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 20, 2007
.Dt CHECK_INT32_ADD 3
.Os
.Sh NAME
.Nm check_int32_add ,
.Nm check_uint32_add ,
.Nm check_int64_add ,
.Nm check_uint64_add ,
.Nm check_int32_sub ,
.Nm check_uint32_sub ,
.Nm check_int64_sub ,
.Nm check_uint64_sub ,
.Nm check_int32_mul ,
.Nm check_uint32_mul ,
.Nm check_int64_mul ,
.Nm check_uint64_mul ,
.Nm check_int32_div ,
.Nm check_uint32_div ,
.Nm check_int64_div ,
.Nm check_uint64_div ,
.Nd detect overflow in arithmetic
.Sh SYNOPSIS
.In checkint.h
.Ft int32_t
.Fo check_int32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Sh DESCRIPTION
The
.Fn check_<type>_<operation> "x" "y" "err" 
family of functions perform the specified arithmetic operation (addition, subtraction, 
multiplication, or division) with the left operand of
.Fa x
and right operand of
.Fa y 
and return the arithmetic result with the specified type.   
.Pp
Either operand 
.Fa x
or 
.Fa y
(or both) can be of any type that is compatible to signed or unsigned
8-bit, 16-bit, 32-bit, or 64-bit integers.
.Pp
The
.Fa err
argument is 
.Em or Ns 'ed
by flags in the function to indicate if an overflow has occurred. 
The possible flag values are:
.Pp
.Bd -literal -offset indent -compact
CHECKINT_NO_ERROR		no overflow has occurred
CHECKINT_OVERFLOW_ERROR		overflow has occurred
CHECKINT_TYPE_ERROR		operand is of an incompatible type
.Ed
.Pp
The
.Fa err
argument is not cleared in calls to the 
.Fn check_<type>_<operation> "x" "y" "err" 
functions.  Detected overflow persists in the 
.Fa err
argument until
.Fa err
is reset to CHECKINT_NO_ERROR.
.Sh RETURN VALUES
If successful, the
.Fn check_<type>_<operation> 
functions will return the arithmetic result of performing the operation with left operand
.Fa x
and right operand
.Fa y 
(even when overflow error occurs). 
.Pp
If any other error occurs, the return value is -1
and the argument
.Fa err
will be set to indicate the error.
.Sh EXAMPLES
.Bd -literal -offset indent
/* Create a variable to store overflow flag */
int32_t err = CHECKINT_NO_ERROR;
/* Use checkint API to perform an arithmetic operation and
 * store result in variable. */
int32_t arithmetic_result = check_int32_add(UINT_MAX, 1, &err);
/* Check status of overflow flag */
if (err & CHECKINT_OVERFLOW_ERROR) {
    /* Perform overflow resolution code */
    fprintf(stderr, "Overflow detected!\\n");
}
/* Check for type error */
else if (err & CHECKINT_TYPE_ERROR) {
    /* Deal with incompatible types error */
    fprintf(stderr, "Incompatible types!\\n");
}
/* Reset overflow flag for next operation */
err = CHECKINT_NO_ERROR;
 
.Ed
.Sh ERRORS
The 
.Fn check_<type>_<operation> 
functions may fail if:
.Pp
.Bd -literal -offset indent -compact
[CHECKINT_TYPE_ERROR]		operand is of an incompatible type
.Ed
.Sh HISTORY
The
.Fn checkint
API was introduced in Mac OS X 10.5.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/check_int64_div.3                            0100644 0001750 0001750 00000007557 12566166265 023734  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 20, 2007
.Dt CHECK_INT32_ADD 3
.Os
.Sh NAME
.Nm check_int32_add ,
.Nm check_uint32_add ,
.Nm check_int64_add ,
.Nm check_uint64_add ,
.Nm check_int32_sub ,
.Nm check_uint32_sub ,
.Nm check_int64_sub ,
.Nm check_uint64_sub ,
.Nm check_int32_mul ,
.Nm check_uint32_mul ,
.Nm check_int64_mul ,
.Nm check_uint64_mul ,
.Nm check_int32_div ,
.Nm check_uint32_div ,
.Nm check_int64_div ,
.Nm check_uint64_div ,
.Nd detect overflow in arithmetic
.Sh SYNOPSIS
.In checkint.h
.Ft int32_t
.Fo check_int32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Sh DESCRIPTION
The
.Fn check_<type>_<operation> "x" "y" "err" 
family of functions perform the specified arithmetic operation (addition, subtraction, 
multiplication, or division) with the left operand of
.Fa x
and right operand of
.Fa y 
and return the arithmetic result with the specified type.   
.Pp
Either operand 
.Fa x
or 
.Fa y
(or both) can be of any type that is compatible to signed or unsigned
8-bit, 16-bit, 32-bit, or 64-bit integers.
.Pp
The
.Fa err
argument is 
.Em or Ns 'ed
by flags in the function to indicate if an overflow has occurred. 
The possible flag values are:
.Pp
.Bd -literal -offset indent -compact
CHECKINT_NO_ERROR		no overflow has occurred
CHECKINT_OVERFLOW_ERROR		overflow has occurred
CHECKINT_TYPE_ERROR		operand is of an incompatible type
.Ed
.Pp
The
.Fa err
argument is not cleared in calls to the 
.Fn check_<type>_<operation> "x" "y" "err" 
functions.  Detected overflow persists in the 
.Fa err
argument until
.Fa err
is reset to CHECKINT_NO_ERROR.
.Sh RETURN VALUES
If successful, the
.Fn check_<type>_<operation> 
functions will return the arithmetic result of performing the operation with left operand
.Fa x
and right operand
.Fa y 
(even when overflow error occurs). 
.Pp
If any other error occurs, the return value is -1
and the argument
.Fa err
will be set to indicate the error.
.Sh EXAMPLES
.Bd -literal -offset indent
/* Create a variable to store overflow flag */
int32_t err = CHECKINT_NO_ERROR;
/* Use checkint API to perform an arithmetic operation and
 * store result in variable. */
int32_t arithmetic_result = check_int32_add(UINT_MAX, 1, &err);
/* Check status of overflow flag */
if (err & CHECKINT_OVERFLOW_ERROR) {
    /* Perform overflow resolution code */
    fprintf(stderr, "Overflow detected!\\n");
}
/* Check for type error */
else if (err & CHECKINT_TYPE_ERROR) {
    /* Deal with incompatible types error */
    fprintf(stderr, "Incompatible types!\\n");
}
/* Reset overflow flag for next operation */
err = CHECKINT_NO_ERROR;
 
.Ed
.Sh ERRORS
The 
.Fn check_<type>_<operation> 
functions may fail if:
.Pp
.Bd -literal -offset indent -compact
[CHECKINT_TYPE_ERROR]		operand is of an incompatible type
.Ed
.Sh HISTORY
The
.Fn checkint
API was introduced in Mac OS X 10.5.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/check_int64_mul.3                            0100644 0001750 0001750 00000007557 12566166265 023747  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 20, 2007
.Dt CHECK_INT32_ADD 3
.Os
.Sh NAME
.Nm check_int32_add ,
.Nm check_uint32_add ,
.Nm check_int64_add ,
.Nm check_uint64_add ,
.Nm check_int32_sub ,
.Nm check_uint32_sub ,
.Nm check_int64_sub ,
.Nm check_uint64_sub ,
.Nm check_int32_mul ,
.Nm check_uint32_mul ,
.Nm check_int64_mul ,
.Nm check_uint64_mul ,
.Nm check_int32_div ,
.Nm check_uint32_div ,
.Nm check_int64_div ,
.Nm check_uint64_div ,
.Nd detect overflow in arithmetic
.Sh SYNOPSIS
.In checkint.h
.Ft int32_t
.Fo check_int32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Sh DESCRIPTION
The
.Fn check_<type>_<operation> "x" "y" "err" 
family of functions perform the specified arithmetic operation (addition, subtraction, 
multiplication, or division) with the left operand of
.Fa x
and right operand of
.Fa y 
and return the arithmetic result with the specified type.   
.Pp
Either operand 
.Fa x
or 
.Fa y
(or both) can be of any type that is compatible to signed or unsigned
8-bit, 16-bit, 32-bit, or 64-bit integers.
.Pp
The
.Fa err
argument is 
.Em or Ns 'ed
by flags in the function to indicate if an overflow has occurred. 
The possible flag values are:
.Pp
.Bd -literal -offset indent -compact
CHECKINT_NO_ERROR		no overflow has occurred
CHECKINT_OVERFLOW_ERROR		overflow has occurred
CHECKINT_TYPE_ERROR		operand is of an incompatible type
.Ed
.Pp
The
.Fa err
argument is not cleared in calls to the 
.Fn check_<type>_<operation> "x" "y" "err" 
functions.  Detected overflow persists in the 
.Fa err
argument until
.Fa err
is reset to CHECKINT_NO_ERROR.
.Sh RETURN VALUES
If successful, the
.Fn check_<type>_<operation> 
functions will return the arithmetic result of performing the operation with left operand
.Fa x
and right operand
.Fa y 
(even when overflow error occurs). 
.Pp
If any other error occurs, the return value is -1
and the argument
.Fa err
will be set to indicate the error.
.Sh EXAMPLES
.Bd -literal -offset indent
/* Create a variable to store overflow flag */
int32_t err = CHECKINT_NO_ERROR;
/* Use checkint API to perform an arithmetic operation and
 * store result in variable. */
int32_t arithmetic_result = check_int32_add(UINT_MAX, 1, &err);
/* Check status of overflow flag */
if (err & CHECKINT_OVERFLOW_ERROR) {
    /* Perform overflow resolution code */
    fprintf(stderr, "Overflow detected!\\n");
}
/* Check for type error */
else if (err & CHECKINT_TYPE_ERROR) {
    /* Deal with incompatible types error */
    fprintf(stderr, "Incompatible types!\\n");
}
/* Reset overflow flag for next operation */
err = CHECKINT_NO_ERROR;
 
.Ed
.Sh ERRORS
The 
.Fn check_<type>_<operation> 
functions may fail if:
.Pp
.Bd -literal -offset indent -compact
[CHECKINT_TYPE_ERROR]		operand is of an incompatible type
.Ed
.Sh HISTORY
The
.Fn checkint
API was introduced in Mac OS X 10.5.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/check_int64_sub.3                            0100644 0001750 0001750 00000007557 12566166265 023743  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 20, 2007
.Dt CHECK_INT32_ADD 3
.Os
.Sh NAME
.Nm check_int32_add ,
.Nm check_uint32_add ,
.Nm check_int64_add ,
.Nm check_uint64_add ,
.Nm check_int32_sub ,
.Nm check_uint32_sub ,
.Nm check_int64_sub ,
.Nm check_uint64_sub ,
.Nm check_int32_mul ,
.Nm check_uint32_mul ,
.Nm check_int64_mul ,
.Nm check_uint64_mul ,
.Nm check_int32_div ,
.Nm check_uint32_div ,
.Nm check_int64_div ,
.Nm check_uint64_div ,
.Nd detect overflow in arithmetic
.Sh SYNOPSIS
.In checkint.h
.Ft int32_t
.Fo check_int32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Sh DESCRIPTION
The
.Fn check_<type>_<operation> "x" "y" "err" 
family of functions perform the specified arithmetic operation (addition, subtraction, 
multiplication, or division) with the left operand of
.Fa x
and right operand of
.Fa y 
and return the arithmetic result with the specified type.   
.Pp
Either operand 
.Fa x
or 
.Fa y
(or both) can be of any type that is compatible to signed or unsigned
8-bit, 16-bit, 32-bit, or 64-bit integers.
.Pp
The
.Fa err
argument is 
.Em or Ns 'ed
by flags in the function to indicate if an overflow has occurred. 
The possible flag values are:
.Pp
.Bd -literal -offset indent -compact
CHECKINT_NO_ERROR		no overflow has occurred
CHECKINT_OVERFLOW_ERROR		overflow has occurred
CHECKINT_TYPE_ERROR		operand is of an incompatible type
.Ed
.Pp
The
.Fa err
argument is not cleared in calls to the 
.Fn check_<type>_<operation> "x" "y" "err" 
functions.  Detected overflow persists in the 
.Fa err
argument until
.Fa err
is reset to CHECKINT_NO_ERROR.
.Sh RETURN VALUES
If successful, the
.Fn check_<type>_<operation> 
functions will return the arithmetic result of performing the operation with left operand
.Fa x
and right operand
.Fa y 
(even when overflow error occurs). 
.Pp
If any other error occurs, the return value is -1
and the argument
.Fa err
will be set to indicate the error.
.Sh EXAMPLES
.Bd -literal -offset indent
/* Create a variable to store overflow flag */
int32_t err = CHECKINT_NO_ERROR;
/* Use checkint API to perform an arithmetic operation and
 * store result in variable. */
int32_t arithmetic_result = check_int32_add(UINT_MAX, 1, &err);
/* Check status of overflow flag */
if (err & CHECKINT_OVERFLOW_ERROR) {
    /* Perform overflow resolution code */
    fprintf(stderr, "Overflow detected!\\n");
}
/* Check for type error */
else if (err & CHECKINT_TYPE_ERROR) {
    /* Deal with incompatible types error */
    fprintf(stderr, "Incompatible types!\\n");
}
/* Reset overflow flag for next operation */
err = CHECKINT_NO_ERROR;
 
.Ed
.Sh ERRORS
The 
.Fn check_<type>_<operation> 
functions may fail if:
.Pp
.Bd -literal -offset indent -compact
[CHECKINT_TYPE_ERROR]		operand is of an incompatible type
.Ed
.Sh HISTORY
The
.Fn checkint
API was introduced in Mac OS X 10.5.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/check_uint32_add.3                           0100644 0001750 0001750 00000007557 12566166265 024062  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 20, 2007
.Dt CHECK_INT32_ADD 3
.Os
.Sh NAME
.Nm check_int32_add ,
.Nm check_uint32_add ,
.Nm check_int64_add ,
.Nm check_uint64_add ,
.Nm check_int32_sub ,
.Nm check_uint32_sub ,
.Nm check_int64_sub ,
.Nm check_uint64_sub ,
.Nm check_int32_mul ,
.Nm check_uint32_mul ,
.Nm check_int64_mul ,
.Nm check_uint64_mul ,
.Nm check_int32_div ,
.Nm check_uint32_div ,
.Nm check_int64_div ,
.Nm check_uint64_div ,
.Nd detect overflow in arithmetic
.Sh SYNOPSIS
.In checkint.h
.Ft int32_t
.Fo check_int32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Sh DESCRIPTION
The
.Fn check_<type>_<operation> "x" "y" "err" 
family of functions perform the specified arithmetic operation (addition, subtraction, 
multiplication, or division) with the left operand of
.Fa x
and right operand of
.Fa y 
and return the arithmetic result with the specified type.   
.Pp
Either operand 
.Fa x
or 
.Fa y
(or both) can be of any type that is compatible to signed or unsigned
8-bit, 16-bit, 32-bit, or 64-bit integers.
.Pp
The
.Fa err
argument is 
.Em or Ns 'ed
by flags in the function to indicate if an overflow has occurred. 
The possible flag values are:
.Pp
.Bd -literal -offset indent -compact
CHECKINT_NO_ERROR		no overflow has occurred
CHECKINT_OVERFLOW_ERROR		overflow has occurred
CHECKINT_TYPE_ERROR		operand is of an incompatible type
.Ed
.Pp
The
.Fa err
argument is not cleared in calls to the 
.Fn check_<type>_<operation> "x" "y" "err" 
functions.  Detected overflow persists in the 
.Fa err
argument until
.Fa err
is reset to CHECKINT_NO_ERROR.
.Sh RETURN VALUES
If successful, the
.Fn check_<type>_<operation> 
functions will return the arithmetic result of performing the operation with left operand
.Fa x
and right operand
.Fa y 
(even when overflow error occurs). 
.Pp
If any other error occurs, the return value is -1
and the argument
.Fa err
will be set to indicate the error.
.Sh EXAMPLES
.Bd -literal -offset indent
/* Create a variable to store overflow flag */
int32_t err = CHECKINT_NO_ERROR;
/* Use checkint API to perform an arithmetic operation and
 * store result in variable. */
int32_t arithmetic_result = check_int32_add(UINT_MAX, 1, &err);
/* Check status of overflow flag */
if (err & CHECKINT_OVERFLOW_ERROR) {
    /* Perform overflow resolution code */
    fprintf(stderr, "Overflow detected!\\n");
}
/* Check for type error */
else if (err & CHECKINT_TYPE_ERROR) {
    /* Deal with incompatible types error */
    fprintf(stderr, "Incompatible types!\\n");
}
/* Reset overflow flag for next operation */
err = CHECKINT_NO_ERROR;
 
.Ed
.Sh ERRORS
The 
.Fn check_<type>_<operation> 
functions may fail if:
.Pp
.Bd -literal -offset indent -compact
[CHECKINT_TYPE_ERROR]		operand is of an incompatible type
.Ed
.Sh HISTORY
The
.Fn checkint
API was introduced in Mac OS X 10.5.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/check_uint32_div.3                           0100644 0001750 0001750 00000007557 12566166265 024114  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 20, 2007
.Dt CHECK_INT32_ADD 3
.Os
.Sh NAME
.Nm check_int32_add ,
.Nm check_uint32_add ,
.Nm check_int64_add ,
.Nm check_uint64_add ,
.Nm check_int32_sub ,
.Nm check_uint32_sub ,
.Nm check_int64_sub ,
.Nm check_uint64_sub ,
.Nm check_int32_mul ,
.Nm check_uint32_mul ,
.Nm check_int64_mul ,
.Nm check_uint64_mul ,
.Nm check_int32_div ,
.Nm check_uint32_div ,
.Nm check_int64_div ,
.Nm check_uint64_div ,
.Nd detect overflow in arithmetic
.Sh SYNOPSIS
.In checkint.h
.Ft int32_t
.Fo check_int32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Sh DESCRIPTION
The
.Fn check_<type>_<operation> "x" "y" "err" 
family of functions perform the specified arithmetic operation (addition, subtraction, 
multiplication, or division) with the left operand of
.Fa x
and right operand of
.Fa y 
and return the arithmetic result with the specified type.   
.Pp
Either operand 
.Fa x
or 
.Fa y
(or both) can be of any type that is compatible to signed or unsigned
8-bit, 16-bit, 32-bit, or 64-bit integers.
.Pp
The
.Fa err
argument is 
.Em or Ns 'ed
by flags in the function to indicate if an overflow has occurred. 
The possible flag values are:
.Pp
.Bd -literal -offset indent -compact
CHECKINT_NO_ERROR		no overflow has occurred
CHECKINT_OVERFLOW_ERROR		overflow has occurred
CHECKINT_TYPE_ERROR		operand is of an incompatible type
.Ed
.Pp
The
.Fa err
argument is not cleared in calls to the 
.Fn check_<type>_<operation> "x" "y" "err" 
functions.  Detected overflow persists in the 
.Fa err
argument until
.Fa err
is reset to CHECKINT_NO_ERROR.
.Sh RETURN VALUES
If successful, the
.Fn check_<type>_<operation> 
functions will return the arithmetic result of performing the operation with left operand
.Fa x
and right operand
.Fa y 
(even when overflow error occurs). 
.Pp
If any other error occurs, the return value is -1
and the argument
.Fa err
will be set to indicate the error.
.Sh EXAMPLES
.Bd -literal -offset indent
/* Create a variable to store overflow flag */
int32_t err = CHECKINT_NO_ERROR;
/* Use checkint API to perform an arithmetic operation and
 * store result in variable. */
int32_t arithmetic_result = check_int32_add(UINT_MAX, 1, &err);
/* Check status of overflow flag */
if (err & CHECKINT_OVERFLOW_ERROR) {
    /* Perform overflow resolution code */
    fprintf(stderr, "Overflow detected!\\n");
}
/* Check for type error */
else if (err & CHECKINT_TYPE_ERROR) {
    /* Deal with incompatible types error */
    fprintf(stderr, "Incompatible types!\\n");
}
/* Reset overflow flag for next operation */
err = CHECKINT_NO_ERROR;
 
.Ed
.Sh ERRORS
The 
.Fn check_<type>_<operation> 
functions may fail if:
.Pp
.Bd -literal -offset indent -compact
[CHECKINT_TYPE_ERROR]		operand is of an incompatible type
.Ed
.Sh HISTORY
The
.Fn checkint
API was introduced in Mac OS X 10.5.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/check_uint32_mul.3                           0100644 0001750 0001750 00000007557 12566166265 024127  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 20, 2007
.Dt CHECK_INT32_ADD 3
.Os
.Sh NAME
.Nm check_int32_add ,
.Nm check_uint32_add ,
.Nm check_int64_add ,
.Nm check_uint64_add ,
.Nm check_int32_sub ,
.Nm check_uint32_sub ,
.Nm check_int64_sub ,
.Nm check_uint64_sub ,
.Nm check_int32_mul ,
.Nm check_uint32_mul ,
.Nm check_int64_mul ,
.Nm check_uint64_mul ,
.Nm check_int32_div ,
.Nm check_uint32_div ,
.Nm check_int64_div ,
.Nm check_uint64_div ,
.Nd detect overflow in arithmetic
.Sh SYNOPSIS
.In checkint.h
.Ft int32_t
.Fo check_int32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Sh DESCRIPTION
The
.Fn check_<type>_<operation> "x" "y" "err" 
family of functions perform the specified arithmetic operation (addition, subtraction, 
multiplication, or division) with the left operand of
.Fa x
and right operand of
.Fa y 
and return the arithmetic result with the specified type.   
.Pp
Either operand 
.Fa x
or 
.Fa y
(or both) can be of any type that is compatible to signed or unsigned
8-bit, 16-bit, 32-bit, or 64-bit integers.
.Pp
The
.Fa err
argument is 
.Em or Ns 'ed
by flags in the function to indicate if an overflow has occurred. 
The possible flag values are:
.Pp
.Bd -literal -offset indent -compact
CHECKINT_NO_ERROR		no overflow has occurred
CHECKINT_OVERFLOW_ERROR		overflow has occurred
CHECKINT_TYPE_ERROR		operand is of an incompatible type
.Ed
.Pp
The
.Fa err
argument is not cleared in calls to the 
.Fn check_<type>_<operation> "x" "y" "err" 
functions.  Detected overflow persists in the 
.Fa err
argument until
.Fa err
is reset to CHECKINT_NO_ERROR.
.Sh RETURN VALUES
If successful, the
.Fn check_<type>_<operation> 
functions will return the arithmetic result of performing the operation with left operand
.Fa x
and right operand
.Fa y 
(even when overflow error occurs). 
.Pp
If any other error occurs, the return value is -1
and the argument
.Fa err
will be set to indicate the error.
.Sh EXAMPLES
.Bd -literal -offset indent
/* Create a variable to store overflow flag */
int32_t err = CHECKINT_NO_ERROR;
/* Use checkint API to perform an arithmetic operation and
 * store result in variable. */
int32_t arithmetic_result = check_int32_add(UINT_MAX, 1, &err);
/* Check status of overflow flag */
if (err & CHECKINT_OVERFLOW_ERROR) {
    /* Perform overflow resolution code */
    fprintf(stderr, "Overflow detected!\\n");
}
/* Check for type error */
else if (err & CHECKINT_TYPE_ERROR) {
    /* Deal with incompatible types error */
    fprintf(stderr, "Incompatible types!\\n");
}
/* Reset overflow flag for next operation */
err = CHECKINT_NO_ERROR;
 
.Ed
.Sh ERRORS
The 
.Fn check_<type>_<operation> 
functions may fail if:
.Pp
.Bd -literal -offset indent -compact
[CHECKINT_TYPE_ERROR]		operand is of an incompatible type
.Ed
.Sh HISTORY
The
.Fn checkint
API was introduced in Mac OS X 10.5.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/check_uint32_sub.3                           0100644 0001750 0001750 00000007557 12566166265 024123  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 20, 2007
.Dt CHECK_INT32_ADD 3
.Os
.Sh NAME
.Nm check_int32_add ,
.Nm check_uint32_add ,
.Nm check_int64_add ,
.Nm check_uint64_add ,
.Nm check_int32_sub ,
.Nm check_uint32_sub ,
.Nm check_int64_sub ,
.Nm check_uint64_sub ,
.Nm check_int32_mul ,
.Nm check_uint32_mul ,
.Nm check_int64_mul ,
.Nm check_uint64_mul ,
.Nm check_int32_div ,
.Nm check_uint32_div ,
.Nm check_int64_div ,
.Nm check_uint64_div ,
.Nd detect overflow in arithmetic
.Sh SYNOPSIS
.In checkint.h
.Ft int32_t
.Fo check_int32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Sh DESCRIPTION
The
.Fn check_<type>_<operation> "x" "y" "err" 
family of functions perform the specified arithmetic operation (addition, subtraction, 
multiplication, or division) with the left operand of
.Fa x
and right operand of
.Fa y 
and return the arithmetic result with the specified type.   
.Pp
Either operand 
.Fa x
or 
.Fa y
(or both) can be of any type that is compatible to signed or unsigned
8-bit, 16-bit, 32-bit, or 64-bit integers.
.Pp
The
.Fa err
argument is 
.Em or Ns 'ed
by flags in the function to indicate if an overflow has occurred. 
The possible flag values are:
.Pp
.Bd -literal -offset indent -compact
CHECKINT_NO_ERROR		no overflow has occurred
CHECKINT_OVERFLOW_ERROR		overflow has occurred
CHECKINT_TYPE_ERROR		operand is of an incompatible type
.Ed
.Pp
The
.Fa err
argument is not cleared in calls to the 
.Fn check_<type>_<operation> "x" "y" "err" 
functions.  Detected overflow persists in the 
.Fa err
argument until
.Fa err
is reset to CHECKINT_NO_ERROR.
.Sh RETURN VALUES
If successful, the
.Fn check_<type>_<operation> 
functions will return the arithmetic result of performing the operation with left operand
.Fa x
and right operand
.Fa y 
(even when overflow error occurs). 
.Pp
If any other error occurs, the return value is -1
and the argument
.Fa err
will be set to indicate the error.
.Sh EXAMPLES
.Bd -literal -offset indent
/* Create a variable to store overflow flag */
int32_t err = CHECKINT_NO_ERROR;
/* Use checkint API to perform an arithmetic operation and
 * store result in variable. */
int32_t arithmetic_result = check_int32_add(UINT_MAX, 1, &err);
/* Check status of overflow flag */
if (err & CHECKINT_OVERFLOW_ERROR) {
    /* Perform overflow resolution code */
    fprintf(stderr, "Overflow detected!\\n");
}
/* Check for type error */
else if (err & CHECKINT_TYPE_ERROR) {
    /* Deal with incompatible types error */
    fprintf(stderr, "Incompatible types!\\n");
}
/* Reset overflow flag for next operation */
err = CHECKINT_NO_ERROR;
 
.Ed
.Sh ERRORS
The 
.Fn check_<type>_<operation> 
functions may fail if:
.Pp
.Bd -literal -offset indent -compact
[CHECKINT_TYPE_ERROR]		operand is of an incompatible type
.Ed
.Sh HISTORY
The
.Fn checkint
API was introduced in Mac OS X 10.5.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/check_uint64_add.3                           0100644 0001750 0001750 00000007557 12566166265 024067  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 20, 2007
.Dt CHECK_INT32_ADD 3
.Os
.Sh NAME
.Nm check_int32_add ,
.Nm check_uint32_add ,
.Nm check_int64_add ,
.Nm check_uint64_add ,
.Nm check_int32_sub ,
.Nm check_uint32_sub ,
.Nm check_int64_sub ,
.Nm check_uint64_sub ,
.Nm check_int32_mul ,
.Nm check_uint32_mul ,
.Nm check_int64_mul ,
.Nm check_uint64_mul ,
.Nm check_int32_div ,
.Nm check_uint32_div ,
.Nm check_int64_div ,
.Nm check_uint64_div ,
.Nd detect overflow in arithmetic
.Sh SYNOPSIS
.In checkint.h
.Ft int32_t
.Fo check_int32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Sh DESCRIPTION
The
.Fn check_<type>_<operation> "x" "y" "err" 
family of functions perform the specified arithmetic operation (addition, subtraction, 
multiplication, or division) with the left operand of
.Fa x
and right operand of
.Fa y 
and return the arithmetic result with the specified type.   
.Pp
Either operand 
.Fa x
or 
.Fa y
(or both) can be of any type that is compatible to signed or unsigned
8-bit, 16-bit, 32-bit, or 64-bit integers.
.Pp
The
.Fa err
argument is 
.Em or Ns 'ed
by flags in the function to indicate if an overflow has occurred. 
The possible flag values are:
.Pp
.Bd -literal -offset indent -compact
CHECKINT_NO_ERROR		no overflow has occurred
CHECKINT_OVERFLOW_ERROR		overflow has occurred
CHECKINT_TYPE_ERROR		operand is of an incompatible type
.Ed
.Pp
The
.Fa err
argument is not cleared in calls to the 
.Fn check_<type>_<operation> "x" "y" "err" 
functions.  Detected overflow persists in the 
.Fa err
argument until
.Fa err
is reset to CHECKINT_NO_ERROR.
.Sh RETURN VALUES
If successful, the
.Fn check_<type>_<operation> 
functions will return the arithmetic result of performing the operation with left operand
.Fa x
and right operand
.Fa y 
(even when overflow error occurs). 
.Pp
If any other error occurs, the return value is -1
and the argument
.Fa err
will be set to indicate the error.
.Sh EXAMPLES
.Bd -literal -offset indent
/* Create a variable to store overflow flag */
int32_t err = CHECKINT_NO_ERROR;
/* Use checkint API to perform an arithmetic operation and
 * store result in variable. */
int32_t arithmetic_result = check_int32_add(UINT_MAX, 1, &err);
/* Check status of overflow flag */
if (err & CHECKINT_OVERFLOW_ERROR) {
    /* Perform overflow resolution code */
    fprintf(stderr, "Overflow detected!\\n");
}
/* Check for type error */
else if (err & CHECKINT_TYPE_ERROR) {
    /* Deal with incompatible types error */
    fprintf(stderr, "Incompatible types!\\n");
}
/* Reset overflow flag for next operation */
err = CHECKINT_NO_ERROR;
 
.Ed
.Sh ERRORS
The 
.Fn check_<type>_<operation> 
functions may fail if:
.Pp
.Bd -literal -offset indent -compact
[CHECKINT_TYPE_ERROR]		operand is of an incompatible type
.Ed
.Sh HISTORY
The
.Fn checkint
API was introduced in Mac OS X 10.5.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/check_uint64_div.3                           0100644 0001750 0001750 00000007557 12566166265 024121  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 20, 2007
.Dt CHECK_INT32_ADD 3
.Os
.Sh NAME
.Nm check_int32_add ,
.Nm check_uint32_add ,
.Nm check_int64_add ,
.Nm check_uint64_add ,
.Nm check_int32_sub ,
.Nm check_uint32_sub ,
.Nm check_int64_sub ,
.Nm check_uint64_sub ,
.Nm check_int32_mul ,
.Nm check_uint32_mul ,
.Nm check_int64_mul ,
.Nm check_uint64_mul ,
.Nm check_int32_div ,
.Nm check_uint32_div ,
.Nm check_int64_div ,
.Nm check_uint64_div ,
.Nd detect overflow in arithmetic
.Sh SYNOPSIS
.In checkint.h
.Ft int32_t
.Fo check_int32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Sh DESCRIPTION
The
.Fn check_<type>_<operation> "x" "y" "err" 
family of functions perform the specified arithmetic operation (addition, subtraction, 
multiplication, or division) with the left operand of
.Fa x
and right operand of
.Fa y 
and return the arithmetic result with the specified type.   
.Pp
Either operand 
.Fa x
or 
.Fa y
(or both) can be of any type that is compatible to signed or unsigned
8-bit, 16-bit, 32-bit, or 64-bit integers.
.Pp
The
.Fa err
argument is 
.Em or Ns 'ed
by flags in the function to indicate if an overflow has occurred. 
The possible flag values are:
.Pp
.Bd -literal -offset indent -compact
CHECKINT_NO_ERROR		no overflow has occurred
CHECKINT_OVERFLOW_ERROR		overflow has occurred
CHECKINT_TYPE_ERROR		operand is of an incompatible type
.Ed
.Pp
The
.Fa err
argument is not cleared in calls to the 
.Fn check_<type>_<operation> "x" "y" "err" 
functions.  Detected overflow persists in the 
.Fa err
argument until
.Fa err
is reset to CHECKINT_NO_ERROR.
.Sh RETURN VALUES
If successful, the
.Fn check_<type>_<operation> 
functions will return the arithmetic result of performing the operation with left operand
.Fa x
and right operand
.Fa y 
(even when overflow error occurs). 
.Pp
If any other error occurs, the return value is -1
and the argument
.Fa err
will be set to indicate the error.
.Sh EXAMPLES
.Bd -literal -offset indent
/* Create a variable to store overflow flag */
int32_t err = CHECKINT_NO_ERROR;
/* Use checkint API to perform an arithmetic operation and
 * store result in variable. */
int32_t arithmetic_result = check_int32_add(UINT_MAX, 1, &err);
/* Check status of overflow flag */
if (err & CHECKINT_OVERFLOW_ERROR) {
    /* Perform overflow resolution code */
    fprintf(stderr, "Overflow detected!\\n");
}
/* Check for type error */
else if (err & CHECKINT_TYPE_ERROR) {
    /* Deal with incompatible types error */
    fprintf(stderr, "Incompatible types!\\n");
}
/* Reset overflow flag for next operation */
err = CHECKINT_NO_ERROR;
 
.Ed
.Sh ERRORS
The 
.Fn check_<type>_<operation> 
functions may fail if:
.Pp
.Bd -literal -offset indent -compact
[CHECKINT_TYPE_ERROR]		operand is of an incompatible type
.Ed
.Sh HISTORY
The
.Fn checkint
API was introduced in Mac OS X 10.5.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/check_uint64_mul.3                           0100644 0001750 0001750 00000007557 12566166265 024134  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 20, 2007
.Dt CHECK_INT32_ADD 3
.Os
.Sh NAME
.Nm check_int32_add ,
.Nm check_uint32_add ,
.Nm check_int64_add ,
.Nm check_uint64_add ,
.Nm check_int32_sub ,
.Nm check_uint32_sub ,
.Nm check_int64_sub ,
.Nm check_uint64_sub ,
.Nm check_int32_mul ,
.Nm check_uint32_mul ,
.Nm check_int64_mul ,
.Nm check_uint64_mul ,
.Nm check_int32_div ,
.Nm check_uint32_div ,
.Nm check_int64_div ,
.Nm check_uint64_div ,
.Nd detect overflow in arithmetic
.Sh SYNOPSIS
.In checkint.h
.Ft int32_t
.Fo check_int32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Sh DESCRIPTION
The
.Fn check_<type>_<operation> "x" "y" "err" 
family of functions perform the specified arithmetic operation (addition, subtraction, 
multiplication, or division) with the left operand of
.Fa x
and right operand of
.Fa y 
and return the arithmetic result with the specified type.   
.Pp
Either operand 
.Fa x
or 
.Fa y
(or both) can be of any type that is compatible to signed or unsigned
8-bit, 16-bit, 32-bit, or 64-bit integers.
.Pp
The
.Fa err
argument is 
.Em or Ns 'ed
by flags in the function to indicate if an overflow has occurred. 
The possible flag values are:
.Pp
.Bd -literal -offset indent -compact
CHECKINT_NO_ERROR		no overflow has occurred
CHECKINT_OVERFLOW_ERROR		overflow has occurred
CHECKINT_TYPE_ERROR		operand is of an incompatible type
.Ed
.Pp
The
.Fa err
argument is not cleared in calls to the 
.Fn check_<type>_<operation> "x" "y" "err" 
functions.  Detected overflow persists in the 
.Fa err
argument until
.Fa err
is reset to CHECKINT_NO_ERROR.
.Sh RETURN VALUES
If successful, the
.Fn check_<type>_<operation> 
functions will return the arithmetic result of performing the operation with left operand
.Fa x
and right operand
.Fa y 
(even when overflow error occurs). 
.Pp
If any other error occurs, the return value is -1
and the argument
.Fa err
will be set to indicate the error.
.Sh EXAMPLES
.Bd -literal -offset indent
/* Create a variable to store overflow flag */
int32_t err = CHECKINT_NO_ERROR;
/* Use checkint API to perform an arithmetic operation and
 * store result in variable. */
int32_t arithmetic_result = check_int32_add(UINT_MAX, 1, &err);
/* Check status of overflow flag */
if (err & CHECKINT_OVERFLOW_ERROR) {
    /* Perform overflow resolution code */
    fprintf(stderr, "Overflow detected!\\n");
}
/* Check for type error */
else if (err & CHECKINT_TYPE_ERROR) {
    /* Deal with incompatible types error */
    fprintf(stderr, "Incompatible types!\\n");
}
/* Reset overflow flag for next operation */
err = CHECKINT_NO_ERROR;
 
.Ed
.Sh ERRORS
The 
.Fn check_<type>_<operation> 
functions may fail if:
.Pp
.Bd -literal -offset indent -compact
[CHECKINT_TYPE_ERROR]		operand is of an incompatible type
.Ed
.Sh HISTORY
The
.Fn checkint
API was introduced in Mac OS X 10.5.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/check_uint64_sub.3                           0100644 0001750 0001750 00000007557 12566166265 024130  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 20, 2007
.Dt CHECK_INT32_ADD 3
.Os
.Sh NAME
.Nm check_int32_add ,
.Nm check_uint32_add ,
.Nm check_int64_add ,
.Nm check_uint64_add ,
.Nm check_int32_sub ,
.Nm check_uint32_sub ,
.Nm check_int64_sub ,
.Nm check_uint64_sub ,
.Nm check_int32_mul ,
.Nm check_uint32_mul ,
.Nm check_int64_mul ,
.Nm check_uint64_mul ,
.Nm check_int32_div ,
.Nm check_uint32_div ,
.Nm check_int64_div ,
.Nm check_uint64_div ,
.Nd detect overflow in arithmetic
.Sh SYNOPSIS
.In checkint.h
.Ft int32_t
.Fo check_int32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Sh DESCRIPTION
The
.Fn check_<type>_<operation> "x" "y" "err" 
family of functions perform the specified arithmetic operation (addition, subtraction, 
multiplication, or division) with the left operand of
.Fa x
and right operand of
.Fa y 
and return the arithmetic result with the specified type.   
.Pp
Either operand 
.Fa x
or 
.Fa y
(or both) can be of any type that is compatible to signed or unsigned
8-bit, 16-bit, 32-bit, or 64-bit integers.
.Pp
The
.Fa err
argument is 
.Em or Ns 'ed
by flags in the function to indicate if an overflow has occurred. 
The possible flag values are:
.Pp
.Bd -literal -offset indent -compact
CHECKINT_NO_ERROR		no overflow has occurred
CHECKINT_OVERFLOW_ERROR		overflow has occurred
CHECKINT_TYPE_ERROR		operand is of an incompatible type
.Ed
.Pp
The
.Fa err
argument is not cleared in calls to the 
.Fn check_<type>_<operation> "x" "y" "err" 
functions.  Detected overflow persists in the 
.Fa err
argument until
.Fa err
is reset to CHECKINT_NO_ERROR.
.Sh RETURN VALUES
If successful, the
.Fn check_<type>_<operation> 
functions will return the arithmetic result of performing the operation with left operand
.Fa x
and right operand
.Fa y 
(even when overflow error occurs). 
.Pp
If any other error occurs, the return value is -1
and the argument
.Fa err
will be set to indicate the error.
.Sh EXAMPLES
.Bd -literal -offset indent
/* Create a variable to store overflow flag */
int32_t err = CHECKINT_NO_ERROR;
/* Use checkint API to perform an arithmetic operation and
 * store result in variable. */
int32_t arithmetic_result = check_int32_add(UINT_MAX, 1, &err);
/* Check status of overflow flag */
if (err & CHECKINT_OVERFLOW_ERROR) {
    /* Perform overflow resolution code */
    fprintf(stderr, "Overflow detected!\\n");
}
/* Check for type error */
else if (err & CHECKINT_TYPE_ERROR) {
    /* Deal with incompatible types error */
    fprintf(stderr, "Incompatible types!\\n");
}
/* Reset overflow flag for next operation */
err = CHECKINT_NO_ERROR;
 
.Ed
.Sh ERRORS
The 
.Fn check_<type>_<operation> 
functions may fail if:
.Pp
.Bd -literal -offset indent -compact
[CHECKINT_TYPE_ERROR]		operand is of an incompatible type
.Ed
.Sh HISTORY
The
.Fn checkint
API was introduced in Mac OS X 10.5.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/checkint.3                                   0100644 0001750 0001750 00000007557 12566166265 022561  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 20, 2007
.Dt CHECK_INT32_ADD 3
.Os
.Sh NAME
.Nm check_int32_add ,
.Nm check_uint32_add ,
.Nm check_int64_add ,
.Nm check_uint64_add ,
.Nm check_int32_sub ,
.Nm check_uint32_sub ,
.Nm check_int64_sub ,
.Nm check_uint64_sub ,
.Nm check_int32_mul ,
.Nm check_uint32_mul ,
.Nm check_int64_mul ,
.Nm check_uint64_mul ,
.Nm check_int32_div ,
.Nm check_uint32_div ,
.Nm check_int64_div ,
.Nm check_uint64_div ,
.Nd detect overflow in arithmetic
.Sh SYNOPSIS
.In checkint.h
.Ft int32_t
.Fo check_int32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_add
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_sub
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_mul
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int32_t
.Fo check_int32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint32_t
.Fo check_uint32_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft int64_t
.Fo check_int64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Ft uint64_t
.Fo check_uint64_div
.Fa "int x"
.Fa "int y"
.Fa "int *err" 
.Fc
.Sh DESCRIPTION
The
.Fn check_<type>_<operation> "x" "y" "err" 
family of functions perform the specified arithmetic operation (addition, subtraction, 
multiplication, or division) with the left operand of
.Fa x
and right operand of
.Fa y 
and return the arithmetic result with the specified type.   
.Pp
Either operand 
.Fa x
or 
.Fa y
(or both) can be of any type that is compatible to signed or unsigned
8-bit, 16-bit, 32-bit, or 64-bit integers.
.Pp
The
.Fa err
argument is 
.Em or Ns 'ed
by flags in the function to indicate if an overflow has occurred. 
The possible flag values are:
.Pp
.Bd -literal -offset indent -compact
CHECKINT_NO_ERROR		no overflow has occurred
CHECKINT_OVERFLOW_ERROR		overflow has occurred
CHECKINT_TYPE_ERROR		operand is of an incompatible type
.Ed
.Pp
The
.Fa err
argument is not cleared in calls to the 
.Fn check_<type>_<operation> "x" "y" "err" 
functions.  Detected overflow persists in the 
.Fa err
argument until
.Fa err
is reset to CHECKINT_NO_ERROR.
.Sh RETURN VALUES
If successful, the
.Fn check_<type>_<operation> 
functions will return the arithmetic result of performing the operation with left operand
.Fa x
and right operand
.Fa y 
(even when overflow error occurs). 
.Pp
If any other error occurs, the return value is -1
and the argument
.Fa err
will be set to indicate the error.
.Sh EXAMPLES
.Bd -literal -offset indent
/* Create a variable to store overflow flag */
int32_t err = CHECKINT_NO_ERROR;
/* Use checkint API to perform an arithmetic operation and
 * store result in variable. */
int32_t arithmetic_result = check_int32_add(UINT_MAX, 1, &err);
/* Check status of overflow flag */
if (err & CHECKINT_OVERFLOW_ERROR) {
    /* Perform overflow resolution code */
    fprintf(stderr, "Overflow detected!\\n");
}
/* Check for type error */
else if (err & CHECKINT_TYPE_ERROR) {
    /* Deal with incompatible types error */
    fprintf(stderr, "Incompatible types!\\n");
}
/* Reset overflow flag for next operation */
err = CHECKINT_NO_ERROR;
 
.Ed
.Sh ERRORS
The 
.Fn check_<type>_<operation> 
functions may fail if:
.Pp
.Bd -literal -offset indent -compact
[CHECKINT_TYPE_ERROR]		operand is of an incompatible type
.Ed
.Sh HISTORY
The
.Fn checkint
API was introduced in Mac OS X 10.5.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/chgat.3x                                     0100644 0001750 0001750 00000025201 12566174415 022225  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\" t
.\"***************************************************************************
.\" Copyright (c) 1998-2006,2007 Free Software Foundation, Inc.              *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, to any person obtaining a  *
.\" copy of this software and associated documentation files (the            *
.\" "Software"), to deal in the Software without restriction, including      *
.\" without limitation the rights to use, copy, modify, merge, publish,      *
.\" distribute, distribute with modifications, sublicense, and/or sell       *
.\" copies of the Software, and to permit persons to whom the Software is    *
.\" furnished to do so, subject to the following conditions:                 *
.\"                                                                          *
.\" The above copyright notice and this permission notice shall be included  *
.\" in all copies or substantial portions of the Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained in this notice, the name(s) of the above copyright   *
.\" holders shall not be used in advertising or otherwise to promote the     *
.\" sale, use or other dealings in this Software without prior written       *
.\" authorization.                                                           *
.\"***************************************************************************
.\"
.\" $Id: curs_attr.3x,v 1.31 2007/03/17 20:30:33 tom Exp $
.TH curs_attr 3X ""
.na
.hy 0
.SH NAME
\fBattroff\fR,
\fBwattroff\fR,
\fBattron\fR,
\fBwattron\fR,
\fBattrset\fR,
\fBwattrset\fR,
\fBcolor_set\fR,
\fBwcolor_set\fR,
\fBstandend\fR,
\fBwstandend\fR,
\fBstandout\fR,
\fBwstandout\fR,
\fBattr_get\fR,
\fBwattr_get\fR,
\fBattr_off\fR,
\fBwattr_off\fR,
\fBattr_on\fR,
\fBwattr_on\fR,
\fBattr_set\fR,
\fBwattr_set\fR,
\fBchgat\fR,
\fBwchgat\fR,
\fBmvchgat\fR,
\fBmvwchgat\fR,
\fBPAIR_NUMBER\fR - \fBcurses\fR character and window attribute control routines
.ad
.hy
.SH SYNOPSIS
\fB#include <curses.h>\fR
.br
\fBint attroff(int attrs);\fR
.br
\fBint wattroff(WINDOW *win, int attrs);\fR
.br
\fBint attron(int attrs);\fR
.br
\fBint wattron(WINDOW *win, int attrs);\fR
.br
\fBint attrset(int attrs);\fR
.br
\fBint wattrset(WINDOW *win, int attrs);\fR
.br
\fBint color_set(short color_pair_number, void* opts);\fR
.br
\fBint wcolor_set(WINDOW *win, short color_pair_number,\fR
      \fBvoid* opts);\fR
.br
\fBint standend(void);\fR
.br
\fBint wstandend(WINDOW *win);\fR
.br
\fBint standout(void);\fR
.br
\fBint wstandout(WINDOW *win);\fR
.br
\fBint attr_get(attr_t *attrs, short *pair, void *opts);\fR
.br
\fBint wattr_get(WINDOW *win, attr_t *attrs, short *pair,\fR
       \fBvoid *opts);\fR
.br
\fBint attr_off(attr_t attrs, void *opts);\fR
.br
\fBint wattr_off(WINDOW *win, attr_t attrs, void *opts);\fR
.br
\fBint attr_on(attr_t attrs, void *opts);\fR
.br
\fBint wattr_on(WINDOW *win, attr_t attrs, void *opts);\fR
.br
\fBint attr_set(attr_t attrs, short pair, void *opts);\fR
.br
\fBint wattr_set(WINDOW *win, attr_t attrs, short pair, void *opts);\fR
.br
\fBint chgat(int n, attr_t attr, short color,\fR
      \fBconst void *opts)\fR
.br
\fBint wchgat(WINDOW *win, int n, attr_t attr,\fR
      \fBshort color, const void *opts)\fR
.br
\fBint mvchgat(int y, int x, int n, attr_t attr,\fR
      \fBshort color, const void *opts)\fR
.br
\fBint mvwchgat(WINDOW *win, int y, int x, int n,\fR
      \fBattr_t attr, short color, const void *opts)\fR
.br
.SH DESCRIPTION
These routines manipulate the current attributes of the named window.  The
current attributes of a window apply to all characters that are written into
the window with \fBwaddch\fR, \fBwaddstr\fR and \fBwprintw\fR.  Attributes are
a property of the character, and move with the character through any scrolling
and insert/delete line/character operations.  To the extent possible, they are
displayed as appropriate modifications to the graphic rendition of characters
put on the screen.
.PP
The routine \fBattrset\fR sets the current attributes of the given window to
\fIattrs\fR.  The routine \fBattroff\fR turns off the named attributes without
turning any other attributes on or off.  The routine \fBattron\fR turns on the
named attributes without affecting any others.  The routine \fBstandout\fR is
the same as \fBattron(A_STANDOUT)\fR.  The routine \fBstandend\fR is the same
as \fBattrset(A_NORMAL)\fR or \fBattrset(0)\fR, that is, it turns off all
attributes.
.PP
The \fBattrset\fR and related routines do not affect the attributes used
when erasing portions of the window.
See \fBcurs_bkgd\fR(3X) for functions which modify the attributes used for
erasing and clearing.
.PP
The routine \fBcolor_set\fR sets the current color of the given window to the
foreground/background combination described by the color_pair_number. The
parameter opts is reserved for future use, applications must supply a null
pointer.
.PP
The routine \fBwattr_get\fR returns the current attribute and color pair for
the given window; \fBattr_get\fR returns the current attribute and color pair
for \fBstdscr\fR.
The remaining \fBattr_\fR* functions operate exactly like the corresponding
\fBattr\fR* functions, except that they take arguments of type \fBattr_t\fR
rather than \fBint\fR.
.PP
The routine \fBchgat\fR changes the attributes of a given number of characters
starting at the current cursor location of \fBstdscr\fR.  It does not update
the cursor and does not perform wrapping.  A character count of -1 or greater
than the remaining window width means to change attributes all the way to the
end of the current line.  The \fBwchgat\fR function generalizes this to any
window; the \fBmvwchgat\fR function does a cursor move before acting.  In these
functions, the color argument is a color-pair index (as in the first argument
of \fIinit_pair\fR, see \fBcurs_color\fR(3X)).  The \fBopts\fR argument is not
presently used, but is reserved for the future (leave it \fBNULL\fR).
.SS Attributes
The following video attributes, defined in \fB<curses.h>\fR, can be passed to
the routines \fBattron\fR, \fBattroff\fR, and \fBattrset\fR, or OR'd with the
characters passed to \fBaddch\fR.
.PP
.TS
center ;
l l .
\fBA_NORMAL\fR	Normal display (no highlight)
\fBA_STANDOUT\fR	Best highlighting mode of the terminal.
\fBA_UNDERLINE\fR	Underlining
\fBA_REVERSE\fR	Reverse video
\fBA_BLINK\fR	Blinking
\fBA_DIM\fR	Half bright
\fBA_BOLD\fR	Extra bright or bold
\fBA_PROTECT\fR	Protected mode
\fBA_INVIS\fR	Invisible or blank mode
\fBA_ALTCHARSET\fR	Alternate character set
\fBA_CHARTEXT\fR	Bit-mask to extract a character
\fBCOLOR_PAIR(\fR\fIn\fR\fB)\fR	Color-pair number \fIn\fR
.TE
.PP
The following macro is the reverse of \fBCOLOR_PAIR(\fR\fIn\fR\fB)\fR:
.PP
.br
\fBPAIR_NUMBER(\fR\fIattrs\fR) Returns the pair number associated
                   with the \fBCOLOR_PAIR(\fR\fIn\fR\fB)\fR attribute.
.br
.PP
The return values of many of these routines are not meaningful (they are
implemented as macro-expanded assignments and simply return their argument).
The SVr4 manual page claims (falsely) that these routines always return \fB1\fR.
.SH NOTES
Note that \fBattroff\fR, \fBwattroff\fR, \fBattron\fR, \fBwattron\fR,
\fBattrset\fR, \fBwattrset\fR, \fBstandend\fR and \fBstandout\fR may be macros.
.PP
\fBCOLOR_PAIR\fP values can only be OR'd with attributes if the pair
number is less than 256.
The alternate functions such as \fBcolor_set\fP can pass a color pair
value directly.
However, ncurses ABI 4 and 5 simply OR this value within the alternate functions.
You must use ncurses ABI 6 to support more than 256 color pairs.
.SH PORTABILITY
These functions are supported in the XSI Curses standard, Issue 4.  The
standard defined the dedicated type for highlights, \fBattr_t\fR, which is not
defined in SVr4 curses. The functions taking \fBattr_t\fR arguments are
not supported under SVr4.
.PP
The XSI Curses standard states that whether the traditional functions
\fBattron\fR/\fBattroff\fR/\fBattrset\fR can manipulate attributes other than
\fBA_BLINK\fR, \fBA_BOLD\fR, \fBA_DIM\fR, \fBA_REVERSE\fR, \fBA_STANDOUT\fR, or
\fBA_UNDERLINE\fR is "unspecified".  Under this implementation as well as
SVr4 curses, these functions correctly manipulate all other highlights
(specifically, \fBA_ALTCHARSET\fR, \fBA_PROTECT\fR, and \fBA_INVIS\fR).
.PP
XSI Curses added the new entry points, \fBattr_get\fR, \fBattr_on\fR,
\fBattr_off\fR, \fBattr_set\fR, \fBwattr_on\fR, \fBwattr_off\fR,
\fBwattr_get\fR, \fBwattr_set\fR.  These are intended to work with
a new series of highlight macros prefixed with \fBWA_\fR.
.PP
Older versions of this library did not force an update of the screen
when changing the attributes.
Use \fBtouchwin\fR to force the screen to match the updated attributes.
.PP
.TS
center ;
l l .
\fBWA_NORMAL\fR	Normal display (no highlight)
\fBWA_STANDOUT\fR	Best highlighting mode of the terminal.
\fBWA_UNDERLINE\fR	Underlining
\fBWA_REVERSE\fR	Reverse video
\fBWA_BLINK\fR	Blinking
\fBWA_DIM\fR	Half bright
\fBWA_BOLD\fR	Extra bright or bold
\fBWA_ALTCHARSET\fR	Alternate character set
.TE
.PP
The XSI curses standard specifies that each pair of corresponding \fBA_\fR
and \fBWA_\fR-using functions operates on the same current-highlight
information.
.PP
The XSI standard extended conformance level adds new highlights
\fBA_HORIZONTAL\fR, \fBA_LEFT\fR, \fBA_LOW\fR, \fBA_RIGHT\fR, \fBA_TOP\fR,
\fBA_VERTICAL\fR (and corresponding \fBWA_\fR macros for each) which this
implementation does not yet support.
.SH RETURN VALUE
All routines return the integer \fBOK\fR on success, or \fBERR\fP on failure.
.PP
X/Open does not define any error conditions.
.PP
This implementation returns an error
if the window pointer is null.
The \fBwcolor_set\fP function returns an error if the color pair parameter
is outside the range 0..COLOR_PAIRS-1.
This implementation also provides
\fBgetattrs\fR
for compatibility with older versions of curses.
.SH SEE ALSO
\fBcurses\fR(3X),
\fBcurs_addch\fR(3X),
\fBcurs_addstr\fR(3X),
\fBcurs_bkgd\fR(3X),
\fBcurs_printw\fR(3X)
.\"#
.\"# The following sets edit modes for GNU EMACS
.\"# Local Variables:
.\"# mode:nroff
.\"# fill-column:79
.\"# End:
                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cimag.3                                      0100644 0001750 0001750 00000000020 12566165764 022026  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/creal.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cimagf.3                                     0100644 0001750 0001750 00000000020 12566165764 022174  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/creal.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/cimagl.3                                     0100644 0001750 0001750 00000000020 12566165764 022202  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/creal.3                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ckalloc.3tcl                                 0100644 0001750 0001750 00000021434 12566232323 023057  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1995-1996 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: Alloc.3,v 1.10.8.1 2009/03/30 18:48:18 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_Alloc 3 7.5 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_Alloc, Tcl_Free, Tcl_Realloc, Tcl_AttemptAlloc, Tcl_AttemptRealloc, ckalloc, ckfree, ckrealloc, attemptckalloc, attemptckrealloc \- allocate or free heap memory
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
char *
\fBTcl_Alloc\fR(\fIsize\fR)
.sp
void
\fBTcl_Free\fR(\fIptr\fR)
.sp
char *
\fBTcl_Realloc\fR(\fIptr, size\fR)
.sp
char *
\fBTcl_AttemptAlloc\fR(\fIsize\fR)
.sp
char *
\fBTcl_AttemptRealloc\fR(\fIptr, size\fR)
.sp
char *
\fBckalloc\fR(\fIsize\fR)
.sp
void
\fBckfree\fR(\fIptr\fR)
.sp
char *
\fBckrealloc\fR(\fIptr, size\fR)
.sp
char *
\fBattemptckalloc\fR(\fIsize\fR)
.sp
char *
\fBattemptckrealloc\fR(\fIptr, size\fR)
.SH ARGUMENTS
.AS char *size
.AP "unsigned int" size in
Size in bytes of the memory block to allocate.
.AP char *ptr in
Pointer to memory block to free or realloc.
.BE

.SH DESCRIPTION
.PP
These procedures provide a platform and compiler independent interface
for memory allocation.  Programs that need to transfer ownership of
memory blocks between Tcl and other modules should use these routines
rather than the native \fBmalloc()\fR and \fBfree()\fR routines
provided by the C run-time library.
.PP
\fBTcl_Alloc\fR returns a pointer to a block of at least \fIsize\fR
bytes suitably aligned for any use.
.PP
\fBTcl_Free\fR makes the space referred to by \fIptr\fR available for
further allocation.
.PP
\fBTcl_Realloc\fR changes the size of the block pointed to by
\fIptr\fR to \fIsize\fR bytes and returns a pointer to the new block.
The contents will be unchanged up to the lesser of the new and old
sizes.  The returned location may be different from \fIptr\fR.  If
\fIptr\fR is NULL, this is equivalent to calling \fBTcl_Alloc\fR with
just the \fIsize\fR argument.
.PP
\fBTcl_AttemptAlloc\fR and \fBTcl_AttemptRealloc\fR are identical in
function to \fBTcl_Alloc\fR and \fBTcl_Realloc\fR, except that
\fBTcl_AttemptAlloc\fR and \fBTcl_AttemptRealloc\fR will not cause the Tcl
interpreter to \fBpanic\fR if the memory allocation fails.  If the
allocation fails, these functions will return NULL.  Note that on some
platforms, but not all, attempting to allocate a zero-sized block of
memory will also cause these functions to return NULL.
.PP
The procedures \fBckalloc\fR, \fBckfree\fR, \fBckrealloc\fR,
\fBattemptckalloc\fR, and \fBattemptckrealloc\fR are implemented
as macros.  Normally, they are synonyms for the corresponding
procedures documented on this page.  When Tcl and all modules
calling Tcl are compiled with \fBTCL_MEM_DEBUG\fR defined, however,
these macros are redefined to be special debugging versions
of these procedures.  To support Tcl's memory debugging within a
module, use the macros rather than direct calls to \fBTcl_Alloc\fR, etc.

.SH KEYWORDS
alloc, allocation, free, malloc, memory, realloc, TCL_MEM_DEBUG
                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ckfree.3tcl                                  0100644 0001750 0001750 00000021434 12566232323 022706  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1995-1996 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: Alloc.3,v 1.10.8.1 2009/03/30 18:48:18 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_Alloc 3 7.5 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_Alloc, Tcl_Free, Tcl_Realloc, Tcl_AttemptAlloc, Tcl_AttemptRealloc, ckalloc, ckfree, ckrealloc, attemptckalloc, attemptckrealloc \- allocate or free heap memory
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
char *
\fBTcl_Alloc\fR(\fIsize\fR)
.sp
void
\fBTcl_Free\fR(\fIptr\fR)
.sp
char *
\fBTcl_Realloc\fR(\fIptr, size\fR)
.sp
char *
\fBTcl_AttemptAlloc\fR(\fIsize\fR)
.sp
char *
\fBTcl_AttemptRealloc\fR(\fIptr, size\fR)
.sp
char *
\fBckalloc\fR(\fIsize\fR)
.sp
void
\fBckfree\fR(\fIptr\fR)
.sp
char *
\fBckrealloc\fR(\fIptr, size\fR)
.sp
char *
\fBattemptckalloc\fR(\fIsize\fR)
.sp
char *
\fBattemptckrealloc\fR(\fIptr, size\fR)
.SH ARGUMENTS
.AS char *size
.AP "unsigned int" size in
Size in bytes of the memory block to allocate.
.AP char *ptr in
Pointer to memory block to free or realloc.
.BE

.SH DESCRIPTION
.PP
These procedures provide a platform and compiler independent interface
for memory allocation.  Programs that need to transfer ownership of
memory blocks between Tcl and other modules should use these routines
rather than the native \fBmalloc()\fR and \fBfree()\fR routines
provided by the C run-time library.
.PP
\fBTcl_Alloc\fR returns a pointer to a block of at least \fIsize\fR
bytes suitably aligned for any use.
.PP
\fBTcl_Free\fR makes the space referred to by \fIptr\fR available for
further allocation.
.PP
\fBTcl_Realloc\fR changes the size of the block pointed to by
\fIptr\fR to \fIsize\fR bytes and returns a pointer to the new block.
The contents will be unchanged up to the lesser of the new and old
sizes.  The returned location may be different from \fIptr\fR.  If
\fIptr\fR is NULL, this is equivalent to calling \fBTcl_Alloc\fR with
just the \fIsize\fR argument.
.PP
\fBTcl_AttemptAlloc\fR and \fBTcl_AttemptRealloc\fR are identical in
function to \fBTcl_Alloc\fR and \fBTcl_Realloc\fR, except that
\fBTcl_AttemptAlloc\fR and \fBTcl_AttemptRealloc\fR will not cause the Tcl
interpreter to \fBpanic\fR if the memory allocation fails.  If the
allocation fails, these functions will return NULL.  Note that on some
platforms, but not all, attempting to allocate a zero-sized block of
memory will also cause these functions to return NULL.
.PP
The procedures \fBckalloc\fR, \fBckfree\fR, \fBckrealloc\fR,
\fBattemptckalloc\fR, and \fBattemptckrealloc\fR are implemented
as macros.  Normally, they are synonyms for the corresponding
procedures documented on this page.  When Tcl and all modules
calling Tcl are compiled with \fBTCL_MEM_DEBUG\fR defined, however,
these macros are redefined to be special debugging versions
of these procedures.  To support Tcl's memory debugging within a
module, use the macros rather than direct calls to \fBTcl_Alloc\fR, etc.

.SH KEYWORDS
alloc, allocation, free, malloc, memory, realloc, TCL_MEM_DEBUG
                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/ckrealloc.3tcl                               0100644 0001750 0001750 00000021434 12566232323 023406  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\"
'\" Copyright (c) 1995-1996 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @(#) $Id: Alloc.3,v 1.10.8.1 2009/03/30 18:48:18 dgp Exp $
'\" 
.\" The -*- nroff -*- definitions below are for supplemental macros used
.\" in Tcl/Tk manual entries.
.\"
.\" .AP type name in/out ?indent?
.\"	Start paragraph describing an argument to a library procedure.
.\"	type is type of argument (int, etc.), in/out is either "in", "out",
.\"	or "in/out" to describe whether procedure reads or modifies arg,
.\"	and indent is equivalent to second arg of .IP (shouldn't ever be
.\"	needed;  use .AS below instead)
.\"
.\" .AS ?type? ?name?
.\"	Give maximum sizes of arguments for setting tab stops.  Type and
.\"	name are examples of largest possible arguments that will be passed
.\"	to .AP later.  If args are omitted, default tab stops are used.
.\"
.\" .BS
.\"	Start box enclosure.  From here until next .BE, everything will be
.\"	enclosed in one large box.
.\"
.\" .BE
.\"	End of box enclosure.
.\"
.\" .CS
.\"	Begin code excerpt.
.\"
.\" .CE
.\"	End code excerpt.
.\"
.\" .VS ?version? ?br?
.\"	Begin vertical sidebar, for use in marking newly-changed parts
.\"	of man pages.  The first argument is ignored and used for recording
.\"	the version when the .VS was added, so that the sidebars can be
.\"	found and removed when they reach a certain age.  If another argument
.\"	is present, then a line break is forced before starting the sidebar.
.\"
.\" .VE
.\"	End of vertical sidebar.
.\"
.\" .DS
.\"	Begin an indented unfilled display.
.\"
.\" .DE
.\"	End of indented unfilled display.
.\"
.\" .SO ?manpage?
.\"	Start of list of standard options for a Tk widget. The manpage
.\"	argument defines where to look up the standard options; if
.\"	omitted, defaults to "options". The options follow on successive
.\"	lines, in three columns separated by tabs.
.\"
.\" .SE
.\"	End of list of standard options for a Tk widget.
.\"
.\" .OP cmdName dbName dbClass
.\"	Start of description of a specific option.  cmdName gives the
.\"	option's name as specified in the class command, dbName gives
.\"	the option's name in the option database, and dbClass gives
.\"	the option's class in the option database.
.\"
.\" .UL arg1 arg2
.\"	Print arg1 underlined, then print arg2 normally.
.\"
.\" .QW arg1 ?arg2?
.\"	Print arg1 in quotes, then arg2 normally (for trailing punctuation).
.\"
.\" .PQ arg1 ?arg2?
.\"	Print an open parenthesis, arg1 in quotes, then arg2 normally
.\"	(for trailing punctuation) and then a closing parenthesis.
.\"
.\" RCS: @(#) $Id: man.macros,v 1.9 2008/01/29 15:32:33 dkf Exp $
.\"
.\"	# Set up traps and other miscellaneous stuff for Tcl/Tk man pages.
.if t .wh -1.3i ^B
.nr ^l \n(.l
.ad b
.\"	# Start an argument description
.de AP
.ie !"\\$4"" .TP \\$4
.el \{\
.   ie !"\\$2"" .TP \\n()Cu
.   el          .TP 15
.\}
.ta \\n()Au \\n()Bu
.ie !"\\$3"" \{\
\&\\$1 \\fI\\$2\\fP (\\$3)
.\".b
.\}
.el \{\
.br
.ie !"\\$2"" \{\
\&\\$1	\\fI\\$2\\fP
.\}
.el \{\
\&\\fI\\$1\\fP
.\}
.\}
..
.\"	# define tabbing values for .AP
.de AS
.nr )A 10n
.if !"\\$1"" .nr )A \\w'\\$1'u+3n
.nr )B \\n()Au+15n
.\"
.if !"\\$2"" .nr )B \\w'\\$2'u+\\n()Au+3n
.nr )C \\n()Bu+\\w'(in/out)'u+2n
..
.AS Tcl_Interp Tcl_CreateInterp in/out
.\"	# BS - start boxed text
.\"	# ^y = starting y location
.\"	# ^b = 1
.de BS
.br
.mk ^y
.nr ^b 1u
.if n .nf
.if n .ti 0
.if n \l'\\n(.lu\(ul'
.if n .fi
..
.\"	# BE - end boxed text (draw box now)
.de BE
.nf
.ti 0
.mk ^t
.ie n \l'\\n(^lu\(ul'
.el \{\
.\"	Draw four-sided box normally, but don't draw top of
.\"	box if the box started on an earlier page.
.ie !\\n(^b-1 \{\
\h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.el \}\
\h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\l'|0u-1.5n\(ul'
.\}
.\}
.fi
.br
.nr ^b 0
..
.\"	# VS - start vertical sidebar
.\"	# ^Y = starting y location
.\"	# ^v = 1 (for troff;  for nroff this doesn't matter)
.de VS
.if !"\\$2"" .br
.mk ^Y
.ie n 'mc \s12\(br\s0
.el .nr ^v 1u
..
.\"	# VE - end of vertical sidebar
.de VE
.ie n 'mc
.el \{\
.ev 2
.nf
.ti 0
.mk ^t
\h'|\\n(^lu+3n'\L'|\\n(^Yu-1v\(bv'\v'\\n(^tu+1v-\\n(^Yu'\h'-|\\n(^lu+3n'
.sp -1
.fi
.ev
.\}
.nr ^v 0
..
.\"	# Special macro to handle page bottom:  finish off current
.\"	# box/sidebar if in box/sidebar mode, then invoked standard
.\"	# page bottom macro.
.de ^B
.ev 2
'ti 0
'nf
.mk ^t
.if \\n(^b \{\
.\"	Draw three-sided box if this is the box's first page,
.\"	draw two sides but no top otherwise.
.ie !\\n(^b-1 \h'-1.5n'\L'|\\n(^yu-1v'\l'\\n(^lu+3n\(ul'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.el \h'-1.5n'\L'|\\n(^yu-1v'\h'\\n(^lu+3n'\L'\\n(^tu+1v-\\n(^yu'\h'|0u'\c
.\}
.if \\n(^v \{\
.nr ^x \\n(^tu+1v-\\n(^Yu
\kx\h'-\\nxu'\h'|\\n(^lu+3n'\ky\L'-\\n(^xu'\v'\\n(^xu'\h'|0u'\c
.\}
.bp
'fi
.ev
.if \\n(^b \{\
.mk ^y
.nr ^b 2
.\}
.if \\n(^v \{\
.mk ^Y
.\}
..
.\"	# DS - begin display
.de DS
.RS
.nf
.sp
..
.\"	# DE - end display
.de DE
.fi
.RE
.sp
..
.\"	# SO - start of list of standard options
.de SO
'ie '\\$1'' .ds So \\fBoptions\\fR
'el .ds So \\fB\\$1\\fR
.SH "STANDARD OPTIONS"
.LP
.nf
.ta 5.5c 11c
.ft B
..
.\"	# SE - end of list of standard options
.de SE
.fi
.ft R
.LP
See the \\*(So manual entry for details on the standard options.
..
.\"	# OP - start of full description for a single option
.de OP
.LP
.nf
.ta 4c
Command-Line Name:	\\fB\\$1\\fR
Database Name:	\\fB\\$2\\fR
Database Class:	\\fB\\$3\\fR
.fi
.IP
..
.\"	# CS - begin code excerpt
.de CS
.RS
.nf
.ta .25i .5i .75i 1i
..
.\"	# CE - end code excerpt
.de CE
.fi
.RE
..
.\"	# UL - underline word
.de UL
\\$1\l'|0\(ul'\\$2
..
.\"	# QW - apply quotation marks to word
.de QW
.ie '\\*(lq'"' ``\\$1''\\$2
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\$2
..
.\"	# PQ - apply parens and quotation marks to word
.de PQ
.ie '\\*(lq'"' (``\\$1''\\$2)\\$3
.\"" fix emacs highlighting
.el (\\*(lq\\$1\\*(rq\\$2)\\$3
..
.\"	# QR - quoted range
.de QR
.ie '\\*(lq'"' ``\\$1''\\-``\\$2''\\$3
.\"" fix emacs highlighting
.el \\*(lq\\$1\\*(rq\\-\\*(lq\\$2\\*(rq\\$3
..
.\"	# MT - "empty" string
.de MT
.QW ""
..
.TH Tcl_Alloc 3 7.5 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_Alloc, Tcl_Free, Tcl_Realloc, Tcl_AttemptAlloc, Tcl_AttemptRealloc, ckalloc, ckfree, ckrealloc, attemptckalloc, attemptckrealloc \- allocate or free heap memory
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
char *
\fBTcl_Alloc\fR(\fIsize\fR)
.sp
void
\fBTcl_Free\fR(\fIptr\fR)
.sp
char *
\fBTcl_Realloc\fR(\fIptr, size\fR)
.sp
char *
\fBTcl_AttemptAlloc\fR(\fIsize\fR)
.sp
char *
\fBTcl_AttemptRealloc\fR(\fIptr, size\fR)
.sp
char *
\fBckalloc\fR(\fIsize\fR)
.sp
void
\fBckfree\fR(\fIptr\fR)
.sp
char *
\fBckrealloc\fR(\fIptr, size\fR)
.sp
char *
\fBattemptckalloc\fR(\fIsize\fR)
.sp
char *
\fBattemptckrealloc\fR(\fIptr, size\fR)
.SH ARGUMENTS
.AS char *size
.AP "unsigned int" size in
Size in bytes of the memory block to allocate.
.AP char *ptr in
Pointer to memory block to free or realloc.
.BE

.SH DESCRIPTION
.PP
These procedures provide a platform and compiler independent interface
for memory allocation.  Programs that need to transfer ownership of
memory blocks between Tcl and other modules should use these routines
rather than the native \fBmalloc()\fR and \fBfree()\fR routines
provided by the C run-time library.
.PP
\fBTcl_Alloc\fR returns a pointer to a block of at least \fIsize\fR
bytes suitably aligned for any use.
.PP
\fBTcl_Free\fR makes the space referred to by \fIptr\fR available for
further allocation.
.PP
\fBTcl_Realloc\fR changes the size of the block pointed to by
\fIptr\fR to \fIsize\fR bytes and returns a pointer to the new block.
The contents will be unchanged up to the lesser of the new and old
sizes.  The returned location may be different from \fIptr\fR.  If
\fIptr\fR is NULL, this is equivalent to calling \fBTcl_Alloc\fR with
just the \fIsize\fR argument.
.PP
\fBTcl_AttemptAlloc\fR and \fBTcl_AttemptRealloc\fR are identical in
function to \fBTcl_Alloc\fR and \fBTcl_Realloc\fR, except that
\fBTcl_AttemptAlloc\fR and \fBTcl_AttemptRealloc\fR will not cause the Tcl
interpreter to \fBpanic\fR if the memory allocation fails.  If the
allocation fails, these functions will return NULL.  Note that on some
platforms, but not all, attempting to allocate a zero-sized block of
memory will also cause these functions to return NULL.
.PP
The procedures \fBckalloc\fR, \fBckfree\fR, \fBckrealloc\fR,
\fBattemptckalloc\fR, and \fBattemptckrealloc\fR are implemented
as macros.  Normally, they are synonyms for the corresponding
procedures documented on this page.  When Tcl and all modules
calling Tcl are compiled with \fBTCL_MEM_DEBUG\fR defined, however,
these macros are redefined to be special debugging versions
of these procedures.  To support Tcl's memory debugging within a
module, use the macros rather than direct calls to \fBTcl_Alloc\fR, etc.

.SH KEYWORDS
alloc, allocation, free, malloc, memory, realloc, TCL_MEM_DEBUG
                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/clear.3x                                     0100644 0001750 0001750 00000012027 12566174416 022230  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"***************************************************************************
.\" Copyright (c) 1998-2005,2007 Free Software Foundation, Inc.              *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, to any person obtaining a  *
.\" copy of this software and associated documentation files (the            *
.\" "Software"), to deal in the Software without restriction, including      *
.\" without limitation the rights to use, copy, modify, merge, publish,      *
.\" distribute, distribute with modifications, sublicense, and/or sell       *
.\" copies of the Software, and to permit persons to whom the Software is    *
.\" furnished to do so, subject to the following conditions:                 *
.\"                                                                          *
.\" The above copyright notice and this permission notice shall be included  *
.\" in all copies or substantial portions of the Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained in this notice, the name(s) of the above copyright   *
.\" holders shall not be used in advertising or otherwise to promote the     *
.\" sale, use or other dealings in this Software without prior written       *
.\" authorization.                                                           *
.\"***************************************************************************
.\"
.\" $Id: curs_clear.3x,v 1.11 2007/12/29 15:58:38 tom Exp $
.TH curs_clear 3X ""
.na
.hy 0
.SH NAME
\fBerase\fR,
\fBwerase\fR,
\fBclear\fR,
\fBwclear\fR,
\fBclrtobot\fR,
\fBwclrtobot\fR,
\fBclrtoeol\fR,
\fBwclrtoeol\fR - clear all or part of a \fBcurses\fR window
.ad
.hy
.SH SYNOPSIS
\fB# include <curses.h>\fR
.sp
\fBint erase(void);\fR
.br
\fBint werase(WINDOW *win);\fR
.br
\fBint clear(void);\fR
.br
\fBint wclear(WINDOW *win);\fR
.br
\fBint clrtobot(void);\fR
.br
\fBint wclrtobot(WINDOW *win);\fR
.br
\fBint clrtoeol(void);\fR
.br
\fBint wclrtoeol(WINDOW *win);\fR
.br
.SH DESCRIPTION
The \fBerase\fR and \fBwerase\fR routines copy blanks to every
position in the window, clearing the screen.
.PP
The \fBclear\fR and \fBwclear\fR routines are like \fBerase\fR and
\fBwerase\fR, but they also call \fBclearok\fR, so that the screen is
cleared completely on the next call to \fBwrefresh\fR for that window
and repainted from scratch.
.PP
The \fBclrtobot\fR and \fBwclrtobot\fR routines erase from the cursor to the
end of screen.  That is, they erase all lines below the cursor in the window.
Also, the current line to the right of the cursor, inclusive, is erased.
.PP
The \fBclrtoeol\fR and \fBwclrtoeol\fR routines erase the current line
to the right of the cursor, inclusive, to the end of the current line.
.PP
Blanks created by erasure have the current background rendition (as set
by \fBwbkgdset\fR) merged into them.
.SH RETURN VALUE
All routines return the integer \fBOK\fR on success and \fBERR\fP on failure.
The SVr4.0 manual says "or a
non-negative integer if \fBimmedok\fR is set", but this appears to be an error.
.PP
X/Open defines no error conditions.
In this implementation,
functions using a window pointer parameter return an error if it is null.
.SH NOTES
Note that \fBerase\fR, \fBwerase\fR, \fBclear\fR, \fBwclear\fR,
\fBclrtobot\fR, and \fBclrtoeol\fR may be macros.
.SH PORTABILITY
These functions are described in the XSI Curses standard, Issue 4.  The
standard specifies that they return \fBERR\fR on failure, but specifies no
error conditions.
.PP
Some historic curses implementations had, as an undocumented feature, the
ability to do the equivalent of \fBclearok(..., 1)\fR by saying
\fBtouchwin(stdscr)\fR or \fBclear(stdscr)\fR.  This will not work under
ncurses.
.PP
This implementation, and others such as Solaris,
sets the current position to 0,0 after erasing
via \fBwerase()\fP and \fBwclear()\fP.
That fact is not documented in other implementations,
and may not be true of implementations
which were not derived from SVr4 source.
.PP
Not obvious from the description,
most implementations clear the screen after \fBwclear\fP
even for a subwindow or derived window.
If you do not want to clear the screen during the next \fBwrefresh\fP,
use \fBwerase\fP instead.
.SH SEE ALSO
\fBcurses\fR(3X), \fBcurs_outopts\fR(3X), \fBcurs_refresh\fR(3X)
.\"#
.\"# The following sets edit modes for GNU EMACS
.\"# Local Variables:
.\"# mode:nroff
.\"# fill-column:79
.\"# End:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/clearerr.3                                   0120777 0001750 0001750 00000000000 12620245063 024115  2ferror.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/clearerr_unlocked.3                          0120777 0001750 0001750 00000000000 12620245063 026001  2ferror.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/clearok.3x                                   0100644 0001750 0001750 00000022340 12566174421 022555  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"***************************************************************************
.\" Copyright (c) 1998-2005,2007 Free Software Foundation, Inc.              *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, to any person obtaining a  *
.\" copy of this software and associated documentation files (the            *
.\" "Software"), to deal in the Software without restriction, including      *
.\" without limitation the rights to use, copy, modify, merge, publish,      *
.\" distribute, distribute with modifications, sublicense, and/or sell       *
.\" copies of the Software, and to permit persons to whom the Software is    *
.\" furnished to do so, subject to the following conditions:                 *
.\"                                                                          *
.\" The above copyright notice and this permission notice shall be included  *
.\" in all copies or substantial portions of the Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained in this notice, the name(s) of the above copyright   *
.\" holders shall not be used in advertising or otherwise to promote the     *
.\" sale, use or other dealings in this Software without prior written       *
.\" authorization.                                                           *
.\"***************************************************************************
.\"
.\" $Id: curs_outopts.3x,v 1.21 2007/06/02 20:40:07 tom Exp $
.TH curs_outopts 3X ""
.na
.hy 0
.SH NAME
\fBclearok\fR,
\fBidlok\fR,
\fBidcok\fR,
\fBimmedok\fR,
\fBleaveok\fR,
\fBsetscrreg\fR,
\fBwsetscrreg\fR,
\fBscrollok\fR,
\fBnl\fR,
\fBnonl\fR - \fBcurses\fR output options
.ad
.hy
.SH SYNOPSIS
\fB#include <curses.h>\fR
.sp
\fBint clearok(WINDOW *win, bool bf);\fR
.br
\fBint idlok(WINDOW *win, bool bf);\fR
.br
\fBvoid idcok(WINDOW *win, bool bf);\fR
.br
\fBvoid immedok(WINDOW *win, bool bf);\fR
.br
\fBint leaveok(WINDOW *win, bool bf);\fR
.br
\fBint setscrreg(int top, int bot);\fR
.br
\fBint wsetscrreg(WINDOW *win, int top, int bot);\fR
.br
\fBint scrollok(WINDOW *win, bool bf);\fR
.br
\fBint nl(void);\fR
.br
\fBint nonl(void);\fR
.br
.SH DESCRIPTION
These routines set options that change the style of output within
\fBcurses\fR.
All options are initially \fBFALSE\fR, unless otherwise stated.
It is not necessary to turn these options off before calling \fBendwin\fR.
.PP
If \fBclearok\fR is called with \fBTRUE\fR as argument, the next
call to \fBwrefresh\fR with this window will clear the screen completely and
redraw the entire screen from scratch.
This is useful when the contents of the
screen are uncertain, or in some cases for a more pleasing visual effect.
If
the \fIwin\fR argument to \fBclearok\fR is the global variable \fBcurscr\fR,
the next call to \fBwrefresh\fR with any window causes the screen to be cleared
and repainted from scratch.
.PP
If \fBidlok\fR is called with \fBTRUE\fR as second argument, \fBcurses\fR
considers using the hardware insert/delete line feature of terminals so
equipped.
Calling \fBidlok\fR with \fBFALSE\fR as second argument disables use
of line insertion and deletion.
This option should be enabled only if the
application needs insert/delete line, for example, for a screen editor.
It is
disabled by default because insert/delete line tends to be visually annoying
when used in applications where it is not really needed.
If insert/delete line
cannot be used, \fBcurses\fR redraws the changed portions of all lines.
.PP
If \fBidcok\fR is called with \fBFALSE\fR as second argument, \fBcurses\fR
no longer considers using the hardware insert/delete character feature of
terminals so equipped.
Use of character insert/delete is enabled by default.
Calling \fBidcok\fR with \fBTRUE\fR as second argument re-enables use
of character insertion and deletion.
.PP
If \fBimmedok\fR is called with \fBTRUE as argument\fR, any change
in the window image, such as the ones caused by \fBwaddch, wclrtobot, wscrl\fR,
etc., automatically cause a call to \fBwrefresh\fR.
However, it may
degrade performance considerably, due to repeated calls to \fBwrefresh\fR.
It is disabled by default.
.PP
Normally, the hardware cursor is left at the location of the window cursor
being refreshed.
The \fBleaveok\fR option allows the cursor to be left
wherever the update happens to leave it.
It is useful for applications where
the cursor is not used, since it reduces the need for cursor motions.
.PP
The \fBsetscrreg\fR and \fBwsetscrreg\fR routines allow the application
programmer to set a software scrolling region in a window.
\fItop\fR and
\fIbot\fR are the line numbers of the top and bottom margin of the scrolling
region.
(Line 0 is the top line of the window.)  If this option and
\fBscrollok\fR are enabled, an attempt to move off the bottom margin line
causes all lines in the scrolling region to scroll one line in the direction
of the first line.
Only the text of the window is scrolled.
(Note that this
has nothing to do with the use of a physical scrolling region capability in the
terminal, like that in the VT100.
If \fBidlok\fR is enabled and the terminal
has either a scrolling region or insert/delete line capability, they will
probably be used by the output routines.)
.PP
The \fBscrollok\fR option controls what happens when the cursor of a window is
moved off the edge of the window or scrolling region, either as a result of a
newline action on the bottom line, or typing the last character of the last
line.
If disabled, (\fIbf\fR is \fBFALSE\fR), the cursor is left on the bottom
line.
If enabled, (\fIbf\fR is \fBTRUE\fR), the window is scrolled up one line
(Note that to get the physical scrolling effect on the terminal, it is
also necessary to call \fBidlok\fR).
.PP
The \fBnl\fR and \fBnonl\fR routines control whether the underlying display
device translates the return key into newline on input, and whether it
translates newline into return and line-feed on output (in either case, the
call \fBaddch('\\n')\fR does the equivalent of return and line feed on the
virtual screen).
Initially, these translations do occur.
If you disable them
using \fBnonl\fR, \fBcurses\fR will be able to make better use of the line-feed
capability, resulting in faster cursor motion.
Also, \fBcurses\fR will then be
able to detect the return key.
.SH RETURN VALUE
The functions \fBsetscrreg\fR and \fBwsetscrreg\fR return \fBOK\fR upon success
and \fBERR\fR upon failure.
All other routines that return an integer always
return \fBOK\fR.
.PP
X/Open does not define any error conditions.
.PP
In this implementation, those functions that have a window pointer
will return an error if the window pointer is null.
.RS
.TP 5
.B wclrtoeol
returns an error
if the cursor position is about to wrap.
.TP 5
.B wsetscrreg
returns an error if the scrolling region limits extend outside the window.
.RE
.PP
X/Open does not define any error conditions.
This implementation returns an error
if the window pointer is null.
.SH PORTABILITY
These functions are described in the XSI Curses standard, Issue 4.
.PP
The XSI Curses standard is ambiguous on the question of whether \fBraw\fR()
should disable the CRLF translations controlled by \fBnl\fR() and \fBnonl\fR().
BSD curses did turn off these translations; AT&T curses (at least as late as
SVr1) did not.
We choose to do so, on the theory that a programmer requesting
raw input wants a clean (ideally 8-bit clean) connection that the operating
system will not alter.
.PP
Some historic curses implementations had, as an undocumented feature, the
ability to do the equivalent of \fBclearok(..., 1)\fR by saying
\fBtouchwin(stdscr)\fR or \fBclear(stdscr)\fR.
This will not work under
ncurses.
.PP
Earlier System V curses implementations specified that with \fBscrollok\fR
enabled, any window modification triggering a scroll also forced a physical
refresh.
XSI Curses does not require this, and \fBncurses\fR avoids doing
it to perform better vertical-motion optimization at \fBwrefresh\fR
time.
.PP
The XSI Curses standard does not mention that the cursor should be
made invisible as a side-effect of \fBleaveok\fR.
SVr4 curses documentation does this, but the code does not.
Use \fBcurs_set\fR to make the cursor invisible.
.SH NOTES
Note that \fBclearok\fR, \fBleaveok\fR, \fBscrollok\fR, \fBidcok\fR, \fBnl\fR,
\fBnonl\fR and \fBsetscrreg\fR may be macros.
.PP
The \fBimmedok\fR routine is useful for windows that are used as terminal
emulators.
.SH SEE ALSO
\fBcurses\fR(3X), \fBcurs_addch\fR(3X), \fBcurs_clear\fR(3X),
\fBcurs_initscr\fR(3X), \fBcurs_scroll\fR(3X), \fBcurs_refresh\fR(3X)
.\"#
.\"# The following sets edit modes for GNU EMACS
.\"# Local Variables:
.\"# mode:nroff
.\"# fill-column:79
.\"# End:
                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/clnt_broadcast.3                             0100644 0001750 0001750 00000073141 12566167025 023736  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"	from: @(#)rpc.3n	2.4 88/08/08 4.0 RPCSRC; from 1.19 88/06/24 SMI
.\"	$Id: rpc.3,v 1.1 1999/04/13 23:15:37 wsanchez Exp $
.\"
.TH RPC 3N "16 February 1988"
.SH NAME
rpc \- library routines for remote procedure calls
.SH SYNOPSIS AND DESCRIPTION
These routines allow C programs to make procedure
calls on other machines across the network.
First, the client calls a procedure to send a
data packet to the server.
Upon receipt of the packet, the server calls a dispatch routine
to perform the requested service, and then sends back a
reply.
Finally, the procedure call returns to the client.
.LP
Routines that are used for Secure RPC (DES authentication) are described in
.BR rpc_secure (3N).
Secure RPC can be used only if DES encryption is available.
.LP
.ft B
.nf
.sp .5
#include <rpc/rpc.h>
.fi
.ft R
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
auth_destroy(auth)
\s-1AUTH\s0 *auth;
.fi
.ft R
.IP
A macro that destroys the authentication information associated with
.IR auth .
Destruction usually involves deallocation of private data
structures. The use of
.I auth
is undefined after calling
.BR auth_destroy(\|) .
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authnone_create(\|)
.fi
.ft R
.IP
Create and returns an
.SM RPC
authentication handle that passes nonusable authentication
information with each remote procedure call. This is the
default authentication used by
.SM RPC.
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create(host, uid, gid, len, aup_gids)
char *host;
int uid, gid, len, *aup.gids;
.fi
.ft R
.IP
Create and return an
.SM RPC
authentication handle that contains
.UX
authentication information.
The parameter
.I host
is the name of the machine on which the information was
created;
.I uid
is the user's user
.SM ID ;
.I gid
is the user's current group
.SM ID ;
.I len
and
.I aup_gids
refer to a counted array of groups to which the user belongs.
It is easy to impersonate a user.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create_default(\|)
.fi
.ft R
.IP
Calls
.B authunix_create(\|)
with the appropriate parameters.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
char *host;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Call the remote procedure associated with
.IR prognum ,
.IR versnum ,
and
.I procnum
on the machine,
.IR host .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results.
This routine returns zero if it succeeds, or the value of
.B "enum clnt_stat"
cast to an integer if it fails.
The routine
.B clnt_perrno(\|)
is handy for translating failure statuses into messages.
.IP
Warning: calling remote procedures with this routine
uses
.SM UDP/IP
as a transport; see
.B clntudp_create(\|)
for restrictions.
You do not have control of timeouts or authentication using
this routine.
.br
.if t .ne 16
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_broadcast(prognum, versnum, procnum, inproc, in, outproc, out, eachresult)
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
resultproc_t eachresult;
.fi
.ft R
.IP
Like
.BR callrpc(\|) ,
except the call message is broadcast to all locally
connected broadcast nets. Each time it receives a
response, this routine calls
.BR eachresult(\|) ,
whose form is:
.IP
.RS 1i
.ft B
.nf
eachresult(out, addr)
char *out;
struct sockaddr_in *addr;
.ft R
.fi
.RE
.IP
where
.I out
is the same as
.I out
passed to
.BR clnt_broadcast(\|) ,
except that the remote procedure's output is decoded there;
.I addr
points to the address of the machine that sent the results.
If
.B eachresult(\|)
returns zero,
.B clnt_broadcast(\|)
waits for more replies; otherwise it returns with appropriate
status.
.IP
Warning: broadcast sockets are limited in size to the
maximum transfer unit of the data link. For ethernet,
this value is 1500 bytes.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_call(clnt, procnum, inproc, in, outproc, out, tout)
\s-1CLIENT\s0 *clnt;
u_long
procnum;
xdrproc_t inproc, outproc;
char *in, *out;
struct timeval tout;
.fi
.ft R
.IP
A macro that calls the remote procedure
.I procnum
associated with the client handle,
.IR clnt ,
which is obtained with an
.SM RPC
client creation routine such as
.BR clnt_create(\|) .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results;
.I tout
is the time allowed for results to come back.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
clnt_destroy(clnt)
\s-1CLIENT\s0 *clnt;
.fi
.ft R
.IP
A macro that destroys the client's
.SM RPC
handle. Destruction usually involves deallocation
of private data structures, including
.I clnt
itself.  Use of
.I clnt
is undefined after calling
.BR clnt_destroy(\|) .
If the
.SM RPC
library opened the associated socket, it will close it also.
Otherwise, the socket remains open.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnt_create(host, prog, vers, proto)
char *host;
u_long prog, vers;
char *proto;
.fi
.ft R
.IP
Generic client creation routine.
.I host
identifies the name of the remote host where the server
is located.
.I proto
indicates which kind of transport protocol to use. The
currently supported values for this field are \(lqudp\(rq
and \(lqtcp\(rq.
Default timeouts are set, but can be modified using
.BR clnt_control(\|) .
.IP
Warning: Using
.SM UDP
has its shortcomings.  Since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes of encoded data,
this transport cannot be used for procedures that take
large arguments or return huge results.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
bool_t
clnt_control(cl, req, info)
\s-1CLIENT\s0 *cl;
char *info;
.fi
.ft R
.IP
A macro used to change or retrieve various information
about a client object.
.I req
indicates the type of operation, and
.I info
is a pointer to the information. For both
.SM UDP
and
.SM TCP\s0,
the supported values of
.I req
and their argument types and what they do are:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_TIMEOUT\s0	struct timeval	set total timeout
.SM CLGET_TIMEOUT\s0	struct timeval	get total timeout
.fi
.IP
Note: if you set the timeout using
.BR clnt_control(\|) ,
the timeout parameter passed to
.B clnt_call(\|)
will be ignored in all future calls.
.IP
.nf
.SM CLGET_SERVER_ADDR\s0	struct sockaddr_in 	get server's address
.fi
.br
.IP
The following operations are valid for
.SM UDP
only:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_RETRY_TIMEOUT\s0		struct timeval	set the retry timeout
.SM CLGET_RETRY_TIMEOUT\s0		struct timeval	get the retry timeout
.fi
.br
.IP
The retry timeout is the time that
.SM "UDP RPC"
waits for the server to reply before
retransmitting the request.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
clnt_freeres(clnt, outproc, out)
\s-1CLIENT\s0 *clnt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the results of an
.SM RPC
call.  The
parameter
.I out
is the address of the results, and
.I outproc
is the
.SM XDR
routine describing the results.
This routine returns one if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
void
clnt_geterr(clnt, errp)
\s-1CLIENT\s0 *clnt;
struct rpc_err *errp;
.fi
.ft R
.IP
A macro that copies the error structure out of the client
handle
to the structure at address
.IR errp .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_pcreateerror(s)
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating
why a client
.SM RPC
handle could not be created.
The message is prepended with string
.I s
and a colon.
Used when a
.BR clnt_create(\|) ,
.BR clntraw_create(\|) ,
.BR clnttcp_create(\|) ,
or
.B clntudp_create(\|)
call fails.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_perrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Print a message to standard error corresponding
to the condition indicated by
.IR stat .
Used after
.BR callrpc(\|) .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
clnt_perror(clnt, s)
\s-1CLIENT\s0 *clnt;
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating why an
.SM RPC
call failed;
.I clnt
is the handle used to do the call.
The message is prepended with string
.I s
and a colon.
Used after
.BR clnt_call(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_spcreateerror
char *s;
.fi
.ft R
.IP
Like
.BR clnt_pcreateerror(\|) ,
except that it returns a string
instead of printing to the standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_sperrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Take the same arguments as
.BR clnt_perrno(\|) ,
but instead of sending a message to the standard error
indicating why an
.SM RPC
call failed, return a pointer to a string which contains
the message.  The string ends with a
.SM NEWLINE\s0.
.IP
.B clnt_sperrno(\|)
is used instead of
.B clnt_perrno(\|)
if the program does not have a standard error (as a program
running as a server quite likely does not), or if the
programmer
does not want the message to be output with
.BR printf ,
or if a message format different than that supported by
.B clnt_perrno(\|)
is to be used.
Note: unlike
.B clnt_sperror(\|)
and
.BR clnt_spcreaterror(\|) ,
.B clnt_sperrno(\|)
returns pointer to static data, but the
result will not get overwritten on each call.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
char *
clnt_sperror(rpch, s)
\s-1CLIENT\s0 *rpch;
char *s;
.fi
.ft R
.IP
Like
.BR clnt_perror(\|) ,
except that (like
.BR clnt_sperrno(\|) )
it returns a string instead of printing to standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntraw_create(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum .
The transport used to pass messages to the service is
actually a buffer within the process's address space, so the
corresponding
.SM RPC
server should live in the same address space; see
.BR svcraw_create(\|) .
This allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads, such as round trip times, without any
kernel interference. This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnttcp_create(addr, prognum, versnum, sockp, sendsz, recvsz)
struct sockaddr_in *addr;
u_long prognum, versnum;
int *sockp;
u_int sendsz, recvsz;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses
.SM TCP/IP
as a transport. The remote program is located at Internet
address
.IR *addr .
If
.\"The following in-line font conversion is necessary for the hyphen indicator
\fB\%addr\->sin_port\fR
is zero, then it is set to the actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
the user may specify the size of the send and receive buffers
with the parameters
.I sendsz
and
.IR recvsz ;
values of zero choose suitable defaults.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_create(addr, prognum, versnum, wait, sockp)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
Warning: since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes
of encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_bufcreate(addr, prognum, versnum, wait, sockp, sendsize, recosize)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
unsigned int sendsize;
unsigned int recosize;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
on
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.BR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
This allows the user to specify the maximun packet size for sending and receiving 
.SM UDP\s0-based
.SM RPC
messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
get_myaddress(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
Stuff the machine's
.SM IP
address into
.IR *addr ,
without consulting the library routines that deal with
.BR /etc/hosts .
The port number is always set to
.BR htons(\s-1PMAPPORT\s0) .
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
struct pmaplist *
pmap_getmaps(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns a list of the current
.SM RPC
program-to-port mappings
on the host located at
.SM IP
address
.IR *addr .
This routine can return
.SM NULL .
The command
.RB ` "rpcinfo \-p" '
uses this routine.
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
u_short
pmap_getport(addr, prognum, versnum, protocol)
struct sockaddr_in *addr;
u_long prognum, versnum, protocol;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns the port number
on which waits a service that supports program number
.IR prognum ,
version
.IR versnum ,
and speaks the transport protocol associated with
.IR protocol .
The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
A return value of zero means that the mapping does not exist
or that
the
.SM RPC
system failured to contact the remote
.B portmap
service.  In the latter case, the global variable
.B rpc_createerr(\|)
contains the
.SM RPC
status.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
enum clnt_stat
pmap_rmtcall(addr, prognum, versnum, procnum, inproc, in, outproc, out, tout, portp)
struct sockaddr_in *addr;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
struct timeval tout;
u_long *portp;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which instructs
.B portmap
on the host at
.SM IP
address
.I *addr
to make an
.SM RPC
call on your behalf to a procedure on that host.
The parameter
.I *portp
will be modified to the program's port number if the
procedure
succeeds. The definitions of other parameters are discussed
in
.B callrpc(\|)
and
.BR clnt_call(\|) .
This procedure should be used for a \(lqping\(rq and nothing
else.
See also
.BR clnt_broadcast(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
pmap_set(prognum, versnum, protocol, port)
u_long prognum, versnum, protocol;
u_short port;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which establishes a mapping between the triple
.RI [ prognum , versnum , protocol\fR]
and
.I port
on the machine's
.B portmap
service. The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
This routine returns one if it succeeds, zero otherwise.
Automatically done by
.BR svc_register(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
pmap_unset(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which destroys all mapping between the triple
.RI [ prognum , versnum , *\fR]
and
.B ports
on the machine's
.B portmap
service. This routine returns one if it succeeds, zero
otherwise.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
u_long prognum, versnum, procnum;
char *(*procname) (\|) ;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Register procedure
.I procname
with the
.SM RPC
service package.  If a request arrives for program
.IR prognum ,
version
.IR versnum ,
and procedure
.IR procnum ,
.I procname
is called with a pointer to its parameter(s);
.I progname
should return a pointer to its static result(s);
.I inproc
is used to decode the parameters while
.I outproc
is used to encode the results.
This routine returns zero if the registration succeeded, \-1
otherwise.
.IP
Warning: remote procedures registered in this form
are accessed using the
.SM UDP/IP
transport; see
.B svcudp_create(\|)
for restrictions.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
struct rpc_createerr     rpc_createerr;
.fi
.ft R
.IP
A global variable whose value is set by any
.SM RPC
client creation routine
that does not succeed.  Use the routine
.B clnt_pcreateerror(\|)
to print the reason why.
.if t .ne 7
.LP
.ft B
.nf
.sp .5
svc_destroy(xprt)
\s-1SVCXPRT\s0 *
xprt;
.fi
.ft R
.IP
A macro that destroys the
.SM RPC
service transport handle,
.IR xprt .
Destruction usually involves deallocation
of private data structures, including
.I xprt
itself.  Use of
.I xprt
is undefined after calling this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
fd_set svc_fdset;
.fi
.ft R
.IP
A global variable reflecting the
.SM RPC
service side's
read file descriptor bit mask; it is suitable as a parameter
to the
.B select
system call. This is only of interest
if a service implementor does not call
.BR svc_run(\|) ,
but rather does his own asynchronous event processing.
This variable is read-only (do not pass its address to
.BR select !),
yet it may change after calls to
.B svc_getreqset(\|)
or any creation routines.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
int svc_fds;
.fi
.ft R
.IP
Similar to
.BR svc_fedset(\|) ,
but limited to 32 descriptors. This
interface is obsoleted by
.BR svc_fdset(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_freeargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the arguments to a service procedure
using
.BR svc_getargs(\|) .
This routine returns 1 if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
svc_getargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that decodes the arguments of an
.SM RPC
request
associated with the
.SM RPC
service transport handle,
.IR xprt .
The parameter
.I in
is the address where the arguments will be placed;
.I inproc
is the
.SM XDR
routine used to decode the arguments.
This routine returns one if decoding succeeds, and zero
otherwise.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
struct sockaddr_in *
svc_getcaller(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
The approved way of getting the network address of the caller
of a procedure associated with the
.SM RPC
service transport handle,
.IR xprt .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_getreqset(rdfds)
fd_set *rdfds;
.fi
.ft R
.IP
This routine is only of interest if a service implementor
does not call
.BR svc_run(\|) ,
but instead implements custom asynchronous event processing.
It is called when the
.B select
system call has determined that an
.SM RPC
request has arrived on some
.SM RPC
.B socket(s) ;
.I rdfds
is the resultant read file descriptor bit mask.
The routine returns when all sockets associated with the
value of
.I rdfds
have been serviced.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_getreq(rdfds)
int rdfds;
.fi
.ft R
.IP
Similar to
.BR svc_getreqset(\|) ,
but limited to 32 descriptors. This interface is obsoleted by
.BR svc_getreqset(\|) .
.br
.if t .ne 17
.LP
.ft B
.nf
.sp .5
svc_register(xprt, prognum, versnum, dispatch, protocol)
\s-1SVCXPRT\s0 *xprt;
u_long prognum, versnum;
void (*dispatch) (\|);
u_long protocol;
.fi
.ft R
.IP
Associates
.I prognum
and
.I versnum
with the service dispatch procedure,
.IR dispatch .
If
.I protocol
is zero, the service is not registered with the
.B portmap
service.  If
.I protocol
is non-zero, then a mapping of the triple
.RI [ prognum , versnum , protocol\fR]
to
\fB\%xprt\->xp_port\fR
is established with the local
.B portmap
service (generally
.I protocol
is zero,
.B
.SM IPPROTO_UDP
or 
.B
.SM IPPROTO_TCP
).
The procedure
.I dispatch
has the following form:
.RS 1i
.ft B
.nf
dispatch(request, xprt)
struct svc_req *request;
\s-1SVCXPRT\s0 *xprt;
.ft R
.fi
.RE
.IP
The
.B svc_register(\|)
routine returns one if it succeeds, and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_run(\|)
.fi
.ft R
.IP
This routine never returns. It waits for
.SM RPC
requests to arrive, and calls the appropriate service
procedure using
.B svc_getreq(\|)
when one arrives. This procedure is usually waiting for a
.B select(\|)
system call to return.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_sendreply(xprt, outproc, out)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
Called by an
.SM RPC
service's dispatch routine to send the results of a
remote procedure call.  The parameter
.I xprt
is the request's associated transport handle;
.I outproc
is the
.SM XDR
routine which is used to encode the results; and
.I out
is the address of the results.
This routine returns one if it succeeds, zero otherwise.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svc_unregister(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
Remove all mapping of the double
.RI [ prognum , versnum ]
to dispatch routines, and of the triple
.RI [ prognum , versnum , *\fR]
to port number.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
svcerr_auth(xprt, why)
\s-1SVCXPRT\s0 *xprt;
enum auth_stat why;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to an authentication error.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_decode(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that cannot successfully
decode its parameters. See also
.BR svc_getargs(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noproc(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that does not implement
the procedure number that the caller requests.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noprog(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired program is not registered with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_progvers(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired version of a program is not registered
with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_systemerr(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine when it detects a system
error
not covered by any particular protocol.
For example, if a service can no longer allocate storage,
it may call this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
svcerr_weakauth(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to insufficient
authentication parameters.  The routine calls
.BR "svcerr_auth(xprt, \s-1AUTH_TOOWEAK\s0)" .
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcraw_create(\|)
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
service transport, to which it returns a pointer.  The
transport
is really a buffer within the process's address space,
so the corresponding
.SM RPC
client should live in the same
address space;
see
.BR clntraw_create(\|) .
This routine allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads (such as round trip times), without any kernel
interference.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svctcp_create(sock, send_buf_size, recv_buf_size)
int sock;
u_int send_buf_size, recv_buf_size;
.fi
.ft R
.IP
This routine creates a
.SM TCP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.BR \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM TCP
port, then this routine binds it to an arbitrary port.  Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails. Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
users may specify the size of buffers; values of zero
choose suitable defaults.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcfd_create(fd, sendsize, recvsize)
int fd;
u_int sendsize;
u_int recvsize;
.fi
.ft R
.IP
Create a service on top of any open descriptor. Typically,
this
descriptor is a connected socket for a stream protocol such
as
.SM TCP\s0.
.I sendsize
and
.I recvsize
indicate sizes for the send and receive buffers.  If they are
zero, a reasonable default is chosen.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcudp_bufcreate(sock, sendsize, recosize)
int sock;
.fi
.ft R
.IP
This routine creates a
.SM UDP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.B \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM UDP
port, then this routine binds it to an arbitrary port. Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails.
.IP
This allows the user to specify the maximun packet size for sending and 
receiving
.SM UDP\s0-based
.SM RPC messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_accepted_reply(xdrs, ar)
\s-1XDR\s0 *xdrs;
struct accepted_reply *ar;
.fi
.ft R
.IP
Used for encoding
.SM RPC
reply messages. This routine is useful for users who
wish to generate
\s-1RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_authunix_parms(xdrs, aupp)
\s-1XDR\s0 *xdrs;
struct authunix_parms *aupp;
.fi
.ft R
.IP
Used for describing
.SM UNIX
credentials. This routine is useful for users
who wish to generate these credentials without using the
.SM RPC
authentication package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
xdr_callhdr(xdrs, chdr)
\s-1XDR\s0 *xdrs;
struct rpc_msg *chdr;
.fi
.ft R
.IP
Used for describing
.SM RPC
call header messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_callmsg(xdrs, cmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *cmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
call messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_opaque_auth(xdrs, ap)
\s-1XDR\s0 *xdrs;
struct opaque_auth *ap;
.fi
.ft R
.IP
Used for describing
.SM RPC
authentication information messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmap(xdrs, regs)
\s-1XDR\s0 *xdrs;
struct pmap *regs;
.fi
.ft R
.IP
Used for describing parameters to various
.B portmap
procedures, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmaplist(xdrs, rp)
\s-1XDR\s0 *xdrs;
struct pmaplist **rp;
.fi
.ft R
.IP
Used for describing a list of port mappings, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_rejected_reply(xdrs, rr)
\s-1XDR\s0 *xdrs;
struct rejected_reply *rr;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_replymsg(xdrs, rmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *rmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC
style messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_register(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
After
.SM RPC
service transport handles are created,
they should register themselves with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_unregister(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Before an
.SM RPC
service transport handle is destroyed,
it should unregister itself with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.SH SEE ALSO
.BR rpc_secure (3N),
.BR xdr (3N)
.br
The following manuals:
.RS
.ft I
Remote Procedure Calls: Protocol Specification
.br
Remote Procedure Call Programming Guide
.br
rpcgen Programming Guide
.br
.ft R
.RE
.IR "\s-1RPC\s0: Remote Procedure Call Protocol Specification" ,
.SM RFC1050, Sun Microsystems, Inc.,
.SM USC-ISI\s0.

                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/clnt_call.3                                  0100644 0001750 0001750 00000073141 12566167025 022707  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"	from: @(#)rpc.3n	2.4 88/08/08 4.0 RPCSRC; from 1.19 88/06/24 SMI
.\"	$Id: rpc.3,v 1.1 1999/04/13 23:15:37 wsanchez Exp $
.\"
.TH RPC 3N "16 February 1988"
.SH NAME
rpc \- library routines for remote procedure calls
.SH SYNOPSIS AND DESCRIPTION
These routines allow C programs to make procedure
calls on other machines across the network.
First, the client calls a procedure to send a
data packet to the server.
Upon receipt of the packet, the server calls a dispatch routine
to perform the requested service, and then sends back a
reply.
Finally, the procedure call returns to the client.
.LP
Routines that are used for Secure RPC (DES authentication) are described in
.BR rpc_secure (3N).
Secure RPC can be used only if DES encryption is available.
.LP
.ft B
.nf
.sp .5
#include <rpc/rpc.h>
.fi
.ft R
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
auth_destroy(auth)
\s-1AUTH\s0 *auth;
.fi
.ft R
.IP
A macro that destroys the authentication information associated with
.IR auth .
Destruction usually involves deallocation of private data
structures. The use of
.I auth
is undefined after calling
.BR auth_destroy(\|) .
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authnone_create(\|)
.fi
.ft R
.IP
Create and returns an
.SM RPC
authentication handle that passes nonusable authentication
information with each remote procedure call. This is the
default authentication used by
.SM RPC.
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create(host, uid, gid, len, aup_gids)
char *host;
int uid, gid, len, *aup.gids;
.fi
.ft R
.IP
Create and return an
.SM RPC
authentication handle that contains
.UX
authentication information.
The parameter
.I host
is the name of the machine on which the information was
created;
.I uid
is the user's user
.SM ID ;
.I gid
is the user's current group
.SM ID ;
.I len
and
.I aup_gids
refer to a counted array of groups to which the user belongs.
It is easy to impersonate a user.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create_default(\|)
.fi
.ft R
.IP
Calls
.B authunix_create(\|)
with the appropriate parameters.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
char *host;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Call the remote procedure associated with
.IR prognum ,
.IR versnum ,
and
.I procnum
on the machine,
.IR host .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results.
This routine returns zero if it succeeds, or the value of
.B "enum clnt_stat"
cast to an integer if it fails.
The routine
.B clnt_perrno(\|)
is handy for translating failure statuses into messages.
.IP
Warning: calling remote procedures with this routine
uses
.SM UDP/IP
as a transport; see
.B clntudp_create(\|)
for restrictions.
You do not have control of timeouts or authentication using
this routine.
.br
.if t .ne 16
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_broadcast(prognum, versnum, procnum, inproc, in, outproc, out, eachresult)
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
resultproc_t eachresult;
.fi
.ft R
.IP
Like
.BR callrpc(\|) ,
except the call message is broadcast to all locally
connected broadcast nets. Each time it receives a
response, this routine calls
.BR eachresult(\|) ,
whose form is:
.IP
.RS 1i
.ft B
.nf
eachresult(out, addr)
char *out;
struct sockaddr_in *addr;
.ft R
.fi
.RE
.IP
where
.I out
is the same as
.I out
passed to
.BR clnt_broadcast(\|) ,
except that the remote procedure's output is decoded there;
.I addr
points to the address of the machine that sent the results.
If
.B eachresult(\|)
returns zero,
.B clnt_broadcast(\|)
waits for more replies; otherwise it returns with appropriate
status.
.IP
Warning: broadcast sockets are limited in size to the
maximum transfer unit of the data link. For ethernet,
this value is 1500 bytes.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_call(clnt, procnum, inproc, in, outproc, out, tout)
\s-1CLIENT\s0 *clnt;
u_long
procnum;
xdrproc_t inproc, outproc;
char *in, *out;
struct timeval tout;
.fi
.ft R
.IP
A macro that calls the remote procedure
.I procnum
associated with the client handle,
.IR clnt ,
which is obtained with an
.SM RPC
client creation routine such as
.BR clnt_create(\|) .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results;
.I tout
is the time allowed for results to come back.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
clnt_destroy(clnt)
\s-1CLIENT\s0 *clnt;
.fi
.ft R
.IP
A macro that destroys the client's
.SM RPC
handle. Destruction usually involves deallocation
of private data structures, including
.I clnt
itself.  Use of
.I clnt
is undefined after calling
.BR clnt_destroy(\|) .
If the
.SM RPC
library opened the associated socket, it will close it also.
Otherwise, the socket remains open.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnt_create(host, prog, vers, proto)
char *host;
u_long prog, vers;
char *proto;
.fi
.ft R
.IP
Generic client creation routine.
.I host
identifies the name of the remote host where the server
is located.
.I proto
indicates which kind of transport protocol to use. The
currently supported values for this field are \(lqudp\(rq
and \(lqtcp\(rq.
Default timeouts are set, but can be modified using
.BR clnt_control(\|) .
.IP
Warning: Using
.SM UDP
has its shortcomings.  Since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes of encoded data,
this transport cannot be used for procedures that take
large arguments or return huge results.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
bool_t
clnt_control(cl, req, info)
\s-1CLIENT\s0 *cl;
char *info;
.fi
.ft R
.IP
A macro used to change or retrieve various information
about a client object.
.I req
indicates the type of operation, and
.I info
is a pointer to the information. For both
.SM UDP
and
.SM TCP\s0,
the supported values of
.I req
and their argument types and what they do are:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_TIMEOUT\s0	struct timeval	set total timeout
.SM CLGET_TIMEOUT\s0	struct timeval	get total timeout
.fi
.IP
Note: if you set the timeout using
.BR clnt_control(\|) ,
the timeout parameter passed to
.B clnt_call(\|)
will be ignored in all future calls.
.IP
.nf
.SM CLGET_SERVER_ADDR\s0	struct sockaddr_in 	get server's address
.fi
.br
.IP
The following operations are valid for
.SM UDP
only:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_RETRY_TIMEOUT\s0		struct timeval	set the retry timeout
.SM CLGET_RETRY_TIMEOUT\s0		struct timeval	get the retry timeout
.fi
.br
.IP
The retry timeout is the time that
.SM "UDP RPC"
waits for the server to reply before
retransmitting the request.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
clnt_freeres(clnt, outproc, out)
\s-1CLIENT\s0 *clnt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the results of an
.SM RPC
call.  The
parameter
.I out
is the address of the results, and
.I outproc
is the
.SM XDR
routine describing the results.
This routine returns one if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
void
clnt_geterr(clnt, errp)
\s-1CLIENT\s0 *clnt;
struct rpc_err *errp;
.fi
.ft R
.IP
A macro that copies the error structure out of the client
handle
to the structure at address
.IR errp .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_pcreateerror(s)
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating
why a client
.SM RPC
handle could not be created.
The message is prepended with string
.I s
and a colon.
Used when a
.BR clnt_create(\|) ,
.BR clntraw_create(\|) ,
.BR clnttcp_create(\|) ,
or
.B clntudp_create(\|)
call fails.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_perrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Print a message to standard error corresponding
to the condition indicated by
.IR stat .
Used after
.BR callrpc(\|) .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
clnt_perror(clnt, s)
\s-1CLIENT\s0 *clnt;
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating why an
.SM RPC
call failed;
.I clnt
is the handle used to do the call.
The message is prepended with string
.I s
and a colon.
Used after
.BR clnt_call(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_spcreateerror
char *s;
.fi
.ft R
.IP
Like
.BR clnt_pcreateerror(\|) ,
except that it returns a string
instead of printing to the standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_sperrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Take the same arguments as
.BR clnt_perrno(\|) ,
but instead of sending a message to the standard error
indicating why an
.SM RPC
call failed, return a pointer to a string which contains
the message.  The string ends with a
.SM NEWLINE\s0.
.IP
.B clnt_sperrno(\|)
is used instead of
.B clnt_perrno(\|)
if the program does not have a standard error (as a program
running as a server quite likely does not), or if the
programmer
does not want the message to be output with
.BR printf ,
or if a message format different than that supported by
.B clnt_perrno(\|)
is to be used.
Note: unlike
.B clnt_sperror(\|)
and
.BR clnt_spcreaterror(\|) ,
.B clnt_sperrno(\|)
returns pointer to static data, but the
result will not get overwritten on each call.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
char *
clnt_sperror(rpch, s)
\s-1CLIENT\s0 *rpch;
char *s;
.fi
.ft R
.IP
Like
.BR clnt_perror(\|) ,
except that (like
.BR clnt_sperrno(\|) )
it returns a string instead of printing to standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntraw_create(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum .
The transport used to pass messages to the service is
actually a buffer within the process's address space, so the
corresponding
.SM RPC
server should live in the same address space; see
.BR svcraw_create(\|) .
This allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads, such as round trip times, without any
kernel interference. This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnttcp_create(addr, prognum, versnum, sockp, sendsz, recvsz)
struct sockaddr_in *addr;
u_long prognum, versnum;
int *sockp;
u_int sendsz, recvsz;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses
.SM TCP/IP
as a transport. The remote program is located at Internet
address
.IR *addr .
If
.\"The following in-line font conversion is necessary for the hyphen indicator
\fB\%addr\->sin_port\fR
is zero, then it is set to the actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
the user may specify the size of the send and receive buffers
with the parameters
.I sendsz
and
.IR recvsz ;
values of zero choose suitable defaults.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_create(addr, prognum, versnum, wait, sockp)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
Warning: since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes
of encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_bufcreate(addr, prognum, versnum, wait, sockp, sendsize, recosize)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
unsigned int sendsize;
unsigned int recosize;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
on
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.BR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
This allows the user to specify the maximun packet size for sending and receiving 
.SM UDP\s0-based
.SM RPC
messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
get_myaddress(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
Stuff the machine's
.SM IP
address into
.IR *addr ,
without consulting the library routines that deal with
.BR /etc/hosts .
The port number is always set to
.BR htons(\s-1PMAPPORT\s0) .
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
struct pmaplist *
pmap_getmaps(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns a list of the current
.SM RPC
program-to-port mappings
on the host located at
.SM IP
address
.IR *addr .
This routine can return
.SM NULL .
The command
.RB ` "rpcinfo \-p" '
uses this routine.
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
u_short
pmap_getport(addr, prognum, versnum, protocol)
struct sockaddr_in *addr;
u_long prognum, versnum, protocol;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns the port number
on which waits a service that supports program number
.IR prognum ,
version
.IR versnum ,
and speaks the transport protocol associated with
.IR protocol .
The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
A return value of zero means that the mapping does not exist
or that
the
.SM RPC
system failured to contact the remote
.B portmap
service.  In the latter case, the global variable
.B rpc_createerr(\|)
contains the
.SM RPC
status.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
enum clnt_stat
pmap_rmtcall(addr, prognum, versnum, procnum, inproc, in, outproc, out, tout, portp)
struct sockaddr_in *addr;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
struct timeval tout;
u_long *portp;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which instructs
.B portmap
on the host at
.SM IP
address
.I *addr
to make an
.SM RPC
call on your behalf to a procedure on that host.
The parameter
.I *portp
will be modified to the program's port number if the
procedure
succeeds. The definitions of other parameters are discussed
in
.B callrpc(\|)
and
.BR clnt_call(\|) .
This procedure should be used for a \(lqping\(rq and nothing
else.
See also
.BR clnt_broadcast(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
pmap_set(prognum, versnum, protocol, port)
u_long prognum, versnum, protocol;
u_short port;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which establishes a mapping between the triple
.RI [ prognum , versnum , protocol\fR]
and
.I port
on the machine's
.B portmap
service. The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
This routine returns one if it succeeds, zero otherwise.
Automatically done by
.BR svc_register(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
pmap_unset(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which destroys all mapping between the triple
.RI [ prognum , versnum , *\fR]
and
.B ports
on the machine's
.B portmap
service. This routine returns one if it succeeds, zero
otherwise.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
u_long prognum, versnum, procnum;
char *(*procname) (\|) ;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Register procedure
.I procname
with the
.SM RPC
service package.  If a request arrives for program
.IR prognum ,
version
.IR versnum ,
and procedure
.IR procnum ,
.I procname
is called with a pointer to its parameter(s);
.I progname
should return a pointer to its static result(s);
.I inproc
is used to decode the parameters while
.I outproc
is used to encode the results.
This routine returns zero if the registration succeeded, \-1
otherwise.
.IP
Warning: remote procedures registered in this form
are accessed using the
.SM UDP/IP
transport; see
.B svcudp_create(\|)
for restrictions.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
struct rpc_createerr     rpc_createerr;
.fi
.ft R
.IP
A global variable whose value is set by any
.SM RPC
client creation routine
that does not succeed.  Use the routine
.B clnt_pcreateerror(\|)
to print the reason why.
.if t .ne 7
.LP
.ft B
.nf
.sp .5
svc_destroy(xprt)
\s-1SVCXPRT\s0 *
xprt;
.fi
.ft R
.IP
A macro that destroys the
.SM RPC
service transport handle,
.IR xprt .
Destruction usually involves deallocation
of private data structures, including
.I xprt
itself.  Use of
.I xprt
is undefined after calling this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
fd_set svc_fdset;
.fi
.ft R
.IP
A global variable reflecting the
.SM RPC
service side's
read file descriptor bit mask; it is suitable as a parameter
to the
.B select
system call. This is only of interest
if a service implementor does not call
.BR svc_run(\|) ,
but rather does his own asynchronous event processing.
This variable is read-only (do not pass its address to
.BR select !),
yet it may change after calls to
.B svc_getreqset(\|)
or any creation routines.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
int svc_fds;
.fi
.ft R
.IP
Similar to
.BR svc_fedset(\|) ,
but limited to 32 descriptors. This
interface is obsoleted by
.BR svc_fdset(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_freeargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the arguments to a service procedure
using
.BR svc_getargs(\|) .
This routine returns 1 if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
svc_getargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that decodes the arguments of an
.SM RPC
request
associated with the
.SM RPC
service transport handle,
.IR xprt .
The parameter
.I in
is the address where the arguments will be placed;
.I inproc
is the
.SM XDR
routine used to decode the arguments.
This routine returns one if decoding succeeds, and zero
otherwise.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
struct sockaddr_in *
svc_getcaller(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
The approved way of getting the network address of the caller
of a procedure associated with the
.SM RPC
service transport handle,
.IR xprt .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_getreqset(rdfds)
fd_set *rdfds;
.fi
.ft R
.IP
This routine is only of interest if a service implementor
does not call
.BR svc_run(\|) ,
but instead implements custom asynchronous event processing.
It is called when the
.B select
system call has determined that an
.SM RPC
request has arrived on some
.SM RPC
.B socket(s) ;
.I rdfds
is the resultant read file descriptor bit mask.
The routine returns when all sockets associated with the
value of
.I rdfds
have been serviced.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_getreq(rdfds)
int rdfds;
.fi
.ft R
.IP
Similar to
.BR svc_getreqset(\|) ,
but limited to 32 descriptors. This interface is obsoleted by
.BR svc_getreqset(\|) .
.br
.if t .ne 17
.LP
.ft B
.nf
.sp .5
svc_register(xprt, prognum, versnum, dispatch, protocol)
\s-1SVCXPRT\s0 *xprt;
u_long prognum, versnum;
void (*dispatch) (\|);
u_long protocol;
.fi
.ft R
.IP
Associates
.I prognum
and
.I versnum
with the service dispatch procedure,
.IR dispatch .
If
.I protocol
is zero, the service is not registered with the
.B portmap
service.  If
.I protocol
is non-zero, then a mapping of the triple
.RI [ prognum , versnum , protocol\fR]
to
\fB\%xprt\->xp_port\fR
is established with the local
.B portmap
service (generally
.I protocol
is zero,
.B
.SM IPPROTO_UDP
or 
.B
.SM IPPROTO_TCP
).
The procedure
.I dispatch
has the following form:
.RS 1i
.ft B
.nf
dispatch(request, xprt)
struct svc_req *request;
\s-1SVCXPRT\s0 *xprt;
.ft R
.fi
.RE
.IP
The
.B svc_register(\|)
routine returns one if it succeeds, and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_run(\|)
.fi
.ft R
.IP
This routine never returns. It waits for
.SM RPC
requests to arrive, and calls the appropriate service
procedure using
.B svc_getreq(\|)
when one arrives. This procedure is usually waiting for a
.B select(\|)
system call to return.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_sendreply(xprt, outproc, out)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
Called by an
.SM RPC
service's dispatch routine to send the results of a
remote procedure call.  The parameter
.I xprt
is the request's associated transport handle;
.I outproc
is the
.SM XDR
routine which is used to encode the results; and
.I out
is the address of the results.
This routine returns one if it succeeds, zero otherwise.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svc_unregister(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
Remove all mapping of the double
.RI [ prognum , versnum ]
to dispatch routines, and of the triple
.RI [ prognum , versnum , *\fR]
to port number.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
svcerr_auth(xprt, why)
\s-1SVCXPRT\s0 *xprt;
enum auth_stat why;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to an authentication error.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_decode(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that cannot successfully
decode its parameters. See also
.BR svc_getargs(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noproc(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that does not implement
the procedure number that the caller requests.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noprog(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired program is not registered with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_progvers(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired version of a program is not registered
with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_systemerr(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine when it detects a system
error
not covered by any particular protocol.
For example, if a service can no longer allocate storage,
it may call this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
svcerr_weakauth(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to insufficient
authentication parameters.  The routine calls
.BR "svcerr_auth(xprt, \s-1AUTH_TOOWEAK\s0)" .
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcraw_create(\|)
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
service transport, to which it returns a pointer.  The
transport
is really a buffer within the process's address space,
so the corresponding
.SM RPC
client should live in the same
address space;
see
.BR clntraw_create(\|) .
This routine allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads (such as round trip times), without any kernel
interference.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svctcp_create(sock, send_buf_size, recv_buf_size)
int sock;
u_int send_buf_size, recv_buf_size;
.fi
.ft R
.IP
This routine creates a
.SM TCP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.BR \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM TCP
port, then this routine binds it to an arbitrary port.  Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails. Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
users may specify the size of buffers; values of zero
choose suitable defaults.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcfd_create(fd, sendsize, recvsize)
int fd;
u_int sendsize;
u_int recvsize;
.fi
.ft R
.IP
Create a service on top of any open descriptor. Typically,
this
descriptor is a connected socket for a stream protocol such
as
.SM TCP\s0.
.I sendsize
and
.I recvsize
indicate sizes for the send and receive buffers.  If they are
zero, a reasonable default is chosen.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcudp_bufcreate(sock, sendsize, recosize)
int sock;
.fi
.ft R
.IP
This routine creates a
.SM UDP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.B \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM UDP
port, then this routine binds it to an arbitrary port. Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails.
.IP
This allows the user to specify the maximun packet size for sending and 
receiving
.SM UDP\s0-based
.SM RPC messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_accepted_reply(xdrs, ar)
\s-1XDR\s0 *xdrs;
struct accepted_reply *ar;
.fi
.ft R
.IP
Used for encoding
.SM RPC
reply messages. This routine is useful for users who
wish to generate
\s-1RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_authunix_parms(xdrs, aupp)
\s-1XDR\s0 *xdrs;
struct authunix_parms *aupp;
.fi
.ft R
.IP
Used for describing
.SM UNIX
credentials. This routine is useful for users
who wish to generate these credentials without using the
.SM RPC
authentication package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
xdr_callhdr(xdrs, chdr)
\s-1XDR\s0 *xdrs;
struct rpc_msg *chdr;
.fi
.ft R
.IP
Used for describing
.SM RPC
call header messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_callmsg(xdrs, cmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *cmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
call messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_opaque_auth(xdrs, ap)
\s-1XDR\s0 *xdrs;
struct opaque_auth *ap;
.fi
.ft R
.IP
Used for describing
.SM RPC
authentication information messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmap(xdrs, regs)
\s-1XDR\s0 *xdrs;
struct pmap *regs;
.fi
.ft R
.IP
Used for describing parameters to various
.B portmap
procedures, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmaplist(xdrs, rp)
\s-1XDR\s0 *xdrs;
struct pmaplist **rp;
.fi
.ft R
.IP
Used for describing a list of port mappings, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_rejected_reply(xdrs, rr)
\s-1XDR\s0 *xdrs;
struct rejected_reply *rr;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_replymsg(xdrs, rmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *rmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC
style messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_register(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
After
.SM RPC
service transport handles are created,
they should register themselves with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_unregister(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Before an
.SM RPC
service transport handle is destroyed,
it should unregister itself with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.SH SEE ALSO
.BR rpc_secure (3N),
.BR xdr (3N)
.br
The following manuals:
.RS
.ft I
Remote Procedure Calls: Protocol Specification
.br
Remote Procedure Call Programming Guide
.br
rpcgen Programming Guide
.br
.ft R
.RE
.IR "\s-1RPC\s0: Remote Procedure Call Protocol Specification" ,
.SM RFC1050, Sun Microsystems, Inc.,
.SM USC-ISI\s0.

                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/clnt_control.3                               0100644 0001750 0001750 00000073141 12566167025 023454  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"	from: @(#)rpc.3n	2.4 88/08/08 4.0 RPCSRC; from 1.19 88/06/24 SMI
.\"	$Id: rpc.3,v 1.1 1999/04/13 23:15:37 wsanchez Exp $
.\"
.TH RPC 3N "16 February 1988"
.SH NAME
rpc \- library routines for remote procedure calls
.SH SYNOPSIS AND DESCRIPTION
These routines allow C programs to make procedure
calls on other machines across the network.
First, the client calls a procedure to send a
data packet to the server.
Upon receipt of the packet, the server calls a dispatch routine
to perform the requested service, and then sends back a
reply.
Finally, the procedure call returns to the client.
.LP
Routines that are used for Secure RPC (DES authentication) are described in
.BR rpc_secure (3N).
Secure RPC can be used only if DES encryption is available.
.LP
.ft B
.nf
.sp .5
#include <rpc/rpc.h>
.fi
.ft R
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
auth_destroy(auth)
\s-1AUTH\s0 *auth;
.fi
.ft R
.IP
A macro that destroys the authentication information associated with
.IR auth .
Destruction usually involves deallocation of private data
structures. The use of
.I auth
is undefined after calling
.BR auth_destroy(\|) .
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authnone_create(\|)
.fi
.ft R
.IP
Create and returns an
.SM RPC
authentication handle that passes nonusable authentication
information with each remote procedure call. This is the
default authentication used by
.SM RPC.
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create(host, uid, gid, len, aup_gids)
char *host;
int uid, gid, len, *aup.gids;
.fi
.ft R
.IP
Create and return an
.SM RPC
authentication handle that contains
.UX
authentication information.
The parameter
.I host
is the name of the machine on which the information was
created;
.I uid
is the user's user
.SM ID ;
.I gid
is the user's current group
.SM ID ;
.I len
and
.I aup_gids
refer to a counted array of groups to which the user belongs.
It is easy to impersonate a user.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create_default(\|)
.fi
.ft R
.IP
Calls
.B authunix_create(\|)
with the appropriate parameters.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
char *host;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Call the remote procedure associated with
.IR prognum ,
.IR versnum ,
and
.I procnum
on the machine,
.IR host .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results.
This routine returns zero if it succeeds, or the value of
.B "enum clnt_stat"
cast to an integer if it fails.
The routine
.B clnt_perrno(\|)
is handy for translating failure statuses into messages.
.IP
Warning: calling remote procedures with this routine
uses
.SM UDP/IP
as a transport; see
.B clntudp_create(\|)
for restrictions.
You do not have control of timeouts or authentication using
this routine.
.br
.if t .ne 16
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_broadcast(prognum, versnum, procnum, inproc, in, outproc, out, eachresult)
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
resultproc_t eachresult;
.fi
.ft R
.IP
Like
.BR callrpc(\|) ,
except the call message is broadcast to all locally
connected broadcast nets. Each time it receives a
response, this routine calls
.BR eachresult(\|) ,
whose form is:
.IP
.RS 1i
.ft B
.nf
eachresult(out, addr)
char *out;
struct sockaddr_in *addr;
.ft R
.fi
.RE
.IP
where
.I out
is the same as
.I out
passed to
.BR clnt_broadcast(\|) ,
except that the remote procedure's output is decoded there;
.I addr
points to the address of the machine that sent the results.
If
.B eachresult(\|)
returns zero,
.B clnt_broadcast(\|)
waits for more replies; otherwise it returns with appropriate
status.
.IP
Warning: broadcast sockets are limited in size to the
maximum transfer unit of the data link. For ethernet,
this value is 1500 bytes.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_call(clnt, procnum, inproc, in, outproc, out, tout)
\s-1CLIENT\s0 *clnt;
u_long
procnum;
xdrproc_t inproc, outproc;
char *in, *out;
struct timeval tout;
.fi
.ft R
.IP
A macro that calls the remote procedure
.I procnum
associated with the client handle,
.IR clnt ,
which is obtained with an
.SM RPC
client creation routine such as
.BR clnt_create(\|) .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results;
.I tout
is the time allowed for results to come back.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
clnt_destroy(clnt)
\s-1CLIENT\s0 *clnt;
.fi
.ft R
.IP
A macro that destroys the client's
.SM RPC
handle. Destruction usually involves deallocation
of private data structures, including
.I clnt
itself.  Use of
.I clnt
is undefined after calling
.BR clnt_destroy(\|) .
If the
.SM RPC
library opened the associated socket, it will close it also.
Otherwise, the socket remains open.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnt_create(host, prog, vers, proto)
char *host;
u_long prog, vers;
char *proto;
.fi
.ft R
.IP
Generic client creation routine.
.I host
identifies the name of the remote host where the server
is located.
.I proto
indicates which kind of transport protocol to use. The
currently supported values for this field are \(lqudp\(rq
and \(lqtcp\(rq.
Default timeouts are set, but can be modified using
.BR clnt_control(\|) .
.IP
Warning: Using
.SM UDP
has its shortcomings.  Since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes of encoded data,
this transport cannot be used for procedures that take
large arguments or return huge results.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
bool_t
clnt_control(cl, req, info)
\s-1CLIENT\s0 *cl;
char *info;
.fi
.ft R
.IP
A macro used to change or retrieve various information
about a client object.
.I req
indicates the type of operation, and
.I info
is a pointer to the information. For both
.SM UDP
and
.SM TCP\s0,
the supported values of
.I req
and their argument types and what they do are:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_TIMEOUT\s0	struct timeval	set total timeout
.SM CLGET_TIMEOUT\s0	struct timeval	get total timeout
.fi
.IP
Note: if you set the timeout using
.BR clnt_control(\|) ,
the timeout parameter passed to
.B clnt_call(\|)
will be ignored in all future calls.
.IP
.nf
.SM CLGET_SERVER_ADDR\s0	struct sockaddr_in 	get server's address
.fi
.br
.IP
The following operations are valid for
.SM UDP
only:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_RETRY_TIMEOUT\s0		struct timeval	set the retry timeout
.SM CLGET_RETRY_TIMEOUT\s0		struct timeval	get the retry timeout
.fi
.br
.IP
The retry timeout is the time that
.SM "UDP RPC"
waits for the server to reply before
retransmitting the request.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
clnt_freeres(clnt, outproc, out)
\s-1CLIENT\s0 *clnt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the results of an
.SM RPC
call.  The
parameter
.I out
is the address of the results, and
.I outproc
is the
.SM XDR
routine describing the results.
This routine returns one if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
void
clnt_geterr(clnt, errp)
\s-1CLIENT\s0 *clnt;
struct rpc_err *errp;
.fi
.ft R
.IP
A macro that copies the error structure out of the client
handle
to the structure at address
.IR errp .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_pcreateerror(s)
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating
why a client
.SM RPC
handle could not be created.
The message is prepended with string
.I s
and a colon.
Used when a
.BR clnt_create(\|) ,
.BR clntraw_create(\|) ,
.BR clnttcp_create(\|) ,
or
.B clntudp_create(\|)
call fails.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_perrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Print a message to standard error corresponding
to the condition indicated by
.IR stat .
Used after
.BR callrpc(\|) .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
clnt_perror(clnt, s)
\s-1CLIENT\s0 *clnt;
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating why an
.SM RPC
call failed;
.I clnt
is the handle used to do the call.
The message is prepended with string
.I s
and a colon.
Used after
.BR clnt_call(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_spcreateerror
char *s;
.fi
.ft R
.IP
Like
.BR clnt_pcreateerror(\|) ,
except that it returns a string
instead of printing to the standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_sperrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Take the same arguments as
.BR clnt_perrno(\|) ,
but instead of sending a message to the standard error
indicating why an
.SM RPC
call failed, return a pointer to a string which contains
the message.  The string ends with a
.SM NEWLINE\s0.
.IP
.B clnt_sperrno(\|)
is used instead of
.B clnt_perrno(\|)
if the program does not have a standard error (as a program
running as a server quite likely does not), or if the
programmer
does not want the message to be output with
.BR printf ,
or if a message format different than that supported by
.B clnt_perrno(\|)
is to be used.
Note: unlike
.B clnt_sperror(\|)
and
.BR clnt_spcreaterror(\|) ,
.B clnt_sperrno(\|)
returns pointer to static data, but the
result will not get overwritten on each call.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
char *
clnt_sperror(rpch, s)
\s-1CLIENT\s0 *rpch;
char *s;
.fi
.ft R
.IP
Like
.BR clnt_perror(\|) ,
except that (like
.BR clnt_sperrno(\|) )
it returns a string instead of printing to standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntraw_create(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum .
The transport used to pass messages to the service is
actually a buffer within the process's address space, so the
corresponding
.SM RPC
server should live in the same address space; see
.BR svcraw_create(\|) .
This allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads, such as round trip times, without any
kernel interference. This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnttcp_create(addr, prognum, versnum, sockp, sendsz, recvsz)
struct sockaddr_in *addr;
u_long prognum, versnum;
int *sockp;
u_int sendsz, recvsz;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses
.SM TCP/IP
as a transport. The remote program is located at Internet
address
.IR *addr .
If
.\"The following in-line font conversion is necessary for the hyphen indicator
\fB\%addr\->sin_port\fR
is zero, then it is set to the actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
the user may specify the size of the send and receive buffers
with the parameters
.I sendsz
and
.IR recvsz ;
values of zero choose suitable defaults.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_create(addr, prognum, versnum, wait, sockp)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
Warning: since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes
of encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_bufcreate(addr, prognum, versnum, wait, sockp, sendsize, recosize)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
unsigned int sendsize;
unsigned int recosize;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
on
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.BR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
This allows the user to specify the maximun packet size for sending and receiving 
.SM UDP\s0-based
.SM RPC
messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
get_myaddress(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
Stuff the machine's
.SM IP
address into
.IR *addr ,
without consulting the library routines that deal with
.BR /etc/hosts .
The port number is always set to
.BR htons(\s-1PMAPPORT\s0) .
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
struct pmaplist *
pmap_getmaps(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns a list of the current
.SM RPC
program-to-port mappings
on the host located at
.SM IP
address
.IR *addr .
This routine can return
.SM NULL .
The command
.RB ` "rpcinfo \-p" '
uses this routine.
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
u_short
pmap_getport(addr, prognum, versnum, protocol)
struct sockaddr_in *addr;
u_long prognum, versnum, protocol;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns the port number
on which waits a service that supports program number
.IR prognum ,
version
.IR versnum ,
and speaks the transport protocol associated with
.IR protocol .
The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
A return value of zero means that the mapping does not exist
or that
the
.SM RPC
system failured to contact the remote
.B portmap
service.  In the latter case, the global variable
.B rpc_createerr(\|)
contains the
.SM RPC
status.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
enum clnt_stat
pmap_rmtcall(addr, prognum, versnum, procnum, inproc, in, outproc, out, tout, portp)
struct sockaddr_in *addr;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
struct timeval tout;
u_long *portp;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which instructs
.B portmap
on the host at
.SM IP
address
.I *addr
to make an
.SM RPC
call on your behalf to a procedure on that host.
The parameter
.I *portp
will be modified to the program's port number if the
procedure
succeeds. The definitions of other parameters are discussed
in
.B callrpc(\|)
and
.BR clnt_call(\|) .
This procedure should be used for a \(lqping\(rq and nothing
else.
See also
.BR clnt_broadcast(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
pmap_set(prognum, versnum, protocol, port)
u_long prognum, versnum, protocol;
u_short port;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which establishes a mapping between the triple
.RI [ prognum , versnum , protocol\fR]
and
.I port
on the machine's
.B portmap
service. The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
This routine returns one if it succeeds, zero otherwise.
Automatically done by
.BR svc_register(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
pmap_unset(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which destroys all mapping between the triple
.RI [ prognum , versnum , *\fR]
and
.B ports
on the machine's
.B portmap
service. This routine returns one if it succeeds, zero
otherwise.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
u_long prognum, versnum, procnum;
char *(*procname) (\|) ;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Register procedure
.I procname
with the
.SM RPC
service package.  If a request arrives for program
.IR prognum ,
version
.IR versnum ,
and procedure
.IR procnum ,
.I procname
is called with a pointer to its parameter(s);
.I progname
should return a pointer to its static result(s);
.I inproc
is used to decode the parameters while
.I outproc
is used to encode the results.
This routine returns zero if the registration succeeded, \-1
otherwise.
.IP
Warning: remote procedures registered in this form
are accessed using the
.SM UDP/IP
transport; see
.B svcudp_create(\|)
for restrictions.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
struct rpc_createerr     rpc_createerr;
.fi
.ft R
.IP
A global variable whose value is set by any
.SM RPC
client creation routine
that does not succeed.  Use the routine
.B clnt_pcreateerror(\|)
to print the reason why.
.if t .ne 7
.LP
.ft B
.nf
.sp .5
svc_destroy(xprt)
\s-1SVCXPRT\s0 *
xprt;
.fi
.ft R
.IP
A macro that destroys the
.SM RPC
service transport handle,
.IR xprt .
Destruction usually involves deallocation
of private data structures, including
.I xprt
itself.  Use of
.I xprt
is undefined after calling this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
fd_set svc_fdset;
.fi
.ft R
.IP
A global variable reflecting the
.SM RPC
service side's
read file descriptor bit mask; it is suitable as a parameter
to the
.B select
system call. This is only of interest
if a service implementor does not call
.BR svc_run(\|) ,
but rather does his own asynchronous event processing.
This variable is read-only (do not pass its address to
.BR select !),
yet it may change after calls to
.B svc_getreqset(\|)
or any creation routines.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
int svc_fds;
.fi
.ft R
.IP
Similar to
.BR svc_fedset(\|) ,
but limited to 32 descriptors. This
interface is obsoleted by
.BR svc_fdset(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_freeargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the arguments to a service procedure
using
.BR svc_getargs(\|) .
This routine returns 1 if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
svc_getargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that decodes the arguments of an
.SM RPC
request
associated with the
.SM RPC
service transport handle,
.IR xprt .
The parameter
.I in
is the address where the arguments will be placed;
.I inproc
is the
.SM XDR
routine used to decode the arguments.
This routine returns one if decoding succeeds, and zero
otherwise.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
struct sockaddr_in *
svc_getcaller(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
The approved way of getting the network address of the caller
of a procedure associated with the
.SM RPC
service transport handle,
.IR xprt .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_getreqset(rdfds)
fd_set *rdfds;
.fi
.ft R
.IP
This routine is only of interest if a service implementor
does not call
.BR svc_run(\|) ,
but instead implements custom asynchronous event processing.
It is called when the
.B select
system call has determined that an
.SM RPC
request has arrived on some
.SM RPC
.B socket(s) ;
.I rdfds
is the resultant read file descriptor bit mask.
The routine returns when all sockets associated with the
value of
.I rdfds
have been serviced.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_getreq(rdfds)
int rdfds;
.fi
.ft R
.IP
Similar to
.BR svc_getreqset(\|) ,
but limited to 32 descriptors. This interface is obsoleted by
.BR svc_getreqset(\|) .
.br
.if t .ne 17
.LP
.ft B
.nf
.sp .5
svc_register(xprt, prognum, versnum, dispatch, protocol)
\s-1SVCXPRT\s0 *xprt;
u_long prognum, versnum;
void (*dispatch) (\|);
u_long protocol;
.fi
.ft R
.IP
Associates
.I prognum
and
.I versnum
with the service dispatch procedure,
.IR dispatch .
If
.I protocol
is zero, the service is not registered with the
.B portmap
service.  If
.I protocol
is non-zero, then a mapping of the triple
.RI [ prognum , versnum , protocol\fR]
to
\fB\%xprt\->xp_port\fR
is established with the local
.B portmap
service (generally
.I protocol
is zero,
.B
.SM IPPROTO_UDP
or 
.B
.SM IPPROTO_TCP
).
The procedure
.I dispatch
has the following form:
.RS 1i
.ft B
.nf
dispatch(request, xprt)
struct svc_req *request;
\s-1SVCXPRT\s0 *xprt;
.ft R
.fi
.RE
.IP
The
.B svc_register(\|)
routine returns one if it succeeds, and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_run(\|)
.fi
.ft R
.IP
This routine never returns. It waits for
.SM RPC
requests to arrive, and calls the appropriate service
procedure using
.B svc_getreq(\|)
when one arrives. This procedure is usually waiting for a
.B select(\|)
system call to return.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_sendreply(xprt, outproc, out)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
Called by an
.SM RPC
service's dispatch routine to send the results of a
remote procedure call.  The parameter
.I xprt
is the request's associated transport handle;
.I outproc
is the
.SM XDR
routine which is used to encode the results; and
.I out
is the address of the results.
This routine returns one if it succeeds, zero otherwise.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svc_unregister(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
Remove all mapping of the double
.RI [ prognum , versnum ]
to dispatch routines, and of the triple
.RI [ prognum , versnum , *\fR]
to port number.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
svcerr_auth(xprt, why)
\s-1SVCXPRT\s0 *xprt;
enum auth_stat why;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to an authentication error.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_decode(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that cannot successfully
decode its parameters. See also
.BR svc_getargs(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noproc(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that does not implement
the procedure number that the caller requests.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noprog(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired program is not registered with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_progvers(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired version of a program is not registered
with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_systemerr(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine when it detects a system
error
not covered by any particular protocol.
For example, if a service can no longer allocate storage,
it may call this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
svcerr_weakauth(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to insufficient
authentication parameters.  The routine calls
.BR "svcerr_auth(xprt, \s-1AUTH_TOOWEAK\s0)" .
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcraw_create(\|)
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
service transport, to which it returns a pointer.  The
transport
is really a buffer within the process's address space,
so the corresponding
.SM RPC
client should live in the same
address space;
see
.BR clntraw_create(\|) .
This routine allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads (such as round trip times), without any kernel
interference.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svctcp_create(sock, send_buf_size, recv_buf_size)
int sock;
u_int send_buf_size, recv_buf_size;
.fi
.ft R
.IP
This routine creates a
.SM TCP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.BR \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM TCP
port, then this routine binds it to an arbitrary port.  Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails. Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
users may specify the size of buffers; values of zero
choose suitable defaults.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcfd_create(fd, sendsize, recvsize)
int fd;
u_int sendsize;
u_int recvsize;
.fi
.ft R
.IP
Create a service on top of any open descriptor. Typically,
this
descriptor is a connected socket for a stream protocol such
as
.SM TCP\s0.
.I sendsize
and
.I recvsize
indicate sizes for the send and receive buffers.  If they are
zero, a reasonable default is chosen.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcudp_bufcreate(sock, sendsize, recosize)
int sock;
.fi
.ft R
.IP
This routine creates a
.SM UDP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.B \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM UDP
port, then this routine binds it to an arbitrary port. Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails.
.IP
This allows the user to specify the maximun packet size for sending and 
receiving
.SM UDP\s0-based
.SM RPC messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_accepted_reply(xdrs, ar)
\s-1XDR\s0 *xdrs;
struct accepted_reply *ar;
.fi
.ft R
.IP
Used for encoding
.SM RPC
reply messages. This routine is useful for users who
wish to generate
\s-1RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_authunix_parms(xdrs, aupp)
\s-1XDR\s0 *xdrs;
struct authunix_parms *aupp;
.fi
.ft R
.IP
Used for describing
.SM UNIX
credentials. This routine is useful for users
who wish to generate these credentials without using the
.SM RPC
authentication package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
xdr_callhdr(xdrs, chdr)
\s-1XDR\s0 *xdrs;
struct rpc_msg *chdr;
.fi
.ft R
.IP
Used for describing
.SM RPC
call header messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_callmsg(xdrs, cmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *cmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
call messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_opaque_auth(xdrs, ap)
\s-1XDR\s0 *xdrs;
struct opaque_auth *ap;
.fi
.ft R
.IP
Used for describing
.SM RPC
authentication information messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmap(xdrs, regs)
\s-1XDR\s0 *xdrs;
struct pmap *regs;
.fi
.ft R
.IP
Used for describing parameters to various
.B portmap
procedures, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmaplist(xdrs, rp)
\s-1XDR\s0 *xdrs;
struct pmaplist **rp;
.fi
.ft R
.IP
Used for describing a list of port mappings, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_rejected_reply(xdrs, rr)
\s-1XDR\s0 *xdrs;
struct rejected_reply *rr;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_replymsg(xdrs, rmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *rmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC
style messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_register(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
After
.SM RPC
service transport handles are created,
they should register themselves with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_unregister(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Before an
.SM RPC
service transport handle is destroyed,
it should unregister itself with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.SH SEE ALSO
.BR rpc_secure (3N),
.BR xdr (3N)
.br
The following manuals:
.RS
.ft I
Remote Procedure Calls: Protocol Specification
.br
Remote Procedure Call Programming Guide
.br
rpcgen Programming Guide
.br
.ft R
.RE
.IR "\s-1RPC\s0: Remote Procedure Call Protocol Specification" ,
.SM RFC1050, Sun Microsystems, Inc.,
.SM USC-ISI\s0.

                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/clnt_create.3                                0100644 0001750 0001750 00000073141 12566167025 023237  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"	from: @(#)rpc.3n	2.4 88/08/08 4.0 RPCSRC; from 1.19 88/06/24 SMI
.\"	$Id: rpc.3,v 1.1 1999/04/13 23:15:37 wsanchez Exp $
.\"
.TH RPC 3N "16 February 1988"
.SH NAME
rpc \- library routines for remote procedure calls
.SH SYNOPSIS AND DESCRIPTION
These routines allow C programs to make procedure
calls on other machines across the network.
First, the client calls a procedure to send a
data packet to the server.
Upon receipt of the packet, the server calls a dispatch routine
to perform the requested service, and then sends back a
reply.
Finally, the procedure call returns to the client.
.LP
Routines that are used for Secure RPC (DES authentication) are described in
.BR rpc_secure (3N).
Secure RPC can be used only if DES encryption is available.
.LP
.ft B
.nf
.sp .5
#include <rpc/rpc.h>
.fi
.ft R
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
auth_destroy(auth)
\s-1AUTH\s0 *auth;
.fi
.ft R
.IP
A macro that destroys the authentication information associated with
.IR auth .
Destruction usually involves deallocation of private data
structures. The use of
.I auth
is undefined after calling
.BR auth_destroy(\|) .
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authnone_create(\|)
.fi
.ft R
.IP
Create and returns an
.SM RPC
authentication handle that passes nonusable authentication
information with each remote procedure call. This is the
default authentication used by
.SM RPC.
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create(host, uid, gid, len, aup_gids)
char *host;
int uid, gid, len, *aup.gids;
.fi
.ft R
.IP
Create and return an
.SM RPC
authentication handle that contains
.UX
authentication information.
The parameter
.I host
is the name of the machine on which the information was
created;
.I uid
is the user's user
.SM ID ;
.I gid
is the user's current group
.SM ID ;
.I len
and
.I aup_gids
refer to a counted array of groups to which the user belongs.
It is easy to impersonate a user.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create_default(\|)
.fi
.ft R
.IP
Calls
.B authunix_create(\|)
with the appropriate parameters.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
char *host;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Call the remote procedure associated with
.IR prognum ,
.IR versnum ,
and
.I procnum
on the machine,
.IR host .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results.
This routine returns zero if it succeeds, or the value of
.B "enum clnt_stat"
cast to an integer if it fails.
The routine
.B clnt_perrno(\|)
is handy for translating failure statuses into messages.
.IP
Warning: calling remote procedures with this routine
uses
.SM UDP/IP
as a transport; see
.B clntudp_create(\|)
for restrictions.
You do not have control of timeouts or authentication using
this routine.
.br
.if t .ne 16
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_broadcast(prognum, versnum, procnum, inproc, in, outproc, out, eachresult)
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
resultproc_t eachresult;
.fi
.ft R
.IP
Like
.BR callrpc(\|) ,
except the call message is broadcast to all locally
connected broadcast nets. Each time it receives a
response, this routine calls
.BR eachresult(\|) ,
whose form is:
.IP
.RS 1i
.ft B
.nf
eachresult(out, addr)
char *out;
struct sockaddr_in *addr;
.ft R
.fi
.RE
.IP
where
.I out
is the same as
.I out
passed to
.BR clnt_broadcast(\|) ,
except that the remote procedure's output is decoded there;
.I addr
points to the address of the machine that sent the results.
If
.B eachresult(\|)
returns zero,
.B clnt_broadcast(\|)
waits for more replies; otherwise it returns with appropriate
status.
.IP
Warning: broadcast sockets are limited in size to the
maximum transfer unit of the data link. For ethernet,
this value is 1500 bytes.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_call(clnt, procnum, inproc, in, outproc, out, tout)
\s-1CLIENT\s0 *clnt;
u_long
procnum;
xdrproc_t inproc, outproc;
char *in, *out;
struct timeval tout;
.fi
.ft R
.IP
A macro that calls the remote procedure
.I procnum
associated with the client handle,
.IR clnt ,
which is obtained with an
.SM RPC
client creation routine such as
.BR clnt_create(\|) .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results;
.I tout
is the time allowed for results to come back.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
clnt_destroy(clnt)
\s-1CLIENT\s0 *clnt;
.fi
.ft R
.IP
A macro that destroys the client's
.SM RPC
handle. Destruction usually involves deallocation
of private data structures, including
.I clnt
itself.  Use of
.I clnt
is undefined after calling
.BR clnt_destroy(\|) .
If the
.SM RPC
library opened the associated socket, it will close it also.
Otherwise, the socket remains open.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnt_create(host, prog, vers, proto)
char *host;
u_long prog, vers;
char *proto;
.fi
.ft R
.IP
Generic client creation routine.
.I host
identifies the name of the remote host where the server
is located.
.I proto
indicates which kind of transport protocol to use. The
currently supported values for this field are \(lqudp\(rq
and \(lqtcp\(rq.
Default timeouts are set, but can be modified using
.BR clnt_control(\|) .
.IP
Warning: Using
.SM UDP
has its shortcomings.  Since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes of encoded data,
this transport cannot be used for procedures that take
large arguments or return huge results.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
bool_t
clnt_control(cl, req, info)
\s-1CLIENT\s0 *cl;
char *info;
.fi
.ft R
.IP
A macro used to change or retrieve various information
about a client object.
.I req
indicates the type of operation, and
.I info
is a pointer to the information. For both
.SM UDP
and
.SM TCP\s0,
the supported values of
.I req
and their argument types and what they do are:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_TIMEOUT\s0	struct timeval	set total timeout
.SM CLGET_TIMEOUT\s0	struct timeval	get total timeout
.fi
.IP
Note: if you set the timeout using
.BR clnt_control(\|) ,
the timeout parameter passed to
.B clnt_call(\|)
will be ignored in all future calls.
.IP
.nf
.SM CLGET_SERVER_ADDR\s0	struct sockaddr_in 	get server's address
.fi
.br
.IP
The following operations are valid for
.SM UDP
only:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_RETRY_TIMEOUT\s0		struct timeval	set the retry timeout
.SM CLGET_RETRY_TIMEOUT\s0		struct timeval	get the retry timeout
.fi
.br
.IP
The retry timeout is the time that
.SM "UDP RPC"
waits for the server to reply before
retransmitting the request.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
clnt_freeres(clnt, outproc, out)
\s-1CLIENT\s0 *clnt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the results of an
.SM RPC
call.  The
parameter
.I out
is the address of the results, and
.I outproc
is the
.SM XDR
routine describing the results.
This routine returns one if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
void
clnt_geterr(clnt, errp)
\s-1CLIENT\s0 *clnt;
struct rpc_err *errp;
.fi
.ft R
.IP
A macro that copies the error structure out of the client
handle
to the structure at address
.IR errp .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_pcreateerror(s)
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating
why a client
.SM RPC
handle could not be created.
The message is prepended with string
.I s
and a colon.
Used when a
.BR clnt_create(\|) ,
.BR clntraw_create(\|) ,
.BR clnttcp_create(\|) ,
or
.B clntudp_create(\|)
call fails.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_perrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Print a message to standard error corresponding
to the condition indicated by
.IR stat .
Used after
.BR callrpc(\|) .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
clnt_perror(clnt, s)
\s-1CLIENT\s0 *clnt;
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating why an
.SM RPC
call failed;
.I clnt
is the handle used to do the call.
The message is prepended with string
.I s
and a colon.
Used after
.BR clnt_call(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_spcreateerror
char *s;
.fi
.ft R
.IP
Like
.BR clnt_pcreateerror(\|) ,
except that it returns a string
instead of printing to the standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_sperrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Take the same arguments as
.BR clnt_perrno(\|) ,
but instead of sending a message to the standard error
indicating why an
.SM RPC
call failed, return a pointer to a string which contains
the message.  The string ends with a
.SM NEWLINE\s0.
.IP
.B clnt_sperrno(\|)
is used instead of
.B clnt_perrno(\|)
if the program does not have a standard error (as a program
running as a server quite likely does not), or if the
programmer
does not want the message to be output with
.BR printf ,
or if a message format different than that supported by
.B clnt_perrno(\|)
is to be used.
Note: unlike
.B clnt_sperror(\|)
and
.BR clnt_spcreaterror(\|) ,
.B clnt_sperrno(\|)
returns pointer to static data, but the
result will not get overwritten on each call.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
char *
clnt_sperror(rpch, s)
\s-1CLIENT\s0 *rpch;
char *s;
.fi
.ft R
.IP
Like
.BR clnt_perror(\|) ,
except that (like
.BR clnt_sperrno(\|) )
it returns a string instead of printing to standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntraw_create(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum .
The transport used to pass messages to the service is
actually a buffer within the process's address space, so the
corresponding
.SM RPC
server should live in the same address space; see
.BR svcraw_create(\|) .
This allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads, such as round trip times, without any
kernel interference. This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnttcp_create(addr, prognum, versnum, sockp, sendsz, recvsz)
struct sockaddr_in *addr;
u_long prognum, versnum;
int *sockp;
u_int sendsz, recvsz;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses
.SM TCP/IP
as a transport. The remote program is located at Internet
address
.IR *addr .
If
.\"The following in-line font conversion is necessary for the hyphen indicator
\fB\%addr\->sin_port\fR
is zero, then it is set to the actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
the user may specify the size of the send and receive buffers
with the parameters
.I sendsz
and
.IR recvsz ;
values of zero choose suitable defaults.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_create(addr, prognum, versnum, wait, sockp)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
Warning: since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes
of encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_bufcreate(addr, prognum, versnum, wait, sockp, sendsize, recosize)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
unsigned int sendsize;
unsigned int recosize;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
on
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.BR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
This allows the user to specify the maximun packet size for sending and receiving 
.SM UDP\s0-based
.SM RPC
messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
get_myaddress(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
Stuff the machine's
.SM IP
address into
.IR *addr ,
without consulting the library routines that deal with
.BR /etc/hosts .
The port number is always set to
.BR htons(\s-1PMAPPORT\s0) .
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
struct pmaplist *
pmap_getmaps(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns a list of the current
.SM RPC
program-to-port mappings
on the host located at
.SM IP
address
.IR *addr .
This routine can return
.SM NULL .
The command
.RB ` "rpcinfo \-p" '
uses this routine.
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
u_short
pmap_getport(addr, prognum, versnum, protocol)
struct sockaddr_in *addr;
u_long prognum, versnum, protocol;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns the port number
on which waits a service that supports program number
.IR prognum ,
version
.IR versnum ,
and speaks the transport protocol associated with
.IR protocol .
The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
A return value of zero means that the mapping does not exist
or that
the
.SM RPC
system failured to contact the remote
.B portmap
service.  In the latter case, the global variable
.B rpc_createerr(\|)
contains the
.SM RPC
status.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
enum clnt_stat
pmap_rmtcall(addr, prognum, versnum, procnum, inproc, in, outproc, out, tout, portp)
struct sockaddr_in *addr;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
struct timeval tout;
u_long *portp;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which instructs
.B portmap
on the host at
.SM IP
address
.I *addr
to make an
.SM RPC
call on your behalf to a procedure on that host.
The parameter
.I *portp
will be modified to the program's port number if the
procedure
succeeds. The definitions of other parameters are discussed
in
.B callrpc(\|)
and
.BR clnt_call(\|) .
This procedure should be used for a \(lqping\(rq and nothing
else.
See also
.BR clnt_broadcast(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
pmap_set(prognum, versnum, protocol, port)
u_long prognum, versnum, protocol;
u_short port;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which establishes a mapping between the triple
.RI [ prognum , versnum , protocol\fR]
and
.I port
on the machine's
.B portmap
service. The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
This routine returns one if it succeeds, zero otherwise.
Automatically done by
.BR svc_register(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
pmap_unset(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which destroys all mapping between the triple
.RI [ prognum , versnum , *\fR]
and
.B ports
on the machine's
.B portmap
service. This routine returns one if it succeeds, zero
otherwise.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
u_long prognum, versnum, procnum;
char *(*procname) (\|) ;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Register procedure
.I procname
with the
.SM RPC
service package.  If a request arrives for program
.IR prognum ,
version
.IR versnum ,
and procedure
.IR procnum ,
.I procname
is called with a pointer to its parameter(s);
.I progname
should return a pointer to its static result(s);
.I inproc
is used to decode the parameters while
.I outproc
is used to encode the results.
This routine returns zero if the registration succeeded, \-1
otherwise.
.IP
Warning: remote procedures registered in this form
are accessed using the
.SM UDP/IP
transport; see
.B svcudp_create(\|)
for restrictions.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
struct rpc_createerr     rpc_createerr;
.fi
.ft R
.IP
A global variable whose value is set by any
.SM RPC
client creation routine
that does not succeed.  Use the routine
.B clnt_pcreateerror(\|)
to print the reason why.
.if t .ne 7
.LP
.ft B
.nf
.sp .5
svc_destroy(xprt)
\s-1SVCXPRT\s0 *
xprt;
.fi
.ft R
.IP
A macro that destroys the
.SM RPC
service transport handle,
.IR xprt .
Destruction usually involves deallocation
of private data structures, including
.I xprt
itself.  Use of
.I xprt
is undefined after calling this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
fd_set svc_fdset;
.fi
.ft R
.IP
A global variable reflecting the
.SM RPC
service side's
read file descriptor bit mask; it is suitable as a parameter
to the
.B select
system call. This is only of interest
if a service implementor does not call
.BR svc_run(\|) ,
but rather does his own asynchronous event processing.
This variable is read-only (do not pass its address to
.BR select !),
yet it may change after calls to
.B svc_getreqset(\|)
or any creation routines.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
int svc_fds;
.fi
.ft R
.IP
Similar to
.BR svc_fedset(\|) ,
but limited to 32 descriptors. This
interface is obsoleted by
.BR svc_fdset(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_freeargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the arguments to a service procedure
using
.BR svc_getargs(\|) .
This routine returns 1 if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
svc_getargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that decodes the arguments of an
.SM RPC
request
associated with the
.SM RPC
service transport handle,
.IR xprt .
The parameter
.I in
is the address where the arguments will be placed;
.I inproc
is the
.SM XDR
routine used to decode the arguments.
This routine returns one if decoding succeeds, and zero
otherwise.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
struct sockaddr_in *
svc_getcaller(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
The approved way of getting the network address of the caller
of a procedure associated with the
.SM RPC
service transport handle,
.IR xprt .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_getreqset(rdfds)
fd_set *rdfds;
.fi
.ft R
.IP
This routine is only of interest if a service implementor
does not call
.BR svc_run(\|) ,
but instead implements custom asynchronous event processing.
It is called when the
.B select
system call has determined that an
.SM RPC
request has arrived on some
.SM RPC
.B socket(s) ;
.I rdfds
is the resultant read file descriptor bit mask.
The routine returns when all sockets associated with the
value of
.I rdfds
have been serviced.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_getreq(rdfds)
int rdfds;
.fi
.ft R
.IP
Similar to
.BR svc_getreqset(\|) ,
but limited to 32 descriptors. This interface is obsoleted by
.BR svc_getreqset(\|) .
.br
.if t .ne 17
.LP
.ft B
.nf
.sp .5
svc_register(xprt, prognum, versnum, dispatch, protocol)
\s-1SVCXPRT\s0 *xprt;
u_long prognum, versnum;
void (*dispatch) (\|);
u_long protocol;
.fi
.ft R
.IP
Associates
.I prognum
and
.I versnum
with the service dispatch procedure,
.IR dispatch .
If
.I protocol
is zero, the service is not registered with the
.B portmap
service.  If
.I protocol
is non-zero, then a mapping of the triple
.RI [ prognum , versnum , protocol\fR]
to
\fB\%xprt\->xp_port\fR
is established with the local
.B portmap
service (generally
.I protocol
is zero,
.B
.SM IPPROTO_UDP
or 
.B
.SM IPPROTO_TCP
).
The procedure
.I dispatch
has the following form:
.RS 1i
.ft B
.nf
dispatch(request, xprt)
struct svc_req *request;
\s-1SVCXPRT\s0 *xprt;
.ft R
.fi
.RE
.IP
The
.B svc_register(\|)
routine returns one if it succeeds, and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_run(\|)
.fi
.ft R
.IP
This routine never returns. It waits for
.SM RPC
requests to arrive, and calls the appropriate service
procedure using
.B svc_getreq(\|)
when one arrives. This procedure is usually waiting for a
.B select(\|)
system call to return.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_sendreply(xprt, outproc, out)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
Called by an
.SM RPC
service's dispatch routine to send the results of a
remote procedure call.  The parameter
.I xprt
is the request's associated transport handle;
.I outproc
is the
.SM XDR
routine which is used to encode the results; and
.I out
is the address of the results.
This routine returns one if it succeeds, zero otherwise.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svc_unregister(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
Remove all mapping of the double
.RI [ prognum , versnum ]
to dispatch routines, and of the triple
.RI [ prognum , versnum , *\fR]
to port number.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
svcerr_auth(xprt, why)
\s-1SVCXPRT\s0 *xprt;
enum auth_stat why;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to an authentication error.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_decode(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that cannot successfully
decode its parameters. See also
.BR svc_getargs(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noproc(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that does not implement
the procedure number that the caller requests.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noprog(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired program is not registered with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_progvers(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired version of a program is not registered
with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_systemerr(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine when it detects a system
error
not covered by any particular protocol.
For example, if a service can no longer allocate storage,
it may call this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
svcerr_weakauth(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to insufficient
authentication parameters.  The routine calls
.BR "svcerr_auth(xprt, \s-1AUTH_TOOWEAK\s0)" .
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcraw_create(\|)
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
service transport, to which it returns a pointer.  The
transport
is really a buffer within the process's address space,
so the corresponding
.SM RPC
client should live in the same
address space;
see
.BR clntraw_create(\|) .
This routine allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads (such as round trip times), without any kernel
interference.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svctcp_create(sock, send_buf_size, recv_buf_size)
int sock;
u_int send_buf_size, recv_buf_size;
.fi
.ft R
.IP
This routine creates a
.SM TCP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.BR \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM TCP
port, then this routine binds it to an arbitrary port.  Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails. Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
users may specify the size of buffers; values of zero
choose suitable defaults.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcfd_create(fd, sendsize, recvsize)
int fd;
u_int sendsize;
u_int recvsize;
.fi
.ft R
.IP
Create a service on top of any open descriptor. Typically,
this
descriptor is a connected socket for a stream protocol such
as
.SM TCP\s0.
.I sendsize
and
.I recvsize
indicate sizes for the send and receive buffers.  If they are
zero, a reasonable default is chosen.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcudp_bufcreate(sock, sendsize, recosize)
int sock;
.fi
.ft R
.IP
This routine creates a
.SM UDP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.B \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM UDP
port, then this routine binds it to an arbitrary port. Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails.
.IP
This allows the user to specify the maximun packet size for sending and 
receiving
.SM UDP\s0-based
.SM RPC messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_accepted_reply(xdrs, ar)
\s-1XDR\s0 *xdrs;
struct accepted_reply *ar;
.fi
.ft R
.IP
Used for encoding
.SM RPC
reply messages. This routine is useful for users who
wish to generate
\s-1RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_authunix_parms(xdrs, aupp)
\s-1XDR\s0 *xdrs;
struct authunix_parms *aupp;
.fi
.ft R
.IP
Used for describing
.SM UNIX
credentials. This routine is useful for users
who wish to generate these credentials without using the
.SM RPC
authentication package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
xdr_callhdr(xdrs, chdr)
\s-1XDR\s0 *xdrs;
struct rpc_msg *chdr;
.fi
.ft R
.IP
Used for describing
.SM RPC
call header messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_callmsg(xdrs, cmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *cmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
call messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_opaque_auth(xdrs, ap)
\s-1XDR\s0 *xdrs;
struct opaque_auth *ap;
.fi
.ft R
.IP
Used for describing
.SM RPC
authentication information messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmap(xdrs, regs)
\s-1XDR\s0 *xdrs;
struct pmap *regs;
.fi
.ft R
.IP
Used for describing parameters to various
.B portmap
procedures, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmaplist(xdrs, rp)
\s-1XDR\s0 *xdrs;
struct pmaplist **rp;
.fi
.ft R
.IP
Used for describing a list of port mappings, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_rejected_reply(xdrs, rr)
\s-1XDR\s0 *xdrs;
struct rejected_reply *rr;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_replymsg(xdrs, rmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *rmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC
style messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_register(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
After
.SM RPC
service transport handles are created,
they should register themselves with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_unregister(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Before an
.SM RPC
service transport handle is destroyed,
it should unregister itself with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.SH SEE ALSO
.BR rpc_secure (3N),
.BR xdr (3N)
.br
The following manuals:
.RS
.ft I
Remote Procedure Calls: Protocol Specification
.br
Remote Procedure Call Programming Guide
.br
rpcgen Programming Guide
.br
.ft R
.RE
.IR "\s-1RPC\s0: Remote Procedure Call Protocol Specification" ,
.SM RFC1050, Sun Microsystems, Inc.,
.SM USC-ISI\s0.

                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/clnt_destroy.3                               0100644 0001750 0001750 00000073141 12566167025 023465  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"	from: @(#)rpc.3n	2.4 88/08/08 4.0 RPCSRC; from 1.19 88/06/24 SMI
.\"	$Id: rpc.3,v 1.1 1999/04/13 23:15:37 wsanchez Exp $
.\"
.TH RPC 3N "16 February 1988"
.SH NAME
rpc \- library routines for remote procedure calls
.SH SYNOPSIS AND DESCRIPTION
These routines allow C programs to make procedure
calls on other machines across the network.
First, the client calls a procedure to send a
data packet to the server.
Upon receipt of the packet, the server calls a dispatch routine
to perform the requested service, and then sends back a
reply.
Finally, the procedure call returns to the client.
.LP
Routines that are used for Secure RPC (DES authentication) are described in
.BR rpc_secure (3N).
Secure RPC can be used only if DES encryption is available.
.LP
.ft B
.nf
.sp .5
#include <rpc/rpc.h>
.fi
.ft R
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
auth_destroy(auth)
\s-1AUTH\s0 *auth;
.fi
.ft R
.IP
A macro that destroys the authentication information associated with
.IR auth .
Destruction usually involves deallocation of private data
structures. The use of
.I auth
is undefined after calling
.BR auth_destroy(\|) .
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authnone_create(\|)
.fi
.ft R
.IP
Create and returns an
.SM RPC
authentication handle that passes nonusable authentication
information with each remote procedure call. This is the
default authentication used by
.SM RPC.
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create(host, uid, gid, len, aup_gids)
char *host;
int uid, gid, len, *aup.gids;
.fi
.ft R
.IP
Create and return an
.SM RPC
authentication handle that contains
.UX
authentication information.
The parameter
.I host
is the name of the machine on which the information was
created;
.I uid
is the user's user
.SM ID ;
.I gid
is the user's current group
.SM ID ;
.I len
and
.I aup_gids
refer to a counted array of groups to which the user belongs.
It is easy to impersonate a user.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create_default(\|)
.fi
.ft R
.IP
Calls
.B authunix_create(\|)
with the appropriate parameters.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
char *host;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Call the remote procedure associated with
.IR prognum ,
.IR versnum ,
and
.I procnum
on the machine,
.IR host .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results.
This routine returns zero if it succeeds, or the value of
.B "enum clnt_stat"
cast to an integer if it fails.
The routine
.B clnt_perrno(\|)
is handy for translating failure statuses into messages.
.IP
Warning: calling remote procedures with this routine
uses
.SM UDP/IP
as a transport; see
.B clntudp_create(\|)
for restrictions.
You do not have control of timeouts or authentication using
this routine.
.br
.if t .ne 16
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_broadcast(prognum, versnum, procnum, inproc, in, outproc, out, eachresult)
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
resultproc_t eachresult;
.fi
.ft R
.IP
Like
.BR callrpc(\|) ,
except the call message is broadcast to all locally
connected broadcast nets. Each time it receives a
response, this routine calls
.BR eachresult(\|) ,
whose form is:
.IP
.RS 1i
.ft B
.nf
eachresult(out, addr)
char *out;
struct sockaddr_in *addr;
.ft R
.fi
.RE
.IP
where
.I out
is the same as
.I out
passed to
.BR clnt_broadcast(\|) ,
except that the remote procedure's output is decoded there;
.I addr
points to the address of the machine that sent the results.
If
.B eachresult(\|)
returns zero,
.B clnt_broadcast(\|)
waits for more replies; otherwise it returns with appropriate
status.
.IP
Warning: broadcast sockets are limited in size to the
maximum transfer unit of the data link. For ethernet,
this value is 1500 bytes.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_call(clnt, procnum, inproc, in, outproc, out, tout)
\s-1CLIENT\s0 *clnt;
u_long
procnum;
xdrproc_t inproc, outproc;
char *in, *out;
struct timeval tout;
.fi
.ft R
.IP
A macro that calls the remote procedure
.I procnum
associated with the client handle,
.IR clnt ,
which is obtained with an
.SM RPC
client creation routine such as
.BR clnt_create(\|) .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results;
.I tout
is the time allowed for results to come back.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
clnt_destroy(clnt)
\s-1CLIENT\s0 *clnt;
.fi
.ft R
.IP
A macro that destroys the client's
.SM RPC
handle. Destruction usually involves deallocation
of private data structures, including
.I clnt
itself.  Use of
.I clnt
is undefined after calling
.BR clnt_destroy(\|) .
If the
.SM RPC
library opened the associated socket, it will close it also.
Otherwise, the socket remains open.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnt_create(host, prog, vers, proto)
char *host;
u_long prog, vers;
char *proto;
.fi
.ft R
.IP
Generic client creation routine.
.I host
identifies the name of the remote host where the server
is located.
.I proto
indicates which kind of transport protocol to use. The
currently supported values for this field are \(lqudp\(rq
and \(lqtcp\(rq.
Default timeouts are set, but can be modified using
.BR clnt_control(\|) .
.IP
Warning: Using
.SM UDP
has its shortcomings.  Since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes of encoded data,
this transport cannot be used for procedures that take
large arguments or return huge results.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
bool_t
clnt_control(cl, req, info)
\s-1CLIENT\s0 *cl;
char *info;
.fi
.ft R
.IP
A macro used to change or retrieve various information
about a client object.
.I req
indicates the type of operation, and
.I info
is a pointer to the information. For both
.SM UDP
and
.SM TCP\s0,
the supported values of
.I req
and their argument types and what they do are:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_TIMEOUT\s0	struct timeval	set total timeout
.SM CLGET_TIMEOUT\s0	struct timeval	get total timeout
.fi
.IP
Note: if you set the timeout using
.BR clnt_control(\|) ,
the timeout parameter passed to
.B clnt_call(\|)
will be ignored in all future calls.
.IP
.nf
.SM CLGET_SERVER_ADDR\s0	struct sockaddr_in 	get server's address
.fi
.br
.IP
The following operations are valid for
.SM UDP
only:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_RETRY_TIMEOUT\s0		struct timeval	set the retry timeout
.SM CLGET_RETRY_TIMEOUT\s0		struct timeval	get the retry timeout
.fi
.br
.IP
The retry timeout is the time that
.SM "UDP RPC"
waits for the server to reply before
retransmitting the request.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
clnt_freeres(clnt, outproc, out)
\s-1CLIENT\s0 *clnt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the results of an
.SM RPC
call.  The
parameter
.I out
is the address of the results, and
.I outproc
is the
.SM XDR
routine describing the results.
This routine returns one if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
void
clnt_geterr(clnt, errp)
\s-1CLIENT\s0 *clnt;
struct rpc_err *errp;
.fi
.ft R
.IP
A macro that copies the error structure out of the client
handle
to the structure at address
.IR errp .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_pcreateerror(s)
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating
why a client
.SM RPC
handle could not be created.
The message is prepended with string
.I s
and a colon.
Used when a
.BR clnt_create(\|) ,
.BR clntraw_create(\|) ,
.BR clnttcp_create(\|) ,
or
.B clntudp_create(\|)
call fails.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_perrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Print a message to standard error corresponding
to the condition indicated by
.IR stat .
Used after
.BR callrpc(\|) .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
clnt_perror(clnt, s)
\s-1CLIENT\s0 *clnt;
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating why an
.SM RPC
call failed;
.I clnt
is the handle used to do the call.
The message is prepended with string
.I s
and a colon.
Used after
.BR clnt_call(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_spcreateerror
char *s;
.fi
.ft R
.IP
Like
.BR clnt_pcreateerror(\|) ,
except that it returns a string
instead of printing to the standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_sperrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Take the same arguments as
.BR clnt_perrno(\|) ,
but instead of sending a message to the standard error
indicating why an
.SM RPC
call failed, return a pointer to a string which contains
the message.  The string ends with a
.SM NEWLINE\s0.
.IP
.B clnt_sperrno(\|)
is used instead of
.B clnt_perrno(\|)
if the program does not have a standard error (as a program
running as a server quite likely does not), or if the
programmer
does not want the message to be output with
.BR printf ,
or if a message format different than that supported by
.B clnt_perrno(\|)
is to be used.
Note: unlike
.B clnt_sperror(\|)
and
.BR clnt_spcreaterror(\|) ,
.B clnt_sperrno(\|)
returns pointer to static data, but the
result will not get overwritten on each call.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
char *
clnt_sperror(rpch, s)
\s-1CLIENT\s0 *rpch;
char *s;
.fi
.ft R
.IP
Like
.BR clnt_perror(\|) ,
except that (like
.BR clnt_sperrno(\|) )
it returns a string instead of printing to standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntraw_create(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum .
The transport used to pass messages to the service is
actually a buffer within the process's address space, so the
corresponding
.SM RPC
server should live in the same address space; see
.BR svcraw_create(\|) .
This allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads, such as round trip times, without any
kernel interference. This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnttcp_create(addr, prognum, versnum, sockp, sendsz, recvsz)
struct sockaddr_in *addr;
u_long prognum, versnum;
int *sockp;
u_int sendsz, recvsz;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses
.SM TCP/IP
as a transport. The remote program is located at Internet
address
.IR *addr .
If
.\"The following in-line font conversion is necessary for the hyphen indicator
\fB\%addr\->sin_port\fR
is zero, then it is set to the actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
the user may specify the size of the send and receive buffers
with the parameters
.I sendsz
and
.IR recvsz ;
values of zero choose suitable defaults.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_create(addr, prognum, versnum, wait, sockp)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
Warning: since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes
of encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_bufcreate(addr, prognum, versnum, wait, sockp, sendsize, recosize)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
unsigned int sendsize;
unsigned int recosize;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
on
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.BR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
This allows the user to specify the maximun packet size for sending and receiving 
.SM UDP\s0-based
.SM RPC
messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
get_myaddress(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
Stuff the machine's
.SM IP
address into
.IR *addr ,
without consulting the library routines that deal with
.BR /etc/hosts .
The port number is always set to
.BR htons(\s-1PMAPPORT\s0) .
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
struct pmaplist *
pmap_getmaps(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns a list of the current
.SM RPC
program-to-port mappings
on the host located at
.SM IP
address
.IR *addr .
This routine can return
.SM NULL .
The command
.RB ` "rpcinfo \-p" '
uses this routine.
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
u_short
pmap_getport(addr, prognum, versnum, protocol)
struct sockaddr_in *addr;
u_long prognum, versnum, protocol;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns the port number
on which waits a service that supports program number
.IR prognum ,
version
.IR versnum ,
and speaks the transport protocol associated with
.IR protocol .
The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
A return value of zero means that the mapping does not exist
or that
the
.SM RPC
system failured to contact the remote
.B portmap
service.  In the latter case, the global variable
.B rpc_createerr(\|)
contains the
.SM RPC
status.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
enum clnt_stat
pmap_rmtcall(addr, prognum, versnum, procnum, inproc, in, outproc, out, tout, portp)
struct sockaddr_in *addr;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
struct timeval tout;
u_long *portp;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which instructs
.B portmap
on the host at
.SM IP
address
.I *addr
to make an
.SM RPC
call on your behalf to a procedure on that host.
The parameter
.I *portp
will be modified to the program's port number if the
procedure
succeeds. The definitions of other parameters are discussed
in
.B callrpc(\|)
and
.BR clnt_call(\|) .
This procedure should be used for a \(lqping\(rq and nothing
else.
See also
.BR clnt_broadcast(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
pmap_set(prognum, versnum, protocol, port)
u_long prognum, versnum, protocol;
u_short port;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which establishes a mapping between the triple
.RI [ prognum , versnum , protocol\fR]
and
.I port
on the machine's
.B portmap
service. The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
This routine returns one if it succeeds, zero otherwise.
Automatically done by
.BR svc_register(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
pmap_unset(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which destroys all mapping between the triple
.RI [ prognum , versnum , *\fR]
and
.B ports
on the machine's
.B portmap
service. This routine returns one if it succeeds, zero
otherwise.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
u_long prognum, versnum, procnum;
char *(*procname) (\|) ;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Register procedure
.I procname
with the
.SM RPC
service package.  If a request arrives for program
.IR prognum ,
version
.IR versnum ,
and procedure
.IR procnum ,
.I procname
is called with a pointer to its parameter(s);
.I progname
should return a pointer to its static result(s);
.I inproc
is used to decode the parameters while
.I outproc
is used to encode the results.
This routine returns zero if the registration succeeded, \-1
otherwise.
.IP
Warning: remote procedures registered in this form
are accessed using the
.SM UDP/IP
transport; see
.B svcudp_create(\|)
for restrictions.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
struct rpc_createerr     rpc_createerr;
.fi
.ft R
.IP
A global variable whose value is set by any
.SM RPC
client creation routine
that does not succeed.  Use the routine
.B clnt_pcreateerror(\|)
to print the reason why.
.if t .ne 7
.LP
.ft B
.nf
.sp .5
svc_destroy(xprt)
\s-1SVCXPRT\s0 *
xprt;
.fi
.ft R
.IP
A macro that destroys the
.SM RPC
service transport handle,
.IR xprt .
Destruction usually involves deallocation
of private data structures, including
.I xprt
itself.  Use of
.I xprt
is undefined after calling this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
fd_set svc_fdset;
.fi
.ft R
.IP
A global variable reflecting the
.SM RPC
service side's
read file descriptor bit mask; it is suitable as a parameter
to the
.B select
system call. This is only of interest
if a service implementor does not call
.BR svc_run(\|) ,
but rather does his own asynchronous event processing.
This variable is read-only (do not pass its address to
.BR select !),
yet it may change after calls to
.B svc_getreqset(\|)
or any creation routines.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
int svc_fds;
.fi
.ft R
.IP
Similar to
.BR svc_fedset(\|) ,
but limited to 32 descriptors. This
interface is obsoleted by
.BR svc_fdset(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_freeargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the arguments to a service procedure
using
.BR svc_getargs(\|) .
This routine returns 1 if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
svc_getargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that decodes the arguments of an
.SM RPC
request
associated with the
.SM RPC
service transport handle,
.IR xprt .
The parameter
.I in
is the address where the arguments will be placed;
.I inproc
is the
.SM XDR
routine used to decode the arguments.
This routine returns one if decoding succeeds, and zero
otherwise.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
struct sockaddr_in *
svc_getcaller(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
The approved way of getting the network address of the caller
of a procedure associated with the
.SM RPC
service transport handle,
.IR xprt .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_getreqset(rdfds)
fd_set *rdfds;
.fi
.ft R
.IP
This routine is only of interest if a service implementor
does not call
.BR svc_run(\|) ,
but instead implements custom asynchronous event processing.
It is called when the
.B select
system call has determined that an
.SM RPC
request has arrived on some
.SM RPC
.B socket(s) ;
.I rdfds
is the resultant read file descriptor bit mask.
The routine returns when all sockets associated with the
value of
.I rdfds
have been serviced.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_getreq(rdfds)
int rdfds;
.fi
.ft R
.IP
Similar to
.BR svc_getreqset(\|) ,
but limited to 32 descriptors. This interface is obsoleted by
.BR svc_getreqset(\|) .
.br
.if t .ne 17
.LP
.ft B
.nf
.sp .5
svc_register(xprt, prognum, versnum, dispatch, protocol)
\s-1SVCXPRT\s0 *xprt;
u_long prognum, versnum;
void (*dispatch) (\|);
u_long protocol;
.fi
.ft R
.IP
Associates
.I prognum
and
.I versnum
with the service dispatch procedure,
.IR dispatch .
If
.I protocol
is zero, the service is not registered with the
.B portmap
service.  If
.I protocol
is non-zero, then a mapping of the triple
.RI [ prognum , versnum , protocol\fR]
to
\fB\%xprt\->xp_port\fR
is established with the local
.B portmap
service (generally
.I protocol
is zero,
.B
.SM IPPROTO_UDP
or 
.B
.SM IPPROTO_TCP
).
The procedure
.I dispatch
has the following form:
.RS 1i
.ft B
.nf
dispatch(request, xprt)
struct svc_req *request;
\s-1SVCXPRT\s0 *xprt;
.ft R
.fi
.RE
.IP
The
.B svc_register(\|)
routine returns one if it succeeds, and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_run(\|)
.fi
.ft R
.IP
This routine never returns. It waits for
.SM RPC
requests to arrive, and calls the appropriate service
procedure using
.B svc_getreq(\|)
when one arrives. This procedure is usually waiting for a
.B select(\|)
system call to return.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_sendreply(xprt, outproc, out)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
Called by an
.SM RPC
service's dispatch routine to send the results of a
remote procedure call.  The parameter
.I xprt
is the request's associated transport handle;
.I outproc
is the
.SM XDR
routine which is used to encode the results; and
.I out
is the address of the results.
This routine returns one if it succeeds, zero otherwise.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svc_unregister(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
Remove all mapping of the double
.RI [ prognum , versnum ]
to dispatch routines, and of the triple
.RI [ prognum , versnum , *\fR]
to port number.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
svcerr_auth(xprt, why)
\s-1SVCXPRT\s0 *xprt;
enum auth_stat why;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to an authentication error.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_decode(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that cannot successfully
decode its parameters. See also
.BR svc_getargs(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noproc(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that does not implement
the procedure number that the caller requests.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noprog(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired program is not registered with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_progvers(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired version of a program is not registered
with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_systemerr(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine when it detects a system
error
not covered by any particular protocol.
For example, if a service can no longer allocate storage,
it may call this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
svcerr_weakauth(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to insufficient
authentication parameters.  The routine calls
.BR "svcerr_auth(xprt, \s-1AUTH_TOOWEAK\s0)" .
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcraw_create(\|)
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
service transport, to which it returns a pointer.  The
transport
is really a buffer within the process's address space,
so the corresponding
.SM RPC
client should live in the same
address space;
see
.BR clntraw_create(\|) .
This routine allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads (such as round trip times), without any kernel
interference.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svctcp_create(sock, send_buf_size, recv_buf_size)
int sock;
u_int send_buf_size, recv_buf_size;
.fi
.ft R
.IP
This routine creates a
.SM TCP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.BR \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM TCP
port, then this routine binds it to an arbitrary port.  Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails. Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
users may specify the size of buffers; values of zero
choose suitable defaults.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcfd_create(fd, sendsize, recvsize)
int fd;
u_int sendsize;
u_int recvsize;
.fi
.ft R
.IP
Create a service on top of any open descriptor. Typically,
this
descriptor is a connected socket for a stream protocol such
as
.SM TCP\s0.
.I sendsize
and
.I recvsize
indicate sizes for the send and receive buffers.  If they are
zero, a reasonable default is chosen.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcudp_bufcreate(sock, sendsize, recosize)
int sock;
.fi
.ft R
.IP
This routine creates a
.SM UDP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.B \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM UDP
port, then this routine binds it to an arbitrary port. Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails.
.IP
This allows the user to specify the maximun packet size for sending and 
receiving
.SM UDP\s0-based
.SM RPC messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_accepted_reply(xdrs, ar)
\s-1XDR\s0 *xdrs;
struct accepted_reply *ar;
.fi
.ft R
.IP
Used for encoding
.SM RPC
reply messages. This routine is useful for users who
wish to generate
\s-1RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_authunix_parms(xdrs, aupp)
\s-1XDR\s0 *xdrs;
struct authunix_parms *aupp;
.fi
.ft R
.IP
Used for describing
.SM UNIX
credentials. This routine is useful for users
who wish to generate these credentials without using the
.SM RPC
authentication package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
xdr_callhdr(xdrs, chdr)
\s-1XDR\s0 *xdrs;
struct rpc_msg *chdr;
.fi
.ft R
.IP
Used for describing
.SM RPC
call header messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_callmsg(xdrs, cmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *cmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
call messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_opaque_auth(xdrs, ap)
\s-1XDR\s0 *xdrs;
struct opaque_auth *ap;
.fi
.ft R
.IP
Used for describing
.SM RPC
authentication information messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmap(xdrs, regs)
\s-1XDR\s0 *xdrs;
struct pmap *regs;
.fi
.ft R
.IP
Used for describing parameters to various
.B portmap
procedures, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmaplist(xdrs, rp)
\s-1XDR\s0 *xdrs;
struct pmaplist **rp;
.fi
.ft R
.IP
Used for describing a list of port mappings, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_rejected_reply(xdrs, rr)
\s-1XDR\s0 *xdrs;
struct rejected_reply *rr;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_replymsg(xdrs, rmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *rmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC
style messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_register(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
After
.SM RPC
service transport handles are created,
they should register themselves with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_unregister(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Before an
.SM RPC
service transport handle is destroyed,
it should unregister itself with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.SH SEE ALSO
.BR rpc_secure (3N),
.BR xdr (3N)
.br
The following manuals:
.RS
.ft I
Remote Procedure Calls: Protocol Specification
.br
Remote Procedure Call Programming Guide
.br
rpcgen Programming Guide
.br
.ft R
.RE
.IR "\s-1RPC\s0: Remote Procedure Call Protocol Specification" ,
.SM RFC1050, Sun Microsystems, Inc.,
.SM USC-ISI\s0.

                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/clnt_freeres.3                               0100644 0001750 0001750 00000073141 12566167025 023427  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\"	from: @(#)rpc.3n	2.4 88/08/08 4.0 RPCSRC; from 1.19 88/06/24 SMI
.\"	$Id: rpc.3,v 1.1 1999/04/13 23:15:37 wsanchez Exp $
.\"
.TH RPC 3N "16 February 1988"
.SH NAME
rpc \- library routines for remote procedure calls
.SH SYNOPSIS AND DESCRIPTION
These routines allow C programs to make procedure
calls on other machines across the network.
First, the client calls a procedure to send a
data packet to the server.
Upon receipt of the packet, the server calls a dispatch routine
to perform the requested service, and then sends back a
reply.
Finally, the procedure call returns to the client.
.LP
Routines that are used for Secure RPC (DES authentication) are described in
.BR rpc_secure (3N).
Secure RPC can be used only if DES encryption is available.
.LP
.ft B
.nf
.sp .5
#include <rpc/rpc.h>
.fi
.ft R
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
auth_destroy(auth)
\s-1AUTH\s0 *auth;
.fi
.ft R
.IP
A macro that destroys the authentication information associated with
.IR auth .
Destruction usually involves deallocation of private data
structures. The use of
.I auth
is undefined after calling
.BR auth_destroy(\|) .
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authnone_create(\|)
.fi
.ft R
.IP
Create and returns an
.SM RPC
authentication handle that passes nonusable authentication
information with each remote procedure call. This is the
default authentication used by
.SM RPC.
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create(host, uid, gid, len, aup_gids)
char *host;
int uid, gid, len, *aup.gids;
.fi
.ft R
.IP
Create and return an
.SM RPC
authentication handle that contains
.UX
authentication information.
The parameter
.I host
is the name of the machine on which the information was
created;
.I uid
is the user's user
.SM ID ;
.I gid
is the user's current group
.SM ID ;
.I len
and
.I aup_gids
refer to a counted array of groups to which the user belongs.
It is easy to impersonate a user.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
\s-1AUTH\s0 *
authunix_create_default(\|)
.fi
.ft R
.IP
Calls
.B authunix_create(\|)
with the appropriate parameters.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
callrpc(host, prognum, versnum, procnum, inproc, in, outproc, out)
char *host;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Call the remote procedure associated with
.IR prognum ,
.IR versnum ,
and
.I procnum
on the machine,
.IR host .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results.
This routine returns zero if it succeeds, or the value of
.B "enum clnt_stat"
cast to an integer if it fails.
The routine
.B clnt_perrno(\|)
is handy for translating failure statuses into messages.
.IP
Warning: calling remote procedures with this routine
uses
.SM UDP/IP
as a transport; see
.B clntudp_create(\|)
for restrictions.
You do not have control of timeouts or authentication using
this routine.
.br
.if t .ne 16
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_broadcast(prognum, versnum, procnum, inproc, in, outproc, out, eachresult)
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
resultproc_t eachresult;
.fi
.ft R
.IP
Like
.BR callrpc(\|) ,
except the call message is broadcast to all locally
connected broadcast nets. Each time it receives a
response, this routine calls
.BR eachresult(\|) ,
whose form is:
.IP
.RS 1i
.ft B
.nf
eachresult(out, addr)
char *out;
struct sockaddr_in *addr;
.ft R
.fi
.RE
.IP
where
.I out
is the same as
.I out
passed to
.BR clnt_broadcast(\|) ,
except that the remote procedure's output is decoded there;
.I addr
points to the address of the machine that sent the results.
If
.B eachresult(\|)
returns zero,
.B clnt_broadcast(\|)
waits for more replies; otherwise it returns with appropriate
status.
.IP
Warning: broadcast sockets are limited in size to the
maximum transfer unit of the data link. For ethernet,
this value is 1500 bytes.
.br
.if t .ne 13
.LP
.ft B
.nf
.sp .5
enum clnt_stat
clnt_call(clnt, procnum, inproc, in, outproc, out, tout)
\s-1CLIENT\s0 *clnt;
u_long
procnum;
xdrproc_t inproc, outproc;
char *in, *out;
struct timeval tout;
.fi
.ft R
.IP
A macro that calls the remote procedure
.I procnum
associated with the client handle,
.IR clnt ,
which is obtained with an
.SM RPC
client creation routine such as
.BR clnt_create(\|) .
The parameter
.I in
is the address of the procedure's argument(s), and
.I out
is the address of where to place the result(s);
.I inproc
is used to encode the procedure's parameters, and
.I outproc
is used to decode the procedure's results;
.I tout
is the time allowed for results to come back.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
clnt_destroy(clnt)
\s-1CLIENT\s0 *clnt;
.fi
.ft R
.IP
A macro that destroys the client's
.SM RPC
handle. Destruction usually involves deallocation
of private data structures, including
.I clnt
itself.  Use of
.I clnt
is undefined after calling
.BR clnt_destroy(\|) .
If the
.SM RPC
library opened the associated socket, it will close it also.
Otherwise, the socket remains open.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnt_create(host, prog, vers, proto)
char *host;
u_long prog, vers;
char *proto;
.fi
.ft R
.IP
Generic client creation routine.
.I host
identifies the name of the remote host where the server
is located.
.I proto
indicates which kind of transport protocol to use. The
currently supported values for this field are \(lqudp\(rq
and \(lqtcp\(rq.
Default timeouts are set, but can be modified using
.BR clnt_control(\|) .
.IP
Warning: Using
.SM UDP
has its shortcomings.  Since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes of encoded data,
this transport cannot be used for procedures that take
large arguments or return huge results.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
bool_t
clnt_control(cl, req, info)
\s-1CLIENT\s0 *cl;
char *info;
.fi
.ft R
.IP
A macro used to change or retrieve various information
about a client object.
.I req
indicates the type of operation, and
.I info
is a pointer to the information. For both
.SM UDP
and
.SM TCP\s0,
the supported values of
.I req
and their argument types and what they do are:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_TIMEOUT\s0	struct timeval	set total timeout
.SM CLGET_TIMEOUT\s0	struct timeval	get total timeout
.fi
.IP
Note: if you set the timeout using
.BR clnt_control(\|) ,
the timeout parameter passed to
.B clnt_call(\|)
will be ignored in all future calls.
.IP
.nf
.SM CLGET_SERVER_ADDR\s0	struct sockaddr_in 	get server's address
.fi
.br
.IP
The following operations are valid for
.SM UDP
only:
.IP
.nf
.ta +2.0i +2.0i +2.0i
.SM CLSET_RETRY_TIMEOUT\s0		struct timeval	set the retry timeout
.SM CLGET_RETRY_TIMEOUT\s0		struct timeval	get the retry timeout
.fi
.br
.IP
The retry timeout is the time that
.SM "UDP RPC"
waits for the server to reply before
retransmitting the request.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
clnt_freeres(clnt, outproc, out)
\s-1CLIENT\s0 *clnt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the results of an
.SM RPC
call.  The
parameter
.I out
is the address of the results, and
.I outproc
is the
.SM XDR
routine describing the results.
This routine returns one if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
void
clnt_geterr(clnt, errp)
\s-1CLIENT\s0 *clnt;
struct rpc_err *errp;
.fi
.ft R
.IP
A macro that copies the error structure out of the client
handle
to the structure at address
.IR errp .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_pcreateerror(s)
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating
why a client
.SM RPC
handle could not be created.
The message is prepended with string
.I s
and a colon.
Used when a
.BR clnt_create(\|) ,
.BR clntraw_create(\|) ,
.BR clnttcp_create(\|) ,
or
.B clntudp_create(\|)
call fails.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
clnt_perrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Print a message to standard error corresponding
to the condition indicated by
.IR stat .
Used after
.BR callrpc(\|) .
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
clnt_perror(clnt, s)
\s-1CLIENT\s0 *clnt;
char *s;
.fi
.ft R
.IP
Print a message to standard error indicating why an
.SM RPC
call failed;
.I clnt
is the handle used to do the call.
The message is prepended with string
.I s
and a colon.
Used after
.BR clnt_call(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_spcreateerror
char *s;
.fi
.ft R
.IP
Like
.BR clnt_pcreateerror(\|) ,
except that it returns a string
instead of printing to the standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
char *
clnt_sperrno(stat)
enum clnt_stat stat;
.fi
.ft R
.IP
Take the same arguments as
.BR clnt_perrno(\|) ,
but instead of sending a message to the standard error
indicating why an
.SM RPC
call failed, return a pointer to a string which contains
the message.  The string ends with a
.SM NEWLINE\s0.
.IP
.B clnt_sperrno(\|)
is used instead of
.B clnt_perrno(\|)
if the program does not have a standard error (as a program
running as a server quite likely does not), or if the
programmer
does not want the message to be output with
.BR printf ,
or if a message format different than that supported by
.B clnt_perrno(\|)
is to be used.
Note: unlike
.B clnt_sperror(\|)
and
.BR clnt_spcreaterror(\|) ,
.B clnt_sperrno(\|)
returns pointer to static data, but the
result will not get overwritten on each call.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
char *
clnt_sperror(rpch, s)
\s-1CLIENT\s0 *rpch;
char *s;
.fi
.ft R
.IP
Like
.BR clnt_perror(\|) ,
except that (like
.BR clnt_sperrno(\|) )
it returns a string instead of printing to standard error.
.IP
Bugs: returns pointer to static data that is overwritten
on each call.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntraw_create(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum .
The transport used to pass messages to the service is
actually a buffer within the process's address space, so the
corresponding
.SM RPC
server should live in the same address space; see
.BR svcraw_create(\|) .
This allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads, such as round trip times, without any
kernel interference. This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clnttcp_create(addr, prognum, versnum, sockp, sendsz, recvsz)
struct sockaddr_in *addr;
u_long prognum, versnum;
int *sockp;
u_int sendsz, recvsz;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses
.SM TCP/IP
as a transport. The remote program is located at Internet
address
.IR *addr .
If
.\"The following in-line font conversion is necessary for the hyphen indicator
\fB\%addr\->sin_port\fR
is zero, then it is set to the actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
the user may specify the size of the send and receive buffers
with the parameters
.I sendsz
and
.IR recvsz ;
values of zero choose suitable defaults.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_create(addr, prognum, versnum, wait, sockp)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
version
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.IR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
Warning: since
.SM UDP\s0-based
.SM RPC
messages can only hold up to 8 Kbytes
of encoded data, this transport cannot be used for procedures
that take large arguments or return huge results.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
\s-1CLIENT\s0 *
clntudp_bufcreate(addr, prognum, versnum, wait, sockp, sendsize, recosize)
struct sockaddr_in *addr;
u_long prognum, versnum;
struct timeval wait;
int *sockp;
unsigned int sendsize;
unsigned int recosize;
.fi
.ft R
.IP
This routine creates an
.SM RPC
client for the remote program
.IR prognum ,
on
.IR versnum ;
the client uses use
.SM UDP/IP
as a transport. The remote program is located at Internet
address
.IR addr .
If
\fB\%addr\->sin_port\fR
is zero, then it is set to actual port that the remote
program is listening on (the remote
.B portmap
service is consulted for this information). The parameter
.I sockp
is a socket; if it is
.BR \s-1RPC_ANYSOCK\s0 ,
then this routine opens a new one and sets
.BR sockp .
The
.SM UDP
transport resends the call message in intervals of
.B wait
time until a response is received or until the call times
out.
The total time for the call to time out is specified by
.BR clnt_call(\|) .
.IP
This allows the user to specify the maximun packet size for sending and receiving 
.SM UDP\s0-based
.SM RPC
messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
get_myaddress(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
Stuff the machine's
.SM IP
address into
.IR *addr ,
without consulting the library routines that deal with
.BR /etc/hosts .
The port number is always set to
.BR htons(\s-1PMAPPORT\s0) .
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
struct pmaplist *
pmap_getmaps(addr)
struct sockaddr_in *addr;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns a list of the current
.SM RPC
program-to-port mappings
on the host located at
.SM IP
address
.IR *addr .
This routine can return
.SM NULL .
The command
.RB ` "rpcinfo \-p" '
uses this routine.
.br
.if t .ne 12
.LP
.ft B
.nf
.sp .5
u_short
pmap_getport(addr, prognum, versnum, protocol)
struct sockaddr_in *addr;
u_long prognum, versnum, protocol;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which returns the port number
on which waits a service that supports program number
.IR prognum ,
version
.IR versnum ,
and speaks the transport protocol associated with
.IR protocol .
The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
A return value of zero means that the mapping does not exist
or that
the
.SM RPC
system failured to contact the remote
.B portmap
service.  In the latter case, the global variable
.B rpc_createerr(\|)
contains the
.SM RPC
status.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
enum clnt_stat
pmap_rmtcall(addr, prognum, versnum, procnum, inproc, in, outproc, out, tout, portp)
struct sockaddr_in *addr;
u_long prognum, versnum, procnum;
char *in, *out;
xdrproc_t inproc, outproc;
struct timeval tout;
u_long *portp;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which instructs
.B portmap
on the host at
.SM IP
address
.I *addr
to make an
.SM RPC
call on your behalf to a procedure on that host.
The parameter
.I *portp
will be modified to the program's port number if the
procedure
succeeds. The definitions of other parameters are discussed
in
.B callrpc(\|)
and
.BR clnt_call(\|) .
This procedure should be used for a \(lqping\(rq and nothing
else.
See also
.BR clnt_broadcast(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
pmap_set(prognum, versnum, protocol, port)
u_long prognum, versnum, protocol;
u_short port;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which establishes a mapping between the triple
.RI [ prognum , versnum , protocol\fR]
and
.I port
on the machine's
.B portmap
service. The value of
.I protocol
is most likely
.B
.SM IPPROTO_UDP
or 
.BR \s-1IPPROTO_TCP\s0 .
This routine returns one if it succeeds, zero otherwise.
Automatically done by
.BR svc_register(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
pmap_unset(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
A user interface to the
.B portmap
service, which destroys all mapping between the triple
.RI [ prognum , versnum , *\fR]
and
.B ports
on the machine's
.B portmap
service. This routine returns one if it succeeds, zero
otherwise.
.br
.if t .ne 15
.LP
.ft B
.nf
.sp .5
registerrpc(prognum, versnum, procnum, procname, inproc, outproc)
u_long prognum, versnum, procnum;
char *(*procname) (\|) ;
xdrproc_t inproc, outproc;
.fi
.ft R
.IP
Register procedure
.I procname
with the
.SM RPC
service package.  If a request arrives for program
.IR prognum ,
version
.IR versnum ,
and procedure
.IR procnum ,
.I procname
is called with a pointer to its parameter(s);
.I progname
should return a pointer to its static result(s);
.I inproc
is used to decode the parameters while
.I outproc
is used to encode the results.
This routine returns zero if the registration succeeded, \-1
otherwise.
.IP
Warning: remote procedures registered in this form
are accessed using the
.SM UDP/IP
transport; see
.B svcudp_create(\|)
for restrictions.
.br
.if t .ne 5
.LP
.ft B
.nf
.sp .5
struct rpc_createerr     rpc_createerr;
.fi
.ft R
.IP
A global variable whose value is set by any
.SM RPC
client creation routine
that does not succeed.  Use the routine
.B clnt_pcreateerror(\|)
to print the reason why.
.if t .ne 7
.LP
.ft B
.nf
.sp .5
svc_destroy(xprt)
\s-1SVCXPRT\s0 *
xprt;
.fi
.ft R
.IP
A macro that destroys the
.SM RPC
service transport handle,
.IR xprt .
Destruction usually involves deallocation
of private data structures, including
.I xprt
itself.  Use of
.I xprt
is undefined after calling this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
fd_set svc_fdset;
.fi
.ft R
.IP
A global variable reflecting the
.SM RPC
service side's
read file descriptor bit mask; it is suitable as a parameter
to the
.B select
system call. This is only of interest
if a service implementor does not call
.BR svc_run(\|) ,
but rather does his own asynchronous event processing.
This variable is read-only (do not pass its address to
.BR select !),
yet it may change after calls to
.B svc_getreqset(\|)
or any creation routines.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
int svc_fds;
.fi
.ft R
.IP
Similar to
.BR svc_fedset(\|) ,
but limited to 32 descriptors. This
interface is obsoleted by
.BR svc_fdset(\|) .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_freeargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that frees any data allocated by the
.SM RPC/XDR
system when it decoded the arguments to a service procedure
using
.BR svc_getargs(\|) .
This routine returns 1 if the results were successfully
freed,
and zero otherwise.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
svc_getargs(xprt, inproc, in)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t inproc;
char *in;
.fi
.ft R
.IP
A macro that decodes the arguments of an
.SM RPC
request
associated with the
.SM RPC
service transport handle,
.IR xprt .
The parameter
.I in
is the address where the arguments will be placed;
.I inproc
is the
.SM XDR
routine used to decode the arguments.
This routine returns one if decoding succeeds, and zero
otherwise.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
struct sockaddr_in *
svc_getcaller(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
The approved way of getting the network address of the caller
of a procedure associated with the
.SM RPC
service transport handle,
.IR xprt .
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_getreqset(rdfds)
fd_set *rdfds;
.fi
.ft R
.IP
This routine is only of interest if a service implementor
does not call
.BR svc_run(\|) ,
but instead implements custom asynchronous event processing.
It is called when the
.B select
system call has determined that an
.SM RPC
request has arrived on some
.SM RPC
.B socket(s) ;
.I rdfds
is the resultant read file descriptor bit mask.
The routine returns when all sockets associated with the
value of
.I rdfds
have been serviced.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_getreq(rdfds)
int rdfds;
.fi
.ft R
.IP
Similar to
.BR svc_getreqset(\|) ,
but limited to 32 descriptors. This interface is obsoleted by
.BR svc_getreqset(\|) .
.br
.if t .ne 17
.LP
.ft B
.nf
.sp .5
svc_register(xprt, prognum, versnum, dispatch, protocol)
\s-1SVCXPRT\s0 *xprt;
u_long prognum, versnum;
void (*dispatch) (\|);
u_long protocol;
.fi
.ft R
.IP
Associates
.I prognum
and
.I versnum
with the service dispatch procedure,
.IR dispatch .
If
.I protocol
is zero, the service is not registered with the
.B portmap
service.  If
.I protocol
is non-zero, then a mapping of the triple
.RI [ prognum , versnum , protocol\fR]
to
\fB\%xprt\->xp_port\fR
is established with the local
.B portmap
service (generally
.I protocol
is zero,
.B
.SM IPPROTO_UDP
or 
.B
.SM IPPROTO_TCP
).
The procedure
.I dispatch
has the following form:
.RS 1i
.ft B
.nf
dispatch(request, xprt)
struct svc_req *request;
\s-1SVCXPRT\s0 *xprt;
.ft R
.fi
.RE
.IP
The
.B svc_register(\|)
routine returns one if it succeeds, and zero otherwise.
.br
.if t .ne 6
.LP
.ft B
.nf
.sp .5
svc_run(\|)
.fi
.ft R
.IP
This routine never returns. It waits for
.SM RPC
requests to arrive, and calls the appropriate service
procedure using
.B svc_getreq(\|)
when one arrives. This procedure is usually waiting for a
.B select(\|)
system call to return.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
svc_sendreply(xprt, outproc, out)
\s-1SVCXPRT\s0 *xprt;
xdrproc_t outproc;
char *out;
.fi
.ft R
.IP
Called by an
.SM RPC
service's dispatch routine to send the results of a
remote procedure call.  The parameter
.I xprt
is the request's associated transport handle;
.I outproc
is the
.SM XDR
routine which is used to encode the results; and
.I out
is the address of the results.
This routine returns one if it succeeds, zero otherwise.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svc_unregister(prognum, versnum)
u_long prognum, versnum;
.fi
.ft R
.IP
Remove all mapping of the double
.RI [ prognum , versnum ]
to dispatch routines, and of the triple
.RI [ prognum , versnum , *\fR]
to port number.
.br
.if t .ne 9
.LP
.ft B
.nf
.sp .5
void
svcerr_auth(xprt, why)
\s-1SVCXPRT\s0 *xprt;
enum auth_stat why;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to an authentication error.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_decode(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that cannot successfully
decode its parameters. See also
.BR svc_getargs(\|) .
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noproc(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that does not implement
the procedure number that the caller requests.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_noprog(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired program is not registered with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_progvers(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called when the desired version of a program is not registered
with the
.SM RPC
package. Service implementors usually do not need this routine.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
svcerr_systemerr(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine when it detects a system
error
not covered by any particular protocol.
For example, if a service can no longer allocate storage,
it may call this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
svcerr_weakauth(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Called by a service dispatch routine that refuses to perform
a remote procedure call due to insufficient
authentication parameters.  The routine calls
.BR "svcerr_auth(xprt, \s-1AUTH_TOOWEAK\s0)" .
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcraw_create(\|)
.fi
.ft R
.IP
This routine creates a toy
.SM RPC
service transport, to which it returns a pointer.  The
transport
is really a buffer within the process's address space,
so the corresponding
.SM RPC
client should live in the same
address space;
see
.BR clntraw_create(\|) .
This routine allows simulation of
.SM RPC
and acquisition of
.SM RPC
overheads (such as round trip times), without any kernel
interference.
This routine returns
.SM NULL
if it fails.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svctcp_create(sock, send_buf_size, recv_buf_size)
int sock;
u_int send_buf_size, recv_buf_size;
.fi
.ft R
.IP
This routine creates a
.SM TCP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.BR \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM TCP
port, then this routine binds it to an arbitrary port.  Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails. Since
.SM TCP\s0-based
.SM RPC
uses buffered
.SM I/O ,
users may specify the size of buffers; values of zero
choose suitable defaults.
.br
.if t .ne 11
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcfd_create(fd, sendsize, recvsize)
int fd;
u_int sendsize;
u_int recvsize;
.fi
.ft R
.IP
Create a service on top of any open descriptor. Typically,
this
descriptor is a connected socket for a stream protocol such
as
.SM TCP\s0.
.I sendsize
and
.I recvsize
indicate sizes for the send and receive buffers.  If they are
zero, a reasonable default is chosen.
.br
.if t .ne 10
.LP
.ft B
.nf
.sp .5
\s-1SVCXPRT\s0 *
svcudp_bufcreate(sock, sendsize, recosize)
int sock;
.fi
.ft R
.IP
This routine creates a
.SM UDP/IP\s0-based
.SM RPC
service transport, to which it returns a pointer.
The transport is associated with the socket
.IR sock ,
which may be
.B \s-1RPC_ANYSOCK\s0 ,
in which case a new socket is created.
If the socket is not bound to a local
.SM UDP
port, then this routine binds it to an arbitrary port. Upon
completion,
\fB\%xprt\->xp_sock\fR
is the transport's socket descriptor, and
\fB\%xprt\->xp_port\fR
is the transport's port number.
This routine returns
.SM NULL
if it fails.
.IP
This allows the user to specify the maximun packet size for sending and 
receiving
.SM UDP\s0-based
.SM RPC messages.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_accepted_reply(xdrs, ar)
\s-1XDR\s0 *xdrs;
struct accepted_reply *ar;
.fi
.ft R
.IP
Used for encoding
.SM RPC
reply messages. This routine is useful for users who
wish to generate
\s-1RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_authunix_parms(xdrs, aupp)
\s-1XDR\s0 *xdrs;
struct authunix_parms *aupp;
.fi
.ft R
.IP
Used for describing
.SM UNIX
credentials. This routine is useful for users
who wish to generate these credentials without using the
.SM RPC
authentication package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
void
xdr_callhdr(xdrs, chdr)
\s-1XDR\s0 *xdrs;
struct rpc_msg *chdr;
.fi
.ft R
.IP
Used for describing
.SM RPC
call header messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_callmsg(xdrs, cmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *cmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
call messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_opaque_auth(xdrs, ap)
\s-1XDR\s0 *xdrs;
struct opaque_auth *ap;
.fi
.ft R
.IP
Used for describing
.SM RPC
authentication information messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmap(xdrs, regs)
\s-1XDR\s0 *xdrs;
struct pmap *regs;
.fi
.ft R
.IP
Used for describing parameters to various
.B portmap
procedures, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_pmaplist(xdrs, rp)
\s-1XDR\s0 *xdrs;
struct pmaplist **rp;
.fi
.ft R
.IP
Used for describing a list of port mappings, externally.
This routine is useful for users who wish to generate
these parameters without using the
.B pmap
interface.
.br
.if t .ne 7
.LP
.ft B
.nf
.sp .5
xdr_rejected_reply(xdrs, rr)
\s-1XDR\s0 *xdrs;
struct rejected_reply *rr;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC\s0-style
messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
xdr_replymsg(xdrs, rmsg)
\s-1XDR\s0 *xdrs;
struct rpc_msg *rmsg;
.fi
.ft R
.IP
Used for describing
.SM RPC
reply messages.
This routine is useful for users who wish to generate
.SM RPC
style messages without using the
.SM RPC
package.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_register(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
After
.SM RPC
service transport handles are created,
they should register themselves with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.br
.if t .ne 8
.LP
.ft B
.nf
.sp .5
void
xprt_unregister(xprt)
\s-1SVCXPRT\s0 *xprt;
.fi
.ft R
.IP
Before an
.SM RPC
service transport handle is destroyed,
it should unregister itself with the
.SM RPC
service package.
This routine modifies the global variable
.BR svc_fds(\|) .
Service implementors usually do not need this routine.
.SH SEE ALSO
.BR rpc_secure (3N),
.BR xdr (3N)
.br
The following manuals:
.RS
.ft I
Remote Procedure Calls: Protocol Specification
.br
Remote Procedure Call Programming Guide
.br
rpcgen Programming Guide
.br
.ft R
.RE
.IR "\s-1RPC\s0: Remot