ment
\&    print "And here it is, bizarrely rerendered as HTML:\en",
\&      $tree\->as_HTML, "\en";
\&
\&    # Now that we\*(Aqre done with it, we must destroy it.
\&    # $tree = $tree\->delete; # Not required with weak references
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
(This class is part of the HTML::Tree dist.)
.PP
This class is for \s-1HTML\s0 syntax trees that get built out of \s-1HTML\s0
source.  The way to use it is to:
.PP
1. start a new (empty) HTML::TreeBuilder object,
.PP
2. then use one of the methods from HTML::Parser (presumably with
\&\f(CW\*(C`$tree\->parse_file($filename)\*(C'\fR for files, or with
\&\f(CW\*(C`$tree\->parse($document_content)\*(C'\fR and \f(CW\*(C`$tree\->eof\*(C'\fR if you've got
the content in a string) to parse the \s-1HTML\s0
document into the tree \f(CW$tree\fR.
.PP
(You can combine steps 1 and 2 with the \*(L"new_from_file\*(R" or
\&\*(L"new_from_content\*(R" methods.)
.PP
2b. call \f(CW\*(C`$root\->elementify()\*(C'\fR if you want.
.PP
3. do whatever you need to do with the syntax tree, presumably
involving traversing it looking for some bit of information in it,
.PP
4. previous versions of HTML::TreeBuilder required you to call
\&\f(CW\*(C`$tree\->delete()\*(C'\fR to erase the contents of the tree from memory
when you're done with the tree.  This is not normally required anymore.
See \*(L"Weak References\*(R" in HTML::Element for details.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Most of the following attributes native to HTML::TreeBuilder control how
parsing takes place; they should be set \fIbefore\fR you try parsing into
the given object.  You can set the attributes by passing a \s-1TRUE\s0 or
\&\s-1FALSE\s0 value as argument.  E.g., \f(CW\*(C`$root\->implicit_tags\*(C'\fR returns
the current setting for the \f(CW\*(C`implicit_tags\*(C'\fR option,
\&\f(CW\*(C`$root\->implicit_tags(1)\*(C'\fR turns that option on,
and \f(CW\*(C`$root\->implicit_tags(0)\*(C'\fR turns it off.
.SS "implicit_tags"
.IX Subsection "implicit_tags"
Setting this attribute to true will instruct the parser to try to
deduce implicit elements and implicit end tags.  If it is false you
get a parse tree that just reflects the text as it stands, which is
unlikely to be useful for anything but quick and dirty parsing.
(In fact, I'd be curious to hear from anyone who finds it useful to
have \f(CW\*(C`implicit_tags\*(C'\fR set to false.)
Default is true.
.PP
Implicit elements have the \*(L"implicit\*(R" in HTML::Element attribute set.
.SS "implicit_body_p_tag"
.IX Subsection "implicit_body_p_tag"
This controls an aspect of implicit element behavior, if \f(CW\*(C`implicit_tags\*(C'\fR
is on:  If a text element (\s-1PCDATA\s0) or a phrasal element (such as
\&\f(CW\*(C`<em>\*(C'\fR) is to be inserted under \f(CW\*(C`<body>\*(C'\fR, two things
can happen: if \f(CW\*(C`implicit_body_p_tag\*(C'\fR is true, it's placed under a new,
implicit \f(CW\*(C`<p>\*(C'\fR tag.  (Past DTDs suggested this was the only
correct behavior, and this is how past versions of this module
behaved.)  But if \f(CW\*(C`implicit_body_p_tag\*(C'\fR is false, nothing is implicated
\&\*(-- the \s-1PCDATA\s0 or phrasal element is simply placed under
\&\f(CW\*(C`<body>\*(C'\fR.  Default is false.
.SS "no_expand_entities"
.IX Subsection "no_expand_entities"
This attribute controls whether entities are decoded during the initial
parse of the source. Enable this if you don't want entities decoded to
their character value. e.g. '&amp;' is decoded to '&' by default, but
will be unchanged if this is enabled.
Default is false (entities will be decoded.)
.SS "ignore_unknown"
.IX Subsection "ignore_unknown"
This attribute controls whether unknown tags should be represented as
elements in the parse tree, or whether they should be ignored.
Default is true (to ignore unknown tags.)
.SS "ignore_text"
.IX Subsection "ignore_text"
Do not represent the text content of elements.  This saves space if
all you want is to examine the structure of the document.  Default is
false.
.SS "ignore_ignorable_whitespace"
.IX Subsection "ignore_ignorable_whitespace"
If set to true, TreeBuilder will try to avoid
creating ignorable whitespace text nodes in the tree.  Default is
true.  (In fact, I'd be interested in hearing if there's ever a case
where you need this off, or where leaving it on leads to incorrect
behavior.)
.SS "no_space_compacting"
.IX Subsection "no_space_compacting"
This determines whether TreeBuilder compacts all whitespace strings
in the document (well, outside of \s-1PRE\s0 or \s-1TEXTAREA\s0 elements), or
leaves them alone.  Normally (default, value of 0), each string of
contiguous whitespace in the document is turned into a single space.
But that's not done if \f(CW\*(C`no_space_compacting\*(C'\fR is set to 1.
.PP
Setting \f(CW\*(C`no_space_compacting\*(C'\fR to 1 might be useful if you want
to read in a tree just to make some minor changes to it before
writing it back out.
.PP
This method is experimental.  If you use it, be sure to report
any problems you might have with it.
.SS "p_strict"
.IX Subsection "p_strict"
If set to true (and it defaults to false), TreeBuilder will take a
narrower than normal view of what can be under a \f(CW\*(C`<p>\*(C'\fR element; if it sees
a non-phrasal element about to be inserted under a \f(CW\*(C`<p>\*(C'\fR, it will
close that \f(CW\*(C`<p>\*(C'\fR.  Otherwise it will close \f(CW\*(C`<p>\*(C'\fR elements only for
other \f(CW\*(C`<p>\*(C'\fR's, headings, and \f(CW\*(C`<form>\*(C'\fR (although the latter may be
removed in future versions).
.PP
For example, when going thru this snippet of code,
.PP
.Vb 2
\&  <p>stuff
\&  <ul>
.Ve
.PP
TreeBuilder will normally (with \f(CW\*(C`p_strict\*(C'\fR false) put the \f(CW\*(C`<ul>\*(C'\fR element
under the \f(CW\*(C`<p>\*(C'\fR element.  However, with \f(CW\*(C`p_strict\*(C'\fR set to true, it will
close the \f(CW\*(C`<p>\*(C'\fR first.
.PP
In theory, there should be strictness options like this for other/all
elements besides just \f(CW\*(C`<p>\*(C'\fR; but I treat this as a special case simply
because of the fact that \f(CW\*(C`<p>\*(C'\fR occurs so frequently and its end-tag is
omitted so often; and also because application of strictness rules
at parse-time across all elements often makes tiny errors in \s-1HTML\s0
coding produce drastically bad parse-trees, in my experience.
.PP
If you find that you wish you had an option like this to enforce
content-models on all elements, then I suggest that what you want is
content-model checking as a stage after TreeBuilder has finished
parsing.
.SS "store_comments"
.IX Subsection "store_comments"
This determines whether TreeBuilder will normally store comments found
while parsing content into \f(CW$root\fR.  Currently, this is off by default.
.SS "store_declarations"
.IX Subsection "store_declarations"
This determines whether TreeBuilder will normally store markup
declarations found while parsing content into \f(CW$root\fR.  This is on
by default.
.SS "store_pis"
.IX Subsection "store_pis"
This determines whether TreeBuilder will normally store processing
instructions found while parsing content into \f(CW$root\fR \*(-- assuming a
recent version of HTML::Parser (old versions won't parse PIs
correctly).  Currently, this is off (false) by default.
.PP
It is somewhat of a known bug (to be fixed one of these days, if
anyone needs it?) that PIs in the preamble (before the \f(CW\*(C`<html>\*(C'\fR
start-tag) end up actually \fIunder\fR the \f(CW\*(C`<html>\*(C'\fR element.
.SS "warn"
.IX Subsection "warn"
This determines whether syntax errors during parsing should generate
warnings, emitted via Perl's \f(CW\*(C`warn\*(C'\fR function.
.PP
This is off (false) by default.
.SH "METHODS"
.IX Header "METHODS"
Objects of this class inherit the methods of both HTML::Parser and
HTML::Element.  The methods inherited from HTML::Parser are used for
building the \s-1HTML\s0 tree, and the methods inherited from HTML::Element
are what you use to scrutinize the tree.  Besides this
(HTML::TreeBuilder) documentation, you must also carefully read the
HTML::Element documentation, and also skim the HTML::Parser
documentation \*(-- probably only its parse and parse_file methods are of
interest.
.SS "new_from_file"
.IX Subsection "new_from_file"
.Vb 1
\&  $root = HTML::TreeBuilder\->new_from_file($filename_or_filehandle);
.Ve
.PP
This \*(L"shortcut\*(R" constructor merely combines constructing a new object
(with the \*(L"new\*(R" method, below), and calling \f(CW\*(C`$new\->parse_file(...)\*(C'\fR on
it.  Returns the new object.  Note that this provides no way of
setting any parse options like \f(CW\*(C`store_comments\*(C'\fR (for that, call \f(CW\*(C`new\*(C'\fR, and
then set options, before calling \f(CW\*(C`parse_file\*(C'\fR).  See the notes (below)
on parameters to \*(L"parse_file\*(R".
.PP
If HTML::TreeBuilder is unable to read the file, then \f(CW\*(C`new_from_file\*(C'\fR
dies.  The error can also be found in \f(CW$!\fR.  (This behavior is new in
HTML-Tree 5. Previous versions returned a tree with only implicit elements.)
.SS "new_from_content"
.IX Subsection "new_from_content"
.Vb 1
\&  $root = HTML::TreeBuilder\->new_from_content(...);
.Ve
.PP
This \*(L"shortcut\*(R" constructor merely combines constructing a new object
(with the \*(L"new\*(R" method, below), and calling \f(CW\*(C`for(...){$new\->parse($_)}\*(C'\fR
and \f(CW\*(C`$new\->eof\*(C'\fR on it.  Returns the new object.  Note that this provides
no way of setting any parse options like \f(CW\*(C`store_comments\*(C'\fR (for that,
call \f(CW\*(C`new\*(C'\fR, and then set options, before calling \f(CW\*(C`parse\*(C'\fR).  Example
usages: \f(CW\*(C`HTML::TreeBuilder\->new_from_content(@lines)\*(C'\fR, or
\&\f(CW\*(C`HTML::TreeBuilder\->new_from_content($content)\*(C'\fR.
.SS "new_from_url"
.IX Subsection "new_from_url"
.Vb 1
\&  $root = HTML::TreeBuilder\->new_from_url($url)
.Ve
.PP
This \*(L"shortcut\*(R" constructor combines constructing a new object (with
the \*(L"new\*(R" method, below), loading LWP::UserAgent, fetching the
specified \s-1URL,\s0 and calling \f(CW\*(C`$new\->parse( $response\->decoded_content)\*(C'\fR
and \f(CW\*(C`$new\->eof\*(C'\fR on it.
Returns the new object.  Note that this provides no way of setting any
parse options like \f(CW\*(C`store_comments\*(C'\fR.
.PP
If \s-1LWP\s0 is unable to fetch the \s-1URL,\s0 or the response is not \s-1HTML \s0(as
determined by \*(L"content_is_html\*(R" in HTTP::Headers), then \f(CW\*(C`new_from_url\*(C'\fR
dies, and the HTTP::Response object is found in
\&\f(CW$HTML::TreeBuilder::lwp_response\fR.
.PP
You must have installed LWP::UserAgent for this method to work.  \s-1LWP\s0
is not installed automatically, because it's a large set of modules
and you might not need it.
.SS "new"
.IX Subsection "new"
.Vb 1
\&  $root = HTML::TreeBuilder\->new();
.Ve
.PP
This creates a new HTML::TreeBuilder object.  This method takes no
attributes.
.SS "parse_file"
.IX Subsection "parse_file"
.Vb 1
\& $root\->parse_file(...)
.Ve
.PP
[An important method inherited from HTML::Parser, which
see.  Current versions of HTML::Parser can take a filespec, or a
filehandle object, like *FOO, or some object from class IO::Handle,
IO::File, IO::Socket) or the like.
I think you should check that a given file exists \fIbefore\fR calling
\&\f(CW\*(C`$root\->parse_file($filespec)\*(C'\fR.]
.PP
When you pass a filename to \f(CW\*(C`parse_file\*(C'\fR, HTML::Parser opens it in
binary mode, which means it's interpreted as Latin\-1 (\s-1ISO\-8859\-1\s0).  If
the file is in another encoding, like \s-1UTF\-8\s0 or \s-1UTF\-16,\s0 this will not
do the right thing.
.PP
One solution is to open the file yourself using the proper
\&\f(CW\*(C`:encoding\*(C'\fR layer, and pass the filehandle to \f(CW\*(C`parse_file\*(C'\fR.  You can
automate this process by using \*(L"html_file\*(R" in \s-1IO::HTML\s0, which will use
the \s-1HTML5\s0 encoding sniffing algorithm to automatically determine the
proper \f(CW\*(C`:encoding\*(C'\fR layer and apply it.
.PP
In the next major release of HTML-Tree, I plan to have it use \s-1IO::HTML\s0
automatically.  If you really want your file opened in binary mode,
you should open it yourself and pass the filehandle to \f(CW\*(C`parse_file\*(C'\fR.
.PP
The return value is \f(CW\*(C`undef\*(C'\fR if there's an error opening the file.  In
that case, the error will be in \f(CW$!\fR.
.SS "parse"
.IX Subsection "parse"
.Vb 1
\&  $root\->parse(...)
.Ve
.PP
[A important method inherited from HTML::Parser, which
see.  See the note below for \f(CW\*(C`$root\->eof()\*(C'\fR.]
.SS "eof"
.IX Subsection "eof"
.Vb 1
\&  $root\->eof();
.Ve
.PP
This signals that you're finished parsing content into this tree; this
runs various kinds of crucial cleanup on the tree.  This is called
\&\fIfor you\fR when you call \f(CW\*(C`$root\->parse_file(...)\*(C'\fR, but not when
you call \f(CW\*(C`$root\->parse(...)\*(C'\fR.  So if you call
\&\f(CW\*(C`$root\->parse(...)\*(C'\fR, then you \fImust\fR call \f(CW\*(C`$root\->eof()\*(C'\fR
once you've finished feeding all the chunks to \f(CW\*(C`parse(...)\*(C'\fR, and
before you actually start doing anything else with the tree in \f(CW$root\fR.
.SS "parse_content"
.IX Subsection "parse_content"
.Vb 1
\&  $root\->parse_content(...);
.Ve
.PP
Basically a handy alias for \f(CW\*(C`$root\->parse(...); $root\->eof\*(C'\fR.
Takes the exact same arguments as \f(CW\*(C`$root\->parse()\*(C'\fR.
.SS "delete"
.IX Subsection "delete"
.Vb 1
\&  $root\->delete();
.Ve
.PP
[A previously important method inherited from HTML::Element,
which see.]
.SS "elementify"
.IX Subsection "elementify"
.Vb 1
\&  $root\->elementify();
.Ve
.PP
This changes the class of the object in \f(CW$root\fR from
HTML::TreeBuilder to the class used for all the rest of the elements
in that tree (generally HTML::Element).  Returns \f(CW$root\fR.
.PP
For most purposes, this is unnecessary, but if you call this after
(after!!)
you've finished building a tree, then it keeps you from accidentally
trying to call anything but HTML::Element methods on it.  (I.e., if
you accidentally call \f(CW\*(C`$root\->parse_file(...)\*(C'\fR on the
already-complete and elementified tree, then instead of charging ahead
and \fIwreaking havoc\fR, it'll throw a fatal error \*(-- since \f(CW$root\fR is
now an object just of class HTML::Element which has no \f(CW\*(C`parse_file\*(C'\fR
method.
.PP
Note that \f(CW\*(C`elementify\*(C'\fR currently deletes all the private attributes of
\&\f(CW$root\fR except for \*(L"_tag\*(R", \*(L"_parent\*(R", \*(L"_content\*(R", \*(L"_pos\*(R", and
\&\*(L"_implicit\*(R".  If anyone requests that I change this to leave in yet
more private attributes, I might do so, in future versions.
.SS "guts"
.IX Subsection "guts"
.Vb 2
\& @nodes = $root\->guts();
\& $parent_for_nodes = $root\->guts();
.Ve
.PP
In list context (as in the first case), this method returns the topmost
non-implicit nodes in a tree.  This is useful when you're parsing \s-1HTML\s0
code that you know doesn't expect an \s-1HTML\s0 document, but instead just
a fragment of an \s-1HTML\s0 document.  For example, if you wanted the parse
tree for a file consisting of just this:
.PP
.Vb 1
\&  <li>I like pie!
.Ve
.PP
Then you would get that with \f(CW\*(C`@nodes = $root\->guts();\*(C'\fR.
It so happens that in this case, \f(CW@nodes\fR will contain just one
element object, representing the \f(CW\*(C`<li>\*(C'\fR node (with \*(L"I like pie!\*(R" being
its text child node).  However, consider if you were parsing this:
.PP
.Vb 1
\&  <hr>Hooboy!<hr>
.Ve
.PP
In that case, \f(CW\*(C`$root\->guts()\*(C'\fR would return three items:
an element object for the first \f(CW\*(C`<hr>\*(C'\fR, a text string \*(L"Hooboy!\*(R", and
another \f(CW\*(C`<hr>\*(C'\fR element object.
.PP
For cases where you want definitely one element (so you can treat it as
a \*(L"document fragment\*(R", roughly speaking), call \f(CW\*(C`guts()\*(C'\fR in scalar
context, as in \f(CW\*(C`$parent_for_nodes = $root\->guts()\*(C'\fR. That works like
\&\f(CW\*(C`guts()\*(C'\fR in list context; in fact, \f(CW\*(C`guts()\*(C'\fR in list context would
have returned exactly one value, and if it would have been an object (as
opposed to a text string), then that's what \f(CW\*(C`guts\*(C'\fR in scalar context
will return.  Otherwise, if \f(CW\*(C`guts()\*(C'\fR in list context would have returned
no values at all, then \f(CW\*(C`guts()\*(C'\fR in scalar context returns undef.  In
all other cases, \f(CW\*(C`guts()\*(C'\fR in scalar context returns an implicit \f(CW\*(C`<div>\*(C'\fR
element node, with children consisting of whatever nodes \f(CW\*(C`guts()\*(C'\fR
in list context would have returned.  Note that that may detach those
nodes from \f(CW$root\fR's tree.
.SS "disembowel"
.IX Subsection "disembowel"
.Vb 2
\&  @nodes = $root\->disembowel();
\&  $parent_for_nodes = $root\->disembowel();
.Ve
.PP
The \f(CW\*(C`disembowel()\*(C'\fR method works just like the \f(CW\*(C`guts()\*(C'\fR method, except
that disembowel definitively destroys the tree above the nodes that
are returned.  Usually when you want the guts from a tree, you're just
going to toss out the rest of the tree anyway, so this saves you the
bother.  (Remember, \*(L"disembowel\*(R" means \*(L"remove the guts from\*(R".)
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
You should not need to call any of the following methods directly.
.SS "element_class"
.IX Subsection "element_class"
.Vb 1
\&  $classname = $h\->element_class;
.Ve
.PP
This method returns the class which will be used for new elements.  It
defaults to HTML::Element, but can be overridden by subclassing or esoteric
means best left to those will will read the source and then not complain when
those esoteric means change.  (Just subclass.)
.SS "comment"
.IX Subsection "comment"
Accept a \*(L"here's a comment\*(R" signal from HTML::Parser.
.SS "declaration"
.IX Subsection "declaration"
Accept a \*(L"here's a markup declaration\*(R" signal from HTML::Parser.
.SS "done"
.IX Subsection "done"
\&\s-1TODO:\s0 document
.SS "end"
.IX Subsection "end"
Either: Acccept an end-tag signal from HTML::Parser
Or: Method for closing currently open elements in some fairly complex
way, as used by other methods in this class.
.PP
\&\s-1TODO:\s0 Why is this hidden?
.SS "process"
.IX Subsection "process"
Accept a \*(L"here's a \s-1PI\*(R"\s0 signal from HTML::Parser.
.SS "start"
.IX Subsection "start"
Accept a signal from HTML::Parser for start-tags.
.PP
\&\s-1TODO:\s0 Why is this hidden?
.SS "stunt"
.IX Subsection "stunt"
\&\s-1TODO:\s0 document
.SS "stunted"
.IX Subsection "stunted"
\&\s-1TODO:\s0 document
.SS "text"
.IX Subsection "text"
Accept a \*(L"here's a text token\*(R" signal from HTML::Parser.
.PP
\&\s-1TODO:\s0 Why is this hidden?
.SS "tighten_up"
.IX Subsection "tighten_up"
Legacy
.PP
Redirects to \*(L"delete_ignorable_whitespace\*(R" in HTML::Element.
.SS "warning"
.IX Subsection "warning"
Wrapper for CORE::warn
.PP
\&\s-1TODO:\s0 why not just use carp?
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.SS "\s-1DEBUG\s0"
.IX Subsection "DEBUG"
Are we in Debug mode?  This is a constant subroutine, to allow
compile-time optimizations.  To control debug mode, set
\&\f(CW$HTML::TreeBuilder::DEBUG\fR \fIbefore\fR loading HTML::TreeBuilder.
.SH "HTML AND ITS DISCONTENTS"
.IX Header "HTML AND ITS DISCONTENTS"
\&\s-1HTML\s0 is rather harder to parse than people who write it generally
suspect.
.PP
Here's the problem: \s-1HTML\s0 is a kind of \s-1SGML\s0 that permits \*(L"minimization\*(R"
and \*(L"implication\*(R".  In short, this means that you don't have to close
every tag you open (because the opening of a subsequent tag may
implicitly close it), and if you use a tag that can't occur in the
context you seem to using it in, under certain conditions the parser
will be able to realize you mean to leave the current context and
enter the new one, that being the only one that your code could
correctly be interpreted in.
.PP
Now, this would all work flawlessly and unproblematically if: 1) all
the rules that both prescribe and describe \s-1HTML\s0 were (and had been)
clearly set out, and 2) everyone was aware of these rules and wrote
their code in compliance to them.
.PP
However, it didn't happen that way, and so most \s-1HTML\s0 pages are
difficult if not impossible to correctly parse with nearly any set of
straightforward \s-1SGML\s0 rules.  That's why the internals of
HTML::TreeBuilder consist of lots and lots of special cases \*(-- instead
of being just a generic \s-1SGML\s0 parser with \s-1HTML DTD\s0 rules plugged in.
.SH "TRANSLATIONS?"
.IX Header "TRANSLATIONS?"
The techniques that HTML::TreeBuilder uses to perform what I consider
very robust parses on everyday code are not things that can work only
in Perl.  To date, the algorithms at the center of HTML::TreeBuilder
have been implemented only in Perl, as far as I know; and I don't
foresee getting around to implementing them in any other language any
time soon.
.PP
If, however, anyone is looking for a semester project for an applied
programming class (or if they merely enjoy \fIextra-curricular\fR
masochism), they might do well to see about choosing as a topic the
implementation/adaptation of these routines to any other interesting
programming language that you feel currently suffers from a lack of
robust HTML-parsing.  I welcome correspondence on this subject, and
point out that one can learn a great deal about languages by trying to
translate between them, and then comparing the result.
.PP
The HTML::TreeBuilder source may seem long and complex, but it is
rather well commented, and symbol names are generally
self-explanatory.  (You are encouraged to read the Mozilla \s-1HTML\s0 parser
source for comparison.)  Some of the complexity comes from little-used
features, and some of it comes from having the \s-1HTML\s0 tokenizer
(HTML::Parser) being a separate module, requiring somewhat of a
different interface than you'd find in a combined tokenizer and
tree-builder.  But most of the length of the source comes from the fact
that it's essentially a long list of special cases, with lots and lots
of sanity-checking, and sanity-recovery \*(-- because, as Roseanne
Rosannadanna once said, "it's always \fIsomething\fR".
.PP
Users looking to compare several \s-1HTML\s0 parsers should look at the
source for Raggett's Tidy
(\f(CW\*(C`<http://www.w3.org/People/Raggett/tidy/>\*(C'\fR),
Mozilla
(\f(CW\*(C`<http://www.mozilla.org/>\*(C'\fR),
and possibly root around the browsers section of Yahoo
to find the various open-source ones
(\f(CW\*(C`<http://dir.yahoo.com/Computers_and_Internet/Software/Internet/World_Wide_Web/Browsers/>\*(C'\fR).
.SH "BUGS"
.IX Header "BUGS"
* Framesets seem to work correctly now.  Email me if you get a strange
parse from a document with framesets.
.PP
* Really bad \s-1HTML\s0 code will, often as not, make for a somewhat
objectionable parse tree.  Regrettable, but unavoidably true.
.PP
* If you're running with \f(CW\*(C`implicit_tags\*(C'\fR off (God help you!), consider
that \f(CW\*(C`$tree\->content_list\*(C'\fR probably contains the tree or grove from the
parse, and not \f(CW$tree\fR itself (which will, oddly enough, be an implicit
\&\f(CW\*(C`<html>\*(C'\fR element).  This seems counter-intuitive and problematic; but
seeing as how almost no \s-1HTML\s0 ever parses correctly with \f(CW\*(C`implicit_tags\*(C'\fR
off, this interface oddity seems the least of your problems.
.SH "BUG REPORTS"
.IX Header "BUG REPORTS"
When a document parses in a way different from how you think it
should, I ask that you report this to me as a bug.  The first thing
you should do is copy the document, trim out as much of it as you can
while still producing the bug in question, and \fIthen\fR email me that
mini-document \fIand\fR the code you're using to parse it, to the HTML::Tree
bug queue at \f(CW\*(C`<bug\-html\-tree\ at\ rt.cpan.org>\*(C'\fR.
.PP
Include a note as to how it
parses (presumably including its \f(CW\*(C`$tree\->dump\*(C'\fR output), and then a
\&\fIcareful and clear\fR explanation of where you think the parser is
going astray, and how you would prefer that it work instead.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
For more information about the HTML-Tree distribution: HTML::Tree.
.PP
Modules used by HTML::TreeBuilder:
HTML::Parser, HTML::Element, HTML::Tagset.
.PP
For converting between XML::DOM::Node, HTML::Element, and
XML::Element trees: HTML::DOMbo.
.PP
For opening a \s-1HTML\s0 file with automatic charset detection: \s-1IO::HTML\s0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Current maintainers:
.IP "\(bu" 4
Christopher J. Madsen \f(CW\*(C`<perl\ AT\ cjmweb.net>\*(C'\fR
.IP "\(bu" 4
Jeff Fearn \f(CW\*(C`<jfearn\ AT\ cpan.org>\*(C'\fR
.PP
Original HTML-Tree author:
.IP "\(bu" 4
Gisle Aas
.PP
Former maintainers:
.IP "\(bu" 4
Sean M. Burke
.IP "\(bu" 4
Andy Lester
.IP "\(bu" 4
Pete Krawczyk \f(CW\*(C`<petek\ AT\ cpan.org>\*(C'\fR
.PP
You can follow or contribute to HTML-Tree's development at
<http://github.com/madsen/HTML\-Tree>.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1995\-1998 Gisle Aas, 1999\-2004 Sean M. Burke,
2005 Andy Lester, 2006 Pete Krawczyk, 2010 Jeff Fearn,
2012 Christopher J. Madsen.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
The programs in this library are distributed in the hope that they
will be useful, but without any warranty; without even the implied
warranty of merchantability or fitness for a particular purpose.
                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTML::TreeBuilder5.16.3pm                    0100644 0001750 0001750 00000072423 12566242174 024703  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::TreeBuilder 3"
.TH HTML::TreeBuilder 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::TreeBuilder \- Parser that builds a HTML syntax tree
.SH "VERSION"
.IX Header "VERSION"
This document describes version 5.03 of
HTML::TreeBuilder, released September 22, 2012
as part of HTML-Tree.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use HTML::TreeBuilder 5 \-weak; # Ensure weak references in use
\&
\&  foreach my $file_name (@ARGV) {
\&    my $tree = HTML::TreeBuilder\->new; # empty tree
\&    $tree\->parse_file($file_name);
\&    print "Hey, here\*(Aqs a dump of the parse tree of $file_name:\en";
\&    $tree\->dump; # a method we inherit from HTML::Element
\&    print "And here it is, bizarrely rerendered as HTML:\en",
\&      $tree\->as_HTML, "\en";
\&
\&    # Now that we\*(Aqre done with it, we must destroy it.
\&    # $tree = $tree\->delete; # Not required with weak references
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
(This class is part of the HTML::Tree dist.)
.PP
This class is for \s-1HTML\s0 syntax trees that get built out of \s-1HTML\s0
source.  The way to use it is to:
.PP
1. start a new (empty) HTML::TreeBuilder object,
.PP
2. then use one of the methods from HTML::Parser (presumably with
\&\f(CW\*(C`$tree\->parse_file($filename)\*(C'\fR for files, or with
\&\f(CW\*(C`$tree\->parse($document_content)\*(C'\fR and \f(CW\*(C`$tree\->eof\*(C'\fR if you've got
the content in a string) to parse the \s-1HTML\s0
document into the tree \f(CW$tree\fR.
.PP
(You can combine steps 1 and 2 with the \*(L"new_from_file\*(R" or
\&\*(L"new_from_content\*(R" methods.)
.PP
2b. call \f(CW\*(C`$root\->elementify()\*(C'\fR if you want.
.PP
3. do whatever you need to do with the syntax tree, presumably
involving traversing it looking for some bit of information in it,
.PP
4. previous versions of HTML::TreeBuilder required you to call
\&\f(CW\*(C`$tree\->delete()\*(C'\fR to erase the contents of the tree from memory
when you're done with the tree.  This is not normally required anymore.
See \*(L"Weak References\*(R" in HTML::Element for details.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Most of the following attributes native to HTML::TreeBuilder control how
parsing takes place; they should be set \fIbefore\fR you try parsing into
the given object.  You can set the attributes by passing a \s-1TRUE\s0 or
\&\s-1FALSE\s0 value as argument.  E.g., \f(CW\*(C`$root\->implicit_tags\*(C'\fR returns
the current setting for the \f(CW\*(C`implicit_tags\*(C'\fR option,
\&\f(CW\*(C`$root\->implicit_tags(1)\*(C'\fR turns that option on,
and \f(CW\*(C`$root\->implicit_tags(0)\*(C'\fR turns it off.
.SS "implicit_tags"
.IX Subsection "implicit_tags"
Setting this attribute to true will instruct the parser to try to
deduce implicit elements and implicit end tags.  If it is false you
get a parse tree that just reflects the text as it stands, which is
unlikely to be useful for anything but quick and dirty parsing.
(In fact, I'd be curious to hear from anyone who finds it useful to
have \f(CW\*(C`implicit_tags\*(C'\fR set to false.)
Default is true.
.PP
Implicit elements have the \*(L"implicit\*(R" in HTML::Element attribute set.
.SS "implicit_body_p_tag"
.IX Subsection "implicit_body_p_tag"
This controls an aspect of implicit element behavior, if \f(CW\*(C`implicit_tags\*(C'\fR
is on:  If a text element (\s-1PCDATA\s0) or a phrasal element (such as
\&\f(CW\*(C`<em>\*(C'\fR) is to be inserted under \f(CW\*(C`<body>\*(C'\fR, two things
can happen: if \f(CW\*(C`implicit_body_p_tag\*(C'\fR is true, it's placed under a new,
implicit \f(CW\*(C`<p>\*(C'\fR tag.  (Past DTDs suggested this was the only
correct behavior, and this is how past versions of this module
behaved.)  But if \f(CW\*(C`implicit_body_p_tag\*(C'\fR is false, nothing is implicated
\&\*(-- the \s-1PCDATA\s0 or phrasal element is simply placed under
\&\f(CW\*(C`<body>\*(C'\fR.  Default is false.
.SS "no_expand_entities"
.IX Subsection "no_expand_entities"
This attribute controls whether entities are decoded during the initial
parse of the source. Enable this if you don't want entities decoded to
their character value. e.g. '&amp;' is decoded to '&' by default, but
will be unchanged if this is enabled.
Default is false (entities will be decoded.)
.SS "ignore_unknown"
.IX Subsection "ignore_unknown"
This attribute controls whether unknown tags should be represented as
elements in the parse tree, or whether they should be ignored.
Default is true (to ignore unknown tags.)
.SS "ignore_text"
.IX Subsection "ignore_text"
Do not represent the text content of elements.  This saves space if
all you want is to examine the structure of the document.  Default is
false.
.SS "ignore_ignorable_whitespace"
.IX Subsection "ignore_ignorable_whitespace"
If set to true, TreeBuilder will try to avoid
creating ignorable whitespace text nodes in the tree.  Default is
true.  (In fact, I'd be interested in hearing if there's ever a case
where you need this off, or where leaving it on leads to incorrect
behavior.)
.SS "no_space_compacting"
.IX Subsection "no_space_compacting"
This determines whether TreeBuilder compacts all whitespace strings
in the document (well, outside of \s-1PRE\s0 or \s-1TEXTAREA\s0 elements), or
leaves them alone.  Normally (default, value of 0), each string of
contiguous whitespace in the document is turned into a single space.
But that's not done if \f(CW\*(C`no_space_compacting\*(C'\fR is set to 1.
.PP
Setting \f(CW\*(C`no_space_compacting\*(C'\fR to 1 might be useful if you want
to read in a tree just to make some minor changes to it before
writing it back out.
.PP
This method is experimental.  If you use it, be sure to report
any problems you might have with it.
.SS "p_strict"
.IX Subsection "p_strict"
If set to true (and it defaults to false), TreeBuilder will take a
narrower than normal view of what can be under a \f(CW\*(C`<p>\*(C'\fR element; if it sees
a non-phrasal element about to be inserted under a \f(CW\*(C`<p>\*(C'\fR, it will
close that \f(CW\*(C`<p>\*(C'\fR.  Otherwise it will close \f(CW\*(C`<p>\*(C'\fR elements only for
other \f(CW\*(C`<p>\*(C'\fR's, headings, and \f(CW\*(C`<form>\*(C'\fR (although the latter may be
removed in future versions).
.PP
For example, when going thru this snippet of code,
.PP
.Vb 2
\&  <p>stuff
\&  <ul>
.Ve
.PP
TreeBuilder will normally (with \f(CW\*(C`p_strict\*(C'\fR false) put the \f(CW\*(C`<ul>\*(C'\fR element
under the \f(CW\*(C`<p>\*(C'\fR element.  However, with \f(CW\*(C`p_strict\*(C'\fR set to true, it will
close the \f(CW\*(C`<p>\*(C'\fR first.
.PP
In theory, there should be strictness options like this for other/all
elements besides just \f(CW\*(C`<p>\*(C'\fR; but I treat this as a special case simply
because of the fact that \f(CW\*(C`<p>\*(C'\fR occurs so frequently and its end-tag is
omitted so often; and also because application of strictness rules
at parse-time across all elements often makes tiny errors in \s-1HTML\s0
coding produce drastically bad parse-trees, in my experience.
.PP
If you find that you wish you had an option like this to enforce
content-models on all elements, then I suggest that what you want is
content-model checking as a stage after TreeBuilder has finished
parsing.
.SS "store_comments"
.IX Subsection "store_comments"
This determines whether TreeBuilder will normally store comments found
while parsing content into \f(CW$root\fR.  Currently, this is off by default.
.SS "store_declarations"
.IX Subsection "store_declarations"
This determines whether TreeBuilder will normally store markup
declarations found while parsing content into \f(CW$root\fR.  This is on
by default.
.SS "store_pis"
.IX Subsection "store_pis"
This determines whether TreeBuilder will normally store processing
instructions found while parsing content into \f(CW$root\fR \*(-- assuming a
recent version of HTML::Parser (old versions won't parse PIs
correctly).  Currently, this is off (false) by default.
.PP
It is somewhat of a known bug (to be fixed one of these days, if
anyone needs it?) that PIs in the preamble (before the \f(CW\*(C`<html>\*(C'\fR
start-tag) end up actually \fIunder\fR the \f(CW\*(C`<html>\*(C'\fR element.
.SS "warn"
.IX Subsection "warn"
This determines whether syntax errors during parsing should generate
warnings, emitted via Perl's \f(CW\*(C`warn\*(C'\fR function.
.PP
This is off (false) by default.
.SH "METHODS"
.IX Header "METHODS"
Objects of this class inherit the methods of both HTML::Parser and
HTML::Element.  The methods inherited from HTML::Parser are used for
building the \s-1HTML\s0 tree, and the methods inherited from HTML::Element
are what you use to scrutinize the tree.  Besides this
(HTML::TreeBuilder) documentation, you must also carefully read the
HTML::Element documentation, and also skim the HTML::Parser
documentation \*(-- probably only its parse and parse_file methods are of
interest.
.SS "new_from_file"
.IX Subsection "new_from_file"
.Vb 1
\&  $root = HTML::TreeBuilder\->new_from_file($filename_or_filehandle);
.Ve
.PP
This \*(L"shortcut\*(R" constructor merely combines constructing a new object
(with the \*(L"new\*(R" method, below), and calling \f(CW\*(C`$new\->parse_file(...)\*(C'\fR on
it.  Returns the new object.  Note that this provides no way of
setting any parse options like \f(CW\*(C`store_comments\*(C'\fR (for that, call \f(CW\*(C`new\*(C'\fR, and
then set options, before calling \f(CW\*(C`parse_file\*(C'\fR).  See the notes (below)
on parameters to \*(L"parse_file\*(R".
.PP
If HTML::TreeBuilder is unable to read the file, then \f(CW\*(C`new_from_file\*(C'\fR
dies.  The error can also be found in \f(CW$!\fR.  (This behavior is new in
HTML-Tree 5. Previous versions returned a tree with only implicit elements.)
.SS "new_from_content"
.IX Subsection "new_from_content"
.Vb 1
\&  $root = HTML::TreeBuilder\->new_from_content(...);
.Ve
.PP
This \*(L"shortcut\*(R" constructor merely combines constructing a new object
(with the \*(L"new\*(R" method, below), and calling \f(CW\*(C`for(...){$new\->parse($_)}\*(C'\fR
and \f(CW\*(C`$new\->eof\*(C'\fR on it.  Returns the new object.  Note that this provides
no way of setting any parse options like \f(CW\*(C`store_comments\*(C'\fR (for that,
call \f(CW\*(C`new\*(C'\fR, and then set options, before calling \f(CW\*(C`parse\*(C'\fR).  Example
usages: \f(CW\*(C`HTML::TreeBuilder\->new_from_content(@lines)\*(C'\fR, or
\&\f(CW\*(C`HTML::TreeBuilder\->new_from_content($content)\*(C'\fR.
.SS "new_from_url"
.IX Subsection "new_from_url"
.Vb 1
\&  $root = HTML::TreeBuilder\->new_from_url($url)
.Ve
.PP
This \*(L"shortcut\*(R" constructor combines constructing a new object (with
the \*(L"new\*(R" method, below), loading LWP::UserAgent, fetching the
specified \s-1URL\s0, and calling \f(CW\*(C`$new\->parse( $response\->decoded_content)\*(C'\fR
and \f(CW\*(C`$new\->eof\*(C'\fR on it.
Returns the new object.  Note that this provides no way of setting any
parse options like \f(CW\*(C`store_comments\*(C'\fR.
.PP
If \s-1LWP\s0 is unable to fetch the \s-1URL\s0, or the response is not \s-1HTML\s0 (as
determined by \*(L"content_is_html\*(R" in HTTP::Headers), then \f(CW\*(C`new_from_url\*(C'\fR
dies, and the HTTP::Response object is found in
\&\f(CW$HTML::TreeBuilder::lwp_response\fR.
.PP
You must have installed LWP::UserAgent for this method to work.  \s-1LWP\s0
is not installed automatically, because it's a large set of modules
and you might not need it.
.SS "new"
.IX Subsection "new"
.Vb 1
\&  $root = HTML::TreeBuilder\->new();
.Ve
.PP
This creates a new HTML::TreeBuilder object.  This method takes no
attributes.
.SS "parse_file"
.IX Subsection "parse_file"
.Vb 1
\& $root\->parse_file(...)
.Ve
.PP
[An important method inherited from HTML::Parser, which
see.  Current versions of HTML::Parser can take a filespec, or a
filehandle object, like *FOO, or some object from class IO::Handle,
IO::File, IO::Socket) or the like.
I think you should check that a given file exists \fIbefore\fR calling
\&\f(CW\*(C`$root\->parse_file($filespec)\*(C'\fR.]
.PP
When you pass a filename to \f(CW\*(C`parse_file\*(C'\fR, HTML::Parser opens it in
binary mode, which means it's interpreted as Latin\-1 (\s-1ISO\-8859\-1\s0).  If
the file is in another encoding, like \s-1UTF\-8\s0 or \s-1UTF\-16\s0, this will not
do the right thing.
.PP
One solution is to open the file yourself using the proper
\&\f(CW\*(C`:encoding\*(C'\fR layer, and pass the filehandle to \f(CW\*(C`parse_file\*(C'\fR.  You can
automate this process by using \*(L"html_file\*(R" in \s-1IO::HTML\s0, which will use
the \s-1HTML5\s0 encoding sniffing algorithm to automatically determine the
proper \f(CW\*(C`:encoding\*(C'\fR layer and apply it.
.PP
In the next major release of HTML-Tree, I plan to have it use \s-1IO::HTML\s0
automatically.  If you really want your file opened in binary mode,
you should open it yourself and pass the filehandle to \f(CW\*(C`parse_file\*(C'\fR.
.PP
The return value is \f(CW\*(C`undef\*(C'\fR if there's an error opening the file.  In
that case, the error will be in \f(CW$!\fR.
.SS "parse"
.IX Subsection "parse"
.Vb 1
\&  $root\->parse(...)
.Ve
.PP
[A important method inherited from HTML::Parser, which
see.  See the note below for \f(CW\*(C`$root\->eof()\*(C'\fR.]
.SS "eof"
.IX Subsection "eof"
.Vb 1
\&  $root\->eof();
.Ve
.PP
This signals that you're finished parsing content into this tree; this
runs various kinds of crucial cleanup on the tree.  This is called
\&\fIfor you\fR when you call \f(CW\*(C`$root\->parse_file(...)\*(C'\fR, but not when
you call \f(CW\*(C`$root\->parse(...)\*(C'\fR.  So if you call
\&\f(CW\*(C`$root\->parse(...)\*(C'\fR, then you \fImust\fR call \f(CW\*(C`$root\->eof()\*(C'\fR
once you've finished feeding all the chunks to \f(CW\*(C`parse(...)\*(C'\fR, and
before you actually start doing anything else with the tree in \f(CW$root\fR.
.SS "parse_content"
.IX Subsection "parse_content"
.Vb 1
\&  $root\->parse_content(...);
.Ve
.PP
Basically a handy alias for \f(CW\*(C`$root\->parse(...); $root\->eof\*(C'\fR.
Takes the exact same arguments as \f(CW\*(C`$root\->parse()\*(C'\fR.
.SS "delete"
.IX Subsection "delete"
.Vb 1
\&  $root\->delete();
.Ve
.PP
[A previously important method inherited from HTML::Element,
which see.]
.SS "elementify"
.IX Subsection "elementify"
.Vb 1
\&  $root\->elementify();
.Ve
.PP
This changes the class of the object in \f(CW$root\fR from
HTML::TreeBuilder to the class used for all the rest of the elements
in that tree (generally HTML::Element).  Returns \f(CW$root\fR.
.PP
For most purposes, this is unnecessary, but if you call this after
(after!!)
you've finished building a tree, then it keeps you from accidentally
trying to call anything but HTML::Element methods on it.  (I.e., if
you accidentally call \f(CW\*(C`$root\->parse_file(...)\*(C'\fR on the
already-complete and elementified tree, then instead of charging ahead
and \fIwreaking havoc\fR, it'll throw a fatal error \*(-- since \f(CW$root\fR is
now an object just of class HTML::Element which has no \f(CW\*(C`parse_file\*(C'\fR
method.
.PP
Note that \f(CW\*(C`elementify\*(C'\fR currently deletes all the private attributes of
\&\f(CW$root\fR except for \*(L"_tag\*(R", \*(L"_parent\*(R", \*(L"_content\*(R", \*(L"_pos\*(R", and
\&\*(L"_implicit\*(R".  If anyone requests that I change this to leave in yet
more private attributes, I might do so, in future versions.
.SS "guts"
.IX Subsection "guts"
.Vb 2
\& @nodes = $root\->guts();
\& $parent_for_nodes = $root\->guts();
.Ve
.PP
In list context (as in the first case), this method returns the topmost
non-implicit nodes in a tree.  This is useful when you're parsing \s-1HTML\s0
code that you know doesn't expect an \s-1HTML\s0 document, but instead just
a fragment of an \s-1HTML\s0 document.  For example, if you wanted the parse
tree for a file consisting of just this:
.PP
.Vb 1
\&  <li>I like pie!
.Ve
.PP
Then you would get that with \f(CW\*(C`@nodes = $root\->guts();\*(C'\fR.
It so happens that in this case, \f(CW@nodes\fR will contain just one
element object, representing the \f(CW\*(C`<li>\*(C'\fR node (with \*(L"I like pie!\*(R" being
its text child node).  However, consider if you were parsing this:
.PP
.Vb 1
\&  <hr>Hooboy!<hr>
.Ve
.PP
In that case, \f(CW\*(C`$root\->guts()\*(C'\fR would return three items:
an element object for the first \f(CW\*(C`<hr>\*(C'\fR, a text string \*(L"Hooboy!\*(R", and
another \f(CW\*(C`<hr>\*(C'\fR element object.
.PP
For cases where you want definitely one element (so you can treat it as
a \*(L"document fragment\*(R", roughly speaking), call \f(CW\*(C`guts()\*(C'\fR in scalar
context, as in \f(CW\*(C`$parent_for_nodes = $root\->guts()\*(C'\fR. That works like
\&\f(CW\*(C`guts()\*(C'\fR in list context; in fact, \f(CW\*(C`guts()\*(C'\fR in list context would
have returned exactly one value, and if it would have been an object (as
opposed to a text string), then that's what \f(CW\*(C`guts\*(C'\fR in scalar context
will return.  Otherwise, if \f(CW\*(C`guts()\*(C'\fR in list context would have returned
no values at all, then \f(CW\*(C`guts()\*(C'\fR in scalar context returns undef.  In
all other cases, \f(CW\*(C`guts()\*(C'\fR in scalar context returns an implicit \f(CW\*(C`<div>\*(C'\fR
element node, with children consisting of whatever nodes \f(CW\*(C`guts()\*(C'\fR
in list context would have returned.  Note that that may detach those
nodes from \f(CW$root\fR's tree.
.SS "disembowel"
.IX Subsection "disembowel"
.Vb 2
\&  @nodes = $root\->disembowel();
\&  $parent_for_nodes = $root\->disembowel();
.Ve
.PP
The \f(CW\*(C`disembowel()\*(C'\fR method works just like the \f(CW\*(C`guts()\*(C'\fR method, except
that disembowel definitively destroys the tree above the nodes that
are returned.  Usually when you want the guts from a tree, you're just
going to toss out the rest of the tree anyway, so this saves you the
bother.  (Remember, \*(L"disembowel\*(R" means \*(L"remove the guts from\*(R".)
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
You should not need to call any of the following methods directly.
.SS "element_class"
.IX Subsection "element_class"
.Vb 1
\&  $classname = $h\->element_class;
.Ve
.PP
This method returns the class which will be used for new elements.  It
defaults to HTML::Element, but can be overridden by subclassing or esoteric
means best left to those will will read the source and then not complain when
those esoteric means change.  (Just subclass.)
.SS "comment"
.IX Subsection "comment"
Accept a \*(L"here's a comment\*(R" signal from HTML::Parser.
.SS "declaration"
.IX Subsection "declaration"
Accept a \*(L"here's a markup declaration\*(R" signal from HTML::Parser.
.SS "done"
.IX Subsection "done"
\&\s-1TODO:\s0 document
.SS "end"
.IX Subsection "end"
Either: Acccept an end-tag signal from HTML::Parser
Or: Method for closing currently open elements in some fairly complex
way, as used by other methods in this class.
.PP
\&\s-1TODO:\s0 Why is this hidden?
.SS "process"
.IX Subsection "process"
Accept a \*(L"here's a \s-1PI\s0\*(R" signal from HTML::Parser.
.SS "start"
.IX Subsection "start"
Accept a signal from HTML::Parser for start-tags.
.PP
\&\s-1TODO:\s0 Why is this hidden?
.SS "stunt"
.IX Subsection "stunt"
\&\s-1TODO:\s0 document
.SS "stunted"
.IX Subsection "stunted"
\&\s-1TODO:\s0 document
.SS "text"
.IX Subsection "text"
Accept a \*(L"here's a text token\*(R" signal from HTML::Parser.
.PP
\&\s-1TODO:\s0 Why is this hidden?
.SS "tighten_up"
.IX Subsection "tighten_up"
Legacy
.PP
Redirects to \*(L"delete_ignorable_whitespace\*(R" in HTML::Element.
.SS "warning"
.IX Subsection "warning"
Wrapper for CORE::warn
.PP
\&\s-1TODO:\s0 why not just use carp?
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.SS "\s-1DEBUG\s0"
.IX Subsection "DEBUG"
Are we in Debug mode?  This is a constant subroutine, to allow
compile-time optimizations.  To control debug mode, set
\&\f(CW$HTML::TreeBuilder::DEBUG\fR \fIbefore\fR loading HTML::TreeBuilder.
.SH "HTML AND ITS DISCONTENTS"
.IX Header "HTML AND ITS DISCONTENTS"
\&\s-1HTML\s0 is rather harder to parse than people who write it generally
suspect.
.PP
Here's the problem: \s-1HTML\s0 is a kind of \s-1SGML\s0 that permits \*(L"minimization\*(R"
and \*(L"implication\*(R".  In short, this means that you don't have to close
every tag you open (because the opening of a subsequent tag may
implicitly close it), and if you use a tag that can't occur in the
context you seem to using it in, under certain conditions the parser
will be able to realize you mean to leave the current context and
enter the new one, that being the only one that your code could
correctly be interpreted in.
.PP
Now, this would all work flawlessly and unproblematically if: 1) all
the rules that both prescribe and describe \s-1HTML\s0 were (and had been)
clearly set out, and 2) everyone was aware of these rules and wrote
their code in compliance to them.
.PP
However, it didn't happen that way, and so most \s-1HTML\s0 pages are
difficult if not impossible to correctly parse with nearly any set of
straightforward \s-1SGML\s0 rules.  That's why the internals of
HTML::TreeBuilder consist of lots and lots of special cases \*(-- instead
of being just a generic \s-1SGML\s0 parser with \s-1HTML\s0 \s-1DTD\s0 rules plugged in.
.SH "TRANSLATIONS?"
.IX Header "TRANSLATIONS?"
The techniques that HTML::TreeBuilder uses to perform what I consider
very robust parses on everyday code are not things that can work only
in Perl.  To date, the algorithms at the center of HTML::TreeBuilder
have been implemented only in Perl, as far as I know; and I don't
foresee getting around to implementing them in any other language any
time soon.
.PP
If, however, anyone is looking for a semester project for an applied
programming class (or if they merely enjoy \fIextra-curricular\fR
masochism), they might do well to see about choosing as a topic the
implementation/adaptation of these routines to any other interesting
programming language that you feel currently suffers from a lack of
robust HTML-parsing.  I welcome correspondence on this subject, and
point out that one can learn a great deal about languages by trying to
translate between them, and then comparing the result.
.PP
The HTML::TreeBuilder source may seem long and complex, but it is
rather well commented, and symbol names are generally
self-explanatory.  (You are encouraged to read the Mozilla \s-1HTML\s0 parser
source for comparison.)  Some of the complexity comes from little-used
features, and some of it comes from having the \s-1HTML\s0 tokenizer
(HTML::Parser) being a separate module, requiring somewhat of a
different interface than you'd find in a combined tokenizer and
tree-builder.  But most of the length of the source comes from the fact
that it's essentially a long list of special cases, with lots and lots
of sanity-checking, and sanity-recovery \*(-- because, as Roseanne
Rosannadanna once said, "it's always \fIsomething\fR".
.PP
Users looking to compare several \s-1HTML\s0 parsers should look at the
source for Raggett's Tidy
(\f(CW\*(C`<http://www.w3.org/People/Raggett/tidy/>\*(C'\fR),
Mozilla
(\f(CW\*(C`<http://www.mozilla.org/>\*(C'\fR),
and possibly root around the browsers section of Yahoo
to find the various open-source ones
(\f(CW\*(C`<http://dir.yahoo.com/Computers_and_Internet/Software/Internet/World_Wide_Web/Browsers/>\*(C'\fR).
.SH "BUGS"
.IX Header "BUGS"
* Framesets seem to work correctly now.  Email me if you get a strange
parse from a document with framesets.
.PP
* Really bad \s-1HTML\s0 code will, often as not, make for a somewhat
objectionable parse tree.  Regrettable, but unavoidably true.
.PP
* If you're running with \f(CW\*(C`implicit_tags\*(C'\fR off (God help you!), consider
that \f(CW\*(C`$tree\->content_list\*(C'\fR probably contains the tree or grove from the
parse, and not \f(CW$tree\fR itself (which will, oddly enough, be an implicit
\&\f(CW\*(C`<html>\*(C'\fR element).  This seems counter-intuitive and problematic; but
seeing as how almost no \s-1HTML\s0 ever parses correctly with \f(CW\*(C`implicit_tags\*(C'\fR
off, this interface oddity seems the least of your problems.
.SH "BUG REPORTS"
.IX Header "BUG REPORTS"
When a document parses in a way different from how you think it
should, I ask that you report this to me as a bug.  The first thing
you should do is copy the document, trim out as much of it as you can
while still producing the bug in question, and \fIthen\fR email me that
mini-document \fIand\fR the code you're using to parse it, to the HTML::Tree
bug queue at \f(CW\*(C`<bug\-html\-tree\ at\ rt.cpan.org>\*(C'\fR.
.PP
Include a note as to how it
parses (presumably including its \f(CW\*(C`$tree\->dump\*(C'\fR output), and then a
\&\fIcareful and clear\fR explanation of where you think the parser is
going astray, and how you would prefer that it work instead.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
For more information about the HTML-Tree distribution: HTML::Tree.
.PP
Modules used by HTML::TreeBuilder:
HTML::Parser, HTML::Element, HTML::Tagset.
.PP
For converting between XML::DOM::Node, HTML::Element, and
XML::Element trees: HTML::DOMbo.
.PP
For opening a \s-1HTML\s0 file with automatic charset detection: \s-1IO::HTML\s0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Current maintainers:
.IP "\(bu" 4
Christopher J. Madsen \f(CW\*(C`<perl\ AT\ cjmweb.net>\*(C'\fR
.IP "\(bu" 4
Jeff Fearn \f(CW\*(C`<jfearn\ AT\ cpan.org>\*(C'\fR
.PP
Original HTML-Tree author:
.IP "\(bu" 4
Gisle Aas
.PP
Former maintainers:
.IP "\(bu" 4
Sean M. Burke
.IP "\(bu" 4
Andy Lester
.IP "\(bu" 4
Pete Krawczyk \f(CW\*(C`<petek\ AT\ cpan.org>\*(C'\fR
.PP
You can follow or contribute to HTML-Tree's development at
http://github.com/madsen/HTML\-Tree <http://github.com/madsen/HTML-Tree>.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1995\-1998 Gisle Aas, 1999\-2004 Sean M. Burke,
2005 Andy Lester, 2006 Pete Krawczyk, 2010 Jeff Fearn,
2012 Christopher J. Madsen.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
The programs in this library are distributed in the hope that they
will be useful, but without any warranty; without even the implied
warranty of merchantability or fitness for a particular purpose.
                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTML::TreeBuilder5.18.3pm                    0100644 0001750 0001750 00000072672 12566242171 024710  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTML::TreeBuilder 3"
.TH HTML::TreeBuilder 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTML::TreeBuilder \- Parser that builds a HTML syntax tree
.SH "VERSION"
.IX Header "VERSION"
This document describes version 5.03 of
HTML::TreeBuilder, released September 22, 2012
as part of HTML-Tree.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use HTML::TreeBuilder 5 \-weak; # Ensure weak references in use
\&
\&  foreach my $file_name (@ARGV) {
\&    my $tree = HTML::TreeBuilder\->new; # empty tree
\&    $tree\->parse_file($file_name);
\&    print "Hey, here\*(Aqs a dump of the parse tree of $file_name:\en";
\&    $tree\->dump; # a method we inherit from HTML::Element
\&    print "And here it is, bizarrely rerendered as HTML:\en",
\&      $tree\->as_HTML, "\en";
\&
\&    # Now that we\*(Aqre done with it, we must destroy it.
\&    # $tree = $tree\->delete; # Not required with weak references
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
(This class is part of the HTML::Tree dist.)
.PP
This class is for \s-1HTML\s0 syntax trees that get built out of \s-1HTML\s0
source.  The way to use it is to:
.PP
1. start a new (empty) HTML::TreeBuilder object,
.PP
2. then use one of the methods from HTML::Parser (presumably with
\&\f(CW\*(C`$tree\->parse_file($filename)\*(C'\fR for files, or with
\&\f(CW\*(C`$tree\->parse($document_content)\*(C'\fR and \f(CW\*(C`$tree\->eof\*(C'\fR if you've got
the content in a string) to parse the \s-1HTML\s0
document into the tree \f(CW$tree\fR.
.PP
(You can combine steps 1 and 2 with the \*(L"new_from_file\*(R" or
\&\*(L"new_from_content\*(R" methods.)
.PP
2b. call \f(CW\*(C`$root\->elementify()\*(C'\fR if you want.
.PP
3. do whatever you need to do with the syntax tree, presumably
involving traversing it looking for some bit of information in it,
.PP
4. previous versions of HTML::TreeBuilder required you to call
\&\f(CW\*(C`$tree\->delete()\*(C'\fR to erase the contents of the tree from memory
when you're done with the tree.  This is not normally required anymore.
See \*(L"Weak References\*(R" in HTML::Element for details.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
Most of the following attributes native to HTML::TreeBuilder control how
parsing takes place; they should be set \fIbefore\fR you try parsing into
the given object.  You can set the attributes by passing a \s-1TRUE\s0 or
\&\s-1FALSE\s0 value as argument.  E.g., \f(CW\*(C`$root\->implicit_tags\*(C'\fR returns
the current setting for the \f(CW\*(C`implicit_tags\*(C'\fR option,
\&\f(CW\*(C`$root\->implicit_tags(1)\*(C'\fR turns that option on,
and \f(CW\*(C`$root\->implicit_tags(0)\*(C'\fR turns it off.
.SS "implicit_tags"
.IX Subsection "implicit_tags"
Setting this attribute to true will instruct the parser to try to
deduce implicit elements and implicit end tags.  If it is false you
get a parse tree that just reflects the text as it stands, which is
unlikely to be useful for anything but quick and dirty parsing.
(In fact, I'd be curious to hear from anyone who finds it useful to
have \f(CW\*(C`implicit_tags\*(C'\fR set to false.)
Default is true.
.PP
Implicit elements have the \*(L"implicit\*(R" in HTML::Element attribute set.
.SS "implicit_body_p_tag"
.IX Subsection "implicit_body_p_tag"
This controls an aspect of implicit element behavior, if \f(CW\*(C`implicit_tags\*(C'\fR
is on:  If a text element (\s-1PCDATA\s0) or a phrasal element (such as
\&\f(CW\*(C`<em>\*(C'\fR) is to be inserted under \f(CW\*(C`<body>\*(C'\fR, two things
can happen: if \f(CW\*(C`implicit_body_p_tag\*(C'\fR is true, it's placed under a new,
implicit \f(CW\*(C`<p>\*(C'\fR tag.  (Past DTDs suggested this was the only
correct behavior, and this is how past versions of this module
behaved.)  But if \f(CW\*(C`implicit_body_p_tag\*(C'\fR is false, nothing is implicated
\&\*(-- the \s-1PCDATA\s0 or phrasal element is simply placed under
\&\f(CW\*(C`<body>\*(C'\fR.  Default is false.
.SS "no_expand_entities"
.IX Subsection "no_expand_entities"
This attribute controls whether entities are decoded during the initial
parse of the source. Enable this if you don't want entities decoded to
their character value. e.g. '&amp;' is decoded to '&' by default, but
will be unchanged if this is enabled.
Default is false (entities will be decoded.)
.SS "ignore_unknown"
.IX Subsection "ignore_unknown"
This attribute controls whether unknown tags should be represented as
elements in the parse tree, or whether they should be ignored.
Default is true (to ignore unknown tags.)
.SS "ignore_text"
.IX Subsection "ignore_text"
Do not represent the text content of elements.  This saves space if
all you want is to examine the structure of the document.  Default is
false.
.SS "ignore_ignorable_whitespace"
.IX Subsection "ignore_ignorable_whitespace"
If set to true, TreeBuilder will try to avoid
creating ignorable whitespace text nodes in the tree.  Default is
true.  (In fact, I'd be interested in hearing if there's ever a case
where you need this off, or where leaving it on leads to incorrect
behavior.)
.SS "no_space_compacting"
.IX Subsection "no_space_compacting"
This determines whether TreeBuilder compacts all whitespace strings
in the document (well, outside of \s-1PRE\s0 or \s-1TEXTAREA\s0 elements), or
leaves them alone.  Normally (default, value of 0), each string of
contiguous whitespace in the document is turned into a single space.
But that's not done if \f(CW\*(C`no_space_compacting\*(C'\fR is set to 1.
.PP
Setting \f(CW\*(C`no_space_compacting\*(C'\fR to 1 might be useful if you want
to read in a tree just to make some minor changes to it before
writing it back out.
.PP
This method is experimental.  If you use it, be sure to report
any problems you might have with it.
.SS "p_strict"
.IX Subsection "p_strict"
If set to true (and it defaults to false), TreeBuilder will take a
narrower than normal view of what can be under a \f(CW\*(C`<p>\*(C'\fR element; if it sees
a non-phrasal element about to be inserted under a \f(CW\*(C`<p>\*(C'\fR, it will
close that \f(CW\*(C`<p>\*(C'\fR.  Otherwise it will close \f(CW\*(C`<p>\*(C'\fR elements only for
other \f(CW\*(C`<p>\*(C'\fR's, headings, and \f(CW\*(C`<form>\*(C'\fR (although the latter may be
removed in future versions).
.PP
For example, when going thru this snippet of code,
.PP
.Vb 2
\&  <p>stuff
\&  <ul>
.Ve
.PP
TreeBuilder will normally (with \f(CW\*(C`p_strict\*(C'\fR false) put the \f(CW\*(C`<ul>\*(C'\fR element
under the \f(CW\*(C`<p>\*(C'\fR element.  However, with \f(CW\*(C`p_strict\*(C'\fR set to true, it will
close the \f(CW\*(C`<p>\*(C'\fR first.
.PP
In theory, there should be strictness options like this for other/all
elements besides just \f(CW\*(C`<p>\*(C'\fR; but I treat this as a special case simply
because of the fact that \f(CW\*(C`<p>\*(C'\fR occurs so frequently and its end-tag is
omitted so often; and also because application of strictness rules
at parse-time across all elements often makes tiny errors in \s-1HTML\s0
coding produce drastically bad parse-trees, in my experience.
.PP
If you find that you wish you had an option like this to enforce
content-models on all elements, then I suggest that what you want is
content-model checking as a stage after TreeBuilder has finished
parsing.
.SS "store_comments"
.IX Subsection "store_comments"
This determines whether TreeBuilder will normally store comments found
while parsing content into \f(CW$root\fR.  Currently, this is off by default.
.SS "store_declarations"
.IX Subsection "store_declarations"
This determines whether TreeBuilder will normally store markup
declarations found while parsing content into \f(CW$root\fR.  This is on
by default.
.SS "store_pis"
.IX Subsection "store_pis"
This determines whether TreeBuilder will normally store processing
instructions found while parsing content into \f(CW$root\fR \*(-- assuming a
recent version of HTML::Parser (old versions won't parse PIs
correctly).  Currently, this is off (false) by default.
.PP
It is somewhat of a known bug (to be fixed one of these days, if
anyone needs it?) that PIs in the preamble (before the \f(CW\*(C`<html>\*(C'\fR
start-tag) end up actually \fIunder\fR the \f(CW\*(C`<html>\*(C'\fR element.
.SS "warn"
.IX Subsection "warn"
This determines whether syntax errors during parsing should generate
warnings, emitted via Perl's \f(CW\*(C`warn\*(C'\fR function.
.PP
This is off (false) by default.
.SH "METHODS"
.IX Header "METHODS"
Objects of this class inherit the methods of both HTML::Parser and
HTML::Element.  The methods inherited from HTML::Parser are used for
building the \s-1HTML\s0 tree, and the methods inherited from HTML::Element
are what you use to scrutinize the tree.  Besides this
(HTML::TreeBuilder) documentation, you must also carefully read the
HTML::Element documentation, and also skim the HTML::Parser
documentation \*(-- probably only its parse and parse_file methods are of
interest.
.SS "new_from_file"
.IX Subsection "new_from_file"
.Vb 1
\&  $root = HTML::TreeBuilder\->new_from_file($filename_or_filehandle);
.Ve
.PP
This \*(L"shortcut\*(R" constructor merely combines constructing a new object
(with the \*(L"new\*(R" method, below), and calling \f(CW\*(C`$new\->parse_file(...)\*(C'\fR on
it.  Returns the new object.  Note that this provides no way of
setting any parse options like \f(CW\*(C`store_comments\*(C'\fR (for that, call \f(CW\*(C`new\*(C'\fR, and
then set options, before calling \f(CW\*(C`parse_file\*(C'\fR).  See the notes (below)
on parameters to \*(L"parse_file\*(R".
.PP
If HTML::TreeBuilder is unable to read the file, then \f(CW\*(C`new_from_file\*(C'\fR
dies.  The error can also be found in \f(CW$!\fR.  (This behavior is new in
HTML-Tree 5. Previous versions returned a tree with only implicit elements.)
.SS "new_from_content"
.IX Subsection "new_from_content"
.Vb 1
\&  $root = HTML::TreeBuilder\->new_from_content(...);
.Ve
.PP
This \*(L"shortcut\*(R" constructor merely combines constructing a new object
(with the \*(L"new\*(R" method, below), and calling \f(CW\*(C`for(...){$new\->parse($_)}\*(C'\fR
and \f(CW\*(C`$new\->eof\*(C'\fR on it.  Returns the new object.  Note that this provides
no way of setting any parse options like \f(CW\*(C`store_comments\*(C'\fR (for that,
call \f(CW\*(C`new\*(C'\fR, and then set options, before calling \f(CW\*(C`parse\*(C'\fR).  Example
usages: \f(CW\*(C`HTML::TreeBuilder\->new_from_content(@lines)\*(C'\fR, or
\&\f(CW\*(C`HTML::TreeBuilder\->new_from_content($content)\*(C'\fR.
.SS "new_from_url"
.IX Subsection "new_from_url"
.Vb 1
\&  $root = HTML::TreeBuilder\->new_from_url($url)
.Ve
.PP
This \*(L"shortcut\*(R" constructor combines constructing a new object (with
the \*(L"new\*(R" method, below), loading LWP::UserAgent, fetching the
specified \s-1URL,\s0 and calling \f(CW\*(C`$new\->parse( $response\->decoded_content)\*(C'\fR
and \f(CW\*(C`$new\->eof\*(C'\fR on it.
Returns the new object.  Note that this provides no way of setting any
parse options like \f(CW\*(C`store_comments\*(C'\fR.
.PP
If \s-1LWP\s0 is unable to fetch the \s-1URL,\s0 or the response is not \s-1HTML \s0(as
determined by \*(L"content_is_html\*(R" in HTTP::Headers), then \f(CW\*(C`new_from_url\*(C'\fR
dies, and the HTTP::Response object is found in
\&\f(CW$HTML::TreeBuilder::lwp_response\fR.
.PP
You must have installed LWP::UserAgent for this method to work.  \s-1LWP\s0
is not installed automatically, because it's a large set of modules
and you might not need it.
.SS "new"
.IX Subsection "new"
.Vb 1
\&  $root = HTML::TreeBuilder\->new();
.Ve
.PP
This creates a new HTML::TreeBuilder object.  This method takes no
attributes.
.SS "parse_file"
.IX Subsection "parse_file"
.Vb 1
\& $root\->parse_file(...)
.Ve
.PP
[An important method inherited from HTML::Parser, which
see.  Current versions of HTML::Parser can take a filespec, or a
filehandle object, like *FOO, or some object from class IO::Handle,
IO::File, IO::Socket) or the like.
I think you should check that a given file exists \fIbefore\fR calling
\&\f(CW\*(C`$root\->parse_file($filespec)\*(C'\fR.]
.PP
When you pass a filename to \f(CW\*(C`parse_file\*(C'\fR, HTML::Parser opens it in
binary mode, which means it's interpreted as Latin\-1 (\s-1ISO\-8859\-1\s0).  If
the file is in another encoding, like \s-1UTF\-8\s0 or \s-1UTF\-16,\s0 this will not
do the right thing.
.PP
One solution is to open the file yourself using the proper
\&\f(CW\*(C`:encoding\*(C'\fR layer, and pass the filehandle to \f(CW\*(C`parse_file\*(C'\fR.  You can
automate this process by using \*(L"html_file\*(R" in \s-1IO::HTML\s0, which will use
the \s-1HTML5\s0 encoding sniffing algorithm to automatically determine the
proper \f(CW\*(C`:encoding\*(C'\fR layer and apply it.
.PP
In the next major release of HTML-Tree, I plan to have it use \s-1IO::HTML\s0
automatically.  If you really want your file opened in binary mode,
you should open it yourself and pass the filehandle to \f(CW\*(C`parse_file\*(C'\fR.
.PP
The return value is \f(CW\*(C`undef\*(C'\fR if there's an error opening the file.  In
that case, the error will be in \f(CW$!\fR.
.SS "parse"
.IX Subsection "parse"
.Vb 1
\&  $root\->parse(...)
.Ve
.PP
[A important method inherited from HTML::Parser, which
see.  See the note below for \f(CW\*(C`$root\->eof()\*(C'\fR.]
.SS "eof"
.IX Subsection "eof"
.Vb 1
\&  $root\->eof();
.Ve
.PP
This signals that you're finished parsing content into this tree; this
runs various kinds of crucial cleanup on the tree.  This is called
\&\fIfor you\fR when you call \f(CW\*(C`$root\->parse_file(...)\*(C'\fR, but not when
you call \f(CW\*(C`$root\->parse(...)\*(C'\fR.  So if you call
\&\f(CW\*(C`$root\->parse(...)\*(C'\fR, then you \fImust\fR call \f(CW\*(C`$root\->eof()\*(C'\fR
once you've finished feeding all the chunks to \f(CW\*(C`parse(...)\*(C'\fR, and
before you actually start doing anything else with the tree in \f(CW$root\fR.
.SS "parse_content"
.IX Subsection "parse_content"
.Vb 1
\&  $root\->parse_content(...);
.Ve
.PP
Basically a handy alias for \f(CW\*(C`$root\->parse(...); $root\->eof\*(C'\fR.
Takes the exact same arguments as \f(CW\*(C`$root\->parse()\*(C'\fR.
.SS "delete"
.IX Subsection "delete"
.Vb 1
\&  $root\->delete();
.Ve
.PP
[A previously important method inherited from HTML::Element,
which see.]
.SS "elementify"
.IX Subsection "elementify"
.Vb 1
\&  $root\->elementify();
.Ve
.PP
This changes the class of the object in \f(CW$root\fR from
HTML::TreeBuilder to the class used for all the rest of the elements
in that tree (generally HTML::Element).  Returns \f(CW$root\fR.
.PP
For most purposes, this is unnecessary, but if you call this after
(after!!)
you've finished building a tree, then it keeps you from accidentally
trying to call anything but HTML::Element methods on it.  (I.e., if
you accidentally call \f(CW\*(C`$root\->parse_file(...)\*(C'\fR on the
already-complete and elementified tree, then instead of charging ahead
and \fIwreaking havoc\fR, it'll throw a fatal error \*(-- since \f(CW$root\fR is
now an object just of class HTML::Element which has no \f(CW\*(C`parse_file\*(C'\fR
method.
.PP
Note that \f(CW\*(C`elementify\*(C'\fR currently deletes all the private attributes of
\&\f(CW$root\fR except for \*(L"_tag\*(R", \*(L"_parent\*(R", \*(L"_content\*(R", \*(L"_pos\*(R", and
\&\*(L"_implicit\*(R".  If anyone requests that I change this to leave in yet
more private attributes, I might do so, in future versions.
.SS "guts"
.IX Subsection "guts"
.Vb 2
\& @nodes = $root\->guts();
\& $parent_for_nodes = $root\->guts();
.Ve
.PP
In list context (as in the first case), this method returns the topmost
non-implicit nodes in a tree.  This is useful when you're parsing \s-1HTML\s0
code that you know doesn't expect an \s-1HTML\s0 document, but instead just
a fragment of an \s-1HTML\s0 document.  For example, if you wanted the parse
tree for a file consisting of just this:
.PP
.Vb 1
\&  <li>I like pie!
.Ve
.PP
Then you would get that with \f(CW\*(C`@nodes = $root\->guts();\*(C'\fR.
It so happens that in this case, \f(CW@nodes\fR will contain just one
element object, representing the \f(CW\*(C`<li>\*(C'\fR node (with \*(L"I like pie!\*(R" being
its text child node).  However, consider if you were parsing this:
.PP
.Vb 1
\&  <hr>Hooboy!<hr>
.Ve
.PP
In that case, \f(CW\*(C`$root\->guts()\*(C'\fR would return three items:
an element object for the first \f(CW\*(C`<hr>\*(C'\fR, a text string \*(L"Hooboy!\*(R", and
another \f(CW\*(C`<hr>\*(C'\fR element object.
.PP
For cases where you want definitely one element (so you can treat it as
a \*(L"document fragment\*(R", roughly speaking), call \f(CW\*(C`guts()\*(C'\fR in scalar
context, as in \f(CW\*(C`$parent_for_nodes = $root\->guts()\*(C'\fR. That works like
\&\f(CW\*(C`guts()\*(C'\fR in list context; in fact, \f(CW\*(C`guts()\*(C'\fR in list context would
have returned exactly one value, and if it would have been an object (as
opposed to a text string), then that's what \f(CW\*(C`guts\*(C'\fR in scalar context
will return.  Otherwise, if \f(CW\*(C`guts()\*(C'\fR in list context would have returned
no values at all, then \f(CW\*(C`guts()\*(C'\fR in scalar context returns undef.  In
all other cases, \f(CW\*(C`guts()\*(C'\fR in scalar context returns an implicit \f(CW\*(C`<div>\*(C'\fR
element node, with children consisting of whatever nodes \f(CW\*(C`guts()\*(C'\fR
in list context would have returned.  Note that that may detach those
nodes from \f(CW$root\fR's tree.
.SS "disembowel"
.IX Subsection "disembowel"
.Vb 2
\&  @nodes = $root\->disembowel();
\&  $parent_for_nodes = $root\->disembowel();
.Ve
.PP
The \f(CW\*(C`disembowel()\*(C'\fR method works just like the \f(CW\*(C`guts()\*(C'\fR method, except
that disembowel definitively destroys the tree above the nodes that
are returned.  Usually when you want the guts from a tree, you're just
going to toss out the rest of the tree anyway, so this saves you the
bother.  (Remember, \*(L"disembowel\*(R" means \*(L"remove the guts from\*(R".)
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
You should not need to call any of the following methods directly.
.SS "element_class"
.IX Subsection "element_class"
.Vb 1
\&  $classname = $h\->element_class;
.Ve
.PP
This method returns the class which will be used for new elements.  It
defaults to HTML::Element, but can be overridden by subclassing or esoteric
means best left to those will will read the source and then not complain when
those esoteric means change.  (Just subclass.)
.SS "comment"
.IX Subsection "comment"
Accept a \*(L"here's a comment\*(R" signal from HTML::Parser.
.SS "declaration"
.IX Subsection "declaration"
Accept a \*(L"here's a markup declaration\*(R" signal from HTML::Parser.
.SS "done"
.IX Subsection "done"
\&\s-1TODO:\s0 document
.SS "end"
.IX Subsection "end"
Either: Acccept an end-tag signal from HTML::Parser
Or: Method for closing currently open elements in some fairly complex
way, as used by other methods in this class.
.PP
\&\s-1TODO:\s0 Why is this hidden?
.SS "process"
.IX Subsection "process"
Accept a \*(L"here's a \s-1PI\*(R"\s0 signal from HTML::Parser.
.SS "start"
.IX Subsection "start"
Accept a signal from HTML::Parser for start-tags.
.PP
\&\s-1TODO:\s0 Why is this hidden?
.SS "stunt"
.IX Subsection "stunt"
\&\s-1TODO:\s0 document
.SS "stunted"
.IX Subsection "stunted"
\&\s-1TODO:\s0 document
.SS "text"
.IX Subsection "text"
Accept a \*(L"here's a text token\*(R" signal from HTML::Parser.
.PP
\&\s-1TODO:\s0 Why is this hidden?
.SS "tighten_up"
.IX Subsection "tighten_up"
Legacy
.PP
Redirects to \*(L"delete_ignorable_whitespace\*(R" in HTML::Element.
.SS "warning"
.IX Subsection "warning"
Wrapper for CORE::warn
.PP
\&\s-1TODO:\s0 why not just use carp?
.SH "SUBROUTINES"
.IX Header "SUBROUTINES"
.SS "\s-1DEBUG\s0"
.IX Subsection "DEBUG"
Are we in Debug mode?  This is a constant subroutine, to allow
compile-time optimizations.  To control debug mode, set
\&\f(CW$HTML::TreeBuilder::DEBUG\fR \fIbefore\fR loading HTML::TreeBuilder.
.SH "HTML AND ITS DISCONTENTS"
.IX Header "HTML AND ITS DISCONTENTS"
\&\s-1HTML\s0 is rather harder to parse than people who write it generally
suspect.
.PP
Here's the problem: \s-1HTML\s0 is a kind of \s-1SGML\s0 that permits \*(L"minimization\*(R"
and \*(L"implication\*(R".  In short, this means that you don't have to close
every tag you open (because the opening of a subsequent tag may
implicitly close it), and if you use a tag that can't occur in the
context you seem to using it in, under certain conditions the parser
will be able to realize you mean to leave the current context and
enter the new one, that being the only one that your code could
correctly be interpreted in.
.PP
Now, this would all work flawlessly and unproblematically if: 1) all
the rules that both prescribe and describe \s-1HTML\s0 were (and had been)
clearly set out, and 2) everyone was aware of these rules and wrote
their code in compliance to them.
.PP
However, it didn't happen that way, and so most \s-1HTML\s0 pages are
difficult if not impossible to correctly parse with nearly any set of
straightforward \s-1SGML\s0 rules.  That's why the internals of
HTML::TreeBuilder consist of lots and lots of special cases \*(-- instead
of being just a generic \s-1SGML\s0 parser with \s-1HTML DTD\s0 rules plugged in.
.SH "TRANSLATIONS?"
.IX Header "TRANSLATIONS?"
The techniques that HTML::TreeBuilder uses to perform what I consider
very robust parses on everyday code are not things that can work only
in Perl.  To date, the algorithms at the center of HTML::TreeBuilder
have been implemented only in Perl, as far as I know; and I don't
foresee getting around to implementing them in any other language any
time soon.
.PP
If, however, anyone is looking for a semester project for an applied
programming class (or if they merely enjoy \fIextra-curricular\fR
masochism), they might do well to see about choosing as a topic the
implementation/adaptation of these routines to any other interesting
programming language that you feel currently suffers from a lack of
robust HTML-parsing.  I welcome correspondence on this subject, and
point out that one can learn a great deal about languages by trying to
translate between them, and then comparing the result.
.PP
The HTML::TreeBuilder source may seem long and complex, but it is
rather well commented, and symbol names are generally
self-explanatory.  (You are encouraged to read the Mozilla \s-1HTML\s0 parser
source for comparison.)  Some of the complexity comes from little-used
features, and some of it comes from having the \s-1HTML\s0 tokenizer
(HTML::Parser) being a separate module, requiring somewhat of a
different interface than you'd find in a combined tokenizer and
tree-builder.  But most of the length of the source comes from the fact
that it's essentially a long list of special cases, with lots and lots
of sanity-checking, and sanity-recovery \*(-- because, as Roseanne
Rosannadanna once said, "it's always \fIsomething\fR".
.PP
Users looking to compare several \s-1HTML\s0 parsers should look at the
source for Raggett's Tidy
(\f(CW\*(C`<http://www.w3.org/People/Raggett/tidy/>\*(C'\fR),
Mozilla
(\f(CW\*(C`<http://www.mozilla.org/>\*(C'\fR),
and possibly root around the browsers section of Yahoo
to find the various open-source ones
(\f(CW\*(C`<http://dir.yahoo.com/Computers_and_Internet/Software/Internet/World_Wide_Web/Browsers/>\*(C'\fR).
.SH "BUGS"
.IX Header "BUGS"
* Framesets seem to work correctly now.  Email me if you get a strange
parse from a document with framesets.
.PP
* Really bad \s-1HTML\s0 code will, often as not, make for a somewhat
objectionable parse tree.  Regrettable, but unavoidably true.
.PP
* If you're running with \f(CW\*(C`implicit_tags\*(C'\fR off (God help you!), consider
that \f(CW\*(C`$tree\->content_list\*(C'\fR probably contains the tree or grove from the
parse, and not \f(CW$tree\fR itself (which will, oddly enough, be an implicit
\&\f(CW\*(C`<html>\*(C'\fR element).  This seems counter-intuitive and problematic; but
seeing as how almost no \s-1HTML\s0 ever parses correctly with \f(CW\*(C`implicit_tags\*(C'\fR
off, this interface oddity seems the least of your problems.
.SH "BUG REPORTS"
.IX Header "BUG REPORTS"
When a document parses in a way different from how you think it
should, I ask that you report this to me as a bug.  The first thing
you should do is copy the document, trim out as much of it as you can
while still producing the bug in question, and \fIthen\fR email me that
mini-document \fIand\fR the code you're using to parse it, to the HTML::Tree
bug queue at \f(CW\*(C`<bug\-html\-tree\ at\ rt.cpan.org>\*(C'\fR.
.PP
Include a note as to how it
parses (presumably including its \f(CW\*(C`$tree\->dump\*(C'\fR output), and then a
\&\fIcareful and clear\fR explanation of where you think the parser is
going astray, and how you would prefer that it work instead.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
For more information about the HTML-Tree distribution: HTML::Tree.
.PP
Modules used by HTML::TreeBuilder:
HTML::Parser, HTML::Element, HTML::Tagset.
.PP
For converting between XML::DOM::Node, HTML::Element, and
XML::Element trees: HTML::DOMbo.
.PP
For opening a \s-1HTML\s0 file with automatic charset detection: \s-1IO::HTML\s0.
.SH "AUTHOR"
.IX Header "AUTHOR"
Current maintainers:
.IP "\(bu" 4
Christopher J. Madsen \f(CW\*(C`<perl\ AT\ cjmweb.net>\*(C'\fR
.IP "\(bu" 4
Jeff Fearn \f(CW\*(C`<jfearn\ AT\ cpan.org>\*(C'\fR
.PP
Original HTML-Tree author:
.IP "\(bu" 4
Gisle Aas
.PP
Former maintainers:
.IP "\(bu" 4
Sean M. Burke
.IP "\(bu" 4
Andy Lester
.IP "\(bu" 4
Pete Krawczyk \f(CW\*(C`<petek\ AT\ cpan.org>\*(C'\fR
.PP
You can follow or contribute to HTML-Tree's development at
<http://github.com/madsen/HTML\-Tree>.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1995\-1998 Gisle Aas, 1999\-2004 Sean M. Burke,
2005 Andy Lester, 2006 Pete Krawczyk, 2010 Jeff Fearn,
2012 Christopher J. Madsen.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
The programs in this library are distributed in the hope that they
will be useful, but without any warranty; without even the implied
warranty of merchantability or fitness for a particular purpose.
                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Config.3pm                             0100644 0001750 0001750 00000031714 12566241314 023374  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Config 3"
.TH HTTP::Config 3 "2012-02-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Config \- Configuration for request and response objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use HTTP::Config;
\& my $c = HTTP::Config\->new;
\& $c\->add(m_domain => ".example.com", m_scheme => "http", verbose => 1);
\& 
\& use HTTP::Request;
\& my $request = HTTP::Request\->new(GET => "http://www.example.com");
\& 
\& if (my @m = $c\->matching($request)) {
\&    print "Yadayada\en" if $m[0]\->{verbose};
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An \f(CW\*(C`HTTP::Config\*(C'\fR object is a list of entries that
can be matched against request or request/response pairs.  Its
purpose is to hold configuration data that can be looked up given a
request or response object.
.PP
Each configuration entry is a hash.  Some keys specify matching to
occur against attributes of request/response objects.  Other keys can
be used to hold user data.
.PP
The following methods are provided:
.ie n .IP "$conf = HTTP::Config\->new" 4
.el .IP "\f(CW$conf\fR = HTTP::Config\->new" 4
.IX Item "$conf = HTTP::Config->new"
Constructs a new empty \f(CW\*(C`HTTP::Config\*(C'\fR object and returns it.
.ie n .IP "$conf\->entries" 4
.el .IP "\f(CW$conf\fR\->entries" 4
.IX Item "$conf->entries"
Returns the list of entries in the configuration object.
In scalar context returns the number of entries.
.ie n .IP "$conf\->empty" 4
.el .IP "\f(CW$conf\fR\->empty" 4
.IX Item "$conf->empty"
Return true if there are no entries in the configuration object.
This is just a shorthand for \f(CW\*(C`not $conf\->entries\*(C'\fR.
.ie n .IP "$conf\->add( %matchspec, %other )" 4
.el .IP "\f(CW$conf\fR\->add( \f(CW%matchspec\fR, \f(CW%other\fR )" 4
.IX Item "$conf->add( %matchspec, %other )"
.PD 0
.ie n .IP "$conf\->add( \e%entry )" 4
.el .IP "\f(CW$conf\fR\->add( \e%entry )" 4
.IX Item "$conf->add( %entry )"
.PD
Adds a new entry to the configuration.
You can either pass separate key/value pairs or a hash reference.
.ie n .IP "$conf\->remove( %spec )" 4
.el .IP "\f(CW$conf\fR\->remove( \f(CW%spec\fR )" 4
.IX Item "$conf->remove( %spec )"
Removes (and returns) the entries that have matches for all the key/value pairs in \f(CW%spec\fR.
If \f(CW%spec\fR is empty this will match all entries; so it will empty the configuation object.
.ie n .IP "$conf\->matching( $uri, $request, $response )" 4
.el .IP "\f(CW$conf\fR\->matching( \f(CW$uri\fR, \f(CW$request\fR, \f(CW$response\fR )" 4
.IX Item "$conf->matching( $uri, $request, $response )"
.PD 0
.ie n .IP "$conf\->matching( $uri )" 4
.el .IP "\f(CW$conf\fR\->matching( \f(CW$uri\fR )" 4
.IX Item "$conf->matching( $uri )"
.ie n .IP "$conf\->matching( $request )" 4
.el .IP "\f(CW$conf\fR\->matching( \f(CW$request\fR )" 4
.IX Item "$conf->matching( $request )"
.ie n .IP "$conf\->matching( $response )" 4
.el .IP "\f(CW$conf\fR\->matching( \f(CW$response\fR )" 4
.IX Item "$conf->matching( $response )"
.PD
Returns the entries that match the given \f(CW$uri\fR, \f(CW$request\fR and \f(CW$response\fR triplet.
.Sp
If called with a single \f(CW$request\fR object then the \f(CW$uri\fR is obtained by calling its 'uri_canonical' method.
If called with a single \f(CW$response\fR object, then the request object is obtained by calling its 'request' method;
and then the \f(CW$uri\fR is obtained as if a single \f(CW$request\fR was provided.
.Sp
The entries are returned with the most specific matches first.
In scalar context returns the most specific match or \f(CW\*(C`undef\*(C'\fR in none match.
.ie n .IP "$conf\->add_item( $item, %matchspec )" 4
.el .IP "\f(CW$conf\fR\->add_item( \f(CW$item\fR, \f(CW%matchspec\fR )" 4
.IX Item "$conf->add_item( $item, %matchspec )"
.PD 0
.ie n .IP "$conf\->remove_items( %spec )" 4
.el .IP "\f(CW$conf\fR\->remove_items( \f(CW%spec\fR )" 4
.IX Item "$conf->remove_items( %spec )"
.ie n .IP "$conf\->matching_items( $uri, $request, $response )" 4
.el .IP "\f(CW$conf\fR\->matching_items( \f(CW$uri\fR, \f(CW$request\fR, \f(CW$response\fR )" 4
.IX Item "$conf->matching_items( $uri, $request, $response )"
.PD
Wrappers that hides the entries themselves.
.SS "Matching"
.IX Subsection "Matching"
The following keys on a configuration entry specify matching.  For all
of these you can provide an array of values instead of a single value.
The entry matches if at least one of the values in the array matches.
.PP
Entries that require match against a response object attribute will never match
unless a response object was provided.
.ie n .IP "m_scheme => $scheme" 4
.el .IP "m_scheme => \f(CW$scheme\fR" 4
.IX Item "m_scheme => $scheme"
Matches if the \s-1URI\s0 uses the specified scheme; e.g. \*(L"http\*(R".
.ie n .IP "m_secure => $bool" 4
.el .IP "m_secure => \f(CW$bool\fR" 4
.IX Item "m_secure => $bool"
If \f(CW$bool\fR is \s-1TRUE\s0; matches if the \s-1URI\s0 uses a secure scheme.  If \f(CW$bool\fR
is \s-1FALSE\s0; matches if the \s-1URI\s0 does not use a secure scheme.  An example
of a secure scheme is \*(L"https\*(R".
.ie n .IP "m_host_port => ""$hostname:$port""" 4
.el .IP "m_host_port => ``$hostname:$port''" 4
.IX Item "m_host_port => $hostname:$port"
Matches if the \s-1URI\s0's host_port method return the specified value.
.ie n .IP "m_host => $hostname" 4
.el .IP "m_host => \f(CW$hostname\fR" 4
.IX Item "m_host => $hostname"
Matches if the \s-1URI\s0's host method returns the specified value.
.ie n .IP "m_port => $port" 4
.el .IP "m_port => \f(CW$port\fR" 4
.IX Item "m_port => $port"
Matches if the \s-1URI\s0's port method returns the specified value.
.ie n .IP "m_domain => "".$domain""" 4
.el .IP "m_domain => ``.$domain''" 4
.IX Item "m_domain => .$domain"
Matches if the \s-1URI\s0's host method return a value that within the given
domain.  The hostname \*(L"www.example.com\*(R" will for instance match the
domain \*(L".com\*(R".
.ie n .IP "m_path => $path" 4
.el .IP "m_path => \f(CW$path\fR" 4
.IX Item "m_path => $path"
Matches if the \s-1URI\s0's path method returns the specified value.
.ie n .IP "m_path_prefix => $path" 4
.el .IP "m_path_prefix => \f(CW$path\fR" 4
.IX Item "m_path_prefix => $path"
Matches if the \s-1URI\s0's path is the specified path or has the specified
path as prefix.
.ie n .IP "m_path_match => $Regexp" 4
.el .IP "m_path_match => \f(CW$Regexp\fR" 4
.IX Item "m_path_match => $Regexp"
Matches if the regular expression matches the \s-1URI\s0's path.  Eg. qr/\e.html$/.
.ie n .IP "m_method => $method" 4
.el .IP "m_method => \f(CW$method\fR" 4
.IX Item "m_method => $method"
Matches if the request method matches the specified value. Eg. \*(L"\s-1GET\*(R"\s0 or \*(L"\s-1POST\*(R".\s0
.ie n .IP "m_code => $digit" 4
.el .IP "m_code => \f(CW$digit\fR" 4
.IX Item "m_code => $digit"
.PD 0
.ie n .IP "m_code => $status_code" 4
.el .IP "m_code => \f(CW$status_code\fR" 4
.IX Item "m_code => $status_code"
.PD
Matches if the response status code matches.  If a single digit is
specified; matches for all response status codes beginning with that digit.
.ie n .IP "m_proxy => $url" 4
.el .IP "m_proxy => \f(CW$url\fR" 4
.IX Item "m_proxy => $url"
Matches if the request is to be sent to the given Proxy server.
.ie n .IP "m_media_type => ""*/*""" 4
.el .IP "m_media_type => ``*/*''" 4
.IX Item "m_media_type => */*"
.PD 0
.ie n .IP "m_media_type => ""text/*""" 4
.el .IP "m_media_type => ``text/*''" 4
.IX Item "m_media_type => text/*"
.ie n .IP "m_media_type => ""html""" 4
.el .IP "m_media_type => ``html''" 4
.IX Item "m_media_type => html"
.ie n .IP "m_media_type => ""xhtml""" 4
.el .IP "m_media_type => ``xhtml''" 4
.IX Item "m_media_type => xhtml"
.ie n .IP "m_media_type => ""text/html""" 4
.el .IP "m_media_type => ``text/html''" 4
.IX Item "m_media_type => text/html"
.PD
Matches if the response media type matches.
.Sp
With a value of \*(L"html\*(R" matches if \f(CW$response\fR\->content_is_html returns \s-1TRUE.\s0
With a value of \*(L"xhtml\*(R" matches if \f(CW$response\fR\->content_is_xhtml returns \s-1TRUE.\s0
.ie n .IP "m_uri_\|_\fI\fI$method\fI\fR => undef" 4
.el .IP "m_uri_\|_\fI\f(CI$method\fI\fR => undef" 4
.IX Item "m_uri__$method => undef"
Matches if the \s-1URI\s0 object provides the method.
.ie n .IP "m_uri_\|_\fI\fI$method\fI\fR => $string" 4
.el .IP "m_uri_\|_\fI\f(CI$method\fI\fR => \f(CW$string\fR" 4
.IX Item "m_uri__$method => $string"
Matches if the \s-1URI\s0's \f(CW$method\fR method returns the given value.
.ie n .IP "m_header_\|_\fI\fI$field\fI\fR => $string" 4
.el .IP "m_header_\|_\fI\f(CI$field\fI\fR => \f(CW$string\fR" 4
.IX Item "m_header__$field => $string"
Matches if either the request or the response have a header \f(CW$field\fR with the given value.
.ie n .IP "m_response_attr_\|_\fI\fI$key\fI\fR => undef" 4
.el .IP "m_response_attr_\|_\fI\f(CI$key\fI\fR => undef" 4
.IX Item "m_response_attr__$key => undef"
.PD 0
.ie n .IP "m_response_attr_\|_\fI\fI$key\fI\fR => $string" 4
.el .IP "m_response_attr_\|_\fI\f(CI$key\fI\fR => \f(CW$string\fR" 4
.IX Item "m_response_attr__$key => $string"
.PD
Matches if the response object has that key, or the entry has the given value.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1URI\s0, HTTP::Request, HTTP::Response
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2008, Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Config5.16.3pm                         0100644 0001750 0001750 00000031373 12566241314 023707  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Config 3"
.TH HTTP::Config 3 "2012-02-15" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Config \- Configuration for request and response objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use HTTP::Config;
\& my $c = HTTP::Config\->new;
\& $c\->add(m_domain => ".example.com", m_scheme => "http", verbose => 1);
\& 
\& use HTTP::Request;
\& my $request = HTTP::Request\->new(GET => "http://www.example.com");
\& 
\& if (my @m = $c\->matching($request)) {
\&    print "Yadayada\en" if $m[0]\->{verbose};
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An \f(CW\*(C`HTTP::Config\*(C'\fR object is a list of entries that
can be matched against request or request/response pairs.  Its
purpose is to hold configuration data that can be looked up given a
request or response object.
.PP
Each configuration entry is a hash.  Some keys specify matching to
occur against attributes of request/response objects.  Other keys can
be used to hold user data.
.PP
The following methods are provided:
.ie n .IP "$conf = HTTP::Config\->new" 4
.el .IP "\f(CW$conf\fR = HTTP::Config\->new" 4
.IX Item "$conf = HTTP::Config->new"
Constructs a new empty \f(CW\*(C`HTTP::Config\*(C'\fR object and returns it.
.ie n .IP "$conf\->entries" 4
.el .IP "\f(CW$conf\fR\->entries" 4
.IX Item "$conf->entries"
Returns the list of entries in the configuration object.
In scalar context returns the number of entries.
.ie n .IP "$conf\->empty" 4
.el .IP "\f(CW$conf\fR\->empty" 4
.IX Item "$conf->empty"
Return true if there are no entries in the configuration object.
This is just a shorthand for \f(CW\*(C`not $conf\->entries\*(C'\fR.
.ie n .IP "$conf\->add( %matchspec, %other )" 4
.el .IP "\f(CW$conf\fR\->add( \f(CW%matchspec\fR, \f(CW%other\fR )" 4
.IX Item "$conf->add( %matchspec, %other )"
.PD 0
.ie n .IP "$conf\->add( \e%entry )" 4
.el .IP "\f(CW$conf\fR\->add( \e%entry )" 4
.IX Item "$conf->add( %entry )"
.PD
Adds a new entry to the configuration.
You can either pass separate key/value pairs or a hash reference.
.ie n .IP "$conf\->remove( %spec )" 4
.el .IP "\f(CW$conf\fR\->remove( \f(CW%spec\fR )" 4
.IX Item "$conf->remove( %spec )"
Removes (and returns) the entries that have matches for all the key/value pairs in \f(CW%spec\fR.
If \f(CW%spec\fR is empty this will match all entries; so it will empty the configuation object.
.ie n .IP "$conf\->matching( $uri, $request, $response )" 4
.el .IP "\f(CW$conf\fR\->matching( \f(CW$uri\fR, \f(CW$request\fR, \f(CW$response\fR )" 4
.IX Item "$conf->matching( $uri, $request, $response )"
.PD 0
.ie n .IP "$conf\->matching( $uri )" 4
.el .IP "\f(CW$conf\fR\->matching( \f(CW$uri\fR )" 4
.IX Item "$conf->matching( $uri )"
.ie n .IP "$conf\->matching( $request )" 4
.el .IP "\f(CW$conf\fR\->matching( \f(CW$request\fR )" 4
.IX Item "$conf->matching( $request )"
.ie n .IP "$conf\->matching( $response )" 4
.el .IP "\f(CW$conf\fR\->matching( \f(CW$response\fR )" 4
.IX Item "$conf->matching( $response )"
.PD
Returns the entries that match the given \f(CW$uri\fR, \f(CW$request\fR and \f(CW$response\fR triplet.
.Sp
If called with a single \f(CW$request\fR object then the \f(CW$uri\fR is obtained by calling its 'uri_canonical' method.
If called with a single \f(CW$response\fR object, then the request object is obtained by calling its 'request' method;
and then the \f(CW$uri\fR is obtained as if a single \f(CW$request\fR was provided.
.Sp
The entries are returned with the most specific matches first.
In scalar context returns the most specific match or \f(CW\*(C`undef\*(C'\fR in none match.
.ie n .IP "$conf\->add_item( $item, %matchspec )" 4
.el .IP "\f(CW$conf\fR\->add_item( \f(CW$item\fR, \f(CW%matchspec\fR )" 4
.IX Item "$conf->add_item( $item, %matchspec )"
.PD 0
.ie n .IP "$conf\->remove_items( %spec )" 4
.el .IP "\f(CW$conf\fR\->remove_items( \f(CW%spec\fR )" 4
.IX Item "$conf->remove_items( %spec )"
.ie n .IP "$conf\->matching_items( $uri, $request, $response )" 4
.el .IP "\f(CW$conf\fR\->matching_items( \f(CW$uri\fR, \f(CW$request\fR, \f(CW$response\fR )" 4
.IX Item "$conf->matching_items( $uri, $request, $response )"
.PD
Wrappers that hides the entries themselves.
.SS "Matching"
.IX Subsection "Matching"
The following keys on a configuration entry specify matching.  For all
of these you can provide an array of values instead of a single value.
The entry matches if at least one of the values in the array matches.
.PP
Entries that require match against a response object attribute will never match
unless a response object was provided.
.ie n .IP "m_scheme => $scheme" 4
.el .IP "m_scheme => \f(CW$scheme\fR" 4
.IX Item "m_scheme => $scheme"
Matches if the \s-1URI\s0 uses the specified scheme; e.g. \*(L"http\*(R".
.ie n .IP "m_secure => $bool" 4
.el .IP "m_secure => \f(CW$bool\fR" 4
.IX Item "m_secure => $bool"
If \f(CW$bool\fR is \s-1TRUE\s0; matches if the \s-1URI\s0 uses a secure scheme.  If \f(CW$bool\fR
is \s-1FALSE\s0; matches if the \s-1URI\s0 does not use a secure scheme.  An example
of a secure scheme is \*(L"https\*(R".
.ie n .IP "m_host_port => ""$hostname:$port""" 4
.el .IP "m_host_port => ``$hostname:$port''" 4
.IX Item "m_host_port => $hostname:$port"
Matches if the \s-1URI\s0's host_port method return the specified value.
.ie n .IP "m_host => $hostname" 4
.el .IP "m_host => \f(CW$hostname\fR" 4
.IX Item "m_host => $hostname"
Matches if the \s-1URI\s0's host method returns the specified value.
.ie n .IP "m_port => $port" 4
.el .IP "m_port => \f(CW$port\fR" 4
.IX Item "m_port => $port"
Matches if the \s-1URI\s0's port method returns the specified value.
.ie n .IP "m_domain => "".$domain""" 4
.el .IP "m_domain => ``.$domain''" 4
.IX Item "m_domain => .$domain"
Matches if the \s-1URI\s0's host method return a value that within the given
domain.  The hostname \*(L"www.example.com\*(R" will for instance match the
domain \*(L".com\*(R".
.ie n .IP "m_path => $path" 4
.el .IP "m_path => \f(CW$path\fR" 4
.IX Item "m_path => $path"
Matches if the \s-1URI\s0's path method returns the specified value.
.ie n .IP "m_path_prefix => $path" 4
.el .IP "m_path_prefix => \f(CW$path\fR" 4
.IX Item "m_path_prefix => $path"
Matches if the \s-1URI\s0's path is the specified path or has the specified
path as prefix.
.ie n .IP "m_path_match => $Regexp" 4
.el .IP "m_path_match => \f(CW$Regexp\fR" 4
.IX Item "m_path_match => $Regexp"
Matches if the regular expression matches the \s-1URI\s0's path.  Eg. qr/\e.html$/.
.ie n .IP "m_method => $method" 4
.el .IP "m_method => \f(CW$method\fR" 4
.IX Item "m_method => $method"
Matches if the request method matches the specified value. Eg. \*(L"\s-1GET\s0\*(R" or \*(L"\s-1POST\s0\*(R".
.ie n .IP "m_code => $digit" 4
.el .IP "m_code => \f(CW$digit\fR" 4
.IX Item "m_code => $digit"
.PD 0
.ie n .IP "m_code => $status_code" 4
.el .IP "m_code => \f(CW$status_code\fR" 4
.IX Item "m_code => $status_code"
.PD
Matches if the response status code matches.  If a single digit is
specified; matches for all response status codes beginning with that digit.
.ie n .IP "m_proxy => $url" 4
.el .IP "m_proxy => \f(CW$url\fR" 4
.IX Item "m_proxy => $url"
Matches if the request is to be sent to the given Proxy server.
.ie n .IP "m_media_type => ""*/*""" 4
.el .IP "m_media_type => ``*/*''" 4
.IX Item "m_media_type => */*"
.PD 0
.ie n .IP "m_media_type => ""text/*""" 4
.el .IP "m_media_type => ``text/*''" 4
.IX Item "m_media_type => text/*"
.ie n .IP "m_media_type => ""html""" 4
.el .IP "m_media_type => ``html''" 4
.IX Item "m_media_type => html"
.ie n .IP "m_media_type => ""xhtml""" 4
.el .IP "m_media_type => ``xhtml''" 4
.IX Item "m_media_type => xhtml"
.ie n .IP "m_media_type => ""text/html""" 4
.el .IP "m_media_type => ``text/html''" 4
.IX Item "m_media_type => text/html"
.PD
Matches if the response media type matches.
.Sp
With a value of \*(L"html\*(R" matches if \f(CW$response\fR\->content_is_html returns \s-1TRUE\s0.
With a value of \*(L"xhtml\*(R" matches if \f(CW$response\fR\->content_is_xhtml returns \s-1TRUE\s0.
.ie n .IP "m_uri_\|_\fI\fI$method\fI\fR => undef" 4
.el .IP "m_uri_\|_\fI\f(CI$method\fI\fR => undef" 4
.IX Item "m_uri__$method => undef"
Matches if the \s-1URI\s0 object provides the method.
.ie n .IP "m_uri_\|_\fI\fI$method\fI\fR => $string" 4
.el .IP "m_uri_\|_\fI\f(CI$method\fI\fR => \f(CW$string\fR" 4
.IX Item "m_uri__$method => $string"
Matches if the \s-1URI\s0's \f(CW$method\fR method returns the given value.
.ie n .IP "m_header_\|_\fI\fI$field\fI\fR => $string" 4
.el .IP "m_header_\|_\fI\f(CI$field\fI\fR => \f(CW$string\fR" 4
.IX Item "m_header__$field => $string"
Matches if either the request or the response have a header \f(CW$field\fR with the given value.
.ie n .IP "m_response_attr_\|_\fI\fI$key\fI\fR => undef" 4
.el .IP "m_response_attr_\|_\fI\f(CI$key\fI\fR => undef" 4
.IX Item "m_response_attr__$key => undef"
.PD 0
.ie n .IP "m_response_attr_\|_\fI\fI$key\fI\fR => $string" 4
.el .IP "m_response_attr_\|_\fI\f(CI$key\fI\fR => \f(CW$string\fR" 4
.IX Item "m_response_attr__$key => $string"
.PD
Matches if the response object has that key, or the entry has the given value.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1URI\s0, HTTP::Request, HTTP::Response
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2008, Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Config5.18.3pm                         0100644 0001750 0001750 00000031714 12566241314 023710  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Config 3"
.TH HTTP::Config 3 "2012-02-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Config \- Configuration for request and response objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use HTTP::Config;
\& my $c = HTTP::Config\->new;
\& $c\->add(m_domain => ".example.com", m_scheme => "http", verbose => 1);
\& 
\& use HTTP::Request;
\& my $request = HTTP::Request\->new(GET => "http://www.example.com");
\& 
\& if (my @m = $c\->matching($request)) {
\&    print "Yadayada\en" if $m[0]\->{verbose};
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An \f(CW\*(C`HTTP::Config\*(C'\fR object is a list of entries that
can be matched against request or request/response pairs.  Its
purpose is to hold configuration data that can be looked up given a
request or response object.
.PP
Each configuration entry is a hash.  Some keys specify matching to
occur against attributes of request/response objects.  Other keys can
be used to hold user data.
.PP
The following methods are provided:
.ie n .IP "$conf = HTTP::Config\->new" 4
.el .IP "\f(CW$conf\fR = HTTP::Config\->new" 4
.IX Item "$conf = HTTP::Config->new"
Constructs a new empty \f(CW\*(C`HTTP::Config\*(C'\fR object and returns it.
.ie n .IP "$conf\->entries" 4
.el .IP "\f(CW$conf\fR\->entries" 4
.IX Item "$conf->entries"
Returns the list of entries in the configuration object.
In scalar context returns the number of entries.
.ie n .IP "$conf\->empty" 4
.el .IP "\f(CW$conf\fR\->empty" 4
.IX Item "$conf->empty"
Return true if there are no entries in the configuration object.
This is just a shorthand for \f(CW\*(C`not $conf\->entries\*(C'\fR.
.ie n .IP "$conf\->add( %matchspec, %other )" 4
.el .IP "\f(CW$conf\fR\->add( \f(CW%matchspec\fR, \f(CW%other\fR )" 4
.IX Item "$conf->add( %matchspec, %other )"
.PD 0
.ie n .IP "$conf\->add( \e%entry )" 4
.el .IP "\f(CW$conf\fR\->add( \e%entry )" 4
.IX Item "$conf->add( %entry )"
.PD
Adds a new entry to the configuration.
You can either pass separate key/value pairs or a hash reference.
.ie n .IP "$conf\->remove( %spec )" 4
.el .IP "\f(CW$conf\fR\->remove( \f(CW%spec\fR )" 4
.IX Item "$conf->remove( %spec )"
Removes (and returns) the entries that have matches for all the key/value pairs in \f(CW%spec\fR.
If \f(CW%spec\fR is empty this will match all entries; so it will empty the configuation object.
.ie n .IP "$conf\->matching( $uri, $request, $response )" 4
.el .IP "\f(CW$conf\fR\->matching( \f(CW$uri\fR, \f(CW$request\fR, \f(CW$response\fR )" 4
.IX Item "$conf->matching( $uri, $request, $response )"
.PD 0
.ie n .IP "$conf\->matching( $uri )" 4
.el .IP "\f(CW$conf\fR\->matching( \f(CW$uri\fR )" 4
.IX Item "$conf->matching( $uri )"
.ie n .IP "$conf\->matching( $request )" 4
.el .IP "\f(CW$conf\fR\->matching( \f(CW$request\fR )" 4
.IX Item "$conf->matching( $request )"
.ie n .IP "$conf\->matching( $response )" 4
.el .IP "\f(CW$conf\fR\->matching( \f(CW$response\fR )" 4
.IX Item "$conf->matching( $response )"
.PD
Returns the entries that match the given \f(CW$uri\fR, \f(CW$request\fR and \f(CW$response\fR triplet.
.Sp
If called with a single \f(CW$request\fR object then the \f(CW$uri\fR is obtained by calling its 'uri_canonical' method.
If called with a single \f(CW$response\fR object, then the request object is obtained by calling its 'request' method;
and then the \f(CW$uri\fR is obtained as if a single \f(CW$request\fR was provided.
.Sp
The entries are returned with the most specific matches first.
In scalar context returns the most specific match or \f(CW\*(C`undef\*(C'\fR in none match.
.ie n .IP "$conf\->add_item( $item, %matchspec )" 4
.el .IP "\f(CW$conf\fR\->add_item( \f(CW$item\fR, \f(CW%matchspec\fR )" 4
.IX Item "$conf->add_item( $item, %matchspec )"
.PD 0
.ie n .IP "$conf\->remove_items( %spec )" 4
.el .IP "\f(CW$conf\fR\->remove_items( \f(CW%spec\fR )" 4
.IX Item "$conf->remove_items( %spec )"
.ie n .IP "$conf\->matching_items( $uri, $request, $response )" 4
.el .IP "\f(CW$conf\fR\->matching_items( \f(CW$uri\fR, \f(CW$request\fR, \f(CW$response\fR )" 4
.IX Item "$conf->matching_items( $uri, $request, $response )"
.PD
Wrappers that hides the entries themselves.
.SS "Matching"
.IX Subsection "Matching"
The following keys on a configuration entry specify matching.  For all
of these you can provide an array of values instead of a single value.
The entry matches if at least one of the values in the array matches.
.PP
Entries that require match against a response object attribute will never match
unless a response object was provided.
.ie n .IP "m_scheme => $scheme" 4
.el .IP "m_scheme => \f(CW$scheme\fR" 4
.IX Item "m_scheme => $scheme"
Matches if the \s-1URI\s0 uses the specified scheme; e.g. \*(L"http\*(R".
.ie n .IP "m_secure => $bool" 4
.el .IP "m_secure => \f(CW$bool\fR" 4
.IX Item "m_secure => $bool"
If \f(CW$bool\fR is \s-1TRUE\s0; matches if the \s-1URI\s0 uses a secure scheme.  If \f(CW$bool\fR
is \s-1FALSE\s0; matches if the \s-1URI\s0 does not use a secure scheme.  An example
of a secure scheme is \*(L"https\*(R".
.ie n .IP "m_host_port => ""$hostname:$port""" 4
.el .IP "m_host_port => ``$hostname:$port''" 4
.IX Item "m_host_port => $hostname:$port"
Matches if the \s-1URI\s0's host_port method return the specified value.
.ie n .IP "m_host => $hostname" 4
.el .IP "m_host => \f(CW$hostname\fR" 4
.IX Item "m_host => $hostname"
Matches if the \s-1URI\s0's host method returns the specified value.
.ie n .IP "m_port => $port" 4
.el .IP "m_port => \f(CW$port\fR" 4
.IX Item "m_port => $port"
Matches if the \s-1URI\s0's port method returns the specified value.
.ie n .IP "m_domain => "".$domain""" 4
.el .IP "m_domain => ``.$domain''" 4
.IX Item "m_domain => .$domain"
Matches if the \s-1URI\s0's host method return a value that within the given
domain.  The hostname \*(L"www.example.com\*(R" will for instance match the
domain \*(L".com\*(R".
.ie n .IP "m_path => $path" 4
.el .IP "m_path => \f(CW$path\fR" 4
.IX Item "m_path => $path"
Matches if the \s-1URI\s0's path method returns the specified value.
.ie n .IP "m_path_prefix => $path" 4
.el .IP "m_path_prefix => \f(CW$path\fR" 4
.IX Item "m_path_prefix => $path"
Matches if the \s-1URI\s0's path is the specified path or has the specified
path as prefix.
.ie n .IP "m_path_match => $Regexp" 4
.el .IP "m_path_match => \f(CW$Regexp\fR" 4
.IX Item "m_path_match => $Regexp"
Matches if the regular expression matches the \s-1URI\s0's path.  Eg. qr/\e.html$/.
.ie n .IP "m_method => $method" 4
.el .IP "m_method => \f(CW$method\fR" 4
.IX Item "m_method => $method"
Matches if the request method matches the specified value. Eg. \*(L"\s-1GET\*(R"\s0 or \*(L"\s-1POST\*(R".\s0
.ie n .IP "m_code => $digit" 4
.el .IP "m_code => \f(CW$digit\fR" 4
.IX Item "m_code => $digit"
.PD 0
.ie n .IP "m_code => $status_code" 4
.el .IP "m_code => \f(CW$status_code\fR" 4
.IX Item "m_code => $status_code"
.PD
Matches if the response status code matches.  If a single digit is
specified; matches for all response status codes beginning with that digit.
.ie n .IP "m_proxy => $url" 4
.el .IP "m_proxy => \f(CW$url\fR" 4
.IX Item "m_proxy => $url"
Matches if the request is to be sent to the given Proxy server.
.ie n .IP "m_media_type => ""*/*""" 4
.el .IP "m_media_type => ``*/*''" 4
.IX Item "m_media_type => */*"
.PD 0
.ie n .IP "m_media_type => ""text/*""" 4
.el .IP "m_media_type => ``text/*''" 4
.IX Item "m_media_type => text/*"
.ie n .IP "m_media_type => ""html""" 4
.el .IP "m_media_type => ``html''" 4
.IX Item "m_media_type => html"
.ie n .IP "m_media_type => ""xhtml""" 4
.el .IP "m_media_type => ``xhtml''" 4
.IX Item "m_media_type => xhtml"
.ie n .IP "m_media_type => ""text/html""" 4
.el .IP "m_media_type => ``text/html''" 4
.IX Item "m_media_type => text/html"
.PD
Matches if the response media type matches.
.Sp
With a value of \*(L"html\*(R" matches if \f(CW$response\fR\->content_is_html returns \s-1TRUE.\s0
With a value of \*(L"xhtml\*(R" matches if \f(CW$response\fR\->content_is_xhtml returns \s-1TRUE.\s0
.ie n .IP "m_uri_\|_\fI\fI$method\fI\fR => undef" 4
.el .IP "m_uri_\|_\fI\f(CI$method\fI\fR => undef" 4
.IX Item "m_uri__$method => undef"
Matches if the \s-1URI\s0 object provides the method.
.ie n .IP "m_uri_\|_\fI\fI$method\fI\fR => $string" 4
.el .IP "m_uri_\|_\fI\f(CI$method\fI\fR => \f(CW$string\fR" 4
.IX Item "m_uri__$method => $string"
Matches if the \s-1URI\s0's \f(CW$method\fR method returns the given value.
.ie n .IP "m_header_\|_\fI\fI$field\fI\fR => $string" 4
.el .IP "m_header_\|_\fI\f(CI$field\fI\fR => \f(CW$string\fR" 4
.IX Item "m_header__$field => $string"
Matches if either the request or the response have a header \f(CW$field\fR with the given value.
.ie n .IP "m_response_attr_\|_\fI\fI$key\fI\fR => undef" 4
.el .IP "m_response_attr_\|_\fI\f(CI$key\fI\fR => undef" 4
.IX Item "m_response_attr__$key => undef"
.PD 0
.ie n .IP "m_response_attr_\|_\fI\fI$key\fI\fR => $string" 4
.el .IP "m_response_attr_\|_\fI\f(CI$key\fI\fR => \f(CW$string\fR" 4
.IX Item "m_response_attr__$key => $string"
.PD
Matches if the response object has that key, or the entry has the given value.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1URI\s0, HTTP::Request, HTTP::Response
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2008, Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Cookies.3pm                            0100644 0001750 0001750 00000027762 12566241317 023576  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Cookies 3"
.TH HTTP::Cookies 3 "2012-02-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Cookies \- HTTP cookie jars
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use HTTP::Cookies;
\&  $cookie_jar = HTTP::Cookies\->new(
\&    file => "$ENV{\*(AqHOME\*(Aq}/lwp_cookies.dat",
\&    autosave => 1,
\&  );
\&
\&  use LWP;
\&  my $browser = LWP::UserAgent\->new;
\&  $browser\->cookie_jar($cookie_jar);
.Ve
.PP
Or for an empty and temporary cookie jar:
.PP
.Vb 3
\&  use LWP;
\&  my $browser = LWP::UserAgent\->new;
\&  $browser\->cookie_jar( {} );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is for objects that represent a \*(L"cookie jar\*(R" \*(-- that is, a
database of all the \s-1HTTP\s0 cookies that a given LWP::UserAgent object
knows about.
.PP
Cookies are a general mechanism which server side connections can use
to both store and retrieve information on the client side of the
connection.  For more information about cookies refer to
<URL:http://curl.haxx.se/rfc/cookie_spec.html> and
<URL:http://www.cookiecentral.com/>.  This module also implements the
new style cookies described in \fI\s-1RFC 2965\s0\fR.
The two variants of cookies are supposed to be able to coexist happily.
.PP
Instances of the class \fIHTTP::Cookies\fR are able to store a collection
of Set\-Cookie2: and Set-Cookie: headers and are able to use this
information to initialize Cookie-headers in \fIHTTP::Request\fR objects.
The state of a \fIHTTP::Cookies\fR object can be saved in and restored from
files.
.SH "METHODS"
.IX Header "METHODS"
The following methods are provided:
.ie n .IP "$cookie_jar = HTTP::Cookies\->new" 4
.el .IP "\f(CW$cookie_jar\fR = HTTP::Cookies\->new" 4
.IX Item "$cookie_jar = HTTP::Cookies->new"
The constructor takes hash style parameters.  The following
parameters are recognized:
.Sp
.Vb 4
\&  file:            name of the file to restore cookies from and save cookies to
\&  autosave:        save during destruction (bool)
\&  ignore_discard:  save even cookies that are requested to be discarded (bool)
\&  hide_cookie2:    do not add Cookie2 header to requests
.Ve
.Sp
Future parameters might include (not yet implemented):
.Sp
.Vb 3
\&  max_cookies               300
\&  max_cookies_per_domain    20
\&  max_cookie_size           4096
\&
\&  no_cookies   list of domain names that we never return cookies to
.Ve
.ie n .IP "$cookie_jar\->add_cookie_header( $request )" 4
.el .IP "\f(CW$cookie_jar\fR\->add_cookie_header( \f(CW$request\fR )" 4
.IX Item "$cookie_jar->add_cookie_header( $request )"
The \fIadd_cookie_header()\fR method will set the appropriate Cookie:\-header
for the \fIHTTP::Request\fR object given as argument.  The \f(CW$request\fR must
have a valid url attribute before this method is called.
.ie n .IP "$cookie_jar\->extract_cookies( $response )" 4
.el .IP "\f(CW$cookie_jar\fR\->extract_cookies( \f(CW$response\fR )" 4
.IX Item "$cookie_jar->extract_cookies( $response )"
The \fIextract_cookies()\fR method will look for Set-Cookie: and
Set\-Cookie2: headers in the \fIHTTP::Response\fR object passed as
argument.  Any of these headers that are found are used to update
the state of the \f(CW$cookie_jar\fR.
.ie n .IP "$cookie_jar\->set_cookie( $version, $key, $val, $path, $domain, $port, $path_spec, $secure, $maxage, $discard, \e%rest )" 4
.el .IP "\f(CW$cookie_jar\fR\->set_cookie( \f(CW$version\fR, \f(CW$key\fR, \f(CW$val\fR, \f(CW$path\fR, \f(CW$domain\fR, \f(CW$port\fR, \f(CW$path_spec\fR, \f(CW$secure\fR, \f(CW$maxage\fR, \f(CW$discard\fR, \e%rest )" 4
.IX Item "$cookie_jar->set_cookie( $version, $key, $val, $path, $domain, $port, $path_spec, $secure, $maxage, $discard, %rest )"
The \fIset_cookie()\fR method updates the state of the \f(CW$cookie_jar\fR.  The
\&\f(CW$key\fR, \f(CW$val\fR, \f(CW$domain\fR, \f(CW$port\fR and \f(CW$path\fR arguments are strings.  The
\&\f(CW$path_spec\fR, \f(CW$secure\fR, \f(CW$discard\fR arguments are boolean values. The \f(CW$maxage\fR
value is a number indicating number of seconds that this cookie will
live.  A value <= 0 will delete this cookie.  \f(CW%rest\fR defines
various other attributes like \*(L"Comment\*(R" and \*(L"CommentURL\*(R".
.ie n .IP "$cookie_jar\->save" 4
.el .IP "\f(CW$cookie_jar\fR\->save" 4
.IX Item "$cookie_jar->save"
.PD 0
.ie n .IP "$cookie_jar\->save( $file )" 4
.el .IP "\f(CW$cookie_jar\fR\->save( \f(CW$file\fR )" 4
.IX Item "$cookie_jar->save( $file )"
.PD
This method file saves the state of the \f(CW$cookie_jar\fR to a file.
The state can then be restored later using the \fIload()\fR method.  If a
filename is not specified we will use the name specified during
construction.  If the attribute \fIignore_discard\fR is set, then we
will even save cookies that are marked to be discarded.
.Sp
The default is to save a sequence of \*(L"Set\-Cookie3\*(R" lines.
\&\*(L"Set\-Cookie3\*(R" is a proprietary \s-1LWP\s0 format, not known to be compatible
with any browser.  The \fIHTTP::Cookies::Netscape\fR sub-class can
be used to save in a format compatible with Netscape.
.ie n .IP "$cookie_jar\->load" 4
.el .IP "\f(CW$cookie_jar\fR\->load" 4
.IX Item "$cookie_jar->load"
.PD 0
.ie n .IP "$cookie_jar\->load( $file )" 4
.el .IP "\f(CW$cookie_jar\fR\->load( \f(CW$file\fR )" 4
.IX Item "$cookie_jar->load( $file )"
.PD
This method reads the cookies from the file and adds them to the
\&\f(CW$cookie_jar\fR.  The file must be in the format written by the \fIsave()\fR
method.
.ie n .IP "$cookie_jar\->revert" 4
.el .IP "\f(CW$cookie_jar\fR\->revert" 4
.IX Item "$cookie_jar->revert"
This method empties the \f(CW$cookie_jar\fR and re-loads the \f(CW$cookie_jar\fR
from the last save file.
.ie n .IP "$cookie_jar\->clear" 4
.el .IP "\f(CW$cookie_jar\fR\->clear" 4
.IX Item "$cookie_jar->clear"
.PD 0
.ie n .IP "$cookie_jar\->clear( $domain )" 4
.el .IP "\f(CW$cookie_jar\fR\->clear( \f(CW$domain\fR )" 4
.IX Item "$cookie_jar->clear( $domain )"
.ie n .IP "$cookie_jar\->clear( $domain, $path )" 4
.el .IP "\f(CW$cookie_jar\fR\->clear( \f(CW$domain\fR, \f(CW$path\fR )" 4
.IX Item "$cookie_jar->clear( $domain, $path )"
.ie n .IP "$cookie_jar\->clear( $domain, $path, $key )" 4
.el .IP "\f(CW$cookie_jar\fR\->clear( \f(CW$domain\fR, \f(CW$path\fR, \f(CW$key\fR )" 4
.IX Item "$cookie_jar->clear( $domain, $path, $key )"
.PD
Invoking this method without arguments will empty the whole
\&\f(CW$cookie_jar\fR.  If given a single argument only cookies belonging to
that domain will be removed.  If given two arguments, cookies
belonging to the specified path within that domain are removed.  If
given three arguments, then the cookie with the specified key, path
and domain is removed.
.ie n .IP "$cookie_jar\->clear_temporary_cookies" 4
.el .IP "\f(CW$cookie_jar\fR\->clear_temporary_cookies" 4
.IX Item "$cookie_jar->clear_temporary_cookies"
Discard all temporary cookies. Scans for all cookies in the jar
with either no expire field or a true \f(CW\*(C`discard\*(C'\fR flag. To be
called when the user agent shuts down according to \s-1RFC 2965.\s0
.ie n .IP "$cookie_jar\->scan( \e&callback )" 4
.el .IP "\f(CW$cookie_jar\fR\->scan( \e&callback )" 4
.IX Item "$cookie_jar->scan( &callback )"
The argument is a subroutine that will be invoked for each cookie
stored in the \f(CW$cookie_jar\fR.  The subroutine will be invoked with
the following arguments:
.Sp
.Vb 11
\&  0  version
\&  1  key
\&  2  val
\&  3  path
\&  4  domain
\&  5  port
\&  6  path_spec
\&  7  secure
\&  8  expires
\&  9  discard
\& 10  hash
.Ve
.ie n .IP "$cookie_jar\->as_string" 4
.el .IP "\f(CW$cookie_jar\fR\->as_string" 4
.IX Item "$cookie_jar->as_string"
.PD 0
.ie n .IP "$cookie_jar\->as_string( $skip_discardables )" 4
.el .IP "\f(CW$cookie_jar\fR\->as_string( \f(CW$skip_discardables\fR )" 4
.IX Item "$cookie_jar->as_string( $skip_discardables )"
.PD
The \fIas_string()\fR method will return the state of the \f(CW$cookie_jar\fR
represented as a sequence of \*(L"Set\-Cookie3\*(R" header lines separated by
\&\*(L"\en\*(R".  If \f(CW$skip_discardables\fR is \s-1TRUE,\s0 it will not return lines for
cookies with the \fIDiscard\fR attribute.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTTP::Cookies::Netscape, HTTP::Cookies::Microsoft
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1997\-2002 Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Cookies5.16.3pm                        0100644 0001750 0001750 00000027441 12566241317 024102  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Cookies 3"
.TH HTTP::Cookies 3 "2012-02-15" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Cookies \- HTTP cookie jars
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use HTTP::Cookies;
\&  $cookie_jar = HTTP::Cookies\->new(
\&    file => "$ENV{\*(AqHOME\*(Aq}/lwp_cookies.dat",
\&    autosave => 1,
\&  );
\&
\&  use LWP;
\&  my $browser = LWP::UserAgent\->new;
\&  $browser\->cookie_jar($cookie_jar);
.Ve
.PP
Or for an empty and temporary cookie jar:
.PP
.Vb 3
\&  use LWP;
\&  my $browser = LWP::UserAgent\->new;
\&  $browser\->cookie_jar( {} );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is for objects that represent a \*(L"cookie jar\*(R" \*(-- that is, a
database of all the \s-1HTTP\s0 cookies that a given LWP::UserAgent object
knows about.
.PP
Cookies are a general mechanism which server side connections can use
to both store and retrieve information on the client side of the
connection.  For more information about cookies refer to
<URL:http://curl.haxx.se/rfc/cookie_spec.html> and
<URL:http://www.cookiecentral.com/>.  This module also implements the
new style cookies described in \fI\s-1RFC\s0 2965\fR.
The two variants of cookies are supposed to be able to coexist happily.
.PP
Instances of the class \fIHTTP::Cookies\fR are able to store a collection
of Set\-Cookie2: and Set-Cookie: headers and are able to use this
information to initialize Cookie-headers in \fIHTTP::Request\fR objects.
The state of a \fIHTTP::Cookies\fR object can be saved in and restored from
files.
.SH "METHODS"
.IX Header "METHODS"
The following methods are provided:
.ie n .IP "$cookie_jar = HTTP::Cookies\->new" 4
.el .IP "\f(CW$cookie_jar\fR = HTTP::Cookies\->new" 4
.IX Item "$cookie_jar = HTTP::Cookies->new"
The constructor takes hash style parameters.  The following
parameters are recognized:
.Sp
.Vb 4
\&  file:            name of the file to restore cookies from and save cookies to
\&  autosave:        save during destruction (bool)
\&  ignore_discard:  save even cookies that are requested to be discarded (bool)
\&  hide_cookie2:    do not add Cookie2 header to requests
.Ve
.Sp
Future parameters might include (not yet implemented):
.Sp
.Vb 3
\&  max_cookies               300
\&  max_cookies_per_domain    20
\&  max_cookie_size           4096
\&
\&  no_cookies   list of domain names that we never return cookies to
.Ve
.ie n .IP "$cookie_jar\->add_cookie_header( $request )" 4
.el .IP "\f(CW$cookie_jar\fR\->add_cookie_header( \f(CW$request\fR )" 4
.IX Item "$cookie_jar->add_cookie_header( $request )"
The \fIadd_cookie_header()\fR method will set the appropriate Cookie:\-header
for the \fIHTTP::Request\fR object given as argument.  The \f(CW$request\fR must
have a valid url attribute before this method is called.
.ie n .IP "$cookie_jar\->extract_cookies( $response )" 4
.el .IP "\f(CW$cookie_jar\fR\->extract_cookies( \f(CW$response\fR )" 4
.IX Item "$cookie_jar->extract_cookies( $response )"
The \fIextract_cookies()\fR method will look for Set-Cookie: and
Set\-Cookie2: headers in the \fIHTTP::Response\fR object passed as
argument.  Any of these headers that are found are used to update
the state of the \f(CW$cookie_jar\fR.
.ie n .IP "$cookie_jar\->set_cookie( $version, $key, $val, $path, $domain, $port, $path_spec, $secure, $maxage, $discard, \e%rest )" 4
.el .IP "\f(CW$cookie_jar\fR\->set_cookie( \f(CW$version\fR, \f(CW$key\fR, \f(CW$val\fR, \f(CW$path\fR, \f(CW$domain\fR, \f(CW$port\fR, \f(CW$path_spec\fR, \f(CW$secure\fR, \f(CW$maxage\fR, \f(CW$discard\fR, \e%rest )" 4
.IX Item "$cookie_jar->set_cookie( $version, $key, $val, $path, $domain, $port, $path_spec, $secure, $maxage, $discard, %rest )"
The \fIset_cookie()\fR method updates the state of the \f(CW$cookie_jar\fR.  The
\&\f(CW$key\fR, \f(CW$val\fR, \f(CW$domain\fR, \f(CW$port\fR and \f(CW$path\fR arguments are strings.  The
\&\f(CW$path_spec\fR, \f(CW$secure\fR, \f(CW$discard\fR arguments are boolean values. The \f(CW$maxage\fR
value is a number indicating number of seconds that this cookie will
live.  A value <= 0 will delete this cookie.  \f(CW%rest\fR defines
various other attributes like \*(L"Comment\*(R" and \*(L"CommentURL\*(R".
.ie n .IP "$cookie_jar\->save" 4
.el .IP "\f(CW$cookie_jar\fR\->save" 4
.IX Item "$cookie_jar->save"
.PD 0
.ie n .IP "$cookie_jar\->save( $file )" 4
.el .IP "\f(CW$cookie_jar\fR\->save( \f(CW$file\fR )" 4
.IX Item "$cookie_jar->save( $file )"
.PD
This method file saves the state of the \f(CW$cookie_jar\fR to a file.
The state can then be restored later using the \fIload()\fR method.  If a
filename is not specified we will use the name specified during
construction.  If the attribute \fIignore_discard\fR is set, then we
will even save cookies that are marked to be discarded.
.Sp
The default is to save a sequence of \*(L"Set\-Cookie3\*(R" lines.
\&\*(L"Set\-Cookie3\*(R" is a proprietary \s-1LWP\s0 format, not known to be compatible
with any browser.  The \fIHTTP::Cookies::Netscape\fR sub-class can
be used to save in a format compatible with Netscape.
.ie n .IP "$cookie_jar\->load" 4
.el .IP "\f(CW$cookie_jar\fR\->load" 4
.IX Item "$cookie_jar->load"
.PD 0
.ie n .IP "$cookie_jar\->load( $file )" 4
.el .IP "\f(CW$cookie_jar\fR\->load( \f(CW$file\fR )" 4
.IX Item "$cookie_jar->load( $file )"
.PD
This method reads the cookies from the file and adds them to the
\&\f(CW$cookie_jar\fR.  The file must be in the format written by the \fIsave()\fR
method.
.ie n .IP "$cookie_jar\->revert" 4
.el .IP "\f(CW$cookie_jar\fR\->revert" 4
.IX Item "$cookie_jar->revert"
This method empties the \f(CW$cookie_jar\fR and re-loads the \f(CW$cookie_jar\fR
from the last save file.
.ie n .IP "$cookie_jar\->clear" 4
.el .IP "\f(CW$cookie_jar\fR\->clear" 4
.IX Item "$cookie_jar->clear"
.PD 0
.ie n .IP "$cookie_jar\->clear( $domain )" 4
.el .IP "\f(CW$cookie_jar\fR\->clear( \f(CW$domain\fR )" 4
.IX Item "$cookie_jar->clear( $domain )"
.ie n .IP "$cookie_jar\->clear( $domain, $path )" 4
.el .IP "\f(CW$cookie_jar\fR\->clear( \f(CW$domain\fR, \f(CW$path\fR )" 4
.IX Item "$cookie_jar->clear( $domain, $path )"
.ie n .IP "$cookie_jar\->clear( $domain, $path, $key )" 4
.el .IP "\f(CW$cookie_jar\fR\->clear( \f(CW$domain\fR, \f(CW$path\fR, \f(CW$key\fR )" 4
.IX Item "$cookie_jar->clear( $domain, $path, $key )"
.PD
Invoking this method without arguments will empty the whole
\&\f(CW$cookie_jar\fR.  If given a single argument only cookies belonging to
that domain will be removed.  If given two arguments, cookies
belonging to the specified path within that domain are removed.  If
given three arguments, then the cookie with the specified key, path
and domain is removed.
.ie n .IP "$cookie_jar\->clear_temporary_cookies" 4
.el .IP "\f(CW$cookie_jar\fR\->clear_temporary_cookies" 4
.IX Item "$cookie_jar->clear_temporary_cookies"
Discard all temporary cookies. Scans for all cookies in the jar
with either no expire field or a true \f(CW\*(C`discard\*(C'\fR flag. To be
called when the user agent shuts down according to \s-1RFC\s0 2965.
.ie n .IP "$cookie_jar\->scan( \e&callback )" 4
.el .IP "\f(CW$cookie_jar\fR\->scan( \e&callback )" 4
.IX Item "$cookie_jar->scan( &callback )"
The argument is a subroutine that will be invoked for each cookie
stored in the \f(CW$cookie_jar\fR.  The subroutine will be invoked with
the following arguments:
.Sp
.Vb 11
\&  0  version
\&  1  key
\&  2  val
\&  3  path
\&  4  domain
\&  5  port
\&  6  path_spec
\&  7  secure
\&  8  expires
\&  9  discard
\& 10  hash
.Ve
.ie n .IP "$cookie_jar\->as_string" 4
.el .IP "\f(CW$cookie_jar\fR\->as_string" 4
.IX Item "$cookie_jar->as_string"
.PD 0
.ie n .IP "$cookie_jar\->as_string( $skip_discardables )" 4
.el .IP "\f(CW$cookie_jar\fR\->as_string( \f(CW$skip_discardables\fR )" 4
.IX Item "$cookie_jar->as_string( $skip_discardables )"
.PD
The \fIas_string()\fR method will return the state of the \f(CW$cookie_jar\fR
represented as a sequence of \*(L"Set\-Cookie3\*(R" header lines separated by
\&\*(L"\en\*(R".  If \f(CW$skip_discardables\fR is \s-1TRUE\s0, it will not return lines for
cookies with the \fIDiscard\fR attribute.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTTP::Cookies::Netscape, HTTP::Cookies::Microsoft
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1997\-2002 Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Cookies5.18.3pm                        0100644 0001750 0001750 00000027762 12566241317 024112  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Cookies 3"
.TH HTTP::Cookies 3 "2012-02-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Cookies \- HTTP cookie jars
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use HTTP::Cookies;
\&  $cookie_jar = HTTP::Cookies\->new(
\&    file => "$ENV{\*(AqHOME\*(Aq}/lwp_cookies.dat",
\&    autosave => 1,
\&  );
\&
\&  use LWP;
\&  my $browser = LWP::UserAgent\->new;
\&  $browser\->cookie_jar($cookie_jar);
.Ve
.PP
Or for an empty and temporary cookie jar:
.PP
.Vb 3
\&  use LWP;
\&  my $browser = LWP::UserAgent\->new;
\&  $browser\->cookie_jar( {} );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is for objects that represent a \*(L"cookie jar\*(R" \*(-- that is, a
database of all the \s-1HTTP\s0 cookies that a given LWP::UserAgent object
knows about.
.PP
Cookies are a general mechanism which server side connections can use
to both store and retrieve information on the client side of the
connection.  For more information about cookies refer to
<URL:http://curl.haxx.se/rfc/cookie_spec.html> and
<URL:http://www.cookiecentral.com/>.  This module also implements the
new style cookies described in \fI\s-1RFC 2965\s0\fR.
The two variants of cookies are supposed to be able to coexist happily.
.PP
Instances of the class \fIHTTP::Cookies\fR are able to store a collection
of Set\-Cookie2: and Set-Cookie: headers and are able to use this
information to initialize Cookie-headers in \fIHTTP::Request\fR objects.
The state of a \fIHTTP::Cookies\fR object can be saved in and restored from
files.
.SH "METHODS"
.IX Header "METHODS"
The following methods are provided:
.ie n .IP "$cookie_jar = HTTP::Cookies\->new" 4
.el .IP "\f(CW$cookie_jar\fR = HTTP::Cookies\->new" 4
.IX Item "$cookie_jar = HTTP::Cookies->new"
The constructor takes hash style parameters.  The following
parameters are recognized:
.Sp
.Vb 4
\&  file:            name of the file to restore cookies from and save cookies to
\&  autosave:        save during destruction (bool)
\&  ignore_discard:  save even cookies that are requested to be discarded (bool)
\&  hide_cookie2:    do not add Cookie2 header to requests
.Ve
.Sp
Future parameters might include (not yet implemented):
.Sp
.Vb 3
\&  max_cookies               300
\&  max_cookies_per_domain    20
\&  max_cookie_size           4096
\&
\&  no_cookies   list of domain names that we never return cookies to
.Ve
.ie n .IP "$cookie_jar\->add_cookie_header( $request )" 4
.el .IP "\f(CW$cookie_jar\fR\->add_cookie_header( \f(CW$request\fR )" 4
.IX Item "$cookie_jar->add_cookie_header( $request )"
The \fIadd_cookie_header()\fR method will set the appropriate Cookie:\-header
for the \fIHTTP::Request\fR object given as argument.  The \f(CW$request\fR must
have a valid url attribute before this method is called.
.ie n .IP "$cookie_jar\->extract_cookies( $response )" 4
.el .IP "\f(CW$cookie_jar\fR\->extract_cookies( \f(CW$response\fR )" 4
.IX Item "$cookie_jar->extract_cookies( $response )"
The \fIextract_cookies()\fR method will look for Set-Cookie: and
Set\-Cookie2: headers in the \fIHTTP::Response\fR object passed as
argument.  Any of these headers that are found are used to update
the state of the \f(CW$cookie_jar\fR.
.ie n .IP "$cookie_jar\->set_cookie( $version, $key, $val, $path, $domain, $port, $path_spec, $secure, $maxage, $discard, \e%rest )" 4
.el .IP "\f(CW$cookie_jar\fR\->set_cookie( \f(CW$version\fR, \f(CW$key\fR, \f(CW$val\fR, \f(CW$path\fR, \f(CW$domain\fR, \f(CW$port\fR, \f(CW$path_spec\fR, \f(CW$secure\fR, \f(CW$maxage\fR, \f(CW$discard\fR, \e%rest )" 4
.IX Item "$cookie_jar->set_cookie( $version, $key, $val, $path, $domain, $port, $path_spec, $secure, $maxage, $discard, %rest )"
The \fIset_cookie()\fR method updates the state of the \f(CW$cookie_jar\fR.  The
\&\f(CW$key\fR, \f(CW$val\fR, \f(CW$domain\fR, \f(CW$port\fR and \f(CW$path\fR arguments are strings.  The
\&\f(CW$path_spec\fR, \f(CW$secure\fR, \f(CW$discard\fR arguments are boolean values. The \f(CW$maxage\fR
value is a number indicating number of seconds that this cookie will
live.  A value <= 0 will delete this cookie.  \f(CW%rest\fR defines
various other attributes like \*(L"Comment\*(R" and \*(L"CommentURL\*(R".
.ie n .IP "$cookie_jar\->save" 4
.el .IP "\f(CW$cookie_jar\fR\->save" 4
.IX Item "$cookie_jar->save"
.PD 0
.ie n .IP "$cookie_jar\->save( $file )" 4
.el .IP "\f(CW$cookie_jar\fR\->save( \f(CW$file\fR )" 4
.IX Item "$cookie_jar->save( $file )"
.PD
This method file saves the state of the \f(CW$cookie_jar\fR to a file.
The state can then be restored later using the \fIload()\fR method.  If a
filename is not specified we will use the name specified during
construction.  If the attribute \fIignore_discard\fR is set, then we
will even save cookies that are marked to be discarded.
.Sp
The default is to save a sequence of \*(L"Set\-Cookie3\*(R" lines.
\&\*(L"Set\-Cookie3\*(R" is a proprietary \s-1LWP\s0 format, not known to be compatible
with any browser.  The \fIHTTP::Cookies::Netscape\fR sub-class can
be used to save in a format compatible with Netscape.
.ie n .IP "$cookie_jar\->load" 4
.el .IP "\f(CW$cookie_jar\fR\->load" 4
.IX Item "$cookie_jar->load"
.PD 0
.ie n .IP "$cookie_jar\->load( $file )" 4
.el .IP "\f(CW$cookie_jar\fR\->load( \f(CW$file\fR )" 4
.IX Item "$cookie_jar->load( $file )"
.PD
This method reads the cookies from the file and adds them to the
\&\f(CW$cookie_jar\fR.  The file must be in the format written by the \fIsave()\fR
method.
.ie n .IP "$cookie_jar\->revert" 4
.el .IP "\f(CW$cookie_jar\fR\->revert" 4
.IX Item "$cookie_jar->revert"
This method empties the \f(CW$cookie_jar\fR and re-loads the \f(CW$cookie_jar\fR
from the last save file.
.ie n .IP "$cookie_jar\->clear" 4
.el .IP "\f(CW$cookie_jar\fR\->clear" 4
.IX Item "$cookie_jar->clear"
.PD 0
.ie n .IP "$cookie_jar\->clear( $domain )" 4
.el .IP "\f(CW$cookie_jar\fR\->clear( \f(CW$domain\fR )" 4
.IX Item "$cookie_jar->clear( $domain )"
.ie n .IP "$cookie_jar\->clear( $domain, $path )" 4
.el .IP "\f(CW$cookie_jar\fR\->clear( \f(CW$domain\fR, \f(CW$path\fR )" 4
.IX Item "$cookie_jar->clear( $domain, $path )"
.ie n .IP "$cookie_jar\->clear( $domain, $path, $key )" 4
.el .IP "\f(CW$cookie_jar\fR\->clear( \f(CW$domain\fR, \f(CW$path\fR, \f(CW$key\fR )" 4
.IX Item "$cookie_jar->clear( $domain, $path, $key )"
.PD
Invoking this method without arguments will empty the whole
\&\f(CW$cookie_jar\fR.  If given a single argument only cookies belonging to
that domain will be removed.  If given two arguments, cookies
belonging to the specified path within that domain are removed.  If
given three arguments, then the cookie with the specified key, path
and domain is removed.
.ie n .IP "$cookie_jar\->clear_temporary_cookies" 4
.el .IP "\f(CW$cookie_jar\fR\->clear_temporary_cookies" 4
.IX Item "$cookie_jar->clear_temporary_cookies"
Discard all temporary cookies. Scans for all cookies in the jar
with either no expire field or a true \f(CW\*(C`discard\*(C'\fR flag. To be
called when the user agent shuts down according to \s-1RFC 2965.\s0
.ie n .IP "$cookie_jar\->scan( \e&callback )" 4
.el .IP "\f(CW$cookie_jar\fR\->scan( \e&callback )" 4
.IX Item "$cookie_jar->scan( &callback )"
The argument is a subroutine that will be invoked for each cookie
stored in the \f(CW$cookie_jar\fR.  The subroutine will be invoked with
the following arguments:
.Sp
.Vb 11
\&  0  version
\&  1  key
\&  2  val
\&  3  path
\&  4  domain
\&  5  port
\&  6  path_spec
\&  7  secure
\&  8  expires
\&  9  discard
\& 10  hash
.Ve
.ie n .IP "$cookie_jar\->as_string" 4
.el .IP "\f(CW$cookie_jar\fR\->as_string" 4
.IX Item "$cookie_jar->as_string"
.PD 0
.ie n .IP "$cookie_jar\->as_string( $skip_discardables )" 4
.el .IP "\f(CW$cookie_jar\fR\->as_string( \f(CW$skip_discardables\fR )" 4
.IX Item "$cookie_jar->as_string( $skip_discardables )"
.PD
The \fIas_string()\fR method will return the state of the \f(CW$cookie_jar\fR
represented as a sequence of \*(L"Set\-Cookie3\*(R" header lines separated by
\&\*(L"\en\*(R".  If \f(CW$skip_discardables\fR is \s-1TRUE,\s0 it will not return lines for
cookies with the \fIDiscard\fR attribute.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTTP::Cookies::Netscape, HTTP::Cookies::Microsoft
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1997\-2002 Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Cookies::Microsoft.3pm                 0100644 0001750 0001750 00000013477 12566241317 025646  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Cookies::Microsoft 3"
.TH HTTP::Cookies::Microsoft 3 "2012-02-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Cookies::Microsoft \- access to Microsoft cookies files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\& use LWP;
\& use HTTP::Cookies::Microsoft;
\& use Win32::TieRegistry(Delimiter => "/");
\& my $cookies_dir = $Registry\->
\&      {"CUser/Software/Microsoft/Windows/CurrentVersion/Explorer/Shell Folders/Cookies"};
\&
\& $cookie_jar = HTTP::Cookies::Microsoft\->new(
\&                   file     => "$cookies_dir\e\eindex.dat",
\&                   \*(Aqdelayload\*(Aq => 1,
\&               );
\& my $browser = LWP::UserAgent\->new;
\& $browser\->cookie_jar( $cookie_jar );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of \f(CW\*(C`HTTP::Cookies\*(C'\fR which
loads Microsoft Internet Explorer 5.x and 6.x for Windows (\s-1MSIE\s0)
cookie files.
.PP
See the documentation for HTTP::Cookies.
.SH "METHODS"
.IX Header "METHODS"
The following methods are provided:
.ie n .IP "$cookie_jar = HTTP::Cookies::Microsoft\->new;" 4
.el .IP "\f(CW$cookie_jar\fR = HTTP::Cookies::Microsoft\->new;" 4
.IX Item "$cookie_jar = HTTP::Cookies::Microsoft->new;"
The constructor takes hash style parameters. In addition
to the regular HTTP::Cookies parameters, HTTP::Cookies::Microsoft
recognizes the following:
.Sp
.Vb 5
\&  delayload:       delay loading of cookie data until a request
\&                   is actually made. This results in faster
\&                   runtime unless you use most of the cookies
\&                   since only the domain\*(Aqs cookie data
\&                   is loaded on demand.
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
Please note that the code \s-1DOESN\s0'T support saving to the \s-1MSIE\s0
cookie file format.
.SH "AUTHOR"
.IX Header "AUTHOR"
Johnny Lee <typo_pl@hotmail.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002 Johnny Lee
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Cookies::Microsoft5.16.3pm             0100644 0001750 0001750 00000013156 12566241317 026152  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Cookies::Microsoft 3"
.TH HTTP::Cookies::Microsoft 3 "2012-02-15" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Cookies::Microsoft \- access to Microsoft cookies files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\& use LWP;
\& use HTTP::Cookies::Microsoft;
\& use Win32::TieRegistry(Delimiter => "/");
\& my $cookies_dir = $Registry\->
\&      {"CUser/Software/Microsoft/Windows/CurrentVersion/Explorer/Shell Folders/Cookies"};
\&
\& $cookie_jar = HTTP::Cookies::Microsoft\->new(
\&                   file     => "$cookies_dir\e\eindex.dat",
\&                   \*(Aqdelayload\*(Aq => 1,
\&               );
\& my $browser = LWP::UserAgent\->new;
\& $browser\->cookie_jar( $cookie_jar );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of \f(CW\*(C`HTTP::Cookies\*(C'\fR which
loads Microsoft Internet Explorer 5.x and 6.x for Windows (\s-1MSIE\s0)
cookie files.
.PP
See the documentation for HTTP::Cookies.
.SH "METHODS"
.IX Header "METHODS"
The following methods are provided:
.ie n .IP "$cookie_jar = HTTP::Cookies::Microsoft\->new;" 4
.el .IP "\f(CW$cookie_jar\fR = HTTP::Cookies::Microsoft\->new;" 4
.IX Item "$cookie_jar = HTTP::Cookies::Microsoft->new;"
The constructor takes hash style parameters. In addition
to the regular HTTP::Cookies parameters, HTTP::Cookies::Microsoft
recognizes the following:
.Sp
.Vb 5
\&  delayload:       delay loading of cookie data until a request
\&                   is actually made. This results in faster
\&                   runtime unless you use most of the cookies
\&                   since only the domain\*(Aqs cookie data
\&                   is loaded on demand.
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
Please note that the code \s-1DOESN\s0'T support saving to the \s-1MSIE\s0
cookie file format.
.SH "AUTHOR"
.IX Header "AUTHOR"
Johnny Lee <typo_pl@hotmail.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002 Johnny Lee
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Cookies::Microsoft5.18.3pm             0100644 0001750 0001750 00000013477 12566241317 026162  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Cookies::Microsoft 3"
.TH HTTP::Cookies::Microsoft 3 "2012-02-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Cookies::Microsoft \- access to Microsoft cookies files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\& use LWP;
\& use HTTP::Cookies::Microsoft;
\& use Win32::TieRegistry(Delimiter => "/");
\& my $cookies_dir = $Registry\->
\&      {"CUser/Software/Microsoft/Windows/CurrentVersion/Explorer/Shell Folders/Cookies"};
\&
\& $cookie_jar = HTTP::Cookies::Microsoft\->new(
\&                   file     => "$cookies_dir\e\eindex.dat",
\&                   \*(Aqdelayload\*(Aq => 1,
\&               );
\& my $browser = LWP::UserAgent\->new;
\& $browser\->cookie_jar( $cookie_jar );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of \f(CW\*(C`HTTP::Cookies\*(C'\fR which
loads Microsoft Internet Explorer 5.x and 6.x for Windows (\s-1MSIE\s0)
cookie files.
.PP
See the documentation for HTTP::Cookies.
.SH "METHODS"
.IX Header "METHODS"
The following methods are provided:
.ie n .IP "$cookie_jar = HTTP::Cookies::Microsoft\->new;" 4
.el .IP "\f(CW$cookie_jar\fR = HTTP::Cookies::Microsoft\->new;" 4
.IX Item "$cookie_jar = HTTP::Cookies::Microsoft->new;"
The constructor takes hash style parameters. In addition
to the regular HTTP::Cookies parameters, HTTP::Cookies::Microsoft
recognizes the following:
.Sp
.Vb 5
\&  delayload:       delay loading of cookie data until a request
\&                   is actually made. This results in faster
\&                   runtime unless you use most of the cookies
\&                   since only the domain\*(Aqs cookie data
\&                   is loaded on demand.
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
Please note that the code \s-1DOESN\s0'T support saving to the \s-1MSIE\s0
cookie file format.
.SH "AUTHOR"
.IX Header "AUTHOR"
Johnny Lee <typo_pl@hotmail.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002 Johnny Lee
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Cookies::Netscape.3pm                  0100644 0001750 0001750 00000012076 12566241317 025435  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Cookies::Netscape 3"
.TH HTTP::Cookies::Netscape 3 "2012-02-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Cookies::Netscape \- access to Netscape cookies files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\& use LWP;
\& use HTTP::Cookies::Netscape;
\& $cookie_jar = HTTP::Cookies::Netscape\->new(
\&   file => "c:/program files/netscape/users/ZombieCharity/cookies.txt",
\& );
\& my $browser = LWP::UserAgent\->new;
\& $browser\->cookie_jar( $cookie_jar );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of \f(CW\*(C`HTTP::Cookies\*(C'\fR that reads (and optionally
writes) Netscape/Mozilla cookie files.
.PP
See the documentation for HTTP::Cookies.
.SH "CAVEATS"
.IX Header "CAVEATS"
Please note that the Netscape/Mozilla cookie file format can't store
all the information available in the Set\-Cookie2 headers, so you will
probably lose some information if you save in this format.
.PP
At time of writing, this module seems to work fine with Mozilla      
Phoenix/Firebird.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTTP::Cookies::Microsoft
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2003 Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Cookies::Netscape5.16.3pm              0100644 0001750 0001750 00000011555 12566241317 025750  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Cookies::Netscape 3"
.TH HTTP::Cookies::Netscape 3 "2012-02-15" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Cookies::Netscape \- access to Netscape cookies files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\& use LWP;
\& use HTTP::Cookies::Netscape;
\& $cookie_jar = HTTP::Cookies::Netscape\->new(
\&   file => "c:/program files/netscape/users/ZombieCharity/cookies.txt",
\& );
\& my $browser = LWP::UserAgent\->new;
\& $browser\->cookie_jar( $cookie_jar );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of \f(CW\*(C`HTTP::Cookies\*(C'\fR that reads (and optionally
writes) Netscape/Mozilla cookie files.
.PP
See the documentation for HTTP::Cookies.
.SH "CAVEATS"
.IX Header "CAVEATS"
Please note that the Netscape/Mozilla cookie file format can't store
all the information available in the Set\-Cookie2 headers, so you will
probably lose some information if you save in this format.
.PP
At time of writing, this module seems to work fine with Mozilla      
Phoenix/Firebird.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTTP::Cookies::Microsoft
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2003 Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Cookies::Netscape5.18.3pm              0100644 0001750 0001750 00000012076 12566241317 025751  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Cookies::Netscape 3"
.TH HTTP::Cookies::Netscape 3 "2012-02-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Cookies::Netscape \- access to Netscape cookies files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\& use LWP;
\& use HTTP::Cookies::Netscape;
\& $cookie_jar = HTTP::Cookies::Netscape\->new(
\&   file => "c:/program files/netscape/users/ZombieCharity/cookies.txt",
\& );
\& my $browser = LWP::UserAgent\->new;
\& $browser\->cookie_jar( $cookie_jar );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a subclass of \f(CW\*(C`HTTP::Cookies\*(C'\fR that reads (and optionally
writes) Netscape/Mozilla cookie files.
.PP
See the documentation for HTTP::Cookies.
.SH "CAVEATS"
.IX Header "CAVEATS"
Please note that the Netscape/Mozilla cookie file format can't store
all the information available in the Set\-Cookie2 headers, so you will
probably lose some information if you save in this format.
.PP
At time of writing, this module seems to work fine with Mozilla      
Phoenix/Firebird.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTTP::Cookies::Microsoft
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2003 Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Daemon.3pm                             0100644 0001750 0001750 00000044253 12566241321 023372  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Daemon 3"
.TH HTTP::Daemon 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Daemon \- a simple http server class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use HTTP::Daemon;
\&  use HTTP::Status;
\&
\&  my $d = HTTP::Daemon\->new || die;
\&  print "Please contact me at: <URL:", $d\->url, ">\en";
\&  while (my $c = $d\->accept) {
\&      while (my $r = $c\->get_request) {
\&          if ($r\->method eq \*(AqGET\*(Aq and $r\->uri\->path eq "/xyzzy") {
\&              # remember, this is *not* recommended practice :\-)
\&              $c\->send_file_response("/etc/passwd");
\&          }
\&          else {
\&              $c\->send_error(RC_FORBIDDEN)
\&          }
\&      }
\&      $c\->close;
\&      undef($c);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Instances of the \f(CW\*(C`HTTP::Daemon\*(C'\fR class are \s-1HTTP/1.1\s0 servers that
listen on a socket for incoming requests. The \f(CW\*(C`HTTP::Daemon\*(C'\fR is a
subclass of \f(CW\*(C`IO::Socket::INET\*(C'\fR, so you can perform socket operations
directly on it too.
.PP
The \fIaccept()\fR method will return when a connection from a client is
available.  The returned value will be an \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR
object which is another \f(CW\*(C`IO::Socket::INET\*(C'\fR subclass.  Calling the
\&\fIget_request()\fR method on this object will read data from the client and
return an \f(CW\*(C`HTTP::Request\*(C'\fR object.  The ClientConn object also provide
methods to send back various responses.
.PP
This \s-1HTTP\s0 daemon does not \fIfork\fR\|(2) for you.  Your application, i.e. the
user of the \f(CW\*(C`HTTP::Daemon\*(C'\fR is responsible for forking if that is
desirable.  Also note that the user is responsible for generating
responses that conform to the \s-1HTTP/1.1\s0 protocol.
.PP
The following methods of \f(CW\*(C`HTTP::Daemon\*(C'\fR are new (or enhanced) relative
to the \f(CW\*(C`IO::Socket::INET\*(C'\fR base class:
.ie n .IP "$d = HTTP::Daemon\->new" 4
.el .IP "\f(CW$d\fR = HTTP::Daemon\->new" 4
.IX Item "$d = HTTP::Daemon->new"
.PD 0
.ie n .IP "$d = HTTP::Daemon\->new( %opts )" 4
.el .IP "\f(CW$d\fR = HTTP::Daemon\->new( \f(CW%opts\fR )" 4
.IX Item "$d = HTTP::Daemon->new( %opts )"
.PD
The constructor method takes the same arguments as the
\&\f(CW\*(C`IO::Socket::INET\*(C'\fR constructor, but unlike its base class it can also
be called without any arguments.  The daemon will then set up a listen
queue of 5 connections and allocate some random port number.
.Sp
A server that wants to bind to some specific address on the standard
\&\s-1HTTP\s0 port will be constructed like this:
.Sp
.Vb 4
\&  $d = HTTP::Daemon\->new(
\&           LocalAddr => \*(Aqwww.thisplace.com\*(Aq,
\&           LocalPort => 80,
\&       );
.Ve
.Sp
See IO::Socket::INET for a description of other arguments that can
be used configure the daemon during construction.
.ie n .IP "$c = $d\->accept" 4
.el .IP "\f(CW$c\fR = \f(CW$d\fR\->accept" 4
.IX Item "$c = $d->accept"
.PD 0
.ie n .IP "$c = $d\->accept( $pkg )" 4
.el .IP "\f(CW$c\fR = \f(CW$d\fR\->accept( \f(CW$pkg\fR )" 4
.IX Item "$c = $d->accept( $pkg )"
.ie n .IP "($c, $peer_addr) = $d\->accept" 4
.el .IP "($c, \f(CW$peer_addr\fR) = \f(CW$d\fR\->accept" 4
.IX Item "($c, $peer_addr) = $d->accept"
.PD
This method works the same the one provided by the base class, but it
returns an \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR reference by default.  If a
package name is provided as argument, then the returned object will be
blessed into the given class.  It is probably a good idea to make that
class a subclass of \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR.
.Sp
The accept method will return \f(CW\*(C`undef\*(C'\fR if timeouts have been enabled
and no connection is made within the given time.  The \fItimeout()\fR method
is described in IO::Socket.
.Sp
In list context both the client object and the peer address will be
returned; see the description of the accept method IO::Socket for
details.
.ie n .IP "$d\->url" 4
.el .IP "\f(CW$d\fR\->url" 4
.IX Item "$d->url"
Returns a \s-1URL\s0 string that can be used to access the server root.
.ie n .IP "$d\->product_tokens" 4
.el .IP "\f(CW$d\fR\->product_tokens" 4
.IX Item "$d->product_tokens"
Returns the name that this server will use to identify itself.  This
is the string that is sent with the \f(CW\*(C`Server\*(C'\fR response header.  The
main reason to have this method is that subclasses can override it if
they want to use another product name.
.Sp
The default is the string \*(L"libwww\-perl\-daemon/#.##\*(R" where \*(L"#.##\*(R" is
replaced with the version number of this module.
.PP
The \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR is a \f(CW\*(C`IO::Socket::INET\*(C'\fR
subclass. Instances of this class are returned by the \fIaccept()\fR method
of \f(CW\*(C`HTTP::Daemon\*(C'\fR.  The following methods are provided:
.ie n .IP "$c\->get_request" 4
.el .IP "\f(CW$c\fR\->get_request" 4
.IX Item "$c->get_request"
.PD 0
.ie n .IP "$c\->get_request( $headers_only )" 4
.el .IP "\f(CW$c\fR\->get_request( \f(CW$headers_only\fR )" 4
.IX Item "$c->get_request( $headers_only )"
.PD
This method reads data from the client and turns it into an
\&\f(CW\*(C`HTTP::Request\*(C'\fR object which is returned.  It returns \f(CW\*(C`undef\*(C'\fR
if reading fails.  If it fails, then the \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR
object ($c) should be discarded, and you should not try call this
method again on it.  The \f(CW$c\fR\->reason method might give you some
information about why \f(CW$c\fR\->get_request failed.
.Sp
The \fIget_request()\fR method will normally not return until the whole
request has been received from the client.  This might not be what you
want if the request is an upload of a large file (and with chunked
transfer encoding \s-1HTTP\s0 can even support infinite request messages \-
uploading live audio for instance).  If you pass a \s-1TRUE\s0 value as the
\&\f(CW$headers_only\fR argument, then \fIget_request()\fR will return immediately
after parsing the request headers and you are responsible for reading
the rest of the request content.  If you are going to call
\&\f(CW$c\fR\->get_request again on the same connection you better read the
correct number of bytes.
.ie n .IP "$c\->read_buffer" 4
.el .IP "\f(CW$c\fR\->read_buffer" 4
.IX Item "$c->read_buffer"
.PD 0
.ie n .IP "$c\->read_buffer( $new_value )" 4
.el .IP "\f(CW$c\fR\->read_buffer( \f(CW$new_value\fR )" 4
.IX Item "$c->read_buffer( $new_value )"
.PD
Bytes read by \f(CW$c\fR\->get_request, but not used are placed in the \fIread
buffer\fR.  The next time \f(CW$c\fR\->get_request is called it will consume the
bytes in this buffer before reading more data from the network
connection itself.  The read buffer is invalid after \f(CW$c\fR\->get_request
has failed.
.Sp
If you handle the reading of the request content yourself you need to
empty this buffer before you read more and you need to place
unconsumed bytes here.  You also need this buffer if you implement
services like \fI101 Switching Protocols\fR.
.Sp
This method always returns the old buffer content and can optionally
replace the buffer content if you pass it an argument.
.ie n .IP "$c\->reason" 4
.el .IP "\f(CW$c\fR\->reason" 4
.IX Item "$c->reason"
When \f(CW$c\fR\->get_request returns \f(CW\*(C`undef\*(C'\fR you can obtain a short string
describing why it happened by calling \f(CW$c\fR\->reason.
.ie n .IP "$c\->proto_ge( $proto )" 4
.el .IP "\f(CW$c\fR\->proto_ge( \f(CW$proto\fR )" 4
.IX Item "$c->proto_ge( $proto )"
Return \s-1TRUE\s0 if the client announced a protocol with version number
greater or equal to the given argument.  The \f(CW$proto\fR argument can be a
string like \*(L"\s-1HTTP/1.1\*(R"\s0 or just \*(L"1.1\*(R".
.ie n .IP "$c\->antique_client" 4
.el .IP "\f(CW$c\fR\->antique_client" 4
.IX Item "$c->antique_client"
Return \s-1TRUE\s0 if the client speaks the \s-1HTTP/0.9\s0 protocol.  No status
code and no headers should be returned to such a client.  This should
be the same as !$c\->proto_ge(\*(L"\s-1HTTP/1.0\*(R"\s0).
.ie n .IP "$c\->head_request" 4
.el .IP "\f(CW$c\fR\->head_request" 4
.IX Item "$c->head_request"
Return \s-1TRUE\s0 if the last request was a \f(CW\*(C`HEAD\*(C'\fR request.  No content
body must be generated for these requests.
.ie n .IP "$c\->force_last_request" 4
.el .IP "\f(CW$c\fR\->force_last_request" 4
.IX Item "$c->force_last_request"
Make sure that \f(CW$c\fR\->get_request will not try to read more requests off
this connection.  If you generate a response that is not self
delimiting, then you should signal this fact by calling this method.
.Sp
This attribute is turned on automatically if the client announces
protocol \s-1HTTP/1.0\s0 or worse and does not include a \*(L"Connection:
Keep-Alive\*(R" header.  It is also turned on automatically when \s-1HTTP/1.1\s0
or better clients send the \*(L"Connection: close\*(R" request header.
.ie n .IP "$c\->send_status_line" 4
.el .IP "\f(CW$c\fR\->send_status_line" 4
.IX Item "$c->send_status_line"
.PD 0
.ie n .IP "$c\->send_status_line( $code )" 4
.el .IP "\f(CW$c\fR\->send_status_line( \f(CW$code\fR )" 4
.IX Item "$c->send_status_line( $code )"
.ie n .IP "$c\->send_status_line( $code, $mess )" 4
.el .IP "\f(CW$c\fR\->send_status_line( \f(CW$code\fR, \f(CW$mess\fR )" 4
.IX Item "$c->send_status_line( $code, $mess )"
.ie n .IP "$c\->send_status_line( $code, $mess, $proto )" 4
.el .IP "\f(CW$c\fR\->send_status_line( \f(CW$code\fR, \f(CW$mess\fR, \f(CW$proto\fR )" 4
.IX Item "$c->send_status_line( $code, $mess, $proto )"
.PD
Send the status line back to the client.  If \f(CW$code\fR is omitted 200 is
assumed.  If \f(CW$mess\fR is omitted, then a message corresponding to \f(CW$code\fR
is inserted.  If \f(CW$proto\fR is missing the content of the
\&\f(CW$HTTP::Daemon::PROTO\fR variable is used.
.ie n .IP "$c\->send_crlf" 4
.el .IP "\f(CW$c\fR\->send_crlf" 4
.IX Item "$c->send_crlf"
Send the \s-1CRLF\s0 sequence to the client.
.ie n .IP "$c\->send_basic_header" 4
.el .IP "\f(CW$c\fR\->send_basic_header" 4
.IX Item "$c->send_basic_header"
.PD 0
.ie n .IP "$c\->send_basic_header( $code )" 4
.el .IP "\f(CW$c\fR\->send_basic_header( \f(CW$code\fR )" 4
.IX Item "$c->send_basic_header( $code )"
.ie n .IP "$c\->send_basic_header( $code, $mess )" 4
.el .IP "\f(CW$c\fR\->send_basic_header( \f(CW$code\fR, \f(CW$mess\fR )" 4
.IX Item "$c->send_basic_header( $code, $mess )"
.ie n .IP "$c\->send_basic_header( $code, $mess, $proto )" 4
.el .IP "\f(CW$c\fR\->send_basic_header( \f(CW$code\fR, \f(CW$mess\fR, \f(CW$proto\fR )" 4
.IX Item "$c->send_basic_header( $code, $mess, $proto )"
.PD
Send the status line and the \*(L"Date:\*(R" and \*(L"Server:\*(R" headers back to
the client.  This header is assumed to be continued and does not end
with an empty \s-1CRLF\s0 line.
.Sp
See the description of \fIsend_status_line()\fR for the description of the
accepted arguments.
.ie n .IP "$c\->send_header( $field, $value )" 4
.el .IP "\f(CW$c\fR\->send_header( \f(CW$field\fR, \f(CW$value\fR )" 4
.IX Item "$c->send_header( $field, $value )"
.PD 0
.ie n .IP "$c\->send_header( $field1, $value1, $field2, $value2, ... )" 4
.el .IP "\f(CW$c\fR\->send_header( \f(CW$field1\fR, \f(CW$value1\fR, \f(CW$field2\fR, \f(CW$value2\fR, ... )" 4
.IX Item "$c->send_header( $field1, $value1, $field2, $value2, ... )"
.PD
Send one or more header lines.
.ie n .IP "$c\->send_response( $res )" 4
.el .IP "\f(CW$c\fR\->send_response( \f(CW$res\fR )" 4
.IX Item "$c->send_response( $res )"
Write a \f(CW\*(C`HTTP::Response\*(C'\fR object to the
client as a response.  We try hard to make sure that the response is
self delimiting so that the connection can stay persistent for further
request/response exchanges.
.Sp
The content attribute of the \f(CW\*(C`HTTP::Response\*(C'\fR object can be a normal
string or a subroutine reference.  If it is a subroutine, then
whatever this callback routine returns is written back to the
client as the response content.  The routine will be called until it
return an undefined or empty value.  If the client is \s-1HTTP/1.1\s0 aware
then we will use chunked transfer encoding for the response.
.ie n .IP "$c\->send_redirect( $loc )" 4
.el .IP "\f(CW$c\fR\->send_redirect( \f(CW$loc\fR )" 4
.IX Item "$c->send_redirect( $loc )"
.PD 0
.ie n .IP "$c\->send_redirect( $loc, $code )" 4
.el .IP "\f(CW$c\fR\->send_redirect( \f(CW$loc\fR, \f(CW$code\fR )" 4
.IX Item "$c->send_redirect( $loc, $code )"
.ie n .IP "$c\->send_redirect( $loc, $code, $entity_body )" 4
.el .IP "\f(CW$c\fR\->send_redirect( \f(CW$loc\fR, \f(CW$code\fR, \f(CW$entity_body\fR )" 4
.IX Item "$c->send_redirect( $loc, $code, $entity_body )"
.PD
Send a redirect response back to the client.  The location ($loc) can
be an absolute or relative \s-1URL.\s0 The \f(CW$code\fR must be one the redirect
status codes, and defaults to \*(L"301 Moved Permanently\*(R"
.ie n .IP "$c\->send_error" 4
.el .IP "\f(CW$c\fR\->send_error" 4
.IX Item "$c->send_error"
.PD 0
.ie n .IP "$c\->send_error( $code )" 4
.el .IP "\f(CW$c\fR\->send_error( \f(CW$code\fR )" 4
.IX Item "$c->send_error( $code )"
.ie n .IP "$c\->send_error( $code, $error_message )" 4
.el .IP "\f(CW$c\fR\->send_error( \f(CW$code\fR, \f(CW$error_message\fR )" 4
.IX Item "$c->send_error( $code, $error_message )"
.PD
Send an error response back to the client.  If the \f(CW$code\fR is missing a
\&\*(L"Bad Request\*(R" error is reported.  The \f(CW$error_message\fR is a string that
is incorporated in the body of the \s-1HTML\s0 entity body.
.ie n .IP "$c\->send_file_response( $filename )" 4
.el .IP "\f(CW$c\fR\->send_file_response( \f(CW$filename\fR )" 4
.IX Item "$c->send_file_response( $filename )"
Send back a response with the specified \f(CW$filename\fR as content.  If the
file is a directory we try to generate an \s-1HTML\s0 index of it.
.ie n .IP "$c\->send_file( $filename )" 4
.el .IP "\f(CW$c\fR\->send_file( \f(CW$filename\fR )" 4
.IX Item "$c->send_file( $filename )"
.PD 0
.ie n .IP "$c\->send_file( $fd )" 4
.el .IP "\f(CW$c\fR\->send_file( \f(CW$fd\fR )" 4
.IX Item "$c->send_file( $fd )"
.PD
Copy the file to the client.  The file can be a string (which
will be interpreted as a filename) or a reference to an \f(CW\*(C`IO::Handle\*(C'\fR
or glob.
.ie n .IP "$c\->daemon" 4
.el .IP "\f(CW$c\fR\->daemon" 4
.IX Item "$c->daemon"
Return a reference to the corresponding \f(CW\*(C`HTTP::Daemon\*(C'\fR object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1RFC 2616\s0
.PP
IO::Socket::INET, IO::Socket
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1996\-2003, Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Daemon5.16.3pm                         0100644 0001750 0001750 00000043732 12566241321 023705  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Daemon 3"
.TH HTTP::Daemon 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Daemon \- a simple http server class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use HTTP::Daemon;
\&  use HTTP::Status;
\&
\&  my $d = HTTP::Daemon\->new || die;
\&  print "Please contact me at: <URL:", $d\->url, ">\en";
\&  while (my $c = $d\->accept) {
\&      while (my $r = $c\->get_request) {
\&          if ($r\->method eq \*(AqGET\*(Aq and $r\->uri\->path eq "/xyzzy") {
\&              # remember, this is *not* recommended practice :\-)
\&              $c\->send_file_response("/etc/passwd");
\&          }
\&          else {
\&              $c\->send_error(RC_FORBIDDEN)
\&          }
\&      }
\&      $c\->close;
\&      undef($c);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Instances of the \f(CW\*(C`HTTP::Daemon\*(C'\fR class are \s-1HTTP/1\s0.1 servers that
listen on a socket for incoming requests. The \f(CW\*(C`HTTP::Daemon\*(C'\fR is a
subclass of \f(CW\*(C`IO::Socket::INET\*(C'\fR, so you can perform socket operations
directly on it too.
.PP
The \fIaccept()\fR method will return when a connection from a client is
available.  The returned value will be an \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR
object which is another \f(CW\*(C`IO::Socket::INET\*(C'\fR subclass.  Calling the
\&\fIget_request()\fR method on this object will read data from the client and
return an \f(CW\*(C`HTTP::Request\*(C'\fR object.  The ClientConn object also provide
methods to send back various responses.
.PP
This \s-1HTTP\s0 daemon does not \fIfork\fR\|(2) for you.  Your application, i.e. the
user of the \f(CW\*(C`HTTP::Daemon\*(C'\fR is responsible for forking if that is
desirable.  Also note that the user is responsible for generating
responses that conform to the \s-1HTTP/1\s0.1 protocol.
.PP
The following methods of \f(CW\*(C`HTTP::Daemon\*(C'\fR are new (or enhanced) relative
to the \f(CW\*(C`IO::Socket::INET\*(C'\fR base class:
.ie n .IP "$d = HTTP::Daemon\->new" 4
.el .IP "\f(CW$d\fR = HTTP::Daemon\->new" 4
.IX Item "$d = HTTP::Daemon->new"
.PD 0
.ie n .IP "$d = HTTP::Daemon\->new( %opts )" 4
.el .IP "\f(CW$d\fR = HTTP::Daemon\->new( \f(CW%opts\fR )" 4
.IX Item "$d = HTTP::Daemon->new( %opts )"
.PD
The constructor method takes the same arguments as the
\&\f(CW\*(C`IO::Socket::INET\*(C'\fR constructor, but unlike its base class it can also
be called without any arguments.  The daemon will then set up a listen
queue of 5 connections and allocate some random port number.
.Sp
A server that wants to bind to some specific address on the standard
\&\s-1HTTP\s0 port will be constructed like this:
.Sp
.Vb 4
\&  $d = HTTP::Daemon\->new(
\&           LocalAddr => \*(Aqwww.thisplace.com\*(Aq,
\&           LocalPort => 80,
\&       );
.Ve
.Sp
See IO::Socket::INET for a description of other arguments that can
be used configure the daemon during construction.
.ie n .IP "$c = $d\->accept" 4
.el .IP "\f(CW$c\fR = \f(CW$d\fR\->accept" 4
.IX Item "$c = $d->accept"
.PD 0
.ie n .IP "$c = $d\->accept( $pkg )" 4
.el .IP "\f(CW$c\fR = \f(CW$d\fR\->accept( \f(CW$pkg\fR )" 4
.IX Item "$c = $d->accept( $pkg )"
.ie n .IP "($c, $peer_addr) = $d\->accept" 4
.el .IP "($c, \f(CW$peer_addr\fR) = \f(CW$d\fR\->accept" 4
.IX Item "($c, $peer_addr) = $d->accept"
.PD
This method works the same the one provided by the base class, but it
returns an \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR reference by default.  If a
package name is provided as argument, then the returned object will be
blessed into the given class.  It is probably a good idea to make that
class a subclass of \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR.
.Sp
The accept method will return \f(CW\*(C`undef\*(C'\fR if timeouts have been enabled
and no connection is made within the given time.  The \fItimeout()\fR method
is described in IO::Socket.
.Sp
In list context both the client object and the peer address will be
returned; see the description of the accept method IO::Socket for
details.
.ie n .IP "$d\->url" 4
.el .IP "\f(CW$d\fR\->url" 4
.IX Item "$d->url"
Returns a \s-1URL\s0 string that can be used to access the server root.
.ie n .IP "$d\->product_tokens" 4
.el .IP "\f(CW$d\fR\->product_tokens" 4
.IX Item "$d->product_tokens"
Returns the name that this server will use to identify itself.  This
is the string that is sent with the \f(CW\*(C`Server\*(C'\fR response header.  The
main reason to have this method is that subclasses can override it if
they want to use another product name.
.Sp
The default is the string \*(L"libwww\-perl\-daemon/#.##\*(R" where \*(L"#.##\*(R" is
replaced with the version number of this module.
.PP
The \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR is a \f(CW\*(C`IO::Socket::INET\*(C'\fR
subclass. Instances of this class are returned by the \fIaccept()\fR method
of \f(CW\*(C`HTTP::Daemon\*(C'\fR.  The following methods are provided:
.ie n .IP "$c\->get_request" 4
.el .IP "\f(CW$c\fR\->get_request" 4
.IX Item "$c->get_request"
.PD 0
.ie n .IP "$c\->get_request( $headers_only )" 4
.el .IP "\f(CW$c\fR\->get_request( \f(CW$headers_only\fR )" 4
.IX Item "$c->get_request( $headers_only )"
.PD
This method reads data from the client and turns it into an
\&\f(CW\*(C`HTTP::Request\*(C'\fR object which is returned.  It returns \f(CW\*(C`undef\*(C'\fR
if reading fails.  If it fails, then the \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR
object ($c) should be discarded, and you should not try call this
method again on it.  The \f(CW$c\fR\->reason method might give you some
information about why \f(CW$c\fR\->get_request failed.
.Sp
The \fIget_request()\fR method will normally not return until the whole
request has been received from the client.  This might not be what you
want if the request is an upload of a large file (and with chunked
transfer encoding \s-1HTTP\s0 can even support infinite request messages \-
uploading live audio for instance).  If you pass a \s-1TRUE\s0 value as the
\&\f(CW$headers_only\fR argument, then \fIget_request()\fR will return immediately
after parsing the request headers and you are responsible for reading
the rest of the request content.  If you are going to call
\&\f(CW$c\fR\->get_request again on the same connection you better read the
correct number of bytes.
.ie n .IP "$c\->read_buffer" 4
.el .IP "\f(CW$c\fR\->read_buffer" 4
.IX Item "$c->read_buffer"
.PD 0
.ie n .IP "$c\->read_buffer( $new_value )" 4
.el .IP "\f(CW$c\fR\->read_buffer( \f(CW$new_value\fR )" 4
.IX Item "$c->read_buffer( $new_value )"
.PD
Bytes read by \f(CW$c\fR\->get_request, but not used are placed in the \fIread
buffer\fR.  The next time \f(CW$c\fR\->get_request is called it will consume the
bytes in this buffer before reading more data from the network
connection itself.  The read buffer is invalid after \f(CW$c\fR\->get_request
has failed.
.Sp
If you handle the reading of the request content yourself you need to
empty this buffer before you read more and you need to place
unconsumed bytes here.  You also need this buffer if you implement
services like \fI101 Switching Protocols\fR.
.Sp
This method always returns the old buffer content and can optionally
replace the buffer content if you pass it an argument.
.ie n .IP "$c\->reason" 4
.el .IP "\f(CW$c\fR\->reason" 4
.IX Item "$c->reason"
When \f(CW$c\fR\->get_request returns \f(CW\*(C`undef\*(C'\fR you can obtain a short string
describing why it happened by calling \f(CW$c\fR\->reason.
.ie n .IP "$c\->proto_ge( $proto )" 4
.el .IP "\f(CW$c\fR\->proto_ge( \f(CW$proto\fR )" 4
.IX Item "$c->proto_ge( $proto )"
Return \s-1TRUE\s0 if the client announced a protocol with version number
greater or equal to the given argument.  The \f(CW$proto\fR argument can be a
string like \*(L"\s-1HTTP/1\s0.1\*(R" or just \*(L"1.1\*(R".
.ie n .IP "$c\->antique_client" 4
.el .IP "\f(CW$c\fR\->antique_client" 4
.IX Item "$c->antique_client"
Return \s-1TRUE\s0 if the client speaks the \s-1HTTP/0\s0.9 protocol.  No status
code and no headers should be returned to such a client.  This should
be the same as !$c\->proto_ge(\*(L"\s-1HTTP/1\s0.0\*(R").
.ie n .IP "$c\->head_request" 4
.el .IP "\f(CW$c\fR\->head_request" 4
.IX Item "$c->head_request"
Return \s-1TRUE\s0 if the last request was a \f(CW\*(C`HEAD\*(C'\fR request.  No content
body must be generated for these requests.
.ie n .IP "$c\->force_last_request" 4
.el .IP "\f(CW$c\fR\->force_last_request" 4
.IX Item "$c->force_last_request"
Make sure that \f(CW$c\fR\->get_request will not try to read more requests off
this connection.  If you generate a response that is not self
delimiting, then you should signal this fact by calling this method.
.Sp
This attribute is turned on automatically if the client announces
protocol \s-1HTTP/1\s0.0 or worse and does not include a \*(L"Connection:
Keep-Alive\*(R" header.  It is also turned on automatically when \s-1HTTP/1\s0.1
or better clients send the \*(L"Connection: close\*(R" request header.
.ie n .IP "$c\->send_status_line" 4
.el .IP "\f(CW$c\fR\->send_status_line" 4
.IX Item "$c->send_status_line"
.PD 0
.ie n .IP "$c\->send_status_line( $code )" 4
.el .IP "\f(CW$c\fR\->send_status_line( \f(CW$code\fR )" 4
.IX Item "$c->send_status_line( $code )"
.ie n .IP "$c\->send_status_line( $code, $mess )" 4
.el .IP "\f(CW$c\fR\->send_status_line( \f(CW$code\fR, \f(CW$mess\fR )" 4
.IX Item "$c->send_status_line( $code, $mess )"
.ie n .IP "$c\->send_status_line( $code, $mess, $proto )" 4
.el .IP "\f(CW$c\fR\->send_status_line( \f(CW$code\fR, \f(CW$mess\fR, \f(CW$proto\fR )" 4
.IX Item "$c->send_status_line( $code, $mess, $proto )"
.PD
Send the status line back to the client.  If \f(CW$code\fR is omitted 200 is
assumed.  If \f(CW$mess\fR is omitted, then a message corresponding to \f(CW$code\fR
is inserted.  If \f(CW$proto\fR is missing the content of the
\&\f(CW$HTTP::Daemon::PROTO\fR variable is used.
.ie n .IP "$c\->send_crlf" 4
.el .IP "\f(CW$c\fR\->send_crlf" 4
.IX Item "$c->send_crlf"
Send the \s-1CRLF\s0 sequence to the client.
.ie n .IP "$c\->send_basic_header" 4
.el .IP "\f(CW$c\fR\->send_basic_header" 4
.IX Item "$c->send_basic_header"
.PD 0
.ie n .IP "$c\->send_basic_header( $code )" 4
.el .IP "\f(CW$c\fR\->send_basic_header( \f(CW$code\fR )" 4
.IX Item "$c->send_basic_header( $code )"
.ie n .IP "$c\->send_basic_header( $code, $mess )" 4
.el .IP "\f(CW$c\fR\->send_basic_header( \f(CW$code\fR, \f(CW$mess\fR )" 4
.IX Item "$c->send_basic_header( $code, $mess )"
.ie n .IP "$c\->send_basic_header( $code, $mess, $proto )" 4
.el .IP "\f(CW$c\fR\->send_basic_header( \f(CW$code\fR, \f(CW$mess\fR, \f(CW$proto\fR )" 4
.IX Item "$c->send_basic_header( $code, $mess, $proto )"
.PD
Send the status line and the \*(L"Date:\*(R" and \*(L"Server:\*(R" headers back to
the client.  This header is assumed to be continued and does not end
with an empty \s-1CRLF\s0 line.
.Sp
See the description of \fIsend_status_line()\fR for the description of the
accepted arguments.
.ie n .IP "$c\->send_header( $field, $value )" 4
.el .IP "\f(CW$c\fR\->send_header( \f(CW$field\fR, \f(CW$value\fR )" 4
.IX Item "$c->send_header( $field, $value )"
.PD 0
.ie n .IP "$c\->send_header( $field1, $value1, $field2, $value2, ... )" 4
.el .IP "\f(CW$c\fR\->send_header( \f(CW$field1\fR, \f(CW$value1\fR, \f(CW$field2\fR, \f(CW$value2\fR, ... )" 4
.IX Item "$c->send_header( $field1, $value1, $field2, $value2, ... )"
.PD
Send one or more header lines.
.ie n .IP "$c\->send_response( $res )" 4
.el .IP "\f(CW$c\fR\->send_response( \f(CW$res\fR )" 4
.IX Item "$c->send_response( $res )"
Write a \f(CW\*(C`HTTP::Response\*(C'\fR object to the
client as a response.  We try hard to make sure that the response is
self delimiting so that the connection can stay persistent for further
request/response exchanges.
.Sp
The content attribute of the \f(CW\*(C`HTTP::Response\*(C'\fR object can be a normal
string or a subroutine reference.  If it is a subroutine, then
whatever this callback routine returns is written back to the
client as the response content.  The routine will be called until it
return an undefined or empty value.  If the client is \s-1HTTP/1\s0.1 aware
then we will use chunked transfer encoding for the response.
.ie n .IP "$c\->send_redirect( $loc )" 4
.el .IP "\f(CW$c\fR\->send_redirect( \f(CW$loc\fR )" 4
.IX Item "$c->send_redirect( $loc )"
.PD 0
.ie n .IP "$c\->send_redirect( $loc, $code )" 4
.el .IP "\f(CW$c\fR\->send_redirect( \f(CW$loc\fR, \f(CW$code\fR )" 4
.IX Item "$c->send_redirect( $loc, $code )"
.ie n .IP "$c\->send_redirect( $loc, $code, $entity_body )" 4
.el .IP "\f(CW$c\fR\->send_redirect( \f(CW$loc\fR, \f(CW$code\fR, \f(CW$entity_body\fR )" 4
.IX Item "$c->send_redirect( $loc, $code, $entity_body )"
.PD
Send a redirect response back to the client.  The location ($loc) can
be an absolute or relative \s-1URL\s0. The \f(CW$code\fR must be one the redirect
status codes, and defaults to \*(L"301 Moved Permanently\*(R"
.ie n .IP "$c\->send_error" 4
.el .IP "\f(CW$c\fR\->send_error" 4
.IX Item "$c->send_error"
.PD 0
.ie n .IP "$c\->send_error( $code )" 4
.el .IP "\f(CW$c\fR\->send_error( \f(CW$code\fR )" 4
.IX Item "$c->send_error( $code )"
.ie n .IP "$c\->send_error( $code, $error_message )" 4
.el .IP "\f(CW$c\fR\->send_error( \f(CW$code\fR, \f(CW$error_message\fR )" 4
.IX Item "$c->send_error( $code, $error_message )"
.PD
Send an error response back to the client.  If the \f(CW$code\fR is missing a
\&\*(L"Bad Request\*(R" error is reported.  The \f(CW$error_message\fR is a string that
is incorporated in the body of the \s-1HTML\s0 entity body.
.ie n .IP "$c\->send_file_response( $filename )" 4
.el .IP "\f(CW$c\fR\->send_file_response( \f(CW$filename\fR )" 4
.IX Item "$c->send_file_response( $filename )"
Send back a response with the specified \f(CW$filename\fR as content.  If the
file is a directory we try to generate an \s-1HTML\s0 index of it.
.ie n .IP "$c\->send_file( $filename )" 4
.el .IP "\f(CW$c\fR\->send_file( \f(CW$filename\fR )" 4
.IX Item "$c->send_file( $filename )"
.PD 0
.ie n .IP "$c\->send_file( $fd )" 4
.el .IP "\f(CW$c\fR\->send_file( \f(CW$fd\fR )" 4
.IX Item "$c->send_file( $fd )"
.PD
Copy the file to the client.  The file can be a string (which
will be interpreted as a filename) or a reference to an \f(CW\*(C`IO::Handle\*(C'\fR
or glob.
.ie n .IP "$c\->daemon" 4
.el .IP "\f(CW$c\fR\->daemon" 4
.IX Item "$c->daemon"
Return a reference to the corresponding \f(CW\*(C`HTTP::Daemon\*(C'\fR object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1RFC\s0 2616
.PP
IO::Socket::INET, IO::Socket
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1996\-2003, Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Daemon5.18.3pm                         0100644 0001750 0001750 00000044253 12566241321 023706  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Daemon 3"
.TH HTTP::Daemon 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Daemon \- a simple http server class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use HTTP::Daemon;
\&  use HTTP::Status;
\&
\&  my $d = HTTP::Daemon\->new || die;
\&  print "Please contact me at: <URL:", $d\->url, ">\en";
\&  while (my $c = $d\->accept) {
\&      while (my $r = $c\->get_request) {
\&          if ($r\->method eq \*(AqGET\*(Aq and $r\->uri\->path eq "/xyzzy") {
\&              # remember, this is *not* recommended practice :\-)
\&              $c\->send_file_response("/etc/passwd");
\&          }
\&          else {
\&              $c\->send_error(RC_FORBIDDEN)
\&          }
\&      }
\&      $c\->close;
\&      undef($c);
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Instances of the \f(CW\*(C`HTTP::Daemon\*(C'\fR class are \s-1HTTP/1.1\s0 servers that
listen on a socket for incoming requests. The \f(CW\*(C`HTTP::Daemon\*(C'\fR is a
subclass of \f(CW\*(C`IO::Socket::INET\*(C'\fR, so you can perform socket operations
directly on it too.
.PP
The \fIaccept()\fR method will return when a connection from a client is
available.  The returned value will be an \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR
object which is another \f(CW\*(C`IO::Socket::INET\*(C'\fR subclass.  Calling the
\&\fIget_request()\fR method on this object will read data from the client and
return an \f(CW\*(C`HTTP::Request\*(C'\fR object.  The ClientConn object also provide
methods to send back various responses.
.PP
This \s-1HTTP\s0 daemon does not \fIfork\fR\|(2) for you.  Your application, i.e. the
user of the \f(CW\*(C`HTTP::Daemon\*(C'\fR is responsible for forking if that is
desirable.  Also note that the user is responsible for generating
responses that conform to the \s-1HTTP/1.1\s0 protocol.
.PP
The following methods of \f(CW\*(C`HTTP::Daemon\*(C'\fR are new (or enhanced) relative
to the \f(CW\*(C`IO::Socket::INET\*(C'\fR base class:
.ie n .IP "$d = HTTP::Daemon\->new" 4
.el .IP "\f(CW$d\fR = HTTP::Daemon\->new" 4
.IX Item "$d = HTTP::Daemon->new"
.PD 0
.ie n .IP "$d = HTTP::Daemon\->new( %opts )" 4
.el .IP "\f(CW$d\fR = HTTP::Daemon\->new( \f(CW%opts\fR )" 4
.IX Item "$d = HTTP::Daemon->new( %opts )"
.PD
The constructor method takes the same arguments as the
\&\f(CW\*(C`IO::Socket::INET\*(C'\fR constructor, but unlike its base class it can also
be called without any arguments.  The daemon will then set up a listen
queue of 5 connections and allocate some random port number.
.Sp
A server that wants to bind to some specific address on the standard
\&\s-1HTTP\s0 port will be constructed like this:
.Sp
.Vb 4
\&  $d = HTTP::Daemon\->new(
\&           LocalAddr => \*(Aqwww.thisplace.com\*(Aq,
\&           LocalPort => 80,
\&       );
.Ve
.Sp
See IO::Socket::INET for a description of other arguments that can
be used configure the daemon during construction.
.ie n .IP "$c = $d\->accept" 4
.el .IP "\f(CW$c\fR = \f(CW$d\fR\->accept" 4
.IX Item "$c = $d->accept"
.PD 0
.ie n .IP "$c = $d\->accept( $pkg )" 4
.el .IP "\f(CW$c\fR = \f(CW$d\fR\->accept( \f(CW$pkg\fR )" 4
.IX Item "$c = $d->accept( $pkg )"
.ie n .IP "($c, $peer_addr) = $d\->accept" 4
.el .IP "($c, \f(CW$peer_addr\fR) = \f(CW$d\fR\->accept" 4
.IX Item "($c, $peer_addr) = $d->accept"
.PD
This method works the same the one provided by the base class, but it
returns an \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR reference by default.  If a
package name is provided as argument, then the returned object will be
blessed into the given class.  It is probably a good idea to make that
class a subclass of \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR.
.Sp
The accept method will return \f(CW\*(C`undef\*(C'\fR if timeouts have been enabled
and no connection is made within the given time.  The \fItimeout()\fR method
is described in IO::Socket.
.Sp
In list context both the client object and the peer address will be
returned; see the description of the accept method IO::Socket for
details.
.ie n .IP "$d\->url" 4
.el .IP "\f(CW$d\fR\->url" 4
.IX Item "$d->url"
Returns a \s-1URL\s0 string that can be used to access the server root.
.ie n .IP "$d\->product_tokens" 4
.el .IP "\f(CW$d\fR\->product_tokens" 4
.IX Item "$d->product_tokens"
Returns the name that this server will use to identify itself.  This
is the string that is sent with the \f(CW\*(C`Server\*(C'\fR response header.  The
main reason to have this method is that subclasses can override it if
they want to use another product name.
.Sp
The default is the string \*(L"libwww\-perl\-daemon/#.##\*(R" where \*(L"#.##\*(R" is
replaced with the version number of this module.
.PP
The \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR is a \f(CW\*(C`IO::Socket::INET\*(C'\fR
subclass. Instances of this class are returned by the \fIaccept()\fR method
of \f(CW\*(C`HTTP::Daemon\*(C'\fR.  The following methods are provided:
.ie n .IP "$c\->get_request" 4
.el .IP "\f(CW$c\fR\->get_request" 4
.IX Item "$c->get_request"
.PD 0
.ie n .IP "$c\->get_request( $headers_only )" 4
.el .IP "\f(CW$c\fR\->get_request( \f(CW$headers_only\fR )" 4
.IX Item "$c->get_request( $headers_only )"
.PD
This method reads data from the client and turns it into an
\&\f(CW\*(C`HTTP::Request\*(C'\fR object which is returned.  It returns \f(CW\*(C`undef\*(C'\fR
if reading fails.  If it fails, then the \f(CW\*(C`HTTP::Daemon::ClientConn\*(C'\fR
object ($c) should be discarded, and you should not try call this
method again on it.  The \f(CW$c\fR\->reason method might give you some
information about why \f(CW$c\fR\->get_request failed.
.Sp
The \fIget_request()\fR method will normally not return until the whole
request has been received from the client.  This might not be what you
want if the request is an upload of a large file (and with chunked
transfer encoding \s-1HTTP\s0 can even support infinite request messages \-
uploading live audio for instance).  If you pass a \s-1TRUE\s0 value as the
\&\f(CW$headers_only\fR argument, then \fIget_request()\fR will return immediately
after parsing the request headers and you are responsible for reading
the rest of the request content.  If you are going to call
\&\f(CW$c\fR\->get_request again on the same connection you better read the
correct number of bytes.
.ie n .IP "$c\->read_buffer" 4
.el .IP "\f(CW$c\fR\->read_buffer" 4
.IX Item "$c->read_buffer"
.PD 0
.ie n .IP "$c\->read_buffer( $new_value )" 4
.el .IP "\f(CW$c\fR\->read_buffer( \f(CW$new_value\fR )" 4
.IX Item "$c->read_buffer( $new_value )"
.PD
Bytes read by \f(CW$c\fR\->get_request, but not used are placed in the \fIread
buffer\fR.  The next time \f(CW$c\fR\->get_request is called it will consume the
bytes in this buffer before reading more data from the network
connection itself.  The read buffer is invalid after \f(CW$c\fR\->get_request
has failed.
.Sp
If you handle the reading of the request content yourself you need to
empty this buffer before you read more and you need to place
unconsumed bytes here.  You also need this buffer if you implement
services like \fI101 Switching Protocols\fR.
.Sp
This method always returns the old buffer content and can optionally
replace the buffer content if you pass it an argument.
.ie n .IP "$c\->reason" 4
.el .IP "\f(CW$c\fR\->reason" 4
.IX Item "$c->reason"
When \f(CW$c\fR\->get_request returns \f(CW\*(C`undef\*(C'\fR you can obtain a short string
describing why it happened by calling \f(CW$c\fR\->reason.
.ie n .IP "$c\->proto_ge( $proto )" 4
.el .IP "\f(CW$c\fR\->proto_ge( \f(CW$proto\fR )" 4
.IX Item "$c->proto_ge( $proto )"
Return \s-1TRUE\s0 if the client announced a protocol with version number
greater or equal to the given argument.  The \f(CW$proto\fR argument can be a
string like \*(L"\s-1HTTP/1.1\*(R"\s0 or just \*(L"1.1\*(R".
.ie n .IP "$c\->antique_client" 4
.el .IP "\f(CW$c\fR\->antique_client" 4
.IX Item "$c->antique_client"
Return \s-1TRUE\s0 if the client speaks the \s-1HTTP/0.9\s0 protocol.  No status
code and no headers should be returned to such a client.  This should
be the same as !$c\->proto_ge(\*(L"\s-1HTTP/1.0\*(R"\s0).
.ie n .IP "$c\->head_request" 4
.el .IP "\f(CW$c\fR\->head_request" 4
.IX Item "$c->head_request"
Return \s-1TRUE\s0 if the last request was a \f(CW\*(C`HEAD\*(C'\fR request.  No content
body must be generated for these requests.
.ie n .IP "$c\->force_last_request" 4
.el .IP "\f(CW$c\fR\->force_last_request" 4
.IX Item "$c->force_last_request"
Make sure that \f(CW$c\fR\->get_request will not try to read more requests off
this connection.  If you generate a response that is not self
delimiting, then you should signal this fact by calling this method.
.Sp
This attribute is turned on automatically if the client announces
protocol \s-1HTTP/1.0\s0 or worse and does not include a \*(L"Connection:
Keep-Alive\*(R" header.  It is also turned on automatically when \s-1HTTP/1.1\s0
or better clients send the \*(L"Connection: close\*(R" request header.
.ie n .IP "$c\->send_status_line" 4
.el .IP "\f(CW$c\fR\->send_status_line" 4
.IX Item "$c->send_status_line"
.PD 0
.ie n .IP "$c\->send_status_line( $code )" 4
.el .IP "\f(CW$c\fR\->send_status_line( \f(CW$code\fR )" 4
.IX Item "$c->send_status_line( $code )"
.ie n .IP "$c\->send_status_line( $code, $mess )" 4
.el .IP "\f(CW$c\fR\->send_status_line( \f(CW$code\fR, \f(CW$mess\fR )" 4
.IX Item "$c->send_status_line( $code, $mess )"
.ie n .IP "$c\->send_status_line( $code, $mess, $proto )" 4
.el .IP "\f(CW$c\fR\->send_status_line( \f(CW$code\fR, \f(CW$mess\fR, \f(CW$proto\fR )" 4
.IX Item "$c->send_status_line( $code, $mess, $proto )"
.PD
Send the status line back to the client.  If \f(CW$code\fR is omitted 200 is
assumed.  If \f(CW$mess\fR is omitted, then a message corresponding to \f(CW$code\fR
is inserted.  If \f(CW$proto\fR is missing the content of the
\&\f(CW$HTTP::Daemon::PROTO\fR variable is used.
.ie n .IP "$c\->send_crlf" 4
.el .IP "\f(CW$c\fR\->send_crlf" 4
.IX Item "$c->send_crlf"
Send the \s-1CRLF\s0 sequence to the client.
.ie n .IP "$c\->send_basic_header" 4
.el .IP "\f(CW$c\fR\->send_basic_header" 4
.IX Item "$c->send_basic_header"
.PD 0
.ie n .IP "$c\->send_basic_header( $code )" 4
.el .IP "\f(CW$c\fR\->send_basic_header( \f(CW$code\fR )" 4
.IX Item "$c->send_basic_header( $code )"
.ie n .IP "$c\->send_basic_header( $code, $mess )" 4
.el .IP "\f(CW$c\fR\->send_basic_header( \f(CW$code\fR, \f(CW$mess\fR )" 4
.IX Item "$c->send_basic_header( $code, $mess )"
.ie n .IP "$c\->send_basic_header( $code, $mess, $proto )" 4
.el .IP "\f(CW$c\fR\->send_basic_header( \f(CW$code\fR, \f(CW$mess\fR, \f(CW$proto\fR )" 4
.IX Item "$c->send_basic_header( $code, $mess, $proto )"
.PD
Send the status line and the \*(L"Date:\*(R" and \*(L"Server:\*(R" headers back to
the client.  This header is assumed to be continued and does not end
with an empty \s-1CRLF\s0 line.
.Sp
See the description of \fIsend_status_line()\fR for the description of the
accepted arguments.
.ie n .IP "$c\->send_header( $field, $value )" 4
.el .IP "\f(CW$c\fR\->send_header( \f(CW$field\fR, \f(CW$value\fR )" 4
.IX Item "$c->send_header( $field, $value )"
.PD 0
.ie n .IP "$c\->send_header( $field1, $value1, $field2, $value2, ... )" 4
.el .IP "\f(CW$c\fR\->send_header( \f(CW$field1\fR, \f(CW$value1\fR, \f(CW$field2\fR, \f(CW$value2\fR, ... )" 4
.IX Item "$c->send_header( $field1, $value1, $field2, $value2, ... )"
.PD
Send one or more header lines.
.ie n .IP "$c\->send_response( $res )" 4
.el .IP "\f(CW$c\fR\->send_response( \f(CW$res\fR )" 4
.IX Item "$c->send_response( $res )"
Write a \f(CW\*(C`HTTP::Response\*(C'\fR object to the
client as a response.  We try hard to make sure that the response is
self delimiting so that the connection can stay persistent for further
request/response exchanges.
.Sp
The content attribute of the \f(CW\*(C`HTTP::Response\*(C'\fR object can be a normal
string or a subroutine reference.  If it is a subroutine, then
whatever this callback routine returns is written back to the
client as the response content.  The routine will be called until it
return an undefined or empty value.  If the client is \s-1HTTP/1.1\s0 aware
then we will use chunked transfer encoding for the response.
.ie n .IP "$c\->send_redirect( $loc )" 4
.el .IP "\f(CW$c\fR\->send_redirect( \f(CW$loc\fR )" 4
.IX Item "$c->send_redirect( $loc )"
.PD 0
.ie n .IP "$c\->send_redirect( $loc, $code )" 4
.el .IP "\f(CW$c\fR\->send_redirect( \f(CW$loc\fR, \f(CW$code\fR )" 4
.IX Item "$c->send_redirect( $loc, $code )"
.ie n .IP "$c\->send_redirect( $loc, $code, $entity_body )" 4
.el .IP "\f(CW$c\fR\->send_redirect( \f(CW$loc\fR, \f(CW$code\fR, \f(CW$entity_body\fR )" 4
.IX Item "$c->send_redirect( $loc, $code, $entity_body )"
.PD
Send a redirect response back to the client.  The location ($loc) can
be an absolute or relative \s-1URL.\s0 The \f(CW$code\fR must be one the redirect
status codes, and defaults to \*(L"301 Moved Permanently\*(R"
.ie n .IP "$c\->send_error" 4
.el .IP "\f(CW$c\fR\->send_error" 4
.IX Item "$c->send_error"
.PD 0
.ie n .IP "$c\->send_error( $code )" 4
.el .IP "\f(CW$c\fR\->send_error( \f(CW$code\fR )" 4
.IX Item "$c->send_error( $code )"
.ie n .IP "$c\->send_error( $code, $error_message )" 4
.el .IP "\f(CW$c\fR\->send_error( \f(CW$code\fR, \f(CW$error_message\fR )" 4
.IX Item "$c->send_error( $code, $error_message )"
.PD
Send an error response back to the client.  If the \f(CW$code\fR is missing a
\&\*(L"Bad Request\*(R" error is reported.  The \f(CW$error_message\fR is a string that
is incorporated in the body of the \s-1HTML\s0 entity body.
.ie n .IP "$c\->send_file_response( $filename )" 4
.el .IP "\f(CW$c\fR\->send_file_response( \f(CW$filename\fR )" 4
.IX Item "$c->send_file_response( $filename )"
Send back a response with the specified \f(CW$filename\fR as content.  If the
file is a directory we try to generate an \s-1HTML\s0 index of it.
.ie n .IP "$c\->send_file( $filename )" 4
.el .IP "\f(CW$c\fR\->send_file( \f(CW$filename\fR )" 4
.IX Item "$c->send_file( $filename )"
.PD 0
.ie n .IP "$c\->send_file( $fd )" 4
.el .IP "\f(CW$c\fR\->send_file( \f(CW$fd\fR )" 4
.IX Item "$c->send_file( $fd )"
.PD
Copy the file to the client.  The file can be a string (which
will be interpreted as a filename) or a reference to an \f(CW\*(C`IO::Handle\*(C'\fR
or glob.
.ie n .IP "$c\->daemon" 4
.el .IP "\f(CW$c\fR\->daemon" 4
.IX Item "$c->daemon"
Return a reference to the corresponding \f(CW\*(C`HTTP::Daemon\*(C'\fR object.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1RFC 2616\s0
.PP
IO::Socket::INET, IO::Socket
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1996\-2003, Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Date.3pm                               0100644 0001750 0001750 00000022251 12566241304 023037  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Date 3"
.TH HTTP::Date 3 "2012-03-30" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Date \- date conversion routines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use HTTP::Date;
\&
\& $string = time2str($time);    # Format as GMT ASCII time
\& $time = str2time($string);    # convert ASCII date to machine time
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides functions that deal the date formats used by the
\&\s-1HTTP\s0 protocol (and then some more).  Only the first two functions,
\&\fItime2str()\fR and \fIstr2time()\fR, are exported by default.
.IP "time2str( [$time] )" 4
.IX Item "time2str( [$time] )"
The \fItime2str()\fR function converts a machine time (seconds since epoch)
to a string.  If the function is called without an argument or with an
undefined argument, it will use the current time.
.Sp
The string returned is in the format preferred for the \s-1HTTP\s0 protocol.
This is a fixed length subset of the format defined by \s-1RFC 1123,\s0
represented in Universal Time (\s-1GMT\s0).  An example of a time stamp
in this format is:
.Sp
.Vb 1
\&   Sun, 06 Nov 1994 08:49:37 GMT
.Ve
.ie n .IP "str2time( $str [, $zone] )" 4
.el .IP "str2time( \f(CW$str\fR [, \f(CW$zone\fR] )" 4
.IX Item "str2time( $str [, $zone] )"
The \fIstr2time()\fR function converts a string to machine time.  It returns
\&\f(CW\*(C`undef\*(C'\fR if the format of \f(CW$str\fR is unrecognized, otherwise whatever the
\&\f(CW\*(C`Time::Local\*(C'\fR functions can make out of the parsed time.  Dates
before the system's epoch may not work on all operating systems.  The
time formats recognized are the same as for \fIparse_date()\fR.
.Sp
The function also takes an optional second argument that specifies the
default time zone to use when converting the date.  This parameter is
ignored if the zone is found in the date string itself.  If this
parameter is missing, and the date string format does not contain any
zone specification, then the local time zone is assumed.
.Sp
If the zone is not "\f(CW\*(C`GMT\*(C'\fR\*(L" or numerical (like \*(R"\f(CW\*(C`\-0800\*(C'\fR\*(L" or
\&\*(R"\f(CW+0100\fR"), then the \f(CW\*(C`Time::Zone\*(C'\fR module must be installed in order
to get the date recognized.
.ie n .IP "parse_date( $str )" 4
.el .IP "parse_date( \f(CW$str\fR )" 4
.IX Item "parse_date( $str )"
This function will try to parse a date string, and then return it as a
list of numerical values followed by a (possible undefined) time zone
specifier; ($year, \f(CW$month\fR, \f(CW$day\fR, \f(CW$hour\fR, \f(CW$min\fR, \f(CW$sec\fR, \f(CW$tz\fR).  The \f(CW$year\fR
will be the full 4\-digit year, and \f(CW$month\fR numbers start with 1 (for January).
.Sp
In scalar context the numbers are interpolated in a string of the
\&\*(L"YYYY-MM-DD hh:mm:ss \s-1TZ\s0\*(R"\-format and returned.
.Sp
If the date is unrecognized, then the empty list is returned (\f(CW\*(C`undef\*(C'\fR in
scalar context).
.Sp
The function is able to parse the following formats:
.Sp
.Vb 5
\& "Wed, 09 Feb 1994 22:23:32 GMT"       \-\- HTTP format
\& "Thu Feb  3 17:03:55 GMT 1994"        \-\- ctime(3) format
\& "Thu Feb  3 00:00:00 1994",           \-\- ANSI C asctime() format
\& "Tuesday, 08\-Feb\-94 14:15:29 GMT"     \-\- old rfc850 HTTP format
\& "Tuesday, 08\-Feb\-1994 14:15:29 GMT"   \-\- broken rfc850 HTTP format
\&
\& "03/Feb/1994:17:03:55 \-0700"   \-\- common logfile format
\& "09 Feb 1994 22:23:32 GMT"     \-\- HTTP format (no weekday)
\& "08\-Feb\-94 14:15:29 GMT"       \-\- rfc850 format (no weekday)
\& "08\-Feb\-1994 14:15:29 GMT"     \-\- broken rfc850 format (no weekday)
\&
\& "1994\-02\-03 14:15:29 \-0100"    \-\- ISO 8601 format
\& "1994\-02\-03 14:15:29"          \-\- zone is optional
\& "1994\-02\-03"                   \-\- only date
\& "1994\-02\-03T14:15:29"          \-\- Use T as separator
\& "19940203T141529Z"             \-\- ISO 8601 compact format
\& "19940203"                     \-\- only date
\&
\& "08\-Feb\-94"         \-\- old rfc850 HTTP format    (no weekday, no time)
\& "08\-Feb\-1994"       \-\- broken rfc850 HTTP format (no weekday, no time)
\& "09 Feb 1994"       \-\- proposed new HTTP format  (no weekday, no time)
\& "03/Feb/1994"       \-\- common logfile format     (no time, no offset)
\&
\& "Feb  3  1994"      \-\- Unix \*(Aqls \-l\*(Aq format
\& "Feb  3 17:03"      \-\- Unix \*(Aqls \-l\*(Aq format
\&
\& "11\-15\-96  03:52PM" \-\- Windows \*(Aqdir\*(Aq format
.Ve
.Sp
The parser ignores leading and trailing whitespace.  It also allow the
seconds to be missing and the month to be numerical in most formats.
.Sp
If the year is missing, then we assume that the date is the first
matching date \fIbefore\fR current month.  If the year is given with only
2 digits, then \fIparse_date()\fR will select the century that makes the
year closest to the current date.
.IP "time2iso( [$time] )" 4
.IX Item "time2iso( [$time] )"
Same as \fItime2str()\fR, but returns a \*(L"YYYY-MM-DD hh:mm:ss\*(R"\-formatted
string representing time in the local time zone.
.IP "time2isoz( [$time] )" 4
.IX Item "time2isoz( [$time] )"
Same as \fItime2str()\fR, but returns a \*(L"YYYY-MM-DD hh:mm:ssZ\*(R"\-formatted
string representing Universal Time.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"time\*(R" in perlfunc, Time::Zone
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-1999, Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Date5.16.3pm                           0100644 0001750 0001750 00000021730 12566241304 023352  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Date 3"
.TH HTTP::Date 3 "2012-03-30" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Date \- date conversion routines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use HTTP::Date;
\&
\& $string = time2str($time);    # Format as GMT ASCII time
\& $time = str2time($string);    # convert ASCII date to machine time
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides functions that deal the date formats used by the
\&\s-1HTTP\s0 protocol (and then some more).  Only the first two functions,
\&\fItime2str()\fR and \fIstr2time()\fR, are exported by default.
.IP "time2str( [$time] )" 4
.IX Item "time2str( [$time] )"
The \fItime2str()\fR function converts a machine time (seconds since epoch)
to a string.  If the function is called without an argument or with an
undefined argument, it will use the current time.
.Sp
The string returned is in the format preferred for the \s-1HTTP\s0 protocol.
This is a fixed length subset of the format defined by \s-1RFC\s0 1123,
represented in Universal Time (\s-1GMT\s0).  An example of a time stamp
in this format is:
.Sp
.Vb 1
\&   Sun, 06 Nov 1994 08:49:37 GMT
.Ve
.ie n .IP "str2time( $str [, $zone] )" 4
.el .IP "str2time( \f(CW$str\fR [, \f(CW$zone\fR] )" 4
.IX Item "str2time( $str [, $zone] )"
The \fIstr2time()\fR function converts a string to machine time.  It returns
\&\f(CW\*(C`undef\*(C'\fR if the format of \f(CW$str\fR is unrecognized, otherwise whatever the
\&\f(CW\*(C`Time::Local\*(C'\fR functions can make out of the parsed time.  Dates
before the system's epoch may not work on all operating systems.  The
time formats recognized are the same as for \fIparse_date()\fR.
.Sp
The function also takes an optional second argument that specifies the
default time zone to use when converting the date.  This parameter is
ignored if the zone is found in the date string itself.  If this
parameter is missing, and the date string format does not contain any
zone specification, then the local time zone is assumed.
.Sp
If the zone is not "\f(CW\*(C`GMT\*(C'\fR\*(L" or numerical (like \*(R"\f(CW\*(C`\-0800\*(C'\fR\*(L" or
\&\*(R"\f(CW+0100\fR"), then the \f(CW\*(C`Time::Zone\*(C'\fR module must be installed in order
to get the date recognized.
.ie n .IP "parse_date( $str )" 4
.el .IP "parse_date( \f(CW$str\fR )" 4
.IX Item "parse_date( $str )"
This function will try to parse a date string, and then return it as a
list of numerical values followed by a (possible undefined) time zone
specifier; ($year, \f(CW$month\fR, \f(CW$day\fR, \f(CW$hour\fR, \f(CW$min\fR, \f(CW$sec\fR, \f(CW$tz\fR).  The \f(CW$year\fR
will be the full 4\-digit year, and \f(CW$month\fR numbers start with 1 (for January).
.Sp
In scalar context the numbers are interpolated in a string of the
\&\*(L"YYYY-MM-DD hh:mm:ss \s-1TZ\s0\*(R"\-format and returned.
.Sp
If the date is unrecognized, then the empty list is returned (\f(CW\*(C`undef\*(C'\fR in
scalar context).
.Sp
The function is able to parse the following formats:
.Sp
.Vb 5
\& "Wed, 09 Feb 1994 22:23:32 GMT"       \-\- HTTP format
\& "Thu Feb  3 17:03:55 GMT 1994"        \-\- ctime(3) format
\& "Thu Feb  3 00:00:00 1994",           \-\- ANSI C asctime() format
\& "Tuesday, 08\-Feb\-94 14:15:29 GMT"     \-\- old rfc850 HTTP format
\& "Tuesday, 08\-Feb\-1994 14:15:29 GMT"   \-\- broken rfc850 HTTP format
\&
\& "03/Feb/1994:17:03:55 \-0700"   \-\- common logfile format
\& "09 Feb 1994 22:23:32 GMT"     \-\- HTTP format (no weekday)
\& "08\-Feb\-94 14:15:29 GMT"       \-\- rfc850 format (no weekday)
\& "08\-Feb\-1994 14:15:29 GMT"     \-\- broken rfc850 format (no weekday)
\&
\& "1994\-02\-03 14:15:29 \-0100"    \-\- ISO 8601 format
\& "1994\-02\-03 14:15:29"          \-\- zone is optional
\& "1994\-02\-03"                   \-\- only date
\& "1994\-02\-03T14:15:29"          \-\- Use T as separator
\& "19940203T141529Z"             \-\- ISO 8601 compact format
\& "19940203"                     \-\- only date
\&
\& "08\-Feb\-94"         \-\- old rfc850 HTTP format    (no weekday, no time)
\& "08\-Feb\-1994"       \-\- broken rfc850 HTTP format (no weekday, no time)
\& "09 Feb 1994"       \-\- proposed new HTTP format  (no weekday, no time)
\& "03/Feb/1994"       \-\- common logfile format     (no time, no offset)
\&
\& "Feb  3  1994"      \-\- Unix \*(Aqls \-l\*(Aq format
\& "Feb  3 17:03"      \-\- Unix \*(Aqls \-l\*(Aq format
\&
\& "11\-15\-96  03:52PM" \-\- Windows \*(Aqdir\*(Aq format
.Ve
.Sp
The parser ignores leading and trailing whitespace.  It also allow the
seconds to be missing and the month to be numerical in most formats.
.Sp
If the year is missing, then we assume that the date is the first
matching date \fIbefore\fR current month.  If the year is given with only
2 digits, then \fIparse_date()\fR will select the century that makes the
year closest to the current date.
.IP "time2iso( [$time] )" 4
.IX Item "time2iso( [$time] )"
Same as \fItime2str()\fR, but returns a \*(L"YYYY-MM-DD hh:mm:ss\*(R"\-formatted
string representing time in the local time zone.
.IP "time2isoz( [$time] )" 4
.IX Item "time2isoz( [$time] )"
Same as \fItime2str()\fR, but returns a \*(L"YYYY-MM-DD hh:mm:ssZ\*(R"\-formatted
string representing Universal Time.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"time\*(R" in perlfunc, Time::Zone
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-1999, Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Date5.18.3pm                           0100644 0001750 0001750 00000022251 12566241304 023353  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Date 3"
.TH HTTP::Date 3 "2012-03-30" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Date \- date conversion routines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use HTTP::Date;
\&
\& $string = time2str($time);    # Format as GMT ASCII time
\& $time = str2time($string);    # convert ASCII date to machine time
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides functions that deal the date formats used by the
\&\s-1HTTP\s0 protocol (and then some more).  Only the first two functions,
\&\fItime2str()\fR and \fIstr2time()\fR, are exported by default.
.IP "time2str( [$time] )" 4
.IX Item "time2str( [$time] )"
The \fItime2str()\fR function converts a machine time (seconds since epoch)
to a string.  If the function is called without an argument or with an
undefined argument, it will use the current time.
.Sp
The string returned is in the format preferred for the \s-1HTTP\s0 protocol.
This is a fixed length subset of the format defined by \s-1RFC 1123,\s0
represented in Universal Time (\s-1GMT\s0).  An example of a time stamp
in this format is:
.Sp
.Vb 1
\&   Sun, 06 Nov 1994 08:49:37 GMT
.Ve
.ie n .IP "str2time( $str [, $zone] )" 4
.el .IP "str2time( \f(CW$str\fR [, \f(CW$zone\fR] )" 4
.IX Item "str2time( $str [, $zone] )"
The \fIstr2time()\fR function converts a string to machine time.  It returns
\&\f(CW\*(C`undef\*(C'\fR if the format of \f(CW$str\fR is unrecognized, otherwise whatever the
\&\f(CW\*(C`Time::Local\*(C'\fR functions can make out of the parsed time.  Dates
before the system's epoch may not work on all operating systems.  The
time formats recognized are the same as for \fIparse_date()\fR.
.Sp
The function also takes an optional second argument that specifies the
default time zone to use when converting the date.  This parameter is
ignored if the zone is found in the date string itself.  If this
parameter is missing, and the date string format does not contain any
zone specification, then the local time zone is assumed.
.Sp
If the zone is not "\f(CW\*(C`GMT\*(C'\fR\*(L" or numerical (like \*(R"\f(CW\*(C`\-0800\*(C'\fR\*(L" or
\&\*(R"\f(CW+0100\fR"), then the \f(CW\*(C`Time::Zone\*(C'\fR module must be installed in order
to get the date recognized.
.ie n .IP "parse_date( $str )" 4
.el .IP "parse_date( \f(CW$str\fR )" 4
.IX Item "parse_date( $str )"
This function will try to parse a date string, and then return it as a
list of numerical values followed by a (possible undefined) time zone
specifier; ($year, \f(CW$month\fR, \f(CW$day\fR, \f(CW$hour\fR, \f(CW$min\fR, \f(CW$sec\fR, \f(CW$tz\fR).  The \f(CW$year\fR
will be the full 4\-digit year, and \f(CW$month\fR numbers start with 1 (for January).
.Sp
In scalar context the numbers are interpolated in a string of the
\&\*(L"YYYY-MM-DD hh:mm:ss \s-1TZ\s0\*(R"\-format and returned.
.Sp
If the date is unrecognized, then the empty list is returned (\f(CW\*(C`undef\*(C'\fR in
scalar context).
.Sp
The function is able to parse the following formats:
.Sp
.Vb 5
\& "Wed, 09 Feb 1994 22:23:32 GMT"       \-\- HTTP format
\& "Thu Feb  3 17:03:55 GMT 1994"        \-\- ctime(3) format
\& "Thu Feb  3 00:00:00 1994",           \-\- ANSI C asctime() format
\& "Tuesday, 08\-Feb\-94 14:15:29 GMT"     \-\- old rfc850 HTTP format
\& "Tuesday, 08\-Feb\-1994 14:15:29 GMT"   \-\- broken rfc850 HTTP format
\&
\& "03/Feb/1994:17:03:55 \-0700"   \-\- common logfile format
\& "09 Feb 1994 22:23:32 GMT"     \-\- HTTP format (no weekday)
\& "08\-Feb\-94 14:15:29 GMT"       \-\- rfc850 format (no weekday)
\& "08\-Feb\-1994 14:15:29 GMT"     \-\- broken rfc850 format (no weekday)
\&
\& "1994\-02\-03 14:15:29 \-0100"    \-\- ISO 8601 format
\& "1994\-02\-03 14:15:29"          \-\- zone is optional
\& "1994\-02\-03"                   \-\- only date
\& "1994\-02\-03T14:15:29"          \-\- Use T as separator
\& "19940203T141529Z"             \-\- ISO 8601 compact format
\& "19940203"                     \-\- only date
\&
\& "08\-Feb\-94"         \-\- old rfc850 HTTP format    (no weekday, no time)
\& "08\-Feb\-1994"       \-\- broken rfc850 HTTP format (no weekday, no time)
\& "09 Feb 1994"       \-\- proposed new HTTP format  (no weekday, no time)
\& "03/Feb/1994"       \-\- common logfile format     (no time, no offset)
\&
\& "Feb  3  1994"      \-\- Unix \*(Aqls \-l\*(Aq format
\& "Feb  3 17:03"      \-\- Unix \*(Aqls \-l\*(Aq format
\&
\& "11\-15\-96  03:52PM" \-\- Windows \*(Aqdir\*(Aq format
.Ve
.Sp
The parser ignores leading and trailing whitespace.  It also allow the
seconds to be missing and the month to be numerical in most formats.
.Sp
If the year is missing, then we assume that the date is the first
matching date \fIbefore\fR current month.  If the year is given with only
2 digits, then \fIparse_date()\fR will select the century that makes the
year closest to the current date.
.IP "time2iso( [$time] )" 4
.IX Item "time2iso( [$time] )"
Same as \fItime2str()\fR, but returns a \*(L"YYYY-MM-DD hh:mm:ss\*(R"\-formatted
string representing time in the local time zone.
.IP "time2isoz( [$time] )" 4
.IX Item "time2isoz( [$time] )"
Same as \fItime2str()\fR, but returns a \*(L"YYYY-MM-DD hh:mm:ssZ\*(R"\-formatted
string representing Universal Time.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\*(L"time\*(R" in perlfunc, Time::Zone
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-1999, Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Headers.3pm                            0100644 0001750 0001750 00000053212 12566241314 023537  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Headers 3"
.TH HTTP::Headers 3 "2012-10-20" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Headers \- Class encapsulating HTTP Message headers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& require HTTP::Headers;
\& $h = HTTP::Headers\->new;
\&
\& $h\->header(\*(AqContent\-Type\*(Aq => \*(Aqtext/plain\*(Aq);  # set
\& $ct = $h\->header(\*(AqContent\-Type\*(Aq);            # get
\& $h\->remove_header(\*(AqContent\-Type\*(Aq);           # delete
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`HTTP::Headers\*(C'\fR class encapsulates HTTP-style message headers.
The headers consist of attribute-value pairs also called fields, which
may be repeated, and which are printed in a particular order.  The
field names are cases insensitive.
.PP
Instances of this class are usually created as member variables of the
\&\f(CW\*(C`HTTP::Request\*(C'\fR and \f(CW\*(C`HTTP::Response\*(C'\fR classes, internal to the
library.
.PP
The following methods are available:
.ie n .IP "$h = HTTP::Headers\->new" 4
.el .IP "\f(CW$h\fR = HTTP::Headers\->new" 4
.IX Item "$h = HTTP::Headers->new"
Constructs a new \f(CW\*(C`HTTP::Headers\*(C'\fR object.  You might pass some initial
attribute-value pairs as parameters to the constructor.  \fIE.g.\fR:
.Sp
.Vb 4
\& $h = HTTP::Headers\->new(
\&       Date         => \*(AqThu, 03 Feb 1994 00:00:00 GMT\*(Aq,
\&       Content_Type => \*(Aqtext/html; version=3.2\*(Aq,
\&       Content_Base => \*(Aqhttp://www.perl.org/\*(Aq);
.Ve
.Sp
The constructor arguments are passed to the \f(CW\*(C`header\*(C'\fR method which is
described below.
.ie n .IP "$h\->clone" 4
.el .IP "\f(CW$h\fR\->clone" 4
.IX Item "$h->clone"
Returns a copy of this \f(CW\*(C`HTTP::Headers\*(C'\fR object.
.ie n .IP "$h\->header( $field )" 4
.el .IP "\f(CW$h\fR\->header( \f(CW$field\fR )" 4
.IX Item "$h->header( $field )"
.PD 0
.ie n .IP "$h\->header( $field => $value )" 4
.el .IP "\f(CW$h\fR\->header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$h->header( $field => $value )"
.ie n .IP "$h\->header( $f1 => $v1, $f2 => $v2, ... )" 4
.el .IP "\f(CW$h\fR\->header( \f(CW$f1\fR => \f(CW$v1\fR, \f(CW$f2\fR => \f(CW$v2\fR, ... )" 4
.IX Item "$h->header( $f1 => $v1, $f2 => $v2, ... )"
.PD
Get or set the value of one or more header fields.  The header field
name ($field) is not case sensitive.  To make the life easier for perl
users who wants to avoid quoting before the => operator, you can use
\&'_' as a replacement for '\-' in header names.
.Sp
The \fIheader()\fR method accepts multiple ($field => \f(CW$value\fR) pairs, which
means that you can update several fields with a single invocation.
.Sp
The \f(CW$value\fR argument may be a plain string or a reference to an array
of strings for a multi-valued field. If the \f(CW$value\fR is provided as
\&\f(CW\*(C`undef\*(C'\fR then the field is removed.  If the \f(CW$value\fR is not given, then
that header field will remain unchanged.
.Sp
The old value (or values) of the last of the header fields is returned.
If no such field exists \f(CW\*(C`undef\*(C'\fR will be returned.
.Sp
A multi-valued field will be returned as separate values in list
context and will be concatenated with \*(L", \*(R" as separator in scalar
context.  The \s-1HTTP\s0 spec (\s-1RFC 2616\s0) promise that joining multiple
values in this way will not change the semantic of a header field, but
in practice there are cases like old-style Netscape cookies (see
HTTP::Cookies) where \*(L",\*(R" is used as part of the syntax of a single
field value.
.Sp
Examples:
.Sp
.Vb 6
\& $header\->header(MIME_Version => \*(Aq1.0\*(Aq,
\&                 User_Agent   => \*(AqMy\-Web\-Client/0.01\*(Aq);
\& $header\->header(Accept => "text/html, text/plain, image/*");
\& $header\->header(Accept => [qw(text/html text/plain image/*)]);
\& @accepts = $header\->header(\*(AqAccept\*(Aq);  # get multiple values
\& $accepts = $header\->header(\*(AqAccept\*(Aq);  # get values as a single string
.Ve
.ie n .IP "$h\->push_header( $field => $value )" 4
.el .IP "\f(CW$h\fR\->push_header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$h->push_header( $field => $value )"
.PD 0
.ie n .IP "$h\->push_header( $f1 => $v1, $f2 => $v2, ... )" 4
.el .IP "\f(CW$h\fR\->push_header( \f(CW$f1\fR => \f(CW$v1\fR, \f(CW$f2\fR => \f(CW$v2\fR, ... )" 4
.IX Item "$h->push_header( $f1 => $v1, $f2 => $v2, ... )"
.PD
Add a new field value for the specified header field.  Previous values
for the same field are retained.
.Sp
As for the \fIheader()\fR method, the field name ($field) is not case
sensitive and '_' can be used as a replacement for '\-'.
.Sp
The \f(CW$value\fR argument may be a scalar or a reference to a list of
scalars.
.Sp
.Vb 2
\& $header\->push_header(Accept => \*(Aqimage/jpeg\*(Aq);
\& $header\->push_header(Accept => [map "image/$_", qw(gif png tiff)]);
.Ve
.ie n .IP "$h\->init_header( $field => $value )" 4
.el .IP "\f(CW$h\fR\->init_header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$h->init_header( $field => $value )"
Set the specified header to the given value, but only if no previous
value for that field is set.
.Sp
The header field name ($field) is not case sensitive and '_'
can be used as a replacement for '\-'.
.Sp
The \f(CW$value\fR argument may be a scalar or a reference to a list of
scalars.
.ie n .IP "$h\->remove_header( $field, ... )" 4
.el .IP "\f(CW$h\fR\->remove_header( \f(CW$field\fR, ... )" 4
.IX Item "$h->remove_header( $field, ... )"
This function removes the header fields with the specified names.
.Sp
The header field names ($field) are not case sensitive and '_'
can be used as a replacement for '\-'.
.Sp
The return value is the values of the fields removed.  In scalar
context the number of fields removed is returned.
.Sp
Note that if you pass in multiple field names then it is generally not
possible to tell which of the returned values belonged to which field.
.ie n .IP "$h\->remove_content_headers" 4
.el .IP "\f(CW$h\fR\->remove_content_headers" 4
.IX Item "$h->remove_content_headers"
This will remove all the header fields used to describe the content of
a message.  All header field names prefixed with \f(CW\*(C`Content\-\*(C'\fR fall
into this category, as well as \f(CW\*(C`Allow\*(C'\fR, \f(CW\*(C`Expires\*(C'\fR and
\&\f(CW\*(C`Last\-Modified\*(C'\fR.  \s-1RFC 2616\s0 denotes these fields as \fIEntity Header
Fields\fR.
.Sp
The return value is a new \f(CW\*(C`HTTP::Headers\*(C'\fR object that contains the
removed headers only.
.ie n .IP "$h\->clear" 4
.el .IP "\f(CW$h\fR\->clear" 4
.IX Item "$h->clear"
This will remove all header fields.
.ie n .IP "$h\->header_field_names" 4
.el .IP "\f(CW$h\fR\->header_field_names" 4
.IX Item "$h->header_field_names"
Returns the list of distinct names for the fields present in the
header.  The field names have case as suggested by \s-1HTTP\s0 spec, and the
names are returned in the recommended \*(L"Good Practice\*(R" order.
.Sp
In scalar context return the number of distinct field names.
.ie n .IP "$h\->scan( \e&process_header_field )" 4
.el .IP "\f(CW$h\fR\->scan( \e&process_header_field )" 4
.IX Item "$h->scan( &process_header_field )"
Apply a subroutine to each header field in turn.  The callback routine
is called with two parameters; the name of the field and a single
value (a string).  If a header field is multi-valued, then the
routine is called once for each value.  The field name passed to the
callback routine has case as suggested by \s-1HTTP\s0 spec, and the headers
will be visited in the recommended \*(L"Good Practice\*(R" order.
.Sp
Any return values of the callback routine are ignored.  The loop can
be broken by raising an exception (\f(CW\*(C`die\*(C'\fR), but the caller of \fIscan()\fR
would have to trap the exception itself.
.ie n .IP "$h\->as_string" 4
.el .IP "\f(CW$h\fR\->as_string" 4
.IX Item "$h->as_string"
.PD 0
.ie n .IP "$h\->as_string( $eol )" 4
.el .IP "\f(CW$h\fR\->as_string( \f(CW$eol\fR )" 4
.IX Item "$h->as_string( $eol )"
.PD
Return the header fields as a formatted \s-1MIME\s0 header.  Since it
internally uses the \f(CW\*(C`scan\*(C'\fR method to build the string, the result
will use case as suggested by \s-1HTTP\s0 spec, and it will follow
recommended \*(L"Good Practice\*(R" of ordering the header fields.  Long header
values are not folded.
.Sp
The optional \f(CW$eol\fR parameter specifies the line ending sequence to
use.  The default is \*(L"\en\*(R".  Embedded \*(L"\en\*(R" characters in header field
values will be substituted with this line ending sequence.
.SH "CONVENIENCE METHODS"
.IX Header "CONVENIENCE METHODS"
The most frequently used headers can also be accessed through the
following convenience methods.  Most of these methods can both be used to read
and to set the value of a header.  The header value is set if you pass
an argument to the method.  The old header value is always returned.
If the given header did not exist then \f(CW\*(C`undef\*(C'\fR is returned.
.PP
Methods that deal with dates/times always convert their value to system
time (seconds since Jan 1, 1970) and they also expect this kind of
value when the header value is set.
.ie n .IP "$h\->date" 4
.el .IP "\f(CW$h\fR\->date" 4
.IX Item "$h->date"
This header represents the date and time at which the message was
originated. \fIE.g.\fR:
.Sp
.Vb 1
\&  $h\->date(time);  # set current date
.Ve
.ie n .IP "$h\->expires" 4
.el .IP "\f(CW$h\fR\->expires" 4
.IX Item "$h->expires"
This header gives the date and time after which the entity should be
considered stale.
.ie n .IP "$h\->if_modified_since" 4
.el .IP "\f(CW$h\fR\->if_modified_since" 4
.IX Item "$h->if_modified_since"
.PD 0
.ie n .IP "$h\->if_unmodified_since" 4
.el .IP "\f(CW$h\fR\->if_unmodified_since" 4
.IX Item "$h->if_unmodified_since"
.PD
These header fields are used to make a request conditional.  If the requested
resource has (or has not) been modified since the time specified in this field,
then the server will return a \f(CW\*(C`304 Not Modified\*(C'\fR response instead of
the document itself.
.ie n .IP "$h\->last_modified" 4
.el .IP "\f(CW$h\fR\->last_modified" 4
.IX Item "$h->last_modified"
This header indicates the date and time at which the resource was last
modified. \fIE.g.\fR:
.Sp
.Vb 6
\&  # check if document is more than 1 hour old
\&  if (my $last_mod = $h\->last_modified) {
\&      if ($last_mod < time \- 60*60) {
\&          ...
\&      }
\&  }
.Ve
.ie n .IP "$h\->content_type" 4
.el .IP "\f(CW$h\fR\->content_type" 4
.IX Item "$h->content_type"
The Content-Type header field indicates the media type of the message
content. \fIE.g.\fR:
.Sp
.Vb 1
\&  $h\->content_type(\*(Aqtext/html\*(Aq);
.Ve
.Sp
The value returned will be converted to lower case, and potential
parameters will be chopped off and returned as a separate value if in
an array context.  If there is no such header field, then the empty
string is returned.  This makes it safe to do the following:
.Sp
.Vb 5
\&  if ($h\->content_type eq \*(Aqtext/html\*(Aq) {
\&     # we enter this place even if the real header value happens to
\&     # be \*(AqTEXT/HTML; version=3.0\*(Aq
\&     ...
\&  }
.Ve
.ie n .IP "$h\->content_type_charset" 4
.el .IP "\f(CW$h\fR\->content_type_charset" 4
.IX Item "$h->content_type_charset"
Returns the upper-cased charset specified in the Content-Type header.  In list
context return the lower-cased bare content type followed by the upper-cased
charset.  Both values will be \f(CW\*(C`undef\*(C'\fR if not specified in the header.
.ie n .IP "$h\->content_is_text" 4
.el .IP "\f(CW$h\fR\->content_is_text" 4
.IX Item "$h->content_is_text"
Returns \s-1TRUE\s0 if the Content-Type header field indicate that the
content is textual.
.ie n .IP "$h\->content_is_html" 4
.el .IP "\f(CW$h\fR\->content_is_html" 4
.IX Item "$h->content_is_html"
Returns \s-1TRUE\s0 if the Content-Type header field indicate that the
content is some kind of \s-1HTML \s0(including \s-1XHTML\s0).  This method can't be
used to set Content-Type.
.ie n .IP "$h\->content_is_xhtml" 4
.el .IP "\f(CW$h\fR\->content_is_xhtml" 4
.IX Item "$h->content_is_xhtml"
Returns \s-1TRUE\s0 if the Content-Type header field indicate that the
content is \s-1XHTML. \s0 This method can't be used to set Content-Type.
.ie n .IP "$h\->content_is_xml" 4
.el .IP "\f(CW$h\fR\->content_is_xml" 4
.IX Item "$h->content_is_xml"
Returns \s-1TRUE\s0 if the Content-Type header field indicate that the
content is \s-1XML. \s0 This method can't be used to set Content-Type.
.ie n .IP "$h\->content_encoding" 4
.el .IP "\f(CW$h\fR\->content_encoding" 4
.IX Item "$h->content_encoding"
The Content-Encoding header field is used as a modifier to the
media type.  When present, its value indicates what additional
encoding mechanism has been applied to the resource.
.ie n .IP "$h\->content_length" 4
.el .IP "\f(CW$h\fR\->content_length" 4
.IX Item "$h->content_length"
A decimal number indicating the size in bytes of the message content.
.ie n .IP "$h\->content_language" 4
.el .IP "\f(CW$h\fR\->content_language" 4
.IX Item "$h->content_language"
The natural language(s) of the intended audience for the message
content.  The value is one or more language tags as defined by \s-1RFC
1766. \s0 Eg. \*(L"no\*(R" for some kind of Norwegian and \*(L"en-US\*(R" for English the
way it is written in the \s-1US.\s0
.ie n .IP "$h\->title" 4
.el .IP "\f(CW$h\fR\->title" 4
.IX Item "$h->title"
The title of the document.  In libwww-perl this header will be
initialized automatically from the <\s-1TITLE\s0>...</TITLE> element
of \s-1HTML\s0 documents.  \fIThis header is no longer part of the \s-1HTTP\s0
standard.\fR
.ie n .IP "$h\->user_agent" 4
.el .IP "\f(CW$h\fR\->user_agent" 4
.IX Item "$h->user_agent"
This header field is used in request messages and contains information
about the user agent originating the request.  \fIE.g.\fR:
.Sp
.Vb 1
\&  $h\->user_agent(\*(AqMozilla/5.0 (compatible; MSIE 7.0; Windows NT 6.0)\*(Aq);
.Ve
.ie n .IP "$h\->server" 4
.el .IP "\f(CW$h\fR\->server" 4
.IX Item "$h->server"
The server header field contains information about the software being
used by the originating server program handling the request.
.ie n .IP "$h\->from" 4
.el .IP "\f(CW$h\fR\->from" 4
.IX Item "$h->from"
This header should contain an Internet e\-mail address for the human
user who controls the requesting user agent.  The address should be
machine-usable, as defined by \s-1RFC822.  E\s0.g.:
.Sp
.Vb 1
\&  $h\->from(\*(AqKing Kong <king@kong.com>\*(Aq);
.Ve
.Sp
\&\fIThis header is no longer part of the \s-1HTTP\s0 standard.\fR
.ie n .IP "$h\->referer" 4
.el .IP "\f(CW$h\fR\->referer" 4
.IX Item "$h->referer"
Used to specify the address (\s-1URI\s0) of the document from which the
requested resource address was obtained.
.Sp
The \*(L"Free On-line Dictionary of Computing\*(R" as this to say about the
word \fIreferer\fR:
.Sp
.Vb 6
\&     <World\-Wide Web> A misspelling of "referrer" which
\&     somehow made it into the {HTTP} standard.  A given {web
\&     page}\*(Aqs referer (sic) is the {URL} of whatever web page
\&     contains the link that the user followed to the current
\&     page.  Most browsers pass this information as part of a
\&     request.
\&
\&     (1998\-10\-19)
.Ve
.Sp
By popular demand \f(CW\*(C`referrer\*(C'\fR exists as an alias for this method so you
can avoid this misspelling in your programs and still send the right
thing on the wire.
.Sp
When setting the referrer, this method removes the fragment from the
given \s-1URI\s0 if it is present, as mandated by \s-1RFC2616. \s0 Note that
the removal does \fInot\fR happen automatically if using the \fIheader()\fR,
\&\fIpush_header()\fR or \fIinit_header()\fR methods to set the referrer.
.ie n .IP "$h\->www_authenticate" 4
.el .IP "\f(CW$h\fR\->www_authenticate" 4
.IX Item "$h->www_authenticate"
This header must be included as part of a \f(CW\*(C`401 Unauthorized\*(C'\fR response.
The field value consist of a challenge that indicates the
authentication scheme and parameters applicable to the requested \s-1URI.\s0
.ie n .IP "$h\->proxy_authenticate" 4
.el .IP "\f(CW$h\fR\->proxy_authenticate" 4
.IX Item "$h->proxy_authenticate"
This header must be included in a \f(CW\*(C`407 Proxy Authentication Required\*(C'\fR
response.
.ie n .IP "$h\->authorization" 4
.el .IP "\f(CW$h\fR\->authorization" 4
.IX Item "$h->authorization"
.PD 0
.ie n .IP "$h\->proxy_authorization" 4
.el .IP "\f(CW$h\fR\->proxy_authorization" 4
.IX Item "$h->proxy_authorization"
.PD
A user agent that wishes to authenticate itself with a server or a
proxy, may do so by including these headers.
.ie n .IP "$h\->authorization_basic" 4
.el .IP "\f(CW$h\fR\->authorization_basic" 4
.IX Item "$h->authorization_basic"
This method is used to get or set an authorization header that use the
\&\*(L"Basic Authentication Scheme\*(R".  In array context it will return two
values; the user name and the password.  In scalar context it will
return \fI\*(L"uname:password\*(R"\fR as a single string value.
.Sp
When used to set the header value, it expects two arguments.  \fIE.g.\fR:
.Sp
.Vb 1
\&  $h\->authorization_basic($uname, $password);
.Ve
.Sp
The method will croak if the \f(CW$uname\fR contains a colon ':'.
.ie n .IP "$h\->proxy_authorization_basic" 4
.el .IP "\f(CW$h\fR\->proxy_authorization_basic" 4
.IX Item "$h->proxy_authorization_basic"
Same as \fIauthorization_basic()\fR but will set the \*(L"Proxy-Authorization\*(R"
header instead.
.SH "NON-CANONICALIZED FIELD NAMES"
.IX Header "NON-CANONICALIZED FIELD NAMES"
The header field name spelling is normally canonicalized including the
\&'_' to '\-' translation.  There are some application where this is not
appropriate.  Prefixing field names with ':' allow you to force a
specific spelling.  For example if you really want a header field name
to show up as \f(CW\*(C`foo_bar\*(C'\fR instead of \*(L"Foo-Bar\*(R", you might set it like
this:
.PP
.Vb 1
\&  $h\->header(":foo_bar" => 1);
.Ve
.PP
These field names are returned with the ':' intact for
\&\f(CW$h\fR\->header_field_names and the \f(CW$h\fR\->scan callback, but the colons do
not show in \f(CW$h\fR\->as_string.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2005 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Headers5.16.3pm                        0100644 0001750 0001750 00000052671 12566241314 024061  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Headers 3"
.TH HTTP::Headers 3 "2012-10-20" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Headers \- Class encapsulating HTTP Message headers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& require HTTP::Headers;
\& $h = HTTP::Headers\->new;
\&
\& $h\->header(\*(AqContent\-Type\*(Aq => \*(Aqtext/plain\*(Aq);  # set
\& $ct = $h\->header(\*(AqContent\-Type\*(Aq);            # get
\& $h\->remove_header(\*(AqContent\-Type\*(Aq);           # delete
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`HTTP::Headers\*(C'\fR class encapsulates HTTP-style message headers.
The headers consist of attribute-value pairs also called fields, which
may be repeated, and which are printed in a particular order.  The
field names are cases insensitive.
.PP
Instances of this class are usually created as member variables of the
\&\f(CW\*(C`HTTP::Request\*(C'\fR and \f(CW\*(C`HTTP::Response\*(C'\fR classes, internal to the
library.
.PP
The following methods are available:
.ie n .IP "$h = HTTP::Headers\->new" 4
.el .IP "\f(CW$h\fR = HTTP::Headers\->new" 4
.IX Item "$h = HTTP::Headers->new"
Constructs a new \f(CW\*(C`HTTP::Headers\*(C'\fR object.  You might pass some initial
attribute-value pairs as parameters to the constructor.  \fIE.g.\fR:
.Sp
.Vb 4
\& $h = HTTP::Headers\->new(
\&       Date         => \*(AqThu, 03 Feb 1994 00:00:00 GMT\*(Aq,
\&       Content_Type => \*(Aqtext/html; version=3.2\*(Aq,
\&       Content_Base => \*(Aqhttp://www.perl.org/\*(Aq);
.Ve
.Sp
The constructor arguments are passed to the \f(CW\*(C`header\*(C'\fR method which is
described below.
.ie n .IP "$h\->clone" 4
.el .IP "\f(CW$h\fR\->clone" 4
.IX Item "$h->clone"
Returns a copy of this \f(CW\*(C`HTTP::Headers\*(C'\fR object.
.ie n .IP "$h\->header( $field )" 4
.el .IP "\f(CW$h\fR\->header( \f(CW$field\fR )" 4
.IX Item "$h->header( $field )"
.PD 0
.ie n .IP "$h\->header( $field => $value )" 4
.el .IP "\f(CW$h\fR\->header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$h->header( $field => $value )"
.ie n .IP "$h\->header( $f1 => $v1, $f2 => $v2, ... )" 4
.el .IP "\f(CW$h\fR\->header( \f(CW$f1\fR => \f(CW$v1\fR, \f(CW$f2\fR => \f(CW$v2\fR, ... )" 4
.IX Item "$h->header( $f1 => $v1, $f2 => $v2, ... )"
.PD
Get or set the value of one or more header fields.  The header field
name ($field) is not case sensitive.  To make the life easier for perl
users who wants to avoid quoting before the => operator, you can use
\&'_' as a replacement for '\-' in header names.
.Sp
The \fIheader()\fR method accepts multiple ($field => \f(CW$value\fR) pairs, which
means that you can update several fields with a single invocation.
.Sp
The \f(CW$value\fR argument may be a plain string or a reference to an array
of strings for a multi-valued field. If the \f(CW$value\fR is provided as
\&\f(CW\*(C`undef\*(C'\fR then the field is removed.  If the \f(CW$value\fR is not given, then
that header field will remain unchanged.
.Sp
The old value (or values) of the last of the header fields is returned.
If no such field exists \f(CW\*(C`undef\*(C'\fR will be returned.
.Sp
A multi-valued field will be returned as separate values in list
context and will be concatenated with \*(L", \*(R" as separator in scalar
context.  The \s-1HTTP\s0 spec (\s-1RFC\s0 2616) promise that joining multiple
values in this way will not change the semantic of a header field, but
in practice there are cases like old-style Netscape cookies (see
HTTP::Cookies) where \*(L",\*(R" is used as part of the syntax of a single
field value.
.Sp
Examples:
.Sp
.Vb 6
\& $header\->header(MIME_Version => \*(Aq1.0\*(Aq,
\&                 User_Agent   => \*(AqMy\-Web\-Client/0.01\*(Aq);
\& $header\->header(Accept => "text/html, text/plain, image/*");
\& $header\->header(Accept => [qw(text/html text/plain image/*)]);
\& @accepts = $header\->header(\*(AqAccept\*(Aq);  # get multiple values
\& $accepts = $header\->header(\*(AqAccept\*(Aq);  # get values as a single string
.Ve
.ie n .IP "$h\->push_header( $field => $value )" 4
.el .IP "\f(CW$h\fR\->push_header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$h->push_header( $field => $value )"
.PD 0
.ie n .IP "$h\->push_header( $f1 => $v1, $f2 => $v2, ... )" 4
.el .IP "\f(CW$h\fR\->push_header( \f(CW$f1\fR => \f(CW$v1\fR, \f(CW$f2\fR => \f(CW$v2\fR, ... )" 4
.IX Item "$h->push_header( $f1 => $v1, $f2 => $v2, ... )"
.PD
Add a new field value for the specified header field.  Previous values
for the same field are retained.
.Sp
As for the \fIheader()\fR method, the field name ($field) is not case
sensitive and '_' can be used as a replacement for '\-'.
.Sp
The \f(CW$value\fR argument may be a scalar or a reference to a list of
scalars.
.Sp
.Vb 2
\& $header\->push_header(Accept => \*(Aqimage/jpeg\*(Aq);
\& $header\->push_header(Accept => [map "image/$_", qw(gif png tiff)]);
.Ve
.ie n .IP "$h\->init_header( $field => $value )" 4
.el .IP "\f(CW$h\fR\->init_header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$h->init_header( $field => $value )"
Set the specified header to the given value, but only if no previous
value for that field is set.
.Sp
The header field name ($field) is not case sensitive and '_'
can be used as a replacement for '\-'.
.Sp
The \f(CW$value\fR argument may be a scalar or a reference to a list of
scalars.
.ie n .IP "$h\->remove_header( $field, ... )" 4
.el .IP "\f(CW$h\fR\->remove_header( \f(CW$field\fR, ... )" 4
.IX Item "$h->remove_header( $field, ... )"
This function removes the header fields with the specified names.
.Sp
The header field names ($field) are not case sensitive and '_'
can be used as a replacement for '\-'.
.Sp
The return value is the values of the fields removed.  In scalar
context the number of fields removed is returned.
.Sp
Note that if you pass in multiple field names then it is generally not
possible to tell which of the returned values belonged to which field.
.ie n .IP "$h\->remove_content_headers" 4
.el .IP "\f(CW$h\fR\->remove_content_headers" 4
.IX Item "$h->remove_content_headers"
This will remove all the header fields used to describe the content of
a message.  All header field names prefixed with \f(CW\*(C`Content\-\*(C'\fR fall
into this category, as well as \f(CW\*(C`Allow\*(C'\fR, \f(CW\*(C`Expires\*(C'\fR and
\&\f(CW\*(C`Last\-Modified\*(C'\fR.  \s-1RFC\s0 2616 denotes these fields as \fIEntity Header
Fields\fR.
.Sp
The return value is a new \f(CW\*(C`HTTP::Headers\*(C'\fR object that contains the
removed headers only.
.ie n .IP "$h\->clear" 4
.el .IP "\f(CW$h\fR\->clear" 4
.IX Item "$h->clear"
This will remove all header fields.
.ie n .IP "$h\->header_field_names" 4
.el .IP "\f(CW$h\fR\->header_field_names" 4
.IX Item "$h->header_field_names"
Returns the list of distinct names for the fields present in the
header.  The field names have case as suggested by \s-1HTTP\s0 spec, and the
names are returned in the recommended \*(L"Good Practice\*(R" order.
.Sp
In scalar context return the number of distinct field names.
.ie n .IP "$h\->scan( \e&process_header_field )" 4
.el .IP "\f(CW$h\fR\->scan( \e&process_header_field )" 4
.IX Item "$h->scan( &process_header_field )"
Apply a subroutine to each header field in turn.  The callback routine
is called with two parameters; the name of the field and a single
value (a string).  If a header field is multi-valued, then the
routine is called once for each value.  The field name passed to the
callback routine has case as suggested by \s-1HTTP\s0 spec, and the headers
will be visited in the recommended \*(L"Good Practice\*(R" order.
.Sp
Any return values of the callback routine are ignored.  The loop can
be broken by raising an exception (\f(CW\*(C`die\*(C'\fR), but the caller of \fIscan()\fR
would have to trap the exception itself.
.ie n .IP "$h\->as_string" 4
.el .IP "\f(CW$h\fR\->as_string" 4
.IX Item "$h->as_string"
.PD 0
.ie n .IP "$h\->as_string( $eol )" 4
.el .IP "\f(CW$h\fR\->as_string( \f(CW$eol\fR )" 4
.IX Item "$h->as_string( $eol )"
.PD
Return the header fields as a formatted \s-1MIME\s0 header.  Since it
internally uses the \f(CW\*(C`scan\*(C'\fR method to build the string, the result
will use case as suggested by \s-1HTTP\s0 spec, and it will follow
recommended \*(L"Good Practice\*(R" of ordering the header fields.  Long header
values are not folded.
.Sp
The optional \f(CW$eol\fR parameter specifies the line ending sequence to
use.  The default is \*(L"\en\*(R".  Embedded \*(L"\en\*(R" characters in header field
values will be substituted with this line ending sequence.
.SH "CONVENIENCE METHODS"
.IX Header "CONVENIENCE METHODS"
The most frequently used headers can also be accessed through the
following convenience methods.  Most of these methods can both be used to read
and to set the value of a header.  The header value is set if you pass
an argument to the method.  The old header value is always returned.
If the given header did not exist then \f(CW\*(C`undef\*(C'\fR is returned.
.PP
Methods that deal with dates/times always convert their value to system
time (seconds since Jan 1, 1970) and they also expect this kind of
value when the header value is set.
.ie n .IP "$h\->date" 4
.el .IP "\f(CW$h\fR\->date" 4
.IX Item "$h->date"
This header represents the date and time at which the message was
originated. \fIE.g.\fR:
.Sp
.Vb 1
\&  $h\->date(time);  # set current date
.Ve
.ie n .IP "$h\->expires" 4
.el .IP "\f(CW$h\fR\->expires" 4
.IX Item "$h->expires"
This header gives the date and time after which the entity should be
considered stale.
.ie n .IP "$h\->if_modified_since" 4
.el .IP "\f(CW$h\fR\->if_modified_since" 4
.IX Item "$h->if_modified_since"
.PD 0
.ie n .IP "$h\->if_unmodified_since" 4
.el .IP "\f(CW$h\fR\->if_unmodified_since" 4
.IX Item "$h->if_unmodified_since"
.PD
These header fields are used to make a request conditional.  If the requested
resource has (or has not) been modified since the time specified in this field,
then the server will return a \f(CW\*(C`304 Not Modified\*(C'\fR response instead of
the document itself.
.ie n .IP "$h\->last_modified" 4
.el .IP "\f(CW$h\fR\->last_modified" 4
.IX Item "$h->last_modified"
This header indicates the date and time at which the resource was last
modified. \fIE.g.\fR:
.Sp
.Vb 6
\&  # check if document is more than 1 hour old
\&  if (my $last_mod = $h\->last_modified) {
\&      if ($last_mod < time \- 60*60) {
\&          ...
\&      }
\&  }
.Ve
.ie n .IP "$h\->content_type" 4
.el .IP "\f(CW$h\fR\->content_type" 4
.IX Item "$h->content_type"
The Content-Type header field indicates the media type of the message
content. \fIE.g.\fR:
.Sp
.Vb 1
\&  $h\->content_type(\*(Aqtext/html\*(Aq);
.Ve
.Sp
The value returned will be converted to lower case, and potential
parameters will be chopped off and returned as a separate value if in
an array context.  If there is no such header field, then the empty
string is returned.  This makes it safe to do the following:
.Sp
.Vb 5
\&  if ($h\->content_type eq \*(Aqtext/html\*(Aq) {
\&     # we enter this place even if the real header value happens to
\&     # be \*(AqTEXT/HTML; version=3.0\*(Aq
\&     ...
\&  }
.Ve
.ie n .IP "$h\->content_type_charset" 4
.el .IP "\f(CW$h\fR\->content_type_charset" 4
.IX Item "$h->content_type_charset"
Returns the upper-cased charset specified in the Content-Type header.  In list
context return the lower-cased bare content type followed by the upper-cased
charset.  Both values will be \f(CW\*(C`undef\*(C'\fR if not specified in the header.
.ie n .IP "$h\->content_is_text" 4
.el .IP "\f(CW$h\fR\->content_is_text" 4
.IX Item "$h->content_is_text"
Returns \s-1TRUE\s0 if the Content-Type header field indicate that the
content is textual.
.ie n .IP "$h\->content_is_html" 4
.el .IP "\f(CW$h\fR\->content_is_html" 4
.IX Item "$h->content_is_html"
Returns \s-1TRUE\s0 if the Content-Type header field indicate that the
content is some kind of \s-1HTML\s0 (including \s-1XHTML\s0).  This method can't be
used to set Content-Type.
.ie n .IP "$h\->content_is_xhtml" 4
.el .IP "\f(CW$h\fR\->content_is_xhtml" 4
.IX Item "$h->content_is_xhtml"
Returns \s-1TRUE\s0 if the Content-Type header field indicate that the
content is \s-1XHTML\s0.  This method can't be used to set Content-Type.
.ie n .IP "$h\->content_is_xml" 4
.el .IP "\f(CW$h\fR\->content_is_xml" 4
.IX Item "$h->content_is_xml"
Returns \s-1TRUE\s0 if the Content-Type header field indicate that the
content is \s-1XML\s0.  This method can't be used to set Content-Type.
.ie n .IP "$h\->content_encoding" 4
.el .IP "\f(CW$h\fR\->content_encoding" 4
.IX Item "$h->content_encoding"
The Content-Encoding header field is used as a modifier to the
media type.  When present, its value indicates what additional
encoding mechanism has been applied to the resource.
.ie n .IP "$h\->content_length" 4
.el .IP "\f(CW$h\fR\->content_length" 4
.IX Item "$h->content_length"
A decimal number indicating the size in bytes of the message content.
.ie n .IP "$h\->content_language" 4
.el .IP "\f(CW$h\fR\->content_language" 4
.IX Item "$h->content_language"
The natural language(s) of the intended audience for the message
content.  The value is one or more language tags as defined by \s-1RFC\s0
1766.  Eg. \*(L"no\*(R" for some kind of Norwegian and \*(L"en-US\*(R" for English the
way it is written in the \s-1US\s0.
.ie n .IP "$h\->title" 4
.el .IP "\f(CW$h\fR\->title" 4
.IX Item "$h->title"
The title of the document.  In libwww-perl this header will be
initialized automatically from the <\s-1TITLE\s0>...</TITLE> element
of \s-1HTML\s0 documents.  \fIThis header is no longer part of the \s-1HTTP\s0
standard.\fR
.ie n .IP "$h\->user_agent" 4
.el .IP "\f(CW$h\fR\->user_agent" 4
.IX Item "$h->user_agent"
This header field is used in request messages and contains information
about the user agent originating the request.  \fIE.g.\fR:
.Sp
.Vb 1
\&  $h\->user_agent(\*(AqMozilla/5.0 (compatible; MSIE 7.0; Windows NT 6.0)\*(Aq);
.Ve
.ie n .IP "$h\->server" 4
.el .IP "\f(CW$h\fR\->server" 4
.IX Item "$h->server"
The server header field contains information about the software being
used by the originating server program handling the request.
.ie n .IP "$h\->from" 4
.el .IP "\f(CW$h\fR\->from" 4
.IX Item "$h->from"
This header should contain an Internet e\-mail address for the human
user who controls the requesting user agent.  The address should be
machine-usable, as defined by \s-1RFC822\s0.  E.g.:
.Sp
.Vb 1
\&  $h\->from(\*(AqKing Kong <king@kong.com>\*(Aq);
.Ve
.Sp
\&\fIThis header is no longer part of the \s-1HTTP\s0 standard.\fR
.ie n .IP "$h\->referer" 4
.el .IP "\f(CW$h\fR\->referer" 4
.IX Item "$h->referer"
Used to specify the address (\s-1URI\s0) of the document from which the
requested resource address was obtained.
.Sp
The \*(L"Free On-line Dictionary of Computing\*(R" as this to say about the
word \fIreferer\fR:
.Sp
.Vb 6
\&     <World\-Wide Web> A misspelling of "referrer" which
\&     somehow made it into the {HTTP} standard.  A given {web
\&     page}\*(Aqs referer (sic) is the {URL} of whatever web page
\&     contains the link that the user followed to the current
\&     page.  Most browsers pass this information as part of a
\&     request.
\&
\&     (1998\-10\-19)
.Ve
.Sp
By popular demand \f(CW\*(C`referrer\*(C'\fR exists as an alias for this method so you
can avoid this misspelling in your programs and still send the right
thing on the wire.
.Sp
When setting the referrer, this method removes the fragment from the
given \s-1URI\s0 if it is present, as mandated by \s-1RFC2616\s0.  Note that
the removal does \fInot\fR happen automatically if using the \fIheader()\fR,
\&\fIpush_header()\fR or \fIinit_header()\fR methods to set the referrer.
.ie n .IP "$h\->www_authenticate" 4
.el .IP "\f(CW$h\fR\->www_authenticate" 4
.IX Item "$h->www_authenticate"
This header must be included as part of a \f(CW\*(C`401 Unauthorized\*(C'\fR response.
The field value consist of a challenge that indicates the
authentication scheme and parameters applicable to the requested \s-1URI\s0.
.ie n .IP "$h\->proxy_authenticate" 4
.el .IP "\f(CW$h\fR\->proxy_authenticate" 4
.IX Item "$h->proxy_authenticate"
This header must be included in a \f(CW\*(C`407 Proxy Authentication Required\*(C'\fR
response.
.ie n .IP "$h\->authorization" 4
.el .IP "\f(CW$h\fR\->authorization" 4
.IX Item "$h->authorization"
.PD 0
.ie n .IP "$h\->proxy_authorization" 4
.el .IP "\f(CW$h\fR\->proxy_authorization" 4
.IX Item "$h->proxy_authorization"
.PD
A user agent that wishes to authenticate itself with a server or a
proxy, may do so by including these headers.
.ie n .IP "$h\->authorization_basic" 4
.el .IP "\f(CW$h\fR\->authorization_basic" 4
.IX Item "$h->authorization_basic"
This method is used to get or set an authorization header that use the
\&\*(L"Basic Authentication Scheme\*(R".  In array context it will return two
values; the user name and the password.  In scalar context it will
return \fI\*(L"uname:password\*(R"\fR as a single string value.
.Sp
When used to set the header value, it expects two arguments.  \fIE.g.\fR:
.Sp
.Vb 1
\&  $h\->authorization_basic($uname, $password);
.Ve
.Sp
The method will croak if the \f(CW$uname\fR contains a colon ':'.
.ie n .IP "$h\->proxy_authorization_basic" 4
.el .IP "\f(CW$h\fR\->proxy_authorization_basic" 4
.IX Item "$h->proxy_authorization_basic"
Same as \fIauthorization_basic()\fR but will set the \*(L"Proxy-Authorization\*(R"
header instead.
.SH "NON-CANONICALIZED FIELD NAMES"
.IX Header "NON-CANONICALIZED FIELD NAMES"
The header field name spelling is normally canonicalized including the
\&'_' to '\-' translation.  There are some application where this is not
appropriate.  Prefixing field names with ':' allow you to force a
specific spelling.  For example if you really want a header field name
to show up as \f(CW\*(C`foo_bar\*(C'\fR instead of \*(L"Foo-Bar\*(R", you might set it like
this:
.PP
.Vb 1
\&  $h\->header(":foo_bar" => 1);
.Ve
.PP
These field names are returned with the ':' intact for
\&\f(CW$h\fR\->header_field_names and the \f(CW$h\fR\->scan callback, but the colons do
not show in \f(CW$h\fR\->as_string.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2005 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Headers5.18.3pm                        0100644 0001750 0001750 00000053212 12566241314 024053  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Headers 3"
.TH HTTP::Headers 3 "2012-10-20" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Headers \- Class encapsulating HTTP Message headers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& require HTTP::Headers;
\& $h = HTTP::Headers\->new;
\&
\& $h\->header(\*(AqContent\-Type\*(Aq => \*(Aqtext/plain\*(Aq);  # set
\& $ct = $h\->header(\*(AqContent\-Type\*(Aq);            # get
\& $h\->remove_header(\*(AqContent\-Type\*(Aq);           # delete
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`HTTP::Headers\*(C'\fR class encapsulates HTTP-style message headers.
The headers consist of attribute-value pairs also called fields, which
may be repeated, and which are printed in a particular order.  The
field names are cases insensitive.
.PP
Instances of this class are usually created as member variables of the
\&\f(CW\*(C`HTTP::Request\*(C'\fR and \f(CW\*(C`HTTP::Response\*(C'\fR classes, internal to the
library.
.PP
The following methods are available:
.ie n .IP "$h = HTTP::Headers\->new" 4
.el .IP "\f(CW$h\fR = HTTP::Headers\->new" 4
.IX Item "$h = HTTP::Headers->new"
Constructs a new \f(CW\*(C`HTTP::Headers\*(C'\fR object.  You might pass some initial
attribute-value pairs as parameters to the constructor.  \fIE.g.\fR:
.Sp
.Vb 4
\& $h = HTTP::Headers\->new(
\&       Date         => \*(AqThu, 03 Feb 1994 00:00:00 GMT\*(Aq,
\&       Content_Type => \*(Aqtext/html; version=3.2\*(Aq,
\&       Content_Base => \*(Aqhttp://www.perl.org/\*(Aq);
.Ve
.Sp
The constructor arguments are passed to the \f(CW\*(C`header\*(C'\fR method which is
described below.
.ie n .IP "$h\->clone" 4
.el .IP "\f(CW$h\fR\->clone" 4
.IX Item "$h->clone"
Returns a copy of this \f(CW\*(C`HTTP::Headers\*(C'\fR object.
.ie n .IP "$h\->header( $field )" 4
.el .IP "\f(CW$h\fR\->header( \f(CW$field\fR )" 4
.IX Item "$h->header( $field )"
.PD 0
.ie n .IP "$h\->header( $field => $value )" 4
.el .IP "\f(CW$h\fR\->header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$h->header( $field => $value )"
.ie n .IP "$h\->header( $f1 => $v1, $f2 => $v2, ... )" 4
.el .IP "\f(CW$h\fR\->header( \f(CW$f1\fR => \f(CW$v1\fR, \f(CW$f2\fR => \f(CW$v2\fR, ... )" 4
.IX Item "$h->header( $f1 => $v1, $f2 => $v2, ... )"
.PD
Get or set the value of one or more header fields.  The header field
name ($field) is not case sensitive.  To make the life easier for perl
users who wants to avoid quoting before the => operator, you can use
\&'_' as a replacement for '\-' in header names.
.Sp
The \fIheader()\fR method accepts multiple ($field => \f(CW$value\fR) pairs, which
means that you can update several fields with a single invocation.
.Sp
The \f(CW$value\fR argument may be a plain string or a reference to an array
of strings for a multi-valued field. If the \f(CW$value\fR is provided as
\&\f(CW\*(C`undef\*(C'\fR then the field is removed.  If the \f(CW$value\fR is not given, then
that header field will remain unchanged.
.Sp
The old value (or values) of the last of the header fields is returned.
If no such field exists \f(CW\*(C`undef\*(C'\fR will be returned.
.Sp
A multi-valued field will be returned as separate values in list
context and will be concatenated with \*(L", \*(R" as separator in scalar
context.  The \s-1HTTP\s0 spec (\s-1RFC 2616\s0) promise that joining multiple
values in this way will not change the semantic of a header field, but
in practice there are cases like old-style Netscape cookies (see
HTTP::Cookies) where \*(L",\*(R" is used as part of the syntax of a single
field value.
.Sp
Examples:
.Sp
.Vb 6
\& $header\->header(MIME_Version => \*(Aq1.0\*(Aq,
\&                 User_Agent   => \*(AqMy\-Web\-Client/0.01\*(Aq);
\& $header\->header(Accept => "text/html, text/plain, image/*");
\& $header\->header(Accept => [qw(text/html text/plain image/*)]);
\& @accepts = $header\->header(\*(AqAccept\*(Aq);  # get multiple values
\& $accepts = $header\->header(\*(AqAccept\*(Aq);  # get values as a single string
.Ve
.ie n .IP "$h\->push_header( $field => $value )" 4
.el .IP "\f(CW$h\fR\->push_header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$h->push_header( $field => $value )"
.PD 0
.ie n .IP "$h\->push_header( $f1 => $v1, $f2 => $v2, ... )" 4
.el .IP "\f(CW$h\fR\->push_header( \f(CW$f1\fR => \f(CW$v1\fR, \f(CW$f2\fR => \f(CW$v2\fR, ... )" 4
.IX Item "$h->push_header( $f1 => $v1, $f2 => $v2, ... )"
.PD
Add a new field value for the specified header field.  Previous values
for the same field are retained.
.Sp
As for the \fIheader()\fR method, the field name ($field) is not case
sensitive and '_' can be used as a replacement for '\-'.
.Sp
The \f(CW$value\fR argument may be a scalar or a reference to a list of
scalars.
.Sp
.Vb 2
\& $header\->push_header(Accept => \*(Aqimage/jpeg\*(Aq);
\& $header\->push_header(Accept => [map "image/$_", qw(gif png tiff)]);
.Ve
.ie n .IP "$h\->init_header( $field => $value )" 4
.el .IP "\f(CW$h\fR\->init_header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$h->init_header( $field => $value )"
Set the specified header to the given value, but only if no previous
value for that field is set.
.Sp
The header field name ($field) is not case sensitive and '_'
can be used as a replacement for '\-'.
.Sp
The \f(CW$value\fR argument may be a scalar or a reference to a list of
scalars.
.ie n .IP "$h\->remove_header( $field, ... )" 4
.el .IP "\f(CW$h\fR\->remove_header( \f(CW$field\fR, ... )" 4
.IX Item "$h->remove_header( $field, ... )"
This function removes the header fields with the specified names.
.Sp
The header field names ($field) are not case sensitive and '_'
can be used as a replacement for '\-'.
.Sp
The return value is the values of the fields removed.  In scalar
context the number of fields removed is returned.
.Sp
Note that if you pass in multiple field names then it is generally not
possible to tell which of the returned values belonged to which field.
.ie n .IP "$h\->remove_content_headers" 4
.el .IP "\f(CW$h\fR\->remove_content_headers" 4
.IX Item "$h->remove_content_headers"
This will remove all the header fields used to describe the content of
a message.  All header field names prefixed with \f(CW\*(C`Content\-\*(C'\fR fall
into this category, as well as \f(CW\*(C`Allow\*(C'\fR, \f(CW\*(C`Expires\*(C'\fR and
\&\f(CW\*(C`Last\-Modified\*(C'\fR.  \s-1RFC 2616\s0 denotes these fields as \fIEntity Header
Fields\fR.
.Sp
The return value is a new \f(CW\*(C`HTTP::Headers\*(C'\fR object that contains the
removed headers only.
.ie n .IP "$h\->clear" 4
.el .IP "\f(CW$h\fR\->clear" 4
.IX Item "$h->clear"
This will remove all header fields.
.ie n .IP "$h\->header_field_names" 4
.el .IP "\f(CW$h\fR\->header_field_names" 4
.IX Item "$h->header_field_names"
Returns the list of distinct names for the fields present in the
header.  The field names have case as suggested by \s-1HTTP\s0 spec, and the
names are returned in the recommended \*(L"Good Practice\*(R" order.
.Sp
In scalar context return the number of distinct field names.
.ie n .IP "$h\->scan( \e&process_header_field )" 4
.el .IP "\f(CW$h\fR\->scan( \e&process_header_field )" 4
.IX Item "$h->scan( &process_header_field )"
Apply a subroutine to each header field in turn.  The callback routine
is called with two parameters; the name of the field and a single
value (a string).  If a header field is multi-valued, then the
routine is called once for each value.  The field name passed to the
callback routine has case as suggested by \s-1HTTP\s0 spec, and the headers
will be visited in the recommended \*(L"Good Practice\*(R" order.
.Sp
Any return values of the callback routine are ignored.  The loop can
be broken by raising an exception (\f(CW\*(C`die\*(C'\fR), but the caller of \fIscan()\fR
would have to trap the exception itself.
.ie n .IP "$h\->as_string" 4
.el .IP "\f(CW$h\fR\->as_string" 4
.IX Item "$h->as_string"
.PD 0
.ie n .IP "$h\->as_string( $eol )" 4
.el .IP "\f(CW$h\fR\->as_string( \f(CW$eol\fR )" 4
.IX Item "$h->as_string( $eol )"
.PD
Return the header fields as a formatted \s-1MIME\s0 header.  Since it
internally uses the \f(CW\*(C`scan\*(C'\fR method to build the string, the result
will use case as suggested by \s-1HTTP\s0 spec, and it will follow
recommended \*(L"Good Practice\*(R" of ordering the header fields.  Long header
values are not folded.
.Sp
The optional \f(CW$eol\fR parameter specifies the line ending sequence to
use.  The default is \*(L"\en\*(R".  Embedded \*(L"\en\*(R" characters in header field
values will be substituted with this line ending sequence.
.SH "CONVENIENCE METHODS"
.IX Header "CONVENIENCE METHODS"
The most frequently used headers can also be accessed through the
following convenience methods.  Most of these methods can both be used to read
and to set the value of a header.  The header value is set if you pass
an argument to the method.  The old header value is always returned.
If the given header did not exist then \f(CW\*(C`undef\*(C'\fR is returned.
.PP
Methods that deal with dates/times always convert their value to system
time (seconds since Jan 1, 1970) and they also expect this kind of
value when the header value is set.
.ie n .IP "$h\->date" 4
.el .IP "\f(CW$h\fR\->date" 4
.IX Item "$h->date"
This header represents the date and time at which the message was
originated. \fIE.g.\fR:
.Sp
.Vb 1
\&  $h\->date(time);  # set current date
.Ve
.ie n .IP "$h\->expires" 4
.el .IP "\f(CW$h\fR\->expires" 4
.IX Item "$h->expires"
This header gives the date and time after which the entity should be
considered stale.
.ie n .IP "$h\->if_modified_since" 4
.el .IP "\f(CW$h\fR\->if_modified_since" 4
.IX Item "$h->if_modified_since"
.PD 0
.ie n .IP "$h\->if_unmodified_since" 4
.el .IP "\f(CW$h\fR\->if_unmodified_since" 4
.IX Item "$h->if_unmodified_since"
.PD
These header fields are used to make a request conditional.  If the requested
resource has (or has not) been modified since the time specified in this field,
then the server will return a \f(CW\*(C`304 Not Modified\*(C'\fR response instead of
the document itself.
.ie n .IP "$h\->last_modified" 4
.el .IP "\f(CW$h\fR\->last_modified" 4
.IX Item "$h->last_modified"
This header indicates the date and time at which the resource was last
modified. \fIE.g.\fR:
.Sp
.Vb 6
\&  # check if document is more than 1 hour old
\&  if (my $last_mod = $h\->last_modified) {
\&      if ($last_mod < time \- 60*60) {
\&          ...
\&      }
\&  }
.Ve
.ie n .IP "$h\->content_type" 4
.el .IP "\f(CW$h\fR\->content_type" 4
.IX Item "$h->content_type"
The Content-Type header field indicates the media type of the message
content. \fIE.g.\fR:
.Sp
.Vb 1
\&  $h\->content_type(\*(Aqtext/html\*(Aq);
.Ve
.Sp
The value returned will be converted to lower case, and potential
parameters will be chopped off and returned as a separate value if in
an array context.  If there is no such header field, then the empty
string is returned.  This makes it safe to do the following:
.Sp
.Vb 5
\&  if ($h\->content_type eq \*(Aqtext/html\*(Aq) {
\&     # we enter this place even if the real header value happens to
\&     # be \*(AqTEXT/HTML; version=3.0\*(Aq
\&     ...
\&  }
.Ve
.ie n .IP "$h\->content_type_charset" 4
.el .IP "\f(CW$h\fR\->content_type_charset" 4
.IX Item "$h->content_type_charset"
Returns the upper-cased charset specified in the Content-Type header.  In list
context return the lower-cased bare content type followed by the upper-cased
charset.  Both values will be \f(CW\*(C`undef\*(C'\fR if not specified in the header.
.ie n .IP "$h\->content_is_text" 4
.el .IP "\f(CW$h\fR\->content_is_text" 4
.IX Item "$h->content_is_text"
Returns \s-1TRUE\s0 if the Content-Type header field indicate that the
content is textual.
.ie n .IP "$h\->content_is_html" 4
.el .IP "\f(CW$h\fR\->content_is_html" 4
.IX Item "$h->content_is_html"
Returns \s-1TRUE\s0 if the Content-Type header field indicate that the
content is some kind of \s-1HTML \s0(including \s-1XHTML\s0).  This method can't be
used to set Content-Type.
.ie n .IP "$h\->content_is_xhtml" 4
.el .IP "\f(CW$h\fR\->content_is_xhtml" 4
.IX Item "$h->content_is_xhtml"
Returns \s-1TRUE\s0 if the Content-Type header field indicate that the
content is \s-1XHTML. \s0 This method can't be used to set Content-Type.
.ie n .IP "$h\->content_is_xml" 4
.el .IP "\f(CW$h\fR\->content_is_xml" 4
.IX Item "$h->content_is_xml"
Returns \s-1TRUE\s0 if the Content-Type header field indicate that the
content is \s-1XML. \s0 This method can't be used to set Content-Type.
.ie n .IP "$h\->content_encoding" 4
.el .IP "\f(CW$h\fR\->content_encoding" 4
.IX Item "$h->content_encoding"
The Content-Encoding header field is used as a modifier to the
media type.  When present, its value indicates what additional
encoding mechanism has been applied to the resource.
.ie n .IP "$h\->content_length" 4
.el .IP "\f(CW$h\fR\->content_length" 4
.IX Item "$h->content_length"
A decimal number indicating the size in bytes of the message content.
.ie n .IP "$h\->content_language" 4
.el .IP "\f(CW$h\fR\->content_language" 4
.IX Item "$h->content_language"
The natural language(s) of the intended audience for the message
content.  The value is one or more language tags as defined by \s-1RFC
1766. \s0 Eg. \*(L"no\*(R" for some kind of Norwegian and \*(L"en-US\*(R" for English the
way it is written in the \s-1US.\s0
.ie n .IP "$h\->title" 4
.el .IP "\f(CW$h\fR\->title" 4
.IX Item "$h->title"
The title of the document.  In libwww-perl this header will be
initialized automatically from the <\s-1TITLE\s0>...</TITLE> element
of \s-1HTML\s0 documents.  \fIThis header is no longer part of the \s-1HTTP\s0
standard.\fR
.ie n .IP "$h\->user_agent" 4
.el .IP "\f(CW$h\fR\->user_agent" 4
.IX Item "$h->user_agent"
This header field is used in request messages and contains information
about the user agent originating the request.  \fIE.g.\fR:
.Sp
.Vb 1
\&  $h\->user_agent(\*(AqMozilla/5.0 (compatible; MSIE 7.0; Windows NT 6.0)\*(Aq);
.Ve
.ie n .IP "$h\->server" 4
.el .IP "\f(CW$h\fR\->server" 4
.IX Item "$h->server"
The server header field contains information about the software being
used by the originating server program handling the request.
.ie n .IP "$h\->from" 4
.el .IP "\f(CW$h\fR\->from" 4
.IX Item "$h->from"
This header should contain an Internet e\-mail address for the human
user who controls the requesting user agent.  The address should be
machine-usable, as defined by \s-1RFC822.  E\s0.g.:
.Sp
.Vb 1
\&  $h\->from(\*(AqKing Kong <king@kong.com>\*(Aq);
.Ve
.Sp
\&\fIThis header is no longer part of the \s-1HTTP\s0 standard.\fR
.ie n .IP "$h\->referer" 4
.el .IP "\f(CW$h\fR\->referer" 4
.IX Item "$h->referer"
Used to specify the address (\s-1URI\s0) of the document from which the
requested resource address was obtained.
.Sp
The \*(L"Free On-line Dictionary of Computing\*(R" as this to say about the
word \fIreferer\fR:
.Sp
.Vb 6
\&     <World\-Wide Web> A misspelling of "referrer" which
\&     somehow made it into the {HTTP} standard.  A given {web
\&     page}\*(Aqs referer (sic) is the {URL} of whatever web page
\&     contains the link that the user followed to the current
\&     page.  Most browsers pass this information as part of a
\&     request.
\&
\&     (1998\-10\-19)
.Ve
.Sp
By popular demand \f(CW\*(C`referrer\*(C'\fR exists as an alias for this method so you
can avoid this misspelling in your programs and still send the right
thing on the wire.
.Sp
When setting the referrer, this method removes the fragment from the
given \s-1URI\s0 if it is present, as mandated by \s-1RFC2616. \s0 Note that
the removal does \fInot\fR happen automatically if using the \fIheader()\fR,
\&\fIpush_header()\fR or \fIinit_header()\fR methods to set the referrer.
.ie n .IP "$h\->www_authenticate" 4
.el .IP "\f(CW$h\fR\->www_authenticate" 4
.IX Item "$h->www_authenticate"
This header must be included as part of a \f(CW\*(C`401 Unauthorized\*(C'\fR response.
The field value consist of a challenge that indicates the
authentication scheme and parameters applicable to the requested \s-1URI.\s0
.ie n .IP "$h\->proxy_authenticate" 4
.el .IP "\f(CW$h\fR\->proxy_authenticate" 4
.IX Item "$h->proxy_authenticate"
This header must be included in a \f(CW\*(C`407 Proxy Authentication Required\*(C'\fR
response.
.ie n .IP "$h\->authorization" 4
.el .IP "\f(CW$h\fR\->authorization" 4
.IX Item "$h->authorization"
.PD 0
.ie n .IP "$h\->proxy_authorization" 4
.el .IP "\f(CW$h\fR\->proxy_authorization" 4
.IX Item "$h->proxy_authorization"
.PD
A user agent that wishes to authenticate itself with a server or a
proxy, may do so by including these headers.
.ie n .IP "$h\->authorization_basic" 4
.el .IP "\f(CW$h\fR\->authorization_basic" 4
.IX Item "$h->authorization_basic"
This method is used to get or set an authorization header that use the
\&\*(L"Basic Authentication Scheme\*(R".  In array context it will return two
values; the user name and the password.  In scalar context it will
return \fI\*(L"uname:password\*(R"\fR as a single string value.
.Sp
When used to set the header value, it expects two arguments.  \fIE.g.\fR:
.Sp
.Vb 1
\&  $h\->authorization_basic($uname, $password);
.Ve
.Sp
The method will croak if the \f(CW$uname\fR contains a colon ':'.
.ie n .IP "$h\->proxy_authorization_basic" 4
.el .IP "\f(CW$h\fR\->proxy_authorization_basic" 4
.IX Item "$h->proxy_authorization_basic"
Same as \fIauthorization_basic()\fR but will set the \*(L"Proxy-Authorization\*(R"
header instead.
.SH "NON-CANONICALIZED FIELD NAMES"
.IX Header "NON-CANONICALIZED FIELD NAMES"
The header field name spelling is normally canonicalized including the
\&'_' to '\-' translation.  There are some application where this is not
appropriate.  Prefixing field names with ':' allow you to force a
specific spelling.  For example if you really want a header field name
to show up as \f(CW\*(C`foo_bar\*(C'\fR instead of \*(L"Foo-Bar\*(R", you might set it like
this:
.PP
.Vb 1
\&  $h\->header(":foo_bar" => 1);
.Ve
.PP
These field names are returned with the ':' intact for
\&\f(CW$h\fR\->header_field_names and the \f(CW$h\fR\->scan callback, but the colons do
not show in \f(CW$h\fR\->as_string.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2005 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Headers::Util.3pm                      0100644 0001750 0001750 00000017212 12566241314 024561  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Headers::Util 3"
.TH HTTP::Headers::Util 3 "2012-02-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Headers::Util \- Header value parsing utility functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use HTTP::Headers::Util qw(split_header_words);
\&  @values = split_header_words($h\->header("Content\-Type"));
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a few functions that helps parsing and
construction of valid \s-1HTTP\s0 header values.  None of the functions are
exported by default.
.PP
The following functions are available:
.ie n .IP "split_header_words( @header_values )" 4
.el .IP "split_header_words( \f(CW@header_values\fR )" 4
.IX Item "split_header_words( @header_values )"
This function will parse the header values given as argument into a
list of anonymous arrays containing key/value pairs.  The function
knows how to deal with \*(L",\*(R", \*(L";\*(R" and \*(L"=\*(R" as well as quoted values after
\&\*(L"=\*(R".  A list of space separated tokens are parsed as if they were
separated by \*(L";\*(R".
.Sp
If the \f(CW@header_values\fR passed as argument contains multiple values,
then they are treated as if they were a single value separated by
comma \*(L",\*(R".
.Sp
This means that this function is useful for parsing header fields that
follow this syntax (\s-1BNF\s0 as from the \s-1HTTP/1.1\s0 specification, but we relax
the requirement for tokens).
.Sp
.Vb 2
\&  headers           = #header
\&  header            = (token | parameter) *( [";"] (token | parameter))
\&
\&  token             = 1*<any CHAR except CTLs or separators>
\&  separators        = "(" | ")" | "<" | ">" | "@"
\&                    | "," | ";" | ":" | "\e" | <">
\&                    | "/" | "[" | "]" | "?" | "="
\&                    | "{" | "}" | SP | HT
\&
\&  quoted\-string     = ( <"> *(qdtext | quoted\-pair ) <"> )
\&  qdtext            = <any TEXT except <">>
\&  quoted\-pair       = "\e" CHAR
\&
\&  parameter         = attribute "=" value
\&  attribute         = token
\&  value             = token | quoted\-string
.Ve
.Sp
Each \fIheader\fR is represented by an anonymous array of key/value
pairs.  The keys will be all be forced to lower case.
The value for a simple token (not part of a parameter) is \f(CW\*(C`undef\*(C'\fR.
Syntactically incorrect headers will not necessarily be parsed as you
would want.
.Sp
This is easier to describe with some examples:
.Sp
.Vb 3
\&   split_header_words(\*(Aqfoo="bar"; port="80,81"; DISCARD, BAR=baz\*(Aq);
\&   split_header_words(\*(Aqtext/html; charset="iso\-8859\-1"\*(Aq);
\&   split_header_words(\*(AqBasic realm="\e\e"foo\e\e\e\ebar\e\e""\*(Aq);
.Ve
.Sp
will return
.Sp
.Vb 3
\&   [foo=>\*(Aqbar\*(Aq, port=>\*(Aq80,81\*(Aq, discard=> undef], [bar=>\*(Aqbaz\*(Aq ]
\&   [\*(Aqtext/html\*(Aq => undef, charset => \*(Aqiso\-8859\-1\*(Aq]
\&   [basic => undef, realm => "\e"foo\e\ebar\e""]
.Ve
.Sp
If you don't want the function to convert tokens and attribute keys to
lower case you can call it as \f(CW\*(C`_split_header_words\*(C'\fR instead (with a
leading underscore).
.ie n .IP "join_header_words( @arrays )" 4
.el .IP "join_header_words( \f(CW@arrays\fR )" 4
.IX Item "join_header_words( @arrays )"
This will do the opposite of the conversion done by \fIsplit_header_words()\fR.
It takes a list of anonymous arrays as arguments (or a list of
key/value pairs) and produces a single header value.  Attribute values
are quoted if needed.
.Sp
Example:
.Sp
.Vb 2
\&   join_header_words(["text/plain" => undef, charset => "iso\-8859/1"]);
\&   join_header_words("text/plain" => undef, charset => "iso\-8859/1");
.Ve
.Sp
will both return the string:
.Sp
.Vb 1
\&   text/plain; charset="iso\-8859/1"
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1997\-1998, Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Headers::Util5.16.3pm                  0100644 0001750 0001750 00000016671 12566241314 025103  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Headers::Util 3"
.TH HTTP::Headers::Util 3 "2012-02-16" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Headers::Util \- Header value parsing utility functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use HTTP::Headers::Util qw(split_header_words);
\&  @values = split_header_words($h\->header("Content\-Type"));
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a few functions that helps parsing and
construction of valid \s-1HTTP\s0 header values.  None of the functions are
exported by default.
.PP
The following functions are available:
.ie n .IP "split_header_words( @header_values )" 4
.el .IP "split_header_words( \f(CW@header_values\fR )" 4
.IX Item "split_header_words( @header_values )"
This function will parse the header values given as argument into a
list of anonymous arrays containing key/value pairs.  The function
knows how to deal with \*(L",\*(R", \*(L";\*(R" and \*(L"=\*(R" as well as quoted values after
\&\*(L"=\*(R".  A list of space separated tokens are parsed as if they were
separated by \*(L";\*(R".
.Sp
If the \f(CW@header_values\fR passed as argument contains multiple values,
then they are treated as if they were a single value separated by
comma \*(L",\*(R".
.Sp
This means that this function is useful for parsing header fields that
follow this syntax (\s-1BNF\s0 as from the \s-1HTTP/1\s0.1 specification, but we relax
the requirement for tokens).
.Sp
.Vb 2
\&  headers           = #header
\&  header            = (token | parameter) *( [";"] (token | parameter))
\&
\&  token             = 1*<any CHAR except CTLs or separators>
\&  separators        = "(" | ")" | "<" | ">" | "@"
\&                    | "," | ";" | ":" | "\e" | <">
\&                    | "/" | "[" | "]" | "?" | "="
\&                    | "{" | "}" | SP | HT
\&
\&  quoted\-string     = ( <"> *(qdtext | quoted\-pair ) <"> )
\&  qdtext            = <any TEXT except <">>
\&  quoted\-pair       = "\e" CHAR
\&
\&  parameter         = attribute "=" value
\&  attribute         = token
\&  value             = token | quoted\-string
.Ve
.Sp
Each \fIheader\fR is represented by an anonymous array of key/value
pairs.  The keys will be all be forced to lower case.
The value for a simple token (not part of a parameter) is \f(CW\*(C`undef\*(C'\fR.
Syntactically incorrect headers will not necessarily be parsed as you
would want.
.Sp
This is easier to describe with some examples:
.Sp
.Vb 3
\&   split_header_words(\*(Aqfoo="bar"; port="80,81"; DISCARD, BAR=baz\*(Aq);
\&   split_header_words(\*(Aqtext/html; charset="iso\-8859\-1"\*(Aq);
\&   split_header_words(\*(AqBasic realm="\e\e"foo\e\e\e\ebar\e\e""\*(Aq);
.Ve
.Sp
will return
.Sp
.Vb 3
\&   [foo=>\*(Aqbar\*(Aq, port=>\*(Aq80,81\*(Aq, discard=> undef], [bar=>\*(Aqbaz\*(Aq ]
\&   [\*(Aqtext/html\*(Aq => undef, charset => \*(Aqiso\-8859\-1\*(Aq]
\&   [basic => undef, realm => "\e"foo\e\ebar\e""]
.Ve
.Sp
If you don't want the function to convert tokens and attribute keys to
lower case you can call it as \f(CW\*(C`_split_header_words\*(C'\fR instead (with a
leading underscore).
.ie n .IP "join_header_words( @arrays )" 4
.el .IP "join_header_words( \f(CW@arrays\fR )" 4
.IX Item "join_header_words( @arrays )"
This will do the opposite of the conversion done by \fIsplit_header_words()\fR.
It takes a list of anonymous arrays as arguments (or a list of
key/value pairs) and produces a single header value.  Attribute values
are quoted if needed.
.Sp
Example:
.Sp
.Vb 2
\&   join_header_words(["text/plain" => undef, charset => "iso\-8859/1"]);
\&   join_header_words("text/plain" => undef, charset => "iso\-8859/1");
.Ve
.Sp
will both return the string:
.Sp
.Vb 1
\&   text/plain; charset="iso\-8859/1"
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1997\-1998, Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Headers::Util5.18.3pm                  0100644 0001750 0001750 00000017212 12566241314 025075  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Headers::Util 3"
.TH HTTP::Headers::Util 3 "2012-02-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Headers::Util \- Header value parsing utility functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use HTTP::Headers::Util qw(split_header_words);
\&  @values = split_header_words($h\->header("Content\-Type"));
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a few functions that helps parsing and
construction of valid \s-1HTTP\s0 header values.  None of the functions are
exported by default.
.PP
The following functions are available:
.ie n .IP "split_header_words( @header_values )" 4
.el .IP "split_header_words( \f(CW@header_values\fR )" 4
.IX Item "split_header_words( @header_values )"
This function will parse the header values given as argument into a
list of anonymous arrays containing key/value pairs.  The function
knows how to deal with \*(L",\*(R", \*(L";\*(R" and \*(L"=\*(R" as well as quoted values after
\&\*(L"=\*(R".  A list of space separated tokens are parsed as if they were
separated by \*(L";\*(R".
.Sp
If the \f(CW@header_values\fR passed as argument contains multiple values,
then they are treated as if they were a single value separated by
comma \*(L",\*(R".
.Sp
This means that this function is useful for parsing header fields that
follow this syntax (\s-1BNF\s0 as from the \s-1HTTP/1.1\s0 specification, but we relax
the requirement for tokens).
.Sp
.Vb 2
\&  headers           = #header
\&  header            = (token | parameter) *( [";"] (token | parameter))
\&
\&  token             = 1*<any CHAR except CTLs or separators>
\&  separators        = "(" | ")" | "<" | ">" | "@"
\&                    | "," | ";" | ":" | "\e" | <">
\&                    | "/" | "[" | "]" | "?" | "="
\&                    | "{" | "}" | SP | HT
\&
\&  quoted\-string     = ( <"> *(qdtext | quoted\-pair ) <"> )
\&  qdtext            = <any TEXT except <">>
\&  quoted\-pair       = "\e" CHAR
\&
\&  parameter         = attribute "=" value
\&  attribute         = token
\&  value             = token | quoted\-string
.Ve
.Sp
Each \fIheader\fR is represented by an anonymous array of key/value
pairs.  The keys will be all be forced to lower case.
The value for a simple token (not part of a parameter) is \f(CW\*(C`undef\*(C'\fR.
Syntactically incorrect headers will not necessarily be parsed as you
would want.
.Sp
This is easier to describe with some examples:
.Sp
.Vb 3
\&   split_header_words(\*(Aqfoo="bar"; port="80,81"; DISCARD, BAR=baz\*(Aq);
\&   split_header_words(\*(Aqtext/html; charset="iso\-8859\-1"\*(Aq);
\&   split_header_words(\*(AqBasic realm="\e\e"foo\e\e\e\ebar\e\e""\*(Aq);
.Ve
.Sp
will return
.Sp
.Vb 3
\&   [foo=>\*(Aqbar\*(Aq, port=>\*(Aq80,81\*(Aq, discard=> undef], [bar=>\*(Aqbaz\*(Aq ]
\&   [\*(Aqtext/html\*(Aq => undef, charset => \*(Aqiso\-8859\-1\*(Aq]
\&   [basic => undef, realm => "\e"foo\e\ebar\e""]
.Ve
.Sp
If you don't want the function to convert tokens and attribute keys to
lower case you can call it as \f(CW\*(C`_split_header_words\*(C'\fR instead (with a
leading underscore).
.ie n .IP "join_header_words( @arrays )" 4
.el .IP "join_header_words( \f(CW@arrays\fR )" 4
.IX Item "join_header_words( @arrays )"
This will do the opposite of the conversion done by \fIsplit_header_words()\fR.
It takes a list of anonymous arrays as arguments (or a list of
key/value pairs) and produces a single header value.  Attribute values
are quoted if needed.
.Sp
Example:
.Sp
.Vb 2
\&   join_header_words(["text/plain" => undef, charset => "iso\-8859/1"]);
\&   join_header_words("text/plain" => undef, charset => "iso\-8859/1");
.Ve
.Sp
will both return the string:
.Sp
.Vb 1
\&   text/plain; charset="iso\-8859/1"
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1997\-1998, Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Message.3pm                            0100644 0001750 0001750 00000046004 12566241314 023551  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Message 3"
.TH HTTP::Message 3 "2012-10-20" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Message \- HTTP style message (base class)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use base \*(AqHTTP::Message\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An \f(CW\*(C`HTTP::Message\*(C'\fR object contains some headers and a content body.
The following methods are available:
.ie n .IP "$mess = HTTP::Message\->new" 4
.el .IP "\f(CW$mess\fR = HTTP::Message\->new" 4
.IX Item "$mess = HTTP::Message->new"
.PD 0
.ie n .IP "$mess = HTTP::Message\->new( $headers )" 4
.el .IP "\f(CW$mess\fR = HTTP::Message\->new( \f(CW$headers\fR )" 4
.IX Item "$mess = HTTP::Message->new( $headers )"
.ie n .IP "$mess = HTTP::Message\->new( $headers, $content )" 4
.el .IP "\f(CW$mess\fR = HTTP::Message\->new( \f(CW$headers\fR, \f(CW$content\fR )" 4
.IX Item "$mess = HTTP::Message->new( $headers, $content )"
.PD
This constructs a new message object.  Normally you would want
construct \f(CW\*(C`HTTP::Request\*(C'\fR or \f(CW\*(C`HTTP::Response\*(C'\fR objects instead.
.Sp
The optional \f(CW$header\fR argument should be a reference to an
\&\f(CW\*(C`HTTP::Headers\*(C'\fR object or a plain array reference of key/value pairs.
If an \f(CW\*(C`HTTP::Headers\*(C'\fR object is provided then a copy of it will be
embedded into the constructed message, i.e. it will not be owned and
can be modified afterwards without affecting the message.
.Sp
The optional \f(CW$content\fR argument should be a string of bytes.
.ie n .IP "$mess = HTTP::Message\->parse( $str )" 4
.el .IP "\f(CW$mess\fR = HTTP::Message\->parse( \f(CW$str\fR )" 4
.IX Item "$mess = HTTP::Message->parse( $str )"
This constructs a new message object by parsing the given string.
.ie n .IP "$mess\->headers" 4
.el .IP "\f(CW$mess\fR\->headers" 4
.IX Item "$mess->headers"
Returns the embedded \f(CW\*(C`HTTP::Headers\*(C'\fR object.
.ie n .IP "$mess\->headers_as_string" 4
.el .IP "\f(CW$mess\fR\->headers_as_string" 4
.IX Item "$mess->headers_as_string"
.PD 0
.ie n .IP "$mess\->headers_as_string( $eol )" 4
.el .IP "\f(CW$mess\fR\->headers_as_string( \f(CW$eol\fR )" 4
.IX Item "$mess->headers_as_string( $eol )"
.PD
Call the \fIas_string()\fR method for the headers in the
message.  This will be the same as
.Sp
.Vb 1
\&    $mess\->headers\->as_string
.Ve
.Sp
but it will make your program a whole character shorter :\-)
.ie n .IP "$mess\->content" 4
.el .IP "\f(CW$mess\fR\->content" 4
.IX Item "$mess->content"
.PD 0
.ie n .IP "$mess\->content( $bytes )" 4
.el .IP "\f(CW$mess\fR\->content( \f(CW$bytes\fR )" 4
.IX Item "$mess->content( $bytes )"
.PD
The \fIcontent()\fR method sets the raw content if an argument is given.  If no
argument is given the content is not touched.  In either case the
original raw content is returned.
.Sp
Note that the content should be a string of bytes.  Strings in perl
can contain characters outside the range of a byte.  The \f(CW\*(C`Encode\*(C'\fR
module can be used to turn such strings into a string of bytes.
.ie n .IP "$mess\->add_content( $bytes )" 4
.el .IP "\f(CW$mess\fR\->add_content( \f(CW$bytes\fR )" 4
.IX Item "$mess->add_content( $bytes )"
The \fIadd_content()\fR methods appends more data bytes to the end of the
current content buffer.
.ie n .IP "$mess\->add_content_utf8( $string )" 4
.el .IP "\f(CW$mess\fR\->add_content_utf8( \f(CW$string\fR )" 4
.IX Item "$mess->add_content_utf8( $string )"
The \fIadd_content_utf8()\fR method appends the \s-1UTF\-8\s0 bytes representing the
string to the end of the current content buffer.
.ie n .IP "$mess\->content_ref" 4
.el .IP "\f(CW$mess\fR\->content_ref" 4
.IX Item "$mess->content_ref"
.PD 0
.ie n .IP "$mess\->content_ref( \e$bytes )" 4
.el .IP "\f(CW$mess\fR\->content_ref( \e$bytes )" 4
.IX Item "$mess->content_ref( $bytes )"
.PD
The \fIcontent_ref()\fR method will return a reference to content buffer string.
It can be more efficient to access the content this way if the content
is huge, and it can even be used for direct manipulation of the content,
for instance:
.Sp
.Vb 1
\&  ${$res\->content_ref} =~ s/\ebfoo\eb/bar/g;
.Ve
.Sp
This example would modify the content buffer in-place.
.Sp
If an argument is passed it will setup the content to reference some
external source.  The \fIcontent()\fR and \fIadd_content()\fR methods
will automatically dereference scalar references passed this way.  For
other references \fIcontent()\fR will return the reference itself and
\&\fIadd_content()\fR will refuse to do anything.
.ie n .IP "$mess\->content_charset" 4
.el .IP "\f(CW$mess\fR\->content_charset" 4
.IX Item "$mess->content_charset"
This returns the charset used by the content in the message.  The
charset is either found as the charset attribute of the
\&\f(CW\*(C`Content\-Type\*(C'\fR header or by guessing.
.Sp
See <http://www.w3.org/TR/REC\-html40/charset.html#spec\-char\-encoding>
for details about how charset is determined.
.ie n .IP "$mess\->decoded_content( %options )" 4
.el .IP "\f(CW$mess\fR\->decoded_content( \f(CW%options\fR )" 4
.IX Item "$mess->decoded_content( %options )"
Returns the content with any \f(CW\*(C`Content\-Encoding\*(C'\fR undone and for textual content
the raw content encoded to Perl's Unicode strings.  If the \f(CW\*(C`Content\-Encoding\*(C'\fR
or \f(CW\*(C`charset\*(C'\fR of the message is unknown this method will fail by returning
\&\f(CW\*(C`undef\*(C'\fR.
.Sp
The following options can be specified.
.RS 4
.ie n .IP """charset""" 4
.el .IP "\f(CWcharset\fR" 4
.IX Item "charset"
This override the charset parameter for text content.  The value
\&\f(CW\*(C`none\*(C'\fR can used to suppress decoding of the charset.
.ie n .IP """default_charset""" 4
.el .IP "\f(CWdefault_charset\fR" 4
.IX Item "default_charset"
This override the default charset guessed by \fIcontent_charset()\fR or
if that fails \*(L"\s-1ISO\-8859\-1\*(R".\s0
.ie n .IP """alt_charset""" 4
.el .IP "\f(CWalt_charset\fR" 4
.IX Item "alt_charset"
If decoding fails because the charset specified in the Content-Type header
isn't recognized by Perl's Encode module, then try decoding using this charset
instead of failing.  The \f(CW\*(C`alt_charset\*(C'\fR might be specified as \f(CW\*(C`none\*(C'\fR to simply
return the string without any decoding of charset as alternative.
.ie n .IP """charset_strict""" 4
.el .IP "\f(CWcharset_strict\fR" 4
.IX Item "charset_strict"
Abort decoding if malformed characters is found in the content.  By
default you get the substitution character (\*(L"\ex{\s-1FFFD\s0}\*(R") in place of
malformed characters.
.ie n .IP """raise_error""" 4
.el .IP "\f(CWraise_error\fR" 4
.IX Item "raise_error"
If \s-1TRUE\s0 then raise an exception if not able to decode content.  Reason
might be that the specified \f(CW\*(C`Content\-Encoding\*(C'\fR or \f(CW\*(C`charset\*(C'\fR is not
supported.  If this option is \s-1FALSE,\s0 then \fIdecoded_content()\fR will return
\&\f(CW\*(C`undef\*(C'\fR on errors, but will still set $@.
.ie n .IP """ref""" 4
.el .IP "\f(CWref\fR" 4
.IX Item "ref"
If \s-1TRUE\s0 then a reference to decoded content is returned.  This might
be more efficient in cases where the decoded content is identical to
the raw content as no data copying is required in this case.
.RE
.RS 4
.RE
.ie n .IP "$mess\->decodable" 4
.el .IP "\f(CW$mess\fR\->decodable" 4
.IX Item "$mess->decodable"
.PD 0
.IP "\fIHTTP::Message::decodable()\fR" 4
.IX Item "HTTP::Message::decodable()"
.PD
This returns the encoding identifiers that \fIdecoded_content()\fR can
process.  In scalar context returns a comma separated string of
identifiers.
.Sp
This value is suitable for initializing the \f(CW\*(C`Accept\-Encoding\*(C'\fR request
header field.
.ie n .IP "$mess\->decode" 4
.el .IP "\f(CW$mess\fR\->decode" 4
.IX Item "$mess->decode"
This method tries to replace the content of the message with the
decoded version and removes the \f(CW\*(C`Content\-Encoding\*(C'\fR header.  Returns
\&\s-1TRUE\s0 if successful and \s-1FALSE\s0 if not.
.Sp
If the message does not have a \f(CW\*(C`Content\-Encoding\*(C'\fR header this method
does nothing and returns \s-1TRUE.\s0
.Sp
Note that the content of the message is still bytes after this method
has been called and you still need to call \fIdecoded_content()\fR if you
want to process its content as a string.
.ie n .IP "$mess\->encode( $encoding, ... )" 4
.el .IP "\f(CW$mess\fR\->encode( \f(CW$encoding\fR, ... )" 4
.IX Item "$mess->encode( $encoding, ... )"
Apply the given encodings to the content of the message.  Returns \s-1TRUE\s0
if successful. The \*(L"identity\*(R" (non\-)encoding is always supported; other
currently supported encodings, subject to availability of required
additional modules, are \*(L"gzip\*(R", \*(L"deflate\*(R", \*(L"x\-bzip2\*(R" and \*(L"base64\*(R".
.Sp
A successful call to this function will set the \f(CW\*(C`Content\-Encoding\*(C'\fR
header.
.Sp
Note that \f(CW\*(C`multipart/*\*(C'\fR or \f(CW\*(C`message/*\*(C'\fR messages can't be encoded and
this method will croak if you try.
.ie n .IP "$mess\->parts" 4
.el .IP "\f(CW$mess\fR\->parts" 4
.IX Item "$mess->parts"
.PD 0
.ie n .IP "$mess\->parts( @parts )" 4
.el .IP "\f(CW$mess\fR\->parts( \f(CW@parts\fR )" 4
.IX Item "$mess->parts( @parts )"
.ie n .IP "$mess\->parts( \e@parts )" 4
.el .IP "\f(CW$mess\fR\->parts( \e@parts )" 4
.IX Item "$mess->parts( @parts )"
.PD
Messages can be composite, i.e. contain other messages.  The composite
messages have a content type of \f(CW\*(C`multipart/*\*(C'\fR or \f(CW\*(C`message/*\*(C'\fR.  This
method give access to the contained messages.
.Sp
The argumentless form will return a list of \f(CW\*(C`HTTP::Message\*(C'\fR objects.
If the content type of \f(CW$msg\fR is not \f(CW\*(C`multipart/*\*(C'\fR or \f(CW\*(C`message/*\*(C'\fR then
this will return the empty list.  In scalar context only the first
object is returned.  The returned message parts should be regarded as
read-only (future versions of this library might make it possible
to modify the parent by modifying the parts).
.Sp
If the content type of \f(CW$msg\fR is \f(CW\*(C`message/*\*(C'\fR then there will only be
one part returned.
.Sp
If the content type is \f(CW\*(C`message/http\*(C'\fR, then the return value will be
either an \f(CW\*(C`HTTP::Request\*(C'\fR or an \f(CW\*(C`HTTP::Response\*(C'\fR object.
.Sp
If a \f(CW@parts\fR argument is given, then the content of the message will be
modified. The array reference form is provided so that an empty list
can be provided.  The \f(CW@parts\fR array should contain \f(CW\*(C`HTTP::Message\*(C'\fR
objects.  The \f(CW@parts\fR objects are owned by \f(CW$mess\fR after this call and
should not be modified or made part of other messages.
.Sp
When updating the message with this method and the old content type of
\&\f(CW$mess\fR is not \f(CW\*(C`multipart/*\*(C'\fR or \f(CW\*(C`message/*\*(C'\fR, then the content type is
set to \f(CW\*(C`multipart/mixed\*(C'\fR and all other content headers are cleared.
.Sp
This method will croak if the content type is \f(CW\*(C`message/*\*(C'\fR and more
than one part is provided.
.ie n .IP "$mess\->add_part( $part )" 4
.el .IP "\f(CW$mess\fR\->add_part( \f(CW$part\fR )" 4
.IX Item "$mess->add_part( $part )"
This will add a part to a message.  The \f(CW$part\fR argument should be
another \f(CW\*(C`HTTP::Message\*(C'\fR object.  If the previous content type of
\&\f(CW$mess\fR is not \f(CW\*(C`multipart/*\*(C'\fR then the old content (together with all
content headers) will be made part #1 and the content type made
\&\f(CW\*(C`multipart/mixed\*(C'\fR before the new part is added.  The \f(CW$part\fR object is
owned by \f(CW$mess\fR after this call and should not be modified or made part
of other messages.
.Sp
There is no return value.
.ie n .IP "$mess\->clear" 4
.el .IP "\f(CW$mess\fR\->clear" 4
.IX Item "$mess->clear"
Will clear the headers and set the content to the empty string.  There
is no return value
.ie n .IP "$mess\->protocol" 4
.el .IP "\f(CW$mess\fR\->protocol" 4
.IX Item "$mess->protocol"
.PD 0
.ie n .IP "$mess\->protocol( $proto )" 4
.el .IP "\f(CW$mess\fR\->protocol( \f(CW$proto\fR )" 4
.IX Item "$mess->protocol( $proto )"
.PD
Sets the \s-1HTTP\s0 protocol used for the message.  The \fIprotocol()\fR is a string
like \f(CW\*(C`HTTP/1.0\*(C'\fR or \f(CW\*(C`HTTP/1.1\*(C'\fR.
.ie n .IP "$mess\->clone" 4
.el .IP "\f(CW$mess\fR\->clone" 4
.IX Item "$mess->clone"
Returns a copy of the message object.
.ie n .IP "$mess\->as_string" 4
.el .IP "\f(CW$mess\fR\->as_string" 4
.IX Item "$mess->as_string"
.PD 0
.ie n .IP "$mess\->as_string( $eol )" 4
.el .IP "\f(CW$mess\fR\->as_string( \f(CW$eol\fR )" 4
.IX Item "$mess->as_string( $eol )"
.PD
Returns the message formatted as a single string.
.Sp
The optional \f(CW$eol\fR parameter specifies the line ending sequence to use.
The default is \*(L"\en\*(R".  If no \f(CW$eol\fR is given then as_string will ensure
that the returned string is newline terminated (even when the message
content is not).  No extra newline is appended if an explicit \f(CW$eol\fR is
passed.
.ie n .IP "$mess\->dump( %opt )" 4
.el .IP "\f(CW$mess\fR\->dump( \f(CW%opt\fR )" 4
.IX Item "$mess->dump( %opt )"
Returns the message formatted as a string.  In void context print the string.
.Sp
This differs from \f(CW\*(C`$mess\->as_string\*(C'\fR in that it escapes the bytes
of the content so that it's safe to print them and it limits how much
content to print.  The escapes syntax used is the same as for Perl's
double quoted strings.  If there is no content the string \*(L"(no
content)\*(R" is shown in its place.
.Sp
Options to influence the output can be passed as key/value pairs. The
following options are recognized:
.RS 4
.ie n .IP "maxlength => $num" 4
.el .IP "maxlength => \f(CW$num\fR" 4
.IX Item "maxlength => $num"
How much of the content to show.  The default is 512.  Set this to 0
for unlimited.
.Sp
If the content is longer then the string is chopped at the limit and
the string \*(L"...\en(### more bytes not shown)\*(R" appended.
.ie n .IP "no_content => $str" 4
.el .IP "no_content => \f(CW$str\fR" 4
.IX Item "no_content => $str"
Replaces the \*(L"(no content)\*(R" marker.
.ie n .IP "prefix => $str" 4
.el .IP "prefix => \f(CW$str\fR" 4
.IX Item "prefix => $str"
A string that will be prefixed to each line of the dump.
.RE
.RS 4
.RE
.PP
All methods unknown to \f(CW\*(C`HTTP::Message\*(C'\fR itself are delegated to the
\&\f(CW\*(C`HTTP::Headers\*(C'\fR object that is part of every message.  This allows
convenient access to these methods.  Refer to HTTP::Headers for
details of these methods:
.PP
.Vb 7
\&    $mess\->header( $field => $val )
\&    $mess\->push_header( $field => $val )
\&    $mess\->init_header( $field => $val )
\&    $mess\->remove_header( $field )
\&    $mess\->remove_content_headers
\&    $mess\->header_field_names
\&    $mess\->scan( \e&doit )
\&
\&    $mess\->date
\&    $mess\->expires
\&    $mess\->if_modified_since
\&    $mess\->if_unmodified_since
\&    $mess\->last_modified
\&    $mess\->content_type
\&    $mess\->content_encoding
\&    $mess\->content_length
\&    $mess\->content_language
\&    $mess\->title
\&    $mess\->user_agent
\&    $mess\->server
\&    $mess\->from
\&    $mess\->referer
\&    $mess\->www_authenticate
\&    $mess\->authorization
\&    $mess\->proxy_authorization
\&    $mess\->authorization_basic
\&    $mess\->proxy_authorization_basic
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2004 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Message5.16.3pm                        0100644 0001750 0001750 00000045563 12566241314 024074  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Message 3"
.TH HTTP::Message 3 "2012-10-20" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Message \- HTTP style message (base class)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use base \*(AqHTTP::Message\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An \f(CW\*(C`HTTP::Message\*(C'\fR object contains some headers and a content body.
The following methods are available:
.ie n .IP "$mess = HTTP::Message\->new" 4
.el .IP "\f(CW$mess\fR = HTTP::Message\->new" 4
.IX Item "$mess = HTTP::Message->new"
.PD 0
.ie n .IP "$mess = HTTP::Message\->new( $headers )" 4
.el .IP "\f(CW$mess\fR = HTTP::Message\->new( \f(CW$headers\fR )" 4
.IX Item "$mess = HTTP::Message->new( $headers )"
.ie n .IP "$mess = HTTP::Message\->new( $headers, $content )" 4
.el .IP "\f(CW$mess\fR = HTTP::Message\->new( \f(CW$headers\fR, \f(CW$content\fR )" 4
.IX Item "$mess = HTTP::Message->new( $headers, $content )"
.PD
This constructs a new message object.  Normally you would want
construct \f(CW\*(C`HTTP::Request\*(C'\fR or \f(CW\*(C`HTTP::Response\*(C'\fR objects instead.
.Sp
The optional \f(CW$header\fR argument should be a reference to an
\&\f(CW\*(C`HTTP::Headers\*(C'\fR object or a plain array reference of key/value pairs.
If an \f(CW\*(C`HTTP::Headers\*(C'\fR object is provided then a copy of it will be
embedded into the constructed message, i.e. it will not be owned and
can be modified afterwards without affecting the message.
.Sp
The optional \f(CW$content\fR argument should be a string of bytes.
.ie n .IP "$mess = HTTP::Message\->parse( $str )" 4
.el .IP "\f(CW$mess\fR = HTTP::Message\->parse( \f(CW$str\fR )" 4
.IX Item "$mess = HTTP::Message->parse( $str )"
This constructs a new message object by parsing the given string.
.ie n .IP "$mess\->headers" 4
.el .IP "\f(CW$mess\fR\->headers" 4
.IX Item "$mess->headers"
Returns the embedded \f(CW\*(C`HTTP::Headers\*(C'\fR object.
.ie n .IP "$mess\->headers_as_string" 4
.el .IP "\f(CW$mess\fR\->headers_as_string" 4
.IX Item "$mess->headers_as_string"
.PD 0
.ie n .IP "$mess\->headers_as_string( $eol )" 4
.el .IP "\f(CW$mess\fR\->headers_as_string( \f(CW$eol\fR )" 4
.IX Item "$mess->headers_as_string( $eol )"
.PD
Call the \fIas_string()\fR method for the headers in the
message.  This will be the same as
.Sp
.Vb 1
\&    $mess\->headers\->as_string
.Ve
.Sp
but it will make your program a whole character shorter :\-)
.ie n .IP "$mess\->content" 4
.el .IP "\f(CW$mess\fR\->content" 4
.IX Item "$mess->content"
.PD 0
.ie n .IP "$mess\->content( $bytes )" 4
.el .IP "\f(CW$mess\fR\->content( \f(CW$bytes\fR )" 4
.IX Item "$mess->content( $bytes )"
.PD
The \fIcontent()\fR method sets the raw content if an argument is given.  If no
argument is given the content is not touched.  In either case the
original raw content is returned.
.Sp
Note that the content should be a string of bytes.  Strings in perl
can contain characters outside the range of a byte.  The \f(CW\*(C`Encode\*(C'\fR
module can be used to turn such strings into a string of bytes.
.ie n .IP "$mess\->add_content( $bytes )" 4
.el .IP "\f(CW$mess\fR\->add_content( \f(CW$bytes\fR )" 4
.IX Item "$mess->add_content( $bytes )"
The \fIadd_content()\fR methods appends more data bytes to the end of the
current content buffer.
.ie n .IP "$mess\->add_content_utf8( $string )" 4
.el .IP "\f(CW$mess\fR\->add_content_utf8( \f(CW$string\fR )" 4
.IX Item "$mess->add_content_utf8( $string )"
The \fIadd_content_utf8()\fR method appends the \s-1UTF\-8\s0 bytes representing the
string to the end of the current content buffer.
.ie n .IP "$mess\->content_ref" 4
.el .IP "\f(CW$mess\fR\->content_ref" 4
.IX Item "$mess->content_ref"
.PD 0
.ie n .IP "$mess\->content_ref( \e$bytes )" 4
.el .IP "\f(CW$mess\fR\->content_ref( \e$bytes )" 4
.IX Item "$mess->content_ref( $bytes )"
.PD
The \fIcontent_ref()\fR method will return a reference to content buffer string.
It can be more efficient to access the content this way if the content
is huge, and it can even be used for direct manipulation of the content,
for instance:
.Sp
.Vb 1
\&  ${$res\->content_ref} =~ s/\ebfoo\eb/bar/g;
.Ve
.Sp
This example would modify the content buffer in-place.
.Sp
If an argument is passed it will setup the content to reference some
external source.  The \fIcontent()\fR and \fIadd_content()\fR methods
will automatically dereference scalar references passed this way.  For
other references \fIcontent()\fR will return the reference itself and
\&\fIadd_content()\fR will refuse to do anything.
.ie n .IP "$mess\->content_charset" 4
.el .IP "\f(CW$mess\fR\->content_charset" 4
.IX Item "$mess->content_charset"
This returns the charset used by the content in the message.  The
charset is either found as the charset attribute of the
\&\f(CW\*(C`Content\-Type\*(C'\fR header or by guessing.
.Sp
See http://www.w3.org/TR/REC\-html40/charset.html#spec\-char\-encoding <http://www.w3.org/TR/REC-html40/charset.html#spec-char-encoding>
for details about how charset is determined.
.ie n .IP "$mess\->decoded_content( %options )" 4
.el .IP "\f(CW$mess\fR\->decoded_content( \f(CW%options\fR )" 4
.IX Item "$mess->decoded_content( %options )"
Returns the content with any \f(CW\*(C`Content\-Encoding\*(C'\fR undone and for textual content
the raw content encoded to Perl's Unicode strings.  If the \f(CW\*(C`Content\-Encoding\*(C'\fR
or \f(CW\*(C`charset\*(C'\fR of the message is unknown this method will fail by returning
\&\f(CW\*(C`undef\*(C'\fR.
.Sp
The following options can be specified.
.RS 4
.ie n .IP """charset""" 4
.el .IP "\f(CWcharset\fR" 4
.IX Item "charset"
This override the charset parameter for text content.  The value
\&\f(CW\*(C`none\*(C'\fR can used to suppress decoding of the charset.
.ie n .IP """default_charset""" 4
.el .IP "\f(CWdefault_charset\fR" 4
.IX Item "default_charset"
This override the default charset guessed by \fIcontent_charset()\fR or
if that fails \*(L"\s-1ISO\-8859\-1\s0\*(R".
.ie n .IP """alt_charset""" 4
.el .IP "\f(CWalt_charset\fR" 4
.IX Item "alt_charset"
If decoding fails because the charset specified in the Content-Type header
isn't recognized by Perl's Encode module, then try decoding using this charset
instead of failing.  The \f(CW\*(C`alt_charset\*(C'\fR might be specified as \f(CW\*(C`none\*(C'\fR to simply
return the string without any decoding of charset as alternative.
.ie n .IP """charset_strict""" 4
.el .IP "\f(CWcharset_strict\fR" 4
.IX Item "charset_strict"
Abort decoding if malformed characters is found in the content.  By
default you get the substitution character (\*(L"\ex{\s-1FFFD\s0}\*(R") in place of
malformed characters.
.ie n .IP """raise_error""" 4
.el .IP "\f(CWraise_error\fR" 4
.IX Item "raise_error"
If \s-1TRUE\s0 then raise an exception if not able to decode content.  Reason
might be that the specified \f(CW\*(C`Content\-Encoding\*(C'\fR or \f(CW\*(C`charset\*(C'\fR is not
supported.  If this option is \s-1FALSE\s0, then \fIdecoded_content()\fR will return
\&\f(CW\*(C`undef\*(C'\fR on errors, but will still set $@.
.ie n .IP """ref""" 4
.el .IP "\f(CWref\fR" 4
.IX Item "ref"
If \s-1TRUE\s0 then a reference to decoded content is returned.  This might
be more efficient in cases where the decoded content is identical to
the raw content as no data copying is required in this case.
.RE
.RS 4
.RE
.ie n .IP "$mess\->decodable" 4
.el .IP "\f(CW$mess\fR\->decodable" 4
.IX Item "$mess->decodable"
.PD 0
.IP "\fIHTTP::Message::decodable()\fR" 4
.IX Item "HTTP::Message::decodable()"
.PD
This returns the encoding identifiers that \fIdecoded_content()\fR can
process.  In scalar context returns a comma separated string of
identifiers.
.Sp
This value is suitable for initializing the \f(CW\*(C`Accept\-Encoding\*(C'\fR request
header field.
.ie n .IP "$mess\->decode" 4
.el .IP "\f(CW$mess\fR\->decode" 4
.IX Item "$mess->decode"
This method tries to replace the content of the message with the
decoded version and removes the \f(CW\*(C`Content\-Encoding\*(C'\fR header.  Returns
\&\s-1TRUE\s0 if successful and \s-1FALSE\s0 if not.
.Sp
If the message does not have a \f(CW\*(C`Content\-Encoding\*(C'\fR header this method
does nothing and returns \s-1TRUE\s0.
.Sp
Note that the content of the message is still bytes after this method
has been called and you still need to call \fIdecoded_content()\fR if you
want to process its content as a string.
.ie n .IP "$mess\->encode( $encoding, ... )" 4
.el .IP "\f(CW$mess\fR\->encode( \f(CW$encoding\fR, ... )" 4
.IX Item "$mess->encode( $encoding, ... )"
Apply the given encodings to the content of the message.  Returns \s-1TRUE\s0
if successful. The \*(L"identity\*(R" (non\-)encoding is always supported; other
currently supported encodings, subject to availability of required
additional modules, are \*(L"gzip\*(R", \*(L"deflate\*(R", \*(L"x\-bzip2\*(R" and \*(L"base64\*(R".
.Sp
A successful call to this function will set the \f(CW\*(C`Content\-Encoding\*(C'\fR
header.
.Sp
Note that \f(CW\*(C`multipart/*\*(C'\fR or \f(CW\*(C`message/*\*(C'\fR messages can't be encoded and
this method will croak if you try.
.ie n .IP "$mess\->parts" 4
.el .IP "\f(CW$mess\fR\->parts" 4
.IX Item "$mess->parts"
.PD 0
.ie n .IP "$mess\->parts( @parts )" 4
.el .IP "\f(CW$mess\fR\->parts( \f(CW@parts\fR )" 4
.IX Item "$mess->parts( @parts )"
.ie n .IP "$mess\->parts( \e@parts )" 4
.el .IP "\f(CW$mess\fR\->parts( \e@parts )" 4
.IX Item "$mess->parts( @parts )"
.PD
Messages can be composite, i.e. contain other messages.  The composite
messages have a content type of \f(CW\*(C`multipart/*\*(C'\fR or \f(CW\*(C`message/*\*(C'\fR.  This
method give access to the contained messages.
.Sp
The argumentless form will return a list of \f(CW\*(C`HTTP::Message\*(C'\fR objects.
If the content type of \f(CW$msg\fR is not \f(CW\*(C`multipart/*\*(C'\fR or \f(CW\*(C`message/*\*(C'\fR then
this will return the empty list.  In scalar context only the first
object is returned.  The returned message parts should be regarded as
read-only (future versions of this library might make it possible
to modify the parent by modifying the parts).
.Sp
If the content type of \f(CW$msg\fR is \f(CW\*(C`message/*\*(C'\fR then there will only be
one part returned.
.Sp
If the content type is \f(CW\*(C`message/http\*(C'\fR, then the return value will be
either an \f(CW\*(C`HTTP::Request\*(C'\fR or an \f(CW\*(C`HTTP::Response\*(C'\fR object.
.Sp
If a \f(CW@parts\fR argument is given, then the content of the message will be
modified. The array reference form is provided so that an empty list
can be provided.  The \f(CW@parts\fR array should contain \f(CW\*(C`HTTP::Message\*(C'\fR
objects.  The \f(CW@parts\fR objects are owned by \f(CW$mess\fR after this call and
should not be modified or made part of other messages.
.Sp
When updating the message with this method and the old content type of
\&\f(CW$mess\fR is not \f(CW\*(C`multipart/*\*(C'\fR or \f(CW\*(C`message/*\*(C'\fR, then the content type is
set to \f(CW\*(C`multipart/mixed\*(C'\fR and all other content headers are cleared.
.Sp
This method will croak if the content type is \f(CW\*(C`message/*\*(C'\fR and more
than one part is provided.
.ie n .IP "$mess\->add_part( $part )" 4
.el .IP "\f(CW$mess\fR\->add_part( \f(CW$part\fR )" 4
.IX Item "$mess->add_part( $part )"
This will add a part to a message.  The \f(CW$part\fR argument should be
another \f(CW\*(C`HTTP::Message\*(C'\fR object.  If the previous content type of
\&\f(CW$mess\fR is not \f(CW\*(C`multipart/*\*(C'\fR then the old content (together with all
content headers) will be made part #1 and the content type made
\&\f(CW\*(C`multipart/mixed\*(C'\fR before the new part is added.  The \f(CW$part\fR object is
owned by \f(CW$mess\fR after this call and should not be modified or made part
of other messages.
.Sp
There is no return value.
.ie n .IP "$mess\->clear" 4
.el .IP "\f(CW$mess\fR\->clear" 4
.IX Item "$mess->clear"
Will clear the headers and set the content to the empty string.  There
is no return value
.ie n .IP "$mess\->protocol" 4
.el .IP "\f(CW$mess\fR\->protocol" 4
.IX Item "$mess->protocol"
.PD 0
.ie n .IP "$mess\->protocol( $proto )" 4
.el .IP "\f(CW$mess\fR\->protocol( \f(CW$proto\fR )" 4
.IX Item "$mess->protocol( $proto )"
.PD
Sets the \s-1HTTP\s0 protocol used for the message.  The \fIprotocol()\fR is a string
like \f(CW\*(C`HTTP/1.0\*(C'\fR or \f(CW\*(C`HTTP/1.1\*(C'\fR.
.ie n .IP "$mess\->clone" 4
.el .IP "\f(CW$mess\fR\->clone" 4
.IX Item "$mess->clone"
Returns a copy of the message object.
.ie n .IP "$mess\->as_string" 4
.el .IP "\f(CW$mess\fR\->as_string" 4
.IX Item "$mess->as_string"
.PD 0
.ie n .IP "$mess\->as_string( $eol )" 4
.el .IP "\f(CW$mess\fR\->as_string( \f(CW$eol\fR )" 4
.IX Item "$mess->as_string( $eol )"
.PD
Returns the message formatted as a single string.
.Sp
The optional \f(CW$eol\fR parameter specifies the line ending sequence to use.
The default is \*(L"\en\*(R".  If no \f(CW$eol\fR is given then as_string will ensure
that the returned string is newline terminated (even when the message
content is not).  No extra newline is appended if an explicit \f(CW$eol\fR is
passed.
.ie n .IP "$mess\->dump( %opt )" 4
.el .IP "\f(CW$mess\fR\->dump( \f(CW%opt\fR )" 4
.IX Item "$mess->dump( %opt )"
Returns the message formatted as a string.  In void context print the string.
.Sp
This differs from \f(CW\*(C`$mess\->as_string\*(C'\fR in that it escapes the bytes
of the content so that it's safe to print them and it limits how much
content to print.  The escapes syntax used is the same as for Perl's
double quoted strings.  If there is no content the string \*(L"(no
content)\*(R" is shown in its place.
.Sp
Options to influence the output can be passed as key/value pairs. The
following options are recognized:
.RS 4
.ie n .IP "maxlength => $num" 4
.el .IP "maxlength => \f(CW$num\fR" 4
.IX Item "maxlength => $num"
How much of the content to show.  The default is 512.  Set this to 0
for unlimited.
.Sp
If the content is longer then the string is chopped at the limit and
the string \*(L"...\en(### more bytes not shown)\*(R" appended.
.ie n .IP "no_content => $str" 4
.el .IP "no_content => \f(CW$str\fR" 4
.IX Item "no_content => $str"
Replaces the \*(L"(no content)\*(R" marker.
.ie n .IP "prefix => $str" 4
.el .IP "prefix => \f(CW$str\fR" 4
.IX Item "prefix => $str"
A string that will be prefixed to each line of the dump.
.RE
.RS 4
.RE
.PP
All methods unknown to \f(CW\*(C`HTTP::Message\*(C'\fR itself are delegated to the
\&\f(CW\*(C`HTTP::Headers\*(C'\fR object that is part of every message.  This allows
convenient access to these methods.  Refer to HTTP::Headers for
details of these methods:
.PP
.Vb 7
\&    $mess\->header( $field => $val )
\&    $mess\->push_header( $field => $val )
\&    $mess\->init_header( $field => $val )
\&    $mess\->remove_header( $field )
\&    $mess\->remove_content_headers
\&    $mess\->header_field_names
\&    $mess\->scan( \e&doit )
\&
\&    $mess\->date
\&    $mess\->expires
\&    $mess\->if_modified_since
\&    $mess\->if_unmodified_since
\&    $mess\->last_modified
\&    $mess\->content_type
\&    $mess\->content_encoding
\&    $mess\->content_length
\&    $mess\->content_language
\&    $mess\->title
\&    $mess\->user_agent
\&    $mess\->server
\&    $mess\->from
\&    $mess\->referer
\&    $mess\->www_authenticate
\&    $mess\->authorization
\&    $mess\->proxy_authorization
\&    $mess\->authorization_basic
\&    $mess\->proxy_authorization_basic
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2004 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Message5.18.3pm                        0100644 0001750 0001750 00000046004 12566241314 024065  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Message 3"
.TH HTTP::Message 3 "2012-10-20" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Message \- HTTP style message (base class)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use base \*(AqHTTP::Message\*(Aq;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An \f(CW\*(C`HTTP::Message\*(C'\fR object contains some headers and a content body.
The following methods are available:
.ie n .IP "$mess = HTTP::Message\->new" 4
.el .IP "\f(CW$mess\fR = HTTP::Message\->new" 4
.IX Item "$mess = HTTP::Message->new"
.PD 0
.ie n .IP "$mess = HTTP::Message\->new( $headers )" 4
.el .IP "\f(CW$mess\fR = HTTP::Message\->new( \f(CW$headers\fR )" 4
.IX Item "$mess = HTTP::Message->new( $headers )"
.ie n .IP "$mess = HTTP::Message\->new( $headers, $content )" 4
.el .IP "\f(CW$mess\fR = HTTP::Message\->new( \f(CW$headers\fR, \f(CW$content\fR )" 4
.IX Item "$mess = HTTP::Message->new( $headers, $content )"
.PD
This constructs a new message object.  Normally you would want
construct \f(CW\*(C`HTTP::Request\*(C'\fR or \f(CW\*(C`HTTP::Response\*(C'\fR objects instead.
.Sp
The optional \f(CW$header\fR argument should be a reference to an
\&\f(CW\*(C`HTTP::Headers\*(C'\fR object or a plain array reference of key/value pairs.
If an \f(CW\*(C`HTTP::Headers\*(C'\fR object is provided then a copy of it will be
embedded into the constructed message, i.e. it will not be owned and
can be modified afterwards without affecting the message.
.Sp
The optional \f(CW$content\fR argument should be a string of bytes.
.ie n .IP "$mess = HTTP::Message\->parse( $str )" 4
.el .IP "\f(CW$mess\fR = HTTP::Message\->parse( \f(CW$str\fR )" 4
.IX Item "$mess = HTTP::Message->parse( $str )"
This constructs a new message object by parsing the given string.
.ie n .IP "$mess\->headers" 4
.el .IP "\f(CW$mess\fR\->headers" 4
.IX Item "$mess->headers"
Returns the embedded \f(CW\*(C`HTTP::Headers\*(C'\fR object.
.ie n .IP "$mess\->headers_as_string" 4
.el .IP "\f(CW$mess\fR\->headers_as_string" 4
.IX Item "$mess->headers_as_string"
.PD 0
.ie n .IP "$mess\->headers_as_string( $eol )" 4
.el .IP "\f(CW$mess\fR\->headers_as_string( \f(CW$eol\fR )" 4
.IX Item "$mess->headers_as_string( $eol )"
.PD
Call the \fIas_string()\fR method for the headers in the
message.  This will be the same as
.Sp
.Vb 1
\&    $mess\->headers\->as_string
.Ve
.Sp
but it will make your program a whole character shorter :\-)
.ie n .IP "$mess\->content" 4
.el .IP "\f(CW$mess\fR\->content" 4
.IX Item "$mess->content"
.PD 0
.ie n .IP "$mess\->content( $bytes )" 4
.el .IP "\f(CW$mess\fR\->content( \f(CW$bytes\fR )" 4
.IX Item "$mess->content( $bytes )"
.PD
The \fIcontent()\fR method sets the raw content if an argument is given.  If no
argument is given the content is not touched.  In either case the
original raw content is returned.
.Sp
Note that the content should be a string of bytes.  Strings in perl
can contain characters outside the range of a byte.  The \f(CW\*(C`Encode\*(C'\fR
module can be used to turn such strings into a string of bytes.
.ie n .IP "$mess\->add_content( $bytes )" 4
.el .IP "\f(CW$mess\fR\->add_content( \f(CW$bytes\fR )" 4
.IX Item "$mess->add_content( $bytes )"
The \fIadd_content()\fR methods appends more data bytes to the end of the
current content buffer.
.ie n .IP "$mess\->add_content_utf8( $string )" 4
.el .IP "\f(CW$mess\fR\->add_content_utf8( \f(CW$string\fR )" 4
.IX Item "$mess->add_content_utf8( $string )"
The \fIadd_content_utf8()\fR method appends the \s-1UTF\-8\s0 bytes representing the
string to the end of the current content buffer.
.ie n .IP "$mess\->content_ref" 4
.el .IP "\f(CW$mess\fR\->content_ref" 4
.IX Item "$mess->content_ref"
.PD 0
.ie n .IP "$mess\->content_ref( \e$bytes )" 4
.el .IP "\f(CW$mess\fR\->content_ref( \e$bytes )" 4
.IX Item "$mess->content_ref( $bytes )"
.PD
The \fIcontent_ref()\fR method will return a reference to content buffer string.
It can be more efficient to access the content this way if the content
is huge, and it can even be used for direct manipulation of the content,
for instance:
.Sp
.Vb 1
\&  ${$res\->content_ref} =~ s/\ebfoo\eb/bar/g;
.Ve
.Sp
This example would modify the content buffer in-place.
.Sp
If an argument is passed it will setup the content to reference some
external source.  The \fIcontent()\fR and \fIadd_content()\fR methods
will automatically dereference scalar references passed this way.  For
other references \fIcontent()\fR will return the reference itself and
\&\fIadd_content()\fR will refuse to do anything.
.ie n .IP "$mess\->content_charset" 4
.el .IP "\f(CW$mess\fR\->content_charset" 4
.IX Item "$mess->content_charset"
This returns the charset used by the content in the message.  The
charset is either found as the charset attribute of the
\&\f(CW\*(C`Content\-Type\*(C'\fR header or by guessing.
.Sp
See <http://www.w3.org/TR/REC\-html40/charset.html#spec\-char\-encoding>
for details about how charset is determined.
.ie n .IP "$mess\->decoded_content( %options )" 4
.el .IP "\f(CW$mess\fR\->decoded_content( \f(CW%options\fR )" 4
.IX Item "$mess->decoded_content( %options )"
Returns the content with any \f(CW\*(C`Content\-Encoding\*(C'\fR undone and for textual content
the raw content encoded to Perl's Unicode strings.  If the \f(CW\*(C`Content\-Encoding\*(C'\fR
or \f(CW\*(C`charset\*(C'\fR of the message is unknown this method will fail by returning
\&\f(CW\*(C`undef\*(C'\fR.
.Sp
The following options can be specified.
.RS 4
.ie n .IP """charset""" 4
.el .IP "\f(CWcharset\fR" 4
.IX Item "charset"
This override the charset parameter for text content.  The value
\&\f(CW\*(C`none\*(C'\fR can used to suppress decoding of the charset.
.ie n .IP """default_charset""" 4
.el .IP "\f(CWdefault_charset\fR" 4
.IX Item "default_charset"
This override the default charset guessed by \fIcontent_charset()\fR or
if that fails \*(L"\s-1ISO\-8859\-1\*(R".\s0
.ie n .IP """alt_charset""" 4
.el .IP "\f(CWalt_charset\fR" 4
.IX Item "alt_charset"
If decoding fails because the charset specified in the Content-Type header
isn't recognized by Perl's Encode module, then try decoding using this charset
instead of failing.  The \f(CW\*(C`alt_charset\*(C'\fR might be specified as \f(CW\*(C`none\*(C'\fR to simply
return the string without any decoding of charset as alternative.
.ie n .IP """charset_strict""" 4
.el .IP "\f(CWcharset_strict\fR" 4
.IX Item "charset_strict"
Abort decoding if malformed characters is found in the content.  By
default you get the substitution character (\*(L"\ex{\s-1FFFD\s0}\*(R") in place of
malformed characters.
.ie n .IP """raise_error""" 4
.el .IP "\f(CWraise_error\fR" 4
.IX Item "raise_error"
If \s-1TRUE\s0 then raise an exception if not able to decode content.  Reason
might be that the specified \f(CW\*(C`Content\-Encoding\*(C'\fR or \f(CW\*(C`charset\*(C'\fR is not
supported.  If this option is \s-1FALSE,\s0 then \fIdecoded_content()\fR will return
\&\f(CW\*(C`undef\*(C'\fR on errors, but will still set $@.
.ie n .IP """ref""" 4
.el .IP "\f(CWref\fR" 4
.IX Item "ref"
If \s-1TRUE\s0 then a reference to decoded content is returned.  This might
be more efficient in cases where the decoded content is identical to
the raw content as no data copying is required in this case.
.RE
.RS 4
.RE
.ie n .IP "$mess\->decodable" 4
.el .IP "\f(CW$mess\fR\->decodable" 4
.IX Item "$mess->decodable"
.PD 0
.IP "\fIHTTP::Message::decodable()\fR" 4
.IX Item "HTTP::Message::decodable()"
.PD
This returns the encoding identifiers that \fIdecoded_content()\fR can
process.  In scalar context returns a comma separated string of
identifiers.
.Sp
This value is suitable for initializing the \f(CW\*(C`Accept\-Encoding\*(C'\fR request
header field.
.ie n .IP "$mess\->decode" 4
.el .IP "\f(CW$mess\fR\->decode" 4
.IX Item "$mess->decode"
This method tries to replace the content of the message with the
decoded version and removes the \f(CW\*(C`Content\-Encoding\*(C'\fR header.  Returns
\&\s-1TRUE\s0 if successful and \s-1FALSE\s0 if not.
.Sp
If the message does not have a \f(CW\*(C`Content\-Encoding\*(C'\fR header this method
does nothing and returns \s-1TRUE.\s0
.Sp
Note that the content of the message is still bytes after this method
has been called and you still need to call \fIdecoded_content()\fR if you
want to process its content as a string.
.ie n .IP "$mess\->encode( $encoding, ... )" 4
.el .IP "\f(CW$mess\fR\->encode( \f(CW$encoding\fR, ... )" 4
.IX Item "$mess->encode( $encoding, ... )"
Apply the given encodings to the content of the message.  Returns \s-1TRUE\s0
if successful. The \*(L"identity\*(R" (non\-)encoding is always supported; other
currently supported encodings, subject to availability of required
additional modules, are \*(L"gzip\*(R", \*(L"deflate\*(R", \*(L"x\-bzip2\*(R" and \*(L"base64\*(R".
.Sp
A successful call to this function will set the \f(CW\*(C`Content\-Encoding\*(C'\fR
header.
.Sp
Note that \f(CW\*(C`multipart/*\*(C'\fR or \f(CW\*(C`message/*\*(C'\fR messages can't be encoded and
this method will croak if you try.
.ie n .IP "$mess\->parts" 4
.el .IP "\f(CW$mess\fR\->parts" 4
.IX Item "$mess->parts"
.PD 0
.ie n .IP "$mess\->parts( @parts )" 4
.el .IP "\f(CW$mess\fR\->parts( \f(CW@parts\fR )" 4
.IX Item "$mess->parts( @parts )"
.ie n .IP "$mess\->parts( \e@parts )" 4
.el .IP "\f(CW$mess\fR\->parts( \e@parts )" 4
.IX Item "$mess->parts( @parts )"
.PD
Messages can be composite, i.e. contain other messages.  The composite
messages have a content type of \f(CW\*(C`multipart/*\*(C'\fR or \f(CW\*(C`message/*\*(C'\fR.  This
method give access to the contained messages.
.Sp
The argumentless form will return a list of \f(CW\*(C`HTTP::Message\*(C'\fR objects.
If the content type of \f(CW$msg\fR is not \f(CW\*(C`multipart/*\*(C'\fR or \f(CW\*(C`message/*\*(C'\fR then
this will return the empty list.  In scalar context only the first
object is returned.  The returned message parts should be regarded as
read-only (future versions of this library might make it possible
to modify the parent by modifying the parts).
.Sp
If the content type of \f(CW$msg\fR is \f(CW\*(C`message/*\*(C'\fR then there will only be
one part returned.
.Sp
If the content type is \f(CW\*(C`message/http\*(C'\fR, then the return value will be
either an \f(CW\*(C`HTTP::Request\*(C'\fR or an \f(CW\*(C`HTTP::Response\*(C'\fR object.
.Sp
If a \f(CW@parts\fR argument is given, then the content of the message will be
modified. The array reference form is provided so that an empty list
can be provided.  The \f(CW@parts\fR array should contain \f(CW\*(C`HTTP::Message\*(C'\fR
objects.  The \f(CW@parts\fR objects are owned by \f(CW$mess\fR after this call and
should not be modified or made part of other messages.
.Sp
When updating the message with this method and the old content type of
\&\f(CW$mess\fR is not \f(CW\*(C`multipart/*\*(C'\fR or \f(CW\*(C`message/*\*(C'\fR, then the content type is
set to \f(CW\*(C`multipart/mixed\*(C'\fR and all other content headers are cleared.
.Sp
This method will croak if the content type is \f(CW\*(C`message/*\*(C'\fR and more
than one part is provided.
.ie n .IP "$mess\->add_part( $part )" 4
.el .IP "\f(CW$mess\fR\->add_part( \f(CW$part\fR )" 4
.IX Item "$mess->add_part( $part )"
This will add a part to a message.  The \f(CW$part\fR argument should be
another \f(CW\*(C`HTTP::Message\*(C'\fR object.  If the previous content type of
\&\f(CW$mess\fR is not \f(CW\*(C`multipart/*\*(C'\fR then the old content (together with all
content headers) will be made part #1 and the content type made
\&\f(CW\*(C`multipart/mixed\*(C'\fR before the new part is added.  The \f(CW$part\fR object is
owned by \f(CW$mess\fR after this call and should not be modified or made part
of other messages.
.Sp
There is no return value.
.ie n .IP "$mess\->clear" 4
.el .IP "\f(CW$mess\fR\->clear" 4
.IX Item "$mess->clear"
Will clear the headers and set the content to the empty string.  There
is no return value
.ie n .IP "$mess\->protocol" 4
.el .IP "\f(CW$mess\fR\->protocol" 4
.IX Item "$mess->protocol"
.PD 0
.ie n .IP "$mess\->protocol( $proto )" 4
.el .IP "\f(CW$mess\fR\->protocol( \f(CW$proto\fR )" 4
.IX Item "$mess->protocol( $proto )"
.PD
Sets the \s-1HTTP\s0 protocol used for the message.  The \fIprotocol()\fR is a string
like \f(CW\*(C`HTTP/1.0\*(C'\fR or \f(CW\*(C`HTTP/1.1\*(C'\fR.
.ie n .IP "$mess\->clone" 4
.el .IP "\f(CW$mess\fR\->clone" 4
.IX Item "$mess->clone"
Returns a copy of the message object.
.ie n .IP "$mess\->as_string" 4
.el .IP "\f(CW$mess\fR\->as_string" 4
.IX Item "$mess->as_string"
.PD 0
.ie n .IP "$mess\->as_string( $eol )" 4
.el .IP "\f(CW$mess\fR\->as_string( \f(CW$eol\fR )" 4
.IX Item "$mess->as_string( $eol )"
.PD
Returns the message formatted as a single string.
.Sp
The optional \f(CW$eol\fR parameter specifies the line ending sequence to use.
The default is \*(L"\en\*(R".  If no \f(CW$eol\fR is given then as_string will ensure
that the returned string is newline terminated (even when the message
content is not).  No extra newline is appended if an explicit \f(CW$eol\fR is
passed.
.ie n .IP "$mess\->dump( %opt )" 4
.el .IP "\f(CW$mess\fR\->dump( \f(CW%opt\fR )" 4
.IX Item "$mess->dump( %opt )"
Returns the message formatted as a string.  In void context print the string.
.Sp
This differs from \f(CW\*(C`$mess\->as_string\*(C'\fR in that it escapes the bytes
of the content so that it's safe to print them and it limits how much
content to print.  The escapes syntax used is the same as for Perl's
double quoted strings.  If there is no content the string \*(L"(no
content)\*(R" is shown in its place.
.Sp
Options to influence the output can be passed as key/value pairs. The
following options are recognized:
.RS 4
.ie n .IP "maxlength => $num" 4
.el .IP "maxlength => \f(CW$num\fR" 4
.IX Item "maxlength => $num"
How much of the content to show.  The default is 512.  Set this to 0
for unlimited.
.Sp
If the content is longer then the string is chopped at the limit and
the string \*(L"...\en(### more bytes not shown)\*(R" appended.
.ie n .IP "no_content => $str" 4
.el .IP "no_content => \f(CW$str\fR" 4
.IX Item "no_content => $str"
Replaces the \*(L"(no content)\*(R" marker.
.ie n .IP "prefix => $str" 4
.el .IP "prefix => \f(CW$str\fR" 4
.IX Item "prefix => $str"
A string that will be prefixed to each line of the dump.
.RE
.RS 4
.RE
.PP
All methods unknown to \f(CW\*(C`HTTP::Message\*(C'\fR itself are delegated to the
\&\f(CW\*(C`HTTP::Headers\*(C'\fR object that is part of every message.  This allows
convenient access to these methods.  Refer to HTTP::Headers for
details of these methods:
.PP
.Vb 7
\&    $mess\->header( $field => $val )
\&    $mess\->push_header( $field => $val )
\&    $mess\->init_header( $field => $val )
\&    $mess\->remove_header( $field )
\&    $mess\->remove_content_headers
\&    $mess\->header_field_names
\&    $mess\->scan( \e&doit )
\&
\&    $mess\->date
\&    $mess\->expires
\&    $mess\->if_modified_since
\&    $mess\->if_unmodified_since
\&    $mess\->last_modified
\&    $mess\->content_type
\&    $mess\->content_encoding
\&    $mess\->content_length
\&    $mess\->content_language
\&    $mess\->title
\&    $mess\->user_agent
\&    $mess\->server
\&    $mess\->from
\&    $mess\->referer
\&    $mess\->www_authenticate
\&    $mess\->authorization
\&    $mess\->proxy_authorization
\&    $mess\->authorization_basic
\&    $mess\->proxy_authorization_basic
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2004 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Negotiate.3pm                          0100644 0001750 0001750 00000027747 12566241322 024120  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Negotiate 3"
.TH HTTP::Negotiate 3 "2012-02-18" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Negotiate \- choose a variant to serve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use HTTP::Negotiate qw(choose);
\&
\& #  ID       QS     Content\-Type   Encoding Char\-Set        Lang   Size
\& $variants =
\&  [[\*(Aqvar1\*(Aq,  1.000, \*(Aqtext/html\*(Aq,   undef,   \*(Aqiso\-8859\-1\*(Aq,   \*(Aqen\*(Aq,   3000],
\&   [\*(Aqvar2\*(Aq,  0.950, \*(Aqtext/plain\*(Aq,  \*(Aqgzip\*(Aq,  \*(Aqus\-ascii\*(Aq,     \*(Aqno\*(Aq,    400],
\&   [\*(Aqvar3\*(Aq,  0.3,   \*(Aqimage/gif\*(Aq,   undef,   undef,          undef, 43555],
\&  ];
\&
\& @preferred = choose($variants, $request_headers);
\& $the_one   = choose($variants);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a complete implementation of the \s-1HTTP\s0 content
negotiation algorithm specified in \fIdraft\-ietf\-http\-v11\-spec\-00.ps\fR
chapter 12.  Content negotiation allows for the selection of a
preferred content representation based upon attributes of the
negotiable variants and the value of the various Accept* header fields
in the request.
.PP
The variants are ordered by preference by calling the function
\&\fIchoose()\fR.
.PP
The first parameter is reference to an array of the variants to
choose among.
Each element in this array is an array with the values [$id, \f(CW$qs\fR,
\&\f(CW$content_type\fR, \f(CW$content_encoding\fR, \f(CW$charset\fR, \f(CW$content_language\fR,
\&\f(CW$content_length\fR] whose meanings are described
below. The \f(CW$content_encoding\fR and \f(CW$content_language\fR can be either a
single scalar value or an array reference if there are several values.
.PP
The second optional parameter is either a HTTP::Headers or a HTTP::Request
object which is searched for \*(L"Accept*\*(R" headers.  If this
parameter is missing, then the accept specification is initialized
from the \s-1CGI\s0 environment variables \s-1HTTP_ACCEPT, HTTP_ACCEPT_CHARSET,
HTTP_ACCEPT_ENCODING\s0 and \s-1HTTP_ACCEPT_LANGUAGE.\s0
.PP
In an array context, \fIchoose()\fR returns a list of [variant
identifier, calculated quality, size] tuples.  The values are sorted by
quality, highest quality first.  If the calculated quality is the same
for two variants, then they are sorted by size (smallest first). \fIE.g.\fR:
.PP
.Vb 1
\&  ([\*(Aqvar1\*(Aq, 1, 2000], [\*(Aqvar2\*(Aq, 0.3, 512], [\*(Aqvar3\*(Aq, 0.3, 1024]);
.Ve
.PP
Note that also zero quality variants are included in the return list
even if these should never be served to the client.
.PP
In a scalar context, it returns the identifier of the variant with the
highest score or \f(CW\*(C`undef\*(C'\fR if none have non-zero quality.
.PP
If the \f(CW$HTTP::Negotiate::DEBUG\fR variable is set to \s-1TRUE,\s0 then a lot of
noise is generated on \s-1STDOUT\s0 during evaluation of \fIchoose()\fR.
.SH "VARIANTS"
.IX Header "VARIANTS"
A variant is described by a list of the following values.  If the
attribute does not make sense or is unknown for a variant, then use
\&\f(CW\*(C`undef\*(C'\fR instead.
.IP "identifier" 3
.IX Item "identifier"
This is a string that you use as the name for the variant.  This
identifier for the preferred variants returned by \fIchoose()\fR.
.IP "qs" 3
.IX Item "qs"
This is a number between 0.000 and 1.000 that describes the \*(L"source
quality\*(R".  This is what \fIdraft\-ietf\-http\-v11\-spec\-00.ps\fR says about this
value:
.Sp
Source quality is measured by the content provider as representing the
amount of degradation from the original source.  For example, a
picture in \s-1JPEG\s0 form would have a lower qs when translated to the \s-1XBM\s0
format, and much lower qs when translated to an ASCII-art
representation.  Note, however, that this is a function of the source
\&\- an original piece of ASCII-art may degrade in quality if it is
captured in \s-1JPEG\s0 form.  The qs values should be assigned to each
variant by the content provider; if no qs value has been assigned, the
default is generally \*(L"qs=1\*(R".
.IP "content-type" 3
.IX Item "content-type"
This is the media type of the variant.  The media type does not
include a charset attribute, but might contain other parameters.
Examples are:
.Sp
.Vb 5
\&  text/html
\&  text/html;version=2.0
\&  text/plain
\&  image/gif
\&  image/jpg
.Ve
.IP "content-encoding" 3
.IX Item "content-encoding"
This is one or more content encodings that has been applied to the
variant.  The content encoding is generally used as a modifier to the
content media type.  The most common content encodings are:
.Sp
.Vb 2
\&  gzip
\&  compress
.Ve
.IP "content-charset" 3
.IX Item "content-charset"
This is the character set used when the variant contains text.
The charset value should generally be \f(CW\*(C`undef\*(C'\fR or one of these:
.Sp
.Vb 8
\&  us\-ascii
\&  iso\-8859\-1 ... iso\-8859\-9
\&  iso\-2022\-jp
\&  iso\-2022\-jp\-2
\&  iso\-2022\-kr
\&  unicode\-1\-1
\&  unicode\-1\-1\-utf\-7
\&  unicode\-1\-1\-utf\-8
.Ve
.IP "content-language" 3
.IX Item "content-language"
This describes one or more languages that are used in the variant.
Language is described like this in \fIdraft\-ietf\-http\-v11\-spec\-00.ps\fR: A
language is in this context a natural language spoken, written, or
otherwise conveyed by human beings for communication of information to
other human beings.  Computer languages are explicitly excluded.
.Sp
The language tags are defined by \s-1RFC 3066. \s0 Examples
are:
.Sp
.Vb 4
\&  no               Norwegian
\&  en               International English
\&  en\-US            US English
\&  en\-cockney
.Ve
.IP "content-length" 3
.IX Item "content-length"
This is the number of bytes used to represent the content.
.SH "ACCEPT HEADERS"
.IX Header "ACCEPT HEADERS"
The following Accept* headers can be used for describing content
preferences in a request (This description is an edited extract from
\&\fIdraft\-ietf\-http\-v11\-spec\-00.ps\fR):
.IP "Accept" 3
.IX Item "Accept"
This header can be used to indicate a list of media ranges which are
acceptable as a response to the request.  The \*(L"*\*(R" character is used to
group media types into ranges, with \*(L"*/*\*(R" indicating all media types
and \*(L"type/*\*(R" indicating all subtypes of that type.
.Sp
The parameter q is used to indicate the quality factor, which
represents the user's preference for that range of media types.  The
parameter mbx gives the maximum acceptable size of the response
content. The default values are: q=1 and mbx=infinity. If no Accept
header is present, then the client accepts all media types with q=1.
.Sp
For example:
.Sp
.Vb 1
\&  Accept: audio/*;q=0.2;mbx=200000, audio/basic
.Ve
.Sp
would mean: \*(L"I prefer audio/basic (of any size), but send me any audio
type if it is the best available after an 80% mark-down in quality and
its size is less than 200000 bytes\*(R"
.IP "Accept-Charset" 3
.IX Item "Accept-Charset"
Used to indicate what character sets are acceptable for the response.
The \*(L"us-ascii\*(R" character set is assumed to be acceptable for all user
agents.  If no Accept-Charset field is given, the default is that any
charset is acceptable.  Example:
.Sp
.Vb 1
\&  Accept\-Charset: iso\-8859\-1, unicode\-1\-1
.Ve
.IP "Accept-Encoding" 3
.IX Item "Accept-Encoding"
Restricts the Content-Encoding values which are acceptable in the
response.  If no Accept-Encoding field is present, the server may
assume that the client will accept any content encoding.  An empty
Accept-Encoding means that no content encoding is acceptable.  Example:
.Sp
.Vb 1
\&  Accept\-Encoding: compress, gzip
.Ve
.IP "Accept-Language" 3
.IX Item "Accept-Language"
This field is similar to Accept, but restricts the set of natural
languages that are preferred in a response.  Each language may be
given an associated quality value which represents an estimate of the
user's comprehension of that language.  For example:
.Sp
.Vb 1
\&  Accept\-Language: no, en\-gb;q=0.8, de;q=0.55
.Ve
.Sp
would mean: "I prefer Norwegian, but will accept British English (with
80% comprehension) or German (with 55% comprehension).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1996,2001 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Gisle Aas <gisle@aas.no>
                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Negotiate5.16.3pm                      0100644 0001750 0001750 00000027446 12566241323 024427  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Negotiate 3"
.TH HTTP::Negotiate 3 "2012-02-18" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Negotiate \- choose a variant to serve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use HTTP::Negotiate qw(choose);
\&
\& #  ID       QS     Content\-Type   Encoding Char\-Set        Lang   Size
\& $variants =
\&  [[\*(Aqvar1\*(Aq,  1.000, \*(Aqtext/html\*(Aq,   undef,   \*(Aqiso\-8859\-1\*(Aq,   \*(Aqen\*(Aq,   3000],
\&   [\*(Aqvar2\*(Aq,  0.950, \*(Aqtext/plain\*(Aq,  \*(Aqgzip\*(Aq,  \*(Aqus\-ascii\*(Aq,     \*(Aqno\*(Aq,    400],
\&   [\*(Aqvar3\*(Aq,  0.3,   \*(Aqimage/gif\*(Aq,   undef,   undef,          undef, 43555],
\&  ];
\&
\& @preferred = choose($variants, $request_headers);
\& $the_one   = choose($variants);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a complete implementation of the \s-1HTTP\s0 content
negotiation algorithm specified in \fIdraft\-ietf\-http\-v11\-spec\-00.ps\fR
chapter 12.  Content negotiation allows for the selection of a
preferred content representation based upon attributes of the
negotiable variants and the value of the various Accept* header fields
in the request.
.PP
The variants are ordered by preference by calling the function
\&\fIchoose()\fR.
.PP
The first parameter is reference to an array of the variants to
choose among.
Each element in this array is an array with the values [$id, \f(CW$qs\fR,
\&\f(CW$content_type\fR, \f(CW$content_encoding\fR, \f(CW$charset\fR, \f(CW$content_language\fR,
\&\f(CW$content_length\fR] whose meanings are described
below. The \f(CW$content_encoding\fR and \f(CW$content_language\fR can be either a
single scalar value or an array reference if there are several values.
.PP
The second optional parameter is either a HTTP::Headers or a HTTP::Request
object which is searched for \*(L"Accept*\*(R" headers.  If this
parameter is missing, then the accept specification is initialized
from the \s-1CGI\s0 environment variables \s-1HTTP_ACCEPT\s0, \s-1HTTP_ACCEPT_CHARSET\s0,
\&\s-1HTTP_ACCEPT_ENCODING\s0 and \s-1HTTP_ACCEPT_LANGUAGE\s0.
.PP
In an array context, \fIchoose()\fR returns a list of [variant
identifier, calculated quality, size] tuples.  The values are sorted by
quality, highest quality first.  If the calculated quality is the same
for two variants, then they are sorted by size (smallest first). \fIE.g.\fR:
.PP
.Vb 1
\&  ([\*(Aqvar1\*(Aq, 1, 2000], [\*(Aqvar2\*(Aq, 0.3, 512], [\*(Aqvar3\*(Aq, 0.3, 1024]);
.Ve
.PP
Note that also zero quality variants are included in the return list
even if these should never be served to the client.
.PP
In a scalar context, it returns the identifier of the variant with the
highest score or \f(CW\*(C`undef\*(C'\fR if none have non-zero quality.
.PP
If the \f(CW$HTTP::Negotiate::DEBUG\fR variable is set to \s-1TRUE\s0, then a lot of
noise is generated on \s-1STDOUT\s0 during evaluation of \fIchoose()\fR.
.SH "VARIANTS"
.IX Header "VARIANTS"
A variant is described by a list of the following values.  If the
attribute does not make sense or is unknown for a variant, then use
\&\f(CW\*(C`undef\*(C'\fR instead.
.IP "identifier" 3
.IX Item "identifier"
This is a string that you use as the name for the variant.  This
identifier for the preferred variants returned by \fIchoose()\fR.
.IP "qs" 3
.IX Item "qs"
This is a number between 0.000 and 1.000 that describes the \*(L"source
quality\*(R".  This is what \fIdraft\-ietf\-http\-v11\-spec\-00.ps\fR says about this
value:
.Sp
Source quality is measured by the content provider as representing the
amount of degradation from the original source.  For example, a
picture in \s-1JPEG\s0 form would have a lower qs when translated to the \s-1XBM\s0
format, and much lower qs when translated to an ASCII-art
representation.  Note, however, that this is a function of the source
\&\- an original piece of ASCII-art may degrade in quality if it is
captured in \s-1JPEG\s0 form.  The qs values should be assigned to each
variant by the content provider; if no qs value has been assigned, the
default is generally \*(L"qs=1\*(R".
.IP "content-type" 3
.IX Item "content-type"
This is the media type of the variant.  The media type does not
include a charset attribute, but might contain other parameters.
Examples are:
.Sp
.Vb 5
\&  text/html
\&  text/html;version=2.0
\&  text/plain
\&  image/gif
\&  image/jpg
.Ve
.IP "content-encoding" 3
.IX Item "content-encoding"
This is one or more content encodings that has been applied to the
variant.  The content encoding is generally used as a modifier to the
content media type.  The most common content encodings are:
.Sp
.Vb 2
\&  gzip
\&  compress
.Ve
.IP "content-charset" 3
.IX Item "content-charset"
This is the character set used when the variant contains text.
The charset value should generally be \f(CW\*(C`undef\*(C'\fR or one of these:
.Sp
.Vb 8
\&  us\-ascii
\&  iso\-8859\-1 ... iso\-8859\-9
\&  iso\-2022\-jp
\&  iso\-2022\-jp\-2
\&  iso\-2022\-kr
\&  unicode\-1\-1
\&  unicode\-1\-1\-utf\-7
\&  unicode\-1\-1\-utf\-8
.Ve
.IP "content-language" 3
.IX Item "content-language"
This describes one or more languages that are used in the variant.
Language is described like this in \fIdraft\-ietf\-http\-v11\-spec\-00.ps\fR: A
language is in this context a natural language spoken, written, or
otherwise conveyed by human beings for communication of information to
other human beings.  Computer languages are explicitly excluded.
.Sp
The language tags are defined by \s-1RFC\s0 3066.  Examples
are:
.Sp
.Vb 4
\&  no               Norwegian
\&  en               International English
\&  en\-US            US English
\&  en\-cockney
.Ve
.IP "content-length" 3
.IX Item "content-length"
This is the number of bytes used to represent the content.
.SH "ACCEPT HEADERS"
.IX Header "ACCEPT HEADERS"
The following Accept* headers can be used for describing content
preferences in a request (This description is an edited extract from
\&\fIdraft\-ietf\-http\-v11\-spec\-00.ps\fR):
.IP "Accept" 3
.IX Item "Accept"
This header can be used to indicate a list of media ranges which are
acceptable as a response to the request.  The \*(L"*\*(R" character is used to
group media types into ranges, with \*(L"*/*\*(R" indicating all media types
and \*(L"type/*\*(R" indicating all subtypes of that type.
.Sp
The parameter q is used to indicate the quality factor, which
represents the user's preference for that range of media types.  The
parameter mbx gives the maximum acceptable size of the response
content. The default values are: q=1 and mbx=infinity. If no Accept
header is present, then the client accepts all media types with q=1.
.Sp
For example:
.Sp
.Vb 1
\&  Accept: audio/*;q=0.2;mbx=200000, audio/basic
.Ve
.Sp
would mean: \*(L"I prefer audio/basic (of any size), but send me any audio
type if it is the best available after an 80% mark-down in quality and
its size is less than 200000 bytes\*(R"
.IP "Accept-Charset" 3
.IX Item "Accept-Charset"
Used to indicate what character sets are acceptable for the response.
The \*(L"us-ascii\*(R" character set is assumed to be acceptable for all user
agents.  If no Accept-Charset field is given, the default is that any
charset is acceptable.  Example:
.Sp
.Vb 1
\&  Accept\-Charset: iso\-8859\-1, unicode\-1\-1
.Ve
.IP "Accept-Encoding" 3
.IX Item "Accept-Encoding"
Restricts the Content-Encoding values which are acceptable in the
response.  If no Accept-Encoding field is present, the server may
assume that the client will accept any content encoding.  An empty
Accept-Encoding means that no content encoding is acceptable.  Example:
.Sp
.Vb 1
\&  Accept\-Encoding: compress, gzip
.Ve
.IP "Accept-Language" 3
.IX Item "Accept-Language"
This field is similar to Accept, but restricts the set of natural
languages that are preferred in a response.  Each language may be
given an associated quality value which represents an estimate of the
user's comprehension of that language.  For example:
.Sp
.Vb 1
\&  Accept\-Language: no, en\-gb;q=0.8, de;q=0.55
.Ve
.Sp
would mean: "I prefer Norwegian, but will accept British English (with
80% comprehension) or German (with 55% comprehension).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1996,2001 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Gisle Aas <gisle@aas.no>
                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Negotiate5.18.3pm                      0100644 0001750 0001750 00000027747 12566241322 024434  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Negotiate 3"
.TH HTTP::Negotiate 3 "2012-02-18" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Negotiate \- choose a variant to serve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use HTTP::Negotiate qw(choose);
\&
\& #  ID       QS     Content\-Type   Encoding Char\-Set        Lang   Size
\& $variants =
\&  [[\*(Aqvar1\*(Aq,  1.000, \*(Aqtext/html\*(Aq,   undef,   \*(Aqiso\-8859\-1\*(Aq,   \*(Aqen\*(Aq,   3000],
\&   [\*(Aqvar2\*(Aq,  0.950, \*(Aqtext/plain\*(Aq,  \*(Aqgzip\*(Aq,  \*(Aqus\-ascii\*(Aq,     \*(Aqno\*(Aq,    400],
\&   [\*(Aqvar3\*(Aq,  0.3,   \*(Aqimage/gif\*(Aq,   undef,   undef,          undef, 43555],
\&  ];
\&
\& @preferred = choose($variants, $request_headers);
\& $the_one   = choose($variants);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides a complete implementation of the \s-1HTTP\s0 content
negotiation algorithm specified in \fIdraft\-ietf\-http\-v11\-spec\-00.ps\fR
chapter 12.  Content negotiation allows for the selection of a
preferred content representation based upon attributes of the
negotiable variants and the value of the various Accept* header fields
in the request.
.PP
The variants are ordered by preference by calling the function
\&\fIchoose()\fR.
.PP
The first parameter is reference to an array of the variants to
choose among.
Each element in this array is an array with the values [$id, \f(CW$qs\fR,
\&\f(CW$content_type\fR, \f(CW$content_encoding\fR, \f(CW$charset\fR, \f(CW$content_language\fR,
\&\f(CW$content_length\fR] whose meanings are described
below. The \f(CW$content_encoding\fR and \f(CW$content_language\fR can be either a
single scalar value or an array reference if there are several values.
.PP
The second optional parameter is either a HTTP::Headers or a HTTP::Request
object which is searched for \*(L"Accept*\*(R" headers.  If this
parameter is missing, then the accept specification is initialized
from the \s-1CGI\s0 environment variables \s-1HTTP_ACCEPT, HTTP_ACCEPT_CHARSET,
HTTP_ACCEPT_ENCODING\s0 and \s-1HTTP_ACCEPT_LANGUAGE.\s0
.PP
In an array context, \fIchoose()\fR returns a list of [variant
identifier, calculated quality, size] tuples.  The values are sorted by
quality, highest quality first.  If the calculated quality is the same
for two variants, then they are sorted by size (smallest first). \fIE.g.\fR:
.PP
.Vb 1
\&  ([\*(Aqvar1\*(Aq, 1, 2000], [\*(Aqvar2\*(Aq, 0.3, 512], [\*(Aqvar3\*(Aq, 0.3, 1024]);
.Ve
.PP
Note that also zero quality variants are included in the return list
even if these should never be served to the client.
.PP
In a scalar context, it returns the identifier of the variant with the
highest score or \f(CW\*(C`undef\*(C'\fR if none have non-zero quality.
.PP
If the \f(CW$HTTP::Negotiate::DEBUG\fR variable is set to \s-1TRUE,\s0 then a lot of
noise is generated on \s-1STDOUT\s0 during evaluation of \fIchoose()\fR.
.SH "VARIANTS"
.IX Header "VARIANTS"
A variant is described by a list of the following values.  If the
attribute does not make sense or is unknown for a variant, then use
\&\f(CW\*(C`undef\*(C'\fR instead.
.IP "identifier" 3
.IX Item "identifier"
This is a string that you use as the name for the variant.  This
identifier for the preferred variants returned by \fIchoose()\fR.
.IP "qs" 3
.IX Item "qs"
This is a number between 0.000 and 1.000 that describes the \*(L"source
quality\*(R".  This is what \fIdraft\-ietf\-http\-v11\-spec\-00.ps\fR says about this
value:
.Sp
Source quality is measured by the content provider as representing the
amount of degradation from the original source.  For example, a
picture in \s-1JPEG\s0 form would have a lower qs when translated to the \s-1XBM\s0
format, and much lower qs when translated to an ASCII-art
representation.  Note, however, that this is a function of the source
\&\- an original piece of ASCII-art may degrade in quality if it is
captured in \s-1JPEG\s0 form.  The qs values should be assigned to each
variant by the content provider; if no qs value has been assigned, the
default is generally \*(L"qs=1\*(R".
.IP "content-type" 3
.IX Item "content-type"
This is the media type of the variant.  The media type does not
include a charset attribute, but might contain other parameters.
Examples are:
.Sp
.Vb 5
\&  text/html
\&  text/html;version=2.0
\&  text/plain
\&  image/gif
\&  image/jpg
.Ve
.IP "content-encoding" 3
.IX Item "content-encoding"
This is one or more content encodings that has been applied to the
variant.  The content encoding is generally used as a modifier to the
content media type.  The most common content encodings are:
.Sp
.Vb 2
\&  gzip
\&  compress
.Ve
.IP "content-charset" 3
.IX Item "content-charset"
This is the character set used when the variant contains text.
The charset value should generally be \f(CW\*(C`undef\*(C'\fR or one of these:
.Sp
.Vb 8
\&  us\-ascii
\&  iso\-8859\-1 ... iso\-8859\-9
\&  iso\-2022\-jp
\&  iso\-2022\-jp\-2
\&  iso\-2022\-kr
\&  unicode\-1\-1
\&  unicode\-1\-1\-utf\-7
\&  unicode\-1\-1\-utf\-8
.Ve
.IP "content-language" 3
.IX Item "content-language"
This describes one or more languages that are used in the variant.
Language is described like this in \fIdraft\-ietf\-http\-v11\-spec\-00.ps\fR: A
language is in this context a natural language spoken, written, or
otherwise conveyed by human beings for communication of information to
other human beings.  Computer languages are explicitly excluded.
.Sp
The language tags are defined by \s-1RFC 3066. \s0 Examples
are:
.Sp
.Vb 4
\&  no               Norwegian
\&  en               International English
\&  en\-US            US English
\&  en\-cockney
.Ve
.IP "content-length" 3
.IX Item "content-length"
This is the number of bytes used to represent the content.
.SH "ACCEPT HEADERS"
.IX Header "ACCEPT HEADERS"
The following Accept* headers can be used for describing content
preferences in a request (This description is an edited extract from
\&\fIdraft\-ietf\-http\-v11\-spec\-00.ps\fR):
.IP "Accept" 3
.IX Item "Accept"
This header can be used to indicate a list of media ranges which are
acceptable as a response to the request.  The \*(L"*\*(R" character is used to
group media types into ranges, with \*(L"*/*\*(R" indicating all media types
and \*(L"type/*\*(R" indicating all subtypes of that type.
.Sp
The parameter q is used to indicate the quality factor, which
represents the user's preference for that range of media types.  The
parameter mbx gives the maximum acceptable size of the response
content. The default values are: q=1 and mbx=infinity. If no Accept
header is present, then the client accepts all media types with q=1.
.Sp
For example:
.Sp
.Vb 1
\&  Accept: audio/*;q=0.2;mbx=200000, audio/basic
.Ve
.Sp
would mean: \*(L"I prefer audio/basic (of any size), but send me any audio
type if it is the best available after an 80% mark-down in quality and
its size is less than 200000 bytes\*(R"
.IP "Accept-Charset" 3
.IX Item "Accept-Charset"
Used to indicate what character sets are acceptable for the response.
The \*(L"us-ascii\*(R" character set is assumed to be acceptable for all user
agents.  If no Accept-Charset field is given, the default is that any
charset is acceptable.  Example:
.Sp
.Vb 1
\&  Accept\-Charset: iso\-8859\-1, unicode\-1\-1
.Ve
.IP "Accept-Encoding" 3
.IX Item "Accept-Encoding"
Restricts the Content-Encoding values which are acceptable in the
response.  If no Accept-Encoding field is present, the server may
assume that the client will accept any content encoding.  An empty
Accept-Encoding means that no content encoding is acceptable.  Example:
.Sp
.Vb 1
\&  Accept\-Encoding: compress, gzip
.Ve
.IP "Accept-Language" 3
.IX Item "Accept-Language"
This field is similar to Accept, but restricts the set of natural
languages that are preferred in a response.  Each language may be
given an associated quality value which represents an estimate of the
user's comprehension of that language.  For example:
.Sp
.Vb 1
\&  Accept\-Language: no, en\-gb;q=0.8, de;q=0.55
.Ve
.Sp
would mean: "I prefer Norwegian, but will accept British English (with
80% comprehension) or German (with 55% comprehension).
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1996,2001 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Gisle Aas <gisle@aas.no>
                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Request.3pm                            0100644 0001750 0001750 00000021502 12566241314 023611  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Request 3"
.TH HTTP::Request 3 "2012-02-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Request \- HTTP style request message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& require HTTP::Request;
\& $request = HTTP::Request\->new(GET => \*(Aqhttp://www.example.com/\*(Aq);
.Ve
.PP
and usually used like this:
.PP
.Vb 2
\& $ua = LWP::UserAgent\->new;
\& $response = $ua\->request($request);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`HTTP::Request\*(C'\fR is a class encapsulating \s-1HTTP\s0 style requests,
consisting of a request line, some headers, and a content body. Note
that the \s-1LWP\s0 library uses \s-1HTTP\s0 style requests even for non-HTTP
protocols.  Instances of this class are usually passed to the
\&\fIrequest()\fR method of an \f(CW\*(C`LWP::UserAgent\*(C'\fR object.
.PP
\&\f(CW\*(C`HTTP::Request\*(C'\fR is a subclass of \f(CW\*(C`HTTP::Message\*(C'\fR and therefore
inherits its methods.  The following additional methods are available:
.ie n .IP "$r = HTTP::Request\->new( $method, $uri )" 4
.el .IP "\f(CW$r\fR = HTTP::Request\->new( \f(CW$method\fR, \f(CW$uri\fR )" 4
.IX Item "$r = HTTP::Request->new( $method, $uri )"
.PD 0
.ie n .IP "$r = HTTP::Request\->new( $method, $uri, $header )" 4
.el .IP "\f(CW$r\fR = HTTP::Request\->new( \f(CW$method\fR, \f(CW$uri\fR, \f(CW$header\fR )" 4
.IX Item "$r = HTTP::Request->new( $method, $uri, $header )"
.ie n .IP "$r = HTTP::Request\->new( $method, $uri, $header, $content )" 4
.el .IP "\f(CW$r\fR = HTTP::Request\->new( \f(CW$method\fR, \f(CW$uri\fR, \f(CW$header\fR, \f(CW$content\fR )" 4
.IX Item "$r = HTTP::Request->new( $method, $uri, $header, $content )"
.PD
Constructs a new \f(CW\*(C`HTTP::Request\*(C'\fR object describing a request on the
object \f(CW$uri\fR using method \f(CW$method\fR.  The \f(CW$method\fR argument must be a
string.  The \f(CW$uri\fR argument can be either a string, or a reference to a
\&\f(CW\*(C`URI\*(C'\fR object.  The optional \f(CW$header\fR argument should be a reference to
an \f(CW\*(C`HTTP::Headers\*(C'\fR object or a plain array reference of key/value
pairs.  The optional \f(CW$content\fR argument should be a string of bytes.
.ie n .IP "$r = HTTP::Request\->parse( $str )" 4
.el .IP "\f(CW$r\fR = HTTP::Request\->parse( \f(CW$str\fR )" 4
.IX Item "$r = HTTP::Request->parse( $str )"
This constructs a new request object by parsing the given string.
.ie n .IP "$r\->method" 4
.el .IP "\f(CW$r\fR\->method" 4
.IX Item "$r->method"
.PD 0
.ie n .IP "$r\->method( $val )" 4
.el .IP "\f(CW$r\fR\->method( \f(CW$val\fR )" 4
.IX Item "$r->method( $val )"
.PD
This is used to get/set the method attribute.  The method should be a
short string like \*(L"\s-1GET\*(R", \*(L"HEAD\*(R", \*(L"PUT\*(R"\s0 or \*(L"\s-1POST\*(R".\s0
.ie n .IP "$r\->uri" 4
.el .IP "\f(CW$r\fR\->uri" 4
.IX Item "$r->uri"
.PD 0
.ie n .IP "$r\->uri( $val )" 4
.el .IP "\f(CW$r\fR\->uri( \f(CW$val\fR )" 4
.IX Item "$r->uri( $val )"
.PD
This is used to get/set the uri attribute.  The \f(CW$val\fR can be a
reference to a \s-1URI\s0 object or a plain string.  If a string is given,
then it should be parseable as an absolute \s-1URI.\s0
.ie n .IP "$r\->header( $field )" 4
.el .IP "\f(CW$r\fR\->header( \f(CW$field\fR )" 4
.IX Item "$r->header( $field )"
.PD 0
.ie n .IP "$r\->header( $field => $value )" 4
.el .IP "\f(CW$r\fR\->header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$r->header( $field => $value )"
.PD
This is used to get/set header values and it is inherited from
\&\f(CW\*(C`HTTP::Headers\*(C'\fR via \f(CW\*(C`HTTP::Message\*(C'\fR.  See HTTP::Headers for
details and other similar methods that can be used to access the
headers.
.ie n .IP "$r\->accept_decodable" 4
.el .IP "\f(CW$r\fR\->accept_decodable" 4
.IX Item "$r->accept_decodable"
This will set the \f(CW\*(C`Accept\-Encoding\*(C'\fR header to the list of encodings
that \fIdecoded_content()\fR can decode.
.ie n .IP "$r\->content" 4
.el .IP "\f(CW$r\fR\->content" 4
.IX Item "$r->content"
.PD 0
.ie n .IP "$r\->content( $bytes )" 4
.el .IP "\f(CW$r\fR\->content( \f(CW$bytes\fR )" 4
.IX Item "$r->content( $bytes )"
.PD
This is used to get/set the content and it is inherited from the
\&\f(CW\*(C`HTTP::Message\*(C'\fR base class.  See HTTP::Message for details and
other methods that can be used to access the content.
.Sp
Note that the content should be a string of bytes.  Strings in perl
can contain characters outside the range of a byte.  The \f(CW\*(C`Encode\*(C'\fR
module can be used to turn such strings into a string of bytes.
.ie n .IP "$r\->as_string" 4
.el .IP "\f(CW$r\fR\->as_string" 4
.IX Item "$r->as_string"
.PD 0
.ie n .IP "$r\->as_string( $eol )" 4
.el .IP "\f(CW$r\fR\->as_string( \f(CW$eol\fR )" 4
.IX Item "$r->as_string( $eol )"
.PD
Method returning a textual representation of the request.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTTP::Headers, HTTP::Message, HTTP::Request::Common,
HTTP::Response
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2004 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Request5.16.3pm                        0100644 0001750 0001750 00000021177 12566241314 024133  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Request 3"
.TH HTTP::Request 3 "2012-02-15" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Request \- HTTP style request message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& require HTTP::Request;
\& $request = HTTP::Request\->new(GET => \*(Aqhttp://www.example.com/\*(Aq);
.Ve
.PP
and usually used like this:
.PP
.Vb 2
\& $ua = LWP::UserAgent\->new;
\& $response = $ua\->request($request);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`HTTP::Request\*(C'\fR is a class encapsulating \s-1HTTP\s0 style requests,
consisting of a request line, some headers, and a content body. Note
that the \s-1LWP\s0 library uses \s-1HTTP\s0 style requests even for non-HTTP
protocols.  Instances of this class are usually passed to the
\&\fIrequest()\fR method of an \f(CW\*(C`LWP::UserAgent\*(C'\fR object.
.PP
\&\f(CW\*(C`HTTP::Request\*(C'\fR is a subclass of \f(CW\*(C`HTTP::Message\*(C'\fR and therefore
inherits its methods.  The following additional methods are available:
.ie n .IP "$r = HTTP::Request\->new( $method, $uri )" 4
.el .IP "\f(CW$r\fR = HTTP::Request\->new( \f(CW$method\fR, \f(CW$uri\fR )" 4
.IX Item "$r = HTTP::Request->new( $method, $uri )"
.PD 0
.ie n .IP "$r = HTTP::Request\->new( $method, $uri, $header )" 4
.el .IP "\f(CW$r\fR = HTTP::Request\->new( \f(CW$method\fR, \f(CW$uri\fR, \f(CW$header\fR )" 4
.IX Item "$r = HTTP::Request->new( $method, $uri, $header )"
.ie n .IP "$r = HTTP::Request\->new( $method, $uri, $header, $content )" 4
.el .IP "\f(CW$r\fR = HTTP::Request\->new( \f(CW$method\fR, \f(CW$uri\fR, \f(CW$header\fR, \f(CW$content\fR )" 4
.IX Item "$r = HTTP::Request->new( $method, $uri, $header, $content )"
.PD
Constructs a new \f(CW\*(C`HTTP::Request\*(C'\fR object describing a request on the
object \f(CW$uri\fR using method \f(CW$method\fR.  The \f(CW$method\fR argument must be a
string.  The \f(CW$uri\fR argument can be either a string, or a reference to a
\&\f(CW\*(C`URI\*(C'\fR object.  The optional \f(CW$header\fR argument should be a reference to
an \f(CW\*(C`HTTP::Headers\*(C'\fR object or a plain array reference of key/value
pairs.  The optional \f(CW$content\fR argument should be a string of bytes.
.ie n .IP "$r = HTTP::Request\->parse( $str )" 4
.el .IP "\f(CW$r\fR = HTTP::Request\->parse( \f(CW$str\fR )" 4
.IX Item "$r = HTTP::Request->parse( $str )"
This constructs a new request object by parsing the given string.
.ie n .IP "$r\->method" 4
.el .IP "\f(CW$r\fR\->method" 4
.IX Item "$r->method"
.PD 0
.ie n .IP "$r\->method( $val )" 4
.el .IP "\f(CW$r\fR\->method( \f(CW$val\fR )" 4
.IX Item "$r->method( $val )"
.PD
This is used to get/set the method attribute.  The method should be a
short string like \*(L"\s-1GET\s0\*(R", \*(L"\s-1HEAD\s0\*(R", \*(L"\s-1PUT\s0\*(R" or \*(L"\s-1POST\s0\*(R".
.ie n .IP "$r\->uri" 4
.el .IP "\f(CW$r\fR\->uri" 4
.IX Item "$r->uri"
.PD 0
.ie n .IP "$r\->uri( $val )" 4
.el .IP "\f(CW$r\fR\->uri( \f(CW$val\fR )" 4
.IX Item "$r->uri( $val )"
.PD
This is used to get/set the uri attribute.  The \f(CW$val\fR can be a
reference to a \s-1URI\s0 object or a plain string.  If a string is given,
then it should be parseable as an absolute \s-1URI\s0.
.ie n .IP "$r\->header( $field )" 4
.el .IP "\f(CW$r\fR\->header( \f(CW$field\fR )" 4
.IX Item "$r->header( $field )"
.PD 0
.ie n .IP "$r\->header( $field => $value )" 4
.el .IP "\f(CW$r\fR\->header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$r->header( $field => $value )"
.PD
This is used to get/set header values and it is inherited from
\&\f(CW\*(C`HTTP::Headers\*(C'\fR via \f(CW\*(C`HTTP::Message\*(C'\fR.  See HTTP::Headers for
details and other similar methods that can be used to access the
headers.
.ie n .IP "$r\->accept_decodable" 4
.el .IP "\f(CW$r\fR\->accept_decodable" 4
.IX Item "$r->accept_decodable"
This will set the \f(CW\*(C`Accept\-Encoding\*(C'\fR header to the list of encodings
that \fIdecoded_content()\fR can decode.
.ie n .IP "$r\->content" 4
.el .IP "\f(CW$r\fR\->content" 4
.IX Item "$r->content"
.PD 0
.ie n .IP "$r\->content( $bytes )" 4
.el .IP "\f(CW$r\fR\->content( \f(CW$bytes\fR )" 4
.IX Item "$r->content( $bytes )"
.PD
This is used to get/set the content and it is inherited from the
\&\f(CW\*(C`HTTP::Message\*(C'\fR base class.  See HTTP::Message for details and
other methods that can be used to access the content.
.Sp
Note that the content should be a string of bytes.  Strings in perl
can contain characters outside the range of a byte.  The \f(CW\*(C`Encode\*(C'\fR
module can be used to turn such strings into a string of bytes.
.ie n .IP "$r\->as_string" 4
.el .IP "\f(CW$r\fR\->as_string" 4
.IX Item "$r->as_string"
.PD 0
.ie n .IP "$r\->as_string( $eol )" 4
.el .IP "\f(CW$r\fR\->as_string( \f(CW$eol\fR )" 4
.IX Item "$r->as_string( $eol )"
.PD
Method returning a textual representation of the request.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTTP::Headers, HTTP::Message, HTTP::Request::Common,
HTTP::Response
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2004 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Request5.18.3pm                        0100644 0001750 0001750 00000021502 12566241314 024125  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Request 3"
.TH HTTP::Request 3 "2012-02-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Request \- HTTP style request message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& require HTTP::Request;
\& $request = HTTP::Request\->new(GET => \*(Aqhttp://www.example.com/\*(Aq);
.Ve
.PP
and usually used like this:
.PP
.Vb 2
\& $ua = LWP::UserAgent\->new;
\& $response = $ua\->request($request);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`HTTP::Request\*(C'\fR is a class encapsulating \s-1HTTP\s0 style requests,
consisting of a request line, some headers, and a content body. Note
that the \s-1LWP\s0 library uses \s-1HTTP\s0 style requests even for non-HTTP
protocols.  Instances of this class are usually passed to the
\&\fIrequest()\fR method of an \f(CW\*(C`LWP::UserAgent\*(C'\fR object.
.PP
\&\f(CW\*(C`HTTP::Request\*(C'\fR is a subclass of \f(CW\*(C`HTTP::Message\*(C'\fR and therefore
inherits its methods.  The following additional methods are available:
.ie n .IP "$r = HTTP::Request\->new( $method, $uri )" 4
.el .IP "\f(CW$r\fR = HTTP::Request\->new( \f(CW$method\fR, \f(CW$uri\fR )" 4
.IX Item "$r = HTTP::Request->new( $method, $uri )"
.PD 0
.ie n .IP "$r = HTTP::Request\->new( $method, $uri, $header )" 4
.el .IP "\f(CW$r\fR = HTTP::Request\->new( \f(CW$method\fR, \f(CW$uri\fR, \f(CW$header\fR )" 4
.IX Item "$r = HTTP::Request->new( $method, $uri, $header )"
.ie n .IP "$r = HTTP::Request\->new( $method, $uri, $header, $content )" 4
.el .IP "\f(CW$r\fR = HTTP::Request\->new( \f(CW$method\fR, \f(CW$uri\fR, \f(CW$header\fR, \f(CW$content\fR )" 4
.IX Item "$r = HTTP::Request->new( $method, $uri, $header, $content )"
.PD
Constructs a new \f(CW\*(C`HTTP::Request\*(C'\fR object describing a request on the
object \f(CW$uri\fR using method \f(CW$method\fR.  The \f(CW$method\fR argument must be a
string.  The \f(CW$uri\fR argument can be either a string, or a reference to a
\&\f(CW\*(C`URI\*(C'\fR object.  The optional \f(CW$header\fR argument should be a reference to
an \f(CW\*(C`HTTP::Headers\*(C'\fR object or a plain array reference of key/value
pairs.  The optional \f(CW$content\fR argument should be a string of bytes.
.ie n .IP "$r = HTTP::Request\->parse( $str )" 4
.el .IP "\f(CW$r\fR = HTTP::Request\->parse( \f(CW$str\fR )" 4
.IX Item "$r = HTTP::Request->parse( $str )"
This constructs a new request object by parsing the given string.
.ie n .IP "$r\->method" 4
.el .IP "\f(CW$r\fR\->method" 4
.IX Item "$r->method"
.PD 0
.ie n .IP "$r\->method( $val )" 4
.el .IP "\f(CW$r\fR\->method( \f(CW$val\fR )" 4
.IX Item "$r->method( $val )"
.PD
This is used to get/set the method attribute.  The method should be a
short string like \*(L"\s-1GET\*(R", \*(L"HEAD\*(R", \*(L"PUT\*(R"\s0 or \*(L"\s-1POST\*(R".\s0
.ie n .IP "$r\->uri" 4
.el .IP "\f(CW$r\fR\->uri" 4
.IX Item "$r->uri"
.PD 0
.ie n .IP "$r\->uri( $val )" 4
.el .IP "\f(CW$r\fR\->uri( \f(CW$val\fR )" 4
.IX Item "$r->uri( $val )"
.PD
This is used to get/set the uri attribute.  The \f(CW$val\fR can be a
reference to a \s-1URI\s0 object or a plain string.  If a string is given,
then it should be parseable as an absolute \s-1URI.\s0
.ie n .IP "$r\->header( $field )" 4
.el .IP "\f(CW$r\fR\->header( \f(CW$field\fR )" 4
.IX Item "$r->header( $field )"
.PD 0
.ie n .IP "$r\->header( $field => $value )" 4
.el .IP "\f(CW$r\fR\->header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$r->header( $field => $value )"
.PD
This is used to get/set header values and it is inherited from
\&\f(CW\*(C`HTTP::Headers\*(C'\fR via \f(CW\*(C`HTTP::Message\*(C'\fR.  See HTTP::Headers for
details and other similar methods that can be used to access the
headers.
.ie n .IP "$r\->accept_decodable" 4
.el .IP "\f(CW$r\fR\->accept_decodable" 4
.IX Item "$r->accept_decodable"
This will set the \f(CW\*(C`Accept\-Encoding\*(C'\fR header to the list of encodings
that \fIdecoded_content()\fR can decode.
.ie n .IP "$r\->content" 4
.el .IP "\f(CW$r\fR\->content" 4
.IX Item "$r->content"
.PD 0
.ie n .IP "$r\->content( $bytes )" 4
.el .IP "\f(CW$r\fR\->content( \f(CW$bytes\fR )" 4
.IX Item "$r->content( $bytes )"
.PD
This is used to get/set the content and it is inherited from the
\&\f(CW\*(C`HTTP::Message\*(C'\fR base class.  See HTTP::Message for details and
other methods that can be used to access the content.
.Sp
Note that the content should be a string of bytes.  Strings in perl
can contain characters outside the range of a byte.  The \f(CW\*(C`Encode\*(C'\fR
module can be used to turn such strings into a string of bytes.
.ie n .IP "$r\->as_string" 4
.el .IP "\f(CW$r\fR\->as_string" 4
.IX Item "$r->as_string"
.PD 0
.ie n .IP "$r\->as_string( $eol )" 4
.el .IP "\f(CW$r\fR\->as_string( \f(CW$eol\fR )" 4
.IX Item "$r->as_string( $eol )"
.PD
Method returning a textual representation of the request.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTTP::Headers, HTTP::Message, HTTP::Request::Common,
HTTP::Response
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2004 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Request::Common.3pm                    0100644 0001750 0001750 00000032312 12566241314 025147  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Request::Common 3"
.TH HTTP::Request::Common 3 "2012-09-30" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Request::Common \- Construct common HTTP::Request objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use HTTP::Request::Common;
\&  $ua = LWP::UserAgent\->new;
\&  $ua\->request(GET \*(Aqhttp://www.sn.no/\*(Aq);
\&  $ua\->request(POST \*(Aqhttp://somewhere/foo\*(Aq, [foo => bar, bar => foo]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provide functions that return newly created \f(CW\*(C`HTTP::Request\*(C'\fR
objects.  These functions are usually more convenient to use than the
standard \f(CW\*(C`HTTP::Request\*(C'\fR constructor for the most common requests.  The
following functions are provided:
.ie n .IP "\s-1GET\s0 $url" 4
.el .IP "\s-1GET\s0 \f(CW$url\fR" 4
.IX Item "GET $url"
.PD 0
.ie n .IP "\s-1GET\s0 $url, Header => Value,..." 4
.el .IP "\s-1GET\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "GET $url, Header => Value,..."
.PD
The \s-1\fIGET\s0()\fR function returns an \f(CW\*(C`HTTP::Request\*(C'\fR object initialized with
the \*(L"\s-1GET\*(R"\s0 method and the specified \s-1URL. \s0 It is roughly equivalent to the
following call
.Sp
.Vb 4
\&  HTTP::Request\->new(
\&     GET => $url,
\&     HTTP::Headers\->new(Header => Value,...),
\&  )
.Ve
.Sp
but is less cluttered.  What is different is that a header named
\&\f(CW\*(C`Content\*(C'\fR will initialize the content part of the request instead of
setting a header field.  Note that \s-1GET\s0 requests should normally not
have a content, so this hack makes more sense for the \s-1\fIPUT\s0()\fR and \s-1\fIPOST\s0()\fR
functions described below.
.Sp
The get(...) method of \f(CW\*(C`LWP::UserAgent\*(C'\fR exists as a shortcut for
\&\f(CW$ua\fR\->request(\s-1GET ...\s0).
.ie n .IP "\s-1HEAD\s0 $url" 4
.el .IP "\s-1HEAD\s0 \f(CW$url\fR" 4
.IX Item "HEAD $url"
.PD 0
.ie n .IP "\s-1HEAD\s0 $url, Header => Value,..." 4
.el .IP "\s-1HEAD\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "HEAD $url, Header => Value,..."
.PD
Like \s-1\fIGET\s0()\fR but the method in the request is \*(L"\s-1HEAD\*(R".\s0
.Sp
The head(...)  method of \*(L"LWP::UserAgent\*(R" exists as a shortcut for
\&\f(CW$ua\fR\->request(\s-1HEAD ...\s0).
.ie n .IP "\s-1PUT\s0 $url" 4
.el .IP "\s-1PUT\s0 \f(CW$url\fR" 4
.IX Item "PUT $url"
.PD 0
.ie n .IP "\s-1PUT\s0 $url, Header => Value,..." 4
.el .IP "\s-1PUT\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "PUT $url, Header => Value,..."
.ie n .IP "\s-1PUT\s0 $url, Header => Value,..., Content => $content" 4
.el .IP "\s-1PUT\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$content\fR" 4
.IX Item "PUT $url, Header => Value,..., Content => $content"
.PD
Like \s-1\fIGET\s0()\fR but the method in the request is \*(L"\s-1PUT\*(R".\s0
.Sp
The content of the request can be specified using the \*(L"Content\*(R"
pseudo-header.  This steals a bit of the header field namespace as
there is no way to directly specify a header that is actually called
\&\*(L"Content\*(R".  If you really need this you must update the request
returned in a separate statement.
.ie n .IP "\s-1DELETE\s0 $url" 4
.el .IP "\s-1DELETE\s0 \f(CW$url\fR" 4
.IX Item "DELETE $url"
.PD 0
.ie n .IP "\s-1DELETE\s0 $url, Header => Value,..." 4
.el .IP "\s-1DELETE\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "DELETE $url, Header => Value,..."
.PD
Like \s-1\fIGET\s0()\fR but the method in the request is \*(L"\s-1DELETE\*(R". \s0 This function
is not exported by default.
.ie n .IP "\s-1POST\s0 $url" 4
.el .IP "\s-1POST\s0 \f(CW$url\fR" 4
.IX Item "POST $url"
.PD 0
.ie n .IP "\s-1POST\s0 $url, Header => Value,..." 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "POST $url, Header => Value,..."
.ie n .IP "\s-1POST\s0 $url, $form_ref, Header => Value,..." 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, \f(CW$form_ref\fR, Header => Value,..." 4
.IX Item "POST $url, $form_ref, Header => Value,..."
.ie n .IP "\s-1POST\s0 $url, Header => Value,..., Content => $form_ref" 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$form_ref\fR" 4
.IX Item "POST $url, Header => Value,..., Content => $form_ref"
.ie n .IP "\s-1POST\s0 $url, Header => Value,..., Content => $content" 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$content\fR" 4
.IX Item "POST $url, Header => Value,..., Content => $content"
.PD
This works mostly like \s-1\fIPUT\s0()\fR with \*(L"\s-1POST\*(R"\s0 as the method, but this
function also takes a second optional array or hash reference
parameter \f(CW$form_ref\fR.  As for \s-1\fIPUT\s0()\fR the content can also be specified
directly using the \*(L"Content\*(R" pseudo-header, and you may also provide
the \f(CW$form_ref\fR this way.
.Sp
The \f(CW$form_ref\fR argument can be used to pass key/value pairs for the
form content.  By default we will initialize a request using the
\&\f(CW\*(C`application/x\-www\-form\-urlencoded\*(C'\fR content type.  This means that
you can emulate an \s-1HTML\s0 <form> POSTing like this:
.Sp
.Vb 7
\&  POST \*(Aqhttp://www.perl.org/survey.cgi\*(Aq,
\&       [ name   => \*(AqGisle Aas\*(Aq,
\&         email  => \*(Aqgisle@aas.no\*(Aq,
\&         gender => \*(AqM\*(Aq,
\&         born   => \*(Aq1964\*(Aq,
\&         perc   => \*(Aq3%\*(Aq,
\&       ];
.Ve
.Sp
This will create an HTTP::Request object that looks like this:
.Sp
.Vb 3
\&  POST http://www.perl.org/survey.cgi
\&  Content\-Length: 66
\&  Content\-Type: application/x\-www\-form\-urlencoded
\&
\&  name=Gisle%20Aas&email=gisle%40aas.no&gender=M&born=1964&perc=3%25
.Ve
.Sp
Multivalued form fields can be specified by either repeating the field
name or by passing the value as an array reference.
.Sp
The \s-1POST\s0 method also supports the \f(CW\*(C`multipart/form\-data\*(C'\fR content used
for \fIForm-based File Upload\fR as specified in \s-1RFC 1867. \s0 You trigger
this content format by specifying a content type of \f(CW\*(Aqform\-data\*(Aq\fR as
one of the request headers.  If one of the values in the \f(CW$form_ref\fR is
an array reference, then it is treated as a file part specification
with the following interpretation:
.Sp
.Vb 2
\&  [ $file, $filename, Header => Value... ]
\&  [ undef, $filename, Header => Value,..., Content => $content ]
.Ve
.Sp
The first value in the array ($file) is the name of a file to open.
This file will be read and its content placed in the request.  The
routine will croak if the file can't be opened.  Use an \f(CW\*(C`undef\*(C'\fR as
\&\f(CW$file\fR value if you want to specify the content directly with a
\&\f(CW\*(C`Content\*(C'\fR header.  The \f(CW$filename\fR is the filename to report in the
request.  If this value is undefined, then the basename of the \f(CW$file\fR
will be used.  You can specify an empty string as \f(CW$filename\fR if you
want to suppress sending the filename when you provide a \f(CW$file\fR value.
.Sp
If a \f(CW$file\fR is provided by no \f(CW\*(C`Content\-Type\*(C'\fR header, then \f(CW\*(C`Content\-Type\*(C'\fR
and \f(CW\*(C`Content\-Encoding\*(C'\fR will be filled in automatically with the values
returned by \fILWP::MediaTypes::guess_media_type()\fR
.Sp
Sending my \fI~/.profile\fR to the survey used as example above can be
achieved by this:
.Sp
.Vb 8
\&  POST \*(Aqhttp://www.perl.org/survey.cgi\*(Aq,
\&       Content_Type => \*(Aqform\-data\*(Aq,
\&       Content      => [ name  => \*(AqGisle Aas\*(Aq,
\&                         email => \*(Aqgisle@aas.no\*(Aq,
\&                         gender => \*(AqM\*(Aq,
\&                         born   => \*(Aq1964\*(Aq,
\&                         init   => ["$ENV{HOME}/.profile"],
\&                       ]
.Ve
.Sp
This will create an HTTP::Request object that almost looks this (the
boundary and the content of your \fI~/.profile\fR is likely to be
different):
.Sp
.Vb 3
\&  POST http://www.perl.org/survey.cgi
\&  Content\-Length: 388
\&  Content\-Type: multipart/form\-data; boundary="6G+f"
\&
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="name"
\&
\&  Gisle Aas
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="email"
\&
\&  gisle@aas.no
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="gender"
\&
\&  M
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="born"
\&
\&  1964
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="init"; filename=".profile"
\&  Content\-Type: text/plain
\&
\&  PATH=/local/perl/bin:$PATH
\&  export PATH
\&
\&  \-\-6G+f\-\-
.Ve
.Sp
If you set the \f(CW$DYNAMIC_FILE_UPLOAD\fR variable (exportable) to some \s-1TRUE\s0
value, then you get back a request object with a subroutine closure as
the content attribute.  This subroutine will read the content of any
files on demand and return it in suitable chunks.  This allow you to
upload arbitrary big files without using lots of memory.  You can even
upload infinite files like \fI/dev/audio\fR if you wish; however, if
the file is not a plain file, there will be no Content-Length header
defined for the request.  Not all servers (or server
applications) like this.  Also, if the file(s) change in size between
the time the Content-Length is calculated and the time that the last
chunk is delivered, the subroutine will \f(CW\*(C`Croak\*(C'\fR.
.Sp
The post(...)  method of \*(L"LWP::UserAgent\*(R" exists as a shortcut for
\&\f(CW$ua\fR\->request(\s-1POST ...\s0).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTTP::Request, LWP::UserAgent
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1997\-2004, Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Request::Common5.16.3pm                0100644 0001750 0001750 00000031771 12566241314 025471  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Request::Common 3"
.TH HTTP::Request::Common 3 "2012-09-30" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Request::Common \- Construct common HTTP::Request objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use HTTP::Request::Common;
\&  $ua = LWP::UserAgent\->new;
\&  $ua\->request(GET \*(Aqhttp://www.sn.no/\*(Aq);
\&  $ua\->request(POST \*(Aqhttp://somewhere/foo\*(Aq, [foo => bar, bar => foo]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provide functions that return newly created \f(CW\*(C`HTTP::Request\*(C'\fR
objects.  These functions are usually more convenient to use than the
standard \f(CW\*(C`HTTP::Request\*(C'\fR constructor for the most common requests.  The
following functions are provided:
.ie n .IP "\s-1GET\s0 $url" 4
.el .IP "\s-1GET\s0 \f(CW$url\fR" 4
.IX Item "GET $url"
.PD 0
.ie n .IP "\s-1GET\s0 $url, Header => Value,..." 4
.el .IP "\s-1GET\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "GET $url, Header => Value,..."
.PD
The \s-1\fIGET\s0()\fR function returns an \f(CW\*(C`HTTP::Request\*(C'\fR object initialized with
the \*(L"\s-1GET\s0\*(R" method and the specified \s-1URL\s0.  It is roughly equivalent to the
following call
.Sp
.Vb 4
\&  HTTP::Request\->new(
\&     GET => $url,
\&     HTTP::Headers\->new(Header => Value,...),
\&  )
.Ve
.Sp
but is less cluttered.  What is different is that a header named
\&\f(CW\*(C`Content\*(C'\fR will initialize the content part of the request instead of
setting a header field.  Note that \s-1GET\s0 requests should normally not
have a content, so this hack makes more sense for the \s-1\fIPUT\s0()\fR and \s-1\fIPOST\s0()\fR
functions described below.
.Sp
The get(...) method of \f(CW\*(C`LWP::UserAgent\*(C'\fR exists as a shortcut for
\&\f(CW$ua\fR\->request(\s-1GET\s0 ...).
.ie n .IP "\s-1HEAD\s0 $url" 4
.el .IP "\s-1HEAD\s0 \f(CW$url\fR" 4
.IX Item "HEAD $url"
.PD 0
.ie n .IP "\s-1HEAD\s0 $url, Header => Value,..." 4
.el .IP "\s-1HEAD\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "HEAD $url, Header => Value,..."
.PD
Like \s-1\fIGET\s0()\fR but the method in the request is \*(L"\s-1HEAD\s0\*(R".
.Sp
The head(...)  method of \*(L"LWP::UserAgent\*(R" exists as a shortcut for
\&\f(CW$ua\fR\->request(\s-1HEAD\s0 ...).
.ie n .IP "\s-1PUT\s0 $url" 4
.el .IP "\s-1PUT\s0 \f(CW$url\fR" 4
.IX Item "PUT $url"
.PD 0
.ie n .IP "\s-1PUT\s0 $url, Header => Value,..." 4
.el .IP "\s-1PUT\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "PUT $url, Header => Value,..."
.ie n .IP "\s-1PUT\s0 $url, Header => Value,..., Content => $content" 4
.el .IP "\s-1PUT\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$content\fR" 4
.IX Item "PUT $url, Header => Value,..., Content => $content"
.PD
Like \s-1\fIGET\s0()\fR but the method in the request is \*(L"\s-1PUT\s0\*(R".
.Sp
The content of the request can be specified using the \*(L"Content\*(R"
pseudo-header.  This steals a bit of the header field namespace as
there is no way to directly specify a header that is actually called
\&\*(L"Content\*(R".  If you really need this you must update the request
returned in a separate statement.
.ie n .IP "\s-1DELETE\s0 $url" 4
.el .IP "\s-1DELETE\s0 \f(CW$url\fR" 4
.IX Item "DELETE $url"
.PD 0
.ie n .IP "\s-1DELETE\s0 $url, Header => Value,..." 4
.el .IP "\s-1DELETE\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "DELETE $url, Header => Value,..."
.PD
Like \s-1\fIGET\s0()\fR but the method in the request is \*(L"\s-1DELETE\s0\*(R".  This function
is not exported by default.
.ie n .IP "\s-1POST\s0 $url" 4
.el .IP "\s-1POST\s0 \f(CW$url\fR" 4
.IX Item "POST $url"
.PD 0
.ie n .IP "\s-1POST\s0 $url, Header => Value,..." 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "POST $url, Header => Value,..."
.ie n .IP "\s-1POST\s0 $url, $form_ref, Header => Value,..." 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, \f(CW$form_ref\fR, Header => Value,..." 4
.IX Item "POST $url, $form_ref, Header => Value,..."
.ie n .IP "\s-1POST\s0 $url, Header => Value,..., Content => $form_ref" 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$form_ref\fR" 4
.IX Item "POST $url, Header => Value,..., Content => $form_ref"
.ie n .IP "\s-1POST\s0 $url, Header => Value,..., Content => $content" 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$content\fR" 4
.IX Item "POST $url, Header => Value,..., Content => $content"
.PD
This works mostly like \s-1\fIPUT\s0()\fR with \*(L"\s-1POST\s0\*(R" as the method, but this
function also takes a second optional array or hash reference
parameter \f(CW$form_ref\fR.  As for \s-1\fIPUT\s0()\fR the content can also be specified
directly using the \*(L"Content\*(R" pseudo-header, and you may also provide
the \f(CW$form_ref\fR this way.
.Sp
The \f(CW$form_ref\fR argument can be used to pass key/value pairs for the
form content.  By default we will initialize a request using the
\&\f(CW\*(C`application/x\-www\-form\-urlencoded\*(C'\fR content type.  This means that
you can emulate an \s-1HTML\s0 <form> POSTing like this:
.Sp
.Vb 7
\&  POST \*(Aqhttp://www.perl.org/survey.cgi\*(Aq,
\&       [ name   => \*(AqGisle Aas\*(Aq,
\&         email  => \*(Aqgisle@aas.no\*(Aq,
\&         gender => \*(AqM\*(Aq,
\&         born   => \*(Aq1964\*(Aq,
\&         perc   => \*(Aq3%\*(Aq,
\&       ];
.Ve
.Sp
This will create an HTTP::Request object that looks like this:
.Sp
.Vb 3
\&  POST http://www.perl.org/survey.cgi
\&  Content\-Length: 66
\&  Content\-Type: application/x\-www\-form\-urlencoded
\&
\&  name=Gisle%20Aas&email=gisle%40aas.no&gender=M&born=1964&perc=3%25
.Ve
.Sp
Multivalued form fields can be specified by either repeating the field
name or by passing the value as an array reference.
.Sp
The \s-1POST\s0 method also supports the \f(CW\*(C`multipart/form\-data\*(C'\fR content used
for \fIForm-based File Upload\fR as specified in \s-1RFC\s0 1867.  You trigger
this content format by specifying a content type of \f(CW\*(Aqform\-data\*(Aq\fR as
one of the request headers.  If one of the values in the \f(CW$form_ref\fR is
an array reference, then it is treated as a file part specification
with the following interpretation:
.Sp
.Vb 2
\&  [ $file, $filename, Header => Value... ]
\&  [ undef, $filename, Header => Value,..., Content => $content ]
.Ve
.Sp
The first value in the array ($file) is the name of a file to open.
This file will be read and its content placed in the request.  The
routine will croak if the file can't be opened.  Use an \f(CW\*(C`undef\*(C'\fR as
\&\f(CW$file\fR value if you want to specify the content directly with a
\&\f(CW\*(C`Content\*(C'\fR header.  The \f(CW$filename\fR is the filename to report in the
request.  If this value is undefined, then the basename of the \f(CW$file\fR
will be used.  You can specify an empty string as \f(CW$filename\fR if you
want to suppress sending the filename when you provide a \f(CW$file\fR value.
.Sp
If a \f(CW$file\fR is provided by no \f(CW\*(C`Content\-Type\*(C'\fR header, then \f(CW\*(C`Content\-Type\*(C'\fR
and \f(CW\*(C`Content\-Encoding\*(C'\fR will be filled in automatically with the values
returned by \fILWP::MediaTypes::guess_media_type()\fR
.Sp
Sending my \fI~/.profile\fR to the survey used as example above can be
achieved by this:
.Sp
.Vb 8
\&  POST \*(Aqhttp://www.perl.org/survey.cgi\*(Aq,
\&       Content_Type => \*(Aqform\-data\*(Aq,
\&       Content      => [ name  => \*(AqGisle Aas\*(Aq,
\&                         email => \*(Aqgisle@aas.no\*(Aq,
\&                         gender => \*(AqM\*(Aq,
\&                         born   => \*(Aq1964\*(Aq,
\&                         init   => ["$ENV{HOME}/.profile"],
\&                       ]
.Ve
.Sp
This will create an HTTP::Request object that almost looks this (the
boundary and the content of your \fI~/.profile\fR is likely to be
different):
.Sp
.Vb 3
\&  POST http://www.perl.org/survey.cgi
\&  Content\-Length: 388
\&  Content\-Type: multipart/form\-data; boundary="6G+f"
\&
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="name"
\&
\&  Gisle Aas
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="email"
\&
\&  gisle@aas.no
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="gender"
\&
\&  M
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="born"
\&
\&  1964
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="init"; filename=".profile"
\&  Content\-Type: text/plain
\&
\&  PATH=/local/perl/bin:$PATH
\&  export PATH
\&
\&  \-\-6G+f\-\-
.Ve
.Sp
If you set the \f(CW$DYNAMIC_FILE_UPLOAD\fR variable (exportable) to some \s-1TRUE\s0
value, then you get back a request object with a subroutine closure as
the content attribute.  This subroutine will read the content of any
files on demand and return it in suitable chunks.  This allow you to
upload arbitrary big files without using lots of memory.  You can even
upload infinite files like \fI/dev/audio\fR if you wish; however, if
the file is not a plain file, there will be no Content-Length header
defined for the request.  Not all servers (or server
applications) like this.  Also, if the file(s) change in size between
the time the Content-Length is calculated and the time that the last
chunk is delivered, the subroutine will \f(CW\*(C`Croak\*(C'\fR.
.Sp
The post(...)  method of \*(L"LWP::UserAgent\*(R" exists as a shortcut for
\&\f(CW$ua\fR\->request(\s-1POST\s0 ...).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTTP::Request, LWP::UserAgent
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1997\-2004, Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Request::Common5.18.3pm                0100644 0001750 0001750 00000032312 12566241314 025463  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Request::Common 3"
.TH HTTP::Request::Common 3 "2012-09-30" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Request::Common \- Construct common HTTP::Request objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use HTTP::Request::Common;
\&  $ua = LWP::UserAgent\->new;
\&  $ua\->request(GET \*(Aqhttp://www.sn.no/\*(Aq);
\&  $ua\->request(POST \*(Aqhttp://somewhere/foo\*(Aq, [foo => bar, bar => foo]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provide functions that return newly created \f(CW\*(C`HTTP::Request\*(C'\fR
objects.  These functions are usually more convenient to use than the
standard \f(CW\*(C`HTTP::Request\*(C'\fR constructor for the most common requests.  The
following functions are provided:
.ie n .IP "\s-1GET\s0 $url" 4
.el .IP "\s-1GET\s0 \f(CW$url\fR" 4
.IX Item "GET $url"
.PD 0
.ie n .IP "\s-1GET\s0 $url, Header => Value,..." 4
.el .IP "\s-1GET\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "GET $url, Header => Value,..."
.PD
The \s-1\fIGET\s0()\fR function returns an \f(CW\*(C`HTTP::Request\*(C'\fR object initialized with
the \*(L"\s-1GET\*(R"\s0 method and the specified \s-1URL. \s0 It is roughly equivalent to the
following call
.Sp
.Vb 4
\&  HTTP::Request\->new(
\&     GET => $url,
\&     HTTP::Headers\->new(Header => Value,...),
\&  )
.Ve
.Sp
but is less cluttered.  What is different is that a header named
\&\f(CW\*(C`Content\*(C'\fR will initialize the content part of the request instead of
setting a header field.  Note that \s-1GET\s0 requests should normally not
have a content, so this hack makes more sense for the \s-1\fIPUT\s0()\fR and \s-1\fIPOST\s0()\fR
functions described below.
.Sp
The get(...) method of \f(CW\*(C`LWP::UserAgent\*(C'\fR exists as a shortcut for
\&\f(CW$ua\fR\->request(\s-1GET ...\s0).
.ie n .IP "\s-1HEAD\s0 $url" 4
.el .IP "\s-1HEAD\s0 \f(CW$url\fR" 4
.IX Item "HEAD $url"
.PD 0
.ie n .IP "\s-1HEAD\s0 $url, Header => Value,..." 4
.el .IP "\s-1HEAD\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "HEAD $url, Header => Value,..."
.PD
Like \s-1\fIGET\s0()\fR but the method in the request is \*(L"\s-1HEAD\*(R".\s0
.Sp
The head(...)  method of \*(L"LWP::UserAgent\*(R" exists as a shortcut for
\&\f(CW$ua\fR\->request(\s-1HEAD ...\s0).
.ie n .IP "\s-1PUT\s0 $url" 4
.el .IP "\s-1PUT\s0 \f(CW$url\fR" 4
.IX Item "PUT $url"
.PD 0
.ie n .IP "\s-1PUT\s0 $url, Header => Value,..." 4
.el .IP "\s-1PUT\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "PUT $url, Header => Value,..."
.ie n .IP "\s-1PUT\s0 $url, Header => Value,..., Content => $content" 4
.el .IP "\s-1PUT\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$content\fR" 4
.IX Item "PUT $url, Header => Value,..., Content => $content"
.PD
Like \s-1\fIGET\s0()\fR but the method in the request is \*(L"\s-1PUT\*(R".\s0
.Sp
The content of the request can be specified using the \*(L"Content\*(R"
pseudo-header.  This steals a bit of the header field namespace as
there is no way to directly specify a header that is actually called
\&\*(L"Content\*(R".  If you really need this you must update the request
returned in a separate statement.
.ie n .IP "\s-1DELETE\s0 $url" 4
.el .IP "\s-1DELETE\s0 \f(CW$url\fR" 4
.IX Item "DELETE $url"
.PD 0
.ie n .IP "\s-1DELETE\s0 $url, Header => Value,..." 4
.el .IP "\s-1DELETE\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "DELETE $url, Header => Value,..."
.PD
Like \s-1\fIGET\s0()\fR but the method in the request is \*(L"\s-1DELETE\*(R". \s0 This function
is not exported by default.
.ie n .IP "\s-1POST\s0 $url" 4
.el .IP "\s-1POST\s0 \f(CW$url\fR" 4
.IX Item "POST $url"
.PD 0
.ie n .IP "\s-1POST\s0 $url, Header => Value,..." 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, Header => Value,..." 4
.IX Item "POST $url, Header => Value,..."
.ie n .IP "\s-1POST\s0 $url, $form_ref, Header => Value,..." 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, \f(CW$form_ref\fR, Header => Value,..." 4
.IX Item "POST $url, $form_ref, Header => Value,..."
.ie n .IP "\s-1POST\s0 $url, Header => Value,..., Content => $form_ref" 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$form_ref\fR" 4
.IX Item "POST $url, Header => Value,..., Content => $form_ref"
.ie n .IP "\s-1POST\s0 $url, Header => Value,..., Content => $content" 4
.el .IP "\s-1POST\s0 \f(CW$url\fR, Header => Value,..., Content => \f(CW$content\fR" 4
.IX Item "POST $url, Header => Value,..., Content => $content"
.PD
This works mostly like \s-1\fIPUT\s0()\fR with \*(L"\s-1POST\*(R"\s0 as the method, but this
function also takes a second optional array or hash reference
parameter \f(CW$form_ref\fR.  As for \s-1\fIPUT\s0()\fR the content can also be specified
directly using the \*(L"Content\*(R" pseudo-header, and you may also provide
the \f(CW$form_ref\fR this way.
.Sp
The \f(CW$form_ref\fR argument can be used to pass key/value pairs for the
form content.  By default we will initialize a request using the
\&\f(CW\*(C`application/x\-www\-form\-urlencoded\*(C'\fR content type.  This means that
you can emulate an \s-1HTML\s0 <form> POSTing like this:
.Sp
.Vb 7
\&  POST \*(Aqhttp://www.perl.org/survey.cgi\*(Aq,
\&       [ name   => \*(AqGisle Aas\*(Aq,
\&         email  => \*(Aqgisle@aas.no\*(Aq,
\&         gender => \*(AqM\*(Aq,
\&         born   => \*(Aq1964\*(Aq,
\&         perc   => \*(Aq3%\*(Aq,
\&       ];
.Ve
.Sp
This will create an HTTP::Request object that looks like this:
.Sp
.Vb 3
\&  POST http://www.perl.org/survey.cgi
\&  Content\-Length: 66
\&  Content\-Type: application/x\-www\-form\-urlencoded
\&
\&  name=Gisle%20Aas&email=gisle%40aas.no&gender=M&born=1964&perc=3%25
.Ve
.Sp
Multivalued form fields can be specified by either repeating the field
name or by passing the value as an array reference.
.Sp
The \s-1POST\s0 method also supports the \f(CW\*(C`multipart/form\-data\*(C'\fR content used
for \fIForm-based File Upload\fR as specified in \s-1RFC 1867. \s0 You trigger
this content format by specifying a content type of \f(CW\*(Aqform\-data\*(Aq\fR as
one of the request headers.  If one of the values in the \f(CW$form_ref\fR is
an array reference, then it is treated as a file part specification
with the following interpretation:
.Sp
.Vb 2
\&  [ $file, $filename, Header => Value... ]
\&  [ undef, $filename, Header => Value,..., Content => $content ]
.Ve
.Sp
The first value in the array ($file) is the name of a file to open.
This file will be read and its content placed in the request.  The
routine will croak if the file can't be opened.  Use an \f(CW\*(C`undef\*(C'\fR as
\&\f(CW$file\fR value if you want to specify the content directly with a
\&\f(CW\*(C`Content\*(C'\fR header.  The \f(CW$filename\fR is the filename to report in the
request.  If this value is undefined, then the basename of the \f(CW$file\fR
will be used.  You can specify an empty string as \f(CW$filename\fR if you
want to suppress sending the filename when you provide a \f(CW$file\fR value.
.Sp
If a \f(CW$file\fR is provided by no \f(CW\*(C`Content\-Type\*(C'\fR header, then \f(CW\*(C`Content\-Type\*(C'\fR
and \f(CW\*(C`Content\-Encoding\*(C'\fR will be filled in automatically with the values
returned by \fILWP::MediaTypes::guess_media_type()\fR
.Sp
Sending my \fI~/.profile\fR to the survey used as example above can be
achieved by this:
.Sp
.Vb 8
\&  POST \*(Aqhttp://www.perl.org/survey.cgi\*(Aq,
\&       Content_Type => \*(Aqform\-data\*(Aq,
\&       Content      => [ name  => \*(AqGisle Aas\*(Aq,
\&                         email => \*(Aqgisle@aas.no\*(Aq,
\&                         gender => \*(AqM\*(Aq,
\&                         born   => \*(Aq1964\*(Aq,
\&                         init   => ["$ENV{HOME}/.profile"],
\&                       ]
.Ve
.Sp
This will create an HTTP::Request object that almost looks this (the
boundary and the content of your \fI~/.profile\fR is likely to be
different):
.Sp
.Vb 3
\&  POST http://www.perl.org/survey.cgi
\&  Content\-Length: 388
\&  Content\-Type: multipart/form\-data; boundary="6G+f"
\&
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="name"
\&
\&  Gisle Aas
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="email"
\&
\&  gisle@aas.no
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="gender"
\&
\&  M
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="born"
\&
\&  1964
\&  \-\-6G+f
\&  Content\-Disposition: form\-data; name="init"; filename=".profile"
\&  Content\-Type: text/plain
\&
\&  PATH=/local/perl/bin:$PATH
\&  export PATH
\&
\&  \-\-6G+f\-\-
.Ve
.Sp
If you set the \f(CW$DYNAMIC_FILE_UPLOAD\fR variable (exportable) to some \s-1TRUE\s0
value, then you get back a request object with a subroutine closure as
the content attribute.  This subroutine will read the content of any
files on demand and return it in suitable chunks.  This allow you to
upload arbitrary big files without using lots of memory.  You can even
upload infinite files like \fI/dev/audio\fR if you wish; however, if
the file is not a plain file, there will be no Content-Length header
defined for the request.  Not all servers (or server
applications) like this.  Also, if the file(s) change in size between
the time the Content-Length is calculated and the time that the last
chunk is delivered, the subroutine will \f(CW\*(C`Croak\*(C'\fR.
.Sp
The post(...)  method of \*(L"LWP::UserAgent\*(R" exists as a shortcut for
\&\f(CW$ua\fR\->request(\s-1POST ...\s0).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTTP::Request, LWP::UserAgent
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1997\-2004, Gisle Aas
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Response.3pm                           0100644 0001750 0001750 00000041403 12566241314 023761  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Response 3"
.TH HTTP::Response 3 "2012-09-30" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Response \- HTTP style response message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Response objects are returned by the \fIrequest()\fR method of the \f(CW\*(C`LWP::UserAgent\*(C'\fR:
.PP
.Vb 8
\&    # ...
\&    $response = $ua\->request($request)
\&    if ($response\->is_success) {
\&        print $response\->decoded_content;
\&    }
\&    else {
\&        print STDERR $response\->status_line, "\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`HTTP::Response\*(C'\fR class encapsulates \s-1HTTP\s0 style responses.  A
response consists of a response line, some headers, and a content
body. Note that the \s-1LWP\s0 library uses \s-1HTTP\s0 style responses even for
non-HTTP protocol schemes.  Instances of this class are usually
created and returned by the \fIrequest()\fR method of an \f(CW\*(C`LWP::UserAgent\*(C'\fR
object.
.PP
\&\f(CW\*(C`HTTP::Response\*(C'\fR is a subclass of \f(CW\*(C`HTTP::Message\*(C'\fR and therefore
inherits its methods.  The following additional methods are available:
.ie n .IP "$r = HTTP::Response\->new( $code )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->new( \f(CW$code\fR )" 4
.IX Item "$r = HTTP::Response->new( $code )"
.PD 0
.ie n .IP "$r = HTTP::Response\->new( $code, $msg )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->new( \f(CW$code\fR, \f(CW$msg\fR )" 4
.IX Item "$r = HTTP::Response->new( $code, $msg )"
.ie n .IP "$r = HTTP::Response\->new( $code, $msg, $header )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->new( \f(CW$code\fR, \f(CW$msg\fR, \f(CW$header\fR )" 4
.IX Item "$r = HTTP::Response->new( $code, $msg, $header )"
.ie n .IP "$r = HTTP::Response\->new( $code, $msg, $header, $content )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->new( \f(CW$code\fR, \f(CW$msg\fR, \f(CW$header\fR, \f(CW$content\fR )" 4
.IX Item "$r = HTTP::Response->new( $code, $msg, $header, $content )"
.PD
Constructs a new \f(CW\*(C`HTTP::Response\*(C'\fR object describing a response with
response code \f(CW$code\fR and optional message \f(CW$msg\fR.  The optional \f(CW$header\fR
argument should be a reference to an \f(CW\*(C`HTTP::Headers\*(C'\fR object or a
plain array reference of key/value pairs.  The optional \f(CW$content\fR
argument should be a string of bytes.  The meanings of these arguments are
described below.
.ie n .IP "$r = HTTP::Response\->parse( $str )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->parse( \f(CW$str\fR )" 4
.IX Item "$r = HTTP::Response->parse( $str )"
This constructs a new response object by parsing the given string.
.ie n .IP "$r\->code" 4
.el .IP "\f(CW$r\fR\->code" 4
.IX Item "$r->code"
.PD 0
.ie n .IP "$r\->code( $code )" 4
.el .IP "\f(CW$r\fR\->code( \f(CW$code\fR )" 4
.IX Item "$r->code( $code )"
.PD
This is used to get/set the code attribute.  The code is a 3 digit
number that encode the overall outcome of an \s-1HTTP\s0 response.  The
\&\f(CW\*(C`HTTP::Status\*(C'\fR module provide constants that provide mnemonic names
for the code attribute.
.ie n .IP "$r\->message" 4
.el .IP "\f(CW$r\fR\->message" 4
.IX Item "$r->message"
.PD 0
.ie n .IP "$r\->message( $message )" 4
.el .IP "\f(CW$r\fR\->message( \f(CW$message\fR )" 4
.IX Item "$r->message( $message )"
.PD
This is used to get/set the message attribute.  The message is a short
human readable single line string that explains the response code.
.ie n .IP "$r\->header( $field )" 4
.el .IP "\f(CW$r\fR\->header( \f(CW$field\fR )" 4
.IX Item "$r->header( $field )"
.PD 0
.ie n .IP "$r\->header( $field => $value )" 4
.el .IP "\f(CW$r\fR\->header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$r->header( $field => $value )"
.PD
This is used to get/set header values and it is inherited from
\&\f(CW\*(C`HTTP::Headers\*(C'\fR via \f(CW\*(C`HTTP::Message\*(C'\fR.  See HTTP::Headers for
details and other similar methods that can be used to access the
headers.
.ie n .IP "$r\->content" 4
.el .IP "\f(CW$r\fR\->content" 4
.IX Item "$r->content"
.PD 0
.ie n .IP "$r\->content( $bytes )" 4
.el .IP "\f(CW$r\fR\->content( \f(CW$bytes\fR )" 4
.IX Item "$r->content( $bytes )"
.PD
This is used to get/set the raw content and it is inherited from the
\&\f(CW\*(C`HTTP::Message\*(C'\fR base class.  See HTTP::Message for details and
other methods that can be used to access the content.
.ie n .IP "$r\->decoded_content( %options )" 4
.el .IP "\f(CW$r\fR\->decoded_content( \f(CW%options\fR )" 4
.IX Item "$r->decoded_content( %options )"
This will return the content after any \f(CW\*(C`Content\-Encoding\*(C'\fR and
charsets have been decoded.  See HTTP::Message for details.
.ie n .IP "$r\->request" 4
.el .IP "\f(CW$r\fR\->request" 4
.IX Item "$r->request"
.PD 0
.ie n .IP "$r\->request( $request )" 4
.el .IP "\f(CW$r\fR\->request( \f(CW$request\fR )" 4
.IX Item "$r->request( $request )"
.PD
This is used to get/set the request attribute.  The request attribute
is a reference to the the request that caused this response.  It does
not have to be the same request passed to the \f(CW$ua\fR\->\fIrequest()\fR method,
because there might have been redirects and authorization retries in
between.
.ie n .IP "$r\->previous" 4
.el .IP "\f(CW$r\fR\->previous" 4
.IX Item "$r->previous"
.PD 0
.ie n .IP "$r\->previous( $response )" 4
.el .IP "\f(CW$r\fR\->previous( \f(CW$response\fR )" 4
.IX Item "$r->previous( $response )"
.PD
This is used to get/set the previous attribute.  The previous
attribute is used to link together chains of responses.  You get
chains of responses if the first response is redirect or unauthorized.
The value is \f(CW\*(C`undef\*(C'\fR if this is the first response in a chain.
.Sp
Note that the method \f(CW$r\fR\->redirects is provided as a more convenient
way to access the response chain.
.ie n .IP "$r\->status_line" 4
.el .IP "\f(CW$r\fR\->status_line" 4
.IX Item "$r->status_line"
Returns the string \*(L"<code> <message>\*(R".  If the message attribute
is not set then the official name of <code> (see HTTP::Status)
is substituted.
.ie n .IP "$r\->base" 4
.el .IP "\f(CW$r\fR\->base" 4
.IX Item "$r->base"
Returns the base \s-1URI\s0 for this response.  The return value will be a
reference to a \s-1URI\s0 object.
.Sp
The base \s-1URI\s0 is obtained from one the following sources (in priority
order):
.RS 4
.IP "1." 4
Embedded in the document content, for instance <\s-1BASE\s0 HREF=\*(L"...\*(R">
in \s-1HTML\s0 documents.
.IP "2." 4
A \*(L"Content-Base:\*(R" or a \*(L"Content-Location:\*(R" header in the response.
.Sp
For backwards compatibility with older \s-1HTTP\s0 implementations we will
also look for the \*(L"Base:\*(R" header.
.IP "3." 4
The \s-1URI\s0 used to request this response. This might not be the original
\&\s-1URI\s0 that was passed to \f(CW$ua\fR\->\fIrequest()\fR method, because we might have
received some redirect responses first.
.RE
.RS 4
.Sp
If none of these sources provide an absolute \s-1URI,\s0 undef is returned.
.Sp
When the \s-1LWP\s0 protocol modules produce the HTTP::Response object, then
any base \s-1URI\s0 embedded in the document (step 1) will already have
initialized the \*(L"Content-Base:\*(R" header. This means that this method
only performs the last 2 steps (the content is not always available
either).
.RE
.ie n .IP "$r\->filename" 4
.el .IP "\f(CW$r\fR\->filename" 4
.IX Item "$r->filename"
Returns a filename for this response.  Note that doing sanity checks
on the returned filename (eg. removing characters that cannot be used
on the target filesystem where the filename would be used, and
laundering it for security purposes) are the caller's responsibility;
the only related thing done by this method is that it makes a simple
attempt to return a plain filename with no preceding path segments.
.Sp
The filename is obtained from one the following sources (in priority
order):
.RS 4
.IP "1." 4
A \*(L"Content-Disposition:\*(R" header in the response.  Proper decoding of
\&\s-1RFC 2047\s0 encoded filenames requires the \f(CW\*(C`MIME::QuotedPrint\*(C'\fR (for \*(L"Q\*(R"
encoding), \f(CW\*(C`MIME::Base64\*(C'\fR (for \*(L"B\*(R" encoding), and \f(CW\*(C`Encode\*(C'\fR modules.
.IP "2." 4
A \*(L"Content-Location:\*(R" header in the response.
.IP "3." 4
The \s-1URI\s0 used to request this response. This might not be the original
\&\s-1URI\s0 that was passed to \f(CW$ua\fR\->\fIrequest()\fR method, because we might have
received some redirect responses first.
.RE
.RS 4
.Sp
If a filename cannot be derived from any of these sources, undef is
returned.
.RE
.ie n .IP "$r\->as_string" 4
.el .IP "\f(CW$r\fR\->as_string" 4
.IX Item "$r->as_string"
.PD 0
.ie n .IP "$r\->as_string( $eol )" 4
.el .IP "\f(CW$r\fR\->as_string( \f(CW$eol\fR )" 4
.IX Item "$r->as_string( $eol )"
.PD
Returns a textual representation of the response.
.ie n .IP "$r\->is_info" 4
.el .IP "\f(CW$r\fR\->is_info" 4
.IX Item "$r->is_info"
.PD 0
.ie n .IP "$r\->is_success" 4
.el .IP "\f(CW$r\fR\->is_success" 4
.IX Item "$r->is_success"
.ie n .IP "$r\->is_redirect" 4
.el .IP "\f(CW$r\fR\->is_redirect" 4
.IX Item "$r->is_redirect"
.ie n .IP "$r\->is_error" 4
.el .IP "\f(CW$r\fR\->is_error" 4
.IX Item "$r->is_error"
.PD
These methods indicate if the response was informational, successful, a
redirection, or an error.  See HTTP::Status for the meaning of these.
.ie n .IP "$r\->error_as_HTML" 4
.el .IP "\f(CW$r\fR\->error_as_HTML" 4
.IX Item "$r->error_as_HTML"
Returns a string containing a complete \s-1HTML\s0 document indicating what
error occurred.  This method should only be called when \f(CW$r\fR\->is_error
is \s-1TRUE.\s0
.ie n .IP "$r\->redirects" 4
.el .IP "\f(CW$r\fR\->redirects" 4
.IX Item "$r->redirects"
Returns the list of redirect responses that lead up to this response
by following the \f(CW$r\fR\->previous chain.  The list order is oldest first.
.Sp
In scalar context return the number of redirect responses leading up
to this one.
.ie n .IP "$r\->current_age" 4
.el .IP "\f(CW$r\fR\->current_age" 4
.IX Item "$r->current_age"
Calculates the \*(L"current age\*(R" of the response as specified by \s-1RFC 2616\s0
section 13.2.3.  The age of a response is the time since it was sent
by the origin server.  The returned value is a number representing the
age in seconds.
.ie n .IP "$r\->freshness_lifetime( %opt )" 4
.el .IP "\f(CW$r\fR\->freshness_lifetime( \f(CW%opt\fR )" 4
.IX Item "$r->freshness_lifetime( %opt )"
Calculates the \*(L"freshness lifetime\*(R" of the response as specified by
\&\s-1RFC 2616\s0 section 13.2.4.  The \*(L"freshness lifetime\*(R" is the length of
time between the generation of a response and its expiration time.
The returned value is the number of seconds until expiry.
.Sp
If the response does not contain an \*(L"Expires\*(R" or a \*(L"Cache-Control\*(R"
header, then this function will apply some simple heuristic based on
the \*(L"Last-Modified\*(R" header to determine a suitable lifetime.  The
following options might be passed to control the heuristics:
.RS 4
.ie n .IP "heuristic_expiry => $bool" 4
.el .IP "heuristic_expiry => \f(CW$bool\fR" 4
.IX Item "heuristic_expiry => $bool"
If passed as a \s-1FALSE\s0 value, don't apply heuristics and just return
\&\f(CW\*(C`undef\*(C'\fR when \*(L"Expires\*(R" or \*(L"Cache-Control\*(R" is lacking.
.ie n .IP "h_lastmod_fraction => $num" 4
.el .IP "h_lastmod_fraction => \f(CW$num\fR" 4
.IX Item "h_lastmod_fraction => $num"
This number represent the fraction of the difference since the
\&\*(L"Last-Modified\*(R" timestamp to make the expiry time.  The default is
\&\f(CW0.10\fR, the suggested typical setting of 10% in \s-1RFC 2616.\s0
.ie n .IP "h_min => $sec" 4
.el .IP "h_min => \f(CW$sec\fR" 4
.IX Item "h_min => $sec"
This is the lower limit of the heuristic expiry age to use.  The
default is \f(CW60\fR (1 minute).
.ie n .IP "h_max => $sec" 4
.el .IP "h_max => \f(CW$sec\fR" 4
.IX Item "h_max => $sec"
This is the upper limit of the heuristic expiry age to use.  The
default is \f(CW86400\fR (24 hours).
.ie n .IP "h_default => $sec" 4
.el .IP "h_default => \f(CW$sec\fR" 4
.IX Item "h_default => $sec"
This is the expiry age to use when nothing else applies.  The default
is \f(CW3600\fR (1 hour) or \*(L"h_min\*(R" if greater.
.RE
.RS 4
.RE
.ie n .IP "$r\->is_fresh( %opt )" 4
.el .IP "\f(CW$r\fR\->is_fresh( \f(CW%opt\fR )" 4
.IX Item "$r->is_fresh( %opt )"
Returns \s-1TRUE\s0 if the response is fresh, based on the values of
\&\fIfreshness_lifetime()\fR and \fIcurrent_age()\fR.  If the response is no longer
fresh, then it has to be re-fetched or re-validated by the origin
server.
.Sp
Options might be passed to control expiry heuristics, see the
description of \fIfreshness_lifetime()\fR.
.ie n .IP "$r\->fresh_until( %opt )" 4
.el .IP "\f(CW$r\fR\->fresh_until( \f(CW%opt\fR )" 4
.IX Item "$r->fresh_until( %opt )"
Returns the time (seconds since epoch) when this entity is no longer fresh.
.Sp
Options might be passed to control expiry heuristics, see the
description of \fIfreshness_lifetime()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTTP::Headers, HTTP::Message, HTTP::Status, HTTP::Request
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2004 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Response5.16.3pm                       0100644 0001750 0001750 00000041062 12566241314 024274  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Response 3"
.TH HTTP::Response 3 "2012-09-30" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Response \- HTTP style response message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Response objects are returned by the \fIrequest()\fR method of the \f(CW\*(C`LWP::UserAgent\*(C'\fR:
.PP
.Vb 8
\&    # ...
\&    $response = $ua\->request($request)
\&    if ($response\->is_success) {
\&        print $response\->decoded_content;
\&    }
\&    else {
\&        print STDERR $response\->status_line, "\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`HTTP::Response\*(C'\fR class encapsulates \s-1HTTP\s0 style responses.  A
response consists of a response line, some headers, and a content
body. Note that the \s-1LWP\s0 library uses \s-1HTTP\s0 style responses even for
non-HTTP protocol schemes.  Instances of this class are usually
created and returned by the \fIrequest()\fR method of an \f(CW\*(C`LWP::UserAgent\*(C'\fR
object.
.PP
\&\f(CW\*(C`HTTP::Response\*(C'\fR is a subclass of \f(CW\*(C`HTTP::Message\*(C'\fR and therefore
inherits its methods.  The following additional methods are available:
.ie n .IP "$r = HTTP::Response\->new( $code )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->new( \f(CW$code\fR )" 4
.IX Item "$r = HTTP::Response->new( $code )"
.PD 0
.ie n .IP "$r = HTTP::Response\->new( $code, $msg )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->new( \f(CW$code\fR, \f(CW$msg\fR )" 4
.IX Item "$r = HTTP::Response->new( $code, $msg )"
.ie n .IP "$r = HTTP::Response\->new( $code, $msg, $header )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->new( \f(CW$code\fR, \f(CW$msg\fR, \f(CW$header\fR )" 4
.IX Item "$r = HTTP::Response->new( $code, $msg, $header )"
.ie n .IP "$r = HTTP::Response\->new( $code, $msg, $header, $content )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->new( \f(CW$code\fR, \f(CW$msg\fR, \f(CW$header\fR, \f(CW$content\fR )" 4
.IX Item "$r = HTTP::Response->new( $code, $msg, $header, $content )"
.PD
Constructs a new \f(CW\*(C`HTTP::Response\*(C'\fR object describing a response with
response code \f(CW$code\fR and optional message \f(CW$msg\fR.  The optional \f(CW$header\fR
argument should be a reference to an \f(CW\*(C`HTTP::Headers\*(C'\fR object or a
plain array reference of key/value pairs.  The optional \f(CW$content\fR
argument should be a string of bytes.  The meanings of these arguments are
described below.
.ie n .IP "$r = HTTP::Response\->parse( $str )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->parse( \f(CW$str\fR )" 4
.IX Item "$r = HTTP::Response->parse( $str )"
This constructs a new response object by parsing the given string.
.ie n .IP "$r\->code" 4
.el .IP "\f(CW$r\fR\->code" 4
.IX Item "$r->code"
.PD 0
.ie n .IP "$r\->code( $code )" 4
.el .IP "\f(CW$r\fR\->code( \f(CW$code\fR )" 4
.IX Item "$r->code( $code )"
.PD
This is used to get/set the code attribute.  The code is a 3 digit
number that encode the overall outcome of an \s-1HTTP\s0 response.  The
\&\f(CW\*(C`HTTP::Status\*(C'\fR module provide constants that provide mnemonic names
for the code attribute.
.ie n .IP "$r\->message" 4
.el .IP "\f(CW$r\fR\->message" 4
.IX Item "$r->message"
.PD 0
.ie n .IP "$r\->message( $message )" 4
.el .IP "\f(CW$r\fR\->message( \f(CW$message\fR )" 4
.IX Item "$r->message( $message )"
.PD
This is used to get/set the message attribute.  The message is a short
human readable single line string that explains the response code.
.ie n .IP "$r\->header( $field )" 4
.el .IP "\f(CW$r\fR\->header( \f(CW$field\fR )" 4
.IX Item "$r->header( $field )"
.PD 0
.ie n .IP "$r\->header( $field => $value )" 4
.el .IP "\f(CW$r\fR\->header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$r->header( $field => $value )"
.PD
This is used to get/set header values and it is inherited from
\&\f(CW\*(C`HTTP::Headers\*(C'\fR via \f(CW\*(C`HTTP::Message\*(C'\fR.  See HTTP::Headers for
details and other similar methods that can be used to access the
headers.
.ie n .IP "$r\->content" 4
.el .IP "\f(CW$r\fR\->content" 4
.IX Item "$r->content"
.PD 0
.ie n .IP "$r\->content( $bytes )" 4
.el .IP "\f(CW$r\fR\->content( \f(CW$bytes\fR )" 4
.IX Item "$r->content( $bytes )"
.PD
This is used to get/set the raw content and it is inherited from the
\&\f(CW\*(C`HTTP::Message\*(C'\fR base class.  See HTTP::Message for details and
other methods that can be used to access the content.
.ie n .IP "$r\->decoded_content( %options )" 4
.el .IP "\f(CW$r\fR\->decoded_content( \f(CW%options\fR )" 4
.IX Item "$r->decoded_content( %options )"
This will return the content after any \f(CW\*(C`Content\-Encoding\*(C'\fR and
charsets have been decoded.  See HTTP::Message for details.
.ie n .IP "$r\->request" 4
.el .IP "\f(CW$r\fR\->request" 4
.IX Item "$r->request"
.PD 0
.ie n .IP "$r\->request( $request )" 4
.el .IP "\f(CW$r\fR\->request( \f(CW$request\fR )" 4
.IX Item "$r->request( $request )"
.PD
This is used to get/set the request attribute.  The request attribute
is a reference to the the request that caused this response.  It does
not have to be the same request passed to the \f(CW$ua\fR\->\fIrequest()\fR method,
because there might have been redirects and authorization retries in
between.
.ie n .IP "$r\->previous" 4
.el .IP "\f(CW$r\fR\->previous" 4
.IX Item "$r->previous"
.PD 0
.ie n .IP "$r\->previous( $response )" 4
.el .IP "\f(CW$r\fR\->previous( \f(CW$response\fR )" 4
.IX Item "$r->previous( $response )"
.PD
This is used to get/set the previous attribute.  The previous
attribute is used to link together chains of responses.  You get
chains of responses if the first response is redirect or unauthorized.
The value is \f(CW\*(C`undef\*(C'\fR if this is the first response in a chain.
.Sp
Note that the method \f(CW$r\fR\->redirects is provided as a more convenient
way to access the response chain.
.ie n .IP "$r\->status_line" 4
.el .IP "\f(CW$r\fR\->status_line" 4
.IX Item "$r->status_line"
Returns the string \*(L"<code> <message>\*(R".  If the message attribute
is not set then the official name of <code> (see HTTP::Status)
is substituted.
.ie n .IP "$r\->base" 4
.el .IP "\f(CW$r\fR\->base" 4
.IX Item "$r->base"
Returns the base \s-1URI\s0 for this response.  The return value will be a
reference to a \s-1URI\s0 object.
.Sp
The base \s-1URI\s0 is obtained from one the following sources (in priority
order):
.RS 4
.IP "1." 4
Embedded in the document content, for instance <\s-1BASE\s0 HREF=\*(L"...\*(R">
in \s-1HTML\s0 documents.
.IP "2." 4
A \*(L"Content-Base:\*(R" or a \*(L"Content-Location:\*(R" header in the response.
.Sp
For backwards compatibility with older \s-1HTTP\s0 implementations we will
also look for the \*(L"Base:\*(R" header.
.IP "3." 4
The \s-1URI\s0 used to request this response. This might not be the original
\&\s-1URI\s0 that was passed to \f(CW$ua\fR\->\fIrequest()\fR method, because we might have
received some redirect responses first.
.RE
.RS 4
.Sp
If none of these sources provide an absolute \s-1URI\s0, undef is returned.
.Sp
When the \s-1LWP\s0 protocol modules produce the HTTP::Response object, then
any base \s-1URI\s0 embedded in the document (step 1) will already have
initialized the \*(L"Content-Base:\*(R" header. This means that this method
only performs the last 2 steps (the content is not always available
either).
.RE
.ie n .IP "$r\->filename" 4
.el .IP "\f(CW$r\fR\->filename" 4
.IX Item "$r->filename"
Returns a filename for this response.  Note that doing sanity checks
on the returned filename (eg. removing characters that cannot be used
on the target filesystem where the filename would be used, and
laundering it for security purposes) are the caller's responsibility;
the only related thing done by this method is that it makes a simple
attempt to return a plain filename with no preceding path segments.
.Sp
The filename is obtained from one the following sources (in priority
order):
.RS 4
.IP "1." 4
A \*(L"Content-Disposition:\*(R" header in the response.  Proper decoding of
\&\s-1RFC\s0 2047 encoded filenames requires the \f(CW\*(C`MIME::QuotedPrint\*(C'\fR (for \*(L"Q\*(R"
encoding), \f(CW\*(C`MIME::Base64\*(C'\fR (for \*(L"B\*(R" encoding), and \f(CW\*(C`Encode\*(C'\fR modules.
.IP "2." 4
A \*(L"Content-Location:\*(R" header in the response.
.IP "3." 4
The \s-1URI\s0 used to request this response. This might not be the original
\&\s-1URI\s0 that was passed to \f(CW$ua\fR\->\fIrequest()\fR method, because we might have
received some redirect responses first.
.RE
.RS 4
.Sp
If a filename cannot be derived from any of these sources, undef is
returned.
.RE
.ie n .IP "$r\->as_string" 4
.el .IP "\f(CW$r\fR\->as_string" 4
.IX Item "$r->as_string"
.PD 0
.ie n .IP "$r\->as_string( $eol )" 4
.el .IP "\f(CW$r\fR\->as_string( \f(CW$eol\fR )" 4
.IX Item "$r->as_string( $eol )"
.PD
Returns a textual representation of the response.
.ie n .IP "$r\->is_info" 4
.el .IP "\f(CW$r\fR\->is_info" 4
.IX Item "$r->is_info"
.PD 0
.ie n .IP "$r\->is_success" 4
.el .IP "\f(CW$r\fR\->is_success" 4
.IX Item "$r->is_success"
.ie n .IP "$r\->is_redirect" 4
.el .IP "\f(CW$r\fR\->is_redirect" 4
.IX Item "$r->is_redirect"
.ie n .IP "$r\->is_error" 4
.el .IP "\f(CW$r\fR\->is_error" 4
.IX Item "$r->is_error"
.PD
These methods indicate if the response was informational, successful, a
redirection, or an error.  See HTTP::Status for the meaning of these.
.ie n .IP "$r\->error_as_HTML" 4
.el .IP "\f(CW$r\fR\->error_as_HTML" 4
.IX Item "$r->error_as_HTML"
Returns a string containing a complete \s-1HTML\s0 document indicating what
error occurred.  This method should only be called when \f(CW$r\fR\->is_error
is \s-1TRUE\s0.
.ie n .IP "$r\->redirects" 4
.el .IP "\f(CW$r\fR\->redirects" 4
.IX Item "$r->redirects"
Returns the list of redirect responses that lead up to this response
by following the \f(CW$r\fR\->previous chain.  The list order is oldest first.
.Sp
In scalar context return the number of redirect responses leading up
to this one.
.ie n .IP "$r\->current_age" 4
.el .IP "\f(CW$r\fR\->current_age" 4
.IX Item "$r->current_age"
Calculates the \*(L"current age\*(R" of the response as specified by \s-1RFC\s0 2616
section 13.2.3.  The age of a response is the time since it was sent
by the origin server.  The returned value is a number representing the
age in seconds.
.ie n .IP "$r\->freshness_lifetime( %opt )" 4
.el .IP "\f(CW$r\fR\->freshness_lifetime( \f(CW%opt\fR )" 4
.IX Item "$r->freshness_lifetime( %opt )"
Calculates the \*(L"freshness lifetime\*(R" of the response as specified by
\&\s-1RFC\s0 2616 section 13.2.4.  The \*(L"freshness lifetime\*(R" is the length of
time between the generation of a response and its expiration time.
The returned value is the number of seconds until expiry.
.Sp
If the response does not contain an \*(L"Expires\*(R" or a \*(L"Cache-Control\*(R"
header, then this function will apply some simple heuristic based on
the \*(L"Last-Modified\*(R" header to determine a suitable lifetime.  The
following options might be passed to control the heuristics:
.RS 4
.ie n .IP "heuristic_expiry => $bool" 4
.el .IP "heuristic_expiry => \f(CW$bool\fR" 4
.IX Item "heuristic_expiry => $bool"
If passed as a \s-1FALSE\s0 value, don't apply heuristics and just return
\&\f(CW\*(C`undef\*(C'\fR when \*(L"Expires\*(R" or \*(L"Cache-Control\*(R" is lacking.
.ie n .IP "h_lastmod_fraction => $num" 4
.el .IP "h_lastmod_fraction => \f(CW$num\fR" 4
.IX Item "h_lastmod_fraction => $num"
This number represent the fraction of the difference since the
\&\*(L"Last-Modified\*(R" timestamp to make the expiry time.  The default is
\&\f(CW0.10\fR, the suggested typical setting of 10% in \s-1RFC\s0 2616.
.ie n .IP "h_min => $sec" 4
.el .IP "h_min => \f(CW$sec\fR" 4
.IX Item "h_min => $sec"
This is the lower limit of the heuristic expiry age to use.  The
default is \f(CW60\fR (1 minute).
.ie n .IP "h_max => $sec" 4
.el .IP "h_max => \f(CW$sec\fR" 4
.IX Item "h_max => $sec"
This is the upper limit of the heuristic expiry age to use.  The
default is \f(CW86400\fR (24 hours).
.ie n .IP "h_default => $sec" 4
.el .IP "h_default => \f(CW$sec\fR" 4
.IX Item "h_default => $sec"
This is the expiry age to use when nothing else applies.  The default
is \f(CW3600\fR (1 hour) or \*(L"h_min\*(R" if greater.
.RE
.RS 4
.RE
.ie n .IP "$r\->is_fresh( %opt )" 4
.el .IP "\f(CW$r\fR\->is_fresh( \f(CW%opt\fR )" 4
.IX Item "$r->is_fresh( %opt )"
Returns \s-1TRUE\s0 if the response is fresh, based on the values of
\&\fIfreshness_lifetime()\fR and \fIcurrent_age()\fR.  If the response is no longer
fresh, then it has to be re-fetched or re-validated by the origin
server.
.Sp
Options might be passed to control expiry heuristics, see the
description of \fIfreshness_lifetime()\fR.
.ie n .IP "$r\->fresh_until( %opt )" 4
.el .IP "\f(CW$r\fR\->fresh_until( \f(CW%opt\fR )" 4
.IX Item "$r->fresh_until( %opt )"
Returns the time (seconds since epoch) when this entity is no longer fresh.
.Sp
Options might be passed to control expiry heuristics, see the
description of \fIfreshness_lifetime()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTTP::Headers, HTTP::Message, HTTP::Status, HTTP::Request
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2004 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Response5.18.3pm                       0100644 0001750 0001750 00000041403 12566241314 024275  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Response 3"
.TH HTTP::Response 3 "2012-09-30" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Response \- HTTP style response message
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Response objects are returned by the \fIrequest()\fR method of the \f(CW\*(C`LWP::UserAgent\*(C'\fR:
.PP
.Vb 8
\&    # ...
\&    $response = $ua\->request($request)
\&    if ($response\->is_success) {
\&        print $response\->decoded_content;
\&    }
\&    else {
\&        print STDERR $response\->status_line, "\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`HTTP::Response\*(C'\fR class encapsulates \s-1HTTP\s0 style responses.  A
response consists of a response line, some headers, and a content
body. Note that the \s-1LWP\s0 library uses \s-1HTTP\s0 style responses even for
non-HTTP protocol schemes.  Instances of this class are usually
created and returned by the \fIrequest()\fR method of an \f(CW\*(C`LWP::UserAgent\*(C'\fR
object.
.PP
\&\f(CW\*(C`HTTP::Response\*(C'\fR is a subclass of \f(CW\*(C`HTTP::Message\*(C'\fR and therefore
inherits its methods.  The following additional methods are available:
.ie n .IP "$r = HTTP::Response\->new( $code )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->new( \f(CW$code\fR )" 4
.IX Item "$r = HTTP::Response->new( $code )"
.PD 0
.ie n .IP "$r = HTTP::Response\->new( $code, $msg )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->new( \f(CW$code\fR, \f(CW$msg\fR )" 4
.IX Item "$r = HTTP::Response->new( $code, $msg )"
.ie n .IP "$r = HTTP::Response\->new( $code, $msg, $header )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->new( \f(CW$code\fR, \f(CW$msg\fR, \f(CW$header\fR )" 4
.IX Item "$r = HTTP::Response->new( $code, $msg, $header )"
.ie n .IP "$r = HTTP::Response\->new( $code, $msg, $header, $content )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->new( \f(CW$code\fR, \f(CW$msg\fR, \f(CW$header\fR, \f(CW$content\fR )" 4
.IX Item "$r = HTTP::Response->new( $code, $msg, $header, $content )"
.PD
Constructs a new \f(CW\*(C`HTTP::Response\*(C'\fR object describing a response with
response code \f(CW$code\fR and optional message \f(CW$msg\fR.  The optional \f(CW$header\fR
argument should be a reference to an \f(CW\*(C`HTTP::Headers\*(C'\fR object or a
plain array reference of key/value pairs.  The optional \f(CW$content\fR
argument should be a string of bytes.  The meanings of these arguments are
described below.
.ie n .IP "$r = HTTP::Response\->parse( $str )" 4
.el .IP "\f(CW$r\fR = HTTP::Response\->parse( \f(CW$str\fR )" 4
.IX Item "$r = HTTP::Response->parse( $str )"
This constructs a new response object by parsing the given string.
.ie n .IP "$r\->code" 4
.el .IP "\f(CW$r\fR\->code" 4
.IX Item "$r->code"
.PD 0
.ie n .IP "$r\->code( $code )" 4
.el .IP "\f(CW$r\fR\->code( \f(CW$code\fR )" 4
.IX Item "$r->code( $code )"
.PD
This is used to get/set the code attribute.  The code is a 3 digit
number that encode the overall outcome of an \s-1HTTP\s0 response.  The
\&\f(CW\*(C`HTTP::Status\*(C'\fR module provide constants that provide mnemonic names
for the code attribute.
.ie n .IP "$r\->message" 4
.el .IP "\f(CW$r\fR\->message" 4
.IX Item "$r->message"
.PD 0
.ie n .IP "$r\->message( $message )" 4
.el .IP "\f(CW$r\fR\->message( \f(CW$message\fR )" 4
.IX Item "$r->message( $message )"
.PD
This is used to get/set the message attribute.  The message is a short
human readable single line string that explains the response code.
.ie n .IP "$r\->header( $field )" 4
.el .IP "\f(CW$r\fR\->header( \f(CW$field\fR )" 4
.IX Item "$r->header( $field )"
.PD 0
.ie n .IP "$r\->header( $field => $value )" 4
.el .IP "\f(CW$r\fR\->header( \f(CW$field\fR => \f(CW$value\fR )" 4
.IX Item "$r->header( $field => $value )"
.PD
This is used to get/set header values and it is inherited from
\&\f(CW\*(C`HTTP::Headers\*(C'\fR via \f(CW\*(C`HTTP::Message\*(C'\fR.  See HTTP::Headers for
details and other similar methods that can be used to access the
headers.
.ie n .IP "$r\->content" 4
.el .IP "\f(CW$r\fR\->content" 4
.IX Item "$r->content"
.PD 0
.ie n .IP "$r\->content( $bytes )" 4
.el .IP "\f(CW$r\fR\->content( \f(CW$bytes\fR )" 4
.IX Item "$r->content( $bytes )"
.PD
This is used to get/set the raw content and it is inherited from the
\&\f(CW\*(C`HTTP::Message\*(C'\fR base class.  See HTTP::Message for details and
other methods that can be used to access the content.
.ie n .IP "$r\->decoded_content( %options )" 4
.el .IP "\f(CW$r\fR\->decoded_content( \f(CW%options\fR )" 4
.IX Item "$r->decoded_content( %options )"
This will return the content after any \f(CW\*(C`Content\-Encoding\*(C'\fR and
charsets have been decoded.  See HTTP::Message for details.
.ie n .IP "$r\->request" 4
.el .IP "\f(CW$r\fR\->request" 4
.IX Item "$r->request"
.PD 0
.ie n .IP "$r\->request( $request )" 4
.el .IP "\f(CW$r\fR\->request( \f(CW$request\fR )" 4
.IX Item "$r->request( $request )"
.PD
This is used to get/set the request attribute.  The request attribute
is a reference to the the request that caused this response.  It does
not have to be the same request passed to the \f(CW$ua\fR\->\fIrequest()\fR method,
because there might have been redirects and authorization retries in
between.
.ie n .IP "$r\->previous" 4
.el .IP "\f(CW$r\fR\->previous" 4
.IX Item "$r->previous"
.PD 0
.ie n .IP "$r\->previous( $response )" 4
.el .IP "\f(CW$r\fR\->previous( \f(CW$response\fR )" 4
.IX Item "$r->previous( $response )"
.PD
This is used to get/set the previous attribute.  The previous
attribute is used to link together chains of responses.  You get
chains of responses if the first response is redirect or unauthorized.
The value is \f(CW\*(C`undef\*(C'\fR if this is the first response in a chain.
.Sp
Note that the method \f(CW$r\fR\->redirects is provided as a more convenient
way to access the response chain.
.ie n .IP "$r\->status_line" 4
.el .IP "\f(CW$r\fR\->status_line" 4
.IX Item "$r->status_line"
Returns the string \*(L"<code> <message>\*(R".  If the message attribute
is not set then the official name of <code> (see HTTP::Status)
is substituted.
.ie n .IP "$r\->base" 4
.el .IP "\f(CW$r\fR\->base" 4
.IX Item "$r->base"
Returns the base \s-1URI\s0 for this response.  The return value will be a
reference to a \s-1URI\s0 object.
.Sp
The base \s-1URI\s0 is obtained from one the following sources (in priority
order):
.RS 4
.IP "1." 4
Embedded in the document content, for instance <\s-1BASE\s0 HREF=\*(L"...\*(R">
in \s-1HTML\s0 documents.
.IP "2." 4
A \*(L"Content-Base:\*(R" or a \*(L"Content-Location:\*(R" header in the response.
.Sp
For backwards compatibility with older \s-1HTTP\s0 implementations we will
also look for the \*(L"Base:\*(R" header.
.IP "3." 4
The \s-1URI\s0 used to request this response. This might not be the original
\&\s-1URI\s0 that was passed to \f(CW$ua\fR\->\fIrequest()\fR method, because we might have
received some redirect responses first.
.RE
.RS 4
.Sp
If none of these sources provide an absolute \s-1URI,\s0 undef is returned.
.Sp
When the \s-1LWP\s0 protocol modules produce the HTTP::Response object, then
any base \s-1URI\s0 embedded in the document (step 1) will already have
initialized the \*(L"Content-Base:\*(R" header. This means that this method
only performs the last 2 steps (the content is not always available
either).
.RE
.ie n .IP "$r\->filename" 4
.el .IP "\f(CW$r\fR\->filename" 4
.IX Item "$r->filename"
Returns a filename for this response.  Note that doing sanity checks
on the returned filename (eg. removing characters that cannot be used
on the target filesystem where the filename would be used, and
laundering it for security purposes) are the caller's responsibility;
the only related thing done by this method is that it makes a simple
attempt to return a plain filename with no preceding path segments.
.Sp
The filename is obtained from one the following sources (in priority
order):
.RS 4
.IP "1." 4
A \*(L"Content-Disposition:\*(R" header in the response.  Proper decoding of
\&\s-1RFC 2047\s0 encoded filenames requires the \f(CW\*(C`MIME::QuotedPrint\*(C'\fR (for \*(L"Q\*(R"
encoding), \f(CW\*(C`MIME::Base64\*(C'\fR (for \*(L"B\*(R" encoding), and \f(CW\*(C`Encode\*(C'\fR modules.
.IP "2." 4
A \*(L"Content-Location:\*(R" header in the response.
.IP "3." 4
The \s-1URI\s0 used to request this response. This might not be the original
\&\s-1URI\s0 that was passed to \f(CW$ua\fR\->\fIrequest()\fR method, because we might have
received some redirect responses first.
.RE
.RS 4
.Sp
If a filename cannot be derived from any of these sources, undef is
returned.
.RE
.ie n .IP "$r\->as_string" 4
.el .IP "\f(CW$r\fR\->as_string" 4
.IX Item "$r->as_string"
.PD 0
.ie n .IP "$r\->as_string( $eol )" 4
.el .IP "\f(CW$r\fR\->as_string( \f(CW$eol\fR )" 4
.IX Item "$r->as_string( $eol )"
.PD
Returns a textual representation of the response.
.ie n .IP "$r\->is_info" 4
.el .IP "\f(CW$r\fR\->is_info" 4
.IX Item "$r->is_info"
.PD 0
.ie n .IP "$r\->is_success" 4
.el .IP "\f(CW$r\fR\->is_success" 4
.IX Item "$r->is_success"
.ie n .IP "$r\->is_redirect" 4
.el .IP "\f(CW$r\fR\->is_redirect" 4
.IX Item "$r->is_redirect"
.ie n .IP "$r\->is_error" 4
.el .IP "\f(CW$r\fR\->is_error" 4
.IX Item "$r->is_error"
.PD
These methods indicate if the response was informational, successful, a
redirection, or an error.  See HTTP::Status for the meaning of these.
.ie n .IP "$r\->error_as_HTML" 4
.el .IP "\f(CW$r\fR\->error_as_HTML" 4
.IX Item "$r->error_as_HTML"
Returns a string containing a complete \s-1HTML\s0 document indicating what
error occurred.  This method should only be called when \f(CW$r\fR\->is_error
is \s-1TRUE.\s0
.ie n .IP "$r\->redirects" 4
.el .IP "\f(CW$r\fR\->redirects" 4
.IX Item "$r->redirects"
Returns the list of redirect responses that lead up to this response
by following the \f(CW$r\fR\->previous chain.  The list order is oldest first.
.Sp
In scalar context return the number of redirect responses leading up
to this one.
.ie n .IP "$r\->current_age" 4
.el .IP "\f(CW$r\fR\->current_age" 4
.IX Item "$r->current_age"
Calculates the \*(L"current age\*(R" of the response as specified by \s-1RFC 2616\s0
section 13.2.3.  The age of a response is the time since it was sent
by the origin server.  The returned value is a number representing the
age in seconds.
.ie n .IP "$r\->freshness_lifetime( %opt )" 4
.el .IP "\f(CW$r\fR\->freshness_lifetime( \f(CW%opt\fR )" 4
.IX Item "$r->freshness_lifetime( %opt )"
Calculates the \*(L"freshness lifetime\*(R" of the response as specified by
\&\s-1RFC 2616\s0 section 13.2.4.  The \*(L"freshness lifetime\*(R" is the length of
time between the generation of a response and its expiration time.
The returned value is the number of seconds until expiry.
.Sp
If the response does not contain an \*(L"Expires\*(R" or a \*(L"Cache-Control\*(R"
header, then this function will apply some simple heuristic based on
the \*(L"Last-Modified\*(R" header to determine a suitable lifetime.  The
following options might be passed to control the heuristics:
.RS 4
.ie n .IP "heuristic_expiry => $bool" 4
.el .IP "heuristic_expiry => \f(CW$bool\fR" 4
.IX Item "heuristic_expiry => $bool"
If passed as a \s-1FALSE\s0 value, don't apply heuristics and just return
\&\f(CW\*(C`undef\*(C'\fR when \*(L"Expires\*(R" or \*(L"Cache-Control\*(R" is lacking.
.ie n .IP "h_lastmod_fraction => $num" 4
.el .IP "h_lastmod_fraction => \f(CW$num\fR" 4
.IX Item "h_lastmod_fraction => $num"
This number represent the fraction of the difference since the
\&\*(L"Last-Modified\*(R" timestamp to make the expiry time.  The default is
\&\f(CW0.10\fR, the suggested typical setting of 10% in \s-1RFC 2616.\s0
.ie n .IP "h_min => $sec" 4
.el .IP "h_min => \f(CW$sec\fR" 4
.IX Item "h_min => $sec"
This is the lower limit of the heuristic expiry age to use.  The
default is \f(CW60\fR (1 minute).
.ie n .IP "h_max => $sec" 4
.el .IP "h_max => \f(CW$sec\fR" 4
.IX Item "h_max => $sec"
This is the upper limit of the heuristic expiry age to use.  The
default is \f(CW86400\fR (24 hours).
.ie n .IP "h_default => $sec" 4
.el .IP "h_default => \f(CW$sec\fR" 4
.IX Item "h_default => $sec"
This is the expiry age to use when nothing else applies.  The default
is \f(CW3600\fR (1 hour) or \*(L"h_min\*(R" if greater.
.RE
.RS 4
.RE
.ie n .IP "$r\->is_fresh( %opt )" 4
.el .IP "\f(CW$r\fR\->is_fresh( \f(CW%opt\fR )" 4
.IX Item "$r->is_fresh( %opt )"
Returns \s-1TRUE\s0 if the response is fresh, based on the values of
\&\fIfreshness_lifetime()\fR and \fIcurrent_age()\fR.  If the response is no longer
fresh, then it has to be re-fetched or re-validated by the origin
server.
.Sp
Options might be passed to control expiry heuristics, see the
description of \fIfreshness_lifetime()\fR.
.ie n .IP "$r\->fresh_until( %opt )" 4
.el .IP "\f(CW$r\fR\->fresh_until( \f(CW%opt\fR )" 4
.IX Item "$r->fresh_until( %opt )"
Returns the time (seconds since epoch) when this entity is no longer fresh.
.Sp
Options might be passed to control expiry heuristics, see the
description of \fIfreshness_lifetime()\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTTP::Headers, HTTP::Message, HTTP::Status, HTTP::Request
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 1995\-2004 Gisle Aas.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Status.3pm                             0100644 0001750 0001750 00000024037 12566241314 023452  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Status 3"
.TH HTTP::Status 3 "2012-02-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Status \- HTTP Status code processing
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use HTTP::Status qw(:constants :is status_message);
\&
\& if ($rc != HTTP_OK) {
\&     print status_message($rc), "\en";
\& }
\&
\& if (is_success($rc)) { ... }
\& if (is_error($rc)) { ... }
\& if (is_redirect($rc)) { ... }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIHTTP::Status\fR is a library of routines for defining and
classifying \s-1HTTP\s0 status codes for libwww-perl.  Status codes are
used to encode the overall outcome of an \s-1HTTP\s0 response message.  Codes
correspond to those defined in \s-1RFC 2616\s0 and \s-1RFC 2518.\s0
.SH "CONSTANTS"
.IX Header "CONSTANTS"
The following constant functions can be used as mnemonic status code
names.  None of these are exported by default.  Use the \f(CW\*(C`:constants\*(C'\fR
tag to import them all.
.PP
.Vb 3
\&   HTTP_CONTINUE                        (100)
\&   HTTP_SWITCHING_PROTOCOLS             (101)
\&   HTTP_PROCESSING                      (102)
\&
\&   HTTP_OK                              (200)
\&   HTTP_CREATED                         (201)
\&   HTTP_ACCEPTED                        (202)
\&   HTTP_NON_AUTHORITATIVE_INFORMATION   (203)
\&   HTTP_NO_CONTENT                      (204)
\&   HTTP_RESET_CONTENT                   (205)
\&   HTTP_PARTIAL_CONTENT                 (206)
\&   HTTP_MULTI_STATUS                    (207)
\&   HTTP_ALREADY_REPORTED                (208)
\&
\&   HTTP_MULTIPLE_CHOICES                (300)
\&   HTTP_MOVED_PERMANENTLY               (301)
\&   HTTP_FOUND                           (302)
\&   HTTP_SEE_OTHER                       (303)
\&   HTTP_NOT_MODIFIED                    (304)
\&   HTTP_USE_PROXY                       (305)
\&   HTTP_TEMPORARY_REDIRECT              (307)
\&
\&   HTTP_BAD_REQUEST                     (400)
\&   HTTP_UNAUTHORIZED                    (401)
\&   HTTP_PAYMENT_REQUIRED                (402)
\&   HTTP_FORBIDDEN                       (403)
\&   HTTP_NOT_FOUND                       (404)
\&   HTTP_METHOD_NOT_ALLOWED              (405)
\&   HTTP_NOT_ACCEPTABLE                  (406)
\&   HTTP_PROXY_AUTHENTICATION_REQUIRED   (407)
\&   HTTP_REQUEST_TIMEOUT                 (408)
\&   HTTP_CONFLICT                        (409)
\&   HTTP_GONE                            (410)
\&   HTTP_LENGTH_REQUIRED                 (411)
\&   HTTP_PRECONDITION_FAILED             (412)
\&   HTTP_REQUEST_ENTITY_TOO_LARGE        (413)
\&   HTTP_REQUEST_URI_TOO_LARGE           (414)
\&   HTTP_UNSUPPORTED_MEDIA_TYPE          (415)
\&   HTTP_REQUEST_RANGE_NOT_SATISFIABLE   (416)
\&   HTTP_EXPECTATION_FAILED              (417)
\&   HTTP_I_AM_A_TEAPOT                   (418)
\&   HTTP_UNPROCESSABLE_ENTITY            (422)
\&   HTTP_LOCKED                          (423)
\&   HTTP_FAILED_DEPENDENCY               (424)
\&   HTTP_NO_CODE                         (425)
\&   HTTP_UPGRADE_REQUIRED                (426)
\&   HTTP_PRECONDITION_REQUIRED           (428)
\&   HTTP_TOO_MANY_REQUESTS               (429)
\&   HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE (431)
\&   HTTP_RETRY_WITH                      (449)
\&
\&   HTTP_INTERNAL_SERVER_ERROR           (500)
\&   HTTP_NOT_IMPLEMENTED                 (501)
\&   HTTP_BAD_GATEWAY                     (502)
\&   HTTP_SERVICE_UNAVAILABLE             (503)
\&   HTTP_GATEWAY_TIMEOUT                 (504)
\&   HTTP_HTTP_VERSION_NOT_SUPPORTED      (505)
\&   HTTP_VARIANT_ALSO_NEGOTIATES         (506)
\&   HTTP_INSUFFICIENT_STORAGE            (507)
\&   HTTP_BANDWIDTH_LIMIT_EXCEEDED        (509)
\&   HTTP_NOT_EXTENDED                    (510)
\&   HTTP_NETWORK_AUTHENTICATION_REQUIRED (511)
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
The following additional functions are provided.  Most of them are
exported by default.  The \f(CW\*(C`:is\*(C'\fR import tag can be used to import all
the classification functions.
.ie n .IP "status_message( $code )" 4
.el .IP "status_message( \f(CW$code\fR )" 4
.IX Item "status_message( $code )"
The \fIstatus_message()\fR function will translate status codes to human
readable strings. The string is the same as found in the constant
names above.  If the \f(CW$code\fR is unknown, then \f(CW\*(C`undef\*(C'\fR is returned.
.ie n .IP "is_info( $code )" 4
.el .IP "is_info( \f(CW$code\fR )" 4
.IX Item "is_info( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR is an \fIInformational\fR status code (1xx).  This
class of status code indicates a provisional response which can't have
any content.
.ie n .IP "is_success( $code )" 4
.el .IP "is_success( \f(CW$code\fR )" 4
.IX Item "is_success( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR is a \fISuccessful\fR status code (2xx).
.ie n .IP "is_redirect( $code )" 4
.el .IP "is_redirect( \f(CW$code\fR )" 4
.IX Item "is_redirect( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR is a \fIRedirection\fR status code (3xx). This class of
status code indicates that further action needs to be taken by the
user agent in order to fulfill the request.
.ie n .IP "is_error( $code )" 4
.el .IP "is_error( \f(CW$code\fR )" 4
.IX Item "is_error( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR is an \fIError\fR status code (4xx or 5xx).  The function
returns \s-1TRUE\s0 for both client and server error status codes.
.ie n .IP "is_client_error( $code )" 4
.el .IP "is_client_error( \f(CW$code\fR )" 4
.IX Item "is_client_error( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR is a \fIClient Error\fR status code (4xx). This class
of status code is intended for cases in which the client seems to have
erred.
.Sp
This function is \fBnot\fR exported by default.
.ie n .IP "is_server_error( $code )" 4
.el .IP "is_server_error( \f(CW$code\fR )" 4
.IX Item "is_server_error( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR is a \fIServer Error\fR status code (5xx). This class
of status codes is intended for cases in which the server is aware
that it has erred or is incapable of performing the request.
.Sp
This function is \fBnot\fR exported by default.
.SH "BUGS"
.IX Header "BUGS"
For legacy reasons all the \f(CW\*(C`HTTP_\*(C'\fR constants are exported by default
with the prefix \f(CW\*(C`RC_\*(C'\fR.  It's recommended to use explicit imports and
the \f(CW\*(C`:constants\*(C'\fR tag instead of relying on this.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Status5.16.3pm                         0100644 0001750 0001750 00000023516 12566241314 023765  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Status 3"
.TH HTTP::Status 3 "2012-02-16" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Status \- HTTP Status code processing
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use HTTP::Status qw(:constants :is status_message);
\&
\& if ($rc != HTTP_OK) {
\&     print status_message($rc), "\en";
\& }
\&
\& if (is_success($rc)) { ... }
\& if (is_error($rc)) { ... }
\& if (is_redirect($rc)) { ... }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIHTTP::Status\fR is a library of routines for defining and
classifying \s-1HTTP\s0 status codes for libwww-perl.  Status codes are
used to encode the overall outcome of an \s-1HTTP\s0 response message.  Codes
correspond to those defined in \s-1RFC\s0 2616 and \s-1RFC\s0 2518.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
The following constant functions can be used as mnemonic status code
names.  None of these are exported by default.  Use the \f(CW\*(C`:constants\*(C'\fR
tag to import them all.
.PP
.Vb 3
\&   HTTP_CONTINUE                        (100)
\&   HTTP_SWITCHING_PROTOCOLS             (101)
\&   HTTP_PROCESSING                      (102)
\&
\&   HTTP_OK                              (200)
\&   HTTP_CREATED                         (201)
\&   HTTP_ACCEPTED                        (202)
\&   HTTP_NON_AUTHORITATIVE_INFORMATION   (203)
\&   HTTP_NO_CONTENT                      (204)
\&   HTTP_RESET_CONTENT                   (205)
\&   HTTP_PARTIAL_CONTENT                 (206)
\&   HTTP_MULTI_STATUS                    (207)
\&   HTTP_ALREADY_REPORTED                (208)
\&
\&   HTTP_MULTIPLE_CHOICES                (300)
\&   HTTP_MOVED_PERMANENTLY               (301)
\&   HTTP_FOUND                           (302)
\&   HTTP_SEE_OTHER                       (303)
\&   HTTP_NOT_MODIFIED                    (304)
\&   HTTP_USE_PROXY                       (305)
\&   HTTP_TEMPORARY_REDIRECT              (307)
\&
\&   HTTP_BAD_REQUEST                     (400)
\&   HTTP_UNAUTHORIZED                    (401)
\&   HTTP_PAYMENT_REQUIRED                (402)
\&   HTTP_FORBIDDEN                       (403)
\&   HTTP_NOT_FOUND                       (404)
\&   HTTP_METHOD_NOT_ALLOWED              (405)
\&   HTTP_NOT_ACCEPTABLE                  (406)
\&   HTTP_PROXY_AUTHENTICATION_REQUIRED   (407)
\&   HTTP_REQUEST_TIMEOUT                 (408)
\&   HTTP_CONFLICT                        (409)
\&   HTTP_GONE                            (410)
\&   HTTP_LENGTH_REQUIRED                 (411)
\&   HTTP_PRECONDITION_FAILED             (412)
\&   HTTP_REQUEST_ENTITY_TOO_LARGE        (413)
\&   HTTP_REQUEST_URI_TOO_LARGE           (414)
\&   HTTP_UNSUPPORTED_MEDIA_TYPE          (415)
\&   HTTP_REQUEST_RANGE_NOT_SATISFIABLE   (416)
\&   HTTP_EXPECTATION_FAILED              (417)
\&   HTTP_I_AM_A_TEAPOT                   (418)
\&   HTTP_UNPROCESSABLE_ENTITY            (422)
\&   HTTP_LOCKED                          (423)
\&   HTTP_FAILED_DEPENDENCY               (424)
\&   HTTP_NO_CODE                         (425)
\&   HTTP_UPGRADE_REQUIRED                (426)
\&   HTTP_PRECONDITION_REQUIRED           (428)
\&   HTTP_TOO_MANY_REQUESTS               (429)
\&   HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE (431)
\&   HTTP_RETRY_WITH                      (449)
\&
\&   HTTP_INTERNAL_SERVER_ERROR           (500)
\&   HTTP_NOT_IMPLEMENTED                 (501)
\&   HTTP_BAD_GATEWAY                     (502)
\&   HTTP_SERVICE_UNAVAILABLE             (503)
\&   HTTP_GATEWAY_TIMEOUT                 (504)
\&   HTTP_HTTP_VERSION_NOT_SUPPORTED      (505)
\&   HTTP_VARIANT_ALSO_NEGOTIATES         (506)
\&   HTTP_INSUFFICIENT_STORAGE            (507)
\&   HTTP_BANDWIDTH_LIMIT_EXCEEDED        (509)
\&   HTTP_NOT_EXTENDED                    (510)
\&   HTTP_NETWORK_AUTHENTICATION_REQUIRED (511)
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
The following additional functions are provided.  Most of them are
exported by default.  The \f(CW\*(C`:is\*(C'\fR import tag can be used to import all
the classification functions.
.ie n .IP "status_message( $code )" 4
.el .IP "status_message( \f(CW$code\fR )" 4
.IX Item "status_message( $code )"
The \fIstatus_message()\fR function will translate status codes to human
readable strings. The string is the same as found in the constant
names above.  If the \f(CW$code\fR is unknown, then \f(CW\*(C`undef\*(C'\fR is returned.
.ie n .IP "is_info( $code )" 4
.el .IP "is_info( \f(CW$code\fR )" 4
.IX Item "is_info( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR is an \fIInformational\fR status code (1xx).  This
class of status code indicates a provisional response which can't have
any content.
.ie n .IP "is_success( $code )" 4
.el .IP "is_success( \f(CW$code\fR )" 4
.IX Item "is_success( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR is a \fISuccessful\fR status code (2xx).
.ie n .IP "is_redirect( $code )" 4
.el .IP "is_redirect( \f(CW$code\fR )" 4
.IX Item "is_redirect( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR is a \fIRedirection\fR status code (3xx). This class of
status code indicates that further action needs to be taken by the
user agent in order to fulfill the request.
.ie n .IP "is_error( $code )" 4
.el .IP "is_error( \f(CW$code\fR )" 4
.IX Item "is_error( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR is an \fIError\fR status code (4xx or 5xx).  The function
returns \s-1TRUE\s0 for both client and server error status codes.
.ie n .IP "is_client_error( $code )" 4
.el .IP "is_client_error( \f(CW$code\fR )" 4
.IX Item "is_client_error( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR is a \fIClient Error\fR status code (4xx). This class
of status code is intended for cases in which the client seems to have
erred.
.Sp
This function is \fBnot\fR exported by default.
.ie n .IP "is_server_error( $code )" 4
.el .IP "is_server_error( \f(CW$code\fR )" 4
.IX Item "is_server_error( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR is a \fIServer Error\fR status code (5xx). This class
of status codes is intended for cases in which the server is aware
that it has erred or is incapable of performing the request.
.Sp
This function is \fBnot\fR exported by default.
.SH "BUGS"
.IX Header "BUGS"
For legacy reasons all the \f(CW\*(C`HTTP_\*(C'\fR constants are exported by default
with the prefix \f(CW\*(C`RC_\*(C'\fR.  It's recommended to use explicit imports and
the \f(CW\*(C`:constants\*(C'\fR tag instead of relying on this.
                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Status5.18.3pm                         0100644 0001750 0001750 00000024037 12566241314 023766  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Status 3"
.TH HTTP::Status 3 "2012-02-16" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Status \- HTTP Status code processing
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use HTTP::Status qw(:constants :is status_message);
\&
\& if ($rc != HTTP_OK) {
\&     print status_message($rc), "\en";
\& }
\&
\& if (is_success($rc)) { ... }
\& if (is_error($rc)) { ... }
\& if (is_redirect($rc)) { ... }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIHTTP::Status\fR is a library of routines for defining and
classifying \s-1HTTP\s0 status codes for libwww-perl.  Status codes are
used to encode the overall outcome of an \s-1HTTP\s0 response message.  Codes
correspond to those defined in \s-1RFC 2616\s0 and \s-1RFC 2518.\s0
.SH "CONSTANTS"
.IX Header "CONSTANTS"
The following constant functions can be used as mnemonic status code
names.  None of these are exported by default.  Use the \f(CW\*(C`:constants\*(C'\fR
tag to import them all.
.PP
.Vb 3
\&   HTTP_CONTINUE                        (100)
\&   HTTP_SWITCHING_PROTOCOLS             (101)
\&   HTTP_PROCESSING                      (102)
\&
\&   HTTP_OK                              (200)
\&   HTTP_CREATED                         (201)
\&   HTTP_ACCEPTED                        (202)
\&   HTTP_NON_AUTHORITATIVE_INFORMATION   (203)
\&   HTTP_NO_CONTENT                      (204)
\&   HTTP_RESET_CONTENT                   (205)
\&   HTTP_PARTIAL_CONTENT                 (206)
\&   HTTP_MULTI_STATUS                    (207)
\&   HTTP_ALREADY_REPORTED                (208)
\&
\&   HTTP_MULTIPLE_CHOICES                (300)
\&   HTTP_MOVED_PERMANENTLY               (301)
\&   HTTP_FOUND                           (302)
\&   HTTP_SEE_OTHER                       (303)
\&   HTTP_NOT_MODIFIED                    (304)
\&   HTTP_USE_PROXY                       (305)
\&   HTTP_TEMPORARY_REDIRECT              (307)
\&
\&   HTTP_BAD_REQUEST                     (400)
\&   HTTP_UNAUTHORIZED                    (401)
\&   HTTP_PAYMENT_REQUIRED                (402)
\&   HTTP_FORBIDDEN                       (403)
\&   HTTP_NOT_FOUND                       (404)
\&   HTTP_METHOD_NOT_ALLOWED              (405)
\&   HTTP_NOT_ACCEPTABLE                  (406)
\&   HTTP_PROXY_AUTHENTICATION_REQUIRED   (407)
\&   HTTP_REQUEST_TIMEOUT                 (408)
\&   HTTP_CONFLICT                        (409)
\&   HTTP_GONE                            (410)
\&   HTTP_LENGTH_REQUIRED                 (411)
\&   HTTP_PRECONDITION_FAILED             (412)
\&   HTTP_REQUEST_ENTITY_TOO_LARGE        (413)
\&   HTTP_REQUEST_URI_TOO_LARGE           (414)
\&   HTTP_UNSUPPORTED_MEDIA_TYPE          (415)
\&   HTTP_REQUEST_RANGE_NOT_SATISFIABLE   (416)
\&   HTTP_EXPECTATION_FAILED              (417)
\&   HTTP_I_AM_A_TEAPOT                   (418)
\&   HTTP_UNPROCESSABLE_ENTITY            (422)
\&   HTTP_LOCKED                          (423)
\&   HTTP_FAILED_DEPENDENCY               (424)
\&   HTTP_NO_CODE                         (425)
\&   HTTP_UPGRADE_REQUIRED                (426)
\&   HTTP_PRECONDITION_REQUIRED           (428)
\&   HTTP_TOO_MANY_REQUESTS               (429)
\&   HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE (431)
\&   HTTP_RETRY_WITH                      (449)
\&
\&   HTTP_INTERNAL_SERVER_ERROR           (500)
\&   HTTP_NOT_IMPLEMENTED                 (501)
\&   HTTP_BAD_GATEWAY                     (502)
\&   HTTP_SERVICE_UNAVAILABLE             (503)
\&   HTTP_GATEWAY_TIMEOUT                 (504)
\&   HTTP_HTTP_VERSION_NOT_SUPPORTED      (505)
\&   HTTP_VARIANT_ALSO_NEGOTIATES         (506)
\&   HTTP_INSUFFICIENT_STORAGE            (507)
\&   HTTP_BANDWIDTH_LIMIT_EXCEEDED        (509)
\&   HTTP_NOT_EXTENDED                    (510)
\&   HTTP_NETWORK_AUTHENTICATION_REQUIRED (511)
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
The following additional functions are provided.  Most of them are
exported by default.  The \f(CW\*(C`:is\*(C'\fR import tag can be used to import all
the classification functions.
.ie n .IP "status_message( $code )" 4
.el .IP "status_message( \f(CW$code\fR )" 4
.IX Item "status_message( $code )"
The \fIstatus_message()\fR function will translate status codes to human
readable strings. The string is the same as found in the constant
names above.  If the \f(CW$code\fR is unknown, then \f(CW\*(C`undef\*(C'\fR is returned.
.ie n .IP "is_info( $code )" 4
.el .IP "is_info( \f(CW$code\fR )" 4
.IX Item "is_info( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR is an \fIInformational\fR status code (1xx).  This
class of status code indicates a provisional response which can't have
any content.
.ie n .IP "is_success( $code )" 4
.el .IP "is_success( \f(CW$code\fR )" 4
.IX Item "is_success( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR is a \fISuccessful\fR status code (2xx).
.ie n .IP "is_redirect( $code )" 4
.el .IP "is_redirect( \f(CW$code\fR )" 4
.IX Item "is_redirect( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR is a \fIRedirection\fR status code (3xx). This class of
status code indicates that further action needs to be taken by the
user agent in order to fulfill the request.
.ie n .IP "is_error( $code )" 4
.el .IP "is_error( \f(CW$code\fR )" 4
.IX Item "is_error( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR is an \fIError\fR status code (4xx or 5xx).  The function
returns \s-1TRUE\s0 for both client and server error status codes.
.ie n .IP "is_client_error( $code )" 4
.el .IP "is_client_error( \f(CW$code\fR )" 4
.IX Item "is_client_error( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR is a \fIClient Error\fR status code (4xx). This class
of status code is intended for cases in which the client seems to have
erred.
.Sp
This function is \fBnot\fR exported by default.
.ie n .IP "is_server_error( $code )" 4
.el .IP "is_server_error( \f(CW$code\fR )" 4
.IX Item "is_server_error( $code )"
Return \s-1TRUE\s0 if \f(CW$code\fR is a \fIServer Error\fR status code (5xx). This class
of status codes is intended for cases in which the server is aware
that it has erred or is incapable of performing the request.
.Sp
This function is \fBnot\fR exported by default.
.SH "BUGS"
.IX Header "BUGS"
For legacy reasons all the \f(CW\*(C`HTTP_\*(C'\fR constants are exported by default
with the prefix \f(CW\*(C`RC_\*(C'\fR.  It's recommended to use explicit imports and
the \f(CW\*(C`:constants\*(C'\fR tag instead of relying on this.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Tiny.3pm                               0100644 0001750 0001750 00000046335 12566207455 023127  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Tiny 3pm"
.TH HTTP::Tiny 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Tiny \- A small, simple, correct HTTP/1.1 client
.SH "VERSION"
.IX Header "VERSION"
version 0.025
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use HTTP::Tiny;
\&
\&    my $response = HTTP::Tiny\->new\->get(\*(Aqhttp://example.com/\*(Aq);
\&
\&    die "Failed!\en" unless $response\->{success};
\&
\&    print "$response\->{status} $response\->{reason}\en";
\&
\&    while (my ($k, $v) = each %{$response\->{headers}}) {
\&        for (ref $v eq \*(AqARRAY\*(Aq ? @$v : $v) {
\&            print "$k: $_\en";
\&        }
\&    }
\&
\&    print $response\->{content} if length $response\->{content};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a very simple \s-1HTTP/1.1\s0 client, designed for doing simple \s-1GET\s0
requests without the overhead of a large framework like LWP::UserAgent.
.PP
It is more correct and more complete than HTTP::Lite.  It supports
proxies (currently only non-authenticating ones) and redirection.  It
also correctly resumes after \s-1EINTR.\s0
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&    $http = HTTP::Tiny\->new( %attributes );
.Ve
.PP
This constructor returns a new HTTP::Tiny object.  Valid attributes include:
.IP "\(bu" 4
\&\f(CW\*(C`agent\*(C'\fR
.Sp
A user-agent string (defaults to 'HTTP\-Tiny/$VERSION'). If \f(CW\*(C`agent\*(C'\fR ends in a space character, the default user-agent string is appended.
.IP "\(bu" 4
\&\f(CW\*(C`default_headers\*(C'\fR
.Sp
A hashref of default headers to apply to requests
.IP "\(bu" 4
\&\f(CW\*(C`local_address\*(C'\fR
.Sp
The local \s-1IP\s0 address to bind to
.IP "\(bu" 4
\&\f(CW\*(C`max_redirect\*(C'\fR
.Sp
Maximum number of redirects allowed (defaults to 5)
.IP "\(bu" 4
\&\f(CW\*(C`max_size\*(C'\fR
.Sp
Maximum response size (only when not using a data callback).  If defined,
responses larger than this will return an exception.
.IP "\(bu" 4
\&\f(CW\*(C`proxy\*(C'\fR
.Sp
\&\s-1URL\s0 of a proxy server to use (default is \f(CW$ENV{http_proxy}\fR if set)
.IP "\(bu" 4
\&\f(CW\*(C`timeout\*(C'\fR
.Sp
Request timeout in seconds (default is 60)
.IP "\(bu" 4
\&\f(CW\*(C`verify_SSL\*(C'\fR
.Sp
A boolean that indicates whether to validate the \s-1SSL\s0 certificate of an \f(CW\*(C`https\*(C'\fR
connection (default is false)
.IP "\(bu" 4
\&\f(CW\*(C`SSL_options\*(C'\fR
.Sp
A hashref of \f(CW\*(C`SSL_*\*(C'\fR options to pass through to IO::Socket::SSL
.PP
Exceptions from \f(CW\*(C`max_size\*(C'\fR, \f(CW\*(C`timeout\*(C'\fR or other errors will result in a
pseudo-HTTP status code of 599 and a reason of \*(L"Internal Exception\*(R". The
content field in the response will contain the text of the exception.
.PP
See \*(L"\s-1SSL SUPPORT\*(R"\s0 for more on the \f(CW\*(C`verify_SSL\*(C'\fR and \f(CW\*(C`SSL_options\*(C'\fR attributes.
.SS "get|head|put|post|delete"
.IX Subsection "get|head|put|post|delete"
.Vb 3
\&    $response = $http\->get($url);
\&    $response = $http\->get($url, \e%options);
\&    $response = $http\->head($url);
.Ve
.PP
These methods are shorthand for calling \f(CW\*(C`request()\*(C'\fR for the given method.  The
\&\s-1URL\s0 must have unsafe characters escaped and international domain names encoded.
See \f(CW\*(C`request()\*(C'\fR for valid options and a description of the response.
.PP
The \f(CW\*(C`success\*(C'\fR field of the response will be true if the status code is 2XX.
.SS "post_form"
.IX Subsection "post_form"
.Vb 2
\&    $response = $http\->post_form($url, $form_data);
\&    $response = $http\->post_form($url, $form_data, \e%options);
.Ve
.PP
This method executes a \f(CW\*(C`POST\*(C'\fR request and sends the key/value pairs from a
form data hash or array reference to the given \s-1URL\s0 with a \f(CW\*(C`content\-type\*(C'\fR of
\&\f(CW\*(C`application/x\-www\-form\-urlencoded\*(C'\fR.  See documentation for the
\&\f(CW\*(C`www_form_urlencode\*(C'\fR method for details on the encoding.
.PP
The \s-1URL\s0 must have unsafe characters escaped and international domain names
encoded.  See \f(CW\*(C`request()\*(C'\fR for valid options and a description of the response.
Any \f(CW\*(C`content\-type\*(C'\fR header or content in the options hashref will be ignored.
.PP
The \f(CW\*(C`success\*(C'\fR field of the response will be true if the status code is 2XX.
.SS "mirror"
.IX Subsection "mirror"
.Vb 4
\&    $response = $http\->mirror($url, $file, \e%options)
\&    if ( $response\->{success} ) {
\&        print "$file is up to date\en";
\&    }
.Ve
.PP
Executes a \f(CW\*(C`GET\*(C'\fR request for the \s-1URL\s0 and saves the response body to the file
name provided.  The \s-1URL\s0 must have unsafe characters escaped and international
domain names encoded.  If the file already exists, the request will includes an
\&\f(CW\*(C`If\-Modified\-Since\*(C'\fR header with the modification timestamp of the file.  You
may specify a different \f(CW\*(C`If\-Modified\-Since\*(C'\fR header yourself in the \f(CW\*(C`$options\->{headers}\*(C'\fR hash.
.PP
The \f(CW\*(C`success\*(C'\fR field of the response will be true if the status code is 2XX
or if the status code is 304 (unmodified).
.PP
If the file was modified and the server response includes a properly
formatted \f(CW\*(C`Last\-Modified\*(C'\fR header, the file modification time will
be updated accordingly.
.SS "request"
.IX Subsection "request"
.Vb 2
\&    $response = $http\->request($method, $url);
\&    $response = $http\->request($method, $url, \e%options);
.Ve
.PP
Executes an \s-1HTTP\s0 request of the given method type ('\s-1GET\s0', '\s-1HEAD\s0', '\s-1POST\s0',
\&'\s-1PUT\s0', etc.) on the given \s-1URL. \s0 The \s-1URL\s0 must have unsafe characters escaped and
international domain names encoded.  A hashref of options may be appended to
modify the request.
.PP
Valid options are:
.IP "\(bu" 4
\&\f(CW\*(C`headers\*(C'\fR
.Sp
A hashref containing headers to include with the request.  If the value for
a header is an array reference, the header will be output multiple times with
each value in the array.  These headers over-write any default headers.
.IP "\(bu" 4
\&\f(CW\*(C`content\*(C'\fR
.Sp
A scalar to include as the body of the request \s-1OR\s0 a code reference
that will be called iteratively to produce the body of the request
.IP "\(bu" 4
\&\f(CW\*(C`trailer_callback\*(C'\fR
.Sp
A code reference that will be called if it exists to provide a hashref
of trailing headers (only used with chunked transfer-encoding)
.IP "\(bu" 4
\&\f(CW\*(C`data_callback\*(C'\fR
.Sp
A code reference that will be called for each chunks of the response
body received.
.PP
If the \f(CW\*(C`content\*(C'\fR option is a code reference, it will be called iteratively
to provide the content body of the request.  It should return the empty
string or undef when the iterator is exhausted.
.PP
If the \f(CW\*(C`data_callback\*(C'\fR option is provided, it will be called iteratively until
the entire response body is received.  The first argument will be a string
containing a chunk of the response body, the second argument will be the
in-progress response hash reference, as described below.  (This allows
customizing the action of the callback based on the \f(CW\*(C`status\*(C'\fR or \f(CW\*(C`headers\*(C'\fR
received prior to the content body.)
.PP
The \f(CW\*(C`request\*(C'\fR method returns a hashref containing the response.  The hashref
will have the following keys:
.IP "\(bu" 4
\&\f(CW\*(C`success\*(C'\fR
.Sp
Boolean indicating whether the operation returned a 2XX status code
.IP "\(bu" 4
\&\f(CW\*(C`url\*(C'\fR
.Sp
\&\s-1URL\s0 that provided the response. This is the \s-1URL\s0 of the request unless
there were redirections, in which case it is the last \s-1URL\s0 queried
in a redirection chain
.IP "\(bu" 4
\&\f(CW\*(C`status\*(C'\fR
.Sp
The \s-1HTTP\s0 status code of the response
.IP "\(bu" 4
\&\f(CW\*(C`reason\*(C'\fR
.Sp
The response phrase returned by the server
.IP "\(bu" 4
\&\f(CW\*(C`content\*(C'\fR
.Sp
The body of the response.  If the response does not have any content
or if a data callback is provided to consume the response body,
this will be the empty string
.IP "\(bu" 4
\&\f(CW\*(C`headers\*(C'\fR
.Sp
A hashref of header fields.  All header field names will be normalized
to be lower case. If a header is repeated, the value will be an arrayref;
it will otherwise be a scalar string containing the value
.PP
On an exception during the execution of the request, the \f(CW\*(C`status\*(C'\fR field will
contain 599, and the \f(CW\*(C`content\*(C'\fR field will contain the text of the exception.
.SS "www_form_urlencode"
.IX Subsection "www_form_urlencode"
.Vb 2
\&    $params = $http\->www_form_urlencode( $data );
\&    $response = $http\->get("http://example.com/query?$params");
.Ve
.PP
This method converts the key/value pairs from a data hash or array reference
into a \f(CW\*(C`x\-www\-form\-urlencoded\*(C'\fR string.  The keys and values from the data
reference will be \s-1UTF\-8\s0 encoded and escaped per \s-1RFC 3986. \s0 If a value is an
array reference, the key will be repeated with each of the values of the array
reference.  The key/value pairs in the resulting string will be sorted by key
and value.
.SH "SSL SUPPORT"
.IX Header "SSL SUPPORT"
Direct \f(CW\*(C`https\*(C'\fR connections are supported only if IO::Socket::SSL 1.56 or
greater and Net::SSLeay 1.49 or greater are installed. An exception will be
thrown if a new enough versions of these modules not installed or if the \s-1SSL\s0
encryption fails. There is no support for \f(CW\*(C`https\*(C'\fR connections via proxy (i.e.
\&\s-1RFC 2817\s0).
.PP
\&\s-1SSL\s0 provides two distinct capabilities:
.IP "\(bu" 4
Encrypted communication channel
.IP "\(bu" 4
Verification of server identity
.PP
\&\fBBy default, HTTP::Tiny does not verify server identity\fR.
.PP
Server identity verification is controversial and potentially tricky because it
depends on a (usually paid) third-party Certificate Authority (\s-1CA\s0) trust model
to validate a certificate as legitimate.  This discriminates against servers
with self-signed certificates or certificates signed by free, community-driven
\&\s-1CA\s0's such as CAcert.org <http://cacert.org>.
.PP
By default, HTTP::Tiny does not make any assumptions about your trust model,
threat level or risk tolerance.  It just aims to give you an encrypted channel
when you need one.
.PP
Setting the \f(CW\*(C`verify_SSL\*(C'\fR attribute to a true value will make HTTP::Tiny verify
that an \s-1SSL\s0 connection has a valid \s-1SSL\s0 certificate corresponding to the host
name of the connection and that the \s-1SSL\s0 certificate has been verified by a \s-1CA.\s0
Assuming you trust the \s-1CA,\s0 this will protect against a man-in-the-middle
attack <http://en.wikipedia.org/wiki/Man-in-the-middle_attack>.  If you are
concerned about security, you should enable this option.
.PP
Certificate verification requires a file containing trusted \s-1CA\s0 certificates.
If the Mozilla::CA module is installed, HTTP::Tiny will use the \s-1CA\s0 file
included with it as a source of trusted \s-1CA\s0's.  (This means you trust Mozilla,
the author of Mozilla::CA, the \s-1CPAN\s0 mirror where you got Mozilla::CA, the
toolchain used to install it, and your operating system security, right?)
.PP
If that module is not available, then HTTP::Tiny will search several
system-specific default locations for a \s-1CA\s0 certificate file:
.IP "\(bu" 4
/etc/ssl/certs/ca\-certificates.crt
.IP "\(bu" 4
/etc/pki/tls/certs/ca\-bundle.crt
.IP "\(bu" 4
/etc/ssl/ca\-bundle.pem
.PP
An exception will be raised if \f(CW\*(C`verify_SSL\*(C'\fR is true and no \s-1CA\s0 certificate file
is available.
.PP
If you desire complete control over \s-1SSL\s0 connections, the \f(CW\*(C`SSL_options\*(C'\fR attribute
lets you provide a hash reference that will be passed through to
\&\f(CW\*(C`IO::Socket::SSL::start_SSL()\*(C'\fR, overriding any options set by HTTP::Tiny. For
example, to provide your own trusted \s-1CA\s0 file:
.PP
.Vb 3
\&    SSL_options => {
\&        SSL_ca_file => $file_path,
\&    }
.Ve
.PP
The \f(CW\*(C`SSL_options\*(C'\fR attribute could also be used for such things as providing a
client certificate for authentication to a server or controlling the choice of
cipher used for the \s-1SSL\s0 connection. See IO::Socket::SSL documentation for
details.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
HTTP::Tiny is \fIconditionally compliant\fR with the
\&\s-1HTTP/1.1\s0 specification <http://www.w3.org/Protocols/rfc2616/rfc2616.html>.
It attempts to meet all \*(L"\s-1MUST\*(R"\s0 requirements of the specification, but does not
implement all \*(L"\s-1SHOULD\*(R"\s0 requirements.
.PP
Some particular limitations of note include:
.IP "\(bu" 4
HTTP::Tiny focuses on correct transport.  Users are responsible for ensuring
that user-defined headers and content are compliant with the \s-1HTTP/1.1\s0
specification.
.IP "\(bu" 4
Users must ensure that URLs are properly escaped for unsafe characters and that
international domain names are properly encoded to \s-1ASCII.\s0 See URI::Escape,
URI::_punycode and Net::IDN::Encode.
.IP "\(bu" 4
Redirection is very strict against the specification.  Redirection is only
automatic for response codes 301, 302 and 307 if the request method is '\s-1GET\s0' or
\&'\s-1HEAD\s0'.  Response code 303 is always converted into a '\s-1GET\s0' redirection, as
mandated by the specification.  There is no automatic support for status 305
(\*(L"Use proxy\*(R") redirections.
.IP "\(bu" 4
Persistent connections are not supported.  The \f(CW\*(C`Connection\*(C'\fR header will
always be set to \f(CW\*(C`close\*(C'\fR.
.IP "\(bu" 4
Cookies are not directly supported.  Users that set a \f(CW\*(C`Cookie\*(C'\fR header
should also set \f(CW\*(C`max_redirect\*(C'\fR to zero to ensure cookies are not
inappropriately re-transmitted.
.IP "\(bu" 4
Only the \f(CW\*(C`http_proxy\*(C'\fR environment variable is supported in the format
\&\f(CW\*(C`http://HOST:PORT/\*(C'\fR.  If a \f(CW\*(C`proxy\*(C'\fR argument is passed to \f(CW\*(C`new\*(C'\fR (including
undef), then the \f(CW\*(C`http_proxy\*(C'\fR environment variable is ignored.
.IP "\(bu" 4
There is no provision for delaying a request body using an \f(CW\*(C`Expect\*(C'\fR header.
Unexpected \f(CW\*(C`1XX\*(C'\fR responses are silently ignored as per the specification.
.IP "\(bu" 4
Only 'chunked' \f(CW\*(C`Transfer\-Encoding\*(C'\fR is supported.
.IP "\(bu" 4
There is no support for a Request-URI of '*' for the '\s-1OPTIONS\s0' request.
.IP "\(bu" 4
There is no support for IPv6 of any kind.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
LWP::UserAgent
.IP "\(bu" 4
IO::Socket::SSL
.IP "\(bu" 4
Mozilla::CA
.IP "\(bu" 4
Net::SSLeay
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests through the issue tracker
at <https://rt.cpan.org/Public/Dist/Display.html?Name=HTTP\-Tiny>.
You will be notified automatically of any progress on your issue.
.SS "Source Code"
.IX Subsection "Source Code"
This is open source software.  The code repository is available for
public review and contribution under the terms of the license.
.PP
<https://github.com/dagolden/http\-tiny>
.PP
.Vb 1
\&  git clone git://github.com/dagolden/http\-tiny.git
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Christian Hansen <chansen@cpan.org>
.IP "\(bu" 4
David Golden <dagolden@cpan.org>
.IP "\(bu" 4
Mike Doherty <doherty@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Christian Hansen.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Tiny5.16.3pm                           0100644 0001750 0001750 00000036274 12566207434 023437  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Tiny 3pm"
.TH HTTP::Tiny 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Tiny \- A small, simple, correct HTTP/1.1 client
.SH "VERSION"
.IX Header "VERSION"
version 0.017
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use HTTP::Tiny;
\&
\&    my $response = HTTP::Tiny\->new\->get(\*(Aqhttp://example.com/\*(Aq);
\&
\&    die "Failed!\en" unless $response\->{success};
\&
\&    print "$response\->{status} $response\->{reason}\en";
\&
\&    while (my ($k, $v) = each %{$response\->{headers}}) {
\&        for (ref $v eq \*(AqARRAY\*(Aq ? @$v : $v) {
\&            print "$k: $_\en";
\&        }
\&    }
\&
\&    print $response\->{content} if length $response\->{content};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a very simple \s-1HTTP/1\s0.1 client, designed for doing simple \s-1GET\s0
requests without the overhead of a large framework like LWP::UserAgent.
.PP
It is more correct and more complete than HTTP::Lite.  It supports
proxies (currently only non-authenticating ones) and redirection.  It
also correctly resumes after \s-1EINTR\s0.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&    $http = HTTP::Tiny\->new( %attributes );
.Ve
.PP
This constructor returns a new HTTP::Tiny object.  Valid attributes include:
.IP "\(bu" 4
\&\f(CW\*(C`agent\*(C'\fR
.Sp
A user-agent string (defaults to 'HTTP::Tiny/$VERSION')
.IP "\(bu" 4
\&\f(CW\*(C`default_headers\*(C'\fR
.Sp
A hashref of default headers to apply to requests
.IP "\(bu" 4
\&\f(CW\*(C`max_redirect\*(C'\fR
.Sp
Maximum number of redirects allowed (defaults to 5)
.IP "\(bu" 4
\&\f(CW\*(C`max_size\*(C'\fR
.Sp
Maximum response size (only when not using a data callback).  If defined,
responses larger than this will return an exception.
.IP "\(bu" 4
\&\f(CW\*(C`proxy\*(C'\fR
.Sp
\&\s-1URL\s0 of a proxy server to use (default is \f(CW$ENV{http_proxy}\fR if set)
.IP "\(bu" 4
\&\f(CW\*(C`timeout\*(C'\fR
.Sp
Request timeout in seconds (default is 60)
.PP
Exceptions from \f(CW\*(C`max_size\*(C'\fR, \f(CW\*(C`timeout\*(C'\fR or other errors will result in a
pseudo-HTTP status code of 599 and a reason of \*(L"Internal Exception\*(R". The
content field in the response will contain the text of the exception.
.SS "get|head|put|post|delete"
.IX Subsection "get|head|put|post|delete"
.Vb 3
\&    $response = $http\->get($url);
\&    $response = $http\->get($url, \e%options);
\&    $response = $http\->head($url);
.Ve
.PP
These methods are shorthand for calling \f(CW\*(C`request()\*(C'\fR for the given method.  The
\&\s-1URL\s0 must have unsafe characters escaped and international domain names encoded.
See \f(CW\*(C`request()\*(C'\fR for valid options and a description of the response.
.PP
The \f(CW\*(C`success\*(C'\fR field of the response will be true if the status code is 2XX.
.SS "post_form"
.IX Subsection "post_form"
.Vb 2
\&    $response = $http\->post_form($url, $form_data);
\&    $response = $http\->post_form($url, $form_data, \e%options);
.Ve
.PP
This method executes a \f(CW\*(C`POST\*(C'\fR request and sends the key/value pairs from a
form data hash or array reference to the given \s-1URL\s0 with a \f(CW\*(C`content\-type\*(C'\fR of
\&\f(CW\*(C`application/x\-www\-form\-urlencoded\*(C'\fR.  See documentation for the
\&\f(CW\*(C`www_form_urlencode\*(C'\fR method for details on the encoding.
.PP
The \s-1URL\s0 must have unsafe characters escaped and international domain names
encoded.  See \f(CW\*(C`request()\*(C'\fR for valid options and a description of the response.
Any \f(CW\*(C`content\-type\*(C'\fR header or content in the options hashref will be ignored.
.PP
The \f(CW\*(C`success\*(C'\fR field of the response will be true if the status code is 2XX.
.SS "mirror"
.IX Subsection "mirror"
.Vb 4
\&    $response = $http\->mirror($url, $file, \e%options)
\&    if ( $response\->{success} ) {
\&        print "$file is up to date\en";
\&    }
.Ve
.PP
Executes a \f(CW\*(C`GET\*(C'\fR request for the \s-1URL\s0 and saves the response body to the file
name provided.  The \s-1URL\s0 must have unsafe characters escaped and international
domain names encoded.  If the file already exists, the request will includes an
\&\f(CW\*(C`If\-Modified\-Since\*(C'\fR header with the modification timestamp of the file.  You
may specify a different \f(CW\*(C`If\-Modified\-Since\*(C'\fR header yourself in the \f(CW\*(C`$options\->{headers}\*(C'\fR hash.
.PP
The \f(CW\*(C`success\*(C'\fR field of the response will be true if the status code is 2XX
or if the status code is 304 (unmodified).
.PP
If the file was modified and the server response includes a properly
formatted \f(CW\*(C`Last\-Modified\*(C'\fR header, the file modification time will
be updated accordingly.
.SS "request"
.IX Subsection "request"
.Vb 2
\&    $response = $http\->request($method, $url);
\&    $response = $http\->request($method, $url, \e%options);
.Ve
.PP
Executes an \s-1HTTP\s0 request of the given method type ('\s-1GET\s0', '\s-1HEAD\s0', '\s-1POST\s0',
\&'\s-1PUT\s0', etc.) on the given \s-1URL\s0.  The \s-1URL\s0 must have unsafe characters escaped and
international domain names encoded.  A hashref of options may be appended to
modify the request.
.PP
Valid options are:
.IP "\(bu" 4
headers
.Sp
A hashref containing headers to include with the request.  If the value for
a header is an array reference, the header will be output multiple times with
each value in the array.  These headers over-write any default headers.
.IP "\(bu" 4
content
.Sp
A scalar to include as the body of the request \s-1OR\s0 a code reference
that will be called iteratively to produce the body of the response
.IP "\(bu" 4
trailer_callback
.Sp
A code reference that will be called if it exists to provide a hashref
of trailing headers (only used with chunked transfer-encoding)
.IP "\(bu" 4
data_callback
.Sp
A code reference that will be called for each chunks of the response
body received.
.PP
If the \f(CW\*(C`content\*(C'\fR option is a code reference, it will be called iteratively
to provide the content body of the request.  It should return the empty
string or undef when the iterator is exhausted.
.PP
If the \f(CW\*(C`data_callback\*(C'\fR option is provided, it will be called iteratively until
the entire response body is received.  The first argument will be a string
containing a chunk of the response body, the second argument will be the
in-progress response hash reference, as described below.  (This allows
customizing the action of the callback based on the \f(CW\*(C`status\*(C'\fR or \f(CW\*(C`headers\*(C'\fR
received prior to the content body.)
.PP
The \f(CW\*(C`request\*(C'\fR method returns a hashref containing the response.  The hashref
will have the following keys:
.IP "\(bu" 4
success
.Sp
Boolean indicating whether the operation returned a 2XX status code
.IP "\(bu" 4
status
.Sp
The \s-1HTTP\s0 status code of the response
.IP "\(bu" 4
reason
.Sp
The response phrase returned by the server
.IP "\(bu" 4
content
.Sp
The body of the response.  If the response does not have any content
or if a data callback is provided to consume the response body,
this will be the empty string
.IP "\(bu" 4
headers
.Sp
A hashref of header fields.  All header field names will be normalized
to be lower case. If a header is repeated, the value will be an arrayref;
it will otherwise be a scalar string containing the value
.PP
On an exception during the execution of the request, the \f(CW\*(C`status\*(C'\fR field will
contain 599, and the \f(CW\*(C`content\*(C'\fR field will contain the text of the exception.
.SS "www_form_urlencode"
.IX Subsection "www_form_urlencode"
.Vb 2
\&    $params = $http\->www_form_urlencode( $data );
\&    $response = $http\->get("http://example.com/query?$params");
.Ve
.PP
This method converts the key/value pairs from a data hash or array reference
into a \f(CW\*(C`x\-www\-form\-urlencoded\*(C'\fR string.  The keys and values from the data
reference will be \s-1UTF\-8\s0 encoded and escaped per \s-1RFC\s0 3986.  If a value is an
array reference, the key will be repeated with each of the values of the array
reference.  The key/value pairs in the resulting string will be sorted by key
and value.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
HTTP::Tiny is \fIconditionally compliant\fR with the
\&\s-1HTTP/1\s0.1 specification <http://www.w3.org/Protocols/rfc2616/rfc2616.html>.
It attempts to meet all \*(L"\s-1MUST\s0\*(R" requirements of the specification, but does not
implement all \*(L"\s-1SHOULD\s0\*(R" requirements.
.PP
Some particular limitations of note include:
.IP "\(bu" 4
HTTP::Tiny focuses on correct transport.  Users are responsible for ensuring
that user-defined headers and content are compliant with the \s-1HTTP/1\s0.1
specification.
.IP "\(bu" 4
Users must ensure that URLs are properly escaped for unsafe characters and that
international domain names are properly encoded to \s-1ASCII\s0. See URI::Escape,
URI::_punycode and Net::IDN::Encode.
.IP "\(bu" 4
Redirection is very strict against the specification.  Redirection is only
automatic for response codes 301, 302 and 307 if the request method is '\s-1GET\s0' or
\&'\s-1HEAD\s0'.  Response code 303 is always converted into a '\s-1GET\s0' redirection, as
mandated by the specification.  There is no automatic support for status 305
(\*(L"Use proxy\*(R") redirections.
.IP "\(bu" 4
Persistent connections are not supported.  The \f(CW\*(C`Connection\*(C'\fR header will
always be set to \f(CW\*(C`close\*(C'\fR.
.IP "\(bu" 4
Direct \f(CW\*(C`https\*(C'\fR connections are supported only if IO::Socket::SSL is
installed.  There is no support for \f(CW\*(C`https\*(C'\fR connections via proxy.
Any \s-1SSL\s0 certificate that matches the host is accepted \*(-- \s-1SSL\s0 certificates
are not verified against certificate authorities.
.IP "\(bu" 4
Cookies are not directly supported.  Users that set a \f(CW\*(C`Cookie\*(C'\fR header
should also set \f(CW\*(C`max_redirect\*(C'\fR to zero to ensure cookies are not
inappropriately re-transmitted.
.IP "\(bu" 4
Only the \f(CW\*(C`http_proxy\*(C'\fR environment variable is supported in the format
\&\f(CW\*(C`http://HOST:PORT/\*(C'\fR.  If a \f(CW\*(C`proxy\*(C'\fR argument is passed to \f(CW\*(C`new\*(C'\fR (including
undef), then the \f(CW\*(C`http_proxy\*(C'\fR environment variable is ignored.
.IP "\(bu" 4
There is no provision for delaying a request body using an \f(CW\*(C`Expect\*(C'\fR header.
Unexpected \f(CW\*(C`1XX\*(C'\fR responses are silently ignored as per the specification.
.IP "\(bu" 4
Only 'chunked' \f(CW\*(C`Transfer\-Encoding\*(C'\fR is supported.
.IP "\(bu" 4
There is no support for a Request-URI of '*' for the '\s-1OPTIONS\s0' request.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
LWP::UserAgent
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests through the issue tracker
at http://rt.cpan.org/Public/Dist/Display.html?Name=HTTP\-Tiny <http://rt.cpan.org/Public/Dist/Display.html?Name=HTTP-Tiny>.
You will be notified automatically of any progress on your issue.
.SS "Source Code"
.IX Subsection "Source Code"
This is open source software.  The code repository is available for
public review and contribution under the terms of the license.
.PP
https://github.com/dagolden/p5\-http\-tiny <https://github.com/dagolden/p5-http-tiny>
.PP
.Vb 1
\&  git clone https://github.com/dagolden/p5\-http\-tiny.git
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Christian Hansen <chansen@cpan.org>
.IP "\(bu" 4
David Golden <dagolden@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Christian Hansen.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/HTTP::Tiny5.18.3pm                           0100644 0001750 0001750 00000046335 12566207455 023443  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "HTTP::Tiny 3pm"
.TH HTTP::Tiny 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
HTTP::Tiny \- A small, simple, correct HTTP/1.1 client
.SH "VERSION"
.IX Header "VERSION"
version 0.025
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use HTTP::Tiny;
\&
\&    my $response = HTTP::Tiny\->new\->get(\*(Aqhttp://example.com/\*(Aq);
\&
\&    die "Failed!\en" unless $response\->{success};
\&
\&    print "$response\->{status} $response\->{reason}\en";
\&
\&    while (my ($k, $v) = each %{$response\->{headers}}) {
\&        for (ref $v eq \*(AqARRAY\*(Aq ? @$v : $v) {
\&            print "$k: $_\en";
\&        }
\&    }
\&
\&    print $response\->{content} if length $response\->{content};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a very simple \s-1HTTP/1.1\s0 client, designed for doing simple \s-1GET\s0
requests without the overhead of a large framework like LWP::UserAgent.
.PP
It is more correct and more complete than HTTP::Lite.  It supports
proxies (currently only non-authenticating ones) and redirection.  It
also correctly resumes after \s-1EINTR.\s0
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
.Vb 1
\&    $http = HTTP::Tiny\->new( %attributes );
.Ve
.PP
This constructor returns a new HTTP::Tiny object.  Valid attributes include:
.IP "\(bu" 4
\&\f(CW\*(C`agent\*(C'\fR
.Sp
A user-agent string (defaults to 'HTTP\-Tiny/$VERSION'). If \f(CW\*(C`agent\*(C'\fR ends in a space character, the default user-agent string is appended.
.IP "\(bu" 4
\&\f(CW\*(C`default_headers\*(C'\fR
.Sp
A hashref of default headers to apply to requests
.IP "\(bu" 4
\&\f(CW\*(C`local_address\*(C'\fR
.Sp
The local \s-1IP\s0 address to bind to
.IP "\(bu" 4
\&\f(CW\*(C`max_redirect\*(C'\fR
.Sp
Maximum number of redirects allowed (defaults to 5)
.IP "\(bu" 4
\&\f(CW\*(C`max_size\*(C'\fR
.Sp
Maximum response size (only when not using a data callback).  If defined,
responses larger than this will return an exception.
.IP "\(bu" 4
\&\f(CW\*(C`proxy\*(C'\fR
.Sp
\&\s-1URL\s0 of a proxy server to use (default is \f(CW$ENV{http_proxy}\fR if set)
.IP "\(bu" 4
\&\f(CW\*(C`timeout\*(C'\fR
.Sp
Request timeout in seconds (default is 60)
.IP "\(bu" 4
\&\f(CW\*(C`verify_SSL\*(C'\fR
.Sp
A boolean that indicates whether to validate the \s-1SSL\s0 certificate of an \f(CW\*(C`https\*(C'\fR
connection (default is false)
.IP "\(bu" 4
\&\f(CW\*(C`SSL_options\*(C'\fR
.Sp
A hashref of \f(CW\*(C`SSL_*\*(C'\fR options to pass through to IO::Socket::SSL
.PP
Exceptions from \f(CW\*(C`max_size\*(C'\fR, \f(CW\*(C`timeout\*(C'\fR or other errors will result in a
pseudo-HTTP status code of 599 and a reason of \*(L"Internal Exception\*(R". The
content field in the response will contain the text of the exception.
.PP
See \*(L"\s-1SSL SUPPORT\*(R"\s0 for more on the \f(CW\*(C`verify_SSL\*(C'\fR and \f(CW\*(C`SSL_options\*(C'\fR attributes.
.SS "get|head|put|post|delete"
.IX Subsection "get|head|put|post|delete"
.Vb 3
\&    $response = $http\->get($url);
\&    $response = $http\->get($url, \e%options);
\&    $response = $http\->head($url);
.Ve
.PP
These methods are shorthand for calling \f(CW\*(C`request()\*(C'\fR for the given method.  The
\&\s-1URL\s0 must have unsafe characters escaped and international domain names encoded.
See \f(CW\*(C`request()\*(C'\fR for valid options and a description of the response.
.PP
The \f(CW\*(C`success\*(C'\fR field of the response will be true if the status code is 2XX.
.SS "post_form"
.IX Subsection "post_form"
.Vb 2
\&    $response = $http\->post_form($url, $form_data);
\&    $response = $http\->post_form($url, $form_data, \e%options);
.Ve
.PP
This method executes a \f(CW\*(C`POST\*(C'\fR request and sends the key/value pairs from a
form data hash or array reference to the given \s-1URL\s0 with a \f(CW\*(C`content\-type\*(C'\fR of
\&\f(CW\*(C`application/x\-www\-form\-urlencoded\*(C'\fR.  See documentation for the
\&\f(CW\*(C`www_form_urlencode\*(C'\fR method for details on the encoding.
.PP
The \s-1URL\s0 must have unsafe characters escaped and international domain names
encoded.  See \f(CW\*(C`request()\*(C'\fR for valid options and a description of the response.
Any \f(CW\*(C`content\-type\*(C'\fR header or content in the options hashref will be ignored.
.PP
The \f(CW\*(C`success\*(C'\fR field of the response will be true if the status code is 2XX.
.SS "mirror"
.IX Subsection "mirror"
.Vb 4
\&    $response = $http\->mirror($url, $file, \e%options)
\&    if ( $response\->{success} ) {
\&        print "$file is up to date\en";
\&    }
.Ve
.PP
Executes a \f(CW\*(C`GET\*(C'\fR request for the \s-1URL\s0 and saves the response body to the file
name provided.  The \s-1URL\s0 must have unsafe characters escaped and international
domain names encoded.  If the file already exists, the request will includes an
\&\f(CW\*(C`If\-Modified\-Since\*(C'\fR header with the modification timestamp of the file.  You
may specify a different \f(CW\*(C`If\-Modified\-Since\*(C'\fR header yourself in the \f(CW\*(C`$options\->{headers}\*(C'\fR hash.
.PP
The \f(CW\*(C`success\*(C'\fR field of the response will be true if the status code is 2XX
or if the status code is 304 (unmodified).
.PP
If the file was modified and the server response includes a properly
formatted \f(CW\*(C`Last\-Modified\*(C'\fR header, the file modification time will
be updated accordingly.
.SS "request"
.IX Subsection "request"
.Vb 2
\&    $response = $http\->request($method, $url);
\&    $response = $http\->request($method, $url, \e%options);
.Ve
.PP
Executes an \s-1HTTP\s0 request of the given method type ('\s-1GET\s0', '\s-1HEAD\s0', '\s-1POST\s0',
\&'\s-1PUT\s0', etc.) on the given \s-1URL. \s0 The \s-1URL\s0 must have unsafe characters escaped and
international domain names encoded.  A hashref of options may be appended to
modify the request.
.PP
Valid options are:
.IP "\(bu" 4
\&\f(CW\*(C`headers\*(C'\fR
.Sp
A hashref containing headers to include with the request.  If the value for
a header is an array reference, the header will be output multiple times with
each value in the array.  These headers over-write any default headers.
.IP "\(bu" 4
\&\f(CW\*(C`content\*(C'\fR
.Sp
A scalar to include as the body of the request \s-1OR\s0 a code reference
that will be called iteratively to produce the body of the request
.IP "\(bu" 4
\&\f(CW\*(C`trailer_callback\*(C'\fR
.Sp
A code reference that will be called if it exists to provide a hashref
of trailing headers (only used with chunked transfer-encoding)
.IP "\(bu" 4
\&\f(CW\*(C`data_callback\*(C'\fR
.Sp
A code reference that will be called for each chunks of the response
body received.
.PP
If the \f(CW\*(C`content\*(C'\fR option is a code reference, it will be called iteratively
to provide the content body of the request.  It should return the empty
string or undef when the iterator is exhausted.
.PP
If the \f(CW\*(C`data_callback\*(C'\fR option is provided, it will be called iteratively until
the entire response body is received.  The first argument will be a string
containing a chunk of the response body, the second argument will be the
in-progress response hash reference, as described below.  (This allows
customizing the action of the callback based on the \f(CW\*(C`status\*(C'\fR or \f(CW\*(C`headers\*(C'\fR
received prior to the content body.)
.PP
The \f(CW\*(C`request\*(C'\fR method returns a hashref containing the response.  The hashref
will have the following keys:
.IP "\(bu" 4
\&\f(CW\*(C`success\*(C'\fR
.Sp
Boolean indicating whether the operation returned a 2XX status code
.IP "\(bu" 4
\&\f(CW\*(C`url\*(C'\fR
.Sp
\&\s-1URL\s0 that provided the response. This is the \s-1URL\s0 of the request unless
there were redirections, in which case it is the last \s-1URL\s0 queried
in a redirection chain
.IP "\(bu" 4
\&\f(CW\*(C`status\*(C'\fR
.Sp
The \s-1HTTP\s0 status code of the response
.IP "\(bu" 4
\&\f(CW\*(C`reason\*(C'\fR
.Sp
The response phrase returned by the server
.IP "\(bu" 4
\&\f(CW\*(C`content\*(C'\fR
.Sp
The body of the response.  If the response does not have any content
or if a data callback is provided to consume the response body,
this will be the empty string
.IP "\(bu" 4
\&\f(CW\*(C`headers\*(C'\fR
.Sp
A hashref of header fields.  All header field names will be normalized
to be lower case. If a header is repeated, the value will be an arrayref;
it will otherwise be a scalar string containing the value
.PP
On an exception during the execution of the request, the \f(CW\*(C`status\*(C'\fR field will
contain 599, and the \f(CW\*(C`content\*(C'\fR field will contain the text of the exception.
.SS "www_form_urlencode"
.IX Subsection "www_form_urlencode"
.Vb 2
\&    $params = $http\->www_form_urlencode( $data );
\&    $response = $http\->get("http://example.com/query?$params");
.Ve
.PP
This method converts the key/value pairs from a data hash or array reference
into a \f(CW\*(C`x\-www\-form\-urlencoded\*(C'\fR string.  The keys and values from the data
reference will be \s-1UTF\-8\s0 encoded and escaped per \s-1RFC 3986. \s0 If a value is an
array reference, the key will be repeated with each of the values of the array
reference.  The key/value pairs in the resulting string will be sorted by key
and value.
.SH "SSL SUPPORT"
.IX Header "SSL SUPPORT"
Direct \f(CW\*(C`https\*(C'\fR connections are supported only if IO::Socket::SSL 1.56 or
greater and Net::SSLeay 1.49 or greater are installed. An exception will be
thrown if a new enough versions of these modules not installed or if the \s-1SSL\s0
encryption fails. There is no support for \f(CW\*(C`https\*(C'\fR connections via proxy (i.e.
\&\s-1RFC 2817\s0).
.PP
\&\s-1SSL\s0 provides two distinct capabilities:
.IP "\(bu" 4
Encrypted communication channel
.IP "\(bu" 4
Verification of server identity
.PP
\&\fBBy default, HTTP::Tiny does not verify server identity\fR.
.PP
Server identity verification is controversial and potentially tricky because it
depends on a (usually paid) third-party Certificate Authority (\s-1CA\s0) trust model
to validate a certificate as legitimate.  This discriminates against servers
with self-signed certificates or certificates signed by free, community-driven
\&\s-1CA\s0's such as CAcert.org <http://cacert.org>.
.PP
By default, HTTP::Tiny does not make any assumptions about your trust model,
threat level or risk tolerance.  It just aims to give you an encrypted channel
when you need one.
.PP
Setting the \f(CW\*(C`verify_SSL\*(C'\fR attribute to a true value will make HTTP::Tiny verify
that an \s-1SSL\s0 connection has a valid \s-1SSL\s0 certificate corresponding to the host
name of the connection and that the \s-1SSL\s0 certificate has been verified by a \s-1CA.\s0
Assuming you trust the \s-1CA,\s0 this will protect against a man-in-the-middle
attack <http://en.wikipedia.org/wiki/Man-in-the-middle_attack>.  If you are
concerned about security, you should enable this option.
.PP
Certificate verification requires a file containing trusted \s-1CA\s0 certificates.
If the Mozilla::CA module is installed, HTTP::Tiny will use the \s-1CA\s0 file
included with it as a source of trusted \s-1CA\s0's.  (This means you trust Mozilla,
the author of Mozilla::CA, the \s-1CPAN\s0 mirror where you got Mozilla::CA, the
toolchain used to install it, and your operating system security, right?)
.PP
If that module is not available, then HTTP::Tiny will search several
system-specific default locations for a \s-1CA\s0 certificate file:
.IP "\(bu" 4
/etc/ssl/certs/ca\-certificates.crt
.IP "\(bu" 4
/etc/pki/tls/certs/ca\-bundle.crt
.IP "\(bu" 4
/etc/ssl/ca\-bundle.pem
.PP
An exception will be raised if \f(CW\*(C`verify_SSL\*(C'\fR is true and no \s-1CA\s0 certificate file
is available.
.PP
If you desire complete control over \s-1SSL\s0 connections, the \f(CW\*(C`SSL_options\*(C'\fR attribute
lets you provide a hash reference that will be passed through to
\&\f(CW\*(C`IO::Socket::SSL::start_SSL()\*(C'\fR, overriding any options set by HTTP::Tiny. For
example, to provide your own trusted \s-1CA\s0 file:
.PP
.Vb 3
\&    SSL_options => {
\&        SSL_ca_file => $file_path,
\&    }
.Ve
.PP
The \f(CW\*(C`SSL_options\*(C'\fR attribute could also be used for such things as providing a
client certificate for authentication to a server or controlling the choice of
cipher used for the \s-1SSL\s0 connection. See IO::Socket::SSL documentation for
details.
.SH "LIMITATIONS"
.IX Header "LIMITATIONS"
HTTP::Tiny is \fIconditionally compliant\fR with the
\&\s-1HTTP/1.1\s0 specification <http://www.w3.org/Protocols/rfc2616/rfc2616.html>.
It attempts to meet all \*(L"\s-1MUST\*(R"\s0 requirements of the specification, but does not
implement all \*(L"\s-1SHOULD\*(R"\s0 requirements.
.PP
Some particular limitations of note include:
.IP "\(bu" 4
HTTP::Tiny focuses on correct transport.  Users are responsible for ensuring
that user-defined headers and content are compliant with the \s-1HTTP/1.1\s0
specification.
.IP "\(bu" 4
Users must ensure that URLs are properly escaped for unsafe characters and that
international domain names are properly encoded to \s-1ASCII.\s0 See URI::Escape,
URI::_punycode and Net::IDN::Encode.
.IP "\(bu" 4
Redirection is very strict against the specification.  Redirection is only
automatic for response codes 301, 302 and 307 if the request method is '\s-1GET\s0' or
\&'\s-1HEAD\s0'.  Response code 303 is always converted into a '\s-1GET\s0' redirection, as
mandated by the specification.  There is no automatic support for status 305
(\*(L"Use proxy\*(R") redirections.
.IP "\(bu" 4
Persistent connections are not supported.  The \f(CW\*(C`Connection\*(C'\fR header will
always be set to \f(CW\*(C`close\*(C'\fR.
.IP "\(bu" 4
Cookies are not directly supported.  Users that set a \f(CW\*(C`Cookie\*(C'\fR header
should also set \f(CW\*(C`max_redirect\*(C'\fR to zero to ensure cookies are not
inappropriately re-transmitted.
.IP "\(bu" 4
Only the \f(CW\*(C`http_proxy\*(C'\fR environment variable is supported in the format
\&\f(CW\*(C`http://HOST:PORT/\*(C'\fR.  If a \f(CW\*(C`proxy\*(C'\fR argument is passed to \f(CW\*(C`new\*(C'\fR (including
undef), then the \f(CW\*(C`http_proxy\*(C'\fR environment variable is ignored.
.IP "\(bu" 4
There is no provision for delaying a request body using an \f(CW\*(C`Expect\*(C'\fR header.
Unexpected \f(CW\*(C`1XX\*(C'\fR responses are silently ignored as per the specification.
.IP "\(bu" 4
Only 'chunked' \f(CW\*(C`Transfer\-Encoding\*(C'\fR is supported.
.IP "\(bu" 4
There is no support for a Request-URI of '*' for the '\s-1OPTIONS\s0' request.
.IP "\(bu" 4
There is no support for IPv6 of any kind.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
LWP::UserAgent
.IP "\(bu" 4
IO::Socket::SSL
.IP "\(bu" 4
Mozilla::CA
.IP "\(bu" 4
Net::SSLeay
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests through the issue tracker
at <https://rt.cpan.org/Public/Dist/Display.html?Name=HTTP\-Tiny>.
You will be notified automatically of any progress on your issue.
.SS "Source Code"
.IX Subsection "Source Code"
This is open source software.  The code repository is available for
public review and contribution under the terms of the license.
.PP
<https://github.com/dagolden/http\-tiny>
.PP
.Vb 1
\&  git clone git://github.com/dagolden/http\-tiny.git
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Christian Hansen <chansen@cpan.org>
.IP "\(bu" 4
David Golden <dagolden@cpan.org>
.IP "\(bu" 4
Mike Doherty <doherty@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2012 by Christian Hansen.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Hash::Merge.3pm                              0100644 0001750 0001750 00000035045 12566242313 023333  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Hash::Merge 3"
.TH Hash::Merge 3 "2013-11-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Hash::Merge \- Merges arbitrarily deep hashes into a single hash
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&    use Hash::Merge qw( merge );
\&    my %a = ( 
\&                \*(Aqfoo\*(Aq    => 1,
\&            \*(Aqbar\*(Aq    => [ qw( a b e ) ],
\&            \*(Aqquerty\*(Aq => { \*(Aqbob\*(Aq => \*(Aqalice\*(Aq },
\&        );
\&    my %b = ( 
\&                \*(Aqfoo\*(Aq     => 2, 
\&                \*(Aqbar\*(Aq    => [ qw(c d) ],
\&                \*(Aqquerty\*(Aq => { \*(Aqted\*(Aq => \*(Aqmargeret\*(Aq }, 
\&        );
\&
\&    my %c = %{ merge( \e%a, \e%b ) };
\&
\&    Hash::Merge::set_behavior( \*(AqRIGHT_PRECEDENT\*(Aq );
\&
\&    # This is the same as above
\&
\&        Hash::Merge::specify_behavior(
\&            {
\&                        \*(AqSCALAR\*(Aq => {
\&                                \*(AqSCALAR\*(Aq => sub { $_[1] },
\&                                \*(AqARRAY\*(Aq  => sub { [ $_[0], @{$_[1]} ] },
\&                                \*(AqHASH\*(Aq   => sub { $_[1] },
\&                        },
\&                        \*(AqARRAY => {
\&                                \*(AqSCALAR\*(Aq => sub { $_[1] },
\&                                \*(AqARRAY\*(Aq  => sub { [ @{$_[0]}, @{$_[1]} ] },
\&                                \*(AqHASH\*(Aq   => sub { $_[1] }, 
\&                        },
\&                        \*(AqHASH\*(Aq => {
\&                                \*(AqSCALAR\*(Aq => sub { $_[1] },
\&                                \*(AqARRAY\*(Aq  => sub { [ values %{$_[0]}, @{$_[1]} ] },
\&                                \*(AqHASH\*(Aq   => sub { Hash::Merge::_merge_hashes( $_[0], $_[1] ) }, 
\&                        },
\&                }, 
\&                \*(AqMy Behavior\*(Aq, 
\&        );
\&        
\&        # Also there is OO interface.
\&        
\&        my $merge = Hash::Merge\->new( \*(AqLEFT_PRECEDENT\*(Aq );
\&        my %c = %{ $merge\->merge( \e%a, \e%b ) };
\&        
\&        # All behavioral changes (e.g. $merge\->set_behavior(...)), called on an object remain specific to that object
\&        # The legacy "Global Setting" behavior is respected only when new called as a non\-OO function.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Hash::Merge merges two arbitrarily deep hashes into a single hash.  That
is, at any level, it will add non-conflicting key-value pairs from one
hash to the other, and follows a set of specific rules when there are key
value conflicts (as outlined below).  The hash is followed recursively,
so that deeply nested hashes that are at the same level will be merged 
when the parent hashes are merged.  \fBPlease note that self-referencing
hashes, or recursive references, are not handled well by this method.\fR
.PP
Values in hashes are considered to be either \s-1ARRAY\s0 references, 
\&\s-1HASH\s0 references, or otherwise are treated as SCALARs.  By default, the 
data passed to the merge function will be cloned using the Clone module; 
however, if necessary, this behavior can be changed to use as many of 
the original values as possible.  (See \f(CW\*(C`set_clone_behavior\*(C'\fR).
.PP
Because there are a number of possible ways that one may want to merge
values when keys are conflicting, Hash::Merge provides several preset
methods for your convenience, as well as a way to define you own.  
These are (currently):
.IP "Left Precedence" 4
.IX Item "Left Precedence"
This is the default behavior.
.Sp
The values buried in the left hash will never
be lost; any values that can be added from the right hash will be
attempted.
.Sp
.Vb 4
\&   my $merge = Hash::Merge\->new();
\&   my $merge = Hash::Merge\->new(\*(AqLEFT_PRECEDENT\*(Aq);
\&   $merge\->set_set_behavior(\*(AqLEFT_PRECEDENT\*(Aq)
\&   Hash::Merge::set_set_behavior(\*(AqLEFT_PRECEDENT\*(Aq)
.Ve
.IP "Right Precedence" 4
.IX Item "Right Precedence"
Same as Left Precedence, but with the right
hash values never being lost
.Sp
.Vb 3
\&   my $merge = Hash::Merge\->new(\*(AqRIGHT_PRECEDENT\*(Aq);
\&   $merge\->set_set_behavior(\*(AqRIGHT_PRECEDENT\*(Aq)
\&   Hash::Merge::set_set_behavior(\*(AqRIGHT_PRECEDENT\*(Aq)
.Ve
.IP "Storage Precedence" 4
.IX Item "Storage Precedence"
If conflicting keys have two different
storage mediums, the 'bigger' medium will win; arrays are preferred over
scalars, hashes over either.  The other medium will try to be fitted in
the other, but if this isn't possible, the data is dropped.
.Sp
.Vb 3
\&   my $merge = Hash::Merge\->new(\*(AqSTORAGE_PRECEDENT\*(Aq);
\&   $merge\->set_set_behavior(\*(AqSTORAGE_PRECEDENT\*(Aq)
\&   Hash::Merge::set_set_behavior(\*(AqSTORAGE_PRECEDENT\*(Aq)
.Ve
.IP "Retainment Precedence" 4
.IX Item "Retainment Precedence"
No data will be lost; scalars will be joined
with arrays, and scalars and arrays will be 'hashified' to fit them into
a hash.
.Sp
.Vb 3
\&   my $merge = Hash::Merge\->new(\*(AqRETAINMENT_PRECEDENT\*(Aq);
\&   $merge\->set_set_behavior(\*(AqRETAINMENT_PRECEDENT\*(Aq)
\&   Hash::Merge::set_set_behavior(\*(AqRETAINMENT_PRECEDENT\*(Aq)
.Ve
.PP
Specific descriptions of how these work are detailed below.
.IP "merge ( <hashref>, <hashref> )" 4
.IX Item "merge ( <hashref>, <hashref> )"
Merges two hashes given the rules specified.  Returns a reference to 
the new hash.
.IP "_hashify( <scalar>|<arrayref> ) \*(-- \s-1INTERNAL FUNCTION\s0" 4
.IX Item "_hashify( <scalar>|<arrayref> ) INTERNAL FUNCTION"
Returns a reference to a hash created from the scalar or array reference, 
where, for the scalar value, or each item in the array, there is a key
and it's value equal to that specific value.  Example, if you pass scalar
\&'3', the hash will be { 3 => 3 }.
.IP "_merge_hashes( <hashref>, <hashref> ) \*(-- \s-1INTERNAL FUNCTION\s0" 4
.IX Item "_merge_hashes( <hashref>, <hashref> ) INTERNAL FUNCTION"
Actually does the key-by-key evaluation of two hashes and returns 
the new merged hash.  Note that this recursively calls \f(CW\*(C`merge\*(C'\fR.
.IP "set_clone_behavior( <scalar> )" 4
.IX Item "set_clone_behavior( <scalar> )"
Sets how the data cloning is handled by Hash::Merge.  If this is true,
then data will be cloned; if false, then original data will be used
whenever possible.  By default, cloning is on (set to true).
.IP "get_clone_behavior( )" 4
.IX Item "get_clone_behavior( )"
Returns the current behavior for data cloning.
.IP "set_behavior( <scalar> )" 4
.IX Item "set_behavior( <scalar> )"
Specify which built-in behavior for merging that is desired.  The scalar
must be one of those given below.
.IP "get_behavior( )" 4
.IX Item "get_behavior( )"
Returns the behavior that is currently in use by Hash::Merge.
.IP "specify_behavior( <hashref>, [<name>] )" 4
.IX Item "specify_behavior( <hashref>, [<name>] )"
Specify a custom merge behavior for Hash::Merge.  This must be a hashref
defined with (at least) 3 keys, \s-1SCALAR, ARRAY,\s0 and \s-1HASH\s0; each of those
keys must have another hashref with (at least) the same 3 keys defined.
Furthermore, the values in those hashes must be coderefs.  These will be
called with two arguments, the left and right values for the merge.  
Your coderef should return either a scalar or an array or hash reference
as per your planned behavior.  If necessary, use the functions
_hashify and _merge_hashes as helper functions for these.  For example,
if you want to add the left \s-1SCALAR\s0 to the right \s-1ARRAY,\s0 you can have your
behavior specification include:
.Sp
.Vb 1
\&   %spec = ( ...SCALAR => { ARRAY => sub { [ $_[0], @$_[1] ] }, ... } } );
.Ve
.Sp
Note that you can import _hashify and _merge_hashes into your program's
namespace with the 'custom' tag.
.SH "BUILT-IN BEHAVIORS"
.IX Header "BUILT-IN BEHAVIORS"
Here is the specifics on how the current internal behaviors are called, 
and what each does.  Assume that the left value is given as \f(CW$a\fR, and
the right as \f(CW$b\fR (these are either scalars or appropriate references)
.PP
.Vb 10
\&        LEFT TYPE   RIGHT TYPE      LEFT_PRECEDENT       RIGHT_PRECEDENT
\&         SCALAR      SCALAR            $a                   $b
\&         SCALAR      ARRAY             $a                   ( $a, @$b )
\&         SCALAR      HASH              $a                   %$b
\&         ARRAY       SCALAR            ( @$a, $b )          $b
\&         ARRAY       ARRAY             ( @$a, @$b )         ( @$a, @$b )
\&         ARRAY       HASH              ( @$a, values %$b )  %$b 
\&         HASH        SCALAR            %$a                  $b
\&         HASH        ARRAY             %$a                  ( values %$a, @$b )
\&         HASH        HASH              merge( %$a, %$b )    merge( %$a, %$b )
\&
\&        LEFT TYPE   RIGHT TYPE  STORAGE_PRECEDENT   RETAINMENT_PRECEDENT
\&         SCALAR      SCALAR     $a                  ( $a ,$b )
\&         SCALAR      ARRAY      ( $a, @$b )         ( $a, @$b )
\&         SCALAR      HASH       %$b                 merge( hashify( $a ), %$b )
\&         ARRAY       SCALAR     ( @$a, $b )         ( @$a, $b )
\&         ARRAY       ARRAY      ( @$a, @$b )        ( @$a, @$b )
\&         ARRAY       HASH       %$b                 merge( hashify( @$a ), %$b )
\&         HASH        SCALAR     %$a                 merge( %$a, hashify( $b ) )
\&         HASH        ARRAY      %$a                 merge( %$a, hashify( @$b ) )
\&         HASH        HASH       merge( %$a, %$b )   merge( %$a, %$b )
.Ve
.PP
(*) note that merge calls _merge_hashes, hashify calls _hashify.
.SH "CAVEATS"
.IX Header "CAVEATS"
This will not handle self\-referencing/recursion within hashes well.  
Plans for a future version include incorporate deep recursion protection.
.PP
As of Feb 16, 2002, ActiveState Perl's \s-1PPM\s0 of Clone.pm is only at
0.09.  This version does not support the cloning of scalars if passed
to the function.  This is fixed by 0.10 (and currently, Clone.pm is at
0.13).  So while most other users can upgrade their Clone.pm
appropriately (and I could put this as a requirement into the
Makefile.PL), those using ActiveState would lose out on the ability to
use this module.  (Clone.pm is not pure perl, so it's not simply a
matter of moving the newer file into place).  Thus, for the time
being, a check is done at the start of loading of this module to see
if a newer version of clone is around.  Then, all cloning calls have
been wrapped in the internal _my_clone function to block any scalar
clones if Clone.pm is too old.  However, this also prevents the
cloning of anything that isn't a hash or array under the same
conditions.  Once ActiveState updates their Clone, I'll remove this 
wrapper.
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael K. Neylon <mneylon\-pm@masemware.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2001,2002 Michael K. Neylon. All rights reserved.
.PP
This library is free software.  You can redistribute it and/or modify it 
under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Hash::Merge5.16.3pm                          0100644 0001750 0001750 00000034537 12566242315 023654  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Merge 3"
.TH Merge 3 "2010-02-15" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Hash::Merge \- Merges arbitrarily deep hashes into a single hash
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&    use Hash::Merge qw( merge );
\&    my %a = ( 
\&                \*(Aqfoo\*(Aq    => 1,
\&            \*(Aqbar\*(Aq    => [ qw( a b e ) ],
\&            \*(Aqquerty\*(Aq => { \*(Aqbob\*(Aq => \*(Aqalice\*(Aq },
\&        );
\&    my %b = ( 
\&                \*(Aqfoo\*(Aq     => 2, 
\&                \*(Aqbar\*(Aq    => [ qw(c d) ],
\&                \*(Aqquerty\*(Aq => { \*(Aqted\*(Aq => \*(Aqmargeret\*(Aq }, 
\&        );
\&
\&    my %c = %{ merge( \e%a, \e%b ) };
\&
\&    Hash::Merge::set_behavior( \*(AqRIGHT_PRECEDENT\*(Aq );
\&
\&    # This is the same as above
\&
\&        Hash::Merge::specify_behavior(
\&            {
\&                        \*(AqSCALAR\*(Aq => {
\&                                \*(AqSCALAR\*(Aq => sub { $_[1] },
\&                                \*(AqARRAY\*(Aq  => sub { [ $_[0], @{$_[1]} ] },
\&                                \*(AqHASH\*(Aq   => sub { $_[1] },
\&                        },
\&                        \*(AqARRAY => {
\&                                \*(AqSCALAR\*(Aq => sub { $_[1] },
\&                                \*(AqARRAY\*(Aq  => sub { [ @{$_[0]}, @{$_[1]} ] },
\&                                \*(AqHASH\*(Aq   => sub { $_[1] }, 
\&                        },
\&                        \*(AqHASH\*(Aq => {
\&                                \*(AqSCALAR\*(Aq => sub { $_[1] },
\&                                \*(AqARRAY\*(Aq  => sub { [ values %{$_[0]}, @{$_[1]} ] },
\&                                \*(AqHASH\*(Aq   => sub { Hash::Merge::_merge_hashes( $_[0], $_[1] ) }, 
\&                        },
\&                }, 
\&                \*(AqMy Behavior\*(Aq, 
\&        );
\&        
\&        # Also there is OO interface.
\&        
\&        my $merge = Hash::Merge\->new( \*(AqLEFT_PRECEDENT\*(Aq );
\&        my %c = %{ $merge\->merge( \e%a, \e%b ) };
\&        
\&        # All behavioral changes (e.g. $merge\->set_behavior(...)), called on an object remain specific to that object
\&        # The legacy "Global Setting" behavior is respected only when new called as a non\-OO function.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Hash::Merge merges two arbitrarily deep hashes into a single hash.  That
is, at any level, it will add non-conflicting key-value pairs from one
hash to the other, and follows a set of specific rules when there are key
value conflicts (as outlined below).  The hash is followed recursively,
so that deeply nested hashes that are at the same level will be merged 
when the parent hashes are merged.  \fBPlease note that self-referencing
hashes, or recursive references, are not handled well by this method.\fR
.PP
Values in hashes are considered to be either \s-1ARRAY\s0 references, 
\&\s-1HASH\s0 references, or otherwise are treated as SCALARs.  By default, the 
data passed to the merge function will be cloned using the Clone module; 
however, if necessary, this behavior can be changed to use as many of 
the original values as possible.  (See \f(CW\*(C`set_clone_behavior\*(C'\fR).
.PP
Because there are a number of possible ways that one may want to merge
values when keys are conflicting, Hash::Merge provides several preset
methods for your convenience, as well as a way to define you own.  
These are (currently):
.IP "Left Precedence" 4
.IX Item "Left Precedence"
This is the default behavior.
.Sp
The values buried in the left hash will never
be lost; any values that can be added from the right hash will be
attempted.
.Sp
.Vb 4
\&   my $merge = Hash::Merge\->new();
\&   my $merge = Hash::Merge\->new(\*(AqLEFT_PRECEDENT\*(Aq);
\&   $merge\->set_set_behavior(\*(AqLEFT_PRECEDENT\*(Aq)
\&   Hash::Merge::set_set_behavior(\*(AqLEFT_PRECEDENT\*(Aq)
.Ve
.IP "Right Precedence" 4
.IX Item "Right Precedence"
Same as Left Precedence, but with the right
hash values never being lost
.Sp
.Vb 3
\&   my $merge = Hash::Merge\->new(\*(AqRIGHT_PRECEDENT\*(Aq);
\&   $merge\->set_set_behavior(\*(AqRIGHT_PRECEDENT\*(Aq)
\&   Hash::Merge::set_set_behavior(\*(AqRIGHT_PRECEDENT\*(Aq)
.Ve
.IP "Storage Precedence" 4
.IX Item "Storage Precedence"
If conflicting keys have two different
storage mediums, the 'bigger' medium will win; arrays are preferred over
scalars, hashes over either.  The other medium will try to be fitted in
the other, but if this isn't possible, the data is dropped.
.Sp
.Vb 3
\&   my $merge = Hash::Merge\->new(\*(AqSTORAGE_PRECEDENT\*(Aq);
\&   $merge\->set_set_behavior(\*(AqSTORAGE_PRECEDENT\*(Aq)
\&   Hash::Merge::set_set_behavior(\*(AqSTORAGE_PRECEDENT\*(Aq)
.Ve
.IP "Retainment Precedence" 4
.IX Item "Retainment Precedence"
No data will be lost; scalars will be joined
with arrays, and scalars and arrays will be 'hashified' to fit them into
a hash.
.Sp
.Vb 3
\&   my $merge = Hash::Merge\->new(\*(AqRETAINMENT_PRECEDENT\*(Aq);
\&   $merge\->set_set_behavior(\*(AqRETAINMENT_PRECEDENT\*(Aq)
\&   Hash::Merge::set_set_behavior(\*(AqRETAINMENT_PRECEDENT\*(Aq)
.Ve
.PP
Specific descriptions of how these work are detailed below.
.IP "merge ( <hashref>, <hashref> )" 4
.IX Item "merge ( <hashref>, <hashref> )"
Merges two hashes given the rules specified.  Returns a reference to 
the new hash.
.IP "_hashify( <scalar>|<arrayref> ) \*(-- \s-1INTERNAL\s0 \s-1FUNCTION\s0" 4
.IX Item "_hashify( <scalar>|<arrayref> )  INTERNAL FUNCTION"
Returns a reference to a hash created from the scalar or array reference, 
where, for the scalar value, or each item in the array, there is a key
and it's value equal to that specific value.  Example, if you pass scalar
\&'3', the hash will be { 3 => 3 }.
.IP "_merge_hashes( <hashref>, <hashref> ) \*(-- \s-1INTERNAL\s0 \s-1FUNCTION\s0" 4
.IX Item "_merge_hashes( <hashref>, <hashref> )  INTERNAL FUNCTION"
Actually does the key-by-key evaluation of two hashes and returns 
the new merged hash.  Note that this recursively calls \f(CW\*(C`merge\*(C'\fR.
.IP "set_clone_behavior( <scalar> )" 4
.IX Item "set_clone_behavior( <scalar> )"
Sets how the data cloning is handled by Hash::Merge.  If this is true,
then data will be cloned; if false, then original data will be used
whenever possible.  By default, cloning is on (set to true).
.IP "get_clone_behavior( )" 4
.IX Item "get_clone_behavior( )"
Returns the current behavior for data cloning.
.IP "set_behavior( <scalar> )" 4
.IX Item "set_behavior( <scalar> )"
Specify which built-in behavior for merging that is desired.  The scalar
must be one of those given below.
.IP "get_behavior( )" 4
.IX Item "get_behavior( )"
Returns the behavior that is currently in use by Hash::Merge.
.IP "specify_behavior( <hashref>, [<name>] )" 4
.IX Item "specify_behavior( <hashref>, [<name>] )"
Specify a custom merge behavior for Hash::Merge.  This must be a hashref
defined with (at least) 3 keys, \s-1SCALAR\s0, \s-1ARRAY\s0, and \s-1HASH\s0; each of those
keys must have another hashref with (at least) the same 3 keys defined.
Furthermore, the values in those hashes must be coderefs.  These will be
called with two arguments, the left and right values for the merge.  
Your coderef should return either a scalar or an array or hash reference
as per your planned behavior.  If necessary, use the functions
_hashify and _merge_hashes as helper functions for these.  For example,
if you want to add the left \s-1SCALAR\s0 to the right \s-1ARRAY\s0, you can have your
behavior specification include:
.Sp
.Vb 1
\&   %spec = ( ...SCALAR => { ARRAY => sub { [ $_[0], @$_[1] ] }, ... } } );
.Ve
.Sp
Note that you can import _hashify and _merge_hashes into your program's
namespace with the 'custom' tag.
.SH "BUILT-IN BEHAVIORS"
.IX Header "BUILT-IN BEHAVIORS"
Here is the specifics on how the current internal behaviors are called, 
and what each does.  Assume that the left value is given as \f(CW$a\fR, and
the right as \f(CW$b\fR (these are either scalars or appropriate references)
.PP
.Vb 10
\&        LEFT TYPE   RIGHT TYPE      LEFT_PRECEDENT       RIGHT_PRECEDENT
\&         SCALAR      SCALAR            $a                   $b
\&         SCALAR      ARRAY             $a                   ( $a, @$b )
\&         SCALAR      HASH              $a                   %$b
\&         ARRAY       SCALAR            ( @$a, $b )          $b
\&         ARRAY       ARRAY             ( @$a, @$b )         ( @$a, @$b )
\&         ARRAY       HASH              ( @$a, values %$b )  %$b 
\&         HASH        SCALAR            %$a                  $b
\&         HASH        ARRAY             %$a                  ( values %$a, @$b )
\&         HASH        HASH              merge( %$a, %$b )    merge( %$a, %$b )
\&
\&        LEFT TYPE   RIGHT TYPE  STORAGE_PRECEDENT   RETAINMENT_PRECEDENT
\&         SCALAR      SCALAR     $a                  ( $a ,$b )
\&         SCALAR      ARRAY      ( $a, @$b )         ( $a, @$b )
\&         SCALAR      HASH       %$b                 merge( hashify( $a ), %$b )
\&         ARRAY       SCALAR     ( @$a, $b )         ( @$a, $b )
\&         ARRAY       ARRAY      ( @$a, @$b )        ( @$a, @$b )
\&         ARRAY       HASH       %$b                 merge( hashify( @$a ), %$b )
\&         HASH        SCALAR     %$a                 merge( %$a, hashify( $b ) )
\&         HASH        ARRAY      %$a                 merge( %$a, hashify( @$b ) )
\&         HASH        HASH       merge( %$a, %$b )   merge( %$a, %$b )
.Ve
.PP
(*) note that merge calls _merge_hashes, hashify calls _hashify.
.SH "CAVEATS"
.IX Header "CAVEATS"
This will not handle self\-referencing/recursion within hashes well.  
Plans for a future version include incorporate deep recursion protection.
.PP
As of Feb 16, 2002, ActiveState Perl's \s-1PPM\s0 of Clone.pm is only at
0.09.  This version does not support the cloning of scalars if passed
to the function.  This is fixed by 0.10 (and currently, Clone.pm is at
0.13).  So while most other users can upgrade their Clone.pm
appropriately (and I could put this as a requirement into the
Makefile.PL), those using ActiveState would lose out on the ability to
use this module.  (Clone.pm is not pure perl, so it's not simply a
matter of moving the newer file into place).  Thus, for the time
being, a check is done at the start of loading of this module to see
if a newer version of clone is around.  Then, all cloning calls have
been wrapped in the internal _my_clone function to block any scalar
clones if Clone.pm is too old.  However, this also prevents the
cloning of anything that isn't a hash or array under the same
conditions.  Once ActiveState updates their Clone, I'll remove this 
wrapper.
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael K. Neylon <mneylon\-pm@masemware.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2001,2002 Michael K. Neylon. All rights reserved.
.PP
This library is free software.  You can redistribute it and/or modify it 
under the same terms as Perl itself.
                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Hash::Merge5.18.3pm                          0100644 0001750 0001750 00000035045 12566242313 023647  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Hash::Merge 3"
.TH Hash::Merge 3 "2013-11-03" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Hash::Merge \- Merges arbitrarily deep hashes into a single hash
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&    use Hash::Merge qw( merge );
\&    my %a = ( 
\&                \*(Aqfoo\*(Aq    => 1,
\&            \*(Aqbar\*(Aq    => [ qw( a b e ) ],
\&            \*(Aqquerty\*(Aq => { \*(Aqbob\*(Aq => \*(Aqalice\*(Aq },
\&        );
\&    my %b = ( 
\&                \*(Aqfoo\*(Aq     => 2, 
\&                \*(Aqbar\*(Aq    => [ qw(c d) ],
\&                \*(Aqquerty\*(Aq => { \*(Aqted\*(Aq => \*(Aqmargeret\*(Aq }, 
\&        );
\&
\&    my %c = %{ merge( \e%a, \e%b ) };
\&
\&    Hash::Merge::set_behavior( \*(AqRIGHT_PRECEDENT\*(Aq );
\&
\&    # This is the same as above
\&
\&        Hash::Merge::specify_behavior(
\&            {
\&                        \*(AqSCALAR\*(Aq => {
\&                                \*(AqSCALAR\*(Aq => sub { $_[1] },
\&                                \*(AqARRAY\*(Aq  => sub { [ $_[0], @{$_[1]} ] },
\&                                \*(AqHASH\*(Aq   => sub { $_[1] },
\&                        },
\&                        \*(AqARRAY => {
\&                                \*(AqSCALAR\*(Aq => sub { $_[1] },
\&                                \*(AqARRAY\*(Aq  => sub { [ @{$_[0]}, @{$_[1]} ] },
\&                                \*(AqHASH\*(Aq   => sub { $_[1] }, 
\&                        },
\&                        \*(AqHASH\*(Aq => {
\&                                \*(AqSCALAR\*(Aq => sub { $_[1] },
\&                                \*(AqARRAY\*(Aq  => sub { [ values %{$_[0]}, @{$_[1]} ] },
\&                                \*(AqHASH\*(Aq   => sub { Hash::Merge::_merge_hashes( $_[0], $_[1] ) }, 
\&                        },
\&                }, 
\&                \*(AqMy Behavior\*(Aq, 
\&        );
\&        
\&        # Also there is OO interface.
\&        
\&        my $merge = Hash::Merge\->new( \*(AqLEFT_PRECEDENT\*(Aq );
\&        my %c = %{ $merge\->merge( \e%a, \e%b ) };
\&        
\&        # All behavioral changes (e.g. $merge\->set_behavior(...)), called on an object remain specific to that object
\&        # The legacy "Global Setting" behavior is respected only when new called as a non\-OO function.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Hash::Merge merges two arbitrarily deep hashes into a single hash.  That
is, at any level, it will add non-conflicting key-value pairs from one
hash to the other, and follows a set of specific rules when there are key
value conflicts (as outlined below).  The hash is followed recursively,
so that deeply nested hashes that are at the same level will be merged 
when the parent hashes are merged.  \fBPlease note that self-referencing
hashes, or recursive references, are not handled well by this method.\fR
.PP
Values in hashes are considered to be either \s-1ARRAY\s0 references, 
\&\s-1HASH\s0 references, or otherwise are treated as SCALARs.  By default, the 
data passed to the merge function will be cloned using the Clone module; 
however, if necessary, this behavior can be changed to use as many of 
the original values as possible.  (See \f(CW\*(C`set_clone_behavior\*(C'\fR).
.PP
Because there are a number of possible ways that one may want to merge
values when keys are conflicting, Hash::Merge provides several preset
methods for your convenience, as well as a way to define you own.  
These are (currently):
.IP "Left Precedence" 4
.IX Item "Left Precedence"
This is the default behavior.
.Sp
The values buried in the left hash will never
be lost; any values that can be added from the right hash will be
attempted.
.Sp
.Vb 4
\&   my $merge = Hash::Merge\->new();
\&   my $merge = Hash::Merge\->new(\*(AqLEFT_PRECEDENT\*(Aq);
\&   $merge\->set_set_behavior(\*(AqLEFT_PRECEDENT\*(Aq)
\&   Hash::Merge::set_set_behavior(\*(AqLEFT_PRECEDENT\*(Aq)
.Ve
.IP "Right Precedence" 4
.IX Item "Right Precedence"
Same as Left Precedence, but with the right
hash values never being lost
.Sp
.Vb 3
\&   my $merge = Hash::Merge\->new(\*(AqRIGHT_PRECEDENT\*(Aq);
\&   $merge\->set_set_behavior(\*(AqRIGHT_PRECEDENT\*(Aq)
\&   Hash::Merge::set_set_behavior(\*(AqRIGHT_PRECEDENT\*(Aq)
.Ve
.IP "Storage Precedence" 4
.IX Item "Storage Precedence"
If conflicting keys have two different
storage mediums, the 'bigger' medium will win; arrays are preferred over
scalars, hashes over either.  The other medium will try to be fitted in
the other, but if this isn't possible, the data is dropped.
.Sp
.Vb 3
\&   my $merge = Hash::Merge\->new(\*(AqSTORAGE_PRECEDENT\*(Aq);
\&   $merge\->set_set_behavior(\*(AqSTORAGE_PRECEDENT\*(Aq)
\&   Hash::Merge::set_set_behavior(\*(AqSTORAGE_PRECEDENT\*(Aq)
.Ve
.IP "Retainment Precedence" 4
.IX Item "Retainment Precedence"
No data will be lost; scalars will be joined
with arrays, and scalars and arrays will be 'hashified' to fit them into
a hash.
.Sp
.Vb 3
\&   my $merge = Hash::Merge\->new(\*(AqRETAINMENT_PRECEDENT\*(Aq);
\&   $merge\->set_set_behavior(\*(AqRETAINMENT_PRECEDENT\*(Aq)
\&   Hash::Merge::set_set_behavior(\*(AqRETAINMENT_PRECEDENT\*(Aq)
.Ve
.PP
Specific descriptions of how these work are detailed below.
.IP "merge ( <hashref>, <hashref> )" 4
.IX Item "merge ( <hashref>, <hashref> )"
Merges two hashes given the rules specified.  Returns a reference to 
the new hash.
.IP "_hashify( <scalar>|<arrayref> ) \*(-- \s-1INTERNAL FUNCTION\s0" 4
.IX Item "_hashify( <scalar>|<arrayref> ) INTERNAL FUNCTION"
Returns a reference to a hash created from the scalar or array reference, 
where, for the scalar value, or each item in the array, there is a key
and it's value equal to that specific value.  Example, if you pass scalar
\&'3', the hash will be { 3 => 3 }.
.IP "_merge_hashes( <hashref>, <hashref> ) \*(-- \s-1INTERNAL FUNCTION\s0" 4
.IX Item "_merge_hashes( <hashref>, <hashref> ) INTERNAL FUNCTION"
Actually does the key-by-key evaluation of two hashes and returns 
the new merged hash.  Note that this recursively calls \f(CW\*(C`merge\*(C'\fR.
.IP "set_clone_behavior( <scalar> )" 4
.IX Item "set_clone_behavior( <scalar> )"
Sets how the data cloning is handled by Hash::Merge.  If this is true,
then data will be cloned; if false, then original data will be used
whenever possible.  By default, cloning is on (set to true).
.IP "get_clone_behavior( )" 4
.IX Item "get_clone_behavior( )"
Returns the current behavior for data cloning.
.IP "set_behavior( <scalar> )" 4
.IX Item "set_behavior( <scalar> )"
Specify which built-in behavior for merging that is desired.  The scalar
must be one of those given below.
.IP "get_behavior( )" 4
.IX Item "get_behavior( )"
Returns the behavior that is currently in use by Hash::Merge.
.IP "specify_behavior( <hashref>, [<name>] )" 4
.IX Item "specify_behavior( <hashref>, [<name>] )"
Specify a custom merge behavior for Hash::Merge.  This must be a hashref
defined with (at least) 3 keys, \s-1SCALAR, ARRAY,\s0 and \s-1HASH\s0; each of those
keys must have another hashref with (at least) the same 3 keys defined.
Furthermore, the values in those hashes must be coderefs.  These will be
called with two arguments, the left and right values for the merge.  
Your coderef should return either a scalar or an array or hash reference
as per your planned behavior.  If necessary, use the functions
_hashify and _merge_hashes as helper functions for these.  For example,
if you want to add the left \s-1SCALAR\s0 to the right \s-1ARRAY,\s0 you can have your
behavior specification include:
.Sp
.Vb 1
\&   %spec = ( ...SCALAR => { ARRAY => sub { [ $_[0], @$_[1] ] }, ... } } );
.Ve
.Sp
Note that you can import _hashify and _merge_hashes into your program's
namespace with the 'custom' tag.
.SH "BUILT-IN BEHAVIORS"
.IX Header "BUILT-IN BEHAVIORS"
Here is the specifics on how the current internal behaviors are called, 
and what each does.  Assume that the left value is given as \f(CW$a\fR, and
the right as \f(CW$b\fR (these are either scalars or appropriate references)
.PP
.Vb 10
\&        LEFT TYPE   RIGHT TYPE      LEFT_PRECEDENT       RIGHT_PRECEDENT
\&         SCALAR      SCALAR            $a                   $b
\&         SCALAR      ARRAY             $a                   ( $a, @$b )
\&         SCALAR      HASH              $a                   %$b
\&         ARRAY       SCALAR            ( @$a, $b )          $b
\&         ARRAY       ARRAY             ( @$a, @$b )         ( @$a, @$b )
\&         ARRAY       HASH              ( @$a, values %$b )  %$b 
\&         HASH        SCALAR            %$a                  $b
\&         HASH        ARRAY             %$a                  ( values %$a, @$b )
\&         HASH        HASH              merge( %$a, %$b )    merge( %$a, %$b )
\&
\&        LEFT TYPE   RIGHT TYPE  STORAGE_PRECEDENT   RETAINMENT_PRECEDENT
\&         SCALAR      SCALAR     $a                  ( $a ,$b )
\&         SCALAR      ARRAY      ( $a, @$b )         ( $a, @$b )
\&         SCALAR      HASH       %$b                 merge( hashify( $a ), %$b )
\&         ARRAY       SCALAR     ( @$a, $b )         ( @$a, $b )
\&         ARRAY       ARRAY      ( @$a, @$b )        ( @$a, @$b )
\&         ARRAY       HASH       %$b                 merge( hashify( @$a ), %$b )
\&         HASH        SCALAR     %$a                 merge( %$a, hashify( $b ) )
\&         HASH        ARRAY      %$a                 merge( %$a, hashify( @$b ) )
\&         HASH        HASH       merge( %$a, %$b )   merge( %$a, %$b )
.Ve
.PP
(*) note that merge calls _merge_hashes, hashify calls _hashify.
.SH "CAVEATS"
.IX Header "CAVEATS"
This will not handle self\-referencing/recursion within hashes well.  
Plans for a future version include incorporate deep recursion protection.
.PP
As of Feb 16, 2002, ActiveState Perl's \s-1PPM\s0 of Clone.pm is only at
0.09.  This version does not support the cloning of scalars if passed
to the function.  This is fixed by 0.10 (and currently, Clone.pm is at
0.13).  So while most other users can upgrade their Clone.pm
appropriately (and I could put this as a requirement into the
Makefile.PL), those using ActiveState would lose out on the ability to
use this module.  (Clone.pm is not pure perl, so it's not simply a
matter of moving the newer file into place).  Thus, for the time
being, a check is done at the start of loading of this module to see
if a newer version of clone is around.  Then, all cloning calls have
been wrapped in the internal _my_clone function to block any scalar
clones if Clone.pm is too old.  However, this also prevents the
cloning of anything that isn't a hash or array under the same
conditions.  Once ActiveState updates their Clone, I'll remove this 
wrapper.
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael K. Neylon <mneylon\-pm@masemware.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2001,2002 Michael K. Neylon. All rights reserved.
.PP
This library is free software.  You can redistribute it and/or modify it 
under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Hash::Util.3pm                               0100644 0001750 0001750 00000047136 12566207455 023225  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Hash::Util 3pm"
.TH Hash::Util 3pm "2013-11-14" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Hash::Util \- A selection of general\-utility hash subroutines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # Restricted hashes
\&
\&  use Hash::Util qw(
\&                     fieldhash fieldhashes
\&
\&                     all_keys
\&                     lock_keys unlock_keys
\&                     lock_value unlock_value
\&                     lock_hash unlock_hash
\&                     lock_keys_plus
\&                     hash_locked hash_unlocked
\&                     hashref_locked hashref_unlocked
\&                     hidden_keys legal_keys
\&
\&                     lock_ref_keys unlock_ref_keys
\&                     lock_ref_value unlock_ref_value
\&                     lock_hashref unlock_hashref
\&                     lock_ref_keys_plus
\&                     hidden_ref_keys legal_ref_keys
\&
\&                     hash_seed hash_value hv_store
\&                     bucket_stats bucket_info bucket_array
\&                     lock_hash_recurse unlock_hash_recurse
\&
\&                     hash_traversal_mask
\&                   );
\&
\&  %hash = (foo => 42, bar => 23);
\&  # Ways to restrict a hash
\&  lock_keys(%hash);
\&  lock_keys(%hash, @keyset);
\&  lock_keys_plus(%hash, @additional_keys);
\&
\&  # Ways to inspect the properties of a restricted hash
\&  my @legal = legal_keys(%hash);
\&  my @hidden = hidden_keys(%hash);
\&  my $ref = all_keys(%hash,@keys,@hidden);
\&  my $is_locked = hash_locked(%hash);
\&
\&  # Remove restrictions on the hash
\&  unlock_keys(%hash);
\&
\&  # Lock individual values in a hash
\&  lock_value  (%hash, \*(Aqfoo\*(Aq);
\&  unlock_value(%hash, \*(Aqfoo\*(Aq);
\&
\&  # Ways to change the restrictions on both keys and values
\&  lock_hash  (%hash);
\&  unlock_hash(%hash);
\&
\&  my $hashes_are_randomised = hash_seed() != 0;
\&
\&  my $int_hash_value = hash_value( \*(Aqstring\*(Aq );
\&
\&  my $mask= hash_traversal_mask(%hash);
\&
\&  hash_traversal_mask(%hash,1234);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Hash::Util\*(C'\fR and \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR contain special functions
for manipulating hashes that don't really warrant a keyword.
.PP
\&\f(CW\*(C`Hash::Util\*(C'\fR contains a set of functions that support
restricted hashes. These are described in
this document.  \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR contains an (unrelated)
set of functions that support the use of hashes in
\&\fIinside-out classes\fR, described in Hash::Util::FieldHash.
.PP
By default \f(CW\*(C`Hash::Util\*(C'\fR does not export anything.
.SS "Restricted hashes"
.IX Subsection "Restricted hashes"
5.8.0 introduces the ability to restrict a hash to a certain set of
keys.  No keys outside of this set can be added.  It also introduces
the ability to lock an individual key so it cannot be deleted and the
ability to ensure that an individual value cannot be changed.
.PP
This is intended to largely replace the deprecated pseudo-hashes.
.IP "\fBlock_keys\fR" 4
.IX Item "lock_keys"
.PD 0
.IP "\fBunlock_keys\fR" 4
.IX Item "unlock_keys"
.PD
.Vb 2
\&  lock_keys(%hash);
\&  lock_keys(%hash, @keys);
.Ve
.Sp
Restricts the given \f(CW%hash\fR's set of keys to \f(CW@keys\fR.  If \f(CW@keys\fR is not
given it restricts it to its current keyset.  No more keys can be
added. \fIdelete()\fR and \fIexists()\fR will still work, but will not alter
the set of allowed keys. \fBNote\fR: the current implementation prevents
the hash from being \fIbless()\fRed while it is in a locked state. Any attempt
to do so will raise an exception. Of course you can still \fIbless()\fR
the hash before you call \fIlock_keys()\fR so this shouldn't be a problem.
.Sp
.Vb 1
\&  unlock_keys(%hash);
.Ve
.Sp
Removes the restriction on the \f(CW%hash\fR's keyset.
.Sp
\&\fBNote\fR that if any of the values of the hash have been locked they will not
be unlocked after this sub executes.
.Sp
Both routines return a reference to the hash operated on.
.IP "\fBlock_keys_plus\fR" 4
.IX Item "lock_keys_plus"
.Vb 1
\&  lock_keys_plus(%hash,@additional_keys)
.Ve
.Sp
Similar to \f(CW\*(C`lock_keys()\*(C'\fR, with the difference being that the optional key list
specifies keys that may or may not be already in the hash. Essentially this is
an easier way to say
.Sp
.Vb 1
\&  lock_keys(%hash,@additional_keys,keys %hash);
.Ve
.Sp
Returns a reference to \f(CW%hash\fR
.IP "\fBlock_value\fR" 4
.IX Item "lock_value"
.PD 0
.IP "\fBunlock_value\fR" 4
.IX Item "unlock_value"
.PD
.Vb 2
\&  lock_value  (%hash, $key);
\&  unlock_value(%hash, $key);
.Ve
.Sp
Locks and unlocks the value for an individual key of a hash.  The value of a
locked key cannot be changed.
.Sp
Unless \f(CW%hash\fR has already been locked the key/value could be deleted
regardless of this setting.
.Sp
Returns a reference to the \f(CW%hash\fR.
.IP "\fBlock_hash\fR" 4
.IX Item "lock_hash"
.PD 0
.IP "\fBunlock_hash\fR" 4
.IX Item "unlock_hash"
.PD
.Vb 1
\&    lock_hash(%hash);
.Ve
.Sp
\&\fIlock_hash()\fR locks an entire hash, making all keys and values read-only.
No value can be changed, no keys can be added or deleted.
.Sp
.Vb 1
\&    unlock_hash(%hash);
.Ve
.Sp
\&\fIunlock_hash()\fR does the opposite of \fIlock_hash()\fR.  All keys and values
are made writable.  All values can be changed and keys can be added
and deleted.
.Sp
Returns a reference to the \f(CW%hash\fR.
.IP "\fBlock_hash_recurse\fR" 4
.IX Item "lock_hash_recurse"
.PD 0
.IP "\fBunlock_hash_recurse\fR" 4
.IX Item "unlock_hash_recurse"
.PD
.Vb 1
\&    lock_hash_recurse(%hash);
.Ve
.Sp
\&\fIlock_hash()\fR locks an entire hash and any hashes it references recursively,
making all keys and values read-only. No value can be changed, no keys can
be added or deleted.
.Sp
This method \fBonly\fR recurses into hashes that are referenced by another hash.
Thus a Hash of Hashes (HoH) will all be restricted, but a Hash of Arrays of
Hashes (HoAoH) will only have the top hash restricted.
.Sp
.Vb 1
\&    unlock_hash_recurse(%hash);
.Ve
.Sp
\&\fIunlock_hash_recurse()\fR does the opposite of \fIlock_hash_recurse()\fR.  All keys and
values are made writable.  All values can be changed and keys can be added
and deleted. Identical recursion restrictions apply as to \fIlock_hash_recurse()\fR.
.Sp
Returns a reference to the \f(CW%hash\fR.
.IP "\fBhashref_locked\fR" 4
.IX Item "hashref_locked"
.PD 0
.IP "\fBhash_locked\fR" 4
.IX Item "hash_locked"
.PD
.Vb 2
\&  hashref_locked(\e%hash) and print "Hash is locked!\en";
\&  hash_locked(%hash) and print "Hash is locked!\en";
.Ve
.Sp
Returns true if the hash and its keys are locked.
.IP "\fBhashref_unlocked\fR" 4
.IX Item "hashref_unlocked"
.PD 0
.IP "\fBhash_unlocked\fR" 4
.IX Item "hash_unlocked"
.PD
.Vb 2
\&  hashref_unlocked(\e%hash) and print "Hash is unlocked!\en";
\&  hash_unlocked(%hash) and print "Hash is unlocked!\en";
.Ve
.Sp
Returns true if the hash and its keys are unlocked.
.IP "\fBlegal_keys\fR" 4
.IX Item "legal_keys"
.Vb 1
\&  my @keys = legal_keys(%hash);
.Ve
.Sp
Returns the list of the keys that are legal in a restricted hash.
In the case of an unrestricted hash this is identical to calling
keys(%hash).
.IP "\fBhidden_keys\fR" 4
.IX Item "hidden_keys"
.Vb 1
\&  my @keys = hidden_keys(%hash);
.Ve
.Sp
Returns the list of the keys that are legal in a restricted hash but
do not have a value associated to them. Thus if 'foo' is a
\&\*(L"hidden\*(R" key of the \f(CW%hash\fR it will return false for both \f(CW\*(C`defined\*(C'\fR
and \f(CW\*(C`exists\*(C'\fR tests.
.Sp
In the case of an unrestricted hash this will return an empty list.
.Sp
\&\fB\s-1NOTE\s0\fR this is an experimental feature that is heavily dependent
on the current implementation of restricted hashes. Should the
implementation change, this routine may become meaningless, in which
case it will return an empty list.
.IP "\fBall_keys\fR" 4
.IX Item "all_keys"
.Vb 1
\&  all_keys(%hash,@keys,@hidden);
.Ve
.Sp
Populates the arrays \f(CW@keys\fR with the all the keys that would pass
an \f(CW\*(C`exists\*(C'\fR tests, and populates \f(CW@hidden\fR with the remaining legal
keys that have not been utilized.
.Sp
Returns a reference to the hash.
.Sp
In the case of an unrestricted hash this will be equivalent to
.Sp
.Vb 5
\&  $ref = do {
\&      @keys = keys %hash;
\&      @hidden = ();
\&      \e%hash
\&  };
.Ve
.Sp
\&\fB\s-1NOTE\s0\fR this is an experimental feature that is heavily dependent
on the current implementation of restricted hashes. Should the
implementation change this routine may become meaningless in which
case it will behave identically to how it would behave on an
unrestricted hash.
.IP "\fBhash_seed\fR" 4
.IX Item "hash_seed"
.Vb 1
\&    my $hash_seed = hash_seed();
.Ve
.Sp
\&\fIhash_seed()\fR returns the seed bytes used to randomise hash ordering.
.Sp
\&\fBNote that the hash seed is sensitive information\fR: by knowing it one
can craft a denial-of-service attack against Perl code, even remotely,
see \*(L"Algorithmic Complexity Attacks\*(R" in perlsec for more information.
\&\fBDo not disclose the hash seed\fR to people who don't need to know it.
See also \*(L"\s-1PERL_HASH_SEED_DEBUG\*(R"\s0 in perlrun.
.Sp
Prior to Perl 5.17.6 this function returned a \s-1UV,\s0 it now returns a string,
which may be of nearly any size as determined by the hash function your
Perl has been built with. Possible sizes may be but are not limited to
4 bytes (for most hash algorithms) and 16 bytes (for siphash).
.IP "\fBhash_value\fR" 4
.IX Item "hash_value"
.Vb 1
\&    my $hash_value = hash_value($string);
.Ve
.Sp
\&\fIhash_value()\fR returns the current perl's internal hash value for a given
string.
.Sp
Returns a 32 bit integer representing the hash value of the string passed
in. This value is only reliable for the lifetime of the process. It may
be different depending on invocation, environment variables,  perl version,
architectures, and build options.
.Sp
\&\fBNote that the hash value of a given string is sensitive information\fR:
by knowing it one can deduce the hash seed which in turn can allow one to
craft a denial-of-service attack against Perl code, even remotely,
see \*(L"Algorithmic Complexity Attacks\*(R" in perlsec for more information.
\&\fBDo not disclose the hash value of a string\fR to people who don't need to
know it. See also \*(L"\s-1PERL_HASH_SEED_DEBUG\*(R"\s0 in perlrun.
.IP "\fBbucket_info\fR" 4
.IX Item "bucket_info"
Return a set of basic information about a hash.
.Sp
.Vb 1
\&    my ($keys, $buckets, $used, @length_counts)= bucket_info($hash);
.Ve
.Sp
Fields are as follows:
.Sp
.Vb 5
\&    0: Number of keys in the hash
\&    1: Number of buckets in the hash
\&    2: Number of used buckets in the hash
\&    rest : list of counts, Kth element is the number of buckets
\&           with K keys in it.
.Ve
.Sp
See also \fIbucket_stats()\fR and \fIbucket_array()\fR.
.IP "\fBbucket_stats\fR" 4
.IX Item "bucket_stats"
Returns a list of statistics about a hash.
.Sp
.Vb 2
\&    my ($keys, buckets, $used, $utilization_ratio, $collision_pct,
\&        $mean, $stddev, @length_counts) = bucket_info($hashref);
.Ve
.Sp
Fields are as follows:
.Sp
.Vb 10
\&    0: Number of keys in the hash
\&    1: Number of buckets in the hash
\&    2: Number of used buckets in the hash
\&    3: Hash Quality Score
\&    4: Percent of buckets used
\&    5: Percent of keys which are in collision
\&    6: Average bucket length
\&    7: Standard Deviation of bucket lengths.
\&    rest : list of counts, Kth element is the number of buckets
\&           with K keys in it.
.Ve
.Sp
See also \fIbucket_info()\fR and \fIbucket_array()\fR.
.Sp
Note that Hash Quality Score would be 1 for an ideal hash, numbers
close to and below 1 indicate good hashing, and number significantly
above indicate a poor score. In practice it should be around 0.95 to 1.05.
It is defined as:
.Sp
.Vb 4
\& $score= sum( $count[$length] * ($length * ($length + 1) / 2) )
\&            /
\&            ( ( $keys / 2 * $buckets ) *
\&              ( $keys + ( 2 * $buckets ) \- 1 ) )
.Ve
.Sp
The formula is from the Red Dragon book (reformulated to use the data available)
and is documented at <http://www.strchr.com/hash_functions>
.IP "\fBbucket_array\fR" 4
.IX Item "bucket_array"
.Vb 1
\&    my $array= bucket_array(\e%hash);
.Ve
.Sp
Returns a packed representation of the bucket array associated with a hash. Each element
of the array is either an integer K, in which case it represents K empty buckets, or
a reference to another array which contains the keys that are in that bucket.
.Sp
\&\fBNote that the information returned by bucket_array is sensitive information\fR:
by knowing it one can directly attack perl's hash function which in turn may allow
one to craft a denial-of-service attack against Perl code, even remotely,
see \*(L"Algorithmic Complexity Attacks\*(R" in perlsec for more information.
\&\fBDo not disclose the output of this function\fR to people who don't need to
know it. See also \*(L"\s-1PERL_HASH_SEED_DEBUG\*(R"\s0 in perlrun. This function is provided strictly
for  debugging and diagnostics purposes only, it is hard to imagine a reason why it
would be used in production code.
.IP "\fBhv_store\fR" 4
.IX Item "hv_store"
.Vb 4
\&  my $sv = 0;
\&  hv_store(%hash,$key,$sv) or die "Failed to alias!";
\&  $hash{$key} = 1;
\&  print $sv; # prints 1
.Ve
.Sp
Stores an alias to a variable in a hash instead of copying the value.
.IP "\fBhash_traversal_mask\fR" 4
.IX Item "hash_traversal_mask"
As of Perl 5.18 every hash has its own hash traversal order, and this order
changes every time a new element is inserted into the hash. This functionality
is provided by maintaining an unsigned integer mask (U32) which is xor'ed
with the actual bucket id during a traversal of the hash buckets using \fIkeys()\fR,
\&\fIvalues()\fR or \fIeach()\fR.
.Sp
You can use this subroutine to get and set the traversal mask for a specific
hash. Setting the mask ensures that a given hash will produce the same key
order. \fBNote\fR that this does \fBnot\fR guarantee that \fBtwo\fR hashes will produce
the same key order for the same hash seed and traversal mask, items that
collide into one bucket may have different orders regardless of this setting.
.SS "Operating on references to hashes."
.IX Subsection "Operating on references to hashes."
Most subroutines documented in this module have equivalent versions
that operate on references to hashes instead of native hashes.
The following is a list of these subs. They are identical except
in name and in that instead of taking a \f(CW%hash\fR they take a \f(CW$hashref\fR,
and additionally are not prototyped.
.IP "lock_ref_keys" 4
.IX Item "lock_ref_keys"
.PD 0
.IP "unlock_ref_keys" 4
.IX Item "unlock_ref_keys"
.IP "lock_ref_keys_plus" 4
.IX Item "lock_ref_keys_plus"
.IP "lock_ref_value" 4
.IX Item "lock_ref_value"
.IP "unlock_ref_value" 4
.IX Item "unlock_ref_value"
.IP "lock_hashref" 4
.IX Item "lock_hashref"
.IP "unlock_hashref" 4
.IX Item "unlock_hashref"
.IP "lock_hashref_recurse" 4
.IX Item "lock_hashref_recurse"
.IP "unlock_hashref_recurse" 4
.IX Item "unlock_hashref_recurse"
.IP "hash_ref_unlocked" 4
.IX Item "hash_ref_unlocked"
.IP "legal_ref_keys" 4
.IX Item "legal_ref_keys"
.IP "hidden_ref_keys" 4
.IX Item "hidden_ref_keys"
.PD
.SH "CAVEATS"
.IX Header "CAVEATS"
Note that the trapping of the restricted operations is not atomic:
for example
.PP
.Vb 1
\&    eval { %hash = (illegal_key => 1) }
.Ve
.PP
leaves the \f(CW%hash\fR empty rather than with its original contents.
.SH "BUGS"
.IX Header "BUGS"
The interface exposed by this module is very close to the current
implementation of restricted hashes. Over time it is expected that
this behavior will be extended and the interface abstracted further.
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael G Schwern <schwern@pobox.com> on top of code by Nick
Ing-Simmons and Jeffrey Friedl.
.PP
\&\fIhv_store()\fR is from Array::RefElem, Copyright 2000 Gisle Aas.
.PP
Additional code by Yves Orton.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Scalar::Util, List::Util and \*(L"Algorithmic Complexity Attacks\*(R" in perlsec.
.PP
Hash::Util::FieldHash.
                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Hash::Util5.16.3pm                           0100644 0001750 0001750 00000033260 12566207434 023525  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Hash::Util 3pm"
.TH Hash::Util 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Hash::Util \- A selection of general\-utility hash subroutines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # Restricted hashes
\&
\&  use Hash::Util qw(
\&                     hash_seed all_keys
\&                     lock_keys unlock_keys
\&                     lock_value unlock_value
\&                     lock_hash unlock_hash
\&                     lock_keys_plus hash_locked
\&                     hidden_keys legal_keys
\&                   );
\&
\&  %hash = (foo => 42, bar => 23);
\&  # Ways to restrict a hash
\&  lock_keys(%hash);
\&  lock_keys(%hash, @keyset);
\&  lock_keys_plus(%hash, @additional_keys);
\&
\&  # Ways to inspect the properties of a restricted hash
\&  my @legal = legal_keys(%hash);
\&  my @hidden = hidden_keys(%hash);
\&  my $ref = all_keys(%hash,@keys,@hidden);
\&  my $is_locked = hash_locked(%hash);
\&
\&  # Remove restrictions on the hash
\&  unlock_keys(%hash);
\&
\&  # Lock individual values in a hash
\&  lock_value  (%hash, \*(Aqfoo\*(Aq);
\&  unlock_value(%hash, \*(Aqfoo\*(Aq);
\&
\&  # Ways to change the restrictions on both keys and values
\&  lock_hash  (%hash);
\&  unlock_hash(%hash);
\&
\&  my $hashes_are_randomised = hash_seed() != 0;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Hash::Util\*(C'\fR and \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR contain special functions
for manipulating hashes that don't really warrant a keyword.
.PP
\&\f(CW\*(C`Hash::Util\*(C'\fR contains a set of functions that support
restricted hashes. These are described in
this document.  \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR contains an (unrelated)
set of functions that support the use of hashes in
\&\fIinside-out classes\fR, described in Hash::Util::FieldHash.
.PP
By default \f(CW\*(C`Hash::Util\*(C'\fR does not export anything.
.SS "Restricted hashes"
.IX Subsection "Restricted hashes"
5.8.0 introduces the ability to restrict a hash to a certain set of
keys.  No keys outside of this set can be added.  It also introduces
the ability to lock an individual key so it cannot be deleted and the
ability to ensure that an individual value cannot be changed.
.PP
This is intended to largely replace the deprecated pseudo-hashes.
.IP "\fBlock_keys\fR" 4
.IX Item "lock_keys"
.PD 0
.IP "\fBunlock_keys\fR" 4
.IX Item "unlock_keys"
.PD
.Vb 2
\&  lock_keys(%hash);
\&  lock_keys(%hash, @keys);
.Ve
.Sp
Restricts the given \f(CW%hash\fR's set of keys to \f(CW@keys\fR.  If \f(CW@keys\fR is not
given it restricts it to its current keyset.  No more keys can be
added. \fIdelete()\fR and \fIexists()\fR will still work, but will not alter
the set of allowed keys. \fBNote\fR: the current implementation prevents
the hash from being \fIbless()\fRed while it is in a locked state. Any attempt
to do so will raise an exception. Of course you can still \fIbless()\fR
the hash before you call \fIlock_keys()\fR so this shouldn't be a problem.
.Sp
.Vb 1
\&  unlock_keys(%hash);
.Ve
.Sp
Removes the restriction on the \f(CW%hash\fR's keyset.
.Sp
\&\fBNote\fR that if any of the values of the hash have been locked they will not be unlocked
after this sub executes.
.Sp
Both routines return a reference to the hash operated on.
.IP "\fBlock_keys_plus\fR" 4
.IX Item "lock_keys_plus"
.Vb 1
\&  lock_keys_plus(%hash,@additional_keys)
.Ve
.Sp
Similar to \f(CW\*(C`lock_keys()\*(C'\fR, with the difference being that the optional key list
specifies keys that may or may not be already in the hash. Essentially this is
an easier way to say
.Sp
.Vb 1
\&  lock_keys(%hash,@additional_keys,keys %hash);
.Ve
.Sp
Returns a reference to \f(CW%hash\fR
.IP "\fBlock_value\fR" 4
.IX Item "lock_value"
.PD 0
.IP "\fBunlock_value\fR" 4
.IX Item "unlock_value"
.PD
.Vb 2
\&  lock_value  (%hash, $key);
\&  unlock_value(%hash, $key);
.Ve
.Sp
Locks and unlocks the value for an individual key of a hash.  The value of a
locked key cannot be changed.
.Sp
Unless \f(CW%hash\fR has already been locked the key/value could be deleted
regardless of this setting.
.Sp
Returns a reference to the \f(CW%hash\fR.
.IP "\fBlock_hash\fR" 4
.IX Item "lock_hash"
.PD 0
.IP "\fBunlock_hash\fR" 4
.IX Item "unlock_hash"
.PD
.Vb 1
\&    lock_hash(%hash);
.Ve
.Sp
\&\fIlock_hash()\fR locks an entire hash, making all keys and values read-only.
No value can be changed, no keys can be added or deleted.
.Sp
.Vb 1
\&    unlock_hash(%hash);
.Ve
.Sp
\&\fIunlock_hash()\fR does the opposite of \fIlock_hash()\fR.  All keys and values
are made writable.  All values can be changed and keys can be added
and deleted.
.Sp
Returns a reference to the \f(CW%hash\fR.
.IP "\fBlock_hash_recurse\fR" 4
.IX Item "lock_hash_recurse"
.PD 0
.IP "\fBunlock_hash_recurse\fR" 4
.IX Item "unlock_hash_recurse"
.PD
.Vb 1
\&    lock_hash_recurse(%hash);
.Ve
.Sp
\&\fIlock_hash()\fR locks an entire hash and any hashes it references recursively,
making all keys and values read-only. No value can be changed, no keys can
be added or deleted.
.Sp
\&\fBOnly\fR recurses into hashes that are referenced by another hash. Thus a
Hash of Hashes (HoH) will all be restricted, but a Hash of Arrays of Hashes
(HoAoH) will only have the top hash restricted.
.Sp
.Vb 1
\&    unlock_hash_recurse(%hash);
.Ve
.Sp
\&\fIunlock_hash_recurse()\fR does the opposite of \fIlock_hash_recurse()\fR.  All keys and
values are made writable.  All values can be changed and keys can be added
and deleted. Identical recursion restrictions apply as to \fIlock_hash_recurse()\fR.
.Sp
Returns a reference to the \f(CW%hash\fR.
.IP "\fBhash_unlocked\fR" 4
.IX Item "hash_unlocked"
.Vb 1
\&  hash_unlocked(%hash) and print "Hash is unlocked!\en";
.Ve
.Sp
Returns true if the hash and its keys are unlocked.
.IP "\fBlegal_keys\fR" 4
.IX Item "legal_keys"
.Vb 1
\&  my @keys = legal_keys(%hash);
.Ve
.Sp
Returns the list of the keys that are legal in a restricted hash.
In the case of an unrestricted hash this is identical to calling
keys(%hash).
.IP "\fBhidden_keys\fR" 4
.IX Item "hidden_keys"
.Vb 1
\&  my @keys = hidden_keys(%hash);
.Ve
.Sp
Returns the list of the keys that are legal in a restricted hash but
do not have a value associated to them. Thus if 'foo' is a
\&\*(L"hidden\*(R" key of the \f(CW%hash\fR it will return false for both \f(CW\*(C`defined\*(C'\fR
and \f(CW\*(C`exists\*(C'\fR tests.
.Sp
In the case of an unrestricted hash this will return an empty list.
.Sp
\&\fB\s-1NOTE\s0\fR this is an experimental feature that is heavily dependent
on the current implementation of restricted hashes. Should the
implementation change, this routine may become meaningless, in which
case it will return an empty list.
.IP "\fBall_keys\fR" 4
.IX Item "all_keys"
.Vb 1
\&  all_keys(%hash,@keys,@hidden);
.Ve
.Sp
Populates the arrays \f(CW@keys\fR with the all the keys that would pass
an \f(CW\*(C`exists\*(C'\fR tests, and populates \f(CW@hidden\fR with the remaining legal
keys that have not been utilized.
.Sp
Returns a reference to the hash.
.Sp
In the case of an unrestricted hash this will be equivalent to
.Sp
.Vb 5
\&  $ref = do {
\&      @keys = keys %hash;
\&      @hidden = ();
\&      \e%hash
\&  };
.Ve
.Sp
\&\fB\s-1NOTE\s0\fR this is an experimental feature that is heavily dependent
on the current implementation of restricted hashes. Should the
implementation change this routine may become meaningless in which
case it will behave identically to how it would behave on an
unrestricted hash.
.IP "\fBhash_seed\fR" 4
.IX Item "hash_seed"
.Vb 1
\&    my $hash_seed = hash_seed();
.Ve
.Sp
\&\fIhash_seed()\fR returns the seed number used to randomise hash ordering.
Zero means the \*(L"traditional\*(R" random hash ordering, non-zero means the
new even more random hash ordering introduced in Perl 5.8.1.
.Sp
\&\fBNote that the hash seed is sensitive information\fR: by knowing it one
can craft a denial-of-service attack against Perl code, even remotely,
see \*(L"Algorithmic Complexity Attacks\*(R" in perlsec for more information.
\&\fBDo not disclose the hash seed\fR to people who don't need to know it.
See also \*(L"\s-1PERL_HASH_SEED_DEBUG\s0\*(R" in perlrun.
.IP "\fBhv_store\fR" 4
.IX Item "hv_store"
.Vb 4
\&  my $sv = 0;
\&  hv_store(%hash,$key,$sv) or die "Failed to alias!";
\&  $hash{$key} = 1;
\&  print $sv; # prints 1
.Ve
.Sp
Stores an alias to a variable in a hash instead of copying the value.
.SS "Operating on references to hashes."
.IX Subsection "Operating on references to hashes."
Most subroutines documented in this module have equivalent versions
that operate on references to hashes instead of native hashes.
The following is a list of these subs. They are identical except
in name and in that instead of taking a \f(CW%hash\fR they take a \f(CW$hashref\fR,
and additionally are not prototyped.
.IP "lock_ref_keys" 4
.IX Item "lock_ref_keys"
.PD 0
.IP "unlock_ref_keys" 4
.IX Item "unlock_ref_keys"
.IP "lock_ref_keys_plus" 4
.IX Item "lock_ref_keys_plus"
.IP "lock_ref_value" 4
.IX Item "lock_ref_value"
.IP "unlock_ref_value" 4
.IX Item "unlock_ref_value"
.IP "lock_hashref" 4
.IX Item "lock_hashref"
.IP "unlock_hashref" 4
.IX Item "unlock_hashref"
.IP "lock_hashref_recurse" 4
.IX Item "lock_hashref_recurse"
.IP "unlock_hashref_recurse" 4
.IX Item "unlock_hashref_recurse"
.IP "hash_ref_unlocked" 4
.IX Item "hash_ref_unlocked"
.IP "legal_ref_keys" 4
.IX Item "legal_ref_keys"
.IP "hidden_ref_keys" 4
.IX Item "hidden_ref_keys"
.PD
.SH "CAVEATS"
.IX Header "CAVEATS"
Note that the trapping of the restricted operations is not atomic:
for example
.PP
.Vb 1
\&    eval { %hash = (illegal_key => 1) }
.Ve
.PP
leaves the \f(CW%hash\fR empty rather than with its original contents.
.SH "BUGS"
.IX Header "BUGS"
The interface exposed by this module is very close to the current
implementation of restricted hashes. Over time it is expected that
this behavior will be extended and the interface abstracted further.
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael G Schwern <schwern@pobox.com> on top of code by Nick
Ing-Simmons and Jeffrey Friedl.
.PP
\&\fIhv_store()\fR is from Array::RefElem, Copyright 2000 Gisle Aas.
.PP
Additional code by Yves Orton.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Scalar::Util, List::Util and \*(L"Algorithmic Complexity Attacks\*(R" in perlsec.
.PP
Hash::Util::FieldHash.
                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Hash::Util5.18.3pm                           0100644 0001750 0001750 00000047136 12566207455 023541  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Hash::Util 3pm"
.TH Hash::Util 3pm "2013-11-14" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Hash::Util \- A selection of general\-utility hash subroutines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # Restricted hashes
\&
\&  use Hash::Util qw(
\&                     fieldhash fieldhashes
\&
\&                     all_keys
\&                     lock_keys unlock_keys
\&                     lock_value unlock_value
\&                     lock_hash unlock_hash
\&                     lock_keys_plus
\&                     hash_locked hash_unlocked
\&                     hashref_locked hashref_unlocked
\&                     hidden_keys legal_keys
\&
\&                     lock_ref_keys unlock_ref_keys
\&                     lock_ref_value unlock_ref_value
\&                     lock_hashref unlock_hashref
\&                     lock_ref_keys_plus
\&                     hidden_ref_keys legal_ref_keys
\&
\&                     hash_seed hash_value hv_store
\&                     bucket_stats bucket_info bucket_array
\&                     lock_hash_recurse unlock_hash_recurse
\&
\&                     hash_traversal_mask
\&                   );
\&
\&  %hash = (foo => 42, bar => 23);
\&  # Ways to restrict a hash
\&  lock_keys(%hash);
\&  lock_keys(%hash, @keyset);
\&  lock_keys_plus(%hash, @additional_keys);
\&
\&  # Ways to inspect the properties of a restricted hash
\&  my @legal = legal_keys(%hash);
\&  my @hidden = hidden_keys(%hash);
\&  my $ref = all_keys(%hash,@keys,@hidden);
\&  my $is_locked = hash_locked(%hash);
\&
\&  # Remove restrictions on the hash
\&  unlock_keys(%hash);
\&
\&  # Lock individual values in a hash
\&  lock_value  (%hash, \*(Aqfoo\*(Aq);
\&  unlock_value(%hash, \*(Aqfoo\*(Aq);
\&
\&  # Ways to change the restrictions on both keys and values
\&  lock_hash  (%hash);
\&  unlock_hash(%hash);
\&
\&  my $hashes_are_randomised = hash_seed() != 0;
\&
\&  my $int_hash_value = hash_value( \*(Aqstring\*(Aq );
\&
\&  my $mask= hash_traversal_mask(%hash);
\&
\&  hash_traversal_mask(%hash,1234);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Hash::Util\*(C'\fR and \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR contain special functions
for manipulating hashes that don't really warrant a keyword.
.PP
\&\f(CW\*(C`Hash::Util\*(C'\fR contains a set of functions that support
restricted hashes. These are described in
this document.  \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR contains an (unrelated)
set of functions that support the use of hashes in
\&\fIinside-out classes\fR, described in Hash::Util::FieldHash.
.PP
By default \f(CW\*(C`Hash::Util\*(C'\fR does not export anything.
.SS "Restricted hashes"
.IX Subsection "Restricted hashes"
5.8.0 introduces the ability to restrict a hash to a certain set of
keys.  No keys outside of this set can be added.  It also introduces
the ability to lock an individual key so it cannot be deleted and the
ability to ensure that an individual value cannot be changed.
.PP
This is intended to largely replace the deprecated pseudo-hashes.
.IP "\fBlock_keys\fR" 4
.IX Item "lock_keys"
.PD 0
.IP "\fBunlock_keys\fR" 4
.IX Item "unlock_keys"
.PD
.Vb 2
\&  lock_keys(%hash);
\&  lock_keys(%hash, @keys);
.Ve
.Sp
Restricts the given \f(CW%hash\fR's set of keys to \f(CW@keys\fR.  If \f(CW@keys\fR is not
given it restricts it to its current keyset.  No more keys can be
added. \fIdelete()\fR and \fIexists()\fR will still work, but will not alter
the set of allowed keys. \fBNote\fR: the current implementation prevents
the hash from being \fIbless()\fRed while it is in a locked state. Any attempt
to do so will raise an exception. Of course you can still \fIbless()\fR
the hash before you call \fIlock_keys()\fR so this shouldn't be a problem.
.Sp
.Vb 1
\&  unlock_keys(%hash);
.Ve
.Sp
Removes the restriction on the \f(CW%hash\fR's keyset.
.Sp
\&\fBNote\fR that if any of the values of the hash have been locked they will not
be unlocked after this sub executes.
.Sp
Both routines return a reference to the hash operated on.
.IP "\fBlock_keys_plus\fR" 4
.IX Item "lock_keys_plus"
.Vb 1
\&  lock_keys_plus(%hash,@additional_keys)
.Ve
.Sp
Similar to \f(CW\*(C`lock_keys()\*(C'\fR, with the difference being that the optional key list
specifies keys that may or may not be already in the hash. Essentially this is
an easier way to say
.Sp
.Vb 1
\&  lock_keys(%hash,@additional_keys,keys %hash);
.Ve
.Sp
Returns a reference to \f(CW%hash\fR
.IP "\fBlock_value\fR" 4
.IX Item "lock_value"
.PD 0
.IP "\fBunlock_value\fR" 4
.IX Item "unlock_value"
.PD
.Vb 2
\&  lock_value  (%hash, $key);
\&  unlock_value(%hash, $key);
.Ve
.Sp
Locks and unlocks the value for an individual key of a hash.  The value of a
locked key cannot be changed.
.Sp
Unless \f(CW%hash\fR has already been locked the key/value could be deleted
regardless of this setting.
.Sp
Returns a reference to the \f(CW%hash\fR.
.IP "\fBlock_hash\fR" 4
.IX Item "lock_hash"
.PD 0
.IP "\fBunlock_hash\fR" 4
.IX Item "unlock_hash"
.PD
.Vb 1
\&    lock_hash(%hash);
.Ve
.Sp
\&\fIlock_hash()\fR locks an entire hash, making all keys and values read-only.
No value can be changed, no keys can be added or deleted.
.Sp
.Vb 1
\&    unlock_hash(%hash);
.Ve
.Sp
\&\fIunlock_hash()\fR does the opposite of \fIlock_hash()\fR.  All keys and values
are made writable.  All values can be changed and keys can be added
and deleted.
.Sp
Returns a reference to the \f(CW%hash\fR.
.IP "\fBlock_hash_recurse\fR" 4
.IX Item "lock_hash_recurse"
.PD 0
.IP "\fBunlock_hash_recurse\fR" 4
.IX Item "unlock_hash_recurse"
.PD
.Vb 1
\&    lock_hash_recurse(%hash);
.Ve
.Sp
\&\fIlock_hash()\fR locks an entire hash and any hashes it references recursively,
making all keys and values read-only. No value can be changed, no keys can
be added or deleted.
.Sp
This method \fBonly\fR recurses into hashes that are referenced by another hash.
Thus a Hash of Hashes (HoH) will all be restricted, but a Hash of Arrays of
Hashes (HoAoH) will only have the top hash restricted.
.Sp
.Vb 1
\&    unlock_hash_recurse(%hash);
.Ve
.Sp
\&\fIunlock_hash_recurse()\fR does the opposite of \fIlock_hash_recurse()\fR.  All keys and
values are made writable.  All values can be changed and keys can be added
and deleted. Identical recursion restrictions apply as to \fIlock_hash_recurse()\fR.
.Sp
Returns a reference to the \f(CW%hash\fR.
.IP "\fBhashref_locked\fR" 4
.IX Item "hashref_locked"
.PD 0
.IP "\fBhash_locked\fR" 4
.IX Item "hash_locked"
.PD
.Vb 2
\&  hashref_locked(\e%hash) and print "Hash is locked!\en";
\&  hash_locked(%hash) and print "Hash is locked!\en";
.Ve
.Sp
Returns true if the hash and its keys are locked.
.IP "\fBhashref_unlocked\fR" 4
.IX Item "hashref_unlocked"
.PD 0
.IP "\fBhash_unlocked\fR" 4
.IX Item "hash_unlocked"
.PD
.Vb 2
\&  hashref_unlocked(\e%hash) and print "Hash is unlocked!\en";
\&  hash_unlocked(%hash) and print "Hash is unlocked!\en";
.Ve
.Sp
Returns true if the hash and its keys are unlocked.
.IP "\fBlegal_keys\fR" 4
.IX Item "legal_keys"
.Vb 1
\&  my @keys = legal_keys(%hash);
.Ve
.Sp
Returns the list of the keys that are legal in a restricted hash.
In the case of an unrestricted hash this is identical to calling
keys(%hash).
.IP "\fBhidden_keys\fR" 4
.IX Item "hidden_keys"
.Vb 1
\&  my @keys = hidden_keys(%hash);
.Ve
.Sp
Returns the list of the keys that are legal in a restricted hash but
do not have a value associated to them. Thus if 'foo' is a
\&\*(L"hidden\*(R" key of the \f(CW%hash\fR it will return false for both \f(CW\*(C`defined\*(C'\fR
and \f(CW\*(C`exists\*(C'\fR tests.
.Sp
In the case of an unrestricted hash this will return an empty list.
.Sp
\&\fB\s-1NOTE\s0\fR this is an experimental feature that is heavily dependent
on the current implementation of restricted hashes. Should the
implementation change, this routine may become meaningless, in which
case it will return an empty list.
.IP "\fBall_keys\fR" 4
.IX Item "all_keys"
.Vb 1
\&  all_keys(%hash,@keys,@hidden);
.Ve
.Sp
Populates the arrays \f(CW@keys\fR with the all the keys that would pass
an \f(CW\*(C`exists\*(C'\fR tests, and populates \f(CW@hidden\fR with the remaining legal
keys that have not been utilized.
.Sp
Returns a reference to the hash.
.Sp
In the case of an unrestricted hash this will be equivalent to
.Sp
.Vb 5
\&  $ref = do {
\&      @keys = keys %hash;
\&      @hidden = ();
\&      \e%hash
\&  };
.Ve
.Sp
\&\fB\s-1NOTE\s0\fR this is an experimental feature that is heavily dependent
on the current implementation of restricted hashes. Should the
implementation change this routine may become meaningless in which
case it will behave identically to how it would behave on an
unrestricted hash.
.IP "\fBhash_seed\fR" 4
.IX Item "hash_seed"
.Vb 1
\&    my $hash_seed = hash_seed();
.Ve
.Sp
\&\fIhash_seed()\fR returns the seed bytes used to randomise hash ordering.
.Sp
\&\fBNote that the hash seed is sensitive information\fR: by knowing it one
can craft a denial-of-service attack against Perl code, even remotely,
see \*(L"Algorithmic Complexity Attacks\*(R" in perlsec for more information.
\&\fBDo not disclose the hash seed\fR to people who don't need to know it.
See also \*(L"\s-1PERL_HASH_SEED_DEBUG\*(R"\s0 in perlrun.
.Sp
Prior to Perl 5.17.6 this function returned a \s-1UV,\s0 it now returns a string,
which may be of nearly any size as determined by the hash function your
Perl has been built with. Possible sizes may be but are not limited to
4 bytes (for most hash algorithms) and 16 bytes (for siphash).
.IP "\fBhash_value\fR" 4
.IX Item "hash_value"
.Vb 1
\&    my $hash_value = hash_value($string);
.Ve
.Sp
\&\fIhash_value()\fR returns the current perl's internal hash value for a given
string.
.Sp
Returns a 32 bit integer representing the hash value of the string passed
in. This value is only reliable for the lifetime of the process. It may
be different depending on invocation, environment variables,  perl version,
architectures, and build options.
.Sp
\&\fBNote that the hash value of a given string is sensitive information\fR:
by knowing it one can deduce the hash seed which in turn can allow one to
craft a denial-of-service attack against Perl code, even remotely,
see \*(L"Algorithmic Complexity Attacks\*(R" in perlsec for more information.
\&\fBDo not disclose the hash value of a string\fR to people who don't need to
know it. See also \*(L"\s-1PERL_HASH_SEED_DEBUG\*(R"\s0 in perlrun.
.IP "\fBbucket_info\fR" 4
.IX Item "bucket_info"
Return a set of basic information about a hash.
.Sp
.Vb 1
\&    my ($keys, $buckets, $used, @length_counts)= bucket_info($hash);
.Ve
.Sp
Fields are as follows:
.Sp
.Vb 5
\&    0: Number of keys in the hash
\&    1: Number of buckets in the hash
\&    2: Number of used buckets in the hash
\&    rest : list of counts, Kth element is the number of buckets
\&           with K keys in it.
.Ve
.Sp
See also \fIbucket_stats()\fR and \fIbucket_array()\fR.
.IP "\fBbucket_stats\fR" 4
.IX Item "bucket_stats"
Returns a list of statistics about a hash.
.Sp
.Vb 2
\&    my ($keys, buckets, $used, $utilization_ratio, $collision_pct,
\&        $mean, $stddev, @length_counts) = bucket_info($hashref);
.Ve
.Sp
Fields are as follows:
.Sp
.Vb 10
\&    0: Number of keys in the hash
\&    1: Number of buckets in the hash
\&    2: Number of used buckets in the hash
\&    3: Hash Quality Score
\&    4: Percent of buckets used
\&    5: Percent of keys which are in collision
\&    6: Average bucket length
\&    7: Standard Deviation of bucket lengths.
\&    rest : list of counts, Kth element is the number of buckets
\&           with K keys in it.
.Ve
.Sp
See also \fIbucket_info()\fR and \fIbucket_array()\fR.
.Sp
Note that Hash Quality Score would be 1 for an ideal hash, numbers
close to and below 1 indicate good hashing, and number significantly
above indicate a poor score. In practice it should be around 0.95 to 1.05.
It is defined as:
.Sp
.Vb 4
\& $score= sum( $count[$length] * ($length * ($length + 1) / 2) )
\&            /
\&            ( ( $keys / 2 * $buckets ) *
\&              ( $keys + ( 2 * $buckets ) \- 1 ) )
.Ve
.Sp
The formula is from the Red Dragon book (reformulated to use the data available)
and is documented at <http://www.strchr.com/hash_functions>
.IP "\fBbucket_array\fR" 4
.IX Item "bucket_array"
.Vb 1
\&    my $array= bucket_array(\e%hash);
.Ve
.Sp
Returns a packed representation of the bucket array associated with a hash. Each element
of the array is either an integer K, in which case it represents K empty buckets, or
a reference to another array which contains the keys that are in that bucket.
.Sp
\&\fBNote that the information returned by bucket_array is sensitive information\fR:
by knowing it one can directly attack perl's hash function which in turn may allow
one to craft a denial-of-service attack against Perl code, even remotely,
see \*(L"Algorithmic Complexity Attacks\*(R" in perlsec for more information.
\&\fBDo not disclose the output of this function\fR to people who don't need to
know it. See also \*(L"\s-1PERL_HASH_SEED_DEBUG\*(R"\s0 in perlrun. This function is provided strictly
for  debugging and diagnostics purposes only, it is hard to imagine a reason why it
would be used in production code.
.IP "\fBhv_store\fR" 4
.IX Item "hv_store"
.Vb 4
\&  my $sv = 0;
\&  hv_store(%hash,$key,$sv) or die "Failed to alias!";
\&  $hash{$key} = 1;
\&  print $sv; # prints 1
.Ve
.Sp
Stores an alias to a variable in a hash instead of copying the value.
.IP "\fBhash_traversal_mask\fR" 4
.IX Item "hash_traversal_mask"
As of Perl 5.18 every hash has its own hash traversal order, and this order
changes every time a new element is inserted into the hash. This functionality
is provided by maintaining an unsigned integer mask (U32) which is xor'ed
with the actual bucket id during a traversal of the hash buckets using \fIkeys()\fR,
\&\fIvalues()\fR or \fIeach()\fR.
.Sp
You can use this subroutine to get and set the traversal mask for a specific
hash. Setting the mask ensures that a given hash will produce the same key
order. \fBNote\fR that this does \fBnot\fR guarantee that \fBtwo\fR hashes will produce
the same key order for the same hash seed and traversal mask, items that
collide into one bucket may have different orders regardless of this setting.
.SS "Operating on references to hashes."
.IX Subsection "Operating on references to hashes."
Most subroutines documented in this module have equivalent versions
that operate on references to hashes instead of native hashes.
The following is a list of these subs. They are identical except
in name and in that instead of taking a \f(CW%hash\fR they take a \f(CW$hashref\fR,
and additionally are not prototyped.
.IP "lock_ref_keys" 4
.IX Item "lock_ref_keys"
.PD 0
.IP "unlock_ref_keys" 4
.IX Item "unlock_ref_keys"
.IP "lock_ref_keys_plus" 4
.IX Item "lock_ref_keys_plus"
.IP "lock_ref_value" 4
.IX Item "lock_ref_value"
.IP "unlock_ref_value" 4
.IX Item "unlock_ref_value"
.IP "lock_hashref" 4
.IX Item "lock_hashref"
.IP "unlock_hashref" 4
.IX Item "unlock_hashref"
.IP "lock_hashref_recurse" 4
.IX Item "lock_hashref_recurse"
.IP "unlock_hashref_recurse" 4
.IX Item "unlock_hashref_recurse"
.IP "hash_ref_unlocked" 4
.IX Item "hash_ref_unlocked"
.IP "legal_ref_keys" 4
.IX Item "legal_ref_keys"
.IP "hidden_ref_keys" 4
.IX Item "hidden_ref_keys"
.PD
.SH "CAVEATS"
.IX Header "CAVEATS"
Note that the trapping of the restricted operations is not atomic:
for example
.PP
.Vb 1
\&    eval { %hash = (illegal_key => 1) }
.Ve
.PP
leaves the \f(CW%hash\fR empty rather than with its original contents.
.SH "BUGS"
.IX Header "BUGS"
The interface exposed by this module is very close to the current
implementation of restricted hashes. Over time it is expected that
this behavior will be extended and the interface abstracted further.
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael G Schwern <schwern@pobox.com> on top of code by Nick
Ing-Simmons and Jeffrey Friedl.
.PP
\&\fIhv_store()\fR is from Array::RefElem, Copyright 2000 Gisle Aas.
.PP
Additional code by Yves Orton.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Scalar::Util, List::Util and \*(L"Algorithmic Complexity Attacks\*(R" in perlsec.
.PP
Hash::Util::FieldHash.
                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Hash::Util::FieldHash.3pm                    0100644 0001750 0001750 00000107256 12566207455 025161  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Hash::Util::FieldHash 3pm"
.TH Hash::Util::FieldHash 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Hash::Util::FieldHash \- Support for Inside\-Out Classes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  ### Create fieldhashes
\&  use Hash::Util qw(fieldhash fieldhashes);
\&
\&  # Create a single field hash
\&  fieldhash my %foo;
\&
\&  # Create three at once...
\&  fieldhashes \e my(%foo, %bar, %baz);
\&  # ...or any number
\&  fieldhashes @hashrefs;
\&
\&  ### Create an idhash and register it for garbage collection
\&  use Hash::Util::FieldHash qw(idhash register);
\&  idhash my %name;
\&  my $object = \e do { my $o };
\&  # register the idhash for garbage collection with $object
\&  register($object, \e %name);
\&  # the following entry will be deleted when $object goes out of scope
\&  $name{$object} = \*(AqJohn Doe\*(Aq;
\&
\&  ### Register an ordinary hash for garbage collection
\&  use Hash::Util::FieldHash qw(id register);
\&  my %name;
\&  my $object = \e do { my $o };
\&  # register the hash %name for garbage collection of $object\*(Aqs id
\&  register $object, \e %name;
\&  # the following entry will be deleted when $object goes out of scope
\&  $name{id $object} = \*(AqJohn Doe\*(Aq;
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
\&\f(CW\*(C`Hash::Util::FieldHash\*(C'\fR offers a number of functions in support of
\&\*(L"The Inside-out Technique\*(R" of class construction.
.IP "id" 4
.IX Item "id"
.Vb 1
\&    id($obj)
.Ve
.Sp
Returns the reference address of a reference \f(CW$obj\fR.  If \f(CW$obj\fR is
not a reference, returns \f(CW$obj\fR.
.Sp
This function is a stand-in replacement for
Scalar::Util::refaddr, that is, it returns
the reference address of its argument as a numeric value.  The only
difference is that \f(CW\*(C`refaddr()\*(C'\fR returns \f(CW\*(C`undef\*(C'\fR when given a
non-reference while \f(CW\*(C`id()\*(C'\fR returns its argument unchanged.
.Sp
\&\f(CW\*(C`id()\*(C'\fR also uses a caching technique that makes it faster when
the id of an object is requested often, but slower if it is needed
only once or twice.
.IP "id_2obj" 4
.IX Item "id_2obj"
.Vb 1
\&    $obj = id_2obj($id)
.Ve
.Sp
If \f(CW$id\fR is the id of a registered object (see \*(L"register\*(R"), returns
the object, otherwise an undefined value.  For registered objects this
is the inverse function of \f(CW\*(C`id()\*(C'\fR.
.IP "register" 4
.IX Item "register"
.Vb 2
\&    register($obj)
\&    register($obj, @hashrefs)
.Ve
.Sp
In the first form, registers an object to work with for the function
\&\f(CW\*(C`id_2obj()\*(C'\fR.  In the second form, it additionally marks the given
hashrefs down for garbage collection.  This means that when the object
goes out of scope, any entries in the given hashes under the key of
\&\f(CW\*(C`id($obj)\*(C'\fR will be deleted from the hashes.
.Sp
It is a fatal error to register a non-reference \f(CW$obj\fR.  Any non-hashrefs
among the following arguments are silently ignored.
.Sp
It is \fInot\fR an error to register the same object multiple times with
varying sets of hashrefs.  Any hashrefs that are not registered yet
will be added, others ignored.
.Sp
Registry also implies thread support.  When a new thread is created,
all references are replaced with new ones, including all objects.
If a hash uses the reference address of an object as a key, that
connection would be broken.  With a registered object, its id will
be updated in all hashes registered with it.
.IP "idhash" 4
.IX Item "idhash"
.Vb 1
\&    idhash my %hash
.Ve
.Sp
Makes an idhash from the argument, which must be a hash.
.Sp
An \fIidhash\fR works like a normal hash, except that it stringifies a
\&\fIreference used as a key\fR differently.  A reference is stringified
as if the \f(CW\*(C`id()\*(C'\fR function had been invoked on it, that is, its
reference address in decimal is used as the key.
.IP "idhashes" 4
.IX Item "idhashes"
.Vb 2
\&    idhashes \e my(%hash, %gnash, %trash)
\&    idhashes \e @hashrefs
.Ve
.Sp
Creates many idhashes from its hashref arguments.  Returns those
arguments that could be converted or their number in scalar context.
.IP "fieldhash" 4
.IX Item "fieldhash"
.Vb 1
\&    fieldhash %hash;
.Ve
.Sp
Creates a single fieldhash.  The argument must be a hash.  Returns
a reference to the given hash if successful, otherwise nothing.
.Sp
A \fIfieldhash\fR is, in short, an idhash with auto-registry.  When an
object (or, indeed, any reference) is used as a fieldhash key, the
fieldhash is automatically registered for garbage collection with
the object, as if \f(CW\*(C`register $obj, \e %fieldhash\*(C'\fR had been called.
.IP "fieldhashes" 4
.IX Item "fieldhashes"
.Vb 1
\&    fieldhashes @hashrefs;
.Ve
.Sp
Creates any number of field hashes.  Arguments must be hash references.
Returns the converted hashrefs in list context, their number in scalar
context.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A word on terminology:  I shall use the term \fIfield\fR for a scalar
piece of data that a class associates with an object.  Other terms that
have been used for this concept are \*(L"object variable\*(R", \*(L"(object) property\*(R",
\&\*(L"(object) attribute\*(R" and more.  Especially \*(L"attribute\*(R" has some currency
among Perl programmer, but that clashes with the \f(CW\*(C`attributes\*(C'\fR pragma.  The
term \*(L"field\*(R" also has some currency in this sense and doesn't seem
to conflict with other Perl terminology.
.PP
In Perl, an object is a blessed reference.  The standard way of associating
data with an object is to store the data inside the object's body, that is,
the piece of data pointed to by the reference.
.PP
In consequence, if two or more classes want to access an object they
\&\fImust\fR agree on the type of reference and also on the organization of
data within the object body.  Failure to agree on the type results in
immediate death when the wrong method tries to access an object.  Failure
to agree on data organization may lead to one class trampling over the
data of another.
.PP
This object model leads to a tight coupling between subclasses.
If one class wants to inherit from another (and both classes access
object data), the classes must agree about implementation details.
Inheritance can only be used among classes that are maintained together,
in a single source or not.
.PP
In particular, it is not possible to write general-purpose classes
in this technique, classes that can advertise themselves as \*(L"Put me
on your \f(CW@ISA\fR list and use my methods\*(R".  If the other class has different
ideas about how the object body is used, there is trouble.
.PP
For reference \f(CW\*(C`Name_hash\*(C'\fR in \*(L"Example 1\*(R" shows the standard implementation of
a simple class \f(CW\*(C`Name\*(C'\fR in the well-known hash based way.  It also demonstrates
the predictable failure to construct a common subclass \f(CW\*(C`NamedFile\*(C'\fR
of \f(CW\*(C`Name\*(C'\fR and the class \f(CW\*(C`IO::File\*(C'\fR (whose objects \fImust\fR be globrefs).
.PP
Thus, techniques are of interest that store object data \fInot\fR in
the object body but some other place.
.SS "The Inside-out Technique"
.IX Subsection "The Inside-out Technique"
With \fIinside-out\fR classes, each class declares a (typically lexical)
hash for each field it wants to use.  The reference address of an
object is used as the hash key.  By definition, the reference address
is unique to each object so this guarantees a place for each field that
is private to the class and unique to each object.  See \f(CW\*(C`Name_id\*(C'\fR
in \*(L"Example 1\*(R" for a simple example.
.PP
In comparison to the standard implementation where the object is a
hash and the fields correspond to hash keys, here the fields correspond
to hashes, and the object determines the hash key.  Thus the hashes
appear to be turned \fIinside out\fR.
.PP
The body of an object is never examined by an inside-out class, only
its reference address is used.  This allows for the body of an actual
object to be \fIanything at all\fR while the object methods of the class
still work as designed.  This is a key feature of inside-out classes.
.SS "Problems of Inside-out"
.IX Subsection "Problems of Inside-out"
Inside-out classes give us freedom of inheritance, but as usual there
is a price.
.PP
Most obviously, there is the necessity of retrieving the reference
address of an object for each data access.  It's a minor inconvenience,
but it does clutter the code.
.PP
More important (and less obvious) is the necessity of garbage
collection.  When a normal object dies, anything stored in the
object body is garbage-collected by perl.  With inside-out objects,
Perl knows nothing about the data stored in field hashes by a class,
but these must be deleted when the object goes out of scope.  Thus
the class must provide a \f(CW\*(C`DESTROY\*(C'\fR method to take care of that.
.PP
In the presence of multiple classes it can be non-trivial
to make sure that every relevant destructor is called for
every object.  Perl calls the first one it finds on the
inheritance tree (if any) and that's it.
.PP
A related issue is thread-safety.  When a new thread is created,
the Perl interpreter is cloned, which implies that all reference
addresses in use will be replaced with new ones.  Thus, if a class
tries to access a field of a cloned object its (cloned) data will
still be stored under the now invalid reference address of the
original in the parent thread.  A general \f(CW\*(C`CLONE\*(C'\fR method must
be provided to re-establish the association.
.SS "Solutions"
.IX Subsection "Solutions"
\&\f(CW\*(C`Hash::Util::FieldHash\*(C'\fR addresses these issues on several
levels.
.PP
The \f(CW\*(C`id()\*(C'\fR function is provided in addition to the
existing \f(CW\*(C`Scalar::Util::refaddr()\*(C'\fR.  Besides its short name
it can be a little faster under some circumstances (and a
bit slower under others).  Benchmark if it matters.  The
working of \f(CW\*(C`id()\*(C'\fR also allows the use of the class name
as a \fIgeneric object\fR as described further down.
.PP
The \f(CW\*(C`id()\*(C'\fR function is incorporated in \fIid hashes\fR in the sense
that it is called automatically on every key that is used with
the hash.  No explicit call is necessary.
.PP
The problems of garbage collection and thread safety are both
addressed by the function \f(CW\*(C`register()\*(C'\fR.  It registers an object
together with any number of hashes.  Registry means that when the
object dies, an entry in any of the hashes under the reference
address of this object will be deleted.  This guarantees garbage
collection in these hashes.  It also means that on thread
cloning the object's entries in registered hashes will be
replaced with updated entries whose key is the cloned object's
reference address.  Thus the object-data association becomes
thread-safe.
.PP
Object registry is best done when the object is initialized
for use with a class.  That way, garbage collection and thread
safety are established for every object and every field that is
initialized.
.PP
Finally, \fIfield hashes\fR incorporate all these functions in one
package.  Besides automatically calling the \f(CW\*(C`id()\*(C'\fR function
on every object used as a key, the object is registered with
the field hash on first use.  Classes based on field hashes
are fully garbage-collected and thread safe without further
measures.
.SS "More Problems"
.IX Subsection "More Problems"
Another problem that occurs with inside-out classes is serialization.
Since the object data is not in its usual place, standard routines
like \f(CW\*(C`Storable::freeze()\*(C'\fR, \f(CW\*(C`Storable::thaw()\*(C'\fR and 
\&\f(CW\*(C`Data::Dumper::Dumper()\*(C'\fR can't deal with it on their own.  Both
\&\f(CW\*(C`Data::Dumper\*(C'\fR and \f(CW\*(C`Storable\*(C'\fR provide the necessary hooks to
make things work, but the functions or methods used by the hooks
must be provided by each inside-out class.
.PP
A general solution to the serialization problem would require another
level of registry, one that that associates \fIclasses\fR and fields.
So far, the functions of \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR are unaware of
any classes, which I consider a feature.  Therefore \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR
doesn't address the serialization problems.
.SS "The Generic Object"
.IX Subsection "The Generic Object"
Classes based on the \f(CW\*(C`id()\*(C'\fR function (and hence classes based on
\&\f(CW\*(C`idhash()\*(C'\fR and \f(CW\*(C`fieldhash()\*(C'\fR) show a peculiar behavior in that
the class name can be used like an object.  Specifically, methods
that set or read data associated with an object continue to work as
class methods, just as if the class name were an object, distinct from
all other objects, with its own data.  This object may be called
the \fIgeneric object\fR of the class.
.PP
This works because field hashes respond to keys that are not references
like a normal hash would and use the string offered as the hash key.
Thus, if a method is called as a class method, the field hash is presented
with the class name instead of an object and blithely uses it as a key.
Since the keys of real objects are decimal numbers, there is no
conflict and the slot in the field hash can be used like any other.
The \f(CW\*(C`id()\*(C'\fR function behaves correspondingly with respect to non-reference
arguments.
.PP
Two possible uses (besides ignoring the property) come to mind.
A singleton class could be implemented this using the generic object.
If necessary, an \f(CW\*(C`init()\*(C'\fR method could die or ignore calls with
actual objects (references), so only the generic object will ever exist.
.PP
Another use of the generic object would be as a template.  It is
a convenient place to store class-specific defaults for various
fields to be used in actual object initialization.
.PP
Usually, the feature can be entirely ignored.  Calling \fIobject
methods\fR as \fIclass methods\fR normally leads to an error and isn't used
routinely anywhere.  It may be a problem that this error isn't
indicated by a class with a generic object.
.SS "How to use Field Hashes"
.IX Subsection "How to use Field Hashes"
Traditionally, the definition of an inside-out class contains a bare
block inside which a number of lexical hashes are declared and the
basic accessor methods defined, usually through \f(CW\*(C`Scalar::Util::refaddr\*(C'\fR.
Further methods may be defined outside this block.  There has to be
a \s-1DESTROY\s0 method and, for thread support, a \s-1CLONE\s0 method.
.PP
When field hashes are used, the basic structure remains the same.
Each lexical hash will be made a field hash.  The call to \f(CW\*(C`refaddr\*(C'\fR
can be omitted from the accessor methods.  \s-1DESTROY\s0 and \s-1CLONE\s0 methods
are not necessary.
.PP
If you have an existing inside-out class, simply making all hashes
field hashes with no other change should make no difference.  Through
the calls to \f(CW\*(C`refaddr\*(C'\fR or equivalent, the field hashes never get to
see a reference and work like normal hashes.  Your \s-1DESTROY \s0(and
\&\s-1CLONE\s0) methods are still needed.
.PP
To make the field hashes kick in, it is easiest to redefine \f(CW\*(C`refaddr\*(C'\fR
as
.PP
.Vb 1
\&    sub refaddr { shift }
.Ve
.PP
instead of importing it from \f(CW\*(C`Scalar::Util\*(C'\fR.  It should now be possible
to disable \s-1DESTROY\s0 and \s-1CLONE. \s0 Note that while it isn't disabled,
\&\s-1DESTROY\s0 will be called before the garbage collection of field hashes,
so it will be invoked with a functional object and will continue to
function.
.PP
It is not desirable to import the functions \f(CW\*(C`fieldhash\*(C'\fR and/or
\&\f(CW\*(C`fieldhashes\*(C'\fR into every class that is going to use them.  They
are only used once to set up the class.  When the class is up and running,
these functions serve no more purpose.
.PP
If there are only a few field hashes to declare, it is simplest to
.PP
.Vb 1
\&    use Hash::Util::FieldHash;
.Ve
.PP
early and call the functions qualified:
.PP
.Vb 1
\&    Hash::Util::FieldHash::fieldhash my %foo;
.Ve
.PP
Otherwise, import the functions into a convenient package like
\&\f(CW\*(C`HUF\*(C'\fR or, more general, \f(CW\*(C`Aux\*(C'\fR
.PP
.Vb 4
\&    {
\&        package Aux;
\&        use Hash::Util::FieldHash \*(Aq:all\*(Aq;
\&    }
.Ve
.PP
and call
.PP
.Vb 1
\&    Aux::fieldhash my %foo;
.Ve
.PP
as needed.
.SS "Garbage-Collected Hashes"
.IX Subsection "Garbage-Collected Hashes"
Garbage collection in a field hash means that entries will \*(L"spontaneously\*(R"
disappear when the object that created them disappears.  That must be
borne in mind, especially when looping over a field hash.  If anything
you do inside the loop could cause an object to go out of scope, a
random key may be deleted from the hash you are looping over.  That
can throw the loop iterator, so it's best to cache a consistent snapshot
of the keys and/or values and loop over that.  You will still have to
check that a cached entry still exists when you get to it.
.PP
Garbage collection can be confusing when keys are created in a field hash
from normal scalars as well as references.  Once a reference is \fIused\fR with
a field hash, the entry will be collected, even if it was later overwritten
with a plain scalar key (every positive integer is a candidate).  This
is true even if the original entry was deleted in the meantime.  In fact,
deletion from a field hash, and also a test for existence constitute
\&\fIuse\fR in this sense and create a liability to delete the entry when
the reference goes out of scope.  If you happen to create an entry
with an identical key from a string or integer, that will be collected
instead.  Thus, mixed use of references and plain scalars as field hash
keys is not entirely supported.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
The examples show a very simple class that implements a \fIname\fR, consisting
of a first and last name (no middle initial).  The name class has four
methods:
.IP "\(bu" 4
\&\f(CW\*(C`init()\*(C'\fR
.Sp
An object method that initializes the first and last name to its
two arguments. If called as a class method, \f(CW\*(C`init()\*(C'\fR creates an
object in the given class and initializes that.
.IP "\(bu" 4
\&\f(CW\*(C`first()\*(C'\fR
.Sp
Retrieve the first name
.IP "\(bu" 4
\&\f(CW\*(C`last()\*(C'\fR
.Sp
Retrieve the last name
.IP "\(bu" 4
\&\f(CW\*(C`name()\*(C'\fR
.Sp
Retrieve the full name, the first and last name joined by a blank.
.PP
The examples show this class implemented with different levels of
support by \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR.  All supported combinations
are shown.  The difference between implementations is often quite
small.  The implementations are:
.IP "\(bu" 4
\&\f(CW\*(C`Name_hash\*(C'\fR
.Sp
A conventional (not inside-out) implementation where an object is
a hash that stores the field values, without support by
\&\f(CW\*(C`Hash::Util::FieldHash\*(C'\fR.  This implementation doesn't allow
arbitrary inheritance.
.IP "\(bu" 4
\&\f(CW\*(C`Name_id\*(C'\fR
.Sp
Inside-out implementation based on the \f(CW\*(C`id()\*(C'\fR function.  It needs
a \f(CW\*(C`DESTROY\*(C'\fR method.  For thread support a \f(CW\*(C`CLONE\*(C'\fR method (not shown)
would also be needed.  Instead of \f(CW\*(C`Hash::Util::FieldHash::id()\*(C'\fR the
function \f(CW\*(C`Scalar::Util::refaddr\*(C'\fR could be used with very little
functional difference.  This is the basic pattern of an inside-out
class.
.IP "\(bu" 4
\&\f(CW\*(C`Name_idhash\*(C'\fR
.Sp
Idhash-based inside-out implementation.  Like \f(CW\*(C`Name_id\*(C'\fR it needs
a \f(CW\*(C`DESTROY\*(C'\fR method and would need \f(CW\*(C`CLONE\*(C'\fR for thread support.
.IP "\(bu" 4
\&\f(CW\*(C`Name_id_reg\*(C'\fR
.Sp
Inside-out implementation based on the \f(CW\*(C`id()\*(C'\fR function with explicit
object registry.  No destructor is needed and objects are thread safe.
.IP "\(bu" 4
\&\f(CW\*(C`Name_idhash_reg\*(C'\fR
.Sp
Idhash-based inside-out implementation with explicit object registry.
No destructor is needed and objects are thread safe.
.IP "\(bu" 4
\&\f(CW\*(C`Name_fieldhash\*(C'\fR
.Sp
FieldHash-based inside-out implementation.  Object registry happens
automatically.  No destructor is needed and objects are thread safe.
.PP
These examples are realized in the code below, which could be copied
to a file \fIExample.pm\fR.
.SS "Example 1"
.IX Subsection "Example 1"
.Vb 1
\&    use strict; use warnings;
\&
\&    {
\&        package Name_hash; # standard implementation: the object is a hash
\&
\&        sub init {
\&            my $obj = shift;
\&            my ($first, $last) = @_;
\&            # create an object if called as class method
\&            $obj = bless {}, $obj unless ref $obj;
\&            $obj\->{ first} = $first;
\&            $obj\->{ last} = $last;
\&            $obj;
\&        }
\&
\&        sub first { shift()\->{ first} }
\&        sub last { shift()\->{ last} }
\&
\&        sub name {
\&            my $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&
\&    }
\&
\&    {
\&        package Name_id;
\&        use Hash::Util::FieldHash qw(id);
\&
\&        my (%first, %last);
\&
\&        sub init {
\&            my $obj = shift;
\&            my ($first, $last) = @_;
\&            # create an object if called as class method
\&            $obj = bless \e my $o, $obj unless ref $obj;
\&            $first{ id $obj} = $first;
\&            $last{ id $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ id shift()} }
\&        sub last { $last{ id shift()} }
\&
\&        sub name {
\&            my $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&
\&        sub DESTROY {
\&            my $id = id shift;
\&            delete $first{ $id};
\&            delete $last{ $id};
\&        }
\&
\&    }
\&
\&    {
\&        package Name_idhash;
\&        use Hash::Util::FieldHash;
\&
\&        Hash::Util::FieldHash::idhashes( \e my (%first, %last) );
\&
\&        sub init {
\&            my $obj = shift;
\&            my ($first, $last) = @_;
\&            # create an object if called as class method
\&            $obj = bless \e my $o, $obj unless ref $obj;
\&            $first{ $obj} = $first;
\&            $last{ $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ shift()} }
\&        sub last { $last{ shift()} }
\&
\&        sub name {
\&            my $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&
\&        sub DESTROY {
\&            my $n = shift;
\&            delete $first{ $n};
\&            delete $last{ $n};
\&        }
\&
\&    }
\&
\&    {
\&        package Name_id_reg;
\&        use Hash::Util::FieldHash qw(id register);
\&
\&        my (%first, %last);
\&
\&        sub init {
\&            my $obj = shift;
\&            my ($first, $last) = @_;
\&            # create an object if called as class method
\&            $obj = bless \e my $o, $obj unless ref $obj;
\&            register( $obj, \e (%first, %last) );
\&            $first{ id $obj} = $first;
\&            $last{ id $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ id shift()} }
\&        sub last { $last{ id shift()} }
\&
\&        sub name {
\&            my $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&    }
\&
\&    {
\&        package Name_idhash_reg;
\&        use Hash::Util::FieldHash qw(register);
\&
\&        Hash::Util::FieldHash::idhashes \e my (%first, %last);
\&
\&        sub init {
\&            my $obj = shift;
\&            my ($first, $last) = @_;
\&            # create an object if called as class method
\&            $obj = bless \e my $o, $obj unless ref $obj;
\&            register( $obj, \e (%first, %last) );
\&            $first{ $obj} = $first;
\&            $last{ $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ shift()} }
\&        sub last { $last{ shift()} }
\&
\&        sub name {
\&            my $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&    }
\&
\&    {
\&        package Name_fieldhash;
\&        use Hash::Util::FieldHash;
\&
\&        Hash::Util::FieldHash::fieldhashes \e my (%first, %last);
\&
\&        sub init {
\&            my $obj = shift;
\&            my ($first, $last) = @_;
\&            # create an object if called as class method
\&            $obj = bless \e my $o, $obj unless ref $obj;
\&            $first{ $obj} = $first;
\&            $last{ $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ shift()} }
\&        sub last { $last{ shift()} }
\&
\&        sub name {
\&            my $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&    }
\&
\&    1;
.Ve
.PP
To exercise the various implementations the script below can
be used.
.PP
It sets up a class \f(CW\*(C`Name\*(C'\fR that is a mirror of one of the implementation
classes \f(CW\*(C`Name_hash\*(C'\fR, \f(CW\*(C`Name_id\*(C'\fR, ..., \f(CW\*(C`Name_fieldhash\*(C'\fR.  That determines
which implementation is run.
.PP
The script first verifies the function of the \f(CW\*(C`Name\*(C'\fR class.
.PP
In the second step, the free inheritability of the implementation
(or lack thereof) is demonstrated.  For this purpose it constructs
a class called \f(CW\*(C`NamedFile\*(C'\fR which is a common subclass of \f(CW\*(C`Name\*(C'\fR and
the standard class \f(CW\*(C`IO::File\*(C'\fR.  This puts inheritability to the test
because objects of \f(CW\*(C`IO::File\*(C'\fR \fImust\fR be globrefs.  Objects of \f(CW\*(C`NamedFile\*(C'\fR
should behave like a file opened for reading and also support the \f(CW\*(C`name()\*(C'\fR
method.  This class juncture works with exception of the \f(CW\*(C`Name_hash\*(C'\fR
implementation, where object initialization fails because of the
incompatibility of object bodies.
.SS "Example 2"
.IX Subsection "Example 2"
.Vb 1
\&    use strict; use warnings; $| = 1;
\&
\&    use Example;
\&
\&    {
\&        package Name;
\&        use base \*(AqName_id\*(Aq;      # define here which implementation to run
\&    }
\&
\&
\&    # Verify that the base package works
\&    my $n = Name\->init(qw(Albert Einstein));
\&    print $n\->name, "\en";
\&    print "\en";
\&
\&    # Create a named file handle (See definition below)
\&    my $nf = NamedFile\->init(qw(/tmp/x Filomena File));
\&    # use as a file handle...
\&    for ( 1 .. 3 ) {
\&        my $l = <$nf>;
\&        print "line $_: $l";
\&    }
\&    # ...and as a Name object
\&    print "...brought to you by ", $nf\->name, "\en";
\&    exit;
\&
\&
\&    # Definition of NamedFile
\&    package NamedFile;
\&    use base \*(AqName\*(Aq;
\&    use base \*(AqIO::File\*(Aq;
\&
\&    sub init {
\&        my $obj = shift;
\&        my ($file, $first, $last) = @_;
\&        $obj = $obj\->IO::File::new() unless ref $obj;
\&        $obj\->open($file) or die "Can\*(Aqt read \*(Aq$file\*(Aq: $!";
\&        $obj\->Name::init($first, $last);
\&    }
\&    _\|_END_\|_
.Ve
.SH "GUTS"
.IX Header "GUTS"
To make \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR work, there were two changes to
\&\fIperl\fR itself.  \f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR was made available for hashes,
and weak references now call uvar \f(CW\*(C`get\*(C'\fR magic after a weakref has been
cleared.  The first feature is used to make field hashes intercept
their keys upon access.  The second one triggers garbage collection.
.ie n .SS "The ""PERL_MAGIC_uvar"" interface for hashes"
.el .SS "The \f(CWPERL_MAGIC_uvar\fP interface for hashes"
.IX Subsection "The PERL_MAGIC_uvar interface for hashes"
\&\f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR \fIget\fR magic is called from \f(CW\*(C`hv_fetch_common\*(C'\fR and
\&\f(CW\*(C`hv_delete_common\*(C'\fR through the function \f(CW\*(C`hv_magic_uvar_xkey\*(C'\fR, which
defines the interface.  The call happens for hashes with \*(L"uvar\*(R" magic
if the \f(CW\*(C`ufuncs\*(C'\fR structure has equal values in the \f(CW\*(C`uf_val\*(C'\fR and \f(CW\*(C`uf_set\*(C'\fR
fields.  Hashes are unaffected if (and as long as) these fields
hold different values.
.PP
Upon the call, the \f(CW\*(C`mg_obj\*(C'\fR field will hold the hash key to be accessed.
Upon return, the \f(CW\*(C`SV*\*(C'\fR value in \f(CW\*(C`mg_obj\*(C'\fR will be used in place of the
original key in the hash access.  The integer index value in the first
parameter will be the \f(CW\*(C`action\*(C'\fR value from \f(CW\*(C`hv_fetch_common\*(C'\fR, or \-1
if the call is from \f(CW\*(C`hv_delete_common\*(C'\fR.
.PP
This is a template for a function suitable for the \f(CW\*(C`uf_val\*(C'\fR field in
a \f(CW\*(C`ufuncs\*(C'\fR structure for this call.  The \f(CW\*(C`uf_set\*(C'\fR and \f(CW\*(C`uf_index\*(C'\fR
fields are irrelevant.
.PP
.Vb 10
\&    IV watch_key(pTHX_ IV action, SV* field) {
\&        MAGIC* mg = mg_find(field, PERL_MAGIC_uvar);
\&        SV* keysv = mg\->mg_obj;
\&        /* Do whatever you need to.  If you decide to
\&           supply a different key newkey, return it like this
\&        */
\&        sv_2mortal(newkey);
\&        mg\->mg_obj = newkey;
\&        return 0;
\&    }
.Ve
.SS "Weakrefs call uvar magic"
.IX Subsection "Weakrefs call uvar magic"
When a weak reference is stored in an \f(CW\*(C`SV\*(C'\fR that has \*(L"uvar\*(R" magic, \f(CW\*(C`set\*(C'\fR
magic is called after the reference has gone stale.  This hook can be
used to trigger further garbage-collection activities associated with
the referenced object.
.SS "How field hashes work"
.IX Subsection "How field hashes work"
The three features of key hashes, \fIkey replacement\fR, \fIthread support\fR,
and \fIgarbage collection\fR are supported by a data structure called
the \fIobject registry\fR.  This is a private hash where every object
is stored.  An \*(L"object\*(R" in this sense is any reference (blessed or
unblessed) that has been used as a field hash key.
.PP
The object registry keeps track of references that have been used as
field hash keys.  The keys are generated from the reference address
like in a field hash (though the registry isn't a field hash).  Each
value is a weak copy of the original reference, stored in an \f(CW\*(C`SV\*(C'\fR that
is itself magical (\f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR again).  The magical structure
holds a list (another hash, really) of field hashes that the reference
has been used with.  When the weakref becomes stale, the magic is
activated and uses the list to delete the reference from all field
hashes it has been used with.  After that, the entry is removed from
the object registry itself.  Implicitly, that frees the magic structure
and the storage it has been using.
.PP
Whenever a reference is used as a field hash key, the object registry
is checked and a new entry is made if necessary.  The field hash is
then added to the list of fields this reference has used.
.PP
The object registry is also used to repair a field hash after thread
cloning.  Here, the entire object registry is processed.  For every
reference found there, the field hashes it has used are visited and
the entry is updated.
.SS "Internal function Hash::Util::FieldHash::_fieldhash"
.IX Subsection "Internal function Hash::Util::FieldHash::_fieldhash"
.Vb 2
\&    # test if %hash is a field hash
\&    my $result = _fieldhash \e %hash, 0;
\&
\&    # make %hash a field hash
\&    my $result = _fieldhash \e %hash, 1;
.Ve
.PP
\&\f(CW\*(C`_fieldhash\*(C'\fR is the internal function used to create field hashes.
It takes two arguments, a hashref and a mode.  If the mode is boolean
false, the hash is not changed but tested if it is a field hash.  If
the hash isn't a field hash the return value is boolean false.  If it
is, the return value indicates the mode of field hash.  When called with
a boolean true mode, it turns the given hash into a field hash of this
mode, returning the mode of the created field hash.  \f(CW\*(C`_fieldhash\*(C'\fR
does not erase the given hash.
.PP
Currently there is only one type of field hash, and only the boolean
value of the mode makes a difference, but that may change.
.SH "AUTHOR"
.IX Header "AUTHOR"
Anno Siegel (\s-1ANNO\s0) wrote the xs code and the changes in perl proper
Jerry Hedden (\s-1JDHEDDEN\s0) made it faster
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007 by (Anno Siegel)
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.7 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Hash::Util::FieldHash5.16.3pm                0100644 0001750 0001750 00000106735 12566207434 025471  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Hash::Util::FieldHash 3pm"
.TH Hash::Util::FieldHash 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Hash::Util::FieldHash \- Support for Inside\-Out Classes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  ### Create fieldhashes
\&  use Hash::Util qw(fieldhash fieldhashes);
\&
\&  # Create a single field hash
\&  fieldhash my %foo;
\&
\&  # Create three at once...
\&  fieldhashes \e my(%foo, %bar, %baz);
\&  # ...or any number
\&  fieldhashes @hashrefs;
\&
\&  ### Create an idhash and register it for garbage collection
\&  use Hash::Util::FieldHash qw(idhash register);
\&  idhash my %name;
\&  my $object = \e do { my $o };
\&  # register the idhash for garbage collection with $object
\&  register($object, \e %name);
\&  # the following entry will be deleted when $object goes out of scope
\&  $name{$object} = \*(AqJohn Doe\*(Aq;
\&
\&  ### Register an ordinary hash for garbage collection
\&  use Hash::Util::FieldHash qw(id register);
\&  my %name;
\&  my $object = \e do { my $o };
\&  # register the hash %name for garbage collection of $object\*(Aqs id
\&  register $object, \e %name;
\&  # the following entry will be deleted when $object goes out of scope
\&  $name{id $object} = \*(AqJohn Doe\*(Aq;
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
\&\f(CW\*(C`Hash::Util::FieldHash\*(C'\fR offers a number of functions in support of
\&\*(L"The Inside-out Technique\*(R" of class construction.
.IP "id" 4
.IX Item "id"
.Vb 1
\&    id($obj)
.Ve
.Sp
Returns the reference address of a reference \f(CW$obj\fR.  If \f(CW$obj\fR is
not a reference, returns \f(CW$obj\fR.
.Sp
This function is a stand-in replacement for
Scalar::Util::refaddr, that is, it returns
the reference address of its argument as a numeric value.  The only
difference is that \f(CW\*(C`refaddr()\*(C'\fR returns \f(CW\*(C`undef\*(C'\fR when given a
non-reference while \f(CW\*(C`id()\*(C'\fR returns its argument unchanged.
.Sp
\&\f(CW\*(C`id()\*(C'\fR also uses a caching technique that makes it faster when
the id of an object is requested often, but slower if it is needed
only once or twice.
.IP "id_2obj" 4
.IX Item "id_2obj"
.Vb 1
\&    $obj = id_2obj($id)
.Ve
.Sp
If \f(CW$id\fR is the id of a registered object (see \*(L"register\*(R"), returns
the object, otherwise an undefined value.  For registered objects this
is the inverse function of \f(CW\*(C`id()\*(C'\fR.
.IP "register" 4
.IX Item "register"
.Vb 2
\&    register($obj)
\&    register($obj, @hashrefs)
.Ve
.Sp
In the first form, registers an object to work with for the function
\&\f(CW\*(C`id_2obj()\*(C'\fR.  In the second form, it additionally marks the given
hashrefs down for garbage collection.  This means that when the object
goes out of scope, any entries in the given hashes under the key of
\&\f(CW\*(C`id($obj)\*(C'\fR will be deleted from the hashes.
.Sp
It is a fatal error to register a non-reference \f(CW$obj\fR.  Any non-hashrefs
among the following arguments are silently ignored.
.Sp
It is \fInot\fR an error to register the same object multiple times with
varying sets of hashrefs.  Any hashrefs that are not registered yet
will be added, others ignored.
.Sp
Registry also implies thread support.  When a new thread is created,
all references are replaced with new ones, including all objects.
If a hash uses the reference address of an object as a key, that
connection would be broken.  With a registered object, its id will
be updated in all hashes registered with it.
.IP "idhash" 4
.IX Item "idhash"
.Vb 1
\&    idhash my %hash
.Ve
.Sp
Makes an idhash from the argument, which must be a hash.
.Sp
An \fIidhash\fR works like a normal hash, except that it stringifies a
\&\fIreference used as a key\fR differently.  A reference is stringified
as if the \f(CW\*(C`id()\*(C'\fR function had been invoked on it, that is, its
reference address in decimal is used as the key.
.IP "idhashes" 4
.IX Item "idhashes"
.Vb 2
\&    idhashes \e my(%hash, %gnash, %trash)
\&    idhashes \e @hashrefs
.Ve
.Sp
Creates many idhashes from its hashref arguments.  Returns those
arguments that could be converted or their number in scalar context.
.IP "fieldhash" 4
.IX Item "fieldhash"
.Vb 1
\&    fieldhash %hash;
.Ve
.Sp
Creates a single fieldhash.  The argument must be a hash.  Returns
a reference to the given hash if successful, otherwise nothing.
.Sp
A \fIfieldhash\fR is, in short, an idhash with auto-registry.  When an
object (or, indeed, any reference) is used as a fieldhash key, the
fieldhash is automatically registered for garbage collection with
the object, as if \f(CW\*(C`register $obj, \e %fieldhash\*(C'\fR had been called.
.IP "fieldhashes" 4
.IX Item "fieldhashes"
.Vb 1
\&    fieldhashes @hashrefs;
.Ve
.Sp
Creates any number of field hashes.  Arguments must be hash references.
Returns the converted hashrefs in list context, their number in scalar
context.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A word on terminology:  I shall use the term \fIfield\fR for a scalar
piece of data that a class associates with an object.  Other terms that
have been used for this concept are \*(L"object variable\*(R", \*(L"(object) property\*(R",
\&\*(L"(object) attribute\*(R" and more.  Especially \*(L"attribute\*(R" has some currency
among Perl programmer, but that clashes with the \f(CW\*(C`attributes\*(C'\fR pragma.  The
term \*(L"field\*(R" also has some currency in this sense and doesn't seem
to conflict with other Perl terminology.
.PP
In Perl, an object is a blessed reference.  The standard way of associating
data with an object is to store the data inside the object's body, that is,
the piece of data pointed to by the reference.
.PP
In consequence, if two or more classes want to access an object they
\&\fImust\fR agree on the type of reference and also on the organization of
data within the object body.  Failure to agree on the type results in
immediate death when the wrong method tries to access an object.  Failure
to agree on data organization may lead to one class trampling over the
data of another.
.PP
This object model leads to a tight coupling between subclasses.
If one class wants to inherit from another (and both classes access
object data), the classes must agree about implementation details.
Inheritance can only be used among classes that are maintained together,
in a single source or not.
.PP
In particular, it is not possible to write general-purpose classes
in this technique, classes that can advertise themselves as \*(L"Put me
on your \f(CW@ISA\fR list and use my methods\*(R".  If the other class has different
ideas about how the object body is used, there is trouble.
.PP
For reference \f(CW\*(C`Name_hash\*(C'\fR in \*(L"Example 1\*(R" shows the standard implementation of
a simple class \f(CW\*(C`Name\*(C'\fR in the well-known hash based way.  It also demonstrates
the predictable failure to construct a common subclass \f(CW\*(C`NamedFile\*(C'\fR
of \f(CW\*(C`Name\*(C'\fR and the class \f(CW\*(C`IO::File\*(C'\fR (whose objects \fImust\fR be globrefs).
.PP
Thus, techniques are of interest that store object data \fInot\fR in
the object body but some other place.
.SS "The Inside-out Technique"
.IX Subsection "The Inside-out Technique"
With \fIinside-out\fR classes, each class declares a (typically lexical)
hash for each field it wants to use.  The reference address of an
object is used as the hash key.  By definition, the reference address
is unique to each object so this guarantees a place for each field that
is private to the class and unique to each object.  See \f(CW\*(C`Name_id\*(C'\fR
in \*(L"Example 1\*(R" for a simple example.
.PP
In comparison to the standard implementation where the object is a
hash and the fields correspond to hash keys, here the fields correspond
to hashes, and the object determines the hash key.  Thus the hashes
appear to be turned \fIinside out\fR.
.PP
The body of an object is never examined by an inside-out class, only
its reference address is used.  This allows for the body of an actual
object to be \fIanything at all\fR while the object methods of the class
still work as designed.  This is a key feature of inside-out classes.
.SS "Problems of Inside-out"
.IX Subsection "Problems of Inside-out"
Inside-out classes give us freedom of inheritance, but as usual there
is a price.
.PP
Most obviously, there is the necessity of retrieving the reference
address of an object for each data access.  It's a minor inconvenience,
but it does clutter the code.
.PP
More important (and less obvious) is the necessity of garbage
collection.  When a normal object dies, anything stored in the
object body is garbage-collected by perl.  With inside-out objects,
Perl knows nothing about the data stored in field hashes by a class,
but these must be deleted when the object goes out of scope.  Thus
the class must provide a \f(CW\*(C`DESTROY\*(C'\fR method to take care of that.
.PP
In the presence of multiple classes it can be non-trivial
to make sure that every relevant destructor is called for
every object.  Perl calls the first one it finds on the
inheritance tree (if any) and that's it.
.PP
A related issue is thread-safety.  When a new thread is created,
the Perl interpreter is cloned, which implies that all reference
addresses in use will be replaced with new ones.  Thus, if a class
tries to access a field of a cloned object its (cloned) data will
still be stored under the now invalid reference address of the
original in the parent thread.  A general \f(CW\*(C`CLONE\*(C'\fR method must
be provided to re-establish the association.
.SS "Solutions"
.IX Subsection "Solutions"
\&\f(CW\*(C`Hash::Util::FieldHash\*(C'\fR addresses these issues on several
levels.
.PP
The \f(CW\*(C`id()\*(C'\fR function is provided in addition to the
existing \f(CW\*(C`Scalar::Util::refaddr()\*(C'\fR.  Besides its short name
it can be a little faster under some circumstances (and a
bit slower under others).  Benchmark if it matters.  The
working of \f(CW\*(C`id()\*(C'\fR also allows the use of the class name
as a \fIgeneric object\fR as described further down.
.PP
The \f(CW\*(C`id()\*(C'\fR function is incorporated in \fIid hashes\fR in the sense
that it is called automatically on every key that is used with
the hash.  No explicit call is necessary.
.PP
The problems of garbage collection and thread safety are both
addressed by the function \f(CW\*(C`register()\*(C'\fR.  It registers an object
together with any number of hashes.  Registry means that when the
object dies, an entry in any of the hashes under the reference
address of this object will be deleted.  This guarantees garbage
collection in these hashes.  It also means that on thread
cloning the object's entries in registered hashes will be
replaced with updated entries whose key is the cloned object's
reference address.  Thus the object-data association becomes
thread-safe.
.PP
Object registry is best done when the object is initialized
for use with a class.  That way, garbage collection and thread
safety are established for every object and every field that is
initialized.
.PP
Finally, \fIfield hashes\fR incorporate all these functions in one
package.  Besides automatically calling the \f(CW\*(C`id()\*(C'\fR function
on every object used as a key, the object is registered with
the field hash on first use.  Classes based on field hashes
are fully garbage-collected and thread safe without further
measures.
.SS "More Problems"
.IX Subsection "More Problems"
Another problem that occurs with inside-out classes is serialization.
Since the object data is not in its usual place, standard routines
like \f(CW\*(C`Storable::freeze()\*(C'\fR, \f(CW\*(C`Storable::thaw()\*(C'\fR and 
\&\f(CW\*(C`Data::Dumper::Dumper()\*(C'\fR can't deal with it on their own.  Both
\&\f(CW\*(C`Data::Dumper\*(C'\fR and \f(CW\*(C`Storable\*(C'\fR provide the necessary hooks to
make things work, but the functions or methods used by the hooks
must be provided by each inside-out class.
.PP
A general solution to the serialization problem would require another
level of registry, one that that associates \fIclasses\fR and fields.
So far, the functions of \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR are unaware of
any classes, which I consider a feature.  Therefore \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR
doesn't address the serialization problems.
.SS "The Generic Object"
.IX Subsection "The Generic Object"
Classes based on the \f(CW\*(C`id()\*(C'\fR function (and hence classes based on
\&\f(CW\*(C`idhash()\*(C'\fR and \f(CW\*(C`fieldhash()\*(C'\fR) show a peculiar behavior in that
the class name can be used like an object.  Specifically, methods
that set or read data associated with an object continue to work as
class methods, just as if the class name were an object, distinct from
all other objects, with its own data.  This object may be called
the \fIgeneric object\fR of the class.
.PP
This works because field hashes respond to keys that are not references
like a normal hash would and use the string offered as the hash key.
Thus, if a method is called as a class method, the field hash is presented
with the class name instead of an object and blithely uses it as a key.
Since the keys of real objects are decimal numbers, there is no
conflict and the slot in the field hash can be used like any other.
The \f(CW\*(C`id()\*(C'\fR function behaves correspondingly with respect to non-reference
arguments.
.PP
Two possible uses (besides ignoring the property) come to mind.
A singleton class could be implemented this using the generic object.
If necessary, an \f(CW\*(C`init()\*(C'\fR method could die or ignore calls with
actual objects (references), so only the generic object will ever exist.
.PP
Another use of the generic object would be as a template.  It is
a convenient place to store class-specific defaults for various
fields to be used in actual object initialization.
.PP
Usually, the feature can be entirely ignored.  Calling \fIobject
methods\fR as \fIclass methods\fR normally leads to an error and isn't used
routinely anywhere.  It may be a problem that this error isn't
indicated by a class with a generic object.
.SS "How to use Field Hashes"
.IX Subsection "How to use Field Hashes"
Traditionally, the definition of an inside-out class contains a bare
block inside which a number of lexical hashes are declared and the
basic accessor methods defined, usually through \f(CW\*(C`Scalar::Util::refaddr\*(C'\fR.
Further methods may be defined outside this block.  There has to be
a \s-1DESTROY\s0 method and, for thread support, a \s-1CLONE\s0 method.
.PP
When field hashes are used, the basic structure remains the same.
Each lexical hash will be made a field hash.  The call to \f(CW\*(C`refaddr\*(C'\fR
can be omitted from the accessor methods.  \s-1DESTROY\s0 and \s-1CLONE\s0 methods
are not necessary.
.PP
If you have an existing inside-out class, simply making all hashes
field hashes with no other change should make no difference.  Through
the calls to \f(CW\*(C`refaddr\*(C'\fR or equivalent, the field hashes never get to
see a reference and work like normal hashes.  Your \s-1DESTROY\s0 (and
\&\s-1CLONE\s0) methods are still needed.
.PP
To make the field hashes kick in, it is easiest to redefine \f(CW\*(C`refaddr\*(C'\fR
as
.PP
.Vb 1
\&    sub refaddr { shift }
.Ve
.PP
instead of importing it from \f(CW\*(C`Scalar::Util\*(C'\fR.  It should now be possible
to disable \s-1DESTROY\s0 and \s-1CLONE\s0.  Note that while it isn't disabled,
\&\s-1DESTROY\s0 will be called before the garbage collection of field hashes,
so it will be invoked with a functional object and will continue to
function.
.PP
It is not desirable to import the functions \f(CW\*(C`fieldhash\*(C'\fR and/or
\&\f(CW\*(C`fieldhashes\*(C'\fR into every class that is going to use them.  They
are only used once to set up the class.  When the class is up and running,
these functions serve no more purpose.
.PP
If there are only a few field hashes to declare, it is simplest to
.PP
.Vb 1
\&    use Hash::Util::FieldHash;
.Ve
.PP
early and call the functions qualified:
.PP
.Vb 1
\&    Hash::Util::FieldHash::fieldhash my %foo;
.Ve
.PP
Otherwise, import the functions into a convenient package like
\&\f(CW\*(C`HUF\*(C'\fR or, more general, \f(CW\*(C`Aux\*(C'\fR
.PP
.Vb 4
\&    {
\&        package Aux;
\&        use Hash::Util::FieldHash \*(Aq:all\*(Aq;
\&    }
.Ve
.PP
and call
.PP
.Vb 1
\&    Aux::fieldhash my %foo;
.Ve
.PP
as needed.
.SS "Garbage-Collected Hashes"
.IX Subsection "Garbage-Collected Hashes"
Garbage collection in a field hash means that entries will \*(L"spontaneously\*(R"
disappear when the object that created them disappears.  That must be
borne in mind, especially when looping over a field hash.  If anything
you do inside the loop could cause an object to go out of scope, a
random key may be deleted from the hash you are looping over.  That
can throw the loop iterator, so it's best to cache a consistent snapshot
of the keys and/or values and loop over that.  You will still have to
check that a cached entry still exists when you get to it.
.PP
Garbage collection can be confusing when keys are created in a field hash
from normal scalars as well as references.  Once a reference is \fIused\fR with
a field hash, the entry will be collected, even if it was later overwritten
with a plain scalar key (every positive integer is a candidate).  This
is true even if the original entry was deleted in the meantime.  In fact,
deletion from a field hash, and also a test for existence constitute
\&\fIuse\fR in this sense and create a liability to delete the entry when
the reference goes out of scope.  If you happen to create an entry
with an identical key from a string or integer, that will be collected
instead.  Thus, mixed use of references and plain scalars as field hash
keys is not entirely supported.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
The examples show a very simple class that implements a \fIname\fR, consisting
of a first and last name (no middle initial).  The name class has four
methods:
.IP "\(bu" 4
\&\f(CW\*(C`init()\*(C'\fR
.Sp
An object method that initializes the first and last name to its
two arguments. If called as a class method, \f(CW\*(C`init()\*(C'\fR creates an
object in the given class and initializes that.
.IP "\(bu" 4
\&\f(CW\*(C`first()\*(C'\fR
.Sp
Retrieve the first name
.IP "\(bu" 4
\&\f(CW\*(C`last()\*(C'\fR
.Sp
Retrieve the last name
.IP "\(bu" 4
\&\f(CW\*(C`name()\*(C'\fR
.Sp
Retrieve the full name, the first and last name joined by a blank.
.PP
The examples show this class implemented with different levels of
support by \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR.  All supported combinations
are shown.  The difference between implementations is often quite
small.  The implementations are:
.IP "\(bu" 4
\&\f(CW\*(C`Name_hash\*(C'\fR
.Sp
A conventional (not inside-out) implementation where an object is
a hash that stores the field values, without support by
\&\f(CW\*(C`Hash::Util::FieldHash\*(C'\fR.  This implementation doesn't allow
arbitrary inheritance.
.IP "\(bu" 4
\&\f(CW\*(C`Name_id\*(C'\fR
.Sp
Inside-out implementation based on the \f(CW\*(C`id()\*(C'\fR function.  It needs
a \f(CW\*(C`DESTROY\*(C'\fR method.  For thread support a \f(CW\*(C`CLONE\*(C'\fR method (not shown)
would also be needed.  Instead of \f(CW\*(C`Hash::Util::FieldHash::id()\*(C'\fR the
function \f(CW\*(C`Scalar::Util::refaddr\*(C'\fR could be used with very little
functional difference.  This is the basic pattern of an inside-out
class.
.IP "\(bu" 4
\&\f(CW\*(C`Name_idhash\*(C'\fR
.Sp
Idhash-based inside-out implementation.  Like \f(CW\*(C`Name_id\*(C'\fR it needs
a \f(CW\*(C`DESTROY\*(C'\fR method and would need \f(CW\*(C`CLONE\*(C'\fR for thread support.
.IP "\(bu" 4
\&\f(CW\*(C`Name_id_reg\*(C'\fR
.Sp
Inside-out implementation based on the \f(CW\*(C`id()\*(C'\fR function with explicit
object registry.  No destructor is needed and objects are thread safe.
.IP "\(bu" 4
\&\f(CW\*(C`Name_idhash_reg\*(C'\fR
.Sp
Idhash-based inside-out implementation with explicit object registry.
No destructor is needed and objects are thread safe.
.IP "\(bu" 4
\&\f(CW\*(C`Name_fieldhash\*(C'\fR
.Sp
FieldHash-based inside-out implementation.  Object registry happens
automatically.  No destructor is needed and objects are thread safe.
.PP
These examples are realized in the code below, which could be copied
to a file \fIExample.pm\fR.
.SS "Example 1"
.IX Subsection "Example 1"
.Vb 1
\&    use strict; use warnings;
\&
\&    {
\&        package Name_hash; # standard implementation: the object is a hash
\&
\&        sub init {
\&            my $obj = shift;
\&            my ($first, $last) = @_;
\&            # create an object if called as class method
\&            $obj = bless {}, $obj unless ref $obj;
\&            $obj\->{ first} = $first;
\&            $obj\->{ last} = $last;
\&            $obj;
\&        }
\&
\&        sub first { shift()\->{ first} }
\&        sub last { shift()\->{ last} }
\&
\&        sub name {
\&            my $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&
\&    }
\&
\&    {
\&        package Name_id;
\&        use Hash::Util::FieldHash qw(id);
\&
\&        my (%first, %last);
\&
\&        sub init {
\&            my $obj = shift;
\&            my ($first, $last) = @_;
\&            # create an object if called as class method
\&            $obj = bless \e my $o, $obj unless ref $obj;
\&            $first{ id $obj} = $first;
\&            $last{ id $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ id shift()} }
\&        sub last { $last{ id shift()} }
\&
\&        sub name {
\&            my $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&
\&        sub DESTROY {
\&            my $id = id shift;
\&            delete $first{ $id};
\&            delete $last{ $id};
\&        }
\&
\&    }
\&
\&    {
\&        package Name_idhash;
\&        use Hash::Util::FieldHash;
\&
\&        Hash::Util::FieldHash::idhashes( \e my (%first, %last) );
\&
\&        sub init {
\&            my $obj = shift;
\&            my ($first, $last) = @_;
\&            # create an object if called as class method
\&            $obj = bless \e my $o, $obj unless ref $obj;
\&            $first{ $obj} = $first;
\&            $last{ $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ shift()} }
\&        sub last { $last{ shift()} }
\&
\&        sub name {
\&            my $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&
\&        sub DESTROY {
\&            my $n = shift;
\&            delete $first{ $n};
\&            delete $last{ $n};
\&        }
\&
\&    }
\&
\&    {
\&        package Name_id_reg;
\&        use Hash::Util::FieldHash qw(id register);
\&
\&        my (%first, %last);
\&
\&        sub init {
\&            my $obj = shift;
\&            my ($first, $last) = @_;
\&            # create an object if called as class method
\&            $obj = bless \e my $o, $obj unless ref $obj;
\&            register( $obj, \e (%first, %last) );
\&            $first{ id $obj} = $first;
\&            $last{ id $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ id shift()} }
\&        sub last { $last{ id shift()} }
\&
\&        sub name {
\&            my $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&    }
\&
\&    {
\&        package Name_idhash_reg;
\&        use Hash::Util::FieldHash qw(register);
\&
\&        Hash::Util::FieldHash::idhashes \e my (%first, %last);
\&
\&        sub init {
\&            my $obj = shift;
\&            my ($first, $last) = @_;
\&            # create an object if called as class method
\&            $obj = bless \e my $o, $obj unless ref $obj;
\&            register( $obj, \e (%first, %last) );
\&            $first{ $obj} = $first;
\&            $last{ $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ shift()} }
\&        sub last { $last{ shift()} }
\&
\&        sub name {
\&            my $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&    }
\&
\&    {
\&        package Name_fieldhash;
\&        use Hash::Util::FieldHash;
\&
\&        Hash::Util::FieldHash::fieldhashes \e my (%first, %last);
\&
\&        sub init {
\&            my $obj = shift;
\&            my ($first, $last) = @_;
\&            # create an object if called as class method
\&            $obj = bless \e my $o, $obj unless ref $obj;
\&            $first{ $obj} = $first;
\&            $last{ $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ shift()} }
\&        sub last { $last{ shift()} }
\&
\&        sub name {
\&            my $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&    }
\&
\&    1;
.Ve
.PP
To exercise the various implementations the script below can
be used.
.PP
It sets up a class \f(CW\*(C`Name\*(C'\fR that is a mirror of one of the implementation
classes \f(CW\*(C`Name_hash\*(C'\fR, \f(CW\*(C`Name_id\*(C'\fR, ..., \f(CW\*(C`Name_fieldhash\*(C'\fR.  That determines
which implementation is run.
.PP
The script first verifies the function of the \f(CW\*(C`Name\*(C'\fR class.
.PP
In the second step, the free inheritability of the implementation
(or lack thereof) is demonstrated.  For this purpose it constructs
a class called \f(CW\*(C`NamedFile\*(C'\fR which is a common subclass of \f(CW\*(C`Name\*(C'\fR and
the standard class \f(CW\*(C`IO::File\*(C'\fR.  This puts inheritability to the test
because objects of \f(CW\*(C`IO::File\*(C'\fR \fImust\fR be globrefs.  Objects of \f(CW\*(C`NamedFile\*(C'\fR
should behave like a file opened for reading and also support the \f(CW\*(C`name()\*(C'\fR
method.  This class juncture works with exception of the \f(CW\*(C`Name_hash\*(C'\fR
implementation, where object initialization fails because of the
incompatibility of object bodies.
.SS "Example 2"
.IX Subsection "Example 2"
.Vb 1
\&    use strict; use warnings; $| = 1;
\&
\&    use Example;
\&
\&    {
\&        package Name;
\&        use base \*(AqName_id\*(Aq;      # define here which implementation to run
\&    }
\&
\&
\&    # Verify that the base package works
\&    my $n = Name\->init(qw(Albert Einstein));
\&    print $n\->name, "\en";
\&    print "\en";
\&
\&    # Create a named file handle (See definition below)
\&    my $nf = NamedFile\->init(qw(/tmp/x Filomena File));
\&    # use as a file handle...
\&    for ( 1 .. 3 ) {
\&        my $l = <$nf>;
\&        print "line $_: $l";
\&    }
\&    # ...and as a Name object
\&    print "...brought to you by ", $nf\->name, "\en";
\&    exit;
\&
\&
\&    # Definition of NamedFile
\&    package NamedFile;
\&    use base \*(AqName\*(Aq;
\&    use base \*(AqIO::File\*(Aq;
\&
\&    sub init {
\&        my $obj = shift;
\&        my ($file, $first, $last) = @_;
\&        $obj = $obj\->IO::File::new() unless ref $obj;
\&        $obj\->open($file) or die "Can\*(Aqt read \*(Aq$file\*(Aq: $!";
\&        $obj\->Name::init($first, $last);
\&    }
\&    _\|_END_\|_
.Ve
.SH "GUTS"
.IX Header "GUTS"
To make \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR work, there were two changes to
\&\fIperl\fR itself.  \f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR was made available for hashes,
and weak references now call uvar \f(CW\*(C`get\*(C'\fR magic after a weakref has been
cleared.  The first feature is used to make field hashes intercept
their keys upon access.  The second one triggers garbage collection.
.ie n .SS "The ""PERL_MAGIC_uvar"" interface for hashes"
.el .SS "The \f(CWPERL_MAGIC_uvar\fP interface for hashes"
.IX Subsection "The PERL_MAGIC_uvar interface for hashes"
\&\f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR \fIget\fR magic is called from \f(CW\*(C`hv_fetch_common\*(C'\fR and
\&\f(CW\*(C`hv_delete_common\*(C'\fR through the function \f(CW\*(C`hv_magic_uvar_xkey\*(C'\fR, which
defines the interface.  The call happens for hashes with \*(L"uvar\*(R" magic
if the \f(CW\*(C`ufuncs\*(C'\fR structure has equal values in the \f(CW\*(C`uf_val\*(C'\fR and \f(CW\*(C`uf_set\*(C'\fR
fields.  Hashes are unaffected if (and as long as) these fields
hold different values.
.PP
Upon the call, the \f(CW\*(C`mg_obj\*(C'\fR field will hold the hash key to be accessed.
Upon return, the \f(CW\*(C`SV*\*(C'\fR value in \f(CW\*(C`mg_obj\*(C'\fR will be used in place of the
original key in the hash access.  The integer index value in the first
parameter will be the \f(CW\*(C`action\*(C'\fR value from \f(CW\*(C`hv_fetch_common\*(C'\fR, or \-1
if the call is from \f(CW\*(C`hv_delete_common\*(C'\fR.
.PP
This is a template for a function suitable for the \f(CW\*(C`uf_val\*(C'\fR field in
a \f(CW\*(C`ufuncs\*(C'\fR structure for this call.  The \f(CW\*(C`uf_set\*(C'\fR and \f(CW\*(C`uf_index\*(C'\fR
fields are irrelevant.
.PP
.Vb 10
\&    IV watch_key(pTHX_ IV action, SV* field) {
\&        MAGIC* mg = mg_find(field, PERL_MAGIC_uvar);
\&        SV* keysv = mg\->mg_obj;
\&        /* Do whatever you need to.  If you decide to
\&           supply a different key newkey, return it like this
\&        */
\&        sv_2mortal(newkey);
\&        mg\->mg_obj = newkey;
\&        return 0;
\&    }
.Ve
.SS "Weakrefs call uvar magic"
.IX Subsection "Weakrefs call uvar magic"
When a weak reference is stored in an \f(CW\*(C`SV\*(C'\fR that has \*(L"uvar\*(R" magic, \f(CW\*(C`set\*(C'\fR
magic is called after the reference has gone stale.  This hook can be
used to trigger further garbage-collection activities associated with
the referenced object.
.SS "How field hashes work"
.IX Subsection "How field hashes work"
The three features of key hashes, \fIkey replacement\fR, \fIthread support\fR,
and \fIgarbage collection\fR are supported by a data structure called
the \fIobject registry\fR.  This is a private hash where every object
is stored.  An \*(L"object\*(R" in this sense is any reference (blessed or
unblessed) that has been used as a field hash key.
.PP
The object registry keeps track of references that have been used as
field hash keys.  The keys are generated from the reference address
like in a field hash (though the registry isn't a field hash).  Each
value is a weak copy of the original reference, stored in an \f(CW\*(C`SV\*(C'\fR that
is itself magical (\f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR again).  The magical structure
holds a list (another hash, really) of field hashes that the reference
has been used with.  When the weakref becomes stale, the magic is
activated and uses the list to delete the reference from all field
hashes it has been used with.  After that, the entry is removed from
the object registry itself.  Implicitly, that frees the magic structure
and the storage it has been using.
.PP
Whenever a reference is used as a field hash key, the object registry
is checked and a new entry is made if necessary.  The field hash is
then added to the list of fields this reference has used.
.PP
The object registry is also used to repair a field hash after thread
cloning.  Here, the entire object registry is processed.  For every
reference found there, the field hashes it has used are visited and
the entry is updated.
.SS "Internal function Hash::Util::FieldHash::_fieldhash"
.IX Subsection "Internal function Hash::Util::FieldHash::_fieldhash"
.Vb 2
\&    # test if %hash is a field hash
\&    my $result = _fieldhash \e %hash, 0;
\&
\&    # make %hash a field hash
\&    my $result = _fieldhash \e %hash, 1;
.Ve
.PP
\&\f(CW\*(C`_fieldhash\*(C'\fR is the internal function used to create field hashes.
It takes two arguments, a hashref and a mode.  If the mode is boolean
false, the hash is not changed but tested if it is a field hash.  If
the hash isn't a field hash the return value is boolean false.  If it
is, the return value indicates the mode of field hash.  When called with
a boolean true mode, it turns the given hash into a field hash of this
mode, returning the mode of the created field hash.  \f(CW\*(C`_fieldhash\*(C'\fR
does not erase the given hash.
.PP
Currently there is only one type of field hash, and only the boolean
value of the mode makes a difference, but that may change.
.SH "AUTHOR"
.IX Header "AUTHOR"
Anno Siegel (\s-1ANNO\s0) wrote the xs code and the changes in perl proper
Jerry Hedden (\s-1JDHEDDEN\s0) made it faster
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007 by (Anno Siegel)
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.7 or,
at your option, any later version of Perl 5 you may have available.
                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Hash::Util::FieldHash5.18.3pm                0100644 0001750 0001750 00000107256 12566207455 025475  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Hash::Util::FieldHash 3pm"
.TH Hash::Util::FieldHash 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Hash::Util::FieldHash \- Support for Inside\-Out Classes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  ### Create fieldhashes
\&  use Hash::Util qw(fieldhash fieldhashes);
\&
\&  # Create a single field hash
\&  fieldhash my %foo;
\&
\&  # Create three at once...
\&  fieldhashes \e my(%foo, %bar, %baz);
\&  # ...or any number
\&  fieldhashes @hashrefs;
\&
\&  ### Create an idhash and register it for garbage collection
\&  use Hash::Util::FieldHash qw(idhash register);
\&  idhash my %name;
\&  my $object = \e do { my $o };
\&  # register the idhash for garbage collection with $object
\&  register($object, \e %name);
\&  # the following entry will be deleted when $object goes out of scope
\&  $name{$object} = \*(AqJohn Doe\*(Aq;
\&
\&  ### Register an ordinary hash for garbage collection
\&  use Hash::Util::FieldHash qw(id register);
\&  my %name;
\&  my $object = \e do { my $o };
\&  # register the hash %name for garbage collection of $object\*(Aqs id
\&  register $object, \e %name;
\&  # the following entry will be deleted when $object goes out of scope
\&  $name{id $object} = \*(AqJohn Doe\*(Aq;
.Ve
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
\&\f(CW\*(C`Hash::Util::FieldHash\*(C'\fR offers a number of functions in support of
\&\*(L"The Inside-out Technique\*(R" of class construction.
.IP "id" 4
.IX Item "id"
.Vb 1
\&    id($obj)
.Ve
.Sp
Returns the reference address of a reference \f(CW$obj\fR.  If \f(CW$obj\fR is
not a reference, returns \f(CW$obj\fR.
.Sp
This function is a stand-in replacement for
Scalar::Util::refaddr, that is, it returns
the reference address of its argument as a numeric value.  The only
difference is that \f(CW\*(C`refaddr()\*(C'\fR returns \f(CW\*(C`undef\*(C'\fR when given a
non-reference while \f(CW\*(C`id()\*(C'\fR returns its argument unchanged.
.Sp
\&\f(CW\*(C`id()\*(C'\fR also uses a caching technique that makes it faster when
the id of an object is requested often, but slower if it is needed
only once or twice.
.IP "id_2obj" 4
.IX Item "id_2obj"
.Vb 1
\&    $obj = id_2obj($id)
.Ve
.Sp
If \f(CW$id\fR is the id of a registered object (see \*(L"register\*(R"), returns
the object, otherwise an undefined value.  For registered objects this
is the inverse function of \f(CW\*(C`id()\*(C'\fR.
.IP "register" 4
.IX Item "register"
.Vb 2
\&    register($obj)
\&    register($obj, @hashrefs)
.Ve
.Sp
In the first form, registers an object to work with for the function
\&\f(CW\*(C`id_2obj()\*(C'\fR.  In the second form, it additionally marks the given
hashrefs down for garbage collection.  This means that when the object
goes out of scope, any entries in the given hashes under the key of
\&\f(CW\*(C`id($obj)\*(C'\fR will be deleted from the hashes.
.Sp
It is a fatal error to register a non-reference \f(CW$obj\fR.  Any non-hashrefs
among the following arguments are silently ignored.
.Sp
It is \fInot\fR an error to register the same object multiple times with
varying sets of hashrefs.  Any hashrefs that are not registered yet
will be added, others ignored.
.Sp
Registry also implies thread support.  When a new thread is created,
all references are replaced with new ones, including all objects.
If a hash uses the reference address of an object as a key, that
connection would be broken.  With a registered object, its id will
be updated in all hashes registered with it.
.IP "idhash" 4
.IX Item "idhash"
.Vb 1
\&    idhash my %hash
.Ve
.Sp
Makes an idhash from the argument, which must be a hash.
.Sp
An \fIidhash\fR works like a normal hash, except that it stringifies a
\&\fIreference used as a key\fR differently.  A reference is stringified
as if the \f(CW\*(C`id()\*(C'\fR function had been invoked on it, that is, its
reference address in decimal is used as the key.
.IP "idhashes" 4
.IX Item "idhashes"
.Vb 2
\&    idhashes \e my(%hash, %gnash, %trash)
\&    idhashes \e @hashrefs
.Ve
.Sp
Creates many idhashes from its hashref arguments.  Returns those
arguments that could be converted or their number in scalar context.
.IP "fieldhash" 4
.IX Item "fieldhash"
.Vb 1
\&    fieldhash %hash;
.Ve
.Sp
Creates a single fieldhash.  The argument must be a hash.  Returns
a reference to the given hash if successful, otherwise nothing.
.Sp
A \fIfieldhash\fR is, in short, an idhash with auto-registry.  When an
object (or, indeed, any reference) is used as a fieldhash key, the
fieldhash is automatically registered for garbage collection with
the object, as if \f(CW\*(C`register $obj, \e %fieldhash\*(C'\fR had been called.
.IP "fieldhashes" 4
.IX Item "fieldhashes"
.Vb 1
\&    fieldhashes @hashrefs;
.Ve
.Sp
Creates any number of field hashes.  Arguments must be hash references.
Returns the converted hashrefs in list context, their number in scalar
context.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A word on terminology:  I shall use the term \fIfield\fR for a scalar
piece of data that a class associates with an object.  Other terms that
have been used for this concept are \*(L"object variable\*(R", \*(L"(object) property\*(R",
\&\*(L"(object) attribute\*(R" and more.  Especially \*(L"attribute\*(R" has some currency
among Perl programmer, but that clashes with the \f(CW\*(C`attributes\*(C'\fR pragma.  The
term \*(L"field\*(R" also has some currency in this sense and doesn't seem
to conflict with other Perl terminology.
.PP
In Perl, an object is a blessed reference.  The standard way of associating
data with an object is to store the data inside the object's body, that is,
the piece of data pointed to by the reference.
.PP
In consequence, if two or more classes want to access an object they
\&\fImust\fR agree on the type of reference and also on the organization of
data within the object body.  Failure to agree on the type results in
immediate death when the wrong method tries to access an object.  Failure
to agree on data organization may lead to one class trampling over the
data of another.
.PP
This object model leads to a tight coupling between subclasses.
If one class wants to inherit from another (and both classes access
object data), the classes must agree about implementation details.
Inheritance can only be used among classes that are maintained together,
in a single source or not.
.PP
In particular, it is not possible to write general-purpose classes
in this technique, classes that can advertise themselves as \*(L"Put me
on your \f(CW@ISA\fR list and use my methods\*(R".  If the other class has different
ideas about how the object body is used, there is trouble.
.PP
For reference \f(CW\*(C`Name_hash\*(C'\fR in \*(L"Example 1\*(R" shows the standard implementation of
a simple class \f(CW\*(C`Name\*(C'\fR in the well-known hash based way.  It also demonstrates
the predictable failure to construct a common subclass \f(CW\*(C`NamedFile\*(C'\fR
of \f(CW\*(C`Name\*(C'\fR and the class \f(CW\*(C`IO::File\*(C'\fR (whose objects \fImust\fR be globrefs).
.PP
Thus, techniques are of interest that store object data \fInot\fR in
the object body but some other place.
.SS "The Inside-out Technique"
.IX Subsection "The Inside-out Technique"
With \fIinside-out\fR classes, each class declares a (typically lexical)
hash for each field it wants to use.  The reference address of an
object is used as the hash key.  By definition, the reference address
is unique to each object so this guarantees a place for each field that
is private to the class and unique to each object.  See \f(CW\*(C`Name_id\*(C'\fR
in \*(L"Example 1\*(R" for a simple example.
.PP
In comparison to the standard implementation where the object is a
hash and the fields correspond to hash keys, here the fields correspond
to hashes, and the object determines the hash key.  Thus the hashes
appear to be turned \fIinside out\fR.
.PP
The body of an object is never examined by an inside-out class, only
its reference address is used.  This allows for the body of an actual
object to be \fIanything at all\fR while the object methods of the class
still work as designed.  This is a key feature of inside-out classes.
.SS "Problems of Inside-out"
.IX Subsection "Problems of Inside-out"
Inside-out classes give us freedom of inheritance, but as usual there
is a price.
.PP
Most obviously, there is the necessity of retrieving the reference
address of an object for each data access.  It's a minor inconvenience,
but it does clutter the code.
.PP
More important (and less obvious) is the necessity of garbage
collection.  When a normal object dies, anything stored in the
object body is garbage-collected by perl.  With inside-out objects,
Perl knows nothing about the data stored in field hashes by a class,
but these must be deleted when the object goes out of scope.  Thus
the class must provide a \f(CW\*(C`DESTROY\*(C'\fR method to take care of that.
.PP
In the presence of multiple classes it can be non-trivial
to make sure that every relevant destructor is called for
every object.  Perl calls the first one it finds on the
inheritance tree (if any) and that's it.
.PP
A related issue is thread-safety.  When a new thread is created,
the Perl interpreter is cloned, which implies that all reference
addresses in use will be replaced with new ones.  Thus, if a class
tries to access a field of a cloned object its (cloned) data will
still be stored under the now invalid reference address of the
original in the parent thread.  A general \f(CW\*(C`CLONE\*(C'\fR method must
be provided to re-establish the association.
.SS "Solutions"
.IX Subsection "Solutions"
\&\f(CW\*(C`Hash::Util::FieldHash\*(C'\fR addresses these issues on several
levels.
.PP
The \f(CW\*(C`id()\*(C'\fR function is provided in addition to the
existing \f(CW\*(C`Scalar::Util::refaddr()\*(C'\fR.  Besides its short name
it can be a little faster under some circumstances (and a
bit slower under others).  Benchmark if it matters.  The
working of \f(CW\*(C`id()\*(C'\fR also allows the use of the class name
as a \fIgeneric object\fR as described further down.
.PP
The \f(CW\*(C`id()\*(C'\fR function is incorporated in \fIid hashes\fR in the sense
that it is called automatically on every key that is used with
the hash.  No explicit call is necessary.
.PP
The problems of garbage collection and thread safety are both
addressed by the function \f(CW\*(C`register()\*(C'\fR.  It registers an object
together with any number of hashes.  Registry means that when the
object dies, an entry in any of the hashes under the reference
address of this object will be deleted.  This guarantees garbage
collection in these hashes.  It also means that on thread
cloning the object's entries in registered hashes will be
replaced with updated entries whose key is the cloned object's
reference address.  Thus the object-data association becomes
thread-safe.
.PP
Object registry is best done when the object is initialized
for use with a class.  That way, garbage collection and thread
safety are established for every object and every field that is
initialized.
.PP
Finally, \fIfield hashes\fR incorporate all these functions in one
package.  Besides automatically calling the \f(CW\*(C`id()\*(C'\fR function
on every object used as a key, the object is registered with
the field hash on first use.  Classes based on field hashes
are fully garbage-collected and thread safe without further
measures.
.SS "More Problems"
.IX Subsection "More Problems"
Another problem that occurs with inside-out classes is serialization.
Since the object data is not in its usual place, standard routines
like \f(CW\*(C`Storable::freeze()\*(C'\fR, \f(CW\*(C`Storable::thaw()\*(C'\fR and 
\&\f(CW\*(C`Data::Dumper::Dumper()\*(C'\fR can't deal with it on their own.  Both
\&\f(CW\*(C`Data::Dumper\*(C'\fR and \f(CW\*(C`Storable\*(C'\fR provide the necessary hooks to
make things work, but the functions or methods used by the hooks
must be provided by each inside-out class.
.PP
A general solution to the serialization problem would require another
level of registry, one that that associates \fIclasses\fR and fields.
So far, the functions of \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR are unaware of
any classes, which I consider a feature.  Therefore \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR
doesn't address the serialization problems.
.SS "The Generic Object"
.IX Subsection "The Generic Object"
Classes based on the \f(CW\*(C`id()\*(C'\fR function (and hence classes based on
\&\f(CW\*(C`idhash()\*(C'\fR and \f(CW\*(C`fieldhash()\*(C'\fR) show a peculiar behavior in that
the class name can be used like an object.  Specifically, methods
that set or read data associated with an object continue to work as
class methods, just as if the class name were an object, distinct from
all other objects, with its own data.  This object may be called
the \fIgeneric object\fR of the class.
.PP
This works because field hashes respond to keys that are not references
like a normal hash would and use the string offered as the hash key.
Thus, if a method is called as a class method, the field hash is presented
with the class name instead of an object and blithely uses it as a key.
Since the keys of real objects are decimal numbers, there is no
conflict and the slot in the field hash can be used like any other.
The \f(CW\*(C`id()\*(C'\fR function behaves correspondingly with respect to non-reference
arguments.
.PP
Two possible uses (besides ignoring the property) come to mind.
A singleton class could be implemented this using the generic object.
If necessary, an \f(CW\*(C`init()\*(C'\fR method could die or ignore calls with
actual objects (references), so only the generic object will ever exist.
.PP
Another use of the generic object would be as a template.  It is
a convenient place to store class-specific defaults for various
fields to be used in actual object initialization.
.PP
Usually, the feature can be entirely ignored.  Calling \fIobject
methods\fR as \fIclass methods\fR normally leads to an error and isn't used
routinely anywhere.  It may be a problem that this error isn't
indicated by a class with a generic object.
.SS "How to use Field Hashes"
.IX Subsection "How to use Field Hashes"
Traditionally, the definition of an inside-out class contains a bare
block inside which a number of lexical hashes are declared and the
basic accessor methods defined, usually through \f(CW\*(C`Scalar::Util::refaddr\*(C'\fR.
Further methods may be defined outside this block.  There has to be
a \s-1DESTROY\s0 method and, for thread support, a \s-1CLONE\s0 method.
.PP
When field hashes are used, the basic structure remains the same.
Each lexical hash will be made a field hash.  The call to \f(CW\*(C`refaddr\*(C'\fR
can be omitted from the accessor methods.  \s-1DESTROY\s0 and \s-1CLONE\s0 methods
are not necessary.
.PP
If you have an existing inside-out class, simply making all hashes
field hashes with no other change should make no difference.  Through
the calls to \f(CW\*(C`refaddr\*(C'\fR or equivalent, the field hashes never get to
see a reference and work like normal hashes.  Your \s-1DESTROY \s0(and
\&\s-1CLONE\s0) methods are still needed.
.PP
To make the field hashes kick in, it is easiest to redefine \f(CW\*(C`refaddr\*(C'\fR
as
.PP
.Vb 1
\&    sub refaddr { shift }
.Ve
.PP
instead of importing it from \f(CW\*(C`Scalar::Util\*(C'\fR.  It should now be possible
to disable \s-1DESTROY\s0 and \s-1CLONE. \s0 Note that while it isn't disabled,
\&\s-1DESTROY\s0 will be called before the garbage collection of field hashes,
so it will be invoked with a functional object and will continue to
function.
.PP
It is not desirable to import the functions \f(CW\*(C`fieldhash\*(C'\fR and/or
\&\f(CW\*(C`fieldhashes\*(C'\fR into every class that is going to use them.  They
are only used once to set up the class.  When the class is up and running,
these functions serve no more purpose.
.PP
If there are only a few field hashes to declare, it is simplest to
.PP
.Vb 1
\&    use Hash::Util::FieldHash;
.Ve
.PP
early and call the functions qualified:
.PP
.Vb 1
\&    Hash::Util::FieldHash::fieldhash my %foo;
.Ve
.PP
Otherwise, import the functions into a convenient package like
\&\f(CW\*(C`HUF\*(C'\fR or, more general, \f(CW\*(C`Aux\*(C'\fR
.PP
.Vb 4
\&    {
\&        package Aux;
\&        use Hash::Util::FieldHash \*(Aq:all\*(Aq;
\&    }
.Ve
.PP
and call
.PP
.Vb 1
\&    Aux::fieldhash my %foo;
.Ve
.PP
as needed.
.SS "Garbage-Collected Hashes"
.IX Subsection "Garbage-Collected Hashes"
Garbage collection in a field hash means that entries will \*(L"spontaneously\*(R"
disappear when the object that created them disappears.  That must be
borne in mind, especially when looping over a field hash.  If anything
you do inside the loop could cause an object to go out of scope, a
random key may be deleted from the hash you are looping over.  That
can throw the loop iterator, so it's best to cache a consistent snapshot
of the keys and/or values and loop over that.  You will still have to
check that a cached entry still exists when you get to it.
.PP
Garbage collection can be confusing when keys are created in a field hash
from normal scalars as well as references.  Once a reference is \fIused\fR with
a field hash, the entry will be collected, even if it was later overwritten
with a plain scalar key (every positive integer is a candidate).  This
is true even if the original entry was deleted in the meantime.  In fact,
deletion from a field hash, and also a test for existence constitute
\&\fIuse\fR in this sense and create a liability to delete the entry when
the reference goes out of scope.  If you happen to create an entry
with an identical key from a string or integer, that will be collected
instead.  Thus, mixed use of references and plain scalars as field hash
keys is not entirely supported.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
The examples show a very simple class that implements a \fIname\fR, consisting
of a first and last name (no middle initial).  The name class has four
methods:
.IP "\(bu" 4
\&\f(CW\*(C`init()\*(C'\fR
.Sp
An object method that initializes the first and last name to its
two arguments. If called as a class method, \f(CW\*(C`init()\*(C'\fR creates an
object in the given class and initializes that.
.IP "\(bu" 4
\&\f(CW\*(C`first()\*(C'\fR
.Sp
Retrieve the first name
.IP "\(bu" 4
\&\f(CW\*(C`last()\*(C'\fR
.Sp
Retrieve the last name
.IP "\(bu" 4
\&\f(CW\*(C`name()\*(C'\fR
.Sp
Retrieve the full name, the first and last name joined by a blank.
.PP
The examples show this class implemented with different levels of
support by \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR.  All supported combinations
are shown.  The difference between implementations is often quite
small.  The implementations are:
.IP "\(bu" 4
\&\f(CW\*(C`Name_hash\*(C'\fR
.Sp
A conventional (not inside-out) implementation where an object is
a hash that stores the field values, without support by
\&\f(CW\*(C`Hash::Util::FieldHash\*(C'\fR.  This implementation doesn't allow
arbitrary inheritance.
.IP "\(bu" 4
\&\f(CW\*(C`Name_id\*(C'\fR
.Sp
Inside-out implementation based on the \f(CW\*(C`id()\*(C'\fR function.  It needs
a \f(CW\*(C`DESTROY\*(C'\fR method.  For thread support a \f(CW\*(C`CLONE\*(C'\fR method (not shown)
would also be needed.  Instead of \f(CW\*(C`Hash::Util::FieldHash::id()\*(C'\fR the
function \f(CW\*(C`Scalar::Util::refaddr\*(C'\fR could be used with very little
functional difference.  This is the basic pattern of an inside-out
class.
.IP "\(bu" 4
\&\f(CW\*(C`Name_idhash\*(C'\fR
.Sp
Idhash-based inside-out implementation.  Like \f(CW\*(C`Name_id\*(C'\fR it needs
a \f(CW\*(C`DESTROY\*(C'\fR method and would need \f(CW\*(C`CLONE\*(C'\fR for thread support.
.IP "\(bu" 4
\&\f(CW\*(C`Name_id_reg\*(C'\fR
.Sp
Inside-out implementation based on the \f(CW\*(C`id()\*(C'\fR function with explicit
object registry.  No destructor is needed and objects are thread safe.
.IP "\(bu" 4
\&\f(CW\*(C`Name_idhash_reg\*(C'\fR
.Sp
Idhash-based inside-out implementation with explicit object registry.
No destructor is needed and objects are thread safe.
.IP "\(bu" 4
\&\f(CW\*(C`Name_fieldhash\*(C'\fR
.Sp
FieldHash-based inside-out implementation.  Object registry happens
automatically.  No destructor is needed and objects are thread safe.
.PP
These examples are realized in the code below, which could be copied
to a file \fIExample.pm\fR.
.SS "Example 1"
.IX Subsection "Example 1"
.Vb 1
\&    use strict; use warnings;
\&
\&    {
\&        package Name_hash; # standard implementation: the object is a hash
\&
\&        sub init {
\&            my $obj = shift;
\&            my ($first, $last) = @_;
\&            # create an object if called as class method
\&            $obj = bless {}, $obj unless ref $obj;
\&            $obj\->{ first} = $first;
\&            $obj\->{ last} = $last;
\&            $obj;
\&        }
\&
\&        sub first { shift()\->{ first} }
\&        sub last { shift()\->{ last} }
\&
\&        sub name {
\&            my $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&
\&    }
\&
\&    {
\&        package Name_id;
\&        use Hash::Util::FieldHash qw(id);
\&
\&        my (%first, %last);
\&
\&        sub init {
\&            my $obj = shift;
\&            my ($first, $last) = @_;
\&            # create an object if called as class method
\&            $obj = bless \e my $o, $obj unless ref $obj;
\&            $first{ id $obj} = $first;
\&            $last{ id $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ id shift()} }
\&        sub last { $last{ id shift()} }
\&
\&        sub name {
\&            my $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&
\&        sub DESTROY {
\&            my $id = id shift;
\&            delete $first{ $id};
\&            delete $last{ $id};
\&        }
\&
\&    }
\&
\&    {
\&        package Name_idhash;
\&        use Hash::Util::FieldHash;
\&
\&        Hash::Util::FieldHash::idhashes( \e my (%first, %last) );
\&
\&        sub init {
\&            my $obj = shift;
\&            my ($first, $last) = @_;
\&            # create an object if called as class method
\&            $obj = bless \e my $o, $obj unless ref $obj;
\&            $first{ $obj} = $first;
\&            $last{ $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ shift()} }
\&        sub last { $last{ shift()} }
\&
\&        sub name {
\&            my $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&
\&        sub DESTROY {
\&            my $n = shift;
\&            delete $first{ $n};
\&            delete $last{ $n};
\&        }
\&
\&    }
\&
\&    {
\&        package Name_id_reg;
\&        use Hash::Util::FieldHash qw(id register);
\&
\&        my (%first, %last);
\&
\&        sub init {
\&            my $obj = shift;
\&            my ($first, $last) = @_;
\&            # create an object if called as class method
\&            $obj = bless \e my $o, $obj unless ref $obj;
\&            register( $obj, \e (%first, %last) );
\&            $first{ id $obj} = $first;
\&            $last{ id $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ id shift()} }
\&        sub last { $last{ id shift()} }
\&
\&        sub name {
\&            my $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&    }
\&
\&    {
\&        package Name_idhash_reg;
\&        use Hash::Util::FieldHash qw(register);
\&
\&        Hash::Util::FieldHash::idhashes \e my (%first, %last);
\&
\&        sub init {
\&            my $obj = shift;
\&            my ($first, $last) = @_;
\&            # create an object if called as class method
\&            $obj = bless \e my $o, $obj unless ref $obj;
\&            register( $obj, \e (%first, %last) );
\&            $first{ $obj} = $first;
\&            $last{ $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ shift()} }
\&        sub last { $last{ shift()} }
\&
\&        sub name {
\&            my $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&    }
\&
\&    {
\&        package Name_fieldhash;
\&        use Hash::Util::FieldHash;
\&
\&        Hash::Util::FieldHash::fieldhashes \e my (%first, %last);
\&
\&        sub init {
\&            my $obj = shift;
\&            my ($first, $last) = @_;
\&            # create an object if called as class method
\&            $obj = bless \e my $o, $obj unless ref $obj;
\&            $first{ $obj} = $first;
\&            $last{ $obj} = $last;
\&            $obj;
\&        }
\&
\&        sub first { $first{ shift()} }
\&        sub last { $last{ shift()} }
\&
\&        sub name {
\&            my $n = shift;
\&            join \*(Aq \*(Aq => $n\->first, $n\->last;
\&        }
\&    }
\&
\&    1;
.Ve
.PP
To exercise the various implementations the script below can
be used.
.PP
It sets up a class \f(CW\*(C`Name\*(C'\fR that is a mirror of one of the implementation
classes \f(CW\*(C`Name_hash\*(C'\fR, \f(CW\*(C`Name_id\*(C'\fR, ..., \f(CW\*(C`Name_fieldhash\*(C'\fR.  That determines
which implementation is run.
.PP
The script first verifies the function of the \f(CW\*(C`Name\*(C'\fR class.
.PP
In the second step, the free inheritability of the implementation
(or lack thereof) is demonstrated.  For this purpose it constructs
a class called \f(CW\*(C`NamedFile\*(C'\fR which is a common subclass of \f(CW\*(C`Name\*(C'\fR and
the standard class \f(CW\*(C`IO::File\*(C'\fR.  This puts inheritability to the test
because objects of \f(CW\*(C`IO::File\*(C'\fR \fImust\fR be globrefs.  Objects of \f(CW\*(C`NamedFile\*(C'\fR
should behave like a file opened for reading and also support the \f(CW\*(C`name()\*(C'\fR
method.  This class juncture works with exception of the \f(CW\*(C`Name_hash\*(C'\fR
implementation, where object initialization fails because of the
incompatibility of object bodies.
.SS "Example 2"
.IX Subsection "Example 2"
.Vb 1
\&    use strict; use warnings; $| = 1;
\&
\&    use Example;
\&
\&    {
\&        package Name;
\&        use base \*(AqName_id\*(Aq;      # define here which implementation to run
\&    }
\&
\&
\&    # Verify that the base package works
\&    my $n = Name\->init(qw(Albert Einstein));
\&    print $n\->name, "\en";
\&    print "\en";
\&
\&    # Create a named file handle (See definition below)
\&    my $nf = NamedFile\->init(qw(/tmp/x Filomena File));
\&    # use as a file handle...
\&    for ( 1 .. 3 ) {
\&        my $l = <$nf>;
\&        print "line $_: $l";
\&    }
\&    # ...and as a Name object
\&    print "...brought to you by ", $nf\->name, "\en";
\&    exit;
\&
\&
\&    # Definition of NamedFile
\&    package NamedFile;
\&    use base \*(AqName\*(Aq;
\&    use base \*(AqIO::File\*(Aq;
\&
\&    sub init {
\&        my $obj = shift;
\&        my ($file, $first, $last) = @_;
\&        $obj = $obj\->IO::File::new() unless ref $obj;
\&        $obj\->open($file) or die "Can\*(Aqt read \*(Aq$file\*(Aq: $!";
\&        $obj\->Name::init($first, $last);
\&    }
\&    _\|_END_\|_
.Ve
.SH "GUTS"
.IX Header "GUTS"
To make \f(CW\*(C`Hash::Util::FieldHash\*(C'\fR work, there were two changes to
\&\fIperl\fR itself.  \f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR was made available for hashes,
and weak references now call uvar \f(CW\*(C`get\*(C'\fR magic after a weakref has been
cleared.  The first feature is used to make field hashes intercept
their keys upon access.  The second one triggers garbage collection.
.ie n .SS "The ""PERL_MAGIC_uvar"" interface for hashes"
.el .SS "The \f(CWPERL_MAGIC_uvar\fP interface for hashes"
.IX Subsection "The PERL_MAGIC_uvar interface for hashes"
\&\f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR \fIget\fR magic is called from \f(CW\*(C`hv_fetch_common\*(C'\fR and
\&\f(CW\*(C`hv_delete_common\*(C'\fR through the function \f(CW\*(C`hv_magic_uvar_xkey\*(C'\fR, which
defines the interface.  The call happens for hashes with \*(L"uvar\*(R" magic
if the \f(CW\*(C`ufuncs\*(C'\fR structure has equal values in the \f(CW\*(C`uf_val\*(C'\fR and \f(CW\*(C`uf_set\*(C'\fR
fields.  Hashes are unaffected if (and as long as) these fields
hold different values.
.PP
Upon the call, the \f(CW\*(C`mg_obj\*(C'\fR field will hold the hash key to be accessed.
Upon return, the \f(CW\*(C`SV*\*(C'\fR value in \f(CW\*(C`mg_obj\*(C'\fR will be used in place of the
original key in the hash access.  The integer index value in the first
parameter will be the \f(CW\*(C`action\*(C'\fR value from \f(CW\*(C`hv_fetch_common\*(C'\fR, or \-1
if the call is from \f(CW\*(C`hv_delete_common\*(C'\fR.
.PP
This is a template for a function suitable for the \f(CW\*(C`uf_val\*(C'\fR field in
a \f(CW\*(C`ufuncs\*(C'\fR structure for this call.  The \f(CW\*(C`uf_set\*(C'\fR and \f(CW\*(C`uf_index\*(C'\fR
fields are irrelevant.
.PP
.Vb 10
\&    IV watch_key(pTHX_ IV action, SV* field) {
\&        MAGIC* mg = mg_find(field, PERL_MAGIC_uvar);
\&        SV* keysv = mg\->mg_obj;
\&        /* Do whatever you need to.  If you decide to
\&           supply a different key newkey, return it like this
\&        */
\&        sv_2mortal(newkey);
\&        mg\->mg_obj = newkey;
\&        return 0;
\&    }
.Ve
.SS "Weakrefs call uvar magic"
.IX Subsection "Weakrefs call uvar magic"
When a weak reference is stored in an \f(CW\*(C`SV\*(C'\fR that has \*(L"uvar\*(R" magic, \f(CW\*(C`set\*(C'\fR
magic is called after the reference has gone stale.  This hook can be
used to trigger further garbage-collection activities associated with
the referenced object.
.SS "How field hashes work"
.IX Subsection "How field hashes work"
The three features of key hashes, \fIkey replacement\fR, \fIthread support\fR,
and \fIgarbage collection\fR are supported by a data structure called
the \fIobject registry\fR.  This is a private hash where every object
is stored.  An \*(L"object\*(R" in this sense is any reference (blessed or
unblessed) that has been used as a field hash key.
.PP
The object registry keeps track of references that have been used as
field hash keys.  The keys are generated from the reference address
like in a field hash (though the registry isn't a field hash).  Each
value is a weak copy of the original reference, stored in an \f(CW\*(C`SV\*(C'\fR that
is itself magical (\f(CW\*(C`PERL_MAGIC_uvar\*(C'\fR again).  The magical structure
holds a list (another hash, really) of field hashes that the reference
has been used with.  When the weakref becomes stale, the magic is
activated and uses the list to delete the reference from all field
hashes it has been used with.  After that, the entry is removed from
the object registry itself.  Implicitly, that frees the magic structure
and the storage it has been using.
.PP
Whenever a reference is used as a field hash key, the object registry
is checked and a new entry is made if necessary.  The field hash is
then added to the list of fields this reference has used.
.PP
The object registry is also used to repair a field hash after thread
cloning.  Here, the entire object registry is processed.  For every
reference found there, the field hashes it has used are visited and
the entry is updated.
.SS "Internal function Hash::Util::FieldHash::_fieldhash"
.IX Subsection "Internal function Hash::Util::FieldHash::_fieldhash"
.Vb 2
\&    # test if %hash is a field hash
\&    my $result = _fieldhash \e %hash, 0;
\&
\&    # make %hash a field hash
\&    my $result = _fieldhash \e %hash, 1;
.Ve
.PP
\&\f(CW\*(C`_fieldhash\*(C'\fR is the internal function used to create field hashes.
It takes two arguments, a hashref and a mode.  If the mode is boolean
false, the hash is not changed but tested if it is a field hash.  If
the hash isn't a field hash the return value is boolean false.  If it
is, the return value indicates the mode of field hash.  When called with
a boolean true mode, it turns the given hash into a field hash of this
mode, returning the mode of the created field hash.  \f(CW\*(C`_fieldhash\*(C'\fR
does not erase the given hash.
.PP
Currently there is only one type of field hash, and only the boolean
value of the mode makes a difference, but that may change.
.SH "AUTHOR"
.IX Header "AUTHOR"
Anno Siegel (\s-1ANNO\s0) wrote the xs code and the changes in perl proper
Jerry Hedden (\s-1JDHEDDEN\s0) made it faster
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2007 by (Anno Siegel)
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.7 or,
at your option, any later version of Perl 5 you may have available.
                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Hook::LexWrap.3pm                            0100644 0001750 0001750 00000032631 12566242516 023676  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Hook::LexWrap 3"
.TH Hook::LexWrap 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Hook::LexWrap \- Lexically scoped subroutine wrappers
.SH "VERSION"
.IX Header "VERSION"
This document describes version 0.23 of Hook::LexWrap.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Hook::LexWrap;
\&
\&        sub doit { print "[doit:", caller, "]"; return {my=>"data"} }
\&
\&        SCOPED: {
\&                wrap doit,
\&                        pre  => sub { print "[pre1: @_]\en" },
\&                        post => sub { print "[post1:@_]\en"; $_[1]=9; };
\&
\&                my $temporarily = wrap doit,
\&                        post => sub { print "[post2:@_]\en" },
\&                        pre  => sub { print "[pre2: @_]\en  "};
\&
\&                @args = (1,2,3);
\&                doit(@args);    # pre2\->pre1\->doit\->post1\->post2
\&        }
\&
\&        @args = (4,5,6);
\&        doit(@args);            # pre1\->doit\->post1
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Hook::LexWrap allows you to install a pre\- or post-wrapper (or both)
around an existing subroutine. Unlike other modules that provide this
capacity (e.g. Hook::PreAndPost and Hook::WrapSub), Hook::LexWrap
implements wrappers in such a way that the standard \f(CW\*(C`caller\*(C'\fR function
works correctly within the wrapped subroutine.
.PP
To install a prewrappers, you write:
.PP
.Vb 1
\&        use Hook::LexWrap;
\&
\&        wrap \*(Aqsubroutine_name\*(Aq, pre => \e&some_other_sub;
\&
\&   #or: wrap *subroutine_name,  pre => \e&some_other_sub;
.Ve
.PP
The first argument to \f(CW\*(C`wrap\*(C'\fR is a string containing the name of the
subroutine to be wrapped (or the typeglob containing it, or a
reference to it). The subroutine name may be qualified, and the
subroutine must already be defined. The second argument indicates the
type of wrapper being applied and must be either \f(CW\*(Aqpre\*(Aq\fR or
\&\f(CW\*(Aqpost\*(Aq\fR. The third argument must be a reference to a subroutine that
implements the wrapper.
.PP
To install a post-wrapper, you write:
.PP
.Vb 1
\&        wrap \*(Aqsubroutine_name\*(Aq, post => \e&yet_another_sub;
\&
\&   #or: wrap *subroutine_name,  post => \e&yet_another_sub;
.Ve
.PP
To install both at once:
.PP
.Vb 3
\&        wrap \*(Aqsubroutine_name\*(Aq,
\&             pre  => \e&some_other_sub,
\&             post => \e&yet_another_sub;
.Ve
.PP
or:
.PP
.Vb 3
\&        wrap *subroutine_name,
\&             post => \e&yet_another_sub,  # order in which wrappers are
\&             pre  => \e&some_other_sub;   # specified doesn\*(Aqt matter
.Ve
.PP
Once they are installed, the pre\- and post-wrappers will be called before
and after the subroutine itself, and will be passed the same argument list.
.PP
The pre\- and post-wrappers and the original subroutine also all see the same
(correct!) values from \f(CW\*(C`caller\*(C'\fR and \f(CW\*(C`wantarray\*(C'\fR.
.SS "Short-circuiting and long-circuiting return values"
.IX Subsection "Short-circuiting and long-circuiting return values"
The pre\- and post-wrappers both receive an extra argument in their \f(CW@_\fR
arrays. That extra argument is appended to the original argument list
(i.e. is can always be accessed as \f(CW$_\fR[\-1]) and acts as a place-holder for
the original subroutine's return value.
.PP
In a pre-wrapper, \f(CW$_\fR[\-1] is \*(-- for obvious reasons \*(-- \f(CW\*(C`undef\*(C'\fR. However,
\&\f(CW$_\fR[\-1] may be assigned to in a pre-wrapper, in which case Hook::LexWrap
assumes that the original subroutine has been \*(L"pre-empted\*(R", and that
neither it, nor the corresponding post-wrapper, nor any wrappers that
were applied \fIbefore\fR the pre-empting pre-wrapper was installed, need
be run. Note that any post-wrappers that were installed after the
pre-empting pre-wrapper was installed \fIwill\fR still be called before the
original subroutine call returns.
.PP
In a post-wrapper, \f(CW$_\fR[\-1] contains the return value produced by the
wrapped subroutine. In a scalar return context, this value is the scalar
return value. In an list return context, this value is a reference to
the array of return values. \f(CW$_\fR[\-1] may be assigned to in a post-wrapper,
and this changes the return value accordingly.
.PP
Access to the arguments and return value is useful for implementing
techniques such as memoization:
.PP
.Vb 4
\&        my %cache;
\&        wrap fibonacci,
\&                pre  => sub { $_[\-1] = $cache{$_[0]} if $cache{$_[0]} },
\&                post => sub { $cache{$_[0]} = $_[\-1] };
.Ve
.PP
or for converting arguments and return values in a consistent manner:
.PP
.Vb 5
\&        # set_temp expects and returns degrees Fahrenheit,
\&        # but we want to use Celsius
\&        wrap set_temp,
\&                pre   => sub { splice @_, 0, 1, $_[0] * 1.8 + 32 },
\&                post  => sub { $_[\-1] = ($_[0] \- 32) / 1.8 };
.Ve
.SS "Lexically scoped wrappers"
.IX Subsection "Lexically scoped wrappers"
Normally, any wrappers installed by \f(CW\*(C`wrap\*(C'\fR remain attached to the 
subroutine until it is undefined. However, it is possible to make
specific wrappers lexically bound, so that they operate only until
the end of the scope in which they're created (or until some other
specific point in the code).
.PP
If \f(CW\*(C`wrap\*(C'\fR is called in a \fInon-void\fR context:
.PP
.Vb 1
\&        my $lexical = wrap \*(Aqsub_name\*(Aq, pre => \e&wrapper;
.Ve
.PP
it returns a special object corresponding to the particular wrapper being
placed around the original subroutine. When that object is destroyed
\&\*(-- when its container variable goes out of scope, or when its
reference count otherwise falls to zero (e.g. \f(CW\*(C`undef $lexical\*(C'\fR), or 
when it is explicitly destroyed (\f(CW\*(C`$lexical\->DESTROY\*(C'\fR) \*(--
the corresponding wrapper is removed from around
the original subroutine. Note, however, that all other wrappers around the
subroutine are preserved.
.SS "Anonymous wrappers"
.IX Subsection "Anonymous wrappers"
If the subroutine to be wrapped is passed as a reference (rather than by name
or by typeglob), \f(CW\*(C`wrap\*(C'\fR does not install the wrappers around the 
original subroutine. Instead it generates a new subroutine which acts
as if it were the original with those wrappers around it.
It then returns a reference to that new subroutine. Only calls to the original
through that wrapped reference invoke the wrappers. Direct by-name calls to
the original, or calls through another reference, do not.
.PP
If the original is subsequently wrapped by name, the anonymously wrapped
subroutine reference does not see those wrappers. In other words,
wrappers installed via a subroutine reference are completely independent
of those installed via the subroutine's name (or typeglob).
.PP
For example:
.PP
.Vb 1
\&        sub original { print "ray" }
\&
\&        # Wrap anonymously...
\&        my $anon_wrapped = wrap \e&original, pre => sub { print "do..." };
\&
\&        # Show effects...
\&        original();             # prints "ray"
\&        $anon_wrapped\->();      # prints "do..ray"
\&
\&        # Wrap nonymously...
\&        wrap *original,
\&                pre  => sub { print "fa.." },
\&                post => sub { print "..mi" };
\&
\&        # Show effects...
\&        original();             #   now prints "fa..ray..mi"
\&        $anon_wrapped\->();      # still prints "do...ray"
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """Can\*(Aqt wrap non\-existent subroutine %s""" 4
.el .IP "\f(CWCan\*(Aqt wrap non\-existent subroutine %s\fR" 4
.IX Item "Cant wrap non-existent subroutine %s"
An attempt was made to wrap a subroutine that was not defined at the
point of wrapping.
.ie n .IP """\*(Aqpre\*(Aq value is not a subroutine reference""" 4
.el .IP "\f(CW\*(Aqpre\*(Aq value is not a subroutine reference\fR" 4
.IX Item "pre value is not a subroutine reference"
The value passed to \f(CW\*(C`wrap\*(C'\fR after the \f(CW\*(Aqpre\*(Aq\fR flag was not
a subroutine reference. Typically, someone forgot the \f(CW\*(C`sub\*(C'\fR on
the anonymous subroutine:
.Sp
.Vb 1
\&        wrap \*(Aqsubname\*(Aq, pre => { your_code_here() };
.Ve
.Sp
and Perl interpreted the last argument as a hash constructor.
.ie n .IP """\*(Aqpost\*(Aq value is not a subroutine reference""" 4
.el .IP "\f(CW\*(Aqpost\*(Aq value is not a subroutine reference\fR" 4
.IX Item "post value is not a subroutine reference"
The value passed to \f(CW\*(C`wrap\*(C'\fR after the \f(CW\*(Aqpost\*(Aq\fR flag was not
a subroutine reference.
.ie n .IP """Uselessly wrapped subroutine reference in void context"" (warning only)" 4
.el .IP "\f(CWUselessly wrapped subroutine reference in void context\fR (warning only)" 4
.IX Item "Uselessly wrapped subroutine reference in void context (warning only)"
When the subroutine to be wrapped is passed as a subroutine reference,
\&\f(CW\*(C`wrap\*(C'\fR does not install the wrapper around the original, but instead
returns a reference to a subroutine which wraps the original
(see \*(L"Anonymous wrappers\*(R").
.Sp
However, there's no point in doing this if you don't catch the resulting
subroutine reference.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "BLAME"
.IX Header "BLAME"
Schwern made me do this (by implying it wasn't possible ;\-)
.SH "BUGS"
.IX Header "BUGS"
There are undoubtedly serious bugs lurking somewhere in code this funky :\-)
.PP
Bug reports and other feedback are most welcome.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Sub::Prepend
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&      Copyright (c) 2001, Damian Conway. All Rights Reserved.
\&    This module is free software. It may be used, redistributed
\&        and/or modified under the same terms as Perl itself.
.Ve
                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Hook::LexWrap5.16.3pm                        0100644 0001750 0001750 00000032310 12566242505 024200  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Hook::LexWrap 3"
.TH Hook::LexWrap 3 "2015-08-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Hook::LexWrap \- Lexically scoped subroutine wrappers
.SH "VERSION"
.IX Header "VERSION"
This document describes version 0.23 of Hook::LexWrap.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Hook::LexWrap;
\&
\&        sub doit { print "[doit:", caller, "]"; return {my=>"data"} }
\&
\&        SCOPED: {
\&                wrap doit,
\&                        pre  => sub { print "[pre1: @_]\en" },
\&                        post => sub { print "[post1:@_]\en"; $_[1]=9; };
\&
\&                my $temporarily = wrap doit,
\&                        post => sub { print "[post2:@_]\en" },
\&                        pre  => sub { print "[pre2: @_]\en  "};
\&
\&                @args = (1,2,3);
\&                doit(@args);    # pre2\->pre1\->doit\->post1\->post2
\&        }
\&
\&        @args = (4,5,6);
\&        doit(@args);            # pre1\->doit\->post1
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Hook::LexWrap allows you to install a pre\- or post-wrapper (or both)
around an existing subroutine. Unlike other modules that provide this
capacity (e.g. Hook::PreAndPost and Hook::WrapSub), Hook::LexWrap
implements wrappers in such a way that the standard \f(CW\*(C`caller\*(C'\fR function
works correctly within the wrapped subroutine.
.PP
To install a prewrappers, you write:
.PP
.Vb 1
\&        use Hook::LexWrap;
\&
\&        wrap \*(Aqsubroutine_name\*(Aq, pre => \e&some_other_sub;
\&
\&   #or: wrap *subroutine_name,  pre => \e&some_other_sub;
.Ve
.PP
The first argument to \f(CW\*(C`wrap\*(C'\fR is a string containing the name of the
subroutine to be wrapped (or the typeglob containing it, or a
reference to it). The subroutine name may be qualified, and the
subroutine must already be defined. The second argument indicates the
type of wrapper being applied and must be either \f(CW\*(Aqpre\*(Aq\fR or
\&\f(CW\*(Aqpost\*(Aq\fR. The third argument must be a reference to a subroutine that
implements the wrapper.
.PP
To install a post-wrapper, you write:
.PP
.Vb 1
\&        wrap \*(Aqsubroutine_name\*(Aq, post => \e&yet_another_sub;
\&
\&   #or: wrap *subroutine_name,  post => \e&yet_another_sub;
.Ve
.PP
To install both at once:
.PP
.Vb 3
\&        wrap \*(Aqsubroutine_name\*(Aq,
\&             pre  => \e&some_other_sub,
\&             post => \e&yet_another_sub;
.Ve
.PP
or:
.PP
.Vb 3
\&        wrap *subroutine_name,
\&             post => \e&yet_another_sub,  # order in which wrappers are
\&             pre  => \e&some_other_sub;   # specified doesn\*(Aqt matter
.Ve
.PP
Once they are installed, the pre\- and post-wrappers will be called before
and after the subroutine itself, and will be passed the same argument list.
.PP
The pre\- and post-wrappers and the original subroutine also all see the same
(correct!) values from \f(CW\*(C`caller\*(C'\fR and \f(CW\*(C`wantarray\*(C'\fR.
.SS "Short-circuiting and long-circuiting return values"
.IX Subsection "Short-circuiting and long-circuiting return values"
The pre\- and post-wrappers both receive an extra argument in their \f(CW@_\fR
arrays. That extra argument is appended to the original argument list
(i.e. is can always be accessed as \f(CW$_\fR[\-1]) and acts as a place-holder for
the original subroutine's return value.
.PP
In a pre-wrapper, \f(CW$_\fR[\-1] is \*(-- for obvious reasons \*(-- \f(CW\*(C`undef\*(C'\fR. However,
\&\f(CW$_\fR[\-1] may be assigned to in a pre-wrapper, in which case Hook::LexWrap
assumes that the original subroutine has been \*(L"pre-empted\*(R", and that
neither it, nor the corresponding post-wrapper, nor any wrappers that
were applied \fIbefore\fR the pre-empting pre-wrapper was installed, need
be run. Note that any post-wrappers that were installed after the
pre-empting pre-wrapper was installed \fIwill\fR still be called before the
original subroutine call returns.
.PP
In a post-wrapper, \f(CW$_\fR[\-1] contains the return value produced by the
wrapped subroutine. In a scalar return context, this value is the scalar
return value. In an list return context, this value is a reference to
the array of return values. \f(CW$_\fR[\-1] may be assigned to in a post-wrapper,
and this changes the return value accordingly.
.PP
Access to the arguments and return value is useful for implementing
techniques such as memoization:
.PP
.Vb 4
\&        my %cache;
\&        wrap fibonacci,
\&                pre  => sub { $_[\-1] = $cache{$_[0]} if $cache{$_[0]} },
\&                post => sub { $cache{$_[0]} = $_[\-1] };
.Ve
.PP
or for converting arguments and return values in a consistent manner:
.PP
.Vb 5
\&        # set_temp expects and returns degrees Fahrenheit,
\&        # but we want to use Celsius
\&        wrap set_temp,
\&                pre   => sub { splice @_, 0, 1, $_[0] * 1.8 + 32 },
\&                post  => sub { $_[\-1] = ($_[0] \- 32) / 1.8 };
.Ve
.SS "Lexically scoped wrappers"
.IX Subsection "Lexically scoped wrappers"
Normally, any wrappers installed by \f(CW\*(C`wrap\*(C'\fR remain attached to the 
subroutine until it is undefined. However, it is possible to make
specific wrappers lexically bound, so that they operate only until
the end of the scope in which they're created (or until some other
specific point in the code).
.PP
If \f(CW\*(C`wrap\*(C'\fR is called in a \fInon-void\fR context:
.PP
.Vb 1
\&        my $lexical = wrap \*(Aqsub_name\*(Aq, pre => \e&wrapper;
.Ve
.PP
it returns a special object corresponding to the particular wrapper being
placed around the original subroutine. When that object is destroyed
\&\*(-- when its container variable goes out of scope, or when its
reference count otherwise falls to zero (e.g. \f(CW\*(C`undef $lexical\*(C'\fR), or 
when it is explicitly destroyed (\f(CW\*(C`$lexical\->DESTROY\*(C'\fR) \*(--
the corresponding wrapper is removed from around
the original subroutine. Note, however, that all other wrappers around the
subroutine are preserved.
.SS "Anonymous wrappers"
.IX Subsection "Anonymous wrappers"
If the subroutine to be wrapped is passed as a reference (rather than by name
or by typeglob), \f(CW\*(C`wrap\*(C'\fR does not install the wrappers around the 
original subroutine. Instead it generates a new subroutine which acts
as if it were the original with those wrappers around it.
It then returns a reference to that new subroutine. Only calls to the original
through that wrapped reference invoke the wrappers. Direct by-name calls to
the original, or calls through another reference, do not.
.PP
If the original is subsequently wrapped by name, the anonymously wrapped
subroutine reference does not see those wrappers. In other words,
wrappers installed via a subroutine reference are completely independent
of those installed via the subroutine's name (or typeglob).
.PP
For example:
.PP
.Vb 1
\&        sub original { print "ray" }
\&
\&        # Wrap anonymously...
\&        my $anon_wrapped = wrap \e&original, pre => sub { print "do..." };
\&
\&        # Show effects...
\&        original();             # prints "ray"
\&        $anon_wrapped\->();      # prints "do..ray"
\&
\&        # Wrap nonymously...
\&        wrap *original,
\&                pre  => sub { print "fa.." },
\&                post => sub { print "..mi" };
\&
\&        # Show effects...
\&        original();             #   now prints "fa..ray..mi"
\&        $anon_wrapped\->();      # still prints "do...ray"
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """Can\*(Aqt wrap non\-existent subroutine %s""" 4
.el .IP "\f(CWCan\*(Aqt wrap non\-existent subroutine %s\fR" 4
.IX Item "Cant wrap non-existent subroutine %s"
An attempt was made to wrap a subroutine that was not defined at the
point of wrapping.
.ie n .IP """\*(Aqpre\*(Aq value is not a subroutine reference""" 4
.el .IP "\f(CW\*(Aqpre\*(Aq value is not a subroutine reference\fR" 4
.IX Item "pre value is not a subroutine reference"
The value passed to \f(CW\*(C`wrap\*(C'\fR after the \f(CW\*(Aqpre\*(Aq\fR flag was not
a subroutine reference. Typically, someone forgot the \f(CW\*(C`sub\*(C'\fR on
the anonymous subroutine:
.Sp
.Vb 1
\&        wrap \*(Aqsubname\*(Aq, pre => { your_code_here() };
.Ve
.Sp
and Perl interpreted the last argument as a hash constructor.
.ie n .IP """\*(Aqpost\*(Aq value is not a subroutine reference""" 4
.el .IP "\f(CW\*(Aqpost\*(Aq value is not a subroutine reference\fR" 4
.IX Item "post value is not a subroutine reference"
The value passed to \f(CW\*(C`wrap\*(C'\fR after the \f(CW\*(Aqpost\*(Aq\fR flag was not
a subroutine reference.
.ie n .IP """Uselessly wrapped subroutine reference in void context"" (warning only)" 4
.el .IP "\f(CWUselessly wrapped subroutine reference in void context\fR (warning only)" 4
.IX Item "Uselessly wrapped subroutine reference in void context (warning only)"
When the subroutine to be wrapped is passed as a subroutine reference,
\&\f(CW\*(C`wrap\*(C'\fR does not install the wrapper around the original, but instead
returns a reference to a subroutine which wraps the original
(see \*(L"Anonymous wrappers\*(R").
.Sp
However, there's no point in doing this if you don't catch the resulting
subroutine reference.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "BLAME"
.IX Header "BLAME"
Schwern made me do this (by implying it wasn't possible ;\-)
.SH "BUGS"
.IX Header "BUGS"
There are undoubtedly serious bugs lurking somewhere in code this funky :\-)
.PP
Bug reports and other feedback are most welcome.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Sub::Prepend
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&      Copyright (c) 2001, Damian Conway. All Rights Reserved.
\&    This module is free software. It may be used, redistributed
\&        and/or modified under the same terms as Perl itself.
.Ve
                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Hook::LexWrap5.18.3pm                        0100644 0001750 0001750 00000032631 12566242516 024212  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Hook::LexWrap 3"
.TH Hook::LexWrap 3 "2015-08-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Hook::LexWrap \- Lexically scoped subroutine wrappers
.SH "VERSION"
.IX Header "VERSION"
This document describes version 0.23 of Hook::LexWrap.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Hook::LexWrap;
\&
\&        sub doit { print "[doit:", caller, "]"; return {my=>"data"} }
\&
\&        SCOPED: {
\&                wrap doit,
\&                        pre  => sub { print "[pre1: @_]\en" },
\&                        post => sub { print "[post1:@_]\en"; $_[1]=9; };
\&
\&                my $temporarily = wrap doit,
\&                        post => sub { print "[post2:@_]\en" },
\&                        pre  => sub { print "[pre2: @_]\en  "};
\&
\&                @args = (1,2,3);
\&                doit(@args);    # pre2\->pre1\->doit\->post1\->post2
\&        }
\&
\&        @args = (4,5,6);
\&        doit(@args);            # pre1\->doit\->post1
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Hook::LexWrap allows you to install a pre\- or post-wrapper (or both)
around an existing subroutine. Unlike other modules that provide this
capacity (e.g. Hook::PreAndPost and Hook::WrapSub), Hook::LexWrap
implements wrappers in such a way that the standard \f(CW\*(C`caller\*(C'\fR function
works correctly within the wrapped subroutine.
.PP
To install a prewrappers, you write:
.PP
.Vb 1
\&        use Hook::LexWrap;
\&
\&        wrap \*(Aqsubroutine_name\*(Aq, pre => \e&some_other_sub;
\&
\&   #or: wrap *subroutine_name,  pre => \e&some_other_sub;
.Ve
.PP
The first argument to \f(CW\*(C`wrap\*(C'\fR is a string containing the name of the
subroutine to be wrapped (or the typeglob containing it, or a
reference to it). The subroutine name may be qualified, and the
subroutine must already be defined. The second argument indicates the
type of wrapper being applied and must be either \f(CW\*(Aqpre\*(Aq\fR or
\&\f(CW\*(Aqpost\*(Aq\fR. The third argument must be a reference to a subroutine that
implements the wrapper.
.PP
To install a post-wrapper, you write:
.PP
.Vb 1
\&        wrap \*(Aqsubroutine_name\*(Aq, post => \e&yet_another_sub;
\&
\&   #or: wrap *subroutine_name,  post => \e&yet_another_sub;
.Ve
.PP
To install both at once:
.PP
.Vb 3
\&        wrap \*(Aqsubroutine_name\*(Aq,
\&             pre  => \e&some_other_sub,
\&             post => \e&yet_another_sub;
.Ve
.PP
or:
.PP
.Vb 3
\&        wrap *subroutine_name,
\&             post => \e&yet_another_sub,  # order in which wrappers are
\&             pre  => \e&some_other_sub;   # specified doesn\*(Aqt matter
.Ve
.PP
Once they are installed, the pre\- and post-wrappers will be called before
and after the subroutine itself, and will be passed the same argument list.
.PP
The pre\- and post-wrappers and the original subroutine also all see the same
(correct!) values from \f(CW\*(C`caller\*(C'\fR and \f(CW\*(C`wantarray\*(C'\fR.
.SS "Short-circuiting and long-circuiting return values"
.IX Subsection "Short-circuiting and long-circuiting return values"
The pre\- and post-wrappers both receive an extra argument in their \f(CW@_\fR
arrays. That extra argument is appended to the original argument list
(i.e. is can always be accessed as \f(CW$_\fR[\-1]) and acts as a place-holder for
the original subroutine's return value.
.PP
In a pre-wrapper, \f(CW$_\fR[\-1] is \*(-- for obvious reasons \*(-- \f(CW\*(C`undef\*(C'\fR. However,
\&\f(CW$_\fR[\-1] may be assigned to in a pre-wrapper, in which case Hook::LexWrap
assumes that the original subroutine has been \*(L"pre-empted\*(R", and that
neither it, nor the corresponding post-wrapper, nor any wrappers that
were applied \fIbefore\fR the pre-empting pre-wrapper was installed, need
be run. Note that any post-wrappers that were installed after the
pre-empting pre-wrapper was installed \fIwill\fR still be called before the
original subroutine call returns.
.PP
In a post-wrapper, \f(CW$_\fR[\-1] contains the return value produced by the
wrapped subroutine. In a scalar return context, this value is the scalar
return value. In an list return context, this value is a reference to
the array of return values. \f(CW$_\fR[\-1] may be assigned to in a post-wrapper,
and this changes the return value accordingly.
.PP
Access to the arguments and return value is useful for implementing
techniques such as memoization:
.PP
.Vb 4
\&        my %cache;
\&        wrap fibonacci,
\&                pre  => sub { $_[\-1] = $cache{$_[0]} if $cache{$_[0]} },
\&                post => sub { $cache{$_[0]} = $_[\-1] };
.Ve
.PP
or for converting arguments and return values in a consistent manner:
.PP
.Vb 5
\&        # set_temp expects and returns degrees Fahrenheit,
\&        # but we want to use Celsius
\&        wrap set_temp,
\&                pre   => sub { splice @_, 0, 1, $_[0] * 1.8 + 32 },
\&                post  => sub { $_[\-1] = ($_[0] \- 32) / 1.8 };
.Ve
.SS "Lexically scoped wrappers"
.IX Subsection "Lexically scoped wrappers"
Normally, any wrappers installed by \f(CW\*(C`wrap\*(C'\fR remain attached to the 
subroutine until it is undefined. However, it is possible to make
specific wrappers lexically bound, so that they operate only until
the end of the scope in which they're created (or until some other
specific point in the code).
.PP
If \f(CW\*(C`wrap\*(C'\fR is called in a \fInon-void\fR context:
.PP
.Vb 1
\&        my $lexical = wrap \*(Aqsub_name\*(Aq, pre => \e&wrapper;
.Ve
.PP
it returns a special object corresponding to the particular wrapper being
placed around the original subroutine. When that object is destroyed
\&\*(-- when its container variable goes out of scope, or when its
reference count otherwise falls to zero (e.g. \f(CW\*(C`undef $lexical\*(C'\fR), or 
when it is explicitly destroyed (\f(CW\*(C`$lexical\->DESTROY\*(C'\fR) \*(--
the corresponding wrapper is removed from around
the original subroutine. Note, however, that all other wrappers around the
subroutine are preserved.
.SS "Anonymous wrappers"
.IX Subsection "Anonymous wrappers"
If the subroutine to be wrapped is passed as a reference (rather than by name
or by typeglob), \f(CW\*(C`wrap\*(C'\fR does not install the wrappers around the 
original subroutine. Instead it generates a new subroutine which acts
as if it were the original with those wrappers around it.
It then returns a reference to that new subroutine. Only calls to the original
through that wrapped reference invoke the wrappers. Direct by-name calls to
the original, or calls through another reference, do not.
.PP
If the original is subsequently wrapped by name, the anonymously wrapped
subroutine reference does not see those wrappers. In other words,
wrappers installed via a subroutine reference are completely independent
of those installed via the subroutine's name (or typeglob).
.PP
For example:
.PP
.Vb 1
\&        sub original { print "ray" }
\&
\&        # Wrap anonymously...
\&        my $anon_wrapped = wrap \e&original, pre => sub { print "do..." };
\&
\&        # Show effects...
\&        original();             # prints "ray"
\&        $anon_wrapped\->();      # prints "do..ray"
\&
\&        # Wrap nonymously...
\&        wrap *original,
\&                pre  => sub { print "fa.." },
\&                post => sub { print "..mi" };
\&
\&        # Show effects...
\&        original();             #   now prints "fa..ray..mi"
\&        $anon_wrapped\->();      # still prints "do...ray"
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP """Can\*(Aqt wrap non\-existent subroutine %s""" 4
.el .IP "\f(CWCan\*(Aqt wrap non\-existent subroutine %s\fR" 4
.IX Item "Cant wrap non-existent subroutine %s"
An attempt was made to wrap a subroutine that was not defined at the
point of wrapping.
.ie n .IP """\*(Aqpre\*(Aq value is not a subroutine reference""" 4
.el .IP "\f(CW\*(Aqpre\*(Aq value is not a subroutine reference\fR" 4
.IX Item "pre value is not a subroutine reference"
The value passed to \f(CW\*(C`wrap\*(C'\fR after the \f(CW\*(Aqpre\*(Aq\fR flag was not
a subroutine reference. Typically, someone forgot the \f(CW\*(C`sub\*(C'\fR on
the anonymous subroutine:
.Sp
.Vb 1
\&        wrap \*(Aqsubname\*(Aq, pre => { your_code_here() };
.Ve
.Sp
and Perl interpreted the last argument as a hash constructor.
.ie n .IP """\*(Aqpost\*(Aq value is not a subroutine reference""" 4
.el .IP "\f(CW\*(Aqpost\*(Aq value is not a subroutine reference\fR" 4
.IX Item "post value is not a subroutine reference"
The value passed to \f(CW\*(C`wrap\*(C'\fR after the \f(CW\*(Aqpost\*(Aq\fR flag was not
a subroutine reference.
.ie n .IP """Uselessly wrapped subroutine reference in void context"" (warning only)" 4
.el .IP "\f(CWUselessly wrapped subroutine reference in void context\fR (warning only)" 4
.IX Item "Uselessly wrapped subroutine reference in void context (warning only)"
When the subroutine to be wrapped is passed as a subroutine reference,
\&\f(CW\*(C`wrap\*(C'\fR does not install the wrapper around the original, but instead
returns a reference to a subroutine which wraps the original
(see \*(L"Anonymous wrappers\*(R").
.Sp
However, there's no point in doing this if you don't catch the resulting
subroutine reference.
.SH "AUTHOR"
.IX Header "AUTHOR"
Damian Conway (damian@conway.org)
.SH "BLAME"
.IX Header "BLAME"
Schwern made me do this (by implying it wasn't possible ;\-)
.SH "BUGS"
.IX Header "BUGS"
There are undoubtedly serious bugs lurking somewhere in code this funky :\-)
.PP
Bug reports and other feedback are most welcome.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Sub::Prepend
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 3
\&      Copyright (c) 2001, Damian Conway. All Rights Reserved.
\&    This module is free software. It may be used, redistributed
\&        and/or modified under the same terms as Perl itself.
.Ve
                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/I18N::Collate.3pm                            0100644 0001750 0001750 00000014171 12566207455 023460  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "I18N::Collate 3pm"
.TH I18N::Collate 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
I18N::Collate \- compare 8\-bit scalar data according to the current locale
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use I18N::Collate;
\&    setlocale(LC_COLLATE, \*(Aqlocale\-of\-your\-choice\*(Aq);
\&    $s1 = I18N::Collate\->new("scalar_data_1");
\&    $s2 = I18N::Collate\->new("scalar_data_2");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 1
\&  ***
\&
\&  WARNING: starting from the Perl version 5.003_06
\&  the I18N::Collate interface for comparing 8\-bit scalar data
\&  according to the current locale
\&
\&        HAS BEEN DEPRECATED
\&
\&  That is, please do not use it anymore for any new applications
\&  and please migrate the old applications away from it because its
\&  functionality was integrated into the Perl core language in the
\&  release 5.003_06.
\&
\&  See the perllocale manual page for further information.
\&
\&  ***
.Ve
.PP
This module provides you with objects that will collate
according to your national character set, provided that the
\&\s-1POSIX\s0 \fIsetlocale()\fR function is supported on your system.
.PP
You can compare \f(CW$s1\fR and \f(CW$s2\fR above with
.PP
.Vb 1
\&    $s1 le $s2
.Ve
.PP
to extract the data itself, you'll need a dereference: $$s1
.PP
This module uses \fIPOSIX::setlocale()\fR. The basic collation conversion is
done by \fIstrxfrm()\fR which terminates at \s-1NUL\s0 characters being a decent C
routine.  \fIcollate_xfrm()\fR handles embedded \s-1NUL\s0 characters gracefully.
.PP
The available locales depend on your operating system; try whether
\&\f(CW\*(C`locale \-a\*(C'\fR shows them or man pages for \*(L"locale\*(R" or \*(L"nlsinfo\*(R" or the
direct approach \f(CW\*(C`ls /usr/lib/nls/loc\*(C'\fR or \f(CW\*(C`ls /usr/lib/nls\*(C'\fR or
\&\f(CW\*(C`ls /usr/lib/locale\*(C'\fR.  Not all the locales that your vendor supports
are necessarily installed: please consult your operating system's
documentation and possibly your local system administration.  The
locale names are probably something like \f(CW\*(C`xx_XX.(ISO)?8859\-N\*(C'\fR or
\&\f(CW\*(C`xx_XX.(ISO)?8859N\*(C'\fR, for example \f(CW\*(C`fr_CH.ISO8859\-1\*(C'\fR is the Swiss (\s-1CH\s0)
variant of French (fr), \s-1ISO\s0 Latin (8859) 1 (\-1) which is the Western
European character set.
                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/I18N::Collate5.16.3pm                        0100644 0001750 0001750 00000013650 12566207434 023770  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "I18N::Collate 3pm"
.TH I18N::Collate 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
I18N::Collate \- compare 8\-bit scalar data according to the current locale
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use I18N::Collate;
\&    setlocale(LC_COLLATE, \*(Aqlocale\-of\-your\-choice\*(Aq);
\&    $s1 = I18N::Collate\->new("scalar_data_1");
\&    $s2 = I18N::Collate\->new("scalar_data_2");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 1
\&  ***
\&
\&  WARNING: starting from the Perl version 5.003_06
\&  the I18N::Collate interface for comparing 8\-bit scalar data
\&  according to the current locale
\&
\&        HAS BEEN DEPRECATED
\&
\&  That is, please do not use it anymore for any new applications
\&  and please migrate the old applications away from it because its
\&  functionality was integrated into the Perl core language in the
\&  release 5.003_06.
\&
\&  See the perllocale manual page for further information.
\&
\&  ***
.Ve
.PP
This module provides you with objects that will collate
according to your national character set, provided that the
\&\s-1POSIX\s0 \fIsetlocale()\fR function is supported on your system.
.PP
You can compare \f(CW$s1\fR and \f(CW$s2\fR above with
.PP
.Vb 1
\&    $s1 le $s2
.Ve
.PP
to extract the data itself, you'll need a dereference: $$s1
.PP
This module uses \fIPOSIX::setlocale()\fR. The basic collation conversion is
done by \fIstrxfrm()\fR which terminates at \s-1NUL\s0 characters being a decent C
routine.  \fIcollate_xfrm()\fR handles embedded \s-1NUL\s0 characters gracefully.
.PP
The available locales depend on your operating system; try whether
\&\f(CW\*(C`locale \-a\*(C'\fR shows them or man pages for \*(L"locale\*(R" or \*(L"nlsinfo\*(R" or the
direct approach \f(CW\*(C`ls /usr/lib/nls/loc\*(C'\fR or \f(CW\*(C`ls /usr/lib/nls\*(C'\fR or
\&\f(CW\*(C`ls /usr/lib/locale\*(C'\fR.  Not all the locales that your vendor supports
are necessarily installed: please consult your operating system's
documentation and possibly your local system administration.  The
locale names are probably something like \f(CW\*(C`xx_XX.(ISO)?8859\-N\*(C'\fR or
\&\f(CW\*(C`xx_XX.(ISO)?8859N\*(C'\fR, for example \f(CW\*(C`fr_CH.ISO8859\-1\*(C'\fR is the Swiss (\s-1CH\s0)
variant of French (fr), \s-1ISO\s0 Latin (8859) 1 (\-1) which is the Western
European character set.
                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/I18N::Collate5.18.3pm                        0100644 0001750 0001750 00000014171 12566207455 023774  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "I18N::Collate 3pm"
.TH I18N::Collate 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
I18N::Collate \- compare 8\-bit scalar data according to the current locale
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&    use I18N::Collate;
\&    setlocale(LC_COLLATE, \*(Aqlocale\-of\-your\-choice\*(Aq);
\&    $s1 = I18N::Collate\->new("scalar_data_1");
\&    $s2 = I18N::Collate\->new("scalar_data_2");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 1
\&  ***
\&
\&  WARNING: starting from the Perl version 5.003_06
\&  the I18N::Collate interface for comparing 8\-bit scalar data
\&  according to the current locale
\&
\&        HAS BEEN DEPRECATED
\&
\&  That is, please do not use it anymore for any new applications
\&  and please migrate the old applications away from it because its
\&  functionality was integrated into the Perl core language in the
\&  release 5.003_06.
\&
\&  See the perllocale manual page for further information.
\&
\&  ***
.Ve
.PP
This module provides you with objects that will collate
according to your national character set, provided that the
\&\s-1POSIX\s0 \fIsetlocale()\fR function is supported on your system.
.PP
You can compare \f(CW$s1\fR and \f(CW$s2\fR above with
.PP
.Vb 1
\&    $s1 le $s2
.Ve
.PP
to extract the data itself, you'll need a dereference: $$s1
.PP
This module uses \fIPOSIX::setlocale()\fR. The basic collation conversion is
done by \fIstrxfrm()\fR which terminates at \s-1NUL\s0 characters being a decent C
routine.  \fIcollate_xfrm()\fR handles embedded \s-1NUL\s0 characters gracefully.
.PP
The available locales depend on your operating system; try whether
\&\f(CW\*(C`locale \-a\*(C'\fR shows them or man pages for \*(L"locale\*(R" or \*(L"nlsinfo\*(R" or the
direct approach \f(CW\*(C`ls /usr/lib/nls/loc\*(C'\fR or \f(CW\*(C`ls /usr/lib/nls\*(C'\fR or
\&\f(CW\*(C`ls /usr/lib/locale\*(C'\fR.  Not all the locales that your vendor supports
are necessarily installed: please consult your operating system's
documentation and possibly your local system administration.  The
locale names are probably something like \f(CW\*(C`xx_XX.(ISO)?8859\-N\*(C'\fR or
\&\f(CW\*(C`xx_XX.(ISO)?8859N\*(C'\fR, for example \f(CW\*(C`fr_CH.ISO8859\-1\*(C'\fR is the Swiss (\s-1CH\s0)
variant of French (fr), \s-1ISO\s0 Latin (8859) 1 (\-1) which is the Western
European character set.
                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/I18N::LangTags.3pm                           0100644 0001750 0001750 00000056124 12566207455 023601  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "I18N::LangTags 3pm"
.TH I18N::LangTags 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
I18N::LangTags \- functions for dealing with RFC3066\-style language tags
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use I18N::LangTags();
.Ve
.PP
\&...or specify whichever of those functions you want to import, like so:
.PP
.Vb 1
\&  use I18N::LangTags qw(implicate_supers similarity_language_tag);
.Ve
.PP
All the exportable functions are listed below \*(-- you're free to import
only some, or none at all.  By default, none are imported.  If you
say:
.PP
.Vb 1
\&    use I18N::LangTags qw(:ALL)
.Ve
.PP
\&...then all are exported.  (This saves you from having to use
something less obvious like \f(CW\*(C`use I18N::LangTags qw(/./)\*(C'\fR.)
.PP
If you don't import any of these functions, assume a \f(CW&I18N::LangTags::\fR
in front of all the function names in the following examples.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Language tags are a formalism, described in \s-1RFC 3066 \s0(obsoleting
1766), for declaring what language form (language and possibly
dialect) a given chunk of information is in.
.PP
This library provides functions for common tasks involving language
tags as they are needed in a variety of protocols and applications.
.PP
Please see the \*(L"See Also\*(R" references for a thorough explanation
of how to correctly use language tags.
.IP "\(bu" 4
the function is_language_tag($lang1)
.Sp
Returns true iff \f(CW$lang1\fR is a formally valid language tag.
.Sp
.Vb 3
\&   is_language_tag("fr")            is TRUE
\&   is_language_tag("x\-jicarilla")   is FALSE
\&       (Subtags can be 8 chars long at most \-\- \*(Aqjicarilla\*(Aq is 9)
\&
\&   is_language_tag("sgn\-US")    is TRUE
\&       (That\*(Aqs American Sign Language)
\&
\&   is_language_tag("i\-Klikitat")    is TRUE
\&       (True without regard to the fact noone has actually
\&        registered Klikitat \-\- it\*(Aqs a formally valid tag)
\&
\&   is_language_tag("fr\-patois")     is TRUE
\&       (Formally valid \-\- altho descriptively weak!)
\&
\&   is_language_tag("Spanish")       is FALSE
\&   is_language_tag("french\-patois") is FALSE
\&       (No good \-\- first subtag has to match
\&        /^([xXiI]|[a\-zA\-Z]{2,3})$/ \-\- see RFC3066)
\&
\&   is_language_tag("x\-borg\-prot2532") is TRUE
\&       (Yes, subtags can contain digits, as of RFC3066)
.Ve
.IP "\(bu" 4
the function extract_language_tags($whatever)
.Sp
Returns a list of whatever looks like formally valid language tags
in \f(CW$whatever\fR.  Not very smart, so don't get too creative with
what you want to feed it.
.Sp
.Vb 2
\&  extract_language_tags("fr, fr\-ca, i\-mingo")
\&    returns:   (\*(Aqfr\*(Aq, \*(Aqfr\-ca\*(Aq, \*(Aqi\-mingo\*(Aq)
\&
\&  extract_language_tags("It\*(Aqs like this: I\*(Aqm in fr \-\- French!")
\&    returns:   (\*(AqIt\*(Aq, \*(Aqin\*(Aq, \*(Aqfr\*(Aq)
\&  (So don\*(Aqt just feed it any old thing.)
.Ve
.Sp
The output is untainted.  If you don't know what tainting is,
don't worry about it.
.IP "\(bu" 4
the function same_language_tag($lang1, \f(CW$lang2\fR)
.Sp
Returns true iff \f(CW$lang1\fR and \f(CW$lang2\fR are acceptable variant tags
representing the same language-form.
.Sp
.Vb 10
\&   same_language_tag(\*(Aqx\-kadara\*(Aq, \*(Aqi\-kadara\*(Aq)  is TRUE
\&      (The x/i\- alternation doesn\*(Aqt matter)
\&   same_language_tag(\*(AqX\-KADARA\*(Aq, \*(Aqi\-kadara\*(Aq)  is TRUE
\&      (...and neither does case)
\&   same_language_tag(\*(Aqen\*(Aq,       \*(Aqen\-US\*(Aq)     is FALSE
\&      (all\-English is not the SAME as US English)
\&   same_language_tag(\*(Aqx\-kadara\*(Aq, \*(Aqx\-kadar\*(Aq)   is FALSE
\&      (these are totally unrelated tags)
\&   same_language_tag(\*(Aqno\-bok\*(Aq,    \*(Aqnb\*(Aq)       is TRUE
\&      (no\-bok is a legacy tag for nb (Norwegian Bokmal))
.Ve
.Sp
\&\f(CW\*(C`same_language_tag\*(C'\fR works by just seeing whether
\&\f(CW\*(C`encode_language_tag($lang1)\*(C'\fR is the same as
\&\f(CW\*(C`encode_language_tag($lang2)\*(C'\fR.
.Sp
(Yes, I know this function is named a bit oddly.  Call it historic
reasons.)
.IP "\(bu" 4
the function similarity_language_tag($lang1, \f(CW$lang2\fR)
.Sp
Returns an integer representing the degree of similarity between
tags \f(CW$lang1\fR and \f(CW$lang2\fR (the order of which does not matter), where
similarity is the number of common elements on the left,
without regard to case and to x/i\- alternation.
.Sp
.Vb 4
\&   similarity_language_tag(\*(Aqfr\*(Aq, \*(Aqfr\-ca\*(Aq)           is 1
\&      (one element in common)
\&   similarity_language_tag(\*(Aqfr\-ca\*(Aq, \*(Aqfr\-FR\*(Aq)        is 1
\&      (one element in common)
\&
\&   similarity_language_tag(\*(Aqfr\-CA\-joual\*(Aq,
\&                           \*(Aqfr\-CA\-PEI\*(Aq)             is 2
\&   similarity_language_tag(\*(Aqfr\-CA\-joual\*(Aq, \*(Aqfr\-CA\*(Aq)  is 2
\&      (two elements in common)
\&
\&   similarity_language_tag(\*(Aqx\-kadara\*(Aq, \*(Aqi\-kadara\*(Aq)  is 1
\&      (x/i\- doesn\*(Aqt matter)
\&
\&   similarity_language_tag(\*(Aqen\*(Aq,       \*(Aqx\-kadar\*(Aq)   is 0
\&   similarity_language_tag(\*(Aqx\-kadara\*(Aq, \*(Aqx\-kadar\*(Aq)   is 0
\&      (unrelated tags \-\- no similarity)
\&
\&   similarity_language_tag(\*(Aqi\-cree\-syllabic\*(Aq,
\&                           \*(Aqi\-cherokee\-syllabic\*(Aq)   is 0
\&      (no B<leftmost> elements in common!)
.Ve
.IP "\(bu" 4
the function is_dialect_of($lang1, \f(CW$lang2\fR)
.Sp
Returns true iff language tag \f(CW$lang1\fR represents a subform of
language tag \f(CW$lang2\fR.
.Sp
\&\fBGet the order right!  It doesn't work the other way around!\fR
.Sp
.Vb 2
\&   is_dialect_of(\*(Aqen\-US\*(Aq, \*(Aqen\*(Aq)            is TRUE
\&     (American English IS a dialect of all\-English)
\&
\&   is_dialect_of(\*(Aqfr\-CA\-joual\*(Aq, \*(Aqfr\-CA\*(Aq)   is TRUE
\&   is_dialect_of(\*(Aqfr\-CA\-joual\*(Aq, \*(Aqfr\*(Aq)      is TRUE
\&     (Joual is a dialect of (a dialect of) French)
\&
\&   is_dialect_of(\*(Aqen\*(Aq, \*(Aqen\-US\*(Aq)            is FALSE
\&     (all\-English is a NOT dialect of American English)
\&
\&   is_dialect_of(\*(Aqfr\*(Aq, \*(Aqen\-CA\*(Aq)            is FALSE
\&
\&   is_dialect_of(\*(Aqen\*(Aq,    \*(Aqen\*(Aq   )         is TRUE
\&   is_dialect_of(\*(Aqen\-US\*(Aq, \*(Aqen\-US\*(Aq)         is TRUE
\&     (B<Note:> these are degenerate cases)
\&
\&   is_dialect_of(\*(Aqi\-mingo\-tom\*(Aq, \*(Aqx\-Mingo\*(Aq) is TRUE
\&     (the x/i thing doesn\*(Aqt matter, nor does case)
\&
\&   is_dialect_of(\*(Aqnn\*(Aq, \*(Aqno\*(Aq)               is TRUE
\&     (because \*(Aqnn\*(Aq (New Norse) is aliased to \*(Aqno\-nyn\*(Aq,
\&      as a special legacy case, and \*(Aqno\-nyn\*(Aq is a
\&      subform of \*(Aqno\*(Aq (Norwegian))
.Ve
.IP "\(bu" 4
the function super_languages($lang1)
.Sp
Returns a list of language tags that are superordinate tags to \f(CW$lang1\fR
\&\*(-- it gets this by removing subtags from the end of \f(CW$lang1\fR until
nothing (or just \*(L"i\*(R" or \*(L"x\*(R") is left.
.Sp
.Vb 1
\&   super_languages("fr\-CA\-joual")  is  ("fr\-CA", "fr")
\&
\&   super_languages("en\-AU")  is  ("en")
\&
\&   super_languages("en")  is  empty\-list, ()
\&
\&   super_languages("i\-cherokee")  is  empty\-list, ()
\&    ...not ("i"), which would be illegal as well as pointless.
.Ve
.Sp
If \f(CW$lang1\fR is not a valid language tag, returns empty-list in
a list context, undef in a scalar context.
.Sp
A notable and rather unavoidable problem with this method:
\&\*(L"x\-mingo-tom\*(R" has an \*(L"x\*(R" because the whole tag isn't an
IANA-registered tag \*(-- but super_languages('x\-mingo\-tom') is
('x\-mingo') \*(-- which isn't really right, since 'i\-mingo' is
registered.  But this module has no way of knowing that.  (But note
that same_language_tag('x\-mingo', 'i\-mingo') is \s-1TRUE.\s0)
.Sp
More importantly, you assume \fIat your peril\fR that superordinates of
\&\f(CW$lang1\fR are mutually intelligible with \f(CW$lang1\fR.  Consider this
carefully.
.IP "\(bu" 4
the function locale2language_tag($locale_identifier)
.Sp
This takes a locale name (like \*(L"en\*(R", \*(L"en_US\*(R", or \*(L"en_US.ISO8859\-1\*(R")
and maps it to a language tag.  If it's not mappable (as with,
notably, \*(L"C\*(R" and \*(L"\s-1POSIX\*(R"\s0), this returns empty-list in a list context,
or undef in a scalar context.
.Sp
.Vb 1
\&   locale2language_tag("en") is "en"
\&
\&   locale2language_tag("en_US") is "en\-US"
\&
\&   locale2language_tag("en_US.ISO8859\-1") is "en\-US"
\&
\&   locale2language_tag("C") is undef or ()
\&
\&   locale2language_tag("POSIX") is undef or ()
\&
\&   locale2language_tag("POSIX") is undef or ()
.Ve
.Sp
I'm not totally sure that locale names map satisfactorily to language
tags.  Think \s-1REAL\s0 hard about how you use this.  \s-1YOU HAVE BEEN WARNED.\s0
.Sp
The output is untainted.  If you don't know what tainting is,
don't worry about it.
.IP "\(bu" 4
the function encode_language_tag($lang1)
.Sp
This function, if given a language tag, returns an encoding of it such
that:
.Sp
* tags representing different languages never get the same encoding.
.Sp
* tags representing the same language always get the same encoding.
.Sp
* an encoding of a formally valid language tag always is a string
value that is defined, has length, and is true if considered as a
boolean.
.Sp
Note that the encoding itself is \fBnot\fR a formally valid language tag.
Note also that you cannot, currently, go from an encoding back to a
language tag that it's an encoding of.
.Sp
Note also that you \fBmust\fR consider the encoded value as atomic; i.e.,
you should not consider it as anything but an opaque, unanalysable
string value.  (The internals of the encoding method may change in
future versions, as the language tagging standard changes over time.)
.Sp
\&\f(CW\*(C`encode_language_tag\*(C'\fR returns undef if given anything other than a
formally valid language tag.
.Sp
The reason \f(CW\*(C`encode_language_tag\*(C'\fR exists is because different language
tags may represent the same language; this is normally treatable with
\&\f(CW\*(C`same_language_tag\*(C'\fR, but consider this situation:
.Sp
You have a data file that expresses greetings in different languages.
Its format is \*(L"[language tag]=[how to say 'Hello']\*(R", like:
.Sp
.Vb 3
\&          en\-US=Hiho
\&          fr=Bonjour
\&          i\-mingo=Hau\*(Aq
.Ve
.Sp
And suppose you write a program that reads that file and then runs as
a daemon, answering client requests that specify a language tag and
then expect the string that says how to greet in that language.  So an
interaction looks like:
.Sp
.Vb 2
\&          greeting\-client asks:    fr
\&          greeting\-server answers: Bonjour
.Ve
.Sp
So far so good.  But suppose the way you're implementing this is:
.Sp
.Vb 9
\&          my %greetings;
\&          die unless open(IN, "<in.dat");
\&          while(<IN>) {
\&            chomp;
\&            next unless /^([^=]+)=(.+)/s;
\&            my($lang, $expr) = ($1, $2);
\&            $greetings{$lang} = $expr;
\&          }
\&          close(IN);
.Ve
.Sp
at which point \f(CW%greetings\fR has the contents:
.Sp
.Vb 3
\&          "en\-US"   => "Hiho"
\&          "fr"      => "Bonjour"
\&          "i\-mingo" => "Hau\*(Aq"
.Ve
.Sp
And suppose then that you answer client requests for language \f(CW$wanted\fR
by just looking up \f(CW$greetings\fR{$wanted}.
.Sp
If the client asks for \*(L"fr\*(R", that will look up successfully in
\&\f(CW%greetings\fR, to the value \*(L"Bonjour\*(R".  And if the client asks for
\&\*(L"i\-mingo\*(R", that will look up successfully in \f(CW%greetings\fR, to the value
\&\*(L"Hau'\*(R".
.Sp
But if the client asks for \*(L"i\-Mingo\*(R" or \*(L"x\-mingo\*(R", or \*(L"Fr\*(R", then the
lookup in \f(CW%greetings\fR fails.  That's the Wrong Thing.
.Sp
You could instead do lookups on \f(CW$wanted\fR with:
.Sp
.Vb 8
\&          use I18N::LangTags qw(same_language_tag);
\&          my $response = \*(Aq\*(Aq;
\&          foreach my $l2 (keys %greetings) {
\&            if(same_language_tag($wanted, $l2)) {
\&              $response = $greetings{$l2};
\&              last;
\&            }
\&          }
.Ve
.Sp
But that's rather inefficient.  A better way to do it is to start your
program with:
.Sp
.Vb 12
\&          use I18N::LangTags qw(encode_language_tag);
\&          my %greetings;
\&          die unless open(IN, "<in.dat");
\&          while(<IN>) {
\&            chomp;
\&            next unless /^([^=]+)=(.+)/s;
\&            my($lang, $expr) = ($1, $2);
\&            $greetings{
\&                        encode_language_tag($lang)
\&                      } = $expr;
\&          }
\&          close(IN);
.Ve
.Sp
and then just answer client requests for language \f(CW$wanted\fR by just
looking up
.Sp
.Vb 1
\&          $greetings{encode_language_tag($wanted)}
.Ve
.Sp
And that does the Right Thing.
.IP "\(bu" 4
the function alternate_language_tags($lang1)
.Sp
This function, if given a language tag, returns all language tags that
are alternate forms of this language tag.  (I.e., tags which refer to
the same language.)  This is meant to handle legacy tags caused by
the minor changes in language tag standards over the years; and
the x\-/i\- alternation is also dealt with.
.Sp
Note that this function does \fInot\fR try to equate new (and never-used,
and unusable)
\&\s-1ISO639\-2\s0 three-letter tags to old (and still in use) \s-1ISO639\-1\s0
two-letter equivalents \*(-- like \*(L"ara\*(R" \-> \*(L"ar\*(R" \*(-- because
\&\*(L"ara\*(R" has \fInever\fR been in use as an Internet language tag,
and \s-1RFC 3066\s0 stipulates that it never should be, since a shorter
tag (\*(L"ar\*(R") exists.
.Sp
Examples:
.Sp
.Vb 10
\&  alternate_language_tags(\*(Aqno\-bok\*(Aq)       is (\*(Aqnb\*(Aq)
\&  alternate_language_tags(\*(Aqnb\*(Aq)           is (\*(Aqno\-bok\*(Aq)
\&  alternate_language_tags(\*(Aqhe\*(Aq)           is (\*(Aqiw\*(Aq)
\&  alternate_language_tags(\*(Aqiw\*(Aq)           is (\*(Aqhe\*(Aq)
\&  alternate_language_tags(\*(Aqi\-hakka\*(Aq)      is (\*(Aqzh\-hakka\*(Aq, \*(Aqx\-hakka\*(Aq)
\&  alternate_language_tags(\*(Aqzh\-hakka\*(Aq)     is (\*(Aqi\-hakka\*(Aq, \*(Aqx\-hakka\*(Aq)
\&  alternate_language_tags(\*(Aqen\*(Aq)           is ()
\&  alternate_language_tags(\*(Aqx\-mingo\-tom\*(Aq)  is (\*(Aqi\-mingo\-tom\*(Aq)
\&  alternate_language_tags(\*(Aqx\-klikitat\*(Aq)   is (\*(Aqi\-klikitat\*(Aq)
\&  alternate_language_tags(\*(Aqi\-klikitat\*(Aq)   is (\*(Aqx\-klikitat\*(Aq)
.Ve
.Sp
This function returns empty-list if given anything other than a formally
valid language tag.
.IP "\(bu" 4
the function \f(CW@langs\fR = panic_languages(@accept_languages)
.Sp
This function takes a list of 0 or more language
tags that constitute a given user's Accept-Language list, and
returns a list of tags for \fIother\fR (non-super)
languages that are probably acceptable to the user, to be
used \fIif all else fails\fR.
.Sp
For example, if a user accepts only 'ca' (Catalan) and
\&'es' (Spanish), and the documents/interfaces you have
available are just in German, Italian, and Chinese, then
the user will most likely want the Italian one (and not
the Chinese or German one!), instead of getting
nothing.  So \f(CW\*(C`panic_languages(\*(Aqca\*(Aq, \*(Aqes\*(Aq)\*(C'\fR returns
a list containing 'it' (Italian).
.Sp
English ('en') is \fIalways\fR in the return list, but
whether it's at the very end or not depends
on the input languages.  This function works by consulting
an internal table that stipulates what common
languages are \*(L"close\*(R" to each other.
.Sp
A useful construct you might consider using is:
.Sp
.Vb 4
\&  @fallbacks = super_languages(@accept_languages);
\&  push @fallbacks, panic_languages(
\&    @accept_languages, @fallbacks,
\&  );
.Ve
.IP "\(bu" 4
the function implicate_supers( ...languages... )
.Sp
This takes a list of strings (which are presumed to be language-tags;
strings that aren't, are ignored); and after each one, this function
inserts super-ordinate forms that don't already appear in the list.
The original list, plus these insertions, is returned.
.Sp
In other words, it takes this:
.Sp
.Vb 1
\&  pt\-br de\-DE en\-US fr pt\-br\-janeiro
.Ve
.Sp
and returns this:
.Sp
.Vb 1
\&  pt\-br pt de\-DE de en\-US en fr pt\-br\-janeiro
.Ve
.Sp
This function is most useful in the idiom
.Sp
.Vb 1
\&  implicate_supers( I18N::LangTags::Detect::detect() );
.Ve
.Sp
(See I18N::LangTags::Detect.)
.IP "\(bu" 4
the function implicate_supers_strictly( ...languages... )
.Sp
This works like \f(CW\*(C`implicate_supers\*(C'\fR except that the implicated
forms are added to the end of the return list.
.Sp
In other words, implicate_supers_strictly takes a list of strings
(which are presumed to be language-tags; strings that aren't, are
ignored) and after the whole given list, it inserts the super-ordinate forms 
of all given tags, minus any tags that already appear in the input list.
.Sp
In other words, it takes this:
.Sp
.Vb 1
\&  pt\-br de\-DE en\-US fr pt\-br\-janeiro
.Ve
.Sp
and returns this:
.Sp
.Vb 1
\&  pt\-br de\-DE en\-US fr pt\-br\-janeiro pt de en
.Ve
.Sp
The reason this function has \*(L"_strictly\*(R" in its name is that when
you're processing an Accept-Language list according to the RFCs, if
you interpret the RFCs quite strictly, then you would use
implicate_supers_strictly, but for normal use (i.e., common-sense use,
as far as I'm concerned) you'd use implicate_supers.
.SH "ABOUT LOWERCASING"
.IX Header "ABOUT LOWERCASING"
I've considered making all the above functions that output language
tags return all those tags strictly in lowercase.  Having all your
language tags in lowercase does make some things easier.  But you
might as well just lowercase as you like, or call
\&\f(CW\*(C`encode_language_tag($lang1)\*(C'\fR where appropriate.
.SH "ABOUT UNICODE PLAINTEXT LANGUAGE TAGS"
.IX Header "ABOUT UNICODE PLAINTEXT LANGUAGE TAGS"
In some future version of I18N::LangTags, I plan to include support
for RFC2482\-style language tags \*(-- which are basically just normal
language tags with their \s-1ASCII\s0 characters shifted into Plane 14.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
* I18N::LangTags::List
.PP
* \s-1RFC 3066, \s0\f(CW\*(C`http://www.ietf.org/rfc/rfc3066.txt\*(C'\fR, \*(L"Tags for the
Identification of Languages\*(R".  (Obsoletes \s-1RFC 1766\s0)
.PP
* \s-1RFC 2277, \s0\f(CW\*(C`http://www.ietf.org/rfc/rfc2277.txt\*(C'\fR, \*(L"\s-1IETF\s0 Policy on
Character Sets and Languages\*(R".
.PP
* \s-1RFC 2231, \s0\f(CW\*(C`http://www.ietf.org/rfc/rfc2231.txt\*(C'\fR, \*(L"\s-1MIME\s0 Parameter
Value and Encoded Word Extensions: Character Sets, Languages, and
Continuations\*(R".
.PP
* \s-1RFC 2482, \s0\f(CW\*(C`http://www.ietf.org/rfc/rfc2482.txt\*(C'\fR,
\&\*(L"Language Tagging in Unicode Plain Text\*(R".
.PP
* Locale::Codes, in
\&\f(CW\*(C`http://www.perl.com/CPAN/modules/by\-module/Locale/\*(C'\fR
.PP
* \s-1ISO 639\-2, \s0\*(L"Codes for the representation of names of languages\*(R",
including two-letter and three-letter codes,
\&\f(CW\*(C`http://www.loc.gov/standards/iso639\-2/php/code_list.php\*(C'\fR
.PP
* The \s-1IANA\s0 list of registered languages (hopefully up-to-date),
\&\f(CW\*(C`http://www.iana.org/assignments/language\-tags\*(C'\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1998+ Sean M. Burke. All rights reserved.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
The programs and documentation in this dist are distributed in
the hope that they will be useful, but without any warranty; without
even the implied warranty of merchantability or fitness for a
particular purpose.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sean M. Burke \f(CW\*(C`sburke@cpan.org\*(C'\fR
                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/I18N::LangTags5.16.3pm                       0100644 0001750 0001750 00000055630 12566207434 024111  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "I18N::LangTags 3pm"
.TH I18N::LangTags 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
I18N::LangTags \- functions for dealing with RFC3066\-style language tags
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use I18N::LangTags();
.Ve
.PP
\&...or specify whichever of those functions you want to import, like so:
.PP
.Vb 1
\&  use I18N::LangTags qw(implicate_supers similarity_language_tag);
.Ve
.PP
All the exportable functions are listed below \*(-- you're free to import
only some, or none at all.  By default, none are imported.  If you
say:
.PP
.Vb 1
\&    use I18N::LangTags qw(:ALL)
.Ve
.PP
\&...then all are exported.  (This saves you from having to use
something less obvious like \f(CW\*(C`use I18N::LangTags qw(/./)\*(C'\fR.)
.PP
If you don't import any of these functions, assume a \f(CW&I18N::LangTags::\fR
in front of all the function names in the following examples.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Language tags are a formalism, described in \s-1RFC\s0 3066 (obsoleting
1766), for declaring what language form (language and possibly
dialect) a given chunk of information is in.
.PP
This library provides functions for common tasks involving language
tags as they are needed in a variety of protocols and applications.
.PP
Please see the \*(L"See Also\*(R" references for a thorough explanation
of how to correctly use language tags.
.IP "\(bu" 4
the function is_language_tag($lang1)
.Sp
Returns true iff \f(CW$lang1\fR is a formally valid language tag.
.Sp
.Vb 3
\&   is_language_tag("fr")            is TRUE
\&   is_language_tag("x\-jicarilla")   is FALSE
\&       (Subtags can be 8 chars long at most \-\- \*(Aqjicarilla\*(Aq is 9)
\&
\&   is_language_tag("sgn\-US")    is TRUE
\&       (That\*(Aqs American Sign Language)
\&
\&   is_language_tag("i\-Klikitat")    is TRUE
\&       (True without regard to the fact noone has actually
\&        registered Klikitat \-\- it\*(Aqs a formally valid tag)
\&
\&   is_language_tag("fr\-patois")     is TRUE
\&       (Formally valid \-\- altho descriptively weak!)
\&
\&   is_language_tag("Spanish")       is FALSE
\&   is_language_tag("french\-patois") is FALSE
\&       (No good \-\- first subtag has to match
\&        /^([xXiI]|[a\-zA\-Z]{2,3})$/ \-\- see RFC3066)
\&
\&   is_language_tag("x\-borg\-prot2532") is TRUE
\&       (Yes, subtags can contain digits, as of RFC3066)
.Ve
.IP "\(bu" 4
the function extract_language_tags($whatever)
.Sp
Returns a list of whatever looks like formally valid language tags
in \f(CW$whatever\fR.  Not very smart, so don't get too creative with
what you want to feed it.
.Sp
.Vb 2
\&  extract_language_tags("fr, fr\-ca, i\-mingo")
\&    returns:   (\*(Aqfr\*(Aq, \*(Aqfr\-ca\*(Aq, \*(Aqi\-mingo\*(Aq)
\&
\&  extract_language_tags("It\*(Aqs like this: I\*(Aqm in fr \-\- French!")
\&    returns:   (\*(AqIt\*(Aq, \*(Aqin\*(Aq, \*(Aqfr\*(Aq)
\&  (So don\*(Aqt just feed it any old thing.)
.Ve
.Sp
The output is untainted.  If you don't know what tainting is,
don't worry about it.
.IP "\(bu" 4
the function same_language_tag($lang1, \f(CW$lang2\fR)
.Sp
Returns true iff \f(CW$lang1\fR and \f(CW$lang2\fR are acceptable variant tags
representing the same language-form.
.Sp
.Vb 10
\&   same_language_tag(\*(Aqx\-kadara\*(Aq, \*(Aqi\-kadara\*(Aq)  is TRUE
\&      (The x/i\- alternation doesn\*(Aqt matter)
\&   same_language_tag(\*(AqX\-KADARA\*(Aq, \*(Aqi\-kadara\*(Aq)  is TRUE
\&      (...and neither does case)
\&   same_language_tag(\*(Aqen\*(Aq,       \*(Aqen\-US\*(Aq)     is FALSE
\&      (all\-English is not the SAME as US English)
\&   same_language_tag(\*(Aqx\-kadara\*(Aq, \*(Aqx\-kadar\*(Aq)   is FALSE
\&      (these are totally unrelated tags)
\&   same_language_tag(\*(Aqno\-bok\*(Aq,    \*(Aqnb\*(Aq)       is TRUE
\&      (no\-bok is a legacy tag for nb (Norwegian Bokmal))
.Ve
.Sp
\&\f(CW\*(C`same_language_tag\*(C'\fR works by just seeing whether
\&\f(CW\*(C`encode_language_tag($lang1)\*(C'\fR is the same as
\&\f(CW\*(C`encode_language_tag($lang2)\*(C'\fR.
.Sp
(Yes, I know this function is named a bit oddly.  Call it historic
reasons.)
.IP "\(bu" 4
the function similarity_language_tag($lang1, \f(CW$lang2\fR)
.Sp
Returns an integer representing the degree of similarity between
tags \f(CW$lang1\fR and \f(CW$lang2\fR (the order of which does not matter), where
similarity is the number of common elements on the left,
without regard to case and to x/i\- alternation.
.Sp
.Vb 4
\&   similarity_language_tag(\*(Aqfr\*(Aq, \*(Aqfr\-ca\*(Aq)           is 1
\&      (one element in common)
\&   similarity_language_tag(\*(Aqfr\-ca\*(Aq, \*(Aqfr\-FR\*(Aq)        is 1
\&      (one element in common)
\&
\&   similarity_language_tag(\*(Aqfr\-CA\-joual\*(Aq,
\&                           \*(Aqfr\-CA\-PEI\*(Aq)             is 2
\&   similarity_language_tag(\*(Aqfr\-CA\-joual\*(Aq, \*(Aqfr\-CA\*(Aq)  is 2
\&      (two elements in common)
\&
\&   similarity_language_tag(\*(Aqx\-kadara\*(Aq, \*(Aqi\-kadara\*(Aq)  is 1
\&      (x/i\- doesn\*(Aqt matter)
\&
\&   similarity_language_tag(\*(Aqen\*(Aq,       \*(Aqx\-kadar\*(Aq)   is 0
\&   similarity_language_tag(\*(Aqx\-kadara\*(Aq, \*(Aqx\-kadar\*(Aq)   is 0
\&      (unrelated tags \-\- no similarity)
\&
\&   similarity_language_tag(\*(Aqi\-cree\-syllabic\*(Aq,
\&                           \*(Aqi\-cherokee\-syllabic\*(Aq)   is 0
\&      (no B<leftmost> elements in common!)
.Ve
.IP "\(bu" 4
the function is_dialect_of($lang1, \f(CW$lang2\fR)
.Sp
Returns true iff language tag \f(CW$lang1\fR represents a subform of
language tag \f(CW$lang2\fR.
.Sp
\&\fBGet the order right!  It doesn't work the other way around!\fR
.Sp
.Vb 2
\&   is_dialect_of(\*(Aqen\-US\*(Aq, \*(Aqen\*(Aq)            is TRUE
\&     (American English IS a dialect of all\-English)
\&
\&   is_dialect_of(\*(Aqfr\-CA\-joual\*(Aq, \*(Aqfr\-CA\*(Aq)   is TRUE
\&   is_dialect_of(\*(Aqfr\-CA\-joual\*(Aq, \*(Aqfr\*(Aq)      is TRUE
\&     (Joual is a dialect of (a dialect of) French)
\&
\&   is_dialect_of(\*(Aqen\*(Aq, \*(Aqen\-US\*(Aq)            is FALSE
\&     (all\-English is a NOT dialect of American English)
\&
\&   is_dialect_of(\*(Aqfr\*(Aq, \*(Aqen\-CA\*(Aq)            is FALSE
\&
\&   is_dialect_of(\*(Aqen\*(Aq,    \*(Aqen\*(Aq   )         is TRUE
\&   is_dialect_of(\*(Aqen\-US\*(Aq, \*(Aqen\-US\*(Aq)         is TRUE
\&     (B<Note:> these are degenerate cases)
\&
\&   is_dialect_of(\*(Aqi\-mingo\-tom\*(Aq, \*(Aqx\-Mingo\*(Aq) is TRUE
\&     (the x/i thing doesn\*(Aqt matter, nor does case)
\&
\&   is_dialect_of(\*(Aqnn\*(Aq, \*(Aqno\*(Aq)               is TRUE
\&     (because \*(Aqnn\*(Aq (New Norse) is aliased to \*(Aqno\-nyn\*(Aq,
\&      as a special legacy case, and \*(Aqno\-nyn\*(Aq is a
\&      subform of \*(Aqno\*(Aq (Norwegian))
.Ve
.IP "\(bu" 4
the function super_languages($lang1)
.Sp
Returns a list of language tags that are superordinate tags to \f(CW$lang1\fR
\&\*(-- it gets this by removing subtags from the end of \f(CW$lang1\fR until
nothing (or just \*(L"i\*(R" or \*(L"x\*(R") is left.
.Sp
.Vb 1
\&   super_languages("fr\-CA\-joual")  is  ("fr\-CA", "fr")
\&
\&   super_languages("en\-AU")  is  ("en")
\&
\&   super_languages("en")  is  empty\-list, ()
\&
\&   super_languages("i\-cherokee")  is  empty\-list, ()
\&    ...not ("i"), which would be illegal as well as pointless.
.Ve
.Sp
If \f(CW$lang1\fR is not a valid language tag, returns empty-list in
a list context, undef in a scalar context.
.Sp
A notable and rather unavoidable problem with this method:
\&\*(L"x\-mingo-tom\*(R" has an \*(L"x\*(R" because the whole tag isn't an
IANA-registered tag \*(-- but super_languages('x\-mingo\-tom') is
('x\-mingo') \*(-- which isn't really right, since 'i\-mingo' is
registered.  But this module has no way of knowing that.  (But note
that same_language_tag('x\-mingo', 'i\-mingo') is \s-1TRUE\s0.)
.Sp
More importantly, you assume \fIat your peril\fR that superordinates of
\&\f(CW$lang1\fR are mutually intelligible with \f(CW$lang1\fR.  Consider this
carefully.
.IP "\(bu" 4
the function locale2language_tag($locale_identifier)
.Sp
This takes a locale name (like \*(L"en\*(R", \*(L"en_US\*(R", or \*(L"en_US.ISO8859\-1\*(R")
and maps it to a language tag.  If it's not mappable (as with,
notably, \*(L"C\*(R" and \*(L"\s-1POSIX\s0\*(R"), this returns empty-list in a list context,
or undef in a scalar context.
.Sp
.Vb 1
\&   locale2language_tag("en") is "en"
\&
\&   locale2language_tag("en_US") is "en\-US"
\&
\&   locale2language_tag("en_US.ISO8859\-1") is "en\-US"
\&
\&   locale2language_tag("C") is undef or ()
\&
\&   locale2language_tag("POSIX") is undef or ()
\&
\&   locale2language_tag("POSIX") is undef or ()
.Ve
.Sp
I'm not totally sure that locale names map satisfactorily to language
tags.  Think \s-1REAL\s0 hard about how you use this.  \s-1YOU\s0 \s-1HAVE\s0 \s-1BEEN\s0 \s-1WARNED\s0.
.Sp
The output is untainted.  If you don't know what tainting is,
don't worry about it.
.IP "\(bu" 4
the function encode_language_tag($lang1)
.Sp
This function, if given a language tag, returns an encoding of it such
that:
.Sp
* tags representing different languages never get the same encoding.
.Sp
* tags representing the same language always get the same encoding.
.Sp
* an encoding of a formally valid language tag always is a string
value that is defined, has length, and is true if considered as a
boolean.
.Sp
Note that the encoding itself is \fBnot\fR a formally valid language tag.
Note also that you cannot, currently, go from an encoding back to a
language tag that it's an encoding of.
.Sp
Note also that you \fBmust\fR consider the encoded value as atomic; i.e.,
you should not consider it as anything but an opaque, unanalysable
string value.  (The internals of the encoding method may change in
future versions, as the language tagging standard changes over time.)
.Sp
\&\f(CW\*(C`encode_language_tag\*(C'\fR returns undef if given anything other than a
formally valid language tag.
.Sp
The reason \f(CW\*(C`encode_language_tag\*(C'\fR exists is because different language
tags may represent the same language; this is normally treatable with
\&\f(CW\*(C`same_language_tag\*(C'\fR, but consider this situation:
.Sp
You have a data file that expresses greetings in different languages.
Its format is \*(L"[language tag]=[how to say 'Hello']\*(R", like:
.Sp
.Vb 3
\&          en\-US=Hiho
\&          fr=Bonjour
\&          i\-mingo=Hau\*(Aq
.Ve
.Sp
And suppose you write a program that reads that file and then runs as
a daemon, answering client requests that specify a language tag and
then expect the string that says how to greet in that language.  So an
interaction looks like:
.Sp
.Vb 2
\&          greeting\-client asks:    fr
\&          greeting\-server answers: Bonjour
.Ve
.Sp
So far so good.  But suppose the way you're implementing this is:
.Sp
.Vb 9
\&          my %greetings;
\&          die unless open(IN, "<in.dat");
\&          while(<IN>) {
\&            chomp;
\&            next unless /^([^=]+)=(.+)/s;
\&            my($lang, $expr) = ($1, $2);
\&            $greetings{$lang} = $expr;
\&          }
\&          close(IN);
.Ve
.Sp
at which point \f(CW%greetings\fR has the contents:
.Sp
.Vb 3
\&          "en\-US"   => "Hiho"
\&          "fr"      => "Bonjour"
\&          "i\-mingo" => "Hau\*(Aq"
.Ve
.Sp
And suppose then that you answer client requests for language \f(CW$wanted\fR
by just looking up \f(CW$greetings\fR{$wanted}.
.Sp
If the client asks for \*(L"fr\*(R", that will look up successfully in
\&\f(CW%greetings\fR, to the value \*(L"Bonjour\*(R".  And if the client asks for
\&\*(L"i\-mingo\*(R", that will look up successfully in \f(CW%greetings\fR, to the value
\&\*(L"Hau'\*(R".
.Sp
But if the client asks for \*(L"i\-Mingo\*(R" or \*(L"x\-mingo\*(R", or \*(L"Fr\*(R", then the
lookup in \f(CW%greetings\fR fails.  That's the Wrong Thing.
.Sp
You could instead do lookups on \f(CW$wanted\fR with:
.Sp
.Vb 8
\&          use I18N::LangTags qw(same_language_tag);
\&          my $response = \*(Aq\*(Aq;
\&          foreach my $l2 (keys %greetings) {
\&            if(same_language_tag($wanted, $l2)) {
\&              $response = $greetings{$l2};
\&              last;
\&            }
\&          }
.Ve
.Sp
But that's rather inefficient.  A better way to do it is to start your
program with:
.Sp
.Vb 12
\&          use I18N::LangTags qw(encode_language_tag);
\&          my %greetings;
\&          die unless open(IN, "<in.dat");
\&          while(<IN>) {
\&            chomp;
\&            next unless /^([^=]+)=(.+)/s;
\&            my($lang, $expr) = ($1, $2);
\&            $greetings{
\&                        encode_language_tag($lang)
\&                      } = $expr;
\&          }
\&          close(IN);
.Ve
.Sp
and then just answer client requests for language \f(CW$wanted\fR by just
looking up
.Sp
.Vb 1
\&          $greetings{encode_language_tag($wanted)}
.Ve
.Sp
And that does the Right Thing.
.IP "\(bu" 4
the function alternate_language_tags($lang1)
.Sp
This function, if given a language tag, returns all language tags that
are alternate forms of this language tag.  (I.e., tags which refer to
the same language.)  This is meant to handle legacy tags caused by
the minor changes in language tag standards over the years; and
the x\-/i\- alternation is also dealt with.
.Sp
Note that this function does \fInot\fR try to equate new (and never-used,
and unusable)
\&\s-1ISO639\-2\s0 three-letter tags to old (and still in use) \s-1ISO639\-1\s0
two-letter equivalents \*(-- like \*(L"ara\*(R" \-> \*(L"ar\*(R" \*(-- because
\&\*(L"ara\*(R" has \fInever\fR been in use as an Internet language tag,
and \s-1RFC\s0 3066 stipulates that it never should be, since a shorter
tag (\*(L"ar\*(R") exists.
.Sp
Examples:
.Sp
.Vb 10
\&  alternate_language_tags(\*(Aqno\-bok\*(Aq)       is (\*(Aqnb\*(Aq)
\&  alternate_language_tags(\*(Aqnb\*(Aq)           is (\*(Aqno\-bok\*(Aq)
\&  alternate_language_tags(\*(Aqhe\*(Aq)           is (\*(Aqiw\*(Aq)
\&  alternate_language_tags(\*(Aqiw\*(Aq)           is (\*(Aqhe\*(Aq)
\&  alternate_language_tags(\*(Aqi\-hakka\*(Aq)      is (\*(Aqzh\-hakka\*(Aq, \*(Aqx\-hakka\*(Aq)
\&  alternate_language_tags(\*(Aqzh\-hakka\*(Aq)     is (\*(Aqi\-hakka\*(Aq, \*(Aqx\-hakka\*(Aq)
\&  alternate_language_tags(\*(Aqen\*(Aq)           is ()
\&  alternate_language_tags(\*(Aqx\-mingo\-tom\*(Aq)  is (\*(Aqi\-mingo\-tom\*(Aq)
\&  alternate_language_tags(\*(Aqx\-klikitat\*(Aq)   is (\*(Aqi\-klikitat\*(Aq)
\&  alternate_language_tags(\*(Aqi\-klikitat\*(Aq)   is (\*(Aqx\-klikitat\*(Aq)
.Ve
.Sp
This function returns empty-list if given anything other than a formally
valid language tag.
.IP "\(bu" 4
the function \f(CW@langs\fR = panic_languages(@accept_languages)
.Sp
This function takes a list of 0 or more language
tags that constitute a given user's Accept-Language list, and
returns a list of tags for \fIother\fR (non-super)
languages that are probably acceptable to the user, to be
used \fIif all else fails\fR.
.Sp
For example, if a user accepts only 'ca' (Catalan) and
\&'es' (Spanish), and the documents/interfaces you have
available are just in German, Italian, and Chinese, then
the user will most likely want the Italian one (and not
the Chinese or German one!), instead of getting
nothing.  So \f(CW\*(C`panic_languages(\*(Aqca\*(Aq, \*(Aqes\*(Aq)\*(C'\fR returns
a list containing 'it' (Italian).
.Sp
English ('en') is \fIalways\fR in the return list, but
whether it's at the very end or not depends
on the input languages.  This function works by consulting
an internal table that stipulates what common
languages are \*(L"close\*(R" to each other.
.Sp
A useful construct you might consider using is:
.Sp
.Vb 4
\&  @fallbacks = super_languages(@accept_languages);
\&  push @fallbacks, panic_languages(
\&    @accept_languages, @fallbacks,
\&  );
.Ve
.IP "\(bu" 4
the function implicate_supers( ...languages... )
.Sp
This takes a list of strings (which are presumed to be language-tags;
strings that aren't, are ignored); and after each one, this function
inserts super-ordinate forms that don't already appear in the list.
The original list, plus these insertions, is returned.
.Sp
In other words, it takes this:
.Sp
.Vb 1
\&  pt\-br de\-DE en\-US fr pt\-br\-janeiro
.Ve
.Sp
and returns this:
.Sp
.Vb 1
\&  pt\-br pt de\-DE de en\-US en fr pt\-br\-janeiro
.Ve
.Sp
This function is most useful in the idiom
.Sp
.Vb 1
\&  implicate_supers( I18N::LangTags::Detect::detect() );
.Ve
.Sp
(See I18N::LangTags::Detect.)
.IP "\(bu" 4
the function implicate_supers_strictly( ...languages... )
.Sp
This works like \f(CW\*(C`implicate_supers\*(C'\fR except that the implicated
forms are added to the end of the return list.
.Sp
In other words, implicate_supers_strictly takes a list of strings
(which are presumed to be language-tags; strings that aren't, are
ignored) and after the whole given list, it inserts the super-ordinate forms 
of all given tags, minus any tags that already appear in the input list.
.Sp
In other words, it takes this:
.Sp
.Vb 1
\&  pt\-br de\-DE en\-US fr pt\-br\-janeiro
.Ve
.Sp
and returns this:
.Sp
.Vb 1
\&  pt\-br de\-DE en\-US fr pt\-br\-janeiro pt de en
.Ve
.Sp
The reason this function has \*(L"_strictly\*(R" in its name is that when
you're processing an Accept-Language list according to the RFCs, if
you interpret the RFCs quite strictly, then you would use
implicate_supers_strictly, but for normal use (i.e., common-sense use,
as far as I'm concerned) you'd use implicate_supers.
.SH "ABOUT LOWERCASING"
.IX Header "ABOUT LOWERCASING"
I've considered making all the above functions that output language
tags return all those tags strictly in lowercase.  Having all your
language tags in lowercase does make some things easier.  But you
might as well just lowercase as you like, or call
\&\f(CW\*(C`encode_language_tag($lang1)\*(C'\fR where appropriate.
.SH "ABOUT UNICODE PLAINTEXT LANGUAGE TAGS"
.IX Header "ABOUT UNICODE PLAINTEXT LANGUAGE TAGS"
In some future version of I18N::LangTags, I plan to include support
for RFC2482\-style language tags \*(-- which are basically just normal
language tags with their \s-1ASCII\s0 characters shifted into Plane 14.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
* I18N::LangTags::List
.PP
* \s-1RFC\s0 3066, \f(CW\*(C`http://www.ietf.org/rfc/rfc3066.txt\*(C'\fR, \*(L"Tags for the
Identification of Languages\*(R".  (Obsoletes \s-1RFC\s0 1766)
.PP
* \s-1RFC\s0 2277, \f(CW\*(C`http://www.ietf.org/rfc/rfc2277.txt\*(C'\fR, \*(L"\s-1IETF\s0 Policy on
Character Sets and Languages\*(R".
.PP
* \s-1RFC\s0 2231, \f(CW\*(C`http://www.ietf.org/rfc/rfc2231.txt\*(C'\fR, \*(L"\s-1MIME\s0 Parameter
Value and Encoded Word Extensions: Character Sets, Languages, and
Continuations\*(R".
.PP
* \s-1RFC\s0 2482, \f(CW\*(C`http://www.ietf.org/rfc/rfc2482.txt\*(C'\fR,
\&\*(L"Language Tagging in Unicode Plain Text\*(R".
.PP
* Locale::Codes, in
\&\f(CW\*(C`http://www.perl.com/CPAN/modules/by\-module/Locale/\*(C'\fR
.PP
* \s-1ISO\s0 639\-2, \*(L"Codes for the representation of names of languages\*(R",
including two-letter and three-letter codes,
\&\f(CW\*(C`http://www.loc.gov/standards/iso639\-2/php/code_list.php\*(C'\fR
.PP
* The \s-1IANA\s0 list of registered languages (hopefully up-to-date),
\&\f(CW\*(C`http://www.iana.org/assignments/language\-tags\*(C'\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1998+ Sean M. Burke. All rights reserved.
.PP
This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
The programs and documentation in this dist are distributed in
the hope that they will be useful, but without any warranty; without
even the implied warranty of merchantability or fitness for a
particular purpose.
.SH "AUTHOR"
.IX Header "AUTHOR"
Sean M. Burke \f(CW\*(C`sburke@cpan.org\*(C'\fR
                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/I18N::LangTags5.18.3pm                       0100644 0001750 0001750 00000056124 12566207455 024115  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "I18N::LangTags 3pm"
.TH I18N::LangTags 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
I18N::LangTags \- functions for dealing with RFC3066\-style language tags
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use I18N::LangTags();
.Ve
.PP
\&...or specify whichever of those functions you want to import, like so:
.PP
.Vb 1
\&  use I18N::LangTags qw(implicate_supers similarity_language_tag);
.Ve
.PP
All the exportable functions are listed below \*(-- you're free to import
only some, or none at all.  By default, none are imported.  If you
say:
.PP
.Vb 1
\&    use I18N::LangTags qw(:ALL)
.Ve
.PP
\&...then all are exported.  (This saves you from having to use
something less obvious like \f(CW\*(C`use I18N::LangTags qw(/./)\*(C'\fR.)
.PP
If you don't import any of these functions, assume a \f(CW&I18N::LangTags::\fR
in front of all the function names in the following examples.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Language tags are a formalism, described in \s-1RFC 3066 \s0(obsoleting
1766), for declaring what language form (language and possibly
dialect) a given chunk of information is in.
.PP
This library provides functions for common tasks involving language
tags as they are needed in a variety of protocols and applications.
.PP
Please see the \*(L"See Also\*(R" references for a thorough explanation
of how to correctly use language tags.
.IP "\(bu" 4
the function is_language_tag($lang1)
.Sp
Returns true iff \f(CW$lang1\fR is a formally valid language tag.
.Sp
.Vb 3
\&   is_language_tag("fr")            is TRUE
\&   is_language_tag("x\-jicarilla")   is FALSE
\&       (Subtags can be 8 chars long at most \-\- \*(Aqjicarilla\*(Aq is 9)
\&
\&   is_language_tag("sgn\-US")    is TRUE
\&       (That\*(Aqs American Sign Language)
\&
\&   is_language_tag("i\-Klikitat")    is TRUE
\&       (True without regard to the fact noone has actually
\&        registered Klikitat \-\- it\*(Aqs a formally valid tag)
\&
\&   is_language_tag("fr\-patois")     is TRUE
\&       (Formally valid \-\- altho descriptively weak!)
\&
\&   is_language_tag("Spanish")       is FALSE
\&   is_language_tag("french\-patois") is FALSE
\&       (No good \-\- first subtag has to match
\&        /^([xXiI]|[a\-zA\-Z]{2,3})$/ \-\- see RFC3066)
\&
\&   is_language_tag("x\-borg\-prot2532") is TRUE
\&       (Yes, subtags can contain digits, as of RFC3066)
.Ve
.IP "\(bu" 4
the function extract_language_tags($whatever)
.Sp
Returns a list of whatever looks like formally valid language tags
in \f(CW$whatever\fR.  Not very smart, so don't get too creative with
what you want to feed it.
.Sp
.Vb 2
\&  extract_language_tags("fr, fr\-ca, i\-mingo")
\&    returns:   (\*(Aqfr\*(Aq, \*(Aqfr\-ca\*(Aq, \*(Aqi\-mingo\*(Aq)
\&
\&  extract_language_tags("It\*(Aqs like this: I\*(Aqm in fr \-\- French!")
\&    returns:   (\*(AqIt\*(Aq, \*(Aqin\*(Aq, \*(Aqfr\*(Aq)
\&  (So don\*(Aqt just feed it any old thing.)
.Ve
.Sp
The output is untainted.  If you don't know what tainting is,
don't worry about it.
.IP "\(bu" 4
the function same_language_tag($lang1, \f(CW$lang2\fR)
.Sp
Returns true iff \f(CW$lang1\fR and \f(CW$lang2\fR are acceptable variant tags
representing the same language-form.
.Sp
.Vb 10
\&   same_language_tag(\*(Aqx\-kadara\*(Aq, \*(Aqi\-kadara\*(Aq)  is TRUE
\&      (The x/i\- alternation doesn\*(Aqt matter)
\&   same_language_tag(\*(AqX\-KADARA\*(Aq, \*(Aqi\-kadara\*(Aq)  is TRUE
\&      (...and neither does case)
\&   same_language_tag(\*(Aqen\*(Aq,       \*(Aqen\-US\*(Aq)     is FALSE
\&      (all\-English is not the SAME as US English)
\&   same_language_tag(\*(Aqx\-kadara\*(Aq, \*(Aqx\-kadar\*(Aq)   is FALSE
\&      (these are totally unrelated tags)
\&   same_language_tag(\*(Aqno\-bok\*(Aq,    \*(Aqnb\*(Aq)       is TRUE
\&      (no\-bok is a legacy tag for nb (Norwegian Bokmal))
.Ve
.Sp
\&\f(CW\*(C`same_language_tag\*(C'\fR works by just seeing whether
\&\f(CW\*(C`encode_language_tag($lang1)\*(C'\fR is the same as
\&\f(CW\*(C`encode_language_tag($lang2)\*(C'\fR.
.Sp
(Yes, I know this function is named a bit oddly.  Call it historic
reasons.)
.IP "\(bu" 4
the function similarity_language_tag($lang1, \f(CW$lang2\fR)
.Sp
Returns an integer representing the degree of similarity between
tags \f(CW$lang1\fR and \f(CW$lang2\fR (the order of which does not matter), where
similarity is the number of common elements on the left,
without regard to case and to x/i\- alternation.
.Sp
.Vb 4
\&   similarity_language_tag(\*(Aqfr\*(Aq, \*(Aqfr\-ca\*(Aq)           is 1
\&      (one element in common)
\&   similarity_language_tag(\*(Aqfr\-ca\*(Aq, \*(Aqfr\-FR\*(Aq)        is 1
\&      (one element in common)
\&
\&   similarity_language_tag(\*(Aqfr\-CA\-joual\*(Aq,
\&                           \*(Aqfr\-CA\-PEI\*(Aq)             is 2
\&   similarity_language_tag(\*(Aqfr\-CA\-joual\*(Aq, \*(Aqfr\-CA\*(Aq)  is 2
\&      (two elements in common)
\&
\&   similarity_language_tag(\*(Aqx\-kadara\*(Aq, \*(Aqi\-kadara\*(Aq)  is 1
\&      (x/i\- doesn\*(Aqt matter)
\&
\&   similarity_language_tag(\*(Aqen\*(Aq,       \*(Aqx\-kadar\*(Aq)   is 0
\&   similarity_language_tag(\*(Aqx\-kadara\*(Aq, \*(Aqx\-kadar\*(Aq)   is 0
\&      (unrelated tags \-\- no similarity)
\&
\&   similarity_language_tag(\*(Aqi\-cree\-syllabic\*(Aq,
\&                           \*(Aqi\-cherokee\-syllabic\*(Aq)   is 0
\&      (no B<leftmost> elements in common!)
.Ve
.IP "\(bu" 4
the function is_dialect_of($lang1, \f(CW$lang2\fR)
.Sp
Returns true iff language tag \f(CW$lang1\fR represents a subform of
language tag \f(CW$lang2\fR.
.Sp
\&\fBGet the order right!  It doesn't work the other way around!\fR
.Sp
.Vb 2
\&   is_dialect_of(\*(Aqen\-US\*(Aq, \*(Aqen\*(Aq)            is TRUE
\&     (American English IS a dialect of all\-English)
\&
\&   is_dialect_of(\*(Aqfr\-CA\-joual\*(Aq, \*(Aqfr\-CA\*(Aq)   is TRUE
\&   is_dialect_of(\*(Aqfr\-CA\-joual\*(Aq, \*(Aqfr\*(Aq)      is TRUE
\&     (Joual is a dialect of (a dialect of) French)
\&
\&   is_dialect_of(\*(Aqen\*(Aq, \*(Aqen\-US\*(Aq)            is FALSE
\&     (all\-English is a NOT dialect of American English)
\&
\&   is_dialect_of(\*(Aqfr\*(Aq, \*(Aqen\-CA\*(Aq)            is FALSE
\&
\&   is_dialect_of(\*(Aqen\*(Aq,    \*(Aqen\*(Aq   )         is TRUE
\&   is_dialect_of(\*(Aqen\-US\*(Aq, \*(Aqen\-US\*(Aq)         is TRUE
\&     (B<Note:> these are degenerate cases)
\&
\&   is_dialect_of(\*(Aqi\-mingo\-tom\*(Aq, \*(Aqx\-Mingo\*(Aq) is TRUE
\&     (the x/i thing doesn\*(Aqt matter, nor does case)
\&
\&   is_dialect_of(\*(Aqnn\*(Aq, \*(Aqno\*(Aq)               is TRUE
\&     (because \*(Aqnn\*(Aq (New Norse) is aliased to \*(Aqno\-nyn\*(Aq,
\&      as a special legacy case, and \*(Aqno\-nyn\*(Aq is a
\&      subform of \*(Aqno\*(Aq (Norwegian))
.Ve
.IP "\(bu" 4
the function super_languages($lang1)
.Sp
Returns a list of language tags that are superordinate tags to \f(CW$lang1\fR
\&\*(-- it gets this by removing subtags from the end of \f(CW$lang1\fR until
nothing (or just \*(L"i\*(R" or \*(L"x\*(R") is left.
.Sp
.Vb 1
\&   super_languages("fr\-CA\-joual")  is  ("fr\-CA", "fr")
\&
\&   super_languages("en\-AU")  is  ("en")
\&
\&   super_languages("en")  is  empty\-list, ()
\&
\&   super_languages("i\-cherokee")  is  empty\-list, ()
\&    ...not ("i"), which would be illegal as well as pointless.
.Ve
.Sp
If \f(CW$lang1\fR is not a valid language tag, returns empty-list in
a list context, undef in a scalar context.
.Sp
A notable and rather unavoidable problem with this method:
\&\*(L"x\-mingo-tom\*(R" has an \*(L"x\*(R" because the whole tag isn't an
IANA-registered tag \*(-- but super_languages('x\-mingo\-tom') is
('x\-mingo') \*(-- which isn't really right, since 'i\-mingo' is
registered.  But this module has no way of knowing that.  (But note
that same_language_tag('x\-mingo', 'i\-mingo') is \s-1TRUE.\s0)
.Sp
More importantly, you assume \fIat your peril\fR that superordinates of
\&\f(CW$lang1\fR are mutually intelligible with \f(CW$lang1\fR.  Consider this
carefully.
.IP "\(bu" 4
the function locale2language_tag($locale_identifier)
.Sp
This takes a locale name (like \*(L"en\*(R", \*(L"en_US\*(R", or \*(L"en_US.ISO8859\-1\*(R")
and maps it to a language tag.  If it's not mappable (as with,
notably, \*(L"C\*(R" and \*(L"\s-1POSIX\*(R"\s0), this returns empty-list in a list context,
or undef in a scalar context.
.Sp
.Vb 1
\&   locale2language_tag("en") is "en"
\&
\&   locale2language_tag("en_US") is "en\-US"
\&
\&   locale2language_tag("en_US.ISO8859\-1") is "en\-US"
\&
\&   locale2language_tag("C") is undef or ()
\&
\&   locale2language_tag("POSIX") is undef or ()
\&
\&   locale2language_tag("POSIX") is undef or ()
.Ve
.Sp
I'm not totally sure that locale names map satisfactorily to language
tags.  Think \s-1REAL\s0 hard about how you use this.  \s-1YOU HAVE BEEN WARNED.\s0
.Sp
The output is untainted.  If you don't know what tainting is,
don't worry about it.
.IP "\(bu" 4
the function encode_language_tag($lang1)
.Sp
This function, if given a language tag, returns an encoding of it such
that:
.Sp
* tags representing different languages never get the same encoding.
.Sp
* tags representing the same language always get the same encoding.
.Sp
* an encoding of a formally valid language tag always is a string
value that is defined, has length, and is true if considered as a
boolean.
.Sp
Note that the encoding itself is \fBnot\fR a formally valid language tag.
Note also that you cannot, currently, go from an encoding back to a
language tag that it's an encoding of.
.Sp
Note also that you \fBmust\fR consider the encoded value as atomic; i.e.,
you should not consider it as anything but an opaque, unanalysable
string value.  (The internals of the encoding method may change in
future versions, as the language tagging standard changes over time.)
.Sp
\&\f(CW\*(C`encode_language_tag\*(C'\fR returns undef if given anything other than a
formally valid language tag.
.Sp
The reason \f(CW\*(C`encode_language_tag\*(C'\fR exists is because different language
tags may represent the same language; this is normally treatable with
\&\f(CW\*(C`same_language_tag\*(C'\fR, but consider this situation:
.Sp
You have a data file that expresses greetings in different languages.
Its format is \*(L"[language tag]=[how to say 'Hello']\*(R", like:
.Sp
.Vb 3
\&          en\-US=Hiho
\&          fr=Bonjour
\&          i\-mingo=Hau\*(Aq
.Ve
.Sp
And suppose you write a program that reads that file and then runs as
a daemon, answering client requests that specify a language tag and
then expect the string that says how to greet in that language.  So an
interaction looks like:
.Sp
.Vb 2
\&          greeting\-client asks:    fr
\&          greeting\-server answers: Bonjour
.Ve
.Sp
So far so good.  But suppose the way you're implementing this is:
.Sp
.Vb 9
\&          my %greetings;
\&          die unless open(IN, "<in.dat");
\&          while(<IN>) {
\&            chomp;
\&            next unless /^([^=]+)=(.+)/s;
\&            my($lang, $expr) = ($1, $2);
\&            $greetings{$lang} = $expr;
\&          }
\&          close(IN);
.Ve
.Sp
at which point \f(CW%greetings\fR has the contents:
.Sp
.Vb 3
\&          "en\-US"   => "Hiho"
\&          "fr"      => "Bonjour"
\&          "i\-mingo" => "Hau\*(Aq"
.Ve
.Sp
And suppose then that you answer client requests for language \f(CW$wanted\fR
by just looking up \f(CW$greetings\fR{$wanted}.
.Sp
If the client asks for \*(L"fr\*(R", that will look up successfully in
\&\f(CW%greetings\fR, to the value \*(L"Bonjour\*(R".  And if the client asks for
\&\*(L"i\-mingo\*(R", that will look up successfully in \f(CW%greetings\fR, to the value
\&\*(L"Hau'\*(R".
.Sp
But if the client asks for \*(L"i\-Mingo\*(R" or \*(L"x\-mingo\*(R", or \*(L"Fr\*(R", then the
lookup in \f(CW%greetings\fR fails.  That's the Wrong Thing.
.Sp
You could instead do lookups on \f(CW$wanted\fR with:
.Sp
.Vb 8
\&          use I18N::LangTags qw(same_language_tag);
\&          my $response = \*(Aq\*(Aq;
\&          foreach my $l2 (keys %greetings) {
\&            if(same_language_tag($wanted, $l2)) {
\&              $response = $greetings{$l2};
\&              last;
\&            }
\&          }
.Ve
.Sp
But that's rather inefficient.  A better way to do it is to start your
program with:
.Sp
.Vb 12
\&          use I18N::LangTags qw(encode_language_tag);
\&          my %greetings;
\&          die unless open(IN, "<in.dat");
\&          while(<IN>) {
\&            chomp;
\&            next unless /^([^=]+)=(.+)/s;
\&            my($lang, $expr) = ($1, $2);
\&            $greetings{
\&                        encode_language_tag($lang)
\&                      } = $expr;
\&          }
\&          close(IN);
.Ve
.Sp
and then just answer client requests for language \f(CW$wanted\fR by just
looking up
.Sp
.Vb 1
\&          $greetings{encode_language_tag($wanted)}
.Ve
.Sp
And that does the Right Thing.
.IP "\(bu" 4
the function alternate_language_tags($lang1)
.Sp
This function, if given a language tag, returns all language tags that
are alternate forms of this language tag.  (I.e., tags which refer to
the same language.)  This is meant to handle legacy tags caused by
the minor changes in language tag standards over the years; and
the x\-/i\- alternation is also dealt with.
.Sp
Note that this function does \fInot\fR try to equate new (and never-used,
and unusable)
\&\s-1ISO639\-2\s0 three-letter tags to old (and still in use) \s-1ISO639\-1\s0
two-letter equivalents \*(-- like \*(L"ara\*(R" \-> \*(L"ar\*(R" \*(-- because
\&\