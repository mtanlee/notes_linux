nker
        CgoPkgConfig []string // cgo: pkg-config names

        // Dependency information
        Imports []string // import paths used by this package
        Deps    []string // all (recursively) imported dependencies

        // Error information
        Incomplete bool            // this package or a dependency has an error
        Error      *PackageError   // error loading package
        DepsErrors []*PackageError // errors loading dependencies

        TestGoFiles  []string // _test.go files in package
        TestImports  []string // imports from TestGoFiles
        XTestGoFiles []string // _test.go files outside package
        XTestImports []string // imports from XTestGoFiles
    }

The template function "join" calls strings.Join.

The template function "context" returns the build context, defined as:

	type Context struct {
		GOARCH        string   // target architecture
		GOOS          string   // target operating system
		GOROOT        string   // Go root
		GOPATH        string   // Go path
		CgoEnabled    bool     // whether cgo can be used
		UseAllFiles   bool     // use files regardless of +build lines, file names
		Compiler      string   // compiler to assume when computing target paths
		BuildTags     []string // build constraints to match in +build lines
		ReleaseTags   []string // releases the current release is compatible with
		InstallSuffix string   // suffix to use in the name of the install dir
	}

For more information about the meaning of these fields see the documentation
for the go/build package's Context type.

The -json flag causes the package data to be printed in JSON format
instead of using the template format.

The -e flag changes the handling of erroneous packages, those that
cannot be found or are malformed.  By default, the list command
prints an error to standard error for each erroneous package and
omits the packages from consideration during the usual printing.
With the -e flag, the list command never prints errors to standard
error and instead processes the erroneous packages with the usual
printing.  Erroneous packages will have a non-empty ImportPath and
a non-nil Error field; other information may or may not be missing
(zeroed).

For more about build flags, see 'go help build'.

For more about specifying packages, see 'go help packages'.


Compile and run Go program

Usage:

	go run [build flags] [-exec xprog] gofiles... [arguments...]

Run compiles and runs the main package comprising the named Go source files.
A Go source file is defined to be a file ending in a literal ".go" suffix.

By default, 'go run' runs the compiled binary directly: 'a.out arguments...'.
If the -exec flag is given, 'go run' invokes the binary using xprog: 'xprog a.out arguments...'.
If the -exec flag is not given, GOOS or GOARCH is different from the system
default, and a program named go_$GOOS_$GOARCH_exec can be found
on the current search path, 'go run' invokes the binary using that program,
for example 'go_nacl_386_exec a.out arguments...'. This allows execution of
cross-compiled programs when a simulator or other execution method is
available.

For more about build flags, see 'go help build'.

See also: go build.


Test packages

Usage:

	go test [-c] [-i] [build and test flags] [packages] [flags for test binary]

'Go test' automates testing the packages named by the import paths.
It prints a summary of the test results in the format:

	ok   archive/tar   0.011s
	FAIL archive/zip   0.022s
	ok   compress/gzip 0.033s
	...

followed by detailed output for each failed package.

'Go test' recompiles each package along with any files with names matching
the file pattern "*_test.go".
Files whose names begin with "_" (including "_test.go") or "." are ignored.
These additional files can contain test functions, benchmark functions, and
example functions.  See 'go help testfunc' for more.
Each listed package causes the execution of a separate test binary.

Test files that declare a package with the suffix "_test" will be compiled as a
separate package, and then linked and run with the main test binary.

By default, go test needs no arguments.  It compiles and tests the package
with source in the current directory, including tests, and runs the tests.

The package is built in a temporary directory so it does not interfere with the
non-test installation.

In addition to the build flags, the flags handled by 'go test' itself are:

	-c
		Compile the test binary to pkg.test but do not run it
		(where pkg is the last element of the package's import path).
		The file name can be changed with the -o flag.

	-exec xprog
	    Run the test binary using xprog. The behavior is the same as
	    in 'go run'. See 'go help run' for details.

	-i
	    Install packages that are dependencies of the test.
	    Do not run the test.

	-o file
		Compile the test binary to the named file.
		The test still runs (unless -c or -i is specified).


The test binary also accepts flags that control execution of the test; these
flags are also accessible by 'go test'.  See 'go help testflag' for details.

If the test binary needs any other flags, they should be presented after the
package names. The go tool treats as a flag the first argument that begins with
a minus sign that it does not recognize itself; that argument and all subsequent
arguments are passed as arguments to the test binary.

For more about build flags, see 'go help build'.
For more about specifying packages, see 'go help packages'.

See also: go build, go vet.


Run specified go tool

Usage:

	go tool [-n] command [args...]

Tool runs the go tool command identified by the arguments.
With no arguments it prints the list of known tools.

The -n flag causes tool to print the command that would be
executed but not execute it.

For more about each tool command, see 'go tool command -h'.


Print Go version

Usage:

	go version

Version prints the Go version, as reported by runtime.Version.


Run go tool vet on packages

Usage:

	go vet [-n] [-x] [packages]

Vet runs the Go vet command on the packages named by the import paths.

For more about vet, see 'godoc golang.org/x/tools/cmd/vet'.
For more about specifying packages, see 'go help packages'.

To run the vet tool with specific options, run 'go tool vet'.

The -n flag prints commands that would be executed.
The -x flag prints commands as they are executed.

See also: go fmt, go fix.


Calling between Go and C

There are two different ways to call between Go and C/C++ code.

The first is the cgo tool, which is part of the Go distribution.  For
information on how to use it see the cgo documentation (godoc cmd/cgo).

The second is the SWIG program, which is a general tool for
interfacing between languages.  For information on SWIG see
http://swig.org/.  When running go build, any file with a .swig
extension will be passed to SWIG.  Any file with a .swigcxx extension
will be passed to SWIG with the -c++ option.

When either cgo or SWIG is used, go build will pass any .c, .m, .s,
or .S files to the C compiler, and any .cc, .cpp, .cxx files to the C++
compiler.  The CC or CXX environment variables may be set to determine
the C or C++ compiler, respectively, to use.


File types

The go command examines the contents of a restricted set of files
in each directory. It identifies which files to examine based on
the extension of the file name. These extensions are:

	.go
		Go source files.
	.c, .h
		C source files.
		If the package uses cgo, these will be compiled with the
		OS-native compiler (typically gcc); otherwise they will be
		compiled with the Go-specific support compiler,
		5c, 6c, or 8c, etc. as appropriate.
	.cc, .cpp, .cxx, .hh, .hpp, .hxx
		C++ source files. Only useful with cgo or SWIG, and always
		compiled with the OS-native compiler.
	.m
		Objective-C source files. Only useful with cgo, and always
		compiled with the OS-native compiler.
	.s, .S
		Assembler source files.
		If the package uses cgo, these will be assembled with the
		OS-native assembler (typically gcc (sic)); otherwise they
		will be assembled with the Go-specific support assembler,
		5a, 6a, or 8a, etc., as appropriate.
	.swig, .swigcxx
		SWIG definition files.
	.syso
		System object files.

Files of each of these types except .syso may contain build
constraints, but the go command stops scanning for build constraints
at the first item in the file that is not a blank line or //-style
line comment.


GOPATH environment variable

The Go path is used to resolve import statements.
It is implemented by and documented in the go/build package.

The GOPATH environment variable lists places to look for Go code.
On Unix, the value is a colon-separated string.
On Windows, the value is a semicolon-separated string.
On Plan 9, the value is a list.

GOPATH must be set to get, build and install packages outside the
standard Go tree.

Each directory listed in GOPATH must have a prescribed structure:

The src/ directory holds source code.  The path below 'src'
determines the import path or executable name.

The pkg/ directory holds installed package objects.
As in the Go tree, each target operating system and
architecture pair has its own subdirectory of pkg
(pkg/GOOS_GOARCH).

If DIR is a directory listed in the GOPATH, a package with
source in DIR/src/foo/bar can be imported as "foo/bar" and
has its compiled form installed to "DIR/pkg/GOOS_GOARCH/foo/bar.a".

The bin/ directory holds compiled commands.
Each command is named for its source directory, but only
the final element, not the entire path.  That is, the
command with source in DIR/src/foo/quux is installed into
DIR/bin/quux, not DIR/bin/foo/quux.  The foo/ is stripped
so that you can add DIR/bin to your PATH to get at the
installed commands.  If the GOBIN environment variable is
set, commands are installed to the directory it names instead
of DIR/bin.

Here's an example directory layout:

    GOPATH=/home/user/gocode

    /home/user/gocode/
        src/
            foo/
                bar/               (go code in package bar)
                    x.go
                quux/              (go code in package main)
                    y.go
        bin/
            quux                   (installed command)
        pkg/
            linux_amd64/
                foo/
                    bar.a          (installed package object)

Go searches each directory listed in GOPATH to find source code,
but new packages are always downloaded into the first directory
in the list.


Import path syntax

An import path (see 'go help packages') denotes a package
stored in the local file system.  In general, an import path denotes
either a standard package (such as "unicode/utf8") or a package
found in one of the work spaces (see 'go help gopath').

Relative import paths

An import path beginning with ./ or ../ is called a relative path.
The toolchain supports relative import paths as a shortcut in two ways.

First, a relative path can be used as a shorthand on the command line.
If you are working in the directory containing the code imported as
"unicode" and want to run the tests for "unicode/utf8", you can type
"go test ./utf8" instead of needing to specify the full path.
Similarly, in the reverse situation, "go test .." will test "unicode" from
the "unicode/utf8" directory. Relative patterns are also allowed, like
"go test ./..." to test all subdirectories. See 'go help packages' for details
on the pattern syntax.

Second, if you are compiling a Go program not in a work space,
you can use a relative path in an import statement in that program
to refer to nearby code also not in a work space.
This makes it easy to experiment with small multipackage programs
outside of the usual work spaces, but such programs cannot be
installed with "go install" (there is no work space in which to install them),
so they are rebuilt from scratch each time they are built.
To avoid ambiguity, Go programs cannot use relative import paths
within a work space.

Remote import paths

Certain import paths also
describe how to obtain the source code for the package using
a revision control system.

A few common code hosting sites have special syntax:

	Bitbucket (Git, Mercurial)

		import "bitbucket.org/user/project"
		import "bitbucket.org/user/project/sub/directory"

	GitHub (Git)

		import "github.com/user/project"
		import "github.com/user/project/sub/directory"

	Google Code Project Hosting (Git, Mercurial, Subversion)

		import "code.google.com/p/project"
		import "code.google.com/p/project/sub/directory"

		import "code.google.com/p/project.subrepository"
		import "code.google.com/p/project.subrepository/sub/directory"

	Launchpad (Bazaar)

		import "launchpad.net/project"
		import "launchpad.net/project/series"
		import "launchpad.net/project/series/sub/directory"

		import "launchpad.net/~user/project/branch"
		import "launchpad.net/~user/project/branch/sub/directory"

	IBM DevOps Services (Git)

		import "hub.jazz.net/git/user/project"
		import "hub.jazz.net/git/user/project/sub/directory"

For code hosted on other servers, import paths may either be qualified
with the version control type, or the go tool can dynamically fetch
the import path over https/http and discover where the code resides
from a <meta> tag in the HTML.

To declare the code location, an import path of the form

	repository.vcs/path

specifies the given repository, with or without the .vcs suffix,
using the named version control system, and then the path inside
that repository.  The supported version control systems are:

	Bazaar      .bzr
	Git         .git
	Mercurial   .hg
	Subversion  .svn

For example,

	import "example.org/user/foo.hg"

denotes the root directory of the Mercurial repository at
example.org/user/foo or foo.hg, and

	import "example.org/repo.git/foo/bar"

denotes the foo/bar directory of the Git repository at
example.org/repo or repo.git.

When a version control system supports multiple protocols,
each is tried in turn when downloading.  For example, a Git
download tries git://, then https://, then http://.

If the import path is not a known code hosting site and also lacks a
version control qualifier, the go tool attempts to fetch the import
over https/http and looks for a <meta> tag in the document's HTML
<head>.

The meta tag has the form:

	<meta name="go-import" content="import-prefix vcs repo-root">

The import-prefix is the import path corresponding to the repository
root. It must be a prefix or an exact match of the package being
fetched with "go get". If it's not an exact match, another http
request is made at the prefix to verify the <meta> tags match.

The vcs is one of "git", "hg", "svn", etc,

The repo-root is the root of the version control system
containing a scheme and not containing a .vcs qualifier.

For example,

	import "example.org/pkg/foo"

will result in the following request(s):

	https://example.org/pkg/foo?go-get=1 (preferred)
	http://example.org/pkg/foo?go-get=1  (fallback)

If that page contains the meta tag

	<meta name="go-import" content="example.org git https://code.org/r/p/exproj">

the go tool will verify that https://example.org/?go-get=1 contains the
same meta tag and then git clone https://code.org/r/p/exproj into
GOPATH/src/example.org.

New downloaded packages are written to the first directory
listed in the GOPATH environment variable (see 'go help gopath').

The go command attempts to download the version of the
package appropriate for the Go release being used.
Run 'go help get' for more.

Import path checking

When the custom import path feature described above redirects to a
known code hosting site, each of the resulting packages has two possible
import paths, using the custom domain or the known hosting site.

A package statement is said to have an "import comment" if it is immediately
followed (before the next newline) by a comment of one of these two forms:

	package math // import "path"
	package math /* import "path" * /

The go command will refuse to install a package with an import comment
unless it is being referred to by that import path. In this way, import comments
let package authors make sure the custom import path is used and not a
direct path to the underlying code hosting site.

See https://golang.org/s/go14customimport for details.


Description of package lists

Many commands apply to a set of packages:

	go action [packages]

Usually, [packages] is a list of import paths.

An import path that is a rooted path or that begins with
a . or .. element is interpreted as a file system path and
denotes the package in that directory.

Otherwise, the import path P denotes the package found in
the directory DIR/src/P for some DIR listed in the GOPATH
environment variable (see 'go help gopath').

If no import paths are given, the action applies to the
package in the current directory.

There are three reserved names for paths that should not be used
for packages to be built with the go tool:

- "main" denotes the top-level package in a stand-alone executable.

- "all" expands to all package directories found in all the GOPATH
trees. For example, 'go list all' lists all the packages on the local
system.

- "std" is like all but expands to just the packages in the standard
Go library.

An import path is a pattern if it includes one or more "..." wildcards,
each of which can match any string, including the empty string and
strings containing slashes.  Such a pattern expands to all package
directories found in the GOPATH trees with names matching the
patterns.  As a special case, x/... matches x as well as x's subdirectories.
For example, net/... expands to net and packages in its subdirectories.

An import path can also name a package to be downloaded from
a remote repository.  Run 'go help importpath' for details.

Every package in a program must have a unique import path.
By convention, this is arranged by starting each path with a
unique prefix that belongs to you.  For example, paths used
internally at Google all begin with 'google', and paths
denoting remote repositories begin with the path to the code,
such as 'code.google.com/p/project'.

As a special case, if the package list is a list of .go files from a
single directory, the command is applied to a single synthesized
package made up of exactly those files, ignoring any build constraints
in those files and ignoring any other files in the directory.

Directory and file names that begin with "." or "_" are ignored
by the go tool, as are directories named "testdata".


Description of testing flags

The 'go test' command takes both flags that apply to 'go test' itself
and flags that apply to the resulting test binary.

Several of the flags control profiling and write an execution profile
suitable for "go tool pprof"; run "go tool pprof help" for more
information.  The --alloc_space, --alloc_objects, and --show_bytes
options of pprof control how the information is presented.

The following flags are recognized by the 'go test' command and
control the execution of any test:

	-bench regexp
	    Run benchmarks matching the regular expression.
	    By default, no benchmarks run. To run all benchmarks,
	    use '-bench .' or '-bench=.'.

	-benchmem
	    Print memory allocation statistics for benchmarks.

	-benchtime t
	    Run enough iterations of each benchmark to take t, specified
	    as a time.Duration (for example, -benchtime 1h30s).
	    The default is 1 second (1s).

	-blockprofile block.out
	    Write a goroutine blocking profile to the specified file
	    when all tests are complete.
	    Writes test binary as -c would.

	-blockprofilerate n
	    Control the detail provided in goroutine blocking profiles by
	    calling runtime.SetBlockProfileRate with n.
	    See 'godoc runtime SetBlockProfileRate'.
	    The profiler aims to sample, on average, one blocking event every
	    n nanoseconds the program spends blocked.  By default,
	    if -test.blockprofile is set without this flag, all blocking events
	    are recorded, equivalent to -test.blockprofilerate=1.

	-cover
	    Enable coverage analysis.

	-covermode set,count,atomic
	    Set the mode for coverage analysis for the package[s]
	    being tested. The default is "set" unless -race is enabled,
	    in which case it is "atomic".
	    The values:
		set: bool: does this statement run?
		count: int: how many times does this statement run?
		atomic: int: count, but correct in multithreaded tests;
			significantly more expensive.
	    Sets -cover.

	-coverpkg pkg1,pkg2,pkg3
	    Apply coverage analysis in each test to the given list of packages.
	    The default is for each test to analyze only the package being tested.
	    Packages are specified as import paths.
	    Sets -cover.

	-coverprofile cover.out
	    Write a coverage profile to the file after all tests have passed.
	    Sets -cover.

	-cpu 1,2,4
	    Specify a list of GOMAXPROCS values for which the tests or
	    benchmarks should be executed.  The default is the current value
	    of GOMAXPROCS.

	-cpuprofile cpu.out
	    Write a CPU profile to the specified file before exiting.
	    Writes test binary as -c would.

	-memprofile mem.out
	    Write a memory profile to the file after all tests have passed.
	    Writes test binary as -c would.

	-memprofilerate n
	    Enable more precise (and expensive) memory profiles by setting
	    runtime.MemProfileRate.  See 'godoc runtime MemProfileRate'.
	    To profile all memory allocations, use -test.memprofilerate=1
	    and pass --alloc_space flag to the pprof tool.

	-outputdir directory
	    Place output files from profiling in the specified directory,
	    by default the directory in which "go test" is running.

	-parallel n
	    Allow parallel execution of test functions that call t.Parallel.
	    The value of this flag is the maximum number of tests to run
	    simultaneously; by default, it is set to the value of GOMAXPROCS.

	-run regexp
	    Run only those tests and examples matching the regular
	    expression.

	-short
	    Tell long-running tests to shorten their run time.
	    It is off by default but set during all.bash so that installing
	    the Go tree can run a sanity check but not spend time running
	    exhaustive tests.

	-timeout t
	    If a test runs longer than t, panic.

	-v
	    Verbose output: log all tests as they are run. Also print all
	    text from Log and Logf calls even if the test succeeds.

The test binary, called pkg.test where pkg is the name of the
directory containing the package sources, can be invoked directly
after building it with 'go test -c'. When invoking the test binary
directly, each of the standard flag names must be prefixed with 'test.',
as in -test.run=TestMyFunc or -test.v.

When running 'go test', flags not listed above are passed through
unaltered. For instance, the command

	go test -x -v -cpuprofile=prof.out -dir=testdata -update

will compile the test binary and then run it as

	pkg.test -test.v -test.cpuprofile=prof.out -dir=testdata -update

The test flags that generate profiles (other than for coverage) also
leave the test binary in pkg.test for use when analyzing the profiles.

Flags not recognized by 'go test' must be placed after any specified packages.


Description of testing functions

The 'go test' command expects to find test, benchmark, and example functions
in the "*_test.go" files corresponding to the package under test.

A test function is one named TestXXX (where XXX is any alphanumeric string
not starting with a lower case letter) and should have the signature,

	func TestXXX(t *testing.T) { ... }

A benchmark function is one named BenchmarkXXX and should have the signature,

	func BenchmarkXXX(b *testing.B) { ... }

An example function is similar to a test function but, instead of using
*testing.T to report success or failure, prints output to os.Stdout.
That output is compared against the function's "Output:" comment, which
must be the last comment in the function body (see example below). An
example with no such comment, or with no text after "Output:" is compiled
but not executed.

Godoc displays the body of ExampleXXX to demonstrate the use
of the function, constant, or variable XXX.  An example of a method M with
receiver type T or *T is named ExampleT_M.  There may be multiple examples
for a given function, constant, or variable, distinguished by a trailing _xxx,
where xxx is a suffix not beginning with an upper case letter.

Here is an example of an example:

	func ExamplePrintln() {
		Println("The output of\nthis example.")
		// Output: The output of
		// this example.
	}

The entire test file is presented as the example when it contains a single
example function, at least one other function, type, variable, or constant
declaration, and no test or benchmark functions.

See the documentation of the testing package for more information.


*/
package main
                                                                                                                                                                                                                                                       root/go1.4/src/cmd/go/env.go                                                                        0100644 0000000 0000000 00000004426 12600426226 014144  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2012 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
	"os"
	"runtime"
	"strings"
)

var cmdEnv = &Command{
	Run:       runEnv,
	UsageLine: "env [var ...]",
	Short:     "print Go environment information",
	Long: `
Env prints Go environment information.

By default env prints information as a shell script
(on Windows, a batch file).  If one or more variable
names is given as arguments,  env prints the value of
each named variable on its own line.
	`,
}

type envVar struct {
	name, value string
}

func mkEnv() []envVar {
	var b builder
	b.init()

	env := []envVar{
		{"GOARCH", goarch},
		{"GOBIN", gobin},
		{"GOCHAR", archChar},
		{"GOEXE", exeSuffix},
		{"GOHOSTARCH", runtime.GOARCH},
		{"GOHOSTOS", runtime.GOOS},
		{"GOOS", goos},
		{"GOPATH", os.Getenv("GOPATH")},
		{"GORACE", os.Getenv("GORACE")},
		{"GOROOT", goroot},
		{"GOTOOLDIR", toolDir},

		// disable escape codes in clang errors
		{"TERM", "dumb"},
	}

	if goos != "plan9" {
		cmd := b.gccCmd(".")
		env = append(env, envVar{"CC", cmd[0]})
		env = append(env, envVar{"GOGCCFLAGS", strings.Join(cmd[3:], " ")})
		cmd = b.gxxCmd(".")
		env = append(env, envVar{"CXX", cmd[0]})
	}

	if buildContext.CgoEnabled {
		env = append(env, envVar{"CGO_ENABLED", "1"})
	} else {
		env = append(env, envVar{"CGO_ENABLED", "0"})
	}

	return env
}

func findEnv(env []envVar, name string) string {
	for _, e := range env {
		if e.name == name {
			return e.value
		}
	}
	return ""
}

func runEnv(cmd *Command, args []string) {
	env := mkEnv()
	if len(args) > 0 {
		for _, name := range args {
			fmt.Printf("%s\n", findEnv(env, name))
		}
		return
	}

	for _, e := range env {
		if e.name != "TERM" {
			switch runtime.GOOS {
			default:
				fmt.Printf("%s=\"%s\"\n", e.name, e.value)
			case "plan9":
				if strings.IndexByte(e.value, '\x00') < 0 {
					fmt.Printf("%s='%s'\n", e.name, strings.Replace(e.value, "'", "''", -1))
				} else {
					v := strings.Split(e.value, "\x00")
					fmt.Printf("%s=(", e.name)
					for x, s := range v {
						if x > 0 {
							fmt.Printf(" ")
						}
						fmt.Printf("%s", s)
					}
					fmt.Printf(")\n")
				}
			case "windows":
				fmt.Printf("set %s=%s\n", e.name, e.value)
			}
		}
	}
}
                                                                                                                                                                                                                                          root/go1.4/src/cmd/go/fix.go                                                                        0100644 0000000 0000000 00000001503 12600426226 014133  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

var cmdFix = &Command{
	Run:       runFix,
	UsageLine: "fix [packages]",
	Short:     "run go tool fix on packages",
	Long: `
Fix runs the Go fix command on the packages named by the import paths.

For more about fix, see 'godoc fix'.
For more about specifying packages, see 'go help packages'.

To run fix with specific options, run 'go tool fix'.

See also: go fmt, go vet.
	`,
}

func runFix(cmd *Command, args []string) {
	for _, pkg := range packages(args) {
		// Use pkg.gofiles instead of pkg.Dir so that
		// the command only applies to this package,
		// not to packages in subdirectories.
		run(stringList(tool("fix"), relPaths(pkg.allgofiles)))
	}
}
                                                                                                                                                                                             root/go1.4/src/cmd/go/fmt.go                                                                        0100644 0000000 0000000 00000002050 12600426226 014131  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

func init() {
	addBuildFlagsNX(cmdFmt)
}

var cmdFmt = &Command{
	Run:       runFmt,
	UsageLine: "fmt [-n] [-x] [packages]",
	Short:     "run gofmt on package sources",
	Long: `
Fmt runs the command 'gofmt -l -w' on the packages named
by the import paths.  It prints the names of the files that are modified.

For more about gofmt, see 'godoc gofmt'.
For more about specifying packages, see 'go help packages'.

The -n flag prints commands that would be executed.
The -x flag prints commands as they are executed.

To run gofmt with specific options, run gofmt itself.

See also: go fix, go vet.
	`,
}

func runFmt(cmd *Command, args []string) {
	for _, pkg := range packages(args) {
		// Use pkg.gofiles instead of pkg.Dir so that
		// the command only applies to this package,
		// not to packages in subdirectories.
		run(stringList("gofmt", "-l", "-w", relPaths(pkg.allgofiles)))
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        root/go1.4/src/cmd/go/generate.go                                                                   0100644 0000000 0000000 00000025370 12600426226 015147  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"
)

var cmdGenerate = &Command{
	Run:       runGenerate,
	UsageLine: "generate [-run regexp] [file.go... | packages]",
	Short:     "generate Go files by processing source",
	Long: `
Generate runs commands described by directives within existing
files. Those commands can run any process but the intent is to
create or update Go source files, for instance by running yacc.

Go generate is never run automatically by go build, go get, go test,
and so on. It must be run explicitly.

Go generate scans the file for directives, which are lines of
the form,

	//go:generate command argument...

(note: no leading spaces and no space in "//go") where command
is the generator to be run, corresponding to an executable file
that can be run locally. It must either be in the shell path
(gofmt), a fully qualified path (/usr/you/bin/mytool), or a
command alias, described below.

Note that go generate does not parse the file, so lines that look
like directives in comments or multiline strings will be treated
as directives.

The arguments to the directive are space-separated tokens or
double-quoted strings passed to the generator as individual
arguments when it is run.

Quoted strings use Go syntax and are evaluated before execution; a
quoted string appears as a single argument to the generator.

Go generate sets several variables when it runs the generator:

	$GOARCH
		The execution architecture (arm, amd64, etc.)
	$GOOS
		The execution operating system (linux, windows, etc.)
	$GOFILE
		The base name of the file.
	$GOPACKAGE
		The name of the package of the file containing the directive.

Other than variable substitution and quoted-string evaluation, no
special processing such as "globbing" is performed on the command
line.

As a last step before running the command, any invocations of any
environment variables with alphanumeric names, such as $GOFILE or
$HOME, are expanded throughout the command line. The syntax for
variable expansion is $NAME on all operating systems.  Due to the
order of evaluation, variables are expanded even inside quoted
strings. If the variable NAME is not set, $NAME expands to the
empty string.

A directive of the form,

	//go:generate -command xxx args...

specifies, for the remainder of this source file only, that the
string xxx represents the command identified by the arguments. This
can be used to create aliases or to handle multiword generators.
For example,

	//go:generate -command yacc go tool yacc

specifies that the command "yacc" represents the generator
"go tool yacc".

Generate processes packages in the order given on the command line,
one at a time. If the command line lists .go files, they are treated
as a single package. Within a package, generate processes the
source files in a package in file name order, one at a time. Within
a source file, generate runs generators in the order they appear
in the file, one at a time.

If any generator returns an error exit status, "go generate" skips
all further processing for that package.

The generator is run in the package's source directory.

Go generate accepts one specific flag:

	-run=""
		TODO: This flag is unimplemented.
		if non-empty, specifies a regular expression to
		select directives whose command matches the expression.

It also accepts the standard build flags -v, -n, and -x.
The -v flag prints the names of packages and files as they are
processed.
The -n flag prints commands that would be executed.
The -x flag prints commands as they are executed.

For more about specifying packages, see 'go help packages'.
	`,
}

var generateRunFlag string // generate -run flag

func init() {
	addBuildFlags(cmdGenerate)
	cmdGenerate.Flag.StringVar(&generateRunFlag, "run", "", "")
}

func runGenerate(cmd *Command, args []string) {
	// Even if the arguments are .go files, this loop suffices.
	for _, pkg := range packages(args) {
		for _, file := range pkg.gofiles {
			if !generate(pkg.Name, file) {
				break
			}
		}
	}
}

// generate runs the generation directives for a single file.
func generate(pkg, absFile string) bool {
	fd, err := os.Open(absFile)
	if err != nil {
		log.Fatalf("generate: %s", err)
	}
	defer fd.Close()
	g := &Generator{
		r:        fd,
		path:     absFile,
		pkg:      pkg,
		commands: make(map[string][]string),
	}
	return g.run()
}

// A Generator represents the state of a single Go source file
// being scanned for generator commands.
type Generator struct {
	r        io.Reader
	path     string // full rooted path name.
	dir      string // full rooted directory of file.
	file     string // base name of file.
	pkg      string
	commands map[string][]string
	lineNum  int
}

// run runs the generators in the current file.
func (g *Generator) run() (ok bool) {
	// Processing below here calls g.errorf on failure, which does panic(stop).
	// If we encounter an error, we abort the package.
	defer func() {
		e := recover()
		if e != nil {
			ok = false
			if e != stop {
				panic(e)
			}
			setExitStatus(1)
		}
	}()
	g.dir, g.file = filepath.Split(g.path)
	g.dir = filepath.Clean(g.dir) // No final separator please.
	if buildV {
		fmt.Fprintf(os.Stderr, "%s\n", shortPath(g.path))
	}

	// Scan for lines that start "//go:generate".
	// Can't use bufio.Scanner because it can't handle long lines,
	// which are likely to appear when using generate.
	input := bufio.NewReader(g.r)
	var err error
	// One line per loop.
	for {
		g.lineNum++ // 1-indexed.
		var buf []byte
		buf, err = input.ReadSlice('\n')
		if err == bufio.ErrBufferFull {
			// Line too long - consume and ignore.
			if isGoGenerate(buf) {
				g.errorf("directive too long")
			}
			for err == bufio.ErrBufferFull {
				_, err = input.ReadSlice('\n')
			}
			if err != nil {
				break
			}
			continue
		}

		if err != nil {
			// Check for marker at EOF without final \n.
			if err == io.EOF && isGoGenerate(buf) {
				err = io.ErrUnexpectedEOF
			}
			break
		}

		if !isGoGenerate(buf) {
			continue
		}

		words := g.split(string(buf))
		if len(words) == 0 {
			g.errorf("no arguments to directive")
		}
		if words[0] == "-command" {
			g.setShorthand(words)
			continue
		}
		// Run the command line.
		if buildN || buildX {
			fmt.Fprintf(os.Stderr, "%s\n", strings.Join(words, " "))
		}
		if buildN {
			continue
		}
		g.exec(words)
	}
	if err != nil && err != io.EOF {
		g.errorf("error reading %s: %s", shortPath(g.path), err)
	}
	return true
}

func isGoGenerate(buf []byte) bool {
	return bytes.HasPrefix(buf, []byte("//go:generate ")) || bytes.HasPrefix(buf, []byte("//go:generate\t"))
}

// split breaks the line into words, evaluating quoted
// strings and evaluating environment variables.
// The initial //go:generate element is present in line.
func (g *Generator) split(line string) []string {
	// Parse line, obeying quoted strings.
	var words []string
	line = line[len("//go:generate ") : len(line)-1] // Drop preamble and final newline.
	// There may still be a carriage return.
	if len(line) > 0 && line[len(line)-1] == '\r' {
		line = line[:len(line)-1]
	}
	// One (possibly quoted) word per iteration.
Words:
	for {
		line = strings.TrimLeft(line, " \t")
		if len(line) == 0 {
			break
		}
		if line[0] == '"' {
			for i := 1; i < len(line); i++ {
				c := line[i] // Only looking for ASCII so this is OK.
				switch c {
				case '\\':
					if i+1 == len(line) {
						g.errorf("bad backslash")
					}
					i++ // Absorb next byte (If it's a multibyte we'll get an error in Unquote).
				case '"':
					word, err := strconv.Unquote(line[0 : i+1])
					if err != nil {
						g.errorf("bad quoted string")
					}
					words = append(words, word)
					line = line[i+1:]
					// Check the next character is space or end of line.
					if len(line) > 0 && line[0] != ' ' && line[0] != '\t' {
						g.errorf("expect space after quoted argument")
					}
					continue Words
				}
			}
			g.errorf("mismatched quoted string")
		}
		i := strings.IndexAny(line, " \t")
		if i < 0 {
			i = len(line)
		}
		words = append(words, line[0:i])
		line = line[i:]
	}
	// Substitute command if required.
	if len(words) > 0 && g.commands[words[0]] != nil {
		// Replace 0th word by command substitution.
		words = append(g.commands[words[0]], words[1:]...)
	}
	// Substitute environment variables.
	for i, word := range words {
		words[i] = g.expandEnv(word)
	}
	return words
}

var stop = fmt.Errorf("error in generation")

// errorf logs an error message prefixed with the file and line number.
// It then exits the program (with exit status 1) because generation stops
// at the first error.
func (g *Generator) errorf(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, "%s:%d: %s\n", shortPath(g.path), g.lineNum,
		fmt.Sprintf(format, args...))
	panic(stop)
}

// expandEnv expands any $XXX invocations in word.
func (g *Generator) expandEnv(word string) string {
	if !strings.ContainsRune(word, '$') {
		return word
	}
	var buf bytes.Buffer
	var w int
	var r rune
	for i := 0; i < len(word); i += w {
		r, w = utf8.DecodeRuneInString(word[i:])
		if r != '$' {
			buf.WriteRune(r)
			continue
		}
		w += g.identLength(word[i+w:])
		envVar := word[i+1 : i+w]
		var sub string
		switch envVar {
		case "GOARCH":
			sub = runtime.GOARCH
		case "GOOS":
			sub = runtime.GOOS
		case "GOFILE":
			sub = g.file
		case "GOPACKAGE":
			sub = g.pkg
		default:
			sub = os.Getenv(envVar)
		}
		buf.WriteString(sub)
	}
	return buf.String()
}

// identLength returns the length of the identifier beginning the string.
func (g *Generator) identLength(word string) int {
	for i, r := range word {
		if r == '_' || unicode.IsLetter(r) || unicode.IsDigit(r) {
			continue
		}
		return i
	}
	return len(word)
}

// setShorthand installs a new shorthand as defined by a -command directive.
func (g *Generator) setShorthand(words []string) {
	// Create command shorthand.
	if len(words) == 1 {
		g.errorf("no command specified for -command")
	}
	command := words[1]
	if g.commands[command] != nil {
		g.errorf("command %q defined multiply defined", command)
	}
	g.commands[command] = words[2:len(words):len(words)] // force later append to make copy
}

// exec runs the command specified by the argument. The first word is
// the command name itself.
func (g *Generator) exec(words []string) {
	cmd := exec.Command(words[0], words[1:]...)
	// Standard in and out of generator should be the usual.
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	// Run the command in the package directory.
	cmd.Dir = g.dir
	env := []string{
		"GOARCH=" + runtime.GOARCH,
		"GOOS=" + runtime.GOOS,
		"GOFILE=" + g.file,
		"GOPACKAGE=" + g.pkg,
	}
	cmd.Env = mergeEnvLists(env, os.Environ())
	err := cmd.Run()
	if err != nil {
		g.errorf("running %q: %s", words[0], err)
	}
}
                                                                                                                                                                                                                                                                        root/go1.4/src/cmd/go/generate_test.go                                                              0100644 0000000 0000000 00000002741 12600426226 016203  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"reflect"
	"runtime"
	"testing"
)

type splitTest struct {
	in  string
	out []string
}

var splitTests = []splitTest{
	{"", nil},
	{"x", []string{"x"}},
	{" a b\tc ", []string{"a", "b", "c"}},
	{` " a " `, []string{" a "}},
	{"$GOARCH", []string{runtime.GOARCH}},
	{"$GOOS", []string{runtime.GOOS}},
	{"$GOFILE", []string{"proc.go"}},
	{"$GOPACKAGE", []string{"sys"}},
	{"a $XXNOTDEFINEDXX b", []string{"a", "", "b"}},
	{"/$XXNOTDEFINED/", []string{"//"}},
	{"yacc -o $GOARCH/yacc_$GOFILE", []string{"go", "tool", "yacc", "-o", runtime.GOARCH + "/yacc_proc.go"}},
}

func TestGenerateCommandParse(t *testing.T) {
	g := &Generator{
		r:        nil, // Unused here.
		path:     "/usr/ken/sys/proc.go",
		dir:      "/usr/ken/sys",
		file:     "proc.go",
		pkg:      "sys",
		commands: make(map[string][]string),
	}
	g.setShorthand([]string{"-command", "yacc", "go", "tool", "yacc"})
	for _, test := range splitTests {
		// First with newlines.
		got := g.split("//go:generate " + test.in + "\n")
		if !reflect.DeepEqual(got, test.out) {
			t.Errorf("split(%q): got %q expected %q", test.in, got, test.out)
		}
		// Then with CRLFs, thank you Windows.
		got = g.split("//go:generate " + test.in + "\r\n")
		if !reflect.DeepEqual(got, test.out) {
			t.Errorf("split(%q): got %q expected %q", test.in, got, test.out)
		}
	}
}
                               root/go1.4/src/cmd/go/get.go                                                                        0100644 0000000 0000000 00000031542 12600426226 014132  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
	"go/build"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"strconv"
	"strings"
)

var cmdGet = &Command{
	UsageLine: "get [-d] [-f] [-fix] [-t] [-u] [build flags] [packages]",
	Short:     "download and install packages and dependencies",
	Long: `
Get downloads and installs the packages named by the import paths,
along with their dependencies.

The -d flag instructs get to stop after downloading the packages; that is,
it instructs get not to install the packages.

The -f flag, valid only when -u is set, forces get -u not to verify that
each package has been checked out from the source control repository
implied by its import path. This can be useful if the source is a local fork
of the original.

The -fix flag instructs get to run the fix tool on the downloaded packages
before resolving dependencies or building the code.

The -t flag instructs get to also download the packages required to build
the tests for the specified packages.

The -u flag instructs get to use the network to update the named packages
and their dependencies.  By default, get uses the network to check out
missing packages but does not use it to look for updates to existing packages.

Get also accepts build flags to control the installation. See 'go help build'.

When checking out or updating a package, get looks for a branch or tag
that matches the locally installed version of Go. The most important
rule is that if the local installation is running version "go1", get
searches for a branch or tag named "go1". If no such version exists it
retrieves the most recent version of the package.

For more about specifying packages, see 'go help packages'.

For more about how 'go get' finds source code to
download, see 'go help importpath'.

See also: go build, go install, go clean.
	`,
}

var getD = cmdGet.Flag.Bool("d", false, "")
var getF = cmdGet.Flag.Bool("f", false, "")
var getT = cmdGet.Flag.Bool("t", false, "")
var getU = cmdGet.Flag.Bool("u", false, "")
var getFix = cmdGet.Flag.Bool("fix", false, "")

func init() {
	addBuildFlags(cmdGet)
	cmdGet.Run = runGet // break init loop
}

func runGet(cmd *Command, args []string) {
	if *getF && !*getU {
		fatalf("go get: cannot use -f flag without -u")
	}

	// Phase 1.  Download/update.
	var stk importStack
	for _, arg := range downloadPaths(args) {
		download(arg, &stk, *getT)
	}
	exitIfErrors()

	// Phase 2. Rescan packages and re-evaluate args list.

	// Code we downloaded and all code that depends on it
	// needs to be evicted from the package cache so that
	// the information will be recomputed.  Instead of keeping
	// track of the reverse dependency information, evict
	// everything.
	for name := range packageCache {
		delete(packageCache, name)
	}

	args = importPaths(args)

	// Phase 3.  Install.
	if *getD {
		// Download only.
		// Check delayed until now so that importPaths
		// has a chance to print errors.
		return
	}

	runInstall(cmd, args)
}

// downloadPaths prepares the list of paths to pass to download.
// It expands ... patterns that can be expanded.  If there is no match
// for a particular pattern, downloadPaths leaves it in the result list,
// in the hope that we can figure out the repository from the
// initial ...-free prefix.
func downloadPaths(args []string) []string {
	args = importPathsNoDotExpansion(args)
	var out []string
	for _, a := range args {
		if strings.Contains(a, "...") {
			var expand []string
			// Use matchPackagesInFS to avoid printing
			// warnings.  They will be printed by the
			// eventual call to importPaths instead.
			if build.IsLocalImport(a) {
				expand = matchPackagesInFS(a)
			} else {
				expand = matchPackages(a)
			}
			if len(expand) > 0 {
				out = append(out, expand...)
				continue
			}
		}
		out = append(out, a)
	}
	return out
}

// downloadCache records the import paths we have already
// considered during the download, to avoid duplicate work when
// there is more than one dependency sequence leading to
// a particular package.
var downloadCache = map[string]bool{}

// downloadRootCache records the version control repository
// root directories we have already considered during the download.
// For example, all the packages in the code.google.com/p/codesearch repo
// share the same root (the directory for that path), and we only need
// to run the hg commands to consider each repository once.
var downloadRootCache = map[string]bool{}

// download runs the download half of the get command
// for the package named by the argument.
func download(arg string, stk *importStack, getTestDeps bool) {
	p := loadPackage(arg, stk)
	if p.Error != nil && p.Error.hard {
		errorf("%s", p.Error)
		return
	}

	// There's nothing to do if this is a package in the standard library.
	if p.Standard {
		return
	}

	// Only process each package once.
	// (Unless we're fetching test dependencies for this package,
	// in which case we want to process it again.)
	if downloadCache[arg] && !getTestDeps {
		return
	}
	downloadCache[arg] = true

	pkgs := []*Package{p}
	wildcardOkay := len(*stk) == 0
	isWildcard := false

	// Download if the package is missing, or update if we're using -u.
	if p.Dir == "" || *getU {
		// The actual download.
		stk.push(p.ImportPath)
		err := downloadPackage(p)
		if err != nil {
			errorf("%s", &PackageError{ImportStack: stk.copy(), Err: err.Error()})
			stk.pop()
			return
		}

		args := []string{arg}
		// If the argument has a wildcard in it, re-evaluate the wildcard.
		// We delay this until after reloadPackage so that the old entry
		// for p has been replaced in the package cache.
		if wildcardOkay && strings.Contains(arg, "...") {
			if build.IsLocalImport(arg) {
				args = matchPackagesInFS(arg)
			} else {
				args = matchPackages(arg)
			}
			isWildcard = true
		}

		// Clear all relevant package cache entries before
		// doing any new loads.
		for _, arg := range args {
			p := packageCache[arg]
			if p != nil {
				delete(packageCache, p.Dir)
				delete(packageCache, p.ImportPath)
			}
		}

		pkgs = pkgs[:0]
		for _, arg := range args {
			stk.push(arg)
			p := loadPackage(arg, stk)
			stk.pop()
			if p.Error != nil {
				errorf("%s", p.Error)
				continue
			}
			pkgs = append(pkgs, p)
		}
	}

	// Process package, which might now be multiple packages
	// due to wildcard expansion.
	for _, p := range pkgs {
		if *getFix {
			run(stringList(tool("fix"), relPaths(p.allgofiles)))

			// The imports might have changed, so reload again.
			p = reloadPackage(arg, stk)
			if p.Error != nil {
				errorf("%s", p.Error)
				return
			}
		}

		if isWildcard {
			// Report both the real package and the
			// wildcard in any error message.
			stk.push(p.ImportPath)
		}

		// Process dependencies, now that we know what they are.
		for _, dep := range p.deps {
			// Don't get test dependencies recursively.
			download(dep.ImportPath, stk, false)
		}
		if getTestDeps {
			// Process test dependencies when -t is specified.
			// (Don't get test dependencies for test dependencies.)
			for _, path := range p.TestImports {
				download(path, stk, false)
			}
			for _, path := range p.XTestImports {
				download(path, stk, false)
			}
		}

		if isWildcard {
			stk.pop()
		}
	}
}

// downloadPackage runs the create or download command
// to make the first copy of or update a copy of the given package.
func downloadPackage(p *Package) error {
	var (
		vcs            *vcsCmd
		repo, rootPath string
		err            error
	)
	if p.build.SrcRoot != "" {
		// Directory exists.  Look for checkout along path to src.
		vcs, rootPath, err = vcsForDir(p)
		if err != nil {
			return err
		}
		repo = "<local>" // should be unused; make distinctive

		// Double-check where it came from.
		if *getU && vcs.remoteRepo != nil && !*getF {
			dir := filepath.Join(p.build.SrcRoot, rootPath)
			if remote, err := vcs.remoteRepo(vcs, dir); err == nil {
				if rr, err := repoRootForImportPath(p.ImportPath); err == nil {
					repo := rr.repo
					if rr.vcs.resolveRepo != nil {
						resolved, err := rr.vcs.resolveRepo(rr.vcs, dir, repo)
						if err == nil {
							repo = resolved
						}
					}
					if remote != repo {
						return fmt.Errorf("%s is a custom import path for %s, but %s is checked out from %s", rr.root, repo, dir, remote)
					}
				}
			}
		}
	} else {
		// Analyze the import path to determine the version control system,
		// repository, and the import path for the root of the repository.
		rr, err := repoRootForImportPath(p.ImportPath)
		if err != nil {
			return err
		}
		vcs, repo, rootPath = rr.vcs, rr.repo, rr.root
	}

	if p.build.SrcRoot == "" {
		// Package not found.  Put in first directory of $GOPATH.
		list := filepath.SplitList(buildContext.GOPATH)
		if len(list) == 0 {
			return fmt.Errorf("cannot download, $GOPATH not set. For more details see: go help gopath")
		}
		// Guard against people setting GOPATH=$GOROOT.
		if list[0] == goroot {
			return fmt.Errorf("cannot download, $GOPATH must not be set to $GOROOT. For more details see: go help gopath")
		}
		p.build.SrcRoot = filepath.Join(list[0], "src")
		p.build.PkgRoot = filepath.Join(list[0], "pkg")
	}
	root := filepath.Join(p.build.SrcRoot, rootPath)
	// If we've considered this repository already, don't do it again.
	if downloadRootCache[root] {
		return nil
	}
	downloadRootCache[root] = true

	if buildV {
		fmt.Fprintf(os.Stderr, "%s (download)\n", rootPath)
	}

	// Check that this is an appropriate place for the repo to be checked out.
	// The target directory must either not exist or have a repo checked out already.
	meta := filepath.Join(root, "."+vcs.cmd)
	st, err := os.Stat(meta)
	if err == nil && !st.IsDir() {
		return fmt.Errorf("%s exists but is not a directory", meta)
	}
	if err != nil {
		// Metadata directory does not exist.  Prepare to checkout new copy.
		// Some version control tools require the target directory not to exist.
		// We require that too, just to avoid stepping on existing work.
		if _, err := os.Stat(root); err == nil {
			return fmt.Errorf("%s exists but %s does not - stale checkout?", root, meta)
		}
		// Some version control tools require the parent of the target to exist.
		parent, _ := filepath.Split(root)
		if err = os.MkdirAll(parent, 0777); err != nil {
			return err
		}
		if err = vcs.create(root, repo); err != nil {
			return err
		}
	} else {
		// Metadata directory does exist; download incremental updates.
		if err = vcs.download(root); err != nil {
			return err
		}
	}

	if buildN {
		// Do not show tag sync in -n; it's noise more than anything,
		// and since we're not running commands, no tag will be found.
		// But avoid printing nothing.
		fmt.Fprintf(os.Stderr, "# cd %s; %s sync/update\n", root, vcs.cmd)
		return nil
	}

	// Select and sync to appropriate version of the repository.
	tags, err := vcs.tags(root)
	if err != nil {
		return err
	}
	vers := runtime.Version()
	if i := strings.Index(vers, " "); i >= 0 {
		vers = vers[:i]
	}
	if err := vcs.tagSync(root, selectTag(vers, tags)); err != nil {
		return err
	}

	return nil
}

// goTag matches go release tags such as go1 and go1.2.3.
// The numbers involved must be small (at most 4 digits),
// have no unnecessary leading zeros, and the version cannot
// end in .0 - it is go1, not go1.0 or go1.0.0.
var goTag = regexp.MustCompile(
	`^go((0|[1-9][0-9]{0,3})\.)*([1-9][0-9]{0,3})$`,
)

// selectTag returns the closest matching tag for a given version.
// Closest means the latest one that is not after the current release.
// Version "goX" (or "goX.Y" or "goX.Y.Z") matches tags of the same form.
// Version "release.rN" matches tags of the form "go.rN" (N being a floating-point number).
// Version "weekly.YYYY-MM-DD" matches tags like "go.weekly.YYYY-MM-DD".
//
// NOTE(rsc): Eventually we will need to decide on some logic here.
// For now, there is only "go1".  This matches the docs in go help get.
func selectTag(goVersion string, tags []string) (match string) {
	for _, t := range tags {
		if t == "go1" {
			return "go1"
		}
	}
	return ""

	/*
		if goTag.MatchString(goVersion) {
			v := goVersion
			for _, t := range tags {
				if !goTag.MatchString(t) {
					continue
				}
				if cmpGoVersion(match, t) < 0 && cmpGoVersion(t, v) <= 0 {
					match = t
				}
			}
		}

		return match
	*/
}

// cmpGoVersion returns -1, 0, +1 reporting whether
// x < y, x == y, or x > y.
func cmpGoVersion(x, y string) int {
	// Malformed strings compare less than well-formed strings.
	if !goTag.MatchString(x) {
		return -1
	}
	if !goTag.MatchString(y) {
		return +1
	}

	// Compare numbers in sequence.
	xx := strings.Split(x[len("go"):], ".")
	yy := strings.Split(y[len("go"):], ".")

	for i := 0; i < len(xx) && i < len(yy); i++ {
		// The Atoi are guaranteed to succeed
		// because the versions match goTag.
		xi, _ := strconv.Atoi(xx[i])
		yi, _ := strconv.Atoi(yy[i])
		if xi < yi {
			return -1
		} else if xi > yi {
			return +1
		}
	}

	if len(xx) < len(yy) {
		return -1
	}
	if len(xx) > len(yy) {
		return +1
	}
	return 0
}
                                                                                                                                                              root/go1.4/src/cmd/go/go11.go                                                                       0100644 0000000 0000000 00000000454 12600426226 014120  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build go1.1

package main

// Test that go1.1 tag above is included in builds. main.go refers to this definition.
const go11tag = true
                                                                                                                                                                                                                    root/go1.4/src/cmd/go/go_windows_test.go                                                            0100644 0000000 0000000 00000002202 12600426226 016560  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
)

func TestAbsolutePath(t *testing.T) {
	tmp, err := ioutil.TempDir("", "TestAbsolutePath")
	if err != nil {
		t.Fatal(err)
	}
	defer os.RemoveAll(tmp)

	file := filepath.Join(tmp, "a.go")
	err = ioutil.WriteFile(file, []byte{}, 0644)
	if err != nil {
		t.Fatal(err)
	}
	dir := filepath.Join(tmp, "dir")
	err = os.Mkdir(dir, 0777)
	if err != nil {
		t.Fatal(err)
	}

	wd, err := os.Getwd()
	if err != nil {
		t.Fatal(err)
	}
	defer os.Chdir(wd)

	// Chdir so current directory and a.go reside on the same drive.
	err = os.Chdir(dir)
	if err != nil {
		t.Fatal(err)
	}

	noVolume := file[len(filepath.VolumeName(file)):]
	wrongPath := filepath.Join(dir, noVolume)
	output, err := exec.Command("go", "build", noVolume).CombinedOutput()
	if err == nil {
		t.Fatal("build should fail")
	}
	if strings.Contains(string(output), wrongPath) {
		t.Fatalf("wrong output found: %v %v", err, string(output))
	}
}
                                                                                                                                                                                                                                                                                                                                                                                              root/go1.4/src/cmd/go/help.go                                                                       0100644 0000000 0000000 00000030556 12600426226 014307  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

var helpC = &Command{
	UsageLine: "c",
	Short:     "calling between Go and C",
	Long: `
There are two different ways to call between Go and C/C++ code.

The first is the cgo tool, which is part of the Go distribution.  For
information on how to use it see the cgo documentation (godoc cmd/cgo).

The second is the SWIG program, which is a general tool for
interfacing between languages.  For information on SWIG see
http://swig.org/.  When running go build, any file with a .swig
extension will be passed to SWIG.  Any file with a .swigcxx extension
will be passed to SWIG with the -c++ option.

When either cgo or SWIG is used, go build will pass any .c, .m, .s,
or .S files to the C compiler, and any .cc, .cpp, .cxx files to the C++
compiler.  The CC or CXX environment variables may be set to determine
the C or C++ compiler, respectively, to use.
	`,
}

var helpPackages = &Command{
	UsageLine: "packages",
	Short:     "description of package lists",
	Long: `
Many commands apply to a set of packages:

	go action [packages]

Usually, [packages] is a list of import paths.

An import path that is a rooted path or that begins with
a . or .. element is interpreted as a file system path and
denotes the package in that directory.

Otherwise, the import path P denotes the package found in
the directory DIR/src/P for some DIR listed in the GOPATH
environment variable (see 'go help gopath').

If no import paths are given, the action applies to the
package in the current directory.

There are three reserved names for paths that should not be used
for packages to be built with the go tool:

- "main" denotes the top-level package in a stand-alone executable.

- "all" expands to all package directories found in all the GOPATH
trees. For example, 'go list all' lists all the packages on the local
system.

- "std" is like all but expands to just the packages in the standard
Go library.

An import path is a pattern if it includes one or more "..." wildcards,
each of which can match any string, including the empty string and
strings containing slashes.  Such a pattern expands to all package
directories found in the GOPATH trees with names matching the
patterns.  As a special case, x/... matches x as well as x's subdirectories.
For example, net/... expands to net and packages in its subdirectories.

An import path can also name a package to be downloaded from
a remote repository.  Run 'go help importpath' for details.

Every package in a program must have a unique import path.
By convention, this is arranged by starting each path with a
unique prefix that belongs to you.  For example, paths used
internally at Google all begin with 'google', and paths
denoting remote repositories begin with the path to the code,
such as 'code.google.com/p/project'.

As a special case, if the package list is a list of .go files from a
single directory, the command is applied to a single synthesized
package made up of exactly those files, ignoring any build constraints
in those files and ignoring any other files in the directory.

Directory and file names that begin with "." or "_" are ignored
by the go tool, as are directories named "testdata".
	`,
}

var helpImportPath = &Command{
	UsageLine: "importpath",
	Short:     "import path syntax",
	Long: `

An import path (see 'go help packages') denotes a package
stored in the local file system.  In general, an import path denotes
either a standard package (such as "unicode/utf8") or a package
found in one of the work spaces (see 'go help gopath').

Relative import paths

An import path beginning with ./ or ../ is called a relative path.
The toolchain supports relative import paths as a shortcut in two ways.

First, a relative path can be used as a shorthand on the command line.
If you are working in the directory containing the code imported as
"unicode" and want to run the tests for "unicode/utf8", you can type
"go test ./utf8" instead of needing to specify the full path.
Similarly, in the reverse situation, "go test .." will test "unicode" from
the "unicode/utf8" directory. Relative patterns are also allowed, like
"go test ./..." to test all subdirectories. See 'go help packages' for details
on the pattern syntax.

Second, if you are compiling a Go program not in a work space,
you can use a relative path in an import statement in that program
to refer to nearby code also not in a work space.
This makes it easy to experiment with small multipackage programs
outside of the usual work spaces, but such programs cannot be
installed with "go install" (there is no work space in which to install them),
so they are rebuilt from scratch each time they are built.
To avoid ambiguity, Go programs cannot use relative import paths
within a work space.

Remote import paths

Certain import paths also
describe how to obtain the source code for the package using
a revision control system.

A few common code hosting sites have special syntax:

	Bitbucket (Git, Mercurial)

		import "bitbucket.org/user/project"
		import "bitbucket.org/user/project/sub/directory"

	GitHub (Git)

		import "github.com/user/project"
		import "github.com/user/project/sub/directory"

	Google Code Project Hosting (Git, Mercurial, Subversion)

		import "code.google.com/p/project"
		import "code.google.com/p/project/sub/directory"

		import "code.google.com/p/project.subrepository"
		import "code.google.com/p/project.subrepository/sub/directory"

	Launchpad (Bazaar)

		import "launchpad.net/project"
		import "launchpad.net/project/series"
		import "launchpad.net/project/series/sub/directory"

		import "launchpad.net/~user/project/branch"
		import "launchpad.net/~user/project/branch/sub/directory"

	IBM DevOps Services (Git)

		import "hub.jazz.net/git/user/project"
		import "hub.jazz.net/git/user/project/sub/directory"

For code hosted on other servers, import paths may either be qualified
with the version control type, or the go tool can dynamically fetch
the import path over https/http and discover where the code resides
from a <meta> tag in the HTML.

To declare the code location, an import path of the form

	repository.vcs/path

specifies the given repository, with or without the .vcs suffix,
using the named version control system, and then the path inside
that repository.  The supported version control systems are:

	Bazaar      .bzr
	Git         .git
	Mercurial   .hg
	Subversion  .svn

For example,

	import "example.org/user/foo.hg"

denotes the root directory of the Mercurial repository at
example.org/user/foo or foo.hg, and

	import "example.org/repo.git/foo/bar"

denotes the foo/bar directory of the Git repository at
example.org/repo or repo.git.

When a version control system supports multiple protocols,
each is tried in turn when downloading.  For example, a Git
download tries git://, then https://, then http://.

If the import path is not a known code hosting site and also lacks a
version control qualifier, the go tool attempts to fetch the import
over https/http and looks for a <meta> tag in the document's HTML
<head>.

The meta tag has the form:

	<meta name="go-import" content="import-prefix vcs repo-root">

The import-prefix is the import path corresponding to the repository
root. It must be a prefix or an exact match of the package being
fetched with "go get". If it's not an exact match, another http
request is made at the prefix to verify the <meta> tags match.

The vcs is one of "git", "hg", "svn", etc,

The repo-root is the root of the version control system
containing a scheme and not containing a .vcs qualifier.

For example,

	import "example.org/pkg/foo"

will result in the following request(s):

	https://example.org/pkg/foo?go-get=1 (preferred)
	http://example.org/pkg/foo?go-get=1  (fallback)

If that page contains the meta tag

	<meta name="go-import" content="example.org git https://code.org/r/p/exproj">

the go tool will verify that https://example.org/?go-get=1 contains the
same meta tag and then git clone https://code.org/r/p/exproj into
GOPATH/src/example.org.

New downloaded packages are written to the first directory
listed in the GOPATH environment variable (see 'go help gopath').

The go command attempts to download the version of the
package appropriate for the Go release being used.
Run 'go help get' for more.

Import path checking

When the custom import path feature described above redirects to a
known code hosting site, each of the resulting packages has two possible
import paths, using the custom domain or the known hosting site.

A package statement is said to have an "import comment" if it is immediately
followed (before the next newline) by a comment of one of these two forms:

	package math // import "path"
	package math /* import "path" */

The go command will refuse to install a package with an import comment
unless it is being referred to by that import path. In this way, import comments
let package authors make sure the custom import path is used and not a
direct path to the underlying code hosting site.

See https://golang.org/s/go14customimport for details.
	`,
}

var helpGopath = &Command{
	UsageLine: "gopath",
	Short:     "GOPATH environment variable",
	Long: `
The Go path is used to resolve import statements.
It is implemented by and documented in the go/build package.

The GOPATH environment variable lists places to look for Go code.
On Unix, the value is a colon-separated string.
On Windows, the value is a semicolon-separated string.
On Plan 9, the value is a list.

GOPATH must be set to get, build and install packages outside the
standard Go tree.

Each directory listed in GOPATH must have a prescribed structure:

The src/ directory holds source code.  The path below 'src'
determines the import path or executable name.

The pkg/ directory holds installed package objects.
As in the Go tree, each target operating system and
architecture pair has its own subdirectory of pkg
(pkg/GOOS_GOARCH).

If DIR is a directory listed in the GOPATH, a package with
source in DIR/src/foo/bar can be imported as "foo/bar" and
has its compiled form installed to "DIR/pkg/GOOS_GOARCH/foo/bar.a".

The bin/ directory holds compiled commands.
Each command is named for its source directory, but only
the final element, not the entire path.  That is, the
command with source in DIR/src/foo/quux is installed into
DIR/bin/quux, not DIR/bin/foo/quux.  The foo/ is stripped
so that you can add DIR/bin to your PATH to get at the
installed commands.  If the GOBIN environment variable is
set, commands are installed to the directory it names instead
of DIR/bin.

Here's an example directory layout:

    GOPATH=/home/user/gocode

    /home/user/gocode/
        src/
            foo/
                bar/               (go code in package bar)
                    x.go
                quux/              (go code in package main)
                    y.go
        bin/
            quux                   (installed command)
        pkg/
            linux_amd64/
                foo/
                    bar.a          (installed package object)

Go searches each directory listed in GOPATH to find source code,
but new packages are always downloaded into the first directory
in the list.
	`,
}

var helpFileType = &Command{
	UsageLine: "filetype",
	Short:     "file types",
	Long: `
The go command examines the contents of a restricted set of files
in each directory. It identifies which files to examine based on
the extension of the file name. These extensions are:

	.go
		Go source files.
	.c, .h
		C source files.
		If the package uses cgo, these will be compiled with the
		OS-native compiler (typically gcc); otherwise they will be
		compiled with the Go-specific support compiler,
		5c, 6c, or 8c, etc. as appropriate.
	.cc, .cpp, .cxx, .hh, .hpp, .hxx
		C++ source files. Only useful with cgo or SWIG, and always
		compiled with the OS-native compiler.
	.m
		Objective-C source files. Only useful with cgo, and always
		compiled with the OS-native compiler.
	.s, .S
		Assembler source files.
		If the package uses cgo, these will be assembled with the
		OS-native assembler (typically gcc (sic)); otherwise they
		will be assembled with the Go-specific support assembler,
		5a, 6a, or 8a, etc., as appropriate.
	.swig, .swigcxx
		SWIG definition files.
	.syso
		System object files.

Files of each of these types except .syso may contain build
constraints, but the go command stops scanning for build constraints
at the first item in the file that is not a blank line or //-style
line comment.
	`,
}
                                                                                                                                                  root/go1.4/src/cmd/go/http.go                                                                       0100644 0000000 0000000 00000004344 12600426226 014332  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2012 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !cmd_go_bootstrap

// This code is compiled into the real 'go' binary, but it is not
// compiled into the binary that is built during all.bash, so as
// to avoid needing to build net (and thus use cgo) during the
// bootstrap process.

package main

import (
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
)

// httpClient is the default HTTP client, but a variable so it can be
// changed by tests, without modifying http.DefaultClient.
var httpClient = http.DefaultClient

// httpGET returns the data from an HTTP GET request for the given URL.
func httpGET(url string) ([]byte, error) {
	resp, err := httpClient.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("%s: %s", url, resp.Status)
	}
	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("%s: %v", url, err)
	}
	return b, nil
}

// httpsOrHTTP returns the body of either the importPath's
// https resource or, if unavailable, the http resource.
func httpsOrHTTP(importPath string) (urlStr string, body io.ReadCloser, err error) {
	fetch := func(scheme string) (urlStr string, res *http.Response, err error) {
		u, err := url.Parse(scheme + "://" + importPath)
		if err != nil {
			return "", nil, err
		}
		u.RawQuery = "go-get=1"
		urlStr = u.String()
		if buildV {
			log.Printf("Fetching %s", urlStr)
		}
		res, err = httpClient.Get(urlStr)
		return
	}
	closeBody := func(res *http.Response) {
		if res != nil {
			res.Body.Close()
		}
	}
	urlStr, res, err := fetch("https")
	if err != nil || res.StatusCode != 200 {
		if buildV {
			if err != nil {
				log.Printf("https fetch failed.")
			} else {
				log.Printf("ignoring https fetch with status code %d", res.StatusCode)
			}
		}
		closeBody(res)
		urlStr, res, err = fetch("http")
	}
	if err != nil {
		closeBody(res)
		return "", nil, err
	}
	// Note: accepting a non-200 OK here, so people can serve a
	// meta import in their http 404 page.
	if buildV {
		log.Printf("Parsing meta tags from %s (status code %d)", urlStr, res.StatusCode)
	}
	return urlStr, res.Body, nil
}
                                                                                                                                                                                                                                                                                            root/go1.4/src/cmd/go/list.go                                                                       0100644 0000000 0000000 00000014770 12600426226 014332  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bufio"
	"encoding/json"
	"io"
	"os"
	"strings"
	"text/template"
)

var cmdList = &Command{
	UsageLine: "list [-e] [-f format] [-json] [build flags] [packages]",
	Short:     "list packages",
	Long: `
List lists the packages named by the import paths, one per line.

The default output shows the package import path:

    code.google.com/p/google-api-go-client/books/v1
    code.google.com/p/goauth2/oauth
    code.google.com/p/sqlite

The -f flag specifies an alternate format for the list, using the
syntax of package template.  The default output is equivalent to -f
'{{.ImportPath}}'. The struct being passed to the template is:

    type Package struct {
        Dir           string // directory containing package sources
        ImportPath    string // import path of package in dir
        ImportComment string // path in import comment on package statement
        Name          string // package name
        Doc           string // package documentation string
        Target        string // install path
        Goroot        bool   // is this package in the Go root?
        Standard      bool   // is this package part of the standard Go library?
        Stale         bool   // would 'go install' do anything for this package?
        Root          string // Go root or Go path dir containing this package

        // Source files
        GoFiles        []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)
        CgoFiles       []string // .go sources files that import "C"
        IgnoredGoFiles []string // .go sources ignored due to build constraints
        CFiles         []string // .c source files
        CXXFiles       []string // .cc, .cxx and .cpp source files
        MFiles         []string // .m source files
        HFiles         []string // .h, .hh, .hpp and .hxx source files
        SFiles         []string // .s source files
        SwigFiles      []string // .swig files
        SwigCXXFiles   []string // .swigcxx files
        SysoFiles      []string // .syso object files to add to archive

        // Cgo directives
        CgoCFLAGS    []string // cgo: flags for C compiler
        CgoCPPFLAGS  []string // cgo: flags for C preprocessor
        CgoCXXFLAGS  []string // cgo: flags for C++ compiler
        CgoLDFLAGS   []string // cgo: flags for linker
        CgoPkgConfig []string // cgo: pkg-config names

        // Dependency information
        Imports []string // import paths used by this package
        Deps    []string // all (recursively) imported dependencies

        // Error information
        Incomplete bool            // this package or a dependency has an error
        Error      *PackageError   // error loading package
        DepsErrors []*PackageError // errors loading dependencies

        TestGoFiles  []string // _test.go files in package
        TestImports  []string // imports from TestGoFiles
        XTestGoFiles []string // _test.go files outside package
        XTestImports []string // imports from XTestGoFiles
    }

The template function "join" calls strings.Join.

The template function "context" returns the build context, defined as:

	type Context struct {
		GOARCH        string   // target architecture
		GOOS          string   // target operating system
		GOROOT        string   // Go root
		GOPATH        string   // Go path
		CgoEnabled    bool     // whether cgo can be used
		UseAllFiles   bool     // use files regardless of +build lines, file names
		Compiler      string   // compiler to assume when computing target paths
		BuildTags     []string // build constraints to match in +build lines
		ReleaseTags   []string // releases the current release is compatible with
		InstallSuffix string   // suffix to use in the name of the install dir
	}

For more information about the meaning of these fields see the documentation
for the go/build package's Context type.

The -json flag causes the package data to be printed in JSON format
instead of using the template format.

The -e flag changes the handling of erroneous packages, those that
cannot be found or are malformed.  By default, the list command
prints an error to standard error for each erroneous package and
omits the packages from consideration during the usual printing.
With the -e flag, the list command never prints errors to standard
error and instead processes the erroneous packages with the usual
printing.  Erroneous packages will have a non-empty ImportPath and
a non-nil Error field; other information may or may not be missing
(zeroed).

For more about build flags, see 'go help build'.

For more about specifying packages, see 'go help packages'.
	`,
}

func init() {
	cmdList.Run = runList // break init cycle
	addBuildFlags(cmdList)
}

var listE = cmdList.Flag.Bool("e", false, "")
var listFmt = cmdList.Flag.String("f", "{{.ImportPath}}", "")
var listJson = cmdList.Flag.Bool("json", false, "")
var nl = []byte{'\n'}

func runList(cmd *Command, args []string) {
	out := newTrackingWriter(os.Stdout)
	defer out.w.Flush()

	var do func(*Package)
	if *listJson {
		do = func(p *Package) {
			b, err := json.MarshalIndent(p, "", "\t")
			if err != nil {
				out.Flush()
				fatalf("%s", err)
			}
			out.Write(b)
			out.Write(nl)
		}
	} else {
		var cachedCtxt *Context
		context := func() *Context {
			if cachedCtxt == nil {
				cachedCtxt = newContext(&buildContext)
			}
			return cachedCtxt
		}
		fm := template.FuncMap{
			"join":    strings.Join,
			"context": context,
		}
		tmpl, err := template.New("main").Funcs(fm).Parse(*listFmt)
		if err != nil {
			fatalf("%s", err)
		}
		do = func(p *Package) {
			if err := tmpl.Execute(out, p); err != nil {
				out.Flush()
				fatalf("%s", err)
			}
			if out.NeedNL() {
				out.Write(nl)
			}
		}
	}

	load := packages
	if *listE {
		load = packagesAndErrors
	}

	for _, pkg := range load(args) {
		do(pkg)
	}
}

// TrackingWriter tracks the last byte written on every write so
// we can avoid printing a newline if one was already written or
// if there is no output at all.
type TrackingWriter struct {
	w    *bufio.Writer
	last byte
}

func newTrackingWriter(w io.Writer) *TrackingWriter {
	return &TrackingWriter{
		w:    bufio.NewWriter(w),
		last: '\n',
	}
}

func (t *TrackingWriter) Write(p []byte) (n int, err error) {
	n, err = t.w.Write(p)
	if n > 0 {
		t.last = p[n-1]
	}
	return
}

func (t *TrackingWriter) Flush() {
	t.w.Flush()
}

func (t *TrackingWriter) NeedNL() bool {
	return t.last != '\n'
}
        root/go1.4/src/cmd/go/main.go                                                                       0100644 0000000 0000000 00000042635 12600426226 014304  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/build"
	"io"
	"log"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"sync"
	"text/template"
	"unicode"
	"unicode/utf8"
)

// A Command is an implementation of a go command
// like go build or go fix.
type Command struct {
	// Run runs the command.
	// The args are the arguments after the command name.
	Run func(cmd *Command, args []string)

	// UsageLine is the one-line usage message.
	// The first word in the line is taken to be the command name.
	UsageLine string

	// Short is the short description shown in the 'go help' output.
	Short string

	// Long is the long message shown in the 'go help <this-command>' output.
	Long string

	// Flag is a set of flags specific to this command.
	Flag flag.FlagSet

	// CustomFlags indicates that the command will do its own
	// flag parsing.
	CustomFlags bool
}

// Name returns the command's name: the first word in the usage line.
func (c *Command) Name() string {
	name := c.UsageLine
	i := strings.Index(name, " ")
	if i >= 0 {
		name = name[:i]
	}
	return name
}

func (c *Command) Usage() {
	fmt.Fprintf(os.Stderr, "usage: %s\n\n", c.UsageLine)
	fmt.Fprintf(os.Stderr, "%s\n", strings.TrimSpace(c.Long))
	os.Exit(2)
}

// Runnable reports whether the command can be run; otherwise
// it is a documentation pseudo-command such as importpath.
func (c *Command) Runnable() bool {
	return c.Run != nil
}

// Commands lists the available commands and help topics.
// The order here is the order in which they are printed by 'go help'.
var commands = []*Command{
	cmdBuild,
	cmdClean,
	cmdEnv,
	cmdFix,
	cmdFmt,
	cmdGenerate,
	cmdGet,
	cmdInstall,
	cmdList,
	cmdRun,
	cmdTest,
	cmdTool,
	cmdVersion,
	cmdVet,

	helpC,
	helpFileType,
	helpGopath,
	helpImportPath,
	helpPackages,
	helpTestflag,
	helpTestfunc,
}

var exitStatus = 0
var exitMu sync.Mutex

func setExitStatus(n int) {
	exitMu.Lock()
	if exitStatus < n {
		exitStatus = n
	}
	exitMu.Unlock()
}

func main() {
	_ = go11tag
	flag.Usage = usage
	flag.Parse()
	log.SetFlags(0)

	args := flag.Args()
	if len(args) < 1 {
		usage()
	}

	if args[0] == "help" {
		help(args[1:])
		return
	}

	// Diagnose common mistake: GOPATH==GOROOT.
	// This setting is equivalent to not setting GOPATH at all,
	// which is not what most people want when they do it.
	if gopath := os.Getenv("GOPATH"); gopath == runtime.GOROOT() {
		fmt.Fprintf(os.Stderr, "warning: GOPATH set to GOROOT (%s) has no effect\n", gopath)
	} else {
		for _, p := range filepath.SplitList(gopath) {
			// Note: using HasPrefix instead of Contains because a ~ can appear
			// in the middle of directory elements, such as /tmp/git-1.8.2~rc3
			// or C:\PROGRA~1. Only ~ as a path prefix has meaning to the shell.
			if strings.HasPrefix(p, "~") {
				fmt.Fprintf(os.Stderr, "go: GOPATH entry cannot start with shell metacharacter '~': %q\n", p)
				os.Exit(2)
			}
			if build.IsLocalImport(p) {
				fmt.Fprintf(os.Stderr, "go: GOPATH entry is relative; must be absolute path: %q.\nRun 'go help gopath' for usage.\n", p)
				os.Exit(2)
			}
		}
	}

	if fi, err := os.Stat(goroot); err != nil || !fi.IsDir() {
		fmt.Fprintf(os.Stderr, "go: cannot find GOROOT directory: %v\n", goroot)
		os.Exit(2)
	}

	for _, cmd := range commands {
		if cmd.Name() == args[0] && cmd.Run != nil {
			cmd.Flag.Usage = func() { cmd.Usage() }
			if cmd.CustomFlags {
				args = args[1:]
			} else {
				cmd.Flag.Parse(args[1:])
				args = cmd.Flag.Args()
			}
			cmd.Run(cmd, args)
			exit()
			return
		}
	}

	fmt.Fprintf(os.Stderr, "go: unknown subcommand %q\nRun 'go help' for usage.\n", args[0])
	setExitStatus(2)
	exit()
}

var usageTemplate = `Go is a tool for managing Go source code.

Usage:

	go command [arguments]

The commands are:
{{range .}}{{if .Runnable}}
    {{.Name | printf "%-11s"}} {{.Short}}{{end}}{{end}}

Use "go help [command]" for more information about a command.

Additional help topics:
{{range .}}{{if not .Runnable}}
    {{.Name | printf "%-11s"}} {{.Short}}{{end}}{{end}}

Use "go help [topic]" for more information about that topic.

`

var helpTemplate = `{{if .Runnable}}usage: go {{.UsageLine}}

{{end}}{{.Long | trim}}
`

var documentationTemplate = `// Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// DO NOT EDIT THIS FILE. GENERATED BY mkdoc.sh.
// Edit the documentation in other files and rerun mkdoc.sh to generate this one.

/*
{{range .}}{{if .Short}}{{.Short | capitalize}}

{{end}}{{if .Runnable}}Usage:

	go {{.UsageLine}}

{{end}}{{.Long | trim}}


{{end}}*/
package main
`

// tmpl executes the given template text on data, writing the result to w.
func tmpl(w io.Writer, text string, data interface{}) {
	t := template.New("top")
	t.Funcs(template.FuncMap{"trim": strings.TrimSpace, "capitalize": capitalize})
	template.Must(t.Parse(text))
	if err := t.Execute(w, data); err != nil {
		panic(err)
	}
}

func capitalize(s string) string {
	if s == "" {
		return s
	}
	r, n := utf8.DecodeRuneInString(s)
	return string(unicode.ToTitle(r)) + s[n:]
}

func printUsage(w io.Writer) {
	tmpl(w, usageTemplate, commands)
}

func usage() {
	// special case "go test -h"
	if len(os.Args) > 1 && os.Args[1] == "test" {
		help([]string{"testflag"})
		os.Exit(2)
	}
	printUsage(os.Stderr)
	os.Exit(2)
}

// help implements the 'help' command.
func help(args []string) {
	if len(args) == 0 {
		printUsage(os.Stdout)
		// not exit 2: succeeded at 'go help'.
		return
	}
	if len(args) != 1 {
		fmt.Fprintf(os.Stderr, "usage: go help command\n\nToo many arguments given.\n")
		os.Exit(2) // failed at 'go help'
	}

	arg := args[0]

	// 'go help documentation' generates doc.go.
	if arg == "documentation" {
		buf := new(bytes.Buffer)
		printUsage(buf)
		usage := &Command{Long: buf.String()}
		tmpl(os.Stdout, documentationTemplate, append([]*Command{usage}, commands...))
		return
	}

	for _, cmd := range commands {
		if cmd.Name() == arg {
			tmpl(os.Stdout, helpTemplate, cmd)
			// not exit 2: succeeded at 'go help cmd'.
			return
		}
	}

	fmt.Fprintf(os.Stderr, "Unknown help topic %#q.  Run 'go help'.\n", arg)
	os.Exit(2) // failed at 'go help cmd'
}

// importPathsNoDotExpansion returns the import paths to use for the given
// command line, but it does no ... expansion.
func importPathsNoDotExpansion(args []string) []string {
	if len(args) == 0 {
		return []string{"."}
	}
	var out []string
	for _, a := range args {
		// Arguments are supposed to be import paths, but
		// as a courtesy to Windows developers, rewrite \ to /
		// in command-line arguments.  Handles .\... and so on.
		if filepath.Separator == '\\' {
			a = strings.Replace(a, `\`, `/`, -1)
		}

		// Put argument in canonical form, but preserve leading ./.
		if strings.HasPrefix(a, "./") {
			a = "./" + path.Clean(a)
			if a == "./." {
				a = "."
			}
		} else {
			a = path.Clean(a)
		}
		if a == "all" || a == "std" {
			out = append(out, allPackages(a)...)
			continue
		}
		out = append(out, a)
	}
	return out
}

// importPaths returns the import paths to use for the given command line.
func importPaths(args []string) []string {
	args = importPathsNoDotExpansion(args)
	var out []string
	for _, a := range args {
		if strings.Contains(a, "...") {
			if build.IsLocalImport(a) {
				out = append(out, allPackagesInFS(a)...)
			} else {
				out = append(out, allPackages(a)...)
			}
			continue
		}
		out = append(out, a)
	}
	return out
}

var atexitFuncs []func()

func atexit(f func()) {
	atexitFuncs = append(atexitFuncs, f)
}

func exit() {
	for _, f := range atexitFuncs {
		f()
	}
	os.Exit(exitStatus)
}

func fatalf(format string, args ...interface{}) {
	errorf(format, args...)
	exit()
}

func errorf(format string, args ...interface{}) {
	log.Printf(format, args...)
	setExitStatus(1)
}

var logf = log.Printf

func exitIfErrors() {
	if exitStatus != 0 {
		exit()
	}
}

func run(cmdargs ...interface{}) {
	cmdline := stringList(cmdargs...)
	if buildN || buildX {
		fmt.Printf("%s\n", strings.Join(cmdline, " "))
		if buildN {
			return
		}
	}

	cmd := exec.Command(cmdline[0], cmdline[1:]...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		errorf("%v", err)
	}
}

func runOut(dir string, cmdargs ...interface{}) []byte {
	cmdline := stringList(cmdargs...)
	cmd := exec.Command(cmdline[0], cmdline[1:]...)
	cmd.Dir = dir
	out, err := cmd.CombinedOutput()
	if err != nil {
		os.Stderr.Write(out)
		errorf("%v", err)
		out = nil
	}
	return out
}

// envForDir returns a copy of the environment
// suitable for running in the given directory.
// The environment is the current process's environment
// but with an updated $PWD, so that an os.Getwd in the
// child will be faster.
func envForDir(dir string) []string {
	env := os.Environ()
	// Internally we only use rooted paths, so dir is rooted.
	// Even if dir is not rooted, no harm done.
	return mergeEnvLists([]string{"PWD=" + dir}, env)
}

// mergeEnvLists merges the two environment lists such that
// variables with the same name in "in" replace those in "out".
func mergeEnvLists(in, out []string) []string {
NextVar:
	for _, inkv := range in {
		k := strings.SplitAfterN(inkv, "=", 2)[0]
		for i, outkv := range out {
			if strings.HasPrefix(outkv, k) {
				out[i] = inkv
				continue NextVar
			}
		}
		out = append(out, inkv)
	}
	return out
}

// matchPattern(pattern)(name) reports whether
// name matches pattern.  Pattern is a limited glob
// pattern in which '...' means 'any string' and there
// is no other special syntax.
func matchPattern(pattern string) func(name string) bool {
	re := regexp.QuoteMeta(pattern)
	re = strings.Replace(re, `\.\.\.`, `.*`, -1)
	// Special case: foo/... matches foo too.
	if strings.HasSuffix(re, `/.*`) {
		re = re[:len(re)-len(`/.*`)] + `(/.*)?`
	}
	reg := regexp.MustCompile(`^` + re + `$`)
	return func(name string) bool {
		return reg.MatchString(name)
	}
}

// hasPathPrefix reports whether the path s begins with the
// elements in prefix.
func hasPathPrefix(s, prefix string) bool {
	switch {
	default:
		return false
	case len(s) == len(prefix):
		return s == prefix
	case len(s) > len(prefix):
		if prefix != "" && prefix[len(prefix)-1] == '/' {
			return strings.HasPrefix(s, prefix)
		}
		return s[len(prefix)] == '/' && s[:len(prefix)] == prefix
	}
}

// treeCanMatchPattern(pattern)(name) reports whether
// name or children of name can possibly match pattern.
// Pattern is the same limited glob accepted by matchPattern.
func treeCanMatchPattern(pattern string) func(name string) bool {
	wildCard := false
	if i := strings.Index(pattern, "..."); i >= 0 {
		wildCard = true
		pattern = pattern[:i]
	}
	return func(name string) bool {
		return len(name) <= len(pattern) && hasPathPrefix(pattern, name) ||
			wildCard && strings.HasPrefix(name, pattern)
	}
}

// allPackages returns all the packages that can be found
// under the $GOPATH directories and $GOROOT matching pattern.
// The pattern is either "all" (all packages), "std" (standard packages)
// or a path including "...".
func allPackages(pattern string) []string {
	pkgs := matchPackages(pattern)
	if len(pkgs) == 0 {
		fmt.Fprintf(os.Stderr, "warning: %q matched no packages\n", pattern)
	}
	return pkgs
}

func matchPackages(pattern string) []string {
	match := func(string) bool { return true }
	treeCanMatch := func(string) bool { return true }
	if pattern != "all" && pattern != "std" {
		match = matchPattern(pattern)
		treeCanMatch = treeCanMatchPattern(pattern)
	}

	have := map[string]bool{
		"builtin": true, // ignore pseudo-package that exists only for documentation
	}
	if !buildContext.CgoEnabled {
		have["runtime/cgo"] = true // ignore during walk
	}
	var pkgs []string

	// Commands
	cmd := filepath.Join(goroot, "src/cmd") + string(filepath.Separator)
	filepath.Walk(cmd, func(path string, fi os.FileInfo, err error) error {
		if err != nil || !fi.IsDir() || path == cmd {
			return nil
		}
		name := path[len(cmd):]
		if !treeCanMatch(name) {
			return filepath.SkipDir
		}
		// Commands are all in cmd/, not in subdirectories.
		if strings.Contains(name, string(filepath.Separator)) {
			return filepath.SkipDir
		}

		// We use, e.g., cmd/gofmt as the pseudo import path for gofmt.
		name = "cmd/" + name
		if have[name] {
			return nil
		}
		have[name] = true
		if !match(name) {
			return nil
		}
		_, err = buildContext.ImportDir(path, 0)
		if err != nil {
			if _, noGo := err.(*build.NoGoError); !noGo {
				log.Print(err)
			}
			return nil
		}
		pkgs = append(pkgs, name)
		return nil
	})

	for _, src := range buildContext.SrcDirs() {
		if pattern == "std" && src != gorootSrc {
			continue
		}
		src = filepath.Clean(src) + string(filepath.Separator)
		filepath.Walk(src, func(path string, fi os.FileInfo, err error) error {
			if err != nil || !fi.IsDir() || path == src {
				return nil
			}

			// Avoid .foo, _foo, and testdata directory trees.
			_, elem := filepath.Split(path)
			if strings.HasPrefix(elem, ".") || strings.HasPrefix(elem, "_") || elem == "testdata" {
				return filepath.SkipDir
			}

			name := filepath.ToSlash(path[len(src):])
			if pattern == "std" && strings.Contains(name, ".") {
				return filepath.SkipDir
			}
			if !treeCanMatch(name) {
				return filepath.SkipDir
			}
			if have[name] {
				return nil
			}
			have[name] = true
			if !match(name) {
				return nil
			}
			_, err = buildContext.ImportDir(path, 0)
			if err != nil {
				if _, noGo := err.(*build.NoGoError); noGo {
					return nil
				}
			}
			pkgs = append(pkgs, name)
			return nil
		})
	}
	return pkgs
}

// allPackagesInFS is like allPackages but is passed a pattern
// beginning ./ or ../, meaning it should scan the tree rooted
// at the given directory.  There are ... in the pattern too.
func allPackagesInFS(pattern string) []string {
	pkgs := matchPackagesInFS(pattern)
	if len(pkgs) == 0 {
		fmt.Fprintf(os.Stderr, "warning: %q matched no packages\n", pattern)
	}
	return pkgs
}

func matchPackagesInFS(pattern string) []string {
	// Find directory to begin the scan.
	// Could be smarter but this one optimization
	// is enough for now, since ... is usually at the
	// end of a path.
	i := strings.Index(pattern, "...")
	dir, _ := path.Split(pattern[:i])

	// pattern begins with ./ or ../.
	// path.Clean will discard the ./ but not the ../.
	// We need to preserve the ./ for pattern matching
	// and in the returned import paths.
	prefix := ""
	if strings.HasPrefix(pattern, "./") {
		prefix = "./"
	}
	match := matchPattern(pattern)

	var pkgs []string
	filepath.Walk(dir, func(path string, fi os.FileInfo, err error) error {
		if err != nil || !fi.IsDir() {
			return nil
		}
		if path == dir {
			// filepath.Walk starts at dir and recurses. For the recursive case,
			// the path is the result of filepath.Join, which calls filepath.Clean.
			// The initial case is not Cleaned, though, so we do this explicitly.
			//
			// This converts a path like "./io/" to "io". Without this step, running
			// "cd $GOROOT/src; go list ./io/..." would incorrectly skip the io
			// package, because prepending the prefix "./" to the unclean path would
			// result in "././io", and match("././io") returns false.
			path = filepath.Clean(path)
		}

		// Avoid .foo, _foo, and testdata directory trees, but do not avoid "." or "..".
		_, elem := filepath.Split(path)
		dot := strings.HasPrefix(elem, ".") && elem != "." && elem != ".."
		if dot || strings.HasPrefix(elem, "_") || elem == "testdata" {
			return filepath.SkipDir
		}

		name := prefix + filepath.ToSlash(path)
		if !match(name) {
			return nil
		}
		if _, err = build.ImportDir(path, 0); err != nil {
			if _, noGo := err.(*build.NoGoError); !noGo {
				log.Print(err)
			}
			return nil
		}
		pkgs = append(pkgs, name)
		return nil
	})
	return pkgs
}

// stringList's arguments should be a sequence of string or []string values.
// stringList flattens them into a single []string.
func stringList(args ...interface{}) []string {
	var x []string
	for _, arg := range args {
		switch arg := arg.(type) {
		case []string:
			x = append(x, arg...)
		case string:
			x = append(x, arg)
		default:
			panic("stringList: invalid argument")
		}
	}
	return x
}

// toFold returns a string with the property that
//	strings.EqualFold(s, t) iff toFold(s) == toFold(t)
// This lets us test a large set of strings for fold-equivalent
// duplicates without making a quadratic number of calls
// to EqualFold. Note that strings.ToUpper and strings.ToLower
// have the desired property in some corner cases.
func toFold(s string) string {
	// Fast path: all ASCII, no upper case.
	// Most paths look like this already.
	for i := 0; i < len(s); i++ {
		c := s[i]
		if c >= utf8.RuneSelf || 'A' <= c && c <= 'Z' {
			goto Slow
		}
	}
	return s

Slow:
	var buf bytes.Buffer
	for _, r := range s {
		// SimpleFold(x) cycles to the next equivalent rune > x
		// or wraps around to smaller values. Iterate until it wraps,
		// and we've found the minimum value.
		for {
			r0 := r
			r = unicode.SimpleFold(r0)
			if r <= r0 {
				break
			}
		}
		// Exception to allow fast path above: A-Z => a-z
		if 'A' <= r && r <= 'Z' {
			r += 'a' - 'A'
		}
		buf.WriteRune(r)
	}
	return buf.String()
}

// foldDup reports a pair of strings from the list that are
// equal according to strings.EqualFold.
// It returns "", "" if there are no such strings.
func foldDup(list []string) (string, string) {
	clash := map[string]string{}
	for _, s := range list {
		fold := toFold(s)
		if t := clash[fold]; t != "" {
			if s > t {
				s, t = t, s
			}
			return s, t
		}
		clash[fold] = s
	}
	return "", ""
}
                                                                                                   root/go1.4/src/cmd/go/match_test.go                                                                 0100644 0000000 0000000 00000004466 12600426226 015513  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2012 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import "testing"

var matchPatternTests = []stringPairTest{
	{"...", "foo", true},
	{"net", "net", true},
	{"net", "net/http", false},
	{"net/http", "net", false},
	{"net/http", "net/http", true},
	{"net...", "netchan", true},
	{"net...", "net", true},
	{"net...", "net/http", true},
	{"net...", "not/http", false},
	{"net/...", "netchan", false},
	{"net/...", "net", true},
	{"net/...", "net/http", true},
	{"net/...", "not/http", false},
}

func TestMatchPattern(t *testing.T) {
	testStringPairs(t, "matchPattern", matchPatternTests, func(pattern, name string) bool {
		return matchPattern(pattern)(name)
	})
}

var treeCanMatchPatternTests = []stringPairTest{
	{"...", "foo", true},
	{"net", "net", true},
	{"net", "net/http", false},
	{"net/http", "net", true},
	{"net/http", "net/http", true},
	{"net...", "netchan", true},
	{"net...", "net", true},
	{"net...", "net/http", true},
	{"net...", "not/http", false},
	{"net/...", "netchan", false},
	{"net/...", "net", true},
	{"net/...", "net/http", true},
	{"net/...", "not/http", false},
	{"abc.../def", "abcxyz", true},
	{"abc.../def", "xyxabc", false},
	{"x/y/z/...", "x", true},
	{"x/y/z/...", "x/y", true},
	{"x/y/z/...", "x/y/z", true},
	{"x/y/z/...", "x/y/z/w", true},
	{"x/y/z", "x", true},
	{"x/y/z", "x/y", true},
	{"x/y/z", "x/y/z", true},
	{"x/y/z", "x/y/z/w", false},
	{"x/.../y/z", "x/a/b/c", true},
	{"x/.../y/z", "y/x/a/b/c", false},
}

func TestChildrenCanMatchPattern(t *testing.T) {
	testStringPairs(t, "treeCanMatchPattern", treeCanMatchPatternTests, func(pattern, name string) bool {
		return treeCanMatchPattern(pattern)(name)
	})
}

var hasPathPrefixTests = []stringPairTest{
	{"abc", "a", false},
	{"a/bc", "a", true},
	{"a", "a", true},
	{"a/bc", "a/", true},
}

func TestHasPathPrefix(t *testing.T) {
	testStringPairs(t, "hasPathPrefix", hasPathPrefixTests, hasPathPrefix)
}

type stringPairTest struct {
	in1 string
	in2 string
	out bool
}

func testStringPairs(t *testing.T, name string, tests []stringPairTest, f func(string, string) bool) {
	for _, tt := range tests {
		if out := f(tt.in1, tt.in2); out != tt.out {
			t.Errorf("%s(%q, %q) = %v, want %v", name, tt.in1, tt.in2, out, tt.out)
		}
	}
}
                                                                                                                                                                                                          root/go1.4/src/cmd/go/mkdoc.sh                                                                      0100755 0000000 0000000 00000000456 12600426226 014460  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/sh
# Copyright 2012 The Go Authors.  All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

go install # So the next line will produce updated documentation.
go help documentation | sed 's; \*/; * /;' >doc.go
gofmt -w doc.go

                                                                                                                                                                                                                  root/go1.4/src/cmd/go/pkg.go                                                                        0100644 0000000 0000000 00000075411 12600426226 014137  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/build"
	"go/scanner"
	"go/token"
	"os"
	pathpkg "path"
	"path/filepath"
	"runtime"
	"sort"
	"strings"
	"time"
	"unicode"
)

// A Package describes a single package found in a directory.
type Package struct {
	// Note: These fields are part of the go command's public API.
	// See list.go.  It is okay to add fields, but not to change or
	// remove existing ones.  Keep in sync with list.go
	Dir           string `json:",omitempty"` // directory containing package sources
	ImportPath    string `json:",omitempty"` // import path of package in dir
	ImportComment string `json:",omitempty"` // path in import comment on package statement
	Name          string `json:",omitempty"` // package name
	Doc           string `json:",omitempty"` // package documentation string
	Target        string `json:",omitempty"` // install path
	Goroot        bool   `json:",omitempty"` // is this package found in the Go root?
	Standard      bool   `json:",omitempty"` // is this package part of the standard Go library?
	Stale         bool   `json:",omitempty"` // would 'go install' do anything for this package?
	Root          string `json:",omitempty"` // Go root or Go path dir containing this package
	ConflictDir   string `json:",omitempty"` // Dir is hidden by this other directory

	// Source files
	GoFiles        []string `json:",omitempty"` // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)
	CgoFiles       []string `json:",omitempty"` // .go sources files that import "C"
	IgnoredGoFiles []string `json:",omitempty"` // .go sources ignored due to build constraints
	CFiles         []string `json:",omitempty"` // .c source files
	CXXFiles       []string `json:",omitempty"` // .cc, .cpp and .cxx source files
	MFiles         []string `json:",omitempty"` // .m source files
	HFiles         []string `json:",omitempty"` // .h, .hh, .hpp and .hxx source files
	SFiles         []string `json:",omitempty"` // .s source files
	SwigFiles      []string `json:",omitempty"` // .swig files
	SwigCXXFiles   []string `json:",omitempty"` // .swigcxx files
	SysoFiles      []string `json:",omitempty"` // .syso system object files added to package

	// Cgo directives
	CgoCFLAGS    []string `json:",omitempty"` // cgo: flags for C compiler
	CgoCPPFLAGS  []string `json:",omitempty"` // cgo: flags for C preprocessor
	CgoCXXFLAGS  []string `json:",omitempty"` // cgo: flags for C++ compiler
	CgoLDFLAGS   []string `json:",omitempty"` // cgo: flags for linker
	CgoPkgConfig []string `json:",omitempty"` // cgo: pkg-config names

	// Dependency information
	Imports []string `json:",omitempty"` // import paths used by this package
	Deps    []string `json:",omitempty"` // all (recursively) imported dependencies

	// Error information
	Incomplete bool            `json:",omitempty"` // was there an error loading this package or dependencies?
	Error      *PackageError   `json:",omitempty"` // error loading this package (not dependencies)
	DepsErrors []*PackageError `json:",omitempty"` // errors loading dependencies

	// Test information
	TestGoFiles  []string `json:",omitempty"` // _test.go files in package
	TestImports  []string `json:",omitempty"` // imports from TestGoFiles
	XTestGoFiles []string `json:",omitempty"` // _test.go files outside package
	XTestImports []string `json:",omitempty"` // imports from XTestGoFiles

	// Unexported fields are not part of the public API.
	build        *build.Package
	pkgdir       string // overrides build.PkgDir
	imports      []*Package
	deps         []*Package
	gofiles      []string // GoFiles+CgoFiles+TestGoFiles+XTestGoFiles files, absolute paths
	sfiles       []string
	allgofiles   []string             // gofiles + IgnoredGoFiles, absolute paths
	target       string               // installed file for this package (may be executable)
	fake         bool                 // synthesized package
	forceBuild   bool                 // this package must be rebuilt
	forceLibrary bool                 // this package is a library (even if named "main")
	cmdline      bool                 // defined by files listed on command line
	local        bool                 // imported via local path (./ or ../)
	localPrefix  string               // interpret ./ and ../ imports relative to this prefix
	exeName      string               // desired name for temporary executable
	coverMode    string               // preprocess Go source files with the coverage tool in this mode
	coverVars    map[string]*CoverVar // variables created by coverage analysis
	omitDWARF    bool                 // tell linker not to write DWARF information
}

// CoverVar holds the name of the generated coverage variables targeting the named file.
type CoverVar struct {
	File string // local file name
	Var  string // name of count struct
}

func (p *Package) copyBuild(pp *build.Package) {
	p.build = pp

	p.Dir = pp.Dir
	p.ImportPath = pp.ImportPath
	p.ImportComment = pp.ImportComment
	p.Name = pp.Name
	p.Doc = pp.Doc
	p.Root = pp.Root
	p.ConflictDir = pp.ConflictDir
	// TODO? Target
	p.Goroot = pp.Goroot
	p.Standard = p.Goroot && p.ImportPath != "" && !strings.Contains(p.ImportPath, ".")
	p.GoFiles = pp.GoFiles
	p.CgoFiles = pp.CgoFiles
	p.IgnoredGoFiles = pp.IgnoredGoFiles
	p.CFiles = pp.CFiles
	p.CXXFiles = pp.CXXFiles
	p.MFiles = pp.MFiles
	p.HFiles = pp.HFiles
	p.SFiles = pp.SFiles
	p.SwigFiles = pp.SwigFiles
	p.SwigCXXFiles = pp.SwigCXXFiles
	p.SysoFiles = pp.SysoFiles
	p.CgoCFLAGS = pp.CgoCFLAGS
	p.CgoCPPFLAGS = pp.CgoCPPFLAGS
	p.CgoCXXFLAGS = pp.CgoCXXFLAGS
	p.CgoLDFLAGS = pp.CgoLDFLAGS
	p.CgoPkgConfig = pp.CgoPkgConfig
	p.Imports = pp.Imports
	p.TestGoFiles = pp.TestGoFiles
	p.TestImports = pp.TestImports
	p.XTestGoFiles = pp.XTestGoFiles
	p.XTestImports = pp.XTestImports
}

// A PackageError describes an error loading information about a package.
type PackageError struct {
	ImportStack   []string // shortest path from package named on command line to this one
	Pos           string   // position of error
	Err           string   // the error itself
	isImportCycle bool     // the error is an import cycle
	hard          bool     // whether the error is soft or hard; soft errors are ignored in some places
}

func (p *PackageError) Error() string {
	// Import cycles deserve special treatment.
	if p.isImportCycle {
		return fmt.Sprintf("%s\npackage %s\n", p.Err, strings.Join(p.ImportStack, "\n\timports "))
	}
	if p.Pos != "" {
		// Omit import stack.  The full path to the file where the error
		// is the most important thing.
		return p.Pos + ": " + p.Err
	}
	if len(p.ImportStack) == 0 {
		return p.Err
	}
	return "package " + strings.Join(p.ImportStack, "\n\timports ") + ": " + p.Err
}

// An importStack is a stack of import paths.
type importStack []string

func (s *importStack) push(p string) {
	*s = append(*s, p)
}

func (s *importStack) pop() {
	*s = (*s)[0 : len(*s)-1]
}

func (s *importStack) copy() []string {
	return append([]string{}, *s...)
}

// shorterThan returns true if sp is shorter than t.
// We use this to record the shortest import sequence
// that leads to a particular package.
func (sp *importStack) shorterThan(t []string) bool {
	s := *sp
	if len(s) != len(t) {
		return len(s) < len(t)
	}
	// If they are the same length, settle ties using string ordering.
	for i := range s {
		if s[i] != t[i] {
			return s[i] < t[i]
		}
	}
	return false // they are equal
}

// packageCache is a lookup cache for loadPackage,
// so that if we look up a package multiple times
// we return the same pointer each time.
var packageCache = map[string]*Package{}

// reloadPackage is like loadPackage but makes sure
// not to use the package cache.
func reloadPackage(arg string, stk *importStack) *Package {
	p := packageCache[arg]
	if p != nil {
		delete(packageCache, p.Dir)
		delete(packageCache, p.ImportPath)
	}
	return loadPackage(arg, stk)
}

// dirToImportPath returns the pseudo-import path we use for a package
// outside the Go path.  It begins with _/ and then contains the full path
// to the directory.  If the package lives in c:\home\gopher\my\pkg then
// the pseudo-import path is _/c_/home/gopher/my/pkg.
// Using a pseudo-import path like this makes the ./ imports no longer
// a special case, so that all the code to deal with ordinary imports works
// automatically.
func dirToImportPath(dir string) string {
	return pathpkg.Join("_", strings.Map(makeImportValid, filepath.ToSlash(dir)))
}

func makeImportValid(r rune) rune {
	// Should match Go spec, compilers, and ../../go/parser/parser.go:/isValidImport.
	const illegalChars = `!"#$%&'()*,:;<=>?[\]^{|}` + "`\uFFFD"
	if !unicode.IsGraphic(r) || unicode.IsSpace(r) || strings.ContainsRune(illegalChars, r) {
		return '_'
	}
	return r
}

// loadImport scans the directory named by path, which must be an import path,
// but possibly a local import path (an absolute file system path or one beginning
// with ./ or ../).  A local relative path is interpreted relative to srcDir.
// It returns a *Package describing the package found in that directory.
func loadImport(path string, srcDir string, stk *importStack, importPos []token.Position) *Package {
	stk.push(path)
	defer stk.pop()

	// Determine canonical identifier for this package.
	// For a local import the identifier is the pseudo-import path
	// we create from the full directory to the package.
	// Otherwise it is the usual import path.
	importPath := path
	isLocal := build.IsLocalImport(path)
	if isLocal {
		importPath = dirToImportPath(filepath.Join(srcDir, path))
	}
	if p := packageCache[importPath]; p != nil {
		if perr := disallowInternal(srcDir, p, stk); perr != p {
			return perr
		}
		return reusePackage(p, stk)
	}

	p := new(Package)
	p.local = isLocal
	p.ImportPath = importPath
	packageCache[importPath] = p

	// Load package.
	// Import always returns bp != nil, even if an error occurs,
	// in order to return partial information.
	//
	// TODO: After Go 1, decide when to pass build.AllowBinary here.
	// See issue 3268 for mistakes to avoid.
	bp, err := buildContext.Import(path, srcDir, build.ImportComment)
	bp.ImportPath = importPath
	if gobin != "" {
		bp.BinDir = gobin
	}
	if err == nil && !isLocal && bp.ImportComment != "" && bp.ImportComment != path {
		err = fmt.Errorf("code in directory %s expects import %q", bp.Dir, bp.ImportComment)
	}
	p.load(stk, bp, err)
	if p.Error != nil && len(importPos) > 0 {
		pos := importPos[0]
		pos.Filename = shortPath(pos.Filename)
		p.Error.Pos = pos.String()
	}

	if perr := disallowInternal(srcDir, p, stk); perr != p {
		return perr
	}

	return p
}

// reusePackage reuses package p to satisfy the import at the top
// of the import stack stk.  If this use causes an import loop,
// reusePackage updates p's error information to record the loop.
func reusePackage(p *Package, stk *importStack) *Package {
	// We use p.imports==nil to detect a package that
	// is in the midst of its own loadPackage call
	// (all the recursion below happens before p.imports gets set).
	if p.imports == nil {
		if p.Error == nil {
			p.Error = &PackageError{
				ImportStack:   stk.copy(),
				Err:           "import cycle not allowed",
				isImportCycle: true,
			}
		}
		p.Incomplete = true
	}
	// Don't rewrite the import stack in the error if we have an import cycle.
	// If we do, we'll lose the path that describes the cycle.
	if p.Error != nil && !p.Error.isImportCycle && stk.shorterThan(p.Error.ImportStack) {
		p.Error.ImportStack = stk.copy()
	}
	return p
}

// disallowInternal checks that srcDir is allowed to import p.
// If the import is allowed, disallowInternal returns the original package p.
// If not, it returns a new package containing just an appropriate error.
func disallowInternal(srcDir string, p *Package, stk *importStack) *Package {
	// golang.org/s/go14internal:
	// An import of a path containing the element internal
	// is disallowed if the importing code is outside the tree
	// rooted at the parent of the internal directory.
	//
	// ... For Go 1.4, we will implement the rule first for $GOROOT, but not $GOPATH.

	// Only applies to $GOROOT.
	if !p.Standard {
		return p
	}

	// The stack includes p.ImportPath.
	// If that's the only thing on the stack, we started
	// with a name given on the command line, not an
	// import. Anything listed on the command line is fine.
	if len(*stk) == 1 {
		return p
	}

	// Check for "internal" element: four cases depending on begin of string and/or end of string.
	i, ok := findInternal(p.ImportPath)
	if !ok {
		return p
	}

	// Internal is present.
	// Map import path back to directory corresponding to parent of internal.
	if i > 0 {
		i-- // rewind over slash in ".../internal"
	}
	parent := p.Dir[:i+len(p.Dir)-len(p.ImportPath)]
	if hasPathPrefix(filepath.ToSlash(srcDir), filepath.ToSlash(parent)) {
		return p
	}

	// Internal is present, and srcDir is outside parent's tree. Not allowed.
	perr := *p
	perr.Error = &PackageError{
		ImportStack: stk.copy(),
		Err:         "use of internal package not allowed",
	}
	perr.Incomplete = true
	return &perr
}

// findInternal looks for the final "internal" path element in the given import path.
// If there isn't one, findInternal returns ok=false.
// Otherwise, findInternal returns ok=true and the index of the "internal".
func findInternal(path string) (index int, ok bool) {
	// Four cases, depending on internal at start/end of string or not.
	// The order matters: we must return the index of the final element,
	// because the final one produces the most restrictive requirement
	// on the importer.
	switch {
	case strings.HasSuffix(path, "/internal"):
		return len(path) - len("internal"), true
	case strings.Contains(path, "/internal/"):
		return strings.LastIndex(path, "/internal/") + 1, true
	case path == "internal", strings.HasPrefix(path, "internal/"):
		return 0, true
	}
	return 0, false
}

type targetDir int

const (
	toRoot    targetDir = iota // to bin dir inside package root (default)
	toTool                     // GOROOT/pkg/tool
	toBin                      // GOROOT/bin
	stalePath                  // the old import path; fail to build
)

// goTools is a map of Go program import path to install target directory.
var goTools = map[string]targetDir{
	"cmd/addr2line":                        toTool,
	"cmd/api":                              toTool,
	"cmd/cgo":                              toTool,
	"cmd/fix":                              toTool,
	"cmd/link":                             toTool,
	"cmd/nm":                               toTool,
	"cmd/objdump":                          toTool,
	"cmd/pack":                             toTool,
	"cmd/pprof":                            toTool,
	"cmd/yacc":                             toTool,
	"golang.org/x/tools/cmd/cover":         toTool,
	"golang.org/x/tools/cmd/godoc":         toBin,
	"golang.org/x/tools/cmd/vet":           toTool,
	"code.google.com/p/go.tools/cmd/cover": stalePath,
	"code.google.com/p/go.tools/cmd/godoc": stalePath,
	"code.google.com/p/go.tools/cmd/vet":   stalePath,
}

// expandScanner expands a scanner.List error into all the errors in the list.
// The default Error method only shows the first error.
func expandScanner(err error) error {
	// Look for parser errors.
	if err, ok := err.(scanner.ErrorList); ok {
		// Prepare error with \n before each message.
		// When printed in something like context: %v
		// this will put the leading file positions each on
		// its own line.  It will also show all the errors
		// instead of just the first, as err.Error does.
		var buf bytes.Buffer
		for _, e := range err {
			e.Pos.Filename = shortPath(e.Pos.Filename)
			buf.WriteString("\n")
			buf.WriteString(e.Error())
		}
		return errors.New(buf.String())
	}
	return err
}

var raceExclude = map[string]bool{
	"runtime/race": true,
	"runtime/cgo":  true,
	"cmd/cgo":      true,
	"syscall":      true,
	"errors":       true,
}

var cgoExclude = map[string]bool{
	"runtime/cgo": true,
}

var cgoSyscallExclude = map[string]bool{
	"runtime/cgo":  true,
	"runtime/race": true,
}

// load populates p using information from bp, err, which should
// be the result of calling build.Context.Import.
func (p *Package) load(stk *importStack, bp *build.Package, err error) *Package {
	p.copyBuild(bp)

	// The localPrefix is the path we interpret ./ imports relative to.
	// Synthesized main packages sometimes override this.
	p.localPrefix = dirToImportPath(p.Dir)

	if err != nil {
		p.Incomplete = true
		err = expandScanner(err)
		p.Error = &PackageError{
			ImportStack: stk.copy(),
			Err:         err.Error(),
		}
		return p
	}

	if p.Name == "main" {
		// Report an error when the old code.google.com/p/go.tools paths are used.
		if goTools[p.ImportPath] == stalePath {
			newPath := strings.Replace(p.ImportPath, "code.google.com/p/go.", "golang.org/x/", 1)
			e := fmt.Sprintf("the %v command has moved; use %v instead.", p.ImportPath, newPath)
			p.Error = &PackageError{Err: e}
			return p
		}
		_, elem := filepath.Split(p.Dir)
		full := buildContext.GOOS + "_" + buildContext.GOARCH + "/" + elem
		if buildContext.GOOS != toolGOOS || buildContext.GOARCH != toolGOARCH {
			// Install cross-compiled binaries to subdirectories of bin.
			elem = full
		}
		if p.build.BinDir != gobin && goTools[p.ImportPath] == toBin {
			// Override BinDir.
			// This is from a subrepo but installs to $GOROOT/bin
			// by default anyway (like godoc).
			p.target = filepath.Join(gorootBin, elem)
		} else if p.build.BinDir != "" {
			// Install to GOBIN or bin of GOPATH entry.
			p.target = filepath.Join(p.build.BinDir, elem)
		}
		if goTools[p.ImportPath] == toTool {
			// This is for 'go tool'.
			// Override all the usual logic and force it into the tool directory.
			p.target = filepath.Join(gorootPkg, "tool", full)
		}
		if p.target != "" && buildContext.GOOS == "windows" {
			p.target += ".exe"
		}
	} else if p.local {
		// Local import turned into absolute path.
		// No permanent install target.
		p.target = ""
	} else {
		p.target = p.build.PkgObj
	}

	importPaths := p.Imports
	// Packages that use cgo import runtime/cgo implicitly.
	// Packages that use cgo also import syscall implicitly,
	// to wrap errno.
	// Exclude certain packages to avoid circular dependencies.
	if len(p.CgoFiles) > 0 && (!p.Standard || !cgoExclude[p.ImportPath]) {
		importPaths = append(importPaths, "runtime/cgo")
	}
	if len(p.CgoFiles) > 0 && (!p.Standard || !cgoSyscallExclude[p.ImportPath]) {
		importPaths = append(importPaths, "syscall")
	}
	// Everything depends on runtime, except runtime and unsafe.
	if !p.Standard || (p.ImportPath != "runtime" && p.ImportPath != "unsafe") {
		importPaths = append(importPaths, "runtime")
		// When race detection enabled everything depends on runtime/race.
		// Exclude certain packages to avoid circular dependencies.
		if buildRace && (!p.Standard || !raceExclude[p.ImportPath]) {
			importPaths = append(importPaths, "runtime/race")
		}
	}

	// Build list of full paths to all Go files in the package,
	// for use by commands like go fmt.
	p.gofiles = stringList(p.GoFiles, p.CgoFiles, p.TestGoFiles, p.XTestGoFiles)
	for i := range p.gofiles {
		p.gofiles[i] = filepath.Join(p.Dir, p.gofiles[i])
	}
	sort.Strings(p.gofiles)

	p.sfiles = stringList(p.SFiles)
	for i := range p.sfiles {
		p.sfiles[i] = filepath.Join(p.Dir, p.sfiles[i])
	}
	sort.Strings(p.sfiles)

	p.allgofiles = stringList(p.IgnoredGoFiles)
	for i := range p.allgofiles {
		p.allgofiles[i] = filepath.Join(p.Dir, p.allgofiles[i])
	}
	p.allgofiles = append(p.allgofiles, p.gofiles...)
	sort.Strings(p.allgofiles)

	// Check for case-insensitive collision of input files.
	// To avoid problems on case-insensitive files, we reject any package
	// where two different input files have equal names under a case-insensitive
	// comparison.
	f1, f2 := foldDup(stringList(
		p.GoFiles,
		p.CgoFiles,
		p.IgnoredGoFiles,
		p.CFiles,
		p.CXXFiles,
		p.MFiles,
		p.HFiles,
		p.SFiles,
		p.SysoFiles,
		p.SwigFiles,
		p.SwigCXXFiles,
		p.TestGoFiles,
		p.XTestGoFiles,
	))
	if f1 != "" {
		p.Error = &PackageError{
			ImportStack: stk.copy(),
			Err:         fmt.Sprintf("case-insensitive file name collision: %q and %q", f1, f2),
		}
		return p
	}

	// Build list of imported packages and full dependency list.
	imports := make([]*Package, 0, len(p.Imports))
	deps := make(map[string]*Package)
	for i, path := range importPaths {
		if path == "C" {
			continue
		}
		p1 := loadImport(path, p.Dir, stk, p.build.ImportPos[path])
		if p1.local {
			if !p.local && p.Error == nil {
				p.Error = &PackageError{
					ImportStack: stk.copy(),
					Err:         fmt.Sprintf("local import %q in non-local package", path),
				}
				pos := p.build.ImportPos[path]
				if len(pos) > 0 {
					p.Error.Pos = pos[0].String()
				}
			}
			path = p1.ImportPath
			importPaths[i] = path
		}
		deps[path] = p1
		imports = append(imports, p1)
		for _, dep := range p1.deps {
			deps[dep.ImportPath] = dep
		}
		if p1.Incomplete {
			p.Incomplete = true
		}
	}
	p.imports = imports

	p.Deps = make([]string, 0, len(deps))
	for dep := range deps {
		p.Deps = append(p.Deps, dep)
	}
	sort.Strings(p.Deps)
	for _, dep := range p.Deps {
		p1 := deps[dep]
		if p1 == nil {
			panic("impossible: missing entry in package cache for " + dep + " imported by " + p.ImportPath)
		}
		p.deps = append(p.deps, p1)
		if p1.Error != nil {
			p.DepsErrors = append(p.DepsErrors, p1.Error)
		}
	}

	// unsafe is a fake package.
	if p.Standard && (p.ImportPath == "unsafe" || buildContext.Compiler == "gccgo") {
		p.target = ""
	}
	p.Target = p.target

	// Check for C code compiled with Plan 9 C compiler.
	// No longer allowed except in runtime and runtime/cgo, for now.
	if len(p.CFiles) > 0 && !p.usesCgo() && (!p.Standard || p.ImportPath != "runtime") {
		p.Error = &PackageError{
			ImportStack: stk.copy(),
			Err:         fmt.Sprintf("C source files not allowed when not using cgo: %s", strings.Join(p.CFiles, " ")),
		}
		return p
	}

	// In the absence of errors lower in the dependency tree,
	// check for case-insensitive collisions of import paths.
	if len(p.DepsErrors) == 0 {
		dep1, dep2 := foldDup(p.Deps)
		if dep1 != "" {
			p.Error = &PackageError{
				ImportStack: stk.copy(),
				Err:         fmt.Sprintf("case-insensitive import collision: %q and %q", dep1, dep2),
			}
			return p
		}
	}

	return p
}

// usesSwig reports whether the package needs to run SWIG.
func (p *Package) usesSwig() bool {
	return len(p.SwigFiles) > 0 || len(p.SwigCXXFiles) > 0
}

// usesCgo reports whether the package needs to run cgo
func (p *Package) usesCgo() bool {
	return len(p.CgoFiles) > 0
}

// packageList returns the list of packages in the dag rooted at roots
// as visited in a depth-first post-order traversal.
func packageList(roots []*Package) []*Package {
	seen := map[*Package]bool{}
	all := []*Package{}
	var walk func(*Package)
	walk = func(p *Package) {
		if seen[p] {
			return
		}
		seen[p] = true
		for _, p1 := range p.imports {
			walk(p1)
		}
		all = append(all, p)
	}
	for _, root := range roots {
		walk(root)
	}
	return all
}

// computeStale computes the Stale flag in the package dag that starts
// at the named pkgs (command-line arguments).
func computeStale(pkgs ...*Package) {
	topRoot := map[string]bool{}
	for _, p := range pkgs {
		topRoot[p.Root] = true
	}

	for _, p := range packageList(pkgs) {
		p.Stale = isStale(p, topRoot)
	}
}

// The runtime version string takes one of two forms:
// "go1.X[.Y]" for Go releases, and "devel +hash" at tip.
// Determine whether we are in a released copy by
// inspecting the version.
var isGoRelease = strings.HasPrefix(runtime.Version(), "go1")

// isStale reports whether package p needs to be rebuilt.
func isStale(p *Package, topRoot map[string]bool) bool {
	if p.Standard && (p.ImportPath == "unsafe" || buildContext.Compiler == "gccgo") {
		// fake, builtin package
		return false
	}
	if p.Error != nil {
		return true
	}

	// A package without Go sources means we only found
	// the installed .a file.  Since we don't know how to rebuild
	// it, it can't be stale, even if -a is set.  This enables binary-only
	// distributions of Go packages, although such binaries are
	// only useful with the specific version of the toolchain that
	// created them.
	if len(p.gofiles) == 0 && !p.usesSwig() {
		return false
	}

	// If we are running a release copy of Go, do not rebuild the standard packages.
	// They may not be writable anyway, but they are certainly not changing.
	// This makes 'go build -a' skip the standard packages when using an official release.
	// See issue 4106 and issue 8290.
	pkgBuildA := buildA
	if p.Standard && isGoRelease {
		pkgBuildA = false
	}

	if pkgBuildA || p.target == "" || p.Stale {
		return true
	}

	// Package is stale if completely unbuilt.
	var built time.Time
	if fi, err := os.Stat(p.target); err == nil {
		built = fi.ModTime()
	}
	if built.IsZero() {
		return true
	}

	olderThan := func(file string) bool {
		fi, err := os.Stat(file)
		return err != nil || fi.ModTime().After(built)
	}

	// Package is stale if a dependency is, or if a dependency is newer.
	for _, p1 := range p.deps {
		if p1.Stale || p1.target != "" && olderThan(p1.target) {
			return true
		}
	}

	// As a courtesy to developers installing new versions of the compiler
	// frequently, define that packages are stale if they are
	// older than the compiler, and commands if they are older than
	// the linker.  This heuristic will not work if the binaries are
	// back-dated, as some binary distributions may do, but it does handle
	// a very common case.
	// See issue 3036.
	// Assume code in $GOROOT is up to date, since it may not be writeable.
	// See issue 4106.
	if p.Root != goroot {
		if olderThan(buildToolchain.compiler()) {
			return true
		}
		if p.build.IsCommand() && olderThan(buildToolchain.linker()) {
			return true
		}
	}

	// Have installed copy, probably built using current compilers,
	// and built after its imported packages.  The only reason now
	// that we'd have to rebuild it is if the sources were newer than
	// the package.   If a package p is not in the same tree as any
	// package named on the command-line, assume it is up-to-date
	// no matter what the modification times on the source files indicate.
	// This avoids rebuilding $GOROOT packages when people are
	// working outside the Go root, and it effectively makes each tree
	// listed in $GOPATH a separate compilation world.
	// See issue 3149.
	if p.Root != "" && !topRoot[p.Root] {
		return false
	}

	srcs := stringList(p.GoFiles, p.CFiles, p.CXXFiles, p.MFiles, p.HFiles, p.SFiles, p.CgoFiles, p.SysoFiles, p.SwigFiles, p.SwigCXXFiles)
	for _, src := range srcs {
		if olderThan(filepath.Join(p.Dir, src)) {
			return true
		}
	}

	return false
}

var cwd, _ = os.Getwd()

var cmdCache = map[string]*Package{}

// loadPackage is like loadImport but is used for command-line arguments,
// not for paths found in import statements.  In addition to ordinary import paths,
// loadPackage accepts pseudo-paths beginning with cmd/ to denote commands
// in the Go command directory, as well as paths to those directories.
func loadPackage(arg string, stk *importStack) *Package {
	if build.IsLocalImport(arg) {
		dir := arg
		if !filepath.IsAbs(dir) {
			if abs, err := filepath.Abs(dir); err == nil {
				// interpret relative to current directory
				dir = abs
			}
		}
		if sub, ok := hasSubdir(gorootSrc, dir); ok && strings.HasPrefix(sub, "cmd/") && !strings.Contains(sub[4:], "/") {
			arg = sub
		}
	}
	if strings.HasPrefix(arg, "cmd/") && !strings.Contains(arg[4:], "/") {
		if p := cmdCache[arg]; p != nil {
			return p
		}
		stk.push(arg)
		defer stk.pop()

		bp, err := buildContext.ImportDir(filepath.Join(gorootSrc, arg), 0)
		bp.ImportPath = arg
		bp.Goroot = true
		bp.BinDir = gorootBin
		if gobin != "" {
			bp.BinDir = gobin
		}
		bp.Root = goroot
		bp.SrcRoot = gorootSrc
		p := new(Package)
		cmdCache[arg] = p
		p.load(stk, bp, err)
		if p.Error == nil && p.Name != "main" {
			p.Error = &PackageError{
				ImportStack: stk.copy(),
				Err:         fmt.Sprintf("expected package main but found package %s in %s", p.Name, p.Dir),
			}
		}
		return p
	}

	// Wasn't a command; must be a package.
	// If it is a local import path but names a standard package,
	// we treat it as if the user specified the standard package.
	// This lets you run go test ./ioutil in package io and be
	// referring to io/ioutil rather than a hypothetical import of
	// "./ioutil".
	if build.IsLocalImport(arg) {
		bp, _ := buildContext.ImportDir(filepath.Join(cwd, arg), build.FindOnly)
		if bp.ImportPath != "" && bp.ImportPath != "." {
			arg = bp.ImportPath
		}
	}

	return loadImport(arg, cwd, stk, nil)
}

// packages returns the packages named by the
// command line arguments 'args'.  If a named package
// cannot be loaded at all (for example, if the directory does not exist),
// then packages prints an error and does not include that
// package in the results.  However, if errors occur trying
// to load dependencies of a named package, the named
// package is still returned, with p.Incomplete = true
// and details in p.DepsErrors.
func packages(args []string) []*Package {
	var pkgs []*Package
	for _, pkg := range packagesAndErrors(args) {
		if pkg.Error != nil {
			errorf("can't load package: %s", pkg.Error)
			continue
		}
		pkgs = append(pkgs, pkg)
	}
	return pkgs
}

// packagesAndErrors is like 'packages' but returns a
// *Package for every argument, even the ones that
// cannot be loaded at all.
// The packages that fail to load will have p.Error != nil.
func packagesAndErrors(args []string) []*Package {
	if len(args) > 0 && strings.HasSuffix(args[0], ".go") {
		return []*Package{goFilesPackage(args)}
	}

	args = importPaths(args)
	var pkgs []*Package
	var stk importStack
	var set = make(map[string]bool)

	for _, arg := range args {
		if !set[arg] {
			pkgs = append(pkgs, loadPackage(arg, &stk))
			set[arg] = true
		}
	}
	computeStale(pkgs...)

	return pkgs
}

// packagesForBuild is like 'packages' but fails if any of
// the packages or their dependencies have errors
// (cannot be built).
func packagesForBuild(args []string) []*Package {
	pkgs := packagesAndErrors(args)
	printed := map[*PackageError]bool{}
	for _, pkg := range pkgs {
		if pkg.Error != nil {
			errorf("can't load package: %s", pkg.Error)
		}
		for _, err := range pkg.DepsErrors {
			// Since these are errors in dependencies,
			// the same error might show up multiple times,
			// once in each package that depends on it.
			// Only print each once.
			if !printed[err] {
				printed[err] = true
				errorf("%s", err)
			}
		}
	}
	exitIfErrors()
	return pkgs
}

// hasSubdir reports whether dir is a subdirectory of
// (possibly multiple levels below) root.
// If so, it sets rel to the path fragment that must be
// appended to root to reach dir.
func hasSubdir(root, dir string) (rel string, ok bool) {
	if p, err := filepath.EvalSymlinks(root); err == nil {
		root = p
	}
	if p, err := filepath.EvalSymlinks(dir); err == nil {
		dir = p
	}
	const sep = string(filepath.Separator)
	root = filepath.Clean(root)
	if !strings.HasSuffix(root, sep) {
		root += sep
	}
	dir = filepath.Clean(dir)
	if !strings.HasPrefix(dir, root) {
		return "", false
	}
	return filepath.ToSlash(dir[len(root):]), true
}
                                                                                                                                                                                                                                                       root/go1.4/src/cmd/go/pkg_test.go                                                                   0100644 0000000 0000000 00000003704 12600426226 015172  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"reflect"
	"strings"
	"testing"
)

var foldDupTests = []struct {
	list   []string
	f1, f2 string
}{
	{stringList("math/rand", "math/big"), "", ""},
	{stringList("math", "strings"), "", ""},
	{stringList("strings"), "", ""},
	{stringList("strings", "strings"), "strings", "strings"},
	{stringList("Rand", "rand", "math", "math/rand", "math/Rand"), "Rand", "rand"},
}

func TestFoldDup(t *testing.T) {
	for _, tt := range foldDupTests {
		f1, f2 := foldDup(tt.list)
		if f1 != tt.f1 || f2 != tt.f2 {
			t.Errorf("foldDup(%q) = %q, %q, want %q, %q", tt.list, f1, f2, tt.f1, tt.f2)
		}
	}
}

var parseMetaGoImportsTests = []struct {
	in  string
	out []metaImport
}{
	{
		`<meta name="go-import" content="foo/bar git https://github.com/rsc/foo/bar">`,
		[]metaImport{{"foo/bar", "git", "https://github.com/rsc/foo/bar"}},
	},
	{
		`<meta name="go-import" content="foo/bar git https://github.com/rsc/foo/bar">
		<meta name="go-import" content="baz/quux git http://github.com/rsc/baz/quux">`,
		[]metaImport{
			{"foo/bar", "git", "https://github.com/rsc/foo/bar"},
			{"baz/quux", "git", "http://github.com/rsc/baz/quux"},
		},
	},
	{
		`<head>
		<meta name="go-import" content="foo/bar git https://github.com/rsc/foo/bar">
		</head>`,
		[]metaImport{{"foo/bar", "git", "https://github.com/rsc/foo/bar"}},
	},
	{
		`<meta name="go-import" content="foo/bar git https://github.com/rsc/foo/bar">
		<body>`,
		[]metaImport{{"foo/bar", "git", "https://github.com/rsc/foo/bar"}},
	},
}

func TestParseMetaGoImports(t *testing.T) {
	for i, tt := range parseMetaGoImportsTests {
		out, err := parseMetaGoImports(strings.NewReader(tt.in))
		if err != nil {
			t.Errorf("test#%d: %v", i, err)
			continue
		}
		if !reflect.DeepEqual(out, tt.out) {
			t.Errorf("test#%d:\n\thave %q\n\twant %q", i, out, tt.out)
		}
	}
}
                                                            root/go1.4/src/cmd/go/run.go                                                                        0100644 0000000 0000000 00000007345 12600426226 014163  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"strings"
)

var execCmd []string // -exec flag, for run and test

func findExecCmd() []string {
	if execCmd != nil {
		return execCmd
	}
	execCmd = []string{} // avoid work the second time
	if goos == runtime.GOOS && goarch == runtime.GOARCH {
		return execCmd
	}
	path, err := exec.LookPath(fmt.Sprintf("go_%s_%s_exec", goos, goarch))
	if err == nil {
		execCmd = []string{path}
	}
	return execCmd
}

var cmdRun = &Command{
	UsageLine: "run [build flags] [-exec xprog] gofiles... [arguments...]",
	Short:     "compile and run Go program",
	Long: `
Run compiles and runs the main package comprising the named Go source files.
A Go source file is defined to be a file ending in a literal ".go" suffix.

By default, 'go run' runs the compiled binary directly: 'a.out arguments...'.
If the -exec flag is given, 'go run' invokes the binary using xprog: 'xprog a.out arguments...'.
If the -exec flag is not given, GOOS or GOARCH is different from the system
default, and a program named go_$GOOS_$GOARCH_exec can be found
on the current search path, 'go run' invokes the binary using that program,
for example 'go_nacl_386_exec a.out arguments...'. This allows execution of
cross-compiled programs when a simulator or other execution method is
available.

For more about build flags, see 'go help build'.

See also: go build.
	`,
}

func init() {
	cmdRun.Run = runRun // break init loop

	addBuildFlags(cmdRun)
	cmdRun.Flag.Var((*stringsFlag)(&execCmd), "exec", "")
}

func printStderr(args ...interface{}) (int, error) {
	return fmt.Fprint(os.Stderr, args...)
}

func runRun(cmd *Command, args []string) {
	raceInit()
	var b builder
	b.init()
	b.print = printStderr
	i := 0
	for i < len(args) && strings.HasSuffix(args[i], ".go") {
		i++
	}
	files, cmdArgs := args[:i], args[i:]
	if len(files) == 0 {
		fatalf("go run: no go files listed")
	}
	for _, file := range files {
		if strings.HasSuffix(file, "_test.go") {
			// goFilesPackage is going to assign this to TestGoFiles.
			// Reject since it won't be part of the build.
			fatalf("go run: cannot run *_test.go files (%s)", file)
		}
	}
	p := goFilesPackage(files)
	if p.Error != nil {
		fatalf("%s", p.Error)
	}
	p.omitDWARF = true
	for _, err := range p.DepsErrors {
		errorf("%s", err)
	}
	exitIfErrors()
	if p.Name != "main" {
		fatalf("go run: cannot run non-main package")
	}
	p.target = "" // must build - not up to date
	var src string
	if len(p.GoFiles) > 0 {
		src = p.GoFiles[0]
	} else if len(p.CgoFiles) > 0 {
		src = p.CgoFiles[0]
	} else {
		// this case could only happen if the provided source uses cgo
		// while cgo is disabled.
		hint := ""
		if !buildContext.CgoEnabled {
			hint = " (cgo is disabled)"
		}
		fatalf("go run: no suitable source files%s", hint)
	}
	p.exeName = src[:len(src)-len(".go")] // name temporary executable for first go file
	a1 := b.action(modeBuild, modeBuild, p)
	a := &action{f: (*builder).runProgram, args: cmdArgs, deps: []*action{a1}}
	b.do(a)
}

// runProgram is the action for running a binary that has already
// been compiled.  We ignore exit status.
func (b *builder) runProgram(a *action) error {
	cmdline := stringList(findExecCmd(), a.deps[0].target, a.args)
	if buildN || buildX {
		b.showcmd("", "%s", strings.Join(cmdline, " "))
		if buildN {
			return nil
		}
	}

	runStdin(cmdline)
	return nil
}

// runStdin is like run, but connects Stdin.
func runStdin(cmdline []string) {
	cmd := exec.Command(cmdline[0], cmdline[1:]...)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	startSigHandlers()
	if err := cmd.Run(); err != nil {
		errorf("%v", err)
	}
}
                                                                                                                                                                                                                                                                                           root/go1.4/src/cmd/go/script                                                                        0100755 0000000 0000000 00000000431 12600426226 014247  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/sh

x() {
	echo '--- ' "$@"
	"$@"
	echo '---'
	echo
}

x go help
x go help build
x go help clean
x go help install
x go help fix
x go help fmt
x go help get
x go help list
x go help test
x go help version
x go help vet
x go help gopath
x go help importpath
x go help remote
                                                                                                                                                                                                                                       root/go1.4/src/cmd/go/script.txt                                                                    0100644 0000000 0000000 00000024427 12600426226 015075  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        ---  go help
usage: go command [arguments]

go manages Go source code.

The commands are:

    build       compile and install packages and dependencies
    clean       remove intermediate objects
    fix         run gofix on packages
    fmt         run gofmt -w on packages
    get         download and install packages and dependencies
    install     install packages and dependencies
    list        list packages
    test        test packages
    version     print Go version
    vet         run govet on packages

Use "go help [command]" for more information about a command.

Additional help topics:

    gopath      GOPATH environment variable
    importpath  description of import paths
    remote      remote import path syntax

Use "go help [topic]" for more information about that topic.

---

---  go help build
usage: go build [-n] [-v] [importpath...]

Build compiles the packages named by the import paths,
along with their dependencies, but it does not install the results.

The -n flag prints the commands but does not run them.
The -v flag prints the commands.

For more about import paths, see 'go help importpath'.

See also: go install, go get, go clean.
---

---  go help clean
usage: go clean [-nuke] [importpath...]

Clean removes intermediate object files generated during
the compilation of the packages named by the import paths,
but by default it does not remove the installed package binaries.

The -nuke flag causes clean to remove the installed package binaries too.

TODO: Clean does not clean dependencies of the packages.

For more about import paths, see 'go help importpath'.
---

---  go help install
usage: go install [-n] [-v] [importpath...]

Install compiles and installs the packages named by the import paths,
along with their dependencies.

The -n flag prints the commands but does not run them.
The -v flag prints the commands.

For more about import paths, see 'go help importpath'.

See also: go build, go get, go clean.
---

---  go help fix
usage: go fix [importpath...]

Fix runs the gofix command on the packages named by the import paths.

For more about gofix, see 'godoc gofix'.
For more about import paths, see 'go help importpath'.

To run gofix with specific options, run gofix itself.

See also: go fmt, go vet.
---

---  go help fmt
usage: go fmt [importpath...]

Fmt runs the command 'gofmt -w' on the packages named by the import paths.

For more about gofmt, see 'godoc gofmt'.
For more about import paths, see 'go help importpath'.

To run gofmt with specific options, run gofmt itself.

See also: go fix, go vet.
---

---  go help get
usage: go get [importpath...]

Get downloads and installs the packages named by the import paths,
along with their dependencies.

After downloading the code, 'go get' looks for a tag beginning
with "go." that corresponds to the local Go version.
For Go "release.r58" it looks for a tag named "go.r58".
For "weekly.2011-06-03" it looks for "go.weekly.2011-06-03".
If the specific "go.X" tag is not found, it uses the latest earlier
version it can find.  Otherwise, it uses the default version for
the version control system: HEAD for git, tip for Mercurial,
and so on.

TODO: Explain versions better.

For more about import paths, see 'go help importpath'.

For more about how 'go get' finds source code to
download, see 'go help remote'.

See also: go build, go install, go clean.
---

---  go help list
usage: go list [-f format] [-json] [importpath...]

List lists the packages named by the import paths.

The default output shows the package name and file system location:

    books /home/you/src/google-api-go-client.googlecode.com/hg/books/v1
    oauth /home/you/src/goauth2.googlecode.com/hg/oauth
    sqlite /home/you/src/gosqlite.googlecode.com/hg/sqlite

The -f flag specifies an alternate format for the list,
using the syntax of package template.  The default output
is equivalent to -f '{{.Name}} {{.Dir}}'  The struct
being passed to the template is:

    type Package struct {
        Name string         // package name
        Doc string          // package documentation string
        GoFiles []string    // names of Go source files in package
        ImportPath string   // import path denoting package
        Imports []string    // import paths used by this package
        Deps []string       // all (recursively) imported dependencies
        Dir string          // directory containing package sources
        Version string      // version of installed package
    }

The -json flag causes the package data to be printed in JSON format.

For more about import paths, see 'go help importpath'.
---

---  go help test
usage: go test [importpath...]

Test runs gotest to test the packages named by the import paths.
It prints a summary of the test results in the format:

	test archive/tar
	FAIL archive/zip
	test compress/gzip
	...

followed by gotest output for each failed package.

For more about import paths, see 'go help importpath'.

See also: go build, go compile, go vet.
---

---  go help version
usage: go version

Version prints the Go version, as reported by runtime.Version.
---

---  go help vet
usage: go vet [importpath...]

Vet runs the govet command on the packages named by the import paths.

For more about govet, see 'godoc govet'.
For more about import paths, see 'go help importpath'.

To run govet with specific options, run govet itself.

See also: go fmt, go fix.
---

---  go help gopath
The GOPATH environment variable lists places to look for Go code.
On Unix, the value is a colon-separated string.
On Windows, the value is a semicolon-separated string.
On Plan 9, the value is a list.

GOPATH must be set to build and install packages outside the
standard Go tree.

Each directory listed in GOPATH must have a prescribed structure:

The src/ directory holds source code.  The path below 'src'
determines the import path or executable name.

The pkg/ directory holds installed package objects.
As in the Go tree, each target operating system and
architecture pair has its own subdirectory of pkg
(pkg/GOOS_GOARCH).

If DIR is a directory listed in the GOPATH, a package with
source in DIR/src/foo/bar can be imported as "foo/bar" and
has its compiled form installed to "DIR/pkg/GOOS_GOARCH/foo/bar.a".

The bin/ directory holds compiled commands.
Each command is named for its source directory, but only
the final element, not the entire path.  That is, the
command with source in DIR/src/foo/quux is installed into
DIR/bin/quux, not DIR/bin/foo/quux.  The foo/ is stripped
so that you can add DIR/bin to your PATH to get at the
installed commands.

Here's an example directory layout:

    GOPATH=/home/user/gocode

    /home/user/gocode/
        src/
            foo/
                bar/               (go code in package bar)
                    x.go
                quux/              (go code in package main)
                    y.go
        bin/
            quux                   (installed command)
		pkg/
		    linux_amd64/
		        foo/
		            bar.a          (installed package object)

Go searches each directory listed in GOPATH to find source code,
but new packages are always downloaded into the first directory 
in the list.
---

---  go help importpath
Many commands apply to a set of packages named by import paths:

	go action [importpath...]

An import path that is a rooted path or that begins with
a . or .. element is interpreted as a file system path and
denotes the package in that directory.

Otherwise, the import path P denotes the package found in
the directory DIR/src/P for some DIR listed in the GOPATH
environment variable (see 'go help gopath'). 

If no import paths are given, the action applies to the
package in the current directory.

The special import path "all" expands to all package directories
found in all the GOPATH trees.  For example, 'go list all' 
lists all the packages on the local system.

An import path can also name a package to be downloaded from
a remote repository.  Run 'go help remote' for details.

Every package in a program must have a unique import path.
By convention, this is arranged by starting each path with a
unique prefix that belongs to you.  For example, paths used
internally at Google all begin with 'google', and paths
denoting remote repositories begin with the path to the code,
such as 'project.googlecode.com/'.
---

---  go help remote
An import path (see 'go help importpath') denotes a package
stored in the local file system.  Certain import paths also
describe how to obtain the source code for the package using
a revision control system.

A few common code hosting sites have special syntax:

	BitBucket (Mercurial)

		import "bitbucket.org/user/project"
		import "bitbucket.org/user/project/sub/directory"

	GitHub (Git)

		import "github.com/user/project"
		import "github.com/user/project/sub/directory"

	Google Code Project Hosting (Git, Mercurial, Subversion)

		import "project.googlecode.com/git"
		import "project.googlecode.com/git/sub/directory"

		import "project.googlecode.com/hg"
		import "project.googlecode.com/hg/sub/directory"

		import "project.googlecode.com/svn/trunk"
		import "project.googlecode.com/svn/trunk/sub/directory"

	Launchpad (Bazaar)

		import "launchpad.net/project"
		import "launchpad.net/project/series"
		import "launchpad.net/project/series/sub/directory"

		import "launchpad.net/~user/project/branch"
		import "launchpad.net/~user/project/branch/sub/directory"

For code hosted on other servers, an import path of the form

	repository.vcs/path

specifies the given repository, with or without the .vcs suffix,
using the named version control system, and then the path inside
that repository.  The supported version control systems are:

	Bazaar      .bzr
	Git         .git
	Mercurial   .hg
	Subversion  .svn

For example,

	import "example.org/user/foo.hg"

denotes the root directory of the Mercurial repository at
example.org/user/foo or foo.hg, and

	import "example.org/repo.git/foo/bar"

denotes the foo/bar directory of the Git repository at
example.com/repo or repo.git.

When a version control system supports multiple protocols,
each is tried in turn when downloading.  For example, a Git
download tries git://, then https://, then http://.

New downloaded packages are written to the first directory
listed in the GOPATH environment variable (see 'go help gopath').

The go command attempts to download the version of the
package appropriate for the Go release being used.
Run 'go help install' for more.
---

                                                                                                                                                                                                                                         root/go1.4/src/cmd/go/signal.go                                                                     0100644 0000000 0000000 00000001174 12600426226 014626  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"os"
	"os/signal"
	"sync"
)

// interrupted is closed, if go process is interrupted.
var interrupted = make(chan struct{})

// processSignals setups signal handler.
func processSignals() {
	sig := make(chan os.Signal)
	signal.Notify(sig, signalsToIgnore...)
	go func() {
		<-sig
		close(interrupted)
	}()
}

var onceProcessSignals sync.Once

// startSigHandlers start signal handlers.
func startSigHandlers() {
	onceProcessSignals.Do(processSignals)
}
                                                                                                                                                                                                                                                                                                                                                                                                    root/go1.4/src/cmd/go/signal_notunix.go                                                             0100644 0000000 0000000 00000000601 12600426226 016404  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build plan9 windows

package main

import (
	"os"
)

var signalsToIgnore = []os.Signal{os.Interrupt}

// signalTrace is the signal to send to make a Go program
// crash with a stack trace.
var signalTrace os.Signal = nil
                                                                                                                               root/go1.4/src/cmd/go/signal_unix.go                                                                0100644 0000000 0000000 00000000726 12600426226 015673  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build darwin dragonfly freebsd linux nacl netbsd openbsd solaris

package main

import (
	"os"
	"syscall"
)

var signalsToIgnore = []os.Signal{os.Interrupt, syscall.SIGQUIT}

// signalTrace is the signal to send to make a Go program
// crash with a stack trace.
var signalTrace os.Signal = syscall.SIGQUIT
                                          root/go1.4/src/cmd/go/tag_test.go                                                                   0100644 0000000 0000000 00000004261 12600426226 015163  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import "testing"

var selectTagTestTags = []string{
	"go.r58",
	"go.r58.1",
	"go.r59",
	"go.r59.1",
	"go.r61",
	"go.r61.1",
	"go.weekly.2010-01-02",
	"go.weekly.2011-10-12",
	"go.weekly.2011-10-12.1",
	"go.weekly.2011-10-14",
	"go.weekly.2011-11-01",
	"go1",
	"go1.0.1",
	"go1.999",
	"go1.9.2",
	"go5",

	// these should be ignored:
	"release.r59",
	"release.r59.1",
	"release",
	"weekly.2011-10-12",
	"weekly.2011-10-12.1",
	"weekly",
	"foo",
	"bar",
	"go.f00",
	"go!r60",
	"go.1999-01-01",
	"go.2x",
	"go.20000000000000",
	"go.2.",
	"go.2.0",
	"go2x",
	"go20000000000000",
	"go2.",
	"go2.0",
}

var selectTagTests = []struct {
	version  string
	selected string
}{
	/*
		{"release.r57", ""},
		{"release.r58.2", "go.r58.1"},
		{"release.r59", "go.r59"},
		{"release.r59.1", "go.r59.1"},
		{"release.r60", "go.r59.1"},
		{"release.r60.1", "go.r59.1"},
		{"release.r61", "go.r61"},
		{"release.r66", "go.r61.1"},
		{"weekly.2010-01-01", ""},
		{"weekly.2010-01-02", "go.weekly.2010-01-02"},
		{"weekly.2010-01-02.1", "go.weekly.2010-01-02"},
		{"weekly.2010-01-03", "go.weekly.2010-01-02"},
		{"weekly.2011-10-12", "go.weekly.2011-10-12"},
		{"weekly.2011-10-12.1", "go.weekly.2011-10-12.1"},
		{"weekly.2011-10-13", "go.weekly.2011-10-12.1"},
		{"weekly.2011-10-14", "go.weekly.2011-10-14"},
		{"weekly.2011-10-14.1", "go.weekly.2011-10-14"},
		{"weekly.2011-11-01", "go.weekly.2011-11-01"},
		{"weekly.2014-01-01", "go.weekly.2011-11-01"},
		{"weekly.3000-01-01", "go.weekly.2011-11-01"},
		{"go1", "go1"},
		{"go1.1", "go1.0.1"},
		{"go1.998", "go1.9.2"},
		{"go1.1000", "go1.999"},
		{"go6", "go5"},

		// faulty versions:
		{"release.f00", ""},
		{"weekly.1999-01-01", ""},
		{"junk", ""},
		{"", ""},
		{"go2x", ""},
		{"go200000000000", ""},
		{"go2.", ""},
		{"go2.0", ""},
	*/
	{"anything", "go1"},
}

func TestSelectTag(t *testing.T) {
	for _, c := range selectTagTests {
		selected := selectTag(c.version, selectTagTestTags)
		if selected != c.selected {
			t.Errorf("selectTag(%q) = %q, want %q", c.version, selected, c.selected)
		}
	}
}
                                                                                                                                                                                                                                                                                                                                               root/go1.4/src/cmd/go/test.bash                                                                     0100755 0000000 0000000 00000077140 12600426226 014651  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/bash
# Copyright 2012 The Go Authors.  All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

set -e
go build -tags testgo -o testgo
go() {
	echo TEST ERROR: ran go, not testgo: go "$@" >&2
	exit 2
}

started=false
testdesc=""
nl="
"
TEST() {
	if $started; then
		stop
	fi
	echo TEST: "$@"
	testdesc="$@"
	started=true
	ok=true
}
stop() {
	if ! $started; then
		echo TEST ERROR: stop missing start >&2
		exit 2
	fi
	started=false
	if $ok; then
		echo PASS
	else
		echo FAIL
		testfail="$testfail	$testdesc$nl"
		allok=false
	fi
}

ok=true
allok=true

unset GOBIN
unset GOPATH
unset GOROOT

TEST 'file:line in error messages'
# Test that error messages have file:line information at beginning of
# the line. Also test issue 4917: that the error is on stderr.
d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)
fn=$d/err.go
echo "package main" > $fn
echo 'import "bar"' >> $fn
./testgo run $fn 2>$d/err.out || true
if ! grep -q "^$fn:" $d/err.out; then
	echo "missing file:line in error message"
	cat $d/err.out
	ok=false
fi
rm -r $d

TEST 'program name in crash messages'
linker=$(./testgo env GOCHAR)l
d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)
./testgo build -ldflags -crash_for_testing $(./testgo env GOROOT)/test/helloworld.go 2>$d/err.out || true
if ! grep -q "/tool/.*/$linker" $d/err.out; then
	echo "missing linker name in error message"
	cat $d/err.out
	ok=false
fi
rm -r $d

TEST broken tests without Test functions all fail
d=$(mktemp -d -t testgoXXX)
./testgo test ./testdata/src/badtest/... >$d/err 2>&1 || true
if grep -q '^ok' $d/err; then
	echo test passed unexpectedly:
	grep '^ok' $d/err
	ok=false
elif ! grep -q 'FAIL.*badtest/badexec' $d/err || ! grep -q 'FAIL.*badtest/badsyntax' $d/err || ! grep -q 'FAIL.*badtest/badvar' $d/err; then
	echo test did not run everything
	cat $d/err
	ok=false
fi
rm -rf $d

TEST 'go build -a in dev branch'
./testgo install math || ok=false # should be up to date already but just in case
d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)
if ! TESTGO_IS_GO_RELEASE=0 ./testgo build -v -a math 2>$d/err.out; then
	cat $d/err.out
	ok=false
elif ! grep -q runtime $d/err.out; then
	echo "testgo build -a math in dev branch DID NOT build runtime, but should have"
	cat $d/err.out
	ok=false
fi
rm -r $d

TEST 'go build -a in release branch'
./testgo install math || ok=false # should be up to date already but just in case
d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)
if ! TESTGO_IS_GO_RELEASE=1 ./testgo build -v -a math 2>$d/err.out; then
	cat $d/err.out
	ok=false
elif grep -q runtime $d/err.out; then
	echo "testgo build -a math in dev branch DID build runtime, but should NOT have"
	cat $d/err.out
	ok=false
fi
rm -r $d

# Test local (./) imports.
testlocal() {
	local="$1"
	TEST local imports $2 '(easy)'
	./testgo build -o hello "testdata/$local/easy.go" || ok=false
	./hello >hello.out || ok=false
	if ! grep -q '^easysub\.Hello' hello.out; then
		echo "testdata/$local/easy.go did not generate expected output"
		cat hello.out
		ok=false
	fi
	
	TEST local imports $2 '(easysub)'
	./testgo build -o hello "testdata/$local/easysub/main.go" || ok=false
	./hello >hello.out || ok=false
	if ! grep -q '^easysub\.Hello' hello.out; then
		echo "testdata/$local/easysub/main.go did not generate expected output"
		cat hello.out
		ok=false
	fi
	
	TEST local imports $2 '(hard)'
	./testgo build -o hello "testdata/$local/hard.go" || ok=false
	./hello >hello.out || ok=false
	if ! grep -q '^sub\.Hello' hello.out || ! grep -q '^subsub\.Hello' hello.out ; then
		echo "testdata/$local/hard.go did not generate expected output"
		cat hello.out
		ok=false
	fi
	
	rm -f hello.out hello
	
	# Test that go install x.go fails.
	TEST local imports $2 '(go install should fail)'
	if ./testgo install "testdata/$local/easy.go" >/dev/null 2>&1; then
		echo "go install testdata/$local/easy.go succeeded"
		ok=false
	fi
}

# Test local imports
testlocal local ''

# Test local imports again, with bad characters in the directory name.
bad='#$%:, &()*;<=>?\^{}'
rm -rf "testdata/$bad"
cp -R testdata/local "testdata/$bad"
testlocal "$bad" 'with bad characters in path'
rm -rf "testdata/$bad"

TEST 'internal packages in $GOROOT are respected'
if ./testgo build -v ./testdata/testinternal >testdata/std.out 2>&1; then
	echo "go build ./testdata/testinternal succeeded incorrectly"
	ok=false
elif ! grep 'use of internal package not allowed' testdata/std.out >/dev/null; then
	echo "wrong error message for testdata/testinternal"
	cat std.out
	ok=false
fi

TEST 'internal packages outside $GOROOT are not respected'
if ! ./testgo build -v ./testdata/testinternal2; then
	echo "go build ./testdata/testinternal2 failed"
	ok=false
fi

# Test that 'go get -u' reports moved packages.
testmove() {
	vcs=$1
	url=$2
	base=$3
	config=$4

	TEST go get -u notices $vcs package that moved
	d=$(mktemp -d -t testgoXXX)
	mkdir -p $d/src
	if ! GOPATH=$d ./testgo get -d $url; then
		echo 'go get -d $url failed'
		ok=false
	elif ! GOPATH=$d ./testgo get -d -u $url; then
		echo 'go get -d -u $url failed'
		ok=false
	else
		set +e
		case "$vcs" in
		svn)
			# SVN doesn't believe in text files so we can't just edit the config.
			# Check out a different repo into the wrong place.
			rm -rf $d/src/code.google.com/p/rsc-svn
			GOPATH=$d ./testgo get -d -u code.google.com/p/rsc-svn2/trunk
			mv $d/src/code.google.com/p/rsc-svn2 $d/src/code.google.com/p/rsc-svn
			;;
		*)
			echo '1,$s;'"$base"';'"$base"'XXX;
w
q' | ed $d/src/$config >/dev/null 2>&1
		esac
		set -e

		if GOPATH=$d ./testgo get -d -u $url 2>$d/err; then
			echo "go get -d -u $url succeeded with wrong remote repo"
			cat $d/err
			ok=false
		elif ! grep 'should be from' $d/err >/dev/null; then
			echo "go get -d -u $url failed for wrong reason"
			cat $d/err
			ok=false
		fi
		
		if GOPATH=$d ./testgo get -d -f -u $url 2>$d/err; then
			echo "go get -d -u $url succeeded with wrong remote repo"
			cat $d/err
			ok=false
		elif ! egrep -i 'validating server certificate|not found' $d/err >/dev/null; then
			echo "go get -d -f -u $url failed for wrong reason"
			cat $d/err
			ok=false
		fi
	fi
	rm -rf $d
}

testmove hg rsc.io/x86/x86asm x86 rsc.io/x86/.hg/hgrc
testmove git rsc.io/pdf pdf rsc.io/pdf/.git/config
testmove svn code.google.com/p/rsc-svn/trunk - -

export GOPATH=$(pwd)/testdata/importcom
TEST 'import comment - match'
if ! ./testgo build ./testdata/importcom/works.go; then
	echo 'go build ./testdata/importcom/works.go failed'
	ok=false
fi
TEST 'import comment - mismatch'
if ./testgo build ./testdata/importcom/wrongplace.go 2>testdata/err; then
	echo 'go build ./testdata/importcom/wrongplace.go suceeded'
	ok=false
elif ! grep 'wrongplace expects import "my/x"' testdata/err >/dev/null; then
	echo 'go build did not mention incorrect import:'
	cat testdata/err
	ok=false
fi
TEST 'import comment - syntax error'
if ./testgo build ./testdata/importcom/bad.go 2>testdata/err; then
	echo 'go build ./testdata/importcom/bad.go suceeded'
	ok=false
elif ! grep 'cannot parse import comment' testdata/err >/dev/null; then
	echo 'go build did not mention syntax error:'
	cat testdata/err
	ok=false
fi
TEST 'import comment - conflict'
if ./testgo build ./testdata/importcom/conflict.go 2>testdata/err; then
	echo 'go build ./testdata/importcom/conflict.go suceeded'
	ok=false
elif ! grep 'found import comments' testdata/err >/dev/null; then
	echo 'go build did not mention comment conflict:'
	cat testdata/err
	ok=false
fi
rm -f ./testdata/err
unset GOPATH

export GOPATH=$(pwd)/testdata/src
TEST disallowed C source files
export GOPATH=$(pwd)/testdata
if ./testgo build badc 2>testdata/err; then
	echo 'go build badc succeeded'
	ok=false
elif ! grep 'C source files not allowed' testdata/err >/dev/null; then
	echo 'go test did not say C source files not allowed:'
	cat testdata/err
	ok=false
fi
rm -f ./testdata/err
unset GOPATH

TEST error message for syntax error in test go file says FAIL
export GOPATH=$(pwd)/testdata
if ./testgo test syntaxerror 2>testdata/err; then
	echo 'go test syntaxerror succeeded'
	ok=false
elif ! grep FAIL testdata/err >/dev/null; then
	echo 'go test did not say FAIL:'
	cat testdata/err
	ok=false
fi
rm -f ./testdata/err
unset GOPATH

TEST wildcards do not look in useless directories
export GOPATH=$(pwd)/testdata
if ./testgo list ... >testdata/err 2>&1; then
	echo "go list ... succeeded"
	ok=false
elif ! grep badpkg testdata/err >/dev/null; then
	echo "go list ... failure does not mention badpkg"
	cat testdata/err
	ok=false
elif ! ./testgo list m... >testdata/err 2>&1; then
	echo "go list m... failed"
	ok=false
fi
rm -rf ./testdata/err
unset GOPATH

# Test tests with relative imports.
TEST relative imports '(go test)'
if ! ./testgo test ./testdata/testimport; then
	echo "go test ./testdata/testimport failed"
	ok=false
fi

# Test installation with relative imports.
TEST relative imports '(go test -i)'
if ! ./testgo test -i ./testdata/testimport; then
    echo "go test -i ./testdata/testimport failed"
    ok=false
fi

# Test tests with relative imports in packages synthesized
# from Go files named on the command line.
TEST relative imports in command-line package
if ! ./testgo test ./testdata/testimport/*.go; then
	echo "go test ./testdata/testimport/*.go failed"
	ok=false
fi

TEST version control error message includes correct directory
export GOPATH=$(pwd)/testdata/shadow/root1
if ./testgo get -u foo 2>testdata/err; then
	echo "go get -u foo succeeded unexpectedly"
	ok=false
elif ! grep testdata/shadow/root1/src/foo testdata/err >/dev/null; then
	echo "go get -u error does not mention shadow/root1/src/foo:"
	cat testdata/err
	ok=false
fi
unset GOPATH

TEST go install fails with no buildable files
export GOPATH=$(pwd)/testdata
export CGO_ENABLED=0
if ./testgo install cgotest 2>testdata/err; then
	echo "go install cgotest succeeded unexpectedly"
elif ! grep 'no buildable Go source files' testdata/err >/dev/null; then
	echo "go install cgotest did not report 'no buildable Go source files'"
	cat testdata/err
	ok=false
fi
unset CGO_ENABLED
unset GOPATH

# Test that without $GOBIN set, binaries get installed
# into the GOPATH bin directory.
TEST install into GOPATH
rm -rf testdata/bin
if ! GOPATH=$(pwd)/testdata ./testgo install go-cmd-test; then
	echo "go install go-cmd-test failed"
	ok=false
elif ! test -x testdata/bin/go-cmd-test; then
	echo "go install go-cmd-test did not write to testdata/bin/go-cmd-test"
	ok=false
fi

TEST package main_test imports archive not binary
export GOBIN=$(pwd)/testdata/bin
mkdir -p $GOBIN
export GOPATH=$(pwd)/testdata
touch ./testdata/src/main_test/m.go
if ! ./testgo test main_test; then
	echo "go test main_test failed without install"
	ok=false
elif ! ./testgo install main_test; then
	echo "go test main_test failed"
	ok=false
elif [ "$(./testgo list -f '{{.Stale}}' main_test)" != false ]; then
	echo "after go install, main listed as stale"
	ok=false
elif ! ./testgo test main_test; then
	echo "go test main_test failed after install"
	ok=false
fi
rm -rf $GOBIN
unset GOBIN

# And with $GOBIN set, binaries get installed to $GOBIN.
TEST install into GOBIN
if ! GOBIN=$(pwd)/testdata/bin1 GOPATH=$(pwd)/testdata ./testgo install go-cmd-test; then
	echo "go install go-cmd-test failed"
	ok=false
elif ! test -x testdata/bin1/go-cmd-test; then
	echo "go install go-cmd-test did not write to testdata/bin1/go-cmd-test"
	ok=false
fi

# Without $GOBIN set, installing a program outside $GOPATH should fail
# (there is nowhere to install it).
TEST install without destination fails
if ./testgo install testdata/src/go-cmd-test/helloworld.go 2>testdata/err; then
	echo "go install testdata/src/go-cmd-test/helloworld.go should have failed, did not"
	ok=false
elif ! grep 'no install location for .go files listed on command line' testdata/err; then
	echo "wrong error:"
	cat testdata/err
	ok=false
fi
rm -f testdata/err

# With $GOBIN set, should install there.
TEST install to GOBIN '(command-line package)'
if ! GOBIN=$(pwd)/testdata/bin1 ./testgo install testdata/src/go-cmd-test/helloworld.go; then
	echo "go install testdata/src/go-cmd-test/helloworld.go failed"
	ok=false
elif ! test -x testdata/bin1/helloworld; then
	echo "go install testdata/src/go-cmd-test/helloworld.go did not write testdata/bin1/helloworld"
	ok=false
fi

TEST godoc installs into GOBIN
d=$(mktemp -d -t testgoXXX)
export GOPATH=$d
mkdir $d/gobin
GOBIN=$d/gobin ./testgo get golang.org/x/tools/cmd/godoc || ok=false
if [ ! -x $d/gobin/godoc ]; then
	echo did not install godoc to '$GOBIN'
	GOBIN=$d/gobin ./testgo list -f 'Target: {{.Target}}' golang.org/x/tools/cmd/godoc || true
	ok=false
fi

TEST godoc installs into GOROOT
GOROOT=$(./testgo env GOROOT)
rm -f $GOROOT/bin/godoc
./testgo install golang.org/x/tools/cmd/godoc || ok=false
if [ ! -x $GOROOT/bin/godoc ]; then
	echo did not install godoc to '$GOROOT/bin'
	./testgo list -f 'Target: {{.Target}}' golang.org/x/tools/cmd/godoc || true
	ok=false
fi

TEST cmd/fix installs into tool
GOOS=$(./testgo env GOOS)
GOARCH=$(./testgo env GOARCH)
rm -f $GOROOT/pkg/tool/${GOOS}_${GOARCH}/fix
./testgo install cmd/fix || ok=false
if [ ! -x $GOROOT/pkg/tool/${GOOS}_${GOARCH}/fix ]; then
	echo 'did not install cmd/fix to $GOROOT/pkg/tool'
	GOBIN=$d/gobin ./testgo list -f 'Target: {{.Target}}' cmd/fix || true
	ok=false
fi
rm -f $GOROOT/pkg/tool/${GOOS}_${GOARCH}/fix
GOBIN=$d/gobin ./testgo install cmd/fix || ok=false
if [ ! -x $GOROOT/pkg/tool/${GOOS}_${GOARCH}/fix ]; then
	echo 'did not install cmd/fix to $GOROOT/pkg/tool with $GOBIN set'
	GOBIN=$d/gobin ./testgo list -f 'Target: {{.Target}}' cmd/fix || true
	ok=false
fi

TEST gopath program installs into GOBIN
mkdir $d/src/progname
echo 'package main; func main() {}' >$d/src/progname/p.go
GOBIN=$d/gobin ./testgo install progname || ok=false
if [ ! -x $d/gobin/progname ]; then
	echo 'did not install progname to $GOBIN/progname'
	./testgo list -f 'Target: {{.Target}}' cmd/api || true
	ok=false
fi
rm -f $d/gobin/progname $d/bin/progname

TEST gopath program installs into GOPATH/bin
./testgo install progname || ok=false
if [ ! -x $d/bin/progname ]; then
	echo 'did not install progname to $GOPATH/bin/progname'
	./testgo list -f 'Target: {{.Target}}' progname || true
	ok=false
fi

unset GOPATH
rm -rf $d

# Reject relative paths in GOPATH.
TEST reject relative paths in GOPATH '(command-line package)'
if GOPATH=. ./testgo build testdata/src/go-cmd-test/helloworld.go; then
    echo 'GOPATH="." go build should have failed, did not'
    ok=false
fi

TEST reject relative paths in GOPATH 
if GOPATH=:$(pwd)/testdata:. ./testgo build go-cmd-test; then
    echo 'GOPATH=":$(pwd)/testdata:." go build should have failed, did not'
    ok=false
fi

# issue 4104
TEST go test with package listed multiple times
if [ $(./testgo test fmt fmt fmt fmt fmt | wc -l) -ne 1 ] ; then
    echo 'go test fmt fmt fmt fmt fmt tested the same package multiple times'
    ok=false
fi

# ensure that output of 'go list' is consistent between runs
TEST go list is consistent
./testgo list std > test_std.list || ok=false
if ! ./testgo list std | cmp -s test_std.list - ; then
	echo "go list std ordering is inconsistent"
	ok=false
fi
rm -f test_std.list

# issue 4096. Validate the output of unsuccessful go install foo/quxx 
TEST unsuccessful go install should mention missing package
if [ $(./testgo install 'foo/quxx' 2>&1 | grep -c 'cannot find package "foo/quxx" in any of') -ne 1 ] ; then
	echo 'go install foo/quxx expected error: .*cannot find package "foo/quxx" in any of'
	ok=false
fi 
# test GOROOT search failure is reported
TEST GOROOT search failure reporting
if [ $(./testgo install 'foo/quxx' 2>&1 | egrep -c 'foo/quxx \(from \$GOROOT\)$') -ne 1 ] ; then
        echo 'go install foo/quxx expected error: .*foo/quxx (from $GOROOT)'
        ok=false
fi
# test multiple GOPATH entries are reported separately
TEST multiple GOPATH entries reported separately
if [ $(GOPATH=$(pwd)/testdata/a:$(pwd)/testdata/b ./testgo install 'foo/quxx' 2>&1 | egrep -c 'testdata/./src/foo/quxx') -ne 2 ] ; then
        echo 'go install foo/quxx expected error: .*testdata/a/src/foo/quxx (from $GOPATH)\n.*testdata/b/src/foo/quxx'
        ok=false
fi
# test (from $GOPATH) annotation is reported for the first GOPATH entry
TEST mention GOPATH in first GOPATH entry
if [ $(GOPATH=$(pwd)/testdata/a:$(pwd)/testdata/b ./testgo install 'foo/quxx' 2>&1 | egrep -c 'testdata/a/src/foo/quxx \(from \$GOPATH\)$') -ne 1 ] ; then
        echo 'go install foo/quxx expected error: .*testdata/a/src/foo/quxx (from $GOPATH)'
        ok=false
fi
# but not on the second
TEST but not the second entry
if [ $(GOPATH=$(pwd)/testdata/a:$(pwd)/testdata/b ./testgo install 'foo/quxx' 2>&1 | egrep -c 'testdata/b/src/foo/quxx$') -ne 1 ] ; then
        echo 'go install foo/quxx expected error: .*testdata/b/src/foo/quxx'
        ok=false
fi
# test missing GOPATH is reported
TEST missing GOPATH is reported
if [ $(GOPATH= ./testgo install 'foo/quxx' 2>&1 | egrep -c '\(\$GOPATH not set\)$') -ne 1 ] ; then
        echo 'go install foo/quxx expected error: ($GOPATH not set)'
        ok=false
fi

# issue 4186. go get cannot be used to download packages to $GOROOT
# Test that without GOPATH set, go get should fail
TEST without GOPATH, go get fails
d=$(mktemp -d -t testgoXXX)
mkdir -p $d/src
if GOPATH= GOROOT=$d ./testgo get -d golang.org/x/codereview/cmd/hgpatch ; then 
	echo 'go get golang.org/x/codereview/cmd/hgpatch should not succeed with $GOPATH unset'
	ok=false
fi	
rm -rf $d

# Test that with GOPATH=$GOROOT, go get should fail
TEST with GOPATH=GOROOT, go get fails
d=$(mktemp -d -t testgoXXX)
mkdir -p $d/src
if GOPATH=$d GOROOT=$d ./testgo get -d golang.org/x/codereview/cmd/hgpatch ; then
        echo 'go get golang.org/x/codereview/cmd/hgpatch should not succeed with GOPATH=$GOROOT'
        ok=false
fi
rm -rf $d

TEST ldflags arguments with spaces '(issue 3941)'
d=$(mktemp -d -t testgoXXX)
cat >$d/main.go<<EOF
package main
var extern string
func main() {
	println(extern)
}
EOF
./testgo run -ldflags '-X main.extern "hello world"' $d/main.go 2>hello.out || ok=false
if ! grep -q '^hello world' hello.out; then
	echo "ldflags -X main.extern 'hello world' failed. Output:"
	cat hello.out
	ok=false
fi
rm -rf $d hello.out

TEST go test -cpuprofile leaves binary behind
./testgo test -cpuprofile strings.prof strings || ok=false
if [ ! -x strings.test ]; then
	echo "go test -cpuprofile did not create strings.test"
	ok=false
fi
rm -f strings.prof strings.test

TEST go test -cpuprofile -o controls binary location
./testgo test -cpuprofile strings.prof -o mystrings.test strings || ok=false
if [ ! -x mystrings.test ]; then
	echo "go test -cpuprofile -o mystrings.test did not create mystrings.test"
	ok=false
fi
rm -f strings.prof mystrings.test

TEST go test -c -o controls binary location
./testgo test -c -o mystrings.test strings || ok=false
if [ ! -x mystrings.test ]; then
	echo "go test -c -o mystrings.test did not create mystrings.test"
	ok=false
fi
rm -f mystrings.test

TEST go test -o writes binary
./testgo test -o mystrings.test strings || ok=false
if [ ! -x mystrings.test ]; then
	echo "go test -o mystrings.test did not create mystrings.test"
	ok=false
fi
rm -f mystrings.test

TEST symlinks do not confuse go list '(issue 4568)'
old=$(pwd)
tmp=$(cd /tmp && pwd -P)
d=$(TMPDIR=$tmp mktemp -d -t testgoXXX)
mkdir -p $d/src
(
	ln -s $d $d/src/dir1
	cd $d/src
	echo package p >dir1/p.go
	export GOPATH=$d
	if [ "$($old/testgo list -f '{{.Root}}' dir1)" != "$d" ]; then
		echo Confused by symlinks.
		echo "Package in current directory $(pwd) should have Root $d"
		env|grep WD
		$old/testgo list -json . dir1
		touch $d/failed
	fi		
)
if [ -f $d/failed ]; then
	ok=false
fi
rm -rf $d

TEST 'install with tags (issue 4515)'
d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)
mkdir -p $d/src/example/a $d/src/example/b $d/bin
cat >$d/src/example/a/main.go <<EOF
package main
func main() {}
EOF
cat >$d/src/example/b/main.go <<EOF
// +build mytag

package main
func main() {}
EOF
GOPATH=$d ./testgo install -tags mytag example/a example/b || ok=false
if [ ! -x $d/bin/a -o ! -x $d/bin/b ]; then
	echo go install example/a example/b did not install binaries
	ok=false
fi
rm -f $d/bin/*
GOPATH=$d ./testgo install -tags mytag example/... || ok=false
if [ ! -x $d/bin/a -o ! -x $d/bin/b ]; then
	echo go install example/... did not install binaries
	ok=false
fi
rm -f $d/bin/*go
export GOPATH=$d
if [ "$(./testgo list -tags mytag example/b...)" != "example/b" ]; then
	echo go list example/b did not find example/b
	ok=false
fi
unset GOPATH
rm -rf $d

TEST case collisions '(issue 4773)'
d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)
export GOPATH=$d
mkdir -p $d/src/example/{a/pkg,a/Pkg,b}
cat >$d/src/example/a/a.go <<EOF
package p
import (
	_ "example/a/pkg"
	_ "example/a/Pkg"
)
EOF
cat >$d/src/example/a/pkg/pkg.go <<EOF
package pkg
EOF
cat >$d/src/example/a/Pkg/pkg.go <<EOF
package pkg
EOF
if ./testgo list example/a 2>$d/out; then
	echo go list example/a should have failed, did not.
	ok=false
elif ! grep "case-insensitive import collision" $d/out >/dev/null; then
	echo go list example/a did not report import collision.
	ok=false
fi
cat >$d/src/example/b/file.go <<EOF
package b
EOF
cat >$d/src/example/b/FILE.go <<EOF
package b
EOF
if [ $(ls $d/src/example/b | wc -l) = 2 ]; then
	# case-sensitive file system, let directory read find both files
	args="example/b"
else
	# case-insensitive file system, list files explicitly on command line.
	args="$d/src/example/b/file.go $d/src/example/b/FILE.go"
fi
if ./testgo list $args 2>$d/out; then
	echo go list example/b should have failed, did not.
	ok=false
elif ! grep "case-insensitive file name collision" $d/out >/dev/null; then
	echo go list example/b did not report file name collision.
	ok=false
fi

TEST go get cover
./testgo get golang.org/x/tools/cmd/cover || ok=false

unset GOPATH
rm -rf $d

TEST go get -t "code.google.com/p/go-get-issue-8181/{a,b}"
d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)
export GOPATH=$d
if ./testgo get -t code.google.com/p/go-get-issue-8181/{a,b}; then
	./testgo list ... | grep go.tools/godoc > /dev/null || ok=false
else
	ok=false
fi
unset GOPATH
rm -rf $d

TEST shadowing logic
export GOPATH=$(pwd)/testdata/shadow/root1:$(pwd)/testdata/shadow/root2

# The math in root1 is not "math" because the standard math is.
set +e
cdir=$(./testgo list -f '({{.ImportPath}}) ({{.ConflictDir}})' ./testdata/shadow/root1/src/math)
set -e
if [ "$cdir" != "(_$(pwd)/testdata/shadow/root1/src/math) ($GOROOT/src/math)" ]; then
	echo shadowed math is not shadowed: "$cdir"
	ok=false
fi

# The foo in root1 is "foo".
set +e
cdir=$(./testgo list -f '({{.ImportPath}}) ({{.ConflictDir}})' ./testdata/shadow/root1/src/foo)
set -e
if [ "$cdir" != "(foo) ()" ]; then
	echo unshadowed foo is shadowed: "$cdir"
	ok=false
fi

# The foo in root2 is not "foo" because the foo in root1 got there first.
set +e
cdir=$(./testgo list -f '({{.ImportPath}}) ({{.ConflictDir}})' ./testdata/shadow/root2/src/foo)
set -e
if [ "$cdir" != "(_$(pwd)/testdata/shadow/root2/src/foo) ($(pwd)/testdata/shadow/root1/src/foo)" ]; then
	echo shadowed foo is not shadowed: "$cdir"
	ok=false
fi

# The error for go install should mention the conflicting directory.
set +e
err=$(./testgo install ./testdata/shadow/root2/src/foo 2>&1)
set -e
if [ "$err" != "go install: no install location for $(pwd)/testdata/shadow/root2/src/foo: hidden by $(pwd)/testdata/shadow/root1/src/foo" ]; then
	echo wrong shadowed install error: "$err"
	ok=false
fi

# Only succeeds if source order is preserved.
TEST source file name order preserved
./testgo test testdata/example[12]_test.go || ok=false

# Check that coverage analysis works at all.
# Don't worry about the exact numbers but require not 0.0%.
checkcoverage() {
	if grep '[^0-9]0\.0%' testdata/cover.txt >/dev/null; then
		echo 'some coverage results are 0.0%'
		ok=false
	fi
	cat testdata/cover.txt
	rm -f testdata/cover.txt
}
	
TEST coverage runs
./testgo test -short -coverpkg=strings strings regexp >testdata/cover.txt 2>&1 || ok=false
./testgo test -short -cover strings math regexp >>testdata/cover.txt 2>&1 || ok=false
checkcoverage

# Check that coverage analysis uses set mode.
TEST coverage uses set mode
if ./testgo test -short -cover encoding/binary -coverprofile=testdata/cover.out >testdata/cover.txt 2>&1; then
	if ! grep -q 'mode: set' testdata/cover.out; then
		ok=false
	fi
	checkcoverage
else
	ok=false
fi
rm -f testdata/cover.out testdata/cover.txt

TEST coverage uses atomic mode for -race.
if ./testgo test -short -race -cover encoding/binary -coverprofile=testdata/cover.out >testdata/cover.txt 2>&1; then
	if ! grep -q 'mode: atomic' testdata/cover.out; then
		ok=false
	fi
	checkcoverage
else
	ok=false
fi
rm -f testdata/cover.out

TEST coverage uses actual setting to override even for -race.
if ./testgo test -short -race -cover encoding/binary -covermode=count -coverprofile=testdata/cover.out >testdata/cover.txt 2>&1; then
	if ! grep -q 'mode: count' testdata/cover.out; then
		ok=false
	fi
	checkcoverage
else
	ok=false
fi
rm -f testdata/cover.out

TEST coverage with cgo
d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)
./testgo test -short -cover ./testdata/cgocover >testdata/cover.txt 2>&1 || ok=false
checkcoverage

TEST cgo depends on syscall
rm -rf $GOROOT/pkg/*_race
d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)
export GOPATH=$d
mkdir -p $d/src/foo
echo '
package foo
//#include <stdio.h>
import "C"
' >$d/src/foo/foo.go
./testgo build -race foo || ok=false
rm -rf $d
unset GOPATH

TEST cgo shows full path names
d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)
export GOPATH=$d
mkdir -p $d/src/x/y/dirname
echo '
package foo
import "C"
func f() {
' >$d/src/x/y/dirname/foo.go
if ./testgo build x/y/dirname >$d/err 2>&1; then
	echo build succeeded unexpectedly.
	ok=false
elif ! grep x/y/dirname $d/err >/dev/null; then
	echo error did not use full path.
	cat $d/err
	ok=false
fi
rm -rf $d
unset GOPATH

TEST 'cgo handles -Wl,$ORIGIN'
d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)
export GOPATH=$d
mkdir -p $d/src/origin
echo '
package origin
// #cgo !darwin LDFLAGS: -Wl,-rpath -Wl,$ORIGIN
// void f(void) {}
import "C"

func f() { C.f() }
' >$d/src/origin/origin.go
if ! ./testgo build origin; then
	echo build failed
	ok=false
fi
rm -rf $d
unset GOPATH

TEST 'Issue 6480: "go test -c -test.bench=XXX fmt" should not hang'
if ! ./testgo test -c -test.bench=XXX fmt; then
	echo build test failed
	ok=false
fi
rm -f fmt.test

TEST 'Issue 7573: cmd/cgo: undefined reference when linking a C-library using gccgo'
d=$(mktemp -d -t testgoXXX)
export GOPATH=$d
mkdir -p $d/src/cgoref
ldflags="-L alibpath -lalib"
echo "
package main
// #cgo LDFLAGS: $ldflags
// void f(void) {}
import \"C\"

func main() { C.f() }
" >$d/src/cgoref/cgoref.go
go_cmds="$(./testgo build -n -compiler gccgo cgoref 2>&1 1>/dev/null)"
ldflags_count="$(echo "$go_cmds" | egrep -c "^gccgo.*$(echo $ldflags | sed -e 's/-/\\-/g')" || true)"
if [ "$ldflags_count" -lt 1 ]; then
	echo "No Go-inline "#cgo LDFLAGS:" (\"$ldflags\") passed to gccgo linking stage."
	ok=false
fi
rm -rf $d
unset ldflags_count
unset go_cmds
unset ldflags
unset GOPATH

TEST list template can use context function
if ! ./testgo list -f "GOARCH: {{context.GOARCH}}"; then 
	echo unable to use context in list template
	ok=false
fi

TEST 'Issue 7108: cmd/go: "go test" should fail if package does not build'
export GOPATH=$(pwd)/testdata
if ./testgo test notest >/dev/null 2>&1; then
	echo 'go test notest succeeded, but should fail'
	ok=false
fi
unset GOPATH

TEST 'Issue 6844: cmd/go: go test -a foo does not rebuild regexp'
if ! ./testgo test -x -a -c testdata/dep_test.go 2>deplist; then
	echo "go test -x -a -c testdata/dep_test.go failed"
	ok=false
elif ! grep -q regexp deplist; then
	echo "go test -x -a -c testdata/dep_test.go did not rebuild regexp"
	ok=false
fi
rm -f deplist
rm -f deps.test

TEST list template can use context function
if ! ./testgo list -f "GOARCH: {{context.GOARCH}}"; then 
	echo unable to use context in list template
	ok=false
fi

TEST build -i installs dependencies
d=$(TMPDIR=/var/tmp mktemp -d -t testgoXXX)
export GOPATH=$d
mkdir -p $d/src/x/y/foo $d/src/x/y/bar
echo '
package foo
func F() {}
' >$d/src/x/y/foo/foo.go
checkbar() {
	desc="$1"
	sleep 1
	touch $d/src/x/y/foo/foo.go
	if ! ./testgo build -v -i x/y/bar &> $d/err; then
		echo build -i "$1" failed
		cat $d/err
		ok=false
	elif ! grep x/y/foo $d/err >/dev/null; then
		echo first build -i "$1" did not build x/y/foo
		cat $d/err
		ok=false
	fi
	if ! ./testgo build -v -i x/y/bar &> $d/err; then
		echo second build -i "$1" failed
		cat $d/err
		ok=false
	elif grep x/y/foo $d/err >/dev/null; then
		echo second build -i "$1" built x/y/foo
		cat $d/err
		ok=false
	fi
}

echo '
package bar
import "x/y/foo"
func F() { foo.F() }
' >$d/src/x/y/bar/bar.go
checkbar pkg

TEST build -i installs dependencies for command
echo '
package main
import "x/y/foo"
func main() { foo.F() }
' >$d/src/x/y/bar/bar.go
checkbar cmd

rm -rf $d bar
unset GOPATH

TEST 'go build in test-only directory fails with a good error'
if ./testgo build ./testdata/testonly 2>testdata/err.out; then
	echo "go build ./testdata/testonly succeeded, should have failed"
	ok=false
elif ! grep 'no buildable Go' testdata/err.out >/dev/null; then
	echo "go build ./testdata/testonly produced unexpected error:"
	cat testdata/err.out
	ok=false
fi
rm -f testdata/err.out

TEST 'go test detects test-only import cycles'
export GOPATH=$(pwd)/testdata
if ./testgo test -c testcycle/p3 2>testdata/err.out; then
	echo "go test testcycle/p3 succeeded, should have failed"
	ok=false
elif ! grep 'import cycle not allowed in test' testdata/err.out >/dev/null; then
	echo "go test testcycle/p3 produced unexpected error:"
	cat testdata/err.out
	ok=false
fi
rm -f testdata/err.out
unset GOPATH

TEST 'go test foo_test.go works'
if ! ./testgo test testdata/standalone_test.go; then
	echo "go test testdata/standalone_test.go failed"
	ok=false
fi

TEST 'go test xtestonly works'
export GOPATH=$(pwd)/testdata
./testgo clean -i xtestonly || ok=false
if ! ./testgo test xtestonly >/dev/null; then
	echo "go test xtestonly failed"
	ok=false
fi
unset GOPATH

TEST 'go test builds an xtest containing only non-runnable examples'
if ! ./testgo test -v ./testdata/norunexample > testdata/std.out; then
	echo "go test ./testdata/norunexample failed"
	ok=false
elif ! grep 'File with non-runnable example was built.' testdata/std.out > /dev/null; then
	echo "file with non-runnable example was not built"
	ok=false
fi

TEST 'go generate handles simple command'
if ! ./testgo generate ./testdata/generate/test1.go > testdata/std.out; then
	echo "go test ./testdata/generate/test1.go failed to run"
	ok=false
elif ! grep 'Success' testdata/std.out > /dev/null; then
	echo "go test ./testdata/generate/test1.go generated wrong output"
	ok=false
fi

TEST 'go generate handles command alias'
if ! ./testgo generate ./testdata/generate/test2.go > testdata/std.out; then
	echo "go test ./testdata/generate/test2.go failed to run"
	ok=false
elif ! grep 'Now is the time for all good men' testdata/std.out > /dev/null; then
	echo "go test ./testdata/generate/test2.go generated wrong output"
	ok=false
fi

TEST 'go generate variable substitution'
if ! ./testgo generate ./testdata/generate/test3.go > testdata/std.out; then
	echo "go test ./testdata/generate/test3.go failed to run"
	ok=false
elif ! grep "$GOARCH test3.go p xyzp/test3.go/123" testdata/std.out > /dev/null; then
	echo "go test ./testdata/generate/test3.go generated wrong output"
	ok=false
fi

TEST go get works with vanity wildcards
d=$(mktemp -d -t testgoXXX)
export GOPATH=$d
if ! ./testgo get -u rsc.io/pdf/...; then
	ok=false
elif [ ! -x $d/bin/pdfpasswd ]; then
	echo did not build rsc.io/pdf/pdfpasswd
	ok=false
fi
unset GOPATH
rm -rf $d

TEST go vet with external tests
d=$(mktemp -d -t testgoXXX)
export GOPATH=$(pwd)/testdata
if ./testgo vet vetpkg >$d/err 2>&1; then
	echo "go vet vetpkg passes incorrectly"
	ok=false
elif ! grep -q 'missing argument for Printf' $d/err; then
	echo "go vet vetpkg did not find missing argument for Printf"
	cat $d/err
	ok=false
fi
unset GOPATH
rm -rf $d

# clean up
if $started; then stop; fi
rm -rf testdata/bin testdata/bin1
rm -f testgo

if $allok; then
	echo PASS
else
	echo FAIL:
	echo "$testfail"
	exit 1
fi
                                                                                                                                                                                                                                                                                                                                                                                                                                root/go1.4/src/cmd/go/test.go                                                                       0100644 0000000 0000000 00000115764 12600426226 014343  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/build"
	"go/doc"
	"go/parser"
	"go/token"
	"log"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"regexp"
	"runtime"
	"sort"
	"strings"
	"text/template"
	"time"
	"unicode"
	"unicode/utf8"
)

// Break init loop.
func init() {
	cmdTest.Run = runTest
}

var cmdTest = &Command{
	CustomFlags: true,
	UsageLine:   "test [-c] [-i] [build and test flags] [packages] [flags for test binary]",
	Short:       "test packages",
	Long: `
'Go test' automates testing the packages named by the import paths.
It prints a summary of the test results in the format:

	ok   archive/tar   0.011s
	FAIL archive/zip   0.022s
	ok   compress/gzip 0.033s
	...

followed by detailed output for each failed package.

'Go test' recompiles each package along with any files with names matching
the file pattern "*_test.go".
Files whose names begin with "_" (including "_test.go") or "." are ignored.
These additional files can contain test functions, benchmark functions, and
example functions.  See 'go help testfunc' for more.
Each listed package causes the execution of a separate test binary.

Test files that declare a package with the suffix "_test" will be compiled as a
separate package, and then linked and run with the main test binary.

By default, go test needs no arguments.  It compiles and tests the package
with source in the current directory, including tests, and runs the tests.

The package is built in a temporary directory so it does not interfere with the
non-test installation.

In addition to the build flags, the flags handled by 'go test' itself are:

	-c
		Compile the test binary to pkg.test but do not run it
		(where pkg is the last element of the package's import path).
		The file name can be changed with the -o flag.

	-exec xprog
	    Run the test binary using xprog. The behavior is the same as
	    in 'go run'. See 'go help run' for details.

	-i
	    Install packages that are dependencies of the test.
	    Do not run the test.

	-o file
		Compile the test binary to the named file.
		The test still runs (unless -c or -i is specified).


The test binary also accepts flags that control execution of the test; these
flags are also accessible by 'go test'.  See 'go help testflag' for details.

If the test binary needs any other flags, they should be presented after the
package names. The go tool treats as a flag the first argument that begins with
a minus sign that it does not recognize itself; that argument and all subsequent
arguments are passed as arguments to the test binary.

For more about build flags, see 'go help build'.
For more about specifying packages, see 'go help packages'.

See also: go build, go vet.
`,
}

var helpTestflag = &Command{
	UsageLine: "testflag",
	Short:     "description of testing flags",
	Long: `
The 'go test' command takes both flags that apply to 'go test' itself
and flags that apply to the resulting test binary.

Several of the flags control profiling and write an execution profile
suitable for "go tool pprof"; run "go tool pprof help" for more
information.  The --alloc_space, --alloc_objects, and --show_bytes
options of pprof control how the information is presented.

The following flags are recognized by the 'go test' command and
control the execution of any test:

	-bench regexp
	    Run benchmarks matching the regular expression.
	    By default, no benchmarks run. To run all benchmarks,
	    use '-bench .' or '-bench=.'.

	-benchmem
	    Print memory allocation statistics for benchmarks.

	-benchtime t
	    Run enough iterations of each benchmark to take t, specified
	    as a time.Duration (for example, -benchtime 1h30s).
	    The default is 1 second (1s).

	-blockprofile block.out
	    Write a goroutine blocking profile to the specified file
	    when all tests are complete.
	    Writes test binary as -c would.

	-blockprofilerate n
	    Control the detail provided in goroutine blocking profiles by
	    calling runtime.SetBlockProfileRate with n.
	    See 'godoc runtime SetBlockProfileRate'.
	    The profiler aims to sample, on average, one blocking event every
	    n nanoseconds the program spends blocked.  By default,
	    if -test.blockprofile is set without this flag, all blocking events
	    are recorded, equivalent to -test.blockprofilerate=1.

	-cover
	    Enable coverage analysis.

	-covermode set,count,atomic
	    Set the mode for coverage analysis for the package[s]
	    being tested. The default is "set" unless -race is enabled,
	    in which case it is "atomic".
	    The values:
		set: bool: does this statement run?
		count: int: how many times does this statement run?
		atomic: int: count, but correct in multithreaded tests;
			significantly more expensive.
	    Sets -cover.

	-coverpkg pkg1,pkg2,pkg3
	    Apply coverage analysis in each test to the given list of packages.
	    The default is for each test to analyze only the package being tested.
	    Packages are specified as import paths.
	    Sets -cover.

	-coverprofile cover.out
	    Write a coverage profile to the file after all tests have passed.
	    Sets -cover.

	-cpu 1,2,4
	    Specify a list of GOMAXPROCS values for which the tests or
	    benchmarks should be executed.  The default is the current value
	    of GOMAXPROCS.

	-cpuprofile cpu.out
	    Write a CPU profile to the specified file before exiting.
	    Writes test binary as -c would.

	-memprofile mem.out
	    Write a memory profile to the file after all tests have passed.
	    Writes test binary as -c would.

	-memprofilerate n
	    Enable more precise (and expensive) memory profiles by setting
	    runtime.MemProfileRate.  See 'godoc runtime MemProfileRate'.
	    To profile all memory allocations, use -test.memprofilerate=1
	    and pass --alloc_space flag to the pprof tool.

	-outputdir directory
	    Place output files from profiling in the specified directory,
	    by default the directory in which "go test" is running.

	-parallel n
	    Allow parallel execution of test functions that call t.Parallel.
	    The value of this flag is the maximum number of tests to run
	    simultaneously; by default, it is set to the value of GOMAXPROCS.

	-run regexp
	    Run only those tests and examples matching the regular
	    expression.

	-short
	    Tell long-running tests to shorten their run time.
	    It is off by default but set during all.bash so that installing
	    the Go tree can run a sanity check but not spend time running
	    exhaustive tests.

	-timeout t
	    If a test runs longer than t, panic.

	-v
	    Verbose output: log all tests as they are run. Also print all
	    text from Log and Logf calls even if the test succeeds.

The test binary, called pkg.test where pkg is the name of the
directory containing the package sources, can be invoked directly
after building it with 'go test -c'. When invoking the test binary
directly, each of the standard flag names must be prefixed with 'test.',
as in -test.run=TestMyFunc or -test.v.

When running 'go test', flags not listed above are passed through
unaltered. For instance, the command

	go test -x -v -cpuprofile=prof.out -dir=testdata -update

will compile the test binary and then run it as

	pkg.test -test.v -test.cpuprofile=prof.out -dir=testdata -update

The test flags that generate profiles (other than for coverage) also
leave the test binary in pkg.test for use when analyzing the profiles.

Flags not recognized by 'go test' must be placed after any specified packages.
`,
}

var helpTestfunc = &Command{
	UsageLine: "testfunc",
	Short:     "description of testing functions",
	Long: `
The 'go test' command expects to find test, benchmark, and example functions
in the "*_test.go" files corresponding to the package under test.

A test function is one named TestXXX (where XXX is any alphanumeric string
not starting with a lower case letter) and should have the signature,

	func TestXXX(t *testing.T) { ... }

A benchmark function is one named BenchmarkXXX and should have the signature,

	func BenchmarkXXX(b *testing.B) { ... }

An example function is similar to a test function but, instead of using
*testing.T to report success or failure, prints output to os.Stdout.
That output is compared against the function's "Output:" comment, which
must be the last comment in the function body (see example below). An
example with no such comment, or with no text after "Output:" is compiled
but not executed.

Godoc displays the body of ExampleXXX to demonstrate the use
of the function, constant, or variable XXX.  An example of a method M with
receiver type T or *T is named ExampleT_M.  There may be multiple examples
for a given function, constant, or variable, distinguished by a trailing _xxx,
where xxx is a suffix not beginning with an upper case letter.

Here is an example of an example:

	func ExamplePrintln() {
		Println("The output of\nthis example.")
		// Output: The output of
		// this example.
	}

The entire test file is presented as the example when it contains a single
example function, at least one other function, type, variable, or constant
declaration, and no test or benchmark functions.

See the documentation of the testing package for more information.
`,
}

var (
	testC            bool       // -c flag
	testCover        bool       // -cover flag
	testCoverMode    string     // -covermode flag
	testCoverPaths   []string   // -coverpkg flag
	testCoverPkgs    []*Package // -coverpkg flag
	testO            string     // -o flag
	testProfile      bool       // some profiling flag
	testNeedBinary   bool       // profile needs to keep binary around
	testV            bool       // -v flag
	testTimeout      string     // -timeout flag
	testArgs         []string
	testBench        bool
	testStreamOutput bool // show output as it is generated
	testShowPass     bool // show passing output

	testKillTimeout = 10 * time.Minute
)

var testMainDeps = map[string]bool{
	// Dependencies for testmain.
	"testing": true,
	"regexp":  true,
	"os":      true,
}

func runTest(cmd *Command, args []string) {
	var pkgArgs []string
	pkgArgs, testArgs = testFlags(args)

	findExecCmd() // initialize cached result

	raceInit()
	pkgs := packagesForBuild(pkgArgs)
	if len(pkgs) == 0 {
		fatalf("no packages to test")
	}

	if testC && len(pkgs) != 1 {
		fatalf("cannot use -c flag with multiple packages")
	}
	if testO != "" && len(pkgs) != 1 {
		fatalf("cannot use -o flag with multiple packages")
	}
	if testProfile && len(pkgs) != 1 {
		fatalf("cannot use test profile flag with multiple packages")
	}

	// If a test timeout was given and is parseable, set our kill timeout
	// to that timeout plus one minute.  This is a backup alarm in case
	// the test wedges with a goroutine spinning and its background
	// timer does not get a chance to fire.
	if dt, err := time.ParseDuration(testTimeout); err == nil && dt > 0 {
		testKillTimeout = dt + 1*time.Minute
	}

	// show passing test output (after buffering) with -v flag.
	// must buffer because tests are running in parallel, and
	// otherwise the output will get mixed.
	testShowPass = testV

	// stream test output (no buffering) when no package has
	// been given on the command line (implicit current directory)
	// or when benchmarking.
	// Also stream if we're showing output anyway with a
	// single package under test.  In that case, streaming the
	// output produces the same result as not streaming,
	// just more immediately.
	testStreamOutput = len(pkgArgs) == 0 || testBench ||
		(len(pkgs) <= 1 && testShowPass)

	var b builder
	b.init()

	if buildI {
		buildV = testV

		deps := make(map[string]bool)
		for dep := range testMainDeps {
			deps[dep] = true
		}

		for _, p := range pkgs {
			// Dependencies for each test.
			for _, path := range p.Imports {
				deps[path] = true
			}
			for _, path := range p.TestImports {
				deps[path] = true
			}
			for _, path := range p.XTestImports {
				deps[path] = true
			}
		}

		// translate C to runtime/cgo
		if deps["C"] {
			delete(deps, "C")
			deps["runtime/cgo"] = true
			if buildContext.GOOS == runtime.GOOS && buildContext.GOARCH == runtime.GOARCH {
				deps["cmd/cgo"] = true
			}
		}
		// Ignore pseudo-packages.
		delete(deps, "unsafe")

		all := []string{}
		for path := range deps {
			if !build.IsLocalImport(path) {
				all = append(all, path)
			}
		}
		sort.Strings(all)

		a := &action{}
		for _, p := range packagesForBuild(all) {
			a.deps = append(a.deps, b.action(modeInstall, modeInstall, p))
		}
		b.do(a)
		if !testC || a.failed {
			return
		}
		b.init()
	}

	var builds, runs, prints []*action

	if testCoverPaths != nil {
		// Load packages that were asked about for coverage.
		// packagesForBuild exits if the packages cannot be loaded.
		testCoverPkgs = packagesForBuild(testCoverPaths)

		// Warn about -coverpkg arguments that are not actually used.
		used := make(map[string]bool)
		for _, p := range pkgs {
			used[p.ImportPath] = true
			for _, dep := range p.Deps {
				used[dep] = true
			}
		}
		for _, p := range testCoverPkgs {
			if !used[p.ImportPath] {
				log.Printf("warning: no packages being tested depend on %s", p.ImportPath)
			}
		}

		// Mark all the coverage packages for rebuilding with coverage.
		for _, p := range testCoverPkgs {
			p.Stale = true // rebuild
			p.fake = true  // do not warn about rebuild
			p.coverMode = testCoverMode
			var coverFiles []string
			coverFiles = append(coverFiles, p.GoFiles...)
			coverFiles = append(coverFiles, p.CgoFiles...)
			coverFiles = append(coverFiles, p.TestGoFiles...)
			p.coverVars = declareCoverVars(p.ImportPath, coverFiles...)
		}
	}

	// Prepare build + run + print actions for all packages being tested.
	for _, p := range pkgs {
		buildTest, runTest, printTest, err := b.test(p)
		if err != nil {
			str := err.Error()
			if strings.HasPrefix(str, "\n") {
				str = str[1:]
			}
			failed := fmt.Sprintf("FAIL\t%s [setup failed]\n", p.ImportPath)

			if p.ImportPath != "" {
				errorf("# %s\n%s\n%s", p.ImportPath, str, failed)
			} else {
				errorf("%s\n%s", str, failed)
			}
			continue
		}
		builds = append(builds, buildTest)
		runs = append(runs, runTest)
		prints = append(prints, printTest)
	}

	// Ultimately the goal is to print the output.
	root := &action{deps: prints}

	// Force the printing of results to happen in order,
	// one at a time.
	for i, a := range prints {
		if i > 0 {
			a.deps = append(a.deps, prints[i-1])
		}
	}

	// Force benchmarks to run in serial.
	if !testC && testBench {
		// The first run must wait for all builds.
		// Later runs must wait for the previous run's print.
		for i, run := range runs {
			if i == 0 {
				run.deps = append(run.deps, builds...)
			} else {
				run.deps = append(run.deps, prints[i-1])
			}
		}
	}

	// If we are building any out-of-date packages other
	// than those under test, warn.
	okBuild := map[*Package]bool{}
	for _, p := range pkgs {
		okBuild[p] = true
	}
	warned := false
	for _, a := range actionList(root) {
		if a.p == nil || okBuild[a.p] {
			continue
		}
		okBuild[a.p] = true // warn at most once

		// Don't warn about packages being rebuilt because of
		// things like coverage analysis.
		for _, p1 := range a.p.imports {
			if p1.fake {
				a.p.fake = true
			}
		}

		if a.f != nil && !okBuild[a.p] && !a.p.fake && !a.p.local {
			if !warned {
				fmt.Fprintf(os.Stderr, "warning: building out-of-date packages:\n")
				warned = true
			}
			fmt.Fprintf(os.Stderr, "\t%s\n", a.p.ImportPath)
		}
	}
	if warned {
		args := strings.Join(pkgArgs, " ")
		if args != "" {
			args = " " + args
		}
		extraOpts := ""
		if buildRace {
			extraOpts = "-race "
		}
		fmt.Fprintf(os.Stderr, "installing these packages with 'go test %s-i%s' will speed future tests.\n\n", extraOpts, args)
	}

	b.do(root)
}

func contains(x []string, s string) bool {
	for _, t := range x {
		if t == s {
			return true
		}
	}
	return false
}

var windowsBadWords = []string{
	"install",
	"patch",
	"setup",
	"update",
}

func (b *builder) test(p *Package) (buildAction, runAction, printAction *action, err error) {
	if len(p.TestGoFiles)+len(p.XTestGoFiles) == 0 {
		build := b.action(modeBuild, modeBuild, p)
		run := &action{p: p, deps: []*action{build}}
		print := &action{f: (*builder).notest, p: p, deps: []*action{run}}
		return build, run, print, nil
	}

	// Build Package structs describing:
	//	ptest - package + test files
	//	pxtest - package of external test files
	//	pmain - pkg.test binary
	var ptest, pxtest, pmain *Package

	var imports, ximports []*Package
	var stk importStack
	stk.push(p.ImportPath + " (test)")
	for _, path := range p.TestImports {
		p1 := loadImport(path, p.Dir, &stk, p.build.TestImportPos[path])
		if p1.Error != nil {
			return nil, nil, nil, p1.Error
		}
		if contains(p1.Deps, p.ImportPath) {
			// Same error that loadPackage returns (via reusePackage) in pkg.go.
			// Can't change that code, because that code is only for loading the
			// non-test copy of a package.
			err := &PackageError{
				ImportStack:   testImportStack(stk[0], p1, p.ImportPath),
				Err:           "import cycle not allowed in test",
				isImportCycle: true,
			}
			return nil, nil, nil, err
		}
		imports = append(imports, p1)
	}
	stk.pop()
	stk.push(p.ImportPath + "_test")
	pxtestNeedsPtest := false
	for _, path := range p.XTestImports {
		if path == p.ImportPath {
			pxtestNeedsPtest = true
			continue
		}
		p1 := loadImport(path, p.Dir, &stk, p.build.XTestImportPos[path])
		if p1.Error != nil {
			return nil, nil, nil, p1.Error
		}
		ximports = append(ximports, p1)
	}
	stk.pop()

	// Use last element of import path, not package name.
	// They differ when package name is "main".
	// But if the import path is "command-line-arguments",
	// like it is during 'go run', use the package name.
	var elem string
	if p.ImportPath == "command-line-arguments" {
		elem = p.Name
	} else {
		_, elem = path.Split(p.ImportPath)
	}
	testBinary := elem + ".test"

	// The ptest package needs to be importable under the
	// same import path that p has, but we cannot put it in
	// the usual place in the temporary tree, because then
	// other tests will see it as the real package.
	// Instead we make a _test directory under the import path
	// and then repeat the import path there.  We tell the
	// compiler and linker to look in that _test directory first.
	//
	// That is, if the package under test is unicode/utf8,
	// then the normal place to write the package archive is
	// $WORK/unicode/utf8.a, but we write the test package archive to
	// $WORK/unicode/utf8/_test/unicode/utf8.a.
	// We write the external test package archive to
	// $WORK/unicode/utf8/_test/unicode/utf8_test.a.
	testDir := filepath.Join(b.work, filepath.FromSlash(p.ImportPath+"/_test"))
	ptestObj := buildToolchain.pkgpath(testDir, p)

	// Create the directory for the .a files.
	ptestDir, _ := filepath.Split(ptestObj)
	if err := b.mkdir(ptestDir); err != nil {
		return nil, nil, nil, err
	}

	// Should we apply coverage analysis locally,
	// only for this package and only for this test?
	// Yes, if -cover is on but -coverpkg has not specified
	// a list of packages for global coverage.
	localCover := testCover && testCoverPaths == nil

	// Test package.
	if len(p.TestGoFiles) > 0 || localCover || p.Name == "main" {
		ptest = new(Package)
		*ptest = *p
		ptest.GoFiles = nil
		ptest.GoFiles = append(ptest.GoFiles, p.GoFiles...)
		ptest.GoFiles = append(ptest.GoFiles, p.TestGoFiles...)
		ptest.target = ""
		ptest.Imports = stringList(p.Imports, p.TestImports)
		ptest.imports = append(append([]*Package{}, p.imports...), imports...)
		ptest.pkgdir = testDir
		ptest.fake = true
		ptest.forceLibrary = true
		ptest.Stale = true
		ptest.build = new(build.Package)
		*ptest.build = *p.build
		m := map[string][]token.Position{}
		for k, v := range p.build.ImportPos {
			m[k] = append(m[k], v...)
		}
		for k, v := range p.build.TestImportPos {
			m[k] = append(m[k], v...)
		}
		ptest.build.ImportPos = m

		if localCover {
			ptest.coverMode = testCoverMode
			var coverFiles []string
			coverFiles = append(coverFiles, ptest.GoFiles...)
			coverFiles = append(coverFiles, ptest.CgoFiles...)
			ptest.coverVars = declareCoverVars(ptest.ImportPath, coverFiles...)
		}
	} else {
		ptest = p
	}

	// External test package.
	if len(p.XTestGoFiles) > 0 {
		pxtest = &Package{
			Name:        p.Name + "_test",
			ImportPath:  p.ImportPath + "_test",
			localPrefix: p.localPrefix,
			Root:        p.Root,
			Dir:         p.Dir,
			GoFiles:     p.XTestGoFiles,
			Imports:     p.XTestImports,
			build: &build.Package{
				ImportPos: p.build.XTestImportPos,
			},
			imports: ximports,
			pkgdir:  testDir,
			fake:    true,
			Stale:   true,
		}
		if pxtestNeedsPtest {
			pxtest.imports = append(pxtest.imports, ptest)
		}
	}

	// Action for building pkg.test.
	pmain = &Package{
		Name:       "main",
		Dir:        testDir,
		GoFiles:    []string{"_testmain.go"},
		ImportPath: "testmain",
		Root:       p.Root,
		build:      &build.Package{Name: "main"},
		pkgdir:     testDir,
		fake:       true,
		Stale:      true,
		omitDWARF:  !testC && !testNeedBinary,
	}

	// The generated main also imports testing, regexp, and os.
	stk.push("testmain")
	for dep := range testMainDeps {
		if dep == ptest.ImportPath {
			pmain.imports = append(pmain.imports, ptest)
		} else {
			p1 := loadImport(dep, "", &stk, nil)
			if p1.Error != nil {
				return nil, nil, nil, p1.Error
			}
			pmain.imports = append(pmain.imports, p1)
		}
	}

	if testCoverPkgs != nil {
		// Add imports, but avoid duplicates.
		seen := map[*Package]bool{p: true, ptest: true}
		for _, p1 := range pmain.imports {
			seen[p1] = true
		}
		for _, p1 := range testCoverPkgs {
			if !seen[p1] {
				seen[p1] = true
				pmain.imports = append(pmain.imports, p1)
			}
		}
	}

	// Do initial scan for metadata needed for writing _testmain.go
	// Use that metadata to update the list of imports for package main.
	// The list of imports is used by recompileForTest and by the loop
	// afterward that gathers t.Cover information.
	t, err := loadTestFuncs(ptest)
	if err != nil {
		return nil, nil, nil, err
	}
	if len(ptest.GoFiles) > 0 {
		pmain.imports = append(pmain.imports, ptest)
		t.ImportTest = true
	}
	if pxtest != nil {
		pmain.imports = append(pmain.imports, pxtest)
		t.ImportXtest = true
	}

	if ptest != p && localCover {
		// We have made modifications to the package p being tested
		// and are rebuilding p (as ptest), writing it to the testDir tree.
		// Arrange to rebuild, writing to that same tree, all packages q
		// such that the test depends on q, and q depends on p.
		// This makes sure that q sees the modifications to p.
		// Strictly speaking, the rebuild is only necessary if the
		// modifications to p change its export metadata, but
		// determining that is a bit tricky, so we rebuild always.
		//
		// This will cause extra compilation, so for now we only do it
		// when testCover is set. The conditions are more general, though,
		// and we may find that we need to do it always in the future.
		recompileForTest(pmain, p, ptest, testDir)
	}

	for _, cp := range pmain.imports {
		if len(cp.coverVars) > 0 {
			t.Cover = append(t.Cover, coverInfo{cp, cp.coverVars})
		}
	}

	// writeTestmain writes _testmain.go. This must happen after recompileForTest,
	// because recompileForTest modifies XXX.
	if err := writeTestmain(filepath.Join(testDir, "_testmain.go"), t); err != nil {
		return nil, nil, nil, err
	}

	computeStale(pmain)

	if ptest != p {
		a := b.action(modeBuild, modeBuild, ptest)
		a.objdir = testDir + string(filepath.Separator) + "_obj_test" + string(filepath.Separator)
		a.objpkg = ptestObj
		a.target = ptestObj
		a.link = false
	}

	if pxtest != nil {
		a := b.action(modeBuild, modeBuild, pxtest)
		a.objdir = testDir + string(filepath.Separator) + "_obj_xtest" + string(filepath.Separator)
		a.objpkg = buildToolchain.pkgpath(testDir, pxtest)
		a.target = a.objpkg
	}

	a := b.action(modeBuild, modeBuild, pmain)
	a.objdir = testDir + string(filepath.Separator)
	a.objpkg = filepath.Join(testDir, "main.a")
	a.target = filepath.Join(testDir, testBinary) + exeSuffix
	if goos == "windows" {
		// There are many reserved words on Windows that,
		// if used in the name of an executable, cause Windows
		// to try to ask for extra permissions.
		// The word list includes setup, install, update, and patch,
		// but it does not appear to be defined anywhere.
		// We have run into this trying to run the
		// go.codereview/patch tests.
		// For package names containing those words, use test.test.exe
		// instead of pkgname.test.exe.
		// Note that this file name is only used in the Go command's
		// temporary directory. If the -c or other flags are
		// given, the code below will still use pkgname.test.exe.
		// There are two user-visible effects of this change.
		// First, you can actually run 'go test' in directories that
		// have names that Windows thinks are installer-like,
		// without getting a dialog box asking for more permissions.
		// Second, in the Windows process listing during go test,
		// the test shows up as test.test.exe, not pkgname.test.exe.
		// That second one is a drawback, but it seems a small
		// price to pay for the test running at all.
		// If maintaining the list of bad words is too onerous,
		// we could just do this always on Windows.
		for _, bad := range windowsBadWords {
			if strings.Contains(testBinary, bad) {
				a.target = filepath.Join(testDir, "test.test") + exeSuffix
				break
			}
		}
	}
	buildAction = a

	if testC || testNeedBinary {
		// -c or profiling flag: create action to copy binary to ./test.out.
		target := filepath.Join(cwd, testBinary+exeSuffix)
		if testO != "" {
			target = testO
			if !filepath.IsAbs(target) {
				target = filepath.Join(cwd, target)
			}
		}
		buildAction = &action{
			f:      (*builder).install,
			deps:   []*action{buildAction},
			p:      pmain,
			target: target,
		}
		runAction = buildAction // make sure runAction != nil even if not running test
	}
	if testC {
		printAction = &action{p: p, deps: []*action{runAction}} // nop
	} else {
		// run test
		runAction = &action{
			f:          (*builder).runTest,
			deps:       []*action{buildAction},
			p:          p,
			ignoreFail: true,
		}
		cleanAction := &action{
			f:    (*builder).cleanTest,
			deps: []*action{runAction},
			p:    p,
		}
		printAction = &action{
			f:    (*builder).printTest,
			deps: []*action{cleanAction},
			p:    p,
		}
	}

	return buildAction, runAction, printAction, nil
}

func testImportStack(top string, p *Package, target string) []string {
	stk := []string{top, p.ImportPath}
Search:
	for p.ImportPath != target {
		for _, p1 := range p.imports {
			if p1.ImportPath == target || contains(p1.Deps, target) {
				stk = append(stk, p1.ImportPath)
				p = p1
				continue Search
			}
		}
		// Can't happen, but in case it does...
		stk = append(stk, "<lost path to cycle>")
		break
	}
	return stk
}

func recompileForTest(pmain, preal, ptest *Package, testDir string) {
	// The "test copy" of preal is ptest.
	// For each package that depends on preal, make a "test copy"
	// that depends on ptest. And so on, up the dependency tree.
	testCopy := map[*Package]*Package{preal: ptest}
	for _, p := range packageList([]*Package{pmain}) {
		// Copy on write.
		didSplit := false
		split := func() {
			if didSplit {
				return
			}
			didSplit = true
			if p.pkgdir != testDir {
				p1 := new(Package)
				testCopy[p] = p1
				*p1 = *p
				p1.imports = make([]*Package, len(p.imports))
				copy(p1.imports, p.imports)
				p = p1
				p.pkgdir = testDir
				p.target = ""
				p.fake = true
				p.Stale = true
			}
		}

		// Update p.deps and p.imports to use at test copies.
		for i, dep := range p.deps {
			if p1 := testCopy[dep]; p1 != nil && p1 != dep {
				split()
				p.deps[i] = p1
			}
		}
		for i, imp := range p.imports {
			if p1 := testCopy[imp]; p1 != nil && p1 != imp {
				split()
				p.imports[i] = p1
			}
		}
	}
}

var coverIndex = 0

// isTestFile reports whether the source file is a set of tests and should therefore
// be excluded from coverage analysis.
func isTestFile(file string) bool {
	// We don't cover tests, only the code they test.
	return strings.HasSuffix(file, "_test.go")
}

// declareCoverVars attaches the required cover variables names
// to the files, to be used when annotating the files.
func declareCoverVars(importPath string, files ...string) map[string]*CoverVar {
	coverVars := make(map[string]*CoverVar)
	for _, file := range files {
		if isTestFile(file) {
			continue
		}
		coverVars[file] = &CoverVar{
			File: filepath.Join(importPath, file),
			Var:  fmt.Sprintf("GoCover_%d", coverIndex),
		}
		coverIndex++
	}
	return coverVars
}

// runTest is the action for running a test binary.
func (b *builder) runTest(a *action) error {
	args := stringList(findExecCmd(), a.deps[0].target, testArgs)
	a.testOutput = new(bytes.Buffer)

	if buildN || buildX {
		b.showcmd("", "%s", strings.Join(args, " "))
		if buildN {
			return nil
		}
	}

	if a.failed {
		// We were unable to build the binary.
		a.failed = false
		fmt.Fprintf(a.testOutput, "FAIL\t%s [build failed]\n", a.p.ImportPath)
		setExitStatus(1)
		return nil
	}

	cmd := exec.Command(args[0], args[1:]...)
	cmd.Dir = a.p.Dir
	cmd.Env = envForDir(cmd.Dir)
	var buf bytes.Buffer
	if testStreamOutput {
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
	} else {
		cmd.Stdout = &buf
		cmd.Stderr = &buf
	}

	// If there are any local SWIG dependencies, we want to load
	// the shared library from the build directory.
	if a.p.usesSwig() {
		env := cmd.Env
		found := false
		prefix := "LD_LIBRARY_PATH="
		for i, v := range env {
			if strings.HasPrefix(v, prefix) {
				env[i] = v + ":."
				found = true
				break
			}
		}
		if !found {
			env = append(env, "LD_LIBRARY_PATH=.")
		}
		cmd.Env = env
	}

	t0 := time.Now()
	err := cmd.Start()

	// This is a last-ditch deadline to detect and
	// stop wedged test binaries, to keep the builders
	// running.
	if err == nil {
		tick := time.NewTimer(testKillTimeout)
		startSigHandlers()
		done := make(chan error)
		go func() {
			done <- cmd.Wait()
		}()
	Outer:
		select {
		case err = <-done:
			// ok
		case <-tick.C:
			if signalTrace != nil {
				// Send a quit signal in the hope that the program will print
				// a stack trace and exit. Give it five seconds before resorting
				// to Kill.
				cmd.Process.Signal(signalTrace)
				select {
				case err = <-done:
					fmt.Fprintf(&buf, "*** Test killed with %v: ran too long (%v).\n", signalTrace, testKillTimeout)
					break Outer
				case <-time.After(5 * time.Second):
				}
			}
			cmd.Process.Kill()
			err = <-done
			fmt.Fprintf(&buf, "*** Test killed: ran too long (%v).\n", testKillTimeout)
		}
		tick.Stop()
	}
	out := buf.Bytes()
	t := fmt.Sprintf("%.3fs", time.Since(t0).Seconds())
	if err == nil {
		if testShowPass {
			a.testOutput.Write(out)
		}
		fmt.Fprintf(a.testOutput, "ok  \t%s\t%s%s\n", a.p.ImportPath, t, coveragePercentage(out))
		return nil
	}

	setExitStatus(1)
	if len(out) > 0 {
		a.testOutput.Write(out)
		// assume printing the test binary's exit status is superfluous
	} else {
		fmt.Fprintf(a.testOutput, "%s\n", err)
	}
	fmt.Fprintf(a.testOutput, "FAIL\t%s\t%s\n", a.p.ImportPath, t)

	return nil
}

// coveragePercentage returns the coverage results (if enabled) for the
// test. It uncovers the data by scanning the output from the test run.
func coveragePercentage(out []byte) string {
	if !testCover {
		return ""
	}
	// The string looks like
	//	test coverage for encoding/binary: 79.9% of statements
	// Extract the piece from the percentage to the end of the line.
	re := regexp.MustCompile(`coverage: (.*)\n`)
	matches := re.FindSubmatch(out)
	if matches == nil {
		// Probably running "go test -cover" not "go test -cover fmt".
		// The coverage output will appear in the output directly.
		return ""
	}
	return fmt.Sprintf("\tcoverage: %s", matches[1])
}

// cleanTest is the action for cleaning up after a test.
func (b *builder) cleanTest(a *action) error {
	if buildWork {
		return nil
	}
	run := a.deps[0]
	testDir := filepath.Join(b.work, filepath.FromSlash(run.p.ImportPath+"/_test"))
	os.RemoveAll(testDir)
	return nil
}

// printTest is the action for printing a test result.
func (b *builder) printTest(a *action) error {
	clean := a.deps[0]
	run := clean.deps[0]
	os.Stdout.Write(run.testOutput.Bytes())
	run.testOutput = nil
	return nil
}

// notest is the action for testing a package with no test files.
func (b *builder) notest(a *action) error {
	fmt.Printf("?   \t%s\t[no test files]\n", a.p.ImportPath)
	return nil
}

// isTestMain tells whether fn is a TestMain(m *testing.M) function.
func isTestMain(fn *ast.FuncDecl) bool {
	if fn.Name.String() != "TestMain" ||
		fn.Type.Results != nil && len(fn.Type.Results.List) > 0 ||
		fn.Type.Params == nil ||
		len(fn.Type.Params.List) != 1 ||
		len(fn.Type.Params.List[0].Names) > 1 {
		return false
	}
	ptr, ok := fn.Type.Params.List[0].Type.(*ast.StarExpr)
	if !ok {
		return false
	}
	// We can't easily check that the type is *testing.M
	// because we don't know how testing has been imported,
	// but at least check that it's *M or *something.M.
	if name, ok := ptr.X.(*ast.Ident); ok && name.Name == "M" {
		return true
	}
	if sel, ok := ptr.X.(*ast.SelectorExpr); ok && sel.Sel.Name == "M" {
		return true
	}
	return false
}

// isTest tells whether name looks like a test (or benchmark, according to prefix).
// It is a Test (say) if there is a character after Test that is not a lower-case letter.
// We don't want TesticularCancer.
func isTest(name, prefix string) bool {
	if !strings.HasPrefix(name, prefix) {
		return false
	}
	if len(name) == len(prefix) { // "Test" is ok
		return true
	}
	rune, _ := utf8.DecodeRuneInString(name[len(prefix):])
	return !unicode.IsLower(rune)
}

type coverInfo struct {
	Package *Package
	Vars    map[string]*CoverVar
}

// loadTestFuncs returns the testFuncs describing the tests that will be run.
func loadTestFuncs(ptest *Package) (*testFuncs, error) {
	t := &testFuncs{
		Package: ptest,
	}
	for _, file := range ptest.TestGoFiles {
		if err := t.load(filepath.Join(ptest.Dir, file), "_test", &t.ImportTest, &t.NeedTest); err != nil {
			return nil, err
		}
	}
	for _, file := range ptest.XTestGoFiles {
		if err := t.load(filepath.Join(ptest.Dir, file), "_xtest", &t.ImportXtest, &t.NeedXtest); err != nil {
			return nil, err
		}
	}
	return t, nil
}

// writeTestmain writes the _testmain.go file for t to the file named out.
func writeTestmain(out string, t *testFuncs) error {
	f, err := os.Create(out)
	if err != nil {
		return err
	}
	defer f.Close()

	if err := testmainTmpl.Execute(f, t); err != nil {
		return err
	}

	return nil
}

type testFuncs struct {
	Tests       []testFunc
	Benchmarks  []testFunc
	Examples    []testFunc
	TestMain    *testFunc
	Package     *Package
	ImportTest  bool
	NeedTest    bool
	ImportXtest bool
	NeedXtest   bool
	Cover       []coverInfo
}

func (t *testFuncs) CoverMode() string {
	return testCoverMode
}

func (t *testFuncs) CoverEnabled() bool {
	return testCover
}

// Covered returns a string describing which packages are being tested for coverage.
// If the covered package is the same as the tested package, it returns the empty string.
// Otherwise it is a comma-separated human-readable list of packages beginning with
// " in", ready for use in the coverage message.
func (t *testFuncs) Covered() string {
	if testCoverPaths == nil {
		return ""
	}
	return " in " + strings.Join(testCoverPaths, ", ")
}

// Tested returns the name of the package being tested.
func (t *testFuncs) Tested() string {
	return t.Package.Name
}

type testFunc struct {
	Package string // imported package name (_test or _xtest)
	Name    string // function name
	Output  string // output, for examples
}

var testFileSet = token.NewFileSet()

func (t *testFuncs) load(filename, pkg string, doImport, seen *bool) error {
	f, err := parser.ParseFile(testFileSet, filename, nil, parser.ParseComments)
	if err != nil {
		return expandScanner(err)
	}
	for _, d := range f.Decls {
		n, ok := d.(*ast.FuncDecl)
		if !ok {
			continue
		}
		if n.Recv != nil {
			continue
		}
		name := n.Name.String()
		switch {
		case isTestMain(n):
			if t.TestMain != nil {
				return errors.New("multiple definitions of TestMain")
			}
			t.TestMain = &testFunc{pkg, name, ""}
			*doImport, *seen = true, true
		case isTest(name, "Test"):
			t.Tests = append(t.Tests, testFunc{pkg, name, ""})
			*doImport, *seen = true, true
		case isTest(name, "Benchmark"):
			t.Benchmarks = append(t.Benchmarks, testFunc{pkg, name, ""})
			*doImport, *seen = true, true
		}
	}
	ex := doc.Examples(f)
	sort.Sort(byOrder(ex))
	for _, e := range ex {
		*doImport = true // import test file whether executed or not
		if e.Output == "" && !e.EmptyOutput {
			// Don't run examples with no output.
			continue
		}
		t.Examples = append(t.Examples, testFunc{pkg, "Example" + e.Name, e.Output})
		*seen = true
	}
	return nil
}

type byOrder []*doc.Example

func (x byOrder) Len() int           { return len(x) }
func (x byOrder) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
func (x byOrder) Less(i, j int) bool { return x[i].Order < x[j].Order }

var testmainTmpl = template.Must(template.New("main").Parse(`
package main

import (
{{if not .TestMain}}
	"os"
{{end}}
	"regexp"
	"testing"

{{if .ImportTest}}
	{{if .NeedTest}}_test{{else}}_{{end}} {{.Package.ImportPath | printf "%q"}}
{{end}}
{{if .ImportXtest}}
	{{if .NeedXtest}}_xtest{{else}}_{{end}} {{.Package.ImportPath | printf "%s_test" | printf "%q"}}
{{end}}
{{range $i, $p := .Cover}}
	_cover{{$i}} {{$p.Package.ImportPath | printf "%q"}}
{{end}}
)

var tests = []testing.InternalTest{
{{range .Tests}}
	{"{{.Name}}", {{.Package}}.{{.Name}}},
{{end}}
}

var benchmarks = []testing.InternalBenchmark{
{{range .Benchmarks}}
	{"{{.Name}}", {{.Package}}.{{.Name}}},
{{end}}
}

var examples = []testing.InternalExample{
{{range .Examples}}
	{"{{.Name}}", {{.Package}}.{{.Name}}, {{.Output | printf "%q"}}},
{{end}}
}

var matchPat string
var matchRe *regexp.Regexp

func matchString(pat, str string) (result bool, err error) {
	if matchRe == nil || matchPat != pat {
		matchPat = pat
		matchRe, err = regexp.Compile(matchPat)
		if err != nil {
			return
		}
	}
	return matchRe.MatchString(str), nil
}

{{if .CoverEnabled}}

// Only updated by init functions, so no need for atomicity.
var (
	coverCounters = make(map[string][]uint32)
	coverBlocks = make(map[string][]testing.CoverBlock)
)

func init() {
	{{range $i, $p := .Cover}}
	{{range $file, $cover := $p.Vars}}
	coverRegisterFile({{printf "%q" $cover.File}}, _cover{{$i}}.{{$cover.Var}}.Count[:], _cover{{$i}}.{{$cover.Var}}.Pos[:], _cover{{$i}}.{{$cover.Var}}.NumStmt[:])
	{{end}}
	{{end}}
}

func coverRegisterFile(fileName string, counter []uint32, pos []uint32, numStmts []uint16) {
	if 3*len(counter) != len(pos) || len(counter) != len(numStmts) {
		panic("coverage: mismatched sizes")
	}
	if coverCounters[fileName] != nil {
		// Already registered.
		return
	}
	coverCounters[fileName] = counter
	block := make([]testing.CoverBlock, len(counter))
	for i := range counter {
		block[i] = testing.CoverBlock{
			Line0: pos[3*i+0],
			Col0: uint16(pos[3*i+2]),
			Line1: pos[3*i+1],
			Col1: uint16(pos[3*i+2]>>16),
			Stmts: numStmts[i],
		}
	}
	coverBlocks[fileName] = block
}
{{end}}

func main() {
{{if .CoverEnabled}}
	testing.RegisterCover(testing.Cover{
		Mode: {{printf "%q" .CoverMode}},
		Counters: coverCounters,
		Blocks: coverBlocks,
		CoveredPackages: {{printf "%q" .Covered}},
	})
{{end}}
	m := testing.MainStart(matchString, tests, benchmarks, examples)
{{with .TestMain}}
	{{.Package}}.{{.Name}}(m)
{{else}}
	os.Exit(m.Run())
{{end}}
}

`))
            root/go1.4/src/cmd/go/testdata/                                                                     0040755 0000000 0000000 00000000000 12600426232 014630  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/cgocover/                                                            0040755 0000000 0000000 00000000000 12600426232 016437  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/cgocover/p.go                                                        0100644 0000000 0000000 00000000145 12600426226 017225  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p

/*
void
f(void)
{
}
*/
import "C"

var b bool

func F() {
	if b {
		for {
		}
	}
	C.f()
}
                                                                                                                                                                                                                                                                                                                                                                                                                           root/go1.4/src/cmd/go/testdata/cgocover/p_test.go                                                   0100644 0000000 0000000 00000000077 12600426226 020270  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p

import "testing"

func TestF(t *testing.T) {
	F()
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 root/go1.4/src/cmd/go/testdata/dep_test.go                                                          0100644 0000000 0000000 00000000302 12600426226 016761  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package deps

import _ "testing"
                                                                                                                                                                                                                                                                                                                              root/go1.4/src/cmd/go/testdata/example1_test.go                                                     0100644 0000000 0000000 00000000613 12600426226 017732  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Make sure that go test runs Example_Z before Example_A, preserving source order.

package p

import "fmt"

var n int

func Example_Z() {
	n++
	fmt.Println(n)
	// Output: 1
}

func Example_A() {
	n++
	fmt.Println(n)
	// Output: 2
}
                                                                                                                     root/go1.4/src/cmd/go/testdata/example2_test.go                                                     0100644 0000000 0000000 00000000600 12600426226 017727  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Make sure that go test runs Example_Y before Example_B, preserving source order.

package p

import "fmt"

func Example_Y() {
	n++
	fmt.Println(n)
	// Output: 3
}

func Example_B() {
	n++
	fmt.Println(n)
	// Output: 4
}
                                                                                                                                root/go1.4/src/cmd/go/testdata/generate/                                                            0040755 0000000 0000000 00000000000 12600426232 016422  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/generate/test1.go                                                    0100644 0000000 0000000 00000000465 12600426226 020016  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Simple test for go generate.

// We include a build tag that go generate should ignore.

// +build ignore

//go:generate echo Success

package p
                                                                                                                                                                                                           root/go1.4/src/cmd/go/testdata/generate/test2.go                                                    0100644 0000000 0000000 00000000462 12600426226 020014  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test that go generate handles command aliases.

//go:generate -command run echo Now is the time
//go:generate run for all good men

package p
                                                                                                                                                                                                              root/go1.4/src/cmd/go/testdata/generate/test3.go                                                    0100644 0000000 0000000 00000000440 12600426226 020011  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Test go generate variable substitution.

//go:generate echo $GOARCH $GOFILE $GOPACKAGE xyz$GOPACKAGE/$GOFILE/123

package p
                                                                                                                                                                                                                                root/go1.4/src/cmd/go/testdata/importcom/                                                           0040755 0000000 0000000 00000000000 12600426232 016641  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/importcom/bad.go                                                     0100644 0000000 0000000 00000000030 12600426226 017707  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p

import "bad"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/importcom/conflict.go                                                0100644 0000000 0000000 00000000035 12600426226 020767  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p

import "conflict"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   root/go1.4/src/cmd/go/testdata/importcom/src/                                                       0040755 0000000 0000000 00000000000 12600426232 017430  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/importcom/src/bad/                                                   0040755 0000000 0000000 00000000000 12600426232 020156  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/importcom/src/bad/bad.go                                             0100644 0000000 0000000 00000000026 12600426226 021231  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package bad // import
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          root/go1.4/src/cmd/go/testdata/importcom/src/conflict/                                              0040755 0000000 0000000 00000000000 12600426232 021231  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/importcom/src/conflict/a.go                                          0100644 0000000 0000000 00000000037 12600426226 022000  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package conflict // import "a"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 root/go1.4/src/cmd/go/testdata/importcom/src/conflict/b.go                                          0100644 0000000 0000000 00000000042 12600426226 021775  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package conflict /* import "b" */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              root/go1.4/src/cmd/go/testdata/importcom/src/works/                                                 0040755 0000000 0000000 00000000000 12600426232 020575  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/importcom/src/works/x/                                               0040755 0000000 0000000 00000000000 12600426232 021044  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/importcom/src/works/x/x.go                                           0100644 0000000 0000000 00000000036 12600426226 021641  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package x // import "works/x"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  root/go1.4/src/cmd/go/testdata/importcom/src/works/x/x1.go                                          0100644 0000000 0000000 00000000056 12600426226 021724  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package x // important! not an import comment
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  root/go1.4/src/cmd/go/testdata/importcom/src/wrongplace/                                            0040755 0000000 0000000 00000000000 12600426232 021571  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/importcom/src/wrongplace/x.go                                        0100644 0000000 0000000 00000000033 12600426226 022363  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package x // import "my/x"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     root/go1.4/src/cmd/go/testdata/importcom/works.go                                                   0100644 0000000 0000000 00000000036 12600426226 020334  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p

import _ "works/x"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  root/go1.4/src/cmd/go/testdata/importcom/wrongplace.go                                              0100644 0000000 0000000 00000000037 12600426226 021331  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p

import "wrongplace"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 root/go1.4/src/cmd/go/testdata/local/                                                               0040755 0000000 0000000 00000000000 12600426232 015722  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/local/easy.go                                                        0100644 0000000 0000000 00000000103 12600426226 017204  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package main

import "./easysub"

func main() {
	easysub.Hello()
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                             root/go1.4/src/cmd/go/testdata/local/easysub/                                                       0040755 0000000 0000000 00000000000 12600426232 017375  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/local/easysub/easysub.go                                             0100644 0000000 0000000 00000000116 12600426226 021375  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package easysub

import "fmt"

func Hello() {
	fmt.Println("easysub.Hello")
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                  root/go1.4/src/cmd/go/testdata/local/easysub/main.go                                                0100644 0000000 0000000 00000000115 12600426226 020645  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // +build ignore

package main

import "."

func main() {
	easysub.Hello()
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                   root/go1.4/src/cmd/go/testdata/local/hard.go                                                        0100644 0000000 0000000 00000000073 12600426226 017167  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package main

import "./sub"

func main() {
	sub.Hello()
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     root/go1.4/src/cmd/go/testdata/local/sub/                                                           0040755 0000000 0000000 00000000000 12600426232 016513  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/local/sub/sub/                                                       0040755 0000000 0000000 00000000000 12600426232 017304  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/local/sub/sub/subsub.go                                              0100644 0000000 0000000 00000000114 12600426226 021132  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package subsub

import "fmt"

func Hello() {
	fmt.Println("subsub.Hello")
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                    root/go1.4/src/cmd/go/testdata/local/sub/sub.go                                                     0100644 0000000 0000000 00000000154 12600426226 017633  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package sub

import (
	"fmt"

	subsub "./sub"
)

func Hello() {
	fmt.Println("sub.Hello")
	subsub.Hello()
}
                                                                                                                                                                                                                                                                                                                                                                                                                    root/go1.4/src/cmd/go/testdata/norunexample/                                                        0040755 0000000 0000000 00000000000 12600426232 017345  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/norunexample/example_test.go                                         0100644 0000000 0000000 00000000314 12600426226 022364  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package pkg_test

import "os"

func init() {
	os.Stdout.Write([]byte("File with non-runnable example was built.\n"))
}

func Example_test() {
	// This test will not be run, it has no "Output:" comment.
}
                                                                                                                                                                                                                                                                                                                    root/go1.4/src/cmd/go/testdata/norunexample/test_test.go                                            0100644 0000000 0000000 00000000205 12600426226 021707  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package pkg

import (
	"os"
	"testing"
)

func TestBuilt(t *testing.T) {
	os.Stdout.Write([]byte("A normal test was executed.\n"))
}
                                                                                                                                                                                                                                                                                                                                                                                           root/go1.4/src/cmd/go/testdata/shadow/                                                              0040755 0000000 0000000 00000000000 12600426232 016115  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/shadow/root1/                                                        0040755 0000000 0000000 00000000000 12600426232 017161  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/shadow/root1/src/                                                    0040755 0000000 0000000 00000000000 12600426232 017750  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/shadow/root1/src/foo/                                                0040755 0000000 0000000 00000000000 12600426232 020533  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/shadow/root1/src/foo/foo.go                                          0100644 0000000 0000000 00000000014 12600426226 021640  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package foo
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    root/go1.4/src/cmd/go/testdata/shadow/root1/src/math/                                               0040755 0000000 0000000 00000000000 12600426232 020701  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/shadow/root1/src/math/math.go                                        0100644 0000000 0000000 00000000015 12600426226 022155  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package math
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   root/go1.4/src/cmd/go/testdata/shadow/root2/                                                        0040755 0000000 0000000 00000000000 12600426232 017162  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/shadow/root2/src/                                                    0040755 0000000 0000000 00000000000 12600426232 017751  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/shadow/root2/src/foo/                                                0040755 0000000 0000000 00000000000 12600426232 020534  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/shadow/root2/src/foo/foo.go                                          0100644 0000000 0000000 00000000014 12600426226 021641  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package foo
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    root/go1.4/src/cmd/go/testdata/src/                                                                 0040755 0000000 0000000 00000000000 12600426232 015417  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/src/badc/                                                            0040755 0000000 0000000 00000000000 12600426232 016310  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/src/badc/x.c                                                         0100644 0000000 0000000 00000000013 12600426226 016715  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // C code!
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     root/go1.4/src/cmd/go/testdata/src/badc/x.go                                                        0100644 0000000 0000000 00000000015 12600426226 017102  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package badc
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   root/go1.4/src/cmd/go/testdata/src/badpkg/                                                          0040755 0000000 0000000 00000000000 12600426232 016647  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/src/badpkg/x.go                                                      0100644 0000000 0000000 00000000013 12600426226 017437  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        pkg badpkg
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     root/go1.4/src/cmd/go/testdata/src/badtest/                                                         0040755 0000000 0000000 00000000000 12600426232 017045  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/src/badtest/badexec/                                                 0040755 0000000 0000000 00000000000 12600426232 020440  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/src/badtest/badexec/x_test.go                                        0100644 0000000 0000000 00000000063 12600426226 022274  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package badexec

func init() {
	panic("badexec")
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             root/go1.4/src/cmd/go/testdata/src/badtest/badsyntax/                                               0040755 0000000 0000000 00000000000 12600426232 021042  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/src/badtest/badsyntax/x.go                                           0100644 0000000 0000000 00000000022 12600426226 021632  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package badsyntax
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              root/go1.4/src/cmd/go/testdata/src/badtest/badsyntax/x_test.go                                      0100644 0000000 0000000 00000000055 12600426226 022677  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package badsyntax

func func func func func!
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   root/go1.4/src/cmd/go/testdata/src/badtest/badvar/                                                  0040755 0000000 0000000 00000000000 12600426232 020304  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/src/badtest/badvar/x.go                                              0100644 0000000 0000000 00000000017 12600426226 021100  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package badvar
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 root/go1.4/src/cmd/go/testdata/src/badtest/badvar/x_test.go                                         0100644 0000000 0000000 00000000062 12600426226 022137  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package badvar_test

func f() {
	_ = notdefined
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              root/go1.4/src/cmd/go/testdata/src/cgotest/                                                         0040755 0000000 0000000 00000000000 12600426232 017067  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/src/cgotest/m.go                                                     0100644 0000000 0000000 00000000051 12600426226 017646  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package cgotest

import "C"

var _ C.int
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       root/go1.4/src/cmd/go/testdata/src/go-cmd-test/                                                     0040755 0000000 0000000 00000000000 12600426232 017542  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/src/go-cmd-test/helloworld.go                                        0100644 0000000 0000000 00000000066 12600426226 022246  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package main

func main() {
	println("hello world")
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          root/go1.4/src/cmd/go/testdata/src/main_test/                                                       0040755 0000000 0000000 00000000000 12600426232 017402  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/src/main_test/m.go                                                   0100644 0000000 0000000 00000000054 12600426226 020164  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package main

func F()    {}
func main() {}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    root/go1.4/src/cmd/go/testdata/src/main_test/m_test.go                                              0100644 0000000 0000000 00000000133 12600426226 021221  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package main_test

import (
	. "main_test"
	"testing"
)

func Test1(t *testing.T) {
	F()
}
                                                                                                                                                                                                                                                                                                                                                                                                                                     root/go1.4/src/cmd/go/testdata/src/notest/                                                          0040755 0000000 0000000 00000000000 12600426232 016733  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/src/notest/hello.go                                                  0100644 0000000 0000000 00000000105 12600426226 020361  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package notest

func hello() {
	println("hello world")
}
Hello world
                                                                                                                                                                                                                                                                                                                                                                                                                                                           root/go1.4/src/cmd/go/testdata/src/syntaxerror/                                                     0040755 0000000 0000000 00000000000 12600426232 020017  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/src/syntaxerror/x.go                                                 0100644 0000000 0000000 00000000012 12600426226 020606  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      root/go1.4/src/cmd/go/testdata/src/syntaxerror/x_test.go                                            0100644 0000000 0000000 00000000045 12600426226 021653  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p

func f() (x.y, z int) {
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           root/go1.4/src/cmd/go/testdata/src/testcycle/                                                       0040755 0000000 0000000 00000000000 12600426232 017416  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/src/testcycle/p1/                                                    0040755 0000000 0000000 00000000000 12600426232 017736  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/src/testcycle/p1/p1.go                                               0100644 0000000 0000000 00000000111 12600426226 020576  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p1

import _ "testcycle/p2"

func init() {
	println("p1 init")
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                       root/go1.4/src/cmd/go/testdata/src/testcycle/p1/p1_test.go                                          0100644 0000000 0000000 00000000072 12600426226 021643  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p1

import "testing"

func Test(t *testing.T) {
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      root/go1.4/src/cmd/go/testdata/src/testcycle/p2/                                                    0040755 0000000 0000000 00000000000 12600426232 017737  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/src/testcycle/p2/p2.go                                               0100644 0000000 0000000 00000000111 12600426226 020600  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p2

import _ "testcycle/p3"

func init() {
	println("p2 init")
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                       root/go1.4/src/cmd/go/testdata/src/testcycle/p3/                                                    0040755 0000000 0000000 00000000000 12600426232 017740  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/src/testcycle/p3/p3.go                                               0100644 0000000 0000000 00000000060 12600426226 020605  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p3

func init() {
	println("p3 init")
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                root/go1.4/src/cmd/go/testdata/src/testcycle/p3/p3_test.go                                          0100644 0000000 0000000 00000000122 12600426226 021643  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p3

import (
	"testing"

	_ "testcycle/p1"
)

func Test(t *testing.T) {
}
                                                                                                                                                                                                                                                                                                                                                                                                                                              root/go1.4/src/cmd/go/testdata/src/vetpkg/                                                          0040755 0000000 0000000 00000000000 12600426232 016717  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/src/vetpkg/a_test.go                                                 0100644 0000000 0000000 00000000017 12600426226 020523  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p_test
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 root/go1.4/src/cmd/go/testdata/src/vetpkg/b.go                                                      0100644 0000000 0000000 00000000070 12600426226 017464  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p

import "fmt"

func f() {
	fmt.Printf("%d")
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/src/xtestonly/                                                       0040755 0000000 0000000 00000000000 12600426232 017470  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/src/xtestonly/f.go                                                   0100644 0000000 0000000 00000000056 12600426226 020245  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package xtestonly

func F() int { return 42 }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  root/go1.4/src/cmd/go/testdata/src/xtestonly/f_test.go                                              0100644 0000000 0000000 00000000243 12600426226 021302  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package xtestonly_test

import (
	"testing"
	"xtestonly"
)

func TestF(t *testing.T) {
	if x := xtestonly.F(); x != 42 {
		t.Errorf("f.F() = %d, want 42", x)
	}
}
                                                                                                                                                                                                                                                                                                                                                             root/go1.4/src/cmd/go/testdata/standalone_test.go                                                   0100644 0000000 0000000 00000000107 12600426226 020344  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package standalone_test

import "testing"

func Test(t *testing.T) {
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                         root/go1.4/src/cmd/go/testdata/testimport/                                                          0040755 0000000 0000000 00000000000 12600426232 017042  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/testimport/p.go                                                      0100644 0000000 0000000 00000000045 12600426226 017627  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p

func F() int { return 1 }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           root/go1.4/src/cmd/go/testdata/testimport/p1/                                                       0040755 0000000 0000000 00000000000 12600426232 017362  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/testimport/p1/p1.go                                                  0100644 0000000 0000000 00000000046 12600426226 020231  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p1

func F() int { return 1 }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          root/go1.4/src/cmd/go/testdata/testimport/p2/                                                       0040755 0000000 0000000 00000000000 12600426232 017363  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/testimport/p2/p2.go                                                  0100644 0000000 0000000 00000000046 12600426226 020233  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p2

func F() int { return 1 }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          root/go1.4/src/cmd/go/testdata/testimport/p_test.go                                                 0100644 0000000 0000000 00000000156 12600426226 020671  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p

import (
	"./p1"

	"testing"
)

func TestF(t *testing.T) {
	if F() != p1.F() {
		t.Fatal(F())
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                  root/go1.4/src/cmd/go/testdata/testimport/x_test.go                                                 0100644 0000000 0000000 00000000210 12600426226 020670  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p_test

import (
	. "../testimport"

	"./p2"

	"testing"
)

func TestF1(t *testing.T) {
	if F() != p2.F() {
		t.Fatal(F())
	}
}
                                                                                                                                                                                                                                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/testinternal/                                                        0040755 0000000 0000000 00000000000 12600426232 017344  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/testinternal/p.go                                                    0100644 0000000 0000000 00000000050 12600426226 020125  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p

import _ "net/http/internal"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/testinternal2/                                                       0040755 0000000 0000000 00000000000 12600426232 017426  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/testinternal2/p.go                                                   0100644 0000000 0000000 00000000051 12600426226 020210  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p

import _ "./x/y/z/internal/w"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       root/go1.4/src/cmd/go/testdata/testinternal2/x/                                                     0040755 0000000 0000000 00000000000 12600426232 017675  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/testinternal2/x/y/                                                   0040755 0000000 0000000 00000000000 12600426232 020145  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/testinternal2/x/y/z/                                                 0040755 0000000 0000000 00000000000 12600426232 020416  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/testinternal2/x/y/z/internal/                                        0040755 0000000 0000000 00000000000 12600426232 022232  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/testinternal2/x/y/z/internal/w/                                      0040755 0000000 0000000 00000000000 12600426232 022500  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/testinternal2/x/y/z/internal/w/w.go                                  0100644 0000000 0000000 00000000012 12600426226 023266  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package w
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      root/go1.4/src/cmd/go/testdata/testonly/                                                            0040755 0000000 0000000 00000000000 12600426232 016511  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/go/testdata/testonly/p_test.go                                                   0100644 0000000 0000000 00000000012 12600426226 020327  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package p
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      root/go1.4/src/cmd/go/testflag.go                                                                   0100644 0000000 0000000 00000021723 12600426226 015164  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
	"os"
	"strconv"
	"strings"
)

// The flag handling part of go test is large and distracting.
// We can't use the flag package because some of the flags from
// our command line are for us, and some are for 6.out, and
// some are for both.

var usageMessage = `Usage of go test:
  -c=false: compile but do not run the test binary
  -file=file_test.go: specify file to use for tests;
      use multiple times for multiple files
  -p=n: build and test up to n packages in parallel
  -x=false: print command lines as they are executed

  // These flags can be passed with or without a "test." prefix: -v or -test.v.
  -bench="": passes -test.bench to test
  -benchmem=false: print memory allocation statistics for benchmarks
  -benchtime=1s: passes -test.benchtime to test
  -cover=false: enable coverage analysis
  -covermode="set": specifies mode for coverage analysis
  -coverpkg="": comma-separated list of packages for coverage analysis
  -coverprofile="": passes -test.coverprofile to test if -cover
  -cpu="": passes -test.cpu to test
  -cpuprofile="": passes -test.cpuprofile to test
  -memprofile="": passes -test.memprofile to test
  -memprofilerate=0: passes -test.memprofilerate to test
  -blockprofile="": pases -test.blockprofile to test
  -blockprofilerate=0: passes -test.blockprofilerate to test
  -outputdir=$PWD: passes -test.outputdir to test
  -parallel=0: passes -test.parallel to test
  -run="": passes -test.run to test
  -short=false: passes -test.short to test
  -timeout=0: passes -test.timeout to test
  -v=false: passes -test.v to test
`

// usage prints a usage message and exits.
func testUsage() {
	fmt.Fprint(os.Stderr, usageMessage)
	setExitStatus(2)
	exit()
}

// testFlagSpec defines a flag we know about.
type testFlagSpec struct {
	name       string
	boolVar    *bool
	passToTest bool // pass to Test
	multiOK    bool // OK to have multiple instances
	present    bool // flag has been seen
}

// testFlagDefn is the set of flags we process.
var testFlagDefn = []*testFlagSpec{
	// local.
	{name: "c", boolVar: &testC},
	{name: "cover", boolVar: &testCover},
	{name: "coverpkg"},
	{name: "o"},

	// build flags.
	{name: "a", boolVar: &buildA},
	{name: "n", boolVar: &buildN},
	{name: "p"},
	{name: "x", boolVar: &buildX},
	{name: "i", boolVar: &buildI},
	{name: "work", boolVar: &buildWork},
	{name: "ccflags"},
	{name: "gcflags"},
	{name: "exec"},
	{name: "ldflags"},
	{name: "gccgoflags"},
	{name: "tags"},
	{name: "compiler"},
	{name: "race", boolVar: &buildRace},
	{name: "installsuffix"},

	// passed to 6.out, adding a "test." prefix to the name if necessary: -v becomes -test.v.
	{name: "bench", passToTest: true},
	{name: "benchmem", boolVar: new(bool), passToTest: true},
	{name: "benchtime", passToTest: true},
	{name: "covermode"},
	{name: "coverprofile", passToTest: true},
	{name: "cpu", passToTest: true},
	{name: "cpuprofile", passToTest: true},
	{name: "memprofile", passToTest: true},
	{name: "memprofilerate", passToTest: true},
	{name: "blockprofile", passToTest: true},
	{name: "blockprofilerate", passToTest: true},
	{name: "outputdir", passToTest: true},
	{name: "parallel", passToTest: true},
	{name: "run", passToTest: true},
	{name: "short", boolVar: new(bool), passToTest: true},
	{name: "timeout", passToTest: true},
	{name: "v", boolVar: &testV, passToTest: true},
}

// testFlags processes the command line, grabbing -x and -c, rewriting known flags
// to have "test" before them, and reading the command line for the 6.out.
// Unfortunately for us, we need to do our own flag processing because go test
// grabs some flags but otherwise its command line is just a holding place for
// pkg.test's arguments.
// We allow known flags both before and after the package name list,
// to allow both
//	go test fmt -custom-flag-for-fmt-test
//	go test -x math
func testFlags(args []string) (packageNames, passToTest []string) {
	inPkg := false
	outputDir := ""
	for i := 0; i < len(args); i++ {
		if !strings.HasPrefix(args[i], "-") {
			if !inPkg && packageNames == nil {
				// First package name we've seen.
				inPkg = true
			}
			if inPkg {
				packageNames = append(packageNames, args[i])
				continue
			}
		}

		if inPkg {
			// Found an argument beginning with "-"; end of package list.
			inPkg = false
		}

		f, value, extraWord := testFlag(args, i)
		if f == nil {
			// This is a flag we do not know; we must assume
			// that any args we see after this might be flag
			// arguments, not package names.
			inPkg = false
			if packageNames == nil {
				// make non-nil: we have seen the empty package list
				packageNames = []string{}
			}
			passToTest = append(passToTest, args[i])
			continue
		}
		var err error
		switch f.name {
		// bool flags.
		case "a", "c", "i", "n", "x", "v", "race", "cover", "work":
			setBoolFlag(f.boolVar, value)
		case "o":
			testO = value
			testNeedBinary = true
		case "p":
			setIntFlag(&buildP, value)
		case "exec":
			execCmd, err = splitQuotedFields(value)
			if err != nil {
				fatalf("invalid flag argument for -%s: %v", f.name, err)
			}
		case "ccflags":
			buildCcflags, err = splitQuotedFields(value)
			if err != nil {
				fatalf("invalid flag argument for -%s: %v", f.name, err)
			}
		case "gcflags":
			buildGcflags, err = splitQuotedFields(value)
			if err != nil {
				fatalf("invalid flag argument for -%s: %v", f.name, err)
			}
		case "ldflags":
			buildLdflags, err = splitQuotedFields(value)
			if err != nil {
				fatalf("invalid flag argument for -%s: %v", f.name, err)
			}
		case "gccgoflags":
			buildGccgoflags, err = splitQuotedFields(value)
			if err != nil {
				fatalf("invalid flag argument for -%s: %v", f.name, err)
			}
		case "tags":
			buildContext.BuildTags = strings.Fields(value)
		case "compiler":
			buildCompiler{}.Set(value)
		case "bench":
			// record that we saw the flag; don't care about the value
			testBench = true
		case "timeout":
			testTimeout = value
		case "blockprofile", "cpuprofile", "memprofile":
			testProfile = true
			testNeedBinary = true
		case "coverpkg":
			testCover = true
			if value == "" {
				testCoverPaths = nil
			} else {
				testCoverPaths = strings.Split(value, ",")
			}
		case "coverprofile":
			testCover = true
			testProfile = true
		case "covermode":
			switch value {
			case "set", "count", "atomic":
				testCoverMode = value
			default:
				fatalf("invalid flag argument for -cover: %q", value)
			}
			testCover = true
		case "outputdir":
			outputDir = value
		}
		if extraWord {
			i++
		}
		if f.passToTest {
			passToTest = append(passToTest, "-test."+f.name+"="+value)
		}
	}

	if testCoverMode == "" {
		testCoverMode = "set"
		if buildRace {
			// Default coverage mode is atomic when -race is set.
			testCoverMode = "atomic"
		}
	}

	// Tell the test what directory we're running in, so it can write the profiles there.
	if testProfile && outputDir == "" {
		dir, err := os.Getwd()
		if err != nil {
			fatalf("error from os.Getwd: %s", err)
		}
		passToTest = append(passToTest, "-test.outputdir", dir)
	}
	return
}

// testFlag sees if argument i is a known flag and returns its definition, value, and whether it consumed an extra word.
func testFlag(args []string, i int) (f *testFlagSpec, value string, extra bool) {
	arg := args[i]
	if strings.HasPrefix(arg, "--") { // reduce two minuses to one
		arg = arg[1:]
	}
	switch arg {
	case "-?", "-h", "-help":
		usage()
	}
	if arg == "" || arg[0] != '-' {
		return
	}
	name := arg[1:]
	// If there's already "test.", drop it for now.
	name = strings.TrimPrefix(name, "test.")
	equals := strings.Index(name, "=")
	if equals >= 0 {
		value = name[equals+1:]
		name = name[:equals]
	}
	for _, f = range testFlagDefn {
		if name == f.name {
			// Booleans are special because they have modes -x, -x=true, -x=false.
			if f.boolVar != nil {
				if equals < 0 { // otherwise, it's been set and will be verified in setBoolFlag
					value = "true"
				} else {
					// verify it parses
					setBoolFlag(new(bool), value)
				}
			} else { // Non-booleans must have a value.
				extra = equals < 0
				if extra {
					if i+1 >= len(args) {
						testSyntaxError("missing argument for flag " + f.name)
					}
					value = args[i+1]
				}
			}
			if f.present && !f.multiOK {
				testSyntaxError(f.name + " flag may be set only once")
			}
			f.present = true
			return
		}
	}
	f = nil
	return
}

// setBoolFlag sets the addressed boolean to the value.
func setBoolFlag(flag *bool, value string) {
	x, err := strconv.ParseBool(value)
	if err != nil {
		testSyntaxError("illegal bool flag value " + value)
	}
	*flag = x
}

// setIntFlag sets the addressed integer to the value.
func setIntFlag(flag *int, value string) {
	x, err := strconv.Atoi(value)
	if err != nil {
		testSyntaxError("illegal int flag value " + value)
	}
	*flag = x
}

func testSyntaxError(msg string) {
	fmt.Fprintf(os.Stderr, "go test: %s\n", msg)
	fmt.Fprintf(os.Stderr, `run "go help test" or "go help testflag" for more information`+"\n")
	os.Exit(2)
}
                                             root/go1.4/src/cmd/go/testgo.go                                                                     0100644 0000000 0000000 00000001103 12600426226 014646  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file contains extra hooks for testing the go command.
// It is compiled into the Go binary only when building the
// test copy; it does not get compiled into the standard go
// command, so these testing hooks are not present in the
// go command that everyone uses.

// +build testgo

package main

import "os"

func init() {
	if v := os.Getenv("TESTGO_IS_GO_RELEASE"); v != "" {
		isGoRelease = v == "1"
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                             root/go1.4/src/cmd/go/tool.go                                                                       0100644 0000000 0000000 00000006631 12600426226 014331  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
	"go/build"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"sort"
	"strings"
)

var cmdTool = &Command{
	Run:       runTool,
	UsageLine: "tool [-n] command [args...]",
	Short:     "run specified go tool",
	Long: `
Tool runs the go tool command identified by the arguments.
With no arguments it prints the list of known tools.

The -n flag causes tool to print the command that would be
executed but not execute it.

For more about each tool command, see 'go tool command -h'.
`,
}

var (
	toolGOOS      = runtime.GOOS
	toolGOARCH    = runtime.GOARCH
	toolIsWindows = toolGOOS == "windows"
	toolDir       = build.ToolDir

	toolN bool
)

func init() {
	cmdTool.Flag.BoolVar(&toolN, "n", false, "")
}

const toolWindowsExtension = ".exe"

func tool(toolName string) string {
	toolPath := filepath.Join(toolDir, toolName)
	if toolIsWindows {
		toolPath += toolWindowsExtension
	}
	// Give a nice message if there is no tool with that name.
	if _, err := os.Stat(toolPath); err != nil {
		if isInGoToolsRepo(toolName) {
			fmt.Fprintf(os.Stderr, "go tool: no such tool %q; to install:\n\tgo get golang.org/x/tools/cmd/%s\n", toolName, toolName)
		} else {
			fmt.Fprintf(os.Stderr, "go tool: no such tool %q\n", toolName)
		}
		setExitStatus(3)
		exit()
	}
	return toolPath
}

func isInGoToolsRepo(toolName string) bool {
	switch toolName {
	case "cover", "vet":
		return true
	}
	return false
}

func runTool(cmd *Command, args []string) {
	if len(args) == 0 {
		listTools()
		return
	}
	toolName := args[0]
	// The tool name must be lower-case letters, numbers or underscores.
	for _, c := range toolName {
		switch {
		case 'a' <= c && c <= 'z', '0' <= c && c <= '9', c == '_':
		default:
			fmt.Fprintf(os.Stderr, "go tool: bad tool name %q\n", toolName)
			setExitStatus(2)
			return
		}
	}
	toolPath := tool(toolName)
	if toolPath == "" {
		return
	}
	if toolN {
		fmt.Printf("%s %s\n", toolPath, strings.Join(args[1:], " "))
		return
	}
	toolCmd := &exec.Cmd{
		Path:   toolPath,
		Args:   args,
		Stdin:  os.Stdin,
		Stdout: os.Stdout,
		Stderr: os.Stderr,
	}
	err := toolCmd.Run()
	if err != nil {
		// Only print about the exit status if the command
		// didn't even run (not an ExitError) or it didn't exit cleanly
		// or we're printing command lines too (-x mode).
		// Assume if command exited cleanly (even with non-zero status)
		// it printed any messages it wanted to print.
		if e, ok := err.(*exec.ExitError); !ok || !e.Exited() || buildX {
			fmt.Fprintf(os.Stderr, "go tool %s: %s\n", toolName, err)
		}
		setExitStatus(1)
		return
	}
}

// listTools prints a list of the available tools in the tools directory.
func listTools() {
	f, err := os.Open(toolDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "go tool: no tool directory: %s\n", err)
		setExitStatus(2)
		return
	}
	defer f.Close()
	names, err := f.Readdirnames(-1)
	if err != nil {
		fmt.Fprintf(os.Stderr, "go tool: can't read directory: %s\n", err)
		setExitStatus(2)
		return
	}

	sort.Strings(names)
	for _, name := range names {
		// Unify presentation by going to lower case.
		name = strings.ToLower(name)
		// If it's windows, don't show the .exe suffix.
		if toolIsWindows && strings.HasSuffix(name, toolWindowsExtension) {
			name = name[:len(name)-len(toolWindowsExtension)]
		}
		fmt.Println(name)
	}
}
                                                                                                       root/go1.4/src/cmd/go/vcs.go                                                                        0100644 0000000 0000000 00000060667 12600426226 014160  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2012 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
)

// A vcsCmd describes how to use a version control system
// like Mercurial, Git, or Subversion.
type vcsCmd struct {
	name string
	cmd  string // name of binary to invoke command

	createCmd   string // command to download a fresh copy of a repository
	downloadCmd string // command to download updates into an existing repository

	tagCmd         []tagCmd // commands to list tags
	tagLookupCmd   []tagCmd // commands to lookup tags before running tagSyncCmd
	tagSyncCmd     string   // command to sync to specific tag
	tagSyncDefault string   // command to sync to default tag

	scheme  []string
	pingCmd string

	remoteRepo  func(v *vcsCmd, rootDir string) (remoteRepo string, err error)
	resolveRepo func(v *vcsCmd, rootDir, remoteRepo string) (realRepo string, err error)
}

// A tagCmd describes a command to list available tags
// that can be passed to tagSyncCmd.
type tagCmd struct {
	cmd     string // command to list tags
	pattern string // regexp to extract tags from list
}

// vcsList lists the known version control systems
var vcsList = []*vcsCmd{
	vcsHg,
	vcsGit,
	vcsSvn,
	vcsBzr,
}

// vcsByCmd returns the version control system for the given
// command name (hg, git, svn, bzr).
func vcsByCmd(cmd string) *vcsCmd {
	for _, vcs := range vcsList {
		if vcs.cmd == cmd {
			return vcs
		}
	}
	return nil
}

// vcsHg describes how to use Mercurial.
var vcsHg = &vcsCmd{
	name: "Mercurial",
	cmd:  "hg",

	createCmd:   "clone -U {repo} {dir}",
	downloadCmd: "pull",

	// We allow both tag and branch names as 'tags'
	// for selecting a version.  This lets people have
	// a go.release.r60 branch and a go1 branch
	// and make changes in both, without constantly
	// editing .hgtags.
	tagCmd: []tagCmd{
		{"tags", `^(\S+)`},
		{"branches", `^(\S+)`},
	},
	tagSyncCmd:     "update -r {tag}",
	tagSyncDefault: "update default",

	scheme:     []string{"https", "http", "ssh"},
	pingCmd:    "identify {scheme}://{repo}",
	remoteRepo: hgRemoteRepo,
}

func hgRemoteRepo(vcsHg *vcsCmd, rootDir string) (remoteRepo string, err error) {
	out, err := vcsHg.runOutput(rootDir, "paths default")
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(string(out)), nil
}

// vcsGit describes how to use Git.
var vcsGit = &vcsCmd{
	name: "Git",
	cmd:  "git",

	createCmd:   "clone {repo} {dir}",
	downloadCmd: "pull --ff-only",

	tagCmd: []tagCmd{
		// tags/xxx matches a git tag named xxx
		// origin/xxx matches a git branch named xxx on the default remote repository
		{"show-ref", `(?:tags|origin)/(\S+)$`},
	},
	tagLookupCmd: []tagCmd{
		{"show-ref tags/{tag} origin/{tag}", `((?:tags|origin)/\S+)$`},
	},
	tagSyncCmd:     "checkout {tag}",
	tagSyncDefault: "checkout master",

	scheme:     []string{"git", "https", "http", "git+ssh"},
	pingCmd:    "ls-remote {scheme}://{repo}",
	remoteRepo: gitRemoteRepo,
}

func gitRemoteRepo(vcsGit *vcsCmd, rootDir string) (remoteRepo string, err error) {
	outb, err := vcsGit.runOutput(rootDir, "remote -v")
	if err != nil {
		return "", err
	}
	out := string(outb)

	// Expect:
	// origin	https://github.com/rsc/pdf (fetch)
	// origin	https://github.com/rsc/pdf (push)
	// use first line only.

	if !strings.HasPrefix(out, "origin\t") {
		return "", fmt.Errorf("unable to parse output of git remote -v")
	}
	out = strings.TrimPrefix(out, "origin\t")
	i := strings.Index(out, "\n")
	if i < 0 {
		return "", fmt.Errorf("unable to parse output of git remote -v")
	}
	out = out[:i]
	i = strings.LastIndex(out, " ")
	if i < 0 {
		return "", fmt.Errorf("unable to parse output of git remote -v")
	}
	out = out[:i]
	return strings.TrimSpace(string(out)), nil
}

// vcsBzr describes how to use Bazaar.
var vcsBzr = &vcsCmd{
	name: "Bazaar",
	cmd:  "bzr",

	createCmd: "branch {repo} {dir}",

	// Without --overwrite bzr will not pull tags that changed.
	// Replace by --overwrite-tags after http://pad.lv/681792 goes in.
	downloadCmd: "pull --overwrite",

	tagCmd:         []tagCmd{{"tags", `^(\S+)`}},
	tagSyncCmd:     "update -r {tag}",
	tagSyncDefault: "update -r revno:-1",

	scheme:      []string{"https", "http", "bzr", "bzr+ssh"},
	pingCmd:     "info {scheme}://{repo}",
	remoteRepo:  bzrRemoteRepo,
	resolveRepo: bzrResolveRepo,
}

func bzrRemoteRepo(vcsBzr *vcsCmd, rootDir string) (remoteRepo string, err error) {
	outb, err := vcsBzr.runOutput(rootDir, "config parent_location")
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(string(outb)), nil
}

func bzrResolveRepo(vcsBzr *vcsCmd, rootDir, remoteRepo string) (realRepo string, err error) {
	outb, err := vcsBzr.runOutput(rootDir, "info "+remoteRepo)
	if err != nil {
		return "", err
	}
	out := string(outb)

	// Expect:
	// ...
	//   (branch root|repository branch): <URL>
	// ...

	found := false
	for _, prefix := range []string{"\n  branch root: ", "\n  repository branch: "} {
		i := strings.Index(out, prefix)
		if i >= 0 {
			out = out[i+len(prefix):]
			found = true
			break
		}
	}
	if !found {
		return "", fmt.Errorf("unable to parse output of bzr info")
	}

	i := strings.Index(out, "\n")
	if i < 0 {
		return "", fmt.Errorf("unable to parse output of bzr info")
	}
	out = out[:i]
	return strings.TrimSpace(string(out)), nil
}

// vcsSvn describes how to use Subversion.
var vcsSvn = &vcsCmd{
	name: "Subversion",
	cmd:  "svn",

	createCmd:   "checkout {repo} {dir}",
	downloadCmd: "update",

	// There is no tag command in subversion.
	// The branch information is all in the path names.

	scheme:     []string{"https", "http", "svn", "svn+ssh"},
	pingCmd:    "info {scheme}://{repo}",
	remoteRepo: svnRemoteRepo,
}

func svnRemoteRepo(vcsSvn *vcsCmd, rootDir string) (remoteRepo string, err error) {
	outb, err := vcsSvn.runOutput(rootDir, "info")
	if err != nil {
		return "", err
	}
	out := string(outb)

	// Expect:
	// ...
	// Repository Root: <URL>
	// ...

	i := strings.Index(out, "\nRepository Root: ")
	if i < 0 {
		return "", fmt.Errorf("unable to parse output of svn info")
	}
	out = out[i+len("\nRepository Root: "):]
	i = strings.Index(out, "\n")
	if i < 0 {
		return "", fmt.Errorf("unable to parse output of svn info")
	}
	out = out[:i]
	return strings.TrimSpace(string(out)), nil
}

func (v *vcsCmd) String() string {
	return v.name
}

// run runs the command line cmd in the given directory.
// keyval is a list of key, value pairs.  run expands
// instances of {key} in cmd into value, but only after
// splitting cmd into individual arguments.
// If an error occurs, run prints the command line and the
// command's combined stdout+stderr to standard error.
// Otherwise run discards the command's output.
func (v *vcsCmd) run(dir string, cmd string, keyval ...string) error {
	_, err := v.run1(dir, cmd, keyval, true)
	return err
}

// runVerboseOnly is like run but only generates error output to standard error in verbose mode.
func (v *vcsCmd) runVerboseOnly(dir string, cmd string, keyval ...string) error {
	_, err := v.run1(dir, cmd, keyval, false)
	return err
}

// runOutput is like run but returns the output of the command.
func (v *vcsCmd) runOutput(dir string, cmd string, keyval ...string) ([]byte, error) {
	return v.run1(dir, cmd, keyval, true)
}

// run1 is the generalized implementation of run and runOutput.
func (v *vcsCmd) run1(dir string, cmdline string, keyval []string, verbose bool) ([]byte, error) {
	m := make(map[string]string)
	for i := 0; i < len(keyval); i += 2 {
		m[keyval[i]] = keyval[i+1]
	}
	args := strings.Fields(cmdline)
	for i, arg := range args {
		args[i] = expand(m, arg)
	}

	_, err := exec.LookPath(v.cmd)
	if err != nil {
		fmt.Fprintf(os.Stderr,
			"go: missing %s command. See http://golang.org/s/gogetcmd\n",
			v.name)
		return nil, err
	}

	cmd := exec.Command(v.cmd, args...)
	cmd.Dir = dir
	cmd.Env = envForDir(cmd.Dir)
	if buildX {
		fmt.Printf("cd %s\n", dir)
		fmt.Printf("%s %s\n", v.cmd, strings.Join(args, " "))
	}
	var buf bytes.Buffer
	cmd.Stdout = &buf
	cmd.Stderr = &buf
	err = cmd.Run()
	out := buf.Bytes()
	if err != nil {
		if verbose || buildV {
			fmt.Fprintf(os.Stderr, "# cd %s; %s %s\n", dir, v.cmd, strings.Join(args, " "))
			os.Stderr.Write(out)
		}
		return nil, err
	}
	return out, nil
}

// ping pings to determine scheme to use.
func (v *vcsCmd) ping(scheme, repo string) error {
	return v.runVerboseOnly(".", v.pingCmd, "scheme", scheme, "repo", repo)
}

// create creates a new copy of repo in dir.
// The parent of dir must exist; dir must not.
func (v *vcsCmd) create(dir, repo string) error {
	return v.run(".", v.createCmd, "dir", dir, "repo", repo)
}

// download downloads any new changes for the repo in dir.
func (v *vcsCmd) download(dir string) error {
	if err := v.fixDetachedHead(dir); err != nil {
		return err
	}
	return v.run(dir, v.downloadCmd)
}

// fixDetachedHead switches a Git repository in dir from a detached head to the master branch.
// Go versions before 1.2 downloaded Git repositories in an unfortunate way
// that resulted in the working tree state being on a detached head.
// That meant the repository was not usable for normal Git operations.
// Go 1.2 fixed that, but we can't pull into a detached head, so if this is
// a Git repository we check for being on a detached head and switch to the
// real branch, almost always called "master".
// TODO(dsymonds): Consider removing this for Go 1.3.
func (v *vcsCmd) fixDetachedHead(dir string) error {
	if v != vcsGit {
		return nil
	}

	// "git symbolic-ref HEAD" succeeds iff we are not on a detached head.
	if err := v.runVerboseOnly(dir, "symbolic-ref HEAD"); err == nil {
		// not on a detached head
		return nil
	}
	if buildV {
		log.Printf("%s on detached head; repairing", dir)
	}
	return v.run(dir, "checkout master")
}

// tags returns the list of available tags for the repo in dir.
func (v *vcsCmd) tags(dir string) ([]string, error) {
	var tags []string
	for _, tc := range v.tagCmd {
		out, err := v.runOutput(dir, tc.cmd)
		if err != nil {
			return nil, err
		}
		re := regexp.MustCompile(`(?m-s)` + tc.pattern)
		for _, m := range re.FindAllStringSubmatch(string(out), -1) {
			tags = append(tags, m[1])
		}
	}
	return tags, nil
}

// tagSync syncs the repo in dir to the named tag,
// which either is a tag returned by tags or is v.tagDefault.
func (v *vcsCmd) tagSync(dir, tag string) error {
	if v.tagSyncCmd == "" {
		return nil
	}
	if tag != "" {
		for _, tc := range v.tagLookupCmd {
			out, err := v.runOutput(dir, tc.cmd, "tag", tag)
			if err != nil {
				return err
			}
			re := regexp.MustCompile(`(?m-s)` + tc.pattern)
			m := re.FindStringSubmatch(string(out))
			if len(m) > 1 {
				tag = m[1]
				break
			}
		}
	}
	if tag == "" && v.tagSyncDefault != "" {
		return v.run(dir, v.tagSyncDefault)
	}
	return v.run(dir, v.tagSyncCmd, "tag", tag)
}

// A vcsPath describes how to convert an import path into a
// version control system and repository name.
type vcsPath struct {
	prefix string                              // prefix this description applies to
	re     string                              // pattern for import path
	repo   string                              // repository to use (expand with match of re)
	vcs    string                              // version control system to use (expand with match of re)
	check  func(match map[string]string) error // additional checks
	ping   bool                                // ping for scheme to use to download repo

	regexp *regexp.Regexp // cached compiled form of re
}

// vcsForDir inspects dir and its parents to determine the
// version control system and code repository to use.
// On return, root is the import path
// corresponding to the root of the repository
// (thus root is a prefix of importPath).
func vcsForDir(p *Package) (vcs *vcsCmd, root string, err error) {
	// Clean and double-check that dir is in (a subdirectory of) srcRoot.
	dir := filepath.Clean(p.Dir)
	srcRoot := filepath.Clean(p.build.SrcRoot)
	if len(dir) <= len(srcRoot) || dir[len(srcRoot)] != filepath.Separator {
		return nil, "", fmt.Errorf("directory %q is outside source root %q", dir, srcRoot)
	}

	origDir := dir
	for len(dir) > len(srcRoot) {
		for _, vcs := range vcsList {
			if fi, err := os.Stat(filepath.Join(dir, "."+vcs.cmd)); err == nil && fi.IsDir() {
				return vcs, dir[len(srcRoot)+1:], nil
			}
		}

		// Move to parent.
		ndir := filepath.Dir(dir)
		if len(ndir) >= len(dir) {
			// Shouldn't happen, but just in case, stop.
			break
		}
		dir = ndir
	}

	return nil, "", fmt.Errorf("directory %q is not using a known version control system", origDir)
}

// repoRoot represents a version control system, a repo, and a root of
// where to put it on disk.
type repoRoot struct {
	vcs *vcsCmd

	// repo is the repository URL, including scheme
	repo string

	// root is the import path corresponding to the root of the
	// repository
	root string
}

var httpPrefixRE = regexp.MustCompile(`^https?:`)

// repoRootForImportPath analyzes importPath to determine the
// version control system, and code repository to use.
func repoRootForImportPath(importPath string) (*repoRoot, error) {
	rr, err := repoRootForImportPathStatic(importPath, "")
	if err == errUnknownSite {
		// If there are wildcards, look up the thing before the wildcard,
		// hoping it applies to the wildcarded parts too.
		// This makes 'go get rsc.io/pdf/...' work in a fresh GOPATH.
		lookup := strings.TrimSuffix(importPath, "/...")
		if i := strings.Index(lookup, "/.../"); i >= 0 {
			lookup = lookup[:i]
		}
		rr, err = repoRootForImportDynamic(lookup)

		// repoRootForImportDynamic returns error detail
		// that is irrelevant if the user didn't intend to use a
		// dynamic import in the first place.
		// Squelch it.
		if err != nil {
			if buildV {
				log.Printf("import %q: %v", importPath, err)
			}
			err = fmt.Errorf("unrecognized import path %q", importPath)
		}
	}

	if err == nil && strings.Contains(importPath, "...") && strings.Contains(rr.root, "...") {
		// Do not allow wildcards in the repo root.
		rr = nil
		err = fmt.Errorf("cannot expand ... in %q", importPath)
	}
	return rr, err
}

var errUnknownSite = errors.New("dynamic lookup required to find mapping")

// repoRootForImportPathStatic attempts to map importPath to a
// repoRoot using the commonly-used VCS hosting sites in vcsPaths
// (github.com/user/dir), or from a fully-qualified importPath already
// containing its VCS type (foo.com/repo.git/dir)
//
// If scheme is non-empty, that scheme is forced.
func repoRootForImportPathStatic(importPath, scheme string) (*repoRoot, error) {
	// A common error is to use https://packagepath because that's what
	// hg and git require. Diagnose this helpfully.
	if loc := httpPrefixRE.FindStringIndex(importPath); loc != nil {
		// The importPath has been cleaned, so has only one slash. The pattern
		// ignores the slashes; the error message puts them back on the RHS at least.
		return nil, fmt.Errorf("%q not allowed in import path", importPath[loc[0]:loc[1]]+"//")
	}
	for _, srv := range vcsPaths {
		if !strings.HasPrefix(importPath, srv.prefix) {
			continue
		}
		m := srv.regexp.FindStringSubmatch(importPath)
		if m == nil {
			if srv.prefix != "" {
				return nil, fmt.Errorf("invalid %s import path %q", srv.prefix, importPath)
			}
			continue
		}

		// Build map of named subexpression matches for expand.
		match := map[string]string{
			"prefix": srv.prefix,
			"import": importPath,
		}
		for i, name := range srv.regexp.SubexpNames() {
			if name != "" && match[name] == "" {
				match[name] = m[i]
			}
		}
		if srv.vcs != "" {
			match["vcs"] = expand(match, srv.vcs)
		}
		if srv.repo != "" {
			match["repo"] = expand(match, srv.repo)
		}
		if srv.check != nil {
			if err := srv.check(match); err != nil {
				return nil, err
			}
		}
		vcs := vcsByCmd(match["vcs"])
		if vcs == nil {
			return nil, fmt.Errorf("unknown version control system %q", match["vcs"])
		}
		if srv.ping {
			if scheme != "" {
				match["repo"] = scheme + "://" + match["repo"]
			} else {
				for _, scheme := range vcs.scheme {
					if vcs.ping(scheme, match["repo"]) == nil {
						match["repo"] = scheme + "://" + match["repo"]
						break
					}
				}
			}
		}
		rr := &repoRoot{
			vcs:  vcs,
			repo: match["repo"],
			root: match["root"],
		}
		return rr, nil
	}
	return nil, errUnknownSite
}

// repoRootForImportDynamic finds a *repoRoot for a custom domain that's not
// statically known by repoRootForImportPathStatic.
//
// This handles "vanity import paths" like "name.tld/pkg/foo".
func repoRootForImportDynamic(importPath string) (*repoRoot, error) {
	slash := strings.Index(importPath, "/")
	if slash < 0 {
		return nil, errors.New("import path does not contain a slash")
	}
	host := importPath[:slash]
	if !strings.Contains(host, ".") {
		return nil, errors.New("import path does not begin with hostname")
	}
	urlStr, body, err := httpsOrHTTP(importPath)
	if err != nil {
		return nil, fmt.Errorf("http/https fetch: %v", err)
	}
	defer body.Close()
	imports, err := parseMetaGoImports(body)
	if err != nil {
		return nil, fmt.Errorf("parsing %s: %v", importPath, err)
	}
	metaImport, err := matchGoImport(imports, importPath)
	if err != nil {
		if err != errNoMatch {
			return nil, fmt.Errorf("parse %s: %v", urlStr, err)
		}
		return nil, fmt.Errorf("parse %s: no go-import meta tags", urlStr)
	}
	if buildV {
		log.Printf("get %q: found meta tag %#v at %s", importPath, metaImport, urlStr)
	}
	// If the import was "uni.edu/bob/project", which said the
	// prefix was "uni.edu" and the RepoRoot was "evilroot.com",
	// make sure we don't trust Bob and check out evilroot.com to
	// "uni.edu" yet (possibly overwriting/preempting another
	// non-evil student).  Instead, first verify the root and see
	// if it matches Bob's claim.
	if metaImport.Prefix != importPath {
		if buildV {
			log.Printf("get %q: verifying non-authoritative meta tag", importPath)
		}
		urlStr0 := urlStr
		urlStr, body, err = httpsOrHTTP(metaImport.Prefix)
		if err != nil {
			return nil, fmt.Errorf("fetch %s: %v", urlStr, err)
		}
		imports, err := parseMetaGoImports(body)
		if err != nil {
			return nil, fmt.Errorf("parsing %s: %v", importPath, err)
		}
		if len(imports) == 0 {
			return nil, fmt.Errorf("fetch %s: no go-import meta tag", urlStr)
		}
		metaImport2, err := matchGoImport(imports, importPath)
		if err != nil || metaImport != metaImport2 {
			return nil, fmt.Errorf("%s and %s disagree about go-import for %s", urlStr0, urlStr, metaImport.Prefix)
		}
	}

	if !strings.Contains(metaImport.RepoRoot, "://") {
		return nil, fmt.Errorf("%s: invalid repo root %q; no scheme", urlStr, metaImport.RepoRoot)
	}
	rr := &repoRoot{
		vcs:  vcsByCmd(metaImport.VCS),
		repo: metaImport.RepoRoot,
		root: metaImport.Prefix,
	}
	if rr.vcs == nil {
		return nil, fmt.Errorf("%s: unknown vcs %q", urlStr, metaImport.VCS)
	}
	return rr, nil
}

// metaImport represents the parsed <meta name="go-import"
// content="prefix vcs reporoot" /> tags from HTML files.
type metaImport struct {
	Prefix, VCS, RepoRoot string
}

// errNoMatch is returned from matchGoImport when there's no applicable match.
var errNoMatch = errors.New("no import match")

// matchGoImport returns the metaImport from imports matching importPath.
// An error is returned if there are multiple matches.
// errNoMatch is returned if none match.
func matchGoImport(imports []metaImport, importPath string) (_ metaImport, err error) {
	match := -1
	for i, im := range imports {
		if !strings.HasPrefix(importPath, im.Prefix) {
			continue
		}
		if match != -1 {
			err = fmt.Errorf("multiple meta tags match import path %q", importPath)
			return
		}
		match = i
	}
	if match == -1 {
		err = errNoMatch
		return
	}
	return imports[match], nil
}

// expand rewrites s to replace {k} with match[k] for each key k in match.
func expand(match map[string]string, s string) string {
	for k, v := range match {
		s = strings.Replace(s, "{"+k+"}", v, -1)
	}
	return s
}

// vcsPaths lists the known vcs paths.
var vcsPaths = []*vcsPath{
	// Google Code - new syntax
	{
		prefix: "code.google.com/",
		re:     `^(?P<root>code\.google\.com/p/(?P<project>[a-z0-9\-]+)(\.(?P<subrepo>[a-z0-9\-]+))?)(/[A-Za-z0-9_.\-]+)*$`,
		repo:   "https://{root}",
		check:  googleCodeVCS,
	},

	// Google Code - old syntax
	{
		re:    `^(?P<project>[a-z0-9_\-.]+)\.googlecode\.com/(git|hg|svn)(?P<path>/.*)?$`,
		check: oldGoogleCode,
	},

	// Github
	{
		prefix: "github.com/",
		re:     `^(?P<root>github\.com/[A-Za-z0-9_.\-]+/[A-Za-z0-9_.\-]+)(/[A-Za-z0-9_.\-]+)*$`,
		vcs:    "git",
		repo:   "https://{root}",
		check:  noVCSSuffix,
	},

	// Bitbucket
	{
		prefix: "bitbucket.org/",
		re:     `^(?P<root>bitbucket\.org/(?P<bitname>[A-Za-z0-9_.\-]+/[A-Za-z0-9_.\-]+))(/[A-Za-z0-9_.\-]+)*$`,
		repo:   "https://{root}",
		check:  bitbucketVCS,
	},

	// Launchpad
	{
		prefix: "launchpad.net/",
		re:     `^(?P<root>launchpad\.net/((?P<project>[A-Za-z0-9_.\-]+)(?P<series>/[A-Za-z0-9_.\-]+)?|~[A-Za-z0-9_.\-]+/(\+junk|[A-Za-z0-9_.\-]+)/[A-Za-z0-9_.\-]+))(/[A-Za-z0-9_.\-]+)*$`,
		vcs:    "bzr",
		repo:   "https://{root}",
		check:  launchpadVCS,
	},

	// IBM DevOps Services (JazzHub)
	{
		prefix: "hub.jazz.net/git",
		re:     `^(?P<root>hub.jazz.net/git/[a-z0-9]+/[A-Za-z0-9_.\-]+)(/[A-Za-z0-9_.\-]+)*$`,
		vcs:    "git",
		repo:   "https://{root}",
		check:  noVCSSuffix,
	},

	// General syntax for any server.
	{
		re:   `^(?P<root>(?P<repo>([a-z0-9.\-]+\.)+[a-z0-9.\-]+(:[0-9]+)?/[A-Za-z0-9_.\-/]*?)\.(?P<vcs>bzr|git|hg|svn))(/[A-Za-z0-9_.\-]+)*$`,
		ping: true,
	},
}

func init() {
	// fill in cached regexps.
	// Doing this eagerly discovers invalid regexp syntax
	// without having to run a command that needs that regexp.
	for _, srv := range vcsPaths {
		srv.regexp = regexp.MustCompile(srv.re)
	}
}

// noVCSSuffix checks that the repository name does not
// end in .foo for any version control system foo.
// The usual culprit is ".git".
func noVCSSuffix(match map[string]string) error {
	repo := match["repo"]
	for _, vcs := range vcsList {
		if strings.HasSuffix(repo, "."+vcs.cmd) {
			return fmt.Errorf("invalid version control suffix in %s path", match["prefix"])
		}
	}
	return nil
}

var googleCheckout = regexp.MustCompile(`id="checkoutcmd">(hg|git|svn)`)

// googleCodeVCS determines the version control system for
// a code.google.com repository, by scraping the project's
// /source/checkout page.
func googleCodeVCS(match map[string]string) error {
	if err := noVCSSuffix(match); err != nil {
		return err
	}
	data, err := httpGET(expand(match, "https://code.google.com/p/{project}/source/checkout?repo={subrepo}"))
	if err != nil {
		return err
	}

	if m := googleCheckout.FindSubmatch(data); m != nil {
		if vcs := vcsByCmd(string(m[1])); vcs != nil {
			// Subversion requires the old URLs.
			// TODO: Test.
			if vcs == vcsSvn {
				if match["subrepo"] != "" {
					return fmt.Errorf("sub-repositories not supported in Google Code Subversion projects")
				}
				match["repo"] = expand(match, "https://{project}.googlecode.com/svn")
			}
			match["vcs"] = vcs.cmd
			return nil
		}
	}

	return fmt.Errorf("unable to detect version control system for code.google.com/ path")
}

// oldGoogleCode is invoked for old-style foo.googlecode.com paths.
// It prints an error giving the equivalent new path.
func oldGoogleCode(match map[string]string) error {
	return fmt.Errorf("invalid Google Code import path: use %s instead",
		expand(match, "code.google.com/p/{project}{path}"))
}

// bitbucketVCS determines the version control system for a
// Bitbucket repository, by using the Bitbucket API.
func bitbucketVCS(match map[string]string) error {
	if err := noVCSSuffix(match); err != nil {
		return err
	}

	var resp struct {
		SCM string `json:"scm"`
	}
	url := expand(match, "https://api.bitbucket.org/1.0/repositories/{bitname}")
	data, err := httpGET(url)
	if err != nil {
		return err
	}
	if err := json.Unmarshal(data, &resp); err != nil {
		return fmt.Errorf("decoding %s: %v", url, err)
	}

	if vcsByCmd(resp.SCM) != nil {
		match["vcs"] = resp.SCM
		if resp.SCM == "git" {
			match["repo"] += ".git"
		}
		return nil
	}

	return fmt.Errorf("unable to detect version control system for bitbucket.org/ path")
}

// launchpadVCS solves the ambiguity for "lp.net/project/foo". In this case,
// "foo" could be a series name registered in Launchpad with its own branch,
// and it could also be the name of a directory within the main project
// branch one level up.
func launchpadVCS(match map[string]string) error {
	if match["project"] == "" || match["series"] == "" {
		return nil
	}
	_, err := httpGET(expand(match, "https://code.launchpad.net/{project}{series}/.bzr/branch-format"))
	if err != nil {
		match["root"] = expand(match, "launchpad.net/{project}")
		match["repo"] = expand(match, "https://{root}")
	}
	return nil
}
                                                                         root/go1.4/src/cmd/go/vcs_test.go                                                                   0100644 0000000 0000000 00000005045 12600426226 015204  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"runtime"
	"testing"
)

// Test that RepoRootForImportPath creates the correct RepoRoot for a given importPath.
// TODO(cmang): Add tests for SVN and BZR.
func TestRepoRootForImportPath(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping test to avoid external network")
	}
	switch runtime.GOOS {
	case "nacl", "android":
		t.Skipf("no networking available on %s", runtime.GOOS)
	}
	tests := []struct {
		path string
		want *repoRoot
	}{
		{
			"code.google.com/p/go",
			&repoRoot{
				vcs:  vcsHg,
				repo: "https://code.google.com/p/go",
			},
		},
		/*{
		        "code.google.com/r/go",
		        &repoRoot{
		                vcs:  vcsHg,
		                repo: "https://code.google.com/r/go",
		        },
		},*/
		{
			"github.com/golang/groupcache",
			&repoRoot{
				vcs:  vcsGit,
				repo: "https://github.com/golang/groupcache",
			},
		},
		// IBM DevOps Services tests
		{
			"hub.jazz.net/git/user1/pkgname",
			&repoRoot{
				vcs:  vcsGit,
				repo: "https://hub.jazz.net/git/user1/pkgname",
			},
		},
		{
			"hub.jazz.net/git/user1/pkgname/submodule/submodule/submodule",
			&repoRoot{
				vcs:  vcsGit,
				repo: "https://hub.jazz.net/git/user1/pkgname",
			},
		},
		{
			"hub.jazz.net",
			nil,
		},
		{
			"hub2.jazz.net",
			nil,
		},
		{
			"hub.jazz.net/someotherprefix",
			nil,
		},
		{
			"hub.jazz.net/someotherprefix/user1/pkgname",
			nil,
		},
		// Spaces are not valid in user names or package names
		{
			"hub.jazz.net/git/User 1/pkgname",
			nil,
		},
		{
			"hub.jazz.net/git/user1/pkg name",
			nil,
		},
		// Dots are not valid in user names
		{
			"hub.jazz.net/git/user.1/pkgname",
			nil,
		},
		{
			"hub.jazz.net/git/user/pkg.name",
			&repoRoot{
				vcs:  vcsGit,
				repo: "https://hub.jazz.net/git/user/pkg.name",
			},
		},
		// User names cannot have uppercase letters
		{
			"hub.jazz.net/git/USER/pkgname",
			nil,
		},
	}

	for _, test := range tests {
		got, err := repoRootForImportPath(test.path)
		want := test.want

		if want == nil {
			if err == nil {
				t.Errorf("RepoRootForImport(%q): Error expected but not received", test.path)
			}
			continue
		}
		if err != nil {
			t.Errorf("RepoRootForImport(%q): %v", test.path, err)
			continue
		}
		if got.vcs.name != want.vcs.name || got.repo != want.repo {
			t.Errorf("RepoRootForImport(%q) = VCS(%s) Repo(%s), want VCS(%s) Repo(%s)", test.path, got.vcs, got.repo, want.vcs, want.repo)
		}
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           root/go1.4/src/cmd/go/version.go                                                                    0100644 0000000 0000000 00000001066 12600426226 015036  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
	"runtime"
)

var cmdVersion = &Command{
	Run:       runVersion,
	UsageLine: "version",
	Short:     "print Go version",
	Long:      `Version prints the Go version, as reported by runtime.Version.`,
}

func runVersion(cmd *Command, args []string) {
	if len(args) != 0 {
		cmd.Usage()
	}

	fmt.Printf("go version %s %s/%s\n", runtime.Version(), runtime.GOOS, runtime.GOARCH)
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          root/go1.4/src/cmd/go/vet.go                                                                        0100644 0000000 0000000 00000002520 12600426226 014143  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import "path/filepath"

func init() {
	addBuildFlagsNX(cmdVet)
}

var cmdVet = &Command{
	Run:       runVet,
	UsageLine: "vet [-n] [-x] [packages]",
	Short:     "run go tool vet on packages",
	Long: `
Vet runs the Go vet command on the packages named by the import paths.

For more about vet, see 'godoc golang.org/x/tools/cmd/vet'.
For more about specifying packages, see 'go help packages'.

To run the vet tool with specific options, run 'go tool vet'.

The -n flag prints commands that would be executed.
The -x flag prints commands as they are executed.

See also: go fmt, go fix.
	`,
}

func runVet(cmd *Command, args []string) {
	for _, p := range packages(args) {
		// Vet expects to be given a set of files all from the same package.
		// Run once for package p and once for package p_test.
		if len(p.GoFiles)+len(p.CgoFiles)+len(p.TestGoFiles) > 0 {
			runVetFiles(p, stringList(p.GoFiles, p.CgoFiles, p.TestGoFiles, p.SFiles))
		}
		if len(p.XTestGoFiles) > 0 {
			runVetFiles(p, stringList(p.XTestGoFiles))
		}
	}
}

func runVetFiles(p *Package, files []string) {
	for i := range files {
		files[i] = filepath.Join(p.Dir, files[i])
	}
	run(tool("vet"), relPaths(files))
}
                                                                                                                                                                                root/go1.4/src/cmd/go/zdefaultcc.go                                                                 0100644 0000000 0000000 00000000142 12600426335 015470  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // auto generated by go tool dist

package main

const defaultCC = `gcc`
const defaultCXX = `g++`
                                                                                                                                                                                                                                                                                                                                                                                                                              root/go1.4/src/cmd/gofmt/                                                                           0040755 0000000 0000000 00000000000 12600426232 013526  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/gofmt/doc.go                                                                     0100644 0000000 0000000 00000005375 12600426226 014634  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

/*
Gofmt formats Go programs.
It uses tabs (width = 8) for indentation and blanks for alignment.

Without an explicit path, it processes the standard input.  Given a file,
it operates on that file; given a directory, it operates on all .go files in
that directory, recursively.  (Files starting with a period are ignored.)
By default, gofmt prints the reformatted sources to standard output.

Usage:
	gofmt [flags] [path ...]

The flags are:
	-d
		Do not print reformatted sources to standard output.
		If a file's formatting is different than gofmt's, print diffs
		to standard output.
	-e
		Print all (including spurious) errors.
	-l
		Do not print reformatted sources to standard output.
		If a file's formatting is different from gofmt's, print its name
		to standard output.
	-r rule
		Apply the rewrite rule to the source before reformatting.
	-s
		Try to simplify code (after applying the rewrite rule, if any).
	-w
		Do not print reformatted sources to standard output.
		If a file's formatting is different from gofmt's, overwrite it
		with gofmt's version.

Debugging support:
	-cpuprofile filename
		Write cpu profile to the specified file.


The rewrite rule specified with the -r flag must be a string of the form:

	pattern -> replacement

Both pattern and replacement must be valid Go expressions.
In the pattern, single-character lowercase identifiers serve as
wildcards matching arbitrary sub-expressions; those expressions
will be substituted for the same identifiers in the replacement.

When gofmt reads from standard input, it accepts either a full Go program
or a program fragment.  A program fragment must be a syntactically
valid declaration list, statement list, or expression.  When formatting
such a fragment, gofmt preserves leading indentation as well as leading
and trailing spaces, so that individual sections of a Go program can be
formatted by piping them through gofmt.

Examples

To check files for unnecessary parentheses:

	gofmt -r '(a) -> a' -l *.go

To remove the parentheses:

	gofmt -r '(a) -> a' -w *.go

To convert the package tree from explicit slice upper bounds to implicit ones:

	gofmt -r '[:len()] -> [:]' -w $GOROOT/src

The simplify command

When invoked with -s gofmt will make the following source transformations where possible.

	An array, slice, or map composite literal of the form:
		[]T{T{}, T{}}
	will be simplified to:
		[]T{{}, {}}

	A slice expression of the form:
		s[a:len(s)]
	will be simplified to:
		s[a:]

	A range of the form:
		for x, _ = range v {...}
	will be simplified to:
		for x = range v {...}
*/
package main

// BUG(rsc): The implementation of -r is a bit slow.
                                                                                                                                                                                                                                                                   root/go1.4/src/cmd/gofmt/gofmt.go                                                                   0100644 0000000 0000000 00000022050 12600426226 015170  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/scanner"
	"go/token"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"runtime/pprof"
	"strings"
)

var (
	// main operation modes
	list        = flag.Bool("l", false, "list files whose formatting differs from gofmt's")
	write       = flag.Bool("w", false, "write result to (source) file instead of stdout")
	rewriteRule = flag.String("r", "", "rewrite rule (e.g., 'a[b:len(a)] -> a[b:]')")
	simplifyAST = flag.Bool("s", false, "simplify code")
	doDiff      = flag.Bool("d", false, "display diffs instead of rewriting files")
	allErrors   = flag.Bool("e", false, "report all errors (not just the first 10 on different lines)")

	// debugging
	cpuprofile = flag.String("cpuprofile", "", "write cpu profile to this file")
)

const (
	tabWidth    = 8
	printerMode = printer.UseSpaces | printer.TabIndent
)

var (
	fileSet    = token.NewFileSet() // per process FileSet
	exitCode   = 0
	rewrite    func(*ast.File) *ast.File
	parserMode parser.Mode
)

func report(err error) {
	scanner.PrintError(os.Stderr, err)
	exitCode = 2
}

func usage() {
	fmt.Fprintf(os.Stderr, "usage: gofmt [flags] [path ...]\n")
	flag.PrintDefaults()
	os.Exit(2)
}

func initParserMode() {
	parserMode = parser.ParseComments
	if *allErrors {
		parserMode |= parser.AllErrors
	}
}

func isGoFile(f os.FileInfo) bool {
	// ignore non-Go files
	name := f.Name()
	return !f.IsDir() && !strings.HasPrefix(name, ".") && strings.HasSuffix(name, ".go")
}

// If in == nil, the source is the contents of the file with the given filename.
func processFile(filename string, in io.Reader, out io.Writer, stdin bool) error {
	if in == nil {
		f, err := os.Open(filename)
		if err != nil {
			return err
		}
		defer f.Close()
		in = f
	}

	src, err := ioutil.ReadAll(in)
	if err != nil {
		return err
	}

	file, sourceAdj, indentAdj, err := parse(fileSet, filename, src, stdin)
	if err != nil {
		return err
	}

	if rewrite != nil {
		if sourceAdj == nil {
			file = rewrite(file)
		} else {
			fmt.Fprintf(os.Stderr, "warning: rewrite ignored for incomplete programs\n")
		}
	}

	ast.SortImports(fileSet, file)

	if *simplifyAST {
		simplify(file)
	}

	res, err := format(fileSet, file, sourceAdj, indentAdj, src, printer.Config{Mode: printerMode, Tabwidth: tabWidth})
	if err != nil {
		return err
	}

	if !bytes.Equal(src, res) {
		// formatting has changed
		if *list {
			fmt.Fprintln(out, filename)
		}
		if *write {
			err = ioutil.WriteFile(filename, res, 0644)
			if err != nil {
				return err
			}
		}
		if *doDiff {
			data, err := diff(src, res)
			if err != nil {
				return fmt.Errorf("computing diff: %s", err)
			}
			fmt.Printf("diff %s gofmt/%s\n", filename, filename)
			out.Write(data)
		}
	}

	if !*list && !*write && !*doDiff {
		_, err = out.Write(res)
	}

	return err
}

func visitFile(path string, f os.FileInfo, err error) error {
	if err == nil && isGoFile(f) {
		err = processFile(path, nil, os.Stdout, false)
	}
	if err != nil {
		report(err)
	}
	return nil
}

func walkDir(path string) {
	filepath.Walk(path, visitFile)
}

func main() {
	// call gofmtMain in a separate function
	// so that it can use defer and have them
	// run before the exit.
	gofmtMain()
	os.Exit(exitCode)
}

func gofmtMain() {
	flag.Usage = usage
	flag.Parse()

	if *cpuprofile != "" {
		f, err := os.Create(*cpuprofile)
		if err != nil {
			fmt.Fprintf(os.Stderr, "creating cpu profile: %s\n", err)
			exitCode = 2
			return
		}
		defer f.Close()
		pprof.StartCPUProfile(f)
		defer pprof.StopCPUProfile()
	}

	initParserMode()
	initRewrite()

	if flag.NArg() == 0 {
		if *write {
			fmt.Fprintln(os.Stderr, "error: cannot use -w with standard input")
			exitCode = 2
			return
		}
		if err := processFile("<standard input>", os.Stdin, os.Stdout, true); err != nil {
			report(err)
		}
		return
	}

	for i := 0; i < flag.NArg(); i++ {
		path := flag.Arg(i)
		switch dir, err := os.Stat(path); {
		case err != nil:
			report(err)
		case dir.IsDir():
			walkDir(path)
		default:
			if err := processFile(path, nil, os.Stdout, false); err != nil {
				report(err)
			}
		}
	}
}

func diff(b1, b2 []byte) (data []byte, err error) {
	f1, err := ioutil.TempFile("", "gofmt")
	if err != nil {
		return
	}
	defer os.Remove(f1.Name())
	defer f1.Close()

	f2, err := ioutil.TempFile("", "gofmt")
	if err != nil {
		return
	}
	defer os.Remove(f2.Name())
	defer f2.Close()

	f1.Write(b1)
	f2.Write(b2)

	data, err = exec.Command("diff", "-u", f1.Name(), f2.Name()).CombinedOutput()
	if len(data) > 0 {
		// diff exits with a non-zero status when the files don't match.
		// Ignore that failure as long as we get output.
		err = nil
	}
	return

}

// ----------------------------------------------------------------------------
// Support functions
//
// The functions parse, format, and isSpace below are identical to the
// respective functions in src/go/format/format.go - keep them in sync!
//
// TODO(gri) Factor out this functionality, eventually.

// parse parses src, which was read from the named file,
// as a Go source file, declaration, or statement list.
func parse(fset *token.FileSet, filename string, src []byte, fragmentOk bool) (
	file *ast.File,
	sourceAdj func(src []byte, indent int) []byte,
	indentAdj int,
	err error,
) {
	// Try as whole source file.
	file, err = parser.ParseFile(fset, filename, src, parserMode)
	// If there's no error, return.  If the error is that the source file didn't begin with a
	// package line and source fragments are ok, fall through to
	// try as a source fragment.  Stop and return on any other error.
	if err == nil || !fragmentOk || !strings.Contains(err.Error(), "expected 'package'") {
		return
	}

	// If this is a declaration list, make it a source file
	// by inserting a package clause.
	// Insert using a ;, not a newline, so that the line numbers
	// in psrc match the ones in src.
	psrc := append([]byte("package p;"), src...)
	file, err = parser.ParseFile(fset, filename, psrc, parserMode)
	if err == nil {
		sourceAdj = func(src []byte, indent int) []byte {
			// Remove the package clause.
			// Gofmt has turned the ; into a \n.
			src = src[indent+len("package p\n"):]
			return bytes.TrimSpace(src)
		}
		return
	}
	// If the error is that the source file didn't begin with a
	// declaration, fall through to try as a statement list.
	// Stop and return on any other error.
	if !strings.Contains(err.Error(), "expected declaration") {
		return
	}

	// If this is a statement list, make it a source file
	// by inserting a package clause and turning the list
	// into a function body.  This handles expressions too.
	// Insert using a ;, not a newline, so that the line numbers
	// in fsrc match the ones in src.
	fsrc := append(append([]byte("package p; func _() {"), src...), '\n', '}')
	file, err = parser.ParseFile(fset, filename, fsrc, parserMode)
	if err == nil {
		sourceAdj = func(src []byte, indent int) []byte {
			// Cap adjusted indent to zero.
			if indent < 0 {
				indent = 0
			}
			// Remove the wrapping.
			// Gofmt has turned the ; into a \n\n.
			// There will be two non-blank lines with indent, hence 2*indent.
			src = src[2*indent+len("package p\n\nfunc _() {"):]
			src = src[:len(src)-(indent+len("\n}\n"))]
			return bytes.TrimSpace(src)
		}
		// Gofmt has also indented the function body one level.
		// Adjust that with indentAdj.
		indentAdj = -1
	}

	// Succeeded, or out of options.
	return
}

// format formats the given package file originally obtained from src
// and adjusts the result based on the original source via sourceAdj
// and indentAdj.
func format(
	fset *token.FileSet,
	file *ast.File,
	sourceAdj func(src []byte, indent int) []byte,
	indentAdj int,
	src []byte,
	cfg printer.Config,
) ([]byte, error) {
	if sourceAdj == nil {
		// Complete source file.
		var buf bytes.Buffer
		err := cfg.Fprint(&buf, fset, file)
		if err != nil {
			return nil, err
		}
		return buf.Bytes(), nil
	}

	// Partial source file.
	// Determine and prepend leading space.
	i, j := 0, 0
	for j < len(src) && isSpace(src[j]) {
		if src[j] == '\n' {
			i = j + 1 // byte offset of last line in leading space
		}
		j++
	}
	var res []byte
	res = append(res, src[:i]...)

	// Determine and prepend indentation of first code line.
	// Spaces are ignored unless there are no tabs,
	// in which case spaces count as one tab.
	indent := 0
	hasSpace := false
	for _, b := range src[i:j] {
		switch b {
		case ' ':
			hasSpace = true
		case '\t':
			indent++
		}
	}
	if indent == 0 && hasSpace {
		indent = 1
	}
	for i := 0; i < indent; i++ {
		res = append(res, '\t')
	}

	// Format the source.
	// Write it without any leading and trailing space.
	cfg.Indent = indent + indentAdj
	var buf bytes.Buffer
	err := cfg.Fprint(&buf, fset, file)
	if err != nil {
		return nil, err
	}
	res = append(res, sourceAdj(buf.Bytes(), cfg.Indent)...)

	// Determine and append trailing space.
	i = len(src)
	for i > 0 && isSpace(src[i-1]) {
		i--
	}
	return append(res, src[i:]...), nil
}

func isSpace(b byte) bool {
	return b == ' ' || b == '\t' || b == '\n' || b == '\r'
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        root/go1.4/src/cmd/gofmt/gofmt_test.go                                                              0100644 0000000 0000000 00000007371 12600426226 016240  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"flag"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"text/scanner"
)

var update = flag.Bool("update", false, "update .golden files")

// gofmtFlags looks for a comment of the form
//
//	//gofmt flags
//
// within the first maxLines lines of the given file,
// and returns the flags string, if any. Otherwise it
// returns the empty string.
func gofmtFlags(filename string, maxLines int) string {
	f, err := os.Open(filename)
	if err != nil {
		return "" // ignore errors - they will be found later
	}
	defer f.Close()

	// initialize scanner
	var s scanner.Scanner
	s.Init(f)
	s.Error = func(*scanner.Scanner, string) {}       // ignore errors
	s.Mode = scanner.GoTokens &^ scanner.SkipComments // want comments

	// look for //gofmt comment
	for s.Line <= maxLines {
		switch s.Scan() {
		case scanner.Comment:
			const prefix = "//gofmt "
			if t := s.TokenText(); strings.HasPrefix(t, prefix) {
				return strings.TrimSpace(t[len(prefix):])
			}
		case scanner.EOF:
			return ""
		}

	}

	return ""
}

func runTest(t *testing.T, in, out string) {
	// process flags
	*simplifyAST = false
	*rewriteRule = ""
	stdin := false
	for _, flag := range strings.Split(gofmtFlags(in, 20), " ") {
		elts := strings.SplitN(flag, "=", 2)
		name := elts[0]
		value := ""
		if len(elts) == 2 {
			value = elts[1]
		}
		switch name {
		case "":
			// no flags
		case "-r":
			*rewriteRule = value
		case "-s":
			*simplifyAST = true
		case "-stdin":
			// fake flag - pretend input is from stdin
			stdin = true
		default:
			t.Errorf("unrecognized flag name: %s", name)
		}
	}

	initParserMode()
	initRewrite()

	var buf bytes.Buffer
	err := processFile(in, nil, &buf, stdin)
	if err != nil {
		t.Error(err)
		return
	}

	expected, err := ioutil.ReadFile(out)
	if err != nil {
		t.Error(err)
		return
	}

	if got := buf.Bytes(); !bytes.Equal(got, expected) {
		if *update {
			if in != out {
				if err := ioutil.WriteFile(out, got, 0666); err != nil {
					t.Error(err)
				}
				return
			}
			// in == out: don't accidentally destroy input
			t.Errorf("WARNING: -update did not rewrite input file %s", in)
		}

		t.Errorf("(gofmt %s) != %s (see %s.gofmt)", in, out, in)
		d, err := diff(expected, got)
		if err == nil {
			t.Errorf("%s", d)
		}
		if err := ioutil.WriteFile(in+".gofmt", got, 0666); err != nil {
			t.Error(err)
		}
	}
}

// TestRewrite processes testdata/*.input files and compares them to the
// corresponding testdata/*.golden files. The gofmt flags used to process
// a file must be provided via a comment of the form
//
//	//gofmt flags
//
// in the processed file within the first 20 lines, if any.
func TestRewrite(t *testing.T) {
	// determine input files
	match, err := filepath.Glob("testdata/*.input")
	if err != nil {
		t.Fatal(err)
	}

	// add larger examples
	match = append(match, "gofmt.go", "gofmt_test.go")

	for _, in := range match {
		out := in // for files where input and output are identical
		if strings.HasSuffix(in, ".input") {
			out = in[:len(in)-len(".input")] + ".golden"
		}
		runTest(t, in, out)
		if in != out {
			// Check idempotence.
			runTest(t, out, out)
		}
	}
}

// Test case for issue 3961.
func TestCRLF(t *testing.T) {
	const input = "testdata/crlf.input"   // must contain CR/LF's
	const golden = "testdata/crlf.golden" // must not contain any CR's

	data, err := ioutil.ReadFile(input)
	if err != nil {
		t.Error(err)
	}
	if bytes.Index(data, []byte("\r\n")) < 0 {
		t.Errorf("%s contains no CR/LF's", input)
	}

	data, err = ioutil.ReadFile(golden)
	if err != nil {
		t.Error(err)
	}
	if bytes.Index(data, []byte("\r")) >= 0 {
		t.Errorf("%s contains CR's", golden)
	}
}
                                                                                                                                                                                                                                                                       root/go1.4/src/cmd/gofmt/long_test.go                                                               0100644 0000000 0000000 00000006546 12600426226 016066  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This test applies gofmt to all Go files under -root.
// To test specific files provide a list of comma-separated
// filenames via the -files flag: go test -files=gofmt.go .

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"io"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"testing"
)

var (
	root    = flag.String("root", runtime.GOROOT(), "test root directory")
	files   = flag.String("files", "", "comma-separated list of files to test")
	ngo     = flag.Int("n", runtime.NumCPU(), "number of goroutines used")
	verbose = flag.Bool("verbose", false, "verbose mode")
	nfiles  int // number of files processed
)

func gofmt(fset *token.FileSet, filename string, src *bytes.Buffer) error {
	f, _, _, err := parse(fset, filename, src.Bytes(), false)
	if err != nil {
		return err
	}
	ast.SortImports(fset, f)
	src.Reset()
	return (&printer.Config{Mode: printerMode, Tabwidth: tabWidth}).Fprint(src, fset, f)
}

func testFile(t *testing.T, b1, b2 *bytes.Buffer, filename string) {
	// open file
	f, err := os.Open(filename)
	if err != nil {
		t.Error(err)
		return
	}

	// read file
	b1.Reset()
	_, err = io.Copy(b1, f)
	f.Close()
	if err != nil {
		t.Error(err)
		return
	}

	// exclude files w/ syntax errors (typically test cases)
	fset := token.NewFileSet()
	if _, _, _, err = parse(fset, filename, b1.Bytes(), false); err != nil {
		if *verbose {
			fmt.Fprintf(os.Stderr, "ignoring %s\n", err)
		}
		return
	}

	// gofmt file
	if err = gofmt(fset, filename, b1); err != nil {
		t.Errorf("1st gofmt failed: %v", err)
		return
	}

	// make a copy of the result
	b2.Reset()
	b2.Write(b1.Bytes())

	// gofmt result again
	if err = gofmt(fset, filename, b2); err != nil {
		t.Errorf("2nd gofmt failed: %v", err)
		return
	}

	// the first and 2nd result should be identical
	if !bytes.Equal(b1.Bytes(), b2.Bytes()) {
		t.Errorf("gofmt %s not idempotent", filename)
	}
}

func testFiles(t *testing.T, filenames <-chan string, done chan<- int) {
	b1 := new(bytes.Buffer)
	b2 := new(bytes.Buffer)
	for filename := range filenames {
		testFile(t, b1, b2, filename)
	}
	done <- 0
}

func genFilenames(t *testing.T, filenames chan<- string) {
	defer close(filenames)

	handleFile := func(filename string, fi os.FileInfo, err error) error {
		if err != nil {
			t.Error(err)
			return nil
		}
		if isGoFile(fi) {
			filenames <- filename
			nfiles++
		}
		return nil
	}

	// test Go files provided via -files, if any
	if *files != "" {
		for _, filename := range strings.Split(*files, ",") {
			fi, err := os.Stat(filename)
			handleFile(filename, fi, err)
		}
		return // ignore files under -root
	}

	// otherwise, test all Go files under *root
	filepath.Walk(*root, handleFile)
}

func TestAll(t *testing.T) {
	if testing.Short() {
		return
	}

	if *ngo < 1 {
		*ngo = 1 // make sure test is run
	}
	if *verbose {
		fmt.Printf("running test using %d goroutines\n", *ngo)
	}

	// generate filenames
	filenames := make(chan string, 32)
	go genFilenames(t, filenames)

	// launch test goroutines
	done := make(chan int)
	for i := 0; i < *ngo; i++ {
		go testFiles(t, filenames, done)
	}

	// wait for all test goroutines to complete
	for i := 0; i < *ngo; i++ {
		<-done
	}

	if *verbose {
		fmt.Printf("processed %d files\n", nfiles)
	}
}
                                                                                                                                                          root/go1.4/src/cmd/gofmt/rewrite.go                                                                 0100644 0000000 0000000 00000017655 12600426226 015554  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"reflect"
	"strings"
	"unicode"
	"unicode/utf8"
)

func initRewrite() {
	if *rewriteRule == "" {
		rewrite = nil // disable any previous rewrite
		return
	}
	f := strings.Split(*rewriteRule, "->")
	if len(f) != 2 {
		fmt.Fprintf(os.Stderr, "rewrite rule must be of the form 'pattern -> replacement'\n")
		os.Exit(2)
	}
	pattern := parseExpr(f[0], "pattern")
	replace := parseExpr(f[1], "replacement")
	rewrite = func(p *ast.File) *ast.File { return rewriteFile(pattern, replace, p) }
}

// parseExpr parses s as an expression.
// It might make sense to expand this to allow statement patterns,
// but there are problems with preserving formatting and also
// with what a wildcard for a statement looks like.
func parseExpr(s, what string) ast.Expr {
	x, err := parser.ParseExpr(s)
	if err != nil {
		fmt.Fprintf(os.Stderr, "parsing %s %s at %s\n", what, s, err)
		os.Exit(2)
	}
	return x
}

// Keep this function for debugging.
/*
func dump(msg string, val reflect.Value) {
	fmt.Printf("%s:\n", msg)
	ast.Print(fileSet, val.Interface())
	fmt.Println()
}
*/

// rewriteFile applies the rewrite rule 'pattern -> replace' to an entire file.
func rewriteFile(pattern, replace ast.Expr, p *ast.File) *ast.File {
	cmap := ast.NewCommentMap(fileSet, p, p.Comments)
	m := make(map[string]reflect.Value)
	pat := reflect.ValueOf(pattern)
	repl := reflect.ValueOf(replace)

	var rewriteVal func(val reflect.Value) reflect.Value
	rewriteVal = func(val reflect.Value) reflect.Value {
		// don't bother if val is invalid to start with
		if !val.IsValid() {
			return reflect.Value{}
		}
		for k := range m {
			delete(m, k)
		}
		val = apply(rewriteVal, val)
		if match(m, pat, val) {
			val = subst(m, repl, reflect.ValueOf(val.Interface().(ast.Node).Pos()))
		}
		return val
	}

	r := apply(rewriteVal, reflect.ValueOf(p)).Interface().(*ast.File)
	r.Comments = cmap.Filter(r).Comments() // recreate comments list
	return r
}

// set is a wrapper for x.Set(y); it protects the caller from panics if x cannot be changed to y.
func set(x, y reflect.Value) {
	// don't bother if x cannot be set or y is invalid
	if !x.CanSet() || !y.IsValid() {
		return
	}
	defer func() {
		if x := recover(); x != nil {
			if s, ok := x.(string); ok &&
				(strings.Contains(s, "type mismatch") || strings.Contains(s, "not assignable")) {
				// x cannot be set to y - ignore this rewrite
				return
			}
			panic(x)
		}
	}()
	x.Set(y)
}

// Values/types for special cases.
var (
	objectPtrNil = reflect.ValueOf((*ast.Object)(nil))
	scopePtrNil  = reflect.ValueOf((*ast.Scope)(nil))

	identType     = reflect.TypeOf((*ast.Ident)(nil))
	objectPtrType = reflect.TypeOf((*ast.Object)(nil))
	positionType  = reflect.TypeOf(token.NoPos)
	callExprType  = reflect.TypeOf((*ast.CallExpr)(nil))
	scopePtrType  = reflect.TypeOf((*ast.Scope)(nil))
)

// apply replaces each AST field x in val with f(x), returning val.
// To avoid extra conversions, f operates on the reflect.Value form.
func apply(f func(reflect.Value) reflect.Value, val reflect.Value) reflect.Value {
	if !val.IsValid() {
		return reflect.Value{}
	}

	// *ast.Objects introduce cycles and are likely incorrect after
	// rewrite; don't follow them but replace with nil instead
	if val.Type() == objectPtrType {
		return objectPtrNil
	}

	// similarly for scopes: they are likely incorrect after a rewrite;
	// replace them with nil
	if val.Type() == scopePtrType {
		return scopePtrNil
	}

	switch v := reflect.Indirect(val); v.Kind() {
	case reflect.Slice:
		for i := 0; i < v.Len(); i++ {
			e := v.Index(i)
			set(e, f(e))
		}
	case reflect.Struct:
		for i := 0; i < v.NumField(); i++ {
			e := v.Field(i)
			set(e, f(e))
		}
	case reflect.Interface:
		e := v.Elem()
		set(v, f(e))
	}
	return val
}

func isWildcard(s string) bool {
	rune, size := utf8.DecodeRuneInString(s)
	return size == len(s) && unicode.IsLower(rune)
}

// match returns true if pattern matches val,
// recording wildcard submatches in m.
// If m == nil, match checks whether pattern == val.
func match(m map[string]reflect.Value, pattern, val reflect.Value) bool {
	// Wildcard matches any expression.  If it appears multiple
	// times in the pattern, it must match the same expression
	// each time.
	if m != nil && pattern.IsValid() && pattern.Type() == identType {
		name := pattern.Interface().(*ast.Ident).Name
		if isWildcard(name) && val.IsValid() {
			// wildcards only match valid (non-nil) expressions.
			if _, ok := val.Interface().(ast.Expr); ok && !val.IsNil() {
				if old, ok := m[name]; ok {
					return match(nil, old, val)
				}
				m[name] = val
				return true
			}
		}
	}

	// Otherwise, pattern and val must match recursively.
	if !pattern.IsValid() || !val.IsValid() {
		return !pattern.IsValid() && !val.IsValid()
	}
	if pattern.Type() != val.Type() {
		return false
	}

	// Special cases.
	switch pattern.Type() {
	case identType:
		// For identifiers, only the names need to match
		// (and none of the other *ast.Object information).
		// This is a common case, handle it all here instead
		// of recursing down any further via reflection.
		p := pattern.Interface().(*ast.Ident)
		v := val.Interface().(*ast.Ident)
		return p == nil && v == nil || p != nil && v != nil && p.Name == v.Name
	case objectPtrType, positionType:
		// object pointers and token positions always match
		return true
	case callExprType:
		// For calls, the Ellipsis fields (token.Position) must
		// match since that is how f(x) and f(x...) are different.
		// Check them here but fall through for the remaining fields.
		p := pattern.Interface().(*ast.CallExpr)
		v := val.Interface().(*ast.CallExpr)
		if p.Ellipsis.IsValid() != v.Ellipsis.IsValid() {
			return false
		}
	}

	p := reflect.Indirect(pattern)
	v := reflect.Indirect(val)
	if !p.IsValid() || !v.IsValid() {
		return !p.IsValid() && !v.IsValid()
	}

	switch p.Kind() {
	case reflect.Slice:
		if p.Len() != v.Len() {
			return false
		}
		for i := 0; i < p.Len(); i++ {
			if !match(m, p.Index(i), v.Index(i)) {
				return false
			}
		}
		return true

	case reflect.Struct:
		for i := 0; i < p.NumField(); i++ {
			if !match(m, p.Field(i), v.Field(i)) {
				return false
			}
		}
		return true

	case reflect.Interface:
		return match(m, p.Elem(), v.Elem())
	}

	// Handle token integers, etc.
	return p.Interface() == v.Interface()
}

// subst returns a copy of pattern with values from m substituted in place
// of wildcards and pos used as the position of tokens from the pattern.
// if m == nil, subst returns a copy of pattern and doesn't change the line
// number information.
func subst(m map[string]reflect.Value, pattern reflect.Value, pos reflect.Value) reflect.Value {
	if !pattern.IsValid() {
		return reflect.Value{}
	}

	// Wildcard gets replaced with map value.
	if m != nil && pattern.Type() == identType {
		name := pattern.Interface().(*ast.Ident).Name
		if isWildcard(name) {
			if old, ok := m[name]; ok {
				return subst(nil, old, reflect.Value{})
			}
		}
	}

	if pos.IsValid() && pattern.Type() == positionType {
		// use new position only if old position was valid in the first place
		if old := pattern.Interface().(token.Pos); !old.IsValid() {
			return pattern
		}
		return pos
	}

	// Otherwise copy.
	switch p := pattern; p.Kind() {
	case reflect.Slice:
		v := reflect.MakeSlice(p.Type(), p.Len(), p.Len())
		for i := 0; i < p.Len(); i++ {
			v.Index(i).Set(subst(m, p.Index(i), pos))
		}
		return v

	case reflect.Struct:
		v := reflect.New(p.Type()).Elem()
		for i := 0; i < p.NumField(); i++ {
			v.Field(i).Set(subst(m, p.Field(i), pos))
		}
		return v

	case reflect.Ptr:
		v := reflect.New(p.Type()).Elem()
		if elem := p.Elem(); elem.IsValid() {
			v.Set(subst(m, elem, pos).Addr())
		}
		return v

	case reflect.Interface:
		v := reflect.New(p.Type()).Elem()
		if elem := p.Elem(); elem.IsValid() {
			v.Set(subst(m, elem, pos))
		}
		return v
	}

	return pattern
}
                                                                                   root/go1.4/src/cmd/gofmt/simplify.go                                                                0100644 0000000 0000000 00000010710 12600426226 015710  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"go/ast"
	"go/token"
	"reflect"
)

type simplifier struct {
	hasDotImport bool // package file contains: import . "some/import/path"
}

func (s *simplifier) Visit(node ast.Node) ast.Visitor {
	switch n := node.(type) {
	case *ast.CompositeLit:
		// array, slice, and map composite literals may be simplified
		outer := n
		var eltType ast.Expr
		switch typ := outer.Type.(type) {
		case *ast.ArrayType:
			eltType = typ.Elt
		case *ast.MapType:
			eltType = typ.Value
		}

		if eltType != nil {
			typ := reflect.ValueOf(eltType)
			for i, x := range outer.Elts {
				px := &outer.Elts[i]
				// look at value of indexed/named elements
				if t, ok := x.(*ast.KeyValueExpr); ok {
					x = t.Value
					px = &t.Value
				}
				ast.Walk(s, x) // simplify x
				// if the element is a composite literal and its literal type
				// matches the outer literal's element type exactly, the inner
				// literal type may be omitted
				if inner, ok := x.(*ast.CompositeLit); ok {
					if match(nil, typ, reflect.ValueOf(inner.Type)) {
						inner.Type = nil
					}
				}
				// if the outer literal's element type is a pointer type *T
				// and the element is & of a composite literal of type T,
				// the inner &T may be omitted.
				if ptr, ok := eltType.(*ast.StarExpr); ok {
					if addr, ok := x.(*ast.UnaryExpr); ok && addr.Op == token.AND {
						if inner, ok := addr.X.(*ast.CompositeLit); ok {
							if match(nil, reflect.ValueOf(ptr.X), reflect.ValueOf(inner.Type)) {
								inner.Type = nil // drop T
								*px = inner      // drop &
							}
						}
					}
				}
			}

			// node was simplified - stop walk (there are no subnodes to simplify)
			return nil
		}

	case *ast.SliceExpr:
		// a slice expression of the form: s[a:len(s)]
		// can be simplified to: s[a:]
		// if s is "simple enough" (for now we only accept identifiers)
		if n.Max != nil || s.hasDotImport {
			// - 3-index slices always require the 2nd and 3rd index
			// - if dot imports are present, we cannot be certain that an
			//   unresolved "len" identifier refers to the predefined len()
			break
		}
		if s, _ := n.X.(*ast.Ident); s != nil && s.Obj != nil {
			// the array/slice object is a single, resolved identifier
			if call, _ := n.High.(*ast.CallExpr); call != nil && len(call.Args) == 1 && !call.Ellipsis.IsValid() {
				// the high expression is a function call with a single argument
				if fun, _ := call.Fun.(*ast.Ident); fun != nil && fun.Name == "len" && fun.Obj == nil {
					// the function called is "len" and it is not locally defined; and
					// because we don't have dot imports, it must be the predefined len()
					if arg, _ := call.Args[0].(*ast.Ident); arg != nil && arg.Obj == s.Obj {
						// the len argument is the array/slice object
						n.High = nil
					}
				}
			}
		}
		// Note: We could also simplify slice expressions of the form s[0:b] to s[:b]
		//       but we leave them as is since sometimes we want to be very explicit
		//       about the lower bound.
		// An example where the 0 helps:
		//       x, y, z := b[0:2], b[2:4], b[4:6]
		// An example where it does not:
		//       x, y := b[:n], b[n:]

	case *ast.RangeStmt:
		// - a range of the form: for x, _ = range v {...}
		// can be simplified to: for x = range v {...}
		// - a range of the form: for _ = range v {...}
		// can be simplified to: for range v {...}
		if isBlank(n.Value) {
			n.Value = nil
		}
		if isBlank(n.Key) && n.Value == nil {
			n.Key = nil
		}
	}

	return s
}

func isBlank(x ast.Expr) bool {
	ident, ok := x.(*ast.Ident)
	return ok && ident.Name == "_"
}

func simplify(f *ast.File) {
	var s simplifier

	// determine if f contains dot imports
	for _, imp := range f.Imports {
		if imp.Name != nil && imp.Name.Name == "." {
			s.hasDotImport = true
			break
		}
	}

	// remove empty declarations such as "const ()", etc
	removeEmptyDeclGroups(f)

	ast.Walk(&s, f)
}

func removeEmptyDeclGroups(f *ast.File) {
	i := 0
	for _, d := range f.Decls {
		if g, ok := d.(*ast.GenDecl); !ok || !isEmpty(f, g) {
			f.Decls[i] = d
			i++
		}
	}
	f.Decls = f.Decls[:i]
}

func isEmpty(f *ast.File, g *ast.GenDecl) bool {
	if g.Doc != nil || g.Specs != nil {
		return false
	}

	for _, c := range f.Comments {
		// if there is a comment in the declaration, it is not considered empty
		if g.Pos() <= c.Pos() && c.End() <= g.End() {
			return false
		}
	}

	return true
}
                                                        root/go1.4/src/cmd/gofmt/testdata/                                                                  0040755 0000000 0000000 00000000000 12600426232 015337  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/gofmt/testdata/comments.golden                                                   0100644 0000000 0000000 00000000114 12600426226 020352  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package main

func main() {}

// comment here

func f() {}

//line foo.go:1
                                                                                                                                                                                                                                                                                                                                                                                                                                                    root/go1.4/src/cmd/gofmt/testdata/comments.input                                                    0100644 0000000 0000000 00000000114 12600426226 020241  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package main

func main() {}

// comment here

func f() {}

//line foo.go:1
                                                                                                                                                                                                                                                                                                                                                                                                                                                    root/go1.4/src/cmd/gofmt/testdata/composites.golden                                                 0100644 0000000 0000000 00000004626 12600426226 020726  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -s

package P

type T struct {
	x, y int
}

var _ = [42]T{
	{},
	{1, 2},
	{3, 4},
}

var _ = [...]T{
	{},
	{1, 2},
	{3, 4},
}

var _ = []T{
	{},
	{1, 2},
	{3, 4},
}

var _ = []T{
	{},
	10: {1, 2},
	20: {3, 4},
}

var _ = []struct {
	x, y int
}{
	{},
	10: {1, 2},
	20: {3, 4},
}

var _ = []interface{}{
	T{},
	10: T{1, 2},
	20: T{3, 4},
}

var _ = [][]int{
	{},
	{1, 2},
	{3, 4},
}

var _ = [][]int{
	([]int{}),
	([]int{1, 2}),
	{3, 4},
}

var _ = [][][]int{
	{},
	{
		{},
		{0, 1, 2, 3},
		{4, 5},
	},
}

var _ = map[string]T{
	"foo": {},
	"bar": {1, 2},
	"bal": {3, 4},
}

var _ = map[string]struct {
	x, y int
}{
	"foo": {},
	"bar": {1, 2},
	"bal": {3, 4},
}

var _ = map[string]interface{}{
	"foo": T{},
	"bar": T{1, 2},
	"bal": T{3, 4},
}

var _ = map[string][]int{
	"foo": {},
	"bar": {1, 2},
	"bal": {3, 4},
}

var _ = map[string][]int{
	"foo": ([]int{}),
	"bar": ([]int{1, 2}),
	"bal": {3, 4},
}

// from exp/4s/data.go
var pieces4 = []Piece{
	{0, 0, Point{4, 1}, []Point{{0, 0}, {1, 0}, {1, 0}, {1, 0}}, nil, nil},
	{1, 0, Point{1, 4}, []Point{{0, 0}, {0, 1}, {0, 1}, {0, 1}}, nil, nil},
	{2, 0, Point{4, 1}, []Point{{0, 0}, {1, 0}, {1, 0}, {1, 0}}, nil, nil},
	{3, 0, Point{1, 4}, []Point{{0, 0}, {0, 1}, {0, 1}, {0, 1}}, nil, nil},
}

var _ = [42]*T{
	{},
	{1, 2},
	{3, 4},
}

var _ = [...]*T{
	{},
	{1, 2},
	{3, 4},
}

var _ = []*T{
	{},
	{1, 2},
	{3, 4},
}

var _ = []*T{
	{},
	10: {1, 2},
	20: {3, 4},
}

var _ = []*struct {
	x, y int
}{
	{},
	10: {1, 2},
	20: {3, 4},
}

var _ = []interface{}{
	&T{},
	10: &T{1, 2},
	20: &T{3, 4},
}

var _ = []*[]int{
	{},
	{1, 2},
	{3, 4},
}

var _ = []*[]int{
	(&[]int{}),
	(&[]int{1, 2}),
	{3, 4},
}

var _ = []*[]*[]int{
	{},
	{
		{},
		{0, 1, 2, 3},
		{4, 5},
	},
}

var _ = map[string]*T{
	"foo": {},
	"bar": {1, 2},
	"bal": {3, 4},
}

var _ = map[string]*struct {
	x, y int
}{
	"foo": {},
	"bar": {1, 2},
	"bal": {3, 4},
}

var _ = map[string]interface{}{
	"foo": &T{},
	"bar": &T{1, 2},
	"bal": &T{3, 4},
}

var _ = map[string]*[]int{
	"foo": {},
	"bar": {1, 2},
	"bal": {3, 4},
}

var _ = map[string]*[]int{
	"foo": (&[]int{}),
	"bar": (&[]int{1, 2}),
	"bal": {3, 4},
}

var pieces4 = []*Piece{
	{0, 0, Point{4, 1}, []Point{{0, 0}, {1, 0}, {1, 0}, {1, 0}}, nil, nil},
	{1, 0, Point{1, 4}, []Point{{0, 0}, {0, 1}, {0, 1}, {0, 1}}, nil, nil},
	{2, 0, Point{4, 1}, []Point{{0, 0}, {1, 0}, {1, 0}, {1, 0}}, nil, nil},
	{3, 0, Point{1, 4}, []Point{{0, 0}, {0, 1}, {0, 1}, {0, 1}}, nil, nil},
}
                                                                                                          root/go1.4/src/cmd/gofmt/testdata/composites.input                                                  0100644 0000000 0000000 00000006006 12600426226 020607  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -s

package P

type T struct {
	x, y int
}

var _ = [42]T{
	T{},
	T{1, 2},
	T{3, 4},
}

var _ = [...]T{
	T{},
	T{1, 2},
	T{3, 4},
}

var _ = []T{
	T{},
	T{1, 2},
	T{3, 4},
}

var _ = []T{
	T{},
	10: T{1, 2},
	20: T{3, 4},
}

var _ = []struct {
	x, y int
}{
	struct{ x, y int }{},
	10: struct{ x, y int }{1, 2},
	20: struct{ x, y int }{3, 4},
}

var _ = []interface{}{
	T{},
	10: T{1, 2},
	20: T{3, 4},
}

var _ = [][]int{
	[]int{},
	[]int{1, 2},
	[]int{3, 4},
}

var _ = [][]int{
	([]int{}),
	([]int{1, 2}),
	[]int{3, 4},
}

var _ = [][][]int{
	[][]int{},
	[][]int{
		[]int{},
		[]int{0, 1, 2, 3},
		[]int{4, 5},
	},
}

var _ = map[string]T{
	"foo": T{},
	"bar": T{1, 2},
	"bal": T{3, 4},
}

var _ = map[string]struct {
	x, y int
}{
	"foo": struct{ x, y int }{},
	"bar": struct{ x, y int }{1, 2},
	"bal": struct{ x, y int }{3, 4},
}

var _ = map[string]interface{}{
	"foo": T{},
	"bar": T{1, 2},
	"bal": T{3, 4},
}

var _ = map[string][]int{
	"foo": []int{},
	"bar": []int{1, 2},
	"bal": []int{3, 4},
}

var _ = map[string][]int{
	"foo": ([]int{}),
	"bar": ([]int{1, 2}),
	"bal": []int{3, 4},
}

// from exp/4s/data.go
var pieces4 = []Piece{
	Piece{0, 0, Point{4, 1}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{1, 0}}, nil, nil},
	Piece{1, 0, Point{1, 4}, []Point{Point{0, 0}, Point{0, 1}, Point{0, 1}, Point{0, 1}}, nil, nil},
	Piece{2, 0, Point{4, 1}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{1, 0}}, nil, nil},
	Piece{3, 0, Point{1, 4}, []Point{Point{0, 0}, Point{0, 1}, Point{0, 1}, Point{0, 1}}, nil, nil},
}

var _ = [42]*T{
	&T{},
	&T{1, 2},
	&T{3, 4},
}

var _ = [...]*T{
	&T{},
	&T{1, 2},
	&T{3, 4},
}

var _ = []*T{
	&T{},
	&T{1, 2},
	&T{3, 4},
}

var _ = []*T{
	&T{},
	10: &T{1, 2},
	20: &T{3, 4},
}

var _ = []*struct {
	x, y int
}{
	&struct{ x, y int }{},
	10: &struct{ x, y int }{1, 2},
	20: &struct{ x, y int }{3, 4},
}

var _ = []interface{}{
	&T{},
	10: &T{1, 2},
	20: &T{3, 4},
}

var _ = []*[]int{
	&[]int{},
	&[]int{1, 2},
	&[]int{3, 4},
}

var _ = []*[]int{
	(&[]int{}),
	(&[]int{1, 2}),
	&[]int{3, 4},
}

var _ = []*[]*[]int{
	&[]*[]int{},
	&[]*[]int{
		&[]int{},
		&[]int{0, 1, 2, 3},
		&[]int{4, 5},
	},
}

var _ = map[string]*T{
	"foo": &T{},
	"bar": &T{1, 2},
	"bal": &T{3, 4},
}

var _ = map[string]*struct {
	x, y int
}{
	"foo": &struct{ x, y int }{},
	"bar": &struct{ x, y int }{1, 2},
	"bal": &struct{ x, y int }{3, 4},
}

var _ = map[string]interface{}{
	"foo": &T{},
	"bar": &T{1, 2},
	"bal": &T{3, 4},
}

var _ = map[string]*[]int{
	"foo": &[]int{},
	"bar": &[]int{1, 2},
	"bal": &[]int{3, 4},
}

var _ = map[string]*[]int{
	"foo": (&[]int{}),
	"bar": (&[]int{1, 2}),
	"bal": &[]int{3, 4},
}

var pieces4 = []*Piece{
	&Piece{0, 0, Point{4, 1}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{1, 0}}, nil, nil},
	&Piece{1, 0, Point{1, 4}, []Point{Point{0, 0}, Point{0, 1}, Point{0, 1}, Point{0, 1}}, nil, nil},
	&Piece{2, 0, Point{4, 1}, []Point{Point{0, 0}, Point{1, 0}, Point{1, 0}, Point{1, 0}}, nil, nil},
	&Piece{3, 0, Point{1, 4}, []Point{Point{0, 0}, Point{0, 1}, Point{0, 1}, Point{0, 1}}, nil, nil},
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          root/go1.4/src/cmd/gofmt/testdata/crlf.golden                                                       0100644 0000000 0000000 00000000352 12600426226 017457  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
	Source containing CR/LF line endings.
	The gofmt'ed output must only have LF
	line endings.
	Test case for issue 3961.
*/
package main

func main() {
	// line comment
	println("hello, world!") // another line comment
	println()
}
                                                                                                                                                                                                                                                                                      root/go1.4/src/cmd/gofmt/testdata/crlf.input                                                        0100644 0000000 0000000 00000000367 12600426226 017354  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
	Source containing CR/LF line endings.
	The gofmt'ed output must only have LF
	line endings.
	Test case for issue 3961.
*/
package main

func main() {
	// line comment
	println("hello, world!") // another line comment
	println()
}
                                                                                                                                                                                                                                                                         root/go1.4/src/cmd/gofmt/testdata/emptydecl.golden                                                  0100644 0000000 0000000 00000000214 12600426226 020514  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -s

// Test case for issue 7631.

package main

// Keep this declaration
var ()

const (
// Keep this declaration
)

func main() {}
                                                                                                                                                                                                                                                                                                                                                                                    root/go1.4/src/cmd/gofmt/testdata/emptydecl.input                                                   0100644 0000000 0000000 00000000224 12600426226 020404  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -s

// Test case for issue 7631.

package main

// Keep this declaration
var ()

const (
// Keep this declaration
)

type ()

func main() {}                                                                                                                                                                                                                                                                                                                                                                            root/go1.4/src/cmd/gofmt/testdata/import.golden                                                     0100644 0000000 0000000 00000002053 12600426226 020043  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package main

import (
	"errors"
	"fmt"
	"io"
	"log"
	"math"
)

import (
	"fmt"

	"math"

	"log"

	"errors"

	"io"
)

import (
	"errors"
	"fmt"
	"io"
	"log"
	"math"

	"fmt"

	"math"

	"log"

	"errors"

	"io"
)

import (
	// a block with comments
	"errors"
	"fmt" // for Printf
	"io"  // for Reader
	"log" // for Fatal
	"math"
)

import (
	"fmt" // for Printf

	"math"

	"log" // for Fatal

	"errors"

	"io" // for Reader
)

import (
	// for Printf
	"fmt"

	"math"

	// for Fatal
	"log"

	"errors"

	// for Reader
	"io"
)

import (
	"errors"
	"fmt" // for Printf
	"io"  // for Reader
	"log" // for Fatal
	"math"

	"fmt" // for Printf

	"math"

	"log" // for Fatal

	"errors"

	"io" // for Reader
)

import (
	"fmt" // for Printf

	"errors"
	"io"  // for Reader
	"log" // for Fatal
	"math"

	"errors"
	"fmt" // for Printf
	"io"  // for Reader
	"log" // for Fatal
	"math"
)

// Test deduping and extended sorting
import (
	a "A" // aA
	b "A" // bA1
	b "A" // bA2
	"B"   // B
	. "B" // .B
	_ "B" // _b
	"C"
	a "D" // aD
)

import (
	"dedup_by_group"

	"dedup_by_group"
)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     root/go1.4/src/cmd/gofmt/testdata/import.input                                                      0100644 0000000 0000000 00000002115 12600426226 017731  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package main

import (
	"fmt"
	"math"
	"log"
	"errors"
	"io"
)

import (
	"fmt"

	"math"

	"log"

	"errors"

	"io"
)

import (
	"fmt"
	"math"
	"log"
	"errors"
	"io"

	"fmt"

	"math"

	"log"

	"errors"

	"io"
)

import (
	// a block with comments
	"fmt" // for Printf
	"math"
	"log" // for Fatal
	"errors"
	"io" // for Reader
)

import (
	"fmt" // for Printf

	"math"

	"log" // for Fatal

	"errors"

	"io" // for Reader
)

import (
	// for Printf
	"fmt"

	"math"

	// for Fatal
	"log"

	"errors"

	// for Reader
	"io"
)

import (
	"fmt" // for Printf
	"math"
	"log" // for Fatal
	"errors"
	"io" // for Reader

	"fmt" // for Printf

	"math"

	"log" // for Fatal

	"errors"

	"io" // for Reader
)

import (
	"fmt" // for Printf

	"math"
	"log" // for Fatal
	"errors"
	"io" // for Reader

	"fmt" // for Printf
	"math"
	"log" // for Fatal
	"errors"
	"io" // for Reader
)

// Test deduping and extended sorting
import (
	"B" // B
	a "A" // aA
	b "A" // bA2
	b "A" // bA1
	. "B" // .B
	. "B"
	"C"
	"C"
	"C"
	a "D" // aD
	"B"
	_ "B" // _b
)

import (
	"dedup_by_group"
	"dedup_by_group"

	"dedup_by_group"
)
                                                                                                                                                                                                                                                                                                                                                                                                                                                   root/go1.4/src/cmd/gofmt/testdata/old.golden                                                        0100644 0000000 0000000 00000000065 12600426226 017310  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package P

func f() {
	if x {
		y
	} else {
		z
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           root/go1.4/src/cmd/gofmt/testdata/old.input                                                         0100644 0000000 0000000 00000000060 12600426226 017172  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package P

func f() {
	if x {
		y
	} else
		z
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                root/go1.4/src/cmd/gofmt/testdata/ranges.golden                                                     0100644 0000000 0000000 00000000463 12600426226 020013  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -s

// Test cases for range simplification.
package p

func _() {
	for a, b = range x {
	}
	for a = range x {
	}
	for _, b = range x {
	}
	for range x {
	}

	for a = range x {
	}
	for range x {
	}

	for a, b := range x {
	}
	for a := range x {
	}
	for _, b := range x {
	}

	for a := range x {
	}
}
                                                                                                                                                                                                             root/go1.4/src/cmd/gofmt/testdata/ranges.input                                                      0100644 0000000 0000000 00000000460 12600426226 017677  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -s

// Test cases for range simplification.
package p

func _() {
	for a, b = range x {}
	for a, _ = range x {}
	for _, b = range x {}
	for _, _ = range x {}

	for a = range x {}
	for _ = range x {}

	for a, b := range x {}
	for a, _ := range x {}
	for _, b := range x {}

	for a := range x {}
}
                                                                                                                                                                                                                root/go1.4/src/cmd/gofmt/testdata/rewrite1.golden                                                   0100644 0000000 0000000 00000000370 12600426226 020273  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -r=Foo->Bar

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

type Bar int

func main() {
	var a Bar
	println(a)
}
                                                                                                                                                                                                                                                                        root/go1.4/src/cmd/gofmt/testdata/rewrite1.input                                                    0100644 0000000 0000000 00000000370 12600426226 020162  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -r=Foo->Bar

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

type Foo int

func main() {
	var a Foo
	println(a)
}
                                                                                                                                                                                                                                                                        root/go1.4/src/cmd/gofmt/testdata/rewrite2.golden                                                   0100644 0000000 0000000 00000000627 12600426226 020301  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -r=int->bool

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package p

// Slices have nil Len values in the corresponding ast.ArrayType
// node and reflect.NewValue(slice.Len) is an invalid reflect.Value.
// The rewriter must not crash in that case. Was issue 1696.
func f() []bool {}
                                                                                                         root/go1.4/src/cmd/gofmt/testdata/rewrite2.input                                                    0100644 0000000 0000000 00000000626 12600426226 020167  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -r=int->bool

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package p

// Slices have nil Len values in the corresponding ast.ArrayType
// node and reflect.NewValue(slice.Len) is an invalid reflect.Value.
// The rewriter must not crash in that case. Was issue 1696.
func f() []int {}
                                                                                                          root/go1.4/src/cmd/gofmt/testdata/rewrite3.golden                                                   0100644 0000000 0000000 00000000646 12600426226 020303  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -r=x->x

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

// Field tags are *ast.BasicLit nodes that are nil when the tag is
// absent. These nil nodes must not be mistaken for expressions,
// the rewriter should not try to dereference them. Was issue 2410.
type Foo struct {
	Field int
}
                                                                                          root/go1.4/src/cmd/gofmt/testdata/rewrite3.input                                                    0100644 0000000 0000000 00000000646 12600426226 020172  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -r=x->x

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

// Field tags are *ast.BasicLit nodes that are nil when the tag is
// absent. These nil nodes must not be mistaken for expressions,
// the rewriter should not try to dereference them. Was issue 2410.
type Foo struct {
	Field int
}
                                                                                          root/go1.4/src/cmd/gofmt/testdata/rewrite4.golden                                                   0100644 0000000 0000000 00000002047 12600426226 020301  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -r=(x)->x

// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Rewriting of parenthesized expressions (x) -> x
// must not drop parentheses if that would lead to
// wrong association of the operands.
// Was issue 1847.

package main

// From example 1 of issue 1847.
func _() {
	var t = (&T{1000}).Id()
}

// From example 2 of issue 1847.
func _() {
	fmt.Println((*xpp).a)
}

// Some more test cases.
func _() {
	_ = (-x).f
	_ = (*x).f
	_ = (&x).f
	_ = (!x).f
	_ = -x.f
	_ = *x.f
	_ = &x.f
	_ = !x.f
	(-x).f()
	(*x).f()
	(&x).f()
	(!x).f()
	_ = -x.f()
	_ = *x.f()
	_ = &x.f()
	_ = !x.f()

	_ = (-x).f
	_ = (*x).f
	_ = (&x).f
	_ = (!x).f
	_ = -x.f
	_ = *x.f
	_ = &x.f
	_ = !x.f
	(-x).f()
	(*x).f()
	(&x).f()
	(!x).f()
	_ = -x.f()
	_ = *x.f()
	_ = &x.f()
	_ = !x.f()

	_ = -x.f
	_ = *x.f
	_ = &x.f
	_ = !x.f
	_ = -x.f
	_ = *x.f
	_ = &x.f
	_ = !x.f
	_ = -x.f()
	_ = *x.f()
	_ = &x.f()
	_ = !x.f()
	_ = -x.f()
	_ = *x.f()
	_ = &x.f()
	_ = !x.f()
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         root/go1.4/src/cmd/gofmt/testdata/rewrite4.input                                                    0100644 0000000 0000000 00000002175 12600426226 020172  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -r=(x)->x

// Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Rewriting of parenthesized expressions (x) -> x
// must not drop parentheses if that would lead to
// wrong association of the operands.
// Was issue 1847.

package main

// From example 1 of issue 1847.
func _() {
	var t = (&T{1000}).Id()
}

// From example 2 of issue 1847.
func _() {
       fmt.Println((*xpp).a)
}

// Some more test cases.
func _() {
	_ = (-x).f
	_ = (*x).f
	_ = (&x).f
	_ = (!x).f
	_ = (-x.f)
	_ = (*x.f)
	_ = (&x.f)
	_ = (!x.f)
	(-x).f()
	(*x).f()
	(&x).f()
	(!x).f()
	_ = (-x.f())
	_ = (*x.f())
	_ = (&x.f())
	_ = (!x.f())

	_ = ((-x)).f
	_ = ((*x)).f
	_ = ((&x)).f
	_ = ((!x)).f
	_ = ((-x.f))
	_ = ((*x.f))
	_ = ((&x.f))
	_ = ((!x.f))
	((-x)).f()
	((*x)).f()
	((&x)).f()
	((!x)).f()
	_ = ((-x.f()))
	_ = ((*x.f()))
	_ = ((&x.f()))
	_ = ((!x.f()))

	_ = -(x).f
	_ = *(x).f
	_ = &(x).f
	_ = !(x).f
	_ = -x.f
	_ = *x.f
	_ = &x.f
	_ = !x.f
	_ = -(x).f()
	_ = *(x).f()
	_ = &(x).f()
	_ = !(x).f()
	_ = -x.f()
	_ = *x.f()
	_ = &x.f()
	_ = !x.f()
}
                                                                                                                                                                                                                                                                                                                                                                                                   root/go1.4/src/cmd/gofmt/testdata/rewrite5.golden                                                   0100644 0000000 0000000 00000000676 12600426226 020310  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -r=x+x->2*x

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Rewriting of expressions containing nodes with associated comments to
// expressions without those nodes must also eliminate the associated
// comments.

package p

func f(x int) int {
	_ = 2 * x // this comment remains in the rewrite
	_ = 2 * x
	return 2 * x
}
                                                                  root/go1.4/src/cmd/gofmt/testdata/rewrite5.input                                                    0100644 0000000 0000000 00000001032 12600426226 020162  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -r=x+x->2*x

// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Rewriting of expressions containing nodes with associated comments to
// expressions without those nodes must also eliminate the associated
// comments.

package p

func f(x int) int {
	_ = x + x // this comment remains in the rewrite
	_ = x /* this comment must not be in the rewrite */ + x
	return x /* this comment must not be in the rewrite */ + x
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      root/go1.4/src/cmd/gofmt/testdata/rewrite6.golden                                                   0100644 0000000 0000000 00000000717 12600426226 020305  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -r=fun(x)->Fun(x)

// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Rewriting of calls must take the ... (ellipsis)
// attribute for the last argument into account.

package p

func fun(x []int) {}

func g(x []int) {
	Fun(x)    // -r='fun(x)->Fun(x)' should rewrite this to Fun(x)
	fun(x...) // -r='fun(x)->Fun(x)' should not rewrite this
}
                                                 root/go1.4/src/cmd/gofmt/testdata/rewrite6.input                                                    0100644 0000000 0000000 00000000717 12600426226 020174  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -r=fun(x)->Fun(x)

// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Rewriting of calls must take the ... (ellipsis)
// attribute for the last argument into account.

package p

func fun(x []int) {}

func g(x []int) {
	fun(x)    // -r='fun(x)->Fun(x)' should rewrite this to Fun(x)
	fun(x...) // -r='fun(x)->Fun(x)' should not rewrite this
}
                                                 root/go1.4/src/cmd/gofmt/testdata/rewrite7.golden                                                   0100644 0000000 0000000 00000000722 12600426226 020302  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -r=fun(x...)->Fun(x)

// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Rewriting of calls must take the ... (ellipsis)
// attribute for the last argument into account.

package p

func fun(x []int) {}

func g(x []int) {
	fun(x) // -r='fun(x...)->Fun(x)' should not rewrite this
	Fun(x) // -r='fun(x...)->Fun(x)' should rewrite this to Fun(x)
}
                                              root/go1.4/src/cmd/gofmt/testdata/rewrite7.input                                                    0100644 0000000 0000000 00000000730 12600426226 020170  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -r=fun(x...)->Fun(x)

// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Rewriting of calls must take the ... (ellipsis)
// attribute for the last argument into account.

package p

func fun(x []int) {}

func g(x []int) {
	fun(x)    // -r='fun(x...)->Fun(x)' should not rewrite this
	fun(x...) // -r='fun(x...)->Fun(x)' should rewrite this to Fun(x)
}
                                        root/go1.4/src/cmd/gofmt/testdata/rewrite8.golden                                                   0100644 0000000 0000000 00000000444 12600426226 020304  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -r=interface{}->int

// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Check that literal type expression rewrites are accepted.
// Was issue 4406.

package p

type T int
                                                                                                                                                                                                                            root/go1.4/src/cmd/gofmt/testdata/rewrite8.input                                                    0100644 0000000 0000000 00000000454 12600426226 020174  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -r=interface{}->int

// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Check that literal type expression rewrites are accepted.
// Was issue 4406.

package p

type T interface{}
                                                                                                                                                                                                                    root/go1.4/src/cmd/gofmt/testdata/slices1.golden                                                    0100644 0000000 0000000 00000001637 12600426226 020103  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -s

// Test cases for slice expression simplification.
package p

var (
	a [10]byte
	b [20]float32
	s []int
	t struct {
		s []byte
	}

	_ = a[0:]
	_ = a[1:10]
	_ = a[2:]
	_ = a[3:(len(a))]
	_ = a[len(a) : len(a)-1]
	_ = a[0:len(b)]
	_ = a[2:len(a):len(a)]

	_ = a[:]
	_ = a[:10]
	_ = a[:]
	_ = a[:(len(a))]
	_ = a[:len(a)-1]
	_ = a[:len(b)]
	_ = a[:len(a):len(a)]

	_ = s[0:]
	_ = s[1:10]
	_ = s[2:]
	_ = s[3:(len(s))]
	_ = s[len(a) : len(s)-1]
	_ = s[0:len(b)]
	_ = s[2:len(s):len(s)]

	_ = s[:]
	_ = s[:10]
	_ = s[:]
	_ = s[:(len(s))]
	_ = s[:len(s)-1]
	_ = s[:len(b)]
	_ = s[:len(s):len(s)]

	_ = t.s[0:]
	_ = t.s[1:10]
	_ = t.s[2:len(t.s)]
	_ = t.s[3:(len(t.s))]
	_ = t.s[len(a) : len(t.s)-1]
	_ = t.s[0:len(b)]
	_ = t.s[2:len(t.s):len(t.s)]

	_ = t.s[:]
	_ = t.s[:10]
	_ = t.s[:len(t.s)]
	_ = t.s[:(len(t.s))]
	_ = t.s[:len(t.s)-1]
	_ = t.s[:len(b)]
	_ = t.s[:len(t.s):len(t.s)]
)

func _() {
	s := s[0:]
	_ = s
}
                                                                                                 root/go1.4/src/cmd/gofmt/testdata/slices1.input                                                     0100644 0000000 0000000 00000001675 12600426226 017774  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -s

// Test cases for slice expression simplification.
package p

var (
	a [10]byte
	b [20]float32
	s []int
	t struct {
		s []byte
	}

	_ = a[0:]
	_ = a[1:10]
	_ = a[2:len(a)]
	_ = a[3:(len(a))]
	_ = a[len(a) : len(a)-1]
	_ = a[0:len(b)]
	_ = a[2:len(a):len(a)]

	_ = a[:]
	_ = a[:10]
	_ = a[:len(a)]
	_ = a[:(len(a))]
	_ = a[:len(a)-1]
	_ = a[:len(b)]
	_ = a[:len(a):len(a)]

	_ = s[0:]
	_ = s[1:10]
	_ = s[2:len(s)]
	_ = s[3:(len(s))]
	_ = s[len(a) : len(s)-1]
	_ = s[0:len(b)]
	_ = s[2:len(s):len(s)]

	_ = s[:]
	_ = s[:10]
	_ = s[:len(s)]
	_ = s[:(len(s))]
	_ = s[:len(s)-1]
	_ = s[:len(b)]
	_ = s[:len(s):len(s)]

	_ = t.s[0:]
	_ = t.s[1:10]
	_ = t.s[2:len(t.s)]
	_ = t.s[3:(len(t.s))]
	_ = t.s[len(a) : len(t.s)-1]
	_ = t.s[0:len(b)]
	_ = t.s[2:len(t.s):len(t.s)]

	_ = t.s[:]
	_ = t.s[:10]
	_ = t.s[:len(t.s)]
	_ = t.s[:(len(t.s))]
	_ = t.s[:len(t.s)-1]
	_ = t.s[:len(b)]
	_ = t.s[:len(t.s):len(t.s)]
)

func _() {
	s := s[0:len(s)]
	_ = s
}
                                                                   root/go1.4/src/cmd/gofmt/testdata/slices2.golden                                                    0100644 0000000 0000000 00000001565 12600426226 020104  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -s

// Test cases for slice expression simplification.
// Because of a dot import, these slices must remain untouched.
package p

import . "math"

var (
	a [10]byte
	b [20]float32
	s []int
	t struct {
		s []byte
	}

	_ = a[0:]
	_ = a[1:10]
	_ = a[2:len(a)]
	_ = a[3:(len(a))]
	_ = a[len(a) : len(a)-1]
	_ = a[0:len(b)]

	_ = a[:]
	_ = a[:10]
	_ = a[:len(a)]
	_ = a[:(len(a))]
	_ = a[:len(a)-1]
	_ = a[:len(b)]

	_ = s[0:]
	_ = s[1:10]
	_ = s[2:len(s)]
	_ = s[3:(len(s))]
	_ = s[len(a) : len(s)-1]
	_ = s[0:len(b)]

	_ = s[:]
	_ = s[:10]
	_ = s[:len(s)]
	_ = s[:(len(s))]
	_ = s[:len(s)-1]
	_ = s[:len(b)]

	_ = t.s[0:]
	_ = t.s[1:10]
	_ = t.s[2:len(t.s)]
	_ = t.s[3:(len(t.s))]
	_ = t.s[len(a) : len(t.s)-1]
	_ = t.s[0:len(b)]

	_ = t.s[:]
	_ = t.s[:10]
	_ = t.s[:len(t.s)]
	_ = t.s[:(len(t.s))]
	_ = t.s[:len(t.s)-1]
	_ = t.s[:len(b)]
)

func _() {
	s := s[0:len(s)]
	_ = s
}
                                                                                                                                           root/go1.4/src/cmd/gofmt/testdata/slices2.input                                                     0100644 0000000 0000000 00000001565 12600426226 017773  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -s

// Test cases for slice expression simplification.
// Because of a dot import, these slices must remain untouched.
package p

import . "math"

var (
	a [10]byte
	b [20]float32
	s []int
	t struct {
		s []byte
	}

	_ = a[0:]
	_ = a[1:10]
	_ = a[2:len(a)]
	_ = a[3:(len(a))]
	_ = a[len(a) : len(a)-1]
	_ = a[0:len(b)]

	_ = a[:]
	_ = a[:10]
	_ = a[:len(a)]
	_ = a[:(len(a))]
	_ = a[:len(a)-1]
	_ = a[:len(b)]

	_ = s[0:]
	_ = s[1:10]
	_ = s[2:len(s)]
	_ = s[3:(len(s))]
	_ = s[len(a) : len(s)-1]
	_ = s[0:len(b)]

	_ = s[:]
	_ = s[:10]
	_ = s[:len(s)]
	_ = s[:(len(s))]
	_ = s[:len(s)-1]
	_ = s[:len(b)]

	_ = t.s[0:]
	_ = t.s[1:10]
	_ = t.s[2:len(t.s)]
	_ = t.s[3:(len(t.s))]
	_ = t.s[len(a) : len(t.s)-1]
	_ = t.s[0:len(b)]

	_ = t.s[:]
	_ = t.s[:10]
	_ = t.s[:len(t.s)]
	_ = t.s[:(len(t.s))]
	_ = t.s[:len(t.s)-1]
	_ = t.s[:len(b)]
)

func _() {
	s := s[0:len(s)]
	_ = s
}
                                                                                                                                           root/go1.4/src/cmd/gofmt/testdata/stdin1.golden                                                     0100644 0000000 0000000 00000000040 12600426226 017725  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        	//gofmt -stdin

	if x {
		y
	}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                root/go1.4/src/cmd/gofmt/testdata/stdin1.input                                                      0100644 0000000 0000000 00000000040 12600426226 017614  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        	//gofmt -stdin

	if x {
		y
	}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                root/go1.4/src/cmd/gofmt/testdata/stdin2.golden                                                     0100644 0000000 0000000 00000000145 12600426226 017734  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -stdin

var x int

func f() {
	y := z
	/* this is a comment */
	// this is a comment too
}


                                                                                                                                                                                                                                                                                                                                                                                                                           root/go1.4/src/cmd/gofmt/testdata/stdin2.input                                                      0100644 0000000 0000000 00000000145 12600426226 017623  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -stdin

var x int


func f() { y := z
	/* this is a comment */
	// this is a comment too
}


                                                                                                                                                                                                                                                                                                                                                                                                                           root/go1.4/src/cmd/gofmt/testdata/stdin3.golden                                                     0100644 0000000 0000000 00000000145 12600426226 017735  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        		//gofmt -stdin

		/* note: no newline at end of file */
		for i := 0; i < 10; i++ {
			s += i
		}
	                                                                                                                                                                                                                                                                                                                                                                                                                           root/go1.4/src/cmd/gofmt/testdata/stdin3.input                                                      0100644 0000000 0000000 00000000140 12600426226 017617  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        		//gofmt -stdin

		/* note: no newline at end of file */
		for i := 0; i < 10; i++ { s += i }
	                                                                                                                                                                                                                                                                                                                                                                                                                                root/go1.4/src/cmd/gofmt/testdata/stdin4.golden                                                     0100644 0000000 0000000 00000000046 12600426226 017736  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        	//gofmt -stdin

	// comment

	i := 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          root/go1.4/src/cmd/gofmt/testdata/stdin4.input                                                      0100644 0000000 0000000 00000000047 12600426226 017626  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        	//gofmt -stdin

	// comment
	
	i := 0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         root/go1.4/src/cmd/gofmt/testdata/stdin5.golden                                                     0100644 0000000 0000000 00000000067 12600426226 017742  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -stdin

i := 5 // Line comment without newline.                                                                                                                                                                                                                                                                                                                                                                                                                                                                         root/go1.4/src/cmd/gofmt/testdata/stdin5.input                                                      0100644 0000000 0000000 00000000066 12600426226 017630  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        //gofmt -stdin

i  :=5// Line comment without newline.                                                                                                                                                                                                                                                                                                                                                                                                                                                                          root/go1.4/src/cmd/gofmt/testdata/stdin6.golden                                                     0100644 0000000 0000000 00000000307 12600426226 017740  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        	//gofmt -stdin

	if err != nil {
		source := strings.NewReader(`line 1.
line 2.
`)
		return source
	}

	f := func(hat, tail string) {

		fmt.Println(hat+`
foo


`+tail,
			"more",
			"and more")
	}
                                                                                                                                                                                                                                                                                                                         root/go1.4/src/cmd/gofmt/testdata/stdin6.input                                                      0100644 0000000 0000000 00000000331 12600426226 017624  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        	//gofmt -stdin

	if err != nil {
		source := strings.NewReader(`line 1.
line 2.
`)
		return source
	}

	f:=func(  hat, tail string){



		   fmt.  Println  (   hat+   `
foo


`+ tail  ,
 "more" ,
		"and more"   )
	}
                                                                                                                                                                                                                                                                                                       root/go1.4/src/cmd/gofmt/testdata/stdin7.golden                                                     0100644 0000000 0000000 00000000526 12600426226 017744  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        															//gofmt -stdin

															if err != nil {
																source := strings.NewReader(`line 1.
line 2.
`)
																return source
															}

															f := func(hat, tail string) {

																fmt.Println(hat+`
		foo


	`+tail,
																	"more",
																	"and more")
															}
                                                                                                                                                                          root/go1.4/src/cmd/gofmt/testdata/stdin7.input                                                      0100644 0000000 0000000 00000000450 12600426226 017627  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        															//gofmt -stdin

															if err != nil {
								source := strings.NewReader(`line 1.
line 2.
`)
								return source
							}

							f:=func(  hat, tail string){



								   fmt.  Println  (   hat+   `
		foo


	`+ tail  ,
						 "more" ,
								"and more"   )
							}
                                                                                                                                                                                                                        root/go1.4/src/cmd/gofmt/testdata/typeswitch.golden                                                 0100644 0000000 0000000 00000002704 12600426226 020737  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
	Parenthesized type switch expressions originally
	accepted by gofmt must continue to be rewritten
	into the correct unparenthesized form.

	Only type-switches that didn't declare a variable
	in the type switch type assertion and which
	contained only "expression-like" (named) types in their
	cases were permitted to have their type assertion parenthesized
	by go/parser (due to a weak predicate in the parser). All others
	were rejected always, either with a syntax error in the
	type switch header or in the case.

	See also issue 4470.
*/
package p

func f() {
	var x interface{}
	switch x.(type) { // should remain the same
	}
	switch x.(type) { // should become: switch x.(type) {
	}

	switch x.(type) { // should remain the same
	case int:
	}
	switch x.(type) { // should become: switch x.(type) {
	case int:
	}

	switch x.(type) { // should remain the same
	case []int:
	}

	// Parenthesized (x.(type)) in type switches containing cases
	// with unnamed (literal) types were never permitted by gofmt;
	// thus there won't be any code in the wild using this style if
	// the code was gofmt-ed.
	/*
		switch (x.(type)) {
		case []int:
		}
	*/

	switch t := x.(type) { // should remain the same
	default:
		_ = t
	}

	// Parenthesized (x.(type)) in type switches declaring a variable
	// were never permitted by gofmt; thus there won't be any code in
	// the wild using this style if the code was gofmt-ed.
	/*
		switch t := (x.(type)) {
		default:
			_ = t
		}
	*/
}
                                                            root/go1.4/src/cmd/gofmt/testdata/typeswitch.input                                                  0100644 0000000 0000000 00000002701 12600426226 020623  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
	Parenthesized type switch expressions originally
	accepted by gofmt must continue to be rewritten
	into the correct unparenthesized form.

	Only type-switches that didn't declare a variable
	in the type switch type assertion and which
	contained only "expression-like" (named) types in their
	cases were permitted to have their type assertion parenthesized
	by go/parser (due to a weak predicate in the parser). All others
	were rejected always, either with a syntax error in the
	type switch header or in the case.

	See also issue 4470.
*/
package p

func f() {
	var x interface{}
	switch x.(type) { // should remain the same
	}
	switch (x.(type)) { // should become: switch x.(type) {
	}

	switch x.(type) { // should remain the same
	case int:
	}
	switch (x.(type)) { // should become: switch x.(type) {
	case int:
	}

	switch x.(type) { // should remain the same
	case []int:
	}

	// Parenthesized (x.(type)) in type switches containing cases
	// with unnamed (literal) types were never permitted by gofmt;
	// thus there won't be any code in the wild using this style if
	// the code was gofmt-ed.
	/*
	switch (x.(type)) {
	case []int:
	}
	*/

	switch t := x.(type) { // should remain the same
	default:
		_ = t
	}

	// Parenthesized (x.(type)) in type switches declaring a variable
	// were never permitted by gofmt; thus there won't be any code in
	// the wild using this style if the code was gofmt-ed.
	/*
	switch t := (x.(type)) {
	default:
		_ = t
	}
	*/
}
                                                               root/go1.4/src/cmd/internal/                                                                        0040755 0000000 0000000 00000000000 12600426232 014226  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/internal/goobj/                                                                  0040755 0000000 0000000 00000000000 12600426232 015326  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/internal/goobj/read.go                                                           0100644 0000000 0000000 00000042074 12600426226 016577  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package goobj implements reading of Go object files and archives.
//
// TODO(rsc): Decide where this package should live. (golang.org/issue/6932)
// TODO(rsc): Decide the appropriate integer types for various fields.
// TODO(rsc): Write tests. (File format still up in the air a little.)
package goobj

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"
)

// A SymKind describes the kind of memory represented by a symbol.
type SymKind int

// This list is taken from include/link.h.

// Defined SymKind values.
// TODO(rsc): Give idiomatic Go names.
// TODO(rsc): Reduce the number of symbol types in the object files.
const (
	_ SymKind = iota

	// readonly, executable
	STEXT
	SELFRXSECT

	// readonly, non-executable
	STYPE
	SSTRING
	SGOSTRING
	SGOFUNC
	SRODATA
	SFUNCTAB
	STYPELINK
	SSYMTAB // TODO: move to unmapped section
	SPCLNTAB
	SELFROSECT

	// writable, non-executable
	SMACHOPLT
	SELFSECT
	SMACHO // Mach-O __nl_symbol_ptr
	SMACHOGOT
	SNOPTRDATA
	SINITARR
	SDATA
	SWINDOWS
	SBSS
	SNOPTRBSS
	STLSBSS

	// not mapped
	SXREF
	SMACHOSYMSTR
	SMACHOSYMTAB
	SMACHOINDIRECTPLT
	SMACHOINDIRECTGOT
	SFILE
	SFILEPATH
	SCONST
	SDYNIMPORT
	SHOSTOBJ
)

var symKindStrings = []string{
	SBSS:              "SBSS",
	SCONST:            "SCONST",
	SDATA:             "SDATA",
	SDYNIMPORT:        "SDYNIMPORT",
	SELFROSECT:        "SELFROSECT",
	SELFRXSECT:        "SELFRXSECT",
	SELFSECT:          "SELFSECT",
	SFILE:             "SFILE",
	SFILEPATH:         "SFILEPATH",
	SFUNCTAB:          "SFUNCTAB",
	SGOFUNC:           "SGOFUNC",
	SGOSTRING:         "SGOSTRING",
	SHOSTOBJ:          "SHOSTOBJ",
	SINITARR:          "SINITARR",
	SMACHO:            "SMACHO",
	SMACHOGOT:         "SMACHOGOT",
	SMACHOINDIRECTGOT: "SMACHOINDIRECTGOT",
	SMACHOINDIRECTPLT: "SMACHOINDIRECTPLT",
	SMACHOPLT:         "SMACHOPLT",
	SMACHOSYMSTR:      "SMACHOSYMSTR",
	SMACHOSYMTAB:      "SMACHOSYMTAB",
	SNOPTRBSS:         "SNOPTRBSS",
	SNOPTRDATA:        "SNOPTRDATA",
	SPCLNTAB:          "SPCLNTAB",
	SRODATA:           "SRODATA",
	SSTRING:           "SSTRING",
	SSYMTAB:           "SSYMTAB",
	STEXT:             "STEXT",
	STLSBSS:           "STLSBSS",
	STYPE:             "STYPE",
	STYPELINK:         "STYPELINK",
	SWINDOWS:          "SWINDOWS",
	SXREF:             "SXREF",
}

func (k SymKind) String() string {
	if k < 0 || int(k) >= len(symKindStrings) {
		return fmt.Sprintf("SymKind(%d)", k)
	}
	return symKindStrings[k]
}

// A Sym is a named symbol in an object file.
type Sym struct {
	SymID         // symbol identifier (name and version)
	Kind  SymKind // kind of symbol
	DupOK bool    // are duplicate definitions okay?
	Size  int     // size of corresponding data
	Type  SymID   // symbol for Go type information
	Data  Data    // memory image of symbol
	Reloc []Reloc // relocations to apply to Data
	Func  *Func   // additional data for functions
}

// A SymID - the combination of Name and Version - uniquely identifies
// a symbol within a package.
type SymID struct {
	// Name is the name of a symbol.
	Name string

	// Version is zero for symbols with global visibility.
	// Symbols with only file visibility (such as file-level static
	// declarations in C) have a non-zero version distinguishing
	// a symbol in one file from a symbol of the same name
	// in another file
	Version int
}

func (s SymID) String() string {
	if s.Version == 0 {
		return s.Name
	}
	return fmt.Sprintf("%s<%d>", s.Name, s.Version)
}

// A Data is a reference to data stored in an object file.
// It records the offset and size of the data, so that a client can
// read the data only if necessary.
type Data struct {
	Offset int64
	Size   int64
}

// A Reloc describes a relocation applied to a memory image to refer
// to an address within a particular symbol.
type Reloc struct {
	// The bytes at [Offset, Offset+Size) within the memory image
	// should be updated to refer to the address Add bytes after the start
	// of the symbol Sym.
	Offset int
	Size   int
	Sym    SymID
	Add    int

	// The Type records the form of address expected in the bytes
	// described by the previous fields: absolute, PC-relative, and so on.
	// TODO(rsc): The interpretation of Type is not exposed by this package.
	Type int
}

// A Var describes a variable in a function stack frame: a declared
// local variable, an input argument, or an output result.
type Var struct {
	// The combination of Name, Kind, and Offset uniquely
	// identifies a variable in a function stack frame.
	// Using fewer of these - in particular, using only Name - does not.
	Name   string // Name of variable.
	Kind   int    // TODO(rsc): Define meaning.
	Offset int    // Frame offset. TODO(rsc): Define meaning.

	Type SymID // Go type for variable.
}

// Func contains additional per-symbol information specific to functions.
type Func struct {
	Args     int        // size in bytes of argument frame: inputs and outputs
	Frame    int        // size in bytes of local variable frame
	Leaf     bool       // function omits save of link register (ARM)
	NoSplit  bool       // function omits stack split prologue
	Var      []Var      // detail about local variables
	PCSP     Data       // PC  SP offset map
	PCFile   Data       // PC  file number map (index into File)
	PCLine   Data       // PC  line number map
	PCData   []Data     // PC  runtime support data map
	FuncData []FuncData // non-PC-specific runtime support data
	File     []string   // paths indexed by PCFile
}

// TODO: Add PCData []byte and PCDataIter (similar to liblink).

// A FuncData is a single function-specific data value.
type FuncData struct {
	Sym    SymID // symbol holding data
	Offset int64 // offset into symbol for funcdata pointer
}

// A Package is a parsed Go object file or archive defining a Go package.
type Package struct {
	ImportPath string   // import path denoting this package
	Imports    []string // packages imported by this package
	Syms       []*Sym   // symbols defined by this package
	MaxVersion int      // maximum Version in any SymID in Syms
}

var (
	archiveHeader = []byte("!<arch>\n")
	archiveMagic  = []byte("`\n")
	goobjHeader   = []byte("go objec") // truncated to size of archiveHeader

	errCorruptArchive   = errors.New("corrupt archive")
	errTruncatedArchive = errors.New("truncated archive")
	errNotArchive       = errors.New("unrecognized archive format")

	errCorruptObject   = errors.New("corrupt object file")
	errTruncatedObject = errors.New("truncated object file")
	errNotObject       = errors.New("unrecognized object file format")
)

// An objReader is an object file reader.
type objReader struct {
	p         *Package
	b         *bufio.Reader
	f         io.ReadSeeker
	err       error
	offset    int64
	limit     int64
	tmp       [256]byte
	pkg       string
	pkgprefix string
}

// importPathToPrefix returns the prefix that will be used in the
// final symbol table for the given import path.
// We escape '%', '"', all control characters and non-ASCII bytes,
// and any '.' after the final slash.
//
// See ../../../cmd/ld/lib.c:/^pathtoprefix and
// ../../../cmd/gc/subr.c:/^pathtoprefix.
func importPathToPrefix(s string) string {
	// find index of last slash, if any, or else -1.
	// used for determining whether an index is after the last slash.
	slash := strings.LastIndex(s, "/")

	// check for chars that need escaping
	n := 0
	for r := 0; r < len(s); r++ {
		if c := s[r]; c <= ' ' || (c == '.' && r > slash) || c == '%' || c == '"' || c >= 0x7F {
			n++
		}
	}

	// quick exit
	if n == 0 {
		return s
	}

	// escape
	const hex = "0123456789abcdef"
	p := make([]byte, 0, len(s)+2*n)
	for r := 0; r < len(s); r++ {
		if c := s[r]; c <= ' ' || (c == '.' && r > slash) || c == '%' || c == '"' || c >= 0x7F {
			p = append(p, '%', hex[c>>4], hex[c&0xF])
		} else {
			p = append(p, c)
		}
	}

	return string(p)
}

// init initializes r to read package p from f.
func (r *objReader) init(f io.ReadSeeker, p *Package) {
	r.f = f
	r.p = p
	r.offset, _ = f.Seek(0, 1)
	r.limit, _ = f.Seek(0, 2)
	f.Seek(r.offset, 0)
	r.b = bufio.NewReader(f)
	r.pkgprefix = importPathToPrefix(p.ImportPath) + "."
}

// error records that an error occurred.
// It returns only the first error, so that an error
// caused by an earlier error does not discard information
// about the earlier error.
func (r *objReader) error(err error) error {
	if r.err == nil {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
		r.err = err
	}
	// panic("corrupt") // useful for debugging
	return r.err
}

// readByte reads and returns a byte from the input file.
// On I/O error or EOF, it records the error but returns byte 0.
// A sequence of 0 bytes will eventually terminate any
// parsing state in the object file. In particular, it ends the
// reading of a varint.
func (r *objReader) readByte() byte {
	if r.err != nil {
		return 0
	}
	if r.offset >= r.limit {
		r.error(io.ErrUnexpectedEOF)
		return 0
	}
	b, err := r.b.ReadByte()
	if err != nil {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
		r.error(err)
		b = 0
	} else {
		r.offset++
	}
	return b
}

// read reads exactly len(b) bytes from the input file.
// If an error occurs, read returns the error but also
// records it, so it is safe for callers to ignore the result
// as long as delaying the report is not a problem.
func (r *objReader) readFull(b []byte) error {
	if r.err != nil {
		return r.err
	}
	if r.offset+int64(len(b)) > r.limit {
		return r.error(io.ErrUnexpectedEOF)
	}
	n, err := io.ReadFull(r.b, b)
	r.offset += int64(n)
	if err != nil {
		return r.error(err)
	}
	return nil
}

// readInt reads a zigzag varint from the input file.
func (r *objReader) readInt() int {
	var u uint64

	for shift := uint(0); ; shift += 7 {
		if shift >= 64 {
			r.error(errCorruptObject)
			return 0
		}
		c := r.readByte()
		u |= uint64(c&0x7F) << shift
		if c&0x80 == 0 {
			break
		}
	}

	v := int64(u>>1) ^ (int64(u) << 63 >> 63)
	if int64(int(v)) != v {
		r.error(errCorruptObject) // TODO
		return 0
	}
	return int(v)
}

// readString reads a length-delimited string from the input file.
func (r *objReader) readString() string {
	n := r.readInt()
	buf := make([]byte, n)
	r.readFull(buf)
	return string(buf)
}

// readSymID reads a SymID from the input file.
func (r *objReader) readSymID() SymID {
	name, vers := r.readString(), r.readInt()

	// In a symbol name in an object file, "". denotes the
	// prefix for the package in which the object file has been found.
	// Expand it.
	name = strings.Replace(name, `"".`, r.pkgprefix, -1)

	// An individual object file only records version 0 (extern) or 1 (static).
	// To make static symbols unique across all files being read, we
	// replace version 1 with the version corresponding to the current
	// file number. The number is incremented on each call to parseObject.
	if vers != 0 {
		vers = r.p.MaxVersion
	}

	return SymID{name, vers}
}

// readData reads a data reference from the input file.
func (r *objReader) readData() Data {
	n := r.readInt()
	d := Data{Offset: r.offset, Size: int64(n)}
	r.skip(int64(n))
	return d
}

// skip skips n bytes in the input.
func (r *objReader) skip(n int64) {
	if n < 0 {
		r.error(fmt.Errorf("debug/goobj: internal error: misuse of skip"))
	}
	if n < int64(len(r.tmp)) {
		// Since the data is so small, a just reading from the buffered
		// reader is better than flushing the buffer and seeking.
		r.readFull(r.tmp[:n])
	} else if n <= int64(r.b.Buffered()) {
		// Even though the data is not small, it has already been read.
		// Advance the buffer instead of seeking.
		for n > int64(len(r.tmp)) {
			r.readFull(r.tmp[:])
			n -= int64(len(r.tmp))
		}
		r.readFull(r.tmp[:n])
	} else {
		// Seek, giving up buffered data.
		_, err := r.f.Seek(r.offset+n, 0)
		if err != nil {
			r.error(err)
		}
		r.offset += n
		r.b.Reset(r.f)
	}
}

// Parse parses an object file or archive from r,
// assuming that its import path is pkgpath.
func Parse(r io.ReadSeeker, pkgpath string) (*Package, error) {
	if pkgpath == "" {
		pkgpath = `""`
	}
	p := new(Package)
	p.ImportPath = pkgpath

	var rd objReader
	rd.init(r, p)
	err := rd.readFull(rd.tmp[:8])
	if err != nil {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
		return nil, err
	}

	switch {
	default:
		return nil, errNotObject

	case bytes.Equal(rd.tmp[:8], archiveHeader):
		if err := rd.parseArchive(); err != nil {
			return nil, err
		}
	case bytes.Equal(rd.tmp[:8], goobjHeader):
		if err := rd.parseObject(goobjHeader); err != nil {
			return nil, err
		}
	}

	return p, nil
}

// trimSpace removes trailing spaces from b and returns the corresponding string.
// This effectively parses the form used in archive headers.
func trimSpace(b []byte) string {
	return string(bytes.TrimRight(b, " "))
}

// parseArchive parses a Unix archive of Go object files.
// TODO(rsc): Need to skip non-Go object files.
// TODO(rsc): Maybe record table of contents in r.p so that
// linker can avoid having code to parse archives too.
func (r *objReader) parseArchive() error {
	for r.offset < r.limit {
		if err := r.readFull(r.tmp[:60]); err != nil {
			return err
		}
		data := r.tmp[:60]

		// Each file is preceded by this text header (slice indices in first column):
		//	 0:16	name
		//	16:28 date
		//	28:34 uid
		//	34:40 gid
		//	40:48 mode
		//	48:58 size
		//	58:60 magic - `\n
		// We only care about name, size, and magic.
		// The fields are space-padded on the right.
		// The size is in decimal.
		// The file data - size bytes - follows the header.
		// Headers are 2-byte aligned, so if size is odd, an extra padding
		// byte sits between the file data and the next header.
		// The file data that follows is padded to an even number of bytes:
		// if size is odd, an extra padding byte is inserted betw the next header.
		if len(data) < 60 {
			return errTruncatedArchive
		}
		if !bytes.Equal(data[58:60], archiveMagic) {
			return errCorruptArchive
		}
		name := trimSpace(data[0:16])
		size, err := strconv.ParseInt(trimSpace(data[48:58]), 10, 64)
		if err != nil {
			return errCorruptArchive
		}
		data = data[60:]
		fsize := size + size&1
		if fsize < 0 || fsize < size {
			return errCorruptArchive
		}
		switch name {
		case "__.SYMDEF", "__.GOSYMDEF", "__.PKGDEF":
			r.skip(size)
		default:
			oldLimit := r.limit
			r.limit = r.offset + size
			if err := r.parseObject(nil); err != nil {
				return fmt.Errorf("parsing archive member %q: %v", name, err)
			}
			r.skip(r.limit - r.offset)
			r.limit = oldLimit
		}
		if size&1 != 0 {
			r.skip(1)
		}
	}
	return nil
}

// parseObject parses a single Go object file.
// The prefix is the bytes already read from the file,
// typically in order to detect that this is an object file.
// The object file consists of a textual header ending in "\n!\n"
// and then the part we want to parse begins.
// The format of that part is defined in a comment at the top
// of src/liblink/objfile.c.
func (r *objReader) parseObject(prefix []byte) error {
	// TODO(rsc): Maybe use prefix and the initial input to
	// record the header line from the file, which would
	// give the architecture and other version information.

	r.p.MaxVersion++
	var c1, c2, c3 byte
	for {
		c1, c2, c3 = c2, c3, r.readByte()
		if c3 == 0 { // NUL or EOF, either is bad
			return errCorruptObject
		}
		if c1 == '\n' && c2 == '!' && c3 == '\n' {
			break
		}
	}

	r.readFull(r.tmp[:8])
	if !bytes.Equal(r.tmp[:8], []byte("\x00\x00go13ld")) {
		return r.error(errCorruptObject)
	}

	b := r.readByte()
	if b != 1 {
		return r.error(errCorruptObject)
	}

	// Direct package dependencies.
	for {
		s := r.readString()
		if s == "" {
			break
		}
		r.p.Imports = append(r.p.Imports, s)
	}

	// Symbols.
	for {
		if b := r.readByte(); b != 0xfe {
			if b != 0xff {
				return r.error(errCorruptObject)
			}
			break
		}

		typ := r.readInt()
		s := &Sym{SymID: r.readSymID()}
		r.p.Syms = append(r.p.Syms, s)
		s.Kind = SymKind(typ)
		flags := r.readInt()
		s.DupOK = flags&1 != 0
		s.Size = r.readInt()
		s.Type = r.readSymID()
		s.Data = r.readData()
		s.Reloc = make([]Reloc, r.readInt())
		for i := range s.Reloc {
			rel := &s.Reloc[i]
			rel.Offset = r.readInt()
			rel.Size = r.readInt()
			rel.Type = r.readInt()
			rel.Add = r.readInt()
			r.readInt() // Xadd - ignored
			rel.Sym = r.readSymID()
			r.readSymID() // Xsym - ignored
		}

		if s.Kind == STEXT {
			f := new(Func)
			s.Func = f
			f.Args = r.readInt()
			f.Frame = r.readInt()
			flags := r.readInt()
			f.Leaf = flags&1 != 0
			f.NoSplit = r.readInt() != 0
			f.Var = make([]Var, r.readInt())
			for i := range f.Var {
				v := &f.Var[i]
				v.Name = r.readSymID().Name
				v.Offset = r.readInt()
				v.Kind = r.readInt()
				v.Type = r.readSymID()
			}

			f.PCSP = r.readData()
			f.PCFile = r.readData()
			f.PCLine = r.readData()
			f.PCData = make([]Data, r.readInt())
			for i := range f.PCData {
				f.PCData[i] = r.readData()
			}
			f.FuncData = make([]FuncData, r.readInt())
			for i := range f.FuncData {
				f.FuncData[i].Sym = r.readSymID()
			}
			for i := range f.FuncData {
				f.FuncData[i].Offset = int64(r.readInt()) // TODO
			}
			f.File = make([]string, r.readInt())
			for i := range f.File {
				f.File[i] = r.readSymID().Name
			}
		}
	}

	r.readFull(r.tmp[:7])
	if !bytes.Equal(r.tmp[:7], []byte("\xffgo13ld")) {
		return r.error(errCorruptObject)
	}

	return nil
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    root/go1.4/src/cmd/internal/goobj/read_test.go                                                      0100644 0000000 0000000 00000001343 12600426226 017630  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package goobj

import "testing"

var importPathToPrefixTests = []struct {
	in  string
	out string
}{
	{"runtime", "runtime"},
	{"sync/atomic", "sync/atomic"},
	{"golang.org/x/tools/godoc", "golang.org/x/tools/godoc"},
	{"foo.bar/baz.quux", "foo.bar/baz%2equux"},
	{"", ""},
	{"%foo%bar", "%25foo%25bar"},
	{"\x01\x00\x7F", "%01%00%7f%e2%98%ba"},
}

func TestImportPathToPrefix(t *testing.T) {
	for _, tt := range importPathToPrefixTests {
		if out := importPathToPrefix(tt.in); out != tt.out {
			t.Errorf("importPathToPrefix(%q) = %q, want %q", tt.in, out, tt.out)
		}
	}
}
                                                                                                                                                                                                                                                                                             root/go1.4/src/cmd/internal/objfile/                                                                0040755 0000000 0000000 00000000000 12600426232 015640  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/internal/objfile/disasm.go                                                       0100644 0000000 0000000 00000014310 12600426226 017446  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package objfile

import (
	"bufio"
	"debug/gosym"
	"encoding/binary"
	"fmt"
	"io"
	"regexp"
	"sort"
	"strings"
	"text/tabwriter"

	"cmd/internal/rsc.io/arm/armasm"
	"cmd/internal/rsc.io/x86/x86asm"
)

// Disasm is a disassembler for a given File.
type Disasm struct {
	syms      []Sym            //symbols in file, sorted by address
	pcln      *gosym.Table     // pcln table
	text      []byte           // bytes of text segment (actual instructions)
	textStart uint64           // start PC of text
	textEnd   uint64           // end PC of text
	goarch    string           // GOARCH string
	disasm    disasmFunc       // disassembler function for goarch
	byteOrder binary.ByteOrder // byte order for goarch
}

// Disasm returns a disassembler for the file f.
func (f *File) Disasm() (*Disasm, error) {
	syms, err := f.Symbols()
	if err != nil {
		return nil, err
	}

	pcln, err := f.PCLineTable()
	if err != nil {
		return nil, err
	}

	textStart, textBytes, err := f.Text()
	if err != nil {
		return nil, err
	}

	goarch := f.GOARCH()
	disasm := disasms[goarch]
	byteOrder := byteOrders[goarch]
	if disasm == nil || byteOrder == nil {
		return nil, fmt.Errorf("unsupported architecture")
	}

	// Filter out section symbols, overwriting syms in place.
	keep := syms[:0]
	for _, sym := range syms {
		switch sym.Name {
		case "runtime.text", "text", "_text", "runtime.etext", "etext", "_etext":
			// drop
		default:
			keep = append(keep, sym)
		}
	}
	syms = keep
	d := &Disasm{
		syms:      syms,
		pcln:      pcln,
		text:      textBytes,
		textStart: textStart,
		textEnd:   textStart + uint64(len(textBytes)),
		goarch:    goarch,
		disasm:    disasm,
		byteOrder: byteOrder,
	}

	return d, nil
}

// lookup finds the symbol name containing addr.
func (d *Disasm) lookup(addr uint64) (name string, base uint64) {
	i := sort.Search(len(d.syms), func(i int) bool { return addr < d.syms[i].Addr })
	if i > 0 {
		s := d.syms[i-1]
		if s.Addr != 0 && s.Addr <= addr && addr < s.Addr+uint64(s.Size) {
			return s.Name, s.Addr
		}
	}
	return "", 0
}

// base returns the final element in the path.
// It works on both Windows and Unix paths,
// regardless of host operating system.
func base(path string) string {
	path = path[strings.LastIndex(path, "/")+1:]
	path = path[strings.LastIndex(path, `\`)+1:]
	return path
}

// Print prints a disassembly of the file to w.
// If filter is non-nil, the disassembly only includes functions with names matching filter.
// The disassembly only includes functions that overlap the range [start, end).
func (d *Disasm) Print(w io.Writer, filter *regexp.Regexp, start, end uint64) {
	if start < d.textStart {
		start = d.textStart
	}
	if end > d.textEnd {
		end = d.textEnd
	}
	printed := false
	bw := bufio.NewWriter(w)
	for _, sym := range d.syms {
		symStart := sym.Addr
		symEnd := sym.Addr + uint64(sym.Size)
		if sym.Code != 'T' && sym.Code != 't' ||
			symStart < d.textStart ||
			symEnd <= start || end <= symStart ||
			filter != nil && !filter.MatchString(sym.Name) {
			continue
		}
		if printed {
			fmt.Fprintf(bw, "\n")
		}
		printed = true

		file, _, _ := d.pcln.PCToLine(sym.Addr)
		fmt.Fprintf(bw, "TEXT %s(SB) %s\n", sym.Name, file)

		tw := tabwriter.NewWriter(bw, 1, 8, 1, '\t', 0)
		if symEnd > end {
			symEnd = end
		}
		code := d.text[:end-d.textStart]
		d.Decode(symStart, symEnd, func(pc, size uint64, file string, line int, text string) {
			i := pc - d.textStart
			fmt.Fprintf(tw, "\t%s:%d\t%#x\t", base(file), line, pc)
			if size%4 != 0 || d.goarch == "386" || d.goarch == "amd64" {
				// Print instruction as bytes.
				fmt.Fprintf(tw, "%x", code[i:i+size])
			} else {
				// Print instruction as 32-bit words.
				for j := uint64(0); j < size; j += 4 {
					if j > 0 {
						fmt.Fprintf(tw, " ")
					}
					fmt.Fprintf(tw, "%08x", d.byteOrder.Uint32(code[i+j:]))
				}
			}
			fmt.Fprintf(tw, "\t%s\n", text)
		})
		tw.Flush()
	}
	bw.Flush()
}

// Decode disassembles the text segment range [start, end), calling f for each instruction.
func (d *Disasm) Decode(start, end uint64, f func(pc, size uint64, file string, line int, text string)) {
	if start < d.textStart {
		start = d.textStart
	}
	if end > d.textEnd {
		end = d.textEnd
	}
	code := d.text[:end-d.textStart]
	lookup := d.lookup
	for pc := start; pc < end; {
		i := pc - d.textStart
		text, size := d.disasm(code[i:], pc, lookup)
		file, line, _ := d.pcln.PCToLine(pc)
		f(pc, uint64(size), file, line, text)
		pc += uint64(size)
	}
}

type lookupFunc func(addr uint64) (sym string, base uint64)
type disasmFunc func(code []byte, pc uint64, lookup lookupFunc) (text string, size int)

func disasm_386(code []byte, pc uint64, lookup lookupFunc) (string, int) {
	return disasm_x86(code, pc, lookup, 32)
}

func disasm_amd64(code []byte, pc uint64, lookup lookupFunc) (string, int) {
	return disasm_x86(code, pc, lookup, 64)
}

func disasm_x86(code []byte, pc uint64, lookup lookupFunc, arch int) (string, int) {
	inst, err := x86asm.Decode(code, 64)
	var text string
	size := inst.Len
	if err != nil || size == 0 || inst.Op == 0 {
		size = 1
		text = "?"
	} else {
		text = x86asm.Plan9Syntax(inst, pc, lookup)
	}
	return text, size
}

type textReader struct {
	code []byte
	pc   uint64
}

func (r textReader) ReadAt(data []byte, off int64) (n int, err error) {
	if off < 0 || uint64(off) < r.pc {
		return 0, io.EOF
	}
	d := uint64(off) - r.pc
	if d >= uint64(len(r.code)) {
		return 0, io.EOF
	}
	n = copy(data, r.code[d:])
	if n < len(data) {
		err = io.ErrUnexpectedEOF
	}
	return
}

func disasm_arm(code []byte, pc uint64, lookup lookupFunc) (string, int) {
	inst, err := armasm.Decode(code, armasm.ModeARM)
	var text string
	size := inst.Len
	if err != nil || size == 0 || inst.Op == 0 {
		size = 4
		text = "?"
	} else {
		text = armasm.Plan9Syntax(inst, pc, lookup, textReader{code, pc})
	}
	return text, size
}

var disasms = map[string]disasmFunc{
	"386":   disasm_386,
	"amd64": disasm_amd64,
	"arm":   disasm_arm,
}

var byteOrders = map[string]binary.ByteOrder{
	"386":       binary.LittleEndian,
	"amd64":     binary.LittleEndian,
	"arm":       binary.LittleEndian,
	"power64":   binary.BigEndian,
	"power64le": binary.LittleEndian,
}
                                                                                                                                                                                                                                                                                                                        root/go1.4/src/cmd/internal/objfile/elf.go                                                          0100644 0000000 0000000 00000004237 12600426226 016743  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Parsing of ELF executables (Linux, FreeBSD, and so on).

package objfile

import (
	"debug/elf"
	"fmt"
	"os"
)

type elfFile struct {
	elf *elf.File
}

func openElf(r *os.File) (rawFile, error) {
	f, err := elf.NewFile(r)
	if err != nil {
		return nil, err
	}
	return &elfFile{f}, nil
}

func (f *elfFile) symbols() ([]Sym, error) {
	elfSyms, err := f.elf.Symbols()
	if err != nil {
		return nil, err
	}

	var syms []Sym
	for _, s := range elfSyms {
		sym := Sym{Addr: s.Value, Name: s.Name, Size: int64(s.Size), Code: '?'}
		switch s.Section {
		case elf.SHN_UNDEF:
			sym.Code = 'U'
		case elf.SHN_COMMON:
			sym.Code = 'B'
		default:
			i := int(s.Section)
			if i < 0 || i >= len(f.elf.Sections) {
				break
			}
			sect := f.elf.Sections[i]
			switch sect.Flags & (elf.SHF_WRITE | elf.SHF_ALLOC | elf.SHF_EXECINSTR) {
			case elf.SHF_ALLOC | elf.SHF_EXECINSTR:
				sym.Code = 'T'
			case elf.SHF_ALLOC:
				sym.Code = 'R'
			case elf.SHF_ALLOC | elf.SHF_WRITE:
				sym.Code = 'D'
			}
		}
		if elf.ST_BIND(s.Info) == elf.STB_LOCAL {
			sym.Code += 'a' - 'A'
		}
		syms = append(syms, sym)
	}

	return syms, nil
}

func (f *elfFile) pcln() (textStart uint64, symtab, pclntab []byte, err error) {
	if sect := f.elf.Section(".text"); sect != nil {
		textStart = sect.Addr
	}
	if sect := f.elf.Section(".gosymtab"); sect != nil {
		if symtab, err = sect.Data(); err != nil {
			return 0, nil, nil, err
		}
	}
	if sect := f.elf.Section(".gopclntab"); sect != nil {
		if pclntab, err = sect.Data(); err != nil {
			return 0, nil, nil, err
		}
	}
	return textStart, symtab, pclntab, nil
}

func (f *elfFile) text() (textStart uint64, text []byte, err error) {
	sect := f.elf.Section(".text")
	if sect == nil {
		return 0, nil, fmt.Errorf("text section not found")
	}
	textStart = sect.Addr
	text, err = sect.Data()
	return
}

func (f *elfFile) goarch() string {
	switch f.elf.Machine {
	case elf.EM_386:
		return "386"
	case elf.EM_X86_64:
		return "amd64"
	case elf.EM_ARM:
		return "arm"
	case elf.EM_PPC64:
		return "power64"
	}
	return ""
}
                                                                                                                                                                                                                                                                                                                                                                 root/go1.4/src/cmd/internal/objfile/goobj.go                                                        0100644 0000000 0000000 00000005320 12600426226 017267  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Parsing of Go intermediate object files and archives.

package objfile

import (
	"cmd/internal/goobj"
	"fmt"
	"os"
)

type goobjFile struct {
	goobj *goobj.Package
}

func openGoobj(r *os.File) (rawFile, error) {
	f, err := goobj.Parse(r, `""`)
	if err != nil {
		return nil, err
	}
	return &goobjFile{f}, nil
}

func goobjName(id goobj.SymID) string {
	if id.Version == 0 {
		return id.Name
	}
	return fmt.Sprintf("%s<%d>", id.Name, id.Version)
}

func (f *goobjFile) symbols() ([]Sym, error) {
	seen := make(map[goobj.SymID]bool)

	var syms []Sym
	for _, s := range f.goobj.Syms {
		seen[s.SymID] = true
		sym := Sym{Addr: uint64(s.Data.Offset), Name: goobjName(s.SymID), Size: int64(s.Size), Type: s.Type.Name, Code: '?'}
		switch s.Kind {
		case goobj.STEXT, goobj.SELFRXSECT:
			sym.Code = 'T'
		case goobj.STYPE, goobj.SSTRING, goobj.SGOSTRING, goobj.SGOFUNC, goobj.SRODATA, goobj.SFUNCTAB, goobj.STYPELINK, goobj.SSYMTAB, goobj.SPCLNTAB, goobj.SELFROSECT:
			sym.Code = 'R'
		case goobj.SMACHOPLT, goobj.SELFSECT, goobj.SMACHO, goobj.SMACHOGOT, goobj.SNOPTRDATA, goobj.SINITARR, goobj.SDATA, goobj.SWINDOWS:
			sym.Code = 'D'
		case goobj.SBSS, goobj.SNOPTRBSS, goobj.STLSBSS:
			sym.Code = 'B'
		case goobj.SXREF, goobj.SMACHOSYMSTR, goobj.SMACHOSYMTAB, goobj.SMACHOINDIRECTPLT, goobj.SMACHOINDIRECTGOT, goobj.SFILE, goobj.SFILEPATH, goobj.SCONST, goobj.SDYNIMPORT, goobj.SHOSTOBJ:
			sym.Code = 'X' // should not see
		}
		if s.Version != 0 {
			sym.Code += 'a' - 'A'
		}
		syms = append(syms, sym)
	}

	for _, s := range f.goobj.Syms {
		for _, r := range s.Reloc {
			if !seen[r.Sym] {
				seen[r.Sym] = true
				sym := Sym{Name: goobjName(r.Sym), Code: 'U'}
				if s.Version != 0 {
					// should not happen but handle anyway
					sym.Code = 'u'
				}
				syms = append(syms, sym)
			}
		}
	}

	return syms, nil
}

// pcln does not make sense for Go object files, because each
// symbol has its own individual pcln table, so there is no global
// space of addresses to map.
func (f *goobjFile) pcln() (textStart uint64, symtab, pclntab []byte, err error) {
	return 0, nil, nil, fmt.Errorf("pcln not available in go object file")
}

// text does not make sense for Go object files, because
// each function has a separate section.
func (f *goobjFile) text() (textStart uint64, text []byte, err error) {
	return 0, nil, fmt.Errorf("text not available in go object file")
}

// goarch makes sense but is not exposed in debug/goobj's API,
// and we don't need it yet for any users of internal/objfile.
func (f *goobjFile) goarch() string {
	return "GOARCH unimplemented for debug/goobj files"
}
                                                                                                                                                                                                                                                                                                                root/go1.4/src/cmd/internal/objfile/macho.go                                                        0100644 0000000 0000000 00000005166 12600426226 017266  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Parsing of Mach-O executables (OS X).

package objfile

import (
	"debug/macho"
	"fmt"
	"os"
	"sort"
)

type machoFile struct {
	macho *macho.File
}

func openMacho(r *os.File) (rawFile, error) {
	f, err := macho.NewFile(r)
	if err != nil {
		return nil, err
	}
	return &machoFile{f}, nil
}

func (f *machoFile) symbols() ([]Sym, error) {
	if f.macho.Symtab == nil {
		return nil, fmt.Errorf("missing symbol table")
	}

	// Build sorted list of addresses of all symbols.
	// We infer the size of a symbol by looking at where the next symbol begins.
	var addrs []uint64
	for _, s := range f.macho.Symtab.Syms {
		addrs = append(addrs, s.Value)
	}
	sort.Sort(uint64s(addrs))

	var syms []Sym
	for _, s := range f.macho.Symtab.Syms {
		sym := Sym{Name: s.Name, Addr: s.Value, Code: '?'}
		i := sort.Search(len(addrs), func(x int) bool { return addrs[x] > s.Value })
		if i < len(addrs) {
			sym.Size = int64(addrs[i] - s.Value)
		}
		if s.Sect == 0 {
			sym.Code = 'U'
		} else if int(s.Sect) <= len(f.macho.Sections) {
			sect := f.macho.Sections[s.Sect-1]
			switch sect.Seg {
			case "__TEXT":
				sym.Code = 'R'
			case "__DATA":
				sym.Code = 'D'
			}
			switch sect.Seg + " " + sect.Name {
			case "__TEXT __text":
				sym.Code = 'T'
			case "__DATA __bss", "__DATA __noptrbss":
				sym.Code = 'B'
			}
		}
		syms = append(syms, sym)
	}

	return syms, nil
}

func (f *machoFile) pcln() (textStart uint64, symtab, pclntab []byte, err error) {
	if sect := f.macho.Section("__text"); sect != nil {
		textStart = sect.Addr
	}
	if sect := f.macho.Section("__gosymtab"); sect != nil {
		if symtab, err = sect.Data(); err != nil {
			return 0, nil, nil, err
		}
	}
	if sect := f.macho.Section("__gopclntab"); sect != nil {
		if pclntab, err = sect.Data(); err != nil {
			return 0, nil, nil, err
		}
	}
	return textStart, symtab, pclntab, nil
}

func (f *machoFile) text() (textStart uint64, text []byte, err error) {
	sect := f.macho.Section("__text")
	if sect == nil {
		return 0, nil, fmt.Errorf("text section not found")
	}
	textStart = sect.Addr
	text, err = sect.Data()
	return
}

func (f *machoFile) goarch() string {
	switch f.macho.Cpu {
	case macho.Cpu386:
		return "386"
	case macho.CpuAmd64:
		return "amd64"
	case macho.CpuArm:
		return "arm"
	case macho.CpuPpc64:
		return "power64"
	}
	return ""
}

type uint64s []uint64

func (x uint64s) Len() int           { return len(x) }
func (x uint64s) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
func (x uint64s) Less(i, j int) bool { return x[i] < x[j] }
                                                                                                                                                                                                                                                                                                                                                                                                          root/go1.4/src/cmd/internal/objfile/objfile.go                                                      0100644 0000000 0000000 00000004057 12600426226 017607  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package objfile implements portable access to OS-specific executable files.
package objfile

import (
	"debug/gosym"
	"fmt"
	"os"
	"sort"
)

type rawFile interface {
	symbols() (syms []Sym, err error)
	pcln() (textStart uint64, symtab, pclntab []byte, err error)
	text() (textStart uint64, text []byte, err error)
	goarch() string
}

// A File is an opened executable file.
type File struct {
	r   *os.File
	raw rawFile
}

// A Sym is a symbol defined in an executable file.
type Sym struct {
	Name string // symbol name
	Addr uint64 // virtual address of symbol
	Size int64  // size in bytes
	Code rune   // nm code (T for text, D for data, and so on)
	Type string // XXX?
}

var openers = []func(*os.File) (rawFile, error){
	openElf,
	openGoobj,
	openMacho,
	openPE,
	openPlan9,
}

// Open opens the named file.
// The caller must call f.Close when the file is no longer needed.
func Open(name string) (*File, error) {
	r, err := os.Open(name)
	if err != nil {
		return nil, err
	}
	for _, try := range openers {
		if raw, err := try(r); err == nil {
			return &File{r, raw}, nil
		}
	}
	r.Close()
	return nil, fmt.Errorf("open %s: unrecognized object file", name)
}

func (f *File) Close() error {
	return f.r.Close()
}

func (f *File) Symbols() ([]Sym, error) {
	syms, err := f.raw.symbols()
	if err != nil {
		return nil, err
	}
	sort.Sort(byAddr(syms))
	return syms, nil
}

type byAddr []Sym

func (x byAddr) Less(i, j int) bool { return x[i].Addr < x[j].Addr }
func (x byAddr) Len() int           { return len(x) }
func (x byAddr) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }

func (f *File) PCLineTable() (*gosym.Table, error) {
	textStart, symtab, pclntab, err := f.raw.pcln()
	if err != nil {
		return nil, err
	}
	return gosym.NewTable(symtab, gosym.NewLineTable(pclntab, textStart))
}

func (f *File) Text() (uint64, []byte, error) {
	return f.raw.text()
}

func (f *File) GOARCH() string {
	return f.raw.goarch()
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 root/go1.4/src/cmd/internal/objfile/pe.go                                                           0100644 0000000 0000000 00000012246 12600426226 016600  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Parsing of PE executables (Microsoft Windows).

package objfile

import (
	"debug/pe"
	"fmt"
	"os"
	"sort"
)

type peFile struct {
	pe *pe.File
}

func openPE(r *os.File) (rawFile, error) {
	f, err := pe.NewFile(r)
	if err != nil {
		return nil, err
	}
	switch f.OptionalHeader.(type) {
	case *pe.OptionalHeader32, *pe.OptionalHeader64:
		// ok
	default:
		return nil, fmt.Errorf("unrecognized PE format")
	}
	return &peFile{f}, nil
}

func (f *peFile) symbols() ([]Sym, error) {
	// Build sorted list of addresses of all symbols.
	// We infer the size of a symbol by looking at where the next symbol begins.
	var addrs []uint64

	var imageBase uint64
	switch oh := f.pe.OptionalHeader.(type) {
	case *pe.OptionalHeader32:
		imageBase = uint64(oh.ImageBase)
	case *pe.OptionalHeader64:
		imageBase = oh.ImageBase
	}

	var syms []Sym
	for _, s := range f.pe.Symbols {
		const (
			N_UNDEF = 0  // An undefined (extern) symbol
			N_ABS   = -1 // An absolute symbol (e_value is a constant, not an address)
			N_DEBUG = -2 // A debugging symbol
		)
		sym := Sym{Name: s.Name, Addr: uint64(s.Value), Code: '?'}
		switch s.SectionNumber {
		case N_UNDEF:
			sym.Code = 'U'
		case N_ABS:
			sym.Code = 'C'
		case N_DEBUG:
			sym.Code = '?'
		default:
			if s.SectionNumber < 0 || len(f.pe.Sections) < int(s.SectionNumber) {
				return nil, fmt.Errorf("invalid section number in symbol table")
			}
			sect := f.pe.Sections[s.SectionNumber-1]
			const (
				text  = 0x20
				data  = 0x40
				bss   = 0x80
				permX = 0x20000000
				permR = 0x40000000
				permW = 0x80000000
			)
			ch := sect.Characteristics
			switch {
			case ch&text != 0:
				sym.Code = 'T'
			case ch&data != 0:
				if ch&permW == 0 {
					sym.Code = 'R'
				} else {
					sym.Code = 'D'
				}
			case ch&bss != 0:
				sym.Code = 'B'
			}
			sym.Addr += imageBase + uint64(sect.VirtualAddress)
		}
		syms = append(syms, sym)
		addrs = append(addrs, sym.Addr)
	}

	sort.Sort(uint64s(addrs))
	for i := range syms {
		j := sort.Search(len(addrs), func(x int) bool { return addrs[x] > syms[i].Addr })
		if j < len(addrs) {
			syms[i].Size = int64(addrs[j] - syms[i].Addr)
		}
	}

	return syms, nil
}

func (f *peFile) pcln() (textStart uint64, symtab, pclntab []byte, err error) {
	var imageBase uint64
	switch oh := f.pe.OptionalHeader.(type) {
	case *pe.OptionalHeader32:
		imageBase = uint64(oh.ImageBase)
	case *pe.OptionalHeader64:
		imageBase = oh.ImageBase
	default:
		return 0, nil, nil, fmt.Errorf("pe file format not recognized")
	}
	if sect := f.pe.Section(".text"); sect != nil {
		textStart = imageBase + uint64(sect.VirtualAddress)
	}
	if pclntab, err = loadPETable(f.pe, "runtime.pclntab", "runtime.epclntab"); err != nil {
		// We didn't find the symbols, so look for the names used in 1.3 and earlier.
		// TODO: Remove code looking for the old symbols when we no longer care about 1.3.
		var err2 error
		if pclntab, err2 = loadPETable(f.pe, "pclntab", "epclntab"); err2 != nil {
			return 0, nil, nil, err
		}
	}
	if symtab, err = loadPETable(f.pe, "runtime.symtab", "runtime.esymtab"); err != nil {
		// Same as above.
		var err2 error
		if symtab, err2 = loadPETable(f.pe, "symtab", "esymtab"); err2 != nil {
			return 0, nil, nil, err
		}
	}
	return textStart, symtab, pclntab, nil
}

func (f *peFile) text() (textStart uint64, text []byte, err error) {
	var imageBase uint64
	switch oh := f.pe.OptionalHeader.(type) {
	case *pe.OptionalHeader32:
		imageBase = uint64(oh.ImageBase)
	case *pe.OptionalHeader64:
		imageBase = oh.ImageBase
	default:
		return 0, nil, fmt.Errorf("pe file format not recognized")
	}
	sect := f.pe.Section(".text")
	if sect == nil {
		return 0, nil, fmt.Errorf("text section not found")
	}
	textStart = imageBase + uint64(sect.VirtualAddress)
	text, err = sect.Data()
	return
}

func findPESymbol(f *pe.File, name string) (*pe.Symbol, error) {
	for _, s := range f.Symbols {
		if s.Name != name {
			continue
		}
		if s.SectionNumber <= 0 {
			return nil, fmt.Errorf("symbol %s: invalid section number %d", name, s.SectionNumber)
		}
		if len(f.Sections) < int(s.SectionNumber) {
			return nil, fmt.Errorf("symbol %s: section number %d is larger than max %d", name, s.SectionNumber, len(f.Sections))
		}
		return s, nil
	}
	return nil, fmt.Errorf("no %s symbol found", name)
}

func loadPETable(f *pe.File, sname, ename string) ([]byte, error) {
	ssym, err := findPESymbol(f, sname)
	if err != nil {
		return nil, err
	}
	esym, err := findPESymbol(f, ename)
	if err != nil {
		return nil, err
	}
	if ssym.SectionNumber != esym.SectionNumber {
		return nil, fmt.Errorf("%s and %s symbols must be in the same section", sname, ename)
	}
	sect := f.Sections[ssym.SectionNumber-1]
	data, err := sect.Data()
	if err != nil {
		return nil, err
	}
	return data[ssym.Value:esym.Value], nil
}

func (f *peFile) goarch() string {
	// Not sure how to get the info we want from PE header.
	// Look in symbol table for telltale rt0 symbol.
	if _, err := findPESymbol(f.pe, "_rt0_386_windows"); err == nil {
		return "386"
	}
	if _, err := findPESymbol(f.pe, "_rt0_amd64_windows"); err == nil {
		return "amd64"
	}
	return ""
}
                                                                                                                                                                                                                                                                                                                                                          root/go1.4/src/cmd/internal/objfile/plan9obj.go                                                     0100644 0000000 0000000 00000006453 12600426226 017715  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Parsing of Plan 9 a.out executables.

package objfile

import (
	"debug/plan9obj"
	"fmt"
	"os"
	"sort"
)

var validSymType = map[rune]bool{
	'T': true,
	't': true,
	'D': true,
	'd': true,
	'B': true,
	'b': true,
}

type plan9File struct {
	plan9 *plan9obj.File
}

func openPlan9(r *os.File) (rawFile, error) {
	f, err := plan9obj.NewFile(r)
	if err != nil {
		return nil, err
	}
	return &plan9File{f}, nil
}

func (f *plan9File) symbols() ([]Sym, error) {
	plan9Syms, err := f.plan9.Symbols()
	if err != nil {
		return nil, err
	}

	// Build sorted list of addresses of all symbols.
	// We infer the size of a symbol by looking at where the next symbol begins.
	var addrs []uint64
	for _, s := range plan9Syms {
		if !validSymType[s.Type] {
			continue
		}
		addrs = append(addrs, s.Value)
	}
	sort.Sort(uint64s(addrs))

	var syms []Sym

	for _, s := range plan9Syms {
		if !validSymType[s.Type] {
			continue
		}
		sym := Sym{Addr: s.Value, Name: s.Name, Code: rune(s.Type)}
		i := sort.Search(len(addrs), func(x int) bool { return addrs[x] > s.Value })
		if i < len(addrs) {
			sym.Size = int64(addrs[i] - s.Value)
		}
		syms = append(syms, sym)
	}

	return syms, nil
}

func (f *plan9File) pcln() (textStart uint64, symtab, pclntab []byte, err error) {
	textStart = f.plan9.LoadAddress + f.plan9.HdrSize
	if pclntab, err = loadPlan9Table(f.plan9, "runtime.pclntab", "runtime.epclntab"); err != nil {
		// We didn't find the symbols, so look for the names used in 1.3 and earlier.
		// TODO: Remove code looking for the old symbols when we no longer care about 1.3.
		var err2 error
		if pclntab, err2 = loadPlan9Table(f.plan9, "pclntab", "epclntab"); err2 != nil {
			return 0, nil, nil, err
		}
	}
	if symtab, err = loadPlan9Table(f.plan9, "runtime.symtab", "runtime.esymtab"); err != nil {
		// Same as above.
		var err2 error
		if symtab, err2 = loadPlan9Table(f.plan9, "symtab", "esymtab"); err2 != nil {
			return 0, nil, nil, err
		}
	}
	return textStart, symtab, pclntab, nil
}

func (f *plan9File) text() (textStart uint64, text []byte, err error) {
	sect := f.plan9.Section("text")
	if sect == nil {
		return 0, nil, fmt.Errorf("text section not found")
	}
	textStart = f.plan9.LoadAddress + f.plan9.HdrSize
	text, err = sect.Data()
	return
}

func findPlan9Symbol(f *plan9obj.File, name string) (*plan9obj.Sym, error) {
	syms, err := f.Symbols()
	if err != nil {
		return nil, err
	}
	for _, s := range syms {
		if s.Name != name {
			continue
		}
		return &s, nil
	}
	return nil, fmt.Errorf("no %s symbol found", name)
}

func loadPlan9Table(f *plan9obj.File, sname, ename string) ([]byte, error) {
	ssym, err := findPlan9Symbol(f, sname)
	if err != nil {
		return nil, err
	}
	esym, err := findPlan9Symbol(f, ename)
	if err != nil {
		return nil, err
	}
	sect := f.Section("text")
	if sect == nil {
		return nil, err
	}
	data, err := sect.Data()
	if err != nil {
		return nil, err
	}
	textStart := f.LoadAddress + f.HdrSize
	return data[ssym.Value-textStart : esym.Value-textStart], nil
}

func (f *plan9File) goarch() string {
	switch f.plan9.Magic {
	case plan9obj.Magic386:
		return "386"
	case plan9obj.MagicAMD64:
		return "amd64"
	case plan9obj.MagicARM:
		return "arm"
	}
	return ""
}
                                                                                                                                                                                                                     root/go1.4/src/cmd/internal/rsc.io/                                                                 0040755 0000000 0000000 00000000000 12600426233 015424  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/internal/rsc.io/arm/                                                             0040755 0000000 0000000 00000000000 12600426232 016202  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/internal/rsc.io/arm/armasm/                                                      0040755 0000000 0000000 00000000000 12600426233 017463  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/internal/rsc.io/arm/armasm/Makefile                                              0100644 0000000 0000000 00000000225 12600426226 021121  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        tables.go: ../armmap/map.go ../arm.csv 
	go run ../armmap/map.go -fmt=decoder ../arm.csv >_tables.go && gofmt _tables.go >tables.go && rm _tables.go
                                                                                                                                                                                                                                                                                                                                                                           root/go1.4/src/cmd/internal/rsc.io/arm/armasm/decode.go                                             0100644 0000000 0000000 00000031221 12600426226 021233  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package armasm

import (
	"encoding/binary"
	"fmt"
)

// An instFormat describes the format of an instruction encoding.
// An instruction with 32-bit value x matches the format if x&mask == value
// and the condition matches.
// The condition matches if x>>28 == 0xF && value>>28==0xF
// or if x>>28 != 0xF and value>>28 == 0.
// If x matches the format, then the rest of the fields describe how to interpret x.
// The opBits describe bits that should be extracted from x and added to the opcode.
// For example opBits = 0x1234 means that the value
//	(2 bits at offset 1) followed by (4 bits at offset 3)
// should be added to op.
// Finally the args describe how to decode the instruction arguments.
// args is stored as a fixed-size array; if there are fewer than len(args) arguments,
// args[i] == 0 marks the end of the argument list.
type instFormat struct {
	mask     uint32
	value    uint32
	priority int8
	op       Op
	opBits   uint64
	args     instArgs
}

type instArgs [4]instArg

var (
	errMode    = fmt.Errorf("unsupported execution mode")
	errShort   = fmt.Errorf("truncated instruction")
	errUnknown = fmt.Errorf("unknown instruction")
)

var decoderCover []bool

// Decode decodes the leading bytes in src as a single instruction.
func Decode(src []byte, mode Mode) (inst Inst, err error) {
	if mode != ModeARM {
		return Inst{}, errMode
	}
	if len(src) < 4 {
		return Inst{}, errShort
	}

	if decoderCover == nil {
		decoderCover = make([]bool, len(instFormats))
	}

	x := binary.LittleEndian.Uint32(src)

	// The instFormat table contains both conditional and unconditional instructions.
	// Considering only the top 4 bits, the conditional instructions use mask=0, value=0,
	// while the unconditional instructions use mask=f, value=f.
	// Prepare a version of x with the condition cleared to 0 in conditional instructions
	// and then assume mask=f during matching.
	const condMask = 0xf0000000
	xNoCond := x
	if x&condMask != condMask {
		xNoCond &^= condMask
	}
	var priority int8
Search:
	for i := range instFormats {
		f := &instFormats[i]
		if xNoCond&(f.mask|condMask) != f.value || f.priority <= priority {
			continue
		}
		delta := uint32(0)
		deltaShift := uint(0)
		for opBits := f.opBits; opBits != 0; opBits >>= 16 {
			n := uint(opBits & 0xFF)
			off := uint((opBits >> 8) & 0xFF)
			delta |= (x >> off) & (1<<n - 1) << deltaShift
			deltaShift += n
		}
		op := f.op + Op(delta)

		// Special case: BKPT encodes with condition but cannot have one.
		if op&^15 == BKPT_EQ && op != BKPT {
			continue Search
		}

		var args Args
		for j, aop := range f.args {
			if aop == 0 {
				break
			}
			arg := decodeArg(aop, x)
			if arg == nil { // cannot decode argument
				continue Search
			}
			args[j] = arg
		}

		decoderCover[i] = true

		inst = Inst{
			Op:   op,
			Args: args,
			Enc:  x,
			Len:  4,
		}
		priority = f.priority
		continue Search
	}
	if inst.Op != 0 {
		return inst, nil
	}
	return Inst{}, errUnknown
}

// An instArg describes the encoding of a single argument.
// In the names used for arguments, _p_ means +, _m_ means -,
// _pm_ means  (usually keyed by the U bit).
// The _W suffix indicates a general addressing mode based on the P and W bits.
// The _offset and _postindex suffixes force the given addressing mode.
// The rest should be somewhat self-explanatory, at least given
// the decodeArg function.
type instArg uint8

const (
	_ instArg = iota
	arg_APSR
	arg_FPSCR
	arg_Dn_half
	arg_R1_0
	arg_R1_12
	arg_R2_0
	arg_R2_12
	arg_R_0
	arg_R_12
	arg_R_12_nzcv
	arg_R_16
	arg_R_16_WB
	arg_R_8
	arg_R_rotate
	arg_R_shift_R
	arg_R_shift_imm
	arg_SP
	arg_Sd
	arg_Sd_Dd
	arg_Dd_Sd
	arg_Sm
	arg_Sm_Dm
	arg_Sn
	arg_Sn_Dn
	arg_const
	arg_endian
	arg_fbits
	arg_fp_0
	arg_imm24
	arg_imm5
	arg_imm5_32
	arg_imm5_nz
	arg_imm_12at8_4at0
	arg_imm_4at16_12at0
	arg_imm_vfp
	arg_label24
	arg_label24H
	arg_label_m_12
	arg_label_p_12
	arg_label_pm_12
	arg_label_pm_4_4
	arg_lsb_width
	arg_mem_R
	arg_mem_R_pm_R_W
	arg_mem_R_pm_R_postindex
	arg_mem_R_pm_R_shift_imm_W
	arg_mem_R_pm_R_shift_imm_offset
	arg_mem_R_pm_R_shift_imm_postindex
	arg_mem_R_pm_imm12_W
	arg_mem_R_pm_imm12_offset
	arg_mem_R_pm_imm12_postindex
	arg_mem_R_pm_imm8_W
	arg_mem_R_pm_imm8_postindex
	arg_mem_R_pm_imm8at0_offset
	arg_option
	arg_registers
	arg_registers1
	arg_registers2
	arg_satimm4
	arg_satimm5
	arg_satimm4m1
	arg_satimm5m1
	arg_widthm1
)

// decodeArg decodes the arg described by aop from the instruction bits x.
// It returns nil if x cannot be decoded according to aop.
func decodeArg(aop instArg, x uint32) Arg {
	switch aop {
	default:
		return nil

	case arg_APSR:
		return APSR
	case arg_FPSCR:
		return FPSCR

	case arg_R_0:
		return Reg(x & (1<<4 - 1))
	case arg_R_8:
		return Reg((x >> 8) & (1<<4 - 1))
	case arg_R_12:
		return Reg((x >> 12) & (1<<4 - 1))
	case arg_R_16:
		return Reg((x >> 16) & (1<<4 - 1))

	case arg_R_12_nzcv:
		r := Reg((x >> 12) & (1<<4 - 1))
		if r == R15 {
			return APSR_nzcv
		}
		return r

	case arg_R_16_WB:
		mode := AddrLDM
		if (x>>21)&1 != 0 {
			mode = AddrLDM_WB
		}
		return Mem{Base: Reg((x >> 16) & (1<<4 - 1)), Mode: mode}

	case arg_R_rotate:
		Rm := Reg(x & (1<<4 - 1))
		typ, count := decodeShift(x)
		// ROR #0 here means ROR #0, but decodeShift rewrites to RRX #1.
		if typ == RotateRightExt {
			return Reg(Rm)
		}
		return RegShift{Rm, typ, uint8(count)}

	case arg_R_shift_R:
		Rm := Reg(x & (1<<4 - 1))
		Rs := Reg((x >> 8) & (1<<4 - 1))
		typ := Shift((x >> 5) & (1<<2 - 1))
		return RegShiftReg{Rm, typ, Rs}

	case arg_R_shift_imm:
		Rm := Reg(x & (1<<4 - 1))
		typ, count := decodeShift(x)
		if typ == ShiftLeft && count == 0 {
			return Reg(Rm)
		}
		return RegShift{Rm, typ, uint8(count)}

	case arg_R1_0:
		return Reg((x & (1<<4 - 1)))
	case arg_R1_12:
		return Reg(((x >> 12) & (1<<4 - 1)))
	case arg_R2_0:
		return Reg((x & (1<<4 - 1)) | 1)
	case arg_R2_12:
		return Reg(((x >> 12) & (1<<4 - 1)) | 1)

	case arg_SP:
		return SP

	case arg_Sd_Dd:
		v := (x >> 12) & (1<<4 - 1)
		vx := (x >> 22) & 1
		sz := (x >> 8) & 1
		if sz != 0 {
			return D0 + Reg(vx<<4+v)
		} else {
			return S0 + Reg(v<<1+vx)
		}

	case arg_Dd_Sd:
		return decodeArg(arg_Sd_Dd, x^(1<<8))

	case arg_Sd:
		v := (x >> 12) & (1<<4 - 1)
		vx := (x >> 22) & 1
		return S0 + Reg(v<<1+vx)

	case arg_Sm_Dm:
		v := (x >> 0) & (1<<4 - 1)
		vx := (x >> 5) & 1
		sz := (x >> 8) & 1
		if sz != 0 {
			return D0 + Reg(vx<<4+v)
		} else {
			return S0 + Reg(v<<1+vx)
		}

	case arg_Sm:
		v := (x >> 0) & (1<<4 - 1)
		vx := (x >> 5) & 1
		return S0 + Reg(v<<1+vx)

	case arg_Dn_half:
		v := (x >> 16) & (1<<4 - 1)
		vx := (x >> 7) & 1
		return RegX{D0 + Reg(vx<<4+v), int((x >> 21) & 1)}

	case arg_Sn_Dn:
		v := (x >> 16) & (1<<4 - 1)
		vx := (x >> 7) & 1
		sz := (x >> 8) & 1
		if sz != 0 {
			return D0 + Reg(vx<<4+v)
		} else {
			return S0 + Reg(v<<1+vx)
		}

	case arg_Sn:
		v := (x >> 16) & (1<<4 - 1)
		vx := (x >> 7) & 1
		return S0 + Reg(v<<1+vx)

	case arg_const:
		v := x & (1<<8 - 1)
		rot := (x >> 8) & (1<<4 - 1) * 2
		if rot > 0 && v&3 == 0 {
			// could rotate less
			return ImmAlt{uint8(v), uint8(rot)}
		}
		if rot >= 24 && ((v<<(32-rot))&0xFF)>>(32-rot) == v {
			// could wrap around to rot==0.
			return ImmAlt{uint8(v), uint8(rot)}
		}
		return Imm(v>>rot | v<<(32-rot))

	case arg_endian:
		return Endian((x >> 9) & 1)

	case arg_fbits:
		return Imm((16 << ((x >> 7) & 1)) - ((x&(1<<4-1))<<1 | (x>>5)&1))

	case arg_fp_0:
		return Imm(0)

	case arg_imm24:
		return Imm(x & (1<<24 - 1))

	case arg_imm5:
		return Imm((x >> 7) & (1<<5 - 1))

	case arg_imm5_32:
		x = (x >> 7) & (1<<5 - 1)
		if x == 0 {
			x = 32
		}
		return Imm(x)

	case arg_imm5_nz:
		x = (x >> 7) & (1<<5 - 1)
		if x == 0 {
			return nil
		}
		return Imm(x)

	case arg_imm_4at16_12at0:
		return Imm((x>>16)&(1<<4-1)<<12 | x&(1<<12-1))

	case arg_imm_12at8_4at0:
		return Imm((x>>8)&(1<<12-1)<<4 | x&(1<<4-1))

	case arg_imm_vfp:
		x = (x>>16)&(1<<4-1)<<4 | x&(1<<4-1)
		return Imm(x)

	case arg_label24:
		imm := (x & (1<<24 - 1)) << 2
		return PCRel(int32(imm<<6) >> 6)

	case arg_label24H:
		h := (x >> 24) & 1
		imm := (x&(1<<24-1))<<2 | h<<1
		return PCRel(int32(imm<<6) >> 6)

	case arg_label_m_12:
		d := int32(x & (1<<12 - 1))
		return Mem{Base: PC, Mode: AddrOffset, Offset: int16(-d)}

	case arg_label_p_12:
		d := int32(x & (1<<12 - 1))
		return Mem{Base: PC, Mode: AddrOffset, Offset: int16(d)}

	case arg_label_pm_12:
		d := int32(x & (1<<12 - 1))
		u := (x >> 23) & 1
		if u == 0 {
			d = -d
		}
		return Mem{Base: PC, Mode: AddrOffset, Offset: int16(d)}

	case arg_label_pm_4_4:
		d := int32((x>>8)&(1<<4-1)<<4 | x&(1<<4-1))
		u := (x >> 23) & 1
		if u == 0 {
			d = -d
		}
		return PCRel(d)

	case arg_lsb_width:
		lsb := (x >> 7) & (1<<5 - 1)
		msb := (x >> 16) & (1<<5 - 1)
		if msb < lsb || msb >= 32 {
			return nil
		}
		return Imm(msb + 1 - lsb)

	case arg_mem_R:
		Rn := Reg((x >> 16) & (1<<4 - 1))
		return Mem{Base: Rn, Mode: AddrOffset}

	case arg_mem_R_pm_R_postindex:
		// Treat [<Rn>],+/-<Rm> like [<Rn>,+/-<Rm>{,<shift>}]{!}
		// by forcing shift bits to <<0 and P=0, W=0 (postindex=true).
		return decodeArg(arg_mem_R_pm_R_shift_imm_W, x&^((1<<7-1)<<5|1<<24|1<<21))

	case arg_mem_R_pm_R_W:
		// Treat [<Rn>,+/-<Rm>]{!} like [<Rn>,+/-<Rm>{,<shift>}]{!}
		// by forcing shift bits to <<0.
		return decodeArg(arg_mem_R_pm_R_shift_imm_W, x&^((1<<7-1)<<5))

	case arg_mem_R_pm_R_shift_imm_offset:
		// Treat [<Rn>],+/-<Rm>{,<shift>} like [<Rn>,+/-<Rm>{,<shift>}]{!}
		// by forcing P=1, W=0 (index=false, wback=false).
		return decodeArg(arg_mem_R_pm_R_shift_imm_W, x&^(1<<21)|1<<24)

	case arg_mem_R_pm_R_shift_imm_postindex:
		// Treat [<Rn>],+/-<Rm>{,<shift>} like [<Rn>,+/-<Rm>{,<shift>}]{!}
		// by forcing P=0, W=0 (postindex=true).
		return decodeArg(arg_mem_R_pm_R_shift_imm_W, x&^(1<<24|1<<21))

	case arg_mem_R_pm_R_shift_imm_W:
		Rn := Reg((x >> 16) & (1<<4 - 1))
		Rm := Reg(x & (1<<4 - 1))
		typ, count := decodeShift(x)
		u := (x >> 23) & 1
		w := (x >> 21) & 1
		p := (x >> 24) & 1
		if p == 0 && w == 1 {
			return nil
		}
		sign := int8(+1)
		if u == 0 {
			sign = -1
		}
		mode := AddrMode(uint8(p<<1) | uint8(w^1))
		return Mem{Base: Rn, Mode: mode, Sign: sign, Index: Rm, Shift: typ, Count: count}

	case arg_mem_R_pm_imm12_offset:
		// Treat [<Rn>,#+/-<imm12>] like [<Rn>{,#+/-<imm12>}]{!}
		// by forcing P=1, W=0 (index=false, wback=false).
		return decodeArg(arg_mem_R_pm_imm12_W, x&^(1<<21)|1<<24)

	case arg_mem_R_pm_imm12_postindex:
		// Treat [<Rn>],#+/-<imm12> like [<Rn>{,#+/-<imm12>}]{!}
		// by forcing P=0, W=0 (postindex=true).
		return decodeArg(arg_mem_R_pm_imm12_W, x&^(1<<24|1<<21))

	case arg_mem_R_pm_imm12_W:
		Rn := Reg((x >> 16) & (1<<4 - 1))
		u := (x >> 23) & 1
		w := (x >> 21) & 1
		p := (x >> 24) & 1
		if p == 0 && w == 1 {
			return nil
		}
		sign := int8(+1)
		if u == 0 {
			sign = -1
		}
		imm := int16(x & (1<<12 - 1))
		mode := AddrMode(uint8(p<<1) | uint8(w^1))
		return Mem{Base: Rn, Mode: mode, Offset: int16(sign) * imm}

	case arg_mem_R_pm_imm8_postindex:
		// Treat [<Rn>],#+/-<imm8> like [<Rn>{,#+/-<imm8>}]{!}
		// by forcing P=0, W=0 (postindex=true).
		return decodeArg(arg_mem_R_pm_imm8_W, x&^(1<<24|1<<21))

	case arg_mem_R_pm_imm8_W:
		Rn := Reg((x >> 16) & (1<<4 - 1))
		u := (x >> 23) & 1
		w := (x >> 21) & 1
		p := (x >> 24) & 1
		if p == 0 && w == 1 {
			return nil
		}
		sign := int8(+1)
		if u == 0 {
			sign = -1
		}
		imm := int16((x>>8)&(1<<4-1)<<4 | x&(1<<4-1))
		mode := AddrMode(uint8(p<<1) | uint8(w^1))
		return Mem{Base: Rn, Mode: mode, Offset: int16(sign) * imm}

	case arg_mem_R_pm_imm8at0_offset:
		Rn := Reg((x >> 16) & (1<<4 - 1))
		u := (x >> 23) & 1
		sign := int8(+1)
		if u == 0 {
			sign = -1
		}
		imm := int16(x&(1<<8-1)) << 2
		return Mem{Base: Rn, Mode: AddrOffset, Offset: int16(sign) * imm}

	case arg_option:
		return Imm(x & (1<<4 - 1))

	case arg_registers:
		return RegList(x & (1<<16 - 1))

	case arg_registers2:
		x &= 1<<16 - 1
		n := 0
		for i := 0; i < 16; i++ {
			if x>>uint(i)&1 != 0 {
				n++
			}
		}
		if n < 2 {
			return nil
		}
		return RegList(x)

	case arg_registers1:
		Rt := (x >> 12) & (1<<4 - 1)
		return RegList(1 << Rt)

	case arg_satimm4:
		return Imm((x >> 16) & (1<<4 - 1))

	case arg_satimm5:
		return Imm((x >> 16) & (1<<5 - 1))

	case arg_satimm4m1:
		return Imm((x>>16)&(1<<4-1) + 1)

	case arg_satimm5m1:
		return Imm((x>>16)&(1<<5-1) + 1)

	case arg_widthm1:
		return Imm((x>>16)&(1<<5-1) + 1)

	}
}

// decodeShift decodes the shift-by-immediate encoded in x.
func decodeShift(x uint32) (Shift, uint8) {
	count := (x >> 7) & (1<<5 - 1)
	typ := Shift((x >> 5) & (1<<2 - 1))
	switch typ {
	case ShiftRight, ShiftRightSigned:
		if count == 0 {
			count = 32
		}
	case RotateRight:
		if count == 0 {
			typ = RotateRightExt
			count = 1
		}
	}
	return typ, uint8(count)
}
                                                                                                                                                                                                                                                                                                                                                                               root/go1.4/src/cmd/internal/rsc.io/arm/armasm/decode_test.go                                        0100644 0000000 0000000 00000003077 12600426226 022302  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package armasm

import (
	"encoding/hex"
	"io/ioutil"
	"strconv"
	"strings"
	"testing"
)

func TestDecode(t *testing.T) {
	data, err := ioutil.ReadFile("testdata/decode.txt")
	if err != nil {
		t.Fatal(err)
	}
	all := string(data)
	for strings.Contains(all, "\t\t") {
		all = strings.Replace(all, "\t\t", "\t", -1)
	}
	for _, line := range strings.Split(all, "\n") {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}
		f := strings.SplitN(line, "\t", 4)
		i := strings.Index(f[0], "|")
		if i < 0 {
			t.Errorf("parsing %q: missing | separator", f[0])
			continue
		}
		if i%2 != 0 {
			t.Errorf("parsing %q: misaligned | separator", f[0])
		}
		size := i / 2
		code, err := hex.DecodeString(f[0][:i] + f[0][i+1:])
		if err != nil {
			t.Errorf("parsing %q: %v", f[0], err)
			continue
		}
		mode, err := strconv.Atoi(f[1])
		if err != nil {
			t.Errorf("invalid mode %q in: %s", f[1], line)
			continue
		}
		syntax, asm := f[2], f[3]
		inst, err := Decode(code, Mode(mode))
		var out string
		if err != nil {
			out = "error: " + err.Error()
		} else {
			switch syntax {
			case "gnu":
				out = GNUSyntax(inst)
			case "plan9":
				out = Plan9Syntax(inst, 0, nil, nil)
			default:
				t.Errorf("unknown syntax %q", syntax)
				continue
			}
		}
		if out != asm || inst.Len != size {
			t.Errorf("Decode(%s) [%s] = %s, %d, want %s, %d", f[0], syntax, out, inst.Len, asm, size)
		}
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 root/go1.4/src/cmd/internal/rsc.io/arm/armasm/ext_test.go                                           0100644 0000000 0000000 00000034236 12600426226 021660  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Support for testing against external disassembler program.
// Copied and simplified from rsc.io/x86/x86asm/ext_test.go.

package armasm

import (
	"bufio"
	"bytes"
	"encoding/hex"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"os"
	"os/exec"
	"regexp"
	"runtime"
	"strings"
	"testing"
	"time"
)

var (
	printTests = flag.Bool("printtests", false, "print test cases that exercise new code paths")
	dumpTest   = flag.Bool("dump", false, "dump all encodings")
	mismatch   = flag.Bool("mismatch", false, "log allowed mismatches")
	longTest   = flag.Bool("long", false, "long test")
	keep       = flag.Bool("keep", false, "keep object files around")
	debug      = false
)

// A ExtInst represents a single decoded instruction parsed
// from an external disassembler's output.
type ExtInst struct {
	addr uint32
	enc  [4]byte
	nenc int
	text string
}

func (r ExtInst) String() string {
	return fmt.Sprintf("%#x: % x: %s", r.addr, r.enc, r.text)
}

// An ExtDis is a connection between an external disassembler and a test.
type ExtDis struct {
	Arch     Mode
	Dec      chan ExtInst
	File     *os.File
	Size     int
	KeepFile bool
	Cmd      *exec.Cmd
}

// Run runs the given command - the external disassembler - and returns
// a buffered reader of its standard output.
func (ext *ExtDis) Run(cmd ...string) (*bufio.Reader, error) {
	if *keep {
		log.Printf("%s\n", strings.Join(cmd, " "))
	}
	ext.Cmd = exec.Command(cmd[0], cmd[1:]...)
	out, err := ext.Cmd.StdoutPipe()
	if err != nil {
		return nil, fmt.Errorf("stdoutpipe: %v", err)
	}
	if err := ext.Cmd.Start(); err != nil {
		return nil, fmt.Errorf("exec: %v", err)
	}

	b := bufio.NewReaderSize(out, 1<<20)
	return b, nil
}

// Wait waits for the command started with Run to exit.
func (ext *ExtDis) Wait() error {
	return ext.Cmd.Wait()
}

// testExtDis tests a set of byte sequences against an external disassembler.
// The disassembler is expected to produce the given syntax and be run
// in the given architecture mode (16, 32, or 64-bit).
// The extdis function must start the external disassembler
// and then parse its output, sending the parsed instructions on ext.Dec.
// The generate function calls its argument f once for each byte sequence
// to be tested. The generate function itself will be called twice, and it must
// make the same sequence of calls to f each time.
// When a disassembly does not match the internal decoding,
// allowedMismatch determines whether this mismatch should be
// allowed, or else considered an error.
func testExtDis(
	t *testing.T,
	syntax string,
	arch Mode,
	extdis func(ext *ExtDis) error,
	generate func(f func([]byte)),
	allowedMismatch func(text string, size int, inst *Inst, dec ExtInst) bool,
) {
	start := time.Now()
	ext := &ExtDis{
		Dec:  make(chan ExtInst),
		Arch: arch,
	}
	errc := make(chan error)

	// First pass: write instructions to input file for external disassembler.
	file, f, size, err := writeInst(generate)
	if err != nil {
		t.Fatal(err)
	}
	ext.Size = size
	ext.File = f
	defer func() {
		f.Close()
		if !*keep {
			os.Remove(file)
		}
	}()

	// Second pass: compare disassembly against our decodings.
	var (
		totalTests  = 0
		totalSkips  = 0
		totalErrors = 0

		errors = make([]string, 0, 100) // sampled errors, at most cap
	)
	go func() {
		errc <- extdis(ext)
	}()
	generate(func(enc []byte) {
		dec, ok := <-ext.Dec
		if !ok {
			t.Errorf("decoding stream ended early")
			return
		}
		inst, text := disasm(syntax, arch, pad(enc))
		totalTests++
		if *dumpTest {
			fmt.Printf("%x -> %s [%d]\n", enc[:len(enc)], dec.text, dec.nenc)
		}
		if text != dec.text || inst.Len != dec.nenc {
			suffix := ""
			if allowedMismatch(text, size, &inst, dec) {
				totalSkips++
				if !*mismatch {
					return
				}
				suffix += " (allowed mismatch)"
			}
			totalErrors++
			if len(errors) >= cap(errors) {
				j := rand.Intn(totalErrors)
				if j >= cap(errors) {
					return
				}
				errors = append(errors[:j], errors[j+1:]...)
			}
			errors = append(errors, fmt.Sprintf("decode(%x) = %q, %d, want %q, %d%s", enc, text, inst.Len, dec.text, dec.nenc, suffix))
		}
	})

	if *mismatch {
		totalErrors -= totalSkips
	}

	for _, b := range errors {
		t.Log(b)
	}

	if totalErrors > 0 {
		t.Fail()
	}
	t.Logf("%d test cases, %d expected mismatches, %d failures; %.0f cases/second", totalTests, totalSkips, totalErrors, float64(totalTests)/time.Since(start).Seconds())

	if err := <-errc; err != nil {
		t.Fatal("external disassembler: %v", err)
	}

}

const start = 0x8000 // start address of text

// writeInst writes the generated byte sequences to a new file
// starting at offset start. That file is intended to be the input to
// the external disassembler.
func writeInst(generate func(func([]byte))) (file string, f *os.File, size int, err error) {
	f, err = ioutil.TempFile("", "armasm")
	if err != nil {
		return
	}

	file = f.Name()

	f.Seek(start, 0)
	w := bufio.NewWriter(f)
	defer w.Flush()
	size = 0
	generate(func(x []byte) {
		if len(x) > 4 {
			x = x[:4]
		}
		if debug {
			fmt.Printf("%#x: %x%x\n", start+size, x, zeros[len(x):])
		}
		w.Write(x)
		w.Write(zeros[len(x):])
		size += len(zeros)
	})
	return file, f, size, nil
}

var zeros = []byte{0, 0, 0, 0}

// pad pads the code sequenc with pops.
func pad(enc []byte) []byte {
	if len(enc) < 4 {
		enc = append(enc[:len(enc):len(enc)], zeros[:4-len(enc)]...)
	}
	return enc
}

// disasm returns the decoded instruction and text
// for the given source bytes, using the given syntax and mode.
func disasm(syntax string, mode Mode, src []byte) (inst Inst, text string) {
	// If printTests is set, we record the coverage value
	// before and after, and we write out the inputs for which
	// coverage went up, in the format expected in testdata/decode.text.
	// This produces a fairly small set of test cases that exercise nearly
	// all the code.
	var cover float64
	if *printTests {
		cover -= coverage()
	}

	inst, err := Decode(src, mode)
	if err != nil {
		text = "error: " + err.Error()
	} else {
		text = inst.String()
		switch syntax {
		//case "arm":
		//	text = ARMSyntax(inst)
		case "gnu":
			text = GNUSyntax(inst)
		//case "plan9":
		//	text = Plan9Syntax(inst, 0, nil)
		default:
			text = "error: unknown syntax " + syntax
		}
	}

	if *printTests {
		cover += coverage()
		if cover > 0 {
			max := len(src)
			if max > 4 && inst.Len <= 4 {
				max = 4
			}
			fmt.Printf("%x|%x\t%d\t%s\t%s\n", src[:inst.Len], src[inst.Len:max], mode, syntax, text)
		}
	}

	return
}

// coverage returns a floating point number denoting the
// test coverage until now. The number increases when new code paths are exercised,
// both in the Go program and in the decoder byte code.
func coverage() float64 {
	/*
		testing.Coverage is not in the main distribution.
		The implementation, which must go in package testing, is:

		// Coverage reports the current code coverage as a fraction in the range [0, 1].
		func Coverage() float64 {
			var n, d int64
			for _, counters := range cover.Counters {
				for _, c := range counters {
					if c > 0 {
						n++
					}
					d++
				}
			}
			if d == 0 {
				return 0
			}
			return float64(n) / float64(d)
		}
	*/

	var f float64
	f += testing.Coverage()
	f += decodeCoverage()
	return f
}

func decodeCoverage() float64 {
	n := 0
	for _, t := range decoderCover {
		if t {
			n++
		}
	}
	return float64(1+n) / float64(1+len(decoderCover))
}

// Helpers for writing disassembler output parsers.

// hasPrefix reports whether any of the space-separated words in the text s
// begins with any of the given prefixes.
func hasPrefix(s string, prefixes ...string) bool {
	for _, prefix := range prefixes {
		for s := s; s != ""; {
			if strings.HasPrefix(s, prefix) {
				return true
			}
			i := strings.Index(s, " ")
			if i < 0 {
				break
			}
			s = s[i+1:]
		}
	}
	return false
}

// contains reports whether the text s contains any of the given substrings.
func contains(s string, substrings ...string) bool {
	for _, sub := range substrings {
		if strings.Contains(s, sub) {
			return true
		}
	}
	return false
}

// isHex reports whether b is a hexadecimal character (0-9A-Fa-f).
func isHex(b byte) bool { return b == '0' || unhex[b] > 0 }

// parseHex parses the hexadecimal byte dump in hex,
// appending the parsed bytes to raw and returning the updated slice.
// The returned bool signals whether any invalid hex was found.
// Spaces and tabs between bytes are okay but any other non-hex is not.
func parseHex(hex []byte, raw []byte) ([]byte, bool) {
	hex = trimSpace(hex)
	for j := 0; j < len(hex); {
		for hex[j] == ' ' || hex[j] == '\t' {
			j++
		}
		if j >= len(hex) {
			break
		}
		if j+2 > len(hex) || !isHex(hex[j]) || !isHex(hex[j+1]) {
			return nil, false
		}
		raw = append(raw, unhex[hex[j]]<<4|unhex[hex[j+1]])
		j += 2
	}
	return raw, true
}

var unhex = [256]byte{
	'0': 0,
	'1': 1,
	'2': 2,
	'3': 3,
	'4': 4,
	'5': 5,
	'6': 6,
	'7': 7,
	'8': 8,
	'9': 9,
	'A': 10,
	'B': 11,
	'C': 12,
	'D': 13,
	'E': 14,
	'F': 15,
	'a': 10,
	'b': 11,
	'c': 12,
	'd': 13,
	'e': 14,
	'f': 15,
}

// index is like bytes.Index(s, []byte(t)) but avoids the allocation.
func index(s []byte, t string) int {
	i := 0
	for {
		j := bytes.IndexByte(s[i:], t[0])
		if j < 0 {
			return -1
		}
		i = i + j
		if i+len(t) > len(s) {
			return -1
		}
		for k := 1; k < len(t); k++ {
			if s[i+k] != t[k] {
				goto nomatch
			}
		}
		return i
	nomatch:
		i++
	}
}

// fixSpace rewrites runs of spaces, tabs, and newline characters into single spaces in s.
// If s must be rewritten, it is rewritten in place.
func fixSpace(s []byte) []byte {
	s = trimSpace(s)
	for i := 0; i < len(s); i++ {
		if s[i] == '\t' || s[i] == '\n' || i > 0 && s[i] == ' ' && s[i-1] == ' ' {
			goto Fix
		}
	}
	return s

Fix:
	b := s
	w := 0
	for i := 0; i < len(s); i++ {
		c := s[i]
		if c == '\t' || c == '\n' {
			c = ' '
		}
		if c == ' ' && w > 0 && b[w-1] == ' ' {
			continue
		}
		b[w] = c
		w++
	}
	if w > 0 && b[w-1] == ' ' {
		w--
	}
	return b[:w]
}

// trimSpace trims leading and trailing space from s, returning a subslice of s.
func trimSpace(s []byte) []byte {
	j := len(s)
	for j > 0 && (s[j-1] == ' ' || s[j-1] == '\t' || s[j-1] == '\n') {
		j--
	}
	i := 0
	for i < j && (s[i] == ' ' || s[i] == '\t') {
		i++
	}
	return s[i:j]
}

// pcrel matches instructions using relative addressing mode.
var (
	pcrel = regexp.MustCompile(`^((?:.* )?(?:b|bl)x?(?:eq|ne|cs|cc|mi|pl|vs|vc|hi|ls|ge|lt|gt|le)?) 0x([0-9a-f]+)$`)
)

// Generators.
//
// The test cases are described as functions that invoke a callback repeatedly,
// with a new input sequence each time. These helpers make writing those
// a little easier.

// condCases generates conditional instructions.
func condCases(t *testing.T) func(func([]byte)) {
	return func(try func([]byte)) {
		// All the strides are relatively prime to 2 and therefore to 2,
		// so we will not repeat any instructions until we have tried all 2.
		// Using a stride other than 1 is meant to visit the instructions in a
		// pseudorandom order, which gives better variety in the set of
		// test cases chosen by -printtests.
		stride := uint32(10007)
		n := 1 << 28 / 7
		if testing.Short() {
			stride = 100003
			n = 1 << 28 / 1001
		} else if *longTest {
			stride = 200000033
			n = 1 << 28
		}
		x := uint32(0)
		for i := 0; i < n; i++ {
			enc := (x%15)<<28 | x&(1<<28-1)
			try([]byte{byte(enc), byte(enc >> 8), byte(enc >> 16), byte(enc >> 24)})
			x += stride
		}
	}
}

// uncondCases generates unconditional instructions.
func uncondCases(t *testing.T) func(func([]byte)) {
	return func(try func([]byte)) {
		condCases(t)(func(enc []byte) {
			enc[3] |= 0xF0
			try(enc)
		})
	}
}

func countBits(x uint32) int {
	n := 0
	for ; x != 0; x >>= 1 {
		n += int(x & 1)
	}
	return n
}

func expandBits(x, m uint32) uint32 {
	var out uint32
	for i := uint(0); i < 32; i++ {
		out >>= 1
		if m&1 != 0 {
			out |= (x & 1) << 31
			x >>= 1
		}
		m >>= 1
	}
	return out
}

func tryCondMask(mask, val uint32, try func([]byte)) {
	n := countBits(^mask)
	bits := uint32(0)
	for i := 0; i < 1<<uint(n); i++ {
		bits += 848251 // arbitrary prime
		x := val | expandBits(bits, ^mask) | uint32(i)%15<<28
		try([]byte{byte(x), byte(x >> 8), byte(x >> 16), byte(x >> 24)})
	}
}

// vfpCases generates VFP instructions.
func vfpCases(t *testing.T) func(func([]byte)) {
	const (
		vfpmask uint32 = 0xFF00FE10
		vfp     uint32 = 0x0E009A00
	)
	return func(try func([]byte)) {
		tryCondMask(0xff00fe10, 0x0e009a00, try) // standard VFP instruction space
		tryCondMask(0xffc00f7f, 0x0e000b10, try) // VFP MOV core reg to/from float64 half
		tryCondMask(0xffe00f7f, 0x0e000a10, try) // VFP MOV core reg to/from float32
		tryCondMask(0xffef0fff, 0x0ee10a10, try) // VFP MOV core reg to/from cond codes
	}
}

// hexCases generates the cases written in hexadecimal in the encoded string.
// Spaces in 'encoded' separate entire test cases, not individual bytes.
func hexCases(t *testing.T, encoded string) func(func([]byte)) {
	return func(try func([]byte)) {
		for _, x := range strings.Fields(encoded) {
			src, err := hex.DecodeString(x)
			if err != nil {
				t.Errorf("parsing %q: %v", x, err)
			}
			try(src)
		}
	}
}

// testdataCases generates the test cases recorded in testdata/decode.txt.
// It only uses the inputs; it ignores the answers recorded in that file.
func testdataCases(t *testing.T) func(func([]byte)) {
	var codes [][]byte
	data, err := ioutil.ReadFile("testdata/decode.txt")
	if err != nil {
		t.Fatal(err)
	}
	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}
		f := strings.Fields(line)[0]
		i := strings.Index(f, "|")
		if i < 0 {
			t.Errorf("parsing %q: missing | separator", f)
			continue
		}
		if i%2 != 0 {
			t.Errorf("parsing %q: misaligned | separator", f)
		}
		code, err := hex.DecodeString(f[:i] + f[i+1:])
		if err != nil {
			t.Errorf("parsing %q: %v", f, err)
			continue
		}
		codes = append(codes, code)
	}

	return func(try func([]byte)) {
		for _, code := range codes {
			try(code)
		}
	}
}

func caller(skip int) string {
	pc, _, _, _ := runtime.Caller(skip)
	f := runtime.FuncForPC(pc)
	name := "?"
	if f != nil {
		name = f.Name()
		if i := strings.LastIndex(name, "."); i >= 0 {
			name = name[i+1:]
		}
	}
	return name
}
                                                                                                                                                                                                                                                                                                                                                                  root/go1.4/src/cmd/internal/rsc.io/arm/armasm/gnu.go                                                0100644 0000000 0000000 00000007005 12600426226 020604  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package armasm

import (
	"bytes"
	"fmt"
	"strings"
)

var saveDot = strings.NewReplacer(
	".F16", "_dot_F16",
	".F32", "_dot_F32",
	".F64", "_dot_F64",
	".S32", "_dot_S32",
	".U32", "_dot_U32",
	".FXS", "_dot_S",
	".FXU", "_dot_U",
	".32", "_dot_32",
)

// GNUSyntax returns the GNU assembler syntax for the instruction, as defined by GNU binutils.
// This form typically matches the syntax defined in the ARM Reference Manual.
func GNUSyntax(inst Inst) string {
	var buf bytes.Buffer
	op := inst.Op.String()
	op = saveDot.Replace(op)
	op = strings.Replace(op, ".", "", -1)
	op = strings.Replace(op, "_dot_", ".", -1)
	op = strings.ToLower(op)
	buf.WriteString(op)
	sep := " "
	for i, arg := range inst.Args {
		if arg == nil {
			break
		}
		text := gnuArg(&inst, i, arg)
		if text == "" {
			continue
		}
		buf.WriteString(sep)
		sep = ", "
		buf.WriteString(text)
	}
	return buf.String()
}

func gnuArg(inst *Inst, argIndex int, arg Arg) string {
	switch inst.Op &^ 15 {
	case LDRD_EQ, LDREXD_EQ, STRD_EQ:
		if argIndex == 1 {
			// second argument in consecutive pair not printed
			return ""
		}
	case STREXD_EQ:
		if argIndex == 2 {
			// second argument in consecutive pair not printed
			return ""
		}
	}

	switch arg := arg.(type) {
	case Imm:
		switch inst.Op &^ 15 {
		case BKPT_EQ:
			return fmt.Sprintf("%#04x", uint32(arg))
		case SVC_EQ:
			return fmt.Sprintf("%#08x", uint32(arg))
		}
		return fmt.Sprintf("#%d", int32(arg))

	case ImmAlt:
		return fmt.Sprintf("#%d, %d", arg.Val, arg.Rot)

	case Mem:
		R := gnuArg(inst, -1, arg.Base)
		X := ""
		if arg.Sign != 0 {
			X = ""
			if arg.Sign < 0 {
				X = "-"
			}
			X += gnuArg(inst, -1, arg.Index)
			if arg.Shift == ShiftLeft && arg.Count == 0 {
				// nothing
			} else if arg.Shift == RotateRightExt {
				X += ", rrx"
			} else {
				X += fmt.Sprintf(", %s #%d", strings.ToLower(arg.Shift.String()), arg.Count)
			}
		} else {
			X = fmt.Sprintf("#%d", arg.Offset)
		}

		switch arg.Mode {
		case AddrOffset:
			if X == "#0" {
				return fmt.Sprintf("[%s]", R)
			}
			return fmt.Sprintf("[%s, %s]", R, X)
		case AddrPreIndex:
			return fmt.Sprintf("[%s, %s]!", R, X)
		case AddrPostIndex:
			return fmt.Sprintf("[%s], %s", R, X)
		case AddrLDM:
			if X == "#0" {
				return R
			}
		case AddrLDM_WB:
			if X == "#0" {
				return R + "!"
			}
		}
		return fmt.Sprintf("[%s Mode(%d) %s]", R, int(arg.Mode), X)

	case PCRel:
		return fmt.Sprintf(".%+#x", int32(arg)+4)

	case Reg:
		switch inst.Op &^ 15 {
		case LDREX_EQ:
			if argIndex == 0 {
				return fmt.Sprintf("r%d", int32(arg))
			}
		}
		switch arg {
		case R10:
			return "sl"
		case R11:
			return "fp"
		case R12:
			return "ip"
		}

	case RegList:
		var buf bytes.Buffer
		fmt.Fprintf(&buf, "{")
		sep := ""
		for i := 0; i < 16; i++ {
			if arg&(1<<uint(i)) != 0 {
				fmt.Fprintf(&buf, "%s%s", sep, gnuArg(inst, -1, Reg(i)))
				sep = ", "
			}
		}
		fmt.Fprintf(&buf, "}")
		return buf.String()

	case RegShift:
		if arg.Shift == ShiftLeft && arg.Count == 0 {
			return gnuArg(inst, -1, arg.Reg)
		}
		if arg.Shift == RotateRightExt {
			return gnuArg(inst, -1, arg.Reg) + ", rrx"
		}
		return fmt.Sprintf("%s, %s #%d", gnuArg(inst, -1, arg.Reg), strings.ToLower(arg.Shift.String()), arg.Count)

	case RegShiftReg:
		return fmt.Sprintf("%s, %s %s", gnuArg(inst, -1, arg.Reg), strings.ToLower(arg.Shift.String()), gnuArg(inst, -1, arg.RegCount))

	}
	return strings.ToLower(arg.String())
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           root/go1.4/src/cmd/internal/rsc.io/arm/armasm/inst.go                                               0100644 0000000 0000000 00000017055 12600426226 020776  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package armasm

import (
	"bytes"
	"fmt"
)

// A Mode is an instruction execution mode.
type Mode int

const (
	_ Mode = iota
	ModeARM
	ModeThumb
)

func (m Mode) String() string {
	switch m {
	case ModeARM:
		return "ARM"
	case ModeThumb:
		return "Thumb"
	}
	return fmt.Sprintf("Mode(%d)", int(m))
}

// An Op is an ARM opcode.
type Op uint16

// NOTE: The actual Op values are defined in tables.go.
// They are chosen to simplify instruction decoding and
// are not a dense packing from 0 to N, although the
// density is high, probably at least 90%.

func (op Op) String() string {
	if op >= Op(len(opstr)) || opstr[op] == "" {
		return fmt.Sprintf("Op(%d)", int(op))
	}
	return opstr[op]
}

// An Inst is a single instruction.
type Inst struct {
	Op   Op     // Opcode mnemonic
	Enc  uint32 // Raw encoding bits.
	Len  int    // Length of encoding in bytes.
	Args Args   // Instruction arguments, in ARM manual order.
}

func (i Inst) String() string {
	var buf bytes.Buffer
	buf.WriteString(i.Op.String())
	for j, arg := range i.Args {
		if arg == nil {
			break
		}
		if j == 0 {
			buf.WriteString(" ")
		} else {
			buf.WriteString(", ")
		}
		buf.WriteString(arg.String())
	}
	return buf.String()
}

// An Args holds the instruction arguments.
// If an instruction has fewer than 4 arguments,
// the final elements in the array are nil.
type Args [4]Arg

// An Arg is a single instruction argument, one of these types:
// Endian, Imm, Mem, PCRel, Reg, RegList, RegShift, RegShiftReg.
type Arg interface {
	IsArg()
	String() string
}

type Float32Imm float32

func (Float32Imm) IsArg() {}

func (f Float32Imm) String() string {
	return fmt.Sprintf("#%v", float32(f))
}

type Float64Imm float32

func (Float64Imm) IsArg() {}

func (f Float64Imm) String() string {
	return fmt.Sprintf("#%v", float64(f))
}

// An Imm is an integer constant.
type Imm uint32

func (Imm) IsArg() {}

func (i Imm) String() string {
	return fmt.Sprintf("#%#x", uint32(i))
}

// A ImmAlt is an alternate encoding of an integer constant.
type ImmAlt struct {
	Val uint8
	Rot uint8
}

func (ImmAlt) IsArg() {}

func (i ImmAlt) Imm() Imm {
	v := uint32(i.Val)
	r := uint(i.Rot)
	return Imm(v>>r | v<<(32-r))
}

func (i ImmAlt) String() string {
	return fmt.Sprintf("#%#x, %d", i.Val, i.Rot)
}

// A Label is a text (code) address.
type Label uint32

func (Label) IsArg() {}

func (i Label) String() string {
	return fmt.Sprintf("%#x", uint32(i))
}

// A Reg is a single register.
// The zero value denotes R0, not the absence of a register.
type Reg uint8

const (
	R0 Reg = iota
	R1
	R2
	R3
	R4
	R5
	R6
	R7
	R8
	R9
	R10
	R11
	R12
	R13
	R14
	R15

	S0
	S1
	S2
	S3
	S4
	S5
	S6
	S7
	S8
	S9
	S10
	S11
	S12
	S13
	S14
	S15
	S16
	S17
	S18
	S19
	S20
	S21
	S22
	S23
	S24
	S25
	S26
	S27
	S28
	S29
	S30
	S31

	D0
	D1
	D2
	D3
	D4
	D5
	D6
	D7
	D8
	D9
	D10
	D11
	D12
	D13
	D14
	D15
	D16
	D17
	D18
	D19
	D20
	D21
	D22
	D23
	D24
	D25
	D26
	D27
	D28
	D29
	D30
	D31

	APSR
	APSR_nzcv
	FPSCR

	SP = R13
	LR = R14
	PC = R15
)

func (Reg) IsArg() {}

func (r Reg) String() string {
	switch r {
	case APSR:
		return "APSR"
	case APSR_nzcv:
		return "APSR_nzcv"
	case FPSCR:
		return "FPSCR"
	case SP:
		return "SP"
	case PC:
		return "PC"
	case LR:
		return "LR"
	}
	if R0 <= r && r <= R15 {
		return fmt.Sprintf("R%d", int(r-R0))
	}
	if S0 <= r && r <= S31 {
		return fmt.Sprintf("S%d", int(r-S0))
	}
	if D0 <= r && r <= D31 {
		return fmt.Sprintf("D%d", int(r-D0))
	}
	return fmt.Sprintf("Reg(%d)", int(r))
}

// A RegX represents a fraction of a multi-value register.
// The Index field specifies the index number,
// but the size of the fraction is not specified.
// It must be inferred from the instruction and the register type.
// For example, in a VMOV instruction, RegX{D5, 1} represents
// the top 32 bits of the 64-bit D5 register.
type RegX struct {
	Reg   Reg
	Index int
}

func (RegX) IsArg() {}

func (r RegX) String() string {
	return fmt.Sprintf("%s[%d]", r.Reg, r.Index)
}

// A RegList is a register list.
// Bits at indexes x = 0 through 15 indicate whether the corresponding Rx register is in the list.
type RegList uint16

func (RegList) IsArg() {}

func (r RegList) String() string {
	var buf bytes.Buffer
	fmt.Fprintf(&buf, "{")
	sep := ""
	for i := 0; i < 16; i++ {
		if r&(1<<uint(i)) != 0 {
			fmt.Fprintf(&buf, "%s%s", sep, Reg(i).String())
			sep = ","
		}
	}
	fmt.Fprintf(&buf, "}")
	return buf.String()
}

// An Endian is the argument to the SETEND instruction.
type Endian uint8

const (
	LittleEndian Endian = 0
	BigEndian    Endian = 1
)

func (Endian) IsArg() {}

func (e Endian) String() string {
	if e != 0 {
		return "BE"
	}
	return "LE"
}

// A Shift describes an ARM shift operation.
type Shift uint8

const (
	ShiftLeft        Shift = 0 // left shift
	ShiftRight       Shift = 1 // logical (unsigned) right shift
	ShiftRightSigned Shift = 2 // arithmetic (signed) right shift
	RotateRight      Shift = 3 // right rotate
	RotateRightExt   Shift = 4 // right rotate through carry (Count will always be 1)
)

var shiftName = [...]string{
	"LSL", "LSR", "ASR", "ROR", "RRX",
}

func (s Shift) String() string {
	if s < 5 {
		return shiftName[s]
	}
	return fmt.Sprintf("Shift(%d)", int(s))
}

// A RegShift is a register shifted by a constant.
type RegShift struct {
	Reg   Reg
	Shift Shift
	Count uint8
}

func (RegShift) IsArg() {}

func (r RegShift) String() string {
	return fmt.Sprintf("%s %s #%d", r.Reg, r.Shift, r.Count)
}

// A RegShiftReg is a register shifted by a register.
type RegShiftReg struct {
	Reg      Reg
	Shift    Shift
	RegCount Reg
}

func (RegShiftReg) IsArg() {}

func (r RegShiftReg) String() string {
	return fmt.Sprintf("%s %s %s", r.Reg, r.Shift, r.RegCount)
}

// A PCRel describes a memory address (usually a code label)
// as a distance relative to the program counter.
// TODO(rsc): Define which program counter (PC+4? PC+8? PC?).
type PCRel int32

func (PCRel) IsArg() {}

func (r PCRel) String() string {
	return fmt.Sprintf("PC%+#x", int32(r))
}

// An AddrMode is an ARM addressing mode.
type AddrMode uint8

const (
	_             AddrMode = iota
	AddrPostIndex          // [R], X  use address R, set R = R + X
	AddrPreIndex           // [R, X]!  use address R + X, set R = R + X
	AddrOffset             // [R, X]  use address R + X
	AddrLDM                // R  [R] but formats as R, for LDM/STM only
	AddrLDM_WB             // R! - [R], X where X is instruction-specific amount, for LDM/STM only
)

// A Mem is a memory reference made up of a base R and index expression X.
// The effective memory address is R or R+X depending on AddrMode.
// The index expression is X = Sign*(Index Shift Count) + Offset,
// but in any instruction either Sign = 0 or Offset = 0.
type Mem struct {
	Base   Reg
	Mode   AddrMode
	Sign   int8
	Index  Reg
	Shift  Shift
	Count  uint8
	Offset int16
}

func (Mem) IsArg() {}

func (m Mem) String() string {
	R := m.Base.String()
	X := ""
	if m.Sign != 0 {
		X = "+"
		if m.Sign < 0 {
			X = "-"
		}
		X += m.Index.String()
		if m.Shift != ShiftLeft || m.Count != 0 {
			X += fmt.Sprintf(", %s #%d", m.Shift, m.Count)
		}
	} else {
		X = fmt.Sprintf("#%d", m.Offset)
	}

	switch m.Mode {
	case AddrOffset:
		if X == "#0" {
			return fmt.Sprintf("[%s]", R)
		}
		return fmt.Sprintf("[%s, %s]", R, X)
	case AddrPreIndex:
		return fmt.Sprintf("[%s, %s]!", R, X)
	case AddrPostIndex:
		return fmt.Sprintf("[%s], %s", R, X)
	case AddrLDM:
		if X == "#0" {
			return R
		}
	case AddrLDM_WB:
		if X == "#0" {
			return R + "!"
		}
	}
	return fmt.Sprintf("[%s Mode(%d) %s]", R, int(m.Mode), X)
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   root/go1.4/src/cmd/internal/rsc.io/arm/armasm/objdump_test.go                                       0100644 0000000 0000000 00000014573 12600426226 022522  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package armasm

import (
	"encoding/binary"
	"strings"
	"testing"
)

func TestObjdumpARMTestdata(t *testing.T) { testObjdumpARM(t, testdataCases(t)) }
func TestObjdumpARMManual(t *testing.T)   { testObjdumpARM(t, hexCases(t, objdumpManualTests)) }
func TestObjdumpARMCond(t *testing.T)     { testObjdumpARM(t, condCases(t)) }
func TestObjdumpARMUncond(t *testing.T)   { testObjdumpARM(t, uncondCases(t)) }
func TestObjdumpARMVFP(t *testing.T)      { testObjdumpARM(t, vfpCases(t)) }

// objdumpManualTests holds test cases that will be run by TestObjdumpARMManual.
// If you are debugging a few cases that turned up in a longer run, it can be useful
// to list them here and then use -run=Manual, particularly with tracing enabled.
// Note that these are byte sequences, so they must be reversed from the usual
// word presentation.
var objdumpManualTests = `
00000000
`

// allowedMismatchObjdump reports whether the mismatch between text and dec
// should be allowed by the test.
func allowedMismatchObjdump(text string, size int, inst *Inst, dec ExtInst) bool {
	if hasPrefix(text, "error:") {
		if hasPrefix(dec.text, unsupported...) || strings.Contains(dec.text, "invalid:") || strings.HasSuffix(dec.text, "^") || strings.Contains(dec.text, "f16.f64") || strings.Contains(dec.text, "f64.f16") {
			return true
		}
		// word 4320F02C: libopcodes says 'nopmi {44}'.
		if hasPrefix(dec.text, "nop") && strings.Contains(dec.text, "{") {
			return true
		}
	}

	if hasPrefix(dec.text, "error:") && text == "undef" && inst.Enc == 0xf7fabcfd {
		return true
	}

	// word 00f02053: libopcodes says 'noppl {0}'.
	if hasPrefix(dec.text, "nop") && hasPrefix(text, "nop") && dec.text == text+" {0}" {
		return true
	}

	// word F57FF04F. we say 'dsb #15', libopcodes says 'dsb sy'.
	if hasPrefix(text, "dsb") && hasPrefix(dec.text, "dsb") {
		return true
	}
	// word F57FF06F. we say 'isb #15', libopcodes says 'isb sy'.
	if hasPrefix(text, "isb") && hasPrefix(dec.text, "isb") {
		return true
	}
	// word F57FF053. we say 'dmb #3', libopcodes says 'dmb osh'.
	if hasPrefix(text, "dmb") && hasPrefix(dec.text, "dmb") {
		return true
	}

	// word 992D0000. push/stmdb with no registers (undefined).
	// we say 'stmdbls sp!, {}', libopcodes says 'pushls {}'.
	if hasPrefix(text, "stmdb") && hasPrefix(dec.text, "push") && strings.Contains(text, "{}") && strings.Contains(dec.text, "{}") {
		return true
	}

	// word 28BD0000. pop/ldm with no registers (undefined).
	// we say 'ldmcs sp!, {}', libopcodes says 'popcs {}'.
	if hasPrefix(text, "ldm") && hasPrefix(dec.text, "pop") && strings.Contains(text, "{}") && strings.Contains(dec.text, "{}") {
		return true
	}

	// word 014640F0.
	// libopcodes emits #-0 for negative zero; we don't.
	if strings.Replace(dec.text, "#-0", "#0", -1) == text || strings.Replace(dec.text, ", #-0", "", -1) == text {
		return true
	}

	// word 91EF90F0. we say 'strdls r9, [pc, #0]!' but libopcodes says 'strdls r9, [pc]'.
	// word D16F60F0. we say 'strdle r6, [pc, #0]!' but libopcodes says 'strdle r6, [pc, #-0]'.
	if strings.Replace(text, ", #0]!", "]", -1) == strings.Replace(dec.text, ", #-0]", "]", -1) {
		return true
	}

	// word 510F4000. we say apsr, libopcodes says CPSR.
	if strings.Replace(dec.text, "CPSR", "apsr", -1) == text {
		return true
	}

	// word 06A4B059.
	// for ssat and usat, libopcodes decodes asr #0 as asr #0 but the manual seems to say it should be asr #32.
	// There is never an asr #0.
	if strings.Replace(dec.text, ", asr #0", ", asr #32", -1) == text {
		return true
	}

	if len(dec.enc) >= 4 {
		raw := binary.LittleEndian.Uint32(dec.enc[:4])

		// word 21FFF0B5.
		// the manual is clear that this is pre-indexed mode (with !) but libopcodes generates post-index (without !).
		if raw&0x01200000 == 0x01200000 && strings.Replace(text, "!", "", -1) == dec.text {
			return true
		}

		// word C100543E: libopcodes says tst, but no evidence for that.
		if strings.HasPrefix(dec.text, "tst") && raw&0x0ff00000 != 0x03100000 && raw&0x0ff00000 != 0x01100000 {
			return true
		}

		// word C3203CE8: libopcodes says teq, but no evidence for that.
		if strings.HasPrefix(dec.text, "teq") && raw&0x0ff00000 != 0x03300000 && raw&0x0ff00000 != 0x01300000 {
			return true
		}

		// word D14C552E: libopcodes says cmp but no evidence for that.
		if strings.HasPrefix(dec.text, "cmp") && raw&0x0ff00000 != 0x03500000 && raw&0x0ff00000 != 0x01500000 {
			return true
		}

		// word 2166AA4A: libopcodes says cmn but no evidence for that.
		if strings.HasPrefix(dec.text, "cmn") && raw&0x0ff00000 != 0x03700000 && raw&0x0ff00000 != 0x01700000 {
			return true
		}

		// word E70AEEEF: libopcodes says str but no evidence for that.
		if strings.HasPrefix(dec.text, "str") && len(dec.text) >= 5 && (dec.text[3] == ' ' || dec.text[5] == ' ') && raw&0x0e500018 != 0x06000000 && raw&0x0e500000 != 0x0400000 {
			return true
		}

		// word B0AF48F4: libopcodes says strd but P=0,W=1 which is unpredictable.
		if hasPrefix(dec.text, "ldr", "str") && raw&0x01200000 == 0x00200000 {
			return true
		}

		// word B6CC1C76: libopcodes inexplicably says 'uxtab16lt r1, ip, r6, ROR #24' instead of 'uxtab16lt r1, ip, r6, ror #24'
		if strings.ToLower(dec.text) == text {
			return true
		}

		// word F410FDA1: libopcodes says PLDW but the manual is clear that PLDW is F5/F7, not F4.
		// word F7D0FB17: libopcodes says PLDW but the manual is clear that PLDW has 0x10 clear
		if hasPrefix(dec.text, "pld") && raw&0xfd000010 != 0xf5000000 {
			return true
		}

		// word F650FE14: libopcodes says PLI but the manual is clear that PLI has 0x10 clear
		if hasPrefix(dec.text, "pli") && raw&0xff000010 != 0xf6000000 {
			return true
		}
	}

	return false
}

// Instructions known to libopcodes (or xed) but not to us.
// Most of these are floating point coprocessor instructions.
var unsupported = strings.Fields(`
	abs
	acs
	adf
	aes
	asn
	atn
	cdp
	cf
	cmf
	cnf
	cos
	cps
	crc32
	dvf
	eret
	exp
	fadd
	fcmp
	fcpy
	fcvt
	fdiv
	fdv
	fix
	fld
	flt
	fmac
	fmd
	fml
	fmr
	fms
	fmul
	fmx
	fneg
	fnm
	frd
	fsit
	fsq
	fst
	fsu
	fto
	fui
	hlt
	hvc
	lda
	ldc
	ldf
	lfm
	lgn
	log
	mar
	mcr
	mcrr
	mia
	mnf
	mra
	mrc
	mrrc
	mrs
	msr
	msr
	muf
	mvf
	nrm
	pol
	pow
	rdf
	rfc
	rfe
	rfs
	rmf
	rnd
	rpw
	rsf
	sdiv
	sev
	sfm
	sha1
	sha256
	sin
	smc
	sqt
	srs
	stc
	stf
	stl
	suf
	tan
	udf
	udiv
	urd
	vfma
	vfms
	vfnma
	vfnms
	vrint
	wfc
	wfs
`)
                                                                                                                                     root/go1.4/src/cmd/internal/rsc.io/arm/armasm/objdumpext_test.go                                    0100644 0000000 0000000 00000014001 12600426226 023225  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Copied and simplified from rsc.io/x86/x86asm/objdumpext_test.go.

package armasm

import (
	"bytes"
	"debug/elf"
	"encoding/binary"
	"fmt"
	"io"
	"log"
	"os"
	"strconv"
	"strings"
	"testing"
)

const objdumpPath = "/usr/local/bin/arm-linux-elf-objdump"

func testObjdumpARM(t *testing.T, generate func(func([]byte))) {
	testObjdumpArch(t, generate, ModeARM)
}

func testObjdumpArch(t *testing.T, generate func(func([]byte)), arch Mode) {
	if testing.Short() {
		t.Skip("skipping objdump test in short mode")
	}

	if _, err := os.Stat(objdumpPath); err != nil {
		t.Fatal(err)
	}

	testExtDis(t, "gnu", arch, objdump, generate, allowedMismatchObjdump)
}

func objdump(ext *ExtDis) error {
	// File already written with instructions; add ELF header.
	if ext.Arch == ModeARM {
		if err := writeELF32(ext.File, ext.Size); err != nil {
			return err
		}
	} else {
		panic("unknown arch")
	}

	b, err := ext.Run(objdumpPath, "-d", "-z", ext.File.Name())
	if err != nil {
		return err
	}

	var (
		nmatch  int
		reading bool
		next    uint32 = start
		addr    uint32
		encbuf  [4]byte
		enc     []byte
		text    string
	)
	flush := func() {
		if addr == next {
			if m := pcrel.FindStringSubmatch(text); m != nil {
				targ, _ := strconv.ParseUint(m[2], 16, 64)
				text = fmt.Sprintf("%s .%+#x", m[1], int32(uint32(targ)-addr-uint32(len(enc))))
			}
			if strings.HasPrefix(text, "stmia") {
				text = "stm" + text[5:]
			}
			if strings.HasPrefix(text, "stmfd") {
				text = "stmdb" + text[5:]
			}
			if strings.HasPrefix(text, "ldmfd") {
				text = "ldm" + text[5:]
			}
			text = strings.Replace(text, "#0.0", "#0", -1)
			if text == "undefined" && len(enc) == 4 {
				text = "error: unknown instruction"
				enc = nil
			}
			if len(enc) == 4 {
				// prints as word but we want to record bytes
				enc[0], enc[3] = enc[3], enc[0]
				enc[1], enc[2] = enc[2], enc[1]
			}
			ext.Dec <- ExtInst{addr, encbuf, len(enc), text}
			encbuf = [4]byte{}
			enc = nil
			next += 4
		}
	}
	var textangle = []byte("<.text>:")
	for {
		line, err := b.ReadSlice('\n')
		if err != nil {
			if err == io.EOF {
				break
			}
			return fmt.Errorf("reading objdump output: %v", err)
		}
		if bytes.Contains(line, textangle) {
			reading = true
			continue
		}
		if !reading {
			continue
		}
		if debug {
			os.Stdout.Write(line)
		}
		if enc1 := parseContinuation(line, encbuf[:len(enc)]); enc1 != nil {
			enc = enc1
			continue
		}
		flush()
		nmatch++
		addr, enc, text = parseLine(line, encbuf[:0])
		if addr > next {
			return fmt.Errorf("address out of sync expected <= %#x at %q in:\n%s", next, line, line)
		}
	}
	flush()
	if next != start+uint32(ext.Size) {
		return fmt.Errorf("not enough results found [%d %d]", next, start+ext.Size)
	}
	if err := ext.Wait(); err != nil {
		return fmt.Errorf("exec: %v", err)
	}

	return nil
}

var (
	undefined      = []byte("<UNDEFINED>")
	unpredictable  = []byte("<UNPREDICTABLE>")
	illegalShifter = []byte("<illegal shifter operand>")
)

func parseLine(line []byte, encstart []byte) (addr uint32, enc []byte, text string) {
	oline := line
	i := index(line, ":\t")
	if i < 0 {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}
	x, err := strconv.ParseUint(string(trimSpace(line[:i])), 16, 32)
	if err != nil {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}
	addr = uint32(x)
	line = line[i+2:]
	i = bytes.IndexByte(line, '\t')
	if i < 0 {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}
	enc, ok := parseHex(line[:i], encstart)
	if !ok {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}
	line = trimSpace(line[i:])
	if bytes.Contains(line, undefined) {
		text = "undefined"
		return
	}
	if bytes.Contains(line, illegalShifter) {
		text = "undefined"
		return
	}
	if false && bytes.Contains(line, unpredictable) {
		text = "unpredictable"
		return
	}
	if i := bytes.IndexByte(line, ';'); i >= 0 {
		line = trimSpace(line[:i])
	}
	text = string(fixSpace(line))
	return
}

func parseContinuation(line []byte, enc []byte) []byte {
	i := index(line, ":\t")
	if i < 0 {
		return nil
	}
	line = line[i+1:]
	enc, _ = parseHex(line, enc)
	return enc
}

// writeELF32 writes an ELF32 header to the file,
// describing a text segment that starts at start
// and extends for size bytes.
func writeELF32(f *os.File, size int) error {
	f.Seek(0, 0)
	var hdr elf.Header32
	var prog elf.Prog32
	var sect elf.Section32
	var buf bytes.Buffer
	binary.Write(&buf, binary.LittleEndian, &hdr)
	off1 := buf.Len()
	binary.Write(&buf, binary.LittleEndian, &prog)
	off2 := buf.Len()
	binary.Write(&buf, binary.LittleEndian, &sect)
	off3 := buf.Len()
	buf.Reset()
	data := byte(elf.ELFDATA2LSB)
	hdr = elf.Header32{
		Ident:     [16]byte{0x7F, 'E', 'L', 'F', 1, data, 1},
		Type:      2,
		Machine:   uint16(elf.EM_ARM),
		Version:   1,
		Entry:     start,
		Phoff:     uint32(off1),
		Shoff:     uint32(off2),
		Flags:     0x05000002,
		Ehsize:    uint16(off1),
		Phentsize: uint16(off2 - off1),
		Phnum:     1,
		Shentsize: uint16(off3 - off2),
		Shnum:     3,
		Shstrndx:  2,
	}
	binary.Write(&buf, binary.LittleEndian, &hdr)
	prog = elf.Prog32{
		Type:   1,
		Off:    start,
		Vaddr:  start,
		Paddr:  start,
		Filesz: uint32(size),
		Memsz:  uint32(size),
		Flags:  5,
		Align:  start,
	}
	binary.Write(&buf, binary.LittleEndian, &prog)
	binary.Write(&buf, binary.LittleEndian, &sect) // NULL section
	sect = elf.Section32{
		Name:      1,
		Type:      uint32(elf.SHT_PROGBITS),
		Addr:      start,
		Off:       start,
		Size:      uint32(size),
		Flags:     uint32(elf.SHF_ALLOC | elf.SHF_EXECINSTR),
		Addralign: 4,
	}
	binary.Write(&buf, binary.LittleEndian, &sect) // .text
	sect = elf.Section32{
		Name:      uint32(len("\x00.text\x00")),
		Type:      uint32(elf.SHT_STRTAB),
		Addr:      0,
		Off:       uint32(off2 + (off3-off2)*3),
		Size:      uint32(len("\x00.text\x00.shstrtab\x00")),
		Addralign: 1,
	}
	binary.Write(&buf, binary.LittleEndian, &sect)
	buf.WriteString("\x00.text\x00.shstrtab\x00")
	f.Write(buf.Bytes())
	return nil
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               root/go1.4/src/cmd/internal/rsc.io/arm/armasm/plan9x.go                                             0100644 0000000 0000000 00000012200 12600426226 021217  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package armasm

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
	"strings"
)

// Plan9Syntax returns the Go assembler syntax for the instruction.
// The syntax was originally defined by Plan 9.
// The pc is the program counter of the instruction, used for expanding
// PC-relative addresses into absolute ones.
// The symname function queries the symbol table for the program
// being disassembled. Given a target address it returns the name and base
// address of the symbol containing the target, if any; otherwise it returns "", 0.
// The reader r should read from the text segment using text addresses
// as offsets; it is used to display pc-relative loads as constant loads.
func Plan9Syntax(inst Inst, pc uint64, symname func(uint64) (string, uint64), text io.ReaderAt) string {
	if symname == nil {
		symname = func(uint64) (string, uint64) { return "", 0 }
	}

	var args []string
	for _, a := range inst.Args {
		if a == nil {
			break
		}
		args = append(args, plan9Arg(&inst, pc, symname, a))
	}

	op := inst.Op.String()

	switch inst.Op &^ 15 {
	case LDR_EQ, LDRB_EQ, LDRH_EQ:
		// Check for RET
		reg, _ := inst.Args[0].(Reg)
		mem, _ := inst.Args[1].(Mem)
		if inst.Op&^15 == LDR_EQ && reg == R15 && mem.Base == SP && mem.Sign == 0 && mem.Mode == AddrPostIndex {
			return fmt.Sprintf("RET%s #%d", op[3:], mem.Offset)
		}

		// Check for PC-relative load.
		if mem.Base == PC && mem.Sign == 0 && mem.Mode == AddrOffset && text != nil {
			addr := uint32(pc) + 8 + uint32(mem.Offset)
			buf := make([]byte, 4)
			switch inst.Op &^ 15 {
			case LDRB_EQ:
				if _, err := text.ReadAt(buf[:1], int64(addr)); err != nil {
					break
				}
				args[1] = fmt.Sprintf("$%#x", buf[0])

			case LDRH_EQ:
				if _, err := text.ReadAt(buf[:2], int64(addr)); err != nil {
					break
				}
				args[1] = fmt.Sprintf("$%#x", binary.LittleEndian.Uint16(buf))

			case LDR_EQ:
				if _, err := text.ReadAt(buf, int64(addr)); err != nil {
					break
				}
				x := binary.LittleEndian.Uint32(buf)
				if s, base := symname(uint64(x)); s != "" && uint64(x) == base {
					args[1] = fmt.Sprintf("$%s(SB)", s)
				} else {
					args[1] = fmt.Sprintf("$%#x", x)
				}
			}
		}
	}

	// Move addressing mode into opcode suffix.
	suffix := ""
	switch inst.Op &^ 15 {
	case LDR_EQ, LDRB_EQ, LDRH_EQ, STR_EQ, STRB_EQ, STRH_EQ:
		mem, _ := inst.Args[1].(Mem)
		switch mem.Mode {
		case AddrOffset, AddrLDM:
			// no suffix
		case AddrPreIndex, AddrLDM_WB:
			suffix = ".W"
		case AddrPostIndex:
			suffix = ".P"
		}
		off := ""
		if mem.Offset != 0 {
			off = fmt.Sprintf("%#x", mem.Offset)
		}
		base := fmt.Sprintf("(R%d)", int(mem.Base))
		index := ""
		if mem.Sign != 0 {
			sign := ""
			if mem.Sign < 0 {
				sign = ""
			}
			shift := ""
			if mem.Count != 0 {
				shift = fmt.Sprintf("%s%d", plan9Shift[mem.Shift], mem.Count)
			}
			index = fmt.Sprintf("(%sR%d%s)", sign, int(mem.Index), shift)
		}
		args[1] = off + base + index
	}

	// Reverse args, placing dest last.
	for i, j := 0, len(args)-1; i < j; i, j = i+1, j-1 {
		args[i], args[j] = args[j], args[i]
	}

	switch inst.Op &^ 15 {
	case MOV_EQ:
		op = "MOVW" + op[3:]

	case LDR_EQ:
		op = "MOVW" + op[3:] + suffix
	case LDRB_EQ:
		op = "MOVB" + op[4:] + suffix
	case LDRH_EQ:
		op = "MOVH" + op[4:] + suffix

	case STR_EQ:
		op = "MOVW" + op[3:] + suffix
		args[0], args[1] = args[1], args[0]
	case STRB_EQ:
		op = "MOVB" + op[4:] + suffix
		args[0], args[1] = args[1], args[0]
	case STRH_EQ:
		op = "MOVH" + op[4:] + suffix
		args[0], args[1] = args[1], args[0]
	}

	if args != nil {
		op += " " + strings.Join(args, ", ")
	}

	return op
}

// assembler syntax for the various shifts.
// @x> is a lie; the assembler uses @> 0
// instead of @x> 1, but i wanted to be clear that it
// was a different operation (rotate right extended, not rotate right).
var plan9Shift = []string{"<<", ">>", "->", "@>", "@x>"}

func plan9Arg(inst *Inst, pc uint64, symname func(uint64) (string, uint64), arg Arg) string {
	switch a := arg.(type) {
	case Endian:

	case Imm:
		return fmt.Sprintf("$%d", int(a))

	case Mem:

	case PCRel:
		addr := uint32(pc) + 8 + uint32(a)
		if s, base := symname(uint64(addr)); s != "" && uint64(addr) == base {
			return fmt.Sprintf("%s(SB)", s)
		}
		return fmt.Sprintf("%#x", addr)

	case Reg:
		if a < 16 {
			return fmt.Sprintf("R%d", int(a))
		}

	case RegList:
		var buf bytes.Buffer
		start := -2
		end := -2
		fmt.Fprintf(&buf, "[")
		flush := func() {
			if start >= 0 {
				if buf.Len() > 1 {
					fmt.Fprintf(&buf, ",")
				}
				if start == end {
					fmt.Fprintf(&buf, "R%d", start)
				} else {
					fmt.Fprintf(&buf, "R%d-R%d", start, end)
				}
			}
		}
		for i := 0; i < 16; i++ {
			if a&(1<<uint(i)) != 0 {
				if i == end+1 {
					end++
					continue
				}
				start = i
				end = i
			}
		}
		flush()
		fmt.Fprintf(&buf, "]")
		return buf.String()

	case RegShift:
		return fmt.Sprintf("R%d%s$%d", int(a.Reg), plan9Shift[a.Shift], int(a.Count))

	case RegShiftReg:
		return fmt.Sprintf("R%d%sR%d", int(a.Reg), plan9Shift[a.Shift], int(a.RegCount))
	}
	return strings.ToUpper(arg.String())
}
                                                                                                                                                                                                                                                                                                                                                                                                root/go1.4/src/cmd/internal/rsc.io/arm/armasm/tables.go                                             0100644 0000000 0000000 00001017742 12600426226 021277  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package armasm

const (
	_ Op = iota
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	ADC_EQ
	ADC_NE
	ADC_CS
	ADC_CC
	ADC_MI
	ADC_PL
	ADC_VS
	ADC_VC
	ADC_HI
	ADC_LS
	ADC_GE
	ADC_LT
	ADC_GT
	ADC_LE
	ADC
	ADC_ZZ
	ADC_S_EQ
	ADC_S_NE
	ADC_S_CS
	ADC_S_CC
	ADC_S_MI
	ADC_S_PL
	ADC_S_VS
	ADC_S_VC
	ADC_S_HI
	ADC_S_LS
	ADC_S_GE
	ADC_S_LT
	ADC_S_GT
	ADC_S_LE
	ADC_S
	ADC_S_ZZ
	ADD_EQ
	ADD_NE
	ADD_CS
	ADD_CC
	ADD_MI
	ADD_PL
	ADD_VS
	ADD_VC
	ADD_HI
	ADD_LS
	ADD_GE
	ADD_LT
	ADD_GT
	ADD_LE
	ADD
	ADD_ZZ
	ADD_S_EQ
	ADD_S_NE
	ADD_S_CS
	ADD_S_CC
	ADD_S_MI
	ADD_S_PL
	ADD_S_VS
	ADD_S_VC
	ADD_S_HI
	ADD_S_LS
	ADD_S_GE
	ADD_S_LT
	ADD_S_GT
	ADD_S_LE
	ADD_S
	ADD_S_ZZ
	AND_EQ
	AND_NE
	AND_CS
	AND_CC
	AND_MI
	AND_PL
	AND_VS
	AND_VC
	AND_HI
	AND_LS
	AND_GE
	AND_LT
	AND_GT
	AND_LE
	AND
	AND_ZZ
	AND_S_EQ
	AND_S_NE
	AND_S_CS
	AND_S_CC
	AND_S_MI
	AND_S_PL
	AND_S_VS
	AND_S_VC
	AND_S_HI
	AND_S_LS
	AND_S_GE
	AND_S_LT
	AND_S_GT
	AND_S_LE
	AND_S
	AND_S_ZZ
	ASR_EQ
	ASR_NE
	ASR_CS
	ASR_CC
	ASR_MI
	ASR_PL
	ASR_VS
	ASR_VC
	ASR_HI
	ASR_LS
	ASR_GE
	ASR_LT
	ASR_GT
	ASR_LE
	ASR
	ASR_ZZ
	ASR_S_EQ
	ASR_S_NE
	ASR_S_CS
	ASR_S_CC
	ASR_S_MI
	ASR_S_PL
	ASR_S_VS
	ASR_S_VC
	ASR_S_HI
	ASR_S_LS
	ASR_S_GE
	ASR_S_LT
	ASR_S_GT
	ASR_S_LE
	ASR_S
	ASR_S_ZZ
	B_EQ
	B_NE
	B_CS
	B_CC
	B_MI
	B_PL
	B_VS
	B_VC
	B_HI
	B_LS
	B_GE
	B_LT
	B_GT
	B_LE
	B
	B_ZZ
	BFC_EQ
	BFC_NE
	BFC_CS
	BFC_CC
	BFC_MI
	BFC_PL
	BFC_VS
	BFC_VC
	BFC_HI
	BFC_LS
	BFC_GE
	BFC_LT
	BFC_GT
	BFC_LE
	BFC
	BFC_ZZ
	BFI_EQ
	BFI_NE
	BFI_CS
	BFI_CC
	BFI_MI
	BFI_PL
	BFI_VS
	BFI_VC
	BFI_HI
	BFI_LS
	BFI_GE
	BFI_LT
	BFI_GT
	BFI_LE
	BFI
	BFI_ZZ
	BIC_EQ
	BIC_NE
	BIC_CS
	BIC_CC
	BIC_MI
	BIC_PL
	BIC_VS
	BIC_VC
	BIC_HI
	BIC_LS
	BIC_GE
	BIC_LT
	BIC_GT
	BIC_LE
	BIC
	BIC_ZZ
	BIC_S_EQ
	BIC_S_NE
	BIC_S_CS
	BIC_S_CC
	BIC_S_MI
	BIC_S_PL
	BIC_S_VS
	BIC_S_VC
	BIC_S_HI
	BIC_S_LS
	BIC_S_GE
	BIC_S_LT
	BIC_S_GT
	BIC_S_LE
	BIC_S
	BIC_S_ZZ
	BKPT_EQ
	BKPT_NE
	BKPT_CS
	BKPT_CC
	BKPT_MI
	BKPT_PL
	BKPT_VS
	BKPT_VC
	BKPT_HI
	BKPT_LS
	BKPT_GE
	BKPT_LT
	BKPT_GT
	BKPT_LE
	BKPT
	BKPT_ZZ
	BL_EQ
	BL_NE
	BL_CS
	BL_CC
	BL_MI
	BL_PL
	BL_VS
	BL_VC
	BL_HI
	BL_LS
	BL_GE
	BL_LT
	BL_GT
	BL_LE
	BL
	BL_ZZ
	BLX_EQ
	BLX_NE
	BLX_CS
	BLX_CC
	BLX_MI
	BLX_PL
	BLX_VS
	BLX_VC
	BLX_HI
	BLX_LS
	BLX_GE
	BLX_LT
	BLX_GT
	BLX_LE
	BLX
	BLX_ZZ
	BX_EQ
	BX_NE
	BX_CS
	BX_CC
	BX_MI
	BX_PL
	BX_VS
	BX_VC
	BX_HI
	BX_LS
	BX_GE
	BX_LT
	BX_GT
	BX_LE
	BX
	BX_ZZ
	BXJ_EQ
	BXJ_NE
	BXJ_CS
	BXJ_CC
	BXJ_MI
	BXJ_PL
	BXJ_VS
	BXJ_VC
	BXJ_HI
	BXJ_LS
	BXJ_GE
	BXJ_LT
	BXJ_GT
	BXJ_LE
	BXJ
	BXJ_ZZ
	CLREX
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	CLZ_EQ
	CLZ_NE
	CLZ_CS
	CLZ_CC
	CLZ_MI
	CLZ_PL
	CLZ_VS
	CLZ_VC
	CLZ_HI
	CLZ_LS
	CLZ_GE
	CLZ_LT
	CLZ_GT
	CLZ_LE
	CLZ
	CLZ_ZZ
	CMN_EQ
	CMN_NE
	CMN_CS
	CMN_CC
	CMN_MI
	CMN_PL
	CMN_VS
	CMN_VC
	CMN_HI
	CMN_LS
	CMN_GE
	CMN_LT
	CMN_GT
	CMN_LE
	CMN
	CMN_ZZ
	CMP_EQ
	CMP_NE
	CMP_CS
	CMP_CC
	CMP_MI
	CMP_PL
	CMP_VS
	CMP_VC
	CMP_HI
	CMP_LS
	CMP_GE
	CMP_LT
	CMP_GT
	CMP_LE
	CMP
	CMP_ZZ
	DBG_EQ
	DBG_NE
	DBG_CS
	DBG_CC
	DBG_MI
	DBG_PL
	DBG_VS
	DBG_VC
	DBG_HI
	DBG_LS
	DBG_GE
	DBG_LT
	DBG_GT
	DBG_LE
	DBG
	DBG_ZZ
	DMB
	DSB
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	EOR_EQ
	EOR_NE
	EOR_CS
	EOR_CC
	EOR_MI
	EOR_PL
	EOR_VS
	EOR_VC
	EOR_HI
	EOR_LS
	EOR_GE
	EOR_LT
	EOR_GT
	EOR_LE
	EOR
	EOR_ZZ
	EOR_S_EQ
	EOR_S_NE
	EOR_S_CS
	EOR_S_CC
	EOR_S_MI
	EOR_S_PL
	EOR_S_VS
	EOR_S_VC
	EOR_S_HI
	EOR_S_LS
	EOR_S_GE
	EOR_S_LT
	EOR_S_GT
	EOR_S_LE
	EOR_S
	EOR_S_ZZ
	ISB
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	LDM_EQ
	LDM_NE
	LDM_CS
	LDM_CC
	LDM_MI
	LDM_PL
	LDM_VS
	LDM_VC
	LDM_HI
	LDM_LS
	LDM_GE
	LDM_LT
	LDM_GT
	LDM_LE
	LDM
	LDM_ZZ
	LDMDA_EQ
	LDMDA_NE
	LDMDA_CS
	LDMDA_CC
	LDMDA_MI
	LDMDA_PL
	LDMDA_VS
	LDMDA_VC
	LDMDA_HI
	LDMDA_LS
	LDMDA_GE
	LDMDA_LT
	LDMDA_GT
	LDMDA_LE
	LDMDA
	LDMDA_ZZ
	LDMDB_EQ
	LDMDB_NE
	LDMDB_CS
	LDMDB_CC
	LDMDB_MI
	LDMDB_PL
	LDMDB_VS
	LDMDB_VC
	LDMDB_HI
	LDMDB_LS
	LDMDB_GE
	LDMDB_LT
	LDMDB_GT
	LDMDB_LE
	LDMDB
	LDMDB_ZZ
	LDMIB_EQ
	LDMIB_NE
	LDMIB_CS
	LDMIB_CC
	LDMIB_MI
	LDMIB_PL
	LDMIB_VS
	LDMIB_VC
	LDMIB_HI
	LDMIB_LS
	LDMIB_GE
	LDMIB_LT
	LDMIB_GT
	LDMIB_LE
	LDMIB
	LDMIB_ZZ
	LDR_EQ
	LDR_NE
	LDR_CS
	LDR_CC
	LDR_MI
	LDR_PL
	LDR_VS
	LDR_VC
	LDR_HI
	LDR_LS
	LDR_GE
	LDR_LT
	LDR_GT
	LDR_LE
	LDR
	LDR_ZZ
	LDRB_EQ
	LDRB_NE
	LDRB_CS
	LDRB_CC
	LDRB_MI
	LDRB_PL
	LDRB_VS
	LDRB_VC
	LDRB_HI
	LDRB_LS
	LDRB_GE
	LDRB_LT
	LDRB_GT
	LDRB_LE
	LDRB
	LDRB_ZZ
	LDRBT_EQ
	LDRBT_NE
	LDRBT_CS
	LDRBT_CC
	LDRBT_MI
	LDRBT_PL
	LDRBT_VS
	LDRBT_VC
	LDRBT_HI
	LDRBT_LS
	LDRBT_GE
	LDRBT_LT
	LDRBT_GT
	LDRBT_LE
	LDRBT
	LDRBT_ZZ
	LDRD_EQ
	LDRD_NE
	LDRD_CS
	LDRD_CC
	LDRD_MI
	LDRD_PL
	LDRD_VS
	LDRD_VC
	LDRD_HI
	LDRD_LS
	LDRD_GE
	LDRD_LT
	LDRD_GT
	LDRD_LE
	LDRD
	LDRD_ZZ
	LDREX_EQ
	LDREX_NE
	LDREX_CS
	LDREX_CC
	LDREX_MI
	LDREX_PL
	LDREX_VS
	LDREX_VC
	LDREX_HI
	LDREX_LS
	LDREX_GE
	LDREX_LT
	LDREX_GT
	LDREX_LE
	LDREX
	LDREX_ZZ
	LDREXB_EQ
	LDREXB_NE
	LDREXB_CS
	LDREXB_CC
	LDREXB_MI
	LDREXB_PL
	LDREXB_VS
	LDREXB_VC
	LDREXB_HI
	LDREXB_LS
	LDREXB_GE
	LDREXB_LT
	LDREXB_GT
	LDREXB_LE
	LDREXB
	LDREXB_ZZ
	LDREXD_EQ
	LDREXD_NE
	LDREXD_CS
	LDREXD_CC
	LDREXD_MI
	LDREXD_PL
	LDREXD_VS
	LDREXD_VC
	LDREXD_HI
	LDREXD_LS
	LDREXD_GE
	LDREXD_LT
	LDREXD_GT
	LDREXD_LE
	LDREXD
	LDREXD_ZZ
	LDREXH_EQ
	LDREXH_NE
	LDREXH_CS
	LDREXH_CC
	LDREXH_MI
	LDREXH_PL
	LDREXH_VS
	LDREXH_VC
	LDREXH_HI
	LDREXH_LS
	LDREXH_GE
	LDREXH_LT
	LDREXH_GT
	LDREXH_LE
	LDREXH
	LDREXH_ZZ
	LDRH_EQ
	LDRH_NE
	LDRH_CS
	LDRH_CC
	LDRH_MI
	LDRH_PL
	LDRH_VS
	LDRH_VC
	LDRH_HI
	LDRH_LS
	LDRH_GE
	LDRH_LT
	LDRH_GT
	LDRH_LE
	LDRH
	LDRH_ZZ
	LDRHT_EQ
	LDRHT_NE
	LDRHT_CS
	LDRHT_CC
	LDRHT_MI
	LDRHT_PL
	LDRHT_VS
	LDRHT_VC
	LDRHT_HI
	LDRHT_LS
	LDRHT_GE
	LDRHT_LT
	LDRHT_GT
	LDRHT_LE
	LDRHT
	LDRHT_ZZ
	LDRSB_EQ
	LDRSB_NE
	LDRSB_CS
	LDRSB_CC
	LDRSB_MI
	LDRSB_PL
	LDRSB_VS
	LDRSB_VC
	LDRSB_HI
	LDRSB_LS
	LDRSB_GE
	LDRSB_LT
	LDRSB_GT
	LDRSB_LE
	LDRSB
	LDRSB_ZZ
	LDRSBT_EQ
	LDRSBT_NE
	LDRSBT_CS
	LDRSBT_CC
	LDRSBT_MI
	LDRSBT_PL
	LDRSBT_VS
	LDRSBT_VC
	LDRSBT_HI
	LDRSBT_LS
	LDRSBT_GE
	LDRSBT_LT
	LDRSBT_GT
	LDRSBT_LE
	LDRSBT
	LDRSBT_ZZ
	LDRSH_EQ
	LDRSH_NE
	LDRSH_CS
	LDRSH_CC
	LDRSH_MI
	LDRSH_PL
	LDRSH_VS
	LDRSH_VC
	LDRSH_HI
	LDRSH_LS
	LDRSH_GE
	LDRSH_LT
	LDRSH_GT
	LDRSH_LE
	LDRSH
	LDRSH_ZZ
	LDRSHT_EQ
	LDRSHT_NE
	LDRSHT_CS
	LDRSHT_CC
	LDRSHT_MI
	LDRSHT_PL
	LDRSHT_VS
	LDRSHT_VC
	LDRSHT_HI
	LDRSHT_LS
	LDRSHT_GE
	LDRSHT_LT
	LDRSHT_GT
	LDRSHT_LE
	LDRSHT
	LDRSHT_ZZ
	LDRT_EQ
	LDRT_NE
	LDRT_CS
	LDRT_CC
	LDRT_MI
	LDRT_PL
	LDRT_VS
	LDRT_VC
	LDRT_HI
	LDRT_LS
	LDRT_GE
	LDRT_LT
	LDRT_GT
	LDRT_LE
	LDRT
	LDRT_ZZ
	LSL_EQ
	LSL_NE
	LSL_CS
	LSL_CC
	LSL_MI
	LSL_PL
	LSL_VS
	LSL_VC
	LSL_HI
	LSL_LS
	LSL_GE
	LSL_LT
	LSL_GT
	LSL_LE
	LSL
	LSL_ZZ
	LSL_S_EQ
	LSL_S_NE
	LSL_S_CS
	LSL_S_CC
	LSL_S_MI
	LSL_S_PL
	LSL_S_VS
	LSL_S_VC
	LSL_S_HI
	LSL_S_LS
	LSL_S_GE
	LSL_S_LT
	LSL_S_GT
	LSL_S_LE
	LSL_S
	LSL_S_ZZ
	LSR_EQ
	LSR_NE
	LSR_CS
	LSR_CC
	LSR_MI
	LSR_PL
	LSR_VS
	LSR_VC
	LSR_HI
	LSR_LS
	LSR_GE
	LSR_LT
	LSR_GT
	LSR_LE
	LSR
	LSR_ZZ
	LSR_S_EQ
	LSR_S_NE
	LSR_S_CS
	LSR_S_CC
	LSR_S_MI
	LSR_S_PL
	LSR_S_VS
	LSR_S_VC
	LSR_S_HI
	LSR_S_LS
	LSR_S_GE
	LSR_S_LT
	LSR_S_GT
	LSR_S_LE
	LSR_S
	LSR_S_ZZ
	MLA_EQ
	MLA_NE
	MLA_CS
	MLA_CC
	MLA_MI
	MLA_PL
	MLA_VS
	MLA_VC
	MLA_HI
	MLA_LS
	MLA_GE
	MLA_LT
	MLA_GT
	MLA_LE
	MLA
	MLA_ZZ
	MLA_S_EQ
	MLA_S_NE
	MLA_S_CS
	MLA_S_CC
	MLA_S_MI
	MLA_S_PL
	MLA_S_VS
	MLA_S_VC
	MLA_S_HI
	MLA_S_LS
	MLA_S_GE
	MLA_S_LT
	MLA_S_GT
	MLA_S_LE
	MLA_S
	MLA_S_ZZ
	MLS_EQ
	MLS_NE
	MLS_CS
	MLS_CC
	MLS_MI
	MLS_PL
	MLS_VS
	MLS_VC
	MLS_HI
	MLS_LS
	MLS_GE
	MLS_LT
	MLS_GT
	MLS_LE
	MLS
	MLS_ZZ
	MOV_EQ
	MOV_NE
	MOV_CS
	MOV_CC
	MOV_MI
	MOV_PL
	MOV_VS
	MOV_VC
	MOV_HI
	MOV_LS
	MOV_GE
	MOV_LT
	MOV_GT
	MOV_LE
	MOV
	MOV_ZZ
	MOV_S_EQ
	MOV_S_NE
	MOV_S_CS
	MOV_S_CC
	MOV_S_MI
	MOV_S_PL
	MOV_S_VS
	MOV_S_VC
	MOV_S_HI
	MOV_S_LS
	MOV_S_GE
	MOV_S_LT
	MOV_S_GT
	MOV_S_LE
	MOV_S
	MOV_S_ZZ
	MOVT_EQ
	MOVT_NE
	MOVT_CS
	MOVT_CC
	MOVT_MI
	MOVT_PL
	MOVT_VS
	MOVT_VC
	MOVT_HI
	MOVT_LS
	MOVT_GE
	MOVT_LT
	MOVT_GT
	MOVT_LE
	MOVT
	MOVT_ZZ
	MOVW_EQ
	MOVW_NE
	MOVW_CS
	MOVW_CC
	MOVW_MI
	MOVW_PL
	MOVW_VS
	MOVW_VC
	MOVW_HI
	MOVW_LS
	MOVW_GE
	MOVW_LT
	MOVW_GT
	MOVW_LE
	MOVW
	MOVW_ZZ
	MRS_EQ
	MRS_NE
	MRS_CS
	MRS_CC
	MRS_MI
	MRS_PL
	MRS_VS
	MRS_VC
	MRS_HI
	MRS_LS
	MRS_GE
	MRS_LT
	MRS_GT
	MRS_LE
	MRS
	MRS_ZZ
	MUL_EQ
	MUL_NE
	MUL_CS
	MUL_CC
	MUL_MI
	MUL_PL
	MUL_VS
	MUL_VC
	MUL_HI
	MUL_LS
	MUL_GE
	MUL_LT
	MUL_GT
	MUL_LE
	MUL
	MUL_ZZ
	MUL_S_EQ
	MUL_S_NE
	MUL_S_CS
	MUL_S_CC
	MUL_S_MI
	MUL_S_PL
	MUL_S_VS
	MUL_S_VC
	MUL_S_HI
	MUL_S_LS
	MUL_S_GE
	MUL_S_LT
	MUL_S_GT
	MUL_S_LE
	MUL_S
	MUL_S_ZZ
	MVN_EQ
	MVN_NE
	MVN_CS
	MVN_CC
	MVN_MI
	MVN_PL
	MVN_VS
	MVN_VC
	MVN_HI
	MVN_LS
	MVN_GE
	MVN_LT
	MVN_GT
	MVN_LE
	MVN
	MVN_ZZ
	MVN_S_EQ
	MVN_S_NE
	MVN_S_CS
	MVN_S_CC
	MVN_S_MI
	MVN_S_PL
	MVN_S_VS
	MVN_S_VC
	MVN_S_HI
	MVN_S_LS
	MVN_S_GE
	MVN_S_LT
	MVN_S_GT
	MVN_S_LE
	MVN_S
	MVN_S_ZZ
	NOP_EQ
	NOP_NE
	NOP_CS
	NOP_CC
	NOP_MI
	NOP_PL
	NOP_VS
	NOP_VC
	NOP_HI
	NOP_LS
	NOP_GE
	NOP_LT
	NOP_GT
	NOP_LE
	NOP
	NOP_ZZ
	ORR_EQ
	ORR_NE
	ORR_CS
	ORR_CC
	ORR_MI
	ORR_PL
	ORR_VS
	ORR_VC
	ORR_HI
	ORR_LS
	ORR_GE
	ORR_LT
	ORR_GT
	ORR_LE
	ORR
	ORR_ZZ
	ORR_S_EQ
	ORR_S_NE
	ORR_S_CS
	ORR_S_CC
	ORR_S_MI
	ORR_S_PL
	ORR_S_VS
	ORR_S_VC
	ORR_S_HI
	ORR_S_LS
	ORR_S_GE
	ORR_S_LT
	ORR_S_GT
	ORR_S_LE
	ORR_S
	ORR_S_ZZ
	PKHBT_EQ
	PKHBT_NE
	PKHBT_CS
	PKHBT_CC
	PKHBT_MI
	PKHBT_PL
	PKHBT_VS
	PKHBT_VC
	PKHBT_HI
	PKHBT_LS
	PKHBT_GE
	PKHBT_LT
	PKHBT_GT
	PKHBT_LE
	PKHBT
	PKHBT_ZZ
	PKHTB_EQ
	PKHTB_NE
	PKHTB_CS
	PKHTB_CC
	PKHTB_MI
	PKHTB_PL
	PKHTB_VS
	PKHTB_VC
	PKHTB_HI
	PKHTB_LS
	PKHTB_GE
	PKHTB_LT
	PKHTB_GT
	PKHTB_LE
	PKHTB
	PKHTB_ZZ
	PLD_W
	PLD
	PLI
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	POP_EQ
	POP_NE
	POP_CS
	POP_CC
	POP_MI
	POP_PL
	POP_VS
	POP_VC
	POP_HI
	POP_LS
	POP_GE
	POP_LT
	POP_GT
	POP_LE
	POP
	POP_ZZ
	PUSH_EQ
	PUSH_NE
	PUSH_CS
	PUSH_CC
	PUSH_MI
	PUSH_PL
	PUSH_VS
	PUSH_VC
	PUSH_HI
	PUSH_LS
	PUSH_GE
	PUSH_LT
	PUSH_GT
	PUSH_LE
	PUSH
	PUSH_ZZ
	QADD_EQ
	QADD_NE
	QADD_CS
	QADD_CC
	QADD_MI
	QADD_PL
	QADD_VS
	QADD_VC
	QADD_HI
	QADD_LS
	QADD_GE
	QADD_LT
	QADD_GT
	QADD_LE
	QADD
	QADD_ZZ
	QADD16_EQ
	QADD16_NE
	QADD16_CS
	QADD16_CC
	QADD16_MI
	QADD16_PL
	QADD16_VS
	QADD16_VC
	QADD16_HI
	QADD16_LS
	QADD16_GE
	QADD16_LT
	QADD16_GT
	QADD16_LE
	QADD16
	QADD16_ZZ
	QADD8_EQ
	QADD8_NE
	QADD8_CS
	QADD8_CC
	QADD8_MI
	QADD8_PL
	QADD8_VS
	QADD8_VC
	QADD8_HI
	QADD8_LS
	QADD8_GE
	QADD8_LT
	QADD8_GT
	QADD8_LE
	QADD8
	QADD8_ZZ
	QASX_EQ
	QASX_NE
	QASX_CS
	QASX_CC
	QASX_MI
	QASX_PL
	QASX_VS
	QASX_VC
	QASX_HI
	QASX_LS
	QASX_GE
	QASX_LT
	QASX_GT
	QASX_LE
	QASX
	QASX_ZZ
	QDADD_EQ
	QDADD_NE
	QDADD_CS
	QDADD_CC
	QDADD_MI
	QDADD_PL
	QDADD_VS
	QDADD_VC
	QDADD_HI
	QDADD_LS
	QDADD_GE
	QDADD_LT
	QDADD_GT
	QDADD_LE
	QDADD
	QDADD_ZZ
	QDSUB_EQ
	QDSUB_NE
	QDSUB_CS
	QDSUB_CC
	QDSUB_MI
	QDSUB_PL
	QDSUB_VS
	QDSUB_VC
	QDSUB_HI
	QDSUB_LS
	QDSUB_GE
	QDSUB_LT
	QDSUB_GT
	QDSUB_LE
	QDSUB
	QDSUB_ZZ
	QSAX_EQ
	QSAX_NE
	QSAX_CS
	QSAX_CC
	QSAX_MI
	QSAX_PL
	QSAX_VS
	QSAX_VC
	QSAX_HI
	QSAX_LS
	QSAX_GE
	QSAX_LT
	QSAX_GT
	QSAX_LE
	QSAX
	QSAX_ZZ
	QSUB_EQ
	QSUB_NE
	QSUB_CS
	QSUB_CC
	QSUB_MI
	QSUB_PL
	QSUB_VS
	QSUB_VC
	QSUB_HI
	QSUB_LS
	QSUB_GE
	QSUB_LT
	QSUB_GT
	QSUB_LE
	QSUB
	QSUB_ZZ
	QSUB16_EQ
	QSUB16_NE
	QSUB16_CS
	QSUB16_CC
	QSUB16_MI
	QSUB16_PL
	QSUB16_VS
	QSUB16_VC
	QSUB16_HI
	QSUB16_LS
	QSUB16_GE
	QSUB16_LT
	QSUB16_GT
	QSUB16_LE
	QSUB16
	QSUB16_ZZ
	QSUB8_EQ
	QSUB8_NE
	QSUB8_CS
	QSUB8_CC
	QSUB8_MI
	QSUB8_PL
	QSUB8_VS
	QSUB8_VC
	QSUB8_HI
	QSUB8_LS
	QSUB8_GE
	QSUB8_LT
	QSUB8_GT
	QSUB8_LE
	QSUB8
	QSUB8_ZZ
	RBIT_EQ
	RBIT_NE
	RBIT_CS
	RBIT_CC
	RBIT_MI
	RBIT_PL
	RBIT_VS
	RBIT_VC
	RBIT_HI
	RBIT_LS
	RBIT_GE
	RBIT_LT
	RBIT_GT
	RBIT_LE
	RBIT
	RBIT_ZZ
	REV_EQ
	REV_NE
	REV_CS
	REV_CC
	REV_MI
	REV_PL
	REV_VS
	REV_VC
	REV_HI
	REV_LS
	REV_GE
	REV_LT
	REV_GT
	REV_LE
	REV
	REV_ZZ
	REV16_EQ
	REV16_NE
	REV16_CS
	REV16_CC
	REV16_MI
	REV16_PL
	REV16_VS
	REV16_VC
	REV16_HI
	REV16_LS
	REV16_GE
	REV16_LT
	REV16_GT
	REV16_LE
	REV16
	REV16_ZZ
	REVSH_EQ
	REVSH_NE
	REVSH_CS
	REVSH_CC
	REVSH_MI
	REVSH_PL
	REVSH_VS
	REVSH_VC
	REVSH_HI
	REVSH_LS
	REVSH_GE
	REVSH_LT
	REVSH_GT
	REVSH_LE
	REVSH
	REVSH_ZZ
	ROR_EQ
	ROR_NE
	ROR_CS
	ROR_CC
	ROR_MI
	ROR_PL
	ROR_VS
	ROR_VC
	ROR_HI
	ROR_LS
	ROR_GE
	ROR_LT
	ROR_GT
	ROR_LE
	ROR
	ROR_ZZ
	ROR_S_EQ
	ROR_S_NE
	ROR_S_CS
	ROR_S_CC
	ROR_S_MI
	ROR_S_PL
	ROR_S_VS
	ROR_S_VC
	ROR_S_HI
	ROR_S_LS
	ROR_S_GE
	ROR_S_LT
	ROR_S_GT
	ROR_S_LE
	ROR_S
	ROR_S_ZZ
	RRX_EQ
	RRX_NE
	RRX_CS
	RRX_CC
	RRX_MI
	RRX_PL
	RRX_VS
	RRX_VC
	RRX_HI
	RRX_LS
	RRX_GE
	RRX_LT
	RRX_GT
	RRX_LE
	RRX
	RRX_ZZ
	RRX_S_EQ
	RRX_S_NE
	RRX_S_CS
	RRX_S_CC
	RRX_S_MI
	RRX_S_PL
	RRX_S_VS
	RRX_S_VC
	RRX_S_HI
	RRX_S_LS
	RRX_S_GE
	RRX_S_LT
	RRX_S_GT
	RRX_S_LE
	RRX_S
	RRX_S_ZZ
	RSB_EQ
	RSB_NE
	RSB_CS
	RSB_CC
	RSB_MI
	RSB_PL
	RSB_VS
	RSB_VC
	RSB_HI
	RSB_LS
	RSB_GE
	RSB_LT
	RSB_GT
	RSB_LE
	RSB
	RSB_ZZ
	RSB_S_EQ
	RSB_S_NE
	RSB_S_CS
	RSB_S_CC
	RSB_S_MI
	RSB_S_PL
	RSB_S_VS
	RSB_S_VC
	RSB_S_HI
	RSB_S_LS
	RSB_S_GE
	RSB_S_LT
	RSB_S_GT
	RSB_S_LE
	RSB_S
	RSB_S_ZZ
	RSC_EQ
	RSC_NE
	RSC_CS
	RSC_CC
	RSC_MI
	RSC_PL
	RSC_VS
	RSC_VC
	RSC_HI
	RSC_LS
	RSC_GE
	RSC_LT
	RSC_GT
	RSC_LE
	RSC
	RSC_ZZ
	RSC_S_EQ
	RSC_S_NE
	RSC_S_CS
	RSC_S_CC
	RSC_S_MI
	RSC_S_PL
	RSC_S_VS
	RSC_S_VC
	RSC_S_HI
	RSC_S_LS
	RSC_S_GE
	RSC_S_LT
	RSC_S_GT
	RSC_S_LE
	RSC_S
	RSC_S_ZZ
	SADD16_EQ
	SADD16_NE
	SADD16_CS
	SADD16_CC
	SADD16_MI
	SADD16_PL
	SADD16_VS
	SADD16_VC
	SADD16_HI
	SADD16_LS
	SADD16_GE
	SADD16_LT
	SADD16_GT
	SADD16_LE
	SADD16
	SADD16_ZZ
	SADD8_EQ
	SADD8_NE
	SADD8_CS
	SADD8_CC
	SADD8_MI
	SADD8_PL
	SADD8_VS
	SADD8_VC
	SADD8_HI
	SADD8_LS
	SADD8_GE
	SADD8_LT
	SADD8_GT
	SADD8_LE
	SADD8
	SADD8_ZZ
	SASX_EQ
	SASX_NE
	SASX_CS
	SASX_CC
	SASX_MI
	SASX_PL
	SASX_VS
	SASX_VC
	SASX_HI
	SASX_LS
	SASX_GE
	SASX_LT
	SASX_GT
	SASX_LE
	SASX
	SASX_ZZ
	SBC_EQ
	SBC_NE
	SBC_CS
	SBC_CC
	SBC_MI
	SBC_PL
	SBC_VS
	SBC_VC
	SBC_HI
	SBC_LS
	SBC_GE
	SBC_LT
	SBC_GT
	SBC_LE
	SBC
	SBC_ZZ
	SBC_S_EQ
	SBC_S_NE
	SBC_S_CS
	SBC_S_CC
	SBC_S_MI
	SBC_S_PL
	SBC_S_VS
	SBC_S_VC
	SBC_S_HI
	SBC_S_LS
	SBC_S_GE
	SBC_S_LT
	SBC_S_GT
	SBC_S_LE
	SBC_S
	SBC_S_ZZ
	SBFX_EQ
	SBFX_NE
	SBFX_CS
	SBFX_CC
	SBFX_MI
	SBFX_PL
	SBFX_VS
	SBFX_VC
	SBFX_HI
	SBFX_LS
	SBFX_GE
	SBFX_LT
	SBFX_GT
	SBFX_LE
	SBFX
	SBFX_ZZ
	SEL_EQ
	SEL_NE
	SEL_CS
	SEL_CC
	SEL_MI
	SEL_PL
	SEL_VS
	SEL_VC
	SEL_HI
	SEL_LS
	SEL_GE
	SEL_LT
	SEL_GT
	SEL_LE
	SEL
	SEL_ZZ
	SETEND
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	SEV_EQ
	SEV_NE
	SEV_CS
	SEV_CC
	SEV_MI
	SEV_PL
	SEV_VS
	SEV_VC
	SEV_HI
	SEV_LS
	SEV_GE
	SEV_LT
	SEV_GT
	SEV_LE
	SEV
	SEV_ZZ
	SHADD16_EQ
	SHADD16_NE
	SHADD16_CS
	SHADD16_CC
	SHADD16_MI
	SHADD16_PL
	SHADD16_VS
	SHADD16_VC
	SHADD16_HI
	SHADD16_LS
	SHADD16_GE
	SHADD16_LT
	SHADD16_GT
	SHADD16_LE
	SHADD16
	SHADD16_ZZ
	SHADD8_EQ
	SHADD8_NE
	SHADD8_CS
	SHADD8_CC
	SHADD8_MI
	SHADD8_PL
	SHADD8_VS
	SHADD8_VC
	SHADD8_HI
	SHADD8_LS
	SHADD8_GE
	SHADD8_LT
	SHADD8_GT
	SHADD8_LE
	SHADD8
	SHADD8_ZZ
	SHASX_EQ
	SHASX_NE
	SHASX_CS
	SHASX_CC
	SHASX_MI
	SHASX_PL
	SHASX_VS
	SHASX_VC
	SHASX_HI
	SHASX_LS
	SHASX_GE
	SHASX_LT
	SHASX_GT
	SHASX_LE
	SHASX
	SHASX_ZZ
	SHSAX_EQ
	SHSAX_NE
	SHSAX_CS
	SHSAX_CC
	SHSAX_MI
	SHSAX_PL
	SHSAX_VS
	SHSAX_VC
	SHSAX_HI
	SHSAX_LS
	SHSAX_GE
	SHSAX_LT
	SHSAX_GT
	SHSAX_LE
	SHSAX
	SHSAX_ZZ
	SHSUB16_EQ
	SHSUB16_NE
	SHSUB16_CS
	SHSUB16_CC
	SHSUB16_MI
	SHSUB16_PL
	SHSUB16_VS
	SHSUB16_VC
	SHSUB16_HI
	SHSUB16_LS
	SHSUB16_GE
	SHSUB16_LT
	SHSUB16_GT
	SHSUB16_LE
	SHSUB16
	SHSUB16_ZZ
	SHSUB8_EQ
	SHSUB8_NE
	SHSUB8_CS
	SHSUB8_CC
	SHSUB8_MI
	SHSUB8_PL
	SHSUB8_VS
	SHSUB8_VC
	SHSUB8_HI
	SHSUB8_LS
	SHSUB8_GE
	SHSUB8_LT
	SHSUB8_GT
	SHSUB8_LE
	SHSUB8
	SHSUB8_ZZ
	SMLABB_EQ
	SMLABB_NE
	SMLABB_CS
	SMLABB_CC
	SMLABB_MI
	SMLABB_PL
	SMLABB_VS
	SMLABB_VC
	SMLABB_HI
	SMLABB_LS
	SMLABB_GE
	SMLABB_LT
	SMLABB_GT
	SMLABB_LE
	SMLABB
	SMLABB_ZZ
	SMLABT_EQ
	SMLABT_NE
	SMLABT_CS
	SMLABT_CC
	SMLABT_MI
	SMLABT_PL
	SMLABT_VS
	SMLABT_VC
	SMLABT_HI
	SMLABT_LS
	SMLABT_GE
	SMLABT_LT
	SMLABT_GT
	SMLABT_LE
	SMLABT
	SMLABT_ZZ
	SMLATB_EQ
	SMLATB_NE
	SMLATB_CS
	SMLATB_CC
	SMLATB_MI
	SMLATB_PL
	SMLATB_VS
	SMLATB_VC
	SMLATB_HI
	SMLATB_LS
	SMLATB_GE
	SMLATB_LT
	SMLATB_GT
	SMLATB_LE
	SMLATB
	SMLATB_ZZ
	SMLATT_EQ
	SMLATT_NE
	SMLATT_CS
	SMLATT_CC
	SMLATT_MI
	SMLATT_PL
	SMLATT_VS
	SMLATT_VC
	SMLATT_HI
	SMLATT_LS
	SMLATT_GE
	SMLATT_LT
	SMLATT_GT
	SMLATT_LE
	SMLATT
	SMLATT_ZZ
	SMLAD_EQ
	SMLAD_NE
	SMLAD_CS
	SMLAD_CC
	SMLAD_MI
	SMLAD_PL
	SMLAD_VS
	SMLAD_VC
	SMLAD_HI
	SMLAD_LS
	SMLAD_GE
	SMLAD_LT
	SMLAD_GT
	SMLAD_LE
	SMLAD
	SMLAD_ZZ
	SMLAD_X_EQ
	SMLAD_X_NE
	SMLAD_X_CS
	SMLAD_X_CC
	SMLAD_X_MI
	SMLAD_X_PL
	SMLAD_X_VS
	SMLAD_X_VC
	SMLAD_X_HI
	SMLAD_X_LS
	SMLAD_X_GE
	SMLAD_X_LT
	SMLAD_X_GT
	SMLAD_X_LE
	SMLAD_X
	SMLAD_X_ZZ
	SMLAL_EQ
	SMLAL_NE
	SMLAL_CS
	SMLAL_CC
	SMLAL_MI
	SMLAL_PL
	SMLAL_VS
	SMLAL_VC
	SMLAL_HI
	SMLAL_LS
	SMLAL_GE
	SMLAL_LT
	SMLAL_GT
	SMLAL_LE
	SMLAL
	SMLAL_ZZ
	SMLAL_S_EQ
	SMLAL_S_NE
	SMLAL_S_CS
	SMLAL_S_CC
	SMLAL_S_MI
	SMLAL_S_PL
	SMLAL_S_VS
	SMLAL_S_VC
	SMLAL_S_HI
	SMLAL_S_LS
	SMLAL_S_GE
	SMLAL_S_LT
	SMLAL_S_GT
	SMLAL_S_LE
	SMLAL_S
	SMLAL_S_ZZ
	SMLALBB_EQ
	SMLALBB_NE
	SMLALBB_CS
	SMLALBB_CC
	SMLALBB_MI
	SMLALBB_PL
	SMLALBB_VS
	SMLALBB_VC
	SMLALBB_HI
	SMLALBB_LS
	SMLALBB_GE
	SMLALBB_LT
	SMLALBB_GT
	SMLALBB_LE
	SMLALBB
	SMLALBB_ZZ
	SMLALBT_EQ
	SMLALBT_NE
	SMLALBT_CS
	SMLALBT_CC
	SMLALBT_MI
	SMLALBT_PL
	SMLALBT_VS
	SMLALBT_VC
	SMLALBT_HI
	SMLALBT_LS
	SMLALBT_GE
	SMLALBT_LT
	SMLALBT_GT
	SMLALBT_LE
	SMLALBT
	SMLALBT_ZZ
	SMLALTB_EQ
	SMLALTB_NE
	SMLALTB_CS
	SMLALTB_CC
	SMLALTB_MI
	SMLALTB_PL
	SMLALTB_VS
	SMLALTB_VC
	SMLALTB_HI
	SMLALTB_LS
	SMLALTB_GE
	SMLALTB_LT
	SMLALTB_GT
	SMLALTB_LE
	SMLALTB
	SMLALTB_ZZ
	SMLALTT_EQ
	SMLALTT_NE
	SMLALTT_CS
	SMLALTT_CC
	SMLALTT_MI
	SMLALTT_PL
	SMLALTT_VS
	SMLALTT_VC
	SMLALTT_HI
	SMLALTT_LS
	SMLALTT_GE
	SMLALTT_LT
	SMLALTT_GT
	SMLALTT_LE
	SMLALTT
	SMLALTT_ZZ
	SMLALD_EQ
	SMLALD_NE
	SMLALD_CS
	SMLALD_CC
	SMLALD_MI
	SMLALD_PL
	SMLALD_VS
	SMLALD_VC
	SMLALD_HI
	SMLALD_LS
	SMLALD_GE
	SMLALD_LT
	SMLALD_GT
	SMLALD_LE
	SMLALD
	SMLALD_ZZ
	SMLALD_X_EQ
	SMLALD_X_NE
	SMLALD_X_CS
	SMLALD_X_CC
	SMLALD_X_MI
	SMLALD_X_PL
	SMLALD_X_VS
	SMLALD_X_VC
	SMLALD_X_HI
	SMLALD_X_LS
	SMLALD_X_GE
	SMLALD_X_LT
	SMLALD_X_GT
	SMLALD_X_LE
	SMLALD_X
	SMLALD_X_ZZ
	SMLAWB_EQ
	SMLAWB_NE
	SMLAWB_CS
	SMLAWB_CC
	SMLAWB_MI
	SMLAWB_PL
	SMLAWB_VS
	SMLAWB_VC
	SMLAWB_HI
	SMLAWB_LS
	SMLAWB_GE
	SMLAWB_LT
	SMLAWB_GT
	SMLAWB_LE
	SMLAWB
	SMLAWB_ZZ
	SMLAWT_EQ
	SMLAWT_NE
	SMLAWT_CS
	SMLAWT_CC
	SMLAWT_MI
	SMLAWT_PL
	SMLAWT_VS
	SMLAWT_VC
	SMLAWT_HI
	SMLAWT_LS
	SMLAWT_GE
	SMLAWT_LT
	SMLAWT_GT
	SMLAWT_LE
	SMLAWT
	SMLAWT_ZZ
	SMLSD_EQ
	SMLSD_NE
	SMLSD_CS
	SMLSD_CC
	SMLSD_MI
	SMLSD_PL
	SMLSD_VS
	SMLSD_VC
	SMLSD_HI
	SMLSD_LS
	SMLSD_GE
	SMLSD_LT
	SMLSD_GT
	SMLSD_LE
	SMLSD
	SMLSD_ZZ
	SMLSD_X_EQ
	SMLSD_X_NE
	SMLSD_X_CS
	SMLSD_X_CC
	SMLSD_X_MI
	SMLSD_X_PL
	SMLSD_X_VS
	SMLSD_X_VC
	SMLSD_X_HI
	SMLSD_X_LS
	SMLSD_X_GE
	SMLSD_X_LT
	SMLSD_X_GT
	SMLSD_X_LE
	SMLSD_X
	SMLSD_X_ZZ
	SMLSLD_EQ
	SMLSLD_NE
	SMLSLD_CS
	SMLSLD_CC
	SMLSLD_MI
	SMLSLD_PL
	SMLSLD_VS
	SMLSLD_VC
	SMLSLD_HI
	SMLSLD_LS
	SMLSLD_GE
	SMLSLD_LT
	SMLSLD_GT
	SMLSLD_LE
	SMLSLD
	SMLSLD_ZZ
	SMLSLD_X_EQ
	SMLSLD_X_NE
	SMLSLD_X_CS
	SMLSLD_X_CC
	SMLSLD_X_MI
	SMLSLD_X_PL
	SMLSLD_X_VS
	SMLSLD_X_VC
	SMLSLD_X_HI
	SMLSLD_X_LS
	SMLSLD_X_GE
	SMLSLD_X_LT
	SMLSLD_X_GT
	SMLSLD_X_LE
	SMLSLD_X
	SMLSLD_X_ZZ
	SMMLA_EQ
	SMMLA_NE
	SMMLA_CS
	SMMLA_CC
	SMMLA_MI
	SMMLA_PL
	SMMLA_VS
	SMMLA_VC
	SMMLA_HI
	SMMLA_LS
	SMMLA_GE
	SMMLA_LT
	SMMLA_GT
	SMMLA_LE
	SMMLA
	SMMLA_ZZ
	SMMLA_R_EQ
	SMMLA_R_NE
	SMMLA_R_CS
	SMMLA_R_CC
	SMMLA_R_MI
	SMMLA_R_PL
	SMMLA_R_VS
	SMMLA_R_VC
	SMMLA_R_HI
	SMMLA_R_LS
	SMMLA_R_GE
	SMMLA_R_LT
	SMMLA_R_GT
	SMMLA_R_LE
	SMMLA_R
	SMMLA_R_ZZ
	SMMLS_EQ
	SMMLS_NE
	SMMLS_CS
	SMMLS_CC
	SMMLS_MI
	SMMLS_PL
	SMMLS_VS
	SMMLS_VC
	SMMLS_HI
	SMMLS_LS
	SMMLS_GE
	SMMLS_LT
	SMMLS_GT
	SMMLS_LE
	SMMLS
	SMMLS_ZZ
	SMMLS_R_EQ
	SMMLS_R_NE
	SMMLS_R_CS
	SMMLS_R_CC
	SMMLS_R_MI
	SMMLS_R_PL
	SMMLS_R_VS
	SMMLS_R_VC
	SMMLS_R_HI
	SMMLS_R_LS
	SMMLS_R_GE
	SMMLS_R_LT
	SMMLS_R_GT
	SMMLS_R_LE
	SMMLS_R
	SMMLS_R_ZZ
	SMMUL_EQ
	SMMUL_NE
	SMMUL_CS
	SMMUL_CC
	SMMUL_MI
	SMMUL_PL
	SMMUL_VS
	SMMUL_VC
	SMMUL_HI
	SMMUL_LS
	SMMUL_GE
	SMMUL_LT
	SMMUL_GT
	SMMUL_LE
	SMMUL
	SMMUL_ZZ
	SMMUL_R_EQ
	SMMUL_R_NE
	SMMUL_R_CS
	SMMUL_R_CC
	SMMUL_R_MI
	SMMUL_R_PL
	SMMUL_R_VS
	SMMUL_R_VC
	SMMUL_R_HI
	SMMUL_R_LS
	SMMUL_R_GE
	SMMUL_R_LT
	SMMUL_R_GT
	SMMUL_R_LE
	SMMUL_R
	SMMUL_R_ZZ
	SMUAD_EQ
	SMUAD_NE
	SMUAD_CS
	SMUAD_CC
	SMUAD_MI
	SMUAD_PL
	SMUAD_VS
	SMUAD_VC
	SMUAD_HI
	SMUAD_LS
	SMUAD_GE
	SMUAD_LT
	SMUAD_GT
	SMUAD_LE
	SMUAD
	SMUAD_ZZ
	SMUAD_X_EQ
	SMUAD_X_NE
	SMUAD_X_CS
	SMUAD_X_CC
	SMUAD_X_MI
	SMUAD_X_PL
	SMUAD_X_VS
	SMUAD_X_VC
	SMUAD_X_HI
	SMUAD_X_LS
	SMUAD_X_GE
	SMUAD_X_LT
	SMUAD_X_GT
	SMUAD_X_LE
	SMUAD_X
	SMUAD_X_ZZ
	SMULBB_EQ
	SMULBB_NE
	SMULBB_CS
	SMULBB_CC
	SMULBB_MI
	SMULBB_PL
	SMULBB_VS
	SMULBB_VC
	SMULBB_HI
	SMULBB_LS
	SMULBB_GE
	SMULBB_LT
	SMULBB_GT
	SMULBB_LE
	SMULBB
	SMULBB_ZZ
	SMULBT_EQ
	SMULBT_NE
	SMULBT_CS
	SMULBT_CC
	SMULBT_MI
	SMULBT_PL
	SMULBT_VS
	SMULBT_VC
	SMULBT_HI
	SMULBT_LS
	SMULBT_GE
	SMULBT_LT
	SMULBT_GT
	SMULBT_LE
	SMULBT
	SMULBT_ZZ
	SMULTB_EQ
	SMULTB_NE
	SMULTB_CS
	SMULTB_CC
	SMULTB_MI
	SMULTB_PL
	SMULTB_VS
	SMULTB_VC
	SMULTB_HI
	SMULTB_LS
	SMULTB_GE
	SMULTB_LT
	SMULTB_GT
	SMULTB_LE
	SMULTB
	SMULTB_ZZ
	SMULTT_EQ
	SMULTT_NE
	SMULTT_CS
	SMULTT_CC
	SMULTT_MI
	SMULTT_PL
	SMULTT_VS
	SMULTT_VC
	SMULTT_HI
	SMULTT_LS
	SMULTT_GE
	SMULTT_LT
	SMULTT_GT
	SMULTT_LE
	SMULTT
	SMULTT_ZZ
	SMULL_EQ
	SMULL_NE
	SMULL_CS
	SMULL_CC
	SMULL_MI
	SMULL_PL
	SMULL_VS
	SMULL_VC
	SMULL_HI
	SMULL_LS
	SMULL_GE
	SMULL_LT
	SMULL_GT
	SMULL_LE
	SMULL
	SMULL_ZZ
	SMULL_S_EQ
	SMULL_S_NE
	SMULL_S_CS
	SMULL_S_CC
	SMULL_S_MI
	SMULL_S_PL
	SMULL_S_VS
	SMULL_S_VC
	SMULL_S_HI
	SMULL_S_LS
	SMULL_S_GE
	SMULL_S_LT
	SMULL_S_GT
	SMULL_S_LE
	SMULL_S
	SMULL_S_ZZ
	SMULWB_EQ
	SMULWB_NE
	SMULWB_CS
	SMULWB_CC
	SMULWB_MI
	SMULWB_PL
	SMULWB_VS
	SMULWB_VC
	SMULWB_HI
	SMULWB_LS
	SMULWB_GE
	SMULWB_LT
	SMULWB_GT
	SMULWB_LE
	SMULWB
	SMULWB_ZZ
	SMULWT_EQ
	SMULWT_NE
	SMULWT_CS
	SMULWT_CC
	SMULWT_MI
	SMULWT_PL
	SMULWT_VS
	SMULWT_VC
	SMULWT_HI
	SMULWT_LS
	SMULWT_GE
	SMULWT_LT
	SMULWT_GT
	SMULWT_LE
	SMULWT
	SMULWT_ZZ
	SMUSD_EQ
	SMUSD_NE
	SMUSD_CS
	SMUSD_CC
	SMUSD_MI
	SMUSD_PL
	SMUSD_VS
	SMUSD_VC
	SMUSD_HI
	SMUSD_LS
	SMUSD_GE
	SMUSD_LT
	SMUSD_GT
	SMUSD_LE
	SMUSD
	SMUSD_ZZ
	SMUSD_X_EQ
	SMUSD_X_NE
	SMUSD_X_CS
	SMUSD_X_CC
	SMUSD_X_MI
	SMUSD_X_PL
	SMUSD_X_VS
	SMUSD_X_VC
	SMUSD_X_HI
	SMUSD_X_LS
	SMUSD_X_GE
	SMUSD_X_LT
	SMUSD_X_GT
	SMUSD_X_LE
	SMUSD_X
	SMUSD_X_ZZ
	SSAT_EQ
	SSAT_NE
	SSAT_CS
	SSAT_CC
	SSAT_MI
	SSAT_PL
	SSAT_VS
	SSAT_VC
	SSAT_HI
	SSAT_LS
	SSAT_GE
	SSAT_LT
	SSAT_GT
	SSAT_LE
	SSAT
	SSAT_ZZ
	SSAT16_EQ
	SSAT16_NE
	SSAT16_CS
	SSAT16_CC
	SSAT16_MI
	SSAT16_PL
	SSAT16_VS
	SSAT16_VC
	SSAT16_HI
	SSAT16_LS
	SSAT16_GE
	SSAT16_LT
	SSAT16_GT
	SSAT16_LE
	SSAT16
	SSAT16_ZZ
	SSAX_EQ
	SSAX_NE
	SSAX_CS
	SSAX_CC
	SSAX_MI
	SSAX_PL
	SSAX_VS
	SSAX_VC
	SSAX_HI
	SSAX_LS
	SSAX_GE
	SSAX_LT
	SSAX_GT
	SSAX_LE
	SSAX
	SSAX_ZZ
	SSUB16_EQ
	SSUB16_NE
	SSUB16_CS
	SSUB16_CC
	SSUB16_MI
	SSUB16_PL
	SSUB16_VS
	SSUB16_VC
	SSUB16_HI
	SSUB16_LS
	SSUB16_GE
	SSUB16_LT
	SSUB16_GT
	SSUB16_LE
	SSUB16
	SSUB16_ZZ
	SSUB8_EQ
	SSUB8_NE
	SSUB8_CS
	SSUB8_CC
	SSUB8_MI
	SSUB8_PL
	SSUB8_VS
	SSUB8_VC
	SSUB8_HI
	SSUB8_LS
	SSUB8_GE
	SSUB8_LT
	SSUB8_GT
	SSUB8_LE
	SSUB8
	SSUB8_ZZ
	STM_EQ
	STM_NE
	STM_CS
	STM_CC
	STM_MI
	STM_PL
	STM_VS
	STM_VC
	STM_HI
	STM_LS
	STM_GE
	STM_LT
	STM_GT
	STM_LE
	STM
	STM_ZZ
	STMDA_EQ
	STMDA_NE
	STMDA_CS
	STMDA_CC
	STMDA_MI
	STMDA_PL
	STMDA_VS
	STMDA_VC
	STMDA_HI
	STMDA_LS
	STMDA_GE
	STMDA_LT
	STMDA_GT
	STMDA_LE
	STMDA
	STMDA_ZZ
	STMDB_EQ
	STMDB_NE
	STMDB_CS
	STMDB_CC
	STMDB_MI
	STMDB_PL
	STMDB_VS
	STMDB_VC
	STMDB_HI
	STMDB_LS
	STMDB_GE
	STMDB_LT
	STMDB_GT
	STMDB_LE
	STMDB
	STMDB_ZZ
	STMIB_EQ
	STMIB_NE
	STMIB_CS
	STMIB_CC
	STMIB_MI
	STMIB_PL
	STMIB_VS
	STMIB_VC
	STMIB_HI
	STMIB_LS
	STMIB_GE
	STMIB_LT
	STMIB_GT
	STMIB_LE
	STMIB
	STMIB_ZZ
	STR_EQ
	STR_NE
	STR_CS
	STR_CC
	STR_MI
	STR_PL
	STR_VS
	STR_VC
	STR_HI
	STR_LS
	STR_GE
	STR_LT
	STR_GT
	STR_LE
	STR
	STR_ZZ
	STRB_EQ
	STRB_NE
	STRB_CS
	STRB_CC
	STRB_MI
	STRB_PL
	STRB_VS
	STRB_VC
	STRB_HI
	STRB_LS
	STRB_GE
	STRB_LT
	STRB_GT
	STRB_LE
	STRB
	STRB_ZZ
	STRBT_EQ
	STRBT_NE
	STRBT_CS
	STRBT_CC
	STRBT_MI
	STRBT_PL
	STRBT_VS
	STRBT_VC
	STRBT_HI
	STRBT_LS
	STRBT_GE
	STRBT_LT
	STRBT_GT
	STRBT_LE
	STRBT
	STRBT_ZZ
	STRD_EQ
	STRD_NE
	STRD_CS
	STRD_CC
	STRD_MI
	STRD_PL
	STRD_VS
	STRD_VC
	STRD_HI
	STRD_LS
	STRD_GE
	STRD_LT
	STRD_GT
	STRD_LE
	STRD
	STRD_ZZ
	STREX_EQ
	STREX_NE
	STREX_CS
	STREX_CC
	STREX_MI
	STREX_PL
	STREX_VS
	STREX_VC
	STREX_HI
	STREX_LS
	STREX_GE
	STREX_LT
	STREX_GT
	STREX_LE
	STREX
	STREX_ZZ
	STREXB_EQ
	STREXB_NE
	STREXB_CS
	STREXB_CC
	STREXB_MI
	STREXB_PL
	STREXB_VS
	STREXB_VC
	STREXB_HI
	STREXB_LS
	STREXB_GE
	STREXB_LT
	STREXB_GT
	STREXB_LE
	STREXB
	STREXB_ZZ
	STREXD_EQ
	STREXD_NE
	STREXD_CS
	STREXD_CC
	STREXD_MI
	STREXD_PL
	STREXD_VS
	STREXD_VC
	STREXD_HI
	STREXD_LS
	STREXD_GE
	STREXD_LT
	STREXD_GT
	STREXD_LE
	STREXD
	STREXD_ZZ
	STREXH_EQ
	STREXH_NE
	STREXH_CS
	STREXH_CC
	STREXH_MI
	STREXH_PL
	STREXH_VS
	STREXH_VC
	STREXH_HI
	STREXH_LS
	STREXH_GE
	STREXH_LT
	STREXH_GT
	STREXH_LE
	STREXH
	STREXH_ZZ
	STRH_EQ
	STRH_NE
	STRH_CS
	STRH_CC
	STRH_MI
	STRH_PL
	STRH_VS
	STRH_VC
	STRH_HI
	STRH_LS
	STRH_GE
	STRH_LT
	STRH_GT
	STRH_LE
	STRH
	STRH_ZZ
	STRHT_EQ
	STRHT_NE
	STRHT_CS
	STRHT_CC
	STRHT_MI
	STRHT_PL
	STRHT_VS
	STRHT_VC
	STRHT_HI
	STRHT_LS
	STRHT_GE
	STRHT_LT
	STRHT_GT
	STRHT_LE
	STRHT
	STRHT_ZZ
	STRT_EQ
	STRT_NE
	STRT_CS
	STRT_CC
	STRT_MI
	STRT_PL
	STRT_VS
	STRT_VC
	STRT_HI
	STRT_LS
	STRT_GE
	STRT_LT
	STRT_GT
	STRT_LE
	STRT
	STRT_ZZ
	SUB_EQ
	SUB_NE
	SUB_CS
	SUB_CC
	SUB_MI
	SUB_PL
	SUB_VS
	SUB_VC
	SUB_HI
	SUB_LS
	SUB_GE
	SUB_LT
	SUB_GT
	SUB_LE
	SUB
	SUB_ZZ
	SUB_S_EQ
	SUB_S_NE
	SUB_S_CS
	SUB_S_CC
	SUB_S_MI
	SUB_S_PL
	SUB_S_VS
	SUB_S_VC
	SUB_S_HI
	SUB_S_LS
	SUB_S_GE
	SUB_S_LT
	SUB_S_GT
	SUB_S_LE
	SUB_S
	SUB_S_ZZ
	SVC_EQ
	SVC_NE
	SVC_CS
	SVC_CC
	SVC_MI
	SVC_PL
	SVC_VS
	SVC_VC
	SVC_HI
	SVC_LS
	SVC_GE
	SVC_LT
	SVC_GT
	SVC_LE
	SVC
	SVC_ZZ
	SWP_EQ
	SWP_NE
	SWP_CS
	SWP_CC
	SWP_MI
	SWP_PL
	SWP_VS
	SWP_VC
	SWP_HI
	SWP_LS
	SWP_GE
	SWP_LT
	SWP_GT
	SWP_LE
	SWP
	SWP_ZZ
	SWP_B_EQ
	SWP_B_NE
	SWP_B_CS
	SWP_B_CC
	SWP_B_MI
	SWP_B_PL
	SWP_B_VS
	SWP_B_VC
	SWP_B_HI
	SWP_B_LS
	SWP_B_GE
	SWP_B_LT
	SWP_B_GT
	SWP_B_LE
	SWP_B
	SWP_B_ZZ
	SXTAB_EQ
	SXTAB_NE
	SXTAB_CS
	SXTAB_CC
	SXTAB_MI
	SXTAB_PL
	SXTAB_VS
	SXTAB_VC
	SXTAB_HI
	SXTAB_LS
	SXTAB_GE
	SXTAB_LT
	SXTAB_GT
	SXTAB_LE
	SXTAB
	SXTAB_ZZ
	SXTAB16_EQ
	SXTAB16_NE
	SXTAB16_CS
	SXTAB16_CC
	SXTAB16_MI
	SXTAB16_PL
	SXTAB16_VS
	SXTAB16_VC
	SXTAB16_HI
	SXTAB16_LS
	SXTAB16_GE
	SXTAB16_LT
	SXTAB16_GT
	SXTAB16_LE
	SXTAB16
	SXTAB16_ZZ
	SXTAH_EQ
	SXTAH_NE
	SXTAH_CS
	SXTAH_CC
	SXTAH_MI
	SXTAH_PL
	SXTAH_VS
	SXTAH_VC
	SXTAH_HI
	SXTAH_LS
	SXTAH_GE
	SXTAH_LT
	SXTAH_GT
	SXTAH_LE
	SXTAH
	SXTAH_ZZ
	SXTB_EQ
	SXTB_NE
	SXTB_CS
	SXTB_CC
	SXTB_MI
	SXTB_PL
	SXTB_VS
	SXTB_VC
	SXTB_HI
	SXTB_LS
	SXTB_GE
	SXTB_LT
	SXTB_GT
	SXTB_LE
	SXTB
	SXTB_ZZ
	SXTB16_EQ
	SXTB16_NE
	SXTB16_CS
	SXTB16_CC
	SXTB16_MI
	SXTB16_PL
	SXTB16_VS
	SXTB16_VC
	SXTB16_HI
	SXTB16_LS
	SXTB16_GE
	SXTB16_LT
	SXTB16_GT
	SXTB16_LE
	SXTB16
	SXTB16_ZZ
	SXTH_EQ
	SXTH_NE
	SXTH_CS
	SXTH_CC
	SXTH_MI
	SXTH_PL
	SXTH_VS
	SXTH_VC
	SXTH_HI
	SXTH_LS
	SXTH_GE
	SXTH_LT
	SXTH_GT
	SXTH_LE
	SXTH
	SXTH_ZZ
	TEQ_EQ
	TEQ_NE
	TEQ_CS
	TEQ_CC
	TEQ_MI
	TEQ_PL
	TEQ_VS
	TEQ_VC
	TEQ_HI
	TEQ_LS
	TEQ_GE
	TEQ_LT
	TEQ_GT
	TEQ_LE
	TEQ
	TEQ_ZZ
	TST_EQ
	TST_NE
	TST_CS
	TST_CC
	TST_MI
	TST_PL
	TST_VS
	TST_VC
	TST_HI
	TST_LS
	TST_GE
	TST_LT
	TST_GT
	TST_LE
	TST
	TST_ZZ
	UADD16_EQ
	UADD16_NE
	UADD16_CS
	UADD16_CC
	UADD16_MI
	UADD16_PL
	UADD16_VS
	UADD16_VC
	UADD16_HI
	UADD16_LS
	UADD16_GE
	UADD16_LT
	UADD16_GT
	UADD16_LE
	UADD16
	UADD16_ZZ
	UADD8_EQ
	UADD8_NE
	UADD8_CS
	UADD8_CC
	UADD8_MI
	UADD8_PL
	UADD8_VS
	UADD8_VC
	UADD8_HI
	UADD8_LS
	UADD8_GE
	UADD8_LT
	UADD8_GT
	UADD8_LE
	UADD8
	UADD8_ZZ
	UASX_EQ
	UASX_NE
	UASX_CS
	UASX_CC
	UASX_MI
	UASX_PL
	UASX_VS
	UASX_VC
	UASX_HI
	UASX_LS
	UASX_GE
	UASX_LT
	UASX_GT
	UASX_LE
	UASX
	UASX_ZZ
	UBFX_EQ
	UBFX_NE
	UBFX_CS
	UBFX_CC
	UBFX_MI
	UBFX_PL
	UBFX_VS
	UBFX_VC
	UBFX_HI
	UBFX_LS
	UBFX_GE
	UBFX_LT
	UBFX_GT
	UBFX_LE
	UBFX
	UBFX_ZZ
	UHADD16_EQ
	UHADD16_NE
	UHADD16_CS
	UHADD16_CC
	UHADD16_MI
	UHADD16_PL
	UHADD16_VS
	UHADD16_VC
	UHADD16_HI
	UHADD16_LS
	UHADD16_GE
	UHADD16_LT
	UHADD16_GT
	UHADD16_LE
	UHADD16
	UHADD16_ZZ
	UHADD8_EQ
	UHADD8_NE
	UHADD8_CS
	UHADD8_CC
	UHADD8_MI
	UHADD8_PL
	UHADD8_VS
	UHADD8_VC
	UHADD8_HI
	UHADD8_LS
	UHADD8_GE
	UHADD8_LT
	UHADD8_GT
	UHADD8_LE
	UHADD8
	UHADD8_ZZ
	UHASX_EQ
	UHASX_NE
	UHASX_CS
	UHASX_CC
	UHASX_MI
	UHASX_PL
	UHASX_VS
	UHASX_VC
	UHASX_HI
	UHASX_LS
	UHASX_GE
	UHASX_LT
	UHASX_GT
	UHASX_LE
	UHASX
	UHASX_ZZ
	UHSAX_EQ
	UHSAX_NE
	UHSAX_CS
	UHSAX_CC
	UHSAX_MI
	UHSAX_PL
	UHSAX_VS
	UHSAX_VC
	UHSAX_HI
	UHSAX_LS
	UHSAX_GE
	UHSAX_LT
	UHSAX_GT
	UHSAX_LE
	UHSAX
	UHSAX_ZZ
	UHSUB16_EQ
	UHSUB16_NE
	UHSUB16_CS
	UHSUB16_CC
	UHSUB16_MI
	UHSUB16_PL
	UHSUB16_VS
	UHSUB16_VC
	UHSUB16_HI
	UHSUB16_LS
	UHSUB16_GE
	UHSUB16_LT
	UHSUB16_GT
	UHSUB16_LE
	UHSUB16
	UHSUB16_ZZ
	UHSUB8_EQ
	UHSUB8_NE
	UHSUB8_CS
	UHSUB8_CC
	UHSUB8_MI
	UHSUB8_PL
	UHSUB8_VS
	UHSUB8_VC
	UHSUB8_HI
	UHSUB8_LS
	UHSUB8_GE
	UHSUB8_LT
	UHSUB8_GT
	UHSUB8_LE
	UHSUB8
	UHSUB8_ZZ
	UMAAL_EQ
	UMAAL_NE
	UMAAL_CS
	UMAAL_CC
	UMAAL_MI
	UMAAL_PL
	UMAAL_VS
	UMAAL_VC
	UMAAL_HI
	UMAAL_LS
	UMAAL_GE
	UMAAL_LT
	UMAAL_GT
	UMAAL_LE
	UMAAL
	UMAAL_ZZ
	UMLAL_EQ
	UMLAL_NE
	UMLAL_CS
	UMLAL_CC
	UMLAL_MI
	UMLAL_PL
	UMLAL_VS
	UMLAL_VC
	UMLAL_HI
	UMLAL_LS
	UMLAL_GE
	UMLAL_LT
	UMLAL_GT
	UMLAL_LE
	UMLAL
	UMLAL_ZZ
	UMLAL_S_EQ
	UMLAL_S_NE
	UMLAL_S_CS
	UMLAL_S_CC
	UMLAL_S_MI
	UMLAL_S_PL
	UMLAL_S_VS
	UMLAL_S_VC
	UMLAL_S_HI
	UMLAL_S_LS
	UMLAL_S_GE
	UMLAL_S_LT
	UMLAL_S_GT
	UMLAL_S_LE
	UMLAL_S
	UMLAL_S_ZZ
	UMULL_EQ
	UMULL_NE
	UMULL_CS
	UMULL_CC
	UMULL_MI
	UMULL_PL
	UMULL_VS
	UMULL_VC
	UMULL_HI
	UMULL_LS
	UMULL_GE
	UMULL_LT
	UMULL_GT
	UMULL_LE
	UMULL
	UMULL_ZZ
	UMULL_S_EQ
	UMULL_S_NE
	UMULL_S_CS
	UMULL_S_CC
	UMULL_S_MI
	UMULL_S_PL
	UMULL_S_VS
	UMULL_S_VC
	UMULL_S_HI
	UMULL_S_LS
	UMULL_S_GE
	UMULL_S_LT
	UMULL_S_GT
	UMULL_S_LE
	UMULL_S
	UMULL_S_ZZ
	UNDEF
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	_
	UQADD16_EQ
	UQADD16_NE
	UQADD16_CS
	UQADD16_CC
	UQADD16_MI
	UQADD16_PL
	UQADD16_VS
	UQADD16_VC
	UQADD16_HI
	UQADD16_LS
	UQADD16_GE
	UQADD16_LT
	UQADD16_GT
	UQADD16_LE
	UQADD16
	UQADD16_ZZ
	UQADD8_EQ
	UQADD8_NE
	UQADD8_CS
	UQADD8_CC
	UQADD8_MI
	UQADD8_PL
	UQADD8_VS
	UQADD8_VC
	UQADD8_HI
	UQADD8_LS
	UQADD8_GE
	UQADD8_LT
	UQADD8_GT
	UQADD8_LE
	UQADD8
	UQADD8_ZZ
	UQASX_EQ
	UQASX_NE
	UQASX_CS
	UQASX_CC
	UQASX_MI
	UQASX_PL
	UQASX_VS
	UQASX_VC
	UQASX_HI
	UQASX_LS
	UQASX_GE
	UQASX_LT
	UQASX_GT
	UQASX_LE
	UQASX
	UQASX_ZZ
	UQSAX_EQ
	UQSAX_NE
	UQSAX_CS
	UQSAX_CC
	UQSAX_MI
	UQSAX_PL
	UQSAX_VS
	UQSAX_VC
	UQSAX_HI
	UQSAX_LS
	UQSAX_GE
	UQSAX_LT
	UQSAX_GT
	UQSAX_LE
	UQSAX
	UQSAX_ZZ
	UQSUB16_EQ
	UQSUB16_NE
	UQSUB16_CS
	UQSUB16_CC
	UQSUB16_MI
	UQSUB16_PL
	UQSUB16_VS
	UQSUB16_VC
	UQSUB16_HI
	UQSUB16_LS
	UQSUB16_GE
	UQSUB16_LT
	UQSUB16_GT
	UQSUB16_LE
	UQSUB16
	UQSUB16_ZZ
	UQSUB8_EQ
	UQSUB8_NE
	UQSUB8_CS
	UQSUB8_CC
	UQSUB8_MI
	UQSUB8_PL
	UQSUB8_VS
	UQSUB8_VC
	UQSUB8_HI
	UQSUB8_LS
	UQSUB8_GE
	UQSUB8_LT
	UQSUB8_GT
	UQSUB8_LE
	UQSUB8
	UQSUB8_ZZ
	USAD8_EQ
	USAD8_NE
	USAD8_CS
	USAD8_CC
	USAD8_MI
	USAD8_PL
	USAD8_VS
	USAD8_VC
	USAD8_HI
	USAD8_LS
	USAD8_GE
	USAD8_LT
	USAD8_GT
	USAD8_LE
	USAD8
	USAD8_ZZ
	USADA8_EQ
	USADA8_NE
	USADA8_CS
	USADA8_CC
	USADA8_MI
	USADA8_PL
	USADA8_VS
	USADA8_VC
	USADA8_HI
	USADA8_LS
	USADA8_GE
	USADA8_LT
	USADA8_GT
	USADA8_LE
	USADA8
	USADA8_ZZ
	USAT_EQ
	USAT_NE
	USAT_CS
	USAT_CC
	USAT_MI
	USAT_PL
	USAT_VS
	USAT_VC
	USAT_HI
	USAT_LS
	USAT_GE
	USAT_LT
	USAT_GT
	USAT_LE
	USAT
	USAT_ZZ
	USAT16_EQ
	USAT16_NE
	USAT16_CS
	USAT16_CC
	USAT16_MI
	USAT16_PL
	USAT16_VS
	USAT16_VC
	USAT16_HI
	USAT16_LS
	USAT16_GE
	USAT16_LT
	USAT16_GT
	USAT16_LE
	USAT16
	USAT16_ZZ
	USAX_EQ
	USAX_NE
	USAX_CS
	USAX_CC
	USAX_MI
	USAX_PL
	USAX_VS
	USAX_VC
	USAX_HI
	USAX_LS
	USAX_GE
	USAX_LT
	USAX_GT
	USAX_LE
	USAX
	USAX_ZZ
	USUB16_EQ
	USUB16_NE
	USUB16_CS
	USUB16_CC
	USUB16_MI
	USUB16_PL
	USUB16_VS
	USUB16_VC
	USUB16_HI
	USUB16_LS
	USUB16_GE
	USUB16_LT
	USUB16_GT
	USUB16_LE
	USUB16
	USUB16_ZZ
	USUB8_EQ
	USUB8_NE
	USUB8_CS
	USUB8_CC
	USUB8_MI
	USUB8_PL
	USUB8_VS
	USUB8_VC
	USUB8_HI
	USUB8_LS
	USUB8_GE
	USUB8_LT
	USUB8_GT
	USUB8_LE
	USUB8
	USUB8_ZZ
	UXTAB_EQ
	UXTAB_NE
	UXTAB_CS
	UXTAB_CC
	UXTAB_MI
	UXTAB_PL
	UXTAB_VS
	UXTAB_VC
	UXTAB_HI
	UXTAB_LS
	UXTAB_GE
	UXTAB_LT
	UXTAB_GT
	UXTAB_LE
	UXTAB
	UXTAB_ZZ
	UXTAB16_EQ
	UXTAB16_NE
	UXTAB16_CS
	UXTAB16_CC
	UXTAB16_MI
	UXTAB16_PL
	UXTAB16_VS
	UXTAB16_VC
	UXTAB16_HI
	UXTAB16_LS
	UXTAB16_GE
	UXTAB16_LT
	UXTAB16_GT
	UXTAB16_LE
	UXTAB16
	UXTAB16_ZZ
	UXTAH_EQ
	UXTAH_NE
	UXTAH_CS
	UXTAH_CC
	UXTAH_MI
	UXTAH_PL
	UXTAH_VS
	UXTAH_VC
	UXTAH_HI
	UXTAH_LS
	UXTAH_GE
	UXTAH_LT
	UXTAH_GT
	UXTAH_LE
	UXTAH
	UXTAH_ZZ
	UXTB_EQ
	UXTB_NE
	UXTB_CS
	UXTB_CC
	UXTB_MI
	UXTB_PL
	UXTB_VS
	UXTB_VC
	UXTB_HI
	UXTB_LS
	UXTB_GE
	UXTB_LT
	UXTB_GT
	UXTB_LE
	UXTB
	UXTB_ZZ
	UXTB16_EQ
	UXTB16_NE
	UXTB16_CS
	UXTB16_CC
	UXTB16_MI
	UXTB16_PL
	UXTB16_VS
	UXTB16_VC
	UXTB16_HI
	UXTB16_LS
	UXTB16_GE
	UXTB16_LT
	UXTB16_GT
	UXTB16_LE
	UXTB16
	UXTB16_ZZ
	UXTH_EQ
	UXTH_NE
	UXTH_CS
	UXTH_CC
	UXTH_MI
	UXTH_PL
	UXTH_VS
	UXTH_VC
	UXTH_HI
	UXTH_LS
	UXTH_GE
	UXTH_LT
	UXTH_GT
	UXTH_LE
	UXTH
	UXTH_ZZ
	VABS_EQ_F32
	VABS_NE_F32
	VABS_CS_F32
	VABS_CC_F32
	VABS_MI_F32
	VABS_PL_F32
	VABS_VS_F32
	VABS_VC_F32
	VABS_HI_F32
	VABS_LS_F32
	VABS_GE_F32
	VABS_LT_F32
	VABS_GT_F32
	VABS_LE_F32
	VABS_F32
	VABS_ZZ_F32
	VABS_EQ_F64
	VABS_NE_F64
	VABS_CS_F64
	VABS_CC_F64
	VABS_MI_F64
	VABS_PL_F64
	VABS_VS_F64
	VABS_VC_F64
	VABS_HI_F64
	VABS_LS_F64
	VABS_GE_F64
	VABS_LT_F64
	VABS_GT_F64
	VABS_LE_F64
	VABS_F64
	VABS_ZZ_F64
	VADD_EQ_F32
	VADD_NE_F32
	VADD_CS_F32
	VADD_CC_F32
	VADD_MI_F32
	VADD_PL_F32
	VADD_VS_F32
	VADD_VC_F32
	VADD_HI_F32
	VADD_LS_F32
	VADD_GE_F32
	VADD_LT_F32
	VADD_GT_F32
	VADD_LE_F32
	VADD_F32
	VADD_ZZ_F32
	VADD_EQ_F64
	VADD_NE_F64
	VADD_CS_F64
	VADD_CC_F64
	VADD_MI_F64
	VADD_PL_F64
	VADD_VS_F64
	VADD_VC_F64
	VADD_HI_F64
	VADD_LS_F64
	VADD_GE_F64
	VADD_LT_F64
	VADD_GT_F64
	VADD_LE_F64
	VADD_F64
	VADD_ZZ_F64
	VCMP_EQ_F32
	VCMP_NE_F32
	VCMP_CS_F32
	VCMP_CC_F32
	VCMP_MI_F32
	VCMP_PL_F32
	VCMP_VS_F32
	VCMP_VC_F32
	VCMP_HI_F32
	VCMP_LS_F32
	VCMP_GE_F32
	VCMP_LT_F32
	VCMP_GT_F32
	VCMP_LE_F32
	VCMP_F32
	VCMP_ZZ_F32
	VCMP_EQ_F64
	VCMP_NE_F64
	VCMP_CS_F64
	VCMP_CC_F64
	VCMP_MI_F64
	VCMP_PL_F64
	VCMP_VS_F64
	VCMP_VC_F64
	VCMP_HI_F64
	VCMP_LS_F64
	VCMP_GE_F64
	VCMP_LT_F64
	VCMP_GT_F64
	VCMP_LE_F64
	VCMP_F64
	VCMP_ZZ_F64
	VCMP_E_EQ_F32
	VCMP_E_NE_F32
	VCMP_E_CS_F32
	VCMP_E_CC_F32
	VCMP_E_MI_F32
	VCMP_E_PL_F32
	VCMP_E_VS_F32
	VCMP_E_VC_F32
	VCMP_E_HI_F32
	VCMP_E_LS_F32
	VCMP_E_GE_F32
	VCMP_E_LT_F32
	VCMP_E_GT_F32
	VCMP_E_LE_F32
	VCMP_E_F32
	VCMP_E_ZZ_F32
	VCMP_E_EQ_F64
	VCMP_E_NE_F64
	VCMP_E_CS_F64
	VCMP_E_CC_F64
	VCMP_E_MI_F64
	VCMP_E_PL_F64
	VCMP_E_VS_F64
	VCMP_E_VC_F64
	VCMP_E_HI_F64
	VCMP_E_LS_F64
	VCMP_E_GE_F64
	VCMP_E_LT_F64
	VCMP_E_GT_F64
	VCMP_E_LE_F64
	VCMP_E_F64
	VCMP_E_ZZ_F64
	VCVT_EQ_F32_FXS16
	VCVT_NE_F32_FXS16
	VCVT_CS_F32_FXS16
	VCVT_CC_F32_FXS16
	VCVT_MI_F32_FXS16
	VCVT_PL_F32_FXS16
	VCVT_VS_F32_FXS16
	VCVT_VC_F32_FXS16
	VCVT_HI_F32_FXS16
	VCVT_LS_F32_FXS16
	VCVT_GE_F32_FXS16
	VCVT_LT_F32_FXS16
	VCVT_GT_F32_FXS16
	VCVT_LE_F32_FXS16
	VCVT_F32_FXS16
	VCVT_ZZ_F32_FXS16
	VCVT_EQ_F32_FXS32
	VCVT_NE_F32_FXS32
	VCVT_CS_F32_FXS32
	VCVT_CC_F32_FXS32
	VCVT_MI_F32_FXS32
	VCVT_PL_F32_FXS32
	VCVT_VS_F32_FXS32
	VCVT_VC_F32_FXS32
	VCVT_HI_F32_FXS32
	VCVT_LS_F32_FXS32
	VCVT_GE_F32_FXS32
	VCVT_LT_F32_FXS32
	VCVT_GT_F32_FXS32
	VCVT_LE_F32_FXS32
	VCVT_F32_FXS32
	VCVT_ZZ_F32_FXS32
	VCVT_EQ_F32_FXU16
	VCVT_NE_F32_FXU16
	VCVT_CS_F32_FXU16
	VCVT_CC_F32_FXU16
	VCVT_MI_F32_FXU16
	VCVT_PL_F32_FXU16
	VCVT_VS_F32_FXU16
	VCVT_VC_F32_FXU16
	VCVT_HI_F32_FXU16
	VCVT_LS_F32_FXU16
	VCVT_GE_F32_FXU16
	VCVT_LT_F32_FXU16
	VCVT_GT_F32_FXU16
	VCVT_LE_F32_FXU16
	VCVT_F32_FXU16
	VCVT_ZZ_F32_FXU16
	VCVT_EQ_F32_FXU32
	VCVT_NE_F32_FXU32
	VCVT_CS_F32_FXU32
	VCVT_CC_F32_FXU32
	VCVT_MI_F32_FXU32
	VCVT_PL_F32_FXU32
	VCVT_VS_F32_FXU32
	VCVT_VC_F32_FXU32
	VCVT_HI_F32_FXU32
	VCVT_LS_F32_FXU32
	VCVT_GE_F32_FXU32
	VCVT_LT_F32_FXU32
	VCVT_GT_F32_FXU32
	VCVT_LE_F32_FXU32
	VCVT_F32_FXU32
	VCVT_ZZ_F32_FXU32
	VCVT_EQ_F64_FXS16
	VCVT_NE_F64_FXS16
	VCVT_CS_F64_FXS16
	VCVT_CC_F64_FXS16
	VCVT_MI_F64_FXS16
	VCVT_PL_F64_FXS16
	VCVT_VS_F64_FXS16
	VCVT_VC_F64_FXS16
	VCVT_HI_F64_FXS16
	VCVT_LS_F64_FXS16
	VCVT_GE_F64_FXS16
	VCVT_LT_F64_FXS16
	VCVT_GT_F64_FXS16
	VCVT_LE_F64_FXS16
	VCVT_F64_FXS16
	VCVT_ZZ_F64_FXS16
	VCVT_EQ_F64_FXS32
	VCVT_NE_F64_FXS32
	VCVT_CS_F64_FXS32
	VCVT_CC_F64_FXS32
	VCVT_MI_F64_FXS32
	VCVT_PL_F64_FXS32
	VCVT_VS_F64_FXS32
	VCVT_VC_F64_FXS32
	VCVT_HI_F64_FXS32
	VCVT_LS_F64_FXS32
	VCVT_GE_F64_FXS32
	VCVT_LT_F64_FXS32
	VCVT_GT_F64_FXS32
	VCVT_LE_F64_FXS32
	VCVT_F64_FXS32
	VCVT_ZZ_F64_FXS32
	VCVT_EQ_F64_FXU16
	VCVT_NE_F64_FXU16
	VCVT_CS_F64_FXU16
	VCVT_CC_F64_FXU16
	VCVT_MI_F64_FXU16
	VCVT_PL_F64_FXU16
	VCVT_VS_F64_FXU16
	VCVT_VC_F64_FXU16
	VCVT_HI_F64_FXU16
	VCVT_LS_F64_FXU16
	VCVT_GE_F64_FXU16
	VCVT_LT_F64_FXU16
	VCVT_GT_F64_FXU16
	VCVT_LE_F64_FXU16
	VCVT_F64_FXU16
	VCVT_ZZ_F64_FXU16
	VCVT_EQ_F64_FXU32
	VCVT_NE_F64_FXU32
	VCVT_CS_F64_FXU32
	VCVT_CC_F64_FXU32
	VCVT_MI_F64_FXU32
	VCVT_PL_F64_FXU32
	VCVT_VS_F64_FXU32
	VCVT_VC_F64_FXU32
	VCVT_HI_F64_FXU32
	VCVT_LS_F64_FXU32
	VCVT_GE_F64_FXU32
	VCVT_LT_F64_FXU32
	VCVT_GT_F64_FXU32
	VCVT_LE_F64_FXU32
	VCVT_F64_FXU32
	VCVT_ZZ_F64_FXU32
	VCVT_EQ_F32_U32
	VCVT_NE_F32_U32
	VCVT_CS_F32_U32
	VCVT_CC_F32_U32
	VCVT_MI_F32_U32
	VCVT_PL_F32_U32
	VCVT_VS_F32_U32
	VCVT_VC_F32_U32
	VCVT_HI_F32_U32
	VCVT_LS_F32_U32
	VCVT_GE_F32_U32
	VCVT_LT_F32_U32
	VCVT_GT_F32_U32
	VCVT_LE_F32_U32
	VCVT_F32_U32
	VCVT_ZZ_F32_U32
	VCVT_EQ_F32_S32
	VCVT_NE_F32_S32
	VCVT_CS_F32_S32
	VCVT_CC_F32_S32
	VCVT_MI_F32_S32
	VCVT_PL_F32_S32
	VCVT_VS_F32_S32
	VCVT_VC_F32_S32
	VCVT_HI_F32_S32
	VCVT_LS_F32_S32
	VCVT_GE_F32_S32
	VCVT_LT_F32_S32
	VCVT_GT_F32_S32
	VCVT_LE_F32_S32
	VCVT_F32_S32
	VCVT_ZZ_F32_S32
	VCVT_EQ_F64_U32
	VCVT_NE_F64_U32
	VCVT_CS_F64_U32
	VCVT_CC_F64_U32
	VCVT_MI_F64_U32
	VCVT_PL_F64_U32
	VCVT_VS_F64_U32
	VCVT_VC_F64_U32
	VCVT_HI_F64_U32
	VCVT_LS_F64_U32
	VCVT_GE_F64_U32
	VCVT_LT_F64_U32
	VCVT_GT_F64_U32
	VCVT_LE_F64_U32
	VCVT_F64_U32
	VCVT_ZZ_F64_U32
	VCVT_EQ_F64_S32
	VCVT_NE_F64_S32
	VCVT_CS_F64_S32
	VCVT_CC_F64_S32
	VCVT_MI_F64_S32
	VCVT_PL_F64_S32
	VCVT_VS_F64_S32
	VCVT_VC_F64_S32
	VCVT_HI_F64_S32
	VCVT_LS_F64_S32
	VCVT_GE_F64_S32
	VCVT_LT_F64_S32
	VCVT_GT_F64_S32
	VCVT_LE_F64_S32
	VCVT_F64_S32
	VCVT_ZZ_F64_S32
	VCVT_EQ_F64_F32
	VCVT_NE_F64_F32
	VCVT_CS_F64_F32
	VCVT_CC_F64_F32
	VCVT_MI_F64_F32
	VCVT_PL_F64_F32
	VCVT_VS_F64_F32
	VCVT_VC_F64_F32
	VCVT_HI_F64_F32
	VCVT_LS_F64_F32
	VCVT_GE_F64_F32
	VCVT_LT_F64_F32
	VCVT_GT_F64_F32
	VCVT_LE_F64_F32
	VCVT_F64_F32
	VCVT_ZZ_F64_F32
	VCVT_EQ_F32_F64
	VCVT_NE_F32_F64
	VCVT_CS_F32_F64
	VCVT_CC_F32_F64
	VCVT_MI_F32_F64
	VCVT_PL_F32_F64
	VCVT_VS_F32_F64
	VCVT_VC_F32_F64
	VCVT_HI_F32_F64
	VCVT_LS_F32_F64
	VCVT_GE_F32_F64
	VCVT_LT_F32_F64
	VCVT_GT_F32_F64
	VCVT_LE_F32_F64
	VCVT_F32_F64
	VCVT_ZZ_F32_F64
	VCVT_EQ_FXS16_F32
	VCVT_NE_FXS16_F32
	VCVT_CS_FXS16_F32
	VCVT_CC_FXS16_F32
	VCVT_MI_FXS16_F32
	VCVT_PL_FXS16_F32
	VCVT_VS_FXS16_F32
	VCVT_VC_FXS16_F32
	VCVT_HI_FXS16_F32
	VCVT_LS_FXS16_F32
	VCVT_GE_FXS16_F32
	VCVT_LT_FXS16_F32
	VCVT_GT_FXS16_F32
	VCVT_LE_FXS16_F32
	VCVT_FXS16_F32
	VCVT_ZZ_FXS16_F32
	VCVT_EQ_FXS16_F64
	VCVT_NE_FXS16_F64
	VCVT_CS_FXS16_F64
	VCVT_CC_FXS16_F64
	VCVT_MI_FXS16_F64
	VCVT_PL_FXS16_F64
	VCVT_VS_FXS16_F64
	VCVT_VC_FXS16_F64
	VCVT_HI_FXS16_F64
	VCVT_LS_FXS16_F64
	VCVT_GE_FXS16_F64
	VCVT_LT_FXS16_F64
	VCVT_GT_FXS16_F64
	VCVT_LE_FXS16_F64
	VCVT_FXS16_F64
	VCVT_ZZ_FXS16_F64
	VCVT_EQ_FXS32_F32
	VCVT_NE_FXS32_F32
	VCVT_CS_FXS32_F32
	VCVT_CC_FXS32_F32
	VCVT_MI_FXS32_F32
	VCVT_PL_FXS32_F32
	VCVT_VS_FXS32_F32
	VCVT_VC_FXS32_F32
	VCVT_HI_FXS32_F32
	VCVT_LS_FXS32_F32
	VCVT_GE_FXS32_F32
	VCVT_LT_FXS32_F32
	VCVT_GT_FXS32_F32
	VCVT_LE_FXS32_F32
	VCVT_FXS32_F32
	VCVT_ZZ_FXS32_F32
	VCVT_EQ_FXS32_F64
	VCVT_NE_FXS32_F64
	VCVT_CS_FXS32_F64
	VCVT_CC_FXS32_F64
	VCVT_MI_FXS32_F64
	VCVT_PL_FXS32_F64
	VCVT_VS_FXS32_F64
	VCVT_VC_FXS32_F64
	VCVT_HI_FXS32_F64
	VCVT_LS_FXS32_F64
	VCVT_GE_FXS32_F64
	VCVT_LT_FXS32_F64
	VCVT_GT_FXS32_F64
	VCVT_LE_FXS32_F64
	VCVT_FXS32_F64
	VCVT_ZZ_FXS32_F64
	VCVT_EQ_FXU16_F32
	VCVT_NE_FXU16_F32
	VCVT_CS_FXU16_F32
	VCVT_CC_FXU16_F32
	VCVT_MI_FXU16_F32
	VCVT_PL_FXU16_F32
	VCVT_VS_FXU16_F32
	VCVT_VC_FXU16_F32
	VCVT_HI_FXU16_F32
	VCVT_LS_FXU16_F32
	VCVT_GE_FXU16_F32
	VCVT_LT_FXU16_F32
	VCVT_GT_FXU16_F32
	VCVT_LE_FXU16_F32
	VCVT_FXU16_F32
	VCVT_ZZ_FXU16_F32
	VCVT_EQ_FXU16_F64
	VCVT_NE_FXU16_F64
	VCVT_CS_FXU16_F64
	VCVT_CC_FXU16_F64
	VCVT_MI_FXU16_F64
	VCVT_PL_FXU16_F64
	VCVT_VS_FXU16_F64
	VCVT_VC_FXU16_F64
	VCVT_HI_FXU16_F64
	VCVT_LS_FXU16_F64
	VCVT_GE_FXU16_F64
	VCVT_LT_FXU16_F64
	VCVT_GT_FXU16_F64
	VCVT_LE_FXU16_F64
	VCVT_FXU16_F64
	VCVT_ZZ_FXU16_F64
	VCVT_EQ_FXU32_F32
	VCVT_NE_FXU32_F32
	VCVT_CS_FXU32_F32
	VCVT_CC_FXU32_F32
	VCVT_MI_FXU32_F32
	VCVT_PL_FXU32_F32
	VCVT_VS_FXU32_F32
	VCVT_VC_FXU32_F32
	VCVT_HI_FXU32_F32
	VCVT_LS_FXU32_F32
	VCVT_GE_FXU32_F32
	VCVT_LT_FXU32_F32
	VCVT_GT_FXU32_F32
	VCVT_LE_FXU32_F32
	VCVT_FXU32_F32
	VCVT_ZZ_FXU32_F32
	VCVT_EQ_FXU32_F64
	VCVT_NE_FXU32_F64
	VCVT_CS_FXU32_F64
	VCVT_CC_FXU32_F64
	VCVT_MI_FXU32_F64
	VCVT_PL_FXU32_F64
	VCVT_VS_FXU32_F64
	VCVT_VC_FXU32_F64
	VCVT_HI_FXU32_F64
	VCVT_LS_FXU32_F64
	VCVT_GE_FXU32_F64
	VCVT_LT_FXU32_F64
	VCVT_GT_FXU32_F64
	VCVT_LE_FXU32_F64
	VCVT_FXU32_F64
	VCVT_ZZ_FXU32_F64
	VCVTB_EQ_F32_F16
	VCVTB_NE_F32_F16
	VCVTB_CS_F32_F16
	VCVTB_CC_F32_F16
	VCVTB_MI_F32_F16
	VCVTB_PL_F32_F16
	VCVTB_VS_F32_F16
	VCVTB_VC_F32_F16
	VCVTB_HI_F32_F16
	VCVTB_LS_F32_F16
	VCVTB_GE_F32_F16
	VCVTB_LT_F32_F16
	VCVTB_GT_F32_F16
	VCVTB_LE_F32_F16
	VCVTB_F32_F16
	VCVTB_ZZ_F32_F16
	VCVTB_EQ_F16_F32
	VCVTB_NE_F16_F32
	VCVTB_CS_F16_F32
	VCVTB_CC_F16_F32
	VCVTB_MI_F16_F32
	VCVTB_PL_F16_F32
	VCVTB_VS_F16_F32
	VCVTB_VC_F16_F32
	VCVTB_HI_F16_F32
	VCVTB_LS_F16_F32
	VCVTB_GE_F16_F32
	VCVTB_LT_F16_F32
	VCVTB_GT_F16_F32
	VCVTB_LE_F16_F32
	VCVTB_F16_F32
	VCVTB_ZZ_F16_F32
	VCVTT_EQ_F32_F16
	VCVTT_NE_F32_F16
	VCVTT_CS_F32_F16
	VCVTT_CC_F32_F16
	VCVTT_MI_F32_F16
	VCVTT_PL_F32_F16
	VCVTT_VS_F32_F16
	VCVTT_VC_F32_F16
	VCVTT_HI_F32_F16
	VCVTT_LS_F32_F16
	VCVTT_GE_F32_F16
	VCVTT_LT_F32_F16
	VCVTT_GT_F32_F16
	VCVTT_LE_F32_F16
	VCVTT_F32_F16
	VCVTT_ZZ_F32_F16
	VCVTT_EQ_F16_F32
	VCVTT_NE_F16_F32
	VCVTT_CS_F16_F32
	VCVTT_CC_F16_F32
	VCVTT_MI_F16_F32
	VCVTT_PL_F16_F32
	VCVTT_VS_F16_F32
	VCVTT_VC_F16_F32
	VCVTT_HI_F16_F32
	VCVTT_LS_F16_F32
	VCVTT_GE_F16_F32
	VCVTT_LT_F16_F32
	VCVTT_GT_F16_F32
	VCVTT_LE_F16_F32
	VCVTT_F16_F32
	VCVTT_ZZ_F16_F32
	VCVTR_EQ_U32_F32
	VCVTR_NE_U32_F32
	VCVTR_CS_U32_F32
	VCVTR_CC_U32_F32
	VCVTR_MI_U32_F32
	VCVTR_PL_U32_F32
	VCVTR_VS_U32_F32
	VCVTR_VC_U32_F32
	VCVTR_HI_U32_F32
	VCVTR_LS_U32_F32
	VCVTR_GE_U32_F32
	VCVTR_LT_U32_F32
	VCVTR_GT_U32_F32
	VCVTR_LE_U32_F32
	VCVTR_U32_F32
	VCVTR_ZZ_U32_F32
	VCVTR_EQ_U32_F64
	VCVTR_NE_U32_F64
	VCVTR_CS_U32_F64
	VCVTR_CC_U32_F64
	VCVTR_MI_U32_F64
	VCVTR_PL_U32_F64
	VCVTR_VS_U32_F64
	VCVTR_VC_U32_F64
	VCVTR_HI_U32_F64
	VCVTR_LS_U32_F64
	VCVTR_GE_U32_F64
	VCVTR_LT_U32_F64
	VCVTR_GT_U32_F64
	VCVTR_LE_U32_F64
	VCVTR_U32_F64
	VCVTR_ZZ_U32_F64
	VCVTR_EQ_S32_F32
	VCVTR_NE_S32_F32
	VCVTR_CS_S32_F32
	VCVTR_CC_S32_F32
	VCVTR_MI_S32_F32
	VCVTR_PL_S32_F32
	VCVTR_VS_S32_F32
	VCVTR_VC_S32_F32
	VCVTR_HI_S32_F32
	VCVTR_LS_S32_F32
	VCVTR_GE_S32_F32
	VCVTR_LT_S32_F32
	VCVTR_GT_S32_F32
	VCVTR_LE_S32_F32
	VCVTR_S32_F32
	VCVTR_ZZ_S32_F32
	VCVTR_EQ_S32_F64
	VCVTR_NE_S32_F64
	VCVTR_CS_S32_F64
	VCVTR_CC_S32_F64
	VCVTR_MI_S32_F64
	VCVTR_PL_S32_F64
	VCVTR_VS_S32_F64
	VCVTR_VC_S32_F64
	VCVTR_HI_S32_F64
	VCVTR_LS_S32_F64
	VCVTR_GE_S32_F64
	VCVTR_LT_S32_F64
	VCVTR_GT_S32_F64
	VCVTR_LE_S32_F64
	VCVTR_S32_F64
	VCVTR_ZZ_S32_F64
	VCVT_EQ_U32_F32
	VCVT_NE_U32_F32
	VCVT_CS_U32_F32
	VCVT_CC_U32_F32
	VCVT_MI_U32_F32
	VCVT_PL_U32_F32
	VCVT_VS_U32_F32
	VCVT_VC_U32_F32
	VCVT_HI_U32_F32
	VCVT_LS_U32_F32
	VCVT_GE_U32_F32
	VCVT_LT_U32_F32
	VCVT_GT_U32_F32
	VCVT_LE_U32_F32
	VCVT_U32_F32
	VCVT_ZZ_U32_F32
	VCVT_EQ_U32_F64
	VCVT_NE_U32_F64
	VCVT_CS_U32_F64
	VCVT_CC_U32_F64
	VCVT_MI_U32_F64
	VCVT_PL_U32_F64
	VCVT_VS_U32_F64
	VCVT_VC_U32_F64
	VCVT_HI_U32_F64
	VCVT_LS_U32_F64
	VCVT_GE_U32_F64
	VCVT_LT_U32_F64
	VCVT_GT_U32_F64
	VCVT_LE_U32_F64
	VCVT_U32_F64
	VCVT_ZZ_U32_F64
	VCVT_EQ_S32_F32
	VCVT_NE_S32_F32
	VCVT_CS_S32_F32
	VCVT_CC_S32_F32
	VCVT_MI_S32_F32
	VCVT_PL_S32_F32
	VCVT_VS_S32_F32
	VCVT_VC_S32_F32
	VCVT_HI_S32_F32
	VCVT_LS_S32_F32
	VCVT_GE_S32_F32
	VCVT_LT_S32_F32
	VCVT_GT_S32_F32
	VCVT_LE_S32_F32
	VCVT_S32_F32
	VCVT_ZZ_S32_F32
	VCVT_EQ_S32_F64
	VCVT_NE_S32_F64
	VCVT_CS_S32_F64
	VCVT_CC_S32_F64
	VCVT_MI_S32_F64
	VCVT_PL_S32_F64
	VCVT_VS_S32_F64
	VCVT_VC_S32_F64
	VCVT_HI_S32_F64
	VCVT_LS_S32_F64
	VCVT_GE_S32_F64
	VCVT_LT_S32_F64
	VCVT_GT_S32_F64
	VCVT_LE_S32_F64
	VCVT_S32_F64
	VCVT_ZZ_S32_F64
	VDIV_EQ_F32
	VDIV_NE_F32
	VDIV_CS_F32
	VDIV_CC_F32
	VDIV_MI_F32
	VDIV_PL_F32
	VDIV_VS_F32
	VDIV_VC_F32
	VDIV_HI_F32
	VDIV_LS_F32
	VDIV_GE_F32
	VDIV_LT_F32
	VDIV_GT_F32
	VDIV_LE_F32
	VDIV_F32
	VDIV_ZZ_F32
	VDIV_EQ_F64
	VDIV_NE_F64
	VDIV_CS_F64
	VDIV_CC_F64
	VDIV_MI_F64
	VDIV_PL_F64
	VDIV_VS_F64
	VDIV_VC_F64
	VDIV_HI_F64
	VDIV_LS_F64
	VDIV_GE_F64
	VDIV_LT_F64
	VDIV_GT_F64
	VDIV_LE_F64
	VDIV_F64
	VDIV_ZZ_F64
	VLDR_EQ
	VLDR_NE
	VLDR_CS
	VLDR_CC
	VLDR_MI
	VLDR_PL
	VLDR_VS
	VLDR_VC
	VLDR_HI
	VLDR_LS
	VLDR_GE
	VLDR_LT
	VLDR_GT
	VLDR_LE
	VLDR
	VLDR_ZZ
	VMLA_EQ_F32
	VMLA_NE_F32
	VMLA_CS_F32
	VMLA_CC_F32
	VMLA_MI_F32
	VMLA_PL_F32
	VMLA_VS_F32
	VMLA_VC_F32
	VMLA_HI_F32
	VMLA_LS_F32
	VMLA_GE_F32
	VMLA_LT_F32
	VMLA_GT_F32
	VMLA_LE_F32
	VMLA_F32
	VMLA_ZZ_F32
	VMLA_EQ_F64
	VMLA_NE_F64
	VMLA_CS_F64
	VMLA_CC_F64
	VMLA_MI_F64
	VMLA_PL_F64
	VMLA_VS_F64
	VMLA_VC_F64
	VMLA_HI_F64
	VMLA_LS_F64
	VMLA_GE_F64
	VMLA_LT_F64
	VMLA_GT_F64
	VMLA_LE_F64
	VMLA_F64
	VMLA_ZZ_F64
	VMLS_EQ_F32
	VMLS_NE_F32
	VMLS_CS_F32
	VMLS_CC_F32
	VMLS_MI_F32
	VMLS_PL_F32
	VMLS_VS_F32
	VMLS_VC_F32
	VMLS_HI_F32
	VMLS_LS_F32
	VMLS_GE_F32
	VMLS_LT_F32
	VMLS_GT_F32
	VMLS_LE_F32
	VMLS_F32
	VMLS_ZZ_F32
	VMLS_EQ_F64
	VMLS_NE_F64
	VMLS_CS_F64
	VMLS_CC_F64
	VMLS_MI_F64
	VMLS_PL_F64
	VMLS_VS_F64
	VMLS_VC_F64
	VMLS_HI_F64
	VMLS_LS_F64
	VMLS_GE_F64
	VMLS_LT_F64
	VMLS_GT_F64
	VMLS_LE_F64
	VMLS_F64
	VMLS_ZZ_F64
	VMOV_EQ
	VMOV_NE
	VMOV_CS
	VMOV_CC
	VMOV_MI
	VMOV_PL
	VMOV_VS
	VMOV_VC
	VMOV_HI
	VMOV_LS
	VMOV_GE
	VMOV_LT
	VMOV_GT
	VMOV_LE
	VMOV
	VMOV_ZZ
	VMOV_EQ_32
	VMOV_NE_32
	VMOV_CS_32
	VMOV_CC_32
	VMOV_MI_32
	VMOV_PL_32
	VMOV_VS_32
	VMOV_VC_32
	VMOV_HI_32
	VMOV_LS_32
	VMOV_GE_32
	VMOV_LT_32
	VMOV_GT_32
	VMOV_LE_32
	VMOV_32
	VMOV_ZZ_32
	VMOV_EQ_F32
	VMOV_NE_F32
	VMOV_CS_F32
	VMOV_CC_F32
	VMOV_MI_F32
	VMOV_PL_F32
	VMOV_VS_F32
	VMOV_VC_F32
	VMOV_HI_F32
	VMOV_LS_F32
	VMOV_GE_F32
	VMOV_LT_F32
	VMOV_GT_F32
	VMOV_LE_F32
	VMOV_F32
	VMOV_ZZ_F32
	VMOV_EQ_F64
	VMOV_NE_F64
	VMOV_CS_F64
	VMOV_CC_F64
	VMOV_MI_F64
	VMOV_PL_F64
	VMOV_VS_F64
	VMOV_VC_F64
	VMOV_HI_F64
	VMOV_LS_F64
	VMOV_GE_F64
	VMOV_LT_F64
	VMOV_GT_F64
	VMOV_LE_F64
	VMOV_F64
	VMOV_ZZ_F64
	VMRS_EQ
	VMRS_NE
	VMRS_CS
	VMRS_CC
	VMRS_MI
	VMRS_PL
	VMRS_VS
	VMRS_VC
	VMRS_HI
	VMRS_LS
	VMRS_GE
	VMRS_LT
	VMRS_GT
	VMRS_LE
	VMRS
	VMRS_ZZ
	VMSR_EQ
	VMSR_NE
	VMSR_CS
	VMSR_CC
	VMSR_MI
	VMSR_PL
	VMSR_VS
	VMSR_VC
	VMSR_HI
	VMSR_LS
	VMSR_GE
	VMSR_LT
	VMSR_GT
	VMSR_LE
	VMSR
	VMSR_ZZ
	VMUL_EQ_F32
	VMUL_NE_F32
	VMUL_CS_F32
	VMUL_CC_F32
	VMUL_MI_F32
	VMUL_PL_F32
	VMUL_VS_F32
	VMUL_VC_F32
	VMUL_HI_F32
	VMUL_LS_F32
	VMUL_GE_F32
	VMUL_LT_F32
	VMUL_GT_F32
	VMUL_LE_F32
	VMUL_F32
	VMUL_ZZ_F32
	VMUL_EQ_F64
	VMUL_NE_F64
	VMUL_CS_F64
	VMUL_CC_F64
	VMUL_MI_F64
	VMUL_PL_F64
	VMUL_VS_F64
	VMUL_VC_F64
	VMUL_HI_F64
	VMUL_LS_F64
	VMUL_GE_F64
	VMUL_LT_F64
	VMUL_GT_F64
	VMUL_LE_F64
	VMUL_F64
	VMUL_ZZ_F64
	VNEG_EQ_F32
	VNEG_NE_F32
	VNEG_CS_F32
	VNEG_CC_F32
	VNEG_MI_F32
	VNEG_PL_F32
	VNEG_VS_F32
	VNEG_VC_F32
	VNEG_HI_F32
	VNEG_LS_F32
	VNEG_GE_F32
	VNEG_LT_F32
	VNEG_GT_F32
	VNEG_LE_F32
	VNEG_F32
	VNEG_ZZ_F32
	VNEG_EQ_F64
	VNEG_NE_F64
	VNEG_CS_F64
	VNEG_CC_F64
	VNEG_MI_F64
	VNEG_PL_F64
	VNEG_VS_F64
	VNEG_VC_F64
	VNEG_HI_F64
	VNEG_LS_F64
	VNEG_GE_F64
	VNEG_LT_F64
	VNEG_GT_F64
	VNEG_LE_F64
	VNEG_F64
	VNEG_ZZ_F64
	VNMLS_EQ_F32
	VNMLS_NE_F32
	VNMLS_CS_F32
	VNMLS_CC_F32
	VNMLS_MI_F32
	VNMLS_PL_F32
	VNMLS_VS_F32
	VNMLS_VC_F32
	VNMLS_HI_F32
	VNMLS_LS_F32
	VNMLS_GE_F32
	VNMLS_LT_F32
	VNMLS_GT_F32
	VNMLS_LE_F32
	VNMLS_F32
	VNMLS_ZZ_F32
	VNMLS_EQ_F64
	VNMLS_NE_F64
	VNMLS_CS_F64
	VNMLS_CC_F64
	VNMLS_MI_F64
	VNMLS_PL_F64
	VNMLS_VS_F64
	VNMLS_VC_F64
	VNMLS_HI_F64
	VNMLS_LS_F64
	VNMLS_GE_F64
	VNMLS_LT_F64
	VNMLS_GT_F64
	VNMLS_LE_F64
	VNMLS_F64
	VNMLS_ZZ_F64
	VNMLA_EQ_F32
	VNMLA_NE_F32
	VNMLA_CS_F32
	VNMLA_CC_F32
	VNMLA_MI_F32
	VNMLA_PL_F32
	VNMLA_VS_F32
	VNMLA_VC_F32
	VNMLA_HI_F32
	VNMLA_LS_F32
	VNMLA_GE_F32
	VNMLA_LT_F32
	VNMLA_GT_F32
	VNMLA_LE_F32
	VNMLA_F32
	VNMLA_ZZ_F32
	VNMLA_EQ_F64
	VNMLA_NE_F64
	VNMLA_CS_F64
	VNMLA_CC_F64
	VNMLA_MI_F64
	VNMLA_PL_F64
	VNMLA_VS_F64
	VNMLA_VC_F64
	VNMLA_HI_F64
	VNMLA_LS_F64
	VNMLA_GE_F64
	VNMLA_LT_F64
	VNMLA_GT_F64
	VNMLA_LE_F64
	VNMLA_F64
	VNMLA_ZZ_F64
	VNMUL_EQ_F32
	VNMUL_NE_F32
	VNMUL_CS_F32
	VNMUL_CC_F32
	VNMUL_MI_F32
	VNMUL_PL_F32
	VNMUL_VS_F32
	VNMUL_VC_F32
	VNMUL_HI_F32
	VNMUL_LS_F32
	VNMUL_GE_F32
	VNMUL_LT_F32
	VNMUL_GT_F32
	VNMUL_LE_F32
	VNMUL_F32
	VNMUL_ZZ_F32
	VNMUL_EQ_F64
	VNMUL_NE_F64
	VNMUL_CS_F64
	VNMUL_CC_F64
	VNMUL_MI_F64
	VNMUL_PL_F64
	VNMUL_VS_F64
	VNMUL_VC_F64
	VNMUL_HI_F64
	VNMUL_LS_F64
	VNMUL_GE_F64
	VNMUL_LT_F64
	VNMUL_GT_F64
	VNMUL_LE_F64
	VNMUL_F64
	VNMUL_ZZ_F64
	VSQRT_EQ_F32
	VSQRT_NE_F32
	VSQRT_CS_F32
	VSQRT_CC_F32
	VSQRT_MI_F32
	VSQRT_PL_F32
	VSQRT_VS_F32
	VSQRT_VC_F32
	VSQRT_HI_F32
	VSQRT_LS_F32
	VSQRT_GE_F32
	VSQRT_LT_F32
	VSQRT_GT_F32
	VSQRT_LE_F32
	VSQRT_F32
	VSQRT_ZZ_F32
	VSQRT_EQ_F64
	VSQRT_NE_F64
	VSQRT_CS_F64
	VSQRT_CC_F64
	VSQRT_MI_F64
	VSQRT_PL_F64
	VSQRT_VS_F64
	VSQRT_VC_F64
	VSQRT_HI_F64
	VSQRT_LS_F64
	VSQRT_GE_F64
	VSQRT_LT_F64
	VSQRT_GT_F64
	VSQRT_LE_F64
	VSQRT_F64
	VSQRT_ZZ_F64
	VSTR_EQ
	VSTR_NE
	VSTR_CS
	VSTR_CC
	VSTR_MI
	VSTR_PL
	VSTR_VS
	VSTR_VC
	VSTR_HI
	VSTR_LS
	VSTR_GE
	VSTR_LT
	VSTR_GT
	VSTR_LE
	VSTR
	VSTR_ZZ
	VSUB_EQ_F32
	VSUB_NE_F32
	VSUB_CS_F32
	VSUB_CC_F32
	VSUB_MI_F32
	VSUB_PL_F32
	VSUB_VS_F32
	VSUB_VC_F32
	VSUB_HI_F32
	VSUB_LS_F32
	VSUB_GE_F32
	VSUB_LT_F32
	VSUB_GT_F32
	VSUB_LE_F32
	VSUB_F32
	VSUB_ZZ_F32
	VSUB_EQ_F64
	VSUB_NE_F64
	VSUB_CS_F64
	VSUB_CC_F64
	VSUB_MI_F64
	VSUB_PL_F64
	VSUB_VS_F64
	VSUB_VC_F64
	VSUB_HI_F64
	VSUB_LS_F64
	VSUB_GE_F64
	VSUB_LT_F64
	VSUB_GT_F64
	VSUB_LE_F64
	VSUB_F64
	VSUB_ZZ_F64
	WFE_EQ
	WFE_NE
	WFE_CS
	WFE_CC
	WFE_MI
	WFE_PL
	WFE_VS
	WFE_VC
	WFE_HI
	WFE_LS
	WFE_GE
	WFE_LT
	WFE_GT
	WFE_LE
	WFE
	WFE_ZZ
	WFI_EQ
	WFI_NE
	WFI_CS
	WFI_CC
	WFI_MI
	WFI_PL
	WFI_VS
	WFI_VC
	WFI_HI
	WFI_LS
	WFI_GE
	WFI_LT
	WFI_GT
	WFI_LE
	WFI
	WFI_ZZ
	YIELD_EQ
	YIELD_NE
	YIELD_CS
	YIELD_CC
	YIELD_MI
	YIELD_PL
	YIELD_VS
	YIELD_VC
	YIELD_HI
	YIELD_LS
	YIELD_GE
	YIELD_LT
	YIELD_GT
	YIELD_LE
	YIELD
	YIELD_ZZ
)

var opstr = [...]string{
	ADC_EQ:            "ADC.EQ",
	ADC_NE:            "ADC.NE",
	ADC_CS:            "ADC.CS",
	ADC_CC:            "ADC.CC",
	ADC_MI:            "ADC.MI",
	ADC_PL:            "ADC.PL",
	ADC_VS:            "ADC.VS",
	ADC_VC:            "ADC.VC",
	ADC_HI:            "ADC.HI",
	ADC_LS:            "ADC.LS",
	ADC_GE:            "ADC.GE",
	ADC_LT:            "ADC.LT",
	ADC_GT:            "ADC.GT",
	ADC_LE:            "ADC.LE",
	ADC:               "ADC",
	ADC_ZZ:            "ADC.ZZ",
	ADC_S_EQ:          "ADC.S.EQ",
	ADC_S_NE:          "ADC.S.NE",
	ADC_S_CS:          "ADC.S.CS",
	ADC_S_CC:          "ADC.S.CC",
	ADC_S_MI:          "ADC.S.MI",
	ADC_S_PL:          "ADC.S.PL",
	ADC_S_VS:          "ADC.S.VS",
	ADC_S_VC:          "ADC.S.VC",
	ADC_S_HI:          "ADC.S.HI",
	ADC_S_LS:          "ADC.S.LS",
	ADC_S_GE:          "ADC.S.GE",
	ADC_S_LT:          "ADC.S.LT",
	ADC_S_GT:          "ADC.S.GT",
	ADC_S_LE:          "ADC.S.LE",
	ADC_S:             "ADC.S",
	ADC_S_ZZ:          "ADC.S.ZZ",
	ADD_EQ:            "ADD.EQ",
	ADD_NE:            "ADD.NE",
	ADD_CS:            "ADD.CS",
	ADD_CC:            "ADD.CC",
	ADD_MI:            "ADD.MI",
	ADD_PL:            "ADD.PL",
	ADD_VS:            "ADD.VS",
	ADD_VC:            "ADD.VC",
	ADD_HI:            "ADD.HI",
	ADD_LS:            "ADD.LS",
	ADD_GE:            "ADD.GE",
	ADD_LT:            "ADD.LT",
	ADD_GT:            "ADD.GT",
	ADD_LE:            "ADD.LE",
	ADD:               "ADD",
	ADD_ZZ:            "ADD.ZZ",
	ADD_S_EQ:          "ADD.S.EQ",
	ADD_S_NE:          "ADD.S.NE",
	ADD_S_CS:          "ADD.S.CS",
	ADD_S_CC:          "ADD.S.CC",
	ADD_S_MI:          "ADD.S.MI",
	ADD_S_PL:          "ADD.S.PL",
	ADD_S_VS:          "ADD.S.VS",
	ADD_S_VC:          "ADD.S.VC",
	ADD_S_HI:          "ADD.S.HI",
	ADD_S_LS:          "ADD.S.LS",
	ADD_S_GE:          "ADD.S.GE",
	ADD_S_LT:          "ADD.S.LT",
	ADD_S_GT:          "ADD.S.GT",
	ADD_S_LE:          "ADD.S.LE",
	ADD_S:             "ADD.S",
	ADD_S_ZZ:          "ADD.S.ZZ",
	AND_EQ:            "AND.EQ",
	AND_NE:            "AND.NE",
	AND_CS:            "AND.CS",
	AND_CC:            "AND.CC",
	AND_MI:            "AND.MI",
	AND_PL:            "AND.PL",
	AND_VS:            "AND.VS",
	AND_VC:            "AND.VC",
	AND_HI:            "AND.HI",
	AND_LS:            "AND.LS",
	AND_GE:            "AND.GE",
	AND_LT:            "AND.LT",
	AND_GT:            "AND.GT",
	AND_LE:            "AND.LE",
	AND:               "AND",
	AND_ZZ:            "AND.ZZ",
	AND_S_EQ:          "AND.S.EQ",
	AND_S_NE:          "AND.S.NE",
	AND_S_CS:          "AND.S.CS",
	AND_S_CC:          "AND.S.CC",
	AND_S_MI:          "AND.S.MI",
	AND_S_PL:          "AND.S.PL",
	AND_S_VS:          "AND.S.VS",
	AND_S_VC:          "AND.S.VC",
	AND_S_HI:          "AND.S.HI",
	AND_S_LS:          "AND.S.LS",
	AND_S_GE:          "AND.S.GE",
	AND_S_LT:          "AND.S.LT",
	AND_S_GT:          "AND.S.GT",
	AND_S_LE:          "AND.S.LE",
	AND_S:             "AND.S",
	AND_S_ZZ:          "AND.S.ZZ",
	ASR_EQ:            "ASR.EQ",
	ASR_NE:            "ASR.NE",
	ASR_CS:            "ASR.CS",
	ASR_CC:            "ASR.CC",
	ASR_MI:            "ASR.MI",
	ASR_PL:            "ASR.PL",
	ASR_VS:            "ASR.VS",
	ASR_VC:            "ASR.VC",
	ASR_HI:            "ASR.HI",
	ASR_LS:            "ASR.LS",
	ASR_GE:            "ASR.GE",
	ASR_LT:            "ASR.LT",
	ASR_GT:            "ASR.GT",
	ASR_LE:            "ASR.LE",
	ASR:               "ASR",
	ASR_ZZ:            "ASR.ZZ",
	ASR_S_EQ:          "ASR.S.EQ",
	ASR_S_NE:          "ASR.S.NE",
	ASR_S_CS:          "ASR.S.CS",
	ASR_S_CC:          "ASR.S.CC",
	ASR_S_MI:          "ASR.S.MI",
	ASR_S_PL:          "ASR.S.PL",
	ASR_S_VS:          "ASR.S.VS",
	ASR_S_VC:          "ASR.S.VC",
	ASR_S_HI:          "ASR.S.HI",
	ASR_S_LS:          "ASR.S.LS",
	ASR_S_GE:          "ASR.S.GE",
	ASR_S_LT:          "ASR.S.LT",
	ASR_S_GT:          "ASR.S.GT",
	ASR_S_LE:          "ASR.S.LE",
	ASR_S:             "ASR.S",
	ASR_S_ZZ:          "ASR.S.ZZ",
	B_EQ:              "B.EQ",
	B_NE:              "B.NE",
	B_CS:              "B.CS",
	B_CC:              "B.CC",
	B_MI:              "B.MI",
	B_PL:              "B.PL",
	B_VS:              "B.VS",
	B_VC:              "B.VC",
	B_HI:              "B.HI",
	B_LS:              "B.LS",
	B_GE:              "B.GE",
	B_LT:              "B.LT",
	B_GT:              "B.GT",
	B_LE:              "B.LE",
	B:                 "B",
	B_ZZ:              "B.ZZ",
	BFC_EQ:            "BFC.EQ",
	BFC_NE:            "BFC.NE",
	BFC_CS:            "BFC.CS",
	BFC_CC:            "BFC.CC",
	BFC_MI:            "BFC.MI",
	BFC_PL:            "BFC.PL",
	BFC_VS:            "BFC.VS",
	BFC_VC:            "BFC.VC",
	BFC_HI:            "BFC.HI",
	BFC_LS:            "BFC.LS",
	BFC_GE:            "BFC.GE",
	BFC_LT:            "BFC.LT",
	BFC_GT:            "BFC.GT",
	BFC_LE:            "BFC.LE",
	BFC:               "BFC",
	BFC_ZZ:            "BFC.ZZ",
	BFI_EQ:            "BFI.EQ",
	BFI_NE:            "BFI.NE",
	BFI_CS:            "BFI.CS",
	BFI_CC:            "BFI.CC",
	BFI_MI:            "BFI.MI",
	BFI_PL:            "BFI.PL",
	BFI_VS:            "BFI.VS",
	BFI_VC:            "BFI.VC",
	BFI_HI:            "BFI.HI",
	BFI_LS:            "BFI.LS",
	BFI_GE:            "BFI.GE",
	BFI_LT:            "BFI.LT",
	BFI_GT:            "BFI.GT",
	BFI_LE:            "BFI.LE",
	BFI:               "BFI",
	BFI_ZZ:            "BFI.ZZ",
	BIC_EQ:            "BIC.EQ",
	BIC_NE:            "BIC.NE",
	BIC_CS:            "BIC.CS",
	BIC_CC:            "BIC.CC",
	BIC_MI:            "BIC.MI",
	BIC_PL:            "BIC.PL",
	BIC_VS:            "BIC.VS",
	BIC_VC:            "BIC.VC",
	BIC_HI:            "BIC.HI",
	BIC_LS:            "BIC.LS",
	BIC_GE:            "BIC.GE",
	BIC_LT:            "BIC.LT",
	BIC_GT:            "BIC.GT",
	BIC_LE:            "BIC.LE",
	BIC:               "BIC",
	BIC_ZZ:            "BIC.ZZ",
	BIC_S_EQ:          "BIC.S.EQ",
	BIC_S_NE:          "BIC.S.NE",
	BIC_S_CS:          "BIC.S.CS",
	BIC_S_CC:          "BIC.S.CC",
	BIC_S_MI:          "BIC.S.MI",
	BIC_S_PL:          "BIC.S.PL",
	BIC_S_VS:          "BIC.S.VS",
	BIC_S_VC:          "BIC.S.VC",
	BIC_S_HI:          "BIC.S.HI",
	BIC_S_LS:          "BIC.S.LS",
	BIC_S_GE:          "BIC.S.GE",
	BIC_S_LT:          "BIC.S.LT",
	BIC_S_GT:          "BIC.S.GT",
	BIC_S_LE:          "BIC.S.LE",
	BIC_S:             "BIC.S",
	BIC_S_ZZ:          "BIC.S.ZZ",
	BKPT_EQ:           "BKPT.EQ",
	BKPT_NE:           "BKPT.NE",
	BKPT_CS:           "BKPT.CS",
	BKPT_CC:           "BKPT.CC",
	BKPT_MI:           "BKPT.MI",
	BKPT_PL:           "BKPT.PL",
	BKPT_VS:           "BKPT.VS",
	BKPT_VC:           "BKPT.VC",
	BKPT_HI:           "BKPT.HI",
	BKPT_LS:           "BKPT.LS",
	BKPT_GE:           "BKPT.GE",
	BKPT_LT:           "BKPT.LT",
	BKPT_GT:           "BKPT.GT",
	BKPT_LE:           "BKPT.LE",
	BKPT:              "BKPT",
	BKPT_ZZ:           "BKPT.ZZ",
	BL_EQ:             "BL.EQ",
	BL_NE:             "BL.NE",
	BL_CS:             "BL.CS",
	BL_CC:             "BL.CC",
	BL_MI:             "BL.MI",
	BL_PL:             "BL.PL",
	BL_VS:             "BL.VS",
	BL_VC:             "BL.VC",
	BL_HI:             "BL.HI",
	BL_LS:             "BL.LS",
	BL_GE:             "BL.GE",
	BL_LT:             "BL.LT",
	BL_GT:             "BL.GT",
	BL_LE:             "BL.LE",
	BL:                "BL",
	BL_ZZ:             "BL.ZZ",
	BLX_EQ:            "BLX.EQ",
	BLX_NE:            "BLX.NE",
	BLX_CS:            "BLX.CS",
	BLX_CC:            "BLX.CC",
	BLX_MI:            "BLX.MI",
	BLX_PL:            "BLX.PL",
	BLX_VS:            "BLX.VS",
	BLX_VC:            "BLX.VC",
	BLX_HI:            "BLX.HI",
	BLX_LS:            "BLX.LS",
	BLX_GE:            "BLX.GE",
	BLX_LT:            "BLX.LT",
	BLX_GT:            "BLX.GT",
	BLX_LE:            "BLX.LE",
	BLX:               "BLX",
	BLX_ZZ:            "BLX.ZZ",
	BX_EQ:             "BX.EQ",
	BX_NE:             "BX.NE",
	BX_CS:             "BX.CS",
	BX_CC:             "BX.CC",
	BX_MI:             "BX.MI",
	BX_PL:             "BX.PL",
	BX_VS:             "BX.VS",
	BX_VC:             "BX.VC",
	BX_HI:             "BX.HI",
	BX_LS:             "BX.LS",
	BX_GE:             "BX.GE",
	BX_LT:             "BX.LT",
	BX_GT:             "BX.GT",
	BX_LE:             "BX.LE",
	BX:                "BX",
	BX_ZZ:             "BX.ZZ",
	BXJ_EQ:            "BXJ.EQ",
	BXJ_NE:            "BXJ.NE",
	BXJ_CS:            "BXJ.CS",
	BXJ_CC:            "BXJ.CC",
	BXJ_MI:            "BXJ.MI",
	BXJ_PL:            "BXJ.PL",
	BXJ_VS:            "BXJ.VS",
	BXJ_VC:            "BXJ.VC",
	BXJ_HI:            "BXJ.HI",
	BXJ_LS:            "BXJ.LS",
	BXJ_GE:            "BXJ.GE",
	BXJ_LT:            "BXJ.LT",
	BXJ_GT:            "BXJ.GT",
	BXJ_LE:            "BXJ.LE",
	BXJ:               "BXJ",
	BXJ_ZZ:            "BXJ.ZZ",
	CLREX:             "CLREX",
	CLZ_EQ:            "CLZ.EQ",
	CLZ_NE:            "CLZ.NE",
	CLZ_CS:            "CLZ.CS",
	CLZ_CC:            "CLZ.CC",
	CLZ_MI:            "CLZ.MI",
	CLZ_PL:            "CLZ.PL",
	CLZ_VS:            "CLZ.VS",
	CLZ_VC:            "CLZ.VC",
	CLZ_HI:            "CLZ.HI",
	CLZ_LS:            "CLZ.LS",
	CLZ_GE:            "CLZ.GE",
	CLZ_LT:            "CLZ.LT",
	CLZ_GT:            "CLZ.GT",
	CLZ_LE:            "CLZ.LE",
	CLZ:               "CLZ",
	CLZ_ZZ:            "CLZ.ZZ",
	CMN_EQ:            "CMN.EQ",
	CMN_NE:            "CMN.NE",
	CMN_CS:            "CMN.CS",
	CMN_CC:            "CMN.CC",
	CMN_MI:            "CMN.MI",
	CMN_PL:            "CMN.PL",
	CMN_VS:            "CMN.VS",
	CMN_VC:            "CMN.VC",
	CMN_HI:            "CMN.HI",
	CMN_LS:            "CMN.LS",
	CMN_GE:            "CMN.GE",
	CMN_LT:            "CMN.LT",
	CMN_GT:            "CMN.GT",
	CMN_LE:            "CMN.LE",
	CMN:               "CMN",
	CMN_ZZ:            "CMN.ZZ",
	CMP_EQ:            "CMP.EQ",
	CMP_NE:            "CMP.NE",
	CMP_CS:            "CMP.CS",
	CMP_CC:            "CMP.CC",
	CMP_MI:            "CMP.MI",
	CMP_PL:            "CMP.PL",
	CMP_VS:            "CMP.VS",
	CMP_VC:            "CMP.VC",
	CMP_HI:            "CMP.HI",
	CMP_LS:            "CMP.LS",
	CMP_GE:            "CMP.GE",
	CMP_LT:            "CMP.LT",
	CMP_GT:            "CMP.GT",
	CMP_LE:            "CMP.LE",
	CMP:               "CMP",
	CMP_ZZ:            "CMP.ZZ",
	DBG_EQ:            "DBG.EQ",
	DBG_NE:            "DBG.NE",
	DBG_CS:            "DBG.CS",
	DBG_CC:            "DBG.CC",
	DBG_MI:            "DBG.MI",
	DBG_PL:            "DBG.PL",
	DBG_VS:            "DBG.VS",
	DBG_VC:            "DBG.VC",
	DBG_HI:            "DBG.HI",
	DBG_LS:            "DBG.LS",
	DBG_GE:            "DBG.GE",
	DBG_LT:            "DBG.LT",
	DBG_GT:            "DBG.GT",
	DBG_LE:            "DBG.LE",
	DBG:               "DBG",
	DBG_ZZ:            "DBG.ZZ",
	DMB:               "DMB",
	DSB:               "DSB",
	EOR_EQ:            "EOR.EQ",
	EOR_NE:            "EOR.NE",
	EOR_CS:            "EOR.CS",
	EOR_CC:            "EOR.CC",
	EOR_MI:            "EOR.MI",
	EOR_PL:            "EOR.PL",
	EOR_VS:            "EOR.VS",
	EOR_VC:            "EOR.VC",
	EOR_HI:            "EOR.HI",
	EOR_LS:            "EOR.LS",
	EOR_GE:            "EOR.GE",
	EOR_LT:            "EOR.LT",
	EOR_GT:            "EOR.GT",
	EOR_LE:            "EOR.LE",
	EOR:               "EOR",
	EOR_ZZ:            "EOR.ZZ",
	EOR_S_EQ:          "EOR.S.EQ",
	EOR_S_NE:          "EOR.S.NE",
	EOR_S_CS:          "EOR.S.CS",
	EOR_S_CC:          "EOR.S.CC",
	EOR_S_MI:          "EOR.S.MI",
	EOR_S_PL:          "EOR.S.PL",
	EOR_S_VS:          "EOR.S.VS",
	EOR_S_VC:          "EOR.S.VC",
	EOR_S_HI:          "EOR.S.HI",
	EOR_S_LS:          "EOR.S.LS",
	EOR_S_GE:          "EOR.S.GE",
	EOR_S_LT:          "EOR.S.LT",
	EOR_S_GT:          "EOR.S.GT",
	EOR_S_LE:          "EOR.S.LE",
	EOR_S:             "EOR.S",
	EOR_S_ZZ:          "EOR.S.ZZ",
	ISB:               "ISB",
	LDM_EQ:            "LDM.EQ",
	LDM_NE:            "LDM.NE",
	LDM_CS:            "LDM.CS",
	LDM_CC:            "LDM.CC",
	LDM_MI:            "LDM.MI",
	LDM_PL:            "LDM.PL",
	LDM_VS:            "LDM.VS",
	LDM_VC:            "LDM.VC",
	LDM_HI:            "LDM.HI",
	LDM_LS:            "LDM.LS",
	LDM_GE:            "LDM.GE",
	LDM_LT:            "LDM.LT",
	LDM_GT:            "LDM.GT",
	LDM_LE:            "LDM.LE",
	LDM:               "LDM",
	LDM_ZZ:            "LDM.ZZ",
	LDMDA_EQ:          "LDMDA.EQ",
	LDMDA_NE:          "LDMDA.NE",
	LDMDA_CS:          "LDMDA.CS",
	LDMDA_CC:          "LDMDA.CC",
	LDMDA_MI:          "LDMDA.MI",
	LDMDA_PL:          "LDMDA.PL",
	LDMDA_VS:          "LDMDA.VS",
	LDMDA_VC:          "LDMDA.VC",
	LDMDA_HI:          "LDMDA.HI",
	LDMDA_LS:          "LDMDA.LS",
	LDMDA_GE:          "LDMDA.GE",
	LDMDA_LT:          "LDMDA.LT",
	LDMDA_GT:          "LDMDA.GT",
	LDMDA_LE:          "LDMDA.LE",
	LDMDA:             "LDMDA",
	LDMDA_ZZ:          "LDMDA.ZZ",
	LDMDB_EQ:          "LDMDB.EQ",
	LDMDB_NE:          "LDMDB.NE",
	LDMDB_CS:          "LDMDB.CS",
	LDMDB_CC:          "LDMDB.CC",
	LDMDB_MI:          "LDMDB.MI",
	LDMDB_PL:          "LDMDB.PL",
	LDMDB_VS:          "LDMDB.VS",
	LDMDB_VC:          "LDMDB.VC",
	LDMDB_HI:          "LDMDB.HI",
	LDMDB_LS:          "LDMDB.LS",
	LDMDB_GE:          "LDMDB.GE",
	LDMDB_LT:          "LDMDB.LT",
	LDMDB_GT:          "LDMDB.GT",
	LDMDB_LE:          "LDMDB.LE",
	LDMDB:             "LDMDB",
	LDMDB_ZZ:          "LDMDB.ZZ",
	LDMIB_EQ:          "LDMIB.EQ",
	LDMIB_NE:          "LDMIB.NE",
	LDMIB_CS:          "LDMIB.CS",
	LDMIB_CC:          "LDMIB.CC",
	LDMIB_MI:          "LDMIB.MI",
	LDMIB_PL:          "LDMIB.PL",
	LDMIB_VS:          "LDMIB.VS",
	LDMIB_VC:          "LDMIB.VC",
	LDMIB_HI:          "LDMIB.HI",
	LDMIB_LS:          "LDMIB.LS",
	LDMIB_GE:          "LDMIB.GE",
	LDMIB_LT:          "LDMIB.LT",
	LDMIB_GT:          "LDMIB.GT",
	LDMIB_LE:          "LDMIB.LE",
	LDMIB:             "LDMIB",
	LDMIB_ZZ:          "LDMIB.ZZ",
	LDR_EQ:            "LDR.EQ",
	LDR_NE:            "LDR.NE",
	LDR_CS:            "LDR.CS",
	LDR_CC:            "LDR.CC",
	LDR_MI:            "LDR.MI",
	LDR_PL:            "LDR.PL",
	LDR_VS:            "LDR.VS",
	LDR_VC:            "LDR.VC",
	LDR_HI:            "LDR.HI",
	LDR_LS:            "LDR.LS",
	LDR_GE:            "LDR.GE",
	LDR_LT:            "LDR.LT",
	LDR_GT:            "LDR.GT",
	LDR_LE:            "LDR.LE",
	LDR:               "LDR",
	LDR_ZZ:            "LDR.ZZ",
	LDRB_EQ:           "LDRB.EQ",
	LDRB_NE:           "LDRB.NE",
	LDRB_CS:           "LDRB.CS",
	LDRB_CC:           "LDRB.CC",
	LDRB_MI:           "LDRB.MI",
	LDRB_PL:           "LDRB.PL",
	LDRB_VS:           "LDRB.VS",
	LDRB_VC:           "LDRB.VC",
	LDRB_HI:           "LDRB.HI",
	LDRB_LS:           "LDRB.LS",
	LDRB_GE:           "LDRB.GE",
	LDRB_LT:           "LDRB.LT",
	LDRB_GT:           "LDRB.GT",
	LDRB_LE:           "LDRB.LE",
	LDRB:              "LDRB",
	LDRB_ZZ:           "LDRB.ZZ",
	LDRBT_EQ:          "LDRBT.EQ",
	LDRBT_NE:          "LDRBT.NE",
	LDRBT_CS:          "LDRBT.CS",
	LDRBT_CC:          "LDRBT.CC",
	LDRBT_MI:          "LDRBT.MI",
	LDRBT_PL:          "LDRBT.PL",
	LDRBT_VS:          "LDRBT.VS",
	LDRBT_VC:          "LDRBT.VC",
	LDRBT_HI:          "LDRBT.HI",
	LDRBT_LS:          "LDRBT.LS",
	LDRBT_GE:          "LDRBT.GE",
	LDRBT_LT:          "LDRBT.LT",
	LDRBT_GT:          "LDRBT.GT",
	LDRBT_LE:          "LDRBT.LE",
	LDRBT:             "LDRBT",
	LDRBT_ZZ:          "LDRBT.ZZ",
	LDRD_EQ:           "LDRD.EQ",
	LDRD_NE:           "LDRD.NE",
	LDRD_CS:           "LDRD.CS",
	LDRD_CC:           "LDRD.CC",
	LDRD_MI:           "LDRD.MI",
	LDRD_PL:           "LDRD.PL",
	LDRD_VS:           "LDRD.VS",
	LDRD_VC:           "LDRD.VC",
	LDRD_HI:           "LDRD.HI",
	LDRD_LS:           "LDRD.LS",
	LDRD_GE:           "LDRD.GE",
	LDRD_LT:           "LDRD.LT",
	LDRD_GT:           "LDRD.GT",
	LDRD_LE:           "LDRD.LE",
	LDRD:              "LDRD",
	LDRD_ZZ:           "LDRD.ZZ",
	LDREX_EQ:          "LDREX.EQ",
	LDREX_NE:          "LDREX.NE",
	LDREX_CS:          "LDREX.CS",
	LDREX_CC:          "LDREX.CC",
	LDREX_MI:          "LDREX.MI",
	LDREX_PL:          "LDREX.PL",
	LDREX_VS:          "LDREX.VS",
	LDREX_VC:          "LDREX.VC",
	LDREX_HI:          "LDREX.HI",
	LDREX_LS:          "LDREX.LS",
	LDREX_GE:          "LDREX.GE",
	LDREX_LT:          "LDREX.LT",
	LDREX_GT:          "LDREX.GT",
	LDREX_LE:          "LDREX.LE",
	LDREX:             "LDREX",
	LDREX_ZZ:          "LDREX.ZZ",
	LDREXB_EQ:         "LDREXB.EQ",
	LDREXB_NE:         "LDREXB.NE",
	LDREXB_CS:         "LDREXB.CS",
	LDREXB_CC:         "LDREXB.CC",
	LDREXB_MI:         "LDREXB.MI",
	LDREXB_PL:         "LDREXB.PL",
	LDREXB_VS:         "LDREXB.VS",
	LDREXB_VC:         "LDREXB.VC",
	LDREXB_HI:         "LDREXB.HI",
	LDREXB_LS:         "LDREXB.LS",
	LDREXB_GE:         "LDREXB.GE",
	LDREXB_LT:         "LDREXB.LT",
	LDREXB_GT:         "LDREXB.GT",
	LDREXB_LE:         "LDREXB.LE",
	LDREXB:            "LDREXB",
	LDREXB_ZZ:         "LDREXB.ZZ",
	LDREXD_EQ:         "LDREXD.EQ",
	LDREXD_NE:         "LDREXD.NE",
	LDREXD_CS:         "LDREXD.CS",
	LDREXD_CC:         "LDREXD.CC",
	LDREXD_MI:         "LDREXD.MI",
	LDREXD_PL:         "LDREXD.PL",
	LDREXD_VS:         "LDREXD.VS",
	LDREXD_VC:         "LDREXD.VC",
	LDREXD_HI:         "LDREXD.HI",
	LDREXD_LS:         "LDREXD.LS",
	LDREXD_GE:         "LDREXD.GE",
	LDREXD_LT:         "LDREXD.LT",
	LDREXD_GT:         "LDREXD.GT",
	LDREXD_LE:         "LDREXD.LE",
	LDREXD:            "LDREXD",
	LDREXD_ZZ:         "LDREXD.ZZ",
	LDREXH_EQ:         "LDREXH.EQ",
	LDREXH_NE:         "LDREXH.NE",
	LDREXH_CS:         "LDREXH.CS",
	LDREXH_CC:         "LDREXH.CC",
	LDREXH_MI:         "LDREXH.MI",
	LDREXH_PL:         "LDREXH.PL",
	LDREXH_VS:         "LDREXH.VS",
	LDREXH_VC:         "LDREXH.VC",
	LDREXH_HI:         "LDREXH.HI",
	LDREXH_LS:         "LDREXH.LS",
	LDREXH_GE:         "LDREXH.GE",
	LDREXH_LT:         "LDREXH.LT",
	LDREXH_GT:         "LDREXH.GT",
	LDREXH_LE:         "LDREXH.LE",
	LDREXH:            "LDREXH",
	LDREXH_ZZ:         "LDREXH.ZZ",
	LDRH_EQ:           "LDRH.EQ",
	LDRH_NE:           "LDRH.NE",
	LDRH_CS:           "LDRH.CS",
	LDRH_CC:           "LDRH.CC",
	LDRH_MI:           "LDRH.MI",
	LDRH_PL:           "LDRH.PL",
	LDRH_VS:           "LDRH.VS",
	LDRH_VC:           "LDRH.VC",
	LDRH_HI:           "LDRH.HI",
	LDRH_LS:           "LDRH.LS",
	LDRH_GE:           "LDRH.GE",
	LDRH_LT:           "LDRH.LT",
	LDRH_GT:           "LDRH.GT",
	LDRH_LE:           "LDRH.LE",
	LDRH:              "LDRH",
	LDRH_ZZ:           "LDRH.ZZ",
	LDRHT_EQ:          "LDRHT.EQ",
	LDRHT_NE:          "LDRHT.NE",
	LDRHT_CS:          "LDRHT.CS",
	LDRHT_CC:          "LDRHT.CC",
	LDRHT_MI:          "LDRHT.MI",
	LDRHT_PL:          "LDRHT.PL",
	LDRHT_VS:          "LDRHT.VS",
	LDRHT_VC:          "LDRHT.VC",
	LDRHT_HI:          "LDRHT.HI",
	LDRHT_LS:          "LDRHT.LS",
	LDRHT_GE:          "LDRHT.GE",
	LDRHT_LT:          "LDRHT.LT",
	LDRHT_GT:          "LDRHT.GT",
	LDRHT_LE:          "LDRHT.LE",
	LDRHT:             "LDRHT",
	LDRHT_ZZ:          "LDRHT.ZZ",
	LDRSB_EQ:          "LDRSB.EQ",
	LDRSB_NE:          "LDRSB.NE",
	LDRSB_CS:          "LDRSB.CS",
	LDRSB_CC:          "LDRSB.CC",
	LDRSB_MI:          "LDRSB.MI",
	LDRSB_PL:          "LDRSB.PL",
	LDRSB_VS:          "LDRSB.VS",
	LDRSB_VC:          "LDRSB.VC",
	LDRSB_HI:          "LDRSB.HI",
	LDRSB_LS:          "LDRSB.LS",
	LDRSB_GE:          "LDRSB.GE",
	LDRSB_LT:          "LDRSB.LT",
	LDRSB_GT:          "LDRSB.GT",
	LDRSB_LE:          "LDRSB.LE",
	LDRSB:             "LDRSB",
	LDRSB_ZZ:          "LDRSB.ZZ",
	LDRSBT_EQ:         "LDRSBT.EQ",
	LDRSBT_NE:         "LDRSBT.NE",
	LDRSBT_CS:         "LDRSBT.CS",
	LDRSBT_CC:         "LDRSBT.CC",
	LDRSBT_MI:         "LDRSBT.MI",
	LDRSBT_PL:         "LDRSBT.PL",
	LDRSBT_VS:         "LDRSBT.VS",
	LDRSBT_VC:         "LDRSBT.VC",
	LDRSBT_HI:         "LDRSBT.HI",
	LDRSBT_LS:         "LDRSBT.LS",
	LDRSBT_GE:         "LDRSBT.GE",
	LDRSBT_LT:         "LDRSBT.LT",
	LDRSBT_GT:         "LDRSBT.GT",
	LDRSBT_LE:         "LDRSBT.LE",
	LDRSBT:            "LDRSBT",
	LDRSBT_ZZ:         "LDRSBT.ZZ",
	LDRSH_EQ:          "LDRSH.EQ",
	LDRSH_NE:          "LDRSH.NE",
	LDRSH_CS:          "LDRSH.CS",
	LDRSH_CC:          "LDRSH.CC",
	LDRSH_MI:          "LDRSH.MI",
	LDRSH_PL:          "LDRSH.PL",
	LDRSH_VS:          "LDRSH.VS",
	LDRSH_VC:          "LDRSH.VC",
	LDRSH_HI:          "LDRSH.HI",
	LDRSH_LS:          "LDRSH.LS",
	LDRSH_GE:          "LDRSH.GE",
	LDRSH_LT:          "LDRSH.LT",
	LDRSH_GT:          "LDRSH.GT",
	LDRSH_LE:          "LDRSH.LE",
	LDRSH:             "LDRSH",
	LDRSH_ZZ:          "LDRSH.ZZ",
	LDRSHT_EQ:         "LDRSHT.EQ",
	LDRSHT_NE:         "LDRSHT.NE",
	LDRSHT_CS:         "LDRSHT.CS",
	LDRSHT_CC:         "LDRSHT.CC",
	LDRSHT_MI:         "LDRSHT.MI",
	LDRSHT_PL:         "LDRSHT.PL",
	LDRSHT_VS:         "LDRSHT.VS",
	LDRSHT_VC:         "LDRSHT.VC",
	LDRSHT_HI:         "LDRSHT.HI",
	LDRSHT_LS:         "LDRSHT.LS",
	LDRSHT_GE:         "LDRSHT.GE",
	LDRSHT_LT:         "LDRSHT.LT",
	LDRSHT_GT:         "LDRSHT.GT",
	LDRSHT_LE:         "LDRSHT.LE",
	LDRSHT:            "LDRSHT",
	LDRSHT_ZZ:         "LDRSHT.ZZ",
	LDRT_EQ:           "LDRT.EQ",
	LDRT_NE:           "LDRT.NE",
	LDRT_CS:           "LDRT.CS",
	LDRT_CC:           "LDRT.CC",
	LDRT_MI:           "LDRT.MI",
	LDRT_PL:           "LDRT.PL",
	LDRT_VS:           "LDRT.VS",
	LDRT_VC:           "LDRT.VC",
	LDRT_HI:           "LDRT.HI",
	LDRT_LS:           "LDRT.LS",
	LDRT_GE:           "LDRT.GE",
	LDRT_LT:           "LDRT.LT",
	LDRT_GT:           "LDRT.GT",
	LDRT_LE:           "LDRT.LE",
	LDRT:              "LDRT",
	LDRT_ZZ:           "LDRT.ZZ",
	LSL_EQ:            "LSL.EQ",
	LSL_NE:            "LSL.NE",
	LSL_CS:            "LSL.CS",
	LSL_CC:            "LSL.CC",
	LSL_MI:            "LSL.MI",
	LSL_PL:            "LSL.PL",
	LSL_VS:            "LSL.VS",
	LSL_VC:            "LSL.VC",
	LSL_HI:            "LSL.HI",
	LSL_LS:            "LSL.LS",
	LSL_GE:            "LSL.GE",
	LSL_LT:            "LSL.LT",
	LSL_GT:            "LSL.GT",
	LSL_LE:            "LSL.LE",
	LSL:               "LSL",
	LSL_ZZ:            "LSL.ZZ",
	LSL_S_EQ:          "LSL.S.EQ",
	LSL_S_NE:          "LSL.S.NE",
	LSL_S_CS:          "LSL.S.CS",
	LSL_S_CC:          "LSL.S.CC",
	LSL_S_MI:          "LSL.S.MI",
	LSL_S_PL:          "LSL.S.PL",
	LSL_S_VS:          "LSL.S.VS",
	LSL_S_VC:          "LSL.S.VC",
	LSL_S_HI:          "LSL.S.HI",
	LSL_S_LS:          "LSL.S.LS",
	LSL_S_GE:          "LSL.S.GE",
	LSL_S_LT:          "LSL.S.LT",
	LSL_S_GT:          "LSL.S.GT",
	LSL_S_LE:          "LSL.S.LE",
	LSL_S:             "LSL.S",
	LSL_S_ZZ:          "LSL.S.ZZ",
	LSR_EQ:            "LSR.EQ",
	LSR_NE:            "LSR.NE",
	LSR_CS:            "LSR.CS",
	LSR_CC:            "LSR.CC",
	LSR_MI:            "LSR.MI",
	LSR_PL:            "LSR.PL",
	LSR_VS:            "LSR.VS",
	LSR_VC:            "LSR.VC",
	LSR_HI:            "LSR.HI",
	LSR_LS:            "LSR.LS",
	LSR_GE:            "LSR.GE",
	LSR_LT:            "LSR.LT",
	LSR_GT:            "LSR.GT",
	LSR_LE:            "LSR.LE",
	LSR:               "LSR",
	LSR_ZZ:            "LSR.ZZ",
	LSR_S_EQ:          "LSR.S.EQ",
	LSR_S_NE:          "LSR.S.NE",
	LSR_S_CS:          "LSR.S.CS",
	LSR_S_CC:          "LSR.S.CC",
	LSR_S_MI:          "LSR.S.MI",
	LSR_S_PL:          "LSR.S.PL",
	LSR_S_VS:          "LSR.S.VS",
	LSR_S_VC:          "LSR.S.VC",
	LSR_S_HI:          "LSR.S.HI",
	LSR_S_LS:          "LSR.S.LS",
	LSR_S_GE:          "LSR.S.GE",
	LSR_S_LT:          "LSR.S.LT",
	LSR_S_GT:          "LSR.S.GT",
	LSR_S_LE:          "LSR.S.LE",
	LSR_S:             "LSR.S",
	LSR_S_ZZ:          "LSR.S.ZZ",
	MLA_EQ:            "MLA.EQ",
	MLA_NE:            "MLA.NE",
	MLA_CS:            "MLA.CS",
	MLA_CC:            "MLA.CC",
	MLA_MI:            "MLA.MI",
	MLA_PL:            "MLA.PL",
	MLA_VS:            "MLA.VS",
	MLA_VC:            "MLA.VC",
	MLA_HI:            "MLA.HI",
	MLA_LS:            "MLA.LS",
	MLA_GE:            "MLA.GE",
	MLA_LT:            "MLA.LT",
	MLA_GT:            "MLA.GT",
	MLA_LE:            "MLA.LE",
	MLA:               "MLA",
	MLA_ZZ:            "MLA.ZZ",
	MLA_S_EQ:          "MLA.S.EQ",
	MLA_S_NE:          "MLA.S.NE",
	MLA_S_CS:          "MLA.S.CS",
	MLA_S_CC:          "MLA.S.CC",
	MLA_S_MI:          "MLA.S.MI",
	MLA_S_PL:          "MLA.S.PL",
	MLA_S_VS:          "MLA.S.VS",
	MLA_S_VC:          "MLA.S.VC",
	MLA_S_HI:          "MLA.S.HI",
	MLA_S_LS:          "MLA.S.LS",
	MLA_S_GE:          "MLA.S.GE",
	MLA_S_LT:          "MLA.S.LT",
	MLA_S_GT:          "MLA.S.GT",
	MLA_S_LE:          "MLA.S.LE",
	MLA_S:             "MLA.S",
	MLA_S_ZZ:          "MLA.S.ZZ",
	MLS_EQ:            "MLS.EQ",
	MLS_NE:            "MLS.NE",
	MLS_CS:            "MLS.CS",
	MLS_CC:            "MLS.CC",
	MLS_MI:            "MLS.MI",
	MLS_PL:            "MLS.PL",
	MLS_VS:            "MLS.VS",
	MLS_VC:            "MLS.VC",
	MLS_HI:            "MLS.HI",
	MLS_LS:            "MLS.LS",
	MLS_GE:            "MLS.GE",
	MLS_LT:            "MLS.LT",
	MLS_GT:            "MLS.GT",
	MLS_LE:            "MLS.LE",
	MLS:               "MLS",
	MLS_ZZ:            "MLS.ZZ",
	MOV_EQ:            "MOV.EQ",
	MOV_NE:            "MOV.NE",
	MOV_CS:            "MOV.CS",
	MOV_CC:            "MOV.CC",
	MOV_MI:            "MOV.MI",
	MOV_PL:            "MOV.PL",
	MOV_VS:            "MOV.VS",
	MOV_VC:            "MOV.VC",
	MOV_HI:            "MOV.HI",
	MOV_LS:            "MOV.LS",
	MOV_GE:            "MOV.GE",
	MOV_LT:            "MOV.LT",
	MOV_GT:            "MOV.GT",
	MOV_LE:            "MOV.LE",
	MOV:               "MOV",
	MOV_ZZ:            "MOV.ZZ",
	MOV_S_EQ:          "MOV.S.EQ",
	MOV_S_NE:          "MOV.S.NE",
	MOV_S_CS:          "MOV.S.CS",
	MOV_S_CC:          "MOV.S.CC",
	MOV_S_MI:          "MOV.S.MI",
	MOV_S_PL:          "MOV.S.PL",
	MOV_S_VS:          "MOV.S.VS",
	MOV_S_VC:          "MOV.S.VC",
	MOV_S_HI:          "MOV.S.HI",
	MOV_S_LS:          "MOV.S.LS",
	MOV_S_GE:          "MOV.S.GE",
	MOV_S_LT:          "MOV.S.LT",
	MOV_S_GT:          "MOV.S.GT",
	MOV_S_LE:          "MOV.S.LE",
	MOV_S:             "MOV.S",
	MOV_S_ZZ:          "MOV.S.ZZ",
	MOVT_EQ:           "MOVT.EQ",
	MOVT_NE:           "MOVT.NE",
	MOVT_CS:           "MOVT.CS",
	MOVT_CC:           "MOVT.CC",
	MOVT_MI:           "MOVT.MI",
	MOVT_PL:           "MOVT.PL",
	MOVT_VS:           "MOVT.VS",
	MOVT_VC:           "MOVT.VC",
	MOVT_HI:           "MOVT.HI",
	MOVT_LS:           "MOVT.LS",
	MOVT_GE:           "MOVT.GE",
	MOVT_LT:           "MOVT.LT",
	MOVT_GT:           "MOVT.GT",
	MOVT_LE:           "MOVT.LE",
	MOVT:              "MOVT",
	MOVT_ZZ:           "MOVT.ZZ",
	MOVW_EQ:           "MOVW.EQ",
	MOVW_NE:           "MOVW.NE",
	MOVW_CS:           "MOVW.CS",
	MOVW_CC:           "MOVW.CC",
	MOVW_MI:           "MOVW.MI",
	MOVW_PL:           "MOVW.PL",
	MOVW_VS:           "MOVW.VS",
	MOVW_VC:           "MOVW.VC",
	MOVW_HI:           "MOVW.HI",
	MOVW_LS:           "MOVW.LS",
	MOVW_GE:           "MOVW.GE",
	MOVW_LT:           "MOVW.LT",
	MOVW_GT:           "MOVW.GT",
	MOVW_LE:           "MOVW.LE",
	MOVW:              "MOVW",
	MOVW_ZZ:           "MOVW.ZZ",
	MRS_EQ:            "MRS.EQ",
	MRS_NE:            "MRS.NE",
	MRS_CS:            "MRS.CS",
	MRS_CC:            "MRS.CC",
	MRS_MI:            "MRS.MI",
	MRS_PL:            "MRS.PL",
	MRS_VS:            "MRS.VS",
	MRS_VC:            "MRS.VC",
	MRS_HI:            "MRS.HI",
	MRS_LS:            "MRS.LS",
	MRS_GE:            "MRS.GE",
	MRS_LT:            "MRS.LT",
	MRS_GT:            "MRS.GT",
	MRS_LE:            "MRS.LE",
	MRS:               "MRS",
	MRS_ZZ:            "MRS.ZZ",
	MUL_EQ:            "MUL.EQ",
	MUL_NE:            "MUL.NE",
	MUL_CS:            "MUL.CS",
	MUL_CC:            "MUL.CC",
	MUL_MI:            "MUL.MI",
	MUL_PL:            "MUL.PL",
	MUL_VS:            "MUL.VS",
	MUL_VC:            "MUL.VC",
	MUL_HI:            "MUL.HI",
	MUL_LS:            "MUL.LS",
	MUL_GE:            "MUL.GE",
	MUL_LT:            "MUL.LT",
	MUL_GT:            "MUL.GT",
	MUL_LE:            "MUL.LE",
	MUL:               "MUL",
	MUL_ZZ:            "MUL.ZZ",
	MUL_S_EQ:          "MUL.S.EQ",
	MUL_S_NE:          "MUL.S.NE",
	MUL_S_CS:          "MUL.S.CS",
	MUL_S_CC:          "MUL.S.CC",
	MUL_S_MI:          "MUL.S.MI",
	MUL_S_PL:          "MUL.S.PL",
	MUL_S_VS:          "MUL.S.VS",
	MUL_S_VC:          "MUL.S.VC",
	MUL_S_HI:          "MUL.S.HI",
	MUL_S_LS:          "MUL.S.LS",
	MUL_S_GE:          "MUL.S.GE",
	MUL_S_LT:          "MUL.S.LT",
	MUL_S_GT:          "MUL.S.GT",
	MUL_S_LE:          "MUL.S.LE",
	MUL_S:             "MUL.S",
	MUL_S_ZZ:          "MUL.S.ZZ",
	MVN_EQ:            "MVN.EQ",
	MVN_NE:            "MVN.NE",
	MVN_CS:            "MVN.CS",
	MVN_CC:            "MVN.CC",
	MVN_MI:            "MVN.MI",
	MVN_PL:            "MVN.PL",
	MVN_VS:            "MVN.VS",
	MVN_VC:            "MVN.VC",
	MVN_HI:            "MVN.HI",
	MVN_LS:            "MVN.LS",
	MVN_GE:            "MVN.GE",
	MVN_LT:            "MVN.LT",
	MVN_GT:            "MVN.GT",
	MVN_LE:            "MVN.LE",
	MVN:               "MVN",
	MVN_ZZ:            "MVN.ZZ",
	MVN_S_EQ:          "MVN.S.EQ",
	MVN_S_NE:          "MVN.S.NE",
	MVN_S_CS:          "MVN.S.CS",
	MVN_S_CC:          "MVN.S.CC",
	MVN_S_MI:          "MVN.S.MI",
	MVN_S_PL:          "MVN.S.PL",
	MVN_S_VS:          "MVN.S.VS",
	MVN_S_VC:          "MVN.S.VC",
	MVN_S_HI:          "MVN.S.HI",
	MVN_S_LS:          "MVN.S.LS",
	MVN_S_GE:          "MVN.S.GE",
	MVN_S_LT:          "MVN.S.LT",
	MVN_S_GT:          "MVN.S.GT",
	MVN_S_LE:          "MVN.S.LE",
	MVN_S:             "MVN.S",
	MVN_S_ZZ:          "MVN.S.ZZ",
	NOP_EQ:            "NOP.EQ",
	NOP_NE:            "NOP.NE",
	NOP_CS:            "NOP.CS",
	NOP_CC:            "NOP.CC",
	NOP_MI:            "NOP.MI",
	NOP_PL:            "NOP.PL",
	NOP_VS:            "NOP.VS",
	NOP_VC:            "NOP.VC",
	NOP_HI:            "NOP.HI",
	NOP_LS:            "NOP.LS",
	NOP_GE:            "NOP.GE",
	NOP_LT:            "NOP.LT",
	NOP_GT:            "NOP.GT",
	NOP_LE:            "NOP.LE",
	NOP:               "NOP",
	NOP_ZZ:            "NOP.ZZ",
	ORR_EQ:            "ORR.EQ",
	ORR_NE:            "ORR.NE",
	ORR_CS:            "ORR.CS",
	ORR_CC:            "ORR.CC",
	ORR_MI:            "ORR.MI",
	ORR_PL:            "ORR.PL",
	ORR_VS:            "ORR.VS",
	ORR_VC:            "ORR.VC",
	ORR_HI:            "ORR.HI",
	ORR_LS:            "ORR.LS",
	ORR_GE:            "ORR.GE",
	ORR_LT:            "ORR.LT",
	ORR_GT:            "ORR.GT",
	ORR_LE:            "ORR.LE",
	ORR:               "ORR",
	ORR_ZZ:            "ORR.ZZ",
	ORR_S_EQ:          "ORR.S.EQ",
	ORR_S_NE:          "ORR.S.NE",
	ORR_S_CS:          "ORR.S.CS",
	ORR_S_CC:          "ORR.S.CC",
	ORR_S_MI:          "ORR.S.MI",
	ORR_S_PL:          "ORR.S.PL",
	ORR_S_VS:          "ORR.S.VS",
	ORR_S_VC:          "ORR.S.VC",
	ORR_S_HI:          "ORR.S.HI",
	ORR_S_LS:          "ORR.S.LS",
	ORR_S_GE:          "ORR.S.GE",
	ORR_S_LT:          "ORR.S.LT",
	ORR_S_GT:          "ORR.S.GT",
	ORR_S_LE:          "ORR.S.LE",
	ORR_S:             "ORR.S",
	ORR_S_ZZ:          "ORR.S.ZZ",
	PKHBT_EQ:          "PKHBT.EQ",
	PKHBT_NE:          "PKHBT.NE",
	PKHBT_CS:          "PKHBT.CS",
	PKHBT_CC:          "PKHBT.CC",
	PKHBT_MI:          "PKHBT.MI",
	PKHBT_PL:          "PKHBT.PL",
	PKHBT_VS:          "PKHBT.VS",
	PKHBT_VC:          "PKHBT.VC",
	PKHBT_HI:          "PKHBT.HI",
	PKHBT_LS:          "PKHBT.LS",
	PKHBT_GE:          "PKHBT.GE",
	PKHBT_LT:          "PKHBT.LT",
	PKHBT_GT:          "PKHBT.GT",
	PKHBT_LE:          "PKHBT.LE",
	PKHBT:             "PKHBT",
	PKHBT_ZZ:          "PKHBT.ZZ",
	PKHTB_EQ:          "PKHTB.EQ",
	PKHTB_NE:          "PKHTB.NE",
	PKHTB_CS:          "PKHTB.CS",
	PKHTB_CC:          "PKHTB.CC",
	PKHTB_MI:          "PKHTB.MI",
	PKHTB_PL:          "PKHTB.PL",
	PKHTB_VS:          "PKHTB.VS",
	PKHTB_VC:          "PKHTB.VC",
	PKHTB_HI:          "PKHTB.HI",
	PKHTB_LS:          "PKHTB.LS",
	PKHTB_GE:          "PKHTB.GE",
	PKHTB_LT:          "PKHTB.LT",
	PKHTB_GT:          "PKHTB.GT",
	PKHTB_LE:          "PKHTB.LE",
	PKHTB:             "PKHTB",
	PKHTB_ZZ:          "PKHTB.ZZ",
	PLD_W:             "PLD.W",
	PLD:               "PLD",
	PLI:               "PLI",
	POP_EQ:            "POP.EQ",
	POP_NE:            "POP.NE",
	POP_CS:            "POP.CS",
	POP_CC:            "POP.CC",
	POP_MI:            "POP.MI",
	POP_PL:            "POP.PL",
	POP_VS:            "POP.VS",
	POP_VC:            "POP.VC",
	POP_HI:            "POP.HI",
	POP_LS:            "POP.LS",
	POP_GE:            "POP.GE",
	POP_LT:            "POP.LT",
	POP_GT:            "POP.GT",
	POP_LE:            "POP.LE",
	POP:               "POP",
	POP_ZZ:            "POP.ZZ",
	PUSH_EQ:           "PUSH.EQ",
	PUSH_NE:           "PUSH.NE",
	PUSH_CS:           "PUSH.CS",
	PUSH_CC:           "PUSH.CC",
	PUSH_MI:           "PUSH.MI",
	PUSH_PL:           "PUSH.PL",
	PUSH_VS:           "PUSH.VS",
	PUSH_VC:           "PUSH.VC",
	PUSH_HI:           "PUSH.HI",
	PUSH_LS:           "PUSH.LS",
	PUSH_GE:           "PUSH.GE",
	PUSH_LT:           "PUSH.LT",
	PUSH_GT:           "PUSH.GT",
	PUSH_LE:           "PUSH.LE",
	PUSH:              "PUSH",
	PUSH_ZZ:           "PUSH.ZZ",
	QADD_EQ:           "QADD.EQ",
	QADD_NE:           "QADD.NE",
	QADD_CS:           "QADD.CS",
	QADD_CC:           "QADD.CC",
	QADD_MI:           "QADD.MI",
	QADD_PL:           "QADD.PL",
	QADD_VS:           "QADD.VS",
	QADD_VC:           "QADD.VC",
	QADD_HI:           "QADD.HI",
	QADD_LS:           "QADD.LS",
	QADD_GE:           "QADD.GE",
	QADD_LT:           "QADD.LT",
	QADD_GT:           "QADD.GT",
	QADD_LE:           "QADD.LE",
	QADD:              "QADD",
	QADD_ZZ:           "QADD.ZZ",
	QADD16_EQ:         "QADD16.EQ",
	QADD16_NE:         "QADD16.NE",
	QADD16_CS:         "QADD16.CS",
	QADD16_CC:         "QADD16.CC",
	QADD16_MI:         "QADD16.MI",
	QADD16_PL:         "QADD16.PL",
	QADD16_VS:         "QADD16.VS",
	QADD16_VC:         "QADD16.VC",
	QADD16_HI:         "QADD16.HI",
	QADD16_LS:         "QADD16.LS",
	QADD16_GE:         "QADD16.GE",
	QADD16_LT:         "QADD16.LT",
	QADD16_GT:         "QADD16.GT",
	QADD16_LE:         "QADD16.LE",
	QADD16:            "QADD16",
	QADD16_ZZ:         "QADD16.ZZ",
	QADD8_EQ:          "QADD8.EQ",
	QADD8_NE:          "QADD8.NE",
	QADD8_CS:          "QADD8.CS",
	QADD8_CC:          "QADD8.CC",
	QADD8_MI:          "QADD8.MI",
	QADD8_PL:          "QADD8.PL",
	QADD8_VS:          "QADD8.VS",
	QADD8_VC:          "QADD8.VC",
	QADD8_HI:          "QADD8.HI",
	QADD8_LS:          "QADD8.LS",
	QADD8_GE:          "QADD8.GE",
	QADD8_LT:          "QADD8.LT",
	QADD8_GT:          "QADD8.GT",
	QADD8_LE:          "QADD8.LE",
	QADD8:             "QADD8",
	QADD8_ZZ:          "QADD8.ZZ",
	QASX_EQ:           "QASX.EQ",
	QASX_NE:           "QASX.NE",
	QASX_CS:           "QASX.CS",
	QASX_CC:           "QASX.CC",
	QASX_MI:           "QASX.MI",
	QASX_PL:           "QASX.PL",
	QASX_VS:           "QASX.VS",
	QASX_VC:           "QASX.VC",
	QASX_HI:           "QASX.HI",
	QASX_LS:           "QASX.LS",
	QASX_GE:           "QASX.GE",
	QASX_LT:           "QASX.LT",
	QASX_GT:           "QASX.GT",
	QASX_LE:           "QASX.LE",
	QASX:              "QASX",
	QASX_ZZ:           "QASX.ZZ",
	QDADD_EQ:          "QDADD.EQ",
	QDADD_NE:          "QDADD.NE",
	QDADD_CS:          "QDADD.CS",
	QDADD_CC:          "QDADD.CC",
	QDADD_MI:          "QDADD.MI",
	QDADD_PL:          "QDADD.PL",
	QDADD_VS:          "QDADD.VS",
	QDADD_VC:          "QDADD.VC",
	QDADD_HI:          "QDADD.HI",
	QDADD_LS:          "QDADD.LS",
	QDADD_GE:          "QDADD.GE",
	QDADD_LT:          "QDADD.LT",
	QDADD_GT:          "QDADD.GT",
	QDADD_LE:          "QDADD.LE",
	QDADD:             "QDADD",
	QDADD_ZZ:          "QDADD.ZZ",
	QDSUB_EQ:          "QDSUB.EQ",
	QDSUB_NE:          "QDSUB.NE",
	QDSUB_CS:          "QDSUB.CS",
	QDSUB_CC:          "QDSUB.CC",
	QDSUB_MI:          "QDSUB.MI",
	QDSUB_PL:          "QDSUB.PL",
	QDSUB_VS:          "QDSUB.VS",
	QDSUB_VC:          "QDSUB.VC",
	QDSUB_HI:          "QDSUB.HI",
	QDSUB_LS:          "QDSUB.LS",
	QDSUB_GE:          "QDSUB.GE",
	QDSUB_LT:          "QDSUB.LT",
	QDSUB_GT:          "QDSUB.GT",
	QDSUB_LE:          "QDSUB.LE",
	QDSUB:             "QDSUB",
	QDSUB_ZZ:          "QDSUB.ZZ",
	QSAX_EQ:           "QSAX.EQ",
	QSAX_NE:           "QSAX.NE",
	QSAX_CS:           "QSAX.CS",
	QSAX_CC:           "QSAX.CC",
	QSAX_MI:           "QSAX.MI",
	QSAX_PL:           "QSAX.PL",
	QSAX_VS:           "QSAX.VS",
	QSAX_VC:           "QSAX.VC",
	QSAX_HI:           "QSAX.HI",
	QSAX_LS:           "QSAX.LS",
	QSAX_GE:           "QSAX.GE",
	QSAX_LT:           "QSAX.LT",
	QSAX_GT:           "QSAX.GT",
	QSAX_LE:           "QSAX.LE",
	QSAX:              "QSAX",
	QSAX_ZZ:           "QSAX.ZZ",
	QSUB_EQ:           "QSUB.EQ",
	QSUB_NE:           "QSUB.NE",
	QSUB_CS:           "QSUB.CS",
	QSUB_CC:           "QSUB.CC",
	QSUB_MI:           "QSUB.MI",
	QSUB_PL:           "QSUB.PL",
	QSUB_VS:           "QSUB.VS",
	QSUB_VC:           "QSUB.VC",
	QSUB_HI:           "QSUB.HI",
	QSUB_LS:           "QSUB.LS",
	QSUB_GE:           "QSUB.GE",
	QSUB_LT:           "QSUB.LT",
	QSUB_GT:           "QSUB.GT",
	QSUB_LE:           "QSUB.LE",
	QSUB:              "QSUB",
	QSUB_ZZ:           "QSUB.ZZ",
	QSUB16_EQ:         "QSUB16.EQ",
	QSUB16_NE:         "QSUB16.NE",
	QSUB16_CS:         "QSUB16.CS",
	QSUB16_CC:         "QSUB16.CC",
	QSUB16_MI:         "QSUB16.MI",
	QSUB16_PL:         "QSUB16.PL",
	QSUB16_VS:         "QSUB16.VS",
	QSUB16_VC:         "QSUB16.VC",
	QSUB16_HI:         "QSUB16.HI",
	QSUB16_LS:         "QSUB16.LS",
	QSUB16_GE:         "QSUB16.GE",
	QSUB16_LT:         "QSUB16.LT",
	QSUB16_GT:         "QSUB16.GT",
	QSUB16_LE:         "QSUB16.LE",
	QSUB16:            "QSUB16",
	QSUB16_ZZ:         "QSUB16.ZZ",
	QSUB8_EQ:          "QSUB8.EQ",
	QSUB8_NE:          "QSUB8.NE",
	QSUB8_CS:          "QSUB8.CS",
	QSUB8_CC:          "QSUB8.CC",
	QSUB8_MI:          "QSUB8.MI",
	QSUB8_PL:          "QSUB8.PL",
	QSUB8_VS:          "QSUB8.VS",
	QSUB8_VC:          "QSUB8.VC",
	QSUB8_HI:          "QSUB8.HI",
	QSUB8_LS:          "QSUB8.LS",
	QSUB8_GE:          "QSUB8.GE",
	QSUB8_LT:          "QSUB8.LT",
	QSUB8_GT:          "QSUB8.GT",
	QSUB8_LE:          "QSUB8.LE",
	QSUB8:             "QSUB8",
	QSUB8_ZZ:          "QSUB8.ZZ",
	RBIT_EQ:           "RBIT.EQ",
	RBIT_NE:           "RBIT.NE",
	RBIT_CS:           "RBIT.CS",
	RBIT_CC:           "RBIT.CC",
	RBIT_MI:           "RBIT.MI",
	RBIT_PL:           "RBIT.PL",
	RBIT_VS:           "RBIT.VS",
	RBIT_VC:           "RBIT.VC",
	RBIT_HI:           "RBIT.HI",
	RBIT_LS:           "RBIT.LS",
	RBIT_GE:           "RBIT.GE",
	RBIT_LT:           "RBIT.LT",
	RBIT_GT:           "RBIT.GT",
	RBIT_LE:           "RBIT.LE",
	RBIT:              "RBIT",
	RBIT_ZZ:           "RBIT.ZZ",
	REV_EQ:            "REV.EQ",
	REV_NE:            "REV.NE",
	REV_CS:            "REV.CS",
	REV_CC:            "REV.CC",
	REV_MI:            "REV.MI",
	REV_PL:            "REV.PL",
	REV_VS:            "REV.VS",
	REV_VC:            "REV.VC",
	REV_HI:            "REV.HI",
	REV_LS:            "REV.LS",
	REV_GE:            "REV.GE",
	REV_LT:            "REV.LT",
	REV_GT:            "REV.GT",
	REV_LE:            "REV.LE",
	REV:               "REV",
	REV_ZZ:            "REV.ZZ",
	REV16_EQ:          "REV16.EQ",
	REV16_NE:          "REV16.NE",
	REV16_CS:          "REV16.CS",
	REV16_CC:          "REV16.CC",
	REV16_MI:          "REV16.MI",
	REV16_PL:          "REV16.PL",
	REV16_VS:          "REV16.VS",
	REV16_VC:          "REV16.VC",
	REV16_HI:          "REV16.HI",
	REV16_LS:          "REV16.LS",
	REV16_GE:          "REV16.GE",
	REV16_LT:          "REV16.LT",
	REV16_GT:          "REV16.GT",
	REV16_LE:          "REV16.LE",
	REV16:             "REV16",
	REV16_ZZ:          "REV16.ZZ",
	REVSH_EQ:          "REVSH.EQ",
	REVSH_NE:          "REVSH.NE",
	REVSH_CS:          "REVSH.CS",
	REVSH_CC:          "REVSH.CC",
	REVSH_MI:          "REVSH.MI",
	REVSH_PL:          "REVSH.PL",
	REVSH_VS:          "REVSH.VS",
	REVSH_VC:          "REVSH.VC",
	REVSH_HI:          "REVSH.HI",
	REVSH_LS:          "REVSH.LS",
	REVSH_GE:          "REVSH.GE",
	REVSH_LT:          "REVSH.LT",
	REVSH_GT:          "REVSH.GT",
	REVSH_LE:          "REVSH.LE",
	REVSH:             "REVSH",
	REVSH_ZZ:          "REVSH.ZZ",
	ROR_EQ:            "ROR.EQ",
	ROR_NE:            "ROR.NE",
	ROR_CS:            "ROR.CS",
	ROR_CC:            "ROR.CC",
	ROR_MI:            "ROR.MI",
	ROR_PL:            "ROR.PL",
	ROR_VS:            "ROR.VS",
	ROR_VC:            "ROR.VC",
	ROR_HI:            "ROR.HI",
	ROR_LS:            "ROR.LS",
	ROR_GE:            "ROR.GE",
	ROR_LT:            "ROR.LT",
	ROR_GT:            "ROR.GT",
	ROR_LE:            "ROR.LE",
	ROR:               "ROR",
	ROR_ZZ:            "ROR.ZZ",
	ROR_S_EQ:          "ROR.S.EQ",
	ROR_S_NE:          "ROR.S.NE",
	ROR_S_CS:          "ROR.S.CS",
	ROR_S_CC:          "ROR.S.CC",
	ROR_S_MI:          "ROR.S.MI",
	ROR_S_PL:          "ROR.S.PL",
	ROR_S_VS:          "ROR.S.VS",
	ROR_S_VC:          "ROR.S.VC",
	ROR_S_HI:          "ROR.S.HI",
	ROR_S_LS:          "ROR.S.LS",
	ROR_S_GE:          "ROR.S.GE",
	ROR_S_LT:          "ROR.S.LT",
	ROR_S_GT:          "ROR.S.GT",
	ROR_S_LE:          "ROR.S.LE",
	ROR_S:             "ROR.S",
	ROR_S_ZZ:          "ROR.S.ZZ",
	RRX_EQ:            "RRX.EQ",
	RRX_NE:            "RRX.NE",
	RRX_CS:            "RRX.CS",
	RRX_CC:            "RRX.CC",
	RRX_MI:            "RRX.MI",
	RRX_PL:            "RRX.PL",
	RRX_VS:            "RRX.VS",
	RRX_VC:            "RRX.VC",
	RRX_HI:            "RRX.HI",
	RRX_LS:            "RRX.LS",
	RRX_GE:            "RRX.GE",
	RRX_LT:            "RRX.LT",
	RRX_GT:            "RRX.GT",
	RRX_LE:            "RRX.LE",
	RRX:               "RRX",
	RRX_ZZ:            "RRX.ZZ",
	RRX_S_EQ:          "RRX.S.EQ",
	RRX_S_NE:          "RRX.S.NE",
	RRX_S_CS:          "RRX.S.CS",
	RRX_S_CC:          "RRX.S.CC",
	RRX_S_MI:          "RRX.S.MI",
	RRX_S_PL:          "RRX.S.PL",
	RRX_S_VS:          "RRX.S.VS",
	RRX_S_VC:          "RRX.S.VC",
	RRX_S_HI:          "RRX.S.HI",
	RRX_S_LS:          "RRX.S.LS",
	RRX_S_GE:          "RRX.S.GE",
	RRX_S_LT:          "RRX.S.LT",
	RRX_S_GT:          "RRX.S.GT",
	RRX_S_LE:          "RRX.S.LE",
	RRX_S:             "RRX.S",
	RRX_S_ZZ:          "RRX.S.ZZ",
	RSB_EQ:            "RSB.EQ",
	RSB_NE:            "RSB.NE",
	RSB_CS:            "RSB.CS",
	RSB_CC:            "RSB.CC",
	RSB_MI:            "RSB.MI",
	RSB_PL:            "RSB.PL",
	RSB_VS:            "RSB.VS",
	RSB_VC:            "RSB.VC",
	RSB_HI:            "RSB.HI",
	RSB_LS:            "RSB.LS",
	RSB_GE:            "RSB.GE",
	RSB_LT:            "RSB.LT",
	RSB_GT:            "RSB.GT",
	RSB_LE:            "RSB.LE",
	RSB:               "RSB",
	RSB_ZZ:            "RSB.ZZ",
	RSB_S_EQ:          "RSB.S.EQ",
	RSB_S_NE:          "RSB.S.NE",
	RSB_S_CS:          "RSB.S.CS",
	RSB_S_CC:          "RSB.S.CC",
	RSB_S_MI:          "RSB.S.MI",
	RSB_S_PL:          "RSB.S.PL",
	RSB_S_VS:          "RSB.S.VS",
	RSB_S_VC:          "RSB.S.VC",
	RSB_S_HI:          "RSB.S.HI",
	RSB_S_LS:          "RSB.S.LS",
	RSB_S_GE:          "RSB.S.GE",
	RSB_S_LT:          "RSB.S.LT",
	RSB_S_GT:          "RSB.S.GT",
	RSB_S_LE:          "RSB.S.LE",
	RSB_S:             "RSB.S",
	RSB_S_ZZ:          "RSB.S.ZZ",
	RSC_EQ:            "RSC.EQ",
	RSC_NE:            "RSC.NE",
	RSC_CS:            "RSC.CS",
	RSC_CC:            "RSC.CC",
	RSC_MI:            "RSC.MI",
	RSC_PL:            "RSC.PL",
	RSC_VS:            "RSC.VS",
	RSC_VC:            "RSC.VC",
	RSC_HI:            "RSC.HI",
	RSC_LS:            "RSC.LS",
	RSC_GE:            "RSC.GE",
	RSC_LT:            "RSC.LT",
	RSC_GT:            "RSC.GT",
	RSC_LE:            "RSC.LE",
	RSC:               "RSC",
	RSC_ZZ:            "RSC.ZZ",
	RSC_S_EQ:          "RSC.S.EQ",
	RSC_S_NE:          "RSC.S.NE",
	RSC_S_CS:          "RSC.S.CS",
	RSC_S_CC:          "RSC.S.CC",
	RSC_S_MI:          "RSC.S.MI",
	RSC_S_PL:          "RSC.S.PL",
	RSC_S_VS:          "RSC.S.VS",
	RSC_S_VC:          "RSC.S.VC",
	RSC_S_HI:          "RSC.S.HI",
	RSC_S_LS:          "RSC.S.LS",
	RSC_S_GE:          "RSC.S.GE",
	RSC_S_LT:          "RSC.S.LT",
	RSC_S_GT:          "RSC.S.GT",
	RSC_S_LE:          "RSC.S.LE",
	RSC_S:             "RSC.S",
	RSC_S_ZZ:          "RSC.S.ZZ",
	SADD16_EQ:         "SADD16.EQ",
	SADD16_NE:         "SADD16.NE",
	SADD16_CS:         "SADD16.CS",
	SADD16_CC:         "SADD16.CC",
	SADD16_MI:         "SADD16.MI",
	SADD16_PL:         "SADD16.PL",
	SADD16_VS:         "SADD16.VS",
	SADD16_VC:         "SADD16.VC",
	SADD16_HI:         "SADD16.HI",
	SADD16_LS:         "SADD16.LS",
	SADD16_GE:         "SADD16.GE",
	SADD16_LT:         "SADD16.LT",
	SADD16_GT:         "SADD16.GT",
	SADD16_LE:         "SADD16.LE",
	SADD16:            "SADD16",
	SADD16_ZZ:         "SADD16.ZZ",
	SADD8_EQ:          "SADD8.EQ",
	SADD8_NE:          "SADD8.NE",
	SADD8_CS:          "SADD8.CS",
	SADD8_CC:          "SADD8.CC",
	SADD8_MI:          "SADD8.MI",
	SADD8_PL:          "SADD8.PL",
	SADD8_VS:          "SADD8.VS",
	SADD8_VC:          "SADD8.VC",
	SADD8_HI:          "SADD8.HI",
	SADD8_LS:          "SADD8.LS",
	SADD8_GE:          "SADD8.GE",
	SADD8_LT:          "SADD8.LT",
	SADD8_GT:          "SADD8.GT",
	SADD8_LE:          "SADD8.LE",
	SADD8:             "SADD8",
	SADD8_ZZ:          "SADD8.ZZ",
	SASX_EQ:           "SASX.EQ",
	SASX_NE:           "SASX.NE",
	SASX_CS:           "SASX.CS",
	SASX_CC:           "SASX.CC",
	SASX_MI:           "SASX.MI",
	SASX_PL:           "SASX.PL",
	SASX_VS:           "SASX.VS",
	SASX_VC:           "SASX.VC",
	SASX_HI:           "SASX.HI",
	SASX_LS:           "SASX.LS",
	SASX_GE:           "SASX.GE",
	SASX_LT:           "SASX.LT",
	SASX_GT:           "SASX.GT",
	SASX_LE:           "SASX.LE",
	SASX:              "SASX",
	SASX_ZZ:           "SASX.ZZ",
	SBC_EQ:            "SBC.EQ",
	SBC_NE:            "SBC.NE",
	SBC_CS:            "SBC.CS",
	SBC_CC:            "SBC.CC",
	SBC_MI:            "SBC.MI",
	SBC_PL:            "SBC.PL",
	SBC_VS:            "SBC.VS",
	SBC_VC:            "SBC.VC",
	SBC_HI:            "SBC.HI",
	SBC_LS:            "SBC.LS",
	SBC_GE:            "SBC.GE",
	SBC_LT:            "SBC.LT",
	SBC_GT:            "SBC.GT",
	SBC_LE:            "SBC.LE",
	SBC:               "SBC",
	SBC_ZZ:            "SBC.ZZ",
	SBC_S_EQ:          "SBC.S.EQ",
	SBC_S_NE:          "SBC.S.NE",
	SBC_S_CS:          "SBC.S.CS",
	SBC_S_CC:          "SBC.S.CC",
	SBC_S_MI:          "SBC.S.MI",
	SBC_S_PL:          "SBC.S.PL",
	SBC_S_VS:          "SBC.S.VS",
	SBC_S_VC:          "SBC.S.VC",
	SBC_S_HI:          "SBC.S.HI",
	SBC_S_LS:          "SBC.S.LS",
	SBC_S_GE:          "SBC.S.GE",
	SBC_S_LT:          "SBC.S.LT",
	SBC_S_GT:          "SBC.S.GT",
	SBC_S_LE:          "SBC.S.LE",
	SBC_S:             "SBC.S",
	SBC_S_ZZ:          "SBC.S.ZZ",
	SBFX_EQ:           "SBFX.EQ",
	SBFX_NE:           "SBFX.NE",
	SBFX_CS:           "SBFX.CS",
	SBFX_CC:           "SBFX.CC",
	SBFX_MI:           "SBFX.MI",
	SBFX_PL:           "SBFX.PL",
	SBFX_VS:           "SBFX.VS",
	SBFX_VC:           "SBFX.VC",
	SBFX_HI:           "SBFX.HI",
	SBFX_LS:           "SBFX.LS",
	SBFX_GE:           "SBFX.GE",
	SBFX_LT:           "SBFX.LT",
	SBFX_GT:           "SBFX.GT",
	SBFX_LE:           "SBFX.LE",
	SBFX:              "SBFX",
	SBFX_ZZ:           "SBFX.ZZ",
	SEL_EQ:            "SEL.EQ",
	SEL_NE:            "SEL.NE",
	SEL_CS:            "SEL.CS",
	SEL_CC:            "SEL.CC",
	SEL_MI:            "SEL.MI",
	SEL_PL:            "SEL.PL",
	SEL_VS:            "SEL.VS",
	SEL_VC:            "SEL.VC",
	SEL_HI:            "SEL.HI",
	SEL_LS:            "SEL.LS",
	SEL_GE:            "SEL.GE",
	SEL_LT:            "SEL.LT",
	SEL_GT:            "SEL.GT",
	SEL_LE:            "SEL.LE",
	SEL:               "SEL",
	SEL_ZZ:            "SEL.ZZ",
	SETEND:            "SETEND",
	SEV_EQ:            "SEV.EQ",
	SEV_NE:            "SEV.NE",
	SEV_CS:            "SEV.CS",
	SEV_CC:            "SEV.CC",
	SEV_MI:            "SEV.MI",
	SEV_PL:            "SEV.PL",
	SEV_VS:            "SEV.VS",
	SEV_VC:            "SEV.VC",
	SEV_HI:            "SEV.HI",
	SEV_LS:            "SEV.LS",
	SEV_GE:            "SEV.GE",
	SEV_LT:            "SEV.LT",
	SEV_GT:            "SEV.GT",
	SEV_LE:            "SEV.LE",
	SEV:               "SEV",
	SEV_ZZ:            "SEV.ZZ",
	SHADD16_EQ:        "SHADD16.EQ",
	SHADD16_NE:        "SHADD16.NE",
	SHADD16_CS:        "SHADD16.CS",
	SHADD16_CC:        "SHADD16.CC",
	SHADD16_MI:        "SHADD16.MI",
	SHADD16_PL:        "SHADD16.PL",
	SHADD16_VS:        "SHADD16.VS",
	SHADD16_VC:        "SHADD16.VC",
	SHADD16_HI:        "SHADD16.HI",
	SHADD16_LS:        "SHADD16.LS",
	SHADD16_GE:        "SHADD16.GE",
	SHADD16_LT:        "SHADD16.LT",
	SHADD16_GT:        "SHADD16.GT",
	SHADD16_LE:        "SHADD16.LE",
	SHADD16:           "SHADD16",
	SHADD16_ZZ:        "SHADD16.ZZ",
	SHADD8_EQ:         "SHADD8.EQ",
	SHADD8_NE:         "SHADD8.NE",
	SHADD8_CS:         "SHADD8.CS",
	SHADD8_CC:         "SHADD8.CC",
	SHADD8_MI:         "SHADD8.MI",
	SHADD8_PL:         "SHADD8.PL",
	SHADD8_VS:         "SHADD8.VS",
	SHADD8_VC:         "SHADD8.VC",
	SHADD8_HI:         "SHADD8.HI",
	SHADD8_LS:         "SHADD8.LS",
	SHADD8_GE:         "SHADD8.GE",
	SHADD8_LT:         "SHADD8.LT",
	SHADD8_GT:         "SHADD8.GT",
	SHADD8_LE:         "SHADD8.LE",
	SHADD8:            "SHADD8",
	SHADD8_ZZ:         "SHADD8.ZZ",
	SHASX_EQ:          "SHASX.EQ",
	SHASX_NE:          "SHASX.NE",
	SHASX_CS:          "SHASX.CS",
	SHASX_CC:          "SHASX.CC",
	SHASX_MI:          "SHASX.MI",
	SHASX_PL:          "SHASX.PL",
	SHASX_VS:          "SHASX.VS",
	SHASX_VC:          "SHASX.VC",
	SHASX_HI:          "SHASX.HI",
	SHASX_LS:          "SHASX.LS",
	SHASX_GE:          "SHASX.GE",
	SHASX_LT:          "SHASX.LT",
	SHASX_GT:          "SHASX.GT",
	SHASX_LE:          "SHASX.LE",
	SHASX:             "SHASX",
	SHASX_ZZ:          "SHASX.ZZ",
	SHSAX_EQ:          "SHSAX.EQ",
	SHSAX_NE:          "SHSAX.NE",
	SHSAX_CS:          "SHSAX.CS",
	SHSAX_CC:          "SHSAX.CC",
	SHSAX_MI:          "SHSAX.MI",
	SHSAX_PL:          "SHSAX.PL",
	SHSAX_VS:          "SHSAX.VS",
	SHSAX_VC:          "SHSAX.VC",
	SHSAX_HI:          "SHSAX.HI",
	SHSAX_LS:          "SHSAX.LS",
	SHSAX_GE:          "SHSAX.GE",
	SHSAX_LT:          "SHSAX.LT",
	SHSAX_GT:          "SHSAX.GT",
	SHSAX_LE:          "SHSAX.LE",
	SHSAX:             "SHSAX",
	SHSAX_ZZ:          "SHSAX.ZZ",
	SHSUB16_EQ:        "SHSUB16.EQ",
	SHSUB16_NE:        "SHSUB16.NE",
	SHSUB16_CS:        "SHSUB16.CS",
	SHSUB16_CC:        "SHSUB16.CC",
	SHSUB16_MI:        "SHSUB16.MI",
	SHSUB16_PL:        "SHSUB16.PL",
	SHSUB16_VS:        "SHSUB16.VS",
	SHSUB16_VC:        "SHSUB16.VC",
	SHSUB16_HI:        "SHSUB16.HI",
	SHSUB16_LS:        "SHSUB16.LS",
	SHSUB16_GE:        "SHSUB16.GE",
	SHSUB16_LT:        "SHSUB16.LT",
	SHSUB16_GT:        "SHSUB16.GT",
	SHSUB16_LE:        "SHSUB16.LE",
	SHSUB16:           "SHSUB16",
	SHSUB16_ZZ:        "SHSUB16.ZZ",
	SHSUB8_EQ:         "SHSUB8.EQ",
	SHSUB8_NE:         "SHSUB8.NE",
	SHSUB8_CS:         "SHSUB8.CS",
	SHSUB8_CC:         "SHSUB8.CC",
	SHSUB8_MI:         "SHSUB8.MI",
	SHSUB8_PL:         "SHSUB8.PL",
	SHSUB8_VS:         "SHSUB8.VS",
	SHSUB8_VC:         "SHSUB8.VC",
	SHSUB8_HI:         "SHSUB8.HI",
	SHSUB8_LS:         "SHSUB8.LS",
	SHSUB8_GE:         "SHSUB8.GE",
	SHSUB8_LT:         "SHSUB8.LT",
	SHSUB8_GT:         "SHSUB8.GT",
	SHSUB8_LE:         "SHSUB8.LE",
	SHSUB8:            "SHSUB8",
	SHSUB8_ZZ:         "SHSUB8.ZZ",
	SMLABB_EQ:         "SMLABB.EQ",
	SMLABB_NE:         "SMLABB.NE",
	SMLABB_CS:         "SMLABB.CS",
	SMLABB_CC:         "SMLABB.CC",
	SMLABB_MI:         "SMLABB.MI",
	SMLABB_PL:         "SMLABB.PL",
	SMLABB_VS:         "SMLABB.VS",
	SMLABB_VC:         "SMLABB.VC",
	SMLABB_HI:         "SMLABB.HI",
	SMLABB_LS:         "SMLABB.LS",
	SMLABB_GE:         "SMLABB.GE",
	SMLABB_LT:         "SMLABB.LT",
	SMLABB_GT:         "SMLABB.GT",
	SMLABB_LE:         "SMLABB.LE",
	SMLABB:            "SMLABB",
	SMLABB_ZZ:         "SMLABB.ZZ",
	SMLABT_EQ:         "SMLABT.EQ",
	SMLABT_NE:         "SMLABT.NE",
	SMLABT_CS:         "SMLABT.CS",
	SMLABT_CC:         "SMLABT.CC",
	SMLABT_MI:         "SMLABT.MI",
	SMLABT_PL:         "SMLABT.PL",
	SMLABT_VS:         "SMLABT.VS",
	SMLABT_VC:         "SMLABT.VC",
	SMLABT_HI:         "SMLABT.HI",
	SMLABT_LS:         "SMLABT.LS",
	SMLABT_GE:         "SMLABT.GE",
	SMLABT_LT:         "SMLABT.LT",
	SMLABT_GT:         "SMLABT.GT",
	SMLABT_LE:         "SMLABT.LE",
	SMLABT:            "SMLABT",
	SMLABT_ZZ:         "SMLABT.ZZ",
	SMLATB_EQ:         "SMLATB.EQ",
	SMLATB_NE:         "SMLATB.NE",
	SMLATB_CS:         "SMLATB.CS",
	SMLATB_CC:         "SMLATB.CC",
	SMLATB_MI:         "SMLATB.MI",
	SMLATB_PL:         "SMLATB.PL",
	SMLATB_VS:         "SMLATB.VS",
	SMLATB_VC:         "SMLATB.VC",
	SMLATB_HI:         "SMLATB.HI",
	SMLATB_LS:         "SMLATB.LS",
	SMLATB_GE:         "SMLATB.GE",
	SMLATB_LT:         "SMLATB.LT",
	SMLATB_GT:         "SMLATB.GT",
	SMLATB_LE:         "SMLATB.LE",
	SMLATB:            "SMLATB",
	SMLATB_ZZ:         "SMLATB.ZZ",
	SMLATT_EQ:         "SMLATT.EQ",
	SMLATT_NE:         "SMLATT.NE",
	SMLATT_CS:         "SMLATT.CS",
	SMLATT_CC:         "SMLATT.CC",
	SMLATT_MI:         "SMLATT.MI",
	SMLATT_PL:         "SMLATT.PL",
	SMLATT_VS:         "SMLATT.VS",
	SMLATT_VC:         "SMLATT.VC",
	SMLATT_HI:         "SMLATT.HI",
	SMLATT_LS:         "SMLATT.LS",
	SMLATT_GE:         "SMLATT.GE",
	SMLATT_LT:         "SMLATT.LT",
	SMLATT_GT:         "SMLATT.GT",
	SMLATT_LE:         "SMLATT.LE",
	SMLATT:            "SMLATT",
	SMLATT_ZZ:         "SMLATT.ZZ",
	SMLAD_EQ:          "SMLAD.EQ",
	SMLAD_NE:          "SMLAD.NE",
	SMLAD_CS:          "SMLAD.CS",
	SMLAD_CC:          "SMLAD.CC",
	SMLAD_MI:          "SMLAD.MI",
	SMLAD_PL:          "SMLAD.PL",
	SMLAD_VS:          "SMLAD.VS",
	SMLAD_VC:          "SMLAD.VC",
	SMLAD_HI:          "SMLAD.HI",
	SMLAD_LS:          "SMLAD.LS",
	SMLAD_GE:          "SMLAD.GE",
	SMLAD_LT:          "SMLAD.LT",
	SMLAD_GT:          "SMLAD.GT",
	SMLAD_LE:          "SMLAD.LE",
	SMLAD:             "SMLAD",
	SMLAD_ZZ:          "SMLAD.ZZ",
	SMLAD_X_EQ:        "SMLAD.X.EQ",
	SMLAD_X_NE:        "SMLAD.X.NE",
	SMLAD_X_CS:        "SMLAD.X.CS",
	SMLAD_X_CC:        "SMLAD.X.CC",
	SMLAD_X_MI:        "SMLAD.X.MI",
	SMLAD_X_PL:        "SMLAD.X.PL",
	SMLAD_X_VS:        "SMLAD.X.VS",
	SMLAD_X_VC:        "SMLAD.X.VC",
	SMLAD_X_HI:        "SMLAD.X.HI",
	SMLAD_X_LS:        "SMLAD.X.LS",
	SMLAD_X_GE:        "SMLAD.X.GE",
	SMLAD_X_LT:        "SMLAD.X.LT",
	SMLAD_X_GT:        "SMLAD.X.GT",
	SMLAD_X_LE:        "SMLAD.X.LE",
	SMLAD_X:           "SMLAD.X",
	SMLAD_X_ZZ:        "SMLAD.X.ZZ",
	SMLAL_EQ:          "SMLAL.EQ",
	SMLAL_NE:          "SMLAL.NE",
	SMLAL_CS:          "SMLAL.CS",
	SMLAL_CC:          "SMLAL.CC",
	SMLAL_MI:          "SMLAL.MI",
	SMLAL_PL:          "SMLAL.PL",
	SMLAL_VS:          "SMLAL.VS",
	SMLAL_VC:          "SMLAL.VC",
	SMLAL_HI:          "SMLAL.HI",
	SMLAL_LS:          "SMLAL.LS",
	SMLAL_GE:          "SMLAL.GE",
	SMLAL_LT:          "SMLAL.LT",
	SMLAL_GT:          "SMLAL.GT",
	SMLAL_LE:          "SMLAL.LE",
	SMLAL:             "SMLAL",
	SMLAL_ZZ:          "SMLAL.ZZ",
	SMLAL_S_EQ:        "SMLAL.S.EQ",
	SMLAL_S_NE:        "SMLAL.S.NE",
	SMLAL_S_CS:        "SMLAL.S.CS",
	SMLAL_S_CC:        "SMLAL.S.CC",
	SMLAL_S_MI:        "SMLAL.S.MI",
	SMLAL_S_PL:        "SMLAL.S.PL",
	SMLAL_S_VS:        "SMLAL.S.VS",
	SMLAL_S_VC:        "SMLAL.S.VC",
	SMLAL_S_HI:        "SMLAL.S.HI",
	SMLAL_S_LS:        "SMLAL.S.LS",
	SMLAL_S_GE:        "SMLAL.S.GE",
	SMLAL_S_LT:        "SMLAL.S.LT",
	SMLAL_S_GT:        "SMLAL.S.GT",
	SMLAL_S_LE:        "SMLAL.S.LE",
	SMLAL_S:           "SMLAL.S",
	SMLAL_S_ZZ:        "SMLAL.S.ZZ",
	SMLALBB_EQ:        "SMLALBB.EQ",
	SMLALBB_NE:        "SMLALBB.NE",
	SMLALBB_CS:        "SMLALBB.CS",
	SMLALBB_CC:        "SMLALBB.CC",
	SMLALBB_MI:        "SMLALBB.MI",
	SMLALBB_PL:        "SMLALBB.PL",
	SMLALBB_VS:        "SMLALBB.VS",
	SMLALBB_VC:        "SMLALBB.VC",
	SMLALBB_HI:        "SMLALBB.HI",
	SMLALBB_LS:        "SMLALBB.LS",
	SMLALBB_GE:        "SMLALBB.GE",
	SMLALBB_LT:        "SMLALBB.LT",
	SMLALBB_GT:        "SMLALBB.GT",
	SMLALBB_LE:        "SMLALBB.LE",
	SMLALBB:           "SMLALBB",
	SMLALBB_ZZ:        "SMLALBB.ZZ",
	SMLALBT_EQ:        "SMLALBT.EQ",
	SMLALBT_NE:        "SMLALBT.NE",
	SMLALBT_CS:        "SMLALBT.CS",
	SMLALBT_CC:        "SMLALBT.CC",
	SMLALBT_MI:        "SMLALBT.MI",
	SMLALBT_PL:        "SMLALBT.PL",
	SMLALBT_VS:        "SMLALBT.VS",
	SMLALBT_VC:        "SMLALBT.VC",
	SMLALBT_HI:        "SMLALBT.HI",
	SMLALBT_LS:        "SMLALBT.LS",
	SMLALBT_GE:        "SMLALBT.GE",
	SMLALBT_LT:        "SMLALBT.LT",
	SMLALBT_GT:        "SMLALBT.GT",
	SMLALBT_LE:        "SMLALBT.LE",
	SMLALBT:           "SMLALBT",
	SMLALBT_ZZ:        "SMLALBT.ZZ",
	SMLALTB_EQ:        "SMLALTB.EQ",
	SMLALTB_NE:        "SMLALTB.NE",
	SMLALTB_CS:        "SMLALTB.CS",
	SMLALTB_CC:        "SMLALTB.CC",
	SMLALTB_MI:        "SMLALTB.MI",
	SMLALTB_PL:        "SMLALTB.PL",
	SMLALTB_VS:        "SMLALTB.VS",
	SMLALTB_VC:        "SMLALTB.VC",
	SMLALTB_HI:        "SMLALTB.HI",
	SMLALTB_LS:        "SMLALTB.LS",
	SMLALTB_GE:        "SMLALTB.GE",
	SMLALTB_LT:        "SMLALTB.LT",
	SMLALTB_GT:        "SMLALTB.GT",
	SMLALTB_LE:        "SMLALTB.LE",
	SMLALTB:           "SMLALTB",
	SMLALTB_ZZ:        "SMLALTB.ZZ",
	SMLALTT_EQ:        "SMLALTT.EQ",
	SMLALTT_NE:        "SMLALTT.NE",
	SMLALTT_CS:        "SMLALTT.CS",
	SMLALTT_CC:        "SMLALTT.CC",
	SMLALTT_MI:        "SMLALTT.MI",
	SMLALTT_PL:        "SMLALTT.PL",
	SMLALTT_VS:        "SMLALTT.VS",
	SMLALTT_VC:        "SMLALTT.VC",
	SMLALTT_HI:        "SMLALTT.HI",
	SMLALTT_LS:        "SMLALTT.LS",
	SMLALTT_GE:        "SMLALTT.GE",
	SMLALTT_LT:        "SMLALTT.LT",
	SMLALTT_GT:        "SMLALTT.GT",
	SMLALTT_LE:        "SMLALTT.LE",
	SMLALTT:           "SMLALTT",
	SMLALTT_ZZ:        "SMLALTT.ZZ",
	SMLALD_EQ:         "SMLALD.EQ",
	SMLALD_NE:         "SMLALD.NE",
	SMLALD_CS:         "SMLALD.CS",
	SMLALD_CC:         "SMLALD.CC",
	SMLALD_MI:         "SMLALD.MI",
	SMLALD_PL:         "SMLALD.PL",
	SMLALD_VS:         "SMLALD.VS",
	SMLALD_VC:         "SMLALD.VC",
	SMLALD_HI:         "SMLALD.HI",
	SMLALD_LS:         "SMLALD.LS",
	SMLALD_GE:         "SMLALD.GE",
	SMLALD_LT:         "SMLALD.LT",
	SMLALD_GT:         "SMLALD.GT",
	SMLALD_LE:         "SMLALD.LE",
	SMLALD:            "SMLALD",
	SMLALD_ZZ:         "SMLALD.ZZ",
	SMLALD_X_EQ:       "SMLALD.X.EQ",
	SMLALD_X_NE:       "SMLALD.X.NE",
	SMLALD_X_CS:       "SMLALD.X.CS",
	SMLALD_X_CC:       "SMLALD.X.CC",
	SMLALD_X_MI:       "SMLALD.X.MI",
	SMLALD_X_PL:       "SMLALD.X.PL",
	SMLALD_X_VS:       "SMLALD.X.VS",
	SMLALD_X_VC:       "SMLALD.X.VC",
	SMLALD_X_HI:       "SMLALD.X.HI",
	SMLALD_X_LS:       "SMLALD.X.LS",
	SMLALD_X_GE:       "SMLALD.X.GE",
	SMLALD_X_LT:       "SMLALD.X.LT",
	SMLALD_X_GT:       "SMLALD.X.GT",
	SMLALD_X_LE:       "SMLALD.X.LE",
	SMLALD_X:          "SMLALD.X",
	SMLALD_X_ZZ:       "SMLALD.X.ZZ",
	SMLAWB_EQ:         "SMLAWB.EQ",
	SMLAWB_NE:         "SMLAWB.NE",
	SMLAWB_CS:         "SMLAWB.CS",
	SMLAWB_CC:         "SMLAWB.CC",
	SMLAWB_MI:         "SMLAWB.MI",
	SMLAWB_PL:         "SMLAWB.PL",
	SMLAWB_VS:         "SMLAWB.VS",
	SMLAWB_VC:         "SMLAWB.VC",
	SMLAWB_HI:         "SMLAWB.HI",
	SMLAWB_LS:         "SMLAWB.LS",
	SMLAWB_GE:         "SMLAWB.GE",
	SMLAWB_LT:         "SMLAWB.LT",
	SMLAWB_GT:         "SMLAWB.GT",
	SMLAWB_LE:         "SMLAWB.LE",
	SMLAWB:            "SMLAWB",
	SMLAWB_ZZ:         "SMLAWB.ZZ",
	SMLAWT_EQ:         "SMLAWT.EQ",
	SMLAWT_NE:         "SMLAWT.NE",
	SMLAWT_CS:         "SMLAWT.CS",
	SMLAWT_CC:         "SMLAWT.CC",
	SMLAWT_MI:         "SMLAWT.MI",
	SMLAWT_PL:         "SMLAWT.PL",
	SMLAWT_VS:         "SMLAWT.VS",
	SMLAWT_VC:         "SMLAWT.VC",
	SMLAWT_HI:         "SMLAWT.HI",
	SMLAWT_LS:         "SMLAWT.LS",
	SMLAWT_GE:         "SMLAWT.GE",
	SMLAWT_LT:         "SMLAWT.LT",
	SMLAWT_GT:         "SMLAWT.GT",
	SMLAWT_LE:         "SMLAWT.LE",
	SMLAWT:            "SMLAWT",
	SMLAWT_ZZ:         "SMLAWT.ZZ",
	SMLSD_EQ:          "SMLSD.EQ",
	SMLSD_NE:          "SMLSD.NE",
	SMLSD_CS:          "SMLSD.CS",
	SMLSD_CC:          "SMLSD.CC",
	SMLSD_MI:          "SMLSD.MI",
	SMLSD_PL:          "SMLSD.PL",
	SMLSD_VS:          "SMLSD.VS",
	SMLSD_VC:          "SMLSD.VC",
	SMLSD_HI:          "SMLSD.HI",
	SMLSD_LS:          "SMLSD.LS",
	SMLSD_GE:          "SMLSD.GE",
	SMLSD_LT:          "SMLSD.LT",
	SMLSD_GT:          "SMLSD.GT",
	SMLSD_LE:          "SMLSD.LE",
	SMLSD:             "SMLSD",
	SMLSD_ZZ:          "SMLSD.ZZ",
	SMLSD_X_EQ:        "SMLSD.X.EQ",
	SMLSD_X_NE:        "SMLSD.X.NE",
	SMLSD_X_CS:        "SMLSD.X.CS",
	SMLSD_X_CC:        "SMLSD.X.CC",
	SMLSD_X_MI:        "SMLSD.X.MI",
	SMLSD_X_PL:        "SMLSD.X.PL",
	SMLSD_X_VS:        "SMLSD.X.VS",
	SMLSD_X_VC:        "SMLSD.X.VC",
	SMLSD_X_HI:        "SMLSD.X.HI",
	SMLSD_X_LS:        "SMLSD.X.LS",
	SMLSD_X_GE:        "SMLSD.X.GE",
	SMLSD_X_LT:        "SMLSD.X.LT",
	SMLSD_X_GT:        "SMLSD.X.GT",
	SMLSD_X_LE:        "SMLSD.X.LE",
	SMLSD_X:           "SMLSD.X",
	SMLSD_X_ZZ:        "SMLSD.X.ZZ",
	SMLSLD_EQ:         "SMLSLD.EQ",
	SMLSLD_NE:         "SMLSLD.NE",
	SMLSLD_CS:         "SMLSLD.CS",
	SMLSLD_CC:         "SMLSLD.CC",
	SMLSLD_MI:         "SMLSLD.MI",
	SMLSLD_PL:         "SMLSLD.PL",
	SMLSLD_VS:         "SMLSLD.VS",
	SMLSLD_VC:         "SMLSLD.VC",
	SMLSLD_HI:         "SMLSLD.HI",
	SMLSLD_LS:         "SMLSLD.LS",
	SMLSLD_GE:         "SMLSLD.GE",
	SMLSLD_LT:         "SMLSLD.LT",
	SMLSLD_GT:         "SMLSLD.GT",
	SMLSLD_LE:         "SMLSLD.LE",
	SMLSLD:            "SMLSLD",
	SMLSLD_ZZ:         "SMLSLD.ZZ",
	SMLSLD_X_EQ:       "SMLSLD.X.EQ",
	SMLSLD_X_NE:       "SMLSLD.X.NE",
	SMLSLD_X_CS:       "SMLSLD.X.CS",
	SMLSLD_X_CC:       "SMLSLD.X.CC",
	SMLSLD_X_MI:       "SMLSLD.X.MI",
	SMLSLD_X_PL:       "SMLSLD.X.PL",
	SMLSLD_X_VS:       "SMLSLD.X.VS",
	SMLSLD_X_VC:       "SMLSLD.X.VC",
	SMLSLD_X_HI:       "SMLSLD.X.HI",
	SMLSLD_X_LS:       "SMLSLD.X.LS",
	SMLSLD_X_GE:       "SMLSLD.X.GE",
	SMLSLD_X_LT:       "SMLSLD.X.LT",
	SMLSLD_X_GT:       "SMLSLD.X.GT",
	SMLSLD_X_LE:       "SMLSLD.X.LE",
	SMLSLD_X:          "SMLSLD.X",
	SMLSLD_X_ZZ:       "SMLSLD.X.ZZ",
	SMMLA_EQ:          "SMMLA.EQ",
	SMMLA_NE:          "SMMLA.NE",
	SMMLA_CS:          "SMMLA.CS",
	SMMLA_CC:          "SMMLA.CC",
	SMMLA_MI:          "SMMLA.MI",
	SMMLA_PL:          "SMMLA.PL",
	SMMLA_VS:          "SMMLA.VS",
	SMMLA_VC:          "SMMLA.VC",
	SMMLA_HI:          "SMMLA.HI",
	SMMLA_LS:          "SMMLA.LS",
	SMMLA_GE:          "SMMLA.GE",
	SMMLA_LT:          "SMMLA.LT",
	SMMLA_GT:          "SMMLA.GT",
	SMMLA_LE:          "SMMLA.LE",
	SMMLA:             "SMMLA",
	SMMLA_ZZ:          "SMMLA.ZZ",
	SMMLA_R_EQ:        "SMMLA.R.EQ",
	SMMLA_R_NE:        "SMMLA.R.NE",
	SMMLA_R_CS:        "SMMLA.R.CS",
	SMMLA_R_CC:        "SMMLA.R.CC",
	SMMLA_R_MI:        "SMMLA.R.MI",
	SMMLA_R_PL:        "SMMLA.R.PL",
	SMMLA_R_VS:        "SMMLA.R.VS",
	SMMLA_R_VC:        "SMMLA.R.VC",
	SMMLA_R_HI:        "SMMLA.R.HI",
	SMMLA_R_LS:        "SMMLA.R.LS",
	SMMLA_R_GE:        "SMMLA.R.GE",
	SMMLA_R_LT:        "SMMLA.R.LT",
	SMMLA_R_GT:        "SMMLA.R.GT",
	SMMLA_R_LE:        "SMMLA.R.LE",
	SMMLA_R:           "SMMLA.R",
	SMMLA_R_ZZ:        "SMMLA.R.ZZ",
	SMMLS_EQ:          "SMMLS.EQ",
	SMMLS_NE:          "SMMLS.NE",
	SMMLS_CS:          "SMMLS.CS",
	SMMLS_CC:          "SMMLS.CC",
	SMMLS_MI:          "SMMLS.MI",
	SMMLS_PL:          "SMMLS.PL",
	SMMLS_VS:          "SMMLS.VS",
	SMMLS_VC:          "SMMLS.VC",
	SMMLS_HI:          "SMMLS.HI",
	SMMLS_LS:          "SMMLS.LS",
	SMMLS_GE:          "SMMLS.GE",
	SMMLS_LT:          "SMMLS.LT",
	SMMLS_GT:          "SMMLS.GT",
	SMMLS_LE:          "SMMLS.LE",
	SMMLS:             "SMMLS",
	SMMLS_ZZ:          "SMMLS.ZZ",
	SMMLS_R_EQ:        "SMMLS.R.EQ",
	SMMLS_R_NE:        "SMMLS.R.NE",
	SMMLS_R_CS:        "SMMLS.R.CS",
	SMMLS_R_CC:        "SMMLS.R.CC",
	SMMLS_R_MI:        "SMMLS.R.MI",
	SMMLS_R_PL:        "SMMLS.R.PL",
	SMMLS_R_VS:        "SMMLS.R.VS",
	SMMLS_R_VC:        "SMMLS.R.VC",
	SMMLS_R_HI:        "SMMLS.R.HI",
	SMMLS_R_LS:        "SMMLS.R.LS",
	SMMLS_R_GE:        "SMMLS.R.GE",
	SMMLS_R_LT:        "SMMLS.R.LT",
	SMMLS_R_GT:        "SMMLS.R.GT",
	SMMLS_R_LE:        "SMMLS.R.LE",
	SMMLS_R:           "SMMLS.R",
	SMMLS_R_ZZ:        "SMMLS.R.ZZ",
	SMMUL_EQ:          "SMMUL.EQ",
	SMMUL_NE:          "SMMUL.NE",
	SMMUL_CS:          "SMMUL.CS",
	SMMUL_CC:          "SMMUL.CC",
	SMMUL_MI:          "SMMUL.MI",
	SMMUL_PL:          "SMMUL.PL",
	SMMUL_VS:          "SMMUL.VS",
	SMMUL_VC:          "SMMUL.VC",
	SMMUL_HI:          "SMMUL.HI",
	SMMUL_LS:          "SMMUL.LS",
	SMMUL_GE:          "SMMUL.GE",
	SMMUL_LT:          "SMMUL.LT",
	SMMUL_GT:          "SMMUL.GT",
	SMMUL_LE:          "SMMUL.LE",
	SMMUL:             "SMMUL",
	SMMUL_ZZ:          "SMMUL.ZZ",
	SMMUL_R_EQ:        "SMMUL.R.EQ",
	SMMUL_R_NE:        "SMMUL.R.NE",
	SMMUL_R_CS:        "SMMUL.R.CS",
	SMMUL_R_CC:        "SMMUL.R.CC",
	SMMUL_R_MI:        "SMMUL.R.MI",
	SMMUL_R_PL:        "SMMUL.R.PL",
	SMMUL_R_VS:        "SMMUL.R.VS",
	SMMUL_R_VC:        "SMMUL.R.VC",
	SMMUL_R_HI:        "SMMUL.R.HI",
	SMMUL_R_LS:        "SMMUL.R.LS",
	SMMUL_R_GE:        "SMMUL.R.GE",
	SMMUL_R_LT:        "SMMUL.R.LT",
	SMMUL_R_GT:        "SMMUL.R.GT",
	SMMUL_R_LE:        "SMMUL.R.LE",
	SMMUL_R:           "SMMUL.R",
	SMMUL_R_ZZ:        "SMMUL.R.ZZ",
	SMUAD_EQ:          "SMUAD.EQ",
	SMUAD_NE:          "SMUAD.NE",
	SMUAD_CS:          "SMUAD.CS",
	SMUAD_CC:          "SMUAD.CC",
	SMUAD_MI:          "SMUAD.MI",
	SMUAD_PL:          "SMUAD.PL",
	SMUAD_VS:          "SMUAD.VS",
	SMUAD_VC:          "SMUAD.VC",
	SMUAD_HI:          "SMUAD.HI",
	SMUAD_LS:          "SMUAD.LS",
	SMUAD_GE:          "SMUAD.GE",
	SMUAD_LT:          "SMUAD.LT",
	SMUAD_GT:          "SMUAD.GT",
	SMUAD_LE:          "SMUAD.LE",
	SMUAD:             "SMUAD",
	SMUAD_ZZ:          "SMUAD.ZZ",
	SMUAD_X_EQ:        "SMUAD.X.EQ",
	SMUAD_X_NE:        "SMUAD.X.NE",
	SMUAD_X_CS:        "SMUAD.X.CS",
	SMUAD_X_CC:        "SMUAD.X.CC",
	SMUAD_X_MI:        "SMUAD.X.MI",
	SMUAD_X_PL:        "SMUAD.X.PL",
	SMUAD_X_VS:        "SMUAD.X.VS",
	SMUAD_X_VC:        "SMUAD.X.VC",
	SMUAD_X_HI:        "SMUAD.X.HI",
	SMUAD_X_LS:        "SMUAD.X.LS",
	SMUAD_X_GE:        "SMUAD.X.GE",
	SMUAD_X_LT:        "SMUAD.X.LT",
	SMUAD_X_GT:        "SMUAD.X.GT",
	SMUAD_X_LE:        "SMUAD.X.LE",
	SMUAD_X:           "SMUAD.X",
	SMUAD_X_ZZ:        "SMUAD.X.ZZ",
	SMULBB_EQ:         "SMULBB.EQ",
	SMULBB_NE:         "SMULBB.NE",
	SMULBB_CS:         "SMULBB.CS",
	SMULBB_CC:         "SMULBB.CC",
	SMULBB_MI:         "SMULBB.MI",
	SMULBB_PL:         "SMULBB.PL",
	SMULBB_VS:         "SMULBB.VS",
	SMULBB_VC:         "SMULBB.VC",
	SMULBB_HI:         "SMULBB.HI",
	SMULBB_LS:         "SMULBB.LS",
	SMULBB_GE:         "SMULBB.GE",
	SMULBB_LT:         "SMULBB.LT",
	SMULBB_GT:         "SMULBB.GT",
	SMULBB_LE:         "SMULBB.LE",
	SMULBB:            "SMULBB",
	SMULBB_ZZ:         "SMULBB.ZZ",
	SMULBT_EQ:         "SMULBT.EQ",
	SMULBT_NE:         "SMULBT.NE",
	SMULBT_CS:         "SMULBT.CS",
	SMULBT_CC:         "SMULBT.CC",
	SMULBT_MI:         "SMULBT.MI",
	SMULBT_PL:         "SMULBT.PL",
	SMULBT_VS:         "SMULBT.VS",
	SMULBT_VC:         "SMULBT.VC",
	SMULBT_HI:         "SMULBT.HI",
	SMULBT_LS:         "SMULBT.LS",
	SMULBT_GE:         "SMULBT.GE",
	SMULBT_LT:         "SMULBT.LT",
	SMULBT_GT:         "SMULBT.GT",
	SMULBT_LE:         "SMULBT.LE",
	SMULBT:            "SMULBT",
	SMULBT_ZZ:         "SMULBT.ZZ",
	SMULTB_EQ:         "SMULTB.EQ",
	SMULTB_NE:         "SMULTB.NE",
	SMULTB_CS:         "SMULTB.CS",
	SMULTB_CC:         "SMULTB.CC",
	SMULTB_MI:         "SMULTB.MI",
	SMULTB_PL:         "SMULTB.PL",
	SMULTB_VS:         "SMULTB.VS",
	SMULTB_VC:         "SMULTB.VC",
	SMULTB_HI:         "SMULTB.HI",
	SMULTB_LS:         "SMULTB.LS",
	SMULTB_GE:         "SMULTB.GE",
	SMULTB_LT:         "SMULTB.LT",
	SMULTB_GT:         "SMULTB.GT",
	SMULTB_LE:         "SMULTB.LE",
	SMULTB:            "SMULTB",
	SMULTB_ZZ:         "SMULTB.ZZ",
	SMULTT_EQ:         "SMULTT.EQ",
	SMULTT_NE:         "SMULTT.NE",
	SMULTT_CS:         "SMULTT.CS",
	SMULTT_CC:         "SMULTT.CC",
	SMULTT_MI:         "SMULTT.MI",
	SMULTT_PL:         "SMULTT.PL",
	SMULTT_VS:         "SMULTT.VS",
	SMULTT_VC:         "SMULTT.VC",
	SMULTT_HI:         "SMULTT.HI",
	SMULTT_LS:         "SMULTT.LS",
	SMULTT_GE:         "SMULTT.GE",
	SMULTT_LT:         "SMULTT.LT",
	SMULTT_GT:         "SMULTT.GT",
	SMULTT_LE:         "SMULTT.LE",
	SMULTT:            "SMULTT",
	SMULTT_ZZ:         "SMULTT.ZZ",
	SMULL_EQ:          "SMULL.EQ",
	SMULL_NE:          "SMULL.NE",
	SMULL_CS:          "SMULL.CS",
	SMULL_CC:          "SMULL.CC",
	SMULL_MI:          "SMULL.MI",
	SMULL_PL:          "SMULL.PL",
	SMULL_VS:          "SMULL.VS",
	SMULL_VC:          "SMULL.VC",
	SMULL_HI:          "SMULL.HI",
	SMULL_LS:          "SMULL.LS",
	SMULL_GE:          "SMULL.GE",
	SMULL_LT:          "SMULL.LT",
	SMULL_GT:          "SMULL.GT",
	SMULL_LE:          "SMULL.LE",
	SMULL:             "SMULL",
	SMULL_ZZ:          "SMULL.ZZ",
	SMULL_S_EQ:        "SMULL.S.EQ",
	SMULL_S_NE:        "SMULL.S.NE",
	SMULL_S_CS:        "SMULL.S.CS",
	SMULL_S_CC:        "SMULL.S.CC",
	SMULL_S_MI:        "SMULL.S.MI",
	SMULL_S_PL:        "SMULL.S.PL",
	SMULL_S_VS:        "SMULL.S.VS",
	SMULL_S_VC:        "SMULL.S.VC",
	SMULL_S_HI:        "SMULL.S.HI",
	SMULL_S_LS:        "SMULL.S.LS",
	SMULL_S_GE:        "SMULL.S.GE",
	SMULL_S_LT:        "SMULL.S.LT",
	SMULL_S_GT:        "SMULL.S.GT",
	SMULL_S_LE:        "SMULL.S.LE",
	SMULL_S:           "SMULL.S",
	SMULL_S_ZZ:        "SMULL.S.ZZ",
	SMULWB_EQ:         "SMULWB.EQ",
	SMULWB_NE:         "SMULWB.NE",
	SMULWB_CS:         "SMULWB.CS",
	SMULWB_CC:         "SMULWB.CC",
	SMULWB_MI:         "SMULWB.MI",
	SMULWB_PL:         "SMULWB.PL",
	SMULWB_VS:         "SMULWB.VS",
	SMULWB_VC:         "SMULWB.VC",
	SMULWB_HI:         "SMULWB.HI",
	SMULWB_LS:         "SMULWB.LS",
	SMULWB_GE:         "SMULWB.GE",
	SMULWB_LT:         "SMULWB.LT",
	SMULWB_GT:         "SMULWB.GT",
	SMULWB_LE:         "SMULWB.LE",
	SMULWB:            "SMULWB",
	SMULWB_ZZ:         "SMULWB.ZZ",
	SMULWT_EQ:         "SMULWT.EQ",
	SMULWT_NE:         "SMULWT.NE",
	SMULWT_CS:         "SMULWT.CS",
	SMULWT_CC:         "SMULWT.CC",
	SMULWT_MI:         "SMULWT.MI",
	SMULWT_PL:         "SMULWT.PL",
	SMULWT_VS:         "SMULWT.VS",
	SMULWT_VC:         "SMULWT.VC",
	SMULWT_HI:         "SMULWT.HI",
	SMULWT_LS:         "SMULWT.LS",
	SMULWT_GE:         "SMULWT.GE",
	SMULWT_LT:         "SMULWT.LT",
	SMULWT_GT:         "SMULWT.GT",
	SMULWT_LE:         "SMULWT.LE",
	SMULWT:            "SMULWT",
	SMULWT_ZZ:         "SMULWT.ZZ",
	SMUSD_EQ:          "SMUSD.EQ",
	SMUSD_NE:          "SMUSD.NE",
	SMUSD_CS:          "SMUSD.CS",
	SMUSD_CC:          "SMUSD.CC",
	SMUSD_MI:          "SMUSD.MI",
	SMUSD_PL:          "SMUSD.PL",
	SMUSD_VS:          "SMUSD.VS",
	SMUSD_VC:          "SMUSD.VC",
	SMUSD_HI:          "SMUSD.HI",
	SMUSD_LS:          "SMUSD.LS",
	SMUSD_GE:          "SMUSD.GE",
	SMUSD_LT:          "SMUSD.LT",
	SMUSD_GT:          "SMUSD.GT",
	SMUSD_LE:          "SMUSD.LE",
	SMUSD:             "SMUSD",
	SMUSD_ZZ:          "SMUSD.ZZ",
	SMUSD_X_EQ:        "SMUSD.X.EQ",
	SMUSD_X_NE:        "SMUSD.X.NE",
	SMUSD_X_CS:        "SMUSD.X.CS",
	SMUSD_X_CC:        "SMUSD.X.CC",
	SMUSD_X_MI:        "SMUSD.X.MI",
	SMUSD_X_PL:        "SMUSD.X.PL",
	SMUSD_X_VS:        "SMUSD.X.VS",
	SMUSD_X_VC:        "SMUSD.X.VC",
	SMUSD_X_HI:        "SMUSD.X.HI",
	SMUSD_X_LS:        "SMUSD.X.LS",
	SMUSD_X_GE:        "SMUSD.X.GE",
	SMUSD_X_LT:        "SMUSD.X.LT",
	SMUSD_X_GT:        "SMUSD.X.GT",
	SMUSD_X_LE:        "SMUSD.X.LE",
	SMUSD_X:           "SMUSD.X",
	SMUSD_X_ZZ:        "SMUSD.X.ZZ",
	SSAT_EQ:           "SSAT.EQ",
	SSAT_NE:           "SSAT.NE",
	SSAT_CS:           "SSAT.CS",
	SSAT_CC:           "SSAT.CC",
	SSAT_MI:           "SSAT.MI",
	SSAT_PL:           "SSAT.PL",
	SSAT_VS:           "SSAT.VS",
	SSAT_VC:           "SSAT.VC",
	SSAT_HI:           "SSAT.HI",
	SSAT_LS:           "SSAT.LS",
	SSAT_GE:           "SSAT.GE",
	SSAT_LT:           "SSAT.LT",
	SSAT_GT:           "SSAT.GT",
	SSAT_LE:           "SSAT.LE",
	SSAT:              "SSAT",
	SSAT_ZZ:           "SSAT.ZZ",
	SSAT16_EQ:         "SSAT16.EQ",
	SSAT16_NE:         "SSAT16.NE",
	SSAT16_CS:         "SSAT16.CS",
	SSAT16_CC:         "SSAT16.CC",
	SSAT16_MI:         "SSAT16.MI",
	SSAT16_PL:         "SSAT16.PL",
	SSAT16_VS:         "SSAT16.VS",
	SSAT16_VC:         "SSAT16.VC",
	SSAT16_HI:         "SSAT16.HI",
	SSAT16_LS:         "SSAT16.LS",
	SSAT16_GE:         "SSAT16.GE",
	SSAT16_LT:         "SSAT16.LT",
	SSAT16_GT:         "SSAT16.GT",
	SSAT16_LE:         "SSAT16.LE",
	SSAT16:            "SSAT16",
	SSAT16_ZZ:         "SSAT16.ZZ",
	SSAX_EQ:           "SSAX.EQ",
	SSAX_NE:           "SSAX.NE",
	SSAX_CS:           "SSAX.CS",
	SSAX_CC:           "SSAX.CC",
	SSAX_MI:           "SSAX.MI",
	SSAX_PL:           "SSAX.PL",
	SSAX_VS:           "SSAX.VS",
	SSAX_VC:           "SSAX.VC",
	SSAX_HI:           "SSAX.HI",
	SSAX_LS:           "SSAX.LS",
	SSAX_GE:           "SSAX.GE",
	SSAX_LT:           "SSAX.LT",
	SSAX_GT:           "SSAX.GT",
	SSAX_LE:           "SSAX.LE",
	SSAX:              "SSAX",
	SSAX_ZZ:           "SSAX.ZZ",
	SSUB16_EQ:         "SSUB16.EQ",
	SSUB16_NE:         "SSUB16.NE",
	SSUB16_CS:         "SSUB16.CS",
	SSUB16_CC:         "SSUB16.CC",
	SSUB16_MI:         "SSUB16.MI",
	SSUB16_PL:         "SSUB16.PL",
	SSUB16_VS:         "SSUB16.VS",
	SSUB16_VC:         "SSUB16.VC",
	SSUB16_HI:         "SSUB16.HI",
	SSUB16_LS:         "SSUB16.LS",
	SSUB16_GE:         "SSUB16.GE",
	SSUB16_LT:         "SSUB16.LT",
	SSUB16_GT:         "SSUB16.GT",
	SSUB16_LE:         "SSUB16.LE",
	SSUB16:            "SSUB16",
	SSUB16_ZZ:         "SSUB16.ZZ",
	SSUB8_EQ:          "SSUB8.EQ",
	SSUB8_NE:          "SSUB8.NE",
	SSUB8_CS:          "SSUB8.CS",
	SSUB8_CC:          "SSUB8.CC",
	SSUB8_MI:          "SSUB8.MI",
	SSUB8_PL:          "SSUB8.PL",
	SSUB8_VS:          "SSUB8.VS",
	SSUB8_VC:          "SSUB8.VC",
	SSUB8_HI:          "SSUB8.HI",
	SSUB8_LS:          "SSUB8.LS",
	SSUB8_GE:          "SSUB8.GE",
	SSUB8_LT:          "SSUB8.LT",
	SSUB8_GT:          "SSUB8.GT",
	SSUB8_LE:          "SSUB8.LE",
	SSUB8:             "SSUB8",
	SSUB8_ZZ:          "SSUB8.ZZ",
	STM_EQ:            "STM.EQ",
	STM_NE:            "STM.NE",
	STM_CS:            "STM.CS",
	STM_CC:            "STM.CC",
	STM_MI:            "STM.MI",
	STM_PL:            "STM.PL",
	STM_VS:            "STM.VS",
	STM_VC:            "STM.VC",
	STM_HI:            "STM.HI",
	STM_LS:            "STM.LS",
	STM_GE:            "STM.GE",
	STM_LT:            "STM.LT",
	STM_GT:            "STM.GT",
	STM_LE:            "STM.LE",
	STM:               "STM",
	STM_ZZ:            "STM.ZZ",
	STMDA_EQ:          "STMDA.EQ",
	STMDA_NE:          "STMDA.NE",
	STMDA_CS:          "STMDA.CS",
	STMDA_CC:          "STMDA.CC",
	STMDA_MI:          "STMDA.MI",
	STMDA_PL:          "STMDA.PL",
	STMDA_VS:          "STMDA.VS",
	STMDA_VC:          "STMDA.VC",
	STMDA_HI:          "STMDA.HI",
	STMDA_LS:          "STMDA.LS",
	STMDA_GE:          "STMDA.GE",
	STMDA_LT:          "STMDA.LT",
	STMDA_GT:          "STMDA.GT",
	STMDA_LE:          "STMDA.LE",
	STMDA:             "STMDA",
	STMDA_ZZ:          "STMDA.ZZ",
	STMDB_EQ:          "STMDB.EQ",
	STMDB_NE:          "STMDB.NE",
	STMDB_CS:          "STMDB.CS",
	STMDB_CC:          "STMDB.CC",
	STMDB_MI:          "STMDB.MI",
	STMDB_PL:          "STMDB.PL",
	STMDB_VS:          "STMDB.VS",
	STMDB_VC:          "STMDB.VC",
	STMDB_HI:          "STMDB.HI",
	STMDB_LS:          "STMDB.LS",
	STMDB_GE:          "STMDB.GE",
	STMDB_LT:          "STMDB.LT",
	STMDB_GT:          "STMDB.GT",
	STMDB_LE:          "STMDB.LE",
	STMDB:             "STMDB",
	STMDB_ZZ:          "STMDB.ZZ",
	STMIB_EQ:          "STMIB.EQ",
	STMIB_NE:          "STMIB.NE",
	STMIB_CS:          "STMIB.CS",
	STMIB_CC:          "STMIB.CC",
	STMIB_MI:          "STMIB.MI",
	STMIB_PL:          "STMIB.PL",
	STMIB_VS:          "STMIB.VS",
	STMIB_VC:          "STMIB.VC",
	STMIB_HI:          "STMIB.HI",
	STMIB_LS:          "STMIB.LS",
	STMIB_GE:          "STMIB.GE",
	STMIB_LT:          "STMIB.LT",
	STMIB_GT:          "STMIB.GT",
	STMIB_LE:          "STMIB.LE",
	STMIB:             "STMIB",
	STMIB_ZZ:          "STMIB.ZZ",
	STR_EQ:            "STR.EQ",
	STR_NE:            "STR.NE",
	STR_CS:            "STR.CS",
	STR_CC:            "STR.CC",
	STR_MI:            "STR.MI",
	STR_PL:            "STR.PL",
	STR_VS:            "STR.VS",
	STR_VC:            "STR.VC",
	STR_HI:            "STR.HI",
	STR_LS:            "STR.LS",
	STR_GE:            "STR.GE",
	STR_LT:            "STR.LT",
	STR_GT:            "STR.GT",
	STR_LE:            "STR.LE",
	STR:               "STR",
	STR_ZZ:            "STR.ZZ",
	STRB_EQ:           "STRB.EQ",
	STRB_NE:           "STRB.NE",
	STRB_CS:           "STRB.CS",
	STRB_CC:           "STRB.CC",
	STRB_MI:           "STRB.MI",
	STRB_PL:           "STRB.PL",
	STRB_VS:           "STRB.VS",
	STRB_VC:           "STRB.VC",
	STRB_HI:           "STRB.HI",
	STRB_LS:           "STRB.LS",
	STRB_GE:           "STRB.GE",
	STRB_LT:           "STRB.LT",
	STRB_GT:           "STRB.GT",
	STRB_LE:           "STRB.LE",
	STRB:              "STRB",
	STRB_ZZ:           "STRB.ZZ",
	STRBT_EQ:          "STRBT.EQ",
	STRBT_NE:          "STRBT.NE",
	STRBT_CS:          "STRBT.CS",
	STRBT_CC:          "STRBT.CC",
	STRBT_MI:          "STRBT.MI",
	STRBT_PL:          "STRBT.PL",
	STRBT_VS:          "STRBT.VS",
	STRBT_VC:          "STRBT.VC",
	STRBT_HI:          "STRBT.HI",
	STRBT_LS:          "STRBT.LS",
	STRBT_GE:          "STRBT.GE",
	STRBT_LT:          "STRBT.LT",
	STRBT_GT:          "STRBT.GT",
	STRBT_LE:          "STRBT.LE",
	STRBT:             "STRBT",
	STRBT_ZZ:          "STRBT.ZZ",
	STRD_EQ:           "STRD.EQ",
	STRD_NE:           "STRD.NE",
	STRD_CS:           "STRD.CS",
	STRD_CC:           "STRD.CC",
	STRD_MI:           "STRD.MI",
	STRD_PL:           "STRD.PL",
	STRD_VS:           "STRD.VS",
	STRD_VC:           "STRD.VC",
	STRD_HI:           "STRD.HI",
	STRD_LS:           "STRD.LS",
	STRD_GE:           "STRD.GE",
	STRD_LT:           "STRD.LT",
	STRD_GT:           "STRD.GT",
	STRD_LE:           "STRD.LE",
	STRD:              "STRD",
	STRD_ZZ:           "STRD.ZZ",
	STREX_EQ:          "STREX.EQ",
	STREX_NE:          "STREX.NE",
	STREX_CS:          "STREX.CS",
	STREX_CC:          "STREX.CC",
	STREX_MI:          "STREX.MI",
	STREX_PL:          "STREX.PL",
	STREX_VS:          "STREX.VS",
	STREX_VC:          "STREX.VC",
	STREX_HI:          "STREX.HI",
	STREX_LS:          "STREX.LS",
	STREX_GE:          "STREX.GE",
	STREX_LT:          "STREX.LT",
	STREX_GT:          "STREX.GT",
	STREX_LE:          "STREX.LE",
	STREX:             "STREX",
	STREX_ZZ:          "STREX.ZZ",
	STREXB_EQ:         "STREXB.EQ",
	STREXB_NE:         "STREXB.NE",
	STREXB_CS:         "STREXB.CS",
	STREXB_CC:         "STREXB.CC",
	STREXB_MI:         "STREXB.MI",
	STREXB_PL:         "STREXB.PL",
	STREXB_VS:         "STREXB.VS",
	STREXB_VC:         "STREXB.VC",
	STREXB_HI:         "STREXB.HI",
	STREXB_LS:         "STREXB.LS",
	STREXB_GE:         "STREXB.GE",
	STREXB_LT:         "STREXB.LT",
	STREXB_GT:         "STREXB.GT",
	STREXB_LE:         "STREXB.LE",
	STREXB:            "STREXB",
	STREXB_ZZ:         "STREXB.ZZ",
	STREXD_EQ:         "STREXD.EQ",
	STREXD_NE:         "STREXD.NE",
	STREXD_CS:         "STREXD.CS",
	STREXD_CC:         "STREXD.CC",
	STREXD_MI:         "STREXD.MI",
	STREXD_PL:         "STREXD.PL",
	STREXD_VS:         "STREXD.VS",
	STREXD_VC:         "STREXD.VC",
	STREXD_HI:         "STREXD.HI",
	STREXD_LS:         "STREXD.LS",
	STREXD_GE:         "STREXD.GE",
	STREXD_LT:         "STREXD.LT",
	STREXD_GT:         "STREXD.GT",
	STREXD_LE:         "STREXD.LE",
	STREXD:            "STREXD",
	STREXD_ZZ:         "STREXD.ZZ",
	STREXH_EQ:         "STREXH.EQ",
	STREXH_NE:         "STREXH.NE",
	STREXH_CS:         "STREXH.CS",
	STREXH_CC:         "STREXH.CC",
	STREXH_MI:         "STREXH.MI",
	STREXH_PL:         "STREXH.PL",
	STREXH_VS:         "STREXH.VS",
	STREXH_VC:         "STREXH.VC",
	STREXH_HI:         "STREXH.HI",
	STREXH_LS:         "STREXH.LS",
	STREXH_GE:         "STREXH.GE",
	STREXH_LT:         "STREXH.LT",
	STREXH_GT:         "STREXH.GT",
	STREXH_LE:         "STREXH.LE",
	STREXH:            "STREXH",
	STREXH_ZZ:         "STREXH.ZZ",
	STRH_EQ:           "STRH.EQ",
	STRH_NE:           "STRH.NE",
	STRH_CS:           "STRH.CS",
	STRH_CC:           "STRH.CC",
	STRH_MI:           "STRH.MI",
	STRH_PL:           "STRH.PL",
	STRH_VS:           "STRH.VS",
	STRH_VC:           "STRH.VC",
	STRH_HI:           "STRH.HI",
	STRH_LS:           "STRH.LS",
	STRH_GE:           "STRH.GE",
	STRH_LT:           "STRH.LT",
	STRH_GT:           "STRH.GT",
	STRH_LE:           "STRH.LE",
	STRH:              "STRH",
	STRH_ZZ:           "STRH.ZZ",
	STRHT_EQ:          "STRHT.EQ",
	STRHT_NE:          "STRHT.NE",
	STRHT_CS:          "STRHT.CS",
	STRHT_CC:          "STRHT.CC",
	STRHT_MI:          "STRHT.MI",
	STRHT_PL:          "STRHT.PL",
	STRHT_VS:          "STRHT.VS",
	STRHT_VC:          "STRHT.VC",
	STRHT_HI:          "STRHT.HI",
	STRHT_LS:          "STRHT.LS",
	STRHT_GE:          "STRHT.GE",
	STRHT_LT:          "STRHT.LT",
	STRHT_GT:          "STRHT.GT",
	STRHT_LE:          "STRHT.LE",
	STRHT:             "STRHT",
	STRHT_ZZ:          "STRHT.ZZ",
	STRT_EQ:           "STRT.EQ",
	STRT_NE:           "STRT.NE",
	STRT_CS:           "STRT.CS",
	STRT_CC:           "STRT.CC",
	STRT_MI:           "STRT.MI",
	STRT_PL:           "STRT.PL",
	STRT_VS:           "STRT.VS",
	STRT_VC:           "STRT.VC",
	STRT_HI:           "STRT.HI",
	STRT_LS:           "STRT.LS",
	STRT_GE:           "STRT.GE",
	STRT_LT:           "STRT.LT",
	STRT_GT:           "STRT.GT",
	STRT_LE:           "STRT.LE",
	STRT:              "STRT",
	STRT_ZZ:           "STRT.ZZ",
	SUB_EQ:            "SUB.EQ",
	SUB_NE:            "SUB.NE",
	SUB_CS:            "SUB.CS",
	SUB_CC:            "SUB.CC",
	SUB_MI:            "SUB.MI",
	SUB_PL:            "SUB.PL",
	SUB_VS:            "SUB.VS",
	SUB_VC:            "SUB.VC",
	SUB_HI:            "SUB.HI",
	SUB_LS:            "SUB.LS",
	SUB_GE:            "SUB.GE",
	SUB_LT:            "SUB.LT",
	SUB_GT:            "SUB.GT",
	SUB_LE:            "SUB.LE",
	SUB:               "SUB",
	SUB_ZZ:            "SUB.ZZ",
	SUB_S_EQ:          "SUB.S.EQ",
	SUB_S_NE:          "SUB.S.NE",
	SUB_S_CS:          "SUB.S.CS",
	SUB_S_CC:          "SUB.S.CC",
	SUB_S_MI:          "SUB.S.MI",
	SUB_S_PL:          "SUB.S.PL",
	SUB_S_VS:          "SUB.S.VS",
	SUB_S_VC:          "SUB.S.VC",
	SUB_S_HI:          "SUB.S.HI",
	SUB_S_LS:          "SUB.S.LS",
	SUB_S_GE:          "SUB.S.GE",
	SUB_S_LT:          "SUB.S.LT",
	SUB_S_GT:          "SUB.S.GT",
	SUB_S_LE:          "SUB.S.LE",
	SUB_S:             "SUB.S",
	SUB_S_ZZ:          "SUB.S.ZZ",
	SVC_EQ:            "SVC.EQ",
	SVC_NE:            "SVC.NE",
	SVC_CS:            "SVC.CS",
	SVC_CC:            "SVC.CC",
	SVC_MI:            "SVC.MI",
	SVC_PL:            "SVC.PL",
	SVC_VS:            "SVC.VS",
	SVC_VC:            "SVC.VC",
	SVC_HI:            "SVC.HI",
	SVC_LS:            "SVC.LS",
	SVC_GE:            "SVC.GE",
	SVC_LT:            "SVC.LT",
	SVC_GT:            "SVC.GT",
	SVC_LE:            "SVC.LE",
	SVC:               "SVC",
	SVC_ZZ:            "SVC.ZZ",
	SWP_EQ:            "SWP.EQ",
	SWP_NE:            "SWP.NE",
	SWP_CS:            "SWP.CS",
	SWP_CC:            "SWP.CC",
	SWP_MI:            "SWP.MI",
	SWP_PL:            "SWP.PL",
	SWP_VS:            "SWP.VS",
	SWP_VC:            "SWP.VC",
	SWP_HI:            "SWP.HI",
	SWP_LS:            "SWP.LS",
	SWP_GE:            "SWP.GE",
	SWP_LT:            "SWP.LT",
	SWP_GT:            "SWP.GT",
	SWP_LE:            "SWP.LE",
	SWP:               "SWP",
	SWP_ZZ:            "SWP.ZZ",
	SWP_B_EQ:          "SWP.B.EQ",
	SWP_B_NE:          "SWP.B.NE",
	SWP_B_CS:          "SWP.B.CS",
	SWP_B_CC:          "SWP.B.CC",
	SWP_B_MI:          "SWP.B.MI",
	SWP_B_PL:          "SWP.B.PL",
	SWP_B_VS:          "SWP.B.VS",
	SWP_B_VC:          "SWP.B.VC",
	SWP_B_HI:          "SWP.B.HI",
	SWP_B_LS:          "SWP.B.LS",
	SWP_B_GE:          "SWP.B.GE",
	SWP_B_LT:          "SWP.B.LT",
	SWP_B_GT:          "SWP.B.GT",
	SWP_B_LE:          "SWP.B.LE",
	SWP_B:             "SWP.B",
	SWP_B_ZZ:          "SWP.B.ZZ",
	SXTAB_EQ:          "SXTAB.EQ",
	SXTAB_NE:          "SXTAB.NE",
	SXTAB_CS:          "SXTAB.CS",
	SXTAB_CC:          "SXTAB.CC",
	SXTAB_MI:          "SXTAB.MI",
	SXTAB_PL:          "SXTAB.PL",
	SXTAB_VS:          "SXTAB.VS",
	SXTAB_VC:          "SXTAB.VC",
	SXTAB_HI:          "SXTAB.HI",
	SXTAB_LS:          "SXTAB.LS",
	SXTAB_GE:          "SXTAB.GE",
	SXTAB_LT:          "SXTAB.LT",
	SXTAB_GT:          "SXTAB.GT",
	SXTAB_LE:          "SXTAB.LE",
	SXTAB:             "SXTAB",
	SXTAB_ZZ:          "SXTAB.ZZ",
	SXTAB16_EQ:        "SXTAB16.EQ",
	SXTAB16_NE:        "SXTAB16.NE",
	SXTAB16_CS:        "SXTAB16.CS",
	SXTAB16_CC:        "SXTAB16.CC",
	SXTAB16_MI:        "SXTAB16.MI",
	SXTAB16_PL:        "SXTAB16.PL",
	SXTAB16_VS:        "SXTAB16.VS",
	SXTAB16_VC:        "SXTAB16.VC",
	SXTAB16_HI:        "SXTAB16.HI",
	SXTAB16_LS:        "SXTAB16.LS",
	SXTAB16_GE:        "SXTAB16.GE",
	SXTAB16_LT:        "SXTAB16.LT",
	SXTAB16_GT:        "SXTAB16.GT",
	SXTAB16_LE:        "SXTAB16.LE",
	SXTAB16:           "SXTAB16",
	SXTAB16_ZZ:        "SXTAB16.ZZ",
	SXTAH_EQ:          "SXTAH.EQ",
	SXTAH_NE:          "SXTAH.NE",
	SXTAH_CS:          "SXTAH.CS",
	SXTAH_CC:          "SXTAH.CC",
	SXTAH_MI:          "SXTAH.MI",
	SXTAH_PL:          "SXTAH.PL",
	SXTAH_VS:          "SXTAH.VS",
	SXTAH_VC:          "SXTAH.VC",
	SXTAH_HI:          "SXTAH.HI",
	SXTAH_LS:          "SXTAH.LS",
	SXTAH_GE:          "SXTAH.GE",
	SXTAH_LT:          "SXTAH.LT",
	SXTAH_GT:          "SXTAH.GT",
	SXTAH_LE:          "SXTAH.LE",
	SXTAH:             "SXTAH",
	SXTAH_ZZ:          "SXTAH.ZZ",
	SXTB_EQ:           "SXTB.EQ",
	SXTB_NE:           "SXTB.NE",
	SXTB_CS:           "SXTB.CS",
	SXTB_CC:           "SXTB.CC",
	SXTB_MI:           "SXTB.MI",
	SXTB_PL:           "SXTB.PL",
	SXTB_VS:           "SXTB.VS",
	SXTB_VC:           "SXTB.VC",
	SXTB_HI:           "SXTB.HI",
	SXTB_LS:           "SXTB.LS",
	SXTB_GE:           "SXTB.GE",
	SXTB_LT:           "SXTB.LT",
	SXTB_GT:           "SXTB.GT",
	SXTB_LE:           "SXTB.LE",
	SXTB:              "SXTB",
	SXTB_ZZ:           "SXTB.ZZ",
	SXTB16_EQ:         "SXTB16.EQ",
	SXTB16_NE:         "SXTB16.NE",
	SXTB16_CS:         "SXTB16.CS",
	SXTB16_CC:         "SXTB16.CC",
	SXTB16_MI:         "SXTB16.MI",
	SXTB16_PL:         "SXTB16.PL",
	SXTB16_VS:         "SXTB16.VS",
	SXTB16_VC:         "SXTB16.VC",
	SXTB16_HI:         "SXTB16.HI",
	SXTB16_LS:         "SXTB16.LS",
	SXTB16_GE:         "SXTB16.GE",
	SXTB16_LT:         "SXTB16.LT",
	SXTB16_GT:         "SXTB16.GT",
	SXTB16_LE:         "SXTB16.LE",
	SXTB16:            "SXTB16",
	SXTB16_ZZ:         "SXTB16.ZZ",
	SXTH_EQ:           "SXTH.EQ",
	SXTH_NE:           "SXTH.NE",
	SXTH_CS:           "SXTH.CS",
	SXTH_CC:           "SXTH.CC",
	SXTH_MI:           "SXTH.MI",
	SXTH_PL:           "SXTH.PL",
	SXTH_VS:           "SXTH.VS",
	SXTH_VC:           "SXTH.VC",
	SXTH_HI:           "SXTH.HI",
	SXTH_LS:           "SXTH.LS",
	SXTH_GE:           "SXTH.GE",
	SXTH_LT:           "SXTH.LT",
	SXTH_GT:           "SXTH.GT",
	SXTH_LE:           "SXTH.LE",
	SXTH:              "SXTH",
	SXTH_ZZ:           "SXTH.ZZ",
	TEQ_EQ:            "TEQ.EQ",
	TEQ_NE:            "TEQ.NE",
	TEQ_CS:            "TEQ.CS",
	TEQ_CC:            "TEQ.CC",
	TEQ_MI:            "TEQ.MI",
	TEQ_PL:            "TEQ.PL",
	TEQ_VS:            "TEQ.VS",
	TEQ_VC:            "TEQ.VC",
	TEQ_HI:            "TEQ.HI",
	TEQ_LS:            "TEQ.LS",
	TEQ_GE:            "TEQ.GE",
	TEQ_LT:            "TEQ.LT",
	TEQ_GT:            "TEQ.GT",
	TEQ_LE:            "TEQ.LE",
	TEQ:               "TEQ",
	TEQ_ZZ:            "TEQ.ZZ",
	TST_EQ:            "TST.EQ",
	TST_NE:            "TST.NE",
	TST_CS:            "TST.CS",
	TST_CC:            "TST.CC",
	TST_MI:            "TST.MI",
	TST_PL:            "TST.PL",
	TST_VS:            "TST.VS",
	TST_VC:            "TST.VC",
	TST_HI:            "TST.HI",
	TST_LS:            "TST.LS",
	TST_GE:            "TST.GE",
	TST_LT:            "TST.LT",
	TST_GT:            "TST.GT",
	TST_LE:            "TST.LE",
	TST:               "TST",
	TST_ZZ:            "TST.ZZ",
	UADD16_EQ:         "UADD16.EQ",
	UADD16_NE:         "UADD16.NE",
	UADD16_CS:         "UADD16.CS",
	UADD16_CC:         "UADD16.CC",
	UADD16_MI:         "UADD16.MI",
	UADD16_PL:         "UADD16.PL",
	UADD16_VS:         "UADD16.VS",
	UADD16_VC:         "UADD16.VC",
	UADD16_HI:         "UADD16.HI",
	UADD16_LS:         "UADD16.LS",
	UADD16_GE:         "UADD16.GE",
	UADD16_LT:         "UADD16.LT",
	UADD16_GT:         "UADD16.GT",
	UADD16_LE:         "UADD16.LE",
	UADD16:            "UADD16",
	UADD16_ZZ:         "UADD16.ZZ",
	UADD8_EQ:          "UADD8.EQ",
	UADD8_NE:          "UADD8.NE",
	UADD8_CS:          "UADD8.CS",
	UADD8_CC:          "UADD8.CC",
	UADD8_MI:          "UADD8.MI",
	UADD8_PL:          "UADD8.PL",
	UADD8_VS:          "UADD8.VS",
	UADD8_VC:          "UADD8.VC",
	UADD8_HI:          "UADD8.HI",
	UADD8_LS:          "UADD8.LS",
	UADD8_GE:          "UADD8.GE",
	UADD8_LT:          "UADD8.LT",
	UADD8_GT:          "UADD8.GT",
	UADD8_LE:          "UADD8.LE",
	UADD8:             "UADD8",
	UADD8_ZZ:          "UADD8.ZZ",
	UASX_EQ:           "UASX.EQ",
	UASX_NE:           "UASX.NE",
	UASX_CS:           "UASX.CS",
	UASX_CC:           "UASX.CC",
	UASX_MI:           "UASX.MI",
	UASX_PL:           "UASX.PL",
	UASX_VS:           "UASX.VS",
	UASX_VC:           "UASX.VC",
	UASX_HI:           "UASX.HI",
	UASX_LS:           "UASX.LS",
	UASX_GE:           "UASX.GE",
	UASX_LT:           "UASX.LT",
	UASX_GT:           "UASX.GT",
	UASX_LE:           "UASX.LE",
	UASX:              "UASX",
	UASX_ZZ:           "UASX.ZZ",
	UBFX_EQ:           "UBFX.EQ",
	UBFX_NE:           "UBFX.NE",
	UBFX_CS:           "UBFX.CS",
	UBFX_CC:           "UBFX.CC",
	UBFX_MI:           "UBFX.MI",
	UBFX_PL:           "UBFX.PL",
	UBFX_VS:           "UBFX.VS",
	UBFX_VC:           "UBFX.VC",
	UBFX_HI:           "UBFX.HI",
	UBFX_LS:           "UBFX.LS",
	UBFX_GE:           "UBFX.GE",
	UBFX_LT:           "UBFX.LT",
	UBFX_GT:           "UBFX.GT",
	UBFX_LE:           "UBFX.LE",
	UBFX:              "UBFX",
	UBFX_ZZ:           "UBFX.ZZ",
	UHADD16_EQ:        "UHADD16.EQ",
	UHADD16_NE:        "UHADD16.NE",
	UHADD16_CS:        "UHADD16.CS",
	UHADD16_CC:        "UHADD16.CC",
	UHADD16_MI:        "UHADD16.MI",
	UHADD16_PL:        "UHADD16.PL",
	UHADD16_VS:        "UHADD16.VS",
	UHADD16_VC:        "UHADD16.VC",
	UHADD16_HI:        "UHADD16.HI",
	UHADD16_LS:        "UHADD16.LS",
	UHADD16_GE:        "UHADD16.GE",
	UHADD16_LT:        "UHADD16.LT",
	UHADD16_GT:        "UHADD16.GT",
	UHADD16_LE:        "UHADD16.LE",
	UHADD16:           "UHADD16",
	UHADD16_ZZ:        "UHADD16.ZZ",
	UHADD8_EQ:         "UHADD8.EQ",
	UHADD8_NE:         "UHADD8.NE",
	UHADD8_CS:         "UHADD8.CS",
	UHADD8_CC:         "UHADD8.CC",
	UHADD8_MI:         "UHADD8.MI",
	UHADD8_PL:         "UHADD8.PL",
	UHADD8_VS:         "UHADD8.VS",
	UHADD8_VC:         "UHADD8.VC",
	UHADD8_HI:         "UHADD8.HI",
	UHADD8_LS:         "UHADD8.LS",
	UHADD8_GE:         "UHADD8.GE",
	UHADD8_LT:         "UHADD8.LT",
	UHADD8_GT:         "UHADD8.GT",
	UHADD8_LE:         "UHADD8.LE",
	UHADD8:            "UHADD8",
	UHADD8_ZZ:         "UHADD8.ZZ",
	UHASX_EQ:          "UHASX.EQ",
	UHASX_NE:          "UHASX.NE",
	UHASX_CS:          "UHASX.CS",
	UHASX_CC:          "UHASX.CC",
	UHASX_MI:          "UHASX.MI",
	UHASX_PL:          "UHASX.PL",
	UHASX_VS:          "UHASX.VS",
	UHASX_VC:          "UHASX.VC",
	UHASX_HI:          "UHASX.HI",
	UHASX_LS:          "UHASX.LS",
	UHASX_GE:          "UHASX.GE",
	UHASX_LT:          "UHASX.LT",
	UHASX_GT:          "UHASX.GT",
	UHASX_LE:          "UHASX.LE",
	UHASX:             "UHASX",
	UHASX_ZZ:          "UHASX.ZZ",
	UHSAX_EQ:          "UHSAX.EQ",
	UHSAX_NE:          "UHSAX.NE",
	UHSAX_CS:          "UHSAX.CS",
	UHSAX_CC:          "UHSAX.CC",
	UHSAX_MI:          "UHSAX.MI",
	UHSAX_PL:          "UHSAX.PL",
	UHSAX_VS:          "UHSAX.VS",
	UHSAX_VC:          "UHSAX.VC",
	UHSAX_HI:          "UHSAX.HI",
	UHSAX_LS:          "UHSAX.LS",
	UHSAX_GE:          "UHSAX.GE",
	UHSAX_LT:          "UHSAX.LT",
	UHSAX_GT:          "UHSAX.GT",
	UHSAX_LE:          "UHSAX.LE",
	UHSAX:             "UHSAX",
	UHSAX_ZZ:          "UHSAX.ZZ",
	UHSUB16_EQ:        "UHSUB16.EQ",
	UHSUB16_NE:        "UHSUB16.NE",
	UHSUB16_CS:        "UHSUB16.CS",
	UHSUB16_CC:        "UHSUB16.CC",
	UHSUB16_MI:        "UHSUB16.MI",
	UHSUB16_PL:        "UHSUB16.PL",
	UHSUB16_VS:        "UHSUB16.VS",
	UHSUB16_VC:        "UHSUB16.VC",
	UHSUB16_HI:        "UHSUB16.HI",
	UHSUB16_LS:        "UHSUB16.LS",
	UHSUB16_GE:        "UHSUB16.GE",
	UHSUB16_LT:        "UHSUB16.LT",
	UHSUB16_GT:        "UHSUB16.GT",
	UHSUB16_LE:        "UHSUB16.LE",
	UHSUB16:           "UHSUB16",
	UHSUB16_ZZ:        "UHSUB16.ZZ",
	UHSUB8_EQ:         "UHSUB8.EQ",
	UHSUB8_NE:         "UHSUB8.NE",
	UHSUB8_CS:         "UHSUB8.CS",
	UHSUB8_CC:         "UHSUB8.CC",
	UHSUB8_MI:         "UHSUB8.MI",
	UHSUB8_PL:         "UHSUB8.PL",
	UHSUB8_VS:         "UHSUB8.VS",
	UHSUB8_VC:         "UHSUB8.VC",
	UHSUB8_HI:         "UHSUB8.HI",
	UHSUB8_LS:         "UHSUB8.LS",
	UHSUB8_GE:         "UHSUB8.GE",
	UHSUB8_LT:         "UHSUB8.LT",
	UHSUB8_GT:         "UHSUB8.GT",
	UHSUB8_LE:         "UHSUB8.LE",
	UHSUB8:            "UHSUB8",
	UHSUB8_ZZ:         "UHSUB8.ZZ",
	UMAAL_EQ:          "UMAAL.EQ",
	UMAAL_NE:          "UMAAL.NE",
	UMAAL_CS:          "UMAAL.CS",
	UMAAL_CC:          "UMAAL.CC",
	UMAAL_MI:          "UMAAL.MI",
	UMAAL_PL:          "UMAAL.PL",
	UMAAL_VS:          "UMAAL.VS",
	UMAAL_VC:          "UMAAL.VC",
	UMAAL_HI:          "UMAAL.HI",
	UMAAL_LS:          "UMAAL.LS",
	UMAAL_GE:          "UMAAL.GE",
	UMAAL_LT:          "UMAAL.LT",
	UMAAL_GT:          "UMAAL.GT",
	UMAAL_LE:          "UMAAL.LE",
	UMAAL:             "UMAAL",
	UMAAL_ZZ:          "UMAAL.ZZ",
	UMLAL_EQ:          "UMLAL.EQ",
	UMLAL_NE:          "UMLAL.NE",
	UMLAL_CS:          "UMLAL.CS",
	UMLAL_CC:          "UMLAL.CC",
	UMLAL_MI:          "UMLAL.MI",
	UMLAL_PL:          "UMLAL.PL",
	UMLAL_VS:          "UMLAL.VS",
	UMLAL_VC:          "UMLAL.VC",
	UMLAL_HI:          "UMLAL.HI",
	UMLAL_LS:          "UMLAL.LS",
	UMLAL_GE:          "UMLAL.GE",
	UMLAL_LT:          "UMLAL.LT",
	UMLAL_GT:          "UMLAL.GT",
	UMLAL_LE:          "UMLAL.LE",
	UMLAL:             "UMLAL",
	UMLAL_ZZ:          "UMLAL.ZZ",
	UMLAL_S_EQ:        "UMLAL.S.EQ",
	UMLAL_S_NE:        "UMLAL.S.NE",
	UMLAL_S_CS:        "UMLAL.S.CS",
	UMLAL_S_CC:        "UMLAL.S.CC",
	UMLAL_S_MI:        "UMLAL.S.MI",
	UMLAL_S_PL:        "UMLAL.S.PL",
	UMLAL_S_VS:        "UMLAL.S.VS",
	UMLAL_S_VC:        "UMLAL.S.VC",
	UMLAL_S_HI:        "UMLAL.S.HI",
	UMLAL_S_LS:        "UMLAL.S.LS",
	UMLAL_S_GE:        "UMLAL.S.GE",
	UMLAL_S_LT:        "UMLAL.S.LT",
	UMLAL_S_GT:        "UMLAL.S.GT",
	UMLAL_S_LE:        "UMLAL.S.LE",
	UMLAL_S:           "UMLAL.S",
	UMLAL_S_ZZ:        "UMLAL.S.ZZ",
	UMULL_EQ:          "UMULL.EQ",
	UMULL_NE:          "UMULL.NE",
	UMULL_CS:          "UMULL.CS",
	UMULL_CC:          "UMULL.CC",
	UMULL_MI:          "UMULL.MI",
	UMULL_PL:          "UMULL.PL",
	UMULL_VS:          "UMULL.VS",
	UMULL_VC:          "UMULL.VC",
	UMULL_HI:          "UMULL.HI",
	UMULL_LS:          "UMULL.LS",
	UMULL_GE:          "UMULL.GE",
	UMULL_LT:          "UMULL.LT",
	UMULL_GT:          "UMULL.GT",
	UMULL_LE:          "UMULL.LE",
	UMULL:             "UMULL",
	UMULL_ZZ:          "UMULL.ZZ",
	UMULL_S_EQ:        "UMULL.S.EQ",
	UMULL_S_NE:        "UMULL.S.NE",
	UMULL_S_CS:        "UMULL.S.CS",
	UMULL_S_CC:        "UMULL.S.CC",
	UMULL_S_MI:        "UMULL.S.MI",
	UMULL_S_PL:        "UMULL.S.PL",
	UMULL_S_VS:        "UMULL.S.VS",
	UMULL_S_VC:        "UMULL.S.VC",
	UMULL_S_HI:        "UMULL.S.HI",
	UMULL_S_LS:        "UMULL.S.LS",
	UMULL_S_GE:        "UMULL.S.GE",
	UMULL_S_LT:        "UMULL.S.LT",
	UMULL_S_GT:        "UMULL.S.GT",
	UMULL_S_LE:        "UMULL.S.LE",
	UMULL_S:           "UMULL.S",
	UMULL_S_ZZ:        "UMULL.S.ZZ",
	UNDEF:             "UNDEF",
	UQADD16_EQ:        "UQADD16.EQ",
	UQADD16_NE:        "UQADD16.NE",
	UQADD16_CS:        "UQADD16.CS",
	UQADD16_CC:        "UQADD16.CC",
	UQADD16_MI:        "UQADD16.MI",
	UQADD16_PL:        "UQADD16.PL",
	UQADD16_VS:        "UQADD16.VS",
	UQADD16_VC:        "UQADD16.VC",
	UQADD16_HI:        "UQADD16.HI",
	UQADD16_LS:        "UQADD16.LS",
	UQADD16_GE:        "UQADD16.GE",
	UQADD16_LT:        "UQADD16.LT",
	UQADD16_GT:        "UQADD16.GT",
	UQADD16_LE:        "UQADD16.LE",
	UQADD16:           "UQADD16",
	UQADD16_ZZ:        "UQADD16.ZZ",
	UQADD8_EQ:         "UQADD8.EQ",
	UQADD8_NE:         "UQADD8.NE",
	UQADD8_CS:         "UQADD8.CS",
	UQADD8_CC:         "UQADD8.CC",
	UQADD8_MI:         "UQADD8.MI",
	UQADD8_PL:         "UQADD8.PL",
	UQADD8_VS:         "UQADD8.VS",
	UQADD8_VC:         "UQADD8.VC",
	UQADD8_HI:         "UQADD8.HI",
	UQADD8_LS:         "UQADD8.LS",
	UQADD8_GE:         "UQADD8.GE",
	UQADD8_LT:         "UQADD8.LT",
	UQADD8_GT:         "UQADD8.GT",
	UQADD8_LE:         "UQADD8.LE",
	UQADD8:            "UQADD8",
	UQADD8_ZZ:         "UQADD8.ZZ",
	UQASX_EQ:          "UQASX.EQ",
	UQASX_NE:          "UQASX.NE",
	UQASX_CS:          "UQASX.CS",
	UQASX_CC:          "UQASX.CC",
	UQASX_MI:          "UQASX.MI",
	UQASX_PL:          "UQASX.PL",
	UQASX_VS:          "UQASX.VS",
	UQASX_VC:          "UQASX.VC",
	UQASX_HI:          "UQASX.HI",
	UQASX_LS:          "UQASX.LS",
	UQASX_GE:          "UQASX.GE",
	UQASX_LT:          "UQASX.LT",
	UQASX_GT:          "UQASX.GT",
	UQASX_LE:          "UQASX.LE",
	UQASX:             "UQASX",
	UQASX_ZZ:          "UQASX.ZZ",
	UQSAX_EQ:          "UQSAX.EQ",
	UQSAX_NE:          "UQSAX.NE",
	UQSAX_CS:          "UQSAX.CS",
	UQSAX_CC:          "UQSAX.CC",
	UQSAX_MI:          "UQSAX.MI",
	UQSAX_PL:          "UQSAX.PL",
	UQSAX_VS:          "UQSAX.VS",
	UQSAX_VC:          "UQSAX.VC",
	UQSAX_HI:          "UQSAX.HI",
	UQSAX_LS:          "UQSAX.LS",
	UQSAX_GE:          "UQSAX.GE",
	UQSAX_LT:          "UQSAX.LT",
	UQSAX_GT:          "UQSAX.GT",
	UQSAX_LE:          "UQSAX.LE",
	UQSAX:             "UQSAX",
	UQSAX_ZZ:          "UQSAX.ZZ",
	UQSUB16_EQ:        "UQSUB16.EQ",
	UQSUB16_NE:        "UQSUB16.NE",
	UQSUB16_CS:        "UQSUB16.CS",
	UQSUB16_CC:        "UQSUB16.CC",
	UQSUB16_MI:        "UQSUB16.MI",
	UQSUB16_PL:        "UQSUB16.PL",
	UQSUB16_VS:        "UQSUB16.VS",
	UQSUB16_VC:        "UQSUB16.VC",
	UQSUB16_HI:        "UQSUB16.HI",
	UQSUB16_LS:        "UQSUB16.LS",
	UQSUB16_GE:        "UQSUB16.GE",
	UQSUB16_LT:        "UQSUB16.LT",
	UQSUB16_GT:        "UQSUB16.GT",
	UQSUB16_LE:        "UQSUB16.LE",
	UQSUB16:           "UQSUB16",
	UQSUB16_ZZ:        "UQSUB16.ZZ",
	UQSUB8_EQ:         "UQSUB8.EQ",
	UQSUB8_NE:         "UQSUB8.NE",
	UQSUB8_CS:         "UQSUB8.CS",
	UQSUB8_CC:         "UQSUB8.CC",
	UQSUB8_MI:         "UQSUB8.MI",
	UQSUB8_PL:         "UQSUB8.PL",
	UQSUB8_VS:         "UQSUB8.VS",
	UQSUB8_VC:         "UQSUB8.VC",
	UQSUB8_HI:         "UQSUB8.HI",
	UQSUB8_LS:         "UQSUB8.LS",
	UQSUB8_GE:         "UQSUB8.GE",
	UQSUB8_LT:         "UQSUB8.LT",
	UQSUB8_GT:         "UQSUB8.GT",
	UQSUB8_LE:         "UQSUB8.LE",
	UQSUB8:            "UQSUB8",
	UQSUB8_ZZ:         "UQSUB8.ZZ",
	USAD8_EQ:          "USAD8.EQ",
	USAD8_NE:          "USAD8.NE",
	USAD8_CS:          "USAD8.CS",
	USAD8_CC:          "USAD8.CC",
	USAD8_MI:          "USAD8.MI",
	USAD8_PL:          "USAD8.PL",
	USAD8_VS:          "USAD8.VS",
	USAD8_VC:          "USAD8.VC",
	USAD8_HI:          "USAD8.HI",
	USAD8_LS:          "USAD8.LS",
	USAD8_GE:          "USAD8.GE",
	USAD8_LT:          "USAD8.LT",
	USAD8_GT:          "USAD8.GT",
	USAD8_LE:          "USAD8.LE",
	USAD8:             "USAD8",
	USAD8_ZZ:          "USAD8.ZZ",
	USADA8_EQ:         "USADA8.EQ",
	USADA8_NE:         "USADA8.NE",
	USADA8_CS:         "USADA8.CS",
	USADA8_CC:         "USADA8.CC",
	USADA8_MI:         "USADA8.MI",
	USADA8_PL:         "USADA8.PL",
	USADA8_VS:         "USADA8.VS",
	USADA8_VC:         "USADA8.VC",
	USADA8_HI:         "USADA8.HI",
	USADA8_LS:         "USADA8.LS",
	USADA8_GE:         "USADA8.GE",
	USADA8_LT:         "USADA8.LT",
	USADA8_GT:         "USADA8.GT",
	USADA8_LE:         "USADA8.LE",
	USADA8:            "USADA8",
	USADA8_ZZ:         "USADA8.ZZ",
	USAT_EQ:           "USAT.EQ",
	USAT_NE:           "USAT.NE",
	USAT_CS:           "USAT.CS",
	USAT_CC:           "USAT.CC",
	USAT_MI:           "USAT.MI",
	USAT_PL:           "USAT.PL",
	USAT_VS:           "USAT.VS",
	USAT_VC:           "USAT.VC",
	USAT_HI:           "USAT.HI",
	USAT_LS:           "USAT.LS",
	USAT_GE:           "USAT.GE",
	USAT_LT:           "USAT.LT",
	USAT_GT:           "USAT.GT",
	USAT_LE:           "USAT.LE",
	USAT:              "USAT",
	USAT_ZZ:           "USAT.ZZ",
	USAT16_EQ:         "USAT16.EQ",
	USAT16_NE:         "USAT16.NE",
	USAT16_CS:         "USAT16.CS",
	USAT16_CC:         "USAT16.CC",
	USAT16_MI:         "USAT16.MI",
	USAT16_PL:         "USAT16.PL",
	USAT16_VS:         "USAT16.VS",
	USAT16_VC:         "USAT16.VC",
	USAT16_HI:         "USAT16.HI",
	USAT16_LS:         "USAT16.LS",
	USAT16_GE:         "USAT16.GE",
	USAT16_LT:         "USAT16.LT",
	USAT16_GT:         "USAT16.GT",
	USAT16_LE:         "USAT16.LE",
	USAT16:            "USAT16",
	USAT16_ZZ:         "USAT16.ZZ",
	USAX_EQ:           "USAX.EQ",
	USAX_NE:           "USAX.NE",
	USAX_CS:           "USAX.CS",
	USAX_CC:           "USAX.CC",
	USAX_MI:           "USAX.MI",
	USAX_PL:           "USAX.PL",
	USAX_VS:           "USAX.VS",
	USAX_VC:           "USAX.VC",
	USAX_HI:           "USAX.HI",
	USAX_LS:           "USAX.LS",
	USAX_GE:           "USAX.GE",
	USAX_LT:           "USAX.LT",
	USAX_GT:           "USAX.GT",
	USAX_LE:           "USAX.LE",
	USAX:              "USAX",
	USAX_ZZ:           "USAX.ZZ",
	USUB16_EQ:         "USUB16.EQ",
	USUB16_NE:         "USUB16.NE",
	USUB16_CS:         "USUB16.CS",
	USUB16_CC:         "USUB16.CC",
	USUB16_MI:         "USUB16.MI",
	USUB16_PL:         "USUB16.PL",
	USUB16_VS:         "USUB16.VS",
	USUB16_VC:         "USUB16.VC",
	USUB16_HI:         "USUB16.HI",
	USUB16_LS:         "USUB16.LS",
	USUB16_GE:         "USUB16.GE",
	USUB16_LT:         "USUB16.LT",
	USUB16_GT:         "USUB16.GT",
	USUB16_LE:         "USUB16.LE",
	USUB16:            "USUB16",
	USUB16_ZZ:         "USUB16.ZZ",
	USUB8_EQ:          "USUB8.EQ",
	USUB8_NE:          "USUB8.NE",
	USUB8_CS:          "USUB8.CS",
	USUB8_CC:          "USUB8.CC",
	USUB8_MI:          "USUB8.MI",
	USUB8_PL:          "USUB8.PL",
	USUB8_VS:          "USUB8.VS",
	USUB8_VC:          "USUB8.VC",
	USUB8_HI:          "USUB8.HI",
	USUB8_LS:          "USUB8.LS",
	USUB8_GE:          "USUB8.GE",
	USUB8_LT:          "USUB8.LT",
	USUB8_GT:          "USUB8.GT",
	USUB8_LE:          "USUB8.LE",
	USUB8:             "USUB8",
	USUB8_ZZ:          "USUB8.ZZ",
	UXTAB_EQ:          "UXTAB.EQ",
	UXTAB_NE:          "UXTAB.NE",
	UXTAB_CS:          "UXTAB.CS",
	UXTAB_CC:          "UXTAB.CC",
	UXTAB_MI:          "UXTAB.MI",
	UXTAB_PL:          "UXTAB.PL",
	UXTAB_VS:          "UXTAB.VS",
	UXTAB_VC:          "UXTAB.VC",
	UXTAB_HI:          "UXTAB.HI",
	UXTAB_LS:          "UXTAB.LS",
	UXTAB_GE:          "UXTAB.GE",
	UXTAB_LT:          "UXTAB.LT",
	UXTAB_GT:          "UXTAB.GT",
	UXTAB_LE:          "UXTAB.LE",
	UXTAB:             "UXTAB",
	UXTAB_ZZ:          "UXTAB.ZZ",
	UXTAB16_EQ:        "UXTAB16.EQ",
	UXTAB16_NE:        "UXTAB16.NE",
	UXTAB16_CS:        "UXTAB16.CS",
	UXTAB16_CC:        "UXTAB16.CC",
	UXTAB16_MI:        "UXTAB16.MI",
	UXTAB16_PL:        "UXTAB16.PL",
	UXTAB16_VS:        "UXTAB16.VS",
	UXTAB16_VC:        "UXTAB16.VC",
	UXTAB16_HI:        "UXTAB16.HI",
	UXTAB16_LS:        "UXTAB16.LS",
	UXTAB16_GE:        "UXTAB16.GE",
	UXTAB16_LT:        "UXTAB16.LT",
	UXTAB16_GT:        "UXTAB16.GT",
	UXTAB16_LE:        "UXTAB16.LE",
	UXTAB16:           "UXTAB16",
	UXTAB16_ZZ:        "UXTAB16.ZZ",
	UXTAH_EQ:          "UXTAH.EQ",
	UXTAH_NE:          "UXTAH.NE",
	UXTAH_CS:          "UXTAH.CS",
	UXTAH_CC:          "UXTAH.CC",
	UXTAH_MI:          "UXTAH.MI",
	UXTAH_PL:          "UXTAH.PL",
	UXTAH_VS:          "UXTAH.VS",
	UXTAH_VC:          "UXTAH.VC",
	UXTAH_HI:          "UXTAH.HI",
	UXTAH_LS:          "UXTAH.LS",
	UXTAH_GE:          "UXTAH.GE",
	UXTAH_LT:          "UXTAH.LT",
	UXTAH_GT:          "UXTAH.GT",
	UXTAH_LE:          "UXTAH.LE",
	UXTAH:             "UXTAH",
	UXTAH_ZZ:          "UXTAH.ZZ",
	UXTB_EQ:           "UXTB.EQ",
	UXTB_NE:           "UXTB.NE",
	UXTB_CS:           "UXTB.CS",
	UXTB_CC:           "UXTB.CC",
	UXTB_MI:           "UXTB.MI",
	UXTB_PL:           "UXTB.PL",
	UXTB_VS:           "UXTB.VS",
	UXTB_VC:           "UXTB.VC",
	UXTB_HI:           "UXTB.HI",
	UXTB_LS:           "UXTB.LS",
	UXTB_GE:           "UXTB.GE",
	UXTB_LT:           "UXTB.LT",
	UXTB_GT:           "UXTB.GT",
	UXTB_LE:           "UXTB.LE",
	UXTB:              "UXTB",
	UXTB_ZZ:           "UXTB.ZZ",
	UXTB16_EQ:         "UXTB16.EQ",
	UXTB16_NE:         "UXTB16.NE",
	UXTB16_CS:         "UXTB16.CS",
	UXTB16_CC:         "UXTB16.CC",
	UXTB16_MI:         "UXTB16.MI",
	UXTB16_PL:         "UXTB16.PL",
	UXTB16_VS:         "UXTB16.VS",
	UXTB16_VC:         "UXTB16.VC",
	UXTB16_HI:         "UXTB16.HI",
	UXTB16_LS:         "UXTB16.LS",
	UXTB16_GE:         "UXTB16.GE",
	UXTB16_LT:         "UXTB16.LT",
	UXTB16_GT:         "UXTB16.GT",
	UXTB16_LE:         "UXTB16.LE",
	UXTB16:            "UXTB16",
	UXTB16_ZZ:         "UXTB16.ZZ",
	UXTH_EQ:           "UXTH.EQ",
	UXTH_NE:           "UXTH.NE",
	UXTH_CS:           "UXTH.CS",
	UXTH_CC:           "UXTH.CC",
	UXTH_MI:           "UXTH.MI",
	UXTH_PL:           "UXTH.PL",
	UXTH_VS:           "UXTH.VS",
	UXTH_VC:           "UXTH.VC",
	UXTH_HI:           "UXTH.HI",
	UXTH_LS:           "UXTH.LS",
	UXTH_GE:           "UXTH.GE",
	UXTH_LT:           "UXTH.LT",
	UXTH_GT:           "UXTH.GT",
	UXTH_LE:           "UXTH.LE",
	UXTH:              "UXTH",
	UXTH_ZZ:           "UXTH.ZZ",
	VABS_EQ_F32:       "VABS.EQ.F32",
	VABS_NE_F32:       "VABS.NE.F32",
	VABS_CS_F32:       "VABS.CS.F32",
	VABS_CC_F32:       "VABS.CC.F32",
	VABS_MI_F32:       "VABS.MI.F32",
	VABS_PL_F32:       "VABS.PL.F32",
	VABS_VS_F32:       "VABS.VS.F32",
	VABS_VC_F32:       "VABS.VC.F32",
	VABS_HI_F32:       "VABS.HI.F32",
	VABS_LS_F32:       "VABS.LS.F32",
	VABS_GE_F32:       "VABS.GE.F32",
	VABS_LT_F32:       "VABS.LT.F32",
	VABS_GT_F32:       "VABS.GT.F32",
	VABS_LE_F32:       "VABS.LE.F32",
	VABS_F32:          "VABS.F32",
	VABS_ZZ_F32:       "VABS.ZZ.F32",
	VABS_EQ_F64:       "VABS.EQ.F64",
	VABS_NE_F64:       "VABS.NE.F64",
	VABS_CS_F64:       "VABS.CS.F64",
	VABS_CC_F64:       "VABS.CC.F64",
	VABS_MI_F64:       "VABS.MI.F64",
	VABS_PL_F64:       "VABS.PL.F64",
	VABS_VS_F64:       "VABS.VS.F64",
	VABS_VC_F64:       "VABS.VC.F64",
	VABS_HI_F64:       "VABS.HI.F64",
	VABS_LS_F64:       "VABS.LS.F64",
	VABS_GE_F64:       "VABS.GE.F64",
	VABS_LT_F64:       "VABS.LT.F64",
	VABS_GT_F64:       "VABS.GT.F64",
	VABS_LE_F64:       "VABS.LE.F64",
	VABS_F64:          "VABS.F64",
	VABS_ZZ_F64:       "VABS.ZZ.F64",
	VADD_EQ_F32:       "VADD.EQ.F32",
	VADD_NE_F32:       "VADD.NE.F32",
	VADD_CS_F32:       "VADD.CS.F32",
	VADD_CC_F32:       "VADD.CC.F32",
	VADD_MI_F32:       "VADD.MI.F32",
	VADD_PL_F32:       "VADD.PL.F32",
	VADD_VS_F32:       "VADD.VS.F32",
	VADD_VC_F32:       "VADD.VC.F32",
	VADD_HI_F32:       "VADD.HI.F32",
	VADD_LS_F32:       "VADD.LS.F32",
	VADD_GE_F32:       "VADD.GE.F32",
	VADD_LT_F32:       "VADD.LT.F32",
	VADD_GT_F32:       "VADD.GT.F32",
	VADD_LE_F32:       "VADD.LE.F32",
	VADD_F32:          "VADD.F32",
	VADD_ZZ_F32:       "VADD.ZZ.F32",
	VADD_EQ_F64:       "VADD.EQ.F64",
	VADD_NE_F64:       "VADD.NE.F64",
	VADD_CS_F64:       "VADD.CS.F64",
	VADD_CC_F64:       "VADD.CC.F64",
	VADD_MI_F64:       "VADD.MI.F64",
	VADD_PL_F64:       "VADD.PL.F64",
	VADD_VS_F64:       "VADD.VS.F64",
	VADD_VC_F64:       "VADD.VC.F64",
	VADD_HI_F64:       "VADD.HI.F64",
	VADD_LS_F64:       "VADD.LS.F64",
	VADD_GE_F64:       "VADD.GE.F64",
	VADD_LT_F64:       "VADD.LT.F64",
	VADD_GT_F64:       "VADD.GT.F64",
	VADD_LE_F64:       "VADD.LE.F64",
	VADD_F64:          "VADD.F64",
	VADD_ZZ_F64:       "VADD.ZZ.F64",
	VCMP_EQ_F32:       "VCMP.EQ.F32",
	VCMP_NE_F32:       "VCMP.NE.F32",
	VCMP_CS_F32:       "VCMP.CS.F32",
	VCMP_CC_F32:       "VCMP.CC.F32",
	VCMP_MI_F32:       "VCMP.MI.F32",
	VCMP_PL_F32:       "VCMP.PL.F32",
	VCMP_VS_F32:       "VCMP.VS.F32",
	VCMP_VC_F32:       "VCMP.VC.F32",
	VCMP_HI_F32:       "VCMP.HI.F32",
	VCMP_LS_F32:       "VCMP.LS.F32",
	VCMP_GE_F32:       "VCMP.GE.F32",
	VCMP_LT_F32:       "VCMP.LT.F32",
	VCMP_GT_F32:       "VCMP.GT.F32",
	VCMP_LE_F32:       "VCMP.LE.F32",
	VCMP_F32:          "VCMP.F32",
	VCMP_ZZ_F32:       "VCMP.ZZ.F32",
	VCMP_EQ_F64:       "VCMP.EQ.F64",
	VCMP_NE_F64:       "VCMP.NE.F64",
	VCMP_CS_F64:       "VCMP.CS.F64",
	VCMP_CC_F64:       "VCMP.CC.F64",
	VCMP_MI_F64:       "VCMP.MI.F64",
	VCMP_PL_F64:       "VCMP.PL.F64",
	VCMP_VS_F64:       "VCMP.VS.F64",
	VCMP_VC_F64:       "VCMP.VC.F64",
	VCMP_HI_F64:       "VCMP.HI.F64",
	VCMP_LS_F64:       "VCMP.LS.F64",
	VCMP_GE_F64:       "VCMP.GE.F64",
	VCMP_LT_F64:       "VCMP.LT.F64",
	VCMP_GT_F64:       "VCMP.GT.F64",
	VCMP_LE_F64:       "VCMP.LE.F64",
	VCMP_F64:          "VCMP.F64",
	VCMP_ZZ_F64:       "VCMP.ZZ.F64",
	VCMP_E_EQ_F32:     "VCMP.E.EQ.F32",
	VCMP_E_NE_F32:     "VCMP.E.NE.F32",
	VCMP_E_CS_F32:     "VCMP.E.CS.F32",
	VCMP_E_CC_F32:     "VCMP.E.CC.F32",
	VCMP_E_MI_F32:     "VCMP.E.MI.F32",
	VCMP_E_PL_F32:     "VCMP.E.PL.F32",
	VCMP_E_VS_F32:     "VCMP.E.VS.F32",
	VCMP_E_VC_F32:     "VCMP.E.VC.F32",
	VCMP_E_HI_F32:     "VCMP.E.HI.F32",
	VCMP_E_LS_F32:     "VCMP.E.LS.F32",
	VCMP_E_GE_F32:     "VCMP.E.GE.F32",
	VCMP_E_LT_F32:     "VCMP.E.LT.F32",
	VCMP_E_GT_F32:     "VCMP.E.GT.F32",
	VCMP_E_LE_F32:     "VCMP.E.LE.F32",
	VCMP_E_F32:        "VCMP.E.F32",
	VCMP_E_ZZ_F32:     "VCMP.E.ZZ.F32",
	VCMP_E_EQ_F64:     "VCMP.E.EQ.F64",
	VCMP_E_NE_F64:     "VCMP.E.NE.F64",
	VCMP_E_CS_F64:     "VCMP.E.CS.F64",
	VCMP_E_CC_F64:     "VCMP.E.CC.F64",
	VCMP_E_MI_F64:     "VCMP.E.MI.F64",
	VCMP_E_PL_F64:     "VCMP.E.PL.F64",
	VCMP_E_VS_F64:     "VCMP.E.VS.F64",
	VCMP_E_VC_F64:     "VCMP.E.VC.F64",
	VCMP_E_HI_F64:     "VCMP.E.HI.F64",
	VCMP_E_LS_F64:     "VCMP.E.LS.F64",
	VCMP_E_GE_F64:     "VCMP.E.GE.F64",
	VCMP_E_LT_F64:     "VCMP.E.LT.F64",
	VCMP_E_GT_F64:     "VCMP.E.GT.F64",
	VCMP_E_LE_F64:     "VCMP.E.LE.F64",
	VCMP_E_F64:        "VCMP.E.F64",
	VCMP_E_ZZ_F64:     "VCMP.E.ZZ.F64",
	VCVT_EQ_F32_FXS16: "VCVT.EQ.F32.FXS16",
	VCVT_NE_F32_FXS16: "VCVT.NE.F32.FXS16",
	VCVT_CS_F32_FXS16: "VCVT.CS.F32.FXS16",
	VCVT_CC_F32_FXS16: "VCVT.CC.F32.FXS16",
	VCVT_MI_F32_FXS16: "VCVT.MI.F32.FXS16",
	VCVT_PL_F32_FXS16: "VCVT.PL.F32.FXS16",
	VCVT_VS_F32_FXS16: "VCVT.VS.F32.FXS16",
	VCVT_VC_F32_FXS16: "VCVT.VC.F32.FXS16",
	VCVT_HI_F32_FXS16: "VCVT.HI.F32.FXS16",
	VCVT_LS_F32_FXS16: "VCVT.LS.F32.FXS16",
	VCVT_GE_F32_FXS16: "VCVT.GE.F32.FXS16",
	VCVT_LT_F32_FXS16: "VCVT.LT.F32.FXS16",
	VCVT_GT_F32_FXS16: "VCVT.GT.F32.FXS16",
	VCVT_LE_F32_FXS16: "VCVT.LE.F32.FXS16",
	VCVT_F32_FXS16:    "VCVT.F32.FXS16",
	VCVT_ZZ_F32_FXS16: "VCVT.ZZ.F32.FXS16",
	VCVT_EQ_F32_FXS32: "VCVT.EQ.F32.FXS32",
	VCVT_NE_F32_FXS32: "VCVT.NE.F32.FXS32",
	VCVT_CS_F32_FXS32: "VCVT.CS.F32.FXS32",
	VCVT_CC_F32_FXS32: "VCVT.CC.F32.FXS32",
	VCVT_MI_F32_FXS32: "VCVT.MI.F32.FXS32",
	VCVT_PL_F32_FXS32: "VCVT.PL.F32.FXS32",
	VCVT_VS_F32_FXS32: "VCVT.VS.F32.FXS32",
	VCVT_VC_F32_FXS32: "VCVT.VC.F32.FXS32",
	VCVT_HI_F32_FXS32: "VCVT.HI.F32.FXS32",
	VCVT_LS_F32_FXS32: "VCVT.LS.F32.FXS32",
	VCVT_GE_F32_FXS32: "VCVT.GE.F32.FXS32",
	VCVT_LT_F32_FXS32: "VCVT.LT.F32.FXS32",
	VCVT_GT_F32_FXS32: "VCVT.GT.F32.FXS32",
	VCVT_LE_F32_FXS32: "VCVT.LE.F32.FXS32",
	VCVT_F32_FXS32:    "VCVT.F32.FXS32",
	VCVT_ZZ_F32_FXS32: "VCVT.ZZ.F32.FXS32",
	VCVT_EQ_F32_FXU16: "VCVT.EQ.F32.FXU16",
	VCVT_NE_F32_FXU16: "VCVT.NE.F32.FXU16",
	VCVT_CS_F32_FXU16: "VCVT.CS.F32.FXU16",
	VCVT_CC_F32_FXU16: "VCVT.CC.F32.FXU16",
	VCVT_MI_F32_FXU16: "VCVT.MI.F32.FXU16",
	VCVT_PL_F32_FXU16: "VCVT.PL.F32.FXU16",
	VCVT_VS_F32_FXU16: "VCVT.VS.F32.FXU16",
	VCVT_VC_F32_FXU16: "VCVT.VC.F32.FXU16",
	VCVT_HI_F32_FXU16: "VCVT.HI.F32.FXU16",
	VCVT_LS_F32_FXU16: "VCVT.LS.F32.FXU16",
	VCVT_GE_F32_FXU16: "VCVT.GE.F32.FXU16",
	VCVT_LT_F32_FXU16: "VCVT.LT.F32.FXU16",
	VCVT_GT_F32_FXU16: "VCVT.GT.F32.FXU16",
	VCVT_LE_F32_FXU16: "VCVT.LE.F32.FXU16",
	VCVT_F32_FXU16:    "VCVT.F32.FXU16",
	VCVT_ZZ_F32_FXU16: "VCVT.ZZ.F32.FXU16",
	VCVT_EQ_F32_FXU32: "VCVT.EQ.F32.FXU32",
	VCVT_NE_F32_FXU32: "VCVT.NE.F32.FXU32",
	VCVT_CS_F32_FXU32: "VCVT.CS.F32.FXU32",
	VCVT_CC_F32_FXU32: "VCVT.CC.F32.FXU32",
	VCVT_MI_F32_FXU32: "VCVT.MI.F32.FXU32",
	VCVT_PL_F32_FXU32: "VCVT.PL.F32.FXU32",
	VCVT_VS_F32_FXU32: "VCVT.VS.F32.FXU32",
	VCVT_VC_F32_FXU32: "VCVT.VC.F32.FXU32",
	VCVT_HI_F32_FXU32: "VCVT.HI.F32.FXU32",
	VCVT_LS_F32_FXU32: "VCVT.LS.F32.FXU32",
	VCVT_GE_F32_FXU32: "VCVT.GE.F32.FXU32",
	VCVT_LT_F32_FXU32: "VCVT.LT.F32.FXU32",
	VCVT_GT_F32_FXU32: "VCVT.GT.F32.FXU32",
	VCVT_LE_F32_FXU32: "VCVT.LE.F32.FXU32",
	VCVT_F32_FXU32:    "VCVT.F32.FXU32",
	VCVT_ZZ_F32_FXU32: "VCVT.ZZ.F32.FXU32",
	VCVT_EQ_F64_FXS16: "VCVT.EQ.F64.FXS16",
	VCVT_NE_F64_FXS16: "VCVT.NE.F64.FXS16",
	VCVT_CS_F64_FXS16: "VCVT.CS.F64.FXS16",
	VCVT_CC_F64_FXS16: "VCVT.CC.F64.FXS16",
	VCVT_MI_F64_FXS16: "VCVT.MI.F64.FXS16",
	VCVT_PL_F64_FXS16: "VCVT.PL.F64.FXS16",
	VCVT_VS_F64_FXS16: "VCVT.VS.F64.FXS16",
	VCVT_VC_F64_FXS16: "VCVT.VC.F64.FXS16",
	VCVT_HI_F64_FXS16: "VCVT.HI.F64.FXS16",
	VCVT_LS_F64_FXS16: "VCVT.LS.F64.FXS16",
	VCVT_GE_F64_FXS16: "VCVT.GE.F64.FXS16",
	VCVT_LT_F64_FXS16: "VCVT.LT.F64.FXS16",
	VCVT_GT_F64_FXS16: "VCVT.GT.F64.FXS16",
	VCVT_LE_F64_FXS16: "VCVT.LE.F64.FXS16",
	VCVT_F64_FXS16:    "VCVT.F64.FXS16",
	VCVT_ZZ_F64_FXS16: "VCVT.ZZ.F64.FXS16",
	VCVT_EQ_F64_FXS32: "VCVT.EQ.F64.FXS32",
	VCVT_NE_F64_FXS32: "VCVT.NE.F64.FXS32",
	VCVT_CS_F64_FXS32: "VCVT.CS.F64.FXS32",
	VCVT_CC_F64_FXS32: "VCVT.CC.F64.FXS32",
	VCVT_MI_F64_FXS32: "VCVT.MI.F64.FXS32",
	VCVT_PL_F64_FXS32: "VCVT.PL.F64.FXS32",
	VCVT_VS_F64_FXS32: "VCVT.VS.F64.FXS32",
	VCVT_VC_F64_FXS32: "VCVT.VC.F64.FXS32",
	VCVT_HI_F64_FXS32: "VCVT.HI.F64.FXS32",
	VCVT_LS_F64_FXS32: "VCVT.LS.F64.FXS32",
	VCVT_GE_F64_FXS32: "VCVT.GE.F64.FXS32",
	VCVT_LT_F64_FXS32: "VCVT.LT.F64.FXS32",
	VCVT_GT_F64_FXS32: "VCVT.GT.F64.FXS32",
	VCVT_LE_F64_FXS32: "VCVT.LE.F64.FXS32",
	VCVT_F64_FXS32:    "VCVT.F64.FXS32",
	VCVT_ZZ_F64_FXS32: "VCVT.ZZ.F64.FXS32",
	VCVT_EQ_F64_FXU16: "VCVT.EQ.F64.FXU16",
	VCVT_NE_F64_FXU16: "VCVT.NE.F64.FXU16",
	VCVT_CS_F64_FXU16: "VCVT.CS.F64.FXU16",
	VCVT_CC_F64_FXU16: "VCVT.CC.F64.FXU16",
	VCVT_MI_F64_FXU16: "VCVT.MI.F64.FXU16",
	VCVT_PL_F64_FXU16: "VCVT.PL.F64.FXU16",
	VCVT_VS_F64_FXU16: "VCVT.VS.F64.FXU16",
	VCVT_VC_F64_FXU16: "VCVT.VC.F64.FXU16",
	VCVT_HI_F64_FXU16: "VCVT.HI.F64.FXU16",
	VCVT_LS_F64_FXU16: "VCVT.LS.F64.FXU16",
	VCVT_GE_F64_FXU16: "VCVT.GE.F64.FXU16",
	VCVT_LT_F64_FXU16: "VCVT.LT.F64.FXU16",
	VCVT_GT_F64_FXU16: "VCVT.GT.F64.FXU16",
	VCVT_LE_F64_FXU16: "VCVT.LE.F64.FXU16",
	VCVT_F64_FXU16:    "VCVT.F64.FXU16",
	VCVT_ZZ_F64_FXU16: "VCVT.ZZ.F64.FXU16",
	VCVT_EQ_F64_FXU32: "VCVT.EQ.F64.FXU32",
	VCVT_NE_F64_FXU32: "VCVT.NE.F64.FXU32",
	VCVT_CS_F64_FXU32: "VCVT.CS.F64.FXU32",
	VCVT_CC_F64_FXU32: "VCVT.CC.F64.FXU32",
	VCVT_MI_F64_FXU32: "VCVT.MI.F64.FXU32",
	VCVT_PL_F64_FXU32: "VCVT.PL.F64.FXU32",
	VCVT_VS_F64_FXU32: "VCVT.VS.F64.FXU32",
	VCVT_VC_F64_FXU32: "VCVT.VC.F64.FXU32",
	VCVT_HI_F64_FXU32: "VCVT.HI.F64.FXU32",
	VCVT_LS_F64_FXU32: "VCVT.LS.F64.FXU32",
	VCVT_GE_F64_FXU32: "VCVT.GE.F64.FXU32",
	VCVT_LT_F64_FXU32: "VCVT.LT.F64.FXU32",
	VCVT_GT_F64_FXU32: "VCVT.GT.F64.FXU32",
	VCVT_LE_F64_FXU32: "VCVT.LE.F64.FXU32",
	VCVT_F64_FXU32:    "VCVT.F64.FXU32",
	VCVT_ZZ_F64_FXU32: "VCVT.ZZ.F64.FXU32",
	VCVT_EQ_F32_U32:   "VCVT.EQ.F32.U32",
	VCVT_NE_F32_U32:   "VCVT.NE.F32.U32",
	VCVT_CS_F32_U32:   "VCVT.CS.F32.U32",
	VCVT_CC_F32_U32:   "VCVT.CC.F32.U32",
	VCVT_MI_F32_U32:   "VCVT.MI.F32.U32",
	VCVT_PL_F32_U32:   "VCVT.PL.F32.U32",
	VCVT_VS_F32_U32:   "VCVT.VS.F32.U32",
	VCVT_VC_F32_U32:   "VCVT.VC.F32.U32",
	VCVT_HI_F32_U32:   "VCVT.HI.F32.U32",
	VCVT_LS_F32_U32:   "VCVT.LS.F32.U32",
	VCVT_GE_F32_U32:   "VCVT.GE.F32.U32",
	VCVT_LT_F32_U32:   "VCVT.LT.F32.U32",
	VCVT_GT_F32_U32:   "VCVT.GT.F32.U32",
	VCVT_LE_F32_U32:   "VCVT.LE.F32.U32",
	VCVT_F32_U32:      "VCVT.F32.U32",
	VCVT_ZZ_F32_U32:   "VCVT.ZZ.F32.U32",
	VCVT_EQ_F32_S32:   "VCVT.EQ.F32.S32",
	VCVT_NE_F32_S32:   "VCVT.NE.F32.S32",
	VCVT_CS_F32_S32:   "VCVT.CS.F32.S32",
	VCVT_CC_F32_S32:   "VCVT.CC.F32.S32",
	VCVT_MI_F32_S32:   "VCVT.MI.F32.S32",
	VCVT_PL_F32_S32:   "VCVT.PL.F32.S32",
	VCVT_VS_F32_S32:   "VCVT.VS.F32.S32",
	VCVT_VC_F32_S32:   "VCVT.VC.F32.S32",
	VCVT_HI_F32_S32:   "VCVT.HI.F32.S32",
	VCVT_LS_F32_S32:   "VCVT.LS.F32.S32",
	VCVT_GE_F32_S32:   "VCVT.GE.F32.S32",
	VCVT_LT_F32_S32:   "VCVT.LT.F32.S32",
	VCVT_GT_F32_S32:   "VCVT.GT.F32.S32",
	VCVT_LE_F32_S32:   "VCVT.LE.F32.S32",
	VCVT_F32_S32:      "VCVT.F32.S32",
	VCVT_ZZ_F32_S32:   "VCVT.ZZ.F32.S32",
	VCVT_EQ_F64_U32:   "VCVT.EQ.F64.U32",
	VCVT_NE_F64_U32:   "VCVT.NE.F64.U32",
	VCVT_CS_F64_U32:   "VCVT.CS.F64.U32",
	VCVT_CC_F64_U32:   "VCVT.CC.F64.U32",
	VCVT_MI_F64_U32:   "VCVT.MI.F64.U32",
	VCVT_PL_F64_U32:   "VCVT.PL.F64.U32",
	VCVT_VS_F64_U32:   "VCVT.VS.F64.U32",
	VCVT_VC_F64_U32:   "VCVT.VC.F64.U32",
	VCVT_HI_F64_U32:   "VCVT.HI.F64.U32",
	VCVT_LS_F64_U32:   "VCVT.LS.F64.U32",
	VCVT_GE_F64_U32:   "VCVT.GE.F64.U32",
	VCVT_LT_F64_U32:   "VCVT.LT.F64.U32",
	VCVT_GT_F64_U32:   "VCVT.GT.F64.U32",
	VCVT_LE_F64_U32:   "VCVT.LE.F64.U32",
	VCVT_F64_U32:      "VCVT.F64.U32",
	VCVT_ZZ_F64_U32:   "VCVT.ZZ.F64.U32",
	VCVT_EQ_F64_S32:   "VCVT.EQ.F64.S32",
	VCVT_NE_F64_S32:   "VCVT.NE.F64.S32",
	VCVT_CS_F64_S32:   "VCVT.CS.F64.S32",
	VCVT_CC_F64_S32:   "VCVT.CC.F64.S32",
	VCVT_MI_F64_S32:   "VCVT.MI.F64.S32",
	VCVT_PL_F64_S32:   "VCVT.PL.F64.S32",
	VCVT_VS_F64_S32:   "VCVT.VS.F64.S32",
	VCVT_VC_F64_S32:   "VCVT.VC.F64.S32",
	VCVT_HI_F64_S32:   "VCVT.HI.F64.S32",
	VCVT_LS_F64_S32:   "VCVT.LS.F64.S32",
	VCVT_GE_F64_S32:   "VCVT.GE.F64.S32",
	VCVT_LT_F64_S32:   "VCVT.LT.F64.S32",
	VCVT_GT_F64_S32:   "VCVT.GT.F64.S32",
	VCVT_LE_F64_S32:   "VCVT.LE.F64.S32",
	VCVT_F64_S32:      "VCVT.F64.S32",
	VCVT_ZZ_F64_S32:   "VCVT.ZZ.F64.S32",
	VCVT_EQ_F64_F32:   "VCVT.EQ.F64.F32",
	VCVT_NE_F64_F32:   "VCVT.NE.F64.F32",
	VCVT_CS_F64_F32:   "VCVT.CS.F64.F32",
	VCVT_CC_F64_F32:   "VCVT.CC.F64.F32",
	VCVT_MI_F64_F32:   "VCVT.MI.F64.F32",
	VCVT_PL_F64_F32:   "VCVT.PL.F64.F32",
	VCVT_VS_F64_F32:   "VCVT.VS.F64.F32",
	VCVT_VC_F64_F32:   "VCVT.VC.F64.F32",
	VCVT_HI_F64_F32:   "VCVT.HI.F64.F32",
	VCVT_LS_F64_F32:   "VCVT.LS.F64.F32",
	VCVT_GE_F64_F32:   "VCVT.GE.F64.F32",
	VCVT_LT_F64_F32:   "VCVT.LT.F64.F32",
	VCVT_GT_F64_F32:   "VCVT.GT.F64.F32",
	VCVT_LE_F64_F32:   "VCVT.LE.F64.F32",
	VCVT_F64_F32:      "VCVT.F64.F32",
	VCVT_ZZ_F64_F32:   "VCVT.ZZ.F64.F32",
	VCVT_EQ_F32_F64:   "VCVT.EQ.F32.F64",
	VCVT_NE_F32_F64:   "VCVT.NE.F32.F64",
	VCVT_CS_F32_F64:   "VCVT.CS.F32.F64",
	VCVT_CC_F32_F64:   "VCVT.CC.F32.F64",
	VCVT_MI_F32_F64:   "VCVT.MI.F32.F64",
	VCVT_PL_F32_F64:   "VCVT.PL.F32.F64",
	VCVT_VS_F32_F64:   "VCVT.VS.F32.F64",
	VCVT_VC_F32_F64:   "VCVT.VC.F32.F64",
	VCVT_HI_F32_F64:   "VCVT.HI.F32.F64",
	VCVT_LS_F32_F64:   "VCVT.LS.F32.F64",
	VCVT_GE_F32_F64:   "VCVT.GE.F32.F64",
	VCVT_LT_F32_F64:   "VCVT.LT.F32.F64",
	VCVT_GT_F32_F64:   "VCVT.GT.F32.F64",
	VCVT_LE_F32_F64:   "VCVT.LE.F32.F64",
	VCVT_F32_F64:      "VCVT.F32.F64",
	VCVT_ZZ_F32_F64:   "VCVT.ZZ.F32.F64",
	VCVT_EQ_FXS16_F32: "VCVT.EQ.FXS16.F32",
	VCVT_NE_FXS16_F32: "VCVT.NE.FXS16.F32",
	VCVT_CS_FXS16_F32: "VCVT.CS.FXS16.F32",
	VCVT_CC_FXS16_F32: "VCVT.CC.FXS16.F32",
	VCVT_MI_FXS16_F32: "VCVT.MI.FXS16.F32",
	VCVT_PL_FXS16_F32: "VCVT.PL.FXS16.F32",
	VCVT_VS_FXS16_F32: "VCVT.VS.FXS16.F32",
	VCVT_VC_FXS16_F32: "VCVT.VC.FXS16.F32",
	VCVT_HI_FXS16_F32: "VCVT.HI.FXS16.F32",
	VCVT_LS_FXS16_F32: "VCVT.LS.FXS16.F32",
	VCVT_GE_FXS16_F32: "VCVT.GE.FXS16.F32",
	VCVT_LT_FXS16_F32: "VCVT.LT.FXS16.F32",
	VCVT_GT_FXS16_F32: "VCVT.GT.FXS16.F32",
	VCVT_LE_FXS16_F32: "VCVT.LE.FXS16.F32",
	VCVT_FXS16_F32:    "VCVT.FXS16.F32",
	VCVT_ZZ_FXS16_F32: "VCVT.ZZ.FXS16.F32",
	VCVT_EQ_FXS16_F64: "VCVT.EQ.FXS16.F64",
	VCVT_NE_FXS16_F64: "VCVT.NE.FXS16.F64",
	VCVT_CS_FXS16_F64: "VCVT.CS.FXS16.F64",
	VCVT_CC_FXS16_F64: "VCVT.CC.FXS16.F64",
	VCVT_MI_FXS16_F64: "VCVT.MI.FXS16.F64",
	VCVT_PL_FXS16_F64: "VCVT.PL.FXS16.F64",
	VCVT_VS_FXS16_F64: "VCVT.VS.FXS16.F64",
	VCVT_VC_FXS16_F64: "VCVT.VC.FXS16.F64",
	VCVT_HI_FXS16_F64: "VCVT.HI.FXS16.F64",
	VCVT_LS_FXS16_F64: "VCVT.LS.FXS16.F64",
	VCVT_GE_FXS16_F64: "VCVT.GE.FXS16.F64",
	VCVT_LT_FXS16_F64: "VCVT.LT.FXS16.F64",
	VCVT_GT_FXS16_F64: "VCVT.GT.FXS16.F64",
	VCVT_LE_FXS16_F64: "VCVT.LE.FXS16.F64",
	VCVT_FXS16_F64:    "VCVT.FXS16.F64",
	VCVT_ZZ_FXS16_F64: "VCVT.ZZ.FXS16.F64",
	VCVT_EQ_FXS32_F32: "VCVT.EQ.FXS32.F32",
	VCVT_NE_FXS32_F32: "VCVT.NE.FXS32.F32",
	VCVT_CS_FXS32_F32: "VCVT.CS.FXS32.F32",
	VCVT_CC_FXS32_F32: "VCVT.CC.FXS32.F32",
	VCVT_MI_FXS32_F32: "VCVT.MI.FXS32.F32",
	VCVT_PL_FXS32_F32: "VCVT.PL.FXS32.F32",
	VCVT_VS_FXS32_F32: "VCVT.VS.FXS32.F32",
	VCVT_VC_FXS32_F32: "VCVT.VC.FXS32.F32",
	VCVT_HI_FXS32_F32: "VCVT.HI.FXS32.F32",
	VCVT_LS_FXS32_F32: "VCVT.LS.FXS32.F32",
	VCVT_GE_FXS32_F32: "VCVT.GE.FXS32.F32",
	VCVT_LT_FXS32_F32: "VCVT.LT.FXS32.F32",
	VCVT_GT_FXS32_F32: "VCVT.GT.FXS32.F32",
	VCVT_LE_FXS32_F32: "VCVT.LE.FXS32.F32",
	VCVT_FXS32_F32:    "VCVT.FXS32.F32",
	VCVT_ZZ_FXS32_F32: "VCVT.ZZ.FXS32.F32",
	VCVT_EQ_FXS32_F64: "VCVT.EQ.FXS32.F64",
	VCVT_NE_FXS32_F64: "VCVT.NE.FXS32.F64",
	VCVT_CS_FXS32_F64: "VCVT.CS.FXS32.F64",
	VCVT_CC_FXS32_F64: "VCVT.CC.FXS32.F64",
	VCVT_MI_FXS32_F64: "VCVT.MI.FXS32.F64",
	VCVT_PL_FXS32_F64: "VCVT.PL.FXS32.F64",
	VCVT_VS_FXS32_F64: "VCVT.VS.FXS32.F64",
	VCVT_VC_FXS32_F64: "VCVT.VC.FXS32.F64",
	VCVT_HI_FXS32_F64: "VCVT.HI.FXS32.F64",
	VCVT_LS_FXS32_F64: "VCVT.LS.FXS32.F64",
	VCVT_GE_FXS32_F64: "VCVT.GE.FXS32.F64",
	VCVT_LT_FXS32_F64: "VCVT.LT.FXS32.F64",
	VCVT_GT_FXS32_F64: "VCVT.GT.FXS32.F64",
	VCVT_LE_FXS32_F64: "VCVT.LE.FXS32.F64",
	VCVT_FXS32_F64:    "VCVT.FXS32.F64",
	VCVT_ZZ_FXS32_F64: "VCVT.ZZ.FXS32.F64",
	VCVT_EQ_FXU16_F32: "VCVT.EQ.FXU16.F32",
	VCVT_NE_FXU16_F32: "VCVT.NE.FXU16.F32",
	VCVT_CS_FXU16_F32: "VCVT.CS.FXU16.F32",
	VCVT_CC_FXU16_F32: "VCVT.CC.FXU16.F32",
	VCVT_MI_FXU16_F32: "VCVT.MI.FXU16.F32",
	VCVT_PL_FXU16_F32: "VCVT.PL.FXU16.F32",
	VCVT_VS_FXU16_F32: "VCVT.VS.FXU16.F32",
	VCVT_VC_FXU16_F32: "VCVT.VC.FXU16.F32",
	VCVT_HI_FXU16_F32: "VCVT.HI.FXU16.F32",
	VCVT_LS_FXU16_F32: "VCVT.LS.FXU16.F32",
	VCVT_GE_FXU16_F32: "VCVT.GE.FXU16.F32",
	VCVT_LT_FXU16_F32: "VCVT.LT.FXU16.F32",
	VCVT_GT_FXU16_F32: "VCVT.GT.FXU16.F32",
	VCVT_LE_FXU16_F32: "VCVT.LE.FXU16.F32",
	VCVT_FXU16_F32:    "VCVT.FXU16.F32",
	VCVT_ZZ_FXU16_F32: "VCVT.ZZ.FXU16.F32",
	VCVT_EQ_FXU16_F64: "VCVT.EQ.FXU16.F64",
	VCVT_NE_FXU16_F64: "VCVT.NE.FXU16.F64",
	VCVT_CS_FXU16_F64: "VCVT.CS.FXU16.F64",
	VCVT_CC_FXU16_F64: "VCVT.CC.FXU16.F64",
	VCVT_MI_FXU16_F64: "VCVT.MI.FXU16.F64",
	VCVT_PL_FXU16_F64: "VCVT.PL.FXU16.F64",
	VCVT_VS_FXU16_F64: "VCVT.VS.FXU16.F64",
	VCVT_VC_FXU16_F64: "VCVT.VC.FXU16.F64",
	VCVT_HI_FXU16_F64: "VCVT.HI.FXU16.F64",
	VCVT_LS_FXU16_F64: "VCVT.LS.FXU16.F64",
	VCVT_GE_FXU16_F64: "VCVT.GE.FXU16.F64",
	VCVT_LT_FXU16_F64: "VCVT.LT.FXU16.F64",
	VCVT_GT_FXU16_F64: "VCVT.GT.FXU16.F64",
	VCVT_LE_FXU16_F64: "VCVT.LE.FXU16.F64",
	VCVT_FXU16_F64:    "VCVT.FXU16.F64",
	VCVT_ZZ_FXU16_F64: "VCVT.ZZ.FXU16.F64",
	VCVT_EQ_FXU32_F32: "VCVT.EQ.FXU32.F32",
	VCVT_NE_FXU32_F32: "VCVT.NE.FXU32.F32",
	VCVT_CS_FXU32_F32: "VCVT.CS.FXU32.F32",
	VCVT_CC_FXU32_F32: "VCVT.CC.FXU32.F32",
	VCVT_MI_FXU32_F32: "VCVT.MI.FXU32.F32",
	VCVT_PL_FXU32_F32: "VCVT.PL.FXU32.F32",
	VCVT_VS_FXU32_F32: "VCVT.VS.FXU32.F32",
	VCVT_VC_FXU32_F32: "VCVT.VC.FXU32.F32",
	VCVT_HI_FXU32_F32: "VCVT.HI.FXU32.F32",
	VCVT_LS_FXU32_F32: "VCVT.LS.FXU32.F32",
	VCVT_GE_FXU32_F32: "VCVT.GE.FXU32.F32",
	VCVT_LT_FXU32_F32: "VCVT.LT.FXU32.F32",
	VCVT_GT_FXU32_F32: "VCVT.GT.FXU32.F32",
	VCVT_LE_FXU32_F32: "VCVT.LE.FXU32.F32",
	VCVT_FXU32_F32:    "VCVT.FXU32.F32",
	VCVT_ZZ_FXU32_F32: "VCVT.ZZ.FXU32.F32",
	VCVT_EQ_FXU32_F64: "VCVT.EQ.FXU32.F64",
	VCVT_NE_FXU32_F64: "VCVT.NE.FXU32.F64",
	VCVT_CS_FXU32_F64: "VCVT.CS.FXU32.F64",
	VCVT_CC_FXU32_F64: "VCVT.CC.FXU32.F64",
	VCVT_MI_FXU32_F64: "VCVT.MI.FXU32.F64",
	VCVT_PL_FXU32_F64: "VCVT.PL.FXU32.F64",
	VCVT_VS_FXU32_F64: "VCVT.VS.FXU32.F64",
	VCVT_VC_FXU32_F64: "VCVT.VC.FXU32.F64",
	VCVT_HI_FXU32_F64: "VCVT.HI.FXU32.F64",
	VCVT_LS_FXU32_F64: "VCVT.LS.FXU32.F64",
	VCVT_GE_FXU32_F64: "VCVT.GE.FXU32.F64",
	VCVT_LT_FXU32_F64: "VCVT.LT.FXU32.F64",
	VCVT_GT_FXU32_F64: "VCVT.GT.FXU32.F64",
	VCVT_LE_FXU32_F64: "VCVT.LE.FXU32.F64",
	VCVT_FXU32_F64:    "VCVT.FXU32.F64",
	VCVT_ZZ_FXU32_F64: "VCVT.ZZ.FXU32.F64",
	VCVTB_EQ_F32_F16:  "VCVTB.EQ.F32.F16",
	VCVTB_NE_F32_F16:  "VCVTB.NE.F32.F16",
	VCVTB_CS_F32_F16:  "VCVTB.CS.F32.F16",
	VCVTB_CC_F32_F16:  "VCVTB.CC.F32.F16",
	VCVTB_MI_F32_F16:  "VCVTB.MI.F32.F16",
	VCVTB_PL_F32_F16:  "VCVTB.PL.F32.F16",
	VCVTB_VS_F32_F16:  "VCVTB.VS.F32.F16",
	VCVTB_VC_F32_F16:  "VCVTB.VC.F32.F16",
	VCVTB_HI_F32_F16:  "VCVTB.HI.F32.F16",
	VCVTB_LS_F32_F16:  "VCVTB.LS.F32.F16",
	VCVTB_GE_F32_F16:  "VCVTB.GE.F32.F16",
	VCVTB_LT_F32_F16:  "VCVTB.LT.F32.F16",
	VCVTB_GT_F32_F16:  "VCVTB.GT.F32.F16",
	VCVTB_LE_F32_F16:  "VCVTB.LE.F32.F16",
	VCVTB_F32_F16:     "VCVTB.F32.F16",
	VCVTB_ZZ_F32_F16:  "VCVTB.ZZ.F32.F16",
	VCVTB_EQ_F16_F32:  "VCVTB.EQ.F16.F32",
	VCVTB_NE_F16_F32:  "VCVTB.NE.F16.F32",
	VCVTB_CS_F16_F32:  "VCVTB.CS.F16.F32",
	VCVTB_CC_F16_F32:  "VCVTB.CC.F16.F32",
	VCVTB_MI_F16_F32:  "VCVTB.MI.F16.F32",
	VCVTB_PL_F16_F32:  "VCVTB.PL.F16.F32",
	VCVTB_VS_F16_F32:  "VCVTB.VS.F16.F32",
	VCVTB_VC_F16_F32:  "VCVTB.VC.F16.F32",
	VCVTB_HI_F16_F32:  "VCVTB.HI.F16.F32",
	VCVTB_LS_F16_F32:  "VCVTB.LS.F16.F32",
	VCVTB_GE_F16_F32:  "VCVTB.GE.F16.F32",
	VCVTB_LT_F16_F32:  "VCVTB.LT.F16.F32",
	VCVTB_GT_F16_F32:  "VCVTB.GT.F16.F32",
	VCVTB_LE_F16_F32:  "VCVTB.LE.F16.F32",
	VCVTB_F16_F32:     "VCVTB.F16.F32",
	VCVTB_ZZ_F16_F32:  "VCVTB.ZZ.F16.F32",
	VCVTT_EQ_F32_F16:  "VCVTT.EQ.F32.F16",
	VCVTT_NE_F32_F16:  "VCVTT.NE.F32.F16",
	VCVTT_CS_F32_F16:  "VCVTT.CS.F32.F16",
	VCVTT_CC_F32_F16:  "VCVTT.CC.F32.F16",
	VCVTT_MI_F32_F16:  "VCVTT.MI.F32.F16",
	VCVTT_PL_F32_F16:  "VCVTT.PL.F32.F16",
	VCVTT_VS_F32_F16:  "VCVTT.VS.F32.F16",
	VCVTT_VC_F32_F16:  "VCVTT.VC.F32.F16",
	VCVTT_HI_F32_F16:  "VCVTT.HI.F32.F16",
	VCVTT_LS_F32_F16:  "VCVTT.LS.F32.F16",
	VCVTT_GE_F32_F16:  "VCVTT.GE.F32.F16",
	VCVTT_LT_F32_F16:  "VCVTT.LT.F32.F16",
	VCVTT_GT_F32_F16:  "VCVTT.GT.F32.F16",
	VCVTT_LE_F32_F16:  "VCVTT.LE.F32.F16",
	VCVTT_F32_F16:     "VCVTT.F32.F16",
	VCVTT_ZZ_F32_F16:  "VCVTT.ZZ.F32.F16",
	VCVTT_EQ_F16_F32:  "VCVTT.EQ.F16.F32",
	VCVTT_NE_F16_F32:  "VCVTT.NE.F16.F32",
	VCVTT_CS_F16_F32:  "VCVTT.CS.F16.F32",
	VCVTT_CC_F16_F32:  "VCVTT.CC.F16.F32",
	VCVTT_MI_F16_F32:  "VCVTT.MI.F16.F32",
	VCVTT_PL_F16_F32:  "VCVTT.PL.F16.F32",
	VCVTT_VS_F16_F32:  "VCVTT.VS.F16.F32",
	VCVTT_VC_F16_F32:  "VCVTT.VC.F16.F32",
	VCVTT_HI_F16_F32:  "VCVTT.HI.F16.F32",
	VCVTT_LS_F16_F32:  "VCVTT.LS.F16.F32",
	VCVTT_GE_F16_F32:  "VCVTT.GE.F16.F32",
	VCVTT_LT_F16_F32:  "VCVTT.LT.F16.F32",
	VCVTT_GT_F16_F32:  "VCVTT.GT.F16.F32",
	VCVTT_LE_F16_F32:  "VCVTT.LE.F16.F32",
	VCVTT_F16_F32:     "VCVTT.F16.F32",
	VCVTT_ZZ_F16_F32:  "VCVTT.ZZ.F16.F32",
	VCVTR_EQ_U32_F32:  "VCVTR.EQ.U32.F32",
	VCVTR_NE_U32_F32:  "VCVTR.NE.U32.F32",
	VCVTR_CS_U32_F32:  "VCVTR.CS.U32.F32",
	VCVTR_CC_U32_F32:  "VCVTR.CC.U32.F32",
	VCVTR_MI_U32_F32:  "VCVTR.MI.U32.F32",
	VCVTR_PL_U32_F32:  "VCVTR.PL.U32.F32",
	VCVTR_VS_U32_F32:  "VCVTR.VS.U32.F32",
	VCVTR_VC_U32_F32:  "VCVTR.VC.U32.F32",
	VCVTR_HI_U32_F32:  "VCVTR.HI.U32.F32",
	VCVTR_LS_U32_F32:  "VCVTR.LS.U32.F32",
	VCVTR_GE_U32_F32:  "VCVTR.GE.U32.F32",
	VCVTR_LT_U32_F32:  "VCVTR.LT.U32.F32",
	VCVTR_GT_U32_F32:  "VCVTR.GT.U32.F32",
	VCVTR_LE_U32_F32:  "VCVTR.LE.U32.F32",
	VCVTR_U32_F32:     "VCVTR.U32.F32",
	VCVTR_ZZ_U32_F32:  "VCVTR.ZZ.U32.F32",
	VCVTR_EQ_U32_F64:  "VCVTR.EQ.U32.F64",
	VCVTR_NE_U32_F64:  "VCVTR.NE.U32.F64",
	VCVTR_CS_U32_F64:  "VCVTR.CS.U32.F64",
	VCVTR_CC_U32_F64:  "VCVTR.CC.U32.F64",
	VCVTR_MI_U32_F64:  "VCVTR.MI.U32.F64",
	VCVTR_PL_U32_F64:  "VCVTR.PL.U32.F64",
	VCVTR_VS_U32_F64:  "VCVTR.VS.U32.F64",
	VCVTR_VC_U32_F64:  "VCVTR.VC.U32.F64",
	VCVTR_HI_U32_F64:  "VCVTR.HI.U32.F64",
	VCVTR_LS_U32_F64:  "VCVTR.LS.U32.F64",
	VCVTR_GE_U32_F64:  "VCVTR.GE.U32.F64",
	VCVTR_LT_U32_F64:  "VCVTR.LT.U32.F64",
	VCVTR_GT_U32_F64:  "VCVTR.GT.U32.F64",
	VCVTR_LE_U32_F64:  "VCVTR.LE.U32.F64",
	VCVTR_U32_F64:     "VCVTR.U32.F64",
	VCVTR_ZZ_U32_F64:  "VCVTR.ZZ.U32.F64",
	VCVTR_EQ_S32_F32:  "VCVTR.EQ.S32.F32",
	VCVTR_NE_S32_F32:  "VCVTR.NE.S32.F32",
	VCVTR_CS_S32_F32:  "VCVTR.CS.S32.F32",
	VCVTR_CC_S32_F32:  "VCVTR.CC.S32.F32",
	VCVTR_MI_S32_F32:  "VCVTR.MI.S32.F32",
	VCVTR_PL_S32_F32:  "VCVTR.PL.S32.F32",
	VCVTR_VS_S32_F32:  "VCVTR.VS.S32.F32",
	VCVTR_VC_S32_F32:  "VCVTR.VC.S32.F32",
	VCVTR_HI_S32_F32:  "VCVTR.HI.S32.F32",
	VCVTR_LS_S32_F32:  "VCVTR.LS.S32.F32",
	VCVTR_GE_S32_F32:  "VCVTR.GE.S32.F32",
	VCVTR_LT_S32_F32:  "VCVTR.LT.S32.F32",
	VCVTR_GT_S32_F32:  "VCVTR.GT.S32.F32",
	VCVTR_LE_S32_F32:  "VCVTR.LE.S32.F32",
	VCVTR_S32_F32:     "VCVTR.S32.F32",
	VCVTR_ZZ_S32_F32:  "VCVTR.ZZ.S32.F32",
	VCVTR_EQ_S32_F64:  "VCVTR.EQ.S32.F64",
	VCVTR_NE_S32_F64:  "VCVTR.NE.S32.F64",
	VCVTR_CS_S32_F64:  "VCVTR.CS.S32.F64",
	VCVTR_CC_S32_F64:  "VCVTR.CC.S32.F64",
	VCVTR_MI_S32_F64:  "VCVTR.MI.S32.F64",
	VCVTR_PL_S32_F64:  "VCVTR.PL.S32.F64",
	VCVTR_VS_S32_F64:  "VCVTR.VS.S32.F64",
	VCVTR_VC_S32_F64:  "VCVTR.VC.S32.F64",
	VCVTR_HI_S32_F64:  "VCVTR.HI.S32.F64",
	VCVTR_LS_S32_F64:  "VCVTR.LS.S32.F64",
	VCVTR_GE_S32_F64:  "VCVTR.GE.S32.F64",
	VCVTR_LT_S32_F64:  "VCVTR.LT.S32.F64",
	VCVTR_GT_S32_F64:  "VCVTR.GT.S32.F64",
	VCVTR_LE_S32_F64:  "VCVTR.LE.S32.F64",
	VCVTR_S32_F64:     "VCVTR.S32.F64",
	VCVTR_ZZ_S32_F64:  "VCVTR.ZZ.S32.F64",
	VCVT_EQ_U32_F32:   "VCVT.EQ.U32.F32",
	VCVT_NE_U32_F32:   "VCVT.NE.U32.F32",
	VCVT_CS_U32_F32:   "VCVT.CS.U32.F32",
	VCVT_CC_U32_F32:   "VCVT.CC.U32.F32",
	VCVT_MI_U32_F32:   "VCVT.MI.U32.F32",
	VCVT_PL_U32_F32:   "VCVT.PL.U32.F32",
	VCVT_VS_U32_F32:   "VCVT.VS.U32.F32",
	VCVT_VC_U32_F32:   "VCVT.VC.U32.F32",
	VCVT_HI_U32_F32:   "VCVT.HI.U32.F32",
	VCVT_LS_U32_F32:   "VCVT.LS.U32.F32",
	VCVT_GE_U32_F32:   "VCVT.GE.U32.F32",
	VCVT_LT_U32_F32:   "VCVT.LT.U32.F32",
	VCVT_GT_U32_F32:   "VCVT.GT.U32.F32",
	VCVT_LE_U32_F32:   "VCVT.LE.U32.F32",
	VCVT_U32_F32:      "VCVT.U32.F32",
	VCVT_ZZ_U32_F32:   "VCVT.ZZ.U32.F32",
	VCVT_EQ_U32_F64:   "VCVT.EQ.U32.F64",
	VCVT_NE_U32_F64:   "VCVT.NE.U32.F64",
	VCVT_CS_U32_F64:   "VCVT.CS.U32.F64",
	VCVT_CC_U32_F64:   "VCVT.CC.U32.F64",
	VCVT_MI_U32_F64:   "VCVT.MI.U32.F64",
	VCVT_PL_U32_F64:   "VCVT.PL.U32.F64",
	VCVT_VS_U32_F64:   "VCVT.VS.U32.F64",
	VCVT_VC_U32_F64:   "VCVT.VC.U32.F64",
	VCVT_HI_U32_F64:   "VCVT.HI.U32.F64",
	VCVT_LS_U32_F64:   "VCVT.LS.U32.F64",
	VCVT_GE_U32_F64:   "VCVT.GE.U32.F64",
	VCVT_LT_U32_F64:   "VCVT.LT.U32.F64",
	VCVT_GT_U32_F64:   "VCVT.GT.U32.F64",
	VCVT_LE_U32_F64:   "VCVT.LE.U32.F64",
	VCVT_U32_F64:      "VCVT.U32.F64",
	VCVT_ZZ_U32_F64:   "VCVT.ZZ.U32.F64",
	VCVT_EQ_S32_F32:   "VCVT.EQ.S32.F32",
	VCVT_NE_S32_F32:   "VCVT.NE.S32.F32",
	VCVT_CS_S32_F32:   "VCVT.CS.S32.F32",
	VCVT_CC_S32_F32:   "VCVT.CC.S32.F32",
	VCVT_MI_S32_F32:   "VCVT.MI.S32.F32",
	VCVT_PL_S32_F32:   "VCVT.PL.S32.F32",
	VCVT_VS_S32_F32:   "VCVT.VS.S32.F32",
	VCVT_VC_S32_F32:   "VCVT.VC.S32.F32",
	VCVT_HI_S32_F32:   "VCVT.HI.S32.F32",
	VCVT_LS_S32_F32:   "VCVT.LS.S32.F32",
	VCVT_GE_S32_F32:   "VCVT.GE.S32.F32",
	VCVT_LT_S32_F32:   "VCVT.LT.S32.F32",
	VCVT_GT_S32_F32:   "VCVT.GT.S32.F32",
	VCVT_LE_S32_F32:   "VCVT.LE.S32.F32",
	VCVT_S32_F32:      "VCVT.S32.F32",
	VCVT_ZZ_S32_F32:   "VCVT.ZZ.S32.F32",
	VCVT_EQ_S32_F64:   "VCVT.EQ.S32.F64",
	VCVT_NE_S32_F64:   "VCVT.NE.S32.F64",
	VCVT_CS_S32_F64:   "VCVT.CS.S32.F64",
	VCVT_CC_S32_F64:   "VCVT.CC.S32.F64",
	VCVT_MI_S32_F64:   "VCVT.MI.S32.F64",
	VCVT_PL_S32_F64:   "VCVT.PL.S32.F64",
	VCVT_VS_S32_F64:   "VCVT.VS.S32.F64",
	VCVT_VC_S32_F64:   "VCVT.VC.S32.F64",
	VCVT_HI_S32_F64:   "VCVT.HI.S32.F64",
	VCVT_LS_S32_F64:   "VCVT.LS.S32.F64",
	VCVT_GE_S32_F64:   "VCVT.GE.S32.F64",
	VCVT_LT_S32_F64:   "VCVT.LT.S32.F64",
	VCVT_GT_S32_F64:   "VCVT.GT.S32.F64",
	VCVT_LE_S32_F64:   "VCVT.LE.S32.F64",
	VCVT_S32_F64:      "VCVT.S32.F64",
	VCVT_ZZ_S32_F64:   "VCVT.ZZ.S32.F64",
	VDIV_EQ_F32:       "VDIV.EQ.F32",
	VDIV_NE_F32:       "VDIV.NE.F32",
	VDIV_CS_F32:       "VDIV.CS.F32",
	VDIV_CC_F32:       "VDIV.CC.F32",
	VDIV_MI_F32:       "VDIV.MI.F32",
	VDIV_PL_F32:       "VDIV.PL.F32",
	VDIV_VS_F32:       "VDIV.VS.F32",
	VDIV_VC_F32:       "VDIV.VC.F32",
	VDIV_HI_F32:       "VDIV.HI.F32",
	VDIV_LS_F32:       "VDIV.LS.F32",
	VDIV_GE_F32:       "VDIV.GE.F32",
	VDIV_LT_F32:       "VDIV.LT.F32",
	VDIV_GT_F32:       "VDIV.GT.F32",
	VDIV_LE_F32:       "VDIV.LE.F32",
	VDIV_F32:          "VDIV.F32",
	VDIV_ZZ_F32:       "VDIV.ZZ.F32",
	VDIV_EQ_F64:       "VDIV.EQ.F64",
	VDIV_NE_F64:       "VDIV.NE.F64",
	VDIV_CS_F64:       "VDIV.CS.F64",
	VDIV_CC_F64:       "VDIV.CC.F64",
	VDIV_MI_F64:       "VDIV.MI.F64",
	VDIV_PL_F64:       "VDIV.PL.F64",
	VDIV_VS_F64:       "VDIV.VS.F64",
	VDIV_VC_F64:       "VDIV.VC.F64",
	VDIV_HI_F64:       "VDIV.HI.F64",
	VDIV_LS_F64:       "VDIV.LS.F64",
	VDIV_GE_F64:       "VDIV.GE.F64",
	VDIV_LT_F64:       "VDIV.LT.F64",
	VDIV_GT_F64:       "VDIV.GT.F64",
	VDIV_LE_F64:       "VDIV.LE.F64",
	VDIV_F64:          "VDIV.F64",
	VDIV_ZZ_F64:       "VDIV.ZZ.F64",
	VLDR_EQ:           "VLDR.EQ",
	VLDR_NE:           "VLDR.NE",
	VLDR_CS:           "VLDR.CS",
	VLDR_CC:           "VLDR.CC",
	VLDR_MI:           "VLDR.MI",
	VLDR_PL:           "VLDR.PL",
	VLDR_VS:           "VLDR.VS",
	VLDR_VC:           "VLDR.VC",
	VLDR_HI:           "VLDR.HI",
	VLDR_LS:           "VLDR.LS",
	VLDR_GE:           "VLDR.GE",
	VLDR_LT:           "VLDR.LT",
	VLDR_GT:           "VLDR.GT",
	VLDR_LE:           "VLDR.LE",
	VLDR:              "VLDR",
	VLDR_ZZ:           "VLDR.ZZ",
	VMLA_EQ_F32:       "VMLA.EQ.F32",
	VMLA_NE_F32:       "VMLA.NE.F32",
	VMLA_CS_F32:       "VMLA.CS.F32",
	VMLA_CC_F32:       "VMLA.CC.F32",
	VMLA_MI_F32:       "VMLA.MI.F32",
	VMLA_PL_F32:       "VMLA.PL.F32",
	VMLA_VS_F32:       "VMLA.VS.F32",
	VMLA_VC_F32:       "VMLA.VC.F32",
	VMLA_HI_F32:       "VMLA.HI.F32",
	VMLA_LS_F32:       "VMLA.LS.F32",
	VMLA_GE_F32:       "VMLA.GE.F32",
	VMLA_LT_F32:       "VMLA.LT.F32",
	VMLA_GT_F32:       "VMLA.GT.F32",
	VMLA_LE_F32:       "VMLA.LE.F32",
	VMLA_F32:          "VMLA.F32",
	VMLA_ZZ_F32:       "VMLA.ZZ.F32",
	VMLA_EQ_F64:       "VMLA.EQ.F64",
	VMLA_NE_F64:       "VMLA.NE.F64",
	VMLA_CS_F64:       "VMLA.CS.F64",
	VMLA_CC_F64:       "VMLA.CC.F64",
	VMLA_MI_F64:       "VMLA.MI.F64",
	VMLA_PL_F64:       "VMLA.PL.F64",
	VMLA_VS_F64:       "VMLA.VS.F64",
	VMLA_VC_F64:       "VMLA.VC.F64",
	VMLA_HI_F64:       "VMLA.HI.F64",
	VMLA_LS_F64:       "VMLA.LS.F64",
	VMLA_GE_F64:       "VMLA.GE.F64",
	VMLA_LT_F64:       "VMLA.LT.F64",
	VMLA_GT_F64:       "VMLA.GT.F64",
	VMLA_LE_F64:       "VMLA.LE.F64",
	VMLA_F64:          "VMLA.F64",
	VMLA_ZZ_F64:       "VMLA.ZZ.F64",
	VMLS_EQ_F32:       "VMLS.EQ.F32",
	VMLS_NE_F32:       "VMLS.NE.F32",
	VMLS_CS_F32:       "VMLS.CS.F32",
	VMLS_CC_F32:       "VMLS.CC.F32",
	VMLS_MI_F32:       "VMLS.MI.F32",
	VMLS_PL_F32:       "VMLS.PL.F32",
	VMLS_VS_F32:       "VMLS.VS.F32",
	VMLS_VC_F32:       "VMLS.VC.F32",
	VMLS_HI_F32:       "VMLS.HI.F32",
	VMLS_LS_F32:       "VMLS.LS.F32",
	VMLS_GE_F32:       "VMLS.GE.F32",
	VMLS_LT_F32:       "VMLS.LT.F32",
	VMLS_GT_F32:       "VMLS.GT.F32",
	VMLS_LE_F32:       "VMLS.LE.F32",
	VMLS_F32:          "VMLS.F32",
	VMLS_ZZ_F32:       "VMLS.ZZ.F32",
	VMLS_EQ_F64:       "VMLS.EQ.F64",
	VMLS_NE_F64:       "VMLS.NE.F64",
	VMLS_CS_F64:       "VMLS.CS.F64",
	VMLS_CC_F64:       "VMLS.CC.F64",
	VMLS_MI_F64:       "VMLS.MI.F64",
	VMLS_PL_F64:       "VMLS.PL.F64",
	VMLS_VS_F64:       "VMLS.VS.F64",
	VMLS_VC_F64:       "VMLS.VC.F64",
	VMLS_HI_F64:       "VMLS.HI.F64",
	VMLS_LS_F64:       "VMLS.LS.F64",
	VMLS_GE_F64:       "VMLS.GE.F64",
	VMLS_LT_F64:       "VMLS.LT.F64",
	VMLS_GT_F64:       "VMLS.GT.F64",
	VMLS_LE_F64:       "VMLS.LE.F64",
	VMLS_F64:          "VMLS.F64",
	VMLS_ZZ_F64:       "VMLS.ZZ.F64",
	VMOV_EQ:           "VMOV.EQ",
	VMOV_NE:           "VMOV.NE",
	VMOV_CS:           "VMOV.CS",
	VMOV_CC:           "VMOV.CC",
	VMOV_MI:           "VMOV.MI",
	VMOV_PL:           "VMOV.PL",
	VMOV_VS:           "VMOV.VS",
	VMOV_VC:           "VMOV.VC",
	VMOV_HI:           "VMOV.HI",
	VMOV_LS:           "VMOV.LS",
	VMOV_GE:           "VMOV.GE",
	VMOV_LT:           "VMOV.LT",
	VMOV_GT:           "VMOV.GT",
	VMOV_LE:           "VMOV.LE",
	VMOV:              "VMOV",
	VMOV_ZZ:           "VMOV.ZZ",
	VMOV_EQ_32:        "VMOV.EQ.32",
	VMOV_NE_32:        "VMOV.NE.32",
	VMOV_CS_32:        "VMOV.CS.32",
	VMOV_CC_32:        "VMOV.CC.32",
	VMOV_MI_32:        "VMOV.MI.32",
	VMOV_PL_32:        "VMOV.PL.32",
	VMOV_VS_32:        "VMOV.VS.32",
	VMOV_VC_32:        "VMOV.VC.32",
	VMOV_HI_32:        "VMOV.HI.32",
	VMOV_LS_32:        "VMOV.LS.32",
	VMOV_GE_32:        "VMOV.GE.32",
	VMOV_LT_32:        "VMOV.LT.32",
	VMOV_GT_32:        "VMOV.GT.32",
	VMOV_LE_32:        "VMOV.LE.32",
	VMOV_32:           "VMOV.32",
	VMOV_ZZ_32:        "VMOV.ZZ.32",
	VMOV_EQ_F32:       "VMOV.EQ.F32",
	VMOV_NE_F32:       "VMOV.NE.F32",
	VMOV_CS_F32:       "VMOV.CS.F32",
	VMOV_CC_F32:       "VMOV.CC.F32",
	VMOV_MI_F32:       "VMOV.MI.F32",
	VMOV_PL_F32:       "VMOV.PL.F32",
	VMOV_VS_F32:       "VMOV.VS.F32",
	VMOV_VC_F32:       "VMOV.VC.F32",
	VMOV_HI_F32:       "VMOV.HI.F32",
	VMOV_LS_F32:       "VMOV.LS.F32",
	VMOV_GE_F32:       "VMOV.GE.F32",
	VMOV_LT_F32:       "VMOV.LT.F32",
	VMOV_GT_F32:       "VMOV.GT.F32",
	VMOV_LE_F32:       "VMOV.LE.F32",
	VMOV_F32:          "VMOV.F32",
	VMOV_ZZ_F32:       "VMOV.ZZ.F32",
	VMOV_EQ_F64:       "VMOV.EQ.F64",
	VMOV_NE_F64:       "VMOV.NE.F64",
	VMOV_CS_F64:       "VMOV.CS.F64",
	VMOV_CC_F64:       "VMOV.CC.F64",
	VMOV_MI_F64:       "VMOV.MI.F64",
	VMOV_PL_F64:       "VMOV.PL.F64",
	VMOV_VS_F64:       "VMOV.VS.F64",
	VMOV_VC_F64:       "VMOV.VC.F64",
	VMOV_HI_F64:       "VMOV.HI.F64",
	VMOV_LS_F64:       "VMOV.LS.F64",
	VMOV_GE_F64:       "VMOV.GE.F64",
	VMOV_LT_F64:       "VMOV.LT.F64",
	VMOV_GT_F64:       "VMOV.GT.F64",
	VMOV_LE_F64:       "VMOV.LE.F64",
	VMOV_F64:          "VMOV.F64",
	VMOV_ZZ_F64:       "VMOV.ZZ.F64",
	VMRS_EQ:           "VMRS.EQ",
	VMRS_NE:           "VMRS.NE",
	VMRS_CS:           "VMRS.CS",
	VMRS_CC:           "VMRS.CC",
	VMRS_MI:           "VMRS.MI",
	VMRS_PL:           "VMRS.PL",
	VMRS_VS:           "VMRS.VS",
	VMRS_VC:           "VMRS.VC",
	VMRS_HI:           "VMRS.HI",
	VMRS_LS:           "VMRS.LS",
	VMRS_GE:           "VMRS.GE",
	VMRS_LT:           "VMRS.LT",
	VMRS_GT:           "VMRS.GT",
	VMRS_LE:           "VMRS.LE",
	VMRS:              "VMRS",
	VMRS_ZZ:           "VMRS.ZZ",
	VMSR_EQ:           "VMSR.EQ",
	VMSR_NE:           "VMSR.NE",
	VMSR_CS:           "VMSR.CS",
	VMSR_CC:           "VMSR.CC",
	VMSR_MI:           "VMSR.MI",
	VMSR_PL:           "VMSR.PL",
	VMSR_VS:           "VMSR.VS",
	VMSR_VC:           "VMSR.VC",
	VMSR_HI:           "VMSR.HI",
	VMSR_LS:           "VMSR.LS",
	VMSR_GE:           "VMSR.GE",
	VMSR_LT:           "VMSR.LT",
	VMSR_GT:           "VMSR.GT",
	VMSR_LE:           "VMSR.LE",
	VMSR:              "VMSR",
	VMSR_ZZ:           "VMSR.ZZ",
	VMUL_EQ_F32:       "VMUL.EQ.F32",
	VMUL_NE_F32:       "VMUL.NE.F32",
	VMUL_CS_F32:       "VMUL.CS.F32",
	VMUL_CC_F32:       "VMUL.CC.F32",
	VMUL_MI_F32:       "VMUL.MI.F32",
	VMUL_PL_F32:       "VMUL.PL.F32",
	VMUL_VS_F32:       "VMUL.VS.F32",
	VMUL_VC_F32:       "VMUL.VC.F32",
	VMUL_HI_F32:       "VMUL.HI.F32",
	VMUL_LS_F32:       "VMUL.LS.F32",
	VMUL_GE_F32:       "VMUL.GE.F32",
	VMUL_LT_F32:       "VMUL.LT.F32",
	VMUL_GT_F32:       "VMUL.GT.F32",
	VMUL_LE_F32:       "VMUL.LE.F32",
	VMUL_F32:          "VMUL.F32",
	VMUL_ZZ_F32:       "VMUL.ZZ.F32",
	VMUL_EQ_F64:       "VMUL.EQ.F64",
	VMUL_NE_F64:       "VMUL.NE.F64",
	VMUL_CS_F64:       "VMUL.CS.F64",
	VMUL_CC_F64:       "VMUL.CC.F64",
	VMUL_MI_F64:       "VMUL.MI.F64",
	VMUL_PL_F64:       "VMUL.PL.F64",
	VMUL_VS_F64:       "VMUL.VS.F64",
	VMUL_VC_F64:       "VMUL.VC.F64",
	VMUL_HI_F64:       "VMUL.HI.F64",
	VMUL_LS_F64:       "VMUL.LS.F64",
	VMUL_GE_F64:       "VMUL.GE.F64",
	VMUL_LT_F64:       "VMUL.LT.F64",
	VMUL_GT_F64:       "VMUL.GT.F64",
	VMUL_LE_F64:       "VMUL.LE.F64",
	VMUL_F64:          "VMUL.F64",
	VMUL_ZZ_F64:       "VMUL.ZZ.F64",
	VNEG_EQ_F32:       "VNEG.EQ.F32",
	VNEG_NE_F32:       "VNEG.NE.F32",
	VNEG_CS_F32:       "VNEG.CS.F32",
	VNEG_CC_F32:       "VNEG.CC.F32",
	VNEG_MI_F32:       "VNEG.MI.F32",
	VNEG_PL_F32:       "VNEG.PL.F32",
	VNEG_VS_F32:       "VNEG.VS.F32",
	VNEG_VC_F32:       "VNEG.VC.F32",
	VNEG_HI_F32:       "VNEG.HI.F32",
	VNEG_LS_F32:       "VNEG.LS.F32",
	VNEG_GE_F32:       "VNEG.GE.F32",
	VNEG_LT_F32:       "VNEG.LT.F32",
	VNEG_GT_F32:       "VNEG.GT.F32",
	VNEG_LE_F32:       "VNEG.LE.F32",
	VNEG_F32:          "VNEG.F32",
	VNEG_ZZ_F32:       "VNEG.ZZ.F32",
	VNEG_EQ_F64:       "VNEG.EQ.F64",
	VNEG_NE_F64:       "VNEG.NE.F64",
	VNEG_CS_F64:       "VNEG.CS.F64",
	VNEG_CC_F64:       "VNEG.CC.F64",
	VNEG_MI_F64:       "VNEG.MI.F64",
	VNEG_PL_F64:       "VNEG.PL.F64",
	VNEG_VS_F64:       "VNEG.VS.F64",
	VNEG_VC_F64:       "VNEG.VC.F64",
	VNEG_HI_F64:       "VNEG.HI.F64",
	VNEG_LS_F64:       "VNEG.LS.F64",
	VNEG_GE_F64:       "VNEG.GE.F64",
	VNEG_LT_F64:       "VNEG.LT.F64",
	VNEG_GT_F64:       "VNEG.GT.F64",
	VNEG_LE_F64:       "VNEG.LE.F64",
	VNEG_F64:          "VNEG.F64",
	VNEG_ZZ_F64:       "VNEG.ZZ.F64",
	VNMLS_EQ_F32:      "VNMLS.EQ.F32",
	VNMLS_NE_F32:      "VNMLS.NE.F32",
	VNMLS_CS_F32:      "VNMLS.CS.F32",
	VNMLS_CC_F32:      "VNMLS.CC.F32",
	VNMLS_MI_F32:      "VNMLS.MI.F32",
	VNMLS_PL_F32:      "VNMLS.PL.F32",
	VNMLS_VS_F32:      "VNMLS.VS.F32",
	VNMLS_VC_F32:      "VNMLS.VC.F32",
	VNMLS_HI_F32:      "VNMLS.HI.F32",
	VNMLS_LS_F32:      "VNMLS.LS.F32",
	VNMLS_GE_F32:      "VNMLS.GE.F32",
	VNMLS_LT_F32:      "VNMLS.LT.F32",
	VNMLS_GT_F32:      "VNMLS.GT.F32",
	VNMLS_LE_F32:      "VNMLS.LE.F32",
	VNMLS_F32:         "VNMLS.F32",
	VNMLS_ZZ_F32:      "VNMLS.ZZ.F32",
	VNMLS_EQ_F64:      "VNMLS.EQ.F64",
	VNMLS_NE_F64:      "VNMLS.NE.F64",
	VNMLS_CS_F64:      "VNMLS.CS.F64",
	VNMLS_CC_F64:      "VNMLS.CC.F64",
	VNMLS_MI_F64:      "VNMLS.MI.F64",
	VNMLS_PL_F64:      "VNMLS.PL.F64",
	VNMLS_VS_F64:      "VNMLS.VS.F64",
	VNMLS_VC_F64:      "VNMLS.VC.F64",
	VNMLS_HI_F64:      "VNMLS.HI.F64",
	VNMLS_LS_F64:      "VNMLS.LS.F64",
	VNMLS_GE_F64:      "VNMLS.GE.F64",
	VNMLS_LT_F64:      "VNMLS.LT.F64",
	VNMLS_GT_F64:      "VNMLS.GT.F64",
	VNMLS_LE_F64:      "VNMLS.LE.F64",
	VNMLS_F64:         "VNMLS.F64",
	VNMLS_ZZ_F64:      "VNMLS.ZZ.F64",
	VNMLA_EQ_F32:      "VNMLA.EQ.F32",
	VNMLA_NE_F32:      "VNMLA.NE.F32",
	VNMLA_CS_F32:      "VNMLA.CS.F32",
	VNMLA_CC_F32:      "VNMLA.CC.F32",
	VNMLA_MI_F32:      "VNMLA.MI.F32",
	VNMLA_PL_F32:      "VNMLA.PL.F32",
	VNMLA_VS_F32:      "VNMLA.VS.F32",
	VNMLA_VC_F32:      "VNMLA.VC.F32",
	VNMLA_HI_F32:      "VNMLA.HI.F32",
	VNMLA_LS_F32:      "VNMLA.LS.F32",
	VNMLA_GE_F32:      "VNMLA.GE.F32",
	VNMLA_LT_F32:      "VNMLA.LT.F32",
	VNMLA_GT_F32:      "VNMLA.GT.F32",
	VNMLA_LE_F32:      "VNMLA.LE.F32",
	VNMLA_F32:         "VNMLA.F32",
	VNMLA_ZZ_F32:      "VNMLA.ZZ.F32",
	VNMLA_EQ_F64:      "VNMLA.EQ.F64",
	VNMLA_NE_F64:      "VNMLA.NE.F64",
	VNMLA_CS_F64:      "VNMLA.CS.F64",
	VNMLA_CC_F64:      "VNMLA.CC.F64",
	VNMLA_MI_F64:      "VNMLA.MI.F64",
	VNMLA_PL_F64:      "VNMLA.PL.F64",
	VNMLA_VS_F64:      "VNMLA.VS.F64",
	VNMLA_VC_F64:      "VNMLA.VC.F64",
	VNMLA_HI_F64:      "VNMLA.HI.F64",
	VNMLA_LS_F64:      "VNMLA.LS.F64",
	VNMLA_GE_F64:      "VNMLA.GE.F64",
	VNMLA_LT_F64:      "VNMLA.LT.F64",
	VNMLA_GT_F64:      "VNMLA.GT.F64",
	VNMLA_LE_F64:      "VNMLA.LE.F64",
	VNMLA_F64:         "VNMLA.F64",
	VNMLA_ZZ_F64:      "VNMLA.ZZ.F64",
	VNMUL_EQ_F32:      "VNMUL.EQ.F32",
	VNMUL_NE_F32:      "VNMUL.NE.F32",
	VNMUL_CS_F32:      "VNMUL.CS.F32",
	VNMUL_CC_F32:      "VNMUL.CC.F32",
	VNMUL_MI_F32:      "VNMUL.MI.F32",
	VNMUL_PL_F32:      "VNMUL.PL.F32",
	VNMUL_VS_F32:      "VNMUL.VS.F32",
	VNMUL_VC_F32:      "VNMUL.VC.F32",
	VNMUL_HI_F32:      "VNMUL.HI.F32",
	VNMUL_LS_F32:      "VNMUL.LS.F32",
	VNMUL_GE_F32:      "VNMUL.GE.F32",
	VNMUL_LT_F32:      "VNMUL.LT.F32",
	VNMUL_GT_F32:      "VNMUL.GT.F32",
	VNMUL_LE_F32:      "VNMUL.LE.F32",
	VNMUL_F32:         "VNMUL.F32",
	VNMUL_ZZ_F32:      "VNMUL.ZZ.F32",
	VNMUL_EQ_F64:      "VNMUL.EQ.F64",
	VNMUL_NE_F64:      "VNMUL.NE.F64",
	VNMUL_CS_F64:      "VNMUL.CS.F64",
	VNMUL_CC_F64:      "VNMUL.CC.F64",
	VNMUL_MI_F64:      "VNMUL.MI.F64",
	VNMUL_PL_F64:      "VNMUL.PL.F64",
	VNMUL_VS_F64:      "VNMUL.VS.F64",
	VNMUL_VC_F64:      "VNMUL.VC.F64",
	VNMUL_HI_F64:      "VNMUL.HI.F64",
	VNMUL_LS_F64:      "VNMUL.LS.F64",
	VNMUL_GE_F64:      "VNMUL.GE.F64",
	VNMUL_LT_F64:      "VNMUL.LT.F64",
	VNMUL_GT_F64:      "VNMUL.GT.F64",
	VNMUL_LE_F64:      "VNMUL.LE.F64",
	VNMUL_F64:         "VNMUL.F64",
	VNMUL_ZZ_F64:      "VNMUL.ZZ.F64",
	VSQRT_EQ_F32:      "VSQRT.EQ.F32",
	VSQRT_NE_F32:      "VSQRT.NE.F32",
	VSQRT_CS_F32:      "VSQRT.CS.F32",
	VSQRT_CC_F32:      "VSQRT.CC.F32",
	VSQRT_MI_F32:      "VSQRT.MI.F32",
	VSQRT_PL_F32:      "VSQRT.PL.F32",
	VSQRT_VS_F32:      "VSQRT.VS.F32",
	VSQRT_VC_F32:      "VSQRT.VC.F32",
	VSQRT_HI_F32:      "VSQRT.HI.F32",
	VSQRT_LS_F32:      "VSQRT.LS.F32",
	VSQRT_GE_F32:      "VSQRT.GE.F32",
	VSQRT_LT_F32:      "VSQRT.LT.F32",
	VSQRT_GT_F32:      "VSQRT.GT.F32",
	VSQRT_LE_F32:      "VSQRT.LE.F32",
	VSQRT_F32:         "VSQRT.F32",
	VSQRT_ZZ_F32:      "VSQRT.ZZ.F32",
	VSQRT_EQ_F64:      "VSQRT.EQ.F64",
	VSQRT_NE_F64:      "VSQRT.NE.F64",
	VSQRT_CS_F64:      "VSQRT.CS.F64",
	VSQRT_CC_F64:      "VSQRT.CC.F64",
	VSQRT_MI_F64:      "VSQRT.MI.F64",
	VSQRT_PL_F64:      "VSQRT.PL.F64",
	VSQRT_VS_F64:      "VSQRT.VS.F64",
	VSQRT_VC_F64:      "VSQRT.VC.F64",
	VSQRT_HI_F64:      "VSQRT.HI.F64",
	VSQRT_LS_F64:      "VSQRT.LS.F64",
	VSQRT_GE_F64:      "VSQRT.GE.F64",
	VSQRT_LT_F64:      "VSQRT.LT.F64",
	VSQRT_GT_F64:      "VSQRT.GT.F64",
	VSQRT_LE_F64:      "VSQRT.LE.F64",
	VSQRT_F64:         "VSQRT.F64",
	VSQRT_ZZ_F64:      "VSQRT.ZZ.F64",
	VSTR_EQ:           "VSTR.EQ",
	VSTR_NE:           "VSTR.NE",
	VSTR_CS:           "VSTR.CS",
	VSTR_CC:           "VSTR.CC",
	VSTR_MI:           "VSTR.MI",
	VSTR_PL:           "VSTR.PL",
	VSTR_VS:           "VSTR.VS",
	VSTR_VC:           "VSTR.VC",
	VSTR_HI:           "VSTR.HI",
	VSTR_LS:           "VSTR.LS",
	VSTR_GE:           "VSTR.GE",
	VSTR_LT:           "VSTR.LT",
	VSTR_GT:           "VSTR.GT",
	VSTR_LE:           "VSTR.LE",
	VSTR:              "VSTR",
	VSTR_ZZ:           "VSTR.ZZ",
	VSUB_EQ_F32:       "VSUB.EQ.F32",
	VSUB_NE_F32:       "VSUB.NE.F32",
	VSUB_CS_F32:       "VSUB.CS.F32",
	VSUB_CC_F32:       "VSUB.CC.F32",
	VSUB_MI_F32:       "VSUB.MI.F32",
	VSUB_PL_F32:       "VSUB.PL.F32",
	VSUB_VS_F32:       "VSUB.VS.F32",
	VSUB_VC_F32:       "VSUB.VC.F32",
	VSUB_HI_F32:       "VSUB.HI.F32",
	VSUB_LS_F32:       "VSUB.LS.F32",
	VSUB_GE_F32:       "VSUB.GE.F32",
	VSUB_LT_F32:       "VSUB.LT.F32",
	VSUB_GT_F32:       "VSUB.GT.F32",
	VSUB_LE_F32:       "VSUB.LE.F32",
	VSUB_F32:          "VSUB.F32",
	VSUB_ZZ_F32:       "VSUB.ZZ.F32",
	VSUB_EQ_F64:       "VSUB.EQ.F64",
	VSUB_NE_F64:       "VSUB.NE.F64",
	VSUB_CS_F64:       "VSUB.CS.F64",
	VSUB_CC_F64:       "VSUB.CC.F64",
	VSUB_MI_F64:       "VSUB.MI.F64",
	VSUB_PL_F64:       "VSUB.PL.F64",
	VSUB_VS_F64:       "VSUB.VS.F64",
	VSUB_VC_F64:       "VSUB.VC.F64",
	VSUB_HI_F64:       "VSUB.HI.F64",
	VSUB_LS_F64:       "VSUB.LS.F64",
	VSUB_GE_F64:       "VSUB.GE.F64",
	VSUB_LT_F64:       "VSUB.LT.F64",
	VSUB_GT_F64:       "VSUB.GT.F64",
	VSUB_LE_F64:       "VSUB.LE.F64",
	VSUB_F64:          "VSUB.F64",
	VSUB_ZZ_F64:       "VSUB.ZZ.F64",
	WFE_EQ:            "WFE.EQ",
	WFE_NE:            "WFE.NE",
	WFE_CS:            "WFE.CS",
	WFE_CC:            "WFE.CC",
	WFE_MI:            "WFE.MI",
	WFE_PL:            "WFE.PL",
	WFE_VS:            "WFE.VS",
	WFE_VC:            "WFE.VC",
	WFE_HI:            "WFE.HI",
	WFE_LS:            "WFE.LS",
	WFE_GE:            "WFE.GE",
	WFE_LT:            "WFE.LT",
	WFE_GT:            "WFE.GT",
	WFE_LE:            "WFE.LE",
	WFE:               "WFE",
	WFE_ZZ:            "WFE.ZZ",
	WFI_EQ:            "WFI.EQ",
	WFI_NE:            "WFI.NE",
	WFI_CS:            "WFI.CS",
	WFI_CC:            "WFI.CC",
	WFI_MI:            "WFI.MI",
	WFI_PL:            "WFI.PL",
	WFI_VS:            "WFI.VS",
	WFI_VC:            "WFI.VC",
	WFI_HI:            "WFI.HI",
	WFI_LS:            "WFI.LS",
	WFI_GE:            "WFI.GE",
	WFI_LT:            "WFI.LT",
	WFI_GT:            "WFI.GT",
	WFI_LE:            "WFI.LE",
	WFI:               "WFI",
	WFI_ZZ:            "WFI.ZZ",
	YIELD_EQ:          "YIELD.EQ",
	YIELD_NE:          "YIELD.NE",
	YIELD_CS:          "YIELD.CS",
	YIELD_CC:          "YIELD.CC",
	YIELD_MI:          "YIELD.MI",
	YIELD_PL:          "YIELD.PL",
	YIELD_VS:          "YIELD.VS",
	YIELD_VC:          "YIELD.VC",
	YIELD_HI:          "YIELD.HI",
	YIELD_LS:          "YIELD.LS",
	YIELD_GE:          "YIELD.GE",
	YIELD_LT:          "YIELD.LT",
	YIELD_GT:          "YIELD.GT",
	YIELD_LE:          "YIELD.LE",
	YIELD:             "YIELD",
	YIELD_ZZ:          "YIELD.ZZ",
}

var instFormats = [...]instFormat{
	{0x0fe00000, 0x02a00000, 2, ADC_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_const}},                      // ADC{S}<c> <Rd>,<Rn>,#<const> cond:4|0|0|1|0|1|0|1|S|Rn:4|Rd:4|imm12:12
	{0x0fe00090, 0x00a00010, 4, ADC_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_R}},                  // ADC{S}<c> <Rd>,<Rn>,<Rm>,<type> <Rs> cond:4|0|0|0|0|1|0|1|S|Rn:4|Rd:4|Rs:4|0|type:2|1|Rm:4
	{0x0fe00010, 0x00a00000, 2, ADC_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_imm}},                // ADC{S}<c> <Rd>,<Rn>,<Rm>{,<shift>} cond:4|0|0|0|0|1|0|1|S|Rn:4|Rd:4|imm5:5|type:2|0|Rm:4
	{0x0fe00000, 0x02800000, 2, ADD_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_const}},                      // ADD{S}<c> <Rd>,<Rn>,#<const> cond:4|0|0|1|0|1|0|0|S|Rn:4|Rd:4|imm12:12
	{0x0fe00090, 0x00800010, 4, ADD_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_R}},                  // ADD{S}<c> <Rd>,<Rn>,<Rm>,<type> <Rs> cond:4|0|0|0|0|1|0|0|S|Rn:4|Rd:4|Rs:4|0|type:2|1|Rm:4
	{0x0fe00010, 0x00800000, 2, ADD_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_imm}},                // ADD{S}<c> <Rd>,<Rn>,<Rm>{,<shift>} cond:4|0|0|0|0|1|0|0|S|Rn:4|Rd:4|imm5:5|type:2|0|Rm:4
	{0x0fef0000, 0x028d0000, 2, ADD_EQ, 0x14011c04, instArgs{arg_R_12, arg_SP, arg_const}},                        // ADD{S}<c> <Rd>,SP,#<const> cond:4|0|0|1|0|1|0|0|S|1|1|0|1|Rd:4|imm12:12
	{0x0fef0010, 0x008d0000, 2, ADD_EQ, 0x14011c04, instArgs{arg_R_12, arg_SP, arg_R_shift_imm}},                  // ADD{S}<c> <Rd>,SP,<Rm>{,<shift>} cond:4|0|0|0|0|1|0|0|S|1|1|0|1|Rd:4|imm5:5|type:2|0|Rm:4
	{0x0fe00000, 0x02000000, 2, AND_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_const}},                      // AND{S}<c> <Rd>,<Rn>,#<const> cond:4|0|0|1|0|0|0|0|S|Rn:4|Rd:4|imm12:12
	{0x0fe00090, 0x00000010, 4, AND_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_R}},                  // AND{S}<c> <Rd>,<Rn>,<Rm>,<type> <Rs> cond:4|0|0|0|0|0|0|0|S|Rn:4|Rd:4|Rs:4|0|type:2|1|Rm:4
	{0x0fe00010, 0x00000000, 2, AND_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_imm}},                // AND{S}<c> <Rd>,<Rn>,<Rm>{,<shift>} cond:4|0|0|0|0|0|0|0|S|Rn:4|Rd:4|imm5:5|type:2|0|Rm:4
	{0x0fef0070, 0x01a00040, 4, ASR_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_0, arg_imm5_32}},                     // ASR{S}<c> <Rd>,<Rm>,#<imm5_32> cond:4|0|0|0|1|1|0|1|S|0|0|0|0|Rd:4|imm5:5|1|0|0|Rm:4
	{0x0fef00f0, 0x01a00050, 4, ASR_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_0, arg_R_8}},                         // ASR{S}<c> <Rd>,<Rn>,<Rm> cond:4|0|0|0|1|1|0|1|S|0|0|0|0|Rd:4|Rm:4|0|1|0|1|Rn:4
	{0x0f000000, 0x0a000000, 4, B_EQ, 0x1c04, instArgs{arg_label24}},                                              // B<c> <label24> cond:4|1|0|1|0|imm24:24
	{0x0fe0007f, 0x07c0001f, 4, BFC_EQ, 0x1c04, instArgs{arg_R_12, arg_imm5, arg_lsb_width}},                      // BFC<c> <Rd>,#<lsb>,#<width> cond:4|0|1|1|1|1|1|0|msb:5|Rd:4|lsb:5|0|0|1|1|1|1|1
	{0x0fe00070, 0x07c00010, 2, BFI_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0, arg_imm5, arg_lsb_width}},             // BFI<c> <Rd>,<Rn>,#<lsb>,#<width> cond:4|0|1|1|1|1|1|0|msb:5|Rd:4|lsb:5|0|0|1|Rn:4
	{0x0fe00000, 0x03c00000, 2, BIC_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_const}},                      // BIC{S}<c> <Rd>,<Rn>,#<const> cond:4|0|0|1|1|1|1|0|S|Rn:4|Rd:4|imm12:12
	{0x0fe00090, 0x01c00010, 4, BIC_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_R}},                  // BIC{S}<c> <Rd>,<Rn>,<Rm>,<type> <Rs> cond:4|0|0|0|1|1|1|0|S|Rn:4|Rd:4|Rs:4|0|type:2|1|Rm:4
	{0x0fe00010, 0x01c00000, 2, BIC_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_imm}},                // BIC{S}<c> <Rd>,<Rn>,<Rm>{,<shift>} cond:4|0|0|0|1|1|1|0|S|Rn:4|Rd:4|imm5:5|type:2|0|Rm:4
	{0x0ff000f0, 0x01200070, 4, BKPT_EQ, 0x1c04, instArgs{arg_imm_12at8_4at0}},                                    // BKPT<c> #<imm12+4> cond:4|0|0|0|1|0|0|1|0|imm12:12|0|1|1|1|imm4:4
	{0x0f000000, 0x0b000000, 4, BL_EQ, 0x1c04, instArgs{arg_label24}},                                             // BL<c> <label24> cond:4|1|0|1|1|imm24:24
	{0xfe000000, 0xfa000000, 4, BLX, 0x0, instArgs{arg_label24H}},                                                 // BLX <label24H> 1|1|1|1|1|0|1|H|imm24:24
	{0x0ffffff0, 0x012fff30, 4, BLX_EQ, 0x1c04, instArgs{arg_R_0}},                                                // BLX<c> <Rm> cond:4|0|0|0|1|0|0|1|0|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|0|0|1|1|Rm:4
	{0x0ff000f0, 0x012fff30, 3, BLX_EQ, 0x1c04, instArgs{arg_R_0}},                                                // BLX<c> <Rm> cond:4|0|0|0|1|0|0|1|0|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|0|0|1|1|Rm:4
	{0x0ffffff0, 0x012fff10, 4, BX_EQ, 0x1c04, instArgs{arg_R_0}},                                                 // BX<c> <Rm> cond:4|0|0|0|1|0|0|1|0|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|0|0|0|1|Rm:4
	{0x0ff000f0, 0x012fff10, 3, BX_EQ, 0x1c04, instArgs{arg_R_0}},                                                 // BX<c> <Rm> cond:4|0|0|0|1|0|0|1|0|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|0|0|0|1|Rm:4
	{0x0ffffff0, 0x012fff20, 4, BXJ_EQ, 0x1c04, instArgs{arg_R_0}},                                                // BXJ<c> <Rm> cond:4|0|0|0|1|0|0|1|0|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|0|0|1|0|Rm:4
	{0x0ff000f0, 0x012fff20, 3, BXJ_EQ, 0x1c04, instArgs{arg_R_0}},                                                // BXJ<c> <Rm> cond:4|0|0|0|1|0|0|1|0|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|0|0|1|0|Rm:4
	{0xffffffff, 0xf57ff01f, 4, CLREX, 0x0, instArgs{}},                                                           // CLREX 1|1|1|1|0|1|0|1|0|1|1|1|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|0|0|0|1|(1)|(1)|(1)|(1)
	{0xfff000f0, 0xf57ff01f, 3, CLREX, 0x0, instArgs{}},                                                           // CLREX 1|1|1|1|0|1|0|1|0|1|1|1|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|0|0|0|1|(1)|(1)|(1)|(1)
	{0x0fff0ff0, 0x016f0f10, 4, CLZ_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0}},                                      // CLZ<c> <Rd>,<Rm> cond:4|0|0|0|1|0|1|1|0|(1)|(1)|(1)|(1)|Rd:4|(1)|(1)|(1)|(1)|0|0|0|1|Rm:4
	{0x0ff000f0, 0x016f0f10, 3, CLZ_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0}},                                      // CLZ<c> <Rd>,<Rm> cond:4|0|0|0|1|0|1|1|0|(1)|(1)|(1)|(1)|Rd:4|(1)|(1)|(1)|(1)|0|0|0|1|Rm:4
	{0x0ff0f000, 0x03700000, 4, CMN_EQ, 0x1c04, instArgs{arg_R_16, arg_const}},                                    // CMN<c> <Rn>,#<const> cond:4|0|0|1|1|0|1|1|1|Rn:4|(0)|(0)|(0)|(0)|imm12:12
	{0x0ff00000, 0x03700000, 3, CMN_EQ, 0x1c04, instArgs{arg_R_16, arg_const}},                                    // CMN<c> <Rn>,#<const> cond:4|0|0|1|1|0|1|1|1|Rn:4|(0)|(0)|(0)|(0)|imm12:12
	{0x0ff0f090, 0x01700010, 4, CMN_EQ, 0x1c04, instArgs{arg_R_16, arg_R_shift_R}},                                // CMN<c> <Rn>,<Rm>,<type> <Rs> cond:4|0|0|0|1|0|1|1|1|Rn:4|(0)|(0)|(0)|(0)|Rs:4|0|type:2|1|Rm:4
	{0x0ff00090, 0x01700010, 3, CMN_EQ, 0x1c04, instArgs{arg_R_16, arg_R_shift_R}},                                // CMN<c> <Rn>,<Rm>,<type> <Rs> cond:4|0|0|0|1|0|1|1|1|Rn:4|(0)|(0)|(0)|(0)|Rs:4|0|type:2|1|Rm:4
	{0x0ff0f010, 0x01700000, 4, CMN_EQ, 0x1c04, instArgs{arg_R_16, arg_R_shift_imm}},                              // CMN<c> <Rn>,<Rm>{,<shift>} cond:4|0|0|0|1|0|1|1|1|Rn:4|(0)|(0)|(0)|(0)|imm5:5|type:2|0|Rm:4
	{0x0ff00010, 0x01700000, 3, CMN_EQ, 0x1c04, instArgs{arg_R_16, arg_R_shift_imm}},                              // CMN<c> <Rn>,<Rm>{,<shift>} cond:4|0|0|0|1|0|1|1|1|Rn:4|(0)|(0)|(0)|(0)|imm5:5|type:2|0|Rm:4
	{0x0ff0f000, 0x03500000, 4, CMP_EQ, 0x1c04, instArgs{arg_R_16, arg_const}},                                    // CMP<c> <Rn>,#<const> cond:4|0|0|1|1|0|1|0|1|Rn:4|(0)|(0)|(0)|(0)|imm12:12
	{0x0ff00000, 0x03500000, 3, CMP_EQ, 0x1c04, instArgs{arg_R_16, arg_const}},                                    // CMP<c> <Rn>,#<const> cond:4|0|0|1|1|0|1|0|1|Rn:4|(0)|(0)|(0)|(0)|imm12:12
	{0x0ff0f090, 0x01500010, 4, CMP_EQ, 0x1c04, instArgs{arg_R_16, arg_R_shift_R}},                                // CMP<c> <Rn>,<Rm>,<type> <Rs> cond:4|0|0|0|1|0|1|0|1|Rn:4|(0)|(0)|(0)|(0)|Rs:4|0|type:2|1|Rm:4
	{0x0ff00090, 0x01500010, 3, CMP_EQ, 0x1c04, instArgs{arg_R_16, arg_R_shift_R}},                                // CMP<c> <Rn>,<Rm>,<type> <Rs> cond:4|0|0|0|1|0|1|0|1|Rn:4|(0)|(0)|(0)|(0)|Rs:4|0|type:2|1|Rm:4
	{0x0ff0f010, 0x01500000, 4, CMP_EQ, 0x1c04, instArgs{arg_R_16, arg_R_shift_imm}},                              // CMP<c> <Rn>,<Rm>{,<shift>} cond:4|0|0|0|1|0|1|0|1|Rn:4|(0)|(0)|(0)|(0)|imm5:5|type:2|0|Rm:4
	{0x0ff00010, 0x01500000, 3, CMP_EQ, 0x1c04, instArgs{arg_R_16, arg_R_shift_imm}},                              // CMP<c> <Rn>,<Rm>{,<shift>} cond:4|0|0|0|1|0|1|0|1|Rn:4|(0)|(0)|(0)|(0)|imm5:5|type:2|0|Rm:4
	{0x0ffffff0, 0x0320f0f0, 4, DBG_EQ, 0x1c04, instArgs{arg_option}},                                             // DBG<c> #<option> cond:4|0|0|1|1|0|0|1|0|0|0|0|0|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|1|1|1|1|option:4
	{0x0fff00f0, 0x0320f0f0, 3, DBG_EQ, 0x1c04, instArgs{arg_option}},                                             // DBG<c> #<option> cond:4|0|0|1|1|0|0|1|0|0|0|0|0|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|1|1|1|1|option:4
	{0xfffffff0, 0xf57ff050, 4, DMB, 0x0, instArgs{arg_option}},                                                   // DMB #<option> 1|1|1|1|0|1|0|1|0|1|1|1|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|0|1|0|1|option:4
	{0xfff000f0, 0xf57ff050, 3, DMB, 0x0, instArgs{arg_option}},                                                   // DMB #<option> 1|1|1|1|0|1|0|1|0|1|1|1|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|0|1|0|1|option:4
	{0xfffffff0, 0xf57ff040, 4, DSB, 0x0, instArgs{arg_option}},                                                   // DSB #<option> 1|1|1|1|0|1|0|1|0|1|1|1|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|0|1|0|0|option:4
	{0xfff000f0, 0xf57ff040, 3, DSB, 0x0, instArgs{arg_option}},                                                   // DSB #<option> 1|1|1|1|0|1|0|1|0|1|1|1|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|0|1|0|0|option:4
	{0x0fe00000, 0x02200000, 2, EOR_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_const}},                      // EOR{S}<c> <Rd>,<Rn>,#<const> cond:4|0|0|1|0|0|0|1|S|Rn:4|Rd:4|imm12:12
	{0x0fe00090, 0x00200010, 4, EOR_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_R}},                  // EOR{S}<c> <Rd>,<Rn>,<Rm>,<type> <Rs> cond:4|0|0|0|0|0|0|1|S|Rn:4|Rd:4|Rs:4|0|type:2|1|Rm:4
	{0x0fe00010, 0x00200000, 2, EOR_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_imm}},                // EOR{S}<c> <Rd>,<Rn>,<Rm>{,<shift>} cond:4|0|0|0|0|0|0|1|S|Rn:4|Rd:4|imm5:5|type:2|0|Rm:4
	{0xfffffff0, 0xf57ff060, 4, ISB, 0x0, instArgs{arg_option}},                                                   // ISB #<option> 1|1|1|1|0|1|0|1|0|1|1|1|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|0|1|1|0|option:4
	{0xfff000f0, 0xf57ff060, 3, ISB, 0x0, instArgs{arg_option}},                                                   // ISB #<option> 1|1|1|1|0|1|0|1|0|1|1|1|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|0|1|1|0|option:4
	{0x0fd00000, 0x08900000, 2, LDM_EQ, 0x1c04, instArgs{arg_R_16_WB, arg_registers}},                             // LDM<c> <Rn>{!},<registers> cond:4|1|0|0|0|1|0|W|1|Rn:4|register_list:16
	{0x0fd00000, 0x08100000, 4, LDMDA_EQ, 0x1c04, instArgs{arg_R_16_WB, arg_registers}},                           // LDMDA<c> <Rn>{!},<registers> cond:4|1|0|0|0|0|0|W|1|Rn:4|register_list:16
	{0x0fd00000, 0x09100000, 4, LDMDB_EQ, 0x1c04, instArgs{arg_R_16_WB, arg_registers}},                           // LDMDB<c> <Rn>{!},<registers> cond:4|1|0|0|1|0|0|W|1|Rn:4|register_list:16
	{0x0fd00000, 0x09900000, 4, LDMIB_EQ, 0x1c04, instArgs{arg_R_16_WB, arg_registers}},                           // LDMIB<c> <Rn>{!},<registers> cond:4|1|0|0|1|1|0|W|1|Rn:4|register_list:16
	{0x0f7f0000, 0x051f0000, 4, LDR_EQ, 0x1c04, instArgs{arg_R_12, arg_label_pm_12}},                              // LDR<c> <Rt>,<label+/-12> cond:4|0|1|0|(1)|U|0|(0)|1|1|1|1|1|Rt:4|imm12:12
	{0x0e5f0000, 0x051f0000, 3, LDR_EQ, 0x1c04, instArgs{arg_R_12, arg_label_pm_12}},                              // LDR<c> <Rt>,<label+/-12> cond:4|0|1|0|(1)|U|0|(0)|1|1|1|1|1|Rt:4|imm12:12
	{0x0e500010, 0x06100000, 2, LDR_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_R_shift_imm_W}},                   // LDR<c> <Rt>,[<Rn>,+/-<Rm>{, <shift>}]{!} cond:4|0|1|1|P|U|0|W|1|Rn:4|Rt:4|imm5:5|type:2|0|Rm:4
	{0x0e500000, 0x04100000, 2, LDR_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_imm12_W}},                         // LDR<c> <Rt>,[<Rn>{,#+/-<imm12>}]{!} cond:4|0|1|0|P|U|0|W|1|Rn:4|Rt:4|imm12:12
	{0x0f7f0000, 0x055f0000, 4, LDRB_EQ, 0x1c04, instArgs{arg_R_12, arg_label_pm_12}},                             // LDRB<c> <Rt>,<label+/-12> cond:4|0|1|0|(1)|U|1|(0)|1|1|1|1|1|Rt:4|imm12:12
	{0x0e5f0000, 0x055f0000, 3, LDRB_EQ, 0x1c04, instArgs{arg_R_12, arg_label_pm_12}},                             // LDRB<c> <Rt>,<label+/-12> cond:4|0|1|0|(1)|U|1|(0)|1|1|1|1|1|Rt:4|imm12:12
	{0x0e500010, 0x06500000, 2, LDRB_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_R_shift_imm_W}},                  // LDRB<c> <Rt>,[<Rn>,+/-<Rm>{, <shift>}]{!} cond:4|0|1|1|P|U|1|W|1|Rn:4|Rt:4|imm5:5|type:2|0|Rm:4
	{0x0e500000, 0x04500000, 2, LDRB_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_imm12_W}},                        // LDRB<c> <Rt>,[<Rn>{,#+/-<imm12>}]{!} cond:4|0|1|0|P|U|1|W|1|Rn:4|Rt:4|imm12:12
	{0x0f700000, 0x04700000, 4, LDRBT_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_imm12_postindex}},               // LDRBT<c> <Rt>,[<Rn>],#+/-<imm12> cond:4|0|1|0|0|U|1|1|1|Rn:4|Rt:4|imm12:12
	{0x0f700010, 0x06700000, 4, LDRBT_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_R_shift_imm_postindex}},         // LDRBT<c> <Rt>,[<Rn>],+/-<Rm>{, <shift>} cond:4|0|1|1|0|U|1|1|1|Rn:4|Rt:4|imm5:5|type:2|0|Rm:4
	{0x0e500ff0, 0x000000d0, 4, LDRD_EQ, 0x1c04, instArgs{arg_R1_12, arg_R2_12, arg_mem_R_pm_R_W}},                // LDRD<c> <Rt1>,<Rt2>,[<Rn>,+/-<Rm>]{!} cond:4|0|0|0|P|U|0|W|0|Rn:4|Rt:4|(0)|(0)|(0)|(0)|1|1|0|1|Rm:4
	{0x0e5000f0, 0x000000d0, 3, LDRD_EQ, 0x1c04, instArgs{arg_R1_12, arg_R2_12, arg_mem_R_pm_R_W}},                // LDRD<c> <Rt1>,<Rt2>,[<Rn>,+/-<Rm>]{!} cond:4|0|0|0|P|U|0|W|0|Rn:4|Rt:4|(0)|(0)|(0)|(0)|1|1|0|1|Rm:4
	{0x0e5000f0, 0x004000d0, 2, LDRD_EQ, 0x1c04, instArgs{arg_R1_12, arg_R2_12, arg_mem_R_pm_imm8_W}},             // LDRD<c> <Rt1>,<Rt2>,[<Rn>{,#+/-<imm8>}]{!} cond:4|0|0|0|P|U|1|W|0|Rn:4|Rt:4|imm4H:4|1|1|0|1|imm4L:4
	{0x0ff00fff, 0x01900f9f, 4, LDREX_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R}},                                  // LDREX<c> <Rt>,[<Rn>] cond:4|0|0|0|1|1|0|0|1|Rn:4|Rt:4|(1)|(1)|(1)|(1)|1|0|0|1|(1)|(1)|(1)|(1)
	{0x0ff000f0, 0x01900f9f, 3, LDREX_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R}},                                  // LDREX<c> <Rt>,[<Rn>] cond:4|0|0|0|1|1|0|0|1|Rn:4|Rt:4|(1)|(1)|(1)|(1)|1|0|0|1|(1)|(1)|(1)|(1)
	{0x0ff00fff, 0x01d00f9f, 4, LDREXB_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R}},                                 // LDREXB<c> <Rt>, [<Rn>] cond:4|0|0|0|1|1|1|0|1|Rn:4|Rt:4|(1)|(1)|(1)|(1)|1|0|0|1|(1)|(1)|(1)|(1)
	{0x0ff000f0, 0x01d00f9f, 3, LDREXB_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R}},                                 // LDREXB<c> <Rt>, [<Rn>] cond:4|0|0|0|1|1|1|0|1|Rn:4|Rt:4|(1)|(1)|(1)|(1)|1|0|0|1|(1)|(1)|(1)|(1)
	{0x0ff00fff, 0x01b00f9f, 4, LDREXD_EQ, 0x1c04, instArgs{arg_R1_12, arg_R2_12, arg_mem_R}},                     // LDREXD<c> <Rt1>,<Rt2>,[<Rn>] cond:4|0|0|0|1|1|0|1|1|Rn:4|Rt:4|(1)|(1)|(1)|(1)|1|0|0|1|(1)|(1)|(1)|(1)
	{0x0ff000f0, 0x01b00f9f, 3, LDREXD_EQ, 0x1c04, instArgs{arg_R1_12, arg_R2_12, arg_mem_R}},                     // LDREXD<c> <Rt1>,<Rt2>,[<Rn>] cond:4|0|0|0|1|1|0|1|1|Rn:4|Rt:4|(1)|(1)|(1)|(1)|1|0|0|1|(1)|(1)|(1)|(1)
	{0x0ff00fff, 0x01f00f9f, 4, LDREXH_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R}},                                 // LDREXH<c> <Rt>, [<Rn>] cond:4|0|0|0|1|1|1|1|1|Rn:4|Rt:4|(1)|(1)|(1)|(1)|1|0|0|1|(1)|(1)|(1)|(1)
	{0x0ff000f0, 0x01f00f9f, 3, LDREXH_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R}},                                 // LDREXH<c> <Rt>, [<Rn>] cond:4|0|0|0|1|1|1|1|1|Rn:4|Rt:4|(1)|(1)|(1)|(1)|1|0|0|1|(1)|(1)|(1)|(1)
	{0x0e500ff0, 0x001000b0, 2, LDRH_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_R_W}},                            // LDRH<c> <Rt>,[<Rn>,+/-<Rm>]{!} cond:4|0|0|0|P|U|0|W|1|Rn:4|Rt:4|0|0|0|0|1|0|1|1|Rm:4
	{0x0e5000f0, 0x005000b0, 2, LDRH_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_imm8_W}},                         // LDRH<c> <Rt>,[<Rn>{,#+/-<imm8>}]{!} cond:4|0|0|0|P|U|1|W|1|Rn:4|Rt:4|imm4H:4|1|0|1|1|imm4L:4
	{0x0f7000f0, 0x007000b0, 4, LDRHT_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_imm8_postindex}},                // LDRHT<c> <Rt>, [<Rn>] {,#+/-<imm8>} cond:4|0|0|0|0|U|1|1|1|Rn:4|Rt:4|imm4H:4|1|0|1|1|imm4L:4
	{0x0f700ff0, 0x003000b0, 4, LDRHT_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_R_postindex}},                   // LDRHT<c> <Rt>, [<Rn>], +/-<Rm> cond:4|0|0|0|0|U|0|1|1|Rn:4|Rt:4|0|0|0|0|1|0|1|1|Rm:4
	{0x0e500ff0, 0x001000d0, 2, LDRSB_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_R_W}},                           // LDRSB<c> <Rt>,[<Rn>,+/-<Rm>]{!} cond:4|0|0|0|P|U|0|W|1|Rn:4|Rt:4|0|0|0|0|1|1|0|1|Rm:4
	{0x0e5000f0, 0x005000d0, 2, LDRSB_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_imm8_W}},                        // LDRSB<c> <Rt>,[<Rn>{,#+/-<imm8>}]{!} cond:4|0|0|0|P|U|1|W|1|Rn:4|Rt:4|imm4H:4|1|1|0|1|imm4L:4
	{0x0f7000f0, 0x007000d0, 4, LDRSBT_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_imm8_postindex}},               // LDRSBT<c> <Rt>, [<Rn>] {,#+/-<imm8>} cond:4|0|0|0|0|U|1|1|1|Rn:4|Rt:4|imm4H:4|1|1|0|1|imm4L:4
	{0x0f700ff0, 0x003000d0, 4, LDRSBT_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_R_postindex}},                  // LDRSBT<c> <Rt>, [<Rn>], +/-<Rm> cond:4|0|0|0|0|U|0|1|1|Rn:4|Rt:4|0|0|0|0|1|1|0|1|Rm:4
	{0x0e500ff0, 0x001000f0, 2, LDRSH_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_R_W}},                           // LDRSH<c> <Rt>,[<Rn>,+/-<Rm>]{!} cond:4|0|0|0|P|U|0|W|1|Rn:4|Rt:4|0|0|0|0|1|1|1|1|Rm:4
	{0x0e5000f0, 0x005000f0, 2, LDRSH_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_imm8_W}},                        // LDRSH<c> <Rt>,[<Rn>{,#+/-<imm8>}]{!} cond:4|0|0|0|P|U|1|W|1|Rn:4|Rt:4|imm4H:4|1|1|1|1|imm4L:4
	{0x0f7000f0, 0x007000f0, 4, LDRSHT_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_imm8_postindex}},               // LDRSHT<c> <Rt>, [<Rn>] {,#+/-<imm8>} cond:4|0|0|0|0|U|1|1|1|Rn:4|Rt:4|imm4H:4|1|1|1|1|imm4L:4
	{0x0f700ff0, 0x003000f0, 4, LDRSHT_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_R_postindex}},                  // LDRSHT<c> <Rt>, [<Rn>], +/-<Rm> cond:4|0|0|0|0|U|0|1|1|Rn:4|Rt:4|0|0|0|0|1|1|1|1|Rm:4
	{0x0f700000, 0x04300000, 4, LDRT_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_imm12_postindex}},                // LDRT<c> <Rt>, [<Rn>] {,#+/-<imm12>} cond:4|0|1|0|0|U|0|1|1|Rn:4|Rt:4|imm12:12
	{0x0f700010, 0x06300000, 4, LDRT_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_R_shift_imm_postindex}},          // LDRT<c> <Rt>,[<Rn>],+/-<Rm>{, <shift>} cond:4|0|1|1|0|U|0|1|1|Rn:4|Rt:4|imm5:5|type:2|0|Rm:4
	{0x0fef0070, 0x01a00000, 2, LSL_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_0, arg_imm5_nz}},                     // LSL{S}<c> <Rd>,<Rm>,#<imm5_nz> cond:4|0|0|0|1|1|0|1|S|0|0|0|0|Rd:4|imm5:5|0|0|0|Rm:4
	{0x0fef00f0, 0x01a00010, 4, LSL_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_0, arg_R_8}},                         // LSL{S}<c> <Rd>,<Rn>,<Rm> cond:4|0|0|0|1|1|0|1|S|0|0|0|0|Rd:4|Rm:4|0|0|0|1|Rn:4
	{0x0fef0070, 0x01a00020, 4, LSR_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_0, arg_imm5_32}},                     // LSR{S}<c> <Rd>,<Rm>,#<imm5_32> cond:4|0|0|0|1|1|0|1|S|0|0|0|0|Rd:4|imm5:5|0|1|0|Rm:4
	{0x0fef00f0, 0x01a00030, 4, LSR_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_0, arg_R_8}},                         // LSR{S}<c> <Rd>,<Rn>,<Rm> cond:4|0|0|0|1|1|0|1|S|0|0|0|0|Rd:4|Rm:4|0|0|1|1|Rn:4
	{0x0fe000f0, 0x00200090, 4, MLA_EQ, 0x14011c04, instArgs{arg_R_16, arg_R_0, arg_R_8, arg_R_12}},               // MLA{S}<c> <Rd>,<Rn>,<Rm>,<Ra> cond:4|0|0|0|0|0|0|1|S|Rd:4|Ra:4|Rm:4|1|0|0|1|Rn:4
	{0x0ff000f0, 0x00600090, 4, MLS_EQ, 0x1c04, instArgs{arg_R_16, arg_R_0, arg_R_8, arg_R_12}},                   // MLS<c> <Rd>,<Rn>,<Rm>,<Ra> cond:4|0|0|0|0|0|1|1|0|Rd:4|Ra:4|Rm:4|1|0|0|1|Rn:4
	{0x0ff00000, 0x03400000, 4, MOVT_EQ, 0x1c04, instArgs{arg_R_12, arg_imm_4at16_12at0}},                         // MOVT<c> <Rd>,#<imm12+4> cond:4|0|0|1|1|0|1|0|0|imm4:4|Rd:4|imm12:12
	{0x0ff00000, 0x03000000, 4, MOVW_EQ, 0x1c04, instArgs{arg_R_12, arg_imm_4at16_12at0}},                         // MOVW<c> <Rd>,#<imm12+4> cond:4|0|0|1|1|0|0|0|0|imm4:4|Rd:4|imm12:12
	{0x0fef0000, 0x03a00000, 2, MOV_EQ, 0x14011c04, instArgs{arg_R_12, arg_const}},                                // MOV{S}<c> <Rd>,#<const> cond:4|0|0|1|1|1|0|1|S|0|0|0|0|Rd:4|imm12:12
	{0x0fef0ff0, 0x01a00000, 2, MOV_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_0}},                                  // MOV{S}<c> <Rd>,<Rm> cond:4|0|0|0|1|1|0|1|S|0|0|0|0|Rd:4|0|0|0|0|0|0|0|0|Rm:4
	{0x0fff0fff, 0x010f0000, 4, MRS_EQ, 0x1c04, instArgs{arg_R_12, arg_APSR}},                                     // MRS<c> <Rd>,APSR cond:4|0|0|0|1|0|0|0|0|(1)|(1)|(1)|(1)|Rd:4|(0)|(0)|(0)|(0)|0|0|0|0|(0)|(0)|(0)|(0)
	{0x0ff000f0, 0x010f0000, 3, MRS_EQ, 0x1c04, instArgs{arg_R_12, arg_APSR}},                                     // MRS<c> <Rd>,APSR cond:4|0|0|0|1|0|0|0|0|(1)|(1)|(1)|(1)|Rd:4|(0)|(0)|(0)|(0)|0|0|0|0|(0)|(0)|(0)|(0)
	{0x0fe0f0f0, 0x00000090, 4, MUL_EQ, 0x14011c04, instArgs{arg_R_16, arg_R_0, arg_R_8}},                         // MUL{S}<c> <Rd>,<Rn>,<Rm> cond:4|0|0|0|0|0|0|0|S|Rd:4|(0)|(0)|(0)|(0)|Rm:4|1|0|0|1|Rn:4
	{0x0fe000f0, 0x00000090, 3, MUL_EQ, 0x14011c04, instArgs{arg_R_16, arg_R_0, arg_R_8}},                         // MUL{S}<c> <Rd>,<Rn>,<Rm> cond:4|0|0|0|0|0|0|0|S|Rd:4|(0)|(0)|(0)|(0)|Rm:4|1|0|0|1|Rn:4
	{0x0fef0000, 0x03e00000, 2, MVN_EQ, 0x14011c04, instArgs{arg_R_12, arg_const}},                                // MVN{S}<c> <Rd>,#<const> cond:4|0|0|1|1|1|1|1|S|(0)|(0)|(0)|(0)|Rd:4|imm12:12
	{0x0fe00000, 0x03e00000, 1, MVN_EQ, 0x14011c04, instArgs{arg_R_12, arg_const}},                                // MVN{S}<c> <Rd>,#<const> cond:4|0|0|1|1|1|1|1|S|(0)|(0)|(0)|(0)|Rd:4|imm12:12
	{0x0fef0090, 0x01e00010, 4, MVN_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_shift_R}},                            // MVN{S}<c> <Rd>,<Rm>,<type> <Rs> cond:4|0|0|0|1|1|1|1|S|(0)|(0)|(0)|(0)|Rd:4|Rs:4|0|type:2|1|Rm:4
	{0x0fe00090, 0x01e00010, 3, MVN_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_shift_R}},                            // MVN{S}<c> <Rd>,<Rm>,<type> <Rs> cond:4|0|0|0|1|1|1|1|S|(0)|(0)|(0)|(0)|Rd:4|Rs:4|0|type:2|1|Rm:4
	{0x0fef0010, 0x01e00000, 2, MVN_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_shift_imm}},                          // MVN{S}<c> <Rd>,<Rm>{,<shift>} cond:4|0|0|0|1|1|1|1|S|(0)|(0)|(0)|(0)|Rd:4|imm5:5|type:2|0|Rm:4
	{0x0fe00010, 0x01e00000, 1, MVN_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_shift_imm}},                          // MVN{S}<c> <Rd>,<Rm>{,<shift>} cond:4|0|0|0|1|1|1|1|S|(0)|(0)|(0)|(0)|Rd:4|imm5:5|type:2|0|Rm:4
	{0x0fffffff, 0x0320f000, 4, NOP_EQ, 0x1c04, instArgs{}},                                                       // NOP<c> cond:4|0|0|1|1|0|0|1|0|0|0|0|0|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|0|0|0|0|0|0|0|0
	{0x0fff00ff, 0x0320f000, 3, NOP_EQ, 0x1c04, instArgs{}},                                                       // NOP<c> cond:4|0|0|1|1|0|0|1|0|0|0|0|0|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|0|0|0|0|0|0|0|0
	{0x0fe00000, 0x03800000, 2, ORR_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_const}},                      // ORR{S}<c> <Rd>,<Rn>,#<const> cond:4|0|0|1|1|1|0|0|S|Rn:4|Rd:4|imm12:12
	{0x0fe00090, 0x01800010, 4, ORR_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_R}},                  // ORR{S}<c> <Rd>,<Rn>,<Rm>,<type> <Rs> cond:4|0|0|0|1|1|0|0|S|Rn:4|Rd:4|Rs:4|0|type:2|1|Rm:4
	{0x0fe00010, 0x01800000, 2, ORR_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_imm}},                // ORR{S}<c> <Rd>,<Rn>,<Rm>{,<shift>} cond:4|0|0|0|1|1|0|0|S|Rn:4|Rd:4|imm5:5|type:2|0|Rm:4
	{0x0ff00030, 0x06800010, 4, PKHBT_EQ, 0x6011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_imm}},               // PKH<BT,TB><c> <Rd>,<Rn>,<Rm>{,LSL #<imm5>} cond:4|0|1|1|0|1|0|0|0|Rn:4|Rd:4|imm5:5|tb|0|1|Rm:4
	{0xff7ff000, 0xf55ff000, 4, PLD, 0x0, instArgs{arg_label_pm_12}},                                              // PLD <label+/-12> 1|1|1|1|0|1|0|1|U|(1)|0|1|1|1|1|1|(1)|(1)|(1)|(1)|imm12:12
	{0xff3f0000, 0xf55ff000, 3, PLD, 0x0, instArgs{arg_label_pm_12}},                                              // PLD <label+/-12> 1|1|1|1|0|1|0|1|U|(1)|0|1|1|1|1|1|(1)|(1)|(1)|(1)|imm12:12
	{0xff30f000, 0xf510f000, 2, PLD_W, 0x1601, instArgs{arg_mem_R_pm_imm12_offset}},                               // PLD{W} [<Rn>,#+/-<imm12>] 1|1|1|1|0|1|0|1|U|R|0|1|Rn:4|(1)|(1)|(1)|(1)|imm12:12
	{0xff300000, 0xf510f000, 1, PLD_W, 0x1601, instArgs{arg_mem_R_pm_imm12_offset}},                               // PLD{W} [<Rn>,#+/-<imm12>] 1|1|1|1|0|1|0|1|U|R|0|1|Rn:4|(1)|(1)|(1)|(1)|imm12:12
	{0xff30f010, 0xf710f000, 4, PLD_W, 0x1601, instArgs{arg_mem_R_pm_R_shift_imm_offset}},                         // PLD{W} [<Rn>,+/-<Rm>{, <shift>}] 1|1|1|1|0|1|1|1|U|R|0|1|Rn:4|(1)|(1)|(1)|(1)|imm5:5|type:2|0|Rm:4
	{0xff300010, 0xf710f000, 3, PLD_W, 0x1601, instArgs{arg_mem_R_pm_R_shift_imm_offset}},                         // PLD{W} [<Rn>,+/-<Rm>{, <shift>}] 1|1|1|1|0|1|1|1|U|R|0|1|Rn:4|(1)|(1)|(1)|(1)|imm5:5|type:2|0|Rm:4
	{0xff70f000, 0xf450f000, 4, PLI, 0x0, instArgs{arg_mem_R_pm_imm12_offset}},                                    // PLI [<Rn>,#+/-<imm12>] 1|1|1|1|0|1|0|0|U|1|0|1|Rn:4|(1)|(1)|(1)|(1)|imm12:12
	{0xff700000, 0xf450f000, 3, PLI, 0x0, instArgs{arg_mem_R_pm_imm12_offset}},                                    // PLI [<Rn>,#+/-<imm12>] 1|1|1|1|0|1|0|0|U|1|0|1|Rn:4|(1)|(1)|(1)|(1)|imm12:12
	{0xff70f010, 0xf650f000, 4, PLI, 0x0, instArgs{arg_mem_R_pm_R_shift_imm_offset}},                              // PLI [<Rn>,+/-<Rm>{, <shift>}] 1|1|1|1|0|1|1|0|U|1|0|1|Rn:4|(1)|(1)|(1)|(1)|imm5:5|type:2|0|Rm:4
	{0xff700010, 0xf650f000, 3, PLI, 0x0, instArgs{arg_mem_R_pm_R_shift_imm_offset}},                              // PLI [<Rn>,+/-<Rm>{, <shift>}] 1|1|1|1|0|1|1|0|U|1|0|1|Rn:4|(1)|(1)|(1)|(1)|imm5:5|type:2|0|Rm:4
	{0x0fff0000, 0x08bd0000, 4, POP_EQ, 0x1c04, instArgs{arg_registers2}},                                         // POP<c> <registers2> cond:4|1|0|0|0|1|0|1|1|1|1|0|1|register_list:16
	{0x0fff0fff, 0x049d0004, 4, POP_EQ, 0x1c04, instArgs{arg_registers1}},                                         // POP<c> <registers1> cond:4|0|1|0|0|1|0|0|1|1|1|0|1|Rt:4|0|0|0|0|0|0|0|0|0|1|0|0
	{0x0fff0000, 0x092d0000, 4, PUSH_EQ, 0x1c04, instArgs{arg_registers2}},                                        // PUSH<c> <registers2> cond:4|1|0|0|1|0|0|1|0|1|1|0|1|register_list:16
	{0x0fff0fff, 0x052d0004, 4, PUSH_EQ, 0x1c04, instArgs{arg_registers1}},                                        // PUSH<c> <registers1> cond:4|0|1|0|1|0|0|1|0|1|1|0|1|Rt:4|0|0|0|0|0|0|0|0|0|1|0|0
	{0x0ff00ff0, 0x06200f10, 4, QADD16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // QADD16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|0|1|Rm:4
	{0x0ff000f0, 0x06200f10, 3, QADD16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // QADD16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|0|1|Rm:4
	{0x0ff00ff0, 0x06200f90, 4, QADD8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // QADD8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|0|0|1|Rm:4
	{0x0ff000f0, 0x06200f90, 3, QADD8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // QADD8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|0|0|1|Rm:4
	{0x0ff00ff0, 0x01000050, 4, QADD_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0, arg_R_16}},                           // QADD<c> <Rd>,<Rm>,<Rn> cond:4|0|0|0|1|0|0|0|0|Rn:4|Rd:4|(0)|(0)|(0)|(0)|0|1|0|1|Rm:4
	{0x0ff000f0, 0x01000050, 3, QADD_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0, arg_R_16}},                           // QADD<c> <Rd>,<Rm>,<Rn> cond:4|0|0|0|1|0|0|0|0|Rn:4|Rd:4|(0)|(0)|(0)|(0)|0|1|0|1|Rm:4
	{0x0ff00ff0, 0x06200f30, 4, QASX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                           // QASX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rm:4
	{0x0ff000f0, 0x06200f30, 3, QASX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                           // QASX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rm:4
	{0x0ff00ff0, 0x01400050, 4, QDADD_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0, arg_R_16}},                          // QDADD<c> <Rd>,<Rm>,<Rn> cond:4|0|0|0|1|0|1|0|0|Rn:4|Rd:4|(0)|(0)|(0)|(0)|0|1|0|1|Rm:4
	{0x0ff000f0, 0x01400050, 3, QDADD_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0, arg_R_16}},                          // QDADD<c> <Rd>,<Rm>,<Rn> cond:4|0|0|0|1|0|1|0|0|Rn:4|Rd:4|(0)|(0)|(0)|(0)|0|1|0|1|Rm:4
	{0x0ff00ff0, 0x01600050, 4, QDSUB_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0, arg_R_16}},                          // QDSUB<c> <Rd>,<Rm>,<Rn> cond:4|0|0|0|1|0|1|1|0|Rn:4|Rd:4|0|0|0|0|0|1|0|1|Rm:4
	{0x0ff00ff0, 0x06200f50, 4, QSAX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                           // QSAX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|0|1|Rm:4
	{0x0ff000f0, 0x06200f50, 3, QSAX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                           // QSAX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|0|1|Rm:4
	{0x0ff00ff0, 0x06200f70, 4, QSUB16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // QSUB16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|1|1|Rm:4
	{0x0ff000f0, 0x06200f70, 3, QSUB16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // QSUB16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|1|1|Rm:4
	{0x0ff00ff0, 0x06200ff0, 4, QSUB8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // QSUB8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|1|1|1|Rm:4
	{0x0ff000f0, 0x06200ff0, 3, QSUB8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // QSUB8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|1|1|1|Rm:4
	{0x0ff00ff0, 0x01200050, 4, QSUB_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0, arg_R_16}},                           // QSUB<c> <Rd>,<Rm>,<Rn> cond:4|0|0|0|1|0|0|1|0|Rn:4|Rd:4|0|0|0|0|0|1|0|1|Rm:4
	{0x0fff0ff0, 0x06ff0f30, 4, RBIT_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0}},                                     // RBIT<c> <Rd>,<Rm> cond:4|0|1|1|0|1|1|1|1|(1)|(1)|(1)|(1)|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rm:4
	{0x0ff000f0, 0x06ff0f30, 3, RBIT_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0}},                                     // RBIT<c> <Rd>,<Rm> cond:4|0|1|1|0|1|1|1|1|(1)|(1)|(1)|(1)|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rm:4
	{0x0fff0ff0, 0x06bf0fb0, 4, REV16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0}},                                    // REV16<c> <Rd>,<Rm> cond:4|0|1|1|0|1|0|1|1|(1)|(1)|(1)|(1)|Rd:4|(1)|(1)|(1)|(1)|1|0|1|1|Rm:4
	{0x0ff000f0, 0x06bf0fb0, 3, REV16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0}},                                    // REV16<c> <Rd>,<Rm> cond:4|0|1|1|0|1|0|1|1|(1)|(1)|(1)|(1)|Rd:4|(1)|(1)|(1)|(1)|1|0|1|1|Rm:4
	{0x0fff0ff0, 0x06bf0f30, 4, REV_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0}},                                      // REV<c> <Rd>,<Rm> cond:4|0|1|1|0|1|0|1|1|(1)|(1)|(1)|(1)|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rm:4
	{0x0ff000f0, 0x06bf0f30, 3, REV_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0}},                                      // REV<c> <Rd>,<Rm> cond:4|0|1|1|0|1|0|1|1|(1)|(1)|(1)|(1)|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rm:4
	{0x0fff0ff0, 0x06ff0fb0, 4, REVSH_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0}},                                    // REVSH<c> <Rd>,<Rm> cond:4|0|1|1|0|1|1|1|1|(1)|(1)|(1)|(1)|Rd:4|(1)|(1)|(1)|(1)|1|0|1|1|Rm:4
	{0x0ff000f0, 0x06ff0fb0, 3, REVSH_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0}},                                    // REVSH<c> <Rd>,<Rm> cond:4|0|1|1|0|1|1|1|1|(1)|(1)|(1)|(1)|Rd:4|(1)|(1)|(1)|(1)|1|0|1|1|Rm:4
	{0x0fef0070, 0x01a00060, 2, ROR_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_0, arg_imm5}},                        // ROR{S}<c> <Rd>,<Rm>,#<imm5> cond:4|0|0|0|1|1|0|1|S|0|0|0|0|Rd:4|imm5:5|1|1|0|Rm:4
	{0x0fef00f0, 0x01a00070, 4, ROR_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_0, arg_R_8}},                         // ROR{S}<c> <Rd>,<Rn>,<Rm> cond:4|0|0|0|1|1|0|1|S|0|0|0|0|Rd:4|Rm:4|0|1|1|1|Rn:4
	{0x0fef0ff0, 0x01a00060, 4, RRX_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_0}},                                  // RRX{S}<c> <Rd>,<Rm> cond:4|0|0|0|1|1|0|1|S|0|0|0|0|Rd:4|0|0|0|0|0|1|1|0|Rm:4
	{0x0fe00000, 0x02600000, 2, RSB_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_const}},                      // RSB{S}<c> <Rd>,<Rn>,#<const> cond:4|0|0|1|0|0|1|1|S|Rn:4|Rd:4|imm12:12
	{0x0fe00090, 0x00600010, 4, RSB_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_R}},                  // RSB{S}<c> <Rd>,<Rn>,<Rm>,<type> <Rs> cond:4|0|0|0|0|0|1|1|S|Rn:4|Rd:4|Rs:4|0|type:2|1|Rm:4
	{0x0fe00010, 0x00600000, 2, RSB_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_imm}},                // RSB{S}<c> <Rd>,<Rn>,<Rm>{,<shift>} cond:4|0|0|0|0|0|1|1|S|Rn:4|Rd:4|imm5:5|type:2|0|Rm:4
	{0x0fe00000, 0x02e00000, 2, RSC_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_const}},                      // RSC{S}<c> <Rd>,<Rn>,#<const> cond:4|0|0|1|0|1|1|1|S|Rn:4|Rd:4|imm12:12
	{0x0fe00090, 0x00e00010, 4, RSC_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_R}},                  // RSC{S}<c> <Rd>,<Rn>,<Rm>,<type> <Rs> cond:4|0|0|0|0|1|1|1|S|Rn:4|Rd:4|Rs:4|0|type:2|1|Rm:4
	{0x0fe00010, 0x00e00000, 2, RSC_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_imm}},                // RSC{S}<c> <Rd>,<Rn>,<Rm>{,<shift>} cond:4|0|0|0|0|1|1|1|S|Rn:4|Rd:4|imm5:5|type:2|0|Rm:4
	{0x0ff00ff0, 0x06100f10, 4, SADD16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // SADD16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|0|1|Rm:4
	{0x0ff000f0, 0x06100f10, 3, SADD16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // SADD16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|0|1|Rm:4
	{0x0ff00ff0, 0x06100f90, 4, SADD8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // SADD8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|0|0|1|Rm:4
	{0x0ff000f0, 0x06100f90, 3, SADD8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // SADD8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|0|0|1|Rm:4
	{0x0ff00ff0, 0x06100f30, 4, SASX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                           // SASX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rm:4
	{0x0ff000f0, 0x06100f30, 3, SASX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                           // SASX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rm:4
	{0x0fe00000, 0x02c00000, 2, SBC_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_const}},                      // SBC{S}<c> <Rd>,<Rn>,#<const> cond:4|0|0|1|0|1|1|0|S|Rn:4|Rd:4|imm12:12
	{0x0fe00090, 0x00c00010, 4, SBC_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_R}},                  // SBC{S}<c> <Rd>,<Rn>,<Rm>,<type> <Rs> cond:4|0|0|0|0|1|1|0|S|Rn:4|Rd:4|Rs:4|0|type:2|1|Rm:4
	{0x0fe00010, 0x00c00000, 2, SBC_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_imm}},                // SBC{S}<c> <Rd>,<Rn>,<Rm>{,<shift>} cond:4|0|0|0|0|1|1|0|S|Rn:4|Rd:4|imm5:5|type:2|0|Rm:4
	{0x0fe00070, 0x07a00050, 4, SBFX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0, arg_imm5, arg_widthm1}},              // SBFX<c> <Rd>,<Rn>,#<lsb>,#<widthm1> cond:4|0|1|1|1|1|0|1|widthm1:5|Rd:4|lsb:5|1|0|1|Rn:4
	{0x0ff00ff0, 0x06800fb0, 4, SEL_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                            // SEL<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|1|0|0|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|0|1|1|Rm:4
	{0x0ff000f0, 0x06800fb0, 3, SEL_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                            // SEL<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|1|0|0|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|0|1|1|Rm:4
	{0xfffffdff, 0xf1010000, 4, SETEND, 0x0, instArgs{arg_endian}},                                                // SETEND <endian_specifier> 1|1|1|1|0|0|0|1|0|0|0|0|0|0|0|1|0|0|0|0|0|0|E|(0)|(0)|(0)|(0)|(0)|(0)|(0)|(0)|(0)
	{0xfffffc00, 0xf1010000, 3, SETEND, 0x0, instArgs{arg_endian}},                                                // SETEND <endian_specifier> 1|1|1|1|0|0|0|1|0|0|0|0|0|0|0|1|0|0|0|0|0|0|E|(0)|(0)|(0)|(0)|(0)|(0)|(0)|(0)|(0)
	{0x0fffffff, 0x0320f004, 4, SEV_EQ, 0x1c04, instArgs{}},                                                       // SEV<c> cond:4|0|0|1|1|0|0|1|0|0|0|0|0|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|0|0|0|0|0|1|0|0
	{0x0fff00ff, 0x0320f004, 3, SEV_EQ, 0x1c04, instArgs{}},                                                       // SEV<c> cond:4|0|0|1|1|0|0|1|0|0|0|0|0|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|0|0|0|0|0|1|0|0
	{0x0ff00ff0, 0x06300f10, 4, SHADD16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                        // SHADD16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|0|1|Rm:4
	{0x0ff000f0, 0x06300f10, 3, SHADD16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                        // SHADD16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|0|1|Rm:4
	{0x0ff00ff0, 0x06300f90, 4, SHADD8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // SHADD8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|0|0|1|Rm:4
	{0x0ff000f0, 0x06300f90, 3, SHADD8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // SHADD8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|0|0|1|Rm:4
	{0x0ff00ff0, 0x06300f30, 4, SHASX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // SHASX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rm:4
	{0x0ff000f0, 0x06300f30, 3, SHASX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // SHASX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rm:4
	{0x0ff00ff0, 0x06300f50, 4, SHSAX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // SHSAX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|0|1|Rm:4
	{0x0ff000f0, 0x06300f50, 3, SHSAX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // SHSAX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|0|1|Rm:4
	{0x0ff00ff0, 0x06300f70, 4, SHSUB16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                        // SHSUB16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|1|1|Rm:4
	{0x0ff000f0, 0x06300f70, 3, SHSUB16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                        // SHSUB16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|1|1|Rm:4
	{0x0ff00ff0, 0x06300ff0, 4, SHSUB8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // SHSUB8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|1|1|1|Rm:4
	{0x0ff000f0, 0x06300ff0, 3, SHSUB8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // SHSUB8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|1|1|1|Rm:4
	{0x0ff00090, 0x01000080, 4, SMLABB_EQ, 0x50106011c04, instArgs{arg_R_16, arg_R_0, arg_R_8, arg_R_12}},         // SMLA<x><y><c> <Rd>,<Rn>,<Rm>,<Ra> cond:4|0|0|0|1|0|0|0|0|Rd:4|Ra:4|Rm:4|1|M|N|0|Rn:4
	{0x0ff000d0, 0x07000010, 2, SMLAD_EQ, 0x5011c04, instArgs{arg_R_16, arg_R_0, arg_R_8, arg_R_12}},              // SMLAD{X}<c> <Rd>,<Rn>,<Rm>,<Ra> cond:4|0|1|1|1|0|0|0|0|Rd:4|Ra:4|Rm:4|0|0|M|1|Rn:4
	{0x0ff00090, 0x01400080, 4, SMLALBB_EQ, 0x50106011c04, instArgs{arg_R_12, arg_R_16, arg_R_0, arg_R_8}},        // SMLAL<x><y><c> <RdLo>,<RdHi>,<Rn>,<Rm> cond:4|0|0|0|1|0|1|0|0|RdHi:4|RdLo:4|Rm:4|1|M|N|0|Rn:4
	{0x0ff000d0, 0x07400010, 4, SMLALD_EQ, 0x5011c04, instArgs{arg_R_12, arg_R_16, arg_R_0, arg_R_8}},             // SMLALD{X}<c> <RdLo>,<RdHi>,<Rn>,<Rm> cond:4|0|1|1|1|0|1|0|0|RdHi:4|RdLo:4|Rm:4|0|0|M|1|Rn:4
	{0x0fe000f0, 0x00e00090, 4, SMLAL_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_0, arg_R_8}},             // SMLAL{S}<c> <RdLo>,<RdHi>,<Rn>,<Rm> cond:4|0|0|0|0|1|1|1|S|RdHi:4|RdLo:4|Rm:4|1|0|0|1|Rn:4
	{0x0ff000b0, 0x01200080, 4, SMLAWB_EQ, 0x6011c04, instArgs{arg_R_16, arg_R_0, arg_R_8, arg_R_12}},             // SMLAW<y><c> <Rd>,<Rn>,<Rm>,<Ra> cond:4|0|0|0|1|0|0|1|0|Rd:4|Ra:4|Rm:4|1|M|0|0|Rn:4
	{0x0ff000d0, 0x07000050, 2, SMLSD_EQ, 0x5011c04, instArgs{arg_R_16, arg_R_0, arg_R_8, arg_R_12}},              // SMLSD{X}<c> <Rd>,<Rn>,<Rm>,<Ra> cond:4|0|1|1|1|0|0|0|0|Rd:4|Ra:4|Rm:4|0|1|M|1|Rn:4
	{0x0ff000d0, 0x07400050, 4, SMLSLD_EQ, 0x5011c04, instArgs{arg_R_12, arg_R_16, arg_R_0, arg_R_8}},             // SMLSLD{X}<c> <RdLo>,<RdHi>,<Rn>,<Rm> cond:4|0|1|1|1|0|1|0|0|RdHi:4|RdLo:4|Rm:4|0|1|M|1|Rn:4
	{0x0ff000d0, 0x07500010, 2, SMMLA_EQ, 0x5011c04, instArgs{arg_R_16, arg_R_0, arg_R_8, arg_R_12}},              // SMMLA{R}<c> <Rd>,<Rn>,<Rm>,<Ra> cond:4|0|1|1|1|0|1|0|1|Rd:4|Ra:4|Rm:4|0|0|R|1|Rn:4
	{0x0ff000d0, 0x075000d0, 4, SMMLS_EQ, 0x5011c04, instArgs{arg_R_16, arg_R_0, arg_R_8, arg_R_12}},              // SMMLS{R}<c> <Rd>,<Rn>,<Rm>,<Ra> cond:4|0|1|1|1|0|1|0|1|Rd:4|Ra:4|Rm:4|1|1|R|1|Rn:4
	{0x0ff0f0d0, 0x0750f010, 4, SMMUL_EQ, 0x5011c04, instArgs{arg_R_16, arg_R_0, arg_R_8}},                        // SMMUL{R}<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|1|0|1|0|1|Rd:4|1|1|1|1|Rm:4|0|0|R|1|Rn:4
	{0x0ff0f0d0, 0x0700f010, 4, SMUAD_EQ, 0x5011c04, instArgs{arg_R_16, arg_R_0, arg_R_8}},                        // SMUAD{X}<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|1|0|0|0|0|Rd:4|1|1|1|1|Rm:4|0|0|M|1|Rn:4
	{0x0ff0f090, 0x01600080, 4, SMULBB_EQ, 0x50106011c04, instArgs{arg_R_16, arg_R_0, arg_R_8}},                   // SMUL<x><y><c> <Rd>,<Rn>,<Rm> cond:4|0|0|0|1|0|1|1|0|Rd:4|0|0|0|0|Rm:4|1|M|N|0|Rn:4
	{0x0fe000f0, 0x00c00090, 4, SMULL_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_0, arg_R_8}},             // SMULL{S}<c> <RdLo>,<RdHi>,<Rn>,<Rm> cond:4|0|0|0|0|1|1|0|S|RdHi:4|RdLo:4|Rm:4|1|0|0|1|Rn:4
	{0x0ff0f0b0, 0x012000a0, 4, SMULWB_EQ, 0x6011c04, instArgs{arg_R_16, arg_R_0, arg_R_8}},                       // SMULW<y><c> <Rd>,<Rn>,<Rm> cond:4|0|0|0|1|0|0|1|0|Rd:4|0|0|0|0|Rm:4|1|M|1|0|Rn:4
	{0x0ff0f0d0, 0x0700f050, 4, SMUSD_EQ, 0x5011c04, instArgs{arg_R_16, arg_R_0, arg_R_8}},                        // SMUSD{X}<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|1|0|0|0|0|Rd:4|1|1|1|1|Rm:4|0|1|M|1|Rn:4
	{0x0ff00ff0, 0x06a00f30, 4, SSAT16_EQ, 0x1c04, instArgs{arg_R_12, arg_satimm4m1, arg_R_0}},                    // SSAT16<c> <Rd>,#<sat_imm4m1>,<Rn> cond:4|0|1|1|0|1|0|1|0|sat_imm:4|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rn:4
	{0x0ff000f0, 0x06a00f30, 3, SSAT16_EQ, 0x1c04, instArgs{arg_R_12, arg_satimm4m1, arg_R_0}},                    // SSAT16<c> <Rd>,#<sat_imm4m1>,<Rn> cond:4|0|1|1|0|1|0|1|0|sat_imm:4|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rn:4
	{0x0fe00030, 0x06a00010, 4, SSAT_EQ, 0x1c04, instArgs{arg_R_12, arg_satimm5m1, arg_R_shift_imm}},              // SSAT<c> <Rd>,#<sat_imm5m1>,<Rn>{,<shift>} cond:4|0|1|1|0|1|0|1|sat_imm:5|Rd:4|imm5:5|sh|0|1|Rn:4
	{0x0ff00ff0, 0x06100f50, 4, SSAX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                           // SSAX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|0|1|Rm:4
	{0x0ff000f0, 0x06100f50, 3, SSAX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                           // SSAX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|0|1|Rm:4
	{0x0ff00ff0, 0x06100f70, 4, SSUB16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // SSUB16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|1|1|Rm:4
	{0x0ff000f0, 0x06100f70, 3, SSUB16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // SSUB16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|1|1|Rm:4
	{0x0ff00ff0, 0x06100ff0, 4, SSUB8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // SSUB8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|1|1|1|Rm:4
	{0x0ff000f0, 0x06100ff0, 3, SSUB8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // SSUB8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|0|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|1|1|1|Rm:4
	{0x0fd00000, 0x08800000, 4, STM_EQ, 0x1c04, instArgs{arg_R_16_WB, arg_registers}},                             // STM<c> <Rn>{!},<registers> cond:4|1|0|0|0|1|0|W|0|Rn:4|register_list:16
	{0x0fd00000, 0x08000000, 4, STMDA_EQ, 0x1c04, instArgs{arg_R_16_WB, arg_registers}},                           // STMDA<c> <Rn>{!},<registers> cond:4|1|0|0|0|0|0|W|0|Rn:4|register_list:16
	{0x0fd00000, 0x09000000, 2, STMDB_EQ, 0x1c04, instArgs{arg_R_16_WB, arg_registers}},                           // STMDB<c> <Rn>{!},<registers> cond:4|1|0|0|1|0|0|W|0|Rn:4|register_list:16
	{0x0fd00000, 0x09800000, 4, STMIB_EQ, 0x1c04, instArgs{arg_R_16_WB, arg_registers}},                           // STMIB<c> <Rn>{!},<registers> cond:4|1|0|0|1|1|0|W|0|Rn:4|register_list:16
	{0x0e500018, 0x06000000, 2, STR_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_R_shift_imm_W}},                   // STR<c> <Rt>,[<Rn>,+/-<Rm>{, <shift>}]{!} cond:4|0|1|1|P|U|0|W|0|Rn:4|Rt:4|imm5:5|type:2|0|Rm:4
	{0x0e500000, 0x04000000, 2, STR_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_imm12_W}},                         // STR<c> <Rt>,[<Rn>{,#+/-<imm12>}]{!} cond:4|0|1|0|P|U|0|W|0|Rn:4|Rt:4|imm12:12
	{0x0e500010, 0x06400000, 2, STRB_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_R_shift_imm_W}},                  // STRB<c> <Rt>,[<Rn>,+/-<Rm>{, <shift>}]{!} cond:4|0|1|1|P|U|1|W|0|Rn:4|Rt:4|imm5:5|type:2|0|Rm:4
	{0x0e500000, 0x04400000, 2, STRB_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_imm12_W}},                        // STRB<c> <Rt>,[<Rn>{,#+/-<imm12>}]{!} cond:4|0|1|0|P|U|1|W|0|Rn:4|Rt:4|imm12:12
	{0x0f700000, 0x04600000, 4, STRBT_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_imm12_postindex}},               // STRBT<c> <Rt>,[<Rn>],#+/-<imm12> cond:4|0|1|0|0|U|1|1|0|Rn:4|Rt:4|imm12:12
	{0x0f700010, 0x06600000, 4, STRBT_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_R_shift_imm_postindex}},         // STRBT<c> <Rt>,[<Rn>],+/-<Rm>{, <shift>} cond:4|0|1|1|0|U|1|1|0|Rn:4|Rt:4|imm5:5|type:2|0|Rm:4
	{0x0e500ff0, 0x000000f0, 4, STRD_EQ, 0x1c04, instArgs{arg_R1_12, arg_R2_12, arg_mem_R_pm_R_W}},                // STRD<c> <Rt1>,<Rt2>,[<Rn>,+/-<Rm>]{!} cond:4|0|0|0|P|U|0|W|0|Rn:4|Rt:4|(0)|(0)|(0)|(0)|1|1|1|1|Rm:4
	{0x0e5000f0, 0x000000f0, 3, STRD_EQ, 0x1c04, instArgs{arg_R1_12, arg_R2_12, arg_mem_R_pm_R_W}},                // STRD<c> <Rt1>,<Rt2>,[<Rn>,+/-<Rm>]{!} cond:4|0|0|0|P|U|0|W|0|Rn:4|Rt:4|(0)|(0)|(0)|(0)|1|1|1|1|Rm:4
	{0x0e5000f0, 0x004000f0, 4, STRD_EQ, 0x1c04, instArgs{arg_R1_12, arg_R2_12, arg_mem_R_pm_imm8_W}},             // STRD<c> <Rt1>,<Rt2>,[<Rn>{,#+/-<imm8>}]{!} cond:4|0|0|0|P|U|1|W|0|Rn:4|Rt:4|imm4H:4|1|1|1|1|imm4L:4
	{0x0ff00ff0, 0x01800f90, 4, STREX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0, arg_mem_R}},                         // STREX<c> <Rd>,<Rt>,[<Rn>] cond:4|0|0|0|1|1|0|0|0|Rn:4|Rd:4|1|1|1|1|1|0|0|1|Rt:4
	{0x0ff00ff0, 0x01c00f90, 4, STREXB_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0, arg_mem_R}},                        // STREXB<c> <Rd>,<Rt>,[<Rn>] cond:4|0|0|0|1|1|1|0|0|Rn:4|Rd:4|1|1|1|1|1|0|0|1|Rt:4
	{0x0ff00ff0, 0x01a00f90, 4, STREXD_EQ, 0x1c04, instArgs{arg_R_12, arg_R1_0, arg_R2_0, arg_mem_R}},             // STREXD<c> <Rd>,<Rt1>,<Rt2>,[<Rn>] cond:4|0|0|0|1|1|0|1|0|Rn:4|Rd:4|1|1|1|1|1|0|0|1|Rt:4
	{0x0ff00ff0, 0x01e00f90, 4, STREXH_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0, arg_mem_R}},                        // STREXH<c> <Rd>,<Rt>,[<Rn>] cond:4|0|0|0|1|1|1|1|0|Rn:4|Rd:4|1|1|1|1|1|0|0|1|Rt:4
	{0x0e500ff0, 0x000000b0, 2, STRH_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_R_W}},                            // STRH<c> <Rt>,[<Rn>,+/-<Rm>]{!} cond:4|0|0|0|P|U|0|W|0|Rn:4|Rt:4|0|0|0|0|1|0|1|1|Rm:4
	{0x0e5000f0, 0x004000b0, 2, STRH_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_imm8_W}},                         // STRH<c> <Rt>,[<Rn>{,#+/-<imm8>}]{!} cond:4|0|0|0|P|U|1|W|0|Rn:4|Rt:4|imm4H:4|1|0|1|1|imm4L:4
	{0x0f7000f0, 0x006000b0, 4, STRHT_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_imm8_postindex}},                // STRHT<c> <Rt>, [<Rn>] {,#+/-<imm8>} cond:4|0|0|0|0|U|1|1|0|Rn:4|Rt:4|imm4H:4|1|0|1|1|imm4L:4
	{0x0f700ff0, 0x002000b0, 4, STRHT_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_R_postindex}},                   // STRHT<c> <Rt>, [<Rn>], +/-<Rm> cond:4|0|0|0|0|U|0|1|0|Rn:4|Rt:4|0|0|0|0|1|0|1|1|Rm:4
	{0x0f700000, 0x04200000, 4, STRT_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_imm12_postindex}},                // STRT<c> <Rt>, [<Rn>] {,#+/-<imm12>} cond:4|0|1|0|0|U|0|1|0|Rn:4|Rt:4|imm12:12
	{0x0f700010, 0x06200000, 4, STRT_EQ, 0x1c04, instArgs{arg_R_12, arg_mem_R_pm_R_shift_imm_postindex}},          // STRT<c> <Rt>,[<Rn>],+/-<Rm>{, <shift>} cond:4|0|1|1|0|U|0|1|0|Rn:4|Rt:4|imm5:5|type:2|0|Rm:4
	{0x0fe00000, 0x02400000, 2, SUB_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_const}},                      // SUB{S}<c> <Rd>,<Rn>,#<const> cond:4|0|0|1|0|0|1|0|S|Rn:4|Rd:4|imm12:12
	{0x0fe00090, 0x00400010, 4, SUB_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_R}},                  // SUB{S}<c> <Rd>,<Rn>,<Rm>,<type> <Rs> cond:4|0|0|0|0|0|1|0|S|Rn:4|Rd:4|Rs:4|0|type:2|1|Rm:4
	{0x0fe00010, 0x00400000, 2, SUB_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_shift_imm}},                // SUB{S}<c> <Rd>,<Rn>,<Rm>{,<shift>} cond:4|0|0|0|0|0|1|0|S|Rn:4|Rd:4|imm5:5|type:2|0|Rm:4
	{0x0fef0000, 0x024d0000, 2, SUB_EQ, 0x14011c04, instArgs{arg_R_12, arg_SP, arg_const}},                        // SUB{S}<c> <Rd>,SP,#<const> cond:4|0|0|1|0|0|1|0|S|1|1|0|1|Rd:4|imm12:12
	{0x0fef0010, 0x004d0000, 2, SUB_EQ, 0x14011c04, instArgs{arg_R_12, arg_SP, arg_R_shift_imm}},                  // SUB{S}<c> <Rd>,SP,<Rm>{,<shift>} cond:4|0|0|0|0|0|1|0|S|1|1|0|1|Rd:4|imm5:5|type:2|0|Rm:4
	{0x0f000000, 0x0f000000, 4, SVC_EQ, 0x1c04, instArgs{arg_imm24}},                                              // SVC<c> #<imm24> cond:4|1|1|1|1|imm24:24
	{0x0fb00ff0, 0x01000090, 4, SWP_EQ, 0x16011c04, instArgs{arg_R_12, arg_R_0, arg_mem_R}},                       // SWP{B}<c> <Rt>,<Rm>,[<Rn>] cond:4|0|0|0|1|0|B|0|0|Rn:4|Rt:4|0|0|0|0|1|0|0|1|Rm:4
	{0x0ff003f0, 0x06800070, 2, SXTAB16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_rotate}},                   // SXTAB16<c> <Rd>,<Rn>,<Rm>{,<rotation>} cond:4|0|1|1|0|1|0|0|0|Rn:4|Rd:4|rotate:2|0|0|0|1|1|1|Rm:4
	{0x0ff003f0, 0x06a00070, 2, SXTAB_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_rotate}},                     // SXTAB<c> <Rd>,<Rn>,<Rm>{,<rotation>} cond:4|0|1|1|0|1|0|1|0|Rn:4|Rd:4|rotate:2|0|0|0|1|1|1|Rm:4
	{0x0ff003f0, 0x06b00070, 2, SXTAH_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_rotate}},                     // SXTAH<c> <Rd>,<Rn>,<Rm>{,<rotation>} cond:4|0|1|1|0|1|0|1|1|Rn:4|Rd:4|rotate:2|0|0|0|1|1|1|Rm:4
	{0x0fff03f0, 0x068f0070, 4, SXTB16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_rotate}},                              // SXTB16<c> <Rd>,<Rm>{,<rotation>} cond:4|0|1|1|0|1|0|0|0|1|1|1|1|Rd:4|rotate:2|0|0|0|1|1|1|Rm:4
	{0x0fff03f0, 0x06af0070, 4, SXTB_EQ, 0x1c04, instArgs{arg_R_12, arg_R_rotate}},                                // SXTB<c> <Rd>,<Rm>{,<rotation>} cond:4|0|1|1|0|1|0|1|0|1|1|1|1|Rd:4|rotate:2|0|0|0|1|1|1|Rm:4
	{0x0fff03f0, 0x06bf0070, 4, SXTH_EQ, 0x1c04, instArgs{arg_R_12, arg_R_rotate}},                                // SXTH<c> <Rd>,<Rm>{,<rotation>} cond:4|0|1|1|0|1|0|1|1|1|1|1|1|Rd:4|rotate:2|0|0|0|1|1|1|Rm:4
	{0x0ff0f000, 0x03300000, 4, TEQ_EQ, 0x1c04, instArgs{arg_R_16, arg_const}},                                    // TEQ<c> <Rn>,#<const> cond:4|0|0|1|1|0|0|1|1|Rn:4|(0)|(0)|(0)|(0)|imm12:12
	{0x0ff00000, 0x03300000, 3, TEQ_EQ, 0x1c04, instArgs{arg_R_16, arg_const}},                                    // TEQ<c> <Rn>,#<const> cond:4|0|0|1|1|0|0|1|1|Rn:4|(0)|(0)|(0)|(0)|imm12:12
	{0x0ff0f090, 0x01300010, 4, TEQ_EQ, 0x1c04, instArgs{arg_R_16, arg_R_shift_R}},                                // TEQ<c> <Rn>,<Rm>,<type> <Rs> cond:4|0|0|0|1|0|0|1|1|Rn:4|(0)|(0)|(0)|(0)|Rs:4|0|type:2|1|Rm:4
	{0x0ff00090, 0x01300010, 3, TEQ_EQ, 0x1c04, instArgs{arg_R_16, arg_R_shift_R}},                                // TEQ<c> <Rn>,<Rm>,<type> <Rs> cond:4|0|0|0|1|0|0|1|1|Rn:4|(0)|(0)|(0)|(0)|Rs:4|0|type:2|1|Rm:4
	{0x0ff0f010, 0x01300000, 4, TEQ_EQ, 0x1c04, instArgs{arg_R_16, arg_R_shift_imm}},                              // TEQ<c> <Rn>,<Rm>{,<shift>} cond:4|0|0|0|1|0|0|1|1|Rn:4|(0)|(0)|(0)|(0)|imm5:5|type:2|0|Rm:4
	{0x0ff00010, 0x01300000, 3, TEQ_EQ, 0x1c04, instArgs{arg_R_16, arg_R_shift_imm}},                              // TEQ<c> <Rn>,<Rm>{,<shift>} cond:4|0|0|0|1|0|0|1|1|Rn:4|(0)|(0)|(0)|(0)|imm5:5|type:2|0|Rm:4
	{0x0ff0f000, 0x03100000, 4, TST_EQ, 0x1c04, instArgs{arg_R_16, arg_const}},                                    // TST<c> <Rn>,#<const> cond:4|0|0|1|1|0|0|0|1|Rn:4|(0)|(0)|(0)|(0)|imm12:12
	{0x0ff00000, 0x03100000, 3, TST_EQ, 0x1c04, instArgs{arg_R_16, arg_const}},                                    // TST<c> <Rn>,#<const> cond:4|0|0|1|1|0|0|0|1|Rn:4|(0)|(0)|(0)|(0)|imm12:12
	{0x0ff0f090, 0x01100010, 4, TST_EQ, 0x1c04, instArgs{arg_R_16, arg_R_shift_R}},                                // TST<c> <Rn>,<Rm>,<type> <Rs> cond:4|0|0|0|1|0|0|0|1|Rn:4|(0)|(0)|(0)|(0)|Rs:4|0|type:2|1|Rm:4
	{0x0ff00090, 0x01100010, 3, TST_EQ, 0x1c04, instArgs{arg_R_16, arg_R_shift_R}},                                // TST<c> <Rn>,<Rm>,<type> <Rs> cond:4|0|0|0|1|0|0|0|1|Rn:4|(0)|(0)|(0)|(0)|Rs:4|0|type:2|1|Rm:4
	{0x0ff0f010, 0x01100000, 4, TST_EQ, 0x1c04, instArgs{arg_R_16, arg_R_shift_imm}},                              // TST<c> <Rn>,<Rm>{,<shift>} cond:4|0|0|0|1|0|0|0|1|Rn:4|(0)|(0)|(0)|(0)|imm5:5|type:2|0|Rm:4
	{0x0ff00010, 0x01100000, 3, TST_EQ, 0x1c04, instArgs{arg_R_16, arg_R_shift_imm}},                              // TST<c> <Rn>,<Rm>{,<shift>} cond:4|0|0|0|1|0|0|0|1|Rn:4|(0)|(0)|(0)|(0)|imm5:5|type:2|0|Rm:4
	{0x0ff00ff0, 0x06500f10, 4, UADD16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // UADD16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|0|1|Rm:4
	{0x0ff000f0, 0x06500f10, 3, UADD16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // UADD16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|0|1|Rm:4
	{0x0ff00ff0, 0x06500f90, 4, UADD8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // UADD8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|0|0|1|Rm:4
	{0x0ff000f0, 0x06500f90, 3, UADD8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // UADD8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|0|0|1|Rm:4
	{0x0ff00ff0, 0x06500f30, 4, UASX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                           // UASX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rm:4
	{0x0ff000f0, 0x06500f30, 3, UASX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                           // UASX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rm:4
	{0x0fe00070, 0x07e00050, 4, UBFX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_0, arg_imm5, arg_widthm1}},              // UBFX<c> <Rd>,<Rn>,#<lsb>,#<widthm1> cond:4|0|1|1|1|1|1|1|widthm1:5|Rd:4|lsb:5|1|0|1|Rn:4
	{0x0ff00ff0, 0x06700f10, 4, UHADD16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                        // UHADD16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|0|1|Rm:4
	{0x0ff000f0, 0x06700f10, 3, UHADD16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                        // UHADD16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|0|1|Rm:4
	{0x0ff00ff0, 0x06700f90, 4, UHADD8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // UHADD8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|0|0|1|Rm:4
	{0x0ff000f0, 0x06700f90, 3, UHADD8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // UHADD8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|0|0|1|Rm:4
	{0x0ff00ff0, 0x06700f30, 4, UHASX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // UHASX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rm:4
	{0x0ff000f0, 0x06700f30, 3, UHASX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // UHASX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rm:4
	{0x0ff00ff0, 0x06700f50, 4, UHSAX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // UHSAX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|0|1|Rm:4
	{0x0ff000f0, 0x06700f50, 3, UHSAX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // UHSAX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|0|1|Rm:4
	{0x0ff00ff0, 0x06700f70, 4, UHSUB16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                        // UHSUB16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|1|1|Rm:4
	{0x0ff000f0, 0x06700f70, 3, UHSUB16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                        // UHSUB16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|1|1|Rm:4
	{0x0ff00ff0, 0x06700ff0, 4, UHSUB8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // UHSUB8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|1|1|1|Rm:4
	{0x0ff000f0, 0x06700ff0, 3, UHSUB8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // UHSUB8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|1|1|1|Rm:4
	{0x0ff000f0, 0x00400090, 4, UMAAL_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0, arg_R_8}},                 // UMAAL<c> <RdLo>,<RdHi>,<Rn>,<Rm> cond:4|0|0|0|0|0|1|0|0|RdHi:4|RdLo:4|Rm:4|1|0|0|1|Rn:4
	{0x0fe000f0, 0x00a00090, 4, UMLAL_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_0, arg_R_8}},             // UMLAL{S}<c> <RdLo>,<RdHi>,<Rn>,<Rm> cond:4|0|0|0|0|1|0|1|S|RdHi:4|RdLo:4|Rm:4|1|0|0|1|Rn:4
	{0x0fe000f0, 0x00800090, 4, UMULL_EQ, 0x14011c04, instArgs{arg_R_12, arg_R_16, arg_R_0, arg_R_8}},             // UMULL{S}<c> <RdLo>,<RdHi>,<Rn>,<Rm> cond:4|0|0|0|0|1|0|0|S|RdHi:4|RdLo:4|Rm:4|1|0|0|1|Rn:4
	{0x0ff00ff0, 0x06600f10, 4, UQADD16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                        // UQADD16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|0|1|Rm:4
	{0x0ff000f0, 0x06600f10, 3, UQADD16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                        // UQADD16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|0|1|Rm:4
	{0x0ff00ff0, 0x06600f90, 4, UQADD8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // UQADD8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|0|0|1|Rm:4
	{0x0ff000f0, 0x06600f90, 3, UQADD8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // UQADD8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|0|0|1|Rm:4
	{0x0ff00ff0, 0x06600f30, 4, UQASX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // UQASX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rm:4
	{0x0ff000f0, 0x06600f30, 3, UQASX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // UQASX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rm:4
	{0x0ff00ff0, 0x06600f50, 4, UQSAX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // UQSAX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|0|1|Rm:4
	{0x0ff000f0, 0x06600f50, 3, UQSAX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // UQSAX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|0|1|Rm:4
	{0x0ff00ff0, 0x06600f70, 4, UQSUB16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                        // UQSUB16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|1|1|Rm:4
	{0x0ff000f0, 0x06600f70, 3, UQSUB16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                        // UQSUB16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|1|1|Rm:4
	{0x0ff00ff0, 0x06600ff0, 4, UQSUB8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // UQSUB8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|1|1|1|Rm:4
	{0x0ff000f0, 0x06600ff0, 3, UQSUB8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // UQSUB8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|1|0|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|1|1|1|Rm:4
	{0x0ff0f0f0, 0x0780f010, 4, USAD8_EQ, 0x1c04, instArgs{arg_R_16, arg_R_0, arg_R_8}},                           // USAD8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|1|1|0|0|0|Rd:4|1|1|1|1|Rm:4|0|0|0|1|Rn:4
	{0x0ff000f0, 0x07800010, 2, USADA8_EQ, 0x1c04, instArgs{arg_R_16, arg_R_0, arg_R_8, arg_R_12}},                // USADA8<c> <Rd>,<Rn>,<Rm>,<Ra> cond:4|0|1|1|1|1|0|0|0|Rd:4|Ra:4|Rm:4|0|0|0|1|Rn:4
	{0x0ff00ff0, 0x06e00f30, 4, USAT16_EQ, 0x1c04, instArgs{arg_R_12, arg_satimm4, arg_R_0}},                      // USAT16<c> <Rd>,#<sat_imm4>,<Rn> cond:4|0|1|1|0|1|1|1|0|sat_imm:4|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rn:4
	{0x0ff000f0, 0x06e00f30, 3, USAT16_EQ, 0x1c04, instArgs{arg_R_12, arg_satimm4, arg_R_0}},                      // USAT16<c> <Rd>,#<sat_imm4>,<Rn> cond:4|0|1|1|0|1|1|1|0|sat_imm:4|Rd:4|(1)|(1)|(1)|(1)|0|0|1|1|Rn:4
	{0x0fe00030, 0x06e00010, 4, USAT_EQ, 0x1c04, instArgs{arg_R_12, arg_satimm5, arg_R_shift_imm}},                // USAT<c> <Rd>,#<sat_imm5>,<Rn>{,<shift>} cond:4|0|1|1|0|1|1|1|sat_imm:5|Rd:4|imm5:5|sh|0|1|Rn:4
	{0x0ff00ff0, 0x06500f50, 4, USAX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                           // USAX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|0|1|Rm:4
	{0x0ff000f0, 0x06500f50, 3, USAX_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                           // USAX<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|0|1|Rm:4
	{0x0ff00ff0, 0x06500f70, 4, USUB16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // USUB16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|1|1|Rm:4
	{0x0ff000f0, 0x06500f70, 3, USUB16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                         // USUB16<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|0|1|1|1|Rm:4
	{0x0ff00ff0, 0x06500ff0, 4, USUB8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // USUB8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|1|1|1|Rm:4
	{0x0ff000f0, 0x06500ff0, 3, USUB8_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_0}},                          // USUB8<c> <Rd>,<Rn>,<Rm> cond:4|0|1|1|0|0|1|0|1|Rn:4|Rd:4|(1)|(1)|(1)|(1)|1|1|1|1|Rm:4
	{0x0ff003f0, 0x06c00070, 2, UXTAB16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_rotate}},                   // UXTAB16<c> <Rd>,<Rn>,<Rm>{,<rotation>} cond:4|0|1|1|0|1|1|0|0|Rn:4|Rd:4|rotate:2|0|0|0|1|1|1|Rm:4
	{0x0ff003f0, 0x06e00070, 2, UXTAB_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_rotate}},                     // UXTAB<c> <Rd>,<Rn>,<Rm>{,<rotation>} cond:4|0|1|1|0|1|1|1|0|Rn:4|Rd:4|rotate:2|0|0|0|1|1|1|Rm:4
	{0x0ff003f0, 0x06f00070, 2, UXTAH_EQ, 0x1c04, instArgs{arg_R_12, arg_R_16, arg_R_rotate}},                     // UXTAH<c> <Rd>,<Rn>,<Rm>{,<rotation>} cond:4|0|1|1|0|1|1|1|1|Rn:4|Rd:4|rotate:2|0|0|0|1|1|1|Rm:4
	{0x0fff03f0, 0x06cf0070, 4, UXTB16_EQ, 0x1c04, instArgs{arg_R_12, arg_R_rotate}},                              // UXTB16<c> <Rd>,<Rm>{,<rotation>} cond:4|0|1|1|0|1|1|0|0|1|1|1|1|Rd:4|rotate:2|0|0|0|1|1|1|Rm:4
	{0x0fff03f0, 0x06ef0070, 4, UXTB_EQ, 0x1c04, instArgs{arg_R_12, arg_R_rotate}},                                // UXTB<c> <Rd>,<Rm>{,<rotation>} cond:4|0|1|1|0|1|1|1|0|1|1|1|1|Rd:4|rotate:2|0|0|0|1|1|1|Rm:4
	{0x0fff03f0, 0x06ff0070, 4, UXTH_EQ, 0x1c04, instArgs{arg_R_12, arg_R_rotate}},                                // UXTH<c> <Rd>,<Rm>{,<rotation>} cond:4|0|1|1|0|1|1|1|1|1|1|1|1|Rd:4|rotate:2|0|0|0|1|1|1|Rm:4
	{0x0fb00e10, 0x0e000a00, 4, VMLA_EQ_F32, 0x60108011c04, instArgs{arg_Sd_Dd, arg_Sn_Dn, arg_Sm_Dm}},            // V<MLA,MLS><c>.F<32,64> <Sd,Dd>, <Sn,Dn>, <Sm,Dm> cond:4|1|1|1|0|0|D|0|0|Vn:4|Vd:4|1|0|1|sz|N|op|M|0|Vm:4
	{0x0fbf0ed0, 0x0eb00ac0, 4, VABS_EQ_F32, 0x8011c04, instArgs{arg_Sd_Dd, arg_Sm_Dm}},                           // VABS<c>.F<32,64> <Sd,Dd>, <Sm,Dm> cond:4|1|1|1|0|1|D|1|1|0|0|0|0|Vd:4|1|0|1|sz|1|1|M|0|Vm:4
	{0x0fb00e50, 0x0e300a00, 4, VADD_EQ_F32, 0x8011c04, instArgs{arg_Sd_Dd, arg_Sn_Dn, arg_Sm_Dm}},                // VADD<c>.F<32,64> <Sd,Dd>, <Sn,Dn>, <Sm,Dm> cond:4|1|1|1|0|0|D|1|1|Vn:4|Vd:4|1|0|1|sz|N|0|M|0|Vm:4
	{0x0fbf0e7f, 0x0eb50a40, 4, VCMP_EQ_F32, 0x70108011c04, instArgs{arg_Sd_Dd, arg_fp_0}},                        // VCMP{E}<c>.F<32,64> <Sd,Dd>, #0.0 cond:4|1|1|1|0|1|D|1|1|0|1|0|1|Vd:4|1|0|1|sz|E|1|0|0|(0)|(0)|(0)|(0)
	{0x0fbf0e70, 0x0eb50a40, 3, VCMP_EQ_F32, 0x70108011c04, instArgs{arg_Sd_Dd, arg_fp_0}},                        // VCMP{E}<c>.F<32,64> <Sd,Dd>, #0.0 cond:4|1|1|1|0|1|D|1|1|0|1|0|1|Vd:4|1|0|1|sz|E|1|0|0|(0)|(0)|(0)|(0)
	{0x0fbf0e50, 0x0eb40a40, 4, VCMP_EQ_F32, 0x70108011c04, instArgs{arg_Sd_Dd, arg_Sm_Dm}},                       // VCMP{E}<c>.F<32,64> <Sd,Dd>, <Sm,Dm> cond:4|1|1|1|0|1|D|1|1|0|1|0|0|Vd:4|1|0|1|sz|E|1|M|0|Vm:4
	{0x0fbe0e50, 0x0eba0a40, 4, VCVT_EQ_F32_FXS16, 0x801100107011c04, instArgs{arg_Sd_Dd, arg_Sd_Dd, arg_fbits}},  // VCVT<c>.F<32,64>.FX<S,U><16,32> <Sd,Dd>, <Sd,Dd>, #<fbits> cond:4|1|1|1|0|1|D|1|1|1|0|1|U|Vd:4|1|0|1|sz|sx|1|i|0|imm4:4
	{0x0fbe0e50, 0x0ebe0a40, 4, VCVT_EQ_FXS16_F32, 0x1001070108011c04, instArgs{arg_Sd_Dd, arg_Sd_Dd, arg_fbits}}, // VCVT<c>.FX<S,U><16,32>.F<32,64> <Sd,Dd>, <Sd,Dd>, #<fbits> cond:4|1|1|1|0|1|D|1|1|1|1|1|U|Vd:4|1|0|1|sz|sx|1|i|0|imm4:4
	{0x0fbf0ed0, 0x0eb70ac0, 4, VCVT_EQ_F64_F32, 0x8011c04, instArgs{arg_Dd_Sd, arg_Sm_Dm}},                       // VCVT<c>.<F64.F32,F32.F64> <Dd,Sd>, <Sm,Dm> cond:4|1|1|1|0|1|D|1|1|0|1|1|1|Vd:4|1|0|1|sz|1|1|M|0|Vm:4
	{0x0fbe0f50, 0x0eb20a40, 4, VCVTB_EQ_F32_F16, 0x70110011c04, instArgs{arg_Sd, arg_Sm}},                        // VCVT<B,T><c>.<F32.F16,F16.F32> <Sd>, <Sm> cond:4|1|1|1|0|1|D|1|1|0|0|1|op|Vd:4|1|0|1|0|T|1|M|0|Vm:4
	{0x0fbf0e50, 0x0eb80a40, 4, VCVT_EQ_F32_U32, 0x80107011c04, instArgs{arg_Sd_Dd, arg_Sm}},                      // VCVT<c>.F<32,64>.<U,S>32 <Sd,Dd>, <Sm> cond:4|1|1|1|0|1|D|1|1|1|0|0|0|Vd:4|1|0|1|sz|op|1|M|0|Vm:4
	{0x0fbe0e50, 0x0ebc0a40, 4, VCVTR_EQ_U32_F32, 0x701100108011c04, instArgs{arg_Sd, arg_Sm_Dm}},                 // VCVT<R,><c>.<U,S>32.F<32,64> <Sd>, <Sm,Dm> cond:4|1|1|1|0|1|D|1|1|1|1|0|signed|Vd:4|1|0|1|sz|op|1|M|0|Vm:4
	{0x0fb00e50, 0x0e800a00, 4, VDIV_EQ_F32, 0x8011c04, instArgs{arg_Sd_Dd, arg_Sn_Dn, arg_Sm_Dm}},                // VDIV<c>.F<32,64> <Sd,Dd>, <Sn,Dn>, <Sm,Dm> cond:4|1|1|1|0|1|D|0|0|Vn:4|Vd:4|1|0|1|sz|N|0|M|0|Vm:4
	{0x0f300e00, 0x0d100a00, 4, VLDR_EQ, 0x1c04, instArgs{arg_Sd_Dd, arg_mem_R_pm_imm8at0_offset}},                // VLDR<c> <Sd,Dd>, [<Rn>{,#+/-<imm8>}] cond:4|1|1|0|1|U|D|0|1|Rn:4|Vd:4|1|0|1|sz|imm8:8
	{0x0ff00f7f, 0x0e000a10, 4, VMOV_EQ, 0x1c04, instArgs{arg_Sn, arg_R_12}},                                      // VMOV<c> <Sn>, <Rt> cond:4|1|1|1|0|0|0|0|0|Vn:4|Rt:4|1|0|1|0|N|0|0|1|0|0|0|0
	{0x0ff00f7f, 0x0e100a10, 4, VMOV_EQ, 0x1c04, instArgs{arg_R_12, arg_Sn}},                                      // VMOV<c> <Rt>, <Sn> cond:4|1|1|1|0|0|0|0|1|Vn:4|Rt:4|1|0|1|0|N|0|0|1|0|0|0|0
	{0x0fd00f7f, 0x0e100b10, 4, VMOV_EQ_32, 0x1c04, instArgs{arg_R_12, arg_Dn_half}},                              // VMOV<c>.32 <Rt>, <Dn[x]> cond:4|1|1|1|0|0|0|opc1|1|Vn:4|Rt:4|1|0|1|1|N|0|0|1|0|0|0|0
	{0x0fd00f7f, 0x0e000b10, 4, VMOV_EQ_32, 0x1c04, instArgs{arg_Dn_half, arg_R_12}},                              // VMOV<c>.32 <Dd[x]>, <Rt> cond:4|1|1|1|0|0|0|opc1|0|Vd:4|Rt:4|1|0|1|1|D|0|0|1|0|0|0|0
	{0x0fb00ef0, 0x0eb00a00, 4, VMOV_EQ_F32, 0x8011c04, instArgs{arg_Sd_Dd, arg_imm_vfp}},                         // VMOV<c>.F<32,64> <Sd,Dd>, #<imm_vfp> cond:4|1|1|1|0|1|D|1|1|imm4H:4|Vd:4|1|0|1|sz|0|0|0|0|imm4L:4
	{0x0fbf0ed0, 0x0eb00a40, 4, VMOV_EQ_F32, 0x8011c04, instArgs{arg_Sd_Dd, arg_Sm_Dm}},                           // VMOV<c>.F<32,64> <Sd,Dd>, <Sm,Dm> cond:4|1|1|1|0|1|D|1|1|0|0|0|0|Vd:4|1|0|1|sz|0|1|M|0|Vm:4
	{0x0fff0fff, 0x0ef10a10, 4, VMRS_EQ, 0x1c04, instArgs{arg_R_12_nzcv, arg_FPSCR}},                              // VMRS<c> <Rt_nzcv>, FPSCR cond:4|1|1|1|0|1|1|1|1|0|0|0|1|Rt:4|1|0|1|0|0|0|0|1|0|0|0|0
	{0x0fff0fff, 0x0ee10a10, 4, VMSR_EQ, 0x1c04, instArgs{arg_FPSCR, arg_R_12}},                                   // VMSR<c> FPSCR, <Rt> cond:4|1|1|1|0|1|1|1|0|0|0|0|1|Rt:4|1|0|1|0|0|0|0|1|0|0|0|0
	{0x0fb00e50, 0x0e200a00, 4, VMUL_EQ_F32, 0x8011c04, instArgs{arg_Sd_Dd, arg_Sn_Dn, arg_Sm_Dm}},                // VMUL<c>.F<32,64> <Sd,Dd>, <Sn,Dn>, <Sm,Dm> cond:4|1|1|1|0|0|D|1|0|Vn:4|Vd:4|1|0|1|sz|N|0|M|0|Vm:4
	{0x0fbf0ed0, 0x0eb10a40, 4, VNEG_EQ_F32, 0x8011c04, instArgs{arg_Sd_Dd, arg_Sm_Dm}},                           // VNEG<c>.F<32,64> <Sd,Dd>, <Sm,Dm> cond:4|1|1|1|0|1|D|1|1|0|0|0|1|Vd:4|1|0|1|sz|0|1|M|0|Vm:4
	{0x0fb00e10, 0x0e100a00, 4, VNMLS_EQ_F32, 0x60108011c04, instArgs{arg_Sd_Dd, arg_Sn_Dn, arg_Sm_Dm}},           // VN<MLS,MLA><c>.F<32,64> <Sd,Dd>, <Sn,Dn>, <Sm,Dm> cond:4|1|1|1|0|0|D|0|1|Vn:4|Vd:4|1|0|1|sz|N|op|M|0|Vm:4
	{0x0fb00e50, 0x0e200a40, 4, VNMUL_EQ_F32, 0x8011c04, instArgs{arg_Sd_Dd, arg_Sn_Dn, arg_Sm_Dm}},               // VNMUL<c>.F<32,64> <Sd,Dd>, <Sn,Dn>, <Sm,Dm> cond:4|1|1|1|0|0|D|1|0|Vn:4|Vd:4|1|0|1|sz|N|1|M|0|Vm:4
	{0x0fbf0ed0, 0x0eb10ac0, 4, VSQRT_EQ_F32, 0x8011c04, instArgs{arg_Sd_Dd, arg_Sm_Dm}},                          // VSQRT<c>.F<32,64> <Sd,Dd>, <Sm,Dm> cond:4|1|1|1|0|1|D|1|1|0|0|0|1|Vd:4|1|0|1|sz|1|1|M|0|Vm:4
	{0x0f300e00, 0x0d000a00, 4, VSTR_EQ, 0x1c04, instArgs{arg_Sd_Dd, arg_mem_R_pm_imm8at0_offset}},                // VSTR<c> <Sd,Dd>, [<Rn>{,#+/-<imm8>}] cond:4|1|1|0|1|U|D|0|0|Rn:4|Vd:4|1|0|1|sz|imm8:8
	{0x0fb00e50, 0x0e300a40, 4, VSUB_EQ_F32, 0x8011c04, instArgs{arg_Sd_Dd, arg_Sn_Dn, arg_Sm_Dm}},                // VSUB<c>.F<32,64> <Sd,Dd>, <Sn,Dn>, <Sm,Dm> cond:4|1|1|1|0|0|D|1|1|Vn:4|Vd:4|1|0|1|sz|N|1|M|0|Vm:4
	{0x0fffffff, 0x0320f002, 4, WFE_EQ, 0x1c04, instArgs{}},                                                       // WFE<c> cond:4|0|0|1|1|0|0|1|0|0|0|0|0|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|0|0|0|0|0|0|1|0
	{0x0fff00ff, 0x0320f002, 3, WFE_EQ, 0x1c04, instArgs{}},                                                       // WFE<c> cond:4|0|0|1|1|0|0|1|0|0|0|0|0|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|0|0|0|0|0|0|1|0
	{0x0fffffff, 0x0320f003, 4, WFI_EQ, 0x1c04, instArgs{}},                                                       // WFI<c> cond:4|0|0|1|1|0|0|1|0|0|0|0|0|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|0|0|0|0|0|0|1|1
	{0x0fff00ff, 0x0320f003, 3, WFI_EQ, 0x1c04, instArgs{}},                                                       // WFI<c> cond:4|0|0|1|1|0|0|1|0|0|0|0|0|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|0|0|0|0|0|0|1|1
	{0x0fffffff, 0x0320f001, 4, YIELD_EQ, 0x1c04, instArgs{}},                                                     // YIELD<c> cond:4|0|0|1|1|0|0|1|0|0|0|0|0|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|0|0|0|0|0|0|0|1
	{0x0fff00ff, 0x0320f001, 3, YIELD_EQ, 0x1c04, instArgs{}},                                                     // YIELD<c> cond:4|0|0|1|1|0|0|1|0|0|0|0|0|(1)|(1)|(1)|(1)|(0)|(0)|(0)|(0)|0|0|0|0|0|0|0|1
	{0xffffffff, 0xf7fabcfd, 4, UNDEF, 0x0, instArgs{}},                                                           // UNDEF 1|1|1|1|0|1|1|1|1|1|1|1|1|0|1|0|1|0|1|1|1|1|0|0|1|1|1|1|1|1|0|1
}
                              root/go1.4/src/cmd/internal/rsc.io/arm/armasm/testdata/                                             0040755 0000000 0000000 00000000000 12600426233 021274  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/internal/rsc.io/arm/armasm/testdata/Makefile                                     0100644 0000000 0000000 00000000404 12600426226 022731  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        newdecode.txt:
	cd ..; go test -cover -run 'ObjdumpARMCond' -v -timeout 10h -printtests -long 2>&1 | tee log
	cd ..; go test -cover -run 'ObjdumpARMUncond' -v -timeout 10h -printtests -long 2>&1 | tee -a log
	egrep '	(gnu|plan9)	' ../log |sort >newdecode.txt

                                                                                                                                                                                                                                                            root/go1.4/src/cmd/internal/rsc.io/arm/armasm/testdata/decode.txt                                   0100644 0000000 0000000 00000026116 12600426226 023265  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        000001f1|	1	gnu	setend le
00100f61|	1	gnu	mrsvs r1, apsr
00f02053|	1	gnu	noppl
00f0d4f4|	1	gnu	pli [r4]
01f020d3|	1	gnu	yieldle
02002d59|	1	gnu	stmdbpl sp!, {r1}
021da9d8|	1	gnu	stmle r9!, {r1, r8, sl, fp, ip}
02c0b071|	1	gnu	movsvc ip, r2
02f02073|	1	gnu	wfevc
03f02013|	1	gnu	wfine
03f05df7|	1	gnu	pld [sp, -r3]
04009d34|	1	gnu	popcc {r0}
043a52b1|	1	gnu	cmplt r2, r4, lsl #20
04402de5|	1	gnu	push {r4}
045b148d|	1	gnu	vldrhi d5, [r4, #-16]
04f02093|	1	gnu	sevls
0793eab0|	1	gnu	rsclt r9, sl, r7, lsl #6
079bfb9e|	1	gnu	vmovls.f64 d25, #183
0a4fc9d3|	1	gnu	bicle r4, r9, #10, 30
0bac7ab6|	1	gnu	ldrbtlt sl, [sl], -fp, lsl #24
0c2aee44|	1	gnu	strbtmi r2, [lr], #2572
0c4bb000|	1	gnu	adcseq r4, r0, ip, lsl #22
0e26d561|	1	gnu	bicsvs r2, r5, lr, lsl #12
0f0fa011|	1	gnu	lslne r0, pc, #30
0fa448e0|	1	gnu	sub sl, r8, pc, lsl #8
101af1de|	1	gnu	vmrsle r1, fpscr
108a0cee|	1	gnu	vmov s24, r8
108a1dae|	1	gnu	vmovge r8, s26
108ae14e|	1	gnu	vmsrmi fpscr, r8
10faf1ae|	1	gnu	vmrsge apsr_nzcv, fpscr
10fb052e|	1	gnu	vmovcs.32 d5[0], pc
11c902b7|	1	gnu	smladlt r2, r1, r9, ip
11ef5b16|	1	gnu	uadd16ne lr, fp, r1
12fa87a7|	1	gnu	usad8ge r7, r2, sl
135f2956|	1	gnu	qadd16pl r5, r9, r3
13de9aa1|	1	gnu	orrsge sp, sl, r3, lsl lr
145c0e40|	1	gnu	andmi r5, lr, r4, lsl ip
150f7fd6|	1	gnu	uhadd16le r0, pc, r5
15b9bf12|	1	gnu	adcsne fp, pc, #344064
16373391|	1	gnu	teqls r3, r6, lsl r7
19ef1966|	1	gnu	sadd16vs lr, r9, r9
1ab0b091|	1	gnu	lslsls fp, sl, r0
1b9f6fe6|	1	gnu	uqadd16 r9, pc, fp
1bb58557|	1	gnu	usada8pl r5, fp, r5, fp
1beff8e0|	1	gnu	rscs lr, r8, fp, lsl pc
1caff0e6|	1	gnu	usat sl, #16, ip, lsl #30
1d0f3d36|	1	gnu	shadd16cc r0, sp, sp
1dca1d52|	1	gnu	andspl ip, sp, #118784
1e4891d0|	1	gnu	addsle r4, r1, lr, lsl r8
1f0889e6|	1	gnu	pkhbt r0, r9, pc, lsl #16
1f1f6fe1|	1	gnu	clz r1, pc
1f26d157|	1	gnu	bfcpl r2, #12, #6
1ff07ff5|	1	gnu	clrex
1fff2fd1|	1	gnu	bxle pc
20f153f6|	1	gnu	pli [r3, -r0, lsr #2]
21047013|	1	gnu	cmnne r0, #553648128
21c2eb8b|	1	gnu	blhi .-0x50f778
21c2ebfb|	1	gnu	blx .-0x50f776
21fa62ee|	1	gnu	vmul.f32 s31, s4, s3
23005720|	1	gnu	subscs r0, r7, r3, lsr #32
236a303e|	1	gnu	vaddcc.f32 s12, s0, s7
23f055f6|	1	gnu	pli [r5, -r3, lsr #32]
2430a031|	1	gnu	lsrcc r3, r4, #32
245d0803|	1	gnu	movweq r5, #36132
251a86be|	1	gnu	vdivlt.f32 s2, s12, s11
25db7b81|	1	gnu	cmnhi fp, r5, lsr #22
26bc3553|	1	gnu	teqpl r5, #9728
277c2d69|	1	gnu	pushvs {r0, r1, r2, r5, sl, fp, ip, sp, lr}
29fc1cf5|	1	gnu	pldw [ip, #-3113]
29ff2fc1|	1	gnu	bxjgt r9
2decd9c0|	1	gnu	sbcsgt lr, r9, sp, lsr #24
30fa5e47|	1	gnu	smmulrmi lr, r0, sl
316f64d6|	1	gnu	uqasxle r6, r4, r1
323f5da6|	1	gnu	uasxge r3, sp, r2
327fe5e6|	1	gnu	usat16 r7, #5, r2
330151e3|	1	gnu	cmp r1, #-1073741812
34af2ae6|	1	gnu	qasx sl, sl, r4
35fd3710|	1	gnu	eorsne pc, r7, r5, lsr sp
36def1c1|	1	gnu	mvnsgt sp, r6, lsr lr
3801b061|	1	gnu	lsrsvs r0, r8, r1
38985477|	1	gnu	smmlarvc r4, r8, r8, r9
3a2fbfa6|	1	gnu	revge r2, sl
3a3f1b06|	1	gnu	sasxeq r3, fp, sl
3a7fa346|	1	gnu	ssat16mi r7, #4, sl
3a943b94|	1	gnu	ldrtls r9, [fp], #-1082
3bf505e7|	1	gnu	smuadx r5, fp, r5
3cef7086|	1	gnu	uhasxhi lr, r0, ip
3e5f3ec6|	1	gnu	shasxgt r5, lr, lr
3f4fff86|	1	gnu	rbithi r4, pc
3faf4717|	1	gnu	smlaldxne sl, r7, pc, pc
3fff2fc1|	1	gnu	blxgt pc
402bbf7e|	1	gnu	vcvtvc.u16.f64 d2, d2, #16
403ab5de|	1	gnu	vcmple.f32 s6, #0
40eb363e|	1	gnu	vsubcc.f64 d14, d6, d0
420f73d1|	1	gnu	cmnle r3, r2, asr #30
424a648e|	1	gnu	vnmulhi.f32 s9, s8, s4
4284d717|	1	gnu	ldrbne r8, [r7, r2, asr #8]
42a599c3|	1	gnu	orrsgt sl, r9, #276824064
42abf0be|	1	gnu	vmovlt.f64 d26, d2
446ea031|	1	gnu	asrcc r6, r4, #28
4a953557|	1	gnu	ldrpl r9, [r5, -sl, asr #10]!
4ab6f712|	1	gnu	rscsne fp, r7, #77594624
4af07ff5|	1	gnu	dsb #10
4df6def4|	1	gnu	pli [lr, #1613]
4efbf52e|	1	gnu	vcmpcs.f64 d31, #0
50aaac79|	1	gnu	stmibvc ip!, {r4, r6, r9, fp, sp, pc}
50caf011|	1	gnu	mvnsne ip, r0, asr sl
50f04961|	1	gnu	qdaddvs pc, r0, r9
51282008|	1	gnu	stmdaeq r0!, {r0, r4, r6, fp, sp}
52bf6576|	1	gnu	uqsaxvc fp, r5, r2
5345c9d0|	1	gnu	sbcle r4, r9, r3, asr r5
538f5e46|	1	gnu	usaxmi r8, lr, r3
54106d31|	1	gnu	qdsubcc r1, r4, sp
56e0e557|	1	gnu	ubfxpl lr, r6, #0, #6
57073d11|	1	gnu	teqne sp, r7, asr r7
58bb0aa9|	1	gnu	stmdbge sl, {r3, r4, r6, r8, r9, fp, ip, sp, pc}
58f007b1|	1	gnu	qaddlt pc, r8, r7
59fd0e77|	1	gnu	smusdvc lr, r9, sp
5ab7f1c5|	1	gnu	ldrbgt fp, [r1, #1882]!
5abf23c6|	1	gnu	qsaxgt fp, r3, sl
5b8f1c96|	1	gnu	ssaxls r8, ip, fp
5b98ab97|	1	gnu	sbfxls r9, fp, #16, #12
5bc9b041|	1	gnu	asrsmi ip, fp, r9
5bf07ff5|	1	gnu	dmb #11
5c102b81|	1	gnu	qsubhi r1, ip, fp
5caa49e1|	1	gnu	qdadd sl, ip, r9
5d3f7226|	1	gnu	uhsaxcs r3, r2, sp
5db55470|	1	gnu	subsvc fp, r4, sp, asr r5
5ef14387|	1	gnu	smlsldhi pc, r3, lr, r1
5f540a11|	1	gnu	qaddne r5, pc, sl
5f9079d1|	1	gnu	cmnle r9, pc, asr r0
5faf3f66|	1	gnu	shsaxvs sl, pc, pc
605071d7|	1	gnu	ldrble r5, [r1, -r0, rrx]!
614adc76|	1	gnu	ldrbvc r4, [ip], r1, ror #20
616b9e42|	1	gnu	addsmi r6, lr, #99328
62c84f15|	1	gnu	strbne ip, [pc, #-2146]
62f051f7|	1	gnu	pld [r1, -r2, rrx]
6346c393|	1	gnu	bicls r4, r3, #103809024
654abbae|	1	gnu	vcvtge.f32.u16 s8, s8, #5
65a5f0e3|	1	gnu	mvns sl, #423624704
65f796f7|	1	gnu	pldw [r6, r5, ror #14]
670bb12e|	1	gnu	vnegcs.f64 d0, d23
67903731|	1	gnu	teqcc r7, r7, rrx
68ddc637|	1	gnu	strbcc sp, [r6, r8, ror #26]
695b3ab6|	1	gnu	ldrtlt r5, [sl], -r9, ror #22
697cfc71|	1	gnu	mvnsvc r7, r9, ror #24
6a0ab3ee|	1	gnu	vcvtb.f16.f32 s0, s21
6ad9ad54|	1	gnu	strtpl sp, [sp], #2410
6af07ff5|	1	gnu	isb #10
6afa6f10|	1	gnu	rsbne pc, pc, sl, ror #20
6d5b19ee|	1	gnu	vnmla.f64 d5, d9, d29
6d60b071|	1	gnu	rrxsvc r6, sp
6df754f7|	1	gnu	pld [r4, -sp, ror #14]
70065821|	1	gnu	cmpcs r8, r0, ror r6
7050ed86|	1	gnu	uxtabhi r5, sp, r0
715f1186|	1	gnu	ssub16hi r5, r1, r1
716c9805|	1	gnu	ldreq r6, [r8, #3185]
718d5ab1|	1	gnu	cmplt sl, r1, ror sp
71c8cfb6|	1	gnu	uxtb16lt ip, r1, ror #16
7294af06|	1	gnu	sxtbeq r9, r2, ror #8
72c0bac6|	1	gnu	sxtahgt ip, sl, r2
730f6716|	1	gnu	uqsub16ne r0, r7, r3
73608f46|	1	gnu	sxtb16mi r6, r3
73687f22|	1	gnu	rsbscs r6, pc, #7536640
74308816|	1	gnu	sxtab16ne r3, r8, r4
757f3456|	1	gnu	shsub16pl r7, r4, r5
77788016|	1	gnu	sxtab16ne r7, r0, r7, ror #16
78061671|	1	gnu	tstvc r6, r8, ror r6
780a2fe1|	1	gnu	bkpt 0xf0a8
7850abd6|	1	gnu	sxtable r5, fp, r8
792cef26|	1	gnu	uxtbcs r2, r9, ror #24
799eb8e0|	1	gnu	adcs r9, r8, r9, ror lr
799f5726|	1	gnu	usub16cs r9, r7, r9
79d0bf16|	1	gnu	sxthne sp, r9
7a037ba1|	1	gnu	cmnge fp, sl, ror r3
7b0f2566|	1	gnu	qsub16vs r0, r5, fp
7b79dd51|	1	gnu	bicspl r7, sp, fp, ror r9
7b9a9f1d|	1	gnu	vldrne s18, [pc, #492]
7c70cea6|	1	gnu	uxtab16ge r7, lr, ip
7d48f966|	1	gnu	uxtahvs r4, r9, sp, ror #16
7d5c13a1|	1	gnu	tstge r3, sp, ror ip
7e0001f1|	1	gnu	setend le
7e1c0ba7|	1	gnu	smlsdxge fp, lr, ip, r1
7e567e40|	1	gnu	rsbsmi r5, lr, lr, ror r6
7e8f73b6|	1	gnu	uhsub16lt r8, r3, lr
7ef0ffd6|	1	gnu	uxthle pc, lr
7faaa011|	1	gnu	rorne sl, pc, sl
81f19af7|	1	gnu	pldw [sl, r1, lsl #3]
82033901|	1	gnu	teqeq r9, r2, lsl #7
82f316f5|	1	gnu	pldw [r6, #-898]
830201f1|	1	gnu	setend be
838a3b91|	1	gnu	teqls fp, r3, lsl #21
8408af2f|	1	gnu	svccs 0x00af0884
884201d1|	1	gnu	smlabble r1, r8, r2, r4
8aa12e31|	1	gnu	smlawbcc lr, sl, r1, sl
8b9b99c0|	1	gnu	addsgt r9, r9, fp, lsl #23
8c005c81|	1	gnu	cmphi ip, ip, lsl #1
8fb429c6|	1	gnu	strtgt fp, [r9], -pc, lsl #9
907b1f9e|	1	gnu	vmovls.32 r7, d31[0]
91975f25|	1	gnu	ldrbcs r9, [pc, #-1937]
91b010e3|	1	gnu	tst r0, #145
927facb1|	1	gnu	strexdlt r7, r2, [ip]
92904c91|	1	gnu	swpbls r9, r2, [ip]
92af1226|	1	gnu	sadd8cs sl, r2, r2
92b28c70|	1	gnu	umullvc fp, ip, r2, r2
945f68a6|	1	gnu	uqadd8ge r5, r8, r4
950b2560|	1	gnu	mlavs r5, r5, fp, r0
969fcf71|	1	gnu	strexbvc r9, r6, [pc]
96cf35e6|	1	gnu	shadd8 ip, r5, r6
98060eb0|	1	gnu	mullt lr, r8, r6
9843fb93|	1	gnu	mvnsls r4, #152, 6
9a3fe2b0|	1	gnu	smlallt r3, r2, sl, pc
9aef58b6|	1	gnu	uadd8lt lr, r8, sl
9afcdff5|	1	gnu	pld [pc, #3226]
9c221810|	1	gnu	mulsne r8, ip, r2
9c3bc9dd|	1	gnu	vstrle d19, [r9, #624]
9c5f2606|	1	gnu	qadd8eq r5, r6, ip
9d87dac0|	1	gnu	smullsgt r8, sl, sp, r7
9e0f7c86|	1	gnu	uhadd8hi r0, ip, lr
9e814560|	1	gnu	umaalvs r8, r5, lr, r1
9e9f8dc1|	1	gnu	strexgt r9, lr, [sp]
9ec3c9d7|	1	gnu	bfile ip, lr, #7, #3
9ed26d90|	1	gnu	mlsls sp, lr, r2, sp
9f7fd9c1|	1	gnu	ldrexbgt r7, [r9]
9f7fea91|	1	gnu	strexhls r7, pc, [sl]
9f9f9921|	1	gnu	ldrexcs r9, [r9]
9faffd21|	1	gnu	ldrexhcs sl, [sp]
9fcfbd61|	1	gnu	ldrexdvs ip, [sp]
9ff7a710|	1	gnu	umlalne pc, r7, pc, r7
a05459d3|	1	gnu	cmple r9, #160, 8
a3062be1|	1	gnu	smulwb fp, r3, r6
a68a92b1|	1	gnu	orrslt r8, r2, r6, lsr #21
abff55f6|	1	gnu	pli [r5, -fp, lsr #31]
addbf8ea|	1	gnu	b .-0x1c9148
ae79b021|	1	gnu	lsrscs r7, lr, #19
b590a3b1|	1	gnu	strhlt r9, [r3, r5]!
b5b2e390|	1	gnu	strhtls fp, [r3], #37
b6ac4e30|	1	gnu	strhcc sl, [lr], #-198
b73fff86|	1	gnu	revshhi r3, r7
b75fbfc6|	1	gnu	rev16gt r5, r7
b80b7c80|	1	gnu	ldrhthi r0, [ip], #-184
b82035e0|	1	gnu	ldrht r2, [r5], -r8
b8877391|	1	gnu	ldrhls r8, [r3, #-120]!
b9703e41|	1	gnu	ldrhmi r7, [lr, -r9]!
b9cf8c16|	1	gnu	selne ip, ip, r9
bd81bd58|	1	gnu	poppl {r0, r2, r3, r4, r5, r7, r8, pc}
bdfdb469|	1	gnu	ldmibvs r4!, {r0, r2, r3, r4, r5, r7, r8, sl, fp, ip, sp, lr, pc}
beb02500|	1	gnu	strhteq fp, [r5], -lr
bf1a5e42|	1	gnu	subsmi r1, lr, #782336
c19a4d5e|	1	gnu	vmlspl.f32 s19, s27, s2
c1aab15e|	1	gnu	vsqrtpl.f32 s20, s2
c354b003|	1	gnu	movseq r5, #-1023410176
c4091dc1|	1	gnu	tstgt sp, r4, asr #19
c50e13a9|	1	gnu	ldmdbge r3, {r0, r2, r6, r7, r9, sl, fp}
c68c8637|	1	gnu	strcc r8, [r6, r6, asr #25]
c6ad48e3|	1	gnu	movt sl, #36294
c6f65ff5|	1	gnu	pld [pc, #-1734]
c8a92f10|	1	gnu	eorne sl, pc, r8, asr #19
c9016b61|	1	gnu	smulbtvs fp, r9, r1
cadbf49e|	1	gnu	vcmpels.f64 d29, d10
ce9de476|	1	gnu	strbtvc r9, [r4], lr, asr #27
cf3c1ab1|	1	gnu	tstlt sl, pc, asr #25
d355aab6|	1	gnu	ssatlt r5, #11, r3, asr #11
d4f4df10|	1	gnu	ldrsbne pc, [pc], #68
d6530d61|	1	gnu	ldrdvs r5, [sp, -r6]
d74d7800|	1	gnu	ldrsbteq r4, [r8], #-215
d9703680|	1	gnu	ldrsbthi r7, [r6], -r9
dbe003c0|	1	gnu	ldrdgt lr, [r3], -fp
dc709561|	1	gnu	ldrsbvs r7, [r5, ip]
dcc3b9c8|	1	gnu	ldmgt r9!, {r2, r3, r4, r6, r7, r8, r9, lr, pc}
debfa0e5|	1	gnu	str fp, [r0, #4062]!
dee062a1|	1	gnu	ldrdge lr, [r2, #-14]!
dfa05ab7|	1	gnu	smmlslt sl, pc, r0, sl
e02ef011|	1	gnu	mvnsne r2, r0, ror #29
e4d41718|	1	gnu	ldmdane r7, {r2, r5, r6, r7, sl, ip, lr, pc}
e6d0fe34|	1	gnu	ldrbtcc sp, [lr], #230
e73bf7be|	1	gnu	vcvtlt.f32.f64 s7, d23
e74e72b3|	1	gnu	cmnlt r2, #3696
e80bf07e|	1	gnu	vabsvc.f64 d16, d24
e9b5b001|	1	gnu	rorseq fp, r9, #11
ea7bbdbe|	1	gnu	vcvtlt.s32.f64 s14, d26
ec063813|	1	gnu	teqne r8, #236, 12
ec0e49e1|	1	gnu	smlaltt r0, r9, ip, lr
ee4ab85e|	1	gnu	vcvtpl.f32.s32 s8, s29
ef461f25|	1	gnu	ldrcs r4, [pc, #-1775]
ef5fd002|	1	gnu	sbcseq r5, r0, #956
f4cf1d36|	1	gnu	ssub8cc ip, sp, r4
f67f73b6|	1	gnu	uhsub8lt r7, r3, r6
f6e09ca0|	1	gnu	ldrshge lr, [ip], r6
f7702e32|	1	gnu	eorcc r7, lr, #247
fa4dcf20|	1	gnu	strdcs r4, [pc], #218
fac03720|	1	gnu	ldrshtcs ip, [r7], -sl
fc0f64c6|	1	gnu	uqsub8gt r0, r4, ip
fc28f481|	1	gnu	ldrshhi r2, [r4, #140]!
fc300560|	1	gnu	strdvs r3, [r5], -ip
fcacfc70|	1	gnu	ldrshtvc sl, [ip], #204
fdbcfaf7|	1	gnu	undef
fddf5c86|	1	gnu	usub8hi sp, ip, sp
fdf02013|	1	gnu	dbgne #13
fe0319e3|	1	gnu	tst r9, #-134217725
fe7f3116|	1	gnu	shsub8ne r7, r1, lr
ff4f2ac6|	1	gnu	qsub8gt r4, sl, pc
ff818c71|	1	gnu	strdvc r8, [ip, pc]
|6b5721d3	1	gnu	error: unknown instruction
|76452001	1	gnu	error: unknown instruction
|97acd647	1	gnu	error: unknown instruction
                                                                                                                                                                                                                                                                                                                                                                                                                                                  root/go1.4/src/cmd/internal/rsc.io/x86/                                                             0040755 0000000 0000000 00000000000 12600426233 016051  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/                                                      0040755 0000000 0000000 00000000000 12600426233 017177  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/Makefile                                              0100644 0000000 0000000 00000000226 12600426226 020636  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        tables.go: ../x86map/map.go ../x86.csv 
	go run ../x86map/map.go -fmt=decoder ../x86.csv >_tables.go && gofmt _tables.go >tables.go && rm _tables.go

                                                                                                                                                                                                                                                                                                                                                                          root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/decode.go                                             0100644 0000000 0000000 00000125131 12600426226 020753  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Table-driven decoding of x86 instructions.

package x86asm

import (
	"encoding/binary"
	"errors"
	"fmt"
	"runtime"
)

// Set trace to true to cause the decoder to print the PC sequence
// of the executed instruction codes. This is typically only useful
// when you are running a test of a single input case.
const trace = false

// A decodeOp is a single instruction in the decoder bytecode program.
//
// The decodeOps correspond to consuming and conditionally branching
// on input bytes, consuming additional fields, and then interpreting
// consumed data as instruction arguments. The names of the xRead and xArg
// operations are taken from the Intel manual conventions, for example
// Volume 2, Section 3.1.1, page 487 of
// http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf
//
// The actual decoding program is generated by ../x86map.
//
// TODO(rsc): We may be able to merge various of the memory operands
// since we don't care about, say, the distinction between m80dec and m80bcd.
// Similarly, mm and mm1 have identical meaning, as do xmm and xmm1.

type decodeOp uint16

const (
	xFail  decodeOp = iota // invalid instruction (return)
	xMatch                 // completed match
	xJump                  // jump to pc

	xCondByte     // switch on instruction byte value
	xCondSlashR   // read and switch on instruction /r value
	xCondPrefix   // switch on presence of instruction prefix
	xCondIs64     // switch on 64-bit processor mode
	xCondDataSize // switch on operand size
	xCondAddrSize // switch on address size
	xCondIsMem    // switch on memory vs register argument

	xSetOp // set instruction opcode

	xReadSlashR // read /r
	xReadIb     // read ib
	xReadIw     // read iw
	xReadId     // read id
	xReadIo     // read io
	xReadCb     // read cb
	xReadCw     // read cw
	xReadCd     // read cd
	xReadCp     // read cp
	xReadCm     // read cm

	xArg1            // arg 1
	xArg3            // arg 3
	xArgAL           // arg AL
	xArgAX           // arg AX
	xArgCL           // arg CL
	xArgCR0dashCR7   // arg CR0-CR7
	xArgCS           // arg CS
	xArgDR0dashDR7   // arg DR0-DR7
	xArgDS           // arg DS
	xArgDX           // arg DX
	xArgEAX          // arg EAX
	xArgEDX          // arg EDX
	xArgES           // arg ES
	xArgFS           // arg FS
	xArgGS           // arg GS
	xArgImm16        // arg imm16
	xArgImm32        // arg imm32
	xArgImm64        // arg imm64
	xArgImm8         // arg imm8
	xArgImm8u        // arg imm8 but record as unsigned
	xArgImm16u       // arg imm8 but record as unsigned
	xArgM            // arg m
	xArgM128         // arg m128
	xArgM1428byte    // arg m14/28byte
	xArgM16          // arg m16
	xArgM16and16     // arg m16&16
	xArgM16and32     // arg m16&32
	xArgM16and64     // arg m16&64
	xArgM16colon16   // arg m16:16
	xArgM16colon32   // arg m16:32
	xArgM16colon64   // arg m16:64
	xArgM16int       // arg m16int
	xArgM2byte       // arg m2byte
	xArgM32          // arg m32
	xArgM32and32     // arg m32&32
	xArgM32fp        // arg m32fp
	xArgM32int       // arg m32int
	xArgM512byte     // arg m512byte
	xArgM64          // arg m64
	xArgM64fp        // arg m64fp
	xArgM64int       // arg m64int
	xArgM8           // arg m8
	xArgM80bcd       // arg m80bcd
	xArgM80dec       // arg m80dec
	xArgM80fp        // arg m80fp
	xArgM94108byte   // arg m94/108byte
	xArgMm           // arg mm
	xArgMm1          // arg mm1
	xArgMm2          // arg mm2
	xArgMm2M64       // arg mm2/m64
	xArgMmM32        // arg mm/m32
	xArgMmM64        // arg mm/m64
	xArgMem          // arg mem
	xArgMoffs16      // arg moffs16
	xArgMoffs32      // arg moffs32
	xArgMoffs64      // arg moffs64
	xArgMoffs8       // arg moffs8
	xArgPtr16colon16 // arg ptr16:16
	xArgPtr16colon32 // arg ptr16:32
	xArgR16          // arg r16
	xArgR16op        // arg r16 with +rw in opcode
	xArgR32          // arg r32
	xArgR32M16       // arg r32/m16
	xArgR32M8        // arg r32/m8
	xArgR32op        // arg r32 with +rd in opcode
	xArgR64          // arg r64
	xArgR64M16       // arg r64/m16
	xArgR64op        // arg r64 with +rd in opcode
	xArgR8           // arg r8
	xArgR8op         // arg r8 with +rb in opcode
	xArgRAX          // arg RAX
	xArgRDX          // arg RDX
	xArgRM           // arg r/m
	xArgRM16         // arg r/m16
	xArgRM32         // arg r/m32
	xArgRM64         // arg r/m64
	xArgRM8          // arg r/m8
	xArgReg          // arg reg
	xArgRegM16       // arg reg/m16
	xArgRegM32       // arg reg/m32
	xArgRegM8        // arg reg/m8
	xArgRel16        // arg rel16
	xArgRel32        // arg rel32
	xArgRel8         // arg rel8
	xArgSS           // arg SS
	xArgST           // arg ST, aka ST(0)
	xArgSTi          // arg ST(i) with +i in opcode
	xArgSreg         // arg Sreg
	xArgTR0dashTR7   // arg TR0-TR7
	xArgXmm          // arg xmm
	xArgXMM0         // arg <XMM0>
	xArgXmm1         // arg xmm1
	xArgXmm2         // arg xmm2
	xArgXmm2M128     // arg xmm2/m128
	xArgXmm2M16      // arg xmm2/m16
	xArgXmm2M32      // arg xmm2/m32
	xArgXmm2M64      // arg xmm2/m64
	xArgXmmM128      // arg xmm/m128
	xArgXmmM32       // arg xmm/m32
	xArgXmmM64       // arg xmm/m64
	xArgRmf16        // arg r/m16 but force mod=3
	xArgRmf32        // arg r/m32 but force mod=3
	xArgRmf64        // arg r/m64 but force mod=3
)

// instPrefix returns an Inst describing just one prefix byte.
// It is only used if there is a prefix followed by an unintelligible
// or invalid instruction byte sequence.
func instPrefix(b byte, mode int) (Inst, error) {
	// When tracing it is useful to see what called instPrefix to report an error.
	if trace {
		_, file, line, _ := runtime.Caller(1)
		fmt.Printf("%s:%d\n", file, line)
	}
	p := Prefix(b)
	switch p {
	case PrefixDataSize:
		if mode == 16 {
			p = PrefixData32
		} else {
			p = PrefixData16
		}
	case PrefixAddrSize:
		if mode == 32 {
			p = PrefixAddr16
		} else {
			p = PrefixAddr32
		}
	}
	// Note: using composite literal with Prefix key confuses 'bundle' tool.
	inst := Inst{Len: 1}
	inst.Prefix = Prefixes{p}
	return inst, nil
}

// truncated reports a truncated instruction.
// For now we use instPrefix but perhaps later we will return
// a specific error here.
func truncated(src []byte, mode int) (Inst, error) {
	//	return Inst{}, len(src), ErrTruncated
	return instPrefix(src[0], mode) // too long
}

// These are the errors returned by Decode.
var (
	ErrInvalidMode  = errors.New("invalid x86 mode in Decode")
	ErrTruncated    = errors.New("truncated instruction")
	ErrUnrecognized = errors.New("unrecognized instruction")
)

// decoderCover records coverage information for which parts
// of the byte code have been executed.
// TODO(rsc): This is for testing. Only use this if a flag is given.
var decoderCover []bool

// Decode decodes the leading bytes in src as a single instruction.
// The mode arguments specifies the assumed processor mode:
// 16, 32, or 64 for 16-, 32-, and 64-bit execution modes.
func Decode(src []byte, mode int) (inst Inst, err error) {
	return decode1(src, mode, false)
}

// decode1 is the implementation of Decode but takes an extra
// gnuCompat flag to cause it to change its behavior to mimic
// bugs (or at least unique features) of GNU libopcodes as used
// by objdump. We don't believe that logic is the right thing to do
// in general, but when testing against libopcodes it simplifies the
// comparison if we adjust a few small pieces of logic.
// The affected logic is in the conditional branch for "mandatory" prefixes,
// case xCondPrefix.
func decode1(src []byte, mode int, gnuCompat bool) (Inst, error) {
	switch mode {
	case 16, 32, 64:
		// ok
		// TODO(rsc): 64-bit mode not tested, probably not working.
	default:
		return Inst{}, ErrInvalidMode
	}

	// Maximum instruction size is 15 bytes.
	// If we need to read more, return 'truncated instruction.
	if len(src) > 15 {
		src = src[:15]
	}

	var (
		// prefix decoding information
		pos           = 0    // position reading src
		nprefix       = 0    // number of prefixes
		lockIndex     = -1   // index of LOCK prefix in src and inst.Prefix
		repIndex      = -1   // index of REP/REPN prefix in src and inst.Prefix
		segIndex      = -1   // index of Group 2 prefix in src and inst.Prefix
		dataSizeIndex = -1   // index of Group 3 prefix in src and inst.Prefix
		addrSizeIndex = -1   // index of Group 4 prefix in src and inst.Prefix
		rex           Prefix // rex byte if present (or 0)
		rexUsed       Prefix // bits used in rex byte
		rexIndex      = -1   // index of rex byte

		addrMode = mode // address mode (width in bits)
		dataMode = mode // operand mode (width in bits)

		// decoded ModR/M fields
		haveModrm bool
		modrm     int
		mod       int
		regop     int
		rm        int

		// if ModR/M is memory reference, Mem form
		mem     Mem
		haveMem bool

		// decoded SIB fields
		haveSIB bool
		sib     int
		scale   int
		index   int
		base    int

		// decoded immediate values
		imm  int64
		imm8 int8
		immc int64

		// output
		opshift int
		inst    Inst
		narg    int // number of arguments written to inst
	)

	if mode == 64 {
		dataMode = 32
	}

	// Prefixes are certainly the most complex and underspecified part of
	// decoding x86 instructions. Although the manuals say things like
	// up to four prefixes, one from each group, nearly everyone seems to
	// agree that in practice as many prefixes as possible, including multiple
	// from a particular group or repetitions of a given prefix, can be used on
	// an instruction, provided the total instruction length including prefixes
	// does not exceed the agreed-upon maximum of 15 bytes.
	// Everyone also agrees that if one of these prefixes is the LOCK prefix
	// and the instruction is not one of the instructions that can be used with
	// the LOCK prefix or if the destination is not a memory operand,
	// then the instruction is invalid and produces the #UD exception.
	// However, that is the end of any semblance of agreement.
	//
	// What happens if prefixes are given that conflict with other prefixes?
	// For example, the memory segment overrides CS, DS, ES, FS, GS, SS
	// conflict with each other: only one segment can be in effect.
	// Disassemblers seem to agree that later prefixes take priority over
	// earlier ones. I have not taken the time to write assembly programs
	// to check to see if the hardware agrees.
	//
	// What happens if prefixes are given that have no meaning for the
	// specific instruction to which they are attached? It depends.
	// If they really have no meaning, they are ignored. However, a future
	// processor may assign a different meaning. As a disassembler, we
	// don't really know whether we're seeing a meaningless prefix or one
	// whose meaning we simply haven't been told yet.
	//
	// Combining the two questions, what happens when conflicting
	// extension prefixes are given? No one seems to know for sure.
	// For example, MOVQ is 66 0F D6 /r, MOVDQ2Q is F2 0F D6 /r,
	// and MOVQ2DQ is F3 0F D6 /r. What is '66 F2 F3 0F D6 /r'?
	// Which prefix wins? See the xCondPrefix prefix for more.
	//
	// Writing assembly test cases to divine which interpretation the
	// CPU uses might clarify the situation, but more likely it would
	// make the situation even less clear.

	// Read non-REX prefixes.
ReadPrefixes:
	for ; pos < len(src); pos++ {
		p := Prefix(src[pos])
		switch p {
		default:
			nprefix = pos
			break ReadPrefixes

		// Group 1 - lock and repeat prefixes
		// According to Intel, there should only be one from this set,
		// but according to AMD both can be present.
		case 0xF0:
			if lockIndex >= 0 {
				inst.Prefix[lockIndex] |= PrefixIgnored
			}
			lockIndex = pos
		case 0xF2, 0xF3:
			if repIndex >= 0 {
				inst.Prefix[repIndex] |= PrefixIgnored
			}
			repIndex = pos

		// Group 2 - segment override / branch hints
		case 0x26, 0x2E, 0x36, 0x3E:
			if mode == 64 {
				p |= PrefixIgnored
				break
			}
			fallthrough
		case 0x64, 0x65:
			if segIndex >= 0 {
				inst.Prefix[segIndex] |= PrefixIgnored
			}
			segIndex = pos

		// Group 3 - operand size override
		case 0x66:
			if mode == 16 {
				dataMode = 32
				p = PrefixData32
			} else {
				dataMode = 16
				p = PrefixData16
			}
			if dataSizeIndex >= 0 {
				inst.Prefix[dataSizeIndex] |= PrefixIgnored
			}
			dataSizeIndex = pos

		// Group 4 - address size override
		case 0x67:
			if mode == 32 {
				addrMode = 16
				p = PrefixAddr16
			} else {
				addrMode = 32
				p = PrefixAddr32
			}
			if addrSizeIndex >= 0 {
				inst.Prefix[addrSizeIndex] |= PrefixIgnored
			}
			addrSizeIndex = pos
		}

		if pos >= len(inst.Prefix) {
			return instPrefix(src[0], mode) // too long
		}

		inst.Prefix[pos] = p
	}

	// Read REX prefix.
	if pos < len(src) && mode == 64 && Prefix(src[pos]).IsREX() {
		rex = Prefix(src[pos])
		rexIndex = pos
		if pos >= len(inst.Prefix) {
			return instPrefix(src[0], mode) // too long
		}
		inst.Prefix[pos] = rex
		pos++
		if rex&PrefixREXW != 0 {
			dataMode = 64
			if dataSizeIndex >= 0 {
				inst.Prefix[dataSizeIndex] |= PrefixIgnored
			}
		}
	}

	// Decode instruction stream, interpreting decoding instructions.
	// opshift gives the shift to use when saving the next
	// opcode byte into inst.Opcode.
	opshift = 24
	if decoderCover == nil {
		decoderCover = make([]bool, len(decoder))
	}

	// Decode loop, executing decoder program.
	var oldPC, prevPC int
Decode:
	for pc := 1; ; { // TODO uint
		oldPC = prevPC
		prevPC = pc
		if trace {
			println("run", pc)
		}
		x := decoder[pc]
		decoderCover[pc] = true
		pc++

		// Read and decode ModR/M if needed by opcode.
		switch decodeOp(x) {
		case xCondSlashR, xReadSlashR:
			if haveModrm {
				return Inst{Len: pos}, errInternal
			}
			haveModrm = true
			if pos >= len(src) {
				return truncated(src, mode)
			}
			modrm = int(src[pos])
			pos++
			if opshift >= 0 {
				inst.Opcode |= uint32(modrm) << uint(opshift)
				opshift -= 8
			}
			mod = modrm >> 6
			regop = (modrm >> 3) & 07
			rm = modrm & 07
			if rex&PrefixREXR != 0 {
				rexUsed |= PrefixREXR
				regop |= 8
			}
			if addrMode == 16 {
				// 16-bit modrm form
				if mod != 3 {
					haveMem = true
					mem = addr16[rm]
					if rm == 6 && mod == 0 {
						mem.Base = 0
					}

					// Consume disp16 if present.
					if mod == 0 && rm == 6 || mod == 2 {
						if pos+2 > len(src) {
							return truncated(src, mode)
						}
						mem.Disp = int64(binary.LittleEndian.Uint16(src[pos:]))
						pos += 2
					}

					// Consume disp8 if present.
					if mod == 1 {
						if pos >= len(src) {
							return truncated(src, mode)
						}
						mem.Disp = int64(int8(src[pos]))
						pos++
					}
				}
			} else {
				haveMem = mod != 3

				// 32-bit or 64-bit form
				// Consume SIB encoding if present.
				if rm == 4 && mod != 3 {
					haveSIB = true
					if pos >= len(src) {
						return truncated(src, mode)
					}
					sib = int(src[pos])
					pos++
					if opshift >= 0 {
						inst.Opcode |= uint32(sib) << uint(opshift)
						opshift -= 8
					}
					scale = sib >> 6
					index = (sib >> 3) & 07
					base = sib & 07
					if rex&PrefixREXB != 0 {
						rexUsed |= PrefixREXB
						base |= 8
					}
					if rex&PrefixREXX != 0 {
						rexUsed |= PrefixREXX
						index |= 8
					}

					mem.Scale = 1 << uint(scale)
					if index == 4 {
						// no mem.Index
					} else {
						mem.Index = baseRegForBits(addrMode) + Reg(index)
					}
					if base&7 == 5 && mod == 0 {
						// no mem.Base
					} else {
						mem.Base = baseRegForBits(addrMode) + Reg(base)
					}
				} else {
					if rex&PrefixREXB != 0 {
						rexUsed |= PrefixREXB
						rm |= 8
					}
					if mod == 0 && rm&7 == 5 || rm&7 == 4 {
						// base omitted
					} else if mod != 3 {
						mem.Base = baseRegForBits(addrMode) + Reg(rm)
					}
				}

				// Consume disp32 if present.
				if mod == 0 && (rm&7 == 5 || haveSIB && base&7 == 5) || mod == 2 {
					if pos+4 > len(src) {
						return truncated(src, mode)
					}
					mem.Disp = int64(binary.LittleEndian.Uint32(src[pos:]))
					pos += 4
				}

				// Consume disp8 if present.
				if mod == 1 {
					if pos >= len(src) {
						return truncated(src, mode)
					}
					mem.Disp = int64(int8(src[pos]))
					pos++
				}

				// In 64-bit, mod=0 rm=5 is PC-relative instead of just disp.
				// See Vol 2A. Table 2-7.
				if mode == 64 && mod == 0 && rm&7 == 5 {
					if addrMode == 32 {
						mem.Base = EIP
					} else {
						mem.Base = RIP
					}
				}
			}

			if segIndex >= 0 {
				mem.Segment = prefixToSegment(inst.Prefix[segIndex])
			}
		}

		// Execute single opcode.
		switch decodeOp(x) {
		default:
			println("bad op", x, "at", pc-1, "from", oldPC)
			return Inst{Len: pos}, errInternal

		case xFail:
			inst.Op = 0
			break Decode

		case xMatch:
			break Decode

		case xJump:
			pc = int(decoder[pc])

		// Conditional branches.

		case xCondByte:
			if pos >= len(src) {
				return truncated(src, mode)
			}
			b := src[pos]
			n := int(decoder[pc])
			pc++
			for i := 0; i < n; i++ {
				xb, xpc := decoder[pc], int(decoder[pc+1])
				pc += 2
				if b == byte(xb) {
					pc = xpc
					pos++
					if opshift >= 0 {
						inst.Opcode |= uint32(b) << uint(opshift)
						opshift -= 8
					}
					continue Decode
				}
			}
			// xCondByte is the only conditional with a fall through,
			// so that it can be used to pick off special cases before
			// an xCondSlash. If the fallthrough instruction is xFail,
			// advance the position so that the decoded instruction
			// size includes the byte we just compared against.
			if decodeOp(decoder[pc]) == xJump {
				pc = int(decoder[pc+1])
			}
			if decodeOp(decoder[pc]) == xFail {
				pos++
			}

		case xCondIs64:
			if mode == 64 {
				pc = int(decoder[pc+1])
			} else {
				pc = int(decoder[pc])
			}

		case xCondIsMem:
			mem := haveMem
			if !haveModrm {
				if pos >= len(src) {
					return instPrefix(src[0], mode) // too long
				}
				mem = src[pos]>>6 != 3
			}
			if mem {
				pc = int(decoder[pc+1])
			} else {
				pc = int(decoder[pc])
			}

		case xCondDataSize:
			switch dataMode {
			case 16:
				if dataSizeIndex >= 0 {
					inst.Prefix[dataSizeIndex] |= PrefixImplicit
				}
				pc = int(decoder[pc])
			case 32:
				if dataSizeIndex >= 0 {
					inst.Prefix[dataSizeIndex] |= PrefixImplicit
				}
				pc = int(decoder[pc+1])
			case 64:
				rexUsed |= PrefixREXW
				pc = int(decoder[pc+2])
			}

		case xCondAddrSize:
			switch addrMode {
			case 16:
				if addrSizeIndex >= 0 {
					inst.Prefix[addrSizeIndex] |= PrefixImplicit
				}
				pc = int(decoder[pc])
			case 32:
				if addrSizeIndex >= 0 {
					inst.Prefix[addrSizeIndex] |= PrefixImplicit
				}
				pc = int(decoder[pc+1])
			case 64:
				pc = int(decoder[pc+2])
			}

		case xCondPrefix:
			// Conditional branch based on presence or absence of prefixes.
			// The conflict cases here are completely undocumented and
			// differ significantly between GNU libopcodes and Intel xed.
			// I have not written assembly code to divine what various CPUs
			// do, but it wouldn't surprise me if they are not consistent either.
			//
			// The basic idea is to switch on the presence of a prefix, so that
			// for example:
			//
			//	xCondPrefix, 4
			//	0xF3, 123,
			//	0xF2, 234,
			//	0x66, 345,
			//	0, 456
			//
			// branch to 123 if the F3 prefix is present, 234 if the F2 prefix
			// is present, 66 if the 345 prefix is present, and 456 otherwise.
			// The prefixes are given in descending order so that the 0 will be last.
			//
			// It is unclear what should happen if multiple conditions are
			// satisfied: what if F2 and F3 are both present, or if 66 and F2
			// are present, or if all three are present? The one chosen becomes
			// part of the opcode and the others do not. Perhaps the answer
			// depends on the specific opcodes in question.
			//
			// The only clear example is that CRC32 is F2 0F 38 F1 /r, and
			// it comes in 16-bit and 32-bit forms based on the 66 prefix,
			// so 66 F2 0F 38 F1 /r should be treated as F2 taking priority,
			// with the 66 being only an operand size override, and probably
			// F2 66 0F 38 F1 /r should be treated the same.
			// Perhaps that rule is specific to the case of CRC32, since no
			// 66 0F 38 F1 instruction is defined (today) (that we know of).
			// However, both libopcodes and xed seem to generalize this
			// example and choose F2/F3 in preference to 66, and we
			// do the same.
			//
			// Next, what if both F2 and F3 are present? Which wins?
			// The Intel xed rule, and ours, is that the one that occurs last wins.
			// The GNU libopcodes rule, which we implement only in gnuCompat mode,
			// is that F3 beats F2 unless F3 has no special meaning, in which
			// case F3 can be a modified on an F2 special meaning.
			//
			// Concretely,
			//	66 0F D6 /r is MOVQ
			//	F2 0F D6 /r is MOVDQ2Q
			//	F3 0F D6 /r is MOVQ2DQ.
			//
			//	F2 66 0F D6 /r is 66 + MOVDQ2Q always.
			//	66 F2 0F D6 /r is 66 + MOVDQ2Q always.
			//	F3 66 0F D6 /r is 66 + MOVQ2DQ always.
			//	66 F3 0F D6 /r is 66 + MOVQ2DQ always.
			//	F2 F3 0F D6 /r is F2 + MOVQ2DQ always.
			//	F3 F2 0F D6 /r is F3 + MOVQ2DQ in Intel xed, but F2 + MOVQ2DQ in GNU libopcodes.
			//	Adding 66 anywhere in the prefix section of the
			//	last two cases does not change the outcome.
			//
			// Finally, what if there is a variant in which 66 is a mandatory
			// prefix rather than an operand size override, but we know of
			// no corresponding F2/F3 form, and we see both F2/F3 and 66.
			// Does F2/F3 still take priority, so that the result is an unknown
			// instruction, or does the 66 take priority, so that the extended
			// 66 instruction should be interpreted as having a REP/REPN prefix?
			// Intel xed does the former and GNU libopcodes does the latter.
			// We side with Intel xed, unless we are trying to match libopcodes
			// more closely during the comparison-based test suite.
			//
			// In 64-bit mode REX.W is another valid prefix to test for, but
			// there is less ambiguity about that. When present, REX.W is
			// always the first entry in the table.
			n := int(decoder[pc])
			pc++
			sawF3 := false
			for j := 0; j < n; j++ {
				prefix := Prefix(decoder[pc+2*j])
				if prefix.IsREX() {
					rexUsed |= prefix
					if rex&prefix == prefix {
						pc = int(decoder[pc+2*j+1])
						continue Decode
					}
					continue
				}
				ok := false
				if prefix == 0 {
					ok = true
				} else if prefix.IsREX() {
					rexUsed |= prefix
					if rex&prefix == prefix {
						ok = true
					}
				} else {
					if prefix == 0xF3 {
						sawF3 = true
					}
					switch prefix {
					case PrefixLOCK:
						if lockIndex >= 0 {
							inst.Prefix[lockIndex] |= PrefixImplicit
							ok = true
						}
					case PrefixREP, PrefixREPN:
						if repIndex >= 0 && inst.Prefix[repIndex]&0xFF == prefix {
							inst.Prefix[repIndex] |= PrefixImplicit
							ok = true
						}
						if gnuCompat && !ok && prefix == 0xF3 && repIndex >= 0 && (j+1 >= n || decoder[pc+2*(j+1)] != 0xF2) {
							// Check to see if earlier prefix F3 is present.
							for i := repIndex - 1; i >= 0; i-- {
								if inst.Prefix[i]&0xFF == prefix {
									inst.Prefix[i] |= PrefixImplicit
									ok = true
								}
							}
						}
						if gnuCompat && !ok && prefix == 0xF2 && repIndex >= 0 && !sawF3 && inst.Prefix[repIndex]&0xFF == 0xF3 {
							// Check to see if earlier prefix F2 is present.
							for i := repIndex - 1; i >= 0; i-- {
								if inst.Prefix[i]&0xFF == prefix {
									inst.Prefix[i] |= PrefixImplicit
									ok = true
								}
							}
						}
					case PrefixCS, PrefixDS, PrefixES, PrefixFS, PrefixGS, PrefixSS:
						if segIndex >= 0 && inst.Prefix[segIndex]&0xFF == prefix {
							inst.Prefix[segIndex] |= PrefixImplicit
							ok = true
						}
					case PrefixDataSize:
						// Looking for 66 mandatory prefix.
						// The F2/F3 mandatory prefixes take priority when both are present.
						// If we got this far in the xCondPrefix table and an F2/F3 is present,
						// it means the table didn't have any entry for that prefix. But if 66 has
						// special meaning, perhaps F2/F3 have special meaning that we don't know.
						// Intel xed works this way, treating the F2/F3 as inhibiting the 66.
						// GNU libopcodes allows the 66 to match. We do what Intel xed does
						// except in gnuCompat mode.
						if repIndex >= 0 && !gnuCompat {
							inst.Op = 0
							break Decode
						}
						if dataSizeIndex >= 0 {
							inst.Prefix[dataSizeIndex] |= PrefixImplicit
							ok = true
						}
					case PrefixAddrSize:
						if addrSizeIndex >= 0 {
							inst.Prefix[addrSizeIndex] |= PrefixImplicit
							ok = true
						}
					}
				}
				if ok {
					pc = int(decoder[pc+2*j+1])
					continue Decode
				}
			}
			inst.Op = 0
			break Decode

		case xCondSlashR:
			pc = int(decoder[pc+regop&7])

		// Input.

		case xReadSlashR:
			// done above

		case xReadIb:
			if pos >= len(src) {
				return truncated(src, mode)
			}
			imm8 = int8(src[pos])
			pos++

		case xReadIw:
			if pos+2 > len(src) {
				return truncated(src, mode)
			}
			imm = int64(binary.LittleEndian.Uint16(src[pos:]))
			pos += 2

		case xReadId:
			if pos+4 > len(src) {
				return truncated(src, mode)
			}
			imm = int64(binary.LittleEndian.Uint32(src[pos:]))
			pos += 4

		case xReadIo:
			if pos+8 > len(src) {
				return truncated(src, mode)
			}
			imm = int64(binary.LittleEndian.Uint64(src[pos:]))
			pos += 8

		case xReadCb:
			if pos >= len(src) {
				return truncated(src, mode)
			}
			immc = int64(src[pos])
			pos++

		case xReadCw:
			if pos+2 > len(src) {
				return truncated(src, mode)
			}
			immc = int64(binary.LittleEndian.Uint16(src[pos:]))
			pos += 2

		case xReadCm:
			if addrMode == 16 {
				if pos+2 > len(src) {
					return truncated(src, mode)
				}
				immc = int64(binary.LittleEndian.Uint16(src[pos:]))
				pos += 2
			} else if addrMode == 32 {
				if pos+4 > len(src) {
					return truncated(src, mode)
				}
				immc = int64(binary.LittleEndian.Uint32(src[pos:]))
				pos += 4
			} else {
				if pos+8 > len(src) {
					return truncated(src, mode)
				}
				immc = int64(binary.LittleEndian.Uint64(src[pos:]))
				pos += 8
			}
		case xReadCd:
			if pos+4 > len(src) {
				return truncated(src, mode)
			}
			immc = int64(binary.LittleEndian.Uint32(src[pos:]))
			pos += 4

		case xReadCp:
			if pos+6 > len(src) {
				return truncated(src, mode)
			}
			w := binary.LittleEndian.Uint32(src[pos:])
			w2 := binary.LittleEndian.Uint16(src[pos+4:])
			immc = int64(w2)<<32 | int64(w)
			pos += 6

		// Output.

		case xSetOp:
			inst.Op = Op(decoder[pc])
			pc++

		case xArg1,
			xArg3,
			xArgAL,
			xArgAX,
			xArgCL,
			xArgCS,
			xArgDS,
			xArgDX,
			xArgEAX,
			xArgEDX,
			xArgES,
			xArgFS,
			xArgGS,
			xArgRAX,
			xArgRDX,
			xArgSS,
			xArgST,
			xArgXMM0:
			inst.Args[narg] = fixedArg[x]
			narg++

		case xArgImm8:
			inst.Args[narg] = Imm(imm8)
			narg++

		case xArgImm8u:
			inst.Args[narg] = Imm(uint8(imm8))
			narg++

		case xArgImm16:
			inst.Args[narg] = Imm(int16(imm))
			narg++

		case xArgImm16u:
			inst.Args[narg] = Imm(uint16(imm))
			narg++

		case xArgImm32:
			inst.Args[narg] = Imm(int32(imm))
			narg++

		case xArgImm64:
			inst.Args[narg] = Imm(imm)
			narg++

		case xArgM,
			xArgM128,
			xArgM1428byte,
			xArgM16,
			xArgM16and16,
			xArgM16and32,
			xArgM16and64,
			xArgM16colon16,
			xArgM16colon32,
			xArgM16colon64,
			xArgM16int,
			xArgM2byte,
			xArgM32,
			xArgM32and32,
			xArgM32fp,
			xArgM32int,
			xArgM512byte,
			xArgM64,
			xArgM64fp,
			xArgM64int,
			xArgM8,
			xArgM80bcd,
			xArgM80dec,
			xArgM80fp,
			xArgM94108byte,
			xArgMem:
			if !haveMem {
				inst.Op = 0
				break Decode
			}
			inst.Args[narg] = mem
			inst.MemBytes = int(memBytes[decodeOp(x)])
			narg++

		case xArgPtr16colon16:
			inst.Args[narg] = Imm(immc >> 16)
			inst.Args[narg+1] = Imm(immc & (1<<16 - 1))
			narg += 2

		case xArgPtr16colon32:
			inst.Args[narg] = Imm(immc >> 32)
			inst.Args[narg+1] = Imm(immc & (1<<32 - 1))
			narg += 2

		case xArgMoffs8, xArgMoffs16, xArgMoffs32, xArgMoffs64:
			// TODO(rsc): Can address be 64 bits?
			mem = Mem{Disp: int64(immc)}
			if segIndex >= 0 {
				mem.Segment = prefixToSegment(inst.Prefix[segIndex])
				inst.Prefix[segIndex] |= PrefixImplicit
			}
			inst.Args[narg] = mem
			inst.MemBytes = int(memBytes[decodeOp(x)])
			narg++

		case xArgR8, xArgR16, xArgR32, xArgR64, xArgXmm, xArgXmm1, xArgDR0dashDR7:
			base := baseReg[x]
			index := Reg(regop)
			if rex != 0 && base == AL && index >= 4 {
				rexUsed |= PrefixREX
				index -= 4
				base = SPB
			}
			inst.Args[narg] = base + index
			narg++

		case xArgMm, xArgMm1, xArgTR0dashTR7:
			inst.Args[narg] = baseReg[x] + Reg(regop&7)
			narg++

		case xArgCR0dashCR7:
			// AMD documents an extension that the LOCK prefix
			// can be used in place of a REX prefix in order to access
			// CR8 from 32-bit mode. The LOCK prefix is allowed in
			// all modes, provided the corresponding CPUID bit is set.
			if lockIndex >= 0 {
				inst.Prefix[lockIndex] |= PrefixImplicit
				regop += 8
			}
			inst.Args[narg] = CR0 + Reg(regop)
			narg++

		case xArgSreg:
			regop &= 7
			if regop >= 6 {
				inst.Op = 0
				break Decode
			}
			inst.Args[narg] = ES + Reg(regop)
			narg++

		case xArgRmf16, xArgRmf32, xArgRmf64:
			base := baseReg[x]
			index := Reg(modrm & 07)
			if rex&PrefixREXB != 0 {
				rexUsed |= PrefixREXB
				index += 8
			}
			inst.Args[narg] = base + index
			narg++

		case xArgR8op, xArgR16op, xArgR32op, xArgR64op, xArgSTi:
			n := inst.Opcode >> uint(opshift+8) & 07
			base := baseReg[x]
			index := Reg(n)
			if rex&PrefixREXB != 0 && decodeOp(x) != xArgSTi {
				rexUsed |= PrefixREXB
				index += 8
			}
			if rex != 0 && base == AL && index >= 4 {
				rexUsed |= PrefixREX
				index -= 4
				base = SPB
			}
			inst.Args[narg] = base + index
			narg++

		case xArgRM8, xArgRM16, xArgRM32, xArgRM64, xArgR32M16, xArgR32M8, xArgR64M16,
			xArgMmM32, xArgMmM64, xArgMm2M64,
			xArgXmm2M16, xArgXmm2M32, xArgXmm2M64, xArgXmmM64, xArgXmmM128, xArgXmmM32, xArgXmm2M128:
			if haveMem {
				inst.Args[narg] = mem
				inst.MemBytes = int(memBytes[decodeOp(x)])
			} else {
				base := baseReg[x]
				index := Reg(rm)
				switch decodeOp(x) {
				case xArgMmM32, xArgMmM64, xArgMm2M64:
					// There are only 8 MMX registers, so these ignore the REX.X bit.
					index &= 7
				case xArgRM8:
					if rex != 0 && index >= 4 {
						rexUsed |= PrefixREX
						index -= 4
						base = SPB
					}
				}
				inst.Args[narg] = base + index
			}
			narg++

		case xArgMm2: // register only; TODO(rsc): Handle with tag modrm_regonly tag
			if haveMem {
				inst.Op = 0
				break Decode
			}
			inst.Args[narg] = baseReg[x] + Reg(rm&7)
			narg++

		case xArgXmm2: // register only; TODO(rsc): Handle with tag modrm_regonly tag
			if haveMem {
				inst.Op = 0
				break Decode
			}
			inst.Args[narg] = baseReg[x] + Reg(rm)
			narg++

		case xArgRel8:
			inst.Args[narg] = Rel(int8(immc))
			narg++

		case xArgRel16:
			inst.Args[narg] = Rel(int16(immc))
			narg++

		case xArgRel32:
			inst.Args[narg] = Rel(int32(immc))
			narg++
		}
	}

	if inst.Op == 0 {
		// Invalid instruction.
		if nprefix > 0 {
			return instPrefix(src[0], mode) // invalid instruction
		}
		return Inst{Len: pos}, ErrUnrecognized
	}

	// Matched! Hooray!

	// 90 decodes as XCHG EAX, EAX but is NOP.
	// 66 90 decodes as XCHG AX, AX and is NOP too.
	// 48 90 decodes as XCHG RAX, RAX and is NOP too.
	// 43 90 decodes as XCHG R8D, EAX and is *not* NOP.
	// F3 90 decodes as REP XCHG EAX, EAX but is PAUSE.
	// It's all too special to handle in the decoding tables, at least for now.
	if inst.Op == XCHG && inst.Opcode>>24 == 0x90 {
		if inst.Args[0] == RAX || inst.Args[0] == EAX || inst.Args[0] == AX {
			inst.Op = NOP
			if dataSizeIndex >= 0 {
				inst.Prefix[dataSizeIndex] &^= PrefixImplicit
			}
			inst.Args[0] = nil
			inst.Args[1] = nil
		}
		if repIndex >= 0 && inst.Prefix[repIndex] == 0xF3 {
			inst.Prefix[repIndex] |= PrefixImplicit
			inst.Op = PAUSE
			inst.Args[0] = nil
			inst.Args[1] = nil
		} else if gnuCompat {
			for i := nprefix - 1; i >= 0; i-- {
				if inst.Prefix[i]&0xFF == 0xF3 {
					inst.Prefix[i] |= PrefixImplicit
					inst.Op = PAUSE
					inst.Args[0] = nil
					inst.Args[1] = nil
					break
				}
			}
		}
	}

	// defaultSeg returns the default segment for an implicit
	// memory reference: the final override if present, or else DS.
	defaultSeg := func() Reg {
		if segIndex >= 0 {
			inst.Prefix[segIndex] |= PrefixImplicit
			return prefixToSegment(inst.Prefix[segIndex])
		}
		return DS
	}

	// Add implicit arguments not present in the tables.
	// Normally we shy away from making implicit arguments explicit,
	// following the Intel manuals, but adding the arguments seems
	// the best way to express the effect of the segment override prefixes.
	// TODO(rsc): Perhaps add these to the tables and
	// create bytecode instructions for them.
	usedAddrSize := false
	switch inst.Op {
	case INSB, INSW, INSD:
		inst.Args[0] = Mem{Segment: ES, Base: baseRegForBits(addrMode) + DI - AX}
		inst.Args[1] = DX
		usedAddrSize = true

	case OUTSB, OUTSW, OUTSD:
		inst.Args[0] = DX
		inst.Args[1] = Mem{Segment: defaultSeg(), Base: baseRegForBits(addrMode) + SI - AX}
		usedAddrSize = true

	case MOVSB, MOVSW, MOVSD, MOVSQ:
		inst.Args[0] = Mem{Segment: ES, Base: baseRegForBits(addrMode) + DI - AX}
		inst.Args[1] = Mem{Segment: defaultSeg(), Base: baseRegForBits(addrMode) + SI - AX}
		usedAddrSize = true

	case CMPSB, CMPSW, CMPSD, CMPSQ:
		inst.Args[0] = Mem{Segment: defaultSeg(), Base: baseRegForBits(addrMode) + SI - AX}
		inst.Args[1] = Mem{Segment: ES, Base: baseRegForBits(addrMode) + DI - AX}
		usedAddrSize = true

	case LODSB, LODSW, LODSD, LODSQ:
		switch inst.Op {
		case LODSB:
			inst.Args[0] = AL
		case LODSW:
			inst.Args[0] = AX
		case LODSD:
			inst.Args[0] = EAX
		case LODSQ:
			inst.Args[0] = RAX
		}
		inst.Args[1] = Mem{Segment: defaultSeg(), Base: baseRegForBits(addrMode) + SI - AX}
		usedAddrSize = true

	case STOSB, STOSW, STOSD, STOSQ:
		inst.Args[0] = Mem{Segment: ES, Base: baseRegForBits(addrMode) + DI - AX}
		switch inst.Op {
		case STOSB:
			inst.Args[1] = AL
		case STOSW:
			inst.Args[1] = AX
		case STOSD:
			inst.Args[1] = EAX
		case STOSQ:
			inst.Args[1] = RAX
		}
		usedAddrSize = true

	case SCASB, SCASW, SCASD, SCASQ:
		inst.Args[1] = Mem{Segment: ES, Base: baseRegForBits(addrMode) + DI - AX}
		switch inst.Op {
		case SCASB:
			inst.Args[0] = AL
		case SCASW:
			inst.Args[0] = AX
		case SCASD:
			inst.Args[0] = EAX
		case SCASQ:
			inst.Args[0] = RAX
		}
		usedAddrSize = true

	case XLATB:
		inst.Args[0] = Mem{Segment: defaultSeg(), Base: baseRegForBits(addrMode) + BX - AX}
		usedAddrSize = true
	}

	// If we used the address size annotation to construct the
	// argument list, mark that prefix as implicit: it doesn't need
	// to be shown when printing the instruction.
	if haveMem || usedAddrSize {
		if addrSizeIndex >= 0 {
			inst.Prefix[addrSizeIndex] |= PrefixImplicit
		}
	}

	// Similarly, if there's some memory operand, the segment
	// will be shown there and doesn't need to be shown as an
	// explicit prefix.
	if haveMem {
		if segIndex >= 0 {
			inst.Prefix[segIndex] |= PrefixImplicit
		}
	}

	// Branch predict prefixes are overloaded segment prefixes,
	// since segment prefixes don't make sense on conditional jumps.
	// Rewrite final instance to prediction prefix.
	// The set of instructions to which the prefixes apply (other then the
	// Jcc conditional jumps) is not 100% clear from the manuals, but
	// the disassemblers seem to agree about the LOOP and JCXZ instructions,
	// so we'll follow along.
	// TODO(rsc): Perhaps this instruction class should be derived from the CSV.
	if isCondJmp[inst.Op] || isLoop[inst.Op] || inst.Op == JCXZ || inst.Op == JECXZ || inst.Op == JRCXZ {
	PredictLoop:
		for i := nprefix - 1; i >= 0; i-- {
			p := inst.Prefix[i]
			switch p & 0xFF {
			case PrefixCS:
				inst.Prefix[i] = PrefixPN
				break PredictLoop
			case PrefixDS:
				inst.Prefix[i] = PrefixPT
				break PredictLoop
			}
		}
	}

	// The BND prefix is part of the Intel Memory Protection Extensions (MPX).
	// A REPN applied to certain control transfers is a BND prefix to bound
	// the range of possible destinations. There's surprisingly little documentation
	// about this, so we just do what libopcodes and xed agree on.
	// In particular, it's unclear why a REPN applied to LOOP or JCXZ instructions
	// does not turn into a BND.
	// TODO(rsc): Perhaps this instruction class should be derived from the CSV.
	if isCondJmp[inst.Op] || inst.Op == JMP || inst.Op == CALL || inst.Op == RET {
		for i := nprefix - 1; i >= 0; i-- {
			p := inst.Prefix[i]
			if p&^PrefixIgnored == PrefixREPN {
				inst.Prefix[i] = PrefixBND
				break
			}
		}
	}

	// The LOCK prefix only applies to certain instructions, and then only
	// to instances of the instruction with a memory destination.
	// Other uses of LOCK are invalid and cause a processor exception,
	// in contrast to the "just ignore it" spirit applied to all other prefixes.
	// Mark invalid lock prefixes.
	hasLock := false
	if lockIndex >= 0 && inst.Prefix[lockIndex]&PrefixImplicit == 0 {
		switch inst.Op {
		// TODO(rsc): Perhaps this instruction class should be derived from the CSV.
		case ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCHG8B, CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, XCHG:
			if isMem(inst.Args[0]) {
				hasLock = true
				break
			}
			fallthrough
		default:
			inst.Prefix[lockIndex] |= PrefixInvalid
		}
	}

	// In certain cases, all of which require a memory destination,
	// the REPN and REP prefixes are interpreted as XACQUIRE and XRELEASE
	// from the Intel Transactional Synchroniation Extensions (TSX).
	//
	// The specific rules are:
	// (1) Any instruction with a valid LOCK prefix can have XACQUIRE or XRELEASE.
	// (2) Any XCHG, which always has an implicit LOCK, can have XACQUIRE or XRELEASE.
	// (3) Any 0x88-, 0x89-, 0xC6-, or 0xC7-opcode MOV can have XRELEASE.
	if isMem(inst.Args[0]) {
		if inst.Op == XCHG {
			hasLock = true
		}

		for i := len(inst.Prefix) - 1; i >= 0; i-- {
			p := inst.Prefix[i] &^ PrefixIgnored
			switch p {
			case PrefixREPN:
				if hasLock {
					inst.Prefix[i] = inst.Prefix[i]&PrefixIgnored | PrefixXACQUIRE
				}

			case PrefixREP:
				if hasLock {
					inst.Prefix[i] = inst.Prefix[i]&PrefixIgnored | PrefixXRELEASE
				}

				if inst.Op == MOV {
					op := (inst.Opcode >> 24) &^ 1
					if op == 0x88 || op == 0xC6 {
						inst.Prefix[i] = inst.Prefix[i]&PrefixIgnored | PrefixXRELEASE
					}
				}
			}
		}
	}

	// If REP is used on a non-REP-able instruction, mark the prefix as ignored.
	if repIndex >= 0 {
		switch inst.Prefix[repIndex] {
		case PrefixREP, PrefixREPN:
			switch inst.Op {
			// According to the manuals, the REP/REPE prefix applies to all of these,
			// while the REPN applies only to some of them. However, both libopcodes
			// and xed show both prefixes explicitly for all instructions, so we do the same.
			// TODO(rsc): Perhaps this instruction class should be derived from the CSV.
			case INSB, INSW, INSD,
				MOVSB, MOVSW, MOVSD, MOVSQ,
				OUTSB, OUTSW, OUTSD,
				LODSB, LODSW, LODSD, LODSQ,
				CMPSB, CMPSW, CMPSD, CMPSQ,
				SCASB, SCASW, SCASD, SCASQ,
				STOSB, STOSW, STOSD, STOSQ:
				// ok
			default:
				inst.Prefix[repIndex] |= PrefixIgnored
			}
		}
	}

	// If REX was present, mark implicit if all the 1 bits were consumed.
	if rexIndex >= 0 {
		if rexUsed != 0 {
			rexUsed |= PrefixREX
		}
		if rex&^rexUsed == 0 {
			inst.Prefix[rexIndex] |= PrefixImplicit
		}
	}

	inst.DataSize = dataMode
	inst.AddrSize = addrMode
	inst.Mode = mode
	inst.Len = pos
	return inst, nil
}

var errInternal = errors.New("internal error")

// addr16 records the eight 16-bit addressing modes.
var addr16 = [8]Mem{
	{Base: BX, Scale: 1, Index: SI},
	{Base: BX, Scale: 1, Index: DI},
	{Base: BP, Scale: 1, Index: SI},
	{Base: BP, Scale: 1, Index: DI},
	{Base: SI},
	{Base: DI},
	{Base: BP},
	{Base: BX},
}

// baseReg returns the base register for a given register size in bits.
func baseRegForBits(bits int) Reg {
	switch bits {
	case 8:
		return AL
	case 16:
		return AX
	case 32:
		return EAX
	case 64:
		return RAX
	}
	return 0
}

// baseReg records the base register for argument types that specify
// a range of registers indexed by op, regop, or rm.
var baseReg = [...]Reg{
	xArgDR0dashDR7: DR0,
	xArgMm1:        M0,
	xArgMm2:        M0,
	xArgMm2M64:     M0,
	xArgMm:         M0,
	xArgMmM32:      M0,
	xArgMmM64:      M0,
	xArgR16:        AX,
	xArgR16op:      AX,
	xArgR32:        EAX,
	xArgR32M16:     EAX,
	xArgR32M8:      EAX,
	xArgR32op:      EAX,
	xArgR64:        RAX,
	xArgR64M16:     RAX,
	xArgR64op:      RAX,
	xArgR8:         AL,
	xArgR8op:       AL,
	xArgRM16:       AX,
	xArgRM32:       EAX,
	xArgRM64:       RAX,
	xArgRM8:        AL,
	xArgRmf16:      AX,
	xArgRmf32:      EAX,
	xArgRmf64:      RAX,
	xArgSTi:        F0,
	xArgTR0dashTR7: TR0,
	xArgXmm1:       X0,
	xArgXmm2:       X0,
	xArgXmm2M128:   X0,
	xArgXmm2M16:    X0,
	xArgXmm2M32:    X0,
	xArgXmm2M64:    X0,
	xArgXmm:        X0,
	xArgXmmM128:    X0,
	xArgXmmM32:     X0,
	xArgXmmM64:     X0,
}

// prefixToSegment returns the segment register
// corresponding to a particular segment prefix.
func prefixToSegment(p Prefix) Reg {
	switch p &^ PrefixImplicit {
	case PrefixCS:
		return CS
	case PrefixDS:
		return DS
	case PrefixES:
		return ES
	case PrefixFS:
		return FS
	case PrefixGS:
		return GS
	case PrefixSS:
		return SS
	}
	return 0
}

// fixedArg records the fixed arguments corresponding to the given bytecodes.
var fixedArg = [...]Arg{
	xArg1:    Imm(1),
	xArg3:    Imm(3),
	xArgAL:   AL,
	xArgAX:   AX,
	xArgDX:   DX,
	xArgEAX:  EAX,
	xArgEDX:  EDX,
	xArgRAX:  RAX,
	xArgRDX:  RDX,
	xArgCL:   CL,
	xArgCS:   CS,
	xArgDS:   DS,
	xArgES:   ES,
	xArgFS:   FS,
	xArgGS:   GS,
	xArgSS:   SS,
	xArgST:   F0,
	xArgXMM0: X0,
}

// memBytes records the size of the memory pointed at
// by a memory argument of the given form.
var memBytes = [...]int8{
	xArgM128:       128 / 8,
	xArgM16:        16 / 8,
	xArgM16and16:   (16 + 16) / 8,
	xArgM16colon16: (16 + 16) / 8,
	xArgM16colon32: (16 + 32) / 8,
	xArgM16int:     16 / 8,
	xArgM2byte:     2,
	xArgM32:        32 / 8,
	xArgM32and32:   (32 + 32) / 8,
	xArgM32fp:      32 / 8,
	xArgM32int:     32 / 8,
	xArgM64:        64 / 8,
	xArgM64fp:      64 / 8,
	xArgM64int:     64 / 8,
	xArgMm2M64:     64 / 8,
	xArgMmM32:      32 / 8,
	xArgMmM64:      64 / 8,
	xArgMoffs16:    16 / 8,
	xArgMoffs32:    32 / 8,
	xArgMoffs64:    64 / 8,
	xArgMoffs8:     8 / 8,
	xArgR32M16:     16 / 8,
	xArgR32M8:      8 / 8,
	xArgR64M16:     16 / 8,
	xArgRM16:       16 / 8,
	xArgRM32:       32 / 8,
	xArgRM64:       64 / 8,
	xArgRM8:        8 / 8,
	xArgXmm2M128:   128 / 8,
	xArgXmm2M16:    16 / 8,
	xArgXmm2M32:    32 / 8,
	xArgXmm2M64:    64 / 8,
	xArgXmm:        128 / 8,
	xArgXmmM128:    128 / 8,
	xArgXmmM32:     32 / 8,
	xArgXmmM64:     64 / 8,
}

// isCondJmp records the conditional jumps.
var isCondJmp = [maxOp + 1]bool{
	JA:  true,
	JAE: true,
	JB:  true,
	JBE: true,
	JE:  true,
	JG:  true,
	JGE: true,
	JL:  true,
	JLE: true,
	JNE: true,
	JNO: true,
	JNP: true,
	JNS: true,
	JO:  true,
	JP:  true,
	JS:  true,
}

// isLoop records the loop operators.
var isLoop = [maxOp + 1]bool{
	LOOP:   true,
	LOOPE:  true,
	LOOPNE: true,
	JECXZ:  true,
	JRCXZ:  true,
}
                                                                                                                                                                                                                                                                                                                                                                                                                                       root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/decode_test.go                                        0100644 0000000 0000000 00000003141 12600426226 022006  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"encoding/hex"
	"io/ioutil"
	"strconv"
	"strings"
	"testing"
)

func TestDecode(t *testing.T) {
	data, err := ioutil.ReadFile("testdata/decode.txt")
	if err != nil {
		t.Fatal(err)
	}
	all := string(data)
	for strings.Contains(all, "\t\t") {
		all = strings.Replace(all, "\t\t", "\t", -1)
	}
	for _, line := range strings.Split(all, "\n") {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}
		f := strings.SplitN(line, "\t", 4)
		i := strings.Index(f[0], "|")
		if i < 0 {
			t.Errorf("parsing %q: missing | separator", f[0])
			continue
		}
		if i%2 != 0 {
			t.Errorf("parsing %q: misaligned | separator", f[0])
		}
		size := i / 2
		code, err := hex.DecodeString(f[0][:i] + f[0][i+1:])
		if err != nil {
			t.Errorf("parsing %q: %v", f[0], err)
			continue
		}
		mode, err := strconv.Atoi(f[1])
		if err != nil {
			t.Errorf("invalid mode %q in: %s", f[1], line)
			continue
		}
		syntax, asm := f[2], f[3]
		inst, err := Decode(code, mode)
		var out string
		if err != nil {
			out = "error: " + err.Error()
		} else {
			switch syntax {
			case "gnu":
				out = GNUSyntax(inst)
			case "intel":
				out = IntelSyntax(inst)
			case "plan9":
				out = Plan9Syntax(inst, 0, nil)
			default:
				t.Errorf("unknown syntax %q", syntax)
				continue
			}
		}
		if out != asm || inst.Len != size {
			t.Errorf("Decode(%s) [%s] = %s, %d, want %s, %d", f[0], syntax, out, inst.Len, asm, size)
		}
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                               root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/ext_test.go                                           0100644 0000000 0000000 00000050163 12600426226 021371  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Support for testing against external disassembler program.

package x86asm

import (
	"bufio"
	"bytes"
	"encoding/hex"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"os"
	"os/exec"
	"regexp"
	"runtime"
	"strings"
	"testing"
	"time"
)

var (
	printTests = flag.Bool("printtests", false, "print test cases that exercise new code paths")
	dumpTest   = flag.Bool("dump", false, "dump all encodings")
	mismatch   = flag.Bool("mismatch", false, "log allowed mismatches")
	longTest   = flag.Bool("long", false, "long test")
	keep       = flag.Bool("keep", false, "keep object files around")
	debug      = false
)

// A ExtInst represents a single decoded instruction parsed
// from an external disassembler's output.
type ExtInst struct {
	addr uint32
	enc  [32]byte
	nenc int
	text string
}

func (r ExtInst) String() string {
	return fmt.Sprintf("%#x: % x: %s", r.addr, r.enc, r.text)
}

// An ExtDis is a connection between an external disassembler and a test.
type ExtDis struct {
	Arch     int
	Dec      chan ExtInst
	File     *os.File
	Size     int
	KeepFile bool
	Cmd      *exec.Cmd
}

// Run runs the given command - the external disassembler - and returns
// a buffered reader of its standard output.
func (ext *ExtDis) Run(cmd ...string) (*bufio.Reader, error) {
	if *keep {
		log.Printf("%s\n", strings.Join(cmd, " "))
	}
	ext.Cmd = exec.Command(cmd[0], cmd[1:]...)
	out, err := ext.Cmd.StdoutPipe()
	if err != nil {
		return nil, fmt.Errorf("stdoutpipe: %v", err)
	}
	if err := ext.Cmd.Start(); err != nil {
		return nil, fmt.Errorf("exec: %v", err)
	}

	b := bufio.NewReaderSize(out, 1<<20)
	return b, nil
}

// Wait waits for the command started with Run to exit.
func (ext *ExtDis) Wait() error {
	return ext.Cmd.Wait()
}

// testExtDis tests a set of byte sequences against an external disassembler.
// The disassembler is expected to produce the given syntax and be run
// in the given architecture mode (16, 32, or 64-bit).
// The extdis function must start the external disassembler
// and then parse its output, sending the parsed instructions on ext.Dec.
// The generate function calls its argument f once for each byte sequence
// to be tested. The generate function itself will be called twice, and it must
// make the same sequence of calls to f each time.
// When a disassembly does not match the internal decoding,
// allowedMismatch determines whether this mismatch should be
// allowed, or else considered an error.
func testExtDis(
	t *testing.T,
	syntax string,
	arch int,
	extdis func(ext *ExtDis) error,
	generate func(f func([]byte)),
	allowedMismatch func(text string, size int, inst *Inst, dec ExtInst) bool,
) {
	start := time.Now()
	ext := &ExtDis{
		Dec:  make(chan ExtInst),
		Arch: arch,
	}
	errc := make(chan error)

	// First pass: write instructions to input file for external disassembler.
	file, f, size, err := writeInst(generate)
	if err != nil {
		t.Fatal(err)
	}
	ext.Size = size
	ext.File = f
	defer func() {
		f.Close()
		if !*keep {
			os.Remove(file)
		}
	}()

	// Second pass: compare disassembly against our decodings.
	var (
		totalTests  = 0
		totalSkips  = 0
		totalErrors = 0

		errors = make([]string, 0, 100) // sampled errors, at most cap
	)
	go func() {
		errc <- extdis(ext)
	}()
	generate(func(enc []byte) {
		dec, ok := <-ext.Dec
		if !ok {
			t.Errorf("decoding stream ended early")
			return
		}
		inst, text := disasm(syntax, arch, pad(enc))
		totalTests++
		if *dumpTest {
			fmt.Printf("%x -> %s [%d]\n", enc[:len(enc)], dec.text, dec.nenc)
		}
		if text != dec.text || inst.Len != dec.nenc {
			suffix := ""
			if allowedMismatch(text, size, &inst, dec) {
				totalSkips++
				if !*mismatch {
					return
				}
				suffix += " (allowed mismatch)"
			}
			totalErrors++
			if len(errors) >= cap(errors) {
				j := rand.Intn(totalErrors)
				if j >= cap(errors) {
					return
				}
				errors = append(errors[:j], errors[j+1:]...)
			}
			errors = append(errors, fmt.Sprintf("decode(%x) = %q, %d, want %q, %d%s", enc, text, inst.Len, dec.text, dec.nenc, suffix))
		}
	})

	if *mismatch {
		totalErrors -= totalSkips
	}

	for _, b := range errors {
		t.Log(b)
	}

	if totalErrors > 0 {
		t.Fail()
	}
	t.Logf("%d test cases, %d expected mismatches, %d failures; %.0f cases/second", totalTests, totalSkips, totalErrors, float64(totalTests)/time.Since(start).Seconds())

	if err := <-errc; err != nil {
		t.Fatal("external disassembler: %v", err)
	}

}

const start = 0x8000 // start address of text

// writeInst writes the generated byte sequences to a new file
// starting at offset start. That file is intended to be the input to
// the external disassembler.
func writeInst(generate func(func([]byte))) (file string, f *os.File, size int, err error) {
	f, err = ioutil.TempFile("", "x86map")
	if err != nil {
		return
	}

	file = f.Name()

	f.Seek(start, 0)
	w := bufio.NewWriter(f)
	defer w.Flush()
	size = 0
	generate(func(x []byte) {
		if len(x) > 16 {
			x = x[:16]
		}
		if debug {
			fmt.Printf("%#x: %x%x\n", start+size, x, pops[len(x):])
		}
		w.Write(x)
		w.Write(pops[len(x):])
		size += len(pops)
	})
	return file, f, size, nil
}

// 0x5F is a single-byte pop instruction.
// We pad the bytes we want decoded with enough 0x5Fs
// that no matter what state the instruction stream is in
// after reading our bytes, the pops will get us back to
// a forced instruction boundary.
var pops = []byte{
	0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f,
	0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f,
	0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f,
	0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f,
}

// pad pads the code sequenc with pops.
func pad(enc []byte) []byte {
	return append(enc[:len(enc):len(enc)], pops...)
}

// disasm returns the decoded instruction and text
// for the given source bytes, using the given syntax and mode.
func disasm(syntax string, mode int, src []byte) (inst Inst, text string) {
	// If printTests is set, we record the coverage value
	// before and after, and we write out the inputs for which
	// coverage went up, in the format expected in testdata/decode.text.
	// This produces a fairly small set of test cases that exercise nearly
	// all the code.
	var cover float64
	if *printTests {
		cover -= coverage()
	}

	inst, err := decode1(src, mode, syntax == "gnu")
	if err != nil {
		text = "error: " + err.Error()
	} else {
		switch syntax {
		case "gnu":
			text = GNUSyntax(inst)
		case "intel":
			text = IntelSyntax(inst)
		case "plan9":
			text = Plan9Syntax(inst, 0, nil)
		default:
			text = "error: unknown syntax " + syntax
		}
	}

	if *printTests {
		cover += coverage()
		if cover > 0 {
			max := len(src)
			if max > 16 && inst.Len <= 16 {
				max = 16
			}
			fmt.Printf("%x|%x\t%d\t%s\t%s\n", src[:inst.Len], src[inst.Len:max], mode, syntax, text)
		}
	}

	return
}

// coverage returns a floating point number denoting the
// test coverage until now. The number increases when new code paths are exercised,
// both in the Go program and in the decoder byte code.
func coverage() float64 {
	/*
		testing.Coverage is not in the main distribution.
		The implementation, which must go in package testing, is:

		// Coverage reports the current code coverage as a fraction in the range [0, 1].
		func Coverage() float64 {
			var n, d int64
			for _, counters := range cover.Counters {
				for _, c := range counters {
					if c > 0 {
						n++
					}
					d++
				}
			}
			if d == 0 {
				return 0
			}
			return float64(n) / float64(d)
		}
	*/

	var f float64
	// f += testing.Coverage()
	f += decodeCoverage()
	return f
}

func decodeCoverage() float64 {
	n := 0
	for _, t := range decoderCover {
		if t {
			n++
		}
	}
	return float64(1+n) / float64(1+len(decoderCover))
}

// Helpers for writing disassembler output parsers.

// isPrefix reports whether text is the name of an instruction prefix.
func isPrefix(text string) bool {
	return prefixByte[text] > 0
}

// prefixByte maps instruction prefix text to actual prefix byte values.
var prefixByte = map[string]byte{
	"es":       0x26,
	"cs":       0x2e,
	"ss":       0x36,
	"ds":       0x3e,
	"fs":       0x64,
	"gs":       0x65,
	"data16":   0x66,
	"addr16":   0x67,
	"lock":     0xf0,
	"repn":     0xf2,
	"repne":    0xf2,
	"rep":      0xf3,
	"repe":     0xf3,
	"xacquire": 0xf2,
	"xrelease": 0xf3,
	"bnd":      0xf2,
	"addr32":   0x66,
	"data32":   0x67,
}

// hasPrefix reports whether any of the space-separated words in the text s
// begins with any of the given prefixes.
func hasPrefix(s string, prefixes ...string) bool {
	for _, prefix := range prefixes {
		for s := s; s != ""; {
			if strings.HasPrefix(s, prefix) {
				return true
			}
			i := strings.Index(s, " ")
			if i < 0 {
				break
			}
			s = s[i+1:]
		}
	}
	return false
}

// contains reports whether the text s contains any of the given substrings.
func contains(s string, substrings ...string) bool {
	for _, sub := range substrings {
		if strings.Contains(s, sub) {
			return true
		}
	}
	return false
}

// isHex reports whether b is a hexadecimal character (0-9A-Fa-f).
func isHex(b byte) bool { return b == '0' || unhex[b] > 0 }

// parseHex parses the hexadecimal byte dump in hex,
// appending the parsed bytes to raw and returning the updated slice.
// The returned bool signals whether any invalid hex was found.
// Spaces and tabs between bytes are okay but any other non-hex is not.
func parseHex(hex []byte, raw []byte) ([]byte, bool) {
	hex = trimSpace(hex)
	for j := 0; j < len(hex); {
		for hex[j] == ' ' || hex[j] == '\t' {
			j++
		}
		if j >= len(hex) {
			break
		}
		if j+2 > len(hex) || !isHex(hex[j]) || !isHex(hex[j+1]) {
			return nil, false
		}
		raw = append(raw, unhex[hex[j]]<<4|unhex[hex[j+1]])
		j += 2
	}
	return raw, true
}

var unhex = [256]byte{
	'0': 0,
	'1': 1,
	'2': 2,
	'3': 3,
	'4': 4,
	'5': 5,
	'6': 6,
	'7': 7,
	'8': 8,
	'9': 9,
	'A': 10,
	'B': 11,
	'C': 12,
	'D': 13,
	'E': 14,
	'F': 15,
	'a': 10,
	'b': 11,
	'c': 12,
	'd': 13,
	'e': 14,
	'f': 15,
}

// index is like bytes.Index(s, []byte(t)) but avoids the allocation.
func index(s []byte, t string) int {
	i := 0
	for {
		j := bytes.IndexByte(s[i:], t[0])
		if j < 0 {
			return -1
		}
		i = i + j
		if i+len(t) > len(s) {
			return -1
		}
		for k := 1; k < len(t); k++ {
			if s[i+k] != t[k] {
				goto nomatch
			}
		}
		return i
	nomatch:
		i++
	}
}

// fixSpace rewrites runs of spaces, tabs, and newline characters into single spaces in s.
// If s must be rewritten, it is rewritten in place.
func fixSpace(s []byte) []byte {
	s = trimSpace(s)
	for i := 0; i < len(s); i++ {
		if s[i] == '\t' || s[i] == '\n' || i > 0 && s[i] == ' ' && s[i-1] == ' ' {
			goto Fix
		}
	}
	return s

Fix:
	b := s
	w := 0
	for i := 0; i < len(s); i++ {
		c := s[i]
		if c == '\t' || c == '\n' {
			c = ' '
		}
		if c == ' ' && w > 0 && b[w-1] == ' ' {
			continue
		}
		b[w] = c
		w++
	}
	if w > 0 && b[w-1] == ' ' {
		w--
	}
	return b[:w]
}

// trimSpace trims leading and trailing space from s, returning a subslice of s.
func trimSpace(s []byte) []byte {
	j := len(s)
	for j > 0 && (s[j-1] == ' ' || s[j-1] == '\t' || s[j-1] == '\n') {
		j--
	}
	i := 0
	for i < j && (s[i] == ' ' || s[i] == '\t') {
		i++
	}
	return s[i:j]
}

// pcrel and pcrelw match instructions using relative addressing mode.
var (
	pcrel  = regexp.MustCompile(`^((?:.* )?(?:j[a-z]+|call|ljmp|loopn?e?w?|xbegin)q?(?:,p[nt])?) 0x([0-9a-f]+)$`)
	pcrelw = regexp.MustCompile(`^((?:.* )?(?:callw|jmpw|xbeginw|ljmpw)(?:,p[nt])?) 0x([0-9a-f]+)$`)
)

// Generators.
//
// The test cases are described as functions that invoke a callback repeatedly,
// with a new input sequence each time. These helpers make writing those
// a little easier.

// hexCases generates the cases written in hexadecimal in the encoded string.
// Spaces in 'encoded' separate entire test cases, not individual bytes.
func hexCases(t *testing.T, encoded string) func(func([]byte)) {
	return func(try func([]byte)) {
		for _, x := range strings.Fields(encoded) {
			src, err := hex.DecodeString(x)
			if err != nil {
				t.Errorf("parsing %q: %v", x, err)
			}
			try(src)
		}
	}
}

// testdataCases generates the test cases recorded in testdata/decode.txt.
// It only uses the inputs; it ignores the answers recorded in that file.
func testdataCases(t *testing.T) func(func([]byte)) {
	var codes [][]byte
	data, err := ioutil.ReadFile("testdata/decode.txt")
	if err != nil {
		t.Fatal(err)
	}
	for _, line := range strings.Split(string(data), "\n") {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}
		f := strings.Fields(line)[0]
		i := strings.Index(f, "|")
		if i < 0 {
			t.Errorf("parsing %q: missing | separator", f)
			continue
		}
		if i%2 != 0 {
			t.Errorf("parsing %q: misaligned | separator", f)
		}
		code, err := hex.DecodeString(f[:i] + f[i+1:])
		if err != nil {
			t.Errorf("parsing %q: %v", f, err)
			continue
		}
		codes = append(codes, code)
	}

	return func(try func([]byte)) {
		for _, code := range codes {
			try(code)
		}
	}
}

// manyPrefixes generates all possible 2 combinations of nine chosen prefixes.
// The relative ordering of the prefixes within the combinations varies deterministically.
func manyPrefixes(try func([]byte)) {
	var prefixBytes = []byte{0x66, 0x67, 0xF0, 0xF2, 0xF3, 0x3E, 0x36, 0x66, 0x67}
	var enc []byte
	for i := 0; i < 1<<uint(len(prefixBytes)); i++ {
		enc = enc[:0]
		for j, p := range prefixBytes {
			if i&(1<<uint(j)) != 0 {
				enc = append(enc, p)
			}
		}
		if len(enc) > 0 {
			k := i % len(enc)
			enc[0], enc[k] = enc[k], enc[0]
		}
		try(enc)
	}
}

// basicPrefixes geneartes 8 different possible prefix cases: no prefix
// and then one each of seven different prefix bytes.
func basicPrefixes(try func([]byte)) {
	try(nil)
	for _, b := range []byte{0x66, 0x67, 0xF0, 0xF2, 0xF3, 0x3E, 0x36} {
		try([]byte{b})
	}
}

func rexPrefixes(try func([]byte)) {
	try(nil)
	for _, b := range []byte{0x40, 0x48, 0x43, 0x4C} {
		try([]byte{b})
	}
}

// concat takes two generators and returns a generator for the
// cross product of the two, concatenating the results from each.
func concat(gen1, gen2 func(func([]byte))) func(func([]byte)) {
	return func(try func([]byte)) {
		gen1(func(enc1 []byte) {
			gen2(func(enc2 []byte) {
				try(append(enc1[:len(enc1):len(enc1)], enc2...))
			})
		})
	}
}

// concat3 takes three generators and returns a generator for the
// cross product of the three, concatenating the results from each.
func concat3(gen1, gen2, gen3 func(func([]byte))) func(func([]byte)) {
	return func(try func([]byte)) {
		gen1(func(enc1 []byte) {
			gen2(func(enc2 []byte) {
				gen3(func(enc3 []byte) {
					try(append(append(enc1[:len(enc1):len(enc1)], enc2...), enc3...))
				})
			})
		})
	}
}

// concat4 takes four generators and returns a generator for the
// cross product of the four, concatenating the results from each.
func concat4(gen1, gen2, gen3, gen4 func(func([]byte))) func(func([]byte)) {
	return func(try func([]byte)) {
		gen1(func(enc1 []byte) {
			gen2(func(enc2 []byte) {
				gen3(func(enc3 []byte) {
					gen4(func(enc4 []byte) {
						try(append(append(append(enc1[:len(enc1):len(enc1)], enc2...), enc3...), enc4...))
					})
				})
			})
		})
	}
}

// filter generates the sequences from gen that satisfy ok.
func filter(gen func(func([]byte)), ok func([]byte) bool) func(func([]byte)) {
	return func(try func([]byte)) {
		gen(func(enc []byte) {
			if ok(enc) {
				try(enc)
			}
		})
	}
}

// enum8bit generates all possible 1-byte sequences, followed by distinctive padding.
func enum8bit(try func([]byte)) {
	for i := 0; i < 1<<8; i++ {
		try([]byte{byte(i), 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88})
	}
}

// enum8bit generates all possible 2-byte sequences, followed by distinctive padding.
func enum16bit(try func([]byte)) {
	for i := 0; i < 1<<16; i++ {
		try([]byte{byte(i), byte(i >> 8), 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88})
	}
}

// enum24bit generates all possible 3-byte sequences, followed by distinctive padding.
func enum24bit(try func([]byte)) {
	for i := 0; i < 1<<24; i++ {
		try([]byte{byte(i), byte(i >> 8), byte(i >> 16), 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88})
	}
}

// enumModRM generates all possible modrm bytes and, for modrm values that indicate
// a following sib byte, all possible modrm, sib combinations.
func enumModRM(try func([]byte)) {
	for i := 0; i < 256; i++ {
		if (i>>3)&07 == 04 && i>>6 != 3 { // has sib
			for j := 0; j < 256; j++ {
				try([]byte{0, byte(i), byte(j), 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88}) // byte encodings
				try([]byte{1, byte(i), byte(j), 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88}) // word encodings
			}
		} else {
			try([]byte{0, byte(i), 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88}) // byte encodings
			try([]byte{1, byte(i), 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88}) // word encodings
		}
	}
}

// fixed generates the single case b.
// It's mainly useful to prepare an argument for concat or concat3.
func fixed(b ...byte) func(func([]byte)) {
	return func(try func([]byte)) {
		try(b)
	}
}

// testBasic runs the given test function with cases all using opcode as the initial opcode bytes.
// It runs three phases:
//
// First, zero-or-one prefixes followed by opcode followed by all possible 1-byte values.
// If in -short mode, that's all.
//
// Second, zero-or-one prefixes followed by opcode followed by all possible 2-byte values.
// If not in -long mode, that's all. This phase and the next run in parallel with other tests
// (using t.Parallel).
//
// Finally, opcode followed by all possible 3-byte values. The test can take a very long time
// and prints progress messages to package log.
func testBasic(t *testing.T, testfn func(*testing.T, func(func([]byte))), opcode ...byte) {
	testfn(t, concat3(basicPrefixes, fixed(opcode...), enum8bit))
	if testing.Short() {
		return
	}

	t.Parallel()
	testfn(t, concat3(basicPrefixes, fixed(opcode...), enum16bit))
	if !*longTest {
		return
	}

	name := caller(2)
	op1 := make([]byte, len(opcode)+1)
	copy(op1, opcode)
	for i := 0; i < 256; i++ {
		log.Printf("%s 24-bit: %d/256\n", name, i)
		op1[len(opcode)] = byte(i)
		testfn(t, concat(fixed(op1...), enum16bit))
	}
}

func testBasicREX(t *testing.T, testfn func(*testing.T, func(func([]byte))), opcode ...byte) {
	testfn(t, filter(concat4(basicPrefixes, rexPrefixes, fixed(opcode...), enum8bit), isValidREX))
	if testing.Short() {
		return
	}

	t.Parallel()
	testfn(t, filter(concat4(basicPrefixes, rexPrefixes, fixed(opcode...), enum16bit), isValidREX))
	if !*longTest {
		return
	}

	name := caller(2)
	op1 := make([]byte, len(opcode)+1)
	copy(op1, opcode)
	for i := 0; i < 256; i++ {
		log.Printf("%s 24-bit: %d/256\n", name, i)
		op1[len(opcode)] = byte(i)
		testfn(t, filter(concat3(rexPrefixes, fixed(op1...), enum16bit), isValidREX))
	}
}

// testPrefix runs the given test function for all many prefix possibilities
// followed by all possible 1-byte sequences.
//
// If in -long mode, it then runs a test of all the prefix possibilities followed
// by all possible 2-byte sequences.
func testPrefix(t *testing.T, testfn func(*testing.T, func(func([]byte)))) {
	t.Parallel()
	testfn(t, concat(manyPrefixes, enum8bit))
	if testing.Short() || !*longTest {
		return
	}

	name := caller(2)
	for i := 0; i < 256; i++ {
		log.Printf("%s 16-bit: %d/256\n", name, i)
		testfn(t, concat3(manyPrefixes, fixed(byte(i)), enum8bit))
	}
}

func testPrefixREX(t *testing.T, testfn func(*testing.T, func(func([]byte)))) {
	t.Parallel()
	testfn(t, filter(concat3(manyPrefixes, rexPrefixes, enum8bit), isValidREX))
	if testing.Short() || !*longTest {
		return
	}

	name := caller(2)
	for i := 0; i < 256; i++ {
		log.Printf("%s 16-bit: %d/256\n", name, i)
		testfn(t, filter(concat4(manyPrefixes, rexPrefixes, fixed(byte(i)), enum8bit), isValidREX))
	}
}

func caller(skip int) string {
	pc, _, _, _ := runtime.Caller(skip)
	f := runtime.FuncForPC(pc)
	name := "?"
	if f != nil {
		name = f.Name()
		if i := strings.LastIndex(name, "."); i >= 0 {
			name = name[i+1:]
		}
	}
	return name
}

func isValidREX(x []byte) bool {
	i := 0
	for i < len(x) && isPrefixByte(x[i]) {
		i++
	}
	if i < len(x) && Prefix(x[i]).IsREX() {
		i++
		if i < len(x) {
			return !isPrefixByte(x[i]) && !Prefix(x[i]).IsREX()
		}
	}
	return true
}

func isPrefixByte(b byte) bool {
	switch b {
	case 0x26, 0x2E, 0x36, 0x3E, 0x64, 0x65, 0x66, 0x67, 0xF0, 0xF2, 0xF3:
		return true
	}
	return false
}
                                                                                                                                                                                                                                                                                                                                                                                                             root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/gnu.go                                                0100644 0000000 0000000 00000050777 12600426226 020336  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"fmt"
	"strings"
)

// GNUSyntax returns the GNU assembler syntax for the instruction, as defined by GNU binutils.
// This general form is often called ``AT&T syntax'' as a reference to AT&T System V Unix.
func GNUSyntax(inst Inst) string {
	// Rewrite instruction to mimic GNU peculiarities.
	// Note that inst has been passed by value and contains
	// no pointers, so any changes we make here are local
	// and will not propagate back out to the caller.

	// Adjust opcode [sic].
	switch inst.Op {
	case FDIV, FDIVR, FSUB, FSUBR, FDIVP, FDIVRP, FSUBP, FSUBRP:
		// DC E0, DC F0: libopcodes swaps FSUBR/FSUB and FDIVR/FDIV, at least
		// if you believe the Intel manual is correct (the encoding is irregular as given;
		// libopcodes uses the more regular expected encoding).
		// TODO(rsc): Test to ensure Intel manuals are correct and report to libopcodes maintainers?
		// NOTE: iant thinks this is deliberate, but we can't find the history.
		_, reg1 := inst.Args[0].(Reg)
		_, reg2 := inst.Args[1].(Reg)
		if reg1 && reg2 && (inst.Opcode>>24 == 0xDC || inst.Opcode>>24 == 0xDE) {
			switch inst.Op {
			case FDIV:
				inst.Op = FDIVR
			case FDIVR:
				inst.Op = FDIV
			case FSUB:
				inst.Op = FSUBR
			case FSUBR:
				inst.Op = FSUB
			case FDIVP:
				inst.Op = FDIVRP
			case FDIVRP:
				inst.Op = FDIVP
			case FSUBP:
				inst.Op = FSUBRP
			case FSUBRP:
				inst.Op = FSUBP
			}
		}

	case MOVNTSD:
		// MOVNTSD is F2 0F 2B /r.
		// MOVNTSS is F3 0F 2B /r (supposedly; not in manuals).
		// Usually inner prefixes win for display,
		// so that F3 F2 0F 2B 11 is REP MOVNTSD
		// and F2 F3 0F 2B 11 is REPN MOVNTSS.
		// Libopcodes always prefers MOVNTSS regardless of prefix order.
		if countPrefix(&inst, 0xF3) > 0 {
			found := false
			for i := len(inst.Prefix) - 1; i >= 0; i-- {
				switch inst.Prefix[i] & 0xFF {
				case 0xF3:
					if !found {
						found = true
						inst.Prefix[i] |= PrefixImplicit
					}
				case 0xF2:
					inst.Prefix[i] &^= PrefixImplicit
				}
			}
			inst.Op = MOVNTSS
		}
	}

	// Add implicit arguments.
	switch inst.Op {
	case MONITOR:
		inst.Args[0] = EDX
		inst.Args[1] = ECX
		inst.Args[2] = EAX
		if inst.AddrSize == 16 {
			inst.Args[2] = AX
		}

	case MWAIT:
		if inst.Mode == 64 {
			inst.Args[0] = RCX
			inst.Args[1] = RAX
		} else {
			inst.Args[0] = ECX
			inst.Args[1] = EAX
		}
	}

	// Adjust which prefixes will be displayed.
	// The rule is to display all the prefixes not implied by
	// the usual instruction display, that is, all the prefixes
	// except the ones with PrefixImplicit set.
	// However, of course, there are exceptions to the rule.
	switch inst.Op {
	case CRC32:
		// CRC32 has a mandatory F2 prefix.
		// If there are multiple F2s and no F3s, the extra F2s do not print.
		// (And Decode has already marked them implicit.)
		// However, if there is an F3 anywhere, then the extra F2s do print.
		// If there are multiple F2 prefixes *and* an (ignored) F3,
		// then libopcodes prints the extra F2s as REPNs.
		if countPrefix(&inst, 0xF2) > 1 {
			unmarkImplicit(&inst, 0xF2)
			markLastImplicit(&inst, 0xF2)
		}

		// An unused data size override should probably be shown,
		// to distinguish DATA16 CRC32B from plain CRC32B,
		// but libopcodes always treats the final override as implicit
		// and the others as explicit.
		unmarkImplicit(&inst, PrefixDataSize)
		markLastImplicit(&inst, PrefixDataSize)

	case CVTSI2SD, CVTSI2SS:
		if !isMem(inst.Args[1]) {
			markLastImplicit(&inst, PrefixDataSize)
		}

	case CVTSD2SI, CVTSS2SI, CVTTSD2SI, CVTTSS2SI,
		ENTER, FLDENV, FNSAVE, FNSTENV, FRSTOR, LGDT, LIDT, LRET,
		POP, PUSH, RET, SGDT, SIDT, SYSRET, XBEGIN:
		markLastImplicit(&inst, PrefixDataSize)

	case LOOP, LOOPE, LOOPNE, MONITOR:
		markLastImplicit(&inst, PrefixAddrSize)

	case MOV:
		// The 16-bit and 32-bit forms of MOV Sreg, dst and MOV src, Sreg
		// cannot be distinguished when src or dst refers to memory, because
		// Sreg is always a 16-bit value, even when we're doing a 32-bit
		// instruction. Because the instruction tables distinguished these two,
		// any operand size prefix has been marked as used (to decide which
		// branch to take). Unmark it, so that it will show up in disassembly,
		// so that the reader can tell the size of memory operand.
		// up with the same arguments
		dst, _ := inst.Args[0].(Reg)
		src, _ := inst.Args[1].(Reg)
		if ES <= src && src <= GS && isMem(inst.Args[0]) || ES <= dst && dst <= GS && isMem(inst.Args[1]) {
			unmarkImplicit(&inst, PrefixDataSize)
		}

	case MOVDQU:
		if countPrefix(&inst, 0xF3) > 1 {
			unmarkImplicit(&inst, 0xF3)
			markLastImplicit(&inst, 0xF3)
		}

	case MOVQ2DQ:
		markLastImplicit(&inst, PrefixDataSize)

	case SLDT, SMSW, STR, FXRSTOR, XRSTOR, XSAVE, XSAVEOPT, CMPXCHG8B:
		if isMem(inst.Args[0]) {
			unmarkImplicit(&inst, PrefixDataSize)
		}

	case SYSEXIT:
		unmarkImplicit(&inst, PrefixDataSize)
	}

	if isCondJmp[inst.Op] || isLoop[inst.Op] || inst.Op == JCXZ || inst.Op == JECXZ || inst.Op == JRCXZ {
		if countPrefix(&inst, PrefixCS) > 0 && countPrefix(&inst, PrefixDS) > 0 {
			for i, p := range inst.Prefix {
				switch p & 0xFFF {
				case PrefixPN, PrefixPT:
					inst.Prefix[i] &= 0xF0FF // cut interpretation bits, producing original segment prefix
				}
			}
		}
	}

	// XACQUIRE/XRELEASE adjustment.
	if inst.Op == MOV {
		// MOV into memory is a candidate for turning REP into XRELEASE.
		// However, if the REP is followed by a REPN, that REPN blocks the
		// conversion.
		haveREPN := false
		for i := len(inst.Prefix) - 1; i >= 0; i-- {
			switch inst.Prefix[i] &^ PrefixIgnored {
			case PrefixREPN:
				haveREPN = true
			case PrefixXRELEASE:
				if haveREPN {
					inst.Prefix[i] = PrefixREP
				}
			}
		}
	}

	// We only format the final F2/F3 as XRELEASE/XACQUIRE.
	haveXA := false
	haveXR := false
	for i := len(inst.Prefix) - 1; i >= 0; i-- {
		switch inst.Prefix[i] &^ PrefixIgnored {
		case PrefixXRELEASE:
			if !haveXR {
				haveXR = true
			} else {
				inst.Prefix[i] = PrefixREP
			}

		case PrefixXACQUIRE:
			if !haveXA {
				haveXA = true
			} else {
				inst.Prefix[i] = PrefixREPN
			}
		}
	}

	// Determine opcode.
	op := strings.ToLower(inst.Op.String())
	if alt := gnuOp[inst.Op]; alt != "" {
		op = alt
	}

	// Determine opcode suffix.
	// Libopcodes omits the suffix if the width of the operation
	// can be inferred from a register arguments. For example,
	// add $1, %ebx has no suffix because you can tell from the
	// 32-bit register destination that it is a 32-bit add,
	// but in addl $1, (%ebx), the destination is memory, so the
	// size is not evident without the l suffix.
	needSuffix := true
SuffixLoop:
	for i, a := range inst.Args {
		if a == nil {
			break
		}
		switch a := a.(type) {
		case Reg:
			switch inst.Op {
			case MOVSX, MOVZX:
				continue

			case SHL, SHR, RCL, RCR, ROL, ROR, SAR:
				if i == 1 {
					// shift count does not tell us operand size
					continue
				}

			case CRC32:
				// The source argument does tell us operand size,
				// but libopcodes still always puts a suffix on crc32.
				continue

			case PUSH, POP:
				// Even though segment registers are 16-bit, push and pop
				// can save/restore them from 32-bit slots, so they
				// do not imply operand size.
				if ES <= a && a <= GS {
					continue
				}

			case CVTSI2SD, CVTSI2SS:
				// The integer register argument takes priority.
				if X0 <= a && a <= X15 {
					continue
				}
			}

			if AL <= a && a <= R15 || ES <= a && a <= GS || X0 <= a && a <= X15 || M0 <= a && a <= M7 {
				needSuffix = false
				break SuffixLoop
			}
		}
	}

	if needSuffix {
		switch inst.Op {
		case CMPXCHG8B, FLDCW, FNSTCW, FNSTSW, LDMXCSR, LLDT, LMSW, LTR, PCLMULQDQ,
			SETA, SETAE, SETB, SETBE, SETE, SETG, SETGE, SETL, SETLE, SETNE, SETNO, SETNP, SETNS, SETO, SETP, SETS,
			SLDT, SMSW, STMXCSR, STR, VERR, VERW:
			// For various reasons, libopcodes emits no suffix for these instructions.

		case CRC32:
			op += byteSizeSuffix(argBytes(&inst, inst.Args[1]))

		case LGDT, LIDT, SGDT, SIDT:
			op += byteSizeSuffix(inst.DataSize / 8)

		case MOVZX, MOVSX:
			// Integer size conversions get two suffixes.
			op = op[:4] + byteSizeSuffix(argBytes(&inst, inst.Args[1])) + byteSizeSuffix(argBytes(&inst, inst.Args[0]))

		case LOOP, LOOPE, LOOPNE:
			// Add w suffix to indicate use of CX register instead of ECX.
			if inst.AddrSize == 16 {
				op += "w"
			}

		case CALL, ENTER, JMP, LCALL, LEAVE, LJMP, LRET, RET, SYSRET, XBEGIN:
			// Add w suffix to indicate use of 16-bit target.
			// Exclude JMP rel8.
			if inst.Opcode>>24 == 0xEB {
				break
			}
			if inst.DataSize == 16 && inst.Mode != 16 {
				markLastImplicit(&inst, PrefixDataSize)
				op += "w"
			} else if inst.Mode == 64 {
				op += "q"
			}

		case FRSTOR, FNSAVE, FNSTENV, FLDENV:
			// Add s suffix to indicate shortened FPU state (I guess).
			if inst.DataSize == 16 {
				op += "s"
			}

		case PUSH, POP:
			if markLastImplicit(&inst, PrefixDataSize) {
				op += byteSizeSuffix(inst.DataSize / 8)
			} else if inst.Mode == 64 {
				op += "q"
			} else {
				op += byteSizeSuffix(inst.MemBytes)
			}

		default:
			if isFloat(inst.Op) {
				// I can't explain any of this, but it's what libopcodes does.
				switch inst.MemBytes {
				default:
					if (inst.Op == FLD || inst.Op == FSTP) && isMem(inst.Args[0]) {
						op += "t"
					}
				case 4:
					if isFloatInt(inst.Op) {
						op += "l"
					} else {
						op += "s"
					}
				case 8:
					if isFloatInt(inst.Op) {
						op += "ll"
					} else {
						op += "l"
					}
				}
				break
			}

			op += byteSizeSuffix(inst.MemBytes)
		}
	}

	// Adjust special case opcodes.
	switch inst.Op {
	case 0:
		if inst.Prefix[0] != 0 {
			return strings.ToLower(inst.Prefix[0].String())
		}

	case INT:
		if inst.Opcode>>24 == 0xCC {
			inst.Args[0] = nil
			op = "int3"
		}

	case CMPPS, CMPPD, CMPSD_XMM, CMPSS:
		imm, ok := inst.Args[2].(Imm)
		if ok && 0 <= imm && imm < 8 {
			inst.Args[2] = nil
			op = cmppsOps[imm] + op[3:]
		}

	case PCLMULQDQ:
		imm, ok := inst.Args[2].(Imm)
		if ok && imm&^0x11 == 0 {
			inst.Args[2] = nil
			op = pclmulqOps[(imm&0x10)>>3|(imm&1)]
		}

	case XLATB:
		if markLastImplicit(&inst, PrefixAddrSize) {
			op = "xlat" // not xlatb
		}
	}

	// Build list of argument strings.
	var (
		usedPrefixes bool     // segment prefixes consumed by Mem formatting
		args         []string // formatted arguments
	)
	for i, a := range inst.Args {
		if a == nil {
			break
		}
		switch inst.Op {
		case MOVSB, MOVSW, MOVSD, MOVSQ, OUTSB, OUTSW, OUTSD:
			if i == 0 {
				usedPrefixes = true // disable use of prefixes for first argument
			} else {
				usedPrefixes = false
			}
		}
		if a == Imm(1) && (inst.Opcode>>24)&^1 == 0xD0 {
			continue
		}
		args = append(args, gnuArg(&inst, a, &usedPrefixes))
	}

	// The default is to print the arguments in reverse Intel order.
	// A few instructions inhibit this behavior.
	switch inst.Op {
	case BOUND, LCALL, ENTER, LJMP:
		// no reverse
	default:
		// reverse args
		for i, j := 0, len(args)-1; i < j; i, j = i+1, j-1 {
			args[i], args[j] = args[j], args[i]
		}
	}

	// Build prefix string.
	// Must be after argument formatting, which can turn off segment prefixes.
	var (
		prefix       = "" // output string
		numAddr      = 0
		numData      = 0
		implicitData = false
	)
	for _, p := range inst.Prefix {
		if p&0xFF == PrefixDataSize && p&PrefixImplicit != 0 {
			implicitData = true
		}
	}
	for _, p := range inst.Prefix {
		if p == 0 {
			break
		}
		if p&PrefixImplicit != 0 {
			continue
		}
		switch p &^ (PrefixIgnored | PrefixInvalid) {
		default:
			if p.IsREX() {
				if p&0xFF == PrefixREX {
					prefix += "rex "
				} else {
					prefix += "rex." + p.String()[4:] + " "
				}
				break
			}
			prefix += strings.ToLower(p.String()) + " "

		case PrefixPN:
			op += ",pn"
			continue

		case PrefixPT:
			op += ",pt"
			continue

		case PrefixAddrSize, PrefixAddr16, PrefixAddr32:
			// For unknown reasons, if the addr16 prefix is repeated,
			// libopcodes displays all but the last as addr32, even though
			// the addressing form used in a memory reference is clearly
			// still 16-bit.
			n := 32
			if inst.Mode == 32 {
				n = 16
			}
			numAddr++
			if countPrefix(&inst, PrefixAddrSize) > numAddr {
				n = inst.Mode
			}
			prefix += fmt.Sprintf("addr%d ", n)
			continue

		case PrefixData16, PrefixData32:
			if implicitData && countPrefix(&inst, PrefixDataSize) > 1 {
				// Similar to the addr32 logic above, but it only kicks in
				// when something used the data size prefix (one is implicit).
				n := 16
				if inst.Mode == 16 {
					n = 32
				}
				numData++
				if countPrefix(&inst, PrefixDataSize) > numData {
					if inst.Mode == 16 {
						n = 16
					} else {
						n = 32
					}
				}
				prefix += fmt.Sprintf("data%d ", n)
				continue
			}
			prefix += strings.ToLower(p.String()) + " "
		}
	}

	// Finally! Put it all together.
	text := prefix + op
	if args != nil {
		text += " "
		// Indirect call/jmp gets a star to distinguish from direct jump address.
		if (inst.Op == CALL || inst.Op == JMP || inst.Op == LJMP || inst.Op == LCALL) && (isMem(inst.Args[0]) || isReg(inst.Args[0])) {
			text += "*"
		}
		text += strings.Join(args, ",")
	}
	return text
}

// gnuArg returns the GNU syntax for the argument x from the instruction inst.
// If *usedPrefixes is false and x is a Mem, then the formatting
// includes any segment prefixes and sets *usedPrefixes to true.
func gnuArg(inst *Inst, x Arg, usedPrefixes *bool) string {
	if x == nil {
		return "<nil>"
	}
	switch x := x.(type) {
	case Reg:
		switch inst.Op {
		case CVTSI2SS, CVTSI2SD, CVTSS2SI, CVTSD2SI, CVTTSD2SI, CVTTSS2SI:
			if inst.DataSize == 16 && EAX <= x && x <= R15L {
				x -= EAX - AX
			}

		case IN, INSB, INSW, INSD, OUT, OUTSB, OUTSW, OUTSD:
			// DX is the port, but libopcodes prints it as if it were a memory reference.
			if x == DX {
				return "(%dx)"
			}
		}
		return gccRegName[x]
	case Mem:
		seg := ""
		var haveCS, haveDS, haveES, haveFS, haveGS, haveSS bool
		switch x.Segment {
		case CS:
			haveCS = true
		case DS:
			haveDS = true
		case ES:
			haveES = true
		case FS:
			haveFS = true
		case GS:
			haveGS = true
		case SS:
			haveSS = true
		}
		switch inst.Op {
		case INSB, INSW, INSD, STOSB, STOSW, STOSD, STOSQ, SCASB, SCASW, SCASD, SCASQ:
			// These do not accept segment prefixes, at least in the GNU rendering.
		default:
			if *usedPrefixes {
				break
			}
			for i := len(inst.Prefix) - 1; i >= 0; i-- {
				p := inst.Prefix[i] &^ PrefixIgnored
				if p == 0 {
					continue
				}
				switch p {
				case PrefixCS:
					if !haveCS {
						haveCS = true
						inst.Prefix[i] |= PrefixImplicit
					}
				case PrefixDS:
					if !haveDS {
						haveDS = true
						inst.Prefix[i] |= PrefixImplicit
					}
				case PrefixES:
					if !haveES {
						haveES = true
						inst.Prefix[i] |= PrefixImplicit
					}
				case PrefixFS:
					if !haveFS {
						haveFS = true
						inst.Prefix[i] |= PrefixImplicit
					}
				case PrefixGS:
					if !haveGS {
						haveGS = true
						inst.Prefix[i] |= PrefixImplicit
					}
				case PrefixSS:
					if !haveSS {
						haveSS = true
						inst.Prefix[i] |= PrefixImplicit
					}
				}
			}
			*usedPrefixes = true
		}
		if haveCS {
			seg += "%cs:"
		}
		if haveDS {
			seg += "%ds:"
		}
		if haveSS {
			seg += "%ss:"
		}
		if haveES {
			seg += "%es:"
		}
		if haveFS {
			seg += "%fs:"
		}
		if haveGS {
			seg += "%gs:"
		}
		disp := ""
		if x.Disp != 0 {
			disp = fmt.Sprintf("%#x", x.Disp)
		}
		if x.Scale == 0 || x.Index == 0 && x.Scale == 1 && (x.Base == ESP || x.Base == RSP || x.Base == 0 && inst.Mode == 64) {
			if x.Base == 0 {
				return seg + disp
			}
			return fmt.Sprintf("%s%s(%s)", seg, disp, gccRegName[x.Base])
		}
		base := gccRegName[x.Base]
		if x.Base == 0 {
			base = ""
		}
		index := gccRegName[x.Index]
		if x.Index == 0 {
			if inst.AddrSize == 64 {
				index = "%riz"
			} else {
				index = "%eiz"
			}
		}
		if AX <= x.Base && x.Base <= DI {
			// 16-bit addressing - no scale
			return fmt.Sprintf("%s%s(%s,%s)", seg, disp, base, index)
		}
		return fmt.Sprintf("%s%s(%s,%s,%d)", seg, disp, base, index, x.Scale)
	case Rel:
		return fmt.Sprintf(".%+#x", int32(x))
	case Imm:
		if inst.Mode == 32 {
			return fmt.Sprintf("$%#x", uint32(x))
		}
		return fmt.Sprintf("$%#x", int64(x))
	}
	return x.String()
}

var gccRegName = [...]string{
	0:    "REG0",
	AL:   "%al",
	CL:   "%cl",
	BL:   "%bl",
	DL:   "%dl",
	AH:   "%ah",
	CH:   "%ch",
	BH:   "%bh",
	DH:   "%dh",
	SPB:  "%spl",
	BPB:  "%bpl",
	SIB:  "%sil",
	DIB:  "%dil",
	R8B:  "%r8b",
	R9B:  "%r9b",
	R10B: "%r10b",
	R11B: "%r11b",
	R12B: "%r12b",
	R13B: "%r13b",
	R14B: "%r14b",
	R15B: "%r15b",
	AX:   "%ax",
	CX:   "%cx",
	BX:   "%bx",
	DX:   "%dx",
	SP:   "%sp",
	BP:   "%bp",
	SI:   "%si",
	DI:   "%di",
	R8W:  "%r8w",
	R9W:  "%r9w",
	R10W: "%r10w",
	R11W: "%r11w",
	R12W: "%r12w",
	R13W: "%r13w",
	R14W: "%r14w",
	R15W: "%r15w",
	EAX:  "%eax",
	ECX:  "%ecx",
	EDX:  "%edx",
	EBX:  "%ebx",
	ESP:  "%esp",
	EBP:  "%ebp",
	ESI:  "%esi",
	EDI:  "%edi",
	R8L:  "%r8d",
	R9L:  "%r9d",
	R10L: "%r10d",
	R11L: "%r11d",
	R12L: "%r12d",
	R13L: "%r13d",
	R14L: "%r14d",
	R15L: "%r15d",
	RAX:  "%rax",
	RCX:  "%rcx",
	RDX:  "%rdx",
	RBX:  "%rbx",
	RSP:  "%rsp",
	RBP:  "%rbp",
	RSI:  "%rsi",
	RDI:  "%rdi",
	R8:   "%r8",
	R9:   "%r9",
	R10:  "%r10",
	R11:  "%r11",
	R12:  "%r12",
	R13:  "%r13",
	R14:  "%r14",
	R15:  "%r15",
	IP:   "%ip",
	EIP:  "%eip",
	RIP:  "%rip",
	F0:   "%st",
	F1:   "%st(1)",
	F2:   "%st(2)",
	F3:   "%st(3)",
	F4:   "%st(4)",
	F5:   "%st(5)",
	F6:   "%st(6)",
	F7:   "%st(7)",
	M0:   "%mm0",
	M1:   "%mm1",
	M2:   "%mm2",
	M3:   "%mm3",
	M4:   "%mm4",
	M5:   "%mm5",
	M6:   "%mm6",
	M7:   "%mm7",
	X0:   "%xmm0",
	X1:   "%xmm1",
	X2:   "%xmm2",
	X3:   "%xmm3",
	X4:   "%xmm4",
	X5:   "%xmm5",
	X6:   "%xmm6",
	X7:   "%xmm7",
	X8:   "%xmm8",
	X9:   "%xmm9",
	X10:  "%xmm10",
	X11:  "%xmm11",
	X12:  "%xmm12",
	X13:  "%xmm13",
	X14:  "%xmm14",
	X15:  "%xmm15",
	CS:   "%cs",
	SS:   "%ss",
	DS:   "%ds",
	ES:   "%es",
	FS:   "%fs",
	GS:   "%gs",
	GDTR: "%gdtr",
	IDTR: "%idtr",
	LDTR: "%ldtr",
	MSW:  "%msw",
	TASK: "%task",
	CR0:  "%cr0",
	CR1:  "%cr1",
	CR2:  "%cr2",
	CR3:  "%cr3",
	CR4:  "%cr4",
	CR5:  "%cr5",
	CR6:  "%cr6",
	CR7:  "%cr7",
	CR8:  "%cr8",
	CR9:  "%cr9",
	CR10: "%cr10",
	CR11: "%cr11",
	CR12: "%cr12",
	CR13: "%cr13",
	CR14: "%cr14",
	CR15: "%cr15",
	DR0:  "%db0",
	DR1:  "%db1",
	DR2:  "%db2",
	DR3:  "%db3",
	DR4:  "%db4",
	DR5:  "%db5",
	DR6:  "%db6",
	DR7:  "%db7",
	TR0:  "%tr0",
	TR1:  "%tr1",
	TR2:  "%tr2",
	TR3:  "%tr3",
	TR4:  "%tr4",
	TR5:  "%tr5",
	TR6:  "%tr6",
	TR7:  "%tr7",
}

var gnuOp = map[Op]string{
	CBW:       "cbtw",
	CDQ:       "cltd",
	CMPSD:     "cmpsl",
	CMPSD_XMM: "cmpsd",
	CWD:       "cwtd",
	CWDE:      "cwtl",
	CQO:       "cqto",
	INSD:      "insl",
	IRET:      "iretw",
	IRETD:     "iret",
	IRETQ:     "iretq",
	LODSB:     "lods",
	LODSD:     "lods",
	LODSQ:     "lods",
	LODSW:     "lods",
	MOVSD:     "movsl",
	MOVSD_XMM: "movsd",
	OUTSD:     "outsl",
	POPA:      "popaw",
	POPAD:     "popa",
	POPF:      "popfw",
	POPFD:     "popf",
	PUSHA:     "pushaw",
	PUSHAD:    "pusha",
	PUSHF:     "pushfw",
	PUSHFD:    "pushf",
	SCASB:     "scas",
	SCASD:     "scas",
	SCASQ:     "scas",
	SCASW:     "scas",
	STOSB:     "stos",
	STOSD:     "stos",
	STOSQ:     "stos",
	STOSW:     "stos",
	XLATB:     "xlat",
}

var cmppsOps = []string{
	"cmpeq",
	"cmplt",
	"cmple",
	"cmpunord",
	"cmpneq",
	"cmpnlt",
	"cmpnle",
	"cmpord",
}

var pclmulqOps = []string{
	"pclmullqlqdq",
	"pclmulhqlqdq",
	"pclmullqhqdq",
	"pclmulhqhqdq",
}

func countPrefix(inst *Inst, target Prefix) int {
	n := 0
	for _, p := range inst.Prefix {
		if p&0xFF == target&0xFF {
			n++
		}
	}
	return n
}

func markLastImplicit(inst *Inst, prefix Prefix) bool {
	for i := len(inst.Prefix) - 1; i >= 0; i-- {
		p := inst.Prefix[i]
		if p&0xFF == prefix {
			inst.Prefix[i] |= PrefixImplicit
			return true
		}
	}
	return false
}

func unmarkImplicit(inst *Inst, prefix Prefix) {
	for i := len(inst.Prefix) - 1; i >= 0; i-- {
		p := inst.Prefix[i]
		if p&0xFF == prefix {
			inst.Prefix[i] &^= PrefixImplicit
		}
	}
}

func byteSizeSuffix(b int) string {
	switch b {
	case 1:
		return "b"
	case 2:
		return "w"
	case 4:
		return "l"
	case 8:
		return "q"
	}
	return ""
}

func argBytes(inst *Inst, arg Arg) int {
	if isMem(arg) {
		return inst.MemBytes
	}
	return regBytes(arg)
}

func isFloat(op Op) bool {
	switch op {
	case FADD, FCOM, FCOMP, FDIV, FDIVR, FIADD, FICOM, FICOMP, FIDIV, FIDIVR, FILD, FIMUL, FIST, FISTP, FISTTP, FISUB, FISUBR, FLD, FMUL, FST, FSTP, FSUB, FSUBR:
		return true
	}
	return false
}

func isFloatInt(op Op) bool {
	switch op {
	case FIADD, FICOM, FICOMP, FIDIV, FIDIVR, FILD, FIMUL, FIST, FISTP, FISTTP, FISUB, FISUBR:
		return true
	}
	return false
}
 root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/inst.go                                               0100644 0000000 0000000 00000024333 12600426226 020507  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package x86asm implements decoding of x86 machine code.
package x86asm

import (
	"bytes"
	"fmt"
)

// An Inst is a single instruction.
type Inst struct {
	Prefix   Prefixes // Prefixes applied to the instruction.
	Op       Op       // Opcode mnemonic
	Opcode   uint32   // Encoded opcode bits, left aligned (first byte is Opcode>>24, etc)
	Args     Args     // Instruction arguments, in Intel order
	Mode     int      // processor mode in bits: 16, 32, or 64
	AddrSize int      // address size in bits: 16, 32, or 64
	DataSize int      // operand size in bits: 16, 32, or 64
	MemBytes int      // size of memory argument in bytes: 1, 2, 4, 8, 16, and so on.
	Len      int      // length of encoded instruction in bytes
}

// Prefixes is an array of prefixes associated with a single instruction.
// The prefixes are listed in the same order as found in the instruction:
// each prefix byte corresponds to one slot in the array. The first zero
// in the array marks the end of the prefixes.
type Prefixes [14]Prefix

// A Prefix represents an Intel instruction prefix.
// The low 8 bits are the actual prefix byte encoding,
// and the top 8 bits contain distinguishing bits and metadata.
type Prefix uint16

const (
	// Metadata about the role of a prefix in an instruction.
	PrefixImplicit Prefix = 0x8000 // prefix is implied by instruction text
	PrefixIgnored  Prefix = 0x4000 // prefix is ignored: either irrelevant or overridden by a later prefix
	PrefixInvalid  Prefix = 0x2000 // prefix makes entire instruction invalid (bad LOCK)

	// Memory segment overrides.
	PrefixES Prefix = 0x26 // ES segment override
	PrefixCS Prefix = 0x2E // CS segment override
	PrefixSS Prefix = 0x36 // SS segment override
	PrefixDS Prefix = 0x3E // DS segment override
	PrefixFS Prefix = 0x64 // FS segment override
	PrefixGS Prefix = 0x65 // GS segment override

	// Branch prediction.
	PrefixPN Prefix = 0x12E // predict not taken (conditional branch only)
	PrefixPT Prefix = 0x13E // predict taken (conditional branch only)

	// Size attributes.
	PrefixDataSize Prefix = 0x66 // operand size override
	PrefixData16   Prefix = 0x166
	PrefixData32   Prefix = 0x266
	PrefixAddrSize Prefix = 0x67 // address size override
	PrefixAddr16   Prefix = 0x167
	PrefixAddr32   Prefix = 0x267

	// One of a kind.
	PrefixLOCK     Prefix = 0xF0 // lock
	PrefixREPN     Prefix = 0xF2 // repeat not zero
	PrefixXACQUIRE Prefix = 0x1F2
	PrefixBND      Prefix = 0x2F2
	PrefixREP      Prefix = 0xF3 // repeat
	PrefixXRELEASE Prefix = 0x1F3

	// The REX prefixes must be in the range [PrefixREX, PrefixREX+0x10).
	// the other bits are set or not according to the intended use.
	PrefixREX  Prefix = 0x40 // REX 64-bit extension prefix
	PrefixREXW Prefix = 0x08 // extension bit W (64-bit instruction width)
	PrefixREXR Prefix = 0x04 // extension bit R (r field in modrm)
	PrefixREXX Prefix = 0x02 // extension bit X (index field in sib)
	PrefixREXB Prefix = 0x01 // extension bit B (r/m field in modrm or base field in sib)
)

// IsREX reports whether p is a REX prefix byte.
func (p Prefix) IsREX() bool {
	return p&0xF0 == PrefixREX
}

func (p Prefix) String() string {
	p &^= PrefixImplicit | PrefixIgnored | PrefixInvalid
	if s := prefixNames[p]; s != "" {
		return s
	}

	if p.IsREX() {
		s := "REX."
		if p&PrefixREXW != 0 {
			s += "W"
		}
		if p&PrefixREXR != 0 {
			s += "R"
		}
		if p&PrefixREXX != 0 {
			s += "X"
		}
		if p&PrefixREXB != 0 {
			s += "B"
		}
		return s
	}

	return fmt.Sprintf("Prefix(%#x)", int(p))
}

// An Op is an x86 opcode.
type Op uint32

func (op Op) String() string {
	i := int(op)
	if i < 0 || i >= len(opNames) || opNames[i] == "" {
		return fmt.Sprintf("Op(%d)", i)
	}
	return opNames[i]
}

// An Args holds the instruction arguments.
// If an instruction has fewer than 4 arguments,
// the final elements in the array are nil.
type Args [4]Arg

// An Arg is a single instruction argument,
// one of these types: Reg, Mem, Imm, Rel.
type Arg interface {
	String() string
	isArg()
}

// Note that the implements of Arg that follow are all sized
// so that on a 64-bit machine the data can be inlined in
// the interface value instead of requiring an allocation.

// A Reg is a single register.
// The zero Reg value has no name but indicates ``no register.''
type Reg uint8

const (
	_ Reg = iota

	// 8-bit
	AL
	CL
	DL
	BL
	AH
	CH
	DH
	BH
	SPB
	BPB
	SIB
	DIB
	R8B
	R9B
	R10B
	R11B
	R12B
	R13B
	R14B
	R15B

	// 16-bit
	AX
	CX
	DX
	BX
	SP
	BP
	SI
	DI
	R8W
	R9W
	R10W
	R11W
	R12W
	R13W
	R14W
	R15W

	// 32-bit
	EAX
	ECX
	EDX
	EBX
	ESP
	EBP
	ESI
	EDI
	R8L
	R9L
	R10L
	R11L
	R12L
	R13L
	R14L
	R15L

	// 64-bit
	RAX
	RCX
	RDX
	RBX
	RSP
	RBP
	RSI
	RDI
	R8
	R9
	R10
	R11
	R12
	R13
	R14
	R15

	// Instruction pointer.
	IP  // 16-bit
	EIP // 32-bit
	RIP // 64-bit

	// 387 floating point registers.
	F0
	F1
	F2
	F3
	F4
	F5
	F6
	F7

	// MMX registers.
	M0
	M1
	M2
	M3
	M4
	M5
	M6
	M7

	// XMM registers.
	X0
	X1
	X2
	X3
	X4
	X5
	X6
	X7
	X8
	X9
	X10
	X11
	X12
	X13
	X14
	X15

	// Segment registers.
	ES
	CS
	SS
	DS
	FS
	GS

	// System registers.
	GDTR
	IDTR
	LDTR
	MSW
	TASK

	// Control registers.
	CR0
	CR1
	CR2
	CR3
	CR4
	CR5
	CR6
	CR7
	CR8
	CR9
	CR10
	CR11
	CR12
	CR13
	CR14
	CR15

	// Debug registers.
	DR0
	DR1
	DR2
	DR3
	DR4
	DR5
	DR6
	DR7
	DR8
	DR9
	DR10
	DR11
	DR12
	DR13
	DR14
	DR15

	// Task registers.
	TR0
	TR1
	TR2
	TR3
	TR4
	TR5
	TR6
	TR7
)

const regMax = TR7

func (Reg) isArg() {}

func (r Reg) String() string {
	i := int(r)
	if i < 0 || i >= len(regNames) || regNames[i] == "" {
		return fmt.Sprintf("Reg(%d)", i)
	}
	return regNames[i]
}

// A Mem is a memory reference.
// The general form is Segment:[Base+Scale*Index+Disp].
type Mem struct {
	Segment Reg
	Base    Reg
	Scale   uint8
	Index   Reg
	Disp    int64
}

func (Mem) isArg() {}

func (m Mem) String() string {
	var base, plus, scale, index, disp string

	if m.Base != 0 {
		base = m.Base.String()
	}
	if m.Scale != 0 {
		if m.Base != 0 {
			plus = "+"
		}
		if m.Scale > 1 {
			scale = fmt.Sprintf("%d*", m.Scale)
		}
		index = m.Index.String()
	}
	if m.Disp != 0 || m.Base == 0 && m.Scale == 0 {
		disp = fmt.Sprintf("%+#x", m.Disp)
	}
	return "[" + base + plus + scale + index + disp + "]"
}

// A Rel is an offset relative to the current instruction pointer.
type Rel int32

func (Rel) isArg() {}

func (r Rel) String() string {
	return fmt.Sprintf(".%+d", r)
}

// An Imm is an integer constant.
type Imm int64

func (Imm) isArg() {}

func (i Imm) String() string {
	return fmt.Sprintf("%#x", int64(i))
}

func (i Inst) String() string {
	var buf bytes.Buffer
	for _, p := range i.Prefix {
		if p == 0 {
			break
		}
		if p&PrefixImplicit != 0 {
			continue
		}
		fmt.Fprintf(&buf, "%v ", p)
	}
	fmt.Fprintf(&buf, "%v", i.Op)
	sep := " "
	for _, v := range i.Args {
		if v == nil {
			break
		}
		fmt.Fprintf(&buf, "%s%v", sep, v)
		sep = ", "
	}
	return buf.String()
}

func isReg(a Arg) bool {
	_, ok := a.(Reg)
	return ok
}

func isSegReg(a Arg) bool {
	r, ok := a.(Reg)
	return ok && ES <= r && r <= GS
}

func isMem(a Arg) bool {
	_, ok := a.(Mem)
	return ok
}

func isImm(a Arg) bool {
	_, ok := a.(Imm)
	return ok
}

func regBytes(a Arg) int {
	r, ok := a.(Reg)
	if !ok {
		return 0
	}
	if AL <= r && r <= R15B {
		return 1
	}
	if AX <= r && r <= R15W {
		return 2
	}
	if EAX <= r && r <= R15L {
		return 4
	}
	if RAX <= r && r <= R15 {
		return 8
	}
	return 0
}

func isSegment(p Prefix) bool {
	switch p {
	case PrefixCS, PrefixDS, PrefixES, PrefixFS, PrefixGS, PrefixSS:
		return true
	}
	return false
}

// The Op definitions and string list are in tables.go.

var prefixNames = map[Prefix]string{
	PrefixCS:       "CS",
	PrefixDS:       "DS",
	PrefixES:       "ES",
	PrefixFS:       "FS",
	PrefixGS:       "GS",
	PrefixSS:       "SS",
	PrefixLOCK:     "LOCK",
	PrefixREP:      "REP",
	PrefixREPN:     "REPN",
	PrefixAddrSize: "ADDRSIZE",
	PrefixDataSize: "DATASIZE",
	PrefixAddr16:   "ADDR16",
	PrefixData16:   "DATA16",
	PrefixAddr32:   "ADDR32",
	PrefixData32:   "DATA32",
	PrefixBND:      "BND",
	PrefixXACQUIRE: "XACQUIRE",
	PrefixXRELEASE: "XRELEASE",
	PrefixREX:      "REX",
	PrefixPT:       "PT",
	PrefixPN:       "PN",
}

var regNames = [...]string{
	AL:   "AL",
	CL:   "CL",
	BL:   "BL",
	DL:   "DL",
	AH:   "AH",
	CH:   "CH",
	BH:   "BH",
	DH:   "DH",
	SPB:  "SPB",
	BPB:  "BPB",
	SIB:  "SIB",
	DIB:  "DIB",
	R8B:  "R8B",
	R9B:  "R9B",
	R10B: "R10B",
	R11B: "R11B",
	R12B: "R12B",
	R13B: "R13B",
	R14B: "R14B",
	R15B: "R15B",
	AX:   "AX",
	CX:   "CX",
	BX:   "BX",
	DX:   "DX",
	SP:   "SP",
	BP:   "BP",
	SI:   "SI",
	DI:   "DI",
	R8W:  "R8W",
	R9W:  "R9W",
	R10W: "R10W",
	R11W: "R11W",
	R12W: "R12W",
	R13W: "R13W",
	R14W: "R14W",
	R15W: "R15W",
	EAX:  "EAX",
	ECX:  "ECX",
	EDX:  "EDX",
	EBX:  "EBX",
	ESP:  "ESP",
	EBP:  "EBP",
	ESI:  "ESI",
	EDI:  "EDI",
	R8L:  "R8L",
	R9L:  "R9L",
	R10L: "R10L",
	R11L: "R11L",
	R12L: "R12L",
	R13L: "R13L",
	R14L: "R14L",
	R15L: "R15L",
	RAX:  "RAX",
	RCX:  "RCX",
	RDX:  "RDX",
	RBX:  "RBX",
	RSP:  "RSP",
	RBP:  "RBP",
	RSI:  "RSI",
	RDI:  "RDI",
	R8:   "R8",
	R9:   "R9",
	R10:  "R10",
	R11:  "R11",
	R12:  "R12",
	R13:  "R13",
	R14:  "R14",
	R15:  "R15",
	IP:   "IP",
	EIP:  "EIP",
	RIP:  "RIP",
	F0:   "F0",
	F1:   "F1",
	F2:   "F2",
	F3:   "F3",
	F4:   "F4",
	F5:   "F5",
	F6:   "F6",
	F7:   "F7",
	M0:   "M0",
	M1:   "M1",
	M2:   "M2",
	M3:   "M3",
	M4:   "M4",
	M5:   "M5",
	M6:   "M6",
	M7:   "M7",
	X0:   "X0",
	X1:   "X1",
	X2:   "X2",
	X3:   "X3",
	X4:   "X4",
	X5:   "X5",
	X6:   "X6",
	X7:   "X7",
	X8:   "X8",
	X9:   "X9",
	X10:  "X10",
	X11:  "X11",
	X12:  "X12",
	X13:  "X13",
	X14:  "X14",
	X15:  "X15",
	CS:   "CS",
	SS:   "SS",
	DS:   "DS",
	ES:   "ES",
	FS:   "FS",
	GS:   "GS",
	GDTR: "GDTR",
	IDTR: "IDTR",
	LDTR: "LDTR",
	MSW:  "MSW",
	TASK: "TASK",
	CR0:  "CR0",
	CR1:  "CR1",
	CR2:  "CR2",
	CR3:  "CR3",
	CR4:  "CR4",
	CR5:  "CR5",
	CR6:  "CR6",
	CR7:  "CR7",
	CR8:  "CR8",
	CR9:  "CR9",
	CR10: "CR10",
	CR11: "CR11",
	CR12: "CR12",
	CR13: "CR13",
	CR14: "CR14",
	CR15: "CR15",
	DR0:  "DR0",
	DR1:  "DR1",
	DR2:  "DR2",
	DR3:  "DR3",
	DR4:  "DR4",
	DR5:  "DR5",
	DR6:  "DR6",
	DR7:  "DR7",
	DR8:  "DR8",
	DR9:  "DR9",
	DR10: "DR10",
	DR11: "DR11",
	DR12: "DR12",
	DR13: "DR13",
	DR14: "DR14",
	DR15: "DR15",
	TR0:  "TR0",
	TR1:  "TR1",
	TR2:  "TR2",
	TR3:  "TR3",
	TR4:  "TR4",
	TR5:  "TR5",
	TR6:  "TR6",
	TR7:  "TR7",
}
                                                                                                                                                                                                                                                                                                     root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/inst_test.go                                          0100644 0000000 0000000 00000000751 12600426226 021544  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"strings"
	"testing"
)

func TestRegString(t *testing.T) {
	for r := Reg(1); r <= regMax; r++ {
		if regNames[r] == "" {
			t.Errorf("regNames[%d] is missing", int(r))
		} else if s := r.String(); strings.Contains(s, "Reg(") {
			t.Errorf("Reg(%d).String() = %s, want proper name", int(r), s)
		}
	}
}
                       root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/intel.go                                              0100644 0000000 0000000 00000025016 12600426226 020644  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"fmt"
	"strings"
)

// IntelSyntax returns the Intel assembler syntax for the instruction, as defined by Intel's XED tool.
func IntelSyntax(inst Inst) string {
	var iargs []Arg
	for _, a := range inst.Args {
		if a == nil {
			break
		}
		iargs = append(iargs, a)
	}

	switch inst.Op {
	case INSB, INSD, INSW, OUTSB, OUTSD, OUTSW, LOOPNE, JCXZ, JECXZ, JRCXZ, LOOP, LOOPE, MOV, XLATB:
		if inst.Op == MOV && (inst.Opcode>>16)&0xFFFC != 0x0F20 {
			break
		}
		for i, p := range inst.Prefix {
			if p&0xFF == PrefixAddrSize {
				inst.Prefix[i] &^= PrefixImplicit
			}
		}
	}

	switch inst.Op {
	case MOV:
		dst, _ := inst.Args[0].(Reg)
		src, _ := inst.Args[1].(Reg)
		if ES <= dst && dst <= GS && EAX <= src && src <= R15L {
			src -= EAX - AX
			iargs[1] = src
		}
		if ES <= dst && dst <= GS && RAX <= src && src <= R15 {
			src -= RAX - AX
			iargs[1] = src
		}

		if inst.Opcode>>24&^3 == 0xA0 {
			for i, p := range inst.Prefix {
				if p&0xFF == PrefixAddrSize {
					inst.Prefix[i] |= PrefixImplicit
				}
			}
		}
	}

	switch inst.Op {
	case AAM, AAD:
		if imm, ok := iargs[0].(Imm); ok {
			if inst.DataSize == 32 {
				iargs[0] = Imm(uint32(int8(imm)))
			} else if inst.DataSize == 16 {
				iargs[0] = Imm(uint16(int8(imm)))
			}
		}

	case PUSH:
		if imm, ok := iargs[0].(Imm); ok {
			iargs[0] = Imm(uint32(imm))
		}
	}

	for _, p := range inst.Prefix {
		if p&PrefixImplicit != 0 {
			for j, pj := range inst.Prefix {
				if pj&0xFF == p&0xFF {
					inst.Prefix[j] |= PrefixImplicit
				}
			}
		}
	}

	if inst.Op != 0 {
		for i, p := range inst.Prefix {
			switch p &^ PrefixIgnored {
			case PrefixData16, PrefixData32, PrefixCS, PrefixDS, PrefixES, PrefixSS:
				inst.Prefix[i] |= PrefixImplicit
			}
			if p.IsREX() {
				inst.Prefix[i] |= PrefixImplicit
			}
		}
	}

	if isLoop[inst.Op] || inst.Op == JCXZ || inst.Op == JECXZ || inst.Op == JRCXZ {
		for i, p := range inst.Prefix {
			if p == PrefixPT || p == PrefixPN {
				inst.Prefix[i] |= PrefixImplicit
			}
		}
	}

	switch inst.Op {
	case AAA, AAS, CBW, CDQE, CLC, CLD, CLI, CLTS, CMC, CPUID, CQO, CWD, DAA, DAS,
		FDECSTP, FINCSTP, FNCLEX, FNINIT, FNOP, FWAIT, HLT,
		ICEBP, INSB, INSD, INSW, INT, INTO, INVD, IRET, IRETQ,
		LAHF, LEAVE, LRET, MONITOR, MWAIT, NOP, OUTSB, OUTSD, OUTSW,
		PAUSE, POPA, POPF, POPFQ, PUSHA, PUSHF, PUSHFQ,
		RDMSR, RDPMC, RDTSC, RDTSCP, RET, RSM,
		SAHF, STC, STD, STI, SYSENTER, SYSEXIT, SYSRET,
		UD2, WBINVD, WRMSR, XEND, XLATB, XTEST:

		if inst.Op == NOP && inst.Opcode>>24 != 0x90 {
			break
		}
		if inst.Op == RET && inst.Opcode>>24 != 0xC3 {
			break
		}
		if inst.Op == INT && inst.Opcode>>24 != 0xCC {
			break
		}
		if inst.Op == LRET && inst.Opcode>>24 != 0xcb {
			break
		}
		for i, p := range inst.Prefix {
			if p&0xFF == PrefixDataSize {
				inst.Prefix[i] &^= PrefixImplicit | PrefixIgnored
			}
		}

	case 0:
		// ok
	}

	switch inst.Op {
	case INSB, INSD, INSW, OUTSB, OUTSD, OUTSW, MONITOR, MWAIT, XLATB:
		iargs = nil

	case STOSB, STOSW, STOSD, STOSQ:
		iargs = iargs[:1]

	case LODSB, LODSW, LODSD, LODSQ, SCASB, SCASW, SCASD, SCASQ:
		iargs = iargs[1:]
	}

	const (
		haveData16 = 1 << iota
		haveData32
		haveAddr16
		haveAddr32
		haveXacquire
		haveXrelease
		haveLock
		haveHintTaken
		haveHintNotTaken
		haveBnd
	)
	var prefixBits uint32
	prefix := ""
	for _, p := range inst.Prefix {
		if p == 0 {
			break
		}
		if p&0xFF == 0xF3 {
			prefixBits &^= haveBnd
		}
		if p&(PrefixImplicit|PrefixIgnored) != 0 {
			continue
		}
		switch p {
		default:
			prefix += strings.ToLower(p.String()) + " "
		case PrefixCS, PrefixDS, PrefixES, PrefixFS, PrefixGS, PrefixSS:
			if inst.Op == 0 {
				prefix += strings.ToLower(p.String()) + " "
			}
		case PrefixREPN:
			prefix += "repne "
		case PrefixLOCK:
			prefixBits |= haveLock
		case PrefixData16, PrefixDataSize:
			prefixBits |= haveData16
		case PrefixData32:
			prefixBits |= haveData32
		case PrefixAddrSize, PrefixAddr16:
			prefixBits |= haveAddr16
		case PrefixAddr32:
			prefixBits |= haveAddr32
		case PrefixXACQUIRE:
			prefixBits |= haveXacquire
		case PrefixXRELEASE:
			prefixBits |= haveXrelease
		case PrefixPT:
			prefixBits |= haveHintTaken
		case PrefixPN:
			prefixBits |= haveHintNotTaken
		case PrefixBND:
			prefixBits |= haveBnd
		}
	}
	switch inst.Op {
	case JMP:
		if inst.Opcode>>24 == 0xEB {
			prefixBits &^= haveBnd
		}
	case RET, LRET:
		prefixBits &^= haveData16 | haveData32
	}

	if prefixBits&haveXacquire != 0 {
		prefix += "xacquire "
	}
	if prefixBits&haveXrelease != 0 {
		prefix += "xrelease "
	}
	if prefixBits&haveLock != 0 {
		prefix += "lock "
	}
	if prefixBits&haveBnd != 0 {
		prefix += "bnd "
	}
	if prefixBits&haveHintTaken != 0 {
		prefix += "hint-taken "
	}
	if prefixBits&haveHintNotTaken != 0 {
		prefix += "hint-not-taken "
	}
	if prefixBits&haveAddr16 != 0 {
		prefix += "addr16 "
	}
	if prefixBits&haveAddr32 != 0 {
		prefix += "addr32 "
	}
	if prefixBits&haveData16 != 0 {
		prefix += "data16 "
	}
	if prefixBits&haveData32 != 0 {
		prefix += "data32 "
	}

	if inst.Op == 0 {
		if prefix == "" {
			return "<no instruction>"
		}
		return prefix[:len(prefix)-1]
	}

	var args []string
	for _, a := range iargs {
		if a == nil {
			break
		}
		args = append(args, intelArg(&inst, a))
	}

	var op string
	switch inst.Op {
	case NOP:
		if inst.Opcode>>24 == 0x0F {
			if inst.DataSize == 16 {
				args = append(args, "ax")
			} else {
				args = append(args, "eax")
			}
		}

	case BLENDVPD, BLENDVPS, PBLENDVB:
		args = args[:2]

	case INT:
		if inst.Opcode>>24 == 0xCC {
			args = nil
			op = "int3"
		}

	case LCALL, LJMP:
		if len(args) == 2 {
			args[0], args[1] = args[1], args[0]
		}

	case FCHS, FABS, FTST, FLDPI, FLDL2E, FLDLG2, F2XM1, FXAM, FLD1, FLDL2T, FSQRT, FRNDINT, FCOS, FSIN:
		if len(args) == 0 {
			args = append(args, "st0")
		}

	case FPTAN, FSINCOS, FUCOMPP, FCOMPP, FYL2X, FPATAN, FXTRACT, FPREM1, FPREM, FYL2XP1, FSCALE:
		if len(args) == 0 {
			args = []string{"st0", "st1"}
		}

	case FST, FSTP, FISTTP, FIST, FISTP, FBSTP:
		if len(args) == 1 {
			args = append(args, "st0")
		}

	case FLD, FXCH, FCOM, FCOMP, FIADD, FIMUL, FICOM, FICOMP, FISUBR, FIDIV, FUCOM, FUCOMP, FILD, FBLD, FADD, FMUL, FSUB, FSUBR, FISUB, FDIV, FDIVR, FIDIVR:
		if len(args) == 1 {
			args = []string{"st0", args[0]}
		}

	case MASKMOVDQU, MASKMOVQ, XLATB, OUTSB, OUTSW, OUTSD:
	FixSegment:
		for i := len(inst.Prefix) - 1; i >= 0; i-- {
			p := inst.Prefix[i] & 0xFF
			switch p {
			case PrefixCS, PrefixES, PrefixFS, PrefixGS, PrefixSS:
				if inst.Mode != 64 || p == PrefixFS || p == PrefixGS {
					args = append(args, strings.ToLower((inst.Prefix[i] & 0xFF).String()))
					break FixSegment
				}
			case PrefixDS:
				if inst.Mode != 64 {
					break FixSegment
				}
			}
		}
	}

	if op == "" {
		op = intelOp[inst.Op]
	}
	if op == "" {
		op = strings.ToLower(inst.Op.String())
	}
	if args != nil {
		op += " " + strings.Join(args, ", ")
	}
	return prefix + op
}

func intelArg(inst *Inst, arg Arg) string {
	switch a := arg.(type) {
	case Imm:
		if inst.Mode == 32 {
			return fmt.Sprintf("%#x", uint32(a))
		}
		if Imm(int32(a)) == a {
			return fmt.Sprintf("%#x", int64(a))
		}
		return fmt.Sprintf("%#x", uint64(a))
	case Mem:
		if a.Base == EIP {
			a.Base = RIP
		}
		prefix := ""
		switch inst.MemBytes {
		case 1:
			prefix = "byte "
		case 2:
			prefix = "word "
		case 4:
			prefix = "dword "
		case 8:
			prefix = "qword "
		case 16:
			prefix = "xmmword "
		}
		switch inst.Op {
		case INVLPG:
			prefix = "byte "
		case STOSB, MOVSB, CMPSB, LODSB, SCASB:
			prefix = "byte "
		case STOSW, MOVSW, CMPSW, LODSW, SCASW:
			prefix = "word "
		case STOSD, MOVSD, CMPSD, LODSD, SCASD:
			prefix = "dword "
		case STOSQ, MOVSQ, CMPSQ, LODSQ, SCASQ:
			prefix = "qword "
		case LAR:
			prefix = "word "
		case BOUND:
			if inst.Mode == 32 {
				prefix = "qword "
			} else {
				prefix = "dword "
			}
		case PREFETCHW, PREFETCHNTA, PREFETCHT0, PREFETCHT1, PREFETCHT2, CLFLUSH:
			prefix = "zmmword "
		}
		switch inst.Op {
		case MOVSB, MOVSW, MOVSD, MOVSQ, CMPSB, CMPSW, CMPSD, CMPSQ, STOSB, STOSW, STOSD, STOSQ, SCASB, SCASW, SCASD, SCASQ, LODSB, LODSW, LODSD, LODSQ:
			switch a.Base {
			case DI, EDI, RDI:
				if a.Segment == ES {
					a.Segment = 0
				}
			case SI, ESI, RSI:
				if a.Segment == DS {
					a.Segment = 0
				}
			}
		case LEA:
			a.Segment = 0
		default:
			switch a.Base {
			case SP, ESP, RSP, BP, EBP, RBP:
				if a.Segment == SS {
					a.Segment = 0
				}
			default:
				if a.Segment == DS {
					a.Segment = 0
				}
			}
		}

		if inst.Mode == 64 && a.Segment != FS && a.Segment != GS {
			a.Segment = 0
		}

		prefix += "ptr "
		if a.Segment != 0 {
			prefix += strings.ToLower(a.Segment.String()) + ":"
		}
		prefix += "["
		if a.Base != 0 {
			prefix += intelArg(inst, a.Base)
		}
		if a.Scale != 0 && a.Index != 0 {
			if a.Base != 0 {
				prefix += "+"
			}
			prefix += fmt.Sprintf("%s*%d", intelArg(inst, a.Index), a.Scale)
		}
		if a.Disp != 0 {
			if prefix[len(prefix)-1] == '[' && (a.Disp >= 0 || int64(int32(a.Disp)) != a.Disp) {
				prefix += fmt.Sprintf("%#x", uint64(a.Disp))
			} else {
				prefix += fmt.Sprintf("%+#x", a.Disp)
			}
		}
		prefix += "]"
		return prefix
	case Rel:
		return fmt.Sprintf(".%+#x", int64(a))
	case Reg:
		if int(a) < len(intelReg) && intelReg[a] != "" {
			return intelReg[a]
		}
	}
	return strings.ToLower(arg.String())
}

var intelOp = map[Op]string{
	JAE:       "jnb",
	JA:        "jnbe",
	JGE:       "jnl",
	JNE:       "jnz",
	JG:        "jnle",
	JE:        "jz",
	SETAE:     "setnb",
	SETA:      "setnbe",
	SETGE:     "setnl",
	SETNE:     "setnz",
	SETG:      "setnle",
	SETE:      "setz",
	CMOVAE:    "cmovnb",
	CMOVA:     "cmovnbe",
	CMOVGE:    "cmovnl",
	CMOVNE:    "cmovnz",
	CMOVG:     "cmovnle",
	CMOVE:     "cmovz",
	LCALL:     "call far",
	LJMP:      "jmp far",
	LRET:      "ret far",
	ICEBP:     "int1",
	MOVSD_XMM: "movsd",
	XLATB:     "xlat",
}

var intelReg = [...]string{
	F0:  "st0",
	F1:  "st1",
	F2:  "st2",
	F3:  "st3",
	F4:  "st4",
	F5:  "st5",
	F6:  "st6",
	F7:  "st7",
	M0:  "mmx0",
	M1:  "mmx1",
	M2:  "mmx2",
	M3:  "mmx3",
	M4:  "mmx4",
	M5:  "mmx5",
	M6:  "mmx6",
	M7:  "mmx7",
	X0:  "xmm0",
	X1:  "xmm1",
	X2:  "xmm2",
	X3:  "xmm3",
	X4:  "xmm4",
	X5:  "xmm5",
	X6:  "xmm6",
	X7:  "xmm7",
	X8:  "xmm8",
	X9:  "xmm9",
	X10: "xmm10",
	X11: "xmm11",
	X12: "xmm12",
	X13: "xmm13",
	X14: "xmm14",
	X15: "xmm15",

	// TODO: Maybe the constants are named wrong.
	SPB: "spl",
	BPB: "bpl",
	SIB: "sil",
	DIB: "dil",

	R8L:  "r8d",
	R9L:  "r9d",
	R10L: "r10d",
	R11L: "r11d",
	R12L: "r12d",
	R13L: "r13d",
	R14L: "r14d",
	R15L: "r15d",
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/objdump_test.go                                       0100644 0000000 0000000 00000022605 12600426226 022231  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"bytes"
	"strings"
	"testing"
)

func TestObjdump32Manual(t *testing.T)   { testObjdump32(t, hexCases(t, objdumpManualTests)) }
func TestObjdump32Testdata(t *testing.T) { testObjdump32(t, concat(basicPrefixes, testdataCases(t))) }
func TestObjdump32ModRM(t *testing.T)    { testObjdump32(t, concat(basicPrefixes, enumModRM)) }
func TestObjdump32OneByte(t *testing.T)  { testBasic(t, testObjdump32) }
func TestObjdump320F(t *testing.T)       { testBasic(t, testObjdump32, 0x0F) }
func TestObjdump320F38(t *testing.T)     { testBasic(t, testObjdump32, 0x0F, 0x38) }
func TestObjdump320F3A(t *testing.T)     { testBasic(t, testObjdump32, 0x0F, 0x3A) }
func TestObjdump32Prefix(t *testing.T)   { testPrefix(t, testObjdump32) }

func TestObjdump64Manual(t *testing.T)   { testObjdump64(t, hexCases(t, objdumpManualTests)) }
func TestObjdump64Testdata(t *testing.T) { testObjdump64(t, concat(basicPrefixes, testdataCases(t))) }
func TestObjdump64ModRM(t *testing.T)    { testObjdump64(t, concat(basicPrefixes, enumModRM)) }
func TestObjdump64OneByte(t *testing.T)  { testBasic(t, testObjdump64) }
func TestObjdump640F(t *testing.T)       { testBasic(t, testObjdump64, 0x0F) }
func TestObjdump640F38(t *testing.T)     { testBasic(t, testObjdump64, 0x0F, 0x38) }
func TestObjdump640F3A(t *testing.T)     { testBasic(t, testObjdump64, 0x0F, 0x3A) }
func TestObjdump64Prefix(t *testing.T)   { testPrefix(t, testObjdump64) }

func TestObjdump64REXTestdata(t *testing.T) {
	testObjdump64(t, filter(concat3(basicPrefixes, rexPrefixes, testdataCases(t)), isValidREX))
}
func TestObjdump64REXModRM(t *testing.T) {
	testObjdump64(t, concat3(basicPrefixes, rexPrefixes, enumModRM))
}
func TestObjdump64REXOneByte(t *testing.T) { testBasicREX(t, testObjdump64) }
func TestObjdump64REX0F(t *testing.T)      { testBasicREX(t, testObjdump64, 0x0F) }
func TestObjdump64REX0F38(t *testing.T)    { testBasicREX(t, testObjdump64, 0x0F, 0x38) }
func TestObjdump64REX0F3A(t *testing.T)    { testBasicREX(t, testObjdump64, 0x0F, 0x3A) }
func TestObjdump64REXPrefix(t *testing.T)  { testPrefixREX(t, testObjdump64) }

// objdumpManualTests holds test cases that will be run by TestObjdumpManual.
// If you are debugging a few cases that turned up in a longer run, it can be useful
// to list them here and then use -run=ObjdumpManual, particularly with tracing enabled.
var objdumpManualTests = `
F390
`

// allowedMismatchObjdump reports whether the mismatch between text and dec
// should be allowed by the test.
func allowedMismatchObjdump(text string, size int, inst *Inst, dec ExtInst) bool {
	if size == 15 && dec.nenc == 15 && contains(text, "truncated") && contains(dec.text, "(bad)") {
		return true
	}

	if i := strings.LastIndex(dec.text, " "); isPrefix(dec.text[i+1:]) && size == 1 && isPrefix(text) {
		return true
	}

	if size == dec.nenc && contains(dec.text, "movupd") && contains(dec.text, "data32") {
		s := strings.Replace(dec.text, "data32 ", "", -1)
		if text == s {
			return true
		}
	}

	// Simplify our invalid instruction text.
	if text == "error: unrecognized instruction" {
		text = "BAD"
	}

	// Invalid instructions for which libopcodes prints %? register.
	// FF E8 11 22 33 44:
	// Invalid instructions for which libopcodes prints "internal disassembler error".
	// Invalid instructions for which libopcodes prints 8087 only (e.g., DB E0)
	// or prints 287 only (e.g., DB E4).
	if contains(dec.text, "%?", "<internal disassembler error>", "(8087 only)", "(287 only)") {
		dec.text = "(bad)"
	}

	// 0F 19 11, 0F 1C 11, 0F 1D 11, 0F 1E 11, 0F 1F 11: libopcodes says nop,
	// but the Intel manuals say that the only NOP there is 0F 1F /0.
	// Perhaps libopcodes is reporting an older encoding.
	i := bytes.IndexByte(dec.enc[:], 0x0F)
	if contains(dec.text, "nop") && i >= 0 && i+2 < len(dec.enc) && dec.enc[i+1]&^7 == 0x18 && (dec.enc[i+1] != 0x1F || (dec.enc[i+2]>>3)&7 != 0) {
		dec.text = "(bad)"
	}

	// Any invalid instruction.
	if text == "BAD" && contains(dec.text, "(bad)") {
		return true
	}

	// Instructions libopcodes knows but we do not (e.g., 0F 19 11).
	if (text == "BAD" || size == 1 && isPrefix(text)) && hasPrefix(dec.text, unsupported...) {
		return true
	}

	// Instructions we know but libopcodes does not (e.g., 0F D0 11).
	if (contains(dec.text, "(bad)") || dec.nenc == 1 && isPrefix(dec.text)) && hasPrefix(text, libopcodesUnsupported...) {
		return true
	}

	// Libopcodes rejects F2 90 as NOP. Not sure why.
	if (contains(dec.text, "(bad)") || dec.nenc == 1 && isPrefix(dec.text)) && inst.Opcode>>24 == 0x90 && countPrefix(inst, 0xF2) > 0 {
		return true
	}

	// 0F 20 11, 0F 21 11, 0F 22 11, 0F 23 11, 0F 24 11:
	// Moves into and out of some control registers seem to be unsupported by libopcodes.
	// TODO(rsc): Are they invalid somehow?
	if (contains(dec.text, "(bad)") || dec.nenc == 1 && isPrefix(dec.text)) && contains(text, "%cr", "%db", "%tr") {
		return true
	}

	if contains(dec.text, "fwait") && dec.nenc == 1 && dec.enc[0] != 0x9B {
		return true
	}

	// 9B D9 11: libopcodes reports FSTSW instead of FWAIT + FNSTSW.
	// This is correct in that FSTSW is a pseudo-op for the pair, but it really
	// is a pair of instructions: execution can stop between them.
	// Our decoder chooses to separate them.
	if (text == "fwait" || strings.HasSuffix(text, " fwait")) && dec.nenc >= len(strings.Fields(text)) && dec.enc[len(strings.Fields(text))-1] == 0x9B {
		return true
	}

	// 0F 18 77 11:
	// Invalid instructions for which libopcodes prints "nop/reserved".
	// Perhaps libopcodes is reporting an older encoding.
	if text == "BAD" && contains(dec.text, "nop/reserved") {
		return true
	}

	// 0F C7 B0 11 22 33 44: libopcodes says vmptrld 0x44332211(%eax); we say rdrand %eax.
	// TODO(rsc): Fix, since we are probably wrong, but we don't have vmptrld in the manual.
	if contains(text, "rdrand") && contains(dec.text, "vmptrld", "vmxon", "vmclear") {
		return true
	}

	// DD C8: libopcodes says FNOP but the Intel manual is clear FNOP is only D9 D0.
	// Perhaps libopcodes is reporting an older encoding.
	if text == "BAD" && contains(dec.text, "fnop") && (dec.enc[0] != 0xD9 || dec.enc[1] != 0xD0) {
		return true
	}

	// 66 90: libopcodes says xchg %ax,%ax; we say 'data16 nop'.
	// The 16-bit swap will preserve the high bits of the register,
	// so they are the same.
	if contains(text, "nop") && contains(dec.text, "xchg %ax,%ax") {
		return true
	}

	// If there are multiple prefixes, allow libopcodes to use an alternate name.
	if size == 1 && dec.nenc == 1 && prefixByte[text] > 0 && prefixByte[text] == prefixByte[dec.text] {
		return true
	}

	// 26 9B: libopcodes reports "fwait"/1, ignoring segment prefix.
	// https://sourceware.org/bugzilla/show_bug.cgi?id=16891
	// F0 82: Decode="lock"/1 but libopcodes="lock (bad)"/2.
	if size == 1 && dec.nenc >= 1 && prefixByte[text] == dec.enc[0] && contains(dec.text, "(bad)", "fwait", "fnop") {
		return true
	}

	// libopcodes interprets 660f801122 as taking a rel16 but
	// truncating the address at 16 bits. Not sure what is correct.
	if contains(text, ".+0x2211", ".+0x11") && contains(dec.text, " .-") {
		return true
	}

	// 66 F3 0F D6 C5, 66 F2 0F D6 C0: libopcodes reports use of XMM register instead of MMX register,
	// but only when the instruction has a 66 prefix. Maybe they know something we don't.
	if countPrefix(inst, 0x66) > 0 && contains(dec.text, "movdq2q", "movq2dq") && !contains(dec.text, "%mm") {
		return true
	}

	// 0F 01 F8, 0F 05, 0F 07: these are 64-bit instructions but libopcodes accepts them.
	if (text == "BAD" || size == 1 && isPrefix(text)) && contains(dec.text, "swapgs", "syscall", "sysret", "rdfsbase", "rdgsbase", "wrfsbase", "wrgsbase") {
		return true
	}

	return false
}

// Instructions known to libopcodes (or xed) but not to us.
// Most of these come from supplementary manuals of one form or another.
var unsupported = strings.Fields(`
	bndc
	bndl
	bndm
	bnds
	clac
	clgi
	femms
	fldln
	fldz
	getsec
	invlpga
	kmov
	montmul
	pavg
	pf2i
	pfacc
	pfadd
	pfcmp
	pfmax
	pfmin
	pfmul
	pfna
	pfpnac
	pfrc
	pfrs
	pfsub
	phadd
	phsub
	pi2f
	pmulhr
	prefetch
	pswap
	ptest
	rdseed
	sha1
	sha256
	skinit
	stac
	stgi
	vadd
	vand
	vcmp
	vcomis
	vcvt
	vcvt
	vdiv
	vhadd
	vhsub
	vld
	vmax
	vmcall
	vmfunc
	vmin
	vmlaunch
	vmload
	vmmcall
	vmov
	vmov
	vmov
	vmptrld
	vmptrst
	vmread
	vmresume
	vmrun
	vmsave
	vmul
	vmwrite
	vmxoff
	vor
	vpack
	vpadd
	vpand
	vpavg
	vpcmp
	vpcmp
	vpins
	vpmadd
	vpmax
	vpmin
	vpmul
	vpmul
	vpor
	vpsad
	vpshuf
	vpsll
	vpsra
	vpsrad
	vpsrl
	vpsub
	vpunp
	vpxor
	vrcp
	vrsqrt
	vshuf
	vsqrt
	vsub
	vucomis
	vunp
	vxor
	vzero
	xcrypt
	xsha1
	xsha256
	xstore-rng
	insertq
	extrq
	vmclear
	invvpid
	adox
	vmxon
	invept
	adcx
	vmclear
	prefetchwt1
	enclu
	encls
	salc
	fstpnce
	fdisi8087_nop
	fsetpm287_nop
	feni8087_nop
	syscall
	sysret
`)

// Instructions known to us but not to libopcodes (at least in binutils 2.24).
var libopcodesUnsupported = strings.Fields(`
	addsubps
	aes
	blend
	cvttpd2dq
	dpp
	extract
	haddps
	hsubps
	insert
	invpcid
	lddqu
	movmsk
	movnt
	movq2dq
	mps
	pack
	pblend
	pclmul
	pcmp
	pext
	phmin
	pins
	pmax
	pmin
	pmov
	pmovmsk
	pmul
	popcnt
	pslld
	psllq
	psllw
	psrad
	psraw
	psrl
	ptest
	punpck
	round
	xrstor
	xsavec
	xsaves
	comis
	ucomis
	movhps
	movntps
	rsqrt
	rcpp
	puncpck
	bsf
	movq2dq
	cvttpd2dq
	movq
	hsubpd
	movdqa
	movhpd
	addsubpd
	movd
	haddpd
	cvtps2dq
	bsr
	cvtdq2ps
	rdrand
	maskmov
	movq2dq
	movlhps
	movbe
	movlpd
`)
                                                                                                                           root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/objdumpext_test.go                                    0100644 0000000 0000000 00000017210 12600426226 022746  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"bytes"
	"debug/elf"
	"encoding/binary"
	"fmt"
	"io"
	"log"
	"os"
	"strconv"
	"strings"
	"testing"
)

// Apologies for the proprietary path, but we need objdump 2.24 + some committed patches that will land in 2.25.
const objdumpPath = "/Users/rsc/bin/objdump2"

func testObjdump32(t *testing.T, generate func(func([]byte))) {
	testObjdumpArch(t, generate, 32)
}

func testObjdump64(t *testing.T, generate func(func([]byte))) {
	testObjdumpArch(t, generate, 64)
}

func testObjdumpArch(t *testing.T, generate func(func([]byte)), arch int) {
	if testing.Short() {
		t.Skip("skipping objdump test in short mode")
	}

	if _, err := os.Stat(objdumpPath); err != nil {
		t.Fatal(err)
	}

	testExtDis(t, "gnu", arch, objdump, generate, allowedMismatchObjdump)
}

func objdump(ext *ExtDis) error {
	// File already written with instructions; add ELF header.
	if ext.Arch == 32 {
		if err := writeELF32(ext.File, ext.Size); err != nil {
			return err
		}
	} else {
		if err := writeELF64(ext.File, ext.Size); err != nil {
			return err
		}
	}

	b, err := ext.Run(objdumpPath, "-d", "-z", ext.File.Name())
	if err != nil {
		return err
	}

	var (
		nmatch  int
		reading bool
		next    uint32 = start
		addr    uint32
		encbuf  [32]byte
		enc     []byte
		text    string
	)
	flush := func() {
		if addr == next {
			switch text {
			case "repz":
				text = "rep"
			case "repnz":
				text = "repn"
			default:
				text = strings.Replace(text, "repz ", "rep ", -1)
				text = strings.Replace(text, "repnz ", "repn ", -1)
			}
			if m := pcrelw.FindStringSubmatch(text); m != nil {
				targ, _ := strconv.ParseUint(m[2], 16, 64)
				text = fmt.Sprintf("%s .%+#x", m[1], int16(uint32(targ)-uint32(uint16(addr))-uint32(len(enc))))
			}
			if m := pcrel.FindStringSubmatch(text); m != nil {
				targ, _ := strconv.ParseUint(m[2], 16, 64)
				text = fmt.Sprintf("%s .%+#x", m[1], int32(uint32(targ)-addr-uint32(len(enc))))
			}
			text = strings.Replace(text, "0x0(", "(", -1)
			text = strings.Replace(text, "%st(0)", "%st", -1)

			ext.Dec <- ExtInst{addr, encbuf, len(enc), text}
			encbuf = [32]byte{}
			enc = nil
			next += 32
		}
	}
	var textangle = []byte("<.text>:")
	for {
		line, err := b.ReadSlice('\n')
		if err != nil {
			if err == io.EOF {
				break
			}
			return fmt.Errorf("reading objdump output: %v", err)
		}
		if bytes.Contains(line, textangle) {
			reading = true
			continue
		}
		if !reading {
			continue
		}
		if debug {
			os.Stdout.Write(line)
		}
		if enc1 := parseContinuation(line, encbuf[:len(enc)]); enc1 != nil {
			enc = enc1
			continue
		}
		flush()
		nmatch++
		addr, enc, text = parseLine(line, encbuf[:0])
		if addr > next {
			return fmt.Errorf("address out of sync expected <= %#x at %q in:\n%s", next, line, line)
		}
	}
	flush()
	if next != start+uint32(ext.Size) {
		return fmt.Errorf("not enough results found [%d %d]", next, start+ext.Size)
	}
	if err := ext.Wait(); err != nil {
		return fmt.Errorf("exec: %v", err)
	}

	return nil
}

func parseLine(line []byte, encstart []byte) (addr uint32, enc []byte, text string) {
	oline := line
	i := index(line, ":\t")
	if i < 0 {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}
	x, err := strconv.ParseUint(string(trimSpace(line[:i])), 16, 32)
	if err != nil {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}
	addr = uint32(x)
	line = line[i+2:]
	i = bytes.IndexByte(line, '\t')
	if i < 0 {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}
	enc, ok := parseHex(line[:i], encstart)
	if !ok {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}
	line = trimSpace(line[i:])
	if i := bytes.IndexByte(line, '#'); i >= 0 {
		line = trimSpace(line[:i])
	}
	text = string(fixSpace(line))
	return
}

func parseContinuation(line []byte, enc []byte) []byte {
	i := index(line, ":\t")
	if i < 0 {
		return nil
	}
	line = line[i+1:]
	enc, _ = parseHex(line, enc)
	return enc
}

// writeELF32 writes an ELF32 header to the file,
// describing a text segment that starts at start
// and extends for size bytes.
func writeELF32(f *os.File, size int) error {
	f.Seek(0, 0)
	var hdr elf.Header32
	var prog elf.Prog32
	var sect elf.Section32
	var buf bytes.Buffer
	binary.Write(&buf, binary.LittleEndian, &hdr)
	off1 := buf.Len()
	binary.Write(&buf, binary.LittleEndian, &prog)
	off2 := buf.Len()
	binary.Write(&buf, binary.LittleEndian, &sect)
	off3 := buf.Len()
	buf.Reset()
	data := byte(elf.ELFDATA2LSB)
	hdr = elf.Header32{
		Ident:     [16]byte{0x7F, 'E', 'L', 'F', 1, data, 1},
		Type:      2,
		Machine:   uint16(elf.EM_386),
		Version:   1,
		Entry:     start,
		Phoff:     uint32(off1),
		Shoff:     uint32(off2),
		Flags:     0x05000002,
		Ehsize:    uint16(off1),
		Phentsize: uint16(off2 - off1),
		Phnum:     1,
		Shentsize: uint16(off3 - off2),
		Shnum:     3,
		Shstrndx:  2,
	}
	binary.Write(&buf, binary.LittleEndian, &hdr)
	prog = elf.Prog32{
		Type:   1,
		Off:    start,
		Vaddr:  start,
		Paddr:  start,
		Filesz: uint32(size),
		Memsz:  uint32(size),
		Flags:  5,
		Align:  start,
	}
	binary.Write(&buf, binary.LittleEndian, &prog)
	binary.Write(&buf, binary.LittleEndian, &sect) // NULL section
	sect = elf.Section32{
		Name:      1,
		Type:      uint32(elf.SHT_PROGBITS),
		Addr:      start,
		Off:       start,
		Size:      uint32(size),
		Flags:     uint32(elf.SHF_ALLOC | elf.SHF_EXECINSTR),
		Addralign: 4,
	}
	binary.Write(&buf, binary.LittleEndian, &sect) // .text
	sect = elf.Section32{
		Name:      uint32(len("\x00.text\x00")),
		Type:      uint32(elf.SHT_STRTAB),
		Addr:      0,
		Off:       uint32(off2 + (off3-off2)*3),
		Size:      uint32(len("\x00.text\x00.shstrtab\x00")),
		Addralign: 1,
	}
	binary.Write(&buf, binary.LittleEndian, &sect)
	buf.WriteString("\x00.text\x00.shstrtab\x00")
	f.Write(buf.Bytes())
	return nil
}

// writeELF64 writes an ELF64 header to the file,
// describing a text segment that starts at start
// and extends for size bytes.
func writeELF64(f *os.File, size int) error {
	f.Seek(0, 0)
	var hdr elf.Header64
	var prog elf.Prog64
	var sect elf.Section64
	var buf bytes.Buffer
	binary.Write(&buf, binary.LittleEndian, &hdr)
	off1 := buf.Len()
	binary.Write(&buf, binary.LittleEndian, &prog)
	off2 := buf.Len()
	binary.Write(&buf, binary.LittleEndian, &sect)
	off3 := buf.Len()
	buf.Reset()
	data := byte(elf.ELFDATA2LSB)
	hdr = elf.Header64{
		Ident:     [16]byte{0x7F, 'E', 'L', 'F', 2, data, 1},
		Type:      2,
		Machine:   uint16(elf.EM_X86_64),
		Version:   1,
		Entry:     start,
		Phoff:     uint64(off1),
		Shoff:     uint64(off2),
		Flags:     0x05000002,
		Ehsize:    uint16(off1),
		Phentsize: uint16(off2 - off1),
		Phnum:     1,
		Shentsize: uint16(off3 - off2),
		Shnum:     3,
		Shstrndx:  2,
	}
	binary.Write(&buf, binary.LittleEndian, &hdr)
	prog = elf.Prog64{
		Type:   1,
		Off:    start,
		Vaddr:  start,
		Paddr:  start,
		Filesz: uint64(size),
		Memsz:  uint64(size),
		Flags:  5,
		Align:  start,
	}
	binary.Write(&buf, binary.LittleEndian, &prog)
	binary.Write(&buf, binary.LittleEndian, &sect) // NULL section
	sect = elf.Section64{
		Name:      1,
		Type:      uint32(elf.SHT_PROGBITS),
		Addr:      start,
		Off:       start,
		Size:      uint64(size),
		Flags:     uint64(elf.SHF_ALLOC | elf.SHF_EXECINSTR),
		Addralign: 4,
	}
	binary.Write(&buf, binary.LittleEndian, &sect) // .text
	sect = elf.Section64{
		Name:      uint32(len("\x00.text\x00")),
		Type:      uint32(elf.SHT_STRTAB),
		Addr:      0,
		Off:       uint64(off2 + (off3-off2)*3),
		Size:      uint64(len("\x00.text\x00.shstrtab\x00")),
		Addralign: 1,
	}
	binary.Write(&buf, binary.LittleEndian, &sect)
	buf.WriteString("\x00.text\x00.shstrtab\x00")
	f.Write(buf.Bytes())
	return nil
}
                                                                                                                                                                                                                                                                                                                                                                                        root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/plan9ext_test.go                                      0100644 0000000 0000000 00000005406 12600426226 022335  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"os"
	"strconv"
	"testing"
)

const plan9Path = "testdata/libmach8db"

func testPlan9Arch(t *testing.T, arch int, generate func(func([]byte))) {
	if testing.Short() {
		t.Skip("skipping libmach test in short mode")
	}

	if _, err := os.Stat(plan9Path); err != nil {
		t.Fatal(err)
	}

	testExtDis(t, "plan9", arch, plan9, generate, allowedMismatchPlan9)
}

func testPlan932(t *testing.T, generate func(func([]byte))) {
	testPlan9Arch(t, 32, generate)
}

func testPlan964(t *testing.T, generate func(func([]byte))) {
	testPlan9Arch(t, 64, generate)
}

func plan9(ext *ExtDis) error {
	flag := "-8"
	if ext.Arch == 64 {
		flag = "-6"
	}
	b, err := ext.Run(plan9Path, flag, ext.File.Name())
	if err != nil {
		return err
	}

	nmatch := 0
	next := uint32(start)
	var (
		addr   uint32
		encbuf [32]byte
		enc    []byte
		text   string
	)

	for {
		line, err := b.ReadSlice('\n')
		if err != nil {
			if err == io.EOF {
				break
			}
			return fmt.Errorf("reading libmach8db output: %v", err)
		}
		if debug {
			os.Stdout.Write(line)
		}
		nmatch++
		addr, enc, text = parseLinePlan9(line, encbuf[:0])
		if addr > next {
			return fmt.Errorf("address out of sync expected <= %#x at %q in:\n%s", next, line, line)
		}
		if addr < next {
			continue
		}
		if m := pcrelw.FindStringSubmatch(text); m != nil {
			targ, _ := strconv.ParseUint(m[2], 16, 64)
			text = fmt.Sprintf("%s .%+#x", m[1], int16(uint32(targ)-uint32(uint16(addr))-uint32(len(enc))))
		}
		if m := pcrel.FindStringSubmatch(text); m != nil {
			targ, _ := strconv.ParseUint(m[2], 16, 64)
			text = fmt.Sprintf("%s .%+#x", m[1], int32(uint32(targ)-addr-uint32(len(enc))))
		}
		ext.Dec <- ExtInst{addr, encbuf, len(enc), text}
		encbuf = [32]byte{}
		enc = nil
		next += 32
	}
	if next != start+uint32(ext.Size) {
		return fmt.Errorf("not enough results found [%d %d]", next, start+ext.Size)
	}
	if err := ext.Wait(); err != nil {
		return fmt.Errorf("exec: %v", err)
	}

	return nil
}

func parseLinePlan9(line []byte, encstart []byte) (addr uint32, enc []byte, text string) {
	i := bytes.IndexByte(line, ' ')
	if i < 0 || line[0] != '0' || line[1] != 'x' {
		log.Fatalf("cannot parse disassembly: %q", line)
	}
	j := bytes.IndexByte(line[i+1:], ' ')
	if j < 0 {
		log.Fatalf("cannot parse disassembly: %q", line)
	}
	j += i + 1
	x, err := strconv.ParseUint(string(trimSpace(line[2:i])), 16, 32)
	if err != nil {
		log.Fatalf("cannot parse disassembly: %q", line)
	}
	addr = uint32(x)
	enc, ok := parseHex(line[i+1:j], encstart)
	if !ok {
		log.Fatalf("cannot parse disassembly: %q", line)
	}
	return addr, enc, string(fixSpace(line[j+1:]))
}
                                                                                                                                                                                                                                                          root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/plan9x.go                                             0100644 0000000 0000000 00000014334 12600426226 020745  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"fmt"
	"strings"
)

// Plan9Syntax returns the Go assembler syntax for the instruction.
// The syntax was originally defined by Plan 9.
// The pc is the program counter of the instruction, used for expanding
// PC-relative addresses into absolute ones.
// The symname function queries the symbol table for the program
// being disassembled. Given a target address it returns the name and base
// address of the symbol containing the target, if any; otherwise it returns "", 0.
func Plan9Syntax(inst Inst, pc uint64, symname func(uint64) (string, uint64)) string {
	if symname == nil {
		symname = func(uint64) (string, uint64) { return "", 0 }
	}
	var args []string
	for i := len(inst.Args) - 1; i >= 0; i-- {
		a := inst.Args[i]
		if a == nil {
			continue
		}
		args = append(args, plan9Arg(&inst, pc, symname, a))
	}

	var last Prefix
	for _, p := range inst.Prefix {
		if p == 0 || p.IsREX() {
			break
		}
		last = p
	}

	prefix := ""
	switch last & 0xFF {
	case 0, 0x66, 0x67:
		// ignore
	case PrefixREPN:
		prefix += "REPNE "
	default:
		prefix += last.String() + " "
	}

	op := inst.Op.String()
	if plan9Suffix[inst.Op] {
		switch inst.DataSize {
		case 8:
			op += "B"
		case 16:
			op += "W"
		case 32:
			op += "L"
		case 64:
			op += "Q"
		}
	}

	if args != nil {
		op += " " + strings.Join(args, ", ")
	}

	return prefix + op
}

func plan9Arg(inst *Inst, pc uint64, symname func(uint64) (string, uint64), arg Arg) string {
	switch a := arg.(type) {
	case Reg:
		return plan9Reg[a]
	case Rel:
		if pc == 0 {
			break
		}
		// If the absolute address is the start of a symbol, use the name.
		// Otherwise use the raw address, so that things like relative
		// jumps show up as JMP 0x123 instead of JMP f+10(SB).
		// It is usually easier to search for 0x123 than to do the mental
		// arithmetic to find f+10.
		addr := pc + uint64(inst.Len) + uint64(a)
		if s, base := symname(addr); s != "" && addr == base {
			return fmt.Sprintf("%s(SB)", s)
		}
		return fmt.Sprintf("%#x", addr)

	case Imm:
		if s, base := symname(uint64(a)); s != "" {
			suffix := ""
			if uint64(a) != base {
				suffix = fmt.Sprintf("%+d", uint64(a)-base)
			}
			return fmt.Sprintf("$%s%s(SB)", s, suffix)
		}
		if inst.Mode == 32 {
			return fmt.Sprintf("$%#x", uint32(a))
		}
		if Imm(int32(a)) == a {
			return fmt.Sprintf("$%#x", int64(a))
		}
		return fmt.Sprintf("$%#x", uint64(a))
	case Mem:
		if a.Segment == 0 && a.Disp != 0 && a.Base == 0 && (a.Index == 0 || a.Scale == 0) {
			if s, base := symname(uint64(a.Disp)); s != "" {
				suffix := ""
				if uint64(a.Disp) != base {
					suffix = fmt.Sprintf("%+d", uint64(a.Disp)-base)
				}
				return fmt.Sprintf("%s%s(SB)", s, suffix)
			}
		}
		s := ""
		if a.Segment != 0 {
			s += fmt.Sprintf("%s:", plan9Reg[a.Segment])
		}
		if a.Disp != 0 {
			s += fmt.Sprintf("%#x", a.Disp)
		} else {
			s += "0"
		}
		if a.Base != 0 {
			s += fmt.Sprintf("(%s)", plan9Reg[a.Base])
		}
		if a.Index != 0 && a.Scale != 0 {
			s += fmt.Sprintf("(%s*%d)", plan9Reg[a.Index], a.Scale)
		}
		return s
	}
	return arg.String()
}

var plan9Suffix = [maxOp + 1]bool{
	ADC:       true,
	ADD:       true,
	AND:       true,
	BSF:       true,
	BSR:       true,
	BT:        true,
	BTC:       true,
	BTR:       true,
	BTS:       true,
	CMP:       true,
	CMPXCHG:   true,
	CVTSI2SD:  true,
	CVTSI2SS:  true,
	CVTSD2SI:  true,
	CVTSS2SI:  true,
	CVTTSD2SI: true,
	CVTTSS2SI: true,
	DEC:       true,
	DIV:       true,
	FLDENV:    true,
	FRSTOR:    true,
	IDIV:      true,
	IMUL:      true,
	IN:        true,
	INC:       true,
	LEA:       true,
	MOV:       true,
	MOVNTI:    true,
	MUL:       true,
	NEG:       true,
	NOP:       true,
	NOT:       true,
	OR:        true,
	OUT:       true,
	POP:       true,
	POPA:      true,
	PUSH:      true,
	PUSHA:     true,
	RCL:       true,
	RCR:       true,
	ROL:       true,
	ROR:       true,
	SAR:       true,
	SBB:       true,
	SHL:       true,
	SHLD:      true,
	SHR:       true,
	SHRD:      true,
	SUB:       true,
	TEST:      true,
	XADD:      true,
	XCHG:      true,
	XOR:       true,
}

var plan9Reg = [...]string{
	AL:   "AL",
	CL:   "CL",
	BL:   "BL",
	DL:   "DL",
	AH:   "AH",
	CH:   "CH",
	BH:   "BH",
	DH:   "DH",
	SPB:  "SP",
	BPB:  "BP",
	SIB:  "SI",
	DIB:  "DI",
	R8B:  "R8",
	R9B:  "R9",
	R10B: "R10",
	R11B: "R11",
	R12B: "R12",
	R13B: "R13",
	R14B: "R14",
	R15B: "R15",
	AX:   "AX",
	CX:   "CX",
	BX:   "BX",
	DX:   "DX",
	SP:   "SP",
	BP:   "BP",
	SI:   "SI",
	DI:   "DI",
	R8W:  "R8",
	R9W:  "R9",
	R10W: "R10",
	R11W: "R11",
	R12W: "R12",
	R13W: "R13",
	R14W: "R14",
	R15W: "R15",
	EAX:  "AX",
	ECX:  "CX",
	EDX:  "DX",
	EBX:  "BX",
	ESP:  "SP",
	EBP:  "BP",
	ESI:  "SI",
	EDI:  "DI",
	R8L:  "R8",
	R9L:  "R9",
	R10L: "R10",
	R11L: "R11",
	R12L: "R12",
	R13L: "R13",
	R14L: "R14",
	R15L: "R15",
	RAX:  "AX",
	RCX:  "CX",
	RDX:  "DX",
	RBX:  "BX",
	RSP:  "SP",
	RBP:  "BP",
	RSI:  "SI",
	RDI:  "DI",
	R8:   "R8",
	R9:   "R9",
	R10:  "R10",
	R11:  "R11",
	R12:  "R12",
	R13:  "R13",
	R14:  "R14",
	R15:  "R15",
	IP:   "IP",
	EIP:  "IP",
	RIP:  "IP",
	F0:   "F0",
	F1:   "F1",
	F2:   "F2",
	F3:   "F3",
	F4:   "F4",
	F5:   "F5",
	F6:   "F6",
	F7:   "F7",
	M0:   "M0",
	M1:   "M1",
	M2:   "M2",
	M3:   "M3",
	M4:   "M4",
	M5:   "M5",
	M6:   "M6",
	M7:   "M7",
	X0:   "X0",
	X1:   "X1",
	X2:   "X2",
	X3:   "X3",
	X4:   "X4",
	X5:   "X5",
	X6:   "X6",
	X7:   "X7",
	X8:   "X8",
	X9:   "X9",
	X10:  "X10",
	X11:  "X11",
	X12:  "X12",
	X13:  "X13",
	X14:  "X14",
	X15:  "X15",
	CS:   "CS",
	SS:   "SS",
	DS:   "DS",
	ES:   "ES",
	FS:   "FS",
	GS:   "GS",
	GDTR: "GDTR",
	IDTR: "IDTR",
	LDTR: "LDTR",
	MSW:  "MSW",
	TASK: "TASK",
	CR0:  "CR0",
	CR1:  "CR1",
	CR2:  "CR2",
	CR3:  "CR3",
	CR4:  "CR4",
	CR5:  "CR5",
	CR6:  "CR6",
	CR7:  "CR7",
	CR8:  "CR8",
	CR9:  "CR9",
	CR10: "CR10",
	CR11: "CR11",
	CR12: "CR12",
	CR13: "CR13",
	CR14: "CR14",
	CR15: "CR15",
	DR0:  "DR0",
	DR1:  "DR1",
	DR2:  "DR2",
	DR3:  "DR3",
	DR4:  "DR4",
	DR5:  "DR5",
	DR6:  "DR6",
	DR7:  "DR7",
	DR8:  "DR8",
	DR9:  "DR9",
	DR10: "DR10",
	DR11: "DR11",
	DR12: "DR12",
	DR13: "DR13",
	DR14: "DR14",
	DR15: "DR15",
	TR0:  "TR0",
	TR1:  "TR1",
	TR2:  "TR2",
	TR3:  "TR3",
	TR4:  "TR4",
	TR5:  "TR5",
	TR6:  "TR6",
	TR7:  "TR7",
}
                                                                                                                                                                                                                                                                                                    root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/plan9x_test.go                                        0100644 0000000 0000000 00000005315 12600426226 022003  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"strings"
	"testing"
)

func TestPlan932Manual(t *testing.T)   { testPlan932(t, hexCases(t, plan9ManualTests)) }
func TestPlan932Testdata(t *testing.T) { testPlan932(t, concat(basicPrefixes, testdataCases(t))) }
func TestPlan932ModRM(t *testing.T)    { testPlan932(t, concat(basicPrefixes, enumModRM)) }
func TestPlan932OneByte(t *testing.T)  { testBasic(t, testPlan932) }
func TestPlan9320F(t *testing.T)       { testBasic(t, testPlan932, 0x0F) }
func TestPlan9320F38(t *testing.T)     { testBasic(t, testPlan932, 0x0F, 0x38) }
func TestPlan9320F3A(t *testing.T)     { testBasic(t, testPlan932, 0x0F, 0x3A) }
func TestPlan932Prefix(t *testing.T)   { testPrefix(t, testPlan932) }

func TestPlan964Manual(t *testing.T)   { testPlan964(t, hexCases(t, plan9ManualTests)) }
func TestPlan964Testdata(t *testing.T) { testPlan964(t, concat(basicPrefixes, testdataCases(t))) }
func TestPlan964ModRM(t *testing.T)    { testPlan964(t, concat(basicPrefixes, enumModRM)) }
func TestPlan964OneByte(t *testing.T)  { testBasic(t, testPlan964) }
func TestPlan9640F(t *testing.T)       { testBasic(t, testPlan964, 0x0F) }
func TestPlan9640F38(t *testing.T)     { testBasic(t, testPlan964, 0x0F, 0x38) }
func TestPlan9640F3A(t *testing.T)     { testBasic(t, testPlan964, 0x0F, 0x3A) }
func TestPlan964Prefix(t *testing.T)   { testPrefix(t, testPlan964) }

func TestPlan964REXTestdata(t *testing.T) {
	testPlan964(t, filter(concat3(basicPrefixes, rexPrefixes, testdataCases(t)), isValidREX))
}
func TestPlan964REXModRM(t *testing.T)   { testPlan964(t, concat3(basicPrefixes, rexPrefixes, enumModRM)) }
func TestPlan964REXOneByte(t *testing.T) { testBasicREX(t, testPlan964) }
func TestPlan964REX0F(t *testing.T)      { testBasicREX(t, testPlan964, 0x0F) }
func TestPlan964REX0F38(t *testing.T)    { testBasicREX(t, testPlan964, 0x0F, 0x38) }
func TestPlan964REX0F3A(t *testing.T)    { testBasicREX(t, testPlan964, 0x0F, 0x3A) }
func TestPlan964REXPrefix(t *testing.T)  { testPrefixREX(t, testPlan964) }

// plan9ManualTests holds test cases that will be run by TestPlan9Manual32 and TestPlan9Manual64.
// If you are debugging a few cases that turned up in a longer run, it can be useful
// to list them here and then use -run=Plan9Manual, particularly with tracing enabled.
var plan9ManualTests = `
`

// allowedMismatchPlan9 reports whether the mismatch between text and dec
// should be allowed by the test.
func allowedMismatchPlan9(text string, size int, inst *Inst, dec ExtInst) bool {
	return false
}

// Instructions known to us but not to plan9.
var plan9Unsupported = strings.Fields(`
`)
                                                                                                                                                                                                                                                                                                                   root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/tables.go                                             0100644 0000000 0000000 00001014612 12600426226 021004  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // DO NOT EDIT
// generated by: x86map -fmt=decoder ../x86.csv

package x86asm

var decoder = [...]uint16{
	uint16(xFail),
	/*1*/ uint16(xCondByte), 243,
	0x00, 490,
	0x01, 496,
	0x02, 525,
	0x03, 531,
	0x04, 560,
	0x05, 566,
	0x06, 595,
	0x07, 602,
	0x08, 609,
	0x09, 615,
	0x0A, 644,
	0x0B, 650,
	0x0C, 679,
	0x0D, 685,
	0x0E, 714,
	0x0F, 721,
	0x10, 8026,
	0x11, 8032,
	0x12, 8061,
	0x13, 8067,
	0x14, 8096,
	0x15, 8102,
	0x16, 8131,
	0x17, 8138,
	0x18, 8145,
	0x19, 8151,
	0x1A, 8180,
	0x1B, 8186,
	0x1C, 8215,
	0x1D, 8221,
	0x1E, 8250,
	0x1F, 8257,
	0x20, 8264,
	0x21, 8270,
	0x22, 8299,
	0x23, 8305,
	0x24, 8334,
	0x25, 8340,
	0x27, 8369,
	0x28, 8375,
	0x29, 8381,
	0x2A, 8410,
	0x2B, 8416,
	0x2C, 8445,
	0x2D, 8451,
	0x2F, 8480,
	0x30, 8486,
	0x31, 8492,
	0x32, 8521,
	0x33, 8527,
	0x34, 8556,
	0x35, 8562,
	0x37, 8591,
	0x38, 8597,
	0x39, 8603,
	0x3A, 8632,
	0x3B, 8638,
	0x3C, 8667,
	0x3D, 8673,
	0x3F, 8702,
	0x40, 8708,
	0x41, 8708,
	0x42, 8708,
	0x43, 8708,
	0x44, 8708,
	0x45, 8708,
	0x46, 8708,
	0x47, 8708,
	0x48, 8723,
	0x49, 8723,
	0x4a, 8723,
	0x4b, 8723,
	0x4c, 8723,
	0x4d, 8723,
	0x4e, 8723,
	0x4f, 8723,
	0x50, 8738,
	0x51, 8738,
	0x52, 8738,
	0x53, 8738,
	0x54, 8738,
	0x55, 8738,
	0x56, 8738,
	0x57, 8738,
	0x58, 8765,
	0x59, 8765,
	0x5a, 8765,
	0x5b, 8765,
	0x5c, 8765,
	0x5d, 8765,
	0x5e, 8765,
	0x5f, 8765,
	0x60, 8792,
	0x61, 8805,
	0x62, 8818,
	0x63, 8837,
	0x68, 8868,
	0x69, 8887,
	0x6A, 8922,
	0x6B, 8927,
	0x6C, 8962,
	0x6D, 8965,
	0x6E, 8978,
	0x6F, 8981,
	0x70, 8994,
	0x71, 8999,
	0x72, 9004,
	0x73, 9009,
	0x74, 9014,
	0x75, 9019,
	0x76, 9024,
	0x77, 9029,
	0x78, 9034,
	0x79, 9039,
	0x7A, 9044,
	0x7B, 9049,
	0x7C, 9054,
	0x7D, 9059,
	0x7E, 9064,
	0x7F, 9069,
	0x80, 9074,
	0x81, 9131,
	0x83, 9372,
	0x84, 9613,
	0x85, 9619,
	0x86, 9648,
	0x87, 9654,
	0x88, 9683,
	0x89, 9689,
	0x8A, 9711,
	0x8B, 9717,
	0x8C, 9739,
	0x8D, 9768,
	0x8E, 9797,
	0x8F, 9826,
	0x90, 9862,
	0x91, 9862,
	0x92, 9862,
	0x93, 9862,
	0x94, 9862,
	0x95, 9862,
	0x96, 9862,
	0x97, 9862,
	0x98, 9888,
	0x99, 9908,
	0x9A, 9928,
	0x9B, 9945,
	0x9C, 9948,
	0x9D, 9971,
	0x9E, 9994,
	0x9F, 9997,
	0xA0, 10000,
	0xA1, 10019,
	0xA2, 10041,
	0xA3, 10060,
	0xA4, 10082,
	0xA5, 10085,
	0xA6, 10105,
	0xA7, 10108,
	0xA8, 10128,
	0xA9, 10134,
	0xAA, 10163,
	0xAB, 10166,
	0xAC, 10186,
	0xAD, 10189,
	0xAE, 10209,
	0xAF, 10212,
	0xb0, 10232,
	0xb1, 10232,
	0xb2, 10232,
	0xb3, 10232,
	0xb4, 10232,
	0xb5, 10232,
	0xb6, 10232,
	0xb7, 10232,
	0xb8, 10238,
	0xb9, 10238,
	0xba, 10238,
	0xbb, 10238,
	0xbc, 10238,
	0xbd, 10238,
	0xbe, 10238,
	0xbf, 10238,
	0xC0, 10267,
	0xC1, 10318,
	0xC2, 10516,
	0xC3, 10521,
	0xC4, 10524,
	0xC5, 10543,
	0xC6, 10562,
	0xC7, 10586,
	0xC8, 10647,
	0xC9, 10654,
	0xCA, 10677,
	0xCB, 10682,
	0xCC, 10685,
	0xCD, 10689,
	0xCE, 10694,
	0xCF, 10700,
	0xD0, 10720,
	0xD1, 10764,
	0xD2, 10955,
	0xD3, 10999,
	0xD4, 11190,
	0xD5, 11198,
	0xD7, 11206,
	0xD8, 11219,
	0xD9, 11428,
	0xDA, 11637,
	0xDB, 11769,
	0xDC, 11940,
	0xDD, 12109,
	0xDE, 12248,
	0xDF, 12422,
	0xE0, 12533,
	0xE1, 12538,
	0xE2, 12543,
	0xE3, 12548,
	0xE4, 12574,
	0xE5, 12580,
	0xE6, 12602,
	0xE7, 12608,
	0xE8, 12630,
	0xE9, 12661,
	0xEA, 12692,
	0xEB, 12709,
	0xEC, 12714,
	0xED, 12719,
	0xEE, 12738,
	0xEF, 12743,
	0xF1, 12762,
	0xF4, 12765,
	0xF5, 12768,
	0xF6, 12771,
	0xF7, 12810,
	0xF8, 12986,
	0xF9, 12989,
	0xFA, 12992,
	0xFB, 12995,
	0xFC, 12998,
	0xFD, 13001,
	0xFE, 13004,
	0xFF, 13021,
	uint16(xFail),
	/*490*/ uint16(xSetOp), uint16(ADD),
	/*492*/ uint16(xReadSlashR),
	/*493*/ uint16(xArgRM8),
	/*494*/ uint16(xArgR8),
	/*495*/ uint16(xMatch),
	/*496*/ uint16(xCondIs64), 499, 515,
	/*499*/ uint16(xCondDataSize), 503, 509, 0,
	/*503*/ uint16(xSetOp), uint16(ADD),
	/*505*/ uint16(xReadSlashR),
	/*506*/ uint16(xArgRM16),
	/*507*/ uint16(xArgR16),
	/*508*/ uint16(xMatch),
	/*509*/ uint16(xSetOp), uint16(ADD),
	/*511*/ uint16(xReadSlashR),
	/*512*/ uint16(xArgRM32),
	/*513*/ uint16(xArgR32),
	/*514*/ uint16(xMatch),
	/*515*/ uint16(xCondDataSize), 503, 509, 519,
	/*519*/ uint16(xSetOp), uint16(ADD),
	/*521*/ uint16(xReadSlashR),
	/*522*/ uint16(xArgRM64),
	/*523*/ uint16(xArgR64),
	/*524*/ uint16(xMatch),
	/*525*/ uint16(xSetOp), uint16(ADD),
	/*527*/ uint16(xReadSlashR),
	/*528*/ uint16(xArgR8),
	/*529*/ uint16(xArgRM8),
	/*530*/ uint16(xMatch),
	/*531*/ uint16(xCondIs64), 534, 550,
	/*534*/ uint16(xCondDataSize), 538, 544, 0,
	/*538*/ uint16(xSetOp), uint16(ADD),
	/*540*/ uint16(xReadSlashR),
	/*541*/ uint16(xArgR16),
	/*542*/ uint16(xArgRM16),
	/*543*/ uint16(xMatch),
	/*544*/ uint16(xSetOp), uint16(ADD),
	/*546*/ uint16(xReadSlashR),
	/*547*/ uint16(xArgR32),
	/*548*/ uint16(xArgRM32),
	/*549*/ uint16(xMatch),
	/*550*/ uint16(xCondDataSize), 538, 544, 554,
	/*554*/ uint16(xSetOp), uint16(ADD),
	/*556*/ uint16(xReadSlashR),
	/*557*/ uint16(xArgR64),
	/*558*/ uint16(xArgRM64),
	/*559*/ uint16(xMatch),
	/*560*/ uint16(xSetOp), uint16(ADD),
	/*562*/ uint16(xReadIb),
	/*563*/ uint16(xArgAL),
	/*564*/ uint16(xArgImm8u),
	/*565*/ uint16(xMatch),
	/*566*/ uint16(xCondIs64), 569, 585,
	/*569*/ uint16(xCondDataSize), 573, 579, 0,
	/*573*/ uint16(xSetOp), uint16(ADD),
	/*575*/ uint16(xReadIw),
	/*576*/ uint16(xArgAX),
	/*577*/ uint16(xArgImm16),
	/*578*/ uint16(xMatch),
	/*579*/ uint16(xSetOp), uint16(ADD),
	/*581*/ uint16(xReadId),
	/*582*/ uint16(xArgEAX),
	/*583*/ uint16(xArgImm32),
	/*584*/ uint16(xMatch),
	/*585*/ uint16(xCondDataSize), 573, 579, 589,
	/*589*/ uint16(xSetOp), uint16(ADD),
	/*591*/ uint16(xReadId),
	/*592*/ uint16(xArgRAX),
	/*593*/ uint16(xArgImm32),
	/*594*/ uint16(xMatch),
	/*595*/ uint16(xCondIs64), 598, 0,
	/*598*/ uint16(xSetOp), uint16(PUSH),
	/*600*/ uint16(xArgES),
	/*601*/ uint16(xMatch),
	/*602*/ uint16(xCondIs64), 605, 0,
	/*605*/ uint16(xSetOp), uint16(POP),
	/*607*/ uint16(xArgES),
	/*608*/ uint16(xMatch),
	/*609*/ uint16(xSetOp), uint16(OR),
	/*611*/ uint16(xReadSlashR),
	/*612*/ uint16(xArgRM8),
	/*613*/ uint16(xArgR8),
	/*614*/ uint16(xMatch),
	/*615*/ uint16(xCondIs64), 618, 634,
	/*618*/ uint16(xCondDataSize), 622, 628, 0,
	/*622*/ uint16(xSetOp), uint16(OR),
	/*624*/ uint16(xReadSlashR),
	/*625*/ uint16(xArgRM16),
	/*626*/ uint16(xArgR16),
	/*627*/ uint16(xMatch),
	/*628*/ uint16(xSetOp), uint16(OR),
	/*630*/ uint16(xReadSlashR),
	/*631*/ uint16(xArgRM32),
	/*632*/ uint16(xArgR32),
	/*633*/ uint16(xMatch),
	/*634*/ uint16(xCondDataSize), 622, 628, 638,
	/*638*/ uint16(xSetOp), uint16(OR),
	/*640*/ uint16(xReadSlashR),
	/*641*/ uint16(xArgRM64),
	/*642*/ uint16(xArgR64),
	/*643*/ uint16(xMatch),
	/*644*/ uint16(xSetOp), uint16(OR),
	/*646*/ uint16(xReadSlashR),
	/*647*/ uint16(xArgR8),
	/*648*/ uint16(xArgRM8),
	/*649*/ uint16(xMatch),
	/*650*/ uint16(xCondIs64), 653, 669,
	/*653*/ uint16(xCondDataSize), 657, 663, 0,
	/*657*/ uint16(xSetOp), uint16(OR),
	/*659*/ uint16(xReadSlashR),
	/*660*/ uint16(xArgR16),
	/*661*/ uint16(xArgRM16),
	/*662*/ uint16(xMatch),
	/*663*/ uint16(xSetOp), uint16(OR),
	/*665*/ uint16(xReadSlashR),
	/*666*/ uint16(xArgR32),
	/*667*/ uint16(xArgRM32),
	/*668*/ uint16(xMatch),
	/*669*/ uint16(xCondDataSize), 657, 663, 673,
	/*673*/ uint16(xSetOp), uint16(OR),
	/*675*/ uint16(xReadSlashR),
	/*676*/ uint16(xArgR64),
	/*677*/ uint16(xArgRM64),
	/*678*/ uint16(xMatch),
	/*679*/ uint16(xSetOp), uint16(OR),
	/*681*/ uint16(xReadIb),
	/*682*/ uint16(xArgAL),
	/*683*/ uint16(xArgImm8u),
	/*684*/ uint16(xMatch),
	/*685*/ uint16(xCondIs64), 688, 704,
	/*688*/ uint16(xCondDataSize), 692, 698, 0,
	/*692*/ uint16(xSetOp), uint16(OR),
	/*694*/ uint16(xReadIw),
	/*695*/ uint16(xArgAX),
	/*696*/ uint16(xArgImm16),
	/*697*/ uint16(xMatch),
	/*698*/ uint16(xSetOp), uint16(OR),
	/*700*/ uint16(xReadId),
	/*701*/ uint16(xArgEAX),
	/*702*/ uint16(xArgImm32),
	/*703*/ uint16(xMatch),
	/*704*/ uint16(xCondDataSize), 692, 698, 708,
	/*708*/ uint16(xSetOp), uint16(OR),
	/*710*/ uint16(xReadId),
	/*711*/ uint16(xArgRAX),
	/*712*/ uint16(xArgImm32),
	/*713*/ uint16(xMatch),
	/*714*/ uint16(xCondIs64), 717, 0,
	/*717*/ uint16(xSetOp), uint16(PUSH),
	/*719*/ uint16(xArgCS),
	/*720*/ uint16(xMatch),
	/*721*/ uint16(xCondByte), 228,
	0x00, 1180,
	0x01, 1237,
	0x02, 1345,
	0x03, 1367,
	0x05, 1389,
	0x06, 1395,
	0x07, 1398,
	0x08, 1404,
	0x09, 1407,
	0x0B, 1410,
	0x0D, 1413,
	0x10, 1426,
	0x11, 1460,
	0x12, 1494,
	0x13, 1537,
	0x14, 1555,
	0x15, 1573,
	0x16, 1591,
	0x17, 1626,
	0x18, 1644,
	0x1F, 1669,
	0x20, 1690,
	0x21, 1705,
	0x22, 1720,
	0x23, 1735,
	0x24, 1750,
	0x26, 1765,
	0x28, 1780,
	0x29, 1798,
	0x2A, 1816,
	0x2B, 1903,
	0x2C, 1937,
	0x2D, 2024,
	0x2E, 2111,
	0x2F, 2129,
	0x30, 2147,
	0x31, 2150,
	0x32, 2153,
	0x33, 2156,
	0x34, 2159,
	0x35, 2162,
	0x38, 2172,
	0x3A, 3073,
	0x40, 3484,
	0x41, 3513,
	0x42, 3542,
	0x43, 3571,
	0x44, 3600,
	0x45, 3629,
	0x46, 3658,
	0x47, 3687,
	0x48, 3716,
	0x49, 3745,
	0x4A, 3774,
	0x4B, 3803,
	0x4C, 3832,
	0x4D, 3861,
	0x4E, 3890,
	0x4F, 3919,
	0x50, 3948,
	0x51, 3966,
	0x52, 4000,
	0x53, 4018,
	0x54, 4036,
	0x55, 4054,
	0x56, 4072,
	0x57, 4090,
	0x58, 4108,
	0x59, 4142,
	0x5A, 4176,
	0x5B, 4210,
	0x5C, 4236,
	0x5D, 4270,
	0x5E, 4304,
	0x5F, 4338,
	0x60, 4372,
	0x61, 4390,
	0x62, 4408,
	0x63, 4426,
	0x64, 4444,
	0x65, 4462,
	0x66, 4480,
	0x67, 4498,
	0x68, 4516,
	0x69, 4534,
	0x6A, 4552,
	0x6B, 4570,
	0x6C, 4588,
	0x6D, 4598,
	0x6E, 4608,
	0x6F, 4675,
	0x70, 4701,
	0x71, 4743,
	0x72, 4806,
	0x73, 4869,
	0x74, 4934,
	0x75, 4952,
	0x76, 4970,
	0x77, 4988,
	0x7C, 4991,
	0x7D, 5009,
	0x7E, 5027,
	0x7F, 5104,
	0x80, 5130,
	0x81, 5161,
	0x82, 5192,
	0x83, 5223,
	0x84, 5254,
	0x85, 5285,
	0x86, 5316,
	0x87, 5347,
	0x88, 5378,
	0x89, 5409,
	0x8A, 5440,
	0x8B, 5471,
	0x8C, 5502,
	0x8D, 5533,
	0x8E, 5564,
	0x8F, 5595,
	0x90, 5626,
	0x91, 5631,
	0x92, 5636,
	0x93, 5641,
	0x94, 5646,
	0x95, 5651,
	0x96, 5656,
	0x97, 5661,
	0x98, 5666,
	0x99, 5671,
	0x9A, 5676,
	0x9B, 5681,
	0x9C, 5686,
	0x9D, 5691,
	0x9E, 5696,
	0x9F, 5701,
	0xA0, 5706,
	0xA1, 5710,
	0xA2, 5737,
	0xA3, 5740,
	0xA4, 5769,
	0xA5, 5804,
	0xA8, 5836,
	0xA9, 5840,
	0xAA, 5867,
	0xAB, 5870,
	0xAC, 5899,
	0xAD, 5934,
	0xAE, 5966,
	0xAF, 6224,
	0xB0, 6253,
	0xB1, 6259,
	0xB2, 6288,
	0xB3, 6317,
	0xB4, 6346,
	0xB5, 6375,
	0xB6, 6404,
	0xB7, 6433,
	0xB8, 6462,
	0xB9, 6499,
	0xBA, 6502,
	0xBB, 6627,
	0xBC, 6656,
	0xBD, 6723,
	0xBE, 6790,
	0xBF, 6819,
	0xC0, 6848,
	0xC1, 6854,
	0xC2, 6883,
	0xC3, 6