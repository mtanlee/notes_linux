od.
// Use the Kind method to find out the kind of value before
// calling kind-specific methods.  Calling a method
// inappropriate to the kind of type causes a run time panic.
//
// The zero Value represents no value.
// Its IsValid method returns false, its Kind method returns Invalid,
// its String method returns "<invalid Value>", and all other methods panic.
// Most functions and methods never return an invalid value.
// If one does, its documentation states the conditions explicitly.
//
// A Value can be used concurrently by multiple goroutines provided that
// the underlying Go value can be used concurrently for the equivalent
// direct operations.
type Value struct {
	// typ holds the type of the value represented by a Value.
	typ *rtype

	// Pointer-valued data or, if flagIndir is set, pointer to data.
	// Valid when either flagIndir is set or typ.pointers() is true.
	ptr unsafe.Pointer

	// flag holds metadata about the value.
	// The lowest bits are flag bits:
	//	- flagRO: obtained via unexported field, so read-only
	//	- flagIndir: val holds a pointer to the data
	//	- flagAddr: v.CanAddr is true (implies flagIndir)
	//	- flagMethod: v is a method value.
	// The next five bits give the Kind of the value.
	// This repeats typ.Kind() except for method values.
	// The remaining 23+ bits give a method number for method values.
	// If flag.kind() != Func, code can assume that flagMethod is unset.
	// If ifaceIndir(typ), code can assume that flagIndir is set.
	flag

	// A method value represents a curried method invocation
	// like r.Read for some receiver r.  The typ+val+flag bits describe
	// the receiver r, but the flag's Kind bits say Func (methods are
	// functions), and the top bits of the flag give the method number
	// in r's type's method table.
}

type flag uintptr

const (
	flagKindWidth        = 5 // there are 27 kinds
	flagKindMask    flag = 1<<flagKindWidth - 1
	flagRO          flag = 1 << 5
	flagIndir       flag = 1 << 6
	flagAddr        flag = 1 << 7
	flagMethod      flag = 1 << 8
	flagMethodShift      = 9
)

func (f flag) kind() Kind {
	return Kind(f & flagKindMask)
}

// pointer returns the underlying pointer represented by v.
// v.Kind() must be Ptr, Map, Chan, Func, or UnsafePointer
func (v Value) pointer() unsafe.Pointer {
	if v.typ.size != ptrSize || !v.typ.pointers() {
		panic("can't call pointer on a non-pointer Value")
	}
	if v.flag&flagIndir != 0 {
		return *(*unsafe.Pointer)(v.ptr)
	}
	return v.ptr
}

// packEface converts v to the empty interface.
func packEface(v Value) interface{} {
	t := v.typ
	var i interface{}
	e := (*emptyInterface)(unsafe.Pointer(&i))
	// First, fill in the data portion of the interface.
	switch {
	case ifaceIndir(t):
		if v.flag&flagIndir == 0 {
			panic("bad indir")
		}
		// Value is indirect, and so is the interface we're making.
		ptr := v.ptr
		if v.flag&flagAddr != 0 {
			// TODO: pass safe boolean from valueInterface so
			// we don't need to copy if safe==true?
			c := unsafe_New(t)
			memmove(c, ptr, t.size)
			ptr = c
		}
		e.word = ptr
	case v.flag&flagIndir != 0:
		// Value is indirect, but interface is direct.  We need
		// to load the data at v.ptr into the interface data word.
		e.word = *(*unsafe.Pointer)(v.ptr)
	default:
		// Value is direct, and so is the interface.
		e.word = v.ptr
	}
	// Now, fill in the type portion.  We're very careful here not
	// to have any operation between the e.word and e.typ assignments
	// that would let the garbage collector observe the partially-built
	// interface value.
	e.typ = t
	return i
}

// unpackEface converts the empty interface i to a Value.
func unpackEface(i interface{}) Value {
	e := (*emptyInterface)(unsafe.Pointer(&i))
	// NOTE: don't read e.word until we know whether it is really a pointer or not.
	t := e.typ
	if t == nil {
		return Value{}
	}
	f := flag(t.Kind())
	if ifaceIndir(t) {
		f |= flagIndir
	}
	return Value{t, unsafe.Pointer(e.word), f}
}

// A ValueError occurs when a Value method is invoked on
// a Value that does not support it.  Such cases are documented
// in the description of each method.
type ValueError struct {
	Method string
	Kind   Kind
}

func (e *ValueError) Error() string {
	if e.Kind == 0 {
		return "reflect: call of " + e.Method + " on zero Value"
	}
	return "reflect: call of " + e.Method + " on " + e.Kind.String() + " Value"
}

// methodName returns the name of the calling method,
// assumed to be two stack frames above.
func methodName() string {
	pc, _, _, _ := runtime.Caller(2)
	f := runtime.FuncForPC(pc)
	if f == nil {
		return "unknown method"
	}
	return f.Name()
}

// emptyInterface is the header for an interface{} value.
type emptyInterface struct {
	typ  *rtype
	word unsafe.Pointer
}

// nonEmptyInterface is the header for a interface value with methods.
type nonEmptyInterface struct {
	// see ../runtime/iface.c:/Itab
	itab *struct {
		ityp   *rtype // static interface type
		typ    *rtype // dynamic concrete type
		link   unsafe.Pointer
		bad    int32
		unused int32
		fun    [100000]unsafe.Pointer // method table
	}
	word unsafe.Pointer
}

// mustBe panics if f's kind is not expected.
// Making this a method on flag instead of on Value
// (and embedding flag in Value) means that we can write
// the very clear v.mustBe(Bool) and have it compile into
// v.flag.mustBe(Bool), which will only bother to copy the
// single important word for the receiver.
func (f flag) mustBe(expected Kind) {
	if f.kind() != expected {
		panic(&ValueError{methodName(), f.kind()})
	}
}

// mustBeExported panics if f records that the value was obtained using
// an unexported field.
func (f flag) mustBeExported() {
	if f == 0 {
		panic(&ValueError{methodName(), 0})
	}
	if f&flagRO != 0 {
		panic("reflect: " + methodName() + " using value obtained using unexported field")
	}
}

// mustBeAssignable panics if f records that the value is not assignable,
// which is to say that either it was obtained using an unexported field
// or it is not addressable.
func (f flag) mustBeAssignable() {
	if f == 0 {
		panic(&ValueError{methodName(), Invalid})
	}
	// Assignable if addressable and not read-only.
	if f&flagRO != 0 {
		panic("reflect: " + methodName() + " using value obtained using unexported field")
	}
	if f&flagAddr == 0 {
		panic("reflect: " + methodName() + " using unaddressable value")
	}
}

// Addr returns a pointer value representing the address of v.
// It panics if CanAddr() returns false.
// Addr is typically used to obtain a pointer to a struct field
// or slice element in order to call a method that requires a
// pointer receiver.
func (v Value) Addr() Value {
	if v.flag&flagAddr == 0 {
		panic("reflect.Value.Addr of unaddressable value")
	}
	return Value{v.typ.ptrTo(), v.ptr, (v.flag & flagRO) | flag(Ptr)}
}

// Bool returns v's underlying value.
// It panics if v's kind is not Bool.
func (v Value) Bool() bool {
	v.mustBe(Bool)
	return *(*bool)(v.ptr)
}

// Bytes returns v's underlying value.
// It panics if v's underlying value is not a slice of bytes.
func (v Value) Bytes() []byte {
	v.mustBe(Slice)
	if v.typ.Elem().Kind() != Uint8 {
		panic("reflect.Value.Bytes of non-byte slice")
	}
	// Slice is always bigger than a word; assume flagIndir.
	return *(*[]byte)(v.ptr)
}

// runes returns v's underlying value.
// It panics if v's underlying value is not a slice of runes (int32s).
func (v Value) runes() []rune {
	v.mustBe(Slice)
	if v.typ.Elem().Kind() != Int32 {
		panic("reflect.Value.Bytes of non-rune slice")
	}
	// Slice is always bigger than a word; assume flagIndir.
	return *(*[]rune)(v.ptr)
}

// CanAddr returns true if the value's address can be obtained with Addr.
// Such values are called addressable.  A value is addressable if it is
// an element of a slice, an element of an addressable array,
// a field of an addressable struct, or the result of dereferencing a pointer.
// If CanAddr returns false, calling Addr will panic.
func (v Value) CanAddr() bool {
	return v.flag&flagAddr != 0
}

// CanSet returns true if the value of v can be changed.
// A Value can be changed only if it is addressable and was not
// obtained by the use of unexported struct fields.
// If CanSet returns false, calling Set or any type-specific
// setter (e.g., SetBool, SetInt64) will panic.
func (v Value) CanSet() bool {
	return v.flag&(flagAddr|flagRO) == flagAddr
}

// Call calls the function v with the input arguments in.
// For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]).
// Call panics if v's Kind is not Func.
// It returns the output results as Values.
// As in Go, each input argument must be assignable to the
// type of the function's corresponding input parameter.
// If v is a variadic function, Call creates the variadic slice parameter
// itself, copying in the corresponding values.
func (v Value) Call(in []Value) []Value {
	v.mustBe(Func)
	v.mustBeExported()
	return v.call("Call", in)
}

// CallSlice calls the variadic function v with the input arguments in,
// assigning the slice in[len(in)-1] to v's final variadic argument.
// For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]...).
// Call panics if v's Kind is not Func or if v is not variadic.
// It returns the output results as Values.
// As in Go, each input argument must be assignable to the
// type of the function's corresponding input parameter.
func (v Value) CallSlice(in []Value) []Value {
	v.mustBe(Func)
	v.mustBeExported()
	return v.call("CallSlice", in)
}

var callGC bool // for testing; see TestCallMethodJump

func (v Value) call(op string, in []Value) []Value {
	// Get function pointer, type.
	t := v.typ
	var (
		fn       unsafe.Pointer
		rcvr     Value
		rcvrtype *rtype
	)
	if v.flag&flagMethod != 0 {
		rcvr = v
		rcvrtype, t, fn = methodReceiver(op, v, int(v.flag)>>flagMethodShift)
	} else if v.flag&flagIndir != 0 {
		fn = *(*unsafe.Pointer)(v.ptr)
	} else {
		fn = v.ptr
	}

	if fn == nil {
		panic("reflect.Value.Call: call of nil function")
	}

	isSlice := op == "CallSlice"
	n := t.NumIn()
	if isSlice {
		if !t.IsVariadic() {
			panic("reflect: CallSlice of non-variadic function")
		}
		if len(in) < n {
			panic("reflect: CallSlice with too few input arguments")
		}
		if len(in) > n {
			panic("reflect: CallSlice with too many input arguments")
		}
	} else {
		if t.IsVariadic() {
			n--
		}
		if len(in) < n {
			panic("reflect: Call with too few input arguments")
		}
		if !t.IsVariadic() && len(in) > n {
			panic("reflect: Call with too many input arguments")
		}
	}
	for _, x := range in {
		if x.Kind() == Invalid {
			panic("reflect: " + op + " using zero Value argument")
		}
	}
	for i := 0; i < n; i++ {
		if xt, targ := in[i].Type(), t.In(i); !xt.AssignableTo(targ) {
			panic("reflect: " + op + " using " + xt.String() + " as type " + targ.String())
		}
	}
	if !isSlice && t.IsVariadic() {
		// prepare slice for remaining values
		m := len(in) - n
		slice := MakeSlice(t.In(n), m, m)
		elem := t.In(n).Elem()
		for i := 0; i < m; i++ {
			x := in[n+i]
			if xt := x.Type(); !xt.AssignableTo(elem) {
				panic("reflect: cannot use " + xt.String() + " as type " + elem.String() + " in " + op)
			}
			slice.Index(i).Set(x)
		}
		origIn := in
		in = make([]Value, n+1)
		copy(in[:n], origIn)
		in[n] = slice
	}

	nin := len(in)
	if nin != t.NumIn() {
		panic("reflect.Value.Call: wrong argument count")
	}
	nout := t.NumOut()

	// Compute frame type, allocate a chunk of memory for frame
	frametype, _, retOffset, _ := funcLayout(t, rcvrtype)
	args := unsafe_New(frametype)
	off := uintptr(0)

	// Copy inputs into args.
	if rcvrtype != nil {
		storeRcvr(rcvr, args)
		off = ptrSize
	}
	for i, v := range in {
		v.mustBeExported()
		targ := t.In(i).(*rtype)
		a := uintptr(targ.align)
		off = (off + a - 1) &^ (a - 1)
		n := targ.size
		addr := unsafe.Pointer(uintptr(args) + off)
		v = v.assignTo("reflect.Value.Call", targ, addr)
		if v.flag&flagIndir != 0 {
			memmove(addr, v.ptr, n)
		} else {
			*(*unsafe.Pointer)(addr) = v.ptr
		}
		off += n
	}

	// Call.
	call(fn, args, uint32(frametype.size), uint32(retOffset))

	// For testing; see TestCallMethodJump.
	if callGC {
		runtime.GC()
	}

	// Copy return values out of args.
	ret := make([]Value, nout)
	off = retOffset
	for i := 0; i < nout; i++ {
		tv := t.Out(i)
		a := uintptr(tv.Align())
		off = (off + a - 1) &^ (a - 1)
		fl := flagIndir | flag(tv.Kind())
		ret[i] = Value{tv.common(), unsafe.Pointer(uintptr(args) + off), fl}
		off += tv.Size()
	}

	return ret
}

// callReflect is the call implementation used by a function
// returned by MakeFunc. In many ways it is the opposite of the
// method Value.call above. The method above converts a call using Values
// into a call of a function with a concrete argument frame, while
// callReflect converts a call of a function with a concrete argument
// frame into a call using Values.
// It is in this file so that it can be next to the call method above.
// The remainder of the MakeFunc implementation is in makefunc.go.
//
// NOTE: This function must be marked as a "wrapper" in the generated code,
// so that the linker can make it work correctly for panic and recover.
// The gc compilers know to do that for the name "reflect.callReflect".
func callReflect(ctxt *makeFuncImpl, frame unsafe.Pointer) {
	ftyp := ctxt.typ
	f := ctxt.fn

	// Copy argument frame into Values.
	ptr := frame
	off := uintptr(0)
	in := make([]Value, 0, len(ftyp.in))
	for _, arg := range ftyp.in {
		typ := arg
		off += -off & uintptr(typ.align-1)
		addr := unsafe.Pointer(uintptr(ptr) + off)
		v := Value{typ, nil, flag(typ.Kind())}
		if ifaceIndir(typ) {
			// value cannot be inlined in interface data.
			// Must make a copy, because f might keep a reference to it,
			// and we cannot let f keep a reference to the stack frame
			// after this function returns, not even a read-only reference.
			v.ptr = unsafe_New(typ)
			memmove(v.ptr, addr, typ.size)
			v.flag |= flagIndir
		} else {
			v.ptr = *(*unsafe.Pointer)(addr)
		}
		in = append(in, v)
		off += typ.size
	}

	// Call underlying function.
	out := f(in)
	if len(out) != len(ftyp.out) {
		panic("reflect: wrong return count from function created by MakeFunc")
	}

	// Copy results back into argument frame.
	if len(ftyp.out) > 0 {
		off += -off & (ptrSize - 1)
		if runtime.GOARCH == "amd64p32" {
			off = align(off, 8)
		}
		for i, arg := range ftyp.out {
			typ := arg
			v := out[i]
			if v.typ != typ {
				panic("reflect: function created by MakeFunc using " + funcName(f) +
					" returned wrong type: have " +
					out[i].typ.String() + " for " + typ.String())
			}
			if v.flag&flagRO != 0 {
				panic("reflect: function created by MakeFunc using " + funcName(f) +
					" returned value obtained from unexported field")
			}
			off += -off & uintptr(typ.align-1)
			addr := unsafe.Pointer(uintptr(ptr) + off)
			if v.flag&flagIndir != 0 {
				memmove(addr, v.ptr, typ.size)
			} else {
				*(*unsafe.Pointer)(addr) = v.ptr
			}
			off += typ.size
		}
	}
}

// methodReceiver returns information about the receiver
// described by v. The Value v may or may not have the
// flagMethod bit set, so the kind cached in v.flag should
// not be used.
// The return value rcvrtype gives the method's actual receiver type.
// The return value t gives the method type signature (without the receiver).
// The return value fn is a pointer to the method code.
func methodReceiver(op string, v Value, methodIndex int) (rcvrtype, t *rtype, fn unsafe.Pointer) {
	i := methodIndex
	if v.typ.Kind() == Interface {
		tt := (*interfaceType)(unsafe.Pointer(v.typ))
		if uint(i) >= uint(len(tt.methods)) {
			panic("reflect: internal error: invalid method index")
		}
		m := &tt.methods[i]
		if m.pkgPath != nil {
			panic("reflect: " + op + " of unexported method")
		}
		iface := (*nonEmptyInterface)(v.ptr)
		if iface.itab == nil {
			panic("reflect: " + op + " of method on nil interface value")
		}
		rcvrtype = iface.itab.typ
		fn = unsafe.Pointer(&iface.itab.fun[i])
		t = m.typ
	} else {
		rcvrtype = v.typ
		ut := v.typ.uncommon()
		if ut == nil || uint(i) >= uint(len(ut.methods)) {
			panic("reflect: internal error: invalid method index")
		}
		m := &ut.methods[i]
		if m.pkgPath != nil {
			panic("reflect: " + op + " of unexported method")
		}
		fn = unsafe.Pointer(&m.ifn)
		t = m.mtyp
	}
	return
}

// v is a method receiver.  Store at p the word which is used to
// encode that receiver at the start of the argument list.
// Reflect uses the "interface" calling convention for
// methods, which always uses one word to record the receiver.
func storeRcvr(v Value, p unsafe.Pointer) {
	t := v.typ
	if t.Kind() == Interface {
		// the interface data word becomes the receiver word
		iface := (*nonEmptyInterface)(v.ptr)
		*(*unsafe.Pointer)(p) = unsafe.Pointer(iface.word)
	} else if v.flag&flagIndir != 0 && !ifaceIndir(t) {
		*(*unsafe.Pointer)(p) = *(*unsafe.Pointer)(v.ptr)
	} else {
		*(*unsafe.Pointer)(p) = v.ptr
	}
}

// align returns the result of rounding x up to a multiple of n.
// n must be a power of two.
func align(x, n uintptr) uintptr {
	return (x + n - 1) &^ (n - 1)
}

// callMethod is the call implementation used by a function returned
// by makeMethodValue (used by v.Method(i).Interface()).
// It is a streamlined version of the usual reflect call: the caller has
// already laid out the argument frame for us, so we don't have
// to deal with individual Values for each argument.
// It is in this file so that it can be next to the two similar functions above.
// The remainder of the makeMethodValue implementation is in makefunc.go.
//
// NOTE: This function must be marked as a "wrapper" in the generated code,
// so that the linker can make it work correctly for panic and recover.
// The gc compilers know to do that for the name "reflect.callMethod".
func callMethod(ctxt *methodValue, frame unsafe.Pointer) {
	rcvr := ctxt.rcvr
	rcvrtype, t, fn := methodReceiver("call", rcvr, ctxt.method)
	frametype, argSize, retOffset, _ := funcLayout(t, rcvrtype)

	// Make a new frame that is one word bigger so we can store the receiver.
	args := unsafe_New(frametype)

	// Copy in receiver and rest of args.
	storeRcvr(rcvr, args)
	memmove(unsafe.Pointer(uintptr(args)+ptrSize), frame, argSize-ptrSize)

	// Call.
	call(fn, args, uint32(frametype.size), uint32(retOffset))

	// Copy return values. On amd64p32, the beginning of return values
	// is 64-bit aligned, so the caller's frame layout (which doesn't have
	// a receiver) is different from the layout of the fn call, which has
	// a receiver.
	// Ignore any changes to args and just copy return values.
	callerRetOffset := retOffset - ptrSize
	if runtime.GOARCH == "amd64p32" {
		callerRetOffset = align(argSize-ptrSize, 8)
	}
	memmove(unsafe.Pointer(uintptr(frame)+callerRetOffset),
		unsafe.Pointer(uintptr(args)+retOffset), frametype.size-retOffset)
}

// funcName returns the name of f, for use in error messages.
func funcName(f func([]Value) []Value) string {
	pc := *(*uintptr)(unsafe.Pointer(&f))
	rf := runtime.FuncForPC(pc)
	if rf != nil {
		return rf.Name()
	}
	return "closure"
}

// Cap returns v's capacity.
// It panics if v's Kind is not Array, Chan, or Slice.
func (v Value) Cap() int {
	k := v.kind()
	switch k {
	case Array:
		return v.typ.Len()
	case Chan:
		return int(chancap(v.pointer()))
	case Slice:
		// Slice is always bigger than a word; assume flagIndir.
		return (*sliceHeader)(v.ptr).Cap
	}
	panic(&ValueError{"reflect.Value.Cap", v.kind()})
}

// Close closes the channel v.
// It panics if v's Kind is not Chan.
func (v Value) Close() {
	v.mustBe(Chan)
	v.mustBeExported()
	chanclose(v.pointer())
}

// Complex returns v's underlying value, as a complex128.
// It panics if v's Kind is not Complex64 or Complex128
func (v Value) Complex() complex128 {
	k := v.kind()
	switch k {
	case Complex64:
		return complex128(*(*complex64)(v.ptr))
	case Complex128:
		return *(*complex128)(v.ptr)
	}
	panic(&ValueError{"reflect.Value.Complex", v.kind()})
}

// Elem returns the value that the interface v contains
// or that the pointer v points to.
// It panics if v's Kind is not Interface or Ptr.
// It returns the zero Value if v is nil.
func (v Value) Elem() Value {
	k := v.kind()
	switch k {
	case Interface:
		var eface interface{}
		if v.typ.NumMethod() == 0 {
			eface = *(*interface{})(v.ptr)
		} else {
			eface = (interface{})(*(*interface {
				M()
			})(v.ptr))
		}
		x := unpackEface(eface)
		if x.flag != 0 {
			x.flag |= v.flag & flagRO
		}
		return x
	case Ptr:
		ptr := v.ptr
		if v.flag&flagIndir != 0 {
			ptr = *(*unsafe.Pointer)(ptr)
		}
		// The returned value's address is v's value.
		if ptr == nil {
			return Value{}
		}
		tt := (*ptrType)(unsafe.Pointer(v.typ))
		typ := tt.elem
		fl := v.flag&flagRO | flagIndir | flagAddr
		fl |= flag(typ.Kind())
		return Value{typ, ptr, fl}
	}
	panic(&ValueError{"reflect.Value.Elem", v.kind()})
}

// Field returns the i'th field of the struct v.
// It panics if v's Kind is not Struct or i is out of range.
func (v Value) Field(i int) Value {
	if v.kind() != Struct {
		panic(&ValueError{"reflect.Value.Field", v.kind()})
	}
	tt := (*structType)(unsafe.Pointer(v.typ))
	if uint(i) >= uint(len(tt.fields)) {
		panic("reflect: Field index out of range")
	}
	field := &tt.fields[i]
	typ := field.typ

	// Inherit permission bits from v.
	fl := v.flag&(flagRO|flagIndir|flagAddr) | flag(typ.Kind())
	// Using an unexported field forces flagRO.
	if field.pkgPath != nil {
		fl |= flagRO
	}
	// Either flagIndir is set and v.ptr points at struct,
	// or flagIndir is not set and v.ptr is the actual struct data.
	// In the former case, we want v.ptr + offset.
	// In the latter case, we must be have field.offset = 0,
	// so v.ptr + field.offset is still okay.
	ptr := unsafe.Pointer(uintptr(v.ptr) + field.offset)
	return Value{typ, ptr, fl}
}

// FieldByIndex returns the nested field corresponding to index.
// It panics if v's Kind is not struct.
func (v Value) FieldByIndex(index []int) Value {
	if len(index) == 1 {
		return v.Field(index[0])
	}
	v.mustBe(Struct)
	for i, x := range index {
		if i > 0 {
			if v.Kind() == Ptr && v.typ.Elem().Kind() == Struct {
				if v.IsNil() {
					panic("reflect: indirection through nil pointer to embedded struct")
				}
				v = v.Elem()
			}
		}
		v = v.Field(x)
	}
	return v
}

// FieldByName returns the struct field with the given name.
// It returns the zero Value if no field was found.
// It panics if v's Kind is not struct.
func (v Value) FieldByName(name string) Value {
	v.mustBe(Struct)
	if f, ok := v.typ.FieldByName(name); ok {
		return v.FieldByIndex(f.Index)
	}
	return Value{}
}

// FieldByNameFunc returns the struct field with a name
// that satisfies the match function.
// It panics if v's Kind is not struct.
// It returns the zero Value if no field was found.
func (v Value) FieldByNameFunc(match func(string) bool) Value {
	if f, ok := v.typ.FieldByNameFunc(match); ok {
		return v.FieldByIndex(f.Index)
	}
	return Value{}
}

// Float returns v's underlying value, as a float64.
// It panics if v's Kind is not Float32 or Float64
func (v Value) Float() float64 {
	k := v.kind()
	switch k {
	case Float32:
		return float64(*(*float32)(v.ptr))
	case Float64:
		return *(*float64)(v.ptr)
	}
	panic(&ValueError{"reflect.Value.Float", v.kind()})
}

var uint8Type = TypeOf(uint8(0)).(*rtype)

// Index returns v's i'th element.
// It panics if v's Kind is not Array, Slice, or String or i is out of range.
func (v Value) Index(i int) Value {
	switch v.kind() {
	case Array:
		tt := (*arrayType)(unsafe.Pointer(v.typ))
		if uint(i) >= uint(tt.len) {
			panic("reflect: array index out of range")
		}
		typ := tt.elem
		offset := uintptr(i) * typ.size

		// Either flagIndir is set and v.ptr points at array,
		// or flagIndir is not set and v.ptr is the actual array data.
		// In the former case, we want v.ptr + offset.
		// In the latter case, we must be doing Index(0), so offset = 0,
		// so v.ptr + offset is still okay.
		val := unsafe.Pointer(uintptr(v.ptr) + offset)
		fl := v.flag&(flagRO|flagIndir|flagAddr) | flag(typ.Kind()) // bits same as overall array
		return Value{typ, val, fl}

	case Slice:
		// Element flag same as Elem of Ptr.
		// Addressable, indirect, possibly read-only.
		s := (*sliceHeader)(v.ptr)
		if uint(i) >= uint(s.Len) {
			panic("reflect: slice index out of range")
		}
		tt := (*sliceType)(unsafe.Pointer(v.typ))
		typ := tt.elem
		val := unsafe.Pointer(uintptr(s.Data) + uintptr(i)*typ.size)
		fl := flagAddr | flagIndir | v.flag&flagRO | flag(typ.Kind())
		return Value{typ, val, fl}

	case String:
		s := (*stringHeader)(v.ptr)
		if uint(i) >= uint(s.Len) {
			panic("reflect: string index out of range")
		}
		p := unsafe.Pointer(uintptr(s.Data) + uintptr(i))
		fl := v.flag&flagRO | flag(Uint8) | flagIndir
		return Value{uint8Type, p, fl}
	}
	panic(&ValueError{"reflect.Value.Index", v.kind()})
}

// Int returns v's underlying value, as an int64.
// It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.
func (v Value) Int() int64 {
	k := v.kind()
	p := v.ptr
	switch k {
	case Int:
		return int64(*(*int)(p))
	case Int8:
		return int64(*(*int8)(p))
	case Int16:
		return int64(*(*int16)(p))
	case Int32:
		return int64(*(*int32)(p))
	case Int64:
		return int64(*(*int64)(p))
	}
	panic(&ValueError{"reflect.Value.Int", v.kind()})
}

// CanInterface returns true if Interface can be used without panicking.
func (v Value) CanInterface() bool {
	if v.flag == 0 {
		panic(&ValueError{"reflect.Value.CanInterface", Invalid})
	}
	return v.flag&flagRO == 0
}

// Interface returns v's current value as an interface{}.
// It is equivalent to:
//	var i interface{} = (v's underlying value)
// It panics if the Value was obtained by accessing
// unexported struct fields.
func (v Value) Interface() (i interface{}) {
	return valueInterface(v, true)
}

func valueInterface(v Value, safe bool) interface{} {
	if v.flag == 0 {
		panic(&ValueError{"reflect.Value.Interface", 0})
	}
	if safe && v.flag&flagRO != 0 {
		// Do not allow access to unexported values via Interface,
		// because they might be pointers that should not be
		// writable or methods or function that should not be callable.
		panic("reflect.Value.Interface: cannot return value obtained from unexported field or method")
	}
	if v.flag&flagMethod != 0 {
		v = makeMethodValue("Interface", v)
	}

	if v.kind() == Interface {
		// Special case: return the element inside the interface.
		// Empty interface has one layout, all interfaces with
		// methods have a second layout.
		if v.NumMethod() == 0 {
			return *(*interface{})(v.ptr)
		}
		return *(*interface {
			M()
		})(v.ptr)
	}

	// TODO: pass safe to packEface so we don't need to copy if safe==true?
	return packEface(v)
}

// InterfaceData returns the interface v's value as a uintptr pair.
// It panics if v's Kind is not Interface.
func (v Value) InterfaceData() [2]uintptr {
	// TODO: deprecate this
	v.mustBe(Interface)
	// We treat this as a read operation, so we allow
	// it even for unexported data, because the caller
	// has to import "unsafe" to turn it into something
	// that can be abused.
	// Interface value is always bigger than a word; assume flagIndir.
	return *(*[2]uintptr)(v.ptr)
}

// IsNil reports whether its argument v is nil. The argument must be
// a chan, func, interface, map, pointer, or slice value; if it is
// not, IsNil panics. Note that IsNil is not always equivalent to a
// regular comparison with nil in Go. For example, if v was created
// by calling ValueOf with an uninitialized interface variable i,
// i==nil will be true but v.IsNil will panic as v will be the zero
// Value.
func (v Value) IsNil() bool {
	k := v.kind()
	switch k {
	case Chan, Func, Map, Ptr:
		if v.flag&flagMethod != 0 {
			return false
		}
		ptr := v.ptr
		if v.flag&flagIndir != 0 {
			ptr = *(*unsafe.Pointer)(ptr)
		}
		return ptr == nil
	case Interface, Slice:
		// Both interface and slice are nil if first word is 0.
		// Both are always bigger than a word; assume flagIndir.
		return *(*unsafe.Pointer)(v.ptr) == nil
	}
	panic(&ValueError{"reflect.Value.IsNil", v.kind()})
}

// IsValid returns true if v represents a value.
// It returns false if v is the zero Value.
// If IsValid returns false, all other methods except String panic.
// Most functions and methods never return an invalid value.
// If one does, its documentation states the conditions explicitly.
func (v Value) IsValid() bool {
	return v.flag != 0
}

// Kind returns v's Kind.
// If v is the zero Value (IsValid returns false), Kind returns Invalid.
func (v Value) Kind() Kind {
	return v.kind()
}

// Len returns v's length.
// It panics if v's Kind is not Array, Chan, Map, Slice, or String.
func (v Value) Len() int {
	k := v.kind()
	switch k {
	case Array:
		tt := (*arrayType)(unsafe.Pointer(v.typ))
		return int(tt.len)
	case Chan:
		return chanlen(v.pointer())
	case Map:
		return maplen(v.pointer())
	case Slice:
		// Slice is bigger than a word; assume flagIndir.
		return (*sliceHeader)(v.ptr).Len
	case String:
		// String is bigger than a word; assume flagIndir.
		return (*stringHeader)(v.ptr).Len
	}
	panic(&ValueError{"reflect.Value.Len", v.kind()})
}

// MapIndex returns the value associated with key in the map v.
// It panics if v's Kind is not Map.
// It returns the zero Value if key is not found in the map or if v represents a nil map.
// As in Go, the key's value must be assignable to the map's key type.
func (v Value) MapIndex(key Value) Value {
	v.mustBe(Map)
	tt := (*mapType)(unsafe.Pointer(v.typ))

	// Do not require key to be exported, so that DeepEqual
	// and other programs can use all the keys returned by
	// MapKeys as arguments to MapIndex.  If either the map
	// or the key is unexported, though, the result will be
	// considered unexported.  This is consistent with the
	// behavior for structs, which allow read but not write
	// of unexported fields.
	key = key.assignTo("reflect.Value.MapIndex", tt.key, nil)

	var k unsafe.Pointer
	if key.flag&flagIndir != 0 {
		k = key.ptr
	} else {
		k = unsafe.Pointer(&key.ptr)
	}
	e := mapaccess(v.typ, v.pointer(), k)
	if e == nil {
		return Value{}
	}
	typ := tt.elem
	fl := (v.flag | key.flag) & flagRO
	fl |= flag(typ.Kind())
	if ifaceIndir(typ) {
		// Copy result so future changes to the map
		// won't change the underlying value.
		c := unsafe_New(typ)
		memmove(c, e, typ.size)
		return Value{typ, c, fl | flagIndir}
	} else {
		return Value{typ, *(*unsafe.Pointer)(e), fl}
	}
}

// MapKeys returns a slice containing all the keys present in the map,
// in unspecified order.
// It panics if v's Kind is not Map.
// It returns an empty slice if v represents a nil map.
func (v Value) MapKeys() []Value {
	v.mustBe(Map)
	tt := (*mapType)(unsafe.Pointer(v.typ))
	keyType := tt.key

	fl := v.flag&flagRO | flag(keyType.Kind())

	m := v.pointer()
	mlen := int(0)
	if m != nil {
		mlen = maplen(m)
	}
	it := mapiterinit(v.typ, m)
	a := make([]Value, mlen)
	var i int
	for i = 0; i < len(a); i++ {
		key := mapiterkey(it)
		if key == nil {
			// Someone deleted an entry from the map since we
			// called maplen above.  It's a data race, but nothing
			// we can do about it.
			break
		}
		if ifaceIndir(keyType) {
			// Copy result so future changes to the map
			// won't change the underlying value.
			c := unsafe_New(keyType)
			memmove(c, key, keyType.size)
			a[i] = Value{keyType, c, fl | flagIndir}
		} else {
			a[i] = Value{keyType, *(*unsafe.Pointer)(key), fl}
		}
		mapiternext(it)
	}
	return a[:i]
}

// Method returns a function value corresponding to v's i'th method.
// The arguments to a Call on the returned function should not include
// a receiver; the returned function will always use v as the receiver.
// Method panics if i is out of range or if v is a nil interface value.
func (v Value) Method(i int) Value {
	if v.typ == nil {
		panic(&ValueError{"reflect.Value.Method", Invalid})
	}
	if v.flag&flagMethod != 0 || uint(i) >= uint(v.typ.NumMethod()) {
		panic("reflect: Method index out of range")
	}
	if v.typ.Kind() == Interface && v.IsNil() {
		panic("reflect: Method on nil interface value")
	}
	fl := v.flag & (flagRO | flagIndir)
	fl |= flag(Func)
	fl |= flag(i)<<flagMethodShift | flagMethod
	return Value{v.typ, v.ptr, fl}
}

// NumMethod returns the number of methods in the value's method set.
func (v Value) NumMethod() int {
	if v.typ == nil {
		panic(&ValueError{"reflect.Value.NumMethod", Invalid})
	}
	if v.flag&flagMethod != 0 {
		return 0
	}
	return v.typ.NumMethod()
}

// MethodByName returns a function value corresponding to the method
// of v with the given name.
// The arguments to a Call on the returned function should not include
// a receiver; the returned function will always use v as the receiver.
// It returns the zero Value if no method was found.
func (v Value) MethodByName(name string) Value {
	if v.typ == nil {
		panic(&ValueError{"reflect.Value.MethodByName", Invalid})
	}
	if v.flag&flagMethod != 0 {
		return Value{}
	}
	m, ok := v.typ.MethodByName(name)
	if !ok {
		return Value{}
	}
	return v.Method(m.Index)
}

// NumField returns the number of fields in the struct v.
// It panics if v's Kind is not Struct.
func (v Value) NumField() int {
	v.mustBe(Struct)
	tt := (*structType)(unsafe.Pointer(v.typ))
	return len(tt.fields)
}

// OverflowComplex returns true if the complex128 x cannot be represented by v's type.
// It panics if v's Kind is not Complex64 or Complex128.
func (v Value) OverflowComplex(x complex128) bool {
	k := v.kind()
	switch k {
	case Complex64:
		return overflowFloat32(real(x)) || overflowFloat32(imag(x))
	case Complex128:
		return false
	}
	panic(&ValueError{"reflect.Value.OverflowComplex", v.kind()})
}

// OverflowFloat returns true if the float64 x cannot be represented by v's type.
// It panics if v's Kind is not Float32 or Float64.
func (v Value) OverflowFloat(x float64) bool {
	k := v.kind()
	switch k {
	case Float32:
		return overflowFloat32(x)
	case Float64:
		return false
	}
	panic(&ValueError{"reflect.Value.OverflowFloat", v.kind()})
}

func overflowFloat32(x float64) bool {
	if x < 0 {
		x = -x
	}
	return math.MaxFloat32 < x && x <= math.MaxFloat64
}

// OverflowInt returns true if the int64 x cannot be represented by v's type.
// It panics if v's Kind is not Int, Int8, int16, Int32, or Int64.
func (v Value) OverflowInt(x int64) bool {
	k := v.kind()
	switch k {
	case Int, Int8, Int16, Int32, Int64:
		bitSize := v.typ.size * 8
		trunc := (x << (64 - bitSize)) >> (64 - bitSize)
		return x != trunc
	}
	panic(&ValueError{"reflect.Value.OverflowInt", v.kind()})
}

// OverflowUint returns true if the uint64 x cannot be represented by v's type.
// It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.
func (v Value) OverflowUint(x uint64) bool {
	k := v.kind()
	switch k {
	case Uint, Uintptr, Uint8, Uint16, Uint32, Uint64:
		bitSize := v.typ.size * 8
		trunc := (x << (64 - bitSize)) >> (64 - bitSize)
		return x != trunc
	}
	panic(&ValueError{"reflect.Value.OverflowUint", v.kind()})
}

// Pointer returns v's value as a uintptr.
// It returns uintptr instead of unsafe.Pointer so that
// code using reflect cannot obtain unsafe.Pointers
// without importing the unsafe package explicitly.
// It panics if v's Kind is not Chan, Func, Map, Ptr, Slice, or UnsafePointer.
//
// If v's Kind is Func, the returned pointer is an underlying
// code pointer, but not necessarily enough to identify a
// single function uniquely. The only guarantee is that the
// result is zero if and only if v is a nil func Value.
//
// If v's Kind is Slice, the returned pointer is to the first
// element of the slice.  If the slice is nil the returned value
// is 0.  If the slice is empty but non-nil the return value is non-zero.
func (v Value) Pointer() uintptr {
	// TODO: deprecate
	k := v.kind()
	switch k {
	case Chan, Map, Ptr, UnsafePointer:
		return uintptr(v.pointer())
	case Func:
		if v.flag&flagMethod != 0 {
			// As the doc comment says, the returned pointer is an
			// underlying code pointer but not necessarily enough to
			// identify a single function uniquely. All method expressions
			// created via reflect have the same underlying code pointer,
			// so their Pointers are equal. The function used here must
			// match the one used in makeMethodValue.
			f := methodValueCall
			return **(**uintptr)(unsafe.Pointer(&f))
		}
		p := v.pointer()
		// Non-nil func value points at data block.
		// First word of data block is actual code.
		if p != nil {
			p = *(*unsafe.Pointer)(p)
		}
		return uintptr(p)

	case Slice:
		return (*SliceHeader)(v.ptr).Data
	}
	panic(&ValueError{"reflect.Value.Pointer", v.kind()})
}

// Recv receives and returns a value from the channel v.
// It panics if v's Kind is not Chan.
// The receive blocks until a value is ready.
// The boolean value ok is true if the value x corresponds to a send
// on the channel, false if it is a zero value received because the channel is closed.
func (v Value) Recv() (x Value, ok bool) {
	v.mustBe(Chan)
	v.mustBeExported()
	return v.recv(false)
}

// internal recv, possibly non-blocking (nb).
// v is known to be a channel.
func (v Value) recv(nb bool) (val Value, ok bool) {
	tt := (*chanType)(unsafe.Pointer(v.typ))
	if ChanDir(tt.dir)&RecvDir == 0 {
		panic("reflect: recv on send-only channel")
	}
	t := tt.elem
	val = Value{t, nil, flag(t.Kind())}
	var p unsafe.Pointer
	if ifaceIndir(t) {
		p = unsafe_New(t)
		val.ptr = p
		val.flag |= flagIndir
	} else {
		p = unsafe.Pointer(&val.ptr)
	}
	selected, ok := chanrecv(v.typ, v.pointer(), nb, p)
	if !selected {
		val = Value{}
	}
	return
}

// Send sends x on the channel v.
// It panics if v's kind is not Chan or if x's type is not the same type as v's element type.
// As in Go, x's value must be assignable to the channel's element type.
func (v Value) Send(x Value) {
	v.mustBe(Chan)
	v.mustBeExported()
	v.send(x, false)
}

// internal send, possibly non-blocking.
// v is known to be a channel.
func (v Value) send(x Value, nb bool) (selected bool) {
	tt := (*chanType)(unsafe.Pointer(v.typ))
	if ChanDir(tt.dir)&SendDir == 0 {
		panic("reflect: send on recv-only channel")
	}
	x.mustBeExported()
	x = x.assignTo("reflect.Value.Send", tt.elem, nil)
	var p unsafe.Pointer
	if x.flag&flagIndir != 0 {
		p = x.ptr
	} else {
		p = unsafe.Pointer(&x.ptr)
	}
	return chansend(v.typ, v.pointer(), p, nb)
}

// Set assigns x to the value v.
// It panics if CanSet returns false.
// As in Go, x's value must be assignable to v's type.
func (v Value) Set(x Value) {
	v.mustBeAssignable()
	x.mustBeExported() // do not let unexported x leak
	var target unsafe.Pointer
	if v.kind() == Interface {
		target = v.ptr
	}
	x = x.assignTo("reflect.Set", v.typ, target)
	if x.flag&flagIndir != 0 {
		memmove(v.ptr, x.ptr, v.typ.size)
	} else {
		*(*unsafe.Pointer)(v.ptr) = x.ptr
	}
}

// SetBool sets v's underlying value.
// It panics if v's Kind is not Bool or if CanSet() is false.
func (v Value) SetBool(x bool) {
	v.mustBeAssignable()
	v.mustBe(Bool)
	*(*bool)(v.ptr) = x
}

// SetBytes sets v's underlying value.
// It panics if v's underlying value is not a slice of bytes.
func (v Value) SetBytes(x []byte) {
	v.mustBeAssignable()
	v.mustBe(Slice)
	if v.typ.Elem().Kind() != Uint8 {
		panic("reflect.Value.SetBytes of non-byte slice")
	}
	*(*[]byte)(v.ptr) = x
}

// setRunes sets v's underlying value.
// It panics if v's underlying value is not a slice of runes (int32s).
func (v Value) setRunes(x []rune) {
	v.mustBeAssignable()
	v.mustBe(Slice)
	if v.typ.Elem().Kind() != Int32 {
		panic("reflect.Value.setRunes of non-rune slice")
	}
	*(*[]rune)(v.ptr) = x
}

// SetComplex sets v's underlying value to x.
// It panics if v's Kind is not Complex64 or Complex128, or if CanSet() is false.
func (v Value) SetComplex(x complex128) {
	v.mustBeAssignable()
	switch k := v.kind(); k {
	default:
		panic(&ValueError{"reflect.Value.SetComplex", v.kind()})
	case Complex64:
		*(*complex64)(v.ptr) = complex64(x)
	case Complex128:
		*(*complex128)(v.ptr) = x
	}
}

// SetFloat sets v's underlying value to x.
// It panics if v's Kind is not Float32 or Float64, or if CanSet() is false.
func (v Value) SetFloat(x float64) {
	v.mustBeAssignable()
	switch k := v.kind(); k {
	default:
		panic(&ValueError{"reflect.Value.SetFloat", v.kind()})
	case Float32:
		*(*float32)(v.ptr) = float32(x)
	case Float64:
		*(*float64)(v.ptr) = x
	}
}

// SetInt sets v's underlying value to x.
// It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false.
func (v Value) SetInt(x int64) {
	v.mustBeAssignable()
	switch k := v.kind(); k {
	default:
		panic(&ValueError{"reflect.Value.SetInt", v.kind()})
	case Int:
		*(*int)(v.ptr) = int(x)
	case Int8:
		*(*int8)(v.ptr) = int8(x)
	case Int16:
		*(*int16)(v.ptr) = int16(x)
	case Int32:
		*(*int32)(v.ptr) = int32(x)
	case Int64:
		*(*int64)(v.ptr) = x
	}
}

// SetLen sets v's length to n.
// It panics if v's Kind is not Slice or if n is negative or
// greater than the capacity of the slice.
func (v Value) SetLen(n int) {
	v.mustBeAssignable()
	v.mustBe(Slice)
	s := (*sliceHeader)(v.ptr)
	if uint(n) > uint(s.Cap) {
		panic("reflect: slice length out of range in SetLen")
	}
	s.Len = n
}

// SetCap sets v's capacity to n.
// It panics if v's Kind is not Slice or if n is smaller than the length or
// greater than the capacity of the slice.
func (v Value) SetCap(n int) {
	v.mustBeAssignable()
	v.mustBe(Slice)
	s := (*sliceHeader)(v.ptr)
	if n < int(s.Len) || n > int(s.Cap) {
		panic("reflect: slice capacity out of range in SetCap")
	}
	s.Cap = n
}

// SetMapIndex sets the value associated with key in the map v to val.
// It panics if v's Kind is not Map.
// If val is the zero Value, SetMapIndex deletes the key from the map.
// Otherwise if v holds a nil map, SetMapIndex will panic.
// As in Go, key's value must be assignable to the map's key type,
// and val's value must be assignable to the map's value type.
func (v Value) SetMapIndex(key, val Value) {
	v.mustBe(Map)
	v.mustBeExported()
	key.mustBeExported()
	tt := (*mapType)(unsafe.Pointer(v.typ))
	key = key.assignTo("reflect.Value.SetMapIndex", tt.key, nil)
	var k unsafe.Pointer
	if key.flag&flagIndir != 0 {
		k = key.ptr
	} else {
		k = unsafe.Pointer(&key.ptr)
	}
	if val.typ == nil {
		mapdelete(v.typ, v.pointer(), k)
		return
	}
	val.mustBeExported()
	val = val.assignTo("reflect.Value.SetMapIndex", tt.elem, nil)
	var e unsafe.Pointer
	if val.flag&flagIndir != 0 {
		e = val.ptr
	} else {
		e = unsafe.Pointer(&val.ptr)
	}
	mapassign(v.typ, v.pointer(), k, e)
}

// SetUint sets v's underlying value to x.
// It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false.
func (v Value) SetUint(x uint64) {
	v.mustBeAssignable()
	switch k := v.kind(); k {
	default:
		panic(&ValueError{"reflect.Value.SetUint", v.kind()})
	case Uint:
		*(*uint)(v.ptr) = uint(x)
	case Uint8:
		*(*uint8)(v.ptr) = uint8(x)
	case Uint16:
		*(*uint16)(v.ptr) = uint16(x)
	case Uint32:
		*(*uint32)(v.ptr) = uint32(x)
	case Uint64:
		*(*uint64)(v.ptr) = x
	case Uintptr:
		*(*uintptr)(v.ptr) = uintptr(x)
	}
}

// SetPointer sets the unsafe.Pointer value v to x.
// It panics if v's Kind is not UnsafePointer.
func (v Value) SetPointer(x unsafe.Pointer) {
	v.mustBeAssignable()
	v.mustBe(UnsafePointer)
	*(*unsafe.Pointer)(v.ptr) = x
}

// SetString sets v's underlying value to x.
// It panics if v's Kind is not String or if CanSet() is false.
func (v Value) SetString(x string) {
	v.mustBeAssignable()
	v.mustBe(String)
	*(*string)(v.ptr) = x
}

// Slice returns v[i:j].
// It panics if v's Kind is not Array, Slice or String, or if v is an unaddressable array,
// or if the indexes are out of bounds.
func (v Value) Slice(i, j int) Value {
	var (
		cap  int
		typ  *sliceType
		base unsafe.Pointer
	)
	switch kind := v.kind(); kind {
	default:
		panic(&ValueError{"reflect.Value.Slice", v.kind()})

	case Array:
		if v.flag&flagAddr == 0 {
			panic("reflect.Value.Slice: slice of unaddressable array")
		}
		tt := (*arrayType)(unsafe.Pointer(v.typ))
		cap = int(tt.len)
		typ = (*sliceType)(unsafe.Pointer(tt.slice))
		base = v.ptr

	case Slice:
		typ = (*sliceType)(unsafe.Pointer(v.typ))
		s := (*sliceHeader)(v.ptr)
		base = unsafe.Pointer(s.Data)
		cap = s.Cap

	case String:
		s := (*stringHeader)(v.ptr)
		if i < 0 || j < i || j > s.Len {
			panic("reflect.Value.Slice: string slice index out of bounds")
		}
		t := stringHeader{unsafe.Pointer(uintptr(s.Data) + uintptr(i)), j - i}
		return Value{v.typ, unsafe.Pointer(&t), v.flag}
	}

	if i < 0 || j < i || j > cap {
		panic("reflect.Value.Slice: slice index out of bounds")
	}

	// Declare slice so that gc can see the base pointer in it.
	var x []unsafe.Pointer

	// Reinterpret as *sliceHeader to edit.
	s := (*sliceHeader)(unsafe.Pointer(&x))
	s.Len = j - i
	s.Cap = cap - i
	if cap-i > 0 {
		s.Data = unsafe.Pointer(uintptr(base) + uintptr(i)*typ.elem.Size())
	} else {
		// do not advance pointer, to avoid pointing beyond end of slice
		s.Data = base
	}

	fl := v.flag&flagRO | flagIndir | flag(Slice)
	return Value{typ.common(), unsafe.Pointer(&x), fl}
}

// Slice3 is the 3-index form of the slice operation: it returns v[i:j:k].
// It panics if v's Kind is not Array or Slice, or if v is an unaddressable array,
// or if the indexes are out of bounds.
func (v Value) Slice3(i, j, k int) Value {
	var (
		cap  int
		typ  *sliceType
		base unsafe.Pointer
	)
	switch kind := v.kind(); kind {
	default:
		panic(&ValueError{"reflect.Value.Slice3", v.kind()})

	case Array:
		if v.flag&flagAddr == 0 {
			panic("reflect.Value.Slice3: slice of unaddressable array")
		}
		tt := (*arrayType)(unsafe.Pointer(v.typ))
		cap = int(tt.len)
		typ = (*sliceType)(unsafe.Pointer(tt.slice))
		base = v.ptr

	case Slice:
		typ = (*sliceType)(unsafe.Pointer(v.typ))
		s := (*sliceHeader)(v.ptr)
		base = s.Data
		cap = s.Cap
	}

	if i < 0 || j < i || k < j || k > cap {
		panic("reflect.Value.Slice3: slice index out of bounds")
	}

	// Declare slice so that the garbage collector
	// can see the base pointer in it.
	var x []unsafe.Pointer

	// Reinterpret as *sliceHeader to edit.
	s := (*sliceHeader)(unsafe.Pointer(&x))
	s.Len = j - i
	s.Cap = k - i
	if k-i > 0 {
		s.Data = unsafe.Pointer(uintptr(base) + uintptr(i)*typ.elem.Size())
	} else {
		// do not advance pointer, to avoid pointing beyond end of slice
		s.Data = base
	}

	fl := v.flag&flagRO | flagIndir | flag(Slice)
	return Value{typ.common(), unsafe.Pointer(&x), fl}
}

// String returns the string v's underlying value, as a string.
// String is a special case because of Go's String method convention.
// Unlike the other getters, it does not panic if v's Kind is not String.
// Instead, it returns a string of the form "<T value>" where T is v's type.
func (v Value) String() string {
	switch k := v.kind(); k {
	case Invalid:
		return "<invalid Value>"
	case String:
		return *(*string)(v.ptr)
	}
	// If you call String on a reflect.Value of other type, it's better to
	// print something than to panic. Useful in debugging.
	return "<" + v.Type().String() + " Value>"
}

// TryRecv attempts to receive a value from the channel v but will not block.
// It panics if v's Kind is not Chan.
// If the receive delivers a value, x is the transferred value and ok is true.
// If the receive cannot finish without blocking, x is the zero Value and ok is false.
// If the channel is closed, x is the zero value for the channel's element type and ok is false.
func (v Value) TryRecv() (x Value, ok bool) {
	v.mustBe(Chan)
	v.mustBeExported()
	return v.recv(true)
}

// TrySend attempts to send x on the channel v but will not block.
// It panics if v's Kind is not Chan.
// It returns true if the value was sent, false otherwise.
// As in Go, x's value must be assignable to the channel's element type.
func (v Value) TrySend(x Value) bool {
	v.mustBe(Chan)
	v.mustBeExported()
	return v.send(x, true)
}

// Type returns v's type.
func (v Value) Type() Type {
	f := v.flag
	if f == 0 {
		panic(&ValueError{"reflect.Value.Type", Invalid})
	}
	if f&flagMethod == 0 {
		// Easy case
		return v.typ
	}

	// Method value.
	// v.typ describes the receiver, not the method type.
	i := int(v.flag) >> flagMethodShift
	if v.typ.Kind() == Interface {
		// Method on interface.
		tt := (*interfaceType)(unsafe.Pointer(v.typ))
		if uint(i) >= uint(len(tt.methods)) {
			panic("reflect: internal error: invalid method index")
		}
		m := &tt.methods[i]
		return m.typ
	}
	// Method on concrete type.
	ut := v.typ.uncommon()
	if ut == nil || uint(i) >= uint(len(ut.methods)) {
		panic("reflect: internal error: invalid method index")
	}
	m := &ut.methods[i]
	return m.mtyp
}

// Uint returns v's underlying value, as a uint64.
// It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.
func (v Value) Uint() uint64 {
	k := v.kind()
	p := v.ptr
	switch k {
	case Uint:
		return uint64(*(*uint)(p))
	case Uint8:
		return uint64(*(*uint8)(p))
	case Uint16:
		return uint64(*(*uint16)(p))
	case Uint32:
		return uint64(*(*uint32)(p))
	case Uint64:
		return uint64(*(*uint64)(p))
	case Uintptr:
		return uint64(*(*uintptr)(p))
	}
	panic(&ValueError{"reflect.Value.Uint", v.kind()})
}

// UnsafeAddr returns a pointer to v's data.
// It is for advanced clients that also import the "unsafe" package.
// It panics if v is not addressable.
func (v Value) UnsafeAddr() uintptr {
	// TODO: deprecate
	if v.typ == nil {
		panic(&ValueError{"reflect.Value.UnsafeAddr", Invalid})
	}
	if v.flag&flagAddr == 0 {
		panic("reflect.Value.UnsafeAddr of unaddressable value")
	}
	return uintptr(v.ptr)
}

// StringHeader is the runtime representation of a string.
// It cannot be used safely or portably and its representation may
// change in a later release.
// Moreover, the Data field is not sufficient to guarantee the data
// it references will not be garbage collected, so programs must keep
// a separate, correctly typed pointer to the underlying data.
type StringHeader struct {
	Data uintptr
	Len  int
}

// stringHeader is a safe version of StringHeader used within this package.
type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// SliceHeader is the runtime representation of a slice.
// It cannot be used safely or portably and its representation may
// change in a later release.
// Moreover, the Data field is not sufficient to guarantee the data
// it references will not be garbage collected, so programs must keep
// a separate, correctly typed pointer to the underlying data.
type SliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

// sliceHeader is a safe version of SliceHeader used within this package.
type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

func typesMustMatch(what string, t1, t2 Type) {
	if t1 != t2 {
		panic(what + ": " + t1.String() + " != " + t2.String())
	}
}

// grow grows the slice s so that it can hold extra more values, allocating
// more capacity if needed. It also returns the old and new slice lengths.
func grow(s Value, extra int) (Value, int, int) {
	i0 := s.Len()
	i1 := i0 + extra
	if i1 < i0 {
		panic("reflect.Append: slice overflow")
	}
	m := s.Cap()
	if i1 <= m {
		return s.Slice(0, i1), i0, i1
	}
	if m == 0 {
		m = extra
	} else {
		for m < i1 {
			if i0 < 1024 {
				m += m
			} else {
				m += m / 4
			}
		}
	}
	t := MakeSlice(s.Type(), i1, m)
	Copy(t, s)
	return t, i0, i1
}

// Append appends the values x to a slice s and returns the resulting slice.
// As in Go, each x's value must be assignable to the slice's element type.
func Append(s Value, x ...Value) Value {
	s.mustBe(Slice)
	s, i0, i1 := grow(s, len(x))
	for i, j := i0, 0; i < i1; i, j = i+1, j+1 {
		s.Index(i).Set(x[j])
	}
	return s
}

// AppendSlice appends a slice t to a slice s and returns the resulting slice.
// The slices s and t must have the same element type.
func AppendSlice(s, t Value) Value {
	s.mustBe(Slice)
	t.mustBe(Slice)
	typesMustMatch("reflect.AppendSlice", s.Type().Elem(), t.Type().Elem())
	s, i0, i1 := grow(s, t.Len())
	Copy(s.Slice(i0, i1), t)
	return s
}

// Copy copies the contents of src into dst until either
// dst has been filled or src has been exhausted.
// It returns the number of elements copied.
// Dst and src each must have kind Slice or Array, and
// dst and src must have the same element type.
func Copy(dst, src Value) int {
	dk := dst.kind()
	if dk != Array && dk != Slice {
		panic(&ValueError{"reflect.Copy", dk})
	}
	if dk == Array {
		dst.mustBeAssignable()
	}
	dst.mustBeExported()

	sk := src.kind()
	if sk != Array && sk != Slice {
		panic(&ValueError{"reflect.Copy", sk})
	}
	src.mustBeExported()

	de := dst.typ.Elem()
	se := src.typ.Elem()
	typesMustMatch("reflect.Copy", de, se)

	n := dst.Len()
	if sn := src.Len(); n > sn {
		n = sn
	}

	// Copy via memmove.
	var da, sa unsafe.Pointer
	if dk == Array {
		da = dst.ptr
	} else {
		da = (*sliceHeader)(dst.ptr).Data
	}
	if src.flag&flagIndir == 0 {
		sa = unsafe.Pointer(&src.ptr)
	} else if sk == Array {
		sa = src.ptr
	} else {
		sa = (*sliceHeader)(src.ptr).Data
	}
	memmove(da, sa, uintptr(n)*de.Size())
	return n
}

// A runtimeSelect is a single case passed to rselect.
// This must match ../runtime/select.go:/runtimeSelect
type runtimeSelect struct {
	dir uintptr        // 0, SendDir, or RecvDir
	typ *rtype         // channel type
	ch  unsafe.Pointer // channel
	val unsafe.Pointer // ptr to data (SendDir) or ptr to receive buffer (RecvDir)
}

// rselect runs a select.  It returns the index of the chosen case.
// If the case was a receive, val is filled in with the received value.
// The conventional OK bool indicates whether the receive corresponds
// to a sent value.
//go:noescape
func rselect([]runtimeSelect) (chosen int, recvOK bool)

// A SelectDir describes the communication direction of a select case.
type SelectDir int

// NOTE: These values must match ../runtime/select.go:/selectDir.

const (
	_             SelectDir = iota
	SelectSend              // case Chan <- Send
	SelectRecv              // case <-Chan:
	SelectDefault           // default
)

// A SelectCase describes a single case in a select operation.
// The kind of case depends on Dir, the communication direction.
//
// If Dir is SelectDefault, the case represents a default case.
// Chan and Send must be zero Values.
//
// If Dir is SelectSend, the case represents a send operation.
// Normally Chan's underlying value must be a channel, and Send's underlying value must be
// assignable to the channel's element type. As a special case, if Chan is a zero Value,
// then the case is ignored, and the field Send will also be ignored and may be either zero
// or non-zero.
//
// If Dir is SelectRecv, the case represents a receive operation.
// Normally Chan's underlying value must be a channel and Send must be a zero Value.
// If Chan is a zero Value, then the case is ignored, but Send must still be a zero Value.
// When a receive operation is selected, the received Value is returned by Select.
//
type SelectCase struct {
	Dir  SelectDir // direction of case
	Chan Value     // channel to use (for send or receive)
	Send Value     // value to send (for send)
}

// Select executes a select operation described by the list of cases.
// Like the Go select statement, it blocks until at least one of the cases
// can proceed, makes a uniform pseudo-random choice,
// and then executes that case. It returns the index of the chosen case
// and, if that case was a receive operation, the value received and a
// boolean indicating whether the value corresponds to a send on the channel
// (as opposed to a zero value received because the channel is closed).
func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool) {
	// NOTE: Do not trust that caller is not modifying cases data underfoot.
	// The range is safe because the caller cannot modify our copy of the len
	// and each iteration makes its own copy of the value c.
	runcases := make([]runtimeSelect, len(cases))
	haveDefault := false
	for i, c := range cases {
		rc := &runcases[i]
		rc.dir = uintptr(c.Dir)
		switch c.Dir {
		default:
			panic("reflect.Select: invalid Dir")

		case SelectDefault: // default
			if haveDefault {
				panic("reflect.Select: multiple default cases")
			}
			haveDefault = true
			if c.Chan.IsValid() {
				panic("reflect.Select: default case has Chan value")
			}
			if c.Send.IsValid() {
				panic("reflect.Select: default case has Send value")
			}

		case SelectSend:
			ch := c.Chan
			if !ch.IsValid() {
				break
			}
			ch.mustBe(Chan)
			ch.mustBeExported()
			tt := (*chanType)(unsafe.Pointer(ch.typ))
			if ChanDir(tt.dir)&SendDir == 0 {
				panic("reflect.Select: SendDir case using recv-only channel")
			}
			rc.ch = ch.pointer()
			rc.typ = &tt.rtype
			v := c.Send
			if !v.IsValid() {
				panic("reflect.Select: SendDir case missing Send value")
			}
			v.mustBeExported()
			v = v.assignTo("reflect.Select", tt.elem, nil)
			if v.flag&flagIndir != 0 {
				rc.val = v.ptr
			} else {
				rc.val = unsafe.Pointer(&v.ptr)
			}

		case SelectRecv:
			if c.Send.IsValid() {
				panic("reflect.Select: RecvDir case has Send value")
			}
			ch := c.Chan
			if !ch.IsValid() {
				break
			}
			ch.mustBe(Chan)
			ch.mustBeExported()
			tt := (*chanType)(unsafe.Pointer(ch.typ))
			if ChanDir(tt.dir)&RecvDir == 0 {
				panic("reflect.Select: RecvDir case using send-only channel")
			}
			rc.ch = ch.pointer()
			rc.typ = &tt.rtype
			rc.val = unsafe_New(tt.elem)
		}
	}

	chosen, recvOK = rselect(runcases)
	if runcases[chosen].dir == uintptr(SelectRecv) {
		tt := (*chanType)(unsafe.Pointer(runcases[chosen].typ))
		t := tt.elem
		p := runcases[chosen].val
		fl := flag(t.Kind())
		if ifaceIndir(t) {
			recv = Value{t, p, fl | flagIndir}
		} else {
			recv = Value{t, *(*unsafe.Pointer)(p), fl}
		}
	}
	return chosen, recv, recvOK
}

/*
 * constructors
 */

// implemented in package runtime
func unsafe_New(*rtype) unsafe.Pointer
func unsafe_NewArray(*rtype, int) unsafe.Pointer

// MakeSlice creates a new zero-initialized slice value
// for the specified slice type, length, and capacity.
func MakeSlice(typ Type, len, cap int) Value {
	if typ.Kind() != Slice {
		panic("reflect.MakeSlice of non-slice type")
	}
	if len < 0 {
		panic("reflect.MakeSlice: negative len")
	}
	if cap < 0 {
		panic("reflect.MakeSlice: negative cap")
	}
	if len > cap {
		panic("reflect.MakeSlice: len > cap")
	}

	s := sliceHeader{unsafe_NewArray(typ.Elem().(*rtype), cap), len, cap}
	return Value{typ.common(), unsafe.Pointer(&s), flagIndir | flag(Slice)}
}

// MakeChan creates a new channel with the specified type and buffer size.
func MakeChan(typ Type, buffer int) Value {
	if typ.Kind() != Chan {
		panic("reflect.MakeChan of non-chan type")
	}
	if buffer < 0 {
		panic("reflect.MakeChan: negative buffer size")
	}
	if typ.ChanDir() != BothDir {
		panic("reflect.MakeChan: unidirectional channel type")
	}
	ch := makechan(typ.(*rtype), uint64(buffer))
	return Value{typ.common(), ch, flag(Chan)}
}

// MakeMap creates a new map of the specified type.
func MakeMap(typ Type) Value {
	if typ.Kind() != Map {
		panic("reflect.MakeMap of non-map type")
	}
	m := makemap(typ.(*rtype))
	return Value{typ.common(), m, flag(Map)}
}

// Indirect returns the value that v points to.
// If v is a nil pointer, Indirect returns a zero Value.
// If v is not a pointer, Indirect returns v.
func Indirect(v Value) Value {
	if v.Kind() != Ptr {
		return v
	}
	return v.Elem()
}

// ValueOf returns a new Value initialized to the concrete value
// stored in the interface i.  ValueOf(nil) returns the zero Value.
func ValueOf(i interface{}) Value {
	if i == nil {
		return Value{}
	}

	// TODO(rsc): Eliminate this terrible hack.
	// In the call to unpackEface, i.typ doesn't escape,
	// and i.word is an integer.  So it looks like
	// i doesn't escape.  But really it does,
	// because i.word is actually a pointer.
	escapes(i)

	return unpackEface(i)
}

// Zero returns a Value representing the zero value for the specified type.
// The result is different from the zero value of the Value struct,
// which represents no value at all.
// For example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0.
// The returned value is neither addressable nor settable.
func Zero(typ Type) Value {
	if typ == nil {
		panic("reflect: Zero(nil)")
	}
	t := typ.common()
	fl := flag(t.Kind())
	if ifaceIndir(t) {
		return Value{t, unsafe_New(typ.(*rtype)), fl | flagIndir}
	}
	return Value{t, nil, fl}
}

// New returns a Value representing a pointer to a new zero value
// for the specified type.  That is, the returned Value's Type is PtrTo(typ).
func New(typ Type) Value {
	if typ == nil {
		panic("reflect: New(nil)")
	}
	ptr := unsafe_New(typ.(*rtype))
	fl := flag(Ptr)
	return Value{typ.common().ptrTo(), ptr, fl}
}

// NewAt returns a Value representing a pointer to a value of the
// specified type, using p as that pointer.
func NewAt(typ Type, p unsafe.Pointer) Value {
	fl := flag(Ptr)
	return Value{typ.common().ptrTo(), p, fl}
}

// assignTo returns a value v that can be assigned directly to typ.
// It panics if v is not assignable to typ.
// For a conversion to an interface type, target is a suggested scratch space to use.
func (v Value) assignTo(context string, dst *rtype, target unsafe.Pointer) Value {
	if v.flag&flagMethod != 0 {
		v = makeMethodValue(context, v)
	}

	switch {
	case directlyAssignable(dst, v.typ):
		// Overwrite type so that they match.
		// Same memory layout, so no harm done.
		v.typ = dst
		fl := v.flag & (flagRO | flagAddr | flagIndir)
		fl |= flag(dst.Kind())
		return Value{dst, v.ptr, fl}

	case implements(dst, v.typ):
		if target == nil {
			target = unsafe_New(dst)
		}
		x := valueInterface(v, false)
		if dst.NumMethod() == 0 {
			*(*interface{})(target) = x
		} else {
			ifaceE2I(dst, x, target)
		}
		return Value{dst, target, flagIndir | flag(Interface)}
	}

	// Failed.
	panic(context + ": value of type " + v.typ.String() + " is not assignable to type " + dst.String())
}

// Convert returns the value v converted to type t.
// If the usual Go conversion rules do not allow conversion
// of the value v to type t, Convert panics.
func (v Value) Convert(t Type) Value {
	if v.flag&flagMethod != 0 {
		v = makeMethodValue("Convert", v)
	}
	op := convertOp(t.common(), v.typ)
	if op == nil {
		panic("reflect.Value.Convert: value of type " + v.typ.String() + " cannot be converted to type " + t.String())
	}
	return op(v, t)
}

// convertOp returns the function to convert a value of type src
// to a value of type dst. If the conversion is illegal, convertOp returns nil.
func convertOp(dst, src *rtype) func(Value, Type) Value {
	switch src.Kind() {
	case Int, Int8, Int16, Int32, Int64:
		switch dst.Kind() {
		case Int, Int8, Int16, Int32, Int64, Uint, Uint8, Uint16, Uint32, Uint64, Uintptr:
			return cvtInt
		case Float32, Float64:
			return cvtIntFloat
		case String:
			return cvtIntString
		}

	case Uint, Uint8, Uint16, Uint32, Uint64, Uintptr:
		switch dst.Kind() {
		case Int, Int8, Int16, Int32, Int64, Uint, Uint8, Uint16, Uint32, Uint64, Uintptr:
			return cvtUint
		case Float32, Float64:
			return cvtUintFloat
		case String:
			return cvtUintString
		}

	case Float32, Float64:
		switch dst.Kind() {
		case Int, Int8, Int16, Int32, Int64:
			return cvtFloatInt
		case Uint, Uint8, Uint16, Uint32, Uint64, Uintptr:
			return cvtFloatUint
		case Float32, Float64:
			return cvtFloat
		}

	case Complex64, Complex128:
		switch dst.Kind() {
		case Complex64, Complex128:
			return cvtComplex
		}

	case String:
		if dst.Kind() == Slice && dst.Elem().PkgPath() == "" {
			switch dst.Elem().Kind() {
			case Uint8:
				return cvtStringBytes
			case Int32:
				return cvtStringRunes
			}
		}

	case Slice:
		if dst.Kind() == String && src.Elem().PkgPath() == "" {
			switch src.Elem().Kind() {
			case Uint8:
				return cvtBytesString
			case Int32:
				return cvtRunesString
			}
		}
	}

	// dst and src have same underlying type.
	if haveIdenticalUnderlyingType(dst, src) {
		return cvtDirect
	}

	// dst and src are unnamed pointer types with same underlying base type.
	if dst.Kind() == Ptr && dst.Name() == "" &&
		src.Kind() == Ptr && src.Name() == "" &&
		haveIdenticalUnderlyingType(dst.Elem().common(), src.Elem().common()) {
		return cvtDirect
	}

	if implements(dst, src) {
		if src.Kind() == Interface {
			return cvtI2I
		}
		return cvtT2I
	}

	return nil
}

// makeInt returns a Value of type t equal to bits (possibly truncated),
// where t is a signed or unsigned int type.
func makeInt(f flag, bits uint64, t Type) Value {
	typ := t.common()
	ptr := unsafe_New(typ)
	switch typ.size {
	case 1:
		*(*uint8)(unsafe.Pointer(ptr)) = uint8(bits)
	case 2:
		*(*uint16)(unsafe.Pointer(ptr)) = uint16(bits)
	case 4:
		*(*uint32)(unsafe.Pointer(ptr)) = uint32(bits)
	case 8:
		*(*uint64)(unsafe.Pointer(ptr)) = bits
	}
	return Value{typ, ptr, f | flagIndir | flag(typ.Kind())}
}

// makeFloat returns a Value of type t equal to v (possibly truncated to float32),
// where t is a float32 or float64 type.
func makeFloat(f flag, v float64, t Type) Value {
	typ := t.common()
	ptr := unsafe_New(typ)
	switch typ.size {
	case 4:
		*(*float32)(unsafe.Pointer(ptr)) = float32(v)
	case 8:
		*(*float64)(unsafe.Pointer(ptr)) = v
	}
	return Value{typ, ptr, f | flagIndir | flag(typ.Kind())}
}

// makeComplex returns a Value of type t equal to v (possibly truncated to complex64),
// where t is a complex64 or complex128 type.
func makeComplex(f flag, v complex128, t Type) Value {
	typ := t.common()
	ptr := unsafe_New(typ)
	switch typ.size {
	case 8:
		*(*complex64)(unsafe.Pointer(ptr)) = complex64(v)
	case 16:
		*(*complex128)(unsafe.Pointer(ptr)) = v
	}
	return Value{typ, ptr, f | flagIndir | flag(typ.Kind())}
}

func makeString(f flag, v string, t Type) Value {
	ret := New(t).Elem()
	ret.SetString(v)
	ret.flag = ret.flag&^flagAddr | f
	return ret
}

func makeBytes(f flag, v []byte, t Type) Value {
	ret := New(t).Elem()
	ret.SetBytes(v)
	ret.flag = ret.flag&^flagAddr | f
	return ret
}

func makeRunes(f flag, v []rune, t Type) Value {
	ret := New(t).Elem()
	ret.setRunes(v)
	ret.flag = ret.flag&^flagAddr | f
	return ret
}

// These conversion functions are returned by convertOp
// for classes of conversions. For example, the first function, cvtInt,
// takes any value v of signed int type and returns the value converted
// to type t, where t is any signed or unsigned int type.

// convertOp: intXX -> [u]intXX
func cvtInt(v Value, t Type) Value {
	return makeInt(v.flag&flagRO, uint64(v.Int()), t)
}

// convertOp: uintXX -> [u]intXX
func cvtUint(v Value, t Type) Value {
	return makeInt(v.flag&flagRO, v.Uint(), t)
}

// convertOp: floatXX -> intXX
func cvtFloatInt(v Value, t Type) Value {
	return makeInt(v.flag&flagRO, uint64(int64(v.Float())), t)
}

// convertOp: floatXX -> uintXX
func cvtFloatUint(v Value, t Type) Value {
	return makeInt(v.flag&flagRO, uint64(v.Float()), t)
}

// convertOp: intXX -> floatXX
func cvtIntFloat(v Value, t Type) Value {
	return makeFloat(v.flag&flagRO, float64(v.Int()), t)
}

// convertOp: uintXX -> floatXX
func cvtUintFloat(v Value, t Type) Value {
	return makeFloat(v.flag&flagRO, float64(v.Uint()), t)
}

// convertOp: floatXX -> floatXX
func cvtFloat(v Value, t Type) Value {
	return makeFloat(v.flag&flagRO, v.Float(), t)
}

// convertOp: complexXX -> complexXX
func cvtComplex(v Value, t Type) Value {
	return makeComplex(v.flag&flagRO, v.Complex(), t)
}

// convertOp: intXX -> string
func cvtIntString(v Value, t Type) Value {
	return makeString(v.flag&flagRO, string(v.Int()), t)
}

// convertOp: uintXX -> string
func cvtUintString(v Value, t Type) Value {
	return makeString(v.flag&flagRO, string(v.Uint()), t)
}

// convertOp: []byte -> string
func cvtBytesString(v Value, t Type) Value {
	return makeString(v.flag&flagRO, string(v.Bytes()), t)
}

// convertOp: string -> []byte
func cvtStringBytes(v Value, t Type) Value {
	return makeBytes(v.flag&flagRO, []byte(v.String()), t)
}

// convertOp: []rune -> string
func cvtRunesString(v Value, t Type) Value {
	return makeString(v.flag&flagRO, string(v.runes()), t)
}

// convertOp: string -> []rune
func cvtStringRunes(v Value, t Type) Value {
	return makeRunes(v.flag&flagRO, []rune(v.String()), t)
}

// convertOp: direct copy
func cvtDirect(v Value, typ Type) Value {
	f := v.flag
	t := typ.common()
	ptr := v.ptr
	if f&flagAddr != 0 {
		// indirect, mutable word - make a copy
		c := unsafe_New(t)
		memmove(c, ptr, t.size)
		ptr = c
		f &^= flagAddr
	}
	return Value{t, ptr, v.flag&flagRO | f} // v.flag&flagRO|f == f?
}

// convertOp: concrete -> interface
func cvtT2I(v Value, typ Type) Value {
	target := unsafe_New(typ.common())
	x := valueInterface(v, false)
	if typ.NumMethod() == 0 {
		*(*interface{})(target) = x
	} else {
		ifaceE2I(typ.(*rtype), x, target)
	}
	return Value{typ.common(), target, v.flag&flagRO | flagIndir | flag(Interface)}
}

// convertOp: interface -> interface
func cvtI2I(v Value, typ Type) Value {
	if v.IsNil() {
		ret := Zero(typ)
		ret.flag |= v.flag & flagRO
		return ret
	}
	return cvtT2I(v.Elem(), typ)
}

// implemented in ../runtime
func chancap(ch unsafe.Pointer) int
func chanclose(ch unsafe.Pointer)
func chanlen(ch unsafe.Pointer) int

//go:noescape
func chanrecv(t *rtype, ch unsafe.Pointer, nb bool, val unsafe.Pointer) (selected, received bool)

//go:noescape
func chansend(t *rtype, ch unsafe.Pointer, val unsafe.Pointer, nb bool) bool

func makechan(typ *rtype, size uint64) (ch unsafe.Pointer)
func makemap(t *rtype) (m unsafe.Pointer)
func mapaccess(t *rtype, m unsafe.Pointer, key unsafe.Pointer) (val unsafe.Pointer)
func mapassign(t *rtype, m unsafe.Pointer, key, val unsafe.Pointer)
func mapdelete(t *rtype, m unsafe.Pointer, key unsafe.Pointer)
func mapiterinit(t *rtype, m unsafe.Pointer) unsafe.Pointer
func mapiterkey(it unsafe.Pointer) (key unsafe.Pointer)
func mapiternext(it unsafe.Pointer)
func maplen(m unsafe.Pointer) int
func call(fn, arg unsafe.Pointer, n uint32, retoffset uint32)

func ifaceE2I(t *rtype, src interface{}, dst unsafe.Pointer)

//go:noescape
func memmove(adst, asrc unsafe.Pointer, n uintptr)

// Dummy annotation marking that the value x escapes,
// for use in cases where the reflect code is so clever that
// the compiler cannot follow.
func escapes(x interface{}) {
	if dummy.b {
		dummy.x = x
	}
}

var dummy struct {
	b bool
	x interface{}
}
                                                                                                                                                                                                       root/go1.4/src/regexp/                                                                              0040755 0000000 0000000 00000000000 12600426244 013144  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/regexp/all_test.go                                                                   0100644 0000000 0000000 00000043547 12600426227 015315  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package regexp

import (
	"reflect"
	"regexp/syntax"
	"strings"
	"testing"
)

var good_re = []string{
	``,
	`.`,
	`^.$`,
	`a`,
	`a*`,
	`a+`,
	`a?`,
	`a|b`,
	`a*|b*`,
	`(a*|b)(c*|d)`,
	`[a-z]`,
	`[a-abc-c\-\]\[]`,
	`[a-z]+`,
	`[abc]`,
	`[^1234]`,
	`[^\n]`,
	`\!\\`,
}

type stringError struct {
	re  string
	err string
}

var bad_re = []stringError{
	{`*`, "missing argument to repetition operator: `*`"},
	{`+`, "missing argument to repetition operator: `+`"},
	{`?`, "missing argument to repetition operator: `?`"},
	{`(abc`, "missing closing ): `(abc`"},
	{`abc)`, "unexpected ): `abc)`"},
	{`x[a-z`, "missing closing ]: `[a-z`"},
	{`[z-a]`, "invalid character class range: `z-a`"},
	{`abc\`, "trailing backslash at end of expression"},
	{`a**`, "invalid nested repetition operator: `**`"},
	{`a*+`, "invalid nested repetition operator: `*+`"},
	{`\x`, "invalid escape sequence: `\\x`"},
}

func compileTest(t *testing.T, expr string, error string) *Regexp {
	re, err := Compile(expr)
	if error == "" && err != nil {
		t.Error("compiling `", expr, "`; unexpected error: ", err.Error())
	}
	if error != "" && err == nil {
		t.Error("compiling `", expr, "`; missing error")
	} else if error != "" && !strings.Contains(err.Error(), error) {
		t.Error("compiling `", expr, "`; wrong error: ", err.Error(), "; want ", error)
	}
	return re
}

func TestGoodCompile(t *testing.T) {
	for i := 0; i < len(good_re); i++ {
		compileTest(t, good_re[i], "")
	}
}

func TestBadCompile(t *testing.T) {
	for i := 0; i < len(bad_re); i++ {
		compileTest(t, bad_re[i].re, bad_re[i].err)
	}
}

func matchTest(t *testing.T, test *FindTest) {
	re := compileTest(t, test.pat, "")
	if re == nil {
		return
	}
	m := re.MatchString(test.text)
	if m != (len(test.matches) > 0) {
		t.Errorf("MatchString failure on %s: %t should be %t", test, m, len(test.matches) > 0)
	}
	// now try bytes
	m = re.Match([]byte(test.text))
	if m != (len(test.matches) > 0) {
		t.Errorf("Match failure on %s: %t should be %t", test, m, len(test.matches) > 0)
	}
}

func TestMatch(t *testing.T) {
	for _, test := range findTests {
		matchTest(t, &test)
	}
}

func matchFunctionTest(t *testing.T, test *FindTest) {
	m, err := MatchString(test.pat, test.text)
	if err == nil {
		return
	}
	if m != (len(test.matches) > 0) {
		t.Errorf("Match failure on %s: %t should be %t", test, m, len(test.matches) > 0)
	}
}

func TestMatchFunction(t *testing.T) {
	for _, test := range findTests {
		matchFunctionTest(t, &test)
	}
}

type ReplaceTest struct {
	pattern, replacement, input, output string
}

var replaceTests = []ReplaceTest{
	// Test empty input and/or replacement, with pattern that matches the empty string.
	{"", "", "", ""},
	{"", "x", "", "x"},
	{"", "", "abc", "abc"},
	{"", "x", "abc", "xaxbxcx"},

	// Test empty input and/or replacement, with pattern that does not match the empty string.
	{"b", "", "", ""},
	{"b", "x", "", ""},
	{"b", "", "abc", "ac"},
	{"b", "x", "abc", "axc"},
	{"y", "", "", ""},
	{"y", "x", "", ""},
	{"y", "", "abc", "abc"},
	{"y", "x", "abc", "abc"},

	// Multibyte characters -- verify that we don't try to match in the middle
	// of a character.
	{"[a-c]*", "x", "\u65e5", "x\u65e5x"},
	{"[^\u65e5]", "x", "abc\u65e5def", "xxx\u65e5xxx"},

	// Start and end of a string.
	{"^[a-c]*", "x", "abcdabc", "xdabc"},
	{"[a-c]*$", "x", "abcdabc", "abcdx"},
	{"^[a-c]*$", "x", "abcdabc", "abcdabc"},
	{"^[a-c]*", "x", "abc", "x"},
	{"[a-c]*$", "x", "abc", "x"},
	{"^[a-c]*$", "x", "abc", "x"},
	{"^[a-c]*", "x", "dabce", "xdabce"},
	{"[a-c]*$", "x", "dabce", "dabcex"},
	{"^[a-c]*$", "x", "dabce", "dabce"},
	{"^[a-c]*", "x", "", "x"},
	{"[a-c]*$", "x", "", "x"},
	{"^[a-c]*$", "x", "", "x"},

	{"^[a-c]+", "x", "abcdabc", "xdabc"},
	{"[a-c]+$", "x", "abcdabc", "abcdx"},
	{"^[a-c]+$", "x", "abcdabc", "abcdabc"},
	{"^[a-c]+", "x", "abc", "x"},
	{"[a-c]+$", "x", "abc", "x"},
	{"^[a-c]+$", "x", "abc", "x"},
	{"^[a-c]+", "x", "dabce", "dabce"},
	{"[a-c]+$", "x", "dabce", "dabce"},
	{"^[a-c]+$", "x", "dabce", "dabce"},
	{"^[a-c]+", "x", "", ""},
	{"[a-c]+$", "x", "", ""},
	{"^[a-c]+$", "x", "", ""},

	// Other cases.
	{"abc", "def", "abcdefg", "defdefg"},
	{"bc", "BC", "abcbcdcdedef", "aBCBCdcdedef"},
	{"abc", "", "abcdabc", "d"},
	{"x", "xXx", "xxxXxxx", "xXxxXxxXxXxXxxXxxXx"},
	{"abc", "d", "", ""},
	{"abc", "d", "abc", "d"},
	{".+", "x", "abc", "x"},
	{"[a-c]*", "x", "def", "xdxexfx"},
	{"[a-c]+", "x", "abcbcdcdedef", "xdxdedef"},
	{"[a-c]*", "x", "abcbcdcdedef", "xdxdxexdxexfx"},

	// Substitutions
	{"a+", "($0)", "banana", "b(a)n(a)n(a)"},
	{"a+", "(${0})", "banana", "b(a)n(a)n(a)"},
	{"a+", "(${0})$0", "banana", "b(a)an(a)an(a)a"},
	{"a+", "(${0})$0", "banana", "b(a)an(a)an(a)a"},
	{"hello, (.+)", "goodbye, ${1}", "hello, world", "goodbye, world"},
	{"hello, (.+)", "goodbye, $1x", "hello, world", "goodbye, "},
	{"hello, (.+)", "goodbye, ${1}x", "hello, world", "goodbye, worldx"},
	{"hello, (.+)", "<$0><$1><$2><$3>", "hello, world", "<hello, world><world><><>"},
	{"hello, (?P<noun>.+)", "goodbye, $noun!", "hello, world", "goodbye, world!"},
	{"hello, (?P<noun>.+)", "goodbye, ${noun}", "hello, world", "goodbye, world"},
	{"(?P<x>hi)|(?P<x>bye)", "$x$x$x", "hi", "hihihi"},
	{"(?P<x>hi)|(?P<x>bye)", "$x$x$x", "bye", "byebyebye"},
	{"(?P<x>hi)|(?P<x>bye)", "$xyz", "hi", ""},
	{"(?P<x>hi)|(?P<x>bye)", "${x}yz", "hi", "hiyz"},
	{"(?P<x>hi)|(?P<x>bye)", "hello $$x", "hi", "hello $x"},
	{"a+", "${oops", "aaa", "${oops"},
	{"a+", "$$", "aaa", "$"},
	{"a+", "$", "aaa", "$"},

	// Substitution when subexpression isn't found
	{"(x)?", "$1", "123", "123"},
	{"abc", "$1", "123", "123"},
}

var replaceLiteralTests = []ReplaceTest{
	// Substitutions
	{"a+", "($0)", "banana", "b($0)n($0)n($0)"},
	{"a+", "(${0})", "banana", "b(${0})n(${0})n(${0})"},
	{"a+", "(${0})$0", "banana", "b(${0})$0n(${0})$0n(${0})$0"},
	{"a+", "(${0})$0", "banana", "b(${0})$0n(${0})$0n(${0})$0"},
	{"hello, (.+)", "goodbye, ${1}", "hello, world", "goodbye, ${1}"},
	{"hello, (?P<noun>.+)", "goodbye, $noun!", "hello, world", "goodbye, $noun!"},
	{"hello, (?P<noun>.+)", "goodbye, ${noun}", "hello, world", "goodbye, ${noun}"},
	{"(?P<x>hi)|(?P<x>bye)", "$x$x$x", "hi", "$x$x$x"},
	{"(?P<x>hi)|(?P<x>bye)", "$x$x$x", "bye", "$x$x$x"},
	{"(?P<x>hi)|(?P<x>bye)", "$xyz", "hi", "$xyz"},
	{"(?P<x>hi)|(?P<x>bye)", "${x}yz", "hi", "${x}yz"},
	{"(?P<x>hi)|(?P<x>bye)", "hello $$x", "hi", "hello $$x"},
	{"a+", "${oops", "aaa", "${oops"},
	{"a+", "$$", "aaa", "$$"},
	{"a+", "$", "aaa", "$"},
}

type ReplaceFuncTest struct {
	pattern       string
	replacement   func(string) string
	input, output string
}

var replaceFuncTests = []ReplaceFuncTest{
	{"[a-c]", func(s string) string { return "x" + s + "y" }, "defabcdef", "defxayxbyxcydef"},
	{"[a-c]+", func(s string) string { return "x" + s + "y" }, "defabcdef", "defxabcydef"},
	{"[a-c]*", func(s string) string { return "x" + s + "y" }, "defabcdef", "xydxyexyfxabcydxyexyfxy"},
}

func TestReplaceAll(t *testing.T) {
	for _, tc := range replaceTests {
		re, err := Compile(tc.pattern)
		if err != nil {
			t.Errorf("Unexpected error compiling %q: %v", tc.pattern, err)
			continue
		}
		actual := re.ReplaceAllString(tc.input, tc.replacement)
		if actual != tc.output {
			t.Errorf("%q.ReplaceAllString(%q,%q) = %q; want %q",
				tc.pattern, tc.input, tc.replacement, actual, tc.output)
		}
		// now try bytes
		actual = string(re.ReplaceAll([]byte(tc.input), []byte(tc.replacement)))
		if actual != tc.output {
			t.Errorf("%q.ReplaceAll(%q,%q) = %q; want %q",
				tc.pattern, tc.input, tc.replacement, actual, tc.output)
		}
	}
}

func TestReplaceAllLiteral(t *testing.T) {
	// Run ReplaceAll tests that do not have $ expansions.
	for _, tc := range replaceTests {
		if strings.Contains(tc.replacement, "$") {
			continue
		}
		re, err := Compile(tc.pattern)
		if err != nil {
			t.Errorf("Unexpected error compiling %q: %v", tc.pattern, err)
			continue
		}
		actual := re.ReplaceAllLiteralString(tc.input, tc.replacement)
		if actual != tc.output {
			t.Errorf("%q.ReplaceAllLiteralString(%q,%q) = %q; want %q",
				tc.pattern, tc.input, tc.replacement, actual, tc.output)
		}
		// now try bytes
		actual = string(re.ReplaceAllLiteral([]byte(tc.input), []byte(tc.replacement)))
		if actual != tc.output {
			t.Errorf("%q.ReplaceAllLiteral(%q,%q) = %q; want %q",
				tc.pattern, tc.input, tc.replacement, actual, tc.output)
		}
	}

	// Run literal-specific tests.
	for _, tc := range replaceLiteralTests {
		re, err := Compile(tc.pattern)
		if err != nil {
			t.Errorf("Unexpected error compiling %q: %v", tc.pattern, err)
			continue
		}
		actual := re.ReplaceAllLiteralString(tc.input, tc.replacement)
		if actual != tc.output {
			t.Errorf("%q.ReplaceAllLiteralString(%q,%q) = %q; want %q",
				tc.pattern, tc.input, tc.replacement, actual, tc.output)
		}
		// now try bytes
		actual = string(re.ReplaceAllLiteral([]byte(tc.input), []byte(tc.replacement)))
		if actual != tc.output {
			t.Errorf("%q.ReplaceAllLiteral(%q,%q) = %q; want %q",
				tc.pattern, tc.input, tc.replacement, actual, tc.output)
		}
	}
}

func TestReplaceAllFunc(t *testing.T) {
	for _, tc := range replaceFuncTests {
		re, err := Compile(tc.pattern)
		if err != nil {
			t.Errorf("Unexpected error compiling %q: %v", tc.pattern, err)
			continue
		}
		actual := re.ReplaceAllStringFunc(tc.input, tc.replacement)
		if actual != tc.output {
			t.Errorf("%q.ReplaceFunc(%q,fn) = %q; want %q",
				tc.pattern, tc.input, actual, tc.output)
		}
		// now try bytes
		actual = string(re.ReplaceAllFunc([]byte(tc.input), func(s []byte) []byte { return []byte(tc.replacement(string(s))) }))
		if actual != tc.output {
			t.Errorf("%q.ReplaceFunc(%q,fn) = %q; want %q",
				tc.pattern, tc.input, actual, tc.output)
		}
	}
}

type MetaTest struct {
	pattern, output, literal string
	isLiteral                bool
}

var metaTests = []MetaTest{
	{``, ``, ``, true},
	{`foo`, `foo`, `foo`, true},
	{`foo\.\$`, `foo\\\.\\\$`, `foo.$`, true}, // has meta but no operator
	{`foo.\$`, `foo\.\\\$`, `foo`, false},     // has escaped operators and real operators
	{`!@#$%^&*()_+-=[{]}\|,<.>/?~`, `!@#\$%\^&\*\(\)_\+-=\[\{\]\}\\\|,<\.>/\?~`, `!@#`, false},
}

func TestQuoteMeta(t *testing.T) {
	for _, tc := range metaTests {
		// Verify that QuoteMeta returns the expected string.
		quoted := QuoteMeta(tc.pattern)
		if quoted != tc.output {
			t.Errorf("QuoteMeta(`%s`) = `%s`; want `%s`",
				tc.pattern, quoted, tc.output)
			continue
		}

		// Verify that the quoted string is in fact treated as expected
		// by Compile -- i.e. that it matches the original, unquoted string.
		if tc.pattern != "" {
			re, err := Compile(quoted)
			if err != nil {
				t.Errorf("Unexpected error compiling QuoteMeta(`%s`): %v", tc.pattern, err)
				continue
			}
			src := "abc" + tc.pattern + "def"
			repl := "xyz"
			replaced := re.ReplaceAllString(src, repl)
			expected := "abcxyzdef"
			if replaced != expected {
				t.Errorf("QuoteMeta(`%s`).Replace(`%s`,`%s`) = `%s`; want `%s`",
					tc.pattern, src, repl, replaced, expected)
			}
		}
	}
}

func TestLiteralPrefix(t *testing.T) {
	for _, tc := range metaTests {
		// Literal method needs to scan the pattern.
		re := MustCompile(tc.pattern)
		str, complete := re.LiteralPrefix()
		if complete != tc.isLiteral {
			t.Errorf("LiteralPrefix(`%s`) = %t; want %t", tc.pattern, complete, tc.isLiteral)
		}
		if str != tc.literal {
			t.Errorf("LiteralPrefix(`%s`) = `%s`; want `%s`", tc.pattern, str, tc.literal)
		}
	}
}

type subexpCase struct {
	input string
	num   int
	names []string
}

var subexpCases = []subexpCase{
	{``, 0, nil},
	{`.*`, 0, nil},
	{`abba`, 0, nil},
	{`ab(b)a`, 1, []string{"", ""}},
	{`ab(.*)a`, 1, []string{"", ""}},
	{`(.*)ab(.*)a`, 2, []string{"", "", ""}},
	{`(.*)(ab)(.*)a`, 3, []string{"", "", "", ""}},
	{`(.*)((a)b)(.*)a`, 4, []string{"", "", "", "", ""}},
	{`(.*)(\(ab)(.*)a`, 3, []string{"", "", "", ""}},
	{`(.*)(\(a\)b)(.*)a`, 3, []string{"", "", "", ""}},
	{`(?P<foo>.*)(?P<bar>(a)b)(?P<foo>.*)a`, 4, []string{"", "foo", "bar", "", "foo"}},
}

func TestSubexp(t *testing.T) {
	for _, c := range subexpCases {
		re := MustCompile(c.input)
		n := re.NumSubexp()
		if n != c.num {
			t.Errorf("%q: NumSubexp = %d, want %d", c.input, n, c.num)
			continue
		}
		names := re.SubexpNames()
		if len(names) != 1+n {
			t.Errorf("%q: len(SubexpNames) = %d, want %d", c.input, len(names), n)
			continue
		}
		if c.names != nil {
			for i := 0; i < 1+n; i++ {
				if names[i] != c.names[i] {
					t.Errorf("%q: SubexpNames[%d] = %q, want %q", c.input, i, names[i], c.names[i])
				}
			}
		}
	}
}

var splitTests = []struct {
	s   string
	r   string
	n   int
	out []string
}{
	{"foo:and:bar", ":", -1, []string{"foo", "and", "bar"}},
	{"foo:and:bar", ":", 1, []string{"foo:and:bar"}},
	{"foo:and:bar", ":", 2, []string{"foo", "and:bar"}},
	{"foo:and:bar", "foo", -1, []string{"", ":and:bar"}},
	{"foo:and:bar", "bar", -1, []string{"foo:and:", ""}},
	{"foo:and:bar", "baz", -1, []string{"foo:and:bar"}},
	{"baabaab", "a", -1, []string{"b", "", "b", "", "b"}},
	{"baabaab", "a*", -1, []string{"b", "b", "b"}},
	{"baabaab", "ba*", -1, []string{"", "", "", ""}},
	{"foobar", "f*b*", -1, []string{"", "o", "o", "a", "r"}},
	{"foobar", "f+.*b+", -1, []string{"", "ar"}},
	{"foobooboar", "o{2}", -1, []string{"f", "b", "boar"}},
	{"a,b,c,d,e,f", ",", 3, []string{"a", "b", "c,d,e,f"}},
	{"a,b,c,d,e,f", ",", 0, nil},
	{",", ",", -1, []string{"", ""}},
	{",,,", ",", -1, []string{"", "", "", ""}},
	{"", ",", -1, []string{""}},
	{"", ".*", -1, []string{""}},
	{"", ".+", -1, []string{""}},
	{"", "", -1, []string{}},
	{"foobar", "", -1, []string{"f", "o", "o", "b", "a", "r"}},
	{"abaabaccadaaae", "a*", 5, []string{"", "b", "b", "c", "cadaaae"}},
	{":x:y:z:", ":", -1, []string{"", "x", "y", "z", ""}},
}

func TestSplit(t *testing.T) {
	for i, test := range splitTests {
		re, err := Compile(test.r)
		if err != nil {
			t.Errorf("#%d: %q: compile error: %s", i, test.r, err.Error())
			continue
		}

		split := re.Split(test.s, test.n)
		if !reflect.DeepEqual(split, test.out) {
			t.Errorf("#%d: %q: got %q; want %q", i, test.r, split, test.out)
		}

		if QuoteMeta(test.r) == test.r {
			strsplit := strings.SplitN(test.s, test.r, test.n)
			if !reflect.DeepEqual(split, strsplit) {
				t.Errorf("#%d: Split(%q, %q, %d): regexp vs strings mismatch\nregexp=%q\nstrings=%q", i, test.s, test.r, test.n, split, strsplit)
			}
		}
	}
}

// Check that one-pass cutoff does trigger.
func TestOnePassCutoff(t *testing.T) {
	re, err := syntax.Parse(`^x{1,1000}y{1,1000}$`, syntax.Perl)
	if err != nil {
		t.Fatalf("parse: %v", err)
	}
	p, err := syntax.Compile(re.Simplify())
	if err != nil {
		t.Fatalf("compile: %v", err)
	}
	if compileOnePass(p) != notOnePass {
		t.Fatalf("makeOnePass succeeded; wanted notOnePass")
	}
}

func BenchmarkLiteral(b *testing.B) {
	x := strings.Repeat("x", 50) + "y"
	b.StopTimer()
	re := MustCompile("y")
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		if !re.MatchString(x) {
			b.Fatalf("no match!")
		}
	}
}

func BenchmarkNotLiteral(b *testing.B) {
	x := strings.Repeat("x", 50) + "y"
	b.StopTimer()
	re := MustCompile(".y")
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		if !re.MatchString(x) {
			b.Fatalf("no match!")
		}
	}
}

func BenchmarkMatchClass(b *testing.B) {
	b.StopTimer()
	x := strings.Repeat("xxxx", 20) + "w"
	re := MustCompile("[abcdw]")
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		if !re.MatchString(x) {
			b.Fatalf("no match!")
		}
	}
}

func BenchmarkMatchClass_InRange(b *testing.B) {
	b.StopTimer()
	// 'b' is between 'a' and 'c', so the charclass
	// range checking is no help here.
	x := strings.Repeat("bbbb", 20) + "c"
	re := MustCompile("[ac]")
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		if !re.MatchString(x) {
			b.Fatalf("no match!")
		}
	}
}

func BenchmarkReplaceAll(b *testing.B) {
	x := "abcdefghijklmnopqrstuvwxyz"
	b.StopTimer()
	re := MustCompile("[cjrw]")
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		re.ReplaceAllString(x, "")
	}
}

func BenchmarkAnchoredLiteralShortNonMatch(b *testing.B) {
	b.StopTimer()
	x := []byte("abcdefghijklmnopqrstuvwxyz")
	re := MustCompile("^zbc(d|e)")
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		re.Match(x)
	}
}

func BenchmarkAnchoredLiteralLongNonMatch(b *testing.B) {
	b.StopTimer()
	x := []byte("abcdefghijklmnopqrstuvwxyz")
	for i := 0; i < 15; i++ {
		x = append(x, x...)
	}
	re := MustCompile("^zbc(d|e)")
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		re.Match(x)
	}
}

func BenchmarkAnchoredShortMatch(b *testing.B) {
	b.StopTimer()
	x := []byte("abcdefghijklmnopqrstuvwxyz")
	re := MustCompile("^.bc(d|e)")
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		re.Match(x)
	}
}

func BenchmarkAnchoredLongMatch(b *testing.B) {
	b.StopTimer()
	x := []byte("abcdefghijklmnopqrstuvwxyz")
	for i := 0; i < 15; i++ {
		x = append(x, x...)
	}
	re := MustCompile("^.bc(d|e)")
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		re.Match(x)
	}
}

func BenchmarkOnePassShortA(b *testing.B) {
	b.StopTimer()
	x := []byte("abcddddddeeeededd")
	re := MustCompile("^.bc(d|e)*$")
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		re.Match(x)
	}
}

func BenchmarkNotOnePassShortA(b *testing.B) {
	b.StopTimer()
	x := []byte("abcddddddeeeededd")
	re := MustCompile(".bc(d|e)*$")
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		re.Match(x)
	}
}

func BenchmarkOnePassShortB(b *testing.B) {
	b.StopTimer()
	x := []byte("abcddddddeeeededd")
	re := MustCompile("^.bc(?:d|e)*$")
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		re.Match(x)
	}
}

func BenchmarkNotOnePassShortB(b *testing.B) {
	b.StopTimer()
	x := []byte("abcddddddeeeededd")
	re := MustCompile(".bc(?:d|e)*$")
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		re.Match(x)
	}
}

func BenchmarkOnePassLongPrefix(b *testing.B) {
	b.StopTimer()
	x := []byte("abcdefghijklmnopqrstuvwxyz")
	re := MustCompile("^abcdefghijklmnopqrstuvwxyz.*$")
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		re.Match(x)
	}
}

func BenchmarkOnePassLongNotPrefix(b *testing.B) {
	b.StopTimer()
	x := []byte("abcdefghijklmnopqrstuvwxyz")
	re := MustCompile("^.bcdefghijklmnopqrstuvwxyz.*$")
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		re.Match(x)
	}
}
                                                                                                                                                         root/go1.4/src/regexp/example_test.go                                                               0100644 0000000 0000000 00000007714 12600426227 016174  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package regexp_test

import (
	"fmt"
	"regexp"
)

func Example() {
	// Compile the expression once, usually at init time.
	// Use raw strings to avoid having to quote the backslashes.
	var validID = regexp.MustCompile(`^[a-z]+\[[0-9]+\]$`)

	fmt.Println(validID.MatchString("adam[23]"))
	fmt.Println(validID.MatchString("eve[7]"))
	fmt.Println(validID.MatchString("Job[48]"))
	fmt.Println(validID.MatchString("snakey"))
	// Output:
	// true
	// true
	// false
	// false
}

func ExampleMatchString() {
	matched, err := regexp.MatchString("foo.*", "seafood")
	fmt.Println(matched, err)
	matched, err = regexp.MatchString("bar.*", "seafood")
	fmt.Println(matched, err)
	matched, err = regexp.MatchString("a(b", "seafood")
	fmt.Println(matched, err)
	// Output:
	// true <nil>
	// false <nil>
	// false error parsing regexp: missing closing ): `a(b`
}

func ExampleRegexp_FindString() {
	re := regexp.MustCompile("fo.?")
	fmt.Printf("%q\n", re.FindString("seafood"))
	fmt.Printf("%q\n", re.FindString("meat"))
	// Output:
	// "foo"
	// ""
}

func ExampleRegexp_FindStringIndex() {
	re := regexp.MustCompile("ab?")
	fmt.Println(re.FindStringIndex("tablett"))
	fmt.Println(re.FindStringIndex("foo") == nil)
	// Output:
	// [1 3]
	// true
}

func ExampleRegexp_FindStringSubmatch() {
	re := regexp.MustCompile("a(x*)b(y|z)c")
	fmt.Printf("%q\n", re.FindStringSubmatch("-axxxbyc-"))
	fmt.Printf("%q\n", re.FindStringSubmatch("-abzc-"))
	// Output:
	// ["axxxbyc" "xxx" "y"]
	// ["abzc" "" "z"]
}

func ExampleRegexp_FindAllString() {
	re := regexp.MustCompile("a.")
	fmt.Println(re.FindAllString("paranormal", -1))
	fmt.Println(re.FindAllString("paranormal", 2))
	fmt.Println(re.FindAllString("graal", -1))
	fmt.Println(re.FindAllString("none", -1))
	// Output:
	// [ar an al]
	// [ar an]
	// [aa]
	// []
}

func ExampleRegexp_FindAllStringSubmatch() {
	re := regexp.MustCompile("a(x*)b")
	fmt.Printf("%q\n", re.FindAllStringSubmatch("-ab-", -1))
	fmt.Printf("%q\n", re.FindAllStringSubmatch("-axxb-", -1))
	fmt.Printf("%q\n", re.FindAllStringSubmatch("-ab-axb-", -1))
	fmt.Printf("%q\n", re.FindAllStringSubmatch("-axxb-ab-", -1))
	// Output:
	// [["ab" ""]]
	// [["axxb" "xx"]]
	// [["ab" ""] ["axb" "x"]]
	// [["axxb" "xx"] ["ab" ""]]
}

func ExampleRegexp_FindAllStringSubmatchIndex() {
	re := regexp.MustCompile("a(x*)b")
	// Indices:
	//    01234567   012345678
	//    -ab-axb-   -axxb-ab-
	fmt.Println(re.FindAllStringSubmatchIndex("-ab-", -1))
	fmt.Println(re.FindAllStringSubmatchIndex("-axxb-", -1))
	fmt.Println(re.FindAllStringSubmatchIndex("-ab-axb-", -1))
	fmt.Println(re.FindAllStringSubmatchIndex("-axxb-ab-", -1))
	fmt.Println(re.FindAllStringSubmatchIndex("-foo-", -1))
	// Output:
	// [[1 3 2 2]]
	// [[1 5 2 4]]
	// [[1 3 2 2] [4 7 5 6]]
	// [[1 5 2 4] [6 8 7 7]]
	// []
}

func ExampleRegexp_ReplaceAllLiteralString() {
	re := regexp.MustCompile("a(x*)b")
	fmt.Println(re.ReplaceAllLiteralString("-ab-axxb-", "T"))
	fmt.Println(re.ReplaceAllLiteralString("-ab-axxb-", "$1"))
	fmt.Println(re.ReplaceAllLiteralString("-ab-axxb-", "${1}"))
	// Output:
	// -T-T-
	// -$1-$1-
	// -${1}-${1}-
}

func ExampleRegexp_ReplaceAllString() {
	re := regexp.MustCompile("a(x*)b")
	fmt.Println(re.ReplaceAllString("-ab-axxb-", "T"))
	fmt.Println(re.ReplaceAllString("-ab-axxb-", "$1"))
	fmt.Println(re.ReplaceAllString("-ab-axxb-", "$1W"))
	fmt.Println(re.ReplaceAllString("-ab-axxb-", "${1}W"))
	// Output:
	// -T-T-
	// --xx-
	// ---
	// -W-xxW-
}

func ExampleRegexp_SubexpNames() {
	re := regexp.MustCompile("(?P<first>[a-zA-Z]+) (?P<last>[a-zA-Z]+)")
	fmt.Println(re.MatchString("Alan Turing"))
	fmt.Printf("%q\n", re.SubexpNames())
	reversed := fmt.Sprintf("${%s} ${%s}", re.SubexpNames()[2], re.SubexpNames()[1])
	fmt.Println(reversed)
	fmt.Println(re.ReplaceAllString("Alan Turing", reversed))
	// Output:
	// true
	// ["" "first" "last"]
	// ${last} ${first}
	// Turing Alan
}
                                                    root/go1.4/src/regexp/exec.go                                                                       0100644 0000000 0000000 00000025237 12600426227 014426  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package regexp

import (
	"io"
	"regexp/syntax"
)

// A queue is a 'sparse array' holding pending threads of execution.
// See http://research.swtch.com/2008/03/using-uninitialized-memory-for-fun-and.html
type queue struct {
	sparse []uint32
	dense  []entry
}

// A entry is an entry on a queue.
// It holds both the instruction pc and the actual thread.
// Some queue entries are just place holders so that the machine
// knows it has considered that pc.  Such entries have t == nil.
type entry struct {
	pc uint32
	t  *thread
}

// A thread is the state of a single path through the machine:
// an instruction and a corresponding capture array.
// See http://swtch.com/~rsc/regexp/regexp2.html
type thread struct {
	inst *syntax.Inst
	cap  []int
}

// A machine holds all the state during an NFA simulation for p.
type machine struct {
	re       *Regexp      // corresponding Regexp
	p        *syntax.Prog // compiled program
	op       *onePassProg // compiled onepass program, or notOnePass
	q0, q1   queue        // two queues for runq, nextq
	pool     []*thread    // pool of available threads
	matched  bool         // whether a match was found
	matchcap []int        // capture information for the match

	// cached inputs, to avoid allocation
	inputBytes  inputBytes
	inputString inputString
	inputReader inputReader
}

func (m *machine) newInputBytes(b []byte) input {
	m.inputBytes.str = b
	return &m.inputBytes
}

func (m *machine) newInputString(s string) input {
	m.inputString.str = s
	return &m.inputString
}

func (m *machine) newInputReader(r io.RuneReader) input {
	m.inputReader.r = r
	m.inputReader.atEOT = false
	m.inputReader.pos = 0
	return &m.inputReader
}

// progMachine returns a new machine running the prog p.
func progMachine(p *syntax.Prog, op *onePassProg) *machine {
	m := &machine{p: p, op: op}
	n := len(m.p.Inst)
	m.q0 = queue{make([]uint32, n), make([]entry, 0, n)}
	m.q1 = queue{make([]uint32, n), make([]entry, 0, n)}
	ncap := p.NumCap
	if ncap < 2 {
		ncap = 2
	}
	m.matchcap = make([]int, ncap)
	return m
}

func (m *machine) init(ncap int) {
	for _, t := range m.pool {
		t.cap = t.cap[:ncap]
	}
	m.matchcap = m.matchcap[:ncap]
}

// alloc allocates a new thread with the given instruction.
// It uses the free pool if possible.
func (m *machine) alloc(i *syntax.Inst) *thread {
	var t *thread
	if n := len(m.pool); n > 0 {
		t = m.pool[n-1]
		m.pool = m.pool[:n-1]
	} else {
		t = new(thread)
		t.cap = make([]int, len(m.matchcap), cap(m.matchcap))
	}
	t.inst = i
	return t
}

// free returns t to the free pool.
func (m *machine) free(t *thread) {
	m.inputBytes.str = nil
	m.inputString.str = ""
	m.inputReader.r = nil
	m.pool = append(m.pool, t)
}

// match runs the machine over the input starting at pos.
// It reports whether a match was found.
// If so, m.matchcap holds the submatch information.
func (m *machine) match(i input, pos int) bool {
	startCond := m.re.cond
	if startCond == ^syntax.EmptyOp(0) { // impossible
		return false
	}
	m.matched = false
	for i := range m.matchcap {
		m.matchcap[i] = -1
	}
	runq, nextq := &m.q0, &m.q1
	r, r1 := endOfText, endOfText
	width, width1 := 0, 0
	r, width = i.step(pos)
	if r != endOfText {
		r1, width1 = i.step(pos + width)
	}
	var flag syntax.EmptyOp
	if pos == 0 {
		flag = syntax.EmptyOpContext(-1, r)
	} else {
		flag = i.context(pos)
	}
	for {
		if len(runq.dense) == 0 {
			if startCond&syntax.EmptyBeginText != 0 && pos != 0 {
				// Anchored match, past beginning of text.
				break
			}
			if m.matched {
				// Have match; finished exploring alternatives.
				break
			}
			if len(m.re.prefix) > 0 && r1 != m.re.prefixRune && i.canCheckPrefix() {
				// Match requires literal prefix; fast search for it.
				advance := i.index(m.re, pos)
				if advance < 0 {
					break
				}
				pos += advance
				r, width = i.step(pos)
				r1, width1 = i.step(pos + width)
			}
		}
		if !m.matched {
			if len(m.matchcap) > 0 {
				m.matchcap[0] = pos
			}
			m.add(runq, uint32(m.p.Start), pos, m.matchcap, flag, nil)
		}
		flag = syntax.EmptyOpContext(r, r1)
		m.step(runq, nextq, pos, pos+width, r, flag)
		if width == 0 {
			break
		}
		if len(m.matchcap) == 0 && m.matched {
			// Found a match and not paying attention
			// to where it is, so any match will do.
			break
		}
		pos += width
		r, width = r1, width1
		if r != endOfText {
			r1, width1 = i.step(pos + width)
		}
		runq, nextq = nextq, runq
	}
	m.clear(nextq)
	return m.matched
}

// clear frees all threads on the thread queue.
func (m *machine) clear(q *queue) {
	for _, d := range q.dense {
		if d.t != nil {
			// m.free(d.t)
			m.pool = append(m.pool, d.t)
		}
	}
	q.dense = q.dense[:0]
}

// step executes one step of the machine, running each of the threads
// on runq and appending new threads to nextq.
// The step processes the rune c (which may be endOfText),
// which starts at position pos and ends at nextPos.
// nextCond gives the setting for the empty-width flags after c.
func (m *machine) step(runq, nextq *queue, pos, nextPos int, c rune, nextCond syntax.EmptyOp) {
	longest := m.re.longest
	for j := 0; j < len(runq.dense); j++ {
		d := &runq.dense[j]
		t := d.t
		if t == nil {
			continue
		}
		if longest && m.matched && len(t.cap) > 0 && m.matchcap[0] < t.cap[0] {
			// m.free(t)
			m.pool = append(m.pool, t)
			continue
		}
		i := t.inst
		add := false
		switch i.Op {
		default:
			panic("bad inst")

		case syntax.InstMatch:
			if len(t.cap) > 0 && (!longest || !m.matched || m.matchcap[1] < pos) {
				t.cap[1] = pos
				copy(m.matchcap, t.cap)
			}
			if !longest {
				// First-match mode: cut off all lower-priority threads.
				for _, d := range runq.dense[j+1:] {
					if d.t != nil {
						// m.free(d.t)
						m.pool = append(m.pool, d.t)
					}
				}
				runq.dense = runq.dense[:0]
			}
			m.matched = true

		case syntax.InstRune:
			add = i.MatchRune(c)
		case syntax.InstRune1:
			add = c == i.Rune[0]
		case syntax.InstRuneAny:
			add = true
		case syntax.InstRuneAnyNotNL:
			add = c != '\n'
		}
		if add {
			t = m.add(nextq, i.Out, nextPos, t.cap, nextCond, t)
		}
		if t != nil {
			// m.free(t)
			m.pool = append(m.pool, t)
		}
	}
	runq.dense = runq.dense[:0]
}

// add adds an entry to q for pc, unless the q already has such an entry.
// It also recursively adds an entry for all instructions reachable from pc by following
// empty-width conditions satisfied by cond.  pos gives the current position
// in the input.
func (m *machine) add(q *queue, pc uint32, pos int, cap []int, cond syntax.EmptyOp, t *thread) *thread {
	if pc == 0 {
		return t
	}
	if j := q.sparse[pc]; j < uint32(len(q.dense)) && q.dense[j].pc == pc {
		return t
	}

	j := len(q.dense)
	q.dense = q.dense[:j+1]
	d := &q.dense[j]
	d.t = nil
	d.pc = pc
	q.sparse[pc] = uint32(j)

	i := &m.p.Inst[pc]
	switch i.Op {
	default:
		panic("unhandled")
	case syntax.InstFail:
		// nothing
	case syntax.InstAlt, syntax.InstAltMatch:
		t = m.add(q, i.Out, pos, cap, cond, t)
		t = m.add(q, i.Arg, pos, cap, cond, t)
	case syntax.InstEmptyWidth:
		if syntax.EmptyOp(i.Arg)&^cond == 0 {
			t = m.add(q, i.Out, pos, cap, cond, t)
		}
	case syntax.InstNop:
		t = m.add(q, i.Out, pos, cap, cond, t)
	case syntax.InstCapture:
		if int(i.Arg) < len(cap) {
			opos := cap[i.Arg]
			cap[i.Arg] = pos
			m.add(q, i.Out, pos, cap, cond, nil)
			cap[i.Arg] = opos
		} else {
			t = m.add(q, i.Out, pos, cap, cond, t)
		}
	case syntax.InstMatch, syntax.InstRune, syntax.InstRune1, syntax.InstRuneAny, syntax.InstRuneAnyNotNL:
		if t == nil {
			t = m.alloc(i)
		} else {
			t.inst = i
		}
		if len(cap) > 0 && &t.cap[0] != &cap[0] {
			copy(t.cap, cap)
		}
		d.t = t
		t = nil
	}
	return t
}

// onepass runs the machine over the input starting at pos.
// It reports whether a match was found.
// If so, m.matchcap holds the submatch information.
func (m *machine) onepass(i input, pos int) bool {
	startCond := m.re.cond
	if startCond == ^syntax.EmptyOp(0) { // impossible
		return false
	}
	m.matched = false
	for i := range m.matchcap {
		m.matchcap[i] = -1
	}
	r, r1 := endOfText, endOfText
	width, width1 := 0, 0
	r, width = i.step(pos)
	if r != endOfText {
		r1, width1 = i.step(pos + width)
	}
	var flag syntax.EmptyOp
	if pos == 0 {
		flag = syntax.EmptyOpContext(-1, r)
	} else {
		flag = i.context(pos)
	}
	pc := m.op.Start
	inst := m.op.Inst[pc]
	// If there is a simple literal prefix, skip over it.
	if pos == 0 && syntax.EmptyOp(inst.Arg)&^flag == 0 &&
		len(m.re.prefix) > 0 && i.canCheckPrefix() {
		// Match requires literal prefix; fast search for it.
		if i.hasPrefix(m.re) {
			pos += len(m.re.prefix)
			r, width = i.step(pos)
			r1, width1 = i.step(pos + width)
			flag = i.context(pos)
			pc = int(m.re.prefixEnd)
		} else {
			return m.matched
		}
	}
	for {
		inst = m.op.Inst[pc]
		pc = int(inst.Out)
		switch inst.Op {
		default:
			panic("bad inst")
		case syntax.InstMatch:
			m.matched = true
			if len(m.matchcap) > 0 {
				m.matchcap[0] = 0
				m.matchcap[1] = pos
			}
			return m.matched
		case syntax.InstRune:
			if !inst.MatchRune(r) {
				return m.matched
			}
		case syntax.InstRune1:
			if r != inst.Rune[0] {
				return m.matched
			}
		case syntax.InstRuneAny:
			// Nothing
		case syntax.InstRuneAnyNotNL:
			if r == '\n' {
				return m.matched
			}
		// peek at the input rune to see which branch of the Alt to take
		case syntax.InstAlt, syntax.InstAltMatch:
			pc = int(onePassNext(&inst, r))
			continue
		case syntax.InstFail:
			return m.matched
		case syntax.InstNop:
			continue
		case syntax.InstEmptyWidth:
			if syntax.EmptyOp(inst.Arg)&^flag != 0 {
				return m.matched
			}
			continue
		case syntax.InstCapture:
			if int(inst.Arg) < len(m.matchcap) {
				m.matchcap[inst.Arg] = pos
			}
			continue
		}
		if width == 0 {
			break
		}
		flag = syntax.EmptyOpContext(r, r1)
		pos += width
		r, width = r1, width1
		if r != endOfText {
			r1, width1 = i.step(pos + width)
		}
	}
	return m.matched
}

// empty is a non-nil 0-element slice,
// so doExecute can avoid an allocation
// when 0 captures are requested from a successful match.
var empty = make([]int, 0)

// doExecute finds the leftmost match in the input and returns
// the position of its subexpressions.
func (re *Regexp) doExecute(r io.RuneReader, b []byte, s string, pos int, ncap int) []int {
	m := re.get()
	var i input
	if r != nil {
		i = m.newInputReader(r)
	} else if b != nil {
		i = m.newInputBytes(b)
	} else {
		i = m.newInputString(s)
	}
	if m.op != notOnePass {
		if !m.onepass(i, pos) {
			re.put(m)
			return nil
		}
	} else {
		m.init(ncap)
		if !m.match(i, pos) {
			re.put(m)
			return nil
		}
	}
	if ncap == 0 {
		re.put(m)
		return empty // empty but not nil
	}
	cap := make([]int, len(m.matchcap))
	copy(cap, m.matchcap)
	re.put(m)
	return cap
}
                                                                                                                                                                                                                                                                                                                                                                 root/go1.4/src/regexp/exec2_test.go                                                                 0100644 0000000 0000000 00000000773 12600426227 015545  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !race

package regexp

import (
	"testing"
)

// This test is excluded when running under the race detector because
// it is a very expensive test and takes too long.
func TestRE2Exhaustive(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping TestRE2Exhaustive during short test")
	}
	testRE2(t, "testdata/re2-exhaustive.txt.bz2")
}
     root/go1.4/src/regexp/exec_test.go                                                                  0100644 0000000 0000000 00000047620 12600426227 015465  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package regexp

import (
	"bufio"
	"compress/bzip2"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"regexp/syntax"
	"strconv"
	"strings"
	"testing"
	"unicode/utf8"
)

// TestRE2 tests this package's regexp API against test cases
// considered during RE2's exhaustive tests, which run all possible
// regexps over a given set of atoms and operators, up to a given
// complexity, over all possible strings over a given alphabet,
// up to a given size.  Rather than try to link with RE2, we read a
// log file containing the test cases and the expected matches.
// The log file, re2.txt, is generated by running 'make exhaustive-log'
// in the open source RE2 distribution.  http://code.google.com/p/re2/
//
// The test file format is a sequence of stanzas like:
//
//	strings
//	"abc"
//	"123x"
//	regexps
//	"[a-z]+"
//	0-3;0-3
//	-;-
//	"([0-9])([0-9])([0-9])"
//	-;-
//	-;0-3 0-1 1-2 2-3
//
// The stanza begins by defining a set of strings, quoted
// using Go double-quote syntax, one per line.  Then the
// regexps section gives a sequence of regexps to run on
// the strings.  In the block that follows a regexp, each line
// gives the semicolon-separated match results of running
// the regexp on the corresponding string.
// Each match result is either a single -, meaning no match, or a
// space-separated sequence of pairs giving the match and
// submatch indices.  An unmatched subexpression formats
// its pair as a single - (not illustrated above).  For now
// each regexp run produces two match results, one for a
// ``full match'' that restricts the regexp to matching the entire
// string or nothing, and one for a ``partial match'' that gives
// the leftmost first match found in the string.
//
// Lines beginning with # are comments.  Lines beginning with
// a capital letter are test names printed during RE2's test suite
// and are echoed into t but otherwise ignored.
//
// At time of writing, re2.txt is 32 MB but compresses to 760 kB,
// so we store re2.txt.gz in the repository and decompress it on the fly.
//
func TestRE2Search(t *testing.T) {
	testRE2(t, "testdata/re2-search.txt")
}

func testRE2(t *testing.T, file string) {
	f, err := os.Open(file)
	if err != nil {
		t.Fatal(err)
	}
	defer f.Close()
	var txt io.Reader
	if strings.HasSuffix(file, ".bz2") {
		z := bzip2.NewReader(f)
		txt = z
		file = file[:len(file)-len(".bz2")] // for error messages
	} else {
		txt = f
	}
	lineno := 0
	scanner := bufio.NewScanner(txt)
	var (
		str       []string
		input     []string
		inStrings bool
		re        *Regexp
		refull    *Regexp
		nfail     int
		ncase     int
	)
	for lineno := 1; scanner.Scan(); lineno++ {
		line := scanner.Text()
		switch {
		case line == "":
			t.Fatalf("%s:%d: unexpected blank line", file, lineno)
		case line[0] == '#':
			continue
		case 'A' <= line[0] && line[0] <= 'Z':
			// Test name.
			t.Logf("%s\n", line)
			continue
		case line == "strings":
			str = str[:0]
			inStrings = true
		case line == "regexps":
			inStrings = false
		case line[0] == '"':
			q, err := strconv.Unquote(line)
			if err != nil {
				// Fatal because we'll get out of sync.
				t.Fatalf("%s:%d: unquote %s: %v", file, lineno, line, err)
			}
			if inStrings {
				str = append(str, q)
				continue
			}
			// Is a regexp.
			if len(input) != 0 {
				t.Fatalf("%s:%d: out of sync: have %d strings left before %#q", file, lineno, len(input), q)
			}
			re, err = tryCompile(q)
			if err != nil {
				if err.Error() == "error parsing regexp: invalid escape sequence: `\\C`" {
					// We don't and likely never will support \C; keep going.
					continue
				}
				t.Errorf("%s:%d: compile %#q: %v", file, lineno, q, err)
				if nfail++; nfail >= 100 {
					t.Fatalf("stopping after %d errors", nfail)
				}
				continue
			}
			full := `\A(?:` + q + `)\z`
			refull, err = tryCompile(full)
			if err != nil {
				// Fatal because q worked, so this should always work.
				t.Fatalf("%s:%d: compile full %#q: %v", file, lineno, full, err)
			}
			input = str
		case line[0] == '-' || '0' <= line[0] && line[0] <= '9':
			// A sequence of match results.
			ncase++
			if re == nil {
				// Failed to compile: skip results.
				continue
			}
			if len(input) == 0 {
				t.Fatalf("%s:%d: out of sync: no input remaining", file, lineno)
			}
			var text string
			text, input = input[0], input[1:]
			if !isSingleBytes(text) && strings.Contains(re.String(), `\B`) {
				// RE2's \B considers every byte position,
				// so it sees 'not word boundary' in the
				// middle of UTF-8 sequences.  This package
				// only considers the positions between runes,
				// so it disagrees.  Skip those cases.
				continue
			}
			res := strings.Split(line, ";")
			if len(res) != len(run) {
				t.Fatalf("%s:%d: have %d test results, want %d", file, lineno, len(res), len(run))
			}
			for i := range res {
				have, suffix := run[i](re, refull, text)
				want := parseResult(t, file, lineno, res[i])
				if !same(have, want) {
					t.Errorf("%s:%d: %#q%s.FindSubmatchIndex(%#q) = %v, want %v", file, lineno, re, suffix, text, have, want)
					if nfail++; nfail >= 100 {
						t.Fatalf("stopping after %d errors", nfail)
					}
					continue
				}
				b, suffix := match[i](re, refull, text)
				if b != (want != nil) {
					t.Errorf("%s:%d: %#q%s.MatchString(%#q) = %v, want %v", file, lineno, re, suffix, text, b, !b)
					if nfail++; nfail >= 100 {
						t.Fatalf("stopping after %d errors", nfail)
					}
					continue
				}
			}

		default:
			t.Fatalf("%s:%d: out of sync: %s\n", file, lineno, line)
		}
	}
	if err := scanner.Err(); err != nil {
		t.Fatalf("%s:%d: %v", file, lineno, err)
	}
	if len(input) != 0 {
		t.Fatalf("%s:%d: out of sync: have %d strings left at EOF", file, lineno, len(input))
	}
	t.Logf("%d cases tested", ncase)
}

var run = []func(*Regexp, *Regexp, string) ([]int, string){
	runFull,
	runPartial,
	runFullLongest,
	runPartialLongest,
}

func runFull(re, refull *Regexp, text string) ([]int, string) {
	refull.longest = false
	return refull.FindStringSubmatchIndex(text), "[full]"
}

func runPartial(re, refull *Regexp, text string) ([]int, string) {
	re.longest = false
	return re.FindStringSubmatchIndex(text), ""
}

func runFullLongest(re, refull *Regexp, text string) ([]int, string) {
	refull.longest = true
	return refull.FindStringSubmatchIndex(text), "[full,longest]"
}

func runPartialLongest(re, refull *Regexp, text string) ([]int, string) {
	re.longest = true
	return re.FindStringSubmatchIndex(text), "[longest]"
}

var match = []func(*Regexp, *Regexp, string) (bool, string){
	matchFull,
	matchPartial,
	matchFullLongest,
	matchPartialLongest,
}

func matchFull(re, refull *Regexp, text string) (bool, string) {
	refull.longest = false
	return refull.MatchString(text), "[full]"
}

func matchPartial(re, refull *Regexp, text string) (bool, string) {
	re.longest = false
	return re.MatchString(text), ""
}

func matchFullLongest(re, refull *Regexp, text string) (bool, string) {
	refull.longest = true
	return refull.MatchString(text), "[full,longest]"
}

func matchPartialLongest(re, refull *Regexp, text string) (bool, string) {
	re.longest = true
	return re.MatchString(text), "[longest]"
}

func isSingleBytes(s string) bool {
	for _, c := range s {
		if c >= utf8.RuneSelf {
			return false
		}
	}
	return true
}

func tryCompile(s string) (re *Regexp, err error) {
	// Protect against panic during Compile.
	defer func() {
		if r := recover(); r != nil {
			err = fmt.Errorf("panic: %v", r)
		}
	}()
	return Compile(s)
}

func parseResult(t *testing.T, file string, lineno int, res string) []int {
	// A single - indicates no match.
	if res == "-" {
		return nil
	}
	// Otherwise, a space-separated list of pairs.
	n := 1
	for j := 0; j < len(res); j++ {
		if res[j] == ' ' {
			n++
		}
	}
	out := make([]int, 2*n)
	i := 0
	n = 0
	for j := 0; j <= len(res); j++ {
		if j == len(res) || res[j] == ' ' {
			// Process a single pair.  - means no submatch.
			pair := res[i:j]
			if pair == "-" {
				out[n] = -1
				out[n+1] = -1
			} else {
				k := strings.Index(pair, "-")
				if k < 0 {
					t.Fatalf("%s:%d: invalid pair %s", file, lineno, pair)
				}
				lo, err1 := strconv.Atoi(pair[:k])
				hi, err2 := strconv.Atoi(pair[k+1:])
				if err1 != nil || err2 != nil || lo > hi {
					t.Fatalf("%s:%d: invalid pair %s", file, lineno, pair)
				}
				out[n] = lo
				out[n+1] = hi
			}
			n += 2
			i = j + 1
		}
	}
	return out
}

func same(x, y []int) bool {
	if len(x) != len(y) {
		return false
	}
	for i, xi := range x {
		if xi != y[i] {
			return false
		}
	}
	return true
}

// TestFowler runs this package's regexp API against the
// POSIX regular expression tests collected by Glenn Fowler
// at http://www2.research.att.com/~gsf/testregex/.
func TestFowler(t *testing.T) {
	files, err := filepath.Glob("testdata/*.dat")
	if err != nil {
		t.Fatal(err)
	}
	for _, file := range files {
		t.Log(file)
		testFowler(t, file)
	}
}

var notab = MustCompilePOSIX(`[^\t]+`)

func testFowler(t *testing.T, file string) {
	f, err := os.Open(file)
	if err != nil {
		t.Error(err)
		return
	}
	defer f.Close()
	b := bufio.NewReader(f)
	lineno := 0
	lastRegexp := ""
Reading:
	for {
		lineno++
		line, err := b.ReadString('\n')
		if err != nil {
			if err != io.EOF {
				t.Errorf("%s:%d: %v", file, lineno, err)
			}
			break Reading
		}

		// http://www2.research.att.com/~gsf/man/man1/testregex.html
		//
		// INPUT FORMAT
		//   Input lines may be blank, a comment beginning with #, or a test
		//   specification. A specification is five fields separated by one
		//   or more tabs. NULL denotes the empty string and NIL denotes the
		//   0 pointer.
		if line[0] == '#' || line[0] == '\n' {
			continue Reading
		}
		line = line[:len(line)-1]
		field := notab.FindAllString(line, -1)
		for i, f := range field {
			if f == "NULL" {
				field[i] = ""
			}
			if f == "NIL" {
				t.Logf("%s:%d: skip: %s", file, lineno, line)
				continue Reading
			}
		}
		if len(field) == 0 {
			continue Reading
		}

		//   Field 1: the regex(3) flags to apply, one character per REG_feature
		//   flag. The test is skipped if REG_feature is not supported by the
		//   implementation. If the first character is not [BEASKLP] then the
		//   specification is a global control line. One or more of [BEASKLP] may be
		//   specified; the test will be repeated for each mode.
		//
		//     B 	basic			BRE	(grep, ed, sed)
		//     E 	REG_EXTENDED		ERE	(egrep)
		//     A	REG_AUGMENTED		ARE	(egrep with negation)
		//     S	REG_SHELL		SRE	(sh glob)
		//     K	REG_SHELL|REG_AUGMENTED	KRE	(ksh glob)
		//     L	REG_LITERAL		LRE	(fgrep)
		//
		//     a	REG_LEFT|REG_RIGHT	implicit ^...$
		//     b	REG_NOTBOL		lhs does not match ^
		//     c	REG_COMMENT		ignore space and #...\n
		//     d	REG_SHELL_DOT		explicit leading . match
		//     e	REG_NOTEOL		rhs does not match $
		//     f	REG_MULTIPLE		multiple \n separated patterns
		//     g	FNM_LEADING_DIR		testfnmatch only -- match until /
		//     h	REG_MULTIREF		multiple digit backref
		//     i	REG_ICASE		ignore case
		//     j	REG_SPAN		. matches \n
		//     k	REG_ESCAPE		\ to ecape [...] delimiter
		//     l	REG_LEFT		implicit ^...
		//     m	REG_MINIMAL		minimal match
		//     n	REG_NEWLINE		explicit \n match
		//     o	REG_ENCLOSED		(|&) magic inside [@|&](...)
		//     p	REG_SHELL_PATH		explicit / match
		//     q	REG_DELIMITED		delimited pattern
		//     r	REG_RIGHT		implicit ...$
		//     s	REG_SHELL_ESCAPED	\ not special
		//     t	REG_MUSTDELIM		all delimiters must be specified
		//     u	standard unspecified behavior -- errors not counted
		//     v	REG_CLASS_ESCAPE	\ special inside [...]
		//     w	REG_NOSUB		no subexpression match array
		//     x	REG_LENIENT		let some errors slide
		//     y	REG_LEFT		regexec() implicit ^...
		//     z	REG_NULL		NULL subexpressions ok
		//     $	                        expand C \c escapes in fields 2 and 3
		//     /	                        field 2 is a regsubcomp() expression
		//     =	                        field 3 is a regdecomp() expression
		//
		//   Field 1 control lines:
		//
		//     C		set LC_COLLATE and LC_CTYPE to locale in field 2
		//
		//     ?test ...	output field 5 if passed and != EXPECTED, silent otherwise
		//     &test ...	output field 5 if current and previous passed
		//     |test ...	output field 5 if current passed and previous failed
		//     ; ...	output field 2 if previous failed
		//     {test ...	skip if failed until }
		//     }		end of skip
		//
		//     : comment		comment copied as output NOTE
		//     :comment:test	:comment: ignored
		//     N[OTE] comment	comment copied as output NOTE
		//     T[EST] comment	comment
		//
		//     number		use number for nmatch (20 by default)
		flag := field[0]
		switch flag[0] {
		case '?', '&', '|', ';', '{', '}':
			// Ignore all the control operators.
			// Just run everything.
			flag = flag[1:]
			if flag == "" {
				continue Reading
			}
		case ':':
			i := strings.Index(flag[1:], ":")
			if i < 0 {
				t.Logf("skip: %s", line)
				continue Reading
			}
			flag = flag[1+i+1:]
		case 'C', 'N', 'T', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
			t.Logf("skip: %s", line)
			continue Reading
		}

		// Can check field count now that we've handled the myriad comment formats.
		if len(field) < 4 {
			t.Errorf("%s:%d: too few fields: %s", file, lineno, line)
			continue Reading
		}

		// Expand C escapes (a.k.a. Go escapes).
		if strings.Contains(flag, "$") {
			f := `"` + field[1] + `"`
			if field[1], err = strconv.Unquote(f); err != nil {
				t.Errorf("%s:%d: cannot unquote %s", file, lineno, f)
			}
			f = `"` + field[2] + `"`
			if field[2], err = strconv.Unquote(f); err != nil {
				t.Errorf("%s:%d: cannot unquote %s", file, lineno, f)
			}
		}

		//   Field 2: the regular expression pattern; SAME uses the pattern from
		//     the previous specification.
		//
		if field[1] == "SAME" {
			field[1] = lastRegexp
		}
		lastRegexp = field[1]

		//   Field 3: the string to match.
		text := field[2]

		//   Field 4: the test outcome...
		ok, shouldCompile, shouldMatch, pos := parseFowlerResult(field[3])
		if !ok {
			t.Errorf("%s:%d: cannot parse result %#q", file, lineno, field[3])
			continue Reading
		}

		//   Field 5: optional comment appended to the report.

	Testing:
		// Run test once for each specified capital letter mode that we support.
		for _, c := range flag {
			pattern := field[1]
			syn := syntax.POSIX | syntax.ClassNL
			switch c {
			default:
				continue Testing
			case 'E':
				// extended regexp (what we support)
			case 'L':
				// literal
				pattern = QuoteMeta(pattern)
			}

			for _, c := range flag {
				switch c {
				case 'i':
					syn |= syntax.FoldCase
				}
			}

			re, err := compile(pattern, syn, true)
			if err != nil {
				if shouldCompile {
					t.Errorf("%s:%d: %#q did not compile", file, lineno, pattern)
				}
				continue Testing
			}
			if !shouldCompile {
				t.Errorf("%s:%d: %#q should not compile", file, lineno, pattern)
				continue Testing
			}
			match := re.MatchString(text)
			if match != shouldMatch {
				t.Errorf("%s:%d: %#q.Match(%#q) = %v, want %v", file, lineno, pattern, text, match, shouldMatch)
				continue Testing
			}
			have := re.FindStringSubmatchIndex(text)
			if (len(have) > 0) != match {
				t.Errorf("%s:%d: %#q.Match(%#q) = %v, but %#q.FindSubmatchIndex(%#q) = %v", file, lineno, pattern, text, match, pattern, text, have)
				continue Testing
			}
			if len(have) > len(pos) {
				have = have[:len(pos)]
			}
			if !same(have, pos) {
				t.Errorf("%s:%d: %#q.FindSubmatchIndex(%#q) = %v, want %v", file, lineno, pattern, text, have, pos)
			}
		}
	}
}

func parseFowlerResult(s string) (ok, compiled, matched bool, pos []int) {
	//   Field 4: the test outcome. This is either one of the posix error
	//     codes (with REG_ omitted) or the match array, a list of (m,n)
	//     entries with m and n being first and last+1 positions in the
	//     field 3 string, or NULL if REG_NOSUB is in effect and success
	//     is expected. BADPAT is acceptable in place of any regcomp(3)
	//     error code. The match[] array is initialized to (-2,-2) before
	//     each test. All array elements from 0 to nmatch-1 must be specified
	//     in the outcome. Unspecified endpoints (offset -1) are denoted by ?.
	//     Unset endpoints (offset -2) are denoted by X. {x}(o:n) denotes a
	//     matched (?{...}) expression, where x is the text enclosed by {...},
	//     o is the expression ordinal counting from 1, and n is the length of
	//     the unmatched portion of the subject string. If x starts with a
	//     number then that is the return value of re_execf(), otherwise 0 is
	//     returned.
	switch {
	case s == "":
		// Match with no position information.
		ok = true
		compiled = true
		matched = true
		return
	case s == "NOMATCH":
		// Match failure.
		ok = true
		compiled = true
		matched = false
		return
	case 'A' <= s[0] && s[0] <= 'Z':
		// All the other error codes are compile errors.
		ok = true
		compiled = false
		return
	}
	compiled = true

	var x []int
	for s != "" {
		var end byte = ')'
		if len(x)%2 == 0 {
			if s[0] != '(' {
				ok = false
				return
			}
			s = s[1:]
			end = ','
		}
		i := 0
		for i < len(s) && s[i] != end {
			i++
		}
		if i == 0 || i == len(s) {
			ok = false
			return
		}
		var v = -1
		var err error
		if s[:i] != "?" {
			v, err = strconv.Atoi(s[:i])
			if err != nil {
				ok = false
				return
			}
		}
		x = append(x, v)
		s = s[i+1:]
	}
	if len(x)%2 != 0 {
		ok = false
		return
	}
	ok = true
	matched = true
	pos = x
	return
}

var text []byte

func makeText(n int) []byte {
	if len(text) >= n {
		return text[:n]
	}
	text = make([]byte, n)
	x := ^uint32(0)
	for i := range text {
		x += x
		x ^= 1
		if int32(x) < 0 {
			x ^= 0x88888eef
		}
		if x%31 == 0 {
			text[i] = '\n'
		} else {
			text[i] = byte(x%(0x7E+1-0x20) + 0x20)
		}
	}
	return text
}

func benchmark(b *testing.B, re string, n int) {
	r := MustCompile(re)
	t := makeText(n)
	b.ResetTimer()
	b.SetBytes(int64(n))
	for i := 0; i < b.N; i++ {
		if r.Match(t) {
			b.Fatal("match!")
		}
	}
}

const (
	easy0  = "ABCDEFGHIJKLMNOPQRSTUVWXYZ$"
	easy1  = "A[AB]B[BC]C[CD]D[DE]E[EF]F[FG]G[GH]H[HI]I[IJ]J$"
	medium = "[XYZ]ABCDEFGHIJKLMNOPQRSTUVWXYZ$"
	hard   = "[ -~]*ABCDEFGHIJKLMNOPQRSTUVWXYZ$"
	parens = "([ -~])*(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)" +
		"(N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)$"
)

func BenchmarkMatchEasy0_32(b *testing.B)   { benchmark(b, easy0, 32<<0) }
func BenchmarkMatchEasy0_1K(b *testing.B)   { benchmark(b, easy0, 1<<10) }
func BenchmarkMatchEasy0_32K(b *testing.B)  { benchmark(b, easy0, 32<<10) }
func BenchmarkMatchEasy0_1M(b *testing.B)   { benchmark(b, easy0, 1<<20) }
func BenchmarkMatchEasy0_32M(b *testing.B)  { benchmark(b, easy0, 32<<20) }
func BenchmarkMatchEasy1_32(b *testing.B)   { benchmark(b, easy1, 32<<0) }
func BenchmarkMatchEasy1_1K(b *testing.B)   { benchmark(b, easy1, 1<<10) }
func BenchmarkMatchEasy1_32K(b *testing.B)  { benchmark(b, easy1, 32<<10) }
func BenchmarkMatchEasy1_1M(b *testing.B)   { benchmark(b, easy1, 1<<20) }
func BenchmarkMatchEasy1_32M(b *testing.B)  { benchmark(b, easy1, 32<<20) }
func BenchmarkMatchMedium_32(b *testing.B)  { benchmark(b, medium, 32<<0) }
func BenchmarkMatchMedium_1K(b *testing.B)  { benchmark(b, medium, 1<<10) }
func BenchmarkMatchMedium_32K(b *testing.B) { benchmark(b, medium, 32<<10) }
func BenchmarkMatchMedium_1M(b *testing.B)  { benchmark(b, medium, 1<<20) }
func BenchmarkMatchMedium_32M(b *testing.B) { benchmark(b, medium, 32<<20) }
func BenchmarkMatchHard_32(b *testing.B)    { benchmark(b, hard, 32<<0) }
func BenchmarkMatchHard_1K(b *testing.B)    { benchmark(b, hard, 1<<10) }
func BenchmarkMatchHard_32K(b *testing.B)   { benchmark(b, hard, 32<<10) }
func BenchmarkMatchHard_1M(b *testing.B)    { benchmark(b, hard, 1<<20) }
func BenchmarkMatchHard_32M(b *testing.B)   { benchmark(b, hard, 32<<20) }

func TestLongest(t *testing.T) {
	re, err := Compile(`a(|b)`)
	if err != nil {
		t.Fatal(err)
	}
	if g, w := re.FindString("ab"), "a"; g != w {
		t.Errorf("first match was %q, want %q", g, w)
	}
	re.Longest()
	if g, w := re.FindString("ab"), "ab"; g != w {
		t.Errorf("longest match was %q, want %q", g, w)
	}
}
                                                                                                                root/go1.4/src/regexp/find_test.go                                                                  0100644 0000000 0000000 00000037130 12600426227 015454  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package regexp

import (
	"fmt"
	"strings"
	"testing"
)

// For each pattern/text pair, what is the expected output of each function?
// We can derive the textual results from the indexed results, the non-submatch
// results from the submatched results, the single results from the 'all' results,
// and the byte results from the string results. Therefore the table includes
// only the FindAllStringSubmatchIndex result.
type FindTest struct {
	pat     string
	text    string
	matches [][]int
}

func (t FindTest) String() string {
	return fmt.Sprintf("pat: %#q text: %#q", t.pat, t.text)
}

var findTests = []FindTest{
	{``, ``, build(1, 0, 0)},
	{`^abcdefg`, "abcdefg", build(1, 0, 7)},
	{`a+`, "baaab", build(1, 1, 4)},
	{"abcd..", "abcdef", build(1, 0, 6)},
	{`a`, "a", build(1, 0, 1)},
	{`x`, "y", nil},
	{`b`, "abc", build(1, 1, 2)},
	{`.`, "a", build(1, 0, 1)},
	{`.*`, "abcdef", build(1, 0, 6)},
	{`^`, "abcde", build(1, 0, 0)},
	{`$`, "abcde", build(1, 5, 5)},
	{`^abcd$`, "abcd", build(1, 0, 4)},
	{`^bcd'`, "abcdef", nil},
	{`^abcd$`, "abcde", nil},
	{`a+`, "baaab", build(1, 1, 4)},
	{`a*`, "baaab", build(3, 0, 0, 1, 4, 5, 5)},
	{`[a-z]+`, "abcd", build(1, 0, 4)},
	{`[^a-z]+`, "ab1234cd", build(1, 2, 6)},
	{`[a\-\]z]+`, "az]-bcz", build(2, 0, 4, 6, 7)},
	{`[^\n]+`, "abcd\n", build(1, 0, 4)},
	{`[]+`, "", build(1, 0, 18)},
	{`+`, "", build(1, 0, 9)},
	{`+`, "", build(1, 0, 18)},
	{`()`, "", build(1, 0, 0, 0, 0)},
	{`(a)`, "a", build(1, 0, 1, 0, 1)},
	{`(.)(.)`, "a", build(1, 0, 4, 0, 3, 3, 4)},
	{`(.*)`, "", build(1, 0, 0, 0, 0)},
	{`(.*)`, "abcd", build(1, 0, 4, 0, 4)},
	{`(..)(..)`, "abcd", build(1, 0, 4, 0, 2, 2, 4)},
	{`(([^xyz]*)(d))`, "abcd", build(1, 0, 4, 0, 4, 0, 3, 3, 4)},
	{`((a|b|c)*(d))`, "abcd", build(1, 0, 4, 0, 4, 2, 3, 3, 4)},
	{`(((a|b|c)*)(d))`, "abcd", build(1, 0, 4, 0, 4, 0, 3, 2, 3, 3, 4)},
	{`\a\f\n\r\t\v`, "\a\f\n\r\t\v", build(1, 0, 6)},
	{`[\a\f\n\r\t\v]+`, "\a\f\n\r\t\v", build(1, 0, 6)},

	{`a*(|(b))c*`, "aacc", build(1, 0, 4, 2, 2, -1, -1)},
	{`(.*).*`, "ab", build(1, 0, 2, 0, 2)},
	{`[.]`, ".", build(1, 0, 1)},
	{`/$`, "/abc/", build(1, 4, 5)},
	{`/$`, "/abc", nil},

	// multiple matches
	{`.`, "abc", build(3, 0, 1, 1, 2, 2, 3)},
	{`(.)`, "abc", build(3, 0, 1, 0, 1, 1, 2, 1, 2, 2, 3, 2, 3)},
	{`.(.)`, "abcd", build(2, 0, 2, 1, 2, 2, 4, 3, 4)},
	{`ab*`, "abbaab", build(3, 0, 3, 3, 4, 4, 6)},
	{`a(b*)`, "abbaab", build(3, 0, 3, 1, 3, 3, 4, 4, 4, 4, 6, 5, 6)},

	// fixed bugs
	{`ab$`, "cab", build(1, 1, 3)},
	{`axxb$`, "axxcb", nil},
	{`data`, "daXY data", build(1, 5, 9)},
	{`da(.)a$`, "daXY data", build(1, 5, 9, 7, 8)},
	{`zx+`, "zzx", build(1, 1, 3)},
	{`ab$`, "abcab", build(1, 3, 5)},
	{`(aa)*$`, "a", build(1, 1, 1, -1, -1)},
	{`(?:.|(?:.a))`, "", nil},
	{`(?:A(?:A|a))`, "Aa", build(1, 0, 2)},
	{`(?:A|(?:A|a))`, "a", build(1, 0, 1)},
	{`(a){0}`, "", build(1, 0, 0, -1, -1)},
	{`(?-s)(?:(?:^).)`, "\n", nil},
	{`(?s)(?:(?:^).)`, "\n", build(1, 0, 1)},
	{`(?:(?:^).)`, "\n", nil},
	{`\b`, "x", build(2, 0, 0, 1, 1)},
	{`\b`, "xx", build(2, 0, 0, 2, 2)},
	{`\b`, "x y", build(4, 0, 0, 1, 1, 2, 2, 3, 3)},
	{`\b`, "xx yy", build(4, 0, 0, 2, 2, 3, 3, 5, 5)},
	{`\B`, "x", nil},
	{`\B`, "xx", build(1, 1, 1)},
	{`\B`, "x y", nil},
	{`\B`, "xx yy", build(2, 1, 1, 4, 4)},

	// RE2 tests
	{`[^\S\s]`, "abcd", nil},
	{`[^\S[:space:]]`, "abcd", nil},
	{`[^\D\d]`, "abcd", nil},
	{`[^\D[:digit:]]`, "abcd", nil},
	{`(?i)\W`, "x", nil},
	{`(?i)\W`, "k", nil},
	{`(?i)\W`, "s", nil},

	// can backslash-escape any punctuation
	{`\!\"\#\$\%\&\'\(\)\*\+\,\-\.\/\:\;\<\=\>\?\@\[\\\]\^\_\{\|\}\~`,
		`!"#$%&'()*+,-./:;<=>?@[\]^_{|}~`, build(1, 0, 31)},
	{`[\!\"\#\$\%\&\'\(\)\*\+\,\-\.\/\:\;\<\=\>\?\@\[\\\]\^\_\{\|\}\~]+`,
		`!"#$%&'()*+,-./:;<=>?@[\]^_{|}~`, build(1, 0, 31)},
	{"\\`", "`", build(1, 0, 1)},
	{"[\\`]+", "`", build(1, 0, 1)},

	// long set of matches (longer than startSize)
	{
		".",
		"qwertyuiopasdfghjklzxcvbnm1234567890",
		build(36, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,
			10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20,
			20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30,
			30, 31, 31, 32, 32, 33, 33, 34, 34, 35, 35, 36),
	},
}

// build is a helper to construct a [][]int by extracting n sequences from x.
// This represents n matches with len(x)/n submatches each.
func build(n int, x ...int) [][]int {
	ret := make([][]int, n)
	runLength := len(x) / n
	j := 0
	for i := range ret {
		ret[i] = make([]int, runLength)
		copy(ret[i], x[j:])
		j += runLength
		if j > len(x) {
			panic("invalid build entry")
		}
	}
	return ret
}

// First the simple cases.

func TestFind(t *testing.T) {
	for _, test := range findTests {
		re := MustCompile(test.pat)
		if re.String() != test.pat {
			t.Errorf("String() = `%s`; should be `%s`", re.String(), test.pat)
		}
		result := re.Find([]byte(test.text))
		switch {
		case len(test.matches) == 0 && len(result) == 0:
			// ok
		case test.matches == nil && result != nil:
			t.Errorf("expected no match; got one: %s", test)
		case test.matches != nil && result == nil:
			t.Errorf("expected match; got none: %s", test)
		case test.matches != nil && result != nil:
			expect := test.text[test.matches[0][0]:test.matches[0][1]]
			if expect != string(result) {
				t.Errorf("expected %q got %q: %s", expect, result, test)
			}
		}
	}
}

func TestFindString(t *testing.T) {
	for _, test := range findTests {
		result := MustCompile(test.pat).FindString(test.text)
		switch {
		case len(test.matches) == 0 && len(result) == 0:
			// ok
		case test.matches == nil && result != "":
			t.Errorf("expected no match; got one: %s", test)
		case test.matches != nil && result == "":
			// Tricky because an empty result has two meanings: no match or empty match.
			if test.matches[0][0] != test.matches[0][1] {
				t.Errorf("expected match; got none: %s", test)
			}
		case test.matches != nil && result != "":
			expect := test.text[test.matches[0][0]:test.matches[0][1]]
			if expect != result {
				t.Errorf("expected %q got %q: %s", expect, result, test)
			}
		}
	}
}

func testFindIndex(test *FindTest, result []int, t *testing.T) {
	switch {
	case len(test.matches) == 0 && len(result) == 0:
		// ok
	case test.matches == nil && result != nil:
		t.Errorf("expected no match; got one: %s", test)
	case test.matches != nil && result == nil:
		t.Errorf("expected match; got none: %s", test)
	case test.matches != nil && result != nil:
		expect := test.matches[0]
		if expect[0] != result[0] || expect[1] != result[1] {
			t.Errorf("expected %v got %v: %s", expect, result, test)
		}
	}
}

func TestFindIndex(t *testing.T) {
	for _, test := range findTests {
		testFindIndex(&test, MustCompile(test.pat).FindIndex([]byte(test.text)), t)
	}
}

func TestFindStringIndex(t *testing.T) {
	for _, test := range findTests {
		testFindIndex(&test, MustCompile(test.pat).FindStringIndex(test.text), t)
	}
}

func TestFindReaderIndex(t *testing.T) {
	for _, test := range findTests {
		testFindIndex(&test, MustCompile(test.pat).FindReaderIndex(strings.NewReader(test.text)), t)
	}
}

// Now come the simple All cases.

func TestFindAll(t *testing.T) {
	for _, test := range findTests {
		result := MustCompile(test.pat).FindAll([]byte(test.text), -1)
		switch {
		case test.matches == nil && result == nil:
			// ok
		case test.matches == nil && result != nil:
			t.Errorf("expected no match; got one: %s", test)
		case test.matches != nil && result == nil:
			t.Fatalf("expected match; got none: %s", test)
		case test.matches != nil && result != nil:
			if len(test.matches) != len(result) {
				t.Errorf("expected %d matches; got %d: %s", len(test.matches), len(result), test)
				continue
			}
			for k, e := range test.matches {
				expect := test.text[e[0]:e[1]]
				if expect != string(result[k]) {
					t.Errorf("match %d: expected %q got %q: %s", k, expect, result[k], test)
				}
			}
		}
	}
}

func TestFindAllString(t *testing.T) {
	for _, test := range findTests {
		result := MustCompile(test.pat).FindAllString(test.text, -1)
		switch {
		case test.matches == nil && result == nil:
			// ok
		case test.matches == nil && result != nil:
			t.Errorf("expected no match; got one: %s", test)
		case test.matches != nil && result == nil:
			t.Errorf("expected match; got none: %s", test)
		case test.matches != nil && result != nil:
			if len(test.matches) != len(result) {
				t.Errorf("expected %d matches; got %d: %s", len(test.matches), len(result), test)
				continue
			}
			for k, e := range test.matches {
				expect := test.text[e[0]:e[1]]
				if expect != result[k] {
					t.Errorf("expected %q got %q: %s", expect, result, test)
				}
			}
		}
	}
}

func testFindAllIndex(test *FindTest, result [][]int, t *testing.T) {
	switch {
	case test.matches == nil && result == nil:
		// ok
	case test.matches == nil && result != nil:
		t.Errorf("expected no match; got one: %s", test)
	case test.matches != nil && result == nil:
		t.Errorf("expected match; got none: %s", test)
	case test.matches != nil && result != nil:
		if len(test.matches) != len(result) {
			t.Errorf("expected %d matches; got %d: %s", len(test.matches), len(result), test)
			return
		}
		for k, e := range test.matches {
			if e[0] != result[k][0] || e[1] != result[k][1] {
				t.Errorf("match %d: expected %v got %v: %s", k, e, result[k], test)
			}
		}
	}
}

func TestFindAllIndex(t *testing.T) {
	for _, test := range findTests {
		testFindAllIndex(&test, MustCompile(test.pat).FindAllIndex([]byte(test.text), -1), t)
	}
}

func TestFindAllStringIndex(t *testing.T) {
	for _, test := range findTests {
		testFindAllIndex(&test, MustCompile(test.pat).FindAllStringIndex(test.text, -1), t)
	}
}

// Now come the Submatch cases.

func testSubmatchBytes(test *FindTest, n int, submatches []int, result [][]byte, t *testing.T) {
	if len(submatches) != len(result)*2 {
		t.Errorf("match %d: expected %d submatches; got %d: %s", n, len(submatches)/2, len(result), test)
		return
	}
	for k := 0; k < len(submatches); k += 2 {
		if submatches[k] == -1 {
			if result[k/2] != nil {
				t.Errorf("match %d: expected nil got %q: %s", n, result, test)
			}
			continue
		}
		expect := test.text[submatches[k]:submatches[k+1]]
		if expect != string(result[k/2]) {
			t.Errorf("match %d: expected %q got %q: %s", n, expect, result, test)
			return
		}
	}
}

func TestFindSubmatch(t *testing.T) {
	for _, test := range findTests {
		result := MustCompile(test.pat).FindSubmatch([]byte(test.text))
		switch {
		case test.matches == nil && result == nil:
			// ok
		case test.matches == nil && result != nil:
			t.Errorf("expected no match; got one: %s", test)
		case test.matches != nil && result == nil:
			t.Errorf("expected match; got none: %s", test)
		case test.matches != nil && result != nil:
			testSubmatchBytes(&test, 0, test.matches[0], result, t)
		}
	}
}

func testSubmatchString(test *FindTest, n int, submatches []int, result []string, t *testing.T) {
	if len(submatches) != len(result)*2 {
		t.Errorf("match %d: expected %d submatches; got %d: %s", n, len(submatches)/2, len(result), test)
		return
	}
	for k := 0; k < len(submatches); k += 2 {
		if submatches[k] == -1 {
			if result[k/2] != "" {
				t.Errorf("match %d: expected nil got %q: %s", n, result, test)
			}
			continue
		}
		expect := test.text[submatches[k]:submatches[k+1]]
		if expect != result[k/2] {
			t.Errorf("match %d: expected %q got %q: %s", n, expect, result, test)
			return
		}
	}
}

func TestFindStringSubmatch(t *testing.T) {
	for _, test := range findTests {
		result := MustCompile(test.pat).FindStringSubmatch(test.text)
		switch {
		case test.matches == nil && result == nil:
			// ok
		case test.matches == nil && result != nil:
			t.Errorf("expected no match; got one: %s", test)
		case test.matches != nil && result == nil:
			t.Errorf("expected match; got none: %s", test)
		case test.matches != nil && result != nil:
			testSubmatchString(&test, 0, test.matches[0], result, t)
		}
	}
}

func testSubmatchIndices(test *FindTest, n int, expect, result []int, t *testing.T) {
	if len(expect) != len(result) {
		t.Errorf("match %d: expected %d matches; got %d: %s", n, len(expect)/2, len(result)/2, test)
		return
	}
	for k, e := range expect {
		if e != result[k] {
			t.Errorf("match %d: submatch error: expected %v got %v: %s", n, expect, result, test)
		}
	}
}

func testFindSubmatchIndex(test *FindTest, result []int, t *testing.T) {
	switch {
	case test.matches == nil && result == nil:
		// ok
	case test.matches == nil && result != nil:
		t.Errorf("expected no match; got one: %s", test)
	case test.matches != nil && result == nil:
		t.Errorf("expected match; got none: %s", test)
	case test.matches != nil && result != nil:
		testSubmatchIndices(test, 0, test.matches[0], result, t)
	}
}

func TestFindSubmatchIndex(t *testing.T) {
	for _, test := range findTests {
		testFindSubmatchIndex(&test, MustCompile(test.pat).FindSubmatchIndex([]byte(test.text)), t)
	}
}

func TestFindStringSubmatchIndex(t *testing.T) {
	for _, test := range findTests {
		testFindSubmatchIndex(&test, MustCompile(test.pat).FindStringSubmatchIndex(test.text), t)
	}
}

func TestFindReaderSubmatchIndex(t *testing.T) {
	for _, test := range findTests {
		testFindSubmatchIndex(&test, MustCompile(test.pat).FindReaderSubmatchIndex(strings.NewReader(test.text)), t)
	}
}

// Now come the monster AllSubmatch cases.

func TestFindAllSubmatch(t *testing.T) {
	for _, test := range findTests {
		result := MustCompile(test.pat).FindAllSubmatch([]byte(test.text), -1)
		switch {
		case test.matches == nil && result == nil:
			// ok
		case test.matches == nil && result != nil:
			t.Errorf("expected no match; got one: %s", test)
		case test.matches != nil && result == nil:
			t.Errorf("expected match; got none: %s", test)
		case len(test.matches) != len(result):
			t.Errorf("expected %d matches; got %d: %s", len(test.matches), len(result), test)
		case test.matches != nil && result != nil:
			for k, match := range test.matches {
				testSubmatchBytes(&test, k, match, result[k], t)
			}
		}
	}
}

func TestFindAllStringSubmatch(t *testing.T) {
	for _, test := range findTests {
		result := MustCompile(test.pat).FindAllStringSubmatch(test.text, -1)
		switch {
		case test.matches == nil && result == nil:
			// ok
		case test.matches == nil && result != nil:
			t.Errorf("expected no match; got one: %s", test)
		case test.matches != nil && result == nil:
			t.Errorf("expected match; got none: %s", test)
		case len(test.matches) != len(result):
			t.Errorf("expected %d matches; got %d: %s", len(test.matches), len(result), test)
		case test.matches != nil && result != nil:
			for k, match := range test.matches {
				testSubmatchString(&test, k, match, result[k], t)
			}
		}
	}
}

func testFindAllSubmatchIndex(test *FindTest, result [][]int, t *testing.T) {
	switch {
	case test.matches == nil && result == nil:
		// ok
	case test.matches == nil && result != nil:
		t.Errorf("expected no match; got one: %s", test)
	case test.matches != nil && result == nil:
		t.Errorf("expected match; got none: %s", test)
	case len(test.matches) != len(result):
		t.Errorf("expected %d matches; got %d: %s", len(test.matches), len(result), test)
	case test.matches != nil && result != nil:
		for k, match := range test.matches {
			testSubmatchIndices(test, k, match, result[k], t)
		}
	}
}

func TestFindAllSubmatchIndex(t *testing.T) {
	for _, test := range findTests {
		testFindAllSubmatchIndex(&test, MustCompile(test.pat).FindAllSubmatchIndex([]byte(test.text), -1), t)
	}
}

func TestFindAllStringSubmatchIndex(t *testing.T) {
	for _, test := range findTests {
		testFindAllSubmatchIndex(&test, MustCompile(test.pat).FindAllStringSubmatchIndex(test.text, -1), t)
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                        root/go1.4/src/regexp/onepass.go                                                                    0100644 0000000 0000000 00000037501 12600426227 015147  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package regexp

import (
	"bytes"
	"regexp/syntax"
	"sort"
	"unicode"
)

// "One-pass" regexp execution.
// Some regexps can be analyzed to determine that they never need
// backtracking: they are guaranteed to run in one pass over the string
// without bothering to save all the usual NFA state.
// Detect those and execute them more quickly.

// A onePassProg is a compiled one-pass regular expression program.
// It is the same as syntax.Prog except for the use of onePassInst.
type onePassProg struct {
	Inst   []onePassInst
	Start  int // index of start instruction
	NumCap int // number of InstCapture insts in re
}

// A onePassInst is a single instruction in a one-pass regular expression program.
// It is the same as syntax.Inst except for the new 'Next' field.
type onePassInst struct {
	syntax.Inst
	Next []uint32
}

// OnePassPrefix returns a literal string that all matches for the
// regexp must start with.  Complete is true if the prefix
// is the entire match. Pc is the index of the last rune instruction
// in the string. The OnePassPrefix skips over the mandatory
// EmptyBeginText
func onePassPrefix(p *syntax.Prog) (prefix string, complete bool, pc uint32) {
	i := &p.Inst[p.Start]
	if i.Op != syntax.InstEmptyWidth || (syntax.EmptyOp(i.Arg))&syntax.EmptyBeginText == 0 {
		return "", i.Op == syntax.InstMatch, uint32(p.Start)
	}
	pc = i.Out
	i = &p.Inst[pc]
	for i.Op == syntax.InstNop {
		pc = i.Out
		i = &p.Inst[pc]
	}
	// Avoid allocation of buffer if prefix is empty.
	if iop(i) != syntax.InstRune || len(i.Rune) != 1 {
		return "", i.Op == syntax.InstMatch, uint32(p.Start)
	}

	// Have prefix; gather characters.
	var buf bytes.Buffer
	for iop(i) == syntax.InstRune && len(i.Rune) == 1 && syntax.Flags(i.Arg)&syntax.FoldCase == 0 {
		buf.WriteRune(i.Rune[0])
		pc, i = i.Out, &p.Inst[i.Out]
	}
	return buf.String(), i.Op == syntax.InstEmptyWidth && (syntax.EmptyOp(i.Arg))&syntax.EmptyBeginText != 0, pc
}

// OnePassNext selects the next actionable state of the prog, based on the input character.
// It should only be called when i.Op == InstAlt or InstAltMatch, and from the one-pass machine.
// One of the alternates may ultimately lead without input to end of line. If the instruction
// is InstAltMatch the path to the InstMatch is in i.Out, the normal node in i.Next.
func onePassNext(i *onePassInst, r rune) uint32 {
	next := i.MatchRunePos(r)
	if next >= 0 {
		return i.Next[next]
	}
	if i.Op == syntax.InstAltMatch {
		return i.Out
	}
	return 0
}

func iop(i *syntax.Inst) syntax.InstOp {
	op := i.Op
	switch op {
	case syntax.InstRune1, syntax.InstRuneAny, syntax.InstRuneAnyNotNL:
		op = syntax.InstRune
	}
	return op
}

// Sparse Array implementation is used as a queueOnePass.
type queueOnePass struct {
	sparse          []uint32
	dense           []uint32
	size, nextIndex uint32
}

func (q *queueOnePass) empty() bool {
	return q.nextIndex >= q.size
}

func (q *queueOnePass) next() (n uint32) {
	n = q.dense[q.nextIndex]
	q.nextIndex++
	return
}

func (q *queueOnePass) clear() {
	q.size = 0
	q.nextIndex = 0
}

func (q *queueOnePass) reset() {
	q.nextIndex = 0
}

func (q *queueOnePass) contains(u uint32) bool {
	if u >= uint32(len(q.sparse)) {
		return false
	}
	return q.sparse[u] < q.size && q.dense[q.sparse[u]] == u
}

func (q *queueOnePass) insert(u uint32) {
	if !q.contains(u) {
		q.insertNew(u)
	}
}

func (q *queueOnePass) insertNew(u uint32) {
	if u >= uint32(len(q.sparse)) {
		return
	}
	q.sparse[u] = q.size
	q.dense[q.size] = u
	q.size++
}

func newQueue(size int) (q *queueOnePass) {
	return &queueOnePass{
		sparse: make([]uint32, size),
		dense:  make([]uint32, size),
	}
}

// mergeRuneSets merges two non-intersecting runesets, and returns the merged result,
// and a NextIp array. The idea is that if a rune matches the OnePassRunes at index
// i, NextIp[i/2] is the target. If the input sets intersect, an empty runeset and a
// NextIp array with the single element mergeFailed is returned.
// The code assumes that both inputs contain ordered and non-intersecting rune pairs.
const mergeFailed = uint32(0xffffffff)

var (
	noRune = []rune{}
	noNext = []uint32{mergeFailed}
)

func mergeRuneSets(leftRunes, rightRunes *[]rune, leftPC, rightPC uint32) ([]rune, []uint32) {
	leftLen := len(*leftRunes)
	rightLen := len(*rightRunes)
	if leftLen&0x1 != 0 || rightLen&0x1 != 0 {
		panic("mergeRuneSets odd length []rune")
	}
	var (
		lx, rx int
	)
	merged := make([]rune, 0)
	next := make([]uint32, 0)
	ok := true
	defer func() {
		if !ok {
			merged = nil
			next = nil
		}
	}()

	ix := -1
	extend := func(newLow *int, newArray *[]rune, pc uint32) bool {
		if ix > 0 && (*newArray)[*newLow] <= merged[ix] {
			return false
		}
		merged = append(merged, (*newArray)[*newLow], (*newArray)[*newLow+1])
		*newLow += 2
		ix += 2
		next = append(next, pc)
		return true
	}

	for lx < leftLen || rx < rightLen {
		switch {
		case rx >= rightLen:
			ok = extend(&lx, leftRunes, leftPC)
		case lx >= leftLen:
			ok = extend(&rx, rightRunes, rightPC)
		case (*rightRunes)[rx] < (*leftRunes)[lx]:
			ok = extend(&rx, rightRunes, rightPC)
		default:
			ok = extend(&lx, leftRunes, leftPC)
		}
		if !ok {
			return noRune, noNext
		}
	}
	return merged, next
}

// cleanupOnePass drops working memory, and restores certain shortcut instructions.
func cleanupOnePass(prog *onePassProg, original *syntax.Prog) {
	for ix, instOriginal := range original.Inst {
		switch instOriginal.Op {
		case syntax.InstAlt, syntax.InstAltMatch, syntax.InstRune:
		case syntax.InstCapture, syntax.InstEmptyWidth, syntax.InstNop, syntax.InstMatch, syntax.InstFail:
			prog.Inst[ix].Next = nil
		case syntax.InstRune1, syntax.InstRuneAny, syntax.InstRuneAnyNotNL:
			prog.Inst[ix].Next = nil
			prog.Inst[ix] = onePassInst{Inst: instOriginal}
		}
	}
}

// onePassCopy creates a copy of the original Prog, as we'll be modifying it
func onePassCopy(prog *syntax.Prog) *onePassProg {
	p := &onePassProg{
		Start:  prog.Start,
		NumCap: prog.NumCap,
	}
	for _, inst := range prog.Inst {
		p.Inst = append(p.Inst, onePassInst{Inst: inst})
	}

	// rewrites one or more common Prog constructs that enable some otherwise
	// non-onepass Progs to be onepass. A:BD (for example) means an InstAlt at
	// ip A, that points to ips B & C.
	// A:BC + B:DA => A:BC + B:CD
	// A:BC + B:DC => A:DC + B:DC
	for pc := range p.Inst {
		switch p.Inst[pc].Op {
		default:
			continue
		case syntax.InstAlt, syntax.InstAltMatch:
			// A:Bx + B:Ay
			p_A_Other := &p.Inst[pc].Out
			p_A_Alt := &p.Inst[pc].Arg
			// make sure a target is another Alt
			instAlt := p.Inst[*p_A_Alt]
			if !(instAlt.Op == syntax.InstAlt || instAlt.Op == syntax.InstAltMatch) {
				p_A_Alt, p_A_Other = p_A_Other, p_A_Alt
				instAlt = p.Inst[*p_A_Alt]
				if !(instAlt.Op == syntax.InstAlt || instAlt.Op == syntax.InstAltMatch) {
					continue
				}
			}
			instOther := p.Inst[*p_A_Other]
			// Analyzing both legs pointing to Alts is for another day
			if instOther.Op == syntax.InstAlt || instOther.Op == syntax.InstAltMatch {
				// too complicated
				continue
			}
			// simple empty transition loop
			// A:BC + B:DA => A:BC + B:DC
			p_B_Alt := &p.Inst[*p_A_Alt].Out
			p_B_Other := &p.Inst[*p_A_Alt].Arg
			patch := false
			if instAlt.Out == uint32(pc) {
				patch = true
			} else if instAlt.Arg == uint32(pc) {
				patch = true
				p_B_Alt, p_B_Other = p_B_Other, p_B_Alt
			}
			if patch {
				*p_B_Alt = *p_A_Other
			}

			// empty transition to common target
			// A:BC + B:DC => A:DC + B:DC
			if *p_A_Other == *p_B_Alt {
				*p_A_Alt = *p_B_Other
			}
		}
	}
	return p
}

// runeSlice exists to permit sorting the case-folded rune sets.
type runeSlice []rune

func (p runeSlice) Len() int           { return len(p) }
func (p runeSlice) Less(i, j int) bool { return p[i] < p[j] }
func (p runeSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }

// Sort is a convenience method.
func (p runeSlice) Sort() {
	sort.Sort(p)
}

var anyRuneNotNL = []rune{0, '\n' - 1, '\n' + 1, unicode.MaxRune}
var anyRune = []rune{0, unicode.MaxRune}

// makeOnePass creates a onepass Prog, if possible. It is possible if at any alt,
// the match engine can always tell which branch to take. The routine may modify
// p if it is turned into a onepass Prog. If it isn't possible for this to be a
// onepass Prog, the Prog notOnePass is returned. makeOnePass is recursive
// to the size of the Prog.
func makeOnePass(p *onePassProg) *onePassProg {
	// If the machine is very long, it's not worth the time to check if we can use one pass.
	if len(p.Inst) >= 1000 {
		return notOnePass
	}

	var (
		instQueue    = newQueue(len(p.Inst))
		visitQueue   = newQueue(len(p.Inst))
		build        func(uint32, *queueOnePass)
		check        func(uint32, map[uint32]bool) bool
		onePassRunes = make([][]rune, len(p.Inst))
	)
	build = func(pc uint32, q *queueOnePass) {
		if q.contains(pc) {
			return
		}
		inst := p.Inst[pc]
		switch inst.Op {
		case syntax.InstAlt, syntax.InstAltMatch:
			q.insert(inst.Out)
			build(inst.Out, q)
			q.insert(inst.Arg)
		case syntax.InstMatch, syntax.InstFail:
		default:
			q.insert(inst.Out)
		}
	}

	// check that paths from Alt instructions are unambiguous, and rebuild the new
	// program as a onepass program
	check = func(pc uint32, m map[uint32]bool) (ok bool) {
		ok = true
		inst := &p.Inst[pc]
		if visitQueue.contains(pc) {
			return
		}
		visitQueue.insert(pc)
		switch inst.Op {
		case syntax.InstAlt, syntax.InstAltMatch:
			ok = check(inst.Out, m) && check(inst.Arg, m)
			// check no-input paths to InstMatch
			matchOut := m[inst.Out]
			matchArg := m[inst.Arg]
			if matchOut && matchArg {
				ok = false
				break
			}
			// Match on empty goes in inst.Out
			if matchArg {
				inst.Out, inst.Arg = inst.Arg, inst.Out
				matchOut, matchArg = matchArg, matchOut
			}
			if matchOut {
				m[pc] = true
				inst.Op = syntax.InstAltMatch
			}

			// build a dispatch operator from the two legs of the alt.
			onePassRunes[pc], inst.Next = mergeRuneSets(
				&onePassRunes[inst.Out], &onePassRunes[inst.Arg], inst.Out, inst.Arg)
			if len(inst.Next) > 0 && inst.Next[0] == mergeFailed {
				ok = false
				break
			}
		case syntax.InstCapture, syntax.InstNop:
			ok = check(inst.Out, m)
			m[pc] = m[inst.Out]
			// pass matching runes back through these no-ops.
			onePassRunes[pc] = append([]rune{}, onePassRunes[inst.Out]...)
			inst.Next = []uint32{}
			for i := len(onePassRunes[pc]) / 2; i >= 0; i-- {
				inst.Next = append(inst.Next, inst.Out)
			}
		case syntax.InstEmptyWidth:
			ok = check(inst.Out, m)
			m[pc] = m[inst.Out]
			onePassRunes[pc] = append([]rune{}, onePassRunes[inst.Out]...)
			inst.Next = []uint32{}
			for i := len(onePassRunes[pc]) / 2; i >= 0; i-- {
				inst.Next = append(inst.Next, inst.Out)
			}
		case syntax.InstMatch, syntax.InstFail:
			m[pc] = inst.Op == syntax.InstMatch
			break
		case syntax.InstRune:
			ok = check(inst.Out, m)
			m[pc] = false
			if len(inst.Next) > 0 {
				break
			}
			if len(inst.Rune) == 0 {
				onePassRunes[pc] = []rune{}
				inst.Next = []uint32{inst.Out}
				break
			}
			runes := make([]rune, 0)
			if len(inst.Rune) == 1 && syntax.Flags(inst.Arg)&syntax.FoldCase != 0 {
				r0 := inst.Rune[0]
				runes = append(runes, r0, r0)
				for r1 := unicode.SimpleFold(r0); r1 != r0; r1 = unicode.SimpleFold(r1) {
					runes = append(runes, r1, r1)
				}
				sort.Sort(runeSlice(runes))
			} else {
				runes = append(runes, inst.Rune...)
			}
			onePassRunes[pc] = runes
			inst.Next = []uint32{}
			for i := len(onePassRunes[pc]) / 2; i >= 0; i-- {
				inst.Next = append(inst.Next, inst.Out)
			}
			inst.Op = syntax.InstRune
		case syntax.InstRune1:
			ok = check(inst.Out, m)
			m[pc] = false
			if len(inst.Next) > 0 {
				break
			}
			runes := []rune{}
			// expand case-folded runes
			if syntax.Flags(inst.Arg)&syntax.FoldCase != 0 {
				r0 := inst.Rune[0]
				runes = append(runes, r0, r0)
				for r1 := unicode.SimpleFold(r0); r1 != r0; r1 = unicode.SimpleFold(r1) {
					runes = append(runes, r1, r1)
				}
				sort.Sort(runeSlice(runes))
			} else {
				runes = append(runes, inst.Rune[0], inst.Rune[0])
			}
			onePassRunes[pc] = runes
			inst.Next = []uint32{}
			for i := len(onePassRunes[pc]) / 2; i >= 0; i-- {
				inst.Next = append(inst.Next, inst.Out)
			}
			inst.Op = syntax.InstRune
		case syntax.InstRuneAny:
			ok = check(inst.Out, m)
			m[pc] = false
			if len(inst.Next) > 0 {
				break
			}
			onePassRunes[pc] = append([]rune{}, anyRune...)
			inst.Next = []uint32{inst.Out}
		case syntax.InstRuneAnyNotNL:
			ok = check(inst.Out, m)
			m[pc] = false
			if len(inst.Next) > 0 {
				break
			}
			onePassRunes[pc] = append([]rune{}, anyRuneNotNL...)
			inst.Next = []uint32{}
			for i := len(onePassRunes[pc]) / 2; i >= 0; i-- {
				inst.Next = append(inst.Next, inst.Out)
			}
		}
		return
	}

	instQueue.clear()
	instQueue.insert(uint32(p.Start))
	m := make(map[uint32]bool, len(p.Inst))
	for !instQueue.empty() {
		pc := instQueue.next()
		inst := p.Inst[pc]
		visitQueue.clear()
		if !check(uint32(pc), m) {
			p = notOnePass
			break
		}
		switch inst.Op {
		case syntax.InstAlt, syntax.InstAltMatch:
			instQueue.insert(inst.Out)
			instQueue.insert(inst.Arg)
		case syntax.InstCapture, syntax.InstEmptyWidth, syntax.InstNop:
			instQueue.insert(inst.Out)
		case syntax.InstMatch:
		case syntax.InstFail:
		case syntax.InstRune, syntax.InstRune1, syntax.InstRuneAny, syntax.InstRuneAnyNotNL:
		default:
		}
	}
	if p != notOnePass {
		for i := range p.Inst {
			p.Inst[i].Rune = onePassRunes[i]
		}
	}
	return p
}

// walk visits each Inst in the prog once, and applies the argument
// function(ip, next), in pre-order.
func walk(prog *syntax.Prog, funcs ...func(ip, next uint32)) {
	var walk1 func(uint32)
	progQueue := newQueue(len(prog.Inst))
	walk1 = func(ip uint32) {
		if progQueue.contains(ip) {
			return
		}
		progQueue.insert(ip)
		inst := prog.Inst[ip]
		switch inst.Op {
		case syntax.InstAlt, syntax.InstAltMatch:
			for _, f := range funcs {
				f(ip, inst.Out)
				f(ip, inst.Arg)
			}
			walk1(inst.Out)
			walk1(inst.Arg)
		default:
			for _, f := range funcs {
				f(ip, inst.Out)
			}
			walk1(inst.Out)
		}
	}
	walk1(uint32(prog.Start))
}

// find returns the Insts that match the argument predicate function
func find(prog *syntax.Prog, f func(*syntax.Prog, int) bool) (matches []uint32) {
	matches = []uint32{}

	for ip := range prog.Inst {
		if f(prog, ip) {
			matches = append(matches, uint32(ip))
		}
	}
	return
}

var notOnePass *onePassProg = nil

// compileOnePass returns a new *syntax.Prog suitable for onePass execution if the original Prog
// can be recharacterized as a one-pass regexp program, or syntax.notOnePass if the
// Prog cannot be converted. For a one pass prog, the fundamental condition that must
// be true is: at any InstAlt, there must be no ambiguity about what branch to  take.
func compileOnePass(prog *syntax.Prog) (p *onePassProg) {
	if prog.Start == 0 {
		return notOnePass
	}
	// onepass regexp is anchored
	if prog.Inst[prog.Start].Op != syntax.InstEmptyWidth ||
		syntax.EmptyOp(prog.Inst[prog.Start].Arg)&syntax.EmptyBeginText != syntax.EmptyBeginText {
		return notOnePass
	}
	// every instruction leading to InstMatch must be EmptyEndText
	for _, inst := range prog.Inst {
		opOut := prog.Inst[inst.Out].Op
		switch inst.Op {
		default:
			if opOut == syntax.InstMatch {
				return notOnePass
			}
		case syntax.InstAlt, syntax.InstAltMatch:
			if opOut == syntax.InstMatch || prog.Inst[inst.Arg].Op == syntax.InstMatch {
				return notOnePass
			}
		case syntax.InstEmptyWidth:
			if opOut == syntax.InstMatch {
				if syntax.EmptyOp(inst.Arg)&syntax.EmptyEndText == syntax.EmptyEndText {
					continue
				}
				return notOnePass
			}
		}
	}
	// Creates a slightly optimized copy of the original Prog
	// that cleans up some Prog idioms that block valid onepass programs
	p = onePassCopy(prog)

	// checkAmbiguity on InstAlts, build onepass Prog if possible
	p = makeOnePass(p)

	if p != notOnePass {
		cleanupOnePass(p, prog)
	}
	return p
}
                                                                                                                                                                                               root/go1.4/src/regexp/onepass_test.go                                                               0100644 0000000 0000000 00000011061 12600426227 016177  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package regexp

import (
	"reflect"
	"regexp/syntax"
	"testing"
)

var runeMergeTests = []struct {
	left, right, merged []rune
	next                []uint32
	leftPC, rightPC     uint32
}{
	{
		// empty rhs
		[]rune{69, 69},
		[]rune{},
		[]rune{69, 69},
		[]uint32{1},
		1, 2,
	},
	{
		// identical runes, identical targets
		[]rune{69, 69},
		[]rune{69, 69},
		[]rune{},
		[]uint32{mergeFailed},
		1, 1,
	},
	{
		// identical runes, different targets
		[]rune{69, 69},
		[]rune{69, 69},
		[]rune{},
		[]uint32{mergeFailed},
		1, 2,
	},
	{
		// append right-first
		[]rune{69, 69},
		[]rune{71, 71},
		[]rune{69, 69, 71, 71},
		[]uint32{1, 2},
		1, 2,
	},
	{
		// append, left-first
		[]rune{71, 71},
		[]rune{69, 69},
		[]rune{69, 69, 71, 71},
		[]uint32{2, 1},
		1, 2,
	},
	{
		// successful interleave
		[]rune{60, 60, 71, 71, 101, 101},
		[]rune{69, 69, 88, 88},
		[]rune{60, 60, 69, 69, 71, 71, 88, 88, 101, 101},
		[]uint32{1, 2, 1, 2, 1},
		1, 2,
	},
	{
		// left surrounds right
		[]rune{69, 74},
		[]rune{71, 71},
		[]rune{},
		[]uint32{mergeFailed},
		1, 2,
	},
	{
		// right surrounds left
		[]rune{69, 74},
		[]rune{68, 75},
		[]rune{},
		[]uint32{mergeFailed},
		1, 2,
	},
	{
		// overlap at interval begin
		[]rune{69, 74},
		[]rune{74, 75},
		[]rune{},
		[]uint32{mergeFailed},
		1, 2,
	},
	{
		// overlap ar interval end
		[]rune{69, 74},
		[]rune{65, 69},
		[]rune{},
		[]uint32{mergeFailed},
		1, 2,
	},
	{
		// overlap from above
		[]rune{69, 74},
		[]rune{71, 74},
		[]rune{},
		[]uint32{mergeFailed},
		1, 2,
	},
	{
		// overlap from below
		[]rune{69, 74},
		[]rune{65, 71},
		[]rune{},
		[]uint32{mergeFailed},
		1, 2,
	},
	{
		// out of order []rune
		[]rune{69, 74, 60, 65},
		[]rune{66, 67},
		[]rune{},
		[]uint32{mergeFailed},
		1, 2,
	},
}

func TestMergeRuneSet(t *testing.T) {
	for ix, test := range runeMergeTests {
		merged, next := mergeRuneSets(&test.left, &test.right, test.leftPC, test.rightPC)
		if !reflect.DeepEqual(merged, test.merged) {
			t.Errorf("mergeRuneSet :%d (%v, %v) merged\n have\n%v\nwant\n%v", ix, test.left, test.right, merged, test.merged)
		}
		if !reflect.DeepEqual(next, test.next) {
			t.Errorf("mergeRuneSet :%d(%v, %v) next\n have\n%v\nwant\n%v", ix, test.left, test.right, next, test.next)
		}
	}
}

const noStr = `!`

var onePass = &onePassProg{}

var onePassTests = []struct {
	re      string
	onePass *onePassProg
	prog    string
}{
	{`^(?:a|(?:a*))$`, notOnePass, noStr},
	{`^(?:(a)|(?:a*))$`, notOnePass, noStr},
	{`^(?:(?:(?:.(?:$))?))$`, onePass, `a`},
	{`^abcd$`, onePass, `abcd`},
	{`^abcd$`, onePass, `abcde`},
	{`^(?:(?:a{0,})*?)$`, onePass, `a`},
	{`^(?:(?:a+)*)$`, onePass, ``},
	{`^(?:(?:a|(?:aa)))$`, onePass, ``},
	{`^(?:[^\s\S])$`, onePass, ``},
	{`^(?:(?:a{3,4}){0,})$`, notOnePass, `aaaaaa`},
	{`^(?:(?:a+)*)$`, onePass, `a`},
	{`^(?:(?:(?:a*)+))$`, onePass, noStr},
	{`^(?:(?:a+)*)$`, onePass, ``},
	{`^[a-c]+$`, onePass, `abc`},
	{`^[a-c]*$`, onePass, `abcdabc`},
	{`^(?:a*)$`, onePass, `aaaaaaa`},
	{`^(?:(?:aa)|a)$`, onePass, `a`},
	{`^[a-c]*`, notOnePass, `abcdabc`},
	{`^[a-c]*$`, onePass, `abc`},
	{`^...$`, onePass, ``},
	{`^(?:a|(?:aa))$`, onePass, `a`},
	{`^[a-c]*`, notOnePass, `abcabc`},
	{`^a((b))c$`, onePass, noStr},
	{`^a.[l-nA-Cg-j]?e$`, onePass, noStr},
	{`^a((b))$`, onePass, noStr},
	{`^a(?:(b)|(c))c$`, onePass, noStr},
	{`^a(?:(b*)|(c))c$`, notOnePass, noStr},
	{`^a(?:b|c)$`, onePass, noStr},
	{`^a(?:b?|c)$`, onePass, noStr},
	{`^a(?:b?|c?)$`, notOnePass, noStr},
	{`^a(?:b?|c+)$`, onePass, noStr},
	{`^a(?:b+|(bc))d$`, notOnePass, noStr},
	{`^a(?:bc)+$`, onePass, noStr},
	{`^a(?:[bcd])+$`, onePass, noStr},
	{`^a((?:[bcd])+)$`, onePass, noStr},
	{`^a(:?b|c)*d$`, onePass, `abbbccbbcbbd"`},
	{`^.bc(d|e)*$`, onePass, `abcddddddeeeededd`},
	{`^(?:(?:aa)|.)$`, notOnePass, `a`},
	{`^(?:(?:a{1,2}){1,2})$`, notOnePass, `aaaa`},
}

func TestCompileOnePass(t *testing.T) {
	var (
		p   *syntax.Prog
		re  *syntax.Regexp
		err error
	)
	for _, test := range onePassTests {
		if re, err = syntax.Parse(test.re, syntax.Perl); err != nil {
			t.Errorf("Parse(%q) got err:%s, want success", test.re, err)
			continue
		}
		// needs to be done before compile...
		re = re.Simplify()
		if p, err = syntax.Compile(re); err != nil {
			t.Errorf("Compile(%q) got err:%s, want success", test.re, err)
			continue
		}
		onePass = compileOnePass(p)
		if (onePass == notOnePass) != (test.onePass == notOnePass) {
			t.Errorf("CompileOnePass(%q) got %v, expected %v", test.re, onePass, test.onePass)
		}
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               root/go1.4/src/regexp/regexp.go                                                                     0100644 0000000 0000000 00000102373 12600426227 014771  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package regexp implements regular expression search.
//
// The syntax of the regular expressions accepted is the same
// general syntax used by Perl, Python, and other languages.
// More precisely, it is the syntax accepted by RE2 and described at
// http://code.google.com/p/re2/wiki/Syntax, except for \C.
// For an overview of the syntax, run
//   godoc regexp/syntax
//
// The regexp implementation provided by this package is
// guaranteed to run in time linear in the size of the input.
// (This is a property not guaranteed by most open source
// implementations of regular expressions.) For more information
// about this property, see
//	http://swtch.com/~rsc/regexp/regexp1.html
// or any book about automata theory.
//
// All characters are UTF-8-encoded code points.
//
// There are 16 methods of Regexp that match a regular expression and identify
// the matched text.  Their names are matched by this regular expression:
//
//	Find(All)?(String)?(Submatch)?(Index)?
//
// If 'All' is present, the routine matches successive non-overlapping
// matches of the entire expression.  Empty matches abutting a preceding
// match are ignored.  The return value is a slice containing the successive
// return values of the corresponding non-'All' routine.  These routines take
// an extra integer argument, n; if n >= 0, the function returns at most n
// matches/submatches.
//
// If 'String' is present, the argument is a string; otherwise it is a slice
// of bytes; return values are adjusted as appropriate.
//
// If 'Submatch' is present, the return value is a slice identifying the
// successive submatches of the expression. Submatches are matches of
// parenthesized subexpressions (also known as capturing groups) within the
// regular expression, numbered from left to right in order of opening
// parenthesis. Submatch 0 is the match of the entire expression, submatch 1
// the match of the first parenthesized subexpression, and so on.
//
// If 'Index' is present, matches and submatches are identified by byte index
// pairs within the input string: result[2*n:2*n+1] identifies the indexes of
// the nth submatch.  The pair for n==0 identifies the match of the entire
// expression.  If 'Index' is not present, the match is identified by the
// text of the match/submatch.  If an index is negative, it means that
// subexpression did not match any string in the input.
//
// There is also a subset of the methods that can be applied to text read
// from a RuneReader:
//
//	MatchReader, FindReaderIndex, FindReaderSubmatchIndex
//
// This set may grow.  Note that regular expression matches may need to
// examine text beyond the text returned by a match, so the methods that
// match text from a RuneReader may read arbitrarily far into the input
// before returning.
//
// (There are a few other methods that do not match this pattern.)
//
package regexp

import (
	"bytes"
	"io"
	"regexp/syntax"
	"strconv"
	"strings"
	"sync"
	"unicode"
	"unicode/utf8"
)

var debug = false

// Regexp is the representation of a compiled regular expression.
// A Regexp is safe for concurrent use by multiple goroutines.
type Regexp struct {
	// read-only after Compile
	expr           string         // as passed to Compile
	prog           *syntax.Prog   // compiled program
	onepass        *onePassProg   // onpass program or nil
	prefix         string         // required prefix in unanchored matches
	prefixBytes    []byte         // prefix, as a []byte
	prefixComplete bool           // prefix is the entire regexp
	prefixRune     rune           // first rune in prefix
	prefixEnd      uint32         // pc for last rune in prefix
	cond           syntax.EmptyOp // empty-width conditions required at start of match
	numSubexp      int
	subexpNames    []string
	longest        bool

	// cache of machines for running regexp
	mu      sync.Mutex
	machine []*machine
}

// String returns the source text used to compile the regular expression.
func (re *Regexp) String() string {
	return re.expr
}

// Compile parses a regular expression and returns, if successful,
// a Regexp object that can be used to match against text.
//
// When matching against text, the regexp returns a match that
// begins as early as possible in the input (leftmost), and among those
// it chooses the one that a backtracking search would have found first.
// This so-called leftmost-first matching is the same semantics
// that Perl, Python, and other implementations use, although this
// package implements it without the expense of backtracking.
// For POSIX leftmost-longest matching, see CompilePOSIX.
func Compile(expr string) (*Regexp, error) {
	return compile(expr, syntax.Perl, false)
}

// CompilePOSIX is like Compile but restricts the regular expression
// to POSIX ERE (egrep) syntax and changes the match semantics to
// leftmost-longest.
//
// That is, when matching against text, the regexp returns a match that
// begins as early as possible in the input (leftmost), and among those
// it chooses a match that is as long as possible.
// This so-called leftmost-longest matching is the same semantics
// that early regular expression implementations used and that POSIX
// specifies.
//
// However, there can be multiple leftmost-longest matches, with different
// submatch choices, and here this package diverges from POSIX.
// Among the possible leftmost-longest matches, this package chooses
// the one that a backtracking search would have found first, while POSIX
// specifies that the match be chosen to maximize the length of the first
// subexpression, then the second, and so on from left to right.
// The POSIX rule is computationally prohibitive and not even well-defined.
// See http://swtch.com/~rsc/regexp/regexp2.html#posix for details.
func CompilePOSIX(expr string) (*Regexp, error) {
	return compile(expr, syntax.POSIX, true)
}

// Longest makes future searches prefer the leftmost-longest match.
// That is, when matching against text, the regexp returns a match that
// begins as early as possible in the input (leftmost), and among those
// it chooses a match that is as long as possible.
func (re *Regexp) Longest() {
	re.longest = true
}

func compile(expr string, mode syntax.Flags, longest bool) (*Regexp, error) {
	re, err := syntax.Parse(expr, mode)
	if err != nil {
		return nil, err
	}
	maxCap := re.MaxCap()
	capNames := re.CapNames()

	re = re.Simplify()
	prog, err := syntax.Compile(re)
	if err != nil {
		return nil, err
	}
	regexp := &Regexp{
		expr:        expr,
		prog:        prog,
		onepass:     compileOnePass(prog),
		numSubexp:   maxCap,
		subexpNames: capNames,
		cond:        prog.StartCond(),
		longest:     longest,
	}
	if regexp.onepass == notOnePass {
		regexp.prefix, regexp.prefixComplete = prog.Prefix()
	} else {
		regexp.prefix, regexp.prefixComplete, regexp.prefixEnd = onePassPrefix(prog)
	}
	if regexp.prefix != "" {
		// TODO(rsc): Remove this allocation by adding
		// IndexString to package bytes.
		regexp.prefixBytes = []byte(regexp.prefix)
		regexp.prefixRune, _ = utf8.DecodeRuneInString(regexp.prefix)
	}
	return regexp, nil
}

// get returns a machine to use for matching re.
// It uses the re's machine cache if possible, to avoid
// unnecessary allocation.
func (re *Regexp) get() *machine {
	re.mu.Lock()
	if n := len(re.machine); n > 0 {
		z := re.machine[n-1]
		re.machine = re.machine[:n-1]
		re.mu.Unlock()
		return z
	}
	re.mu.Unlock()
	z := progMachine(re.prog, re.onepass)
	z.re = re
	return z
}

// put returns a machine to the re's machine cache.
// There is no attempt to limit the size of the cache, so it will
// grow to the maximum number of simultaneous matches
// run using re.  (The cache empties when re gets garbage collected.)
func (re *Regexp) put(z *machine) {
	re.mu.Lock()
	re.machine = append(re.machine, z)
	re.mu.Unlock()
}

// MustCompile is like Compile but panics if the expression cannot be parsed.
// It simplifies safe initialization of global variables holding compiled regular
// expressions.
func MustCompile(str string) *Regexp {
	regexp, error := Compile(str)
	if error != nil {
		panic(`regexp: Compile(` + quote(str) + `): ` + error.Error())
	}
	return regexp
}

// MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed.
// It simplifies safe initialization of global variables holding compiled regular
// expressions.
func MustCompilePOSIX(str string) *Regexp {
	regexp, error := CompilePOSIX(str)
	if error != nil {
		panic(`regexp: CompilePOSIX(` + quote(str) + `): ` + error.Error())
	}
	return regexp
}

func quote(s string) string {
	if strconv.CanBackquote(s) {
		return "`" + s + "`"
	}
	return strconv.Quote(s)
}

// NumSubexp returns the number of parenthesized subexpressions in this Regexp.
func (re *Regexp) NumSubexp() int {
	return re.numSubexp
}

// SubexpNames returns the names of the parenthesized subexpressions
// in this Regexp.  The name for the first sub-expression is names[1],
// so that if m is a match slice, the name for m[i] is SubexpNames()[i].
// Since the Regexp as a whole cannot be named, names[0] is always
// the empty string.  The slice should not be modified.
func (re *Regexp) SubexpNames() []string {
	return re.subexpNames
}

const endOfText rune = -1

// input abstracts different representations of the input text. It provides
// one-character lookahead.
type input interface {
	step(pos int) (r rune, width int) // advance one rune
	canCheckPrefix() bool             // can we look ahead without losing info?
	hasPrefix(re *Regexp) bool
	index(re *Regexp, pos int) int
	context(pos int) syntax.EmptyOp
}

// inputString scans a string.
type inputString struct {
	str string
}

func (i *inputString) step(pos int) (rune, int) {
	if pos < len(i.str) {
		c := i.str[pos]
		if c < utf8.RuneSelf {
			return rune(c), 1
		}
		return utf8.DecodeRuneInString(i.str[pos:])
	}
	return endOfText, 0
}

func (i *inputString) canCheckPrefix() bool {
	return true
}

func (i *inputString) hasPrefix(re *Regexp) bool {
	return strings.HasPrefix(i.str, re.prefix)
}

func (i *inputString) index(re *Regexp, pos int) int {
	return strings.Index(i.str[pos:], re.prefix)
}

func (i *inputString) context(pos int) syntax.EmptyOp {
	r1, r2 := endOfText, endOfText
	if pos > 0 && pos <= len(i.str) {
		r1, _ = utf8.DecodeLastRuneInString(i.str[:pos])
	}
	if pos < len(i.str) {
		r2, _ = utf8.DecodeRuneInString(i.str[pos:])
	}
	return syntax.EmptyOpContext(r1, r2)
}

// inputBytes scans a byte slice.
type inputBytes struct {
	str []byte
}

func (i *inputBytes) step(pos int) (rune, int) {
	if pos < len(i.str) {
		c := i.str[pos]
		if c < utf8.RuneSelf {
			return rune(c), 1
		}
		return utf8.DecodeRune(i.str[pos:])
	}
	return endOfText, 0
}

func (i *inputBytes) canCheckPrefix() bool {
	return true
}

func (i *inputBytes) hasPrefix(re *Regexp) bool {
	return bytes.HasPrefix(i.str, re.prefixBytes)
}

func (i *inputBytes) index(re *Regexp, pos int) int {
	return bytes.Index(i.str[pos:], re.prefixBytes)
}

func (i *inputBytes) context(pos int) syntax.EmptyOp {
	r1, r2 := endOfText, endOfText
	if pos > 0 && pos <= len(i.str) {
		r1, _ = utf8.DecodeLastRune(i.str[:pos])
	}
	if pos < len(i.str) {
		r2, _ = utf8.DecodeRune(i.str[pos:])
	}
	return syntax.EmptyOpContext(r1, r2)
}

// inputReader scans a RuneReader.
type inputReader struct {
	r     io.RuneReader
	atEOT bool
	pos   int
}

func (i *inputReader) step(pos int) (rune, int) {
	if !i.atEOT && pos != i.pos {
		return endOfText, 0

	}
	r, w, err := i.r.ReadRune()
	if err != nil {
		i.atEOT = true
		return endOfText, 0
	}
	i.pos += w
	return r, w
}

func (i *inputReader) canCheckPrefix() bool {
	return false
}

func (i *inputReader) hasPrefix(re *Regexp) bool {
	return false
}

func (i *inputReader) index(re *Regexp, pos int) int {
	return -1
}

func (i *inputReader) context(pos int) syntax.EmptyOp {
	return 0
}

// LiteralPrefix returns a literal string that must begin any match
// of the regular expression re.  It returns the boolean true if the
// literal string comprises the entire regular expression.
func (re *Regexp) LiteralPrefix() (prefix string, complete bool) {
	return re.prefix, re.prefixComplete
}

// MatchReader reports whether the Regexp matches the text read by the
// RuneReader.
func (re *Regexp) MatchReader(r io.RuneReader) bool {
	return re.doExecute(r, nil, "", 0, 0) != nil
}

// MatchString reports whether the Regexp matches the string s.
func (re *Regexp) MatchString(s string) bool {
	return re.doExecute(nil, nil, s, 0, 0) != nil
}

// Match reports whether the Regexp matches the byte slice b.
func (re *Regexp) Match(b []byte) bool {
	return re.doExecute(nil, b, "", 0, 0) != nil
}

// MatchReader checks whether a textual regular expression matches the text
// read by the RuneReader.  More complicated queries need to use Compile and
// the full Regexp interface.
func MatchReader(pattern string, r io.RuneReader) (matched bool, err error) {
	re, err := Compile(pattern)
	if err != nil {
		return false, err
	}
	return re.MatchReader(r), nil
}

// MatchString checks whether a textual regular expression
// matches a string.  More complicated queries need
// to use Compile and the full Regexp interface.
func MatchString(pattern string, s string) (matched bool, err error) {
	re, err := Compile(pattern)
	if err != nil {
		return false, err
	}
	return re.MatchString(s), nil
}

// Match checks whether a textual regular expression
// matches a byte slice.  More complicated queries need
// to use Compile and the full Regexp interface.
func Match(pattern string, b []byte) (matched bool, err error) {
	re, err := Compile(pattern)
	if err != nil {
		return false, err
	}
	return re.Match(b), nil
}

// ReplaceAllString returns a copy of src, replacing matches of the Regexp
// with the replacement string repl.  Inside repl, $ signs are interpreted as
// in Expand, so for instance $1 represents the text of the first submatch.
func (re *Regexp) ReplaceAllString(src, repl string) string {
	n := 2
	if strings.Index(repl, "$") >= 0 {
		n = 2 * (re.numSubexp + 1)
	}
	b := re.replaceAll(nil, src, n, func(dst []byte, match []int) []byte {
		return re.expand(dst, repl, nil, src, match)
	})
	return string(b)
}

// ReplaceAllLiteralString returns a copy of src, replacing matches of the Regexp
// with the replacement string repl.  The replacement repl is substituted directly,
// without using Expand.
func (re *Regexp) ReplaceAllLiteralString(src, repl string) string {
	return string(re.replaceAll(nil, src, 2, func(dst []byte, match []int) []byte {
		return append(dst, repl...)
	}))
}

// ReplaceAllStringFunc returns a copy of src in which all matches of the
// Regexp have been replaced by the return value of function repl applied
// to the matched substring.  The replacement returned by repl is substituted
// directly, without using Expand.
func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string {
	b := re.replaceAll(nil, src, 2, func(dst []byte, match []int) []byte {
		return append(dst, repl(src[match[0]:match[1]])...)
	})
	return string(b)
}

func (re *Regexp) replaceAll(bsrc []byte, src string, nmatch int, repl func(dst []byte, m []int) []byte) []byte {
	lastMatchEnd := 0 // end position of the most recent match
	searchPos := 0    // position where we next look for a match
	var buf []byte
	var endPos int
	if bsrc != nil {
		endPos = len(bsrc)
	} else {
		endPos = len(src)
	}
	for searchPos <= endPos {
		a := re.doExecute(nil, bsrc, src, searchPos, nmatch)
		if len(a) == 0 {
			break // no more matches
		}

		// Copy the unmatched characters before this match.
		if bsrc != nil {
			buf = append(buf, bsrc[lastMatchEnd:a[0]]...)
		} else {
			buf = append(buf, src[lastMatchEnd:a[0]]...)
		}

		// Now insert a copy of the replacement string, but not for a
		// match of the empty string immediately after another match.
		// (Otherwise, we get double replacement for patterns that
		// match both empty and nonempty strings.)
		if a[1] > lastMatchEnd || a[0] == 0 {
			buf = repl(buf, a)
		}
		lastMatchEnd = a[1]

		// Advance past this match; always advance at least one character.
		var width int
		if bsrc != nil {
			_, width = utf8.DecodeRune(bsrc[searchPos:])
		} else {
			_, width = utf8.DecodeRuneInString(src[searchPos:])
		}
		if searchPos+width > a[1] {
			searchPos += width
		} else if searchPos+1 > a[1] {
			// This clause is only needed at the end of the input
			// string.  In that case, DecodeRuneInString returns width=0.
			searchPos++
		} else {
			searchPos = a[1]
		}
	}

	// Copy the unmatched characters after the last match.
	if bsrc != nil {
		buf = append(buf, bsrc[lastMatchEnd:]...)
	} else {
		buf = append(buf, src[lastMatchEnd:]...)
	}

	return buf
}

// ReplaceAll returns a copy of src, replacing matches of the Regexp
// with the replacement text repl.  Inside repl, $ signs are interpreted as
// in Expand, so for instance $1 represents the text of the first submatch.
func (re *Regexp) ReplaceAll(src, repl []byte) []byte {
	n := 2
	if bytes.IndexByte(repl, '$') >= 0 {
		n = 2 * (re.numSubexp + 1)
	}
	srepl := ""
	b := re.replaceAll(src, "", n, func(dst []byte, match []int) []byte {
		if len(srepl) != len(repl) {
			srepl = string(repl)
		}
		return re.expand(dst, srepl, src, "", match)
	})
	return b
}

// ReplaceAllLiteral returns a copy of src, replacing matches of the Regexp
// with the replacement bytes repl.  The replacement repl is substituted directly,
// without using Expand.
func (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte {
	return re.replaceAll(src, "", 2, func(dst []byte, match []int) []byte {
		return append(dst, repl...)
	})
}

// ReplaceAllFunc returns a copy of src in which all matches of the
// Regexp have been replaced by the return value of function repl applied
// to the matched byte slice.  The replacement returned by repl is substituted
// directly, without using Expand.
func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte {
	return re.replaceAll(src, "", 2, func(dst []byte, match []int) []byte {
		return append(dst, repl(src[match[0]:match[1]])...)
	})
}

var specialBytes = []byte(`\.+*?()|[]{}^$`)

func special(b byte) bool {
	return bytes.IndexByte(specialBytes, b) >= 0
}

// QuoteMeta returns a string that quotes all regular expression metacharacters
// inside the argument text; the returned string is a regular expression matching
// the literal text.  For example, QuoteMeta(`[foo]`) returns `\[foo\]`.
func QuoteMeta(s string) string {
	b := make([]byte, 2*len(s))

	// A byte loop is correct because all metacharacters are ASCII.
	j := 0
	for i := 0; i < len(s); i++ {
		if special(s[i]) {
			b[j] = '\\'
			j++
		}
		b[j] = s[i]
		j++
	}
	return string(b[0:j])
}

// The number of capture values in the program may correspond
// to fewer capturing expressions than are in the regexp.
// For example, "(a){0}" turns into an empty program, so the
// maximum capture in the program is 0 but we need to return
// an expression for \1.  Pad appends -1s to the slice a as needed.
func (re *Regexp) pad(a []int) []int {
	if a == nil {
		// No match.
		return nil
	}
	n := (1 + re.numSubexp) * 2
	for len(a) < n {
		a = append(a, -1)
	}
	return a
}

// Find matches in slice b if b is non-nil, otherwise find matches in string s.
func (re *Regexp) allMatches(s string, b []byte, n int, deliver func([]int)) {
	var end int
	if b == nil {
		end = len(s)
	} else {
		end = len(b)
	}

	for pos, i, prevMatchEnd := 0, 0, -1; i < n && pos <= end; {
		matches := re.doExecute(nil, b, s, pos, re.prog.NumCap)
		if len(matches) == 0 {
			break
		}

		accept := true
		if matches[1] == pos {
			// We've found an empty match.
			if matches[0] == prevMatchEnd {
				// We don't allow an empty match right
				// after a previous match, so ignore it.
				accept = false
			}
			var width int
			// TODO: use step()
			if b == nil {
				_, width = utf8.DecodeRuneInString(s[pos:end])
			} else {
				_, width = utf8.DecodeRune(b[pos:end])
			}
			if width > 0 {
				pos += width
			} else {
				pos = end + 1
			}
		} else {
			pos = matches[1]
		}
		prevMatchEnd = matches[1]

		if accept {
			deliver(re.pad(matches))
			i++
		}
	}
}

// Find returns a slice holding the text of the leftmost match in b of the regular expression.
// A return value of nil indicates no match.
func (re *Regexp) Find(b []byte) []byte {
	a := re.doExecute(nil, b, "", 0, 2)
	if a == nil {
		return nil
	}
	return b[a[0]:a[1]]
}

// FindIndex returns a two-element slice of integers defining the location of
// the leftmost match in b of the regular expression.  The match itself is at
// b[loc[0]:loc[1]].
// A return value of nil indicates no match.
func (re *Regexp) FindIndex(b []byte) (loc []int) {
	a := re.doExecute(nil, b, "", 0, 2)
	if a == nil {
		return nil
	}
	return a[0:2]
}

// FindString returns a string holding the text of the leftmost match in s of the regular
// expression.  If there is no match, the return value is an empty string,
// but it will also be empty if the regular expression successfully matches
// an empty string.  Use FindStringIndex or FindStringSubmatch if it is
// necessary to distinguish these cases.
func (re *Regexp) FindString(s string) string {
	a := re.doExecute(nil, nil, s, 0, 2)
	if a == nil {
		return ""
	}
	return s[a[0]:a[1]]
}

// FindStringIndex returns a two-element slice of integers defining the
// location of the leftmost match in s of the regular expression.  The match
// itself is at s[loc[0]:loc[1]].
// A return value of nil indicates no match.
func (re *Regexp) FindStringIndex(s string) (loc []int) {
	a := re.doExecute(nil, nil, s, 0, 2)
	if a == nil {
		return nil
	}
	return a[0:2]
}

// FindReaderIndex returns a two-element slice of integers defining the
// location of the leftmost match of the regular expression in text read from
// the RuneReader.  The match text was found in the input stream at
// byte offset loc[0] through loc[1]-1.
// A return value of nil indicates no match.
func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int) {
	a := re.doExecute(r, nil, "", 0, 2)
	if a == nil {
		return nil
	}
	return a[0:2]
}

// FindSubmatch returns a slice of slices holding the text of the leftmost
// match of the regular expression in b and the matches, if any, of its
// subexpressions, as defined by the 'Submatch' descriptions in the package
// comment.
// A return value of nil indicates no match.
func (re *Regexp) FindSubmatch(b []byte) [][]byte {
	a := re.doExecute(nil, b, "", 0, re.prog.NumCap)
	if a == nil {
		return nil
	}
	ret := make([][]byte, 1+re.numSubexp)
	for i := range ret {
		if 2*i < len(a) && a[2*i] >= 0 {
			ret[i] = b[a[2*i]:a[2*i+1]]
		}
	}
	return ret
}

// Expand appends template to dst and returns the result; during the
// append, Expand replaces variables in the template with corresponding
// matches drawn from src.  The match slice should have been returned by
// FindSubmatchIndex.
//
// In the template, a variable is denoted by a substring of the form
// $name or ${name}, where name is a non-empty sequence of letters,
// digits, and underscores.  A purely numeric name like $1 refers to
// the submatch with the corresponding index; other names refer to
// capturing parentheses named with the (?P<name>...) syntax.  A
// reference to an out of range or unmatched index or a name that is not
// present in the regular expression is replaced with an empty slice.
//
// In the $name form, name is taken to be as long as possible: $1x is
// equivalent to ${1x}, not ${1}x, and, $10 is equivalent to ${10}, not ${1}0.
//
// To insert a literal $ in the output, use $$ in the template.
func (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte {
	return re.expand(dst, string(template), src, "", match)
}

// ExpandString is like Expand but the template and source are strings.
// It appends to and returns a byte slice in order to give the calling
// code control over allocation.
func (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []byte {
	return re.expand(dst, template, nil, src, match)
}

func (re *Regexp) expand(dst []byte, template string, bsrc []byte, src string, match []int) []byte {
	for len(template) > 0 {
		i := strings.Index(template, "$")
		if i < 0 {
			break
		}
		dst = append(dst, template[:i]...)
		template = template[i:]
		if len(template) > 1 && template[1] == '$' {
			// Treat $$ as $.
			dst = append(dst, '$')
			template = template[2:]
			continue
		}
		name, num, rest, ok := extract(template)
		if !ok {
			// Malformed; treat $ as raw text.
			dst = append(dst, '$')
			template = template[1:]
			continue
		}
		template = rest
		if num >= 0 {
			if 2*num+1 < len(match) && match[2*num] >= 0 {
				if bsrc != nil {
					dst = append(dst, bsrc[match[2*num]:match[2*num+1]]...)
				} else {
					dst = append(dst, src[match[2*num]:match[2*num+1]]...)
				}
			}
		} else {
			for i, namei := range re.subexpNames {
				if name == namei && 2*i+1 < len(match) && match[2*i] >= 0 {
					if bsrc != nil {
						dst = append(dst, bsrc[match[2*i]:match[2*i+1]]...)
					} else {
						dst = append(dst, src[match[2*i]:match[2*i+1]]...)
					}
					break
				}
			}
		}
	}
	dst = append(dst, template...)
	return dst
}

// extract returns the name from a leading "$name" or "${name}" in str.
// If it is a number, extract returns num set to that number; otherwise num = -1.
func extract(str string) (name string, num int, rest string, ok bool) {
	if len(str) < 2 || str[0] != '$' {
		return
	}
	brace := false
	if str[1] == '{' {
		brace = true
		str = str[2:]
	} else {
		str = str[1:]
	}
	i := 0
	for i < len(str) {
		rune, size := utf8.DecodeRuneInString(str[i:])
		if !unicode.IsLetter(rune) && !unicode.IsDigit(rune) && rune != '_' {
			break
		}
		i += size
	}
	if i == 0 {
		// empty name is not okay
		return
	}
	name = str[:i]
	if brace {
		if i >= len(str) || str[i] != '}' {
			// missing closing brace
			return
		}
		i++
	}

	// Parse number.
	num = 0
	for i := 0; i < len(name); i++ {
		if name[i] < '0' || '9' < name[i] || num >= 1e8 {
			num = -1
			break
		}
		num = num*10 + int(name[i]) - '0'
	}
	// Disallow leading zeros.
	if name[0] == '0' && len(name) > 1 {
		num = -1
	}

	rest = str[i:]
	ok = true
	return
}

// FindSubmatchIndex returns a slice holding the index pairs identifying the
// leftmost match of the regular expression in b and the matches, if any, of
// its subexpressions, as defined by the 'Submatch' and 'Index' descriptions
// in the package comment.
// A return value of nil indicates no match.
func (re *Regexp) FindSubmatchIndex(b []byte) []int {
	return re.pad(re.doExecute(nil, b, "", 0, re.prog.NumCap))
}

// FindStringSubmatch returns a slice of strings holding the text of the
// leftmost match of the regular expression in s and the matches, if any, of
// its subexpressions, as defined by the 'Submatch' description in the
// package comment.
// A return value of nil indicates no match.
func (re *Regexp) FindStringSubmatch(s string) []string {
	a := re.doExecute(nil, nil, s, 0, re.prog.NumCap)
	if a == nil {
		return nil
	}
	ret := make([]string, 1+re.numSubexp)
	for i := range ret {
		if 2*i < len(a) && a[2*i] >= 0 {
			ret[i] = s[a[2*i]:a[2*i+1]]
		}
	}
	return ret
}

// FindStringSubmatchIndex returns a slice holding the index pairs
// identifying the leftmost match of the regular expression in s and the
// matches, if any, of its subexpressions, as defined by the 'Submatch' and
// 'Index' descriptions in the package comment.
// A return value of nil indicates no match.
func (re *Regexp) FindStringSubmatchIndex(s string) []int {
	return re.pad(re.doExecute(nil, nil, s, 0, re.prog.NumCap))
}

// FindReaderSubmatchIndex returns a slice holding the index pairs
// identifying the leftmost match of the regular expression of text read by
// the RuneReader, and the matches, if any, of its subexpressions, as defined
// by the 'Submatch' and 'Index' descriptions in the package comment.  A
// return value of nil indicates no match.
func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int {
	return re.pad(re.doExecute(r, nil, "", 0, re.prog.NumCap))
}

const startSize = 10 // The size at which to start a slice in the 'All' routines.

// FindAll is the 'All' version of Find; it returns a slice of all successive
// matches of the expression, as defined by the 'All' description in the
// package comment.
// A return value of nil indicates no match.
func (re *Regexp) FindAll(b []byte, n int) [][]byte {
	if n < 0 {
		n = len(b) + 1
	}
	result := make([][]byte, 0, startSize)
	re.allMatches("", b, n, func(match []int) {
		result = append(result, b[match[0]:match[1]])
	})
	if len(result) == 0 {
		return nil
	}
	return result
}

// FindAllIndex is the 'All' version of FindIndex; it returns a slice of all
// successive matches of the expression, as defined by the 'All' description
// in the package comment.
// A return value of nil indicates no match.
func (re *Regexp) FindAllIndex(b []byte, n int) [][]int {
	if n < 0 {
		n = len(b) + 1
	}
	result := make([][]int, 0, startSize)
	re.allMatches("", b, n, func(match []int) {
		result = append(result, match[0:2])
	})
	if len(result) == 0 {
		return nil
	}
	return result
}

// FindAllString is the 'All' version of FindString; it returns a slice of all
// successive matches of the expression, as defined by the 'All' description
// in the package comment.
// A return value of nil indicates no match.
func (re *Regexp) FindAllString(s string, n int) []string {
	if n < 0 {
		n = len(s) + 1
	}
	result := make([]string, 0, startSize)
	re.allMatches(s, nil, n, func(match []int) {
		result = append(result, s[match[0]:match[1]])
	})
	if len(result) == 0 {
		return nil
	}
	return result
}

// FindAllStringIndex is the 'All' version of FindStringIndex; it returns a
// slice of all successive matches of the expression, as defined by the 'All'
// description in the package comment.
// A return value of nil indicates no match.
func (re *Regexp) FindAllStringIndex(s string, n int) [][]int {
	if n < 0 {
		n = len(s) + 1
	}
	result := make([][]int, 0, startSize)
	re.allMatches(s, nil, n, func(match []int) {
		result = append(result, match[0:2])
	})
	if len(result) == 0 {
		return nil
	}
	return result
}

// FindAllSubmatch is the 'All' version of FindSubmatch; it returns a slice
// of all successive matches of the expression, as defined by the 'All'
// description in the package comment.
// A return value of nil indicates no match.
func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte {
	if n < 0 {
		n = len(b) + 1
	}
	result := make([][][]byte, 0, startSize)
	re.allMatches("", b, n, func(match []int) {
		slice := make([][]byte, len(match)/2)
		for j := range slice {
			if match[2*j] >= 0 {
				slice[j] = b[match[2*j]:match[2*j+1]]
			}
		}
		result = append(result, slice)
	})
	if len(result) == 0 {
		return nil
	}
	return result
}

// FindAllSubmatchIndex is the 'All' version of FindSubmatchIndex; it returns
// a slice of all successive matches of the expression, as defined by the
// 'All' description in the package comment.
// A return value of nil indicates no match.
func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int {
	if n < 0 {
		n = len(b) + 1
	}
	result := make([][]int, 0, startSize)
	re.allMatches("", b, n, func(match []int) {
		result = append(result, match)
	})
	if len(result) == 0 {
		return nil
	}
	return result
}

// FindAllStringSubmatch is the 'All' version of FindStringSubmatch; it
// returns a slice of all successive matches of the expression, as defined by
// the 'All' description in the package comment.
// A return value of nil indicates no match.
func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string {
	if n < 0 {
		n = len(s) + 1
	}
	result := make([][]string, 0, startSize)
	re.allMatches(s, nil, n, func(match []int) {
		slice := make([]string, len(match)/2)
		for j := range slice {
			if match[2*j] >= 0 {
				slice[j] = s[match[2*j]:match[2*j+1]]
			}
		}
		result = append(result, slice)
	})
	if len(result) == 0 {
		return nil
	}
	return result
}

// FindAllStringSubmatchIndex is the 'All' version of
// FindStringSubmatchIndex; it returns a slice of all successive matches of
// the expression, as defined by the 'All' description in the package
// comment.
// A return value of nil indicates no match.
func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int {
	if n < 0 {
		n = len(s) + 1
	}
	result := make([][]int, 0, startSize)
	re.allMatches(s, nil, n, func(match []int) {
		result = append(result, match)
	})
	if len(result) == 0 {
		return nil
	}
	return result
}

// Split slices s into substrings separated by the expression and returns a slice of
// the substrings between those expression matches.
//
// The slice returned by this method consists of all the substrings of s
// not contained in the slice returned by FindAllString. When called on an expression
// that contains no metacharacters, it is equivalent to strings.SplitN.
//
// Example:
//   s := regexp.MustCompile("a*").Split("abaabaccadaaae", 5)
//   // s: ["", "b", "b", "c", "cadaaae"]
//
// The count determines the number of substrings to return:
//   n > 0: at most n substrings; the last substring will be the unsplit remainder.
//   n == 0: the result is nil (zero substrings)
//   n < 0: all substrings
func (re *Regexp) Split(s string, n int) []string {

	if n == 0 {
		return nil
	}

	if len(re.expr) > 0 && len(s) == 0 {
		return []string{""}
	}

	matches := re.FindAllStringIndex(s, n)
	strings := make([]string, 0, len(matches))

	beg := 0
	end := 0
	for _, match := range matches {
		if n > 0 && len(strings) >= n-1 {
			break
		}

		end = match[0]
		if match[1] != 0 {
			strings = append(strings, s[beg:end])
		}
		beg = match[1]
	}

	if end != len(s) {
		strings = append(strings, s[beg:])
	}

	return strings
}
                                                                                                                                                                                                                                                                     root/go1.4/src/regexp/syntax/                                                                       0040755 0000000 0000000 00000000000 12600426244 014472  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/regexp/syntax/compile.go                                                             0100644 0000000 0000000 00000014177 12600426227 016461  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package syntax

import "unicode"

// A patchList is a list of instruction pointers that need to be filled in (patched).
// Because the pointers haven't been filled in yet, we can reuse their storage
// to hold the list.  It's kind of sleazy, but works well in practice.
// See http://swtch.com/~rsc/regexp/regexp1.html for inspiration.
//
// These aren't really pointers: they're integers, so we can reinterpret them
// this way without using package unsafe.  A value l denotes
// p.inst[l>>1].Out (l&1==0) or .Arg (l&1==1).
// l == 0 denotes the empty list, okay because we start every program
// with a fail instruction, so we'll never want to point at its output link.
type patchList uint32

func (l patchList) next(p *Prog) patchList {
	i := &p.Inst[l>>1]
	if l&1 == 0 {
		return patchList(i.Out)
	}
	return patchList(i.Arg)
}

func (l patchList) patch(p *Prog, val uint32) {
	for l != 0 {
		i := &p.Inst[l>>1]
		if l&1 == 0 {
			l = patchList(i.Out)
			i.Out = val
		} else {
			l = patchList(i.Arg)
			i.Arg = val
		}
	}
}

func (l1 patchList) append(p *Prog, l2 patchList) patchList {
	if l1 == 0 {
		return l2
	}
	if l2 == 0 {
		return l1
	}

	last := l1
	for {
		next := last.next(p)
		if next == 0 {
			break
		}
		last = next
	}

	i := &p.Inst[last>>1]
	if last&1 == 0 {
		i.Out = uint32(l2)
	} else {
		i.Arg = uint32(l2)
	}
	return l1
}

// A frag represents a compiled program fragment.
type frag struct {
	i   uint32    // index of first instruction
	out patchList // where to record end instruction
}

type compiler struct {
	p *Prog
}

// Compile compiles the regexp into a program to be executed.
// The regexp should have been simplified already (returned from re.Simplify).
func Compile(re *Regexp) (*Prog, error) {
	var c compiler
	c.init()
	f := c.compile(re)
	f.out.patch(c.p, c.inst(InstMatch).i)
	c.p.Start = int(f.i)
	return c.p, nil
}

func (c *compiler) init() {
	c.p = new(Prog)
	c.p.NumCap = 2 // implicit ( and ) for whole match $0
	c.inst(InstFail)
}

var anyRuneNotNL = []rune{0, '\n' - 1, '\n' + 1, unicode.MaxRune}
var anyRune = []rune{0, unicode.MaxRune}

func (c *compiler) compile(re *Regexp) frag {
	switch re.Op {
	case OpNoMatch:
		return c.fail()
	case OpEmptyMatch:
		return c.nop()
	case OpLiteral:
		if len(re.Rune) == 0 {
			return c.nop()
		}
		var f frag
		for j := range re.Rune {
			f1 := c.rune(re.Rune[j:j+1], re.Flags)
			if j == 0 {
				f = f1
			} else {
				f = c.cat(f, f1)
			}
		}
		return f
	case OpCharClass:
		return c.rune(re.Rune, re.Flags)
	case OpAnyCharNotNL:
		return c.rune(anyRuneNotNL, 0)
	case OpAnyChar:
		return c.rune(anyRune, 0)
	case OpBeginLine:
		return c.empty(EmptyBeginLine)
	case OpEndLine:
		return c.empty(EmptyEndLine)
	case OpBeginText:
		return c.empty(EmptyBeginText)
	case OpEndText:
		return c.empty(EmptyEndText)
	case OpWordBoundary:
		return c.empty(EmptyWordBoundary)
	case OpNoWordBoundary:
		return c.empty(EmptyNoWordBoundary)
	case OpCapture:
		bra := c.cap(uint32(re.Cap << 1))
		sub := c.compile(re.Sub[0])
		ket := c.cap(uint32(re.Cap<<1 | 1))
		return c.cat(c.cat(bra, sub), ket)
	case OpStar:
		return c.star(c.compile(re.Sub[0]), re.Flags&NonGreedy != 0)
	case OpPlus:
		return c.plus(c.compile(re.Sub[0]), re.Flags&NonGreedy != 0)
	case OpQuest:
		return c.quest(c.compile(re.Sub[0]), re.Flags&NonGreedy != 0)
	case OpConcat:
		if len(re.Sub) == 0 {
			return c.nop()
		}
		var f frag
		for i, sub := range re.Sub {
			if i == 0 {
				f = c.compile(sub)
			} else {
				f = c.cat(f, c.compile(sub))
			}
		}
		return f
	case OpAlternate:
		var f frag
		for _, sub := range re.Sub {
			f = c.alt(f, c.compile(sub))
		}
		return f
	}
	panic("regexp: unhandled case in compile")
}

func (c *compiler) inst(op InstOp) frag {
	// TODO: impose length limit
	f := frag{i: uint32(len(c.p.Inst))}
	c.p.Inst = append(c.p.Inst, Inst{Op: op})
	return f
}

func (c *compiler) nop() frag {
	f := c.inst(InstNop)
	f.out = patchList(f.i << 1)
	return f
}

func (c *compiler) fail() frag {
	return frag{}
}

func (c *compiler) cap(arg uint32) frag {
	f := c.inst(InstCapture)
	f.out = patchList(f.i << 1)
	c.p.Inst[f.i].Arg = arg

	if c.p.NumCap < int(arg)+1 {
		c.p.NumCap = int(arg) + 1
	}
	return f
}

func (c *compiler) cat(f1, f2 frag) frag {
	// concat of failure is failure
	if f1.i == 0 || f2.i == 0 {
		return frag{}
	}

	// TODO: elide nop

	f1.out.patch(c.p, f2.i)
	return frag{f1.i, f2.out}
}

func (c *compiler) alt(f1, f2 frag) frag {
	// alt of failure is other
	if f1.i == 0 {
		return f2
	}
	if f2.i == 0 {
		return f1
	}

	f := c.inst(InstAlt)
	i := &c.p.Inst[f.i]
	i.Out = f1.i
	i.Arg = f2.i
	f.out = f1.out.append(c.p, f2.out)
	return f
}

func (c *compiler) quest(f1 frag, nongreedy bool) frag {
	f := c.inst(InstAlt)
	i := &c.p.Inst[f.i]
	if nongreedy {
		i.Arg = f1.i
		f.out = patchList(f.i << 1)
	} else {
		i.Out = f1.i
		f.out = patchList(f.i<<1 | 1)
	}
	f.out = f.out.append(c.p, f1.out)
	return f
}

func (c *compiler) star(f1 frag, nongreedy bool) frag {
	f := c.inst(InstAlt)
	i := &c.p.Inst[f.i]
	if nongreedy {
		i.Arg = f1.i
		f.out = patchList(f.i << 1)
	} else {
		i.Out = f1.i
		f.out = patchList(f.i<<1 | 1)
	}
	f1.out.patch(c.p, f.i)
	return f
}

func (c *compiler) plus(f1 frag, nongreedy bool) frag {
	return frag{f1.i, c.star(f1, nongreedy).out}
}

func (c *compiler) empty(op EmptyOp) frag {
	f := c.inst(InstEmptyWidth)
	c.p.Inst[f.i].Arg = uint32(op)
	f.out = patchList(f.i << 1)
	return f
}

func (c *compiler) rune(r []rune, flags Flags) frag {
	f := c.inst(InstRune)
	i := &c.p.Inst[f.i]
	i.Rune = r
	flags &= FoldCase // only relevant flag is FoldCase
	if len(r) != 1 || unicode.SimpleFold(r[0]) == r[0] {
		// and sometimes not even that
		flags &^= FoldCase
	}
	i.Arg = uint32(flags)
	f.out = patchList(f.i << 1)

	// Special cases for exec machine.
	switch {
	case flags&FoldCase == 0 && (len(r) == 1 || len(r) == 2 && r[0] == r[1]):
		i.Op = InstRune1
	case len(r) == 2 && r[0] == 0 && r[1] == unicode.MaxRune:
		i.Op = InstRuneAny
	case len(r) == 4 && r[0] == 0 && r[1] == '\n'-1 && r[2] == '\n'+1 && r[3] == unicode.MaxRune:
		i.Op = InstRuneAnyNotNL
	}

	return f
}
                                                                                                                                                                                                                                                                                                                                                                                                 root/go1.4/src/regexp/syntax/doc.go                                                                 0100644 0000000 0000000 00000012425 12600426227 015570  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2012 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// DO NOT EDIT. This file is generated by mksyntaxgo from the RE2 distribution.

/*
Package syntax parses regular expressions into parse trees and compiles
parse trees into programs. Most clients of regular expressions will use the
facilities of package regexp (such as Compile and Match) instead of this package.

Syntax

The regular expression syntax understood by this package when parsing with the Perl flag is as follows.
Parts of the syntax can be disabled by passing alternate flags to Parse.


Single characters:
  .              any character, possibly including newline (flag s=true)
  [xyz]          character class
  [^xyz]         negated character class
  \d             Perl character class
  \D             negated Perl character class
  [[:alpha:]]    ASCII character class
  [[:^alpha:]]   negated ASCII character class
  \pN            Unicode character class (one-letter name)
  \p{Greek}      Unicode character class
  \PN            negated Unicode character class (one-letter name)
  \P{Greek}      negated Unicode character class

Composites:
  xy             x followed by y
  x|y            x or y (prefer x)

Repetitions:
  x*             zero or more x, prefer more
  x+             one or more x, prefer more
  x?             zero or one x, prefer one
  x{n,m}         n or n+1 or ... or m x, prefer more
  x{n,}          n or more x, prefer more
  x{n}           exactly n x
  x*?            zero or more x, prefer fewer
  x+?            one or more x, prefer fewer
  x??            zero or one x, prefer zero
  x{n,m}?        n or n+1 or ... or m x, prefer fewer
  x{n,}?         n or more x, prefer fewer
  x{n}?          exactly n x

Implementation restriction: The counting forms x{n,m}, x{n,}, and x{n}
reject forms that create a minimum or maximum repetition count above 1000.
Unlimited repetitions are not subject to this restriction.

Grouping:
  (re)           numbered capturing group (submatch)
  (?P<name>re)   named & numbered capturing group (submatch)
  (?:re)         non-capturing group
  (?flags)       set flags within current group; non-capturing
  (?flags:re)    set flags during re; non-capturing

  Flag syntax is xyz (set) or -xyz (clear) or xy-z (set xy, clear z). The flags are:

  i              case-insensitive (default false)
  m              multi-line mode: ^ and $ match begin/end line in addition to begin/end text (default false)
  s              let . match \n (default false)
  U              ungreedy: swap meaning of x* and x*?, x+ and x+?, etc (default false)

Empty strings:
  ^              at beginning of text or line (flag m=true)
  $              at end of text (like \z not \Z) or line (flag m=true)
  \A             at beginning of text
  \b             at ASCII word boundary (\w on one side and \W, \A, or \z on the other)
  \B             not at ASCII word boundary
  \z             at end of text

Escape sequences:
  \a             bell (== \007)
  \f             form feed (== \014)
  \t             horizontal tab (== \011)
  \n             newline (== \012)
  \r             carriage return (== \015)
  \v             vertical tab character (== \013)
  \*             literal *, for any punctuation character *
  \123           octal character code (up to three digits)
  \x7F           hex character code (exactly two digits)
  \x{10FFFF}     hex character code
  \Q...\E        literal text ... even if ... has punctuation

Character class elements:
  x              single character
  A-Z            character range (inclusive)
  \d             Perl character class
  [:foo:]        ASCII character class foo
  \p{Foo}        Unicode character class Foo
  \pF            Unicode character class F (one-letter name)

Named character classes as character class elements:
  [\d]           digits (== \d)
  [^\d]          not digits (== \D)
  [\D]           not digits (== \D)
  [^\D]          not not digits (== \d)
  [[:name:]]     named ASCII class inside character class (== [:name:])
  [^[:name:]]    named ASCII class inside negated character class (== [:^name:])
  [\p{Name}]     named Unicode property inside character class (== \p{Name})
  [^\p{Name}]    named Unicode property inside negated character class (== \P{Name})

Perl character classes (all ASCII-only):
  \d             digits (== [0-9])
  \D             not digits (== [^0-9])
  \s             whitespace (== [\t\n\f\r ])
  \S             not whitespace (== [^\t\n\f\r ])
  \w             word characters (== [0-9A-Za-z_])
  \W             not word characters (== [^0-9A-Za-z_])

ASCII character classes:
  [[:alnum:]]    alphanumeric (== [0-9A-Za-z])
  [[:alpha:]]    alphabetic (== [A-Za-z])
  [[:ascii:]]    ASCII (== [\x00-\x7F])
  [[:blank:]]    blank (== [\t ])
  [[:cntrl:]]    control (== [\x00-\x1F\x7F])
  [[:digit:]]    digits (== [0-9])
  [[:graph:]]    graphical (== [!-~] == [A-Za-z0-9!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])
  [[:lower:]]    lower case (== [a-z])
  [[:print:]]    printable (== [ -~] == [ [:graph:]])
  [[:punct:]]    punctuation (== [!-/:-@[-`{-~])
  [[:space:]]    whitespace (== [\t\n\v\f\r ])
  [[:upper:]]    upper case (== [A-Z])
  [[:word:]]     word characters (== [0-9A-Za-z_])
  [[:xdigit:]]   hex digit (== [0-9A-Fa-f])

*/
package syntax
                                                                                                                                                                                                                                           root/go1.4/src/regexp/syntax/make_perl_groups.pl                                                    0100755 0000000 0000000 00000004335 12600426227 020373  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/perl
# Copyright 2008 The Go Authors.  All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

# Modified version of RE2's make_perl_groups.pl.

# Generate table entries giving character ranges
# for POSIX/Perl character classes.  Rather than
# figure out what the definition is, it is easier to ask
# Perl about each letter from 0-128 and write down
# its answer.

@posixclasses = (
	"[:alnum:]",
	"[:alpha:]",
	"[:ascii:]",
	"[:blank:]",
	"[:cntrl:]",
	"[:digit:]",
	"[:graph:]",
	"[:lower:]",
	"[:print:]",
	"[:punct:]",
	"[:space:]",
	"[:upper:]",
	"[:word:]",
	"[:xdigit:]",
);

@perlclasses = (
	"\\d",
	"\\s",
	"\\w",
);

sub ComputeClass($) {
  my @ranges;
  my ($class) = @_;
  my $regexp = "[$class]";
  my $start = -1;
  for (my $i=0; $i<=129; $i++) {
    if ($i == 129) { $i = 256; }
    if ($i <= 128 && chr($i) =~ $regexp) {
      if ($start < 0) {
        $start = $i;
      }
    } else {
      if ($start >= 0) {
        push @ranges, [$start, $i-1];
      }
      $start = -1;
    }
  }
  return @ranges;
}

sub PrintClass($$@) {
  my ($cname, $name, @ranges) = @_;
  print "var code$cname = []rune{  /* $name */\n";
  for (my $i=0; $i<@ranges; $i++) {
    my @a = @{$ranges[$i]};
    printf "\t0x%x, 0x%x,\n", $a[0], $a[1];
  }
  print "}\n\n";
  my $n = @ranges;
  $negname = $name;
  if ($negname =~ /:/) {
    $negname =~ s/:/:^/;
  } else {
    $negname =~ y/a-z/A-Z/;
  }
  return "\t`$name`: {+1, code$cname},\n" .
  	"\t`$negname`: {-1, code$cname},\n";
}

my $gen = 0;

sub PrintClasses($@) {
  my ($cname, @classes) = @_;
  my @entries;
  foreach my $cl (@classes) {
    my @ranges = ComputeClass($cl);
    push @entries, PrintClass(++$gen, $cl, @ranges);
  }
  print "var ${cname}Group = map[string]charGroup{\n";
  foreach my $e (@entries) {
    print $e;
  }
  print "}\n";
  my $count = @entries;
}

print <<EOF;
// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// GENERATED BY make_perl_groups.pl; DO NOT EDIT.
// make_perl_groups.pl >perl_groups.go

package syntax

EOF

PrintClasses("perl", @perlclasses);
PrintClasses("posix", @posixclasses);
                                                                                                                                                                                                                                                                                                   root/go1.4/src/regexp/syntax/parse.go                                                               0100644 0000000 0000000 00000133325 12600426227 016140  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package syntax

import (
	"sort"
	"strings"
	"unicode"
	"unicode/utf8"
)

// An Error describes a failure to parse a regular expression
// and gives the offending expression.
type Error struct {
	Code ErrorCode
	Expr string
}

func (e *Error) Error() string {
	return "error parsing regexp: " + e.Code.String() + ": `" + e.Expr + "`"
}

// An ErrorCode describes a failure to parse a regular expression.
type ErrorCode string

const (
	// Unexpected error
	ErrInternalError ErrorCode = "regexp/syntax: internal error"

	// Parse errors
	ErrInvalidCharClass      ErrorCode = "invalid character class"
	ErrInvalidCharRange      ErrorCode = "invalid character class range"
	ErrInvalidEscape         ErrorCode = "invalid escape sequence"
	ErrInvalidNamedCapture   ErrorCode = "invalid named capture"
	ErrInvalidPerlOp         ErrorCode = "invalid or unsupported Perl syntax"
	ErrInvalidRepeatOp       ErrorCode = "invalid nested repetition operator"
	ErrInvalidRepeatSize     ErrorCode = "invalid repeat count"
	ErrInvalidUTF8           ErrorCode = "invalid UTF-8"
	ErrMissingBracket        ErrorCode = "missing closing ]"
	ErrMissingParen          ErrorCode = "missing closing )"
	ErrMissingRepeatArgument ErrorCode = "missing argument to repetition operator"
	ErrTrailingBackslash     ErrorCode = "trailing backslash at end of expression"
	ErrUnexpectedParen       ErrorCode = "unexpected )"
)

func (e ErrorCode) String() string {
	return string(e)
}

// Flags control the behavior of the parser and record information about regexp context.
type Flags uint16

const (
	FoldCase      Flags = 1 << iota // case-insensitive match
	Literal                         // treat pattern as literal string
	ClassNL                         // allow character classes like [^a-z] and [[:space:]] to match newline
	DotNL                           // allow . to match newline
	OneLine                         // treat ^ and $ as only matching at beginning and end of text
	NonGreedy                       // make repetition operators default to non-greedy
	PerlX                           // allow Perl extensions
	UnicodeGroups                   // allow \p{Han}, \P{Han} for Unicode group and negation
	WasDollar                       // regexp OpEndText was $, not \z
	Simple                          // regexp contains no counted repetition

	MatchNL = ClassNL | DotNL

	Perl        = ClassNL | OneLine | PerlX | UnicodeGroups // as close to Perl as possible
	POSIX Flags = 0                                         // POSIX syntax
)

// Pseudo-ops for parsing stack.
const (
	opLeftParen = opPseudo + iota
	opVerticalBar
)

type parser struct {
	flags       Flags     // parse mode flags
	stack       []*Regexp // stack of parsed expressions
	free        *Regexp
	numCap      int // number of capturing groups seen
	wholeRegexp string
	tmpClass    []rune // temporary char class work space
}

func (p *parser) newRegexp(op Op) *Regexp {
	re := p.free
	if re != nil {
		p.free = re.Sub0[0]
		*re = Regexp{}
	} else {
		re = new(Regexp)
	}
	re.Op = op
	return re
}

func (p *parser) reuse(re *Regexp) {
	re.Sub0[0] = p.free
	p.free = re
}

// Parse stack manipulation.

// push pushes the regexp re onto the parse stack and returns the regexp.
func (p *parser) push(re *Regexp) *Regexp {
	if re.Op == OpCharClass && len(re.Rune) == 2 && re.Rune[0] == re.Rune[1] {
		// Single rune.
		if p.maybeConcat(re.Rune[0], p.flags&^FoldCase) {
			return nil
		}
		re.Op = OpLiteral
		re.Rune = re.Rune[:1]
		re.Flags = p.flags &^ FoldCase
	} else if re.Op == OpCharClass && len(re.Rune) == 4 &&
		re.Rune[0] == re.Rune[1] && re.Rune[2] == re.Rune[3] &&
		unicode.SimpleFold(re.Rune[0]) == re.Rune[2] &&
		unicode.SimpleFold(re.Rune[2]) == re.Rune[0] ||
		re.Op == OpCharClass && len(re.Rune) == 2 &&
			re.Rune[0]+1 == re.Rune[1] &&
			unicode.SimpleFold(re.Rune[0]) == re.Rune[1] &&
			unicode.SimpleFold(re.Rune[1]) == re.Rune[0] {
		// Case-insensitive rune like [Aa] or [].
		if p.maybeConcat(re.Rune[0], p.flags|FoldCase) {
			return nil
		}

		// Rewrite as (case-insensitive) literal.
		re.Op = OpLiteral
		re.Rune = re.Rune[:1]
		re.Flags = p.flags | FoldCase
	} else {
		// Incremental concatenation.
		p.maybeConcat(-1, 0)
	}

	p.stack = append(p.stack, re)
	return re
}

// maybeConcat implements incremental concatenation
// of literal runes into string nodes.  The parser calls this
// before each push, so only the top fragment of the stack
// might need processing.  Since this is called before a push,
// the topmost literal is no longer subject to operators like *
// (Otherwise ab* would turn into (ab)*.)
// If r >= 0 and there's a node left over, maybeConcat uses it
// to push r with the given flags.
// maybeConcat reports whether r was pushed.
func (p *parser) maybeConcat(r rune, flags Flags) bool {
	n := len(p.stack)
	if n < 2 {
		return false
	}

	re1 := p.stack[n-1]
	re2 := p.stack[n-2]
	if re1.Op != OpLiteral || re2.Op != OpLiteral || re1.Flags&FoldCase != re2.Flags&FoldCase {
		return false
	}

	// Push re1 into re2.
	re2.Rune = append(re2.Rune, re1.Rune...)

	// Reuse re1 if possible.
	if r >= 0 {
		re1.Rune = re1.Rune0[:1]
		re1.Rune[0] = r
		re1.Flags = flags
		return true
	}

	p.stack = p.stack[:n-1]
	p.reuse(re1)
	return false // did not push r
}

// newLiteral returns a new OpLiteral Regexp with the given flags
func (p *parser) newLiteral(r rune, flags Flags) *Regexp {
	re := p.newRegexp(OpLiteral)
	re.Flags = flags
	if flags&FoldCase != 0 {
		r = minFoldRune(r)
	}
	re.Rune0[0] = r
	re.Rune = re.Rune0[:1]
	return re
}

// minFoldRune returns the minimum rune fold-equivalent to r.
func minFoldRune(r rune) rune {
	if r < minFold || r > maxFold {
		return r
	}
	min := r
	r0 := r
	for r = unicode.SimpleFold(r); r != r0; r = unicode.SimpleFold(r) {
		if min > r {
			min = r
		}
	}
	return min
}

// literal pushes a literal regexp for the rune r on the stack
// and returns that regexp.
func (p *parser) literal(r rune) {
	p.push(p.newLiteral(r, p.flags))
}

// op pushes a regexp with the given op onto the stack
// and returns that regexp.
func (p *parser) op(op Op) *Regexp {
	re := p.newRegexp(op)
	re.Flags = p.flags
	return p.push(re)
}

// repeat replaces the top stack element with itself repeated according to op, min, max.
// before is the regexp suffix starting at the repetition operator.
// after is the regexp suffix following after the repetition operator.
// repeat returns an updated 'after' and an error, if any.
func (p *parser) repeat(op Op, min, max int, before, after, lastRepeat string) (string, error) {
	flags := p.flags
	if p.flags&PerlX != 0 {
		if len(after) > 0 && after[0] == '?' {
			after = after[1:]
			flags ^= NonGreedy
		}
		if lastRepeat != "" {
			// In Perl it is not allowed to stack repetition operators:
			// a** is a syntax error, not a doubled star, and a++ means
			// something else entirely, which we don't support!
			return "", &Error{ErrInvalidRepeatOp, lastRepeat[:len(lastRepeat)-len(after)]}
		}
	}
	n := len(p.stack)
	if n == 0 {
		return "", &Error{ErrMissingRepeatArgument, before[:len(before)-len(after)]}
	}
	sub := p.stack[n-1]
	if sub.Op >= opPseudo {
		return "", &Error{ErrMissingRepeatArgument, before[:len(before)-len(after)]}
	}

	re := p.newRegexp(op)
	re.Min = min
	re.Max = max
	re.Flags = flags
	re.Sub = re.Sub0[:1]
	re.Sub[0] = sub
	p.stack[n-1] = re

	if op == OpRepeat && (min >= 2 || max >= 2) && !repeatIsValid(re, 1000) {
		return "", &Error{ErrInvalidRepeatSize, before[:len(before)-len(after)]}
	}

	return after, nil
}

// repeatIsValid reports whether the repetition re is valid.
// Valid means that the combination of the top-level repetition
// and any inner repetitions does not exceed n copies of the
// innermost thing.
// This function rewalks the regexp tree and is called for every repetition,
// so we have to worry about inducing quadratic behavior in the parser.
// We avoid this by only calling repeatIsValid when min or max >= 2.
// In that case the depth of any >= 2 nesting can only get to 9 without
// triggering a parse error, so each subtree can only be rewalked 9 times.
func repeatIsValid(re *Regexp, n int) bool {
	if re.Op == OpRepeat {
		m := re.Max
		if m == 0 {
			return true
		}
		if m < 0 {
			m = re.Min
		}
		if m > n {
			return false
		}
		if m > 0 {
			n /= m
		}
	}
	for _, sub := range re.Sub {
		if !repeatIsValid(sub, n) {
			return false
		}
	}
	return true
}

// concat replaces the top of the stack (above the topmost '|' or '(') with its concatenation.
func (p *parser) concat() *Regexp {
	p.maybeConcat(-1, 0)

	// Scan down to find pseudo-operator | or (.
	i := len(p.stack)
	for i > 0 && p.stack[i-1].Op < opPseudo {
		i--
	}
	subs := p.stack[i:]
	p.stack = p.stack[:i]

	// Empty concatenation is special case.
	if len(subs) == 0 {
		return p.push(p.newRegexp(OpEmptyMatch))
	}

	return p.push(p.collapse(subs, OpConcat))
}

// alternate replaces the top of the stack (above the topmost '(') with its alternation.
func (p *parser) alternate() *Regexp {
	// Scan down to find pseudo-operator (.
	// There are no | above (.
	i := len(p.stack)
	for i > 0 && p.stack[i-1].Op < opPseudo {
		i--
	}
	subs := p.stack[i:]
	p.stack = p.stack[:i]

	// Make sure top class is clean.
	// All the others already are (see swapVerticalBar).
	if len(subs) > 0 {
		cleanAlt(subs[len(subs)-1])
	}

	// Empty alternate is special case
	// (shouldn't happen but easy to handle).
	if len(subs) == 0 {
		return p.push(p.newRegexp(OpNoMatch))
	}

	return p.push(p.collapse(subs, OpAlternate))
}

// cleanAlt cleans re for eventual inclusion in an alternation.
func cleanAlt(re *Regexp) {
	switch re.Op {
	case OpCharClass:
		re.Rune = cleanClass(&re.Rune)
		if len(re.Rune) == 2 && re.Rune[0] == 0 && re.Rune[1] == unicode.MaxRune {
			re.Rune = nil
			re.Op = OpAnyChar
			return
		}
		if len(re.Rune) == 4 && re.Rune[0] == 0 && re.Rune[1] == '\n'-1 && re.Rune[2] == '\n'+1 && re.Rune[3] == unicode.MaxRune {
			re.Rune = nil
			re.Op = OpAnyCharNotNL
			return
		}
		if cap(re.Rune)-len(re.Rune) > 100 {
			// re.Rune will not grow any more.
			// Make a copy or inline to reclaim storage.
			re.Rune = append(re.Rune0[:0], re.Rune...)
		}
	}
}

// collapse returns the result of applying op to sub.
// If sub contains op nodes, they all get hoisted up
// so that there is never a concat of a concat or an
// alternate of an alternate.
func (p *parser) collapse(subs []*Regexp, op Op) *Regexp {
	if len(subs) == 1 {
		return subs[0]
	}
	re := p.newRegexp(op)
	re.Sub = re.Sub0[:0]
	for _, sub := range subs {
		if sub.Op == op {
			re.Sub = append(re.Sub, sub.Sub...)
			p.reuse(sub)
		} else {
			re.Sub = append(re.Sub, sub)
		}
	}
	if op == OpAlternate {
		re.Sub = p.factor(re.Sub, re.Flags)
		if len(re.Sub) == 1 {
			old := re
			re = re.Sub[0]
			p.reuse(old)
		}
	}
	return re
}

// factor factors common prefixes from the alternation list sub.
// It returns a replacement list that reuses the same storage and
// frees (passes to p.reuse) any removed *Regexps.
//
// For example,
//     ABC|ABD|AEF|BCX|BCY
// simplifies by literal prefix extraction to
//     A(B(C|D)|EF)|BC(X|Y)
// which simplifies by character class introduction to
//     A(B[CD]|EF)|BC[XY]
//
func (p *parser) factor(sub []*Regexp, flags Flags) []*Regexp {
	if len(sub) < 2 {
		return sub
	}

	// Round 1: Factor out common literal prefixes.
	var str []rune
	var strflags Flags
	start := 0
	out := sub[:0]
	for i := 0; i <= len(sub); i++ {
		// Invariant: the Regexps that were in sub[0:start] have been
		// used or marked for reuse, and the slice space has been reused
		// for out (len(out) <= start).
		//
		// Invariant: sub[start:i] consists of regexps that all begin
		// with str as modified by strflags.
		var istr []rune
		var iflags Flags
		if i < len(sub) {
			istr, iflags = p.leadingString(sub[i])
			if iflags == strflags {
				same := 0
				for same < len(str) && same < len(istr) && str[same] == istr[same] {
					same++
				}
				if same > 0 {
					// Matches at least one rune in current range.
					// Keep going around.
					str = str[:same]
					continue
				}
			}
		}

		// Found end of a run with common leading literal string:
		// sub[start:i] all begin with str[0:len(str)], but sub[i]
		// does not even begin with str[0].
		//
		// Factor out common string and append factored expression to out.
		if i == start {
			// Nothing to do - run of length 0.
		} else if i == start+1 {
			// Just one: don't bother factoring.
			out = append(out, sub[start])
		} else {
			// Construct factored form: prefix(suffix1|suffix2|...)
			prefix := p.newRegexp(OpLiteral)
			prefix.Flags = strflags
			prefix.Rune = append(prefix.Rune[:0], str...)

			for j := start; j < i; j++ {
				sub[j] = p.removeLeadingString(sub[j], len(str))
			}
			suffix := p.collapse(sub[start:i], OpAlternate) // recurse

			re := p.newRegexp(OpConcat)
			re.Sub = append(re.Sub[:0], prefix, suffix)
			out = append(out, re)
		}

		// Prepare for next iteration.
		start = i
		str = istr
		strflags = iflags
	}
	sub = out

	// Round 2: Factor out common complex prefixes,
	// just the first piece of each concatenation,
	// whatever it is.  This is good enough a lot of the time.
	start = 0
	out = sub[:0]
	var first *Regexp
	for i := 0; i <= len(sub); i++ {
		// Invariant: the Regexps that were in sub[0:start] have been
		// used or marked for reuse, and the slice space has been reused
		// for out (len(out) <= start).
		//
		// Invariant: sub[start:i] consists of regexps that all begin with ifirst.
		var ifirst *Regexp
		if i < len(sub) {
			ifirst = p.leadingRegexp(sub[i])
			if first != nil && first.Equal(ifirst) {
				continue
			}
		}

		// Found end of a run with common leading regexp:
		// sub[start:i] all begin with first but sub[i] does not.
		//
		// Factor out common regexp and append factored expression to out.
		if i == start {
			// Nothing to do - run of length 0.
		} else if i == start+1 {
			// Just one: don't bother factoring.
			out = append(out, sub[start])
		} else {
			// Construct factored form: prefix(suffix1|suffix2|...)
			prefix := first
			for j := start; j < i; j++ {
				reuse := j != start // prefix came from sub[start]
				sub[j] = p.removeLeadingRegexp(sub[j], reuse)
			}
			suffix := p.collapse(sub[start:i], OpAlternate) // recurse

			re := p.newRegexp(OpConcat)
			re.Sub = append(re.Sub[:0], prefix, suffix)
			out = append(out, re)
		}

		// Prepare for next iteration.
		start = i
		first = ifirst
	}
	sub = out

	// Round 3: Collapse runs of single literals into character classes.
	start = 0
	out = sub[:0]
	for i := 0; i <= len(sub); i++ {
		// Invariant: the Regexps that were in sub[0:start] have been
		// used or marked for reuse, and the slice space has been reused
		// for out (len(out) <= start).
		//
		// Invariant: sub[start:i] consists of regexps that are either
		// literal runes or character classes.
		if i < len(sub) && isCharClass(sub[i]) {
			continue
		}

		// sub[i] is not a char or char class;
		// emit char class for sub[start:i]...
		if i == start {
			// Nothing to do - run of length 0.
		} else if i == start+1 {
			out = append(out, sub[start])
		} else {
			// Make new char class.
			// Start with most complex regexp in sub[start].
			max := start
			for j := start + 1; j < i; j++ {
				if sub[max].Op < sub[j].Op || sub[max].Op == sub[j].Op && len(sub[max].Rune) < len(sub[j].Rune) {
					max = j
				}
			}
			sub[start], sub[max] = sub[max], sub[start]

			for j := start + 1; j < i; j++ {
				mergeCharClass(sub[start], sub[j])
				p.reuse(sub[j])
			}
			cleanAlt(sub[start])
			out = append(out, sub[start])
		}

		// ... and then emit sub[i].
		if i < len(sub) {
			out = append(out, sub[i])
		}
		start = i + 1
	}
	sub = out

	// Round 4: Collapse runs of empty matches into a single empty match.
	start = 0
	out = sub[:0]
	for i := range sub {
		if i+1 < len(sub) && sub[i].Op == OpEmptyMatch && sub[i+1].Op == OpEmptyMatch {
			continue
		}
		out = append(out, sub[i])
	}
	sub = out

	return sub
}

// leadingString returns the leading literal string that re begins with.
// The string refers to storage in re or its children.
func (p *parser) leadingString(re *Regexp) ([]rune, Flags) {
	if re.Op == OpConcat && len(re.Sub) > 0 {
		re = re.Sub[0]
	}
	if re.Op != OpLiteral {
		return nil, 0
	}
	return re.Rune, re.Flags & FoldCase
}

// removeLeadingString removes the first n leading runes
// from the beginning of re.  It returns the replacement for re.
func (p *parser) removeLeadingString(re *Regexp, n int) *Regexp {
	if re.Op == OpConcat && len(re.Sub) > 0 {
		// Removing a leading string in a concatenation
		// might simplify the concatenation.
		sub := re.Sub[0]
		sub = p.removeLeadingString(sub, n)
		re.Sub[0] = sub
		if sub.Op == OpEmptyMatch {
			p.reuse(sub)
			switch len(re.Sub) {
			case 0, 1:
				// Impossible but handle.
				re.Op = OpEmptyMatch
				re.Sub = nil
			case 2:
				old := re
				re = re.Sub[1]
				p.reuse(old)
			default:
				copy(re.Sub, re.Sub[1:])
				re.Sub = re.Sub[:len(re.Sub)-1]
			}
		}
		return re
	}

	if re.Op == OpLiteral {
		re.Rune = re.Rune[:copy(re.Rune, re.Rune[n:])]
		if len(re.Rune) == 0 {
			re.Op = OpEmptyMatch
		}
	}
	return re
}

// leadingRegexp returns the leading regexp that re begins with.
// The regexp refers to storage in re or its children.
func (p *parser) leadingRegexp(re *Regexp) *Regexp {
	if re.Op == OpEmptyMatch {
		return nil
	}
	if re.Op == OpConcat && len(re.Sub) > 0 {
		sub := re.Sub[0]
		if sub.Op == OpEmptyMatch {
			return nil
		}
		return sub
	}
	return re
}

// removeLeadingRegexp removes the leading regexp in re.
// It returns the replacement for re.
// If reuse is true, it passes the removed regexp (if no longer needed) to p.reuse.
func (p *parser) removeLeadingRegexp(re *Regexp, reuse bool) *Regexp {
	if re.Op == OpConcat && len(re.Sub) > 0 {
		if reuse {
			p.reuse(re.Sub[0])
		}
		re.Sub = re.Sub[:copy(re.Sub, re.Sub[1:])]
		switch len(re.Sub) {
		case 0:
			re.Op = OpEmptyMatch
			re.Sub = nil
		case 1:
			old := re
			re = re.Sub[0]
			p.reuse(old)
		}
		return re
	}
	if reuse {
		p.reuse(re)
	}
	return p.newRegexp(OpEmptyMatch)
}

func literalRegexp(s string, flags Flags) *Regexp {
	re := &Regexp{Op: OpLiteral}
	re.Flags = flags
	re.Rune = re.Rune0[:0] // use local storage for small strings
	for _, c := range s {
		if len(re.Rune) >= cap(re.Rune) {
			// string is too long to fit in Rune0.  let Go handle it
			re.Rune = []rune(s)
			break
		}
		re.Rune = append(re.Rune, c)
	}
	return re
}

// Parsing.

// Parse parses a regular expression string s, controlled by the specified
// Flags, and returns a regular expression parse tree. The syntax is
// described in the top-level comment.
func Parse(s string, flags Flags) (*Regexp, error) {
	if flags&Literal != 0 {
		// Trivial parser for literal string.
		if err := checkUTF8(s); err != nil {
			return nil, err
		}
		return literalRegexp(s, flags), nil
	}

	// Otherwise, must do real work.
	var (
		p          parser
		err        error
		c          rune
		op         Op
		lastRepeat string
	)
	p.flags = flags
	p.wholeRegexp = s
	t := s
	for t != "" {
		repeat := ""
	BigSwitch:
		switch t[0] {
		default:
			if c, t, err = nextRune(t); err != nil {
				return nil, err
			}
			p.literal(c)

		case '(':
			if p.flags&PerlX != 0 && len(t) >= 2 && t[1] == '?' {
				// Flag changes and non-capturing groups.
				if t, err = p.parsePerlFlags(t); err != nil {
					return nil, err
				}
				break
			}
			p.numCap++
			p.op(opLeftParen).Cap = p.numCap
			t = t[1:]
		case '|':
			if err = p.parseVerticalBar(); err != nil {
				return nil, err
			}
			t = t[1:]
		case ')':
			if err = p.parseRightParen(); err != nil {
				return nil, err
			}
			t = t[1:]
		case '^':
			if p.flags&OneLine != 0 {
				p.op(OpBeginText)
			} else {
				p.op(OpBeginLine)
			}
			t = t[1:]
		case '$':
			if p.flags&OneLine != 0 {
				p.op(OpEndText).Flags |= WasDollar
			} else {
				p.op(OpEndLine)
			}
			t = t[1:]
		case '.':
			if p.flags&DotNL != 0 {
				p.op(OpAnyChar)
			} else {
				p.op(OpAnyCharNotNL)
			}
			t = t[1:]
		case '[':
			if t, err = p.parseClass(t); err != nil {
				return nil, err
			}
		case '*', '+', '?':
			before := t
			switch t[0] {
			case '*':
				op = OpStar
			case '+':
				op = OpPlus
			case '?':
				op = OpQuest
			}
			after := t[1:]
			if after, err = p.repeat(op, 0, 0, before, after, lastRepeat); err != nil {
				return nil, err
			}
			repeat = before
			t = after
		case '{':
			op = OpRepeat
			before := t
			min, max, after, ok := p.parseRepeat(t)
			if !ok {
				// If the repeat cannot be parsed, { is a literal.
				p.literal('{')
				t = t[1:]
				break
			}
			if min < 0 || min > 1000 || max > 1000 || max >= 0 && min > max {
				// Numbers were too big, or max is present and min > max.
				return nil, &Error{ErrInvalidRepeatSize, before[:len(before)-len(after)]}
			}
			if after, err = p.repeat(op, min, max, before, after, lastRepeat); err != nil {
				return nil, err
			}
			repeat = before
			t = after
		case '\\':
			if p.flags&PerlX != 0 && len(t) >= 2 {
				switch t[1] {
				case 'A':
					p.op(OpBeginText)
					t = t[2:]
					break BigSwitch
				case 'b':
					p.op(OpWordBoundary)
					t = t[2:]
					break BigSwitch
				case 'B':
					p.op(OpNoWordBoundary)
					t = t[2:]
					break BigSwitch
				case 'C':
					// any byte; not supported
					return nil, &Error{ErrInvalidEscape, t[:2]}
				case 'Q':
					// \Q ... \E: the ... is always literals
					var lit string
					if i := strings.Index(t, `\E`); i < 0 {
						lit = t[2:]
						t = ""
					} else {
						lit = t[2:i]
						t = t[i+2:]
					}
					p.push(literalRegexp(lit, p.flags))
					break BigSwitch
				case 'z':
					p.op(OpEndText)
					t = t[2:]
					break BigSwitch
				}
			}

			re := p.newRegexp(OpCharClass)
			re.Flags = p.flags

			// Look for Unicode character group like \p{Han}
			if len(t) >= 2 && (t[1] == 'p' || t[1] == 'P') {
				r, rest, err := p.parseUnicodeClass(t, re.Rune0[:0])
				if err != nil {
					return nil, err
				}
				if r != nil {
					re.Rune = r
					t = rest
					p.push(re)
					break BigSwitch
				}
			}

			// Perl character class escape.
			if r, rest := p.parsePerlClassEscape(t, re.Rune0[:0]); r != nil {
				re.Rune = r
				t = rest
				p.push(re)
				break BigSwitch
			}
			p.reuse(re)

			// Ordinary single-character escape.
			if c, t, err = p.parseEscape(t); err != nil {
				return nil, err
			}
			p.literal(c)
		}
		lastRepeat = repeat
	}

	p.concat()
	if p.swapVerticalBar() {
		// pop vertical bar
		p.stack = p.stack[:len(p.stack)-1]
	}
	p.alternate()

	n := len(p.stack)
	if n != 1 {
		return nil, &Error{ErrMissingParen, s}
	}
	return p.stack[0], nil
}

// parseRepeat parses {min} (max=min) or {min,} (max=-1) or {min,max}.
// If s is not of that form, it returns ok == false.
// If s has the right form but the values are too big, it returns min == -1, ok == true.
func (p *parser) parseRepeat(s string) (min, max int, rest string, ok bool) {
	if s == "" || s[0] != '{' {
		return
	}
	s = s[1:]
	var ok1 bool
	if min, s, ok1 = p.parseInt(s); !ok1 {
		return
	}
	if s == "" {
		return
	}
	if s[0] != ',' {
		max = min
	} else {
		s = s[1:]
		if s == "" {
			return
		}
		if s[0] == '}' {
			max = -1
		} else if max, s, ok1 = p.parseInt(s); !ok1 {
			return
		} else if max < 0 {
			// parseInt found too big a number
			min = -1
		}
	}
	if s == "" || s[0] != '}' {
		return
	}
	rest = s[1:]
	ok = true
	return
}

// parsePerlFlags parses a Perl flag setting or non-capturing group or both,
// like (?i) or (?: or (?i:.  It removes the prefix from s and updates the parse state.
// The caller must have ensured that s begins with "(?".
func (p *parser) parsePerlFlags(s string) (rest string, err error) {
	t := s

	// Check for named captures, first introduced in Python's regexp library.
	// As usual, there are three slightly different syntaxes:
	//
	//   (?P<name>expr)   the original, introduced by Python
	//   (?<name>expr)    the .NET alteration, adopted by Perl 5.10
	//   (?'name'expr)    another .NET alteration, adopted by Perl 5.10
	//
	// Perl 5.10 gave in and implemented the Python version too,
	// but they claim that the last two are the preferred forms.
	// PCRE and languages based on it (specifically, PHP and Ruby)
	// support all three as well.  EcmaScript 4 uses only the Python form.
	//
	// In both the open source world (via Code Search) and the
	// Google source tree, (?P<expr>name) is the dominant form,
	// so that's the one we implement.  One is enough.
	if len(t) > 4 && t[2] == 'P' && t[3] == '<' {
		// Pull out name.
		end := strings.IndexRune(t, '>')
		if end < 0 {
			if err = checkUTF8(t); err != nil {
				return "", err
			}
			return "", &Error{ErrInvalidNamedCapture, s}
		}

		capture := t[:end+1] // "(?P<name>"
		name := t[4:end]     // "name"
		if err = checkUTF8(name); err != nil {
			return "", err
		}
		if !isValidCaptureName(name) {
			return "", &Error{ErrInvalidNamedCapture, capture}
		}

		// Like ordinary capture, but named.
		p.numCap++
		re := p.op(opLeftParen)
		re.Cap = p.numCap
		re.Name = name
		return t[end+1:], nil
	}

	// Non-capturing group.  Might also twiddle Perl flags.
	var c rune
	t = t[2:] // skip (?
	flags := p.flags
	sign := +1
	sawFlag := false
Loop:
	for t != "" {
		if c, t, err = nextRune(t); err != nil {
			return "", err
		}
		switch c {
		default:
			break Loop

		// Flags.
		case 'i':
			flags |= FoldCase
			sawFlag = true
		case 'm':
			flags &^= OneLine
			sawFlag = true
		case 's':
			flags |= DotNL
			sawFlag = true
		case 'U':
			flags |= NonGreedy
			sawFlag = true

		// Switch to negation.
		case '-':
			if sign < 0 {
				break Loop
			}
			sign = -1
			// Invert flags so that | above turn into &^ and vice versa.
			// We'll invert flags again before using it below.
			flags = ^flags
			sawFlag = false

		// End of flags, starting group or not.
		case ':', ')':
			if sign < 0 {
				if !sawFlag {
					break Loop
				}
				flags = ^flags
			}
			if c == ':' {
				// Open new group
				p.op(opLeftParen)
			}
			p.flags = flags
			return t, nil
		}
	}

	return "", &Error{ErrInvalidPerlOp, s[:len(s)-len(t)]}
}

// isValidCaptureName reports whether name
// is a valid capture name: [A-Za-z0-9_]+.
// PCRE limits names to 32 bytes.
// Python rejects names starting with digits.
// We don't enforce either of those.
func isValidCaptureName(name string) bool {
	if name == "" {
		return false
	}
	for _, c := range name {
		if c != '_' && !isalnum(c) {
			return false
		}
	}
	return true
}

// parseInt parses a decimal integer.
func (p *parser) parseInt(s string) (n int, rest string, ok bool) {
	if s == "" || s[0] < '0' || '9' < s[0] {
		return
	}
	// Disallow leading zeros.
	if len(s) >= 2 && s[0] == '0' && '0' <= s[1] && s[1] <= '9' {
		return
	}
	t := s
	for s != "" && '0' <= s[0] && s[0] <= '9' {
		s = s[1:]
	}
	rest = s
	ok = true
	// Have digits, compute value.
	t = t[:len(t)-len(s)]
	for i := 0; i < len(t); i++ {
		// Avoid overflow.
		if n >= 1e8 {
			n = -1
			break
		}
		n = n*10 + int(t[i]) - '0'
	}
	return
}

// can this be represented as a character class?
// single-rune literal string, char class, ., and .|\n.
func isCharClass(re *Regexp) bool {
	return re.Op == OpLiteral && len(re.Rune) == 1 ||
		re.Op == OpCharClass ||
		re.Op == OpAnyCharNotNL ||
		re.Op == OpAnyChar
}

// does re match r?
func matchRune(re *Regexp, r rune) bool {
	switch re.Op {
	case OpLiteral:
		return len(re.Rune) == 1 && re.Rune[0] == r
	case OpCharClass:
		for i := 0; i < len(re.Rune); i += 2 {
			if re.Rune[i] <= r && r <= re.Rune[i+1] {
				return true
			}
		}
		return false
	case OpAnyCharNotNL:
		return r != '\n'
	case OpAnyChar:
		return true
	}
	return false
}

// parseVerticalBar handles a | in the input.
func (p *parser) parseVerticalBar() error {
	p.concat()

	// The concatenation we just parsed is on top of the stack.
	// If it sits above an opVerticalBar, swap it below
	// (things below an opVerticalBar become an alternation).
	// Otherwise, push a new vertical bar.
	if !p.swapVerticalBar() {
		p.op(opVerticalBar)
	}

	return nil
}

// mergeCharClass makes dst = dst|src.
// The caller must ensure that dst.Op >= src.Op,
// to reduce the amount of copying.
func mergeCharClass(dst, src *Regexp) {
	switch dst.Op {
	case OpAnyChar:
		// src doesn't add anything.
	case OpAnyCharNotNL:
		// src might add \n
		if matchRune(src, '\n') {
			dst.Op = OpAnyChar
		}
	case OpCharClass:
		// src is simpler, so either literal or char class
		if src.Op == OpLiteral {
			dst.Rune = appendLiteral(dst.Rune, src.Rune[0], src.Flags)
		} else {
			dst.Rune = appendClass(dst.Rune, src.Rune)
		}
	case OpLiteral:
		// both literal
		if src.Rune[0] == dst.Rune[0] && src.Flags == dst.Flags {
			break
		}
		dst.Op = OpCharClass
		dst.Rune = appendLiteral(dst.Rune[:0], dst.Rune[0], dst.Flags)
		dst.Rune = appendLiteral(dst.Rune, src.Rune[0], src.Flags)
	}
}

// If the top of the stack is an element followed by an opVerticalBar
// swapVerticalBar swaps the two and returns true.
// Otherwise it returns false.
func (p *parser) swapVerticalBar() bool {
	// If above and below vertical bar are literal or char class,
	// can merge into a single char class.
	n := len(p.stack)
	if n >= 3 && p.stack[n-2].Op == opVerticalBar && isCharClass(p.stack[n-1]) && isCharClass(p.stack[n-3]) {
		re1 := p.stack[n-1]
		re3 := p.stack[n-3]
		// Make re3 the more complex of the two.
		if re1.Op > re3.Op {
			re1, re3 = re3, re1
			p.stack[n-3] = re3
		}
		mergeCharClass(re3, re1)
		p.reuse(re1)
		p.stack = p.stack[:n-1]
		return true
	}

	if n >= 2 {
		re1 := p.stack[n-1]
		re2 := p.stack[n-2]
		if re2.Op == opVerticalBar {
			if n >= 3 {
				// Now out of reach.
				// Clean opportunistically.
				cleanAlt(p.stack[n-3])
			}
			p.stack[n-2] = re1
			p.stack[n-1] = re2
			return true
		}
	}
	return false
}

// parseRightParen handles a ) in the input.
func (p *parser) parseRightParen() error {
	p.concat()
	if p.swapVerticalBar() {
		// pop vertical bar
		p.stack = p.stack[:len(p.stack)-1]
	}
	p.alternate()

	n := len(p.stack)
	if n < 2 {
		return &Error{ErrUnexpectedParen, p.wholeRegexp}
	}
	re1 := p.stack[n-1]
	re2 := p.stack[n-2]
	p.stack = p.stack[:n-2]
	if re2.Op != opLeftParen {
		return &Error{ErrUnexpectedParen, p.wholeRegexp}
	}
	// Restore flags at time of paren.
	p.flags = re2.Flags
	if re2.Cap == 0 {
		// Just for grouping.
		p.push(re1)
	} else {
		re2.Op = OpCapture
		re2.Sub = re2.Sub0[:1]
		re2.Sub[0] = re1
		p.push(re2)
	}
	return nil
}

// parseEscape parses an escape sequence at the beginning of s
// and returns the rune.
func (p *parser) parseEscape(s string) (r rune, rest string, err error) {
	t := s[1:]
	if t == "" {
		return 0, "", &Error{ErrTrailingBackslash, ""}
	}
	c, t, err := nextRune(t)
	if err != nil {
		return 0, "", err
	}

Switch:
	switch c {
	default:
		if c < utf8.RuneSelf && !isalnum(c) {
			// Escaped non-word characters are always themselves.
			// PCRE is not quite so rigorous: it accepts things like
			// \q, but we don't.  We once rejected \_, but too many
			// programs and people insist on using it, so allow \_.
			return c, t, nil
		}

	// Octal escapes.
	case '1', '2', '3', '4', '5', '6', '7':
		// Single non-zero digit is a backreference; not supported
		if t == "" || t[0] < '0' || t[0] > '7' {
			break
		}
		fallthrough
	case '0':
		// Consume up to three octal digits; already have one.
		r = c - '0'
		for i := 1; i < 3; i++ {
			if t == "" || t[0] < '0' || t[0] > '7' {
				break
			}
			r = r*8 + rune(t[0]) - '0'
			t = t[1:]
		}
		return r, t, nil

	// Hexadecimal escapes.
	case 'x':
		if t == "" {
			break
		}
		if c, t, err = nextRune(t); err != nil {
			return 0, "", err
		}
		if c == '{' {
			// Any number of digits in braces.
			// Perl accepts any text at all; it ignores all text
			// after the first non-hex digit.  We require only hex digits,
			// and at least one.
			nhex := 0
			r = 0
			for {
				if t == "" {
					break Switch
				}
				if c, t, err = nextRune(t); err != nil {
					return 0, "", err
				}
				if c == '}' {
					break
				}
				v := unhex(c)
				if v < 0 {
					break Switch
				}
				r = r*16 + v
				if r > unicode.MaxRune {
					break Switch
				}
				nhex++
			}
			if nhex == 0 {
				break Switch
			}
			return r, t, nil
		}

		// Easy case: two hex digits.
		x := unhex(c)
		if c, t, err = nextRune(t); err != nil {
			return 0, "", err
		}
		y := unhex(c)
		if x < 0 || y < 0 {
			break
		}
		return x*16 + y, t, nil

	// C escapes.  There is no case 'b', to avoid misparsing
	// the Perl word-boundary \b as the C backspace \b
	// when in POSIX mode.  In Perl, /\b/ means word-boundary
	// but /[\b]/ means backspace.  We don't support that.
	// If you want a backspace, embed a literal backspace
	// character or use \x08.
	case 'a':
		return '\a', t, err
	case 'f':
		return '\f', t, err
	case 'n':
		return '\n', t, err
	case 'r':
		return '\r', t, err
	case 't':
		return '\t', t, err
	case 'v':
		return '\v', t, err
	}
	return 0, "", &Error{ErrInvalidEscape, s[:len(s)-len(t)]}
}

// parseClassChar parses a character class character at the beginning of s
// and returns it.
func (p *parser) parseClassChar(s, wholeClass string) (r rune, rest string, err error) {
	if s == "" {
		return 0, "", &Error{Code: ErrMissingBracket, Expr: wholeClass}
	}

	// Allow regular escape sequences even though
	// many need not be escaped in this context.
	if s[0] == '\\' {
		return p.parseEscape(s)
	}

	return nextRune(s)
}

type charGroup struct {
	sign  int
	class []rune
}

// parsePerlClassEscape parses a leading Perl character class escape like \d
// from the beginning of s.  If one is present, it appends the characters to r
// and returns the new slice r and the remainder of the string.
func (p *parser) parsePerlClassEscape(s string, r []rune) (out []rune, rest string) {
	if p.flags&PerlX == 0 || len(s) < 2 || s[0] != '\\' {
		return
	}
	g := perlGroup[s[0:2]]
	if g.sign == 0 {
		return
	}
	return p.appendGroup(r, g), s[2:]
}

// parseNamedClass parses a leading POSIX named character class like [:alnum:]
// from the beginning of s.  If one is present, it appends the characters to r
// and returns the new slice r and the remainder of the string.
func (p *parser) parseNamedClass(s string, r []rune) (out []rune, rest string, err error) {
	if len(s) < 2 || s[0] != '[' || s[1] != ':' {
		return
	}

	i := strings.Index(s[2:], ":]")
	if i < 0 {
		return
	}
	i += 2
	name, s := s[0:i+2], s[i+2:]
	g := posixGroup[name]
	if g.sign == 0 {
		return nil, "", &Error{ErrInvalidCharRange, name}
	}
	return p.appendGroup(r, g), s, nil
}

func (p *parser) appendGroup(r []rune, g charGroup) []rune {
	if p.flags&FoldCase == 0 {
		if g.sign < 0 {
			r = appendNegatedClass(r, g.class)
		} else {
			r = appendClass(r, g.class)
		}
	} else {
		tmp := p.tmpClass[:0]
		tmp = appendFoldedClass(tmp, g.class)
		p.tmpClass = tmp
		tmp = cleanClass(&p.tmpClass)
		if g.sign < 0 {
			r = appendNegatedClass(r, tmp)
		} else {
			r = appendClass(r, tmp)
		}
	}
	return r
}

var anyTable = &unicode.RangeTable{
	R16: []unicode.Range16{{Lo: 0, Hi: 1<<16 - 1, Stride: 1}},
	R32: []unicode.Range32{{Lo: 1 << 16, Hi: unicode.MaxRune, Stride: 1}},
}

// unicodeTable returns the unicode.RangeTable identified by name
// and the table of additional fold-equivalent code points.
func unicodeTable(name string) (*unicode.RangeTable, *unicode.RangeTable) {
	// Special case: "Any" means any.
	if name == "Any" {
		return anyTable, anyTable
	}
	if t := unicode.Categories[name]; t != nil {
		return t, unicode.FoldCategory[name]
	}
	if t := unicode.Scripts[name]; t != nil {
		return t, unicode.FoldScript[name]
	}
	return nil, nil
}

// parseUnicodeClass parses a leading Unicode character class like \p{Han}
// from the beginning of s.  If one is present, it appends the characters to r
// and returns the new slice r and the remainder of the string.
func (p *parser) parseUnicodeClass(s string, r []rune) (out []rune, rest string, err error) {
	if p.flags&UnicodeGroups == 0 || len(s) < 2 || s[0] != '\\' || s[1] != 'p' && s[1] != 'P' {
		return
	}

	// Committed to parse or return error.
	sign := +1
	if s[1] == 'P' {
		sign = -1
	}
	t := s[2:]
	c, t, err := nextRune(t)
	if err != nil {
		return
	}
	var seq, name string
	if c != '{' {
		// Single-letter name.
		seq = s[:len(s)-len(t)]
		name = seq[2:]
	} else {
		// Name is in braces.
		end := strings.IndexRune(s, '}')
		if end < 0 {
			if err = checkUTF8(s); err != nil {
				return
			}
			return nil, "", &Error{ErrInvalidCharRange, s}
		}
		seq, t = s[:end+1], s[end+1:]
		name = s[3:end]
		if err = checkUTF8(name); err != nil {
			return
		}
	}

	// Group can have leading negation too.  \p{^Han} == \P{Han}, \P{^Han} == \p{Han}.
	if name != "" && name[0] == '^' {
		sign = -sign
		name = name[1:]
	}

	tab, fold := unicodeTable(name)
	if tab == nil {
		return nil, "", &Error{ErrInvalidCharRange, seq}
	}

	if p.flags&FoldCase == 0 || fold == nil {
		if sign > 0 {
			r = appendTable(r, tab)
		} else {
			r = appendNegatedTable(r, tab)
		}
	} else {
		// Merge and clean tab and fold in a temporary buffer.
		// This is necessary for the negative case and just tidy
		// for the positive case.
		tmp := p.tmpClass[:0]
		tmp = appendTable(tmp, tab)
		tmp = appendTable(tmp, fold)
		p.tmpClass = tmp
		tmp = cleanClass(&p.tmpClass)
		if sign > 0 {
			r = appendClass(r, tmp)
		} else {
			r = appendNegatedClass(r, tmp)
		}
	}
	return r, t, nil
}

// parseClass parses a character class at the beginning of s
// and pushes it onto the parse stack.
func (p *parser) parseClass(s string) (rest string, err error) {
	t := s[1:] // chop [
	re := p.newRegexp(OpCharClass)
	re.Flags = p.flags
	re.Rune = re.Rune0[:0]

	sign := +1
	if t != "" && t[0] == '^' {
		sign = -1
		t = t[1:]

		// If character class does not match \n, add it here,
		// so that negation later will do the right thing.
		if p.flags&ClassNL == 0 {
			re.Rune = append(re.Rune, '\n', '\n')
		}
	}

	class := re.Rune
	first := true // ] and - are okay as first char in class
	for t == "" || t[0] != ']' || first {
		// POSIX: - is only okay unescaped as first or last in class.
		// Perl: - is okay anywhere.
		if t != "" && t[0] == '-' && p.flags&PerlX == 0 && !first && (len(t) == 1 || t[1] != ']') {
			_, size := utf8.DecodeRuneInString(t[1:])
			return "", &Error{Code: ErrInvalidCharRange, Expr: t[:1+size]}
		}
		first = false

		// Look for POSIX [:alnum:] etc.
		if len(t) > 2 && t[0] == '[' && t[1] == ':' {
			nclass, nt, err := p.parseNamedClass(t, class)
			if err != nil {
				return "", err
			}
			if nclass != nil {
				class, t = nclass, nt
				continue
			}
		}

		// Look for Unicode character group like \p{Han}.
		nclass, nt, err := p.parseUnicodeClass(t, class)
		if err != nil {
			return "", err
		}
		if nclass != nil {
			class, t = nclass, nt
			continue
		}

		// Look for Perl character class symbols (extension).
		if nclass, nt := p.parsePerlClassEscape(t, class); nclass != nil {
			class, t = nclass, nt
			continue
		}

		// Single character or simple range.
		rng := t
		var lo, hi rune
		if lo, t, err = p.parseClassChar(t, s); err != nil {
			return "", err
		}
		hi = lo
		// [a-] means (a|-) so check for final ].
		if len(t) >= 2 && t[0] == '-' && t[1] != ']' {
			t = t[1:]
			if hi, t, err = p.parseClassChar(t, s); err != nil {
				return "", err
			}
			if hi < lo {
				rng = rng[:len(rng)-len(t)]
				return "", &Error{Code: ErrInvalidCharRange, Expr: rng}
			}
		}
		if p.flags&FoldCase == 0 {
			class = appendRange(class, lo, hi)
		} else {
			class = appendFoldedRange(class, lo, hi)
		}
	}
	t = t[1:] // chop ]

	// Use &re.Rune instead of &class to avoid allocation.
	re.Rune = class
	class = cleanClass(&re.Rune)
	if sign < 0 {
		class = negateClass(class)
	}
	re.Rune = class
	p.push(re)
	return t, nil
}

// cleanClass sorts the ranges (pairs of elements of r),
// merges them, and eliminates duplicates.
func cleanClass(rp *[]rune) []rune {

	// Sort by lo increasing, hi decreasing to break ties.
	sort.Sort(ranges{rp})

	r := *rp
	if len(r) < 2 {
		return r
	}

	// Merge abutting, overlapping.
	w := 2 // write index
	for i := 2; i < len(r); i += 2 {
		lo, hi := r[i], r[i+1]
		if lo <= r[w-1]+1 {
			// merge with previous range
			if hi > r[w-1] {
				r[w-1] = hi
			}
			continue
		}
		// new disjoint range
		r[w] = lo
		r[w+1] = hi
		w += 2
	}

	return r[:w]
}

// appendLiteral returns the result of appending the literal x to the class r.
func appendLiteral(r []rune, x rune, flags Flags) []rune {
	if flags&FoldCase != 0 {
		return appendFoldedRange(r, x, x)
	}
	return appendRange(r, x, x)
}

// appendRange returns the result of appending the range lo-hi to the class r.
func appendRange(r []rune, lo, hi rune) []rune {
	// Expand last range or next to last range if it overlaps or abuts.
	// Checking two ranges helps when appending case-folded
	// alphabets, so that one range can be expanding A-Z and the
	// other expanding a-z.
	n := len(r)
	for i := 2; i <= 4; i += 2 { // twice, using i=2, i=4
		if n >= i {
			rlo, rhi := r[n-i], r[n-i+1]
			if lo <= rhi+1 && rlo <= hi+1 {
				if lo < rlo {
					r[n-i] = lo
				}
				if hi > rhi {
					r[n-i+1] = hi
				}
				return r
			}
		}
	}

	return append(r, lo, hi)
}

const (
	// minimum and maximum runes involved in folding.
	// checked during test.
	minFold = 0x0041
	maxFold = 0x118df
)

// appendFoldedRange returns the result of appending the range lo-hi
// and its case folding-equivalent runes to the class r.
func appendFoldedRange(r []rune, lo, hi rune) []rune {
	// Optimizations.
	if lo <= minFold && hi >= maxFold {
		// Range is full: folding can't add more.
		return appendRange(r, lo, hi)
	}
	if hi < minFold || lo > maxFold {
		// Range is outside folding possibilities.
		return appendRange(r, lo, hi)
	}
	if lo < minFold {
		// [lo, minFold-1] needs no folding.
		r = appendRange(r, lo, minFold-1)
		lo = minFold
	}
	if hi > maxFold {
		// [maxFold+1, hi] needs no folding.
		r = appendRange(r, maxFold+1, hi)
		hi = maxFold
	}

	// Brute force.  Depend on appendRange to coalesce ranges on the fly.
	for c := lo; c <= hi; c++ {
		r = appendRange(r, c, c)
		f := unicode.SimpleFold(c)
		for f != c {
			r = appendRange(r, f, f)
			f = unicode.SimpleFold(f)
		}
	}
	return r
}

// appendClass returns the result of appending the class x to the class r.
// It assume x is clean.
func appendClass(r []rune, x []rune) []rune {
	for i := 0; i < len(x); i += 2 {
		r = appendRange(r, x[i], x[i+1])
	}
	return r
}

// appendFolded returns the result of appending the case folding of the class x to the class r.
func appendFoldedClass(r []rune, x []rune) []rune {
	for i := 0; i < len(x); i += 2 {
		r = appendFoldedRange(r, x[i], x[i+1])
	}
	return r
}

// appendNegatedClass returns the result of appending the negation of the class x to the class r.
// It assumes x is clean.
func appendNegatedClass(r []rune, x []rune) []rune {
	nextLo := '\u0000'
	for i := 0; i < len(x); i += 2 {
		lo, hi := x[i], x[i+1]
		if nextLo <= lo-1 {
			r = appendRange(r, nextLo, lo-1)
		}
		nextLo = hi + 1
	}
	if nextLo <= unicode.MaxRune {
		r = appendRange(r, nextLo, unicode.MaxRune)
	}
	return r
}

// appendTable returns the result of appending x to the class r.
func appendTable(r []rune, x *unicode.RangeTable) []rune {
	for _, xr := range x.R16 {
		lo, hi, stride := rune(xr.Lo), rune(xr.Hi), rune(xr.Stride)
		if stride == 1 {
			r = appendRange(r, lo, hi)
			continue
		}
		for c := lo; c <= hi; c += stride {
			r = appendRange(r, c, c)
		}
	}
	for _, xr := range x.R32 {
		lo, hi, stride := rune(xr.Lo), rune(xr.Hi), rune(xr.Stride)
		if stride == 1 {
			r = appendRange(r, lo, hi)
			continue
		}
		for c := lo; c <= hi; c += stride {
			r = appendRange(r, c, c)
		}
	}
	return r
}

// appendNegatedTable returns the result of appending the negation of x to the class r.
func appendNegatedTable(r []rune, x *unicode.RangeTable) []rune {
	nextLo := '\u0000' // lo end of next class to add
	for _, xr := range x.R16 {
		lo, hi, stride := rune(xr.Lo), rune(xr.Hi), rune(xr.Stride)
		if stride == 1 {
			if nextLo <= lo-1 {
				r = appendRange(r, nextLo, lo-1)
			}
			nextLo = hi + 1
			continue
		}
		for c := lo; c <= hi; c += stride {
			if nextLo <= c-1 {
				r = appendRange(r, nextLo, c-1)
			}
			nextLo = c + 1
		}
	}
	for _, xr := range x.R32 {
		lo, hi, stride := rune(xr.Lo), rune(xr.Hi), rune(xr.Stride)
		if stride == 1 {
			if nextLo <= lo-1 {
				r = appendRange(r, nextLo, lo-1)
			}
			nextLo = hi + 1
			continue
		}
		for c := lo; c <= hi; c += stride {
			if nextLo <= c-1 {
				r = appendRange(r, nextLo, c-1)
			}
			nextLo = c + 1
		}
	}
	if nextLo <= unicode.MaxRune {
		r = appendRange(r, nextLo, unicode.MaxRune)
	}
	return r
}

// negateClass overwrites r and returns r's negation.
// It assumes the class r is already clean.
func negateClass(r []rune) []rune {
	nextLo := '\u0000' // lo end of next class to add
	w := 0             // write index
	for i := 0; i < len(r); i += 2 {
		lo, hi := r[i], r[i+1]
		if nextLo <= lo-1 {
			r[w] = nextLo
			r[w+1] = lo - 1
			w += 2
		}
		nextLo = hi + 1
	}
	r = r[:w]
	if nextLo <= unicode.MaxRune {
		// It's possible for the negation to have one more
		// range - this one - than the original class, so use append.
		r = append(r, nextLo, unicode.MaxRune)
	}
	return r
}

// ranges implements sort.Interface on a []rune.
// The choice of receiver type definition is strange
// but avoids an allocation since we already have
// a *[]rune.
type ranges struct {
	p *[]rune
}

func (ra ranges) Less(i, j int) bool {
	p := *ra.p
	i *= 2
	j *= 2
	return p[i] < p[j] || p[i] == p[j] && p[i+1] > p[j+1]
}

func (ra ranges) Len() int {
	return len(*ra.p) / 2
}

func (ra ranges) Swap(i, j int) {
	p := *ra.p
	i *= 2
	j *= 2
	p[i], p[i+1], p[j], p[j+1] = p[j], p[j+1], p[i], p[i+1]
}

func checkUTF8(s string) error {
	for s != "" {
		rune, size := utf8.DecodeRuneInString(s)
		if rune == utf8.RuneError && size == 1 {
			return &Error{Code: ErrInvalidUTF8, Expr: s}
		}
		s = s[size:]
	}
	return nil
}

func nextRune(s string) (c rune, t string, err error) {
	c, size := utf8.DecodeRuneInString(s)
	if c == utf8.RuneError && size == 1 {
		return 0, "", &Error{Code: ErrInvalidUTF8, Expr: s}
	}
	return c, s[size:], nil
}

func isalnum(c rune) bool {
	return '0' <= c && c <= '9' || 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z'
}

func unhex(c rune) rune {
	if '0' <= c && c <= '9' {
		return c - '0'
	}
	if 'a' <= c && c <= 'f' {
		return c - 'a' + 10
	}
	if 'A' <= c && c <= 'F' {
		return c - 'A' + 10
	}
	return -1
}
                                                                                                                                                                                                                                                                                                           root/go1.4/src/regexp/syntax/parse_test.go                                                          0100644 0000000 0000000 00000034452 12600426227 017200  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package syntax

import (
	"bytes"
	"fmt"
	"testing"
	"unicode"
)

type parseTest struct {
	Regexp string
	Dump   string
}

var parseTests = []parseTest{
	// Base cases
	{`a`, `lit{a}`},
	{`a.`, `cat{lit{a}dot{}}`},
	{`a.b`, `cat{lit{a}dot{}lit{b}}`},
	{`ab`, `str{ab}`},
	{`a.b.c`, `cat{lit{a}dot{}lit{b}dot{}lit{c}}`},
	{`abc`, `str{abc}`},
	{`a|^`, `alt{lit{a}bol{}}`},
	{`a|b`, `cc{0x61-0x62}`},
	{`(a)`, `cap{lit{a}}`},
	{`(a)|b`, `alt{cap{lit{a}}lit{b}}`},
	{`a*`, `star{lit{a}}`},
	{`a+`, `plus{lit{a}}`},
	{`a?`, `que{lit{a}}`},
	{`a{2}`, `rep{2,2 lit{a}}`},
	{`a{2,3}`, `rep{2,3 lit{a}}`},
	{`a{2,}`, `rep{2,-1 lit{a}}`},
	{`a*?`, `nstar{lit{a}}`},
	{`a+?`, `nplus{lit{a}}`},
	{`a??`, `nque{lit{a}}`},
	{`a{2}?`, `nrep{2,2 lit{a}}`},
	{`a{2,3}?`, `nrep{2,3 lit{a}}`},
	{`a{2,}?`, `nrep{2,-1 lit{a}}`},
	// Malformed { } are treated as literals.
	{`x{1001`, `str{x{1001}`},
	{`x{9876543210`, `str{x{9876543210}`},
	{`x{9876543210,`, `str{x{9876543210,}`},
	{`x{2,1`, `str{x{2,1}`},
	{`x{1,9876543210`, `str{x{1,9876543210}`},
	{``, `emp{}`},
	{`|`, `emp{}`}, // alt{emp{}emp{}} but got factored
	{`|x|`, `alt{emp{}lit{x}emp{}}`},
	{`.`, `dot{}`},
	{`^`, `bol{}`},
	{`$`, `eol{}`},
	{`\|`, `lit{|}`},
	{`\(`, `lit{(}`},
	{`\)`, `lit{)}`},
	{`\*`, `lit{*}`},
	{`\+`, `lit{+}`},
	{`\?`, `lit{?}`},
	{`{`, `lit{{}`},
	{`}`, `lit{}}`},
	{`\.`, `lit{.}`},
	{`\^`, `lit{^}`},
	{`\$`, `lit{$}`},
	{`\\`, `lit{\}`},
	{`[ace]`, `cc{0x61 0x63 0x65}`},
	{`[abc]`, `cc{0x61-0x63}`},
	{`[a-z]`, `cc{0x61-0x7a}`},
	{`[a]`, `lit{a}`},
	{`\-`, `lit{-}`},
	{`-`, `lit{-}`},
	{`\_`, `lit{_}`},
	{`abc`, `str{abc}`},
	{`abc|def`, `alt{str{abc}str{def}}`},
	{`abc|def|ghi`, `alt{str{abc}str{def}str{ghi}}`},

	// Posix and Perl extensions
	{`[[:lower:]]`, `cc{0x61-0x7a}`},
	{`[a-z]`, `cc{0x61-0x7a}`},
	{`[^[:lower:]]`, `cc{0x0-0x60 0x7b-0x10ffff}`},
	{`[[:^lower:]]`, `cc{0x0-0x60 0x7b-0x10ffff}`},
	{`(?i)[[:lower:]]`, `cc{0x41-0x5a 0x61-0x7a 0x17f 0x212a}`},
	{`(?i)[a-z]`, `cc{0x41-0x5a 0x61-0x7a 0x17f 0x212a}`},
	{`(?i)[^[:lower:]]`, `cc{0x0-0x40 0x5b-0x60 0x7b-0x17e 0x180-0x2129 0x212b-0x10ffff}`},
	{`(?i)[[:^lower:]]`, `cc{0x0-0x40 0x5b-0x60 0x7b-0x17e 0x180-0x2129 0x212b-0x10ffff}`},
	{`\d`, `cc{0x30-0x39}`},
	{`\D`, `cc{0x0-0x2f 0x3a-0x10ffff}`},
	{`\s`, `cc{0x9-0xa 0xc-0xd 0x20}`},
	{`\S`, `cc{0x0-0x8 0xb 0xe-0x1f 0x21-0x10ffff}`},
	{`\w`, `cc{0x30-0x39 0x41-0x5a 0x5f 0x61-0x7a}`},
	{`\W`, `cc{0x0-0x2f 0x3a-0x40 0x5b-0x5e 0x60 0x7b-0x10ffff}`},
	{`(?i)\w`, `cc{0x30-0x39 0x41-0x5a 0x5f 0x61-0x7a 0x17f 0x212a}`},
	{`(?i)\W`, `cc{0x0-0x2f 0x3a-0x40 0x5b-0x5e 0x60 0x7b-0x17e 0x180-0x2129 0x212b-0x10ffff}`},
	{`[^\\]`, `cc{0x0-0x5b 0x5d-0x10ffff}`},
	//	{ `\C`, `byte{}` },  // probably never

	// Unicode, negatives, and a double negative.
	{`\p{Braille}`, `cc{0x2800-0x28ff}`},
	{`\P{Braille}`, `cc{0x0-0x27ff 0x2900-0x10ffff}`},
	{`\p{^Braille}`, `cc{0x0-0x27ff 0x2900-0x10ffff}`},
	{`\P{^Braille}`, `cc{0x2800-0x28ff}`},
	{`\pZ`, `cc{0x20 0xa0 0x1680 0x2000-0x200a 0x2028-0x2029 0x202f 0x205f 0x3000}`},
	{`[\p{Braille}]`, `cc{0x2800-0x28ff}`},
	{`[\P{Braille}]`, `cc{0x0-0x27ff 0x2900-0x10ffff}`},
	{`[\p{^Braille}]`, `cc{0x0-0x27ff 0x2900-0x10ffff}`},
	{`[\P{^Braille}]`, `cc{0x2800-0x28ff}`},
	{`[\pZ]`, `cc{0x20 0xa0 0x1680 0x2000-0x200a 0x2028-0x2029 0x202f 0x205f 0x3000}`},
	{`\p{Lu}`, mkCharClass(unicode.IsUpper)},
	{`[\p{Lu}]`, mkCharClass(unicode.IsUpper)},
	{`(?i)[\p{Lu}]`, mkCharClass(isUpperFold)},
	{`\p{Any}`, `dot{}`},
	{`\p{^Any}`, `cc{}`},

	// Hex, octal.
	{`[\012-\234]\141`, `cat{cc{0xa-0x9c}lit{a}}`},
	{`[\x{41}-\x7a]\x61`, `cat{cc{0x41-0x7a}lit{a}}`},

	// More interesting regular expressions.
	{`a{,2}`, `str{a{,2}}`},
	{`\.\^\$\\`, `str{.^$\}`},
	{`[a-zABC]`, `cc{0x41-0x43 0x61-0x7a}`},
	{`[^a]`, `cc{0x0-0x60 0x62-0x10ffff}`},
	{`[-]`, `cc{0x3b1-0x3b5 0x263a}`}, // utf-8
	{`a*{`, `cat{star{lit{a}}lit{{}}`},

	// Test precedences
	{`(?:ab)*`, `star{str{ab}}`},
	{`(ab)*`, `star{cap{str{ab}}}`},
	{`ab|cd`, `alt{str{ab}str{cd}}`},
	{`a(b|c)d`, `cat{lit{a}cap{cc{0x62-0x63}}lit{d}}`},

	// Test flattening.
	{`(?:a)`, `lit{a}`},
	{`(?:ab)(?:cd)`, `str{abcd}`},
	{`(?:a+b+)(?:c+d+)`, `cat{plus{lit{a}}plus{lit{b}}plus{lit{c}}plus{lit{d}}}`},
	{`(?:a+|b+)|(?:c+|d+)`, `alt{plus{lit{a}}plus{lit{b}}plus{lit{c}}plus{lit{d}}}`},
	{`(?:a|b)|(?:c|d)`, `cc{0x61-0x64}`},
	{`a|.`, `dot{}`},
	{`.|a`, `dot{}`},
	{`(?:[abc]|A|Z|hello|world)`, `alt{cc{0x41 0x5a 0x61-0x63}str{hello}str{world}}`},
	{`(?:[abc]|A|Z)`, `cc{0x41 0x5a 0x61-0x63}`},

	// Test Perl quoted literals
	{`\Q+|*?{[\E`, `str{+|*?{[}`},
	{`\Q+\E+`, `plus{lit{+}}`},
	{`\Q\\E`, `lit{\}`},
	{`\Q\\\E`, `str{\\}`},

	// Test Perl \A and \z
	{`(?m)^`, `bol{}`},
	{`(?m)$`, `eol{}`},
	{`(?-m)^`, `bot{}`},
	{`(?-m)$`, `eot{}`},
	{`(?m)\A`, `bot{}`},
	{`(?m)\z`, `eot{\z}`},
	{`(?-m)\A`, `bot{}`},
	{`(?-m)\z`, `eot{\z}`},

	// Test named captures
	{`(?P<name>a)`, `cap{name:lit{a}}`},

	// Case-folded literals
	{`[Aa]`, `litfold{A}`},
	{`[\x{100}\x{101}]`, `litfold{}`},
	{`[]`, `litfold{}`},

	// Strings
	{`abcde`, `str{abcde}`},
	{`[Aa][Bb]cd`, `cat{strfold{AB}str{cd}}`},

	// Factoring.
	{`abc|abd|aef|bcx|bcy`, `alt{cat{lit{a}alt{cat{lit{b}cc{0x63-0x64}}str{ef}}}cat{str{bc}cc{0x78-0x79}}}`},
	{`ax+y|ax+z|ay+w`, `cat{lit{a}alt{cat{plus{lit{x}}cc{0x79-0x7a}}cat{plus{lit{y}}lit{w}}}}`},

	// Bug fixes.
	{`(?:.)`, `dot{}`},
	{`(?:x|(?:xa))`, `cat{lit{x}alt{emp{}lit{a}}}`},
	{`(?:.|(?:.a))`, `cat{dot{}alt{emp{}lit{a}}}`},
	{`(?:A(?:A|a))`, `cat{lit{A}litfold{A}}`},
	{`(?:A|a)`, `litfold{A}`},
	{`A|(?:A|a)`, `litfold{A}`},
	{`(?s).`, `dot{}`},
	{`(?-s).`, `dnl{}`},
	{`(?:(?:^).)`, `cat{bol{}dot{}}`},
	{`(?-s)(?:(?:^).)`, `cat{bol{}dnl{}}`},

	// RE2 prefix_tests
	{`abc|abd`, `cat{str{ab}cc{0x63-0x64}}`},
	{`a(?:b)c|abd`, `cat{str{ab}cc{0x63-0x64}}`},
	{`abc|abd|aef|bcx|bcy`,
		`alt{cat{lit{a}alt{cat{lit{b}cc{0x63-0x64}}str{ef}}}` +
			`cat{str{bc}cc{0x78-0x79}}}`},
	{`abc|x|abd`, `alt{str{abc}lit{x}str{abd}}`},
	{`(?i)abc|ABD`, `cat{strfold{AB}cc{0x43-0x44 0x63-0x64}}`},
	{`[ab]c|[ab]d`, `cat{cc{0x61-0x62}cc{0x63-0x64}}`},
	{`(?:xx|yy)c|(?:xx|yy)d`,
		`cat{alt{str{xx}str{yy}}cc{0x63-0x64}}`},
	{`x{2}|x{2}[0-9]`,
		`cat{rep{2,2 lit{x}}alt{emp{}cc{0x30-0x39}}}`},
	{`x{2}y|x{2}[0-9]y`,
		`cat{rep{2,2 lit{x}}alt{lit{y}cat{cc{0x30-0x39}lit{y}}}}`},

	// Valid repetitions.
	{`((((((((((x{2}){2}){2}){2}){2}){2}){2}){2}){2}))`, ``},
	{`((((((((((x{1}){2}){2}){2}){2}){2}){2}){2}){2}){2})`, ``},
}

const testFlags = MatchNL | PerlX | UnicodeGroups

func TestParseSimple(t *testing.T) {
	testParseDump(t, parseTests, testFlags)
}

var foldcaseTests = []parseTest{
	{`AbCdE`, `strfold{ABCDE}`},
	{`[Aa]`, `litfold{A}`},
	{`a`, `litfold{A}`},

	// 0x17F is an old English long s (looks like an f) and folds to s.
	// 0x212A is the Kelvin symbol and folds to k.
	{`A[F-g]`, `cat{litfold{A}cc{0x41-0x7a 0x17f 0x212a}}`}, // [Aa][A-z...]
	{`[[:upper:]]`, `cc{0x41-0x5a 0x61-0x7a 0x17f 0x212a}`},
	{`[[:lower:]]`, `cc{0x41-0x5a 0x61-0x7a 0x17f 0x212a}`},
}

func TestParseFoldCase(t *testing.T) {
	testParseDump(t, foldcaseTests, FoldCase)
}

var literalTests = []parseTest{
	{"(|)^$.[*+?]{5,10},\\", "str{(|)^$.[*+?]{5,10},\\}"},
}

func TestParseLiteral(t *testing.T) {
	testParseDump(t, literalTests, Literal)
}

var matchnlTests = []parseTest{
	{`.`, `dot{}`},
	{"\n", "lit{\n}"},
	{`[^a]`, `cc{0x0-0x60 0x62-0x10ffff}`},
	{`[a\n]`, `cc{0xa 0x61}`},
}

func TestParseMatchNL(t *testing.T) {
	testParseDump(t, matchnlTests, MatchNL)
}

var nomatchnlTests = []parseTest{
	{`.`, `dnl{}`},
	{"\n", "lit{\n}"},
	{`[^a]`, `cc{0x0-0x9 0xb-0x60 0x62-0x10ffff}`},
	{`[a\n]`, `cc{0xa 0x61}`},
}

func TestParseNoMatchNL(t *testing.T) {
	testParseDump(t, nomatchnlTests, 0)
}

// Test Parse -> Dump.
func testParseDump(t *testing.T, tests []parseTest, flags Flags) {
	for _, tt := range tests {
		re, err := Parse(tt.Regexp, flags)
		if err != nil {
			t.Errorf("Parse(%#q): %v", tt.Regexp, err)
			continue
		}
		if tt.Dump == "" {
			// It parsed. That's all we care about.
			continue
		}
		d := dump(re)
		if d != tt.Dump {
			t.Errorf("Parse(%#q).Dump() = %#q want %#q", tt.Regexp, d, tt.Dump)
		}
	}
}

// dump prints a string representation of the regexp showing
// the structure explicitly.
func dump(re *Regexp) string {
	var b bytes.Buffer
	dumpRegexp(&b, re)
	return b.String()
}

var opNames = []string{
	OpNoMatch:        "no",
	OpEmptyMatch:     "emp",
	OpLiteral:        "lit",
	OpCharClass:      "cc",
	OpAnyCharNotNL:   "dnl",
	OpAnyChar:        "dot",
	OpBeginLine:      "bol",
	OpEndLine:        "eol",
	OpBeginText:      "bot",
	OpEndText:        "eot",
	OpWordBoundary:   "wb",
	OpNoWordBoundary: "nwb",
	OpCapture:        "cap",
	OpStar:           "star",
	OpPlus:           "plus",
	OpQuest:          "que",
	OpRepeat:         "rep",
	OpConcat:         "cat",
	OpAlternate:      "alt",
}

// dumpRegexp writes an encoding of the syntax tree for the regexp re to b.
// It is used during testing to distinguish between parses that might print
// the same using re's String method.
func dumpRegexp(b *bytes.Buffer, re *Regexp) {
	if int(re.Op) >= len(opNames) || opNames[re.Op] == "" {
		fmt.Fprintf(b, "op%d", re.Op)
	} else {
		switch re.Op {
		default:
			b.WriteString(opNames[re.Op])
		case OpStar, OpPlus, OpQuest, OpRepeat:
			if re.Flags&NonGreedy != 0 {
				b.WriteByte('n')
			}
			b.WriteString(opNames[re.Op])
		case OpLiteral:
			if len(re.Rune) > 1 {
				b.WriteString("str")
			} else {
				b.WriteString("lit")
			}
			if re.Flags&FoldCase != 0 {
				for _, r := range re.Rune {
					if unicode.SimpleFold(r) != r {
						b.WriteString("fold")
						break
					}
				}
			}
		}
	}
	b.WriteByte('{')
	switch re.Op {
	case OpEndText:
		if re.Flags&WasDollar == 0 {
			b.WriteString(`\z`)
		}
	case OpLiteral:
		for _, r := range re.Rune {
			b.WriteRune(r)
		}
	case OpConcat, OpAlternate:
		for _, sub := range re.Sub {
			dumpRegexp(b, sub)
		}
	case OpStar, OpPlus, OpQuest:
		dumpRegexp(b, re.Sub[0])
	case OpRepeat:
		fmt.Fprintf(b, "%d,%d ", re.Min, re.Max)
		dumpRegexp(b, re.Sub[0])
	case OpCapture:
		if re.Name != "" {
			b.WriteString(re.Name)
			b.WriteByte(':')
		}
		dumpRegexp(b, re.Sub[0])
	case OpCharClass:
		sep := ""
		for i := 0; i < len(re.Rune); i += 2 {
			b.WriteString(sep)
			sep = " "
			lo, hi := re.Rune[i], re.Rune[i+1]
			if lo == hi {
				fmt.Fprintf(b, "%#x", lo)
			} else {
				fmt.Fprintf(b, "%#x-%#x", lo, hi)
			}
		}
	}
	b.WriteByte('}')
}

func mkCharClass(f func(rune) bool) string {
	re := &Regexp{Op: OpCharClass}
	lo := rune(-1)
	for i := rune(0); i <= unicode.MaxRune; i++ {
		if f(i) {
			if lo < 0 {
				lo = i
			}
		} else {
			if lo >= 0 {
				re.Rune = append(re.Rune, lo, i-1)
				lo = -1
			}
		}
	}
	if lo >= 0 {
		re.Rune = append(re.Rune, lo, unicode.MaxRune)
	}
	return dump(re)
}

func isUpperFold(r rune) bool {
	if unicode.IsUpper(r) {
		return true
	}
	c := unicode.SimpleFold(r)
	for c != r {
		if unicode.IsUpper(c) {
			return true
		}
		c = unicode.SimpleFold(c)
	}
	return false
}

func TestFoldConstants(t *testing.T) {
	last := rune(-1)
	for i := rune(0); i <= unicode.MaxRune; i++ {
		if unicode.SimpleFold(i) == i {
			continue
		}
		if last == -1 && minFold != i {
			t.Errorf("minFold=%#U should be %#U", minFold, i)
		}
		last = i
	}
	if maxFold != last {
		t.Errorf("maxFold=%#U should be %#U", maxFold, last)
	}
}

func TestAppendRangeCollapse(t *testing.T) {
	// AppendRange should collapse each of the new ranges
	// into the earlier ones (it looks back two ranges), so that
	// the slice never grows very large.
	// Note that we are not calling cleanClass.
	var r []rune
	for i := rune('A'); i <= 'Z'; i++ {
		r = appendRange(r, i, i)
		r = appendRange(r, i+'a'-'A', i+'a'-'A')
	}
	if string(r) != "AZaz" {
		t.Errorf("appendRange interlaced A-Z a-z = %s, want AZaz", string(r))
	}
}

var invalidRegexps = []string{
	`(`,
	`)`,
	`(a`,
	`a)`,
	`(a))`,
	`(a|b|`,
	`a|b|)`,
	`(a|b|))`,
	`(a|b`,
	`a|b)`,
	`(a|b))`,
	`[a-z`,
	`([a-z)`,
	`[a-z)`,
	`([a-z]))`,
	`x{1001}`,
	`x{9876543210}`,
	`x{2,1}`,
	`x{1,9876543210}`,
	"\xff", // Invalid UTF-8
	"[\xff]",
	"[\\\xff]",
	"\\\xff",
	`(?P<name>a`,
	`(?P<name>`,
	`(?P<name`,
	`(?P<x y>a)`,
	`(?P<>a)`,
	`[a-Z]`,
	`(?i)[a-Z]`,
	`a{100000}`,
	`a{100000,}`,
	"((((((((((x{2}){2}){2}){2}){2}){2}){2}){2}){2}){2})",
}

var onlyPerl = []string{
	`[a-b-c]`,
	`\Qabc\E`,
	`\Q*+?{[\E`,
	`\Q\\E`,
	`\Q\\\E`,
	`\Q\\\\E`,
	`\Q\\\\\E`,
	`(?:a)`,
	`(?P<name>a)`,
}

var onlyPOSIX = []string{
	"a++",
	"a**",
	"a?*",
	"a+*",
	"a{1}*",
	".{1}{2}.{3}",
}

func TestParseInvalidRegexps(t *testing.T) {
	for _, regexp := range invalidRegexps {
		if re, err := Parse(regexp, Perl); err == nil {
			t.Errorf("Parse(%#q, Perl) = %s, should have failed", regexp, dump(re))
		}
		if re, err := Parse(regexp, POSIX); err == nil {
			t.Errorf("Parse(%#q, POSIX) = %s, should have failed", regexp, dump(re))
		}
	}
	for _, regexp := range onlyPerl {
		if _, err := Parse(regexp, Perl); err != nil {
			t.Errorf("Parse(%#q, Perl): %v", regexp, err)
		}
		if re, err := Parse(regexp, POSIX); err == nil {
			t.Errorf("Parse(%#q, POSIX) = %s, should have failed", regexp, dump(re))
		}
	}
	for _, regexp := range onlyPOSIX {
		if re, err := Parse(regexp, Perl); err == nil {
			t.Errorf("Parse(%#q, Perl) = %s, should have failed", regexp, dump(re))
		}
		if _, err := Parse(regexp, POSIX); err != nil {
			t.Errorf("Parse(%#q, POSIX): %v", regexp, err)
		}
	}
}

func TestToStringEquivalentParse(t *testing.T) {
	for _, tt := range parseTests {
		re, err := Parse(tt.Regexp, testFlags)
		if err != nil {
			t.Errorf("Parse(%#q): %v", tt.Regexp, err)
			continue
		}
		if tt.Dump == "" {
			// It parsed. That's all we care about.
			continue
		}
		d := dump(re)
		if d != tt.Dump {
			t.Errorf("Parse(%#q).Dump() = %#q want %#q", tt.Regexp, d, tt.Dump)
			continue
		}

		s := re.String()
		if s != tt.Regexp {
			// If ToString didn't return the original regexp,
			// it must have found one with fewer parens.
			// Unfortunately we can't check the length here, because
			// ToString produces "\\{" for a literal brace,
			// but "{" is a shorter equivalent in some contexts.
			nre, err := Parse(s, testFlags)
			if err != nil {
				t.Errorf("Parse(%#q.String() = %#q): %v", tt.Regexp, s, err)
				continue
			}
			nd := dump(nre)
			if d != nd {
				t.Errorf("Parse(%#q) -> %#q; %#q vs %#q", tt.Regexp, s, d, nd)
			}

			ns := nre.String()
			if s != ns {
				t.Errorf("Parse(%#q) -> %#q -> %#q", tt.Regexp, s, ns)
			}
		}
	}
}
                                                                                                                                                                                                                      root/go1.4/src/regexp/syntax/perl_groups.go                                                         0100644 0000000 0000000 00000004543 12600426227 017366  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// GENERATED BY make_perl_groups.pl; DO NOT EDIT.
// make_perl_groups.pl >perl_groups.go

package syntax

var code1 = []rune{ /* \d */
	0x30, 0x39,
}

var code2 = []rune{ /* \s */
	0x9, 0xa,
	0xc, 0xd,
	0x20, 0x20,
}

var code3 = []rune{ /* \w */
	0x30, 0x39,
	0x41, 0x5a,
	0x5f, 0x5f,
	0x61, 0x7a,
}

var perlGroup = map[string]charGroup{
	`\d`: {+1, code1},
	`\D`: {-1, code1},
	`\s`: {+1, code2},
	`\S`: {-1, code2},
	`\w`: {+1, code3},
	`\W`: {-1, code3},
}
var code4 = []rune{ /* [:alnum:] */
	0x30, 0x39,
	0x41, 0x5a,
	0x61, 0x7a,
}

var code5 = []rune{ /* [:alpha:] */
	0x41, 0x5a,
	0x61, 0x7a,
}

var code6 = []rune{ /* [:ascii:] */
	0x0, 0x7f,
}

var code7 = []rune{ /* [:blank:] */
	0x9, 0x9,
	0x20, 0x20,
}

var code8 = []rune{ /* [:cntrl:] */
	0x0, 0x1f,
	0x7f, 0x7f,
}

var code9 = []rune{ /* [:digit:] */
	0x30, 0x39,
}

var code10 = []rune{ /* [:graph:] */
	0x21, 0x7e,
}

var code11 = []rune{ /* [:lower:] */
	0x61, 0x7a,
}

var code12 = []rune{ /* [:print:] */
	0x20, 0x7e,
}

var code13 = []rune{ /* [:punct:] */
	0x21, 0x2f,
	0x3a, 0x40,
	0x5b, 0x60,
	0x7b, 0x7e,
}

var code14 = []rune{ /* [:space:] */
	0x9, 0xd,
	0x20, 0x20,
}

var code15 = []rune{ /* [:upper:] */
	0x41, 0x5a,
}

var code16 = []rune{ /* [:word:] */
	0x30, 0x39,
	0x41, 0x5a,
	0x5f, 0x5f,
	0x61, 0x7a,
}

var code17 = []rune{ /* [:xdigit:] */
	0x30, 0x39,
	0x41, 0x46,
	0x61, 0x66,
}

var posixGroup = map[string]charGroup{
	`[:alnum:]`:   {+1, code4},
	`[:^alnum:]`:  {-1, code4},
	`[:alpha:]`:   {+1, code5},
	`[:^alpha:]`:  {-1, code5},
	`[:ascii:]`:   {+1, code6},
	`[:^ascii:]`:  {-1, code6},
	`[:blank:]`:   {+1, code7},
	`[:^blank:]`:  {-1, code7},
	`[:cntrl:]`:   {+1, code8},
	`[:^cntrl:]`:  {-1, code8},
	`[:digit:]`:   {+1, code9},
	`[:^digit:]`:  {-1, code9},
	`[:graph:]`:   {+1, code10},
	`[:^graph:]`:  {-1, code10},
	`[:lower:]`:   {+1, code11},
	`[:^lower:]`:  {-1, code11},
	`[:print:]`:   {+1, code12},
	`[:^print:]`:  {-1, code12},
	`[:punct:]`:   {+1, code13},
	`[:^punct:]`:  {-1, code13},
	`[:space:]`:   {+1, code14},
	`[:^space:]`:  {-1, code14},
	`[:upper:]`:   {+1, code15},
	`[:^upper:]`:  {-1, code15},
	`[:word:]`:    {+1, code16},
	`[:^word:]`:   {-1, code16},
	`[:xdigit:]`:  {+1, code17},
	`[:^xdigit:]`: {-1, code17},
}
                                                                                                                                                             root/go1.4/src/regexp/syntax/prog.go                                                                0100644 0000000 0000000 00000017225 12600426227 015775  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package syntax

import (
	"bytes"
	"strconv"
	"unicode"
)

// Compiled program.
// May not belong in this package, but convenient for now.

// A Prog is a compiled regular expression program.
type Prog struct {
	Inst   []Inst
	Start  int // index of start instruction
	NumCap int // number of InstCapture insts in re
}

// An InstOp is an instruction opcode.
type InstOp uint8

const (
	InstAlt InstOp = iota
	InstAltMatch
	InstCapture
	InstEmptyWidth
	InstMatch
	InstFail
	InstNop
	InstRune
	InstRune1
	InstRuneAny
	InstRuneAnyNotNL
)

var instOpNames = []string{
	"InstAlt",
	"InstAltMatch",
	"InstCapture",
	"InstEmptyWidth",
	"InstMatch",
	"InstFail",
	"InstNop",
	"InstRune",
	"InstRune1",
	"InstRuneAny",
	"InstRuneAnyNotNL",
}

func (i InstOp) String() string {
	if uint(i) >= uint(len(instOpNames)) {
		return ""
	}
	return instOpNames[i]
}

// An EmptyOp specifies a kind or mixture of zero-width assertions.
type EmptyOp uint8

const (
	EmptyBeginLine EmptyOp = 1 << iota
	EmptyEndLine
	EmptyBeginText
	EmptyEndText
	EmptyWordBoundary
	EmptyNoWordBoundary
)

// EmptyOpContext returns the zero-width assertions
// satisfied at the position between the runes r1 and r2.
// Passing r1 == -1 indicates that the position is
// at the beginning of the text.
// Passing r2 == -1 indicates that the position is
// at the end of the text.
func EmptyOpContext(r1, r2 rune) EmptyOp {
	var op EmptyOp = EmptyNoWordBoundary
	var boundary byte
	switch {
	case IsWordChar(r1):
		boundary = 1
	case r1 == '\n':
		op |= EmptyBeginLine
	case r1 < 0:
		op |= EmptyBeginText | EmptyBeginLine
	}
	switch {
	case IsWordChar(r2):
		boundary ^= 1
	case r2 == '\n':
		op |= EmptyEndLine
	case r2 < 0:
		op |= EmptyEndText | EmptyEndLine
	}
	if boundary != 0 { // IsWordChar(r1) != IsWordChar(r2)
		op ^= (EmptyWordBoundary | EmptyNoWordBoundary)
	}
	return op
}

// IsWordChar reports whether r is consider a ``word character''
// during the evaluation of the \b and \B zero-width assertions.
// These assertions are ASCII-only: the word characters are [A-Za-z0-9_].
func IsWordChar(r rune) bool {
	return 'A' <= r && r <= 'Z' || 'a' <= r && r <= 'z' || '0' <= r && r <= '9' || r == '_'
}

// An Inst is a single instruction in a regular expression program.
type Inst struct {
	Op   InstOp
	Out  uint32 // all but InstMatch, InstFail
	Arg  uint32 // InstAlt, InstAltMatch, InstCapture, InstEmptyWidth
	Rune []rune
}

func (p *Prog) String() string {
	var b bytes.Buffer
	dumpProg(&b, p)
	return b.String()
}

// skipNop follows any no-op or capturing instructions
// and returns the resulting pc.
func (p *Prog) skipNop(pc uint32) (*Inst, uint32) {
	i := &p.Inst[pc]
	for i.Op == InstNop || i.Op == InstCapture {
		pc = i.Out
		i = &p.Inst[pc]
	}
	return i, pc
}

// op returns i.Op but merges all the Rune special cases into InstRune
func (i *Inst) op() InstOp {
	op := i.Op
	switch op {
	case InstRune1, InstRuneAny, InstRuneAnyNotNL:
		op = InstRune
	}
	return op
}

// Prefix returns a literal string that all matches for the
// regexp must start with.  Complete is true if the prefix
// is the entire match.
func (p *Prog) Prefix() (prefix string, complete bool) {
	i, _ := p.skipNop(uint32(p.Start))

	// Avoid allocation of buffer if prefix is empty.
	if i.op() != InstRune || len(i.Rune) != 1 {
		return "", i.Op == InstMatch
	}

	// Have prefix; gather characters.
	var buf bytes.Buffer
	for i.op() == InstRune && len(i.Rune) == 1 && Flags(i.Arg)&FoldCase == 0 {
		buf.WriteRune(i.Rune[0])
		i, _ = p.skipNop(i.Out)
	}
	return buf.String(), i.Op == InstMatch
}

// StartCond returns the leading empty-width conditions that must
// be true in any match.  It returns ^EmptyOp(0) if no matches are possible.
func (p *Prog) StartCond() EmptyOp {
	var flag EmptyOp
	pc := uint32(p.Start)
	i := &p.Inst[pc]
Loop:
	for {
		switch i.Op {
		case InstEmptyWidth:
			flag |= EmptyOp(i.Arg)
		case InstFail:
			return ^EmptyOp(0)
		case InstCapture, InstNop:
			// skip
		default:
			break Loop
		}
		pc = i.Out
		i = &p.Inst[pc]
	}
	return flag
}

const noMatch = -1

// MatchRune returns true if the instruction matches (and consumes) r.
// It should only be called when i.Op == InstRune.
func (i *Inst) MatchRune(r rune) bool {
	return i.MatchRunePos(r) != noMatch
}

// MatchRunePos checks whether the instruction matches (and consumes) r.
// If so, MatchRunePos returns the index of the matching rune pair
// (or, when len(i.Rune) == 1, rune singleton).
// If not, MatchRunePos returns -1.
// MatchRunePos should only be called when i.Op == InstRune.
func (i *Inst) MatchRunePos(r rune) int {
	rune := i.Rune

	// Special case: single-rune slice is from literal string, not char class.
	if len(rune) == 1 {
		r0 := rune[0]
		if r == r0 {
			return 0
		}
		if Flags(i.Arg)&FoldCase != 0 {
			for r1 := unicode.SimpleFold(r0); r1 != r0; r1 = unicode.SimpleFold(r1) {
				if r == r1 {
					return 0
				}
			}
		}
		return noMatch
	}

	// Peek at the first few pairs.
	// Should handle ASCII well.
	for j := 0; j < len(rune) && j <= 8; j += 2 {
		if r < rune[j] {
			return noMatch
		}
		if r <= rune[j+1] {
			return j / 2
		}
	}

	// Otherwise binary search.
	lo := 0
	hi := len(rune) / 2
	for lo < hi {
		m := lo + (hi-lo)/2
		if c := rune[2*m]; c <= r {
			if r <= rune[2*m+1] {
				return m
			}
			lo = m + 1
		} else {
			hi = m
		}
	}
	return noMatch
}

// As per re2's Prog::IsWordChar. Determines whether rune is an ASCII word char.
// Since we act on runes, it would be easy to support Unicode here.
func wordRune(r rune) bool {
	return r == '_' ||
		('A' <= r && r <= 'Z') ||
		('a' <= r && r <= 'z') ||
		('0' <= r && r <= '9')
}

// MatchEmptyWidth returns true if the instruction matches
// an empty string between the runes before and after.
// It should only be called when i.Op == InstEmptyWidth.
func (i *Inst) MatchEmptyWidth(before rune, after rune) bool {
	switch EmptyOp(i.Arg) {
	case EmptyBeginLine:
		return before == '\n' || before == -1
	case EmptyEndLine:
		return after == '\n' || after == -1
	case EmptyBeginText:
		return before == -1
	case EmptyEndText:
		return after == -1
	case EmptyWordBoundary:
		return wordRune(before) != wordRune(after)
	case EmptyNoWordBoundary:
		return wordRune(before) == wordRune(after)
	}
	panic("unknown empty width arg")
}

func (i *Inst) String() string {
	var b bytes.Buffer
	dumpInst(&b, i)
	return b.String()
}

func bw(b *bytes.Buffer, args ...string) {
	for _, s := range args {
		b.WriteString(s)
	}
}

func dumpProg(b *bytes.Buffer, p *Prog) {
	for j := range p.Inst {
		i := &p.Inst[j]
		pc := strconv.Itoa(j)
		if len(pc) < 3 {
			b.WriteString("   "[len(pc):])
		}
		if j == p.Start {
			pc += "*"
		}
		bw(b, pc, "\t")
		dumpInst(b, i)
		bw(b, "\n")
	}
}

func u32(i uint32) string {
	return strconv.FormatUint(uint64(i), 10)
}

func dumpInst(b *bytes.Buffer, i *Inst) {
	switch i.Op {
	case InstAlt:
		bw(b, "alt -> ", u32(i.Out), ", ", u32(i.Arg))
	case InstAltMatch:
		bw(b, "altmatch -> ", u32(i.Out), ", ", u32(i.Arg))
	case InstCapture:
		bw(b, "cap ", u32(i.Arg), " -> ", u32(i.Out))
	case InstEmptyWidth:
		bw(b, "empty ", u32(i.Arg), " -> ", u32(i.Out))
	case InstMatch:
		bw(b, "match")
	case InstFail:
		bw(b, "fail")
	case InstNop:
		bw(b, "nop -> ", u32(i.Out))
	case InstRune:
		if i.Rune == nil {
			// shouldn't happen
			bw(b, "rune <nil>")
		}
		bw(b, "rune ", strconv.QuoteToASCII(string(i.Rune)))
		if Flags(i.Arg)&FoldCase != 0 {
			bw(b, "/i")
		}
		bw(b, " -> ", u32(i.Out))
	case InstRune1:
		bw(b, "rune1 ", strconv.QuoteToASCII(string(i.Rune)), " -> ", u32(i.Out))
	case InstRuneAny:
		bw(b, "any -> ", u32(i.Out))
	case InstRuneAnyNotNL:
		bw(b, "anynotnl -> ", u32(i.Out))
	}
}
                                                                                                                                                                                                                                                                                                                                                                           root/go1.4/src/regexp/syntax/prog_test.go                                                           0100644 0000000 0000000 00000003520 12600426227 017025  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package syntax

import "testing"

var compileTests = []struct {
	Regexp string
	Prog   string
}{
	{"a", `  0	fail
  1*	rune1 "a" -> 2
  2	match
`},
	{"[A-M][n-z]", `  0	fail
  1*	rune "AM" -> 2
  2	rune "nz" -> 3
  3	match
`},
	{"", `  0	fail
  1*	nop -> 2
  2	match
`},
	{"a?", `  0	fail
  1	rune1 "a" -> 3
  2*	alt -> 1, 3
  3	match
`},
	{"a??", `  0	fail
  1	rune1 "a" -> 3
  2*	alt -> 3, 1
  3	match
`},
	{"a+", `  0	fail
  1*	rune1 "a" -> 2
  2	alt -> 1, 3
  3	match
`},
	{"a+?", `  0	fail
  1*	rune1 "a" -> 2
  2	alt -> 3, 1
  3	match
`},
	{"a*", `  0	fail
  1	rune1 "a" -> 2
  2*	alt -> 1, 3
  3	match
`},
	{"a*?", `  0	fail
  1	rune1 "a" -> 2
  2*	alt -> 3, 1
  3	match
`},
	{"a+b+", `  0	fail
  1*	rune1 "a" -> 2
  2	alt -> 1, 3
  3	rune1 "b" -> 4
  4	alt -> 3, 5
  5	match
`},
	{"(a+)(b+)", `  0	fail
  1*	cap 2 -> 2
  2	rune1 "a" -> 3
  3	alt -> 2, 4
  4	cap 3 -> 5
  5	cap 4 -> 6
  6	rune1 "b" -> 7
  7	alt -> 6, 8
  8	cap 5 -> 9
  9	match
`},
	{"a+|b+", `  0	fail
  1	rune1 "a" -> 2
  2	alt -> 1, 6
  3	rune1 "b" -> 4
  4	alt -> 3, 6
  5*	alt -> 1, 3
  6	match
`},
	{"A[Aa]", `  0	fail
  1*	rune1 "A" -> 2
  2	rune "A"/i -> 3
  3	match
`},
	{"(?:(?:^).)", `  0	fail
  1*	empty 4 -> 2
  2	anynotnl -> 3
  3	match
`},
}

func TestCompile(t *testing.T) {
	for _, tt := range compileTests {
		re, _ := Parse(tt.Regexp, Perl)
		p, _ := Compile(re)
		s := p.String()
		if s != tt.Prog {
			t.Errorf("compiled %#q:\n--- have\n%s---\n--- want\n%s---", tt.Regexp, s, tt.Prog)
		}
	}
}

func BenchmarkEmptyOpContext(b *testing.B) {
	for i := 0; i < b.N; i++ {
		var r1 rune = -1
		for _, r2 := range "foo, bar, baz\nsome input text.\n" {
			EmptyOpContext(r1, r2)
			r1 = r2
		}
		EmptyOpContext(r1, -1)
	}
}
                                                                                                                                                                                root/go1.4/src/regexp/syntax/regexp.go                                                              0100644 0000000 0000000 00000017140 12600426227 016314  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package syntax

// Note to implementers:
// In this package, re is always a *Regexp and r is always a rune.

import (
	"bytes"
	"strconv"
	"strings"
	"unicode"
)

// A Regexp is a node in a regular expression syntax tree.
type Regexp struct {
	Op       Op // operator
	Flags    Flags
	Sub      []*Regexp  // subexpressions, if any
	Sub0     [1]*Regexp // storage for short Sub
	Rune     []rune     // matched runes, for OpLiteral, OpCharClass
	Rune0    [2]rune    // storage for short Rune
	Min, Max int        // min, max for OpRepeat
	Cap      int        // capturing index, for OpCapture
	Name     string     // capturing name, for OpCapture
}

// An Op is a single regular expression operator.
type Op uint8

// Operators are listed in precedence order, tightest binding to weakest.
// Character class operators are listed simplest to most complex
// (OpLiteral, OpCharClass, OpAnyCharNotNL, OpAnyChar).

const (
	OpNoMatch        Op = 1 + iota // matches no strings
	OpEmptyMatch                   // matches empty string
	OpLiteral                      // matches Runes sequence
	OpCharClass                    // matches Runes interpreted as range pair list
	OpAnyCharNotNL                 // matches any character except newline
	OpAnyChar                      // matches any character
	OpBeginLine                    // matches empty string at beginning of line
	OpEndLine                      // matches empty string at end of line
	OpBeginText                    // matches empty string at beginning of text
	OpEndText                      // matches empty string at end of text
	OpWordBoundary                 // matches word boundary `\b`
	OpNoWordBoundary               // matches word non-boundary `\B`
	OpCapture                      // capturing subexpression with index Cap, optional name Name
	OpStar                         // matches Sub[0] zero or more times
	OpPlus                         // matches Sub[0] one or more times
	OpQuest                        // matches Sub[0] zero or one times
	OpRepeat                       // matches Sub[0] at least Min times, at most Max (Max == -1 is no limit)
	OpConcat                       // matches concatenation of Subs
	OpAlternate                    // matches alternation of Subs
)

const opPseudo Op = 128 // where pseudo-ops start

// Equal returns true if x and y have identical structure.
func (x *Regexp) Equal(y *Regexp) bool {
	if x == nil || y == nil {
		return x == y
	}
	if x.Op != y.Op {
		return false
	}
	switch x.Op {
	case OpEndText:
		// The parse flags remember whether this is \z or \Z.
		if x.Flags&WasDollar != y.Flags&WasDollar {
			return false
		}

	case OpLiteral, OpCharClass:
		if len(x.Rune) != len(y.Rune) {
			return false
		}
		for i, r := range x.Rune {
			if r != y.Rune[i] {
				return false
			}
		}

	case OpAlternate, OpConcat:
		if len(x.Sub) != len(y.Sub) {
			return false
		}
		for i, sub := range x.Sub {
			if !sub.Equal(y.Sub[i]) {
				return false
			}
		}

	case OpStar, OpPlus, OpQuest:
		if x.Flags&NonGreedy != y.Flags&NonGreedy || !x.Sub[0].Equal(y.Sub[0]) {
			return false
		}

	case OpRepeat:
		if x.Flags&NonGreedy != y.Flags&NonGreedy || x.Min != y.Min || x.Max != y.Max || !x.Sub[0].Equal(y.Sub[0]) {
			return false
		}

	case OpCapture:
		if x.Cap != y.Cap || x.Name != y.Name || !x.Sub[0].Equal(y.Sub[0]) {
			return false
		}
	}
	return true
}

// writeRegexp writes the Perl syntax for the regular expression re to b.
func writeRegexp(b *bytes.Buffer, re *Regexp) {
	switch re.Op {
	default:
		b.WriteString("<invalid op" + strconv.Itoa(int(re.Op)) + ">")
	case OpNoMatch:
		b.WriteString(`[^\x00-\x{10FFFF}]`)
	case OpEmptyMatch:
		b.WriteString(`(?:)`)
	case OpLiteral:
		if re.Flags&FoldCase != 0 {
			b.WriteString(`(?i:`)
		}
		for _, r := range re.Rune {
			escape(b, r, false)
		}
		if re.Flags&FoldCase != 0 {
			b.WriteString(`)`)
		}
	case OpCharClass:
		if len(re.Rune)%2 != 0 {
			b.WriteString(`[invalid char class]`)
			break
		}
		b.WriteRune('[')
		if len(re.Rune) == 0 {
			b.WriteString(`^\x00-\x{10FFFF}`)
		} else if re.Rune[0] == 0 && re.Rune[len(re.Rune)-1] == unicode.MaxRune {
			// Contains 0 and MaxRune.  Probably a negated class.
			// Print the gaps.
			b.WriteRune('^')
			for i := 1; i < len(re.Rune)-1; i += 2 {
				lo, hi := re.Rune[i]+1, re.Rune[i+1]-1
				escape(b, lo, lo == '-')
				if lo != hi {
					b.WriteRune('-')
					escape(b, hi, hi == '-')
				}
			}
		} else {
			for i := 0; i < len(re.Rune); i += 2 {
				lo, hi := re.Rune[i], re.Rune[i+1]
				escape(b, lo, lo == '-')
				if lo != hi {
					b.WriteRune('-')
					escape(b, hi, hi == '-')
				}
			}
		}
		b.WriteRune(']')
	case OpAnyCharNotNL:
		b.WriteString(`(?-s:.)`)
	case OpAnyChar:
		b.WriteString(`(?s:.)`)
	case OpBeginLine:
		b.WriteRune('^')
	case OpEndLine:
		b.WriteRune('$')
	case OpBeginText:
		b.WriteString(`\A`)
	case OpEndText:
		if re.Flags&WasDollar != 0 {
			b.WriteString(`(?-m:$)`)
		} else {
			b.WriteString(`\z`)
		}
	case OpWordBoundary:
		b.WriteString(`\b`)
	case OpNoWordBoundary:
		b.WriteString(`\B`)
	case OpCapture:
		if re.Name != "" {
			b.WriteString(`(?P<`)
			b.WriteString(re.Name)
			b.WriteRune('>')
		} else {
			b.WriteRune('(')
		}
		if re.Sub[0].Op != OpEmptyMatch {
			writeRegexp(b, re.Sub[0])
		}
		b.WriteRune(')')
	case OpStar, OpPlus, OpQuest, OpRepeat:
		if sub := re.Sub[0]; sub.Op > OpCapture || sub.Op == OpLiteral && len(sub.Rune) > 1 {
			b.WriteString(`(?:`)
			writeRegexp(b, sub)
			b.WriteString(`)`)
		} else {
			writeRegexp(b, sub)
		}
		switch re.Op {
		case OpStar:
			b.WriteRune('*')
		case OpPlus:
			b.WriteRune('+')
		case OpQuest:
			b.WriteRune('?')
		case OpRepeat:
			b.WriteRune('{')
			b.WriteString(strconv.Itoa(re.Min))
			if re.Max != re.Min {
				b.WriteRune(',')
				if re.Max >= 0 {
					b.WriteString(strconv.Itoa(re.Max))
				}
			}
			b.WriteRune('}')
		}
		if re.Flags&NonGreedy != 0 {
			b.WriteRune('?')
		}
	case OpConcat:
		for _, sub := range re.Sub {
			if sub.Op == OpAlternate {
				b.WriteString(`(?:`)
				writeRegexp(b, sub)
				b.WriteString(`)`)
			} else {
				writeRegexp(b, sub)
			}
		}
	case OpAlternate:
		for i, sub := range re.Sub {
			if i > 0 {
				b.WriteRune('|')
			}
			writeRegexp(b, sub)
		}
	}
}

func (re *Regexp) String() string {
	var b bytes.Buffer
	writeRegexp(&b, re)
	return b.String()
}

const meta = `\.+*?()|[]{}^$`

func escape(b *bytes.Buffer, r rune, force bool) {
	if unicode.IsPrint(r) {
		if strings.IndexRune(meta, r) >= 0 || force {
			b.WriteRune('\\')
		}
		b.WriteRune(r)
		return
	}

	switch r {
	case '\a':
		b.WriteString(`\a`)
	case '\f':
		b.WriteString(`\f`)
	case '\n':
		b.WriteString(`\n`)
	case '\r':
		b.WriteString(`\r`)
	case '\t':
		b.WriteString(`\t`)
	case '\v':
		b.WriteString(`\v`)
	default:
		if r < 0x100 {
			b.WriteString(`\x`)
			s := strconv.FormatInt(int64(r), 16)
			if len(s) == 1 {
				b.WriteRune('0')
			}
			b.WriteString(s)
			break
		}
		b.WriteString(`\x{`)
		b.WriteString(strconv.FormatInt(int64(r), 16))
		b.WriteString(`}`)
	}
}

// MaxCap walks the regexp to find the maximum capture index.
func (re *Regexp) MaxCap() int {
	m := 0
	if re.Op == OpCapture {
		m = re.Cap
	}
	for _, sub := range re.Sub {
		if n := sub.MaxCap(); m < n {
			m = n
		}
	}
	return m
}

// CapNames walks the regexp to find the names of capturing groups.
func (re *Regexp) CapNames() []string {
	names := make([]string, re.MaxCap()+1)
	re.capNames(names)
	return names
}

func (re *Regexp) capNames(names []string) {
	if re.Op == OpCapture {
		names[re.Cap] = re.Name
	}
	for _, sub := range re.Sub {
		sub.capNames(names)
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                root/go1.4/src/regexp/syntax/simplify.go                                                            0100644 0000000 0000000 00000010317 12600426227 016655  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package syntax

// Simplify returns a regexp equivalent to re but without counted repetitions
// and with various other simplifications, such as rewriting /(?:a+)+/ to /a+/.
// The resulting regexp will execute correctly but its string representation
// will not produce the same parse tree, because capturing parentheses
// may have been duplicated or removed.  For example, the simplified form
// for /(x){1,2}/ is /(x)(x)?/ but both parentheses capture as $1.
// The returned regexp may share structure with or be the original.
func (re *Regexp) Simplify() *Regexp {
	if re == nil {
		return nil
	}
	switch re.Op {
	case OpCapture, OpConcat, OpAlternate:
		// Simplify children, building new Regexp if children change.
		nre := re
		for i, sub := range re.Sub {
			nsub := sub.Simplify()
			if nre == re && nsub != sub {
				// Start a copy.
				nre = new(Regexp)
				*nre = *re
				nre.Rune = nil
				nre.Sub = append(nre.Sub0[:0], re.Sub[:i]...)
			}
			if nre != re {
				nre.Sub = append(nre.Sub, nsub)
			}
		}
		return nre

	case OpStar, OpPlus, OpQuest:
		sub := re.Sub[0].Simplify()
		return simplify1(re.Op, re.Flags, sub, re)

	case OpRepeat:
		// Special special case: x{0} matches the empty string
		// and doesn't even need to consider x.
		if re.Min == 0 && re.Max == 0 {
			return &Regexp{Op: OpEmptyMatch}
		}

		// The fun begins.
		sub := re.Sub[0].Simplify()

		// x{n,} means at least n matches of x.
		if re.Max == -1 {
			// Special case: x{0,} is x*.
			if re.Min == 0 {
				return simplify1(OpStar, re.Flags, sub, nil)
			}

			// Special case: x{1,} is x+.
			if re.Min == 1 {
				return simplify1(OpPlus, re.Flags, sub, nil)
			}

			// General case: x{4,} is xxxx+.
			nre := &Regexp{Op: OpConcat}
			nre.Sub = nre.Sub0[:0]
			for i := 0; i < re.Min-1; i++ {
				nre.Sub = append(nre.Sub, sub)
			}
			nre.Sub = append(nre.Sub, simplify1(OpPlus, re.Flags, sub, nil))
			return nre
		}

		// Special case x{0} handled above.

		// Special case: x{1} is just x.
		if re.Min == 1 && re.Max == 1 {
			return sub
		}

		// General case: x{n,m} means n copies of x and m copies of x?
		// The machine will do less work if we nest the final m copies,
		// so that x{2,5} = xx(x(x(x)?)?)?

		// Build leading prefix: xx.
		var prefix *Regexp
		if re.Min > 0 {
			prefix = &Regexp{Op: OpConcat}
			prefix.Sub = prefix.Sub0[:0]
			for i := 0; i < re.Min; i++ {
				prefix.Sub = append(prefix.Sub, sub)
			}
		}

		// Build and attach suffix: (x(x(x)?)?)?
		if re.Max > re.Min {
			suffix := simplify1(OpQuest, re.Flags, sub, nil)
			for i := re.Min + 1; i < re.Max; i++ {
				nre2 := &Regexp{Op: OpConcat}
				nre2.Sub = append(nre2.Sub0[:0], sub, suffix)
				suffix = simplify1(OpQuest, re.Flags, nre2, nil)
			}
			if prefix == nil {
				return suffix
			}
			prefix.Sub = append(prefix.Sub, suffix)
		}
		if prefix != nil {
			return prefix
		}

		// Some degenerate case like min > max or min < max < 0.
		// Handle as impossible match.
		return &Regexp{Op: OpNoMatch}
	}

	return re
}

// simplify1 implements Simplify for the unary OpStar,
// OpPlus, and OpQuest operators.  It returns the simple regexp
// equivalent to
//
//	Regexp{Op: op, Flags: flags, Sub: {sub}}
//
// under the assumption that sub is already simple, and
// without first allocating that structure.  If the regexp
// to be returned turns out to be equivalent to re, simplify1
// returns re instead.
//
// simplify1 is factored out of Simplify because the implementation
// for other operators generates these unary expressions.
// Letting them call simplify1 makes sure the expressions they
// generate are simple.
func simplify1(op Op, flags Flags, sub, re *Regexp) *Regexp {
	// Special case: repeat the empty string as much as
	// you want, but it's still the empty string.
	if sub.Op == OpEmptyMatch {
		return sub
	}
	// The operators are idempotent if the flags match.
	if op == sub.Op && flags&NonGreedy == sub.Flags&NonGreedy {
		return sub
	}
	if re != nil && re.Op == op && re.Flags&NonGreedy == flags&NonGreedy && sub == re.Sub[0] {
		return re
	}

	re = &Regexp{Op: op, Flags: flags}
	re.Sub = append(re.Sub0[:0], sub)
	return re
}
                                                                                                                                                                                                                                                                                                                 root/go1.4/src/regexp/syntax/simplify_test.go                                                       0100644 0000000 0000000 00000010002 12600426227 017703  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package syntax

import "testing"

var simplifyTests = []struct {
	Regexp string
	Simple string
}{
	// Already-simple constructs
	{`a`, `a`},
	{`ab`, `ab`},
	{`a|b`, `[a-b]`},
	{`ab|cd`, `ab|cd`},
	{`(ab)*`, `(ab)*`},
	{`(ab)+`, `(ab)+`},
	{`(ab)?`, `(ab)?`},
	{`.`, `(?s:.)`},
	{`^`, `^`},
	{`$`, `$`},
	{`[ac]`, `[ac]`},
	{`[^ac]`, `[^ac]`},

	// Posix character classes
	{`[[:alnum:]]`, `[0-9A-Za-z]`},
	{`[[:alpha:]]`, `[A-Za-z]`},
	{`[[:blank:]]`, `[\t ]`},
	{`[[:cntrl:]]`, `[\x00-\x1f\x7f]`},
	{`[[:digit:]]`, `[0-9]`},
	{`[[:graph:]]`, `[!-~]`},
	{`[[:lower:]]`, `[a-z]`},
	{`[[:print:]]`, `[ -~]`},
	{`[[:punct:]]`, "[!-/:-@\\[-`\\{-~]"},
	{`[[:space:]]`, `[\t-\r ]`},
	{`[[:upper:]]`, `[A-Z]`},
	{`[[:xdigit:]]`, `[0-9A-Fa-f]`},

	// Perl character classes
	{`\d`, `[0-9]`},
	{`\s`, `[\t-\n\f-\r ]`},
	{`\w`, `[0-9A-Z_a-z]`},
	{`\D`, `[^0-9]`},
	{`\S`, `[^\t-\n\f-\r ]`},
	{`\W`, `[^0-9A-Z_a-z]`},
	{`[\d]`, `[0-9]`},
	{`[\s]`, `[\t-\n\f-\r ]`},
	{`[\w]`, `[0-9A-Z_a-z]`},
	{`[\D]`, `[^0-9]`},
	{`[\S]`, `[^\t-\n\f-\r ]`},
	{`[\W]`, `[^0-9A-Z_a-z]`},

	// Posix repetitions
	{`a{1}`, `a`},
	{`a{2}`, `aa`},
	{`a{5}`, `aaaaa`},
	{`a{0,1}`, `a?`},
	// The next three are illegible because Simplify inserts (?:)
	// parens instead of () parens to avoid creating extra
	// captured subexpressions.  The comments show a version with fewer parens.
	{`(a){0,2}`, `(?:(a)(a)?)?`},                       //       (aa?)?
	{`(a){0,4}`, `(?:(a)(?:(a)(?:(a)(a)?)?)?)?`},       //   (a(a(aa?)?)?)?
	{`(a){2,6}`, `(a)(a)(?:(a)(?:(a)(?:(a)(a)?)?)?)?`}, // aa(a(a(aa?)?)?)?
	{`a{0,2}`, `(?:aa?)?`},                             //       (aa?)?
	{`a{0,4}`, `(?:a(?:a(?:aa?)?)?)?`},                 //   (a(a(aa?)?)?)?
	{`a{2,6}`, `aa(?:a(?:a(?:aa?)?)?)?`},               // aa(a(a(aa?)?)?)?
	{`a{0,}`, `a*`},
	{`a{1,}`, `a+`},
	{`a{2,}`, `aa+`},
	{`a{5,}`, `aaaaa+`},

	// Test that operators simplify their arguments.
	{`(?:a{1,}){1,}`, `a+`},
	{`(a{1,}b{1,})`, `(a+b+)`},
	{`a{1,}|b{1,}`, `a+|b+`},
	{`(?:a{1,})*`, `(?:a+)*`},
	{`(?:a{1,})+`, `a+`},
	{`(?:a{1,})?`, `(?:a+)?`},
	{``, `(?:)`},
	{`a{0}`, `(?:)`},

	// Character class simplification
	{`[ab]`, `[a-b]`},
	{`[a-za-za-z]`, `[a-z]`},
	{`[A-Za-zA-Za-z]`, `[A-Za-z]`},
	{`[ABCDEFGH]`, `[A-H]`},
	{`[AB-CD-EF-GH]`, `[A-H]`},
	{`[W-ZP-XE-R]`, `[E-Z]`},
	{`[a-ee-gg-m]`, `[a-m]`},
	{`[a-ea-ha-m]`, `[a-m]`},
	{`[a-ma-ha-e]`, `[a-m]`},
	{`[a-zA-Z0-9 -~]`, `[ -~]`},

	// Empty character classes
	{`[^[:cntrl:][:^cntrl:]]`, `[^\x00-\x{10FFFF}]`},

	// Full character classes
	{`[[:cntrl:][:^cntrl:]]`, `(?s:.)`},

	// Unicode case folding.
	{`(?i)A`, `(?i:A)`},
	{`(?i)a`, `(?i:A)`},
	{`(?i)[A]`, `(?i:A)`},
	{`(?i)[a]`, `(?i:A)`},
	{`(?i)K`, `(?i:K)`},
	{`(?i)k`, `(?i:K)`},
	{`(?i)\x{212a}`, "(?i:K)"},
	{`(?i)[K]`, "[Kk\u212A]"},
	{`(?i)[k]`, "[Kk\u212A]"},
	{`(?i)[\x{212a}]`, "[Kk\u212A]"},
	{`(?i)[a-z]`, "[A-Za-z\u017F\u212A]"},
	{`(?i)[\x00-\x{FFFD}]`, "[\\x00-\uFFFD]"},
	{`(?i)[\x00-\x{10FFFF}]`, `(?s:.)`},

	// Empty string as a regular expression.
	// The empty string must be preserved inside parens in order
	// to make submatches work right, so these tests are less
	// interesting than they might otherwise be.  String inserts
	// explicit (?:) in place of non-parenthesized empty strings,
	// to make them easier to spot for other parsers.
	{`(a|b|)`, `([a-b]|(?:))`},
	{`(|)`, `()`},
	{`a()`, `a()`},
	{`(()|())`, `(()|())`},
	{`(a|)`, `(a|(?:))`},
	{`ab()cd()`, `ab()cd()`},
	{`()`, `()`},
	{`()*`, `()*`},
	{`()+`, `()+`},
	{`()?`, `()?`},
	{`(){0}`, `(?:)`},
	{`(){1}`, `()`},
	{`(){1,}`, `()+`},
	{`(){0,2}`, `(?:()()?)?`},
}

func TestSimplify(t *testing.T) {
	for _, tt := range simplifyTests {
		re, err := Parse(tt.Regexp, MatchNL|Perl&^OneLine)
		if err != nil {
			t.Errorf("Parse(%#q) = error %v", tt.Regexp, err)
			continue
		}
		s := re.Simplify().String()
		if s != tt.Simple {
			t.Errorf("Simplify(%#q) = %#q, want %#q", tt.Regexp, s, tt.Simple)
		}
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              root/go1.4/src/regexp/testdata/                                                                     0040755 0000000 0000000 00000000000 12600426244 014755  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/regexp/testdata/README                                                               0100644 0000000 0000000 00000001676 12600426227 015645  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        AT&T POSIX Test Files
See textregex.c for copyright + license.

testregex.c	http://www2.research.att.com/~gsf/testregex/testregex.c
basic.dat	http://www2.research.att.com/~gsf/testregex/basic.dat
nullsubexpr.dat	http://www2.research.att.com/~gsf/testregex/nullsubexpr.dat
repetition.dat	http://www2.research.att.com/~gsf/testregex/repetition.dat

The test data has been edited to reflect RE2/Go differences:
  * In a star of a possibly empty match like (a*)* matching x,
    the no match case runs the starred subexpression zero times,
    not once.  This is consistent with (a*)* matching a, which
    runs the starred subexpression one time, not twice.
  * The submatch choice is first match, not the POSIX rule.

Such changes are marked with 'RE2/Go'.


RE2 Test Files

re2-exhaustive.txt.bz2 and re2-search.txt are built by running
'make log' in the RE2 distribution.  http://code.google.com/p/re2/.
The exhaustive file is compressed because it is huge.
                                                                  root/go1.4/src/regexp/testdata/basic.dat                                                            0100644 0000000 0000000 00000021034 12600426227 016526  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        NOTE	all standard compliant implementations should pass these : 2002-05-31

BE	abracadabra$	abracadabracadabra	(7,18)
BE	a...b		abababbb		(2,7)
BE	XXXXXX		..XXXXXX		(2,8)
E	\)		()	(1,2)
BE	a]		a]a	(0,2)
B	}		}	(0,1)
E	\}		}	(0,1)
BE	\]		]	(0,1)
B	]		]	(0,1)
E	]		]	(0,1)
B	{		{	(0,1)
B	}		}	(0,1)
BE	^a		ax	(0,1)
BE	\^a		a^a	(1,3)
BE	a\^		a^	(0,2)
BE	a$		aa	(1,2)
BE	a\$		a$	(0,2)
BE	^$		NULL	(0,0)
E	$^		NULL	(0,0)
E	a($)		aa	(1,2)(2,2)
E	a*(^a)		aa	(0,1)(0,1)
E	(..)*(...)*		a	(0,0)
E	(..)*(...)*		abcd	(0,4)(2,4)
E	(ab|a)(bc|c)		abc	(0,3)(0,2)(2,3)
E	(ab)c|abc		abc	(0,3)(0,2)
E	a{0}b		ab			(1,2)
E	(a*)(b?)(b+)b{3}	aaabbbbbbb	(0,10)(0,3)(3,4)(4,7)
E	(a*)(b{0,1})(b{1,})b{3}	aaabbbbbbb	(0,10)(0,3)(3,4)(4,7)
E	a{9876543210}	NULL	BADBR
E	((a|a)|a)			a	(0,1)(0,1)(0,1)
E	(a*)(a|aa)			aaaa	(0,4)(0,3)(3,4)
E	a*(a.|aa)			aaaa	(0,4)(2,4)
E	a(b)|c(d)|a(e)f			aef	(0,3)(?,?)(?,?)(1,2)
E	(a|b)?.*			b	(0,1)(0,1)
E	(a|b)c|a(b|c)			ac	(0,2)(0,1)
E	(a|b)c|a(b|c)			ab	(0,2)(?,?)(1,2)
E	(a|b)*c|(a|ab)*c		abc	(0,3)(1,2)
E	(a|b)*c|(a|ab)*c		xc	(1,2)
E	(.a|.b).*|.*(.a|.b)		xa	(0,2)(0,2)
E	a?(ab|ba)ab			abab	(0,4)(0,2)
E	a?(ac{0}b|ba)ab			abab	(0,4)(0,2)
E	ab|abab				abbabab	(0,2)
E	aba|bab|bba			baaabbbaba	(5,8)
E	aba|bab				baaabbbaba	(6,9)
E	(aa|aaa)*|(a|aaaaa)		aa	(0,2)(0,2)
E	(a.|.a.)*|(a|.a...)		aa	(0,2)(0,2)
E	ab|a				xabc	(1,3)
E	ab|a				xxabc	(2,4)
Ei	(Ab|cD)*			aBcD	(0,4)(2,4)
BE	[^-]			--a		(2,3)
BE	[a-]*			--a		(0,3)
BE	[a-m-]*			--amoma--	(0,4)
E	:::1:::0:|:::1:1:0:	:::0:::1:::1:::0:	(8,17)
E	:::1:::0:|:::1:1:1:	:::0:::1:::1:::0:	(8,17)
{E	[[:upper:]]		A		(0,1)	[[<element>]] not supported
E	[[:lower:]]+		`az{		(1,3)
E	[[:upper:]]+		@AZ[		(1,3)
# No collation in Go
#BE	[[-]]			[[-]]		(2,4)
#BE	[[.NIL.]]	NULL	ECOLLATE
#BE	[[=aleph=]]	NULL	ECOLLATE
}
BE$	\n		\n	(0,1)
BEn$	\n		\n	(0,1)
BE$	[^a]		\n	(0,1)
BE$	\na		\na	(0,2)
E	(a)(b)(c)	abc	(0,3)(0,1)(1,2)(2,3)
BE	xxx		xxx	(0,3)
E1	(^|[ (,;])((([Ff]eb[^ ]* *|0*2/|\* */?)0*[6-7]))([^0-9]|$)	feb 6,	(0,6)
E1	(^|[ (,;])((([Ff]eb[^ ]* *|0*2/|\* */?)0*[6-7]))([^0-9]|$)	2/7	(0,3)
E1	(^|[ (,;])((([Ff]eb[^ ]* *|0*2/|\* */?)0*[6-7]))([^0-9]|$)	feb 1,Feb 6	(5,11)
E3	((((((((((((((((((((((((((((((x))))))))))))))))))))))))))))))	x	(0,1)(0,1)(0,1)
E3	((((((((((((((((((((((((((((((x))))))))))))))))))))))))))))))*	xx	(0,2)(1,2)(1,2)
E	a?(ab|ba)*	ababababababababababababababababababababababababababababababababababababababababa	(0,81)(79,81)
E	abaa|abbaa|abbbaa|abbbbaa	ababbabbbabbbabbbbabbbbaa	(18,25)
E	abaa|abbaa|abbbaa|abbbbaa	ababbabbbabbbabbbbabaa	(18,22)
E	aaac|aabc|abac|abbc|baac|babc|bbac|bbbc	baaabbbabac	(7,11)
BE$	.*			\x01\xff	(0,2)
E	aaaa|bbbb|cccc|ddddd|eeeeee|fffffff|gggg|hhhh|iiiii|jjjjj|kkkkk|llll		XaaaXbbbXcccXdddXeeeXfffXgggXhhhXiiiXjjjXkkkXlllXcbaXaaaa	(53,57)
L	aaaa\nbbbb\ncccc\nddddd\neeeeee\nfffffff\ngggg\nhhhh\niiiii\njjjjj\nkkkkk\nllll		XaaaXbbbXcccXdddXeeeXfffXgggXhhhXiiiXjjjXkkkXlllXcbaXaaaa	NOMATCH
E	a*a*a*a*a*b		aaaaaaaaab	(0,10)
BE	^			NULL		(0,0)
BE	$			NULL		(0,0)
BE	^$			NULL		(0,0)
BE	^a$			a		(0,1)
BE	abc			abc		(0,3)
BE	abc			xabcy		(1,4)
BE	abc			ababc		(2,5)
BE	ab*c			abc		(0,3)
BE	ab*bc			abc		(0,3)
BE	ab*bc			abbc		(0,4)
BE	ab*bc			abbbbc		(0,6)
E	ab+bc			abbc		(0,4)
E	ab+bc			abbbbc		(0,6)
E	ab?bc			abbc		(0,4)
E	ab?bc			abc		(0,3)
E	ab?c			abc		(0,3)
BE	^abc$			abc		(0,3)
BE	^abc			abcc		(0,3)
BE	abc$			aabc		(1,4)
BE	^			abc		(0,0)
BE	$			abc		(3,3)
BE	a.c			abc		(0,3)
BE	a.c			axc		(0,3)
BE	a.*c			axyzc		(0,5)
BE	a[bc]d			abd		(0,3)
BE	a[b-d]e			ace		(0,3)
BE	a[b-d]			aac		(1,3)
BE	a[-b]			a-		(0,2)
BE	a[b-]			a-		(0,2)
BE	a]			a]		(0,2)
BE	a[]]b			a]b		(0,3)
BE	a[^bc]d			aed		(0,3)
BE	a[^-b]c			adc		(0,3)
BE	a[^]b]c			adc		(0,3)
E	ab|cd			abc		(0,2)
E	ab|cd			abcd		(0,2)
E	a\(b			a(b		(0,3)
E	a\(*b			ab		(0,2)
E	a\(*b			a((b		(0,4)
E	((a))			abc		(0,1)(0,1)(0,1)
E	(a)b(c)			abc		(0,3)(0,1)(2,3)
E	a+b+c			aabbabc		(4,7)
E	a*			aaa		(0,3)
#E	(a*)*			-		(0,0)(0,0)
E	(a*)*			-		(0,0)(?,?)	RE2/Go
E	(a*)+			-		(0,0)(0,0)
#E	(a*|b)*			-		(0,0)(0,0)
E	(a*|b)*			-		(0,0)(?,?)	RE2/Go
E	(a+|b)*			ab		(0,2)(1,2)
E	(a+|b)+			ab		(0,2)(1,2)
E	(a+|b)?			ab		(0,1)(0,1)
BE	[^ab]*			cde		(0,3)
#E	(^)*			-		(0,0)(0,0)
E	(^)*			-		(0,0)(?,?)	RE2/Go
BE	a*			NULL		(0,0)
E	([abc])*d		abbbcd		(0,6)(4,5)
E	([abc])*bcd		abcd		(0,4)(0,1)
E	a|b|c|d|e		e		(0,1)
E	(a|b|c|d|e)f		ef		(0,2)(0,1)
#E	((a*|b))*		-		(0,0)(0,0)(0,0)
E	((a*|b))*		-		(0,0)(?,?)(?,?)	RE2/Go
BE	abcd*efg		abcdefg		(0,7)
BE	ab*			xabyabbbz	(1,3)
BE	ab*			xayabbbz	(1,2)
E	(ab|cd)e		abcde		(2,5)(2,4)
BE	[abhgefdc]ij		hij		(0,3)
E	(a|b)c*d		abcd		(1,4)(1,2)
E	(ab|ab*)bc		abc		(0,3)(0,1)
E	a([bc]*)c*		abc		(0,3)(1,3)
E	a([bc]*)(c*d)		abcd		(0,4)(1,3)(3,4)
E	a([bc]+)(c*d)		abcd		(0,4)(1,3)(3,4)
E	a([bc]*)(c+d)		abcd		(0,4)(1,2)(2,4)
E	a[bcd]*dcdcde		adcdcde		(0,7)
E	(ab|a)b*c		abc		(0,3)(0,2)
E	((a)(b)c)(d)		abcd		(0,4)(0,3)(0,1)(1,2)(3,4)
BE	[A-Za-z_][A-Za-z0-9_]*	alpha		(0,5)
E	^a(bc+|b[eh])g|.h$	abh		(1,3)
E	(bc+d$|ef*g.|h?i(j|k))	effgz		(0,5)(0,5)
E	(bc+d$|ef*g.|h?i(j|k))	ij		(0,2)(0,2)(1,2)
E	(bc+d$|ef*g.|h?i(j|k))	reffgz		(1,6)(1,6)
E	(((((((((a)))))))))	a		(0,1)(0,1)(0,1)(0,1)(0,1)(0,1)(0,1)(0,1)(0,1)(0,1)
BE	multiple words		multiple words yeah	(0,14)
E	(.*)c(.*)		abcde		(0,5)(0,2)(3,5)
BE	abcd			abcd		(0,4)
E	a(bc)d			abcd		(0,4)(1,3)
E	a[-]?c		ac		(0,3)
E	M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]	Muammar Qaddafi	(0,15)(?,?)(10,12)
E	M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]	Mo'ammar Gadhafi	(0,16)(?,?)(11,13)
E	M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]	Muammar Kaddafi	(0,15)(?,?)(10,12)
E	M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]	Muammar Qadhafi	(0,15)(?,?)(10,12)
E	M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]	Muammar Gadafi	(0,14)(?,?)(10,11)
E	M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]	Mu'ammar Qadafi	(0,15)(?,?)(11,12)
E	M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]	Moamar Gaddafi	(0,14)(?,?)(9,11)
E	M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]	Mu'ammar Qadhdhafi	(0,18)(?,?)(13,15)
E	M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]	Muammar Khaddafi	(0,16)(?,?)(11,13)
E	M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]	Muammar Ghaddafy	(0,16)(?,?)(11,13)
E	M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]	Muammar Ghadafi	(0,15)(?,?)(11,12)
E	M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]	Muammar Ghaddafi	(0,16)(?,?)(11,13)
E	M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]	Muamar Kaddafi	(0,14)(?,?)(9,11)
E	M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]	Muammar Quathafi	(0,16)(?,?)(11,13)
E	M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]	Muammar Gheddafi	(0,16)(?,?)(11,13)
E	M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]	Moammar Khadafy	(0,15)(?,?)(11,12)
E	M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]	Moammar Qudhafi	(0,15)(?,?)(10,12)
E	a+(b|c)*d+		aabcdd			(0,6)(3,4)
E	^.+$			vivi			(0,4)
E	^(.+)$			vivi			(0,4)(0,4)
E	^([^!.]+).att.com!(.+)$	gryphon.att.com!eby	(0,19)(0,7)(16,19)
E	^([^!]+!)?([^!]+)$	bas			(0,3)(?,?)(0,3)
E	^([^!]+!)?([^!]+)$	bar!bas			(0,7)(0,4)(4,7)
E	^([^!]+!)?([^!]+)$	foo!bas			(0,7)(0,4)(4,7)
E	^.+!([^!]+!)([^!]+)$	foo!bar!bas		(0,11)(4,8)(8,11)
E	((foo)|(bar))!bas	bar!bas			(0,7)(0,3)(?,?)(0,3)
E	((foo)|(bar))!bas	foo!bar!bas		(4,11)(4,7)(?,?)(4,7)
E	((foo)|(bar))!bas	foo!bas			(0,7)(0,3)(0,3)
E	((foo)|bar)!bas		bar!bas			(0,7)(0,3)
E	((foo)|bar)!bas		foo!bar!bas		(4,11)(4,7)
E	((foo)|bar)!bas		foo!bas			(0,7)(0,3)(0,3)
E	(foo|(bar))!bas		bar!bas			(0,7)(0,3)(0,3)
E	(foo|(bar))!bas		foo!bar!bas		(4,11)(4,7)(4,7)
E	(foo|(bar))!bas		foo!bas			(0,7)(0,3)
E	(foo|bar)!bas		bar!bas			(0,7)(0,3)
E	(foo|bar)!bas		foo!bar!bas		(4,11)(4,7)
E	(foo|bar)!bas		foo!bas			(0,7)(0,3)
E	^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$	foo!bar!bas	(0,11)(0,11)(?,?)(?,?)(4,8)(8,11)
E	^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$	bas		(0,3)(?,?)(0,3)
E	^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$	bar!bas		(0,7)(0,4)(4,7)
E	^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$	foo!bar!bas	(0,11)(?,?)(?,?)(4,8)(8,11)
E	^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$	foo!bas		(0,7)(0,4)(4,7)
E	^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$	bas		(0,3)(0,3)(?,?)(0,3)
E	^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$	bar!bas		(0,7)(0,7)(0,4)(4,7)
E	^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$	foo!bar!bas	(0,11)(0,11)(?,?)(?,?)(4,8)(8,11)
E	^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$	foo!bas		(0,7)(0,7)(0,4)(4,7)
E	.*(/XXX).*			/XXX			(0,4)(0,4)
E	.*(\\XXX).*			\XXX			(0,4)(0,4)
E	\\XXX				\XXX			(0,4)
E	.*(/000).*			/000			(0,4)(0,4)
E	.*(\\000).*			\000			(0,4)(0,4)
E	\\000				\000			(0,4)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    root/go1.4/src/regexp/testdata/nullsubexpr.dat                                                      0100644 0000000 0000000 00000004046 12600426227 020034  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        NOTE	null subexpression matches : 2002-06-06

E	(a*)*		a		(0,1)(0,1)
#E	SAME		x		(0,0)(0,0)
E	SAME		x		(0,0)(?,?)	RE2/Go
E	SAME		aaaaaa		(0,6)(0,6)
E	SAME		aaaaaax		(0,6)(0,6)
E	(a*)+		a		(0,1)(0,1)
E	SAME		x		(0,0)(0,0)
E	SAME		aaaaaa		(0,6)(0,6)
E	SAME		aaaaaax		(0,6)(0,6)
E	(a+)*		a		(0,1)(0,1)
E	SAME		x		(0,0)
E	SAME		aaaaaa		(0,6)(0,6)
E	SAME		aaaaaax		(0,6)(0,6)
E	(a+)+		a		(0,1)(0,1)
E	SAME		x		NOMATCH
E	SAME		aaaaaa		(0,6)(0,6)
E	SAME		aaaaaax		(0,6)(0,6)

E	([a]*)*		a		(0,1)(0,1)
#E	SAME		x		(0,0)(0,0)
E	SAME		x		(0,0)(?,?)	RE2/Go
E	SAME		aaaaaa		(0,6)(0,6)
E	SAME		aaaaaax		(0,6)(0,6)
E	([a]*)+		a		(0,1)(0,1)
E	SAME		x		(0,0)(0,0)
E	SAME		aaaaaa		(0,6)(0,6)
E	SAME		aaaaaax		(0,6)(0,6)
E	([^b]*)*	a		(0,1)(0,1)
#E	SAME		b		(0,0)(0,0)
E	SAME		b		(0,0)(?,?)	RE2/Go
E	SAME		aaaaaa		(0,6)(0,6)
E	SAME		aaaaaab		(0,6)(0,6)
E	([ab]*)*	a		(0,1)(0,1)
E	SAME		aaaaaa		(0,6)(0,6)
E	SAME		ababab		(0,6)(0,6)
E	SAME		bababa		(0,6)(0,6)
E	SAME		b		(0,1)(0,1)
E	SAME		bbbbbb		(0,6)(0,6)
E	SAME		aaaabcde	(0,5)(0,5)
E	([^a]*)*	b		(0,1)(0,1)
E	SAME		bbbbbb		(0,6)(0,6)
#E	SAME		aaaaaa		(0,0)(0,0)
E	SAME		aaaaaa		(0,0)(?,?)	RE2/Go
E	([^ab]*)*	ccccxx		(0,6)(0,6)
#E	SAME		ababab		(0,0)(0,0)
E	SAME		ababab		(0,0)(?,?)	RE2/Go

E	((z)+|a)*	zabcde		(0,2)(1,2)

#{E	a+?		aaaaaa		(0,1)	no *? +? mimimal match ops
#E	(a)		aaa		(0,1)(0,1)
#E	(a*?)		aaa		(0,0)(0,0)
#E	(a)*?		aaa		(0,0)
#E	(a*?)*?		aaa		(0,0)
#}

B	\(a*\)*\(x\)		x	(0,1)(0,0)(0,1)
B	\(a*\)*\(x\)		ax	(0,2)(0,1)(1,2)
B	\(a*\)*\(x\)		axa	(0,2)(0,1)(1,2)
B	\(a*\)*\(x\)\(\1\)	x	(0,1)(0,0)(0,1)(1,1)
B	\(a*\)*\(x\)\(\1\)	ax	(0,2)(1,1)(1,2)(2,2)
B	\(a*\)*\(x\)\(\1\)	axa	(0,3)(0,1)(1,2)(2,3)
B	\(a*\)*\(x\)\(\1\)\(x\)	axax	(0,4)(0,1)(1,2)(2,3)(3,4)
B	\(a*\)*\(x\)\(\1\)\(x\)	axxa	(0,3)(1,1)(1,2)(2,2)(2,3)

#E	(a*)*(x)		x	(0,1)(0,0)(0,1)
E	(a*)*(x)		x	(0,1)(?,?)(0,1)	RE2/Go
E	(a*)*(x)		ax	(0,2)(0,1)(1,2)
E	(a*)*(x)		axa	(0,2)(0,1)(1,2)

E	(a*)+(x)		x	(0,1)(0,0)(0,1)
E	(a*)+(x)		ax	(0,2)(0,1)(1,2)
E	(a*)+(x)		axa	(0,2)(0,1)(1,2)

E	(a*){2}(x)		x	(0,1)(0,0)(0,1)
E	(a*){2}(x)		ax	(0,2)(1,1)(1,2)
E	(a*){2}(x)		axa	(0,2)(1,1)(1,2)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          root/go1.4/src/regexp/testdata/re2-exhaustive.txt.bz2                                               0100644 0000000 0000000 00001401440 12600426227 021067  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        BZh91AY&SY; _ \{xx:`cP:
*Ge q eU[j
mUl3H&5MT*VuLNpLkVkZ$fK2V     2 8T}BT  >mh2cCV%Pk^%B;cv"yDT h  )RJ4h@  U"   #i%HCL&P)$=O#A@*jIJ   ?B# RFAB# FAB#%-.(P(D`B# P(DiPIKB vW{jaS
TeEGJ[wjv0WC
T/^}GJ[+WEy=z2k5!
!V|<]sFh\h9W4sFi>h<8&m'c18c5sGw9W4sFh\{k W4s	Ij@Fh\UUx>h}]^xW4p?XVQQXVEeD(Pj"!(-DhmFmEbcbj*6(6j6(,U6*4jEPl (6ch6(fXfTllUEbEDTEDklhlUE
b+(QBFmFhcF4jEA FE&&[CjhlBhkFmKbC4m*[FFcFlV6jSmZY[2YVMXmbjX5

(mFPAFjdU\.NKbC4Q*[FQ4E cbi)*LFie1[4jZ+Z(5cmZMXlj4Bj
[Vm666=R$iFt{J0JN;%oVEFYDN$qGVV%DK&XVj2*$b*$(m5-FAYm6U62L(PlaIoJ9wU6	\Jjj2TKmJ3
jl&-BM%--,ICdYBdsu9)[c%Dd
lLS5Ul
m){w<eDNYIoFEFYDN$lzP
MI@EDED*6-5AYi3dcKm[	i\Rbm-c+(H1-s9rDb*RUBUU+f$1f%2+4)-Z-b1[F5QhDjVCVPEh-QmjTF(V1libe"Z)V5iSSB	1V1j"icVXl,jaKMlkBF!lB4  cBF`bfH]\1,0^Wj)CH		4W.N'mPpW.M<!as
R2.t(S8vwmQJMjRa2W]W#]mrp-B5M,Ka1])[f>;uwfmsitpM&`eLeK2o/~8UY ""%H&$I	
N
[l8dCrW)N`U?*lRk66D"!&VeLom~6u-$rw#3Nud6l'Cio"0_~S^m6l----2z
RW\mP	TimmLVh.ZsV"&ls,"@+:M&RI$79dY&MVShSJa[0rjMkW#h?8lUm2,
IDYlM4rin[Imb*u@m'&Y,TvTbLP[Mg$-:,7#O"9i\M#<fffcl)mql'[\%f|#zt
m*c+&dIOn::Ife(X)d2f[I9ev.kK[1dfS,f3v2k4PPE(F4Q][vimjM34z.+dij%,Z2Mv24w.&[K;lXmLfkbQIHNM`0*-E&Qn@milLGj(FL[tR]gjvT(5PQ%+$tP$IZ$I T{;b{A,)uZf;W*k4v.kK+MsvV^[Q2inXwnaIdQLi.f7kMFjMl21M)bbIDXj-VF[kS1{Md[A6Xk3q%y=EMEDM)zd	Hi#:Z6j+VllI-mNqalW'xSQQ4]kSb2!!+s=Tvfiz7gGr2[f&iV4Y-
jCD4Ki-d6=czVdm	E,F5VjXk3jdPr0(7hq]SRe1dVA-HirmVF:NvN-sh-V'90L>xxG1YRyG<sA2ng)y`L9LLUiI3I!&HibCFM$&fTc
R*IHLiZK6l 	$#l6kUm2[D2#$dK)+VZ Rc|iAvV[&50 2bc-6!Y5ellM k+[mx =t\p*' X%}wZ*TSI2JtxS5w&{6NmmJ<b6)T1w9W:b.+>+VjLa<c|>sobK6LBm&cyO$f%79TZt89}w	&BM&I9strp"L7)XNK2snM,!;'xavBjilfs==`+qsG<gYRm"NvUR{-mSfMdV	K1*c5`c
DR%2D =vsd"wr$VA7cbry$ iy^xI^lkeZ;+dx$XN3+}r1 ^N\kx)hen3oy{b<EEesf4jFN]W.vIcS:(g$s)e>)kEV-:KYDDU	6DN-l2ksmsiWqzW:Ev6MLws5]ymm)lvr=fJXff;n5d{^#j1c5cJMEm<t)k+!<7vK)" 5VvnJMerm,d35umtbhfW4gk2iiX8W6M^5{mVm![K((XM"Suq]sfX&9n+WYNi\uU4RgZKYMRUYm%TYef3MmI] la(064Fi5b4R,&cQQ%[V-ELM)t)R]vw$w(7%Vme6nbWajVSF4%$U!+aK	Ie6TX`2M`446RMJdY,;	vZjJsj5%Zi#4VeL3(>e_YmmP0.X54l#+5mv 5j
cFmD$$ISJLbf;d"7BDCmBlwm[mS,YUbYV+X5j6Q&A)NQrL[mqNnW  j5
  5jTXh5r,mJSZNtKcfNrbN\'j:91DFNXZ8^GVi.4%X$F;7=67't]TMEMdkZ6)$FhSF,=PKRmH8t9kd;9rCbq.*qW|oJ^[1in[:.wKJ7+:FR%jD d%i+t+Lnni\ )4lS&V@d &Ubqh[NV1+9fi+ebbL}|g$9%Qc^;ujMmS2(RbZ##<<3ofqb[$lH5kZfDyObQn]uYw{!j\zM	r]O{Gz=WY:I3030303030303030  l YSY I4@I$mf6lI$	$M6lJP$$HD"""4diDX$H2XjkT]lLKSmZN+FBLM)RFD"Hk&BUQB[*~3'Ib"""""""""  DD#bDA""""""""""A1bDDA"1 D1bDDA"1 DD#/c1cuc1cu1c7]v1c1]c1cuc1cu1c7]v1c1Av1c1]c1cuc1cu1c7\Db""A1F"" v1c1]c1cuc1cu1c7]v1c1]c1cuc1cu1c7r1"""""""""""""""""""""%1c7]v1c1]c1cuc1cD[[[[skkyI(BIBJP$!$	%I(BIBJW1c1c1c1c1c1c
m
m)[HB [HB {{m; wormR`Mz}U1c1c1c1c1c1^^}ormR;6JS{&u)Jv {z~1c1c1c1c1c1/////|C
k
k
k
k
k
k
kzUo1c1c1c1c1c<p@;mp@;mp@;mp@;<{$$!$	%I(BIBJ _r//m!@$!$	%xvo7|1c||7|77o?8k{\^M${${
KbZ)wYU}QHbF{YEa,lo} @e$!Bt]cS"x'>TW a!W)-+GGGGGGGGD]tEGGGGGGGGD]tEsj3M7[)O}K[;[;<!O}P`3MkY_{}*DyAU[LOJG,}k\+#?e_tzETiKTj,lJ}NUUU<iOeX#qW?G| |>>j/?]T`_9"tE*@/3	a~IaU4q N7lt]m ?E'1~yI$u]<;aw~(
)4`"ZKkUM]n|~~uu$\{}E}{
6w;]cS7IJ6.D)ff5I~>#\MFL&x&Yly  !@ gn`;mn3706P<oN`^Sq ',zw-mjKrU-UQ=)JR(PJR)B
	JRsk[x\TfdI-_-myi!C8;'N\dd@@;[]@32+
UmVO],lKl-WUml,NNjt  @ Nwj[  p3zP9aBqMmT;sjrnX0!3cBn ^6  8z] mm  PMoZ&7cfvMmT;sjrnX0!3cBnP@g6aBg9mT9P7Ymcs1!	k'6nK5	xu^/ J-bju]cv f`[ZxRU[Wt-rYk[w r@0ko:&%#gUw;!E8od2q2,m;;=g({Mqvd m6\l)q;uff,BB$+Ib[s]@uW5e)JR(	 H H0LRS@EZj`eZ!djV2$"Zc
F$j2h5Y-+#(m&Mb4Z()!&k2#RMhR2b
jjeF)a6VU*2R3l&k%%,B	SiLU36fC4&"+3Zc3hl6tpErQlEI&9GXK;lrgle$i;#[!f[LL;9]j4h3uuu3,MkV&[XJur;dFM]fcwUf;6g9D'#.Dol 4 :L 4 =n

sJt:qsERX+FERhj1fk,-I[)hR[
0lZQF6KcjU2mba&SVvMVfD6U7vm P\X+V*b&mJcv6Qmtn'md[F5hAMRAL,lsiYu,h+cZ8$]qYaSm07]nr`e56fZIj&*\t<WOPb.5ifbk+FmRTfmQMwIdjW)[7&UI[+kh,,pldm4{!aDiL!4ILj7suUvcU9d2[mu58[<9mfH&IfKzrGihrfK	0z:4s#i''2[#do9"=mZ<	_	MPRXbE#$*1%@QJ0E-B #v>_Vew~]{~]zd;r<<>-bBIc>z6w1b1W]!(BIBJ!$	%I(BIpBk-P$UO?`IW"5`e!J%a(#R>$%JBAIx	s
IO$JJ**4H	4KaLa F&"bL2m63[mUS32 l25Y2[-VXKSJRllfRl(%eVXdmJ$fX"O>	%c1aXaSc43	MbLU`TId3ZbV4bI,Jd6jb4S	-ffY$a4D!6$f5j	13RL`Z,K)d55-)ZLSKFc[kT"Z,LeVUJFKfId-if6HXP%QHUU#-D`6mZVXf`#BMeBilmiFFj5f,[!!LIR&#4V0mQM-4-IT2PlFUbFRmlLmb
54cc%jXV+lVcALeIKRRDRa-X`XDbmQ*}}~{|"['/-dmJJY @$mm63U'?}z .P59z-8mR)JRB$TETETE HRUI]{pd<_Wx[;/:Nz>j=AWWUx{O[nMb)LpCevvUu$!$BJP$&MP+~`p^;?'ip wpd<_^@!oC}2EIz*w{l{a*=pGknc)JcJcmmBII(BIBP$!$!Bl$$!'`'m6w a$ !x_9Lyw<mq"*Oimi1JR[nwuP 8!$	%I(BIpB#eI+Nz;zvWnk/z|>/L/<=~Mmm  $	   @]IH	9$l@$	@$	 A H H L /A?p56pD#t                   -/4'(qSmKA)JRWz{@$	@$	 @
N2m=Vqo^[m6HRzyw@$	@$	"&8DkmFiT"(p5Vu)
RT[XEQ$	@$	` $	dMek%H	~  @Qb     GPJ_a
fllRPeXIdY2ZS6LT)]ebXVAm;h     '#	>DbB  MabBjmE); wH$
	4$Gjo$TOT*%=
Ih%Oz)b0$ $OFMI%TbzF$g;x(DqlI%-
I)hRIKBD(KBG
GhFZR$/FyGKGKq3ujRTovnwt;]cX9qU({W.&r.m!L6jwN9u]cnEEdXDY+)ZR]u'R^h\RpR6U+i8UZ<-5a$ #VUi%U#i8UZU+i8UZUK	I<9W4F*	I#i"     zzp {c5sO[:Ws   =y PP Q4 @F l@ IlTMEh$j6KQ*&hT*,SFQ,V2
	XSJYbTkIj,M$QQ&Q,QQ&%&N Ne\reS	Q,2TI)*+1cAKf!!Um-YJ%,M79N\u\1Cjl3RfPU[RYlRiVhkdaQTSbQhA6db6d,X,XcS"5E4hF-j1hEVhd-y`d  !F6i!#fYU$HV`)Rf8Y
f[p!SMqkaWUfzUIb xLlBf!3o{)Y<5,4aa{JIij^<}lZmMfo14eL2Iw&m5V6SKD$ch46 m\oD %$ %$$$$$/*9s \mYF>m-Zm6]%u0 %NmEs*T;[jI6H*$Fd4d33$Ljp-l[mmSVf[xMmm7m0L-ymwq!cTffm#h m!yNH6Q*aU|^fc49t2HgPESh8|*J6Mm|iS019R<d4Ru,lm^=e5'qyz6K5M[Clb=k(bJ$ 7ejl42Te\c(42KtA!;#{u,wZ"ddmZsm/. ZWYIc,d$P


mnQfP66Sj4[](m%I"8iNk#F5r6~ADc&K%@()I)P!jDMn#LF!2KV$R	E:wNqaTRqk[#n:u5FhHk3Z[QWNtGjMm5[95i2k[K+J-@nm[-Rvb]=[T<f]vTV%d"3Sn\jG{Uzl*#nGu\,j*V[tt >J]6SHKm%$lvgj)TUy*;T;WY4)JK)fZj-uXTkRki5d:m+]+A*1+=<Q[f$~aI$4"9%RQe2|d<I$18G'2e29LbXXf!9%%3eLLk86e,Ki1mIU&Ki1mIhsrnJ87C&eTf136%6SicH+6SUA^brGYxp.ky }M-JbL|pnT=}:T|[Z6m3l*K&)44LD2MmfI!%zzz-Xy8eJKs85+v|wvc}okYQ|P!Aj]Cq;pa6ELea>yN,;N33z	>!ismMGBm:d#n11)6 6.AklsBfP4
lIke-YcS@Zi|w.p6.dcV*#\*m]v|3Nu\w`u[UnVmpJ{V!}56t{xT{gTNe[i6{ksp6nesmy6	xYFYC*{[Qu6,VK^K*N)Nbs%g]]WtFX1&aJ;kIsz]	:QJ1[6u&ohOv)X{ET=4UMIdZe"@ PDQDQlbm
v6t5sc3EeX2nvqQvBQ]qk+iZ7]r6L
YsKZm;UIN{{S*4H$	mmmb*AYK%VIfwI'bC U+nW62V54)MJCZ%lm"Mm2UQKE0QaV6)$0ka1+4+,HL# vCiU9&5eMLEHf~ IPZa"#
KfeV5ks+l6%fhQN.fmb@42ZuCm%Q@(IE"2h+(Tm4hbljb5*iDDdKe&M	$HiT\.	-Uj`&DM3**T  MUt3iav;eq.3cb4]sTh9[e%[lP)98I{N8
:1wCskK.1mPfimh,+dS:;rx]FCmeagnwI;Si6kMYi4cA%/1"D8nX[[4nnj
]tH+1B]wqmB6meprkus;uqq&LDd[%f6w8UV[sut;V(-ZZDfPQ7m46n7&IJVZe0Z(g`h3<yv-H0cbi9a*ZlVU[303LLLL03030303eLYd1eIJJYI$ [-)@  bHe"$ B$&[-X 5355 Z
$$*XYaeliLl6$/*&TJR[B     [JBhL    kVmDDDDDDDDDDDF 1"""#bDDA"1bDDD1F DDA""""""""""A1bDDA"1 D1D`DDA"1 DD#?1c1v1c1]c1cuc1c1cuc1cu1c7]v1c1Av1c1]c1cuc1cu1c7\Db""""A1F""]c1cuc1cu1c7]v1c1]c1cuc1cu1c7]v1c1A""""""""""""]c1cuc1cu1c7]v1c1c1c1c1c1c1c!m!m!	m!	m!m!6	m!	m!	m[1c1c1c1c1c1c	m!	m!	m!	m!	]Us$$k[m.$!$	%I(BIBJP$!$c1c1c1c1c}(mB(mB(mB(mB(mB(mB(mB(g1cc1c1c/;\% P\% P\% P\% P{&E2)Loo7N?#_ttrVw>szN"\R_-~vvD9>t1m@5-`H?xmmp.|cb@hu]zzmx-!puXg
_K~>x?w SGqtED_}Q_dkig{LOzq6<~Mn1~OW2SO|xw<z-XEP'i:8q[mm]    sNl15m>mU_wUUU2e>?.%~{?~||r\Wr>|> ?9?]G2R-rVKyX3\t9xN~>81}5%1 ?ttg<m|_ozmm 2UQD;KKlUQDx^DD7{oyU=l[o*HUUU2[cJ=mQcc}l6~Dm>~ J,~>x?O;    Bpw{{x>);=qmqr'   {Vn1<x)JR)JR
(_}$I%j>HwwpZOO	 >-	t;cvR 3D    {W^;
Ho{T':*UU^,%my cn]m`m./ xGZy@7i=y=}O(uUB3cy Y`;8omvwq w:_<xue|!M7mPeo"oy[}!g@[lUv 2]mf!c m; V. uhB{o$ [uy}.py}.py|{`
gS[_lLrk prX`3Au >T[\  T- [ug/;,UY^ m'A@C@m(_I)6mNbTq"HI!
K lb$)$!I!
I!x#~~s&Wim9N"GP&mJR=zW@$	@$	@l*UA@~Fc$cS#UE0DeQj4ZU3"3Kj&VY*hK[26fm4IJ&-"3YmBXXC%SX6QKJmm66eJ)%A26ZEf529qgia"mBMl0S$1,S+d,[$$0ST*a;Uw.$D&mMil	)cidUiIIU7csHn531!'Tb*D.iSfjTt\39uG.*\mw^]8WNum!\rf]J;l.tG"a:,tRi(%,LEQQkVT	:ejT:lRj#3]FQ	)6Rj9avtZH5[fV;E6&
Vndp+)53V6;ghllm,4SiLft'5VVkwpxv5%6J/*Qtw;),TStmM"59Jdhm3.cf4wjJudR:6m'juYAlfM-ImpBei78w.K5fdcRl$rXUbu:l{7c1I]Y[r[EWg]rUSZWHQBZKSuJJJZ'Q*I_TR0R@JE,JjbVUXLU'}U3.wr{r}15FbMRS=v!Ri{n(BIBJ!$	%I(BIpBk-P$*s}TJ`(M`DP
2PR*QPjB0LJURP? AJkjL`
5RS4HXbm1$IlM%2I2dVkU)1`)|cKKeV5iU%6V>0JUQ4@dB&,b0Vb0,4$dJ|U+hIZTL[ei2m!db5HXP&f3TeRQ2&efYjPKVM,66["2kfZmk",Bd+!A285	1P>U#X6lZ26SZ`U#$4l2fibfhYZY"*bBRYM)3J!6*5ZfXZXUK*FUlm4KdZ4I$M$25fY&eLX@Z VlaMBkZ,EWG>||q3.:<r^	vmemZRe*	`HHUkq3~|9{utC	l)JS^^*	5 H Kmj~jW|mdjeyT8p"Q
'wmouR)Lwl[e$P#eI(BIBJ\d$!$8>Uj/^Ls{r}7?J7=TUj]JB1[w}n	%I(BJP$!!(BIBJ/9]VL*5fsdNmp"Qr
ImiJB7wm$mWBI$!"IBJ$!$	%FF.:x &  L   	X"$	@$	@  H H $	~=ghlpD#tx      h          t[qE:k0QN*[cm	
Rm"*H H *tTMtE85[l!Be	@$	` H[N/wkl!
RZ[j"" H0$	_dMfry?0~ @Qb   qFF 1Atj#ecmJ @4JDDJBAE  J! 	(@T=:
  R s7Immh   i|{{AP	^s}    V03on7IH%ORa4 L$5*j6@d=   $QCj0G&MRmM AMI%T@@3m..W...=EKCRZ8y\y\jk-nr>=Tm99-Khj^;dXf@9^-6@jHm_s<95sGs<95sG4jhJ>h>J><95sGs<95sG4jhJ>h>J>hsF^x5sGy^xUo5}_wJ>h>Jp Gb7
lV6UM-6[JmE[JmiMj
3PO\PQf:VPR%1a6.3cfjjL6LmRM))Um%66666^df,k%Q.2BHdBA\z7C2S7C{SbF["aFmEF6j61\5F/JyHT=7Bz%'
r^\-mF9zW/b)w\K^r<VQcUXV
[
VlbZk%VF5L(YlK6,,lQs8tJLfuDSc)ZHUmjPjmkRFMi0ddKKd13PflKcm fss:SmX"Xcj3iF
F66ii`ELK7&Y\
Zb	J4L-Uy[sV"fVtu"]mo1G)7^j.<9W4z)wy/^^mk4[&["[CbMeZZkJ
Q+6cXk
AZ]m9tU)V6tJK[cUb(ILbLf(Vf-.N]
Q\\mDV+Ql[41bk5Rkli[4iIK@)J5FElFF#Z[F5hbjXMEa[TSbXS5kYmYi-cIl*6)M	A4 VLZ4bUc&[k*iMm-Zb4J
55TlFcBjPB5&Y1jl4 1!SYMhl#b6)(B$B!-Z&K	a&dc5LDhV AA6dmBhAh!ZLI#my7q<,TI4hDF7 L-uI$pWbGr$	f&%uMhsI$1&36logWirq8H6-I#*AD$4M#l%2mI$+NLqtQLqt1Lm"nCNsnDn&8~Hk5u;$IU2I$hA$I)
+QMI$Db,pX(/JKdh$I&2Fm}mjUM""NB#I]1s0Yu)b'4MA5h7-5U[e3zUl6ILmPVK2[F4Ll"#hZ14HQP/kj5m]ZIJGrN9L&D[6!8cl	55TV$BPO[^
EV RK-"LD'J8q9&lRPZ&&MlH7&GI*V+4MMir96DBISoO'NM=ejmOo-M[([kRZ5)C>&IZUpjp77M2pg8DMM4LM3fDD&M6i	6&"z]Kw0T5*,j4TXhBb,)(PtIjKk6IhsrMEQE&h[:8u&U
lQMEF_3$AH d4U*!n` $q7&mrm[`lZ=9$q8=R- :YKmJj**cIa6&F@UxUA""immAX-RmlK+)lq1iilZ&qLS0MebH!j8lnMV"fi<a)9gxBcyBr604<ixrHBCD8m2nNly1F8MiI3I 90DL&CHf6DbhcDmcll$$6&"lDMMil	Lb2l6d2FK5,i4HPZ	jKV9rF$9&7U990505W-FG9&MIHPPV[S)ml k+[V z_]V|U(0 =t\p*wS$Ll45S;].un MyuhfU2.V\lKim[Kcjb-}[s#nl(6HDMF<F$hnL0q4s$s6qI"(XWLFMChq|fs7O91sa
gUVo,1hY"ETd6eb)[mHlZx    T[*$^{.pl&"wr;b&Sk[%m}}^ fR[)VkZwss`|;<cu#}wwxx#$LyC8LiC6b@BK`5b&TSZ
m,TbbQZ6th""$'F$B2hQK6lw+2fB2XMEcQV5E"Z"I$!*R#uV6jo#yluUUP  T55 ,@*b mX6 B 
X-IMM&D6BfC&mNn&A5Qlg4srf$n<gCh4Ng<68s12bLUMlhL#CCm4mmU[fq<ssltRlhv#yM7-n[9	fu]PZnW6uAii*Ilu%* -#IKi:*IYVHH"
J[jJMCSVi(Z[!|'UQ4B62xXL6D"1m,TdL#s],[%-spm9:bxw'6gb`foLeZ1cDUEZ(K%J4E#Q)Hkk	3Qh`"h#Xb*"eAV X65-mLM4 nhm4[brimWR^h>lc1Qc1bc1cc1cc1c(1c1F1c11c1Qc1bc1cc1cc1c1c(1c1F1c11Q1Qc1bc1cc1cc1c1c(1c1F1c11c111c1c1c1c1c1cJ(5H5H5H5H5EVc1c1c1c1c1c1UUa*1c1c1c1c1c1c@    *%Vc1c1c1c1c1c1UUa*1cJ16V7d!$	%I(BIB9JP$!$	%Ilq@ 	m,`j&zq	gHr"`j&qEYpVt;$U I;$U Nzq	gHqEYpVpLa"D.DLa"D*La"D.DLa"DH0m@d0m@B{k$!$	%I(^zwPw(BIBJlE$iI)-5)H2RR[MR2ZjAI)JRR)!!m4H#,"Hu$J)eV[UuJY d"&k	jm7eRM RY-J2"/"eed Jhl5q|_/|_"|_/E/x.m/I&$|${I/$ Qd<)"1o|aFH(i,{<k;7>s_\Zw^W5 _
6[B!Vi\uu7;[o =zXE|k|I|IV]+|>>|>| {o~^wAoYj9IBlQv.$|-wmeUsVU"Iwr(<"$7w;P`FX$r.yw;J}~_~[;st2&L	5{\KU~.    7.{s%F|U49r*e~d:qAJIR)DDDDA!B @;mE0%EUWy,P~P~ST^*9`ee'$|Dw6Qyppy-Oye^$lI.T{ v-hU-hz e{q!"" """" g"X,Jr{dQ,R%RY9I=P0",h.(t!\c1Bh(#A/IYZnCr	5MI.JR
(yxB>5UFrkl''g;Iq1"zI!]iuIi$KIHl$IB7gI{oKHBI!.#I{oKti,\!3!,bdy$=$;M%$}I-d3 1B,a=$Kq"liuUR!tKrHRj$uUvI6M+\!3 cR5y$=$Ix$}I-d3 1B,a=$Kq)Hm$0B81Bq"l>I-dI#vJ1B!RHm$r$ikI$g1c@$ik;ue7D!1Cc!,S!NzIm_N[[l%g)1Gv};mlqm9I6[L!8(CeO!Hm$n~}=^=%WbF]AQx*jFc	 c^)(y={nBHBAb)$!I!
IRHB!I!snSgUUc&eR!A) RJ[m)B@$	@mkkk[mm)ATVQDIF(@jjEjK?Goido"l3he?`~$aBaDD8""qwnUy+I(BIBJP$!$	%
6I(BIBJs <DQ0ml-a4$Rm)*Rt*R*^"+ZjM#	4H6La F&"FdI[DLjI&hiFFSmJ6jMDjehfH0E65(b#afhhLDm6LlBAi!miQUh"M53$#i6MbL&m&"&#F 63#	"dhM&bhH$d@h-jVF646h#m4d M	flnM&d$&6$mmLf0f<31adm3$BI&2d5jVZ26Bf2Fl`df3DY`M!1F$MDM0IC4M6i`rB6J4@h@fm[2eTY[mEQ{eU80MAUW-7$	@ @B@U>*N]eKqEWWr2)JB) i[#u H Hh"""""$""""""H"""""$""""""Z"""""$""""""H""""""H"""""$""""""H"""""%""""""H"""""$i"""""""""""""""""""""""$""""""""""""""""""""""""""""""""""HVu @N-	`K5UQ|UUUf~f=a!
xJ2)J vI/QTDDEQUDDATUQTDDEQUDDATAUV"#UDDATUS 3w(w^ o+
[[z@S>|[E/	Wm"'1N8N88MW{$	%I(BIBJP$(RH$IBPwwni :j{ij,	kN~>yUUW:o@^InQ!
xJ2)JRr@1I(BIBJP$(RH$	%I0mC?Z amo` "D $	D    H?m@$I I d&	@$	@  @$	@$	D HGr5*r:*           rlyW8qpT{<z$	@$	@  $|msE=	pN8uUu[J[m)m$	@$@ "@+nJUkT)6\.UrkJZ$	@$	D HGPVI|2x ("  NW>Q@vj-Q
*j2P[
m #[Fm(Tev :  <0p=`Wf;b_X2U   ;6 =O3   o`$IUH4  $4 iU5  zR 	  *jIEPP`_sUmMm5%\K=$@$PKj(%	!8I%%FN5$D!	mE[QAPRAQ\L]LKwtmks\W8Tt+i;pz-{j
p]&a`X"L"(VHwr'uUqF4sFh}wtWwzzWy^xyiK^ZRW>])wys$ $2I$AH^xK4jhwJ]uwy^uwy      zz< .<4j[.:q     {y ?mJcV6QQmQF5)Y,%$4fTUZj5"-(P)S-
efQYc+&VjLcYRXif3im}:NeNm\(tF6)8kETltJNhtJNEmLC+cU-YIfmE#5"ZC61l[BPQ1-)YnsrbJwqJmLW)V+5F)96)VRJmRd
+S$LS6YfY(fF[)-JmffDdKmmUE5"DYML&H*4mjPBjSb,MKR"QYDkDb1F(*ciSbQhA6db6Ic*TcccEYM26"),XjhAFk,XcEkE%
l4hF)m-mV+P
blm5j5A#V+Z16Ta#i&J@jhC!!12B`oBHIh0HKmlL`I&mFgu+VV#p0xL$rni<#LoP
6K m34!QZCc< h@4!&!	BgB`IySKH7ZxD$&}eo[fM#DF7~\uQ8$[jm_~T*&trc6<8h05Fh2$gLRf%	I	BRBBI	3$		fe3,sY],VjI*q',q.lId	,&jQ
)D*l}*v7yZZ>#Fh5VURITI2dS*-}&iK",BdI$[(6Oqjm,5^Ax1&e1FeF`^)3VUVm19&M8ecb*iHmm+g;ql"3Jt)E+L!R>*I9j6MVV[`LV!&8YmPSmSq1U`8Iqi	"Fd*Mjs!"HB$FmzSYee@f52V-]nm$ 
+b69KP3E6(V)JpgsqrQ;l[UVm
Q4fK%@(d$(dK)$WKj4L2CL4-ZH$R	D[uZF'l*I#CiI&Hq1$IhLuF)L#R aV,en#3LfYVLc2V'+l1^mz>jUD9'8i
#D6jA4FgI)c*vu-VVmAI(\1Y[cc!D7;ITYL8ol&4$H8"&CF6g$uUFi2F3"F8Ki1mIh&jmCiq3I9>g1#fK6IY
Fk&5RFm=l4xk+^|O_<"hpy>:8sfrS$$9fQ<zu}>UX:rU6fz+UJdi4"Hh6$m]-Js%u9#ZUq;9eCCU4jC{9f|IQ=<S'.c<	l841bG1<2GKp ^4:8!lZY"i&DRR`R|w.p6&mT*V{j<+Tvp*JF^b[l56kV:^[suHn#m$	3y<}&#978IR4DLLDrTJ2$0N)/t^m2-bV4hQ`IPi6
EBBIY5eJma
K-$&IpjRiqGsP5,mD$`#k*d679ehblYeQI(`Zh+(beQF*6k,HiCDDLLFH F%%I-"DJRIBukMV#q2&Dr7BUUP ,@TR 6 (E5  W"mr9.8cMDhf$6**)YIXII#<$3Orq49138u^L4D97!fb#8g3*V6XFch{h4T,h&lMbd4%C8~i$K1U59Ehxn`Rgs2Tj\t:pA$%LIS#\(W5sZ!`]w u.[%KRjMKREV i)()UI$#pnreVXFFy"743jR]L9nRX69Fea*J"XeeUkih!L4eoZIalz9T,3iY[\oC,}_[ccccccccccccccccccbNl[sbS1V6"-hYllj3+$3u98N&m1#5@Fb6;i]bd#DKm;M-UNjfP @Du %[V-bJr-~5UUw611kmoZJ1c1Qc1bc1cc1cc1c(1c1F1c11c1Qc1bc1cc16\B3337Tc1c1c1c(1c1F1c11c1Qc1bc1c1c1F1c11c1c1c1c1c1c1c1Q*XJ%V	UUac1c1c1c1c1c1*W6\d!	fC33333311c1c1c1c1c	UUa*XJ1c1c1c1c1c%UUm([G9QDB=Q{%h*([G9j"PprDmB=Q{%h-DJZ/@h!-*o^I(BIBKLxP|ykLsx--33--3yUx--33--33--33--3w$!$	%I(BIBJP$!$	%8U-([G9j"PprDmXB JP-DJZ-rDmT([G9j"Ppro]]ziJ))Ja*I$bJRIT,%$MY, 
""R$M4MUM4i*M[      Zd5`     1I$YJHI%l=V}/E+8/\\-X/~|?[}ovvy),Fy	 ;|~@A}|+viQhZmo!
9laI,}$$+ ~z} }3@?|>|> >~]_~oI7nh[%m |hu%>o2~Kq".yWD`msvsK}~^,!cO}TVEXK=UUUUlf I$lEIwvsm mwR   ]}J2z6A>O{}{N'4XI=$IHRwcIP <xDDDDDDDDA|[YM%+QVs\sK!8=J1<"yUUU[J/`S\}]uWl  6mI$I Vu)Wnnj4\V,[a1DDDDDDDDAY<*JbY<cI=*{=OS><x""<RmBUUUUUe<c\!N-BudTI$<{"RUUUUDD~UAd-;Ti[xm[mm)vs6m?-vl$n5UTQUWm7om&[-u/urBsy]KmR{7{-
QEUUd!pAi
=.urBsfm4fqS;!@{7W.QD*rm!v^vmeQUUYB*o&k#i-mi-meQUUYB*o&k#i-mi-meQUUYB*o&k#i-m{[jm3[moT.@IiS6m%,([]cMe%,[.8C6(VkvMTm%3n:$r%,r(AiN9hfy}^4MOyzi9oUC'BY@<xC)L6mmGYHY%u)D!I#if($)$!I!
IR]w~jm\5s|I4\n^{@$	@$	A~*~hU~lD&Ta2"21e*fRDKERU:aYX#ca0\`p2b<vgoeHI^*xTKQO"]HWbTJ1RTbV)IkY%ZJVeTeTaa~}{=MdJL4f"O?<_>]>8f&LCd<xJa1"w"c!;e]xP$!$	%I(BIBJ)$lPsws*'A)&)	e)	R0Q*#B8*`)b$j~RImmYI*f,
PWecM$$$RI&--(SY%I*0%+A"6D,b0KF1b0L*C))8dF1VbLfb"b Iii4m!dFbdmALPdYeULXJc1B3+2$1T#,F&i4lm4M	aVT*RaA/AGB3M66!aaYeCFiA#&R1RYLS
),2V12b)W$fLL4$I3B&1di,2XX(,eJ'U 6 jHmdV5e##,$:e]hv+LaTUUUeY!	$" #uVL}cS:^7tcJQUUmBI!	$$ H H?tDDDDDIDDDDDD$DDDDDIDDDDDD-YDDDDDD$DDDDDV""""""H"""""$""""""H""""""H"""""""""""""""""""""""""""""+Q-lw?$8'C}2"j9z>~<"~mw/O1(am]w"P[[DBj%")H2%")Ho^r = vJ\	8?mUDB!gm'>I{4'r&1Bks^i3K%I(BIBJP$!$BF%I(BIB~U;{TzjUd|TPjW l	jy~t{6'I<xJa00r&1BksN]v%I(BIBJP$!$BF%I(pq'}|{S]nq?  D H   H/HH.H H H H   H H HD HW;hr5-6UUUVlI$@         [chrSlv&DJE[*XBI!	$ H" #\(.$;@McJ*U-$H H   H\a6bhrg8"c"%jUVRBI! H H  H?dMgK'+~ @Qb     U{   P%AVaYd*2 @jkIHHMTV%%(j
5$ M5     %<@
@0[   <;OQBRP[<fupJL	O52`)RR&@P4@IIJ# Q4*jJ)F#M6T3jmDmREVjC
T
l*jC
TVjC
T0L6Hd5#Tl!R4d1JjFFAQ( 4j4c5 hhh%  	@Q  5FFCA( 4j45	@Q jh FP hX 5 hh    1V*,QEdMLjSTB
QdMFSeRTm*"*"IEXhTlQPmFmE*QPXEjEAcQ5FQThj hZjhbEFFfb()+l+(QB+e6+jlSEE64jcFj(`6Ml+mmXd[Pe,E6F6,QV6-h666*l4mF-XbZQV5+5`jP	f3VL5U*4mETmV6S(CU&j6!,FDZlF2Z6,QV65ElV(Z4E cFjJ%RM6d6#P+a"6mY6f0VTeb+U*lj4ZhVEl6 #V-lEDmm5!Ii4HQQQ#QlV`FVj3+f%VmKiQ[Bdm56c1Z-Q&mLLZebL-%bX`V
Yf&hI)3UmTCe&3QLV6FDmmHRmkY3D&eQRf3m)mZQjVF"[cVQ[k%dQ!BQeB6VVm %IbV5cc[lQKmM0KM*lE6iTdYb#elFbAjajlbfS4Ef5fC4U+5F`1F-F*-jDmXcV[F6U[F-V6UdA[
kcP(jLmmXELcmmXELLZ4bU&[cR-M1F*ff-kj6mm6mmZ)Z5Z,hYmTfVH"1j1S1[M"lXfm0Yc[L+be25()I+cj-XA,%h&hA6M@K	a4MPIfoMd[X55jT,<&B[6AlB 4nY-,1Vbc)CE$LSRM6-b)A`7&mLM1uE+6pZEal+fg
EC$H6 $66";>%}UopM$B";mm1YVu^UD1"D"H^!R6ne)LDQA~7z"&i22h4XM~Bk&uH&2 V
6hsi$yDIDI0_JQfVUsC!3&I$ng"""#EUchRncDFUQDQ"d"3D'J8M&H'P.c[KRl&F$ih m)ClRn<fF(QE4V(2ZbJnmJrm 64&qxm	%X20jRD!(E(F4Qjd1JF9JVZLsm
a8Gc XYHbbm4$iDD$&&HDDIEJU[ 	PQQbFFFF1LFJ)2bk BMDmCs1(mB,DFZZ4ZA5oR $[[!R $I1iU6yc,dTVK9L)hNnl2Mb`b#*qfHnR&(j"&F5Ej(JU(SHA`CscjV`Kj'*9efTIf@L/_u-j[I##I]+u@YiIMldI- 	DID4DI0#oZZ2ff'!6[j2U\F6ee2F&d-j73D3qQXfMA7gVZ70`K'*&69qzb1b^,,eda0d2G)3RYffXXJF8EY2aDc$n!!4rbQ
HdrJ*ZR ,Y$ *@MmXLTHhX)JV	rcn#"UTFU6&MDL@h%,4g9&;mR2&YFFM-6"gAeV2#mj,R#I`,P R"&"i5bLh!e2XKQEXb-V,T	F)I) V!T 9n S@FY[1Je2da(Q$X6Fmke0F@2LS,RfDbs(d&DY4RTfVbd,C%VMJhA"1Ab*T@IF`t#Z(blE)1B56QdX6mw@B#DDhf3F$SJHg	1	1K55.4*Zv56Fb*#hMIj6 j2 )e%%u[H0kM`R_    Ii6*T *b kP[RC` PVmLn#BAJ)FJ)f+QdX`DbM3hpq4LFFdn DF%JmB&$L+mu5r EEbm-[]-[[VsC"s4pq9R	88h"Ei55c3jfj	i2Q h*S$@ mI"&[LhA6K)2	V*UMFJmm8+"q"6Fl,2+LdN#3fRZidVkMhDMV66FR"4pm6Q 8mllllllllllllllllllllllllllllllllX2X-cTlQVK%MdFcDUdE16EF-lXb&2T&$5k,X
V"1EAV`6
V#61[ja
iJZcTb-I-|E'I!I$I&I$I$I$HdaI$I$$I$I$I$I$I$IC2I$I!HaI$n2II$I4I$I$I&I$I$I$I$I$I$$C$I$M$I$I$I$0$I4I!I$I&I$I$I$HdaI$IC2I$I!HaI$n2II$I4I$I$I&I$I$I$I$I$I$C$I$I$I$I$$dI$I$$dI$$dI$[mm
m
nL2II$I$I$I$I$I$I$I$I%m
n+mIC2I$IC2I$IC2I$IC2I$Jn+mVp[mm&$I$I$I$I$I$I$I$I$I$I$I$m
n$I!$HaJnI$I$I$I$36ffa33afl036ffR-wv1^gv1^TDmc	c	;d([G%h-DJ9j"PprDmB=Q@;Y;}|"PprDmB=Q{%h}rnrn nB=gv1^gv1^Q|fa33afl7{oo-im)J JRyj"P*RovUjea$RJhJ	)DFDiDP	IM-	l)(LaeRKDDDE)%4DDZD_]		$f)I%4JiFYQ~)faFbFihR 1`,!$L-L!)JdXY$RJR -h HL  I$HIM-6JI$Iii&`4i&XfMhI,TI%6Xe@ Z1t?>O_/_"_/444444'pde$?XO*Gre^I$q$Wk`_(j1~Z@cPW=5}ss}7>~7_sj3hRv? ~^w+60 oXM[m?|>| |>o3ay4,z	5R#Ji{M&^h$|k4ryJPc"2O<rLFIxwHc>|}n@c$@c8=<.]nWww_n\Gh8~`g=VZq /{_==w  oXD4}D_7K=b}LX~zD@'pq{RA/{m0imMQ.m1 ^=iivbhU>D~[%6sC(>g%Y0d ?~ .{w)d!*$>HJAB!E5UEK$Np=lII
_S
(/Yf14YfM"%Rz@kd%G2"mdfAd/Ea;5d[^BI$L  !@  k{m/wI:@
+sIcEUr@5Y6n2hdmif	q_v:W v'pt+ 1iBsb,i%ElDou.l9B=sVUQT!DrBR-#:lP
\c `\c|VI 1s|W [(UTUBJRmPWfe[UEPIKVlP^B=zsVUQT!DrBR-#:lP^UTUQ=dmme[P[ovMMpNc@')59iCnWi@R@2+}[
OF1zUp1kkoIKmB_8oc[Iakea
'5 MVqPk/7Ozp t`t	$8,?ix;BzK(0)lm&6$tBK$.cms|zT.30ff"T.affla33036fc-wqV?</w S(REx H H0++)cLF+E2+&VeUbcEa0hQ)VVFLab2b+ebFLU$D@2L,V22X0#i2$BChCFh13ibVfRL0.da &7q68ZrS)-XDB#s!2fMfs#8g6W9qW(NV22DdF!D&997IhC8l88FSs\pI+uk[S i pWxW0   +<+uu\o]q ]{1uH9Ii'wI<{y^sJ9I$qHB6ADAAih$!KBMXlT&jfb(j,MYhlKj+e,L	VK-j&UQ#cVEU$"6dgE`[&I2TmV+[L	DP%EJH2D1c("nUD8-icD5bYY,6FqX+e%FT+qN3IsSQFBRI8)D[R*Xpb8D+Pm4fQFM&<uUXLI&I$mwE66mIjULjX[bj6E8l:S:nmX-HFE5mDt[vV62A9Klfbxl4V$dcVUeyN6c xDiS&HM4PXDFMghzZ]J\$+<,T[M!p`vZg6Mm"F,I%im)6ksgCgB&1B Ml<s8g6pTdJq1ME2MMG"xSb^"RTxI^+@AZhQ	2&j(	,YdJUT`|~K%X{	K$W?wR}xt'<xJ`m%0S m[\u-a33a)36ffaZf)33;s_RG,@R%T$
!J*TBRVUP	>aG'KBByT#AKHzI$B*!O_lgMn_=|)UVDJIdE$	D$	D HE(~wu tiNe@1L""Q}{$	@$	@"URWl7Z[^F>h'N	n=$y;O)L"S]"Lp]wp-dzDNUJSj^UG{wwffna7~?}VSU-zPh@ k=>+'OZ$;f)L"S1f]w.u33afl0p36ffabS8ovU-x(0{y~.3uL%0LUmCN\0a33afl6ab1M[n  @L3
30ZHD.HjZ30ZUT)+Z H H DH?Kx:q`Yu9pfk[mVUU           #8gtv-	eeR	LRW
`f f`f FfS)n]mvv#r$S1L"RH2,mVVBI	@$	@  GV8&n[,#{YN(C),",l@$	@$@$dMef@2~ @Qb   q } *Z6J RBmB
*J5$kn 8 ;{   5%kTm  WgUIsP(e
)x
/vp$H5<OJQ`     %OzLFM1$JjhhhI*jP@ T?Th 3LJVKE$lF4H"6i46HV"iHjM0MI5!HjJYRm!I5&F"5!5XK""i$j4FI	@MFbS h%  4+Jm%0P F@1)4P J Q	CA       `  6%0F Hh0     Vv
-5QmAF[DDE[	$K$(K
PBLPY!BTPh*,MAkXIclUF)ek@H%M2X
*-j6S%jFV(K(FIMdmAFk	h&Z)XY%XV(#QC5+5h
m[
IF5ml#mfFm6#`[I*EMYV[3iHd[,,fJ[E6%fl26RVPF)DI"M6`1%[j)5!f*bHDI6SR(LQ1M&(Ijj1Ub11F)*IF-FdXb6ER"TZ6"),XbZSaF4hZ-l4hFEjQ+iShQCb6ckF4Fb4FA&$I+F3h,Y0[T[*YDBi JFRZ&QD7Ae&0HJ`fg)4)IIkHD[k&FE+Y!umm6+
SjI a+L24I*XaXeiWbkmK&DA},lKe#km5eq
6o}C}{RI( mF4ko&EkJldMiLld2F@C$ d3;KI$8qQJUlj>"ATHSd^U+YdjLFjS ha0L_*)@Ln77<DGmh hB4#60F0XH|	A+o A"B!#FF(*qL#48Mj6En[de3d&g<PZ[F(6+TP6MX9U0$\2Wa!r6iMl-Ir2&-!!i	3HDfhJ"BQThIL+AX-&jipmb)Yjv#DFlQlIR$X6"7U;mcU~STF2SEi!LI$(
MV:nY%	RBi"$EHI[Z$AI$
K6QJ8qM4$9GZEjj2J`I";V(msCIh&4n89cCn#KPIh%RF%^tMq
"+nm$$Hi2!#8};VWq5VkUef

fmt#DF4V*j*9`f02h1#u63S0Jm*=LF!"C8II4f@XQeY*Y3*rXeWy Dh    (**%+1%6PY	6#2#qBkKU%f5REA@-SjcWW2IX)@2G,J	#6<HI2!#mm"AXmdS!)X nY*e-]6
$%jT,[jbL$laBRrUJ3(fU	L	eaEC
\QWe$3,,S"dLa1WVxX@j@D	J"2I`j
&AhHI4PF%*K* $HMIfCw)[9*8!m6B jU45DlUCMnn(m"(P(m"QEEhmY4hlblieQIQE6jT4DDd Dh$M	&H"Ie]A&"Sm0`mWT P l * T 6 `` I&)]1"L$1	1f+5YYLr4IDhmZqqa9qdn!LUX1dM$@i+af8lmjktPh&hl&H4[mMB 4bLE5& ,j525+&
Y5iIR3S%V 2eTm)TJfhS\	ULafbYm%U+	VfSdLMHmjJTmm  k@]6U\T"Ur;i6bjr\esvw|U^Hm[QZ66666666,QblllllllllllllTX"&IV)X(P(jbK%beT&	*
j65lF+cV1FTRkb $LkF)5[-aYA3Y1Jl&}aAdwB!B!B!K30!	B0!BY!	ff30&fffeL+&fa3333333"30	L9s9c1bc1c9sw\93333,30!3333,fffffffYfa33BffffY!	r30fffffffffffeB0!333333	B333330!333333	B3332-UZjUpmUW\d&fa33333333333333333333333333333333333333333333j2wqU1c1cc1c;fff30&ffffmUW\UpmUW\d&fa3333333333333333333333333333j686l2\6 El2\6 El2\6 El2\6 I"&r"`"&r"{VPi\m}JP$!${njIBJyP*c6"&ELcPI(BIBJPIBJ{vIBJI% "&r"`"&r"`"&ELcbD.DLa$"&ELcbD.Eo*UJT   DFE1L	
`@JjYSI$AQiPQiPM(*&@RH4+f2SMf)M32AP)L$H I4Dl e ~  & %0H2	@lFV f`0XX      I$I I%4I1$I$M6I3  k5EiHJV      |myy~r'-9e~<5}Wvc>vd(Amd9<f|5=fI^UUUU[No@*(&{M m$K6mi^yW5>pu(j4|^xo[mj_i;l|JwJQX}oIRhmRiKold'9E>7DQ;~{InX|~v7 m)i@-^*!m"TQHh$o~{/  mD`y}y}| m|4AyF~|Mo5@	""""1D$t_Mv_zzy=cHtuC|iir/F-IwHYEVS/ppF'sjq  w#m4sM	i.yUDDDDA$H6 IIkbczm(*zhBVES\0O(O6-mmI8 j,I$]{R~~>} 	4A|*"1{OyNWbrZ]uZ0ivmmsWdmmhqKk$en5W$^]MI*^/f(RB{6wA]: 
B,WApAi	2 8Pm%iu3d3]yu3Mwiu3
n\J 8m w 
B,WApAi	2 8P	2 8PBQdCVMpImIm%UB*o6kL3osQpdY*z)K7iQpdm^6%J%lm4[`fYp(fRHUKmmm$aC6PtC;x}85*m9PtC65/J4ODvoLxY.=oORysU<P;==w66!bB$)$!I!
I"-F5s.dCDD d~$	@$	@$	ATP|))Xb0#M3!XTB4LHMI31#42DD	IIMBBbCM1HaCbD!&e02a	am&qfdcsI#"g4a&fS8pVs0brM6#m$LI!.\1b9Lc
2`8`0V
#1'UG.N9;Tr]p\F&nJ%W'\G'jE$"w
k]mZb)B)B)B)W%VE+eV"""sQw:.N7DrsQw:.wrt;mqeEiRIahddk*1fTiAAR\6r*N19Ce33-5Ph6lr"7$R6 inrqq/.rVg9;eFM1lWjiQ	lXm8MX\tSHZM#:ZjwvFzv5p4A)%ulH:+rVlktmwum.DeVPmX:VV%6
5)[6VF
6jXA)cIZ<x56H!FIsLSVS,2lP"\\b)c4)bICeE	Y62t!lVVL%lM2pH;H!W
^@UCjb(F$*X)aB	F	GA}_&X|oH$OyO8wi6Nlx$!(BIBJP	IBJw;q*T*jEUhMUJU	U,:HU*R+@QD?	TJ=Op=
%$=R*U)W%T
W|u>8Pkls:gv-EU+[ HD HD H}mD 5Nj-Zg.dCDD dU#iKm- H HSjDDDDDD"""""""""""""$5mr:?1B`	kWM&-S|?-g;AA/ {N1N189[Q;{s$!$	%I(BIBJPI 8I(BIBuuXBC|c}*,=(Z%>_;~<%lim=IS8c4^ww6<m=P 8!$	%I(BIB!#eI(BIBUrwn .mm>ESo,@~<2Gb`{b>_q8v'sGw/[}I(BIBP$!$B#e	p|.\:yI?>   @    H H D H@$	G#@$	@$	$	SmmjMjYpUUvFj.           WjZkl{!<1p"".QV[JZ$	@$	A$@_*RKdqxK^ycc1]Ue H" sUMIhP.=XqxD8Ul@$	@$	$	bL	  (1  
p  =bladcRJ,!6bV5f UTHHBTCfU!(@JEU  P`    = {Hl   =>y    >LxTh$R4JJT $P 
JhzMJ*D=@U/#&ffmM6#URFIdAF$j
Qj" k!REj@jHX6"l$lDIMfm$$63DI"Ma"eJl
b3Y)T6C2YMlTSmJfX`I"aRfIMUFlSjRUPJZZ"#mjU+5Hl$ShmShY)lC62Ic3R-I6jFZFEkFQEl([ZmDi23I"L$#IHi"A!Xm[SmC)$lj*1Vjlm+jFfRUMVjeRXa&Df$HYm,j2X#SQhm6-ZVZ$4F&Ihh#KEf3$BCfU)[2T1$31l(U5
lT3mIf&32+6&kSaj#YijVaL"Z+5fLI"MI"MIlHH#L(*([	"m-@feKe6HQVeYmTUJI"LI#+a3 Y&4lEm*keljV)LFIa6T0fE&YSSmF`-02)65jL[F-JF5"FF-Dkb&6"QZ#Z#[Dhi[dZddF4A4BDia&i$bD&DHKV64j+QQV+bBVe6Sl	6ld$i2MY0i	&PhFj+TmhQlXdSc21Y3*fi&HH-0IH&K3VBcm56hA65-m6"Mj#SB	fI&4L%2HDd[IdlmM&D+ R61&e3)6fAbM4kV6McmVmbYm!2f
fUS2XkjjZlm2Z1mlF2A6IbM&f2M6M+$C%
elFD4XK%hlJlJhA52QDi"4HD2LI&IHDbIf14~ AAB!hCB"&!0RFd3gB!fI!,fBl-Z&cK!cf0I!a$56$i6D6h3I$r$D$ZIhFLFLFK\kD66tI$B-FMAUi$#&xX6I+IMAiyRIo#b5%&`)Uo2!`z oE4cdFjJMI_$]gD![*kQ115Z4d),FjJMExboTgF4'Y[I[mmb6JK%%I2RcbF[%C!7ZV*$fmmM!VVI[Y-blb(ei%I%z]	5l$Tg""BmIV*JKIi$dJjDj4BDUIU&7!(C8 RI-q&gp1 #06<[V"LBJiii,T	mE"Ci++h-Z"d*%lT[%%e0i(t$\{4DDmB4dh%J%*I*R$ &$A$e
Vj@AY*PkJc2IS(,)fT	!ALIHD$44DlM%([$hfD$"
Q,6VC)%AI$RKUd2I,
JJQ$!pcLITiz!!GJ&KUII&$FB!fK6D@AVVVRHHpp$N@d| =[Ej*#q,EIIdKjmZ&I)lp C5b($%Ji]$4f2`.Z
,j,"-Ji+$I$	$i$@IHa$RDI#CuZMF)5TM[V!&DU44h,)MIlJBI%XF )$j
$(D%P%%UTcD-$IaaMX""DI"DHiKDDHqDwUTv Imp I-IR[&M[+4A	m-LDHAD6EUVI&MU     `I%RI$I$)*$B@b THI$IPU$RM
MI$7TK0!#\E`T(7AVi$ZjI,lmd2h(h$IhJIPh*DLH8wTJ*$b4D488C!s[KKIjD4!1(#IKYF2AY[,VdIlHD#IKY)ZU2L&m%*K[eZU6K4fD"0b2#02afFl6hdi[JVk[VhXh!&jgfb 8"9jllllTmFEXdHjm[S
m&QMlImZQAQcccQhclllXPTPkmFhfh-b(Qhjh5M4ji,mZXPk-)ABfXm1c1c(1c1F1c11Q1Qc1bc1c1c1F1c11c1Vc1bc1cc1c1c(c(1c1F1c11c1Vc1bc1cc1c1cj1c1Qc1bc1c1c1F1c11bc1c1c1c1*AAAAAXc1c1F1c1cXJ%V1c1c1c1c1c1bUTTTTRUac1c1c1c1c1c1*XJ%V1c1c1c1bUUac1c1c1c1*XMU?%I(BIBJP$!$	%I(BIBJ}W{KzmXKzmXK.Bz.zc/Wctu]tuWIBw:sPH^MRzl)Aj],uj],{6ujIzMIzM],I(BIBww$	%j],uk$vX7m[{U                                 P 2 (0`( 	(   H0`e  0@ $	A 	@` H  J H)` ?8% (X f & "    	@@@A@A@0@@  @$1  $	m5                 @ @ 	@$	@$	@@h     f  H, 	    *7|t~gyyyyyyyyyyyyyyyyyyy^^^^Wnunuo{M5rm/s_Iw/.	$~I&9I$Ec~&U]t-{q8$x{\q8{zU}8;=Q mB!~i]}	MK?f0kAD^nv~  TITI|m'Nm/Ax9y/^m/Q0'>}wwZK>}vEN5&9)& ~tO]]RQJiQ#"IrEs:2"X7s=\P9tsp9 JriDQ5xNXQ]qFs)    :}yNXEQ/c'F4Pi(%c4$8$I$I)JRI$!|$TaUWy,uA\9gk'M|eT^$r^9NTI$KhUKhrH=9y9~5D'"MG"DQ5!~  /{Uuke"T)A$I$JRD!BbDJXIc0H)K,$(1Cc''(g!B!	]Ea"BI%C8by$	BE#p#`zqw\})JW 	$?[e[l*i;rC|k$&q)"IvJMM2KOitIH&K!Gw6Fv] 2/uHfd$w\IrGW$bXbg4(BdKKl>}\UmzFtMV;%af!1bD	,a6I5XyZYU 29$h%I.	#nHZYU6iTUccAj	,I-oHRMV/%m}I5X11q&Jq#l6I$c[fI&031"PT0mzFi$vKl6I$cXbc$J*oH$U;&Ksq$mc81b@}#lMmsoI\Z^B1!1r	bD"Nm:kk\k'7+.01Ccm	*1+*umklT1F1%liD#[zF4+/moE56Enn~2Rc%R<!b(_}lJGbb$eobI!
IRHBB$Iw;7G@VPuYUTCoFQ!F2ik]-uws6H H"$D#mUSL*gocFK%gCv3POugx)1KV]%G{ks$!$	%I(BIBJPI#d$!$~U}.hs+
bhTRuTR~HT"vb*[S?s}^[o\\_]u]tn8m`$	$	"$	kVmGmVulQrX
 (RZZK]G5 H H HUkDDDDDD$DDDDDIDDDDDD-R"""""$""""""Z"""""$""""""H"""""$""""""H""""""H"""""%DDDDDD$DDDDDKT""""""dDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDEDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD+QmLNwVK0]~u_`D2KQx1O)F1)vz|>IBJP$!$	%I(PIBJP/0vyyaeSE_JV 	ZyTQri</f-EU	Wae xJB)1;dV;g	,2I`KX0d$$`%d{X()$RIB{{{Y@]}U@y]~yq>)r~J[uVe(2E=S zJ_xvqc$I( %PA$d$$X,ayKX()$_5kZ   @     H HH"s.\Ha$0$3Zmkm, mmdZmk`k[ml@$I 6Bd0{j^;_wwWw8wp98           n6hw9=y?XY1
!%snk[ml$	@$@"DH6^Z5nFj{L=b)H$mm339s; @$I $H 6CbHd>o^]mt[]QZ{s=&z RcHAi	(vfwwwgsZmk`k[ml@$I 6Bd0dMe*gw~ @Qb qLw@ @U%*cbKE	h@EVm`CYF[,TUnF  4  
HH{  y&:rICqR>4@}Owwp  xGDI)E44#LjzyH)=	b0F	O%*jH  i IH5= iRJQL4 
&  *wFyx71-<O4yq]v5s;\3:]bbcn]L&*LTFiiRF&E$lF4H"6i6FF iTLHZ_M_Mh4msc6\nt4msc6\N qF i26B
L+fD[Ztmsc6\N =,2$!&"dfDDDIDDI$6hkHIM$HDI$h6M$HD&6#c|F2LSP*,YX2Z
-4j-ksmhF,XQ`5EbE6WMhd6TiI!#i"N[DmF5lRD[WLkXIchSjR]MIkQb)-6J9M5((mIMA4&m CgMc(PYMmE-[h#jjfVefQ-SS2Fm-5Fhl E &hI)*$!bXUn[v[6IFjm)-rlRvsj6JmEfT;$.e)PS6uJ2[2JW4m+d'j'2DfI"@SSbRW5Rug&6I
(OrsfW9Y2fdU6f)sl;[mPI1KaE*vNh+jBYR+e+ef6V1x."k5s;\"Tr	cf6IM62)ERM H$	5JV1-*6mEbeFmQ"#lKJ$M1&5gcsIk0SZQ"2@2LVZehUS*$YaiD6d-[V0eLUXR-VfxWC)sW2
-Dxjj1QXb1F4mjZb1FlFlIhhRh&b	$i	4HID&D6Ii&ViMV,XV+XblD#H4&&m++FM6Z4RTIh&IdI65CkjF5EFVeVb6mQfYQl#he/"0U-6NFLFLFMc8A[f8CoSj+$m&m xLNV'58b0\1L5E	m(rPFmP>eVI,bJ]%,U%T6qmI-8p7rKD^ESt-"mj#Q&3)JjmQY-B![YU"*$#Rj,)mmmLRZ|DelF+)KezXb,XC[Um$p#F>8ppLm-fzSvmsm5QbJq*Sbi$ 1tf><aPhI#WSV-]m5 bJ-5yU PiJy$` HIZtQh:E2vliK
FomUn( [n@!UItzmuiihclL5hjY^nARI$TDjI+tD")J{fZKW#Dms8j4R(KIl[bdr`Wvbu[mJKIM(bR[dR)Iihp\1#7+ED#EHLjYd1BcR)`IhcK-P"YjIT"H)$
I U[l*I,j+Vncn-M51[MGeV0TdlZ+Rn5(4A]]Rt84GE$%v"k7XEeeem4avI%uz6b^R#<%,cT e+m&7ZP:MU8b.k\kh4PJ$efmU-G;t.tFQI#d2FFgN'4M84DFMM2%enhJ-lZ j" wc;yWLTmsW46
SoJ3=jY.lm&Wi-m[kDyn=^Y%fjq9$xqoe+lU.uFFXaeDb6IfMcTcYY7rK\"):b+g2DQ[;w]bRY-3 Gb:[(N!Kd^x&AJFxmaKLLJ
$XMR)AIIMElRXcMKvJ L"	]jJ`*U)"h.9&N-b"R+.k[I)$jZNII1"(,dBhHHHD"	UTfUId1j-Qh6XsK%KJ2D&Dg6 )(;ji%jRif&rn:9PWAD&D%+h&aQ!BIKjVRicu T -- ETJI4$I$R-%K*[m)Dw#8,]U]:W1)i	dU&B!I\{zvv/ .im$J)Y[	 MFBch.m#(khS+1$7--MB-Lfumm-rml4ktP-Dvask4Uj6mKX3GD65Qbd,ldZ-`e&MFS5 4I&I4i6FHHRY"fVHhF
@fL$fb2cF!eVeTP9	 x;~~;;Xojj           [[6T 	$J I$0P $If* I&`d0T*  $H  m jPM2Obe`ZQ4c(a1L)%"fb2mRc5^O/V*jV[X-HlS+)E6VU(c(*6(*-lb%%mXh-TU&1c11c1Qc1bc1cc1c1c1c(1c1Z1c11c1Qc1bc1c#DF"" 0DDb""#DF"""1``DDD#b""c1cc1c1c1c(1c1Z1c1Dc1c1c1c1c1c1cJ%Vc1c1c1c1c1c1UUa*""""#`""""0F"""""c1cc1c7q1c1v1c1cwc1c"""""""""""""""""""""""""""""""]c1cu1c1]c1cu1c1]c1cc1c1H5H5H5H5H4c1c1	G {O w=x1*0z QQ{y<b
 O{b
b
G*0zTETE {wmco1c1c1c1c1c1c1c1c1c}]%.jTMl ;Q5R$vJD///c1c1c1c1c1c1c1c1Y)k%"@wmdH ;QR H H H[kk_;$p]#vH$$p]#G8$	vH8.wd$p]#@.wd$	vH$$p] D_w |1*7pv1*7ptwmcwmc u"**-7H$	mj%UUUU]Ixrmp4| o< [> >`V5S}zuxZA6|{CGN::tuUP@  %   A@@ @*@YP $06[   4 (X   6`)  6 % P\j@ [SF-E@          B` """(m DBPm       I
@	 @ $ h MP    A
m5`     mksrNNS*$>rrfkGw\z&"\!IyCvN2z9'r|:)^[.[[]MvS3z9>3gt*[n}fc3-nLr?}UUUU];ccb^W/Qz^	L["M	-D4	c4"y`OHHh4F%>+y];}0Ss"e_D-\w]TQE?`fbRzf
SL(~&o)N30xGu3%sA   EVFy@M
@&4m},RE@.{{N}eUSLLgCYE6'{kb}z=G@zk$ Oq/x`Ao]icYe[UUw[k;l    dUy,[Q$}mzmo0UUU_=-,8=&k<m{#cjLwf0< JbwznUUfO6wm=yUUUUUUUUUUUK2l!B	d]33;3#nN0[[spuC;:$d9l.K%_UUd^wt:{fg2!fOmyw 7|     @    !swe^7urzll[mlm5&UU~o|y~Cf1B!@I@7m!2dX%mm}}/ |>UV3$I$I"iJiJRp8z8plm1b; Bwpww3Ue   wuszf6K-U}}}oY{w{;wt!ixo6Gtm:uQ}Pb
6zvwmJq)l$c6wUju}{f3#6lFolN;}Pb
KG% -Uj!	}7o&u9m}Pb
SmJq)l Ye;:n}Pb
6zvw}m#6vd	$M:-MmJq)l$c7zwpt(30f?_	y#2Kfn,;tuEQT c@-B1fW0[ZF<Sug'
qS&I%2;m}RyuomJq)l$c6ly3ohKy0jy!$y%B?AG?'~^+%mv; fx11hf21QVg""a%fy"**"""**300_>~w2AA%66RxW8'%3M!mETETETET H Y~I"JY)FRc2bKZ*Vcaf5*Q7`4 8iDM-ilMLXiM"e#+m-&I,ZZ*Z2&mKhYeVV1fTj(khPEmF9)
Pml6i8l:jISk:i27UIu\ujq-m*\wg.VQaE8RKI$W+
S
SA JiQLz`Kop$c5k>0i	_%zW]J%W}J,I7py9^
Rb4c <*m)!	fd-MFU6FWYAQDUDUb " " #AQQSlTeSlTTDAw>'UBU$TQRD!BZUCU](DaIDF*$+H2 )>J|
!*	hDdLa&T1eRYE66kMmD,	SF1*L4--$Tf&#Fc%Fk6D6P1DTTT-i6HS0LFfj(X6m6H|%"
Ovo[/`icHlVwwe4g%Vfq7!f*"""""@$@"@J+`}wl>4b?7+#F6	@Pwd9( 3f2$	@$	@$	@R}(
fgU>][zp9J%Wg%U]$	@$	@%T?PPccOyt{]z}cBmRxWR9,L4i<$	@$	@$	@[j"""""$""""""H"""""$""""""H""""""H"""""%jDDDDDD$DDDDDIDDDDDD"""""#DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD$$||*$4};`4'JKUlnCKzYKmu3M4cjMChvHG;t	@G8.$\!#H8.$~UU*0``'~??I{A-R9d6$lc 2[M7n^30h0m4!FiI5F~|8.wdvwd$p] Hs$	vH+5>0mm-z4f`o3D4!F<{/yQDAEDRJ"J! H"DH[m[o_>~?W :anV$Q)V8XZ3n"""#DDBR!""#B@^5~>|EF3,nwUMt o*QJu*RE*h]uZlniiIar[i[vBh4@Jv]u	wHBig%kzv+(M)6  0ov+M+mwt!koj)hi^DDDFDCj{r[$caa	m(+$k;:P@; n          ( P4Q Pm`DI5J+mRMDH&0``SUXRJJUmh)R6 lFbX5DUUkZ            0D Gc<`Om}
aOZ c
R
PPP^> #Mm[L,<	I
($_Y;_`6n lfS!J 2<5JQTT44@$JI*	SRJS =G^{W+:+Vuy35^FgtkwF{gtk{:c\3={wFgtk{:FgtkwFg"Uqg\vZvjvvq\35uYkTTmkmWaaz5s;\g\uLL;\35i1S1S1]k\9k9Wf6LT10ZLT10Zth2Fi/9^4msc9^4msc9^4msc6Ms6\lsF69k=nth4msc6WI8W9\lp+xxlsF69kh[]$6\lN yku$AtrK[]$rI]djgN ykh[]$EYth4msc6WI8 l-tsENhiid          V*QUF&U,XZ,XYj)dMd1,Z,XZ-Q,cPbeF"%Z$Z"EQcHFbeF-hTXhV4TXhEQQ`1Q`1Q`)-E6mZ,XJT&IVVeefVh-6   0
IZ,F"#2JmM-fc, ccF5cQj*61JFQTm4 mE-QF1M[56V2(EEF-"-b[EEE%6kHHKif5lZ4kFhmf A %E%),Sa-lQm3C6e6b
eje6bZ#*1cEE+6PjDda6jME%,dY2[RhRR[dDj!j5!JMSvQFQj]gtka\Alg;nmwv&LK1VQhLJimZdRSJD&6Mmd&2	4M Y*h0V-*"-k&Tl[25Em*66
M-$mfE%45Y5YKJ$M1#KIJ$kZHX,mXmEkcF$	J$YlHHH3K6LDYF24Ze1cLZfQ6b6FL,2Ik(-el2]:e]sZDtkwFD;)&*f v5Ulcc1,mhd&(eKk2BYIfRY+U&A&Ik%&$%l``lEU*6-clFPbeFZ62kJ$Y$l$D@5Z6X6FIcjSh-1%YKiSbD ile"dbJ6hkF#liImQmdIL#HiBRmmc[Q.1Z(4IFQ6[kckc"Dmci4fDmU
bceVem3RVLU	SfZLUhZX`*m+YaT0eLUE(mLa1blfH,Q)XmhL	m13CAJ7B5FBjQF3=i%,Ro y"bZmMbCB#zV1DX[QhS!oXcZSVlb,Vb-mPP>vSimA,+j	a[PKJ12LI4Z-IML=(!/PvQmmF53mElV+jmB<UXq6+d-56b-b|6&d-Zm"!lU	2IM68CKzU+61mEb-yqylK+-3nZMZH@+yXQY-&m&m&m]KbC%V)[m&Tb[5&I2Ec9C0+jfI$)%-ZTbFRslq'&3
Q*)$[L65+YMkcj1F-kj9F8C<CH[l(mB#5R'VCv1Vm	1ZLF`3[lXj
m
1#b<vVZ:+eX&L$hZQEEXK,VKMVKSSiX6&0YF-15M3fEm,N<"E"[	$$I-	"[	$$I-l0`+1hL0$dJYXBL0,ri2Y#i2X6I6KbMPfl""4DRL5v]Z[I2I2I$Ui6n!kt9mk1'D&l[YBj#f5w;j(-,,Xm4YKQ]A%NEmEclmlbXV4TXjXjfFjMm;M]&4eVJHu-$W
AlT4&fLXh	E2	%"C
k^(ysUa6I6Fi5K$iaDmdmrB4Xe5mh+r3t+M08t@,9dm]iwZEgXffjt+5&V7M7"f
5LK%ba
CLX%1M+62QY1&h(F5[EEQjHY0Xv5FQUZVs	U-KQKU!lK,wZJ6v,FeDDEK#DEq-jFjV#fqcnT!B a0/7*1[5nE1(V^0]p)b&UU1+m[eaMVZQ]kn-$JkiTT"F
Wnj9mllQM6nMM&Ue
X-KX[R$7JTFFmj1k%RJgLUl5l+m-0SLn!-V
[rggvN2kKkr8-sv3fQf"2mM$YB$hrn9'7"e,YfEC:j[r9')m8ri&$2+38+1U&IdhhA*LS)3fl$*KR@IJX4Z51,Dm$$16"2&#m!lXaM@%)%93Jm*f(m1Y"ZR[Jb(Z5PQjZP-( 5kD,	l6`F&$S5c)jZQXkbj`0cj`kZ5U&LVd+jh&M1b&MmeHThAtwuW  638mc;FK{c<Jf  lgnqwqp]czwaDn4h$jj4$bJ`I,zkICmi5mj(QXmmQ/:={.tgwC&DH5l:2m*[zXVU0U3Ml&
j#PTDQ:d'#VIO{ov-d+Ftt	&*mk N{qnvudwL-e4Y\==[dPsDi"P5ig{zefmzN<p1ZhYm-5Jm`@` L%*b(,@M
&K
&XjLL&bS4M`VhTQjF#mEFDjf)jqME1jgM(;Bi-j;Rh.MXljR8JD5
l)2QFvEg
:T#lI5c)b&M$XI1$	"R(#A1F]j*qemFRSIkm1FQZb56+m
kRb;*jFIrEK4DBL lHK7h0K	 VQJ`]S56ef%5EY"FDYMmUVA(67j5luHD&$[ P1+-TrF&),b\825drL4H)s`-llf##vb0,[M*wsmSSUWm`8L9A	#pjRL+UBdv&hFX[Vje3iQb"& #DJvn\&M4l}Tm1E5wEwwTc` EA`eRTcy]*n:w9
M$Y1Ri5+)V)4HP*3&L2d%$A-IXM,lVs0!0@Xi-IeI%4HE)YJ#j2!J[ejjFuX;!:k4YtUvmJ5i7Z\[NGl0xHD{ldI691b1wtDcEybi,u]2X2dL\h,hS(i[nR
P]\7usc( R)FD3R3VF"WS3grRj6Rc4Us(vltW,-3[\i[i9fp9nV&ZtY1Lfm[1,mQm5f6                                  Y`JT aR faeP 05  3R*  faj  faj   jE@ 05  30 af afa   afI&aI$a$fIfI&`U)RI$DI$?q%$RI$U@"$JVqi-"$33$ I!"lHm#YvB6FH#$l$CMI4hFeie#U4-B	dD)B af&iUY0k6![#[* kmDDA`DDDDD0FDDDDA`DDA""1b"""#DF"""1`DD"#FDDD#b"" #0FDDDDA`DDA""1b"""#DF"""1`DD"#FDDD#b"" #0FDD"#FDDA""1`DDA0F"""1`""1/1c1nc1c1c1nc1ct""""0F""""#`""""2c1c1c1nc1c1c11c1nc1c1c11c1nc1c#c1c1c1nc1c1c1nc1c`""""0F""""#`1c1c1cc1c1c1nc1cc1c1c1nc1cc1cDb DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD1c1c1c1c1c1c1c1""""#`"""""""""!1c1v1c1cwc1cc1c7\v1c1cuc1c7]v1c1cud1c]uq	%FPlBNB#eI(BIBJP|iBVIows"!J-%^V%d
P
uHBKAhwI@(wI]VR% !( !	@(!Mc1c1c1c1c1c1c1c1<5(%ff\iBVIo/=r*7t[s"!J-EZK{hJ-V%d"wIY%_}wzU1c1c1c1c1c1c1c1c1/B[HBK{iBVIows"!J-zU!	Y%2\s.1c1c1c1c1c1c1c1cV%dw=r*^zUn+$EZB[\%dw=r*7t[s"!J-EZK{hK[~1c1c1c1c1c1c1c1c.e2\;iBVIows"!J-zU!	Y%\!+$Voc1c1c1c1c1c6$!$@PfhJ-zUn+$IfEZK{oo1c1c1c1c1c1ls.e2@)B^WU!	Y%\!+$V%dw=r*Il'e22=_N.d?>ow%s>IcI%$ow$}jI,$K% I~@$w& 0Vyw;srw6|nUnn\Z~nn9w}+~~>_O~S\	2,Oy? b1hKw_}Uh )@O!B.K,dDzM	(1?/L7+^*8~JLJPm<WRWl2$e%'ww*dns<H$qkkZ$%ocp6N3:?EmkD^?-GzxE;u#'g{g[052LL `?mpaX $|xh"< ;ttP;wv X go?y6D	<m'tP9rpe go<67UR#;KDh0|&O	0x2(<=MJ8(|my%   /_{s@(
Y,d<B {'9r"|l72~}UUUUUUUUUUUUUUU_NUUUUUUUUUUUUUUUUz[$00T6$%`gt2OG&a\$rt2K.7al=vw=G{?]7ar_9vfY=-o) @) D@#?s\` #=3=dMs\7E @1wEtM;srwo&TW '3u_D
/0SufzB2/w c/ySup<&uJp?	1?	jJ8nIlUddfI<m,^O	i    ~/{}y||)2X*L"P       PI[!IdSE&&
yeB'2nqF=1w+Z,LiDy	[mUUUUUUUUUUUUWa%Rmp36IVfl}m[nttP;wv@;m{nv'tP9rU@f:Ie(hVR[!{}[p	+n[jKw[mn&
(fnm*o `36wjBmWw[wvmRI|wr'7OwjTU+@;(
@^o[-oNljZ = "J,XEc bF00c4r+m!|, 8BBI Wwo {8_O}U^;vu|v;D.Imm[w v&m}-\EQj6
I  9dwXIhOT{ffiyU [m$um$hb  ;{dm:^dY.@W's*">Nxzf\9GymIP	&W}}T$mI=[p	+nZ>  3zl.	-=mIuUU@/\  olmM> MIVrQEM	57`*jO $KEmj| o[mEa%> s7_y33#b  mH$Vf$]Z+n{S3*
}wLw\e  s7"nNnn8 w"nNn8 w"nNn$M]N4lfI{fms2.{39 |*3>RI`]L5.  gNfefkZ wiYflonfJ[6+7\$5USKR  I6k6w=M3vmjdmI2 mpUM-K  j$mIZ&mHI6m*Ls>f|Ro/~i,}`kkD6tm;6vH<^@k3&cWf^,I[#1R @P!@(M003$ a
@% 
(fP!@(BP	p!wBJ( L@a>(yAz!)M00TuE_#kI@9Uw7!1vlz6@$I lI $H%$X	/_Hk#MbidXf&Zi$lV"FK&QJ2ek!,ff*ZJVk? ,  :'`f  kI :44qJbDSkI&Y3ljf+QX--6f$SdmISl5[&BVfZ[jVj11S@RIP*aLZFF44JjfLa(ZC$mm31Vb+j3[2$F5kIcEeM[6d*6C"XV%6lVSRLlL2MCf+ThJ[bXAYa6Q&%i1mEsQSHKtI
f,6Q6b6[2"&F*NmkTYkZ66Jl(*Ujefl3!3JNCYB4EK+jI%RYXcnja5
X"iiE%Y($[mV-iv&Vi%)uAk`N[lF+Fi2LI#PNwV$M\:Wkr(b*iJ"Q#Sl2PVlXvR]awN%-t*H()"$8s37L0rUP"@D,+!J+40	J2QLSGOm3V[wT+mx_v,lo~4[^mI2[rTUU@:]Go=#eI(B6PlB$!(B6\llB#e\UER#!"XQR,HECQ!%RELPT~#o"M&M di6im$d#$i6IY$DHLH625cJ}B_PXB1ah0I12UaY(c	aFX4!BUXEB:dhVSZCZiiM
4+FbmPXaXd2XbVfeMXa-0fHH$e2ad3Ef5YU0ReVC`d01i42lQJZ+2mdLbA!#h[ihR1CVfj)C)5&UjMmk[6()ZlUEMR56`PP!lU,i-j!KR_~I?I ^Fe:e{*kQrkY
I=sA  l6@   `-,eI^5?36=@;>k2L&Z |oZfmLWm=e<B<!KmI@9Unj %7twus:K{% !.P
@(J@(KP
Bt(wI@(wK&@(wJ@P
@P
@P
@_XPUO=,#yw&m	Iofd2g}}w[o[GFZ-&Y)Y,U n^fj %Pt{U,P
@(!K  n( n.@)B]% , (wK@(  P7tP7tIlRy{${8)a>w_|f2xJaF1zrz	 @ @$I $Il	,KWP^6^n$~#zIy yn[^kAY4wKp.j %7t:Y{P
HB n.@( @(J@(KP
Bt(wI@(wK&@(wJ@P
@
@ $ %[-$_ouyj\}=<$~#x^!zVy^>|W{=l,fL$lw[p,^U@UT wq@( $
@\ @7BP7tP7t !&P
P
LP
{km!@ & H    H	 @$Il @I`$ K 	,HH`6s  $ HK`I  p`I lmmhm	 [m %%le$p\^^prKmre<  m$m#`               ~ZLrl7g9VZ$D	{mLAaBc.fwmwoW]	 	 @$I  I	-%<de$ o ,GI^X$-X1!1clz 	  $H	 L 0$I0&enr$$mI1A ]2$;.d@8Uw71!F1cLrlz 	  $H	 p l	8e$6_7.Udm0^{1A<< e22^3,c5ac1dw&dmwKm	-I  6s_
2U9H!
   )
#e6YC6`	E!EAKX"UkE5$YBu[1 JI        A w [;}l{KS]hJP     wvO)I^Q|^s  }{@mv<DlS@  S
#@4LODM%C@z TihFFLMIHE# hF??JJCWg35t-yNLkS)TPHw:#75wFf*YMwZ336f6ZiLeZZ"VYMwZAkVmq4dK26|>_s;\.]FWeg;^kwF{gtW35]RFDI 9%4msc6u%HWI8p[]$rIjVFgtkpms[[R#"H$]IjrIwu"DriuM.$AtrB           w]w  rQ*"$Html1_=Q9\lp5xxlsF69kh F69k[]%lsFlsF65\{]h4msc6wkkykF_m>#chTDDDlD[&TlF,ch`P$Km-!$A&Id-
6jfKLKm"mlH-ZMk`T` ,X,b`5Flk%k4"!!!!,3VPX$Kii0-(i+AXm`V`M&&hhmM-i4m6dLdM&H3Sm[QdRJ$KmAmAV	Y+Fh5FQZQ\k\5XZlm[hF64p5[[hI'Z5F	sUh6lfliimQ"V4$Q6QEKda,P(PBw*
w*cZt:lj6kmj
QQgv16m[E[EVNElVtImI9i, ]+Vm+fbPZKd[R[KjfHHleF,m&i`ZEZK6m-,!ilZ[	2$aYXQ+&XVcSm6"kd4DBmwU[]gtkaMFwjm-[fevbQU"i%G7-I9]IKJte$,:;J$Mm,]H3+g&[94$:i$8uhk5mcmMUjZd[2TKMZ6Z6"$lZQ"ia#VfS+6j6lkM+UVJV(e2[Q"2Y&ZQ"-FjbXmM*CUY+SjZCLJii-dM6*EL4,$b5ei2ZL0`,0`j-Lmi,fVSfDUmJVl,cZKbebkf&#(`xlB7E7!h&%q$)5JJ
m3KmPKfLiRQDXMuc$9	dB]2m'Z[S-/yFm
"=9A&FV3 ],nmKI)ZM5%B*/3d{rTM+FhA6E_B!B)[m[7fTYkU55ckX$6"J74xC:mmm2Bo6 lmpIh0=v06I^mKm--kbVab"%
Sm30Ve+mV56+m3l37I=%5KDhH&Zi[Rk\6I$VM4BhM$$7nYIA
jchJm%,VfdYKPXaMe-AcmbkI['N*[(KJ6*"lZ#cV5M4"TIh&8S[mMnX"X*hE+cm)e\\SecZ\k\lK$I6YlSeKmDUW5E He3ReV[I`+2j%u3i;L(4DMeYl*Bfm6ij#[!UU3VP6VJc`5Qin[3t(41ZMbl-*18)Jl+dlTclEY6`"cmDm3jmF%UI$M)L9,9f4nemnFq
K$I\m%-zhQ[$5[&!e&fbR4dm&"h)3YU+h[i*KkXI7rYeEpB[)LQMilpZ66Y&fmVSmk1E8+v37,AQV%ljKmzfUf2Ve^Yi
f`PHB"DLsr8irNnr$I4DP)4X0&MVLY28*IF$44DFH24`UUT6Eff1fe
3(e2YXS6HZZ$ *[IVYK05fZ1-LTRbKJRmi*F	(54DlZeHH 6 	cms wq @w	cmyr c;lgwFD{Nn'vih
9<`x-ia[6V(V1Zymm\\hjX# PeldljfMH6&*Jk3u)+lSlSbbJKucsgiD^s=y< meR^7;m]6tnn@imygO2;mkZRY5/[`5jV65\dVcf-FY-CZH-QV:C"uaI5FdG	2hDV$	cVH2Tb;bkpYch
*f2I-c[6	13j#hkWv`+`n&DD3e*V  ,bX5VQRVdB	bgpgJV$5+S9b b-%wjpkajprQXEvF(44hXlXkf4hFF4hXhEbXUf,Xb(EQXQDDU*"""&Rd FjY"A$$ID$TE-&mVZ]vRjXVdS4A[to9lJ[8trn7:3kgQE:PjH5;8Mh6P5wPch[wLj9				8aa;g&-"RF51Uu\HNMLK2L)XRi56-ktAEPJ[$%#I5QbEr8@6B"JBMmNnI%*dJ`K%h-2j1VMkT[l[[mlmTmPQjCn:Z<go Rz8i<g"yJYXRT+\x\xDo[Qm1*f0e,Ll[H hpo^zT+<S1bL56l.7w]799mIfTU[bRVEHQ[b*$P"Db8lj1cD-5Mb""#Xm6Y-94LIi4$b)|?n^y{l5UP     VjK\       +P0+
  .Z1fmF2Y6n  *  7Jvj  ]5m  ]JvV    55-5J%MJf5Z$*i5ssbYvud "	4kBF*lXRVTY6[3ZeVm6m5B(*1#&M4b       d+%%,f5Lh2sMTFmPknUuY\mf`     1u
6l""""""""""0F0DD`D"#b0DDb "#DFDD""1D`DA"#FDDULc1c1c11c1cc1c(1c1Qc1c1Dc1F1c1bc1cF1c1bc1c1c11c1cc1c+c1c1F1bc+c1c1\0DDb"""" DDDA0F""""""""0F""""#`""""!1c1v1c1cwc1cu1c1v1c1cwc1cc1c7q1c1v1c1cw"1b"""""""""""""""""""""""""""""""]c1cu1c1]c1cu1c1]c1cc1c1c1c1c1c1c1c1c(l%[	VUl%[	VUl1c1c1c1c1c1c1c1c1cl%[	VUl1c1c1c1c1c1clF.1c1nc1c;1c1c1c1c10b""""]c1cc1c1c1c1c1c1c1c1c7]})C=P$@m%BD>R!"wd{i(b w{P$@{y{H!J~{~oxmc1c1c1c1c1c1c1c1c}[BD{!P$@BD{!P$@BD>H7CyXR-s,XR-s,.s@e\ B w2<Y([DXU$JV%hAdm;aW<Y([D{*Dm;`zDm;`zDm;`zDm;`zDl7wZjCZjQjCZjQjQjCZjQjQjCZjCZjCZ'%u9+m|*]#%8PkHB<Y([Dm%i)	+asH,-m([L+([Dc-m11c1c~|H{$7JnqHR`;{$7JJBiHR{s%|{sc1c1gItU]#kYHkYHkY^{K                 t/=#   6@  @}  ||`RP   6~>c)5
     mz6mB{Z^-/v\wflqg-8LDGggn88v:1kem[U- s%DKUlDE5& &*wRX6#W0@{}eI$'Mgnnf~'~[nZVXsoox{/ U ac6~JUUUUU_p{UUUUUUUUUUUVI$I%aq;[ wBmw^Mv=hOS|MI!;kMC}I	^<9qy[ O ?{}F0c }CQ#3n'WW{N*^;,S{N{{@~<F$x&$\dH-?~l}C[}{yyUU_vzg02KdRL9h__|{_'sy< #'}GI$G}}qY~UUUUUWUUUUUWwB{=wt3sMikN X{H^O&$vbJbKy'0 V~;<N N@$fZ*_o)(FAIm[lI$OK /{{|{$p'<}3J#O_m\x|~X{@/4vMayt 7N}g^u~ c 5hi3Dw=~vl A OtOT57:lo=^N|/Z^&=![G  r|{sAO[z?"ZPLmwq|UUUUUUUUUUUUUUUUUY$I$I$O)+z{jK$)&i'lv mOBEtZU\Km}]:|"Et>&4I$]{O~\=$Inm\q)$I!#:f~}0`CCm$Q$-$L%I0I6nl{(a[I$I$I$rmm.mf:mm	$]]pKLi$:t:pg!O=R
mId$P!2d$M$h0J|1J&KWdwHK~!)hdI&"	4 jw}!B BUUUUI$I!+6f[&m I/mI$KBa=q$I;' I$	snt
1A{J>en-{twD bFcJF	$N/(^$ $\MKLQaa8^&Mm5+mFrnv/Jh$wJiixI[lQJ
+'nk^[{n*j0a:.gun)]>w/wJmn 0;#JF-^%mHq.ZI[mNI[m6[m/I+m8sIAEdxw9kNVKI%]I+mII+mmI%mQGi((/-zism/%^$ '6QNahN{gq+mVA$w^$I$$e$w4VNNsy;t%mJh$\	$l^$V5q)r'nyISnI]e1T16.6B1B{sE7+mabn$nI&$8`FmNIwvu96I. Jv$lOH"pa5'Iy_mm;'nq%A $Xp)I<I 8a8A<08Axmou6Jjb6n$IA/r	$cIvok_x"sk-}~k~1wsQB,]F?>O-I&{4>[?6}jJQEJ+lx+k,Mbv1JbHmzwzumz$6^`)!R^`)!R^`)!R^`)>w'B(b)I+e Ncmy{=>{bK=<WHx[j!DA0\rm!zkY5CY5CY5CY5CYCY5CY])J&j1Rj342Q3	APe	UI%piH@-id5d4fXImf
d6U2UkJ3fQeaIM$443H,T5SR[diMPP,d)e	mwqfHQt+if+)jcjXmM[UM+Z6VEKER4	kc,R%uVr-d1[6.\5]ra,u7YjSR!VLm8W%U.9N1Zf&dLeBUT)QHxH(QL!DJUQVZjQFTT>y6qy~?{~+|??;}lck#Smx =I${Zk |H>NJ#qo\c<wJo{mCj]b1	.vP$mC[m%BMn1	.v)C[m%BMn1	:lhJSmR!&n(bmKR"w8Wlm)}&(T!HMH$}u*U4Q)URT"	GmCM,D	)J"6"6+*PfDfB3D#/%XBda1dMd&	0#"i0YbR0<HU3FaI0Mid0Qc*FDM4cA&Q1HX2f,Ya#"a#dMBL$"dQLUfhYQS1dhM-&bi0METj8LI&mlLeDZZ  KZZHmlT4-&)QTLcR[VZY`3L&@fV*`Amdk+;;$ _{*@>IUQUJ"a +Y-/[-/[-CY5CY:CY5FS5CY5CY^wk?!8
S~9c}~~~}:SMT>4Z~mbFHHHr\<JEWUm	\_knW:MCm4n1IvCi([M.b]JICi([M.b]JICi([{Nb1[ cmBit!PmB;Fe>x<K1 yNd>m%4WlYJ{@@5ARX"x{6uk|wB"xt}-Im!
BHkYJ3YHkYJ3YJ3YHkYJ3YJ3YYaUf!f!f!(l~tt}-N\m'mWsuo*)<#mD H"&+Y-/[gqgqgqgqgqgqg};wwn""""""H""""""$"""""""H""""""$"""""""UDDDDDDD$DDDDDDIDDDDDDD$DDD6l""""""""""""""""""""""""""""""""""""""""""""""""""""""H-%iGA?_{=" .a)fCSC 		s{o4$1"5ARX*:{u)<x:U\&1KnlB-Km%-]c.!6!v!HIdRRh]m!b61[tb)mm<1Xe<u x <[wK1tUv|ltA"mR-u"m@G$WIoU|u_{{\_knW:KZkRkf(f,:55[5Fk5Fk5,*P554w$AF5mwwn~}o_o?8NtNqgHTgtN(S8N_9fs53R9Mfj*fafdL303tqAAA^CY5W\CYunwK3"afmkmkn}r8;Vo*g}{***\#\Ml%d8N(S8N(S8N[=v}$'wA<a=zz>xbL"":%r[zs53Ps53Ps53Ps53SU3Ps5Awz{{aN9{jmUlw{C/HA0QU"c	JH|0303fa,N9{jU6W==t>8=!'TUhaH-SN3030afr>U|N$<c	zQeZ&JVDDvm]NigUu]u]qgUfa(+$k6Oqn       @PXZ(d$*lQ3ekTRTU(i`$R4E! )A
$U3 U("Qu            G|4ym0
 J  `K   6}|wyg       }8 6D-`5?B)&AeJj JT zjRM@ )'P +w\y35s;\3z5s;\g\vtktuc\13z5s=qWBw\v35t-yWui6u&dFosVugtkpms[k6{gqw035s0Tk4b6-4m`p4gwFwp\3Z0kjD4fcjd5d4g."B&j1"Yk9\lp5xxlsF69kh F69k[]%k9\lp5xxlsF674mscIw yk[]%)%iI*RR]%lsF6=RVhj$H9'uUW7vtp[]%Iw u]],  mW6ovK\lsF6=ntpovK\7Iw :RRv;riM$H           w]w  6U[ba""6-b56mLbic[F6Qm&lDF%c$Km(	-&Id-f&m2X-(4)YVS[*, XMjIJ6hX,ZB5FeY*RMFddIf2DY$$$%fH2Cm&iDIXjjiLLikV-ZlkQJTllllU*UmcI$fEYiDLdM&Hj+Z#Zhd*Ut;;9t*17:NSF5Cm5wFf4gvf1fK.5es79wt;vW15sM5cQD*1M$D%nCuQL:;J$BY$I8lm[hUYfI&wel+g&[94DR4m  1]8 PI8c[W0m.cTbBcZjC`T mAcZ6!-2iHI,,[fE%6IId-&fIiD$ii6IYdj1%ZI`5V**5+
MRj5iQ"2feme`&$iV%f5m[Q()lF6VSi4-KfI6bifVl$dtIt0m5ws1h9XS`VeAMF)FV1E[EsM$	XHu$Jj"DwjI&]rfuuhU6ibEDF6ci-JY+m1fDh+U&Bbh,Zm&5m5&ITZLJ14f%%$jIR6PXkXmI[	-iZ1cVYe`l2lb+mmV+Zm-lU9cXY%KXeeK)Y5Q2[km#ial1ZX`UZieSldZZ)24C#FVa"f|QmmJ6*[ylm#U(6BF
QQZ*")C+%JIh#QAX\)FB	ecjQFmbTEAh@m,Z4mch[R!76VV7f1b,j6"QmZ*6 kIJDm hm$2*dLzPRa9flQj-FMEF-c6C"Y"i4lT,EjB	xAM,2m1UjEh[jQ%
SodB8Q3p"LM"i&HcVTbbHmcl`"+E^6C"nk6DD-MIXddDdS8C^];YU4Q&*VPUE`c<@84IxtW-MM[jUr[2IQCbX|TIfzbubL:9cHQi+I*Qd%VbF&[J"A#cESXa5&"j(|#88Me6DB"@m#A[l([,ilmJVn4rfd,JR(j$RKSC=6)9" VTF*	V"m2+VVF#nh&$o7&f3-SKfI$Ut;qr*LwC UA&`mfX[ql3VAlbmmLZdV`Bgu91*E6c]MjZ$D*H0S6a4$$i3mRUDovS" VSg6FFB&!$$LI$I$$mL]RcRtsQL-Ai$+P@lm$%ahZ@fI)V-ct[:,dFD-`VlZ	Rh4AJJ#dU#mt)j'pp&l6[
b+l7 K68iMvZ",8Fh"
3R1V*4gJJ9LA"bI"BDfTJWn5 RV6T|E1M&V2:VeV5Mj%M[bJIf#c5mLZ$c9$DhB4C(WF+bSePjl9Kb3:R%"aHi"(R&`_d>%yTY[Kl#:SQSg4$lioeZVb`*1hoXa%UUXcJK[w 6U/DT(F``0EQ[jpUrfm+P1YBA!#j)dXzi`SjuHIVLdZK%W
*feY2i VIfi:	mB[*LMI1+y6$HbCmV+i!$&sqXm#i3IL,Y9p&I&c$$MfFRlI!6!0B D 	6M5e552q@"A#"f$d@"h2#l!$f9K)[fRIeZ,h5F1hEkRj%Rai@1FdbZm1m&mmE-5%j`QYPj3$lIAdYi-j66b+: KKsm\;	yz5um\ Owp8wwY;^kG8Rw*-H%4"S`D$Y)R2*LAcmMYX+[kkjwC-N
G5AsZfSd-lR^Ps*AX6"-T+-Fa[0Sds7#dh)^66fGmsK3#{[.4r8s7$bI{(ok4Ywuws<Uxb79$4mL3Vi9lC4DlYbK-M[5bT,	``,	``"2T3iFi,lc&h4dEj*"hFXfR V2YV`R(5-SeMTm6(6@R*&DmKwF$V
)1F
0WdP*qUl#7muM\22FciV6D1X!`hb"EZJIP,D	aJeQ	m5*A44hmmZRThQbQj*-EF""&L,D]k1.1e|-()!;*I:::8p6L1
*)c4Jup wt%v7pJBu\H4Vq",me
QS2BM +[Hg61fI*Ac$H4VQ%[i[$fMffQX$mX]w\8@6B-6-tJl$T[FKmmRuFrsl	"uu[kr-FcD$Mi1{])K9W8 lKJm\wWidd
V)A%*U$C Tw^x^Je0E2elt1^Y	a(.gALEjVcC:#HVSjD4LAufluB$RZKI$c_S2P*S&+dm2K%iKeilbM&ekhUc5-[[J&$m&5b1Z1%Ih	Zb,QcTcF4h1F2Rb*1df6-2&je3Z
ak2k-J$[UF4mPjlIAmb(TID6l1c1c1F1c1bc1c1c11c1cc(c(1c1Qc1c1c1Qc1c1c1F1c1bc1c1c11c1cc1c(1c1Qc1c1c1c1c-X1c1Qc1c1c1F1c1b1c1F1c1bc1c1c11c1cc1c(1c1Qc1c1c1kQc1c1c1F1c1bc1c1c1c1bc1c1c1c1c1c1c1c1c1c1%[	VUl%[	VUl%[c1c1c1c1c1c1c1c1c%[	VUl%[c1c1c1c1c1c%[	VUl%[	l1c1c1c1c1c1cl%[	VU1c1c1c1c1c1c1c1c1Q*Ja*Ja*c1c1c1c1c1c1c1c1c1*JcI$?!J@)BPP6!	@/#UP
!((bP
@VIfV% !( !	@(!J@)BP
iP{{bIF
P6iClJ@(bP)BP
HBP
BR% [$:cJ[eF1Zv[kP
-jbP
-TjbP
-Vh#UVjUV,(1Z1Z1Z1Z1[-[zmcJ[eF1Z8Bnc	@+$Ivm
Bn0KDwi61I[qBi6ZM&1M&Cml1M&IeWz1% WP
-jbP
-5a(m5](m5](m^c	@+l@+lQ@+lYkP
-TkP
-TkP
-TkP
-TkP
-d                                 F B H  P P    6  @ Al  $04*  04*   l  $	B  H0)`H`!l   @ 3   0  D@(m iLS*lDS*R$Hbo0j  *eM)-4jCP DId,[2aJi6&-ZJ-ZJ4F}0MMmVVViX  )l35=N/BI=Yt/twK\^t5$>|jI~|$o>sD$uI%pYI$>\)$3S
E_vDDS"ot\seWE_dDE2"1tU{7J'7A>v/_~=3ivI'/YY=-H(He!Bm60M/K,dD|Me M Q{z[w=^w]zO{N{ROXQIm<\mO^]lq-zgR>M]t6:K[mgYzdWCX{Gn{X7V.t\1e	{E 04c  }31g}Dw=c4 wW0  ""Z5Zu{nust}_o~bml*Ye^TXO~<Pu^]{*H[dewD]@     y,d {19I[!G,d aQ&xPbsKXBX*@
LJ]*@ /m
'#mD@/ ~k$UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUV>lcmvnnfmH[6?6VWo$~mw~]v,,m{D&;(qy[eUUTJTw
NwJQg.5UUZ   <?oO-4<L@BR6zw^  .:O@  Tx~ll,NEc<@~[YY"W[=   yd<I0Uz~8$7UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUlVPx -R tBm3ff^Kv6@)6fm[wvx$A@oV*U*JBh>BNH-ZbTU*T r!EZ lL\r`x	 (+
XEcmWmm
(t  9$""I&?_>*mSR$+nL36fmKv76fmUfUUUTIEwj$m@H#?p*bUY88! kL=c1f < Gwe I}e}QUUw VUUUUUS]a4*KW swms9uo7e	- rm-mn%mKW cv[\[kLp"]
`8/@X/YmkLp"\-mIh-p6mosm[p	+nbZ  \g 9sln{vZ+} -cv[mJ*g  6a%m[hpZjw#P{8  77vmwcy	2g 9sln{v OwwaUM~m@T1-^  .mosnKEqo7e ^l}J*g  6a%\$;7www6 uKmdx41n[Cdxgvm2K6v b-UUUUUSR-S(UU`*!em;fIfb	vi%VUv,YM5UAVBi37r6mIf`{mK2Y}VjM
 +RX!^zmjv fI j1bU41[DDjZ!wI %I}.=Z[W @/z>	|X%oH0Hk6k@jb	{jubqXbUT!T%fd+7zz{	R (8t'Bt8 !@(!
v	@( !@(!
@%!P
.!p^!v
)Bu:Cx=x<P4036Fm`b*c0'NUUU~$H	 @$I $HHXC$HT%zRHRT5THTK.
[_hh`f}kuUw~{K?&#=1f=KUHBP
B()BPP6% !Jv
P6(b% !( !	@(!J~l$1lCdjRhFDQ*U(D^i~im&64i40RUc4hDk0lK%MD0?C3""D4F" "lh6Ch3 lAF3dbBhh43&d6i2	L&ibahH6"m$ID3`&2FD4!#d#`mD!	DlMh6&&IdFBfDF1DZj!  5lPL3HimI1F6IA&4mfR B<tWm[NmN%k:uhpgUUUUUUUQEL	QUUP;1l$I $Hl BHK\?EGW|Zhg6WK-/?~M}{N~mBB<.h/F1cy6EIMP(XP(B6P$b6PlXIBJP;c|>eSKfo~4Z&#-[BGi-D0^[{T^l<l-B3z=z,W!J@)BPP6!	@.@P
!((bP
@KJBmB@	B @
BR$[?I-I'Zvycm~aak_5Oj6zzzz1ct#*qsiiH	 @$I $Ha$,I!DDDDDDD$DDDDDDIDDDDDDD$DDDDDDIH""""""$"""""""HYDDDDDDD$DDDDDDIDDDDDDE$DDDDDDJ"""""""H""""""%Z$DDDDDDIDDDDDDD$DDDDDDIDDDDDDD*"""""""H""""""$""""""""""""""""""""""""""""""""""""""""$"""""""""""""""""""""""""""""""""""""""""U^3zYeVz)o	K@/yx7e|hHD6n%&`*y$(/F1cy6Ew}Ip.6\;e.K8p'9%$PrK~U}TFOcmf{3wJo4'Ox-{q&#=17q&>U}}+% !((bPR`m@(lJx
B( m@%%!P6!J@)BP
HBH!B	w]```b 	!f,I        ZmkmH@$m$HX $0I 	!Ha$Ha$0$6 $l$HmlCmkmH "k[[Zmkm @$I $H	!	!d,6CbH~S:CY+U3i*"}{4SdQSdUUULMv                    kjANY\UUUUQD KeduB0  D	@$	D$D$~Y;;:mUWPL~XJG@kbf!;qc{m}}H	 @$I $H0 	 dlSuugt*{v!tcBNtXv	 @$I $Hd6$6CjwKh:YYdXUUUUUME	QUUpVmH	 @$I $6 !$0llIdMg$^7~ @Qb  q{ E1 *0PR4aT"Cl BURT(	BQR%2
#,"     t (   <    ophjGBZ@    nyBEJ*DqOzns   9@D"J$P  T@'Q&L#14)&jP*jJT2z@:JE	Rf0V1S1RLLLL0Yibbb-jf*f*f*f610YiL&*LTFcMK01Rcea] Fh6 4 6Fh6FhlL 4m`l6i& V4m`l6Fh6Ff` h6FhlL 66 Fh4mITPH}w+:Tgy;vuiqg\v5gtkJVf\i3;h3541Ib$ ].6-m^$ovV[W!)U wk:.vK IIK]VM;riwn        pup mbQbbhZ6-XfhXchKFX2j,ihYBiRZTJTcdZ6MhF6kFmZKXQ`5dV%hj-ba""*12b-5FcZd"ecH[miDIm2L$mHbYP6+j5EFSbFQbVS`"X-hDkF-Qhh&[EEkmmQb4IQb4h5Fha,Dl`T`&F[&(P@ZR%$MYdD,kJ$EJ
5TXEP)55Zb)P*VmE-e)2B(SX5Z4*&H
DJDV$4kFh5ETY, 6KEV54M&+--ccccF4M1DLdM&Kl--61T`VKm0m-VcILVdKHIClSQ$6ScVa[VldB @iJBQVcS3+0(&K`6FlkhlM#j`MF5f6mfUF
#462biXK	mEY$MmKH$	50Z[kFZJ()XR2fEEAhVC-(dbLKfYKJ$M1&j%`)eV+IYQ"MiTcFVV4ZQ"-,QLDF4
fI[c)K SUYS-V#LVm[m#Ie3ZQ"M[Z-E4M"T,B&-B&j1"iKi1S5[+cMlcc&%6MiILV,[YHK6J$LM H$J$LJjZ6i!-,UklZbeFIYI,6KfKJ$M1,$j(+R[jRdFXFIbM%,%iDem[6d4M4U!,ERVj-fZjJKld1fmQF`6*b40`lb,0`m0f,0`fT4@+C6"k
DmXR#UF#U")-k3EA3Vb61V6,FZFC$m6sSDDYhe&d	@	WQ!5("4o&k*)CfF,2XVQHA"4hBYU\ftV+D+,)Cf  >JZfF$(d	@sdV+L@+2B,)LV(DFD4-g4m[F-E-bE!M^SoCD^lVR<68[mVmV[[VhmcD[xhz6VjbYFx4hpqT hVkEm",{Ste6V+2+VlSe)CHekBJZ`L)F::V+16&ihMlFYdgIi	$eYeY$I$KJf3m $ZBR+QU0ZkH6$1&IF5M5m%Qi65m%WF-DTb4Vbk5M3J))Dp85mJ6Tb+Ahd6mA&cQ!hg#3iZLbm2dm3mk&-VMu(L-[hkb2Z4h+cZ-4Ticml$.hdyD"D 4#B4DDD\*bDQ[kQF(4QX%[5b+U(XVel7Xjl[3FkET[Eh-d64iGDmmX:jM[ngm;jZY&uX,MXQ4M,VZ+lklcRF,6KV-QQE5V76I4I2&YEQMAm"6aoI"IudD3=j4h!p#&I$"I"DB4!%I6FMdh7j+VnwV" O)fV6C{unwW I <8pBd35UfCVP$$bd5mlQi*Mhb+DmYL[dj#ZK%1mmE+m[+68Fn4JU)+ZJjLa$nU2Z@h
U)0\ X85l|y$6Alxra,&[&LH)Z2dm-KlmF+UfPem-kFFZS1MIM6j)2[V YTZKUv[&YIL*V-[0 Ta a lb &!l*[&4M)5M4,1%a*11h1Z1j563c4A	d0D&[b3713thIS(L6QEbm5T"lmj#lfFdjZZ1RH)`c$aBA#i&Lq&lmf2dc !c j)4H@@MkDI4jM%I	m)@[0JM1A#0[kVAm]mn1Z\2" +JJ
VUfDc5Uln14nbYRR)M5C0p1UJ+QD$hINUVg7Jb)AjMcjl(6hFIE-V4hIf4i44Z"b*Rk4c""TT6D,DDRdU"A$$ID( iLR#mFjmK4R#h4	KJ- 4A
UBV%ht\x+QE8Mh6LcB*3dm^urHK4U-[2&YC$cXtDde&Z&D3A&@Xm2de$$&lEdRY4F5"iH"0@XibM	$ZJRiQY-scclcF5)Z$M(94*  5E*@RJi
+2XQ76g6j IYJ+msjx04ReijFs&IIYYJ6D4be+cH 8VRa,VF!JaY["YZH-2frMQ-RMWaqgX:TI+y3cQcYDDFj&&I4!bBU||~?m{}[`f,vphgsphgsp7rp;9m4DD6MhId&hhI$4q $		bLIWp3u6nf1m,*&&l~7k		bBaX$&bBU&Df bR`M-IlL  4),""DTX*l[&`  ce()`*VbLZa[jb#h+f%ZR6+T"@( T!W41c11c1cc1c(1c1c1c1F1c1bcc1c11c1cTc1c(1c1Qc1c1c1F1c1bI$HdI$I2CI$Haa$I&I$C$I$M!HadI$C0$I4!HaI$i2C0$I$daI$IdaI$I2CI$I!d$I&C$02I$M$HadI$slaIRi2C0$I$daI$I00I$Haa$I&I!d$I&C$02I$M$HadI$I$0$Ijrc1c1c1c1c1c1c1ca*Ja*J1c1c1c1c1c1c1c1Ja*Jw]saaadaa!Haaadaa!HaaaV[npV6Cn\rm&dHdI$I$I$I$I$I$I$I$I$I$I$I$I$I$I$I+m
s8+m&aa!Haaadaa!Haaadaag\rum!LC$I$I$I$I$I$I$I$I$I$I$I$I$I$I$I$Vm\D?9#-Qw3sH2T{KICM),wkbICMDPj=skq
B7qICMDPj=C{UC{UC{UC{UC@84qpD{6sr CM\m%i6sr CM\m%i6\c-;([MwmqPm7q1B`;1mM6!Pjiu1b6SJmM6!4]LCbICM6SKc4mLCjb6S(i6HLpB 1mM6!Pj{	Q;1CMr Pj=sUAd@nic47.%6w5\$JmD 8nic45\$(i CMW	JmGjH"Pj w5ic4mLCbICM1mM.!4mLCi(i41CM6SMm%6S(i41CM1mM6!Pji1bS q[@          R6  X       6    I$%I0%L6YfmZZ-)6m       5eiV-     	U                             `S`  0`S`  0`@   4     	 `i   	 `   H
      ,I  YI$(IF6o{ )JYe)JHHJ)5M46 -S{  $I$
P-lHRI$!S`HC*ViR"-AU@ jT RPI$I$DFdI$I$IAI%PYi&`6hI)e%*QJ]
UT_UUUU_+<uzs>WsD}fffzUUUUW{z'>vbI$p;wp?}A |N#glGUuT@P|`$-z!W{	
}6 3 49sZ 
(|gEyKg0U^;Y>~MRk?@ t9h3}1wSK;t}UUUUWyUUUUW?S[wnnyv`r\^1ZQTW|9s{iJi#0vI@$IsI$}/ O}zz[x||}nS=}*{*A>m5oLy$1>{k)'^fAnfrqnaS)gW3DF3c"c1o^{= KiHq$I$!@Egws-(p]%=>ww_nd|i.66=B{i ]]u slY1w.L4fbq88}UUUUUUUUUWS-:N^n}wn*mmI--J\s1o[mI$I$Hm=GviN#fmUWlUUUUUUUUUUUUUUUWm6Ko0WM}-{km;}nx/x/
E>om5%
=)VB\M}mnj;|L}yxUU^'=^H[KxWT?I$I$ Wyyp>~?{*m&'=*mUUUW&0b`( %Odd}UUUUUUUUUUUUUUUUUUUUUUU_[mI6md_[}$d}6^Pm)Ndnt$L$To[ksmdXa{Fn[[0Px$)$hmnj;mm.wvq#fd?zI=i1[_Nu?  !C{~UUUWM
T`6mmI--[t}UUUUUUUUUUUeg&wDRdJ\mu-Qk)5{mGuwls1RkBI:M6I$I ]M;pI$RWarvm$6O4|):Hm;pI$RWmK77JzfQEQ)-f'@!Gb2hmr[mjIFrmf&jI6I"&'km[mI"{hVkmr,0c$	I^li$.2Hpm7.<I+q
Nm[mmOmJokmmmm NabyIv5d[mkm{hVnRV{[mlmmmpwsDMK'f),I+[EQ|Rxkmbx0 paa	bmK77J{VrmkmqYI[mmmmmdi14LO).fl7km[mI"{hVnRV{[mlmI&i$A6Dmkm$OmJ;v%6i{9Hw$i4%2iqnI!YRz]6
SVm8]6I6MXA(!-'5oIm5nZ
O\T6IQ|Rm'0H 	DCFm'*JY&KRzmKaInuma (
3%)=qnuL%)=qRT\L(m8$!2X|N1!4hNRz%.A#<8 !l9R!mHw`C

|RA (~x+mOx{ IHHr)!J%fK5A*TK5I,i$YfK5I,i$Yf]99u]99u[f${HK2I0,{c	DD1UUU]kyH H HRUI_61m6""4FL	F!&if4&HB1m#L	Bm2&IM6lmmU  u' N  4RDu)eMtubI#II$I$I$I$stY$[EID6mbKi	
&Vjf%I`	dEd,dFPLJI0C)SQ*"J&j-XL(B3dMFkhSm4liF1cE(cDBkZ&Md6VV#cm	*Z3Z4
FX`)em[(Q[jeL+*TkFEH`Z		2[l*EmZLmQmEDT6HC4$$tUq24jeF%%FVK%&ZW1+mm!hFKn@hlc[Y"B"DU50*@uUA#IHdDH$AS]tnhvf+jQF!lUZT!uJ\g$nkfDmV4+32[1mv61cAfh6 1 ~T*NZr5E-^^t]uC=wsqxU} 0*8[SO|6Ol8>U|q%YMfI5$HYe\Ci)M!kfIunfY!e!IekckY1iBgof&fl32f66@c396g3a,3mfaM
((*( Umfm3Ff@o614FlI6dfa#LHMm4lhd2mlml3ZZmm--P   $DHdmvlog`}a$~o;#9yv}MTmmm"*-m{yH H H"""E(I	 J'"P	UT'|w___wY	%dJL AmUUUq6|6Ol8>{mLCi(i41CM6SKm%6SJmM6!4]LCbICM6^ckLSCk1mM6!Pji1b~CQ@o`,dM%9&[4gYgJYs0 %m: N 9%H<n$ UUUW{@'U_M{{jb[oi41CM6SKmmbICM6SKc4]LCi(i4PkSPji1bSMm%6W8s5?mo5[${aYfa.E<x0DJSEUUUfn!	$H H H HZQ$DDDDDDIDDDDDDDDDDDDDD$DDDDDDIDDDDDDDDDDDDDD$DDDDDDIV-Z|xC	NN 9K3S<zg8=yIxuxw/[dI0 !=UUU}mO{/&W{mM6!Pjiu1b[oi4Pji1b6SJmM6!46Cm!4mLCv44wW
4
\==	ORhD	5:YM)> })#xVs YI$I0 0UUUUq6|{/&Wg{mM6!Pjiu1b[oi4Pji1b6SJmM6!46Cm!4mLCi(i4Pjk8s5 !>wDUDU032f
f`#3 V#3ZV#3Z" $	 Iff`ff`#3f`ff`ff`f1@1Aff`ff`ff`Pf`6\q8*>_vmyUUUUUUUUU]eUUUUVHBI!	$ H H#k@!Hl @	w ONx0[1DDDDt$bUWMZRm)Km3 303  30P=sqqvp'rU}oKxoh-<=jB":Jm"
]eU|]ff`ff`#3f`fnvtwIH_y8T-N2m!OI U|<<f`ff`ff`PPFffas;s	B@yq&{Aoxvu)#d -k3 303 303bf`3 1AY&SYc  _@{p  0  `p>    H J *3)5LRQTRCl( DPED %P@
QP BT(P@$Kk`f      @ P/    (1 `Um((=
C*U%i%m[GL> |{@	}_XD#J0&*i=LR 4	=RJSR4 MJI05$Id`OmekjfhFRDU)-SL`0[FZaiKL33-0TTTTlm3f*f*f*ZcKL30Zf4cQFaLfL-0L&iI(iaFdh2F%Fh4mIII H Fh @ h6Fh4maI0 l6F  l4@ F I+JIT`h4m
YhRJJjIIIII6K           h6FhlL 65hK3FY6$           `1 %JY
`5m6"Mh2cK-1Zb-V*&if,QbB&Z6"XXb-eD*"E612cZ)!lVd,ElmEElIVVIJ$BK2$2L4FhZ4[EEl  0@IIK-IJ-XEiFQEcVaM"Lm4VQQFTjZ,)hRli+lDDj4bBHU1%VdRSfJ$jmY,	
jVe
i6I5V-E%6HHHHKl-)%)%mjhiIJk$j+-VIHDFbB"kXEQb6EHDm-EV, FR))f&+6Pji6&lSi4LdM&K-(#%lJd*U60iEHYlM*0l`kmj3FRLT`X61ml$"V,[YH	MD&*[-(2	4M E%-$%`0ZI"hZHE!-Cl#[U5LRIm2l6L`HbFdEjcVaMce3ldI5"5V+lh-IJ$YlHHHSLDY6U%!M[hDm2kFmdY65ifSVl`#")-kF
#&Lj`-V6Mi$4m0m*cUhm-lk[
m(Y$Xli"
6-mf5&H52J	IXm-YYSfPVfk+$
l5j`fEm-lll#j()3dTlJSl&1ZX`14l6*c%#21lC&3fieZ[eVVX`02##E6em
fFeaS4|R*[qoCVT)(Zs)[G6mQl oJ6z)MlnmMiVJI(h*j-)UJ7B
6kZ`5k-bUgb 4!Jcljb,Tbh6m)FhBBoZ7f`6 1,UQV6-D[zRe-"Rli+0Vjl5i6[Imbm64HiZK62DRJ-bTVg"2SmkeF4cQ&6-F"EVRC" `
Q*0lU*jhl6*Vll$HnM[j[hPAho8U1V5,c>DLzldSjFkGz:MblZ%l-j6M&-"ZJoC*kZs4F8c)LphpmDKIFV1LcF42JCc=VJlh#<!LMR[qf\vkmYXek`vbY%XmWFeK+S6f$FBfL$H6FM4b"mi	4{z3}[ b	D!NAh&Y"4iBi!mdK$M$I$DDfYJfXaPlTcXI1b@m-i$Mk3AHI%6D5k)lPSjfjSjf6icZG#F5%%QF6RkD[%&E	m,+ia,VA#tVlSEZQLIib1,fK!b
UF,j6j1V6,b1b*3sl&D&% 1em`aM([]ee+%i-cmA#0^-	D#$I4F3M!Y4F@H($n5p W!6BBB6y)`KZXQF(bl-("K%qGf3M[)Q+
mMcq7$I$DDi4*b&0TIQ)D210"1Q6,X1VLIdbbdCXlX[kuI%JK, YFL#UIPc[)M))""0`aJig66I[t((8L:kob1=Mpg-UVM#H$&m	[$mnZ67Wpu5%-B0b0h6w +jK%^AVQKIQcRQV)%!&jm!,f$4c7	fs
Eb64jg49ZI$Fq#mVXlek48F3F!1!F  Vyja0b(, Hcj40mF*!5I 4,F*,Q4 16FlV4TXkIFIEEFh6CIbjP[mj ZZ#14X6EU8;nhjUKXI1I$AHUkX)P`EJlU*`h-UZl9424CLDLIHm2`	I$DdF9m[6RF#C,UJDp!$c&A&m!AL2dff"#h2&6>6lvRj-h%m%,X 1QE("1ZA[[UUAA(MHT[ i(QhQM`ea5"$h6b`5U``0mpUJhb[mVJ
@`!Q!#Db7]-%%(-(QVNdM6C8#c*mUl%4TZF&j-hm,E(5FRi5AEh6AUQDD  RJJJZfaLI2m[(AfjS"2cF1bkI(ijJ%dH 31icJ#)I%P-dIFRT#VVdLEFb"5QK%ZhDCJ@Q dY4d%)"RlI@("K%6#F"&jmk"""kve+Ach;[dhIj8j4LmUQUAUId4$l$i1lHQ+aBkmA&dJl3i2cFS"HLRXXJXm-H1 R-V*6[3rDj7vUMlf-@JBT142"#,fbK%d$ 6`0cUaaEUMVdelK!b3)fkjV4[-	lcjf-kQZelVD3Llh1F-b*"*1FeJ-"mV*"MbVdl6[EjCcbi1KQEbLi,k[d"kkcj6ccb4h,C)o!a$i2C0$$daI$Iv0$02I$LaHadI$0$I6I$$I$i$2C$I$daI$II$$I$Haa$I&$02I$M$HadI$C0$I4!aI$mc2C0$I$Hd!I$I2CI$I!d$I&C$02I$MI$HdI$I2CI$C%I4I$$I$i$2C$I$aHadI$nI$II$I4!HaI$i2C0$I$I$HdI$I00I$Haa$I&C$02I$M!HadI$C0$I6!aI$i$2C$I$Hd!I$I2CI$I!d$I$!aaI002C001rkmw	$I$I$I$I$I$I$I$I$I$daa!Haaadaa!Haaadaalm!wPCnV5Mm2I2I$I$I$I$I$I$I$I$I$I$I$I$I$I$I$I$wa[n[n$2VC00$0002C00$0002C004pr!wPCnvraI$HdI$I$I$I$I$I$I$I$I$I$I$I$I$I$I$CnwP37m_HBP
BMi)BP8Bhbvm	%ZBq{m{om=Bi6Z&meBi6ZM&m!J@)BP(bP)BP(bP
@^HB^@P

BR% !( !	@+$IXVj&QqBi6ZvZv[BIF% F% Yfc	@+lQc	@+lQc	@+lQc	@+lQc	@+$I-lV1Z1[m@+e1[m@(lJ[kP
-6% a0KUiBP
HBP
BR[$~&meBi6[@ml&me&C;h[-!	Bn1I&e!4h[-BI!4h[-BIyf
                                4 @  B 
   l  $
 H  H0`hT  $0`hU    	@  $ 	     h   X  0 5+   F 5  )iDBMMoDDD[-I&`A$L")-K+k~"$%)R3H#Kb"HlI$` 4bM&T4"SP00AMiT*d*U4,4R@)DMR5JI$hdi3)l    I$I$I$H&[$&[$JLMI2A$I$I$I$-,li&f!J3`--*I&l   kkk[|ZYkKgtKeo**$Xt/tq{BI~]=[Io}%_bK_bJm____W_[j[Wz,:.c]	Fc_XF g{*1}w}5oozKvvIDb<^>"R#$HzY/e'}56
c)Dh    _4Y7h!t,8qyGlIKf-ds**$**$+{zjl^'6BG]|+zgI>zh^=w"i pL8	>kN[q){G=obL~/t\7{ ^]DDk37t L3Dt"#_pvs]_'w=:=gg46v_qzgg^~W/sLXPIIRY"bouI  H6dR) C$}zRLe((~   ^^Yi`d,b(>   ?|{,YbmTsGwvwue[ImUUUUUUUU{UUUUUUUUUUUUUUUUUUUUU[Mbz>y%L4N #d^$ "kW^v'n6I!"L-^JN> .KI$|A Sov dOd; Q' -@,qw]=z9be*I$I$knSH$   wt\}72{H?svk>mvw	&i&@6i$I[(I2Ja&m mbh`d*"&pKmI8.H[m@ $%%r$w7r\ @$$XdOS#aKh6 E(A,1(I$$I$I$knSm$I'RI::{L$Hx$  4Z|I$N(r$M4-DS6nmcu&S/so.[mdA@]ovA!$$wS"G#UUU[XrIeOw7Id$I>{%"z7$@yXZI$7JE~Hwo8IoU4oN$QAc$I&ly8I$i$M7E[&[}w$-}IUbmdI$mI'rJ2oN$i$nf8z7$@8pnH}w(~_UXaWy}$de/I6TU~I$MI'rJ2oN$mmNe/I6TU7I$kow$-}IvH}*t_E8xQFA@a&%h-I$zvJoN$mmNe/I6"};c; $II$IF[-mI;Qzq$ko  ,UI$M	$IF[-mI8/]mO)+oN-mRz	$umV>>RVA$[]mOuI$mnRIvH_  I~?u$I'I#lNtXLvmII3ukm nBU~I$Lvm3;T[I'I'kiv$nI;\vI6Pucm!7bI$uI$m:j{$1m0
-H_oI$I;wkmNWUwzws.cw3[[[}@	#x|)6$km[me |(`H 	m$`XL$YeYe JP6qqt( @.(b^P6 ( @(B\m{mv	@[mzVqiI"BJIi????>|FUUU/q	vmM4 ff`f  C3Q3foqB6FhF"@H6"hA4b1F 1A2l!l$mJV  iI Y Zp  ,V4 iL6R$RDu)&KnI.j,&W9HubI$]b$X:$]u9$sj,&(39g$sQm:S$HiKmZRf,&[i H2[[2X,jFl[6MhP4d+2d24lelQm)Y2S1m*3jL#l$VYkE-Sb6Am5ThZ265mRKieC&bLb[FEMT4d	HQ#2dFfItS,)[3#D(
Q9lJi6	&ZZ*Fm*FA[s[]6m(G[u#7FbldkVU0j$mXM5VPa0PVU,cZ-[Tb3K1%f[6me+fI6IlF2jS)ZjMmiQJMR,iW465h&J1dNNMLrpDYR1")5FI4XI+p6q$m$'$KivI*h5h5Q[)729#NeUBUV+4ii4$ c&KsI$p8knp77t:1"9VBNLrsFcStLIeI&!@mlRT,Y[n]$DssFe6HmHBSkE2ZjEmMhI$5mb6"TB 	@)D-HJl0g_.mGy4Vut5u[~Uh$H$ R<[$Wgf3U]_Yx*hbP
HB]% lK{n8ooon\lJ/@(b]% ](bPI%2[-Id%CAU,*LJUUJDj_DJUK/A%JPU
W#sNb1
I+q*MwhYU>c_;            ( vA~$-+%WM$M$5}_Y$:uO{Yx6/wu7d*>U}eW@P
B


P6RP6% PbCq	@(P
% l>Ou6Y#kfe~Ydi5l>=$ =`|	'?~I%@Yx6x`d*>{U|{ H@)BP(bP( 
P6RP6% P
@(6, ( BP|gX.ZrYgiI!$!$ni????>|UUVl'sUmm6`  f`ff` 30yICGWVZGj/U|I {>_yU:{{%PW}{e6@/WU|{ H@)BP(bP( 
P6RP6% P
@( BP
Cq	@TWmC+oAd`i6~U}{Ngwt:_{R^* *dT	_Kx*iiSa0l0633aal601MSamv}|  ZYE$	    	wwwwu`ff`f 4fa!fa0-jff (30L f`
`ff`h 30fUUkUZT@$	D$@"@Vue%+<{m
dUml                  ww~Q76y1UPWc0wUUMvmi3 S 303 @!30>i^l:KaHY#$HV1
(F1!4{q!a2*^>gL3 303 303 o[wSu;_yUCItg1&{qg l^f)f`ffaFff^>^^Wca;6`AUPwwN@$	D$@"@e5(.eG  S*FP/XmbFUUP#a $TfQJRC!"+HT(U!%djkYmXV     | `      > <@   oCg;9     	c`|#o;>syM4J4 4eJ)M4@ TH&#	z&i )(M<S&'i@>ldT-UB3B%S+3ieVfLS0YimDJ[h2$HjI
%%5M$$$LHa[*  m`[S0mf`i6h4b3LhA1(!	EJ53%YZVlvI(,YffR#$MM4M$li$I&&Ild[QLQTbmmaeA-Mm$E[TmV-d[*"$EJf"3ff"mbPlIf!#jefmE6%-h[+e-6Q3!fQLYLYC2b1Y,j,,4j(51MlKj(jYQ&`Y`YLI6lfQ-lb1Tck[-lbmkFhi,[k)6ImI$dLIlQX4&$mX,ZcVcbl`kRh4DHf"$& emRMFUVm3U(mBjfa$H,#1Uf	1liRMYFbmmVB#KKZ4Z*!VLh$L&Hf$"D#mUmTQHD(JBd"iQXZ+X!MF5f4bMlclFlbb(cM5cQD%V@HII2$"BL#F$HI3Ii4II&LILI$L4IfaElVmmmkZhV&[mFS4mk6Llk[l$di"D03"2D"h&HEcQf5f4HHm+h,mhF4mVh,ZPXVkB$[XLH"$H2ldDm&2F2$2"FhlfSm&)e6a&ihkc53(%JVf$m4D$CI$4I$	6imMV"ij!e4M5cQDFm6-iXF-``QQE!MF5f,FmZm&L"D"HI&A&MH2bM&$bM4"dIIdIdI6m4-i5mlmQB2@H6DFMi"H&bfS22aV5&b%$-ckhVHD5mMLHLi&F$D i1bVJDER-Td46Ue6dI&L"Hl$HmF#b$=V[MV&Y1cJV0fV0fMYamdiSZ2a5i5e%k(2k(1&M$I4lI4Fi$I4I&MlDFi$IYVU#icm
Ej-Hf6h,3XYj&$"Mid3i!$1H,lLk# h-"eYa1aXfe,%a1XeCY%	imTVS%RoI$6B
4I&tVI-1-%%%n	&zJ7DD!IF6DhXB$nFhFB;ji5lcMbDI&$5II%Dj")-x*#I$nAgmU&68Zli,hi,$6d`$;P	$ m8lIZC($l	m)61IJDYZXbB-IURIi,FbKIR[5Ylf(e-+,JRl("J;PbI"!YmeaJl,ljRY6bXj6Kl`bCjK$KI4P	$!!!7fjmJ%,S))[Mlm6ChRII-1F*1UBM HEmBYj&U&*5&
V$b4C!mf4D8MJ7Gphjm&	6$'lg-Y&mAJj&"jD6$OBIaF64c7QY"RR,dQh&lAJ	%Icr4B4&DhD"27kXT0`I$Yl[@ I&  $I6 )$E42--SjKP[e*aY3HJIFVSVlmbIk%k6Y+ABIi+I6dhX+(A!	"I""m[kw1I*2Q*AV$E`%DRmSSb45I-2dD44S*c`J$*+
K,lV%f(f!ch-RY6Q%64TkLidMpF(44HFlm#ImDIclm]enCdDbm,lL'dR7I!FbWWVRH#2%D$i$phljITc4pp4\7 FmJZIWp%eyIIT ZRVSDips%T1bFVY[6f4m%"YJVF6VSee%EfQM	fYYLQP$$m%V,j5EFf4HNel)8')mCVHHdLU$M1MfxNDf,Va3*bjX`xG$;2	diQMFFmBM$MHIIMhI6Li1eh`M2&!YSSFBIdIi$jRH!#D$DbU6I(+jHIV	$b5%% I$&V""4!"
Y	$DI7)j)ik$Ac	%-pKHJJR$RI&7DQJK%	mH$	k%m6hT	e`$)Ij2`DdI*&TRI	4Dr4hFKZFZ"mH$I76VK#fM&i5%-V#"bCHJ-YDSf&b-UP1D`Th$i$&D,jP I$JRFVcmbQXh545`Ii64*MR2,FaLAPVh	U,Ueb$HI
YXDfH%3dhR"Fi4d$d&LDH4$D[44D-KeBLmRY4Fh mMXIZKJdH4$D%fIY&(
*KnblbTVdBM&i0paZJNelLW
qUeJDsUR6lD)RbD66Ti$&0le*R&HSS"42mJ[iJ1 +%Jl.)*ai)G6kI-IbM"Ilh#,56}yw*zS0EUjk6,Mc-C$hdeMbYcIZVC[YjjeFfM66*6llZ-c4lh+!MCTM64h5F5ebTcZeQlc1F665k%[+d,	f[F*j6RE2cTI$-b+$FRXDFl[Pb6lSMm0m*KAB!BB!Ba	B!BD!3BB!B!3BQL&ffffdB0!	Zc1c1c11c1cc1c(1c1Qc1c1Dc1F1c1bc1cF1c1bc1c1c11c1cc1c+c1c1F1c1b1c1ccc1c11c1cc1c(1c1Qc1c1c1F1c1bc1c1c1Zc1c1c11c1cc1c(1snm6!B![Lf!B'tntntn**s&ffa3333333333333333333333333j[c1c1c1c1c1c1c1c1ca*Ja*J1c1c1c1c1c1c1c1c1ca*J1c1c1cUl1c1c1c%[	c1c1c1c1c1c1c1c1ca*Ja*J1c1c1c1c1c1c1c1c1ca*JwNg#V1Z1[kpcJY%Z@% J[kP
-q(jXfc	@+$V% !( !	@+U0Ie?V1Z1[jbP
-kP
-5](m5](m5a(mUecJ[ecJ[ecJ[ecJ[ecJY%{+4Ik!(wi6RqI&M!(o|vvPW96PUq(]zJyvwJ>Usf>
|Cml}F% M-UsBi6[jbP
-TjbP
%5a(m5a(m5a(m5a(m5a(d% !(J{!J{ wP
@% % ;@( w^HBP
BR% !)o]h    [e[`                             PC, 04  @  $F  $04*   B     i   $"  H   $
X6   H`hT  @)@	T    @,-   H   f   2	J H)DDA P   ,-   @AJPA@ D  ,    r"" @ Pah    X  *    HX    	@@ +   +-i[`         P  
HJH3J kCQ       R 	 H H$ H    L & 2K4 -6  H 	 YK R     l77OO{O{~~^# G
I{qT{$/<Io:ics$qTDIff ff ?81LD_Qi#r{>9\
E2"6zWsc{\o{"9Zy?9}bUURTEH$W${Gs>m8l!P!s{9wk~f
bi',1)zg	t<<fOy.9}3{I{gyUUUUUUUUUUUUU_Im*-};!TN=5t6/YWB'oI>=uq/[_]lq-g+zuwwYw{Dlg6lo;#v8;U1  _1g]	w"Ab`K_%{p~@  F4cK]mmd9/{zOt\={o]nkOLpH|q(q*{wq'*'$Ve}=}&}9 .{mwEu/        'y1(`i5Yq'Lf
b`b]8J}X4??fBW?L4bcig IK$UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUW/>i]|DR6[_ybimsr
|s/+ZMm<< !$8x9l!%ulv ccE{L!(o\2X6g<|   i aU^VUVVVO)$IL.m<  w]wSc>]wSOhVv<pmTo %mvZ%n6mf5 Jzn+]v-v7UUQEQDQEQE-sH 7|%RjQ` ,SMjTQEQEQM~s@Erj!
` Z)1/aUgj./O{]wZ $I""-[w{UUUUUUUUUUUUY$@}vM3,7nno[YI.n+]I#$o3UjudI$l`L;@7BB=(I$I=$W&;e``  !GvgI$skUbSEnff.\ff-W#J-{Ik)$]d|UZbTJ(v*"`hf	>  w,RH:d| 92I=7mot$s'v6E&4s3  {8N&O-I7/8*.XU=QOv.E@Z1[;2$4<7cd0n| $cd"hf	>  Lqv=7mLqv=7mot$s'v6$@30I  <7cd$h [bE-O*W,XEQ'dS@$  )$],MDs'va$MDr?~bsz;[$  12wfMO.B;$#v>3UL~6blqn$  12wfI6G| $<7 {BI$!$&tZ+C(cm$UmHvmnrQ>fB.{3iln ftRHmI7x \b(O(#t9B<:enUdi2F[/wJ\FZ,l!\WwTn- :9$_[x \b(N*"@-<C!
ImI/%I/%eo9(bmXf Mx%g*ynLj!O*3h47:>|,J;==4Bt'=I=O{lqy8 !@(!
8	:@	HBJBJ@(( !@(!
p(JBR ($m^1kxs^^4Oj0j6ijVOFFF1F1i:s(y$H	 @$I $Ha$0$H~\\}D}EXTlU`e)*Lj@F$4f#QM&dJdMmm`@S+
lQL+fZkUasT48FZ)LYYqR+QK4QUB\EUEW*VE"|W=<ylmj4kF|P /	M/9]U?'*RmI/{L Ar>FcK/v[*.iBP
HB^HRRq( P)BP)Rq(M@!( !	@(!JN]uI_b(F*MP(
-"K UU
O`{!ER+EW"QUt/ezhnlv+?{|Htu|VhOBz1cFnlvEU\;H	 @$I$Hb6FH	!9U==RMxeWmb^Z6l [sK[W	/fn]OTSZc
g#-a	%N9Kr!{eBRm@.HB^% ()BPP6% `!@ $!X )BP
HBP
BBO,IbM}[;RzSgZR)D /9q_c~=B0hSwnwwwC7f8ETG[OOOOOOK'NL}-'{ef$,F$,F,I(X!(V)$lP$!$sl&EyG#lwM[RLCMQk-X{&>u<y&"+2c@@$I $H	 C	!	 8so6%)JP"""""""H""""""$"""""""H""""""$VDDDDDDIDDDDDDD$DDDDDDKYDDDDDDD$DH""""""$"""""""H""""""$"""""""HjDDDDDDD$DDDDDDIDDDDDDE""""""""""""""""""""""""""""""""""""""""""""""""""""""H""""""""""""""""""""""""""""""""""""""""""+l1yl?zl7*R6OM5T^q2:~=^~Oh/4kW{i'n=EU33zzzzzY=wg#np}{{{!H !B@	@6`!	 '@P
! (bP	  b@	6	BHBP
B@	B @B}[dtfP25}cz~Iz)oMGKN}s2U}# Bs.={_m$r>FzzzzzzY=wg#nD=={{*t!wH@)BP)B'tRq( P)BP)Rq(@!( !	@(!J@)BPo ^X[~}6C,I #abHl6F#dl CbHBHlI @$ HdlBk[m5$m" $D H;; Cmk`$  d,6C	 A$H	 @$I $0$H~<;:Sie:K@UW7[<}e_=UUU^S9TE2*g'yl66 F#a6F#dluuu6[mWgtCw$OC_M9op|:<y<+'rEb\'Dt@$I $H	 @ Hdlw]ux4m|<Y$'_u{Si=]$c=Bz1dN'NgfI8I0Y  ! $	@$	"$	Go;)be0/,Ot4z3=	F1;n9;"Xw H|mkl$5l6Bd0m=6;(vSnA{*I!=4vHbQEp$<YScm4mM6$H	 @$IFI $?e5>p/eG@ []Vc  `E"* [)l@Q"Ikl5"TP%%[cl4 PR"	
3:        ^ k      >}v3HkM1N     kw>8       { r5<	RMb$   T 0 	=TH*~2  I4=M cP5I<@6JJBDL`0i6Z5Y60iHZBT,B%Lf3L"i%S+3ihm1Zi6fF 4bF6`LhX4f4cQFa4b6-4m3h1A1(kh!MF5f,J1jCFf5D&k!DM5cQD-)%iDHI$h$M$4IM$4IM$$Ii$I2$dI"	"HI I2i&I2i&I2$&$bM&$I HM$li$m4IM4$LI4M$Hi!4mig3<(RTB
3Sm[R*R(PBkB2bicSd[Ul&QFhTV6hlm[B2kmFE!-)!!$H$lH$	ii6 $L6H$	D"hF43H4$H2A&KVYM666666lX65f4B$[djSjbXlV[lm!X-ijlj5Em"K5bQmZ4IbI-R$LIII4$I4"dMMC$$DDi0$l"HiaX4Xbb44M4m,Xik6PB-"6Z6
++6VHkj5m!YL"DliF6"4D$#H4#"H I i i3D"EI%UXcQ)
M*0l&"i!KF-60jJ[F-TdDM5"Xkh#i4dI&D $LM$I3i46$H1&"DIM$+6`4E43VJZXmi"X!5PXId$$D"H4I"Ll[V[6+f"j[6lU6LfR0f l$53b%bdMjIYYVdd	3ZfjMbcmlIeS23![mR+2R36[[$Z-V1R6*[)--mQZ0VbM$4I-J[UR)F%bdlic4+a6h0%}Z2mLPh*(i3U*Jmi+PX,i i@$M6ddV2V%%%eiPUWMfZ`\1t\8bZ+H6[yl%(I&!y2%mB$o%mL$l%(I&,7*(mX1Mh,Ui,ZI%)61b)$JJh(hIR[p
V$1AgUlb!DISj
5&+ea-T)BI6!$VMmZ0`CjK$IdIVd@V(i4l7-JjRY)$J$ML$mrS*FQZ hhm2J,YlEIhv,[e
(VF$gej*M%IlY@6(ei&"$"[TUHU*HtcX*Y%[%6I+nMIp2l%U,IS$n#D*KI("In6nM+&fp*f5%TX-1&*jdA2M"&&I$51l56$PfnU\* cnXV-R.L1.!r;!e
e1o93(+fXSdSjVI\IF 8p3NUXP%pFeYMM4mQmx-IjReMbce4jIY(2)dI+ '*f@B-#,&(Km!6Mh5R2Ml6UR%JX%h6"4&MVjifDI)&%FI&#m%[lLZ4c`S$Kd0X6,YZKYAY$Q+$&V-U0JD)dW#"<V!#ghDVdn	dBDQ$DIfX26L$Ids$\	I8A<rQ2 [mE(JeBFHHE&b)FT(K I&XjbCHSH$H$I(a2Y"%PM$"BHDe("M#DF9e6Ld E2m[V0G(MCqD#AauimZirH*1F*K$%] 2I*-v@Kjel6d$6j)j)$$i	f3Vl3"R1l6,Ijj	3I$Id356I(G1r+BQ.m-Zl	``5(jRH$I&D3HIi$H2E2be*SmAcb61f%Yik`%$KX
bf$$YX"4Th
6(R&V[Y5$lcKI)SlJT	B@$^L1)d%Ifc$I*T	mnIeF lcmB0FcZ#BHIHi6dHIHi$
I$J"ZI$#"!M%	!hFeSUA*-)B[mI$bI36	aF+KbEQhlL$2 &IdI$HR)IQVlX2&( DlJQ$i$H4M
RY)5VeI4$FSm3V-;b(PY#FLFh&kM21c-mHm63h-CBm%iId$$$$$i	I#LDId&	hiH!4H4$"Bh IdCDlbBFZEFm6bA#$2b$Hd$$Ja,S2[j0+Q&JcDVqii$$YK
Q#RHbl"`6iM,XdFDm0cFE-I#!	B2"fIIfm[*1+sV6c5iU&MM&Id#"M?]mE@ <BKUc3vUhX+2Mb,554VMb3DVbiMeL4ee
2[HTiQ&jF4h1j54hFFXRlYIch666UblVe6*-Mmf[cbT&2PFTbmEIXj1KHmlkRmL%m+m1J
je,Z+mlX[kmUj1c1bc1c1c11c1cc1c(1c1Qc1c1c1F1c1b1c1F1c1bc1c1c11c1cc1c(1c1Qc1c1c1F1c1bcc1c1V1c1cc1c1cQc1c1c1Qc1c1c1F1c1bc1c1c11c1cc1c(1c1Zc1c(1c1Qc1c1c1F1c1c1c1c1c1c1c1c1c1c1%[	VUl%[	VUl%[c1c1c1c1c1c1c1c1c%[	VUl%[c1c1c1c1c1c%[	VUl%[	VU1c1c1c1c1c1bUkBU"81c1c1c1c1c1c1c1c1Q*Ja*Ja*c1c1c1c1c1c1c1c1c1*JmRT o1Z1[jbP
-5a(mUpcJ[eF% F% Yfc	@+lQc	@+lQc	@+lQc	@+lQc	CswJP(XP(B6P$b6PlbIBJPm4I0U0pWlJ[eF% -lJZv[kP
-6WlJ[d0KUiBP
F% ZB0K}$o{uM!( !	@/mN% :;iwi6!	@+! wiA[a(O>'@BJP6]vHd`0$  q uwc	@+lQc	@+lv[kP
-5](m5](m0pWlJ[eWlJ[d#XVjXVjXVjXVjX_U@                                F B H  P P    6  @ A `   	   i   4B    F   0h[    mh     \  @    (  ""!A@P@@  P  @    Xb   $	 0  	  3    @@ @@)   H k3 
l   , 	@,Xbmh                      >( K PB 
   `mm          I@$	@$	@$	 @  $
h Zm   )`   H 	        V       U1PuV*^9]s5$~UUUUUUUUUUUUUU}et^|I{Kl./t9wk%^=^z>+/}Vy*7io5gkV<g#qEyc\1cz
dDEkysq"y8OF`f:xjH9YJ{{I$IUVEVOY/{Y;NS*Sh=m$I$	/ 	 	 B!
i]uF5DtoOoqwCC!4"D n0Ow>\x@|$*I={I:}k{ROG|zh^/[mg}G]}=JsJ&JW9w@p8p@87{BI#M]/tdQlsgy8<{V\9r.1csq0 g9\98Nwv'81np9py\{m]ngFtaNEh@RWD
W+ J\U*HYUUUUUUdUdzu$IHK))j11=t$	t-I$9      7\\|MN,h!dL2$LV@i$cI C9xRO{IuI$q~>o^G}km$ KjJi/$ F5SWI2t Jpx3 J0x0$ @oo6<;$`C7gH}T'$H^7n\m$/y(^i'I$IUUUUI'dim<6m\H[[f$6[m$I$=  yd>-h
0P!r_
I4<B>I$UUUUUUUUUUUUUUUUUUUUUUUUUUUUUWllt{RT	4nvm4U$-@7AI%RLIBHT	4nvmc+%.,(  @ @DA.%wHK}!+A	KaDI$,0!3x(^I5&ml*UaUUUUUU[$
6w%w$%s&$#DFI"$I{{{UUUUUUUUUUUUgdeZaUlaML4 oso%mIAIvKvI=BjmBqoI$I$I$I$e%6kE8$II'>wwH^aqp@CA A~om8MMwt$II/w08tt-"JI,[a ARx,JlI$v%$&n$(IF`n$(IQID$(;t-$I+mJ9;Q-I.II-_&c( A $IpSmn n$wv%q[mQJ3-I+mJ9$Frw$Q$0Qnv6[mI$VFrw$24%^$I#J9;I(d(;t-$I+mJ9;QmIv"JIIb0A wasPrh(I$]Hwd8ksAxVFrw$24I$iG'rI%Lne^$I%miG'rJ3-I+mJ9;QmI[mQ$4$&IQnv6[mI$VFrw$0[sAxVFN-i#m>Sn$I#m'Xbbd&0l<nI8.Inwv%$3IrLa Al6nOI$ t)!Mmu;uz=mAI0LaNa9$bxAd;mzLDN&+H6I0a@A
Api=$lO &$v7ZAIi[;aAIpbh 0azzI AFv$ x>E=Zlo-x).sf~gOW^;6{)III% 	 %(p  
'"C0mx	%hqNwq JBRNwq !
@%!P%lP%!P
)BP	HBJB)B\!
@%!P>[N[NWXc[Q___>s)P}AI
II'( !1:20!UU@<6|@$I $H	 @$I$@$.\=
RIi[ITQJFdT8IT}RT"`5+RC;[cmFFmp#Y<|^]dW bL>D N2|MUTgSd_Yx.=.!J@)BP(bP)BP(bP
@^HB^@P
^)B)BP
HBP
BRtUzaR*+%!RS2ULUN*")X@@X
JW.A&b	XRRUW8<twJtHtwJyP(>	*IB|QD@c;-Ug 7{$H	 @$@$C	!	!so}~W{C.,/[D%,mf|#^dROyNUM},Fz1zYHOOO^6Er{PBB%#e
$JP989}~o>CK7F+V;`dMyy;;z$>K0jI;/dUU6E!BIHOOO^6E!	@(!J{lJ{!J{lJ@(bP)BP(bP
@K%!P6!J !  !J@)BP$YI{L- }; p~[0M>Pdx
aB1gN!FUUP^ ]mi$H	 @$I I$I[W"""""""H""""""$"""""""H""""""$VDDDDDDIDDDDDDD$DDDDDDJ"""""""H""""""$"""""""HYDDDDDDDDDQDDDDDDDR""""""$"""""""H""""""$"""""""H""""""%Z$DDDDDDIDDDDDDD$DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDJ""""""""""""""""""""""""""""""""""$V~~~z;|AKI 8Re3Fr|>$Y x`| @IcJ9$F/F3OK)	>]({{M4ki11(B6P1(B6\1q'JP8ru[Rf}N]jP;mzz7.Mkw;y!x/Dd<&" o%I;/dUU6E!i%!===x%{HBP
B

B
P6RP6% JBmBR% BI-/^w^vyww~9s9bHbH      9q H H"	 C	!HHa$HX $Hd0$Z	!-m$;wEE[ZmkdkdkmH	 @$I $HX $0l@$K)!,"[<_{mUUU6EUSdUU6EUSdW                    zsuM rnKzRH	*},
 &!gwsAUTwtwwN@$	@ @$|jh!NXtIl"M>
 @Q c<UXaWl+]@$I $H	 B @$I loNs;T9&gt}kb}2!4a/s;VaC /egM4@$IZ	 i!`i@9rsj$;Y;/"Iz%
(c<UYU{I $H	 @$I $H{=)- M/ 
=\    0?P*W  *5aFDQ@ i,      F'K$X 4  O}o"}zp`P@T {UU=' DL& RRcC 
hP~rgG:r5k+OnNrgGJW#\k+N+:;BEm$PBE	gGJt$PBEi"(Y(H%6&*(eSPE+ 4msW4msWrF5sKgX+gX+gX+gE\\l]l]l]l]l]l]l]\sE,]566-sFell]]]Jl[6h6h5mEX5j5V6lUV* bjjjjj"bTU*ae,MML,hkDK4Z-YM"FJZQQbhV(mITX*,AF6*,A5Fh4[EElb6 "ZlPVee7-Z-E;e
e2LV
]q5
eN!L%[i%"m$lMFl%dll+e#i6(FYUmkIn;j:D't]]vTlj5t]rr.\rYbkTngt]NcMQET[&LJl[4Z4kIdJ$LCI&K((fEUlZHmF-USKh(bHjkJ$[I`Hi666-(bXbfJDkhEB3VeMI
PS!$d3$EY5Idl-lLI- Kldm2e5YXV(lSe6V2bX+e`V(lefJ"jem2+2FQJDVmQe5"-1M2QFSj,LQMS
(mE6mSeglRmqm04cXPJJ{jx]$j(Q4I$)M$Nl[u50(FIDI'*1asbmVn6kJBZgB6rVYU3"T{TD.SO&&JU4,`lf`e2H6Si&>qCqr2FIa	$i-ZZWh,Z*KETVJ 1 ^;vZ6a6833m[
T
w6[[wWe+TY"Q#(j6fqe<4gSB( $Mhl[[bQ1b5PV][1FFb6,)6CJojWmmF1QQh"nbP `6VmSTn0bac!0bmEYj6Q*cj-)HE9><\	ldb(;6Uxy*sVKlk]MMXopppltkVU-(jmj                                                     Ij@    Jlj    I&am
     $k5X&0[,!dJ$MU3AmL!4,EUaVZ0DD`DDA""0b"# #b""`1D`DDA0F"""1``DDA""0bA0DD`#DFA0DD``DDA""0b""""0F""""#`""""#/1c7]v1c1cwc1cu1c1v1c1cwc1cu1c1v1c1cwc1cD""""""""""]c1cu1c1]c1cu1c1]c1cc1c7q1;1c11c1nF""1`#DFA1c1nc1c;1c1D H H H/wu62'2'Fa8a8a8a8a:0fl0jZ06UkFha:036ff1c1c1c1c1c1c1c1}/<*Kme P\2H
Z[HB,%ve6[HB-]u[xc1c1c1c1c1cc1c1g--!@KiY# JY# Jm7c1c1c1c1c1c1sffDD n%GBi$#G,<[z1c1c1c1c1c1c1=G)i$![HB,-r8	yBgSked    [kKkmbmj7$;l$i-9&@zhk}{D i$9Hu	Yj#BiC}l8m >F}l{kEnUUU70{'gXfF(HA{{>zm   mb)mbmZ-V{wm#Mk+k
YmnkYF Zb~ $H$]$R c9I$q>^/Id-6"\_?]MUw^ Q_x6xH`>Cmml.d<L@=`!4>AC#@  H&Kp5N!v};K][u!n-   j!b-VXmnI
vH}uKu6Tr<vCl}Y#uCFJQl)$	63(aKL0k8m^cmtY&LHgxz#E+?yk[  /_>{0I]$D{}Z1FmFi$ mamEWL!0@MA1M`6H\x5r p8 i%cmSEYmnkYFm%cmSnmdmmmdnkYKk j.m6d%v9_mCOUnY >6UHKp	CSi'x9(x cjy	,rG}"@w?m0H!!6	mHit7nBCOEE$UtPkNR@ /." *I!lK1TCdc\$-Cdm'^E$UdP\6RCOEkE$4ApYI$L]66Hmdm$3]tI"ZmI$6Mf5H2I$6MbuREWjkE$UvfI /.tYwdCdc\$,RI[i$LN0%I"fDuk#i$FIe6$fuhJ\6gV$YMI+ %p,kn[		VX$ 	$. i1QA*c[d$L$Pz j)9$JVrRjH)I"V@j ema2A*d$`7^{ ? 2Ad?<[Skz]EyyE;9W]h,2~n_  $	A H/oyC>`mw;#SmzF 	@	bI	$[
6b1dL3lLfF6})"*HGDDDDEb+%cH%a-k
%Se&EYFbLb-Kh2URV	(mtp#:2[D$Ha,&l
f+U9A'JATjQU-RZRZRYA&PI b$@| m?_gzo[:}k|3mx+P {20{<6@$ 	@ H@RJTJMUUUiKEBBSAND`H2PP 'z6Hl&6mf33 C"f46i6 1f40bbmf&	di"-4i6lYKKcMlmHmLPPVjQm6llD
E{vjX6;$zILl1 KHE	E %i]|mP<xF'{b ;[}}xBmtCt3Da$1{jsi$I8aI$`8a8aI$I!I$`;	|X0bM"N	ww{0Hl(Bzy4mpm<y*6#mmjZ2Z2ZL*3 37 /@ fs>6f#1p``}};jM":<p 9~^[`o~^z}zbyuW$$nShI$0633h$KRIjd36fgdZ0vuoX ml{O~yh#SrKX y=u=h[iyN;C=h	&`8aI!I$I$`8aI!	@$	@$	A L	h% L	`L 	b`  - H H &3&m
wumD`Hm8mI$Imi$nX	pkb3m%\uk1s:bcm $	 A L	~5e.hJ1.i5{k$6I5vK;wm]KhAwzci1k7&_            mom(7:@V|fb3Mu}wwZyy@$	A H  @e5fD G  S   F FXTXRQ,+L P     AYh}4{   l|'[t$^8H	!%* h%H *{Td 'J)i
IISC *4rgG:r5k+OnNrgGJ+:rgG:]t+:f;BEm$PBE	gGJ+:/3E	$PLHu{BEm%IFvzi(5E
(QB2m6&+^xkks< \\\\g+jjjjjs< \\9 cs6Wt <kW4ZWMp\\\\j4^ yUUh[SjmmMFmcieZ+I66f6`[+6j bjlU&Q`Q`
V*6 m&kEZC)jmk&Qj,Z,lXlMF6TXYMbmCi*6Qbhi0S+S)e2KN!LQ*e2N&lRSRl[lYMPQeFRUF(j0Y,eSi2lS
ld,bYVjGh25FQgt]Dmm*6qS4JUlIl-S0fE-53Y)cETlVhhQdFSemFSe
AMEP2 25TEY(+2Z5V1JXd(E3VDDeefIXQZ+Eh)j1jF)cL-----EEeDQjPlhJ6y$@jV4hmmiCVRvzJ,jm2FtI'gh@9mM)VC\hjSVhSs5Ujf9)kdhFwm+YQLA\le6)$)LSHH}&IXjbB-hT&*Fc@ 5FE e2+6o[QTx6fqj"^j-TZ,YmUNaYRd0MEfZ-hk]JdX'V)eLXH+*=a^l4bEmmaJZVs-EQ,mbTbc-"	P$H33.X'G\f.0,]\F1ci-%XV+iYM1+j6                                                                  ?@  $@3
0 (PjVJoI3M#C+lm* CBB  mjkj0`DD"# ""0bDA"" 1`1`1D`DD"# #b"" #F`"10DD`#DFA0`DD1`"#DF"""1DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDF_1c1cwc1cc1c7]v1c1cwc1cc1c7q1c1v1c1cwc1c0DD``DDD#b""e1c1v1c1cuc1c7]v1c1cwc1cc1c7\v11c11c1nc1c1c1c;1c1""1.1c1nc1c!(B6PlfiF!)`#eF.c1c1c1c1c1c1c1c1c}.Kw%o{;{pmr\6No=1c1c1c1c1c1c1c1c1N8mr\6N{U]u[yc76sny<a(B6Smbk[mB3Uq'c1	@]uWp$	?]wuupHfh#e6!)1	%I(BIBJWsnf1c1cw%o^;]u[wyu'Uq Ic1c1c=]u[w	{'J1?D0D `  `$0] `$DBI%mbqy	gHy	x!-=dzns/{*-fV<z)$	/x?rM   #h4Me/f=^NYHmI|J}{00D `$$+DCN yf${Ieo3>M>Kd]d]d]d]dkW@$E}dvl%KzZJ7UV</LBEy`<I$RI.$mdOx<`G$  9&@*MP4/)XiFl);umwe!]J5KfFWlHui*-T>t.`$f$F`,HKw_t; @"0I "DD ,={,bW#%eH/ !Z x$||[r~]wm}|:||a@8dRI.$mf)&a@M9&  4Rl>@Zu(   I(I@Z==>PCM3\w._d\m\m\m\m5D@"P]dx{=7wqEI{kgKKKKI$\k]klklklklklj$06b.!M1BX8A.Qlc(r8\Al$dN ^0 ^7"hMS4Omz4Om.in '%^) =Wh@{sy$x)Wh4^RR/;>I%[4Om)'{}qMiMis-\gidWsZb~=EqSx)Wh^
wN}$U <x '%kl D w>I*M9WhJSE%"Sw>I%[1l3.?kL["Ogm5B%n)zI[h'%^)BAos$xC<xC<xBBZI!<IWiOJi	>y*X-'	rOJiN\4Ai<x/>~+m>8A,IuSX$LLK5`"8qH,U!JAC1YKF1f!
6fffffff!
6Bm
6Bl(Q;617tK(Q$ib&FnI4M$J@             6"UU2FV,%Fj(flIuph"*H4ucJbXKj2K	4,K5Xla[SilJ61h+eKRjVJERR@Vb[Vd$Z-Im0Qm"s'.\)H\	'AIU1$j(KQ!j$,	?y,@b1fiH\N)/>[n23 YqM<fJQ)@	ZmlB#eF!(B6Pl_+BEI/T,"bE*\JP vR$R)~SkmQlcTcjY$YJiP'BSG1)ITabX0T`T"X&	L4!"3I,MQRQaM%
D*}y~}zj(1%kfbfb7d9&iH                mkk5mW" #"^@c^?O|   	X)LI)
Z     @      m_~Ms Kxz3{g.n
#P
PlJV @(iJqM[7JRwx;kB#e5X!5DIN%sIDDDHl|uN\EJcm,[$I&iH         @      kjo/Hbok!{g.M"}_mhED`1RCnaJBZa$ 0 lIFffff`$ff`]wu]_W #}un #w}-vu&%  iJ@b.qN-vubLmL)HRmXc%@        $       kj             5l @$Hh$	 @ $oI{gubVGl%c1bIMI$ha	4              YThZ$	bnK&nIi5D$,
[%cXmId"HD              \Xn9UTbJbPdI$j%}ko	 5@#MI`ZYL6	E$MQ	4K31AY&SY^pi {p  0  `2{ (PEWd45 	P     B|"6v   b}-H
s N|0'pp$$OR4 	I*S@RQ $IH)  &BQQR@}5MMmWd]vy{+W\F\rr:jNjkni\5r5!f68N;'L1w'LTTTlkr5FOZ%%%lnkFDh4QQE@QW6jU9]5nt u\ +^xkks< \\\g+jjhLdfdd`             E^ ykkh`*Q-lHmF1,m6X-,JRce*-kiE"V6JY*hXQ`
m  EDQ`6FeaL1ViFhh  DA cV,beE,XXh,kQmQMhZKI6-Z4m3QQ;-J5bt[N;-nrp#\wjYn1455dIMkfSMMIi4i4miIKJ%KI1ba11)h41[DbR[L%4fE%6IIRd2dhRS"*ImjY*(b%FI-ie0fRm1ei[kdhM)(,RYM6Z+QbhllQE(eMf6(F)KQF4)Kj*6Kd6^llll()AiObjZMI$-$Qf
cTTdDI*&.,2+jhlKD&*hlC$1'blMYvM46[-)rwmfD9(mK1uY34un+;`6TI|	4+F52iQQEVF1Q6k(dvkZ[m423
 66+i$y|`"z9g#9g# eqc%cSJnQJ5X5 1@4VaLPymm*\oncIFPl)xxlF6	mh-[mMlkelbffKWjva.6Xfj6Sem,W[xXMi4(-2m62qKliXFv;SQ*\E*]ibdeSllmEh*5-(,k3DVmWcbQe+]sFFbXcXQcFb5Fkb,XTQFhF""dRf3cg90	\(jmffj65h7VR`[)m	l:/'e[Uxrq9XfpULGY7yGr6ft#R
'mm6mLlK%#m[+fTm                                 5@   K@ 	+B    M  5@   3	55  [lS6PdifY0dm*i@ ULSlmw#DFA0FDFDD""1D`DDDA"""1`10DD`#DFA0FDD"# 0FDDA0F"""0FDD"""""""""0F"""""1c11c1nc1cDDDDDDDDDDDDDDDDDDDDDDDDDD1c1c1c1c1""""#`""""0`""""#.1c1nc1c;1c1c1cc1c;1c1c1cc1cDbDDDDDDDDDDDDDDDDDDDDDDDDDD1c1c1c1c1c1nc1c1c1c1c1c1c1c1n H=kJkN6iu[yuU1c1c1c1c1c1c7%rmk{F{F$FI+!(B6PlXX$wuu|c1c1c1c1c1c1c1c=n2 F2 FPVH@lRH
[k[I@KYY# KZI	Mim1c1c1c1c1c1cipi@%e P\2B(	[I!@#mpi@%m$!HBI[mI+mw]u	@$k[mI+!+V!(B6PlB	%b	%I+]_m	$I*EaWB-em;w`A1!{6!>I*I[i>26zEi|1(6\=}m[m#|RTmTut$OPGzgYuj&\lx"I$t"]I/.}} knUa3[O{yJxCeQ?LA}$d}eXm[:\3}7m{tKJ|.me<!{hD0" }~byE ^ 7!{Od~ 
]I$C*jVl_gwzI$UYvZcRwd:n?"Cw0M8C(G%=a0as$eeXm[:\6T\I!#%NQ&lcg6eL%1mmxB;jL`m{-u8@(]w /9{umG#o5;jMFPlf{ knUaVADme^6{wOD_[;]`D05mm  F??$^^sU 5l*knUl* t5l*knF6okqmMYWK{f6L>Jdcr]dL__Lw[B! .iZpN'3v*m_;z"#nN+
tFR)Z)I%} _
i$9+mwz;=zfd'p OI%ZKCw-Q;r$6{u8nu#m]CnP6BvDmwzN KQ-wv%XDKz{\$%{lmEA[l; zI/%mmG{vG{vG{vF6K>6tUCKlCh\ChIwv /4uJ.|eIg^XD|$:{,I'Tbv).%&M$R]q7Z%SuI%! )o_DB?}~tYm&}B@(4;wwngt	1}_>@ 0$	@%V;}Wvsw7{51mc $/$laV3IdVU-[O8hH".v5"aNslf5iZ`&k,+dUZZSaQTQhU)[64em4-m*k*l%6D[ CZb.+EhfY] aSrfv9)6k`1Vu\nr%'Z%4,4( t9IU8JDz	R*)VIJQmAzTjn^D"m!fKtoDhM iue,Ik&kY&.Y[@8@$ 	@	@U$ *U_B%L,
JIXHbCL%%S*(Ie
IKO[6l%jRT6DX+D{	T^)TbcP**X*$<.*FA)2EFbKh&VYZZ,0'$5SY5*D1M),&mU*9*rf^ {[\ml&JW5D	!c`6F[-OgU4w}i66i[Dt:N)Ik!B#|!TpB 9B6PlL 8B6P7!/VOG@QYJ`:m6AVf& VG]efn $	  @s	A KkWk|m~/6@iswZmfIG`"BI/ /1&{k0dp\3@qbcH^e],Y7QQQQQP$DD	_VEF+^{=<]|Gic`6h=;Dm3Z?b"8o!(B6P3333F!)B6PF]mm$	@$	`H&A I& H,	h@$	@$	`H/=W=k`:nmnng:uGm 6"6[mFcM$H $	 A HMVj+vA[z%k$IlKvj\kp-mI6]{^%FK$@&6A K_Vn[;vM{>In4KvjcmlH @&  H(+$k5 En   T+bdbE$A%QJr`,(BZ}    /3@ =|VdDT%
na t w\mCLe*TL   zEU  $QOUhhh4	=R)   I)*hP MIIPzP  }>XH}(D,"QVwWldLH)u5aslBBE	IcYgGHi"DG,V:"p[]5jV7"K	VtW$.:  jy+\\ :::<\ kk:f: x\\:+glPl*&1lK	b,Im#K0bkQdLRJVl2f#j6!)TMhZ-Qh
]q
e3V:SV(mjef4b:i5+EX4U)+Pj,e	%YhPLUvwE9j5dhR
hTQ
VttYj:D5nV:::X+2tJ5bGM&dRRnV6c\IAY"DY[9rel`:"  mj1&h0S(j
d4V5-Q!65mlmHD&$,I[M#QJfELjC`--XXXEdJM-IC-(m`Z[	LI- ILcML5f(P,-ej2Yebj6ccXm*6l6+FQ&XJDQVm,SelM+65DmZ()5VQC7mJpmX6xl[mUEcUmUb&)[1J^mlniH:JM1eH)L&l&uZ[Qd)$BcRRTcp-TiblmV
mG[iJ-jE1UFQc$2!,%3VAh[6m
=BLi	
eB[6Yl&II;feV4Dv,6LmX6-XMhkZ-61`,cIVZ`e c kmwkvlY^ieUO5[Uxr*O4a%5Kl[fTf0y7"<qFhg&CaUC6
;u.5+=%&[(j+ED[u*Sh$) 0[muj&T)nY*[ju66ajX+)&TIF-&AE*1"!b)i2bI"A$$IDR<7sm3][fim\mX5`FjFUk-ZADmUy<.\j#aUbmGul[fl9yIIIr5J&hlbTi1&I#DBDy$?>n[-[f     m[n    WKf\m  fmc[R	5t$mRM#gmVndkm$C;lhrnU    *b!#hmf5+p32T    ommB"""""""""""""0F0D""""0DDb" ~1c1bc1c1c111cc1c(1c1Qc1c1c1kQc1c1c1F1c1bc1c1c1c1cc1c7q1c1]c1c1cc7q1c1Av1c1cuc1c71c1c1c1c1c1c1c1c1%[	VU%[	VUl1c1c1c1c1c1c1c1c1cl%[	VUmc1c1go$Gmy9+o;y^|s$"<HEHE1s$"<HE=1c1cx.[yw$I^{s@$	@$	@$	@$sG;K	.$	.$	@$	Gj79D-Qlm4"MmXm4"EbhE6m[cihEH H H H>v=|}|ji@                    
    ^/Cl    }Ws     U,pW*|.Kt dm-64 2 @# I$'IFb`3!&C_>|c}y|} ml~_;!I{lcn_tvP 6moRO%{m=};;p;0,<I;0ka$3qKp 7wF"	27(,Ab z/P 	_$M4 pgI$T?n\QKlcd%$wp}/=-6L<I=}q>y-ve\z\2QX6gou*	$]V$RI!4$I#rs!%x!|= cm$f7t. wtmmJK1#';0r||qJ89pys;^'7B$Q2yNa 7o>`v pe@I$I$T`lGBs<@i%hi$583 i%\;( mm6 0h%I<)${I$l%)4[[g5]x<dt< / 	n#Lm^jxEh 
[mI2I$IrmN$VNn wtvPn wtfnV	0N:T+b${m,i"IJG$&d0HVD{$$Pii;( mLj]s64:d=P#AA-0{n	uwwu=[^fIa,Q-&wI{{js7w fff
_[lb{z[*-YI-da,QD$=$0@;$0@;o6o6wU5[^viUffd;333WssM{jv1`*Aj!3*v^q`v33 q q*n^HawoiHawowwPz"f"zZmtQkV5wxZu6lMvW.D$,w^gCwRXxIzKXO
({wvQz]fPMI;)%EJPM&QE)vtmhp[mn\I9UUY4ug	3wxT8B6-!9#0I4a4NQ/nJ-]*5	fV-KR,R5	jj%Kz4Hq S=zcI&U!32&a03jHR%_2*LA,,Jm~n@i26Vm&1[FKL\XMF-6KvUJ()HROBB"Q,
,,-*Q1V*}.I\i%pvu\4]mW_77Kw}6i?m UF*t- [4M7	P+*	P	+*PPPP UR	TrRe Y"+$*,ER,D"J$@UUZT*B"Ec5+*d@_O)OB`1VQ)<$65E15*3UbfXh6*	fefYmS3aPQis,&TfxRX&m%%c)5Y-bbc0LMR
1m
Ou4r8@?nO7B!$ ~~"a2&[k[k[k_E?OoKj{[+.(br\:[s]-[-@$ 	@  $	 G/-z%-t/Z#{#; UU[@"iEHEHEHEYUHEHEefVUI*U!jfffFhP
a|78v|*QEMZ*x %kko""""""$" """"""$"""""""HjDDDDDDD$DDDDDDIDDDDDDDZDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDj}g|dP`~H8# \oVkuc^8:={im _yIbXoaqB@$	 @$ D$DR+0~(~a:\@Asbr'.9p7{-_M6n{+;ETETET@ $	  @ $}Umo~?_9rVdL3"dL3aC6r#HiPxwn];@     Fm?4"dL2&D"dL6Z~MJS6TlUs<BAv'C#^m%JU|RJIP|}nfa0037@N	1e zwu1V%BH!  $z?F7{uxww"A/{>)bIo 
=\    0lJYXFf       >z8wpgP  }G>(    >0S	4 T$  	=R5( RTP6=@5%E<UtYgGJVz9==gGJuO{9YgGJgGJ+:nfYtll:v{+::VttrFE6jjjcc3vVXk^< hhjcccc66jvjv]KGi<^t;`4msW4msW4msWi;F*yV[BR*+i-iRUU$Z-EES)5.82fGQRSS)f6jef5lj:i5+EX5Z*XIFP(1:`Vm+XUTheUfH6IImE+im#cV+w)LQFQ3.ZwEQTc-6nhS
Bl6jm)vmMrhe%*mE6mUM&kUMrhZ\:i55cnVm&Ke-mAfC5fE3B6TeQkk5,[Vf1Jf+5%vVEETh-ljm
i6*llcb[EFhhlj,V(0V[c(
X6[Hm-m+FcbcX5K#Qm0EFj-k2EY(+2+2+5[fZj50e6RTV+YbB
l(ZYFQe(l[emZ(2(jj-1L
j-1EXZ6o5F-,61e61jF61bkQlQlQlQj(2EE)[[[["(m)l>JD,d!FGCnZR$(*K%$KC	+e[Q<)z6XkU]L +2m&lI|8DL+44,Dh%Wel-mcED ^Q((,r	(y.QVRIUWR8q1<E4MAA1XcV j1WZ[5MQ5jjcV+e"Zz)ajl9UFfBYVS(d-*KV"Ej+P5l[$iL%46[U(jVmc1c1c11c1ck1c11c1cc1c"(1Q1Zc1c(1c1Qc1c1c1F1c1bc1c1c11c1cc1c-j1c1cc1c(1c1Qc1c1c1c1c1c1c1c1c1cJac1c1Qc1c1c1c1*Ja*c1c1c1c1c1c1c1c1c(l%[	VUl%[	VUl1c1c1c1c1c1c1c1c1cl%[	VUmi@$@$@$	GUkxoSa$$)6YmuI%Iv sKMA%o{Mw;wSao{ ZVql5ZA$1MZ)dCb1MSa{o{mSa)o wd	!l06b1Mv|{MsK	.MsK	.:$o{ sKuIwnl7{vvNob[+5bV+l                                                                                >><`fh  fVa3hMUT 
6%([YkY5J4 4	J.w i H8 h8 i H8v{fg~5bWkV_9.BO&>OsK&	2d? u^   os}}]__ohK^)^ml-xZnhhmxZ&f@y,K=Ymv pA$ I 4 A 4 pA$ I 5s={;w=mMz22dd<<-^wvBM8i!fE@t!>B%	$K&7v _
   ,t  u^   ncoM4kJv3{Y~ h8 i$ i  h8 i$[ZHmri#ri#vHI$ ZHZHZHZHZH+: I 4{}Ii4RM$I<	$YO {}  ^i!hm6mZHZH*4$z@IIIIIImnR-$nR-$n i$IIIIIg@I gfLo7<5,}_$d rMyd|   XbZHmri#ri#vHI$ ZHZHZHZHZH+: I 4f}Z{&1C{{  B]YkOeZe<NYkO5Svc3U:i8TAM5SsXN|3S,S-inlt^aa,@w^XZHnRIJYi#})K-$ouY56N[ybS63U:iShTAKT%}yiL!OTAM5SsXN|3w^P,72FwwfRZHn$ne7G 7=R72[OFjZ-A<HfuqQ{{f<C{Gh=shGh=`wv6h4Tfu y1TjZ>=feYYZ>o_W|Iap	<RD) 2X)3 E$E$cHHH"#f@0.xJKGtvntjwGd}(RjIP0U+eeMd dqJQXe3H=|xG}RDDvdd%()J:[$$	@ $	  @,l_>SR0U(`U,WIHU}'+Vbcl-$)qKDJ0,Bh0ZRbp8*RF%1QAM*T0RO*>2>>|[$0+ tH 3KU_k[ 3pH<&  <m   i|"+)J["R)J"""JRm^)J[$I$I$I$I$I$K I$I$I$I$I$I#9skUx#lhb5{QEbXfxM=;RYQe"  H    H kUjV\6~})Jcr@$	$	$	@""""""$"""""""kYDDDDDDD"""""""UDDDDDDD$DDDDDDIDDDDDDD$DDDDDDIH""""""$"""""""H""""""""""$""""""""""""""""""""""""""""""""""""""""""%j'o[k=1d&gq;RwaL=|xG}RDDvddvc-/al06bI$1MSaI$I$)dI#j jy d# Fx  q"JRbJRR-ofDDDWJR{I$I$I$I$I$I$	$I$I$I$I$I$I$I/mm                F                                j5E[?=mqnnwr+fYM2M33wda)--.t{W                bI IkUnfWUfY$&&$mjGNWU^             -5rn{XF:'HxP                (+$k+Hutn      kB)
P*AYL-%M,+1@    Tv)  J}<'8p =sd#   fdlD@4h%2dT	OTS)4&&SMIJ&@ >o\Yg+::Vt{w:v{rgG:r5k+OnNrgGJcLz6Q^+=+;{;=W#\F\rZnR*LVQkW 669%xkkvW <hjjk^< hh:::<vW <hhhh ZhU^[J\Y[:Y[:Y[:b'MBiRKjhC2f@f*dYbm%Z#4C1*%aYJs&wE't]]CQw)grq1*R+W#\FWX66FGXcSmX*(5B&cX(kF*QItkvE%5#s[c]a"%URtkGM&tk[j.:RRvCY[9tMp  :     5cMBjR0XcVJXKEj%J!$Y2ZZQ"M%ibZY HD&$"ZLSm#cTDEj-5j5Z!-"[il-(1&Id6(4L:bam&(6UsMbCjW0Skb-6)M50U5l2J*4[Fclj-cY***,FYl&[Q*6+EX6Z-X5EehMFEbbF6MYI&Dj+F
("bemEdYi2j-mmmVjmWccc1i--LQM(2mlaJmfLz(VPnB"#@MQI"-$PTkhUlVb*MmS60(ERI	kII&lx&:eMimHp##-3)BlS+jf&m[nfr1-QmAFm#4pDeec,*l98H#q*
 -Uz(5(b2cDEFVWsaB@P `-)Cs4H[m`zjKS[>-pMl4nF6Y4mVELSV2LbCd 4:-UQFJ5mE6EQ`M 46 h*#$(6fR5Ft]MF-0jVaz
mx3j[mRSlFj3P"hDg7nS9
L/A)1eKViE(TV,P`1s16emKd`2* JKTjk[kYQccb*+EEQ**TDH!DpssqSHd6d#$:561MtXVypy47<pemYMej1uJW41ci$aLFhhjaUFjeVik*i-m`VlFmSXljmmb5cm{Q  A;kk`mmc1cc1c(1c1Qc1c1c1F1c1cm1c11c1c1c11c1cc1c(1c1Qc1c1c1F1c1bc1c1c1Zc1c1c11c1cc1c(1c1c1cJ1c1c1c%[	VUl%[	V1c1cVU1c1c1c1c1c1c1c1c1Q*Ja*Ja*c1c1c1c1c1c1c1c1c1*JZP#eI(L3BJ{]3v]d!$	%I(BIBuJm%v###mm$uwHHVGU^{^yw=o{{fw%v8t6+m{ql6WlfuvJu6+mrW30wk[z!([k[B%I(BIBJPZmkm H H HkS~jlP[P                                       U    `         `  -ZUuM   i$Hf1fJal 4*FSAw^I I$W*uI$K{las<ww@K&7-o6www<{gG1 h3?T3S}|`/5o~$(bX	I$1?I$Tm|,],0owXHZ|&i-Y]~~MmR+vU=I$jI5G$*I${{[<@"H@"I$dh#SmI$f3 =&eer\y\.bA&aX0^!bY#s%Qn;y7sye{k\q#3]X#qoI6 0Ye$.g1!'=JII%|  Qkonw"XRuQg{;Ug$/Zb4hB@,'| `$ `$I^4W@BI$I [:Kv[@I!m(u$[lI^EdQ6m4w%N9$?evAgzC#nI$I$7_rI$/{RQ5$ ?Kz|~Iwv5qvWIh^P]dq7m5Y$"/IVb*VK;wt$&K3IW$K;G6yjp h!^8=II!$4$@ A{kln&$BPm[BR{H1'r]$~kzy{>k	$zI'Y/$]ovMi}]oe`2zfM/T3{I%6zzfNz'fb$rI$'fn
=rK6M8L> ?oM2K<qzm}qd}n\b>b58+fN8+H\IfNz&^_(8xI$&^zO\_$zi1tsZb#kL["}id|7Oo*+ADgA{yW^^ {cmQ4{}qN1u]keky-HEM]oq9{}n(Vp, o)8ib&~B@`feFR_h}&X1p;f2-J.QUUe&bn
IRHm)$!FBF3337$)$!I!
IRHX`5$@$fkHBDB`rI	|H  H Hm
Hx@RCIRb)YT;RO'ob4/V1!,I$X3{Y$ZYUl0]J xZel;4c6BJ3330!$Bffffh[HP$!$xUG%)
%2*XV))2T"b,UUF(8BR.H %)I;l[*ml[J3(+31&Dkk1)+a*KbaK%)S
eUL$&*(JY1e&aQ bXcXU)&e+mQ++Sd&hC&Xm
9$@$(E2qDdr8BI)@ $ 	  @ $J)Wa9;kt$$b@-uZTj.]p*m`*}ku H H   HmmmWo[h6hD`I%o=o`BFishk*ZaE)MjnTj;4c2J!$3333BJ&ffff%	m"2IBJ8?GbsA]B@R#HHMBII$!$ H  HVm$DDDDDDIDDDDDDD$DDDDDDMiDDDDDDDR""""""$"""""""H""""""$"""""""H""""""%Z$DDDDDDIDDDDDDD$DDDDDDDDDDDDDDDDDDDDDDDDDE$DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDKZ_oudX W50Z9J+Rc}}w$	@mmCd  Hwu]5j6)kv6(}{=e^cYWeZ+UZUZ+cY H    H [w$H 	    [!E ZB5k$	HUIPayw$n-I"=jd=W==             >5bUT`mDY6H!fS
 56*ajWLT`knD}@             lmUft`Hi5=ff\1, 1U[D*0V6H"lmA,$Sf3?
2_'o~   -
+hzMhb !Y1Z*lTdiga  R&X u6% R  R8n)Zl  778;'OaR   MHb4Oj%   )!A4 &F SR$&G"H"-c+&j4mQhj4mFmKj;>5k"kr5Y,vtrp#]D:[&kw+4W8hpHhX1!MF(JQ1&D;F5sF5yRx6wkp;5n;5n;%pgvVCZelR-w              a(mIm-m5F55[1([F1mZ-Fm!Q&aiD[FiYH4FS(SK4mDZ#UhFTXZ4kF D@A D V""-%DEmXj5m)hdb6$2LFbXfFc6Pc@$fSS1ZZmcEh0elVf\mH\KM65e26d$!K&"ei*"d$$HP`mXF3j&5fMdDV#k3)&he5mmXSSlXmXbQV[elX+U+dFH5[mYC)(2ZFS
)&9m)Fuf6fuQ,26mLI(96sR
mEm]6"J56&&R4%&M5A36g
2,f&	jmT[TVJyi5ZBKP%4XUm*4j,+X(NfKZTI-@!LZi]eb4QEQ+jX#mmL60Y,5e+lcXJUV24l4,XcF(RQl4hRlEdK#F5&Z6H,4hh#lEmHlX( 6	DMDH"BEfDBC@MefYVl5d[%j6h	[(x3Fa191qWDb*kCIvFi4M"I6o_yemwwsmIbY|`Ubr.VEg28F"6"BhAsZm$$ImtrSVQjNBCZEke[*Z1Yf6U=Km1c1F1c1bc1c1c11c1cc1c(1Q1c1c1c1UF1c1bc1c1c11c1cc1cVmHaa!Hf$02C$!HadI!nZHd!I$I2CI#c1c1c1c1c1c1c1cl%[	VUl%[	Zl1c1c1c1c1c1c1c1b!HmRTpaad!aaHaaaf5Mm[n$I$I$I$I$I$I$I$I$I$+m+vN];um;knwH56Mv"Gmm;v[sGUr@~.Kjk$YYMfI5$k$YMfHt$	@$	@$	JJ0M6.W'']u''8$s.9:$k%#ZwqkSmqkSN#Zwxk5II&Y$dk5II&Y$dk5II&Y$dk5IK^6U                   mP       mh     4L6YMiklQ       ZZh     %l+P            % *m    l^wR&bm	dIEZLf~|wtm\.bmy<xmy6MS(P    
bm{0=xmd$  \xff_~piw|ZQ$@{7w5oeo</&YI+mJ-M}Wh FiH)m%#&Z\-S  3\1TUqf`v(O3f hhbp     +mb7o\q|@eeY&$ 7w|    Ye==}>Fiv>8S4}$LC=Cm}T.ckO<ewwLK$<u-gu}H>fML^{ 7MZ>x;H  (v[{gP@AmZfd7	      :/M7md@    mvk3LUzmvfPwwuZvEc~`0jvz8whuv[{gRmoMuvKmoqouTRF6ozB3@owJu\x7uRvv= _zC3mo|[{%l{l*!gFy;"JSZvY/drvY/_,4-I#cq	+d:	$V$I#	+d:F4eM|w I>XrWlm.eImvvY]t$HH'DI[$I$Kw@'DHH4}-u@y<$XNknGZ[:wwu$H4wwwvt[r:l]+*Uvn;,4jKvK`np%\[43uKvK`nL]$p'y>*zy>*zp'\]D\JD=7BejI$D=C7ey+{<w=mH +N}3[:Md^{|%igF.Bn8n<$	 $	$	@XW|_6*QjiIyObjR4iZQ5[S[UdDI%.6ka[5EIKAbm13LVMuUsmfrmdfpTr]@
j-RD4HQZKU	j*5
O\tVLg{}f<77/0IS	)ZwvQ`Zbkm`i@$ 	@"@$	Alm0aVT&&U'UL%)+TTjB/H&B!Tz m4bj	jV jMUM4jV4h	EXhjUBU9RQ^-/15B{Ep 1{${_/'YJ|qQYx;e|yo6z41;697#5r:3 30L3 MfHS S 30:;=_k,uLL*_I5Zwv7v,LQp-6M$	@ $	 "$	*`AC/7
X~|7^zj<;QU!E  MoRY[mDDDDDDD$DDDDDDIDDDDDDDDDDDDDDDDDDDDD$DDDDDDIDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDBd|}>i/BZ;ZwM3.cM$5u+fY$k^!Y)qye^I&Y$dk5IR:].st,k4k5IKoPV-Yu)+^;kvW"c^_^{jX1xii#>7X14cvlrnGj8%72y{x^^^YMfI5$k$I$k$YMfI*TJ$YMfI5$Yn~}},JP H H$	5	H H H H>slmgz2YJRI$I6I{27Bz ,MIk$5DhXh,M %6Sf$Ikk5xiffAi4@JY1lrMlW&${ [AkUZV	@$	@$	@k5m$mjMMklW&$5m	@$	@$	@$~GdMf.E~ @Qb    | AIM"$*%C#! V    H S (  Qhp x3FHmTSU%P  ibB7U=# M H4 {67}el-jX-jd(LE	L"E4mH"$PA"&YTTTl4QQEETZ4 6FPFjlP hlh5 i( 4mF% QhFQh j4mFFQMJ cFjMJ FMUcEcEckfEcFmUYchAMFkbTEE6PR,TXUVUZJQeUFP(+lQblZ--FU+4i@FciCRj5 ElQQb
J#kYbP5ecm hcEXlF mZMejj))FCFf6aXbSmMFjPQV6ILj6Z[mZX	)35f[fjmbHKCF144cUhM5ijMk[F-14QFMJ$[JYYYLmJ$L$jllh6B&Z-)Kmj6+R
HjHfA(%5iIKIL)UcIM[fZRK&KVmkeaiklZM1bcXJeS+jML4M5Vb,M[QB)MEFjiFSJhVZ6)F+V-EbV2bRR(Y(+2VecV&(,ZVD#h4Fh6c-SUhFj)Q(eCSQi5(&6SQi(2dlEb6#QDj-jmVe2bfS((--EEh)3f6SDhR6&76nA*)BTb+dcIFMpI2Y*Di3djmh!cXi	()rfY#Mim3lN,lucP3N8P528Kll7-n*6
69JjjSSSxn!6-	&"6bV2ffFzmQd
5Tj[E3EfYBfml	lVd`6hm	9` 3Dgm`YA6[1 M1 WJMU 5PV
	WUqc`mP`43'
V+jdcQdLR!D63!Q3LsFh6jj9n cXKId_V>l66FC3j(552jYY2dU)
jKamM+>f0fa3L33332!3B%Lf33332!3B%L0!LfY!3L333	LfffffY&aB0L&a33	ffff0L&a33	f!Lff&LY&aB0L&a33	WQL&ffffeBf!3	K30&a	ff0!33333,0!	Lf!B&a3	Bf!B]jjw2wd!333LUB!B!B!B!B!B!B!B!Bjj6um!\nUUBf!333333L&a33	L0&a	Bffffff!Lffum6um!$b6P$bc8B6P$b6Pp$	%I(BIBJP1-m$5c8[ZH	$IBJ#eJ&3#eJ#eLgJP$!.qclJumm;u[wHvt:	bkeuZWq	Vxo^tnmrWntVCCm!w%qJfw%vJmpl~Lj55FU                                                            P &P    `i$YIjjjbY
lD[5e  V$E$6heR-& ZZQmlwF$I}pI J6:@"HI$ybX{Ien2$|=ob1n#	n +|1,:8nD]X$q%V$ @  *M1,w2z3iyx_x#4  nm%EJ5Ke$e!]J5KfFWl$1$b4I$"@"0I wWt 1xweq #	3DvY$@bP9n*+)|1=I r7snl
q H[DI{3D1#&blf//j4zh4  | 	$P  
aLaLg5\oOM"&4 I3|H  }v@"D$D@" 
b.6b.6b.6b.6b"I `N}{;]wwtJG;,J.H&3'X=}'jGZ=m$)$p #@I   C@ ;-`cgH Bx-H^@6b.6b.6b.6b.6b$` qqqqI sQI_hZN NAsvF5o9	/cvRtN'I$   HKo (m\m\m\m\m5D@"EB|q4-tBHp/wf[cJw3N.:$LliNw4vint(O8^KXty;Z}t8$<342HlieS:x4+wUeN#L[%#mqv[n\b<lVPKqemt$,:dS4]5Z}9uOuI$)q]Izd(Zy/;`E8K:hk9nGL[%#mqv[n\b<lLI'2KI='n$D\k[{I$I7)S/{r u$qw\J	{e3~QR6(\Gd)ynM4iF`Oz	>wfIG{YR^aH?oYS?~$)C&yR#bP*frL.#{SRR1(A6T!(G]SkMm6M0$l6fffn$#`I"3335 $QS\Mu6\YyQD%,I4DiM "" H?Zm D!F6f4	M6ld!`%8P"*H4tENuNsG]'XG]"'XK&-imm&IHPSdH$%3em51F6+[+([ahFV)1$iFkfUUIF6S h"$j6iV	4)i	&U[%$iXTm4c"VfMi@G& Fb[&,"c	lnl8`l10lm3cMd6Clm2mN&-"`K^/<~y b{HqKM)HUZ:i
G5K;|Q$,F#effff%ll$	%I(BIB]zUuzT-`lf86Abm0l67;m6l6~M@Kf/ebG7)$mjbv=SD HHD H #V A;Y1    A/)k%c])JX:iJZcm6:iJZ-1""""1b1~Z6k=(IA[j
P#1`oq<i#byBH}4t-SIk)ZZR4mm2IBlb333BBfffffff2IBfml	%cm={)fqVJSIfI.zWB4$@$hH?*Z[^*Zm"	b3Ox}Lw& Z7fRW3Li!Bn-m(@ 	 @$  	@ U #<m@+ Fs[v@ `GOwv,4-v4>+z      H       ~m[Z  D$	    $4Hj$5 H H"HmL{2G!]2lIrM#I$#             }F>T-BVI$TBO{4C<H"  D!J::V{z,{HY$E{= HD H D">hj}wYin*Pv$E$m(rIM%q beXQJr$jQ	fsbLU   (1p  
`  a+RhaYYa&    3P ]Tb
-  \{Tf##1 !?LiUJa1U  =HiM$jTb2hGi@D@4|km(QY4PBe(H"+kZd(H""6(H"EETQSSPX4 6FPFj4mFFI@hh56FQh6FQhh56FmF% Qhh56FhFQh6h6m,m*m,1ichZ[hEh)YPjRV VV*XTX*,hbThFhm        Ubje2L
j5%m5CblV6MEkhmcmhkhMjI|dU mDj1cUlj3Vj3Sb6k[&UIi4lSI!SfI[FV6Eif+1E[cVEf*53Y-,KH3KHhLIM-STPCl5l,k4j1QmXhRHE&I4LHaS0V6LeU `["Jf	3 JddfVf}FcFkDQkcccQj&b65QZ-MMEVMbV+jEFXj,lkmm+V+V+QImJ+RSdfY(VhhXj,"!LlDMFVVZ#h4FmFbeh-cV1eb(2e0ME(#b6dFlFjhDjQlQleh(QMQMPgKyO6ZR(K$MFh+4j""vULhef9()+f7YjZI8pj4RAbK.gLmiDMDiMQMY
l1Qb+c5#k .@11).$%=)<4k4T4-&(5EAMDZM1,(%QlUde&DmMld1aRVU
&!HO*eJm1`	M7X6r67UU-
7mV+pshc6QF1lU1JR#B[*UA$	ae2EjlZL(akkkjfY=H}UWe)6Tm6lmFhfIflm6ZmUc
M-Vjl%gv$C$2C$I$daHd00$3I$!$I&$02C$!HadI!C0C4!a$i2C0$2IvdaI$I00$3I!d$I&C$02I$M!HadI!t!a$c!HadI!C0C7v$2C$I$Hd!I$I2CI$C$aaaaaaaaaaaaaaaaamXa]vrkmw&daI$I!HadI!Hd!I$I$HadI$daHd+mw
w
w&daaaaadaa!Haaa5rkm$I$I$I$I$I$I$I$I$I$I$I$I$I+m+m+n$	$	$	@oxm'udwydawydwydwydwydwydn^xm'u:{%T~Sa_X%=l7Z{n"{mm{36=wowl7<<q|!936b33aY!l0%C36ffa33afl2X$"dI,EKdIb,Kdfl0Kd}wwvvj5Fj*m                                                               (j      `e@  @@ @V&{e*dbbI$- VdLlI2d[TYI)Se 5ym)SD0D `  `$0E!n@ %&}.b={PmnZs6vt~^j/\$	\?]   +k:\o?r6XyqLX0Pg$$}}q00D `$$0Wd-DI{v.J.tHWkClO*w'|M_2B[<f^HP%{\^#Y-Xv    o:r [j    d:r~Q(Ow4{7D$D ` I $D.Uh$A{$~.qqqqI WIhD.L$p[#56OqJOIw p	8/fQe/{zm/x~y< 	-K{eH\ m\m\m\m\mkh^I$-D]v-mv-mv-mv-mv-]$0Y-mz1E:(yr{[wr <nnPK["U&!% 	~]d]d]d]dkW@$D+I$r~-uzy{,'r]$;G,)=^I$I{M$M.$jhnHe)HnHn$"II;%I#3SDz])%}=.#,I#wcSDrI$?xMMGbww\c]d}qv-wv%"]w?z54K>~fjhnHnWkx!$}rY$?[54J7%@Fw?z54J76jbm\c]dmqv-u5F}Fu55FuFu]%vf `%sK3SDFN^NKI;R}fji;R}{fji45wr,);F6,vO3]J4:hQ7|O}H.Kmkk|u9uoPOcc;j$lKv)VE$E$ FB)  $I#blo@4:K*a] q=y<z+H?(1X1e&*TdcfR).;S%sJsR',Mr""""".[)$Mj56jf1(+mZ(e3S6+5mXX!UYd2T6*cQ60sbM&]pj32h4S)4&XS(4Yl6 P`Fdp1$\*	Q^U?%RT`TA0&*b_M_bnm.l)?OV[=${o <xcRl.K1Ylu)rT  H   H?>}"RRSTPFD4@ 1+>IRG\"*	(Q~}]ywn%zY`bKo@`?	0.,#wV F>?=rTlbc-u)kZ1J[bT*QI$Y$Y$I$I$Y$I$I$I$I$I$I$KuoVF}=z,Et^"x^=-lc;,ac	AI]R:  @  Hw  
`77;P_{/e[@4:K*lJr+h       @ Zoiv5r9te>>+-NzC[n1YlwYmuec+-6Jl33a)dI!l0$I,036b$33a{Um xC;p@`: Fn|lRKi1[f1cgkcm)mRF1cII$I$IKdAdI$I$AdI$AdAcu@ $	@$ 	 @Hh$4H      H H  H   H H  #WrA9I%LIkmI$dl[mKmI]T]rx@&5K(ZvQJ']wx $  	@  $ 	Ghw{kn*#kqImJ.ws \%$72]D[#mqIr8IzcrI!%B H    H \kGeX "c]uy@  $	@   $	dMfs89~ @Qb    qP$J"Ifk53,jf>   
 2F P P  QZ=ggI"
40 5$	OSiU(@  H$LT44 MIRD d_MHU11111jM5SiV4(H"lM2iLd,BE	"eK#EDhR!&"D%%66FQhh56i( lP I@f % Qh FI@X"E!Y[$++del`                hJ clcZB&j5)hc,mUQEXF65j#MHEb#HY+&*,Z6X RZ*,ZQ"lI4kF(lDb1JY
(SfVB&Z"6K-TcV66cZ,beDmIIU"d&Im[lSlf(45 0QVD+JDcM*)m*jS"J6(4fC-(2IBi-$jHYE[QiZE%ZQ4iic4e%Ehj6h3UY6*-HT[
EJ`M&IcQ45D[idDEX-j-hKD4M[e6)bYU`YjD[ZSlV2D,*MmR>6lQL(l|]PR5[kulMDMhFDDVi%66#[)X[7lRxlfj"F&5,lHQ.b[UmFZMebZJ#vfD\.XR[I7N%aefHdm,iEj42cf#2FYpl ihBOFHillJ/q	amBj+1D56 +)(S$dcAQKEbd1cUViq5mqFKFZ66#lj4hIhFm,X,bFZ4hIhFmEdIlBI4f>6mKEXX)[Sm[L1bLjTpXLPV)qTCj1J%ck&*M&IFD5Z0hZaC5&HjY[1,%FJ(PY0+$
kjYZfa,0lFm6BwnOaaa02C03Haaaf$02C$!Had!C04!a$mc2C0$I$daI$I00I$aa$I&0$02I$MI$!$I&C$02I$M!HadI!I$$I$00I!d$I&00I$I!d$I!aaaHaaad!aaHaaad!aac[n5\s
+0wI!I$I$I$I$I$I$I$I$I$I$I$I$I$I$I$I$ppppp!aaHdJw
w&praI!I$I$I$a]?{fyws6wqsws{o<yyfl7ls3;ql<{fyws6<yJ H H H{;{qlyJ+gyJ)dkSmZkSm@V@$	@$	@$	@$	@$	@$	@$	[oQm@                          ,             06     Jf @AA 5imKja=4)X       I$lK)$I&d6I5     i4I%Cs~m\I$ow@   .Y4 I,mouFV'l~7mIBj;]w<$36NI$I$I$-b}>g   
.7Ic_6>^_.TI$IH\h  2Ih4$Nt   I4d/'k.KlK.KuebuK.]%	.nVLG$B*  I?;7I$I$I$$mV1!)$&IM
LC4bwr; ~ ~>z| {]C_%5$d4M&@{or$    dd\IshWdH[@#v;;)&lII6
wtnL%.j5ng0x$I$I$I$H{D&9'(lIrQ]$I$ yv>L_}[@$B.Y$ur$N  zI[oU'E)=`t^[%a5NQ9G$-[dHwS~0guk}}zOd^J7K w{$Nt.Y8H az+mm	IGvmm%a5NQ9G$-[dHwSv{s\_%mhikp^MH(^M#>%!=|yp|JJ%pLv0	9'amIyN|pC")T=-e44J$BM( H'7;Mi$bssI {N|pC&9G$6Um/0	odB>:"G?m<V)hCM0	$a^`mvI$s6H9m$>vLvM}{I1>$1H}{I158-%'/HmuE{wl'/CokvoJCokwwvoI$KnHmnHmR~xm)N^?[f{Km|,N\IQsjvtb9nfasyc-VfURe--Ys0C3 
a@3 30=e]-\um-rTB)33"IN}$	@ @ @$	k~`JS%JX3R3@cF0)JqYUZ@h"*H\pFkT\l)KXXXXrw5.jYI&V.9jIJdVLMmLVekTB+I#&cFh$#!44V4d
*UBmJ(4lb16jVV65`%Uc[UbXQfm)+\mMS**W23&ag#-gUdU[n1K2Lb9.8#]*X120!**PNIHJ$jULH"*PL!!(|>?mGmgZ`$+4<z)$&"Ewu=eL(Wyl0SajI$633adI.S36ffgs(
a%{
)aDMQR,@$*	_rIKQ%UrEP^JH+DHHh@GoVE)$M0jI&i>^G[0i{h-Un$2)JRJR H  H  RW6=3`}`w]HXT=U-S
=Y3f,XahpI!l4ffVjV1Lpg
f6ll"O>CIirTB)0%i3$$I6$U65) eb4p]KJGTEmZ!   H I|'Zckb@'h
RNW-DRt)KrHE<xxH  H  H DH  H    *H4$j5_jsf$kJk.*c$I"HI$Z                -4i
eJjsvE$fInn4o$`.+OeHV96E$I]}H""  HlV6y^ul
G2H)"$i7[``6!Y,]UUnL1MMe5w=D}G  [V'}F 6+*
6WcG    +   } $z=) $   'G   w	 3Jh 4 i2M@ )TP   IRL=@G=ORi`Jj   ;(mXlJJmn5hZ
6m*mJ3%eeiDtVu%[lUEf	64SjhfPJ6*M6J[CaUYbfYPfI,jbe)*Y1EmJMmPmQmU[ES2TR,lM"cUF5"i5b)i-ShZ566f5M5QEVKh$L#bM&i1&M&dI&LILf0KdFj+efJelV(%JD5fa2j`abcmD5j6d&dI&IlIMC"H#HbY14E!Ki""$mQd"eh-
--Y"cdj-Qd"e-@4	$3ID"F4Da#D"h"$hllJ((&5cX6j-cXj665TQl[Ki)TkILi	&i6i3ILfi3Hl2bMLVdfK2Re")j5XcQhJ+6lEcXQX6"!A"D!#Hi!4!l$BM,mVM-hh6h*CVL$4ljmhF)A[ZC&lH$B&d$$$ia"MLFRMmQ161b-QF-h&0&$DH%D#=,UId6MaZL8%J[jKdWTcjI5M[bI6LddY$Ya5FTdVJI"DI&D8Z& BJJKI$RKidA")mM6+28[jBbfRU,C&Hm2:IWNQB*%B!$JjEF4hQMIA"D$HiDTI PTRI$DQVPZh4U%%mn-l+HM%$iJR,{	47BLmLipdhXFEAVYdUq*4Y+F1ngeVn mm^{CtC+V*ijfLf4b-RbcV24ek3HD[U[[m
rb<p!BfffffD!Bf!wu1c11c1cc1c(1c1Qc1c1c1F1b1bc1c1c1Zc1c1c11c1cc1c(1c1jc1c1c1F1c1cUc1c1c11c1c8ntac1c1c1c1c1c1c1c1cUl%[	VUl%[	VU1c1c1c1c1c1c1c1c1bUl%[	VU1c1cc1c1c1bVUl1c1c1c1c1c1ca*Hm$vtn Hmkm	bIBppppp$bc8XP6$	@$;Bmkm9w;6T]fy<x{yBuJpw{^zPw<lzp]tJywzBu=zz$,LgLgJ{]3&31/Ww{{JLgw=%=zzLgw} YkFj5EV                                                  =B      -#T      `Z         f  R(j@              A@@    Chm   *      j[        $
P  -    H   j   0 `*Th e 5QE.&'2Ov=io $ 8 "H84&]"O}Y@ l 4m lh` 6I$9N$\@N%4AK H|$  )"4j{^HWg E,mx  X)ck!$cLiC	^E]rBI$I DpA$$6w4Hy:lw5Yrun@'qIRH#D^{5vo|Rt, ^@yvuq:&/!y|_$ bI__ : %;5S0;oja#.]?6>M}I| zkx[@$I " 8$"I6vBU$"]dI+KMm/$}=T{%TI  W%&FI66j*^&^?, {sX~o       FmL$!>mm*Ih	!1mv-%q-mv-I&vI$5bWjb.6b5p^~WN}$Z {`qKHMl m4kzITDY{r	C.iK HB<mE]I!m.uDKMm/$WwHma #iO7]\~k)>=Kyy$CkvkCi$GmrUioGK]^6@m$hxWsyx|mkay[to2Sj9'6"tWKJsmm+m[meI&=<^2KlhQ751llkln['6mI9+Nm[tI_OY/)H!qC4	!hxs5E@%9d6rNmE$,V|-m^v-mc]dab9Q9nsmsm^<Nmq`KeI&==M5x6#`y-mNKm$k{zwEoo^^^[a_p>}}o7mlql%m&<yyy{eG<3JfYfY/it7`G^1S R,L'-w%UB@$!RI%b""""zxOmVa$\9*&m6k&)ddP*HTIJIU})shZ 5{:y;Z#_y %=7k#\4w\$kwnx^yq H H "DH#[}jITQ"TRUXED	Ty i@>BU%J u
]e9hy7vohqc@2t!
azt- ! @"DH"I"@$	U__o=*y<	(^lQ` N8$L$nWtfwFt6L'u8iI$rE$@p@pLg@p@p+o<xV+6i9bk[qO'k# nqt	.Lq>d! @ H "DH#U;fzl86K,~m:X$\J,o+`! H"DH H	^aC)J$DDDDDDIDDDDDDD$DDDDDDIDDDDDDD*"""""""H""""""$""""""$"""""""m"""""""HDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDADDDDDDDDDDDDDDDDDDDDDDDDDKZH==|z[^|k[Ty[ 	$&~zo	b{opjRmRt`3[RWow$!$b6P$l6P$b6Pc$!$W.sws6>X!Fc+gYSUTu<Ib ;I.l =?6R{M{M+o[-mR,m1	6Ke.}!&fffa&fffffffa&fffa_o>@$	@$	D$	"@ "D$	$@    "@$	@$	D$	)nin4I[moIzI/[mIn	 nmNS	Lc0iHe+)UUl@$@"@$@ "@ !mMHztoX+[i$-qU,x$n	$M;fI''mI9emI$*mU{                {m35-)1K`4$3*^R$	D$	D $	>e5Ew4.WG  S   F &P"RVe    -0   7Qq\(   ,}c    1I!OUQM IT  %7Th'PH44%)M7f@JOjTb0yI.}iF63fcUAlVFm3"fJ222&e",,*I-b+a	[R[*MQf*&jCj-m)6I"Y(kj+kel%`+P+
eb53&cIibfU3Q6eYB3dmXEdj*2&!DH[3DHS	YLjJYi#i[Y1$aD#&lTc&Hmm
[ VjlmTeEYh-(3$-L%6V6jf`M@3dF`Uf*f
XX5cXi+4kDZQ-cXj665TjTTh-4mVYmUL4i2Lf4!"dI4&IL4&i3HH4"dI$&DHFSVRbX"RV,bXRFFk"Rj5[k*V+l[E$CHi!46"m"Hi#I4	dIHIhh6XEb6DmEAQXb12hfUX*VeT(6IL&6IMl4DD$&Hd$H4Z26#fLDml2dlFM,lccDmh6cf1*,MI4I6&$D&6&6&D&$$I6H"Fl ,:I%myIIIJ%F*MI2I%%xmDA267YFcS[M(J8cI#5fbZFT%mVmmm4b1EF$$$L I.lUFJV*b+mPTFKKi-$-5bF6*1Ji,KjK]J
!1hXb,Z4KIm%[Ijd"BDM$pQi2+6ff! $L!66Zmld,T<2FKMZ(hceVV
`V4,TbiI-RfjbV_[V1c11c1cc1c(1c1Qc1c1c1F1c1bc1c1c1Zc1c1c11c1cc1c(1c1U1c1c1c1c1bc1c1c11c1cc1c(1c1kc1c1F1c1c1c1c1c1c1c1c1c1c1%[	VUl%[	VUl%[c1c1c1c1c1c1c1c1c%[	VUl%[c1cJ1c1V1c1c1B6CjJ1c1c1cl%](B6PlBf30!(B6P#eF!(B6P[[oWw[n:6WnrUCk:;v/=:#eF&i3BwF!(^webwwwU%I8Bmkm1a(MmBfiI(BIBJPWw#CCm!m Hv;u[wHvtnC[_j6FQ5Q5hl                                                                      x@  M   @	@  KFX        |@	@-@      X   $F@            )P mZ-             YP PK  @, e@mlJ.vgoI @"0I EtD0D[m}}/K%IDInwSoYmU||w_&T?z[x   YmoKo'<N=?~^16I/{Mk"4m1&l\I/=^MSad+<|$D ` I $E}di"@"H@"I-}M7}\BkKhboRKI/63-3rNh|.hMCL<M{wN$kNnic}%@   [m@)Ym  oe2R ~@QAsxK}}D$D ` I $E}di"@"H@"I ` sd]d]d]d]dkW@$E}dq/%q5J78BBLG&xiB{q;-I'tNI'I%kJzK  o   |%"I{}mv-mv-mv-mv-mv-I#JMv-mcd(b.6b.6b.6b.6b"I `_Y(m\mm?D.$$y>^^Fa/)w.'mmx $w.y\m\m\m\m5D@"P]dX9nc$$z{zjvI.|.\{]{m7t}qMiB{m7{wN}qMiU Wh@{w>I*M\4^ ]9Wh %"JSE<'{Nw=$-'wtw=s-u#id]q.~/ .4^ lxwNI%^)JSD {>y-{[f s$x .|U/ .4^ lxwNI%^)IVL["GG5-u#id]q=5DX{5DX{zs$z< .|U ]JSD {>y*M'Wi<MO>I*M'Wi _${/y.I<IW4/|UM\4@ s$x .|_}~~s6[][=~QQ<Qc)q<R5TYSz(Q1Qd!FfffFB!
6BlC["!-mo[	{}N             jjJ",))}~F+h6I	,q!(mq&8,p\$SvlB#e	F!(L6PlB86qx**T*J*T(_;RI*OhzmAyuo^Uo^h               UZ_m@b;A .@ @
O~?MM)$kcCSMM)$| iqSMM)$\5            [y7)}AV)E(R{;\yE%G I	?{w1!);\	%Q	(bw()%$RE (B6Pl3333B#e	F3330!(_w]I$_{F4~x1|kx-jZV            ~""""""H""""""$"""""""H""""""$"""""""UDDDDDDD$DDDDDDIYk"""""""H""""""$"""""""HYDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD$Am~m_hfm5y i17t)YyIGT$k1LY9rBb;(I$!(BIBffff$!(LiJPea$|* #^ns% PAwm # Rx<|m64121ci8 iC      H       ~k[Z             j      P  ?	"CD!@ $ 	@o:4MI_u^[i/f[{YYwy=             jvDre[Pj^-U$m&nH]k{BF^,+)rUouU                _-M@YyKed$kuVbI,
S ! $	 @$  	 @hHIu]E \YoHJ5{
*o)Fx/ 
=\    0/<P$F
 S`lPJV[    |    d<S@  ,9p   c9 3lB
R  4m@JJ L$R	)4*izO)=@5)*?Rz~YYYFJUfi
Fi ```mm35cXY5	VPi&MMMLc$m4fi$&i3I	mJQ[meVM+6fb"ebaDbLIm&i$HdI0J
(SfbDFjEm6UP$HA HH4d%1cd"iM*5bcZXKMjJ%4
P- (Rk-M5+PbCI$"F"D4LIF	4b$&$&FI&JJI4*$lmY"!hKCPX-,m"+Ackh,VBHZa42dD$H$"M$"@"$l"HimJX(VhVZS)jSI$H$fA L#DdfY(lVfScm&fcfMVbYm%12hl6[eM&FhiP5flVaM5*cQ+F"3IHH4L4HH4IDH3Mm#i	4e6V"elQK%&PR([F#RJlbD#$2&D&!I&Ve6lV&dI}%aIklEV11mc$IHDl{0ejI&^,9PJTMRJfi4D`Ym%YIIJI-)6%XFJ4HYJdDC3<0)-fH$#iM<0F2J(DR@PdFIXm#$i	2FEz)die[d,PS+6#
[`m3,am#1Fk*RY,$H$l;tU*E	,h$I#3EDiluKjAbmI[qpEm,j-%5lHlHIL)2M +m[44Dmy&IU&4K4hFmbE`Id&H	2MDe)+X+b"&@X10veS5VlAmcVjF+k[E!HvlF"426l#mj[46DDF)-i4$$mUU } !BeYhHP%Y`F!KHdcEk)HVUV ibb"dZ)Xd@~1c1c11c1cc1c61c1cc1c(1c1Qc1c1c1Qc1c1c1F1c1bc1c1c11c1cc1c61c11c1cc1c(1c1c(1c1c1c1c1c1c1ca*J1c1c1c1c1c1c1c1bUl%[	V1c1c1c1c1c1c1cl%[	VUl%[	VU1c1c1c1c1cF1c1ca*JZ~R Hrzwlu^ls.{(]^5sPu9](]^sP{,F,I(X!(B6PlBB$,F{yBzu9v{]tu{wF{esPy(]](]sP]tw{BPB{IU-Jw9;R#+$	@$	G9.W9F,I(X!(B6PlBB$,F^VQ                                   P    T Cj     Zj         YEmP           B   B   R  X  0bV*                      ;rP)` 0iX  R  HM`  l    `   *  ZVI.I? {mxmmrT(lnI$I8&CVB%	7w|Tm9bfby+nn:SC6M&]|  {UM+Vlol!
~g7b  3m@+, 
Mm$4  U$I$\U%6mII}-wzh`5oI==w[nwnY%#)$R;R$	I`6)OM^[mwr|Iw  @8n\    pmW%))F61|.p   u4TXl})aoK=JBWs{mTI$IrT(lnI$I$[U% mT(6IrmT@i/'T ~'is3332W1APZo)=}y{wJx   $`m  ow3n@ /Cyvnt={U% mT(6IrmT[U% mT(6IrmTM'RzO-x#m<|a}/<{K!&b^uC S]=Gq(rQ=%Bmj CN-&y1=k .PmJO\[SWlmg)y3$PT0136}OY;mj geII'z}'3w^I$w^oS$6]$6vo$Hy] FyU1h  ^U1H$Cv$7$6vWCs;wwo=ZywVvyU4  u /Hy$l{I$ Is.P3o* P3o*uhngnCs;wwo=Zgn{{rL7aH2gwot!kI$fgyZ#baZG;79I#dw$scyIBI_O>0 ;F$lL9^RI$}}<3; >IB[+nD>^wwy%],\b|@n!e-A7~rw<HDH @ @$	5cb+?mR,Bk nmaN{ ml0ffF6>;
UH@~s\>vmx,h,$8|N H  $D HRW>7F6fm1l( *"
?@+i%_ tx|B+,e  eTw$
i
h;P<!32sox|<KiL@i1F41<<[Mb.1c5n%$RE#q(B6Pl3333B#e	FlB{z:X^UUw{M;vgc<m .jHP|84,kp$Q4mQEBIBlbIBlbIBl3333{6I(xy'PzBPY[6yeQQ::6m%r]m6M""""H""""""$DDDDDDIDDDDDDD+l"""""""H""""""$"""""""H""""""&""""""$"""""""""$"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""16`9.g$]>ZrY5gT`- rV7Pj>-*MM	 @$ D$	Gri
h3qC8&&32swc1[Mb6LN1
1yympAcyE#q)")I6Pl3333B#e	FlBka!@  D H HH H H HD H,FBF H H  Hb:0\ 5mP333ffw){(rJNH6z62MeI% [M6@$@"@$@ "@$	V%9
fou{[A[d[dZ mw]suD H  H   H-E*+;R62q$d B[hvC(kIa1mYDRIm l-V H  H   HdMf4XC~ @Qq  @@?N@  eP$  2
@  2 2RX   #Zz( @  	'!"o`;b[whjU  (1B|= TRQ`,rZeLT
= tp6jPP0DM4S4E   z U@444@&OTM   zjJ dh  hDFM~*^,$f66H$	:(rn\]aK^aa'XR'XXIufI:NOzo7.F]vHFuEHU|*mv$Y"_}}r7'dU"E,#rzHsWJF"1DX1b,ETMH1*cd[l~w~5.QkonW\6wQ:zpuw|9^x6nk;kF4msFSv4msFwh5s\+]s\+_qp|5rKYs     ;5h]s\4j-|kF4mzf21ea+fd>j	MJSU61ccj%60hQ"XC&+b5FccbThX4mEQEQbEjcEF lQ`(GmUVZ-f[lkj665+mj6hcUU-mmmhV	4[mV6-lJ([^VkO{kk\Z6[&5m3iRl.ZfF`3U!W3*61hGMs[\#d3efY8U+j$uh4aUm[	"C8,X=^-vrnnr{=^#TkmZ*fmZV#3i+eDT	
{-QM6sDGm"?4l5ff%ff+0b,jmJGm)Fa(b$ lG5*V
lljf5XQcVB_3Y-e[%cUV1EUk[lj+X+eSiHY6mDTUXo%&j-F&cE[cEcQEfkC#Q1lc[%QD15bJlQQ*V"CiT~jl2%TQX[&fVLEf$A6ijfd=q,KKU]{>q|r/6L+%5IIIoo$	$m6`vGc%33.qJjmhMi8MjLgY|r?f1e8'aTU0,0_&l>&O1}mG)MKf|-/O8pid)p6m4~[S`VLa5&l?3m10\_>zG:Gyg[nd--C~Sp|eq|F-e]p9CS\W#S>['[rS8ecJSO\ddCX&DSe&	imTQcVl*VcTZ5|"l3TC2fkijc21?#'6,g8w3mX;8Uf%/N,1QK$5SfeO+2@cK:]~<KSLWN#pG2.8a:a8Lb,~,b&+*&jUG885!+v qm|Gt:8fS5,&#r]DdGTaa#8-,aQ,g{ip~uhT)$-kN5pL4x>.ch6cmxk=Cy(G/TixrgN
9.:u
Ef2D}38bFkdTfIG
Unizzx320fgJ6_ToO3o;6b=Qd1/KK
WG\G,o3<E|#}I'op'xu82dWy>TTQ6'h]>k>9SF#VhK&IwNNoKerj:{S%z;vq\Kbu>!Y8+fx>>34N$GW+#)>bgMG\9l3<JuF?J+u9sqb5O]+sHYG9q9SXFHJj(5hrkSU{WmE#
XXS%X"F>1[Yj%
oTWJ2w[fZ`@kTZJY1Db0JJ2f3W+11EQQXX(lQDj,Z(1F,hh`DE+S"&L ",HI,Z?fP2Z[V6WF+;*_VekHX)VKeIRZiIjk-hlX6dbfZ)7g"5^:Q2:UtzuMiLp|9X<9x8=Mr$oHr*P6}ni3~:sO0+i2h??C|rcUIyT8>Q~/a"u|75g8y$CQy_36k6fmjjTm,@                               ]JLc1cf,,c1aee2YZlU55kT"O\&2be  4UZ*VXj   kZv
-j-bH6WB3e6lssQc1cwkbt;nn1cc(c+b"6W9jfsMnC1D0b"" """1b""1DDDD1`D#``D#``""""DA"19\]\ptW""" D#cmcj66Uwu6666J]c1v1c7\3t:Mm""""""""3ccnc1nc1n""""DA"1]c1]c1]c1]c1]c1]c1v1c7r1""""""""""""%1cu1cu1cc11c;1c1cc1nc11cF FAc1cuc1cwc1lllllcc1c1c/_}o%n!u!%qb ;mvr#wRP;m%HmHI@r"'`8wnZ}Vc1c1i:N	(mmZc1c1c1ap'CwwH"I1c m""v{m""v{m""v{DNq{DNq{}kc1c1c1'Itwmmm1c1c1c1xmz;m-V`8rk;DNq{ZmU=={Zc1c1c1c{2{Cmz;m-V`8cmmlm m?????*.c1m{XHzqv^$o]kW~
wnj4o218um/uj{5 F{=p((h9:``..bKaUl   06@ U @k 5`      ~t
      _o_}]mm`lx	 m r`I'ev}oyk			IosPn6Mk-+ &`'3vI'AjL#Xw#ejKiM6o[OzXKV$g/w{ ~@P!! R!Hw2TQycV#@$8lvcmm6mm$h 5}62I4	&_?x  n6LNA2sMB2>I>;IQgv*7U${HE,t<^4JS]n	,jH!t/][^nob"f^dDB/~rD^=w{ NR7t=L{>3(- 70^DygNZ~5"j2I6/9U,8bRBvZ.NvH7V}<xn}QD{3  H}k	a`$R,X)I$C!%Jlmm.F%$!	:; H#WlI]'ev IbN;+%1zFI&LwfH 8Hb8Id	,ifHTZ}[~}=fwwtqUI+-$50I IA H wwu:q'@>FRU!T*HDLCA;e2uh"l:ckzzjE5}&}"{ob	6H60:}$IO6*mA%gQ}$l> mBLc:}$m.cVoO:s!Y<Ax>}::oV]zVV[5h-J8{M4}"{ob	{^I/xl*mA%gQ}$l> mBLc:}$mk_o>VWlI]&I;+$m_o>k_o65ljz;f<[|f__Rim-6	$=dXdH#Xb gMMuM=MuM=,INmui$I=dH#Y>YuOgK6	aXIkk[GmnO>G--uvWdN]].xQ$y,g1^DNt1!XHcn5YdH$)E!$EHyp $imY$TU(XX$Ko
"$BIIQWUxDy!&@48/-$d}N^^mEzyiv8^W{zWpWp[mVlIk\smkU%~ _5kVAU}e~s[^f5nwTj*5z[%16fYx?5]cFXK|wQyG"hF+YYsmoS2/b(z|JQ@_DY"/n,Hyqe$2;7paSUP#P j!YT\+*Er3`v'q.:WRfB+Au VuH%#-\ib#J:YBX32yi(3
]J;XxuCBx*K,\,;.FzeKI&yf(c3q%+xy*RtUIOL0&cMqs<Kzj1#=8sb!Qu^zt|+wWpq>KWrgT/K%R2ci'l[-\jr5^"]H\G-eF7
ssrWH^Szz(Vj21[95Ng}v1yS}1h&/^W|Izur:j^G6kn=>>j>z)fhW/7+9mVT{|U[B6/t+Ky)W~iDrrY]eKI@
U %RVZ 5UC8

&(R+,2JhVhAjQbbaK
X+VYC(hbV%bZFQLb24Dd#E-$dZ+Ejdi,`
iI&aVBY	e(QFXIa%-B$(FVVD2!%V*b?fpm,vi']/MWpKc1q5ld$a2Qgr2c&:NhIatJBE*Ym{	yWBE^U)N$U^k-t!$I$Rt!"*ZBIc1c$Z1l:F"@{lw\;YzJ_ EfUI,dRR?W4 5i*D$A,U,(0+KRDJ
HhVUPZT@)d(`IH`CFAQUC	2#"7E*UU0UVQpD2"X)iHU[me+PV#U@R0(8$HEF2"	!*R)`*i(ART+UH+2*POK2Y1,33I"kd2QM3l4&VUb#*U\ef/-mUlg]IgG46QfFbFa>xWOx+E/uqWWewUT
U6Z>s)6Ul/a\/R_%'E]B\P=Ga'&bEORUzT)AbV0;EU$Rs%hn,&m95
TmP)BUVJ<_?BJM1c	5F)L*!l&U[&eY*aj	QJ,0$dRM0X':	B$1O_IZ63*2X#32T5V6VSVT}$0i&jVX0m1HL*Ox:SF$d`VT$<%`qp.Y/5+3jx#,OU.K,\
aA_885%	 K(hYHjkf8$zp6m(vl6vm;6q;i:%U,,X?}w^^Uym5)i%"Sm(ZQq6K]8]%%_&DDDDDDDDD"&L2"d"""""""HVL2"d"&L[k&L2lH6L2dms99WWyGsm-7~<}"_7vmFb,U+(ag3z,dL`ia^tE^UmSyW9Wyc1+F-,F-HE^UI'_>!9!js~_h@gUc-a7MN.Q4Z4{*:@1Wrb\t110yWUxU^UUWyUW^UU^yW^yWUxc1c1c1ZkZU^UU}G~G	; (I  *   K  l@$ le$H	 @$ l%j+m^]  n ^ (
 (
 Wuku;n"%d@m6ml{{ l6@    nnnxnw*+yzyifb<z{$H	 @$  l_UUOkZkbf/bL2 3f^R (  
eB     @ AE_Gv 2a   @       R$@2H  f'(mTZ(*ABb
.:  
  '`qP@ ( ;    :rq mCST b	LF LL%7TLaMz$I%%F@P 	*AID)P{E=L@?Drfs\kEY#[$Y#KeWMLb,ESF4lh64hN^) zOTxI9`zz{(Crn]sr7.F{RN)b,$
X$	:NLF~}r7/mIT!Dwp8:Qi{np_QvrnGu#r<+d,j5wWNn5bCk$mRY"-)T\J[hsF^=+s4msFs4msF4mz=+F4mp=+F4mp=+F4msF4msF~zWhwyJy      m4mzWh5Uznk6m=	mK6TQE(j4k5AA 6BEQ"I%i-mV1Rhl(Pm(A-Qb6b[[kmXUS*FFNjDsF+EEFj5XNl	Ul(hZ"KbM_
	H[)l5Bz[U[&N,:B*<:Czk]ms2s{tlQ\F$X[/>_MxkRkryzk<5j**-rp>hnr^@AGs;V2*-B_n
vDk]CeP\6j)z`EEZ2+`;Wbm+O,mljyzkm
~JVelW2I+4faYl5-`*
ZUV
e&%0JC1Yf*bCjA ~!AHm$mUVA)*iDs$@6[%-FJMU&@lHmR_^*@mJ[RIKi[V-6kC#Q[bSmSbfjd-eKe@bjkBlXm3TXU[cm+U,ZHkk[+-6mlbKf4hVcU4T&m3TX5V,kmhFEcbf,UlUcj$b|TX5m4cSF+6F-SBBJL1))3Qj13((6[TMF-j&b614EfQ%d4lccEIVSblmbJb5cDkDEDZIXZ("#ZDhi4FF-bfIEE2J*(EZbfi>']0b#O1ONV1fbS}H8f.'J1z?G	''>d?C&&ad`I#i`1Y/C=d_Kl6Eh-TZ6m-|pbJfT0/}4{,^dN?.Y\ITY\I;yeeq_dWrXE+kc5(([Mch6-ekfQEij,c&4QF6M2&Kff[E)ab/j_eGbz~pbwYKS$Jm]e1M3,*~1YY]uXbf:qUb8apc		c1cc11X,ffLHuVUYVL*#Unma,#Q j`[]ZSN(OEQN(Df-a&0)+#?#61p~aNfac31b2dN"Zm6O	qt,mLo]N	1q<+*bG!1/AOL38cUM3Tf6I'|EW74uf+20qfcUKmC+jV+Oi=mol|YFD|>'N~<T=18^=$V2N-?>
?3'~OT{FLr20p}\&_/8I2q8//x=*OHy/0Rz:uz^I:ck\++1&`#l6x/fm,9ihb1#c0cFP@B&a0 6EVjb#b14hccdXcV6YECQDj,ZiX5P
P"$,)B3T #F1!,T%IIIK)e]ed6UdXjM5Pknk+nT-1kX6QmWUJbthnQhcFY-`Vh2,bq)d+<Y($<:NUW,Y*P.g{^=R\=cl)8E/TQ)xXpp\=bSXQT]xT>)WE:={\\^[n&{:q8<
eTDY1Xc? l\2#DJ4M-J4ll]l%)7+vZmj9mZ[e]g]IjY2KiYAj.i2Vqin$k\k5nc`5@
'2Yh56VeVWk5]YV#A`rokjFUl6d6,jY1UlmVW        QsrbLLLLr1c1vnBt:fjfnQc11c1jc1Qc11c1W     .c1bc1Qc11c1F1#77wFn-mBnl[p-mCjP     1cn-[pn-mn-mBk1bc1Qc11c1F1c(1c1cF1c(1c1c1c1c1c1b6-cccccccccK;66.hJ1c1c1c1chJ%Z17wnn-[pm-[pmjPmBhJ%Z	VN2C7rmBn-[pmn-[pmnVNUc1c1c1cU*hJ%Z	V1c1c1c1c	V&-1'*{{wgv1^qwa9W{1^S	W.cjj;'*8;a:j9S	^         h         m                    0TU??/>WAY30H5zqf)AnS	Ww&YvnZH5zqs1L'R^g;pNf;3L'R^S	W.cjj;6^)Y;a:j;mVR^qk 0wmVR^ws1L'R^wg;a:j;mVR^q.mE*-Q@                                e2LS)ej~ kfq\ jV  %mmT5G63^=~o     dYK(O_<9o     0*f    RJYSa%*VZN)DYRkdi*imjl|	.dR;{wmlmcmm<Hww{Ia!$_""_|h9}hk_gvI<u  ]mqm+8IHB}{w]U  =^ 9r/~{~q'n|.w7;?u_)okwv]ty_ifvm):hY,s7p"F--@$8y6meUdUf'HZ  uwn-	z'S&)MdB	:7
wn'~I	:$#d-*&kkB^y D`K_wvo  M\ &I"$L[$nldI1
B +JAK%w4SB$yX8ra>}Kd$R{~$b.]5I)wHt5|'~YV*UbYYYYYW6wl}oyxL7A [I  MdHm-R6o[K}ur `-u[$I!$LxnhCl$4gp}%+PqP@y^Wv6wlmk{ K:CLKom l&5Nw/[{l[|fmiLO!} /H~}[m	,$+h4:ut.I f{2*{;m!H|ofa@j:>z].K
HBxN{0Qo3D(kl9{hFv[s,;k-m%vp#v gv1nuf'F6v ap{b0mv$ a:7; s;9Q^lP;9bLc:Ct!{yt(6,C:=#gX0BhH)G8B98twhm B]f&Q=$I"nwXNg`ag0
;:HxG6cc$(6,A[lf{;m(+.f{;mf {;m8WM`xGk-e[^W d'I6hvPI[&#U0a[b!@!J@,EyBho2ao`l@BXIg^HzN!tYu6<CoZ/""?!k7QUR'u]Sk|\C f8	!!)CM;1%#$9r"R(tkj$#jI"A1$D9UTDyQ^xE.K=%1c
B*"<3''yjcyV={[w%kK-"I!
IRHBBp$wuu]uJ)5bJ~Kb?p+u21z'x=%T#fm]]Dm8.)>)2VOQK9%EqY0LTud*JT:WaE2$p*G\Mut$x'xJqX]&Y&$u3Oc&2ppBJz:#:i/KRE^edy:ddW\'C<dfGX.'VN1E!#GA^W=T,65,S^Sq\2c,Ez^\Sb.q+4FI[u/,d9kzz>|OG'560{$Qz*#S
#+*NQATB*L*L!RQ`1H*$ d@%d02TF,0L,-12Ibbj5e+LaF(VS)f#V	eFIY%bUmb,EaaXV@d*b"XX_Uq@J7WWT3	tdI:zSg'qv1@&k( 'Y$DJ!JPXDzQ""r*"'*""r*"'*""r*"'*1c1%hV9Wy{2
*$2Pe"j,	pPXJdTDT$ZSTA`Bi$F#Rh"	jAYTb*F)#P
DBVY"
tRCaNL+eEKiPEB2.
(cPC"U8-)$!h$$Le(`TK
R`FPPT `Y*YbbY-cLb6IYXSM6M1(BPX+U]qq3'!Kffa0OGC_(}	_'||^z^G'b{Q:U/>WEuT"O0H0JF"Y)
?GT:%j)-C@jY.S!LU58@-J6hT!*0jA`	:'~_E%b2bIaDC$O2f2XXB\	}	0`*LLUbPbRGWi(IN)x#<JO2XU*ea2Ff1e`1JLR@S>c2iLbI'K,aPLQ
0G$:e+"h)JVuYd1E`qp%K!&JOBe@R,%,\1L0RrJ(kW666%	 K/VVi$kf8ZvXRHBBp cBeN8^GbyTUc[{wl^!b=m-(%kK-"I!
IRHBBp$&D"%&L2d&I&L2d%&L2d&IDDDDD$DDDDIDDDDD$DDDDIDDDDDQEQERQEQEQJQEQEQIEQEQE*DDDDIDDDDD$DDDDIDDDDD$DDDDIL""""""""""""""""""""""(((((H(((((""""""""""""""""""""mUTiJKo8>j<s6
WkhW" Z
q 3$NIJtifI$4MpW^/w:^"czNDJQgDDKXDK9g+jZ%:j^(WjDNcWJ"u bQXH5z,ecofng{vZx+IDHz'R^U8||qqc\p8:*oVrm}>]vAtUUX*Xp3X*Z*Uc0c-cUV1-`3yk^ cUWA5zWjU^)XUWjU^)Xc,c$e2X1HckXd,jU^)Y;z__? bHX  2326 ff`&d	p83--33--3lf6N'efefefefefefemL&iizj{{zpx   l  m              {]Fkwv{k$-ymI$lL#dlm@8Bl!6N'M&f`33M&so6(k<lu{x,ZQgcYi,ZYefefefefefemLf6NKLwu]_JI).tYu%%I_
2xJ @  )
   z }FS&bemUdH
   )P    M(H
|  v   UJy     0'1    D   :a@B@   h%RC &# J0M i%( 2 MJHh~zCah"I+?~fiHF5$j5IFS*MLd$ZS*jTHHFTJ"THF-eLd-Y)MCfc-RJm	@-)Fh% J P64 cM 4lh4lhP64J F	M      h6h% hcFlmREi#kY"K%fP3DXbolmm`%66R4lQccmMME,jI(bEFUQTU6([6([5QmF"JbM3-665m[HJmVM6CiVlU %M@l#i!D6!fHUk(J+hY Ljed4eSfj-LcQdjTUmQbImE23%ffJ`ZTi3)K1EfELFV [T[H6J5"lSaCdPfMkVd`3%&d5eU6[ZMQ%IVMk%Rj
VPVmmm0+1V242cj-R[T
[m*6IFVj" l6(1E![kG)6T-E5EVm"lXZVK`Ov2-hdj(-`l[1lblmj+TUlk6Uk}mFQm	`[Ym6Ia+ZFXl!TfcI6L6lS-Z*MXaZh%Kk%lJ3T?xbDHl-VUFU5cXMDmcbEhb%UILRVc2|fQ0QF5D25FmPE[beQII&EE6&bm*LlmQb25mF,TVm%$fjVh**(***!6+cV6#mh$blQ%bZIXCbMj25L4H!JZY)lI$Y)*IU+RJY$f$Q"TmZ(%T(-Z#Eh#hdJXf3&cd<|;(LV`Kg qa8g(*X}<:^>/OI0K2#e&^+d\YXfFfCkF5hm% e-6=,3)YIzc*X`X*c/>.+evec>*v]:j?R;lckc1%IlmFmclVJST6IDjMQkDQF*JjY1LEI))*RA%AXb0*}T.a	da3<_X?LXvN{"eNc)?*'e
b080N%V%XK]D>''bd2NIa;xdT$+?D1\=QNvp)aq|X>Cge:	*|Z{$a0q%DeLvEWINW##p8U9a0F$K]]1M.(Cem1cjjUvQ4E":]mJbR SkU~x*]0sc&c)Q1)*KI%-l&L	"`%R$MAPTFIc%E1c%F6AQY$%SLQDDb1c%E` JE(Q2fTI!,T%IIIK)e&6*bQbQcXIY*lQ5h6BhEd	bU&,b4XlDmhlJdcEai#8a2R(`(/gq.
E,F8(*m*+V)UC#cUeO}qJt]cK18zQ#XLx(G`Y3oIDHIe^Ua2mQbjQYSMK-&[iMi3IK2AEb-V0[mET0M5%mcTZj,lfJ6YmQ[FFFUk_jI  $   $ @VH
H" HB*aaf000$HdI$$I1dai$I$2I$dd$I1I!$cC$29\ 78rUlrUW*UW%\rUVJJ**J*%[%\rUrUW%Y**VW%\r\rUM+78np1cc1b	DkIss%Y**VW%\1cc1b   $HdI$CC4!$i$C$2I$ddjUJJUW%[%\dY*d%\rUUV8n B.C$2I%*J*%[%\rUY*eW%[%\d$HdI$I$I$ddwJkZJ+m5d$I$I$I$I$I$I$a[nJ*11c1c1	U8J9UiNpZ	Vnppsc1c1cqVZv[naaJ*J*J*JaJ*ZJkvu]md$IdJ*lrUVHd*dnqV*-Uoc(80bihnpc(80bihnpc(8]);J!l\6v1u8]/uo                        Z     `         h      M    h5    Mh    A       4   @N|1-mL1-mL1-mL1-mL1-mp`(8ofFVFqdv!u0`(1R\1-}Sw\BSqudedgK'nubmofFVFqdvmdedgK'n!uRSbKhn8ofFu99vT?k`m[XQT                            ;U,j,lkE                9
a
dALj  0@+6
i@  f)(Mb eF      WUlZ  6jc0#   ISPjCT    [[3 )MXh@       e    me *l  m   I YY60iZ      (VkFmIlu[$?WTmmlm w{{m
$y{}Otr{H!k|gv\d~=EiJ2{	4:[${AD<>l N rrs{ pa=PC4zjgw}#>Q0x;iyKiio_m+J;w}mmlm w{im[f$;m7}z;A  {v>i>*kRV@IZR^/
erLn\1<m#l-#`
zL\Ul| {kZ%K{vD^kTS*Ht{ C1Z*Ja^ry_1xexjOsc_4^'I%zzQzDW;lmcmm}}%wm6vbmi$BH<
y1gubDd!m3*=J{eTPy g;l_I$I@$zk$$MMfmUTUUS{  %gv63m\E(gY}$x
__b=o_{I}}%&zKi;lmvI'zI	 <)N6UY	'l2,_#O_mdd9`twO \cJxo_{I}}%I$Bp=Kw];eNfzd$HI:Hz{6LyGAGo8yGK/oBr|{zs#|{vn^Q
vX8#h}(Z}(.W]}m/(9")q$6S*&ry#kl{wJ:;hr	}}}XyUeoVo"__{7hTn{kdOo_;]EB5M6)UUU/md]:Uom$E0`N$yAD_nQ/$qtr)-z}%_oXoz}%*o_{I}cezERHI'r{oImd$TL[,_{zO;k!$Up{UMvWUW]}A}|/}w3_{~|@>_KryblxUurS"0kCe<k(8vu{:qEWH5s9k^k_5%|';O>^yVzk%,RRZZ%x
PKB)B-,Zo<Z++@!hJk5JihJihZZ(Ro#W^V+^5o]NREyUfs3f0lc6cff%Xc6gB	QB5jhB1llps\3hF4XUKY*zQdv$^01.f0tc:Nc8v[l1.UTHka{9LmQG@GL=0)Pm:munDY/nHyq/0RyBajcjt^ m v [xMN`JPeX0%E+ZU<1,:8p\p,V[T'TGFtb,,LEr2&;Yj3GXV8:%qJ9*vWehQNieb'It*+D)
vROk'$4KX]:%.'E16pep%ggJe^Ne]c$p=	q2;FY;x^8H7$qX;%p<]N,pP%(v"(='SJE2\#2#>W
t:8SGpUF\,H,pp)xS$<*
Pkn9%xciX;+xim3x.Xlmik1tb/=p<p=:%{v.qhm	OW.u"p>	b_YjlbSKmVmv<j-UGm,b\U)fU/"Iz'ki#*NQN/0
*Pe*!jPXZU4`L	dX)`SK	bXb(a0UXTV(EVYB*Ub&	,QbV(1A)&0,QjjU,-RJa)CRai*UZBBEa*U,QjT6x[FkK^X%R-M>/uZq3V":W6y<]uzN-k([I@--
P)BKBVihZZJihR(kZ+X!XWHT)BKB
P--pqR%XIb$j
)d03"p#$$b,BP)b
R&"b1J"UD%
X:@V)J%T
jYJD5*&J-UA8AKJQd$Ta**h!+JR"
ED]OxKDPOU^zW+BzQzB(=ROD.	U^*:Rb/SUu(G)C)!&)J.$$_JHSRUD'T
cw':VZNw<335j8113f0l$J1H,AdBc6c?mvy^iyemGMfXwwo4v[ogu]m8lc6cfa113f0li U113n9?C1(J(()(((((((H""""%T((""""$TY(((((JQEQEQIEh(QEQDDDDDDDDDDDIEQDEQEDDDDDDDDDDDQEQEQEEEQE*QEQEQE([dWkl;;imWlm~,[~#WjY }{<`Kb	<A*;&VEIr*6=RHE#zW'RhR)J-KhP(:4[BJP)m
[B)@jZEUmU!Qm
RKhxpKR1/[o^t\vm~}UzTm{>tm@g=wr51wuZ:mkZmImdmV-ld7{[\<p<v;<<wxxazaxmz^^^=$pxJ@dfdD]S]r A	 U,I3 1LfVi,6fbd4JIa36fb*TVJHd430a3f`fflTRfff?vm{n+:qmY$$u+VC`00$dAdA$dA$dAdAdA{6y\5o1V{u{O{6*6**!*!*!i*T*TVJHd;rUkyE5^^v<jYjj:ffla30a3*J*T%Ymn|5kZQ(+$k1$B  T	}	2I X	    1@   D H(  @Q@9  JI@M@    J2h4hSQSRd  IQ4f4FjUOSddyC 4 )(D   }muv*6If(,/JHFL$i#Ilm6HRR6              jH$jFL`LfLc2dXLc2cYcfEf11_*OfgblQAAImRe(dmBsT-`)mJ2N)6Jum

sm?\j*c )mUTk%O-DUJMdSb""f!mQ!&j2*+m,[Xdj)fkbTlkCF1LU3#1fJfK|43hZlZ%66*hM-&fYL3$K3YaL&MYAU*qQFF51Q,R,YXE5Dm!m$,Z%%%I-T}m[&RlZ%RU%I%RV#f$QD[k,#AIlRd%fhE7f4/YT/v`j6j-BT\[| 5
}v[!>e-e"mT^Qyw6+%}G*7;l899ih0bPil4*WV|h>0L?'$O4}e{kNo2FW5N:y2IMia_.CCE^f-lIvfVwmi+@X`KkJa%~R^Bw<t{{.F8OmGsjWUyj.`9JUIK@{3-56j5$QVZ_(9,84tU#p~KUH~	tbspk,NHhj5m[ZEA1XbdP0UbHb1FU,`,)F!,K
pp
m1V?1``~/R1Jb'!Rq;r8QZN'nPQ\.1YL6t -p-u8r6	r0\sZ26LcI4k*T$qF,rtml@V*k/+.jhL$i&$RaLfaLxV6z<CbRmE.\is4dpe.&6n}#nSpv;)[j.9WtkjsxG~EyS)^T5>'\1.o{xqN'cz8R:Z#GjdKxH^k+mp\YWJ:W(:XaF]*bU;--E]WT$+X*kf2fld[Mc`#QDb,bF*IdTI-)RTXR2"H"("Y+$RJY))4O664Qb3&fF'K&+%FjEYZ
*_Kh	#OdtH/13R=Z+0
=GyC+R?B+WF#UDUoztL"nD&'y$L"nD65eM9!YST_?p#kQ-6F-6"ZekcdkXeH"?zc1F1c(1c1ccc1bc1Z1cc1bc1WDDDDDDDDDQUc1Qc11c1F1c(1c1cF1c1c1c1cJ%Z	VBU*1c1c1c1bU*iu1c1c]c1c1c1c7]v1c1c1c1cc1c1*hJ%Zc1c%hM}/.7q1*7q1*7q1*7q1*7q1*0wuFX X X {W	@$	G{jFmW$	GmmcT`-81Fnq H#r@$e;rm7K,[
|wbccZ               h     X -jQ          .A4m@     5HZ     U 5dV   kM     mUskcV{kg"V1oo. Lwl^S}>[{]z]WTxx*q_$trV}>O	 +{O49N=wcu7Tv;{aQ;E[UCM\  	;Uq>ApK4QGM-UQiE)m 6~	|aWld^i]m/DY/aW=^c\iy<}\p  :0[A@-Y".m	Qu9I$tIuRMpY$ m=ki]m
5%U
23].v$K`IBHV5 )\I#By<iM|M*\(IvdX4RMpY$gdjir6USKGuXywtd_ytmQ[)4R\{oDE$o)tL~\6}7r&u"%%u`
mP7phd[ms"k7&@Y5-\kIqv[%nw.]zz;|bjitLe-9I] ,Kd)m)H4Rd[mFmc_g`\VVg""eefy"(ffg""$:C{/;rLDDQ($	@ @k a
WZ_mwejNkd@$	    H HkmM@T0d*QLR";EeeL5MJ\4lpU\'\Cj+r8N^aT'dp82CS
8h\UbRJ (1\\:#QhJ+Q,T+Y<\Xb2T9SJH8r/$<td`##'LZVG+1'U#CHRjqae)00Z+PC'QGTz^<x2Ul:]y#R4f6=czGjGjGbG"|cjp,$bm+<$*T="%R>T0*(UP1TRQL-*iS*,$b-QaL5Ad(j%2CH1 S%eVXAi*2D4`R4FJCss6YbTW#b6-+o@;;U/:9Lc;W)l"
**" "
*fffE" h$E*`+ET*<RIVQX`V"(D0eUFVj*J#QDahT0*0E0RL	0+y"^U&Rmk, 	`     H Hmn!nTt"(RllP'	(P:L)JQI"&ZDiB Ych(61lch(1XV2XU,XabbRpUliVb6#h6$S+~t(p~MdcRIQ<j,xl6 2 6	ti.IQjB"%w(`B"P%PK}/jbZRU%_DR}"GLX*NOPJ)	I1`R_K}UlU1&1X#HR%
x^)Gb1
aCAK2R8QcKPS_iD]8IxIUIw ^W:ma&X {mvD[U=@^'Ncvj*DUd	D$@ "@kjUoP=Mjl9nC)R%UD H  H?Uo""""$"""""H""""$"""""UH""""$j"""""H""""$TDDDDDDDDDDDDDDDIY62Gy&F$}K_E
" yxyvSFy@$	@HGZ|DDGc0PHLHL#H"#T$CI2R%5$CI2n:O$wrH$h#gvFAw/
\.slETD$!   H>+V$K_ *5$CI2DB-$EK|DDG.D{BI2DI2!p(T _q|zBh;s4dhS,c66#+TbKh`ZbR_  $@  hH4UD^8hN* u`UUUT       yZ^yYlTTTU8^8^%u.hdhQU\/okmm#An8:Z%pG6$J%Um%FJj<!#WnAND&I-Xq8"3"+0+R+EEEEgbEg5k8jZbgbp+[Bb3
*"E****/bL?[T   (1 @  M  H   4@ @i  *`"UP d  r` PM	SUT4iR iOT &
H4 RQCO)6jdlYK6~5E+tfd3 Y      l        l h 6 -{*
hVAVV4)llkb+4*AkU&J6-lm)ZJ&"[FHK3-1l=Bl	6AFJ IK6lhFEfL*aMU|0f4_XZqQ5lR-HZm[Tc{X}[i1]2tO<jJ?1&*R3eI6aN2Yp8fLrq2XMVe3TVZ>E2Le2W$$B|(0FGV<_0\3[#F-.z1+sSg!`p+%.?i6,|+Z2iKh7Ah=aT2%eie-S{SF-Q~lfi>09(<M!.P%!Zv,.Q]K_SjYl14dk2h5>+F/#FOB_#dh1m-elLDccHFV222a:,e/VY2f64L!C&)/fF22&Q+1,L(1A&Lu)f1,0:Xbee+(bPpY0V2d%LeXd2FQ2IfTLLTGqPp9pF*OfgW%[mNL>cb5F:65XI`XX	pp,)`\*S.K3ILn*LhLK#`a1K&P2*&QquS+*2JbiAheudYJ;m'&+m*fd/2#LNGZ:G0c>/b
`UdR06[LVeLae#'/:ke6Hb2K/^Di$RzL'4\l>36,GTq}N+q<.ux)dy9]h5Cxu
r2uewy<4xKZHh,,.VLdq:]]N&U{X/<T;Pv&Nk+C*6</i&:2dcd'h.<kHEa	Th&<.XLL1rXPVRiHCP4~
_xbM`HRLLXN`4bE5Yj2dj?"p3Q4ah~ALQ&L0?j %-iU,Y,L,-#$iFa-P '""""""""""""""""""""$#b""""" DDDDDD1c1c1c]c1c1c1c1c1F1]c1c1c1c7]v1c1c1c1cu1c1cTZUaV]fOtg{99'WK.n])n" 	0]Jj]WK8xhjKcj]WJu*8

u"U]3r,L/"ugpkwjUT{3'3ugR5^x/A;\]6VkMSAMMSAKGR4N+KGT899czs/]7A0fWaH=MlM;E6,ek\]3v2U{J5`5J^46h[5A  @    H;;EOEEEEt\TQMS4p88M2Z`EPhFUHYL**P`rhW+#3mFdIC*E8db)TILF,+#,++IpSFb]NGiNE`jua'88e&SZ5:NAOjO0SRGD,W .RzVZ+5c*;%(]4<bYX8\t%<<$zOOle^#8^v1wK1dW,|.v2zS%|!FScJ5V#DrWE8SUee|
Y-6t|>a]4<t`MKQebGOeU#Bz)OT=	tf\2.o+Y\nS"{G )zZ*6Mm+-4aJ5F
H9mvF-IyjU8*T'5&*j>WIpUCfV+<l=W8JQ+>)JU"DR$F#H1$(I0*V QIS,$0EQ-TYU$0C2%jLJh!,bY-IbX001RA1BLR**q'HGB"eDaV`E0XJ4$V+YX%0I	SNiPrA+5#m
uT%"o-`%#MQDDDDDDDDD	H0$DDLl 9%"r". UtK%"8@+Q8RTB(!YBR JL4
1b1i1PP*)2`dMHJ

Yl-$RS%"X6WcmeA'r3 V6FF
;XhmmdbTtN'!=FB"$8RO$W`.'IMT
TU)}FFRK+CBFBj%GDO}/ZBP5Cj#J+}>C `2V,bPXI$}_E*dXAV}2b>UFbK}Ua`bc	FR1*2&	Lz{Oa5&1`$0*|>B^N2*JACJ}zT0vE55SOweMB;****    6i
$'y%6Md5R-TREVVEJ(kBl+[zV[-)45ma_{h-|o{{d0fVa
^jpm=yf{[={4>vhjkhj98hj9Khj98h999b%stc.hj9K:cbL6bjE   (1 `  NOQH"m(D :3X p  NG
P+U@
aEP Pm|\$%*44 j45=U d 'R B42F22ba## ~[`_[fFd=51~wC.6<    UUU\/;s^U{zRB$UUUUUUUU^^b.|gb PZZ`l-Q\.
/R=mR& mU[Z(ZZ9({D%Wub8.?rUR3D2=lmBKUm*fE6geVs%9zeE#9jl/WJKYN</~o3;s6wOhOUYU7-b.hjfZ^{X]_*WdJ~1NF=j_eO%fA_yvh+o^[SNr\Ll^j-KX8{7,|K2YY9o)VlUwM_v2m*}fU8j>'`3d\Wd_JCgU|Zf4W|KUW+29KY!A^l"On{{|%@hDdJNF`Z4l8,e98dZ[kvFfrf'[[hmZB|\,3a
1:JI"1S:IQEd.#*N	qSEd,,2dT,jp8T8q\%ffm[&Y+`8W]\]UuquV%:uK3fVWeaYY&WQQh{q9mr9?'PjqrTUt;r9UpIeQms^mmkVm| r8#l\G8R^{.#,u8kEX^sK8X,XXpc~..1pZUi`}r2;.Y;y-&Ge)Yo4^a\ca=cgQ'j{h<e^\O*xI8TxYezikdmOIswG9lI%a+F5W#ME8I=x`E_Ubc,kXZ'Pmj.KLfL+NLM:3QN4	$Nyg^S<y.<NxN
sw7XxA7(DJSqG8:+{1VLe|3S=Y43k&!LuvACLA'N^<q{u.r^P@sdLWy8v;;'4T{ET<5ih9!W
\u;YW!sVxx-/#Y#,,+d%u"Y,!Tvh+UkarN:(\j,)ZFeJ\]mDIYZ"UKIUA4ZI.,)d\HvHrX41S vY&iT\Z89VC3iNr\gr	"       *nI$MST/)jU{j_DDIc(u1c1c1c1cuc1c1nc1c1]c1c1c1c7]v1cc1c1]c1c6C9P@TUFmW$)$~-4?N()k
v[QV3+M;l
I=lU=4E,YmRs++MiU 6lkVMs4#!t:ie#RkAt-"ss$b+,HHJJ,icXX5MdYl%Qd1F(TY*H(1DQIREE%LHZhlJ~+k""k    @%T}s'J $A,r( @y 0 $   	@$	@[[V)2-BZ5	)+IbdJk)k*0,0r-2Y)51XqI-SQpNBeb&2drIb$dZ$jt%i(P+EEvPWj8\l854;Mrj 0LNJWiRpSP\K,1ZR<2uQ4F)KUkEGRS^B"/%D
<Qy9(gv^b]GW:S.L$MSy4Xn*\vhTqek"+=)9MA)5KDiyP#E<@^#z2:=>uqz!&0|<zI|+,4"RN	d:i{E]qO'zpc+\6l'llW^[G1O=P\).=%{*QKCUE| ~H)"(EDRQLUH1S"PU*%($1i*j4IFZJF(T0QM)LJUXUF%,,	XZBiT`(ih((
C Q(5()Uh*d"DV!USI`TU1%L5Q&T&/
 URN |"" A L     	@$	@J*$WX1lEQ1DmVjA.KUW`T"2Q)2TTJ(>V)Q`SbXXX2X11eX2%!1sKjL[[eZfYLJ53333PZEr9\T{00EVm-/0%W<S(uxuV.RUM3333s&ff*Ir%!:T<L1y!lI<DMvikZ*Mn6G (lQK+SHbY
aVU14Y%2J|K'|W)CE0eYS*@Qj|LJ|C5MiT+,)bii*I}\#,k
W|Y&IK |>u]3|3U[TMb2XL5J2FJ(=W].J,b*=6:WK@[^EsncXjnjw'166*mk8[We]aebm]  @B@  [m  $	@$	wwww]hXI%ymFjj,jVbjFVj5kf56lC(?O*K*m!NCM{k{utWj6mno{;wYK;;QDYmZks{F'!&Cckyh)fn
Y;p{m2)2)2)2ZMj5B!B!DB"D" ZkZk]Cd6 [)n(`l2)55c[XXm`5cV51AY&SY4{ ~  
`%l lE@+@ n |/	T!HCwRIA@h  u jR PI'Rj4(  )$j3PzO P]~W7d=z!dItKwu[5- _/=~}A/=T]Wk m(6FZa6U3Qm{hd}J*jdSAM,LK#4'
)%QDegu35sZm-4GMajb,#Off_e1:ZFhu++L5ivq\Kae6WhGe#%A64'f/J~-*&>_WC	t,Lc4_\}x&Zjhu3dk>OKm)3MZB"H|Y}$V{f'ZKJ-Z,MEdI}&|L&>KTiq-CUK<[cZ34E,-!KH>ORJVIL><+&^a	q%|eO<9<2&"`8.N$S<N)UIqT2bQO2Cb\0`*1LK
`eYeLJ300I3d)rDh6e8029's18$SSq9xR8d_D|VS*
mh,nWy(}y<*x::8K'SWc5F%G}/|r|||>XGfV_1lo%<Jn*
'cs&Wei^3]]q]WzTGyO>?7WimQ[KCCQ!e>/[u,3(oBT f-pXLC~T=#A/24dd)0~;5I8rttv-FGA,<itf^/bfidUU~,,-^Z51I>Jzs39trmx%P*9GNK/,1SL8Y-`LC*Yh+FE^)i%:(e05XV(,QTY)(CV#&#V
Z0W	*V(0]*0ZLqyd?*yN\-LYCzXXa/TS5jWtM]&S  j  "   "mzm@ 4YjjjjZZZZXKk_DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD1DF""""""1c1cuc1c1nc1c1]c1cu1c1c1b7]v1c1c1c1cu1c1c1c1c*Ub6U1,gy3ASXFE)t0;8aJmZ^xFbvk
dq&G\8V	uV[T[U[TiHUdj*dEsZjK`f
3dUr*3O<.&:2FWFWFWFWM]#jC,twcR7R:EeImRMXV$5bMG	
*KG	
*Jh$ef#,HK$	!lYjFjbJ,$eU6-JVHmRVT,Q]G@wU<_hjFVh
Q_4A
m_U[U[~7jG*@V(rT,5V&&lmJ$A
&
WjVQZ+XHPN(854q2rN&,q.,5tZtZE4uGWW*1cSxVNNj:.)K<RjGK5522I]1+IpyGWW"TxH*xI=b-'GYk.,lqa.]..[<Ey:8rN>TMKO
M)PmLj4JV0>:XFV:tPa^GviQrWA_R"/.Md$9<y4{{z[,|Zj`JSY,[Ejt4ak^<NLN+&/VOHb*4Qj*5FY4{LR}h+>LUgMSF#ZaezLPe|
^1|l2fJ!J$W!_@GR2BD5R(XIKRD4-DZZC0&J1A`F(ZUbSB0TUX@!M$JR$d(
(^TK
#"1!hFUT&RUJ*h+2HE<"y+X'T!pJR,B@l GyI%Ej#j#"6"0  $	  5ImgJKP)*`QT)i!'`*EU"U@W(l30E1(V--k}2fH\BQ+Xq'/+hL
=Ty^{[F,_+G3S+BtrQ[Cts?Tm.<UPr!UhVlG8TT;[<
8B%Ed8P9:LIdIE
VV@EF4K_~_a2**AUV"Oc(*	b$SJfru*~I%FbDdWO:jG&2dO<W~KELUc%)$+Rkj|s6t}2c&X2O'W$+(d)WOrSt1$y(ycCGB~cm|;V\ s[77>=o[oZx7m}[[o$Gn5C	([Y[k|$MzT=UTUE*545SU5RUUUUSUC,E-UC,E-UC,C,C/|%EEjj-jVEjZ-jVwWuUX74IJmf,W[TYb. SsMt.GUefKoInhk4QU-WUT[ZSlJmE@ smB]KMW)e2Q2TL)e2LS     \ 	p@@BQ2
Z[LibLvRb   (1 0  ,}@  4f  T% Pa@ /GT~1ETa&"~4# %JzddT(IDJ4?'~,eL2&|wChmY	6w/                  m@ @p
*_P_vRm&*}c,YY$"m/_RQe^m8|<xtu~Sd}OxI$K}}'P2/u1QLc
8C12LdFLd0,,#*$$20fFFGOJwN.]\eb:11|{}9waMjKU~}g/!Z%,*g|B1vSV&SRX$],5AGiUa& SW*eU	%TZ*<N?UcW~;9?lh-         nf@@JKe%}""""""""""""""""""""""""""""""""""""""""""""DD1DDF DDA#DDD>1c1cu1c1c1c1cuc1c1nc1c1v1c1c;1c1cwc1c1pc1c1FPCjj)}?wMO7	7cqv[[ffa3R =wM7vcqv[[,;6;{{wqv8[[uI\y<y<:99QQQQRT%IQQX(*JFQ5FQQQXQQXEEEb|U}}k} 6   &      H KZ` ]WUUU  %UUB	` H   *A HjPAV@*He
SLCi-HK7ms0XjjBNHU)U9\Ud!sWDtyJ$w^d^y{*.!G]P/e^$yS+S#=YgmO '}}y4_4Fp</'Qt[/d,H$_i/EHEHE`*eJAVZ&U"VDa1,,V%0B%aEQ"V"S$R>bN*UYS*CLQLQ22KDhJ
	XRRr+ 6    &      H KCIGSm26  ""6DXDDD"
"""DDDDDDDAb A"DUkjIT\#RPt
 2aJ$J@HV$*RJae+W_8?GG_"|CO8L^%xCO.ab%tKb90\HM+JR^RYJ(VRUE=GO0FUJj1Az^bebMW	{#LKxRuY2rPZm_wsU]]{ $I$3y $I$3umr Un]{M+kh#6?MGGh06CFml1hjj4TZVFbjZ6,ZVFE:wyCl-FVanVa/v7&naAm[#'v3 MizeP`l-F"p0p0/v%gtCj^<i$IAA$)31pc)36mSLe1SlLe1SLe1SLh1cD&42le1pcLg
m2c8SmSm2le1q3 ?PVIEZ   B  >0  *s<:B  Th@dJ T@@Rz04%M 4}jV#13-X)[bvIw[brLIkw            T 
        ,PX * @X-[kVT\c,YXcK1Vc,c1PJATCH|2.|*>(aIFPPmUlk          RMVk~c1c1c1c1c1c#0c11111c1c1c1c0b11FF1`1b0b1c1czDDDDn""""""""""""""".""""""".""""""".""""""""""""""""""""4DEtDDDDDDDEtDDDDDDETCj mP^=+sE>>eHTfT*B/dmyhZ-/[3u
u7]lHUL:^; Z-EfR!fn

<{IIGnnjv;[VsVjsV\ov;ZNkSfsf'k1;YNbvjv;ZN]su7]wi2IW31mZs1kI]Lwj$."3f-\Zb62IvXLNm6CMil16am Azzk`ww@wwwp@wwwwwwwwp@$P!S8$[(j!I	DCU`HCUZUjT*VJ@NE@Eb(#T*1b*""0EX"*`0V*rHRU$]dU`)W&	6km	W(]Uc 1 1lm68t)W9T
UJp
Ur` 	W+EPTx";uHwU!U!UHtPC
H
j$^WwjwUPUUf*<s   @* `   (       @ 0T P@ 0W>(#6ydVj,
*&j16Mk]ahQl-m[m[UAmY.UaZ6aldh0r0%xKxBZKyahZ6VanVanUUVadWr'M6.tWKh6.t)m     
(   
S LL 0 TS O
2d n    S DP p}:0>_6  8Q Pt	4IJLCUI4`5?jT4i)JiFAjR5TIE5=J t6n;f ,ed=:s{[~X0 Xr|^W~;u$/RKUUVyU^v/RH^v/RY[K@F-[`-Z
2V|gWEp$%LSmQIP+*X
*W'>5'T]BK{DIxW#'"+IXFND+KJG*WVUoh,-P4hLcFZfg
Gb`CKiX&b-%j+jR*V1XjjmTfK0pWUUDVXuW\F *X6DB%L*BWUX1UcV5[ukvjkg%2&LZYfDjb 64Xb1bjJm"   " m{"#b"#b"""""0DDDb""B"1 """"#DDDDF" 1e1c1cu1c1cc1c1c+1c1cwc1c1c1c7]1cT6ljUo?R[Zgs0rja#E-HYQe,1	$!fE(I[C-[kj$a2IcVy^wH;]tSV`9r8
B/fLc  @      H/}^4@e 0    	@$	@V%Ir2f
C!YVL
UR9.&WI@V:]EUJG+JQN"Q5RWQ9-JZAj

>>_J`<?:@HsdzG:	KI^+ S(yIB jKTD0RV@`D`D`a0T`V`(F
`0&`V`&`(Q` `%UEI_HD0
LH$LJ S`0(0JQX
00V"0ECjUjeWd,"#m1LQ  @      H.Un$T9w5lmm(V11AUD%%%%%1D+pU
+T #`BN R\N VRbEIllIWV~ DEN_ONp(`+ /izR%FTb/Bz@1JdUda`Uz@W+#V4A.TT^=AW]$)HVZE	"4WW^vT::t@OUYUT]:U^y
JZd$W3+@Rm|uIkGVmDUDuL;m~hmj5+T!fLCVlQejRm+TAi~<o=qS%NCM{k{uM-U.,brk[.&&EAl,YeZ`kyhww-ov:wSLSuNu1Au:w;DEQDDCFDFD[6QLSRQJ5ffkLZb	0$54*A KT[})5m@ 
?@ 0	_ 5 xX7E   .gwy"
 1iAzTIIC&'QJhSM44 #(3M]rqs<{kjY{U.k%X%Kcon;}oK#%M$6I6#k W~wlY6Pkl}m
=*zX]f!zj35pLi\QUOUt <C,d{H*ENW	W
q
(L{B=3m6deVvU&7[PlfUJVrIkVeUV[936frk6U3$TsmJuJc)V6jc|*X)aC/W[4iJ@g mMTojJ2JM  TlM)RH@@ h mZo""""0DD`1DD"""1DF""""""1c1c;1cc1c1]c1c11c1cc1c1cuc1c1cmQmQh-[
?f5eE3H;;uz~3ywo:7]RUmdOK8WwAq1 j{.k4kW+Ic	(HlQ iU	t m9uvy#v@@$l	H$$Z$	" ;A'"u2s.\T'"-es*rKcBr"9	oIoK5ich)ZmV46 Z7{w]gtM4MKf`!eILjPG*Q*R'9cRL\)pGDWB*r.M]*NWR	4iDIIe*,x	'n7xXyq7w6=^rD
!^Q*=^z
UU
@,)FV	++ ,0
	0L,L`L&L
LV**GIDU%(U`L*`&# 
R0T
`0# P$ +"J#$DC`T
pSmumujUjj@RH6"mb.NR$p
	,
Qp`RUpITS+JRP$)Khv-BJCV#Gt}\	&
`V +2+!ed-&bYH
|| GS)VaJ
K*+>eJPKPj>LR\S} +RGQ^*X10UXTrSTzU]8!)+Uc	TT`b=*%Pp8ET<P"<ehsQ FlkF J[UmkT>@o2fG`3m01{4t;x`  f JjZ6)6MJYf[Fe?~fz;M{n=p]*m]9="zg2oyx4|wp	|7v&4kuyud]         mmm`" "  ?e57 *;OWale 	GHH*@   t$ t)T.6UADAml(ET4"  5l Pa @(@   ( (  d&2n  dCM4iL	%0UT      	OAJ*j	  d	=RT)      Qh     i %Jh     ?.wubM;`NI	4;4q:ts{]UW4=-sPZ[zp$Z&PI%`ls{j6   >=qw>j6z\Ls2^-iOjxu`-F7K>a$49mmZ0om*5PS
0_Uh*l.6aX1L1LirmkeJk5YiO}NkVZ8p./Z`|3X61=$?	RcRg<x
Sz/>K%%vebpwQ)JRc)<N@WDK|>]:upb0p\GOtKW{:^%/U^{ry}GKp9<^~kxj~kxj~kxj~k\e}EaU.prytK_]~u/Wxj'*?NN#.Ux~G\98Ur|'w\JV,U?}p%>Ux~=R]:+ORt9+M+SiZw>##/V//U>p+^2>=--jUp9<KW<x'x'QkiddWZdE\eb+W?"+"yY~WDY~S#+Sk|k]nbBMA6YMN-PFV0f$jY,_rQfR,
+?JrYTs}YdN2f.viDQSY8ce[M[4Suddn>/ETey\NQ~2'(_+"*3r!~K*&Iml@DUihjMi^6(RGy6qGN8VU/f+bSe/vp:q91l8V\imEjl|K( 8&zM\Uh`YYDXJ2T*lb"jJ}K1D\Q[p2*]j[jZ[m"M}U\VwXg7]ki12>4*SK.lSJ]u'^~bNnK@ 23$SRR2LTTlTJ6  MIdF- Jb,MlX(ZY$U  "    kmTU?"""""1 """#DDDDF" 1DF" 1DDDD`DDDDDDDA`A""""#b#DDDb""""""""""""""DDDDDDDDDK11c1cu1c1cc1c1c1c1nc1c1v1c1c1c1cu1c1cc1c1]c1c11c1cu1c1c1c1cuc1c1mT8T6ml*UaVFmW    g/fgrldjMR2jpWom_p;Nvitnuo{{nFkU|Zwv:wnrWGNrswnE|i;KiMel-r#vl6&  2Af	 `dH 7okI{.KZsZpwpws$aIi.{wy{wy$1&{{<`sfMmm41f0$0ndaI"a0]rvJIs\J]""WY\]5v\+"]JmJn\r5t+NN.U\1skIp))ErTr5W%%JmVCja+iZP1A  @      H/$$qe-8 K,m K1,KmW"(@ BA DE-*P-m %D D@D9s?eET8hkm(4##5_>Op",.y8W>54zNH8\*WR~*tK5.rpWJ)cUq.'*	~\/^NQpS\KN*pU_
jK]IEWRx4I)WE.Uq.RNu.:K}<KKO}/> We	e:\GWgNu.(:yU\/H'TgNu.U/'tSjzG}Iy?NU}Kp?}
c>j%~O~=NK\~*)>9]=SWT}_R\G7WRp;*yU/|O,8/'zEKOS]K|%#\]aOt+
Or}<>}QS~OS_KTC\0]2NV_?$\GI>i"_Z~<].#^ELWRq=TT^tt#;>].#NU}Kq>j*cO%aTtrWRq>"ztU\+$'z$sNgjKTKy=U}Kqj>UL.'zPO>yU\G%#{;U\G%R_?]_K"tQ{>}Kqb]IOJNJrD>49>jC>]sCwOwOmmV\KW_P(eN/WUx&`ZKGKJ~a7)W*{A|!Y.@Y@/UGTzR/j%G}i]"/Uz].|>|Kx'Uq.@GiJh%:*G)BzRRP"KAh(VhKFK+&VLTHLb(ZVZV!V11c1j+jZ4ddbjUimmK%V1iFF,Yi*M,	li0`,l+SSIVik[ddbjSf,C[5iM&Z,%ZM23J54L5cM4mk##,KU*6YeYelKQj-!0L221bdV4M621bdV4M6%ZM4##&IYe[i21bdV4M6%ZM4%ZM4%ZM4%ZM4#IYeYe[fb,5VZ+SSILiddbjUiFF,Y,XddbjiZVI%Z%Z##,K##,K##-4MIbK$$Z4M6YM&5j-4Z!Y
%JYekfM&IV-21b%ZM4Z##Km[?tsV9\/WjZals+C&29V+^U{s\+k$:u
gvtN.2
sE]](WDV+/IJ,Pu2=CRVK	jq.!XIi8'+JK+T+"%Rq'
'=E+Ih`TF)0#.)qbi$%(*+%UG\Q.J5Fb(IZN
*Y	eTL"YbIX8+*K&C+Wq"XeXb+qK)`K%K$%,WVDST%,R2	`$)%P%u^"JrJ8Xb&D'qJ1aQdK/;]J9]#*+[KXR
TM"BjVHS U [;5\5k\3w;+O VT	bb&QjU
41YLIIXDEVU0'aI'K)4$0Q)	I&UJ2d
+.+$]xEUWjdQaY1Y2)*bDYL)LW:ZT1XHY2*]Fm1hEUF+mM66"<@<x"x+%AW8U]\Hi 
&eeX22RqpGe`q[qw\VZUOPaUa E" -*,AM
0EHG8bL+	W5UWJ\cUT	B8p,1
XC8HU~#ADCADP1A  @      HmffpG^+LN:]Wj`vU[TU\uGe]]"WEDVUvFhL#8(\eW\\qWP(ZHAhRUYR `,U`-$Z*ZZ%'1xhUtW5s*qWBUSY*Ybc	tqLjJT0uj	qj	ueT,d&D)hQcb1F!dXhQIDIDIDIDIDIDIDIDIb"H6lrORK-(U]v

O@=YiYeK2=J\eW\\qJV@`,,5Ia +HiT/WWmSZU\te]]Sp\U($QH:8]ku](:LCtiGWnp$]rIX"'EVYhMi\GVp/R%/IPY*Sx	:jrRQe\\K2Y%:tf,WWJY3)R	j']uI+%K*VMy\es*bM \$@=R*F2<%q-q*m]J+r]iGWlIV$J\bWHRK1f,cN	%H&dN:Ddu]20<+]LCG	1p1&R'W\R""=%y+-+,fG5En8YU:x\FwJ89LW\#D)IH\uPJ)](\n.+
#4BkJ.JT[Vy+.JJ;];].5vp`uu\CtU:t%1HJqu:u.kuwWt$)	+++ExEJf^JBvN\s-S%qWuWD'N8'V]]\N)	u]u)SPsJwRee,vVZWp.]Jv^+\e&\Nv%pWT	NQ:eRD|A-
Wsf[kfQII^q'
q[-a%bQ3+31g]zNIfzN88mbJ:,Yz/@.u{^U>$p+^:_R}GKp9<^~kQ/u\?NO5x'tKW{:^%vvv<N})*{GUr}Qjy9<:^%Q.|?NO:vrytK_~K^'*?NN#.Ux~G\9>O8EGjQK]998U/^|/|e]:+ORt8E,^}!vW.vW{WKt<Sd=Wt^%jBVF5$UQUhDEW~+U5C<y(Qzy(QWU|@>*W?C
4DbiTRp/i\O]<r(UZj2$]1]-PEtjtB
WOM\+KdmI-P
Qxxx/_Ta~1|a(x/-Px^j!WM_V~{N' _%_
qT^O%hZ*ZX|>~P}>ONO}=}>_5U-kYHj"PV%H2pS?Kte0@]JWjbe8AzzpQ{UK&USRZ2zj^)LiT{+:!{8{ON)+Z>5p~'z8E/e{<N^n!~)+Z2{j_'x|uK=J+x!{{pBOO|dLRGRr"q}>(%}8W}_Od//|>Q*|RW}iOeU?_^|N%Kc/Z58B%:*^\NqI^!:0Y*^E/O%~W_O~+HO}v\PJ!(+kVJ/on"/HOI?BRNBiCm2P4T!9/Z/Z|*_2|E"OU/A!_>A_IN:RNU%~~?!%E_21)GI/~.7;&+Xcss ]m[S .@%	\kM[V%(%zx/2PQ]\dRxv	{=":E{1HL[4	RcwvElsl,,[+Hnlh7.n4  
-e-V,  $	@$	umEV!6mAQ;.\p0;=GbejcZj6+emFhblblCej-*X6VclVAzG?)R1Ke>mq3'<r>sT*M;av_Bp*#DHg27tfNx lRX*
&ZM;e.D2IR2I9^]B(F[ky9:
m%	$	!T	GUUmI,:NkulOmLm'6mII+HLbJm%oI6 mH[3mnp0af1km`mnc6m1kpmlOmLm&7e{Ysq=oI6!F36+HLbJm%oI6!F36+HLbJm%oI6!F36I[LbBI[M&1Q!dMf$4;n  @Q   )@ *        IJ   (    @         @`             = =mz 
(U?TUCJL04 ~U 'Tj 4zjR$C IUj465G<V+[8eZf,%$2hJ3 Y2,fd3 YAF`Tjm8z]uwuO=         m@                           m@ 4 ` m@         x8h 6lBTw(kZVDYY2e+1Vc,YYe~X`0<!A8I]"CWqCW] 8@q=\@q=\' 8>z'P' 8OW 8>z' 8>z 2}__@q?\@q=\~zqqOW <N> >':]}u|]}u|]}u{    @?ifS`VhZM@ ?6S1mMcO@ ?lY)mVO ~?'&l&E                       >[4X 0@ 0d$m 
7mkvDDDD`""""#b"#b#DDDbDD1DDF DDA#DDDbDD1DDF DDA#DDDb"""""""""""""""" 1c1c1c1c7q1c1c1c1cuc1c1nc1c1]c1c11c1cc1c1nc1c1]c1c1c1c7]v1c1c1c1cu1c1cc1c1v1c1c;1c1cwc1c11c1cc1c1nc1c7]v1c1c1c1cjJJjT6mPCjT6
T**)al6_wwuU3;[K v;86pmv;t}{kvFQeFQ{oV-.fwC\,wW9^uyx"\l6aUwwm;t86;tyN<nSO)QeFQ{oC1It!".:3
BPT6al6`a{kSg<nSO)=^{2(6plp66RZkZ""j)nk;unxNvs\FFGO#h)O#iO#iO#]xgtYvtYmjy7m<GO#&O#:O#:OuO#vd]i`0ny<+vm=im=i{t6egznlWOzOn.v0-<3]]<;8a.<3]xgexvp[vxgYvtYmjYm=e.=4TIJM(hW58$	@$	@& H KrUH H L	@$	@j69UZ@$	@$	`H H*+ A+ A*PA ` H      @$	@%Zz u  P;N www]Www S 
8    !Bw(B;!9!B!BPw(B;!GrUmj\@hS ?rqS)2 :*]v'W^I@rqb}@vjRuJN:P=zz=IWS^S):}@zzWd'HtW.' :J^.']x@x'P=zz=J}@quu:TP uRuW:}@zz*N:P=zz=J^^UE}O(UxOD :\~'P*N=xuuTz~=@z=@z'Yu=qq>:@RWS^SRuT|uu>=@z=@z'_]OPzOPI}OTRx! ET{W|-
\\OjP^`zOPW|uu>=z=@{R{ jR ER$+X#&Yffd@dY2eff@dLe&Yffd@dY2eff@dLe&Yffd@dY2eff@dLe&Yffd@dY2eff@dLe&Yffd@dY2eff@dLe&Yffd@dY2eff@dLe&Yffd@dY2eff@dLe&Yffd@dY2e@dLe&@dLe&Yfffd@dY2eYffd@d&Yffd@~G6-f)6ChmVelj*L)JR< q@UQOA5J@2^)KU'R/EQhEREx)j)KUdYJZ"RE,RhHKx 2xR^/xRYaR^<@g<,xRYaRYaRYaRYaRXXBQi*zG'<,<^ 2G@aTT<dx#RS 0*Y*dK%L0dF,e
Chm-fIZ5K%L#)b`HZEX&L+J1FR2Qb-%?OC8NEYQuQrY%2@t<@u)LW 8W0Lej  4Umwu]q%X^ 2!	?(=))jACT!bU1Hb*1LR)ES"CHbA!!WqyqJX4)DdR q q U5UTTX *	k A 1 A L    "# H3m<^&D=<@dC 9 I1AHe^RJ)%SC	T!bU1Ha*0LRJ)CuHqK\*,\RZJd8HK,2N-(ZQqbJe.8^V  2""5  2""5   ib(DDQDbDDDAb "" DDDDDDD"D1b lgHz1!8NJC#AC	T!bU1Ha*0LRJJ"J"JIWQ&D:x\R*Yqr2*q8(qHb 8A!HzR@a@!x."R%2`p8/K2fRT8$.8IR!!!@rHt8$:#CC!"."R%0q/K2Jd9H8 ^:<uHgTD9 @=)D]R!!!\E\EUJ8q8JQ!!Cq )H]R!".".Rp8*QT<qrR))))@8!CE\E\Qp<T..,Gx8R$@q8R)
RRRRE\E\UQp<T..,Gx8!
UQj
	mchGKT2y!Sq=OW 8@q=\OWqqOW\@q=\}qq~_qOW\@q=\}qqOW\@q=\}dO''OW 8>z8'zS:\@q>/:O?P%$H	1DOQ~"/_"E#,///E_Q}E_Q|RK/_0JU}}vJvi%9 -%<) ]@=EIM -%:]r?Sz) IO||vJ@>"S|_SZQ`????%}C}>>>C}????U-(?IGe)"W]qJq^SRQz)N/^<@zJzR]W^
Qz)OW\RS@|E<R/qJ||x?_/YKyJ/E}^//~/?	GR_^)N2,YJuS<*u/CSQz
uqJuOQz)O^RP|S)>><RP|S)O3(iAT#V|s
PJ#TNyy/
)#svSf6lf6l_^}TH_=bi(~>u6lf6lf6l^]%O~|E>/RS>=IOZJ|S#}w*      *;y;}J *    
yev{;{|U@UUUUUT     UU`1  xv{s? ^VVVUVUVVVVVUVUO2jFy&4j 
|mmV^hmmVVJ|W^@[gh ^+(lW5{ @^+{m^W>x">Q{<xx H H @$	@%m[[QMlTvl-e1F[Vbwu[V               v;et                rjb6lbBla\ i*mZ5lSQl[*4l-
!@4HP_o6(lPCbom>8nr8t;q7wM  WLLizCb6(lPV<8nr8t;q7wMn;>~_q}{k(xWx,j*a6(lPCb[=m x MnUUp8t;q7UUUUUUTwMo}	]{sRj,ZYx)f-R=UUUUUW=^{|`>w(8{@iEB*U qr7l;pe]t8bvUw(8L*TT-2ZeQPj4^rxUL*TT-2ZeQPiEZeQPiEB*U!iEZeQbTTVnwMSv`q7l;M*;t87l8vlTnwMSv`q7l;M*;t87l 1AY&SY1[   
`M !D@H        c    w*%        (	@    D          
h "{" Dd2`'JLdR7S&GFIThm#?p69T9BF9!00[TliK6If,%|WcjmoLf@Z24,fd3 WH'{I+pvl    j}o8yCeMmj.>}U;]         h 6                 l 6 l h 6o\w] V[UkLJBy	WZQ@Z|

hZK6h^!LYYCef2i+1Vc,YZ1~abdZG_8mm)Uqzjj ===?Q^3<x8KKKt<x)<g<xqx'qJ.^O8G/|/E</_9q}sN/Rz"^E8Kqz9./r)\_o\Sj/}sN/R"^E8Kqz9./r)\_o\Sq}sN/Rz_RO^9\_o/OryO.NEz=IrQrI/)R^O]T^I_R|/R./N./RzPk?Li#y\NRc$~(f?P}y\N%U66PF	LT0	dMK3$>v$}'}Iq83bGy\N)WC1?_3ZS4kNN7 dfbZ-%:`KiKM-vRD	RbGf<'+!$}&cqH}u^jm6AwkZ@zkI[S -hj5UY-e+*?Iq7l#`J?Iv3#jbj
?'!hE                      !DI@$lTh 5;t2#S 
Z,)aa4ffmVD@ @@  A?MkYZ#b"#b""""0DDDb""""""" DA0b 1DDDA1DDF DDA#DDDbDD1DDDbDD1DDF DDA#DDDec1c1nc1c1v1c1c1c1cu1c1cc1c1]c1c11c1c1c7]v1c1c1c1cc1c1nc1c7]v1c1c1c1cu1c1c1c1cwc1c11c1c1cc;1c1cwc1c11c1cc1c1n[
l*UaV6l*UaVmPCjlZjZjZmm /w*_~9^["g:vyN)<]S)g)`
`Jclj/wWvJ,r5dmyMxp6< Wl ({R-KR-KR= u:0SvyN<]S)0S4LLqmlllS\p6{*

jZjZP*U u:0SvyN<]S)0S4LL1Uojy]=u9sb{<yNu9:s]ILX]{{<v:]<g:vxRzdNiNzdZ:f
]@uN<g:;naz]<!g:=vx u<] :]@vx
::j`:::j`:::j`::C6XmVCF6b*mh*``0h""   JRI)           $$JRI)I$$JWV{  y*mmZ   6ZBUbUUU
((ZkZjj("(;':stNqN29]:s8NttqUrQeFm-^_i$<yO$ODi5?_/O|.K(?%I/j5EZ.Nuy@q{T_	K_R|u./jUb9K>/O"G/RyUU//*@}.KRt]qr\]T>/)V^IO*&PE)(/\\H*qr)cKqr\\e..E? \_S=}uxLR~<yx_A=}y~%..E?Q#r\\|*r\\|PO_^^x\xg/.E<D_^_K.E<U/O%Yqr\\r$zKS*/.A~TT?)QqD$>J.=\\H*1Kqr\\e..E? \_S=}ux?LXx%r)z.KO+9r\\~GS~qr)A=}yz^%r)</=}y}/
~?%\('u..E8
S#^"!^J/.E<BO|]$+r?t+WwO-&FdZDjE\]B%_.d?eO))^=S<)Iuqr)P|~S<E$0~U^B|K}E:.KN^:QV.(RP/HY P1P2F-Z5J-"&VLY2"Y2ed(!(bX%,Tic1	c1iZc5b2230SSJ-
bbffdS"dXkY,Y,,ZffE2)K%LbbffdS"dXkY,Y,,ZffE2)K%LbbffdS"dXkY,Y,,ZE2)K%LbbffdS"dXkY,Y,,ZffE2)K%LbbffdS"dXkY,Y,,ZffE2)K%LbbffffdS"dXkY,Y,,ZffE2)K%LbbfdS"dXkY,Y,,ZE2)K%LbbLbdS"dY,Y,Y,,ZE2)ffdS"dXbffdS"dXkY,Y,K%LbK%L&W6j.jbl%'	mBUm6lds+C&29l-rRq-(55 u\UN&gK	
XRt(vJ?A>	CUC
A(*8A29N	
1\4G
QF0aP+MN#(TFp8jRddhQ#RW-UF$BQ25HjL,%LI09~J.UQu%R9NTF	(j!'J4jPCj58Q#TFpRL)125rTkq%R5Dbe(j!)`%KE9rQtTG)TIp$TF,TSUQQr35PjRbJ5DjPA
J5DjPQ;56sh,UrVj.J.jETS,)+&a`S(#
D)0U?+ZUIdx:2X1Lxxxq"x,./$N0e(a'Mkjm6*[Ebd6RD
)^%%+jv:bE(\\VV+YZkEr2XfMUUh*K 0, ), *XH`JO+	
Yt8:*JNeP`t5Dc*6Cl m6   I)I$         I%)$RIJI%)$1U^zHyey^P+vqBvJ?+.<fE3H)aJ](#U=BF i, RXTII`R%%EK 4 i, (x*OvRF()] GEdfa#!:e)pfRd[T D"+b  &EX  @ b0"("V11FJJI,i)(fIC*JJI,dII%K3d%%)(fIC6JJcmeUzIWaUGU#%S2)aJE2)_H"Q4$IJR&&"M"2PXW^We+vRGn.JWt:Q.:rB]1&vLuJuvLZQ(b%Lb"S0~(ZRGxB.IWG)WnJ-S:+NWV]]ZXD?UxL^ pHJ='ZQkPZGZ:^<+:] *;iEt:KNLt%R$+]ufuL]kUJS%Vm(vJ:BzZQkPZGZu)]NSu*L] ;iE:EtB+n'm(uR:*Z/%QJWku*Udv"]:tcM!-*rG'	qvQ(QGZTf+)t)u:O
.:EtB+D-iEvE:TG.X(]J.k;*tt;.:rB]1/dH$ [[-b`/L?qN.kemlT(3xqqxqg'x
]q?CUOST}<?.8?QWzx_}/q}Kqz9./r)\_o\Sq}sN/Rz"^E8K8/KO./9./or)\_o\Sq}sN/Rz"^E8Kqz9./||O./ysq%|/R_o_O~'i=I{vQv9(O$SiETSU'qq}uRqzzTK%(,_YU(!>}G`>|b|>#~{Gai$&(_Y$tQ#$8`!:-]j0`LR>'jW=8$}Uh'zd<TZ2xAQ*UTSbbz>OG~O>|=|>{=>J%T	Tj#Q5uPQ>OBATG<9T>OjW#DxTh'zdPt<B/}_OW\8|_a|_|?{^kA>GPD`A:-]j0tT<NU	Z<rGNCDxU	-^9T<OPQUA~)LJezPNhsJS5uGqH'QzGz+O'xKY*iX0Q-OOt}
<(xxpPEUG{      }!t
 
    8NtYNx    F$	$V I w	]^$W**UUUUUUUUUUUUUUUUyPU^TUWUU@UUyPU^TUWwwvuMmC$Ty_ZrEn H H $	@$	uW+W+\VH H L	@$	@T[(4MlmF!W0m8n H H0$	@$	]rEkH H L	@$	@V*&$	@$	@K@$	@%m\66+]5  $	@$	]7-\k[  H     A H H\Mb66U~o>Ql-Fl-F/Y$<HN*.r6j6j6j*,qwb^-m=!Fl-Fl-Gpg2tx!;xT]m[UTm[m[UPUU^YIZyZ6qiiooZ[Fl-Fl-#zYQ;3Q[zp0*p0p0*"W5g8Na:fNa:l]4Nnm
I;:;	5^Hl4$4y!$6,<hCcc,Cc#!D	$!e#!.Yl6h H$6/N^6/ty!zu:^Hlb'{sev^Hl7;/$6$6wyBCG$6V`N:m[8nah#!Yl6HCaCaCah"6dd!#!q@9l2]l2]l6$@C,6dd!Zs;(=!Yl42CavP'NzB2heai^8NbL.	y  (  eC{Le  BDR   yZ  0x H " f*	      $ 	         $TBt8!'o* g B)U*     JR z@  EL  d 5TTi214 &Jbd> f4$?<,_{7<a6SC9h6h6~*f%g<UhYeWZ,~*w\        *|E~o[m}ph6U(XmQOD9D^hklb|H?"$I6QT:Ou*^e_(FQ	:0
;a7/p'	Z[j7BEnn>|~YcS*ttjeSccT;}%}%}Qn9Yb|=*FCmmZ)ZF($1`{1XF1Ucqc+&1`11CW`j[;qEu!unvgxJv]RTW.qNZj	Ce-ZCb+AT2Qd0CbC*2S!C(?xb|&S#O\>r)9s[9<y\Fy#<Gy8p9N>c99999l49l49l49>epU_R-6&.[}#Wsj}46&1esjri\x|Ua21dp%K25kXZ1F;rw];
\aeY.L8U>yWxpNNY;'Xd{LR0~Q\M^x;Hu}g~*'||_HpFbezW
~^L8l<0uw_~bT6	{_T5K-}+5C*AmAh0-k,akQ~/E(E"$_|>j7ZvmRi&\_E"$_~/EHI7	uu RDU"<&in86 HXclUlSai[m,4fm@UG_TVRRjjjngVkZnD&$$MrHDy{"H2$I"H2$~JJS"T1fAZ[J5,RMll@@ " DF>]mmDDDD`"""""""0DDDDDb"ADb"AF"""""""DDDDDDDDDDDDDDDDDDDDDDDDDDE>c1c1v1c1c;1c1cwc1c1c1c7]v1c1c1cuc1c1nc1c1]c1c1c1c7]tcmVT66mPTm-? 	>/Ds&UcxppyzTiOVTn/;!%no5-:@=P{erwo<x.m\WUO[gUx>lL :avQ8{TAWAQHu]WDSprVDFs" S/sYsYqgvmvkLYYR:R:^..`/@[Lgp3"g3;mD9m
m;]5k={tZl!R:R:^..a2Fur:jAVB`C+tZyQmMj6cQmW!C B 4R]RB=4R]R 4LD5I5MUuU""@VmBtI5*m%/.'?yTRyTQ.L*_E&Ka6l.42d&KI^0_2_RL2d"HM--h)\ifs6Z^*L*M6lzesRz{/jW2UK"UdeJes!4%z/}E?-iUJ&%j)4lUqNeY/}**N,(oIYet,*jY-IL]ld)Vqe^uzzOgzU~if*S?;4E_]e^zYW^$ }HrT8
8F#:PLWU5b*8}>UBSzkM,*6l?$zkM,%__q,S5MUhtNeyJ~=
U]f*%:DN;8le^DVf6YWW_qf*f*E^}oN;8{=UJg==*)Wn6YV$~n6l
Ue^~UE5'J*.st	t|G*p58GQ8
GbTKSjh|4=wOV4>]kwzMaeDIR<H{<O9Wv`\YUe/uQL:WQY%,$eI.~;y~V_JWk]@'V:RL
[JRW}Q5Wuz?Qhp#26HpG=h)Q0CqK'QAar,*\>6l-bBU/KJTUI I,K"deUYb2ebL&jYFQbbkXa&Yj30R6l30R6l30R6l30R6l30R6l30R6l30KKK,fJ--,f33	*T6l$+jjhLU5S)e,0,jZ%JYfJYfJYfJYfJYf*ZZYf6ffTiie6lRlffeJYf3mRRBj)2*2bMZ&LVkZ2VZ0,jZ2VZ&LV0,j2d-Z&L22d6+RV	4QZjZkli((VZklXDT6l$*ke!+&L-ZjHTiiiie6lkZ3l0XR>8EQTV6+Wy<yfK`lVdtgVU+dN%85[(r+].I"/?PB4a\BUF&dW&qp8J,X*)'+$pRI9\Z1	
UYVYIK\RqQMH	eVQSPQ2VY"'/c*GTT
r(pSIG".p
i(E"W"WRSJ+!RNSQFUIQ
b"8B2,)SJ &b)a)ocEnOSU#*"S)Q"SU#$XK%I#"S)QkEWI:9$[SU#$XK%I#$\TR4bL2T)aCim[WsV9txIQ00bV!`ef)KX(a,*,%0JLBX1H&IL,TUJfL
[WkeaHA/,U#%Y2&!X<Ix*UYJ:U:ZHeVLY2T[[)l1iZ-m  FV+$xxxxtb+Jp^MlY])")"3-DC9qK2H\RzE`Z,BU4E,dYT(!'x2\9N
	0b#Pt:U%*# Q``N:*0AB 0ME^;qn"E*xUaU=9g%YQG8.jqdITT
L,"L%0XSIXS*"
,)	<l]Hq.\UtGUYu2Je&X:P)j:S,i"*Ld:tUz|IE"#
R1/I`c.tvU]]\QrH
^5G.4*^[WAB)E2,X*"J*X,B,!#%Ix.5apJ.!W]Pt:T.QU`N8vJWk)\]\-].KWkbq%n8^[WE+U`yU\(MUW.jUqUWT,aJc
LA%10uquu1ST:tN
@yq9p(!%"uAz'Xkf8[V5sMB^<URqGFpI\YUWTJ_$$,bt))*dL:TSc&2bTUNW*lO9^j\c\	i*nW$E"C5G\i-qq]Q:y5W.58.*2!\WU]Ht:QUueN:tP]54A.Id<X4x8Y'B]r\Tp(pBW qUW@:%U]Yuuj*8tT]\5UA.IdaU<rIm[,\x5W.9Fk5NpqUWU]t:T.'(pNRCZvZF#vRvHkfYaT[,GWC^j\ke\UuUWiPt:J N:uR(D)QW	B1bMTc!RLUH^U'Ubj6XI#2R0zC ^O >R[KnUc'f1'f1'f1'f1'f1'f1e1e1e1qTU/i=^DK1Vi9l4m[.M<>cVO_L8|Ua21dp?uoBT%}.OOLc*}0*^?ktu=.z]'Xd{/TW>k]RGIW}Tl%9;<>xW}T.NO>c]Ves!z(VF("JX
JQ`A? rrA9 rAA9 lU=^=UUY
1I1j&@dj2iLTQbzL(xTu?'tGH^QQXq#uxz<T^Z^5	
UbxtD_}w*b%WT|>K)z<pK=N
W^k+J*6Tmmv.E)0-?{a?( @ @ @{a=%&&T(Q`CiTu}>)EVGUrR<<9QW84z;
9^*%QcQ{sPv~+c~NIW]iJ%6]]a+6IC;TH:[<	[[_W%U/gg{^~_*U~'''''''"99999996r{=gd2_(?.'ir'$\NU#R</\.&G*:HUzuU=.M=HUx.GW_}/){6^=9Ti4{U{k?t$^^mk_m@[H?EGU_atE<W$bzYm=#[[5^#]DQAFFD!B!B!bE.T>>Ud2T^~?!B!B_C>>>d2HLK}f1r6l*=J$eWDEU%P+jmml{*wiWTK\}XD5STI.*q-l-[$Y'YRN   @[J*$$ $$"BI    DJ*:$rP9V##'_DylCv2D?rL&Io&HtLO	"">1;=k{3f1<wDDGPHLHLPHLHL"yDwD
"/tB(#I2CHL(CI2EPL#H"D
#PLT4%"Q
#PLT4'wpqG$wrH${y$ID$IGw]"H#/\'IuLKQi&HI$FaQi&HIl"(!QDJd"DFds="""{I&I$QjI&I y^^y,np>|!O+2M6m6Fl`3d C_{\,Sx!j]z;vYvv7vn$^GI>=McYvv7vnI-z`sTU_8f|z=h~{Q{80vqyy-Y[4][|mppp*98Ts:tppm`km[vmmmmnmmns 9s 9
2|-   	   S >'T

( ePh k3*rJ*  5xPh Sz)FAhI DJC@ )(R47|lSOtd         4 `Am42j,lQRdmZb
X[J4-lBic1)SffbOm?zcfX@65k[Zbjl3kk5BR6X52_aaW-d&"{jC)hGLl/=Z{kX_^f<4<31G"_lm#T:b#5UI|lWxq\.F2\~/[-1/3*5|j3
Y{d^2f%4/R5*/SJ<5y{2nNZn4Kbp-3:N*r9N+hO0V-!i4_MSj1LI|TH|1&2KXedSdc>Xat2gdG=.ZEG.!2ZU9:8qK
9`+Wye6,~7TQ&++O('mUlljccUMQ&fLadYTb`beSL"XdeSFW(8R\W*G-[*Rq,q,le\}.abbRVV"qB1G*8JT(p"\ciY3JnSIqS[V&YijfjXVPp1bX}1c0c0{iKQMFvbe-T:NLLN$'S)j'nPtY0F%IiaN,tnBrb&UIf}f}y-iFR2LDJL"ij+2Zy1ed6E2g:2dFfT<(0F+#]MwhfeGuSblu#mL_cT3KAmfZ0Ur5F~w3f[7?ss/'!N.KYud,VZK]aaV%Ys;u\O#/
M[%fVI{m6i{9+wt:G#]\L5e'x:&#|Y5mlq+uc'L|VZ(V|dC6Gp\S:5JbjGgx4u^8zVbdrxi8!c[]<,X<)D4RKUWT*]%:]U|A_=[5j	4[MZ6j4fBxD-W3fJd_\.fDaQs[XX~Q-Z0F%KH?6l"""%1c1cu1c1cc1cuc1c1c1F0f[UV0ivzB4c]9:W_p{uo+ZA=o8tVZFw=wwna1sy8J?%J1 	    $	@$	mp-`Z	J]]].V#UP(ehQQGdNS!0XcKh1d0$TMC\W"Q=WY&:!anq9dR)bqsY.#&jtR=CZyI4RZr+riZ
ifq8!yB^	W^qWV'UyH^
R#$0*ZK=bb
0jz*&=ReGy=/JlUrVB{,]OEBWG>)$:)=G%UUa*I!|U>J(	W zT>YG:6#zzuz)j)6v'.P++	_*0Cl[-m4"m"[ko[oE>:*>=TW|AKJG%_ThURC*!EU`R$C)BD+ ,R2bH*C"A2)U,eU4XE),jHjDFJ`S*UV	V+")d%XH*C*?PS)@!%"V(j
FR,R2)B"ZLaS#*($R4vj$"P#  @ 
-@$fq%JpSJSQ2EN)tJKN
W	vIB"%QpG
CU LQ"*?RYFF6mYjLXY&,S,&,U
*4(r3Vd3LDZj65cXTG.V+ZJMhPO
]
HujUW)Kim-d$W>!{K*es"/Dm-6jW"^!xA<
a*DUm+0JQG%YRBBi(YP(d_P,%DK iK+ES~?XXXY)R*[	_Vh#zLbI"d2L_!_Z+FfVTd=/O]?UYTe*jKbK#0WJ>G!O;8U."ERHV#fjMVUk1>
aL	K-&`*^]wmziNv{})k{{n{$H"@ Mmh"D!!"DB!	!66almli~bL0   (1 @  APP  H@  (*tDE! (K` A
4SUPA)*2 FmT 5(Q" RQiTTfM<mxiL)34I04I04e   @X * A` , a`+ijmlEC&mAj
+f6F G)?URfe	'fU_&hbcYf0Jlm i&h2kUcZM66p4.eCf	m&ZkL1ud,Z
c632C{8}qy;OPzlf
/U#22A~^!zal]eXdqiO)KLk3tN)8]f5,,Tzj=}jJ_1F&cQffb|-bR$?px7jz/WsxY\Yg18Tr]F'2eLX24#*B\F.%:q$N?B)ddodeS-4c2e|YL&z2F0-kFbS'fmFfOA2OX'xb:1)U,[Qa6?Z__EOaliX~2
Z4-Za]eV3dY)&"xfC3hUW"F	dTdcPDf5,Qt*1d&M"eQDc&MT5$Jf&aY2Q!utWYSwmU+V&11c/3a+ B\~O%dVXjLLUM)alliJe&_KO&>+q<1\2*xbV,riNM4\
<xg)<YSZGV)uI83>7}3=,FbZ-PeI`YC#,I,(gN812r]*p;T6fcK3e#:\p:]efl6k31dGK0YNS5&%4BCcr]w[[Gu`uSUV<lybz,\,lYjpkLY\	._b/mhmqueck.8{en:gc=55_q]4;J8Km6\<NSU=U]C.^m6r.Yj.,\9>dxQed8=)pRw"GuhTmv(y6.#j/d9KM%jzxoUG
+U4
;+*HJH/UER+Pd_h#K4KLG)22c..UYj1]6] )l,Yh2ejY_S?lfc1c1c1`c1c0F1c1c#1cc|77"""""""".nnDDDDDDDD\QPCjGkY>;rg8`<$<*5,<v/xwA2/	.ZCPUAUAP#j*fYZ--Z'PP&5Mf66f66ccaf66y?Ml_FiF*V^}Wr5HQ"VbZG951q4nSim8+"\@e8ETW(Z4sLqr)vZ-meNA)INIQGJqe{RGR=*5&S#q<JVWN\2tSjoNA
vOyE*QyYlxYcWgg&ZYGDIdU1#{,hU]O:u4|pZ4l|922iG9*xUzZF==J^=*QC(yK8jTgL!VZg'UeuW;y={WU>(_2X%E^O8M~+24Q5<}>:+\E>q,^]N#@t_%")C*
W"CU8/I>D0quXQrE-b4\xdv|t&UN!4}!Ck&&*5Q2%qRu6"'>|Ejlf&Vpf}}>zlcfi4+x1v,l/p(yPCB*(O*)S2Dh
*5JFCP0LU5SHMJL0+%-JhjDdFT$XBU*V jC$4iP1E51U4(h,QC"""EQCAV(_
4ZF(F
FFV",DQK	MQ0&LHQi@5S\4F"Bjj*W q6P0Z21N	UbHPQqE)%
*.PJ%$UB(WJVT(|(6ZbkXPmu6lfL,dLX2Ij*#cme	`mK`[)*k1p6[[YV%8Gu:+'j$'1	C{'Wz)FTzq4\^5y"mml
8Ut(t)8QJUAZX*F!RhmT>>VK++CP_V#ZC*%*12%}~Z%EV ?~j["OU2La,&YVa$X5Q#A4WXcff0REzW%0h%zEGsqfqjjjqWISifbm6Ffx?~o[DmUUT{.&YUUR[l*fyqZmo|7v    	$jY  aF    ff@	$ @	$ Z f& dMeH
fn  @Qb   )z>>@ $ 4P(0 B@ R 1Kf4J@ j{ OT4{h RQF&M>k,%5,]p     4 ` m     VBllTIiU6m#dl-Q6EcLfIUDUClkmmPI`=m'fp(_mP$J =5a=|?6z+y^*#ZX~`3kptu~wUe_5i>bfV6`yf?eFbW&HxyV^5<6<v1kWe_lYdHZ}hkOF2#ZXqQ5Sc`(ci,6	/jz-Sh,eOXAjpp!VuIZ5Y
a6(_Q+_Q+66Vm+h[F`KXaY	aXHT,V4JmBj025)SQ2JMrP\TTErMLn}T1!0T*eO!0j{Zh^hZ^}4,ZJSQpq-UZpErVci3MV.`*k#Xb1b0Zi`k``0`0}>CjRbPQcGVDXb%XsllYkkLcqbdeb_Y|^/j2F3BZYj$V3$YcK6.=uqbu+/?K&&%5.VjVegqZ=1|qKFmjcyLu9<zSKSZXO]pv]*w/F)<Wf!,>5ZXSR{q_l|5r;F0/Pwl:xpGUO)#O0]yJw$Xz_ZG+ApZk,i8P<q5-az)x<!yEO{(b,8LG#E<bD2
J%ILb*jIkFT]	K*Sb8b
/z34LM"4!qS*_!rYkeV/,1|E\ieRdj|.445;IOM2+(NPf"%]c1c1c1c7]v1c1c1c1cu6mPCe:C3]n={UMN= w|ZU{pM|\nrwJ^v@4z6y{Ms.r.r1]r5\\h(((0X1A_F"+T4X+U_h`_ZdZDp%XUS!CTK adtV\YS\MZdXh0krP(*\.W^\ZS!r8CdZ8hreT;@ P]8p:F.Ku(Pz"%YLBd^Iq5ie7\\Ey"<^%/	8tb8^x/
TJ-
KZ)8PSqLJcQgJZ^
'xgK:1p%1'z^z/jO),|EO
|NJ{H>0+S)|)|RW]xE=J |/O:V<OABilMjSffJN2DJ{Q/[KN:J|E/T|z(R>>|R~@KK$
 %SF	h@@F@R1HLEdVQ$TQ1RM@FaULJ`L( A,0TL1(a	
24`AFQP(` AR1JFtaU@hCP)AQ-DR%d%0QX+DL"AaR&""+.	Jkmm'
fcfekfp:E('pI%*.%5"
bGJR"|FCc`PQ$661RV4L0eMIVUdYZ4,HqN\&63jZkQJ6FjfjfcZU.W{lmQVMlm-QQc-T'A<
'ju!Rld*x/Z)ZE.rl61t9"]8j^<W)'kFkFbS\l3,YR. z'njK/5Z5Zx)[[[N9$pBtI%Q\kk1lGFX	V
tVTD-$aF]]]{PQ&hHH~eMP~?$c%dE05AjaQYE]pib;;;;:T1Y0U0hYUFvjkaW*ZUi,FhX%d#,4USJjTOClU0`,L+}TWvI'O||zT>*#6m[5t\em  P!h[hP V (h)iUUUepe%ZjVRi'PI'<}1)tIhKt.dlr$sznhpmB\(+$k=(85p 
 $  L/Z  
 z
)*W\Aw
P%*$  P@ 2d	IU4%U?4M	=TC'jR4Q` RQ&T4ikoz6\  jFAM6l$6`*_bmH)F*$l]mfZ&	
;m	_-YX wQZFSZ?e=U+/2Uj2'7;rSY0|'&^{P_{|Owmy;3ena+g+9uY+~mGlOeEl6Z5wVVa]|<W{reW~/l\#SS.^%U9S{VrKZK4fU1('hcmjdJ"12fYQaeQL1)UUL011czcD/*cL4e0,YZd24j+4N##S"R8"d'\,8qdXY_Sd6>p5jZq(q"K.*8G.RRTJEq9J0.s09X+q0RJ-m_PL9d5Ug8s8g89fCRg9RNng9H$s5+0Y0iFl0ML&$f>L7L8&Y?	u8hZrC9W.q.Xhe`1tYI][wG39&^Y8gh>lnkWOpbhY}9r5Qm_\;wthci[J	PIt8z:pN/4q<my.JR1zZr)ZBKH'Z`bU6n.$,98QKlQ$tmKV]fxBi.1xfqVXI/,Q
(ljCL
rv.jX"*\,Q2 8sUkkj!1J/Kddp.W
L)'*N30l-PW?)G>=*TG=Q

'Tm'h^^PA
:NJKr#bF'2eh>}(CC_@}>>~Q$ff&VKEdZ8$DDD1c1c.c1c1n\c1c1QfpUjbS^yW'N-dLO_SR!hc$jjtF,"""Y7LRJ1BM,c&bY1&1eV@hf0m+Uj!@         [mm+J+UDFk5fZLk5VFSKISQZj2ML#(#
b1&&(B0SUXI,,(m5Ub5j5cV02eVCZ1d5:(?5*@E fcRV-@D&P}U`R%k0TUmcfE(UDbU	`,"_U,cQ**5qINrGFkf)QW	NBVW$/)11Ae,a&U0~UiL]9u)*69jY9vUkusj4nqPN # RYAx%6SMUeOFF*X]2KR+%!wgZY%&885{VQ+;]sj2x'C!</<%%b4?JZT]]|se=Ed\fYW)]}g{=,v=EEv;.+%WxWJ\+]6+.Uu;Vt|A)|XrjIb-g2cTfKM^Mj/z_gWS	Ve}Wc^=WC`G!At>uB`b^J^KD*jF@?TWTWRJ5-**F+(
QE2W!j)NV42*+ 21G1)j)a+	ZXL&bF$jJ
IjKS 0 IbKD4CJP#Z(eUFUY*&&FFP*`0	P$?+"*Jx3Dd$RBYZ#&4IJ99AX&c,EEJaL)+bV,SE,bS
e(1I3ZI5) $)bH2*QE:AMb\)T<R,`j<ZY6RUUbJ(I$v (TTxJwH`VU2QJt4H HI+(Q`Q  $`"L$WYA\-e3)LB#6F2e1VUD%O#V.*Q/+GKpL'rU	_QK>+KN|$D>JJ/S*K*UN\i(%W~?O_'z_ZXL2ZHA2L]d4F0)3TRbbH*utV2Ya2*+t_ej2ZbdUcEZZ/3-#I5R2.0MFET3NGMDt@I	>>>6jmZUj!>	$! Ot H|_Wfu]#x7w{y0U{uVbs;lmqKmZF#fm$H	 @$Iw1AY&SY~FZ[ T~   
` 2 "("S TP$TJ(fM	-( L*@UOR #M IhhMJ$$)(FmkPlFliA~?mmj*QRFZm[(OmZ(hx#$x<jf6mP;)u,{~uk([J{u6+wfRj)yJZvv3vcff;1WEp8)~kYiO3T|GL53^202fL<fc0,^={Z^+/X+ej5t+)VUppWl4Z4Rc52"ll%C
a"c2eeaf La"ce*+"3LIE&$dbOKpp!MXqLq2eK9ULL&LLL"IZFAp+ApRr\KmS7Qa-jFYSc,-Z-a,`|a1|x<Le+.+*aK,g0FXJFXJFD6Y+2fW,0Xg]JZ5CX#PeV04rm-*0Ec6tWhlzXSm0[2me+k=f|x8\.,02u){)t04gR{)irf
ImbIwm\\Yd1Sxv]&^5NpEY,fFKcOGm2q[x3,WkS8\f 	5kEmYy\Z;vcKKTX)l2Es22
M*2j@
CTJ /~~~*Edj^WcHyy'VSW1bZ!KW#vA$[ !SZGi>)"E/B/AE_ >$|TA3ebZa+nm_4DDDDDDDDDDDDDDDDDDDDDDDDDDDc1c1]c1c1c1c1cjFm^	>}{tw6{wvkewjAk]v;${y{d5dc%jcbW$;fl"#ZoowwswwrwwsamI`        m6m%Hcd*Y,L,dV(b	L%jV%0(L%11+I2*X
Uf5e6iVEXVPEd4d6lY]JC,*(EJEhU&P4J=)N8r9+S9+e,qsN\#D\(r*.vvqrijvJUu+tVB\rvt'h.Wj	?"Gsn/J.:yEGq;T8-+BBcKKT!T_{v{N^^\y4y\xPO/P.
u~;axpj)zQ#z(TRTZyC/_u;w<@z=59WPW5m3l)t%m\t/(iNObKzH%9B>REJBR
Bj)N*+W!p8HKB."#r\r	S)pEY(hSDXF	-Ib2MJjQ5Ua#
dajjiT`SU)jH&&Xj)ZV,XD"VA ]R'h-
)%bIp0,p0))C1C L(0`0ZP*.
L.U	;``mmr t"RL$`2U1jmVUE
MP'UAK"	5)L%S$D8]$Ue!RH.*(  HpU}J!eJ"JV_m,KKjYj2&,,,PR~R	Sb(Vb6UZ1mb*QR?uW*+e6$j;N%v}vKCl[-SR!zCq?E^^lXRJx.dxeB.bGae*Tl.;U)E)8XDE_|'}_V`
a!,S*HXF2b#KX(*Rd"2K>|x5H**V|q>jR5F21YYPdjiy^]$|Q5jkMQ,Y;;u	|+32RYS'gn/iS$$_gwmvx=w]{jWRHAI4OWfb.*
,if"Ij*u.]oin5uf AUEm       @!hZ!hZ)N4m *??@   0} PQQ*)TDm ]JEP"@Q@H)cM( CP 4 @5?jMP  	=RBdd4	DE4=OPhD*
[Y3Bl-FEkZdEZm$E
-LimUOmO26>EHZ]J *HXI_<zn@6!|hE_kf+.cP-mS&MdUzf+1%Hi6fvu/#1rM+m5SV5/ZxUZ{iUt
aYYs)k|eN5ctSbu2 /5j6W[+OeG5=LbfA,1 Z%|j<Mj%`o5r6=^Sx1o9X5y'/Wm,F;deax.p,Iluq$T&o*JZ!VTXZ_S%OcLZSieh|c3#RcQOdJ5>1|d;d3-I/g8K=*Vb/%
ByG8'BSqD0(WRQiV5	+Z?jYLQkPW(JcURWV2jiG&GYc,1'LXeR,a31VNc+13P#&uc2afLiC:H&:c"fK-	)LLc&0cS	3We8
"1j,lbaaVfN-r8^>,Ya2dL&QYdJf[ZJ&V,fjeeW)1S,:\Pp8qLZ%jN8c,8t2.2 
Zm'&uJLIp0p8F%PGF]b\qfX>}x#	XbdVY0F	21{fV4m5DFiMV{$Lny.[l5DA4kH%Luk]0	k)"o$3mID;\\88N.\SKVu/GLZ:4d80t4ymg5<Rhja.=h63<wOn	o52ijca36,]WCZYp}gc	xySc:X.53j[[MjmS5jYZ#V{>M4\\.*R2p:Yu3|:c1%q'u+,Epj)prcQ=Mbe-1c2-pV^$t0`iVXb1WQ2FUlYJiYhj-%L-ikJYXI`14VmiF5V+%+ZfS-`EKMYZ$*iHUi fX00+"V"(~`C))_~LhYe>+)|V|i[YO=+kkHhK`gUGHWekB5xBt+)1P)>}!2O|(_$>QO_*("$hR`j@C/>AWdK++,b1&]b21c1cu1c1c1c1cub1c66l*Ud43$n^<w^Yummu:kEn=S6wXz](/o{j{W,IwvQ+TEjdbW!jUu]WVK6If,if@Hh 6 l VmIkT&	Lj)&ccc1f4idIIe$0bUZ-RLYX%dUe-IXHReE&
E#YEYTSefiZ)LAMe&iK4dhDedd@	AIXG2FedeLmm1IG!	()2pRN)Ybim9W**rCSJtQu89.V)t&e
vH,]Ntj\\:F;	N.J(J?bz!sZYNW|je<y**xV+5sf45xxreheN'eE)IBkgU+w5:Z\W\Mu=jK=R{QLSYW|Ezh^.^UCQG*RW}(l_lQ6pz^kBqWVkJfT|GSghp^=)UVfb/.RV5hWhuz'".Hz#z@>HW?e*B!G	a`I,4B,XXUaS("q%'%$( p8W"p#.PrKZQdS	I-)5",1S2U"bDaj)(X*&TLE0FFQM"b(QB""U?T%TQ,@.EQ&(4U1*aL)L%P RvI("]@.0H:*xR *C%ym4	@$	@$	A H HJryEXT@ pD iJLRU<4IuJ
@D*($+Qr)T9B")/BW#m,e1b+$kZAAAYXa*?9d&j9l6Sae0$Ut&&kkk*q"WGlS5V\b?kRDWM[J\V%^I#fTx
RpQM!Z
_O}Oi_CRZ4,hT5V4aeeJeK,R`MLd_OK-T,&HZd%FOVU#&IU*beH'yY#2aVL*2cEe2LKP8(/.R"^[;4-{*C
wn |+;]>T|=yU>%R^+$wwp }H,IVHK#%sb AdAdAzI&MfI5$k$YMfI5AodMe2Sun  AQb   )kA  E( P(shB(*JT;x h2~T  
T 'U5 z4Hz@2Q*LOj`5Z$RbFBj6`+UW$	?mT',m^EQMj3H.PJ}##dQTtA|CfRl=6`e/V_.K+ebe~vTcj:6 Q*.$jD^D2Sn'18Wc%Y\vZcIh(M3SdyQ<M$yf4 U=b/MZcCffA0gG:2qKqc,GhdLLeGTe+3&b^1cD~*>Y|,IebG</YQt,B:\p/]c,)eMM2&bbBVkK2Q6=j8FLK*:bb(ueLKH)!Y&1L$QICT,-`bZUYjT|00aVUF,0`5^&	D|f,z9pkupcQU4LBjT\'&rrlriNNHddmZ,VIiM8Z*rSe)K4\mWqY3+/2V%3-k@5iUfVWdiV22x%ZnEUq[&Ue'sh4\UdM;D$*#qp\?u^.FYef:VXa+2+x7I]MsSCde8:&1e'^Z:0OMVaKA] puB/CRVKTpAS
2L
X1-44K2YXKhY'UGRcRbj+"U,12ZJ:6-[a-bMTV4XX!_&P:-*/_G;3RdwU|Kb}{X/UAWVt^Ty*<RDJ;$ZR*X?XK4('i"wI'R"J^QTDU<@"mV1bKI-vmDDDDDDDA~qc1c7]v1c1c1cuc1c1cmQ?/on
O`@-5x96%bBKmRH;5%$G	Rfm!.ENpxJ.E"U*E"=UQRUQRQRUUB"TEmMU[R"*"*"q6lm&( w"	$
Q:;%t?[WYc%-I    @ lcUmkm%""lRE#-LVMFJKL+%hX`RC$!RYE`ZUedLL5SU2bhUhiV)R(t+4KH#2YQMI)q*SWWWRQ60FR(JQP
	q"aQ="%.^q2t#v%Z8Bb-P0A
8EGT:QvTK?%.jzsL/DtPhW$N<,`	rU^H(dzO5qOueuJdGW=QE{$YJqQKrNR{s49qyC<"D'"b!/"p^>wx9JzO^J/|]'-S66|JR8 Q>RG*>&
}u"$I&-J0`R*Ru)"I9*9!!
TUpqT 8+G 8+EhR-2b-VTRaFbALZ%h	X`,AL`&eDR)b1UII"&j&!B]RWRM!BGJ!U#D82!C&jCHXU00#RHF:RJT&TV$!U#lU\.&RH$OOlbmUvU/%
aEI`*t)v"L	Z%&R .RDST
$qHI5R8$BZJGJZRIkQ1JIa0@}SANAZ+k1$D&?
).dp=Q=R=U/
/ At	DJ\*H%M+AT*%yO*^O$YEYVIHb20%+LDMWji#`b
LTclh%M)`02*2&2dGLBh1	bH\R`r@A,GVvy1\2y<< Uh=.7	gg=qjGgg=^7Cm>h*Ggg=;xm+kbLpZ Q   1 @  8{(h l  H& (PPQJ	PmVjm }P 4L  Tz@  %E 	HE&DBJR=C[AQi*m@mADmBU!P+|*4AmkV[+lHj}lI]K[J%l^IAy^j-BJf%I{mw.$b-I[hY\w\:ug9WC5S)}6Cm-/-_Fd}^6lf+Q;XEm?`MkiUjEmTBlkbY,X|-ejzZj<SiAY'XkdYc5fYij,JdmYfJdmYfMTelVPIef1Q0,13CQJ,e&`f1ATf1$Gd\B\EJ.T.Urn*PNrbZE94L\\Y)Nbfg"aN9G16e>D*9?&4U&_\\S(j8B8qJT%XdX0`X+``0`0~?{Zdj&,YLZ9ZV4#\WAem`"3[#/,e/6jLSi-mY47halVqYq\Net5e/5([3)\\-=93L=NN4kFmvS-36g;~s:v{t=ph?"|#Z2fT'%i389~cn\Rw-89vuxYM5dc,|k..zlluayrVl*rSMh2LeYz^&a`Vi$LeurZX%<RiTXe]T)TZ*6VU$/?|&0_(}j7zi=)i<(z/%<0N'ut%e( BY5~CC0Q|Q|(
/E
/A*~*~HP=>/ZZfhYU|H:c1c1nc1c1c,cu1cm-[mWn2`VL5\^WsvKku9IoZnz5<zMcC[[6&R=oo }jo>!]swf&d
j    4 `     1j&DM4E*ed1bFJaeHbb1)1CB,
H`ZMh5Pi55,d4UYkFe+4*#Y4*HE(Qae*mm[XZh(8..PYg8%5		]EB<8eNDi*uW&Rs:Qtt2]U()3z#QO$x^A<q(ri(xU]aFE?ERzpn_)<q)q^WWI=#
$3PFG&/Q^<
"&^UE.=z/<y=G_%O|_%2q]5M6jrklUmllGQ.RD*JZ
 ?TUY`(*iH('HrG!
rHW(S8N\)A$'%,T#U%iL,STY*YELQb4@,-aEjjaB-TSUT`DDQ`QeX	MUE?0"U~]@AeTyURq+!LH"dGd T@1HV)dC ( (^J#R$(jokVU @W*KUJ5H[3mlAv[SEYQK ]ET*V%)*QbN R ThUrCHUQN	bZ
J(T#PV%**iCc`Q"c`Q%		KI-EbRVEqd0k&LjdlJ,ETT!:w%b%cTlAH?<
'USu&Www|Jufffc35Rnw Kt8utulw}U)Rz|pDI$WWn:=(%^Qffff*rsmfPn
.
N,7-eB%8
,VUP#W_~)'?	~VUb-R%2,fE_~?0ZL&EQY&F$/0UR2JaXffkIb0jXSUX0YdaeF$e,u!>|O,11021,'GK>=*U%g;\," 0@ 
  @  $rZ, 0DBH0 	!  &B@ [Up#G"W_pF]r-Vp,tQL-PM*M-UV"t_PVIw;   L  @ )B$(& ( NGx$*IH$RR
P \(  2d6QULU  $JH4QRUMID)PzM4LeZnw'1WTWm   {w]sCU _mzj~%r{)'P^P	0RKr_-.wx qSr>Y.wP{~3fq_5V$1!|e1xe?(>	Q9j$w3:<Y<s<jW2`=>0|h'=j^
Slzzykd+=.lG+fC}|}}kMO|eO_[hm&Qz1S(b}}V/Kd}+/}FGyS>2Od_HcF>SFrdlLO?5^{%.||5xe/)~1U>+/mfBOb0)j#`c)
\8.\9rgUcYa45-5c?>"1
uz8JpxN)	#p8%N]NqS)G+%MhkB2`LUda1FLTd2e4<FMFM#&L*2U\KU\]uEku%0jm{{^G:	]xG:)xwGGJu"wT3a3,c3g0f=sFd9s,%;Lwl6xvb];p}..D5ufw.;NJb6qRf,laq+e0=qC,>/TJEj84jX|T1qv2W9J|8Se\-hSwKr\or,83{hrN-fV?#3%I},n#XZvyN20U34kZ92supx'Lec+*cxF0p^4RyQ{=ZqE8aYqc0a*ejejx%d&F`Y$%=^3ne`Z%nG&aW
2FWB]R/mCIIyd\	r$WRRBN:q,R
-DYSFF)r&hrYhrLof5.-mkc     >6mU/}{b^z[Q:O	:tN88LM*=U^+W+UUGQ}TBU_QJg$5eVXKQTqT6l"""""""""""""""""""(cc1c1]c1c1cc1nc1c1mT6P_gX\=L;q\%-^KW@k^hfeXardS XQ,F2&<BxRTQIhb%RTQIVV^Z!
o[8n8C.UUU	    H Ho UEmjIb@TTT24LL&L#J10&0(a0	VLb45c(VM5i!)NbR0$YY
)XD`V*18LSFW,E5FNf.VH*p
b*As,Ddx]FWZucrCH.4K
..q,q`hNk
J-QY'"8A+nJgHV;B%%puqxXuv]FO V Yy^5smqxg]<bu^+)1G##vN|t+!8 !]99&<%FK]Q0+$g^x'G/Zx(C#/STiJpwmu'3JJ<Wu[,UZ'q]Z\,NS|AZ.vvMI%]a0|4U	OC/>"X,iR|44l=wyc9j;\O\W^3!'UR^++zqN.pK&	|SZM.TT~IC='DN%\BwcjG|'|KXX41	_I%Di%Dp!YMT\UBA(9-Bp ZM(JL%IC.,\gPahJ!Y%bdVBj&B`i+Tb)S	VQY
VFFd+"EMT#HS(SUAZ	VUB/PuLX)^X@P$MZL&R\\\r,Z#A5(Ae@TRXL%VjU,Y*Y2,dS,EFEH'UGEb-h4Tk^UmjCXDBCD0t<01C j4S`KJ"I:RJklkf)<0CJ+ZV1*t@NTt2*XQhBiM)%
<U"*X(JE6IUh%+,iR,TiHY"pFQ(_)4 |FEsMf3*K2j-2fL3K";"8UB8qQ,J*qYWqBpGeG#<]Jk+|ea(U.a(0SF^ZBG0%zlINa)h_"9GS
P<J6G0
W` (d~%(&J!bJ/>*?*~O?'iF UVhijOJdTMK*2dK2LY#*}	PdLEVV2@j[J_ %2`+LeExEubd%2afZe2`&PBd3e4~RWsb6U9Q wmqJjUN:K?[!*(Z(4QAejyI~AgmiNwm@AgmiNw6E6, Nzv^	yY! aeeYEFa`00I$IR0)$*IRT$*bL#8   (1    B>   	
 :
mf@I)7 !9!TRP j 8AF 4(4hdLPhFIT2h	%5RHa4
J!MRzhW7~s?q6yU//_8.\qyF/ UWW^zvkwJ +VFmx`0Vnex[t!mT;N9Z'^<;6U+7n(d^vvpU\tr*&|LBU
Tg>cWN]-al{fkiOKX<5EF>\r)]Z+_i{6O<sNke_do>==j/M,3kX-U}}>d~Y~Z}r|=c#d|f8/ki%Y,hSqr|SecaY<s>hdd3F[TO!jRo>Y|YC/'Z/YP?*U5SYt|0e|GuO<"zDzOMsQV#Dl2sx_TzbU}oJ?1~xutR<e8\QWFP*EN8`p!x:*/xttdK$	0`+
Ue*:4-VZ"ZV5kA1,P&Y),&0dY8+8A%8s5qd8qh8qj5ZLQLVZXGz)00XaUmi=sm.8px3\GB;\8:tR\pN#\'QS:.u0fgc3gU\\a'Qq8x\axqA^8 ypG2`7M<<s:]uG!<Lb!y9ru9J{x^Brk1Zu102??jB3:A;S[	Au]{utmD:$'IQG:u8SXVi+o~$x~I]1b28a@!Gpi	9Me94ki8r6^\fo9GZ+:ev8q%P@v2|Kvu_M4<Gq.1cp+8LF DB'Kngi r{nf,90qLtgWa=ZH%dPWc.gx+
x:VVjl~^)InZ:Ty%=Zh,ZZC+Ut3C9@24]Djd-4ELcXZhP*@<	(YjU3QZh)R\&lL"i%"P?tMe[l\[K:V,4WSZ]cb+JX@]jL\pq@   =fiVVVVYb
Z+N	?sfDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDAc1c11c1c7.\1c1c\c1\s1c1cjEZmj,nF9G9S
w!l(bvT2" W=eZr+m[k1
b1D 	`     H HA<U5RJj%URU6!KIeEVP-0TIV^Pi9#'	`U4M.`{*'JibKI*):L/.q8RJUPG]c6fS]3.QTRbSYW.QfIbbzLUr]rxO$WYO3^RXc+g'XV's/u, 'q:Nd=]Jt.(-jM2Eb)x?I*eQvdraM{'y;tzH*^*sg]=nNL&c:?.e?'^{|?.%h]@4U#JjS$,:%/bhtzq-h,/{<]Wbi^_"^/AP{M;7o7wxpC@<'`8<P	j-z 4\'&#Iy~|C>|}=X!2W
Tbee+HIekmY	WJUbx<'Q}PYlZ/#\I$>U>|%>RTDPJIB(C((0
%5
2QTV*JXD0%Y!jCI,	Z1d	V
1#,IjLPb1J$%L
`+%IhS
T*K)*e%L

K(P`(??QtU
H*SBEVZR#TX2"-JYPh2D*Z4jH4Vbb5WB*Hmstla"HEC Q)iE'RU+		`!q
Q|Yaf*K2K5%(21'JT!q+\bx."uu]qNWW]:+wNnc8\:J1;FS[MA*VTv-j[3Ji9(8@<A+h:(8t.+AAR+!TdDS1h%!~/_E0,Mh##&0LXTF`FR2~p?xD4Rh:ZhjK%wFm-XR2#
SFE[d&^T<c.=_H}[o`? cbFZ4h+TFjm6
mi6+TW_g>!aU/qZ|C;<fu)3{snqUs9rcA1IkUjZVU
L$"2J2J2J2J2J2JI2NPVIJ	@tv   D  W} >IH ) 	 /|w(	PQ@RPAD=vaAF 4Rz* dzME=&I	DJzdb=O@!Jo=-//WWusOyjwwZp:Wk W{=z[VWj2QlBm'IO\$tN&e+*#!Q(&XKj5
jH1LjiNx64<%xJh=AmR+byxcK5/'TjhlKihOMV^P^h
'HXPWDzdzc+a^<LX.V)1_]fYOW0U|EA%#ae>)`}Y_WeX/"^/]TEz2Oq.t,TueYMkQb/P}XJd/^p0T0Q=4&'dV@5YOfN%dDd!VRxOM,5e*UGJp8`b!\ieTR0c188p3p`p.fX.8p8YG1,[,+-1VBZ6mYDH:SQkI]_Jt T]'hHHNv)]gBuY]gxK9C)!Qxq~2<xqc.q\fgw!?~ztW<NNSMHru0_BScK++r-D. e2a*~t/~X/~\tOqzeW|Vj$2i+471SiF4G/Vpe^T++++X8mVf-Q(WW|\^\,5VM&xH\UTI)0"vy=WiMXpK+GdS[A1Y$x e,-ZaF1@TE8)lIkhD-hUjCL$-%U9)V\5SUeY21\LGhi5ce_5jizSI2fr      "  k|T If6lJRM2LI~%K_dDDDDDDDDDDDDDDDDDDDDDDF""""""1c1cuc1c1nc1cuc1c1nc1c1mUM[
?SZu9zM]b:k=yN$kKgyY-XyY+Xe4F6wNqcY'rhX!UTzY2&hYQEQEJQQEQDwwEXbV*bU!!@X#":wm$DA!]wu5hBJV"B4|kygu#%r9[ZB$I"EbUe *<AZ9K8(Ep#.IXA8|8Qcs,$q-Na`:uRvAu]02WWN$\!FtW@8.brV:W+QCI<KAxB"J^K+l9W::^$ex:a8WR0WQ.2%KxIhyZ1U]GbNLAzT
)/b{
/NI+4+pz:..Kz=E1q|YW	TAdbYS	b	$M'co-zPQIIWk)X|KrH	E| QCPCh7wWo76>Wr%.+c1hv:tx/S%8zz^XLYa#!dXL
k)%^*/R1t< cr\
X$PjCUR| |P>
T>R9*""bEbDV(J@b)2VX0(TVi)h,eK(dReIX*Y*Ue(F(EbQFhU%jU14BJ*Q))T1JQQTaJp#*%#KQ*F(h1eThEXET11@UU	,Qb,J``.QaGJ`Ye:@ljlG:D'"$)M!IFSA%KAPX)dU_E
">C#VR`WA0b2aX2_kaV,#+ejE||@{	RR*Q<<(
%*T:t*)Ph/J*ehIL1*VbXd?O>C!+CDEZ'	SRU(TW)*F	SDd0CfjKLL)a 1O/$e!`/LT<	t/L48l[6MmcallM9AnsB[Ii;d(ssws^)_%.y-ER(mO/_Y{2JU ;
lRWJ;XC8-\Bu2    D@  mm H
2:X31 P @)sJ ()  M ( t{
 h@AT  gx    i(P h@Jd4  I ~j644  oT0C>_ wu0s:4W*t'| v0:]@IVp[ :;HE[%QVkF[djMOJQ)6U'h=5JIV
jWL@(UEXU,D!KM!k[?9W`uyYy2iw:9Hx{<c;]a_E|_7}c41>$/KO_=~/~4}|z/NcmC[6]WCe8cd#}qU}j}h+>,jZ)Ws%iOM_]_+e|,dKjEIZ.Xn ae*:/<i1X'AqqLb?WioJl7fRlVSSO,*b^O,xXC.*.]]q;bux"b*q28e&*LSTuKed8Y8Q1dpsf6,J*bD,YVXI`VXaC
GW%2L+Y,R2,"]YuX1)edX,eL`T)>+D&D
DIe^:Z]u^>^'zI5nU+tS88@y.]\qrx+5\u9rN `0`X00xF&iypq3AV_3htXw@YGJ]tGx'E]Yae^XY8:Q.%\SrOW,bpaqps[QYfS)F%grSzqO:yk53Suae9(rS8>o^skj9m><i][M|RC$$e\9XFYj_|OpOqq#:T\YLOb|04PV|8\mkDj#Tg8rqk:\,qDLX#)-+jRW2kSkBN0jIIU`j.(i\+,2Tc0YKL(iR/OkfMJ,Dpq-bgVvuiNG)pxY93bgVvubG)pJxgU973aYa=NjXT9aT6X?T[UDAF}&D7]"dI$Yef)5*+KeV^k[o(b"" Db"" A/1"%1nc1ne7\v1""""""""""""""""""""""""""""""%17\0-BLq&X8l'mF1mF1m^]c1c1c1c1ccuc1c1cZu $   uH&A/<TZ6yqo,n}fe9U"\,	6{7ss^zRnVI'XdUU|,%n%BZoI7L-1zUbUVO<udL0\5eW:c-Ys+L,YII	,,2SUZ%W$T!IK1 IH2@)!A;;;:u	 D&y CDC#$${qn]   'fd,*I   r)d6$5WQAjm2[r+UUU|}Ej^ BA 	tMY+1-@P#,5VY);+H5`jV9)Y,j]A8@88eESZ).G89X'Wg(eM]ZvreHR)N4S4\jU1u95
t	]5Qt/SK,`bZuK	!^UKEy(69z+%./x.,U<X2.G;0ri:T]e:NepmYcS6/	]Q,Weyx(!!{U*WueIxYquz^#q].A4|]i`q**1GT:F"X^#b!|U@A|]bI sms%UFd*q{9W*du/V\]^/WgH|\eI)(PJ'8\#o$J"E+> ~PPV)LJLTK	SX`2iT+*4*YCRPQS!ZXT%YZ@iLBb+),EiR$
Z,ZR`%`%e2W?
@TQZM5HLTMb%E+*$VDS$&BK*L"FL#	+WK $j]%!N`;kmVjV1!MpTN*U$A bT*!-UT*A$aD}I#eIfIT[K,YdYe*!Ie43PP
S
.&RQt:fbtt.WR<E</	xxx yU')rLqZ+)=;q6wW8
d%mVz\8OFc[vr@qJ^*kM@5;urXx9H.kZbYP9$k*IOSIbkddITXjHS#'GdZ1LH%cATX&S%$.DLafK5~~~~'#Ab2H"Ia>FgGK0Q_4JkU2Xd_7QruU,Ka0MI`XG.q.]GFb'}i3ULdL
&^l>sGnq.]JL
B~guysN*wwn;OK\c 7szkI!!  zO4:-:3-2,.clUma}6614K&UUUUUUDUX
*D
UUUUUT          eP @J*D* =2d2[61/DfcZu~w&HX _]U^\u'rUZ"ViA<4-(#T$r.wr%Hs)_'dY",Y8U5iOC9n7w(sygsw7w, nv7urt?e5{R9)GD ] n    @  c0T   _a)x   TAQ@ x_%L1jHoT2bbzJy*I"2z`jh@IQh&RTzz  D 4P@ >Pqq{)^2ZYB* nq [   jK{
xPaN7! |z [h  =]]S]]n1]c1c>:1c1mF4WprMmjBF"("kUEDrn-lZ6Mnm"e]M-6TDmlM4VZ[HhM[
mlZ6Qk[[*i&6NUxEqtOmDZQQ"xGb:sI9-aV6hY,DyQQ>
yC#3
-eEVSKa>$8;TC2]]	;EvTS2Pwu;B Y.N;^FZ Uw;iB"3
us[VrmEQEcKi$13l3$Y3 6Fbjlb0KeYS2lbJHm(B36Mf*f<b\ZjiM&-5V4M2LSNi/]Mp[MA_7Ni=fj{/wN5%ov#Cvj%T)|:iZjY=\44(o6De]LUJmP7GiV4M|:6[R$:ajXl#iy\Kn7iFjX=pbl^{*O_kj7KdZjlVmc3lc)Xl5]pkLsmk1WiSjmR#NSA:.Z~VXs^5$=h[t<64sUfAjMJr74*Wi[FF'4KfUU[+3*n[%ra!$EM5L5sSS2U3C2LFdEf,fIjff3!ff
e32	Y`,QY*f9,d,/2Y	%c2VVdvVfjUd5MUVC]%khd<KjmcUe)Q[CQ2Fj6m[Fm6MbmCm.I:-\<yxs'989QsR8:0:fLUS%f_]}<1fV$>>e,9Yy6"G*d/"Y1/~7f0f&af+03eK4t7m#wG9F=8hbWS|;K3|/^j&smI@KjPPF6&D%l,XUH{|jWiG<h<!iy#xq<u4Uz<7:Z+TksU\*E#*Gb1AuZf~8c,jFU`*q2122,#y9yt\utIdI$I-[)*msix/(g:.UU#UL)//=n1Qd81OV<RLWLz,Xq9gxp2z>%$"U,!1"nnSw.''}_^RSV2^!iOfn[mmm}mmfom}mmR"*I$Rs9[msI3*Fgbf*a&T=&{kZkZm}F$	L]w7LLnfw7RfB[|0VF5l	j[TJXhY   U=>gYUAL}&A B Aw=n{	@$  %q D`D0=cnccv1]cup1DDD1"'z/VummF1cj{z	0'AcW.1Duc1]c7]v1cu1ncDv1""]c{{ohuc"  Kmkc1nc1nc1nc]   vc"^]Hwd6 g%"AD=cj1cj^WHA A}"E2Orw;U2g/jiUngfffffffffffg+o<Rv6;]__^EE/_H4_tVsV].^ m=cv;GfcYc2I$L  8kQC(JYhj6v"X6m   Buy8U2+)UJUU`/T    !zN5]p|6T7g<5YY
PGZwR+ybv4 k1Q<jg^^;(qKKu
2,RR8]*w{y7P$n$s[]|Io]-f.#'E'],b]-q ]+M-ks]p79s*["ck{No=HKo!a&{mn{/=7r	D/mq0e`(J9s8f	zAI(1c0FsuuWUX(h"2DADd)))_^y6AjJ((0(Y[}}QIIJ-jH~2fVdfS2YfC2ei3()e30d,RsrpHlM6Ci[kZI$2JJTK&m)fEV(.r]I+DNbH&d23%Fe(3*FEI6dmj8bYYLSB0(H]J tsSja\am/t]CybQ9X46++q bQAR$E_%S{yyF^G9F	f)6+){.S)Lkhl]a=Bqxe$jZ*D.K*](5M6&j^+Os[/c^kJy%e2;!9NSLLMe	Llfc6=zB/B(=)_"
@>R@PHU$K)C%!d!iAZhMJ  SU&ZC4d%5ReX,TO]xi?H?QP~R!V	1Q1J&U
e*L(H%(HEL)1TIj*KHV%),(ET0H UZH<AU}6VjK%Rd6ld6L
b	L~!x(/ 6-h[U<GM*mQ#%6 <MW+	mQ.BkT`TGF$c(UTa%V2V01c	c1`L`,`)Ba)}QKd-%h(HZCd,C(I`UXHyWbdS2fZiaIaPi#l_CUE*bXK,K,Cd=d=%S2ObX"+b=16)W BM1VIH^????*~o]~0Adwwwwwx-$*1c7,#}>5@  LZ Q( "#^zvy	@@D@AUUU^>b+XbjnoH=QI!mA"!c1B%6 H KjM6|)[f(ae-n3mgh11U;]v~4t
AUUUUUWJ" ZB &A B AS4mToAoy?7kkEQQQ0qf+c[<0MAZAk M Dq&AKIfs\qT3L&f]l*gYfbHAQy>~*d@F71y<=:<|xnQIIJ[kj4V%eW???;_w};B B A)U s~2 
=T   
0~! @ P 	 (%   *M8` 
   8JFU )I4 I5T 'JSJx5*   JRg;k1{1{o;= q{UE\Cdyo<qccQeEL,\w1p3xc8cyp3xKO]0:(4& S3o1:7] ]Uyj,V"[Q[V5EdMZ+h*(vNv[[s
.)f;6gtwq;Is2I#4&bf1"Q6-cXl%5b,V1[-E2e/pTAaa4z58txjdtb8a0f0fxp>!F8`39j>v.e*'1-@3?13c89%_1bxW<b8P\c4d':#0g+d'yf+?d4lT:Zf]QUmfZlj5	flf[[[U,(Xer9rq*ecb,X9Daec(efXQe2cHr,9b)418ZX,*22,R*#,.G\|\9ry)22/#8s`$a/,T[S35,;GU';#.X8rRvn3992ye\O+S/FYe/.G\x^#ruR$~f'Lis3)9s2eXXdhlW>6V4c<q0,eSbUe,(ySn8w.aK
78U2"UIB@Y	&SKZR+KJ] [1N,\9g8<9%2q<cSLL<rm&NH82138><1_0hd/.|qJr56	p!)G6~X/,i?bYjuviKYL,vlE+|8\G,~\PMF*+yx~hj31f`dT'V`JYaTEb6"5(1IdmT    ?ZVc08$	_0b"DDDD0D`0`1DDDE0`"D1DDDDDDDD>ccv1]c1c1v1c1cwc7]v1c1cc1ccDDD@cDD.1nc @$	{1c1cj1cj1mR6jF6bf1c1ccc@d	  " `   a$@ $ 	ujp WVS0k_v/wK['bS3uLd2'\LC$2sU2yU+pL6dbI;4{4}Z{;j:*V}_YN==}WzL*zVTS{r3jJEf|~`{,:izO|Et%F]X5@UUJ\wDZ)x=g:Vte5gFY@c49 ZmJ|)* "$@'qjC*oummnU]4{[l&V0ct] H!  I&_z4pB9gUURJp3316jl"3WF^	RI$UymjeJff2D$H900$$I$<{Q2]l{UA*>m&jpY5+SR**qMJ 5UUUp" jUENj{[-M@-->/j.Ov]t+PH@ $oy[{u<gp"W
Tf&YL2*"!3&i$,*eR,61fbSJS#s8Rs9XsR2(pILqsS0g8fVsna9F)21x&29q\(fUOi"byx
^P_vNnbW.1Z><<fc^X<E1NXtn_Xoez8W
&a9yq\x<0Nd||<*gJi	ehiD(U_*PO"W"V!1	Jb*`F*JaS
(ddYEXFAYeUVT(`!0L6m0	mjkJE?H
&jBS*5%QVQVP*%+ F*E5!2(N) UIUBM&dX,,,*T2%bd*/
JQp+VTT#U(RS*"*S$CT|-SC1bYF*1e*C*O,eV,FVBd23$20S"2_^UUb0XFUEbS!<2	I!VImV,R"\{s+k ;pR=jt299Q>n7pma$UU5jUmki3ff3B(+$k$p{=- o     G_  
   }  t>UV  k% %U?U10 5OoUzT d%OH(OTRf&mjT@ IJC@ iH)_J!Py2XrR8 css 7u[p 0cF1ns,\g33<^,8x 99xc9pu&Ufn33G9 l*v#a-(wnMdfD;JlM)-mTXUGDij
%&DIfim_8"cR=kY11RG0]kZYa8|5Ww3k2y+=x?aecQ^o!.2|~\12*bfVi6&bhmFeffRs211c0L&Ac&`T&bc"S1&eX3bXcRuONkx^TgyXz[q\op^^tI,Qbf&b0`0j.<{<r,/9.1fK+4iXU)/1<UR1 PawG/^sb43U139bi3
V.1g8#VX-2H5KRvDi&JF|iV1Uia@AE#|:403bNB?8<`pcqIp0<a<c|LbGbt ',mn+UxV21\U/kj68AqVZZW    	!ei)$MEkd&`iY4Y,  [Zmk_m:H     V61c1c66j1ow0x`g1c1c11ccDD1`cu]cwcunc1c1nc1cccc"""DD.1nc1DA1"""" "10`DDADDDBc1^	H&B@$BA2pj@$	!C@4 	 ]U: &@@ H   q!( 	 ] Ho|km+?:<Nkw	|6sk{G{+[w %*s*UUonN|+?[`Zu-{GZWw{]_lk	n{s]Wt|Wph,*|LqNx wg[N%K%u@ ofnzV5Oyc;T_b]iWv***m|kW/}yUUUwEECUE{mUUW*U_}|   \31Jf(    f
)fRo<nK[,rXL;k`$%7;  $r@,%q%n[Ps'^ZJH@aIy2ZZ8  9}	sV.DA{lB670*ZeffZjeUKpj[LH444 Sl^{b&`P{z}G{xx5Hh$5@8]9v$Ks"eI Hff h&XjZAha,eh 5YMds3&dS"qM3Yd].4ArFiNg
NUK:!V#<^N^g,\X2IU1b8<&<zD^0i^BH5PX)LX$Ux
m[V;r2ti$33,>a|x98	1xbb%`vYGTLvY`JGmhXYi0qxIfWM+ZR3q&1qe3DJ%	NGWETJT?H))a*`*00 -J4	MTT0#1U&*V
2 ETEVM2@$	0+	I_PV%,HX %SUH$!AJ&(h*i%RQ
J_lcccfc0# U.*UpU"*QdEaJb) Gd`j%c+#!hc"0hXQUs5+1@a&T-2*8L0TXL(pT%KUv[	YH(SvsDqhcVA`q*$ 	|mvs2@$m*zUbLx   (1P  
@ (O8 }2   )@   VL@@   TC}
  a@	j#c@  4L OTMC#*  $yS  4@I*FLLW\;(9   unX u78npq{7WB`6@yp8y <79<1c1ss.1Q9s9\xc^[mLEA+QV 0cF1ZX5IFDVb5jCh56+_{  ^o--m+e$fB-f323DKq+VQb^b;T)U'6*Jlmj{"-b*$4mEhRYYHm4_Maf&3fK9GsS2MR3>wkdfph[l0+C0q_Qm`<|y~'|:v$fyU\?{v1:wuWrW;'y5a]fm,4Oe;qEgfgm+[v#gL/'JS_U|[8maYNyq[m%sT4R~*xmsmhOkj#DcOaQqJ,OiM"~&h6UiZjkN2hvm?s#SXRS-ZZBkT%N
S3433fEs3ffJIs9ffTjW2,&Jr4)2aK1ma&&lNq9XRB3@xLE<ak\hM&b#4FIR91?kBe6&@><]U/3y./W2-i.vmc1YRf	ivej&18UhY$zZXXaWIhSQ4&mH]}x~14-~gMmQTM\%~wk_=e3lw8s_=4bu|yX_!e..~4Mh/W:#n]j=</%9"Yk,dvlvhOXlwnQp01><_+_5qWc;'1\[Hf+tnrbK<2Sbd,/a/3QfK3k(]vk6_,hjv9=mV+UU*s2;&lqv9&+%X<^9K9yrh8\Mj*yi{)lDmrw;2BefS-h&di-FQJhYiKA3s[Vei7*YVI6jIT+Ye14N3jm+!,:sfLh^yy\)_C>86wwTuwp\*GYKbb<V#^|LcKTZU>h8OK?*iiwVT8qb~
d[AuZeL1g>xk~"m1aL4E}6Fu[[Jdj   3M2IJRRZUkTdi-,lfCV$Y2 $b;sf8 $ 	zp%eW]u[yUr]Vc7u1c1cu1c1"`1DD1b"" D.1DAD@cDD;D1ncDDD1cDD1DKnc H H H1c1c11c^	^mFc1c1ccmF1mFm^nq	@%H#uAp H Unq	@%H/k_dMcdI	!iS;v9suuVmnf/<hOlJ@$=n~-F(3hnk	! n@@kcMYlss86C~4f<Z6 kCHM|wddc3am{+~"'(YdB 7
"=7uSmtE/qm J7Vh[9] !	V

PN/UUYk,e3w2si@NsFkEUU PUFQFAAA@&r$xI.vyY31-LTk.t%<V%-"B7& '(I3B^&sz-brj7mmnhjs$7<k5xWm'FC
Os

H$ 	  @ZMW6_Wmo{^[H[Sej|{|_lr;|GmiMyU =L*&+4&+YE5ef0#@R%i-2S)-Yelv)Z&+ijj%q8[Jdf.dNS4j8qpqX9ei,isTv;`Qu)'I"8-c,9l1`aY9g,SiQ^22`]mXaVci<S292ifgYUe8F4VbM9BWij+&xNb88mR-kTsDh'Sm+\V1#K&j*xjaV(!TnmY$\3fa'yTV0)r.QfXa<U,ZFKUZ [-ez	XtqK#y6Bnti^BX2z:s2X\u!nbSZs/iax3,Njf&}IVCDE-VKlRB@6Oby>^Ld
\+v55wNsZ8bFe|06!UG*GTGBJJUBHb*#S0ZD$bbT`I*(R5RU-*@H1)J
WU>?>W]l$	@^ W*Z$	,H+JQ
ZTXS**LDT$MHTT%,U$aBJD*	*IlZZ(ESdDYKj-VF	1u	/EJl$tBM0I*WVRFU)&e
R% ff*C2U D`YdlKbHW,'	U/5L2[4aX4M[YF2KfCjeCaIji56mT2Ic*xc 2EI` aCDMPeERRFf#EF2"3m)G*__wM67<<+?){Qo{xgx<ng3 HmUUZj~g;.[@$	zYKTMD"Jj%*dMeF
5~  @Qb   Q@f hh[(i@  65G@K`j 
9Q  GC{aF   HBJh@ [5<A*db0E(!  	=RQ*44hi&zLIJ0&1_{\"s0$  n"3J\DfAj+nqE@i[swsQo9o7swsQo9o71c19ks8:b{PVL&b5Xj#mDTEmhbdZ*- cUQKa[I-6MH"Emkk%RcmhZ#X5mE[kZz c;65Ul%Ii[$km"Q-M Ann;x^uyvVj*2R{v f".C`QU5E;)6$6F*FlAdjE+-Ii)(#Kg%q3B5?[/02af2&`Uq_G)%=3I]#:F0i';rm llY9uC/|VGBuk6>|}L0{llhsSeSUw)J6-#|wl3^v\u2_GYm'L|i'd/Vf}u5ZVk\+3*J
UJ92+Q]F;Ug58n:]Wbwn~f`]z=F|2j>&}N+2Or|flVfGq..p2yeg3e)228||5lt*Jm(f}[ab<z\ZkMh]_VkQ\,9>s'7NKwU,_av/{i{TvSd'mU&*YkV%V`6bSZ@LhXlv+JL5YV5m:1SG33*?5KL,S2N0YF2jK#8:tYj0,i6jUd'f4GW3iS:H\	)I3KXS2S8G3V !a1QabY\J0La`[h!4Ld?FlJ1
x5f+Nm=bym.e/Sn~b|Ls"O-^}>u#kEm3s%W_f1Q3!jhxpf"d<|zv0fI2V(bcql1m0dKkECA5ir eD*iW_qSfW:k}%um6bI\(4a>7??GZ2hDBJUS%MJ*DS/GnK4kMNn\/nG^Toe(\}\4^nd3Ajf,ZFY6
nd9k}=kwb+F5}n%m3urrMs1G|-3'Y/2f><TN^wNxgflv#S}+q}+E(k:l"4/mUZsn#.*SNr.MsN76#5.)YSE%V52b-NmmKfG53mXVL5`Crys4kcQeKGz)UQr+IYmYX5%wwtH]R7Xj5Y5t+j-Fdd3nemSBBTHm@R[jJM,*.b
I_R~6,YmM"*Pk\mvCZcJU%!Ymj4KuG7cY*j9n)\jW7<xcv8]y[fmS[Q);xs&j:Gk\YSIG2q'n^;c6w;N99U8NdY+mdibwutJvLwP0qaWWhr$	c*V1:G`kWI 9F?+K,v,i\31ew8'f-b++ nW}11:L^ s-0Lm*R37UW_j/cK`d;ZV1*-TuA~Z[K~  %))JRRf1Z:f1dSJ22Djc33CT54[-0Xf2iHQ?%?+  %H/FDA0b"""""" 1DDDDDDDDD1b"""""_11c1cu1c1cu1c1cu1c1$	_/cDD1nc1nb"""%7\v1]cuc|+=8W{{;8W{wfp{	@%)A.v.WZ$	^61c1cj1o|$	w1c1cc~U}*UOU>Rr
0Qk^s1+nxjsLC)szs0\.&fg^c$V$)
XJ#s7n>yY)uuh1a1ll7bC0%Tf{
2Fws[V;(0y:gQUI$/A"LVZM]5WWQM)K:5h		WVs6.{7	wPv;9W*!VxZNym[d"7n[<nHndH2LA6yy1WGo%YmI$L9[`Qu4AN 2UQ@I;lws6rm5i	$I5vIR EX8[g]$KI$$I,dK	$2I,d?8JB@$5u>}NKjjgvfwp5kf[t $	 I  I u\%[y<pQ41f1VVZ2k!MVc1*aD+kiZjd2"eJTLkm[OWiT,kk%8NU[K3KYuGM'2rKlGjY:LVb;JZiUq A' PkaV0:N\1el6,si-fSs6YNK20:n:\gKf1i-U6l%O:OX;Q#w@;shBf'zYjC-iW=9^M*[Q$IK0g1{FM'Ie#hL5JiWm(S4I+\t:wJ'S.]Ur-Ze8)T
SIJ?mLf0U<L+tZc;wZpq8Lu/F{q<Zafveg=]mY^*e7:dk,U=.hz]Z^d\vmBaZ_>+YGVD$dk|IF2NO-a|d^>4\+tZY^4V;U^AeNI_us3wqm9M-6xF<.0QDc[||T#0a|].<Vm63I9'!,|BYVNm[4_'Ee;V(-VGf>&W$[6	DUI>U?`P(
R)K*, `	aFRUidT"L&4	hRM*b(QTIhDcqm H}Z6P%Q!L"%Q2)`#(TYQ)Z*hj
9UU)Q-P4S
BPj
J&UZ@[66%L%&fdbY2
Um(f#a$"c$'R
M-ihl6PR'*MqQNJVk26STFCfJ5(D~~JjeR$R)C1m3+TfJS`i#-KY"Z3@Vh[4VV3MYFJ!2uSZI/$~PadeeVI1cFd3R3(h)IKJC
}FjaF"lU3,X QdklIE$+	e0bbdDL-6I"TKkv^wzGP*_o<i+%[B!JP@?$	: HW!-_~wcR	@%!QISTE%JbL   (1P  
@ (Q 4 6  +[a*i*   (|**F  ABZaT	S2eJ15OJ0 5S  %d2jJ)C@I$ c{QkDPs]^pWZk5+qjWpo9s1u=wuc8y 56y8y 56pzs<9c u 51sknQCV"+QhF#[%daeY)TFQFhm11Q(luS3	K2wp];JU(6.MbVr{'pknZHZ-l[BTMX+"m)6S-%666[!&jj(l&fhl3K)6J6f3WTse3]Mds\{2&dN3FeMlhc%vZ56\j^I]"Ouf;?im#{3Y+;fmm:+fcI^kj=6b|R[3W}cj9jolj%{mmXd8UjW0cX}O5gpSAUVQkgc5FxU=fYj<W-gl^vljqS>2 h7_OQJaI&}a&a1OuOrAeS+fhd6Tjw1GV3DQl5Um2Wgmij}FZa6dhJm%Qk>1])5
Kgc1vRH+5`~ &,.	S2fC0O33 x1U,GC#1	UxrHqYVdLb1R3 c %1bff]TfZ0+LueS2
A ffj%VfRmL[VeYe j[pn{|gYIAl/aOkhL|u]{N;/zB#m1|k&8cQev[l\[im^lK6;3XwJf9{IlyY{'n~uV,{808SJc2L*4SOV^ziZI~.dt0m>>::3wc&#Y{;1\&v>}|tS<=qyURO1]Uz&[+nssi,m=>'iC#Ke5P,b'Z2>`,af-cV[MK^*7$zWkmk.Yt64SV4v*ei-$f*Nd=tS^.6Cpyfhzk0XJf31[4mj1rri*8XAfRik+ERmA"KeU3hXEYM$/_^+Z2jE&1_/;l&m3m&FdHP(%U)ehgfhEJUi'4vrjT<c/v]cZVfsp[<7peAW.Is\n;S-S<h[NG2r\m\]N5	9IJb:=CRRK6dR1FNmlV2S8x}]f\CdMS%v^+\\>EUU9UUC%-/<=aPw?   3$e!$RKZ?qF4HiDIkk)ZM+M+IJYIm%6+  %H/~"""""""0b" 1DDDDDDD1"""" $	^}1DA;1ncDDDv1]c|$	@$	_o" }1c1c1c1c1c1c1c1c1nb"%7]v1$	_Kk\ KU1c1~.j6j1c1cj6o;k $ 	z^ /U_X1flVlJ+bV1cQ|s/}F/{k[ow>}vs3G={|.~oiU_TmMgBjFY5ZEnnYH^#qu(=m>6bP7S8MNr=jHk2$nI$qZHBi&p#t#&v($4qCpB+0_:	yo&bp eX	"|Ay6GxO~[[}4!Obco4.^nr4g<PP[khiya[@(  9[\svy5 pEZ$]DeRjh`C1q-eRYl@AAARJB$KaNf.Cgm[dy rwmXfzwkel`K!osuGJPR%i!Giw7w{(;dLRT


v_3=}Ui(C}wXB(w)a(*I$BI$I$BI,sKko Hfm66-9n4l$Nm9D @2@	$ $	{b0e;v5a?DAifbmlUle4,2M&Ulha"XT2fZEKZ6LaZ,Y/q6lUm3m#.#0[8je8j$Ms52'.!&S]Sk	LhFt8H(rU\RIl,88KZPAvFw7[e:;mN\#b]b:4jY^0kk346K5Ng"Zj^4{yC9W%{-a9SeZtgTC{TlZVSL"qR`)1re9ShyjpDWce8nJ<ZufhJcgYKNf33:<i21xl2xrR.`LAn-([f[yy;+wP{k1{^zbb/|fhWQ>V$r,xYN^.<6;c^SMeqYb9sijlJZQV}Wg_.gXS>_RSEURy<kLvJOFFR5Y)93V62U>S.(Z.;6hhTR}hzW*G"$H1%*aQK %H$aUV0P(j*5-MM iD%0X
%d*J$mff?PP/
RL$XQ&
&UjVEI( -R	u tHK4)%A2TXKT_*)O[6*Le1aa5UHDjefRG*E\P$ tINAEQOLd2,!1XS%LL~TjIVe,0,S"jTLUV"6f0XUSEY_R<Z*5`5XFZa(Fb5A_<)Z&"ZxUV(d@+df%* mRR UkvGcdl
?%}_s#a+>g0O'?wsf
TX3fQ]RTEJQe5i
^= G  R F}9>}(h	@P@7`JUb  J}:Km$h J ( ]i2F E?H 	O%)5F@ $IEH=M Ja4IJF4~?cc\A]7+uq9^5+qa4SJ5pup9$[s{ ]$ZuGTuE<}U*QJ66Mj"#2S26&f	Um@

l[#e$JSff>34fc13+sUU66*Ge.ZA;f*GghmCME s ZP+2bK:VI@6VTTYkk}ko6_[T{+i+MS9l$2mKh4_>WI)/0;6a_4GIJ3%|0UO6:MVH>>m+b}+.LRu~~~sjBf325~U_fisU}eCaZ#mIj,:healI5mCUfV/b{om&f$4lLh4[l,lDL6U IKlaaYZh>%|50fe^|H]dfY6fylELZfPfZelel'cbWZnZ5U]MeRR(Zl2l0m3dR%fC'd;[ka6j0#!8L01f1|KL&,2J3ALES!9<e%f5)T0KZ+ZZ
xje<qKhlm/-h numwxeCC|<pyujkU+~s(<x^23U|=&yVFbVfS9>eA;~{<!oW^)W2x2w,>%0eC1cfO2~LFvaCa',m5i)9,/=;of+Mj*efY}R0	u4X}>xuu<smmqxtunG[mn3:
=|FRTw:MfQe5j43QuUd{FfjBmRWmj"CXgf1h'(cm{(%PtBzUTjo|+"![4TmKhX5YLjHV2hSjF:jH}z=`	aa	-	F6.jlYZaYW*flfFWT.w9Nsyp@'aEx"H\js<=*eV[m^eL9F#!wi06vA$H\'Sq[rAUR{uzfaiDDhwn&pu @  n,Yb)b)bx9".\Kw:U]]_}cl6tprxk%y90oZmm+oh  $	$ jmji$)(JR-DZ-IVM-X#YLfY*ZT_~kT#M, 	5o``ccp1DA0b"""""" 1DDDDDDDDDDmF1m]$	^1cjpcucr"]cuc1c1cuc1c1cuc1c1cuc1c7]v1"DD.1DKnc H@L	]#&B8UUD@^k1cj1cj1bAHg%"@wyUr]VmF1cccm^|tn"  %P   IWH/j~yr}o./_ff}
UVp
`|=v~U>!^N>_}gk+, hT32.u$[-}Si &?x'
J |hL}uU[P~~{o	*.]2,$cdGnlc_UT/d;Rb-)0_}q=a `:	+Y* NW5pi(xz{d 'R`[WXm{N{OCd gFlKe7nmf3vgHz3t{,MPPPPPP`PPPPPq GHX"]gI]7c1PEfX	J]&=\C-* M HQEQ'Cd+5[8ipxt7D$exoBE0fpgw"JA??YYY]Y]veg k323232	@$md@r;`@k**`H $@%t)5Q
$Q*`21PE2)FM4i4m,dRemmZfAZZRZE.ZRTE#T.lws;K"rUU6I$2\*)	kF:ILb'q;twUuu%%%rYwl9j\kQ.mepdqa4SzZJ2jek5^55e6oMe{]{zQe:9WT,]^;CWvU=q=^L^5{ElU
/Uy[ZkMb9H%3eIVUIcjQ&m6mV]sd8k^mdVFUU]G(^Y.[ONvL^jW,uez/fyxM&a3Q$}o,,Z;\WMr}Pdr^>N|fc7g_lfZ4SW3fO"Y,sp>Y\|yp'4v[,0QO>GV`H}`apm:V!ref`>}%sTl66aEUP>WH#
AX%bJU`dS !U%*	&h$"XU0RJ)AbT%@#c?UQ_%SJhY!JH""'(%!5BJdRS!
Z
*YHAJBxN)T)AH+[YTf!P	PJSY-jm
+$+E9]KaaM~$`mC
I9PfYfa
S$_ d%RJRd$Ra"D#?)~B~PS(S
dL1L4PfIYCXTiejM$YZ&X%JO1"~~
OFfkmV4Y66	ZY`U22MM3@~9.bCQ,JT-$Ud0ABl%T|K0NbJI$%{5vvmpW	UkI'
a?AK%g%C:"  ;Z)]%wE  [kW6_4%STQF)U"4QJUQjQ2(+$k00a? o         
f o}k8pVT Hj~ JOz=Gh ISQ&)DHA5)
 )$ C{q{x3y7qC\Y665j*abswso 9swwu]8:w1suw0g] z  u rQb&#mFV("Z[EII%=snvlGim]2S13JI;Ne;RFhLfS0]mQ6-bl&jch,kbQFj1j9FS8e(9T#(a+04tdiU \5IgfkUtis,1Wq<fP<W1KP2*ZFX~a<Y2/1Lrthj+1W(LJ.GjY1bX':/0s`e9ER?dZe7652k&hkvheITcQK2vYrP8b,r8U1eY`*Ydgrb221Q*2F,e1,YaYW..rSibpI]M8#,XTde.YW,#UFYe.\,aqbdrS#&ed_G8p+.I!^Xvfk5<YvO]{neYYbyr<g"fO,~GW^,^\,3\,.,Y,U_)a?3499Ns2eN,iX~L46JfFR+b+iLc1I821h*QX2S;0Y*WcL4e1SpkA[.JWn16b'?.NYtpccq<g+<yLA#1q/:8d18\4aN>8%96~X/,[2Ullg,0dYe\|q>~3g3>PMF*+yx~eE.Z5++m Z'%W-,KK,YTEb+b4ETb$dJH    jU_jc0H/1"""""0`D0`D"""0`0`A"|11c1c1cc1c;1nc1c117q1DA;.1DKnc1c1c66h};8W=w3pj6;{;nc1c111Q{@$	@d	uZ  0   Iq&IK)D @ U] 
&M{nWyz~69{[mu|L2w*2'5\wk.DnCljkm$4RIVd.Tw+lqyoVTSCu_sjJEf|`e6O~;O{A:{'bQ %fMe,QK/]F d1f!Rmmb["DBjC:Umm7bWvamu`c'y:] @  H|{=$<7*+C0Gs$32.r2K!:sQooxa'4 kRn[h@<J nTVUtY	o8``NUUUhkI%}h%WnIz0DfN.$E)w3yOmkmm aU uC[mmJ=j U`ohjiXNYOoOv]t+X$	5&U<kK-Ww]HJZ-hXefSa

XeSi)lZS4Il)9qBc)a9)qUVh(afSK8Zj9fS19q,9n0]rS
dc9<S%Le,1WsP-*$bKyx
^P9X'i[1mv,jvpy<eqXq[aC--&a9yq\x<fX'm>>cTAl)4`TFwE]*]DK$zURRIBP!j	hF0JEYEdFj&hEZV	/iih 	 RJKHx	
2%VEZ-D
(T0)FBrr+HU,*1R)"	-RQJIT'[0$BK!&f`XXXXT
FYYdd'Jdb1b2O*<9#W*-"*y!yQZ
P*eX04 P$O*Xjb1bF,X(YQEX#Pa*I?#&VXcXb%T?FYUbb)LjR00S!&e$UK*1&CAB)m40I(?vC{oGoWU/ AuSAtIr)R$	  D}>c&l IU[dMe ~  @Qb   QjU@       : Oc1Qa||R: FP]T2iJd  Jy*J@ IT4hRUM)$Oi ks 778xR
W*S`
WWV;9)BVh4 (V9s79uo 96c1s*33*3732 17332S32S34]8yErITYJQ7qWvjF
h`66 mVlCciT[Tb+6kRDDExcOcR=kY11RG0]kZYa8|5WsIG{;^<<}O330f9sGGsCK6b>E2/M,#4#dfb,9T~8*X321PfF1X11fIV0ff%25FhX]v.80+fTWOepm`/92~;9WUv$\||?',1^\Xa8\sfxc%Ub*~-mf&=u/w|O>qf3:fKYV><<1xs%q<yLh+UV9|=rxq)90TH+BN|,cETDZ\07dmLi4Ly1XU)EG$\L1U&t)88\<c3<Xbq.3q+g>g`<9$xa!RHmYS.\ba/~8+qWyb^6LeuuuI<[E`    	E%$X*iMLc2ifIiRl  ?5kZVV!     H?DDDDDb" DDb"" 1b"""""_c1bu7\0b" ;;cu1c1c&1ccccu7\1b"%7\v1]cucu7]v1L%Uc1c1ccmF1o0;{zj61c1c66j1cj6j 	 H)`X  kSd KVD	    kfP $ 	uU$	@9` UlvUn;gR>O<JUI',"X;U W,D	1Ie.)U@k\\b~a& rE n%Y{xunfmmI<Zrc-=:|_H`vUuTV8^y@Q(6  I&TfXXQab|vn-jMM[yf@e1nc.  @mU||}TW=UWT-B3333>xC1`    #ld         F @WR]Jr[oRsu)y    sfqdV^sywzlm	]5#JRk7  	Fi%SR'-s{';jQijR!U    udU\Ie[I1!@I^?QK5T4UpUT  UUUU\U]UB QUBw<*4-_}w`;w-|B>xk$L$MA I$5	 sRxIZ"0b+MZZjLDi+J!Mds3b.1+Ef2rueWHXVeaNM:q\bJ'EIpRIO8r9b<b.V%DrN2.TLq1'r@JSMUZ!,1UW
c*<`2*pGU
]ksqdYkffeVRxq<Lq^<<Oi.+(kJ)ZMjVkd'\UV3b3R16lG8U}PJ1,5E_5-`GWEJ}DP(,*,THb#{##@JC0#(I$V
V@ RRfY`H/C|$#B2E4TMJULI:R8E0I("D%EQ/db3(U+R	8U\d
(_"Ad,)VLR`a`H9LYbY22!CTdjjVbP+ei@C	h`LC+%j R+%S>}\l=
!:g'p;ca)J @ JJ/I8SX$	@U_[[V1AY&SYAc_`{~  >_T`.t = UV   @@di    uwW;
   P (@
z
@ QOJzjOS  jT A4oR5OQ    $JHRm QM h 4I$UC 	>sy\BnFnFnFe'zCEocMok%S)JRL	6v9tam]a/woOw98{7s7999l`<h4knhc54l`160\   +x60<s  5.   mn^Zm2+FS'b;mm-bb,F-bb,EQjEPkskU00#0ccFTXQ,l`(K5X #jZZZ[jataFww[UmUHO!J-)ydk#Z@ej103m$cal1l0[cmEZjca1U00#kf,)XkVElf2/<e
3dOE4c2ei+Y1j>e=SZ&YX|1Y^&CPXeaQy2jUyjFd)j2+^14hz'!C:'#~2D&CJjV5dVX1W3&fqVWyY6NCs_w2Jq<'pF!#~`e*>Ti,{T}d.1T)x:CIp;\T28aOd?	BGyQp0YU&I<9(ap:eO~'/Q5#GV?#S$1aqx1aUda6V3380ccffU11?Nf,cF3LUaf3$F`38LU:{$MQTuxeFk& I=ew]m"{,mG0DfT9RE.#Uvo=Q"OT|t;Cz 9 4)jc.RCS&V5LMJ[fnxM	VJ\\e`Qp+S`p
YF
N-:gux[Sb&%5#iM~HeMQu(qz4h5$ep0
urjSQ+>r]Qq._C1_:d15Mxd|s+55'Y,?^6T5G^&.21N1UCWQ$q]Qu9YT1=FZA<4>0soj~kWKThEa:'rS
98-VJlllmZxL%[HL&	I[fm%48D@'JudJY!aZETYRcal]J
C1Y3%Vb
5[\UQv#66!iMca5da0jLBCqN1CTLX.3p.q>qc8
92Rqc7m8>R
kk&D7]"dI}J++++,Qj1cmhea3hTC6;tlh-ik+44(M_tH!o"" 1A#=c1cuc1c1cuc1c7\1b"""""""""""""""""""""""""""""""""""""""v6Zc1c1c1c1c1c1nc1c1c1c1c1c1c1c1c1c1c1c1c1c1c1nc1c1c1c1c1c1c1c$H$kKfmg[j[-urW?vg}uql[|oAOyI1$x|I/{9}ws}{lzlm[
M,mU!S*c=uoK,X""5b:4:[:zmkI(,F9MT0{Wywo1r=tDUcWVbb,^DDDk>o{e[-xxz~i;zm%:H$o[I6!5[5d,bK\39<I%]_s7CI1+s0S30*H$ q  $ ?MvPuWlsrfaZjO%DT/AR5F6j5FB5bX#QJ["k-M-12aL46UK,2RbQffV]bF2c3!74IQ)12)eQFGy``!.48JfMIe<b10Teb5F1e`bS$#@bM.4qz]bU5FIACIYdcx^ye\5+!x<WrfK&)g
+6k,%>
:[&mH&XW1I->R}HA_Hi6m6m6m6mcv89.%eM&A,ZD6#>3*I<>|<xx<j,px5I[&dy>?3d,R//?P?FJ0R&(!1*0F)4JLP,P,#(SALRK
	XTHR P-+B
DZ(`/22mI,i)JZh[iUWRgo[Gb*^0
Ab$bbU0E(	J9UR%IM
%4Eb
K+$("RT%T#PE|,LDa"	TG=DJO*8TAP %J%YdTVSeQ~- X5FYi#*bY#"	2CH%HUH0bBJN0J%(KJY1VC%%cXUe akc1*W0aTL1aa*p #GV&f1a_BQ"?xg0p0pp xg0p00=8`=8`?=_&ed31;wN<~p#{[mnW44444/I$Im]PT*6;\g.o hhhhh^I$hhhheBP+s[mrk   hhhhhhhhhhh^I$I$I/[l2S
T2wBPTmtwK9,PGs3I%%KT3kiiS66j68i3j3kj36j68i3j3kj36j68i3jmLdjfA'I;<6mm2B%KT*R\FmQ6QTffffFpQTfk-FmQTgFmQS6fFpQTfFmmFmQ[QTa.U$*
KT[I-[LfII$d^d^$ONK"YI$;   '*  p 	t        YtY                 mmmm         P     m_%wa"%INF%,U*$#eIefK,hJRB H H H H0 H H  &	OdY I$  `  H H H H L  	     A LY<eQ)bE VQ\RjYeIeh)YYi4UKw/= G8`Uy@P?VecjYGbL<
y  (1t  }\9  d_$" lT)bJ      6n	] UJ  >P R;W}:MDO@zi	A*#M2 OR   )F?Ti' @&T	  )%	RO(  w~owzn>_;0[g[r0zKnX7r`8=8['8o6Nmz00e I0&j0&j}<   >s>W|yl`z   ll`7m]<   >4knhg5]  yl`z   60scnx   mULlj[-KeTQb(",EQ-bP@E5EX "Pc00l`#lXQmEhllllQ-184Nl8:0N7Z(J0#XKZs6mdaF0kF0mhje*Xf006JLhc"U#B0";umMEdqU4B%!ZaVVi4bW^e.-JGCUbbb1UuZ@XA@9exe4

G$vvx\_oBJ&,IFZ1|5CZTq|Z(i4RN224)q.#q\GN%Q<Wa]J]=B	c/	``5%t$$N}'J=ZSxpS4j]I'h>/!P0IzWkjQ'*+qyt1hSQ&_Uzlm_m h5,I_0V)R8d2qV2UOr\8UXd.QXeLQaOqj#UTA,8pmOp Ucyd5[CnnYMW7CUd6%UUjmm=9 <ziF5R
-+H4X,Z1i,X1Rt-VI^uY!N6	a3<L&rHL&uuZ,%1`XK'&*hC`~/OHQciLrUp'))<1`XE%qVD:M&It4tNzzx^a::'R>.4{'UX9'IFO-+<gSSW42C9RLCqV'*UrADdS#+#^Pe:N#=*,z80vIQ,N6nTllUy0L&	!0LIa-m{[-mJ9D1+ibF)]Z5lbfkMvmMBrK*j%cCc@cb ZVIMm&6R5VhDa0MmBa0j*rXcuXiLG.Z5u.=xjW+,8*Z5u.=xjI#mUdJAi[wwmcfP8[/]Y&$L#-&IF41bJYIdjZM&/=YZiZ>^V 
jV##F""""""DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDn1c1c1c1c1c7]v1c1c1c1cu1c0c1cu1c1c1c1cuc1c1c1c1]c1c1c1c7]v1c1c1c1cu1c1c1c1cuc1c1c1c1]c1c1c1c7}o[gjz"c:nc;[|,kuowD]Y|vmoW[-qLEx<yx<w=_m_8]jtv6;jq\\mIgk|XD^X1Xb{""53}[-xx}=iyvvK]cc7c-Xb~c3b%,Xb=1}c{{}b%l[{x<y][i{K;3^U^Nkm k2=L^m0w<:0tq[_J+$mi	 I0ZZViM$Old8501\iX#JqQ%DPIhZ8#t:]`0dX5+	5eN .jR\d.@\G+ux*<AS^T9":I(YXN<O"-\dbqZ=Ue5(b8%]2xQ$8q'^I^UH[mkh/olEm-gr:qKc+FV3UXrEI%1-[|zkA'oK$|bZ@a^RU6ptvmS]zU3*Jf[eHi>_	J?"#J" aPJd$VVVJh4HibYLTQHXTjACDd"
`Tl5U6SB 43B ,lP $	Mm L[@%O3kg>_JW*0T02U DR*G"
5eJTU5UPdT*?IJH2+vUt0VS4~jh4# DV$eXT()PFeF,J2"e#	Ua2#%*"HpjLXV
K"+U_gy]pd	 {J
W`!	+yg?N}yg?3kg>3{=L6='}_}=uI>3[l ~9&{^{~g>sskoy|~L|m{6zOs}>L^S=uIkg>sskoy|"x^y<ku{~`^UyT@UU  UVuWUuSx)7x Usz*  9z  U\j/^\/xsx/7UUU\  >    ^UuWUuWUuWUuWUuWUuWU>      o]U]ULjcSL^x_b{|Y^=/zzboyoz	R(B) E!F
"@#4 44(-Ie)2le&RmMIP[2)6fRe&AlL(-L2J!ReerVvE ljljljllVlRser1@ 1LSYYJbbfe.YvYvYvYrbb6lP1@SP1@R. )_mow[F1 EUn2B&Lcoy>XWv=wp  ; a73w ;   <fa  <     f3r"G*2&U0`#F $	@$	@$	"0D`	`$	`L ADawD_z0Dc.pkomZK?Vj/!3o?<9&{</U|}c2DfYlYDDU}36l@$ [- 	@$	@$	@$	@$	`  L     	`619
dL\%ww.rSEU3fBL41,l1 P$	@$	@$	X"$ 	@ $   	oW~e_s)|0=Md-:]:]5=F':]:]:]:]5=F'S5=F'av6]5=F'dMgG~  @Qb   <     (1
ihj    /&l
)&a$@<D P@ uhh  zUiz@  ITP 	%%@6QmGPzFmE#wE#}}w[r0t]wE#}}wwzm_wa^0e IT@mta)M@mtam]`@mtaO4l`1  F9[sF><   >h4Whyl`z   scnx   |cW|\   {l2cehTZ(X "TZ(-bP@E5EX "T`01aam60j
660Uk66666jm #E4,e7ST{<T{k^m[lMS`PP+45InFUVc-aa[JEcj,ha000a6zF*a6F53fmTExXFT<<WL}M4LU(^"0VP.Y,-J,Uqe-CEX1i1i1h#XM*i4ST`VJ&INY,,P(<hyAtSK/?.RiVV20hF4R3(|YN2j<jE:/z^Qz*KI~X^pDM~^DVQ/>WQj+jLTIENMC]^R>/	|RqxLLIG,jP@r/	\L4%k?WNjcZi$)XY'/F,_\1.G,1\XqpFYb..XFU%1b0Z>	rS*xjT^N@KmOU  z[mnnYdm!7,V/*AaCmOr('z*up
XS,%'eP5KPS-P020$-SC%yF+o&	g&y390Ua0%i':BuU X>.qt.z,/qz,e8dYu5=R\&NE<Yk.Y+}JZN.&,ZE2#x^I='9K,9IjuP2H|_)yj^^k8he}:V$>NHybZ1<.&Y$]d1u'zR/	z&PNST9z'Z_(F)
-*s]65[<L&	m]]`L&	*pK3Q\=3V]Hj[Q&imuX,Qebe~+l6lVkJeeI;&6F	&a0Kj	Mm]jVTjp,,QjhjKkh\,/r2--r^`Uuu\/K./D.jm[l#E,ZM&IFM&&a4,VUTd?7fbW/B_^ZmSJ2fmRTb""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""" #/c1c1c1nc1c1c1c1c1c1c1c1c1c1c1c1c1c1c1c4cuc1c1c1c1]c1c1c1c7]v1c1c1c1cu1c1c1c1cuc1c1c1c11u;Wc:9{e]E/l[-UOmSAI1-tm<Z.YrQ?8jUjU[>y1o,Xb"#^c?[o|tIk^~,},c,X1ccb,Xb=DDI7[b,Xv{{A$LwL$61F:moNpyk,1LO}IOkF{VP
?h%Z#Q"0RL40TeT_Z(T:qWLUf44RJJq%B4Ks\N]ab0RtS1(*SG":*jzh2E<XQ @yITGB:D&P20tyebi
$qei|di:zV$KJxUd'GXRaQ
aDUP5gF<x+XXZ5eQl6a{W@^^pqq#{YeIb$lhlTU
m'3 |g3HK,'WT!W(
)F*C%i%P4%SKRSBBSXJ((#TP4(UA0FD2	*_Z3fl6ee L@ H H H H0 H H  k6W]O7}(
DU0a$XA:UR!4Li U+RIDe*J%EHq%)A~(Wy/*UWKQ^I\#DqU"?dbB2I&i02M)S,YbB1e&BZbjHD
~5QdjKd1XC#*beXb0V
BI@ e5Pb%IX*NC&#W!/v[_<}w}=q'?x}&{{zO~w9>L6= ?~&s}|l{m>g3|g7}3csco{oI}=wK}}i|S=q'}9>L6= 3{zl{m?sO^lK/[k mvme2zv2=^=^zz}mzmmmmymmm<Ws)3=to] onnnnngmx  mmLzmmmP6XeXeY^TWWggoTWI}V{[YY=mz\\AaeYrq)e[e\)mXYBZl,mYBZl,mYBZl,mYBZl,mYBZl,mYBZl)eKVPV''NY}9:s\)\`6K%6e([e!+Vcb\.l %r66LgS%cJnu3LPQe([e!+Vcm)e[eTO?3csco{oI	,+yI  h 
9TAlH  	  *Qp     p  
D*,Ua#F"0D`#F"0Dd`DDD(A"""DF#F 0^+cl{_6l@IfY,[,b H H H H H 0L  H	`%0fl@B- moy6hcffc,lc $	[h`5XV?{{^$4d7,%nmnY"[va,Y[nv,k!d7,%nmnY"[v;;&nY"[v;;+tXnS:,YYs:,d7,%nmeis1AY&SY9ec  `   >|    <qzX P F   oUTh @       ?U$@ 4    @h           56HHi	aL C& 	6hdF  	  	0 Uz       @            h)   @ 4@?T  2            zQ4M1 M        @      @  jy N&f$M4[	*6\[u;;q:nH^^	0 #b,XL\\xKX"im!,Y\cc`3mMfHMfDTilfb7J677*[Tbnn"&i'*]1"cUq18+Q(2jX:`b8bLba63H8c"0a:ua:1c`aYdf*Y	R6u	J2[Ce3*6',-VFnjOQ&X*W5xHuh**j2Fx1x1`2xh3d1ac0V1&001*bb10Sm1a5ff# 1^ R!x J].yMm   mFFFU-./012g$"d!B&7R^_ `!a"b#c,ZBFJLe   @B%e&f1;<l
*:JZjz5Uu6Vv7Ww8Xx9Yy:Zz;[{<\|#0                                                           00f<1b35***yY.H$	!H?c{=)<!""Cx&is8AD%$wr>>eWMH[l[mflYV!B!AE"DPPTD





	"ala1'1BALl)ZdZ	= J|ju*:9
*ghfJ0@J$JLM:iyg{<<g<}m%@P)^Nbk%$Y	EaO&"6SJ#Jj(.*)(O'66.R)
tPQ
9JO&RWP] mlV!5xTTJ%j.E)XXZ))&	4&FF 1(`)P0)bx=#\BIRe((X"
a
,QT;)r	i(I	uQuUJ9I)]h"(r:(uR]mso.zS}MM{;wnn;3}PxBH rDf)l'QBA#;&IFb`Y;EL6Q)J(R)BUP?y:ny8s3-`")*kX$EQEQEw\.]]8|q8n8/Y,YeD=oyn.u6]qqxYhy$=3AAtt
5UUUUU8Eo2|00,7ifgr*Fo+8mOVzv6]nHQEQD           wwwwwwwwwwwv                                               aaqj#+-(EP

`P #4  |;q?/ x[;:cNynsO0y|Y<OC;y;v(1 HD*S$A0 RI1ZUralY ox8B{$I$I$I5UUUUUUUUX9I$JRI%)$IJI$$RI)I$JRI%)$INL2dJbI%1	$ILBI$!$SI)I$$JbI%1	$ILE{/{I{  J?$      I%gHX`          ?TH8$A$	$pI$I$I IH8$A$	$pI$I$I =88mmmmmmmmmmmmmmUUUUUUUUI$I$I$M-+3333333330                                                                                 (+$k5]= { O
 sx
v4oT    M4&@LUC#&&141FdhiiRR&2h =OSlUUI*hf-PBjMbhD;;sAqlD*;,6&6QEUx< L=_!\89ClB`O$D-(	^O0	N(!R+ J,R$0* L`L!># JA+
X
	R`
aT0 	 DIQ N{CrIaJJwokD^ ^ SO;:/|JR)J^d^O?$ ~w@TEeT#XN/=z|33=m;:;{x'Gqt;<z9v?rE8Pk:b                                                                                                                                                                                                                                root/go1.4/src/regexp/testdata/re2-search.txt                                                       0100644 0000000 0000000 00000122430 12600426227 017451  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # RE2 basic search tests built by make log
# Thu Sep 8 13:43:43 EDT 2011
Regexp.SearchTests
strings
""
"a"
regexps
"a"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:a)$"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:a)"
-;-;-;-
0-1;0-1;0-1;0-1
"(?:a)$"
-;-;-;-
0-1;0-1;0-1;0-1
strings
""
"zyzzyva"
regexps
"a"
-;-;-;-
-;6-7;-;6-7
"^(?:a)$"
-;-;-;-
-;-;-;-
"^(?:a)"
-;-;-;-
-;-;-;-
"(?:a)$"
-;-;-;-
-;6-7;-;6-7
strings
""
"aa"
regexps
"a+"
-;-;-;-
0-2;0-2;0-2;0-2
"^(?:a+)$"
-;-;-;-
0-2;0-2;0-2;0-2
"^(?:a+)"
-;-;-;-
0-2;0-2;0-2;0-2
"(?:a+)$"
-;-;-;-
0-2;0-2;0-2;0-2
strings
""
"ab"
regexps
"(a+|b)+"
-;-;-;-
0-2 1-2;0-2 1-2;0-2 1-2;0-2 1-2
"^(?:(a+|b)+)$"
-;-;-;-
0-2 1-2;0-2 1-2;0-2 1-2;0-2 1-2
"^(?:(a+|b)+)"
-;-;-;-
0-2 1-2;0-2 1-2;0-2 1-2;0-2 1-2
"(?:(a+|b)+)$"
-;-;-;-
0-2 1-2;0-2 1-2;0-2 1-2;0-2 1-2
strings
""
"xabcdx"
regexps
"ab|cd"
-;-;-;-
-;1-3;-;1-3
"^(?:ab|cd)$"
-;-;-;-
-;-;-;-
"^(?:ab|cd)"
-;-;-;-
-;-;-;-
"(?:ab|cd)$"
-;-;-;-
-;-;-;-
strings
""
"hello\ngoodbye\n"
regexps
"h.*od?"
-;-;-;-
-;0-5;-;0-5
"^(?:h.*od?)$"
-;-;-;-
-;-;-;-
"^(?:h.*od?)"
-;-;-;-
-;0-5;-;0-5
"(?:h.*od?)$"
-;-;-;-
-;-;-;-
strings
""
"hello\ngoodbye\n"
regexps
"h.*o"
-;-;-;-
-;0-5;-;0-5
"^(?:h.*o)$"
-;-;-;-
-;-;-;-
"^(?:h.*o)"
-;-;-;-
-;0-5;-;0-5
"(?:h.*o)$"
-;-;-;-
-;-;-;-
strings
""
"goodbye\nhello\n"
regexps
"h.*o"
-;-;-;-
-;8-13;-;8-13
"^(?:h.*o)$"
-;-;-;-
-;-;-;-
"^(?:h.*o)"
-;-;-;-
-;-;-;-
"(?:h.*o)$"
-;-;-;-
-;-;-;-
strings
""
"hello world"
regexps
"h.*o"
-;-;-;-
-;0-8;-;0-8
"^(?:h.*o)$"
-;-;-;-
-;-;-;-
"^(?:h.*o)"
-;-;-;-
-;0-8;-;0-8
"(?:h.*o)$"
-;-;-;-
-;-;-;-
strings
""
"othello, world"
regexps
"h.*o"
-;-;-;-
-;2-11;-;2-11
"^(?:h.*o)$"
-;-;-;-
-;-;-;-
"^(?:h.*o)"
-;-;-;-
-;-;-;-
"(?:h.*o)$"
-;-;-;-
-;-;-;-
strings
""
"aaaaaaa"
regexps
"[^\\s\\S]"
-;-;-;-
-;-;-;-
"^(?:[^\\s\\S])$"
-;-;-;-
-;-;-;-
"^(?:[^\\s\\S])"
-;-;-;-
-;-;-;-
"(?:[^\\s\\S])$"
-;-;-;-
-;-;-;-
strings
""
"aaaaaaa"
regexps
"a"
-;-;-;-
-;0-1;-;0-1
"^(?:a)$"
-;-;-;-
-;-;-;-
"^(?:a)"
-;-;-;-
-;0-1;-;0-1
"(?:a)$"
-;-;-;-
-;6-7;-;6-7
strings
""
"aaaaaaa"
regexps
"a*"
0-0;0-0;0-0;0-0
0-7;0-7;0-7;0-7
"^(?:a*)$"
0-0;0-0;0-0;0-0
0-7;0-7;0-7;0-7
"^(?:a*)"
0-0;0-0;0-0;0-0
0-7;0-7;0-7;0-7
"(?:a*)$"
0-0;0-0;0-0;0-0
0-7;0-7;0-7;0-7
strings
""
""
regexps
"a*"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:a*)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:a*)"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"(?:a*)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
strings
""
""
regexps
"a*"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:a*)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:a*)"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"(?:a*)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
strings
""
"xabcdx"
regexps
"ab|cd"
-;-;-;-
-;1-3;-;1-3
"^(?:ab|cd)$"
-;-;-;-
-;-;-;-
"^(?:ab|cd)"
-;-;-;-
-;-;-;-
"(?:ab|cd)$"
-;-;-;-
-;-;-;-
strings
""
"cab"
regexps
"a"
-;-;-;-
-;1-2;-;1-2
"^(?:a)$"
-;-;-;-
-;-;-;-
"^(?:a)"
-;-;-;-
-;-;-;-
"(?:a)$"
-;-;-;-
-;-;-;-
strings
""
"cab"
regexps
"a*b"
-;-;-;-
-;1-3;-;1-3
"^(?:a*b)$"
-;-;-;-
-;-;-;-
"^(?:a*b)"
-;-;-;-
-;-;-;-
"(?:a*b)$"
-;-;-;-
-;1-3;-;1-3
strings
""
"x"
regexps
"((((((((((((((((((((x))))))))))))))))))))"
-;-;-;-
0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1;0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1;0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1;0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1
"^(?:((((((((((((((((((((x)))))))))))))))))))))$"
-;-;-;-
0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1;0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1;0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1;0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1
"^(?:((((((((((((((((((((x)))))))))))))))))))))"
-;-;-;-
0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1;0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1;0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1;0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1
"(?:((((((((((((((((((((x)))))))))))))))))))))$"
-;-;-;-
0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1;0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1;0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1;0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1 0-1
strings
""
"xxxabcdxxx"
regexps
"[abcd]"
-;-;-;-
-;3-4;-;3-4
"^(?:[abcd])$"
-;-;-;-
-;-;-;-
"^(?:[abcd])"
-;-;-;-
-;-;-;-
"(?:[abcd])$"
-;-;-;-
-;-;-;-
strings
""
"xxxabcdxxx"
regexps
"[^x]"
-;-;-;-
-;3-4;-;3-4
"^(?:[^x])$"
-;-;-;-
-;-;-;-
"^(?:[^x])"
-;-;-;-
-;-;-;-
"(?:[^x])$"
-;-;-;-
-;-;-;-
strings
""
"xxxabcdxxx"
regexps
"[abcd]+"
-;-;-;-
-;3-7;-;3-7
"^(?:[abcd]+)$"
-;-;-;-
-;-;-;-
"^(?:[abcd]+)"
-;-;-;-
-;-;-;-
"(?:[abcd]+)$"
-;-;-;-
-;-;-;-
strings
""
"xxxabcdxxx"
regexps
"[^x]+"
-;-;-;-
-;3-7;-;3-7
"^(?:[^x]+)$"
-;-;-;-
-;-;-;-
"^(?:[^x]+)"
-;-;-;-
-;-;-;-
"(?:[^x]+)$"
-;-;-;-
-;-;-;-
strings
""
"fo"
regexps
"(fo|foo)"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
"^(?:(fo|foo))$"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
"^(?:(fo|foo))"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
"(?:(fo|foo))$"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
strings
""
"foo"
regexps
"(foo|fo)"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:(foo|fo))$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:(foo|fo))"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"(?:(foo|fo))$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
strings
""
"aA"
regexps
"aa"
-;-;-;-
-;-;-;-
"^(?:aa)$"
-;-;-;-
-;-;-;-
"^(?:aa)"
-;-;-;-
-;-;-;-
"(?:aa)$"
-;-;-;-
-;-;-;-
strings
""
"Aa"
regexps
"a"
-;-;-;-
-;1-2;-;1-2
"^(?:a)$"
-;-;-;-
-;-;-;-
"^(?:a)"
-;-;-;-
-;-;-;-
"(?:a)$"
-;-;-;-
-;1-2;-;1-2
strings
""
"A"
regexps
"a"
-;-;-;-
-;-;-;-
"^(?:a)$"
-;-;-;-
-;-;-;-
"^(?:a)"
-;-;-;-
-;-;-;-
"(?:a)$"
-;-;-;-
-;-;-;-
strings
""
"abc"
regexps
"ABC"
-;-;-;-
-;-;-;-
"^(?:ABC)$"
-;-;-;-
-;-;-;-
"^(?:ABC)"
-;-;-;-
-;-;-;-
"(?:ABC)$"
-;-;-;-
-;-;-;-
strings
""
"XABCY"
regexps
"abc"
-;-;-;-
-;-;-;-
"^(?:abc)$"
-;-;-;-
-;-;-;-
"^(?:abc)"
-;-;-;-
-;-;-;-
"(?:abc)$"
-;-;-;-
-;-;-;-
strings
""
"xabcy"
regexps
"ABC"
-;-;-;-
-;-;-;-
"^(?:ABC)$"
-;-;-;-
-;-;-;-
"^(?:ABC)"
-;-;-;-
-;-;-;-
"(?:ABC)$"
-;-;-;-
-;-;-;-
strings
""
"foo"
regexps
"foo|bar|[A-Z]"
-;-;-;-
0-3;0-3;0-3;0-3
"^(?:foo|bar|[A-Z])$"
-;-;-;-
0-3;0-3;0-3;0-3
"^(?:foo|bar|[A-Z])"
-;-;-;-
0-3;0-3;0-3;0-3
"(?:foo|bar|[A-Z])$"
-;-;-;-
0-3;0-3;0-3;0-3
strings
""
"foo"
regexps
"^(foo|bar|[A-Z])"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:^(foo|bar|[A-Z]))$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:^(foo|bar|[A-Z]))"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"(?:^(foo|bar|[A-Z]))$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
strings
""
"foo\n"
regexps
"(foo|bar|[A-Z])$"
-;-;-;-
-;-;-;-
"^(?:(foo|bar|[A-Z])$)$"
-;-;-;-
-;-;-;-
"^(?:(foo|bar|[A-Z])$)"
-;-;-;-
-;-;-;-
"(?:(foo|bar|[A-Z])$)$"
-;-;-;-
-;-;-;-
strings
""
"foo"
regexps
"(foo|bar|[A-Z])$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:(foo|bar|[A-Z])$)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:(foo|bar|[A-Z])$)"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"(?:(foo|bar|[A-Z])$)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
strings
""
"foo\n"
regexps
"^(foo|bar|[A-Z])$"
-;-;-;-
-;-;-;-
"^(?:^(foo|bar|[A-Z])$)$"
-;-;-;-
-;-;-;-
"^(?:^(foo|bar|[A-Z])$)"
-;-;-;-
-;-;-;-
"(?:^(foo|bar|[A-Z])$)$"
-;-;-;-
-;-;-;-
strings
""
"foo"
regexps
"^(foo|bar|[A-Z])$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:^(foo|bar|[A-Z])$)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:^(foo|bar|[A-Z])$)"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"(?:^(foo|bar|[A-Z])$)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
strings
""
"bar"
regexps
"^(foo|bar|[A-Z])$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:^(foo|bar|[A-Z])$)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:^(foo|bar|[A-Z])$)"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"(?:^(foo|bar|[A-Z])$)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
strings
""
"X"
regexps
"^(foo|bar|[A-Z])$"
-;-;-;-
0-1 0-1;0-1 0-1;0-1 0-1;0-1 0-1
"^(?:^(foo|bar|[A-Z])$)$"
-;-;-;-
0-1 0-1;0-1 0-1;0-1 0-1;0-1 0-1
"^(?:^(foo|bar|[A-Z])$)"
-;-;-;-
0-1 0-1;0-1 0-1;0-1 0-1;0-1 0-1
"(?:^(foo|bar|[A-Z])$)$"
-;-;-;-
0-1 0-1;0-1 0-1;0-1 0-1;0-1 0-1
strings
""
"XY"
regexps
"^(foo|bar|[A-Z])$"
-;-;-;-
-;-;-;-
"^(?:^(foo|bar|[A-Z])$)$"
-;-;-;-
-;-;-;-
"^(?:^(foo|bar|[A-Z])$)"
-;-;-;-
-;-;-;-
"(?:^(foo|bar|[A-Z])$)$"
-;-;-;-
-;-;-;-
strings
""
"fo"
regexps
"^(fo|foo)$"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
"^(?:^(fo|foo)$)$"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
"^(?:^(fo|foo)$)"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
"(?:^(fo|foo)$)$"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
strings
""
"foo"
regexps
"^(fo|foo)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:^(fo|foo)$)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:^(fo|foo)$)"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"(?:^(fo|foo)$)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
strings
""
"fo"
regexps
"^^(fo|foo)$"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
"^(?:^^(fo|foo)$)$"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
"^(?:^^(fo|foo)$)"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
"(?:^^(fo|foo)$)$"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
strings
""
"foo"
regexps
"^^(fo|foo)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:^^(fo|foo)$)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:^^(fo|foo)$)"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"(?:^^(fo|foo)$)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
strings
""
""
regexps
"^$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^$)"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"(?:^$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
strings
""
"x"
regexps
"^$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^$)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^$)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:^$)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
""
regexps
"^^$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^^$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^^$)"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"(?:^^$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
strings
""
""
regexps
"^$$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^$$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^$$)"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"(?:^$$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
strings
""
"x"
regexps
"^^$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^^$)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^^$)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:^^$)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
"x"
regexps
"^$$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^$$)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^$$)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:^$$)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
""
regexps
"^^$$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^^$$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^^$$)"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"(?:^^$$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
strings
""
"x"
regexps
"^^$$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^^$$)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^^$$)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:^^$$)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
""
regexps
"^^^^^^^^$$$$$$$$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^^^^^^^^$$$$$$$$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^^^^^^^^$$$$$$$$)"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"(?:^^^^^^^^$$$$$$$$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
strings
""
"x"
regexps
"^"
0-0;0-0;0-0;0-0
-;0-0;-;0-0
"^(?:^)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^)"
0-0;0-0;0-0;0-0
-;0-0;-;0-0
"(?:^)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
"x"
regexps
"$"
0-0;0-0;0-0;0-0
-;1-1;-;1-1
"^(?:$)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:$)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:$)$"
0-0;0-0;0-0;0-0
-;1-1;-;1-1
strings
""
"nofoo foo that"
regexps
"\\bfoo\\b"
-;-;-;-
-;6-9;-;6-9
"^(?:\\bfoo\\b)$"
-;-;-;-
-;-;-;-
"^(?:\\bfoo\\b)"
-;-;-;-
-;-;-;-
"(?:\\bfoo\\b)$"
-;-;-;-
-;-;-;-
strings
""
"faoa x"
regexps
"a\\b"
-;-;-;-
-;3-4;-;3-4
"^(?:a\\b)$"
-;-;-;-
-;-;-;-
"^(?:a\\b)"
-;-;-;-
-;-;-;-
"(?:a\\b)$"
-;-;-;-
-;-;-;-
strings
""
"bar x"
regexps
"\\bbar"
-;-;-;-
-;0-3;-;0-3
"^(?:\\bbar)$"
-;-;-;-
-;-;-;-
"^(?:\\bbar)"
-;-;-;-
-;0-3;-;0-3
"(?:\\bbar)$"
-;-;-;-
-;-;-;-
strings
""
"foo\nbar x"
regexps
"\\bbar"
-;-;-;-
-;4-7;-;4-7
"^(?:\\bbar)$"
-;-;-;-
-;-;-;-
"^(?:\\bbar)"
-;-;-;-
-;-;-;-
"(?:\\bbar)$"
-;-;-;-
-;-;-;-
strings
""
"foobar"
regexps
"bar\\b"
-;-;-;-
-;3-6;-;3-6
"^(?:bar\\b)$"
-;-;-;-
-;-;-;-
"^(?:bar\\b)"
-;-;-;-
-;-;-;-
"(?:bar\\b)$"
-;-;-;-
-;3-6;-;3-6
strings
""
"foobar\nxxx"
regexps
"bar\\b"
-;-;-;-
-;3-6;-;3-6
"^(?:bar\\b)$"
-;-;-;-
-;-;-;-
"^(?:bar\\b)"
-;-;-;-
-;-;-;-
"(?:bar\\b)$"
-;-;-;-
-;-;-;-
strings
""
"foo"
regexps
"(foo|bar|[A-Z])\\b"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:(foo|bar|[A-Z])\\b)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:(foo|bar|[A-Z])\\b)"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"(?:(foo|bar|[A-Z])\\b)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
strings
""
"foo\n"
regexps
"(foo|bar|[A-Z])\\b"
-;-;-;-
-;0-3 0-3;-;0-3 0-3
"^(?:(foo|bar|[A-Z])\\b)$"
-;-;-;-
-;-;-;-
"^(?:(foo|bar|[A-Z])\\b)"
-;-;-;-
-;0-3 0-3;-;0-3 0-3
"(?:(foo|bar|[A-Z])\\b)$"
-;-;-;-
-;-;-;-
strings
""
""
regexps
"\\b"
-;-;-;-
-;-;-;-
"^(?:\\b)$"
-;-;-;-
-;-;-;-
"^(?:\\b)"
-;-;-;-
-;-;-;-
"(?:\\b)$"
-;-;-;-
-;-;-;-
strings
""
"x"
regexps
"\\b"
-;-;-;-
-;0-0;-;0-0
"^(?:\\b)$"
-;-;-;-
-;-;-;-
"^(?:\\b)"
-;-;-;-
-;0-0;-;0-0
"(?:\\b)$"
-;-;-;-
-;1-1;-;1-1
strings
""
"foo"
regexps
"\\b(foo|bar|[A-Z])"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:\\b(foo|bar|[A-Z]))$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:\\b(foo|bar|[A-Z]))"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"(?:\\b(foo|bar|[A-Z]))$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
strings
""
"X"
regexps
"\\b(foo|bar|[A-Z])\\b"
-;-;-;-
0-1 0-1;0-1 0-1;0-1 0-1;0-1 0-1
"^(?:\\b(foo|bar|[A-Z])\\b)$"
-;-;-;-
0-1 0-1;0-1 0-1;0-1 0-1;0-1 0-1
"^(?:\\b(foo|bar|[A-Z])\\b)"
-;-;-;-
0-1 0-1;0-1 0-1;0-1 0-1;0-1 0-1
"(?:\\b(foo|bar|[A-Z])\\b)$"
-;-;-;-
0-1 0-1;0-1 0-1;0-1 0-1;0-1 0-1
strings
""
"XY"
regexps
"\\b(foo|bar|[A-Z])\\b"
-;-;-;-
-;-;-;-
"^(?:\\b(foo|bar|[A-Z])\\b)$"
-;-;-;-
-;-;-;-
"^(?:\\b(foo|bar|[A-Z])\\b)"
-;-;-;-
-;-;-;-
"(?:\\b(foo|bar|[A-Z])\\b)$"
-;-;-;-
-;-;-;-
strings
""
"bar"
regexps
"\\b(foo|bar|[A-Z])\\b"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:\\b(foo|bar|[A-Z])\\b)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:\\b(foo|bar|[A-Z])\\b)"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"(?:\\b(foo|bar|[A-Z])\\b)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
strings
""
"foo"
regexps
"\\b(foo|bar|[A-Z])\\b"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:\\b(foo|bar|[A-Z])\\b)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:\\b(foo|bar|[A-Z])\\b)"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"(?:\\b(foo|bar|[A-Z])\\b)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
strings
""
"foo\n"
regexps
"\\b(foo|bar|[A-Z])\\b"
-;-;-;-
-;0-3 0-3;-;0-3 0-3
"^(?:\\b(foo|bar|[A-Z])\\b)$"
-;-;-;-
-;-;-;-
"^(?:\\b(foo|bar|[A-Z])\\b)"
-;-;-;-
-;0-3 0-3;-;0-3 0-3
"(?:\\b(foo|bar|[A-Z])\\b)$"
-;-;-;-
-;-;-;-
strings
""
"ffoo bbar N x"
regexps
"\\b(foo|bar|[A-Z])\\b"
-;-;-;-
-;10-11 10-11;-;10-11 10-11
"^(?:\\b(foo|bar|[A-Z])\\b)$"
-;-;-;-
-;-;-;-
"^(?:\\b(foo|bar|[A-Z])\\b)"
-;-;-;-
-;-;-;-
"(?:\\b(foo|bar|[A-Z])\\b)$"
-;-;-;-
-;-;-;-
strings
""
"fo"
regexps
"\\b(fo|foo)\\b"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
"^(?:\\b(fo|foo)\\b)$"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
"^(?:\\b(fo|foo)\\b)"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
"(?:\\b(fo|foo)\\b)$"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
strings
""
"foo"
regexps
"\\b(fo|foo)\\b"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:\\b(fo|foo)\\b)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:\\b(fo|foo)\\b)"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"(?:\\b(fo|foo)\\b)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
strings
""
""
regexps
"\\b\\b"
-;-;-;-
-;-;-;-
"^(?:\\b\\b)$"
-;-;-;-
-;-;-;-
"^(?:\\b\\b)"
-;-;-;-
-;-;-;-
"(?:\\b\\b)$"
-;-;-;-
-;-;-;-
strings
""
"x"
regexps
"\\b\\b"
-;-;-;-
-;0-0;-;0-0
"^(?:\\b\\b)$"
-;-;-;-
-;-;-;-
"^(?:\\b\\b)"
-;-;-;-
-;0-0;-;0-0
"(?:\\b\\b)$"
-;-;-;-
-;1-1;-;1-1
strings
""
""
regexps
"\\b$"
-;-;-;-
-;-;-;-
"^(?:\\b$)$"
-;-;-;-
-;-;-;-
"^(?:\\b$)"
-;-;-;-
-;-;-;-
"(?:\\b$)$"
-;-;-;-
-;-;-;-
strings
""
"x"
regexps
"\\b$"
-;-;-;-
-;1-1;-;1-1
"^(?:\\b$)$"
-;-;-;-
-;-;-;-
"^(?:\\b$)"
-;-;-;-
-;-;-;-
"(?:\\b$)$"
-;-;-;-
-;1-1;-;1-1
strings
""
"y x"
regexps
"\\b$"
-;-;-;-
-;3-3;-;3-3
"^(?:\\b$)$"
-;-;-;-
-;-;-;-
"^(?:\\b$)"
-;-;-;-
-;-;-;-
"(?:\\b$)$"
-;-;-;-
-;3-3;-;3-3
strings
""
"x"
regexps
"\\b.$"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:\\b.$)$"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:\\b.$)"
-;-;-;-
0-1;0-1;0-1;0-1
"(?:\\b.$)$"
-;-;-;-
0-1;0-1;0-1;0-1
strings
""
"fo"
regexps
"^\\b(fo|foo)\\b"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
"^(?:^\\b(fo|foo)\\b)$"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
"^(?:^\\b(fo|foo)\\b)"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
"(?:^\\b(fo|foo)\\b)$"
-;-;-;-
0-2 0-2;0-2 0-2;0-2 0-2;0-2 0-2
strings
""
"foo"
regexps
"^\\b(fo|foo)\\b"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:^\\b(fo|foo)\\b)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:^\\b(fo|foo)\\b)"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"(?:^\\b(fo|foo)\\b)$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
strings
""
""
regexps
"^\\b"
-;-;-;-
-;-;-;-
"^(?:^\\b)$"
-;-;-;-
-;-;-;-
"^(?:^\\b)"
-;-;-;-
-;-;-;-
"(?:^\\b)$"
-;-;-;-
-;-;-;-
strings
""
"x"
regexps
"^\\b"
-;-;-;-
-;0-0;-;0-0
"^(?:^\\b)$"
-;-;-;-
-;-;-;-
"^(?:^\\b)"
-;-;-;-
-;0-0;-;0-0
"(?:^\\b)$"
-;-;-;-
-;-;-;-
strings
""
""
regexps
"^\\b\\b"
-;-;-;-
-;-;-;-
"^(?:^\\b\\b)$"
-;-;-;-
-;-;-;-
"^(?:^\\b\\b)"
-;-;-;-
-;-;-;-
"(?:^\\b\\b)$"
-;-;-;-
-;-;-;-
strings
""
"x"
regexps
"^\\b\\b"
-;-;-;-
-;0-0;-;0-0
"^(?:^\\b\\b)$"
-;-;-;-
-;-;-;-
"^(?:^\\b\\b)"
-;-;-;-
-;0-0;-;0-0
"(?:^\\b\\b)$"
-;-;-;-
-;-;-;-
strings
""
""
regexps
"^\\b$"
-;-;-;-
-;-;-;-
"^(?:^\\b$)$"
-;-;-;-
-;-;-;-
"^(?:^\\b$)"
-;-;-;-
-;-;-;-
"(?:^\\b$)$"
-;-;-;-
-;-;-;-
strings
""
"x"
regexps
"^\\b$"
-;-;-;-
-;-;-;-
"^(?:^\\b$)$"
-;-;-;-
-;-;-;-
"^(?:^\\b$)"
-;-;-;-
-;-;-;-
"(?:^\\b$)$"
-;-;-;-
-;-;-;-
strings
""
"x"
regexps
"^\\b.$"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:^\\b.$)$"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:^\\b.$)"
-;-;-;-
0-1;0-1;0-1;0-1
"(?:^\\b.$)$"
-;-;-;-
0-1;0-1;0-1;0-1
strings
""
"x"
regexps
"^\\b.\\b$"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:^\\b.\\b$)$"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:^\\b.\\b$)"
-;-;-;-
0-1;0-1;0-1;0-1
"(?:^\\b.\\b$)$"
-;-;-;-
0-1;0-1;0-1;0-1
strings
""
""
regexps
"^^^^^^^^\\b$$$$$$$"
-;-;-;-
-;-;-;-
"^(?:^^^^^^^^\\b$$$$$$$)$"
-;-;-;-
-;-;-;-
"^(?:^^^^^^^^\\b$$$$$$$)"
-;-;-;-
-;-;-;-
"(?:^^^^^^^^\\b$$$$$$$)$"
-;-;-;-
-;-;-;-
strings
""
"x"
regexps
"^^^^^^^^\\b.$$$$$$"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:^^^^^^^^\\b.$$$$$$)$"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:^^^^^^^^\\b.$$$$$$)"
-;-;-;-
0-1;0-1;0-1;0-1
"(?:^^^^^^^^\\b.$$$$$$)$"
-;-;-;-
0-1;0-1;0-1;0-1
strings
""
"x"
regexps
"^^^^^^^^\\b$$$$$$$"
-;-;-;-
-;-;-;-
"^(?:^^^^^^^^\\b$$$$$$$)$"
-;-;-;-
-;-;-;-
"^(?:^^^^^^^^\\b$$$$$$$)"
-;-;-;-
-;-;-;-
"(?:^^^^^^^^\\b$$$$$$$)$"
-;-;-;-
-;-;-;-
strings
""
"n foo xfoox that"
regexps
"\\Bfoo\\B"
-;-;-;-
-;7-10;-;7-10
"^(?:\\Bfoo\\B)$"
-;-;-;-
-;-;-;-
"^(?:\\Bfoo\\B)"
-;-;-;-
-;-;-;-
"(?:\\Bfoo\\B)$"
-;-;-;-
-;-;-;-
strings
""
"faoa x"
regexps
"a\\B"
-;-;-;-
-;1-2;-;1-2
"^(?:a\\B)$"
-;-;-;-
-;-;-;-
"^(?:a\\B)"
-;-;-;-
-;-;-;-
"(?:a\\B)$"
-;-;-;-
-;-;-;-
strings
""
"bar x"
regexps
"\\Bbar"
-;-;-;-
-;-;-;-
"^(?:\\Bbar)$"
-;-;-;-
-;-;-;-
"^(?:\\Bbar)"
-;-;-;-
-;-;-;-
"(?:\\Bbar)$"
-;-;-;-
-;-;-;-
strings
""
"foo\nbar x"
regexps
"\\Bbar"
-;-;-;-
-;-;-;-
"^(?:\\Bbar)$"
-;-;-;-
-;-;-;-
"^(?:\\Bbar)"
-;-;-;-
-;-;-;-
"(?:\\Bbar)$"
-;-;-;-
-;-;-;-
strings
""
"foobar"
regexps
"bar\\B"
-;-;-;-
-;-;-;-
"^(?:bar\\B)$"
-;-;-;-
-;-;-;-
"^(?:bar\\B)"
-;-;-;-
-;-;-;-
"(?:bar\\B)$"
-;-;-;-
-;-;-;-
strings
""
"foobar\nxxx"
regexps
"bar\\B"
-;-;-;-
-;-;-;-
"^(?:bar\\B)$"
-;-;-;-
-;-;-;-
"^(?:bar\\B)"
-;-;-;-
-;-;-;-
"(?:bar\\B)$"
-;-;-;-
-;-;-;-
strings
""
"foox"
regexps
"(foo|bar|[A-Z])\\B"
-;-;-;-
-;0-3 0-3;-;0-3 0-3
"^(?:(foo|bar|[A-Z])\\B)$"
-;-;-;-
-;-;-;-
"^(?:(foo|bar|[A-Z])\\B)"
-;-;-;-
-;0-3 0-3;-;0-3 0-3
"(?:(foo|bar|[A-Z])\\B)$"
-;-;-;-
-;-;-;-
strings
""
"foo\n"
regexps
"(foo|bar|[A-Z])\\B"
-;-;-;-
-;-;-;-
"^(?:(foo|bar|[A-Z])\\B)$"
-;-;-;-
-;-;-;-
"^(?:(foo|bar|[A-Z])\\B)"
-;-;-;-
-;-;-;-
"(?:(foo|bar|[A-Z])\\B)$"
-;-;-;-
-;-;-;-
strings
""
""
regexps
"\\B"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:\\B)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:\\B)"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"(?:\\B)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
strings
""
"x"
regexps
"\\B"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:\\B)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:\\B)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:\\B)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
"foo"
regexps
"\\B(foo|bar|[A-Z])"
-;-;-;-
-;-;-;-
"^(?:\\B(foo|bar|[A-Z]))$"
-;-;-;-
-;-;-;-
"^(?:\\B(foo|bar|[A-Z]))"
-;-;-;-
-;-;-;-
"(?:\\B(foo|bar|[A-Z]))$"
-;-;-;-
-;-;-;-
strings
""
"xXy"
regexps
"\\B(foo|bar|[A-Z])\\B"
-;-;-;-
-;1-2 1-2;-;1-2 1-2
"^(?:\\B(foo|bar|[A-Z])\\B)$"
-;-;-;-
-;-;-;-
"^(?:\\B(foo|bar|[A-Z])\\B)"
-;-;-;-
-;-;-;-
"(?:\\B(foo|bar|[A-Z])\\B)$"
-;-;-;-
-;-;-;-
strings
""
"XY"
regexps
"\\B(foo|bar|[A-Z])\\B"
-;-;-;-
-;-;-;-
"^(?:\\B(foo|bar|[A-Z])\\B)$"
-;-;-;-
-;-;-;-
"^(?:\\B(foo|bar|[A-Z])\\B)"
-;-;-;-
-;-;-;-
"(?:\\B(foo|bar|[A-Z])\\B)$"
-;-;-;-
-;-;-;-
strings
""
"XYZ"
regexps
"\\B(foo|bar|[A-Z])\\B"
-;-;-;-
-;1-2 1-2;-;1-2 1-2
"^(?:\\B(foo|bar|[A-Z])\\B)$"
-;-;-;-
-;-;-;-
"^(?:\\B(foo|bar|[A-Z])\\B)"
-;-;-;-
-;-;-;-
"(?:\\B(foo|bar|[A-Z])\\B)$"
-;-;-;-
-;-;-;-
strings
""
"abara"
regexps
"\\B(foo|bar|[A-Z])\\B"
-;-;-;-
-;1-4 1-4;-;1-4 1-4
"^(?:\\B(foo|bar|[A-Z])\\B)$"
-;-;-;-
-;-;-;-
"^(?:\\B(foo|bar|[A-Z])\\B)"
-;-;-;-
-;-;-;-
"(?:\\B(foo|bar|[A-Z])\\B)$"
-;-;-;-
-;-;-;-
strings
""
"xfoo_"
regexps
"\\B(foo|bar|[A-Z])\\B"
-;-;-;-
-;1-4 1-4;-;1-4 1-4
"^(?:\\B(foo|bar|[A-Z])\\B)$"
-;-;-;-
-;-;-;-
"^(?:\\B(foo|bar|[A-Z])\\B)"
-;-;-;-
-;-;-;-
"(?:\\B(foo|bar|[A-Z])\\B)$"
-;-;-;-
-;-;-;-
strings
""
"xfoo\n"
regexps
"\\B(foo|bar|[A-Z])\\B"
-;-;-;-
-;-;-;-
"^(?:\\B(foo|bar|[A-Z])\\B)$"
-;-;-;-
-;-;-;-
"^(?:\\B(foo|bar|[A-Z])\\B)"
-;-;-;-
-;-;-;-
"(?:\\B(foo|bar|[A-Z])\\B)$"
-;-;-;-
-;-;-;-
strings
""
"foo bar vNx"
regexps
"\\B(foo|bar|[A-Z])\\B"
-;-;-;-
-;9-10 9-10;-;9-10 9-10
"^(?:\\B(foo|bar|[A-Z])\\B)$"
-;-;-;-
-;-;-;-
"^(?:\\B(foo|bar|[A-Z])\\B)"
-;-;-;-
-;-;-;-
"(?:\\B(foo|bar|[A-Z])\\B)$"
-;-;-;-
-;-;-;-
strings
""
"xfoo"
regexps
"\\B(fo|foo)\\B"
-;-;-;-
-;1-3 1-3;-;1-3 1-3
"^(?:\\B(fo|foo)\\B)$"
-;-;-;-
-;-;-;-
"^(?:\\B(fo|foo)\\B)"
-;-;-;-
-;-;-;-
"(?:\\B(fo|foo)\\B)$"
-;-;-;-
-;-;-;-
strings
""
"xfooo"
regexps
"\\B(foo|fo)\\B"
-;-;-;-
-;1-4 1-4;-;1-4 1-4
"^(?:\\B(foo|fo)\\B)$"
-;-;-;-
-;-;-;-
"^(?:\\B(foo|fo)\\B)"
-;-;-;-
-;-;-;-
"(?:\\B(foo|fo)\\B)$"
-;-;-;-
-;-;-;-
strings
""
""
regexps
"\\B\\B"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:\\B\\B)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:\\B\\B)"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"(?:\\B\\B)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
strings
""
"x"
regexps
"\\B\\B"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:\\B\\B)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:\\B\\B)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:\\B\\B)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
""
regexps
"\\B$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:\\B$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:\\B$)"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"(?:\\B$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
strings
""
"x"
regexps
"\\B$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:\\B$)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:\\B$)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:\\B$)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
"y x"
regexps
"\\B$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:\\B$)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:\\B$)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:\\B$)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
"x"
regexps
"\\B.$"
-;-;-;-
-;-;-;-
"^(?:\\B.$)$"
-;-;-;-
-;-;-;-
"^(?:\\B.$)"
-;-;-;-
-;-;-;-
"(?:\\B.$)$"
-;-;-;-
-;-;-;-
strings
""
"fo"
regexps
"^\\B(fo|foo)\\B"
-;-;-;-
-;-;-;-
"^(?:^\\B(fo|foo)\\B)$"
-;-;-;-
-;-;-;-
"^(?:^\\B(fo|foo)\\B)"
-;-;-;-
-;-;-;-
"(?:^\\B(fo|foo)\\B)$"
-;-;-;-
-;-;-;-
strings
""
"foo"
regexps
"^\\B(fo|foo)\\B"
-;-;-;-
-;-;-;-
"^(?:^\\B(fo|foo)\\B)$"
-;-;-;-
-;-;-;-
"^(?:^\\B(fo|foo)\\B)"
-;-;-;-
-;-;-;-
"(?:^\\B(fo|foo)\\B)$"
-;-;-;-
-;-;-;-
strings
""
""
regexps
"^\\B"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^\\B)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^\\B)"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"(?:^\\B)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
strings
""
"x"
regexps
"^\\B"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^\\B)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^\\B)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:^\\B)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
""
regexps
"^\\B\\B"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^\\B\\B)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^\\B\\B)"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"(?:^\\B\\B)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
strings
""
"x"
regexps
"^\\B\\B"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^\\B\\B)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^\\B\\B)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:^\\B\\B)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
""
regexps
"^\\B$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^\\B$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^\\B$)"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"(?:^\\B$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
strings
""
"x"
regexps
"^\\B$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^\\B$)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^\\B$)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:^\\B$)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
"x"
regexps
"^\\B.$"
-;-;-;-
-;-;-;-
"^(?:^\\B.$)$"
-;-;-;-
-;-;-;-
"^(?:^\\B.$)"
-;-;-;-
-;-;-;-
"(?:^\\B.$)$"
-;-;-;-
-;-;-;-
strings
""
"x"
regexps
"^\\B.\\B$"
-;-;-;-
-;-;-;-
"^(?:^\\B.\\B$)$"
-;-;-;-
-;-;-;-
"^(?:^\\B.\\B$)"
-;-;-;-
-;-;-;-
"(?:^\\B.\\B$)$"
-;-;-;-
-;-;-;-
strings
""
""
regexps
"^^^^^^^^\\B$$$$$$$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^^^^^^^^\\B$$$$$$$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^^^^^^^^\\B$$$$$$$)"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"(?:^^^^^^^^\\B$$$$$$$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
strings
""
"x"
regexps
"^^^^^^^^\\B.$$$$$$"
-;-;-;-
-;-;-;-
"^(?:^^^^^^^^\\B.$$$$$$)$"
-;-;-;-
-;-;-;-
"^(?:^^^^^^^^\\B.$$$$$$)"
-;-;-;-
-;-;-;-
"(?:^^^^^^^^\\B.$$$$$$)$"
-;-;-;-
-;-;-;-
strings
""
"x"
regexps
"^^^^^^^^\\B$$$$$$$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^^^^^^^^\\B$$$$$$$)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^^^^^^^^\\B$$$$$$$)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:^^^^^^^^\\B$$$$$$$)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
"x"
regexps
"\\bx\\b"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:\\bx\\b)$"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:\\bx\\b)"
-;-;-;-
0-1;0-1;0-1;0-1
"(?:\\bx\\b)$"
-;-;-;-
0-1;0-1;0-1;0-1
strings
""
"x>"
regexps
"\\bx\\b"
-;-;-;-
-;0-1;-;0-1
"^(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
"^(?:\\bx\\b)"
-;-;-;-
-;0-1;-;0-1
"(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
strings
""
"<x"
regexps
"\\bx\\b"
-;-;-;-
-;1-2;-;1-2
"^(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
"^(?:\\bx\\b)"
-;-;-;-
-;-;-;-
"(?:\\bx\\b)$"
-;-;-;-
-;1-2;-;1-2
strings
""
"<x>"
regexps
"\\bx\\b"
-;-;-;-
-;1-2;-;1-2
"^(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
"^(?:\\bx\\b)"
-;-;-;-
-;-;-;-
"(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
strings
""
"ax"
regexps
"\\bx\\b"
-;-;-;-
-;-;-;-
"^(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
"^(?:\\bx\\b)"
-;-;-;-
-;-;-;-
"(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
strings
""
"xb"
regexps
"\\bx\\b"
-;-;-;-
-;-;-;-
"^(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
"^(?:\\bx\\b)"
-;-;-;-
-;-;-;-
"(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
strings
""
"axb"
regexps
"\\bx\\b"
-;-;-;-
-;-;-;-
"^(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
"^(?:\\bx\\b)"
-;-;-;-
-;-;-;-
"(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
strings
""
"x"
regexps
"\\bx\\b"
-;-;-;-
-;2-3;-;2-3
"^(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
"^(?:\\bx\\b)"
-;-;-;-
-;-;-;-
"(?:\\bx\\b)$"
-;-;-;-
-;2-3;-;2-3
strings
""
"x"
regexps
"\\bx\\b"
-;-;-;-
-;0-1;-;0-1
"^(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
"^(?:\\bx\\b)"
-;-;-;-
-;0-1;-;0-1
"(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
strings
""
"x"
regexps
"\\bx\\b"
-;-;-;-
-;2-3;-;2-3
"^(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
"^(?:\\bx\\b)"
-;-;-;-
-;-;-;-
"(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
strings
""
"axb"
regexps
"\\bx\\b"
-;-;-;-
-;-;-;-
"^(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
"^(?:\\bx\\b)"
-;-;-;-
-;-;-;-
"(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
strings
""
"x"
regexps
"\\bx\\b"
-;-;-;-
-;2-3;-;2-3
"^(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
"^(?:\\bx\\b)"
-;-;-;-
-;-;-;-
"(?:\\bx\\b)$"
-;-;-;-
-;-;-;-
strings
""
"axb"
regexps
"\\Bx\\B"
-;-;-;-
-;1-2;-;1-2
"^(?:\\Bx\\B)$"
-;-;-;-
-;-;-;-
"^(?:\\Bx\\B)"
-;-;-;-
-;-;-;-
"(?:\\Bx\\B)$"
-;-;-;-
-;-;-;-
strings
""
"x"
regexps
"\\Bx\\B"
-;-;-;-
-;-;-;-
"^(?:\\Bx\\B)$"
-;-;-;-
-;-;-;-
"^(?:\\Bx\\B)"
-;-;-;-
-;-;-;-
"(?:\\Bx\\B)$"
-;-;-;-
-;-;-;-
strings
""
""
regexps
"^$^$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^$^$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^$^$)"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"(?:^$^$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
strings
""
""
regexps
"^$^"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^$^)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:^$^)"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"(?:^$^)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
strings
""
""
regexps
"$^$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:$^$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"^(?:$^$)"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
"(?:$^$)$"
0-0;0-0;0-0;0-0
0-0;0-0;0-0;0-0
strings
""
"x"
regexps
"^$^$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^$^$)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^$^$)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:^$^$)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
"x"
regexps
"^$^"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^$^)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^$^)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:^$^)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
"x"
regexps
"$^$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:$^$)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:$^$)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:$^$)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
"x\ny"
regexps
"^$^$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^$^$)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^$^$)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:^$^$)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
"x\ny"
regexps
"^$^"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^$^)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^$^)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:^$^)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
"x\ny"
regexps
"$^$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:$^$)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:$^$)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:$^$)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
"x\n\ny"
regexps
"^$^$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^$^$)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^$^$)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:^$^$)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
"x\n\ny"
regexps
"^$^"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^$^)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^$^)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:^$^)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
"x\n\ny"
regexps
"$^$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:$^$)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:$^$)"
0-0;0-0;0-0;0-0
-;-;-;-
"(?:$^$)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
"foo$bar"
regexps
"^(foo\\$)$"
-;-;-;-
-;-;-;-
"^(?:^(foo\\$)$)$"
-;-;-;-
-;-;-;-
"^(?:^(foo\\$)$)"
-;-;-;-
-;-;-;-
"(?:^(foo\\$)$)$"
-;-;-;-
-;-;-;-
strings
""
"foo$bar"
regexps
"(foo\\$)"
-;-;-;-
-;0-4 0-4;-;0-4 0-4
"^(?:(foo\\$))$"
-;-;-;-
-;-;-;-
"^(?:(foo\\$))"
-;-;-;-
-;0-4 0-4;-;0-4 0-4
"(?:(foo\\$))$"
-;-;-;-
-;-;-;-
strings
""
"abc"
regexps
"^...$"
-;-;-;-
0-3;0-3;0-3;0-3
"^(?:^...$)$"
-;-;-;-
0-3;0-3;0-3;0-3
"^(?:^...$)"
-;-;-;-
0-3;0-3;0-3;0-3
"(?:^...$)$"
-;-;-;-
0-3;0-3;0-3;0-3
strings
""
""
regexps
"^$"
-;-;-;-
0-3;0-3;0-3;0-3
"^(?:^$)$"
-;-;-;-
0-3;0-3;0-3;0-3
"^(?:^$)"
-;-;-;-
0-3;0-3;0-3;0-3
"(?:^$)$"
-;-;-;-
0-3;0-3;0-3;0-3
strings
""
""
regexps
"^...$"
-;-;-;-
0-9;0-9;0-9;0-9
"^(?:^...$)$"
-;-;-;-
0-9;0-9;0-9;0-9
"^(?:^...$)"
-;-;-;-
0-9;0-9;0-9;0-9
"(?:^...$)$"
-;-;-;-
0-9;0-9;0-9;0-9
strings
""
".."
regexps
"^...$"
-;-;-;-
0-5;0-5;0-5;0-5
"^(?:^...$)$"
-;-;-;-
0-5;0-5;0-5;0-5
"^(?:^...$)"
-;-;-;-
0-5;0-5;0-5;0-5
"(?:^...$)$"
-;-;-;-
0-5;0-5;0-5;0-5
strings
""
""
regexps
"^\\C\\C\\C$"
-;-;-;-
0-3;0-3;0-3;0-3
"^(?:^\\C\\C\\C$)$"
-;-;-;-
0-3;0-3;0-3;0-3
"^(?:^\\C\\C\\C$)"
-;-;-;-
0-3;0-3;0-3;0-3
"(?:^\\C\\C\\C$)$"
-;-;-;-
0-3;0-3;0-3;0-3
strings
""
""
regexps
"^\\C$"
-;-;-;-
-;-;-;-
"^(?:^\\C$)$"
-;-;-;-
-;-;-;-
"^(?:^\\C$)"
-;-;-;-
-;-;-;-
"(?:^\\C$)$"
-;-;-;-
-;-;-;-
strings
""
""
regexps
"^\\C\\C\\C$"
-;-;-;-
-;-;-;-
"^(?:^\\C\\C\\C$)$"
-;-;-;-
-;-;-;-
"^(?:^\\C\\C\\C$)"
-;-;-;-
-;-;-;-
"(?:^\\C\\C\\C$)$"
-;-;-;-
-;-;-;-
strings
""
""
regexps
"^...$"
-;-;-;-
0-9;0-9;0-9;0-9
"^(?:^...$)$"
-;-;-;-
0-9;0-9;0-9;0-9
"^(?:^...$)"
-;-;-;-
0-9;0-9;0-9;0-9
"(?:^...$)$"
-;-;-;-
0-9;0-9;0-9;0-9
strings
""
""
regexps
"^.........$"
-;-;-;-
-;-;-;-
"^(?:^.........$)$"
-;-;-;-
-;-;-;-
"^(?:^.........$)"
-;-;-;-
-;-;-;-
"(?:^.........$)$"
-;-;-;-
-;-;-;-
strings
""
".."
regexps
"^...$"
-;-;-;-
0-5;0-5;0-5;0-5
"^(?:^...$)$"
-;-;-;-
0-5;0-5;0-5;0-5
"^(?:^...$)"
-;-;-;-
0-5;0-5;0-5;0-5
"(?:^...$)$"
-;-;-;-
0-5;0-5;0-5;0-5
strings
""
".."
regexps
"^.....$"
-;-;-;-
-;-;-;-
"^(?:^.....$)$"
-;-;-;-
-;-;-;-
"^(?:^.....$)"
-;-;-;-
-;-;-;-
"(?:^.....$)$"
-;-;-;-
-;-;-;-
strings
""
"xfooo"
regexps
"\\B(fo|foo)\\B"
-;-;-;-
-;1-3 1-3;-;1-4 1-4
"^(?:\\B(fo|foo)\\B)$"
-;-;-;-
-;-;-;-
"^(?:\\B(fo|foo)\\B)"
-;-;-;-
-;-;-;-
"(?:\\B(fo|foo)\\B)$"
-;-;-;-
-;-;-;-
strings
""
"foo"
regexps
"(fo|foo)"
-;-;-;-
0-3 0-3;0-2 0-2;0-3 0-3;0-3 0-3
"^(?:(fo|foo))$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
"^(?:(fo|foo))"
-;-;-;-
0-3 0-3;0-2 0-2;0-3 0-3;0-3 0-3
"(?:(fo|foo))$"
-;-;-;-
0-3 0-3;0-3 0-3;0-3 0-3;0-3 0-3
strings
""
"a"
regexps
"\\141"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:\\141)$"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:\\141)"
-;-;-;-
0-1;0-1;0-1;0-1
"(?:\\141)$"
-;-;-;-
0-1;0-1;0-1;0-1
strings
""
"0"
regexps
"\\060"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:\\060)$"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:\\060)"
-;-;-;-
0-1;0-1;0-1;0-1
"(?:\\060)$"
-;-;-;-
0-1;0-1;0-1;0-1
strings
""
"00"
regexps
"\\0600"
-;-;-;-
0-2;0-2;0-2;0-2
"^(?:\\0600)$"
-;-;-;-
0-2;0-2;0-2;0-2
"^(?:\\0600)"
-;-;-;-
0-2;0-2;0-2;0-2
"(?:\\0600)$"
-;-;-;-
0-2;0-2;0-2;0-2
strings
""
"08"
regexps
"\\608"
-;-;-;-
0-2;0-2;0-2;0-2
"^(?:\\608)$"
-;-;-;-
0-2;0-2;0-2;0-2
"^(?:\\608)"
-;-;-;-
0-2;0-2;0-2;0-2
"(?:\\608)$"
-;-;-;-
0-2;0-2;0-2;0-2
strings
""
""
regexps
"\\01"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:\\01)$"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:\\01)"
-;-;-;-
0-1;0-1;0-1;0-1
"(?:\\01)$"
-;-;-;-
0-1;0-1;0-1;0-1
strings
""
"8"
regexps
"\\018"
-;-;-;-
0-2;0-2;0-2;0-2
"^(?:\\018)$"
-;-;-;-
0-2;0-2;0-2;0-2
"^(?:\\018)"
-;-;-;-
0-2;0-2;0-2;0-2
"(?:\\018)$"
-;-;-;-
0-2;0-2;0-2;0-2
strings
""
"a"
regexps
"\\x{61}"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:\\x{61})$"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:\\x{61})"
-;-;-;-
0-1;0-1;0-1;0-1
"(?:\\x{61})$"
-;-;-;-
0-1;0-1;0-1;0-1
strings
""
"a"
regexps
"\\x61"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:\\x61)$"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:\\x61)"
-;-;-;-
0-1;0-1;0-1;0-1
"(?:\\x61)$"
-;-;-;-
0-1;0-1;0-1;0-1
strings
""
"a"
regexps
"\\x{00000061}"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:\\x{00000061})$"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:\\x{00000061})"
-;-;-;-
0-1;0-1;0-1;0-1
"(?:\\x{00000061})$"
-;-;-;-
0-1;0-1;0-1;0-1
strings
""
"ab"
regexps
"\\p{Greek}+"
-;-;-;-
-;1-5;-;1-5
"^(?:\\p{Greek}+)$"
-;-;-;-
-;-;-;-
"^(?:\\p{Greek}+)"
-;-;-;-
-;-;-;-
"(?:\\p{Greek}+)$"
-;-;-;-
-;-;-;-
strings
""
"ab"
regexps
"\\P{Greek}+"
-;-;-;-
-;0-1;-;0-1
"^(?:\\P{Greek}+)$"
-;-;-;-
-;-;-;-
"^(?:\\P{Greek}+)"
-;-;-;-
-;0-1;-;0-1
"(?:\\P{Greek}+)$"
-;-;-;-
-;5-6;-;5-6
strings
""
"ab"
regexps
"\\p{^Greek}+"
-;-;-;-
-;0-1;-;0-1
"^(?:\\p{^Greek}+)$"
-;-;-;-
-;-;-;-
"^(?:\\p{^Greek}+)"
-;-;-;-
-;0-1;-;0-1
"(?:\\p{^Greek}+)$"
-;-;-;-
-;5-6;-;5-6
strings
""
"ab"
regexps
"\\P{^Greek}+"
-;-;-;-
-;1-5;-;1-5
"^(?:\\P{^Greek}+)$"
-;-;-;-
-;-;-;-
"^(?:\\P{^Greek}+)"
-;-;-;-
-;-;-;-
"(?:\\P{^Greek}+)$"
-;-;-;-
-;-;-;-
strings
""
"abc123"
regexps
"[^0-9]+"
-;-;-;-
-;0-3;-;0-3
"^(?:[^0-9]+)$"
-;-;-;-
-;-;-;-
"^(?:[^0-9]+)"
-;-;-;-
-;0-3;-;0-3
"(?:[^0-9]+)$"
-;-;-;-
-;-;-;-
strings
""
"abc123"
regexps
"\\p{Nd}+"
-;-;-;-
-;3-6;-;3-6
"^(?:\\p{Nd}+)$"
-;-;-;-
-;-;-;-
"^(?:\\p{Nd}+)"
-;-;-;-
-;-;-;-
"(?:\\p{Nd}+)$"
-;-;-;-
-;-;-;-
strings
""
"abc123"
regexps
"\\p{^Nd}+"
-;-;-;-
-;0-3;-;0-3
"^(?:\\p{^Nd}+)$"
-;-;-;-
-;-;-;-
"^(?:\\p{^Nd}+)"
-;-;-;-
-;0-3;-;0-3
"(?:\\p{^Nd}+)$"
-;-;-;-
-;6-22;-;6-22
strings
""
"abc123"
regexps
"\\P{Nd}+"
-;-;-;-
-;0-3;-;0-3
"^(?:\\P{Nd}+)$"
-;-;-;-
-;-;-;-
"^(?:\\P{Nd}+)"
-;-;-;-
-;0-3;-;0-3
"(?:\\P{Nd}+)$"
-;-;-;-
-;6-22;-;6-22
strings
""
"abc123"
regexps
"\\P{^Nd}+"
-;-;-;-
-;3-6;-;3-6
"^(?:\\P{^Nd}+)$"
-;-;-;-
-;-;-;-
"^(?:\\P{^Nd}+)"
-;-;-;-
-;-;-;-
"(?:\\P{^Nd}+)$"
-;-;-;-
-;-;-;-
strings
""
"abc123"
regexps
"\\pN+"
-;-;-;-
-;3-22;-;3-22
"^(?:\\pN+)$"
-;-;-;-
-;-;-;-
"^(?:\\pN+)"
-;-;-;-
-;-;-;-
"(?:\\pN+)$"
-;-;-;-
-;3-22;-;3-22
strings
""
"abc123"
regexps
"\\p{N}+"
-;-;-;-
-;3-22;-;3-22
"^(?:\\p{N}+)$"
-;-;-;-
-;-;-;-
"^(?:\\p{N}+)"
-;-;-;-
-;-;-;-
"(?:\\p{N}+)$"
-;-;-;-
-;3-22;-;3-22
strings
""
"abc123"
regexps
"\\p{^N}+"
-;-;-;-
-;0-3;-;0-3
"^(?:\\p{^N}+)$"
-;-;-;-
-;-;-;-
"^(?:\\p{^N}+)"
-;-;-;-
-;0-3;-;0-3
"(?:\\p{^N}+)$"
-;-;-;-
-;-;-;-
strings
""
"abc123"
regexps
"\\p{Any}+"
-;-;-;-
0-6;0-6;0-6;0-6
"^(?:\\p{Any}+)$"
-;-;-;-
0-6;0-6;0-6;0-6
"^(?:\\p{Any}+)"
-;-;-;-
0-6;0-6;0-6;0-6
"(?:\\p{Any}+)$"
-;-;-;-
0-6;0-6;0-6;0-6
strings
""
"@AaB"
regexps
"(?i)[@-A]+"
-;-;-;-
-;0-3;-;0-3
"^(?:(?i)[@-A]+)$"
-;-;-;-
-;-;-;-
"^(?:(?i)[@-A]+)"
-;-;-;-
-;0-3;-;0-3
"(?:(?i)[@-A]+)$"
-;-;-;-
-;-;-;-
strings
""
"aAzZ"
regexps
"(?i)[A-Z]+"
-;-;-;-
0-4;0-4;0-4;0-4
"^(?:(?i)[A-Z]+)$"
-;-;-;-
0-4;0-4;0-4;0-4
"^(?:(?i)[A-Z]+)"
-;-;-;-
0-4;0-4;0-4;0-4
"(?:(?i)[A-Z]+)$"
-;-;-;-
0-4;0-4;0-4;0-4
strings
""
"Aa\\"
regexps
"(?i)[^\\\\]+"
-;-;-;-
-;0-2;-;0-2
"^(?:(?i)[^\\\\]+)$"
-;-;-;-
-;-;-;-
"^(?:(?i)[^\\\\]+)"
-;-;-;-
-;0-2;-;0-2
"(?:(?i)[^\\\\]+)$"
-;-;-;-
-;-;-;-
strings
""
"acegikmoqsuwyACEGIKMOQSUWY"
regexps
"(?i)[acegikmoqsuwy]+"
-;-;-;-
0-26;0-26;0-26;0-26
"^(?:(?i)[acegikmoqsuwy]+)$"
-;-;-;-
0-26;0-26;0-26;0-26
"^(?:(?i)[acegikmoqsuwy]+)"
-;-;-;-
0-26;0-26;0-26;0-26
"(?:(?i)[acegikmoqsuwy]+)$"
-;-;-;-
0-26;0-26;0-26;0-26
strings
""
"@AaB"
regexps
"[@-A]+"
-;-;-;-
-;0-2;-;0-2
"^(?:[@-A]+)$"
-;-;-;-
-;-;-;-
"^(?:[@-A]+)"
-;-;-;-
-;0-2;-;0-2
"(?:[@-A]+)$"
-;-;-;-
-;-;-;-
strings
""
"aAzZ"
regexps
"[A-Z]+"
-;-;-;-
-;1-2;-;1-2
"^(?:[A-Z]+)$"
-;-;-;-
-;-;-;-
"^(?:[A-Z]+)"
-;-;-;-
-;-;-;-
"(?:[A-Z]+)$"
-;-;-;-
-;3-4;-;3-4
strings
""
"Aa\\"
regexps
"[^\\\\]+"
-;-;-;-
-;0-2;-;0-2
"^(?:[^\\\\]+)$"
-;-;-;-
-;-;-;-
"^(?:[^\\\\]+)"
-;-;-;-
-;0-2;-;0-2
"(?:[^\\\\]+)$"
-;-;-;-
-;-;-;-
strings
""
"acegikmoqsuwyACEGIKMOQSUWY"
regexps
"[acegikmoqsuwy]+"
-;-;-;-
-;0-13;-;0-13
"^(?:[acegikmoqsuwy]+)$"
-;-;-;-
-;-;-;-
"^(?:[acegikmoqsuwy]+)"
-;-;-;-
-;0-13;-;0-13
"(?:[acegikmoqsuwy]+)$"
-;-;-;-
-;-;-;-
strings
""
"abcdef"
regexps
"^abc"
-;-;-;-
-;0-3;-;0-3
"^(?:^abc)$"
-;-;-;-
-;-;-;-
"^(?:^abc)"
-;-;-;-
-;0-3;-;0-3
"(?:^abc)$"
-;-;-;-
-;-;-;-
strings
""
"aabcdef"
regexps
"^abc"
-;-;-;-
-;-;-;-
"^(?:^abc)$"
-;-;-;-
-;-;-;-
"^(?:^abc)"
-;-;-;-
-;-;-;-
"(?:^abc)$"
-;-;-;-
-;-;-;-
strings
""
"abcdef"
regexps
"^[ay]*[bx]+c"
-;-;-;-
-;0-3;-;0-3
"^(?:^[ay]*[bx]+c)$"
-;-;-;-
-;-;-;-
"^(?:^[ay]*[bx]+c)"
-;-;-;-
-;0-3;-;0-3
"(?:^[ay]*[bx]+c)$"
-;-;-;-
-;-;-;-
strings
""
"aabcdef"
regexps
"^[ay]*[bx]+c"
-;-;-;-
-;0-4;-;0-4
"^(?:^[ay]*[bx]+c)$"
-;-;-;-
-;-;-;-
"^(?:^[ay]*[bx]+c)"
-;-;-;-
-;0-4;-;0-4
"(?:^[ay]*[bx]+c)$"
-;-;-;-
-;-;-;-
strings
""
"abcdef"
regexps
"def$"
-;-;-;-
-;3-6;-;3-6
"^(?:def$)$"
-;-;-;-
-;-;-;-
"^(?:def$)"
-;-;-;-
-;-;-;-
"(?:def$)$"
-;-;-;-
-;3-6;-;3-6
strings
""
"abcdeff"
regexps
"def$"
-;-;-;-
-;-;-;-
"^(?:def$)$"
-;-;-;-
-;-;-;-
"^(?:def$)"
-;-;-;-
-;-;-;-
"(?:def$)$"
-;-;-;-
-;-;-;-
strings
""
"abcdef"
regexps
"d[ex][fy]$"
-;-;-;-
-;3-6;-;3-6
"^(?:d[ex][fy]$)$"
-;-;-;-
-;-;-;-
"^(?:d[ex][fy]$)"
-;-;-;-
-;-;-;-
"(?:d[ex][fy]$)$"
-;-;-;-
-;3-6;-;3-6
strings
""
"abcdeff"
regexps
"d[ex][fy]$"
-;-;-;-
-;-;-;-
"^(?:d[ex][fy]$)$"
-;-;-;-
-;-;-;-
"^(?:d[ex][fy]$)"
-;-;-;-
-;-;-;-
"(?:d[ex][fy]$)$"
-;-;-;-
-;-;-;-
strings
""
"abcdef"
regexps
"[dz][ex][fy]$"
-;-;-;-
-;3-6;-;3-6
"^(?:[dz][ex][fy]$)$"
-;-;-;-
-;-;-;-
"^(?:[dz][ex][fy]$)"
-;-;-;-
-;-;-;-
"(?:[dz][ex][fy]$)$"
-;-;-;-
-;3-6;-;3-6
strings
""
"abcdeff"
regexps
"[dz][ex][fy]$"
-;-;-;-
-;-;-;-
"^(?:[dz][ex][fy]$)$"
-;-;-;-
-;-;-;-
"^(?:[dz][ex][fy]$)"
-;-;-;-
-;-;-;-
"(?:[dz][ex][fy]$)$"
-;-;-;-
-;-;-;-
strings
""
"abcdef"
regexps
"(?m)^abc"
-;-;-;-
-;0-3;-;0-3
"^(?:(?m)^abc)$"
-;-;-;-
-;-;-;-
"^(?:(?m)^abc)"
-;-;-;-
-;0-3;-;0-3
"(?:(?m)^abc)$"
-;-;-;-
-;-;-;-
strings
""
"aabcdef"
regexps
"(?m)^abc"
-;-;-;-
-;-;-;-
"^(?:(?m)^abc)$"
-;-;-;-
-;-;-;-
"^(?:(?m)^abc)"
-;-;-;-
-;-;-;-
"(?:(?m)^abc)$"
-;-;-;-
-;-;-;-
strings
""
"abcdef"
regexps
"(?m)^[ay]*[bx]+c"
-;-;-;-
-;0-3;-;0-3
"^(?:(?m)^[ay]*[bx]+c)$"
-;-;-;-
-;-;-;-
"^(?:(?m)^[ay]*[bx]+c)"
-;-;-;-
-;0-3;-;0-3
"(?:(?m)^[ay]*[bx]+c)$"
-;-;-;-
-;-;-;-
strings
""
"aabcdef"
regexps
"(?m)^[ay]*[bx]+c"
-;-;-;-
-;0-4;-;0-4
"^(?:(?m)^[ay]*[bx]+c)$"
-;-;-;-
-;-;-;-
"^(?:(?m)^[ay]*[bx]+c)"
-;-;-;-
-;0-4;-;0-4
"(?:(?m)^[ay]*[bx]+c)$"
-;-;-;-
-;-;-;-
strings
""
"abcdef"
regexps
"(?m)def$"
-;-;-;-
-;3-6;-;3-6
"^(?:(?m)def$)$"
-;-;-;-
-;-;-;-
"^(?:(?m)def$)"
-;-;-;-
-;-;-;-
"(?:(?m)def$)$"
-;-;-;-
-;3-6;-;3-6
strings
""
"abcdeff"
regexps
"(?m)def$"
-;-;-;-
-;-;-;-
"^(?:(?m)def$)$"
-;-;-;-
-;-;-;-
"^(?:(?m)def$)"
-;-;-;-
-;-;-;-
"(?:(?m)def$)$"
-;-;-;-
-;-;-;-
strings
""
"abcdef"
regexps
"(?m)d[ex][fy]$"
-;-;-;-
-;3-6;-;3-6
"^(?:(?m)d[ex][fy]$)$"
-;-;-;-
-;-;-;-
"^(?:(?m)d[ex][fy]$)"
-;-;-;-
-;-;-;-
"(?:(?m)d[ex][fy]$)$"
-;-;-;-
-;3-6;-;3-6
strings
""
"abcdeff"
regexps
"(?m)d[ex][fy]$"
-;-;-;-
-;-;-;-
"^(?:(?m)d[ex][fy]$)$"
-;-;-;-
-;-;-;-
"^(?:(?m)d[ex][fy]$)"
-;-;-;-
-;-;-;-
"(?:(?m)d[ex][fy]$)$"
-;-;-;-
-;-;-;-
strings
""
"abcdef"
regexps
"(?m)[dz][ex][fy]$"
-;-;-;-
-;3-6;-;3-6
"^(?:(?m)[dz][ex][fy]$)$"
-;-;-;-
-;-;-;-
"^(?:(?m)[dz][ex][fy]$)"
-;-;-;-
-;-;-;-
"(?:(?m)[dz][ex][fy]$)$"
-;-;-;-
-;3-6;-;3-6
strings
""
"abcdeff"
regexps
"(?m)[dz][ex][fy]$"
-;-;-;-
-;-;-;-
"^(?:(?m)[dz][ex][fy]$)$"
-;-;-;-
-;-;-;-
"^(?:(?m)[dz][ex][fy]$)"
-;-;-;-
-;-;-;-
"(?:(?m)[dz][ex][fy]$)$"
-;-;-;-
-;-;-;-
strings
""
"a"
regexps
"^"
0-0;0-0;0-0;0-0
-;0-0;-;0-0
"^(?:^)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^)"
0-0;0-0;0-0;0-0
-;0-0;-;0-0
"(?:^)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
"a"
regexps
"^^"
0-0;0-0;0-0;0-0
-;0-0;-;0-0
"^(?:^^)$"
0-0;0-0;0-0;0-0
-;-;-;-
"^(?:^^)"
0-0;0-0;0-0;0-0
-;0-0;-;0-0
"(?:^^)$"
0-0;0-0;0-0;0-0
-;-;-;-
strings
""
"a"
regexps
"a"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:a)$"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:a)"
-;-;-;-
0-1;0-1;0-1;0-1
"(?:a)$"
-;-;-;-
0-1;0-1;0-1;0-1
strings
""
"a"
regexps
"ab*"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:ab*)$"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:ab*)"
-;-;-;-
0-1;0-1;0-1;0-1
"(?:ab*)$"
-;-;-;-
0-1;0-1;0-1;0-1
strings
""
"a"
regexps
"a\\C*"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:a\\C*)$"
-;-;-;-
0-1;0-1;0-1;0-1
"^(?:a\\C*)"
-;-;-;-
0-1;0-1;0-1;0-1
"(?:a\\C*)$"
-;-;-;-
0-1;0-1;0-1;0-1
strings
""
"baba"
regexps
"a\\C*|ba\\C"
-;-;-;-
-;0-3;-;0-3
"^(?:a\\C*|ba\\C)$"
-;-;-;-
-;-;-;-
"^(?:a\\C*|ba\\C)"
-;-;-;-
-;0-3;-;0-3
"(?:a\\C*|ba\\C)$"
-;-;-;-
-;1-4;-;1-4
                                                                                                                                                                                                                                        root/go1.4/src/regexp/testdata/repetition.dat                                                       0100644 0000000 0000000 00000015160 12600426227 017632  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        NOTE	implicit vs. explicit repetitions : 2009-02-02

# Glenn Fowler <gsf@research.att.com>
# conforming matches (column 4) must match one of the following BREs
#	NOMATCH
#	(0,.)\((\(.\),\(.\))(?,?)(\2,\3)\)*
#	(0,.)\((\(.\),\(.\))(\2,\3)(?,?)\)*
# i.e., each 3-tuple has two identical elements and one (?,?)

E	((..)|(.))				NULL		NOMATCH
E	((..)|(.))((..)|(.))			NULL		NOMATCH
E	((..)|(.))((..)|(.))((..)|(.))		NULL		NOMATCH

E	((..)|(.)){1}				NULL		NOMATCH
E	((..)|(.)){2}				NULL		NOMATCH
E	((..)|(.)){3}				NULL		NOMATCH

E	((..)|(.))*				NULL		(0,0)

E	((..)|(.))				a		(0,1)(0,1)(?,?)(0,1)
E	((..)|(.))((..)|(.))			a		NOMATCH
E	((..)|(.))((..)|(.))((..)|(.))		a		NOMATCH

E	((..)|(.)){1}				a		(0,1)(0,1)(?,?)(0,1)
E	((..)|(.)){2}				a		NOMATCH
E	((..)|(.)){3}				a		NOMATCH

E	((..)|(.))*				a		(0,1)(0,1)(?,?)(0,1)

E	((..)|(.))				aa		(0,2)(0,2)(0,2)(?,?)
E	((..)|(.))((..)|(.))			aa		(0,2)(0,1)(?,?)(0,1)(1,2)(?,?)(1,2)
E	((..)|(.))((..)|(.))((..)|(.))		aa		NOMATCH

E	((..)|(.)){1}				aa		(0,2)(0,2)(0,2)(?,?)
E	((..)|(.)){2}				aa		(0,2)(1,2)(?,?)(1,2)
E	((..)|(.)){3}				aa		NOMATCH

E	((..)|(.))*				aa		(0,2)(0,2)(0,2)(?,?)

E	((..)|(.))				aaa		(0,2)(0,2)(0,2)(?,?)
E	((..)|(.))((..)|(.))			aaa		(0,3)(0,2)(0,2)(?,?)(2,3)(?,?)(2,3)
E	((..)|(.))((..)|(.))((..)|(.))		aaa		(0,3)(0,1)(?,?)(0,1)(1,2)(?,?)(1,2)(2,3)(?,?)(2,3)

E	((..)|(.)){1}				aaa		(0,2)(0,2)(0,2)(?,?)
#E	((..)|(.)){2}				aaa		(0,3)(2,3)(?,?)(2,3)
E	((..)|(.)){2}				aaa		(0,3)(2,3)(0,2)(2,3)	RE2/Go
E	((..)|(.)){3}				aaa		(0,3)(2,3)(?,?)(2,3)

#E	((..)|(.))*				aaa		(0,3)(2,3)(?,?)(2,3)
E	((..)|(.))*				aaa		(0,3)(2,3)(0,2)(2,3)	RE2/Go

E	((..)|(.))				aaaa		(0,2)(0,2)(0,2)(?,?)
E	((..)|(.))((..)|(.))			aaaa		(0,4)(0,2)(0,2)(?,?)(2,4)(2,4)(?,?)
E	((..)|(.))((..)|(.))((..)|(.))		aaaa		(0,4)(0,2)(0,2)(?,?)(2,3)(?,?)(2,3)(3,4)(?,?)(3,4)

E	((..)|(.)){1}				aaaa		(0,2)(0,2)(0,2)(?,?)
E	((..)|(.)){2}				aaaa		(0,4)(2,4)(2,4)(?,?)
#E	((..)|(.)){3}				aaaa		(0,4)(3,4)(?,?)(3,4)
E	((..)|(.)){3}				aaaa		(0,4)(3,4)(0,2)(3,4)	RE2/Go

E	((..)|(.))*				aaaa		(0,4)(2,4)(2,4)(?,?)

E	((..)|(.))				aaaaa		(0,2)(0,2)(0,2)(?,?)
E	((..)|(.))((..)|(.))			aaaaa		(0,4)(0,2)(0,2)(?,?)(2,4)(2,4)(?,?)
E	((..)|(.))((..)|(.))((..)|(.))		aaaaa		(0,5)(0,2)(0,2)(?,?)(2,4)(2,4)(?,?)(4,5)(?,?)(4,5)

E	((..)|(.)){1}				aaaaa		(0,2)(0,2)(0,2)(?,?)
E	((..)|(.)){2}				aaaaa		(0,4)(2,4)(2,4)(?,?)
#E	((..)|(.)){3}				aaaaa		(0,5)(4,5)(?,?)(4,5)
E	((..)|(.)){3}				aaaaa		(0,5)(4,5)(2,4)(4,5)	RE2/Go

#E	((..)|(.))*				aaaaa		(0,5)(4,5)(?,?)(4,5)
E	((..)|(.))*				aaaaa		(0,5)(4,5)(2,4)(4,5)	RE2/Go

E	((..)|(.))				aaaaaa		(0,2)(0,2)(0,2)(?,?)
E	((..)|(.))((..)|(.))			aaaaaa		(0,4)(0,2)(0,2)(?,?)(2,4)(2,4)(?,?)
E	((..)|(.))((..)|(.))((..)|(.))		aaaaaa		(0,6)(0,2)(0,2)(?,?)(2,4)(2,4)(?,?)(4,6)(4,6)(?,?)

E	((..)|(.)){1}				aaaaaa		(0,2)(0,2)(0,2)(?,?)
E	((..)|(.)){2}				aaaaaa		(0,4)(2,4)(2,4)(?,?)
E	((..)|(.)){3}				aaaaaa		(0,6)(4,6)(4,6)(?,?)

E	((..)|(.))*				aaaaaa		(0,6)(4,6)(4,6)(?,?)

NOTE	additional repetition tests graciously provided by Chris Kuklewicz www.haskell.org 2009-02-02

# These test a bug in OS X / FreeBSD / NetBSD, and libtree. 
# Linux/GLIBC gets the {8,} and {8,8} wrong.

:HA#100:E	X(.?){0,}Y	X1234567Y	(0,9)(7,8)
:HA#101:E	X(.?){1,}Y	X1234567Y	(0,9)(7,8)
:HA#102:E	X(.?){2,}Y	X1234567Y	(0,9)(7,8)
:HA#103:E	X(.?){3,}Y	X1234567Y	(0,9)(7,8)
:HA#104:E	X(.?){4,}Y	X1234567Y	(0,9)(7,8)
:HA#105:E	X(.?){5,}Y	X1234567Y	(0,9)(7,8)
:HA#106:E	X(.?){6,}Y	X1234567Y	(0,9)(7,8)
:HA#107:E	X(.?){7,}Y	X1234567Y	(0,9)(7,8)
:HA#108:E	X(.?){8,}Y	X1234567Y	(0,9)(8,8)
#:HA#110:E	X(.?){0,8}Y	X1234567Y	(0,9)(7,8)
:HA#110:E	X(.?){0,8}Y	X1234567Y	(0,9)(8,8)	RE2/Go
#:HA#111:E	X(.?){1,8}Y	X1234567Y	(0,9)(7,8)
:HA#111:E	X(.?){1,8}Y	X1234567Y	(0,9)(8,8)	RE2/Go
#:HA#112:E	X(.?){2,8}Y	X1234567Y	(0,9)(7,8)
:HA#112:E	X(.?){2,8}Y	X1234567Y	(0,9)(8,8)	RE2/Go
#:HA#113:E	X(.?){3,8}Y	X1234567Y	(0,9)(7,8)
:HA#113:E	X(.?){3,8}Y	X1234567Y	(0,9)(8,8)	RE2/Go
#:HA#114:E	X(.?){4,8}Y	X1234567Y	(0,9)(7,8)
:HA#114:E	X(.?){4,8}Y	X1234567Y	(0,9)(8,8)	RE2/Go
#:HA#115:E	X(.?){5,8}Y	X1234567Y	(0,9)(7,8)
:HA#115:E	X(.?){5,8}Y	X1234567Y	(0,9)(8,8)	RE2/Go
#:HA#116:E	X(.?){6,8}Y	X1234567Y	(0,9)(7,8)
:HA#116:E	X(.?){6,8}Y	X1234567Y	(0,9)(8,8)	RE2/Go
#:HA#117:E	X(.?){7,8}Y	X1234567Y	(0,9)(7,8)
:HA#117:E	X(.?){7,8}Y	X1234567Y	(0,9)(8,8)	RE2/Go
:HA#118:E	X(.?){8,8}Y	X1234567Y	(0,9)(8,8)

# These test a fixed bug in my regex-tdfa that did not keep the expanded
# form properly grouped, so right association did the wrong thing with
# these ambiguous patterns (crafted just to test my code when I became
# suspicious of my implementation).  The first subexpression should use
# "ab" then "a" then "bcd".

# OS X / FreeBSD / NetBSD badly fail many of these, with impossible
# results like (0,6)(4,5)(6,6).

:HA#260:E	(a|ab|c|bcd){0,}(d*)	ababcd	(0,6)(3,6)(6,6)
:HA#261:E	(a|ab|c|bcd){1,}(d*)	ababcd	(0,6)(3,6)(6,6)
:HA#262:E	(a|ab|c|bcd){2,}(d*)	ababcd	(0,6)(3,6)(6,6)
:HA#263:E	(a|ab|c|bcd){3,}(d*)	ababcd	(0,6)(3,6)(6,6)
:HA#264:E	(a|ab|c|bcd){4,}(d*)	ababcd	NOMATCH
:HA#265:E	(a|ab|c|bcd){0,10}(d*)	ababcd	(0,6)(3,6)(6,6)
:HA#266:E	(a|ab|c|bcd){1,10}(d*)	ababcd	(0,6)(3,6)(6,6)
:HA#267:E	(a|ab|c|bcd){2,10}(d*)	ababcd	(0,6)(3,6)(6,6)
:HA#268:E	(a|ab|c|bcd){3,10}(d*)	ababcd	(0,6)(3,6)(6,6)
:HA#269:E	(a|ab|c|bcd){4,10}(d*)	ababcd	NOMATCH
:HA#270:E	(a|ab|c|bcd)*(d*)	ababcd	(0,6)(3,6)(6,6)
:HA#271:E	(a|ab|c|bcd)+(d*)	ababcd	(0,6)(3,6)(6,6)

# The above worked on Linux/GLIBC but the following often fail.
# They also trip up OS X / FreeBSD / NetBSD:

#:HA#280:E	(ab|a|c|bcd){0,}(d*)	ababcd	(0,6)(3,6)(6,6)
:HA#280:E	(ab|a|c|bcd){0,}(d*)	ababcd	(0,6)(4,5)(5,6)	RE2/Go
#:HA#281:E	(ab|a|c|bcd){1,}(d*)	ababcd	(0,6)(3,6)(6,6)
:HA#281:E	(ab|a|c|bcd){1,}(d*)	ababcd	(0,6)(4,5)(5,6)	RE2/Go
#:HA#282:E	(ab|a|c|bcd){2,}(d*)	ababcd	(0,6)(3,6)(6,6)
:HA#282:E	(ab|a|c|bcd){2,}(d*)	ababcd	(0,6)(4,5)(5,6)	RE2/Go
#:HA#283:E	(ab|a|c|bcd){3,}(d*)	ababcd	(0,6)(3,6)(6,6)
:HA#283:E	(ab|a|c|bcd){3,}(d*)	ababcd	(0,6)(4,5)(5,6)	RE2/Go
:HA#284:E	(ab|a|c|bcd){4,}(d*)	ababcd	NOMATCH
#:HA#285:E	(ab|a|c|bcd){0,10}(d*)	ababcd	(0,6)(3,6)(6,6)
:HA#285:E	(ab|a|c|bcd){0,10}(d*)	ababcd	(0,6)(4,5)(5,6)	RE2/Go
#:HA#286:E	(ab|a|c|bcd){1,10}(d*)	ababcd	(0,6)(3,6)(6,6)
:HA#286:E	(ab|a|c|bcd){1,10}(d*)	ababcd	(0,6)(4,5)(5,6)	RE2/Go
#:HA#287:E	(ab|a|c|bcd){2,10}(d*)	ababcd	(0,6)(3,6)(6,6)
:HA#287:E	(ab|a|c|bcd){2,10}(d*)	ababcd	(0,6)(4,5)(5,6)	RE2/Go
#:HA#288:E	(ab|a|c|bcd){3,10}(d*)	ababcd	(0,6)(3,6)(6,6)
:HA#288:E	(ab|a|c|bcd){3,10}(d*)	ababcd	(0,6)(4,5)(5,6)	RE2/Go
:HA#289:E	(ab|a|c|bcd){4,10}(d*)	ababcd	NOMATCH
#:HA#290:E	(ab|a|c|bcd)*(d*)	ababcd	(0,6)(3,6)(6,6)
:HA#290:E	(ab|a|c|bcd)*(d*)	ababcd	(0,6)(4,5)(5,6)	RE2/Go
#:HA#291:E	(ab|a|c|bcd)+(d*)	ababcd	(0,6)(3,6)(6,6)
:HA#291:E	(ab|a|c|bcd)+(d*)	ababcd	(0,6)(4,5)(5,6)	RE2/Go
                                                                                                                                                                                                                                                                                                                                                                                                                root/go1.4/src/regexp/testdata/testregex.c                                                          0100644 0000000 0000000 00000146535 12600426227 017147  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #pragma prototyped noticed

/*
 * regex(3) test harness
 *
 * build:	cc -o testregex testregex.c
 * help:	testregex --man
 * note:	REG_* features are detected by #ifdef; if REG_* are enums
 *		then supply #define REG_foo REG_foo for each enum REG_foo
 *
 *	Glenn Fowler <gsf@research.att.com>
 *	AT&T Research
 *
 * PLEASE: publish your tests so everyone can benefit
 *
 * The following license covers testregex.c and all associated test data.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of THIS SOFTWARE FILE (the "Software"), to deal in the Software
 * without restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, and/or sell copies of the
 * Software, and to permit persons to whom the Software is furnished to do
 * so, subject to the following disclaimer:
 *
 * THIS SOFTWARE IS PROVIDED BY AT&T ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL AT&T BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

static const char id[] = "\n@(#)$Id: testregex (AT&T Research) 2010-06-10 $\0\n";

#if _PACKAGE_ast
#include <ast.h>
#else
#include <sys/types.h>
#endif

#include <stdio.h>
#include <regex.h>
#include <ctype.h>
#include <setjmp.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>

#ifdef	__STDC__
#include <stdlib.h>
#include <locale.h>
#endif

#ifndef RE_DUP_MAX
#define RE_DUP_MAX	32767
#endif

#if !_PACKAGE_ast
#undef	REG_DISCIPLINE
#endif

#ifndef REG_DELIMITED
#undef	_REG_subcomp
#endif

#define TEST_ARE		0x00000001
#define TEST_BRE		0x00000002
#define TEST_ERE		0x00000004
#define TEST_KRE		0x00000008
#define TEST_LRE		0x00000010
#define TEST_SRE		0x00000020

#define TEST_EXPAND		0x00000100
#define TEST_LENIENT		0x00000200

#define TEST_QUERY		0x00000400
#define TEST_SUB		0x00000800
#define TEST_UNSPECIFIED	0x00001000
#define TEST_VERIFY		0x00002000
#define TEST_AND		0x00004000
#define TEST_OR			0x00008000

#define TEST_DELIMIT		0x00010000
#define TEST_OK			0x00020000
#define TEST_SAME		0x00040000

#define TEST_ACTUAL		0x00100000
#define TEST_BASELINE		0x00200000
#define TEST_FAIL		0x00400000
#define TEST_PASS		0x00800000
#define TEST_SUMMARY		0x01000000

#define TEST_IGNORE_ERROR	0x02000000
#define TEST_IGNORE_OVER	0x04000000
#define TEST_IGNORE_POSITION	0x08000000

#define TEST_CATCH		0x10000000
#define TEST_VERBOSE		0x20000000

#define TEST_DECOMP		0x40000000

#define TEST_GLOBAL		(TEST_ACTUAL|TEST_AND|TEST_BASELINE|TEST_CATCH|TEST_FAIL|TEST_IGNORE_ERROR|TEST_IGNORE_OVER|TEST_IGNORE_POSITION|TEST_OR|TEST_PASS|TEST_SUMMARY|TEST_VERBOSE)

#ifdef REG_DISCIPLINE


#include <stk.h>

typedef struct Disc_s
{
	regdisc_t	disc;
	int		ordinal;
	Sfio_t*		sp;
} Disc_t;

static void*
compf(const regex_t* re, const char* xstr, size_t xlen, regdisc_t* disc)
{
	Disc_t*		dp = (Disc_t*)disc;

	return (void*)((char*)0 + ++dp->ordinal);
}

static int
execf(const regex_t* re, void* data, const char* xstr, size_t xlen, const char* sstr, size_t slen, char** snxt, regdisc_t* disc)
{
	Disc_t*		dp = (Disc_t*)disc;

	sfprintf(dp->sp, "{%-.*s}(%lu:%d)", xlen, xstr, (char*)data - (char*)0, slen);
	return atoi(xstr);
}

static void*
resizef(void* handle, void* data, size_t size)
{
	if (!size)
		return 0;
	return stkalloc((Sfio_t*)handle, size);
}

#endif

#ifndef NiL
#ifdef	__STDC__
#define NiL		0
#else
#define NiL		(char*)0
#endif
#endif

#define H(x)		do{if(html)fprintf(stderr,x);}while(0)
#define T(x)		fprintf(stderr,x)

static void
help(int html)
{
H("<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML//EN\">\n");
H("<HTML>\n");
H("<HEAD>\n");
H("<TITLE>testregex man document</TITLE>\n");
H("</HEAD>\n");
H("<BODY bgcolor=white>\n");
H("<PRE>\n");
T("NAME\n");
T("  testregex - regex(3) test harness\n");
T("\n");
T("SYNOPSIS\n");
T("  testregex [ options ]\n");
T("\n");
T("DESCRIPTION\n");
T("  testregex reads regex(3) test specifications, one per line, from the\n");
T("  standard input and writes one output line for each failed test. A\n");
T("  summary line is written after all tests are done. Each successful\n");
T("  test is run again with REG_NOSUB. Unsupported features are noted\n");
T("  before the first test, and tests requiring these features are\n");
T("  silently ignored.\n");
T("\n");
T("OPTIONS\n");
T("  -c	catch signals and non-terminating calls\n");
T("  -e	ignore error return mismatches\n");
T("  -h	list help on standard error\n");
T("  -n	do not repeat successful tests with regnexec()\n");
T("  -o	ignore match[] overrun errors\n");
T("  -p	ignore negative position mismatches\n");
T("  -s	use stack instead of malloc\n");
T("  -x	do not repeat successful tests with REG_NOSUB\n");
T("  -v	list each test line\n");
T("  -A	list failed test lines with actual answers\n");
T("  -B	list all test lines with actual answers\n");
T("  -F	list failed test lines\n");
T("  -P	list passed test lines\n");
T("  -S	output one summary line\n");
T("\n");
T("INPUT FORMAT\n");
T("  Input lines may be blank, a comment beginning with #, or a test\n");
T("  specification. A specification is five fields separated by one\n");
T("  or more tabs. NULL denotes the empty string and NIL denotes the\n");
T("  0 pointer.\n");
T("\n");
T("  Field 1: the regex(3) flags to apply, one character per REG_feature\n");
T("  flag. The test is skipped if REG_feature is not supported by the\n");
T("  implementation. If the first character is not [BEASKLP] then the\n");
T("  specification is a global control line. One or more of [BEASKLP] may be\n");
T("  specified; the test will be repeated for each mode.\n");
T("\n");
T("    B 	basic			BRE	(grep, ed, sed)\n");
T("    E 	REG_EXTENDED		ERE	(egrep)\n");
T("    A	REG_AUGMENTED		ARE	(egrep with negation)\n");
T("    S	REG_SHELL		SRE	(sh glob)\n");
T("    K	REG_SHELL|REG_AUGMENTED	KRE	(ksh glob)\n");
T("    L	REG_LITERAL		LRE	(fgrep)\n");
T("\n");
T("    a	REG_LEFT|REG_RIGHT	implicit ^...$\n");
T("    b	REG_NOTBOL		lhs does not match ^\n");
T("    c	REG_COMMENT		ignore space and #...\\n\n");
T("    d	REG_SHELL_DOT		explicit leading . match\n");
T("    e	REG_NOTEOL		rhs does not match $\n");
T("    f	REG_MULTIPLE		multiple \\n separated patterns\n");
T("    g	FNM_LEADING_DIR		testfnmatch only -- match until /\n");
T("    h	REG_MULTIREF		multiple digit backref\n");
T("    i	REG_ICASE		ignore case\n");
T("    j	REG_SPAN		. matches \\n\n");
T("    k	REG_ESCAPE		\\ to ecape [...] delimiter\n");
T("    l	REG_LEFT		implicit ^...\n");
T("    m	REG_MINIMAL		minimal match\n");
T("    n	REG_NEWLINE		explicit \\n match\n");
T("    o	REG_ENCLOSED		(|&) magic inside [@|&](...)\n");
T("    p	REG_SHELL_PATH		explicit / match\n");
T("    q	REG_DELIMITED		delimited pattern\n");
T("    r	REG_RIGHT		implicit ...$\n");
T("    s	REG_SHELL_ESCAPED	\\ not special\n");
T("    t	REG_MUSTDELIM		all delimiters must be specified\n");
T("    u	standard unspecified behavior -- errors not counted\n");
T("    v	REG_CLASS_ESCAPE	\\ special inside [...]\n");
T("    w	REG_NOSUB		no subexpression match array\n");
T("    x	REG_LENIENT		let some errors slide\n");
T("    y	REG_LEFT		regexec() implicit ^...\n");
T("    z	REG_NULL		NULL subexpressions ok\n");
T("    $	                        expand C \\c escapes in fields 2 and 3\n");
T("    /	                        field 2 is a regsubcomp() expression\n");
T("    =	                        field 3 is a regdecomp() expression\n");
T("\n");
T("  Field 1 control lines:\n");
T("\n");
T("    C		set LC_COLLATE and LC_CTYPE to locale in field 2\n");
T("\n");
T("    ?test ...	output field 5 if passed and != EXPECTED, silent otherwise\n");
T("    &test ...	output field 5 if current and previous passed\n");
T("    |test ...	output field 5 if current passed and previous failed\n");
T("    ; ...	output field 2 if previous failed\n");
T("    {test ...	skip if failed until }\n");
T("    }		end of skip\n");
T("\n");
T("    : comment		comment copied as output NOTE\n");
T("    :comment:test	:comment: ignored\n");
T("    N[OTE] comment	comment copied as output NOTE\n");
T("    T[EST] comment	comment\n");
T("\n");
T("    number		use number for nmatch (20 by default)\n");
T("\n");
T("  Field 2: the regular expression pattern; SAME uses the pattern from\n");
T("    the previous specification. RE_DUP_MAX inside {...} expands to the\n");
T("    value from <limits.h>.\n");
T("\n");
T("  Field 3: the string to match. X...{RE_DUP_MAX} expands to RE_DUP_MAX\n");
T("    copies of X.\n");
T("\n");
T("  Field 4: the test outcome. This is either one of the posix error\n");
T("    codes (with REG_ omitted) or the match array, a list of (m,n)\n");
T("    entries with m and n being first and last+1 positions in the\n");
T("    field 3 string, or NULL if REG_NOSUB is in effect and success\n");
T("    is expected. BADPAT is acceptable in place of any regcomp(3)\n");
T("    error code. The match[] array is initialized to (-2,-2) before\n");
T("    each test. All array elements from 0 to nmatch-1 must be specified\n");
T("    in the outcome. Unspecified endpoints (offset -1) are denoted by ?.\n");
T("    Unset endpoints (offset -2) are denoted by X. {x}(o:n) denotes a\n");
T("    matched (?{...}) expression, where x is the text enclosed by {...},\n");
T("    o is the expression ordinal counting from 1, and n is the length of\n");
T("    the unmatched portion of the subject string. If x starts with a\n");
T("    number then that is the return value of re_execf(), otherwise 0 is\n");
T("    returned. RE_DUP_MAX[-+]N expands to the <limits.h> value -+N.\n");
T("\n");
T("  Field 5: optional comment appended to the report.\n");
T("\n");
T("CAVEAT\n");
T("    If a regex implementation misbehaves with memory then all bets are off.\n");
T("\n");
T("CONTRIBUTORS\n");
T("  Glenn Fowler    gsf@research.att.com        (ksh strmatch, regex extensions)\n");
T("  David Korn      dgk@research.att.com        (ksh glob matcher)\n");
T("  Doug McIlroy    mcilroy@dartmouth.edu       (ast regex/testre in C++)\n");
T("  Tom Lord        lord@regexps.com            (rx tests)\n");
T("  Henry Spencer   henry@zoo.toronto.edu       (original public regex)\n");
T("  Andrew Hume     andrew@research.att.com     (gre tests)\n");
T("  John Maddock    John_Maddock@compuserve.com (regex++ tests)\n");
T("  Philip Hazel    ph10@cam.ac.uk              (pcre tests)\n");
T("  Ville Laurikari vl@iki.fi                   (libtre tests)\n");
H("</PRE>\n");
H("</BODY>\n");
H("</HTML>\n");
}

#ifndef elementsof
#define elementsof(x)	(sizeof(x)/sizeof(x[0]))
#endif

#ifndef streq
#define streq(a,b)	(*(a)==*(b)&&!strcmp(a,b))
#endif

#define HUNG		2
#define NOTEST		(~0)

#ifndef REG_TEST_DEFAULT
#define REG_TEST_DEFAULT	0
#endif

#ifndef REG_EXEC_DEFAULT
#define REG_EXEC_DEFAULT	0
#endif

static const char* unsupported[] =
{
	"BASIC",
#ifndef REG_EXTENDED
	"EXTENDED",
#endif
#ifndef REG_AUGMENTED
	"AUGMENTED",
#endif
#ifndef REG_SHELL
	"SHELL",
#endif

#ifndef REG_CLASS_ESCAPE
	"CLASS_ESCAPE",
#endif
#ifndef REG_COMMENT
	"COMMENT",
#endif
#ifndef REG_DELIMITED
	"DELIMITED",
#endif
#ifndef REG_DISCIPLINE
	"DISCIPLINE",
#endif
#ifndef REG_ESCAPE
	"ESCAPE",
#endif
#ifndef REG_ICASE
	"ICASE",
#endif
#ifndef REG_LEFT
	"LEFT",
#endif
#ifndef REG_LENIENT
	"LENIENT",
#endif
#ifndef REG_LITERAL
	"LITERAL",
#endif
#ifndef REG_MINIMAL
	"MINIMAL",
#endif
#ifndef REG_MULTIPLE
	"MULTIPLE",
#endif
#ifndef REG_MULTIREF
	"MULTIREF",
#endif
#ifndef REG_MUSTDELIM
	"MUSTDELIM",
#endif
#ifndef REG_NEWLINE
	"NEWLINE",
#endif
#ifndef REG_NOTBOL
	"NOTBOL",
#endif
#ifndef REG_NOTEOL
	"NOTEOL",
#endif
#ifndef REG_NULL
	"NULL",
#endif
#ifndef REG_RIGHT
	"RIGHT",
#endif
#ifndef REG_SHELL_DOT
	"SHELL_DOT",
#endif
#ifndef REG_SHELL_ESCAPED
	"SHELL_ESCAPED",
#endif
#ifndef REG_SHELL_GROUP
	"SHELL_GROUP",
#endif
#ifndef REG_SHELL_PATH
	"SHELL_PATH",
#endif
#ifndef REG_SPAN
	"SPAN",
#endif
#if REG_NOSUB & REG_TEST_DEFAULT
	"SUBMATCH",
#endif
#if !_REG_nexec
	"regnexec",
#endif
#if !_REG_subcomp
	"regsubcomp",
#endif
#if !_REG_decomp
	"redecomp",
#endif
	0
};

#ifndef REG_CLASS_ESCAPE
#define REG_CLASS_ESCAPE	NOTEST
#endif
#ifndef REG_COMMENT
#define REG_COMMENT	NOTEST
#endif
#ifndef REG_DELIMITED
#define REG_DELIMITED	NOTEST
#endif
#ifndef REG_ESCAPE
#define REG_ESCAPE	NOTEST
#endif
#ifndef REG_ICASE
#define REG_ICASE	NOTEST
#endif
#ifndef REG_LEFT
#define REG_LEFT	NOTEST
#endif
#ifndef REG_LENIENT
#define REG_LENIENT	0
#endif
#ifndef REG_MINIMAL
#define REG_MINIMAL	NOTEST
#endif
#ifndef REG_MULTIPLE
#define REG_MULTIPLE	NOTEST
#endif
#ifndef REG_MULTIREF
#define REG_MULTIREF	NOTEST
#endif
#ifndef REG_MUSTDELIM
#define REG_MUSTDELIM	NOTEST
#endif
#ifndef REG_NEWLINE
#define REG_NEWLINE	NOTEST
#endif
#ifndef REG_NOTBOL
#define REG_NOTBOL	NOTEST
#endif
#ifndef REG_NOTEOL
#define REG_NOTEOL	NOTEST
#endif
#ifndef REG_NULL
#define REG_NULL	NOTEST
#endif
#ifndef REG_RIGHT
#define REG_RIGHT	NOTEST
#endif
#ifndef REG_SHELL_DOT
#define REG_SHELL_DOT	NOTEST
#endif
#ifndef REG_SHELL_ESCAPED
#define REG_SHELL_ESCAPED	NOTEST
#endif
#ifndef REG_SHELL_GROUP
#define REG_SHELL_GROUP	NOTEST
#endif
#ifndef REG_SHELL_PATH
#define REG_SHELL_PATH	NOTEST
#endif
#ifndef REG_SPAN
#define REG_SPAN	NOTEST
#endif

#define REG_UNKNOWN	(-1)

#ifndef REG_ENEWLINE
#define REG_ENEWLINE	(REG_UNKNOWN-1)
#endif
#ifndef REG_ENULL
#ifndef REG_EMPTY
#define REG_ENULL	(REG_UNKNOWN-2)
#else
#define REG_ENULL	REG_EMPTY
#endif
#endif
#ifndef REG_ECOUNT
#define REG_ECOUNT	(REG_UNKNOWN-3)
#endif
#ifndef REG_BADESC
#define REG_BADESC	(REG_UNKNOWN-4)
#endif
#ifndef REG_EMEM
#define REG_EMEM	(REG_UNKNOWN-5)
#endif
#ifndef REG_EHUNG
#define REG_EHUNG	(REG_UNKNOWN-6)
#endif
#ifndef REG_EBUS
#define REG_EBUS	(REG_UNKNOWN-7)
#endif
#ifndef REG_EFAULT
#define REG_EFAULT	(REG_UNKNOWN-8)
#endif
#ifndef REG_EFLAGS
#define REG_EFLAGS	(REG_UNKNOWN-9)
#endif
#ifndef REG_EDELIM
#define REG_EDELIM	(REG_UNKNOWN-9)
#endif

static const struct { int code; char* name; } codes[] =
{
	REG_UNKNOWN,	"UNKNOWN",
	REG_NOMATCH,	"NOMATCH",
	REG_BADPAT,	"BADPAT",
	REG_ECOLLATE,	"ECOLLATE",
	REG_ECTYPE,	"ECTYPE",
	REG_EESCAPE,	"EESCAPE",
	REG_ESUBREG,	"ESUBREG",
	REG_EBRACK,	"EBRACK",
	REG_EPAREN,	"EPAREN",
	REG_EBRACE,	"EBRACE",
	REG_BADBR,	"BADBR",
	REG_ERANGE,	"ERANGE",
	REG_ESPACE,	"ESPACE",
	REG_BADRPT,	"BADRPT",
	REG_ENEWLINE,	"ENEWLINE",
	REG_ENULL,	"ENULL",
	REG_ECOUNT,	"ECOUNT",
	REG_BADESC,	"BADESC",
	REG_EMEM,	"EMEM",
	REG_EHUNG,	"EHUNG",
	REG_EBUS,	"EBUS",
	REG_EFAULT,	"EFAULT",
	REG_EFLAGS,	"EFLAGS",
	REG_EDELIM,	"EDELIM",
};

static struct
{
	regmatch_t	NOMATCH;
	int		errors;
	int		extracted;
	int		ignored;
	int		lineno;
	int		passed;
	int		signals;
	int		unspecified;
	int		verify;
	int		warnings;
	char*		file;
	char*		stack;
	char*		which;
	jmp_buf		gotcha;
#ifdef REG_DISCIPLINE
	Disc_t		disc;
#endif
} state;

static void
quote(char* s, int len, unsigned long test)
{
	unsigned char*	u = (unsigned char*)s;
	unsigned char*	e;
	int		c;
#ifdef MB_CUR_MAX
	int		w;
#endif

	if (!u)
		printf("NIL");
	else if (!*u && len <= 1)
		printf("NULL");
	else if (test & TEST_EXPAND)
	{
		if (len < 0)
			len = strlen((char*)u);
		e = u + len;
		if (test & TEST_DELIMIT)
			printf("\"");
		while (u < e)
			switch (c = *u++)
			{
			case '\\':
				printf("\\\\");
				break;
			case '"':
				if (test & TEST_DELIMIT)
					printf("\\\"");
				else
					printf("\"");
				break;
			case '\a':
				printf("\\a");
				break;
			case '\b':
				printf("\\b");
				break;
			case 033:
				printf("\\e");
				break;
			case '\f':
				printf("\\f");
				break;
			case '\n':
				printf("\\n");
				break;
			case '\r':
				printf("\\r");
				break;
			case '\t':
				printf("\\t");
				break;
			case '\v':
				printf("\\v");
				break;
			default:
#ifdef MB_CUR_MAX
				s = (char*)u - 1;
				if ((w = mblen(s, (char*)e - s)) > 1)
				{
					u += w - 1;
					fwrite(s, 1, w, stdout);
				}
				else
#endif
				if (!iscntrl(c) && isprint(c))
					putchar(c);
				else
					printf("\\x%02x", c);
				break;
			}
		if (test & TEST_DELIMIT)
			printf("\"");
	}
	else
		printf("%s", s);
}

static void
report(char* comment, char* fun, char* re, char* s, int len, char* msg, int flags, unsigned long test)
{
	if (state.file)
		printf("%s:", state.file);
	printf("%d:", state.lineno);
	if (re)
	{
		printf(" ");
		quote(re, -1, test|TEST_DELIMIT);
		if (s)
		{
			printf(" versus ");
			quote(s, len, test|TEST_DELIMIT);
		}
	}
	if (test & TEST_UNSPECIFIED)
	{
		state.unspecified++;
		printf(" unspecified behavior");
	}
	else
		state.errors++;
	if (state.which)
		printf(" %s", state.which);
	if (flags & REG_NOSUB)
		printf(" NOSUB");
	if (fun)
		printf(" %s", fun);
	if (comment[strlen(comment)-1] == '\n')
		printf(" %s", comment);
	else
	{
		printf(" %s: ", comment);
		if (msg)
			printf("%s: ", msg);
	}
}

static void
error(regex_t* preg, int code)
{
	char*	msg;
	char	buf[256];

	switch (code)
	{
	case REG_EBUS:
		msg = "bus error";
		break;
	case REG_EFAULT:
		msg = "memory fault";
		break;
	case REG_EHUNG:
		msg = "did not terminate";
		break;
	default:
		regerror(code, preg, msg = buf, sizeof buf);
		break;
	}
	printf("%s\n", msg);
}

static void
bad(char* comment, char* re, char* s, int len, unsigned long test)
{
	printf("bad test case ");
	report(comment, NiL, re, s, len, NiL, 0, test);
	exit(1);
}

static int
escape(char* s)
{
	char*	b;
	char*	t;
	char*	q;
	char*	e;
	int	c;

	for (b = t = s; *t = *s; s++, t++)
		if (*s == '\\')
			switch (*++s)
			{
			case '\\':
				break;
			case 'a':
				*t = '\a';
				break;
			case 'b':
				*t = '\b';
				break;
			case 'c':
				if (*t = *++s)
					*t &= 037;
				else
					s--;
				break;
			case 'e':
			case 'E':
				*t = 033;
				break;
			case 'f':
				*t = '\f';
				break;
			case 'n':
				*t = '\n';
				break;
			case 'r':
				*t = '\r';
				break;
			case 's':
				*t = ' ';
				break;
			case 't':
				*t = '\t';
				break;
			case 'v':
				*t = '\v';
				break;
			case 'u':
			case 'x':
				c = 0;
				q = c == 'u' ? (s + 5) : (char*)0;
				e = s + 1;
				while (!e || !q || s < q)
				{
					switch (*++s)
					{
					case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
						c = (c << 4) + *s - 'a' + 10;
						continue;
					case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
						c = (c << 4) + *s - 'A' + 10;
						continue;
					case '0': case '1': case '2': case '3': case '4':
					case '5': case '6': case '7': case '8': case '9':
						c = (c << 4) + *s - '0';
						continue;
					case '{':
					case '[':
						if (s != e)
						{
							s--;
							break;
						}
						e = 0;
						continue;
					case '}':
					case ']':
						if (e)
							s--;
						break;
					default:
						s--;
						break;
					}
					break;
				}
				*t = c;
				break;
			case '0': case '1': case '2': case '3':
			case '4': case '5': case '6': case '7':
				c = *s - '0';
				q = s + 2;
				while (s < q)
				{
					switch (*++s)
					{
					case '0': case '1': case '2': case '3':
					case '4': case '5': case '6': case '7':
						c = (c << 3) + *s - '0';
						break;
					default:
						q = --s;
						break;
					}
				}
				*t = c;
				break;
			default:
				*(s + 1) = 0;
				bad("invalid C \\ escape\n", s - 1, NiL, 0, 0);
			}
	return t - b;
}

static void
matchoffprint(int off)
{
	switch (off)
	{
	case -2:
		printf("X");
		break;
	case -1:
		printf("?");
		break;
	default:
		printf("%d", off);
		break;
	}
}

static void
matchprint(regmatch_t* match, int nmatch, int nsub, char* ans, unsigned long test)
{
	int	i;

	for (; nmatch > nsub + 1; nmatch--)
		if ((match[nmatch-1].rm_so != -1 || match[nmatch-1].rm_eo != -1) && (!(test & TEST_IGNORE_POSITION) || match[nmatch-1].rm_so >= 0 && match[nmatch-1].rm_eo >= 0))
			break;
	for (i = 0; i < nmatch; i++)
	{
		printf("(");
		matchoffprint(match[i].rm_so);
		printf(",");
		matchoffprint(match[i].rm_eo);
		printf(")");
	}
	if (!(test & (TEST_ACTUAL|TEST_BASELINE)))
	{
		if (ans)
			printf(" expected: %s", ans);
		printf("\n");
	}
}

static int
matchcheck(regmatch_t* match, int nmatch, int nsub, char* ans, char* re, char* s, int len, int flags, unsigned long test)
{
	char*	p;
	int	i;
	int	m;
	int	n;

	if (streq(ans, "OK"))
		return test & (TEST_BASELINE|TEST_PASS|TEST_VERIFY);
	for (i = 0, p = ans; i < nmatch && *p; i++)
	{
		if (*p == '{')
		{
#ifdef REG_DISCIPLINE
			char*	x;

			if (!(x = sfstruse(state.disc.sp)))
				bad("out of space [discipline string]\n", NiL, NiL, 0, 0);
			if (strcmp(p, x))
			{
				if (test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_QUERY|TEST_SUMMARY|TEST_VERIFY))
					return 0;
				report("callout failed", NiL, re, s, len, NiL, flags, test);
				quote(p, -1, test);
				printf(" expected, ");
				quote(x, -1, test);
				printf(" returned\n");
			}
#endif
			break;
		}
		if (*p++ != '(')
			bad("improper answer\n", re, s, -1, test);
		if (*p == '?')
		{
			m = -1;
			p++;
		}
		else if (*p == 'R' && !memcmp(p, "RE_DUP_MAX", 10))
		{
			m = RE_DUP_MAX;
			p += 10;
			if (*p == '+' || *p == '-')
				m += strtol(p, &p, 10);
		}
		else
			m = strtol(p, &p, 10);
		if (*p++ != ',')
			bad("improper answer\n", re, s, -1, test);
		if (*p == '?')
		{
			n = -1;
			p++;
		}
		else if (*p == 'R' && !memcmp(p, "RE_DUP_MAX", 10))
		{
			n = RE_DUP_MAX;
			p += 10;
			if (*p == '+' || *p == '-')
				n += strtol(p, &p, 10);
		}
		else
			n = strtol(p, &p, 10);
		if (*p++ != ')')
			bad("improper answer\n", re, s, -1, test);
		if (m!=match[i].rm_so || n!=match[i].rm_eo)
		{
			if (!(test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_QUERY|TEST_SUMMARY|TEST_VERIFY)))
			{
				report("failed: match was", NiL, re, s, len, NiL, flags, test);
				matchprint(match, nmatch, nsub, ans, test);
			}
			return 0;
		}
	}
	for (; i < nmatch; i++)
	{
		if (match[i].rm_so!=-1 || match[i].rm_eo!=-1)
		{
			if (!(test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_QUERY|TEST_VERIFY)))
			{
				if ((test & TEST_IGNORE_POSITION) && (match[i].rm_so<0 || match[i].rm_eo<0))
				{
					state.ignored++;
					return 0;
				}
				if (!(test & TEST_SUMMARY))
				{
					report("failed: match was", NiL, re, s, len, NiL, flags, test);
					matchprint(match, nmatch, nsub, ans, test);
				}
			}
			return 0;
		}
	}
	if (!(test & TEST_IGNORE_OVER) && match[nmatch].rm_so != state.NOMATCH.rm_so)
	{
		if (!(test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_QUERY|TEST_SUMMARY|TEST_VERIFY)))
		{
			report("failed: overran match array", NiL, re, s, len, NiL, flags, test);
			matchprint(match, nmatch + 1, nsub, NiL, test);
		}
		return 0;
	}
	return 1;
}

static void
sigunblock(int s)
{
#ifdef SIG_SETMASK
	int		op;
	sigset_t	mask;

	sigemptyset(&mask);
	if (s)
	{
		sigaddset(&mask, s);
		op = SIG_UNBLOCK;
	}
	else op = SIG_SETMASK;
	sigprocmask(op, &mask, NiL);
#else
#ifdef sigmask
	sigsetmask(s ? (sigsetmask(0L) & ~sigmask(s)) : 0L);
#endif
#endif
}

static void
gotcha(int sig)
{
	int	ret;

	signal(sig, gotcha);
	alarm(0);
	state.signals++;
	switch (sig)
	{
	case SIGALRM:
		ret = REG_EHUNG;
		break;
	case SIGBUS:
		ret = REG_EBUS;
		break;
	default:
		ret = REG_EFAULT;
		break;
	}
	sigunblock(sig);
	longjmp(state.gotcha, ret);
}

static char*
getline(FILE* fp)
{
	static char	buf[32 * 1024];

	register char*	s = buf;
	register char*	e = &buf[sizeof(buf)];
	register char*	b;

	for (;;)
	{
		if (!(b = fgets(s, e - s, fp)))
			return 0;
		state.lineno++;
		s += strlen(s);
		if (s == b || *--s != '\n' || s == b || *(s - 1) != '\\')
		{
			*s = 0;
			break;
		}
		s--;
	}
	return buf;
}

static unsigned long
note(unsigned long level, char* msg, unsigned long skip, unsigned long test)
{
	if (!(test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_SUMMARY)) && !skip)
	{
		printf("NOTE\t");
		if (msg)
			printf("%s: ", msg);
		printf("skipping lines %d", state.lineno);
	}
	return skip | level;
}

#define TABS(n)		&ts[7-((n)&7)]

static char		ts[] = "\t\t\t\t\t\t\t";

static unsigned long
extract(int* tabs, char* spec, char* re, char* s, char* ans, char* msg, char* accept, regmatch_t* match, int nmatch, int nsub, unsigned long skip, unsigned long level, unsigned long test)
{
	if (test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_OK|TEST_PASS|TEST_SUMMARY))
	{
		state.extracted = 1;
		if (test & TEST_OK)
		{
			state.passed++;
			if ((test & TEST_VERIFY) && !(test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_SUMMARY)))
			{
				if (msg && strcmp(msg, "EXPECTED"))
					printf("NOTE\t%s\n", msg);
				return skip;
			}
			test &= ~(TEST_PASS|TEST_QUERY);
		}
		if (test & (TEST_QUERY|TEST_VERIFY))
		{
			if (test & TEST_BASELINE)
				test &= ~(TEST_BASELINE|TEST_PASS);
			else
				test |= TEST_PASS;
			skip |= level;
		}
		if (!(test & TEST_OK))
		{
			if (test & TEST_UNSPECIFIED)
				state.unspecified++;
			else
				state.errors++;
		}
		if (test & (TEST_PASS|TEST_SUMMARY))
			return skip;
		test &= ~TEST_DELIMIT;
		printf("%s%s", spec, TABS(*tabs++));
		if ((test & (TEST_BASELINE|TEST_SAME)) == (TEST_BASELINE|TEST_SAME))
			printf("SAME");
		else
			quote(re, -1, test);
		printf("%s", TABS(*tabs++));
		quote(s, -1, test);
		printf("%s", TABS(*tabs++));
		if (!(test & (TEST_ACTUAL|TEST_BASELINE)) || !accept && !match)
			printf("%s", ans);
		else if (accept)
			printf("%s", accept);
		else
			matchprint(match, nmatch, nsub, NiL, test);
		if (msg)
			printf("%s%s", TABS(*tabs++), msg);
		putchar('\n');
	}
	else if (test & TEST_QUERY)
		skip = note(level, msg, skip, test);
	else if (test & TEST_VERIFY)
		state.extracted = 1;
	return skip;
}

static int
catchfree(regex_t* preg, int flags, int* tabs, char* spec, char* re, char* s, char* ans, char* msg, char* accept, regmatch_t* match, int nmatch, int nsub, unsigned long skip, unsigned long level, unsigned long test)
{
	int	eret;

	if (!(test & TEST_CATCH))
	{
		regfree(preg);
		eret = 0;
	}
	else if (!(eret = setjmp(state.gotcha)))
	{
		alarm(HUNG);
		regfree(preg);
		alarm(0);
	}
	else if (test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_QUERY|TEST_SUMMARY|TEST_VERIFY))
		extract(tabs, spec, re, s, ans, msg, NiL, NiL, 0, 0, skip, level, test);
	else
	{
		report("failed", "regfree", re, NiL, -1, msg, flags, test);
		error(preg, eret);
	}
	return eret;
}

static char*
expand(char* os, char* ot)
{
	char*	s = os;
	char*	t;
	int	n = 0;
	int	r;
	long	m;

	for (;;)
	{
		switch (*s++)
		{
		case 0:
			break;
		case '{':
			n++;
			continue;
		case '}':
			n--;
			continue;
		case 'R':
			if (n == 1 && !memcmp(s, "E_DUP_MAX", 9))
			{
				s--;
				for (t = ot; os < s; *t++ = *os++);
				r = ((t - ot) >= 5 && t[-1] == '{' && t[-2] == '.' && t[-3] == '.' && t[-4] == '.') ? t[-5] : 0;
				os = ot;
				m = RE_DUP_MAX;
				if (*(s += 10) == '+' || *s == '-')
					m += strtol(s, &s, 10);
				if (r)
				{
					t -= 5;
					while (m-- > 0)
						*t++ = r;
					while (*s && *s++ != '}');
				}
				else
					t += snprintf(t, 32, "%ld", m);
				while (*t = *s++)
					t++;
				break;
			}
			continue;
		default:
			continue;
		}
		break;
	}
	return os;
}

int
main(int argc, char** argv)
{
	int		flags;
	int		cflags;
	int		eflags;
	int		nmatch;
	int		nexec;
	int		nstr;
	int		cret;
	int		eret;
	int		nsub;
	int		i;
	int		j;
	int		expected;
	int		got;
	int		locale;
	int		subunitlen;
	int		testno;
	unsigned long	level;
	unsigned long	skip;
	char*		p;
	char*		line;
	char*		spec;
	char*		re;
	char*		s;
	char*		ans;
	char*		msg;
	char*		fun;
	char*		ppat;
	char*		subunit;
	char*		version;
	char*		field[6];
	char*		delim[6];
	FILE*		fp;
	int		tabs[6];
	char		unit[64];
	regmatch_t	match[100];
	regex_t		preg;

	static char	pat[32 * 1024];
	static char	patbuf[32 * 1024];
	static char	strbuf[32 * 1024];

	int		nonosub = REG_NOSUB == 0;
	int		nonexec = 0;

	unsigned long	test = 0;

	static char*	filter[] = { "-", 0 };

	state.NOMATCH.rm_so = state.NOMATCH.rm_eo = -2;
	p = unit;
	version = (char*)id + 10;
	while (p < &unit[sizeof(unit)-1] && (*p = *version++) && !isspace(*p))
		p++;
	*p = 0;
	while ((p = *++argv) && *p == '-')
		for (;;)
		{
			switch (*++p)
			{
			case 0:
				break;
			case 'c':
				test |= TEST_CATCH;
				continue;
			case 'e':
				test |= TEST_IGNORE_ERROR;
				continue;
			case 'h':
			case '?':
				help(0);
				return 2;
			case '-':
				help(p[1] == 'h');
				return 2;
			case 'n':
				nonexec = 1;
				continue;
			case 'o':
				test |= TEST_IGNORE_OVER;
				continue;
			case 'p':
				test |= TEST_IGNORE_POSITION;
				continue;
			case 's':
#ifdef REG_DISCIPLINE
				if (!(state.stack = stkalloc(stkstd, 0)))
					fprintf(stderr, "%s: out of space [stack]", unit);
				state.disc.disc.re_resizef = resizef;
				state.disc.disc.re_resizehandle = (void*)stkstd;
#endif
				continue;
			case 'x':
				nonosub = 1;
				continue;
			case 'v':
				test |= TEST_VERBOSE;
				continue;
			case 'A':
				test |= TEST_ACTUAL;
				continue;
			case 'B':
				test |= TEST_BASELINE;
				continue;
			case 'F':
				test |= TEST_FAIL;
				continue;
			case 'P':
				test |= TEST_PASS;
				continue;
			case 'S':
				test |= TEST_SUMMARY;
				continue;
			default:
				fprintf(stderr, "%s: %c: invalid option\n", unit, *p);
				return 2;
			}
			break;
		}
	if (!*argv)
		argv = filter;
	locale = 0;
	while (state.file = *argv++)
	{
		if (streq(state.file, "-") || streq(state.file, "/dev/stdin") || streq(state.file, "/dev/fd/0"))
		{
			state.file = 0;
			fp = stdin;
		}
		else if (!(fp = fopen(state.file, "r")))
		{
			fprintf(stderr, "%s: %s: cannot read\n", unit, state.file);
			return 2;
		}
		testno = state.errors = state.ignored = state.lineno = state.passed =
		state.signals = state.unspecified = state.warnings = 0;
		skip = 0;
		level = 1;
		if (!(test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_SUMMARY)))
		{
			printf("TEST\t%s ", unit);
			if (s = state.file)
			{
				subunit = p = 0;
				for (;;)
				{
					switch (*s++)
					{
					case 0:
						break;
					case '/':
						subunit = s;
						continue;
					case '.':
						p = s - 1;
						continue;
					default:
						continue;
					}
					break;
				}
				if (!subunit)
					subunit = state.file;
				if (p < subunit)
					p = s - 1;
				subunitlen = p - subunit;
				printf("%-.*s ", subunitlen, subunit);
			}
			else
				subunit = 0;
			for (s = version; *s && (*s != ' ' || *(s + 1) != '$'); s++)
				putchar(*s);
			if (test & TEST_CATCH)
				printf(", catch");
			if (test & TEST_IGNORE_ERROR)
				printf(", ignore error code mismatches");
			if (test & TEST_IGNORE_POSITION)
				printf(", ignore negative position mismatches");
#ifdef REG_DISCIPLINE
			if (state.stack)
				printf(", stack");
#endif
			if (test & TEST_VERBOSE)
				printf(", verbose");
			printf("\n");
#ifdef REG_VERSIONID
			if (regerror(REG_VERSIONID, NiL, pat, sizeof(pat)) > 0)
				s = pat;
			else
#endif
#ifdef REG_TEST_VERSION
			s = REG_TEST_VERSION;
#else
			s = "regex";
#endif
			printf("NOTE\t%s\n", s);
			if (elementsof(unsupported) > 1)
			{
#if (REG_TEST_DEFAULT & (REG_AUGMENTED|REG_EXTENDED|REG_SHELL)) || !defined(REG_EXTENDED)
				i = 0;
#else
				i = REG_EXTENDED != 0;
#endif
				for (got = 0; i < elementsof(unsupported) - 1; i++)
				{
					if (!got)
					{
						got = 1;
						printf("NOTE\tunsupported: %s", unsupported[i]);
					}
					else
						printf(",%s", unsupported[i]);
				}
				if (got)
					printf("\n");
			}
		}
#ifdef REG_DISCIPLINE
		state.disc.disc.re_version = REG_VERSION;
		state.disc.disc.re_compf = compf;
		state.disc.disc.re_execf = execf;
		if (!(state.disc.sp = sfstropen()))
			bad("out of space [discipline string stream]\n", NiL, NiL, 0, 0);
		preg.re_disc = &state.disc.disc;
#endif
		if (test & TEST_CATCH)
		{
			signal(SIGALRM, gotcha);
			signal(SIGBUS, gotcha);
			signal(SIGSEGV, gotcha);
		}
		while (p = getline(fp))
		{

		/* parse: */

			line = p;
			if (*p == ':' && !isspace(*(p + 1)))
			{
				while (*++p && *p != ':');
				if (!*p++)
				{
					if (test & TEST_BASELINE)
						printf("%s\n", line);
					continue;
				}
			}
			while (isspace(*p))
				p++;
			if (*p == 0 || *p == '#' || *p == 'T')
			{
				if (test & TEST_BASELINE)
					printf("%s\n", line);
				continue;
			}
			if (*p == ':' || *p == 'N')
			{
				if (test & TEST_BASELINE)
					printf("%s\n", line);
				else if (!(test & (TEST_ACTUAL|TEST_FAIL|TEST_PASS|TEST_SUMMARY)))
				{
					while (*++p && !isspace(*p));
					while (isspace(*p))
						p++;
					printf("NOTE	%s\n", p);
				}
				continue;
			}
			j = 0;
			i = 0;
			field[i++] = p;
			for (;;)
			{
				switch (*p++)
				{
				case 0:
					p--;
					j = 0;
					goto checkfield;
				case '\t':
					*(delim[i] = p - 1) = 0;
					j = 1;
				checkfield:
					s = field[i - 1];
					if (streq(s, "NIL"))
						field[i - 1] = 0;
					else if (streq(s, "NULL"))
						*s = 0;
					while (*p == '\t')
					{
						p++;
						j++;
					}
					tabs[i - 1] = j;
					if (!*p)
						break;
					if (i >= elementsof(field))
						bad("too many fields\n", NiL, NiL, 0, 0);
					field[i++] = p;
					/*FALLTHROUGH*/
				default:
					continue;
				}
				break;
			}
			if (!(spec = field[0]))
				bad("NIL spec\n", NiL, NiL, 0, 0);

		/* interpret: */

			cflags = REG_TEST_DEFAULT;
			eflags = REG_EXEC_DEFAULT;
			test &= TEST_GLOBAL;
			state.extracted = 0;
			nmatch = 20;
			nsub = -1;
			for (p = spec; *p; p++)
			{
				if (isdigit(*p))
				{
					nmatch = strtol(p, &p, 10);
					if (nmatch >= elementsof(match))
						bad("nmatch must be < 100\n", NiL, NiL, 0, 0);
					p--;
					continue;
				}
				switch (*p)
				{
				case 'A':
					test |= TEST_ARE;
					continue;
				case 'B':
					test |= TEST_BRE;
					continue;
				case 'C':
					if (!(test & TEST_QUERY) && !(skip & level))
						bad("locale must be nested\n", NiL, NiL, 0, 0);
					test &= ~TEST_QUERY;
					if (locale)
						bad("locale nesting not supported\n", NiL, NiL, 0, 0);
					if (i != 2)
						bad("locale field expected\n", NiL, NiL, 0, 0);
					if (!(skip & level))
					{
#if defined(LC_COLLATE) && defined(LC_CTYPE)
						s = field[1];
						if (!s || streq(s, "POSIX"))
							s = "C";
						if ((ans = setlocale(LC_COLLATE, s)) && streq(ans, "POSIX"))
							ans = "C";
						if (!ans || !streq(ans, s) && streq(s, "C"))
							ans = 0;
						else if ((ans = setlocale(LC_CTYPE, s)) && streq(ans, "POSIX"))
							ans = "C";
						if (!ans || !streq(ans, s) && streq(s, "C"))
							skip = note(level, s, skip, test);
						else
						{
							if (!(test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_SUMMARY)))
								printf("NOTE	\"%s\" locale\n", s);
							locale = level;
						}
#else
						skip = note(level, skip, test, "locales not supported");
#endif
					}
					cflags = NOTEST;
					continue;
				case 'E':
					test |= TEST_ERE;
					continue;
				case 'K':
					test |= TEST_KRE;
					continue;
				case 'L':
					test |= TEST_LRE;
					continue;
				case 'S':
					test |= TEST_SRE;
					continue;

				case 'a':
					cflags |= REG_LEFT|REG_RIGHT;
					continue;
				case 'b':
					eflags |= REG_NOTBOL;
					continue;
				case 'c':
					cflags |= REG_COMMENT;
					continue;
				case 'd':
					cflags |= REG_SHELL_DOT;
					continue;
				case 'e':
					eflags |= REG_NOTEOL;
					continue;
				case 'f':
					cflags |= REG_MULTIPLE;
					continue;
				case 'g':
					cflags |= NOTEST;
					continue;
				case 'h':
					cflags |= REG_MULTIREF;
					continue;
				case 'i':
					cflags |= REG_ICASE;
					continue;
				case 'j':
					cflags |= REG_SPAN;
					continue;
				case 'k':
					cflags |= REG_ESCAPE;
					continue;
				case 'l':
					cflags |= REG_LEFT;
					continue;
				case 'm':
					cflags |= REG_MINIMAL;
					continue;
				case 'n':
					cflags |= REG_NEWLINE;
					continue;
				case 'o':
					cflags |= REG_SHELL_GROUP;
					continue;
				case 'p':
					cflags |= REG_SHELL_PATH;
					continue;
				case 'q':
					cflags |= REG_DELIMITED;
					continue;
				case 'r':
					cflags |= REG_RIGHT;
					continue;
				case 's':
					cflags |= REG_SHELL_ESCAPED;
					continue;
				case 't':
					cflags |= REG_MUSTDELIM;
					continue;
				case 'u':
					test |= TEST_UNSPECIFIED;
					continue;
				case 'v':
					cflags |= REG_CLASS_ESCAPE;
					continue;
				case 'w':
					cflags |= REG_NOSUB;
					continue;
				case 'x':
					if (REG_LENIENT)
						cflags |= REG_LENIENT;
					else
						test |= TEST_LENIENT;
					continue;
				case 'y':
					eflags |= REG_LEFT;
					continue;
				case 'z':
					cflags |= REG_NULL;
					continue;

				case '$':
					test |= TEST_EXPAND;
					continue;

				case '/':
					test |= TEST_SUB;
					continue;

				case '=':
					test |= TEST_DECOMP;
					continue;

				case '?':
					test |= TEST_VERIFY;
					test &= ~(TEST_AND|TEST_OR);
					state.verify = state.passed;
					continue;
				case '&':
					test |= TEST_VERIFY|TEST_AND;
					test &= ~TEST_OR;
					continue;
				case '|':
					test |= TEST_VERIFY|TEST_OR;
					test &= ~TEST_AND;
					continue;
				case ';':
					test |= TEST_OR;
					test &= ~TEST_AND;
					continue;

				case '{':
					level <<= 1;
					if (skip & (level >> 1))
					{
						skip |= level;
						cflags = NOTEST;
					}
					else
					{
						skip &= ~level;
						test |= TEST_QUERY;
					}
					continue;
				case '}':
					if (level == 1)
						bad("invalid {...} nesting\n", NiL, NiL, 0, 0);
					if ((skip & level) && !(skip & (level>>1)))
					{
						if (!(test & (TEST_BASELINE|TEST_SUMMARY)))
						{
							if (test & (TEST_ACTUAL|TEST_FAIL))
								printf("}\n");
							else if (!(test & TEST_PASS))
								printf("-%d\n", state.lineno);
						}
					}
#if defined(LC_COLLATE) && defined(LC_CTYPE)
					else if (locale & level)
					{
						locale = 0;
						if (!(skip & level))
						{
							s = "C";
							setlocale(LC_COLLATE, s);
							setlocale(LC_CTYPE, s);
							if (!(test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_SUMMARY)))
								printf("NOTE	\"%s\" locale\n", s);
							else if (test & (TEST_ACTUAL|TEST_BASELINE|TEST_PASS))
								printf("}\n");
						}
						else if (test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL))
							printf("}\n");
					}
#endif
					level >>= 1;
					cflags = NOTEST;
					continue;

				default:
					bad("bad spec\n", spec, NiL, 0, test);
					break;

				}
				break;
			}
			if ((cflags|eflags) == NOTEST || (skip & level) && (test & TEST_BASELINE))
			{
				if (test & TEST_BASELINE)
				{
					while (i > 1)
						*delim[--i] = '\t';
					printf("%s\n", line);
				}
				continue;
			}
			if (test & TEST_OR)
			{
				if (!(test & TEST_VERIFY))
				{
					test &= ~TEST_OR;
					if (state.passed == state.verify && i > 1)
						printf("NOTE\t%s\n", field[1]);
					continue;
				}
				else if (state.passed > state.verify)
					continue;
			}
			else if (test & TEST_AND)
			{
				if (state.passed == state.verify)
					continue;
				state.passed = state.verify;
			}
			if (i < ((test & TEST_DECOMP) ? 3 : 4))
				bad("too few fields\n", NiL, NiL, 0, test);
			while (i < elementsof(field))
				field[i++] = 0;
			if (re = field[1])
			{
				if (streq(re, "SAME"))
				{
					re = ppat;
					test |= TEST_SAME;
				}
				else
				{
					if (test & TEST_EXPAND)
						escape(re);
					re = expand(re, patbuf);
					strcpy(ppat = pat, re);
				}
			}
			else
				ppat = 0;
			nstr = -1;
			if (s = field[2])
			{
				s = expand(s, strbuf);
				if (test & TEST_EXPAND)
				{
					nstr = escape(s);
#if _REG_nexec
					if (nstr != strlen(s))
						nexec = nstr;
#endif
				}
			}
			if (!(ans = field[(test & TEST_DECOMP) ? 2 : 3]))
				bad("NIL answer\n", NiL, NiL, 0, test);
			msg = field[4];
			fflush(stdout);
			if (test & TEST_SUB)
#if _REG_subcomp
				cflags |= REG_DELIMITED;
#else
				continue;
#endif
#if !_REG_decomp
			if (test & TEST_DECOMP)
				continue;
#endif

		compile:

			if (state.extracted || (skip & level))
				continue;
#if !(REG_TEST_DEFAULT & (REG_AUGMENTED|REG_EXTENDED|REG_SHELL))
#ifdef REG_EXTENDED
			if (REG_EXTENDED != 0 && (test & TEST_BRE))
#else
			if (test & TEST_BRE)
#endif
			{
				test &= ~TEST_BRE;
				flags = cflags;
				state.which = "BRE";
			}
			else
#endif
#ifdef REG_EXTENDED
			if (test & TEST_ERE)
			{
				test &= ~TEST_ERE;
				flags = cflags | REG_EXTENDED;
				state.which = "ERE";
			}
			else
#endif
#ifdef REG_AUGMENTED
			if (test & TEST_ARE)
			{
				test &= ~TEST_ARE;
				flags = cflags | REG_AUGMENTED;
				state.which = "ARE";
			}
			else
#endif
#ifdef REG_LITERAL
			if (test & TEST_LRE)
			{
				test &= ~TEST_LRE;
				flags = cflags | REG_LITERAL;
				state.which = "LRE";
			}
			else
#endif
#ifdef REG_SHELL
			if (test & TEST_SRE)
			{
				test &= ~TEST_SRE;
				flags = cflags | REG_SHELL;
				state.which = "SRE";
			}
			else
#ifdef REG_AUGMENTED
			if (test & TEST_KRE)
			{
				test &= ~TEST_KRE;
				flags = cflags | REG_SHELL | REG_AUGMENTED;
				state.which = "KRE";
			}
			else
#endif
#endif
			{
				if (test & (TEST_BASELINE|TEST_PASS|TEST_VERIFY))
					extract(tabs, line, re, s, ans, msg, NiL, NiL, 0, 0, skip, level, test|TEST_OK);
				continue;
			}
			if ((test & (TEST_QUERY|TEST_VERBOSE|TEST_VERIFY)) == TEST_VERBOSE)
			{
				printf("test %-3d %s ", state.lineno, state.which);
				quote(re, -1, test|TEST_DELIMIT);
				printf(" ");
				quote(s, nstr, test|TEST_DELIMIT);
				printf("\n");
			}

		nosub:
			fun = "regcomp";
#if _REG_nexec
			if (nstr >= 0 && nstr != strlen(s))
				nexec = nstr;

			else
#endif
				nexec = -1;
			if (state.extracted || (skip & level))
				continue;
			if (!(test & TEST_QUERY))
				testno++;
#ifdef REG_DISCIPLINE
			if (state.stack)
				stkset(stkstd, state.stack, 0);
			flags |= REG_DISCIPLINE;
			state.disc.ordinal = 0;
			sfstrseek(state.disc.sp, 0, SEEK_SET);
#endif
			if (!(test & TEST_CATCH))
				cret = regcomp(&preg, re, flags);
			else if (!(cret = setjmp(state.gotcha)))
			{
				alarm(HUNG);
				cret = regcomp(&preg, re, flags);
				alarm(0);
			}
#if _REG_subcomp
			if (!cret && (test & TEST_SUB))
			{
				fun = "regsubcomp";
				p = re + preg.re_npat;
				if (!(test & TEST_CATCH))
					cret = regsubcomp(&preg, p, NiL, 0, 0);
				else if (!(cret = setjmp(state.gotcha)))
				{
					alarm(HUNG);
					cret = regsubcomp(&preg, p, NiL, 0, 0);
					alarm(0);
				}
				if (!cret && *(p += preg.re_npat) && !(preg.re_sub->re_flags & REG_SUB_LAST))
				{
					if (catchfree(&preg, flags, tabs, line, re, s, ans, msg, NiL, NiL, 0, 0, skip, level, test))
						continue;
					cret = REG_EFLAGS;
				}
			}
#endif
#if _REG_decomp
			if (!cret && (test & TEST_DECOMP))
			{
				char	buf[128];

				if ((j = nmatch) > sizeof(buf))
					j = sizeof(buf);
				fun = "regdecomp";
				p = re + preg.re_npat;
				if (!(test & TEST_CATCH))
					i = regdecomp(&preg, -1, buf, j);
				else if (!(cret = setjmp(state.gotcha)))
				{
					alarm(HUNG);
					i = regdecomp(&preg, -1, buf, j);
					alarm(0);
				}
				if (!cret)
				{
					catchfree(&preg, flags, tabs, line, re, s, ans, msg, NiL, NiL, 0, 0, skip, level, test);
					if (i > j)
					{
						if (i != (strlen(ans) + 1))
						{
							report("failed", fun, re, s, nstr, msg, flags, test);
							printf(" %d byte buffer supplied, %d byte buffer required\n", j, i);
						}
					}
					else if (strcmp(buf, ans))
					{
						report("failed", fun, re, s, nstr, msg, flags, test);
						quote(ans, -1, test|TEST_DELIMIT);
						printf(" expected, ");
						quote(buf, -1, test|TEST_DELIMIT);
						printf(" returned\n");
					}
					continue;
				}
			}
#endif
			if (!cret)
			{
				if (!(flags & REG_NOSUB) && nsub < 0 && *ans == '(')
				{
					for (p = ans; *p; p++)
						if (*p == '(')
							nsub++;
						else if (*p == '{')
							nsub--;
					if (nsub >= 0)
					{
						if (test & TEST_IGNORE_OVER)
						{
							if (nmatch > nsub)
								nmatch = nsub + 1;
						}
						else if (nsub != preg.re_nsub)
						{
							if (nsub > preg.re_nsub)
							{
								if (test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_QUERY|TEST_SUMMARY|TEST_VERIFY))
									skip = extract(tabs, line, re, s, ans, msg, "OK", NiL, 0, 0, skip, level, test|TEST_DELIMIT);
								else
								{
									report("re_nsub incorrect", fun, re, NiL, -1, msg, flags, test);
									printf("at least %d expected, %d returned\n", nsub, preg.re_nsub);
									state.errors++;
								}
							}
							else
								nsub = preg.re_nsub;
						}
					}
				}
				if (!(test & (TEST_DECOMP|TEST_SUB)) && *ans && *ans != '(' && !streq(ans, "OK") && !streq(ans, "NOMATCH"))
				{
					if (test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_QUERY|TEST_SUMMARY|TEST_VERIFY))
						skip = extract(tabs, line, re, s, ans, msg, "OK", NiL, 0, 0, skip, level, test|TEST_DELIMIT);
					else if (!(test & TEST_LENIENT))
					{
						report("failed", fun, re, NiL, -1, msg, flags, test);
						printf("%s expected, OK returned\n", ans);
					}
					catchfree(&preg, flags, tabs, line, re, s, ans, msg, NiL, NiL, 0, 0, skip, level, test);
					continue;
				}
			}
			else
			{
				if (test & TEST_LENIENT)
					/* we'll let it go this time */;
				else if (!*ans || ans[0]=='(' || cret == REG_BADPAT && streq(ans, "NOMATCH"))
				{
					got = 0;
					for (i = 1; i < elementsof(codes); i++)
						if (cret==codes[i].code)
							got = i;
					if (test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_QUERY|TEST_SUMMARY|TEST_VERIFY))
						skip = extract(tabs, line, re, s, ans, msg, codes[got].name, NiL, 0, 0, skip, level, test|TEST_DELIMIT);
					else
					{
						report("failed", fun, re, NiL, -1, msg, flags, test);
						printf("%s returned: ", codes[got].name);
						error(&preg, cret);
					}
				}
				else
				{
					expected = got = 0;
					for (i = 1; i < elementsof(codes); i++)
					{
						if (streq(ans, codes[i].name))
							expected = i;
						if (cret==codes[i].code)
							got = i;
					}
					if (!expected)
					{
						if (test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_QUERY|TEST_SUMMARY|TEST_VERIFY))
							skip = extract(tabs, line, re, s, ans, msg, codes[got].name, NiL, 0, 0, skip, level, test|TEST_DELIMIT);
						else
						{
							report("failed: invalid error code", NiL, re, NiL, -1, msg, flags, test);
							printf("%s expected, %s returned\n", ans, codes[got].name);
						}
					}
					else if (cret != codes[expected].code && cret != REG_BADPAT)
					{
						if (test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_QUERY|TEST_SUMMARY|TEST_VERIFY))
							skip = extract(tabs, line, re, s, ans, msg, codes[got].name, NiL, 0, 0, skip, level, test|TEST_DELIMIT);
						else if (test & TEST_IGNORE_ERROR)
							state.ignored++;
						else
						{
							report("should fail and did", fun, re, NiL, -1, msg, flags, test);
							printf("%s expected, %s returned: ", ans, codes[got].name);
							state.errors--;
							state.warnings++;
							error(&preg, cret);
						}
					}
				}
				goto compile;
			}

#if _REG_nexec
		execute:
			if (nexec >= 0)
				fun = "regnexec";
			else
#endif
				fun = "regexec";
			
			for (i = 0; i < elementsof(match); i++)
				match[i] = state.NOMATCH;

#if _REG_nexec
			if (nexec >= 0)
			{
				eret = regnexec(&preg, s, nexec, nmatch, match, eflags);
				s[nexec] = 0;
			}
			else
#endif
			{
				if (!(test & TEST_CATCH))
					eret = regexec(&preg, s, nmatch, match, eflags);
				else if (!(eret = setjmp(state.gotcha)))
				{
					alarm(HUNG);
					eret = regexec(&preg, s, nmatch, match, eflags);
					alarm(0);
				}
			}
#if _REG_subcomp
			if ((test & TEST_SUB) && !eret)
			{
				fun = "regsubexec";
				if (!(test & TEST_CATCH))
					eret = regsubexec(&preg, s, nmatch, match);
				else if (!(eret = setjmp(state.gotcha)))
				{
					alarm(HUNG);
					eret = regsubexec(&preg, s, nmatch, match);
					alarm(0);
				}
			}
#endif
			if (flags & REG_NOSUB)
			{
				if (eret)
				{
					if (eret != REG_NOMATCH || !streq(ans, "NOMATCH"))
					{
						if (test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_QUERY|TEST_SUMMARY|TEST_VERIFY))
							skip = extract(tabs, line, re, s, ans, msg, "NOMATCH", NiL, 0, 0, skip, level, test|TEST_DELIMIT);
						else
						{
							report("REG_NOSUB failed", fun, re, s, nstr, msg, flags, test);
							error(&preg, eret);
						}
					}
				}
				else if (streq(ans, "NOMATCH"))
				{
					if (test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_QUERY|TEST_SUMMARY|TEST_VERIFY))
						skip = extract(tabs, line, re, s, ans, msg, NiL, match, nmatch, nsub, skip, level, test|TEST_DELIMIT);
					else
					{
						report("should fail and didn't", fun, re, s, nstr, msg, flags, test);
						error(&preg, eret);
					}
				}
			}
			else if (eret)
			{
				if (eret != REG_NOMATCH || !streq(ans, "NOMATCH"))
				{
					if (test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_QUERY|TEST_SUMMARY|TEST_VERIFY))
						skip = extract(tabs, line, re, s, ans, msg, "NOMATCH", NiL, 0, nsub, skip, level, test|TEST_DELIMIT);
					else
					{
						report("failed", fun, re, s, nstr, msg, flags, test);
						if (eret != REG_NOMATCH)
							error(&preg, eret);
						else if (*ans)
							printf("expected: %s\n", ans);
						else
							printf("\n");
					}
				}
			}
			else if (streq(ans, "NOMATCH"))
			{
				if (test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_QUERY|TEST_SUMMARY|TEST_VERIFY))
					skip = extract(tabs, line, re, s, ans, msg, NiL, match, nmatch, nsub, skip, level, test|TEST_DELIMIT);
				else
				{
					report("should fail and didn't", fun, re, s, nstr, msg, flags, test);
					matchprint(match, nmatch, nsub, NiL, test);
				}
			}
#if _REG_subcomp
			else if (test & TEST_SUB)
			{
				p = preg.re_sub->re_buf;
				if (strcmp(p, ans))
				{
					report("failed", fun, re, s, nstr, msg, flags, test);
					quote(ans, -1, test|TEST_DELIMIT);
					printf(" expected, ");
					quote(p, -1, test|TEST_DELIMIT);
					printf(" returned\n");
				}
			}
#endif
			else if (!*ans)
			{
				if (match[0].rm_so != state.NOMATCH.rm_so)
				{
					if (test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_QUERY|TEST_SUMMARY|TEST_VERIFY))
						skip = extract(tabs, line, re, s, ans, msg, NiL, NiL, 0, 0, skip, level, test);
					else
					{
						report("failed: no match but match array assigned", NiL, re, s, nstr, msg, flags, test);
						matchprint(match, nmatch, nsub, NiL, test);
					}
				}
			}
			else if (matchcheck(match, nmatch, nsub, ans, re, s, nstr, flags, test))
			{
#if _REG_nexec
				if (nexec < 0 && !nonexec)
				{
					nexec = nstr >= 0 ? nstr : strlen(s);
					s[nexec] = '\n';
					testno++;
					goto execute;
				}
#endif
				if (!(test & (TEST_DECOMP|TEST_SUB|TEST_VERIFY)) && !nonosub)
				{
					if (catchfree(&preg, flags, tabs, line, re, s, ans, msg, NiL, NiL, 0, 0, skip, level, test))
						continue;
					flags |= REG_NOSUB;
					goto nosub;
				}
				if (test & (TEST_BASELINE|TEST_PASS|TEST_VERIFY))
					skip = extract(tabs, line, re, s, ans, msg, NiL, match, nmatch, nsub, skip, level, test|TEST_OK);
			}
			else if (test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS|TEST_QUERY|TEST_SUMMARY|TEST_VERIFY))
				skip = extract(tabs, line, re, s, ans, msg, NiL, match, nmatch, nsub, skip, level, test|TEST_DELIMIT);
			if (catchfree(&preg, flags, tabs, line, re, s, ans, msg, NiL, NiL, 0, 0, skip, level, test))
				continue;
			goto compile;
		}
		if (test & TEST_SUMMARY)
			printf("tests=%-4d errors=%-4d warnings=%-2d ignored=%-2d unspecified=%-2d signals=%d\n", testno, state.errors, state.warnings, state.ignored, state.unspecified, state.signals);
		else if (!(test & (TEST_ACTUAL|TEST_BASELINE|TEST_FAIL|TEST_PASS)))
		{
			printf("TEST\t%s", unit);
			if (subunit)
				printf(" %-.*s", subunitlen, subunit);
			printf(", %d test%s", testno, testno == 1 ? "" : "s");
			if (state.ignored)
				printf(", %d ignored mismatche%s", state.ignored, state.ignored == 1 ? "" : "s");
			if (state.warnings)
				printf(", %d warning%s", state.warnings, state.warnings == 1 ? "" : "s");
			if (state.unspecified)
				printf(", %d unspecified difference%s", state.unspecified, state.unspecified == 1 ? "" : "s");
			if (state.signals)
				printf(", %d signal%s", state.signals, state.signals == 1 ? "" : "s");
			printf(", %d error%s\n", state.errors, state.errors == 1 ? "" : "s");
		}
		if (fp != stdin)
			fclose(fp);
	}
	return 0;
}
                                                                                                                                                                   root/go1.4/src/run.bash                                                                             0100755 0000000 0000000 00000017540 12600426227 013325  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/usr/bin/env bash
# Copyright 2009 The Go Authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

set -e

eval $(go env)
export GOROOT   # the api test requires GOROOT to be set.

unset CDPATH	# in case user has it set
unset GOPATH    # we disallow local import for non-local packages, if $GOROOT happens
                # to be under $GOPATH, then some tests below will fail

# no core files, please
ulimit -c 0

# Raise soft limits to hard limits for NetBSD/OpenBSD.
# We need at least 256 files and ~300 MB of bss.
# On OS X ulimit -S -n rejects 'unlimited'.
#
# Note that ulimit -S -n may fail if ulimit -H -n is set higher than a
# non-root process is allowed to set the high limit.
# This is a system misconfiguration and should be fixed on the
# broken system, not "fixed" by ignoring the failure here.
# See longer discussion on golang.org/issue/7381. 
[ "$(ulimit -H -n)" == "unlimited" ] || ulimit -S -n $(ulimit -H -n)
[ "$(ulimit -H -d)" == "unlimited" ] || ulimit -S -d $(ulimit -H -d)

# Thread count limit on NetBSD 7.
if ulimit -T &> /dev/null; then
	[ "$(ulimit -H -T)" == "unlimited" ] || ulimit -S -T $(ulimit -H -T)
fi

# allow all.bash to avoid double-build of everything
rebuild=true
if [ "$1" == "--no-rebuild" ]; then
	shift
else
	echo '# Building packages and commands.'
	time go install -a -v std
	echo
fi

# we must unset GOROOT_FINAL before tests, because runtime/debug requires
# correct access to source code, so if we have GOROOT_FINAL in effect,
# at least runtime/debug test will fail.
unset GOROOT_FINAL

# increase timeout for ARM up to 3 times the normal value
timeout_scale=1
[ "$GOARCH" == "arm" ] && timeout_scale=3

echo '# Testing packages.'
time go test std -short -timeout=$(expr 120 \* $timeout_scale)s -gcflags "$GO_GCFLAGS"
echo

# We set GOMAXPROCS=2 in addition to -cpu=1,2,4 in order to test runtime bootstrap code,
# creation of first goroutines and first garbage collections in the parallel setting.
echo '# GOMAXPROCS=2 runtime -cpu=1,2,4'
GOMAXPROCS=2 go test runtime -short -timeout=$(expr 300 \* $timeout_scale)s -cpu=1,2,4
echo

echo '# sync -cpu=10'
go test sync -short -timeout=$(expr 120 \* $timeout_scale)s -cpu=10

xcd() {
	echo
	echo '#' $1
	builtin cd "$GOROOT"/src/$1 || exit 1
}

# NOTE: "set -e" cannot help us in subshells. It works until you test it with ||.
#
#	$ bash --version
#	GNU bash, version 3.2.48(1)-release (x86_64-apple-darwin12)
#	Copyright (C) 2007 Free Software Foundation, Inc.
#
#	$ set -e; (set -e; false; echo still here); echo subshell exit status $?
#	subshell exit status 1
#	# subshell stopped early, set exit status, but outer set -e didn't stop.
#
#	$ set -e; (set -e; false; echo still here) || echo stopped
#	still here
#	# somehow the '|| echo stopped' broke the inner set -e.
#	
# To avoid this bug, every command in a subshell should have '|| exit 1' on it.
# Strictly speaking, the test may be unnecessary on the final command of
# the subshell, but it aids later editing and may avoid future bash bugs.

if [ "$GOOS" == "android" ]; then
	# Disable cgo tests on android.
	# They are not designed to run off the host.
	# golang.org/issue/8345
	CGO_ENABLED=0
fi

[ "$CGO_ENABLED" != 1 ] ||
[ "$GOHOSTOS" == windows ] ||
(xcd ../misc/cgo/stdio
go run $GOROOT/test/run.go - . || exit 1
) || exit $?

[ "$CGO_ENABLED" != 1 ] ||
(xcd ../misc/cgo/life
go run $GOROOT/test/run.go - . || exit 1
) || exit $?

[ "$CGO_ENABLED" != 1 ] ||
(xcd ../misc/cgo/test
# cgo tests inspect the traceback for runtime functions
extlink=0
export GOTRACEBACK=2
go test -ldflags '-linkmode=auto' || exit 1
# linkmode=internal fails on dragonfly since errno is a TLS relocation.
[ "$GOHOSTOS" == dragonfly ] || go test -ldflags '-linkmode=internal' || exit 1
case "$GOHOSTOS-$GOARCH" in
openbsd-386 | openbsd-amd64)
	# test linkmode=external, but __thread not supported, so skip testtls.
	go test -ldflags '-linkmode=external' || exit 1
	extlink=1
	;;
darwin-386 | darwin-amd64)
	# linkmode=external fails on OS X 10.6 and earlier == Darwin
	# 10.8 and earlier.
	case $(uname -r) in
	[0-9].* | 10.*) ;;
	*)
		go test -ldflags '-linkmode=external'  || exit 1
		extlink=1
		;;
	esac
	;;
android-arm | dragonfly-386 | dragonfly-amd64 | freebsd-386 | freebsd-amd64 | freebsd-arm | linux-386 | linux-amd64 | linux-arm | netbsd-386 | netbsd-amd64)
	go test -ldflags '-linkmode=external' || exit 1
	go test -ldflags '-linkmode=auto' ../testtls || exit 1
	go test -ldflags '-linkmode=external' ../testtls || exit 1
	extlink=1
	
	case "$GOHOSTOS-$GOARCH" in
	netbsd-386 | netbsd-amd64) ;; # no static linking
	freebsd-arm) ;; # -fPIC compiled tls code will use __tls_get_addr instead
	                # of __aeabi_read_tp, however, on FreeBSD/ARM, __tls_get_addr
	                # is implemented in rtld-elf, so -fPIC isn't compatible with
	                # static linking on FreeBSD/ARM with clang. (cgo depends on
			# -fPIC fundamentally.)
	*)
		if ! $CC -xc -o /dev/null -static - 2>/dev/null <<<'int main() {}' ; then
			echo "No support for static linking found (lacks libc.a?), skip cgo static linking test."
		else
			go test -ldflags '-linkmode=external -extldflags "-static -pthread"' ../testtls || exit 1
			go test ../nocgo || exit 1
			go test -ldflags '-linkmode=external' ../nocgo || exit 1
			go test -ldflags '-linkmode=external -extldflags "-static -pthread"' ../nocgo || exit 1
		fi
		;;
	esac
	;;
esac
) || exit $?

# Race detector only supported on Linux, FreeBSD and OS X,
# and only on amd64, and only when cgo is enabled.
# Delayed until here so we know whether to try external linking.
case "$GOHOSTOS-$GOOS-$GOARCH-$CGO_ENABLED" in
linux-linux-amd64-1 | freebsd-freebsd-amd64-1 | darwin-darwin-amd64-1)
	echo
	echo '# Testing race detector.'
	go test -race -i runtime/race flag os/exec
	go test -race -run=Output runtime/race
	go test -race -short flag os/exec
	
	# Test with external linking; see issue 9133.
	if [ "$extlink" = 1 ]; then
		go test -race -short -ldflags=-linkmode=external flag os/exec
	fi
esac

# This tests cgo -cdefs. That mode is not supported,
# so it's okay if it doesn't work on some systems.
# In particular, it works badly with clang on OS X.
# It doesn't work at all now that we disallow C code
# outside runtime. Once runtime has no C code it won't
# even be necessary.
# [ "$CGO_ENABLED" != 1 ] || [ "$GOOS" == darwin ] ||
# (xcd ../misc/cgo/testcdefs
# ./test.bash || exit 1
# ) || exit $?

[ "$CGO_ENABLED" != 1 ] || [ "$GOOS" == darwin ] ||
(xcd ../misc/cgo/testgodefs
./test.bash || exit 1
) || exit $?

[ "$CGO_ENABLED" != 1 ] ||
[ "$GOHOSTOS" == windows ] ||
(xcd ../misc/cgo/testso
./test.bash || exit 1
) || exit $?

[ "$CGO_ENABLED" != 1 ] ||
[ "$GOHOSTOS-$GOARCH" != linux-amd64 ] ||
(xcd ../misc/cgo/testasan
go run main.go || exit 1
) || exit $?

[ "$CGO_ENABLED" != 1 ] ||
[ "$GOHOSTOS" == windows ] ||
(xcd ../misc/cgo/errors
./test.bash || exit 1
) || exit $?

[ "$GOOS" == nacl ] ||
[ "$GOOS" == android ] ||
(xcd ../doc/progs
time ./run || exit 1
) || exit $?

[ "$GOOS" == android ] ||
[ "$GOOS" == nacl ] ||
[ "$GOARCH" == arm ] ||  # uses network, fails under QEMU
(xcd ../doc/articles/wiki
./test.bash || exit 1
) || exit $?

[ "$GOOS" == android ] ||
[ "$GOOS" == nacl ] ||
(xcd ../doc/codewalk
time ./run || exit 1
) || exit $?

[ "$GOOS" == nacl ] ||
[ "$GOARCH" == arm ] ||
(xcd ../test/bench/shootout
time ./timing.sh -test || exit 1
) || exit $?

[ "$GOOS" == android ] || # TODO(crawshaw): get this working
[ "$GOOS" == openbsd ] || # golang.org/issue/5057
(
echo
echo '#' ../test/bench/go1
go test ../test/bench/go1 || exit 1
) || exit $?

[ "$GOOS" == android ] ||
(xcd ../test
unset GOMAXPROCS
GOOS=$GOHOSTOS GOARCH=$GOHOSTARCH go build -o runtest run.go || exit 1
time ./runtest || exit 1
rm -f runtest
) || exit $?

[ "$GOOS" == android ] ||
[ "$GOOS" == nacl ] ||
(
echo
echo '# Checking API compatibility.'
time go run $GOROOT/src/cmd/api/run.go || exit 1
) || exit $?

echo
echo ALL TESTS PASSED
                                                                                                                                                                root/go1.4/src/run.bat                                                                              0100644 0000000 0000000 00000006222 12600426227 013146  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        :: Copyright 2012 The Go Authors. All rights reserved.
:: Use of this source code is governed by a BSD-style
:: license that can be found in the LICENSE file.
@echo off

:: Keep environment variables within this script
:: unless invoked with --no-local.
if x%1==x--no-local goto nolocal
if x%2==x--no-local goto nolocal
setlocal
:nolocal

set GOBUILDFAIL=0

:: we disallow local import for non-local packages, if %GOROOT% happens
:: to be under %GOPATH%, then some tests below will fail
set GOPATH=

rem TODO avoid rebuild if possible

if x%1==x--no-rebuild goto norebuild
echo # Building packages and commands.
go install -a -v std
if errorlevel 1 goto fail
echo.
:norebuild

:: we must unset GOROOT_FINAL before tests, because runtime/debug requires
:: correct access to source code, so if we have GOROOT_FINAL in effect,
:: at least runtime/debug test will fail.
set GOROOT_FINAL=

:: get CGO_ENABLED
go env > env.bat
if errorlevel 1 goto fail
call env.bat
del env.bat
echo.

echo # Testing packages.
go test std -short -timeout=120s
if errorlevel 1 goto fail
echo.

set OLDGOMAXPROCS=%GOMAXPROCS%

:: We set GOMAXPROCS=2 in addition to -cpu=1,2,4 in order to test runtime bootstrap code,
:: creation of first goroutines and first garbage collections in the parallel setting.
echo # GOMAXPROCS=2 runtime -cpu=1,2,4
set GOMAXPROCS=2
go test runtime -short -timeout=300s -cpu=1,2,4
if errorlevel 1 goto fail
echo.

set GOMAXPROCS=%OLDGOMAXPROCS%
set OLDGOMAXPROCS=

echo # sync -cpu=10
go test sync -short -timeout=120s -cpu=10
if errorlevel 1 goto fail
echo.

:: Race detector only supported on Linux and OS X,
:: and only on amd64, and only when cgo is enabled.
if not "%GOHOSTOS%-%GOOS%-%GOARCH%-%CGO_ENABLED%" == "windows-windows-amd64-1" goto norace
echo # Testing race detector.
go test -race -i runtime/race flag
if errorlevel 1 goto fail
go test -race -run=Output runtime/race
if errorlevel 1 goto fail
go test -race -short flag
if errorlevel 1 goto fail
echo.
:norace

echo # ..\test\bench\go1
go test ..\test\bench\go1
if errorlevel 1 goto fail
echo.

:: cgo tests
if x%CGO_ENABLED% == x0 goto nocgo
echo # ..\misc\cgo\life
go run "%GOROOT%\test\run.go" - ..\misc\cgo\life
if errorlevel 1 goto fail
echo.

echo # ..\misc\cgo\stdio
go run "%GOROOT%\test\run.go" - ..\misc\cgo\stdio
if errorlevel 1 goto fail
echo.

:: cgo tests inspect the traceback for runtime functions
set OLDGOTRACEBACK=%GOTRACEBACK%
set GOTRACEBACK=2

echo # ..\misc\cgo\test
go test ..\misc\cgo\test
if errorlevel 1 goto fail
echo.

set GOTRACEBACK=%OLDGOTRACEBACK%
set OLDGOTRACEBACK=

echo # ..\misc\cgo\testso
cd ..\misc\cgo\testso
set FAIL=0
call test.bat
cd ..\..\..\src
if %FAIL%==1 goto fail
echo.
:nocgo

echo # ..\doc\progs
go run "%GOROOT%\test\run.go" - ..\doc\progs
if errorlevel 1 goto fail
echo.

:: TODO: The other tests in run.bash.


set OLDGOMAXPROCS=%GOMAXPROCS%

echo # ..\test
cd ..\test
set FAIL=0
set GOMAXPROCS=
go run run.go
if errorlevel 1 set FAIL=1
cd ..\src
echo.
if %FAIL%==1 goto fail

set GOMAXPROCS=%OLDGOMAXPROCS%
set OLDGOMAXPROCS=

echo # Checking API compatibility.
go run "%GOROOT%\src\cmd\api\run.go"
if errorlevel 1 goto fail
echo.

echo ALL TESTS PASSED
goto end

:fail
set GOBUILDFAIL=1

:end
                                                                                                                                                                                                                                                                                                                                                                              root/go1.4/src/run.rc                                                                               0100755 0000000 0000000 00000002634 12600426227 013012  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #!/bin/rc -e
# Copyright 2012 The Go Authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

rfork e

eval `{go env}

GOPATH = () # we disallow local import for non-local packages, if $GOROOT happens
            # to be under $GOPATH, then some tests below will fail

# allow all.rc to avoid double-build of everything
rebuild = true
if(~ $1 --no-rebuild)
	shift
if not {
	# Run only one process at a time on 9vx.
	if(~ $sysname vx32)
		pflag = (-p 1)
	echo '# Building packages and commands.'
	time go install -a -v $pflag std
	echo
}

# we must unset GOROOT_FINAL before tests, because runtime/debug requires
# correct access to source code, so if we have GOROOT_FINAL in effect,
# at least runtime/debug test will fail.
GOROOT_FINAL = ()

echo '# Testing packages.'
time go test std -short -timeout 120s
echo

# We set GOMAXPROCS=2 in addition to -cpu=1,2,4 in order to test runtime bootstrap code,
# creation of first goroutines and first garbage collections in the parallel setting.
echo '# GOMAXPROCS=2 runtime -cpu=1,2,4'
GOMAXPROCS=2 go test runtime -short -timeout 240s -cpu 1,2,4
echo

echo '# sync -cpu=10'
go test sync -short -timeout 120s -cpu 10
echo

fn xcd {
	echo
	echo '#' $1
	cd $"GOROOT/src/$1
}

echo
echo '#' ../test/bench/go1
go test ../test/bench/go1

@{
	xcd ../test
	GOMAXPROCS='' time go run run.go -v
}

echo
echo ALL TESTS PASSED
                                                                                                    root/go1.4/src/runtime/                                                                             0040755 0000000 0000000 00000000000 12600426332 013333  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/runtime/Makefile                                                                     0100644 0000000 0000000 00000000262 12600426227 014773  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Copyright 2009 The Go Authors. All rights reserved.
# Use of this source code is governed by a BSD-style
# license that can be found in the LICENSE file.

include ../Make.dist
                                                                                                                                                                                                                                                                                                                                              root/go1.4/src/runtime/alg.go                                                                       0100644 0000000 0000000 00000021445 12600426227 014433  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package runtime

import "unsafe"

const (
	c0 = uintptr((8-ptrSize)/4*2860486313 + (ptrSize-4)/4*33054211828000289)
	c1 = uintptr((8-ptrSize)/4*3267000013 + (ptrSize-4)/4*23344194077549503)
)

// type algorithms - known to compiler
const (
	alg_MEM = iota
	alg_MEM0
	alg_MEM8
	alg_MEM16
	alg_MEM32
	alg_MEM64
	alg_MEM128
	alg_NOEQ
	alg_NOEQ0
	alg_NOEQ8
	alg_NOEQ16
	alg_NOEQ32
	alg_NOEQ64
	alg_NOEQ128
	alg_STRING
	alg_INTER
	alg_NILINTER
	alg_SLICE
	alg_FLOAT32
	alg_FLOAT64
	alg_CPLX64
	alg_CPLX128
	alg_max
)

type typeAlg struct {
	// function for hashing objects of this type
	// (ptr to object, size, seed) -> hash
	hash func(unsafe.Pointer, uintptr, uintptr) uintptr
	// function for comparing objects of this type
	// (ptr to object A, ptr to object B, size) -> ==?
	equal func(unsafe.Pointer, unsafe.Pointer, uintptr) bool
}

var algarray = [alg_max]typeAlg{
	alg_MEM:      {memhash, memequal},
	alg_MEM0:     {memhash, memequal0},
	alg_MEM8:     {memhash, memequal8},
	alg_MEM16:    {memhash, memequal16},
	alg_MEM32:    {memhash, memequal32},
	alg_MEM64:    {memhash, memequal64},
	alg_MEM128:   {memhash, memequal128},
	alg_NOEQ:     {nil, nil},
	alg_NOEQ0:    {nil, nil},
	alg_NOEQ8:    {nil, nil},
	alg_NOEQ16:   {nil, nil},
	alg_NOEQ32:   {nil, nil},
	alg_NOEQ64:   {nil, nil},
	alg_NOEQ128:  {nil, nil},
	alg_STRING:   {strhash, strequal},
	alg_INTER:    {interhash, interequal},
	alg_NILINTER: {nilinterhash, nilinterequal},
	alg_SLICE:    {nil, nil},
	alg_FLOAT32:  {f32hash, f32equal},
	alg_FLOAT64:  {f64hash, f64equal},
	alg_CPLX64:   {c64hash, c64equal},
	alg_CPLX128:  {c128hash, c128equal},
}

const nacl = GOOS == "nacl"

var useAeshash bool

// in asm_*.s
func aeshash(p unsafe.Pointer, s, h uintptr) uintptr
func aeshash32(p unsafe.Pointer, s, h uintptr) uintptr
func aeshash64(p unsafe.Pointer, s, h uintptr) uintptr
func aeshashstr(p unsafe.Pointer, s, h uintptr) uintptr

func memhash(p unsafe.Pointer, s, h uintptr) uintptr {
	if !nacl && useAeshash {
		return aeshash(p, s, h)
	}

	h ^= c0
	for s > 0 {
		h = (h ^ uintptr(*(*byte)(p))) * c1
		p = add(p, 1)
		s--
	}
	return h
}

func strhash(a unsafe.Pointer, s, h uintptr) uintptr {
	return memhash((*stringStruct)(a).str, uintptr(len(*(*string)(a))), h)
}

// NOTE: Because NaN != NaN, a map can contain any
// number of (mostly useless) entries keyed with NaNs.
// To avoid long hash chains, we assign a random number
// as the hash value for a NaN.

func f32hash(p unsafe.Pointer, s, h uintptr) uintptr {
	f := *(*float32)(p)
	switch {
	case f == 0:
		return c1 * (c0 ^ h) // +0, -0
	case f != f:
		return c1 * (c0 ^ h ^ uintptr(fastrand1())) // any kind of NaN
	default:
		return memhash(p, 4, h)
	}
}

func f64hash(p unsafe.Pointer, s, h uintptr) uintptr {
	f := *(*float64)(p)
	switch {
	case f == 0:
		return c1 * (c0 ^ h) // +0, -0
	case f != f:
		return c1 * (c0 ^ h ^ uintptr(fastrand1())) // any kind of NaN
	default:
		return memhash(p, 8, h)
	}
}

func c64hash(p unsafe.Pointer, s, h uintptr) uintptr {
	x := (*[2]float32)(p)
	return f32hash(unsafe.Pointer(&x[1]), 4, f32hash(unsafe.Pointer(&x[0]), 4, h))
}

func c128hash(p unsafe.Pointer, s, h uintptr) uintptr {
	x := (*[2]float64)(p)
	return f64hash(unsafe.Pointer(&x[1]), 8, f64hash(unsafe.Pointer(&x[0]), 8, h))
}

func interhash(p unsafe.Pointer, s, h uintptr) uintptr {
	a := (*iface)(p)
	tab := a.tab
	if tab == nil {
		return h
	}
	t := tab._type
	fn := goalg(t.alg).hash
	if fn == nil {
		panic(errorString("hash of unhashable type " + *t._string))
	}
	if isDirectIface(t) {
		return c1 * fn(unsafe.Pointer(&a.data), uintptr(t.size), h^c0)
	} else {
		return c1 * fn(a.data, uintptr(t.size), h^c0)
	}
}

func nilinterhash(p unsafe.Pointer, s, h uintptr) uintptr {
	a := (*eface)(p)
	t := a._type
	if t == nil {
		return h
	}
	fn := goalg(t.alg).hash
	if fn == nil {
		panic(errorString("hash of unhashable type " + *t._string))
	}
	if isDirectIface(t) {
		return c1 * fn(unsafe.Pointer(&a.data), uintptr(t.size), h^c0)
	} else {
		return c1 * fn(a.data, uintptr(t.size), h^c0)
	}
}

func memequal(p, q unsafe.Pointer, size uintptr) bool {
	if p == q {
		return true
	}
	return memeq(p, q, size)
}

func memequal0(p, q unsafe.Pointer, size uintptr) bool {
	return true
}
func memequal8(p, q unsafe.Pointer, size uintptr) bool {
	return *(*int8)(p) == *(*int8)(q)
}
func memequal16(p, q unsafe.Pointer, size uintptr) bool {
	return *(*int16)(p) == *(*int16)(q)
}
func memequal32(p, q unsafe.Pointer, size uintptr) bool {
	return *(*int32)(p) == *(*int32)(q)
}
func memequal64(p, q unsafe.Pointer, size uintptr) bool {
	return *(*int64)(p) == *(*int64)(q)
}
func memequal128(p, q unsafe.Pointer, size uintptr) bool {
	return *(*[2]int64)(p) == *(*[2]int64)(q)
}
func f32equal(p, q unsafe.Pointer, size uintptr) bool {
	return *(*float32)(p) == *(*float32)(q)
}
func f64equal(p, q unsafe.Pointer, size uintptr) bool {
	return *(*float64)(p) == *(*float64)(q)
}
func c64equal(p, q unsafe.Pointer, size uintptr) bool {
	return *(*complex64)(p) == *(*complex64)(q)
}
func c128equal(p, q unsafe.Pointer, size uintptr) bool {
	return *(*complex128)(p) == *(*complex128)(q)
}
func strequal(p, q unsafe.Pointer, size uintptr) bool {
	return *(*string)(p) == *(*string)(q)
}
func interequal(p, q unsafe.Pointer, size uintptr) bool {
	return ifaceeq(*(*interface {
		f()
	})(p), *(*interface {
		f()
	})(q))
}
func nilinterequal(p, q unsafe.Pointer, size uintptr) bool {
	return efaceeq(*(*interface{})(p), *(*interface{})(q))
}
func efaceeq(p, q interface{}) bool {
	x := (*eface)(unsafe.Pointer(&p))
	y := (*eface)(unsafe.Pointer(&q))
	t := x._type
	if t != y._type {
		return false
	}
	if t == nil {
		return true
	}
	eq := goalg(t.alg).equal
	if eq == nil {
		panic(errorString("comparing uncomparable type " + *t._string))
	}
	if isDirectIface(t) {
		return eq(noescape(unsafe.Pointer(&x.data)), noescape(unsafe.Pointer(&y.data)), uintptr(t.size))
	}
	return eq(x.data, y.data, uintptr(t.size))
}
func ifaceeq(p, q interface {
	f()
}) bool {
	x := (*iface)(unsafe.Pointer(&p))
	y := (*iface)(unsafe.Pointer(&q))
	xtab := x.tab
	if xtab != y.tab {
		return false
	}
	if xtab == nil {
		return true
	}
	t := xtab._type
	eq := goalg(t.alg).equal
	if eq == nil {
		panic(errorString("comparing uncomparable type " + *t._string))
	}
	if isDirectIface(t) {
		return eq(noescape(unsafe.Pointer(&x.data)), noescape(unsafe.Pointer(&y.data)), uintptr(t.size))
	}
	return eq(x.data, y.data, uintptr(t.size))
}

// Testing adapters for hash quality tests (see hash_test.go)
func haveGoodHash() bool {
	return useAeshash
}

func stringHash(s string, seed uintptr) uintptr {
	return algarray[alg_STRING].hash(noescape(unsafe.Pointer(&s)), unsafe.Sizeof(s), seed)
}

func bytesHash(b []byte, seed uintptr) uintptr {
	s := (*sliceStruct)(unsafe.Pointer(&b))
	return algarray[alg_MEM].hash(s.array, uintptr(s.len), seed)
}

func int32Hash(i uint32, seed uintptr) uintptr {
	return algarray[alg_MEM32].hash(noescape(unsafe.Pointer(&i)), 4, seed)
}

func int64Hash(i uint64, seed uintptr) uintptr {
	return algarray[alg_MEM64].hash(noescape(unsafe.Pointer(&i)), 8, seed)
}

func efaceHash(i interface{}, seed uintptr) uintptr {
	return algarray[alg_NILINTER].hash(noescape(unsafe.Pointer(&i)), unsafe.Sizeof(i), seed)
}

func ifaceHash(i interface {
	F()
}, seed uintptr) uintptr {
	return algarray[alg_INTER].hash(noescape(unsafe.Pointer(&i)), unsafe.Sizeof(i), seed)
}

// Testing adapter for memclr
func memclrBytes(b []byte) {
	s := (*sliceStruct)(unsafe.Pointer(&b))
	memclr(s.array, uintptr(s.len))
}

// TODO(dvyukov): remove when Type is converted to Go and contains *typeAlg.
func goalg(a unsafe.Pointer) *typeAlg {
	return (*typeAlg)(a)
}

// used in asm_{386,amd64}.s
const hashRandomBytes = 32

var aeskeysched [hashRandomBytes]byte

//go:noescape
func get_random_data(rnd *unsafe.Pointer, n *int32)

func init() {
	if theGoos == "nacl" {
		return
	}

	// Install aes hash algorithm if we have the instructions we need
	if (cpuid_ecx&(1<<25)) != 0 && // aes (aesenc)
		(cpuid_ecx&(1<<9)) != 0 && // sse3 (pshufb)
		(cpuid_ecx&(1<<19)) != 0 { // sse4.1 (pinsr{d,q})
		useAeshash = true
		algarray[alg_MEM].hash = aeshash
		algarray[alg_MEM8].hash = aeshash
		algarray[alg_MEM16].hash = aeshash
		algarray[alg_MEM32].hash = aeshash32
		algarray[alg_MEM64].hash = aeshash64
		algarray[alg_MEM128].hash = aeshash
		algarray[alg_STRING].hash = aeshashstr
		// Initialize with random data so hash collisions will be hard to engineer.
		var rnd unsafe.Pointer
		var n int32
		get_random_data(&rnd, &n)
		if n > hashRandomBytes {
			n = hashRandomBytes
		}
		memmove(unsafe.Pointer(&aeskeysched[0]), rnd, uintptr(n))
		if n < hashRandomBytes {
			// Not very random, but better than nothing.
			for t := nanotime(); n < hashRandomBytes; n++ {
				aeskeysched[n] = byte(t >> uint(8*(n%8)))
			}
		}
	}
}
                                                                                                                                                                                                                           root/go1.4/src/runtime/append_test.go                                                               0100644 0000000 0000000 00000010555 12600426227 016176  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
package runtime_test

import "testing"

const N = 20

func BenchmarkAppend(b *testing.B) {
	b.StopTimer()
	x := make([]int, 0, N)
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		x = x[0:0]
		for j := 0; j < N; j++ {
			x = append(x, j)
		}
	}
}

func BenchmarkAppendGrowByte(b *testing.B) {
	for i := 0; i < b.N; i++ {
		var x []byte
		for j := 0; j < 1<<20; j++ {
			x = append(x, byte(j))
		}
	}
}

func BenchmarkAppendGrowString(b *testing.B) {
	var s string
	for i := 0; i < b.N; i++ {
		var x []string
		for j := 0; j < 1<<20; j++ {
			x = append(x, s)
		}
	}
}

func benchmarkAppendBytes(b *testing.B, length int) {
	b.StopTimer()
	x := make([]byte, 0, N)
	y := make([]byte, length)
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		x = x[0:0]
		x = append(x, y...)
	}
}

func BenchmarkAppend1Byte(b *testing.B) {
	benchmarkAppendBytes(b, 1)
}

func BenchmarkAppend4Bytes(b *testing.B) {
	benchmarkAppendBytes(b, 4)
}

func BenchmarkAppend7Bytes(b *testing.B) {
	benchmarkAppendBytes(b, 7)
}

func BenchmarkAppend8Bytes(b *testing.B) {
	benchmarkAppendBytes(b, 8)
}

func BenchmarkAppend15Bytes(b *testing.B) {
	benchmarkAppendBytes(b, 15)
}

func BenchmarkAppend16Bytes(b *testing.B) {
	benchmarkAppendBytes(b, 16)
}

func BenchmarkAppend32Bytes(b *testing.B) {
	benchmarkAppendBytes(b, 32)
}

func benchmarkAppendStr(b *testing.B, str string) {
	b.StopTimer()
	x := make([]byte, 0, N)
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		x = x[0:0]
		x = append(x, str...)
	}
}

func BenchmarkAppendStr1Byte(b *testing.B) {
	benchmarkAppendStr(b, "1")
}

func BenchmarkAppendStr4Bytes(b *testing.B) {
	benchmarkAppendStr(b, "1234")
}

func BenchmarkAppendStr8Bytes(b *testing.B) {
	benchmarkAppendStr(b, "12345678")
}

func BenchmarkAppendStr16Bytes(b *testing.B) {
	benchmarkAppendStr(b, "1234567890123456")
}

func BenchmarkAppendStr32Bytes(b *testing.B) {
	benchmarkAppendStr(b, "12345678901234567890123456789012")
}

func BenchmarkAppendSpecialCase(b *testing.B) {
	b.StopTimer()
	x := make([]int, 0, N)
	b.StartTimer()
	for i := 0; i < b.N; i++ {
		x = x[0:0]
		for j := 0; j < N; j++ {
			if len(x) < cap(x) {
				x = x[:len(x)+1]
				x[len(x)-1] = j
			} else {
				x = append(x, j)
			}
		}
	}
}

var x []int

func f() int {
	x[:1][0] = 3
	return 2
}

func TestSideEffectOrder(t *testing.T) {
	x = make([]int, 0, 10)
	x = append(x, 1, f())
	if x[0] != 1 || x[1] != 2 {
		t.Error("append failed: ", x[0], x[1])
	}
}

func TestAppendOverlap(t *testing.T) {
	x := []byte("1234")
	x = append(x[1:], x...) // p > q in runtimeappendslice.
	got := string(x)
	want := "2341234"
	if got != want {
		t.Errorf("overlap failed: got %q want %q", got, want)
	}
}

func benchmarkCopySlice(b *testing.B, l int) {
	s := make([]byte, l)
	buf := make([]byte, 4096)
	var n int
	for i := 0; i < b.N; i++ {
		n = copy(buf, s)
	}
	b.SetBytes(int64(n))
}

func benchmarkCopyStr(b *testing.B, l int) {
	s := string(make([]byte, l))
	buf := make([]byte, 4096)
	var n int
	for i := 0; i < b.N; i++ {
		n = copy(buf, s)
	}
	b.SetBytes(int64(n))
}

func BenchmarkCopy1Byte(b *testing.B)    { benchmarkCopySlice(b, 1) }
func BenchmarkCopy2Byte(b *testing.B)    { benchmarkCopySlice(b, 2) }
func BenchmarkCopy4Byte(b *testing.B)    { benchmarkCopySlice(b, 4) }
func BenchmarkCopy8Byte(b *testing.B)    { benchmarkCopySlice(b, 8) }
func BenchmarkCopy12Byte(b *testing.B)   { benchmarkCopySlice(b, 12) }
func BenchmarkCopy16Byte(b *testing.B)   { benchmarkCopySlice(b, 16) }
func BenchmarkCopy32Byte(b *testing.B)   { benchmarkCopySlice(b, 32) }
func BenchmarkCopy128Byte(b *testing.B)  { benchmarkCopySlice(b, 128) }
func BenchmarkCopy1024Byte(b *testing.B) { benchmarkCopySlice(b, 1024) }

func BenchmarkCopy1String(b *testing.B)    { benchmarkCopyStr(b, 1) }
func BenchmarkCopy2String(b *testing.B)    { benchmarkCopyStr(b, 2) }
func BenchmarkCopy4String(b *testing.B)    { benchmarkCopyStr(b, 4) }
func BenchmarkCopy8String(b *testing.B)    { benchmarkCopyStr(b, 8) }
func BenchmarkCopy12String(b *testing.B)   { benchmarkCopyStr(b, 12) }
func BenchmarkCopy16String(b *testing.B)   { benchmarkCopyStr(b, 16) }
func BenchmarkCopy32String(b *testing.B)   { benchmarkCopyStr(b, 32) }
func BenchmarkCopy128String(b *testing.B)  { benchmarkCopyStr(b, 128) }
func BenchmarkCopy1024String(b *testing.B) { benchmarkCopyStr(b, 1024) }
                                                                                                                                                   root/go1.4/src/runtime/arch_386.go                                                                  0100644 0000000 0000000 00000000354 12600426227 015201  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package runtime

type uintreg uint32
type intptr int32 // TODO(rsc): remove
                                                                                                                                                                                                                                                                                    root/go1.4/src/runtime/arch_386.h                                                                   0100644 0000000 0000000 00000000542 12600426227 015022  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

enum {
	thechar = '8',
	BigEndian = 0,
	CacheLineSize = 64,
	RuntimeGogoBytes = 64,
#ifdef GOOS_nacl
	PhysPageSize = 65536,
#else
	PhysPageSize = 4096,
#endif
	PCQuantum = 1,
	Int64Align = 4
};
                                                                                                                                                              root/go1.4/src/runtime/arch_amd64.go                                                                0100644 0000000 0000000 00000000354 12600426227 015574  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package runtime

type uintreg uint64
type intptr int64 // TODO(rsc): remove
                                                                                                                                                                                                                                                                                    root/go1.4/src/runtime/arch_amd64.h                                                                 0100644 0000000 0000000 00000000766 12600426227 015425  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

enum {
	thechar = '6',
	BigEndian = 0,
	CacheLineSize = 64,
#ifdef GOOS_solaris
	RuntimeGogoBytes = 80,
#else
#ifdef GOOS_windows
	RuntimeGogoBytes = 80,
#else
#ifdef GOOS_plan9
	RuntimeGogoBytes = 80,
#else
	RuntimeGogoBytes = 64,
#endif	// Plan 9
#endif	// Windows
#endif	// Solaris
	PhysPageSize = 4096,
	PCQuantum = 1,
	Int64Align = 8
};
          root/go1.4/src/runtime/arch_amd64p32.go                                                             0100644 0000000 0000000 00000000354 12600426227 016121  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package runtime

type uintreg uint64
type intptr int32 // TODO(rsc): remove
                                                                                                                                                                                                                                                                                    root/go1.4/src/runtime/arch_amd64p32.h                                                              0100644 0000000 0000000 00000000542 12600426227 015742  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

enum {
	thechar = '6',
	BigEndian = 0,
	CacheLineSize = 64,
	RuntimeGogoBytes = 64,
#ifdef GOOS_nacl
	PhysPageSize = 65536,
#else
	PhysPageSize = 4096,
#endif
	PCQuantum = 1,
	Int64Align = 8
};
                                                                                                                                                              root/go1.4/src/runtime/arch_arm.go                                                                  0100644 0000000 0000000 00000000354 12600426227 015440  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package runtime

type uintreg uint32
type intptr int32 // TODO(rsc): remove
                                                                                                                                                                                                                                                                                    root/go1.4/src/runtime/arch_arm.h                                                                   0100644 0000000 0000000 00000000542 12600426227 015261  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

enum {
	thechar = '5',
	BigEndian = 0,
	CacheLineSize = 32,
	RuntimeGogoBytes = 60,
#ifdef GOOS_nacl
	PhysPageSize = 65536,
#else
	PhysPageSize = 4096,
#endif
	PCQuantum = 4,
	Int64Align = 4
};
                                                                                                                                                              root/go1.4/src/runtime/asm.s                                                                        0100644 0000000 0000000 00000001140 12600426227 014273  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include "textflag.h"

// funcdata for functions with no local variables in frame.
// Define two zero-length bitmaps, because the same index is used
// for the local variables as for the argument frame, and assembly
// frames have two argument bitmaps, one without results and one with results.
DATA runtimeno_pointers_stackmap+0x00(SB)/4, $2
DATA runtimeno_pointers_stackmap+0x04(SB)/4, $0
GLOBL runtimeno_pointers_stackmap(SB),RODATA, $8

                                                                                                                                                                                                                                                                                                                                                                                                                                root/go1.4/src/runtime/asm_386.s                                                                    0100644 0000000 0000000 00000126055 12600426227 014710  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include "zasm_GOOS_GOARCH.h"
#include "funcdata.h"
#include "textflag.h"

TEXT runtimert0_go(SB),NOSPLIT,$0
	// copy arguments forward on an even stack
	MOVL	argc+0(FP), AX
	MOVL	argv+4(FP), BX
	SUBL	$128, SP		// plenty of scratch
	ANDL	$~15, SP
	MOVL	AX, 120(SP)		// save argc, argv away
	MOVL	BX, 124(SP)

	// set default stack bounds.
	// _cgo_init may update stackguard.
	MOVL	$runtimeg0(SB), BP
	LEAL	(-64*1024+104)(SP), BX
	MOVL	BX, g_stackguard0(BP)
	MOVL	BX, g_stackguard1(BP)
	MOVL	BX, (g_stack+stack_lo)(BP)
	MOVL	SP, (g_stack+stack_hi)(BP)
	
	// find out information about the processor we're on
	MOVL	$0, AX
	CPUID
	CMPL	AX, $0
	JE	nocpuinfo
	MOVL	$1, AX
	CPUID
	MOVL	CX, runtimecpuid_ecx(SB)
	MOVL	DX, runtimecpuid_edx(SB)
nocpuinfo:	

	// if there is an _cgo_init, call it to let it
	// initialize and to set up GS.  if not,
	// we set up GS ourselves.
	MOVL	_cgo_init(SB), AX
	TESTL	AX, AX
	JZ	needtls
	MOVL	$setg_gcc<>(SB), BX
	MOVL	BX, 4(SP)
	MOVL	BP, 0(SP)
	CALL	AX

	// update stackguard after _cgo_init
	MOVL	$runtimeg0(SB), CX
	MOVL	(g_stack+stack_lo)(CX), AX
	ADDL	$const_StackGuard, AX
	MOVL	AX, g_stackguard0(CX)
	MOVL	AX, g_stackguard1(CX)

	// skip runtimeldt0setup(SB) and tls test after _cgo_init for non-windows
	CMPL runtimeiswindows(SB), $0
	JEQ ok
needtls:
	// skip runtimeldt0setup(SB) and tls test on Plan 9 in all cases
	CMPL	runtimeisplan9(SB), $1
	JEQ	ok

	// set up %gs
	CALL	runtimeldt0setup(SB)

	// store through it, to make sure it works
	get_tls(BX)
	MOVL	$0x123, g(BX)
	MOVL	runtimetls0(SB), AX
	CMPL	AX, $0x123
	JEQ	ok
	MOVL	AX, 0	// abort
ok:
	// set up m and g "registers"
	get_tls(BX)
	LEAL	runtimeg0(SB), CX
	MOVL	CX, g(BX)
	LEAL	runtimem0(SB), AX

	// save m->g0 = g0
	MOVL	CX, m_g0(AX)
	// save g0->m = m0
	MOVL	AX, g_m(CX)

	CALL	runtimeemptyfunc(SB)	// fault if stack check is wrong

	// convention is D is always cleared
	CLD

	CALL	runtimecheck(SB)

	// saved argc, argv
	MOVL	120(SP), AX
	MOVL	AX, 0(SP)
	MOVL	124(SP), AX
	MOVL	AX, 4(SP)
	CALL	runtimeargs(SB)
	CALL	runtimeosinit(SB)
	CALL	runtimeschedinit(SB)

	// create a new goroutine to start program
	PUSHL	$runtimemainf(SB)	// entry
	PUSHL	$0	// arg size
	CALL	runtimenewproc(SB)
	POPL	AX
	POPL	AX

	// start this M
	CALL	runtimemstart(SB)

	INT $3
	RET

DATA	runtimemainf+0(SB)/4,$runtimemain(SB)
GLOBL	runtimemainf(SB),RODATA,$4

TEXT runtimebreakpoint(SB),NOSPLIT,$0-0
	INT $3
	RET

TEXT runtimeasminit(SB),NOSPLIT,$0-0
	// Linux and MinGW start the FPU in extended double precision.
	// Other operating systems use double precision.
	// Change to double precision to match them,
	// and to match other hardware that only has double.
	PUSHL $0x27F
	FLDCW	0(SP)
	POPL AX
	RET

/*
 *  go-routine
 */

// void gosave(Gobuf*)
// save state in Gobuf; setjmp
TEXT runtimegosave(SB), NOSPLIT, $0-4
	MOVL	buf+0(FP), AX		// gobuf
	LEAL	buf+0(FP), BX		// caller's SP
	MOVL	BX, gobuf_sp(AX)
	MOVL	0(SP), BX		// caller's PC
	MOVL	BX, gobuf_pc(AX)
	MOVL	$0, gobuf_ret(AX)
	MOVL	$0, gobuf_ctxt(AX)
	get_tls(CX)
	MOVL	g(CX), BX
	MOVL	BX, gobuf_g(AX)
	RET

// void gogo(Gobuf*)
// restore state from Gobuf; longjmp
TEXT runtimegogo(SB), NOSPLIT, $0-4
	MOVL	buf+0(FP), BX		// gobuf
	MOVL	gobuf_g(BX), DX
	MOVL	0(DX), CX		// make sure g != nil
	get_tls(CX)
	MOVL	DX, g(CX)
	MOVL	gobuf_sp(BX), SP	// restore SP
	MOVL	gobuf_ret(BX), AX
	MOVL	gobuf_ctxt(BX), DX
	MOVL	$0, gobuf_sp(BX)	// clear to help garbage collector
	MOVL	$0, gobuf_ret(BX)
	MOVL	$0, gobuf_ctxt(BX)
	MOVL	gobuf_pc(BX), BX
	JMP	BX

// func mcall(fn func(*g))
// Switch to m->g0's stack, call fn(g).
// Fn must never return.  It should gogo(&g->sched)
// to keep running g.
TEXT runtimemcall(SB), NOSPLIT, $0-4
	MOVL	fn+0(FP), DI
	
	get_tls(CX)
	MOVL	g(CX), AX	// save state in g->sched
	MOVL	0(SP), BX	// caller's PC
	MOVL	BX, (g_sched+gobuf_pc)(AX)
	LEAL	fn+0(FP), BX	// caller's SP
	MOVL	BX, (g_sched+gobuf_sp)(AX)
	MOVL	AX, (g_sched+gobuf_g)(AX)

	// switch to m->g0 & its stack, call fn
	MOVL	g(CX), BX
	MOVL	g_m(BX), BX
	MOVL	m_g0(BX), SI
	CMPL	SI, AX	// if g == m->g0 call badmcall
	JNE	3(PC)
	MOVL	$runtimebadmcall(SB), AX
	JMP	AX
	MOVL	SI, g(CX)	// g = m->g0
	MOVL	(g_sched+gobuf_sp)(SI), SP	// sp = m->g0->sched.sp
	PUSHL	AX
	MOVL	DI, DX
	MOVL	0(DI), DI
	CALL	DI
	POPL	AX
	MOVL	$runtimebadmcall2(SB), AX
	JMP	AX
	RET

// switchtoM is a dummy routine that onM leaves at the bottom
// of the G stack.  We need to distinguish the routine that
// lives at the bottom of the G stack from the one that lives
// at the top of the M stack because the one at the top of
// the M stack terminates the stack walk (see topofstack()).
TEXT runtimeswitchtoM(SB), NOSPLIT, $0-0
	RET

// func onM_signalok(fn func())
TEXT runtimeonM_signalok(SB), NOSPLIT, $0-4
	get_tls(CX)
	MOVL	g(CX), AX	// AX = g
	MOVL	g_m(AX), BX	// BX = m
	MOVL	m_gsignal(BX), DX	// DX = gsignal
	CMPL	AX, DX
	JEQ	ongsignal
	JMP	runtimeonM(SB)

ongsignal:
	MOVL	fn+0(FP), DI	// DI = fn
	MOVL	DI, DX
	MOVL	0(DI), DI
	CALL	DI
	RET

// func onM(fn func())
TEXT runtimeonM(SB), NOSPLIT, $0-4
	MOVL	fn+0(FP), DI	// DI = fn
	get_tls(CX)
	MOVL	g(CX), AX	// AX = g
	MOVL	g_m(AX), BX	// BX = m

	MOVL	m_g0(BX), DX	// DX = g0
	CMPL	AX, DX
	JEQ	onm

	MOVL	m_curg(BX), BP
	CMPL	AX, BP
	JEQ	oncurg
	
	// Not g0, not curg. Must be gsignal, but that's not allowed.
	// Hide call from linker nosplit analysis.
	MOVL	$runtimebadonm(SB), AX
	CALL	AX

oncurg:
	// save our state in g->sched.  Pretend to
	// be switchtoM if the G stack is scanned.
	MOVL	$runtimeswitchtoM(SB), (g_sched+gobuf_pc)(AX)
	MOVL	SP, (g_sched+gobuf_sp)(AX)
	MOVL	AX, (g_sched+gobuf_g)(AX)

	// switch to g0
	MOVL	DX, g(CX)
	MOVL	(g_sched+gobuf_sp)(DX), BX
	// make it look like mstart called onM on g0, to stop traceback
	SUBL	$4, BX
	MOVL	$runtimemstart(SB), DX
	MOVL	DX, 0(BX)
	MOVL	BX, SP

	// call target function
	MOVL	DI, DX
	MOVL	0(DI), DI
	CALL	DI

	// switch back to g
	get_tls(CX)
	MOVL	g(CX), AX
	MOVL	g_m(AX), BX
	MOVL	m_curg(BX), AX
	MOVL	AX, g(CX)
	MOVL	(g_sched+gobuf_sp)(AX), SP
	MOVL	$0, (g_sched+gobuf_sp)(AX)
	RET

onm:
	// already on m stack, just call directly
	MOVL	DI, DX
	MOVL	0(DI), DI
	CALL	DI
	RET

/*
 * support for morestack
 */

// Called during function prolog when more stack is needed.
//
// The traceback routines see morestack on a g0 as being
// the top of a stack (for example, morestack calling newstack
// calling the scheduler calling newm calling gc), so we must
// record an argument size. For that purpose, it has no arguments.
TEXT runtimemorestack(SB),NOSPLIT,$0-0
	// Cannot grow scheduler stack (m->g0).
	get_tls(CX)
	MOVL	g(CX), BX
	MOVL	g_m(BX), BX
	MOVL	m_g0(BX), SI
	CMPL	g(CX), SI
	JNE	2(PC)
	INT	$3

	// Cannot grow signal stack.
	MOVL	m_gsignal(BX), SI
	CMPL	g(CX), SI
	JNE	2(PC)
	INT	$3

	// Called from f.
	// Set m->morebuf to f's caller.
	MOVL	4(SP), DI	// f's caller's PC
	MOVL	DI, (m_morebuf+gobuf_pc)(BX)
	LEAL	8(SP), CX	// f's caller's SP
	MOVL	CX, (m_morebuf+gobuf_sp)(BX)
	get_tls(CX)
	MOVL	g(CX), SI
	MOVL	SI, (m_morebuf+gobuf_g)(BX)

	// Set g->sched to context in f.
	MOVL	0(SP), AX	// f's PC
	MOVL	AX, (g_sched+gobuf_pc)(SI)
	MOVL	SI, (g_sched+gobuf_g)(SI)
	LEAL	4(SP), AX	// f's SP
	MOVL	AX, (g_sched+gobuf_sp)(SI)
	MOVL	DX, (g_sched+gobuf_ctxt)(SI)

	// Call newstack on m->g0's stack.
	MOVL	m_g0(BX), BP
	MOVL	BP, g(CX)
	MOVL	(g_sched+gobuf_sp)(BP), AX
	MOVL	-4(AX), BX	// fault if CALL would, before smashing SP
	MOVL	AX, SP
	CALL	runtimenewstack(SB)
	MOVL	$0, 0x1003	// crash if newstack returns
	RET

TEXT runtimemorestack_noctxt(SB),NOSPLIT,$0-0
	MOVL	$0, DX
	JMP runtimemorestack(SB)

// reflectcall: call a function with the given argument list
// func call(f *FuncVal, arg *byte, argsize, retoffset uint32).
// we don't have variable-sized frames, so we use a small number
// of constant-sized-frame functions to encode a few bits of size in the pc.
// Caution: ugly multiline assembly macros in your future!

#define DISPATCH(NAME,MAXSIZE)		\
	CMPL	CX, $MAXSIZE;		\
	JA	3(PC);			\
	MOVL	$NAME(SB), AX;		\
	JMP	AX
// Note: can't just "JMP NAME(SB)" - bad inlining results.

TEXT reflectcall(SB), NOSPLIT, $0-16
	MOVL	argsize+8(FP), CX
	DISPATCH(runtimecall16, 16)
	DISPATCH(runtimecall32, 32)
	DISPATCH(runtimecall64, 64)
	DISPATCH(runtimecall128, 128)
	DISPATCH(runtimecall256, 256)
	DISPATCH(runtimecall512, 512)
	DISPATCH(runtimecall1024, 1024)
	DISPATCH(runtimecall2048, 2048)
	DISPATCH(runtimecall4096, 4096)
	DISPATCH(runtimecall8192, 8192)
	DISPATCH(runtimecall16384, 16384)
	DISPATCH(runtimecall32768, 32768)
	DISPATCH(runtimecall65536, 65536)
	DISPATCH(runtimecall131072, 131072)
	DISPATCH(runtimecall262144, 262144)
	DISPATCH(runtimecall524288, 524288)
	DISPATCH(runtimecall1048576, 1048576)
	DISPATCH(runtimecall2097152, 2097152)
	DISPATCH(runtimecall4194304, 4194304)
	DISPATCH(runtimecall8388608, 8388608)
	DISPATCH(runtimecall16777216, 16777216)
	DISPATCH(runtimecall33554432, 33554432)
	DISPATCH(runtimecall67108864, 67108864)
	DISPATCH(runtimecall134217728, 134217728)
	DISPATCH(runtimecall268435456, 268435456)
	DISPATCH(runtimecall536870912, 536870912)
	DISPATCH(runtimecall1073741824, 1073741824)
	MOVL	$runtimebadreflectcall(SB), AX
	JMP	AX

#define CALLFN(NAME,MAXSIZE)			\
TEXT NAME(SB), WRAPPER, $MAXSIZE-16;		\
	NO_LOCAL_POINTERS;			\
	/* copy arguments to stack */		\
	MOVL	argptr+4(FP), SI;		\
	MOVL	argsize+8(FP), CX;		\
	MOVL	SP, DI;				\
	REP;MOVSB;				\
	/* call function */			\
	MOVL	f+0(FP), DX;			\
	MOVL	(DX), AX; 			\
	PCDATA  $PCDATA_StackMapIndex, $0;	\
	CALL	AX;				\
	/* copy return values back */		\
	MOVL	argptr+4(FP), DI;		\
	MOVL	argsize+8(FP), CX;		\
	MOVL	retoffset+12(FP), BX;		\
	MOVL	SP, SI;				\
	ADDL	BX, DI;				\
	ADDL	BX, SI;				\
	SUBL	BX, CX;				\
	REP;MOVSB;				\
	RET

CALLFN(call16, 16)
CALLFN(call32, 32)
CALLFN(call64, 64)
CALLFN(call128, 128)
CALLFN(call256, 256)
CALLFN(call512, 512)
CALLFN(call1024, 1024)
CALLFN(call2048, 2048)
CALLFN(call4096, 4096)
CALLFN(call8192, 8192)
CALLFN(call16384, 16384)
CALLFN(call32768, 32768)
CALLFN(call65536, 65536)
CALLFN(call131072, 131072)
CALLFN(call262144, 262144)
CALLFN(call524288, 524288)
CALLFN(call1048576, 1048576)
CALLFN(call2097152, 2097152)
CALLFN(call4194304, 4194304)
CALLFN(call8388608, 8388608)
CALLFN(call16777216, 16777216)
CALLFN(call33554432, 33554432)
CALLFN(call67108864, 67108864)
CALLFN(call134217728, 134217728)
CALLFN(call268435456, 268435456)
CALLFN(call536870912, 536870912)
CALLFN(call1073741824, 1073741824)

// bool cas(int32 *val, int32 old, int32 new)
// Atomically:
//	if(*val == old){
//		*val = new;
//		return 1;
//	}else
//		return 0;
TEXT runtimecas(SB), NOSPLIT, $0-13
	MOVL	ptr+0(FP), BX
	MOVL	old+4(FP), AX
	MOVL	new+8(FP), CX
	LOCK
	CMPXCHGL	CX, 0(BX)
	JZ 4(PC)
	MOVL	$0, AX
	MOVB	AX, ret+12(FP)
	RET
	MOVL	$1, AX
	MOVB	AX, ret+12(FP)
	RET

TEXT runtimecasuintptr(SB), NOSPLIT, $0-13
	JMP	runtimecas(SB)

TEXT runtimeatomicloaduintptr(SB), NOSPLIT, $0-8
	JMP	runtimeatomicload(SB)

TEXT runtimeatomicloaduint(SB), NOSPLIT, $0-8
	JMP	runtimeatomicload(SB)

TEXT runtimeatomicstoreuintptr(SB), NOSPLIT, $0-8
	JMP	runtimeatomicstore(SB)

// bool runtimecas64(uint64 *val, uint64 old, uint64 new)
// Atomically:
//	if(*val == *old){
//		*val = new;
//		return 1;
//	} else {
//		return 0;
//	}
TEXT runtimecas64(SB), NOSPLIT, $0-21
	MOVL	ptr+0(FP), BP
	MOVL	old_lo+4(FP), AX
	MOVL	old_hi+8(FP), DX
	MOVL	new_lo+12(FP), BX
	MOVL	new_hi+16(FP), CX
	LOCK
	CMPXCHG8B	0(BP)
	JNZ	cas64_fail
	MOVL	$1, AX
	MOVB	AX, ret+20(FP)
	RET
cas64_fail:
	MOVL	$0, AX
	MOVB	AX, ret+20(FP)
	RET

// bool casp(void **p, void *old, void *new)
// Atomically:
//	if(*p == old){
//		*p = new;
//		return 1;
//	}else
//		return 0;
TEXT runtimecasp(SB), NOSPLIT, $0-13
	MOVL	ptr+0(FP), BX
	MOVL	old+4(FP), AX
	MOVL	new+8(FP), CX
	LOCK
	CMPXCHGL	CX, 0(BX)
	JZ 4(PC)
	MOVL	$0, AX
	MOVB	AX, ret+12(FP)
	RET
	MOVL	$1, AX
	MOVB	AX, ret+12(FP)
	RET

// uint32 xadd(uint32 volatile *val, int32 delta)
// Atomically:
//	*val += delta;
//	return *val;
TEXT runtimexadd(SB), NOSPLIT, $0-12
	MOVL	ptr+0(FP), BX
	MOVL	delta+4(FP), AX
	MOVL	AX, CX
	LOCK
	XADDL	AX, 0(BX)
	ADDL	CX, AX
	MOVL	AX, ret+8(FP)
	RET

TEXT runtimexchg(SB), NOSPLIT, $0-12
	MOVL	ptr+0(FP), BX
	MOVL	new+4(FP), AX
	XCHGL	AX, 0(BX)
	MOVL	AX, ret+8(FP)
	RET

TEXT runtimexchgp(SB), NOSPLIT, $0-12
	MOVL	ptr+0(FP), BX
	MOVL	new+4(FP), AX
	XCHGL	AX, 0(BX)
	MOVL	AX, ret+8(FP)
	RET

TEXT runtimexchguintptr(SB), NOSPLIT, $0-12
	JMP	runtimexchg(SB)

TEXT runtimeprocyield(SB),NOSPLIT,$0-0
	MOVL	cycles+0(FP), AX
again:
	PAUSE
	SUBL	$1, AX
	JNZ	again
	RET

TEXT runtimeatomicstorep(SB), NOSPLIT, $0-8
	MOVL	ptr+0(FP), BX
	MOVL	val+4(FP), AX
	XCHGL	AX, 0(BX)
	RET

TEXT runtimeatomicstore(SB), NOSPLIT, $0-8
	MOVL	ptr+0(FP), BX
	MOVL	val+4(FP), AX
	XCHGL	AX, 0(BX)
	RET

// uint64 atomicload64(uint64 volatile* addr);
TEXT runtimeatomicload64(SB), NOSPLIT, $0-12
	MOVL	ptr+0(FP), AX
	LEAL	ret_lo+4(FP), BX
	// MOVQ (%EAX), %MM0
	BYTE $0x0f; BYTE $0x6f; BYTE $0x00
	// MOVQ %MM0, 0(%EBX)
	BYTE $0x0f; BYTE $0x7f; BYTE $0x03
	// EMMS
	BYTE $0x0F; BYTE $0x77
	RET

// void runtimeatomicstore64(uint64 volatile* addr, uint64 v);
TEXT runtimeatomicstore64(SB), NOSPLIT, $0-12
	MOVL	ptr+0(FP), AX
	// MOVQ and EMMS were introduced on the Pentium MMX.
	// MOVQ 0x8(%ESP), %MM0
	BYTE $0x0f; BYTE $0x6f; BYTE $0x44; BYTE $0x24; BYTE $0x08
	// MOVQ %MM0, (%EAX)
	BYTE $0x0f; BYTE $0x7f; BYTE $0x00 
	// EMMS
	BYTE $0x0F; BYTE $0x77
	// This is essentially a no-op, but it provides required memory fencing.
	// It can be replaced with MFENCE, but MFENCE was introduced only on the Pentium4 (SSE2).
	MOVL	$0, AX
	LOCK
	XADDL	AX, (SP)
	RET

// void	runtimeatomicor8(byte volatile*, byte);
TEXT runtimeatomicor8(SB), NOSPLIT, $0-5
	MOVL	ptr+0(FP), AX
	MOVB	val+4(FP), BX
	LOCK
	ORB	BX, (AX)
	RET

// void jmpdefer(fn, sp);
// called from deferreturn.
// 1. pop the caller
// 2. sub 5 bytes from the callers return
// 3. jmp to the argument
TEXT runtimejmpdefer(SB), NOSPLIT, $0-8
	MOVL	fv+0(FP), DX	// fn
	MOVL	argp+4(FP), BX	// caller sp
	LEAL	-4(BX), SP	// caller sp after CALL
	SUBL	$5, (SP)	// return to CALL again
	MOVL	0(DX), BX
	JMP	BX	// but first run the deferred function

// Save state of caller into g->sched.
TEXT gosave<>(SB),NOSPLIT,$0
	PUSHL	AX
	PUSHL	BX
	get_tls(BX)
	MOVL	g(BX), BX
	LEAL	arg+0(FP), AX
	MOVL	AX, (g_sched+gobuf_sp)(BX)
	MOVL	-4(AX), AX
	MOVL	AX, (g_sched+gobuf_pc)(BX)
	MOVL	$0, (g_sched+gobuf_ret)(BX)
	MOVL	$0, (g_sched+gobuf_ctxt)(BX)
	POPL	BX
	POPL	AX
	RET

// asmcgocall(void(*fn)(void*), void *arg)
// Call fn(arg) on the scheduler stack,
// aligned appropriately for the gcc ABI.
// See cgocall.c for more details.
TEXT asmcgocall(SB),NOSPLIT,$0-8
	MOVL	fn+0(FP), AX
	MOVL	arg+4(FP), BX
	CALL	asmcgocall<>(SB)
	RET

TEXT asmcgocall_errno(SB),NOSPLIT,$0-12
	MOVL	fn+0(FP), AX
	MOVL	arg+4(FP), BX
	CALL	asmcgocall<>(SB)
	MOVL	AX, ret+8(FP)
	RET

TEXT asmcgocall<>(SB),NOSPLIT,$0-0
	// fn in AX, arg in BX
	MOVL	SP, DX

	// Figure out if we need to switch to m->g0 stack.
	// We get called to create new OS threads too, and those
	// come in on the m->g0 stack already.
	get_tls(CX)
	MOVL	g(CX), BP
	MOVL	g_m(BP), BP
	MOVL	m_g0(BP), SI
	MOVL	g(CX), DI
	CMPL	SI, DI
	JEQ	4(PC)
	CALL	gosave<>(SB)
	MOVL	SI, g(CX)
	MOVL	(g_sched+gobuf_sp)(SI), SP

	// Now on a scheduling stack (a pthread-created stack).
	SUBL	$32, SP
	ANDL	$~15, SP	// alignment, perhaps unnecessary
	MOVL	DI, 8(SP)	// save g
	MOVL	(g_stack+stack_hi)(DI), DI
	SUBL	DX, DI
	MOVL	DI, 4(SP)	// save depth in stack (can't just save SP, as stack might be copied during a callback)
	MOVL	BX, 0(SP)	// first argument in x86-32 ABI
	CALL	AX

	// Restore registers, g, stack pointer.
	get_tls(CX)
	MOVL	8(SP), DI
	MOVL	(g_stack+stack_hi)(DI), SI
	SUBL	4(SP), SI
	MOVL	DI, g(CX)
	MOVL	SI, SP
	RET

// cgocallback(void (*fn)(void*), void *frame, uintptr framesize)
// Turn the fn into a Go func (by taking its address) and call
// cgocallback_gofunc.
TEXT runtimecgocallback(SB),NOSPLIT,$12-12
	LEAL	fn+0(FP), AX
	MOVL	AX, 0(SP)
	MOVL	frame+4(FP), AX
	MOVL	AX, 4(SP)
	MOVL	framesize+8(FP), AX
	MOVL	AX, 8(SP)
	MOVL	$runtimecgocallback_gofunc(SB), AX
	CALL	AX
	RET

// cgocallback_gofunc(FuncVal*, void *frame, uintptr framesize)
// See cgocall.c for more details.
TEXT cgocallback_gofunc(SB),NOSPLIT,$12-12
	NO_LOCAL_POINTERS

	// If g is nil, Go did not create the current thread.
	// Call needm to obtain one for temporary use.
	// In this case, we're running on the thread stack, so there's
	// lots of space, but the linker doesn't know. Hide the call from
	// the linker analysis by using an indirect call through AX.
	get_tls(CX)
#ifdef GOOS_windows
	MOVL	$0, BP
	CMPL	CX, $0
	JEQ	2(PC) // TODO
#endif
	MOVL	g(CX), BP
	CMPL	BP, $0
	JEQ	needm
	MOVL	g_m(BP), BP
	MOVL	BP, DX // saved copy of oldm
	JMP	havem
needm:
	MOVL	$0, 0(SP)
	MOVL	$runtimeneedm(SB), AX
	CALL	AX
	MOVL	0(SP), DX
	get_tls(CX)
	MOVL	g(CX), BP
	MOVL	g_m(BP), BP

	// Set m->sched.sp = SP, so that if a panic happens
	// during the function we are about to execute, it will
	// have a valid SP to run on the g0 stack.
	// The next few lines (after the havem label)
	// will save this SP onto the stack and then write
	// the same SP back to m->sched.sp. That seems redundant,
	// but if an unrecovered panic happens, unwindm will
	// restore the g->sched.sp from the stack location
	// and then onM will try to use it. If we don't set it here,
	// that restored SP will be uninitialized (typically 0) and
	// will not be usable.
	MOVL	m_g0(BP), SI
	MOVL	SP, (g_sched+gobuf_sp)(SI)

havem:
	// Now there's a valid m, and we're running on its m->g0.
	// Save current m->g0->sched.sp on stack and then set it to SP.
	// Save current sp in m->g0->sched.sp in preparation for
	// switch back to m->curg stack.
	// NOTE: unwindm knows that the saved g->sched.sp is at 0(SP).
	MOVL	m_g0(BP), SI
	MOVL	(g_sched+gobuf_sp)(SI), AX
	MOVL	AX, 0(SP)
	MOVL	SP, (g_sched+gobuf_sp)(SI)

	// Switch to m->curg stack and call runtime.cgocallbackg.
	// Because we are taking over the execution of m->curg
	// but *not* resuming what had been running, we need to
	// save that information (m->curg->sched) so we can restore it.
	// We can restore m->curg->sched.sp easily, because calling
	// runtime.cgocallbackg leaves SP unchanged upon return.
	// To save m->curg->sched.pc, we push it onto the stack.
	// This has the added benefit that it looks to the traceback
	// routine like cgocallbackg is going to return to that
	// PC (because the frame we allocate below has the same
	// size as cgocallback_gofunc's frame declared above)
	// so that the traceback will seamlessly trace back into
	// the earlier calls.
	//
	// In the new goroutine, 0(SP) holds the saved oldm (DX) register.
	// 4(SP) and 8(SP) are unused.
	MOVL	m_curg(BP), SI
	MOVL	SI, g(CX)
	MOVL	(g_sched+gobuf_sp)(SI), DI // prepare stack as DI
	MOVL	(g_sched+gobuf_pc)(SI), BP
	MOVL	BP, -4(DI)
	LEAL	-(4+12)(DI), SP
	MOVL	DX, 0(SP)
	CALL	runtimecgocallbackg(SB)
	MOVL	0(SP), DX

	// Restore g->sched (== m->curg->sched) from saved values.
	get_tls(CX)
	MOVL	g(CX), SI
	MOVL	12(SP), BP
	MOVL	BP, (g_sched+gobuf_pc)(SI)
	LEAL	(12+4)(SP), DI
	MOVL	DI, (g_sched+gobuf_sp)(SI)

	// Switch back to m->g0's stack and restore m->g0->sched.sp.
	// (Unlike m->curg, the g0 goroutine never uses sched.pc,
	// so we do not have to restore it.)
	MOVL	g(CX), BP
	MOVL	g_m(BP), BP
	MOVL	m_g0(BP), SI
	MOVL	SI, g(CX)
	MOVL	(g_sched+gobuf_sp)(SI), SP
	MOVL	0(SP), AX
	MOVL	AX, (g_sched+gobuf_sp)(SI)
	
	// If the m on entry was nil, we called needm above to borrow an m
	// for the duration of the call. Since the call is over, return it with dropm.
	CMPL	DX, $0
	JNE 3(PC)
	MOVL	$runtimedropm(SB), AX
	CALL	AX

	// Done!
	RET

// void setg(G*); set g. for use by needm.
TEXT runtimesetg(SB), NOSPLIT, $0-4
	MOVL	gg+0(FP), BX
#ifdef GOOS_windows
	CMPL	BX, $0
	JNE	settls
	MOVL	$0, 0x14(FS)
	RET
settls:
	MOVL	g_m(BX), AX
	LEAL	m_tls(AX), AX
	MOVL	AX, 0x14(FS)
#endif
	get_tls(CX)
	MOVL	BX, g(CX)
	RET

// void setg_gcc(G*); set g. for use by gcc
TEXT setg_gcc<>(SB), NOSPLIT, $0
	get_tls(AX)
	MOVL	gg+0(FP), DX
	MOVL	DX, g(AX)
	RET

// check that SP is in range [g->stack.lo, g->stack.hi)
TEXT runtimestackcheck(SB), NOSPLIT, $0-0
	get_tls(CX)
	MOVL	g(CX), AX
	CMPL	(g_stack+stack_hi)(AX), SP
	JHI	2(PC)
	INT	$3
	CMPL	SP, (g_stack+stack_lo)(AX)
	JHI	2(PC)
	INT	$3
	RET

TEXT runtimegetcallerpc(SB),NOSPLIT,$0-8
	MOVL	argp+0(FP),AX		// addr of first arg
	MOVL	-4(AX),AX		// get calling pc
	MOVL	AX, ret+4(FP)
	RET

TEXT runtimegogetcallerpc(SB),NOSPLIT,$0-8
	MOVL	p+0(FP),AX		// addr of first arg
	MOVL	-4(AX),AX		// get calling pc
	MOVL	AX, ret+4(FP)
	RET

TEXT runtimesetcallerpc(SB),NOSPLIT,$0-8
	MOVL	argp+0(FP),AX		// addr of first arg
	MOVL	pc+4(FP), BX
	MOVL	BX, -4(AX)		// set calling pc
	RET

TEXT runtimegetcallersp(SB), NOSPLIT, $0-8
	MOVL	argp+0(FP), AX
	MOVL	AX, ret+4(FP)
	RET

// func gogetcallersp(p unsafe.Pointer) uintptr
TEXT runtimegogetcallersp(SB),NOSPLIT,$0-8
	MOVL	p+0(FP),AX		// addr of first arg
	MOVL	AX, ret+4(FP)
	RET

// int64 runtimecputicks(void), so really
// void runtimecputicks(int64 *ticks)
TEXT runtimecputicks(SB),NOSPLIT,$0-8
	RDTSC
	MOVL	AX, ret_lo+0(FP)
	MOVL	DX, ret_hi+4(FP)
	RET

TEXT runtimeldt0setup(SB),NOSPLIT,$16-0
	// set up ldt 7 to point at tls0
	// ldt 1 would be fine on Linux, but on OS X, 7 is as low as we can go.
	// the entry number is just a hint.  setldt will set up GS with what it used.
	MOVL	$7, 0(SP)
	LEAL	runtimetls0(SB), AX
	MOVL	AX, 4(SP)
	MOVL	$32, 8(SP)	// sizeof(tls array)
	CALL	runtimesetldt(SB)
	RET

TEXT runtimeemptyfunc(SB),0,$0-0
	RET

TEXT runtimeabort(SB),NOSPLIT,$0-0
	INT $0x3

// hash function using AES hardware instructions
TEXT runtimeaeshash(SB),NOSPLIT,$0-16
	MOVL	p+0(FP), AX	// ptr to data
	MOVL	s+4(FP), CX	// size
	JMP	runtimeaeshashbody(SB)

TEXT runtimeaeshashstr(SB),NOSPLIT,$0-16
	MOVL	p+0(FP), AX	// ptr to string object
	// s+4(FP) is ignored, it is always sizeof(String)
	MOVL	4(AX), CX	// length of string
	MOVL	(AX), AX	// string data
	JMP	runtimeaeshashbody(SB)

// AX: data
// CX: length
TEXT runtimeaeshashbody(SB),NOSPLIT,$0-16
	MOVL	h+8(FP), X0	// seed to low 32 bits of xmm0
	PINSRD	$1, CX, X0	// size to next 32 bits of xmm0
	MOVO	runtimeaeskeysched+0(SB), X2
	MOVO	runtimeaeskeysched+16(SB), X3
	CMPL	CX, $16
	JB	aessmall
aesloop:
	CMPL	CX, $16
	JBE	aesloopend
	MOVOU	(AX), X1
	AESENC	X2, X0
	AESENC	X1, X0
	SUBL	$16, CX
	ADDL	$16, AX
	JMP	aesloop
// 1-16 bytes remaining
aesloopend:
	// This load may overlap with the previous load above.
	// We'll hash some bytes twice, but that's ok.
	MOVOU	-16(AX)(CX*1), X1
	JMP	partial
// 0-15 bytes
aessmall:
	TESTL	CX, CX
	JE	finalize	// 0 bytes

	CMPB	AX, $0xf0
	JA	highpartial

	// 16 bytes loaded at this address won't cross
	// a page boundary, so we can load it directly.
	MOVOU	(AX), X1
	ADDL	CX, CX
	PAND	masks<>(SB)(CX*8), X1
	JMP	partial
highpartial:
	// address ends in 1111xxxx.  Might be up against
	// a page boundary, so load ending at last byte.
	// Then shift bytes down using pshufb.
	MOVOU	-16(AX)(CX*1), X1
	ADDL	CX, CX
	PSHUFB	shifts<>(SB)(CX*8), X1
partial:
	// incorporate partial block into hash
	AESENC	X3, X0
	AESENC	X1, X0
finalize:	
	// finalize hash
	AESENC	X2, X0
	AESENC	X3, X0
	AESENC	X2, X0
	MOVL	X0, ret+12(FP)
	RET

TEXT runtimeaeshash32(SB),NOSPLIT,$0-16
	MOVL	p+0(FP), AX	// ptr to data
	// s+4(FP) is ignored, it is always sizeof(int32)
	MOVL	h+8(FP), X0	// seed
	PINSRD	$1, (AX), X0	// data
	AESENC	runtimeaeskeysched+0(SB), X0
	AESENC	runtimeaeskeysched+16(SB), X0
	AESENC	runtimeaeskeysched+0(SB), X0
	MOVL	X0, ret+12(FP)
	RET

TEXT runtimeaeshash64(SB),NOSPLIT,$0-16
	MOVL	p+0(FP), AX	// ptr to data
	// s+4(FP) is ignored, it is always sizeof(int64)
	MOVQ	(AX), X0	// data
	PINSRD	$2, h+8(FP), X0	// seed
	AESENC	runtimeaeskeysched+0(SB), X0
	AESENC	runtimeaeskeysched+16(SB), X0
	AESENC	runtimeaeskeysched+0(SB), X0
	MOVL	X0, ret+12(FP)
	RET

// simple mask to get rid of data in the high part of the register.
DATA masks<>+0x00(SB)/4, $0x00000000
DATA masks<>+0x04(SB)/4, $0x00000000
DATA masks<>+0x08(SB)/4, $0x00000000
DATA masks<>+0x0c(SB)/4, $0x00000000
	
DATA masks<>+0x10(SB)/4, $0x000000ff
DATA masks<>+0x14(SB)/4, $0x00000000
DATA masks<>+0x18(SB)/4, $0x00000000
DATA masks<>+0x1c(SB)/4, $0x00000000
	
DATA masks<>+0x20(SB)/4, $0x0000ffff
DATA masks<>+0x24(SB)/4, $0x00000000
DATA masks<>+0x28(SB)/4, $0x00000000
DATA masks<>+0x2c(SB)/4, $0x00000000
	
DATA masks<>+0x30(SB)/4, $0x00ffffff
DATA masks<>+0x34(SB)/4, $0x00000000
DATA masks<>+0x38(SB)/4, $0x00000000
DATA masks<>+0x3c(SB)/4, $0x00000000
	
DATA masks<>+0x40(SB)/4, $0xffffffff
DATA masks<>+0x44(SB)/4, $0x00000000
DATA masks<>+0x48(SB)/4, $0x00000000
DATA masks<>+0x4c(SB)/4, $0x00000000
	
DATA masks<>+0x50(SB)/4, $0xffffffff
DATA masks<>+0x54(SB)/4, $0x000000ff
DATA masks<>+0x58(SB)/4, $0x00000000
DATA masks<>+0x5c(SB)/4, $0x00000000
	
DATA masks<>+0x60(SB)/4, $0xffffffff
DATA masks<>+0x64(SB)/4, $0x0000ffff
DATA masks<>+0x68(SB)/4, $0x00000000
DATA masks<>+0x6c(SB)/4, $0x00000000
	
DATA masks<>+0x70(SB)/4, $0xffffffff
DATA masks<>+0x74(SB)/4, $0x00ffffff
DATA masks<>+0x78(SB)/4, $0x00000000
DATA masks<>+0x7c(SB)/4, $0x00000000
	
DATA masks<>+0x80(SB)/4, $0xffffffff
DATA masks<>+0x84(SB)/4, $0xffffffff
DATA masks<>+0x88(SB)/4, $0x00000000
DATA masks<>+0x8c(SB)/4, $0x00000000
	
DATA masks<>+0x90(SB)/4, $0xffffffff
DATA masks<>+0x94(SB)/4, $0xffffffff
DATA masks<>+0x98(SB)/4, $0x000000ff
DATA masks<>+0x9c(SB)/4, $0x00000000
	
DATA masks<>+0xa0(SB)/4, $0xffffffff
DATA masks<>+0xa4(SB)/4, $0xffffffff
DATA masks<>+0xa8(SB)/4, $0x0000ffff
DATA masks<>+0xac(SB)/4, $0x00000000
	
DATA masks<>+0xb0(SB)/4, $0xffffffff
DATA masks<>+0xb4(SB)/4, $0xffffffff
DATA masks<>+0xb8(SB)/4, $0x00ffffff
DATA masks<>+0xbc(SB)/4, $0x00000000
	
DATA masks<>+0xc0(SB)/4, $0xffffffff
DATA masks<>+0xc4(SB)/4, $0xffffffff
DATA masks<>+0xc8(SB)/4, $0xffffffff
DATA masks<>+0xcc(SB)/4, $0x00000000
	
DATA masks<>+0xd0(SB)/4, $0xffffffff
DATA masks<>+0xd4(SB)/4, $0xffffffff
DATA masks<>+0xd8(SB)/4, $0xffffffff
DATA masks<>+0xdc(SB)/4, $0x000000ff
	
DATA masks<>+0xe0(SB)/4, $0xffffffff
DATA masks<>+0xe4(SB)/4, $0xffffffff
DATA masks<>+0xe8(SB)/4, $0xffffffff
DATA masks<>+0xec(SB)/4, $0x0000ffff
	
DATA masks<>+0xf0(SB)/4, $0xffffffff
DATA masks<>+0xf4(SB)/4, $0xffffffff
DATA masks<>+0xf8(SB)/4, $0xffffffff
DATA masks<>+0xfc(SB)/4, $0x00ffffff

GLOBL masks<>(SB),RODATA,$256

// these are arguments to pshufb.  They move data down from
// the high bytes of the register to the low bytes of the register.
// index is how many bytes to move.
DATA shifts<>+0x00(SB)/4, $0x00000000
DATA shifts<>+0x04(SB)/4, $0x00000000
DATA shifts<>+0x08(SB)/4, $0x00000000
DATA shifts<>+0x0c(SB)/4, $0x00000000
	
DATA shifts<>+0x10(SB)/4, $0xffffff0f
DATA shifts<>+0x14(SB)/4, $0xffffffff
DATA shifts<>+0x18(SB)/4, $0xffffffff
DATA shifts<>+0x1c(SB)/4, $0xffffffff
	
DATA shifts<>+0x20(SB)/4, $0xffff0f0e
DATA shifts<>+0x24(SB)/4, $0xffffffff
DATA shifts<>+0x28(SB)/4, $0xffffffff
DATA shifts<>+0x2c(SB)/4, $0xffffffff
	
DATA shifts<>+0x30(SB)/4, $0xff0f0e0d
DATA shifts<>+0x34(SB)/4, $0xffffffff
DATA shifts<>+0x38(SB)/4, $0xffffffff
DATA shifts<>+0x3c(SB)/4, $0xffffffff
	
DATA shifts<>+0x40(SB)/4, $0x0f0e0d0c
DATA shifts<>+0x44(SB)/4, $0xffffffff
DATA shifts<>+0x48(SB)/4, $0xffffffff
DATA shifts<>+0x4c(SB)/4, $0xffffffff
	
DATA shifts<>+0x50(SB)/4, $0x0e0d0c0b
DATA shifts<>+0x54(SB)/4, $0xffffff0f
DATA shifts<>+0x58(SB)/4, $0xffffffff
DATA shifts<>+0x5c(SB)/4, $0xffffffff
	
DATA shifts<>+0x60(SB)/4, $0x0d0c0b0a
DATA shifts<>+0x64(SB)/4, $0xffff0f0e
DATA shifts<>+0x68(SB)/4, $0xffffffff
DATA shifts<>+0x6c(SB)/4, $0xffffffff
	
DATA shifts<>+0x70(SB)/4, $0x0c0b0a09
DATA shifts<>+0x74(SB)/4, $0xff0f0e0d
DATA shifts<>+0x78(SB)/4, $0xffffffff
DATA shifts<>+0x7c(SB)/4, $0xffffffff
	
DATA shifts<>+0x80(SB)/4, $0x0b0a0908
DATA shifts<>+0x84(SB)/4, $0x0f0e0d0c
DATA shifts<>+0x88(SB)/4, $0xffffffff
DATA shifts<>+0x8c(SB)/4, $0xffffffff
	
DATA shifts<>+0x90(SB)/4, $0x0a090807
DATA shifts<>+0x94(SB)/4, $0x0e0d0c0b
DATA shifts<>+0x98(SB)/4, $0xffffff0f
DATA shifts<>+0x9c(SB)/4, $0xffffffff
	
DATA shifts<>+0xa0(SB)/4, $0x09080706
DATA shifts<>+0xa4(SB)/4, $0x0d0c0b0a
DATA shifts<>+0xa8(SB)/4, $0xffff0f0e
DATA shifts<>+0xac(SB)/4, $0xffffffff
	
DATA shifts<>+0xb0(SB)/4, $0x08070605
DATA shifts<>+0xb4(SB)/4, $0x0c0b0a09
DATA shifts<>+0xb8(SB)/4, $0xff0f0e0d
DATA shifts<>+0xbc(SB)/4, $0xffffffff
	
DATA shifts<>+0xc0(SB)/4, $0x07060504
DATA shifts<>+0xc4(SB)/4, $0x0b0a0908
DATA shifts<>+0xc8(SB)/4, $0x0f0e0d0c
DATA shifts<>+0xcc(SB)/4, $0xffffffff
	
DATA shifts<>+0xd0(SB)/4, $0x06050403
DATA shifts<>+0xd4(SB)/4, $0x0a090807
DATA shifts<>+0xd8(SB)/4, $0x0e0d0c0b
DATA shifts<>+0xdc(SB)/4, $0xffffff0f
	
DATA shifts<>+0xe0(SB)/4, $0x05040302
DATA shifts<>+0xe4(SB)/4, $0x09080706
DATA shifts<>+0xe8(SB)/4, $0x0d0c0b0a
DATA shifts<>+0xec(SB)/4, $0xffff0f0e
	
DATA shifts<>+0xf0(SB)/4, $0x04030201
DATA shifts<>+0xf4(SB)/4, $0x08070605
DATA shifts<>+0xf8(SB)/4, $0x0c0b0a09
DATA shifts<>+0xfc(SB)/4, $0xff0f0e0d

GLOBL shifts<>(SB),RODATA,$256

TEXT runtimememeq(SB),NOSPLIT,$0-13
	MOVL	a+0(FP), SI
	MOVL	b+4(FP), DI
	MOVL	size+8(FP), BX
	CALL	runtimememeqbody(SB)
	MOVB	AX, ret+12(FP)
	RET

// eqstring tests whether two strings are equal.
// See runtime_test.go:eqstring_generic for
// equivalent Go code.
TEXT runtimeeqstring(SB),NOSPLIT,$0-17
	MOVL	s1len+4(FP), AX
	MOVL	s2len+12(FP), BX
	CMPL	AX, BX
	JNE	different
	MOVL	s1str+0(FP), SI
	MOVL	s2str+8(FP), DI
	CMPL	SI, DI
	JEQ	same
	CALL	runtimememeqbody(SB)
	MOVB	AX, v+16(FP)
	RET
same:
	MOVB	$1, v+16(FP)
	RET
different:
	MOVB	$0, v+16(FP)
	RET

TEXT bytesEqual(SB),NOSPLIT,$0-25
	MOVL	a_len+4(FP), BX
	MOVL	b_len+16(FP), CX
	XORL	AX, AX
	CMPL	BX, CX
	JNE	eqret
	MOVL	a+0(FP), SI
	MOVL	b+12(FP), DI
	CALL	runtimememeqbody(SB)
eqret:
	MOVB	AX, ret+24(FP)
	RET

// a in SI
// b in DI
// count in BX
TEXT runtimememeqbody(SB),NOSPLIT,$0-0
	XORL	AX, AX

	CMPL	BX, $4
	JB	small

	// 64 bytes at a time using xmm registers
hugeloop:
	CMPL	BX, $64
	JB	bigloop
	TESTL	$0x4000000, runtimecpuid_edx(SB) // check for sse2
	JE	bigloop
	MOVOU	(SI), X0
	MOVOU	(DI), X1
	MOVOU	16(SI), X2
	MOVOU	16(DI), X3
	MOVOU	32(SI), X4
	MOVOU	32(DI), X5
	MOVOU	48(SI), X6
	MOVOU	48(DI), X7
	PCMPEQB	X1, X0
	PCMPEQB	X3, X2
	PCMPEQB	X5, X4
	PCMPEQB	X7, X6
	PAND	X2, X0
	PAND	X6, X4
	PAND	X4, X0
	PMOVMSKB X0, DX
	ADDL	$64, SI
	ADDL	$64, DI
	SUBL	$64, BX
	CMPL	DX, $0xffff
	JEQ	hugeloop
	RET

	// 4 bytes at a time using 32-bit register
bigloop:
	CMPL	BX, $4
	JBE	leftover
	MOVL	(SI), CX
	MOVL	(DI), DX
	ADDL	$4, SI
	ADDL	$4, DI
	SUBL	$4, BX
	CMPL	CX, DX
	JEQ	bigloop
	RET

	// remaining 0-4 bytes
leftover:
	MOVL	-4(SI)(BX*1), CX
	MOVL	-4(DI)(BX*1), DX
	CMPL	CX, DX
	SETEQ	AX
	RET

small:
	CMPL	BX, $0
	JEQ	equal

	LEAL	0(BX*8), CX
	NEGL	CX

	MOVL	SI, DX
	CMPB	DX, $0xfc
	JA	si_high

	// load at SI won't cross a page boundary.
	MOVL	(SI), SI
	JMP	si_finish
si_high:
	// address ends in 111111xx.  Load up to bytes we want, move to correct position.
	MOVL	-4(SI)(BX*1), SI
	SHRL	CX, SI
si_finish:

	// same for DI.
	MOVL	DI, DX
	CMPB	DX, $0xfc
	JA	di_high
	MOVL	(DI), DI
	JMP	di_finish
di_high:
	MOVL	-4(DI)(BX*1), DI
	SHRL	CX, DI
di_finish:

	SUBL	SI, DI
	SHLL	CX, DI
equal:
	SETEQ	AX
	RET

TEXT runtimecmpstring(SB),NOSPLIT,$0-20
	MOVL	s1_base+0(FP), SI
	MOVL	s1_len+4(FP), BX
	MOVL	s2_base+8(FP), DI
	MOVL	s2_len+12(FP), DX
	CALL	runtimecmpbody(SB)
	MOVL	AX, ret+16(FP)
	RET

TEXT runtimecmpbytes(SB),NOSPLIT,$0-28
	MOVL	s1+0(FP), SI
	MOVL	s1+4(FP), BX
	MOVL	s2+12(FP), DI
	MOVL	s2+16(FP), DX
	CALL	runtimecmpbody(SB)
	MOVL	AX, ret+24(FP)
	RET

TEXT bytesIndexByte(SB),NOSPLIT,$0
	MOVL	s+0(FP), SI
	MOVL	s_len+4(FP), CX
	MOVB	c+12(FP), AL
	MOVL	SI, DI
	CLD; REPN; SCASB
	JZ 3(PC)
	MOVL	$-1, ret+16(FP)
	RET
	SUBL	SI, DI
	SUBL	$1, DI
	MOVL	DI, ret+16(FP)
	RET

TEXT stringsIndexByte(SB),NOSPLIT,$0
	MOVL	s+0(FP), SI
	MOVL	s_len+4(FP), CX
	MOVB	c+8(FP), AL
	MOVL	SI, DI
	CLD; REPN; SCASB
	JZ 3(PC)
	MOVL	$-1, ret+12(FP)
	RET
	SUBL	SI, DI
	SUBL	$1, DI
	MOVL	DI, ret+12(FP)
	RET

// input:
//   SI = a
//   DI = b
//   BX = alen
//   DX = blen
// output:
//   AX = 1/0/-1
TEXT runtimecmpbody(SB),NOSPLIT,$0-0
	CMPL	SI, DI
	JEQ	cmp_allsame
	CMPL	BX, DX
	MOVL	DX, BP
	CMOVLLT	BX, BP // BP = min(alen, blen)
	CMPL	BP, $4
	JB	cmp_small
	TESTL	$0x4000000, runtimecpuid_edx(SB) // check for sse2
	JE	cmp_mediumloop
cmp_largeloop:
	CMPL	BP, $16
	JB	cmp_mediumloop
	MOVOU	(SI), X0
	MOVOU	(DI), X1
	PCMPEQB X0, X1
	PMOVMSKB X1, AX
	XORL	$0xffff, AX	// convert EQ to NE
	JNE	cmp_diff16	// branch if at least one byte is not equal
	ADDL	$16, SI
	ADDL	$16, DI
	SUBL	$16, BP
	JMP	cmp_largeloop

cmp_diff16:
	BSFL	AX, BX	// index of first byte that differs
	XORL	AX, AX
	MOVB	(SI)(BX*1), CX
	CMPB	CX, (DI)(BX*1)
	SETHI	AX
	LEAL	-1(AX*2), AX	// convert 1/0 to +1/-1
	RET

cmp_mediumloop:
	CMPL	BP, $4
	JBE	cmp_0through4
	MOVL	(SI), AX
	MOVL	(DI), CX
	CMPL	AX, CX
	JNE	cmp_diff4
	ADDL	$4, SI
	ADDL	$4, DI
	SUBL	$4, BP
	JMP	cmp_mediumloop

cmp_0through4:
	MOVL	-4(SI)(BP*1), AX
	MOVL	-4(DI)(BP*1), CX
	CMPL	AX, CX
	JEQ	cmp_allsame

cmp_diff4:
	BSWAPL	AX	// reverse order of bytes
	BSWAPL	CX
	XORL	AX, CX	// find bit differences
	BSRL	CX, CX	// index of highest bit difference
	SHRL	CX, AX	// move a's bit to bottom
	ANDL	$1, AX	// mask bit
	LEAL	-1(AX*2), AX // 1/0 => +1/-1
	RET

	// 0-3 bytes in common
cmp_small:
	LEAL	(BP*8), CX
	NEGL	CX
	JEQ	cmp_allsame

	// load si
	CMPB	SI, $0xfc
	JA	cmp_si_high
	MOVL	(SI), SI
	JMP	cmp_si_finish
cmp_si_high:
	MOVL	-4(SI)(BP*1), SI
	SHRL	CX, SI
cmp_si_finish:
	SHLL	CX, SI

	// same for di
	CMPB	DI, $0xfc
	JA	cmp_di_high
	MOVL	(DI), DI
	JMP	cmp_di_finish
cmp_di_high:
	MOVL	-4(DI)(BP*1), DI
	SHRL	CX, DI
cmp_di_finish:
	SHLL	CX, DI

	BSWAPL	SI	// reverse order of bytes
	BSWAPL	DI
	XORL	SI, DI	// find bit differences
	JEQ	cmp_allsame
	BSRL	DI, CX	// index of highest bit difference
	SHRL	CX, SI	// move a's bit to bottom
	ANDL	$1, SI	// mask bit
	LEAL	-1(SI*2), AX // 1/0 => +1/-1
	RET

	// all the bytes in common are the same, so we just need
	// to compare the lengths.
cmp_allsame:
	XORL	AX, AX
	XORL	CX, CX
	CMPL	BX, DX
	SETGT	AX	// 1 if alen > blen
	SETEQ	CX	// 1 if alen == blen
	LEAL	-1(CX)(AX*2), AX	// 1,0,-1 result
	RET

// A Duff's device for zeroing memory.
// The compiler jumps to computed addresses within
// this routine to zero chunks of memory.  Do not
// change this code without also changing the code
// in ../../cmd/8g/ggen.c:clearfat.
// AX: zero
// DI: ptr to memory to be zeroed
// DI is updated as a side effect.
TEXT runtimeduffzero(SB), NOSPLIT, $0-0
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	STOSL
	RET

// A Duff's device for copying memory.
// The compiler jumps to computed addresses within
// this routine to copy chunks of memory.  Source
// and destination must not overlap.  Do not
// change this code without also changing the code
// in ../../cmd/6g/cgen.c:sgen.
// SI: ptr to source memory
// DI: ptr to destination memory
// SI and DI are updated as a side effect.

// NOTE: this is equivalent to a sequence of MOVSL but
// for some reason MOVSL is really slow.
TEXT runtimeduffcopy(SB), NOSPLIT, $0-0
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	MOVL	(SI),CX
	ADDL	$4,SI
	MOVL	CX,(DI)
	ADDL	$4,DI
	
	RET

TEXT runtimefastrand1(SB), NOSPLIT, $0-4
	get_tls(CX)
	MOVL	g(CX), AX
	MOVL	g_m(AX), AX
	MOVL	m_fastrand(AX), DX
	ADDL	DX, DX
	MOVL	DX, BX
	XORL	$0x88888eef, DX
	CMOVLMI	BX, DX
	MOVL	DX, m_fastrand(AX)
	MOVL	DX, ret+0(FP)
	RET

TEXT runtimereturn0(SB), NOSPLIT, $0
	MOVL	$0, AX
	RET

// Called from cgo wrappers, this function returns g->m->curg.stack.hi.
// Must obey the gcc calling convention.
TEXT _cgo_topofstack(SB),NOSPLIT,$0
	get_tls(CX)
	MOVL	g(CX), AX
	MOVL	g_m(AX), AX
	MOVL	m_curg(AX), AX
	MOVL	(g_stack+stack_hi)(AX), AX
	RET

// The top-most function running on a goroutine
// returns to goexit+PCQuantum.
TEXT runtimegoexit(SB),NOSPLIT,$0-0
	BYTE	$0x90	// NOP
	CALL	runtimegoexit1(SB)	// does not return
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   root/go1.4/src/runtime/asm_amd64.s                                                                  0100644 0000000 0000000 00000122534 12600426227 015301  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include "zasm_GOOS_GOARCH.h"
#include "funcdata.h"
#include "textflag.h"

TEXT runtimert0_go(SB),NOSPLIT,$0
	// copy arguments forward on an even stack
	MOVQ	DI, AX		// argc
	MOVQ	SI, BX		// argv
	SUBQ	$(4*8+7), SP		// 2args 2auto
	ANDQ	$~15, SP
	MOVQ	AX, 16(SP)
	MOVQ	BX, 24(SP)
	
	// create istack out of the given (operating system) stack.
	// _cgo_init may update stackguard.
	MOVQ	$runtimeg0(SB), DI
	LEAQ	(-64*1024+104)(SP), BX
	MOVQ	BX, g_stackguard0(DI)
	MOVQ	BX, g_stackguard1(DI)
	MOVQ	BX, (g_stack+stack_lo)(DI)
	MOVQ	SP, (g_stack+stack_hi)(DI)

	// find out information about the processor we're on
	MOVQ	$0, AX
	CPUID
	CMPQ	AX, $0
	JE	nocpuinfo
	MOVQ	$1, AX
	CPUID
	MOVL	CX, runtimecpuid_ecx(SB)
	MOVL	DX, runtimecpuid_edx(SB)
nocpuinfo:	
	
	// if there is an _cgo_init, call it.
	MOVQ	_cgo_init(SB), AX
	TESTQ	AX, AX
	JZ	needtls
	// g0 already in DI
	MOVQ	DI, CX	// Win64 uses CX for first parameter
	MOVQ	$setg_gcc<>(SB), SI
	CALL	AX

	// update stackguard after _cgo_init
	MOVQ	$runtimeg0(SB), CX
	MOVQ	(g_stack+stack_lo)(CX), AX
	ADDQ	$const_StackGuard, AX
	MOVQ	AX, g_stackguard0(CX)
	MOVQ	AX, g_stackguard1(CX)

	CMPL	runtimeiswindows(SB), $0
	JEQ ok
needtls:
	// skip TLS setup on Plan 9
	CMPL	runtimeisplan9(SB), $1
	JEQ ok
	// skip TLS setup on Solaris
	CMPL	runtimeissolaris(SB), $1
	JEQ ok

	LEAQ	runtimetls0(SB), DI
	CALL	runtimesettls(SB)

	// store through it, to make sure it works
	get_tls(BX)
	MOVQ	$0x123, g(BX)
	MOVQ	runtimetls0(SB), AX
	CMPQ	AX, $0x123
	JEQ 2(PC)
	MOVL	AX, 0	// abort
ok:
	// set the per-goroutine and per-mach "registers"
	get_tls(BX)
	LEAQ	runtimeg0(SB), CX
	MOVQ	CX, g(BX)
	LEAQ	runtimem0(SB), AX

	// save m->g0 = g0
	MOVQ	CX, m_g0(AX)
	// save m0 to g0->m
	MOVQ	AX, g_m(CX)

	CLD				// convention is D is always left cleared
	CALL	runtimecheck(SB)

	MOVL	16(SP), AX		// copy argc
	MOVL	AX, 0(SP)
	MOVQ	24(SP), AX		// copy argv
	MOVQ	AX, 8(SP)
	CALL	runtimeargs(SB)
	CALL	runtimeosinit(SB)
	CALL	runtimeschedinit(SB)

	// create a new goroutine to start program
	MOVQ	$runtimemainf(SB), BP		// entry
	PUSHQ	BP
	PUSHQ	$0			// arg size
	CALL	runtimenewproc(SB)
	POPQ	AX
	POPQ	AX

	// start this M
	CALL	runtimemstart(SB)

	MOVL	$0xf1, 0xf1  // crash
	RET

DATA	runtimemainf+0(SB)/8,$runtimemain(SB)
GLOBL	runtimemainf(SB),RODATA,$8

TEXT runtimebreakpoint(SB),NOSPLIT,$0-0
	BYTE	$0xcc
	RET

TEXT runtimeasminit(SB),NOSPLIT,$0-0
	// No per-thread init.
	RET

/*
 *  go-routine
 */

// void gosave(Gobuf*)
// save state in Gobuf; setjmp
TEXT runtimegosave(SB), NOSPLIT, $0-8
	MOVQ	buf+0(FP), AX		// gobuf
	LEAQ	buf+0(FP), BX		// caller's SP
	MOVQ	BX, gobuf_sp(AX)
	MOVQ	0(SP), BX		// caller's PC
	MOVQ	BX, gobuf_pc(AX)
	MOVQ	$0, gobuf_ret(AX)
	MOVQ	$0, gobuf_ctxt(AX)
	get_tls(CX)
	MOVQ	g(CX), BX
	MOVQ	BX, gobuf_g(AX)
	RET

// void gogo(Gobuf*)
// restore state from Gobuf; longjmp
TEXT runtimegogo(SB), NOSPLIT, $0-8
	MOVQ	buf+0(FP), BX		// gobuf
	MOVQ	gobuf_g(BX), DX
	MOVQ	0(DX), CX		// make sure g != nil
	get_tls(CX)
	MOVQ	DX, g(CX)
	MOVQ	gobuf_sp(BX), SP	// restore SP
	MOVQ	gobuf_ret(BX), AX
	MOVQ	gobuf_ctxt(BX), DX
	MOVQ	$0, gobuf_sp(BX)	// clear to help garbage collector
	MOVQ	$0, gobuf_ret(BX)
	MOVQ	$0, gobuf_ctxt(BX)
	MOVQ	gobuf_pc(BX), BX
	JMP	BX

// func mcall(fn func(*g))
// Switch to m->g0's stack, call fn(g).
// Fn must never return.  It should gogo(&g->sched)
// to keep running g.
TEXT runtimemcall(SB), NOSPLIT, $0-8
	MOVQ	fn+0(FP), DI
	
	get_tls(CX)
	MOVQ	g(CX), AX	// save state in g->sched
	MOVQ	0(SP), BX	// caller's PC
	MOVQ	BX, (g_sched+gobuf_pc)(AX)
	LEAQ	fn+0(FP), BX	// caller's SP
	MOVQ	BX, (g_sched+gobuf_sp)(AX)
	MOVQ	AX, (g_sched+gobuf_g)(AX)

	// switch to m->g0 & its stack, call fn
	MOVQ	g(CX), BX
	MOVQ	g_m(BX), BX
	MOVQ	m_g0(BX), SI
	CMPQ	SI, AX	// if g == m->g0 call badmcall
	JNE	3(PC)
	MOVQ	$runtimebadmcall(SB), AX
	JMP	AX
	MOVQ	SI, g(CX)	// g = m->g0
	MOVQ	(g_sched+gobuf_sp)(SI), SP	// sp = m->g0->sched.sp
	PUSHQ	AX
	MOVQ	DI, DX
	MOVQ	0(DI), DI
	CALL	DI
	POPQ	AX
	MOVQ	$runtimebadmcall2(SB), AX
	JMP	AX
	RET

// switchtoM is a dummy routine that onM leaves at the bottom
// of the G stack.  We need to distinguish the routine that
// lives at the bottom of the G stack from the one that lives
// at the top of the M stack because the one at the top of
// the M stack terminates the stack walk (see topofstack()).
TEXT runtimeswitchtoM(SB), NOSPLIT, $0-0
	RET

// func onM_signalok(fn func())
TEXT runtimeonM_signalok(SB), NOSPLIT, $0-8
	get_tls(CX)
	MOVQ	g(CX), AX	// AX = g
	MOVQ	g_m(AX), BX	// BX = m
	MOVQ	m_gsignal(BX), DX	// DX = gsignal
	CMPQ	AX, DX
	JEQ	ongsignal
	JMP	runtimeonM(SB)

ongsignal:
	MOVQ	fn+0(FP), DI	// DI = fn
	MOVQ	DI, DX
	MOVQ	0(DI), DI
	CALL	DI
	RET

// func onM(fn func())
TEXT runtimeonM(SB), NOSPLIT, $0-8
	MOVQ	fn+0(FP), DI	// DI = fn
	get_tls(CX)
	MOVQ	g(CX), AX	// AX = g
	MOVQ	g_m(AX), BX	// BX = m

	MOVQ	m_g0(BX), DX	// DX = g0
	CMPQ	AX, DX
	JEQ	onm

	MOVQ	m_curg(BX), BP
	CMPQ	AX, BP
	JEQ	oncurg
	
	// Not g0, not curg. Must be gsignal, but that's not allowed.
	// Hide call from linker nosplit analysis.
	MOVQ	$runtimebadonm(SB), AX
	CALL	AX

oncurg:
	// save our state in g->sched.  Pretend to
	// be switchtoM if the G stack is scanned.
	MOVQ	$runtimeswitchtoM(SB), BP
	MOVQ	BP, (g_sched+gobuf_pc)(AX)
	MOVQ	SP, (g_sched+gobuf_sp)(AX)
	MOVQ	AX, (g_sched+gobuf_g)(AX)

	// switch to g0
	MOVQ	DX, g(CX)
	MOVQ	(g_sched+gobuf_sp)(DX), BX
	// make it look like mstart called onM on g0, to stop traceback
	SUBQ	$8, BX
	MOVQ	$runtimemstart(SB), DX
	MOVQ	DX, 0(BX)
	MOVQ	BX, SP

	// call target function
	MOVQ	DI, DX
	MOVQ	0(DI), DI
	CALL	DI

	// switch back to g
	get_tls(CX)
	MOVQ	g(CX), AX
	MOVQ	g_m(AX), BX
	MOVQ	m_curg(BX), AX
	MOVQ	AX, g(CX)
	MOVQ	(g_sched+gobuf_sp)(AX), SP
	MOVQ	$0, (g_sched+gobuf_sp)(AX)
	RET

onm:
	// already on m stack, just call directly
	MOVQ	DI, DX
	MOVQ	0(DI), DI
	CALL	DI
	RET

/*
 * support for morestack
 */

// Called during function prolog when more stack is needed.
//
// The traceback routines see morestack on a g0 as being
// the top of a stack (for example, morestack calling newstack
// calling the scheduler calling newm calling gc), so we must
// record an argument size. For that purpose, it has no arguments.
TEXT runtimemorestack(SB),NOSPLIT,$0-0
	// Cannot grow scheduler stack (m->g0).
	get_tls(CX)
	MOVQ	g(CX), BX
	MOVQ	g_m(BX), BX
	MOVQ	m_g0(BX), SI
	CMPQ	g(CX), SI
	JNE	2(PC)
	INT	$3

	// Cannot grow signal stack (m->gsignal).
	MOVQ	m_gsignal(BX), SI
	CMPQ	g(CX), SI
	JNE	2(PC)
	INT	$3

	// Called from f.
	// Set m->morebuf to f's caller.
	MOVQ	8(SP), AX	// f's caller's PC
	MOVQ	AX, (m_morebuf+gobuf_pc)(BX)
	LEAQ	16(SP), AX	// f's caller's SP
	MOVQ	AX, (m_morebuf+gobuf_sp)(BX)
	get_tls(CX)
	MOVQ	g(CX), SI
	MOVQ	SI, (m_morebuf+gobuf_g)(BX)

	// Set g->sched to context in f.
	MOVQ	0(SP), AX // f's PC
	MOVQ	AX, (g_sched+gobuf_pc)(SI)
	MOVQ	SI, (g_sched+gobuf_g)(SI)
	LEAQ	8(SP), AX // f's SP
	MOVQ	AX, (g_sched+gobuf_sp)(SI)
	MOVQ	DX, (g_sched+gobuf_ctxt)(SI)

	// Call newstack on m->g0's stack.
	MOVQ	m_g0(BX), BP
	MOVQ	BP, g(CX)
	MOVQ	(g_sched+gobuf_sp)(BP), SP
	CALL	runtimenewstack(SB)
	MOVQ	$0, 0x1003	// crash if newstack returns
	RET

// morestack but not preserving ctxt.
TEXT runtimemorestack_noctxt(SB),NOSPLIT,$0
	MOVL	$0, DX
	JMP	runtimemorestack(SB)

// reflectcall: call a function with the given argument list
// func call(f *FuncVal, arg *byte, argsize, retoffset uint32).
// we don't have variable-sized frames, so we use a small number
// of constant-sized-frame functions to encode a few bits of size in the pc.
// Caution: ugly multiline assembly macros in your future!

#define DISPATCH(NAME,MAXSIZE)		\
	CMPQ	CX, $MAXSIZE;		\
	JA	3(PC);			\
	MOVQ	$NAME(SB), AX;		\
	JMP	AX
// Note: can't just "JMP NAME(SB)" - bad inlining results.

TEXT reflectcall(SB), NOSPLIT, $0-24
	MOVLQZX argsize+16(FP), CX
	DISPATCH(runtimecall16, 16)
	DISPATCH(runtimecall32, 32)
	DISPATCH(runtimecall64, 64)
	DISPATCH(runtimecall128, 128)
	DISPATCH(runtimecall256, 256)
	DISPATCH(runtimecall512, 512)
	DISPATCH(runtimecall1024, 1024)
	DISPATCH(runtimecall2048, 2048)
	DISPATCH(runtimecall4096, 4096)
	DISPATCH(runtimecall8192, 8192)
	DISPATCH(runtimecall16384, 16384)
	DISPATCH(runtimecall32768, 32768)
	DISPATCH(runtimecall65536, 65536)
	DISPATCH(runtimecall131072, 131072)
	DISPATCH(runtimecall262144, 262144)
	DISPATCH(runtimecall524288, 524288)
	DISPATCH(runtimecall1048576, 1048576)
	DISPATCH(runtimecall2097152, 2097152)
	DISPATCH(runtimecall4194304, 4194304)
	DISPATCH(runtimecall8388608, 8388608)
	DISPATCH(runtimecall16777216, 16777216)
	DISPATCH(runtimecall33554432, 33554432)
	DISPATCH(runtimecall67108864, 67108864)
	DISPATCH(runtimecall134217728, 134217728)
	DISPATCH(runtimecall268435456, 268435456)
	DISPATCH(runtimecall536870912, 536870912)
	DISPATCH(runtimecall1073741824, 1073741824)
	MOVQ	$runtimebadreflectcall(SB), AX
	JMP	AX

#define CALLFN(NAME,MAXSIZE)			\
TEXT NAME(SB), WRAPPER, $MAXSIZE-24;		\
	NO_LOCAL_POINTERS;			\
	/* copy arguments to stack */		\
	MOVQ	argptr+8(FP), SI;		\
	MOVLQZX argsize+16(FP), CX;		\
	MOVQ	SP, DI;				\
	REP;MOVSB;				\
	/* call function */			\
	MOVQ	f+0(FP), DX;			\
	PCDATA  $PCDATA_StackMapIndex, $0;	\
	CALL	(DX);				\
	/* copy return values back */		\
	MOVQ	argptr+8(FP), DI;		\
	MOVLQZX	argsize+16(FP), CX;		\
	MOVLQZX retoffset+20(FP), BX;		\
	MOVQ	SP, SI;				\
	ADDQ	BX, DI;				\
	ADDQ	BX, SI;				\
	SUBQ	BX, CX;				\
	REP;MOVSB;				\
	RET

CALLFN(call16, 16)
CALLFN(call32, 32)
CALLFN(call64, 64)
CALLFN(call128, 128)
CALLFN(call256, 256)
CALLFN(call512, 512)
CALLFN(call1024, 1024)
CALLFN(call2048, 2048)
CALLFN(call4096, 4096)
CALLFN(call8192, 8192)
CALLFN(call16384, 16384)
CALLFN(call32768, 32768)
CALLFN(call65536, 65536)
CALLFN(call131072, 131072)
CALLFN(call262144, 262144)
CALLFN(call524288, 524288)
CALLFN(call1048576, 1048576)
CALLFN(call2097152, 2097152)
CALLFN(call4194304, 4194304)
CALLFN(call8388608, 8388608)
CALLFN(call16777216, 16777216)
CALLFN(call33554432, 33554432)
CALLFN(call67108864, 67108864)
CALLFN(call134217728, 134217728)
CALLFN(call268435456, 268435456)
CALLFN(call536870912, 536870912)
CALLFN(call1073741824, 1073741824)

// bool cas(int32 *val, int32 old, int32 new)
// Atomically:
//	if(*val == old){
//		*val = new;
//		return 1;
//	} else
//		return 0;
TEXT runtimecas(SB), NOSPLIT, $0-17
	MOVQ	ptr+0(FP), BX
	MOVL	old+8(FP), AX
	MOVL	new+12(FP), CX
	LOCK
	CMPXCHGL	CX, 0(BX)
	JZ 4(PC)
	MOVL	$0, AX
	MOVB	AX, ret+16(FP)
	RET
	MOVL	$1, AX
	MOVB	AX, ret+16(FP)
	RET

// bool	runtimecas64(uint64 *val, uint64 old, uint64 new)
// Atomically:
//	if(*val == *old){
//		*val = new;
//		return 1;
//	} else {
//		return 0;
//	}
TEXT runtimecas64(SB), NOSPLIT, $0-25
	MOVQ	ptr+0(FP), BX
	MOVQ	old+8(FP), AX
	MOVQ	new+16(FP), CX
	LOCK
	CMPXCHGQ	CX, 0(BX)
	JNZ	cas64_fail
	MOVL	$1, AX
	MOVB	AX, ret+24(FP)
	RET
cas64_fail:
	MOVL	$0, AX
	MOVB	AX, ret+24(FP)
	RET
	
TEXT runtimecasuintptr(SB), NOSPLIT, $0-25
	JMP	runtimecas64(SB)

TEXT runtimeatomicloaduintptr(SB), NOSPLIT, $0-16
	JMP	runtimeatomicload64(SB)

TEXT runtimeatomicloaduint(SB), NOSPLIT, $0-16
	JMP	runtimeatomicload64(SB)

TEXT runtimeatomicstoreuintptr(SB), NOSPLIT, $0-16
	JMP	runtimeatomicstore64(SB)

// bool casp(void **val, void *old, void *new)
// Atomically:
//	if(*val == old){
//		*val = new;
//		return 1;
//	} else
//		return 0;
TEXT runtimecasp(SB), NOSPLIT, $0-25
	MOVQ	ptr+0(FP), BX
	MOVQ	old+8(FP), AX
	MOVQ	new+16(FP), CX
	LOCK
	CMPXCHGQ	CX, 0(BX)
	JZ 4(PC)
	MOVL	$0, AX
	MOVB	AX, ret+24(FP)
	RET
	MOVL	$1, AX
	MOVB	AX, ret+24(FP)
	RET

// uint32 xadd(uint32 volatile *val, int32 delta)
// Atomically:
//	*val += delta;
//	return *val;
TEXT runtimexadd(SB), NOSPLIT, $0-20
	MOVQ	ptr+0(FP), BX
	MOVL	delta+8(FP), AX
	MOVL	AX, CX
	LOCK
	XADDL	AX, 0(BX)
	ADDL	CX, AX
	MOVL	AX, ret+16(FP)
	RET

TEXT runtimexadd64(SB), NOSPLIT, $0-24
	MOVQ	ptr+0(FP), BX
	MOVQ	delta+8(FP), AX
	MOVQ	AX, CX
	LOCK
	XADDQ	AX, 0(BX)
	ADDQ	CX, AX
	MOVQ	AX, ret+16(FP)
	RET

TEXT runtimexchg(SB), NOSPLIT, $0-20
	MOVQ	ptr+0(FP), BX
	MOVL	new+8(FP), AX
	XCHGL	AX, 0(BX)
	MOVL	AX, ret+16(FP)
	RET

TEXT runtimexchg64(SB), NOSPLIT, $0-24
	MOVQ	ptr+0(FP), BX
	MOVQ	new+8(FP), AX
	XCHGQ	AX, 0(BX)
	MOVQ	AX, ret+16(FP)
	RET

TEXT runtimexchgp(SB), NOSPLIT, $0-24
	MOVQ	ptr+0(FP), BX
	MOVQ	new+8(FP), AX
	XCHGQ	AX, 0(BX)
	MOVQ	AX, ret+16(FP)
	RET

TEXT runtimexchguintptr(SB), NOSPLIT, $0-24
	JMP	runtimexchg64(SB)

TEXT runtimeprocyield(SB),NOSPLIT,$0-0
	MOVL	cycles+0(FP), AX
again:
	PAUSE
	SUBL	$1, AX
	JNZ	again
	RET

TEXT runtimeatomicstorep(SB), NOSPLIT, $0-16
	MOVQ	ptr+0(FP), BX
	MOVQ	val+8(FP), AX
	XCHGQ	AX, 0(BX)
	RET

TEXT runtimeatomicstore(SB), NOSPLIT, $0-12
	MOVQ	ptr+0(FP), BX
	MOVL	val+8(FP), AX
	XCHGL	AX, 0(BX)
	RET

TEXT runtimeatomicstore64(SB), NOSPLIT, $0-16
	MOVQ	ptr+0(FP), BX
	MOVQ	val+8(FP), AX
	XCHGQ	AX, 0(BX)
	RET

// void	runtimeatomicor8(byte volatile*, byte);
TEXT runtimeatomicor8(SB), NOSPLIT, $0-9
	MOVQ	ptr+0(FP), AX
	MOVB	val+8(FP), BX
	LOCK
	ORB	BX, (AX)
	RET

// void jmpdefer(fn, sp);
// called from deferreturn.
// 1. pop the caller
// 2. sub 5 bytes from the callers return
// 3. jmp to the argument
TEXT runtimejmpdefer(SB), NOSPLIT, $0-16
	MOVQ	fv+0(FP), DX	// fn
	MOVQ	argp+8(FP), BX	// caller sp
	LEAQ	-8(BX), SP	// caller sp after CALL
	SUBQ	$5, (SP)	// return to CALL again
	MOVQ	0(DX), BX
	JMP	BX	// but first run the deferred function

// Save state of caller into g->sched. Smashes R8, R9.
TEXT gosave<>(SB),NOSPLIT,$0
	get_tls(R8)
	MOVQ	g(R8), R8
	MOVQ	0(SP), R9
	MOVQ	R9, (g_sched+gobuf_pc)(R8)
	LEAQ	8(SP), R9
	MOVQ	R9, (g_sched+gobuf_sp)(R8)
	MOVQ	$0, (g_sched+gobuf_ret)(R8)
	MOVQ	$0, (g_sched+gobuf_ctxt)(R8)
	RET

// asmcgocall(void(*fn)(void*), void *arg)
// Call fn(arg) on the scheduler stack,
// aligned appropriately for the gcc ABI.
// See cgocall.c for more details.
TEXT asmcgocall(SB),NOSPLIT,$0-16
	MOVQ	fn+0(FP), AX
	MOVQ	arg+8(FP), BX
	CALL	asmcgocall<>(SB)
	RET

TEXT asmcgocall_errno(SB),NOSPLIT,$0-20
	MOVQ	fn+0(FP), AX
	MOVQ	arg+8(FP), BX
	CALL	asmcgocall<>(SB)
	MOVL	AX, ret+16(FP)
	RET

// asmcgocall common code. fn in AX, arg in BX. returns errno in AX.
TEXT asmcgocall<>(SB),NOSPLIT,$0-0
	MOVQ	SP, DX

	// Figure out if we need to switch to m->g0 stack.
	// We get called to create new OS threads too, and those
	// come in on the m->g0 stack already.
	get_tls(CX)
	MOVQ	g(CX), BP
	MOVQ	g_m(BP), BP
	MOVQ	m_g0(BP), SI
	MOVQ	g(CX), DI
	CMPQ	SI, DI
	JEQ	nosave
	MOVQ	m_gsignal(BP), SI
	CMPQ	SI, DI
	JEQ	nosave
	
	MOVQ	m_g0(BP), SI
	CALL	gosave<>(SB)
	MOVQ	SI, g(CX)
	MOVQ	(g_sched+gobuf_sp)(SI), SP
nosave:

	// Now on a scheduling stack (a pthread-created stack).
	// Make sure we have enough room for 4 stack-backed fast-call
	// registers as per windows amd64 calling convention.
	SUBQ	$64, SP
	ANDQ	$~15, SP	// alignment for gcc ABI
	MOVQ	DI, 48(SP)	// save g
	MOVQ	(g_stack+stack_hi)(DI), DI
	SUBQ	DX, DI
	MOVQ	DI, 40(SP)	// save depth in stack (can't just save SP, as stack might be copied during a callback)
	MOVQ	BX, DI		// DI = first argument in AMD64 ABI
	MOVQ	BX, CX		// CX = first argument in Win64
	CALL	AX

	// Restore registers, g, stack pointer.
	get_tls(CX)
	MOVQ	48(SP), DI
	MOVQ	(g_stack+stack_hi)(DI), SI
	SUBQ	40(SP), SI
	MOVQ	DI, g(CX)
	MOVQ	SI, SP
	RET

// cgocallback(void (*fn)(void*), void *frame, uintptr framesize)
// Turn the fn into a Go func (by taking its address) and call
// cgocallback_gofunc.
TEXT runtimecgocallback(SB),NOSPLIT,$24-24
	LEAQ	fn+0(FP), AX
	MOVQ	AX, 0(SP)
	MOVQ	frame+8(FP), AX
	MOVQ	AX, 8(SP)
	MOVQ	framesize+16(FP), AX
	MOVQ	AX, 16(SP)
	MOVQ	$runtimecgocallback_gofunc(SB), AX
	CALL	AX
	RET

// cgocallback_gofunc(FuncVal*, void *frame, uintptr framesize)
// See cgocall.c for more details.
TEXT cgocallback_gofunc(SB),NOSPLIT,$8-24
	NO_LOCAL_POINTERS

	// If g is nil, Go did not create the current thread.
	// Call needm to obtain one m for temporary use.
	// In this case, we're running on the thread stack, so there's
	// lots of space, but the linker doesn't know. Hide the call from
	// the linker analysis by using an indirect call through AX.
	get_tls(CX)
#ifdef GOOS_windows
	MOVL	$0, BP
	CMPQ	CX, $0
	JEQ	2(PC)
#endif
	MOVQ	g(CX), BP
	CMPQ	BP, $0
	JEQ	needm
	MOVQ	g_m(BP), BP
	MOVQ	BP, R8 // holds oldm until end of function
	JMP	havem
needm:
	MOVQ	$0, 0(SP)
	MOVQ	$runtimeneedm(SB), AX
	CALL	AX
	MOVQ	0(SP), R8
	get_tls(CX)
	MOVQ	g(CX), BP
	MOVQ	g_m(BP), BP
	
	// Set m->sched.sp = SP, so that if a panic happens
	// during the function we are about to execute, it will
	// have a valid SP to run on the g0 stack.
	// The next few lines (after the havem label)
	// will save this SP onto the stack and then write
	// the same SP back to m->sched.sp. That seems redundant,
	// but if an unrecovered panic happens, unwindm will
	// restore the g->sched.sp from the stack location
	// and then onM will try to use it. If we don't set it here,
	// that restored SP will be uninitialized (typically 0) and
	// will not be usable.
	MOVQ	m_g0(BP), SI
	MOVQ	SP, (g_sched+gobuf_sp)(SI)

havem:
	// Now there's a valid m, and we're running on its m->g0.
	// Save current m->g0->sched.sp on stack and then set it to SP.
	// Save current sp in m->g0->sched.sp in preparation for
	// switch back to m->curg stack.
	// NOTE: unwindm knows that the saved g->sched.sp is at 0(SP).
	MOVQ	m_g0(BP), SI
	MOVQ	(g_sched+gobuf_sp)(SI), AX
	MOVQ	AX, 0(SP)
	MOVQ	SP, (g_sched+gobuf_sp)(SI)

	// Switch to m->curg stack and call runtime.cgocallbackg.
	// Because we are taking over the execution of m->curg
	// but *not* resuming what had been running, we need to
	// save that information (m->curg->sched) so we can restore it.
	// We can restore m->curg->sched.sp easily, because calling
	// runtime.cgocallbackg leaves SP unchanged upon return.
	// To save m->curg->sched.pc, we push it onto the stack.
	// This has the added benefit that it looks to the traceback
	// routine like cgocallbackg is going to return to that
	// PC (because the frame we allocate below has the same
	// size as cgocallback_gofunc's frame declared above)
	// so that the traceback will seamlessly trace back into
	// the earlier calls.
	//
	// In the new goroutine, 0(SP) holds the saved R8.
	MOVQ	m_curg(BP), SI
	MOVQ	SI, g(CX)
	MOVQ	(g_sched+gobuf_sp)(SI), DI  // prepare stack as DI
	MOVQ	(g_sched+gobuf_pc)(SI), BP
	MOVQ	BP, -8(DI)
	LEAQ	-(8+8)(DI), SP
	MOVQ	R8, 0(SP)
	CALL	runtimecgocallbackg(SB)
	MOVQ	0(SP), R8

	// Restore g->sched (== m->curg->sched) from saved values.
	get_tls(CX)
	MOVQ	g(CX), SI
	MOVQ	8(SP), BP
	MOVQ	BP, (g_sched+gobuf_pc)(SI)
	LEAQ	(8+8)(SP), DI
	MOVQ	DI, (g_sched+gobuf_sp)(SI)

	// Switch back to m->g0's stack and restore m->g0->sched.sp.
	// (Unlike m->curg, the g0 goroutine never uses sched.pc,
	// so we do not have to restore it.)
	MOVQ	g(CX), BP
	MOVQ	g_m(BP), BP
	MOVQ	m_g0(BP), SI
	MOVQ	SI, g(CX)
	MOVQ	(g_sched+gobuf_sp)(SI), SP
	MOVQ	0(SP), AX
	MOVQ	AX, (g_sched+gobuf_sp)(SI)
	
	// If the m on entry was nil, we called needm above to borrow an m
	// for the duration of the call. Since the call is over, return it with dropm.
	CMPQ	R8, $0
	JNE 3(PC)
	MOVQ	$runtimedropm(SB), AX
	CALL	AX

	// Done!
	RET

// void setg(G*); set g. for use by needm.
TEXT runtimesetg(SB), NOSPLIT, $0-8
	MOVQ	gg+0(FP), BX
#ifdef GOOS_windows
	CMPQ	BX, $0
	JNE	settls
	MOVQ	$0, 0x28(GS)
	RET
settls:
	MOVQ	g_m(BX), AX
	LEAQ	m_tls(AX), AX
	MOVQ	AX, 0x28(GS)
#endif
	get_tls(CX)
	MOVQ	BX, g(CX)
	RET

// void setg_gcc(G*); set g called from gcc.
TEXT setg_gcc<>(SB),NOSPLIT,$0
	get_tls(AX)
	MOVQ	DI, g(AX)
	RET

// check that SP is in range [g->stack.lo, g->stack.hi)
TEXT runtimestackcheck(SB), NOSPLIT, $0-0
	get_tls(CX)
	MOVQ	g(CX), AX
	CMPQ	(g_stack+stack_hi)(AX), SP
	JHI	2(PC)
	INT	$3
	CMPQ	SP, (g_stack+stack_lo)(AX)
	JHI	2(PC)
	INT	$3
	RET

TEXT runtimegetcallerpc(SB),NOSPLIT,$0-16
	MOVQ	argp+0(FP),AX		// addr of first arg
	MOVQ	-8(AX),AX		// get calling pc
	MOVQ	AX, ret+8(FP)
	RET

TEXT runtimegogetcallerpc(SB),NOSPLIT,$0-16
	MOVQ	p+0(FP),AX		// addr of first arg
	MOVQ	-8(AX),AX		// get calling pc
	MOVQ	AX,ret+8(FP)
	RET

TEXT runtimesetcallerpc(SB),NOSPLIT,$0-16
	MOVQ	argp+0(FP),AX		// addr of first arg
	MOVQ	pc+8(FP), BX
	MOVQ	BX, -8(AX)		// set calling pc
	RET

TEXT runtimegetcallersp(SB),NOSPLIT,$0-16
	MOVQ	argp+0(FP), AX
	MOVQ	AX, ret+8(FP)
	RET

// func gogetcallersp(p unsafe.Pointer) uintptr
TEXT runtimegogetcallersp(SB),NOSPLIT,$0-16
	MOVQ	p+0(FP),AX		// addr of first arg
	MOVQ	AX, ret+8(FP)
	RET

// int64 runtimecputicks(void)
TEXT runtimecputicks(SB),NOSPLIT,$0-0
	RDTSC
	SHLQ	$32, DX
	ADDQ	DX, AX
	MOVQ	AX, ret+0(FP)
	RET

// hash function using AES hardware instructions
TEXT runtimeaeshash(SB),NOSPLIT,$0-32
	MOVQ	p+0(FP), AX	// ptr to data
	MOVQ	s+8(FP), CX	// size
	JMP	runtimeaeshashbody(SB)

TEXT runtimeaeshashstr(SB),NOSPLIT,$0-32
	MOVQ	p+0(FP), AX	// ptr to string struct
	// s+8(FP) is ignored, it is always sizeof(String)
	MOVQ	8(AX), CX	// length of string
	MOVQ	(AX), AX	// string data
	JMP	runtimeaeshashbody(SB)

// AX: data
// CX: length
TEXT runtimeaeshashbody(SB),NOSPLIT,$0-32
	MOVQ	h+16(FP), X0	// seed to low 64 bits of xmm0
	PINSRQ	$1, CX, X0	// size to high 64 bits of xmm0
	MOVO	runtimeaeskeysched+0(SB), X2
	MOVO	runtimeaeskeysched+16(SB), X3
	CMPQ	CX, $16
	JB	aessmall
aesloop:
	CMPQ	CX, $16
	JBE	aesloopend
	MOVOU	(AX), X1
	AESENC	X2, X0
	AESENC	X1, X0
	SUBQ	$16, CX
	ADDQ	$16, AX
	JMP	aesloop
// 1-16 bytes remaining
aesloopend:
	// This load may overlap with the previous load above.
	// We'll hash some bytes twice, but that's ok.
	MOVOU	-16(AX)(CX*1), X1
	JMP	partial
// 0-15 bytes
aessmall:
	TESTQ	CX, CX
	JE	finalize	// 0 bytes

	CMPB	AX, $0xf0
	JA	highpartial

	// 16 bytes loaded at this address won't cross
	// a page boundary, so we can load it directly.
	MOVOU	(AX), X1
	ADDQ	CX, CX
	MOVQ	$masks<>(SB), BP
	PAND	(BP)(CX*8), X1
	JMP	partial
highpartial:
	// address ends in 1111xxxx.  Might be up against
	// a page boundary, so load ending at last byte.
	// Then shift bytes down using pshufb.
	MOVOU	-16(AX)(CX*1), X1
	ADDQ	CX, CX
	MOVQ	$shifts<>(SB), BP
	PSHUFB	(BP)(CX*8), X1
partial:
	// incorporate partial block into hash
	AESENC	X3, X0
	AESENC	X1, X0
finalize:	
	// finalize hash
	AESENC	X2, X0
	AESENC	X3, X0
	AESENC	X2, X0
	MOVQ	X0, res+24(FP)
	RET

TEXT runtimeaeshash32(SB),NOSPLIT,$0-32
	MOVQ	p+0(FP), AX	// ptr to data
	// s+8(FP) is ignored, it is always sizeof(int32)
	MOVQ	h+16(FP), X0	// seed
	PINSRD	$2, (AX), X0	// data
	AESENC	runtimeaeskeysched+0(SB), X0
	AESENC	runtimeaeskeysched+16(SB), X0
	AESENC	runtimeaeskeysched+0(SB), X0
	MOVQ	X0, ret+24(FP)
	RET

TEXT runtimeaeshash64(SB),NOSPLIT,$0-32
	MOVQ	p+0(FP), AX	// ptr to data
	// s+8(FP) is ignored, it is always sizeof(int64)
	MOVQ	h+16(FP), X0	// seed
	PINSRQ	$1, (AX), X0	// data
	AESENC	runtimeaeskeysched+0(SB), X0
	AESENC	runtimeaeskeysched+16(SB), X0
	AESENC	runtimeaeskeysched+0(SB), X0
	MOVQ	X0, ret+24(FP)
	RET

// simple mask to get rid of data in the high part of the register.
DATA masks<>+0x00(SB)/8, $0x0000000000000000
DATA masks<>+0x08(SB)/8, $0x0000000000000000
DATA masks<>+0x10(SB)/8, $0x00000000000000ff
DATA masks<>+0x18(SB)/8, $0x0000000000000000
DATA masks<>+0x20(SB)/8, $0x000000000000ffff
DATA masks<>+0x28(SB)/8, $0x0000000000000000
DATA masks<>+0x30(SB)/8, $0x0000000000ffffff
DATA masks<>+0x38(SB)/8, $0x0000000000000000
DATA masks<>+0x40(SB)/8, $0x00000000ffffffff
DATA masks<>+0x48(SB)/8, $0x0000000000000000
DATA masks<>+0x50(SB)/8, $0x000000ffffffffff
DATA masks<>+0x58(SB)/8, $0x0000000000000000
DATA masks<>+0x60(SB)/8, $0x0000ffffffffffff
DATA masks<>+0x68(SB)/8, $0x0000000000000000
DATA masks<>+0x70(SB)/8, $0x00ffffffffffffff
DATA masks<>+0x78(SB)/8, $0x0000000000000000
DATA masks<>+0x80(SB)/8, $0xffffffffffffffff
DATA masks<>+0x88(SB)/8, $0x0000000000000000
DATA masks<>+0x90(SB)/8, $0xffffffffffffffff
DATA masks<>+0x98(SB)/8, $0x00000000000000ff
DATA masks<>+0xa0(SB)/8, $0xffffffffffffffff
DATA masks<>+0xa8(SB)/8, $0x000000000000ffff
DATA masks<>+0xb0(SB)/8, $0xffffffffffffffff
DATA masks<>+0xb8(SB)/8, $0x0000000000ffffff
DATA masks<>+0xc0(SB)/8, $0xffffffffffffffff
DATA masks<>+0xc8(SB)/8, $0x00000000ffffffff
DATA masks<>+0xd0(SB)/8, $0xffffffffffffffff
DATA masks<>+0xd8(SB)/8, $0x000000ffffffffff
DATA masks<>+0xe0(SB)/8, $0xffffffffffffffff
DATA masks<>+0xe8(SB)/8, $0x0000ffffffffffff
DATA masks<>+0xf0(SB)/8, $0xffffffffffffffff
DATA masks<>+0xf8(SB)/8, $0x00ffffffffffffff
GLOBL masks<>(SB),RODATA,$256

// these are arguments to pshufb.  They move data down from
// the high bytes of the register to the low bytes of the register.
// index is how many bytes to move.
DATA shifts<>+0x00(SB)/8, $0x0000000000000000
DATA shifts<>+0x08(SB)/8, $0x0000000000000000
DATA shifts<>+0x10(SB)/8, $0xffffffffffffff0f
DATA shifts<>+0x18(SB)/8, $0xffffffffffffffff
DATA shifts<>+0x20(SB)/8, $0xffffffffffff0f0e
DATA shifts<>+0x28(SB)/8, $0xffffffffffffffff
DATA shifts<>+0x30(SB)/8, $0xffffffffff0f0e0d
DATA shifts<>+0x38(SB)/8, $0xffffffffffffffff
DATA shifts<>+0x40(SB)/8, $0xffffffff0f0e0d0c
DATA shifts<>+0x48(SB)/8, $0xffffffffffffffff
DATA shifts<>+0x50(SB)/8, $0xffffff0f0e0d0c0b
DATA shifts<>+0x58(SB)/8, $0xffffffffffffffff
DATA shifts<>+0x60(SB)/8, $0xffff0f0e0d0c0b0a
DATA shifts<>+0x68(SB)/8, $0xffffffffffffffff
DATA shifts<>+0x70(SB)/8, $0xff0f0e0d0c0b0a09
DATA shifts<>+0x78(SB)/8, $0xffffffffffffffff
DATA shifts<>+0x80(SB)/8, $0x0f0e0d0c0b0a0908
DATA shifts<>+0x88(SB)/8, $0xffffffffffffffff
DATA shifts<>+0x90(SB)/8, $0x0e0d0c0b0a090807
DATA shifts<>+0x98(SB)/8, $0xffffffffffffff0f
DATA shifts<>+0xa0(SB)/8, $0x0d0c0b0a09080706
DATA shifts<>+0xa8(SB)/8, $0xffffffffffff0f0e
DATA shifts<>+0xb0(SB)/8, $0x0c0b0a0908070605
DATA shifts<>+0xb8(SB)/8, $0xffffffffff0f0e0d
DATA shifts<>+0xc0(SB)/8, $0x0b0a090807060504
DATA shifts<>+0xc8(SB)/8, $0xffffffff0f0e0d0c
DATA shifts<>+0xd0(SB)/8, $0x0a09080706050403
DATA shifts<>+0xd8(SB)/8, $0xffffff0f0e0d0c0b
DATA shifts<>+0xe0(SB)/8, $0x0908070605040302
DATA shifts<>+0xe8(SB)/8, $0xffff0f0e0d0c0b0a
DATA shifts<>+0xf0(SB)/8, $0x0807060504030201
DATA shifts<>+0xf8(SB)/8, $0xff0f0e0d0c0b0a09
GLOBL shifts<>(SB),RODATA,$256

TEXT runtimememeq(SB),NOSPLIT,$0-25
	MOVQ	a+0(FP), SI
	MOVQ	b+8(FP), DI
	MOVQ	size+16(FP), BX
	CALL	runtimememeqbody(SB)
	MOVB	AX, ret+24(FP)
	RET

// eqstring tests whether two strings are equal.
// See runtime_test.go:eqstring_generic for
// equivalent Go code.
TEXT runtimeeqstring(SB),NOSPLIT,$0-33
	MOVQ	s1len+8(FP), AX
	MOVQ	s2len+24(FP), BX
	CMPQ	AX, BX
	JNE	different
	MOVQ	s1str+0(FP), SI
	MOVQ	s2str+16(FP), DI
	CMPQ	SI, DI
	JEQ	same
	CALL	runtimememeqbody(SB)
	MOVB	AX, v+32(FP)
	RET
same:
	MOVB	$1, v+32(FP)
	RET
different:
	MOVB	$0, v+32(FP)
	RET

// a in SI
// b in DI
// count in BX
TEXT runtimememeqbody(SB),NOSPLIT,$0-0
	XORQ	AX, AX

	CMPQ	BX, $8
	JB	small
	
	// 64 bytes at a time using xmm registers
hugeloop:
	CMPQ	BX, $64
	JB	bigloop
	MOVOU	(SI), X0
	MOVOU	(DI), X1
	MOVOU	16(SI), X2
	MOVOU	16(DI), X3
	MOVOU	32(SI), X4
	MOVOU	32(DI), X5
	MOVOU	48(SI), X6
	MOVOU	48(DI), X7
	PCMPEQB	X1, X0
	PCMPEQB	X3, X2
	PCMPEQB	X5, X4
	PCMPEQB	X7, X6
	PAND	X2, X0
	PAND	X6, X4
	PAND	X4, X0
	PMOVMSKB X0, DX
	ADDQ	$64, SI
	ADDQ	$64, DI
	SUBQ	$64, BX
	CMPL	DX, $0xffff
	JEQ	hugeloop
	RET

	// 8 bytes at a time using 64-bit register
bigloop:
	CMPQ	BX, $8
	JBE	leftover
	MOVQ	(SI), CX
	MOVQ	(DI), DX
	ADDQ	$8, SI
	ADDQ	$8, DI
	SUBQ	$8, BX
	CMPQ	CX, DX
	JEQ	bigloop
	RET

	// remaining 0-8 bytes
leftover:
	MOVQ	-8(SI)(BX*1), CX
	MOVQ	-8(DI)(BX*1), DX
	CMPQ	CX, DX
	SETEQ	AX
	RET

small:
	CMPQ	BX, $0
	JEQ	equal

	LEAQ	0(BX*8), CX
	NEGQ	CX

	CMPB	SI, $0xf8
	JA	si_high

	// load at SI won't cross a page boundary.
	MOVQ	(SI), SI
	JMP	si_finish
si_high:
	// address ends in 11111xxx.  Load up to bytes we want, move to correct position.
	MOVQ	-8(SI)(BX*1), SI
	SHRQ	CX, SI
si_finish:

	// same for DI.
	CMPB	DI, $0xf8
	JA	di_high
	MOVQ	(DI), DI
	JMP	di_finish
di_high:
	MOVQ	-8(DI)(BX*1), DI
	SHRQ	CX, DI
di_finish:

	SUBQ	SI, DI
	SHLQ	CX, DI
equal:
	SETEQ	AX
	RET

TEXT runtimecmpstring(SB),NOSPLIT,$0-40
	MOVQ	s1_base+0(FP), SI
	MOVQ	s1_len+8(FP), BX
	MOVQ	s2_base+16(FP), DI
	MOVQ	s2_len+24(FP), DX
	CALL	runtimecmpbody(SB)
	MOVQ	AX, ret+32(FP)
	RET

TEXT runtimecmpbytes(SB),NOSPLIT,$0-56
	MOVQ	s1+0(FP), SI
	MOVQ	s1+8(FP), BX
	MOVQ	s2+24(FP), DI
	MOVQ	s2+32(FP), DX
	CALL	runtimecmpbody(SB)
	MOVQ	AX, res+48(FP)
	RET

// input:
//   SI = a
//   DI = b
//   BX = alen
//   DX = blen
// output:
//   AX = 1/0/-1
TEXT runtimecmpbody(SB),NOSPLIT,$0-0
	CMPQ	SI, DI
	JEQ	cmp_allsame
	CMPQ	BX, DX
	MOVQ	DX, BP
	CMOVQLT	BX, BP // BP = min(alen, blen) = # of bytes to compare
	CMPQ	BP, $8
	JB	cmp_small

cmp_loop:
	CMPQ	BP, $16
	JBE	cmp_0through16
	MOVOU	(SI), X0
	MOVOU	(DI), X1
	PCMPEQB X0, X1
	PMOVMSKB X1, AX
	XORQ	$0xffff, AX	// convert EQ to NE
	JNE	cmp_diff16	// branch if at least one byte is not equal
	ADDQ	$16, SI
	ADDQ	$16, DI
	SUBQ	$16, BP
	JMP	cmp_loop
	
	// AX = bit mask of differences
cmp_diff16:
	BSFQ	AX, BX	// index of first byte that differs
	XORQ	AX, AX
	MOVB	(SI)(BX*1), CX
	CMPB	CX, (DI)(BX*1)
	SETHI	AX
	LEAQ	-1(AX*2), AX	// convert 1/0 to +1/-1
	RET

	// 0 through 16 bytes left, alen>=8, blen>=8
cmp_0through16:
	CMPQ	BP, $8
	JBE	cmp_0through8
	MOVQ	(SI), AX
	MOVQ	(DI), CX
	CMPQ	AX, CX
	JNE	cmp_diff8
cmp_0through8:
	MOVQ	-8(SI)(BP*1), AX
	MOVQ	-8(DI)(BP*1), CX
	CMPQ	AX, CX
	JEQ	cmp_allsame

	// AX and CX contain parts of a and b that differ.
cmp_diff8:
	BSWAPQ	AX	// reverse order of bytes
	BSWAPQ	CX
	XORQ	AX, CX
	BSRQ	CX, CX	// index of highest bit difference
	SHRQ	CX, AX	// move a's bit to bottom
	ANDQ	$1, AX	// mask bit
	LEAQ	-1(AX*2), AX // 1/0 => +1/-1
	RET

	// 0-7 bytes in common
cmp_small:
	LEAQ	(BP*8), CX	// bytes left -> bits left
	NEGQ	CX		//  - bits lift (== 64 - bits left mod 64)
	JEQ	cmp_allsame

	// load bytes of a into high bytes of AX
	CMPB	SI, $0xf8
	JA	cmp_si_high
	MOVQ	(SI), SI
	JMP	cmp_si_finish
cmp_si_high:
	MOVQ	-8(SI)(BP*1), SI
	SHRQ	CX, SI
cmp_si_finish:
	SHLQ	CX, SI

	// load bytes of b in to high bytes of BX
	CMPB	DI, $0xf8
	JA	cmp_di_high
	MOVQ	(DI), DI
	JMP	cmp_di_finish
cmp_di_high:
	MOVQ	-8(DI)(BP*1), DI
	SHRQ	CX, DI
cmp_di_finish:
	SHLQ	CX, DI

	BSWAPQ	SI	// reverse order of bytes
	BSWAPQ	DI
	XORQ	SI, DI	// find bit differences
	JEQ	cmp_allsame
	BSRQ	DI, CX	// index of highest bit difference
	SHRQ	CX, SI	// move a's bit to bottom
	ANDQ	$1, SI	// mask bit
	LEAQ	-1(SI*2), AX // 1/0 => +1/-1
	RET

cmp_allsame:
	XORQ	AX, AX
	XORQ	CX, CX
	CMPQ	BX, DX
	SETGT	AX	// 1 if alen > blen
	SETEQ	CX	// 1 if alen == blen
	LEAQ	-1(CX)(AX*2), AX	// 1,0,-1 result
	RET

TEXT bytesIndexByte(SB),NOSPLIT,$0
	MOVQ s+0(FP), SI
	MOVQ s_len+8(FP), BX
	MOVB c+24(FP), AL
	CALL runtimeindexbytebody(SB)
	MOVQ AX, ret+32(FP)
	RET

TEXT stringsIndexByte(SB),NOSPLIT,$0
	MOVQ s+0(FP), SI
	MOVQ s_len+8(FP), BX
	MOVB c+16(FP), AL
	CALL runtimeindexbytebody(SB)
	MOVQ AX, ret+24(FP)
	RET

// input:
//   SI: data
//   BX: data len
//   AL: byte sought
// output:
//   AX
TEXT runtimeindexbytebody(SB),NOSPLIT,$0
	MOVQ SI, DI

	CMPQ BX, $16
	JLT indexbyte_small

	// round up to first 16-byte boundary
	TESTQ $15, SI
	JZ aligned
	MOVQ SI, CX
	ANDQ $~15, CX
	ADDQ $16, CX

	// search the beginning
	SUBQ SI, CX
	REPN; SCASB
	JZ success

// DI is 16-byte aligned; get ready to search using SSE instructions
aligned:
	// round down to last 16-byte boundary
	MOVQ BX, R11
	ADDQ SI, R11
	ANDQ $~15, R11

	// shuffle X0 around so that each byte contains c
	MOVD AX, X0
	PUNPCKLBW X0, X0
	PUNPCKLBW X0, X0
	PSHUFL $0, X0, X0
	JMP condition

sse:
	// move the next 16-byte chunk of the buffer into X1
	MOVO (DI), X1
	// compare bytes in X0 to X1
	PCMPEQB X0, X1
	// take the top bit of each byte in X1 and put the result in DX
	PMOVMSKB X1, DX
	TESTL DX, DX
	JNZ ssesuccess
	ADDQ $16, DI

condition:
	CMPQ DI, R11
	JLT sse

	// search the end
	MOVQ SI, CX
	ADDQ BX, CX
	SUBQ R11, CX
	// if CX == 0, the zero flag will be set and we'll end up
	// returning a false success
	JZ failure
	REPN; SCASB
	JZ success

failure:
	MOVQ $-1, AX
	RET

// handle for lengths < 16
indexbyte_small:
	MOVQ BX, CX
	REPN; SCASB
	JZ success
	MOVQ $-1, AX
	RET

// we've found the chunk containing the byte
// now just figure out which specific byte it is
ssesuccess:
	// get the index of the least significant set bit
	BSFW DX, DX
	SUBQ SI, DI
	ADDQ DI, DX
	MOVQ DX, AX
	RET

success:
	SUBQ SI, DI
	SUBL $1, DI
	MOVQ DI, AX
	RET

TEXT bytesEqual(SB),NOSPLIT,$0-49
	MOVQ	a_len+8(FP), BX
	MOVQ	b_len+32(FP), CX
	XORQ	AX, AX
	CMPQ	BX, CX
	JNE	eqret
	MOVQ	a+0(FP), SI
	MOVQ	b+24(FP), DI
	CALL	runtimememeqbody(SB)
eqret:
	MOVB	AX, ret+48(FP)
	RET

// A Duff's device for zeroing memory.
// The compiler jumps to computed addresses within
// this routine to zero chunks of memory.  Do not
// change this code without also changing the code
// in ../../cmd/6g/ggen.c:clearfat.
// AX: zero
// DI: ptr to memory to be zeroed
// DI is updated as a side effect.
TEXT runtimeduffzero(SB), NOSPLIT, $0-0
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	STOSQ
	RET

// A Duff's device for copying memory.
// The compiler jumps to computed addresses within
// this routine to copy chunks of memory.  Source
// and destination must not overlap.  Do not
// change this code without also changing the code
// in ../../cmd/6g/cgen.c:sgen.
// SI: ptr to source memory
// DI: ptr to destination memory
// SI and DI are updated as a side effect.

// NOTE: this is equivalent to a sequence of MOVSQ but
// for some reason that is 3.5x slower than this code.
// The STOSQ above seem fine, though.
TEXT runtimeduffcopy(SB), NOSPLIT, $0-0
	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	MOVQ	(SI),CX
	ADDQ	$8,SI
	MOVQ	CX,(DI)
	ADDQ	$8,DI

	RET

TEXT runtimefastrand1(SB), NOSPLIT, $0-4
	get_tls(CX)
	MOVQ	g(CX), AX
	MOVQ	g_m(AX), AX
	MOVL	m_fastrand(AX), DX
	ADDL	DX, DX
	MOVL	DX, BX
	XORL	$0x88888eef, DX
	CMOVLMI	BX, DX
	MOVL	DX, m_fastrand(AX)
	MOVL	DX, ret+0(FP)
	RET

TEXT runtimereturn0(SB), NOSPLIT, $0
	MOVL	$0, AX
	RET


// Called from cgo wrappers, this function returns g->m->curg.stack.hi.
// Must obey the gcc calling convention.
TEXT _cgo_topofstack(SB),NOSPLIT,$0
	get_tls(CX)
	MOVQ	g(CX), AX
	MOVQ	g_m(AX), AX
	MOVQ	m_curg(AX), AX
	MOVQ	(g_stack+stack_hi)(AX), AX
	RET

// The top-most function running on a goroutine
// returns to goexit+PCQuantum.
TEXT runtimegoexit(SB),NOSPLIT,$0-0
	BYTE	$0x90	// NOP
	CALL	runtimegoexit1(SB)	// does not return
                                                                                                                                                                    root/go1.4/src/runtime/asm_amd64p32.s                                                               0100644 0000000 0000000 00000053424 12600426227 015627  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include "zasm_GOOS_GOARCH.h"
#include "funcdata.h"
#include "textflag.h"

TEXT runtimert0_go(SB),NOSPLIT,$0
	// copy arguments forward on an even stack
	MOVL	argc+0(FP), AX
	MOVL	argv+4(FP), BX
	MOVL	SP, CX
	SUBL	$128, SP		// plenty of scratch
	ANDL	$~15, CX
	MOVL	CX, SP

	MOVL	AX, 16(SP)
	MOVL	BX, 24(SP)
	
	// create istack out of the given (operating system) stack.
	MOVL	$runtimeg0(SB), DI
	LEAL	(-64*1024+104)(SP), BX
	MOVL	BX, g_stackguard0(DI)
	MOVL	BX, g_stackguard1(DI)
	MOVL	BX, (g_stack+stack_lo)(DI)
	MOVL	SP, (g_stack+stack_hi)(DI)

	// find out information about the processor we're on
	MOVQ	$0, AX
	CPUID
	CMPQ	AX, $0
	JE	nocpuinfo
	MOVQ	$1, AX
	CPUID
	MOVL	CX, runtimecpuid_ecx(SB)
	MOVL	DX, runtimecpuid_edx(SB)
nocpuinfo:	
	
needtls:
	LEAL	runtimetls0(SB), DI
	CALL	runtimesettls(SB)

	// store through it, to make sure it works
	get_tls(BX)
	MOVQ	$0x123, g(BX)
	MOVQ	runtimetls0(SB), AX
	CMPQ	AX, $0x123
	JEQ 2(PC)
	MOVL	AX, 0	// abort
ok:
	// set the per-goroutine and per-mach "registers"
	get_tls(BX)
	LEAL	runtimeg0(SB), CX
	MOVL	CX, g(BX)
	LEAL	runtimem0(SB), AX

	// save m->g0 = g0
	MOVL	CX, m_g0(AX)
	// save m0 to g0->m
	MOVL	AX, g_m(CX)

	CLD				// convention is D is always left cleared
	CALL	runtimecheck(SB)

	MOVL	16(SP), AX		// copy argc
	MOVL	AX, 0(SP)
	MOVL	24(SP), AX		// copy argv
	MOVL	AX, 4(SP)
	CALL	runtimeargs(SB)
	CALL	runtimeosinit(SB)
	CALL	runtimeschedinit(SB)

	// create a new goroutine to start program
	MOVL	$runtimemainf(SB), AX	// entry
	MOVL	$0, 0(SP)
	MOVL	AX, 4(SP)
	CALL	runtimenewproc(SB)

	// start this M
	CALL	runtimemstart(SB)

	MOVL	$0xf1, 0xf1  // crash
	RET

DATA	runtimemainf+0(SB)/4,$runtimemain(SB)
GLOBL	runtimemainf(SB),RODATA,$4

TEXT runtimebreakpoint(SB),NOSPLIT,$0-0
	INT $3
	RET

TEXT runtimeasminit(SB),NOSPLIT,$0-0
	// No per-thread init.
	RET

/*
 *  go-routine
 */

// void gosave(Gobuf*)
// save state in Gobuf; setjmp
TEXT runtimegosave(SB), NOSPLIT, $0-4
	MOVL	buf+0(FP), AX	// gobuf
	LEAL	buf+0(FP), BX	// caller's SP
	MOVL	BX, gobuf_sp(AX)
	MOVL	0(SP), BX		// caller's PC
	MOVL	BX, gobuf_pc(AX)
	MOVL	$0, gobuf_ctxt(AX)
	MOVQ	$0, gobuf_ret(AX)
	get_tls(CX)
	MOVL	g(CX), BX
	MOVL	BX, gobuf_g(AX)
	RET

// void gogo(Gobuf*)
// restore state from Gobuf; longjmp
TEXT runtimegogo(SB), NOSPLIT, $0-4
	MOVL	buf+0(FP), BX		// gobuf
	MOVL	gobuf_g(BX), DX
	MOVL	0(DX), CX		// make sure g != nil
	get_tls(CX)
	MOVL	DX, g(CX)
	MOVL	gobuf_sp(BX), SP	// restore SP
	MOVL	gobuf_ctxt(BX), DX
	MOVQ	gobuf_ret(BX), AX
	MOVL	$0, gobuf_sp(BX)	// clear to help garbage collector
	MOVQ	$0, gobuf_ret(BX)
	MOVL	$0, gobuf_ctxt(BX)
	MOVL	gobuf_pc(BX), BX
	JMP	BX

// func mcall(fn func(*g))
// Switch to m->g0's stack, call fn(g).
// Fn must never return.  It should gogo(&g->sched)
// to keep running g.
TEXT runtimemcall(SB), NOSPLIT, $0-4
	MOVL	fn+0(FP), DI
	
	get_tls(CX)
	MOVL	g(CX), AX	// save state in g->sched
	MOVL	0(SP), BX	// caller's PC
	MOVL	BX, (g_sched+gobuf_pc)(AX)
	LEAL	fn+0(FP), BX	// caller's SP
	MOVL	BX, (g_sched+gobuf_sp)(AX)
	MOVL	AX, (g_sched+gobuf_g)(AX)

	// switch to m->g0 & its stack, call fn
	MOVL	g(CX), BX
	MOVL	g_m(BX), BX
	MOVL	m_g0(BX), SI
	CMPL	SI, AX	// if g == m->g0 call badmcall
	JNE	3(PC)
	MOVL	$runtimebadmcall(SB), AX
	JMP	AX
	MOVL	SI, g(CX)	// g = m->g0
	MOVL	(g_sched+gobuf_sp)(SI), SP	// sp = m->g0->sched.sp
	PUSHQ	AX
	MOVL	DI, DX
	MOVL	0(DI), DI
	CALL	DI
	POPQ	AX
	MOVL	$runtimebadmcall2(SB), AX
	JMP	AX
	RET

// switchtoM is a dummy routine that onM leaves at the bottom
// of the G stack.  We need to distinguish the routine that
// lives at the bottom of the G stack from the one that lives
// at the top of the M stack because the one at the top of
// the M stack terminates the stack walk (see topofstack()).
TEXT runtimeswitchtoM(SB), NOSPLIT, $0-0
	RET

// func onM_signalok(fn func())
TEXT runtimeonM_signalok(SB), NOSPLIT, $0-4
	get_tls(CX)
	MOVL	g(CX), AX	// AX = g
	MOVL	g_m(AX), BX	// BX = m
	MOVL	m_gsignal(BX), DX	// DX = gsignal
	CMPL	AX, DX
	JEQ	ongsignal
	JMP	runtimeonM(SB)

ongsignal:
	MOVL	fn+0(FP), DI	// DI = fn
	MOVL	DI, DX
	MOVL	0(DI), DI
	CALL	DI
	RET

// func onM(fn func())
TEXT runtimeonM(SB), NOSPLIT, $0-4
	MOVL	fn+0(FP), DI	// DI = fn
	get_tls(CX)
	MOVL	g(CX), AX	// AX = g
	MOVL	g_m(AX), BX	// BX = m

	MOVL	m_g0(BX), DX	// DX = g0
	CMPL	AX, DX
	JEQ	onm

	MOVL	m_curg(BX), R8
	CMPL	AX, R8
	JEQ	oncurg
	
	// Not g0, not curg. Must be gsignal, but that's not allowed.
	// Hide call from linker nosplit analysis.
	MOVL	$runtimebadonm(SB), AX
	CALL	AX

oncurg:
	// save our state in g->sched.  Pretend to
	// be switchtoM if the G stack is scanned.
	MOVL	$runtimeswitchtoM(SB), SI
	MOVL	SI, (g_sched+gobuf_pc)(AX)
	MOVL	SP, (g_sched+gobuf_sp)(AX)
	MOVL	AX, (g_sched+gobuf_g)(AX)

	// switch to g0
	MOVL	DX, g(CX)
	MOVL	(g_sched+gobuf_sp)(DX), SP

	// call target function
	MOVL	DI, DX
	MOVL	0(DI), DI
	CALL	DI

	// switch back to g
	get_tls(CX)
	MOVL	g(CX), AX
	MOVL	g_m(AX), BX
	MOVL	m_curg(BX), AX
	MOVL	AX, g(CX)
	MOVL	(g_sched+gobuf_sp)(AX), SP
	MOVL	$0, (g_sched+gobuf_sp)(AX)
	RET

onm:
	// already on m stack, just call directly
	MOVL	DI, DX
	MOVL	0(DI), DI
	CALL	DI
	RET

/*
 * support for morestack
 */

// Called during function prolog when more stack is needed.
//
// The traceback routines see morestack on a g0 as being
// the top of a stack (for example, morestack calling newstack
// calling the scheduler calling newm calling gc), so we must
// record an argument size. For that purpose, it has no arguments.
TEXT runtimemorestack(SB),NOSPLIT,$0-0
	get_tls(CX)
	MOVL	g(CX), BX
	MOVL	g_m(BX), BX

	// Cannot grow scheduler stack (m->g0).
	MOVL	m_g0(BX), SI
	CMPL	g(CX), SI
	JNE	2(PC)
	MOVL	0, AX

	// Cannot grow signal stack (m->gsignal).
	MOVL	m_gsignal(BX), SI
	CMPL	g(CX), SI
	JNE	2(PC)
	MOVL	0, AX

	// Called from f.
	// Set m->morebuf to f's caller.
	MOVL	8(SP), AX	// f's caller's PC
	MOVL	AX, (m_morebuf+gobuf_pc)(BX)
	LEAL	16(SP), AX	// f's caller's SP
	MOVL	AX, (m_morebuf+gobuf_sp)(BX)
	get_tls(CX)
	MOVL	g(CX), SI
	MOVL	SI, (m_morebuf+gobuf_g)(BX)

	// Set g->sched to context in f.
	MOVL	0(SP), AX // f's PC
	MOVL	AX, (g_sched+gobuf_pc)(SI)
	MOVL	SI, (g_sched+gobuf_g)(SI)
	LEAL	8(SP), AX // f's SP
	MOVL	AX, (g_sched+gobuf_sp)(SI)
	MOVL	DX, (g_sched+gobuf_ctxt)(SI)

	// Call newstack on m->g0's stack.
	MOVL	m_g0(BX), BX
	MOVL	BX, g(CX)
	MOVL	(g_sched+gobuf_sp)(BX), SP
	CALL	runtimenewstack(SB)
	MOVL	$0, 0x1003	// crash if newstack returns
	RET

// morestack trampolines
TEXT runtimemorestack_noctxt(SB),NOSPLIT,$0
	MOVL	$0, DX
	JMP	runtimemorestack(SB)

// reflectcall: call a function with the given argument list
// func call(f *FuncVal, arg *byte, argsize, retoffset uint32).
// we don't have variable-sized frames, so we use a small number
// of constant-sized-frame functions to encode a few bits of size in the pc.
// Caution: ugly multiline assembly macros in your future!

#define DISPATCH(NAME,MAXSIZE)		\
	CMPL	CX, $MAXSIZE;		\
	JA	3(PC);			\
	MOVL	$NAME(SB), AX;		\
	JMP	AX
// Note: can't just "JMP NAME(SB)" - bad inlining results.

TEXT reflectcall(SB), NOSPLIT, $0-16
	MOVLQZX argsize+8(FP), CX
	DISPATCH(runtimecall16, 16)
	DISPATCH(runtimecall32, 32)
	DISPATCH(runtimecall64, 64)
	DISPATCH(runtimecall128, 128)
	DISPATCH(runtimecall256, 256)
	DISPATCH(runtimecall512, 512)
	DISPATCH(runtimecall1024, 1024)
	DISPATCH(runtimecall2048, 2048)
	DISPATCH(runtimecall4096, 4096)
	DISPATCH(runtimecall8192, 8192)
	DISPATCH(runtimecall16384, 16384)
	DISPATCH(runtimecall32768, 32768)
	DISPATCH(runtimecall65536, 65536)
	DISPATCH(runtimecall131072, 131072)
	DISPATCH(runtimecall262144, 262144)
	DISPATCH(runtimecall524288, 524288)
	DISPATCH(runtimecall1048576, 1048576)
	DISPATCH(runtimecall2097152, 2097152)
	DISPATCH(runtimecall4194304, 4194304)
	DISPATCH(runtimecall8388608, 8388608)
	DISPATCH(runtimecall16777216, 16777216)
	DISPATCH(runtimecall33554432, 33554432)
	DISPATCH(runtimecall67108864, 67108864)
	DISPATCH(runtimecall134217728, 134217728)
	DISPATCH(runtimecall268435456, 268435456)
	DISPATCH(runtimecall536870912, 536870912)
	DISPATCH(runtimecall1073741824, 1073741824)
	MOVL	$runtimebadreflectcall(SB), AX
	JMP	AX

#define CALLFN(NAME,MAXSIZE)			\
TEXT NAME(SB), WRAPPER, $MAXSIZE-16;		\
	NO_LOCAL_POINTERS;			\
	/* copy arguments to stack */		\
	MOVL	argptr+4(FP), SI;		\
	MOVL	argsize+8(FP), CX;		\
	MOVL	SP, DI;				\
	REP;MOVSB;				\
	/* call function */			\
	MOVL	f+0(FP), DX;			\
	MOVL	(DX), AX;			\
	CALL	AX;				\
	/* copy return values back */		\
	MOVL	argptr+4(FP), DI;		\
	MOVL	argsize+8(FP), CX;		\
	MOVL	retoffset+12(FP), BX;		\
	MOVL	SP, SI;				\
	ADDL	BX, DI;				\
	ADDL	BX, SI;				\
	SUBL	BX, CX;				\
	REP;MOVSB;				\
	RET

CALLFN(call16, 16)
CALLFN(call32, 32)
CALLFN(call64, 64)
CALLFN(call128, 128)
CALLFN(call256, 256)
CALLFN(call512, 512)
CALLFN(call1024, 1024)
CALLFN(call2048, 2048)
CALLFN(call4096, 4096)
CALLFN(call8192, 8192)
CALLFN(call16384, 16384)
CALLFN(call32768, 32768)
CALLFN(call65536, 65536)
CALLFN(call131072, 131072)
CALLFN(call262144, 262144)
CALLFN(call524288, 524288)
CALLFN(call1048576, 1048576)
CALLFN(call2097152, 2097152)
CALLFN(call4194304, 4194304)
CALLFN(call8388608, 8388608)
CALLFN(call16777216, 16777216)
CALLFN(call33554432, 33554432)
CALLFN(call67108864, 67108864)
CALLFN(call134217728, 134217728)
CALLFN(call268435456, 268435456)
CALLFN(call536870912, 536870912)
CALLFN(call1073741824, 1073741824)

// bool cas(int32 *val, int32 old, int32 new)
// Atomically:
//	if(*val == old){
//		*val = new;
//		return 1;
//	} else
//		return 0;
TEXT runtimecas(SB), NOSPLIT, $0-17
	MOVL	ptr+0(FP), BX
	MOVL	old+4(FP), AX
	MOVL	new+8(FP), CX
	LOCK
	CMPXCHGL	CX, 0(BX)
	JZ 4(PC)
	MOVL	$0, AX
	MOVB	AX, ret+16(FP)
	RET
	MOVL	$1, AX
	MOVB	AX, ret+16(FP)
	RET

TEXT runtimecasuintptr(SB), NOSPLIT, $0-17
	JMP	runtimecas(SB)

TEXT runtimeatomicloaduintptr(SB), NOSPLIT, $0-12
	JMP	runtimeatomicload(SB)

TEXT runtimeatomicloaduint(SB), NOSPLIT, $0-12
	JMP	runtimeatomicload(SB)

TEXT runtimeatomicstoreuintptr(SB), NOSPLIT, $0-12
	JMP	runtimeatomicstore(SB)

// bool	runtimecas64(uint64 *val, uint64 old, uint64 new)
// Atomically:
//	if(*val == *old){
//		*val = new;
//		return 1;
//	} else {
//		return 0;
//	}
TEXT runtimecas64(SB), NOSPLIT, $0-25
	MOVL	ptr+0(FP), BX
	MOVQ	old+8(FP), AX
	MOVQ	new+16(FP), CX
	LOCK
	CMPXCHGQ	CX, 0(BX)
	JNZ	cas64_fail
	MOVL	$1, AX
	MOVB	AX, ret+24(FP)
	RET
cas64_fail:
	MOVL	$0, AX
	MOVB	AX, ret+24(FP)
	RET

// bool casp(void **val, void *old, void *new)
// Atomically:
//	if(*val == old){
//		*val = new;
//		return 1;
//	} else
//		return 0;
TEXT runtimecasp(SB), NOSPLIT, $0-17
	MOVL	ptr+0(FP), BX
	MOVL	old+4(FP), AX
	MOVL	new+8(FP), CX
	LOCK
	CMPXCHGL	CX, 0(BX)
	JZ 4(PC)
	MOVL	$0, AX
	MOVB	AX, ret+16(FP)
	RET
	MOVL	$1, AX
	MOVB	AX, ret+16(FP)
	RET

// uint32 xadd(uint32 volatile *val, int32 delta)
// Atomically:
//	*val += delta;
//	return *val;
TEXT runtimexadd(SB), NOSPLIT, $0-12
	MOVL	ptr+0(FP), BX
	MOVL	delta+4(FP), AX
	MOVL	AX, CX
	LOCK
	XADDL	AX, 0(BX)
	ADDL	CX, AX
	MOVL	AX, ret+8(FP)
	RET

TEXT runtimexadd64(SB), NOSPLIT, $0-24
	MOVL	ptr+0(FP), BX
	MOVQ	delta+8(FP), AX
	MOVQ	AX, CX
	LOCK
	XADDQ	AX, 0(BX)
	ADDQ	CX, AX
	MOVQ	AX, ret+16(FP)
	RET

TEXT runtimexchg(SB), NOSPLIT, $0-12
	MOVL	ptr+0(FP), BX
	MOVL	new+4(FP), AX
	XCHGL	AX, 0(BX)
	MOVL	AX, ret+8(FP)
	RET

TEXT runtimexchg64(SB), NOSPLIT, $0-24
	MOVL	ptr+0(FP), BX
	MOVQ	new+8(FP), AX
	XCHGQ	AX, 0(BX)
	MOVQ	AX, ret+16(FP)
	RET

TEXT runtimexchgp(SB), NOSPLIT, $0-12
	MOVL	ptr+0(FP), BX
	MOVL	new+4(FP), AX
	XCHGL	AX, 0(BX)
	MOVL	AX, ret+8(FP)
	RET

TEXT runtimexchguintptr(SB), NOSPLIT, $0-12
	JMP	runtimexchg(SB)

TEXT runtimeprocyield(SB),NOSPLIT,$0-0
	MOVL	cycles+0(FP), AX
again:
	PAUSE
	SUBL	$1, AX
	JNZ	again
	RET

TEXT runtimeatomicstorep(SB), NOSPLIT, $0-8
	MOVL	ptr+0(FP), BX
	MOVL	val+4(FP), AX
	XCHGL	AX, 0(BX)
	RET

TEXT runtimeatomicstore(SB), NOSPLIT, $0-8
	MOVL	ptr+0(FP), BX
	MOVL	val+4(FP), AX
	XCHGL	AX, 0(BX)
	RET

TEXT runtimeatomicstore64(SB), NOSPLIT, $0-16
	MOVL	ptr+0(FP), BX
	MOVQ	val+8(FP), AX
	XCHGQ	AX, 0(BX)
	RET

// void	runtimeatomicor8(byte volatile*, byte);
TEXT runtimeatomicor8(SB), NOSPLIT, $0-5
	MOVL	ptr+0(FP), BX
	MOVB	val+4(FP), AX
	LOCK
	ORB	AX, 0(BX)
	RET

// void jmpdefer(fn, sp);
// called from deferreturn.
// 1. pop the caller
// 2. sub 5 bytes from the callers return
// 3. jmp to the argument
TEXT runtimejmpdefer(SB), NOSPLIT, $0-8
	MOVL	fv+0(FP), DX
	MOVL	argp+4(FP), BX
	LEAL	-8(BX), SP	// caller sp after CALL
	SUBL	$5, (SP)	// return to CALL again
	MOVL	0(DX), BX
	JMP	BX	// but first run the deferred function

// asmcgocall(void(*fn)(void*), void *arg)
// Not implemented.
TEXT runtimeasmcgocall(SB),NOSPLIT,$0-8
	MOVL	0, AX
	RET

// asmcgocall(void(*fn)(void*), void *arg)
// Not implemented.
TEXT runtimeasmcgocall_errno(SB),NOSPLIT,$0-12
	MOVL	0, AX
	RET

// cgocallback(void (*fn)(void*), void *frame, uintptr framesize)
// Not implemented.
TEXT runtimecgocallback(SB),NOSPLIT,$0-12
	MOVL	0, AX
	RET

// void setg(G*); set g. for use by needm.
// Not implemented.
TEXT runtimesetg(SB), NOSPLIT, $0-4
	MOVL	0, AX
	RET

// check that SP is in range [g->stack.lo, g->stack.hi)
TEXT runtimestackcheck(SB), NOSPLIT, $0-0
	get_tls(CX)
	MOVL	g(CX), AX
	CMPL	(g_stack+stack_hi)(AX), SP
	JHI	2(PC)
	MOVL	0, AX
	CMPL	SP, (g_stack+stack_lo)(AX)
	JHI	2(PC)
	MOVL	0, AX
	RET

TEXT runtimememclr(SB),NOSPLIT,$0-8
	MOVL	ptr+0(FP), DI
	MOVL	n+4(FP), CX
	MOVQ	CX, BX
	ANDQ	$7, BX
	SHRQ	$3, CX
	MOVQ	$0, AX
	CLD
	REP
	STOSQ
	MOVQ	BX, CX
	REP
	STOSB
	RET

TEXT runtimegetcallerpc(SB),NOSPLIT,$0-12
	MOVL	argp+0(FP),AX		// addr of first arg
	MOVL	-8(AX),AX		// get calling pc
	MOVL	AX, ret+8(FP)
	RET

TEXT runtimegogetcallerpc(SB),NOSPLIT,$0-12
	MOVL	p+0(FP),AX		// addr of first arg
	MOVL	-8(AX),AX		// get calling pc
	MOVL	AX, ret+8(FP)
	RET

TEXT runtimesetcallerpc(SB),NOSPLIT,$0-8
	MOVL	argp+0(FP),AX		// addr of first arg
	MOVL	pc+4(FP), BX		// pc to set
	MOVQ	BX, -8(AX)		// set calling pc
	RET

TEXT runtimegetcallersp(SB),NOSPLIT,$0-12
	MOVL	argp+0(FP), AX
	MOVL	AX, ret+8(FP)
	RET

// func gogetcallersp(p unsafe.Pointer) uintptr
TEXT runtimegogetcallersp(SB),NOSPLIT,$0-12
	MOVL	p+0(FP),AX		// addr of first arg
	MOVL	AX, ret+8(FP)
	RET

// int64 runtimecputicks(void)
TEXT runtimecputicks(SB),NOSPLIT,$0-0
	RDTSC
	SHLQ	$32, DX
	ADDQ	DX, AX
	MOVQ	AX, ret+0(FP)
	RET

// hash function using AES hardware instructions
// For now, our one amd64p32 system (NaCl) does not
// support using AES instructions, so have not bothered to
// write the implementations. Can copy and adjust the ones
// in asm_amd64.s when the time comes.

TEXT runtimeaeshash(SB),NOSPLIT,$0-20
	MOVL	AX, ret+16(FP)
	RET

TEXT runtimeaeshashstr(SB),NOSPLIT,$0-20
	MOVL	AX, ret+16(FP)
	RET

TEXT runtimeaeshash32(SB),NOSPLIT,$0-20
	MOVL	AX, ret+16(FP)
	RET

TEXT runtimeaeshash64(SB),NOSPLIT,$0-20
	MOVL	AX, ret+16(FP)
	RET

TEXT runtimememeq(SB),NOSPLIT,$0-17
	MOVL	a+0(FP), SI
	MOVL	b+4(FP), DI
	MOVL	size+8(FP), BX
	CALL	runtimememeqbody(SB)
	MOVB	AX, ret+16(FP)
	RET

// eqstring tests whether two strings are equal.
// See runtime_test.go:eqstring_generic for
// equivalent Go code.
TEXT runtimeeqstring(SB),NOSPLIT,$0-17
	MOVL	s1len+4(FP), AX
	MOVL	s2len+12(FP), BX
	CMPL	AX, BX
	JNE	different
	MOVL	s1str+0(FP), SI
	MOVL	s2str+8(FP), DI
	CMPL	SI, DI
	JEQ	same
	CALL	runtimememeqbody(SB)
	MOVB	AX, v+16(FP)
	RET
same:
	MOVB	$1, v+16(FP)
	RET
different:
	MOVB	$0, v+16(FP)
	RET

// a in SI
// b in DI
// count in BX
TEXT runtimememeqbody(SB),NOSPLIT,$0-0
	XORQ	AX, AX

	CMPQ	BX, $8
	JB	small
	
	// 64 bytes at a time using xmm registers
hugeloop:
	CMPQ	BX, $64
	JB	bigloop
	MOVOU	(SI), X0
	MOVOU	(DI), X1
	MOVOU	16(SI), X2
	MOVOU	16(DI), X3
	MOVOU	32(SI), X4
	MOVOU	32(DI), X5
	MOVOU	48(SI), X6
	MOVOU	48(DI), X7
	PCMPEQB	X1, X0
	PCMPEQB	X3, X2
	PCMPEQB	X5, X4
	PCMPEQB	X7, X6
	PAND	X2, X0
	PAND	X6, X4
	PAND	X4, X0
	PMOVMSKB X0, DX
	ADDQ	$64, SI
	ADDQ	$64, DI
	SUBQ	$64, BX
	CMPL	DX, $0xffff
	JEQ	hugeloop
	RET

	// 8 bytes at a time using 64-bit register
bigloop:
	CMPQ	BX, $8
	JBE	leftover
	MOVQ	(SI), CX
	MOVQ	(DI), DX
	ADDQ	$8, SI
	ADDQ	$8, DI
	SUBQ	$8, BX
	CMPQ	CX, DX
	JEQ	bigloop
	RET

	// remaining 0-8 bytes
leftover:
	ADDQ	BX, SI
	ADDQ	BX, DI
	MOVQ	-8(SI), CX
	MOVQ	-8(DI), DX
	CMPQ	CX, DX
	SETEQ	AX
	RET

small:
	CMPQ	BX, $0
	JEQ	equal

	LEAQ	0(BX*8), CX
	NEGQ	CX

	CMPB	SI, $0xf8
	JA	si_high

	// load at SI won't cross a page boundary.
	MOVQ	(SI), SI
	JMP	si_finish
si_high:
	// address ends in 11111xxx.  Load up to bytes we want, move to correct position.
	MOVQ	BX, DX
	ADDQ	SI, DX
	MOVQ	-8(DX), SI
	SHRQ	CX, SI
si_finish:

	// same for DI.
	CMPB	DI, $0xf8
	JA	di_high
	MOVQ	(DI), DI
	JMP	di_finish
di_high:
	MOVQ	BX, DX
	ADDQ	DI, DX
	MOVQ	-8(DX), DI
	SHRQ	CX, DI
di_finish:

	SUBQ	SI, DI
	SHLQ	CX, DI
equal:
	SETEQ	AX
	RET

TEXT runtimecmpstring(SB),NOSPLIT,$0-20
	MOVL	s1_base+0(FP), SI
	MOVL	s1_len+4(FP), BX
	MOVL	s2_base+8(FP), DI
	MOVL	s2_len+12(FP), DX
	CALL	runtimecmpbody(SB)
	MOVL	AX, ret+16(FP)
	RET

TEXT runtimecmpbytes(SB),NOSPLIT,$0-28
	MOVL	s1+0(FP), SI
	MOVL	s1+4(FP), BX
	MOVL	s2+12(FP), DI
	MOVL	s2+16(FP), DX
	CALL	runtimecmpbody(SB)
	MOVQ	AX, res+24(FP)
	RET

// input:
//   SI = a
//   DI = b
//   BX = alen
//   DX = blen
// output:
//   AX = 1/0/-1
TEXT runtimecmpbody(SB),NOSPLIT,$0-0
	CMPQ	SI, DI
	JEQ	cmp_allsame
	CMPQ	BX, DX
	MOVQ	DX, R8
	CMOVQLT	BX, R8 // R8 = min(alen, blen) = # of bytes to compare
	CMPQ	R8, $8
	JB	cmp_small

cmp_loop:
	CMPQ	R8, $16
	JBE	cmp_0through16
	MOVOU	(SI), X0
	MOVOU	(DI), X1
	PCMPEQB X0, X1
	PMOVMSKB X1, AX
	XORQ	$0xffff, AX	// convert EQ to NE
	JNE	cmp_diff16	// branch if at least one byte is not equal
	ADDQ	$16, SI
	ADDQ	$16, DI
	SUBQ	$16, R8
	JMP	cmp_loop
	
	// AX = bit mask of differences
cmp_diff16:
	BSFQ	AX, BX	// index of first byte that differs
	XORQ	AX, AX
	ADDQ	BX, SI
	MOVB	(SI), CX
	ADDQ	BX, DI
	CMPB	CX, (DI)
	SETHI	AX
	LEAQ	-1(AX*2), AX	// convert 1/0 to +1/-1
	RET

	// 0 through 16 bytes left, alen>=8, blen>=8
cmp_0through16:
	CMPQ	R8, $8
	JBE	cmp_0through8
	MOVQ	(SI), AX
	MOVQ	(DI), CX
	CMPQ	AX, CX
	JNE	cmp_diff8
cmp_0through8:
	ADDQ	R8, SI
	ADDQ	R8, DI
	MOVQ	-8(SI), AX
	MOVQ	-8(DI), CX
	CMPQ	AX, CX
	JEQ	cmp_allsame

	// AX and CX contain parts of a and b that differ.
cmp_diff8:
	BSWAPQ	AX	// reverse order of bytes
	BSWAPQ	CX
	XORQ	AX, CX
	BSRQ	CX, CX	// index of highest bit difference
	SHRQ	CX, AX	// move a's bit to bottom
	ANDQ	$1, AX	// mask bit
	LEAQ	-1(AX*2), AX // 1/0 => +1/-1
	RET

	// 0-7 bytes in common
cmp_small:
	LEAQ	(R8*8), CX	// bytes left -> bits left
	NEGQ	CX		//  - bits lift (== 64 - bits left mod 64)
	JEQ	cmp_allsame

	// load bytes of a into high bytes of AX
	CMPB	SI, $0xf8
	JA	cmp_si_high
	MOVQ	(SI), SI
	JMP	cmp_si_finish
cmp_si_high:
	ADDQ	R8, SI
	MOVQ	-8(SI), SI
	SHRQ	CX, SI
cmp_si_finish:
	SHLQ	CX, SI

	// load bytes of b in to high bytes of BX
	CMPB	DI, $0xf8
	JA	cmp_di_high
	MOVQ	(DI), DI
	JMP	cmp_di_finish
cmp_di_high:
	ADDQ	R8, DI
	MOVQ	-8(DI), DI
	SHRQ	CX, DI
cmp_di_finish:
	SHLQ	CX, DI

	BSWAPQ	SI	// reverse order of bytes
	BSWAPQ	DI
	XORQ	SI, DI	// find bit differences
	JEQ	cmp_allsame
	BSRQ	DI, CX	// index of highest bit difference
	SHRQ	CX, SI	// move a's bit to bottom
	ANDQ	$1, SI	// mask bit
	LEAQ	-1(SI*2), AX // 1/0 => +1/-1
	RET

cmp_allsame:
	XORQ	AX, AX
	XORQ	CX, CX
	CMPQ	BX, DX
	SETGT	AX	// 1 if alen > blen
	SETEQ	CX	// 1 if alen == blen
	LEAQ	-1(CX)(AX*2), AX	// 1,0,-1 result
	RET

TEXT bytesIndexByte(SB),NOSPLIT,$0
	MOVL s+0(FP), SI
	MOVL s_len+4(FP), BX
	MOVB c+12(FP), AL
	CALL runtimeindexbytebody(SB)
	MOVL AX, ret+16(FP)
	RET

TEXT stringsIndexByte(SB),NOSPLIT,$0
	MOVL s+0(FP), SI
	MOVL s_len+4(FP), BX
	MOVB c+8(FP), AL
	CALL runtimeindexbytebody(SB)
	MOVL AX, ret+16(FP)
	RET

// input:
//   SI: data
//   BX: data len
//   AL: byte sought
// output:
//   AX
TEXT runtimeindexbytebody(SB),NOSPLIT,$0
	MOVL SI, DI

	CMPL BX, $16
	JLT indexbyte_small

	// round up to first 16-byte boundary
	TESTL $15, SI
	JZ aligned
	MOVL SI, CX
	ANDL $~15, CX
	ADDL $16, CX

	// search the beginning
	SUBL SI, CX
	REPN; SCASB
	JZ success

// DI is 16-byte aligned; get ready to search using SSE instructions
aligned:
	// round down to last 16-byte boundary
	MOVL BX, R11
	ADDL SI, R11
	ANDL $~15, R11

	// shuffle X0 around so that each byte contains c
	MOVD AX, X0
	PUNPCKLBW X0, X0
	PUNPCKLBW X0, X0
	PSHUFL $0, X0, X0
	JMP condition

sse:
	// move the next 16-byte chunk of the buffer into X1
	MOVO (DI), X1
	// compare bytes in X0 to X1
	PCMPEQB X0, X1
	// take the top bit of each byte in X1 and put the result in DX
	PMOVMSKB X1, DX
	TESTL DX, DX
	JNZ ssesuccess
	ADDL $16, DI

condition:
	CMPL DI, R11
	JLT sse

	// search the end
	MOVL SI, CX
	ADDL BX, CX
	SUBL R11, CX
	// if CX == 0, the zero flag will be set and we'll end up
	// returning a false success
	JZ failure
	REPN; SCASB
	JZ success

failure:
	MOVL $-1, AX
	RET

// handle for lengths < 16
indexbyte_small:
	MOVL BX, CX
	REPN; SCASB
	JZ success
	MOVL $-1, AX
	RET

// we've found the chunk containing the byte
// now just figure out which specific byte it is
ssesuccess:
	// get the index of the least significant set bit
	BSFW DX, DX
	SUBL SI, DI
	ADDL DI, DX
	MOVL DX, AX
	RET

success:
	SUBL SI, DI
	SUBL $1, DI
	MOVL DI, AX
	RET

TEXT bytesEqual(SB),NOSPLIT,$0-25
	MOVL	a_len+4(FP), BX
	MOVL	b_len+16(FP), CX
	XORL	AX, AX
	CMPL	BX, CX
	JNE	eqret
	MOVL	a+0(FP), SI
	MOVL	b+12(FP), DI
	CALL	runtimememeqbody(SB)
eqret:
	MOVB	AX, ret+24(FP)
	RET

TEXT runtimefastrand1(SB), NOSPLIT, $0-4
	get_tls(CX)
	MOVL	g(CX), AX
	MOVL	g_m(AX), AX
	MOVL	m_fastrand(AX), DX
	ADDL	DX, DX
	MOVL	DX, BX
	XORL	$0x88888eef, DX
	CMOVLMI	BX, DX
	MOVL	DX, m_fastrand(AX)
	MOVL	DX, ret+0(FP)
	RET

TEXT runtimereturn0(SB), NOSPLIT, $0
	MOVL	$0, AX
	RET

// The top-most function running on a goroutine
// returns to goexit+PCQuantum.
TEXT runtimegoexit(SB),NOSPLIT,$0-0
	BYTE	$0x90	// NOP
	CALL	runtimegoexit1(SB)	// does not return
                                                                                                                                                                                                                                            root/go1.4/src/runtime/asm_arm.s                                                                    0100644 0000000 0000000 00000073410 12600426227 015143  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include "zasm_GOOS_GOARCH.h"
#include "funcdata.h"
#include "textflag.h"

// using frame size $-4 means do not save LR on stack.
TEXT runtimert0_go(SB),NOSPLIT,$-4
	MOVW	$0xcafebabe, R12

	// copy arguments forward on an even stack
	// use R13 instead of SP to avoid linker rewriting the offsets
	MOVW	0(R13), R0		// argc
	MOVW	4(R13), R1		// argv
	SUB	$64, R13		// plenty of scratch
	AND	$~7, R13
	MOVW	R0, 60(R13)		// save argc, argv away
	MOVW	R1, 64(R13)

	// set up g register
	// g is R10
	MOVW	$runtimeg0(SB), g
	MOVW	$runtimem0(SB), R8

	// save m->g0 = g0
	MOVW	g, m_g0(R8)
	// save g->m = m0
	MOVW	R8, g_m(g)

	// create istack out of the OS stack
	MOVW	$(-8192+104)(R13), R0
	MOVW	R0, g_stackguard0(g)
	MOVW	R0, g_stackguard1(g)
	MOVW	R0, (g_stack+stack_lo)(g)
	MOVW	R13, (g_stack+stack_hi)(g)

	BL	runtimeemptyfunc(SB)	// fault if stack check is wrong

#ifndef GOOS_nacl
	// if there is an _cgo_init, call it.
	MOVW	_cgo_init(SB), R4
	CMP	$0, R4
	B.EQ	nocgo
	MRC     15, 0, R0, C13, C0, 3 	// load TLS base pointer
	MOVW 	R0, R3 			// arg 3: TLS base pointer
	MOVW 	$runtimetlsg(SB), R2 	// arg 2: tlsg
	MOVW	$setg_gcc<>(SB), R1 	// arg 1: setg
	MOVW	g, R0 			// arg 0: G
	BL	(R4) // will clobber R0-R3
#endif

nocgo:
	// update stackguard after _cgo_init
	MOVW	(g_stack+stack_lo)(g), R0
	ADD	$const_StackGuard, R0
	MOVW	R0, g_stackguard0(g)
	MOVW	R0, g_stackguard1(g)

	BL	runtimecheckgoarm(SB)
	BL	runtimecheck(SB)

	// saved argc, argv
	MOVW	60(R13), R0
	MOVW	R0, 4(R13)
	MOVW	64(R13), R1
	MOVW	R1, 8(R13)
	BL	runtimeargs(SB)
	BL	runtimeosinit(SB)
	BL	runtimeschedinit(SB)

	// create a new goroutine to start program
	MOVW	$runtimemainf(SB), R0
	MOVW.W	R0, -4(R13)
	MOVW	$8, R0
	MOVW.W	R0, -4(R13)
	MOVW	$0, R0
	MOVW.W	R0, -4(R13)	// push $0 as guard
	BL	runtimenewproc(SB)
	MOVW	$12(R13), R13	// pop args and LR

	// start this M
	BL	runtimemstart(SB)

	MOVW	$1234, R0
	MOVW	$1000, R1
	MOVW	R0, (R1)	// fail hard

DATA	runtimemainf+0(SB)/4,$runtimemain(SB)
GLOBL	runtimemainf(SB),RODATA,$4

TEXT runtimebreakpoint(SB),NOSPLIT,$0-0
	// gdb won't skip this breakpoint instruction automatically,
	// so you must manually "set $pc+=4" to skip it and continue.
#ifdef GOOS_nacl
	WORD	$0xe125be7f	// BKPT 0x5bef, NACL_INSTR_ARM_BREAKPOINT
#else
	WORD	$0xe7f001f0	// undefined instruction that gdb understands is a software breakpoint
#endif
	RET

TEXT runtimeasminit(SB),NOSPLIT,$0-0
	// disable runfast (flush-to-zero) mode of vfp if runtime.goarm > 5
	MOVB	runtimegoarm(SB), R11
	CMP	$5, R11
	BLE	4(PC)
	WORD	$0xeef1ba10	// vmrs r11, fpscr
	BIC	$(1<<24), R11
	WORD	$0xeee1ba10	// vmsr fpscr, r11
	RET

/*
 *  go-routine
 */

// void gosave(Gobuf*)
// save state in Gobuf; setjmp
TEXT runtimegosave(SB),NOSPLIT,$-4-4
	MOVW	0(FP), R0		// gobuf
	MOVW	SP, gobuf_sp(R0)
	MOVW	LR, gobuf_pc(R0)
	MOVW	g, gobuf_g(R0)
	MOVW	$0, R11
	MOVW	R11, gobuf_lr(R0)
	MOVW	R11, gobuf_ret(R0)
	MOVW	R11, gobuf_ctxt(R0)
	RET

// void gogo(Gobuf*)
// restore state from Gobuf; longjmp
TEXT runtimegogo(SB),NOSPLIT,$-4-4
	MOVW	0(FP), R1		// gobuf
	MOVW	gobuf_g(R1), R0
	BL	setg<>(SB)

	// NOTE: We updated g above, and we are about to update SP.
	// Until LR and PC are also updated, the g/SP/LR/PC quadruple
	// are out of sync and must not be used as the basis of a traceback.
	// Sigprof skips the traceback when SP is not within g's bounds,
	// and when the PC is inside this function, runtime.gogo.
	// Since we are about to update SP, until we complete runtime.gogo
	// we must not leave this function. In particular, no calls
	// after this point: it must be straight-line code until the
	// final B instruction.
	// See large comment in sigprof for more details.
	MOVW	gobuf_sp(R1), SP	// restore SP
	MOVW	gobuf_lr(R1), LR
	MOVW	gobuf_ret(R1), R0
	MOVW	gobuf_ctxt(R1), R7
	MOVW	$0, R11
	MOVW	R11, gobuf_sp(R1)	// clear to help garbage collector
	MOVW	R11, gobuf_ret(R1)
	MOVW	R11, gobuf_lr(R1)
	MOVW	R11, gobuf_ctxt(R1)
	MOVW	gobuf_pc(R1), R11
	CMP	R11, R11 // set condition codes for == test, needed by stack split
	B	(R11)

// func mcall(fn func(*g))
// Switch to m->g0's stack, call fn(g).
// Fn must never return.  It should gogo(&g->sched)
// to keep running g.
TEXT runtimemcall(SB),NOSPLIT,$-4-4
	// Save caller state in g->sched.
	MOVW	SP, (g_sched+gobuf_sp)(g)
	MOVW	LR, (g_sched+gobuf_pc)(g)
	MOVW	$0, R11
	MOVW	R11, (g_sched+gobuf_lr)(g)
	MOVW	g, (g_sched+gobuf_g)(g)

	// Switch to m->g0 & its stack, call fn.
	MOVW	g, R1
	MOVW	g_m(g), R8
	MOVW	m_g0(R8), R0
	BL	setg<>(SB)
	CMP	g, R1
	B.NE	2(PC)
	B	runtimebadmcall(SB)
	MOVB	runtimeiscgo(SB), R11
	CMP	$0, R11
	BL.NE	runtimesave_g(SB)
	MOVW	fn+0(FP), R0
	MOVW	(g_sched+gobuf_sp)(g), SP
	SUB	$8, SP
	MOVW	R1, 4(SP)
	MOVW	R0, R7
	MOVW	0(R0), R0
	BL	(R0)
	B	runtimebadmcall2(SB)
	RET

// switchtoM is a dummy routine that onM leaves at the bottom
// of the G stack.  We need to distinguish the routine that
// lives at the bottom of the G stack from the one that lives
// at the top of the M stack because the one at the top of
// the M stack terminates the stack walk (see topofstack()).
TEXT runtimeswitchtoM(SB),NOSPLIT,$0-0
	MOVW	$0, R0
	BL	(R0) // clobber lr to ensure push {lr} is kept
	RET

// func onM_signalok(fn func())
TEXT runtimeonM_signalok(SB), NOSPLIT, $-4-4
	MOVW	g_m(g), R1
	MOVW	m_gsignal(R1), R2
	CMP	g, R2
	B.EQ	ongsignal
	B	runtimeonM(SB)

ongsignal:
	MOVW	fn+0(FP), R0
	MOVW	R0, R7
	MOVW	0(R0), R0
	BL	(R0)
	RET

// func onM(fn func())
TEXT runtimeonM(SB),NOSPLIT,$0-4
	MOVW	fn+0(FP), R0	// R0 = fn
	MOVW	g_m(g), R1	// R1 = m

	MOVW	m_g0(R1), R2	// R2 = g0
	CMP	g, R2
	B.EQ	onm

	MOVW	m_curg(R1), R3
	CMP	g, R3
	B.EQ	oncurg

	// Not g0, not curg. Must be gsignal, but that's not allowed.
	// Hide call from linker nosplit analysis.
	MOVW	$runtimebadonm(SB), R0
	BL	(R0)

oncurg:
	// save our state in g->sched.  Pretend to
	// be switchtoM if the G stack is scanned.
	MOVW	$runtimeswitchtoM(SB), R3
	ADD	$4, R3, R3 // get past push {lr}
	MOVW	R3, (g_sched+gobuf_pc)(g)
	MOVW	SP, (g_sched+gobuf_sp)(g)
	MOVW	LR, (g_sched+gobuf_lr)(g)
	MOVW	g, (g_sched+gobuf_g)(g)

	// switch to g0
	MOVW	R0, R5
	MOVW	R2, R0
	BL	setg<>(SB)
	MOVW	R5, R0
	MOVW	(g_sched+gobuf_sp)(R2), R3
	// make it look like mstart called onM on g0, to stop traceback
	SUB	$4, R3, R3
	MOVW	$runtimemstart(SB), R4
	MOVW	R4, 0(R3)
	MOVW	R3, SP

	// call target function
	MOVW	R0, R7
	MOVW	0(R0), R0
	BL	(R0)

	// switch back to g
	MOVW	g_m(g), R1
	MOVW	m_curg(R1), R0
	BL	setg<>(SB)
	MOVW	(g_sched+gobuf_sp)(g), SP
	MOVW	$0, R3
	MOVW	R3, (g_sched+gobuf_sp)(g)
	RET

onm:
	MOVW	R0, R7
	MOVW	0(R0), R0
	BL	(R0)
	RET

/*
 * support for morestack
 */

// Called during function prolog when more stack is needed.
// R1 frame size
// R2 arg size
// R3 prolog's LR
// NB. we do not save R0 because we've forced 5c to pass all arguments
// on the stack.
// using frame size $-4 means do not save LR on stack.
//
// The traceback routines see morestack on a g0 as being
// the top of a stack (for example, morestack calling newstack
// calling the scheduler calling newm calling gc), so we must
// record an argument size. For that purpose, it has no arguments.
TEXT runtimemorestack(SB),NOSPLIT,$-4-0
	// Cannot grow scheduler stack (m->g0).
	MOVW	g_m(g), R8
	MOVW	m_g0(R8), R4
	CMP	g, R4
	BL.EQ	runtimeabort(SB)

	// Cannot grow signal stack (m->gsignal).
	MOVW	m_gsignal(R8), R4
	CMP	g, R4
	BL.EQ	runtimeabort(SB)

	// Called from f.
	// Set g->sched to context in f.
	MOVW	R7, (g_sched+gobuf_ctxt)(g)
	MOVW	SP, (g_sched+gobuf_sp)(g)
	MOVW	LR, (g_sched+gobuf_pc)(g)
	MOVW	R3, (g_sched+gobuf_lr)(g)

	// Called from f.
	// Set m->morebuf to f's caller.
	MOVW	R3, (m_morebuf+gobuf_pc)(R8)	// f's caller's PC
	MOVW	SP, (m_morebuf+gobuf_sp)(R8)	// f's caller's SP
	MOVW	$4(SP), R3			// f's argument pointer
	MOVW	g, (m_morebuf+gobuf_g)(R8)

	// Call newstack on m->g0's stack.
	MOVW	m_g0(R8), R0
	BL	setg<>(SB)
	MOVW	(g_sched+gobuf_sp)(g), SP
	BL	runtimenewstack(SB)

	// Not reached, but make sure the return PC from the call to newstack
	// is still in this function, and not the beginning of the next.
	RET

TEXT runtimemorestack_noctxt(SB),NOSPLIT,$-4-0
	MOVW	$0, R7
	B runtimemorestack(SB)

// reflectcall: call a function with the given argument list
// func call(f *FuncVal, arg *byte, argsize, retoffset uint32).
// we don't have variable-sized frames, so we use a small number
// of constant-sized-frame functions to encode a few bits of size in the pc.
// Caution: ugly multiline assembly macros in your future!

#define DISPATCH(NAME,MAXSIZE)		\
	CMP	$MAXSIZE, R0;		\
	B.HI	3(PC);			\
	MOVW	$NAME(SB), R1;		\
	B	(R1)

TEXT reflectcall(SB),NOSPLIT,$-4-16
	MOVW	argsize+8(FP), R0
	DISPATCH(runtimecall16, 16)
	DISPATCH(runtimecall32, 32)
	DISPATCH(runtimecall64, 64)
	DISPATCH(runtimecall128, 128)
	DISPATCH(runtimecall256, 256)
	DISPATCH(runtimecall512, 512)
	DISPATCH(runtimecall1024, 1024)
	DISPATCH(runtimecall2048, 2048)
	DISPATCH(runtimecall4096, 4096)
	DISPATCH(runtimecall8192, 8192)
	DISPATCH(runtimecall16384, 16384)
	DISPATCH(runtimecall32768, 32768)
	DISPATCH(runtimecall65536, 65536)
	DISPATCH(runtimecall131072, 131072)
	DISPATCH(runtimecall262144, 262144)
	DISPATCH(runtimecall524288, 524288)
	DISPATCH(runtimecall1048576, 1048576)
	DISPATCH(runtimecall2097152, 2097152)
	DISPATCH(runtimecall4194304, 4194304)
	DISPATCH(runtimecall8388608, 8388608)
	DISPATCH(runtimecall16777216, 16777216)
	DISPATCH(runtimecall33554432, 33554432)
	DISPATCH(runtimecall67108864, 67108864)
	DISPATCH(runtimecall134217728, 134217728)
	DISPATCH(runtimecall268435456, 268435456)
	DISPATCH(runtimecall536870912, 536870912)
	DISPATCH(runtimecall1073741824, 1073741824)
	MOVW	$runtimebadreflectcall(SB), R1
	B	(R1)

#define CALLFN(NAME,MAXSIZE)			\
TEXT NAME(SB), WRAPPER, $MAXSIZE-16;		\
	NO_LOCAL_POINTERS;			\
	/* copy arguments to stack */		\
	MOVW	argptr+4(FP), R0;		\
	MOVW	argsize+8(FP), R2;		\
	ADD	$4, SP, R1;			\
	CMP	$0, R2;				\
	B.EQ	5(PC);				\
	MOVBU.P	1(R0), R5;			\
	MOVBU.P R5, 1(R1);			\
	SUB	$1, R2, R2;			\
	B	-5(PC);				\
	/* call function */			\
	MOVW	f+0(FP), R7;			\
	MOVW	(R7), R0;			\
	PCDATA  $PCDATA_StackMapIndex, $0;	\
	BL	(R0);				\
	/* copy return values back */		\
	MOVW	argptr+4(FP), R0;		\
	MOVW	argsize+8(FP), R2;		\
	MOVW	retoffset+12(FP), R3;		\
	ADD	$4, SP, R1;			\
	ADD	R3, R1;				\
	ADD	R3, R0;				\
	SUB	R3, R2;				\
	CMP	$0, R2;				\
	RET.EQ	;				\
	MOVBU.P	1(R1), R5;			\
	MOVBU.P R5, 1(R0);			\
	SUB	$1, R2, R2;			\
	B	-5(PC)				\

CALLFN(call16, 16)
CALLFN(call32, 32)
CALLFN(call64, 64)
CALLFN(call128, 128)
CALLFN(call256, 256)
CALLFN(call512, 512)
CALLFN(call1024, 1024)
CALLFN(call2048, 2048)
CALLFN(call4096, 4096)
CALLFN(call8192, 8192)
CALLFN(call16384, 16384)
CALLFN(call32768, 32768)
CALLFN(call65536, 65536)
CALLFN(call131072, 131072)
CALLFN(call262144, 262144)
CALLFN(call524288, 524288)
CALLFN(call1048576, 1048576)
CALLFN(call2097152, 2097152)
CALLFN(call4194304, 4194304)
CALLFN(call8388608, 8388608)
CALLFN(call16777216, 16777216)
CALLFN(call33554432, 33554432)
CALLFN(call67108864, 67108864)
CALLFN(call134217728, 134217728)
CALLFN(call268435456, 268435456)
CALLFN(call536870912, 536870912)
CALLFN(call1073741824, 1073741824)

// void jmpdefer(fn, sp);
// called from deferreturn.
// 1. grab stored LR for caller
// 2. sub 4 bytes to get back to BL deferreturn
// 3. B to fn
// TODO(rsc): Push things on stack and then use pop
// to load all registers simultaneously, so that a profiling
// interrupt can never see mismatched SP/LR/PC.
// (And double-check that pop is atomic in that way.)
TEXT runtimejmpdefer(SB),NOSPLIT,$0-8
	MOVW	0(SP), LR
	MOVW	$-4(LR), LR	// BL deferreturn
	MOVW	fv+0(FP), R7
	MOVW	argp+4(FP), SP
	MOVW	$-4(SP), SP	// SP is 4 below argp, due to saved LR
	MOVW	0(R7), R1
	B	(R1)

// Save state of caller into g->sched. Smashes R11.
TEXT gosave<>(SB),NOSPLIT,$0
	MOVW	LR, (g_sched+gobuf_pc)(g)
	MOVW	R13, (g_sched+gobuf_sp)(g)
	MOVW	$0, R11
	MOVW	R11, (g_sched+gobuf_lr)(g)
	MOVW	R11, (g_sched+gobuf_ret)(g)
	MOVW	R11, (g_sched+gobuf_ctxt)(g)
	RET

// asmcgocall(void(*fn)(void*), void *arg)
// Call fn(arg) on the scheduler stack,
// aligned appropriately for the gcc ABI.
// See cgocall.c for more details.
TEXT	asmcgocall(SB),NOSPLIT,$0-8
	MOVW	fn+0(FP), R1
	MOVW	arg+4(FP), R0
	BL	asmcgocall<>(SB)
	RET

TEXT asmcgocall_errno(SB),NOSPLIT,$0-12
	MOVW	fn+0(FP), R1
	MOVW	arg+4(FP), R0
	BL	asmcgocall<>(SB)
	MOVW	R0, ret+8(FP)
	RET

TEXT asmcgocall<>(SB),NOSPLIT,$0-0
	// fn in R1, arg in R0.
	MOVW	R13, R2
	MOVW	g, R4

	// Figure out if we need to switch to m->g0 stack.
	// We get called to create new OS threads too, and those
	// come in on the m->g0 stack already.
	MOVW	g_m(g), R8
	MOVW	m_g0(R8), R3
	CMP	R3, g
	BEQ	asmcgocall_g0
	BL	gosave<>(SB)
	MOVW	R0, R5
	MOVW	R3, R0
	BL	setg<>(SB)
	MOVW	R5, R0
	MOVW	(g_sched+gobuf_sp)(g), R13

	// Now on a scheduling stack (a pthread-created stack).
asmcgocall_g0:
	SUB	$24, R13
	BIC	$0x7, R13	// alignment for gcc ABI
	MOVW	R4, 20(R13) // save old g
	MOVW	(g_stack+stack_hi)(R4), R4
	SUB	R2, R4
	MOVW	R4, 16(R13)	// save depth in stack (can't just save SP, as stack might be copied during a callback)
	BL	(R1)

	// Restore registers, g, stack pointer.
	MOVW	R0, R5
	MOVW	20(R13), R0
	BL	setg<>(SB)
	MOVW	(g_stack+stack_hi)(g), R1
	MOVW	16(R13), R2
	SUB	R2, R1
	MOVW	R5, R0
	MOVW	R1, R13
	RET

// cgocallback(void (*fn)(void*), void *frame, uintptr framesize)
// Turn the fn into a Go func (by taking its address) and call
// cgocallback_gofunc.
TEXT runtimecgocallback(SB),NOSPLIT,$12-12
	MOVW	$fn+0(FP), R0
	MOVW	R0, 4(R13)
	MOVW	frame+4(FP), R0
	MOVW	R0, 8(R13)
	MOVW	framesize+8(FP), R0
	MOVW	R0, 12(R13)
	MOVW	$runtimecgocallback_gofunc(SB), R0
	BL	(R0)
	RET

// cgocallback_gofunc(void (*fn)(void*), void *frame, uintptr framesize)
// See cgocall.c for more details.
TEXT	cgocallback_gofunc(SB),NOSPLIT,$8-12
	NO_LOCAL_POINTERS
	
	// Load m and g from thread-local storage.
	MOVB	runtimeiscgo(SB), R0
	CMP	$0, R0
	BL.NE	runtimeload_g(SB)

	// If g is nil, Go did not create the current thread.
	// Call needm to obtain one for temporary use.
	// In this case, we're running on the thread stack, so there's
	// lots of space, but the linker doesn't know. Hide the call from
	// the linker analysis by using an indirect call.
	CMP	$0, g
	B.NE	havem
	MOVW	g, savedm-4(SP) // g is zero, so is m.
	MOVW	$runtimeneedm(SB), R0
	BL	(R0)

	// Set m->sched.sp = SP, so that if a panic happens
	// during the function we are about to execute, it will
	// have a valid SP to run on the g0 stack.
	// The next few lines (after the havem label)
	// will save this SP onto the stack and then write
	// the same SP back to m->sched.sp. That seems redundant,
	// but if an unrecovered panic happens, unwindm will
	// restore the g->sched.sp from the stack location
	// and then onM will try to use it. If we don't set it here,
	// that restored SP will be uninitialized (typically 0) and
	// will not be usable.
	MOVW	g_m(g), R8
	MOVW	m_g0(R8), R3
	MOVW	R13, (g_sched+gobuf_sp)(R3)

havem:
	MOVW	g_m(g), R8
	MOVW	R8, savedm-4(SP)
	// Now there's a valid m, and we're running on its m->g0.
	// Save current m->g0->sched.sp on stack and then set it to SP.
	// Save current sp in m->g0->sched.sp in preparation for
	// switch back to m->curg stack.
	// NOTE: unwindm knows that the saved g->sched.sp is at 4(R13) aka savedsp-8(SP).
	MOVW	m_g0(R8), R3
	MOVW	(g_sched+gobuf_sp)(R3), R4
	MOVW	R4, savedsp-8(SP)
	MOVW	R13, (g_sched+gobuf_sp)(R3)

	// Switch to m->curg stack and call runtime.cgocallbackg.
	// Because we are taking over the execution of m->curg
	// but *not* resuming what had been running, we need to
	// save that information (m->curg->sched) so we can restore it.
	// We can restore m->curg->sched.sp easily, because calling
	// runtime.cgocallbackg leaves SP unchanged upon return.
	// To save m->curg->sched.pc, we push it onto the stack.
	// This has the added benefit that it looks to the traceback
	// routine like cgocallbackg is going to return to that
	// PC (because the frame we allocate below has the same
	// size as cgocallback_gofunc's frame declared above)
	// so that the traceback will seamlessly trace back into
	// the earlier calls.
	//
	// In the new goroutine, -8(SP) and -4(SP) are unused.
	MOVW	m_curg(R8), R0
	BL	setg<>(SB)
	MOVW	(g_sched+gobuf_sp)(g), R4 // prepare stack as R4
	MOVW	(g_sched+gobuf_pc)(g), R5
	MOVW	R5, -12(R4)
	MOVW	$-12(R4), R13
	BL	runtimecgocallbackg(SB)

	// Restore g->sched (== m->curg->sched) from saved values.
	MOVW	0(R13), R5
	MOVW	R5, (g_sched+gobuf_pc)(g)
	MOVW	$12(R13), R4
	MOVW	R4, (g_sched+gobuf_sp)(g)

	// Switch back to m->g0's stack and restore m->g0->sched.sp.
	// (Unlike m->curg, the g0 goroutine never uses sched.pc,
	// so we do not have to restore it.)
	MOVW	g_m(g), R8
	MOVW	m_g0(R8), R0
	BL	setg<>(SB)
	MOVW	(g_sched+gobuf_sp)(g), R13
	MOVW	savedsp-8(SP), R4
	MOVW	R4, (g_sched+gobuf_sp)(g)

	// If the m on entry was nil, we called needm above to borrow an m
	// for the duration of the call. Since the call is over, return it with dropm.
	MOVW	savedm-4(SP), R6
	CMP	$0, R6
	B.NE	3(PC)
	MOVW	$runtimedropm(SB), R0
	BL	(R0)

	// Done!
	RET

// void setg(G*); set g. for use by needm.
TEXT runtimesetg(SB),NOSPLIT,$-4-4
	MOVW	gg+0(FP), R0
	B	setg<>(SB)

TEXT setg<>(SB),NOSPLIT,$-4-0
	MOVW	R0, g

	// Save g to thread-local storage.
	MOVB	runtimeiscgo(SB), R0
	CMP	$0, R0
	B.EQ	2(PC)
	B	runtimesave_g(SB)

	MOVW	g, R0
	RET

TEXT runtimegetcallerpc(SB),NOSPLIT,$-4-4
	MOVW	0(SP), R0
	MOVW	R0, ret+4(FP)
	RET

TEXT runtimegogetcallerpc(SB),NOSPLIT,$-4-8
	MOVW	R14, ret+4(FP)
	RET

TEXT runtimesetcallerpc(SB),NOSPLIT,$-4-8
	MOVW	pc+4(FP), R0
	MOVW	R0, 0(SP)
	RET

TEXT runtimegetcallersp(SB),NOSPLIT,$-4-4
	MOVW	0(FP), R0
	MOVW	$-4(R0), R0
	MOVW	R0, ret+4(FP)
	RET

// func gogetcallersp(p unsafe.Pointer) uintptr
TEXT runtimegogetcallersp(SB),NOSPLIT,$-4-8
	MOVW	0(FP), R0
	MOVW	$-4(R0), R0
	MOVW	R0, ret+4(FP)
	RET

TEXT runtimeemptyfunc(SB),0,$0-0
	RET

TEXT runtimeabort(SB),NOSPLIT,$-4-0
	MOVW	$0, R0
	MOVW	(R0), R1

// bool armcas(int32 *val, int32 old, int32 new)
// Atomically:
//	if(*val == old){
//		*val = new;
//		return 1;
//	}else
//		return 0;
//
// To implement runtimecas in sys_$GOOS_arm.s
// using the native instructions, use:
//
//	TEXT runtimecas(SB),NOSPLIT,$0
//		B	runtimearmcas(SB)
//
TEXT runtimearmcas(SB),NOSPLIT,$0-13
	MOVW	valptr+0(FP), R1
	MOVW	old+4(FP), R2
	MOVW	new+8(FP), R3
casl:
	LDREX	(R1), R0
	CMP	R0, R2
	BNE	casfail
	STREX	R3, (R1), R0
	CMP	$0, R0
	BNE	casl
	MOVW	$1, R0
	MOVB	R0, ret+12(FP)
	RET
casfail:
	MOVW	$0, R0
	MOVB	R0, ret+12(FP)
	RET

TEXT runtimecasuintptr(SB),NOSPLIT,$0-13
	B	runtimecas(SB)

TEXT runtimeatomicloaduintptr(SB),NOSPLIT,$0-8
	B	runtimeatomicload(SB)

TEXT runtimeatomicloaduint(SB),NOSPLIT,$0-8
	B	runtimeatomicload(SB)

TEXT runtimeatomicstoreuintptr(SB),NOSPLIT,$0-8
	B	runtimeatomicstore(SB)

// AES hashing not implemented for ARM
TEXT runtimeaeshash(SB),NOSPLIT,$-4-0
	MOVW	$0, R0
	MOVW	(R0), R1
TEXT runtimeaeshash32(SB),NOSPLIT,$-4-0
	MOVW	$0, R0
	MOVW	(R0), R1
TEXT runtimeaeshash64(SB),NOSPLIT,$-4-0
	MOVW	$0, R0
	MOVW	(R0), R1
TEXT runtimeaeshashstr(SB),NOSPLIT,$-4-0
	MOVW	$0, R0
	MOVW	(R0), R1

TEXT runtimememeq(SB),NOSPLIT,$-4-13
	MOVW	a+0(FP), R1
	MOVW	b+4(FP), R2
	MOVW	size+8(FP), R3
	ADD	R1, R3, R6
	MOVW	$1, R0
	MOVB	R0, ret+12(FP)
_next2:
	CMP	R1, R6
	RET.EQ
	MOVBU.P	1(R1), R4
	MOVBU.P	1(R2), R5
	CMP	R4, R5
	BEQ	_next2

	MOVW	$0, R0
	MOVB	R0, ret+12(FP)
	RET

// eqstring tests whether two strings are equal.
// See runtime_test.go:eqstring_generic for
// equivalent Go code.
TEXT runtimeeqstring(SB),NOSPLIT,$-4-17
	MOVW	s1len+4(FP), R0
	MOVW	s2len+12(FP), R1
	MOVW	$0, R7
	CMP	R0, R1
	MOVB.NE R7, v+16(FP)
	RET.NE
	MOVW	s1str+0(FP), R2
	MOVW	s2str+8(FP), R3
	MOVW	$1, R8
	MOVB	R8, v+16(FP)
	CMP	R2, R3
	RET.EQ
	ADD	R2, R0, R6
_eqnext:
	CMP	R2, R6
	RET.EQ
	MOVBU.P	1(R2), R4
	MOVBU.P	1(R3), R5
	CMP	R4, R5
	BEQ	_eqnext
	MOVB	R7, v+16(FP)
	RET

// void setg_gcc(G*); set g called from gcc.
TEXT setg_gcc<>(SB),NOSPLIT,$0
	MOVW	R0, g
	B		runtimesave_g(SB)

// TODO: share code with memeq?
TEXT bytesEqual(SB),NOSPLIT,$0
	MOVW	a_len+4(FP), R1
	MOVW	b_len+16(FP), R3
	
	CMP	R1, R3		// unequal lengths are not equal
	B.NE	_notequal

	MOVW	a+0(FP), R0
	MOVW	b+12(FP), R2
	ADD	R0, R1		// end

_byteseq_next:
	CMP	R0, R1
	B.EQ	_equal		// reached the end
	MOVBU.P	1(R0), R4
	MOVBU.P	1(R2), R5
	CMP	R4, R5
	B.EQ	_byteseq_next

_notequal:
	MOVW	$0, R0
	MOVBU	R0, ret+24(FP)
	RET

_equal:
	MOVW	$1, R0
	MOVBU	R0, ret+24(FP)
	RET

TEXT bytesIndexByte(SB),NOSPLIT,$0
	MOVW	s+0(FP), R0
	MOVW	s_len+4(FP), R1
	MOVBU	c+12(FP), R2	// byte to find
	MOVW	R0, R4		// store base for later
	ADD	R0, R1		// end 

_loop:
	CMP	R0, R1
	B.EQ	_notfound
	MOVBU.P	1(R0), R3
	CMP	R2, R3
	B.NE	_loop

	SUB	$1, R0		// R0 will be one beyond the position we want
	SUB	R4, R0		// remove base
	MOVW    R0, ret+16(FP) 
	RET

_notfound:
	MOVW	$-1, R0
	MOVW	R0, ret+16(FP)
	RET

TEXT stringsIndexByte(SB),NOSPLIT,$0
	MOVW	s+0(FP), R0
	MOVW	s_len+4(FP), R1
	MOVBU	c+8(FP), R2	// byte to find
	MOVW	R0, R4		// store base for later
	ADD	R0, R1		// end 

_sib_loop:
	CMP	R0, R1
	B.EQ	_sib_notfound
	MOVBU.P	1(R0), R3
	CMP	R2, R3
	B.NE	_sib_loop

	SUB	$1, R0		// R0 will be one beyond the position we want
	SUB	R4, R0		// remove base
	MOVW	R0, ret+12(FP) 
	RET

_sib_notfound:
	MOVW	$-1, R0
	MOVW	R0, ret+12(FP)
	RET

// A Duff's device for zeroing memory.
// The compiler jumps to computed addresses within
// this routine to zero chunks of memory.  Do not
// change this code without also changing the code
// in ../../cmd/5g/ggen.c:clearfat.
// R0: zero
// R1: ptr to memory to be zeroed
// R1 is updated as a side effect.
TEXT runtimeduffzero(SB),NOSPLIT,$0-0
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	MOVW.P	R0, 4(R1)
	RET

// A Duff's device for copying memory.
// The compiler jumps to computed addresses within
// this routine to copy chunks of memory.  Source
// and destination must not overlap.  Do not
// change this code without also changing the code
// in ../../cmd/5g/cgen.c:sgen.
// R0: scratch space
// R1: ptr to source memory
// R2: ptr to destination memory
// R1 and R2 are updated as a side effect
TEXT runtimeduffcopy(SB),NOSPLIT,$0-0
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	MOVW.P	4(R1), R0
	MOVW.P	R0, 4(R2)
	RET

TEXT runtimefastrand1(SB),NOSPLIT,$-4-4
	MOVW	g_m(g), R1
	MOVW	m_fastrand(R1), R0
	ADD.S	R0, R0
	EOR.MI	$0x88888eef, R0
	MOVW	R0, m_fastrand(R1)
	MOVW	R0, ret+0(FP)
	RET

TEXT runtimereturn0(SB),NOSPLIT,$0
	MOVW	$0, R0
	RET

TEXT runtimeprocyield(SB),NOSPLIT,$-4
	MOVW	cycles+0(FP), R1
	MOVW	$0, R0
yieldloop:
	CMP	R0, R1
	B.NE	2(PC)
	RET
	SUB	$1, R1
	B yieldloop

// Called from cgo wrappers, this function returns g->m->curg.stack.hi.
// Must obey the gcc calling convention.
TEXT _cgo_topofstack(SB),NOSPLIT,$8
	// R11 and g register are clobbered by load_g.  They are
	// callee-save in the gcc calling convention, so save them here.
	MOVW	R11, saveR11-4(SP)
	MOVW	g, saveG-8(SP)
	
	BL	runtimeload_g(SB)
	MOVW	g_m(g), R0
	MOVW	m_curg(R0), R0
	MOVW	(g_stack+stack_hi)(R0), R0
	
	MOVW	saveG-8(SP), g
	MOVW	saveR11-4(SP), R11
	RET

// The top-most function running on a goroutine
// returns to goexit+PCQuantum.
TEXT runtimegoexit(SB),NOSPLIT,$-4-0
	MOVW	R0, R0	// NOP
	BL	runtimegoexit1(SB)	// does not return
                                                                                                                                                                                                                                                        root/go1.4/src/runtime/atomic.go                                                                    0100644 0000000 0000000 00000002052 12600426227 015135  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build !arm

package runtime

import "unsafe"

//go:noescape
func xadd(ptr *uint32, delta int32) uint32

//go:noescape
func xadd64(ptr *uint64, delta int64) uint64

//go:noescape
func xchg(ptr *uint32, new uint32) uint32

//go:noescape
func xchg64(ptr *uint64, new uint64) uint64

//go:noescape
func xchgp(ptr unsafe.Pointer, new unsafe.Pointer) unsafe.Pointer

//go:noescape
func xchguintptr(ptr *uintptr, new uintptr) uintptr

//go:noescape
func atomicload(ptr *uint32) uint32

//go:noescape
func atomicload64(ptr *uint64) uint64

//go:noescape
func atomicloadp(ptr unsafe.Pointer) unsafe.Pointer

//go:noescape
func atomicor8(ptr *uint8, val uint8)

//go:noescape
func cas64(ptr *uint64, old, new uint64) bool

//go:noescape
func atomicstore(ptr *uint32, val uint32)

//go:noescape
func atomicstore64(ptr *uint64, val uint64)

//go:noescape
func atomicstorep(ptr unsafe.Pointer, val unsafe.Pointer)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      root/go1.4/src/runtime/atomic_386.c                                                                 0100644 0000000 0000000 00000001345 12600426227 015356  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include "runtime.h"
#include "textflag.h"

#pragma textflag NOSPLIT
uint32
runtimeatomicload(uint32 volatile* addr)
{
	return *addr;
}

#pragma textflag NOSPLIT
void*
runtimeatomicloadp(void* volatile* addr)
{
	return *addr;
}

#pragma textflag NOSPLIT
uint64
runtimexadd64(uint64 volatile* addr, int64 v)
{
	uint64 old;

	do
		old = *addr;
	while(!runtimecas64(addr, old, old+v));

	return old+v;
}

#pragma textflag NOSPLIT
uint64
runtimexchg64(uint64 volatile* addr, uint64 v)
{
	uint64 old;

	do
		old = *addr;
	while(!runtimecas64(addr, old, v));

	return old;
}
                                                                                                                                                                                                                                                                                           root/go1.4/src/runtime/atomic_amd64x.c                                                              0100644 0000000 0000000 00000001003 12600426227 016130  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build amd64 amd64p32

#include "runtime.h"
#include "textflag.h"

#pragma textflag NOSPLIT
uint32
runtimeatomicload(uint32 volatile* addr)
{
	return *addr;
}

#pragma textflag NOSPLIT
uint64
runtimeatomicload64(uint64 volatile* addr)
{
	return *addr;
}

#pragma textflag NOSPLIT
void*
runtimeatomicloadp(void* volatile* addr)
{
	return *addr;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             root/go1.4/src/runtime/atomic_arm.go                                                                0100644 0000000 0000000 00000005236 12600426227 016003  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package runtime

import "unsafe"

var locktab [57]struct {
	l   mutex
	pad [_CacheLineSize - unsafe.Sizeof(mutex{})]byte
}

func addrLock(addr *uint64) *mutex {
	return &locktab[(uintptr(unsafe.Pointer(addr))>>3)%uintptr(len(locktab))].l
}

// Atomic add and return new value.
//go:nosplit
func xadd(val *uint32, delta int32) uint32 {
	for {
		oval := *val
		nval := oval + uint32(delta)
		if cas(val, oval, nval) {
			return nval
		}
	}
}

//go:nosplit
func xchg(addr *uint32, v uint32) uint32 {
	for {
		old := *addr
		if cas(addr, old, v) {
			return old
		}
	}
}

//go:nosplit
func xchgp(addr *unsafe.Pointer, v unsafe.Pointer) unsafe.Pointer {
	for {
		old := *addr
		if casp(addr, old, v) {
			return old
		}
	}
}

//go:nosplit
func xchguintptr(addr *uintptr, v uintptr) uintptr {
	return uintptr(xchg((*uint32)(unsafe.Pointer(addr)), uint32(v)))
}

//go:nosplit
func atomicload(addr *uint32) uint32 {
	return xadd(addr, 0)
}

//go:nosplit
func atomicloadp(addr unsafe.Pointer) unsafe.Pointer {
	return unsafe.Pointer(uintptr(xadd((*uint32)(addr), 0)))
}

//go:nosplit
func atomicstorep(addr unsafe.Pointer, v unsafe.Pointer) {
	for {
		old := *(*unsafe.Pointer)(addr)
		if casp((*unsafe.Pointer)(addr), old, v) {
			return
		}
	}
}

//go:nosplit
func atomicstore(addr *uint32, v uint32) {
	for {
		old := *addr
		if cas(addr, old, v) {
			return
		}
	}
}

//go:nosplit
func cas64(addr *uint64, old, new uint64) bool {
	var ok bool
	onM(func() {
		lock(addrLock(addr))
		if *addr == old {
			*addr = new
			ok = true
		}
		unlock(addrLock(addr))
	})
	return ok
}

//go:nosplit
func xadd64(addr *uint64, delta int64) uint64 {
	var r uint64
	onM(func() {
		lock(addrLock(addr))
		r = *addr + uint64(delta)
		*addr = r
		unlock(addrLock(addr))
	})
	return r
}

//go:nosplit
func xchg64(addr *uint64, v uint64) uint64 {
	var r uint64
	onM(func() {
		lock(addrLock(addr))
		r = *addr
		*addr = v
		unlock(addrLock(addr))
	})
	return r
}

//go:nosplit
func atomicload64(addr *uint64) uint64 {
	var r uint64
	onM(func() {
		lock(addrLock(addr))
		r = *addr
		unlock(addrLock(addr))
	})
	return r
}

//go:nosplit
func atomicstore64(addr *uint64, v uint64) {
	onM(func() {
		lock(addrLock(addr))
		*addr = v
		unlock(addrLock(addr))
	})
}

//go:nosplit
func atomicor8(addr *uint8, v uint8) {
	// Align down to 4 bytes and use 32-bit CAS.
	uaddr := uintptr(unsafe.Pointer(addr))
	addr32 := (*uint32)(unsafe.Pointer(uaddr &^ 3))
	word := uint32(v) << ((uaddr & 3) * 8) // little endian
	for {
		old := *addr32
		if cas(addr32, old, old|word) {
			return
		}
	}
}
                                                                                                                                                                                                                                                                                                                                                                  root/go1.4/src/runtime/cgo/                                                                         0040755 0000000 0000000 00000000000 12600426244 014105  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/runtime/cgo/asm_386.s                                                                0100644 0000000 0000000 00000001042 12600426227 015444  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include "textflag.h"

/*
 * void crosscall2(void (*fn)(void*, int32), void*, int32)
 * Save registers and call fn with two arguments.
 */
TEXT crosscall2(SB),NOSPLIT,$0
	PUSHL	BP
	MOVL	SP, BP
	PUSHL	BX
	PUSHL	SI
	PUSHL	DI
	
	SUBL	$8, SP
	MOVL	16(BP), AX
	MOVL	AX, 4(SP)
	MOVL	12(BP), AX
	MOVL	AX, 0(SP)
	MOVL	8(BP), AX
	CALL	AX
	ADDL	$8, SP
	
	POPL	DI
	POPL	SI
	POPL	BX
	POPL	BP
	RET
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              root/go1.4/src/runtime/cgo/asm_amd64.s                                                              0100644 0000000 0000000 00000001766 12600426227 016054  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include "textflag.h"

/*
 * void crosscall2(void (*fn)(void*, int32), void*, int32)
 * Save registers and call fn with two arguments.
 */
TEXT crosscall2(SB),NOSPLIT,$0
	SUBQ	$0x58, SP	/* keeps stack pointer 32-byte aligned */
	MOVQ	BX, 0x10(SP)
	MOVQ	BP, 0x18(SP)
	MOVQ	R12, 0x20(SP)
	MOVQ	R13, 0x28(SP)
	MOVQ	R14, 0x30(SP)
	MOVQ	R15, 0x38(SP)

#ifdef GOOS_windows
	// Win64 save RBX, RBP, RDI, RSI, RSP, R12, R13, R14, and R15
	MOVQ	DI, 0x40(SP)
	MOVQ	SI, 0x48(SP)

	MOVQ	DX, 0(SP)	/* arg */
	MOVQ	R8, 8(SP)	/* argsize (includes padding) */
	
	CALL	CX	/* fn */
	
	MOVQ	0x40(SP), DI
	MOVQ	0x48(SP), SI
#else
	MOVQ	SI, 0(SP)	/* arg */
	MOVQ	DX, 8(SP)	/* argsize (includes padding) */

	CALL	DI	/* fn */
#endif

	MOVQ	0x10(SP), BX
	MOVQ	0x18(SP), BP
	MOVQ	0x20(SP), R12
	MOVQ	0x28(SP), R13
	MOVQ	0x30(SP), R14
	MOVQ	0x38(SP), R15
	
	ADDQ	$0x58, SP
	RET
          root/go1.4/src/runtime/cgo/asm_arm.s                                                                0100644 0000000 0000000 00000001560 12600426227 015710  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2012 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include "textflag.h"

/*
 * void crosscall2(void (*fn)(void*, int32), void*, int32)
 * Save registers and call fn with two arguments.
 */
TEXT crosscall2(SB),NOSPLIT,$-4
	/* 
	 * We still need to save all callee save register as before, and then
	 *  push 2 args for fn (R1 and R2).
	 * Also note that at procedure entry in 5c/5g world, 4(R13) will be the
	 *  first arg, so we must push another dummy reg (R0) for 0(R13).
	 *  Additionally, runtimeload_g will clobber R0, so we need to save R0
	 *  nevertheless.
	 */
	MOVM.WP	[R0, R1, R2, R4, R5, R6, R7, R8, R9, g, R11, R12, R14], (R13)
	BL	runtimeload_g(SB)
	MOVW	PC, R14
	MOVW	0(R13), PC
	MOVM.IAW	(R13), [R0, R1, R2, R4, R5, R6, R7, R8, R9, g, R11, R12, PC]
                                                                                                                                                root/go1.4/src/runtime/cgo/asm_nacl_amd64p32.s                                                      0100644 0000000 0000000 00000000530 12600426227 017362  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include "textflag.h"

/*
 * void crosscall2(void (*fn)(void*, int32), void*, int32)
 * Save registers and call fn with two arguments.
 */
TEXT crosscall2(SB),NOSPLIT,$0
	INT $3
	RET
                                                                                                                                                                        root/go1.4/src/runtime/cgo/callbacks.c                                                              0100644 0000000 0000000 00000005344 12600426227 016174  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include "../runtime.h"
#include "../cgocall.h"
#include "textflag.h"

// These utility functions are available to be called from code
// compiled with gcc via crosscall2.

// The declaration of crosscall2 is:
//   void crosscall2(void (*fn)(void *, int), void *, int);
// 
// We need to export the symbol crosscall2 in order to support
// callbacks from shared libraries. This applies regardless of
// linking mode.
#pragma cgo_export_static crosscall2
#pragma cgo_export_dynamic crosscall2

// Allocate memory.  This allocates the requested number of bytes in
// memory controlled by the Go runtime.  The allocated memory will be
// zeroed.  You are responsible for ensuring that the Go garbage
// collector can see a pointer to the allocated memory for as long as
// it is valid, e.g., by storing a pointer in a local variable in your
// C function, or in memory allocated by the Go runtime.  If the only
// pointers are in a C global variable or in memory allocated via
// malloc, then the Go garbage collector may collect the memory.

// Call like this in code compiled with gcc:
//   struct { size_t len; void *ret; } a;
//   a.len = /* number of bytes to allocate */;
//   crosscall2(_cgo_allocate, &a, sizeof a);
//   /* Here a.ret is a pointer to the allocated memory.  */

void runtime_cgo_allocate_internal(void);

#pragma cgo_export_static _cgo_allocate
#pragma cgo_export_dynamic _cgo_allocate
#pragma textflag NOSPLIT
void
_cgo_allocate(void *a, int32 n)
{
	runtimecgocallback((void(*)(void))runtime_cgo_allocate_internal, a, n);
}

// Panic.  The argument is converted into a Go string.

// Call like this in code compiled with gcc:
//   struct { const char *p; } a;
//   a.p = /* string to pass to panic */;
//   crosscall2(_cgo_panic, &a, sizeof a);
//   /* The function call will not return.  */

void runtime_cgo_panic_internal(void);

#pragma cgo_export_static _cgo_panic
#pragma cgo_export_dynamic _cgo_panic
#pragma textflag NOSPLIT
void
_cgo_panic(void *a, int32 n)
{
	runtimecgocallback((void(*)(void))runtime_cgo_panic_internal, a, n);
}

#pragma cgo_import_static x_cgo_init
extern void x_cgo_init(G*);
void (*_cgo_init)(G*) = x_cgo_init;

#pragma cgo_import_static x_cgo_malloc
extern void x_cgo_malloc(void*);
void (*_cgo_malloc)(void*) = x_cgo_malloc;

#pragma cgo_import_static x_cgo_free
extern void x_cgo_free(void*);
void (*_cgo_free)(void*) = x_cgo_free;

#pragma cgo_import_static x_cgo_thread_start
extern void x_cgo_thread_start(void*);
void (*_cgo_thread_start)(void*) = x_cgo_thread_start;

#pragma cgo_export_static _cgo_topofstack
#pragma cgo_export_dynamic _cgo_topofstack
                                                                                                                                                                                                                                                                                            root/go1.4/src/runtime/cgo/cgo.go                                                                   0100644 0000000 0000000 00000001170 12600426227 015201  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

/*
Package cgo contains runtime support for code generated
by the cgo tool.  See the documentation for the cgo command
for details on using cgo.
*/
package cgo

/*

#cgo darwin LDFLAGS: -lpthread
#cgo dragonfly LDFLAGS: -lpthread
#cgo freebsd LDFLAGS: -lpthread
#cgo android LDFLAGS: -llog
#cgo !android,linux LDFLAGS: -lpthread
#cgo netbsd LDFLAGS: -lpthread
#cgo openbsd LDFLAGS: -lpthread
#cgo windows LDFLAGS: -lm -mthreads

#cgo CFLAGS: -Wall -Werror

*/
import "C"
                                                                                                                                                                                                                                                                                                                                                                                                        root/go1.4/src/runtime/cgo/dragonfly.c                                                              0100644 0000000 0000000 00000000770 12600426227 016240  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build dragonfly

#include "textflag.h"

// Supply environ and __progname, because we don't
// link against the standard DragonFly crt0.o and the
// libc dynamic library needs them.

#pragma dataflag NOPTR
char *environ[1];
#pragma dataflag NOPTR
char *__progname;

#pragma dynexport environ environ
#pragma dynexport __progname __progname
        root/go1.4/src/runtime/cgo/freebsd.c                                                                0100644 0000000 0000000 00000000764 12600426227 015670  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2010 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build freebsd

#include "textflag.h"

// Supply environ and __progname, because we don't
// link against the standard FreeBSD crt0.o and the
// libc dynamic library needs them.

#pragma dataflag NOPTR
char *environ[1];
#pragma dataflag NOPTR
char *__progname;

#pragma dynexport environ environ
#pragma dynexport __progname __progname
            root/go1.4/src/runtime/cgo/gcc_386.S                                                                0100644 0000000 0000000 00000001617 12600426227 015370  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

/*
 * Apple still insists on underscore prefixes for C function names.
 */
#if defined(__APPLE__) || defined(_WIN32)
#define EXT(s) _##s
#else
#define EXT(s) s
#endif

/*
 * void crosscall_386(void (*fn)(void))
 *
 * Calling into the 8c tool chain, where all registers are caller save.
 * Called from standard x86 ABI, where %ebp, %ebx, %esi,
 * and %edi are callee-save, so they must be saved explicitly.
 */
.globl EXT(crosscall_386)
EXT(crosscall_386):
	pushl %ebp
	movl %esp, %ebp
	pushl %ebx
	pushl %esi
	pushl %edi

	movl 8(%ebp), %eax	/* fn */
	call *%eax

	popl %edi
	popl %esi
	popl %ebx
	popl %ebp
	ret

.globl EXT(__stack_chk_fail_local)
EXT(__stack_chk_fail_local):
1:
	jmp 1b

#ifdef __ELF__
.section .note.GNU-stack,"",@progbits
#endif
                                                                                                                 root/go1.4/src/runtime/cgo/gcc_amd64.S                                                              0100644 0000000 0000000 00000001711 12600426227 015756  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

/*
 * Apple still insists on underscore prefixes for C function names.
 */
#if defined(__APPLE__)
#define EXT(s) _##s
#else
#define EXT(s) s
#endif

/*
 * void crosscall_amd64(void (*fn)(void))
 *
 * Calling into the 6c tool chain, where all registers are caller save.
 * Called from standard x86-64 ABI, where %rbx, %rbp, %r12-%r15
 * are callee-save so they must be saved explicitly.
 * The standard x86-64 ABI passes the three arguments m, g, fn
 * in %rdi, %rsi, %rdx.
 */
.globl EXT(crosscall_amd64)
EXT(crosscall_amd64):
	pushq %rbx
	pushq %rbp
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15

#if defined(_WIN64)
	call *%rcx	/* fn */
#else
	call *%rdi	/* fn */
#endif

	popq %r15
	popq %r14
	popq %r13
	popq %r12
	popq %rbp
	popq %rbx
	ret

#ifdef __ELF__
.section .note.GNU-stack,"",@progbits
#endif
                                                       root/go1.4/src/runtime/cgo/gcc_android.c                                                            0100644 0000000 0000000 00000001331 12600426227 016501  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include <stdarg.h>
#include <android/log.h>
#include "libcgo.h"

void
fatalf(const char* format, ...)
{
	va_list ap;

	// Write to both stderr and logcat.
	//
	// When running from an .apk, /dev/stderr and /dev/stdout
	// redirect to /dev/null. And when running a test binary
	// via adb shell, it's easy to miss logcat.

	fprintf(stderr, "runtime/cgo: ");
	va_start(ap, format);
	vfprintf(stderr, format, ap);
	va_end(ap);
	fprintf(stderr, "\n");

	va_start(ap, format);
	__android_log_vprint(ANDROID_LOG_FATAL, "runtime/cgo", format, ap);
	va_end(ap);

	abort();
}
                                                                                                                                                                                                                                                                                                       root/go1.4/src/runtime/cgo/gcc_android_arm.c                                                        0100644 0000000 0000000 00000002304 12600426227 017341  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include <pthread.h>
#include <signal.h>
#include <stdio.h>
#include <sys/limits.h>
#include "libcgo.h"

#define magic1 (0x23581321U)

// PTHREAD_KEYS_MAX has been added to sys/limits.h at head in bionic:
// https://android.googlesource.com/platform/bionic/+/master/libc/include/sys/limits.h
// TODO(crawshaw): remove this definition when a new NDK is released.
#define PTHREAD_KEYS_MAX 128

// inittls allocates a thread-local storage slot for g.
//
// It finds the first available slot using pthread_key_create and uses
// it as the offset value for runtime.tlsg.
static void
inittls(void **tlsg, void **tlsbase)
{
	pthread_key_t k;
	int i, err;

	err = pthread_key_create(&k, nil);
	if(err != 0) {
		fatalf("pthread_key_create failed: %d", err);
	}
	pthread_setspecific(k, (void*)magic1);
	for (i=0; i<PTHREAD_KEYS_MAX; i++) {
		if (*(tlsbase+i) == (void*)magic1) {
			*tlsg = (void*)(i*sizeof(void *));
			pthread_setspecific(k, 0);
			return;
		}
	}
	fatalf("could not find pthread key");
}

void (*x_cgo_inittls)(void **tlsg, void **tlsbase) = inittls;
                                                                                                                                                                                                                                                                                                                            root/go1.4/src/runtime/cgo/gcc_arm.S                                                                0100644 0000000 0000000 00000002063 12600426227 015623  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2012 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

/*
 * Apple still insists on underscore prefixes for C function names.
 */
#if defined(__APPLE__)
#define EXT(s) _##s
#else
#define EXT(s) s
#endif

/*
 * void crosscall_arm1(void (*fn)(void), void (*setg_gcc)(void *g), void *g)
 *
 * Calling into the 5c tool chain, where all registers are caller save.
 * Called from standard ARM EABI, where r4-r11 are callee-save, so they
 * must be saved explicitly.
 */
.globl EXT(crosscall_arm1)
EXT(crosscall_arm1):
	push {r4, r5, r6, r7, r8, r9, r10, r11, ip, lr}
	mov r4, r0
	mov r5, r1
	mov r0, r2

	// Because the assembler might target an earlier revision of the ISA
	// by default, we encode BLX as a .word.
	.word 0xe12fff35 // blx r5 // setg(g)
	.word 0xe12fff34 // blx r4 // fn()

	pop {r4, r5, r6, r7, r8, r9, r10, r11, ip, pc}

.globl EXT(__stack_chk_fail_local)
EXT(__stack_chk_fail_local):
1:
	b 1b

#ifdef __ELF__
.section .note.GNU-stack,"",%progbits
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             root/go1.4/src/runtime/cgo/gcc_darwin_386.c                                                         0100644 0000000 0000000 00000007772 12600426227 016764  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include <string.h> /* for strerror */
#include <pthread.h>
#include <signal.h>
#include "libcgo.h"

static void* threadentry(void*);
static pthread_key_t k1;

#define magic1 (0x23581321U)

static void
inittls(void)
{
	uint32 x;
	pthread_key_t tofree[128], k;
	int i, ntofree;

	/*
	 * Allocate thread-local storage slot for g.
	 * The key numbers start at 0x100, and we expect to be
	 * one of the early calls to pthread_key_create, so we
	 * should be able to get a pretty low number.
	 *
	 * In Darwin/386 pthreads, %gs points at the thread
	 * structure, and each key is an index into the thread-local
	 * storage array that begins at offset 0x48 within in that structure.
	 * It may happen that we are not quite the first function to try
	 * to allocate thread-local storage keys, so instead of depending
	 * on getting 0x100, we try for 0x108, allocating keys until
	 * we get the one we want and then freeing the ones we didn't want.
	 *
	 * Thus the final offset to use in %gs references is
	 * 0x48+4*0x108 = 0x468.
	 *
	 * The linker and runtime hard-code this constant offset
	 * from %gs where we expect to find g.
	 * Known to ../../../liblink/sym.c:/468
	 * and to ../sys_darwin_386.s:/468
	 *
	 * This is truly disgusting and a bit fragile, but taking care
	 * of it here protects the rest of the system from damage.
	 * The alternative would be to use a global variable that
	 * held the offset and refer to that variable each time we
	 * need a %gs variable (g).  That approach would
	 * require an extra instruction and memory reference in
	 * every stack growth prolog and would also require
	 * rewriting the code that 8c generates for extern registers.
	 *
	 * Things get more disgusting on OS X 10.7 Lion.
	 * The 0x48 base mentioned above is the offset of the tsd
	 * array within the per-thread structure on Leopard and Snow Leopard.
	 * On Lion, the base moved a little, so while the math above
	 * still applies, the base is different.  Thus, we cannot
	 * look for specific key values if we want to build binaries
	 * that run on both systems.  Instead, forget about the
	 * specific key values and just allocate and initialize per-thread
	 * storage until we find a key that writes to the memory location
	 * we want.  Then keep that key.
	 */
	ntofree = 0;
	for(;;) {
		if(pthread_key_create(&k, nil) < 0) {
			fprintf(stderr, "runtime/cgo: pthread_key_create failed\n");
			abort();
		}
		pthread_setspecific(k, (void*)magic1);
		asm volatile("movl %%gs:0x468, %0" : "=r"(x));
		pthread_setspecific(k, 0);
		if(x == magic1) {
			k1 = k;
			break;
		}
		if(ntofree >= nelem(tofree)) {
			fprintf(stderr, "runtime/cgo: could not obtain pthread_keys\n");
			fprintf(stderr, "\ttried");
			for(i=0; i<ntofree; i++)
				fprintf(stderr, " %#x", (unsigned)tofree[i]);
			fprintf(stderr, "\n");
			abort();
		}
		tofree[ntofree++] = k;
	}

	/*
	 * We got the key we wanted.  Free the others.
	 */
	for(i=0; i<ntofree; i++)
		pthread_key_delete(tofree[i]);
}

void
x_cgo_init(G *g)
{
	pthread_attr_t attr;
	size_t size;

	pthread_attr_init(&attr);
	pthread_attr_getstacksize(&attr, &size);
	g->stacklo = (uintptr)&attr - size + 4096;
	pthread_attr_destroy(&attr);

	inittls();
}


void
_cgo_sys_thread_start(ThreadStart *ts)
{
	pthread_attr_t attr;
	sigset_t ign, oset;
	pthread_t p;
	size_t size;
	int err;

	sigfillset(&ign);
	pthread_sigmask(SIG_SETMASK, &ign, &oset);

	pthread_attr_init(&attr);
	pthread_attr_getstacksize(&attr, &size);
	// Leave stacklo=0 and set stackhi=size; mstack will do the rest.
	ts->g->stackhi = size;
	err = pthread_create(&p, &attr, threadentry, ts);

	pthread_sigmask(SIG_SETMASK, &oset, nil);

	if (err != 0) {
		fprintf(stderr, "runtime/cgo: pthread_create failed: %s\n", strerror(err));
		abort();
	}
}

static void*
threadentry(void *v)
{
	ThreadStart ts;

	ts = *(ThreadStart*)v;
	free(v);

	pthread_setspecific(k1, (void*)ts.g);

	crosscall_386(ts.fn);
	return nil;
}
      root/go1.4/src/runtime/cgo/gcc_darwin_amd64.c                                                       0100644 0000000 0000000 00000005002 12600426227 017337  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        