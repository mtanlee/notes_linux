, Jabber:, MSN:, Yahoo:, or ICQ:).
				Usually found in user records (kODRecordTypeUsers).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeIMHandle;

/*!
    @const		kODAttributeTypeIPAddress
    @abstract   IP address expressed either as domain or IP notation.
    @discussion IP address expressed either as domain or IP notation.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeIPAddress;

/*!
    @const		kODAttributeTypeIPAddressAndENetAddress
	@abstract   A pairing of IPv4 or IPv6 addresses with Ethernet addresses 
	@discussion A pairing of IPv4 or IPv6 addresses with Ethernet addresses 
				(e.g., "10.1.1.1/00:16:cb:92:56:41").  Usually found on kODRecordTypeComputers for use by 
				services that need specific pairing of the two values.  This should be in addition to 
				kODAttributeTypeIPAddress, kODAttributeTypeIPv6Address and kODAttributeTypeENetAddress. This is
				necessary because not all directories return attribute values in a guaranteed order.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeIPAddressAndENetAddress;

/*!
    @const		kODAttributeTypeIPv6Address
	@abstract   IPv6 address expressed in the standard notation
	@discussion IPv6 address expressed in the standard notation (e.g., "fe80::236:caff:fcc2:5641")
				Usually found on kODRecordTypeComputers and kODRecordTypeHosts.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeIPv6Address;

/*!
    @const		kODAttributeTypeJPEGPhoto
	@abstract   Used to store binary picture data in JPEG format. 
	@discussion Used to store binary picture data in JPEG format. 
				Usually found in user, people or group records (kODRecordTypeUsers, 
				kODRecordTypePeople, kODRecordTypeGroups).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeJPEGPhoto;

/*!
    @const		kODAttributeTypeJobTitle
	@abstract   Represents the job title of a user.
	@discussion Represents the job title of a user.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeJobTitle;

/*!
    @const		kODAttributeTypeKDCAuthKey
    @abstract   KDC master key RSA encrypted with realm public key.
    @discussion KDC master key RSA encrypted with realm public key.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeKDCAuthKey;

/*!
    @const		kODAttributeTypeKeywords
    @abstract   Keywords using for searching capability.
    @discussion Keywords using for searching capability.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeKeywords;

/*!
    @const		kODAttributeTypeLDAPReadReplicas
    @abstract   List of LDAP server URLs which can each be used to read directory data.
    @discussion List of LDAP server URLs which can each be used to read directory data.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeLDAPReadReplicas;

/*!
    @const		kODAttributeTypeLDAPWriteReplicas
    @abstract   List of LDAP server URLs which can each be used to write directory data.
    @discussion List of LDAP server URLs which can each be used to write directory data.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeLDAPWriteReplicas;

/*!
    @const		kODAttributeTypeMapCoordinates
	@abstract   attribute that defines coordinates for a user's location.
	@discussion attribute that defines coordinates for a user's location .
				found in user records (kODRecordTypeUsers) and resource records (kODRecordTypeResources).
				Example: 7.7,10.6
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMapCoordinates;

/*!
    @const		kODAttributeTypeMapURI
	@abstract   attribute that defines the URI of a user's location.
	@discussion attribute that defines the URI of a user's location.
				Usually found in user records (kODRecordTypeUsers). 
				Example: http://example.com/bldg1
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMapURI;

/*!
    @const		kODAttributeTypeMIME
    @abstract   Data contained in this attribute type is a fully qualified MIME Type. 
    @discussion Data contained in this attribute type is a fully qualified MIME Type. 
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMIME;

/*!
    @const		kODAttributeTypeMobileNumber
	@abstract   Represents the mobile numbers of a user or person.
	@discussion Represents the mobile numbers of a user or person.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMobileNumber;

/*!
    @const		kODAttributeTypeNestedGroups
    @abstract   Attribute type in group records for the list of GUID values for nested groups.
    @discussion Attribute type in group records for the list of GUID values for nested groups.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNestedGroups;

/*!
    @const		kODAttributeTypeNetGroups
	@abstract   Attribute type that indicates which netgroups its record is a member of.
	@discussion Attribute type that indicates which netgroups its record is a member of.
				Found in user and host records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNetGroups;

/*!
    @const		kODAttributeTypeNickName
	@abstract   Represents the nickname of a user or person.
	@discussion Represents the nickname of a user or person.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNickName;

/*!
    @const		kODAttributeTypeOrganizationInfo
    @abstract   Usually the organization info of a user.
    @discussion Usually the organization info of a user.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeOrganizationInfo;

/*!
    @const		kODAttributeTypeOrganizationName
    @abstract   Usually the organization of a user.
    @discussion Usually the organization of a user.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeOrganizationName;

/*!
    @const		kODAttributeTypePagerNumber
	@abstract   Represents the pager numbers of a user or person.
	@discussion Represents the pager numbers of a user or person.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePagerNumber;

/*!
    @const		kODAttributeTypePhoneContacts
	@abstract   attribute that defines a record's custom phone numbers.
	@discussion attribute that defines a record's custom phone numbers.
				found in user or people records.
					Example: home fax:408-555-4444
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePhoneContacts;

/*!
    @const		kODAttributeTypePhoneNumber
    @abstract   Telephone number of a user.
    @discussion Telephone number of a user.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePhoneNumber;

/*!
    @const		kODAttributeTypePGPPublicKey
    @abstract   Pretty Good Privacy public encryption key.
    @discussion Pretty Good Privacy public encryption key.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePGPPublicKey;

/*!
    @const		kODAttributeTypePostalAddress
    @abstract   The postal address usually excluding postal code.
    @discussion The postal address usually excluding postal code.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePostalAddress;

/*!
    @const		kODAttributeTypePostalAddressContacts
	@abstract   attribute that defines a record's alternate postal addresses.
	@discussion attribute that defines a record's alternate postal addresses.
				Found in user records (kODRecordTypeUsers) and resource records (kODRecordTypeResources).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePostalAddressContacts;

/*!
    @const		kODAttributeTypePostalCode
    @abstract   The postal code such as zip code in the USA.
    @discussion The postal code such as zip code in the USA.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePostalCode;

/*!
    @const		kODAttributeTypeNamePrefix
	@abstract   Represents the title prefix of a user or person.
	@discussion Represents the title prefix of a user or person.
				ie. Mr., Ms., Mrs., Dr., etc.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNamePrefix;

/*!
    @const      kODAttributeTypeProfiles
    @abstract   Profiles associated with the record.
 */
CF_EXPORT
const ODAttributeType kODAttributeTypeProfiles __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODAttributeTypeProfilesTimestamp
    @abstract   Timestamp for the profiles associated with the record.
 */
CF_EXPORT
const ODAttributeType kODAttributeTypeProfilesTimestamp __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const		kODAttributeTypeProtocols
    @abstract   List of protocols.
    @discussion List of protocols.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeProtocols;

/*!
    @const		kODAttributeTypeRecordName
    @abstract   List of names/keys for this record.
    @discussion List of names/keys for this record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeRecordName;

/*!
    @const		kODAttributeTypeRelationships
	@abstract   attribute that defines the relationship to the record type.
	@discussion attribute that defines the relationship to the record type.
				found in user records (kODRecordTypeUsers). 
					Example: brother:John
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeRelationships;

/*!
    @const		kODAttributeTypeResourceInfo
    @abstract   attribute that defines a resource record's info.
    @discussion attribute that defines a resource record's info.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeResourceInfo;

/*!
    @const		kODAttributeTypeResourceType
	@abstract   Attribute type for the kind of resource. 
	@discussion Attribute type for the kind of resource. 
				found in resource records (kODRecordTypeResources). 
					Example: ConferenceRoom
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeResourceType;

/*!
    @const		kODAttributeTypeState
    @abstract   The state or province of a country.
    @discussion The state or province of a country.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeState;

/*!
    @const		kODAttributeTypeStreet
	@abstract   Represents the street address of a user or person.
	@discussion Represents the street address of a user or person.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeStreet;

/*!
    @const		kODAttributeTypeNameSuffix
	@abstract   Represents the name suffix of a user or person.
	@discussion Represents the name suffix of a user or person.
				i.e., Jr., Sr., etc.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNameSuffix;

/*!
    @const		kODAttributeTypeURL
    @abstract   List of URLs.
    @discussion List of URLs.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeURL;

/*!
    @const		kODAttributeTypeVFSOpts
    @abstract   Used in support of mount records.
    @discussion Used in support of mount records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeVFSOpts;

/*!
    @const		kODAttributeTypeAlias
    @abstract   Alias attribute, contain pointer to another node/record/attribute.
    @discussion Alias attribute, contain pointer to another node/record/attribute.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAlias;

/*!
    @const		kODAttributeTypeAuthCredential
    @abstract   An authentication credential, to be used to authenticate to a Directory.
    @discussion An authentication credential, to be used to authenticate to a Directory.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAuthCredential;

/*!
    @const		kODAttributeTypeCopyTimestamp
    @abstract   Timestamp used in local account caching.
    @discussion Timestamp used in local account caching.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCopyTimestamp;

/*!
    @const		kODAttributeTypeDateRecordCreated
    @abstract   Date of record creation.
    @discussion Date of record creation.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeDateRecordCreated;

/*!
    @const		kODAttributeTypeKerberosRealm
    @abstract   Supports Kerberized SMB Server services.
    @discussion Supports Kerberized SMB Server services.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeKerberosRealm;

/*!
    @const		kODAttributeTypeNTDomainComputerAccount
    @abstract   Supports Kerberized SMB Server services.
    @discussion Supports Kerberized SMB Server services.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNTDomainComputerAccount;

/*!
    @const		kODAttributeTypeOriginalHomeDirectory
    @abstract   Home directory URL used in local account caching.
    @discussion Home directory URL used in local account caching.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeOriginalHomeDirectory;

/*!
    @const		kODAttributeTypeOriginalNFSHomeDirectory
    @abstract   NFS home directory used in local account caching.
    @discussion NFS home directory used in local account caching.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeOriginalNFSHomeDirectory;

/*!
    @const		kODAttributeTypeOriginalNodeName
    @abstract   Nodename used in local account caching.
    @discussion Nodename used in local account caching.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeOriginalNodeName;

/*!
    @const		kODAttributeTypePrimaryNTDomain
    @abstract   Supports Kerberized SMB Server services.
    @discussion Supports Kerberized SMB Server services.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrimaryNTDomain;

/*!
    @const		kODAttributeTypePwdAgingPolicy
    @abstract   Contains the password aging policy data for an authentication capable record.
    @discussion Contains the password aging policy data for an authentication capable record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePwdAgingPolicy;

/*!
    @const		kODAttributeTypeReadOnlyNode
	@abstract   Can be found using dsGetDirNodeInfo and will return one of
				ReadOnly, ReadWrite, or WriteOnly strings.
	@discussion Can be found using dsGetDirNodeInfo and will return one of
				ReadOnly, ReadWrite, or WriteOnly strings.
				Note that ReadWrite does not imply fully readable or writable
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeReadOnlyNode;

/*!
    @const		kODAttributeTypeTimePackage
    @abstract   Data of Create, Modify, Backup time in UTC.
    @discussion Data of Create, Modify, Backup time in UTC.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeTimePackage;

/*!
    @const		kODAttributeTypeTotalSize
    @abstract   checksum/meta data.
    @discussion checksum/meta data.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeTotalSize;

/*!
    @const		kODAttributeTypeAuthMethod
    @abstract   Authentication method for an authentication capable record.
    @discussion Authentication method for an authentication capable record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAuthMethod;

/*!
    @const		kODAttributeTypeMetaNodeLocation
    @abstract   Meta attribute returning registered node name by directory node plugin.
    @discussion Meta attribute returning registered node name by directory node plugin.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMetaNodeLocation;

/*!
    @const		kODAttributeTypeNodePath
	@abstract   Attribute type in Neighborhood records describing the DS Node to search while
				looking up aliases in this neighborhood.
	@discussion Attribute type in Neighborhood records describing the DS Node to search while
				looking up aliases in this neighborhood.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNodePath;

/*!
    @const		kODAttributeTypePlugInInfo
	@abstract   Information (version, signature, about, credits, etc.) about the plug-in
				that is actually servicing a particular directory node.
	@discussion Information (version, signature, about, credits, etc.) about the plug-in
				that is actually servicing a particular directory node.
				Has never been supported.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePlugInInfo;

/*!
    @const		kODAttributeTypeRecordType
    @abstract   Attribute for a Record or a Directory Node.
    @discussion Attribute for a Record or a Directory Node.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeRecordType;

/*!
    @const		kODAttributeTypeSchema
    @abstract   List of attribute types.
    @discussion List of attribute types.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSchema;

/*!
    @const		kODAttributeTypeSubNodes
	@abstract   Attribute of a node which lists the available subnodes
				of that node.
	@discussion Attribute of a node which lists the available subnodes
				of that node.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSubNodes;

/*!
    @const		kODAttributeTypeNetGroupTriplet
	@abstract   Attribute that defines the host, user and domain triplet combinations
				to support NetGroups.  Each attribute value is comma separated string to maintain the
				triplet (e.g., host,user,domain).
	@discussion Attribute that defines the host, user and domain triplet combinations
				to support NetGroups.  Each attribute value is comma separated string to maintain the
				triplet (e.g., host,user,domain).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNetGroupTriplet;

/*!
    @const		kODAttributeTypeSearchPath
    @abstract   Search path used by the search node.
    @discussion Search path used by the search node.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSearchPath;

/*!
    @const		kODAttributeTypeSearchPolicy
    @abstract   Search policy for the search node.
    @discussion Search policy for the search node.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSearchPolicy;

/*!
    @const		kODAttributeTypeAutomaticSearchPath
    @abstract   Automatic search path defined by the search node.
    @discussion Automatic search path defined by the search node.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAutomaticSearchPath;

/*!
    @const		kODAttributeTypeLocalOnlySearchPath
    @abstract   Local only search path defined by the search node.
    @discussion Local only search path defined by the search node.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeLocalOnlySearchPath;

/*!
    @const		kODAttributeTypeCustomSearchPath
    @abstract   Admin user configured custom search path defined by the search node.
    @discussion Admin user configured custom search path defined by the search node.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCustomSearchPath;

/*!
    @const      kODAttributeTypeNodeOptions
    @abstract   Any extended options supported by the node during creation
    @discussion Any extended options supported by the node during creation
 */
CF_EXPORT
const ODAttributeType kODAttributeTypeNodeOptions __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);

/*!
    @const      kODAttributeTypeNodeSASLRealm
    @abstract   Contains the SASL realm associated with this node (if any)
    @discussion Contains the SASL realm associated with this node (if any)
 */
CF_EXPORT
const ODAttributeType kODAttributeTypeNodeSASLRealm __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
	@const		kODAttributeTypeAdvertisedServices
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAdvertisedServices __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);

/*!
	@const		kODAttributeTypeLocaleRelay
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeLocaleRelay __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);

/*!
	@const		kODAttributeTypeLocaleSubnets
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeLocaleSubnets __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);

/*!
	@const		kODAttributeTypeNetworkInterfaces
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNetworkInterfaces __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);

/*!
	@const		kODAttributeTypeParentLocales
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeParentLocales __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);

/*!
	@const		kODAttributeTypePrimaryLocale
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrimaryLocale __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);

#pragma mark Attribute Types (Configure Node)

/*!
    @const		kODAttributeTypeBuildVersion
    @abstract   Build version for reference.
    @discussion Build version for reference.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeBuildVersion;

/*!
    @const		kODAttributeTypeConfigAvail
    @abstract   Config avail tag.
    @discussion Config avail tag.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeConfigAvailable;

/*!
    @const		kODAttributeTypeConfigFile
    @abstract   Config file name.
    @discussion Config file name.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeConfigFile;

/*!
    @const		kODAttributeTypeCoreFWVersion
    @abstract   Core FW version for reference.
    @discussion Core FW version for reference.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCoreFWVersion;

/*!
    @const		kODAttributeTypeFunctionalState
    @abstract   Functional state of plugin for example.
    @discussion Functional state of plugin for example.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeFunctionalState;

/*!
    @const		kODAttributeTypeFWVersion
    @abstract   Framework version for reference.
    @discussion Framework version for reference.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeFWVersion;

/*!
    @const		kODAttributeTypePluginIndex
    @abstract   Plugin index for reference.
    @discussion Plugin index for reference.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePluginIndex;

/*!
    @const		kODAttributeTypeNumTableList
    @abstract   Summary of the reference table entries presented as attribute values 
				from the Configure node.
    @discussion Summary of the reference table entries presented as attribute values
				from the Configure node.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNumTableList;

/*!
    @const		kODAttributeTypeVersion
    @abstract   Version label.
    @discussion Version label.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeVersion;

/*!
    @const		kODAttributeTypePIDValue
    @abstract   PID value.
    @discussion PID value.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePIDValue;

/*!
    @const		kODAttributeTypeProcessName
    @abstract   Process Name.
    @discussion Process Name.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeProcessName;

/*!
    @const		kODAttributeTypeTotalRefCount
    @abstract   Total count of references for a process.
    @discussion Total count of references for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeTotalRefCount;

/*!
    @const		kODAttributeTypeDirRefCount
    @abstract   Directory reference count for a process.
    @discussion Directory reference count for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeDirRefCount;

/*!
    @const		kODAttributeTypeNodeRefCount
    @abstract   Node reference count for a process.
    @discussion Node reference count for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNodeRefCount;

/*!
    @const		kODAttributeTypeRecRefCount
    @abstract   Record reference count for a process.
    @discussion Record reference count for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeRecRefCount;

/*!
    @const		kODAttributeTypeAttrListRefCount
    @abstract   Attribute List reference count for a process.
    @discussion Attribute List reference count for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAttrListRefCount;

/*!
    @const		kODAttributeTypeAttrListValueRefCount
    @abstract   Attr List Value reference count for a process.
    @discussion Attr List Value reference count for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAttrListValueRefCount;

/*!
    @const		kODAttributeTypeDirRefs
    @abstract   All the directory references for a process.
    @discussion All the directory references for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeDirRefs;

/*!
    @const		kODAttributeTypeNodeRefs
    @abstract   All the node references for a process.
    @discussion All the node references for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNodeRefs;

/*!
    @const		kODAttributeTypeRecRefs
    @abstract   All the record references for a process.
    @discussion All the record references for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeRecRefs;

/*!
    @const		kODAttributeTypeAttrListRefs
    @abstract   All the attribute list references for a process.
    @discussion All the attribute list references for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAttrListRefs;

/*!
    @const		kODAttributeTypeAttrListValueRefs
    @abstract   All the attribute list value references for a process.
    @discussion All the attribute list value references for a process.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAttrListValueRefs;

#pragma mark Authentication Types

/*!
    @const		kODAuthenticationType2WayRandom
	@abstract   Two way random authentication method.
	@discussion Two way random authentication method. This method uses two passes to
				complete the authentication.

				First pass authentication array has items:
					user name in UTF8 encoding

				Second pass authentication array has items:
					8 byte DES digest,
					8 bytes of random
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationType2WayRandom;

/*!
    @const		kODAuthenticationType2WayRandomChangePasswd
	@abstract   Change the password for a user using the two-way random method.
	@discussion Change the password for a user using the two-way random method.
				Does not require prior authentication.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					old password encrypted with new (should be 8 chars),
					new password encrypted with old (should be 8 chars)
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationType2WayRandomChangePasswd;

/*!
    @const		kODAuthenticationTypeAPOP
	@abstract   APOP authentication method.
	@discussion APOP authentication method.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					server challenge in UTF8 encoding,
					client response in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeAPOP;

/*!
    @const		kODAuthenticationTypeCRAM_MD5
	@abstract   CRAM MD5 authentication method.
	@discussion CRAM MD5 authentication method.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					server challenge in UTF8 encoding,
					client response data
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeCRAM_MD5;

/*!
    @const		kODAuthenticationTypeChangePasswd
	@abstract   Change the password for a user.
	@discussion Change the password for a user. Does not require prior authentication.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					old password in UTF8 encoding,
					new password in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeChangePasswd;

/*!
    @const		kODAuthenticationTypeClearText
	@abstract   Clear text authentication method.
	@discussion Clear text authentication method.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					password in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeClearText;

/*!
    @const		kODAuthenticationTypeCrypt
	@abstract   Use a crypt password stored in the user record if available to
				do the authentication.
	@discussion Use a crypt password stored in the user record if available to
				do the authentication.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					password in UTF8 encoding

				This method may not be supported by all plug-ins or for all users.
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeCrypt;

/*!
    @const		kODAuthenticationTypeDIGEST_MD5
	@abstract   Digest MD5 authentication method.
	@discussion Digest MD5 authentication method.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					server challenge in UTF8 encoding,
					client response data,
					HTTP method in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeDIGEST_MD5;

/*!
    @const		kODAuthenticationTypeDeleteUser
	@abstract   Used for Apple password server user deletion.
	@discussion Used for Apple password server user deletion.
				This authentication method is only implemented by the PasswordServer node.

				Authentication array has following items in order:
					Password Server ID in UTF8 encoding,
					authenticator password in UTF8 encoding,
					user's Password Server ID in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeDeleteUser;

/*!
    @const		kODAuthenticationTypeGetEffectivePolicy
	@abstract   Used to extract, from a password server, the actual policies that will be applied
				to a user; a combination of global and user policies.
	@discussion Used to extract, from a password server, the actual policies that will be applied
				to a user; a combination of global and user policies.

				Authentication array has following items in order:
					user name or Password Server ID in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeGetEffectivePolicy;

/*!
    @const		kODAuthenticationTypeGetGlobalPolicy
	@abstract   Used for extraction of global authentication policy.
	@discussion Used for extraction of global authentication policy. Authentication
				is not required to get policies. The authenticator name and password
				fields are optional.

				Authentication array has following items in order:
					user name in UTF8 encoding
					password in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeGetGlobalPolicy;

/*!
    @const		kODAuthenticationTypeGetKerberosPrincipal
	@abstract   Retrieves Kerberos Principal name.
	@discussion Retrieves Kerberos Principal name.

				Authentication array has following items in order:
					user name in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeGetKerberosPrincipal;

/*!
    @const		kODAuthenticationTypeGetPolicy
	@abstract   The plug-in should determine which specific authentication method to use.
	@discussion The plug-in should determine which specific authentication method to use.
				Authentication is not required to get policies. The authenticator name and password
				fields may be left blank by using a length of 1 and a zero-byte for the data.

				Authentication array has following items in order:
					authenticator's name or Password Server ID in UTF8 encoding,
					authenticator's password in UTF8 encoding
					account's name or Password Server ID

				The Password Server does not require authentication for this authentication method.
				The first two fields are to cover us for future policy changes and to keep the buffer
				format as standardized as possible.
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeGetPolicy;

/*!
    @const		kODAuthenticationTypeGetUserData
	@abstract   Used with Apple password server.
	@discussion Used with Apple password server. The password server maintains a space
				for a small amount of miscellaneous data.
				This authentication method is only implemented by the PasswordServer node.

				Authentication array has following items in order:
					authenticator's Password Server ID in UTF8 encoding,
					authenticator's password in UTF8 encoding
					Password Server ID in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeGetUserData;

/*!
    @const		kODAuthenticationTypeGetUserName
	@abstract   Used with Apple password server.
	@discussion Used with Apple password server. This name is the same as the primary
				short name for the user.
				This authentication method is only implemented by the PasswordServer node.

				Authentication array has following items in order:
					authenticator's Password Server ID in UTF8 encoding,
					authenticator's password in UTF8 encoding,
					user's Password Server ID in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeGetUserName;

/*!
    @const		kODAuthenticationTypeKerberosTickets
	@abstract   Provides write-access to LDAP with an existing Kerberos ticket.
	@discussion Provides write-access to LDAP with an existing Kerberos ticket

				Authentication array has following items in order:
					user name in UTF8 encoding,
					krb5_data containing a service ticket
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeKerberosTickets;

/*!
    @const		kODAuthenticationTypeMPPEMasterKeys
	@abstract   Generated 40-bit or 128-bit master keys from MS-CHAPv2 credentials (RFC 3079).
	@discussion Generated 40-bit or 128-bit master keys from MS-CHAPv2 credentials (RFC 3079).

				Authentication array has following items in order:
					user name in UTF8 encoding,
					MS-CHAPv2 digest (P24),
					key size, 8 or 16 (packed as a byte, not a string)
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeMPPEMasterKeys;

/*!
    @const		kODAuthenticationTypeMSCHAP2
	@abstract	MS-CHAP2 is a mutual authentication method.
	@discussion	MS-CHAP2 is a mutual authentication method. The plug-in will generate the data to
				send back to the client and put it in the continue items array.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					server challenge,
					peer challenge,
					client's digest,
					client's user name (the name used for MS-CHAPv2, usually the first short name)

				Continue items array contains:
					digest for the client's challenge
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeMSCHAP2;

/*!
    @const		kODAuthenticationTypeNTLMv2
	@abstract   Verifies an NTLMv2 challenge and response.
	@discussion Verifies an NTLMv2 challenge and response. The session keys
				(if any) must be retrieved separately with a trusted authentication.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					SMB server challenge,
					the client "blob" which includes 16 bytes of client digest prefixed
						to the the blob data,
					the user name used to calculate the digest in UTF8 encoding,
					the SMB domain in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeNTLMv2;

/*!
    @const		kODAuthenticationTypeNTLMv2WithSessionKey
	@abstract   An optimized method that checks the user's challenge and response
				and retrieves session keys in a single call.
	@discussion An optimized method that checks the user's challenge and response
				and retrieves session keys in a single call. If the NTLMv2 session key is
				supported, it is returned in the step buffer.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					SMB server challenge,
					the client "blob" which includes 16 bytes of client digest prefixed
						to the the blob data,
					the user name used to calculate the digest  in UTF8 encoding,
					the SMB domain in UTF8 encoding,
					user name in UTF8 encoding,
					authenticator password in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeNTLMv2WithSessionKey;

/*!
    @const		kODAuthenticationTypeNewUser
	@abstract	Create a new user record with the authentication authority.
	@discussion	Create a new user record with the authentication authority
				This authentication method is only implemented by the PasswordServer node.

				Authentication array has following items in order:
					authenticator's Password Server ID in UTF8 encoding,
					authenticator's password in UTF8 encoding,
					user's short-name,
					user's password
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeNewUser;

/*!
    @const		kODAuthenticationTypeNewUserWithPolicy
	@abstract	Create a new user record with the authentication authority and initial policy settings.
	@discussion	Create a new user record with the authentication authority and initial policy settings
				This authentication method is only implemented by the PasswordServer node.

				Authentication array has following items in order:
					authenticator's Password Server ID in UTF8 encoding,
					authenticator's password in UTF8 encoding,
					user's short-name,
					user's password,
					policy string in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeNewUserWithPolicy;

/*!
    @const		kODAuthenticationTypeNodeNativeClearTextOK
	@abstract   The plug-in should determine which specific authentication method to use.
	@discussion The plug-in should determine which specific authentication method to use.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					password in UTF8 encoding

				The plug-in may choose to use a cleartext authentication method if necessary.
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeNodeNativeClearTextOK;

/*!
    @const		kODAuthenticationTypeNodeNativeNoClearText
	@abstract   The plug-in should determine which specific authentication method to use.
	@discussion The plug-in should determine which specific authentication method to use.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					password in UTF8 encoding

				The plug-in must not use an authentication method that sends the password in cleartext.
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeNodeNativeNoClearText;

/*!
    @const		kODAuthenticationTypeReadSecureHash
	@abstract   Returns the SHA1 or Seeded SHA1 hash for a local user.
	@discussion Returns the SHA1 or Seeded SHA1 hash for a local user
				Only accessible by root processes. Only implemented by the local node.

				Authentication array has following items in order:
					user's name in UTF8 encoding

				Continue items array contains:
					value, either the old 20-byte SHA1 or the new seeded 24-byte SHA1.
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeReadSecureHash;

/*!
    @const		kODAuthenticationTypeSMBNTv2UserSessionKey
	@abstract   Generate the ntlm-v2 user session key.
	@discussion Generate the ntlm-v2 user session key. Requires prior authentication with a trusted
				authentication method.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					8 byte server challenge
					client response buffer
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSMBNTv2UserSessionKey;

/*!
    @const		kODAuthenticationTypeSMBWorkstationCredentialSessionKey
    @abstract   Generates an SMB workstation credential session key.
    @discussion Generates an SMB workstation credential session key.
 
				Authentication array has following items in order:
					user name in UTF8 encoding,
					8 byte server challenge + 8 byte client challenge
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSMBWorkstationCredentialSessionKey;

/*!
    @const		kODAuthenticationTypeSMB_LM_Key
	@abstract   SMB Lan Manager authentication method.
	@discussion SMB Lan Manager authentication method.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					8 byte server challenge,
					24 byte client response
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSMB_LM_Key;

/*!
    @const		kODAuthenticationTypeSMB_NT_Key
	@abstract   SMB NT authentication method.
	@discussion SMB NT authentication method.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					8 byte server challenge,
					24 byte client response
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSMB_NT_Key;

/*!
    @const		kODAuthenticationTypeSMB_NT_UserSessionKey
	@abstract   Used by SMB to get session keys.
	@discussion Used by SMB to get session keys
				This authentication method is only implemented by the PasswordServer node.

				Authentication array has following items in order:
					Password Server ID in UTF8 encoding

				Continue items array contains:
					MD4( ntHash )
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSMB_NT_UserSessionKey;

/*!
    @const		kODAuthenticationTypeSMB_NT_WithUserSessionKey
	@abstract   Used by SMB to authenticate and get session keys.
	@discussion Used by SMB to authenticate and get session keys

				Authentication array has following items in order:
					user name in UTF8 encoding,
					8 byte server challenge,
					24 byte client response,
					authenticator name in UTF8 encoding,
					authenticator password in UTF8 encoding

				Continue items array contains:
					MD4( ntHash )
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSMB_NT_WithUserSessionKey;

/*!
    @const		kODAuthenticationTypeSecureHash
	@abstract   Authentication specifically using the secure hash.
	@discussion Authentication specifically using the secure hash.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					salted SHA1 hash
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSecureHash __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_6, __MAC_10_7, __IPHONE_NA, __IPHONE_NA);

/*!
	@const		kODAuthenticationTypeSetCertificateHashAsCurrent
	@abstract	Set certificate using the authenticated user's credentials.
	@discussion	Set certificate using the authenticated user's credentials.

				Authentication array has the following items in order:
					user name in UTF8 encoding
					hashed certificate data (40 hex characters)
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetCertificateHashAsCurrent __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);

/*!
    @const		kODAuthenticationTypeSetGlobalPolicy
	@abstract   Used to set the global policy.
	@discussion Used to set the global policy.

				Authentication array has following items in order:
					user name or Password Server ID in UTF8 encoding,
					password in UTF8 encoding,
					policy string in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetGlobalPolicy;

/*!
    @const		kODAuthenticationTypeSetLMHash
	@abstract   Set the LAN Manager hash for an account.
	@discussion Set the LAN Manager hash for an account. This method requires prior authentication.
				Setting the LM hash for an account instead of the plain text password can cause the Windows
				password to get out-of-sync with the password for other services. Therefore, this
				authentication method should only be used when there is no other choice.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					LAN Manager hash buffer
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetLMHash;

/*!
    @const		kODAuthenticationTypeSetNTHash
	@abstract   Set the NT hash for a user.
	@discussion Set the NT hash for a user. This method requires prior authentication.
				Setting the NT hash for an account instead of the plain text password can cause the Windows
				password to get out-of-sync with the password for other services. Therefore, this
				authentication method should only be used when there is no other choice.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					NT hash buffer
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetNTHash;

/*!
    @const		kODAuthenticationTypeSetPassword
	@abstract   Set password method.
	@discussion Set password method.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					new password in UTF8 encoding,
					authenticator's name in UTF8 encoding,
					authenticator's password in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetPassword;

/*!
    @const		kODAuthenticationTypeSetPasswordAsCurrent
	@abstract   Set password using the current credentials.
	@discussion Set password using the current credentials.
 
				Authentication array has following items in order:
					user name in UTF8 encoding,
					new password in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetPasswordAsCurrent;

/*!
    @const		kODAuthenticationTypeSetPolicy
	@abstract   The plug-in should determine which specific authentication method to use.
	@discussion The plug-in should determine which specific authentication method to use.

				Authentication array has following items in order:
					authenticator's name or Password Server ID in UTF8 encoding,
					authenticator's password in UTF8 encoding,
					name or Password Server ID of the target account in UTF8 encoding,
					policy data
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetPolicy;

/*!
    @const		kODAuthenticationTypeSetPolicyAsCurrent
	@abstract   A set policy for the password server.
	@discussion A set policy for the password server.

				Authentication array has following items in order:
					user name or Password Server ID of the target account in UTF8 encoding,
					policy data
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetPolicyAsCurrent;

/*!
    @const		kODAuthenticationTypeSetUserData
	@abstract   Used for Apple password server.
	@discussion Used for Apple password server.
				This authentication method is only implemented by the PasswordServer node.

				Authentication array has following items in order:
					authenticator's Password Server ID in UTF8 encoding,
					authenticator's password in UTF8 encoding,
					Password Server ID in UTF8 encoding,
					user data
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetUserData;

/*!
    @const		kODAuthenticationTypeSetUserName
	@abstract   Used for Apple password server.
	@discussion Used for Apple password server.
				This authentication method is only implemented by the PasswordServer node.

				Authentication array has following items in order:
					authenticator's Password Server ID in UTF8 encoding,
					authenticator's password in UTF8 encoding,
					Password Server ID in UTF8 encoding,
					user's short name in UTF8 encoding
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetUserName;

/*!
    @const		kODAuthenticationTypeSetWorkstationPassword
	@abstract   Supports PDC SMB interaction with DS.
	@discussion Supports PDC SMB interaction with DS.
 
				Authentication array has following items in order:
					workstation's Password Server ID in UTF8 encoding,
					NT hash
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeSetWorkstationPassword;

/*!
    @const		kODAuthenticationTypeWithAuthorizationRef
	@abstract	Allows access to local directories as root with a valid AuthorizationRef.
	@discussion	Allows access to local directories as root with a valid AuthorizationRef.

				Authentication array has following items in order:
					externalized AuthorizationRef
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeWithAuthorizationRef;

/*!
    @const		kODAuthenticationTypeWriteSecureHash
	@abstract	Supports ONLY a root process to be able to directly write the secure hash of a user record.
	@discussion	Supports ONLY a root process to be able to directly write the secure hash of a user record.

				Authentication array has following items in order:
					user name in UTF8 encoding,
					salted SHA1 hash
*/
CF_EXPORT
const ODAuthenticationType kODAuthenticationTypeWriteSecureHash;

#pragma mark Policy Types

/*!
    @const      kODPolicyTypePasswordCannotBeAccountName
    @abstract   Boolean signifying the password must not contain the name of the account.
    @discussion Boolean signifying the password must not contain the name of the account.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordCannotBeAccountName __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordChangeRequired
    @abstract   Boolean stating the password should be changed on next logon.
    @discussion Should be set to a CFBooleanRef/NSNumber accordingly to signify the password should be changed at next logon.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordChangeRequired __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordHistory
    @abstract   The number of previous passwords that will be remembered.
    @discussion Should be set with a CFNumber/NSNumber accordingly with a range of 1 to 15 passwords.  Remove this policy or
                set to 0 if no history is tracked.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordHistory __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordMinimumNumberOfCharacters
    @abstract   The minimum number of characters a password must contain.
    @discussion A CFNumber/NSNumber signifying the minimum number of characters a password must contain.
 */
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordMinimumNumberOfCharacters __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordMaximumNumberOfCharacters
    @abstract   The maximum number of characters a password can contain.
    @discussion A CFNumber/NSNumber signifying the maximum number of characters a password can contain.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordMaximumNumberOfCharacters __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordMaximumAgeInMinutes
    @abstract   Number of minutes before password must be changed.
    @discussion The value for the policy should be a CFNumberRef/NSNumber accordingly.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordMaximumAgeInMinutes __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordRequiresAlpha
    @abstract   Sets the number of alpha characters that must present in the password.
    @discussion A CFNumber/NSNumber signifying the number of alpha characters [A-Z][a-z] that must be present in the password.
                Note, not all modules will support this capability.  If you exceed the module's capabilities, it will reset to
                the maximum supported by that module.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordRequiresAlpha __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordRequiresMixedCase
    @abstract   Boolean signifying if password requires mixed case characters both upper and lower characters.
    @discussion Boolean signifying if password requires mixed case characters both upper and lower characters.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordRequiresMixedCase __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordRequiresNumeric
    @abstract   Sets the number of numeric characters that must present in the password.
    @discussion A CFNumber/NSNumber signifying the number of numeric characters [0-9] that must be present in the password.
                Note, not all modules will support this capability.  If you exceed the module's capabilities, it will reset to
                the maximum supported by that module.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordRequiresNumeric __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordRequiresSymbol
    @abstract   Sets the number of symbol characters that must present in the password.
    @discussion A CFNumber/NSNumber signifying the number of symbol characters that must be present in the password.
                Note, not all modules will support this capability.  If you exceed the module's capabilities, it will reset to
                the maximum supported by that module.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordRequiresSymbol __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordSelfModification
    @abstract   Boolean stating if the account is allowed to change their own password.
    @discussion Should be set to a CFBooleanRef/NSNumber accordingly to signify the if the account holder is allowed to change
                their own password.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypePasswordSelfModification __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypeAccountExpiresOnDate
    @abstract   Date when an account expires and becomes deactivated.
    @discussion A CFDate/NSDate signifying when an account expires will be deactivated.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypeAccountExpiresOnDate __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypeAccountMaximumFailedLogins
    @abstract   Sets the number of maximum failed logins allowed for the account.
    @discussion A CFNumber/NSNumber signifying the number of times a bad password can be entered before the account is locked out.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypeAccountMaximumFailedLogins __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypeAccountMaximumMinutesUntilDisabled
    @abstract   Sets the number of maximum number of minutes before this account is disabled automatically from password set.
    @discussion A CFNumber/NSNumber signifying the number of minutes before the account should be auto-disabled.  Note,
                calculation of this is based on timestamp of the password, therefore also preventing the password from
                being changed is required.
 */
CF_EXPORT
const ODPolicyType kODPolicyTypeAccountMaximumMinutesUntilDisabled __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypePasswordMinutesUntilFailedLoginReset
    @abstract   Number of minutes before an account locked out by bad passwords is automatically re-activated.
    @discussion The value for the policy should be a CFNumberRef/NSNumber accordingly.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypeAccountMinutesUntilFailedLoginReset __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @const      kODPolicyTypeMaximumMinutesOfNonUse
    @abstract   Maximum number of minutes that an account has not been used before it is deactivated.
    @discussion A CFNumber/NSNumber signifying the number of minutes before an account has not been used before it is deactivated.
*/
CF_EXPORT
const ODPolicyType kODPolicyTypeAccountMaximumMinutesOfNonUse __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
   @enum        Expiration constants
   @abstract    Special values that may be returned by ODRecordSecondsUntil*Expires().
   @constant    kODExpirationTimeExpired indicates the password or authentication
                has expired.
   @constant    kODExpirationTimeNeverExpires indicates the password or
                authentication will never expire. 
*/
enum {
    kODExpirationTimeExpired      = 0LL,
    kODExpirationTimeNeverExpires = -1LL,
};

/*!
    @typedef    kODPolicyKeyType
    @abstract   Type for the keys in a policy dictionary.
    @discussion Type for the keys in a policy dictionary.  These are the
                expected keys in a policy.  Some keys are optional.  For more
                information see the the specific key.  Some keys are used in
                individual policies, others in a policy set.
*/
#ifdef __OBJC__
typedef NSString *ODPolicyKeyType;
#else
typedef CFStringRef ODPolicyKeyType;
#endif

/*!
    @const      kODPolicyKeyIdentifier
    @abstract   Key for the policy identifier in a policy dictionary.
    @discussion Key for the policy identifier in a policy dictionary.  Required
                key in a policy dictionary.  The value of this key is a string
                that uniquely identifies the policy.  It can be anything from a
                GUID to a string that describes the policy (e.g. "max num chars"). 
 */
CF_EXPORT
const ODPolicyKeyType kODPolicyKeyIdentifier __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyKeyParameters
    @abstract   Key for the policy parameters, if any, in a policy dictionary.
    @discussion Key for the policy parameters, if any, in a policy dictionary.
                Optional key in a policy dictionary.  The value of this key is a
                dictionary containing any parameters that are relevant to the
                policy.  Parameters may be used for information purposes or to
                provide additional data to be used in the policy format string.
 */
CF_EXPORT
const ODPolicyKeyType kODPolicyKeyParameters __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyKeyContent
    @abstract   Key for the policy format string in a policy dictionary.
    @discussion Key for the policy format string in a policy dictionary.
                Required key in a policy dictionary.  The value of this key is a
                string containing the policy itself, from which a predicate will
                be created.  The predicate will be applied during policy
                evaluation. 
 */
CF_EXPORT
const ODPolicyKeyType kODPolicyKeyContent __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyKeyContentDescription
    @abstract   Key for the policy content description.
    @discussion Key for the policy content description.  Used in either a policy
                dictionary or in kODPolicyKeyEvaluationDetails dictionary.  It
                is an optional key in either dictionary.

                When used in a policy dictionary, the value of this key is a
                dictionary containing key/value pairs consisting of locale
                identifiers and localized descriptions of the policy content.

                When used in kODPolicyKeyEvaluationDetails dictionary, the value
                is a string containing the localized description of the policy
                content.
 */
CF_EXPORT
const ODPolicyKeyType kODPolicyKeyContentDescription __OSX_AVAILABLE_STARTING(__MAC_10_11, __IPHONE_NA);

/*!
    @const      kODPolicyKeyEvaluationDetails
    @abstract   Key containing details of the policy evaluation results.
    @discussion Key containing details of the policy evaluation results.  This
                key may be used in the userInfo portion of a CFErrorRef/NSError.
                The value of this key is an array of dictionaries, with each
                dictionary containing the results of an individual policy
                evaluation.  The keys in the details dictionaries are:
                   kODPolicyKeyIdentifier
                   kODPolicyKeyContentDescription
                   kODPolicyKeyPolicySatisfied
*/
CF_EXPORT
const ODPolicyKeyType kODPolicyKeyEvaluationDetails __OSX_AVAILABLE_STARTING(__MAC_10_11, __IPHONE_NA);

/*!
    @const      kODPolicyKeyPolicySatisfied
    @abstract   Key denoting if a specific policy was satisfied during evaluation.
    @discussion Key denoting if a specific policy was satisfied during evaluation.
                This key is used in the dictionaries in kODPolicyKeyEvaluationDetails.
                The value of this key will be true if the specific policy was
                satisfied and false if not.
*/
CF_EXPORT
const ODPolicyKeyType kODPolicyKeyPolicySatisfied __OSX_AVAILABLE_STARTING(__MAC_10_11, __IPHONE_NA);

/*!
    @typedef    ODPolicyCategoryType
    @abstract   Type for the policy categories.
    @discussion Type for the policy categories.  Policy categories are also keys
                in a policy set dictionary, where the value of each category is
                an array of policy dictionaries.
*/
#ifdef __OBJC__
typedef NSString *ODPolicyCategoryType;
#else
typedef CFStringRef ODPolicyCategoryType;
#endif

/*!
    @const      kODPolicyCategoryAuthentication
    @abstract   Category for policies controlling when authentications are allowed.
    @discussion Category for policies controlling when authentications are allowed.  
                Policies in this category are evaluated when determining if an
                authentication should be allowed or when authentications will
                expire.  This constant is also used as a key in a policy set
                dictionary with a value containing an array of policy
                dictionaries. 
 */
CF_EXPORT
ODPolicyCategoryType kODPolicyCategoryAuthentication __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyCategoryPasswordContent
    @abstract   Category for policies controlling content of passwords.
    @discussion Category for policies controlling content of passwords.
                Policies in this category are evaluated when determining if a
                password contains the required content, which is typically done
                during password changes.  This constant is also used as a key in
                a policy set dictionary with a value containing an array of
                policy dictionaries.
 */
CF_EXPORT
ODPolicyCategoryType kODPolicyCategoryPasswordContent __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyCategoryPasswordChange
    @abstract   Category for policies controlling when password require changing.
    @discussion Category for policies controlling when password require changing.
 */
CF_EXPORT
ODPolicyCategoryType kODPolicyCategoryPasswordChange __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);


/*!
    @typedef    kODPolicyAttributeType
    @abstract   Type for attributes that may be used in policies.
    @discussion Type for attributes that may be used in policies.  Policies in
                this category will be evaluated when determining if an
                authentication should be allowed or when determine when a
                password will expire.  This constant is also used as a key in a
                policy set dictionary with a value containing an array of policy
                dictionaries. 
*/
#ifdef __OBJC__
typedef NSString *ODPolicyAttributeType;
#else
typedef CFStringRef ODPolicyAttributeType;
#endif

/*!
    @const      kODPolicyAttributeRecordName
    @abstract   Policy attribute for the record name.
    @discussion Policy attribute for the record name.  May be used in policies
                to compare against other record attributes.  For example, this
                Password Content policy string prevents the password from being
                the same as the record name:
                    [NSString stringWithFormat:@"%@ != %@", kODPolicyAttributeRecordName, kODPolicyAttributePassword];
 */
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeRecordName __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeRecordType
    @abstract   Policy attribute for the record type.
    @discussion Policy attribute for the record type.  Could be used in policies
                to tailor behavior for a particular record type.  For example,
                this Password Content policy string would require computer
                passwords to be a minimum of 24 characters long:
                    [NSString stringWithFormat:@"%@ == %@ and %@ matches '.{24,}+'",
                              kODPolicyAttributeRecordType, kODRecordTypeComputer,
                              kODPolicyAttributePassword]; 
 */
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeRecordType __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);


/*!
    @const      kODPolicyAttributePassword
    @abstract   Policy attribute for the password.
    @discussion Policy attribute for the password in plain text.  May be used in
		policies to compare against other attributes or for evaluation
		against regular expressions.  Primarily useful in the Password
		Content policies.  For example, this policy string checks
		whether the password length is at least 8 characters: 
                    [NSString stringWithFormat:@"%@ matches '.{8,}+'", kODPolicyAttributePassword];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributePassword __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributePasswordHashes
    @abstract   Policy attribute for the password hashes
    @discussion Policy attribute for the password hashes.  The value should be a
		CFArray containing one or more CFData values representing a
		password hash.

		Used in Password Content policy strings to compare the new
		password against the password history, for example:
                    [NSString stringWithFormat:@"none %@ in %@", kODPolicyAttributePasswordHashes, kODPolicyAttributePasswordHistory];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributePasswordHashes __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributePasswordHistory
    @abstract   Policy attribute for the list of previous password hashes
    @discussion Policy attribute for the list of previous password hashes.  The
		value of this attribute is a CFArray containing one or more
		CFData elements representing a hash of a previous password.
		Hash types may be mixed.

		Used in Password Content policy strings to compare the new
		password against the password history, for example:
                    [NSString stringWithFormat:@"none %@ in %@", kODPolicyAttributePasswordHashes, kODPolicyAttributePasswordHistory];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributePasswordHistory __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributePasswordHistoryDepth
    @abstract   Policy attribute for the number of previous hashed passwords to keep.
    @discussion Policy attribute for the number of previous hashed passwords to
                keep.  Should used as a key in the policy parameter dictionary,
                with a CFNumber value, specifying the number of password to keep.
                Should not be used in a policy string. 
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributePasswordHistoryDepth __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeCurrentDate
    @abstract   Policy attribute for the current date and time as a CFDate.
    @discussion Policy attribute for the current date and time as a CFDate used
                in policy strings to compare the current date against another
                date.  The following policy string would allow authentications
                until the expiration date: 
                    [NSString stringWithFormat:@"%@ < %@", kODPolicyAttributeCurrentDate, kODPolicyAttributeExpiresOnDate];

                Do not use kODPolicyAttributeCurrentDate in policies where date
                arithmetic is needed; for those policies use
                kODPolicyAttributeCurrentTime instead.
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeCurrentDate __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeCurrentTime
    @abstract   Policy attribute for the current date and time in seconds.
    @discussion Policy attribute for the current date and time in seconds since
                the Unix epoch.  Used in policy strings to compare the
                current time against other times.  Suitable for use in policies
                where "date arithmetic" is needed (i.e. adding/subtracting
                values to/from the current time or another time in seconds).
                Ensure all times and date arithmetic in the policy are specified
                in seconds.

                Note that kODPolicyAttributeExpiresEveryNDays needs to be
                converted to seconds to match the units of the other times.  The
                special keyword DAYS_TO_SECONDS can be used to accomplish this.

                In the policy below, password changes are required every 90 days
                (kODPolicyAttributeExpiresEveryNDays = 90).

                    [NSString stringWithFormat:@"%@ < %@ + (%@ * DAYS_TO_SECONDS)",
                              kODPolicyAttributeCurrentTime,
                              kODPolicyAttributeLastPasswordChangeTime,
                              kODPolicyAttributeExpiresEveryNDays];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeCurrentTime __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeCurrentTimeOfDay
    @abstract   Policy attribute for the current time of day as a CFNumber.
    @discussion Policy attribute for the current time of day as a CFNumber, in
                24 hour time, i.e. the range is 0000 through 2359.  Does not
                contain any date information.

                This attribute is used in policies to compare the current time
                of day against another time of day.  For example, to allow
                authentications between the hours of 8:00 AM and 5:00 PM, the
                policy string would be (kODPolicyAttributeEnableAtTimeOfDay is
                set to 0800 and  kODPolicyAttributeExpiresAtTimeOfDay is 1700):
                    [NSString stringWithFormat:@"%@ > %@ and %@ < %@",
                              kODPolicyAttributeCurrentTimeOfDay,
                              kODPolicyAttributeEnableAtTimeOfDay,
                              kODPolicyAttributeCurrentTimeOfDay,
                              kODPolicyAttributeExpiresAtTimeOfDay];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeCurrentTimeOfDay __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeCurrentDayOfWeek
    @abstract   Policy attribute for the current day of the week, as a CFNumber.
    @discussion Policy attribute for the current day of the week, as a CFNumber.  
                Specified in units appropriate for the local calendar.  The
                range is 1 through 7, with 1 representing the first day of the
                week in the local calendar, and 7 representing the last day of
                the week.

                This attribute is used in policies to compare the current day of
                the week against another day of the week.  For example, to
                enable authentications on Monday through Friday, the policy
                would be (kODPolicyAttributeEnableOnDayOfWeek is set to the
                number for Monday and kODPolicyAttributeExpiresOnDayOfWeek is
                set to the number for Friday):
                    [NSString stringWithFormat:@"%@ > %@ and %@ < %@",
                              kODPolicyAttributeCurrentDayOfWeek,
                              kODPolicyAttributeEnableOnDayOfWeek,
                              kODPolicyAttributeCurrentDayOfWeek,
                              kODPolicyAttributeExpiresOnDayOfWeek];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeCurrentDayOfWeek __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeFailedAuthentications
    @abstract   Policy attribute for the number of failed authentications.
    @discussion Policy attribute for the number of failed authentications for
                the record.  Used in policies to compare against the maximum
                failed authentications.  The following policy would deny further
                authentications after 3 failed attempts (assumes
                kODPolicyAttributeMaximumFailedAuthentications is 3):
                    [NSString stringWithFormat:@"%@ < %@",
                              kODPolicyAttributeFailedAuthentications,
                              kODPolicyAttributeMaximumFailedAuthentications];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeFailedAuthentications __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeMaximumFailedAuthentications
    @abstract   Policy attribute for the maximum failed authentication attempts.
    @discussion Policy attribute for the maximum failed authentication attempts.  
                Used as a key in policy parameter dictionary to specify the
                maximum allowable failed authentication attempts with a CFNumber
                value.  Also used in the policy string to compare against the
                number of failed authentication attempts.  This policy would
                disallow authentications after 3 failed attempts:
                    @{ kODPolicyKeyIdentifier  : @"maximum failed authentications",
                       kODPolicyKeyParameters  : @{ kODPolicyAttributeMaximumFailedAuthentications : @3 },
                       kODPolicyKeyContent     : [NSString stringWithFormat:@"%@ < %@",
                                                           kODPolicyAttributeFailedAuthentications,
                                                           kODPolicyAttributeMaximumFailedAuthentications] };
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeMaximumFailedAuthentications __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeLastFailedAuthenticationTime
    @abstract   Policy attribute for the time of the last failed auth attempt.
    @discussion Policy attribute for the time of the last failed auth attempt.
                CFNumber with a value representing the the number of seconds
                since the Unix epoch.  Used in policies to compare against other
                times.  As an example, this policy string would prevent another
                authentication within 10 seconds of a failed authentication:  
                    [NSString stringWithFormat:@"%@ > %@ + 10",
                              kODPolicyAttributeCurrentTime,
                              kODPolicyAttributeLastFailedAuthenticationTime];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeLastFailedAuthenticationTime __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeLastAuthenticationTime
    @abstract   Policy attribute for the time of the last successful auth attempt.
    @discussion Policy attribute for the time of the last successful auth attempt.
                CFNumber with a value representing the number of seconds since
                the Unix epoch.  Used in policies to compare against another
                time.  

                The sample policy string below would deny authentications if
                there have been no authentications in the last 90 days.

                Note that the number of days needs to be converted to seconds to
                match the units of kODPolicyAttributeCurrentTime.  The special
                keyword DAYS_TO_SECONDS can be used for the conversion.

                    [NSString stringWithFormat:@"%@ < %@ + 90 * DAYS_TO_SECONDS",
                              kODPolicyAttributeCurrentTime,
                              kODPolicyAttributeLastAuthenticationTime];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeLastAuthenticationTime __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeLastPasswordChangeTime
    @abstract   Policy attribute for time of the last password change.
    @discussion Policy attribute for time of the last password change.  The time
                is specified as the number of seconds since the Unix epoch.
                Used in policies to compare against other times.  Typically
                would be used in Password Change policies to expire a password
                at a certain time or interval.

                The policy string below requires a password change every 90 days
                (kODPolicyAttributeExpiresEveryNDays is set to 90).

                Note that kODPolicyAttributeExpiresEveryNDays needs to be
                converted to seconds to match the units of the other times.  The
                special keyword DAYS_TO_SECONDS can be used for the conversion.

                    [NSString stringWithFormat:@"%@ < %@ + %@ * DAYS_TO_SECONDS",
                              kODPolicyAttributeCurrentTime,
                              kODPolicyAttributeLastPasswordChangeTime,
                              kODPolicyAttributeExpiresEveryNDays];
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeLastPasswordChangeTime __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeNewPasswordRequiredTime
    @abstract   Policy attribute for the time when "new password required" was set.
    @discussion Policy attribute for the time when "new password required" was set.
                The time is specified as the number of seconds since the
                Unix epoch.

                This attribute may be used in the policy string.  Whenever it's
                used in the policy string, it must also be specified in the
                policy's parameter dictionary.

                This attribute is used to capture the time when the system
                administrator wants to force all users to change their
                passwords.  This would be a "one-time" change, i.e. once the
                user changed the password, the policy would apply.  The policy
                would have to be updated with a new time for
                kODPolicyAttributeNewPasswordRequiredTime in order to force a
                new round of password changes.

                For example:
                    @{ kODPolicyKeyIdentifier : @"change on next auth",
                       kODPolicyKeyParameters : @{ kODPolicyAttributeNewPasswordRequiredTime : @(<time>) },
                       kODPolicyKeyContent    : [NSString stringWithFormat:@"%@ < %@",
                                                          kODPolicyAttributeLastPasswordChangeTime,
                                                          kODPolicyAttributeNewPasswordRequiredTime]};
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeNewPasswordRequiredTime __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeCreationTime
    @abstract   Policy attribute for the record creation time.
    @discussion Policy attribute for the record creation time.  The time is
                specified as the number of seconds since the "reference date".
                Could be used to disable "temporary" accounts after a specific
                period of time.  

                The example below disables authentications after 10
                days after the account was created.

                Note that kODPolicyAttributeDaysUntilExpiration must be
                converted to seconds to match the units of the other times.  The
                special keyword DAYS_TO_SECONDS can be used for the conversion.

                    @{ kODPolicyKeyIdentifier : @"expires after 10 days",
                       kODPolicyKeyParameters : @{kODPolicyAttributeDaysUntilExpiration : @10 },
                       kODPolicyKeyContent    : [NSString stringWithFormat:@"%@ < %@ + (%@ * DAYS_TO_SECONDS)",
                                                          kODPolicyAttributeCurrentTime,
                                                          kODPolicyAttributeCreationTime,
                                                          kODPolicyAttributeDaysUntilExpiration]};
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeCreationTime __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeExpiresEveryNDays
    @abstract   Policy attribute for expires every N days.
    @discussion Policy attribute for expires every N days.  This attribute is
                used as a key in the policy parameter dictionary, with CFNumber
                value.  Also used in the policy strings. Typically would be used
                in Password Change policies to expire a password at a certain
                time or interval. 

                The example policy below would require a password change every
                90 days.

                Note that kODPolicyAttributeExpiresEveryNDays needs to be
                converted to seconds to match the units of the other times used
                in the policy.  The special keyword DAYS_TO_SECONDS can be used
                for the conversion.

                    @{ kODPolicyKeyIdentifier : @"expires every 90 days",
                       kODPolicyKeyParameters : @{ kODPolicyAttributeExpiresEveryNDays : @90 },
                       kODPolicyKeyContent    : [NSString stringWithFormat:@"%@ < %@ + %@ * DAYS_TO_SECONDS",
                                                          kODPolicyAttributeCurrentTime,
                                                          kODPolicyAttributeLastPasswordChangeTime,
                                                          kODPolicyAttributeExpiresEveryNDays]};
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeExpiresEveryNDays __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeEnableOnDate
    @abstract   Policy attribute for the "enable on" date.
    @discussion Policy attribute for the "enable on" date.  Used as a key in the
                policy parameter dictionary, with a CFDate value.   Also used in
                policy strings. The date is specified as a CFDate representing a
                fixed date, appropriate for the locale.  Use in policies when
                comparing other date-based attributes.

                This attribute is typically used Authentication policies to
                control when authentications are allowed. This policy would
                enable authentications on Jan 1, 2014 (assumes the date
                formatter is properly configured for the locale): 
                    @{ kODPolicyKeyIdentifier : @"enable on Jan 1",
                       kODPolicyKeyParameters : @{ kODPolicyAttributeEnableOnDate : [localFormatter dateWithString:@"01/01/2014"] },
                       kODPolicyKeyContent    : [NSString stringWithFormat:@"%@ >= %@",
                                                          kODPolicyAttributeCurrentDate,
                                                          kODPolicyAttributeEnableOnDate]};
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeEnableOnDate __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeExpiresOnDate
    @abstract   Policy attribute for the "expires on" date.
    @discussion Policy attribute for the "expires on" date.  Used as a key in the
                policy parameter dictionary, with a CFDate value.   Also used in
                policy strings. The date is specified as a CFDate representing a
                fixed date, appropriate for the locale.  Use in policies when
                comparing other date-based attributes.

                This attribute is typically used in Authentication policies to
                control when authentications are allowed. This policy would
                disallow authentications on Jan 1, 2014 (assumes the date
                formatter is properly configured for the locale): 
                    @{ kODPolicyKeyIdentifier : @"expires on Jan 1",
                       kODPolicyKeyParameters : @{ kODPolicyAttributeExpiresOnDate : [localFormatter dateWithString:@"01/01/2014"] },
                       kODPolicyKeyContent    : [NSString stringWithFormat:@"%@ < %@",
                                                          kODPolicyAttributeCurrentDate,
                                                          kODPolicyAttributeExpiresOnDate]};
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeExpiresOnDate __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeEnableOnDayOfWeek
    @abstract   Policy attribute for enable on a day of the week.
    @discussion Policy attribute for enable on a day of the week.  Specified as a
                in units appropriate for the local calendar.  The range is 1
                through 7, with 1 representing the first day of the week in the
                local calendar, and 7 representing the last day of the week. 

                This attribute is used as a key in the policy parameter
                dictionary, with a CFNumber value, and in policy strings.
                Typically used i policy strings to compare against the another
                day of the week.  For example, to allow authentications only on
                Monday through Friday, the policy would be (assumes Monday = 2
                and Friday = 6 in the local calendar): 
                    @{ kODPolicyKeyIdentifier : @"mon-fri only",
                       kODPolicyKeyParameters : @{ kODPolicyAttributeEnableOnDayOfWeek : @2,
                                                   kODPolicyAttributeExpiresOnDayOfWeek : @6 },
                       kOPolicyKeyPolicy      : [NSString stringWithFormat:@"%@ > %@ and %@ < %@",
                                                          kODPolicyAttributeCurrentDayOfWeek,
                                                          kODPolicyAttributeEnableOnDayOfWeek,
                                                          kODPolicyAttributeCurrentDayOfWeek,
                                                          kODPolicyAttributeExpiresOnDayOfWeek]};
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeEnableOnDayOfWeek __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeExpiresOnDayOfWeek
    @abstract   Policy attribute for expires on a day of the week.
    @discussion Policy attribute for expires on a day of the week.  Specified as a
                in units appropriate for the local calendar.  The range is 1
                through 7, with 1 representing the first day of the week in the
                local calendar, and 7 representing the last day of the week. 

                This attribute is used as a key in the policy parameter
                dictionary, with a CFNumber value, and in policy strings.
                Typically used i policy strings to compare against the another
                day of the week.  See the example above for kODPolicyAttributeEnableOnDayOfWeek.
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeExpiresOnDayOfWeek __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeEnableAtTimeOfDay
    @abstract   Policy attribute for enable at a specific time of day.
    @discussion Policy attribute for enable at a specific time of day.
                The time is specified in 24-hour time, with a range of 0000
                through 2359.  This attribute can be used as a key in the policy
                parameter dictionary, with a CFNumber value, and in the policy
                strings. 

                Typically used in authentication policies to control specific
                times of when when authentications are allowed.  For example, to
                enable authentications between the hours of 8:00 AM and 5:00 PM,
                the policy would be: 
                    @{ kODPolicyKeyIdentifier : @"school hours",
                       kODPolicyKeyParameters : @{ kODPolicyAttributeEnableAtTimeOfDay  : @800,
                                                   kODPolicyAttributeExpiresAtTimeOfDay : @1700 },
                       kODPolicyKeyContent    : [NSString stringWithFormat:@"%@ > %@ and %@ < %@",
                                                          kODPolicyAttributeCurrentTimeOfDay,
                                                          kODPolicyAttributeEnableAtTimeOfDay,
                                                          kODPolicyAttributeCurrentTimeOfDay,
                                                          kODPolicyAttributeExpiresAtTimeOfDay]};
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeEnableAtTimeOfDay __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @const      kODPolicyAttributeExpiresAtTimeOfDay
    @abstract   Policy attribute for expires at a specific time of day.
    @discussion Policy attribute for expires at a specific time of day.
                The time is specified in 24-hour time, with a range of 0000
                through 2359.  This attribute can be used as a key in the policy
                parameter dictionary, with a CFNumber value, and in the policy
                strings. 

                Typically used in authentication policies to control specific
                times of when when authentications are allowed.  See the example
                above for kODPolicyAttributeEnableAtTimeOfDay.
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeExpiresAtTimeOfDay __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);


/*!
    @const      kODPolicyAttributeDaysUntilExpiration
    @abstract   Policy attribute for the number of days until expiration.
    @discussion Policy attribute for the number of days until expiration.
                This attribute can be used as a key in the policy parameter
                dictionary with a CFNumber value representing some number of
                days.  It can also be used in the policy strings. 

                May be used in Authentication policies to expire authentications
                after some number of days or in Password Change policies to
                expire passwords.

                The example below disables authentications after 10
                days after the account was created.

                Note that kODPolicyAttributeDaysUntilExpiration must be
                converted to seconds to match the units of the other times.  The
                special keyword DAYS_TO_SECONDS can be used for the conversion.

                    @{ kODPolicyKeyIdentifier : @"expires after 10 days",
                       kODPolicyKeyParameters : @{kODPolicyAttributeDaysUntilExpiration : @10 },
                       kODPolicyKeyContent    : [NSString stringWithFormat:@"%@ < %@ + (%@ * DAYS_TO_SECONDS)",
                                                          kODPolicyAttributeCurrentTime,
                                                          kODPolicyAttributeCreationTime,
                                                          kODPolicyAttributeDaysUntilExpiration]};
*/
CF_EXPORT
ODPolicyAttributeType kODPolicyAttributeDaysUntilExpiration __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);


#pragma mark Errors

/*!
 @enum   	ODFrameworkErrors
 @abstract   Errors specific to the framework and to underlying calls
 @discussion Errors specific to the framework and to underlying calls
 @constant kODErrorSuccess is when operation was successful (if appropriate)
 @constant kODErrorSessionLocalOnlyDaemonInUse is when a Local Only session was initiated and is still active
 @constant kODErrorSessionNormalDaemonInUse is when the Normal daemon is still in use but request was issued for Local only
 @constant kODErrorSessionDaemonNotRunning is when the daemon is not running
 @constant kODErrorSessionDaemonRefused is when the daemon refused the session
 @constant kODErrorSessionProxyCommunicationError is when there was a communication error with the remote daemon
 @constant kODErrorSessionProxyVersionMismatch is when versions mismatch between the remote daemon and local framework
 @constant kODErrorSessionProxyIPUnreachable is when the provided kODSessionProxyAddress did not respond
 @constant kODErrorSessionProxyUnknownHost is when the provided kODSessionProxyAddress cannot be resolved
 @constant kODErrorNodeUnknownName is when the node name provided does not exist and cannot be opened
 @constant kODErrorNodeUnknownType is when the node type provided is not a known value
 @constant kODErrorNodeConnectionFailed is when a node connection failed (commonly server closed connection, etc.)
 @constant kODErrorNodeUnknownHost is when an invalid host is provided
 @constant kODErrorQuerySynchronize is an error code that is returned when a synchronize has been initiated
 @constant kODErrorQueryInvalidMatchType is when an invalid match type is provided in a query
 @constant kODErrorQueryUnsupportedMatchType is when plugin does not support the requirested match type
 @constant kODErrorQueryTimeout is when a query timed out during request
 @constant kODErrorRecordReadOnlyNode is when a record cannot be modified
 @constant kODErrorRecordPermissionError is when the changes requested were denied due to insufficient permissions
 @constant kODErrorRecordParameterError is when an invalid parameter was provided
 @constant kODErrorRecordInvalidType is when an invalid record type was provided
 @constant kODErrorRecordAlreadyExists is when a record create failed because the record already exists
 @constant kODErrorRecordTypeDisabled is when a particular record type is disabled by policy for a plugin
 @constant kODErrorRecordAttributeUnknownType is when an unknown attribute type is provided
 @constant kODErrorRecordAttributeNotFound is when an attribute requested is not found in the record
 @constant kODErrorRecordAttributeValueSchemaError is when an attribute value does not meet schema requirements
 @constant kODErrorRecordAttributeValueNotFound is when an attribute value is not found in a record
 @constant kODErrorCredentialsInvalid is when credentials provided are invalid with the current node
 @constant kODErrorCredentialsMethodNotSupported is when a particular extended method is not supported by the node
 @constant kODErrorCredentialsNotAuthorized is when an operation such as changing a password is not authorized with current privileges
 @constant kODErrorCredentialsParameterError is when a parameter provided is invalid
 @constant kODErrorCredentialsOperationFailed is when the requested operation failed (usually due to some unrecoverable error)
 @constant kODErrorCredentialsServerUnreachable is when the authententication server is not reachabable
 @constant kODErrorCredentialsServerNotFound is when the authentication server could not be found for the operation requested
 @constant kODErrorCredentialsServerError is when the authentication server encountered an error
 @constant kODErrorCredentialsServerTimeout is when the authentication server timed out
 @constant kODErrorCredentialsContactMaster is when the authentication server is not the master and the operation requires the master
 @constant kODErrorCredentialsServerCommunicationError is when the authentication server had a communications error
 @constant kODErrorCredentialsAccountNotFound is when the authentication server could not find the account provided
 @constant kODErrorCredentialsAccountDisabled is when the account is disabled
 @constant kODErrorCredentialsAccountExpired is when the account is expired
 @constant kODErrorCredentialsAccountInactive is when the account is inactive
 @constant kODErrorCredentialsPasswordExpired is when the password has expired and must be changed
 @constant kODErrorCredentialsPasswordChangeRequired is when a password change is required
 @constant kODErrorCredentialsPasswordQualityFailed is when a password provided for change did not meet quality minimum requirements
 @constant kODErrorCredentialsPasswordTooShort is when a password provided is too short
 @constant kODErrorCredentialsPasswordTooLong is when a password provided is too long
 @constant kODErrorCredentialsPasswordNeedsLetter is when a password needs a letter
 @constant kODErrorCredentialsPasswordNeedsDigit is when a password needs a digit
 @constant kODErrorCredentialsPasswordChangeTooSoon is when a an attempt to change a password too soon before last change
 @constant kODErrorCredentialsPasswordUnrecoverable is when password was not recoverable from the authentication database
 @constant kODErrorCredentialsInvalidLogonHours is when an account attempts to login outside of set logon hours
 @constant kODErrorCredentialsInvalidComputer is when an account attempts to login to a computer they are not authorized
 @constant kODErrorPolicyUnsupported all requested policies were not supported
 @constant kODErrorPolicyOutOfRange policy value was beyond the allowed range
 @constant kODErrorPluginOperationNotSupported is when a plugin does not support the requested operation
 @constant kODErrorPluginError is when a plugin has encountered some undefined error
 @constant kODErrorDaemonError is when some error occurred inside the daemon
 @constant kODErrorPluginOperationTimeout is when an operation exceeds an imposed timeout
*/

enum ODFrameworkErrors
{
    kODErrorSuccess                             = 0,
    
	/* ODSession error codes */
	kODErrorSessionLocalOnlyDaemonInUse			=	1000,
	kODErrorSessionNormalDaemonInUse			=	1001,
	kODErrorSessionDaemonNotRunning				=	1002,
	kODErrorSessionDaemonRefused				=	1003,

	kODErrorSessionProxyCommunicationError		=	1100,
	kODErrorSessionProxyVersionMismatch			=	1101,
	kODErrorSessionProxyIPUnreachable			=	1102,
	kODErrorSessionProxyUnknownHost				=	1103,
	
	/* ODNode error codes */
	kODErrorNodeUnknownName						=	2000,
	kODErrorNodeUnknownType						=	2001,
	kODErrorNodeDisabled						=	2002,

	kODErrorNodeConnectionFailed				=	2100,
	
	/* ODNode miscellaneous error codes */
	kODErrorNodeUnknownHost						=	2200,
	
	/* ODQuery error codes */
	kODErrorQuerySynchronize					=	3000,
	
	kODErrorQueryInvalidMatchType				=	3100,
	kODErrorQueryUnsupportedMatchType			=	3101,
	kODErrorQueryTimeout						=	3102,
	
	/* ODRecord error codes */
	kODErrorRecordReadOnlyNode					=	4000,
	kODErrorRecordPermissionError				=	4001,
	
	kODErrorRecordParameterError				=	4100,
	kODErrorRecordInvalidType					=	4101,
	kODErrorRecordAlreadyExists					=	4102,
	kODErrorRecordTypeDisabled					=	4103,
	kODErrorRecordNoLongerExists				=	4104,
	
	kODErrorRecordAttributeUnknownType			=	4200,
	kODErrorRecordAttributeNotFound				=	4201,
	kODErrorRecordAttributeValueSchemaError		=	4202,
	kODErrorRecordAttributeValueNotFound		=   4203,
	
	/* Credential specific error codes */
	kODErrorCredentialsInvalid					=	5000,
	
	kODErrorCredentialsMethodNotSupported		=	5100,
	kODErrorCredentialsNotAuthorized			=	5101,
	kODErrorCredentialsParameterError			=	5102,
	kODErrorCredentialsOperationFailed			=	5103,
	
	kODErrorCredentialsServerUnreachable		=	5200,
	kODErrorCredentialsServerNotFound			=	5201,
	kODErrorCredentialsServerError				=	5202,
	kODErrorCredentialsServerTimeout			=	5203,
	kODErrorCredentialsContactMaster			=	5204,
	kODErrorCredentialsServerCommunicationError	=	5205,
	
	kODErrorCredentialsAccountNotFound			=	5300,
	kODErrorCredentialsAccountDisabled			=	5301,
	kODErrorCredentialsAccountExpired			=	5302,
	kODErrorCredentialsAccountInactive			=	5303,
	
	kODErrorCredentialsPasswordExpired			=	5400,
	kODErrorCredentialsPasswordChangeRequired	=	5401,
	kODErrorCredentialsPasswordQualityFailed	=	5402,
	kODErrorCredentialsPasswordTooShort			=	5403,
	kODErrorCredentialsPasswordTooLong			=	5404,
	kODErrorCredentialsPasswordNeedsLetter		=	5405,
	kODErrorCredentialsPasswordNeedsDigit		=	5406,
	kODErrorCredentialsPasswordChangeTooSoon	=	5407,
	kODErrorCredentialsPasswordUnrecoverable	=	5408,

	kODErrorCredentialsInvalidLogonHours		= 	5500,
	kODErrorCredentialsInvalidComputer			= 	5501,
    
    /* Policy errors */
    kODErrorPolicyUnsupported                   =   6000,
    kODErrorPolicyOutOfRange                    =   6001,

	/* Underlying plugin errors */
	kODErrorPluginOperationNotSupported			=	10000,
	kODErrorPluginError							=	10001,
	kODErrorDaemonError							=	10002,
    kODErrorPluginOperationTimeout              =   10003,
};

#endif
                                                                                                                                   Current                                                                                             0120777 0001750 0001750 00000000000 12620245063 043421  2A                                                                                                   ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks/CFOpenDirectory.framework/Versions                         Headers/                                                                                            0040755 0001750 0001750 00000000000 12612224743 032410  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A                                                                       NSOpenDirectory.h                                                                                   0100644 0001750 0001750 00000001762 12566202403 035610  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Headers                                                               /*
 * Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#import <OpenDirectory/OpenDirectory.h>
              ODAttributeMap.h                                                                                    0100644 0001750 0001750 00000006257 12566202403 035411  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Headers                                                               /*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#import <Foundation/Foundation.h>

NS_CLASS_AVAILABLE(10_9, NA)
@interface ODAttributeMap : NSObject {
	@protected
	NSString *customQueryFunction;
	NSString *customTranslationFunction;
	NSArray *customAttributes;
	NSString *value;
}

/*
 * Custom functions are in the format of: 
 *		"<module>:<function>"
 *
 * Example: "ldap:query_attribute"
 */

/* Custom function to be used when querying the attribute */
@property(copy) NSString *customQueryFunction NS_AVAILABLE_MAC(10_9);

/* Custom function to be used when translating the result for the client */
@property(copy) NSString *customTranslationFunction NS_AVAILABLE_MAC(10_9);

/* Attributes required for the custom functions */
@property(copy) NSArray *customAttributes NS_AVAILABLE_MAC(10_9);

/* The value used for the mapping.  Static, variable substitution and native are all represented */
@property(copy) NSString *value NS_AVAILABLE_MAC(10_9);

/*!
 * @method attributeMapWithValue:
 *
 * @abstract
 * Returns an initialized and autoreleased ODAttributeMap object with the given value mapped.
 *
 * @discussion
 * Returns an initialized and autoreleased ODAttributeMap object with the given value mapped.
 */
+ (instancetype)attributeMapWithValue:(NSString *)value;

/*!
 * @method attributeMapWithStaticValue:
 *
 * @abstract
 * Returns an initialized and autoreleased ODAttributeMap object with the given static value.
 *
 * @discussion
 * Returns an initialized and autoreleased ODAttributeMap object with the given static value.
 */
+ (instancetype)attributeMapWithStaticValue:(NSString *)staticValue;

/*!
 * @method setStaticValue:
 *
 * @abstract
 * Sets a static value that will always be returned for this mapping.
 *
 * @discussion
 * Sets a static value that will always be returned for this mapping, i.e., "20".
 */
- (void)setStaticValue:(NSString *)staticValue NS_AVAILABLE_MAC(10_9);

/*!
 * @method setVariableSubstitution:
 *
 * @abstract
 * Sets a variable substitution-based value.
 *
 * @discussion
 * Value should be using the syntax '$native$' for all substited values.  For example,
 * to form a home directory using the "cn" of an LDAP record, substitution could be done
 * with "/home/$cn$".
 */
- (void)setVariableSubstitution:(NSString *)variableSubstitution NS_AVAILABLE_MAC(10_9);

@end
                                                                                                                                                                                                                                                                                                                                                 ODConfiguration.h                                                                                   0100644 0001750 0001750 00000022620 12566202403 035607  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Headers                                                               /*
 * Copyright (c) 2009-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#import <Foundation/Foundation.h>
#import <OpenDirectory/OpenDirectory.h>

enum {
    ODPacketSigningDisabled = 0,
    ODPacketSigningAllow = 1,
    ODPacketSigningRequired = 2,
};

enum {
    ODPacketEncryptionDisabled = 0,
    ODPacketEncryptionAllow = 1,
    ODPacketEncryptionRequired = 2,
    ODPacketEncryptionSSL = 3,
};

@class SFAuthorization;
@class ODMappings;

/* Signifies that the configuration is "joined" to the directory (a.k.a., Authenticated binding) with it's own dedicated account (often a computer account) */
FOUNDATION_EXPORT NSString *const ODTrustTypeJoined NS_AVAILABLE_MAC(10_9);

/* Signfies that some form of credentials is being used to talk to this directory node */
FOUNDATION_EXPORT NSString *const ODTrustTypeUsingCredentials NS_AVAILABLE_MAC(10_9);

/* Signifies there is no account associated with this configuration */
FOUNDATION_EXPORT NSString *const ODTrustTypeAnonymous NS_AVAILABLE_MAC(10_9);

NS_CLASS_AVAILABLE(10_9, NA)
@interface ODConfiguration : NSObject {
	@protected
	ODSession *session;
	NSString *nodeName;
	NSString *comment;
	NSArray *defaultModuleEntries;
	NSArray *authenticationModuleEntries;
	NSArray *discoveryModuleEntries;
	NSArray *generalModuleEntries;
	ODMappings *defaultMappings;
	NSString *templateName;
	NSArray *virtualSubnodes;
	BOOL hideRegistration;
	NSString *preferredDestinationHostName;
	uint16_t preferredDestinationHostPort;
	NSString *trustAccount;
	NSString *trustType;
	NSString *trustKerberosPrincipal;
	NSString *trustMetaAccount;
	BOOL trustUsesMutualAuthentication;
	BOOL trustUsesKerberosKeytab;
	BOOL trustUsesSystemKeychain;
	NSInteger packetSigning;
	NSInteger packetEncryption;
	BOOL manInTheMiddleProtection;
	NSInteger queryTimeoutInSeconds;
	NSInteger connectionSetupTimeoutInSeconds;
	NSInteger connectionIdleTimeoutInSeconds;
}

/* the nodename associated with this configuration */
@property(copy) NSString *nodeName NS_AVAILABLE_MAC(10_9);

/* comment for this configuration */
@property(copy) NSString *comment NS_AVAILABLE_MAC(10_9);

/* default mappings for this configuration (used for all modules unless specific ones are set for the module) */
@property(strong) ODMappings *defaultMappings NS_AVAILABLE_MAC(10_9);

/*
 * Name of the template used for this configuration, specifically loaded from /System/Library/OpenDirectory/Templates or /Library/OpenDirectory/Templates.  These templates
 * specify the module layout, settings, etc. appropriate for that template.   Any settings in this configuration will override settings from the template
 */
@property(copy) NSString *templateName NS_AVAILABLE_MAC(10_9);

/*
 * A list of subnodenames to be registered on behalf of this configuration.  For example, "subnode1" would register "/Nodename/subnode1" automatically so it is visible
 * without loading the actual configuration/modules.
 */
@property(copy) NSArray *virtualSubnodes NS_AVAILABLE_MAC(10_9);

/* Hides the registration of this node so it is not visible to clients in the UI. */
@property(assign) BOOL hideRegistration NS_AVAILABLE_MAC(10_9);

/* The optional hostname to be used with this configuration */
@property(copy) NSString *preferredDestinationHostName NS_AVAILABLE_MAC(10_9);

/* An optional port to be used in conjunction with the preferred hostname for this configuration */
@property(assign) uint16_t preferredDestinationHostPort NS_AVAILABLE_MAC(10_9);

/* The current trust account used with this configuration */
@property(readonly, copy) NSString *trustAccount NS_AVAILABLE_MAC(10_9);

/* The current trust meta account used with this configuration */
@property(readonly, copy) NSString *trustMetaAccount NS_AVAILABLE_MAC(10_9);

/* The current trust kerberos account used with this configuration */
@property(readonly, copy) NSString *trustKerberosPrincipal NS_AVAILABLE_MAC(10_9);

/* Type of trust established for this configuration */
@property(readonly, copy) NSString *trustType NS_AVAILABLE_MAC(10_9);

/* Trust uses mutual authentication for security */
@property(readonly) BOOL trustUsesMutualAuthentication NS_AVAILABLE_MAC(10_9);

/* Trust uses keytab for password storage */
@property(readonly) BOOL trustUsesKerberosKeytab NS_AVAILABLE_MAC(10_9);

/* Trust uses the system keychain to store password */
@property(readonly) BOOL trustUsesSystemKeychain NS_AVAILABLE_MAC(10_9);

/* Determines if packet signing is used for this configuration, should be one of the ODPacketSigning values */
@property(assign) NSInteger packetSigning NS_AVAILABLE_MAC(10_9);

/* Determins if packet encryption is used for this configuration, should be one of the ODPacketEncryption values */
@property(assign) NSInteger packetEncryption NS_AVAILABLE_MAC(10_9);

/* States if some man-in-the-middle protection is required */
@property(assign) BOOL manInTheMiddleProtection NS_AVAILABLE_MAC(10_9);

/* Timeout in seconds for all queries issued for this configuration */
@property(assign) NSInteger queryTimeoutInSeconds NS_AVAILABLE_MAC(10_9);

/* Timeout in seconds for connection setup for this configuration */
@property(assign) NSInteger connectionSetupTimeoutInSeconds NS_AVAILABLE_MAC(10_9);

/* Default timeout in seconds for all connections associated with this configuration */
@property(assign) NSInteger connectionIdleTimeoutInSeconds NS_AVAILABLE_MAC(10_9);

/* A list of default ODModuleEntry objects.  Default modules are used in all categories, after all "specific" modules */
@property(copy) NSArray *defaultModuleEntries NS_AVAILABLE_MAC(10_9);

/* A list of authentication ODModuleEntry objects */
@property(copy) NSArray *authenticationModuleEntries NS_AVAILABLE_MAC(10_9);

/* A list of discovery ODModuleEntry objects */
@property(copy) NSArray *discoveryModuleEntries NS_AVAILABLE_MAC(10_9);

/* A list of general ODModuleEntry objects used for all other APIs (Queries, modifications, etc.) */
@property(copy) NSArray *generalModuleEntries NS_AVAILABLE_MAC(10_9);

/*!
 * @method configuration
 *
 * @abstract
 * Returns an initialized and autoreleased ODConfiguration object.
 *
 * @discussion
 * Returns an initialized and autoreleased ODConfiguration object.
 */
+ (instancetype)configuration;

/*!
 * @method suggestedTrustAccount:
 *
 * @abstract
 * Returns a suggested name to use for the trust account.
 *
 * @discussion
 * Returns a suggested name to use for a trust account.  This name will be derived from the hostname
 * (if provided), otherwise it will be derived from the local hostname removing special characters
 * that may not be allowed by many systems.
 */
+ (NSString *) suggestedTrustAccount:(NSString *)hostname NS_AVAILABLE_MAC(10_9);

/*!
 * @method suggestedTrustPassword:
 *
 * @abstract
 * Returns a suggested password to be used for trust account with the requested length.
 *
 * @discussion
 * Returns a suggested password to be used for trust account with the requested length.
 */
+ (NSString *) suggestedTrustPassword:(size_t)length NS_AVAILABLE_MAC(10_9);

/*!
 * @method saveUsingAuthorization:error:
 *
 * @abstract
 * Saves the configuration using the provided authorization.
 *
 * @discussion
 * Saves the configuration using the provided authorization.
 */
- (BOOL) saveUsingAuthorization:(SFAuthorization *)authorization error:(NSError **)error NS_AVAILABLE_MAC(10_9);

/*!
 * @method addTrustType:trustAccount:trustPassword:username:password:joinExisting:error:
 *
 * @abstract
 * Adds a trust account with the provided name and password using the credentials provided by the user.
 *
 * @discussion
 * Adds a trust account with the provided name and password using the credentials provided by the user.  User can
 * request that the trust be forcibly created (replacing existing trust if found in directory).  A trust should be
 * established only after enough configuration is available and the configuration been saved.  If the trust is
 * required, then the configuration can be deleted if necessary upon failure.
 */
- (BOOL) addTrustType:(NSString *)trustType trustAccount:(NSString *)account trustPassword:(NSString *)accountPassword username:(NSString *)username password:(NSString *)password joinExisting:(BOOL)join error:(NSError **)error NS_AVAILABLE_MAC(10_9);

/*!
 * @method removeTrustUsingUsername:password:deleteTrustAccount:error:
 *
 * @abstract
 * Removes trust using the provided username and password.
 *
 * @discussion
 * Removes trust using the provided username and password.  The trust account will be removed from the directory only if requested.
 */
- (BOOL) removeTrustUsingUsername:(NSString *)username password:(NSString *)password deleteTrustAccount:(BOOL)deleteAccount error:(NSError **)error NS_AVAILABLE_MAC(10_9);

@end
                                                                                                                ODMappings.h                                                                                        0100644 0001750 0001750 00000005705 12566202403 034563  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Headers                                                               /*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#import <Foundation/Foundation.h>

@class ODRecordMap;

NS_CLASS_AVAILABLE(10_9, NA)
@interface ODMappings : NSObject {
	@protected
	NSString *comment;
	NSString *templateName;
	NSString *identifier;
	NSString *function;
	NSArray *functionAttributes;
	NSMutableDictionary *recordTypes;
}

/* Short comment about the mappings */
@property(copy) NSString *comment NS_AVAILABLE_MAC(10_9);

/*
 * Name of the mappings template to be used for this configuration from /System/Library/OpenDirectory/Mappings or /Library/OpenDirectory/Mappings
 * if a template is used, then no other values should be set, template is an exclusive setting
 */
@property(copy) NSString *templateName NS_AVAILABLE_MAC(10_9);

/* RFC1034 identifier for this mapping, com.company.mapping */
@property(copy) NSString *identifier NS_AVAILABLE_MAC(10_9);

/* Returns a list of NSString values for all attributes currently configured */
@property(readonly, copy) NSArray *recordTypes NS_AVAILABLE_MAC(10_9);

/* function to translate record types */
@property(copy) NSString *function NS_AVAILABLE_MAC(10_9);

/* native attributes required for translation function to work */
@property(copy) NSArray *functionAttributes NS_AVAILABLE_MAC(10_9);

/*!
 * @method mappings
 *
 * @abstract
 * Returns an initialized and autoreleased ODMappings object.
 *
 * @discussion
 * Returns an initialized and autoreleased ODMappings object.
 */
+ (instancetype)mappings;

/*!
 * @method recordType:
 *
 * @abstract
 * Returns an ODRecordMap associated with the provided recordtype.
 *
 * @discussion
 * Returns an ODRecordMap associated with the provided recordtype.
 */
- (ODRecordMap *) recordMapForStandardRecordType:(NSString *)stdType NS_AVAILABLE_MAC(10_9);

/*!
 * @method setRecordMap:forRecordType:
 *
 * @abstract
 * Sets a particular ODRecordMap for a given standard record type.
 *
 * @discussion
 * Sets a particular ODRecordMap for a given standard record type.
 */
- (void) setRecordMap:(ODRecordMap *)map forStandardRecordType:(NSString *)stdType NS_AVAILABLE_MAC(10_9);

@end
                                                           ODModuleEntry.h                                                                                     0100644 0001750 0001750 00000005436 12566202403 035255  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Headers                                                               /*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#import <Foundation/Foundation.h>

@class ODMappings;

NS_CLASS_AVAILABLE(10_9, NA)
@interface ODModuleEntry : NSObject {
	@protected
	ODMappings *mappings;
	NSArray *supportedOptions;
	NSString *name;
	NSString *xpcServiceName;
	NSMutableDictionary *options;
	NSString *uuidString;
};

/* mappings that are specific to this module configuration */
@property(strong) ODMappings *mappings NS_AVAILABLE_MAC(10_9);

/* A list supported options for a module.  The list will contain dictionaries with keys ODModuleOptionName, ODModuleOptionType, etc. */
@property(readonly, copy) NSArray *supportedOptions NS_AVAILABLE_MAC(10_9);

/* Name of the module, used in logging, etc. */
@property(copy) NSString *name NS_AVAILABLE_MAC(10_9);

/* XPCService to be used for this module */
@property(copy) NSString *xpcServiceName NS_AVAILABLE_MAC(10_9);

/* A UUID in string form that uniquely identifies this configuration, will be assigned automatically if missing */
@property(copy) NSString *uuidString NS_AVAILABLE_MAC(10_9);

/*!
 * @method moduleEntryWithName:xpcServiceName:
 *
 * @abstract
 * Creates a new module entry with a given name and service.
 *
 * @discussion
 * Creates a new module entry with a given name and service.
 */
+ (instancetype)moduleEntryWithName:(NSString *)name xpcServiceName:(NSString *)xpcServiceName NS_AVAILABLE_MAC(10_9);

/*!
 * @method setOption:value:
 *
 * @abstract
 * Assigns a particular option for this module.
 *
 * @discussion
 * Options are dictated by the module and can be queried via [module supportedOptions].
 */
- (void) setOption:(NSString *)optionName value:(id)value NS_AVAILABLE_MAC(10_9);

/*!
 * @method option:
 *
 * @abstract
 * Fetches the current setting for the requested option.
 *
 * @discussion
 * Fetches the current setting for the requested option.
 */
- (id) option:(NSString *)optionName NS_AVAILABLE_MAC(10_9);

@end
                                                                                                                                                                                                                                  ODNode.h                                                                                            0100644 0001750 0001750 00000044064 12566202403 033673  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Headers                                                               /*
 * Copyright (c) 2005-2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#import <OpenDirectory/OpenDirectory.h>

@class ODConfiguration;
@class ODRecord;

/*!
    @class       ODNode
    @abstract    This class is used to work with OpenDirectory nodes.
    @discussion  OpenDirectory uses nodes to represent different sources of directory information, via the local disk, LDAP, etc.
*/
@interface ODNode : NSObject {
	@private
	void *_internal;
}

/*!
    @method     nodeWithSession:type:error:
    @abstract   Create an autoreleased ODNode of the given type, optionally in a specific session.
    @discussion Autoreleased instance of an ODNode with a provided ODSession and ODNodeType.  outError is 
                optional parameter, nil can be passed if error details are not needed.
*/
+ (instancetype)nodeWithSession:(ODSession *)inSession type:(ODNodeType)inType error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     nodeWithSession:name:error:
    @abstract   Create an autoreleased ODNode with the given name, optionally in a specific session.
    @discussion autoreleased instance of an ODNode with a provided ODSession and node name.  outError is 
                optional parameter, nil can be passed if error details are not needed.
*/
+ (instancetype)nodeWithSession:(ODSession *)inSession name:(NSString *)inName error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     initWithSession:type:error:
    @abstract   Initialize an ODNode instance of the given type, optionally in a specific session.
    @discussion initialize instance of an ODNode with a provided ODSession and ODNodeType.  outError is 
                optional parameter, nil can be passed if error details are not needed.
*/
- (instancetype)initWithSession:(ODSession *)inSession type:(ODNodeType)inType error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     initWithSession:name:error:
    @abstract   Initialize an ODNode instance with the given name, optionally in a specific session.
    @discussion initialize instance of an ODNode with a provided ODSession and node name.  outError is optional
                parameter, nil can be passed if error details are not needed.
*/
- (instancetype)initWithSession:(ODSession *)inSession name:(NSString *)inName error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     subnodeNamesAndReturnError:
    @abstract   Returns NSArray of node names for this node, which may contain sub-nodes or search policy nodes
    @discussion Returns NSArray of node names for this node, which may contain sub-nodes or search policy nodes.
                Commonly used with Search policy nodes.  outError is optional parameter, nil can be passed if error
                details are not needed.
*/
- (NSArray *)subnodeNamesAndReturnError:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     unreachableSubnodeNamesAndReturnError:
    @abstract   Will return NSArray of names of subnodes that are not currently reachable.
    @discussion Will return NSArray of names of subnodes that are not currently reachable.  Commonly used with Search policy 
                nodes to determine if any nodes are currently unreachable, but may also return other subnodes if the
                OpenDirectory plugin supports.  outError is optional parameter, nil can be passed if error details are not needed.
*/
- (NSArray *)unreachableSubnodeNamesAndReturnError:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @property   nodeName
    @abstract   The node name.
    @discussion The node name, corresponding to its path in OpenDirectory.
*/
@property (nonatomic, readonly, copy) NSString *nodeName NS_AVAILABLE(10_6, NA);

/*!
    @method     nodeDetails:error:
    @abstract   Returns a dictionary of information about the instance of ODNode
    @discussion Returns a dictionary of information about the instance of ODNode.  Details such as Trust information
                (kODAttributeTypeTrustInformation) or other Node details can be retrieved.  outError is optional parameter,
                nil can be passed if error details are not needed.
                
*/
- (NSDictionary *)nodeDetailsForKeys:(NSArray *)inKeys error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     supportedRecordTypesAndReturnError:
    @abstract   Returns a NSArray of the record types supported by this node.
    @discussion Returns a NSArray of the record types supported by this node.  If node does not support the check
                then all possible types will be returned.  outError is optional parameter, nil can be passed if error details
                are not needed.
*/
- (NSArray *)supportedRecordTypesAndReturnError:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     supportedAttributesForRecordType:error:
    @abstract   Will return a list of attribute types supported for that attribute if possible
    @discussion Will return a list of attribute types supported for that attribute if possible.  If no specific
                types are available, then all possible values will be returned instead.  outError is optional parameter,
                nil can be passed if error details are not needed.
*/
- (NSArray *)supportedAttributesForRecordType:(ODRecordType)inRecordType error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     setCredentialsWithRecordType:recordName:password:error:
    @abstract   Sets the credentials for interaction with the ODNode
    @discussion Sets the credentials for interaction with the ODNode.  Record references, etc. will use these credentials
                to query or change data.  Setting the credentials on a node referenced by other OD object types will
                change the credentials for all for all references.  outError is optional parameter, nil can be passed if error
                details are not needed.
*/
- (BOOL)setCredentialsWithRecordType:(ODRecordType)inRecordType recordName:(NSString *)inRecordName password:(NSString *)inPassword
                               error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     setCredentialsWithRecordType:authType:authItems:outAuthItems:context:error:
    @abstract   Allows use of other OpenDirectory types of authentications to set the credentials for an ODNode
    @discussion Allows the caller to use other types of authentications that are available in OpenDirectory, that may
                require response-request loops, etc.  Not all OD plugins will support this call, look for 
                kODErrorCredentialsMethodNotSupported in outError.  outError is optional parameter, nil can be passed if 
				error details is not needed.
*/
- (BOOL)setCredentialsWithRecordType:(ODRecordType)inRecordType authenticationType:(ODAuthenticationType)inType 
                 authenticationItems:(NSArray *)inItems continueItems:(NSArray **)outItems
                             context:(id *)outContext error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     setCredentialsUsingKerberosCache:error:
    @abstract   Unsupported method.
    @discussion Unsupported method.
*/
- (BOOL)setCredentialsUsingKerberosCache:(NSString *)inCacheName error:(NSError **)outError NS_DEPRECATED_MAC(10_6, 10_7) NS_AVAILABLE(10_6, NA);

/*!
    @method     createRecordWithRecordType:name:attributes:error:
    @abstract   Creates a record in this node, using the given name and attributes.
    @discussion Takes all the provided attributes and type to create an entire record.  The function will assign a
                UUID to the record automatically.  This UUID can be overwritten by the client by passing with the
                other attributes.  inAttributes is optional, nil can be passed if no other attributes are to be set.
*/
- (ODRecord *)createRecordWithRecordType:(ODRecordType)inRecordType name:(NSString *)inRecordName 
                              attributes:(NSDictionary *)inAttributes error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     recordWithRecordType:name:attributes:error:
    @abstract   Returns an ODRecord object that references the requested type and name
    @discussion Returns an ODRecord object that references the requested type and name.  The record will have cached the
                attributes requested.  Further attributes can be requested via ODRecord APIs.  For performance it is best
                to ask for as many attributes that are needed as possible up front.
*/
- (ODRecord *)recordWithRecordType:(ODRecordType)inRecordType name:(NSString *)inRecordName attributes:(id)inAttributes
                             error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     customCall:sendData:error:
    @abstract   Sends a custom code to the node; input and output data formats are specific to the call.
    @discussion Sends a custom code to the node; input and output data formats are specific to the call.  outError is 
                optional parameter, nil can be passed if error details are not needed.
*/
- (NSData *)customCall:(NSInteger)inCustomCode sendData:(NSData *)inSendData error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     customFunction:payload:error:
    @abstract   Sends a custom function call to the node; data is a type specific to the call.
    @discussion Sends a custom function call to the node; data is a type specific to the call.  'error' is an
                optional parameter therefore nil can be passed if error details are not needed.  Return type is
				defined by the custom function requested.
*/
- (id)customFunction:(NSString *)function payload:(id)payload error:(NSError **)error NS_AVAILABLE(10_9, NA);

/*!
 * @method configuration
 *
 * @abstract
 * Returns an ODConfiguration object for the node.
 *
 * @discussion
 * Returns an ODConfiguration object for the node.
 */
@property (readonly, strong) ODConfiguration *configuration;

/*!
    @method     policiesAndReturnError:
    @abstract   This will copy any policies configured for the node.
    @discussion This will copy any policies configured for the node.
*/
- (NSDictionary *)policiesAndReturnError:(NSError **)error __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "use accountPoliciesAndReturnError:");

/*!
    @function   supportedPoliciesAndReturnError:
    @abstract   This will return a dictionary of supported policies.
    @discussion This will return a dictionary of supported policies, if appropriate, the value will be the maximum value allowed
                for the policy in question.  For example, if password history is available, it will state how much history is
                supported.
*/
- (NSDictionary *)supportedPoliciesAndReturnError:(NSError **)error __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA);

/*!
    @function   setPolicies:error:
    @abstract   This will set the policy for the node.
    @discussion This will set the policy for the node.  Policies are evaluated in combination with record-level policies.
*/
- (BOOL)setPolicies:(NSDictionary *)policies error:(NSError **)error __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "use setAccountPolicies:error:");

/*!
    @function   setPolicy:value:error:
    @abstract   This will set a specific policy setting for the node.
    @discussion This will set a specific policy setting for the node.
*/
- (BOOL)setPolicy:(ODPolicyType)policy value:(id)value error:(NSError **)error __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "use addAccountPolicy:toCategory:error:");

/*!
    @function   removePolicy:value:error:
    @abstract   This will remove a specific policy setting from the node.
    @discussion This will remove a specific policy setting from the node.
*/
- (BOOL)removePolicy:(ODPolicyType)policy error:(NSError **)error __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "use removeAccountPolicy:fromCategory:error:");

/*!
    @method     addAccountPolicy:toCategory:error:
    @abstract   This will add an account policy to the node for the specified category.
    @discussion This will add an account policy to the node for the specified category.
                The specified policy will be applied to all users in the
                specified node when policies are evaluated.
    @param      policy a dictionary containing the specific policy to be added.
                The dictionary may contain the following keys:
                    kODPolicyKeyIdentifier a required key identifying the policy.
                    kODPolicyKeyParameters an optional key containing a dictionary of
                        parameters that can be used for informational purposes or in
                        the policy format string.
                    kODPolicyKeyContent a required key specifying the policy,
                        from which a predicate will be created for evaluating
                        the policy.
    @param      category a valid ODPolicyCategoryType to which the specified policy will be added.
    @param      error an optional NSError reference for error details.
    @result     a BOOL which signifies if the policy addition succeeded, otherwise error is set.
*/
- (BOOL)addAccountPolicy:(NSDictionary *)policy toCategory:(ODPolicyCategoryType)category error:(NSError **)error __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @method     removeAccountPolicy:fromCategory:error:
    @abstract   This will remove an account policy from the node for the specified category.
    @discussion This will remove an account policy from the node for the specified category.
    @param      policy a dictionary containing the specific policy to be
                removed, with the same format as described in addAccountPolicy.
    @param      category a valid ODPolicyCategoryType from which the specified policy will be removed.
    @param      error an optional NSError reference for error details.
    @result     a BOOL which signifies if the policy removal succeeded, otherwise error is set.
*/
- (BOOL)removeAccountPolicy:(NSDictionary *)policy fromCategory:(ODPolicyCategoryType)category error:(NSError **)error __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @method     setAccountPolicies:error:
    @abstract   This will set the policies for the node.
    @discussion This will set the policies for the node, replacing any existing
                policies.  All of the policies in the set will be applied to all
                users in the specified node when policies are evaluated.
    @param      policies a dictionary containing all of the policies to be set
                for the node.  The dictionary may contain the following keys:
                    kODPolicyCategoryAuthentication an optional key with a value
                        of an array of policy dictionaries that specify when
                        authentications should be allowed.
                    kODPolicyCategoryPasswordContent an optional key with a
                        value of an array of policy dictionaries the specify the
                        required content of passwords. 
                    kODPolicyCategoryPasswordChange an optional key with a value
                    of an array of policy dictionaries that specify when
                    passwords are required to be changed.
    @param      error an optional NSError reference for error details.
    @result     a BOOL which signifies if the policy set succeeded, otherwise error is set.
*/
- (BOOL)setAccountPolicies:(NSDictionary *)policies error:(NSError **)error __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @method     accountPoliciesAndReturnError:
    @abstract   Returns a dictionary containing any policies configured for the node.
    @discussion Returns a dictionary containing any policies configured for the node.
    @param      error an optional NSError reference for error details.
    @result     an NSDictionary containing all currently set policies.  The
                format of the dictionary is the same as described in
                setAccountPolicies.
*/
- (NSDictionary *)accountPoliciesAndReturnError:(NSError **)error __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @method     passwordContentCheck:forRecordName:error:
    @abstract   Validates a password against the node's password content policies.
    @discussion Validates a password against the node's password content policies.
                The node's password content policies will be evaluated to
                determine if the password is acceptable.  May be used prior to
                creating the record.

                This check is only definitive at the time it was requested. The
                policy or the environment could change before the password change
                is actually requested.  Errors from the password change request
                should be consulted.

    @param      password the password to be evaluated against the content policies.
    @param      recordName the name of the record.
    @param      error an optional NSError reference for error details.
    @result     a bool which signifies if the password passes all content policies, otherwise error is set.
 */
- (BOOL)passwordContentCheck:(NSString *)password forRecordName:(NSString *)recordName error:(NSError **)error __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);
@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            ODQuery.h                                                                                           0100644 0001750 0001750 00000015103 12566202403 034103  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Headers                                                               /*
 * Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#import <OpenDirectory/OpenDirectory.h>

@class ODQuery;
@class ODNode;

/*!
    @protocol    ODQueryDelegate
    @abstract    The delegate method for receiving query results from the NSRunLoop-based queries
    @discussion  The delegate method called as results are returned from an NSRunLoop-based query.  These results are only partial
                 and delegate is called repeatedly as results are available.  The incoming result must be retained or copied.  The 
                 array will be released by the NSRunLoop upon return.  Incoming results do not include previous results,
                 only the most resent results are returned.  inResults can be nil if an error occurs or the query is complete.  If 
                 inResults and inError are nil then the query has completed.
*/
@protocol ODQueryDelegate <NSObject>
@required
- (void)query:(ODQuery *)inQuery foundResults:(NSArray *)inResults error:(NSError *)inError NS_AVAILABLE(10_6, NA);
@end

/*!
    @class       ODQuery
    @abstract    Class used for querying OpenDirectory.
    @discussion  OpenDirectory queries may be used to search for different types of records, e.g. users, groups.
*/
@interface ODQuery : NSObject <NSCopying>
{
	@private
	void *_internal;
}

/*!
    @method     queryWithNode:forRecordTypes:attribute:matchType:queryValues:returnAttributes:maximumResults:error:
    @abstract   Creates an autoreleased query with the node using the parameters provided
    @discussion Creates an autoreleased query with the node using the supplied query parameters.  Some parameters
                can either be NSString or NSData or an NSArray of either NSString or NSData.  Passing nil for 
                returnAttributes is equivalent to passing kODAttributeTypeStandardOnly.  outError is optional parameter,
                nil can be passed if error details are not needed.  
*/
+ (ODQuery *)queryWithNode:(ODNode *)inNode forRecordTypes:(id)inRecordTypeOrList attribute:(ODAttributeType)inAttribute
                 matchType:(ODMatchType)inMatchType queryValues:(id)inQueryValueOrList 
          returnAttributes:(id)inReturnAttributeOrList maximumResults:(NSInteger)inMaximumResults
                     error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     initWithNode:forRecordTypes:attribute:matchType:queryValues:returnAttributes:maximumResults:error:
    @abstract   Creates a query with the node using the parameters provided
    @discussion Creates a query with the node using the supplied query parameters.  Some parameters
                can either be NSString or NSData or an NSArray of either NSString or NSData.  Passing nil for 
                returnAttributes is equivalent to passing kODAttributeTypeStandardOnly. outError is optional parameter,
                nil can be passed if error details are not needed.
*/
- (instancetype)initWithNode:(ODNode *)inNode forRecordTypes:(id)inRecordTypeOrList attribute:(ODAttributeType)inAttribute
         matchType:(ODMatchType)inMatchType queryValues:(id)inQueryValueOrList 
  returnAttributes:(id)inReturnAttributeOrList maximumResults:(NSInteger)inMaximumResults error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     resultsAllowingPartial:error:
    @abstract   Returns results from a provided ODQuery synchronously
    @discussion Returns results from a provided ODQuery synchronously.  Passing NO to inAllowPartialResults
                will block the call until all results are returned or an error occurs.  YES can be passed at any time
                even if previous calls were made with NO.  outError is optional parameter, nil can be passed if error 
                details are not needed.
*/
- (NSArray *)resultsAllowingPartial:(BOOL)inAllowPartialResults error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @property   delegate
    @abstract   The currently set delegate
    @discussion The query delegate which will receive asynchronous query results.
*/
@property (nonatomic, readwrite, assign) id <ODQueryDelegate> delegate NS_AVAILABLE(10_6, NA);

/*!
    @method     scheduleInRunLoop:forMode:
    @abstract   Adds the query object to the specified NSRunLoop to receive asynchronous results
    @discussion Adds the query object to the specified NSRunLoop to receive asynchronous results.  A delegate must be set
                in advance otherwise results may be lost due to the lack of a receiver.
*/
- (void)scheduleInRunLoop:(NSRunLoop *)inRunLoop forMode:(NSString *)inMode NS_AVAILABLE(10_6, NA);

/*!
    @method     removeFromRunLoop:forMode:
    @abstract   Removes the query object from the specified NSRunLoop
    @discussion Removes the query object from the specified NSRunLoop.
*/
- (void)removeFromRunLoop:(NSRunLoop *)inRunLoop forMode:(NSString *)inMode NS_AVAILABLE(10_6, NA);

/*!
    @method     synchronize
    @abstract   Will dispose of any results and restart the query.
    @discussion Will dispose of any results and restart the query for subsequent resultsAllowingPartial: calls.  If the query
                is currently scheduled on a RunLoop, then the delegate will be called with inResults == nil and
                [inError code] == kODErrorQuerySynchronize and [inError domain] == ODFrameworkErrorDomain, signifying that
                all existing results should be thrown away in preparation for new results.
*/
- (void)synchronize NS_AVAILABLE(10_6, NA);

/*!
    @property   operationQueue
    @abstract   The NSOperationQueue on which asynchronous results are delivered to the delegate.
    @discussion The NSOperationQueue on which asynchronous results are delivered to the delegate.
 */
@property (readwrite, retain) NSOperationQueue * operationQueue NS_AVAILABLE(10_6, NA);

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                             ODRecord.h                                                                                          0100644 0001750 0001750 00000062557 12566202403 034233  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Headers                                                               /*
 * Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#import <OpenDirectory/OpenDirectory.h>

/*!
    @class       ODRecord
    @abstract    This class is used to read, update and modify records within the directory
    @discussion  This class is used to read, update and modify records within the directory.  outError is optional parameter,
                 nil can be passed if error details are not needed.
*/
@interface ODRecord : NSObject

/*!
    @method     setNodeCredentials:password:error:
    @abstract   Similar to calling -[ODNode setCredentials:] except credentials are only set for this particular
                record's node
    @discussion Sets the credentials if necessary on the ODNode referenced by this ODRecord.  Very similar to
                calling -[ODNode setCredentials:] except other records referencing the underlying node will not get
                authenticated, therefore inadvertant changes cannot occur.  If all records referencing a particular 
                node need to be updated, then use -[ODNode setCredentials:] on the original node instead.  If the
                node is already authenticated with the same name and password, it will be a NOOP call.  The original
                ODNode held by an ODRecord will be released when the credentials are changed for the connection
                associated with the record.  outError is optional parameter, nil can be passed if error details are not needed.
*/
- (BOOL)setNodeCredentials:(NSString *)inUsername password:(NSString *)inPassword error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     setNodeCredentialsWithRecordType:authenticationType:authenticationItems:continueItems:context:error:
    @abstract   Similar to calling -[ODNode setCredentialsWithRecordType:] except credentials are only set for this particular record's
                node
    @discussion Allows the caller to use other types of authentications that are available in OpenDirectory, that may
                require response-request loops, etc.  Not all OD plugins will support this call, look for 
                kODErrorCredentialsMethodNotSupported in outError.  Same behavior as ODRecordSetNodeCredentials.  outError 
				is optional parameter, nil can be passed if error details are not needed.
*/
- (BOOL)setNodeCredentialsWithRecordType:(ODRecordType)inRecordType authenticationType:(ODAuthenticationType)inType 
                     authenticationItems:(NSArray *)inItems continueItems:(NSArray **)outItems
                                 context:(id *)outContext error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     setNodeCredentialsUsingKerberosCache:error:
    @abstract   Unsupported method.
    @discussion Unsupported method.
*/
- (BOOL)setNodeCredentialsUsingKerberosCache:(NSString *)inCacheName error:(NSError **)outError NS_DEPRECATED_MAC(10_6, 10_7);

/*!
    @method     passwordPolicyAndReturnError:
    @abstract   Returns a dictionary containing the password policy for the record if available.
    @discussion Returns a dictionary containing the password policy for the record if available.  If no policy for record
                nil will be returned.  outError is optional parameter, nil can be passed if error details are not needed.
*/
- (NSDictionary *)passwordPolicyAndReturnError:(NSError **)outError __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_6, __MAC_10_9, __IPHONE_NA, __IPHONE_NA, "use effectivePoliciesAndReturnError");

/*!
    @method     verifyPassword:error:
    @abstract   Verifies the password provided is valid for the record
    @discussion Verifies the password provided is valid for the record.  outError is optional parameter, nil can be passed if 
                error details are not needed.
*/
- (BOOL)verifyPassword:(NSString *)inPassword error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     verifyExtendedWithAuthenticationType:authenticationItems:continueItems:context:error:
    @abstract   Allows use of other OpenDirectory types of authentications
    @discussion Allows the caller to use other types of authentications that are available in OpenDirectory, that may 
                require response-request loops, etc.  A bool with the result of the operation.  
                If it fails, outError can be checked for more specific error.  Some ODNodes may not support the call
                so an error code of kODErrorCredentialsMethodNotSupported may be returned.  outError is optional 
                parameter, nil can be passed if error details are not needed.
*/
- (BOOL)verifyExtendedWithAuthenticationType:(ODAuthenticationType)inType authenticationItems:(NSArray *)inItems 
                               continueItems:(NSArray **)outItems context:(id *)outContext error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     changePassword:toPassword:error:
    @abstract   Changes the password for a record
    @discussion Changes the password for a record.  The oldPassword can be nil if password is being set assuming the appropriate
                privileges are in place.  outError is optional parameter, nil can be passed if error details are not needed.
*/
- (BOOL)changePassword:(NSString *)oldPassword toPassword:(NSString *)newPassword error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     synchronizeAndReturnError:
    @abstract   Synchronizes the record from the Directory in order to get current data and/or commit pending changes
    @discussion Synchronizes the record from the Directory in order to get current data.  Any previously fetched attributes
                will be re-fetch from the Directory.  This will not re-fetch the entire record, unless the entire record
                has been accessed.  Additionally, any changes made to the record will be committed to the directory,
                if the node does not do immediate commits.  outError is optional parameter, nil can be passed if error details
                are not needed.
*/
- (BOOL)synchronizeAndReturnError:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @property   recordType
    @abstract   Type of the record.
    @discussion The record type.
*/
@property (nonatomic, readonly, copy) NSString *recordType NS_AVAILABLE(10_6, NA);

/*!
    @property   recordName
    @abstract   Name of the record.
    @discussion This is the official record name.
*/
@property (nonatomic, readonly, copy) NSString *recordName NS_AVAILABLE(10_6, NA);

/*!
    @method     recordDetailsForAttributes:error:
    @abstract   Returns the attributes and values in the form of a key-value pair set.
    @discussion Returns the attributes and values in the form of a key-value pair set for this record.  The key is a 
                NSString of the attribute name (e.g., kODAttributeTypeRecordName, etc.) and the value is an NSArray
                of either NSData or NSString depending on the type of data.  Binary data will be returned as NSData.
                If nil is passed, then all currently retrieved attributes will be returned.  outError is optional parameter, 
                nil can be passed if error details are not needed.
*/
- (NSDictionary *)recordDetailsForAttributes:(NSArray *)inAttributes error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     valuesForAttribute:error:
    @abstract   Returns an NSArray of NSString or NSData values of the attribute
    @discussion Returns an NSArray of NSString or NSData depending on the type of data.  Binary data will be 
                returned as NSData.  outError is optional parameter, nil can be passed if error details are not needed.
*/
- (NSArray *)valuesForAttribute:(ODAttributeType)inAttribute error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
	@method     setValue:forAttribute:error:
	@abstract   Will take a mixture of NSData or NSString or an NSArray of either type when setting the values of an attribute
	@discussion Will take a mixture of NSData or NSString or an NSArray of either type when setting the values of an attribute.
				outError is optional parameter, nil can be passed if error details are not needed.
*/
- (BOOL)setValue:(id)inValueOrValues forAttribute:(ODAttributeType)inAttribute error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     removeValuesForAttribute:error:
    @abstract   Removes all the values for an attribute.
    @discussion Removes all the values for an attribute.  outError is optional parameter, nil can be passed if 
                error details are not needed.
*/
- (BOOL)removeValuesForAttribute:(ODAttributeType)inAttribute error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     addValue:toAttribute:error:
    @abstract   Will add a value to an attribute
    @discussion Will add a value to an attribute.  Should be either NSData or NSString type.  outError is optional 
                parameter, nil can be passed if error details are not needed.
*/
- (BOOL)addValue:(id)inValue toAttribute:(ODAttributeType)inAttribute error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     removeValue:fromAttribute:error:
    @abstract   Will remove a value from an attribute
    @discussion Will remove a value from an attribute.  Should be either NSData or NSString type.  outError is optional 
                parameter, nil can be passed if error details are not needed.
*/
- (BOOL)removeValue:(id)inValue fromAttribute:(ODAttributeType)inAttribute error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     deleteRecordAndReturnError:
    @abstract   Deletes the record from the node and invalidates the record.
    @discussion Deletes the record from the node and invalidates the record.  The ODRecord should be
                released after deletion.  outError is optional parameter, nil can be passed if error details are not needed.
*/
- (BOOL)deleteRecordAndReturnError:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     policiesAndReturnError:
    @abstract   This will copy any policies configured for the record.
    @discussion This will copy any policies configured for the record.
*/
- (NSDictionary *)policiesAndReturnError:(NSError **)error __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "use accountPoliciesAndReturnError:");

/*!
    @method     effectivePoliciesAndReturnError:
    @abstract   This will copy any policies configured for the record.
    @discussion This will copy any policies configured for the record.
*/
- (NSDictionary *)effectivePoliciesAndReturnError:(NSError **)error __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "use authenticationAllowedAndReturnError: and similar methods");

/*!
    @function   supportedPoliciesAndReturnError:
    @abstract   This will return a dictionary of supported policies.
    @discussion This will return a dictionary of supported policies, if appropriate, the value will be the maximum value allowed
                for the policy in question.  For example, if password history is available, it will state how much history is
                supported.
*/
- (NSDictionary *)supportedPoliciesAndReturnError:(NSError **)error __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA);

/*!
    @function   setPolicies:error:
    @abstract   This will set the policy for the record.
    @discussion This will set the policy for the record.  Policies are evaluated in combination with node-level policies.
*/
- (BOOL)setPolicies:(NSDictionary *)policies error:(NSError **)error __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "use setAccountPolicies:error:");

/*!
    @function   setPolicy:value:error:
    @abstract   This will set a specific policy setting for the record.
    @discussion This will set a specific policy setting for the record.
*/
- (BOOL)setPolicy:(ODPolicyType)policy value:(id)value error:(NSError **)error __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "use addAccountPolicy:toCategory:error:");

/*!
    @function   removePolicy:error:
    @abstract   This will remove a specific policy setting from the record.
    @discussion This will remove a specific policy setting from the record.
*/
- (BOOL)removePolicy:(ODPolicyType)policy error:(NSError **)error __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "use removeAccountPolicy:fromCategory:error:");

/*!
    @method     addAccountPolicy:toCategory:error:
    @abstract   This will add a specific policy to the specific category for the record.
    @discussion This will add a specific policy to the specific category for the record.
                The specified policy will be applied, in combination with any
                node policies, to the specified record when policies are evaluated.
    @param      policy a dictionary containing the specific policy to be added.
                The dictionary may contain the following keys:
                    kODPolicyKeyIdentifier a required key identifying the policy.
                    kODPolicyKeyParameters an optional key containing a dictionary of
                        parameters that can be used for informational purposes or in
                        the policy format string.
                    kODPolicyKeyContent a required key specifying the policy,
                        from which a predicate will be created for evaluating
                        the policy.
    @param      category a valid ODPolicyCategoryType to which the policy will be added.
    @param      error an optional NSError reference for error details.
    @result     a BOOL which signifies if the policy addition succeeded, otherwise error is set.
*/
- (BOOL)addAccountPolicy:(NSDictionary *)policy toCategory:(ODPolicyCategoryType)category error:(NSError **)error __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @method     removeAccountPolicy:fromCategory:error:
    @abstract   This will remove a specific policy from the specific category for the record.
    @discussion This will remove a specific policy from the specific category for the record.
    @param      policy a dictionary containing the specific policy to be
                removed, with the same format as described in addAccountPolicy.
    @param      category a valid ODPolicyCategoryType from which the policy will be removed.
    @param      error an optional NSError reference for error details.
    @result     a BOOL which signifies if the policy removal succeeded, otherwise error is set.
*/
- (BOOL)removeAccountPolicy:(NSDictionary *)policy fromCategory:(ODPolicyCategoryType)category error:(NSError **)error __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @method     setAccountPolicies:error:
    @abstract   This will set the policies for the record.
    @discussion This will set the policies for the record, replacing any
                existing policies.  All of the policies in the set will be
                applied to the record when policies are evaluated.
    @param      policies a dictionary containing all of the policies to be set
                for the node.  The dictionary may contain the following keys:
                    kODPolicyCategoryAuthentication an optional key with a value
                        of an array of policy dictionaries that specify when
                        authentications should be allowed.
                    kODPolicyCategoryPasswordContent an optional key with a
                        value of an array of policy dictionaries the specify the
                        required content of passwords. 
                    kODPolicyCategoryPasswordChange an optional key with a value
                        of an array of policy dictionaries that specify when
                        passwords are required to be changed.
    @param      error an optional NSError reference for error details.
    @result     a BOOL which signifies if the policy set succeeded, otherwise error is set.
*/
- (BOOL)setAccountPolicies:(NSDictionary *)policies error:(NSError **)error __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @method     accountPoliciesAndReturnError:
    @abstract   Returns a dictionary containing any policies configured for the record.
    @discussion Returns a dictionary containing any policies configured for the record.
                Does not include any policies set for the node.
    @discussion Returns a dictionary containing any policies configured for the record.
    @param      error an optional NSError reference for error details.
    @result     a NSDictionary containing all currently set policies.  The
                format of the dictionary is the same as described in
                setAccountPolicies. 
*/
- (NSDictionary *)accountPoliciesAndReturnError:(NSError **)error __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @function   authenticationAllowedAndReturnError:
    @abstract   Determines if policies allow the account to authenticate.
    @discussion Determines if policies allow the account to authenticate.
                Authentication and password change policies are evaluated.
                Record-level and node-level policies are evaluated in
                combination, with record-level taking precedence over node-level
                policies.  The failure of any single policy will deny the
                authentication.
 
                This check is only definitive at the time it was requested. The
                policy or the environment could change before the authentication
                is actually requested.  Errors from the authentication request
                should be consulted.

                It is not necessary to call this function when calling
                verifyPassword or verifyPasswordExtended since those methods
                perform the same policy evaluation.

    @param      error an optional NSError reference for error details.
    @result     a bool which signifies if the authentication is allowed, otherwise error is set.
 */
- (BOOL)authenticationAllowedAndReturnError:(NSError **)error __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @method     passwordChangeAllowed:error:
    @abstract   Determines if policies allow the password change.
    @discussion Determines if policies allow the password change.  Password
                content policies are evaluated. Record-level and node-level
                policies are evaluated in combination, with record-level taking
                precedence over node-level policies.  The failure of any single
                policy will deny the password change.

                This check is only definitive at the time it was requested. The
                policy or the environment could change before the password change
                is actually requested.  Errors from the password change request
                should be consulted.

    @param      newPassword contains the password to be evaluated.
    @param      error an optional NSError reference for error details.
    @result     a BOOL which signifies if the password change is allowed, otherwise error is set.
 */
- (BOOL)passwordChangeAllowed:(NSString *)newPassword error:(NSError **)error __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @method     willPasswordExpire:
    @abstract   Determines if the password will expire within the specified time.
    @discussion Determines if the password will expire (i.e. need to be changed)
                between now and the specified number of seconds in the future. 
                Password change policies are evaluated.  Record-level and
                node-level policies are evaluated in combination, with
                record-level taking precedence over node-level policies.
    @param      willExpireIn the number of seconds from the current time to be
                used as the upper-bound for the password expiration period.
    @result     a BOOL which signifies if the password will expire within the
                specified time.
 */
- (BOOL)willPasswordExpire:(uint64_t)willExpireIn __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @method     willAuthenticationsExpire:
    @abstract   Determines if authentications will expire within the specified time.
    @discussion Determines if authentications will expire (i.e. session and/or
                account expires) between now and the specified number of seconds
                in the future.  Authentication policies are evaluated.
                Record-level and node-level policies are evaluated in
                combination, with record-level taking precedence over node-level
                policies. 
    @param      willExpireIn the number of seconds from the current time to be
                used as the upper-bound for the authentication expiration period.
    @result     a BOOL which signifies if authentications will expire within the
                specified time.
 */
- (BOOL)willAuthenticationsExpire:(uint64_t)willExpireIn __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @method     secondsUntilPasswordExpires
    @abstract   Determines how many seconds until the password expires.
    @discussion Determines how many seconds until the password expires (i.e.
                needs changing).  Password change policies are evaluated.
                Record-level and node-level policies are evaluated in
                combination, with record-level taking precedence over node-level
                policies. 
    @result     the number of seconds until the password expires.  If multiple
                policies will cause the password to expire, the soonest
                expiration time is returned.  If already expired,
                kODExpirationTimeExpired is returned.  If there are no password
                change policies, kODExpirationTimeNeverExpires is returned. 
 */
@property (readonly) int64_t secondsUntilPasswordExpires __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @method     secondsUntilAuthenticationsExpire
    @abstract   Determines how many seconds until authentications expire.
    @discussion Determines how many seconds until authentications expire (i.e.
                session and/or account expires). Authentication policies are
                evaluated.   Record-level and node-level policies are evaluated
                in combination, with record-level taking precedence over
                node-level policies.
    @result     the number of seconds until authentications expire.  If multiple
                policies will cause authentications to expire, the soonest
                expiration time is returned. If already expired,
                kODExpirationTimeExpired is returned.  If there are no
                authentication policies controlling expiration,
                kODExpirationTimeNeverExpires is returned.  
 */
@property (readonly) int64_t secondsUntilAuthenticationsExpire __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

@end

/*!
    @category    ODRecord (ODRecordGroupExtensions)
    @discussion  Record extensions for checking and modifying group membership.
*/
@interface ODRecord (ODRecordGroupExtensions)

/*!
    @method     addMemberRecord:error:
    @abstract   Will add the record as a member of the group record
    @discussion Will add the record as a member of the group record.  An error will be returned if the record is not
                a group record.  Additionally, if the member record is not an appropriate type allowed as part of a group
                an error will be returned.  outError is optional parameter, nil can be passed if error details are not needed.
*/
- (BOOL)addMemberRecord:(ODRecord *)inRecord error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     removeMemberRecord:error:
    @abstract   Will remove the record as a member from the group record
    @discussion Will remove the record as a member from the group record. An error will be returned if the record is not
                a group record.  Additionally, if the member record is not an appropriate type allowed as part of a group
                an error will be returned.  outError is optional parameter, nil can be passed if error details are not needed.
*/
- (BOOL)removeMemberRecord:(ODRecord *)inRecord error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     isMemberRecord:error:
    @abstract   Will use membership APIs to determine if inRecord is a member of the group
    @discussion Will use membership APIs to determine if inRecord is a member of the group.  If the receiving
                object is not a group then NO will still be returned.  outError is optional parameter, nil can be passed if 
                error details are not needed.
*/
- (BOOL)isMemberRecord:(ODRecord *)inRecord error:(NSError **)outError NS_AVAILABLE(10_6, NA);

@end
                                                                                                                                                 ODRecordMap.h                                                                                       0100644 0001750 0001750 00000006101 12566202403 034650  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Headers                                                               /*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#import <Foundation/Foundation.h>

@class ODAttributeMap;

NS_CLASS_AVAILABLE_MAC(10_9)
@interface ODRecordMap : NSObject {
	@protected
	NSString *native;
	NSDictionary *odPredicate;
	NSMutableDictionary *attributes;
}

/* native value for this attribute, if not present, translation function or preformed OD predicate must be present */
@property(copy) NSString *native NS_AVAILABLE_MAC(10_9);

/*
 * preformed OD-style predicate that defines a query for a specific record type
 * 
 * predicate dictionary:
 *		attribute : <native attribute>
 *		values : [ <value> ] # note multiple values will be treated as AND
 *		matchtype : <value from kODMatchEqualTo(0x2001) | kODMatchBeginsWith(0x2002) | kODMatchContains(0x2003) | kODMatchEndsWith(0x2004)>
 *
 * nested predicates
 *		operator : { OR | AND | NOT }
 *		predicates : [ <predicate>, ... ]
 */
@property(copy) NSDictionary *odPredicate NS_AVAILABLE_MAC(10_9);

/* dictionary of OpenDirectory standard attributes as a key and a value of ODAttributeMap */
@property(readonly, copy) NSDictionary *attributes NS_AVAILABLE_MAC(10_9);

/* returns an array of NSStrings that list the attributes for this recordmap */
@property(readonly, copy) NSArray *standardAttributeTypes NS_AVAILABLE_MAC(10_9);

/*!
 * @method recordMap
 *
 * @abstract
 * Returns an initialized and autoreleased ODRecordMap object.
 *
 * @discussion
 * Returns an initialized and autoreleased ODRecordMap object.
 */
+ (instancetype)recordMap;

/*!
 * @method attributeMapForStandardAttribute:
 *
 * @abstract
 * Returns an ODAttributeMap object for the given OD standard attribute.
 *
 * @discussion
 * Returns an ODAttributeMap object for the given OD standard attribute.
 */
- (ODAttributeMap *)attributeMapForStandardAttribute:(NSString *)standardAttribute NS_AVAILABLE_MAC(10_9);

/*!
 * @method setAttributeMap:forStandardAttribute:
 *
 * @abstract
 * Sets an ODAttributeMap object for a given OD standard attribute.
 *
 * @discussion
 * Sets an ODAttributeMap object for a given OD standard attribute.
 */
- (void)setAttributeMap:(ODAttributeMap *)attributeMap forStandardAttribute:(NSString *)standardAttribute NS_AVAILABLE_MAC(10_9);

@end
                                                                                                                                                                                                                                                                                                                                                                                                                                                               ODSession.h                                                                                         0100644 0001750 0001750 00000017752 12566202403 034435  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Headers                                                               /*
 * Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

@class SFAuthorization;

/*!
    @const      ODSessionProxyAddress
    @abstract   the address to connect to via proxy, used when making the options dictionary
    @discussion the address to connect to via proxy, used when making the options dictionary
*/
FOUNDATION_EXPORT NSString *const ODSessionProxyAddress NS_AVAILABLE(10_6, NA);

/*!
    @const      ODSessionProxyPort
    @abstract   the port to connect to via proxy, used when making the options dictionary
    @discussion the port to connect to via proxy, used when making the options dictionary.  This parameter
                is optional and should not be passed normally.
*/
FOUNDATION_EXPORT NSString *const ODSessionProxyPort NS_AVAILABLE(10_6, NA);

/*!
    @const      ODSessionProxyUsername
    @abstract   the username to connect with via proxy, used when making the options dictionary
    @discussion the username to connect with via proxy, used when making the options dictionary
*/
FOUNDATION_EXPORT NSString *const ODSessionProxyUsername NS_AVAILABLE(10_6, NA);

/*!
    @const      ODSessionProxyPassword
    @abstract   the password to connect with via proxy, used when making the options dictionary
    @discussion the password to connect with via proxy, used when making the options dictionary
*/
FOUNDATION_EXPORT NSString *const ODSessionProxyPassword NS_AVAILABLE(10_6, NA);

@class ODConfiguration;

/*!
    @class       ODSession
    @abstract    Class for working with OpenDirectory sessions.
    @discussion  Class for working with OpenDirectory sessions.
*/
@interface ODSession : NSObject {
	@private
	void *_internal;
}

/*!
    @method     defaultSession
    @abstract   Returns a shared instance of a local ODSession
    @discussion Returns a shared instance of a local ODSession.  This can be used for most situations unless
                more control is needed over the session.
*/
+ (ODSession *)defaultSession NS_AVAILABLE(10_6, NA);

/*!
    @method     sessionWithOptions:error:
    @abstract   Creates an autoreleased instance of ODSession directed over Proxy to another host
    @discussion Creates an autoreleased instance of ODSession directed over Proxy to another host.  nil
                can be passed for no options. outError is optional parameter, nil can be passed if error
                details are not needed.  Options include:

                If proxy is required then a dictionary with keys should be:
                            Key                             Value
                    ODSessionProxyAddress        NSString(hostname or IP)
                    ODSessionProxyPort           NSNumber(IP port, should not be set as it will default)
                    ODSessionProxyUsername       NSString(username)
                    ODSessionProxyPassword       NSString(password)
*/
+ (instancetype)sessionWithOptions:(NSDictionary *)inOptions error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     initWithOptions:error:
    @abstract   Creates an instance of ODSession directed over Proxy to another host
    @discussion Creates an instance of ODSession directed over Proxy to another host.  nil can be
                passed for no options. outError is optional parameter, nil can be passed if error
                details are not needed. Options include:
     
                If proxy is required then a dictionary with keys should be:
                            Key                             Value
                    ODSessionProxyAddress        NSString(hostname or IP)
                    ODSessionProxyPort           NSNumber(IP port, should not be set as it will default)
                    ODSessionProxyUsername       NSString(username)
                    ODSessionProxyPassword       NSString(password)
*/
- (instancetype)initWithOptions:(NSDictionary *)inOptions error:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
    @method     nodeNamesAndReturnError:
    @abstract   Returns the node names that are registered on this ODSession
    @discussion Returns the node names that are registered on this ODSession.  outError can be nil if
                error details are not needed.
*/
- (NSArray *)nodeNamesAndReturnError:(NSError **)outError NS_AVAILABLE(10_6, NA);

/*!
 * @method configurationTemplateNames
 *
 * @abstract
 * Returns a list of names as NSStrings for all available configuration templates.
 *
 * @discussion
 * Returns a list of names as NSStrings for all available configuration templates.  Configuration templates
 * have pre-configured modules and/or mappings.  Useful for re-using existing configurations
 * that may change with operating system without changing the actual configuration.
 */
@property (readonly, copy) NSArray *configurationTemplateNames NS_AVAILABLE_MAC(10_9);

/*!
 * @method mappingTemplateNames
 *
 * @abstract
 * Returns a list names as NSStrings for all available mapping templates.
 *
 * @discussion
 * Returns a list names as NSStrings for all available mapping templates.  Mapping templates have pre-configured
 * record/attribute mappings.  Useful if a configuration uses a common layout of mappings for a type of server.
 */
@property (readonly, copy) NSArray *mappingTemplateNames NS_AVAILABLE_MAC(10_9);

/*!
 * @method configurationAuthorizationAllowingUserInteraction:
 *
 * @abstract
 * Returns an authorization appropriate for managing configurations.
 *
 * @discussion
 * Returns an authorization appropriate for managing configurations.  If a proxy session is in use this method will return
 * nil and no error.
 */
- (SFAuthorization *)configurationAuthorizationAllowingUserInteraction:(BOOL)allowInteraction error:(NSError **)error NS_AVAILABLE_MAC(10_9);

/*!
 * @method configurationForNodename:
 *
 * @abstract
 * Reads the configuration for a given nodename.
 *
 * @discussion
 * Reads the configuration for a given nodename.
 */
- (ODConfiguration *)configurationForNodename:(NSString *)nodename NS_AVAILABLE_MAC(10_9);

/*!
 * @method addConfiguration:authorization:error:
 *
 * @abstract
 * Adds a new configuration to the existing ODSession.
 *
 * @discussion
 * Adds a new configuration to the existing ODSession.  An SFAuthorization can be provided if necessary.
 */
- (BOOL) addConfiguration:(ODConfiguration *)configuration authorization:(SFAuthorization *)authorization error:(NSError **)error NS_AVAILABLE_MAC(10_9);

/*!
 * @method deleteConfiguration:authorization:error:
 *
 * @abstract
 * Deletes an existing configuration from the ODSession.
 *
 * @discussion
 * Deletes an existing configuration from the ODSession.  An authorization can be provided if necessary.
 */
- (BOOL) deleteConfiguration:(ODConfiguration *)configuration authorization:(SFAuthorization *)authorization error:(NSError **)error NS_AVAILABLE_MAC(10_9);

/*!
 * @method deleteConfigurationWithNodename:authorization:error:
 *
 * @abstract
 * Deletes an existing configuration from the ODSession.
 *
 * @discussion
 * Deletes an existing configuration from the ODSession.  An authorization can be provided if necessary.
 */
- (BOOL) deleteConfigurationWithNodename:(NSString *)nodename authorization:(SFAuthorization *)authorization error:(NSError **)error NS_AVAILABLE_MAC(10_9);

@end
                      OpenDirectory.h                                                                                     0100644 0001750 0001750 00000003005 12566202403 035337  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Headers                                                               /*
 * Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#if __OBJC__
#import <Foundation/Foundation.h>
#endif /* __OBJC__ */

#include <CFOpenDirectory/CFOpenDirectory.h>

#if __OBJC__

FOUNDATION_EXPORT NSString *const ODFrameworkErrorDomain NS_AVAILABLE(10_6, NA);

#import <OpenDirectory/ODSession.h>
#import <OpenDirectory/ODRecord.h>
#import <OpenDirectory/ODNode.h>
#import <OpenDirectory/ODQuery.h>
#import <OpenDirectory/ODConfiguration.h>
#import <OpenDirectory/ODMappings.h>
#import <OpenDirectory/ODRecordMap.h>
#import <OpenDirectory/ODAttributeMap.h>
#import <OpenDirectory/ODModuleEntry.h>

#endif /* __OBJC__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           OpenDirectory.tbd                                                                                   0100644 0001750 0001750 00000001555 12571375067 034333  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A                                                                       ---
archs:           [ i386, x86_64 ]
platform:        macosx
install-name:    /System/Library/Frameworks/OpenDirectory.framework/Versions/A/OpenDirectory
exports:         
  - archs:           [ i386, x86_64 ]
    re-exports:      [ /System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks/CFOpenDirectory.framework/Versions/A/CFOpenDirectory ]
    symbols:         [ _ODFrameworkErrorDomain, _ODSessionProxyAddress, 
                       _ODSessionProxyPassword, _ODSessionProxyPort, _ODSessionProxyUsername, 
                       _ODTrustInfoCopy, _ODTrustTypeAnonymous, _ODTrustTypeJoined, 
                       _ODTrustTypeUsingCredentials ]
    objc-classes:    [ _ODAttributeMap, _ODConfiguration, _ODContext, _ODMappings, 
                       _ODModuleEntry, _ODNode, _ODQuery, _ODRecord, _ODRecordMap, 
                       _ODSession ]
...
                                                                                                                                                   Current                                                                                             0120777 0001750 0001750 00000000000 12620245063 032316  2A                                                                                                   ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions                                                                         osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/module.map    0100644 0001750 0001750 00000000426 12566173266 031122  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        framework module OpenDirectory [extern_c] {
  umbrella header "OpenDirectory.h"

  export *
  module * { export * }

  exclude header "NSOpenDirectory.h"

  framework module CFOpenDirectory {
    umbrella header "CFOpenDirectory.h"
    export *
    module * { export * }
  }
}

                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/                     0040755 0001750 0001750 00000000000 12612224743 025462  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Headers              0120777 0001750 0001750 00000000000 12620245063 033501  2Versions/Current/Headers                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Libraries            0120777 0001750 0001750 00000000000 12620245063 034403  2Versions/Current/Libraries                                                                          ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/OpenGL.tbd           0120777 0001750 0001750 00000000000 12620245063 034343  2Versions/Current/OpenGL.tbd                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/            0040755 0001750 0001750 00000000000 12612224743 027272  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/A/          0040755 0001750 0001750 00000000000 12612224743 027452  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers/  0040755 0001750 0001750 00000000000 12612224743 031025  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        CGLContext.h                                                                                        0100644 0001750 0001750 00000001055 12567471560 033101  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers                                                                      /*
	Copyright:	(c) 1999-2012 Apple Inc. All rights reserved.
*/

#ifndef _CGLCONTEXT_H
#define _CGLCONTEXT_H

#include <OpenGL/gliContext.h>
#include <OpenGL/gliDispatch.h>

#ifdef __cplusplus
extern "C" {
#endif


/*
** Opaque declaration for private CGLContext data.
*/
typedef struct _CGLPrivateObject *CGLPrivateObj;

/*
** CGLContext structure.
*/
struct _CGLContextObject {
	GLIContext            rend;
	GLIFunctionDispatch   disp;
	CGLPrivateObj         priv;
	void                 *stak;
};


#ifdef __cplusplus
}
#endif

#endif /* _CGLCONTEXT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   CGLCurrent.h                                                                                        0100644 0001750 0001750 00000000723 12567471557 033106  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers                                                                      /*
	Copyright:	(c) 1999-2012 Apple Inc. All rights reserved.
*/

#ifndef _CGLCURRENT_H
#define _CGLCURRENT_H

#include <OpenGL/CGLTypes.h>

#ifdef __cplusplus
extern "C" {
#endif

OPENGL_ASSUME_NONNULL_BEGIN

/*
** Current context functions
*/
extern CGLError CGLSetCurrentContext(CGLContextObj OPENGL_NULLABLE ctx);
extern CGLContextObj OPENGL_NULLABLE CGLGetCurrentContext(void);

OPENGL_ASSUME_NONNULL_END

#ifdef __cplusplus
}
#endif

#endif /* _CGLCURRENT_H */

                                             CGLDevice.h                                                                                         0100644 0001750 0001750 00000001724 12567471560 032657  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers                                                                      /*
	Copyright:	(c) 2008-2012 Apple Inc. All rights reserved.
*/

#ifndef _CGLDEVICE_H
#define _CGLDEVICE_H

#include <OpenGL/CGLTypes.h>
#include <OpenGL/gltypes.h>

#ifdef __cplusplus
extern "C" {
#endif

OPENGL_ASSUME_NONNULL_BEGIN

typedef struct CGLShareGroupRec	*CGLShareGroupObj OPENGL_AVAILABLE(10_6);

CGLShareGroupObj OPENGL_NULLABLE CGLGetShareGroup(CGLContextObj ctx) OPENGL_AVAILABLE(10_6);

typedef struct _cl_device_id *      cl_device_id OPENGL_AVAILABLE(10_10);
  
/*
** CGLGetDeviceFromGLRenderer returns the cl_device_id corresponding to the
** specified GL renderer ID. Use CGLDescribeRenderer to check if the renderer
** supports kCGLRPAcceleratedCompute before calling this function. If there is 
** no cl_device_id corresponding to the specified renderer ID, the result is
** undefined.
 */
cl_device_id CGLGetDeviceFromGLRenderer(GLint rendererID) OPENGL_AVAILABLE(10_10);

OPENGL_ASSUME_NONNULL_END

#ifdef __cplusplus
}
#endif

#endif /* _CGLDEVICE_H */

                                            CGLIOSurface.h                                                                                      0100644 0001750 0001750 00000034357 12567471560 033310  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers                                                                      /*
	Copyright:	(c) 2008-2012 Apple Inc. All rights reserved.
*/

#ifndef _CGLIOSURFACE_H
#define _CGLIOSURFACE_H

#include <AvailabilityMacros.h>
#include <OpenGL/CGLTypes.h>
#include <OpenGL/gltypes.h>

#ifdef __cplusplus
extern "C" {
#endif

OPENGL_ASSUME_NONNULL_BEGIN

typedef struct __IOSurface *IOSurfaceRef;

/*!
            @function  CGLTexImageIOSurface2D
            
            CGLTexImageIOSurface2D() allows you to bind a single image plane from an IOSurfaceRef to
            an OpenGL texture object.   It is the rough equivalent to glTexImage2D(), except that
            the underlying source data comes from an IOSurface rather than from an explicit pointer.
            Note that unlike glTexImage2D(), the binding is "live", in that if the contents of
            the IOSurface change, the contents become visible to OpenGL without making another
            call to CGLTexImageIOSurface2D().   That being said, there are a few synchronization
            things to worry about if you are using IOSurface to pass data between contexts and/or
            different processes, or between the CPU and OpenGL.
            
            In general IOSurface follows Apple's cross-context synchronization rules for OpenGL. Put
            simply, in order for changes done to an IOSurface on context A to become visible to context
            B, you must flush context A's command stream (via an explicit call to glFlush, glFlushRenderAPPLE,
            etc.), and then perform a 'bind' (in this case, glBindTexture()) on context B.  Note that
            in the case of an IOSurface backed texture used as a color buffer attachment for an FBO,
            you are only required to call glBindFramebuffer() again.  You do not have to call
            glFramebufferTexture2D().
            
            Likewise, if you make changes to an IOSurface with the CPU, you *must* wrap those changes
            with calls to IOSurfaceLock() and IOSurfaceUnlock(), and call glBindTexture() again for
            OpenGL to pick up the changes.
            
            Going in the other direction, if you want changes made with OpenGL to an IOSurface to become
            visible to the CPU, you must also perform an explicit flush of the OpenGL context before
            calling IOSurfaceLock(), or you may not get the most recent data.
            
            IOSurface and OpenGL make no guarantees about correctness if these rules are not followed.
            
            Because of the way IOSurface is currently implemented, it does not allow for any kind of
            automatic format conversion to take place between the data in the IOSurface and the data seen
            by the GPU.   This means that OpenGL is going to interpret the data in the IOSurface exactly
            as how it is specified by the format and type parameters passed to CGLTexImageIOSurface2D().
            
            The upshot if this is that the only supported format/type combinations are those that have
            exact matching hardware formats.   The table at the bottom of this file lists the format/type/
            internalFormat combinations that are supported in Mac OS X 10.6.
            
            In cases where a given format/type combination has both an Internal Format and Sized Internal
            Format, either one may be used.
            
            Note that CGLTexImageIOSurface2D for the most part doesn't care what the pixel format or bytes
            per element of the IOSurface is.  Instead it only enforces the rule that there must be enough
            data in the plane being bound to cover what is required by the width/height/format/type
            parameters.   However, if you are using the IOSurface texture as a color buffer attachment to
            an FBO, then you must ensure that the bytes per element value of the IOSurface must match the
            effective bytes per pixel value for the format and type combination you are passing to OpenGL.
            
            @param ctx              The CGLContextObj for the OpenGL context you are using
            @param target           Must currently be GL_TEXTURE_RECTANGLE_ARB as of Mac OS X 10.6.0.
            @param internal_format  One of the supported values from the table below that matches
                                    the format/type combination.
            @param width            The width of the texture in pixels.
            @param height           The height of the texture in pixels.
            @param format           The OpenGL texture format enum
            @param type             The OpenGL texture type enum
            @param ioSurface        The IOSurfaceRef this texture is being bound to
            @param plane            Which plane of the IOSurface this texture is being bound to
            
*/
extern CGLError CGLTexImageIOSurface2D(CGLContextObj ctx, GLenum target, GLenum internal_format,
						GLsizei width, GLsizei height, GLenum format, GLenum type, IOSurfaceRef ioSurface, GLuint plane) OPENGL_AVAILABLE(10_6);
/*!

    Supported IOSurface texture format/type/internal format combinations in Mac OS X 10.6

    Format                          Type                                    Internal Format         Sized Internal Format
    GL_ALPHA                        GL_UNSIGNED_BYTE                        GL_ALPHA                GL_ALPHA8
    GL_LUMINANCE                    GL_UNSIGNED_BYTE                        GL_LUMINANCE            GL_LUMINANCE8
    GL_LUMINANCE                    GL_UNSIGNED_BYTE                        GL_INTENSITY            GL_INTENSITY8
    GL_LUMINANCE_ALPHA              GL_UNSIGNED_BYTE                        GL_LUMINANCE_ALPHA      GL_LUMINANCE8_ALPHA8

    GL_ALPHA                        GL_UNSIGNED_SHORT                       GL_ALPHA                GL_ALPHA16
    GL_LUMINANCE                    GL_UNSIGNED_SHORT                       GL_LUMINANCE            GL_LUMINANCE16
    GL_LUMINANCE                    GL_UNSIGNED_SHORT                       GL_INTENSITY            GL_INTENSITY16

    GL_BGRA                         GL_UNSIGNED_SHORT_1_5_5_5_REV           GL_RGBA                 GL_RGB5_A1
    GL_BGRA                         GL_UNSIGNED_SHORT_4_4_4_4_REV           GL_RGBA                 GL_RGBA4

    GL_BGRA                         GL_UNSIGNED_INT_8_8_8_8_REV             GL_RGB                  GL_RGB8
    GL_BGRA                         GL_UNSIGNED_INT_8_8_8_8_REV             GL_RGBA                 GL_RGBA8
    GL_BGRA                         GL_UNSIGNED_INT_2_10_10_10_REV          GL_RGBA                 GL_RGB10_A2

    // "Video" formats

    GL_RGB_422_APPLE                GL_UNSIGNED_SHORT_8_8_APPLE             GL_RGB                  GL_RGB8
    GL_RGB_422_APPLE                GL_UNSIGNED_SHORT_8_8_REV_APPLE         GL_RGB                  GL_RGB8
    GL_YCBCR_422_APPLE              GL_UNSIGNED_SHORT_8_8_APPLE             GL_RGB                  GL_RGB8
    GL_YCBCR_422_APPLE              GL_UNSIGNED_SHORT_8_8_REV_APPLE         GL_RGB                  GL_RGB8

    // sRGB formats

    GL_BGRA                         GL_UNSIGNED_INT_8_8_8_8_REV             GL_SRGB                 GL_SRGB8
    GL_BGRA                         GL_UNSIGNED_INT_8_8_8_8_REV             GL_SRGB_ALPHA           GL_SRGB8_ALPHA8

    // Float formats for drivers that support APPLE_float_pixels:

    GL_RGBA                         GL_HALF_APPLE                           GL_RGB                  GL_RGB_FLOAT16_APPLE
    GL_RGBA                         GL_HALF_APPLE                           GL_RGBA                 GL_RGBA_FLOAT16_APPLE
    GL_RGBA                         GL_FLOAT                                GL_RGB                  GL_RGB_FLOAT32_APPLE
    GL_RGBA                         GL_FLOAT                                GL_RGBA                 GL_RGBA_FLOAT32_APPLE

    // 16-bit unorm textures
    GL_RGBA                         GL_UNSIGNED_SHORT                       GL_RGBA                  GL_RGBA16

    // Integer formats for drivers that support EXT_texture_integer:

    GL_ALPHA_INTEGER_EXT            GL_UNSIGNED_BYTE                                                GL_ALPHA8UI
    GL_ALPHA_INTEGER_EXT            GL_BYTE                                                         GL_ALPHA8I
    GL_ALPHA_INTEGER_EXT            GL_UNSIGNED_SHORT                                               GL_ALPHA16UI
    GL_ALPHA_INTEGER_EXT            GL_SHORT                                                        GL_ALPHA16I
    GL_ALPHA_INTEGER_EXT            GL_UNSIGNED_INT                                                 GL_ALPHA32UI
    GL_ALPHA_INTEGER_EXT            GL_INT                                                          GL_ALPHA32I

    GL_LUMINANCE_INTEGER_EXT        GL_UNSIGNED_BYTE                                                GL_LUMINANCE8UI
    GL_LUMINANCE_INTEGER_EXT        GL_BYTE                                                         GL_LUMINANCE8I
    GL_LUMINANCE_INTEGER_EXT        GL_UNSIGNED_SHORT                                               GL_LUMINANCE16UI
    GL_LUMINANCE_INTEGER_EXT        GL_SHORT                                                        GL_LUMINANCE16I
    GL_LUMINANCE_INTEGER_EXT        GL_UNSIGNED_INT                                                 GL_LUMINANCE32UI
    GL_LUMINANCE_INTEGER_EXT        GL_INT                                                          GL_LUMINANCE32I

    GL_LUMINANCE_INTEGER_EXT        GL_UNSIGNED_BYTE                                                GL_INTENSITY8UI
    GL_LUMINANCE_INTEGER_EXT        GL_BYTE                                                         GL_INTENSITY8I
    GL_LUMINANCE_INTEGER_EXT        GL_UNSIGNED_SHORT                                               GL_INTENSITY16UI
    GL_LUMINANCE_INTEGER_EXT        GL_SHORT                                                        GL_INTENSITY16I
    GL_LUMINANCE_INTEGER_EXT        GL_UNSIGNED_INT                                                 GL_INTENSITY32UI
    GL_LUMINANCE_INTEGER_EXT        GL_INT                                                          GL_INTENSITY32I

    GL_LUMINANCE_ALPHA_INTEGER_EXT  GL_UNSIGNED_BYTE                                                GL_LUMINANCE_ALPHA8UI
    GL_LUMINANCE_ALPHA_INTEGER_EXT  GL_BYTE                                                         GL_LUMINANCE_ALPHA8I
    GL_LUMINANCE_ALPHA_INTEGER_EXT  GL_UNSIGNED_SHORT                                               GL_LUMINANCE_ALPHA16UI
    GL_LUMINANCE_ALPHA_INTEGER_EXT  GL_SHORT                                                        GL_LUMINANCE_ALPHA16I
    GL_LUMINANCE_ALPHA_INTEGER_EXT  GL_UNSIGNED_INT                                                 GL_LUMINANCE_ALPHA32UI
    GL_LUMINANCE_ALPHA_INTEGER_EXT  GL_INT                                                          GL_LUMINANCE_ALPHA32I

    GL_RGBA_INTEGER_EXT             GL_UNSIGNED_BYTE                                                GL_RGB8UI
    GL_RGBA_INTEGER_EXT             GL_BYTE                                                         GL_RGB8I
    GL_RGBA_INTEGER_EXT             GL_UNSIGNED_SHORT                                               GL_RGB16UI
    GL_RGBA_INTEGER_EXT             GL_SHORT                                                        GL_RGB16I
    GL_RGBA_INTEGER_EXT             GL_UNSIGNED_INT                                                 GL_RGB32UI
    GL_RGBA_INTEGER_EXT             GL_INT                                                          GL_RGB32I

    GL_RGBA_INTEGER_EXT             GL_UNSIGNED_BYTE                                                GL_RGBA8UI
    GL_RGBA_INTEGER_EXT             GL_BYTE                                                         GL_RGBA8I
    GL_RGBA_INTEGER_EXT             GL_UNSIGNED_SHORT                                               GL_RGBA16UI
    GL_RGBA_INTEGER_EXT             GL_SHORT                                                        GL_RGBA16I
    GL_RGBA_INTEGER_EXT             GL_UNSIGNED_INT                                                 GL_RGBA32UI
    GL_RGBA_INTEGER_EXT             GL_INT                                                          GL_RGBA32I

    // Additional supported formats for drivers that support ARB_texture_rg:

    GL_RED                          GL_UNSIGNED_BYTE                        GL_RED                  GL_R8
    GL_RED                          GL_UNSIGNED_SHORT                       GL_RED                  GL_R16
    GL_RED                          GL_HALF_APPLE                           GL_RED                  GL_R16F
    GL_RED                          GL_FLOAT                                GL_RED                  GL_R32F

    GL_RG                           GL_UNSIGNED_BYTE                        GL_RG                   GL_RG8
    GL_RG                           GL_UNSIGNED_SHORT                       GL_RG                   GL_RG16
    GL_RG                           GL_HALF_APPLE                           GL_RG                   GL_R16F
    GL_RG                           GL_FLOAT                                GL_RG                   GL_R32F

    GL_RED_INTEGER                  GL_UNSIGNED_BYTE                                                GL_R8UI
    GL_RED_INTEGER                  GL_BYTE                                                         GL_R8I
    GL_RED_INTEGER                  GL_UNSIGNED_SHORT                                               GL_R16UI
    GL_RED_INTEGER                  GL_SHORT                                                        GL_R16I
    GL_RED_INTEGER                  GL_UNSIGNED_INT                                                 GL_R32UI
    GL_RED_INTEGER                  GL_INT                                                          GL_R32I

    GL_RG_INTEGER                   GL_UNSIGNED_BYTE                                                GL_RG8UI
    GL_RG_INTEGER                   GL_BYTE                                                         GL_RG8I
    GL_RG_INTEGER                   GL_UNSIGNED_SHORT                                               GL_RG16UI
    GL_RG_INTEGER                   GL_SHORT                                                        GL_RG16I
    GL_RG_INTEGER                   GL_UNSIGNED_INT                                                 GL_RG32UI
    GL_RG_INTEGER                   GL_INT                                                          GL_RG32I

*/

OPENGL_ASSUME_NONNULL_END

#ifdef __cplusplus
}
#endif

#endif /* _CGLSURFACE_H */

                                                                                                                                                                                                                                                                                 CGLMacro.h                                                                                          0100644 0001750 0001750 00000406734 12567471557 032541  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers                                                                      /*
	Copyright:	(c) 1999-2012 Apple Inc. All rights reserved.
*/

#ifndef _CGLMACRO_H
#define _CGLMACRO_H

#ifdef __gl3_h_
#  ifndef __has_feature
#    define __has_feature(X) 0
#  endif
#  if !__has_feature(modules)
#    error Can not include both gl3.h and CGLMacro.h simultaneously
#  endif
#endif

#include <OpenGL/CGLTypes.h>
#include <OpenGL/CGLContext.h>
#include <OpenGL/gl.h>
#include <OpenGL/glext.h>

/* Macro context name (CGLContextObj) */
#if !defined(CGL_MACRO_CONTEXT)
#define CGL_MACRO_CONTEXT cgl_ctx
#endif

/* Macro renderer name (GLIContext) */
#if !defined(CGL_MACRO_RENDERER)
#define CGL_MACRO_RENDERER cgl_rend
#endif

#define CGL_MACRO_DECLARE_CONTEXT()  CGLContextObj CGL_MACRO_CONTEXT = CGLGetCurrentContext();

/* Repeated renderer lookups may be avoided by defining CGL_MACRO_CACHE_RENDERER before including CGLMacro.h.
   Note: If you change the value of CGL_MACRO_CONTEXT partway through a function, you will have to
   keep CGL_MACRO_RENDERER up to date with with it's context. */
#if defined(CGL_MACRO_CACHE_RENDERER)
#define CGL_MACRO_DECLARE_RENDERER()  GLIContext CGL_MACRO_RENDERER = CGL_MACRO_CONTEXT->rend;
#define CGL_MACRO_CONTEXT_RENDERER  CGL_MACRO_RENDERER
#else
#define CGL_MACRO_DECLARE_RENDERER()
#define CGL_MACRO_CONTEXT_RENDERER  CGL_MACRO_CONTEXT->rend
#endif

/* Use the following function macro to declare the local CGLMacro variables */
#define CGL_MACRO_DECLARE_VARIABLES() \
	CGL_MACRO_DECLARE_CONTEXT(); \
	CGL_MACRO_DECLARE_RENDERER();

/* This is for converting old non-arb handle definitions to ARB handle definitions for 64 bit compiles */
#define CGL_HANDLE_ARB(handle)	(GLhandleARB)((unsigned long)handle)

/****************** OpenGL 1.1 Macros *****************************/

#define glAccum(op, value) \
	(*(CGL_MACRO_CONTEXT)->disp.accum)(CGL_MACRO_CONTEXT_RENDERER, op, value)

#define glAlphaFunc(func, ref) \
	(*(CGL_MACRO_CONTEXT)->disp.alpha_func)(CGL_MACRO_CONTEXT_RENDERER, func, ref)

#define glAreTexturesResident(n, textures, residences) \
	(*(CGL_MACRO_CONTEXT)->disp.are_textures_resident)(CGL_MACRO_CONTEXT_RENDERER, n, textures, residences)

#define glArrayElement(i) \
	(*(CGL_MACRO_CONTEXT)->disp.array_element)(CGL_MACRO_CONTEXT_RENDERER, i)

#define glBegin(mode) \
	(*(CGL_MACRO_CONTEXT)->disp.begin)(CGL_MACRO_CONTEXT_RENDERER, mode)

#define glBindTexture(target, texture) \
	(*(CGL_MACRO_CONTEXT)->disp.bind_texture)(CGL_MACRO_CONTEXT_RENDERER, target, texture)

#define glBitmap(width, height, xorig, yorig, xmove, ymove, bmap) \
	(*(CGL_MACRO_CONTEXT)->disp.bitmap)(CGL_MACRO_CONTEXT_RENDERER, width, height, xorig, yorig, xmove, ymove, bmap)

#define glBlendFunc(sfactor, dfactor) \
	(*(CGL_MACRO_CONTEXT)->disp.blend_func)(CGL_MACRO_CONTEXT_RENDERER, sfactor, dfactor)

#define glCallList(list) \
	(*(CGL_MACRO_CONTEXT)->disp.call_list)(CGL_MACRO_CONTEXT_RENDERER, list)

#define glCallLists(n, type, lists) \
	(*(CGL_MACRO_CONTEXT)->disp.call_lists)(CGL_MACRO_CONTEXT_RENDERER, n, type, lists)

#define glClear(mask) \
	(*(CGL_MACRO_CONTEXT)->disp.clear)(CGL_MACRO_CONTEXT_RENDERER, mask)

#define glClearAccum(red, green, blue, alpha) \
	(*(CGL_MACRO_CONTEXT)->disp.clear_accum)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue, alpha)

#define glClearColor(red, green, blue, alpha) \
	(*(CGL_MACRO_CONTEXT)->disp.clear_color)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue, alpha)

#define glClearDepth(depth) \
	(*(CGL_MACRO_CONTEXT)->disp.clear_depth)(CGL_MACRO_CONTEXT_RENDERER, depth)

#define glClearIndex(c) \
	(*(CGL_MACRO_CONTEXT)->disp.clear_index)(CGL_MACRO_CONTEXT_RENDERER, c)

#define glClearStencil(s) \
	(*(CGL_MACRO_CONTEXT)->disp.clear_stencil)(CGL_MACRO_CONTEXT_RENDERER, s)

#define glClipPlane(plane, equation) \
	(*(CGL_MACRO_CONTEXT)->disp.clip_plane)(CGL_MACRO_CONTEXT_RENDERER, plane, equation)

#define glColor3b(red, green, blue) \
	(*(CGL_MACRO_CONTEXT)->disp.color3b)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue)

#define glColor3bv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.color3bv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glColor3d(red, green, blue) \
	(*(CGL_MACRO_CONTEXT)->disp.color3d)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue)

#define glColor3dv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.color3dv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glColor3f(red, green, blue) \
	(*(CGL_MACRO_CONTEXT)->disp.color3f)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue)

#define glColor3fv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.color3fv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glColor3i(red, green, blue) \
	(*(CGL_MACRO_CONTEXT)->disp.color3i)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue)

#define glColor3iv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.color3iv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glColor3s(red, green, blue) \
	(*(CGL_MACRO_CONTEXT)->disp.color3s)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue)

#define glColor3sv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.color3sv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glColor3ub(red, green, blue) \
	(*(CGL_MACRO_CONTEXT)->disp.color3ub)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue)

#define glColor3ubv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.color3ubv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glColor3ui(red, green, blue) \
	(*(CGL_MACRO_CONTEXT)->disp.color3ui)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue)

#define glColor3uiv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.color3uiv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glColor3us(red, green, blue) \
	(*(CGL_MACRO_CONTEXT)->disp.color3us)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue)

#define glColor3usv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.color3usv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glColor4b(red, green, blue, alpha) \
	(*(CGL_MACRO_CONTEXT)->disp.color4b)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue, alpha)

#define glColor4bv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.color4bv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glColor4d(red, green, blue, alpha) \
	(*(CGL_MACRO_CONTEXT)->disp.color4d)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue, alpha)

#define glColor4dv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.color4dv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glColor4f(red, green, blue, alpha) \
	(*(CGL_MACRO_CONTEXT)->disp.color4f)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue, alpha)

#define glColor4fv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.color4fv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glColor4i(red, green, blue, alpha) \
	(*(CGL_MACRO_CONTEXT)->disp.color4i)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue, alpha)

#define glColor4iv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.color4iv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glColor4s(red, green, blue, alpha) \
	(*(CGL_MACRO_CONTEXT)->disp.color4s)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue, alpha)

#define glColor4sv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.color4sv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glColor4ub(red, green, blue, alpha) \
	(*(CGL_MACRO_CONTEXT)->disp.color4ub)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue, alpha)

#define glColor4ubv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.color4ubv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glColor4ui(red, green, blue, alpha) \
	(*(CGL_MACRO_CONTEXT)->disp.color4ui)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue, alpha)

#define glColor4uiv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.color4uiv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glColor4us(red, green, blue, alpha) \
	(*(CGL_MACRO_CONTEXT)->disp.color4us)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue, alpha)

#define glColor4usv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.color4usv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glColorMask(red, green, blue, alpha) \
	(*(CGL_MACRO_CONTEXT)->disp.color_mask)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue, alpha)

#define glColorMaterial(face, mode) \
	(*(CGL_MACRO_CONTEXT)->disp.color_material)(CGL_MACRO_CONTEXT_RENDERER, face, mode)

#define glColorPointer(size, type, stride, pointer) \
	(*(CGL_MACRO_CONTEXT)->disp.color_pointer)(CGL_MACRO_CONTEXT_RENDERER, size, type, stride, pointer)

#define glCopyPixels(x, y, width, height, type) \
	(*(CGL_MACRO_CONTEXT)->disp.copy_pixels)(CGL_MACRO_CONTEXT_RENDERER, x, y, width, height, type)

#define glCopyTexImage1D(target, level, internalFormat, x, y, width, border) \
	(*(CGL_MACRO_CONTEXT)->disp.copy_tex_image1D)(CGL_MACRO_CONTEXT_RENDERER, target, level, internalFormat, x, y, width, border)

#define glCopyTexImage2D(target, level, internalFormat, x, y, width, height, border) \
	(*(CGL_MACRO_CONTEXT)->disp.copy_tex_image2D)(CGL_MACRO_CONTEXT_RENDERER, target, level, internalFormat, x, y, width, height, border)

#define glCopyTexSubImage1D(target, level, xoffset, x, y, width) \
	(*(CGL_MACRO_CONTEXT)->disp.copy_tex_sub_image1D)(CGL_MACRO_CONTEXT_RENDERER, target, level, xoffset, x, y, width)

#define glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height) \
	(*(CGL_MACRO_CONTEXT)->disp.copy_tex_sub_image2D)(CGL_MACRO_CONTEXT_RENDERER, target, level, xoffset, yoffset, x, y, width, height)

#define glCullFace(mode) \
	(*(CGL_MACRO_CONTEXT)->disp.cull_face)(CGL_MACRO_CONTEXT_RENDERER, mode)

#define glDeleteLists(list, range) \
	(*(CGL_MACRO_CONTEXT)->disp.delete_lists)(CGL_MACRO_CONTEXT_RENDERER, list, range)

#define glDeleteTextures(n, textures) \
	(*(CGL_MACRO_CONTEXT)->disp.delete_textures)(CGL_MACRO_CONTEXT_RENDERER, n, textures)

#define glDepthFunc(func) \
	(*(CGL_MACRO_CONTEXT)->disp.depth_func)(CGL_MACRO_CONTEXT_RENDERER, func)

#define glDepthMask(flag) \
	(*(CGL_MACRO_CONTEXT)->disp.depth_mask)(CGL_MACRO_CONTEXT_RENDERER, flag)

#define glDepthRange(zNear, zFar) \
	(*(CGL_MACRO_CONTEXT)->disp.depth_range)(CGL_MACRO_CONTEXT_RENDERER, zNear, zFar)

#define glDisable(cap) \
	(*(CGL_MACRO_CONTEXT)->disp.disable)(CGL_MACRO_CONTEXT_RENDERER, cap)

#define glDisableClientState(array) \
	(*(CGL_MACRO_CONTEXT)->disp.disable_client_state)(CGL_MACRO_CONTEXT_RENDERER, array)

#define glDrawArrays(mode, first, count) \
	(*(CGL_MACRO_CONTEXT)->disp.draw_arrays)(CGL_MACRO_CONTEXT_RENDERER, mode, first, count)

#define glDrawBuffer(mode) \
	(*(CGL_MACRO_CONTEXT)->disp.draw_buffer)(CGL_MACRO_CONTEXT_RENDERER, mode)

#define glDrawElements(mode, count, type, indices) \
	(*(CGL_MACRO_CONTEXT)->disp.draw_elements)(CGL_MACRO_CONTEXT_RENDERER, mode, count, type, indices)

#define glDrawPixels(width, height, format, type, pixels) \
	(*(CGL_MACRO_CONTEXT)->disp.draw_pixels)(CGL_MACRO_CONTEXT_RENDERER, width, height, format, type, pixels)

#define glEdgeFlag(flag) \
	(*(CGL_MACRO_CONTEXT)->disp.edge_flag)(CGL_MACRO_CONTEXT_RENDERER, flag)

#define glEdgeFlagPointer(stride, pointer) \
	(*(CGL_MACRO_CONTEXT)->disp.edge_flag_pointer)(CGL_MACRO_CONTEXT_RENDERER, stride, pointer)

#define glEdgeFlagv(flag) \
	(*(CGL_MACRO_CONTEXT)->disp.edge_flagv)(CGL_MACRO_CONTEXT_RENDERER, flag)

#define glEnable(cap) \
	(*(CGL_MACRO_CONTEXT)->disp.enable)(CGL_MACRO_CONTEXT_RENDERER, cap)

#define glEnableClientState(array) \
	(*(CGL_MACRO_CONTEXT)->disp.enable_client_state)(CGL_MACRO_CONTEXT_RENDERER, array)

#define glEnd() \
	(*(CGL_MACRO_CONTEXT)->disp.end)(CGL_MACRO_CONTEXT_RENDERER)

#define glEndList() \
	(*(CGL_MACRO_CONTEXT)->disp.end_list)(CGL_MACRO_CONTEXT_RENDERER)

#define glEvalCoord1d(u) \
	(*(CGL_MACRO_CONTEXT)->disp.eval_coord1d)(CGL_MACRO_CONTEXT_RENDERER, u)

#define glEvalCoord1dv(u) \
	(*(CGL_MACRO_CONTEXT)->disp.eval_coord1dv)(CGL_MACRO_CONTEXT_RENDERER, u)

#define glEvalCoord1f(u) \
	(*(CGL_MACRO_CONTEXT)->disp.eval_coord1f)(CGL_MACRO_CONTEXT_RENDERER, u)

#define glEvalCoord1fv(u) \
	(*(CGL_MACRO_CONTEXT)->disp.eval_coord1fv)(CGL_MACRO_CONTEXT_RENDERER, u)

#define glEvalCoord2d(u, v) \
	(*(CGL_MACRO_CONTEXT)->disp.eval_coord2d)(CGL_MACRO_CONTEXT_RENDERER, u, v)

#define glEvalCoord2dv(u) \
	(*(CGL_MACRO_CONTEXT)->disp.eval_coord2dv)(CGL_MACRO_CONTEXT_RENDERER, u)

#define glEvalCoord2f(u, v) \
	(*(CGL_MACRO_CONTEXT)->disp.eval_coord2f)(CGL_MACRO_CONTEXT_RENDERER, u, v)

#define glEvalCoord2fv(u) \
	(*(CGL_MACRO_CONTEXT)->disp.eval_coord2fv)(CGL_MACRO_CONTEXT_RENDERER, u)

#define glEvalMesh1(mode, i1, i2) \
	(*(CGL_MACRO_CONTEXT)->disp.eval_mesh1)(CGL_MACRO_CONTEXT_RENDERER, mode, i1, i2)

#define glEvalMesh2(mode, i1, i2, j1, j2) \
	(*(CGL_MACRO_CONTEXT)->disp.eval_mesh2)(CGL_MACRO_CONTEXT_RENDERER, mode, i1, i2, j1, j2)

#define glEvalPoint1(i) \
	(*(CGL_MACRO_CONTEXT)->disp.eval_point1)(CGL_MACRO_CONTEXT_RENDERER, i)

#define glEvalPoint2(i, j) \
	(*(CGL_MACRO_CONTEXT)->disp.eval_point2)(CGL_MACRO_CONTEXT_RENDERER, i, j)

#define glFeedbackBuffer(size, type, buffer) \
	(*(CGL_MACRO_CONTEXT)->disp.feedback_buffer)(CGL_MACRO_CONTEXT_RENDERER, size, type, buffer)

#define glFinish() \
	(*(CGL_MACRO_CONTEXT)->disp.finish)(CGL_MACRO_CONTEXT_RENDERER)

#define glFlush() \
	(*(CGL_MACRO_CONTEXT)->disp.flush)(CGL_MACRO_CONTEXT_RENDERER)

#define glFogf(pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.fogf)(CGL_MACRO_CONTEXT_RENDERER, pname, param)

#define glFogfv(pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.fogfv)(CGL_MACRO_CONTEXT_RENDERER, pname, params)

#define glFogi(pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.fogi)(CGL_MACRO_CONTEXT_RENDERER, pname, param)

#define glFogiv(pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.fogiv)(CGL_MACRO_CONTEXT_RENDERER, pname, params)

#define glFrontFace(mode) \
	(*(CGL_MACRO_CONTEXT)->disp.front_face)(CGL_MACRO_CONTEXT_RENDERER, mode)

#define glFrustum(left, right, bottom, top, zNear, zFar) \
	(*(CGL_MACRO_CONTEXT)->disp.frustum)(CGL_MACRO_CONTEXT_RENDERER, left, right, bottom, top, zNear, zFar)

#define glGenLists(range) \
	(*(CGL_MACRO_CONTEXT)->disp.gen_lists)(CGL_MACRO_CONTEXT_RENDERER, range)

#define glGenTextures(n, textures) \
	(*(CGL_MACRO_CONTEXT)->disp.gen_textures)(CGL_MACRO_CONTEXT_RENDERER, n, textures)

#define glGetBooleanv(pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_booleanv)(CGL_MACRO_CONTEXT_RENDERER, pname, params)

#define glGetClipPlane(plane, equation) \
	(*(CGL_MACRO_CONTEXT)->disp.get_clip_plane)(CGL_MACRO_CONTEXT_RENDERER, plane, equation)

#define glGetDoublev(pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_doublev)(CGL_MACRO_CONTEXT_RENDERER, pname, params)

#define glGetError() \
	(*(CGL_MACRO_CONTEXT)->disp.get_error)(CGL_MACRO_CONTEXT_RENDERER)

#define glGetFloatv(pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_floatv)(CGL_MACRO_CONTEXT_RENDERER, pname, params)

#define glGetIntegerv(pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_integerv)(CGL_MACRO_CONTEXT_RENDERER, pname, params)

#define glGetLightfv(light, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_lightfv)(CGL_MACRO_CONTEXT_RENDERER, light, pname, params)

#define glGetLightiv(light, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_lightiv)(CGL_MACRO_CONTEXT_RENDERER, light, pname, params)

#define glGetMapdv(target, query, v) \
	(*(CGL_MACRO_CONTEXT)->disp.get_mapdv)(CGL_MACRO_CONTEXT_RENDERER, target, query, v)

#define glGetMapfv(target, query, v) \
	(*(CGL_MACRO_CONTEXT)->disp.get_mapfv)(CGL_MACRO_CONTEXT_RENDERER, target, query, v)

#define glGetMapiv(target, query, v) \
	(*(CGL_MACRO_CONTEXT)->disp.get_mapiv)(CGL_MACRO_CONTEXT_RENDERER, target, query, v)

#define glGetMaterialfv(face, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_materialfv)(CGL_MACRO_CONTEXT_RENDERER, face, pname, params)

#define glGetMaterialiv(face, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_materialiv)(CGL_MACRO_CONTEXT_RENDERER, face, pname, params)

#define glGetPixelMapfv(map, values) \
	(*(CGL_MACRO_CONTEXT)->disp.get_pixel_mapfv)(CGL_MACRO_CONTEXT_RENDERER, map, values)

#define glGetPixelMapuiv(map, values) \
	(*(CGL_MACRO_CONTEXT)->disp.get_pixel_mapuiv)(CGL_MACRO_CONTEXT_RENDERER, map, values)

#define glGetPixelMapusv(map, values) \
	(*(CGL_MACRO_CONTEXT)->disp.get_pixel_mapusv)(CGL_MACRO_CONTEXT_RENDERER, map, values)

#define glGetPointerv(pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_pointerv)(CGL_MACRO_CONTEXT_RENDERER, pname, params)

#define glGetPolygonStipple(mask) \
	(*(CGL_MACRO_CONTEXT)->disp.get_polygon_stipple)(CGL_MACRO_CONTEXT_RENDERER, mask)

#define glGetString(name) \
	(*(CGL_MACRO_CONTEXT)->disp.get_string)(CGL_MACRO_CONTEXT_RENDERER, name)

#define glGetTexEnvfv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_tex_envfv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glGetTexEnviv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_tex_enviv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glGetTexGendv(coord, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_tex_gendv)(CGL_MACRO_CONTEXT_RENDERER, coord, pname, params)

#define glGetTexGenfv(coord, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_tex_genfv)(CGL_MACRO_CONTEXT_RENDERER, coord, pname, params)

#define glGetTexGeniv(coord, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_tex_geniv)(CGL_MACRO_CONTEXT_RENDERER, coord, pname, params)

#define glGetTexImage(target, level, format, type, pixels) \
	(*(CGL_MACRO_CONTEXT)->disp.get_tex_image)(CGL_MACRO_CONTEXT_RENDERER, target, level, format, type, pixels)

#define glGetTexLevelParameterfv(target, level, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_tex_level_parameterfv)(CGL_MACRO_CONTEXT_RENDERER, target, level, pname, params)

#define glGetTexLevelParameteriv(target, level, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_tex_level_parameteriv)(CGL_MACRO_CONTEXT_RENDERER, target, level, pname, params)

#define glGetTexParameterfv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_tex_parameterfv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glGetTexParameteriv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_tex_parameteriv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glHint(target, mode) \
	(*(CGL_MACRO_CONTEXT)->disp.hint)(CGL_MACRO_CONTEXT_RENDERER, target, mode)

#define glIndexMask(mask) \
	(*(CGL_MACRO_CONTEXT)->disp.index_mask)(CGL_MACRO_CONTEXT_RENDERER, mask)

#define glIndexPointer(type, stride, pointer) \
	(*(CGL_MACRO_CONTEXT)->disp.index_pointer)(CGL_MACRO_CONTEXT_RENDERER, type, stride, pointer)

#define glIndexd(c) \
	(*(CGL_MACRO_CONTEXT)->disp.indexd)(CGL_MACRO_CONTEXT_RENDERER, c)

#define glIndexdv(c) \
	(*(CGL_MACRO_CONTEXT)->disp.indexdv)(CGL_MACRO_CONTEXT_RENDERER, c)

#define glIndexf(c) \
	(*(CGL_MACRO_CONTEXT)->disp.indexf)(CGL_MACRO_CONTEXT_RENDERER, c)

#define glIndexfv(c) \
	(*(CGL_MACRO_CONTEXT)->disp.indexfv)(CGL_MACRO_CONTEXT_RENDERER, c)

#define glIndexi(c) \
	(*(CGL_MACRO_CONTEXT)->disp.indexi)(CGL_MACRO_CONTEXT_RENDERER, c)

#define glIndexiv(c) \
	(*(CGL_MACRO_CONTEXT)->disp.indexiv)(CGL_MACRO_CONTEXT_RENDERER, c)

#define glIndexs(c) \
	(*(CGL_MACRO_CONTEXT)->disp.indexs)(CGL_MACRO_CONTEXT_RENDERER, c)

#define glIndexsv(c) \
	(*(CGL_MACRO_CONTEXT)->disp.indexsv)(CGL_MACRO_CONTEXT_RENDERER, c)

#define glIndexub(c) \
	(*(CGL_MACRO_CONTEXT)->disp.indexub)(CGL_MACRO_CONTEXT_RENDERER, c)

#define glIndexubv(c) \
	(*(CGL_MACRO_CONTEXT)->disp.indexubv)(CGL_MACRO_CONTEXT_RENDERER, c)

#define glInitNames() \
	(*(CGL_MACRO_CONTEXT)->disp.init_names)(CGL_MACRO_CONTEXT_RENDERER)

#define glInterleavedArrays(format, stride, pointer) \
	(*(CGL_MACRO_CONTEXT)->disp.interleaved_arrays)(CGL_MACRO_CONTEXT_RENDERER, format, stride, pointer)

#define glIsEnabled(cap) \
	(*(CGL_MACRO_CONTEXT)->disp.is_enabled)(CGL_MACRO_CONTEXT_RENDERER, cap)

#define glIsList(list) \
	(*(CGL_MACRO_CONTEXT)->disp.is_list)(CGL_MACRO_CONTEXT_RENDERER, list)

#define glIsTexture(texture) \
	(*(CGL_MACRO_CONTEXT)->disp.is_texture)(CGL_MACRO_CONTEXT_RENDERER, texture)

#define glLightModelf(pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.light_modelf)(CGL_MACRO_CONTEXT_RENDERER, pname, param)

#define glLightModelfv(pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.light_modelfv)(CGL_MACRO_CONTEXT_RENDERER, pname, params)

#define glLightModeli(pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.light_modeli)(CGL_MACRO_CONTEXT_RENDERER, pname, param)

#define glLightModeliv(pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.light_modeliv)(CGL_MACRO_CONTEXT_RENDERER, pname, params)

#define glLightf(light, pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.lightf)(CGL_MACRO_CONTEXT_RENDERER, light, pname, param)

#define glLightfv(light, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.lightfv)(CGL_MACRO_CONTEXT_RENDERER, light, pname, params)

#define glLighti(light, pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.lighti)(CGL_MACRO_CONTEXT_RENDERER, light, pname, param)

#define glLightiv(light, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.lightiv)(CGL_MACRO_CONTEXT_RENDERER, light, pname, params)

#define glLineStipple(factor, pattern) \
	(*(CGL_MACRO_CONTEXT)->disp.line_stipple)(CGL_MACRO_CONTEXT_RENDERER, factor, pattern)

#define glLineWidth(width) \
	(*(CGL_MACRO_CONTEXT)->disp.line_width)(CGL_MACRO_CONTEXT_RENDERER, width)

#define glListBase(base) \
	(*(CGL_MACRO_CONTEXT)->disp.list_base)(CGL_MACRO_CONTEXT_RENDERER, base)

#define glLoadIdentity() \
	(*(CGL_MACRO_CONTEXT)->disp.load_identity)(CGL_MACRO_CONTEXT_RENDERER)

#define glLoadMatrixd(m) \
	(*(CGL_MACRO_CONTEXT)->disp.load_matrixd)(CGL_MACRO_CONTEXT_RENDERER, m)

#define glLoadMatrixf(m) \
	(*(CGL_MACRO_CONTEXT)->disp.load_matrixf)(CGL_MACRO_CONTEXT_RENDERER, m)

#define glLoadName(name) \
	(*(CGL_MACRO_CONTEXT)->disp.load_name)(CGL_MACRO_CONTEXT_RENDERER, name)

#define glLogicOp(opcode) \
	(*(CGL_MACRO_CONTEXT)->disp.logic_op)(CGL_MACRO_CONTEXT_RENDERER, opcode)

#define glMap1d(target, u1, u2, stride, order, points) \
	(*(CGL_MACRO_CONTEXT)->disp.map1d)(CGL_MACRO_CONTEXT_RENDERER, target, u1, u2, stride, order, points)

#define glMap1f(target, u1, u2, stride, order, points) \
	(*(CGL_MACRO_CONTEXT)->disp.map1f)(CGL_MACRO_CONTEXT_RENDERER, target, u1, u2, stride, order, points)

#define glMap2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points) \
	(*(CGL_MACRO_CONTEXT)->disp.map2d)(CGL_MACRO_CONTEXT_RENDERER, target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points)

#define glMap2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points) \
	(*(CGL_MACRO_CONTEXT)->disp.map2f)(CGL_MACRO_CONTEXT_RENDERER, target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points)

#define glMapGrid1d(un, u1, u2) \
	(*(CGL_MACRO_CONTEXT)->disp.map_grid1d)(CGL_MACRO_CONTEXT_RENDERER, un, u1, u2)

#define glMapGrid1f(un, u1, u2) \
	(*(CGL_MACRO_CONTEXT)->disp.map_grid1f)(CGL_MACRO_CONTEXT_RENDERER, un, u1, u2)

#define glMapGrid2d(un, u1, u2, vn, v1, v2) \
	(*(CGL_MACRO_CONTEXT)->disp.map_grid2d)(CGL_MACRO_CONTEXT_RENDERER, un, u1, u2, vn, v1, v2)

#define glMapGrid2f(un, u1, u2, vn, v1, v2) \
	(*(CGL_MACRO_CONTEXT)->disp.map_grid2f)(CGL_MACRO_CONTEXT_RENDERER, un, u1, u2, vn, v1, v2)

#define glMaterialf(face, pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.materialf)(CGL_MACRO_CONTEXT_RENDERER, face, pname, param)

#define glMaterialfv(face, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.materialfv)(CGL_MACRO_CONTEXT_RENDERER, face, pname, params)

#define glMateriali(face, pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.materiali)(CGL_MACRO_CONTEXT_RENDERER, face, pname, param)

#define glMaterialiv(face, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.materialiv)(CGL_MACRO_CONTEXT_RENDERER, face, pname, params)

#define glMatrixMode(mode) \
	(*(CGL_MACRO_CONTEXT)->disp.matrix_mode)(CGL_MACRO_CONTEXT_RENDERER, mode)

#define glMultMatrixd(m) \
	(*(CGL_MACRO_CONTEXT)->disp.mult_matrixd)(CGL_MACRO_CONTEXT_RENDERER, m)

#define glMultMatrixf(m) \
	(*(CGL_MACRO_CONTEXT)->disp.mult_matrixf)(CGL_MACRO_CONTEXT_RENDERER, m)

#define glNewList(list, mode) \
	(*(CGL_MACRO_CONTEXT)->disp.new_list)(CGL_MACRO_CONTEXT_RENDERER, list, mode)

#define glNormal3b(nx, ny, nz) \
	(*(CGL_MACRO_CONTEXT)->disp.normal3b)(CGL_MACRO_CONTEXT_RENDERER, nx, ny, nz)

#define glNormal3bv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.normal3bv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glNormal3d(nx, ny, nz) \
	(*(CGL_MACRO_CONTEXT)->disp.normal3d)(CGL_MACRO_CONTEXT_RENDERER, nx, ny, nz)

#define glNormal3dv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.normal3dv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glNormal3f(nx, ny, nz) \
	(*(CGL_MACRO_CONTEXT)->disp.normal3f)(CGL_MACRO_CONTEXT_RENDERER, nx, ny, nz)

#define glNormal3fv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.normal3fv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glNormal3i(nx, ny, nz) \
	(*(CGL_MACRO_CONTEXT)->disp.normal3i)(CGL_MACRO_CONTEXT_RENDERER, nx, ny, nz)

#define glNormal3iv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.normal3iv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glNormal3s(nx, ny, nz) \
	(*(CGL_MACRO_CONTEXT)->disp.normal3s)(CGL_MACRO_CONTEXT_RENDERER, nx, ny, nz)

#define glNormal3sv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.normal3sv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glNormalPointer(type, stride, pointer) \
	(*(CGL_MACRO_CONTEXT)->disp.normal_pointer)(CGL_MACRO_CONTEXT_RENDERER, type, stride, pointer)

#define glOrtho(left, right, bottom, top, zNear, zFar) \
	(*(CGL_MACRO_CONTEXT)->disp.ortho)(CGL_MACRO_CONTEXT_RENDERER, left, right, bottom, top, zNear, zFar)

#define glPassThrough(token) \
	(*(CGL_MACRO_CONTEXT)->disp.pass_through)(CGL_MACRO_CONTEXT_RENDERER, token)

#define glPixelMapfv(map, mapsize, values) \
	(*(CGL_MACRO_CONTEXT)->disp.pixel_mapfv)(CGL_MACRO_CONTEXT_RENDERER, map, mapsize, values)

#define glPixelMapuiv(map, mapsize, values) \
	(*(CGL_MACRO_CONTEXT)->disp.pixel_mapuiv)(CGL_MACRO_CONTEXT_RENDERER, map, mapsize, values)

#define glPixelMapusv(map, mapsize, values) \
	(*(CGL_MACRO_CONTEXT)->disp.pixel_mapusv)(CGL_MACRO_CONTEXT_RENDERER, map, mapsize, values)

#define glPixelStoref(pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.pixel_storef)(CGL_MACRO_CONTEXT_RENDERER, pname, param)

#define glPixelStorei(pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.pixel_storei)(CGL_MACRO_CONTEXT_RENDERER, pname, param)

#define glPixelTransferf(pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.pixel_transferf)(CGL_MACRO_CONTEXT_RENDERER, pname, param)

#define glPixelTransferi(pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.pixel_transferi)(CGL_MACRO_CONTEXT_RENDERER, pname, param)

#define glPixelZoom(xfactor, yfactor) \
	(*(CGL_MACRO_CONTEXT)->disp.pixel_zoom)(CGL_MACRO_CONTEXT_RENDERER, xfactor, yfactor)

#define glPointSize(size) \
	(*(CGL_MACRO_CONTEXT)->disp.point_size)(CGL_MACRO_CONTEXT_RENDERER, size)

#define glPolygonMode(face, mode) \
	(*(CGL_MACRO_CONTEXT)->disp.polygon_mode)(CGL_MACRO_CONTEXT_RENDERER, face, mode)

#define glPolygonOffset(factor, units) \
	(*(CGL_MACRO_CONTEXT)->disp.polygon_offset)(CGL_MACRO_CONTEXT_RENDERER, factor, units)

#define glPolygonStipple(mask) \
	(*(CGL_MACRO_CONTEXT)->disp.polygon_stipple)(CGL_MACRO_CONTEXT_RENDERER, mask)

#define glPopAttrib() \
	(*(CGL_MACRO_CONTEXT)->disp.pop_attrib)(CGL_MACRO_CONTEXT_RENDERER)

#define glPopClientAttrib() \
	(*(CGL_MACRO_CONTEXT)->disp.pop_client_attrib)(CGL_MACRO_CONTEXT_RENDERER)

#define glPopMatrix() \
	(*(CGL_MACRO_CONTEXT)->disp.pop_matrix)(CGL_MACRO_CONTEXT_RENDERER)

#define glPopName() \
	(*(CGL_MACRO_CONTEXT)->disp.pop_name)(CGL_MACRO_CONTEXT_RENDERER)

#define glPrioritizeTextures(n, textures, priorities) \
	(*(CGL_MACRO_CONTEXT)->disp.prioritize_textures)(CGL_MACRO_CONTEXT_RENDERER, n, textures, priorities)

#define glPushAttrib(mask) \
	(*(CGL_MACRO_CONTEXT)->disp.push_attrib)(CGL_MACRO_CONTEXT_RENDERER, mask)

#define glPushClientAttrib(mask) \
	(*(CGL_MACRO_CONTEXT)->disp.push_client_attrib)(CGL_MACRO_CONTEXT_RENDERER, mask)

#define glPushMatrix() \
	(*(CGL_MACRO_CONTEXT)->disp.push_matrix)(CGL_MACRO_CONTEXT_RENDERER)

#define glPushName(name) \
	(*(CGL_MACRO_CONTEXT)->disp.push_name)(CGL_MACRO_CONTEXT_RENDERER, name)

#define glRasterPos2d(x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos2d)(CGL_MACRO_CONTEXT_RENDERER, x, y)

#define glRasterPos2dv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos2dv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glRasterPos2f(x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos2f)(CGL_MACRO_CONTEXT_RENDERER, x, y)

#define glRasterPos2fv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos2fv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glRasterPos2i(x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos2i)(CGL_MACRO_CONTEXT_RENDERER, x, y)

#define glRasterPos2iv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos2iv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glRasterPos2s(x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos2s)(CGL_MACRO_CONTEXT_RENDERER, x, y)

#define glRasterPos2sv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos2sv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glRasterPos3d(x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos3d)(CGL_MACRO_CONTEXT_RENDERER, x, y, z)

#define glRasterPos3dv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos3dv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glRasterPos3f(x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos3f)(CGL_MACRO_CONTEXT_RENDERER, x, y, z)

#define glRasterPos3fv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos3fv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glRasterPos3i(x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos3i)(CGL_MACRO_CONTEXT_RENDERER, x, y, z)

#define glRasterPos3iv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos3iv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glRasterPos3s(x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos3s)(CGL_MACRO_CONTEXT_RENDERER, x, y, z)

#define glRasterPos3sv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos3sv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glRasterPos4d(x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos4d)(CGL_MACRO_CONTEXT_RENDERER, x, y, z, w)

#define glRasterPos4dv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos4dv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glRasterPos4f(x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos4f)(CGL_MACRO_CONTEXT_RENDERER, x, y, z, w)

#define glRasterPos4fv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos4fv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glRasterPos4i(x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos4i)(CGL_MACRO_CONTEXT_RENDERER, x, y, z, w)

#define glRasterPos4iv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos4iv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glRasterPos4s(x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos4s)(CGL_MACRO_CONTEXT_RENDERER, x, y, z, w)

#define glRasterPos4sv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.raster_pos4sv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glReadBuffer(mode) \
	(*(CGL_MACRO_CONTEXT)->disp.read_buffer)(CGL_MACRO_CONTEXT_RENDERER, mode)

#define glReadPixels(x, y, width, height, format, type, pixels) \
	(*(CGL_MACRO_CONTEXT)->disp.read_pixels)(CGL_MACRO_CONTEXT_RENDERER, x, y, width, height, format, type, pixels)

#define glRectd(x1, y1, x2, y2) \
	(*(CGL_MACRO_CONTEXT)->disp.rectd)(CGL_MACRO_CONTEXT_RENDERER, x1, y1, x2, y2)

#define glRectdv(v1, v2) \
	(*(CGL_MACRO_CONTEXT)->disp.rectdv)(CGL_MACRO_CONTEXT_RENDERER, v1, v2)

#define glRectf(x1, y1, x2, y2) \
	(*(CGL_MACRO_CONTEXT)->disp.rectf)(CGL_MACRO_CONTEXT_RENDERER, x1, y1, x2, y2)

#define glRectfv(v1, v2) \
	(*(CGL_MACRO_CONTEXT)->disp.rectfv)(CGL_MACRO_CONTEXT_RENDERER, v1, v2)

#define glRecti(x1, y1, x2, y2) \
	(*(CGL_MACRO_CONTEXT)->disp.recti)(CGL_MACRO_CONTEXT_RENDERER, x1, y1, x2, y2)

#define glRectiv(v1, v2) \
	(*(CGL_MACRO_CONTEXT)->disp.rectiv)(CGL_MACRO_CONTEXT_RENDERER, v1, v2)

#define glRects(x1, y1, x2, y2) \
	(*(CGL_MACRO_CONTEXT)->disp.rects)(CGL_MACRO_CONTEXT_RENDERER, x1, y1, x2, y2)

#define glRectsv(v1, v2) \
	(*(CGL_MACRO_CONTEXT)->disp.rectsv)(CGL_MACRO_CONTEXT_RENDERER, v1, v2)

#define glRenderMode(mode) \
	(*(CGL_MACRO_CONTEXT)->disp.render_mode)(CGL_MACRO_CONTEXT_RENDERER, mode)

#define glRotated(angle, x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.rotated)(CGL_MACRO_CONTEXT_RENDERER, angle, x, y, z)

#define glRotatef(angle, x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.rotatef)(CGL_MACRO_CONTEXT_RENDERER, angle, x, y, z)

#define glScaled(x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.scaled)(CGL_MACRO_CONTEXT_RENDERER, x, y, z)

#define glScalef(x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.scalef)(CGL_MACRO_CONTEXT_RENDERER, x, y, z)

#define glScissor(x, y, width, height) \
	(*(CGL_MACRO_CONTEXT)->disp.scissor)(CGL_MACRO_CONTEXT_RENDERER, x, y, width, height)

#define glSelectBuffer(size, buffer) \
	(*(CGL_MACRO_CONTEXT)->disp.select_buffer)(CGL_MACRO_CONTEXT_RENDERER, size, buffer)

#define glShadeModel(mode) \
	(*(CGL_MACRO_CONTEXT)->disp.shade_model)(CGL_MACRO_CONTEXT_RENDERER, mode)

#define glStencilFunc(func, ref, mask) \
	(*(CGL_MACRO_CONTEXT)->disp.stencil_func)(CGL_MACRO_CONTEXT_RENDERER, func, ref, mask)

#define glStencilMask(mask) \
	(*(CGL_MACRO_CONTEXT)->disp.stencil_mask)(CGL_MACRO_CONTEXT_RENDERER, mask)

#define glStencilOp(fail, zfail, zpass) \
	(*(CGL_MACRO_CONTEXT)->disp.stencil_op)(CGL_MACRO_CONTEXT_RENDERER, fail, zfail, zpass)

#define glTexCoord1d(s) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord1d)(CGL_MACRO_CONTEXT_RENDERER, s)

#define glTexCoord1dv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord1dv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glTexCoord1f(s) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord1f)(CGL_MACRO_CONTEXT_RENDERER, s)

#define glTexCoord1fv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord1fv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glTexCoord1i(s) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord1i)(CGL_MACRO_CONTEXT_RENDERER, s)

#define glTexCoord1iv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord1iv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glTexCoord1s(s) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord1s)(CGL_MACRO_CONTEXT_RENDERER, s)

#define glTexCoord1sv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord1sv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glTexCoord2d(s, t) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord2d)(CGL_MACRO_CONTEXT_RENDERER, s, t)

#define glTexCoord2dv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord2dv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glTexCoord2f(s, t) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord2f)(CGL_MACRO_CONTEXT_RENDERER, s, t)

#define glTexCoord2fv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord2fv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glTexCoord2i(s, t) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord2i)(CGL_MACRO_CONTEXT_RENDERER, s, t)

#define glTexCoord2iv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord2iv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glTexCoord2s(s, t) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord2s)(CGL_MACRO_CONTEXT_RENDERER, s, t)

#define glTexCoord2sv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord2sv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glTexCoord3d(s, t, r) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord3d)(CGL_MACRO_CONTEXT_RENDERER, s, t, r)

#define glTexCoord3dv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord3dv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glTexCoord3f(s, t, r) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord3f)(CGL_MACRO_CONTEXT_RENDERER, s, t, r)

#define glTexCoord3fv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord3fv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glTexCoord3i(s, t, r) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord3i)(CGL_MACRO_CONTEXT_RENDERER, s, t, r)

#define glTexCoord3iv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord3iv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glTexCoord3s(s, t, r) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord3s)(CGL_MACRO_CONTEXT_RENDERER, s, t, r)

#define glTexCoord3sv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord3sv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glTexCoord4d(s, t, r, q) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord4d)(CGL_MACRO_CONTEXT_RENDERER, s, t, r, q)

#define glTexCoord4dv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord4dv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glTexCoord4f(s, t, r, q) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord4f)(CGL_MACRO_CONTEXT_RENDERER, s, t, r, q)

#define glTexCoord4fv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord4fv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glTexCoord4i(s, t, r, q) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord4i)(CGL_MACRO_CONTEXT_RENDERER, s, t, r, q)

#define glTexCoord4iv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord4iv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glTexCoord4s(s, t, r, q) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord4s)(CGL_MACRO_CONTEXT_RENDERER, s, t, r, q)

#define glTexCoord4sv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord4sv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glTexCoordPointer(size, type, stride, pointer) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_coord_pointer)(CGL_MACRO_CONTEXT_RENDERER, size, type, stride, pointer)

#define glTexEnvf(target, pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_envf)(CGL_MACRO_CONTEXT_RENDERER, target, pname, param)

#define glTexEnvfv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_envfv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glTexEnvi(target, pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_envi)(CGL_MACRO_CONTEXT_RENDERER, target, pname, param)

#define glTexEnviv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_enviv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glTexGend(coord, pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_gend)(CGL_MACRO_CONTEXT_RENDERER, coord, pname, param)

#define glTexGendv(coord, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_gendv)(CGL_MACRO_CONTEXT_RENDERER, coord, pname, params)

#define glTexGenf(coord, pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_genf)(CGL_MACRO_CONTEXT_RENDERER, coord, pname, param)

#define glTexGenfv(coord, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_genfv)(CGL_MACRO_CONTEXT_RENDERER, coord, pname, params)

#define glTexGeni(coord, pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_geni)(CGL_MACRO_CONTEXT_RENDERER, coord, pname, param)

#define glTexGeniv(coord, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_geniv)(CGL_MACRO_CONTEXT_RENDERER, coord, pname, params)

#define glTexImage1D(target, level, internalformat, width, border, format, type, pixels) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_image1D)(CGL_MACRO_CONTEXT_RENDERER, target, level, internalformat, width, border, format, type, pixels)

#define glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_image2D)(CGL_MACRO_CONTEXT_RENDERER, target, level, internalformat, width, height, border, format, type, pixels)

#define glTexParameterf(target, pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_parameterf)(CGL_MACRO_CONTEXT_RENDERER, target, pname, param)

#define glTexParameterfv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_parameterfv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glTexParameteri(target, pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_parameteri)(CGL_MACRO_CONTEXT_RENDERER, target, pname, param)

#define glTexParameteriv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_parameteriv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glTexSubImage1D(target, level, xoffset, width, format, type, pixels) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_sub_image1D)(CGL_MACRO_CONTEXT_RENDERER, target, level, xoffset, width, format, type, pixels)

#define glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_sub_image2D)(CGL_MACRO_CONTEXT_RENDERER, target, level, xoffset, yoffset, width, height, format, type, pixels)

#define glTranslated(x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.translated)(CGL_MACRO_CONTEXT_RENDERER, x, y, z)

#define glTranslatef(x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.translatef)(CGL_MACRO_CONTEXT_RENDERER, x, y, z)

#define glVertex2d(x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex2d)(CGL_MACRO_CONTEXT_RENDERER, x, y)

#define glVertex2dv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex2dv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glVertex2f(x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex2f)(CGL_MACRO_CONTEXT_RENDERER, x, y)

#define glVertex2fv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex2fv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glVertex2i(x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex2i)(CGL_MACRO_CONTEXT_RENDERER, x, y)

#define glVertex2iv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex2iv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glVertex2s(x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex2s)(CGL_MACRO_CONTEXT_RENDERER, x, y)

#define glVertex2sv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex2sv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glVertex3d(x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex3d)(CGL_MACRO_CONTEXT_RENDERER, x, y, z)

#define glVertex3dv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex3dv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glVertex3f(x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex3f)(CGL_MACRO_CONTEXT_RENDERER, x, y, z)

#define glVertex3fv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex3fv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glVertex3i(x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex3i)(CGL_MACRO_CONTEXT_RENDERER, x, y, z)

#define glVertex3iv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex3iv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glVertex3s(x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex3s)(CGL_MACRO_CONTEXT_RENDERER, x, y, z)

#define glVertex3sv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex3sv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glVertex4d(x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex4d)(CGL_MACRO_CONTEXT_RENDERER, x, y, z, w)

#define glVertex4dv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex4dv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glVertex4f(x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex4f)(CGL_MACRO_CONTEXT_RENDERER, x, y, z, w)

#define glVertex4fv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex4fv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glVertex4i(x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex4i)(CGL_MACRO_CONTEXT_RENDERER, x, y, z, w)

#define glVertex4iv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex4iv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glVertex4s(x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex4s)(CGL_MACRO_CONTEXT_RENDERER, x, y, z, w)

#define glVertex4sv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex4sv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glVertexPointer(size, type, stride, pointer) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_pointer)(CGL_MACRO_CONTEXT_RENDERER, size, type, stride, pointer)

#define glViewport(x, y, width, height) \
	(*(CGL_MACRO_CONTEXT)->disp.viewport)(CGL_MACRO_CONTEXT_RENDERER, x, y, width, height)

/****************** OpenGL 1.2 ************************************/

#define glBlendColor(red, green, blue, alpha) \
	(*(CGL_MACRO_CONTEXT)->disp.blend_color)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue, alpha)

#define glBlendEquation(mode) \
	(*(CGL_MACRO_CONTEXT)->disp.blend_equation)(CGL_MACRO_CONTEXT_RENDERER, mode)

#define glDrawRangeElements(mode, start, end, count, type, indices) \
	(*(CGL_MACRO_CONTEXT)->disp.draw_range_elements)(CGL_MACRO_CONTEXT_RENDERER, mode, start, end, count, type, indices)

#define glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, data) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_image3D)(CGL_MACRO_CONTEXT_RENDERER, target, level, internalformat, width, height, depth, border, format, type, data)

#define glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_sub_image3D)(CGL_MACRO_CONTEXT_RENDERER, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels)

#define glCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height) \
	(*(CGL_MACRO_CONTEXT)->disp.copy_tex_sub_image3D)(CGL_MACRO_CONTEXT_RENDERER, target, level, xoffset, yoffset, zoffset, x, y, width, height)

/****************** OpenGL 1.2 Imaging Subset *********************/

#define glColorTable(target, internalformat, width, format, type, table) \
	(*(CGL_MACRO_CONTEXT)->disp.color_table)(CGL_MACRO_CONTEXT_RENDERER, target, internalformat, width, format, type, table)

#define glColorTableParameterfv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.color_table_parameterfv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glColorTableParameteriv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.color_table_parameteriv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glCopyColorTable(target, internalformat, x, y, width) \
	(*(CGL_MACRO_CONTEXT)->disp.copy_color_table)(CGL_MACRO_CONTEXT_RENDERER, target, internalformat, x, y, width)

#define glGetColorTable(target, format, type, table) \
	(*(CGL_MACRO_CONTEXT)->disp.get_color_table)(CGL_MACRO_CONTEXT_RENDERER, target, format, type, table)

#define glGetColorTableParameterfv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_color_table_parameterfv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glGetColorTableParameteriv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_color_table_parameteriv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glColorSubTable(target, start, count, format, type, data) \
	(*(CGL_MACRO_CONTEXT)->disp.color_sub_table)(CGL_MACRO_CONTEXT_RENDERER, target, start, count, format, type, data)

#define glCopyColorSubTable(target, start, x, y, width) \
	(*(CGL_MACRO_CONTEXT)->disp.copy_color_sub_table)(CGL_MACRO_CONTEXT_RENDERER, target, start, x, y, width)

#define glConvolutionFilter1D(target, internalformat, width, format, type, image) \
	(*(CGL_MACRO_CONTEXT)->disp.convolution_filter1D)(CGL_MACRO_CONTEXT_RENDERER, target, internalformat, width, format, type, image)

#define glConvolutionFilter2D(target, internalformat, width, height, format, type, image) \
	(*(CGL_MACRO_CONTEXT)->disp.convolution_filter2D)(CGL_MACRO_CONTEXT_RENDERER, target, internalformat, width, height, format, type, image)

#define glConvolutionParameterf(target, pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.convolution_parameterf)(CGL_MACRO_CONTEXT_RENDERER, target, pname, param)

#define glConvolutionParameterfv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.convolution_parameterfv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glConvolutionParameteri(target, pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.convolution_parameteri)(CGL_MACRO_CONTEXT_RENDERER, target, pname, param)

#define glConvolutionParameteriv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.convolution_parameteriv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glCopyConvolutionFilter1D(target, internalformat, x, y, width) \
	(*(CGL_MACRO_CONTEXT)->disp.copy_convolution_filter1D)(CGL_MACRO_CONTEXT_RENDERER, target, internalformat, x, y, width)

#define glCopyConvolutionFilter2D(target, internalformat, x, y, width, height) \
	(*(CGL_MACRO_CONTEXT)->disp.copy_convolution_filter2D)(CGL_MACRO_CONTEXT_RENDERER, target, internalformat, x, y, width, height)

#define glGetConvolutionFilter(target, format, type, image) \
	(*(CGL_MACRO_CONTEXT)->disp.get_convolution_filter)(CGL_MACRO_CONTEXT_RENDERER, target, format, type, image)

#define glGetConvolutionParameterfv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_convolution_parameterfv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glGetConvolutionParameteriv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_convolution_parameteriv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glGetSeparableFilter(target, format, type, row, column, span) \
	(*(CGL_MACRO_CONTEXT)->disp.get_separable_filter)(CGL_MACRO_CONTEXT_RENDERER, target, format, type, row, column, span)

#define glSeparableFilter2D(target, internalformat, width, height, format, type, row, column) \
	(*(CGL_MACRO_CONTEXT)->disp.separable_filter2D)(CGL_MACRO_CONTEXT_RENDERER, target, internalformat, width, height, format, type, row, column)

#define glGetHistogram(target, reset, format, type, values) \
	(*(CGL_MACRO_CONTEXT)->disp.get_histogram)(CGL_MACRO_CONTEXT_RENDERER, target, reset, format, type, values)

#define glGetHistogramParameterfv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_histogram_parameterfv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glGetHistogramParameteriv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_histogram_parameteriv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glGetMinmax(target, reset, format, type, values) \
	(*(CGL_MACRO_CONTEXT)->disp.get_minmax)(CGL_MACRO_CONTEXT_RENDERER, target, reset, format, type, values)

#define glGetMinmaxParameterfv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_minmax_parameterfv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glGetMinmaxParameteriv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_minmax_parameteriv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glHistogram(target, width, internalformat, sink) \
	(*(CGL_MACRO_CONTEXT)->disp.histogram)(CGL_MACRO_CONTEXT_RENDERER, target, width, internalformat, sink)

#define glMinmax(target, internalformat, sink) \
	(*(CGL_MACRO_CONTEXT)->disp.minmax)(CGL_MACRO_CONTEXT_RENDERER, target, internalformat, sink)

#define glResetHistogram(target) \
	(*(CGL_MACRO_CONTEXT)->disp.reset_histogram)(CGL_MACRO_CONTEXT_RENDERER, target)

#define glResetMinmax(target) \
	(*(CGL_MACRO_CONTEXT)->disp.reset_minmax)(CGL_MACRO_CONTEXT_RENDERER, target)

/****************** OpenGL 1.3 ************************************/

#define glClientActiveTexture(target) \
	(*(CGL_MACRO_CONTEXT)->disp.client_active_texture)(CGL_MACRO_CONTEXT_RENDERER, target)

#define glActiveTexture(target) \
	(*(CGL_MACRO_CONTEXT)->disp.active_texture)(CGL_MACRO_CONTEXT_RENDERER, target)

#define glMultiTexCoord1d(target, s) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord1d)(CGL_MACRO_CONTEXT_RENDERER, target, s)

#define glMultiTexCoord1dv(target, v) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord1dv)(CGL_MACRO_CONTEXT_RENDERER, target, v)

#define glMultiTexCoord1f(target, s) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord1f)(CGL_MACRO_CONTEXT_RENDERER, target, s)

#define glMultiTexCoord1fv(target, v) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord1fv)(CGL_MACRO_CONTEXT_RENDERER, target, v)

#define glMultiTexCoord1i(target, s) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord1i)(CGL_MACRO_CONTEXT_RENDERER, target, s)

#define glMultiTexCoord1iv(target, v) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord1iv)(CGL_MACRO_CONTEXT_RENDERER, target, v)

#define glMultiTexCoord1s(target, s) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord1s)(CGL_MACRO_CONTEXT_RENDERER, target, s)

#define glMultiTexCoord1sv(target, v) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord1sv)(CGL_MACRO_CONTEXT_RENDERER, target, v)

#define glMultiTexCoord2d(target, s, t) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord2d)(CGL_MACRO_CONTEXT_RENDERER, target, s, t)

#define glMultiTexCoord2dv(target, v) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord2dv)(CGL_MACRO_CONTEXT_RENDERER, target, v)

#define glMultiTexCoord2f(target, s, t) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord2f)(CGL_MACRO_CONTEXT_RENDERER, target, s, t)

#define glMultiTexCoord2fv(target, v) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord2fv)(CGL_MACRO_CONTEXT_RENDERER, target, v)

#define glMultiTexCoord2i(target, s, t) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord2i)(CGL_MACRO_CONTEXT_RENDERER, target, s, t)

#define glMultiTexCoord2iv(target, v) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord2iv)(CGL_MACRO_CONTEXT_RENDERER, target, v)

#define glMultiTexCoord2s(target, s, t) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord2s)(CGL_MACRO_CONTEXT_RENDERER, target, s, t)

#define glMultiTexCoord2sv(target, v) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord2sv)(CGL_MACRO_CONTEXT_RENDERER, target, v)

#define glMultiTexCoord3d(target, s, t, r) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord3d)(CGL_MACRO_CONTEXT_RENDERER, target, s, t, r)

#define glMultiTexCoord3dv(target, v) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord3dv)(CGL_MACRO_CONTEXT_RENDERER, target, v)

#define glMultiTexCoord3f(target, s, t, r) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord3f)(CGL_MACRO_CONTEXT_RENDERER, target, s, t, r)

#define glMultiTexCoord3fv(target, v) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord3fv)(CGL_MACRO_CONTEXT_RENDERER, target, v)

#define glMultiTexCoord3i(target, s, t, r) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord3i)(CGL_MACRO_CONTEXT_RENDERER, target, s, t, r)

#define glMultiTexCoord3iv(target, v) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord3iv)(CGL_MACRO_CONTEXT_RENDERER, target, v)

#define glMultiTexCoord3s(target, s, t, r) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord3s)(CGL_MACRO_CONTEXT_RENDERER, target, s, t, r)

#define glMultiTexCoord3sv(target, v) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord3sv)(CGL_MACRO_CONTEXT_RENDERER, target, v)

#define glMultiTexCoord4d(target, s, t, r, q) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord4d)(CGL_MACRO_CONTEXT_RENDERER, target, s, t, r, q)

#define glMultiTexCoord4dv(target, v) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord4dv)(CGL_MACRO_CONTEXT_RENDERER, target, v)

#define glMultiTexCoord4f(target, s, t, r, q) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord4f)(CGL_MACRO_CONTEXT_RENDERER, target, s, t, r, q)

#define glMultiTexCoord4fv(target, v) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord4fv)(CGL_MACRO_CONTEXT_RENDERER, target, v)

#define glMultiTexCoord4i(target, s, t, r, q) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord4i)(CGL_MACRO_CONTEXT_RENDERER, target, s, t, r, q)

#define glMultiTexCoord4iv(target, v) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord4iv)(CGL_MACRO_CONTEXT_RENDERER, target, v)

#define glMultiTexCoord4s(target, s, t, r, q) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord4s)(CGL_MACRO_CONTEXT_RENDERER, target, s, t, r, q)

#define glMultiTexCoord4sv(target, v) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_tex_coord4sv)(CGL_MACRO_CONTEXT_RENDERER, target, v)

#define glSampleCoverage(value, invert) \
	(*(CGL_MACRO_CONTEXT)->disp.sample_coverage)(CGL_MACRO_CONTEXT_RENDERER, value, invert)

#define glLoadTransposeMatrixf(m) \
	(*(CGL_MACRO_CONTEXT)->disp.load_transpose_matrixf)(CGL_MACRO_CONTEXT_RENDERER, m)

#define glLoadTransposeMatrixd(m) \
	(*(CGL_MACRO_CONTEXT)->disp.load_transpose_matrixd)(CGL_MACRO_CONTEXT_RENDERER, m)

#define glMultTransposeMatrixf(m) \
	(*(CGL_MACRO_CONTEXT)->disp.mult_transpose_matrixf)(CGL_MACRO_CONTEXT_RENDERER, m)

#define glMultTransposeMatrixd(m) \
	(*(CGL_MACRO_CONTEXT)->disp.mult_transpose_matrixd)(CGL_MACRO_CONTEXT_RENDERER, m)

#define glCompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data) \
	(*(CGL_MACRO_CONTEXT)->disp.compressed_tex_image3D)(CGL_MACRO_CONTEXT_RENDERER, target, level, internalformat, width, height, depth, border, imageSize, data)

#define glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data) \
	(*(CGL_MACRO_CONTEXT)->disp.compressed_tex_image2D)(CGL_MACRO_CONTEXT_RENDERER, target, level, internalformat, width, height, border, imageSize, data)

#define glCompressedTexImage1D(target, level, internalformat, width, border, imageSize, data) \
	(*(CGL_MACRO_CONTEXT)->disp.compressed_tex_image1D)(CGL_MACRO_CONTEXT_RENDERER, target, level, internalformat, width, border, imageSize, data)

#define glCompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data) \
	(*(CGL_MACRO_CONTEXT)->disp.compressed_tex_sub_image3D)(CGL_MACRO_CONTEXT_RENDERER, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data)

#define glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data) \
	(*(CGL_MACRO_CONTEXT)->disp.compressed_tex_sub_image2D)(CGL_MACRO_CONTEXT_RENDERER, target, level, xoffset, yoffset, width, height, format, imageSize, data)

#define glCompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data) \
	(*(CGL_MACRO_CONTEXT)->disp.compressed_tex_sub_image1D)(CGL_MACRO_CONTEXT_RENDERER, target, level, xoffset, width, format, imageSize, data)

#define glGetCompressedTexImage(target, level, img) \
	(*(CGL_MACRO_CONTEXT)->disp.get_compressed_tex_image)(CGL_MACRO_CONTEXT_RENDERER, target, level, img)

/****************** OpenGL 1.4 ************************************/

#define glFogCoordf(coord) \
	(*(CGL_MACRO_CONTEXT)->disp.fog_coordf)(CGL_MACRO_CONTEXT_RENDERER, coord)

#define glFogCoordfv(coord) \
	(*(CGL_MACRO_CONTEXT)->disp.fog_coordfv)(CGL_MACRO_CONTEXT_RENDERER, coord)

#define glFogCoordd(coord) \
	(*(CGL_MACRO_CONTEXT)->disp.fog_coordd)(CGL_MACRO_CONTEXT_RENDERER, coord)

#define glFogCoorddv(coord) \
	(*(CGL_MACRO_CONTEXT)->disp.fog_coorddv)(CGL_MACRO_CONTEXT_RENDERER,coord)

#define glFogCoordPointer(type, stride, pointer) \
	(*(CGL_MACRO_CONTEXT)->disp.fog_coord_pointer)(CGL_MACRO_CONTEXT_RENDERER, type, stride, pointer)

#define glSecondaryColor3b(red, green, blue) \
	(*(CGL_MACRO_CONTEXT)->disp.secondary_color3b)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue)

#define glSecondaryColor3bv(components) \
	(*(CGL_MACRO_CONTEXT)->disp.secondary_color3bv)(CGL_MACRO_CONTEXT_RENDERER, components)

#define glSecondaryColor3d(red, green, blue) \
	(*(CGL_MACRO_CONTEXT)->disp.secondary_color3d)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue)

#define glSecondaryColor3dv(components) \
	(*(CGL_MACRO_CONTEXT)->disp.secondary_color3dv)(CGL_MACRO_CONTEXT_RENDERER, components)

#define glSecondaryColor3f(red, green, blue) \
	(*(CGL_MACRO_CONTEXT)->disp.secondary_color3f)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue)

#define glSecondaryColor3fv(components) \
	(*(CGL_MACRO_CONTEXT)->disp.secondary_color3fv)(CGL_MACRO_CONTEXT_RENDERER, components)

#define glSecondaryColor3i(red, green, blue) \
	(*(CGL_MACRO_CONTEXT)->disp.secondary_color3i)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue)

#define glSecondaryColor3iv(components) \
	(*(CGL_MACRO_CONTEXT)->disp.secondary_color3iv)(CGL_MACRO_CONTEXT_RENDERER, components)

#define glSecondaryColor3s(red, green, blue) \
	(*(CGL_MACRO_CONTEXT)->disp.secondary_color3s)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue)

#define glSecondaryColor3sv(components) \
	(*(CGL_MACRO_CONTEXT)->disp.secondary_color3sv)(CGL_MACRO_CONTEXT_RENDERER, components)

#define glSecondaryColor3ub(red, green, blue) \
	(*(CGL_MACRO_CONTEXT)->disp.secondary_color3ub)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue)

#define glSecondaryColor3ubv(components) \
	(*(CGL_MACRO_CONTEXT)->disp.secondary_color3ubv)(CGL_MACRO_CONTEXT_RENDERER, components)

#define glSecondaryColor3ui(red, green, blue) \
	(*(CGL_MACRO_CONTEXT)->disp.secondary_color3ui)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue)

#define glSecondaryColor3uiv(components) \
	(*(CGL_MACRO_CONTEXT)->disp.secondary_color3uiv)(CGL_MACRO_CONTEXT_RENDERER, components)

#define glSecondaryColor3us(red, green, blue) \
	(*(CGL_MACRO_CONTEXT)->disp.secondary_color3us)(CGL_MACRO_CONTEXT_RENDERER, red, green, blue)

#define glSecondaryColor3usv(components) \
	(*(CGL_MACRO_CONTEXT)->disp.secondary_color3usv)(CGL_MACRO_CONTEXT_RENDERER, components)

#define glSecondaryColorPointer(size, type, stride, pointer) \
	(*(CGL_MACRO_CONTEXT)->disp.secondary_color_pointer)(CGL_MACRO_CONTEXT_RENDERER, size, type, stride, pointer)

#define glPointParameterf(pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.point_parameterf)(CGL_MACRO_CONTEXT_RENDERER, pname, param)

#define glPointParameterfv(pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.point_parameterfv)(CGL_MACRO_CONTEXT_RENDERER, pname, params)

#define glPointParameteri(pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.point_parameteri)(CGL_MACRO_CONTEXT_RENDERER, pname, param)

#define glPointParameteriv(pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.point_parameteriv)(CGL_MACRO_CONTEXT_RENDERER, pname, params)

#define glBlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha) \
	(*(CGL_MACRO_CONTEXT)->disp.blend_func_separate)(CGL_MACRO_CONTEXT_RENDERER, sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha)

#define glMultiDrawArrays(mode, first, count, primcount) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_draw_arrays)(CGL_MACRO_CONTEXT_RENDERER, mode, first, count, primcount)

#define glMultiDrawElements(mode, count, type, indices, primcount) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_draw_elements)(CGL_MACRO_CONTEXT_RENDERER, mode, count, type, indices, primcount)

#define glWindowPos2d(x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.window_pos2d)(CGL_MACRO_CONTEXT_RENDERER, x, y)

#define glWindowPos2dv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.window_pos2dv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glWindowPos2f(x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.window_pos2f)(CGL_MACRO_CONTEXT_RENDERER, x, y)

#define glWindowPos2fv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.window_pos2fv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glWindowPos2i(x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.window_pos2i)(CGL_MACRO_CONTEXT_RENDERER, x, y)

#define glWindowPos2iv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.window_pos2iv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glWindowPos2s(x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.window_pos2s)(CGL_MACRO_CONTEXT_RENDERER, x, y)

#define glWindowPos2sv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.window_pos2sv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glWindowPos3d(x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.window_pos3d)(CGL_MACRO_CONTEXT_RENDERER, x, y, z)

#define glWindowPos3dv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.window_pos3dv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glWindowPos3f(x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.window_pos3f)(CGL_MACRO_CONTEXT_RENDERER, x, y, z)

#define glWindowPos3fv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.window_pos3fv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glWindowPos3i(x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.window_pos3i)(CGL_MACRO_CONTEXT_RENDERER, x, y, z)

#define glWindowPos3iv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.window_pos3iv)(CGL_MACRO_CONTEXT_RENDERER, v)

#define glWindowPos3s(x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.window_pos3s)(CGL_MACRO_CONTEXT_RENDERER, x, y, z)

#define glWindowPos3sv(v) \
	(*(CGL_MACRO_CONTEXT)->disp.window_pos3sv)(CGL_MACRO_CONTEXT_RENDERER, v)

/****************** OpenGL 1.5 Macros *****************************/

#define glGenQueries(n, ids) \
	(*(CGL_MACRO_CONTEXT)->disp.gen_queries)(CGL_MACRO_CONTEXT_RENDERER, n, ids)

#define glDeleteQueries(n, ids) \
	(*(CGL_MACRO_CONTEXT)->disp.delete_queries)(CGL_MACRO_CONTEXT_RENDERER, n, ids)

#define glIsQuery(id) \
	(*(CGL_MACRO_CONTEXT)->disp.is_query)(CGL_MACRO_CONTEXT_RENDERER, id)

#define glBeginQuery(target, id) \
	(*(CGL_MACRO_CONTEXT)->disp.begin_query)(CGL_MACRO_CONTEXT_RENDERER, target, id)

#define glEndQuery(target) \
	(*(CGL_MACRO_CONTEXT)->disp.end_query)(CGL_MACRO_CONTEXT_RENDERER, target)

#define glGetQueryiv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_queryiv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glGetQueryObjectiv(id, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_query_objectiv)(CGL_MACRO_CONTEXT_RENDERER, id, pname, params)

#define glGetQueryObjectuiv(id, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_query_objectuiv)(CGL_MACRO_CONTEXT_RENDERER, id, pname, params)

#define glBindBuffer(target, buffer) \
	(*(CGL_MACRO_CONTEXT)->disp.bind_buffer)(CGL_MACRO_CONTEXT_RENDERER, target, buffer)

#define glDeleteBuffers(n, buffers) \
	(*(CGL_MACRO_CONTEXT)->disp.delete_buffers)(CGL_MACRO_CONTEXT_RENDERER, n, buffers)

#define glGenBuffers(n, buffers) \
	(*(CGL_MACRO_CONTEXT)->disp.gen_buffers)(CGL_MACRO_CONTEXT_RENDERER, n, buffers)

#define glIsBuffer(buffer) \
	(*(CGL_MACRO_CONTEXT)->disp.is_buffer)(CGL_MACRO_CONTEXT_RENDERER, buffer)

#define glBufferData(target, size, data, usage) \
	(*(CGL_MACRO_CONTEXT)->disp.buffer_data)(CGL_MACRO_CONTEXT_RENDERER, target, size, data, usage)

#define glBufferSubData(target, offset, size, data) \
	(*(CGL_MACRO_CONTEXT)->disp.buffer_sub_data)(CGL_MACRO_CONTEXT_RENDERER, target, offset, size, data)

#define glGetBufferSubData(target, offset, size, data) \
	(*(CGL_MACRO_CONTEXT)->disp.get_buffer_sub_data)(CGL_MACRO_CONTEXT_RENDERER, target, offset, size, data)

#define glMapBuffer(target, access) \
	(*(CGL_MACRO_CONTEXT)->disp.map_buffer)(CGL_MACRO_CONTEXT_RENDERER, target, access)

#define glUnmapBuffer(target) \
	(*(CGL_MACRO_CONTEXT)->disp.unmap_buffer)(CGL_MACRO_CONTEXT_RENDERER, target)

#define glGetBufferParameteriv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_buffer_parameteriv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glGetBufferPointerv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_buffer_pointerv)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

/****************** OpenGL 2.0 Macros *****************************/

#define glDrawBuffers(n, bufs) \
	(*(CGL_MACRO_CONTEXT)->disp.draw_buffers_ARB)(CGL_MACRO_CONTEXT_RENDERER, n, bufs)

#define glVertexAttrib1d(index, x) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib1d_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x)

#define glVertexAttrib1dv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib1dv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib1f(index, x) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib1f_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x)

#define glVertexAttrib1fv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib1fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib1s(index, x) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib1s_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x)

#define glVertexAttrib1sv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib1sv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib2d(index, x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib2d_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y)

#define glVertexAttrib2dv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib2dv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib2f(index, x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib2f_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y)

#define glVertexAttrib2fv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib2fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib2s(index, x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib2s_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y)

#define glVertexAttrib2sv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib2sv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib3d(index, x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib3d_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y, z)

#define glVertexAttrib3dv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib3dv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib3f(index, x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib3f_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y, z)

#define glVertexAttrib3fv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib3fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib3s(index, x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib3s_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y, z)

#define glVertexAttrib3sv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib3sv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib4Nbv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4Nbv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib4Niv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4Niv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib4Nsv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4Nsv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib4Nub(index, x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4Nub_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y, x, w)

#define glVertexAttrib4Nubv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4Nubv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib4Nuiv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4Nuiv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib4Nusv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4Nusv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib4bv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4bv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib4d(index, x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4d_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y, z, w)

#define glVertexAttrib4dv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4dv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib4f(index, x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4f_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y, z, w)

#define glVertexAttrib4fv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib4iv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4iv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib4s(index, x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4s_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y, z, w)

#define glVertexAttrib4sv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4sv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib4ubv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4ubv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib4uiv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4uiv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttrib4usv(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4usv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, v)

#define glVertexAttribPointer(index, size, type, normalized, stride, pointer) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib_pointer_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, size, type, normalized, stride, pointer)

#define glEnableVertexAttribArray(index) \
	(*(CGL_MACRO_CONTEXT)->disp.enable_vertex_attrib_array_ARB)(CGL_MACRO_CONTEXT_RENDERER, index)

#define glDisableVertexAttribArray(index) \
	(*(CGL_MACRO_CONTEXT)->disp.disable_vertex_attrib_array_ARB)(CGL_MACRO_CONTEXT_RENDERER, index)

#define glGetVertexAttribdv(index, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_vertex_attribdv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, pname, params)

#define glGetVertexAttribfv(index, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_vertex_attribfv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, pname, params)

#define glGetVertexAttribiv(index, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_vertex_attribiv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, pname, params)

#define glGetVertexAttribPointerv(index, pname, pointer) \
	(*(CGL_MACRO_CONTEXT)->disp.get_vertex_attrib_pointerv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, pname, pointer)

#define glDeleteShader(shader) \
	(*(CGL_MACRO_CONTEXT)->disp.delete_object_ARB)(CGL_MACRO_CONTEXT_RENDERER, CGL_HANDLE_ARB(shader))

#define glDetachShader(program, shader) \
	(*(CGL_MACRO_CONTEXT)->disp.detach_object_ARB)(CGL_MACRO_CONTEXT_RENDERER, CGL_HANDLE_ARB(program), CGL_HANDLE_ARB(shader))

#define glCreateShader(type) \
	(GLuint)((unsigned long)(*(CGL_MACRO_CONTEXT)->disp.create_shader_object_ARB)(CGL_MACRO_CONTEXT_RENDERER, type))

#define glShaderSource(shader, count, string, length) \
	(*(CGL_MACRO_CONTEXT)->disp.shader_source_ARB)(CGL_MACRO_CONTEXT_RENDERER, CGL_HANDLE_ARB(shader), count, string, length)

#define glCompileShader(shader) \
	(*(CGL_MACRO_CONTEXT)->disp.compile_shader_ARB)(CGL_MACRO_CONTEXT_RENDERER, CGL_HANDLE_ARB(shader))

#define glCreateProgram() \
	(GLuint)((unsigned long)(*(CGL_MACRO_CONTEXT)->disp.create_program_object_ARB)(CGL_MACRO_CONTEXT_RENDERER))

#define glAttachShader(program, shader) \
	(*(CGL_MACRO_CONTEXT)->disp.attach_object_ARB)(CGL_MACRO_CONTEXT_RENDERER, CGL_HANDLE_ARB(program), CGL_HANDLE_ARB(shader))

#define glLinkProgram(program) \
	(*(CGL_MACRO_CONTEXT)->disp.link_program_ARB)(CGL_MACRO_CONTEXT_RENDERER, CGL_HANDLE_ARB(program))

#define glUseProgram(program) \
	(*(CGL_MACRO_CONTEXT)->disp.use_program_object_ARB)(CGL_MACRO_CONTEXT_RENDERER, CGL_HANDLE_ARB(program))

#define glDeleteProgram(program) \
	(*(CGL_MACRO_CONTEXT)->disp.delete_object_ARB)(CGL_MACRO_CONTEXT_RENDERER, CGL_HANDLE_ARB(program))

#define glValidateProgram(program) \
	(*(CGL_MACRO_CONTEXT)->disp.validate_program_ARB)(CGL_MACRO_CONTEXT_RENDERER, CGL_HANDLE_ARB(program))

#define glUniform1f(location, v0) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform1f_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, v0)

#define glUniform2f(location, v0, v1) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform2f_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, v0, v1)

#define glUniform3f(location, v0, v1, v2) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform3f_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, v0, v1, v2)

#define glUniform4f(location, v0, v1, v2, v3) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform4f_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, v0, v1, v2, v3)

#define glUniform1i(location, v0) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform1i_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, v0)

#define glUniform2i(location, v0, v1) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform2i_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, v0, v1)

#define glUniform3i(location, v0, v1, v2) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform3i_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, v0, v1, v2)

#define glUniform4i(location, v0, v1, v2, v3) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform4i_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, v0, v1, v2, v3)

#define glUniform1fv(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform1fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)

#define glUniform2fv(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform2fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)

#define glUniform3fv(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform3fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)

#define glUniform4fv(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform4fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)

#define glUniform1iv(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform1iv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)

#define glUniform2iv(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform2iv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)

#define glUniform3iv(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform3iv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)

#define glUniform4iv(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform4iv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)

#define glUniformMatrix2fv(location, count, transpose, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform_matrix2fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, transpose, value)

#define glUniformMatrix3fv(location, count, transpose, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform_matrix3fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, transpose, value)

#define glUniformMatrix4fv(location, count, transpose, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform_matrix4fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, transpose, value)

#define glIsShader(shader) \
	(*(CGL_MACRO_CONTEXT)->disp.is_shader)(CGL_MACRO_CONTEXT_RENDERER, shader)

#define glIsProgram(program) \
	(*(CGL_MACRO_CONTEXT)->disp.is_program)(CGL_MACRO_CONTEXT_RENDERER, program)

#define glGetShaderiv(shader, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_shaderiv)(CGL_MACRO_CONTEXT_RENDERER, shader, pname, params)

#define glGetProgramiv(program, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_programiv)(CGL_MACRO_CONTEXT_RENDERER, program, pname, params)

#define glGetAttachedShaders(program, maxCount, count, shaders) \
	(*(CGL_MACRO_CONTEXT)->disp.get_attached_shaders)(CGL_MACRO_CONTEXT_RENDERER, program, maxCount, count, shaders)

#define glGetShaderInfoLog(shader, bufSize, length, infoLog) \
	(*(CGL_MACRO_CONTEXT)->disp.get_shader_info_log)(CGL_MACRO_CONTEXT_RENDERER, shader, bufSize, length, infoLog)

#define glGetProgramInfoLog(program, bufSize, length, infoLog) \
	(*(CGL_MACRO_CONTEXT)->disp.get_program_info_log)(CGL_MACRO_CONTEXT_RENDERER, program, bufSize, length, infoLog)

#define glGetUniformLocation(program, name) \
	(*(CGL_MACRO_CONTEXT)->disp.get_uniform_location_ARB)(CGL_MACRO_CONTEXT_RENDERER, CGL_HANDLE_ARB(program), name)

#define glGetActiveUniform(program, index, bufSize, length, size, type, name) \
	(*(CGL_MACRO_CONTEXT)->disp.get_active_uniform_ARB)(CGL_MACRO_CONTEXT_RENDERER, CGL_HANDLE_ARB(program), index, bufSize, length, size, type, name)

#define glGetUniformfv(program, location, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_uniformfv_ARB)(CGL_MACRO_CONTEXT_RENDERER, CGL_HANDLE_ARB(program), location, params)

#define glGetUniformiv(program, location, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_uniformiv_ARB)(CGL_MACRO_CONTEXT_RENDERER, CGL_HANDLE_ARB(program), location, params)

#define glGetShaderSource(shader, bufSize, length, source) \
	(*(CGL_MACRO_CONTEXT)->disp.get_shader_source_ARB)(CGL_MACRO_CONTEXT_RENDERER, CGL_HANDLE_ARB(shader), bufSize, length, source)

#define glBindAttribLocation(program, index, name) \
	(*(CGL_MACRO_CONTEXT)->disp.bind_attrib_location_ARB)(CGL_MACRO_CONTEXT_RENDERER, CGL_HANDLE_ARB(program), index, name)

#define glGetActiveAttrib(program, index, bufSize, length, size, type, name) \
	(*(CGL_MACRO_CONTEXT)->disp.get_active_attrib_ARB)(CGL_MACRO_CONTEXT_RENDERER, CGL_HANDLE_ARB(program), index, bufSize, length, size, type, name)

#define glGetAttribLocation(program, name) \
	(*(CGL_MACRO_CONTEXT)->disp.get_attrib_location_ARB)(CGL_MACRO_CONTEXT_RENDERER, CGL_HANDLE_ARB(program), name)

#define glStencilFuncSeparate(face, func, ref, mask) \
	(*(CGL_MACRO_CONTEXT)->disp.stencil_func_separate)(CGL_MACRO_CONTEXT_RENDERER, face, func, ref, mask)

#define glStencilOpSeparate(face, fail, zfail, zpass) \
	(*(CGL_MACRO_CONTEXT)->disp.stencil_op_separate_ATI)(CGL_MACRO_CONTEXT_RENDERER, face, fail, zfail, zpass)

#define glStencilMaskSeparate(face, mask) \
	(*(CGL_MACRO_CONTEXT)->disp.stencil_mask_separate)(CGL_MACRO_CONTEXT_RENDERER, face, mask)

#define glBlendEquationSeparate glBlendEquationSeparateEXT

/****************** OpenGL 2.1 Macros *****************************/

#define glUniformMatrix2x3fv(location, count, transpose, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform_matrix2x3fv)(CGL_MACRO_CONTEXT_RENDERER, location, count, transpose, value)

#define glUniformMatrix3x2fv(location, count, transpose, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform_matrix3x2fv)(CGL_MACRO_CONTEXT_RENDERER, location, count, transpose, value)

#define glUniformMatrix2x4fv(location, count, transpose, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform_matrix2x4fv)(CGL_MACRO_CONTEXT_RENDERER, location, count, transpose, value)

#define glUniformMatrix4x2fv(location, count, transpose, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform_matrix4x2fv)(CGL_MACRO_CONTEXT_RENDERER, location, count, transpose, value)

#define glUniformMatrix3x4fv(location, count, transpose, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform_matrix3x4fv)(CGL_MACRO_CONTEXT_RENDERER, location, count, transpose, value)

#define glUniformMatrix4x3fv(location, count, transpose, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform_matrix4x3fv)(CGL_MACRO_CONTEXT_RENDERER, location, count, transpose, value)

/****************** OpenGL 3.0 Macros *****************************/

#define glColorMaski glColorMaskIndexedEXT
#define glGetBooleani_v glGetBooleanIndexedvEXT
#define glGetIntegeri_v glGetIntegerIndexedvEXT
#define glEnablei glEnableIndexedEXT
#define glDisablei glDisableIndexedEXT
#define glIsEnabledi glIsEnabledIndexedEXT

#define glBeginTransformFeedback glBeginTransformFeedbackEXT
#define glEndTransformFeedback glEndTransformFeedbackEXT
#define glBindBufferRange glBindBufferRangeEXT
#define glBindBufferBase glBindBufferBaseEXT
#define glTransformFeedbackVaryings glTransformFeedbackVaryingsEXT
#define glGetTransformFeedbackVarying glGetTransformFeedbackVaryingEXT

#define glClampColor glClampColorARB

#define glBeginConditionalRender glBeginConditionalRenderNV
#define glEndConditionalRender glEndConditionalRenderNV

#define glVertexAttribIPointer glVertexAttribIPointerEXT
#define glGetVertexAttribIiv glGetVertexAttribIivEXT
#define glGetVertexAttribIuiv glGetVertexAttribIuivEXT
#define glVertexAttribI1i glVertexAttribI1iEXT
#define glVertexAttribI2i glVertexAttribI2iEXT
#define glVertexAttribI3i glVertexAttribI3iEXT
#define glVertexAttribI4i glVertexAttribI4iEXT
#define glVertexAttribI1ui glVertexAttribI1uiEXT
#define glVertexAttribI2ui glVertexAttribI2uiEXT
#define glVertexAttribI3ui glVertexAttribI3uiEXT
#define glVertexAttribI4ui glVertexAttribI4uiEXT
#define glVertexAttribI1iv glVertexAttribI1ivEXT
#define glVertexAttribI2iv glVertexAttribI2ivEXT
#define glVertexAttribI3iv glVertexAttribI3ivEXT
#define glVertexAttribI4iv glVertexAttribI4ivEXT
#define glVertexAttribI1uiv glVertexAttribI1uivEXT
#define glVertexAttribI2uiv glVertexAttribI2uivEXT
#define glVertexAttribI3uiv glVertexAttribI3uivEXT
#define glVertexAttribI4uiv glVertexAttribI4uivEXT
#define glVertexAttribI4bv glVertexAttribI4bvEXT
#define glVertexAttribI4sv glVertexAttribI4svEXT
#define glVertexAttribI4ubv glVertexAttribI4ubvEXT
#define glVertexAttribI4usv glVertexAttribI4usvEXT
#define glGetUniformuiv glGetUniformuivEXT
#define glBindFragDataLocation glBindFragDataLocationEXT
#define glGetFragDataLocation glGetFragDataLocationEXT
#define glUniform1ui glUniform1uiEXT
#define glUniform2ui glUniform2uiEXT
#define glUniform3ui glUniform3uiEXT
#define glUniform4ui glUniform4uiEXT
#define glUniform1uiv glUniform1uivEXT
#define glUniform2uiv glUniform2uivEXT
#define glUniform3uiv glUniform3uivEXT
#define glUniform4uiv glUniform4uivEXT

#define glTexParameterIiv glTexParameterIivEXT
#define glTexParameterIuiv glTexParameterIuivEXT
#define glGetTexParameterIiv glGetTexParameterIivEXT
#define glGetTexParameterIuiv glGetTexParameterIuivEXT

#define glClearBufferiv(buffer, drawbuffer, value) \
	(*(CGL_MACRO_CONTEXT)->disp.clear_bufferiv)(CGL_MACRO_CONTEXT_RENDERER, buffer, drawbuffer, value)

#define glClearBufferuiv(buffer, drawbuffer, value) \
	(*(CGL_MACRO_CONTEXT)->disp.clear_bufferuiv)(CGL_MACRO_CONTEXT_RENDERER, buffer, drawbuffer, value)

#define glClearBufferfv(buffer, drawbuffer, value) \
	(*(CGL_MACRO_CONTEXT)->disp.clear_bufferfv)(CGL_MACRO_CONTEXT_RENDERER, buffer, drawbuffer, value)

#define glClearBufferfi(buffer, drawbuffer, depth, stencil) \
	(*(CGL_MACRO_CONTEXT)->disp.clear_bufferfi)(CGL_MACRO_CONTEXT_RENDERER, buffer, drawbuffer, depth, stencil)

#define glGetStringi(name, index) \
	(*(CGL_MACRO_CONTEXT)->disp.get_stringi)(CGL_MACRO_CONTEXT_RENDERER, name, index)



/********** ARB Extensions *************************************************/

/* GL_ARB_vertex_program */
#define glBindProgramARB(target, id) \
	(*(CGL_MACRO_CONTEXT)->disp.bind_program_ARB)(CGL_MACRO_CONTEXT_RENDERER, target, id)

#define glDeleteProgramsARB(n, programs) \
	(*(CGL_MACRO_CONTEXT)->disp.delete_programs_ARB)(CGL_MACRO_CONTEXT_RENDERER, n, programs)

#define glGenProgramsARB(n, programs) \
	(*(CGL_MACRO_CONTEXT)->disp.gen_programs_ARB)(CGL_MACRO_CONTEXT_RENDERER, n, programs)

#define glIsProgramARB(id) \
	(*(CGL_MACRO_CONTEXT)->disp.is_program_ARB)(CGL_MACRO_CONTEXT_RENDERER, id)

#define glVertexAttrib1sARB(index, x) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib1s_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x)

#define glVertexAttrib1fARB(index, x) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib1f_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x)

#define glVertexAttrib1dARB(index, x) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib1d_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x)

#define glVertexAttrib2sARB(index, x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib2s_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y)

#define glVertexAttrib2fARB(index, x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib2f_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y)

#define glVertexAttrib2dARB(index, x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib2d_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y)

#define glVertexAttrib3sARB(index, x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib3s_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y, z)

#define glVertexAttrib3fARB(index, x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib3f_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y, z)

#define glVertexAttrib3dARB(index, x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib3d_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y, z)

#define glVertexAttrib4sARB(index, x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4s_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y, z, w)

#define glVertexAttrib4fARB(index, x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4f_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y, z, w)

#define glVertexAttrib4dARB(index, x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4d_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y, z, w)

#define glVertexAttrib4NubARB(index, x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4Nub_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, x, y, z, w)

#define glVertexAttrib1svARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib1sv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib1fvARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib1fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib1dvARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib1dv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib2svARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib2sv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib2fvARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib2fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib2dvARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib2dv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib3svARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib3sv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib3fvARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib3fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib3dvARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib3dv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib4bvARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4bv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib4ubvARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4ubv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib4svARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4sv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib4usvARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4usv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib4ivARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4iv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib4uivARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4uiv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib4fvARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib4dvARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4dv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib4NbvARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4Nbv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib4NubvARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4Nubv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib4NsvARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4Nsv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib4NusvARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4Nusv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib4NivARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4Niv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttrib4NuivARB(index, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib4Nuiv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, addr)

#define glVertexAttribPointerARB(index, size, type, normalized, stride, addr) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib_pointer_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, size, type, normalized, stride, addr)

#define glEnableVertexAttribArrayARB(index) \
	(*(CGL_MACRO_CONTEXT)->disp.enable_vertex_attrib_array_ARB)(CGL_MACRO_CONTEXT_RENDERER, index)

#define glDisableVertexAttribArrayARB(index) \
	(*(CGL_MACRO_CONTEXT)->disp.disable_vertex_attrib_array_ARB)(CGL_MACRO_CONTEXT_RENDERER, index)

#define glGetVertexAttribdvARB(index, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_vertex_attribdv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, pname, params)

#define glGetVertexAttribfvARB(index, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_vertex_attribfv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, pname, params)

#define glGetVertexAttribivARB(index, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_vertex_attribiv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, pname, params)

#define glGetVertexAttribPointervARB(index, pname, pointer) \
	(*(CGL_MACRO_CONTEXT)->disp.get_vertex_attrib_pointerv_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, pname, pointer)

#define glProgramEnvParameter4dARB(target, index, x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.program_env_parameter4d_ARB)(CGL_MACRO_CONTEXT_RENDERER, target, index, x, y, z, w)

#define glProgramEnvParameter4dvARB(target, index, params) \
	(*(CGL_MACRO_CONTEXT)->disp.program_env_parameter4dv_ARB)(CGL_MACRO_CONTEXT_RENDERER, target, index, params)

#define glProgramEnvParameter4fARB(target, index, x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.program_env_parameter4f_ARB)(CGL_MACRO_CONTEXT_RENDERER, target, index, x, y, z, w)

#define glProgramEnvParameter4fvARB(target, index, params) \
	(*(CGL_MACRO_CONTEXT)->disp.program_env_parameter4fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, target, index, params)

#define glProgramLocalParameter4dARB(target, index, x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.program_local_parameter4d_ARB)(CGL_MACRO_CONTEXT_RENDERER, target, index, x, y, z, w)

#define glProgramLocalParameter4dvARB(target, index, params) \
	(*(CGL_MACRO_CONTEXT)->disp.program_local_parameter4dv_ARB)(CGL_MACRO_CONTEXT_RENDERER, target, index, params)

#define glProgramLocalParameter4fARB(target, index, x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.program_local_parameter4f_ARB)(CGL_MACRO_CONTEXT_RENDERER, target, index, x, y, z, w)

#define glProgramLocalParameter4fvARB(target, index, params) \
	(*(CGL_MACRO_CONTEXT)->disp.program_local_parameter4fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, target, index, params)

#define glGetProgramEnvParameterdvARB(target, index, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_program_env_parameterdv_ARB)(CGL_MACRO_CONTEXT_RENDERER, target, index, params)

#define glGetProgramEnvParameterfvARB(target, index, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_program_env_parameterfv_ARB)(CGL_MACRO_CONTEXT_RENDERER, target, index, params)

#define glGetProgramLocalParameterdvARB(target, index, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_program_local_parameterdv_ARB)(CGL_MACRO_CONTEXT_RENDERER, target, index, params)

#define glGetProgramLocalParameterfvARB(target, index, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_program_local_parameterfv_ARB)(CGL_MACRO_CONTEXT_RENDERER, target, index, params)

#define glProgramStringARB(target, format, length, string) \
	(*(CGL_MACRO_CONTEXT)->disp.program_string_ARB)(CGL_MACRO_CONTEXT_RENDERER, target, format, length, string)

#define glGetProgramStringARB(target, pname, string) \
	(*(CGL_MACRO_CONTEXT)->disp.get_program_string_ARB)(CGL_MACRO_CONTEXT_RENDERER, target, pname, string)

#define glGetProgramivARB(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_programiv_ARB)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

/* GL_EXT_gpu_program_parameters */
#define glProgramEnvParameters4fvEXT(target, index, count, params) \
	(*(CGL_MACRO_CONTEXT)->disp.program_env_parameters4fv_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, index, count, params)

#define glProgramLocalParameters4fvEXT(target, index, count, params) \
	(*(CGL_MACRO_CONTEXT)->disp.program_local_parameters4fv_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, index, count, params)

/* GL_ARB_vertex_blend */
#define glWeightbvARB(size, weights) \
	(*(CGL_MACRO_CONTEXT)->disp.weightbv_ARB)(CGL_MACRO_CONTEXT_RENDERER, size, weights)

#define glWeightsvARB(size, weights) \
	(*(CGL_MACRO_CONTEXT)->disp.weightsv_ARB)(CGL_MACRO_CONTEXT_RENDERER, size, weights)

#define glWeightivARB(size, weights) \
	(*(CGL_MACRO_CONTEXT)->disp.weightiv_ARB)(CGL_MACRO_CONTEXT_RENDERER, size, weights)

#define glWeightfvARB(size, weights) \
	(*(CGL_MACRO_CONTEXT)->disp.weightfv_ARB)(CGL_MACRO_CONTEXT_RENDERER, size, weights)

#define glWeightdvARB(size, weights) \
	(*(CGL_MACRO_CONTEXT)->disp.weightdv_ARB)(CGL_MACRO_CONTEXT_RENDERER, size, weights)

#define glWeightubvARB(size, weights) \
	(*(CGL_MACRO_CONTEXT)->disp.weightubv_ARB)(CGL_MACRO_CONTEXT_RENDERER, size, weights)

#define glWeightusvARB(size, weights) \
	(*(CGL_MACRO_CONTEXT)->disp.weightusv_ARB)(CGL_MACRO_CONTEXT_RENDERER, size, weights)

#define glWeightuivARB(size, weights) \
	(*(CGL_MACRO_CONTEXT)->disp.weightuiv_ARB)(CGL_MACRO_CONTEXT_RENDERER, size, weights)

#define glWeightPointerARB(size, type, stride, pointer) \
	(*(CGL_MACRO_CONTEXT)->disp.weight_pointer_ARB)(CGL_MACRO_CONTEXT_RENDERER, size, type, stride, pointer)

#define glVertexBlendARB(count) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_blend_ARB)(CGL_MACRO_CONTEXT_RENDERER, count)

/* GL_ARB_multitexture */
#define glClientActiveTextureARB glClientActiveTexture
#define glActiveTextureARB       glActiveTexture
#define glMultiTexCoord1dARB  glMultiTexCoord1d
#define glMultiTexCoord1dvARB glMultiTexCoord1dv
#define glMultiTexCoord1fARB  glMultiTexCoord1f
#define glMultiTexCoord1fvARB glMultiTexCoord1fv
#define glMultiTexCoord1iARB  glMultiTexCoord1i
#define glMultiTexCoord1ivARB glMultiTexCoord1iv
#define glMultiTexCoord1sARB  glMultiTexCoord1s
#define glMultiTexCoord1svARB glMultiTexCoord1sv
#define glMultiTexCoord2dARB  glMultiTexCoord2d
#define glMultiTexCoord2dvARB glMultiTexCoord2dv
#define glMultiTexCoord2fARB  glMultiTexCoord2f
#define glMultiTexCoord2fvARB glMultiTexCoord2fv
#define glMultiTexCoord2iARB  glMultiTexCoord2i
#define glMultiTexCoord2ivARB glMultiTexCoord2iv
#define glMultiTexCoord2sARB  glMultiTexCoord2s
#define glMultiTexCoord2svARB glMultiTexCoord2sv
#define glMultiTexCoord3dARB  glMultiTexCoord3d
#define glMultiTexCoord3dvARB glMultiTexCoord3dv
#define glMultiTexCoord3fARB  glMultiTexCoord3f
#define glMultiTexCoord3fvARB glMultiTexCoord3fv
#define glMultiTexCoord3iARB  glMultiTexCoord3i
#define glMultiTexCoord3ivARB glMultiTexCoord3iv
#define glMultiTexCoord3sARB  glMultiTexCoord3s
#define glMultiTexCoord3svARB glMultiTexCoord3sv
#define glMultiTexCoord4dARB  glMultiTexCoord4d
#define glMultiTexCoord4dvARB glMultiTexCoord4dv
#define glMultiTexCoord4fARB  glMultiTexCoord4f
#define glMultiTexCoord4fvARB glMultiTexCoord4fv
#define glMultiTexCoord4iARB  glMultiTexCoord4i
#define glMultiTexCoord4ivARB glMultiTexCoord4iv
#define glMultiTexCoord4sARB  glMultiTexCoord4s
#define glMultiTexCoord4svARB glMultiTexCoord4sv

/* GL_ARB_transpose_matrix */
#define glLoadTransposeMatrixfARB glLoadTransposeMatrixf
#define glLoadTransposeMatrixdARB glLoadTransposeMatrixd
#define glMultTransposeMatrixfARB glMultTransposeMatrixf
#define glMultTransposeMatrixdARB glMultTransposeMatrixd

/* GL_ARB_texture_compression */
#define glCompressedTexImage3DARB    glCompressedTexImage3D
#define glCompressedTexImage2DARB    glCompressedTexImage2D
#define glCompressedTexImage1DARB    glCompressedTexImage1D
#define glCompressedTexSubImage3DARB glCompressedTexSubImage3D
#define glCompressedTexSubImage2DARB glCompressedTexSubImage2D
#define glCompressedTexSubImage1DARB glCompressedTexSubImage1D
#define glGetCompressedTexImageARB   glGetCompressedTexImage

/* GL_ARB_multisample */
#define glSampleCoverageARB glSampleCoverage

/* GL_ARB_point_parameters */
#define glPointParameterfARB  glPointParameterf
#define glPointParameterfvARB glPointParameterfv

/* GL_ARB_window_pos */
#define glWindowPos2dARB  glWindowPos2d
#define glWindowPos2dvARB glWindowPos2dv
#define glWindowPos2fARB  glWindowPos2f
#define glWindowPos2fvARB glWindowPos2fv
#define glWindowPos2iARB  glWindowPos2i
#define glWindowPos2ivARB glWindowPos2iv
#define glWindowPos2sARB  glWindowPos2s
#define glWindowPos2svARB glWindowPos2sv
#define glWindowPos3dARB  glWindowPos3d
#define glWindowPos3dvARB glWindowPos3dv
#define glWindowPos3fARB  glWindowPos3f
#define glWindowPos3fvARB glWindowPos3fv
#define glWindowPos3iARB  glWindowPos3i
#define glWindowPos3ivARB glWindowPos3iv
#define glWindowPos3sARB  glWindowPos3s
#define glWindowPos3svARB glWindowPos3sv

/* GL_ARB_occlusion_query */
#define glGenQueriesARB        glGenQueries
#define glDeleteQueriesARB     glDeleteQueries
#define glIsQueryARB           glIsQuery
#define glBeginQueryARB        glBeginQuery
#define glEndQueryARB          glEndQuery
#define glGetQueryivARB        glGetQueryiv
#define glGetQueryObjectivARB  glGetQueryObjectiv
#define glGetQueryObjectuivARB glGetQueryObjectuiv

/* GL_ARB_vertex_buffer_object */
#define glBindBufferARB           glBindBuffer
#define glDeleteBuffersARB        glDeleteBuffers
#define glGenBuffersARB           glGenBuffers
#define glIsBufferARB             glIsBuffer
#define glBufferDataARB           glBufferData
#define glBufferSubDataARB        glBufferSubData
#define glGetBufferSubDataARB     glGetBufferSubData
#define glMapBufferARB            glMapBuffer
#define glUnmapBufferARB          glUnmapBuffer
#define glGetBufferParameterivARB glGetBufferParameteriv
#define glGetBufferPointervARB    glGetBufferPointerv

/* GL_ARB_shader_objects */
#define glDeleteObjectARB(obj) \
	(*(CGL_MACRO_CONTEXT)->disp.delete_object_ARB)(CGL_MACRO_CONTEXT_RENDERER, obj)

#define glGetHandleARB(pname) \
	(*(CGL_MACRO_CONTEXT)->disp.get_handle_ARB)(CGL_MACRO_CONTEXT_RENDERER, pname)

#define glDetachObjectARB(container, attached) \
	(*(CGL_MACRO_CONTEXT)->disp.detach_object_ARB)(CGL_MACRO_CONTEXT_RENDERER, container, attached)

#define glCreateShaderObjectARB(shader) \
	(*(CGL_MACRO_CONTEXT)->disp.create_shader_object_ARB)(CGL_MACRO_CONTEXT_RENDERER, shader)

#define glShaderSourceARB(shader, count, string, length) \
	(*(CGL_MACRO_CONTEXT)->disp.shader_source_ARB)(CGL_MACRO_CONTEXT_RENDERER, shader, count, string, length)

#define glCompileShaderARB(shader) \
	(*(CGL_MACRO_CONTEXT)->disp.compile_shader_ARB)(CGL_MACRO_CONTEXT_RENDERER, shader)

#define glCreateProgramObjectARB() \
	(*(CGL_MACRO_CONTEXT)->disp.create_program_object_ARB)(CGL_MACRO_CONTEXT_RENDERER)

#define glAttachObjectARB(container, object) \
	(*(CGL_MACRO_CONTEXT)->disp.attach_object_ARB)(CGL_MACRO_CONTEXT_RENDERER, container, object)

#define glLinkProgramARB(program) \
	(*(CGL_MACRO_CONTEXT)->disp.link_program_ARB)(CGL_MACRO_CONTEXT_RENDERER, program)

#define glUseProgramObjectARB(program) \
	(*(CGL_MACRO_CONTEXT)->disp.use_program_object_ARB)(CGL_MACRO_CONTEXT_RENDERER, program)

#define glValidateProgramARB(program) \
	(*(CGL_MACRO_CONTEXT)->disp.validate_program_ARB)(CGL_MACRO_CONTEXT_RENDERER, program)

#define glUniform1fARB(location, v0) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform1f_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, v0)

#define glUniform2fARB(location, v0, v1) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform2f_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, v0, v1)

#define glUniform3fARB(location, v0, v1, v2) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform3f_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, v0, v1, v2)

#define glUniform4fARB(location, v0, v1, v2, v3) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform4f_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, v0, v1, v2, v3)

#define glUniform1iARB(location, v0) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform1i_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, v0)

#define glUniform2iARB(location, v0, v1) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform2i_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, v0, v1)

#define glUniform3iARB(location, v0, v1, v2) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform3i_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, v0, v1, v2)

#define glUniform4iARB(location, v0, v1, v2, v3) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform4i_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, v0, v1, v2, v3)

#define glUniform1fvARB(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform1fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)

#define glUniform2fvARB(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform2fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)

#define glUniform3fvARB(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform3fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)

#define glUniform4fvARB(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform4fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)

#define glUniform1ivARB(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform1iv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)

#define glUniform2ivARB(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform2iv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)

#define glUniform3ivARB(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform3iv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)

#define glUniform4ivARB(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform4iv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)

#define glUniformMatrix2fvARB(location, count, transpose, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform_matrix2fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, transpose, value)

#define glUniformMatrix3fvARB(location, count, transpose, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform_matrix3fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, transpose, value)

#define glUniformMatrix4fvARB(location, count, transpose, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform_matrix4fv_ARB)(CGL_MACRO_CONTEXT_RENDERER, location, count, transpose, value)

#define glGetObjectParameterfvARB(obj, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_object_parameterfv_ARB)(CGL_MACRO_CONTEXT_RENDERER, obj, pname, params)

#define glGetObjectParameterivARB(obj, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_object_parameteriv_ARB)(CGL_MACRO_CONTEXT_RENDERER, obj, pname, params)

#define glGetInfoLogARB(obj, max, length, info) \
	(*(CGL_MACRO_CONTEXT)->disp.get_info_log_ARB)(CGL_MACRO_CONTEXT_RENDERER, obj, max, length, info)

#define glGetAttachedObjectsARB(container, max, count, obj) \
	(*(CGL_MACRO_CONTEXT)->disp.get_attached_objects_ARB)(CGL_MACRO_CONTEXT_RENDERER, container, max, count, obj)

#define glGetUniformLocationARB(program, name) \
	(*(CGL_MACRO_CONTEXT)->disp.get_uniform_location_ARB)(CGL_MACRO_CONTEXT_RENDERER, program, name)

#define glGetActiveUniformARB(program, index, max, length, size, type, name) \
	(*(CGL_MACRO_CONTEXT)->disp.get_active_uniform_ARB)(CGL_MACRO_CONTEXT_RENDERER, program, index, max, length, size, type, name)

#define glGetUniformfvARB(program, location, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_uniformfv_ARB)(CGL_MACRO_CONTEXT_RENDERER, program, location, params)

#define glGetUniformivARB(program, location, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_uniformiv_ARB)(CGL_MACRO_CONTEXT_RENDERER, program, location, params)

#define glGetShaderSourceARB(obj, max, length, source) \
	(*(CGL_MACRO_CONTEXT)->disp.get_shader_source_ARB)(CGL_MACRO_CONTEXT_RENDERER, obj, max, length, source)

/* GL_ARB_vertex_shader */
#define glBindAttribLocationARB(program, index, name) \
	(*(CGL_MACRO_CONTEXT)->disp.bind_attrib_location_ARB)(CGL_MACRO_CONTEXT_RENDERER, program, index, name)

#define glGetActiveAttribARB(program, index, max, length, size, type, name) \
	(*(CGL_MACRO_CONTEXT)->disp.get_active_attrib_ARB)(CGL_MACRO_CONTEXT_RENDERER, program, index, max, length, size, type, name)

#define glGetAttribLocationARB(program, name) \
	(*(CGL_MACRO_CONTEXT)->disp.get_attrib_location_ARB)(CGL_MACRO_CONTEXT_RENDERER, program, name)

#define glDrawBuffersARB(n, bufs)\
	(*(CGL_MACRO_CONTEXT)->disp.draw_buffers_ARB)(CGL_MACRO_CONTEXT_RENDERER, n, bufs)

/* GL_ARB_color_buffer_float */
#define glClampColorARB(target, clamp)\
	(*(CGL_MACRO_CONTEXT)->disp.clamp_color_ARB)(CGL_MACRO_CONTEXT_RENDERER, target, clamp)

/* GL_ARB_framebuffer_object */
#define glIsRenderbuffer(renderbuffer) \
	(*(CGL_MACRO_CONTEXT)->disp.is_renderbuffer_EXT)(CGL_MACRO_CONTEXT_RENDERER, renderbuffer)

#define glBindRenderbuffer(target, renderbuffer) \
	(*(CGL_MACRO_CONTEXT)->disp.bind_renderbuffer_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, renderbuffer)

#define glDeleteRenderbuffers(n, renderbuffers) \
	(*(CGL_MACRO_CONTEXT)->disp.delete_renderbuffers_EXT)(CGL_MACRO_CONTEXT_RENDERER, n, renderbuffers)

#define glGenRenderbuffers(n, renderbuffers) \
	(*(CGL_MACRO_CONTEXT)->disp.gen_renderbuffers_EXT)(CGL_MACRO_CONTEXT_RENDERER, n, renderbuffers)

#define glRenderbufferStorage(target, internalformat, width, height) \
	(*(CGL_MACRO_CONTEXT)->disp.renderbuffer_storage_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, internalformat, width, height)

#define glGetRenderbufferParameteriv(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_renderbuffer_parameteriv_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glIsFramebuffer(framebuffer) \
	(*(CGL_MACRO_CONTEXT)->disp.is_framebuffer_EXT)(CGL_MACRO_CONTEXT_RENDERER, framebuffer)

#define glBindFramebuffer(target, framebuffer) \
	(*(CGL_MACRO_CONTEXT)->disp.bind_framebuffer_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, framebuffer)

#define glDeleteFramebuffers(n, framebuffers) \
	(*(CGL_MACRO_CONTEXT)->disp.delete_framebuffers_EXT)(CGL_MACRO_CONTEXT_RENDERER, n, framebuffers)

#define glGenFramebuffers(n, framebuffers) \
	(*(CGL_MACRO_CONTEXT)->disp.gen_framebuffers_EXT)(CGL_MACRO_CONTEXT_RENDERER, n, framebuffers)

#define glCheckFramebufferStatus(target) \
	(*(CGL_MACRO_CONTEXT)->disp.check_framebuffer_status_EXT)(CGL_MACRO_CONTEXT_RENDERER, target)

#define glFramebufferTexture1D(target, attachment, textarget, texture, level) \
	(*(CGL_MACRO_CONTEXT)->disp.framebuffer_texture1D_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, attachment, textarget, texture, level)

#define glFramebufferTexture2D(target, attachment, textarget, texture, level) \
	(*(CGL_MACRO_CONTEXT)->disp.framebuffer_texture2D_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, attachment, textarget, texture, level)

#define glFramebufferTexture3D(target, attachment, textarget, texture, level, zoffset) \
	(*(CGL_MACRO_CONTEXT)->disp.framebuffer_texture3D_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, attachment, textarget, texture, level, zoffset)

#define glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer) \
	(*(CGL_MACRO_CONTEXT)->disp.framebuffer_renderbuffer_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, attachment, renderbuffertarget, renderbuffer)

#define glGetFramebufferAttachmentParameteriv(target, attachment, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_framebuffer_attachment_parameteriv_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, attachment, pname, params)

#define glGenerateMipmap(target) \
	(*(CGL_MACRO_CONTEXT)->disp.generate_mipmap_EXT)(CGL_MACRO_CONTEXT_RENDERER, target)

#define glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter) \
	(*(CGL_MACRO_CONTEXT)->disp.blit_framebuffer_EXT)(CGL_MACRO_CONTEXT_RENDERER, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)

#define glRenderbufferStorageMultisample(target, samples, internalformat, width, height) \
	(*(CGL_MACRO_CONTEXT)->disp.renderbuffer_storage_multisample_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, samples, internalformat, width, height)

#define glFramebufferTextureLayer(target, attachment, texture, level, layer) \
	(*(CGL_MACRO_CONTEXT)->disp.framebuffer_texture_layer_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, attachment, texture, level, layer)

/* GL_ARB_instanced_arrays */
#define glVertexAttribDivisorARB(index,divisor) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attrib_divisor)(CGL_MACRO_CONTEXT_RENDERER, index, divisor)

/* GL_ARB_draw_instanced */
#define glDrawArraysInstancedARB(mode, first, count, primcount) \
	(*(CGL_MACRO_CONTEXT)->disp.draw_arrays_instanced)(CGL_MACRO_CONTEXT_RENDERER, mode, first, count, primcount)

#define glDrawElementsInstancedARB(mode, count, type, indices, primcount) \
	(*(CGL_MACRO_CONTEXT)->disp.draw_elements_instanced)(CGL_MACRO_CONTEXT_RENDERER, mode, count, type, indices, primcount)

/* GL_ARB_draw_elements_base_vertex */
#define glDrawElementsBaseVertex(mode, count, type, indices, basev) \
	(*(CGL_MACRO_CONTEXT)->disp.draw_elements_base_vertex)(CGL_MACRO_CONTEXT_RENDERER, mode, count, type, indices, basev)

#define glDrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basev) \
	(*(CGL_MACRO_CONTEXT)->disp.draw_range_elements_base_vertex)(CGL_MACRO_CONTEXT_RENDERER, mode, start, end, count, type, indices, basev)

#define glDrawElementsInstancedBaseVertex(mode, count, type, indices, primcount, basev) \
	(*(CGL_MACRO_CONTEXT)->disp.draw_elements_instanced_base_vertex)(CGL_MACRO_CONTEXT_RENDERER, mode, count, type, indices, primcount, basev)

#define glMultiDrawElementsBaseVertex(mode, count, type, indices, primcount, basev) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_draw_elements_base_vertex)(CGL_MACRO_CONTEXT_RENDERER, mode, count, type, indices, primcount, basev)

/* GL_ARB_sync */
#define glFenceSync(condition, flags) \
	(*(CGL_MACRO_CONTEXT)->disp.fence_sync)(CGL_MACRO_CONTEXT_RENDERER, condition, flags)

#define glIsSync(sync) \
	(*(CGL_MACRO_CONTEXT)->disp.is_sync)(CGL_MACRO_CONTEXT_RENDERER, sync)

#define glDeleteSync(sync) \
	(*(CGL_MACRO_CONTEXT)->disp.delete_sync)(CGL_MACRO_CONTEXT_RENDERER, sync)

#define glClientWaitSync(sync, flags, timeout) \
	(*(CGL_MACRO_CONTEXT)->disp.client_wait_sync)(CGL_MACRO_CONTEXT_RENDERER, sync, flags, timeout)

#define glWaitSync(sync, flags, timeout) \
	(*(CGL_MACRO_CONTEXT)->disp.wait_sync)(CGL_MACRO_CONTEXT_RENDERER, sync, flags, timeout)

#define glGetInteger64v(pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_integer64v_sync)(CGL_MACRO_CONTEXT_RENDERER, pname, params)

#define glGetSynciv(sync, pname, bufSize, length, values) \
	(*(CGL_MACRO_CONTEXT)->disp.get_synciv)(CGL_MACRO_CONTEXT_RENDERER, sync, pname, bufSize, length, values)

/*********** EXT Extensions *************************************************/

/* GL_EXT_stencil_two_side */
#define glActiveStencilFaceEXT(face) \
	(*(CGL_MACRO_CONTEXT)->disp.active_stencil_face_EXT)(CGL_MACRO_CONTEXT_RENDERER, face)

/* GL_EXT_depth_bounds_test */
#define glDepthBoundsEXT(zmin, zmax) \
	(*(CGL_MACRO_CONTEXT)->disp.depth_bounds_EXT)(CGL_MACRO_CONTEXT_RENDERER, zmin, zmax)

/* GL_EXT_blend_equation_separate */
#define glBlendEquationSeparateEXT(modeRGB, modeAlpha) \
	(*(CGL_MACRO_CONTEXT)->disp.blend_equation_separate_EXT)(CGL_MACRO_CONTEXT_RENDERER, modeRGB, modeAlpha)

/* GL_EXT_paletted_texture */
#define glColorTableEXT glColorTable
#define glColorSubTableEXT glColorSubTable
#define glGetColorTableEXT glGetColorTable
#define glGetColorTableParameterivEXT glGetColorTableParameteriv
#define glGetColorTableParameterfvEXT glGetColorTableParameterfv

/* GL_EXT_secondary_color */
#define glSecondaryColor3bEXT glSecondaryColor3b
#define glSecondaryColor3bvEXT glSecondaryColor3bv
#define glSecondaryColor3dEXT glSecondaryColor3d
#define glSecondaryColor3dvEXT glSecondaryColor3dv
#define glSecondaryColor3fEXT glSecondaryColor3f
#define glSecondaryColor3fvEXT glSecondaryColor3fv
#define glSecondaryColor3iEXT glSecondaryColor3i
#define glSecondaryColor3ivEXT glSecondaryColor3iv
#define glSecondaryColor3sEXT glSecondaryColor3s
#define glSecondaryColor3svEXT glSecondaryColor3sv
#define glSecondaryColor3ubEXT glSecondaryColor3ub
#define glSecondaryColor3ubvEXT glSecondaryColor3ubv
#define glSecondaryColor3uiEXT glSecondaryColor3ui
#define glSecondaryColor3uivEXT glSecondaryColor3uiv
#define glSecondaryColor3usEXT glSecondaryColor3us
#define glSecondaryColor3usvEXT glSecondaryColor3usv
#define glSecondaryColorPointerEXT glSecondaryColorPointer

/* GL_EXT_fog_coord */
#define glFogCoordfEXT glFogCoordf
#define glFogCoordfvEXT glFogCoordfv
#define glFogCoorddEXT glFogCoordd
#define glFogCoorddvEXT glFogCoorddv
#define glFogCoordPointerEXT glFogCoordPointer

/* GL_EXT_draw_range_elements */
#define glDrawRangeElementsEXT glDrawRangeElements

/* GL_EXT_blend_func_separate */
#define glBlendFuncSeparateEXT glBlendFuncSeparate

/* GL_EXT_multi_draw_arrays */
#define glMultiDrawArraysEXT glMultiDrawArrays
#define glMultiDrawElementsEXT glMultiDrawElements

/* GL_EXT_blend_color */
#define glBlendColorEXT glBlendColor

/* GL_EXT_blend_minmax */
#define glBlendEquationEXT glBlendEquation

/* GL_EXT_framebuffer_object */
#define glIsRenderbufferEXT(renderbuffer) \
	(*(CGL_MACRO_CONTEXT)->disp.is_renderbuffer_EXT)(CGL_MACRO_CONTEXT_RENDERER, renderbuffer)

#define glBindRenderbufferEXT(target, renderbuffer) \
	(*(CGL_MACRO_CONTEXT)->disp.bind_renderbuffer_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, renderbuffer)

#define glDeleteRenderbuffersEXT(n, renderbuffers) \
	(*(CGL_MACRO_CONTEXT)->disp.delete_renderbuffers_EXT)(CGL_MACRO_CONTEXT_RENDERER, n, renderbuffers)

#define glGenRenderbuffersEXT(n, renderbuffers) \
	(*(CGL_MACRO_CONTEXT)->disp.gen_renderbuffers_EXT)(CGL_MACRO_CONTEXT_RENDERER, n, renderbuffers)

#define glRenderbufferStorageEXT(target, internalformat, width, height) \
	(*(CGL_MACRO_CONTEXT)->disp.renderbuffer_storage_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, internalformat, width, height)

#define glGetRenderbufferParameterivEXT(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_renderbuffer_parameteriv_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

#define glIsFramebufferEXT(framebuffer) \
	(*(CGL_MACRO_CONTEXT)->disp.is_framebuffer_EXT)(CGL_MACRO_CONTEXT_RENDERER, framebuffer)

#define glBindFramebufferEXT(target, framebuffer) \
	(*(CGL_MACRO_CONTEXT)->disp.bind_framebuffer_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, framebuffer)

#define glDeleteFramebuffersEXT(n, framebuffers) \
	(*(CGL_MACRO_CONTEXT)->disp.delete_framebuffers_EXT)(CGL_MACRO_CONTEXT_RENDERER, n, framebuffers)

#define glGenFramebuffersEXT(n, framebuffers) \
	(*(CGL_MACRO_CONTEXT)->disp.gen_framebuffers_EXT)(CGL_MACRO_CONTEXT_RENDERER, n, framebuffers)

#define glCheckFramebufferStatusEXT(target) \
	(*(CGL_MACRO_CONTEXT)->disp.check_framebuffer_status_EXT)(CGL_MACRO_CONTEXT_RENDERER, target)

#define glFramebufferTexture1DEXT(target, attachment, textarget, texture, level) \
	(*(CGL_MACRO_CONTEXT)->disp.framebuffer_texture1D_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, attachment, textarget, texture, level)

#define glFramebufferTexture2DEXT(target, attachment, textarget, texture, level) \
	(*(CGL_MACRO_CONTEXT)->disp.framebuffer_texture2D_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, attachment, textarget, texture, level)

#define glFramebufferTexture3DEXT(target, attachment, textarget, texture, level, zoffset) \
	(*(CGL_MACRO_CONTEXT)->disp.framebuffer_texture3D_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, attachment, textarget, texture, level, zoffset)

#define glFramebufferRenderbufferEXT(target, attachment, renderbuffertarget, renderbuffer) \
	(*(CGL_MACRO_CONTEXT)->disp.framebuffer_renderbuffer_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, attachment, renderbuffertarget, renderbuffer)

#define glGetFramebufferAttachmentParameterivEXT(target, attachment, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_framebuffer_attachment_parameteriv_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, attachment, pname, params)

#define glGenerateMipmapEXT(target) \
	(*(CGL_MACRO_CONTEXT)->disp.generate_mipmap_EXT)(CGL_MACRO_CONTEXT_RENDERER, target)

/* EXT_framebuffer_blit and EXT_framebuffer_multisample */
#define glBlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter) \
	(*(CGL_MACRO_CONTEXT)->disp.blit_framebuffer_EXT)(CGL_MACRO_CONTEXT_RENDERER, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter)

#define glRenderbufferStorageMultisampleEXT(target, samples, internalformat, width, height) \
	(*(CGL_MACRO_CONTEXT)->disp.renderbuffer_storage_multisample_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, samples, internalformat, width, height)

/* GL_EXT_geometry_shader4 */
#define glProgramParameteriEXT(program, pname, value) \
	(*(CGL_MACRO_CONTEXT)->disp.program_parameteri_EXT)(CGL_MACRO_CONTEXT_RENDERER, program, pname, value)

#define glFramebufferTextureEXT(target, attachment, texture, level) \
	(*(CGL_MACRO_CONTEXT)->disp.framebuffer_texture_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, attachment, texture, level)

#define glFramebufferTextureLayerEXT(target, attachment, texture, level, layer) \
	(*(CGL_MACRO_CONTEXT)->disp.framebuffer_texture_layer_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, attachment, texture, level, layer)

#define glFramebufferTextureFaceEXT(target, attachment, texture, level, face) \
	(*(CGL_MACRO_CONTEXT)->disp.framebuffer_texture_face_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, attachment, texture, level, face)

/* GL_EXT_transform_feedback */
#define glBindBufferRangeEXT(target, index, buffer, offset, size) \
	(*(CGL_MACRO_CONTEXT)->disp.bind_buffer_range_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, index, buffer, offset, size)
#define glBindBufferOffsetEXT(target, index, buffer, offset) \
	(*(CGL_MACRO_CONTEXT)->disp.bind_buffer_offset_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, index, buffer, offset)
#define glBindBufferBaseEXT(target, index, buffer) \
	(*(CGL_MACRO_CONTEXT)->disp.bind_buffer_base_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, index, buffer)
#define glBeginTransformFeedbackEXT(primitiveMode) \
	(*(CGL_MACRO_CONTEXT)->disp.begin_transform_feedback_EXT)(CGL_MACRO_CONTEXT_RENDERER, primitiveMode)
#define glEndTransformFeedbackEXT() \
	(*(CGL_MACRO_CONTEXT)->disp.end_transform_feedback_EXT)(CGL_MACRO_CONTEXT_RENDERER)
#define glTransformFeedbackVaryingsEXT(program, count, varyings, bufferMode) \
	(*(CGL_MACRO_CONTEXT)->disp.transform_feedback_varyings_EXT)(CGL_MACRO_CONTEXT_RENDERER, program, count, varyings, bufferMode)
#define glGetTransformFeedbackVaryingEXT(program, index, bufSize, length, size, type, name) \
	(*(CGL_MACRO_CONTEXT)->disp.get_transform_feedback_varying_EXT)(CGL_MACRO_CONTEXT_RENDERER, program, index, bufSize, length, size, type, name)

/* GL_EXT_transform_feedback || GL_EXT_draw_buffers2 */
#define glGetIntegerIndexedvEXT(param, index, values) \
	(*(CGL_MACRO_CONTEXT)->disp.get_integer_indexedv_EXT)(CGL_MACRO_CONTEXT_RENDERER, param, index, values)
#define glGetBooleanIndexedvEXT(param, index, values) \
	(*(CGL_MACRO_CONTEXT)->disp.get_boolean_indexedv_EXT)(CGL_MACRO_CONTEXT_RENDERER, param, index, values)

/* GL_EXT_bindable_uniform */
#define glUniformBufferEXT(program, location, buffer) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform_buffer_EXT)(CGL_MACRO_CONTEXT_RENDERER, program, location, buffer)
#define glGetUniformBufferSizeEXT(program, location) \
	(*(CGL_MACRO_CONTEXT)->disp.get_uniform_buffer_size_EXT)(CGL_MACRO_CONTEXT_RENDERER, program, location)
#define glGetUniformOffsetEXT(program, location) \
	(*(CGL_MACRO_CONTEXT)->disp.get_uniform_buffer_offset_EXT)(CGL_MACRO_CONTEXT_RENDERER, program, location)

/* GL_EXT_texture_integer */
#define glClearColorIiEXT(r, g, b, a) \
	(*(CGL_MACRO_CONTEXT)->disp.clear_colorIi_EXT)(CGL_MACRO_CONTEXT_RENDERER, r, g, b, a)
#define glClearColorIuiEXT(r, g, b, a) \
	(*(CGL_MACRO_CONTEXT)->disp.clear_colorIui_EXT)(CGL_MACRO_CONTEXT_RENDERER, r, g, b, a)
#define glTexParameterIivEXT(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_parameterIiv_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)
#define glTexParameterIuivEXT(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.tex_parameterIuiv_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)
#define glGetTexParameterIivEXT(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_tex_parameterIiv_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)
#define glGetTexParameterIuivEXT(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_tex_parameterIuiv_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

/* GL_EXT_gpu_shader4 */
#define glVertexAttribI1iEXT(index, x) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI1i_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, x)
#define glVertexAttribI2iEXT(index, x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI2i_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, x, y)
#define glVertexAttribI3iEXT(index, x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI3i_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, x, y, z)
#define glVertexAttribI4iEXT(index, x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI4i_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, x, y, z, w)
#define glVertexAttribI1uiEXT(index, x) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI1ui_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, x)
#define glVertexAttribI2uiEXT(index, x, y) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI2ui_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, x, y)
#define glVertexAttribI3uiEXT(index, x, y, z) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI3ui_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, x, y, z)
#define glVertexAttribI4uiEXT(index, x, y, z, w) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI4ui_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, x, y, z, w)
#define glVertexAttribI1ivEXT(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI1iv_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, v)
#define glVertexAttribI2ivEXT(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI2iv_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, v)
#define glVertexAttribI3ivEXT(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI3iv_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, v)
#define glVertexAttribI4ivEXT(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI4iv_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, v)
#define glVertexAttribI1uivEXT(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI1uiv_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, v)
#define glVertexAttribI2uivEXT(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI2uiv_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, v)
#define glVertexAttribI3uivEXT(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI3uiv_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, v)
#define glVertexAttribI4uivEXT(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI4uiv_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, v)
#define glVertexAttribI4bvEXT(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI4bv_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, v)
#define glVertexAttribI4svEXT(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI4sv_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, v)
#define glVertexAttribI4ubvEXT(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI4ubv_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, v)
#define glVertexAttribI4usvEXT(index, v) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI4usv_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, v)
#define glVertexAttribIPointerEXT(index, size, type, stride, pointer) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_attribI_pointer_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, size, type, stride, pointer)
#define glGetVertexAttribIivEXT(index, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_vertex_attribIiv_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, pname, params)
#define glGetVertexAttribIuivEXT(index, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_vertex_attribIuiv_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, pname, params)
#define glUniform1uiEXT(location, v0) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform1ui_EXT)(CGL_MACRO_CONTEXT_RENDERER, location, v0)
#define glUniform2uiEXT(location, v0, v1) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform2ui_EXT)(CGL_MACRO_CONTEXT_RENDERER, location, v0, v1)
#define glUniform3uiEXT(location, v0, v1, v2) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform3ui_EXT)(CGL_MACRO_CONTEXT_RENDERER, location, v0, v1, v2)
#define glUniform4uiEXT(location, v0, v1, v2, v3) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform4ui_EXT)(CGL_MACRO_CONTEXT_RENDERER, location, v0, v1, v2, v3)
#define glUniform1uivEXT(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform1uiv_EXT)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)
#define glUniform2uivEXT(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform2uiv_EXT)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)
#define glUniform3uivEXT(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform3uiv_EXT)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)
#define glUniform4uivEXT(location, count, value) \
	(*(CGL_MACRO_CONTEXT)->disp.uniform4uiv_EXT)(CGL_MACRO_CONTEXT_RENDERER, location, count, value)
#define glGetUniformuivEXT(program, location, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_uniformuiv_EXT)(CGL_MACRO_CONTEXT_RENDERER, program, location, params)
#define glBindFragDataLocationEXT(program, colorNumber, name) \
	(*(CGL_MACRO_CONTEXT)->disp.bind_frag_data_location_EXT)(CGL_MACRO_CONTEXT_RENDERER, program, colorNumber, name)
#define glGetFragDataLocationEXT(program, name) \
	(*(CGL_MACRO_CONTEXT)->disp.get_frag_data_location_EXT)(CGL_MACRO_CONTEXT_RENDERER, program, name)

/* GL_EXT_draw_buffers2 */
#define glColorMaskIndexedEXT(index, r, g, b, a) \
	(*(CGL_MACRO_CONTEXT)->disp.color_mask_indexed_EXT)(CGL_MACRO_CONTEXT_RENDERER, index, r, g, b, a)
#define glEnableIndexedEXT(target, index) \
	(*(CGL_MACRO_CONTEXT)->disp.enable_indexed_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, index)
#define glDisableIndexedEXT(target, index) \
	(*(CGL_MACRO_CONTEXT)->disp.disable_indexed_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, index)
#define glIsEnabledIndexedEXT(target, index) \
	(*(CGL_MACRO_CONTEXT)->disp.is_enabled_indexed_EXT)(CGL_MACRO_CONTEXT_RENDERER, target, index)

/* GL_ARB_provoking_vertex */
#define glProvokingVertex(mode) \
	(*(CGL_MACRO_CONTEXT)->disp.provoking_vertex_EXT)(CGL_MACRO_CONTEXT_RENDERER, mode)

/* GL_EXT_provoking_vertex */
#define glProvokingVertexEXT glProvokingVertex

/* GL_EXT_timer_query */
#define glGetQueryObjecti64vEXT(id, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_query_objecti64v)(CGL_MACRO_CONTEXT_RENDERER, id, pname, params)

#define glGetQueryObjectui64vEXT(id, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_query_objectui64v)(CGL_MACRO_CONTEXT_RENDERER, id, pname, params)

/* GL_EXT_debug_label */
#define glLabelObjectEXT(type, object, length, label) \
	(*(CGL_MACRO_CONTEXT)->disp.label_object_EXT)(CGL_MACRO_CONTEXT_RENDERER, type, object, length, label)

#define glGetObjectLabelEXT(type, object, bufSize, length, label) \
	(*(CGL_MACRO_CONTEXT)->disp.get_object_label_EXT)(CGL_MACRO_CONTEXT_RENDERER, type, object, bufSize, length, label)

/* GL_EXT_debug_marker */
#define glInsertEventMarkerEXT(length, marker) \
	(*(CGL_MACRO_CONTEXT)->disp.insert_event_marker_EXT)(CGL_MACRO_CONTEXT_RENDERER, length, marker)

#define glPushGroupMarkerEXT(length, marker) \
	(*(CGL_MACRO_CONTEXT)->disp.push_group_marker_EXT)(CGL_MACRO_CONTEXT_RENDERER, length, marker)

#define glPopGroupMarkerEXT() \
	(*(CGL_MACRO_CONTEXT)->disp.pop_group_marker_EXT)(CGL_MACRO_CONTEXT_RENDERER)

/*********** APPLE Extensions ***********************************************/

/* GL_APPLE_vertex_program_evaluators */
#define glEnableVertexAttribAPPLE(index, pname) \
	(*(CGL_MACRO_CONTEXT)->disp.enable_vertex_attrib_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, pname)

#define glDisableVertexAttribAPPLE(index, pname) \
	(*(CGL_MACRO_CONTEXT)->disp.disable_vertex_attrib_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, pname)

#define glIsVertexAttribEnabledAPPLE(index, pname) \
	(*(CGL_MACRO_CONTEXT)->disp.is_vertex_attrib_enabled_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, pname)

#define glMapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points) \
	(*(CGL_MACRO_CONTEXT)->disp.map_vertex_attrib1d_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, size, u1, u2, stride, order, points)

#define glMapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points) \
	(*(CGL_MACRO_CONTEXT)->disp.map_vertex_attrib1f_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, size, u1, u2, stride, order, points)

#define glMapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points) \
	(*(CGL_MACRO_CONTEXT)->disp.map_vertex_attrib2d_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points)

#define glMapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points) \
	(*(CGL_MACRO_CONTEXT)->disp.map_vertex_attrib2f_ARB)(CGL_MACRO_CONTEXT_RENDERER, index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points)

/* GL_APPLE_texture_range */
#define glTextureRangeAPPLE(target, length, pointer) \
	(*(CGL_MACRO_CONTEXT)->disp.texture_range_APPLE)(CGL_MACRO_CONTEXT_RENDERER, target, length, pointer)

#define glGetTexParameterPointervAPPLE(target, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_tex_parameter_pointerv_APPLE)(CGL_MACRO_CONTEXT_RENDERER, target, pname, params)

/* GL_APPLE_fence */
#define glGenFencesAPPLE(n, fences) \
	(*(CGL_MACRO_CONTEXT)->disp.gen_fences_APPLE)(CGL_MACRO_CONTEXT_RENDERER, n, fences)

#define glDeleteFencesAPPLE(n, fences) \
	(*(CGL_MACRO_CONTEXT)->disp.delete_fences_APPLE)(CGL_MACRO_CONTEXT_RENDERER, n, fences)

#define glSetFenceAPPLE(fence) \
	(*(CGL_MACRO_CONTEXT)->disp.set_fence_APPLE)(CGL_MACRO_CONTEXT_RENDERER, fence)

#define glIsFenceAPPLE(fence) \
	(*(CGL_MACRO_CONTEXT)->disp.is_fence_APPLE)(CGL_MACRO_CONTEXT_RENDERER, fence)

#define glTestFenceAPPLE(fence) \
	(*(CGL_MACRO_CONTEXT)->disp.test_fence_APPLE)(CGL_MACRO_CONTEXT_RENDERER, fence)

#define glFinishFenceAPPLE(fence) \
	(*(CGL_MACRO_CONTEXT)->disp.finish_fence_APPLE)(CGL_MACRO_CONTEXT_RENDERER, fence)

#define glTestObjectAPPLE(object, name) \
	(*(CGL_MACRO_CONTEXT)->disp.test_object_APPLE)(CGL_MACRO_CONTEXT_RENDERER, object, name)

#define glFinishObjectAPPLE(object, name) \
	(*(CGL_MACRO_CONTEXT)->disp.finish_object_APPLE)(CGL_MACRO_CONTEXT_RENDERER, object, name)

/* GL_APPLE_vertex_array_range */
#define glVertexArrayRangeAPPLE(length, pointer) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_array_range_EXT)(CGL_MACRO_CONTEXT_RENDERER, length, pointer)

#define glFlushVertexArrayRangeAPPLE(length, pointer) \
	(*(CGL_MACRO_CONTEXT)->disp.flush_vertex_array_range_EXT)(CGL_MACRO_CONTEXT_RENDERER, length, pointer)

#define glVertexArrayParameteriAPPLE(pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_array_parameteri_EXT)(CGL_MACRO_CONTEXT_RENDERER, pname, param)

/* GL_APPLE_vertex_array_object */
#define glBindVertexArrayAPPLE(id) \
	(*(CGL_MACRO_CONTEXT)->disp.bind_vertex_array_EXT)(CGL_MACRO_CONTEXT_RENDERER, id)

#define glDeleteVertexArraysAPPLE(n, ids) \
	(*(CGL_MACRO_CONTEXT)->disp.delete_vertex_arrays_EXT)(CGL_MACRO_CONTEXT_RENDERER, n, ids)

#define glGenVertexArraysAPPLE(n, ids) \
	(*(CGL_MACRO_CONTEXT)->disp.gen_vertex_arrays_EXT)(CGL_MACRO_CONTEXT_RENDERER, n, ids)

#define glIsVertexArrayAPPLE(id) \
	(*(CGL_MACRO_CONTEXT)->disp.is_vertex_array_EXT)(CGL_MACRO_CONTEXT_RENDERER, id)

/* GL_APPLE_element_array */
#define glElementPointerAPPLE(type, pointer) \
	(*(CGL_MACRO_CONTEXT)->disp.element_pointer_APPLE)(CGL_MACRO_CONTEXT_RENDERER, type, pointer)

#define glDrawElementArrayAPPLE(mode, first, count) \
	(*(CGL_MACRO_CONTEXT)->disp.draw_element_array_APPLE)(CGL_MACRO_CONTEXT_RENDERER, mode, first, count)

#define glDrawRangeElementArrayAPPLE(mode, start, end, first, count) \
	(*(CGL_MACRO_CONTEXT)->disp.draw_range_element_array_APPLE)(CGL_MACRO_CONTEXT_RENDERER, mode, start, end, first, count)

#define glMultiDrawElementArrayAPPLE(mode, first, count, primcount) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_draw_element_array_APPLE)(CGL_MACRO_CONTEXT_RENDERER, mode, first, count, primcount)

#define glMultiDrawRangeElementArrayAPPLE(mode, start, end, first, count, primcount) \
	(*(CGL_MACRO_CONTEXT)->disp.multi_draw_range_element_array_APPLE)(CGL_MACRO_CONTEXT_RENDERER, mode, start, end, first, count, primcount)

/* GL_APPLE_flush_render */
#define glFlushRenderAPPLE() \
	(*(CGL_MACRO_CONTEXT)->disp.flush_render_APPLE)(CGL_MACRO_CONTEXT_RENDERER)

#define glFinishRenderAPPLE() \
	(*(CGL_MACRO_CONTEXT)->disp.finish_render_APPLE)(CGL_MACRO_CONTEXT_RENDERER)

#define glSwapAPPLE() \
	(*(CGL_MACRO_CONTEXT)->disp.swap_APPLE)(CGL_MACRO_CONTEXT_RENDERER)

/* GL_APPLE_flush_buffer_range */
#define glBufferParameteriAPPLE(target, pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.buffer_parameteri_APPLE)(CGL_MACRO_CONTEXT_RENDERER, target, pname, param)

#define glFlushMappedBufferRangeAPPLE(target, offset, size) \
	(*(CGL_MACRO_CONTEXT)->disp.flush_mapped_buffer_range_APPLE)(CGL_MACRO_CONTEXT_RENDERER, target, offset, size)

/* GL_APPLE_object_purgeability */
#define glObjectPurgeableAPPLE(objectType, name, option) \
	(*(CGL_MACRO_CONTEXT)->disp.object_purgeable_APPLE)(CGL_MACRO_CONTEXT_RENDERER, objectType, name, option)

#define glObjectUnpurgeableAPPLE(objectType, name, option) \
	(*(CGL_MACRO_CONTEXT)->disp.object_unpurgeable_APPLE)(CGL_MACRO_CONTEXT_RENDERER, objectType, name, option)

#define glGetObjectParameterivAPPLE(objectType, name, pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.get_object_parameteriv_APPLE)(CGL_MACRO_CONTEXT_RENDERER, objectType, name, pname, params)

/* GL_APPLE_vertex_point_size */
#define glPointSizePointerAPPLE(type, stride, pointer) \
	(*(CGL_MACRO_CONTEXT)->disp.point_size_pointer)(CGL_MACRO_CONTEXT_RENDERER, type, stride, pointer)

#define glVertexPointSizefAPPLE(size) \
	(*(CGL_MACRO_CONTEXT)->disp.vertex_point_sizef_APPLE)(CGL_MACRO_CONTEXT_RENDERER, size)

/*********** ATI Extensions *************************************************/

/* GL_ATI_separate_stencil */
#define glStencilOpSeparateATI(face, sfail, dpfail, dppass) \
	(*(CGL_MACRO_CONTEXT)->disp.stencil_op_separate_ATI)(CGL_MACRO_CONTEXT_RENDERER, face, sfail, dpfail, dppass)

#define glStencilFuncSeparateATI(frontfunc, backfunc, ref, mask) \
	(*(CGL_MACRO_CONTEXT)->disp.stencil_func_separate_ATI)(CGL_MACRO_CONTEXT_RENDERER, frontfunc, backfunc, ref, mask)

/* GL_ATI_blend_equation_separate */
#define glBlendEquationSeparateATI glBlendEquationSeparateEXT

/*********** NVIDIA Extensions **********************************************/

/* GL_NV_point_sprite */
#define glPointParameteriNV(pname, param) \
	(*(CGL_MACRO_CONTEXT)->disp.point_parameteri)(CGL_MACRO_CONTEXT_RENDERER, pname, param)

#define glPointParameterivNV(pname, params) \
	(*(CGL_MACRO_CONTEXT)->disp.point_parameteriv)(CGL_MACRO_CONTEXT_RENDERER, pname, params)

/* GL_NV_conditional_render */
#define glBeginConditionalRenderNV(id, mode) \
	(*(CGL_MACRO_CONTEXT)->disp.begin_conditional_render_NV)(CGL_MACRO_CONTEXT_RENDERER, id, mode)

#define glEndConditionalRenderNV() \
	(*(CGL_MACRO_CONTEXT)->disp.end_conditional_render_NV)(CGL_MACRO_CONTEXT_RENDERER)

/* GL_NV_texture_barrier */
#define glTextureBarrierNV() \
	(*(CGL_MACRO_CONTEXT)->disp.texture_barrier_NV)(CGL_MACRO_CONTEXT_RENDERER)

#endif /* _CGLMACRO_H */

                                    CGLRenderers.h                                                                                      0100644 0001750 0001750 00000006077 12567471557 033425  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers                                                                      /*
	Copyright:	(c) 1999-2013 Apple Inc. All rights reserved.
*/

#ifndef _CGLRENDERERS_H
#define _CGLRENDERERS_H

#include <OpenGL/OpenGLAvailability.h>

/*
** Renderer ID numbers
*/
enum {
    kCGLRendererGenericID        OPENGL_ENUM_DEPRECATED(10_0, 10_5) = 0x00020200,
    kCGLRendererGenericFloatID   OPENGL_ENUM_AVAILABLE(10_3)        = 0x00020400, // Apple Software Renderer
    kCGLRendererAppleSWID                                           = 0x00020600,

    kCGLRendererATIRage128ID     OPENGL_ENUM_DEPRECATED(10_0, 10_5) = 0x00021000,
    kCGLRendererATIRadeonID      OPENGL_ENUM_DEPRECATED(10_0, 10_6) = 0x00021200,
    kCGLRendererATIRageProID     OPENGL_ENUM_DEPRECATED(10_0, 10_6) = 0x00021400,
    kCGLRendererATIRadeon8500ID  OPENGL_ENUM_DEPRECATED(10_2, 10_6) = 0x00021600,
    kCGLRendererATIRadeon9700ID  OPENGL_ENUM_DEPRECATED(10_2, 10_6) = 0x00021800,
    kCGLRendererATIRadeonX1000ID OPENGL_ENUM_DEPRECATED(10_4, 10_8) = 0x00021900, // Radeon X1xxx
    kCGLRendererATIRadeonX2000ID OPENGL_ENUM_AVAILABLE(10_4)        = 0x00021A00, // Radeon HD 2xxx and 4xxx
    kCGLRendererATIRadeonX3000ID OPENGL_ENUM_AVAILABLE(10_6)        = 0x00021B00, // Radeon HD 5xxx and 6xxx
    kCGLRendererATIRadeonX4000ID OPENGL_ENUM_AVAILABLE(10_8)        = 0x00021C00, // Radeon HD 7xxx

    kCGLRendererGeForce2MXID     OPENGL_ENUM_DEPRECATED(10_0, 10_6) = 0x00022000, // GeForce 2MX and 4MX
    kCGLRendererGeForce3ID       OPENGL_ENUM_DEPRECATED(10_0, 10_6) = 0x00022200, // GeForce 3 and 4Ti
    kCGLRendererGeForceFXID      OPENGL_ENUM_DEPRECATED(10_2, 10_8) = 0x00022400, // GeForce 5xxx, 6xxx and 7xxx, and
                                                                                  // Quadro FX 4500
    kCGLRendererGeForce8xxxID    OPENGL_ENUM_AVAILABLE(10_4)        = 0x00022600, // GeForce 8xxx, 9xxx, 1xx, 2xx, and 3xx, and
                                                                                  // Quadro 4800
    kCGLRendererGeForceID        OPENGL_ENUM_AVAILABLE(10_9)        = 0x00022700, // GeForce 6xx, and
                                                                                  // Quadro 4000, K5000

    kCGLRendererVTBladeXP2ID     OPENGL_ENUM_DEPRECATED(10_3, 10_6) = 0x00023000,

    kCGLRendererIntel900ID       OPENGL_ENUM_DEPRECATED(10_4, 10_8) = 0x00024000, // GMA 950
    kCGLRendererIntelX3100ID     OPENGL_ENUM_DEPRECATED(10_5, 10_8) = 0x00024200,
    kCGLRendererIntelHDID        OPENGL_ENUM_AVAILABLE(10_6)        = 0x00024300, // HD Graphics 3000
    kCGLRendererIntelHD4000ID    OPENGL_ENUM_AVAILABLE(10_7)        = 0x00024400,
    kCGLRendererIntelHD5000ID    OPENGL_ENUM_AVAILABLE(10_8)        = 0x00024500, // Iris

    kCGLRendererMesa3DFXID       OPENGL_ENUM_DEPRECATED(10_0, 10_6) = 0x00040000,
};

/*
** kCGLRendererIDMatchingMask gives the bits that are useful for matching a
** renderer ID (as returned by CGLDescribePixelFormat or CGLDescribeRenderer)
** with the assigned values above.  There should be no bits set in the assigned
** renderer ID's that are not set in this mask.
*/
#define kCGLRendererIDMatchingMask   0x00FE7F00


#endif /* _CGLRENDERERS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 CGLTypes.h                                                                                          0100644 0001750 0001750 00000047705 12567471557 032603  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers                                                                      /*
	Copyright:	(c) 1999-2013 Apple Inc. All rights reserved.
*/

#ifndef _CGLTYPES_H
#define _CGLTYPES_H

#include <OpenGL/OpenGLAvailability.h>

#ifdef __cplusplus
extern "C" {
#endif

#if __has_feature(assume_nonnull)
#define OPENGL_ASSUME_NONNULL_BEGIN _Pragma("clang assume_nonnull begin")
#define OPENGL_ASSUME_NONNULL_END _Pragma("clang assume_nonnull end")
#else
#define OPENGL_ASSUME_NONNULL_BEGIN
#define OPENGL_ASSUME_NONNULL_END
#endif

#if __has_feature(nullability)
#define OPENGL_NULLABLE __nullable
#define OPENGL_NONNULL __nonnull
#else
#define OPENGL_NULLABLE
#define OPENGL_NONNULL
#endif

/*
** CGL opaque data.
*/
typedef struct _CGLContextObject       *CGLContextObj;
typedef struct _CGLPixelFormatObject   *CGLPixelFormatObj;
typedef struct _CGLRendererInfoObject  *CGLRendererInfoObj;
typedef struct _CGLPBufferObject       *CGLPBufferObj OPENGL_DEPRECATED(10_3, 10_7);

/*
** Attribute names for CGLChoosePixelFormat and CGLDescribePixelFormat.
*/
typedef enum _CGLPixelFormatAttribute {
	kCGLPFAAllRenderers                                                   =   1, /* choose from all available renderers          */
	kCGLPFATripleBuffer OPENGL_ENUM_AVAILABLE(10_7)                       =   3, /* choose a triple buffered pixel format        */
	kCGLPFADoubleBuffer                                                   =   5, /* choose a double buffered pixel format        */
	kCGLPFAColorSize                                                      =   8, /* number of color buffer bits                  */
	kCGLPFAAlphaSize                                                      =  11, /* number of alpha component bits               */
	kCGLPFADepthSize                                                      =  12, /* number of depth buffer bits                  */
	kCGLPFAStencilSize                                                    =  13, /* number of stencil buffer bits                */
	kCGLPFAMinimumPolicy                                                  =  51, /* never choose smaller buffers than requested  */
	kCGLPFAMaximumPolicy                                                  =  52, /* choose largest buffers of type requested     */
	kCGLPFASampleBuffers OPENGL_ENUM_AVAILABLE(10_2)                      =  55, /* number of multi sample buffers               */
	kCGLPFASamples OPENGL_ENUM_AVAILABLE(10_2)                            =  56, /* number of samples per multi sample buffer    */
	kCGLPFAColorFloat OPENGL_ENUM_AVAILABLE(10_2)                         =  58, /* color buffers store floating point pixels    */
	kCGLPFAMultisample OPENGL_ENUM_AVAILABLE(10_3)                        =  59, /* choose multisampling                         */
	kCGLPFASupersample OPENGL_ENUM_AVAILABLE(10_3)                        =  60, /* choose supersampling                         */
	kCGLPFASampleAlpha OPENGL_ENUM_AVAILABLE(10_3)                        =  61, /* request alpha filtering                      */
	kCGLPFARendererID                                                     =  70, /* request renderer by ID                       */
	kCGLPFANoRecovery                                                     =  72, /* disable all failure recovery systems         */
	kCGLPFAAccelerated                                                    =  73, /* choose a hardware accelerated renderer       */
	kCGLPFAClosestPolicy                                                  =  74, /* choose the closest color buffer to request   */
	kCGLPFABackingStore                                                   =  76, /* back buffer contents are valid after swap    */
	kCGLPFABackingVolatile OPENGL_ENUM_AVAILABLE(10_7)                    =  77, /* back buffer contents are volatile after swap */
	kCGLPFADisplayMask                                                    =  84, /* mask limiting supported displays             */
	kCGLPFAAllowOfflineRenderers OPENGL_ENUM_AVAILABLE(10_5)              =  96, /* show offline renderers in pixel formats      */
	kCGLPFAAcceleratedCompute OPENGL_ENUM_AVAILABLE(10_6)                 =  97, /* choose a hardware accelerated compute device */
	kCGLPFAOpenGLProfile OPENGL_ENUM_AVAILABLE(10_7)                      =  99, /* specify an OpenGL Profile to use             */
	kCGLPFASupportsAutomaticGraphicsSwitching OPENGL_ENUM_AVAILABLE(10_8) = 101, /* responds to display changes                  */
	kCGLPFAVirtualScreenCount                                             = 128, /* number of virtual screens in this format     */

	/* Note: the following attributes are deprecated in Core Profile                    */
	kCGLPFAAuxBuffers                                  =   7, /* number of aux buffers                        */
	kCGLPFAAccumSize                                   =  14, /* number of accum buffer bits                  */
	kCGLPFAAuxDepthStencil OPENGL_ENUM_AVAILABLE(10_2) =  57, /* each aux buffer has its own depth stencil    */

	kCGLPFAStereo OPENGL_ENUM_DEPRECATED(10_0, 10_11)        =   6,
	kCGLPFAOffScreen OPENGL_ENUM_DEPRECATED(10_0, 10_7)      =  53,
	kCGLPFAWindow OPENGL_ENUM_DEPRECATED(10_0, 10_9)         =  80,
	kCGLPFACompliant OPENGL_ENUM_DEPRECATED(10_0, 10_9)      =  83,
	kCGLPFAPBuffer OPENGL_ENUM_DEPRECATED(10_3, 10_7)        =  90,
	kCGLPFARemotePBuffer OPENGL_ENUM_DEPRECATED(10_3, 10_9)  =  91,

	kCGLPFASingleRenderer OPENGL_ENUM_DEPRECATED(10_0, 10_9) =  71,
	kCGLPFARobust OPENGL_ENUM_DEPRECATED(10_0, 10_5)         =  75,
	kCGLPFAMPSafe OPENGL_ENUM_DEPRECATED(10_0, 10_5)         =  78,
	kCGLPFAMultiScreen OPENGL_ENUM_DEPRECATED(10_0, 10_5)    =  81,
	kCGLPFAFullScreen OPENGL_ENUM_DEPRECATED(10_0, 10_6)     =  54,
} CGLPixelFormatAttribute;

/*
** Property names for CGLDescribeRenderer.
*/
typedef enum _CGLRendererProperty {
	kCGLRPOffScreen                                          =  53,
	kCGLRPRendererID                                         =  70,
	kCGLRPAccelerated                                        =  73,
	kCGLRPBackingStore                                       =  76,
	kCGLRPWindow                                             =  80,
	kCGLRPCompliant                                          =  83,
	kCGLRPDisplayMask                                        =  84,
	kCGLRPBufferModes                                        = 100, /* a bitfield of supported buffer modes             */
	kCGLRPColorModes                                         = 103, /* a bitfield of supported color buffer formats     */
	kCGLRPAccumModes                                         = 104, /* a bitfield of supported accum buffer formats     */
	kCGLRPDepthModes                                         = 105, /* a bitfield of supported depth buffer depths      */
	kCGLRPStencilModes                                       = 106, /* a bitfield of supported stencil buffer depths    */
	kCGLRPMaxAuxBuffers                                      = 107, /* maximum number of auxilliary buffers             */
	kCGLRPMaxSampleBuffers OPENGL_ENUM_AVAILABLE(10_2)       = 108, /* maximum number of sample buffers                 */
	kCGLRPMaxSamples OPENGL_ENUM_AVAILABLE(10_2)             = 109, /* maximum number of samples                        */
	kCGLRPSampleModes OPENGL_ENUM_AVAILABLE(10_3)            = 110, /* a bitfield of supported sample modes             */
	kCGLRPSampleAlpha OPENGL_ENUM_AVAILABLE(10_3)            = 111, /* support for alpha sampling                       */
	kCGLRPGPUVertProcCapable OPENGL_ENUM_AVAILABLE(10_4)     = 122, /* renderer capable of GPU vertex processing        */
	kCGLRPGPUFragProcCapable OPENGL_ENUM_AVAILABLE(10_4)     = 123, /* renderer capable of GPU fragment processing      */
	kCGLRPRendererCount                                      = 128, /* the number of renderers in this renderer info    */
	kCGLRPOnline OPENGL_ENUM_AVAILABLE(10_5)                 = 129, /* a boolean stating if renderer is on/offline      */
	kCGLRPAcceleratedCompute OPENGL_ENUM_AVAILABLE(10_6)     = 130, /* hardware accelerated compute device              */
	kCGLRPVideoMemoryMegabytes OPENGL_ENUM_AVAILABLE(10_7)   = 131, /* total video memory (in megabytes)                */
	kCGLRPTextureMemoryMegabytes OPENGL_ENUM_AVAILABLE(10_7) = 132, /* video memory useable for textures (in megabytes) */
	kCGLRPMajorGLVersion OPENGL_ENUM_AVAILABLE(10_9)         = 133, /* maximum supported major GL revision              */

	kCGLRPRobust OPENGL_ENUM_DEPRECATED(10_0, 10_5)      =  75,
	kCGLRPMPSafe OPENGL_ENUM_DEPRECATED(10_0, 10_5)      =  78,
	kCGLRPMultiScreen OPENGL_ENUM_DEPRECATED(10_0, 10_5) =  81,
	kCGLRPFullScreen OPENGL_ENUM_DEPRECATED(10_0, 10_6)  =  54,
	kCGLRPVideoMemory OPENGL_ENUM_DEPRECATED_MSG(10_0, 10_7, "Use kCGLRPVideoMemoryMegabytes") = 120,
	kCGLRPTextureMemory OPENGL_ENUM_DEPRECATED_MSG(10_0, 10_7, "Use kCGLRPTextureMemoryMegabytes") = 121,
} CGLRendererProperty;

/*
** Enable names for CGLEnable, CGLDisable, and CGLIsEnabled.
*/
typedef enum _CGLContextEnable {
	kCGLCESwapRectangle                                       = 201, /* Enable or disable the swap rectangle              */
	kCGLCESwapLimit OPENGL_ENUM_AVAILABLE(10_2)               = 203, /* Enable or disable the swap async limit            */
	kCGLCERasterization                                       = 221, /* Enable or disable all rasterization               */
	kCGLCEStateValidation                                     = 301, /* Validate state for multi-screen functionality     */
	kCGLCESurfaceBackingSize OPENGL_ENUM_AVAILABLE(10_3)      = 305, /* Enable or disable surface backing size override   */
	kCGLCEDisplayListOptimization OPENGL_ENUM_AVAILABLE(10_3) = 307, /* Ability to turn off display list optimizer        */
	kCGLCEMPEngine OPENGL_ENUM_AVAILABLE(10_4)                = 313, /* Enable or disable multi-threaded GL engine        */
	kCGLCECrashOnRemovedFunctions OPENGL_ENUM_AVAILABLE(10_7) = 316  /* Die on call to function removed from Core Profile */
} CGLContextEnable;

/*
** GPURestartStatus names
*/
typedef enum _CGLGPURestartStatus { /* GPU Restart Status */
	kCGLCPGPURestartStatusNone        = 0, /* current context has not caused recent GPU restart */
	kCGLCPGPURestartStatusCaused      = 1, /* current context caused recent GPU restart (auto-clear on query) */
	kCGLCPGPURestartStatusBlacklisted = 2, /* current context is being ignored for excessive GPU restarts (won't clear on query) */
} CGLGPURestartStatus;

/*
** Parameter names for CGLSetParameter and CGLGetParameter.
*/
typedef enum _CGLContextParameter {
	kCGLCPSwapRectangle                                      = 200, /* 4 params.  Set or get the swap rectangle {x, y, w, h}        */
	kCGLCPSwapInterval                                       = 222, /* 1 param.   0 -> Don't sync, 1 -> Sync to vertical retrace    */
	kCGLCPDispatchTableSize OPENGL_ENUM_AVAILABLE(10_3)      = 224, /* 1 param.   Get the dispatch table size                       */
	/* Note: kCGLCPClientStorage is always a pointer-sized parameter, even though the API claims GLint. */
	kCGLCPClientStorage                                      = 226, /* 1 param.   Context specific generic storage                  */
	kCGLCPSurfaceTexture OPENGL_ENUM_DEPRECATED(10_3, 10_9)  = 228, /* 3 params.  Context, target, internal_format                  */
/*  - Used by AGL - */
/*  AGL_STATE_VALIDATION                                       230 */
/*  AGL_BUFFER_NAME                                            231 */
/*  AGL_ORDER_CONTEXT_TO_FRONT                                 232 */
/*  AGL_CONTEXT_SURFACE_ID                                     233 */
/*  AGL_CONTEXT_DISPLAY_ID                                     234 */
	kCGLCPSurfaceOrder OPENGL_ENUM_AVAILABLE(10_2)           = 235, /* 1 param.   1 -> Above window, -1 -> Below Window             */
	kCGLCPSurfaceOpacity OPENGL_ENUM_AVAILABLE(10_2)         = 236, /* 1 param.   1 -> Surface is opaque (default), 0 -> non-opaque */
/*  - Used by AGL - */
/*  AGL_CLIP_REGION                                            254 */
/*  AGL_FS_CAPTURE_SINGLE                                      255 */
	kCGLCPSurfaceBackingSize OPENGL_ENUM_AVAILABLE(10_3)     = 304, /* 2 params.  Width/height of surface backing size              */
/*  AGL_SURFACE_VOLATILE                                       306 */
	kCGLCPSurfaceSurfaceVolatile OPENGL_ENUM_AVAILABLE(10_3) = 306, /* 1 param.   Surface volatile state                            */
	kCGLCPReclaimResources OPENGL_ENUM_AVAILABLE(10_4)       = 308, /* 0 params.                                                    */
	kCGLCPCurrentRendererID OPENGL_ENUM_AVAILABLE(10_4)      = 309, /* 1 param.   Retrieves the current renderer ID                 */
	kCGLCPGPUVertexProcessing OPENGL_ENUM_AVAILABLE(10_4)    = 310, /* 1 param.   Currently processing vertices with GPU (get)      */
	kCGLCPGPUFragmentProcessing OPENGL_ENUM_AVAILABLE(10_4)  = 311, /* 1 param.   Currently processing fragments with GPU (get)     */
	kCGLCPHasDrawable OPENGL_ENUM_AVAILABLE(10_5)            = 314, /* 1 param.   Boolean returned if drawable is attached			*/
	kCGLCPMPSwapsInFlight OPENGL_ENUM_AVAILABLE(10_5)        = 315, /* 1 param.   Max number of swaps queued by the MP GL engine	*/
	kCGLCPGPURestartStatus OPENGL_ENUM_AVAILABLE(10_10)      = 317, /* 1 param.   Retrieves and clears the current CGLGPURestartStatus */
	kCGLCPAbortOnGPURestartStatusBlacklisted OPENGL_ENUM_AVAILABLE(10_10) = 318, /* 1 param.  Establish action to take upon blacklisting */
	kCGLCPSupportGPURestart OPENGL_ENUM_AVAILABLE(10_10)     = 319, /* 1 param.   Does driver support auto-restart of GPU on hang/crash? */
	kCGLCPSupportSeparateAddressSpace OPENGL_ENUM_AVAILABLE(10_10) = 320, /* 1 param. Does context get its own GPU address space?   */
	kCGLCPContextPriorityRequest OPENGL_ENUM_AVAILABLE(10_10) = 608, /* 1 param. kCGLCPContextPriorityRequest[High|Normal|Low] 0|1|2 */
} CGLContextParameter;

typedef enum
{
	kCGLCPContextPriorityRequestHigh   = 0,
	kCGLCPContextPriorityRequestNormal = 1,
	kCGLCPContextPriorityRequestLow    = 2
} CGLCPContextPriorityRequest;

/*
** Option names for CGLSetOption and CGLGetOption.
*/
typedef enum _CGLGlobalOption {
	kCGLGOFormatCacheSize                           = 501, /* Set the size of the pixel format cache        */
	kCGLGOClearFormatCache                          = 502, /* Reset the pixel format cache if true          */
	kCGLGORetainRenderers                           = 503, /* Whether to retain loaded renderers in memory  */
	kCGLGOUseBuildCache OPENGL_ENUM_AVAILABLE(10_5) = 506, /* Enable the function compilation block cache.  */
	                                                       /* Off by default.  Must be enabled at startup.  */
	
	kCGLGOResetLibrary OPENGL_ENUM_DEPRECATED(10_0, 10_4)     = 504,
	kCGLGOUseErrorHandler OPENGL_ENUM_DEPRECATED(10_0, 10_7)  = 505,
} CGLGlobalOption;

/*
** OpenGL Implementation Profiles
*/
typedef enum _CGLOpenGLProfile {
	kCGLOGLPVersion_Legacy OPENGL_ENUM_AVAILABLE(10_7)   = 0x1000, /* choose a renderer compatible with GL1.0       */
	kCGLOGLPVersion_3_2_Core OPENGL_ENUM_AVAILABLE(10_7) = 0x3200, /* choose a renderer capable of GL3.2 or later   */
	kCGLOGLPVersion_GL3_Core OPENGL_ENUM_AVAILABLE(10_7) = 0x3200, /* choose a renderer capable of GL3.2 or later   */
	kCGLOGLPVersion_GL4_Core OPENGL_ENUM_AVAILABLE(10_9) = 0x4100, /* choose a renderer capable of GL4.1 or later   */
} CGLOpenGLProfile OPENGL_AVAILABLE(10_7);

/*
** Error return values from CGLGetError.
*/
typedef enum _CGLError {
	kCGLNoError            = 0,     /* no error */
	kCGLBadAttribute       = 10000,	/* invalid pixel format attribute  */
	kCGLBadProperty        = 10001,	/* invalid renderer property       */
	kCGLBadPixelFormat     = 10002,	/* invalid pixel format            */
	kCGLBadRendererInfo    = 10003,	/* invalid renderer info           */
	kCGLBadContext         = 10004,	/* invalid context                 */
	kCGLBadDrawable        = 10005,	/* invalid drawable                */
	kCGLBadDisplay         = 10006,	/* invalid graphics device         */
	kCGLBadState           = 10007,	/* invalid context state           */
	kCGLBadValue           = 10008,	/* invalid numerical value         */
	kCGLBadMatch           = 10009,	/* invalid share context           */
	kCGLBadEnumeration     = 10010,	/* invalid enumerant               */
	kCGLBadOffScreen       = 10011,	/* invalid offscreen drawable      */
	kCGLBadFullScreen      = 10012,	/* invalid fullscreen drawable     */
	kCGLBadWindow          = 10013,	/* invalid window                  */
	kCGLBadAddress         = 10014,	/* invalid pointer                 */
	kCGLBadCodeModule      = 10015,	/* invalid code module             */
	kCGLBadAlloc           = 10016,	/* invalid memory allocation       */
	kCGLBadConnection      = 10017 	/* invalid CoreGraphics connection */
} CGLError;


/* 
** Buffer modes
*/
#define kCGLMonoscopicBit   0x00000001
#define kCGLStereoscopicBit 0x00000002
#define kCGLSingleBufferBit 0x00000004
#define kCGLDoubleBufferBit 0x00000008
#define kCGLTripleBufferBit 0x00000010

/*
** Depth and stencil buffer depths
*/
#define kCGL0Bit            0x00000001
#define kCGL1Bit            0x00000002
#define kCGL2Bit            0x00000004
#define kCGL3Bit            0x00000008
#define kCGL4Bit            0x00000010
#define kCGL5Bit            0x00000020
#define kCGL6Bit            0x00000040
#define kCGL8Bit            0x00000080
#define kCGL10Bit           0x00000100
#define kCGL12Bit           0x00000200
#define kCGL16Bit           0x00000400
#define kCGL24Bit           0x00000800
#define kCGL32Bit           0x00001000
#define kCGL48Bit           0x00002000
#define kCGL64Bit           0x00004000
#define kCGL96Bit           0x00008000
#define kCGL128Bit          0x00010000

/*
** Color and accumulation buffer formats.
*/
#define kCGLRGB444Bit       0x00000040  /* 16 rgb bit/pixel,    R=11:8, G=7:4, B=3:0              */
#define kCGLARGB4444Bit     0x00000080  /* 16 argb bit/pixel,   A=15:12, R=11:8, G=7:4, B=3:0     */
#define kCGLRGB444A8Bit     0x00000100  /* 8-16 argb bit/pixel, A=7:0, R=11:8, G=7:4, B=3:0       */
#define kCGLRGB555Bit       0x00000200  /* 16 rgb bit/pixel,    R=14:10, G=9:5, B=4:0             */
#define kCGLARGB1555Bit     0x00000400  /* 16 argb bit/pixel,   A=15, R=14:10, G=9:5, B=4:0       */
#define kCGLRGB555A8Bit     0x00000800  /* 8-16 argb bit/pixel, A=7:0, R=14:10, G=9:5, B=4:0      */
#define kCGLRGB565Bit       0x00001000  /* 16 rgb bit/pixel,    R=15:11, G=10:5, B=4:0            */
#define kCGLRGB565A8Bit     0x00002000  /* 8-16 argb bit/pixel, A=7:0, R=15:11, G=10:5, B=4:0     */
#define kCGLRGB888Bit       0x00004000  /* 32 rgb bit/pixel,    R=23:16, G=15:8, B=7:0            */
#define kCGLARGB8888Bit     0x00008000  /* 32 argb bit/pixel,   A=31:24, R=23:16, G=15:8, B=7:0   */
#define kCGLRGB888A8Bit     0x00010000  /* 8-32 argb bit/pixel, A=7:0, R=23:16, G=15:8, B=7:0     */
#define kCGLRGB101010Bit    0x00020000  /* 32 rgb bit/pixel,    R=29:20, G=19:10, B=9:0           */
#define kCGLARGB2101010Bit  0x00040000  /* 32 argb bit/pixel,   A=31:30  R=29:20, G=19:10, B=9:0  */
#define kCGLRGB101010_A8Bit 0x00080000  /* 8-32 argb bit/pixel, A=7:0  R=29:20, G=19:10, B=9:0    */
#define kCGLRGB121212Bit    0x00100000  /* 48 rgb bit/pixel,    R=35:24, G=23:12, B=11:0          */
#define kCGLARGB12121212Bit 0x00200000  /* 48 argb bit/pixel,   A=47:36, R=35:24, G=23:12, B=11:0 */
#define kCGLRGB161616Bit    0x00400000  /* 64 rgb bit/pixel,    R=63:48, G=47:32, B=31:16         */
#define kCGLRGBA16161616Bit 0x00800000  /* 64 argb bit/pixel,   R=63:48, G=47:32, B=31:16, A=15:0 */
#define kCGLRGBFloat64Bit   0x01000000  /* 64 rgb bit/pixel,    half float                        */
#define kCGLRGBAFloat64Bit  0x02000000  /* 64 argb bit/pixel,   half float                        */
#define kCGLRGBFloat128Bit  0x04000000  /* 128 rgb bit/pixel,   ieee float                        */
#define kCGLRGBAFloat128Bit 0x08000000  /* 128 argb bit/pixel,  ieee float                        */
#define kCGLRGBFloat256Bit  0x10000000  /* 256 rgb bit/pixel,   ieee double                       */
#define kCGLRGBAFloat256Bit 0x20000000  /* 256 argb bit/pixel,  ieee double                       */

/*
** Sampling modes
*/
#define kCGLSupersampleBit 0x00000001
#define kCGLMultisampleBit 0x00000002

/* Obsolete */
#define kCGLARGB16161616Bit kCGLRGBA16161616Bit


#ifdef __cplusplus
}
#endif

#endif /* _CGLTYPES_H */
                                                           OpenGL.h                                                                                            0100644 0001750 0001750 00000013071 12567471557 032262  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers                                                                      /*
	Copyright:	(c) 1999-2012 Apple Inc. All rights reserved.
*/

#ifndef _OPENGL_H
#define _OPENGL_H

#include <OpenGL/OpenGLAvailability.h>
#include <OpenGL/CGLCurrent.h>
#include <OpenGL/CGLDevice.h>
#include <OpenGL/CGLRenderers.h>
#include <OpenGL/CGLIOSurface.h>
#include <OpenGL/gltypes.h>

#ifdef __cplusplus
extern "C" {
#endif

OPENGL_ASSUME_NONNULL_BEGIN

/*
** CGL API version.
*/
#define CGL_VERSION_1_0  1
#define CGL_VERSION_1_1  1
#define CGL_VERSION_1_2  1
#define CGL_VERSION_1_3  1

/*
** Pixel format functions
*/
extern CGLError CGLChoosePixelFormat(const CGLPixelFormatAttribute *attribs, CGLPixelFormatObj OPENGL_NULLABLE * OPENGL_NONNULL pix, GLint *npix);
extern CGLError CGLDestroyPixelFormat(CGLPixelFormatObj pix);
extern CGLError CGLDescribePixelFormat(CGLPixelFormatObj pix, GLint pix_num, CGLPixelFormatAttribute attrib, GLint *value);
extern void CGLReleasePixelFormat(CGLPixelFormatObj pix) OPENGL_AVAILABLE(10_5);
extern CGLPixelFormatObj CGLRetainPixelFormat(CGLPixelFormatObj pix) OPENGL_AVAILABLE(10_5);
extern GLuint CGLGetPixelFormatRetainCount(CGLPixelFormatObj pix) OPENGL_AVAILABLE(10_5);

/*
** Renderer information functions
*/
extern CGLError CGLQueryRendererInfo(GLuint display_mask, CGLRendererInfoObj OPENGL_NULLABLE * OPENGL_NONNULL rend, GLint *nrend);
extern CGLError CGLDestroyRendererInfo(CGLRendererInfoObj rend);
extern CGLError CGLDescribeRenderer(CGLRendererInfoObj rend, GLint rend_num, CGLRendererProperty prop, GLint * OPENGL_NULLABLE value);

/*
** Context functions
*/
extern CGLError CGLCreateContext(CGLPixelFormatObj pix, CGLContextObj OPENGL_NULLABLE share, CGLContextObj OPENGL_NULLABLE * OPENGL_NONNULL ctx);
extern CGLError CGLDestroyContext(CGLContextObj ctx);
extern CGLError CGLCopyContext(CGLContextObj src, CGLContextObj dst, GLbitfield mask) OPENGL_DEPRECATED(10_0, 10_8);
extern CGLContextObj CGLRetainContext(CGLContextObj ctx) OPENGL_AVAILABLE(10_5);
extern void CGLReleaseContext(CGLContextObj ctx) OPENGL_AVAILABLE(10_5);
extern GLuint CGLGetContextRetainCount(CGLContextObj ctx) OPENGL_AVAILABLE(10_5);
extern CGLPixelFormatObj OPENGL_NULLABLE CGLGetPixelFormat(CGLContextObj ctx) OPENGL_AVAILABLE(10_5);

/*
** PBuffer functions
*/
extern CGLError CGLCreatePBuffer(GLsizei width, GLsizei height, GLenum target, GLenum internalFormat, GLint max_level, CGLPBufferObj OPENGL_NULLABLE * OPENGL_NONNULL pbuffer) OPENGL_DEPRECATED(10_3, 10_7);
extern CGLError CGLDestroyPBuffer(CGLPBufferObj pbuffer) OPENGL_DEPRECATED(10_3, 10_7);
extern CGLError CGLDescribePBuffer(CGLPBufferObj obj, GLsizei *width, GLsizei *height, GLenum *target, GLenum *internalFormat, GLint *mipmap) OPENGL_DEPRECATED(10_3, 10_7);
extern CGLError CGLTexImagePBuffer(CGLContextObj ctx, CGLPBufferObj pbuffer, GLenum source) OPENGL_DEPRECATED(10_3, 10_7);
extern CGLPBufferObj CGLRetainPBuffer(CGLPBufferObj pbuffer) OPENGL_DEPRECATED(10_5, 10_7);
extern void CGLReleasePBuffer(CGLPBufferObj pbuffer) OPENGL_DEPRECATED(10_5, 10_7);
extern GLuint CGLGetPBufferRetainCount(CGLPBufferObj pbuffer) OPENGL_DEPRECATED(10_5, 10_7);

/*
** Drawable Functions
*/
extern CGLError CGLSetOffScreen(CGLContextObj ctx, GLsizei width, GLsizei height, GLint rowbytes, void *baseaddr) OPENGL_DEPRECATED(10_0, 10_7);
extern CGLError CGLGetOffScreen(CGLContextObj ctx, GLsizei *width, GLsizei *height, GLint *rowbytes, void * OPENGL_NULLABLE * OPENGL_NONNULL baseaddr) OPENGL_DEPRECATED(10_0, 10_7);
extern CGLError CGLSetFullScreen(CGLContextObj ctx) OPENGL_DEPRECATED(10_0, 10_6);
extern CGLError CGLSetFullScreenOnDisplay(CGLContextObj ctx, GLuint display_mask) OPENGL_DEPRECATED(10_5, 10_7);

extern CGLError CGLSetPBuffer(CGLContextObj ctx, CGLPBufferObj pbuffer, GLenum face, GLint level, GLint screen) OPENGL_DEPRECATED(10_3, 10_7);
extern CGLError CGLGetPBuffer(CGLContextObj ctx, CGLPBufferObj OPENGL_NULLABLE * OPENGL_NONNULL pbuffer, GLenum *face, GLint *level, GLint *screen) OPENGL_DEPRECATED(10_3, 10_7);

extern CGLError CGLClearDrawable(CGLContextObj ctx);
extern CGLError CGLFlushDrawable(CGLContextObj ctx);

/*
** Per context enables and parameters
*/
extern CGLError CGLEnable(CGLContextObj ctx, CGLContextEnable pname);
extern CGLError CGLDisable(CGLContextObj ctx, CGLContextEnable pname);
extern CGLError CGLIsEnabled(CGLContextObj ctx, CGLContextEnable pname, GLint *enable);
extern CGLError CGLSetParameter(CGLContextObj ctx, CGLContextParameter pname, const GLint *params);
extern CGLError CGLGetParameter(CGLContextObj ctx, CGLContextParameter pname, GLint *params);

/*
** Virtual screen functions
*/
extern CGLError CGLSetVirtualScreen(CGLContextObj ctx, GLint screen);
extern CGLError CGLGetVirtualScreen(CGLContextObj ctx, GLint *screen);

extern CGLError CGLUpdateContext(CGLContextObj ctx) OPENGL_AVAILABLE(10_7);

/*
** Global library options
*/
extern CGLError CGLSetGlobalOption(CGLGlobalOption pname, const GLint * OPENGL_NULLABLE params) OPENGL_AVAILABLE(10_6);
extern CGLError CGLGetGlobalOption(CGLGlobalOption pname, GLint *params) OPENGL_AVAILABLE(10_6);

extern CGLError CGLSetOption(CGLGlobalOption pname, GLint param);  /* Use CGLSetGlobalOption */
extern CGLError CGLGetOption(CGLGlobalOption pname, GLint *param); /* Use CGLGetGlobalOption */

/*
** Locking functions
*/
extern CGLError CGLLockContext(CGLContextObj ctx) OPENGL_AVAILABLE(10_4);

extern CGLError CGLUnlockContext(CGLContextObj ctx) OPENGL_AVAILABLE(10_4);

/*
** Version numbers
*/
extern void CGLGetVersion(GLint * OPENGL_NULLABLE majorvers, GLint * OPENGL_NULLABLE minorvers);

/*
** Convert an error code to a string
*/
const char *CGLErrorString(CGLError error);

OPENGL_ASSUME_NONNULL_END

#ifdef __cplusplus
}
#endif

#endif /* _OPENGL_H */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                       OpenGLAvailability.h                                                                                0100644 0001750 0001750 00000001623 12567471557 034615  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers                                                                      #ifndef _OpenGLAvailability_H
#define _OpenGLAvailability_H

#include <Availability.h>

#if !defined(__has_extension)
	#define __has_extension(x) 0
#endif

#define OPENGL_AVAILABLE(from) __OSX_AVAILABLE_STARTING(__MAC_##from, __IPHONE_NA)
#define OPENGL_DEPRECATED(from, to) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_##from, __MAC_##to, __IPHONE_NA, __IPHONE_NA)
#define OPENGL_DEPRECATED_MSG(from, to, msg) __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_##from, __MAC_##to, __IPHONE_NA, __IPHONE_NA, "" #msg "")

#if __has_extension(enumerator_attributes)
	#define OPENGL_ENUM_AVAILABLE(from) OPENGL_AVAILABLE(from)
	#define OPENGL_ENUM_DEPRECATED(from, to) OPENGL_DEPRECATED(from, to)
	#define OPENGL_ENUM_DEPRECATED_MSG(from, to, msg) OPENGL_DEPRECATED_MSG(from, to, msg)
#else
	#define OPENGL_ENUM_AVAILABLE(from)
	#define OPENGL_ENUM_DEPRECATED(from, to)
	#define OPENGL_ENUM_DEPRECATED_MSG(from, to, msg)
#endif

#endif
                                                                                                             gl.h                                                                                                0100644 0001750 0001750 00000452072 12567471555 031546  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers                                                                      #ifndef __gl_h_
#define __gl_h_

#if defined __gl3_h_ && !(defined GL_DO_NOT_WARN_IF_MULTI_GL_VERSION_HEADERS_INCLUDED)
#warning gl.h and gl3.h are both included.  Compiler will not invoke errors if using removed OpenGL functionality.
#endif

/*
** License Applicability. Except to the extent portions of this file are
** made subject to an alternative license as permitted in the SGI Free
** Software License B, Version 1.1 (the "License"), the contents of this
** file are subject only to the provisions of the License. You may not use
** this file except in compliance with the License. You may obtain a copy
** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
** 
** http://oss.sgi.com/projects/FreeB
** 
** Note that, as provided in the License, the Software is distributed on an
** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
** 
** Original Code. The Original Code is: OpenGL Sample Implementation,
** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
** Copyright in any portions created by third parties is as indicated
** elsewhere herein. All Rights Reserved.
** 
** Additional Notice Provisions: This software was created using the
** OpenGL(R) version 1.2.1 Sample Implementation published by SGI, but has
** not been independently verified as being compliant with the OpenGL(R)
** version 1.2.1 Specification.
*/

// switches to providing function pointers
//#define GL_GLEXT_FUNCTION_POINTERS 1

#include <OpenGL/gltypes.h>
	
#ifndef GL_GLEXT_LEGACY
#include <OpenGL/glext.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* For compatibility with OpenGL v1.0 */
#define GL_LOGIC_OP GL_INDEX_LOGIC_OP
#define GL_TEXTURE_COMPONENTS GL_TEXTURE_INTERNAL_FORMAT

/*************************************************************/

/* Version */
#define GL_VERSION_1_1                    1
#define GL_VERSION_1_2                    1
#define GL_VERSION_1_3                    1
#define GL_VERSION_1_4                    1
#define GL_VERSION_1_5                    1
#define GL_VERSION_2_0                    1
#define GL_VERSION_2_1                    1

/* AccumOp */
#define GL_ACCUM                          0x0100
#define GL_LOAD                           0x0101
#define GL_RETURN                         0x0102
#define GL_MULT                           0x0103
#define GL_ADD                            0x0104

/* AlphaFunction */
#define GL_NEVER                          0x0200
#define GL_LESS                           0x0201
#define GL_EQUAL                          0x0202
#define GL_LEQUAL                         0x0203
#define GL_GREATER                        0x0204
#define GL_NOTEQUAL                       0x0205
#define GL_GEQUAL                         0x0206
#define GL_ALWAYS                         0x0207

/* AttribMask */
#define GL_CURRENT_BIT                    0x00000001
#define GL_POINT_BIT                      0x00000002
#define GL_LINE_BIT                       0x00000004
#define GL_POLYGON_BIT                    0x00000008
#define GL_POLYGON_STIPPLE_BIT            0x00000010
#define GL_PIXEL_MODE_BIT                 0x00000020
#define GL_LIGHTING_BIT                   0x00000040
#define GL_FOG_BIT                        0x00000080
#define GL_DEPTH_BUFFER_BIT               0x00000100
#define GL_ACCUM_BUFFER_BIT               0x00000200
#define GL_STENCIL_BUFFER_BIT             0x00000400
#define GL_VIEWPORT_BIT                   0x00000800
#define GL_TRANSFORM_BIT                  0x00001000
#define GL_ENABLE_BIT                     0x00002000
#define GL_COLOR_BUFFER_BIT               0x00004000
#define GL_HINT_BIT                       0x00008000
#define GL_EVAL_BIT                       0x00010000
#define GL_LIST_BIT                       0x00020000
#define GL_TEXTURE_BIT                    0x00040000
#define GL_SCISSOR_BIT                    0x00080000
#define GL_ALL_ATTRIB_BITS                0x000fffff

/* BeginMode */
#define GL_POINTS                         0x0000
#define GL_LINES                          0x0001
#define GL_LINE_LOOP                      0x0002
#define GL_LINE_STRIP                     0x0003
#define GL_TRIANGLES                      0x0004
#define GL_TRIANGLE_STRIP                 0x0005
#define GL_TRIANGLE_FAN                   0x0006
#define GL_QUADS                          0x0007
#define GL_QUAD_STRIP                     0x0008
#define GL_POLYGON                        0x0009

/* BlendEquationMode */
/*      GL_LOGIC_OP */
/*      GL_FUNC_ADD */
/*      GL_MIN */
/*      GL_MAX */
/*      GL_FUNC_SUBTRACT */
/*      GL_FUNC_REVERSE_SUBTRACT */

/* BlendingFactorDest */
#define GL_ZERO                           0
#define GL_ONE                            1
#define GL_SRC_COLOR                      0x0300
#define GL_ONE_MINUS_SRC_COLOR            0x0301
#define GL_SRC_ALPHA                      0x0302
#define GL_ONE_MINUS_SRC_ALPHA            0x0303
#define GL_DST_ALPHA                      0x0304
#define GL_ONE_MINUS_DST_ALPHA            0x0305
/*      GL_CONSTANT_COLOR */
/*      GL_ONE_MINUS_CONSTANT_COLOR */
/*      GL_CONSTANT_ALPHA */
/*      GL_ONE_MINUS_CONSTANT_ALPHA */

/* BlendingFactorSrc */
/*      GL_ZERO */
/*      GL_ONE */
#define GL_DST_COLOR                      0x0306
#define GL_ONE_MINUS_DST_COLOR            0x0307
#define GL_SRC_ALPHA_SATURATE             0x0308
/*      GL_SRC_ALPHA */
/*      GL_ONE_MINUS_SRC_ALPHA */
/*      GL_DST_ALPHA */
/*      GL_ONE_MINUS_DST_ALPHA */
/*      GL_CONSTANT_COLOR */
/*      GL_ONE_MINUS_CONSTANT_COLOR */
/*      GL_CONSTANT_ALPHA */
/*      GL_ONE_MINUS_CONSTANT_ALPHA */

/* Boolean */
#define GL_TRUE                           1
#define GL_FALSE                          0

/* ClearBufferMask */
/*      GL_COLOR_BUFFER_BIT */
/*      GL_ACCUM_BUFFER_BIT */
/*      GL_STENCIL_BUFFER_BIT */
/*      GL_DEPTH_BUFFER_BIT */

/* ClientArrayType */
/*      GL_VERTEX_ARRAY */
/*      GL_NORMAL_ARRAY */
/*      GL_COLOR_ARRAY */
/*      GL_INDEX_ARRAY */
/*      GL_TEXTURE_COORD_ARRAY */
/*      GL_EDGE_FLAG_ARRAY */

/* ClipPlaneName */
#define GL_CLIP_PLANE0                    0x3000
#define GL_CLIP_PLANE1                    0x3001
#define GL_CLIP_PLANE2                    0x3002
#define GL_CLIP_PLANE3                    0x3003
#define GL_CLIP_PLANE4                    0x3004
#define GL_CLIP_PLANE5                    0x3005

/* ColorMaterialFace */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_FRONT_AND_BACK */

/* ColorMaterialParameter */
/*      GL_AMBIENT */
/*      GL_DIFFUSE */
/*      GL_SPECULAR */
/*      GL_EMISSION */
/*      GL_AMBIENT_AND_DIFFUSE */

/* ColorPointerType */
/*      GL_BYTE */
/*      GL_UNSIGNED_BYTE */
/*      GL_SHORT */
/*      GL_UNSIGNED_SHORT */
/*      GL_INT */
/*      GL_UNSIGNED_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* ColorTableParameterPName */
/*      GL_COLOR_TABLE_SCALE */
/*      GL_COLOR_TABLE_BIAS */

/* ColorTableTarget */
/*      GL_COLOR_TABLE */
/*      GL_POST_CONVOLUTION_COLOR_TABLE */
/*      GL_POST_COLOR_MATRIX_COLOR_TABLE */
/*      GL_PROXY_COLOR_TABLE */
/*      GL_PROXY_POST_CONVOLUTION_COLOR_TABLE */
/*      GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE */

/* ConvolutionBorderMode */
/*      GL_REDUCE */
/*      GL_IGNORE_BORDER */
/*      GL_CONSTANT_BORDER */

/* ConvolutionParameter */
/*      GL_CONVOLUTION_BORDER_MODE */
/*      GL_CONVOLUTION_FILTER_SCALE */
/*      GL_CONVOLUTION_FILTER_BIAS */

/* ConvolutionTarget */
/*      GL_CONVOLUTION_1D */
/*      GL_CONVOLUTION_2D */

/* CullFaceMode */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_FRONT_AND_BACK */

/* DataType */
#define GL_BYTE                           0x1400
#define GL_UNSIGNED_BYTE                  0x1401
#define GL_SHORT                          0x1402
#define GL_UNSIGNED_SHORT                 0x1403
#define GL_INT                            0x1404
#define GL_UNSIGNED_INT                   0x1405
#define GL_FLOAT                          0x1406
#define GL_2_BYTES                        0x1407
#define GL_3_BYTES                        0x1408
#define GL_4_BYTES                        0x1409
#define GL_DOUBLE                         0x140A

/* DepthFunction */
/*      GL_NEVER */
/*      GL_LESS */
/*      GL_EQUAL */
/*      GL_LEQUAL */
/*      GL_GREATER */
/*      GL_NOTEQUAL */
/*      GL_GEQUAL */
/*      GL_ALWAYS */

/* DrawBufferMode */
#define GL_NONE                           0
#define GL_FRONT_LEFT                     0x0400
#define GL_FRONT_RIGHT                    0x0401
#define GL_BACK_LEFT                      0x0402
#define GL_BACK_RIGHT                     0x0403
#define GL_FRONT                          0x0404
#define GL_BACK                           0x0405
#define GL_LEFT                           0x0406
#define GL_RIGHT                          0x0407
#define GL_FRONT_AND_BACK                 0x0408
#define GL_AUX0                           0x0409
#define GL_AUX1                           0x040A
#define GL_AUX2                           0x040B
#define GL_AUX3                           0x040C

/* Enable */
/*      GL_FOG */
/*      GL_LIGHTING */
/*      GL_TEXTURE_1D */
/*      GL_TEXTURE_2D */
/*      GL_LINE_STIPPLE */
/*      GL_POLYGON_STIPPLE */
/*      GL_CULL_FACE */
/*      GL_ALPHA_TEST */
/*      GL_BLEND */
/*      GL_INDEX_LOGIC_OP */
/*      GL_COLOR_LOGIC_OP */
/*      GL_DITHER */
/*      GL_STENCIL_TEST */
/*      GL_DEPTH_TEST */
/*      GL_CLIP_PLANE0 */
/*      GL_CLIP_PLANE1 */
/*      GL_CLIP_PLANE2 */
/*      GL_CLIP_PLANE3 */
/*      GL_CLIP_PLANE4 */
/*      GL_CLIP_PLANE5 */
/*      GL_LIGHT0 */
/*      GL_LIGHT1 */
/*      GL_LIGHT2 */
/*      GL_LIGHT3 */
/*      GL_LIGHT4 */
/*      GL_LIGHT5 */
/*      GL_LIGHT6 */
/*      GL_LIGHT7 */
/*      GL_TEXTURE_GEN_S */
/*      GL_TEXTURE_GEN_T */
/*      GL_TEXTURE_GEN_R */
/*      GL_TEXTURE_GEN_Q */
/*      GL_MAP1_VERTEX_3 */
/*      GL_MAP1_VERTEX_4 */
/*      GL_MAP1_COLOR_4 */
/*      GL_MAP1_INDEX */
/*      GL_MAP1_NORMAL */
/*      GL_MAP1_TEXTURE_COORD_1 */
/*      GL_MAP1_TEXTURE_COORD_2 */
/*      GL_MAP1_TEXTURE_COORD_3 */
/*      GL_MAP1_TEXTURE_COORD_4 */
/*      GL_MAP2_VERTEX_3 */
/*      GL_MAP2_VERTEX_4 */
/*      GL_MAP2_COLOR_4 */
/*      GL_MAP2_INDEX */
/*      GL_MAP2_NORMAL */
/*      GL_MAP2_TEXTURE_COORD_1 */
/*      GL_MAP2_TEXTURE_COORD_2 */
/*      GL_MAP2_TEXTURE_COORD_3 */
/*      GL_MAP2_TEXTURE_COORD_4 */
/*      GL_POINT_SMOOTH */
/*      GL_LINE_SMOOTH */
/*      GL_POLYGON_SMOOTH */
/*      GL_SCISSOR_TEST */
/*      GL_COLOR_MATERIAL */
/*      GL_NORMALIZE */
/*      GL_AUTO_NORMAL */
/*      GL_VERTEX_ARRAY */
/*      GL_NORMAL_ARRAY */
/*      GL_COLOR_ARRAY */
/*      GL_INDEX_ARRAY */
/*      GL_TEXTURE_COORD_ARRAY */
/*      GL_EDGE_FLAG_ARRAY */
/*      GL_POLYGON_OFFSET_POINT */
/*      GL_POLYGON_OFFSET_LINE */
/*      GL_POLYGON_OFFSET_FILL */
/*      GL_COLOR_TABLE */
/*      GL_POST_CONVOLUTION_COLOR_TABLE */
/*      GL_POST_COLOR_MATRIX_COLOR_TABLE */
/*      GL_CONVOLUTION_1D */
/*      GL_CONVOLUTION_2D */
/*      GL_SEPARABLE_2D */
/*      GL_HISTOGRAM */
/*      GL_MINMAX */
/*      GL_RESCALE_NORMAL */
/*      GL_TEXTURE_3D */

/* ErrorCode */
#define GL_NO_ERROR                       0
#define GL_INVALID_ENUM                   0x0500
#define GL_INVALID_VALUE                  0x0501
#define GL_INVALID_OPERATION              0x0502
#define GL_STACK_OVERFLOW                 0x0503
#define GL_STACK_UNDERFLOW                0x0504
#define GL_OUT_OF_MEMORY                  0x0505
/*      GL_TABLE_TOO_LARGE */

/* FeedBackMode */
#define GL_2D                             0x0600
#define GL_3D                             0x0601
#define GL_3D_COLOR                       0x0602
#define GL_3D_COLOR_TEXTURE               0x0603
#define GL_4D_COLOR_TEXTURE               0x0604

/* FeedBackToken */
#define GL_PASS_THROUGH_TOKEN             0x0700
#define GL_POINT_TOKEN                    0x0701
#define GL_LINE_TOKEN                     0x0702
#define GL_POLYGON_TOKEN                  0x0703
#define GL_BITMAP_TOKEN                   0x0704
#define GL_DRAW_PIXEL_TOKEN               0x0705
#define GL_COPY_PIXEL_TOKEN               0x0706
#define GL_LINE_RESET_TOKEN               0x0707

/* FogMode */
/*      GL_LINEAR */
#define GL_EXP                            0x0800
#define GL_EXP2                           0x0801

/* FogParameter */
/*      GL_FOG_COLOR */
/*      GL_FOG_DENSITY */
/*      GL_FOG_END */
/*      GL_FOG_INDEX */
/*      GL_FOG_MODE */
/*      GL_FOG_START */

/* FrontFaceDirection */
#define GL_CW                             0x0900
#define GL_CCW                            0x0901

/* GetColorTableParameterPName */
/*      GL_COLOR_TABLE_SCALE */
/*      GL_COLOR_TABLE_BIAS */
/*      GL_COLOR_TABLE_FORMAT */
/*      GL_COLOR_TABLE_WIDTH */
/*      GL_COLOR_TABLE_RED_SIZE */
/*      GL_COLOR_TABLE_GREEN_SIZE */
/*      GL_COLOR_TABLE_BLUE_SIZE */
/*      GL_COLOR_TABLE_ALPHA_SIZE */
/*      GL_COLOR_TABLE_LUMINANCE_SIZE */
/*      GL_COLOR_TABLE_INTENSITY_SIZE */

/* GetConvolutionParameterPName */
/*      GL_CONVOLUTION_BORDER_COLOR */
/*      GL_CONVOLUTION_BORDER_MODE */
/*      GL_CONVOLUTION_FILTER_SCALE */
/*      GL_CONVOLUTION_FILTER_BIAS */
/*      GL_CONVOLUTION_FORMAT */
/*      GL_CONVOLUTION_WIDTH */
/*      GL_CONVOLUTION_HEIGHT */
/*      GL_MAX_CONVOLUTION_WIDTH */
/*      GL_MAX_CONVOLUTION_HEIGHT */

/* GetHistogramParameterPName */
/*      GL_HISTOGRAM_WIDTH */
/*      GL_HISTOGRAM_FORMAT */
/*      GL_HISTOGRAM_RED_SIZE */
/*      GL_HISTOGRAM_GREEN_SIZE */
/*      GL_HISTOGRAM_BLUE_SIZE */
/*      GL_HISTOGRAM_ALPHA_SIZE */
/*      GL_HISTOGRAM_LUMINANCE_SIZE */
/*      GL_HISTOGRAM_SINK */

/* GetMapTarget */
#define GL_COEFF                          0x0A00
#define GL_ORDER                          0x0A01
#define GL_DOMAIN                         0x0A02

/* GetMinmaxParameterPName */
/*      GL_MINMAX_FORMAT */
/*      GL_MINMAX_SINK */

/* GetPixelMap */
/*      GL_PIXEL_MAP_I_TO_I */
/*      GL_PIXEL_MAP_S_TO_S */
/*      GL_PIXEL_MAP_I_TO_R */
/*      GL_PIXEL_MAP_I_TO_G */
/*      GL_PIXEL_MAP_I_TO_B */
/*      GL_PIXEL_MAP_I_TO_A */
/*      GL_PIXEL_MAP_R_TO_R */
/*      GL_PIXEL_MAP_G_TO_G */
/*      GL_PIXEL_MAP_B_TO_B */
/*      GL_PIXEL_MAP_A_TO_A */

/* GetPointerTarget */
/*      GL_VERTEX_ARRAY_POINTER */
/*      GL_NORMAL_ARRAY_POINTER */
/*      GL_COLOR_ARRAY_POINTER */
/*      GL_INDEX_ARRAY_POINTER */
/*      GL_TEXTURE_COORD_ARRAY_POINTER */
/*      GL_EDGE_FLAG_ARRAY_POINTER */

/* GetTarget */
#define GL_CURRENT_COLOR                  0x0B00
#define GL_CURRENT_INDEX                  0x0B01
#define GL_CURRENT_NORMAL                 0x0B02
#define GL_CURRENT_TEXTURE_COORDS         0x0B03
#define GL_CURRENT_RASTER_COLOR           0x0B04
#define GL_CURRENT_RASTER_INDEX           0x0B05
#define GL_CURRENT_RASTER_TEXTURE_COORDS  0x0B06
#define GL_CURRENT_RASTER_POSITION        0x0B07
#define GL_CURRENT_RASTER_POSITION_VALID  0x0B08
#define GL_CURRENT_RASTER_DISTANCE        0x0B09
#define GL_POINT_SMOOTH                   0x0B10
#define GL_POINT_SIZE                     0x0B11
#define GL_POINT_SIZE_RANGE               0x0B12
#define GL_POINT_SIZE_GRANULARITY         0x0B13
#define GL_LINE_SMOOTH                    0x0B20
#define GL_LINE_WIDTH                     0x0B21
#define GL_LINE_WIDTH_RANGE               0x0B22
#define GL_LINE_WIDTH_GRANULARITY         0x0B23
#define GL_LINE_STIPPLE                   0x0B24
#define GL_LINE_STIPPLE_PATTERN           0x0B25
#define GL_LINE_STIPPLE_REPEAT            0x0B26
/*      GL_SMOOTH_POINT_SIZE_RANGE */
/*      GL_SMOOTH_POINT_SIZE_GRANULARITY */
/*      GL_SMOOTH_LINE_WIDTH_RANGE */
/*      GL_SMOOTH_LINE_WIDTH_GRANULARITY */
/*      GL_ALIASED_POINT_SIZE_RANGE */
/*      GL_ALIASED_LINE_WIDTH_RANGE */
#define GL_LIST_MODE                      0x0B30
#define GL_MAX_LIST_NESTING               0x0B31
#define GL_LIST_BASE                      0x0B32
#define GL_LIST_INDEX                     0x0B33
#define GL_POLYGON_MODE                   0x0B40
#define GL_POLYGON_SMOOTH                 0x0B41
#define GL_POLYGON_STIPPLE                0x0B42
#define GL_EDGE_FLAG                      0x0B43
#define GL_CULL_FACE                      0x0B44
#define GL_CULL_FACE_MODE                 0x0B45
#define GL_FRONT_FACE                     0x0B46
#define GL_LIGHTING                       0x0B50
#define GL_LIGHT_MODEL_LOCAL_VIEWER       0x0B51
#define GL_LIGHT_MODEL_TWO_SIDE           0x0B52
#define GL_LIGHT_MODEL_AMBIENT            0x0B53
#define GL_SHADE_MODEL                    0x0B54
#define GL_COLOR_MATERIAL_FACE            0x0B55
#define GL_COLOR_MATERIAL_PARAMETER       0x0B56
#define GL_COLOR_MATERIAL                 0x0B57
#define GL_FOG                            0x0B60
#define GL_FOG_INDEX                      0x0B61
#define GL_FOG_DENSITY                    0x0B62
#define GL_FOG_START                      0x0B63
#define GL_FOG_END                        0x0B64
#define GL_FOG_MODE                       0x0B65
#define GL_FOG_COLOR                      0x0B66
#define GL_DEPTH_RANGE                    0x0B70
#define GL_DEPTH_TEST                     0x0B71
#define GL_DEPTH_WRITEMASK                0x0B72
#define GL_DEPTH_CLEAR_VALUE              0x0B73
#define GL_DEPTH_FUNC                     0x0B74
#define GL_ACCUM_CLEAR_VALUE              0x0B80
#define GL_STENCIL_TEST                   0x0B90
#define GL_STENCIL_CLEAR_VALUE            0x0B91
#define GL_STENCIL_FUNC                   0x0B92
#define GL_STENCIL_VALUE_MASK             0x0B93
#define GL_STENCIL_FAIL                   0x0B94
#define GL_STENCIL_PASS_DEPTH_FAIL        0x0B95
#define GL_STENCIL_PASS_DEPTH_PASS        0x0B96
#define GL_STENCIL_REF                    0x0B97
#define GL_STENCIL_WRITEMASK              0x0B98
#define GL_MATRIX_MODE                    0x0BA0
#define GL_NORMALIZE                      0x0BA1
#define GL_VIEWPORT                       0x0BA2
#define GL_MODELVIEW_STACK_DEPTH          0x0BA3
#define GL_PROJECTION_STACK_DEPTH         0x0BA4
#define GL_TEXTURE_STACK_DEPTH            0x0BA5
#define GL_MODELVIEW_MATRIX               0x0BA6
#define GL_PROJECTION_MATRIX              0x0BA7
#define GL_TEXTURE_MATRIX                 0x0BA8
#define GL_ATTRIB_STACK_DEPTH             0x0BB0
#define GL_CLIENT_ATTRIB_STACK_DEPTH      0x0BB1
#define GL_ALPHA_TEST                     0x0BC0
#define GL_ALPHA_TEST_FUNC                0x0BC1
#define GL_ALPHA_TEST_REF                 0x0BC2
#define GL_DITHER                         0x0BD0
#define GL_BLEND_DST                      0x0BE0
#define GL_BLEND_SRC                      0x0BE1
#define GL_BLEND                          0x0BE2
#define GL_LOGIC_OP_MODE                  0x0BF0
#define GL_INDEX_LOGIC_OP                 0x0BF1
#define GL_COLOR_LOGIC_OP                 0x0BF2
#define GL_AUX_BUFFERS                    0x0C00
#define GL_DRAW_BUFFER                    0x0C01
#define GL_READ_BUFFER                    0x0C02
#define GL_SCISSOR_BOX                    0x0C10
#define GL_SCISSOR_TEST                   0x0C11
#define GL_INDEX_CLEAR_VALUE              0x0C20
#define GL_INDEX_WRITEMASK                0x0C21
#define GL_COLOR_CLEAR_VALUE              0x0C22
#define GL_COLOR_WRITEMASK                0x0C23
#define GL_INDEX_MODE                     0x0C30
#define GL_RGBA_MODE                      0x0C31
#define GL_DOUBLEBUFFER                   0x0C32
#define GL_STEREO                         0x0C33
#define GL_RENDER_MODE                    0x0C40
#define GL_PERSPECTIVE_CORRECTION_HINT    0x0C50
#define GL_POINT_SMOOTH_HINT              0x0C51
#define GL_LINE_SMOOTH_HINT               0x0C52
#define GL_POLYGON_SMOOTH_HINT            0x0C53
#define GL_FOG_HINT                       0x0C54
#define GL_TEXTURE_GEN_S                  0x0C60
#define GL_TEXTURE_GEN_T                  0x0C61
#define GL_TEXTURE_GEN_R                  0x0C62
#define GL_TEXTURE_GEN_Q                  0x0C63
#define GL_PIXEL_MAP_I_TO_I               0x0C70
#define GL_PIXEL_MAP_S_TO_S               0x0C71
#define GL_PIXEL_MAP_I_TO_R               0x0C72
#define GL_PIXEL_MAP_I_TO_G               0x0C73
#define GL_PIXEL_MAP_I_TO_B               0x0C74
#define GL_PIXEL_MAP_I_TO_A               0x0C75
#define GL_PIXEL_MAP_R_TO_R               0x0C76
#define GL_PIXEL_MAP_G_TO_G               0x0C77
#define GL_PIXEL_MAP_B_TO_B               0x0C78
#define GL_PIXEL_MAP_A_TO_A               0x0C79
#define GL_PIXEL_MAP_I_TO_I_SIZE          0x0CB0
#define GL_PIXEL_MAP_S_TO_S_SIZE          0x0CB1
#define GL_PIXEL_MAP_I_TO_R_SIZE          0x0CB2
#define GL_PIXEL_MAP_I_TO_G_SIZE          0x0CB3
#define GL_PIXEL_MAP_I_TO_B_SIZE          0x0CB4
#define GL_PIXEL_MAP_I_TO_A_SIZE          0x0CB5
#define GL_PIXEL_MAP_R_TO_R_SIZE          0x0CB6
#define GL_PIXEL_MAP_G_TO_G_SIZE          0x0CB7
#define GL_PIXEL_MAP_B_TO_B_SIZE          0x0CB8
#define GL_PIXEL_MAP_A_TO_A_SIZE          0x0CB9
#define GL_UNPACK_SWAP_BYTES              0x0CF0
#define GL_UNPACK_LSB_FIRST               0x0CF1
#define GL_UNPACK_ROW_LENGTH              0x0CF2
#define GL_UNPACK_SKIP_ROWS               0x0CF3
#define GL_UNPACK_SKIP_PIXELS             0x0CF4
#define GL_UNPACK_ALIGNMENT               0x0CF5
#define GL_PACK_SWAP_BYTES                0x0D00
#define GL_PACK_LSB_FIRST                 0x0D01
#define GL_PACK_ROW_LENGTH                0x0D02
#define GL_PACK_SKIP_ROWS                 0x0D03
#define GL_PACK_SKIP_PIXELS               0x0D04
#define GL_PACK_ALIGNMENT                 0x0D05
#define GL_MAP_COLOR                      0x0D10
#define GL_MAP_STENCIL                    0x0D11
#define GL_INDEX_SHIFT                    0x0D12
#define GL_INDEX_OFFSET                   0x0D13
#define GL_RED_SCALE                      0x0D14
#define GL_RED_BIAS                       0x0D15
#define GL_ZOOM_X                         0x0D16
#define GL_ZOOM_Y                         0x0D17
#define GL_GREEN_SCALE                    0x0D18
#define GL_GREEN_BIAS                     0x0D19
#define GL_BLUE_SCALE                     0x0D1A
#define GL_BLUE_BIAS                      0x0D1B
#define GL_ALPHA_SCALE                    0x0D1C
#define GL_ALPHA_BIAS                     0x0D1D
#define GL_DEPTH_SCALE                    0x0D1E
#define GL_DEPTH_BIAS                     0x0D1F
#define GL_MAX_EVAL_ORDER                 0x0D30
#define GL_MAX_LIGHTS                     0x0D31
#define GL_MAX_CLIP_PLANES                0x0D32
#define GL_MAX_TEXTURE_SIZE               0x0D33
#define GL_MAX_PIXEL_MAP_TABLE            0x0D34
#define GL_MAX_ATTRIB_STACK_DEPTH         0x0D35
#define GL_MAX_MODELVIEW_STACK_DEPTH      0x0D36
#define GL_MAX_NAME_STACK_DEPTH           0x0D37
#define GL_MAX_PROJECTION_STACK_DEPTH     0x0D38
#define GL_MAX_TEXTURE_STACK_DEPTH        0x0D39
#define GL_MAX_VIEWPORT_DIMS              0x0D3A
#define GL_MAX_CLIENT_ATTRIB_STACK_DEPTH  0x0D3B
#define GL_SUBPIXEL_BITS                  0x0D50
#define GL_INDEX_BITS                     0x0D51
#define GL_RED_BITS                       0x0D52
#define GL_GREEN_BITS                     0x0D53
#define GL_BLUE_BITS                      0x0D54
#define GL_ALPHA_BITS                     0x0D55
#define GL_DEPTH_BITS                     0x0D56
#define GL_STENCIL_BITS                   0x0D57
#define GL_ACCUM_RED_BITS                 0x0D58
#define GL_ACCUM_GREEN_BITS               0x0D59
#define GL_ACCUM_BLUE_BITS                0x0D5A
#define GL_ACCUM_ALPHA_BITS               0x0D5B
#define GL_NAME_STACK_DEPTH               0x0D70
#define GL_AUTO_NORMAL                    0x0D80
#define GL_MAP1_COLOR_4                   0x0D90
#define GL_MAP1_INDEX                     0x0D91
#define GL_MAP1_NORMAL                    0x0D92
#define GL_MAP1_TEXTURE_COORD_1           0x0D93
#define GL_MAP1_TEXTURE_COORD_2           0x0D94
#define GL_MAP1_TEXTURE_COORD_3           0x0D95
#define GL_MAP1_TEXTURE_COORD_4           0x0D96
#define GL_MAP1_VERTEX_3                  0x0D97
#define GL_MAP1_VERTEX_4                  0x0D98
#define GL_MAP2_COLOR_4                   0x0DB0
#define GL_MAP2_INDEX                     0x0DB1
#define GL_MAP2_NORMAL                    0x0DB2
#define GL_MAP2_TEXTURE_COORD_1           0x0DB3
#define GL_MAP2_TEXTURE_COORD_2           0x0DB4
#define GL_MAP2_TEXTURE_COORD_3           0x0DB5
#define GL_MAP2_TEXTURE_COORD_4           0x0DB6
#define GL_MAP2_VERTEX_3                  0x0DB7
#define GL_MAP2_VERTEX_4                  0x0DB8
#define GL_MAP1_GRID_DOMAIN               0x0DD0
#define GL_MAP1_GRID_SEGMENTS             0x0DD1
#define GL_MAP2_GRID_DOMAIN               0x0DD2
#define GL_MAP2_GRID_SEGMENTS             0x0DD3
#define GL_TEXTURE_1D                     0x0DE0
#define GL_TEXTURE_2D                     0x0DE1
#define GL_FEEDBACK_BUFFER_POINTER        0x0DF0
#define GL_FEEDBACK_BUFFER_SIZE           0x0DF1
#define GL_FEEDBACK_BUFFER_TYPE           0x0DF2
#define GL_SELECTION_BUFFER_POINTER       0x0DF3
#define GL_SELECTION_BUFFER_SIZE          0x0DF4
/*      GL_TEXTURE_BINDING_1D */
/*      GL_TEXTURE_BINDING_2D */
/*      GL_TEXTURE_BINDING_3D */
/*      GL_VERTEX_ARRAY */
/*      GL_NORMAL_ARRAY */
/*      GL_COLOR_ARRAY */
/*      GL_INDEX_ARRAY */
/*      GL_TEXTURE_COORD_ARRAY */
/*      GL_EDGE_FLAG_ARRAY */
/*      GL_VERTEX_ARRAY_SIZE */
/*      GL_VERTEX_ARRAY_TYPE */
/*      GL_VERTEX_ARRAY_STRIDE */
/*      GL_NORMAL_ARRAY_TYPE */
/*      GL_NORMAL_ARRAY_STRIDE */
/*      GL_COLOR_ARRAY_SIZE */
/*      GL_COLOR_ARRAY_TYPE */
/*      GL_COLOR_ARRAY_STRIDE */
/*      GL_INDEX_ARRAY_TYPE */
/*      GL_INDEX_ARRAY_STRIDE */
/*      GL_TEXTURE_COORD_ARRAY_SIZE */
/*      GL_TEXTURE_COORD_ARRAY_TYPE */
/*      GL_TEXTURE_COORD_ARRAY_STRIDE */
/*      GL_EDGE_FLAG_ARRAY_STRIDE */
/*      GL_POLYGON_OFFSET_FACTOR */
/*      GL_POLYGON_OFFSET_UNITS */
/*      GL_COLOR_TABLE */
/*      GL_POST_CONVOLUTION_COLOR_TABLE */
/*      GL_POST_COLOR_MATRIX_COLOR_TABLE */
/*      GL_CONVOLUTION_1D */
/*      GL_CONVOLUTION_2D */
/*      GL_SEPARABLE_2D */
/*      GL_POST_CONVOLUTION_RED_SCALE */
/*      GL_POST_CONVOLUTION_GREEN_SCALE */
/*      GL_POST_CONVOLUTION_BLUE_SCALE */
/*      GL_POST_CONVOLUTION_ALPHA_SCALE */
/*      GL_POST_CONVOLUTION_RED_BIAS */
/*      GL_POST_CONVOLUTION_GREEN_BIAS */
/*      GL_POST_CONVOLUTION_BLUE_BIAS */
/*      GL_POST_CONVOLUTION_ALPHA_BIAS */
/*      GL_COLOR_MATRIX */
/*      GL_COLOR_MATRIX_STACK_DEPTH */
/*      GL_MAX_COLOR_MATRIX_STACK_DEPTH */
/*      GL_POST_COLOR_MATRIX_RED_SCALE */
/*      GL_POST_COLOR_MATRIX_GREEN_SCALE */
/*      GL_POST_COLOR_MATRIX_BLUE_SCALE */
/*      GL_POST_COLOR_MATRIX_ALPHA_SCALE */
/*      GL_POST_COLOR_MATRIX_RED_BIAS */
/*      GL_POST_COLOR_MATRIX_GREEN_BIAS */
/*      GL_POST_COLOR_MATRIX_BLUE_BIAS */
/*      GL_POST_COLOR_MATRIX_ALPHA_BIAS */
/*      GL_HISTOGRAM */
/*      GL_MINMAX */
/*      GL_MAX_ELEMENTS_VERTICES */
/*      GL_MAX_ELEMENTS_INDICES */
/*      GL_RESCALE_NORMAL */
/*      GL_LIGHT_MODEL_COLOR_CONTROL */
/*      GL_PACK_SKIP_IMAGES */
/*      GL_PACK_IMAGE_HEIGHT */
/*      GL_UNPACK_SKIP_IMAGES */
/*      GL_UNPACK_IMAGE_HEIGHT */
/*      GL_TEXTURE_3D */
/*      GL_MAX_3D_TEXTURE_SIZE */
/*      GL_BLEND_COLOR */
/*      GL_BLEND_EQUATION */

/* GetTextureParameter */
/*      GL_TEXTURE_MAG_FILTER */
/*      GL_TEXTURE_MIN_FILTER */
/*      GL_TEXTURE_WRAP_S */
/*      GL_TEXTURE_WRAP_T */
#define GL_TEXTURE_WIDTH                  0x1000
#define GL_TEXTURE_HEIGHT                 0x1001
#define GL_TEXTURE_INTERNAL_FORMAT        0x1003
#define GL_TEXTURE_BORDER_COLOR           0x1004
#define GL_TEXTURE_BORDER                 0x1005
/*      GL_TEXTURE_RED_SIZE */
/*      GL_TEXTURE_GREEN_SIZE */
/*      GL_TEXTURE_BLUE_SIZE */
/*      GL_TEXTURE_ALPHA_SIZE */
/*      GL_TEXTURE_LUMINANCE_SIZE */
/*      GL_TEXTURE_INTENSITY_SIZE */
/*      GL_TEXTURE_PRIORITY */
/*      GL_TEXTURE_RESIDENT */
/*      GL_TEXTURE_DEPTH */
/*      GL_TEXTURE_WRAP_R */
/*      GL_TEXTURE_MIN_LOD */
/*      GL_TEXTURE_MAX_LOD */
/*      GL_TEXTURE_BASE_LEVEL */
/*      GL_TEXTURE_MAX_LEVEL */

/* HintMode */
#define GL_DONT_CARE                      0x1100
#define GL_FASTEST                        0x1101
#define GL_NICEST                         0x1102

/* HintTarget */
/*      GL_PERSPECTIVE_CORRECTION_HINT */
/*      GL_POINT_SMOOTH_HINT */
/*      GL_LINE_SMOOTH_HINT */
/*      GL_POLYGON_SMOOTH_HINT */
/*      GL_FOG_HINT */

/* HistogramTarget */
/*      GL_HISTOGRAM */
/*      GL_PROXY_HISTOGRAM */

/* IndexPointerType */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* LightModelColorControl */
/*      GL_SINGLE_COLOR */
/*      GL_SEPARATE_SPECULAR_COLOR */

/* LightModelParameter */
/*      GL_LIGHT_MODEL_AMBIENT */
/*      GL_LIGHT_MODEL_LOCAL_VIEWER */
/*      GL_LIGHT_MODEL_TWO_SIDE */
/*      GL_LIGHT_MODEL_COLOR_CONTROL */

/* LightName */
#define GL_LIGHT0                         0x4000
#define GL_LIGHT1                         0x4001
#define GL_LIGHT2                         0x4002
#define GL_LIGHT3                         0x4003
#define GL_LIGHT4                         0x4004
#define GL_LIGHT5                         0x4005
#define GL_LIGHT6                         0x4006
#define GL_LIGHT7                         0x4007

/* LightParameter */
#define GL_AMBIENT                        0x1200
#define GL_DIFFUSE                        0x1201
#define GL_SPECULAR                       0x1202
#define GL_POSITION                       0x1203
#define GL_SPOT_DIRECTION                 0x1204
#define GL_SPOT_EXPONENT                  0x1205
#define GL_SPOT_CUTOFF                    0x1206
#define GL_CONSTANT_ATTENUATION           0x1207
#define GL_LINEAR_ATTENUATION             0x1208
#define GL_QUADRATIC_ATTENUATION          0x1209

/* InterleavedArrays */
/*      GL_V2F */
/*      GL_V3F */
/*      GL_C4UB_V2F */
/*      GL_C4UB_V3F */
/*      GL_C3F_V3F */
/*      GL_N3F_V3F */
/*      GL_C4F_N3F_V3F */
/*      GL_T2F_V3F */
/*      GL_T4F_V4F */
/*      GL_T2F_C4UB_V3F */
/*      GL_T2F_C3F_V3F */
/*      GL_T2F_N3F_V3F */
/*      GL_T2F_C4F_N3F_V3F */
/*      GL_T4F_C4F_N3F_V4F */

/* ListMode */
#define GL_COMPILE                        0x1300
#define GL_COMPILE_AND_EXECUTE            0x1301

/* ListNameType */
/*      GL_BYTE */
/*      GL_UNSIGNED_BYTE */
/*      GL_SHORT */
/*      GL_UNSIGNED_SHORT */
/*      GL_INT */
/*      GL_UNSIGNED_INT */
/*      GL_FLOAT */
/*      GL_2_BYTES */
/*      GL_3_BYTES */
/*      GL_4_BYTES */

/* LogicOp */
#define GL_CLEAR                          0x1500
#define GL_AND                            0x1501
#define GL_AND_REVERSE                    0x1502
#define GL_COPY                           0x1503
#define GL_AND_INVERTED                   0x1504
#define GL_NOOP                           0x1505
#define GL_XOR                            0x1506
#define GL_OR                             0x1507
#define GL_NOR                            0x1508
#define GL_EQUIV                          0x1509
#define GL_INVERT                         0x150A
#define GL_OR_REVERSE                     0x150B
#define GL_COPY_INVERTED                  0x150C
#define GL_OR_INVERTED                    0x150D
#define GL_NAND                           0x150E
#define GL_SET                            0x150F

/* MapTarget */
/*      GL_MAP1_COLOR_4 */
/*      GL_MAP1_INDEX */
/*      GL_MAP1_NORMAL */
/*      GL_MAP1_TEXTURE_COORD_1 */
/*      GL_MAP1_TEXTURE_COORD_2 */
/*      GL_MAP1_TEXTURE_COORD_3 */
/*      GL_MAP1_TEXTURE_COORD_4 */
/*      GL_MAP1_VERTEX_3 */
/*      GL_MAP1_VERTEX_4 */
/*      GL_MAP2_COLOR_4 */
/*      GL_MAP2_INDEX */
/*      GL_MAP2_NORMAL */
/*      GL_MAP2_TEXTURE_COORD_1 */
/*      GL_MAP2_TEXTURE_COORD_2 */
/*      GL_MAP2_TEXTURE_COORD_3 */
/*      GL_MAP2_TEXTURE_COORD_4 */
/*      GL_MAP2_VERTEX_3 */
/*      GL_MAP2_VERTEX_4 */

/* MaterialFace */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_FRONT_AND_BACK */

/* MaterialParameter */
#define GL_EMISSION                       0x1600
#define GL_SHININESS                      0x1601
#define GL_AMBIENT_AND_DIFFUSE            0x1602
#define GL_COLOR_INDEXES                  0x1603
/*      GL_AMBIENT */
/*      GL_DIFFUSE */
/*      GL_SPECULAR */

/* MatrixMode */
#define GL_MODELVIEW                      0x1700
#define GL_PROJECTION                     0x1701
#define GL_TEXTURE                        0x1702

/* MeshMode1 */
/*      GL_POINT */
/*      GL_LINE */

/* MeshMode2 */
/*      GL_POINT */
/*      GL_LINE */
/*      GL_FILL */

/* MinmaxTarget */
/*      GL_MINMAX */

/* NormalPointerType */
/*      GL_BYTE */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* PixelCopyType */
#define GL_COLOR                          0x1800
#define GL_DEPTH                          0x1801
#define GL_STENCIL                        0x1802

/* PixelFormat */
#define GL_COLOR_INDEX                    0x1900
#define GL_STENCIL_INDEX                  0x1901
#define GL_DEPTH_COMPONENT                0x1902
#define GL_RED                            0x1903
#define GL_GREEN                          0x1904
#define GL_BLUE                           0x1905
#define GL_ALPHA                          0x1906
#define GL_RGB                            0x1907
#define GL_RGBA                           0x1908
#define GL_LUMINANCE                      0x1909
#define GL_LUMINANCE_ALPHA                0x190A
/*      GL_ABGR */

/* PixelInternalFormat */
/*      GL_ALPHA4 */
/*      GL_ALPHA8 */
/*      GL_ALPHA12 */
/*      GL_ALPHA16 */
/*      GL_LUMINANCE4 */
/*      GL_LUMINANCE8 */
/*      GL_LUMINANCE12 */
/*      GL_LUMINANCE16 */
/*      GL_LUMINANCE4_ALPHA4 */
/*      GL_LUMINANCE6_ALPHA2 */
/*      GL_LUMINANCE8_ALPHA8 */
/*      GL_LUMINANCE12_ALPHA4 */
/*      GL_LUMINANCE12_ALPHA12 */
/*      GL_LUMINANCE16_ALPHA16 */
/*      GL_INTENSITY */
/*      GL_INTENSITY4 */
/*      GL_INTENSITY8 */
/*      GL_INTENSITY12 */
/*      GL_INTENSITY16 */
/*      GL_R3_G3_B2 */
/*      GL_RGB4 */
/*      GL_RGB5 */
/*      GL_RGB8 */
/*      GL_RGB10 */
/*      GL_RGB12 */
/*      GL_RGB16 */
/*      GL_RGBA2 */
/*      GL_RGBA4 */
/*      GL_RGB5_A1 */
/*      GL_RGBA8 */
/*      GL_RGB10_A2 */
/*      GL_RGBA12 */
/*      GL_RGBA16 */

/* PixelMap */
/*      GL_PIXEL_MAP_I_TO_I */
/*      GL_PIXEL_MAP_S_TO_S */
/*      GL_PIXEL_MAP_I_TO_R */
/*      GL_PIXEL_MAP_I_TO_G */
/*      GL_PIXEL_MAP_I_TO_B */
/*      GL_PIXEL_MAP_I_TO_A */
/*      GL_PIXEL_MAP_R_TO_R */
/*      GL_PIXEL_MAP_G_TO_G */
/*      GL_PIXEL_MAP_B_TO_B */
/*      GL_PIXEL_MAP_A_TO_A */

/* PixelStore */
/*      GL_UNPACK_SWAP_BYTES */
/*      GL_UNPACK_LSB_FIRST */
/*      GL_UNPACK_ROW_LENGTH */
/*      GL_UNPACK_SKIP_ROWS */
/*      GL_UNPACK_SKIP_PIXELS */
/*      GL_UNPACK_ALIGNMENT */
/*      GL_PACK_SWAP_BYTES */
/*      GL_PACK_LSB_FIRST */
/*      GL_PACK_ROW_LENGTH */
/*      GL_PACK_SKIP_ROWS */
/*      GL_PACK_SKIP_PIXELS */
/*      GL_PACK_ALIGNMENT */
/*      GL_PACK_SKIP_IMAGES */
/*      GL_PACK_IMAGE_HEIGHT */
/*      GL_UNPACK_SKIP_IMAGES */
/*      GL_UNPACK_IMAGE_HEIGHT */

/* PixelTransfer */
/*      GL_MAP_COLOR */
/*      GL_MAP_STENCIL */
/*      GL_INDEX_SHIFT */
/*      GL_INDEX_OFFSET */
/*      GL_RED_SCALE */
/*      GL_RED_BIAS */
/*      GL_GREEN_SCALE */
/*      GL_GREEN_BIAS */
/*      GL_BLUE_SCALE */
/*      GL_BLUE_BIAS */
/*      GL_ALPHA_SCALE */
/*      GL_ALPHA_BIAS */
/*      GL_DEPTH_SCALE */
/*      GL_DEPTH_BIAS */
/*      GL_POST_CONVOLUTION_RED_SCALE */
/*      GL_POST_CONVOLUTION_GREEN_SCALE */
/*      GL_POST_CONVOLUTION_BLUE_SCALE */
/*      GL_POST_CONVOLUTION_ALPHA_SCALE */
/*      GL_POST_CONVOLUTION_RED_BIAS */
/*      GL_POST_CONVOLUTION_GREEN_BIAS */
/*      GL_POST_CONVOLUTION_BLUE_BIAS */
/*      GL_POST_CONVOLUTION_ALPHA_BIAS */
/*      GL_POST_COLOR_MATRIX_RED_SCALE */
/*      GL_POST_COLOR_MATRIX_GREEN_SCALE */
/*      GL_POST_COLOR_MATRIX_BLUE_SCALE */
/*      GL_POST_COLOR_MATRIX_ALPHA_SCALE */
/*      GL_POST_COLOR_MATRIX_RED_BIAS */
/*      GL_POST_COLOR_MATRIX_GREEN_BIAS */
/*      GL_POST_COLOR_MATRIX_BLUE_BIAS */
/*      GL_POST_COLOR_MATRIX_ALPHA_BIAS */

/* PixelType */
#define GL_BITMAP                         0x1A00
/*      GL_BYTE */
/*      GL_UNSIGNED_BYTE */
/*      GL_SHORT */
/*      GL_UNSIGNED_SHORT */
/*      GL_INT */
/*      GL_UNSIGNED_INT */
/*      GL_FLOAT */
/*      GL_BGR */
/*      GL_BGRA */
/*      GL_UNSIGNED_BYTE_3_3_2 */
/*      GL_UNSIGNED_SHORT_4_4_4_4 */
/*      GL_UNSIGNED_SHORT_5_5_5_1 */
/*      GL_UNSIGNED_INT_8_8_8_8 */
/*      GL_UNSIGNED_INT_10_10_10_2 */
/*      GL_UNSIGNED_SHORT_5_6_5 */
/*      GL_UNSIGNED_BYTE_2_3_3_REV */
/*      GL_UNSIGNED_SHORT_5_6_5_REV */
/*      GL_UNSIGNED_SHORT_4_4_4_4_REV */
/*      GL_UNSIGNED_SHORT_1_5_5_5_REV */
/*      GL_UNSIGNED_INT_8_8_8_8_REV */
/*      GL_UNSIGNED_INT_2_10_10_10_REV */

/* PolygonMode */
#define GL_POINT                          0x1B00
#define GL_LINE                           0x1B01
#define GL_FILL                           0x1B02

/* ReadBufferMode */
/*      GL_FRONT_LEFT */
/*      GL_FRONT_RIGHT */
/*      GL_BACK_LEFT */
/*      GL_BACK_RIGHT */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_LEFT */
/*      GL_RIGHT */
/*      GL_AUX0 */
/*      GL_AUX1 */
/*      GL_AUX2 */
/*      GL_AUX3 */

/* RenderingMode */
#define GL_RENDER                         0x1C00
#define GL_FEEDBACK                       0x1C01
#define GL_SELECT                         0x1C02

/* SeparableTarget */
/*      GL_SEPARABLE_2D */

/* ShadingModel */
#define GL_FLAT                           0x1D00
#define GL_SMOOTH                         0x1D01

/* StencilFunction */
/*      GL_NEVER */
/*      GL_LESS */
/*      GL_EQUAL */
/*      GL_LEQUAL */
/*      GL_GREATER */
/*      GL_NOTEQUAL */
/*      GL_GEQUAL */
/*      GL_ALWAYS */

/* StencilOp */
/*      GL_ZERO */
#define GL_KEEP                           0x1E00
#define GL_REPLACE                        0x1E01
#define GL_INCR                           0x1E02
#define GL_DECR                           0x1E03
/*      GL_INVERT */

/* StringName */
#define GL_VENDOR                         0x1F00
#define GL_RENDERER                       0x1F01
#define GL_VERSION                        0x1F02
#define GL_EXTENSIONS                     0x1F03

/* TextureCoordName */
#define GL_S                              0x2000
#define GL_T                              0x2001
#define GL_R                              0x2002
#define GL_Q                              0x2003

/* TexCoordPointerType */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* TextureEnvMode */
#define GL_MODULATE                       0x2100
#define GL_DECAL                          0x2101
/*      GL_BLEND */
/*      GL_REPLACE */

/* TextureEnvParameter */
#define GL_TEXTURE_ENV_MODE               0x2200
#define GL_TEXTURE_ENV_COLOR              0x2201

/* TextureEnvTarget */
#define GL_TEXTURE_ENV                    0x2300

/* TextureGenMode */
#define GL_EYE_LINEAR                     0x2400
#define GL_OBJECT_LINEAR                  0x2401
#define GL_SPHERE_MAP                     0x2402

/* TextureGenParameter */
#define GL_TEXTURE_GEN_MODE               0x2500
#define GL_OBJECT_PLANE                   0x2501
#define GL_EYE_PLANE                      0x2502

/* TextureMagFilter */
#define GL_NEAREST                        0x2600
#define GL_LINEAR                         0x2601

/* TextureMinFilter */
/*      GL_NEAREST */
/*      GL_LINEAR */
#define GL_NEAREST_MIPMAP_NEAREST         0x2700
#define GL_LINEAR_MIPMAP_NEAREST          0x2701
#define GL_NEAREST_MIPMAP_LINEAR          0x2702
#define GL_LINEAR_MIPMAP_LINEAR           0x2703

/* TextureParameterName */
#define GL_TEXTURE_MAG_FILTER             0x2800
#define GL_TEXTURE_MIN_FILTER             0x2801
#define GL_TEXTURE_WRAP_S                 0x2802
#define GL_TEXTURE_WRAP_T                 0x2803
/*      GL_TEXTURE_BORDER_COLOR */
/*      GL_TEXTURE_PRIORITY */
/*      GL_TEXTURE_WRAP_R */
/*      GL_TEXTURE_MIN_LOD */
/*      GL_TEXTURE_MAX_LOD */
/*      GL_TEXTURE_BASE_LEVEL */
/*      GL_TEXTURE_MAX_LEVEL */

/* TextureTarget */
/*      GL_TEXTURE_1D */
/*      GL_TEXTURE_2D */
/*      GL_PROXY_TEXTURE_1D */
/*      GL_PROXY_TEXTURE_2D */
/*      GL_TEXTURE_3D */
/*      GL_PROXY_TEXTURE_3D */

/* TextureWrapMode */
#define GL_CLAMP                          0x2900
#define GL_REPEAT                         0x2901
/*      GL_CLAMP_TO_EDGE */

/* VertexPointerType */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* ClientAttribMask */
#define GL_CLIENT_PIXEL_STORE_BIT         0x00000001
#define GL_CLIENT_VERTEX_ARRAY_BIT        0x00000002
#define GL_CLIENT_ALL_ATTRIB_BITS         0xffffffff

/* polygon_offset */
#define GL_POLYGON_OFFSET_FACTOR          0x8038
#define GL_POLYGON_OFFSET_UNITS           0x2A00
#define GL_POLYGON_OFFSET_POINT           0x2A01
#define GL_POLYGON_OFFSET_LINE            0x2A02
#define GL_POLYGON_OFFSET_FILL            0x8037

/* texture */
#define GL_ALPHA4                         0x803B
#define GL_ALPHA8                         0x803C
#define GL_ALPHA12                        0x803D
#define GL_ALPHA16                        0x803E
#define GL_LUMINANCE4                     0x803F
#define GL_LUMINANCE8                     0x8040
#define GL_LUMINANCE12                    0x8041
#define GL_LUMINANCE16                    0x8042
#define GL_LUMINANCE4_ALPHA4              0x8043
#define GL_LUMINANCE6_ALPHA2              0x8044
#define GL_LUMINANCE8_ALPHA8              0x8045
#define GL_LUMINANCE12_ALPHA4             0x8046
#define GL_LUMINANCE12_ALPHA12            0x8047
#define GL_LUMINANCE16_ALPHA16            0x8048
#define GL_INTENSITY                      0x8049
#define GL_INTENSITY4                     0x804A
#define GL_INTENSITY8                     0x804B
#define GL_INTENSITY12                    0x804C
#define GL_INTENSITY16                    0x804D
#define GL_R3_G3_B2                       0x2A10
#define GL_RGB4                           0x804F
#define GL_RGB5                           0x8050
#define GL_RGB8                           0x8051
#define GL_RGB10                          0x8052
#define GL_RGB12                          0x8053
#define GL_RGB16                          0x8054
#define GL_RGBA2                          0x8055
#define GL_RGBA4                          0x8056
#define GL_RGB5_A1                        0x8057
#define GL_RGBA8                          0x8058
#define GL_RGB10_A2                       0x8059
#define GL_RGBA12                         0x805A
#define GL_RGBA16                         0x805B
#define GL_TEXTURE_RED_SIZE               0x805C
#define GL_TEXTURE_GREEN_SIZE             0x805D
#define GL_TEXTURE_BLUE_SIZE              0x805E
#define GL_TEXTURE_ALPHA_SIZE             0x805F
#define GL_TEXTURE_LUMINANCE_SIZE         0x8060
#define GL_TEXTURE_INTENSITY_SIZE         0x8061
#define GL_PROXY_TEXTURE_1D               0x8063
#define GL_PROXY_TEXTURE_2D               0x8064

/* texture_object */
#define GL_TEXTURE_PRIORITY               0x8066
#define GL_TEXTURE_RESIDENT               0x8067
#define GL_TEXTURE_BINDING_1D             0x8068
#define GL_TEXTURE_BINDING_2D             0x8069
#define GL_TEXTURE_BINDING_3D             0x806A

/* vertex_array */
#define GL_VERTEX_ARRAY                   0x8074
#define GL_NORMAL_ARRAY                   0x8075
#define GL_COLOR_ARRAY                    0x8076
#define GL_INDEX_ARRAY                    0x8077
#define GL_TEXTURE_COORD_ARRAY            0x8078
#define GL_EDGE_FLAG_ARRAY                0x8079
#define GL_VERTEX_ARRAY_SIZE              0x807A
#define GL_VERTEX_ARRAY_TYPE              0x807B
#define GL_VERTEX_ARRAY_STRIDE            0x807C
#define GL_NORMAL_ARRAY_TYPE              0x807E
#define GL_NORMAL_ARRAY_STRIDE            0x807F
#define GL_COLOR_ARRAY_SIZE               0x8081
#define GL_COLOR_ARRAY_TYPE               0x8082
#define GL_COLOR_ARRAY_STRIDE             0x8083
#define GL_INDEX_ARRAY_TYPE               0x8085
#define GL_INDEX_ARRAY_STRIDE             0x8086
#define GL_TEXTURE_COORD_ARRAY_SIZE       0x8088
#define GL_TEXTURE_COORD_ARRAY_TYPE       0x8089
#define GL_TEXTURE_COORD_ARRAY_STRIDE     0x808A
#define GL_EDGE_FLAG_ARRAY_STRIDE         0x808C
#define GL_VERTEX_ARRAY_POINTER           0x808E
#define GL_NORMAL_ARRAY_POINTER           0x808F
#define GL_COLOR_ARRAY_POINTER            0x8090
#define GL_INDEX_ARRAY_POINTER            0x8091
#define GL_TEXTURE_COORD_ARRAY_POINTER    0x8092
#define GL_EDGE_FLAG_ARRAY_POINTER        0x8093
#define GL_V2F                            0x2A20
#define GL_V3F                            0x2A21
#define GL_C4UB_V2F                       0x2A22
#define GL_C4UB_V3F                       0x2A23
#define GL_C3F_V3F                        0x2A24
#define GL_N3F_V3F                        0x2A25
#define GL_C4F_N3F_V3F                    0x2A26
#define GL_T2F_V3F                        0x2A27
#define GL_T4F_V4F                        0x2A28
#define GL_T2F_C4UB_V3F                   0x2A29
#define GL_T2F_C3F_V3F                    0x2A2A
#define GL_T2F_N3F_V3F                    0x2A2B
#define GL_T2F_C4F_N3F_V3F                0x2A2C
#define GL_T4F_C4F_N3F_V4F                0x2A2D

/* bgra */
#define GL_BGR                            0x80E0
#define GL_BGRA                           0x80E1

/* blend_color */
#define GL_CONSTANT_COLOR                 0x8001
#define GL_ONE_MINUS_CONSTANT_COLOR       0x8002
#define GL_CONSTANT_ALPHA                 0x8003
#define GL_ONE_MINUS_CONSTANT_ALPHA       0x8004
#define GL_BLEND_COLOR                    0x8005

/* blend_minmax */
#define GL_FUNC_ADD                       0x8006
#define GL_MIN                            0x8007
#define GL_MAX                            0x8008
#define GL_BLEND_EQUATION                 0x8009

/* blend_equation_separate */
#define GL_BLEND_EQUATION_RGB             0x8009
#define GL_BLEND_EQUATION_ALPHA           0x883D

/* blend_subtract */
#define GL_FUNC_SUBTRACT                  0x800A
#define GL_FUNC_REVERSE_SUBTRACT          0x800B

/* color_matrix */
#define GL_COLOR_MATRIX                   0x80B1
#define GL_COLOR_MATRIX_STACK_DEPTH       0x80B2
#define GL_MAX_COLOR_MATRIX_STACK_DEPTH   0x80B3
#define GL_POST_COLOR_MATRIX_RED_SCALE    0x80B4
#define GL_POST_COLOR_MATRIX_GREEN_SCALE  0x80B5
#define GL_POST_COLOR_MATRIX_BLUE_SCALE   0x80B6
#define GL_POST_COLOR_MATRIX_ALPHA_SCALE  0x80B7
#define GL_POST_COLOR_MATRIX_RED_BIAS     0x80B8
#define GL_POST_COLOR_MATRIX_GREEN_BIAS   0x80B9
#define GL_POST_COLOR_MATRIX_BLUE_BIAS    0x80BA
#define GL_POST_COLOR_MATRIX_ALPHA_BIAS   0x80BB

/* color_table */
#define GL_COLOR_TABLE                    0x80D0
#define GL_POST_CONVOLUTION_COLOR_TABLE   0x80D1
#define GL_POST_COLOR_MATRIX_COLOR_TABLE  0x80D2
#define GL_PROXY_COLOR_TABLE              0x80D3
#define GL_PROXY_POST_CONVOLUTION_COLOR_TABLE 0x80D4
#define GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE 0x80D5
#define GL_COLOR_TABLE_SCALE              0x80D6
#define GL_COLOR_TABLE_BIAS               0x80D7
#define GL_COLOR_TABLE_FORMAT             0x80D8
#define GL_COLOR_TABLE_WIDTH              0x80D9
#define GL_COLOR_TABLE_RED_SIZE           0x80DA
#define GL_COLOR_TABLE_GREEN_SIZE         0x80DB
#define GL_COLOR_TABLE_BLUE_SIZE          0x80DC
#define GL_COLOR_TABLE_ALPHA_SIZE         0x80DD
#define GL_COLOR_TABLE_LUMINANCE_SIZE     0x80DE
#define GL_COLOR_TABLE_INTENSITY_SIZE     0x80DF

/* convolution */
#define GL_CONVOLUTION_1D                 0x8010
#define GL_CONVOLUTION_2D                 0x8011
#define GL_SEPARABLE_2D                   0x8012
#define GL_CONVOLUTION_BORDER_MODE        0x8013
#define GL_CONVOLUTION_FILTER_SCALE       0x8014
#define GL_CONVOLUTION_FILTER_BIAS        0x8015
#define GL_REDUCE                         0x8016
#define GL_CONVOLUTION_FORMAT             0x8017
#define GL_CONVOLUTION_WIDTH              0x8018
#define GL_CONVOLUTION_HEIGHT             0x8019
#define GL_MAX_CONVOLUTION_WIDTH          0x801A
#define GL_MAX_CONVOLUTION_HEIGHT         0x801B
#define GL_POST_CONVOLUTION_RED_SCALE     0x801C
#define GL_POST_CONVOLUTION_GREEN_SCALE   0x801D
#define GL_POST_CONVOLUTION_BLUE_SCALE    0x801E
#define GL_POST_CONVOLUTION_ALPHA_SCALE   0x801F
#define GL_POST_CONVOLUTION_RED_BIAS      0x8020
#define GL_POST_CONVOLUTION_GREEN_BIAS    0x8021
#define GL_POST_CONVOLUTION_BLUE_BIAS     0x8022
#define GL_POST_CONVOLUTION_ALPHA_BIAS    0x8023
#define GL_CONSTANT_BORDER                0x8151
#define GL_REPLICATE_BORDER               0x8153
#define GL_CONVOLUTION_BORDER_COLOR       0x8154

/* draw_range_elements */
#define GL_MAX_ELEMENTS_VERTICES          0x80E8
#define GL_MAX_ELEMENTS_INDICES           0x80E9

/* histogram */
#define GL_HISTOGRAM                      0x8024
#define GL_PROXY_HISTOGRAM                0x8025
#define GL_HISTOGRAM_WIDTH                0x8026
#define GL_HISTOGRAM_FORMAT               0x8027
#define GL_HISTOGRAM_RED_SIZE             0x8028
#define GL_HISTOGRAM_GREEN_SIZE           0x8029
#define GL_HISTOGRAM_BLUE_SIZE            0x802A
#define GL_HISTOGRAM_ALPHA_SIZE           0x802B
#define GL_HISTOGRAM_LUMINANCE_SIZE       0x802C
#define GL_HISTOGRAM_SINK                 0x802D
#define GL_MINMAX                         0x802E
#define GL_MINMAX_FORMAT                  0x802F
#define GL_MINMAX_SINK                    0x8030
#define GL_TABLE_TOO_LARGE                0x8031

/* packed_pixels */
#define GL_UNSIGNED_BYTE_3_3_2            0x8032
#define GL_UNSIGNED_SHORT_4_4_4_4         0x8033
#define GL_UNSIGNED_SHORT_5_5_5_1         0x8034
#define GL_UNSIGNED_INT_8_8_8_8           0x8035
#define GL_UNSIGNED_INT_10_10_10_2        0x8036
#define GL_UNSIGNED_BYTE_2_3_3_REV        0x8362
#define GL_UNSIGNED_SHORT_5_6_5           0x8363
#define GL_UNSIGNED_SHORT_5_6_5_REV       0x8364
#define GL_UNSIGNED_SHORT_4_4_4_4_REV     0x8365
#define GL_UNSIGNED_SHORT_1_5_5_5_REV     0x8366
#define GL_UNSIGNED_INT_8_8_8_8_REV       0x8367
#define GL_UNSIGNED_INT_2_10_10_10_REV    0x8368

/* rescale_normal */
#define GL_RESCALE_NORMAL                 0x803A

/* separate_specular_color */
#define GL_LIGHT_MODEL_COLOR_CONTROL      0x81F8
#define GL_SINGLE_COLOR                   0x81F9
#define GL_SEPARATE_SPECULAR_COLOR        0x81FA

/* texture3D */
#define GL_PACK_SKIP_IMAGES               0x806B
#define GL_PACK_IMAGE_HEIGHT              0x806C
#define GL_UNPACK_SKIP_IMAGES             0x806D
#define GL_UNPACK_IMAGE_HEIGHT            0x806E
#define GL_TEXTURE_3D                     0x806F
#define GL_PROXY_TEXTURE_3D               0x8070
#define GL_TEXTURE_DEPTH                  0x8071
#define GL_TEXTURE_WRAP_R                 0x8072
#define GL_MAX_3D_TEXTURE_SIZE            0x8073

/* texture_edge_clamp */
#define GL_CLAMP_TO_EDGE                  0x812F
#define GL_CLAMP_TO_BORDER                0x812D

/* texture_lod */
#define GL_TEXTURE_MIN_LOD                0x813A
#define GL_TEXTURE_MAX_LOD                0x813B
#define GL_TEXTURE_BASE_LEVEL             0x813C
#define GL_TEXTURE_MAX_LEVEL              0x813D

/* GetTarget1_2 */
#define GL_SMOOTH_POINT_SIZE_RANGE        0x0B12
#define GL_SMOOTH_POINT_SIZE_GRANULARITY  0x0B13
#define GL_SMOOTH_LINE_WIDTH_RANGE        0x0B22
#define GL_SMOOTH_LINE_WIDTH_GRANULARITY  0x0B23
#define GL_ALIASED_POINT_SIZE_RANGE       0x846D
#define GL_ALIASED_LINE_WIDTH_RANGE       0x846E

#define GL_TEXTURE0                       0x84C0
#define GL_TEXTURE1                       0x84C1
#define GL_TEXTURE2                       0x84C2
#define GL_TEXTURE3                       0x84C3
#define GL_TEXTURE4                       0x84C4
#define GL_TEXTURE5                       0x84C5
#define GL_TEXTURE6                       0x84C6
#define GL_TEXTURE7                       0x84C7
#define GL_TEXTURE8                       0x84C8
#define GL_TEXTURE9                       0x84C9
#define GL_TEXTURE10                      0x84CA
#define GL_TEXTURE11                      0x84CB
#define GL_TEXTURE12                      0x84CC
#define GL_TEXTURE13                      0x84CD
#define GL_TEXTURE14                      0x84CE
#define GL_TEXTURE15                      0x84CF
#define GL_TEXTURE16                      0x84D0
#define GL_TEXTURE17                      0x84D1
#define GL_TEXTURE18                      0x84D2
#define GL_TEXTURE19                      0x84D3
#define GL_TEXTURE20                      0x84D4
#define GL_TEXTURE21                      0x84D5
#define GL_TEXTURE22                      0x84D6
#define GL_TEXTURE23                      0x84D7
#define GL_TEXTURE24                      0x84D8
#define GL_TEXTURE25                      0x84D9
#define GL_TEXTURE26                      0x84DA
#define GL_TEXTURE27                      0x84DB
#define GL_TEXTURE28                      0x84DC
#define GL_TEXTURE29                      0x84DD
#define GL_TEXTURE30                      0x84DE
#define GL_TEXTURE31                      0x84DF
#define GL_ACTIVE_TEXTURE                 0x84E0
#define GL_CLIENT_ACTIVE_TEXTURE          0x84E1
#define GL_MAX_TEXTURE_UNITS              0x84E2

#define GL_COMBINE                        0x8570
#define GL_COMBINE_RGB                    0x8571
#define GL_COMBINE_ALPHA                  0x8572
#define GL_RGB_SCALE                      0x8573
#define GL_ADD_SIGNED                     0x8574
#define GL_INTERPOLATE                    0x8575
#define GL_CONSTANT                       0x8576
#define GL_PRIMARY_COLOR                  0x8577
#define GL_PREVIOUS                       0x8578
#define GL_SUBTRACT                       0x84E7

#define GL_SRC0_RGB                       0x8580
#define GL_SRC1_RGB                       0x8581
#define GL_SRC2_RGB                       0x8582
#define GL_SRC0_ALPHA                     0x8588
#define GL_SRC1_ALPHA                     0x8589
#define GL_SRC2_ALPHA                     0x858A

/* Obsolete */
#define GL_SOURCE0_RGB                    0x8580
#define GL_SOURCE1_RGB                    0x8581
#define GL_SOURCE2_RGB                    0x8582
#define GL_SOURCE0_ALPHA                  0x8588
#define GL_SOURCE1_ALPHA                  0x8589
#define GL_SOURCE2_ALPHA                  0x858A

#define GL_OPERAND0_RGB                   0x8590
#define GL_OPERAND1_RGB                   0x8591
#define GL_OPERAND2_RGB                   0x8592
#define GL_OPERAND0_ALPHA                 0x8598
#define GL_OPERAND1_ALPHA                 0x8599
#define GL_OPERAND2_ALPHA                 0x859A

#define GL_DOT3_RGB                       0x86AE
#define GL_DOT3_RGBA                      0x86AF

#define GL_TRANSPOSE_MODELVIEW_MATRIX     0x84E3
#define GL_TRANSPOSE_PROJECTION_MATRIX    0x84E4
#define GL_TRANSPOSE_TEXTURE_MATRIX       0x84E5
#define GL_TRANSPOSE_COLOR_MATRIX         0x84E6

#define GL_NORMAL_MAP                     0x8511
#define GL_REFLECTION_MAP                 0x8512
#define GL_TEXTURE_CUBE_MAP               0x8513
#define GL_TEXTURE_BINDING_CUBE_MAP       0x8514
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X    0x8515
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X    0x8516
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y    0x8517
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y    0x8518
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z    0x8519
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z    0x851A
#define GL_PROXY_TEXTURE_CUBE_MAP         0x851B
#define GL_MAX_CUBE_MAP_TEXTURE_SIZE      0x851C

#define GL_COMPRESSED_ALPHA               0x84E9
#define GL_COMPRESSED_LUMINANCE           0x84EA
#define GL_COMPRESSED_LUMINANCE_ALPHA     0x84EB
#define GL_COMPRESSED_INTENSITY           0x84EC
#define GL_COMPRESSED_RGB                 0x84ED
#define GL_COMPRESSED_RGBA                0x84EE
#define GL_TEXTURE_COMPRESSION_HINT       0x84EF
#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE  0x86A0
#define GL_TEXTURE_COMPRESSED             0x86A1
#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
#define GL_COMPRESSED_TEXTURE_FORMATS     0x86A3

#define GL_MULTISAMPLE                    0x809D
#define GL_SAMPLE_ALPHA_TO_COVERAGE       0x809E
#define GL_SAMPLE_ALPHA_TO_ONE            0x809F
#define GL_SAMPLE_COVERAGE                0x80A0
#define GL_SAMPLE_BUFFERS                 0x80A8
#define GL_SAMPLES                        0x80A9
#define GL_SAMPLE_COVERAGE_VALUE          0x80AA
#define GL_SAMPLE_COVERAGE_INVERT         0x80AB
#define GL_MULTISAMPLE_BIT                0x20000000

#define GL_DEPTH_COMPONENT16              0x81A5
#define GL_DEPTH_COMPONENT24              0x81A6
#define GL_DEPTH_COMPONENT32              0x81A7
#define GL_TEXTURE_DEPTH_SIZE             0x884A
#define GL_DEPTH_TEXTURE_MODE             0x884B

#define GL_TEXTURE_COMPARE_MODE           0x884C
#define GL_TEXTURE_COMPARE_FUNC           0x884D
#define GL_COMPARE_R_TO_TEXTURE           0x884E

/* occlusion_query */
#define GL_QUERY_COUNTER_BITS             0x8864
#define GL_CURRENT_QUERY                  0x8865
#define GL_QUERY_RESULT                   0x8866
#define GL_QUERY_RESULT_AVAILABLE         0x8867
#define GL_SAMPLES_PASSED                 0x8914

#define GL_FOG_COORD_SRC                  0x8450
#define GL_FOG_COORD                      0x8451
#define GL_FRAGMENT_DEPTH                 0x8452
#define GL_CURRENT_FOG_COORD              0x8453  
#define GL_FOG_COORD_ARRAY_TYPE           0x8454
#define GL_FOG_COORD_ARRAY_STRIDE         0x8455
#define GL_FOG_COORD_ARRAY_POINTER        0x8456
#define GL_FOG_COORD_ARRAY                0x8457

/* Obsolete */
#define GL_FOG_COORDINATE_SOURCE          0x8450
#define GL_FOG_COORDINATE                 0x8451
#define GL_CURRENT_FOG_COORDINATE         0x8453  
#define GL_FOG_COORDINATE_ARRAY_TYPE      0x8454
#define GL_FOG_COORDINATE_ARRAY_STRIDE    0x8455
#define GL_FOG_COORDINATE_ARRAY_POINTER   0x8456
#define GL_FOG_COORDINATE_ARRAY           0x8457

#define GL_COLOR_SUM                      0x8458
#define GL_CURRENT_SECONDARY_COLOR        0x8459
#define GL_SECONDARY_COLOR_ARRAY_SIZE     0x845A
#define GL_SECONDARY_COLOR_ARRAY_TYPE     0x845B
#define GL_SECONDARY_COLOR_ARRAY_STRIDE   0x845C
#define GL_SECONDARY_COLOR_ARRAY_POINTER  0x845D
#define GL_SECONDARY_COLOR_ARRAY          0x845E

#define GL_POINT_SIZE_MIN                 0x8126
#define GL_POINT_SIZE_MAX                 0x8127
#define GL_POINT_FADE_THRESHOLD_SIZE      0x8128
#define GL_POINT_DISTANCE_ATTENUATION     0x8129

#define GL_BLEND_DST_RGB                  0x80C8
#define GL_BLEND_SRC_RGB                  0x80C9
#define GL_BLEND_DST_ALPHA                0x80CA
#define GL_BLEND_SRC_ALPHA                0x80CB

#define GL_GENERATE_MIPMAP                0x8191
#define GL_GENERATE_MIPMAP_HINT           0x8192

#define GL_INCR_WRAP                      0x8507
#define GL_DECR_WRAP                      0x8508

#define GL_MIRRORED_REPEAT                0x8370

#define GL_MAX_TEXTURE_LOD_BIAS           0x84FD
#define GL_TEXTURE_FILTER_CONTROL         0x8500
#define GL_TEXTURE_LOD_BIAS               0x8501

/* vertex_buffer_object */
#define GL_ARRAY_BUFFER                                0x8892
#define GL_ELEMENT_ARRAY_BUFFER                        0x8893
#define GL_ARRAY_BUFFER_BINDING                        0x8894
#define GL_ELEMENT_ARRAY_BUFFER_BINDING                0x8895
#define GL_VERTEX_ARRAY_BUFFER_BINDING                 0x8896
#define GL_NORMAL_ARRAY_BUFFER_BINDING                 0x8897
#define GL_COLOR_ARRAY_BUFFER_BINDING                  0x8898
#define GL_INDEX_ARRAY_BUFFER_BINDING                  0x8899
#define GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING          0x889A
#define GL_EDGE_FLAG_ARRAY_BUFFER_BINDING              0x889B
#define GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING        0x889C
#define GL_FOG_COORD_ARRAY_BUFFER_BINDING              0x889D
#define GL_WEIGHT_ARRAY_BUFFER_BINDING                 0x889E
#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING          0x889F
#define GL_STREAM_DRAW                                 0x88E0
#define GL_STREAM_READ                                 0x88E1
#define GL_STREAM_COPY                                 0x88E2
#define GL_STATIC_DRAW                                 0x88E4
#define GL_STATIC_READ                                 0x88E5
#define GL_STATIC_COPY                                 0x88E6
#define GL_DYNAMIC_DRAW                                0x88E8
#define GL_DYNAMIC_READ                                0x88E9
#define GL_DYNAMIC_COPY                                0x88EA
#define GL_READ_ONLY                                   0x88B8
#define GL_WRITE_ONLY                                  0x88B9
#define GL_READ_WRITE                                  0x88BA
#define GL_BUFFER_SIZE                                 0x8764
#define GL_BUFFER_USAGE                                0x8765
#define GL_BUFFER_ACCESS                               0x88BB
#define GL_BUFFER_MAPPED                               0x88BC
#define GL_BUFFER_MAP_POINTER                          0x88BD
/* Obsolete */
#define GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING         0x889D

/* OpenGL 2.0 */
#define GL_CURRENT_PROGRAM                0x8B8D
#define GL_SHADER_TYPE                    0x8B4F
#define GL_DELETE_STATUS                  0x8B80
#define GL_COMPILE_STATUS                 0x8B81
#define GL_LINK_STATUS                    0x8B82
#define GL_VALIDATE_STATUS                0x8B83
#define GL_INFO_LOG_LENGTH                0x8B84
#define GL_ATTACHED_SHADERS               0x8B85
#define GL_ACTIVE_UNIFORMS                0x8B86
#define GL_ACTIVE_UNIFORM_MAX_LENGTH      0x8B87
#define GL_SHADER_SOURCE_LENGTH           0x8B88
#define GL_FLOAT_VEC2                     0x8B50
#define GL_FLOAT_VEC3                     0x8B51
#define GL_FLOAT_VEC4                     0x8B52
#define GL_INT_VEC2                       0x8B53
#define GL_INT_VEC3                       0x8B54
#define GL_INT_VEC4                       0x8B55
#define GL_BOOL                           0x8B56
#define GL_BOOL_VEC2                      0x8B57
#define GL_BOOL_VEC3                      0x8B58
#define GL_BOOL_VEC4                      0x8B59
#define GL_FLOAT_MAT2                     0x8B5A
#define GL_FLOAT_MAT3                     0x8B5B
#define GL_FLOAT_MAT4                     0x8B5C
#define GL_SAMPLER_1D                     0x8B5D
#define GL_SAMPLER_2D                     0x8B5E
#define GL_SAMPLER_3D                     0x8B5F
#define GL_SAMPLER_CUBE                   0x8B60
#define GL_SAMPLER_1D_SHADOW              0x8B61
#define GL_SAMPLER_2D_SHADOW              0x8B62
#define GL_SHADING_LANGUAGE_VERSION       0x8B8C
#define GL_VERTEX_SHADER                  0x8B31
#define GL_MAX_VERTEX_UNIFORM_COMPONENTS  0x8B4A
#define GL_MAX_VARYING_FLOATS             0x8B4B
#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS 0x8B4C
#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
#define GL_ACTIVE_ATTRIBUTES              0x8B89
#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH    0x8B8A
#define GL_FRAGMENT_SHADER                0x8B30
#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS 0x8B49
#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT 0x8B8B
#define GL_MAX_VERTEX_ATTRIBS             0x8869
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED    0x8622
#define GL_VERTEX_ATTRIB_ARRAY_SIZE       0x8623
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE     0x8624
#define GL_VERTEX_ATTRIB_ARRAY_TYPE       0x8625
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED 0x886A
#define GL_CURRENT_VERTEX_ATTRIB          0x8626
#define GL_VERTEX_ATTRIB_ARRAY_POINTER    0x8645
#define GL_VERTEX_PROGRAM_POINT_SIZE      0x8642
#define GL_VERTEX_PROGRAM_TWO_SIDE        0x8643
#define GL_MAX_TEXTURE_COORDS             0x8871
#define GL_MAX_TEXTURE_IMAGE_UNITS        0x8872
#define GL_MAX_DRAW_BUFFERS               0x8824
#define GL_DRAW_BUFFER0                   0x8825
#define GL_DRAW_BUFFER1                   0x8826
#define GL_DRAW_BUFFER2                   0x8827
#define GL_DRAW_BUFFER3                   0x8828
#define GL_DRAW_BUFFER4                   0x8829
#define GL_DRAW_BUFFER5                   0x882A
#define GL_DRAW_BUFFER6                   0x882B
#define GL_DRAW_BUFFER7                   0x882C
#define GL_DRAW_BUFFER8                   0x882D
#define GL_DRAW_BUFFER9                   0x882E
#define GL_DRAW_BUFFER10                  0x882F
#define GL_DRAW_BUFFER11                  0x8830
#define GL_DRAW_BUFFER12                  0x8831
#define GL_DRAW_BUFFER13                  0x8832
#define GL_DRAW_BUFFER14                  0x8833
#define GL_DRAW_BUFFER15                  0x8834
#define GL_POINT_SPRITE                   0x8861
#define GL_COORD_REPLACE                  0x8862
#define GL_POINT_SPRITE_COORD_ORIGIN      0x8CA0
#define GL_LOWER_LEFT                     0x8CA1
#define GL_UPPER_LEFT                     0x8CA2
#define GL_STENCIL_BACK_FUNC              0x8800
#define GL_STENCIL_BACK_VALUE_MASK        0x8CA4
#define GL_STENCIL_BACK_REF               0x8CA3
#define GL_STENCIL_BACK_FAIL              0x8801
#define GL_STENCIL_BACK_PASS_DEPTH_FAIL   0x8802
#define GL_STENCIL_BACK_PASS_DEPTH_PASS   0x8803
#define GL_STENCIL_BACK_WRITEMASK         0x8CA5

/* OpenGL 2.1 */
#define GL_CURRENT_RASTER_SECONDARY_COLOR 0x845F
#define GL_PIXEL_PACK_BUFFER              0x88EB
#define GL_PIXEL_UNPACK_BUFFER            0x88EC
#define GL_PIXEL_PACK_BUFFER_BINDING      0x88ED
#define GL_PIXEL_UNPACK_BUFFER_BINDING    0x88EF
#define GL_FLOAT_MAT2x3                   0x8B65
#define GL_FLOAT_MAT2x4                   0x8B66
#define GL_FLOAT_MAT3x2                   0x8B67
#define GL_FLOAT_MAT3x4                   0x8B68
#define GL_FLOAT_MAT4x2                   0x8B69
#define GL_FLOAT_MAT4x3                   0x8B6A
#define GL_SRGB                           0x8C40
#define GL_SRGB8                          0x8C41
#define GL_SRGB_ALPHA                     0x8C42
#define GL_SRGB8_ALPHA8                   0x8C43
#define GL_SLUMINANCE_ALPHA               0x8C44
#define GL_SLUMINANCE8_ALPHA8             0x8C45
#define GL_SLUMINANCE                     0x8C46
#define GL_SLUMINANCE8                    0x8C47
#define GL_COMPRESSED_SRGB                0x8C48
#define GL_COMPRESSED_SRGB_ALPHA          0x8C49
#define GL_COMPRESSED_SLUMINANCE          0x8C4A
#define GL_COMPRESSED_SLUMINANCE_ALPHA    0x8C4B

/*************************************************************/

#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glAccumProcPtr) (GLenum op, GLfloat value);
typedef void (* glAlphaFuncProcPtr) (GLenum func, GLclampf ref);
typedef GLboolean (* glAreTexturesResidentProcPtr) (GLsizei n, const GLuint *textures, GLboolean *residences);
typedef void (* glArrayElementProcPtr) (GLint i);
typedef void (* glBeginProcPtr) (GLenum mode);
typedef void (* glBindTextureProcPtr) (GLenum target, GLuint texture);
typedef void (* glBitmapProcPtr) (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
typedef void (* glBlendColorProcPtr) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
typedef void (* glBlendEquationProcPtr) (GLenum mode);
typedef void (* glBlendEquationSeparateProcPtr) (GLenum modeRGB, GLenum modeAlpha);
typedef void (* glBlendFuncProcPtr) (GLenum sfactor, GLenum dfactor);
typedef void (* glCallListProcPtr) (GLuint list);
typedef void (* glCallListsProcPtr) (GLsizei n, GLenum type, const GLvoid *lists);
typedef void (* glClearProcPtr) (GLbitfield mask);
typedef void (* glClearAccumProcPtr) (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
typedef void (* glClearColorProcPtr) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
typedef void (* glClearDepthProcPtr) (GLclampd depth);
typedef void (* glClearIndexProcPtr) (GLfloat c);
typedef void (* glClearStencilProcPtr) (GLint s);
typedef void (* glClipPlaneProcPtr) (GLenum plane, const GLdouble *equation);
typedef void (* glColor3bProcPtr) (GLbyte red, GLbyte green, GLbyte blue);
typedef void (* glColor3bvProcPtr) (const GLbyte *v);
typedef void (* glColor3dProcPtr) (GLdouble red, GLdouble green, GLdouble blue);
typedef void (* glColor3dvProcPtr) (const GLdouble *v);
typedef void (* glColor3fProcPtr) (GLfloat red, GLfloat green, GLfloat blue);
typedef void (* glColor3fvProcPtr) (const GLfloat *v);
typedef void (* glColor3iProcPtr) (GLint red, GLint green, GLint blue);
typedef void (* glColor3ivProcPtr) (const GLint *v);
typedef void (* glColor3sProcPtr) (GLshort red, GLshort green, GLshort blue);
typedef void (* glColor3svProcPtr) (const GLshort *v);
typedef void (* glColor3ubProcPtr) (GLubyte red, GLubyte green, GLubyte blue);
typedef void (* glColor3ubvProcPtr) (const GLubyte *v);
typedef void (* glColor3uiProcPtr) (GLuint red, GLuint green, GLuint blue);
typedef void (* glColor3uivProcPtr) (const GLuint *v);
typedef void (* glColor3usProcPtr) (GLushort red, GLushort green, GLushort blue);
typedef void (* glColor3usvProcPtr) (const GLushort *v);
typedef void (* glColor4bProcPtr) (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
typedef void (* glColor4bvProcPtr) (const GLbyte *v);
typedef void (* glColor4dProcPtr) (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
typedef void (* glColor4dvProcPtr) (const GLdouble *v);
typedef void (* glColor4fProcPtr) (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
typedef void (* glColor4fvProcPtr) (const GLfloat *v);
typedef void (* glColor4iProcPtr) (GLint red, GLint green, GLint blue, GLint alpha);
typedef void (* glColor4ivProcPtr) (const GLint *v);
typedef void (* glColor4sProcPtr) (GLshort red, GLshort green, GLshort blue, GLshort alpha);
typedef void (* glColor4svProcPtr) (const GLshort *v);
typedef void (* glColor4ubProcPtr) (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
typedef void (* glColor4ubvProcPtr) (const GLubyte *v);
typedef void (* glColor4uiProcPtr) (GLuint red, GLuint green, GLuint blue, GLuint alpha);
typedef void (* glColor4uivProcPtr) (const GLuint *v);
typedef void (* glColor4usProcPtr) (GLushort red, GLushort green, GLushort blue, GLushort alpha);
typedef void (* glColor4usvProcPtr) (const GLushort *v);
typedef void (* glColorMaskProcPtr) (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
typedef void (* glColorMaterialProcPtr) (GLenum face, GLenum mode);
typedef void (* glColorPointerProcPtr) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (* glColorSubTableProcPtr) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
typedef void (* glColorTableProcPtr) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
typedef void (* glColorTableParameterfvProcPtr) (GLenum target, GLenum pname, const GLfloat *params);
typedef void (* glColorTableParameterivProcPtr) (GLenum target, GLenum pname, const GLint *params);
typedef void (* glConvolutionFilter1DProcPtr) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
typedef void (* glConvolutionFilter2DProcPtr) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
typedef void (* glConvolutionParameterfProcPtr) (GLenum target, GLenum pname, GLfloat params);
typedef void (* glConvolutionParameterfvProcPtr) (GLenum target, GLenum pname, const GLfloat *params);
typedef void (* glConvolutionParameteriProcPtr) (GLenum target, GLenum pname, GLint params);
typedef void (* glConvolutionParameterivProcPtr) (GLenum target, GLenum pname, const GLint *params);
typedef void (* glCopyColorSubTableProcPtr) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
typedef void (* glCopyColorTableProcPtr) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (* glCopyConvolutionFilter1DProcPtr) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (* glCopyConvolutionFilter2DProcPtr) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (* glCopyPixelsProcPtr) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
typedef void (* glCopyTexImage1DProcPtr) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (* glCopyTexImage2DProcPtr) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (* glCopyTexSubImage1DProcPtr) (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (* glCopyTexSubImage2DProcPtr) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (* glCopyTexSubImage3DProcPtr) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (* glCullFaceProcPtr) (GLenum mode);
typedef void (* glDeleteListsProcPtr) (GLuint list, GLsizei range);
typedef void (* glDeleteTexturesProcPtr) (GLsizei n, const GLuint *textures);
typedef void (* glDepthFuncProcPtr) (GLenum func);
typedef void (* glDepthMaskProcPtr) (GLboolean flag);
typedef void (* glDepthRangeProcPtr) (GLclampd zNear, GLclampd zFar);
typedef void (* glDisableProcPtr) (GLenum cap);
typedef void (* glDisableClientStateProcPtr) (GLenum array);
typedef void (* glDrawArraysProcPtr) (GLenum mode, GLint first, GLsizei count);
typedef void (* glDrawBufferProcPtr) (GLenum mode);
typedef void (* glDrawElementsProcPtr) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
typedef void (* glDrawPixelsProcPtr) (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (* glDrawRangeElementsProcPtr) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
typedef void (* glEdgeFlagProcPtr) (GLboolean flag);
typedef void (* glEdgeFlagPointerProcPtr) (GLsizei stride, const GLvoid *pointer);
typedef void (* glEdgeFlagvProcPtr) (const GLboolean *flag);
typedef void (* glEnableProcPtr) (GLenum cap);
typedef void (* glEnableClientStateProcPtr) (GLenum array);
typedef void (* glEndProcPtr) (void);
typedef void (* glEndListProcPtr) (void);
typedef void (* glEvalCoord1dProcPtr) (GLdouble u);
typedef void (* glEvalCoord1dvProcPtr) (const GLdouble *u);
typedef void (* glEvalCoord1fProcPtr) (GLfloat u);
typedef void (* glEvalCoord1fvProcPtr) (const GLfloat *u);
typedef void (* glEvalCoord2dProcPtr) (GLdouble u, GLdouble v);
typedef void (* glEvalCoord2dvProcPtr) (const GLdouble *u);
typedef void (* glEvalCoord2fProcPtr) (GLfloat u, GLfloat v);
typedef void (* glEvalCoord2fvProcPtr) (const GLfloat *u);
typedef void (* glEvalMesh1ProcPtr) (GLenum mode, GLint i1, GLint i2);
typedef void (* glEvalMesh2ProcPtr) (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
typedef void (* glEvalPoint1ProcPtr) (GLint i);
typedef void (* glEvalPoint2ProcPtr) (GLint i, GLint j);
typedef void (* glFeedbackBufferProcPtr) (GLsizei size, GLenum type, GLfloat *buffer);
typedef void (* glFinishProcPtr) (void);
typedef void (* glFlushProcPtr) (void);
typedef void (* glFogfProcPtr) (GLenum pname, GLfloat param);
typedef void (* glFogfvProcPtr) (GLenum pname, const GLfloat *params);
typedef void (* glFogiProcPtr) (GLenum pname, GLint param);
typedef void (* glFogivProcPtr) (GLenum pname, const GLint *params);
typedef void (* glFrontFaceProcPtr) (GLenum mode);
typedef void (* glFrustumProcPtr) (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
typedef GLuint (* glGenListsProcPtr) (GLsizei range);
typedef void (* glGenTexturesProcPtr) (GLsizei n, GLuint *textures);
typedef void (* glGetBooleanvProcPtr) (GLenum pname, GLboolean *params);
typedef void (* glGetClipPlaneProcPtr) (GLenum plane, GLdouble *equation);
typedef void (* glGetColorTableProcPtr) (GLenum target, GLenum format, GLenum type, GLvoid *table);
typedef void (* glGetColorTableParameterfvProcPtr) (GLenum target, GLenum pname, GLfloat *params);
typedef void (* glGetColorTableParameterivProcPtr) (GLenum target, GLenum pname, GLint *params);
typedef void (* glGetConvolutionFilterProcPtr) (GLenum target, GLenum format, GLenum type, GLvoid *image);
typedef void (* glGetConvolutionParameterfvProcPtr) (GLenum target, GLenum pname, GLfloat *params);
typedef void (* glGetConvolutionParameterivProcPtr) (GLenum target, GLenum pname, GLint *params);
typedef void (* glGetDoublevProcPtr) (GLenum pname, GLdouble *params);
typedef GLenum (* glGetErrorProcPtr) (void);
typedef void (* glGetFloatvProcPtr) (GLenum pname, GLfloat *params);
typedef void (* glGetHistogramProcPtr) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void (* glGetHistogramParameterfvProcPtr) (GLenum target, GLenum pname, GLfloat *params);
typedef void (* glGetHistogramParameterivProcPtr) (GLenum target, GLenum pname, GLint *params);
typedef void (* glGetIntegervProcPtr) (GLenum pname, GLint *params);
typedef void (* glGetLightfvProcPtr) (GLenum light, GLenum pname, GLfloat *params);
typedef void (* glGetLightivProcPtr) (GLenum light, GLenum pname, GLint *params);
typedef void (* glGetMapdvProcPtr) (GLenum target, GLenum query, GLdouble *v);
typedef void (* glGetMapfvProcPtr) (GLenum target, GLenum query, GLfloat *v);
typedef void (* glGetMapivProcPtr) (GLenum target, GLenum query, GLint *v);
typedef void (* glGetMaterialfvProcPtr) (GLenum face, GLenum pname, GLfloat *params);
typedef void (* glGetMaterialivProcPtr) (GLenum face, GLenum pname, GLint *params);
typedef void (* glGetMinmaxProcPtr) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void (* glGetMinmaxParameterfvProcPtr) (GLenum target, GLenum pname, GLfloat *params);
typedef void (* glGetMinmaxParameterivProcPtr) (GLenum target, GLenum pname, GLint *params);
typedef void (* glGetPixelMapfvProcPtr) (GLenum map, GLfloat *values);
typedef void (* glGetPixelMapuivProcPtr) (GLenum map, GLuint *values);
typedef void (* glGetPixelMapusvProcPtr) (GLenum map, GLushort *values);
typedef void (* glGetPointervProcPtr) (GLenum pname, GLvoid **params);
typedef void (* glGetPolygonStippleProcPtr) (GLubyte *mask);
typedef void (* glGetSeparableFilterProcPtr) (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
typedef const GLubyte *(* glGetStringProcPtr) (GLenum name);
typedef void (* glGetTexEnvfvProcPtr) (GLenum target, GLenum pname, GLfloat *params);
typedef void (* glGetTexEnvivProcPtr) (GLenum target, GLenum pname, GLint *params);
typedef void (* glGetTexGendvProcPtr) (GLenum coord, GLenum pname, GLdouble *params);
typedef void (* glGetTexGenfvProcPtr) (GLenum coord, GLenum pname, GLfloat *params);
typedef void (* glGetTexGenivProcPtr) (GLenum coord, GLenum pname, GLint *params);
typedef void (* glGetTexImageProcPtr) (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
typedef void (* glGetTexLevelParameterfvProcPtr) (GLenum target, GLint level, GLenum pname, GLfloat *params);
typedef void (* glGetTexLevelParameterivProcPtr) (GLenum target, GLint level, GLenum pname, GLint *params);
typedef void (* glGetTexParameterfvProcPtr) (GLenum target, GLenum pname, GLfloat *params);
typedef void (* glGetTexParameterivProcPtr) (GLenum target, GLenum pname, GLint *params);
typedef void (* glHintProcPtr) (GLenum target, GLenum mode);
typedef void (* glHistogramProcPtr) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void (* glIndexMaskProcPtr) (GLuint mask);
typedef void (* glIndexPointerProcPtr) (GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (* glIndexdProcPtr) (GLdouble c);
typedef void (* glIndexdvProcPtr) (const GLdouble *c);
typedef void (* glIndexfProcPtr) (GLfloat c);
typedef void (* glIndexfvProcPtr) (const GLfloat *c);
typedef void (* glIndexiProcPtr) (GLint c);
typedef void (* glIndexivProcPtr) (const GLint *c);
typedef void (* glIndexsProcPtr) (GLshort c);
typedef void (* glIndexsvProcPtr) (const GLshort *c);
typedef void (* glIndexubProcPtr) (GLubyte c);
typedef void (* glIndexubvProcPtr) (const GLubyte *c);
typedef void (* glInitNamesProcPtr) (void);
typedef void (* glInterleavedArraysProcPtr) (GLenum format, GLsizei stride, const GLvoid *pointer);
typedef GLboolean (* glIsEnabledProcPtr) (GLenum cap);
typedef GLboolean (* glIsListProcPtr) (GLuint list);
typedef GLboolean (* glIsTextureProcPtr) (GLuint texture);
typedef void (* glLightModelfProcPtr) (GLenum pname, GLfloat param);
typedef void (* glLightModelfvProcPtr) (GLenum pname, const GLfloat *params);
typedef void (* glLightModeliProcPtr) (GLenum pname, GLint param);
typedef void (* glLightModelivProcPtr) (GLenum pname, const GLint *params);
typedef void (* glLightfProcPtr) (GLenum light, GLenum pname, GLfloat param);
typedef void (* glLightfvProcPtr) (GLenum light, GLenum pname, const GLfloat *params);
typedef void (* glLightiProcPtr) (GLenum light, GLenum pname, GLint param);
typedef void (* glLightivProcPtr) (GLenum light, GLenum pname, const GLint *params);
typedef void (* glLineStippleProcPtr) (GLint factor, GLushort pattern);
typedef void (* glLineWidthProcPtr) (GLfloat width);
typedef void (* glListBaseProcPtr) (GLuint base);
typedef void (* glLoadIdentityProcPtr) (void);
typedef void (* glLoadMatrixdProcPtr) (const GLdouble *m);
typedef void (* glLoadMatrixfProcPtr) (const GLfloat *m);
typedef void (* glLoadNameProcPtr) (GLuint name);
typedef void (* glLogicOpProcPtr) (GLenum opcode);
typedef void (* glMap1dProcPtr) (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
typedef void (* glMap1fProcPtr) (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
typedef void (* glMap2dProcPtr) (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
typedef void (* glMap2fProcPtr) (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
typedef void (* glMapGrid1dProcPtr) (GLint un, GLdouble u1, GLdouble u2);
typedef void (* glMapGrid1fProcPtr) (GLint un, GLfloat u1, GLfloat u2);
typedef void (* glMapGrid2dProcPtr) (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
typedef void (* glMapGrid2fProcPtr) (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
typedef void (* glMaterialfProcPtr) (GLenum face, GLenum pname, GLfloat param);
typedef void (* glMaterialfvProcPtr) (GLenum face, GLenum pname, const GLfloat *params);
typedef void (* glMaterialiProcPtr) (GLenum face, GLenum pname, GLint param);
typedef void (* glMaterialivProcPtr) (GLenum face, GLenum pname, const GLint *params);
typedef void (* glMatrixModeProcPtr) (GLenum mode);
typedef void (* glMinmaxProcPtr) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void (* glMultMatrixdProcPtr) (const GLdouble *m);
typedef void (* glMultMatrixfProcPtr) (const GLfloat *m);
typedef void (* glNewListProcPtr) (GLuint list, GLenum mode);
typedef void (* glNormal3bProcPtr) (GLbyte nx, GLbyte ny, GLbyte nz);
typedef void (* glNormal3bvProcPtr) (const GLbyte *v);
typedef void (* glNormal3dProcPtr) (GLdouble nx, GLdouble ny, GLdouble nz);
typedef void (* glNormal3dvProcPtr) (const GLdouble *v);
typedef void (* glNormal3fProcPtr) (GLfloat nx, GLfloat ny, GLfloat nz);
typedef void (* glNormal3fvProcPtr) (const GLfloat *v);
typedef void (* glNormal3iProcPtr) (GLint nx, GLint ny, GLint nz);
typedef void (* glNormal3ivProcPtr) (const GLint *v);
typedef void (* glNormal3sProcPtr) (GLshort nx, GLshort ny, GLshort nz);
typedef void (* glNormal3svProcPtr) (const GLshort *v);
typedef void (* glNormalPointerProcPtr) (GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (* glOrthoProcPtr) (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
typedef void (* glPassThroughProcPtr) (GLfloat token);
typedef void (* glPixelMapfvProcPtr) (GLenum map, GLint mapsize, const GLfloat *values);
typedef void (* glPixelMapuivProcPtr) (GLenum map, GLint mapsize, const GLuint *values);
typedef void (* glPixelMapusvProcPtr) (GLenum map, GLint mapsize, const GLushort *values);
typedef void (* glPixelStorefProcPtr) (GLenum pname, GLfloat param);
typedef void (* glPixelStoreiProcPtr) (GLenum pname, GLint param);
typedef void (* glPixelTransferfProcPtr) (GLenum pname, GLfloat param);
typedef void (* glPixelTransferiProcPtr) (GLenum pname, GLint param);
typedef void (* glPixelZoomProcPtr) (GLfloat xfactor, GLfloat yfactor);
typedef void (* glPointSizeProcPtr) (GLfloat size);
typedef void (* glPolygonModeProcPtr) (GLenum face, GLenum mode);
typedef void (* glPolygonOffsetProcPtr) (GLfloat factor, GLfloat units);
typedef void (* glPolygonStippleProcPtr) (const GLubyte *mask);
typedef void (* glPopAttribProcPtr) (void);
typedef void (* glPopClientAttribProcPtr) (void);
typedef void (* glPopMatrixProcPtr) (void);
typedef void (* glPopNameProcPtr) (void);
typedef void (* glPrioritizeTexturesProcPtr) (GLsizei n, const GLuint *textures, const GLclampf *priorities);
typedef void (* glPushAttribProcPtr) (GLbitfield mask);
typedef void (* glPushClientAttribProcPtr) (GLbitfield mask);
typedef void (* glPushMatrixProcPtr) (void);
typedef void (* glPushNameProcPtr) (GLuint name);
typedef void (* glRasterPos2dProcPtr) (GLdouble x, GLdouble y);
typedef void (* glRasterPos2dvProcPtr) (const GLdouble *v);
typedef void (* glRasterPos2fProcPtr) (GLfloat x, GLfloat y);
typedef void (* glRasterPos2fvProcPtr) (const GLfloat *v);
typedef void (* glRasterPos2iProcPtr) (GLint x, GLint y);
typedef void (* glRasterPos2ivProcPtr) (const GLint *v);
typedef void (* glRasterPos2sProcPtr) (GLshort x, GLshort y);
typedef void (* glRasterPos2svProcPtr) (const GLshort *v);
typedef void (* glRasterPos3dProcPtr) (GLdouble x, GLdouble y, GLdouble z);
typedef void (* glRasterPos3dvProcPtr) (const GLdouble *v);
typedef void (* glRasterPos3fProcPtr) (GLfloat x, GLfloat y, GLfloat z);
typedef void (* glRasterPos3fvProcPtr) (const GLfloat *v);
typedef void (* glRasterPos3iProcPtr) (GLint x, GLint y, GLint z);
typedef void (* glRasterPos3ivProcPtr) (const GLint *v);
typedef void (* glRasterPos3sProcPtr) (GLshort x, GLshort y, GLshort z);
typedef void (* glRasterPos3svProcPtr) (const GLshort *v);
typedef void (* glRasterPos4dProcPtr) (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (* glRasterPos4dvProcPtr) (const GLdouble *v);
typedef void (* glRasterPos4fProcPtr) (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (* glRasterPos4fvProcPtr) (const GLfloat *v);
typedef void (* glRasterPos4iProcPtr) (GLint x, GLint y, GLint z, GLint w);
typedef void (* glRasterPos4ivProcPtr) (const GLint *v);
typedef void (* glRasterPos4sProcPtr) (GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (* glRasterPos4svProcPtr) (const GLshort *v);
typedef void (* glReadBufferProcPtr) (GLenum mode);
typedef void (* glReadPixelsProcPtr) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
typedef void (* glRectdProcPtr) (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
typedef void (* glRectdvProcPtr) (const GLdouble *v1, const GLdouble *v2);
typedef void (* glRectfProcPtr) (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
typedef void (* glRectfvProcPtr) (const GLfloat *v1, const GLfloat *v2);
typedef void (* glRectiProcPtr) (GLint x1, GLint y1, GLint x2, GLint y2);
typedef void (* glRectivProcPtr) (const GLint *v1, const GLint *v2);
typedef void (* glRectsProcPtr) (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
typedef void (* glRectsvProcPtr) (const GLshort *v1, const GLshort *v2);
typedef GLint (* glRenderModeProcPtr) (GLenum mode);
typedef void (* glResetHistogramProcPtr) (GLenum target);
typedef void (* glResetMinmaxProcPtr) (GLenum target);
typedef void (* glRotatedProcPtr) (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
typedef void (* glRotatefProcPtr) (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
typedef void (* glScaledProcPtr) (GLdouble x, GLdouble y, GLdouble z);
typedef void (* glScalefProcPtr) (GLfloat x, GLfloat y, GLfloat z);
typedef void (* glScissorProcPtr) (GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (* glSelectBufferProcPtr) (GLsizei size, GLuint *buffer);
typedef void (* glSeparableFilter2DProcPtr) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
typedef void (* glShadeModelProcPtr) (GLenum mode);
typedef void (* glStencilFuncProcPtr) (GLenum func, GLint ref, GLuint mask);
typedef void (* glStencilMaskProcPtr) (GLuint mask);
typedef void (* glStencilOpProcPtr) (GLenum fail, GLenum zfail, GLenum zpass);
typedef void (* glTexCoord1dProcPtr) (GLdouble s);
typedef void (* glTexCoord1dvProcPtr) (const GLdouble *v);
typedef void (* glTexCoord1fProcPtr) (GLfloat s);
typedef void (* glTexCoord1fvProcPtr) (const GLfloat *v);
typedef void (* glTexCoord1iProcPtr) (GLint s);
typedef void (* glTexCoord1ivProcPtr) (const GLint *v);
typedef void (* glTexCoord1sProcPtr) (GLshort s);
typedef void (* glTexCoord1svProcPtr) (const GLshort *v);
typedef void (* glTexCoord2dProcPtr) (GLdouble s, GLdouble t);
typedef void (* glTexCoord2dvProcPtr) (const GLdouble *v);
typedef void (* glTexCoord2fProcPtr) (GLfloat s, GLfloat t);
typedef void (* glTexCoord2fvProcPtr) (const GLfloat *v);
typedef void (* glTexCoord2iProcPtr) (GLint s, GLint t);
typedef void (* glTexCoord2ivProcPtr) (const GLint *v);
typedef void (* glTexCoord2sProcPtr) (GLshort s, GLshort t);
typedef void (* glTexCoord2svProcPtr) (const GLshort *v);
typedef void (* glTexCoord3dProcPtr) (GLdouble s, GLdouble t, GLdouble r);
typedef void (* glTexCoord3dvProcPtr) (const GLdouble *v);
typedef void (* glTexCoord3fProcPtr) (GLfloat s, GLfloat t, GLfloat r);
typedef void (* glTexCoord3fvProcPtr) (const GLfloat *v);
typedef void (* glTexCoord3iProcPtr) (GLint s, GLint t, GLint r);
typedef void (* glTexCoord3ivProcPtr) (const GLint *v);
typedef void (* glTexCoord3sProcPtr) (GLshort s, GLshort t, GLshort r);
typedef void (* glTexCoord3svProcPtr) (const GLshort *v);
typedef void (* glTexCoord4dProcPtr) (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void (* glTexCoord4dvProcPtr) (const GLdouble *v);
typedef void (* glTexCoord4fProcPtr) (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void (* glTexCoord4fvProcPtr) (const GLfloat *v);
typedef void (* glTexCoord4iProcPtr) (GLint s, GLint t, GLint r, GLint q);
typedef void (* glTexCoord4ivProcPtr) (const GLint *v);
typedef void (* glTexCoord4sProcPtr) (GLshort s, GLshort t, GLshort r, GLshort q);
typedef void (* glTexCoord4svProcPtr) (const GLshort *v);
typedef void (* glTexCoordPointerProcPtr) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (* glTexEnvfProcPtr) (GLenum target, GLenum pname, GLfloat param);
typedef void (* glTexEnvfvProcPtr) (GLenum target, GLenum pname, const GLfloat *params);
typedef void (* glTexEnviProcPtr) (GLenum target, GLenum pname, GLint param);
typedef void (* glTexEnvivProcPtr) (GLenum target, GLenum pname, const GLint *params);
typedef void (* glTexGendProcPtr) (GLenum coord, GLenum pname, GLdouble param);
typedef void (* glTexGendvProcPtr) (GLenum coord, GLenum pname, const GLdouble *params);
typedef void (* glTexGenfProcPtr) (GLenum coord, GLenum pname, GLfloat param);
typedef void (* glTexGenfvProcPtr) (GLenum coord, GLenum pname, const GLfloat *params);
typedef void (* glTexGeniProcPtr) (GLenum coord, GLenum pname, GLint param);
typedef void (* glTexGenivProcPtr) (GLenum coord, GLenum pname, const GLint *params);
typedef void (* glTexImage1DProcPtr) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (* glTexImage2DProcPtr) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (* glTexImage3DProcPtr) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (* glTexParameterfProcPtr) (GLenum target, GLenum pname, GLfloat param);
typedef void (* glTexParameterfvProcPtr) (GLenum target, GLenum pname, const GLfloat *params);
typedef void (* glTexParameteriProcPtr) (GLenum target, GLenum pname, GLint param);
typedef void (* glTexParameterivProcPtr) (GLenum target, GLenum pname, const GLint *params);
typedef void (* glTexSubImage1DProcPtr) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (* glTexSubImage2DProcPtr) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (* glTexSubImage3DProcPtr) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (* glTranslatedProcPtr) (GLdouble x, GLdouble y, GLdouble z);
typedef void (* glTranslatefProcPtr) (GLfloat x, GLfloat y, GLfloat z);
typedef void (* glVertex2dProcPtr) (GLdouble x, GLdouble y);
typedef void (* glVertex2dvProcPtr) (const GLdouble *v);
typedef void (* glVertex2fProcPtr) (GLfloat x, GLfloat y);
typedef void (* glVertex2fvProcPtr) (const GLfloat *v);
typedef void (* glVertex2iProcPtr) (GLint x, GLint y);
typedef void (* glVertex2ivProcPtr) (const GLint *v);
typedef void (* glVertex2sProcPtr) (GLshort x, GLshort y);
typedef void (* glVertex2svProcPtr) (const GLshort *v);
typedef void (* glVertex3dProcPtr) (GLdouble x, GLdouble y, GLdouble z);
typedef void (* glVertex3dvProcPtr) (const GLdouble *v);
typedef void (* glVertex3fProcPtr) (GLfloat x, GLfloat y, GLfloat z);
typedef void (* glVertex3fvProcPtr) (const GLfloat *v);
typedef void (* glVertex3iProcPtr) (GLint x, GLint y, GLint z);
typedef void (* glVertex3ivProcPtr) (const GLint *v);
typedef void (* glVertex3sProcPtr) (GLshort x, GLshort y, GLshort z);
typedef void (* glVertex3svProcPtr) (const GLshort *v);
typedef void (* glVertex4dProcPtr) (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (* glVertex4dvProcPtr) (const GLdouble *v);
typedef void (* glVertex4fProcPtr) (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (* glVertex4fvProcPtr) (const GLfloat *v);
typedef void (* glVertex4iProcPtr) (GLint x, GLint y, GLint z, GLint w);
typedef void (* glVertex4ivProcPtr) (const GLint *v);
typedef void (* glVertex4sProcPtr) (GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (* glVertex4svProcPtr) (const GLshort *v);
typedef void (* glVertexPointerProcPtr) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (* glViewportProcPtr) (GLint x, GLint y, GLsizei width, GLsizei height);

typedef void (* glSampleCoverageProcPtr) (GLclampf value, GLboolean invert);

typedef void (* glLoadTransposeMatrixfProcPtr) (const GLfloat *m);
typedef void (* glLoadTransposeMatrixdProcPtr) (const GLdouble *m);
typedef void (* glMultTransposeMatrixfProcPtr) (const GLfloat *m);
typedef void (* glMultTransposeMatrixdProcPtr) (const GLdouble *m);

typedef void (* glCompressedTexImage3DProcPtr) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (* glCompressedTexImage2DProcPtr) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (* glCompressedTexImage1DProcPtr) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (* glCompressedTexSubImage3DProcPtr) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (* glCompressedTexSubImage2DProcPtr) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (* glCompressedTexSubImage1DProcPtr) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (* glGetCompressedTexImageProcPtr) (GLenum target, GLint lod, GLvoid *img);

typedef void (* glActiveTextureProcPtr) (GLenum texture);
typedef void (* glClientActiveTextureProcPtr) (GLenum texture);
typedef void (* glMultiTexCoord1dProcPtr) (GLenum target, GLdouble s);
typedef void (* glMultiTexCoord1dvProcPtr) (GLenum target, const GLdouble *v);
typedef void (* glMultiTexCoord1fProcPtr) (GLenum target, GLfloat s);
typedef void (* glMultiTexCoord1fvProcPtr) (GLenum target, const GLfloat *v);
typedef void (* glMultiTexCoord1iProcPtr) (GLenum target, GLint s);
typedef void (* glMultiTexCoord1ivProcPtr) (GLenum target, const GLint *v);
typedef void (* glMultiTexCoord1sProcPtr) (GLenum target, GLshort s);
typedef void (* glMultiTexCoord1svProcPtr) (GLenum target, const GLshort *v);
typedef void (* glMultiTexCoord2dProcPtr) (GLenum target, GLdouble s, GLdouble t);
typedef void (* glMultiTexCoord2dvProcPtr) (GLenum target, const GLdouble *v);
typedef void (* glMultiTexCoord2fProcPtr) (GLenum target, GLfloat s, GLfloat t);
typedef void (* glMultiTexCoord2fvProcPtr) (GLenum target, const GLfloat *v);
typedef void (* glMultiTexCoord2iProcPtr) (GLenum target, GLint s, GLint t);
typedef void (* glMultiTexCoord2ivProcPtr) (GLenum target, const GLint *v);
typedef void (* glMultiTexCoord2sProcPtr) (GLenum target, GLshort s, GLshort t);
typedef void (* glMultiTexCoord2svProcPtr) (GLenum target, const GLshort *v);
typedef void (* glMultiTexCoord3dProcPtr) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void (* glMultiTexCoord3dvProcPtr) (GLenum target, const GLdouble *v);
typedef void (* glMultiTexCoord3fProcPtr) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void (* glMultiTexCoord3fvProcPtr) (GLenum target, const GLfloat *v);
typedef void (* glMultiTexCoord3iProcPtr) (GLenum target, GLint s, GLint t, GLint r);
typedef void (* glMultiTexCoord3ivProcPtr) (GLenum target, const GLint *v);
typedef void (* glMultiTexCoord3sProcPtr) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void (* glMultiTexCoord3svProcPtr) (GLenum target, const GLshort *v);
typedef void (* glMultiTexCoord4dProcPtr) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void (* glMultiTexCoord4dvProcPtr) (GLenum target, const GLdouble *v);
typedef void (* glMultiTexCoord4fProcPtr) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void (* glMultiTexCoord4fvProcPtr) (GLenum target, const GLfloat *v);
typedef void (* glMultiTexCoord4iProcPtr) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void (* glMultiTexCoord4ivProcPtr) (GLenum target, const GLint *v);
typedef void (* glMultiTexCoord4sProcPtr) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void (* glMultiTexCoord4svProcPtr) (GLenum target, const GLshort *v);

typedef void (* glFogCoordfProcPtr) (GLfloat coord);
typedef void (* glFogCoordfvProcPtr) (const GLfloat *coord);  
typedef void (* glFogCoorddProcPtr) (GLdouble coord);
typedef void (* glFogCoorddvProcPtr) (const GLdouble *coord);   
typedef void (* glFogCoordPointerProcPtr) (GLenum type, GLsizei stride, const GLvoid *pointer);

typedef void (* glSecondaryColor3bProcPtr) (GLbyte red, GLbyte green, GLbyte blue);
typedef void (* glSecondaryColor3bvProcPtr) (const GLbyte *v);
typedef void (* glSecondaryColor3dProcPtr) (GLdouble red, GLdouble green, GLdouble blue);
typedef void (* glSecondaryColor3dvProcPtr) (const GLdouble *v);
typedef void (* glSecondaryColor3fProcPtr) (GLfloat red, GLfloat green, GLfloat blue);
typedef void (* glSecondaryColor3fvProcPtr) (const GLfloat *v);
typedef void (* glSecondaryColor3iProcPtr) (GLint red, GLint green, GLint blue);
typedef void (* glSecondaryColor3ivProcPtr) (const GLint *v);
typedef void (* glSecondaryColor3sProcPtr) (GLshort red, GLshort green, GLshort blue);
typedef void (* glSecondaryColor3svProcPtr) (const GLshort *v);
typedef void (* glSecondaryColor3ubProcPtr) (GLubyte red, GLubyte green, GLubyte blue);
typedef void (* glSecondaryColor3ubvProcPtr) (const GLubyte *v);
typedef void (* glSecondaryColor3uiProcPtr) (GLuint red, GLuint green, GLuint blue);
typedef void (* glSecondaryColor3uivProcPtr) (const GLuint *v);
typedef void (* glSecondaryColor3usProcPtr) (GLushort red, GLushort green, GLushort blue);
typedef void (* glSecondaryColor3usvProcPtr) (const GLushort *v);
typedef void (* glSecondaryColorPointerProcPtr) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

typedef void (* glPointParameterfProcPtr) (GLenum pname, GLfloat param); 
typedef void (* glPointParameterfvProcPtr) (GLenum pname, const GLfloat *params);
typedef void (* glPointParameteriProcPtr) (GLenum pname, GLint param); 
typedef void (* glPointParameterivProcPtr) (GLenum pname, const GLint *params);

typedef void (* glBlendFuncSeparateProcPtr) (GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);

typedef void (* glMultiDrawArraysProcPtr) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
typedef void (* glMultiDrawElementsProcPtr) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei primcount);

typedef void (* glWindowPos2dProcPtr) (GLdouble x, GLdouble y);
typedef void (* glWindowPos2dvProcPtr) (const GLdouble *v);
typedef void (* glWindowPos2fProcPtr) (GLfloat x, GLfloat y);
typedef void (* glWindowPos2fvProcPtr) (const GLfloat *v);
typedef void (* glWindowPos2iProcPtr) (GLint x, GLint y); 
typedef void (* glWindowPos2ivProcPtr) (const GLint *v);
typedef void (* glWindowPos2sProcPtr) (GLshort x, GLshort y);
typedef void (* glWindowPos2svProcPtr) (const GLshort *v);
typedef void (* glWindowPos3dProcPtr) (GLdouble x, GLdouble y, GLdouble z);
typedef void (* glWindowPos3dvProcPtr) (const GLdouble *v);
typedef void (* glWindowPos3fProcPtr) (GLfloat x, GLfloat y, GLfloat z);
typedef void (* glWindowPos3fvProcPtr) (const GLfloat *v);
typedef void (* glWindowPos3iProcPtr) (GLint x, GLint y, GLint z);
typedef void (* glWindowPos3ivProcPtr) (const GLint *v);
typedef void (* glWindowPos3sProcPtr) (GLshort x, GLshort y, GLshort z);
typedef void (* glWindowPos3svProcPtr) (const GLshort *v);

typedef void (* glGenQueriesProcPtr) (GLsizei n, GLuint *ids);
typedef void (* glDeleteQueriesProcPtr) (GLsizei n, const GLuint *ids);
typedef GLboolean (* glIsQueryProcPtr) (GLuint id);
typedef void (* glBeginQueryProcPtr) (GLenum target, GLuint id);
typedef void (* glEndQueryProcPtr) (GLenum target);
typedef void (* glGetQueryivProcPtr) (GLenum target, GLenum pname, GLint *params);
typedef void (* glGetQueryObjectivProcPtr) (GLuint id, GLenum pname, GLint *params);
typedef void (* glGetQueryObjectuivProcPtr) (GLuint id, GLenum pname, GLuint *params);

typedef void (* glBindBufferProcPtr) (GLenum target, GLuint buffer);
typedef void (* glDeleteBuffersProcPtr) (GLsizei n, const GLuint *buffers);
typedef void (* glGenBuffersProcPtr) (GLsizei n, GLuint *buffers);
typedef GLboolean (* glIsBufferProcPtr) (GLuint buffer);
typedef void (* glBufferDataProcPtr) (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
typedef void (* glBufferSubDataProcPtr) (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
typedef void (* glGetBufferSubDataProcPtr) (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
typedef GLvoid *(* glMapBufferProcPtr) (GLenum target, GLenum access);
typedef GLboolean (* glUnmapBufferProcPtr) (GLenum target);
typedef void (* glGetBufferParameterivProcPtr) (GLenum target, GLenum pname, GLint *params);
typedef void (* glGetBufferPointervProcPtr) (GLenum target, GLenum pname, GLvoid **params);

typedef void (* glDrawBuffersProcPtr) (GLsizei n, const GLenum *bufs);
typedef void (* glVertexAttrib1dProcPtr) (GLuint index, GLdouble x);
typedef void (* glVertexAttrib1dvProcPtr) (GLuint index, const GLdouble *v);
typedef void (* glVertexAttrib1fProcPtr) (GLuint index, GLfloat x);
typedef void (* glVertexAttrib1fvProcPtr) (GLuint index, const GLfloat *v);
typedef void (* glVertexAttrib1sProcPtr) (GLuint index, GLshort x);
typedef void (* glVertexAttrib1svProcPtr) (GLuint index, const GLshort *v);
typedef void (* glVertexAttrib2dProcPtr) (GLuint index, GLdouble x, GLdouble y);
typedef void (* glVertexAttrib2dvProcPtr) (GLuint index, const GLdouble *v);
typedef void (* glVertexAttrib2fProcPtr) (GLuint index, GLfloat x, GLfloat y);
typedef void (* glVertexAttrib2fvProcPtr) (GLuint index, const GLfloat *v);
typedef void (* glVertexAttrib2sProcPtr) (GLuint index, GLshort x, GLshort y);
typedef void (* glVertexAttrib2svProcPtr) (GLuint index, const GLshort *v);
typedef void (* glVertexAttrib3dProcPtr) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (* glVertexAttrib3dvProcPtr) (GLuint index, const GLdouble *v);
typedef void (* glVertexAttrib3fProcPtr) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (* glVertexAttrib3fvProcPtr) (GLuint index, const GLfloat *v);
typedef void (* glVertexAttrib3sProcPtr) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (* glVertexAttrib3svProcPtr) (GLuint index, const GLshort *v);
typedef void (* glVertexAttrib4NbvProcPtr) (GLuint index, const GLbyte *v);
typedef void (* glVertexAttrib4NivProcPtr) (GLuint index, const GLint *v);
typedef void (* glVertexAttrib4NsvProcPtr) (GLuint index, const GLshort *v);
typedef void (* glVertexAttrib4NubProcPtr) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (* glVertexAttrib4NubvProcPtr) (GLuint index, const GLubyte *v);
typedef void (* glVertexAttrib4NuivProcPtr) (GLuint index, const GLuint *v);
typedef void (* glVertexAttrib4NusvProcPtr) (GLuint index, const GLushort *v);
typedef void (* glVertexAttrib4bvProcPtr) (GLuint index, const GLbyte *v);
typedef void (* glVertexAttrib4dProcPtr) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (* glVertexAttrib4dvProcPtr) (GLuint index, const GLdouble *v);
typedef void (* glVertexAttrib4fProcPtr) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (* glVertexAttrib4fvProcPtr) (GLuint index, const GLfloat *v);
typedef void (* glVertexAttrib4ivProcPtr) (GLuint index, const GLint *v);
typedef void (* glVertexAttrib4sProcPtr) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (* glVertexAttrib4svProcPtr) (GLuint index, const GLshort *v);
typedef void (* glVertexAttrib4ubvProcPtr) (GLuint index, const GLubyte *v);
typedef void (* glVertexAttrib4uivProcPtr) (GLuint index, const GLuint *v);
typedef void (* glVertexAttrib4usvProcPtr) (GLuint index, const GLushort *v);
typedef void (* glVertexAttribPointerProcPtr) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
typedef void (* glEnableVertexAttribArrayProcPtr) (GLuint index);
typedef void (* glDisableVertexAttribArrayProcPtr) (GLuint index);
typedef void (* glGetVertexAttribdvProcPtr) (GLuint index, GLenum pname, GLdouble *params);
typedef void (* glGetVertexAttribfvProcPtr) (GLuint index, GLenum pname, GLfloat *params);
typedef void (* glGetVertexAttribivProcPtr) (GLuint index, GLenum pname, GLint *params);
typedef void (* glGetVertexAttribPointervProcPtr) (GLuint index, GLenum pname, GLvoid **pointer);
typedef void (* glDeleteShaderProcPtr) (GLuint shader);
typedef void (* glDetachShaderProcPtr) (GLuint program, GLuint shader);
typedef GLuint (* glCreateShaderProcPtr) (GLenum type);
typedef void (* glShaderSourceProcPtr) (GLuint shader, GLsizei count, const GLchar* const *string, const GLint *length);
typedef void (* glCompileShaderProcPtr) (GLuint shader);
typedef GLuint (* glCreateProgramProcPtr) (void);
typedef void (* glAttachShaderProcPtr) (GLuint program, GLuint shader);
typedef void (* glLinkProgramProcPtr) (GLuint program);
typedef void (* glUseProgramProcPtr) (GLuint program);
typedef void (* glDeleteProgramProcPtr) (GLuint program);
typedef void (* glValidateProgramProcPtr) (GLuint program);
typedef void (* glUniform1fProcPtr) (GLint location, GLfloat v0);
typedef void (* glUniform2fProcPtr) (GLint location, GLfloat v0, GLfloat v1);
typedef void (* glUniform3fProcPtr) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (* glUniform4fProcPtr) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (* glUniform1iProcPtr) (GLint location, GLint v0);
typedef void (* glUniform2iProcPtr) (GLint location, GLint v0, GLint v1);
typedef void (* glUniform3iProcPtr) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void (* glUniform4iProcPtr) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (* glUniform1fvProcPtr) (GLint location, GLsizei count, const GLfloat *value);
typedef void (* glUniform2fvProcPtr) (GLint location, GLsizei count, const GLfloat *value);
typedef void (* glUniform3fvProcPtr) (GLint location, GLsizei count, const GLfloat *value);
typedef void (* glUniform4fvProcPtr) (GLint location, GLsizei count, const GLfloat *value);
typedef void (* glUniform1ivProcPtr) (GLint location, GLsizei count, const GLint *value);
typedef void (* glUniform2ivProcPtr) (GLint location, GLsizei count, const GLint *value);
typedef void (* glUniform3ivProcPtr) (GLint location, GLsizei count, const GLint *value);
typedef void (* glUniform4ivProcPtr) (GLint location, GLsizei count, const GLint *value);
typedef void (* glUniformMatrix2fvProcPtr) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (* glUniformMatrix3fvProcPtr) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (* glUniformMatrix4fvProcPtr) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef GLboolean (* glIsShaderProcPtr) (GLuint shader);
typedef GLboolean (* glIsProgramProcPtr) (GLuint program);
typedef void (* glGetShaderivProcPtr) (GLuint shader, GLenum pname, GLint *params);
typedef void (* glGetProgramivProcPtr) (GLuint program, GLenum pname, GLint *params);
typedef void (* glGetAttachedShadersProcPtr) (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
typedef void (* glGetShaderInfoLogProcPtr) (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
typedef void (* glGetProgramInfoLogProcPtr) (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
typedef GLint (* glGetUniformLocationProcPtr) (GLuint program, const GLchar *name);
typedef void (* glGetActiveUniformProcPtr) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
typedef void (* glGetUniformfvProcPtr) (GLuint program, GLint location, GLfloat *params);
typedef void (* glGetUniformivProcPtr) (GLuint program, GLint location, GLint *params);
typedef void (* glGetShaderSourceProcPtr) (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
typedef void (* glBindAttribLocationProcPtr) (GLuint program, GLuint index, const GLchar *name);
typedef void (* glGetActiveAttribProcPtr) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
typedef GLint (* glGetAttribLocationProcPtr) (GLuint program, const GLchar *name);
typedef void (* glStencilFuncSeparateProcPtr) (GLenum face, GLenum func, GLint ref, GLuint mask);
typedef void (* glStencilOpSeparateProcPtr) (GLenum face, GLenum fail, GLenum zfail, GLenum zpass);
typedef void (* glStencilMaskSeparateProcPtr) (GLenum face, GLuint mask);

typedef void (* glUniformMatrix2x3fvProcPtr) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (* glUniformMatrix3x2fvProcPtr) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (* glUniformMatrix2x4fvProcPtr) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (* glUniformMatrix4x2fvProcPtr) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (* glUniformMatrix3x4fvProcPtr) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (* glUniformMatrix4x3fvProcPtr) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);

#else /* GL_GLEXT_FUNCTION_POINTERS */

extern void glAccum (GLenum op, GLfloat value);
extern void glAlphaFunc (GLenum func, GLclampf ref);
extern GLboolean glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
extern void glArrayElement (GLint i);
extern void glBegin (GLenum mode);
extern void glBindTexture (GLenum target, GLuint texture);
extern void glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
extern void glBlendColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void glBlendEquation (GLenum mode);
extern void glBlendEquationSeparate (GLenum modeRGB, GLenum modeAlpha);
extern void glBlendFunc (GLenum sfactor, GLenum dfactor);
extern void glCallList (GLuint list);
extern void glCallLists (GLsizei n, GLenum type, const GLvoid *lists);
extern void glClear (GLbitfield mask);
extern void glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void glClearDepth (GLclampd depth);
extern void glClearIndex (GLfloat c);
extern void glClearStencil (GLint s);
extern void glClipPlane (GLenum plane, const GLdouble *equation);
extern void glColor3b (GLbyte red, GLbyte green, GLbyte blue);
extern void glColor3bv (const GLbyte *v);
extern void glColor3d (GLdouble red, GLdouble green, GLdouble blue);
extern void glColor3dv (const GLdouble *v);
extern void glColor3f (GLfloat red, GLfloat green, GLfloat blue);
extern void glColor3fv (const GLfloat *v);
extern void glColor3i (GLint red, GLint green, GLint blue);
extern void glColor3iv (const GLint *v);
extern void glColor3s (GLshort red, GLshort green, GLshort blue);
extern void glColor3sv (const GLshort *v);
extern void glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
extern void glColor3ubv (const GLubyte *v);
extern void glColor3ui (GLuint red, GLuint green, GLuint blue);
extern void glColor3uiv (const GLuint *v);
extern void glColor3us (GLushort red, GLushort green, GLushort blue);
extern void glColor3usv (const GLushort *v);
extern void glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
extern void glColor4bv (const GLbyte *v);
extern void glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
extern void glColor4dv (const GLdouble *v);
extern void glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void glColor4fv (const GLfloat *v);
extern void glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
extern void glColor4iv (const GLint *v);
extern void glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
extern void glColor4sv (const GLshort *v);
extern void glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
extern void glColor4ubv (const GLubyte *v);
extern void glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
extern void glColor4uiv (const GLuint *v);
extern void glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
extern void glColor4usv (const GLushort *v);
extern void glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern void glColorMaterial (GLenum face, GLenum mode);
extern void glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glColorSubTable (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
extern void glColorTable (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
extern void glColorTableParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glColorTableParameteriv (GLenum target, GLenum pname, const GLint *params);
extern void glConvolutionFilter1D (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
extern void glConvolutionFilter2D (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
extern void glConvolutionParameterf (GLenum target, GLenum pname, GLfloat params);
extern void glConvolutionParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glConvolutionParameteri (GLenum target, GLenum pname, GLint params);
extern void glConvolutionParameteriv (GLenum target, GLenum pname, const GLint *params);
extern void glCopyColorSubTable (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
extern void glCopyColorTable (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern void glCopyConvolutionFilter1D (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern void glCopyConvolutionFilter2D (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
extern void glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
extern void glCopyTexImage1D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
extern void glCopyTexImage2D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern void glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern void glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void glCopyTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void glCullFace (GLenum mode);
extern void glDeleteLists (GLuint list, GLsizei range);
extern void glDeleteTextures (GLsizei n, const GLuint *textures);
extern void glDepthFunc (GLenum func);
extern void glDepthMask (GLboolean flag);
extern void glDepthRange (GLclampd zNear, GLclampd zFar);
extern void glDisable (GLenum cap);
extern void glDisableClientState (GLenum array);
extern void glDrawArrays (GLenum mode, GLint first, GLsizei count);
extern void glDrawBuffer (GLenum mode);
extern void glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
extern void glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void glDrawRangeElements (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
extern void glEdgeFlag (GLboolean flag);
extern void glEdgeFlagPointer (GLsizei stride, const GLvoid *pointer);
extern void glEdgeFlagv (const GLboolean *flag);
extern void glEnable (GLenum cap);
extern void glEnableClientState (GLenum array);
extern void glEnd (void);
extern void glEndList (void);
extern void glEvalCoord1d (GLdouble u);
extern void glEvalCoord1dv (const GLdouble *u);
extern void glEvalCoord1f (GLfloat u);
extern void glEvalCoord1fv (const GLfloat *u);
extern void glEvalCoord2d (GLdouble u, GLdouble v);
extern void glEvalCoord2dv (const GLdouble *u);
extern void glEvalCoord2f (GLfloat u, GLfloat v);
extern void glEvalCoord2fv (const GLfloat *u);
extern void glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
extern void glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
extern void glEvalPoint1 (GLint i);
extern void glEvalPoint2 (GLint i, GLint j);
extern void glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
extern void glFinish (void);
extern void glFlush (void);
extern void glFogf (GLenum pname, GLfloat param);
extern void glFogfv (GLenum pname, const GLfloat *params);
extern void glFogi (GLenum pname, GLint param);
extern void glFogiv (GLenum pname, const GLint *params);
extern void glFrontFace (GLenum mode);
extern void glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern GLuint glGenLists (GLsizei range);
extern void glGenTextures (GLsizei n, GLuint *textures);
extern void glGetBooleanv (GLenum pname, GLboolean *params);
extern void glGetClipPlane (GLenum plane, GLdouble *equation);
extern void glGetColorTable (GLenum target, GLenum format, GLenum type, GLvoid *table);
extern void glGetColorTableParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetColorTableParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetConvolutionFilter (GLenum target, GLenum format, GLenum type, GLvoid *image);
extern void glGetConvolutionParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetConvolutionParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetDoublev (GLenum pname, GLdouble *params);
extern GLenum glGetError (void);
extern void glGetFloatv (GLenum pname, GLfloat *params);
extern void glGetHistogram (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
extern void glGetHistogramParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetHistogramParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetIntegerv (GLenum pname, GLint *params);
extern void glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
extern void glGetLightiv (GLenum light, GLenum pname, GLint *params);
extern void glGetMapdv (GLenum target, GLenum query, GLdouble *v);
extern void glGetMapfv (GLenum target, GLenum query, GLfloat *v);
extern void glGetMapiv (GLenum target, GLenum query, GLint *v);
extern void glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
extern void glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
extern void glGetMinmax (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
extern void glGetMinmaxParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetMinmaxParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetPixelMapfv (GLenum map, GLfloat *values);
extern void glGetPixelMapuiv (GLenum map, GLuint *values);
extern void glGetPixelMapusv (GLenum map, GLushort *values);
extern void glGetPointerv (GLenum pname, GLvoid **params);
extern void glGetPolygonStipple (GLubyte *mask);
extern void glGetSeparableFilter (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
extern const GLubyte *glGetString (GLenum name);
extern void glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
extern void glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
extern void glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
extern void glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
extern void glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
extern void glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
extern void glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
extern void glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glHint (GLenum target, GLenum mode);
extern void glHistogram (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
extern void glIndexMask (GLuint mask);
extern void glIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glIndexd (GLdouble c);
extern void glIndexdv (const GLdouble *c);
extern void glIndexf (GLfloat c);
extern void glIndexfv (const GLfloat *c);
extern void glIndexi (GLint c);
extern void glIndexiv (const GLint *c);
extern void glIndexs (GLshort c);
extern void glIndexsv (const GLshort *c);
extern void glIndexub (GLubyte c);
extern void glIndexubv (const GLubyte *c);
extern void glInitNames (void);
extern void glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer);
extern GLboolean glIsEnabled (GLenum cap);
extern GLboolean glIsList (GLuint list);
extern GLboolean glIsTexture (GLuint texture);
extern void glLightModelf (GLenum pname, GLfloat param);
extern void glLightModelfv (GLenum pname, const GLfloat *params);
extern void glLightModeli (GLenum pname, GLint param);
extern void glLightModeliv (GLenum pname, const GLint *params);
extern void glLightf (GLenum light, GLenum pname, GLfloat param);
extern void glLightfv (GLenum light, GLenum pname, const GLfloat *params);
extern void glLighti (GLenum light, GLenum pname, GLint param);
extern void glLightiv (GLenum light, GLenum pname, const GLint *params);
extern void glLineStipple (GLint factor, GLushort pattern);
extern void glLineWidth (GLfloat width);
extern void glListBase (GLuint base);
extern void glLoadIdentity (void);
extern void glLoadMatrixd (const GLdouble *m);
extern void glLoadMatrixf (const GLfloat *m);
extern void glLoadName (GLuint name);
extern void glLogicOp (GLenum opcode);
extern void glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern void glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern void glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern void glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
extern void glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
extern void glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
extern void glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
extern void glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
extern void glMaterialf (GLenum face, GLenum pname, GLfloat param);
extern void glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
extern void glMateriali (GLenum face, GLenum pname, GLint param);
extern void glMaterialiv (GLenum face, GLenum pname, const GLint *params);
extern void glMatrixMode (GLenum mode);
extern void glMinmax (GLenum target, GLenum internalformat, GLboolean sink);
extern void glMultMatrixd (const GLdouble *m);
extern void glMultMatrixf (const GLfloat *m);
extern void glNewList (GLuint list, GLenum mode);
extern void glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
extern void glNormal3bv (const GLbyte *v);
extern void glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
extern void glNormal3dv (const GLdouble *v);
extern void glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
extern void glNormal3fv (const GLfloat *v);
extern void glNormal3i (GLint nx, GLint ny, GLint nz);
extern void glNormal3iv (const GLint *v);
extern void glNormal3s (GLshort nx, GLshort ny, GLshort nz);
extern void glNormal3sv (const GLshort *v);
extern void glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern void glPassThrough (GLfloat token);
extern void glPixelMapfv (GLenum map, GLint mapsize, const GLfloat *values);
extern void glPixelMapuiv (GLenum map, GLint mapsize, const GLuint *values);
extern void glPixelMapusv (GLenum map, GLint mapsize, const GLushort *values);
extern void glPixelStoref (GLenum pname, GLfloat param);
extern void glPixelStorei (GLenum pname, GLint param);
extern void glPixelTransferf (GLenum pname, GLfloat param);
extern void glPixelTransferi (GLenum pname, GLint param);
extern void glPixelZoom (GLfloat xfactor, GLfloat yfactor);
extern void glPointSize (GLfloat size);
extern void glPolygonMode (GLenum face, GLenum mode);
extern void glPolygonOffset (GLfloat factor, GLfloat units);
extern void glPolygonStipple (const GLubyte *mask);
extern void glPopAttrib (void);
extern void glPopClientAttrib (void);
extern void glPopMatrix (void);
extern void glPopName (void);
extern void glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
extern void glPushAttrib (GLbitfield mask);
extern void glPushClientAttrib (GLbitfield mask);
extern void glPushMatrix (void);
extern void glPushName (GLuint name);
extern void glRasterPos2d (GLdouble x, GLdouble y);
extern void glRasterPos2dv (const GLdouble *v);
extern void glRasterPos2f (GLfloat x, GLfloat y);
extern void glRasterPos2fv (const GLfloat *v);
extern void glRasterPos2i (GLint x, GLint y);
extern void glRasterPos2iv (const GLint *v);
extern void glRasterPos2s (GLshort x, GLshort y);
extern void glRasterPos2sv (const GLshort *v);
extern void glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
extern void glRasterPos3dv (const GLdouble *v);
extern void glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
extern void glRasterPos3fv (const GLfloat *v);
extern void glRasterPos3i (GLint x, GLint y, GLint z);
extern void glRasterPos3iv (const GLint *v);
extern void glRasterPos3s (GLshort x, GLshort y, GLshort z);
extern void glRasterPos3sv (const GLshort *v);
extern void glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glRasterPos4dv (const GLdouble *v);
extern void glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glRasterPos4fv (const GLfloat *v);
extern void glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
extern void glRasterPos4iv (const GLint *v);
extern void glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
extern void glRasterPos4sv (const GLshort *v);
extern void glReadBuffer (GLenum mode);
extern void glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
extern void glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
extern void glRectdv (const GLdouble *v1, const GLdouble *v2);
extern void glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
extern void glRectfv (const GLfloat *v1, const GLfloat *v2);
extern void glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
extern void glRectiv (const GLint *v1, const GLint *v2);
extern void glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
extern void glRectsv (const GLshort *v1, const GLshort *v2);
extern GLint glRenderMode (GLenum mode);
extern void glResetHistogram (GLenum target);
extern void glResetMinmax (GLenum target);
extern void glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
extern void glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
extern void glScaled (GLdouble x, GLdouble y, GLdouble z);
extern void glScalef (GLfloat x, GLfloat y, GLfloat z);
extern void glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
extern void glSelectBuffer (GLsizei size, GLuint *buffer);
extern void glSeparableFilter2D (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
extern void glShadeModel (GLenum mode);
extern void glStencilFunc (GLenum func, GLint ref, GLuint mask);
extern void glStencilMask (GLuint mask);
extern void glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
extern void glTexCoord1d (GLdouble s);
extern void glTexCoord1dv (const GLdouble *v);
extern void glTexCoord1f (GLfloat s);
extern void glTexCoord1fv (const GLfloat *v);
extern void glTexCoord1i (GLint s);
extern void glTexCoord1iv (const GLint *v);
extern void glTexCoord1s (GLshort s);
extern void glTexCoord1sv (const GLshort *v);
extern void glTexCoord2d (GLdouble s, GLdouble t);
extern void glTexCoord2dv (const GLdouble *v);
extern void glTexCoord2f (GLfloat s, GLfloat t);
extern void glTexCoord2fv (const GLfloat *v);
extern void glTexCoord2i (GLint s, GLint t);
extern void glTexCoord2iv (const GLint *v);
extern void glTexCoord2s (GLshort s, GLshort t);
extern void glTexCoord2sv (const GLshort *v);
extern void glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
extern void glTexCoord3dv (const GLdouble *v);
extern void glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
extern void glTexCoord3fv (const GLfloat *v);
extern void glTexCoord3i (GLint s, GLint t, GLint r);
extern void glTexCoord3iv (const GLint *v);
extern void glTexCoord3s (GLshort s, GLshort t, GLshort r);
extern void glTexCoord3sv (const GLshort *v);
extern void glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void glTexCoord4dv (const GLdouble *v);
extern void glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void glTexCoord4fv (const GLfloat *v);
extern void glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
extern void glTexCoord4iv (const GLint *v);
extern void glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
extern void glTexCoord4sv (const GLshort *v);
extern void glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glTexEnvf (GLenum target, GLenum pname, GLfloat param);
extern void glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glTexEnvi (GLenum target, GLenum pname, GLint param);
extern void glTexEnviv (GLenum target, GLenum pname, const GLint *params);
extern void glTexGend (GLenum coord, GLenum pname, GLdouble param);
extern void glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
extern void glTexGenf (GLenum coord, GLenum pname, GLfloat param);
extern void glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
extern void glTexGeni (GLenum coord, GLenum pname, GLint param);
extern void glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
extern void glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexImage3D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexParameterf (GLenum target, GLenum pname, GLfloat param);
extern void glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glTexParameteri (GLenum target, GLenum pname, GLint param);
extern void glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
extern void glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTranslated (GLdouble x, GLdouble y, GLdouble z);
extern void glTranslatef (GLfloat x, GLfloat y, GLfloat z);
extern void glVertex2d (GLdouble x, GLdouble y);
extern void glVertex2dv (const GLdouble *v);
extern void glVertex2f (GLfloat x, GLfloat y);
extern void glVertex2fv (const GLfloat *v);
extern void glVertex2i (GLint x, GLint y);
extern void glVertex2iv (const GLint *v);
extern void glVertex2s (GLshort x, GLshort y);
extern void glVertex2sv (const GLshort *v);
extern void glVertex3d (GLdouble x, GLdouble y, GLdouble z);
extern void glVertex3dv (const GLdouble *v);
extern void glVertex3f (GLfloat x, GLfloat y, GLfloat z);
extern void glVertex3fv (const GLfloat *v);
extern void glVertex3i (GLint x, GLint y, GLint z);
extern void glVertex3iv (const GLint *v);
extern void glVertex3s (GLshort x, GLshort y, GLshort z);
extern void glVertex3sv (const GLshort *v);
extern void glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertex4dv (const GLdouble *v);
extern void glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertex4fv (const GLfloat *v);
extern void glVertex4i (GLint x, GLint y, GLint z, GLint w);
extern void glVertex4iv (const GLint *v);
extern void glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertex4sv (const GLshort *v);
extern void glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glViewport (GLint x, GLint y, GLsizei width, GLsizei height);

extern void glSampleCoverage (GLclampf value, GLboolean invert);

extern void glLoadTransposeMatrixf (const GLfloat *m);
extern void glLoadTransposeMatrixd (const GLdouble *m);
extern void glMultTransposeMatrixf (const GLfloat *m);
extern void glMultTransposeMatrixd (const GLdouble *m);

extern void glCompressedTexImage3D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexImage1D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glGetCompressedTexImage (GLenum target, GLint lod, GLvoid *img);

extern void glActiveTexture (GLenum texture);
extern void glClientActiveTexture (GLenum texture);
extern void glMultiTexCoord1d (GLenum target, GLdouble s);
extern void glMultiTexCoord1dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord1f (GLenum target, GLfloat s);
extern void glMultiTexCoord1fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord1i (GLenum target, GLint s);
extern void glMultiTexCoord1iv (GLenum target, const GLint *v);
extern void glMultiTexCoord1s (GLenum target, GLshort s);
extern void glMultiTexCoord1sv (GLenum target, const GLshort *v);
extern void glMultiTexCoord2d (GLenum target, GLdouble s, GLdouble t);
extern void glMultiTexCoord2dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord2f (GLenum target, GLfloat s, GLfloat t);
extern void glMultiTexCoord2fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord2i (GLenum target, GLint s, GLint t);
extern void glMultiTexCoord2iv (GLenum target, const GLint *v);
extern void glMultiTexCoord2s (GLenum target, GLshort s, GLshort t);
extern void glMultiTexCoord2sv (GLenum target, const GLshort *v);
extern void glMultiTexCoord3d (GLenum target, GLdouble s, GLdouble t, GLdouble r);
extern void glMultiTexCoord3dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord3f (GLenum target, GLfloat s, GLfloat t, GLfloat r);
extern void glMultiTexCoord3fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord3i (GLenum target, GLint s, GLint t, GLint r);
extern void glMultiTexCoord3iv (GLenum target, const GLint *v);
extern void glMultiTexCoord3s (GLenum target, GLshort s, GLshort t, GLshort r);
extern void glMultiTexCoord3sv (GLenum target, const GLshort *v);
extern void glMultiTexCoord4d (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void glMultiTexCoord4dv (GLenum target, const GLdouble *v);
extern void glMultiTexCoord4f (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void glMultiTexCoord4fv (GLenum target, const GLfloat *v);
extern void glMultiTexCoord4i (GLenum target, GLint s, GLint t, GLint r, GLint q);
extern void glMultiTexCoord4iv (GLenum target, const GLint *v);
extern void glMultiTexCoord4s (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
extern void glMultiTexCoord4sv (GLenum target, const GLshort *v);

extern void glFogCoordf (GLfloat coord);
extern void glFogCoordfv (const GLfloat *coord);  
extern void glFogCoordd (GLdouble coord);
extern void glFogCoorddv (const GLdouble *coord);   
extern void glFogCoordPointer (GLenum type, GLsizei stride, const GLvoid *pointer);

extern void glSecondaryColor3b (GLbyte red, GLbyte green, GLbyte blue);
extern void glSecondaryColor3bv (const GLbyte *v);
extern void glSecondaryColor3d (GLdouble red, GLdouble green, GLdouble blue);
extern void glSecondaryColor3dv (const GLdouble *v);
extern void glSecondaryColor3f (GLfloat red, GLfloat green, GLfloat blue);
extern void glSecondaryColor3fv (const GLfloat *v);
extern void glSecondaryColor3i (GLint red, GLint green, GLint blue);
extern void glSecondaryColor3iv (const GLint *v);
extern void glSecondaryColor3s (GLshort red, GLshort green, GLshort blue);
extern void glSecondaryColor3sv (const GLshort *v);
extern void glSecondaryColor3ub (GLubyte red, GLubyte green, GLubyte blue);
extern void glSecondaryColor3ubv (const GLubyte *v);
extern void glSecondaryColor3ui (GLuint red, GLuint green, GLuint blue);
extern void glSecondaryColor3uiv (const GLuint *v);
extern void glSecondaryColor3us (GLushort red, GLushort green, GLushort blue);
extern void glSecondaryColor3usv (const GLushort *v);
extern void glSecondaryColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

extern void glPointParameterf (GLenum pname, GLfloat param); 
extern void glPointParameterfv (GLenum pname, const GLfloat *params);
extern void glPointParameteri (GLenum pname, GLint param); 
extern void glPointParameteriv (GLenum pname, const GLint *params);

extern void glBlendFuncSeparate (GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);

extern void glMultiDrawArrays (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
extern void glMultiDrawElements (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei primcount);

extern void glWindowPos2d (GLdouble x, GLdouble y);
extern void glWindowPos2dv (const GLdouble *v);
extern void glWindowPos2f (GLfloat x, GLfloat y);
extern void glWindowPos2fv (const GLfloat *v);
extern void glWindowPos2i (GLint x, GLint y); 
extern void glWindowPos2iv (const GLint *v);
extern void glWindowPos2s (GLshort x, GLshort y);
extern void glWindowPos2sv (const GLshort *v);
extern void glWindowPos3d (GLdouble x, GLdouble y, GLdouble z);
extern void glWindowPos3dv (const GLdouble *v);
extern void glWindowPos3f (GLfloat x, GLfloat y, GLfloat z);
extern void glWindowPos3fv (const GLfloat *v);
extern void glWindowPos3i (GLint x, GLint y, GLint z);
extern void glWindowPos3iv (const GLint *v);
extern void glWindowPos3s (GLshort x, GLshort y, GLshort z);
extern void glWindowPos3sv (const GLshort *v);

extern void glGenQueries (GLsizei n, GLuint *ids);
extern void glDeleteQueries (GLsizei n, const GLuint *ids);
extern GLboolean glIsQuery (GLuint id);
extern void glBeginQuery (GLenum target, GLuint id);
extern void glEndQuery (GLenum target);
extern void glGetQueryiv (GLenum target, GLenum pname, GLint *params);
extern void glGetQueryObjectiv (GLuint id, GLenum pname, GLint *params);
extern void glGetQueryObjectuiv (GLuint id, GLenum pname, GLuint *params);

extern void glBindBuffer (GLenum target, GLuint buffer);
extern void glDeleteBuffers (GLsizei n, const GLuint *buffers);
extern void glGenBuffers (GLsizei n, GLuint *buffers);
extern GLboolean glIsBuffer (GLuint buffer);
extern void glBufferData (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
extern void glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
extern void glGetBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
extern GLvoid *glMapBuffer (GLenum target, GLenum access);
extern GLboolean glUnmapBuffer (GLenum target);
extern void glGetBufferParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glGetBufferPointerv (GLenum target, GLenum pname, GLvoid **params);

extern void glDrawBuffers (GLsizei n, const GLenum *bufs);
extern void glVertexAttrib1d (GLuint index, GLdouble x);
extern void glVertexAttrib1dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib1f (GLuint index, GLfloat x);
extern void glVertexAttrib1fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib1s (GLuint index, GLshort x);
extern void glVertexAttrib1sv (GLuint index, const GLshort *v);
extern void glVertexAttrib2d (GLuint index, GLdouble x, GLdouble y);
extern void glVertexAttrib2dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib2f (GLuint index, GLfloat x, GLfloat y);
extern void glVertexAttrib2fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib2s (GLuint index, GLshort x, GLshort y);
extern void glVertexAttrib2sv (GLuint index, const GLshort *v);
extern void glVertexAttrib3d (GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern void glVertexAttrib3dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib3f (GLuint index, GLfloat x, GLfloat y, GLfloat z);
extern void glVertexAttrib3fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib3s (GLuint index, GLshort x, GLshort y, GLshort z);
extern void glVertexAttrib3sv (GLuint index, const GLshort *v);
extern void glVertexAttrib4Nbv (GLuint index, const GLbyte *v);
extern void glVertexAttrib4Niv (GLuint index, const GLint *v);
extern void glVertexAttrib4Nsv (GLuint index, const GLshort *v);
extern void glVertexAttrib4Nub (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
extern void glVertexAttrib4Nubv (GLuint index, const GLubyte *v);
extern void glVertexAttrib4Nuiv (GLuint index, const GLuint *v);
extern void glVertexAttrib4Nusv (GLuint index, const GLushort *v);
extern void glVertexAttrib4bv (GLuint index, const GLbyte *v);
extern void glVertexAttrib4d (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertexAttrib4dv (GLuint index, const GLdouble *v);
extern void glVertexAttrib4f (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertexAttrib4fv (GLuint index, const GLfloat *v);
extern void glVertexAttrib4iv (GLuint index, const GLint *v);
extern void glVertexAttrib4s (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertexAttrib4sv (GLuint index, const GLshort *v);
extern void glVertexAttrib4ubv (GLuint index, const GLubyte *v);
extern void glVertexAttrib4uiv (GLuint index, const GLuint *v);
extern void glVertexAttrib4usv (GLuint index, const GLushort *v);
extern void glVertexAttribPointer (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
extern void glEnableVertexAttribArray (GLuint index);
extern void glDisableVertexAttribArray (GLuint index);
extern void glGetVertexAttribdv (GLuint index, GLenum pname, GLdouble *params);
extern void glGetVertexAttribfv (GLuint index, GLenum pname, GLfloat *params);
extern void glGetVertexAttribiv (GLuint index, GLenum pname, GLint *params);
extern void glGetVertexAttribPointerv (GLuint index, GLenum pname, GLvoid **pointer);
extern void glDeleteShader (GLuint shader);
extern void glDetachShader (GLuint program, GLuint shader);
extern GLuint glCreateShader (GLenum type);
extern void glShaderSource (GLuint shader, GLsizei count, const GLchar* const *string, const GLint *length);
extern void glCompileShader (GLuint shader);
extern GLuint glCreateProgram (void);
extern void glAttachShader (GLuint program, GLuint shader);
extern void glLinkProgram (GLuint program);
extern void glUseProgram (GLuint program);
extern void glDeleteProgram (GLuint program);
extern void glValidateProgram (GLuint program);
extern void glUniform1f (GLint location, GLfloat v0);
extern void glUniform2f (GLint location, GLfloat v0, GLfloat v1);
extern void glUniform3f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
extern void glUniform4f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
extern void glUniform1i (GLint location, GLint v0);
extern void glUniform2i (GLint location, GLint v0, GLint v1);
extern void glUniform3i (GLint location, GLint v0, GLint v1, GLint v2);
extern void glUniform4i (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
extern void glUniform1fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform2fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform3fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform4fv (GLint location, GLsizei count, const GLfloat *value);
extern void glUniform1iv (GLint location, GLsizei count, const GLint *value);
extern void glUniform2iv (GLint location, GLsizei count, const GLint *value);
extern void glUniform3iv (GLint location, GLsizei count, const GLint *value);
extern void glUniform4iv (GLint location, GLsizei count, const GLint *value);
extern void glUniformMatrix2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern GLboolean glIsShader (GLuint shader);
extern GLboolean glIsProgram (GLuint program);
extern void glGetShaderiv (GLuint shader, GLenum pname, GLint *params);
extern void glGetProgramiv (GLuint program, GLenum pname, GLint *params);
extern void glGetAttachedShaders (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
extern void glGetShaderInfoLog (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
extern void glGetProgramInfoLog (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
extern GLint glGetUniformLocation (GLuint program, const GLchar *name);
extern void glGetActiveUniform (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
extern void glGetUniformfv (GLuint program, GLint location, GLfloat *params);
extern void glGetUniformiv (GLuint program, GLint location, GLint *params);
extern void glGetShaderSource (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
extern void glBindAttribLocation (GLuint program, GLuint index, const GLchar *name);
extern void glGetActiveAttrib (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
extern GLint glGetAttribLocation (GLuint program, const GLchar *name);
extern void glStencilFuncSeparate (GLenum face, GLenum func, GLint ref, GLuint mask);
extern void glStencilOpSeparate (GLenum face, GLenum fail, GLenum zfail, GLenum zpass);
extern void glStencilMaskSeparate (GLenum face, GLuint mask);

extern void glUniformMatrix2x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix2x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);


#endif /* GL_GLEXT_FUNCTION_POINTERS */

#ifdef __cplusplus
}
#endif

#endif /* __gl_h_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      gl3.h                                                                                               0100644 0001750 0001750 00000507472 12567471556 031637  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers                                                                      #ifndef __gl3_h_
#define __gl3_h_

/* Allow multiple GL version headers to be included when we're working
   with modules. */
#ifdef __has_feature
#  if __has_feature(modules)
#    ifndef GL_DO_NOT_WARN_IF_MULTI_GL_VERSION_HEADERS_INCLUDED
#      define GL_DO_NOT_WARN_IF_MULTI_GL_VERSION_HEADERS_INCLUDED 1
#    endif
#  endif
#endif

#if defined __gl_h_ && !(defined GL_DO_NOT_WARN_IF_MULTI_GL_VERSION_HEADERS_INCLUDED)
#warning gl.h and gl3.h are both included.  Compiler will not invoke errors if using removed OpenGL functionality.
#endif

#ifdef _CGLMACRO_H
#  ifndef __has_feature
#    define __has_feature(X) 0
#  endif
#  if !__has_feature(modules)
#    error Can not include both gl3.h and CGLMacro.h simultaneously
#  endif
#endif

/*
** Copyright (c) 2007-2012 The Khronos Group Inc.
** 
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
** 
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
** 
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

/* This is a draft release of gl3.h, a header for use with OpenGL 3.1, and
 * 3.2 and later core profile implementations. The current version is
 * available at http://www.opengl.org/registry/ . Please don't package
 * gl3.h for release with other software until it's out of draft status.
 * The structure of the file may change significantly, and the details
 * will probably change slightly as we make sure exactly the right set
 * of interfaces is included.
 *
 * gl3.h last updated on $Date: 2012-01-26 02:57:23 -0800 (Thu, 26 Jan 2012) $
 *
 * RELEASE NOTES - 2012/01/26
 *
 * gl3.h should be placed under a directory 'GL3' and included as
 * '<GL3/gl3.h>'.
 *
 * gl3.h is supposed to only include APIs in a OpenGL 3.1 (without
 * GL_ARB_compatibility) or OpenGL 3.2 or later core profile
 * implementation, as well as interfaces for newer ARB extensions which
 * can be supported by the core profile. It does not, and never will
 * include functionality removed from the core profile, such as
 * fixed-function vertex and fragment processing.
 *
 * Implementations of OpenGL 3.1 supporting the optional
 * GL_ARB_compatibility extension continue to provide that functionality,
 * as do implementations of the OpenGL 3.2+ compatibility profiles, and
 * source code requiring it should use the traditional <GL/gl.h> and
 * <GL/glext.h> headers instead of <GL3/gl3.h>.
 *
 * It is not possible to #include both <GL3/gl3.h> and either of
 * <GL/gl.h> or <GL/glext.h> in the same source file.
 *
 * We welcome feedback on gl3.h. Please register for the Khronos Bugzilla
 * (www.khronos.org/bugzilla) and file issues there under product
 * "OpenGL", category "Registry". Feedback on the opengl.org forums
 * may not be responded to in a timely fashion.
 */

/* Function declaration macros - to move into glplatform.h */

#if defined(_WIN32) && !defined(APIENTRY) && !defined(__CYGWIN__) && !defined(__SCITECH_SNAP__)
#define WIN32_LEAN_AND_MEAN 1
#include <windows.h>
#endif


#if defined(__APPLE__)
#define GL3_PROTOTYPES
#endif

#ifndef APIENTRY
#define APIENTRY
#endif
#ifndef APIENTRYP
#define APIENTRYP APIENTRY *
#endif
#ifndef GLAPI
#define GLAPI extern
#endif

/* Base GL types */
#include <OpenGL/gltypes.h>

#ifdef __cplusplus
extern "C" {
#endif

/*************************************************************/

#ifndef GL_VERSION_1_1
/* AttribMask */
#define GL_DEPTH_BUFFER_BIT               0x00000100
#define GL_STENCIL_BUFFER_BIT             0x00000400
#define GL_COLOR_BUFFER_BIT               0x00004000
/* Boolean */
#define GL_FALSE                          0
#define GL_TRUE                           1
/* BeginMode */
#define GL_POINTS                         0x0000
#define GL_LINES                          0x0001
#define GL_LINE_LOOP                      0x0002
#define GL_LINE_STRIP                     0x0003
#define GL_TRIANGLES                      0x0004
#define GL_TRIANGLE_STRIP                 0x0005
#define GL_TRIANGLE_FAN                   0x0006
/* AlphaFunction */
#define GL_NEVER                          0x0200
#define GL_LESS                           0x0201
#define GL_EQUAL                          0x0202
#define GL_LEQUAL                         0x0203
#define GL_GREATER                        0x0204
#define GL_NOTEQUAL                       0x0205
#define GL_GEQUAL                         0x0206
#define GL_ALWAYS                         0x0207
/* BlendingFactorDest */
#define GL_ZERO                           0
#define GL_ONE                            1
#define GL_SRC_COLOR                      0x0300
#define GL_ONE_MINUS_SRC_COLOR            0x0301
#define GL_SRC_ALPHA                      0x0302
#define GL_ONE_MINUS_SRC_ALPHA            0x0303
#define GL_DST_ALPHA                      0x0304
#define GL_ONE_MINUS_DST_ALPHA            0x0305
/* BlendingFactorSrc */
#define GL_DST_COLOR                      0x0306
#define GL_ONE_MINUS_DST_COLOR            0x0307
#define GL_SRC_ALPHA_SATURATE             0x0308
/* DrawBufferMode */
#define GL_NONE                           0
#define GL_FRONT_LEFT                     0x0400
#define GL_FRONT_RIGHT                    0x0401
#define GL_BACK_LEFT                      0x0402
#define GL_BACK_RIGHT                     0x0403
#define GL_FRONT                          0x0404
#define GL_BACK                           0x0405
#define GL_LEFT                           0x0406
#define GL_RIGHT                          0x0407
#define GL_FRONT_AND_BACK                 0x0408
/* ErrorCode */
#define GL_NO_ERROR                       0
#define GL_INVALID_ENUM                   0x0500
#define GL_INVALID_VALUE                  0x0501
#define GL_INVALID_OPERATION              0x0502
#define GL_OUT_OF_MEMORY                  0x0505
/* FrontFaceDirection */
#define GL_CW                             0x0900
#define GL_CCW                            0x0901
/* GetPName */
#define GL_POINT_SIZE                     0x0B11
#define GL_POINT_SIZE_RANGE               0x0B12
#define GL_POINT_SIZE_GRANULARITY         0x0B13
#define GL_LINE_SMOOTH                    0x0B20
#define GL_LINE_WIDTH                     0x0B21
#define GL_LINE_WIDTH_RANGE               0x0B22
#define GL_LINE_WIDTH_GRANULARITY         0x0B23
#define GL_POLYGON_MODE                   0x0B40
#define GL_POLYGON_SMOOTH                 0x0B41
#define GL_CULL_FACE                      0x0B44
#define GL_CULL_FACE_MODE                 0x0B45
#define GL_FRONT_FACE                     0x0B46
#define GL_DEPTH_RANGE                    0x0B70
#define GL_DEPTH_TEST                     0x0B71
#define GL_DEPTH_WRITEMASK                0x0B72
#define GL_DEPTH_CLEAR_VALUE              0x0B73
#define GL_DEPTH_FUNC                     0x0B74
#define GL_STENCIL_TEST                   0x0B90
#define GL_STENCIL_CLEAR_VALUE            0x0B91
#define GL_STENCIL_FUNC                   0x0B92
#define GL_STENCIL_VALUE_MASK             0x0B93
#define GL_STENCIL_FAIL                   0x0B94
#define GL_STENCIL_PASS_DEPTH_FAIL        0x0B95
#define GL_STENCIL_PASS_DEPTH_PASS        0x0B96
#define GL_STENCIL_REF                    0x0B97
#define GL_STENCIL_WRITEMASK              0x0B98
#define GL_VIEWPORT                       0x0BA2
#define GL_DITHER                         0x0BD0
#define GL_BLEND_DST                      0x0BE0
#define GL_BLEND_SRC                      0x0BE1
#define GL_BLEND                          0x0BE2
#define GL_LOGIC_OP_MODE                  0x0BF0
#define GL_COLOR_LOGIC_OP                 0x0BF2
#define GL_DRAW_BUFFER                    0x0C01
#define GL_READ_BUFFER                    0x0C02
#define GL_SCISSOR_BOX                    0x0C10
#define GL_SCISSOR_TEST                   0x0C11
#define GL_COLOR_CLEAR_VALUE              0x0C22
#define GL_COLOR_WRITEMASK                0x0C23
#define GL_DOUBLEBUFFER                   0x0C32
#define GL_STEREO                         0x0C33
#define GL_LINE_SMOOTH_HINT               0x0C52
#define GL_POLYGON_SMOOTH_HINT            0x0C53
#define GL_UNPACK_SWAP_BYTES              0x0CF0
#define GL_UNPACK_LSB_FIRST               0x0CF1
#define GL_UNPACK_ROW_LENGTH              0x0CF2
#define GL_UNPACK_SKIP_ROWS               0x0CF3
#define GL_UNPACK_SKIP_PIXELS             0x0CF4
#define GL_UNPACK_ALIGNMENT               0x0CF5
#define GL_PACK_SWAP_BYTES                0x0D00
#define GL_PACK_LSB_FIRST                 0x0D01
#define GL_PACK_ROW_LENGTH                0x0D02
#define GL_PACK_SKIP_ROWS                 0x0D03
#define GL_PACK_SKIP_PIXELS               0x0D04
#define GL_PACK_ALIGNMENT                 0x0D05
#define GL_MAX_TEXTURE_SIZE               0x0D33
#define GL_MAX_VIEWPORT_DIMS              0x0D3A
#define GL_SUBPIXEL_BITS                  0x0D50
#define GL_TEXTURE_1D                     0x0DE0
#define GL_TEXTURE_2D                     0x0DE1
#define GL_POLYGON_OFFSET_UNITS           0x2A00
#define GL_POLYGON_OFFSET_POINT           0x2A01
#define GL_POLYGON_OFFSET_LINE            0x2A02
#define GL_POLYGON_OFFSET_FILL            0x8037
#define GL_POLYGON_OFFSET_FACTOR          0x8038
#define GL_TEXTURE_BINDING_1D             0x8068
#define GL_TEXTURE_BINDING_2D             0x8069
/* GetTextureParameter */
#define GL_TEXTURE_WIDTH                  0x1000
#define GL_TEXTURE_HEIGHT                 0x1001
#define GL_TEXTURE_INTERNAL_FORMAT        0x1003
#define GL_TEXTURE_BORDER_COLOR           0x1004
#define GL_TEXTURE_RED_SIZE               0x805C
#define GL_TEXTURE_GREEN_SIZE             0x805D
#define GL_TEXTURE_BLUE_SIZE              0x805E
#define GL_TEXTURE_ALPHA_SIZE             0x805F
/* HintMode */
#define GL_DONT_CARE                      0x1100
#define GL_FASTEST                        0x1101
#define GL_NICEST                         0x1102
/* DataType */
#define GL_BYTE                           0x1400
#define GL_UNSIGNED_BYTE                  0x1401
#define GL_SHORT                          0x1402
#define GL_UNSIGNED_SHORT                 0x1403
#define GL_INT                            0x1404
#define GL_UNSIGNED_INT                   0x1405
#define GL_FLOAT                          0x1406
#define GL_DOUBLE                         0x140A
/* LogicOp */
#define GL_CLEAR                          0x1500
#define GL_AND                            0x1501
#define GL_AND_REVERSE                    0x1502
#define GL_COPY                           0x1503
#define GL_AND_INVERTED                   0x1504
#define GL_NOOP                           0x1505
#define GL_XOR                            0x1506
#define GL_OR                             0x1507
#define GL_NOR                            0x1508
#define GL_EQUIV                          0x1509
#define GL_INVERT                         0x150A
#define GL_OR_REVERSE                     0x150B
#define GL_COPY_INVERTED                  0x150C
#define GL_OR_INVERTED                    0x150D
#define GL_NAND                           0x150E
#define GL_SET                            0x150F
/* MatrixMode (for gl3.h, FBO attachment type) */
#define GL_TEXTURE                        0x1702
/* PixelCopyType */
#define GL_COLOR                          0x1800
#define GL_DEPTH                          0x1801
#define GL_STENCIL                        0x1802
/* PixelFormat */
#define GL_STENCIL_INDEX                  0x1901
#define GL_DEPTH_COMPONENT                0x1902
#define GL_RED                            0x1903
#define GL_GREEN                          0x1904
#define GL_BLUE                           0x1905
#define GL_ALPHA                          0x1906
#define GL_RGB                            0x1907
#define GL_RGBA                           0x1908
/* PolygonMode */
#define GL_POINT                          0x1B00
#define GL_LINE                           0x1B01
#define GL_FILL                           0x1B02
/* StencilOp */
#define GL_KEEP                           0x1E00
#define GL_REPLACE                        0x1E01
#define GL_INCR                           0x1E02
#define GL_DECR                           0x1E03
/* StringName */
#define GL_VENDOR                         0x1F00
#define GL_RENDERER                       0x1F01
#define GL_VERSION                        0x1F02
#define GL_EXTENSIONS                     0x1F03
/* TextureMagFilter */
#define GL_NEAREST                        0x2600
#define GL_LINEAR                         0x2601
/* TextureMinFilter */
#define GL_NEAREST_MIPMAP_NEAREST         0x2700
#define GL_LINEAR_MIPMAP_NEAREST          0x2701
#define GL_NEAREST_MIPMAP_LINEAR          0x2702
#define GL_LINEAR_MIPMAP_LINEAR           0x2703
/* TextureParameterName */
#define GL_TEXTURE_MAG_FILTER             0x2800
#define GL_TEXTURE_MIN_FILTER             0x2801
#define GL_TEXTURE_WRAP_S                 0x2802
#define GL_TEXTURE_WRAP_T                 0x2803
/* TextureTarget */
#define GL_PROXY_TEXTURE_1D               0x8063
#define GL_PROXY_TEXTURE_2D               0x8064
/* TextureWrapMode */
#define GL_REPEAT                         0x2901
/* PixelInternalFormat */
#define GL_R3_G3_B2                       0x2A10
#define GL_RGB4                           0x804F
#define GL_RGB5                           0x8050
#define GL_RGB8                           0x8051
#define GL_RGB10                          0x8052
#define GL_RGB12                          0x8053
#define GL_RGB16                          0x8054
#define GL_RGBA2                          0x8055
#define GL_RGBA4                          0x8056
#define GL_RGB5_A1                        0x8057
#define GL_RGBA8                          0x8058
#define GL_RGB10_A2                       0x8059
#define GL_RGBA12                         0x805A
#define GL_RGBA16                         0x805B
#endif

#ifndef GL_VERSION_1_2
#define GL_UNSIGNED_BYTE_3_3_2            0x8032
#define GL_UNSIGNED_SHORT_4_4_4_4         0x8033
#define GL_UNSIGNED_SHORT_5_5_5_1         0x8034
#define GL_UNSIGNED_INT_8_8_8_8           0x8035
#define GL_UNSIGNED_INT_10_10_10_2        0x8036
#define GL_TEXTURE_BINDING_3D             0x806A
#define GL_PACK_SKIP_IMAGES               0x806B
#define GL_PACK_IMAGE_HEIGHT              0x806C
#define GL_UNPACK_SKIP_IMAGES             0x806D
#define GL_UNPACK_IMAGE_HEIGHT            0x806E
#define GL_TEXTURE_3D                     0x806F
#define GL_PROXY_TEXTURE_3D               0x8070
#define GL_TEXTURE_DEPTH                  0x8071
#define GL_TEXTURE_WRAP_R                 0x8072
#define GL_MAX_3D_TEXTURE_SIZE            0x8073
#define GL_UNSIGNED_BYTE_2_3_3_REV        0x8362
#define GL_UNSIGNED_SHORT_5_6_5           0x8363
#define GL_UNSIGNED_SHORT_5_6_5_REV       0x8364
#define GL_UNSIGNED_SHORT_4_4_4_4_REV     0x8365
#define GL_UNSIGNED_SHORT_1_5_5_5_REV     0x8366
#define GL_UNSIGNED_INT_8_8_8_8_REV       0x8367
#define GL_UNSIGNED_INT_2_10_10_10_REV    0x8368
#define GL_BGR                            0x80E0
#define GL_BGRA                           0x80E1
#define GL_MAX_ELEMENTS_VERTICES          0x80E8
#define GL_MAX_ELEMENTS_INDICES           0x80E9
#define GL_CLAMP_TO_EDGE                  0x812F
#define GL_TEXTURE_MIN_LOD                0x813A
#define GL_TEXTURE_MAX_LOD                0x813B
#define GL_TEXTURE_BASE_LEVEL             0x813C
#define GL_TEXTURE_MAX_LEVEL              0x813D
#define GL_SMOOTH_POINT_SIZE_RANGE        0x0B12
#define GL_SMOOTH_POINT_SIZE_GRANULARITY  0x0B13
#define GL_SMOOTH_LINE_WIDTH_RANGE        0x0B22
#define GL_SMOOTH_LINE_WIDTH_GRANULARITY  0x0B23
#define GL_ALIASED_LINE_WIDTH_RANGE       0x846E
#endif

#ifndef GL_ARB_imaging
#define GL_CONSTANT_COLOR                 0x8001
#define GL_ONE_MINUS_CONSTANT_COLOR       0x8002
#define GL_CONSTANT_ALPHA                 0x8003
#define GL_ONE_MINUS_CONSTANT_ALPHA       0x8004
#define GL_BLEND_COLOR                    0x8005
#define GL_FUNC_ADD                       0x8006
#define GL_MIN                            0x8007
#define GL_MAX                            0x8008
#define GL_BLEND_EQUATION                 0x8009
#define GL_FUNC_SUBTRACT                  0x800A
#define GL_FUNC_REVERSE_SUBTRACT          0x800B
#endif

#ifndef GL_VERSION_1_3
#define GL_TEXTURE0                       0x84C0
#define GL_TEXTURE1                       0x84C1
#define GL_TEXTURE2                       0x84C2
#define GL_TEXTURE3                       0x84C3
#define GL_TEXTURE4                       0x84C4
#define GL_TEXTURE5                       0x84C5
#define GL_TEXTURE6                       0x84C6
#define GL_TEXTURE7                       0x84C7
#define GL_TEXTURE8                       0x84C8
#define GL_TEXTURE9                       0x84C9
#define GL_TEXTURE10                      0x84CA
#define GL_TEXTURE11                      0x84CB
#define GL_TEXTURE12                      0x84CC
#define GL_TEXTURE13                      0x84CD
#define GL_TEXTURE14                      0x84CE
#define GL_TEXTURE15                      0x84CF
#define GL_TEXTURE16                      0x84D0
#define GL_TEXTURE17                      0x84D1
#define GL_TEXTURE18                      0x84D2
#define GL_TEXTURE19                      0x84D3
#define GL_TEXTURE20                      0x84D4
#define GL_TEXTURE21                      0x84D5
#define GL_TEXTURE22                      0x84D6
#define GL_TEXTURE23                      0x84D7
#define GL_TEXTURE24                      0x84D8
#define GL_TEXTURE25                      0x84D9
#define GL_TEXTURE26                      0x84DA
#define GL_TEXTURE27                      0x84DB
#define GL_TEXTURE28                      0x84DC
#define GL_TEXTURE29                      0x84DD
#define GL_TEXTURE30                      0x84DE
#define GL_TEXTURE31                      0x84DF
#define GL_ACTIVE_TEXTURE                 0x84E0
#define GL_MULTISAMPLE                    0x809D
#define GL_SAMPLE_ALPHA_TO_COVERAGE       0x809E
#define GL_SAMPLE_ALPHA_TO_ONE            0x809F
#define GL_SAMPLE_COVERAGE                0x80A0
#define GL_SAMPLE_BUFFERS                 0x80A8
#define GL_SAMPLES                        0x80A9
#define GL_SAMPLE_COVERAGE_VALUE          0x80AA
#define GL_SAMPLE_COVERAGE_INVERT         0x80AB
#define GL_TEXTURE_CUBE_MAP               0x8513
#define GL_TEXTURE_BINDING_CUBE_MAP       0x8514
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X    0x8515
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X    0x8516
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y    0x8517
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y    0x8518
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z    0x8519
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z    0x851A
#define GL_PROXY_TEXTURE_CUBE_MAP         0x851B
#define GL_MAX_CUBE_MAP_TEXTURE_SIZE      0x851C
#define GL_COMPRESSED_RGB                 0x84ED
#define GL_COMPRESSED_RGBA                0x84EE
#define GL_TEXTURE_COMPRESSION_HINT       0x84EF
#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE  0x86A0
#define GL_TEXTURE_COMPRESSED             0x86A1
#define GL_NUM_COMPRESSED_TEXTURE_FORMATS 0x86A2
#define GL_COMPRESSED_TEXTURE_FORMATS     0x86A3
#define GL_CLAMP_TO_BORDER                0x812D
#endif

#ifndef GL_VERSION_1_4
#define GL_BLEND_DST_RGB                  0x80C8
#define GL_BLEND_SRC_RGB                  0x80C9
#define GL_BLEND_DST_ALPHA                0x80CA
#define GL_BLEND_SRC_ALPHA                0x80CB
#define GL_POINT_FADE_THRESHOLD_SIZE      0x8128
#define GL_DEPTH_COMPONENT16              0x81A5
#define GL_DEPTH_COMPONENT24              0x81A6
#define GL_DEPTH_COMPONENT32              0x81A7
#define GL_MIRRORED_REPEAT                0x8370
#define GL_MAX_TEXTURE_LOD_BIAS           0x84FD
#define GL_TEXTURE_LOD_BIAS               0x8501
#define GL_INCR_WRAP                      0x8507
#define GL_DECR_WRAP                      0x8508
#define GL_TEXTURE_DEPTH_SIZE             0x884A
#define GL_TEXTURE_COMPARE_MODE           0x884C
#define GL_TEXTURE_COMPARE_FUNC           0x884D
#endif

#ifndef GL_VERSION_1_5
#define GL_BUFFER_SIZE                    0x8764
#define GL_BUFFER_USAGE                   0x8765
#define GL_QUERY_COUNTER_BITS             0x8864
#define GL_CURRENT_QUERY                  0x8865
#define GL_QUERY_RESULT                   0x8866
#define GL_QUERY_RESULT_AVAILABLE         0x8867
#define GL_ARRAY_BUFFER                   0x8892
#define GL_ELEMENT_ARRAY_BUFFER           0x8893
#define GL_ARRAY_BUFFER_BINDING           0x8894
#define GL_ELEMENT_ARRAY_BUFFER_BINDING   0x8895
#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING 0x889F
#define GL_READ_ONLY                      0x88B8
#define GL_WRITE_ONLY                     0x88B9
#define GL_READ_WRITE                     0x88BA
#define GL_BUFFER_ACCESS                  0x88BB
#define GL_BUFFER_MAPPED                  0x88BC
#define GL_BUFFER_MAP_POINTER             0x88BD
#define GL_STREAM_DRAW                    0x88E0
#define GL_STREAM_READ                    0x88E1
#define GL_STREAM_COPY                    0x88E2
#define GL_STATIC_DRAW                    0x88E4
#define GL_STATIC_READ                    0x88E5
#define GL_STATIC_COPY                    0x88E6
#define GL_DYNAMIC_DRAW                   0x88E8
#define GL_DYNAMIC_READ                   0x88E9
#define GL_DYNAMIC_COPY                   0x88EA
#define GL_SAMPLES_PASSED                 0x8914
#endif

#ifndef GL_VERSION_2_0
#define GL_BLEND_EQUATION_RGB             0x8009
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED    0x8622
#define GL_VERTEX_ATTRIB_ARRAY_SIZE       0x8623
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE     0x8624
#define GL_VERTEX_ATTRIB_ARRAY_TYPE       0x8625
#define GL_CURRENT_VERTEX_ATTRIB          0x8626
#define GL_VERTEX_PROGRAM_POINT_SIZE      0x8642
#define GL_VERTEX_ATTRIB_ARRAY_POINTER    0x8645
#define GL_STENCIL_BACK_FUNC              0x8800
#define GL_STENCIL_BACK_FAIL              0x8801
#define GL_STENCIL_BACK_PASS_DEPTH_FAIL   0x8802
#define GL_STENCIL_BACK_PASS_DEPTH_PASS   0x8803
#define GL_MAX_DRAW_BUFFERS               0x8824
#define GL_DRAW_BUFFER0                   0x8825
#define GL_DRAW_BUFFER1                   0x8826
#define GL_DRAW_BUFFER2                   0x8827
#define GL_DRAW_BUFFER3                   0x8828
#define GL_DRAW_BUFFER4                   0x8829
#define GL_DRAW_BUFFER5                   0x882A
#define GL_DRAW_BUFFER6                   0x882B
#define GL_DRAW_BUFFER7                   0x882C
#define GL_DRAW_BUFFER8                   0x882D
#define GL_DRAW_BUFFER9                   0x882E
#define GL_DRAW_BUFFER10                  0x882F
#define GL_DRAW_BUFFER11                  0x8830
#define GL_DRAW_BUFFER12                  0x8831
#define GL_DRAW_BUFFER13                  0x8832
#define GL_DRAW_BUFFER14                  0x8833
#define GL_DRAW_BUFFER15                  0x8834
#define GL_BLEND_EQUATION_ALPHA           0x883D
#define GL_MAX_VERTEX_ATTRIBS             0x8869
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED 0x886A
#define GL_MAX_TEXTURE_IMAGE_UNITS        0x8872
#define GL_FRAGMENT_SHADER                0x8B30
#define GL_VERTEX_SHADER                  0x8B31
#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS 0x8B49
#define GL_MAX_VERTEX_UNIFORM_COMPONENTS  0x8B4A
#define GL_MAX_VARYING_FLOATS             0x8B4B
#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS 0x8B4C
#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS 0x8B4D
#define GL_SHADER_TYPE                    0x8B4F
#define GL_FLOAT_VEC2                     0x8B50
#define GL_FLOAT_VEC3                     0x8B51
#define GL_FLOAT_VEC4                     0x8B52
#define GL_INT_VEC2                       0x8B53
#define GL_INT_VEC3                       0x8B54
#define GL_INT_VEC4                       0x8B55
#define GL_BOOL                           0x8B56
#define GL_BOOL_VEC2                      0x8B57
#define GL_BOOL_VEC3                      0x8B58
#define GL_BOOL_VEC4                      0x8B59
#define GL_FLOAT_MAT2                     0x8B5A
#define GL_FLOAT_MAT3                     0x8B5B
#define GL_FLOAT_MAT4                     0x8B5C
#define GL_SAMPLER_1D                     0x8B5D
#define GL_SAMPLER_2D                     0x8B5E
#define GL_SAMPLER_3D                     0x8B5F
#define GL_SAMPLER_CUBE                   0x8B60
#define GL_SAMPLER_1D_SHADOW              0x8B61
#define GL_SAMPLER_2D_SHADOW              0x8B62
#define GL_DELETE_STATUS                  0x8B80
#define GL_COMPILE_STATUS                 0x8B81
#define GL_LINK_STATUS                    0x8B82
#define GL_VALIDATE_STATUS                0x8B83
#define GL_INFO_LOG_LENGTH                0x8B84
#define GL_ATTACHED_SHADERS               0x8B85
#define GL_ACTIVE_UNIFORMS                0x8B86
#define GL_ACTIVE_UNIFORM_MAX_LENGTH      0x8B87
#define GL_SHADER_SOURCE_LENGTH           0x8B88
#define GL_ACTIVE_ATTRIBUTES              0x8B89
#define GL_ACTIVE_ATTRIBUTE_MAX_LENGTH    0x8B8A
#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT 0x8B8B
#define GL_SHADING_LANGUAGE_VERSION       0x8B8C
#define GL_CURRENT_PROGRAM                0x8B8D
#define GL_POINT_SPRITE_COORD_ORIGIN      0x8CA0
#define GL_LOWER_LEFT                     0x8CA1
#define GL_UPPER_LEFT                     0x8CA2
#define GL_STENCIL_BACK_REF               0x8CA3
#define GL_STENCIL_BACK_VALUE_MASK        0x8CA4
#define GL_STENCIL_BACK_WRITEMASK         0x8CA5
#endif

#ifndef GL_VERSION_2_1
#define GL_PIXEL_PACK_BUFFER              0x88EB
#define GL_PIXEL_UNPACK_BUFFER            0x88EC
#define GL_PIXEL_PACK_BUFFER_BINDING      0x88ED
#define GL_PIXEL_UNPACK_BUFFER_BINDING    0x88EF
#define GL_FLOAT_MAT2x3                   0x8B65
#define GL_FLOAT_MAT2x4                   0x8B66
#define GL_FLOAT_MAT3x2                   0x8B67
#define GL_FLOAT_MAT3x4                   0x8B68
#define GL_FLOAT_MAT4x2                   0x8B69
#define GL_FLOAT_MAT4x3                   0x8B6A
#define GL_SRGB                           0x8C40
#define GL_SRGB8                          0x8C41
#define GL_SRGB_ALPHA                     0x8C42
#define GL_SRGB8_ALPHA8                   0x8C43
#define GL_COMPRESSED_SRGB                0x8C48
#define GL_COMPRESSED_SRGB_ALPHA          0x8C49
#endif

#ifndef GL_VERSION_3_0
#define GL_COMPARE_REF_TO_TEXTURE         0x884E
#define GL_CLIP_DISTANCE0                 0x3000
#define GL_CLIP_DISTANCE1                 0x3001
#define GL_CLIP_DISTANCE2                 0x3002
#define GL_CLIP_DISTANCE3                 0x3003
#define GL_CLIP_DISTANCE4                 0x3004
#define GL_CLIP_DISTANCE5                 0x3005
#define GL_CLIP_DISTANCE6                 0x3006
#define GL_CLIP_DISTANCE7                 0x3007
#define GL_MAX_CLIP_DISTANCES             0x0D32
#define GL_MAJOR_VERSION                  0x821B
#define GL_MINOR_VERSION                  0x821C
#define GL_NUM_EXTENSIONS                 0x821D
#define GL_CONTEXT_FLAGS                  0x821E
#define GL_COMPRESSED_RED                 0x8225
#define GL_COMPRESSED_RG                  0x8226
#define GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT 0x0001
#define GL_RGBA32F                        0x8814
#define GL_RGB32F                         0x8815
#define GL_RGBA16F                        0x881A
#define GL_RGB16F                         0x881B
#define GL_VERTEX_ATTRIB_ARRAY_INTEGER    0x88FD
#define GL_MAX_ARRAY_TEXTURE_LAYERS       0x88FF
#define GL_MIN_PROGRAM_TEXEL_OFFSET       0x8904
#define GL_MAX_PROGRAM_TEXEL_OFFSET       0x8905
#define GL_CLAMP_READ_COLOR               0x891C
#define GL_FIXED_ONLY                     0x891D
#define GL_MAX_VARYING_COMPONENTS         0x8B4B
#define GL_TEXTURE_1D_ARRAY               0x8C18
#define GL_PROXY_TEXTURE_1D_ARRAY         0x8C19
#define GL_TEXTURE_2D_ARRAY               0x8C1A
#define GL_PROXY_TEXTURE_2D_ARRAY         0x8C1B
#define GL_TEXTURE_BINDING_1D_ARRAY       0x8C1C
#define GL_TEXTURE_BINDING_2D_ARRAY       0x8C1D
#define GL_R11F_G11F_B10F                 0x8C3A
#define GL_UNSIGNED_INT_10F_11F_11F_REV   0x8C3B
#define GL_RGB9_E5                        0x8C3D
#define GL_UNSIGNED_INT_5_9_9_9_REV       0x8C3E
#define GL_TEXTURE_SHARED_SIZE            0x8C3F
#define GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH 0x8C76
#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE 0x8C7F
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS 0x8C80
#define GL_TRANSFORM_FEEDBACK_VARYINGS    0x8C83
#define GL_TRANSFORM_FEEDBACK_BUFFER_START 0x8C84
#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE 0x8C85
#define GL_PRIMITIVES_GENERATED           0x8C87
#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN 0x8C88
#define GL_RASTERIZER_DISCARD             0x8C89
#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS 0x8C8A
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS 0x8C8B
#define GL_INTERLEAVED_ATTRIBS            0x8C8C
#define GL_SEPARATE_ATTRIBS               0x8C8D
#define GL_TRANSFORM_FEEDBACK_BUFFER      0x8C8E
#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING 0x8C8F
#define GL_RGBA32UI                       0x8D70
#define GL_RGB32UI                        0x8D71
#define GL_RGBA16UI                       0x8D76
#define GL_RGB16UI                        0x8D77
#define GL_RGBA8UI                        0x8D7C
#define GL_RGB8UI                         0x8D7D
#define GL_RGBA32I                        0x8D82
#define GL_RGB32I                         0x8D83
#define GL_RGBA16I                        0x8D88
#define GL_RGB16I                         0x8D89
#define GL_RGBA8I                         0x8D8E
#define GL_RGB8I                          0x8D8F
#define GL_RED_INTEGER                    0x8D94
#define GL_GREEN_INTEGER                  0x8D95
#define GL_BLUE_INTEGER                   0x8D96
#define GL_RGB_INTEGER                    0x8D98
#define GL_RGBA_INTEGER                   0x8D99
#define GL_BGR_INTEGER                    0x8D9A
#define GL_BGRA_INTEGER                   0x8D9B
#define GL_SAMPLER_1D_ARRAY               0x8DC0
#define GL_SAMPLER_2D_ARRAY               0x8DC1
#define GL_SAMPLER_1D_ARRAY_SHADOW        0x8DC3
#define GL_SAMPLER_2D_ARRAY_SHADOW        0x8DC4
#define GL_SAMPLER_CUBE_SHADOW            0x8DC5
#define GL_UNSIGNED_INT_VEC2              0x8DC6
#define GL_UNSIGNED_INT_VEC3              0x8DC7
#define GL_UNSIGNED_INT_VEC4              0x8DC8
#define GL_INT_SAMPLER_1D                 0x8DC9
#define GL_INT_SAMPLER_2D                 0x8DCA
#define GL_INT_SAMPLER_3D                 0x8DCB
#define GL_INT_SAMPLER_CUBE               0x8DCC
#define GL_INT_SAMPLER_1D_ARRAY           0x8DCE
#define GL_INT_SAMPLER_2D_ARRAY           0x8DCF
#define GL_UNSIGNED_INT_SAMPLER_1D        0x8DD1
#define GL_UNSIGNED_INT_SAMPLER_2D        0x8DD2
#define GL_UNSIGNED_INT_SAMPLER_3D        0x8DD3
#define GL_UNSIGNED_INT_SAMPLER_CUBE      0x8DD4
#define GL_UNSIGNED_INT_SAMPLER_1D_ARRAY  0x8DD6
#define GL_UNSIGNED_INT_SAMPLER_2D_ARRAY  0x8DD7
#define GL_QUERY_WAIT                     0x8E13
#define GL_QUERY_NO_WAIT                  0x8E14
#define GL_QUERY_BY_REGION_WAIT           0x8E15
#define GL_QUERY_BY_REGION_NO_WAIT        0x8E16
#define GL_BUFFER_ACCESS_FLAGS            0x911F
#define GL_BUFFER_MAP_LENGTH              0x9120
#define GL_BUFFER_MAP_OFFSET              0x9121
/* Reuse tokens from ARB_depth_buffer_float */
/* reuse GL_DEPTH_COMPONENT32F */
/* reuse GL_DEPTH32F_STENCIL8 */
/* reuse GL_FLOAT_32_UNSIGNED_INT_24_8_REV */
/* Reuse tokens from ARB_framebuffer_object */
/* reuse GL_INVALID_FRAMEBUFFER_OPERATION */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE */
/* reuse GL_FRAMEBUFFER_DEFAULT */
/* reuse GL_FRAMEBUFFER_UNDEFINED */
/* reuse GL_DEPTH_STENCIL_ATTACHMENT */
/* reuse GL_MAX_RENDERBUFFER_SIZE */
/* reuse GL_DEPTH_STENCIL */
/* reuse GL_UNSIGNED_INT_24_8 */
/* reuse GL_DEPTH24_STENCIL8 */
/* reuse GL_TEXTURE_STENCIL_SIZE */
/* reuse GL_TEXTURE_RED_TYPE */
/* reuse GL_TEXTURE_GREEN_TYPE */
/* reuse GL_TEXTURE_BLUE_TYPE */
/* reuse GL_TEXTURE_ALPHA_TYPE */
/* reuse GL_TEXTURE_DEPTH_TYPE */
/* reuse GL_UNSIGNED_NORMALIZED */
/* reuse GL_FRAMEBUFFER_BINDING */
/* reuse GL_DRAW_FRAMEBUFFER_BINDING */
/* reuse GL_RENDERBUFFER_BINDING */
/* reuse GL_READ_FRAMEBUFFER */
/* reuse GL_DRAW_FRAMEBUFFER */
/* reuse GL_READ_FRAMEBUFFER_BINDING */
/* reuse GL_RENDERBUFFER_SAMPLES */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER */
/* reuse GL_FRAMEBUFFER_COMPLETE */
/* reuse GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT */
/* reuse GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT */
/* reuse GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER */
/* reuse GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER */
/* reuse GL_FRAMEBUFFER_UNSUPPORTED */
/* reuse GL_MAX_COLOR_ATTACHMENTS */
/* reuse GL_COLOR_ATTACHMENT0 */
/* reuse GL_COLOR_ATTACHMENT1 */
/* reuse GL_COLOR_ATTACHMENT2 */
/* reuse GL_COLOR_ATTACHMENT3 */
/* reuse GL_COLOR_ATTACHMENT4 */
/* reuse GL_COLOR_ATTACHMENT5 */
/* reuse GL_COLOR_ATTACHMENT6 */
/* reuse GL_COLOR_ATTACHMENT7 */
/* reuse GL_COLOR_ATTACHMENT8 */
/* reuse GL_COLOR_ATTACHMENT9 */
/* reuse GL_COLOR_ATTACHMENT10 */
/* reuse GL_COLOR_ATTACHMENT11 */
/* reuse GL_COLOR_ATTACHMENT12 */
/* reuse GL_COLOR_ATTACHMENT13 */
/* reuse GL_COLOR_ATTACHMENT14 */
/* reuse GL_COLOR_ATTACHMENT15 */
/* reuse GL_DEPTH_ATTACHMENT */
/* reuse GL_STENCIL_ATTACHMENT */
/* reuse GL_FRAMEBUFFER */
/* reuse GL_RENDERBUFFER */
/* reuse GL_RENDERBUFFER_WIDTH */
/* reuse GL_RENDERBUFFER_HEIGHT */
/* reuse GL_RENDERBUFFER_INTERNAL_FORMAT */
/* reuse GL_STENCIL_INDEX1 */
/* reuse GL_STENCIL_INDEX4 */
/* reuse GL_STENCIL_INDEX8 */
/* reuse GL_STENCIL_INDEX16 */
/* reuse GL_RENDERBUFFER_RED_SIZE */
/* reuse GL_RENDERBUFFER_GREEN_SIZE */
/* reuse GL_RENDERBUFFER_BLUE_SIZE */
/* reuse GL_RENDERBUFFER_ALPHA_SIZE */
/* reuse GL_RENDERBUFFER_DEPTH_SIZE */
/* reuse GL_RENDERBUFFER_STENCIL_SIZE */
/* reuse GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE */
/* reuse GL_MAX_SAMPLES */
/* Reuse tokens from ARB_framebuffer_sRGB */
/* reuse GL_FRAMEBUFFER_SRGB */
/* Reuse tokens from ARB_half_float_vertex */
/* reuse GL_HALF_FLOAT */
/* Reuse tokens from ARB_map_buffer_range */
/* reuse GL_MAP_READ_BIT */
/* reuse GL_MAP_WRITE_BIT */
/* reuse GL_MAP_INVALIDATE_RANGE_BIT */
/* reuse GL_MAP_INVALIDATE_BUFFER_BIT */
/* reuse GL_MAP_FLUSH_EXPLICIT_BIT */
/* reuse GL_MAP_UNSYNCHRONIZED_BIT */
/* Reuse tokens from ARB_texture_compression_rgtc */
/* reuse GL_COMPRESSED_RED_RGTC1 */
/* reuse GL_COMPRESSED_SIGNED_RED_RGTC1 */
/* reuse GL_COMPRESSED_RG_RGTC2 */
/* reuse GL_COMPRESSED_SIGNED_RG_RGTC2 */
/* Reuse tokens from ARB_texture_rg */
/* reuse GL_RG */
/* reuse GL_RG_INTEGER */
/* reuse GL_R8 */
/* reuse GL_R16 */
/* reuse GL_RG8 */
/* reuse GL_RG16 */
/* reuse GL_R16F */
/* reuse GL_R32F */
/* reuse GL_RG16F */
/* reuse GL_RG32F */
/* reuse GL_R8I */
/* reuse GL_R8UI */
/* reuse GL_R16I */
/* reuse GL_R16UI */
/* reuse GL_R32I */
/* reuse GL_R32UI */
/* reuse GL_RG8I */
/* reuse GL_RG8UI */
/* reuse GL_RG16I */
/* reuse GL_RG16UI */
/* reuse GL_RG32I */
/* reuse GL_RG32UI */
/* Reuse tokens from ARB_vertex_array_object */
/* reuse GL_VERTEX_ARRAY_BINDING */
#endif

#ifndef GL_VERSION_3_1
#define GL_SAMPLER_2D_RECT                0x8B63
#define GL_SAMPLER_2D_RECT_SHADOW         0x8B64
#define GL_SAMPLER_BUFFER                 0x8DC2
#define GL_INT_SAMPLER_2D_RECT            0x8DCD
#define GL_INT_SAMPLER_BUFFER             0x8DD0
#define GL_UNSIGNED_INT_SAMPLER_2D_RECT   0x8DD5
#define GL_UNSIGNED_INT_SAMPLER_BUFFER    0x8DD8
#define GL_TEXTURE_BUFFER                 0x8C2A
#define GL_MAX_TEXTURE_BUFFER_SIZE        0x8C2B
#define GL_TEXTURE_BINDING_BUFFER         0x8C2C
#define GL_TEXTURE_BUFFER_DATA_STORE_BINDING 0x8C2D
#define GL_TEXTURE_RECTANGLE              0x84F5
#define GL_TEXTURE_BINDING_RECTANGLE      0x84F6
#define GL_PROXY_TEXTURE_RECTANGLE        0x84F7
#define GL_MAX_RECTANGLE_TEXTURE_SIZE     0x84F8
#define GL_R8_SNORM                       0x8F94
#define GL_RG8_SNORM                      0x8F95
#define GL_RGB8_SNORM                     0x8F96
#define GL_RGBA8_SNORM                    0x8F97
#define GL_R16_SNORM                      0x8F98
#define GL_RG16_SNORM                     0x8F99
#define GL_RGB16_SNORM                    0x8F9A
#define GL_RGBA16_SNORM                   0x8F9B
#define GL_SIGNED_NORMALIZED              0x8F9C
#define GL_PRIMITIVE_RESTART              0x8F9D
#define GL_PRIMITIVE_RESTART_INDEX        0x8F9E
/* Reuse tokens from ARB_copy_buffer */
/* reuse GL_COPY_READ_BUFFER */
/* reuse GL_COPY_WRITE_BUFFER */
/* Reuse tokens from ARB_draw_instanced (none) */
/* Reuse tokens from ARB_uniform_buffer_object */
/* reuse GL_UNIFORM_BUFFER */
/* reuse GL_UNIFORM_BUFFER_BINDING */
/* reuse GL_UNIFORM_BUFFER_START */
/* reuse GL_UNIFORM_BUFFER_SIZE */
/* reuse GL_MAX_VERTEX_UNIFORM_BLOCKS */
/* reuse GL_MAX_FRAGMENT_UNIFORM_BLOCKS */
/* reuse GL_MAX_COMBINED_UNIFORM_BLOCKS */
/* reuse GL_MAX_UNIFORM_BUFFER_BINDINGS */
/* reuse GL_MAX_UNIFORM_BLOCK_SIZE */
/* reuse GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS */
/* reuse GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS */
/* reuse GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT */
/* reuse GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH */
/* reuse GL_ACTIVE_UNIFORM_BLOCKS */
/* reuse GL_UNIFORM_TYPE */
/* reuse GL_UNIFORM_SIZE */
/* reuse GL_UNIFORM_NAME_LENGTH */
/* reuse GL_UNIFORM_BLOCK_INDEX */
/* reuse GL_UNIFORM_OFFSET */
/* reuse GL_UNIFORM_ARRAY_STRIDE */
/* reuse GL_UNIFORM_MATRIX_STRIDE */
/* reuse GL_UNIFORM_IS_ROW_MAJOR */
/* reuse GL_UNIFORM_BLOCK_BINDING */
/* reuse GL_UNIFORM_BLOCK_DATA_SIZE */
/* reuse GL_UNIFORM_BLOCK_NAME_LENGTH */
/* reuse GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS */
/* reuse GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES */
/* reuse GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER */
/* reuse GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER */
/* reuse GL_INVALID_INDEX */
#endif

#ifndef GL_VERSION_3_2
#define GL_CONTEXT_CORE_PROFILE_BIT       0x00000001
#define GL_CONTEXT_COMPATIBILITY_PROFILE_BIT 0x00000002
#define GL_LINES_ADJACENCY                0x000A
#define GL_LINE_STRIP_ADJACENCY           0x000B
#define GL_TRIANGLES_ADJACENCY            0x000C
#define GL_TRIANGLE_STRIP_ADJACENCY       0x000D
#define GL_PROGRAM_POINT_SIZE             0x8642
#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS 0x8C29
#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED 0x8DA7
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS 0x8DA8
#define GL_GEOMETRY_SHADER                0x8DD9
#define GL_GEOMETRY_VERTICES_OUT          0x8916
#define GL_GEOMETRY_INPUT_TYPE            0x8917
#define GL_GEOMETRY_OUTPUT_TYPE           0x8918
#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS 0x8DDF
#define GL_MAX_GEOMETRY_OUTPUT_VERTICES   0x8DE0
#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS 0x8DE1
#define GL_MAX_VERTEX_OUTPUT_COMPONENTS   0x9122
#define GL_MAX_GEOMETRY_INPUT_COMPONENTS  0x9123
#define GL_MAX_GEOMETRY_OUTPUT_COMPONENTS 0x9124
#define GL_MAX_FRAGMENT_INPUT_COMPONENTS  0x9125
#define GL_CONTEXT_PROFILE_MASK           0x9126
/* reuse GL_MAX_VARYING_COMPONENTS */
/* reuse GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER */
/* Reuse tokens from ARB_depth_clamp */
/* reuse GL_DEPTH_CLAMP */
/* Reuse tokens from ARB_draw_elements_base_vertex (none) */
/* Reuse tokens from ARB_fragment_coord_conventions (none) */
/* Reuse tokens from ARB_provoking_vertex */
/* reuse GL_FIRST_VERTEX_CONVENTION */
/* reuse GL_LAST_VERTEX_CONVENTION */
/* reuse GL_PROVOKING_VERTEX */
/* Reuse tokens from ARB_seamless_cube_map */
/* reuse GL_TEXTURE_CUBE_MAP_SEAMLESS */
/* Reuse tokens from ARB_sync */
/* reuse GL_MAX_SERVER_WAIT_TIMEOUT */
/* reuse GL_OBJECT_TYPE */
/* reuse GL_SYNC_CONDITION */
/* reuse GL_SYNC_STATUS */
/* reuse GL_SYNC_FLAGS */
/* reuse GL_SYNC_FENCE */
/* reuse GL_SYNC_GPU_COMMANDS_COMPLETE */
/* reuse GL_UNSIGNALED */
/* reuse GL_SIGNALED */
/* reuse GL_ALREADY_SIGNALED */
/* reuse GL_TIMEOUT_EXPIRED */
/* reuse GL_CONDITION_SATISFIED */
/* reuse GL_WAIT_FAILED */
/* reuse GL_TIMEOUT_IGNORED */
/* reuse GL_SYNC_FLUSH_COMMANDS_BIT */
/* reuse GL_TIMEOUT_IGNORED */
/* Reuse tokens from ARB_texture_multisample */
/* reuse GL_SAMPLE_POSITION */
/* reuse GL_SAMPLE_MASK */
/* reuse GL_SAMPLE_MASK_VALUE */
/* reuse GL_MAX_SAMPLE_MASK_WORDS */
/* reuse GL_TEXTURE_2D_MULTISAMPLE */
/* reuse GL_PROXY_TEXTURE_2D_MULTISAMPLE */
/* reuse GL_TEXTURE_2D_MULTISAMPLE_ARRAY */
/* reuse GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY */
/* reuse GL_TEXTURE_BINDING_2D_MULTISAMPLE */
/* reuse GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY */
/* reuse GL_TEXTURE_SAMPLES */
/* reuse GL_TEXTURE_FIXED_SAMPLE_LOCATIONS */
/* reuse GL_SAMPLER_2D_MULTISAMPLE */
/* reuse GL_INT_SAMPLER_2D_MULTISAMPLE */
/* reuse GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE */
/* reuse GL_SAMPLER_2D_MULTISAMPLE_ARRAY */
/* reuse GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY */
/* reuse GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY */
/* reuse GL_MAX_COLOR_TEXTURE_SAMPLES */
/* reuse GL_MAX_DEPTH_TEXTURE_SAMPLES */
/* reuse GL_MAX_INTEGER_SAMPLES */
/* Don't need to reuse tokens from ARB_vertex_array_bgra since they're already in 1.2 core */
#endif

#ifndef GL_VERSION_3_3
#define GL_VERTEX_ATTRIB_ARRAY_DIVISOR    0x88FE
/* Reuse tokens from ARB_blend_func_extended */
/* reuse GL_SRC1_COLOR */
/* reuse GL_SRC1_ALPHA */
/* reuse GL_ONE_MINUS_SRC1_COLOR */
/* reuse GL_ONE_MINUS_SRC1_ALPHA */
/* reuse GL_MAX_DUAL_SOURCE_DRAW_BUFFERS */
/* Reuse tokens from ARB_explicit_attrib_location (none) */
/* Reuse tokens from ARB_occlusion_query2 */
/* reuse GL_ANY_SAMPLES_PASSED */
/* Reuse tokens from ARB_sampler_objects */
/* reuse GL_SAMPLER_BINDING */
/* Reuse tokens from ARB_shader_bit_encoding (none) */
/* Reuse tokens from ARB_texture_rgb10_a2ui */
/* reuse GL_RGB10_A2UI */
/* Reuse tokens from ARB_texture_swizzle */
/* reuse GL_TEXTURE_SWIZZLE_R */
/* reuse GL_TEXTURE_SWIZZLE_G */
/* reuse GL_TEXTURE_SWIZZLE_B */
/* reuse GL_TEXTURE_SWIZZLE_A */
/* reuse GL_TEXTURE_SWIZZLE_RGBA */
/* Reuse tokens from ARB_timer_query */
/* reuse GL_TIME_ELAPSED */
/* reuse GL_TIMESTAMP */
/* Reuse tokens from ARB_vertex_type_2_10_10_10_rev */
/* reuse GL_INT_2_10_10_10_REV */
#endif

#ifndef GL_VERSION_4_0
#define GL_SAMPLE_SHADING                 0x8C36
#define GL_MIN_SAMPLE_SHADING_VALUE       0x8C37
#define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5E
#define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET 0x8E5F
#define GL_TEXTURE_CUBE_MAP_ARRAY         0x9009
#define GL_TEXTURE_BINDING_CUBE_MAP_ARRAY 0x900A
#define GL_PROXY_TEXTURE_CUBE_MAP_ARRAY   0x900B
#define GL_SAMPLER_CUBE_MAP_ARRAY         0x900C
#define GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW  0x900D
#define GL_INT_SAMPLER_CUBE_MAP_ARRAY     0x900E
#define GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY 0x900F
/* Reuse tokens from ARB_texture_query_lod (none) */
/* Reuse tokens from ARB_draw_indirect */
/* reuse GL_DRAW_INDIRECT_BUFFER */
/* reuse GL_DRAW_INDIRECT_BUFFER_BINDING */
/* Reuse tokens from ARB_gpu_shader5 */
/* reuse GL_GEOMETRY_SHADER_INVOCATIONS */
/* reuse GL_MAX_GEOMETRY_SHADER_INVOCATIONS */
/* reuse GL_MIN_FRAGMENT_INTERPOLATION_OFFSET */
/* reuse GL_MAX_FRAGMENT_INTERPOLATION_OFFSET */
/* reuse GL_FRAGMENT_INTERPOLATION_OFFSET_BITS */
/* reuse GL_MAX_VERTEX_STREAMS */
/* Reuse tokens from ARB_gpu_shader_fp64 */
/* reuse GL_DOUBLE_VEC2 */
/* reuse GL_DOUBLE_VEC3 */
/* reuse GL_DOUBLE_VEC4 */
/* reuse GL_DOUBLE_MAT2 */
/* reuse GL_DOUBLE_MAT3 */
/* reuse GL_DOUBLE_MAT4 */
/* reuse GL_DOUBLE_MAT2x3 */
/* reuse GL_DOUBLE_MAT2x4 */
/* reuse GL_DOUBLE_MAT3x2 */
/* reuse GL_DOUBLE_MAT3x4 */
/* reuse GL_DOUBLE_MAT4x2 */
/* reuse GL_DOUBLE_MAT4x3 */
/* Reuse tokens from ARB_shader_subroutine */
/* reuse GL_ACTIVE_SUBROUTINES */
/* reuse GL_ACTIVE_SUBROUTINE_UNIFORMS */
/* reuse GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS */
/* reuse GL_ACTIVE_SUBROUTINE_MAX_LENGTH */
/* reuse GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH */
/* reuse GL_MAX_SUBROUTINES */
/* reuse GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS */
/* reuse GL_NUM_COMPATIBLE_SUBROUTINES */
/* reuse GL_COMPATIBLE_SUBROUTINES */
/* Reuse tokens from ARB_tessellation_shader */
/* reuse GL_PATCHES */
/* reuse GL_PATCH_VERTICES */
/* reuse GL_PATCH_DEFAULT_INNER_LEVEL */
/* reuse GL_PATCH_DEFAULT_OUTER_LEVEL */
/* reuse GL_TESS_CONTROL_OUTPUT_VERTICES */
/* reuse GL_TESS_GEN_MODE */
/* reuse GL_TESS_GEN_SPACING */
/* reuse GL_TESS_GEN_VERTEX_ORDER */
/* reuse GL_TESS_GEN_POINT_MODE */
/* reuse GL_ISOLINES */
/* reuse GL_FRACTIONAL_ODD */
/* reuse GL_FRACTIONAL_EVEN */
/* reuse GL_MAX_PATCH_VERTICES */
/* reuse GL_MAX_TESS_GEN_LEVEL */
/* reuse GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS */
/* reuse GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS */
/* reuse GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS */
/* reuse GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS */
/* reuse GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS */
/* reuse GL_MAX_TESS_PATCH_COMPONENTS */
/* reuse GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS */
/* reuse GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS */
/* reuse GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS */
/* reuse GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS */
/* reuse GL_MAX_TESS_CONTROL_INPUT_COMPONENTS */
/* reuse GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS */
/* reuse GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS */
/* reuse GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS */
/* reuse GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER */
/* reuse GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER */
/* reuse GL_TESS_EVALUATION_SHADER */
/* reuse GL_TESS_CONTROL_SHADER */
/* Reuse tokens from ARB_texture_buffer_object_rgb32 (none) */
/* Reuse tokens from ARB_transform_feedback2 */
/* reuse GL_TRANSFORM_FEEDBACK */
/* reuse GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED */
/* reuse GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE */
/* reuse GL_TRANSFORM_FEEDBACK_BINDING */
/* Reuse tokens from ARB_transform_feedback3 */
/* reuse GL_MAX_TRANSFORM_FEEDBACK_BUFFERS */
/* reuse GL_MAX_VERTEX_STREAMS */
#endif

#ifndef GL_VERSION_4_1
/* Reuse tokens from ARB_ES2_compatibility */
/* reuse GL_FIXED */
/* reuse GL_IMPLEMENTATION_COLOR_READ_TYPE */
/* reuse GL_IMPLEMENTATION_COLOR_READ_FORMAT */
/* reuse GL_LOW_FLOAT */
/* reuse GL_MEDIUM_FLOAT */
/* reuse GL_HIGH_FLOAT */
/* reuse GL_LOW_INT */
/* reuse GL_MEDIUM_INT */
/* reuse GL_HIGH_INT */
/* reuse GL_SHADER_COMPILER */
/* reuse GL_NUM_SHADER_BINARY_FORMATS */
/* reuse GL_MAX_VERTEX_UNIFORM_VECTORS */
/* reuse GL_MAX_VARYING_VECTORS */
/* reuse GL_MAX_FRAGMENT_UNIFORM_VECTORS */
/* reuse GL_RGB565 */
/* Reuse tokens from ARB_get_program_binary */
/* reuse GL_PROGRAM_BINARY_RETRIEVABLE_HINT */
/* reuse GL_PROGRAM_BINARY_LENGTH */
/* reuse GL_NUM_PROGRAM_BINARY_FORMATS */
/* reuse GL_PROGRAM_BINARY_FORMATS */
/* Reuse tokens from ARB_separate_shader_objects */
/* reuse GL_VERTEX_SHADER_BIT */
/* reuse GL_FRAGMENT_SHADER_BIT */
/* reuse GL_GEOMETRY_SHADER_BIT */
/* reuse GL_TESS_CONTROL_SHADER_BIT */
/* reuse GL_TESS_EVALUATION_SHADER_BIT */
/* reuse GL_ALL_SHADER_BITS */
/* reuse GL_PROGRAM_SEPARABLE */
/* reuse GL_ACTIVE_PROGRAM */
/* reuse GL_PROGRAM_PIPELINE_BINDING */
/* Reuse tokens from ARB_shader_precision (none) */
/* Reuse tokens from ARB_vertex_attrib_64bit - all are in GL 3.0 and 4.0 already */
/* Reuse tokens from ARB_viewport_array - some are in GL 1.1 and ARB_provoking_vertex already */
/* reuse GL_MAX_VIEWPORTS */
/* reuse GL_VIEWPORT_SUBPIXEL_BITS */
/* reuse GL_VIEWPORT_BOUNDS_RANGE */
/* reuse GL_LAYER_PROVOKING_VERTEX */
/* reuse GL_VIEWPORT_INDEX_PROVOKING_VERTEX */
/* reuse GL_UNDEFINED_VERTEX */
#endif

#ifndef GL_ARB_depth_buffer_float
#define GL_DEPTH_COMPONENT32F             0x8CAC
#define GL_DEPTH32F_STENCIL8              0x8CAD
#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV 0x8DAD
#endif

#ifndef GL_ARB_framebuffer_object
#define GL_INVALID_FRAMEBUFFER_OPERATION  0x0506
#define GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING 0x8210
#define GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE 0x8211
#define GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE 0x8212
#define GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE 0x8213
#define GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE 0x8214
#define GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE 0x8215
#define GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE 0x8216
#define GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE 0x8217
#define GL_FRAMEBUFFER_DEFAULT            0x8218
#define GL_FRAMEBUFFER_UNDEFINED          0x8219
#define GL_DEPTH_STENCIL_ATTACHMENT       0x821A
#define GL_MAX_RENDERBUFFER_SIZE          0x84E8
#define GL_DEPTH_STENCIL                  0x84F9
#define GL_UNSIGNED_INT_24_8              0x84FA
#define GL_DEPTH24_STENCIL8               0x88F0
#define GL_TEXTURE_STENCIL_SIZE           0x88F1
#define GL_TEXTURE_RED_TYPE               0x8C10
#define GL_TEXTURE_GREEN_TYPE             0x8C11
#define GL_TEXTURE_BLUE_TYPE              0x8C12
#define GL_TEXTURE_ALPHA_TYPE             0x8C13
#define GL_TEXTURE_DEPTH_TYPE             0x8C16
#define GL_UNSIGNED_NORMALIZED            0x8C17
#define GL_FRAMEBUFFER_BINDING            0x8CA6
#define GL_DRAW_FRAMEBUFFER_BINDING       GL_FRAMEBUFFER_BINDING
#define GL_RENDERBUFFER_BINDING           0x8CA7
#define GL_READ_FRAMEBUFFER               0x8CA8
#define GL_DRAW_FRAMEBUFFER               0x8CA9
#define GL_READ_FRAMEBUFFER_BINDING       0x8CAA
#define GL_RENDERBUFFER_SAMPLES           0x8CAB
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE 0x8CD0
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME 0x8CD1
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL 0x8CD2
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE 0x8CD3
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER 0x8CD4
#define GL_FRAMEBUFFER_COMPLETE           0x8CD5
#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT 0x8CD6
#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT 0x8CD7
#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER 0x8CDB
#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER 0x8CDC
#define GL_FRAMEBUFFER_UNSUPPORTED        0x8CDD
#define GL_MAX_COLOR_ATTACHMENTS          0x8CDF
#define GL_COLOR_ATTACHMENT0              0x8CE0
#define GL_COLOR_ATTACHMENT1              0x8CE1
#define GL_COLOR_ATTACHMENT2              0x8CE2
#define GL_COLOR_ATTACHMENT3              0x8CE3
#define GL_COLOR_ATTACHMENT4              0x8CE4
#define GL_COLOR_ATTACHMENT5              0x8CE5
#define GL_COLOR_ATTACHMENT6              0x8CE6
#define GL_COLOR_ATTACHMENT7              0x8CE7
#define GL_COLOR_ATTACHMENT8              0x8CE8
#define GL_COLOR_ATTACHMENT9              0x8CE9
#define GL_COLOR_ATTACHMENT10             0x8CEA
#define GL_COLOR_ATTACHMENT11             0x8CEB
#define GL_COLOR_ATTACHMENT12             0x8CEC
#define GL_COLOR_ATTACHMENT13             0x8CED
#define GL_COLOR_ATTACHMENT14             0x8CEE
#define GL_COLOR_ATTACHMENT15             0x8CEF
#define GL_DEPTH_ATTACHMENT               0x8D00
#define GL_STENCIL_ATTACHMENT             0x8D20
#define GL_FRAMEBUFFER                    0x8D40
#define GL_RENDERBUFFER                   0x8D41
#define GL_RENDERBUFFER_WIDTH             0x8D42
#define GL_RENDERBUFFER_HEIGHT            0x8D43
#define GL_RENDERBUFFER_INTERNAL_FORMAT   0x8D44
#define GL_STENCIL_INDEX1                 0x8D46
#define GL_STENCIL_INDEX4                 0x8D47
#define GL_STENCIL_INDEX8                 0x8D48
#define GL_STENCIL_INDEX16                0x8D49
#define GL_RENDERBUFFER_RED_SIZE          0x8D50
#define GL_RENDERBUFFER_GREEN_SIZE        0x8D51
#define GL_RENDERBUFFER_BLUE_SIZE         0x8D52
#define GL_RENDERBUFFER_ALPHA_SIZE        0x8D53
#define GL_RENDERBUFFER_DEPTH_SIZE        0x8D54
#define GL_RENDERBUFFER_STENCIL_SIZE      0x8D55
#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE 0x8D56
#define GL_MAX_SAMPLES                    0x8D57
#endif

#ifndef GL_ARB_framebuffer_sRGB
#define GL_FRAMEBUFFER_SRGB               0x8DB9
#endif

#ifndef GL_ARB_half_float_vertex
#define GL_HALF_FLOAT                     0x140B
#endif

#ifndef GL_ARB_map_buffer_range
#define GL_MAP_READ_BIT                   0x0001
#define GL_MAP_WRITE_BIT                  0x0002
#define GL_MAP_INVALIDATE_RANGE_BIT       0x0004
#define GL_MAP_INVALIDATE_BUFFER_BIT      0x0008
#define GL_MAP_FLUSH_EXPLICIT_BIT         0x0010
#define GL_MAP_UNSYNCHRONIZED_BIT         0x0020
#endif

#ifndef GL_ARB_texture_compression_rgtc
#define GL_COMPRESSED_RED_RGTC1           0x8DBB
#define GL_COMPRESSED_SIGNED_RED_RGTC1    0x8DBC
#define GL_COMPRESSED_RG_RGTC2            0x8DBD
#define GL_COMPRESSED_SIGNED_RG_RGTC2     0x8DBE
#endif

#ifndef GL_ARB_texture_rg
#define GL_RG                             0x8227
#define GL_RG_INTEGER                     0x8228
#define GL_R8                             0x8229
#define GL_R16                            0x822A
#define GL_RG8                            0x822B
#define GL_RG16                           0x822C
#define GL_R16F                           0x822D
#define GL_R32F                           0x822E
#define GL_RG16F                          0x822F
#define GL_RG32F                          0x8230
#define GL_R8I                            0x8231
#define GL_R8UI                           0x8232
#define GL_R16I                           0x8233
#define GL_R16UI                          0x8234
#define GL_R32I                           0x8235
#define GL_R32UI                          0x8236
#define GL_RG8I                           0x8237
#define GL_RG8UI                          0x8238
#define GL_RG16I                          0x8239
#define GL_RG16UI                         0x823A
#define GL_RG32I                          0x823B
#define GL_RG32UI                         0x823C
#endif

#ifndef GL_ARB_vertex_array_object
#define GL_VERTEX_ARRAY_BINDING           0x85B5
#endif

#ifndef GL_ARB_uniform_buffer_object
#define GL_UNIFORM_BUFFER                 0x8A11
#define GL_UNIFORM_BUFFER_BINDING         0x8A28
#define GL_UNIFORM_BUFFER_START           0x8A29
#define GL_UNIFORM_BUFFER_SIZE            0x8A2A
#define GL_MAX_VERTEX_UNIFORM_BLOCKS      0x8A2B
#define GL_MAX_GEOMETRY_UNIFORM_BLOCKS    0x8A2C
#define GL_MAX_FRAGMENT_UNIFORM_BLOCKS    0x8A2D
#define GL_MAX_COMBINED_UNIFORM_BLOCKS    0x8A2E
#define GL_MAX_UNIFORM_BUFFER_BINDINGS    0x8A2F
#define GL_MAX_UNIFORM_BLOCK_SIZE         0x8A30
#define GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS 0x8A31
#define GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS 0x8A32
#define GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS 0x8A33
#define GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT 0x8A34
#define GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH 0x8A35
#define GL_ACTIVE_UNIFORM_BLOCKS          0x8A36
#define GL_UNIFORM_TYPE                   0x8A37
#define GL_UNIFORM_SIZE                   0x8A38
#define GL_UNIFORM_NAME_LENGTH            0x8A39
#define GL_UNIFORM_BLOCK_INDEX            0x8A3A
#define GL_UNIFORM_OFFSET                 0x8A3B
#define GL_UNIFORM_ARRAY_STRIDE           0x8A3C
#define GL_UNIFORM_MATRIX_STRIDE          0x8A3D
#define GL_UNIFORM_IS_ROW_MAJOR           0x8A3E
#define GL_UNIFORM_BLOCK_BINDING          0x8A3F
#define GL_UNIFORM_BLOCK_DATA_SIZE        0x8A40
#define GL_UNIFORM_BLOCK_NAME_LENGTH      0x8A41
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS  0x8A42
#define GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES 0x8A43
#define GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER 0x8A44
#define GL_UNIFORM_BLOCK_REFERENCED_BY_GEOMETRY_SHADER 0x8A45
#define GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER 0x8A46
#define GL_INVALID_INDEX                  0xFFFFFFFFu
#endif

#ifndef GL_ARB_copy_buffer
#define GL_COPY_READ_BUFFER               0x8F36
#define GL_COPY_WRITE_BUFFER              0x8F37
#endif

#ifndef GL_ARB_depth_clamp
#define GL_DEPTH_CLAMP                    0x864F
#endif

#ifndef GL_ARB_draw_elements_base_vertex
#endif

#ifndef GL_ARB_fragment_coord_conventions
#endif

#ifndef GL_ARB_provoking_vertex
#define GL_FIRST_VERTEX_CONVENTION        0x8E4D
#define GL_LAST_VERTEX_CONVENTION         0x8E4E
#define GL_PROVOKING_VERTEX               0x8E4F
#endif

#ifndef GL_ARB_seamless_cube_map
#define GL_TEXTURE_CUBE_MAP_SEAMLESS      0x884F
#endif

#ifndef GL_ARB_sync
#define GL_MAX_SERVER_WAIT_TIMEOUT        0x9111
#define GL_OBJECT_TYPE                    0x9112
#define GL_SYNC_CONDITION                 0x9113
#define GL_SYNC_STATUS                    0x9114
#define GL_SYNC_FLAGS                     0x9115
#define GL_SYNC_FENCE                     0x9116
#define GL_SYNC_GPU_COMMANDS_COMPLETE     0x9117
#define GL_UNSIGNALED                     0x9118
#define GL_SIGNALED                       0x9119
#define GL_ALREADY_SIGNALED               0x911A
#define GL_TIMEOUT_EXPIRED                0x911B
#define GL_CONDITION_SATISFIED            0x911C
#define GL_WAIT_FAILED                    0x911D
#define GL_SYNC_FLUSH_COMMANDS_BIT        0x00000001
#define GL_TIMEOUT_IGNORED                0xFFFFFFFFFFFFFFFFull
#endif

#ifndef GL_ARB_texture_multisample
#define GL_SAMPLE_POSITION                0x8E50
#define GL_SAMPLE_MASK                    0x8E51
#define GL_SAMPLE_MASK_VALUE              0x8E52
#define GL_MAX_SAMPLE_MASK_WORDS          0x8E59
#define GL_TEXTURE_2D_MULTISAMPLE         0x9100
#define GL_PROXY_TEXTURE_2D_MULTISAMPLE   0x9101
#define GL_TEXTURE_2D_MULTISAMPLE_ARRAY   0x9102
#define GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY 0x9103
#define GL_TEXTURE_BINDING_2D_MULTISAMPLE 0x9104
#define GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY 0x9105
#define GL_TEXTURE_SAMPLES                0x9106
#define GL_TEXTURE_FIXED_SAMPLE_LOCATIONS 0x9107
#define GL_SAMPLER_2D_MULTISAMPLE         0x9108
#define GL_INT_SAMPLER_2D_MULTISAMPLE     0x9109
#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE 0x910A
#define GL_SAMPLER_2D_MULTISAMPLE_ARRAY   0x910B
#define GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910C
#define GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY 0x910D
#define GL_MAX_COLOR_TEXTURE_SAMPLES      0x910E
#define GL_MAX_DEPTH_TEXTURE_SAMPLES      0x910F
#define GL_MAX_INTEGER_SAMPLES            0x9110
#endif

#ifndef GL_ARB_vertex_array_bgra
/* reuse GL_BGRA */
#endif

#ifndef GL_ARB_texture_query_lod
#endif

#ifndef GL_ARB_blend_func_extended
#define GL_SRC1_COLOR                     0x88F9
#define GL_SRC1_ALPHA                     0x8589
#define GL_ONE_MINUS_SRC1_COLOR           0x88FA
#define GL_ONE_MINUS_SRC1_ALPHA           0x88FB
#define GL_MAX_DUAL_SOURCE_DRAW_BUFFERS   0x88FC
#endif

#ifndef GL_ARB_explicit_attrib_location
#endif

#ifndef GL_ARB_occlusion_query2
#define GL_ANY_SAMPLES_PASSED             0x8C2F
#endif

#ifndef GL_ARB_sampler_objects
#define GL_SAMPLER_BINDING                0x8919
#endif

#ifndef GL_ARB_shader_bit_encoding
#endif

#ifndef GL_ARB_texture_rgb10_a2ui
#define GL_RGB10_A2UI                     0x906F
#endif

#ifndef GL_ARB_texture_swizzle
#define GL_TEXTURE_SWIZZLE_R              0x8E42
#define GL_TEXTURE_SWIZZLE_G              0x8E43
#define GL_TEXTURE_SWIZZLE_B              0x8E44
#define GL_TEXTURE_SWIZZLE_A              0x8E45
#define GL_TEXTURE_SWIZZLE_RGBA           0x8E46
#endif

#ifndef GL_ARB_timer_query
#define GL_TIME_ELAPSED                   0x88BF
#define GL_TIMESTAMP                      0x8E28
#endif

#ifndef GL_ARB_vertex_type_2_10_10_10_rev
/* reuse GL_UNSIGNED_INT_2_10_10_10_REV */
#define GL_INT_2_10_10_10_REV             0x8D9F
#endif

#ifndef GL_ARB_draw_indirect
#define GL_DRAW_INDIRECT_BUFFER           0x8F3F
#define GL_DRAW_INDIRECT_BUFFER_BINDING   0x8F43
#endif

#ifndef GL_ARB_gpu_shader5
#define GL_GEOMETRY_SHADER_INVOCATIONS    0x887F
#define GL_MAX_GEOMETRY_SHADER_INVOCATIONS 0x8E5A
#define GL_MIN_FRAGMENT_INTERPOLATION_OFFSET 0x8E5B
#define GL_MAX_FRAGMENT_INTERPOLATION_OFFSET 0x8E5C
#define GL_FRAGMENT_INTERPOLATION_OFFSET_BITS 0x8E5D
/* reuse GL_MAX_VERTEX_STREAMS */
#endif

#ifndef GL_ARB_gpu_shader_fp64
/* reuse GL_DOUBLE */
#define GL_DOUBLE_VEC2                    0x8FFC
#define GL_DOUBLE_VEC3                    0x8FFD
#define GL_DOUBLE_VEC4                    0x8FFE
#define GL_DOUBLE_MAT2                    0x8F46
#define GL_DOUBLE_MAT3                    0x8F47
#define GL_DOUBLE_MAT4                    0x8F48
#define GL_DOUBLE_MAT2x3                  0x8F49
#define GL_DOUBLE_MAT2x4                  0x8F4A
#define GL_DOUBLE_MAT3x2                  0x8F4B
#define GL_DOUBLE_MAT3x4                  0x8F4C
#define GL_DOUBLE_MAT4x2                  0x8F4D
#define GL_DOUBLE_MAT4x3                  0x8F4E
#endif

#ifndef GL_ARB_shader_subroutine
#define GL_ACTIVE_SUBROUTINES             0x8DE5
#define GL_ACTIVE_SUBROUTINE_UNIFORMS     0x8DE6
#define GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS 0x8E47
#define GL_ACTIVE_SUBROUTINE_MAX_LENGTH   0x8E48
#define GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH 0x8E49
#define GL_MAX_SUBROUTINES                0x8DE7
#define GL_MAX_SUBROUTINE_UNIFORM_LOCATIONS 0x8DE8
#define GL_NUM_COMPATIBLE_SUBROUTINES     0x8E4A
#define GL_COMPATIBLE_SUBROUTINES         0x8E4B
/* reuse GL_UNIFORM_SIZE */
/* reuse GL_UNIFORM_NAME_LENGTH */
#endif

#ifndef GL_ARB_tessellation_shader
#define GL_PATCHES                        0x000E
#define GL_PATCH_VERTICES                 0x8E72
#define GL_PATCH_DEFAULT_INNER_LEVEL      0x8E73
#define GL_PATCH_DEFAULT_OUTER_LEVEL      0x8E74
#define GL_TESS_CONTROL_OUTPUT_VERTICES   0x8E75
#define GL_TESS_GEN_MODE                  0x8E76
#define GL_TESS_GEN_SPACING               0x8E77
#define GL_TESS_GEN_VERTEX_ORDER          0x8E78
#define GL_TESS_GEN_POINT_MODE            0x8E79
/* reuse GL_TRIANGLES */
#define GL_QUADS                          0x0007
#define GL_ISOLINES                       0x8E7A
/* reuse GL_EQUAL */
#define GL_FRACTIONAL_ODD                 0x8E7B
#define GL_FRACTIONAL_EVEN                0x8E7C
/* reuse GL_CCW */
/* reuse GL_CW */
#define GL_MAX_PATCH_VERTICES             0x8E7D
#define GL_MAX_TESS_GEN_LEVEL             0x8E7E
#define GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS 0x8E7F
#define GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS 0x8E80
#define GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS 0x8E81
#define GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS 0x8E82
#define GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS 0x8E83
#define GL_MAX_TESS_PATCH_COMPONENTS      0x8E84
#define GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS 0x8E85
#define GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS 0x8E86
#define GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS 0x8E89
#define GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS 0x8E8A
#define GL_MAX_TESS_CONTROL_INPUT_COMPONENTS 0x886C
#define GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS 0x886D
#define GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS 0x8E1E
#define GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS 0x8E1F
#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_CONTROL_SHADER 0x84F0
#define GL_UNIFORM_BLOCK_REFERENCED_BY_TESS_EVALUATION_SHADER 0x84F1
#define GL_TESS_EVALUATION_SHADER         0x8E87
#define GL_TESS_CONTROL_SHADER            0x8E88
#endif

#ifndef GL_ARB_texture_buffer_object_rgb32
/* reuse GL_RGB32F */
/* reuse GL_RGB32UI */
/* reuse GL_RGB32I */
#endif

#ifndef GL_ARB_transform_feedback2
#define GL_TRANSFORM_FEEDBACK             0x8E22
#define GL_TRANSFORM_FEEDBACK_BUFFER_PAUSED 0x8E23
#define GL_TRANSFORM_FEEDBACK_BUFFER_ACTIVE 0x8E24
#define GL_TRANSFORM_FEEDBACK_BINDING     0x8E25
#endif

#ifndef GL_ARB_transform_feedback3
#define GL_MAX_TRANSFORM_FEEDBACK_BUFFERS 0x8E70
#define GL_MAX_VERTEX_STREAMS             0x8E71
#endif

#ifndef GL_ARB_ES2_compatibility
#define GL_FIXED                          0x140C
#define GL_IMPLEMENTATION_COLOR_READ_TYPE 0x8B9A
#define GL_IMPLEMENTATION_COLOR_READ_FORMAT 0x8B9B
#define GL_LOW_FLOAT                      0x8DF0
#define GL_MEDIUM_FLOAT                   0x8DF1
#define GL_HIGH_FLOAT                     0x8DF2
#define GL_LOW_INT                        0x8DF3
#define GL_MEDIUM_INT                     0x8DF4
#define GL_HIGH_INT                       0x8DF5
#define GL_SHADER_COMPILER                0x8DFA
#define GL_SHADER_BINARY_FORMATS          0x8DF8
#define GL_NUM_SHADER_BINARY_FORMATS      0x8DF9
#define GL_MAX_VERTEX_UNIFORM_VECTORS     0x8DFB
#define GL_MAX_VARYING_VECTORS            0x8DFC
#define GL_MAX_FRAGMENT_UNIFORM_VECTORS   0x8DFD
#define GL_RGB565                         0x8D62
#endif

#ifndef GL_ARB_get_program_binary
#define GL_PROGRAM_BINARY_RETRIEVABLE_HINT 0x8257
#define GL_PROGRAM_BINARY_LENGTH          0x8741
#define GL_NUM_PROGRAM_BINARY_FORMATS     0x87FE
#define GL_PROGRAM_BINARY_FORMATS         0x87FF
#endif

#ifndef GL_ARB_separate_shader_objects
#define GL_VERTEX_SHADER_BIT              0x00000001
#define GL_FRAGMENT_SHADER_BIT            0x00000002
#define GL_GEOMETRY_SHADER_BIT            0x00000004
#define GL_TESS_CONTROL_SHADER_BIT        0x00000008
#define GL_TESS_EVALUATION_SHADER_BIT     0x00000010
#define GL_ALL_SHADER_BITS                0xFFFFFFFF
#define GL_PROGRAM_SEPARABLE              0x8258
#define GL_ACTIVE_PROGRAM                 0x8259
#define GL_PROGRAM_PIPELINE_BINDING       0x825A
#endif

#ifndef GL_ARB_shader_precision
#endif

#ifndef GL_ARB_vertex_attrib_64bit
/* reuse GL_DOUBLE */
/* reuse GL_DOUBLE_VEC2 */
/* reuse GL_DOUBLE_VEC3 */
/* reuse GL_DOUBLE_VEC4 */
/* reuse GL_DOUBLE_MAT2 */
/* reuse GL_DOUBLE_MAT3 */
/* reuse GL_DOUBLE_MAT4 */
/* reuse GL_DOUBLE_MAT2x3 */
/* reuse GL_DOUBLE_MAT2x4 */
/* reuse GL_DOUBLE_MAT3x2 */
/* reuse GL_DOUBLE_MAT3x4 */
/* reuse GL_DOUBLE_MAT4x2 */
/* reuse GL_DOUBLE_MAT4x3 */
#endif

#ifndef GL_ARB_viewport_array
/* reuse GL_SCISSOR_BOX */
/* reuse GL_VIEWPORT */
/* reuse GL_DEPTH_RANGE */
/* reuse GL_SCISSOR_TEST */
#define GL_MAX_VIEWPORTS                  0x825B
#define GL_VIEWPORT_SUBPIXEL_BITS         0x825C
#define GL_VIEWPORT_BOUNDS_RANGE          0x825D
#define GL_LAYER_PROVOKING_VERTEX         0x825E
#define GL_VIEWPORT_INDEX_PROVOKING_VERTEX 0x825F
#define GL_UNDEFINED_VERTEX               0x8260
/* reuse GL_FIRST_VERTEX_CONVENTION */
/* reuse GL_LAST_VERTEX_CONVENTION */
/* reuse GL_PROVOKING_VERTEX */
#endif


/*************************************************************/

#ifndef GL_VERSION_1_0
#define GL_VERSION_1_0 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glCullFace (GLenum mode);
GLAPI void APIENTRY glFrontFace (GLenum mode);
GLAPI void APIENTRY glHint (GLenum target, GLenum mode);
GLAPI void APIENTRY glLineWidth (GLfloat width);
GLAPI void APIENTRY glPointSize (GLfloat size);
GLAPI void APIENTRY glPolygonMode (GLenum face, GLenum mode);
GLAPI void APIENTRY glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
GLAPI void APIENTRY glTexParameterf (GLenum target, GLenum pname, GLfloat param);
GLAPI void APIENTRY glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
GLAPI void APIENTRY glTexParameteri (GLenum target, GLenum pname, GLint param);
GLAPI void APIENTRY glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
GLAPI void APIENTRY glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
GLAPI void APIENTRY glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
GLAPI void APIENTRY glDrawBuffer (GLenum mode);
GLAPI void APIENTRY glClear (GLbitfield mask);
GLAPI void APIENTRY glClearColor (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
GLAPI void APIENTRY glClearStencil (GLint s);
GLAPI void APIENTRY glClearDepth (GLclampd depth);
GLAPI void APIENTRY glStencilMask (GLuint mask);
GLAPI void APIENTRY glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
GLAPI void APIENTRY glDepthMask (GLboolean flag);
GLAPI void APIENTRY glDisable (GLenum cap);
GLAPI void APIENTRY glEnable (GLenum cap);
GLAPI void APIENTRY glFinish (void);
GLAPI void APIENTRY glFlush (void);
GLAPI void APIENTRY glBlendFunc (GLenum sfactor, GLenum dfactor);
GLAPI void APIENTRY glLogicOp (GLenum opcode);
GLAPI void APIENTRY glStencilFunc (GLenum func, GLint ref, GLuint mask);
GLAPI void APIENTRY glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
GLAPI void APIENTRY glDepthFunc (GLenum func);
GLAPI void APIENTRY glPixelStoref (GLenum pname, GLfloat param);
GLAPI void APIENTRY glPixelStorei (GLenum pname, GLint param);
GLAPI void APIENTRY glReadBuffer (GLenum mode);
GLAPI void APIENTRY glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
GLAPI void APIENTRY glGetBooleanv (GLenum pname, GLboolean *params);
GLAPI void APIENTRY glGetDoublev (GLenum pname, GLdouble *params);
GLAPI GLenum APIENTRY glGetError (void);
GLAPI void APIENTRY glGetFloatv (GLenum pname, GLfloat *params);
GLAPI void APIENTRY glGetIntegerv (GLenum pname, GLint *params);
GLAPI const GLubyte * APIENTRY glGetString (GLenum name);
GLAPI void APIENTRY glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
GLAPI void APIENTRY glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
GLAPI void APIENTRY glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
GLAPI void APIENTRY glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
GLAPI void APIENTRY glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
GLAPI GLboolean APIENTRY glIsEnabled (GLenum cap);
GLAPI void APIENTRY glDepthRange (GLclampd near, GLclampd far);
GLAPI void APIENTRY glViewport (GLint x, GLint y, GLsizei width, GLsizei height);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLCULLFACEPROC) (GLenum mode);
typedef void (APIENTRYP PFNGLFRONTFACEPROC) (GLenum mode);
typedef void (APIENTRYP PFNGLHINTPROC) (GLenum target, GLenum mode);
typedef void (APIENTRYP PFNGLLINEWIDTHPROC) (GLfloat width);
typedef void (APIENTRYP PFNGLPOINTSIZEPROC) (GLfloat size);
typedef void (APIENTRYP PFNGLPOLYGONMODEPROC) (GLenum face, GLenum mode);
typedef void (APIENTRYP PFNGLSCISSORPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (APIENTRYP PFNGLTEXPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void (APIENTRYP PFNGLTEXPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void (APIENTRYP PFNGLTEXPARAMETERIPROC) (GLenum target, GLenum pname, GLint param);
typedef void (APIENTRYP PFNGLTEXPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (APIENTRYP PFNGLTEXIMAGE1DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (APIENTRYP PFNGLTEXIMAGE2DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (APIENTRYP PFNGLDRAWBUFFERPROC) (GLenum mode);
typedef void (APIENTRYP PFNGLCLEARPROC) (GLbitfield mask);
typedef void (APIENTRYP PFNGLCLEARCOLORPROC) (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
typedef void (APIENTRYP PFNGLCLEARSTENCILPROC) (GLint s);
typedef void (APIENTRYP PFNGLCLEARDEPTHPROC) (GLclampd depth);
typedef void (APIENTRYP PFNGLSTENCILMASKPROC) (GLuint mask);
typedef void (APIENTRYP PFNGLCOLORMASKPROC) (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
typedef void (APIENTRYP PFNGLDEPTHMASKPROC) (GLboolean flag);
typedef void (APIENTRYP PFNGLDISABLEPROC) (GLenum cap);
typedef void (APIENTRYP PFNGLENABLEPROC) (GLenum cap);
typedef void (APIENTRYP PFNGLFINISHPROC) (void);
typedef void (APIENTRYP PFNGLFLUSHPROC) (void);
typedef void (APIENTRYP PFNGLBLENDFUNCPROC) (GLenum sfactor, GLenum dfactor);
typedef void (APIENTRYP PFNGLLOGICOPPROC) (GLenum opcode);
typedef void (APIENTRYP PFNGLSTENCILFUNCPROC) (GLenum func, GLint ref, GLuint mask);
typedef void (APIENTRYP PFNGLSTENCILOPPROC) (GLenum fail, GLenum zfail, GLenum zpass);
typedef void (APIENTRYP PFNGLDEPTHFUNCPROC) (GLenum func);
typedef void (APIENTRYP PFNGLPIXELSTOREFPROC) (GLenum pname, GLfloat param);
typedef void (APIENTRYP PFNGLPIXELSTOREIPROC) (GLenum pname, GLint param);
typedef void (APIENTRYP PFNGLREADBUFFERPROC) (GLenum mode);
typedef void (APIENTRYP PFNGLREADPIXELSPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
typedef void (APIENTRYP PFNGLGETBOOLEANVPROC) (GLenum pname, GLboolean *params);
typedef void (APIENTRYP PFNGLGETDOUBLEVPROC) (GLenum pname, GLdouble *params);
typedef GLenum (APIENTRYP PFNGLGETERRORPROC) (void);
typedef void (APIENTRYP PFNGLGETFLOATVPROC) (GLenum pname, GLfloat *params);
typedef void (APIENTRYP PFNGLGETINTEGERVPROC) (GLenum pname, GLint *params);
typedef const GLubyte * (APIENTRYP PFNGLGETSTRINGPROC) (GLenum name);
typedef void (APIENTRYP PFNGLGETTEXIMAGEPROC) (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
typedef void (APIENTRYP PFNGLGETTEXPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (APIENTRYP PFNGLGETTEXPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (APIENTRYP PFNGLGETTEXLEVELPARAMETERFVPROC) (GLenum target, GLint level, GLenum pname, GLfloat *params);
typedef void (APIENTRYP PFNGLGETTEXLEVELPARAMETERIVPROC) (GLenum target, GLint level, GLenum pname, GLint *params);
typedef GLboolean (APIENTRYP PFNGLISENABLEDPROC) (GLenum cap);
typedef void (APIENTRYP PFNGLDEPTHRANGEPROC) (GLclampd near, GLclampd far);
typedef void (APIENTRYP PFNGLVIEWPORTPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
#endif

#ifndef GL_VERSION_1_1
#define GL_VERSION_1_1 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glDrawArrays (GLenum mode, GLint first, GLsizei count);
GLAPI void APIENTRY glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
GLAPI void APIENTRY glPolygonOffset (GLfloat factor, GLfloat units);
GLAPI void APIENTRY glCopyTexImage1D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
GLAPI void APIENTRY glCopyTexImage2D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
GLAPI void APIENTRY glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
GLAPI void APIENTRY glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
GLAPI void APIENTRY glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
GLAPI void APIENTRY glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
GLAPI void APIENTRY glBindTexture (GLenum target, GLuint texture);
GLAPI void APIENTRY glDeleteTextures (GLsizei n, const GLuint *textures);
GLAPI void APIENTRY glGenTextures (GLsizei n, GLuint *textures);
GLAPI GLboolean APIENTRY glIsTexture (GLuint texture);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLDRAWARRAYSPROC) (GLenum mode, GLint first, GLsizei count);
typedef void (APIENTRYP PFNGLDRAWELEMENTSPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
typedef void (APIENTRYP PFNGLPOLYGONOFFSETPROC) (GLfloat factor, GLfloat units);
typedef void (APIENTRYP PFNGLCOPYTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (APIENTRYP PFNGLCOPYTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (APIENTRYP PFNGLTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (APIENTRYP PFNGLTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (APIENTRYP PFNGLBINDTEXTUREPROC) (GLenum target, GLuint texture);
typedef void (APIENTRYP PFNGLDELETETEXTURESPROC) (GLsizei n, const GLuint *textures);
typedef void (APIENTRYP PFNGLGENTEXTURESPROC) (GLsizei n, GLuint *textures);
typedef GLboolean (APIENTRYP PFNGLISTEXTUREPROC) (GLuint texture);
#endif

#ifndef GL_VERSION_1_2
#define GL_VERSION_1_2 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glBlendColor (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
GLAPI void APIENTRY glBlendEquation (GLenum mode);
GLAPI void APIENTRY glDrawRangeElements (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
GLAPI void APIENTRY glTexImage3D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
GLAPI void APIENTRY glTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
GLAPI void APIENTRY glCopyTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLBLENDCOLORPROC) (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
typedef void (APIENTRYP PFNGLBLENDEQUATIONPROC) (GLenum mode);
typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
typedef void (APIENTRYP PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (APIENTRYP PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
#endif

#ifndef GL_VERSION_1_3
#define GL_VERSION_1_3 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glActiveTexture (GLenum texture);
GLAPI void APIENTRY glSampleCoverage (GLclampf value, GLboolean invert);
GLAPI void APIENTRY glCompressedTexImage3D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
GLAPI void APIENTRY glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
GLAPI void APIENTRY glCompressedTexImage1D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
GLAPI void APIENTRY glCompressedTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
GLAPI void APIENTRY glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
GLAPI void APIENTRY glCompressedTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
GLAPI void APIENTRY glGetCompressedTexImage (GLenum target, GLint level, GLvoid *img);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLACTIVETEXTUREPROC) (GLenum texture);
typedef void (APIENTRYP PFNGLSAMPLECOVERAGEPROC) (GLclampf value, GLboolean invert);
typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (APIENTRYP PFNGLGETCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint level, GLvoid *img);
#endif

#ifndef GL_VERSION_1_4
#define GL_VERSION_1_4 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glBlendFuncSeparate (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
GLAPI void APIENTRY glMultiDrawArrays (GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
GLAPI void APIENTRY glMultiDrawElements (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei drawcount);
GLAPI void APIENTRY glPointParameterf (GLenum pname, GLfloat param);
GLAPI void APIENTRY glPointParameterfv (GLenum pname, const GLfloat *params);
GLAPI void APIENTRY glPointParameteri (GLenum pname, GLint param);
GLAPI void APIENTRY glPointParameteriv (GLenum pname, const GLint *params);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei drawcount);
typedef void (APIENTRYP PFNGLPOINTPARAMETERFPROC) (GLenum pname, GLfloat param);
typedef void (APIENTRYP PFNGLPOINTPARAMETERFVPROC) (GLenum pname, const GLfloat *params);
typedef void (APIENTRYP PFNGLPOINTPARAMETERIPROC) (GLenum pname, GLint param);
typedef void (APIENTRYP PFNGLPOINTPARAMETERIVPROC) (GLenum pname, const GLint *params);
#endif

#ifndef GL_VERSION_1_5
#define GL_VERSION_1_5 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glGenQueries (GLsizei n, GLuint *ids);
GLAPI void APIENTRY glDeleteQueries (GLsizei n, const GLuint *ids);
GLAPI GLboolean APIENTRY glIsQuery (GLuint id);
GLAPI void APIENTRY glBeginQuery (GLenum target, GLuint id);
GLAPI void APIENTRY glEndQuery (GLenum target);
GLAPI void APIENTRY glGetQueryiv (GLenum target, GLenum pname, GLint *params);
GLAPI void APIENTRY glGetQueryObjectiv (GLuint id, GLenum pname, GLint *params);
GLAPI void APIENTRY glGetQueryObjectuiv (GLuint id, GLenum pname, GLuint *params);
GLAPI void APIENTRY glBindBuffer (GLenum target, GLuint buffer);
GLAPI void APIENTRY glDeleteBuffers (GLsizei n, const GLuint *buffers);
GLAPI void APIENTRY glGenBuffers (GLsizei n, GLuint *buffers);
GLAPI GLboolean APIENTRY glIsBuffer (GLuint buffer);
GLAPI void APIENTRY glBufferData (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
GLAPI void APIENTRY glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
GLAPI void APIENTRY glGetBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
GLAPI GLvoid* APIENTRY glMapBuffer (GLenum target, GLenum access);
GLAPI GLboolean APIENTRY glUnmapBuffer (GLenum target);
GLAPI void APIENTRY glGetBufferParameteriv (GLenum target, GLenum pname, GLint *params);
GLAPI void APIENTRY glGetBufferPointerv (GLenum target, GLenum pname, GLvoid* *params);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLGENQUERIESPROC) (GLsizei n, GLuint *ids);
typedef void (APIENTRYP PFNGLDELETEQUERIESPROC) (GLsizei n, const GLuint *ids);
typedef GLboolean (APIENTRYP PFNGLISQUERYPROC) (GLuint id);
typedef void (APIENTRYP PFNGLBEGINQUERYPROC) (GLenum target, GLuint id);
typedef void (APIENTRYP PFNGLENDQUERYPROC) (GLenum target);
typedef void (APIENTRYP PFNGLGETQUERYIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (APIENTRYP PFNGLGETQUERYOBJECTIVPROC) (GLuint id, GLenum pname, GLint *params);
typedef void (APIENTRYP PFNGLGETQUERYOBJECTUIVPROC) (GLuint id, GLenum pname, GLuint *params);
typedef void (APIENTRYP PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);
typedef void (APIENTRYP PFNGLDELETEBUFFERSPROC) (GLsizei n, const GLuint *buffers);
typedef void (APIENTRYP PFNGLGENBUFFERSPROC) (GLsizei n, GLuint *buffers);
typedef GLboolean (APIENTRYP PFNGLISBUFFERPROC) (GLuint buffer);
typedef void (APIENTRYP PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
typedef void (APIENTRYP PFNGLBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
typedef void (APIENTRYP PFNGLGETBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
typedef GLvoid* (APIENTRYP PFNGLMAPBUFFERPROC) (GLenum target, GLenum access);
typedef GLboolean (APIENTRYP PFNGLUNMAPBUFFERPROC) (GLenum target);
typedef void (APIENTRYP PFNGLGETBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (APIENTRYP PFNGLGETBUFFERPOINTERVPROC) (GLenum target, GLenum pname, GLvoid* *params);
#endif

#ifndef GL_VERSION_2_0
#define GL_VERSION_2_0 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glBlendEquationSeparate (GLenum modeRGB, GLenum modeAlpha);
GLAPI void APIENTRY glDrawBuffers (GLsizei n, const GLenum *bufs);
GLAPI void APIENTRY glStencilOpSeparate (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
GLAPI void APIENTRY glStencilFuncSeparate (GLenum face, GLenum func, GLint ref, GLuint mask);
GLAPI void APIENTRY glStencilMaskSeparate (GLenum face, GLuint mask);
GLAPI void APIENTRY glAttachShader (GLuint program, GLuint shader);
GLAPI void APIENTRY glBindAttribLocation (GLuint program, GLuint index, const GLchar *name);
GLAPI void APIENTRY glCompileShader (GLuint shader);
GLAPI GLuint APIENTRY glCreateProgram (void);
GLAPI GLuint APIENTRY glCreateShader (GLenum type);
GLAPI void APIENTRY glDeleteProgram (GLuint program);
GLAPI void APIENTRY glDeleteShader (GLuint shader);
GLAPI void APIENTRY glDetachShader (GLuint program, GLuint shader);
GLAPI void APIENTRY glDisableVertexAttribArray (GLuint index);
GLAPI void APIENTRY glEnableVertexAttribArray (GLuint index);
GLAPI void APIENTRY glGetActiveAttrib (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
GLAPI void APIENTRY glGetActiveUniform (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
GLAPI void APIENTRY glGetAttachedShaders (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
GLAPI GLint APIENTRY glGetAttribLocation (GLuint program, const GLchar *name);
GLAPI void APIENTRY glGetProgramiv (GLuint program, GLenum pname, GLint *params);
GLAPI void APIENTRY glGetProgramInfoLog (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
GLAPI void APIENTRY glGetShaderiv (GLuint shader, GLenum pname, GLint *params);
GLAPI void APIENTRY glGetShaderInfoLog (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
GLAPI void APIENTRY glGetShaderSource (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
GLAPI GLint APIENTRY glGetUniformLocation (GLuint program, const GLchar *name);
GLAPI void APIENTRY glGetUniformfv (GLuint program, GLint location, GLfloat *params);
GLAPI void APIENTRY glGetUniformiv (GLuint program, GLint location, GLint *params);
GLAPI void APIENTRY glGetVertexAttribdv (GLuint index, GLenum pname, GLdouble *params);
GLAPI void APIENTRY glGetVertexAttribfv (GLuint index, GLenum pname, GLfloat *params);
GLAPI void APIENTRY glGetVertexAttribiv (GLuint index, GLenum pname, GLint *params);
GLAPI void APIENTRY glGetVertexAttribPointerv (GLuint index, GLenum pname, GLvoid* *pointer);
GLAPI GLboolean APIENTRY glIsProgram (GLuint program);
GLAPI GLboolean APIENTRY glIsShader (GLuint shader);
GLAPI void APIENTRY glLinkProgram (GLuint program);
GLAPI void APIENTRY glShaderSource (GLuint shader, GLsizei count, const GLchar* const *string, const GLint *length);
GLAPI void APIENTRY glUseProgram (GLuint program);
GLAPI void APIENTRY glUniform1f (GLint location, GLfloat v0);
GLAPI void APIENTRY glUniform2f (GLint location, GLfloat v0, GLfloat v1);
GLAPI void APIENTRY glUniform3f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
GLAPI void APIENTRY glUniform4f (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
GLAPI void APIENTRY glUniform1i (GLint location, GLint v0);
GLAPI void APIENTRY glUniform2i (GLint location, GLint v0, GLint v1);
GLAPI void APIENTRY glUniform3i (GLint location, GLint v0, GLint v1, GLint v2);
GLAPI void APIENTRY glUniform4i (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
GLAPI void APIENTRY glUniform1fv (GLint location, GLsizei count, const GLfloat *value);
GLAPI void APIENTRY glUniform2fv (GLint location, GLsizei count, const GLfloat *value);
GLAPI void APIENTRY glUniform3fv (GLint location, GLsizei count, const GLfloat *value);
GLAPI void APIENTRY glUniform4fv (GLint location, GLsizei count, const GLfloat *value);
GLAPI void APIENTRY glUniform1iv (GLint location, GLsizei count, const GLint *value);
GLAPI void APIENTRY glUniform2iv (GLint location, GLsizei count, const GLint *value);
GLAPI void APIENTRY glUniform3iv (GLint location, GLsizei count, const GLint *value);
GLAPI void APIENTRY glUniform4iv (GLint location, GLsizei count, const GLint *value);
GLAPI void APIENTRY glUniformMatrix2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI void APIENTRY glUniformMatrix3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI void APIENTRY glUniformMatrix4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI void APIENTRY glValidateProgram (GLuint program);
GLAPI void APIENTRY glVertexAttrib1d (GLuint index, GLdouble x);
GLAPI void APIENTRY glVertexAttrib1dv (GLuint index, const GLdouble *v);
GLAPI void APIENTRY glVertexAttrib1f (GLuint index, GLfloat x);
GLAPI void APIENTRY glVertexAttrib1fv (GLuint index, const GLfloat *v);
GLAPI void APIENTRY glVertexAttrib1s (GLuint index, GLshort x);
GLAPI void APIENTRY glVertexAttrib1sv (GLuint index, const GLshort *v);
GLAPI void APIENTRY glVertexAttrib2d (GLuint index, GLdouble x, GLdouble y);
GLAPI void APIENTRY glVertexAttrib2dv (GLuint index, const GLdouble *v);
GLAPI void APIENTRY glVertexAttrib2f (GLuint index, GLfloat x, GLfloat y);
GLAPI void APIENTRY glVertexAttrib2fv (GLuint index, const GLfloat *v);
GLAPI void APIENTRY glVertexAttrib2s (GLuint index, GLshort x, GLshort y);
GLAPI void APIENTRY glVertexAttrib2sv (GLuint index, const GLshort *v);
GLAPI void APIENTRY glVertexAttrib3d (GLuint index, GLdouble x, GLdouble y, GLdouble z);
GLAPI void APIENTRY glVertexAttrib3dv (GLuint index, const GLdouble *v);
GLAPI void APIENTRY glVertexAttrib3f (GLuint index, GLfloat x, GLfloat y, GLfloat z);
GLAPI void APIENTRY glVertexAttrib3fv (GLuint index, const GLfloat *v);
GLAPI void APIENTRY glVertexAttrib3s (GLuint index, GLshort x, GLshort y, GLshort z);
GLAPI void APIENTRY glVertexAttrib3sv (GLuint index, const GLshort *v);
GLAPI void APIENTRY glVertexAttrib4Nbv (GLuint index, const GLbyte *v);
GLAPI void APIENTRY glVertexAttrib4Niv (GLuint index, const GLint *v);
GLAPI void APIENTRY glVertexAttrib4Nsv (GLuint index, const GLshort *v);
GLAPI void APIENTRY glVertexAttrib4Nub (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
GLAPI void APIENTRY glVertexAttrib4Nubv (GLuint index, const GLubyte *v);
GLAPI void APIENTRY glVertexAttrib4Nuiv (GLuint index, const GLuint *v);
GLAPI void APIENTRY glVertexAttrib4Nusv (GLuint index, const GLushort *v);
GLAPI void APIENTRY glVertexAttrib4bv (GLuint index, const GLbyte *v);
GLAPI void APIENTRY glVertexAttrib4d (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
GLAPI void APIENTRY glVertexAttrib4dv (GLuint index, const GLdouble *v);
GLAPI void APIENTRY glVertexAttrib4f (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
GLAPI void APIENTRY glVertexAttrib4fv (GLuint index, const GLfloat *v);
GLAPI void APIENTRY glVertexAttrib4iv (GLuint index, const GLint *v);
GLAPI void APIENTRY glVertexAttrib4s (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
GLAPI void APIENTRY glVertexAttrib4sv (GLuint index, const GLshort *v);
GLAPI void APIENTRY glVertexAttrib4ubv (GLuint index, const GLubyte *v);
GLAPI void APIENTRY glVertexAttrib4uiv (GLuint index, const GLuint *v);
GLAPI void APIENTRY glVertexAttrib4usv (GLuint index, const GLushort *v);
GLAPI void APIENTRY glVertexAttribPointer (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLBLENDEQUATIONSEPARATEPROC) (GLenum modeRGB, GLenum modeAlpha);
typedef void (APIENTRYP PFNGLDRAWBUFFERSPROC) (GLsizei n, const GLenum *bufs);
typedef void (APIENTRYP PFNGLSTENCILOPSEPARATEPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void (APIENTRYP PFNGLSTENCILFUNCSEPARATEPROC) (GLenum face, GLenum func, GLint ref, GLuint mask);
typedef void (APIENTRYP PFNGLSTENCILMASKSEPARATEPROC) (GLenum face, GLuint mask);
typedef void (APIENTRYP PFNGLATTACHSHADERPROC) (GLuint program, GLuint shader);
typedef void (APIENTRYP PFNGLBINDATTRIBLOCATIONPROC) (GLuint program, GLuint index, const GLchar *name);
typedef void (APIENTRYP PFNGLCOMPILESHADERPROC) (GLuint shader);
typedef GLuint (APIENTRYP PFNGLCREATEPROGRAMPROC) (void);
typedef GLuint (APIENTRYP PFNGLCREATESHADERPROC) (GLenum type);
typedef void (APIENTRYP PFNGLDELETEPROGRAMPROC) (GLuint program);
typedef void (APIENTRYP PFNGLDELETESHADERPROC) (GLuint shader);
typedef void (APIENTRYP PFNGLDETACHSHADERPROC) (GLuint program, GLuint shader);
typedef void (APIENTRYP PFNGLDISABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void (APIENTRYP PFNGLENABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void (APIENTRYP PFNGLGETACTIVEATTRIBPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
typedef void (APIENTRYP PFNGLGETATTACHEDSHADERSPROC) (GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
typedef GLint (APIENTRYP PFNGLGETATTRIBLOCATIONPROC) (GLuint program, const GLchar *name);
typedef void (APIENTRYP PFNGLGETPROGRAMIVPROC) (GLuint program, GLenum pname, GLint *params);
typedef void (APIENTRYP PFNGLGETPROGRAMINFOLOGPROC) (GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
typedef void (APIENTRYP PFNGLGETSHADERIVPROC) (GLuint shader, GLenum pname, GLint *params);
typedef void (APIENTRYP PFNGLGETSHADERINFOLOGPROC) (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
typedef void (APIENTRYP PFNGLGETSHADERSOURCEPROC) (GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
typedef GLint (APIENTRYP PFNGLGETUNIFORMLOCATIONPROC) (GLuint program, const GLchar *name);
typedef void (APIENTRYP PFNGLGETUNIFORMFVPROC) (GLuint program, GLint location, GLfloat *params);
typedef void (APIENTRYP PFNGLGETUNIFORMIVPROC) (GLuint program, GLint location, GLint *params);
typedef void (APIENTRYP PFNGLGETVERTEXATTRIBDVPROC) (GLuint index, GLenum pname, GLdouble *params);
typedef void (APIENTRYP PFNGLGETVERTEXATTRIBFVPROC) (GLuint index, GLenum pname, GLfloat *params);
typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIVPROC) (GLuint index, GLenum pname, GLint *params);
typedef void (APIENTRYP PFNGLGETVERTEXATTRIBPOINTERVPROC) (GLuint index, GLenum pname, GLvoid* *pointer);
typedef GLboolean (APIENTRYP PFNGLISPROGRAMPROC) (GLuint program);
typedef GLboolean (APIENTRYP PFNGLISSHADERPROC) (GLuint shader);
typedef void (APIENTRYP PFNGLLINKPROGRAMPROC) (GLuint program);
typedef void (APIENTRYP PFNGLSHADERSOURCEPROC) (GLuint shader, GLsizei count, const GLchar* const *string, const GLint *length);
typedef void (APIENTRYP PFNGLUSEPROGRAMPROC) (GLuint program);
typedef void (APIENTRYP PFNGLUNIFORM1FPROC) (GLint location, GLfloat v0);
typedef void (APIENTRYP PFNGLUNIFORM2FPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void (APIENTRYP PFNGLUNIFORM3FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (APIENTRYP PFNGLUNIFORM4FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (APIENTRYP PFNGLUNIFORM1IPROC) (GLint location, GLint v0);
typedef void (APIENTRYP PFNGLUNIFORM2IPROC) (GLint location, GLint v0, GLint v1);
typedef void (APIENTRYP PFNGLUNIFORM3IPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void (APIENTRYP PFNGLUNIFORM4IPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (APIENTRYP PFNGLUNIFORM1FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void (APIENTRYP PFNGLUNIFORM2FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void (APIENTRYP PFNGLUNIFORM3FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void (APIENTRYP PFNGLUNIFORM4FVPROC) (GLint location, GLsizei count, const GLfloat *value);
typedef void (APIENTRYP PFNGLUNIFORM1IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void (APIENTRYP PFNGLUNIFORM2IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void (APIENTRYP PFNGLUNIFORM3IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void (APIENTRYP PFNGLUNIFORM4IVPROC) (GLint location, GLsizei count, const GLint *value);
typedef void (APIENTRYP PFNGLUNIFORMMATRIX2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (APIENTRYP PFNGLUNIFORMMATRIX3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (APIENTRYP PFNGLUNIFORMMATRIX4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (APIENTRYP PFNGLVALIDATEPROGRAMPROC) (GLuint program);
typedef void (APIENTRYP PFNGLVERTEXATTRIB1DPROC) (GLuint index, GLdouble x);
typedef void (APIENTRYP PFNGLVERTEXATTRIB1DVPROC) (GLuint index, const GLdouble *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB1FPROC) (GLuint index, GLfloat x);
typedef void (APIENTRYP PFNGLVERTEXATTRIB1FVPROC) (GLuint index, const GLfloat *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB1SPROC) (GLuint index, GLshort x);
typedef void (APIENTRYP PFNGLVERTEXATTRIB1SVPROC) (GLuint index, const GLshort *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (APIENTRYP PFNGLVERTEXATTRIB2DVPROC) (GLuint index, const GLdouble *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB2FPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void (APIENTRYP PFNGLVERTEXATTRIB2FVPROC) (GLuint index, const GLfloat *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB2SPROC) (GLuint index, GLshort x, GLshort y);
typedef void (APIENTRYP PFNGLVERTEXATTRIB2SVPROC) (GLuint index, const GLshort *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (APIENTRYP PFNGLVERTEXATTRIB3DVPROC) (GLuint index, const GLdouble *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB3FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (APIENTRYP PFNGLVERTEXATTRIB3FVPROC) (GLuint index, const GLfloat *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB3SPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (APIENTRYP PFNGLVERTEXATTRIB3SVPROC) (GLuint index, const GLshort *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB4NBVPROC) (GLuint index, const GLbyte *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB4NIVPROC) (GLuint index, const GLint *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB4NSVPROC) (GLuint index, const GLshort *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUBVPROC) (GLuint index, const GLubyte *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUIVPROC) (GLuint index, const GLuint *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB4NUSVPROC) (GLuint index, const GLushort *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB4BVPROC) (GLuint index, const GLbyte *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (APIENTRYP PFNGLVERTEXATTRIB4DVPROC) (GLuint index, const GLdouble *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB4FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (APIENTRYP PFNGLVERTEXATTRIB4FVPROC) (GLuint index, const GLfloat *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB4IVPROC) (GLuint index, const GLint *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB4SPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (APIENTRYP PFNGLVERTEXATTRIB4SVPROC) (GLuint index, const GLshort *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB4UBVPROC) (GLuint index, const GLubyte *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB4UIVPROC) (GLuint index, const GLuint *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIB4USVPROC) (GLuint index, const GLushort *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
#endif

#ifndef GL_VERSION_2_1
#define GL_VERSION_2_1 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glUniformMatrix2x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI void APIENTRY glUniformMatrix3x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI void APIENTRY glUniformMatrix2x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI void APIENTRY glUniformMatrix4x2fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI void APIENTRY glUniformMatrix3x4fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI void APIENTRY glUniformMatrix4x3fv (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLUNIFORMMATRIX2X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (APIENTRYP PFNGLUNIFORMMATRIX3X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (APIENTRYP PFNGLUNIFORMMATRIX2X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (APIENTRYP PFNGLUNIFORMMATRIX4X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (APIENTRYP PFNGLUNIFORMMATRIX3X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (APIENTRYP PFNGLUNIFORMMATRIX4X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
#endif

#ifndef GL_VERSION_3_0
#define GL_VERSION_3_0 1
/* OpenGL 3.0 also reuses entry points from these extensions: */
/* ARB_framebuffer_object */
/* ARB_map_buffer_range */
/* ARB_vertex_array_object */
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glColorMaski (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
GLAPI void APIENTRY glGetBooleani_v (GLenum target, GLuint index, GLboolean *data);
GLAPI void APIENTRY glGetIntegeri_v (GLenum target, GLuint index, GLint *data);
GLAPI void APIENTRY glEnablei (GLenum target, GLuint index);
GLAPI void APIENTRY glDisablei (GLenum target, GLuint index);
GLAPI GLboolean APIENTRY glIsEnabledi (GLenum target, GLuint index);
GLAPI void APIENTRY glBeginTransformFeedback (GLenum primitiveMode);
GLAPI void APIENTRY glEndTransformFeedback (void);
GLAPI void APIENTRY glBindBufferRange (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
GLAPI void APIENTRY glBindBufferBase (GLenum target, GLuint index, GLuint buffer);
GLAPI void APIENTRY glTransformFeedbackVaryings (GLuint program, GLsizei count, const GLchar* const *varyings, GLenum bufferMode);
GLAPI void APIENTRY glGetTransformFeedbackVarying (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
GLAPI void APIENTRY glClampColor (GLenum target, GLenum clamp);
GLAPI void APIENTRY glBeginConditionalRender (GLuint id, GLenum mode);
GLAPI void APIENTRY glEndConditionalRender (void);
GLAPI void APIENTRY glVertexAttribIPointer (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
GLAPI void APIENTRY glGetVertexAttribIiv (GLuint index, GLenum pname, GLint *params);
GLAPI void APIENTRY glGetVertexAttribIuiv (GLuint index, GLenum pname, GLuint *params);
GLAPI void APIENTRY glVertexAttribI1i (GLuint index, GLint x);
GLAPI void APIENTRY glVertexAttribI2i (GLuint index, GLint x, GLint y);
GLAPI void APIENTRY glVertexAttribI3i (GLuint index, GLint x, GLint y, GLint z);
GLAPI void APIENTRY glVertexAttribI4i (GLuint index, GLint x, GLint y, GLint z, GLint w);
GLAPI void APIENTRY glVertexAttribI1ui (GLuint index, GLuint x);
GLAPI void APIENTRY glVertexAttribI2ui (GLuint index, GLuint x, GLuint y);
GLAPI void APIENTRY glVertexAttribI3ui (GLuint index, GLuint x, GLuint y, GLuint z);
GLAPI void APIENTRY glVertexAttribI4ui (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
GLAPI void APIENTRY glVertexAttribI1iv (GLuint index, const GLint *v);
GLAPI void APIENTRY glVertexAttribI2iv (GLuint index, const GLint *v);
GLAPI void APIENTRY glVertexAttribI3iv (GLuint index, const GLint *v);
GLAPI void APIENTRY glVertexAttribI4iv (GLuint index, const GLint *v);
GLAPI void APIENTRY glVertexAttribI1uiv (GLuint index, const GLuint *v);
GLAPI void APIENTRY glVertexAttribI2uiv (GLuint index, const GLuint *v);
GLAPI void APIENTRY glVertexAttribI3uiv (GLuint index, const GLuint *v);
GLAPI void APIENTRY glVertexAttribI4uiv (GLuint index, const GLuint *v);
GLAPI void APIENTRY glVertexAttribI4bv (GLuint index, const GLbyte *v);
GLAPI void APIENTRY glVertexAttribI4sv (GLuint index, const GLshort *v);
GLAPI void APIENTRY glVertexAttribI4ubv (GLuint index, const GLubyte *v);
GLAPI void APIENTRY glVertexAttribI4usv (GLuint index, const GLushort *v);
GLAPI void APIENTRY glGetUniformuiv (GLuint program, GLint location, GLuint *params);
GLAPI void APIENTRY glBindFragDataLocation (GLuint program, GLuint color, const GLchar *name);
GLAPI GLint APIENTRY glGetFragDataLocation (GLuint program, const GLchar *name);
GLAPI void APIENTRY glUniform1ui (GLint location, GLuint v0);
GLAPI void APIENTRY glUniform2ui (GLint location, GLuint v0, GLuint v1);
GLAPI void APIENTRY glUniform3ui (GLint location, GLuint v0, GLuint v1, GLuint v2);
GLAPI void APIENTRY glUniform4ui (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
GLAPI void APIENTRY glUniform1uiv (GLint location, GLsizei count, const GLuint *value);
GLAPI void APIENTRY glUniform2uiv (GLint location, GLsizei count, const GLuint *value);
GLAPI void APIENTRY glUniform3uiv (GLint location, GLsizei count, const GLuint *value);
GLAPI void APIENTRY glUniform4uiv (GLint location, GLsizei count, const GLuint *value);
GLAPI void APIENTRY glTexParameterIiv (GLenum target, GLenum pname, const GLint *params);
GLAPI void APIENTRY glTexParameterIuiv (GLenum target, GLenum pname, const GLuint *params);
GLAPI void APIENTRY glGetTexParameterIiv (GLenum target, GLenum pname, GLint *params);
GLAPI void APIENTRY glGetTexParameterIuiv (GLenum target, GLenum pname, GLuint *params);
GLAPI void APIENTRY glClearBufferiv (GLenum buffer, GLint drawbuffer, const GLint *value);
GLAPI void APIENTRY glClearBufferuiv (GLenum buffer, GLint drawbuffer, const GLuint *value);
GLAPI void APIENTRY glClearBufferfv (GLenum buffer, GLint drawbuffer, const GLfloat *value);
GLAPI void APIENTRY glClearBufferfi (GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
GLAPI const GLubyte * APIENTRY glGetStringi (GLenum name, GLuint index);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLCOLORMASKIPROC) (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void (APIENTRYP PFNGLGETBOOLEANI_VPROC) (GLenum target, GLuint index, GLboolean *data);
typedef void (APIENTRYP PFNGLGETINTEGERI_VPROC) (GLenum target, GLuint index, GLint *data);
typedef void (APIENTRYP PFNGLENABLEIPROC) (GLenum target, GLuint index);
typedef void (APIENTRYP PFNGLDISABLEIPROC) (GLenum target, GLuint index);
typedef GLboolean (APIENTRYP PFNGLISENABLEDIPROC) (GLenum target, GLuint index);
typedef void (APIENTRYP PFNGLBEGINTRANSFORMFEEDBACKPROC) (GLenum primitiveMode);
typedef void (APIENTRYP PFNGLENDTRANSFORMFEEDBACKPROC) (void);
typedef void (APIENTRYP PFNGLBINDBUFFERRANGEPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (APIENTRYP PFNGLBINDBUFFERBASEPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void (APIENTRYP PFNGLTRANSFORMFEEDBACKVARYINGSPROC) (GLuint program, GLsizei count, const GLchar* const *varyings, GLenum bufferMode);
typedef void (APIENTRYP PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
typedef void (APIENTRYP PFNGLCLAMPCOLORPROC) (GLenum target, GLenum clamp);
typedef void (APIENTRYP PFNGLBEGINCONDITIONALRENDERPROC) (GLuint id, GLenum mode);
typedef void (APIENTRYP PFNGLENDCONDITIONALRENDERPROC) (void);
typedef void (APIENTRYP PFNGLVERTEXATTRIBIPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIIVPROC) (GLuint index, GLenum pname, GLint *params);
typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIUIVPROC) (GLuint index, GLenum pname, GLuint *params);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI1IPROC) (GLuint index, GLint x);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI2IPROC) (GLuint index, GLint x, GLint y);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI3IPROC) (GLuint index, GLint x, GLint y, GLint z);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI4IPROC) (GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI1UIPROC) (GLuint index, GLuint x);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI2UIPROC) (GLuint index, GLuint x, GLuint y);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI3UIPROC) (GLuint index, GLuint x, GLuint y, GLuint z);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI4UIPROC) (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI1IVPROC) (GLuint index, const GLint *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI2IVPROC) (GLuint index, const GLint *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI3IVPROC) (GLuint index, const GLint *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI4IVPROC) (GLuint index, const GLint *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI1UIVPROC) (GLuint index, const GLuint *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI2UIVPROC) (GLuint index, const GLuint *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI3UIVPROC) (GLuint index, const GLuint *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI4UIVPROC) (GLuint index, const GLuint *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI4BVPROC) (GLuint index, const GLbyte *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI4SVPROC) (GLuint index, const GLshort *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI4UBVPROC) (GLuint index, const GLubyte *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIBI4USVPROC) (GLuint index, const GLushort *v);
typedef void (APIENTRYP PFNGLGETUNIFORMUIVPROC) (GLuint program, GLint location, GLuint *params);
typedef void (APIENTRYP PFNGLBINDFRAGDATALOCATIONPROC) (GLuint program, GLuint color, const GLchar *name);
typedef GLint (APIENTRYP PFNGLGETFRAGDATALOCATIONPROC) (GLuint program, const GLchar *name);
typedef void (APIENTRYP PFNGLUNIFORM1UIPROC) (GLint location, GLuint v0);
typedef void (APIENTRYP PFNGLUNIFORM2UIPROC) (GLint location, GLuint v0, GLuint v1);
typedef void (APIENTRYP PFNGLUNIFORM3UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (APIENTRYP PFNGLUNIFORM4UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (APIENTRYP PFNGLUNIFORM1UIVPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (APIENTRYP PFNGLUNIFORM2UIVPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (APIENTRYP PFNGLUNIFORM3UIVPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (APIENTRYP PFNGLUNIFORM4UIVPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (APIENTRYP PFNGLTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (APIENTRYP PFNGLTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, const GLuint *params);
typedef void (APIENTRYP PFNGLGETTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (APIENTRYP PFNGLGETTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, GLuint *params);
typedef void (APIENTRYP PFNGLCLEARBUFFERIVPROC) (GLenum buffer, GLint drawbuffer, const GLint *value);
typedef void (APIENTRYP PFNGLCLEARBUFFERUIVPROC) (GLenum buffer, GLint drawbuffer, const GLuint *value);
typedef void (APIENTRYP PFNGLCLEARBUFFERFVPROC) (GLenum buffer, GLint drawbuffer, const GLfloat *value);
typedef void (APIENTRYP PFNGLCLEARBUFFERFIPROC) (GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
typedef const GLubyte * (APIENTRYP PFNGLGETSTRINGIPROC) (GLenum name, GLuint index);
#endif

#ifndef GL_VERSION_3_1
#define GL_VERSION_3_1 1
/* OpenGL 3.1 also reuses entry points from these extensions: */
/* ARB_copy_buffer */
/* ARB_uniform_buffer_object */
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glDrawArraysInstanced (GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
GLAPI void APIENTRY glDrawElementsInstanced (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei instancecount);
GLAPI void APIENTRY glTexBuffer (GLenum target, GLenum internalformat, GLuint buffer);
GLAPI void APIENTRY glPrimitiveRestartIndex (GLuint index);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLDRAWARRAYSINSTANCEDPROC) (GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei instancecount);
typedef void (APIENTRYP PFNGLTEXBUFFERPROC) (GLenum target, GLenum internalformat, GLuint buffer);
typedef void (APIENTRYP PFNGLPRIMITIVERESTARTINDEXPROC) (GLuint index);
#endif

#ifndef GL_VERSION_3_2
#define GL_VERSION_3_2 1
/* OpenGL 3.2 also reuses entry points from these extensions: */
/* ARB_draw_elements_base_vertex */
/* ARB_provoking_vertex */
/* ARB_sync */
/* ARB_texture_multisample */
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glGetInteger64i_v (GLenum target, GLuint index, GLint64 *data);
GLAPI void APIENTRY glGetBufferParameteri64v (GLenum target, GLenum pname, GLint64 *params);
GLAPI void APIENTRY glFramebufferTexture (GLenum target, GLenum attachment, GLuint texture, GLint level);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLGETINTEGER64I_VPROC) (GLenum target, GLuint index, GLint64 *data);
typedef void (APIENTRYP PFNGLGETBUFFERPARAMETERI64VPROC) (GLenum target, GLenum pname, GLint64 *params);
typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTUREPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
#endif

#ifndef GL_VERSION_3_3
#define GL_VERSION_3_3 1
/* OpenGL 3.3 also reuses entry points from these extensions: */
/* ARB_blend_func_extended */
/* ARB_sampler_objects */
/* ARB_explicit_attrib_location, but it has none */
/* ARB_occlusion_query2 (no entry points) */
/* ARB_shader_bit_encoding (no entry points) */
/* ARB_texture_rgb10_a2ui (no entry points) */
/* ARB_texture_swizzle (no entry points) */
/* ARB_timer_query */
/* ARB_vertex_type_2_10_10_10_rev */
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glVertexAttribDivisor (GLuint index, GLuint divisor);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLVERTEXATTRIBDIVISORPROC) (GLuint index, GLuint divisor);
#endif

#ifndef GL_VERSION_4_0
#define GL_VERSION_4_0 1
/* OpenGL 4.0 also reuses entry points from these extensions: */
/* ARB_texture_query_lod (no entry points) */
/* ARB_draw_indirect */
/* ARB_gpu_shader5 (no entry points) */
/* ARB_gpu_shader_fp64 */
/* ARB_shader_subroutine */
/* ARB_tessellation_shader */
/* ARB_texture_buffer_object_rgb32 (no entry points) */
/* ARB_texture_cube_map_array (no entry points) */
/* ARB_texture_gather (no entry points) */
/* ARB_transform_feedback2 */
/* ARB_transform_feedback3 */
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glMinSampleShading (GLfloat value);
GLAPI void APIENTRY glBlendEquationi (GLuint buf, GLenum mode);
GLAPI void APIENTRY glBlendEquationSeparatei (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
GLAPI void APIENTRY glBlendFunci (GLuint buf, GLenum src, GLenum dst);
GLAPI void APIENTRY glBlendFuncSeparatei (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLMINSAMPLESHADINGPROC) (GLfloat value);
typedef void (APIENTRYP PFNGLBLENDEQUATIONIPROC) (GLuint buf, GLenum mode);
typedef void (APIENTRYP PFNGLBLENDEQUATIONSEPARATEIPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (APIENTRYP PFNGLBLENDFUNCIPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEIPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
#endif

#ifndef GL_VERSION_4_1
#define GL_VERSION_4_1 1
/* OpenGL 4.1 reuses entry points from these extensions: */
/* ARB_ES2_compatibility */
/* ARB_get_program_binary */
/* ARB_separate_shader_objects */
/* ARB_shader_precision (no entry points) */
/* ARB_vertex_attrib_64bit */
/* ARB_viewport_array */
#endif

#ifndef GL_ARB_depth_buffer_float
#define GL_ARB_depth_buffer_float 1
#endif

#ifndef GL_ARB_framebuffer_object
#define GL_ARB_framebuffer_object 1
#ifdef GL3_PROTOTYPES
GLAPI GLboolean APIENTRY glIsRenderbuffer (GLuint renderbuffer);
GLAPI void APIENTRY glBindRenderbuffer (GLenum target, GLuint renderbuffer);
GLAPI void APIENTRY glDeleteRenderbuffers (GLsizei n, const GLuint *renderbuffers);
GLAPI void APIENTRY glGenRenderbuffers (GLsizei n, GLuint *renderbuffers);
GLAPI void APIENTRY glRenderbufferStorage (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
GLAPI void APIENTRY glGetRenderbufferParameteriv (GLenum target, GLenum pname, GLint *params);
GLAPI GLboolean APIENTRY glIsFramebuffer (GLuint framebuffer);
GLAPI void APIENTRY glBindFramebuffer (GLenum target, GLuint framebuffer);
GLAPI void APIENTRY glDeleteFramebuffers (GLsizei n, const GLuint *framebuffers);
GLAPI void APIENTRY glGenFramebuffers (GLsizei n, GLuint *framebuffers);
GLAPI GLenum APIENTRY glCheckFramebufferStatus (GLenum target);
GLAPI void APIENTRY glFramebufferTexture1D (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
GLAPI void APIENTRY glFramebufferTexture2D (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
GLAPI void APIENTRY glFramebufferTexture3D (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
GLAPI void APIENTRY glFramebufferRenderbuffer (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
GLAPI void APIENTRY glGetFramebufferAttachmentParameteriv (GLenum target, GLenum attachment, GLenum pname, GLint *params);
GLAPI void APIENTRY glGenerateMipmap (GLenum target);
GLAPI void APIENTRY glBlitFramebuffer (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
GLAPI void APIENTRY glRenderbufferStorageMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
GLAPI void APIENTRY glFramebufferTextureLayer (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
#endif /* GL3_PROTOTYPES */
typedef GLboolean (APIENTRYP PFNGLISRENDERBUFFERPROC) (GLuint renderbuffer);
typedef void (APIENTRYP PFNGLBINDRENDERBUFFERPROC) (GLenum target, GLuint renderbuffer);
typedef void (APIENTRYP PFNGLDELETERENDERBUFFERSPROC) (GLsizei n, const GLuint *renderbuffers);
typedef void (APIENTRYP PFNGLGENRENDERBUFFERSPROC) (GLsizei n, GLuint *renderbuffers);
typedef void (APIENTRYP PFNGLRENDERBUFFERSTORAGEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (APIENTRYP PFNGLGETRENDERBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef GLboolean (APIENTRYP PFNGLISFRAMEBUFFERPROC) (GLuint framebuffer);
typedef void (APIENTRYP PFNGLBINDFRAMEBUFFERPROC) (GLenum target, GLuint framebuffer);
typedef void (APIENTRYP PFNGLDELETEFRAMEBUFFERSPROC) (GLsizei n, const GLuint *framebuffers);
typedef void (APIENTRYP PFNGLGENFRAMEBUFFERSPROC) (GLsizei n, GLuint *framebuffers);
typedef GLenum (APIENTRYP PFNGLCHECKFRAMEBUFFERSTATUSPROC) (GLenum target);
typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURE1DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURE2DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURE3DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void (APIENTRYP PFNGLFRAMEBUFFERRENDERBUFFERPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (APIENTRYP PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLenum target, GLenum attachment, GLenum pname, GLint *params);
typedef void (APIENTRYP PFNGLGENERATEMIPMAPPROC) (GLenum target);
typedef void (APIENTRYP PFNGLBLITFRAMEBUFFERPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void (APIENTRYP PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTURELAYERPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
#endif

#ifndef GL_ARB_framebuffer_sRGB
#define GL_ARB_framebuffer_sRGB 1
#endif

#ifndef GL_ARB_half_float_vertex
#define GL_ARB_half_float_vertex 1
#endif

#ifndef GL_ARB_map_buffer_range
#define GL_ARB_map_buffer_range 1
#ifdef GL3_PROTOTYPES
GLAPI GLvoid* APIENTRY glMapBufferRange (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
GLAPI void APIENTRY glFlushMappedBufferRange (GLenum target, GLintptr offset, GLsizeiptr length);
#endif /* GL3_PROTOTYPES */
typedef GLvoid* (APIENTRYP PFNGLMAPBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void (APIENTRYP PFNGLFLUSHMAPPEDBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length);
#endif

#ifndef GL_ARB_texture_compression_rgtc
#define GL_ARB_texture_compression_rgtc 1
#endif

#ifndef GL_ARB_texture_rg
#define GL_ARB_texture_rg 1
#endif

#ifndef GL_ARB_vertex_array_object
#define GL_ARB_vertex_array_object 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glBindVertexArray (GLuint array);
GLAPI void APIENTRY glDeleteVertexArrays (GLsizei n, const GLuint *arrays);
GLAPI void APIENTRY glGenVertexArrays (GLsizei n, GLuint *arrays);
GLAPI GLboolean APIENTRY glIsVertexArray (GLuint array);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLBINDVERTEXARRAYPROC) (GLuint array);
typedef void (APIENTRYP PFNGLDELETEVERTEXARRAYSPROC) (GLsizei n, const GLuint *arrays);
typedef void (APIENTRYP PFNGLGENVERTEXARRAYSPROC) (GLsizei n, GLuint *arrays);
typedef GLboolean (APIENTRYP PFNGLISVERTEXARRAYPROC) (GLuint array);
#endif

#ifndef GL_ARB_uniform_buffer_object
#define GL_ARB_uniform_buffer_object 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glGetUniformIndices (GLuint program, GLsizei uniformCount, const GLchar* const *uniformNames, GLuint *uniformIndices);
GLAPI void APIENTRY glGetActiveUniformsiv (GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
GLAPI void APIENTRY glGetActiveUniformName (GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName);
GLAPI GLuint APIENTRY glGetUniformBlockIndex (GLuint program, const GLchar *uniformBlockName);
GLAPI void APIENTRY glGetActiveUniformBlockiv (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
GLAPI void APIENTRY glGetActiveUniformBlockName (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
GLAPI void APIENTRY glUniformBlockBinding (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLGETUNIFORMINDICESPROC) (GLuint program, GLsizei uniformCount, const GLchar* const *uniformNames, GLuint *uniformIndices);
typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMSIVPROC) (GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMNAMEPROC) (GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName);
typedef GLuint (APIENTRYP PFNGLGETUNIFORMBLOCKINDEXPROC) (GLuint program, const GLchar *uniformBlockName);
typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMBLOCKIVPROC) (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
typedef void (APIENTRYP PFNGLUNIFORMBLOCKBINDINGPROC) (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
#endif

#ifndef GL_ARB_copy_buffer
#define GL_ARB_copy_buffer 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glCopyBufferSubData (GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLCOPYBUFFERSUBDATAPROC) (GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
#endif

#ifndef GL_ARB_depth_clamp
#define GL_ARB_depth_clamp 1
#endif

#ifndef GL_ARB_draw_elements_base_vertex
#define GL_ARB_draw_elements_base_vertex 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glDrawElementsBaseVertex (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
GLAPI void APIENTRY glDrawRangeElementsBaseVertex (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
GLAPI void APIENTRY glDrawElementsInstancedBaseVertex (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei instancecount, GLint basevertex);
GLAPI void APIENTRY glMultiDrawElementsBaseVertex (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei drawcount, const GLint *basevertex);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei instancecount, GLint basevertex);
typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei drawcount, const GLint *basevertex);
#endif

#ifndef GL_ARB_fragment_coord_conventions
#define GL_ARB_fragment_coord_conventions 1
#endif

#ifndef GL_ARB_provoking_vertex
#define GL_ARB_provoking_vertex 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glProvokingVertex (GLenum mode);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLPROVOKINGVERTEXPROC) (GLenum mode);
#endif

#ifndef GL_ARB_seamless_cube_map
#define GL_ARB_seamless_cube_map 1
#endif

#ifndef GL_ARB_sync
#define GL_ARB_sync 1
#ifdef GL3_PROTOTYPES
GLAPI GLsync APIENTRY glFenceSync (GLenum condition, GLbitfield flags);
GLAPI GLboolean APIENTRY glIsSync (GLsync sync);
GLAPI void APIENTRY glDeleteSync (GLsync sync);
GLAPI GLenum APIENTRY glClientWaitSync (GLsync sync, GLbitfield flags, GLuint64 timeout);
GLAPI void APIENTRY glWaitSync (GLsync sync, GLbitfield flags, GLuint64 timeout);
GLAPI void APIENTRY glGetInteger64v (GLenum pname, GLint64 *params);
GLAPI void APIENTRY glGetSynciv (GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
#endif /* GL3_PROTOTYPES */
typedef GLsync (APIENTRYP PFNGLFENCESYNCPROC) (GLenum condition, GLbitfield flags);
typedef GLboolean (APIENTRYP PFNGLISSYNCPROC) (GLsync sync);
typedef void (APIENTRYP PFNGLDELETESYNCPROC) (GLsync sync);
typedef GLenum (APIENTRYP PFNGLCLIENTWAITSYNCPROC) (GLsync sync, GLbitfield flags, GLuint64 timeout);
typedef void (APIENTRYP PFNGLWAITSYNCPROC) (GLsync sync, GLbitfield flags, GLuint64 timeout);
typedef void (APIENTRYP PFNGLGETINTEGER64VPROC) (GLenum pname, GLint64 *params);
typedef void (APIENTRYP PFNGLGETSYNCIVPROC) (GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
#endif

#ifndef GL_ARB_texture_multisample
#define GL_ARB_texture_multisample 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glTexImage2DMultisample (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
GLAPI void APIENTRY glTexImage3DMultisample (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
GLAPI void APIENTRY glGetMultisamplefv (GLenum pname, GLuint index, GLfloat *val);
GLAPI void APIENTRY glSampleMaski (GLuint index, GLbitfield mask);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLTEXIMAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (APIENTRYP PFNGLTEXIMAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (APIENTRYP PFNGLGETMULTISAMPLEFVPROC) (GLenum pname, GLuint index, GLfloat *val);
typedef void (APIENTRYP PFNGLSAMPLEMASKIPROC) (GLuint index, GLbitfield mask);
#endif

#ifndef GL_ARB_vertex_array_bgra
#define GL_ARB_vertex_array_bgra 1
#endif

#ifndef GL_ARB_texture_query_lod
#define GL_ARB_texture_query_lod 1
#endif

#ifndef GL_ARB_blend_func_extended
#define GL_ARB_blend_func_extended 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glBindFragDataLocationIndexed (GLuint program, GLuint colorNumber, GLuint index, const GLchar *name);
GLAPI GLint APIENTRY glGetFragDataIndex (GLuint program, const GLchar *name);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) (GLuint program, GLuint colorNumber, GLuint index, const GLchar *name);
typedef GLint (APIENTRYP PFNGLGETFRAGDATAINDEXPROC) (GLuint program, const GLchar *name);
#endif

#ifndef GL_ARB_explicit_attrib_location
#define GL_ARB_explicit_attrib_location 1
#endif

#ifndef GL_ARB_occlusion_query2
#define GL_ARB_occlusion_query2 1
#endif

#ifndef GL_ARB_sampler_objects
#define GL_ARB_sampler_objects 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glGenSamplers (GLsizei count, GLuint *samplers);
GLAPI void APIENTRY glDeleteSamplers (GLsizei count, const GLuint *samplers);
GLAPI GLboolean APIENTRY glIsSampler (GLuint sampler);
GLAPI void APIENTRY glBindSampler (GLuint unit, GLuint sampler);
GLAPI void APIENTRY glSamplerParameteri (GLuint sampler, GLenum pname, GLint param);
GLAPI void APIENTRY glSamplerParameteriv (GLuint sampler, GLenum pname, const GLint *param);
GLAPI void APIENTRY glSamplerParameterf (GLuint sampler, GLenum pname, GLfloat param);
GLAPI void APIENTRY glSamplerParameterfv (GLuint sampler, GLenum pname, const GLfloat *param);
GLAPI void APIENTRY glSamplerParameterIiv (GLuint sampler, GLenum pname, const GLint *param);
GLAPI void APIENTRY glSamplerParameterIuiv (GLuint sampler, GLenum pname, const GLuint *param);
GLAPI void APIENTRY glGetSamplerParameteriv (GLuint sampler, GLenum pname, GLint *params);
GLAPI void APIENTRY glGetSamplerParameterIiv (GLuint sampler, GLenum pname, GLint *params);
GLAPI void APIENTRY glGetSamplerParameterfv (GLuint sampler, GLenum pname, GLfloat *params);
GLAPI void APIENTRY glGetSamplerParameterIuiv (GLuint sampler, GLenum pname, GLuint *params);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLGENSAMPLERSPROC) (GLsizei count, GLuint *samplers);
typedef void (APIENTRYP PFNGLDELETESAMPLERSPROC) (GLsizei count, const GLuint *samplers);
typedef GLboolean (APIENTRYP PFNGLISSAMPLERPROC) (GLuint sampler);
typedef void (APIENTRYP PFNGLBINDSAMPLERPROC) (GLuint unit, GLuint sampler);
typedef void (APIENTRYP PFNGLSAMPLERPARAMETERIPROC) (GLuint sampler, GLenum pname, GLint param);
typedef void (APIENTRYP PFNGLSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, const GLint *param);
typedef void (APIENTRYP PFNGLSAMPLERPARAMETERFPROC) (GLuint sampler, GLenum pname, GLfloat param);
typedef void (APIENTRYP PFNGLSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, const GLfloat *param);
typedef void (APIENTRYP PFNGLSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, const GLint *param);
typedef void (APIENTRYP PFNGLSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, const GLuint *param);
typedef void (APIENTRYP PFNGLGETSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, GLint *params);
typedef void (APIENTRYP PFNGLGETSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, GLint *params);
typedef void (APIENTRYP PFNGLGETSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, GLfloat *params);
typedef void (APIENTRYP PFNGLGETSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, GLuint *params);
#endif

#ifndef GL_ARB_shader_bit_encoding
#define GL_ARB_shader_bit_encoding 1
#endif

#ifndef GL_ARB_texture_rgb10_a2ui
#define GL_ARB_texture_rgb10_a2ui 1
#endif

#ifndef GL_ARB_texture_swizzle
#define GL_ARB_texture_swizzle 1
#endif

#ifndef GL_ARB_timer_query
#define GL_ARB_timer_query 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glQueryCounter (GLuint id, GLenum target);
GLAPI void APIENTRY glGetQueryObjecti64v (GLuint id, GLenum pname, GLint64 *params);
GLAPI void APIENTRY glGetQueryObjectui64v (GLuint id, GLenum pname, GLuint64 *params);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLQUERYCOUNTERPROC) (GLuint id, GLenum target);
typedef void (APIENTRYP PFNGLGETQUERYOBJECTI64VPROC) (GLuint id, GLenum pname, GLint64 *params);
typedef void (APIENTRYP PFNGLGETQUERYOBJECTUI64VPROC) (GLuint id, GLenum pname, GLuint64 *params);
#endif

#ifndef GL_ARB_vertex_type_2_10_10_10_rev
#define GL_ARB_vertex_type_2_10_10_10_rev 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glVertexAttribP1ui (GLuint index, GLenum type, GLboolean normalized, GLuint value);
GLAPI void APIENTRY glVertexAttribP1uiv (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
GLAPI void APIENTRY glVertexAttribP2ui (GLuint index, GLenum type, GLboolean normalized, GLuint value);
GLAPI void APIENTRY glVertexAttribP2uiv (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
GLAPI void APIENTRY glVertexAttribP3ui (GLuint index, GLenum type, GLboolean normalized, GLuint value);
GLAPI void APIENTRY glVertexAttribP3uiv (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
GLAPI void APIENTRY glVertexAttribP4ui (GLuint index, GLenum type, GLboolean normalized, GLuint value);
GLAPI void APIENTRY glVertexAttribP4uiv (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLVERTEXATTRIBP1UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (APIENTRYP PFNGLVERTEXATTRIBP1UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
typedef void (APIENTRYP PFNGLVERTEXATTRIBP2UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (APIENTRYP PFNGLVERTEXATTRIBP2UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
typedef void (APIENTRYP PFNGLVERTEXATTRIBP3UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (APIENTRYP PFNGLVERTEXATTRIBP3UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
typedef void (APIENTRYP PFNGLVERTEXATTRIBP4UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (APIENTRYP PFNGLVERTEXATTRIBP4UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
#endif

#ifndef GL_ARB_draw_indirect
#define GL_ARB_draw_indirect 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glDrawArraysIndirect (GLenum mode, const GLvoid *indirect);
GLAPI void APIENTRY glDrawElementsIndirect (GLenum mode, GLenum type, const GLvoid *indirect);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLDRAWARRAYSINDIRECTPROC) (GLenum mode, const GLvoid *indirect);
typedef void (APIENTRYP PFNGLDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const GLvoid *indirect);
#endif

#ifndef GL_ARB_gpu_shader5
#define GL_ARB_gpu_shader5 1
#endif

#ifndef GL_ARB_gpu_shader_fp64
#define GL_ARB_gpu_shader_fp64 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glUniform1d (GLint location, GLdouble x);
GLAPI void APIENTRY glUniform2d (GLint location, GLdouble x, GLdouble y);
GLAPI void APIENTRY glUniform3d (GLint location, GLdouble x, GLdouble y, GLdouble z);
GLAPI void APIENTRY glUniform4d (GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
GLAPI void APIENTRY glUniform1dv (GLint location, GLsizei count, const GLdouble *value);
GLAPI void APIENTRY glUniform2dv (GLint location, GLsizei count, const GLdouble *value);
GLAPI void APIENTRY glUniform3dv (GLint location, GLsizei count, const GLdouble *value);
GLAPI void APIENTRY glUniform4dv (GLint location, GLsizei count, const GLdouble *value);
GLAPI void APIENTRY glUniformMatrix2dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI void APIENTRY glUniformMatrix3dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI void APIENTRY glUniformMatrix4dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI void APIENTRY glUniformMatrix2x3dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI void APIENTRY glUniformMatrix2x4dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI void APIENTRY glUniformMatrix3x2dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI void APIENTRY glUniformMatrix3x4dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI void APIENTRY glUniformMatrix4x2dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI void APIENTRY glUniformMatrix4x3dv (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI void APIENTRY glGetUniformdv (GLuint program, GLint location, GLdouble *params);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLUNIFORM1DPROC) (GLint location, GLdouble x);
typedef void (APIENTRYP PFNGLUNIFORM2DPROC) (GLint location, GLdouble x, GLdouble y);
typedef void (APIENTRYP PFNGLUNIFORM3DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void (APIENTRYP PFNGLUNIFORM4DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (APIENTRYP PFNGLUNIFORM1DVPROC) (GLint location, GLsizei count, const GLdouble *value);
typedef void (APIENTRYP PFNGLUNIFORM2DVPROC) (GLint location, GLsizei count, const GLdouble *value);
typedef void (APIENTRYP PFNGLUNIFORM3DVPROC) (GLint location, GLsizei count, const GLdouble *value);
typedef void (APIENTRYP PFNGLUNIFORM4DVPROC) (GLint location, GLsizei count, const GLdouble *value);
typedef void (APIENTRYP PFNGLUNIFORMMATRIX2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void (APIENTRYP PFNGLUNIFORMMATRIX3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void (APIENTRYP PFNGLUNIFORMMATRIX4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void (APIENTRYP PFNGLUNIFORMMATRIX2X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void (APIENTRYP PFNGLUNIFORMMATRIX2X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void (APIENTRYP PFNGLUNIFORMMATRIX3X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void (APIENTRYP PFNGLUNIFORMMATRIX3X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void (APIENTRYP PFNGLUNIFORMMATRIX4X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void (APIENTRYP PFNGLUNIFORMMATRIX4X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void (APIENTRYP PFNGLGETUNIFORMDVPROC) (GLuint program, GLint location, GLdouble *params);
#endif

#ifndef GL_ARB_shader_subroutine
#define GL_ARB_shader_subroutine 1
#ifdef GL3_PROTOTYPES
GLAPI GLint APIENTRY glGetSubroutineUniformLocation (GLuint program, GLenum shadertype, const GLchar *name);
GLAPI GLuint APIENTRY glGetSubroutineIndex (GLuint program, GLenum shadertype, const GLchar *name);
GLAPI void APIENTRY glGetActiveSubroutineUniformiv (GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values);
GLAPI void APIENTRY glGetActiveSubroutineUniformName (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
GLAPI void APIENTRY glGetActiveSubroutineName (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
GLAPI void APIENTRY glUniformSubroutinesuiv (GLenum shadertype, GLsizei count, const GLuint *indices);
GLAPI void APIENTRY glGetUniformSubroutineuiv (GLenum shadertype, GLint location, GLuint *params);
GLAPI void APIENTRY glGetProgramStageiv (GLuint program, GLenum shadertype, GLenum pname, GLint *values);
#endif /* GL3_PROTOTYPES */
typedef GLint (APIENTRYP PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) (GLuint program, GLenum shadertype, const GLchar *name);
typedef GLuint (APIENTRYP PFNGLGETSUBROUTINEINDEXPROC) (GLuint program, GLenum shadertype, const GLchar *name);
typedef void (APIENTRYP PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) (GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values);
typedef void (APIENTRYP PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
typedef void (APIENTRYP PFNGLGETACTIVESUBROUTINENAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
typedef void (APIENTRYP PFNGLUNIFORMSUBROUTINESUIVPROC) (GLenum shadertype, GLsizei count, const GLuint *indices);
typedef void (APIENTRYP PFNGLGETUNIFORMSUBROUTINEUIVPROC) (GLenum shadertype, GLint location, GLuint *params);
typedef void (APIENTRYP PFNGLGETPROGRAMSTAGEIVPROC) (GLuint program, GLenum shadertype, GLenum pname, GLint *values);
#endif

#ifndef GL_ARB_tessellation_shader
#define GL_ARB_tessellation_shader 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glPatchParameteri (GLenum pname, GLint value);
GLAPI void APIENTRY glPatchParameterfv (GLenum pname, const GLfloat *values);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLPATCHPARAMETERIPROC) (GLenum pname, GLint value);
typedef void (APIENTRYP PFNGLPATCHPARAMETERFVPROC) (GLenum pname, const GLfloat *values);
#endif

#ifndef GL_ARB_texture_buffer_object_rgb32
#define GL_ARB_texture_buffer_object_rgb32 1
#endif

#ifndef GL_ARB_transform_feedback2
#define GL_ARB_transform_feedback2 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glBindTransformFeedback (GLenum target, GLuint id);
GLAPI void APIENTRY glDeleteTransformFeedbacks (GLsizei n, const GLuint *ids);
GLAPI void APIENTRY glGenTransformFeedbacks (GLsizei n, GLuint *ids);
GLAPI GLboolean APIENTRY glIsTransformFeedback (GLuint id);
GLAPI void APIENTRY glPauseTransformFeedback (void);
GLAPI void APIENTRY glResumeTransformFeedback (void);
GLAPI void APIENTRY glDrawTransformFeedback (GLenum mode, GLuint id);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLBINDTRANSFORMFEEDBACKPROC) (GLenum target, GLuint id);
typedef void (APIENTRYP PFNGLDELETETRANSFORMFEEDBACKSPROC) (GLsizei n, const GLuint *ids);
typedef void (APIENTRYP PFNGLGENTRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint *ids);
typedef GLboolean (APIENTRYP PFNGLISTRANSFORMFEEDBACKPROC) (GLuint id);
typedef void (APIENTRYP PFNGLPAUSETRANSFORMFEEDBACKPROC) (void);
typedef void (APIENTRYP PFNGLRESUMETRANSFORMFEEDBACKPROC) (void);
typedef void (APIENTRYP PFNGLDRAWTRANSFORMFEEDBACKPROC) (GLenum mode, GLuint id);
#endif

#ifndef GL_ARB_transform_feedback3
#define GL_ARB_transform_feedback3 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glDrawTransformFeedbackStream (GLenum mode, GLuint id, GLuint stream);
GLAPI void APIENTRY glBeginQueryIndexed (GLenum target, GLuint index, GLuint id);
GLAPI void APIENTRY glEndQueryIndexed (GLenum target, GLuint index);
GLAPI void APIENTRY glGetQueryIndexediv (GLenum target, GLuint index, GLenum pname, GLint *params);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) (GLenum mode, GLuint id, GLuint stream);
typedef void (APIENTRYP PFNGLBEGINQUERYINDEXEDPROC) (GLenum target, GLuint index, GLuint id);
typedef void (APIENTRYP PFNGLENDQUERYINDEXEDPROC) (GLenum target, GLuint index);
typedef void (APIENTRYP PFNGLGETQUERYINDEXEDIVPROC) (GLenum target, GLuint index, GLenum pname, GLint *params);
#endif

#ifndef GL_ARB_ES2_compatibility
#define GL_ARB_ES2_compatibility 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glReleaseShaderCompiler (void);
GLAPI void APIENTRY glShaderBinary (GLsizei count, const GLuint *shaders, GLenum binaryformat, const GLvoid *binary, GLsizei length);
GLAPI void APIENTRY glGetShaderPrecisionFormat (GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision);
GLAPI void APIENTRY glDepthRangef (GLclampf n, GLclampf f);
GLAPI void APIENTRY glClearDepthf (GLclampf d);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLRELEASESHADERCOMPILERPROC) (void);
typedef void (APIENTRYP PFNGLSHADERBINARYPROC) (GLsizei count, const GLuint *shaders, GLenum binaryformat, const GLvoid *binary, GLsizei length);
typedef void (APIENTRYP PFNGLGETSHADERPRECISIONFORMATPROC) (GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision);
typedef void (APIENTRYP PFNGLDEPTHRANGEFPROC) (GLclampf n, GLclampf f);
typedef void (APIENTRYP PFNGLCLEARDEPTHFPROC) (GLclampf d);
#endif

#ifndef GL_ARB_get_program_binary
#define GL_ARB_get_program_binary 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glGetProgramBinary (GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary);
GLAPI void APIENTRY glProgramBinary (GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length);
GLAPI void APIENTRY glProgramParameteri (GLuint program, GLenum pname, GLint value);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLGETPROGRAMBINARYPROC) (GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary);
typedef void (APIENTRYP PFNGLPROGRAMBINARYPROC) (GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length);
typedef void (APIENTRYP PFNGLPROGRAMPARAMETERIPROC) (GLuint program, GLenum pname, GLint value);
#endif

#ifndef GL_ARB_separate_shader_objects
#define GL_ARB_separate_shader_objects 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glUseProgramStages (GLuint pipeline, GLbitfield stages, GLuint program);
GLAPI void APIENTRY glActiveShaderProgram (GLuint pipeline, GLuint program);
GLAPI GLuint APIENTRY glCreateShaderProgramv (GLenum type, GLsizei count, const GLchar* const *strings);
GLAPI void APIENTRY glBindProgramPipeline (GLuint pipeline);
GLAPI void APIENTRY glDeleteProgramPipelines (GLsizei n, const GLuint *pipelines);
GLAPI void APIENTRY glGenProgramPipelines (GLsizei n, GLuint *pipelines);
GLAPI GLboolean APIENTRY glIsProgramPipeline (GLuint pipeline);
GLAPI void APIENTRY glGetProgramPipelineiv (GLuint pipeline, GLenum pname, GLint *params);
GLAPI void APIENTRY glProgramUniform1i (GLuint program, GLint location, GLint v0);
GLAPI void APIENTRY glProgramUniform1iv (GLuint program, GLint location, GLsizei count, const GLint *value);
GLAPI void APIENTRY glProgramUniform1f (GLuint program, GLint location, GLfloat v0);
GLAPI void APIENTRY glProgramUniform1fv (GLuint program, GLint location, GLsizei count, const GLfloat *value);
GLAPI void APIENTRY glProgramUniform1d (GLuint program, GLint location, GLdouble v0);
GLAPI void APIENTRY glProgramUniform1dv (GLuint program, GLint location, GLsizei count, const GLdouble *value);
GLAPI void APIENTRY glProgramUniform1ui (GLuint program, GLint location, GLuint v0);
GLAPI void APIENTRY glProgramUniform1uiv (GLuint program, GLint location, GLsizei count, const GLuint *value);
GLAPI void APIENTRY glProgramUniform2i (GLuint program, GLint location, GLint v0, GLint v1);
GLAPI void APIENTRY glProgramUniform2iv (GLuint program, GLint location, GLsizei count, const GLint *value);
GLAPI void APIENTRY glProgramUniform2f (GLuint program, GLint location, GLfloat v0, GLfloat v1);
GLAPI void APIENTRY glProgramUniform2fv (GLuint program, GLint location, GLsizei count, const GLfloat *value);
GLAPI void APIENTRY glProgramUniform2d (GLuint program, GLint location, GLdouble v0, GLdouble v1);
GLAPI void APIENTRY glProgramUniform2dv (GLuint program, GLint location, GLsizei count, const GLdouble *value);
GLAPI void APIENTRY glProgramUniform2ui (GLuint program, GLint location, GLuint v0, GLuint v1);
GLAPI void APIENTRY glProgramUniform2uiv (GLuint program, GLint location, GLsizei count, const GLuint *value);
GLAPI void APIENTRY glProgramUniform3i (GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
GLAPI void APIENTRY glProgramUniform3iv (GLuint program, GLint location, GLsizei count, const GLint *value);
GLAPI void APIENTRY glProgramUniform3f (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
GLAPI void APIENTRY glProgramUniform3fv (GLuint program, GLint location, GLsizei count, const GLfloat *value);
GLAPI void APIENTRY glProgramUniform3d (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
GLAPI void APIENTRY glProgramUniform3dv (GLuint program, GLint location, GLsizei count, const GLdouble *value);
GLAPI void APIENTRY glProgramUniform3ui (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
GLAPI void APIENTRY glProgramUniform3uiv (GLuint program, GLint location, GLsizei count, const GLuint *value);
GLAPI void APIENTRY glProgramUniform4i (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
GLAPI void APIENTRY glProgramUniform4iv (GLuint program, GLint location, GLsizei count, const GLint *value);
GLAPI void APIENTRY glProgramUniform4f (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
GLAPI void APIENTRY glProgramUniform4fv (GLuint program, GLint location, GLsizei count, const GLfloat *value);
GLAPI void APIENTRY glProgramUniform4d (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
GLAPI void APIENTRY glProgramUniform4dv (GLuint program, GLint location, GLsizei count, const GLdouble *value);
GLAPI void APIENTRY glProgramUniform4ui (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
GLAPI void APIENTRY glProgramUniform4uiv (GLuint program, GLint location, GLsizei count, const GLuint *value);
GLAPI void APIENTRY glProgramUniformMatrix2fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI void APIENTRY glProgramUniformMatrix3fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI void APIENTRY glProgramUniformMatrix4fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI void APIENTRY glProgramUniformMatrix2dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI void APIENTRY glProgramUniformMatrix3dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI void APIENTRY glProgramUniformMatrix4dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI void APIENTRY glProgramUniformMatrix2x3fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI void APIENTRY glProgramUniformMatrix3x2fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI void APIENTRY glProgramUniformMatrix2x4fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI void APIENTRY glProgramUniformMatrix4x2fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI void APIENTRY glProgramUniformMatrix3x4fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI void APIENTRY glProgramUniformMatrix4x3fv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GLAPI void APIENTRY glProgramUniformMatrix2x3dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI void APIENTRY glProgramUniformMatrix3x2dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI void APIENTRY glProgramUniformMatrix2x4dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI void APIENTRY glProgramUniformMatrix4x2dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI void APIENTRY glProgramUniformMatrix3x4dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI void APIENTRY glProgramUniformMatrix4x3dv (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
GLAPI void APIENTRY glValidateProgramPipeline (GLuint pipeline);
GLAPI void APIENTRY glGetProgramPipelineInfoLog (GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLUSEPROGRAMSTAGESPROC) (GLuint pipeline, GLbitfield stages, GLuint program);
typedef void (APIENTRYP PFNGLACTIVESHADERPROGRAMPROC) (GLuint pipeline, GLuint program);
typedef GLuint (APIENTRYP PFNGLCREATESHADERPROGRAMVPROC) (GLenum type, GLsizei count, const GLchar* const *strings);
typedef void (APIENTRYP PFNGLBINDPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef void (APIENTRYP PFNGLDELETEPROGRAMPIPELINESPROC) (GLsizei n, const GLuint *pipelines);
typedef void (APIENTRYP PFNGLGENPROGRAMPIPELINESPROC) (GLsizei n, GLuint *pipelines);
typedef GLboolean (APIENTRYP PFNGLISPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef void (APIENTRYP PFNGLGETPROGRAMPIPELINEIVPROC) (GLuint pipeline, GLenum pname, GLint *params);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1IPROC) (GLuint program, GLint location, GLint v0);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1IVPROC) (GLuint program, GLint location, GLsizei count, const GLint *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1FPROC) (GLuint program, GLint location, GLfloat v0);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1DPROC) (GLuint program, GLint location, GLdouble v0);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1UIPROC) (GLuint program, GLint location, GLuint v0);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2IPROC) (GLuint program, GLint location, GLint v0, GLint v1);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2IVPROC) (GLuint program, GLint location, GLsizei count, const GLint *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2FPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2DPROC) (GLuint program, GLint location, GLdouble v0, GLdouble v1);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2UIPROC) (GLuint program, GLint location, GLuint v0, GLuint v1);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3IPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3IVPROC) (GLuint program, GLint location, GLsizei count, const GLint *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3FPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3DPROC) (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3UIPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4IPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4IVPROC) (GLuint program, GLint location, GLsizei count, const GLint *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4FPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4DPROC) (GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4UIPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void (APIENTRYP PFNGLVALIDATEPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef void (APIENTRYP PFNGLGETPROGRAMPIPELINEINFOLOGPROC) (GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
#endif

#ifndef GL_ARB_shader_precision
#define GL_ARB_shader_precision 1
#endif

#ifndef GL_ARB_vertex_attrib_64bit
#define GL_ARB_vertex_attrib_64bit 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glVertexAttribL1d (GLuint index, GLdouble x);
GLAPI void APIENTRY glVertexAttribL2d (GLuint index, GLdouble x, GLdouble y);
GLAPI void APIENTRY glVertexAttribL3d (GLuint index, GLdouble x, GLdouble y, GLdouble z);
GLAPI void APIENTRY glVertexAttribL4d (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
GLAPI void APIENTRY glVertexAttribL1dv (GLuint index, const GLdouble *v);
GLAPI void APIENTRY glVertexAttribL2dv (GLuint index, const GLdouble *v);
GLAPI void APIENTRY glVertexAttribL3dv (GLuint index, const GLdouble *v);
GLAPI void APIENTRY glVertexAttribL4dv (GLuint index, const GLdouble *v);
GLAPI void APIENTRY glVertexAttribLPointer (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
GLAPI void APIENTRY glGetVertexAttribLdv (GLuint index, GLenum pname, GLdouble *params);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLVERTEXATTRIBL1DPROC) (GLuint index, GLdouble x);
typedef void (APIENTRYP PFNGLVERTEXATTRIBL2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (APIENTRYP PFNGLVERTEXATTRIBL3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (APIENTRYP PFNGLVERTEXATTRIBL4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (APIENTRYP PFNGLVERTEXATTRIBL1DVPROC) (GLuint index, const GLdouble *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIBL2DVPROC) (GLuint index, const GLdouble *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIBL3DVPROC) (GLuint index, const GLdouble *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIBL4DVPROC) (GLuint index, const GLdouble *v);
typedef void (APIENTRYP PFNGLVERTEXATTRIBLPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (APIENTRYP PFNGLGETVERTEXATTRIBLDVPROC) (GLuint index, GLenum pname, GLdouble *params);
#endif

#ifndef GL_ARB_viewport_array
#define GL_ARB_viewport_array 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glViewportArrayv (GLuint first, GLsizei count, const GLfloat *v);
GLAPI void APIENTRY glViewportIndexedf (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
GLAPI void APIENTRY glViewportIndexedfv (GLuint index, const GLfloat *v);
GLAPI void APIENTRY glScissorArrayv (GLuint first, GLsizei count, const GLint *v);
GLAPI void APIENTRY glScissorIndexed (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
GLAPI void APIENTRY glScissorIndexedv (GLuint index, const GLint *v);
GLAPI void APIENTRY glDepthRangeArrayv (GLuint first, GLsizei count, const GLclampd *v);
GLAPI void APIENTRY glDepthRangeIndexed (GLuint index, GLclampd n, GLclampd f);
GLAPI void APIENTRY glGetFloati_v (GLenum target, GLuint index, GLfloat *data);
GLAPI void APIENTRY glGetDoublei_v (GLenum target, GLuint index, GLdouble *data);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLVIEWPORTARRAYVPROC) (GLuint first, GLsizei count, const GLfloat *v);
typedef void (APIENTRYP PFNGLVIEWPORTINDEXEDFPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
typedef void (APIENTRYP PFNGLVIEWPORTINDEXEDFVPROC) (GLuint index, const GLfloat *v);
typedef void (APIENTRYP PFNGLSCISSORARRAYVPROC) (GLuint first, GLsizei count, const GLint *v);
typedef void (APIENTRYP PFNGLSCISSORINDEXEDPROC) (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
typedef void (APIENTRYP PFNGLSCISSORINDEXEDVPROC) (GLuint index, const GLint *v);
typedef void (APIENTRYP PFNGLDEPTHRANGEARRAYVPROC) (GLuint first, GLsizei count, const GLclampd *v);
typedef void (APIENTRYP PFNGLDEPTHRANGEINDEXEDPROC) (GLuint index, GLclampd n, GLclampd f);
typedef void (APIENTRYP PFNGLGETFLOATI_VPROC) (GLenum target, GLuint index, GLfloat *data);
typedef void (APIENTRYP PFNGLGETDOUBLEI_VPROC) (GLenum target, GLuint index, GLdouble *data);
#endif


#ifdef __cplusplus
}
#endif

#endif
                                                                                                                                                                                                      gl3ext.h                                                                                            0100644 0001750 0001750 00000032574 12567471560 032347  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers                                                                      /*
	Copyright:	(c) 2010-2013 Apple Inc. All rights reserved.
*/

#ifndef __gl3ext_h_
#define __gl3ext_h_

#include <OpenGL/gltypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#if defined(_WIN32) && !defined(APIENTRY) && !defined(__CYGWIN__) && !defined(__SCITECH_SNAP__)
#define WIN32_LEAN_AND_MEAN 1
#include <windows.h>
#endif

#if defined(__APPLE__)
#define GL3_PROTOTYPES
#endif

#ifndef APIENTRY
#define APIENTRY
#endif
#ifndef APIENTRYP
#define APIENTRYP APIENTRY *
#endif
#ifndef GLAPI
#define GLAPI extern
#endif

/****** Enums ************************************************/

#ifndef GL_ARB_instanced_arrays
#define GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB 0x88FE
#endif

#ifndef GL_ARB_internalformat_query
#define GL_NUM_SAMPLE_COUNTS              0x9380
#endif

#ifndef GL_ARB_sample_shading
#define GL_SAMPLE_SHADING_ARB             0x8C36
#define GL_MIN_SAMPLE_SHADING_VALUE_ARB   0x8C37
#endif

#ifndef GL_ARB_shading_language_include
#define GL_SHADER_INCLUDE_ARB             0x8DAE
#define GL_NAMED_STRING_LENGTH_ARB        0x8DE9
#define GL_NAMED_STRING_TYPE_ARB          0x8DEA
#endif

#ifndef GL_ARB_texture_cube_map_array
#define GL_TEXTURE_CUBE_MAP_ARRAY_ARB     0x9009
#define GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_ARB 0x900A
#define GL_PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB 0x900B
#define GL_SAMPLER_CUBE_MAP_ARRAY_ARB     0x900C
#define GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_ARB 0x900D
#define GL_INT_SAMPLER_CUBE_MAP_ARRAY_ARB 0x900E
#define GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_ARB 0x900F
#endif

#ifndef GL_ARB_texture_gather
#define GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_ARB 0x8E5E
#define GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_ARB 0x8E5F
#define GL_MAX_PROGRAM_TEXTURE_GATHER_COMPONENTS_ARB 0x8F9F
#endif

#ifndef GL_ARB_texture_storage
#define GL_TEXTURE_IMMUTABLE_FORMAT       0x912F
#endif

#ifndef GL_EXT_debug_label
/* reuse GL_TEXTURE */
/* reuse GL_FRAMEBUFFER */
/* reuse GL_RENDERBUFFER */
/* reuse GL_TRANSFORM_FEEDBACK */
#define GL_BUFFER_OBJECT_EXT              0x9151
#define GL_SHADER_OBJECT_EXT              0x8B48
#define GL_PROGRAM_OBJECT_EXT             0x8B40
#define GL_VERTEX_ARRAY_OBJECT_EXT        0x9154
#define GL_QUERY_OBJECT_EXT               0x9153
#define GL_PROGRAM_PIPELINE_OBJECT_EXT    0x8A4F
#define GL_SYNC_OBJECT_APPLE              0x8A53
#define GL_SAMPLER                        0x82E6
#endif

#ifndef GL_EXT_depth_bounds_test
#define GL_DEPTH_BOUNDS_TEST_EXT          0x8890
#define GL_DEPTH_BOUNDS_EXT               0x8891
#endif

#ifndef GL_EXT_framebuffer_multisample_blit_scaled
#define GL_SCALED_RESOLVE_FASTEST_EXT     0x90BA
#define GL_SCALED_RESOLVE_NICEST_EXT      0x90BB
#endif

#ifndef GL_EXT_texture_compression_s3tc
#define GL_COMPRESSED_RGB_S3TC_DXT1_EXT   0x83F0
#define GL_COMPRESSED_RGBA_S3TC_DXT1_EXT  0x83F1
#define GL_COMPRESSED_RGBA_S3TC_DXT3_EXT  0x83F2
#define GL_COMPRESSED_RGBA_S3TC_DXT5_EXT  0x83F3
#define GL_COMPRESSED_SRGB_S3TC_DXT1_EXT  0x8C4C
#define GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT 0x8C4D
#define GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT 0x8C4E
#define GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT 0x8C4F
#endif

#ifndef GL_EXT_texture_filter_anisotropic
#define GL_TEXTURE_MAX_ANISOTROPY_EXT     0x84FE
#define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT 0x84FF
#endif

#ifndef GL_EXT_texture_mirror_clamp
#define GL_MIRROR_CLAMP_EXT               0x8742
#define GL_MIRROR_CLAMP_TO_EDGE_EXT       0x8743
#define GL_MIRROR_CLAMP_TO_BORDER_EXT     0x8912
#endif

#ifndef GL_EXT_texture_sRGB_decode
#define GL_TEXTURE_SRGB_DECODE_EXT        0x8A48
#define GL_DECODE_EXT                     0x8A49
#define GL_SKIP_DECODE_EXT                0x8A4A
#endif

#ifndef GL_APPLE_client_storage
#define GL_UNPACK_CLIENT_STORAGE_APPLE    0x85B2
#endif

#ifndef GL_APPLE_object_purgeable
#define GL_RELEASED_APPLE                 0x8A19
#define GL_VOLATILE_APPLE                 0x8A1A
#define GL_RETAINED_APPLE                 0x8A1B
#define GL_UNDEFINED_APPLE                0x8A1C
#define GL_PURGEABLE_APPLE                0x8A1D
#endif

#ifndef GL_APPLE_rgb_422
#define GL_RGB_422_APPLE                  0x8A1F
#define GL_UNSIGNED_SHORT_8_8_APPLE       0x85BA
#define GL_UNSIGNED_SHORT_8_8_REV_APPLE   0x85BB
#define GL_RGB_RAW_422_APPLE              0x8A51
#endif

#ifndef GL_APPLE_row_bytes
#define GL_PACK_ROW_BYTES_APPLE           0x8A15
#define GL_UNPACK_ROW_BYTES_APPLE         0x8A16
#define GL_PACK_IMAGE_BYTES_APPLE         0x8A17
#define GL_UNPACK_IMAGE_BYTES_APPLE       0x8A18
#endif

#ifndef GL_APPLE_texture_range
#define GL_TEXTURE_RANGE_LENGTH_APPLE     0x85B7
#define GL_TEXTURE_RANGE_POINTER_APPLE    0x85B8
#define GL_TEXTURE_STORAGE_HINT_APPLE     0x85BC
#define GL_TEXTURE_MINIMIZE_STORAGE_APPLE 0x85B6
#define GL_STORAGE_PRIVATE_APPLE          0x85BD
#define GL_STORAGE_CACHED_APPLE           0x85BE
#define GL_STORAGE_SHARED_APPLE           0x85BF
#endif

#ifndef GL_ATI_texture_mirror_once
#define GL_MIRROR_CLAMP_ATI               0x8742
#define GL_MIRROR_CLAMP_TO_EDGE_ATI       0x8743
#endif

/****** Functions Prototypes *********************************/

#ifndef GL_ARB_draw_buffers_blend
#define GL_ARB_draw_buffers_blend 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glBlendEquationiARB (GLuint buf, GLenum mode);
GLAPI void APIENTRY glBlendEquationSeparateiARB (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
GLAPI void APIENTRY glBlendFunciARB (GLuint buf, GLenum src, GLenum dst);
GLAPI void APIENTRY glBlendFuncSeparateiARB (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLBLENDEQUATIONIARBPROC) (GLuint buf, GLenum mode);
typedef void (APIENTRYP PFNGLBLENDEQUATIONSEPARATEIARBPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (APIENTRYP PFNGLBLENDFUNCIARBPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEIARBPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
#endif

#ifndef GL_ARB_instanced_arrays
#define GL_ARB_instanced_arrays 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glVertexAttribDivisorARB (GLuint index, GLuint divisor);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLVERTEXATTRIBDIVISORARBPROC) (GLuint index, GLuint divisor);
#endif

#ifndef GL_ARB_internalformat_query
#define GL_ARB_internalformat_query 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glGetInternalformativ (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLGETINTERNALFORMATIVPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
#endif

#ifndef GL_ARB_sample_shading
#define GL_ARB_sample_shading 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glMinSampleShadingARB (GLclampf value);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLMINSAMPLESHADINGARBPROC) (GLclampf value);
#endif

#ifndef GL_ARB_shading_language_include
#define GL_ARB_shading_language_include 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glNamedStringARB (GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string);
GLAPI void APIENTRY glDeleteNamedStringARB (GLint namelen, const GLchar *name);
GLAPI void APIENTRY glCompileShaderIncludeARB (GLuint shader, GLsizei count, const GLchar* const *path, const GLint *length);
GLAPI GLboolean APIENTRY glIsNamedStringARB (GLint namelen, const GLchar *name);
GLAPI void APIENTRY glGetNamedStringARB (GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string);
GLAPI void APIENTRY glGetNamedStringivARB (GLint namelen, const GLchar *name, GLenum pname, GLint *params);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLNAMEDSTRINGARBPROC) (GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string);
typedef void (APIENTRYP PFNGLDELETENAMEDSTRINGARBPROC) (GLint namelen, const GLchar *name);
typedef void (APIENTRYP PFNGLCOMPILESHADERINCLUDEARBPROC) (GLuint shader, GLsizei count, const GLchar* const *path, const GLint *length);
typedef GLboolean (APIENTRYP PFNGLISNAMEDSTRINGARBPROC) (GLint namelen, const GLchar *name);
typedef void (APIENTRYP PFNGLGETNAMEDSTRINGARBPROC) (GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string);
typedef void (APIENTRYP PFNGLGETNAMEDSTRINGIVARBPROC) (GLint namelen, const GLchar *name, GLenum pname, GLint *params);
#endif

#ifndef GL_ARB_texture_cube_map_array
#define GL_ARB_texture_cube_map_array 1
#endif

#ifndef GL_ARB_texture_gather
#define GL_ARB_texture_gather 1
#endif

#ifndef GL_ARB_texture_storage
#define GL_ARB_texture_storage 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glTexStorage1D (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
GLAPI void APIENTRY glTexStorage2D (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
GLAPI void APIENTRY glTexStorage3D (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLTEXSTORAGE1DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (APIENTRYP PFNGLTEXSTORAGE2DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (APIENTRYP PFNGLTEXSTORAGE3DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
#endif

#ifndef GL_EXT_debug_label
#define GL_EXT_debug_label 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glLabelObjectEXT (GLenum type, GLuint object, GLsizei length, const GLchar *label);
GLAPI void APIENTRY glGetObjectLabelEXT (GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLLABELOBJECTEXTPROC) (GLenum type, GLuint object, GLsizei length, const GLchar *label);
typedef void (APIENTRYP PFNGLGETOBJECTLABELEXTPROC) (GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label);
#endif

#ifndef GL_EXT_debug_marker
#define GL_EXT_debug_marker 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glInsertEventMarkerEXT (GLsizei length, const char *marker);
GLAPI void APIENTRY glPushGroupMarkerEXT (GLsizei length, const char *marker);
GLAPI void APIENTRY glPopGroupMarkerEXT (void);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLINSERTEVENTMARKEREXTPROC) (GLsizei length, const char *marker);
typedef void (APIENTRYP PFNGLPUSHGROUPMARKEREXTPROC) (GLsizei length, const char *marker);
typedef void (APIENTRYP PFNGLPOPGROUPMARKEREXTPROC) (void);
#endif

#ifndef GL_EXT_depth_bounds_test
#define GL_EXT_depth_bounds_test 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glDepthBoundsEXT (GLclampd zmin, GLclampd zmax);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLDEPTHBOUNDSEXTPROC) (GLclampd zmin, GLclampd zmax);
#endif

#ifndef GL_EXT_framebuffer_multisample_blit_scaled
#define GL_EXT_framebuffer_multisample_blit_scaled 1
#endif

#ifndef GL_EXT_texture_compression_s3tc
#define GL_EXT_texture_compression_s3tc 1
#endif

#ifndef GL_EXT_texture_filter_anisotropic
#define GL_EXT_texture_filter_anisotropic 1
#endif

#ifndef GL_EXT_texture_mirror_clamp
#define GL_EXT_texture_mirror_clamp 1
#endif

#ifndef GL_EXT_texture_sRGB_decode
#define GL_EXT_texture_sRGB_decode 1
#endif

#ifndef GL_APPLE_client_storage
#define GL_APPLE_client_storage 1
#endif

#ifndef GL_APPLE_container_object_shareable
#define GL_APPLE_container_object_shareable 1
#endif

#ifndef GL_APPLE_flush_render
#define GL_APPLE_flush_render 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glFlushRenderAPPLE (void);
GLAPI void APIENTRY glFinishRenderAPPLE (void);
GLAPI void APIENTRY glSwapAPPLE (void);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLFLUSHRENDERAPPLEPROC) (void);
typedef void (APIENTRYP PFNGLFINISHRENDERAPPLEPROC) (void);
typedef void (APIENTRYP PFNGLSWAPAPPLEPROC) (void);
#endif

#ifndef GL_APPLE_object_purgeable
#define GL_APPLE_object_purgeable 1
#ifdef GL3_PROTOTYPES
GLAPI GLenum APIENTRY glObjectPurgeableAPPLE (GLenum objectType, GLuint name, GLenum option);
GLAPI GLenum APIENTRY glObjectUnpurgeableAPPLE (GLenum objectType, GLuint name, GLenum option);
GLAPI void APIENTRY glGetObjectParameterivAPPLE (GLenum objectType, GLuint name, GLenum pname, GLint *params);
#endif /* GL3_PROTOTYPES */
typedef GLenum (APIENTRYP PFNGLOBJECTPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);
typedef GLenum (APIENTRYP PFNGLOBJECTUNPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);
typedef void (APIENTRYP PFNGLGETOBJECTPARAMETERIVAPPLEPROC) (GLenum objectType, GLuint name, GLenum pname, GLint *params);
#endif

#ifndef GL_APPLE_rgb_422
#define GL_APPLE_rgb_422 1
#endif

#ifndef GL_APPLE_row_bytes
#define GL_APPLE_row_bytes 1
#endif

#ifndef GL_APPLE_texture_range
#define GL_APPLE_texture_range 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glTextureRangeAPPLE (GLenum target, GLsizei length, const GLvoid *pointer);
GLAPI void APIENTRY glGetTexParameterPointervAPPLE (GLenum target, GLenum pname, GLvoid **params);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLTEXTURERANGEAPPLEPROC) (GLenum target, GLsizei length, const GLvoid *pointer);
typedef void (APIENTRYP PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC) (GLenum target, GLenum pname, GLvoid **params);
#endif

#ifndef GL_ATI_texture_mirror_once
#define GL_ATI_texture_mirror_once 1
#endif

#ifndef GL_NV_texture_barrier
#define GL_NV_texture_barrier 1
#ifdef GL3_PROTOTYPES
GLAPI void APIENTRY glTextureBarrierNV (void);
#endif /* GL3_PROTOTYPES */
typedef void (APIENTRYP PFNGLTEXTUREBARRIERNVPROC) (void);
#endif

#ifdef __cplusplus
}
#endif

#endif

                                                                                                                                    glext.h                                                                                             0100644 0001750 0001750 00000650740 12567471560 032265  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers                                                                      /*
	Copyright:	(c) 1999-2012 Apple Inc. All rights reserved.
*/

#ifndef __glext_h_
#define __glext_h_

#include <OpenGL/gltypes.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
** License Applicability. Except to the extent portions of this file are
** made subject to an alternative license as permitted in the SGI Free
** Software License B, Version 1.1 (the "License"), the contents of this
** file are subject only to the provisions of the License. You may not use
** this file except in compliance with the License. You may obtain a copy
** of the License at Silicon Graphics, Inc., attn: Legal Services, 1600
** Amphitheatre Parkway, Mountain View, CA 94043-1351, or at:
**
** http://oss.sgi.com/projects/FreeB
**
** Note that, as provided in the License, the Software is distributed on an
** "AS IS" basis, with ALL EXPRESS AND IMPLIED WARRANTIES AND CONDITIONS
** DISCLAIMED, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTIES AND
** CONDITIONS OF MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A
** PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
**
** Original Code. The Original Code is: OpenGL Sample Implementation,
** Version 1.2.1, released January 26, 2000, developed by Silicon Graphics,
** Inc. The Original Code is Copyright (c) 1991-2000 Silicon Graphics, Inc.
** Copyright in any portions created by third parties is as indicated
** elsewhere herein. All Rights Reserved.
**
** Additional Notice Provisions: This software was created using the
** OpenGL(R) version 1.2.1 Sample Implementation published by SGI, but has
** not been independently verified as being compliant with the OpenGL(R)
** version 1.2.1 Specification.
*/

/* switches to providing function pointers */
/* #define GL_GLEXT_FUNCTION_POINTERS 1 */

#define GL_ARB_color_buffer_float                            1
#define GL_ARB_depth_buffer_float                            1
#define GL_ARB_depth_clamp                                   1
#define GL_ARB_depth_texture                                 1
#define GL_ARB_draw_buffers                                  1
#define GL_ARB_draw_elements_base_vertex                     1
#define GL_ARB_draw_instanced                                1
#define GL_ARB_fragment_program                              1
#define GL_ARB_fragment_program_shadow                       1
#define GL_ARB_fragment_shader                               1
#define GL_ARB_framebuffer_object                            1
#define GL_ARB_framebuffer_sRGB                              1
#define GL_ARB_half_float_pixel                              1
#define GL_ARB_half_float_vertex                             1
#define GL_ARB_imaging                                       1
#define GL_ARB_instanced_arrays                              1
#define GL_ARB_multisample                                   1
#define GL_ARB_multitexture                                  1
#define GL_ARB_occlusion_query                               1
#define GL_ARB_pixel_buffer_object                           1
#define GL_ARB_point_parameters                              1
#define GL_ARB_point_sprite                                  1
#define GL_ARB_provoking_vertex                              1
#define GL_ARB_seamless_cube_map                             1
#define GL_ARB_shader_objects                                1
#define GL_ARB_shader_texture_lod                            1
#define GL_ARB_shading_language_100                          1
#define GL_ARB_shadow                                        1
#define GL_ARB_shadow_ambient                                1
#define GL_ARB_sync                                          1
#define GL_ARB_texture_border_clamp                          1
#define GL_ARB_texture_compression                           1
#define GL_ARB_texture_compression_rgtc                      1
#define GL_ARB_texture_cube_map                              1
#define GL_ARB_texture_env_add                               1
#define GL_ARB_texture_env_combine                           1
#define GL_ARB_texture_env_crossbar                          1
#define GL_ARB_texture_env_dot3                              1
#define GL_ARB_texture_float                                 1
#define GL_ARB_texture_mirrored_repeat                       1
#define GL_ARB_texture_non_power_of_two                      1
#define GL_ARB_texture_rectangle                             1
#define GL_ARB_texture_rg                                    1
#define GL_ARB_transpose_matrix                              1
#define GL_ARB_vertex_array_bgra                             1
#define GL_ARB_vertex_blend                                  1
#define GL_ARB_vertex_buffer_object                          1
#define GL_ARB_vertex_program                                1
#define GL_ARB_vertex_shader                                 1
#define GL_ARB_window_pos                                    1
#define GL_EXT_abgr                                          1
#define GL_EXT_bgra                                          1
#define GL_EXT_bindable_uniform                              1
#define GL_EXT_blend_color                                   1
#define GL_EXT_blend_equation_separate                       1
#define GL_EXT_blend_func_separate                           1
#define GL_EXT_blend_minmax                                  1
#define GL_EXT_blend_subtract                                1
#define GL_EXT_clip_volume_hint                              1
#define GL_EXT_debug_label                                   1
#define GL_EXT_debug_marker                                  1
#define GL_EXT_depth_bounds_test                             1
#define GL_EXT_draw_buffers2                                 1
#define GL_EXT_draw_range_elements                           1
#define GL_EXT_fog_coord                                     1
#define GL_EXT_framebuffer_blit                              1
#define GL_EXT_framebuffer_multisample                       1
#define GL_EXT_framebuffer_multisample_blit_scaled           1
#define GL_EXT_framebuffer_object                            1
#define GL_EXT_framebuffer_sRGB                              1
#define GL_EXT_geometry_shader4                              1
#define GL_EXT_gpu_program_parameters                        1
#define GL_EXT_gpu_shader4                                   1
#define GL_EXT_multi_draw_arrays                             1
#define GL_EXT_packed_depth_stencil                          1
#define GL_EXT_packed_float                                  1
#define GL_EXT_provoking_vertex                              1
#define GL_EXT_rescale_normal                                1
#define GL_EXT_secondary_color                               1
#define GL_EXT_separate_specular_color                       1
#define GL_EXT_shadow_funcs                                  1
#define GL_EXT_stencil_two_side                              1
#define GL_EXT_stencil_wrap                                  1
#define GL_EXT_texture_array                                 1
#define GL_EXT_texture_compression_dxt1                      1
#define GL_EXT_texture_compression_s3tc                      1
#define GL_EXT_texture_env_add                               1
#define GL_EXT_texture_filter_anisotropic                    1
#define GL_EXT_texture_integer                               1
#define GL_EXT_texture_lod_bias                              1
#define GL_EXT_texture_mirror_clamp                          1
#define GL_EXT_texture_rectangle                             1
#define GL_EXT_texture_shared_exponent                       1
#define GL_EXT_texture_sRGB                                  1
#define GL_EXT_texture_sRGB_decode                           1
#define GL_EXT_timer_query                                   1
#define GL_EXT_transform_feedback                            1
#define GL_EXT_vertex_array_bgra                             1
#define GL_APPLE_aux_depth_stencil                           1
#define GL_APPLE_client_storage                              1
#define GL_APPLE_element_array                               1
#define GL_APPLE_fence                                       1
#define GL_APPLE_float_pixels                                1
#define GL_APPLE_flush_buffer_range                          1
#define GL_APPLE_flush_render                                1
#define GL_APPLE_object_purgeable                            1
#define GL_APPLE_packed_pixels                               1
#define GL_APPLE_pixel_buffer                                1
#define GL_APPLE_rgb_422                                     1
#define GL_APPLE_row_bytes                                   1
#define GL_APPLE_specular_vector                             1
#define GL_APPLE_texture_range                               1
#define GL_APPLE_transform_hint                              1
#define GL_APPLE_vertex_array_object                         1
#define GL_APPLE_vertex_array_range                          1
#define GL_APPLE_vertex_point_size                           1
#define GL_APPLE_vertex_program_evaluators                   1
#define GL_APPLE_ycbcr_422                                   1
#define GL_ATI_blend_equation_separate                       1
#define GL_ATI_blend_weighted_minmax                         1
#define GL_ATI_separate_stencil                              1
#define GL_ATI_texture_compression_3dc                       1
#define GL_ATI_texture_env_combine3                          1
#define GL_ATI_texture_float                                 1
#define GL_ATI_texture_mirror_once                           1
#define GL_IBM_rasterpos_clip                                1
#define GL_NV_blend_square                                   1
#define GL_NV_conditional_render                             1
#define GL_NV_depth_clamp                                    1
#define GL_NV_fog_distance                                   1
#define GL_NV_fragment_program_option                        1
#define GL_NV_fragment_program2                              1
#define GL_NV_light_max_exponent                             1
#define GL_NV_multisample_filter_hint                        1
#define GL_NV_point_sprite                                   1
#define GL_NV_texgen_reflection                              1
#define GL_NV_texture_barrier                                1
#define GL_NV_vertex_program2_option                         1
#define GL_NV_vertex_program3                                1
#define GL_SGI_color_matrix                                  1
#define GL_SGIS_generate_mipmap                              1
#define GL_SGIS_texture_edge_clamp                           1
#define GL_SGIS_texture_lod                                  1

#ifdef GL_GLEXT_WUNDEF_SUPPORT
#define GL_EXT_color_subtable                                0
#define GL_EXT_compiled_vertex_array                         0
#define GL_EXT_convolution                                   0
#define GL_EXT_copy_texture                                  0
#define GL_EXT_histogram                                     0
#define GL_EXT_packed_pixels                                 0
#define GL_EXT_paletted_texture                              0
#define GL_EXT_polygon_offset                                0
#define GL_EXT_shared_texture_palette                        0
#define GL_EXT_subtexture                                    0
#define GL_EXT_texture                                       0
#define GL_EXT_texture_cube_map                              0
#define GL_EXT_texture_env_combine                           0
#define GL_EXT_texture_object                                0
#define GL_EXT_texture3D                                     0
#define GL_EXT_vertex_array                                  0
#define GL_ATI_array_rev_comps_in_4_bytes                    0
#define GL_ATI_pn_triangles                                  0
#define GL_ATI_point_cull_mode                               0
#define GL_ATI_text_fragment_shader                          0
#define GL_ATIX_pn_triangles                                 0
#define GL_HP_convolution_border_modes                       0
#define GL_NV_register_combiners                             0
#define GL_NV_register_combiners2                            0
#define GL_NV_texture_shader                                 0
#define GL_NV_texture_shader2                                0
#define GL_NV_texture_shader3                                0
#define GL_NV_vertex_array_range                             0
#define GL_NV_vertex_array_range2                            0
#define GL_NV_vertex_program                                 0
#define GL_SGI_color_table                                   0
#define GL_SGIS_point_parameters                             0
#define GL_SGIS_texture_border_clamp                         0
#define GL_SGIX_depth_texture                                0
#endif

/*************************************************************/

#ifndef __gltypes_h_
#if GL_ARB_half_float_pixel
typedef unsigned short GLhalfARB;
#endif

#if GL_ARB_half_float_vertex
typedef unsigned short GLhalf;
#endif

#if GL_ARB_shader_objects
typedef char GLcharARB;
typedef void *GLhandleARB;
#endif

#if GL_ARB_sync
typedef int64_t GLint64;
typedef uint64_t GLuint64;
typedef struct __GLsync *GLsync;
#endif

#if GL_ARB_vertex_buffer_object
typedef long GLintptrARB;
typedef long GLsizeiptrARB;
#endif

#if GL_EXT_timer_query
typedef int64_t GLint64EXT;
typedef uint64_t GLuint64EXT;
#endif
#endif

/*************************************************************/
#define GL_GLEXT_VERSION 8

#if GL_ARB_color_buffer_float
#define GL_RGBA_FLOAT_MODE_ARB                               0x8820
#define GL_CLAMP_VERTEX_COLOR_ARB                            0x891A
#define GL_CLAMP_FRAGMENT_COLOR_ARB                          0x891B
#define GL_CLAMP_READ_COLOR_ARB                              0x891C
#define GL_FIXED_ONLY_ARB                                    0x891D
#endif

#if GL_ARB_depth_buffer_float
#define GL_DEPTH_COMPONENT32F                                0x8CAC
#define GL_DEPTH32F_STENCIL8                                 0x8CAD
#define GL_FLOAT_32_UNSIGNED_INT_24_8_REV                    0x8DAD
#endif

#if GL_ARB_depth_clamp
#define GL_DEPTH_CLAMP                                       0x864F
#endif

#if GL_ARB_depth_texture
#define GL_DEPTH_COMPONENT16_ARB                             0x81A5
#define GL_DEPTH_COMPONENT24_ARB                             0x81A6
#define GL_DEPTH_COMPONENT32_ARB                             0x81A7
#define GL_TEXTURE_DEPTH_SIZE_ARB                            0x884A
#define GL_DEPTH_TEXTURE_MODE_ARB                            0x884B
#endif

#if GL_ARB_draw_buffers
#define GL_MAX_DRAW_BUFFERS_ARB                              0x8824
#define GL_DRAW_BUFFER0_ARB                                  0x8825
#define GL_DRAW_BUFFER1_ARB                                  0x8826
#define GL_DRAW_BUFFER2_ARB                                  0x8827
#define GL_DRAW_BUFFER3_ARB                                  0x8828
#define GL_DRAW_BUFFER4_ARB                                  0x8829
#define GL_DRAW_BUFFER5_ARB                                  0x882A
#define GL_DRAW_BUFFER6_ARB                                  0x882B
#define GL_DRAW_BUFFER7_ARB                                  0x882C
#define GL_DRAW_BUFFER8_ARB                                  0x882D
#define GL_DRAW_BUFFER9_ARB                                  0x882E
#define GL_DRAW_BUFFER10_ARB                                 0x882F
#define GL_DRAW_BUFFER11_ARB                                 0x8830
#define GL_DRAW_BUFFER12_ARB                                 0x8831
#define GL_DRAW_BUFFER13_ARB                                 0x8832
#define GL_DRAW_BUFFER14_ARB                                 0x8833
#define GL_DRAW_BUFFER15_ARB                                 0x8834
#endif

#if GL_ARB_fragment_program
#define GL_FRAGMENT_PROGRAM_ARB                              0x8804
#define GL_PROGRAM_ALU_INSTRUCTIONS_ARB                      0x8805
#define GL_PROGRAM_TEX_INSTRUCTIONS_ARB                      0x8806
#define GL_PROGRAM_TEX_INDIRECTIONS_ARB                      0x8807
#define GL_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB               0x8808
#define GL_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB               0x8809
#define GL_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB               0x880A
#define GL_MAX_PROGRAM_ALU_INSTRUCTIONS_ARB                  0x880B
#define GL_MAX_PROGRAM_TEX_INSTRUCTIONS_ARB                  0x880C
#define GL_MAX_PROGRAM_TEX_INDIRECTIONS_ARB                  0x880D
#define GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB           0x880E
#define GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB           0x880F
#define GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB           0x8810
#define GL_MAX_TEXTURE_COORDS_ARB                            0x8871
#define GL_MAX_TEXTURE_IMAGE_UNITS_ARB                       0x8872
#endif

#if GL_ARB_fragment_shader
#define GL_FRAGMENT_SHADER_ARB                               0x8B30
#define GL_MAX_FRAGMENT_UNIFORM_COMPONENTS_ARB               0x8B49
#define GL_FRAGMENT_SHADER_DERIVATIVE_HINT_ARB               0x8B8B
#define GL_MAX_TEXTURE_COORDS_ARB                            0x8871
#define GL_MAX_TEXTURE_IMAGE_UNITS_ARB                       0x8872
#endif

#if GL_ARB_framebuffer_object
#define GL_INVALID_FRAMEBUFFER_OPERATION                     0x0506
#define GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING             0x8210
#define GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE             0x8211
#define GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE                   0x8212
#define GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE                 0x8213
#define GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE                  0x8214
#define GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE                 0x8215
#define GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE                 0x8216
#define GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE               0x8217
#define GL_FRAMEBUFFER_DEFAULT                               0x8218
#define GL_FRAMEBUFFER_UNDEFINED                             0x8219
#define GL_DEPTH_STENCIL_ATTACHMENT                          0x821A
#define GL_MAX_RENDERBUFFER_SIZE                             0x84E8
#define GL_DEPTH_STENCIL                                     0x84F9
#define GL_UNSIGNED_INT_24_8                                 0x84FA
#define GL_DEPTH24_STENCIL8                                  0x88F0
#define GL_TEXTURE_STENCIL_SIZE                              0x88F1
#define GL_TEXTURE_RED_TYPE                                  0x8C10
#define GL_TEXTURE_GREEN_TYPE                                0x8C11
#define GL_TEXTURE_BLUE_TYPE                                 0x8C12
#define GL_TEXTURE_ALPHA_TYPE                                0x8C13
#define GL_TEXTURE_DEPTH_TYPE                                0x8C16
#define GL_UNSIGNED_NORMALIZED                               0x8C17
#define GL_FRAMEBUFFER_BINDING                               0x8CA6
#define GL_DRAW_FRAMEBUFFER_BINDING                          GL_FRAMEBUFFER_BINDING
#define GL_RENDERBUFFER_BINDING                              0x8CA7
#define GL_READ_FRAMEBUFFER                                  0x8CA8
#define GL_DRAW_FRAMEBUFFER                                  0x8CA9
#define GL_READ_FRAMEBUFFER_BINDING                          0x8CAA
#define GL_RENDERBUFFER_SAMPLES                              0x8CAB
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE                0x8CD0
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME                0x8CD1
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL              0x8CD2
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE      0x8CD3
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER              0x8CD4
#define GL_FRAMEBUFFER_COMPLETE                              0x8CD5
#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT                 0x8CD6
#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT         0x8CD7
#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER                0x8CDB
#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER                0x8CDC
#define GL_FRAMEBUFFER_UNSUPPORTED                           0x8CDD
#define GL_MAX_COLOR_ATTACHMENTS                             0x8CDF
#define GL_COLOR_ATTACHMENT0                                 0x8CE0
#define GL_COLOR_ATTACHMENT1                                 0x8CE1
#define GL_COLOR_ATTACHMENT2                                 0x8CE2
#define GL_COLOR_ATTACHMENT3                                 0x8CE3
#define GL_COLOR_ATTACHMENT4                                 0x8CE4
#define GL_COLOR_ATTACHMENT5                                 0x8CE5
#define GL_COLOR_ATTACHMENT6                                 0x8CE6
#define GL_COLOR_ATTACHMENT7                                 0x8CE7
#define GL_COLOR_ATTACHMENT8                                 0x8CE8
#define GL_COLOR_ATTACHMENT9                                 0x8CE9
#define GL_COLOR_ATTACHMENT10                                0x8CEA
#define GL_COLOR_ATTACHMENT11                                0x8CEB
#define GL_COLOR_ATTACHMENT12                                0x8CEC
#define GL_COLOR_ATTACHMENT13                                0x8CED
#define GL_COLOR_ATTACHMENT14                                0x8CEE
#define GL_COLOR_ATTACHMENT15                                0x8CEF
#define GL_DEPTH_ATTACHMENT                                  0x8D00
#define GL_STENCIL_ATTACHMENT                                0x8D20
#define GL_FRAMEBUFFER                                       0x8D40
#define GL_RENDERBUFFER                                      0x8D41
#define GL_RENDERBUFFER_WIDTH                                0x8D42
#define GL_RENDERBUFFER_HEIGHT                               0x8D43
#define GL_RENDERBUFFER_INTERNAL_FORMAT                      0x8D44
#define GL_STENCIL_INDEX1                                    0x8D46
#define GL_STENCIL_INDEX4                                    0x8D47
#define GL_STENCIL_INDEX8                                    0x8D48
#define GL_STENCIL_INDEX16                                   0x8D49
#define GL_RENDERBUFFER_RED_SIZE                             0x8D50
#define GL_RENDERBUFFER_GREEN_SIZE                           0x8D51
#define GL_RENDERBUFFER_BLUE_SIZE                            0x8D52
#define GL_RENDERBUFFER_ALPHA_SIZE                           0x8D53
#define GL_RENDERBUFFER_DEPTH_SIZE                           0x8D54
#define GL_RENDERBUFFER_STENCIL_SIZE                         0x8D55
#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE                0x8D56
#define GL_MAX_SAMPLES                                       0x8D57
#endif

#if GL_ARB_framebuffer_sRGB
#define GL_FRAMEBUFFER_SRGB                                  0x8DB9
#endif

#if GL_ARB_half_float_pixel
#define GL_HALF_FLOAT_ARB                                    0x140B
#endif

#if GL_ARB_half_float_vertex
#define GL_HALF_FLOAT                                        0x140B
#endif

#if GL_ARB_instanced_arrays
#define GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB                   0x88FE
#endif

#if GL_ARB_multisample
#define GL_MULTISAMPLE_ARB                                   0x809D
#define GL_SAMPLE_ALPHA_TO_COVERAGE_ARB                      0x809E
#define GL_SAMPLE_ALPHA_TO_ONE_ARB                           0x809F
#define GL_SAMPLE_COVERAGE_ARB                               0x80A0
#define GL_SAMPLE_BUFFERS_ARB                                0x80A8
#define GL_SAMPLES_ARB                                       0x80A9
#define GL_SAMPLE_COVERAGE_VALUE_ARB                         0x80AA
#define GL_SAMPLE_COVERAGE_INVERT_ARB                        0x80AB
#define GL_MULTISAMPLE_BIT_ARB                               0x20000000
#endif

#if GL_ARB_multitexture
#define GL_TEXTURE0_ARB                                      0x84C0
#define GL_TEXTURE1_ARB                                      0x84C1
#define GL_TEXTURE2_ARB                                      0x84C2
#define GL_TEXTURE3_ARB                                      0x84C3
#define GL_TEXTURE4_ARB                                      0x84C4
#define GL_TEXTURE5_ARB                                      0x84C5
#define GL_TEXTURE6_ARB                                      0x84C6
#define GL_TEXTURE7_ARB                                      0x84C7
#define GL_TEXTURE8_ARB                                      0x84C8
#define GL_TEXTURE9_ARB                                      0x84C9
#define GL_TEXTURE10_ARB                                     0x84CA
#define GL_TEXTURE11_ARB                                     0x84CB
#define GL_TEXTURE12_ARB                                     0x84CC
#define GL_TEXTURE13_ARB                                     0x84CD
#define GL_TEXTURE14_ARB                                     0x84CE
#define GL_TEXTURE15_ARB                                     0x84CF
#define GL_TEXTURE16_ARB                                     0x84D0
#define GL_TEXTURE17_ARB                                     0x84D1
#define GL_TEXTURE18_ARB                                     0x84D2
#define GL_TEXTURE19_ARB                                     0x84D3
#define GL_TEXTURE20_ARB                                     0x84D4
#define GL_TEXTURE21_ARB                                     0x84D5
#define GL_TEXTURE22_ARB                                     0x84D6
#define GL_TEXTURE23_ARB                                     0x84D7
#define GL_TEXTURE24_ARB                                     0x84D8
#define GL_TEXTURE25_ARB                                     0x84D9
#define GL_TEXTURE26_ARB                                     0x84DA
#define GL_TEXTURE27_ARB                                     0x84DB
#define GL_TEXTURE28_ARB                                     0x84DC
#define GL_TEXTURE29_ARB                                     0x84DD
#define GL_TEXTURE30_ARB                                     0x84DE
#define GL_TEXTURE31_ARB                                     0x84DF
#define GL_ACTIVE_TEXTURE_ARB                                0x84E0
#define GL_CLIENT_ACTIVE_TEXTURE_ARB                         0x84E1
#define GL_MAX_TEXTURE_UNITS_ARB                             0x84E2
#endif

#if GL_ARB_occlusion_query
#define GL_SAMPLES_PASSED_ARB                                0x8914
#define GL_QUERY_COUNTER_BITS_ARB                            0x8864
#define GL_CURRENT_QUERY_ARB                                 0x8865
#define GL_QUERY_RESULT_ARB                                  0x8866
#define GL_QUERY_RESULT_AVAILABLE_ARB                        0x8867
#endif

#if GL_ARB_pixel_buffer_object
#define GL_PIXEL_PACK_BUFFER_ARB                             0x88EB
#define GL_PIXEL_UNPACK_BUFFER_ARB                           0x88EC
#define GL_PIXEL_PACK_BUFFER_BINDING_ARB                     0x88ED
#define GL_PIXEL_UNPACK_BUFFER_BINDING_ARB                   0x88EF
#endif

#if GL_ARB_point_parameters
#define GL_POINT_SIZE_MIN_ARB                                0x8126
#define GL_POINT_SIZE_MAX_ARB                                0x8127
#define GL_POINT_FADE_THRESHOLD_SIZE_ARB                     0x8128
#define GL_POINT_DISTANCE_ATTENUATION_ARB                    0x8129
#endif

#if GL_ARB_point_sprite
#define GL_POINT_SPRITE_ARB                                  0x8861
#define GL_COORD_REPLACE_ARB                                 0x8862
#endif

#if GL_ARB_provoking_vertex
#define GL_FIRST_VERTEX_CONVENTION                           0x8E4D
#define GL_LAST_VERTEX_CONVENTION                            0x8E4E
#define GL_PROVOKING_VERTEX                                  0x8E4F
#define GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION          0x8E4C
#endif

#if GL_ARB_seamless_cube_map
#define GL_TEXTURE_CUBE_MAP_SEAMLESS                         0x884F
#endif

#if GL_ARB_shader_objects
#define GL_PROGRAM_OBJECT_ARB                                0x8B40
#define GL_OBJECT_TYPE_ARB                                   0x8B4E
#define GL_OBJECT_SUBTYPE_ARB                                0x8B4F
#define GL_OBJECT_DELETE_STATUS_ARB                          0x8B80
#define GL_OBJECT_COMPILE_STATUS_ARB                         0x8B81
#define GL_OBJECT_LINK_STATUS_ARB                            0x8B82
#define GL_OBJECT_VALIDATE_STATUS_ARB                        0x8B83
#define GL_OBJECT_INFO_LOG_LENGTH_ARB                        0x8B84
#define GL_OBJECT_ATTACHED_OBJECTS_ARB                       0x8B85
#define GL_OBJECT_ACTIVE_UNIFORMS_ARB                        0x8B86
#define GL_OBJECT_ACTIVE_UNIFORM_MAX_LENGTH_ARB              0x8B87
#define GL_OBJECT_SHADER_SOURCE_LENGTH_ARB                   0x8B88
#define GL_SHADER_OBJECT_ARB                                 0x8B48
#define GL_FLOAT_VEC2_ARB                                    0x8B50
#define GL_FLOAT_VEC3_ARB                                    0x8B51
#define GL_FLOAT_VEC4_ARB                                    0x8B52
#define GL_INT_VEC2_ARB                                      0x8B53
#define GL_INT_VEC3_ARB                                      0x8B54
#define GL_INT_VEC4_ARB                                      0x8B55
#define GL_BOOL_ARB                                          0x8B56
#define GL_BOOL_VEC2_ARB                                     0x8B57
#define GL_BOOL_VEC3_ARB                                     0x8B58
#define GL_BOOL_VEC4_ARB                                     0x8B59
#define GL_FLOAT_MAT2_ARB                                    0x8B5A
#define GL_FLOAT_MAT3_ARB                                    0x8B5B
#define GL_FLOAT_MAT4_ARB                                    0x8B5C
#define GL_SAMPLER_1D_ARB                                    0x8B5D
#define GL_SAMPLER_2D_ARB                                    0x8B5E
#define GL_SAMPLER_3D_ARB                                    0x8B5F
#define GL_SAMPLER_CUBE_ARB                                  0x8B60
#define GL_SAMPLER_1D_SHADOW_ARB                             0x8B61
#define GL_SAMPLER_2D_SHADOW_ARB                             0x8B62
#define GL_SAMPLER_2D_RECT_ARB                               0x8B63
#define GL_SAMPLER_2D_RECT_SHADOW_ARB                        0x8B64
#endif

#if GL_ARB_shading_language_100
#define GL_SHADING_LANGUAGE_VERSION_ARB                      0x8B8C
#endif

#if GL_ARB_shadow
#define GL_TEXTURE_COMPARE_MODE_ARB                          0x884C
#define GL_TEXTURE_COMPARE_FUNC_ARB                          0x884D
#define GL_COMPARE_R_TO_TEXTURE_ARB                          0x884E
#endif

#if GL_ARB_shadow_ambient
#define GL_TEXTURE_COMPARE_FAIL_VALUE_ARB                    0x80BF
#endif

#if GL_ARB_sync
#define GL_MAX_SERVER_WAIT_TIMEOUT                           0x9111
#define GL_OBJECT_TYPE                                       0x9112
#define GL_SYNC_CONDITION                                    0x9113
#define GL_SYNC_STATUS                                       0x9114
#define GL_SYNC_FLAGS                                        0x9115
#define GL_SYNC_FENCE                                        0x9116
#define GL_SYNC_GPU_COMMANDS_COMPLETE                        0x9117
#define GL_UNSIGNALED                                        0x9118
#define GL_SIGNALED                                          0x9119
#define GL_ALREADY_SIGNALED                                  0x911A
#define GL_TIMEOUT_EXPIRED                                   0x911B
#define GL_CONDITION_SATISFIED                               0x911C
#define GL_WAIT_FAILED                                       0x911D
#define GL_SYNC_FLUSH_COMMANDS_BIT                           0x00000001
#define GL_TIMEOUT_IGNORED                                   0xFFFFFFFFFFFFFFFFull
#endif

#if GL_ARB_texture_border_clamp
#define GL_CLAMP_TO_BORDER_ARB                               0x812D
#endif

#if GL_ARB_texture_compression
#define GL_COMPRESSED_ALPHA_ARB                              0x84E9
#define GL_COMPRESSED_LUMINANCE_ARB                          0x84EA
#define GL_COMPRESSED_LUMINANCE_ALPHA_ARB                    0x84EB
#define GL_COMPRESSED_INTENSITY_ARB                          0x84EC
#define GL_COMPRESSED_RGB_ARB                                0x84ED
#define GL_COMPRESSED_RGBA_ARB                               0x84EE
#define GL_TEXTURE_COMPRESSION_HINT_ARB                      0x84EF
#define GL_TEXTURE_COMPRESSED_IMAGE_SIZE_ARB                 0x86A0
#define GL_TEXTURE_COMPRESSED_ARB                            0x86A1
#define GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB                0x86A2
#define GL_COMPRESSED_TEXTURE_FORMATS_ARB                    0x86A3
#endif

#if GL_ARB_texture_compression_rgtc
#define GL_COMPRESSED_RED_RGTC1                              0x8DBB
#define GL_COMPRESSED_SIGNED_RED_RGTC1                       0x8DBC
#define GL_COMPRESSED_RG_RGTC2                               0x8DBD
#define GL_COMPRESSED_SIGNED_RG_RGTC2                        0x8DBE
#endif

#if GL_ARB_texture_cube_map
#define GL_NORMAL_MAP_ARB                                    0x8511
#define GL_REFLECTION_MAP_ARB                                0x8512
#define GL_TEXTURE_CUBE_MAP_ARB                              0x8513
#define GL_TEXTURE_BINDING_CUBE_MAP_ARB                      0x8514
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB                   0x8515
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB                   0x8516
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB                   0x8517
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB                   0x8518
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB                   0x8519
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB                   0x851A
#define GL_PROXY_TEXTURE_CUBE_MAP_ARB                        0x851B
#define GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB                     0x851C
#endif

#if GL_ARB_texture_env_combine
#define GL_COMBINE_ARB                                       0x8570
#define GL_COMBINE_RGB_ARB                                   0x8571
#define GL_COMBINE_ALPHA_ARB                                 0x8572
#define GL_RGB_SCALE_ARB                                     0x8573
#define GL_ADD_SIGNED_ARB                                    0x8574
#define GL_INTERPOLATE_ARB                                   0x8575
#define GL_CONSTANT_ARB                                      0x8576
#define GL_PRIMARY_COLOR_ARB                                 0x8577
#define GL_PREVIOUS_ARB                                      0x8578
#define GL_SUBTRACT_ARB                                      0x84E7
#define GL_SOURCE0_RGB_ARB                                   0x8580
#define GL_SOURCE1_RGB_ARB                                   0x8581
#define GL_SOURCE2_RGB_ARB                                   0x8582
#define GL_SOURCE0_ALPHA_ARB                                 0x8588
#define GL_SOURCE1_ALPHA_ARB                                 0x8589
#define GL_SOURCE2_ALPHA_ARB                                 0x858A
#define GL_OPERAND0_RGB_ARB                                  0x8590
#define GL_OPERAND1_RGB_ARB                                  0x8591
#define GL_OPERAND2_RGB_ARB                                  0x8592
#define GL_OPERAND0_ALPHA_ARB                                0x8598
#define GL_OPERAND1_ALPHA_ARB                                0x8599
#define GL_OPERAND2_ALPHA_ARB                                0x859A
#endif

#if GL_ARB_texture_env_dot3
#define GL_DOT3_RGB_ARB                                      0x86AE
#define GL_DOT3_RGBA_ARB                                     0x86AF
#endif

#if GL_ARB_texture_float
#define GL_TEXTURE_RED_TYPE_ARB                              0x8C10
#define GL_TEXTURE_GREEN_TYPE_ARB                            0x8C11
#define GL_TEXTURE_BLUE_TYPE_ARB                             0x8C12
#define GL_TEXTURE_ALPHA_TYPE_ARB                            0x8C13
#define GL_TEXTURE_LUMINANCE_TYPE_ARB                        0x8C14
#define GL_TEXTURE_INTENSITY_TYPE_ARB                        0x8C15
#define GL_TEXTURE_DEPTH_TYPE_ARB                            0x8C16
#define GL_UNSIGNED_NORMALIZED_ARB                           0x8C17
#define GL_RGBA32F_ARB                                       0x8814
#define GL_RGB32F_ARB                                        0x8815
#define GL_ALPHA32F_ARB                                      0x8816
#define GL_INTENSITY32F_ARB                                  0x8817
#define GL_LUMINANCE32F_ARB                                  0x8818
#define GL_LUMINANCE_ALPHA32F_ARB                            0x8819
#define GL_RGBA16F_ARB                                       0x881A
#define GL_RGB16F_ARB                                        0x881B
#define GL_ALPHA16F_ARB                                      0x881C
#define GL_INTENSITY16F_ARB                                  0x881D
#define GL_LUMINANCE16F_ARB                                  0x881E
#define GL_LUMINANCE_ALPHA16F_ARB                            0x881F
#endif

#if GL_ARB_texture_mirrored_repeat
#define GL_MIRRORED_REPEAT_ARB                               0x8370
#endif

#if GL_ARB_texture_rectangle
#define GL_TEXTURE_RECTANGLE_ARB                             0x84F5
#define GL_TEXTURE_BINDING_RECTANGLE_ARB                     0x84F6
#define GL_PROXY_TEXTURE_RECTANGLE_ARB                       0x84F7
#define GL_MAX_RECTANGLE_TEXTURE_SIZE_ARB                    0x84F8
#endif

#if GL_ARB_texture_rg
#define GL_COMPRESSED_RED                                    0x8225
#define GL_COMPRESSED_RG                                     0x8226
#define GL_RG                                                0x8227
#define GL_RG_INTEGER                                        0x8228
#define GL_R8                                                0x8229
#define GL_R16                                               0x822A
#define GL_RG8                                               0x822B
#define GL_RG16                                              0x822C
#define GL_R16F                                              0x822D
#define GL_R32F                                              0x822E
#define GL_RG16F                                             0x822F
#define GL_RG32F                                             0x8230
#define GL_R8I                                               0x8231
#define GL_R8UI                                              0x8232
#define GL_R16I                                              0x8233
#define GL_R16UI                                             0x8234
#define GL_R32I                                              0x8235
#define GL_R32UI                                             0x8236
#define GL_RG8I                                              0x8237
#define GL_RG8UI                                             0x8238
#define GL_RG16I                                             0x8239
#define GL_RG16UI                                            0x823A
#define GL_RG32I                                             0x823B
#define GL_RG32UI                                            0x823C
#endif

#if GL_ARB_transpose_matrix
#define GL_TRANSPOSE_MODELVIEW_MATRIX_ARB                    0x84E3
#define GL_TRANSPOSE_PROJECTION_MATRIX_ARB                   0x84E4
#define GL_TRANSPOSE_TEXTURE_MATRIX_ARB                      0x84E5
#define GL_TRANSPOSE_COLOR_MATRIX_ARB                        0x84E6
#endif

#if GL_ARB_vertex_blend
#define GL_MAX_VERTEX_UNITS_ARB                              0x86A4
#define GL_ACTIVE_VERTEX_UNITS_ARB                           0x86A5
#define GL_WEIGHT_SUM_UNITY_ARB                              0x86A6
#define GL_VERTEX_BLEND_ARB                                  0x86A7
#define GL_CURRENT_WEIGHT_ARB                                0x86A8
#define GL_WEIGHT_ARRAY_TYPE_ARB                             0x86A9
#define GL_WEIGHT_ARRAY_STRIDE_ARB                           0x86AA
#define GL_WEIGHT_ARRAY_SIZE_ARB                             0x86AB
#define GL_WEIGHT_ARRAY_POINTER_ARB                          0x86AC
#define GL_WEIGHT_ARRAY_ARB                                  0x86AD
#define GL_MODELVIEW0_ARB                                    0x1700
#define GL_MODELVIEW1_ARB                                    0x850A
#define GL_MODELVIEW2_ARB                                    0x8722
#define GL_MODELVIEW3_ARB                                    0x8723
#define GL_MODELVIEW4_ARB                                    0x8724
#define GL_MODELVIEW5_ARB                                    0x8725
#define GL_MODELVIEW6_ARB                                    0x8726
#define GL_MODELVIEW7_ARB                                    0x8727
#define GL_MODELVIEW8_ARB                                    0x8728
#define GL_MODELVIEW9_ARB                                    0x8729
#define GL_MODELVIEW10_ARB                                   0x872A
#define GL_MODELVIEW11_ARB                                   0x872B
#define GL_MODELVIEW12_ARB                                   0x872C
#define GL_MODELVIEW13_ARB                                   0x872D
#define GL_MODELVIEW14_ARB                                   0x872E
#define GL_MODELVIEW15_ARB                                   0x872F
#define GL_MODELVIEW16_ARB                                   0x8730
#define GL_MODELVIEW17_ARB                                   0x8731
#define GL_MODELVIEW18_ARB                                   0x8732
#define GL_MODELVIEW19_ARB                                   0x8733
#define GL_MODELVIEW20_ARB                                   0x8734
#define GL_MODELVIEW21_ARB                                   0x8735
#define GL_MODELVIEW22_ARB                                   0x8736
#define GL_MODELVIEW23_ARB                                   0x8737
#define GL_MODELVIEW24_ARB                                   0x8738
#define GL_MODELVIEW25_ARB                                   0x8739
#define GL_MODELVIEW26_ARB                                   0x873A
#define GL_MODELVIEW27_ARB                                   0x873B
#define GL_MODELVIEW28_ARB                                   0x873C
#define GL_MODELVIEW29_ARB                                   0x873D
#define GL_MODELVIEW30_ARB                                   0x873E
#define GL_MODELVIEW31_ARB                                   0x873F
#endif

#if GL_ARB_vertex_buffer_object
#define GL_ARRAY_BUFFER_ARB                                  0x8892
#define GL_ELEMENT_ARRAY_BUFFER_ARB                          0x8893
#define GL_ARRAY_BUFFER_BINDING_ARB                          0x8894
#define GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB                  0x8895
#define GL_VERTEX_ARRAY_BUFFER_BINDING_ARB                   0x8896
#define GL_NORMAL_ARRAY_BUFFER_BINDING_ARB                   0x8897
#define GL_COLOR_ARRAY_BUFFER_BINDING_ARB                    0x8898
#define GL_INDEX_ARRAY_BUFFER_BINDING_ARB                    0x8899
#define GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB            0x889A
#define GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB                0x889B
#define GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB          0x889C
#define GL_FOG_COORD_ARRAY_BUFFER_BINDING_ARB                0x889D
#define GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB                   0x889E
#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB            0x889F
#define GL_STREAM_DRAW_ARB                                   0x88E0
#define GL_STREAM_READ_ARB                                   0x88E1
#define GL_STREAM_COPY_ARB                                   0x88E2
#define GL_STATIC_DRAW_ARB                                   0x88E4
#define GL_STATIC_READ_ARB                                   0x88E5
#define GL_STATIC_COPY_ARB                                   0x88E6
#define GL_DYNAMIC_DRAW_ARB                                  0x88E8
#define GL_DYNAMIC_READ_ARB                                  0x88E9
#define GL_DYNAMIC_COPY_ARB                                  0x88EA
#define GL_READ_ONLY_ARB                                     0x88B8
#define GL_WRITE_ONLY_ARB                                    0x88B9
#define GL_READ_WRITE_ARB                                    0x88BA
#define GL_BUFFER_SIZE_ARB                                   0x8764
#define GL_BUFFER_USAGE_ARB                                  0x8765
#define GL_BUFFER_ACCESS_ARB                                 0x88BB
#define GL_BUFFER_MAPPED_ARB                                 0x88BC
#define GL_BUFFER_MAP_POINTER_ARB                            0x88BD
/* Obsolete */
#define GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB           0x889D
#endif

#if GL_ARB_vertex_program
#define GL_VERTEX_PROGRAM_ARB                                0x8620
#define GL_VERTEX_PROGRAM_POINT_SIZE_ARB                     0x8642
#define GL_VERTEX_PROGRAM_TWO_SIDE_ARB                       0x8643
#define GL_PROGRAM_FORMAT_ASCII_ARB                          0x8875
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB                   0x8622
#define GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB                      0x8623
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB                    0x8624
#define GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB                      0x8625
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB                0x886A
#define GL_CURRENT_VERTEX_ATTRIB_ARB                         0x8626
#define GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB                   0x8645
#define GL_PROGRAM_LENGTH_ARB                                0x8627
#define GL_PROGRAM_FORMAT_ARB                                0x8876
#define GL_PROGRAM_NAME_ARB                                  0x8677
#define GL_PROGRAM_BINDING_ARB                               0x8677
#define GL_PROGRAM_INSTRUCTIONS_ARB                          0x88A0
#define GL_MAX_PROGRAM_INSTRUCTIONS_ARB                      0x88A1
#define GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB                   0x88A2
#define GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB               0x88A3
#define GL_PROGRAM_TEMPORARIES_ARB                           0x88A4
#define GL_MAX_PROGRAM_TEMPORARIES_ARB                       0x88A5
#define GL_PROGRAM_NATIVE_TEMPORARIES_ARB                    0x88A6
#define GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB                0x88A7
#define GL_PROGRAM_PARAMETERS_ARB                            0x88A8
#define GL_MAX_PROGRAM_PARAMETERS_ARB                        0x88A9
#define GL_PROGRAM_NATIVE_PARAMETERS_ARB                     0x88AA
#define GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB                 0x88AB
#define GL_PROGRAM_ATTRIBS_ARB                               0x88AC
#define GL_MAX_PROGRAM_ATTRIBS_ARB                           0x88AD
#define GL_PROGRAM_NATIVE_ATTRIBS_ARB                        0x88AE
#define GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB                    0x88AF
#define GL_PROGRAM_ADDRESS_REGISTERS_ARB                     0x88B0
#define GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB                 0x88B1
#define GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB              0x88B2
#define GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB          0x88B3
#define GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB                  0x88B4
#define GL_MAX_PROGRAM_ENV_PARAMETERS_ARB                    0x88B5
#define GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB                   0x88B6
#define GL_PROGRAM_STRING_ARB                                0x8628
#define GL_PROGRAM_ERROR_POSITION_ARB                        0x864B
#define GL_CURRENT_MATRIX_ARB                                0x8641
#define GL_TRANSPOSE_CURRENT_MATRIX_ARB                      0x88B7
#define GL_CURRENT_MATRIX_STACK_DEPTH_ARB                    0x8640
#define GL_MAX_VERTEX_ATTRIBS_ARB                            0x8869
#define GL_MAX_PROGRAM_MATRICES_ARB                          0x862F
#define GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB                0x862E
#define GL_PROGRAM_ERROR_STRING_ARB                          0x8874
#define GL_MATRIX0_ARB                                       0x88C0
#define GL_MATRIX1_ARB                                       0x88C1
#define GL_MATRIX2_ARB                                       0x88C2
#define GL_MATRIX3_ARB                                       0x88C3
#define GL_MATRIX4_ARB                                       0x88C4
#define GL_MATRIX5_ARB                                       0x88C5
#define GL_MATRIX6_ARB                                       0x88C6
#define GL_MATRIX7_ARB                                       0x88C7
#define GL_MATRIX8_ARB                                       0x88C8
#define GL_MATRIX9_ARB                                       0x88C9
#define GL_MATRIX10_ARB                                      0x88CA
#define GL_MATRIX11_ARB                                      0x88CB
#define GL_MATRIX12_ARB                                      0x88CC
#define GL_MATRIX13_ARB                                      0x88CD
#define GL_MATRIX14_ARB                                      0x88CE
#define GL_MATRIX15_ARB                                      0x88CF
#define GL_MATRIX16_ARB                                      0x88D0
#define GL_MATRIX17_ARB                                      0x88D1
#define GL_MATRIX18_ARB                                      0x88D2
#define GL_MATRIX19_ARB                                      0x88D3
#define GL_MATRIX20_ARB                                      0x88D4
#define GL_MATRIX21_ARB                                      0x88D5
#define GL_MATRIX22_ARB                                      0x88D6
#define GL_MATRIX23_ARB                                      0x88D7
#define GL_MATRIX24_ARB                                      0x88D8
#define GL_MATRIX25_ARB                                      0x88D9
#define GL_MATRIX26_ARB                                      0x88DA
#define GL_MATRIX27_ARB                                      0x88DB
#define GL_MATRIX28_ARB                                      0x88DC
#define GL_MATRIX29_ARB                                      0x88DD
#define GL_MATRIX30_ARB                                      0x88DE
#define GL_MATRIX31_ARB                                      0x88DF
#define GL_COLOR_SUM_ARB                                     0x8458
#endif

#if GL_ARB_vertex_shader
#define GL_VERTEX_SHADER_ARB                                 0x8B31
#define GL_MAX_VERTEX_UNIFORM_COMPONENTS_ARB                 0x8B4A
#define GL_MAX_TEXTURE_COORDS_ARB                            0x8871
#define GL_MAX_TEXTURE_IMAGE_UNITS_ARB                       0x8872
#define GL_MAX_VARYING_FLOATS_ARB                            0x8B4B
#define GL_MAX_VERTEX_ATTRIBS_ARB                            0x8869
#define GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS_ARB              0x8B4D
#define GL_VERTEX_PROGRAM_POINT_SIZE_ARB                     0x8642
#define GL_VERTEX_PROGRAM_TWO_SIDE_ARB                       0x8643
#define GL_OBJECT_ACTIVE_ATTRIBUTES_ARB                      0x8B89
#define GL_OBJECT_ACTIVE_ATTRIBUTE_MAX_LENGTH_ARB            0x8B8A
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB                   0x8622
#define GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB                      0x8623
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB                    0x8624
#define GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB                      0x8625
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB                0x886A
#define GL_CURRENT_VERTEX_ATTRIB_ARB                         0x8626
#define GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB                   0x8645
#endif

#if GL_ARB_vertex_shader || GL_NV_vertex_program3
#define GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS_ARB                0x8B4C
#endif

#if GL_EXT_abgr
#define GL_ABGR_EXT                                          0x8000
#endif

#if GL_EXT_bgra
#define GL_BGR_EXT                                           0x80E0
#define GL_BGRA_EXT                                          0x80E1
#endif

#if GL_EXT_bindable_uniform
#define GL_MAX_VERTEX_BINDABLE_UNIFORMS_EXT                  0x8DE2
#define GL_MAX_FRAGMENT_BINDABLE_UNIFORMS_EXT                0x8DE3
#define GL_MAX_GEOMETRY_BINDABLE_UNIFORMS_EXT                0x8DE4
#define GL_MAX_BINDABLE_UNIFORM_SIZE_EXT                     0x8DED
#define GL_UNIFORM_BUFFER_BINDING_EXT                        0x8DEF
#define GL_UNIFORM_BUFFER_EXT                                0x8DEE
#endif

#if GL_EXT_blend_color
#define GL_CONSTANT_COLOR_EXT                                0x8001
#define GL_ONE_MINUS_CONSTANT_COLOR_EXT                      0x8002
#define GL_CONSTANT_ALPHA_EXT                                0x8003
#define GL_ONE_MINUS_CONSTANT_ALPHA_EXT                      0x8004
#define GL_BLEND_COLOR_EXT                                   0x8005
#endif

#if GL_EXT_blend_equation_separate
#define GL_BLEND_EQUATION_RGB_EXT                            0x8009
#define GL_BLEND_EQUATION_ALPHA_EXT                          0x883D
#endif

#if GL_EXT_blend_func_separate
#define GL_BLEND_DST_RGB_EXT                                 0x80C8
#define GL_BLEND_SRC_RGB_EXT                                 0x80C9
#define GL_BLEND_DST_ALPHA_EXT                               0x80CA
#define GL_BLEND_SRC_ALPHA_EXT                               0x80CB
#endif

#if GL_EXT_blend_minmax
#define GL_FUNC_ADD_EXT                                      0x8006
#define GL_MIN_EXT                                           0x8007
#define GL_MAX_EXT                                           0x8008
#define GL_BLEND_EQUATION_EXT                                0x8009
#endif

#if GL_EXT_blend_subtract
#define GL_FUNC_SUBTRACT_EXT                                 0x800A
#define GL_FUNC_REVERSE_SUBTRACT_EXT                         0x800B
#endif

#if GL_EXT_clip_volume_hint
#define GL_CLIP_VOLUME_CLIPPING_HINT_EXT                     0x80F0
#endif

#if GL_EXT_compiled_vertex_array
#define GL_ARRAY_ELEMENT_LOCK_FIRST_EXT                      0x81A8
#define GL_ARRAY_ELEMENT_LOCK_COUNT_EXT                      0x81A9
#endif

#if GL_EXT_convolution
#define GL_CONVOLUTION_1D_EXT                                0x8010
#define GL_CONVOLUTION_2D_EXT                                0x8011
#define GL_SEPARABLE_2D_EXT                                  0x8012
#define GL_CONVOLUTION_BORDER_MODE_EXT                       0x8013
#define GL_CONVOLUTION_FILTER_SCALE_EXT                      0x8014
#define GL_CONVOLUTION_FILTER_BIAS_EXT                       0x8015
#define GL_REDUCE_EXT                                        0x8016
#define GL_CONVOLUTION_FORMAT_EXT                            0x8017
#define GL_CONVOLUTION_WIDTH_EXT                             0x8018
#define GL_CONVOLUTION_HEIGHT_EXT                            0x8019
#define GL_MAX_CONVOLUTION_WIDTH_EXT                         0x801A
#define GL_MAX_CONVOLUTION_HEIGHT_EXT                        0x801B
#define GL_POST_CONVOLUTION_RED_SCALE_EXT                    0x801C
#define GL_POST_CONVOLUTION_GREEN_SCALE_EXT                  0x801D
#define GL_POST_CONVOLUTION_BLUE_SCALE_EXT                   0x801E
#define GL_POST_CONVOLUTION_ALPHA_SCALE_EXT                  0x801F
#define GL_POST_CONVOLUTION_RED_BIAS_EXT                     0x8020
#define GL_POST_CONVOLUTION_GREEN_BIAS_EXT                   0x8021
#define GL_POST_CONVOLUTION_BLUE_BIAS_EXT                    0x8022
#define GL_POST_CONVOLUTION_ALPHA_BIAS_EXT                   0x8023
#endif

#if GL_EXT_debug_label
#define GL_BUFFER_OBJECT_EXT                                 0x9151
#define GL_SHADER_OBJECT_EXT                                 0x8B48
#define GL_PROGRAM_OBJECT_EXT                                0x8B40
#define GL_QUERY_OBJECT_EXT                                  0x9153
#define GL_VERTEX_ARRAY_OBJECT_EXT                           0x9154
#define GL_SAMPLER                                           0x82E6
#define GL_SYNC_OBJECT_APPLE								 0x8A53
#endif

#if GL_EXT_depth_bounds_test
#define GL_DEPTH_BOUNDS_TEST_EXT                             0x8890
#define GL_DEPTH_BOUNDS_EXT                                  0x8891
#endif

#if GL_EXT_draw_range_elements
#define GL_MAX_ELEMENTS_VERTICES_EXT                         0x80E8
#define GL_MAX_ELEMENTS_INDICES_EXT                          0x80E9
#endif

#if GL_EXT_fog_coord
#define GL_FOG_COORDINATE_SOURCE_EXT                         0x8450
#define GL_FOG_COORDINATE_EXT                                0x8451
#define GL_FRAGMENT_DEPTH_EXT                                0x8452
#define GL_CURRENT_FOG_COORDINATE_EXT                        0x8453
#define GL_FOG_COORDINATE_ARRAY_TYPE_EXT                     0x8454
#define GL_FOG_COORDINATE_ARRAY_STRIDE_EXT                   0x8455
#define GL_FOG_COORDINATE_ARRAY_POINTER_EXT                  0x8456
#define GL_FOG_COORDINATE_ARRAY_EXT                          0x8457
#endif

#if GL_EXT_framebuffer_blit
#define GL_READ_FRAMEBUFFER_EXT                              0x8CA8
#define GL_DRAW_FRAMEBUFFER_EXT                              0x8CA9
#define GL_DRAW_FRAMEBUFFER_BINDING_EXT                      0x8CA6
#define GL_READ_FRAMEBUFFER_BINDING_EXT                      0x8CAA
#endif

#if GL_EXT_framebuffer_multisample
#define GL_RENDERBUFFER_SAMPLES_EXT                          0x8CAB
#define GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT            0x8D56
#define GL_MAX_SAMPLES_EXT                                   0x8D57
#endif

#if GL_EXT_framebuffer_multisample_blit_scaled
#define GL_SCALED_RESOLVE_FASTEST_EXT                        0x90BA
#define GL_SCALED_RESOLVE_NICEST_EXT                         0x90BB
#endif

#if GL_EXT_framebuffer_object
#define GL_FRAMEBUFFER_EXT                                   0x8D40
#define GL_RENDERBUFFER_EXT                                  0x8D41
#define GL_STENCIL_INDEX1_EXT                                0x8D46
#define GL_STENCIL_INDEX4_EXT                                0x8D47
#define GL_STENCIL_INDEX8_EXT                                0x8D48
#define GL_STENCIL_INDEX16_EXT                               0x8D49
#define GL_RENDERBUFFER_WIDTH_EXT                            0x8D42
#define GL_RENDERBUFFER_HEIGHT_EXT                           0x8D43
#define GL_RENDERBUFFER_INTERNAL_FORMAT_EXT                  0x8D44
#define GL_RENDERBUFFER_RED_SIZE_EXT                         0x8D50
#define GL_RENDERBUFFER_GREEN_SIZE_EXT                       0x8D51
#define GL_RENDERBUFFER_BLUE_SIZE_EXT                        0x8D52
#define GL_RENDERBUFFER_ALPHA_SIZE_EXT                       0x8D53
#define GL_RENDERBUFFER_DEPTH_SIZE_EXT                       0x8D54
#define GL_RENDERBUFFER_STENCIL_SIZE_EXT                     0x8D55
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT            0x8CD0
#define GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT            0x8CD1
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL_EXT          0x8CD2
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE_EXT  0x8CD3
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_EXT     0x8CD4
#define GL_COLOR_ATTACHMENT0_EXT                             0x8CE0
#define GL_COLOR_ATTACHMENT1_EXT                             0x8CE1
#define GL_COLOR_ATTACHMENT2_EXT                             0x8CE2
#define GL_COLOR_ATTACHMENT3_EXT                             0x8CE3
#define GL_COLOR_ATTACHMENT4_EXT                             0x8CE4
#define GL_COLOR_ATTACHMENT5_EXT                             0x8CE5
#define GL_COLOR_ATTACHMENT6_EXT                             0x8CE6
#define GL_COLOR_ATTACHMENT7_EXT                             0x8CE7
#define GL_COLOR_ATTACHMENT8_EXT                             0x8CE8
#define GL_COLOR_ATTACHMENT9_EXT                             0x8CE9
#define GL_COLOR_ATTACHMENT10_EXT                            0x8CEA
#define GL_COLOR_ATTACHMENT11_EXT                            0x8CEB
#define GL_COLOR_ATTACHMENT12_EXT                            0x8CEC
#define GL_COLOR_ATTACHMENT13_EXT                            0x8CED
#define GL_COLOR_ATTACHMENT14_EXT                            0x8CEE
#define GL_COLOR_ATTACHMENT15_EXT                            0x8CEF
#define GL_DEPTH_ATTACHMENT_EXT                              0x8D00
#define GL_STENCIL_ATTACHMENT_EXT                            0x8D20
#define GL_FRAMEBUFFER_COMPLETE_EXT                          0x8CD5
#define GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT             0x8CD6
#define GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT     0x8CD7
#define GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT             0x8CD9
#define GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT                0x8CDA
#define GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT            0x8CDB
#define GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT            0x8CDC
#define GL_FRAMEBUFFER_UNSUPPORTED_EXT                       0x8CDD
#define GL_FRAMEBUFFER_BINDING_EXT                           0x8CA6
#define GL_RENDERBUFFER_BINDING_EXT                          0x8CA7
#define GL_MAX_COLOR_ATTACHMENTS_EXT                         0x8CDF
#define GL_MAX_RENDERBUFFER_SIZE_EXT                         0x84E8
#define GL_INVALID_FRAMEBUFFER_OPERATION_EXT                 0x0506
#endif

#if GL_EXT_framebuffer_sRGB
#define GL_FRAMEBUFFER_SRGB_EXT                              0x8DB9
#define GL_FRAMEBUFFER_SRGB_CAPABLE_EXT                      0x8DBA
#endif

#if GL_EXT_geometry_shader4
#define GL_GEOMETRY_SHADER_EXT                               0x8DD9
#define GL_GEOMETRY_VERTICES_OUT_EXT                         0x8DDA
#define GL_GEOMETRY_INPUT_TYPE_EXT                           0x8DDB
#define GL_GEOMETRY_OUTPUT_TYPE_EXT                          0x8DDC
#define GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT              0x8C29
#define GL_MAX_GEOMETRY_VARYING_COMPONENTS_EXT               0x8DDD
#define GL_MAX_VERTEX_VARYING_COMPONENTS_EXT                 0x8DDE
#define GL_MAX_VARYING_COMPONENTS_EXT                        0x8B4B
#define GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT               0x8DDF
#define GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT                  0x8DE0
#define GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT          0x8DE1
#define GL_LINES_ADJACENCY_EXT                               0xA
#define GL_LINE_STRIP_ADJACENCY_EXT                          0xB
#define GL_TRIANGLES_ADJACENCY_EXT                           0xC
#define GL_TRIANGLE_STRIP_ADJACENCY_EXT                      0xD
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT          0x8DA8
#define GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_EXT            0x8DA9
#define GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT                0x8DA7
#define GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT          0x8CD4
#define GL_PROGRAM_POINT_SIZE_EXT                            0x8642
#endif

#if GL_EXT_gpu_shader4
#define GL_VERTEX_ATTRIB_ARRAY_INTEGER_EXT                   0x88FD
#define GL_SAMPLER_1D_ARRAY_EXT                              0x8DC0
#define GL_SAMPLER_2D_ARRAY_EXT                              0x8DC1
#define GL_SAMPLER_BUFFER_EXT                                0x8DC2
#define GL_SAMPLER_1D_ARRAY_SHADOW_EXT                       0x8DC3
#define GL_SAMPLER_2D_ARRAY_SHADOW_EXT                       0x8DC4
#define GL_SAMPLER_CUBE_SHADOW_EXT                           0x8DC5
#define GL_UNSIGNED_INT_VEC2_EXT                             0x8DC6
#define GL_UNSIGNED_INT_VEC3_EXT                             0x8DC7
#define GL_UNSIGNED_INT_VEC4_EXT                             0x8DC8
#define GL_INT_SAMPLER_1D_EXT                                0x8DC9
#define GL_INT_SAMPLER_2D_EXT                                0x8DCA
#define GL_INT_SAMPLER_3D_EXT                                0x8DCB
#define GL_INT_SAMPLER_CUBE_EXT                              0x8DCC
#define GL_INT_SAMPLER_2D_RECT_EXT                           0x8DCD
#define GL_INT_SAMPLER_1D_ARRAY_EXT                          0x8DCE
#define GL_INT_SAMPLER_2D_ARRAY_EXT                          0x8DCF
#define GL_INT_SAMPLER_BUFFER_EXT                            0x8DD0
#define GL_UNSIGNED_INT_SAMPLER_1D_EXT                       0x8DD1
#define GL_UNSIGNED_INT_SAMPLER_2D_EXT                       0x8DD2
#define GL_UNSIGNED_INT_SAMPLER_3D_EXT                       0x8DD3
#define GL_UNSIGNED_INT_SAMPLER_CUBE_EXT                     0x8DD4
#define GL_UNSIGNED_INT_SAMPLER_2D_RECT_EXT                  0x8DD5
#define GL_UNSIGNED_INT_SAMPLER_1D_ARRAY_EXT                 0x8DD6
#define GL_UNSIGNED_INT_SAMPLER_2D_ARRAY_EXT                 0x8DD7
#define GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT                   0x8DD8
#define GL_MIN_PROGRAM_TEXEL_OFFSET_EXT                      0x8904
#define GL_MAX_PROGRAM_TEXEL_OFFSET_EXT                      0x8905
#endif

#if GL_EXT_histogram
#define GL_HISTOGRAM_EXT                                     0x8024
#define GL_PROXY_HISTOGRAM_EXT                               0x8025
#define GL_HISTOGRAM_WIDTH_EXT                               0x8026
#define GL_HISTOGRAM_FORMAT_EXT                              0x8027
#define GL_HISTOGRAM_RED_SIZE_EXT                            0x8028
#define GL_HISTOGRAM_GREEN_SIZE_EXT                          0x8029
#define GL_HISTOGRAM_BLUE_SIZE_EXT                           0x802A
#define GL_HISTOGRAM_ALPHA_SIZE_EXT                          0x802B
#define GL_HISTOGRAM_LUMINANCE_SIZE_EXT                      0x802C
#define GL_HISTOGRAM_SINK_EXT                                0x802D
#define GL_MINMAX_EXT                                        0x802E
#define GL_MINMAX_FORMAT_EXT                                 0x802F
#define GL_MINMAX_SINK_EXT                                   0x8030
#define GL_TABLE_TOO_LARGE_EXT                               0x8031
#endif

#if GL_EXT_packed_depth_stencil
#define GL_DEPTH_STENCIL_EXT                                 0x84F9
#define GL_UNSIGNED_INT_24_8_EXT                             0x84FA
#define GL_DEPTH24_STENCIL8_EXT                              0x88F0
#define GL_TEXTURE_STENCIL_SIZE_EXT                          0x88F1
#endif

#if GL_EXT_packed_float
#define GL_R11F_G11F_B10F_EXT                                0x8C3A
#define GL_UNSIGNED_INT_10F_11F_11F_REV_EXT                  0x8C3B
#define GL_RGBA_SIGNED_COMPONENTS_EXT                        0x8C3C
#endif

#if GL_EXT_packed_pixels
#define GL_UNSIGNED_BYTE_3_3_2_EXT                           0x8032
#define GL_UNSIGNED_SHORT_4_4_4_4_EXT                        0x8033
#define GL_UNSIGNED_SHORT_5_5_5_1_EXT                        0x8034
#define GL_UNSIGNED_INT_8_8_8_8_EXT                          0x8035
#define GL_UNSIGNED_INT_10_10_10_2_EXT                       0x8036
#endif

#if GL_EXT_paletted_texture
#define GL_COLOR_INDEX1_EXT                                  0x80E2
#define GL_COLOR_INDEX2_EXT                                  0x80E3
#define GL_COLOR_INDEX4_EXT                                  0x80E4
#define GL_COLOR_INDEX8_EXT                                  0x80E5
#define GL_COLOR_INDEX12_EXT                                 0x80E6
#define GL_COLOR_INDEX16_EXT                                 0x80E7
#define GL_TEXTURE_INDEX_SIZE_EXT                            0x80ED
#endif

#if GL_EXT_polygon_offset
#define GL_POLYGON_OFFSET_EXT                                0x8037
#define GL_POLYGON_OFFSET_FACTOR_EXT                         0x8038
#define GL_POLYGON_OFFSET_BIAS_EXT                           0x8039
#endif

#if GL_EXT_provoking_vertex
#define GL_FIRST_VERTEX_CONVENTION_EXT                       0x8E4D
#define GL_LAST_VERTEX_CONVENTION_EXT                        0x8E4E
#define GL_PROVOKING_VERTEX_EXT                              0x8E4F
#define GL_QUADS_FOLLOW_PROVOKING_VERTEX_CONVENTION_EXT      0x8E4C
#endif

#if GL_EXT_rescale_normal
#define GL_RESCALE_NORMAL_EXT                                0x803A
#endif

#if GL_EXT_secondary_color
#define GL_COLOR_SUM_EXT                                     0x8458
#define GL_CURRENT_SECONDARY_COLOR_EXT                       0x8459
#define GL_SECONDARY_COLOR_ARRAY_SIZE_EXT                    0x845A
#define GL_SECONDARY_COLOR_ARRAY_TYPE_EXT                    0x845B
#define GL_SECONDARY_COLOR_ARRAY_STRIDE_EXT                  0x845C
#define GL_SECONDARY_COLOR_ARRAY_POINTER_EXT                 0x845D
#define GL_SECONDARY_COLOR_ARRAY_EXT                         0x845E
#endif

#if GL_EXT_separate_specular_color
#define GL_LIGHT_MODEL_COLOR_CONTROL_EXT                     0x81F8
#define GL_SINGLE_COLOR_EXT                                  0x81F9
#define GL_SEPARATE_SPECULAR_COLOR_EXT                       0x81FA
#endif

#if GL_EXT_shared_texture_palette
#define GL_SHARED_TEXTURE_PALETTE_EXT                        0x81FB
#endif

#if GL_EXT_stencil_two_side
#define GL_STENCIL_TEST_TWO_SIDE_EXT                         0x8910
#define GL_ACTIVE_STENCIL_FACE_EXT                           0x8911
#endif

#if GL_EXT_stencil_wrap
#define GL_INCR_WRAP_EXT                                     0x8507
#define GL_DECR_WRAP_EXT                                     0x8508
#endif

#if GL_EXT_texture
#define GL_ALPHA4_EXT                                        0x803B
#define GL_ALPHA8_EXT                                        0x803C
#define GL_ALPHA12_EXT                                       0x803D
#define GL_ALPHA16_EXT                                       0x803E
#define GL_LUMINANCE4_EXT                                    0x803F
#define GL_LUMINANCE8_EXT                                    0x8040
#define GL_LUMINANCE12_EXT                                   0x8041
#define GL_LUMINANCE16_EXT                                   0x8042
#define GL_LUMINANCE4_ALPHA4_EXT                             0x8043
#define GL_LUMINANCE6_ALPHA2_EXT                             0x8044
#define GL_LUMINANCE8_ALPHA8_EXT                             0x8045
#define GL_LUMINANCE12_ALPHA4_EXT                            0x8046
#define GL_LUMINANCE12_ALPHA12_EXT                           0x8047
#define GL_LUMINANCE16_ALPHA16_EXT                           0x8048
#define GL_INTENSITY_EXT                                     0x8049
#define GL_INTENSITY4_EXT                                    0x804A
#define GL_INTENSITY8_EXT                                    0x804B
#define GL_INTENSITY12_EXT                                   0x804C
#define GL_INTENSITY16_EXT                                   0x804D
#define GL_RGB2_EXT                                          0x804E
#define GL_RGB4_EXT                                          0x804F
#define GL_RGB5_EXT                                          0x8050
#define GL_RGB8_EXT                                          0x8051
#define GL_RGB10_EXT                                         0x8052
#define GL_RGB12_EXT                                         0x8053
#define GL_RGB16_EXT                                         0x8054
#define GL_RGBA2_EXT                                         0x8055
#define GL_RGBA4_EXT                                         0x8056
#define GL_RGB5_A1_EXT                                       0x8057
#define GL_RGBA8_EXT                                         0x8058
#define GL_RGB10_A2_EXT                                      0x8059
#define GL_RGBA12_EXT                                        0x805A
#define GL_RGBA16_EXT                                        0x805B
#define GL_TEXTURE_RED_SIZE_EXT                              0x805C
#define GL_TEXTURE_GREEN_SIZE_EXT                            0x805D
#define GL_TEXTURE_BLUE_SIZE_EXT                             0x805E
#define GL_TEXTURE_ALPHA_SIZE_EXT                            0x805F
#define GL_TEXTURE_LUMINANCE_SIZE_EXT                        0x8060
#define GL_TEXTURE_INTENSITY_SIZE_EXT                        0x8061
#define GL_REPLACE_EXT                                       0x8062
#define GL_PROXY_TEXTURE_1D_EXT                              0x8063
#define GL_PROXY_TEXTURE_2D_EXT                              0x8064
#define GL_TEXTURE_TOO_LARGE_EXT                             0x8065
#endif

#if GL_EXT_texture3D
#define GL_PACK_SKIP_IMAGES_EXT                              0x806B
#define GL_PACK_IMAGE_HEIGHT_EXT                             0x806C
#define GL_UNPACK_SKIP_IMAGES_EXT                            0x806D
#define GL_UNPACK_IMAGE_HEIGHT_EXT                           0x806E
#define GL_TEXTURE_3D_EXT                                    0x806F
#define GL_PROXY_TEXTURE_3D_EXT                              0x8070
#define GL_TEXTURE_DEPTH_EXT                                 0x8071
#define GL_TEXTURE_WRAP_R_EXT                                0x8072
#define GL_MAX_3D_TEXTURE_SIZE_EXT                           0x8073
#endif

#if GL_EXT_texture_array
#define GL_TEXTURE_1D_ARRAY_EXT                              0x8C18
#define GL_PROXY_TEXTURE_1D_ARRAY_EXT                        0x8C19
#define GL_TEXTURE_2D_ARRAY_EXT                              0x8C1A
#define GL_PROXY_TEXTURE_2D_ARRAY_EXT                        0x8C1B
#define GL_TEXTURE_BINDING_1D_ARRAY_EXT                      0x8C1C
#define GL_TEXTURE_BINDING_2D_ARRAY_EXT                      0x8C1D
#define GL_MAX_ARRAY_TEXTURE_LAYERS_EXT                      0x88FF
#define GL_COMPARE_REF_DEPTH_TO_TEXTURE_EXT                  0x884E
/* reuse GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT */
/* reuse GL_SAMPLER_1D_ARRAY_EXT */
/* reuse GL_SAMPLER_2D_ARRAY_EXT */
/* reuse GL_SAMPLER_1D_ARRAY_SHADOW_EXT */
/* reuse GL_SAMPLER_2D_ARRAY_SHADOW_EXT */
#endif

#if GL_EXT_texture_compression_s3tc
#define GL_COMPRESSED_RGB_S3TC_DXT1_EXT                      0x83F0
#define GL_COMPRESSED_RGBA_S3TC_DXT1_EXT                     0x83F1
#define GL_COMPRESSED_RGBA_S3TC_DXT3_EXT                     0x83F2
#define GL_COMPRESSED_RGBA_S3TC_DXT5_EXT                     0x83F3
#endif

#if GL_EXT_texture_cube_map
#define GL_NORMAL_MAP_EXT                                    0x8511
#define GL_REFLECTION_MAP_EXT                                0x8512
#define GL_TEXTURE_CUBE_MAP_EXT                              0x8513
#define GL_TEXTURE_BINDING_CUBE_MAP_EXT                      0x8514
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT                   0x8515
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X_EXT                   0x8516
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y_EXT                   0x8517
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_EXT                   0x8518
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z_EXT                   0x8519
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_EXT                   0x851A
#define GL_PROXY_TEXTURE_CUBE_MAP_EXT                        0x851B
#define GL_MAX_CUBE_MAP_TEXTURE_SIZE_EXT                     0x851C
#endif

#if GL_EXT_texture_env_combine
#define GL_COMBINE_EXT                                       0x8570
#define GL_COMBINE_RGB_EXT                                   0x8571
#define GL_COMBINE_ALPHA_EXT                                 0x8572
#define GL_RGB_SCALE_EXT                                     0x8573
#define GL_ADD_SIGNED_EXT                                    0x8574
#define GL_INTERPOLATE_EXT                                   0x8575
#define GL_CONSTANT_EXT                                      0x8576
#define GL_PRIMARY_COLOR_EXT                                 0x8577
#define GL_PREVIOUS_EXT                                      0x8578
#define GL_SOURCE0_RGB_EXT                                   0x8580
#define GL_SOURCE1_RGB_EXT                                   0x8581
#define GL_SOURCE2_RGB_EXT                                   0x8582
#define GL_SOURCE0_ALPHA_EXT                                 0x8588
#define GL_SOURCE1_ALPHA_EXT                                 0x8589
#define GL_SOURCE2_ALPHA_EXT                                 0x858A
#define GL_OPERAND0_RGB_EXT                                  0x8590
#define GL_OPERAND1_RGB_EXT                                  0x8591
#define GL_OPERAND2_RGB_EXT                                  0x8592
#define GL_OPERAND0_ALPHA_EXT                                0x8598
#define GL_OPERAND1_ALPHA_EXT                                0x8599
#define GL_OPERAND2_ALPHA_EXT                                0x859A
#endif

#if GL_EXT_texture_filter_anisotropic
#define GL_TEXTURE_MAX_ANISOTROPY_EXT                        0x84FE
#define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT                    0x84FF
#endif

#if GL_EXT_texture_integer
#define GL_RGBA_INTEGER_MODE_EXT                             0x8D9E
#define GL_RGBA32UI_EXT                                      0x8D70
#define GL_RGB32UI_EXT                                       0x8D71
#define GL_ALPHA32UI_EXT                                     0x8D72
#define GL_INTENSITY32UI_EXT                                 0x8D73
#define GL_LUMINANCE32UI_EXT                                 0x8D74
#define GL_LUMINANCE_ALPHA32UI_EXT                           0x8D75
#define GL_RGBA16UI_EXT                                      0x8D76
#define GL_RGB16UI_EXT                                       0x8D77
#define GL_ALPHA16UI_EXT                                     0x8D78
#define GL_INTENSITY16UI_EXT                                 0x8D79
#define GL_LUMINANCE16UI_EXT                                 0x8D7A
#define GL_LUMINANCE_ALPHA16UI_EXT                           0x8D7B
#define GL_RGBA8UI_EXT                                       0x8D7C
#define GL_RGB8UI_EXT                                        0x8D7D
#define GL_ALPHA8UI_EXT                                      0x8D7E
#define GL_INTENSITY8UI_EXT                                  0x8D7F
#define GL_LUMINANCE8UI_EXT                                  0x8D80
#define GL_LUMINANCE_ALPHA8UI_EXT                            0x8D81
#define GL_RGBA32I_EXT                                       0x8D82
#define GL_RGB32I_EXT                                        0x8D83
#define GL_ALPHA32I_EXT                                      0x8D84
#define GL_INTENSITY32I_EXT                                  0x8D85
#define GL_LUMINANCE32I_EXT                                  0x8D86
#define GL_LUMINANCE_ALPHA32I_EXT                            0x8D87
#define GL_RGBA16I_EXT                                       0x8D88
#define GL_RGB16I_EXT                                        0x8D89
#define GL_ALPHA16I_EXT                                      0x8D8A
#define GL_INTENSITY16I_EXT                                  0x8D8B
#define GL_LUMINANCE16I_EXT                                  0x8D8C
#define GL_LUMINANCE_ALPHA16I_EXT                            0x8D8D
#define GL_RGBA8I_EXT                                        0x8D8E
#define GL_RGB8I_EXT                                         0x8D8F
#define GL_ALPHA8I_EXT                                       0x8D90
#define GL_INTENSITY8I_EXT                                   0x8D91
#define GL_LUMINANCE8I_EXT                                   0x8D92
#define GL_LUMINANCE_ALPHA8I_EXT                             0x8D93
#define GL_RED_INTEGER_EXT                                   0x8D94
#define GL_GREEN_INTEGER_EXT                                 0x8D95
#define GL_BLUE_INTEGER_EXT                                  0x8D96
#define GL_ALPHA_INTEGER_EXT                                 0x8D97
#define GL_RGB_INTEGER_EXT                                   0x8D98
#define GL_RGBA_INTEGER_EXT                                  0x8D99
#define GL_BGR_INTEGER_EXT                                   0x8D9A
#define GL_BGRA_INTEGER_EXT                                  0x8D9B
#define GL_LUMINANCE_INTEGER_EXT                             0x8D9C
#define GL_LUMINANCE_ALPHA_INTEGER_EXT                       0x8D9D
#endif

#if GL_EXT_texture_lod_bias
#define GL_MAX_TEXTURE_LOD_BIAS_EXT                          0x84FD
#define GL_TEXTURE_FILTER_CONTROL_EXT                        0x8500
#define GL_TEXTURE_LOD_BIAS_EXT                              0x8501
#endif

#if GL_EXT_texture_mirror_clamp
#define GL_MIRROR_CLAMP_EXT                                  0x8742
#define GL_MIRROR_CLAMP_TO_EDGE_EXT                          0x8743
#define GL_MIRROR_CLAMP_TO_BORDER_EXT                        0x8912
#endif

#if GL_EXT_texture_object
#define GL_TEXTURE_PRIORITY_EXT                              0x8066
#define GL_TEXTURE_RESIDENT_EXT                              0x8067
#define GL_TEXTURE_1D_BINDING_EXT                            0x8068
#define GL_TEXTURE_2D_BINDING_EXT                            0x8069
#define GL_TEXTURE_3D_BINDING_EXT                            0x806A
#endif

#if GL_EXT_texture_rectangle
#define GL_TEXTURE_RECTANGLE_EXT                             0x84F5
#define GL_TEXTURE_BINDING_RECTANGLE_EXT                     0x84F6
#define GL_PROXY_TEXTURE_RECTANGLE_EXT                       0x84F7
#define GL_MAX_RECTANGLE_TEXTURE_SIZE_EXT                    0x84F8
#endif

#if GL_EXT_texture_shared_exponent
#define GL_RGB9_E5_EXT                                       0x8C3D
#define GL_UNSIGNED_INT_5_9_9_9_REV_EXT                      0x8C3E
#define GL_TEXTURE_SHARED_SIZE_EXT                           0x8C3F
#endif

#if GL_EXT_texture_sRGB
#define GL_SRGB_EXT                                          0x8C40
#define GL_SRGB8_EXT                                         0x8C41
#define GL_SRGB_ALPHA_EXT                                    0x8C42
#define GL_SRGB8_ALPHA8_EXT                                  0x8C43
#define GL_SLUMINANCE_ALPHA_EXT                              0x8C44
#define GL_SLUMINANCE8_ALPHA8_EXT                            0x8C45
#define GL_SLUMINANCE_EXT                                    0x8C46
#define GL_SLUMINANCE8_EXT                                   0x8C47
#define GL_COMPRESSED_SRGB_EXT                               0x8C48
#define GL_COMPRESSED_SRGB_ALPHA_EXT                         0x8C49
#define GL_COMPRESSED_SLUMINANCE_EXT                         0x8C4A
#define GL_COMPRESSED_SLUMINANCE_ALPHA_EXT                   0x8C4B
#define GL_COMPRESSED_SRGB_S3TC_DXT1_EXT                     0x8C4C
#define GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT               0x8C4D
#define GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT               0x8C4E
#define GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT               0x8C4F
#endif

#if GL_EXT_texture_sRGB_decode
#define GL_TEXTURE_SRGB_DECODE_EXT                           0x8A48
#define GL_DECODE_EXT                                        0x8A49
#define GL_SKIP_DECODE_EXT                                   0x8A4A
#endif

#if GL_EXT_timer_query
#define GL_TIME_ELAPSED_EXT                                  0x88BF
#endif

#if GL_EXT_transform_feedback
#define GL_TRANSFORM_FEEDBACK_BUFFER_EXT                     0x8C8E
#define GL_TRANSFORM_FEEDBACK_BUFFER_START_EXT               0x8C84
#define GL_TRANSFORM_FEEDBACK_BUFFER_SIZE_EXT                0x8C85
#define GL_TRANSFORM_FEEDBACK_BUFFER_BINDING_EXT             0x8C8F
#define GL_INTERLEAVED_ATTRIBS_EXT                           0x8C8C
#define GL_SEPARATE_ATTRIBS_EXT                              0x8C8D
#define GL_PRIMITIVES_GENERATED_EXT                          0x8C87
#define GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN_EXT         0x8C88
#define GL_RASTERIZER_DISCARD_EXT                            0x8C89
#define GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS_EXT 0x8C8A
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS_EXT       0x8C8B
#define GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS_EXT    0x8C80
#define GL_TRANSFORM_FEEDBACK_VARYINGS_EXT                   0x8C83
#define GL_TRANSFORM_FEEDBACK_BUFFER_MODE_EXT                0x8C7F
#define GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH_EXT         0x8C76
#endif

#if GL_EXT_vertex_array
#define GL_VERTEX_ARRAY_EXT                                  0x8074
#define GL_NORMAL_ARRAY_EXT                                  0x8075
#define GL_COLOR_ARRAY_EXT                                   0x8076
#define GL_INDEX_ARRAY_EXT                                   0x8077
#define GL_TEXTURE_COORD_ARRAY_EXT                           0x8078
#define GL_EDGE_FLAG_ARRAY_EXT                               0x8079
#define GL_VERTEX_ARRAY_SIZE_EXT                             0x807A
#define GL_VERTEX_ARRAY_TYPE_EXT                             0x807B
#define GL_VERTEX_ARRAY_STRIDE_EXT                           0x807C
#define GL_VERTEX_ARRAY_COUNT_EXT                            0x807D
#define GL_NORMAL_ARRAY_TYPE_EXT                             0x807E
#define GL_NORMAL_ARRAY_STRIDE_EXT                           0x807F
#define GL_NORMAL_ARRAY_COUNT_EXT                            0x8080
#define GL_COLOR_ARRAY_SIZE_EXT                              0x8081
#define GL_COLOR_ARRAY_TYPE_EXT                              0x8082
#define GL_COLOR_ARRAY_STRIDE_EXT                            0x8083
#define GL_COLOR_ARRAY_COUNT_EXT                             0x8084
#define GL_INDEX_ARRAY_TYPE_EXT                              0x8085
#define GL_INDEX_ARRAY_STRIDE_EXT                            0x8086
#define GL_INDEX_ARRAY_COUNT_EXT                             0x8087
#define GL_TEXTURE_COORD_ARRAY_SIZE_EXT                      0x8088
#define GL_TEXTURE_COORD_ARRAY_TYPE_EXT                      0x8089
#define GL_TEXTURE_COORD_ARRAY_STRIDE_EXT                    0x808A
#define GL_TEXTURE_COORD_ARRAY_COUNT_EXT                     0x808B
#define GL_EDGE_FLAG_ARRAY_STRIDE_EXT                        0x808C
#define GL_EDGE_FLAG_ARRAY_COUNT_EXT                         0x808D
#define GL_VERTEX_ARRAY_POINTER_EXT                          0x808E
#define GL_NORMAL_ARRAY_POINTER_EXT                          0x808F
#define GL_COLOR_ARRAY_POINTER_EXT                           0x8090
#define GL_INDEX_ARRAY_POINTER_EXT                           0x8091
#define GL_TEXTURE_COORD_ARRAY_POINTER_EXT                   0x8092
#define GL_EDGE_FLAG_ARRAY_POINTER_EXT                       0x8093
#endif

#if GL_APPLE_aux_depth_stencil
#define GL_AUX_DEPTH_STENCIL_APPLE                           0x8A14
#endif

#if GL_APPLE_client_storage
#define GL_UNPACK_CLIENT_STORAGE_APPLE                       0x85B2
#endif

#if GL_APPLE_element_array
#define GL_ELEMENT_ARRAY_APPLE                               0x8A0C
#define GL_ELEMENT_ARRAY_TYPE_APPLE                          0x8A0D
#define GL_ELEMENT_ARRAY_POINTER_APPLE                       0x8A0E
#endif

#if GL_APPLE_fence
#define GL_DRAW_PIXELS_APPLE                                 0x8A0A
#define GL_FENCE_APPLE                                       0x8A0B
#define GL_BUFFER_OBJECT_APPLE                               0x85B3
#endif

#if GL_APPLE_float_pixels
#define GL_HALF_APPLE                                        0x140B
#define GL_COLOR_FLOAT_APPLE                                 0x8A0F
#define GL_RGBA_FLOAT32_APPLE                                0x8814
#define GL_RGB_FLOAT32_APPLE                                 0x8815
#define GL_ALPHA_FLOAT32_APPLE                               0x8816
#define GL_INTENSITY_FLOAT32_APPLE                           0x8817
#define GL_LUMINANCE_FLOAT32_APPLE                           0x8818
#define GL_LUMINANCE_ALPHA_FLOAT32_APPLE                     0x8819
#define GL_RGBA_FLOAT16_APPLE                                0x881A
#define GL_RGB_FLOAT16_APPLE                                 0x881B
#define GL_ALPHA_FLOAT16_APPLE                               0x881C
#define GL_INTENSITY_FLOAT16_APPLE                           0x881D
#define GL_LUMINANCE_FLOAT16_APPLE                           0x881E
#define GL_LUMINANCE_ALPHA_FLOAT16_APPLE                     0x881F
#endif

#if GL_APPLE_flush_buffer_range
#define GL_BUFFER_SERIALIZED_MODIFY_APPLE                    0x8A12
#define GL_BUFFER_FLUSHING_UNMAP_APPLE                       0x8A13
#endif

#if GL_APPLE_object_purgeable
#define GL_RELEASED_APPLE                                    0x8A19
#define GL_VOLATILE_APPLE                                    0x8A1A
#define GL_RETAINED_APPLE                                    0x8A1B
#define GL_UNDEFINED_APPLE                                   0x8A1C
#define GL_PURGEABLE_APPLE                                   0x8A1D
#endif

#if GL_APPLE_pixel_buffer
#define GL_MIN_PBUFFER_VIEWPORT_DIMS_APPLE                   0x8A10
#endif

#if GL_APPLE_rgb_422
#define GL_RGB_422_APPLE                                     0x8A1F
#endif

#if GL_APPLE_row_bytes
#define GL_PACK_ROW_BYTES_APPLE                              0x8A15
#define GL_UNPACK_ROW_BYTES_APPLE                            0x8A16
#define GL_PACK_IMAGE_BYTES_APPLE                            0x8A17
#define GL_UNPACK_IMAGE_BYTES_APPLE                          0x8A18
#endif

#if GL_APPLE_specular_vector
#define GL_LIGHT_MODEL_SPECULAR_VECTOR_APPLE                 0x85B0
#endif

#if GL_APPLE_texture_range
#define GL_TEXTURE_RANGE_LENGTH_APPLE                        0x85B7
#define GL_TEXTURE_RANGE_POINTER_APPLE                       0x85B8
#define GL_TEXTURE_STORAGE_HINT_APPLE                        0x85BC
#define GL_TEXTURE_MINIMIZE_STORAGE_APPLE                    0x85B6
#define GL_STORAGE_PRIVATE_APPLE                             0x85BD
#define GL_STORAGE_CACHED_APPLE                              0x85BE
#define GL_STORAGE_SHARED_APPLE                              0x85BF
#endif

#if GL_APPLE_transform_hint
#define GL_TRANSFORM_HINT_APPLE                              0x85B1
#endif

#if GL_APPLE_vertex_array_object
#define GL_VERTEX_ARRAY_BINDING_APPLE                        0x85B5
#endif

#if GL_APPLE_vertex_array_range
#define GL_VERTEX_ARRAY_RANGE_APPLE                          0x851D
#define GL_VERTEX_ARRAY_RANGE_LENGTH_APPLE                   0x851E
#define GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_APPLE              0x8520
#define GL_VERTEX_ARRAY_RANGE_POINTER_APPLE                  0x8521
#define GL_VERTEX_ARRAY_STORAGE_HINT_APPLE                   0x851F
#define GL_STORAGE_CLIENT_APPLE                              0x85B4
#define GL_STORAGE_PRIVATE_APPLE                             0x85BD
#define GL_STORAGE_CACHED_APPLE                              0x85BE
#define GL_STORAGE_SHARED_APPLE                              0x85BF
#endif

#if GL_APPLE_vertex_point_size
#define GL_VERTEX_POINT_SIZE_APPLE                           0x8A26
#define GL_CURRENT_POINT_SIZE_APPLE                          0x8A27
#define GL_POINT_SIZE_ARRAY_APPLE                            0x8B9C
#define GL_POINT_SIZE_ARRAY_TYPE_APPLE                       0x898A
#define GL_POINT_SIZE_ARRAY_STRIDE_APPLE                     0x898B
#define GL_POINT_SIZE_ARRAY_POINTER_APPLE                    0x898C
#define GL_POINT_SIZE_ARRAY_BUFFER_BINDING_APPLE             0x8B9F
#endif

#if GL_APPLE_vertex_program_evaluators
#define GL_VERTEX_ATTRIB_MAP1_APPLE                          0x8A00
#define GL_VERTEX_ATTRIB_MAP2_APPLE                          0x8A01
#define GL_VERTEX_ATTRIB_MAP1_SIZE_APPLE                     0x8A02
#define GL_VERTEX_ATTRIB_MAP1_COEFF_APPLE                    0x8A03
#define GL_VERTEX_ATTRIB_MAP1_ORDER_APPLE                    0x8A04
#define GL_VERTEX_ATTRIB_MAP1_DOMAIN_APPLE                   0x8A05
#define GL_VERTEX_ATTRIB_MAP2_SIZE_APPLE                     0x8A06
#define GL_VERTEX_ATTRIB_MAP2_COEFF_APPLE                    0x8A07
#define GL_VERTEX_ATTRIB_MAP2_ORDER_APPLE                    0x8A08
#define GL_VERTEX_ATTRIB_MAP2_DOMAIN_APPLE                   0x8A09
#endif

#if GL_APPLE_ycbcr_422
#define GL_YCBCR_422_APPLE                                   0x85B9
#endif

#if GL_APPLE_ycbcr_422 || GL_APPLE_rgb_422
#define GL_UNSIGNED_SHORT_8_8_APPLE                          0x85BA
#define GL_UNSIGNED_SHORT_8_8_REV_APPLE                      0x85BB
#endif

#if GL_ATI_array_rev_comps_in_4_bytes
#define GL_ARRAY_REV_COMPS_IN_4_BYTES_ATI                    0x897C
#endif

#if GL_ATI_blend_equation_separate
#define GL_ALPHA_BLEND_EQUATION_ATI                          0x883D
#endif

#if GL_ATI_blend_weighted_minmax
#define GL_MIN_WEIGHTED_ATI                                  0x877D
#define GL_MAX_WEIGHTED_ATI                                  0x877E
#endif

#if GL_ATI_pn_triangles
#define GL_PN_TRIANGLES_ATI                                  0x6090
#define GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATI            0x6091
#define GL_PN_TRIANGLES_POINT_MODE_ATI                       0x6092
#define GL_PN_TRIANGLES_NORMAL_MODE_ATI                      0x6093
#define GL_PN_TRIANGLES_TESSELATION_LEVEL_ATI                0x6094
#define GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATI                0x6095
#define GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATI                 0x6096
#define GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATI               0x6097
#define GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATI            0x6098
#endif

#if GL_ATI_point_cull_mode
#define GL_POINT_CULL_MODE_ATI                               0x60B3
#define GL_POINT_CULL_CENTER_ATI                             0x60B4
#define GL_POINT_CULL_CLIP_ATI                               0x60B5
#endif

#if GL_ATI_separate_stencil
#define GL_STENCIL_BACK_FUNC_ATI                             0x8800
#define GL_STENCIL_BACK_FAIL_ATI                             0x8801
#define GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI                  0x8802
#define GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI                  0x8803
#endif

#if GL_ATI_text_fragment_shader
#define GL_TEXT_FRAGMENT_SHADER_ATI                          0x8200
#endif

#if GL_ATI_texture_compression_3dc
#define GL_COMPRESSED_LUMINANCE_ALPHA_3DC_ATI                0x8837
#endif

#if GL_ATI_texture_env_combine3
#define GL_MODULATE_ADD_ATI                                  0x8744
#define GL_MODULATE_SIGNED_ADD_ATI                           0x8745
#define GL_MODULATE_SUBTRACT_ATI                             0x8746
#endif

#if GL_ATI_texture_float
#define GL_RGBA_FLOAT32_ATI                                  0x8814
#define GL_RGB_FLOAT32_ATI                                   0x8815
#define GL_ALPHA_FLOAT32_ATI                                 0x8816
#define GL_INTENSITY_FLOAT32_ATI                             0x8817
#define GL_LUMINANCE_FLOAT32_ATI                             0x8818
#define GL_LUMINANCE_ALPHA_FLOAT32_ATI                       0x8819
#define GL_RGBA_FLOAT16_ATI                                  0x881A
#define GL_RGB_FLOAT16_ATI                                   0x881B
#define GL_ALPHA_FLOAT16_ATI                                 0x881C
#define GL_INTENSITY_FLOAT16_ATI                             0x881D
#define GL_LUMINANCE_FLOAT16_ATI                             0x881E
#define GL_LUMINANCE_ALPHA_FLOAT16_ATI                       0x881F
#endif

#if GL_ATI_texture_mirror_once
#define GL_MIRROR_CLAMP_ATI                                  0x8742
#define GL_MIRROR_CLAMP_TO_EDGE_ATI                          0x8743
#endif

#if GL_ATIX_pn_triangles
#define GL_PN_TRIANGLES_ATIX                                 0x6090
#define GL_MAX_PN_TRIANGLES_TESSELATION_LEVEL_ATIX           0x6091
#define GL_PN_TRIANGLES_POINT_MODE_ATIX                      0x6092
#define GL_PN_TRIANGLES_NORMAL_MODE_ATIX                     0x6093
#define GL_PN_TRIANGLES_TESSELATION_LEVEL_ATIX               0x6094
#define GL_PN_TRIANGLES_POINT_MODE_LINEAR_ATIX               0x6095
#define GL_PN_TRIANGLES_POINT_MODE_CUBIC_ATIX                0x6096
#define GL_PN_TRIANGLES_NORMAL_MODE_LINEAR_ATIX              0x6097
#define GL_PN_TRIANGLES_NORMAL_MODE_QUADRATIC_ATIX           0x6098
#endif

#if GL_HP_convolution_border_modes
#define GL_IGNORE_BORDER_HP                                  0x8150
#define GL_CONSTANT_BORDER_HP                                0x8151
#define GL_REPLICATE_BORDER_HP                               0x8153
#define GL_CONVOLUTION_BORDER_COLOR_HP                       0x8154
#endif

#if GL_IBM_rasterpos_clip
#define GL_RASTER_POSITION_UNCLIPPED_IBM                     0x19262
#endif

#if GL_NV_conditional_render
#define GL_QUERY_WAIT_NV                                     0x8E13
#define GL_QUERY_NO_WAIT_NV                                  0x8E14
#define GL_QUERY_BY_REGION_WAIT_NV                           0x8E15
#define GL_QUERY_BY_REGION_NO_WAIT_NV                        0x8E16
#endif

#if GL_NV_depth_clamp
#define GL_DEPTH_CLAMP_NV                                    0x864F
#endif

#if GL_NV_fog_distance
#define GL_FOG_DISTANCE_MODE_NV                              0x855A
#define GL_EYE_RADIAL_NV                                     0x855B
#define GL_EYE_PLANE_ABSOLUTE_NV                             0x855C
/* reuse GL_EYE_PLANE */
#endif

#if GL_NV_fragment_program2
#define GL_MAX_PROGRAM_IF_DEPTH_NV                           0x88F6
#define GL_MAX_PROGRAM_LOOP_DEPTH_NV                         0x88F7
#define GL_MAX_PROGRAM_LOOP_COUNT_NV                         0x88F8
#endif

#if GL_NV_fragment_program2 || GL_NV_vertex_program2_option
#define GL_MAX_PROGRAM_EXEC_INSTRUCTIONS_NV                  0x88F4
#define GL_MAX_PROGRAM_CALL_DEPTH_NV                         0x88F5
#endif

#if GL_NV_light_max_exponent
#define GL_MAX_SHININESS_NV                                  0x8504
#define GL_MAX_SPOT_EXPONENT_NV                              0x8505
#endif

#if GL_NV_multisample_filter_hint
#define GL_MULTISAMPLE_FILTER_HINT_NV                        0x8534
#endif

#if GL_NV_point_sprite
#define GL_POINT_SPRITE_NV                                   0x8861
#define GL_COORD_REPLACE_NV                                  0x8862
#define GL_POINT_SPRITE_R_MODE_NV                            0x8863
#endif

#if GL_NV_register_combiners
#define GL_REGISTER_COMBINERS_NV                             0x8522
#define GL_VARIABLE_A_NV                                     0x8523
#define GL_VARIABLE_B_NV                                     0x8524
#define GL_VARIABLE_C_NV                                     0x8525
#define GL_VARIABLE_D_NV                                     0x8526
#define GL_VARIABLE_E_NV                                     0x8527
#define GL_VARIABLE_F_NV                                     0x8528
#define GL_VARIABLE_G_NV                                     0x8529
#define GL_CONSTANT_COLOR0_NV                                0x852A
#define GL_CONSTANT_COLOR1_NV                                0x852B
#define GL_PRIMARY_COLOR_NV                                  0x852C
#define GL_SECONDARY_COLOR_NV                                0x852D
#define GL_SPARE0_NV                                         0x852E
#define GL_SPARE1_NV                                         0x852F
#define GL_DISCARD_NV                                        0x8530
#define GL_E_TIMES_F_NV                                      0x8531
#define GL_SPARE0_PLUS_SECONDARY_COLOR_NV                    0x8532
#define GL_UNSIGNED_IDENTITY_NV                              0x8536
#define GL_UNSIGNED_INVERT_NV                                0x8537
#define GL_EXPAND_NORMAL_NV                                  0x8538
#define GL_EXPAND_NEGATE_NV                                  0x8539
#define GL_HALF_BIAS_NORMAL_NV                               0x853A
#define GL_HALF_BIAS_NEGATE_NV                               0x853B
#define GL_SIGNED_IDENTITY_NV                                0x853C
#define GL_SIGNED_NEGATE_NV                                  0x853D
#define GL_SCALE_BY_TWO_NV                                   0x853E
#define GL_SCALE_BY_FOUR_NV                                  0x853F
#define GL_SCALE_BY_ONE_HALF_NV                              0x8540
#define GL_BIAS_BY_NEGATIVE_ONE_HALF_NV                      0x8541
#define GL_COMBINER_INPUT_NV                                 0x8542
#define GL_COMBINER_MAPPING_NV                               0x8543
#define GL_COMBINER_COMPONENT_USAGE_NV                       0x8544
#define GL_COMBINER_AB_DOT_PRODUCT_NV                        0x8545
#define GL_COMBINER_CD_DOT_PRODUCT_NV                        0x8546
#define GL_COMBINER_MUX_SUM_NV                               0x8547
#define GL_COMBINER_SCALE_NV                                 0x8548
#define GL_COMBINER_BIAS_NV                                  0x8549
#define GL_COMBINER_AB_OUTPUT_NV                             0x854A
#define GL_COMBINER_CD_OUTPUT_NV                             0x854B
#define GL_COMBINER_SUM_OUTPUT_NV                            0x854C
#define GL_MAX_GENERAL_COMBINERS_NV                          0x854D
#define GL_NUM_GENERAL_COMBINERS_NV                          0x854E
#define GL_COLOR_SUM_CLAMP_NV                                0x854F
#define GL_COMBINER0_NV                                      0x8550
#define GL_COMBINER1_NV                                      0x8551
#define GL_COMBINER2_NV                                      0x8552
#define GL_COMBINER3_NV                                      0x8553
#define GL_COMBINER4_NV                                      0x8554
#define GL_COMBINER5_NV                                      0x8555
#define GL_COMBINER6_NV                                      0x8556
#define GL_COMBINER7_NV                                      0x8557
/* reuse GL_TEXTURE0_ARB */
/* reuse GL_TEXTURE1_ARB */
/* reuse GL_ZERO */
/* reuse GL_NONE */
/* reuse GL_FOG */
#endif

#if GL_NV_register_combiners2
#define GL_PER_STAGE_CONSTANTS_NV                            0x8535
#endif

#if GL_NV_texgen_reflection
#define GL_NORMAL_MAP_NV                                     0x8511
#define GL_REFLECTION_MAP_NV                                 0x8512
#endif

#if GL_NV_texture_shader
#define GL_RGBA_UNSIGNED_DOT_PRODUCT_MAPPING_NV              0x86D9
#define GL_UNSIGNED_INT_S8_S8_8_8_NV                         0x86DA
#define GL_UNSIGNED_INT_8_8_S8_S8_REV_NV                     0x86DB
#define GL_DSDT_MAG_INTENSITY_NV                             0x86DC
#define GL_TEXTURE_SHADER_NV                                 0x86DE
#define GL_SHADER_OPERATION_NV                               0x86DF
#define GL_CULL_MODES_NV                                     0x86E0
#define GL_OFFSET_TEXTURE_MATRIX_NV                          0x86E1
#define GL_OFFSET_TEXTURE_SCALE_NV                           0x86E2
#define GL_OFFSET_TEXTURE_BIAS_NV                            0x86E3
#define GL_OFFSET_TEXTURE_2D_MATRIX_NV                       GL_OFFSET_TEXTURE_MATRIX_NV
#define GL_OFFSET_TEXTURE_2D_SCALE_NV                        GL_OFFSET_TEXTURE_SCALE_NV
#define GL_OFFSET_TEXTURE_2D_BIAS_NV                         GL_OFFSET_TEXTURE_BIAS_NV
#define GL_PREVIOUS_TEXTURE_INPUT_NV                         0x86E4
#define GL_CONST_EYE_NV                                      0x86E5
#define GL_SHADER_CONSISTENT_NV                              0x86DD
#define GL_PASS_THROUGH_NV                                   0x86E6
#define GL_CULL_FRAGMENT_NV                                  0x86E7
#define GL_OFFSET_TEXTURE_2D_NV                              0x86E8
#define GL_OFFSET_TEXTURE_RECTANGLE_NV                       0x864C
#define GL_OFFSET_TEXTURE_RECTANGLE_SCALE_NV                 0x864D
#define GL_DEPENDENT_AR_TEXTURE_2D_NV                        0x86E9
#define GL_DEPENDENT_GB_TEXTURE_2D_NV                        0x86EA
#define GL_DOT_PRODUCT_NV                                    0x86EC
#define GL_DOT_PRODUCT_DEPTH_REPLACE_NV                      0x86ED
#define GL_DOT_PRODUCT_TEXTURE_2D_NV                         0x86EE
#define GL_DOT_PRODUCT_TEXTURE_RECTANGLE_NV                  0x864E
#define GL_DOT_PRODUCT_TEXTURE_CUBE_MAP_NV                   0x86F0
#define GL_DOT_PRODUCT_DIFFUSE_CUBE_MAP_NV                   0x86F1
#define GL_DOT_PRODUCT_REFLECT_CUBE_MAP_NV                   0x86F2
#define GL_DOT_PRODUCT_CONST_EYE_REFLECT_CUBE_MAP_NV         0x86F3
#define GL_HILO_NV                                           0x86F4
#define GL_DSDT_NV                                           0x86F5
#define GL_DSDT_MAG_NV                                       0x86F6
#define GL_DSDT_MAG_VIB_NV                                   0x86F7
#define GL_HILO16_NV                                         0x86F8
#define GL_SIGNED_HILO_NV                                    0x86F9
#define GL_SIGNED_HILO16_NV                                  0x86FA
#define GL_SIGNED_RGBA_NV                                    0x86FB
#define GL_SIGNED_RGBA8_NV                                   0x86FC
#define GL_SIGNED_RGB_NV                                     0x86FE
#define GL_SIGNED_RGB8_NV                                    0x86FF
#define GL_SIGNED_LUMINANCE_NV                               0x8701
#define GL_SIGNED_LUMINANCE8_NV                              0x8702
#define GL_SIGNED_LUMINANCE_ALPHA_NV                         0x8703
#define GL_SIGNED_LUMINANCE8_ALPHA8_NV                       0x8704
#define GL_SIGNED_ALPHA_NV                                   0x8705
#define GL_SIGNED_ALPHA8_NV                                  0x8706
#define GL_SIGNED_INTENSITY_NV                               0x8707
#define GL_SIGNED_INTENSITY8_NV                              0x8708
#define GL_DSDT8_NV                                          0x8709
#define GL_DSDT8_MAG8_NV                                     0x870A
#define GL_DSDT8_MAG8_INTENSITY8_NV                          0x870B
#define GL_SIGNED_RGB_UNSIGNED_ALPHA_NV                      0x870C
#define GL_SIGNED_RGB8_UNSIGNED_ALPHA8_NV                    0x870D
#define GL_HI_SCALE_NV                                       0x870E
#define GL_LO_SCALE_NV                                       0x870F
#define GL_DS_SCALE_NV                                       0x8710
#define GL_DT_SCALE_NV                                       0x8711
#define GL_MAGNITUDE_SCALE_NV                                0x8712
#define GL_VIBRANCE_SCALE_NV                                 0x8713
#define GL_HI_BIAS_NV                                        0x8714
#define GL_LO_BIAS_NV                                        0x8715
#define GL_DS_BIAS_NV                                        0x8716
#define GL_DT_BIAS_NV                                        0x8717
#define GL_MAGNITUDE_BIAS_NV                                 0x8718
#define GL_VIBRANCE_BIAS_NV                                  0x8719
#define GL_TEXTURE_BORDER_VALUES_NV                          0x871A
#define GL_TEXTURE_HI_SIZE_NV                                0x871B
#define GL_TEXTURE_LO_SIZE_NV                                0x871C
#define GL_TEXTURE_DS_SIZE_NV                                0x871D
#define GL_TEXTURE_DT_SIZE_NV                                0x871E
#define GL_TEXTURE_MAG_SIZE_NV                               0x871F
#endif

#if GL_NV_texture_shader2
#define GL_DOT_PRODUCT_TEXTURE_3D_NV                         0x86EF
#endif

#if GL_NV_texture_shader3
#define GL_OFFSET_PROJECTIVE_TEXTURE_2D_NV                   0x8850
#define GL_OFFSET_PROJECTIVE_TEXTURE_2D_SCALE_NV             0x8851
#define GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_NV            0x8852
#define GL_OFFSET_PROJECTIVE_TEXTURE_RECTANGLE_SCALE_NV      0x8853
#define GL_OFFSET_HILO_TEXTURE_2D_NV                         0x8854
#define GL_OFFSET_HILO_TEXTURE_RECTANGLE_NV                  0x8855
#define GL_OFFSET_HILO_PROJECTIVE_TEXTURE_2D_NV              0x8856
#define GL_OFFSET_HILO_PROJECTIVE_TEXTURE_RECTANGLE_NV       0x8857
#define GL_DEPENDENT_HILO_TEXTURE_2D_NV                      0x8858
#define GL_DEPENDENT_RGB_TEXTURE_3D_NV                       0x8859
#define GL_DEPENDENT_RGB_TEXTURE_CUBE_MAP_NV                 0x885A
#define GL_DOT_PRODUCT_PASS_THROUGH_NV                       0x885B
#define GL_DOT_PRODUCT_TEXTURE_1D_NV                         0x885C
#define GL_DOT_PRODUCT_AFFINE_DEPTH_REPLACE_NV               0x885D
#define GL_HILO8_NV                                          0x885E
#define GL_SIGNED_HILO8_NV                                   0x885F
#define GL_FORCE_BLUE_TO_ONE_NV                              0x8860
#endif

#if GL_NV_vertex_array_range
#define GL_VERTEX_ARRAY_RANGE_NV                             0x851D
#define GL_VERTEX_ARRAY_RANGE_LENGTH_NV                      0x851E
#define GL_VERTEX_ARRAY_RANGE_VALID_NV                       0x851F
#define GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV                 0x8520
#define GL_VERTEX_ARRAY_RANGE_POINTER_NV                     0x8521
#endif

#if GL_NV_vertex_array_range2
#define GL_VERTEX_ARRAY_RANGE_WITHOUT_FLUSH_NV               0x8533
#endif

#if GL_NV_vertex_program
#define GL_VERTEX_PROGRAM_NV                                 0x8620
#define GL_VERTEX_STATE_PROGRAM_NV                           0x8621
#define GL_ATTRIB_ARRAY_SIZE_NV                              0x8623
#define GL_ATTRIB_ARRAY_STRIDE_NV                            0x8624
#define GL_ATTRIB_ARRAY_TYPE_NV                              0x8625
#define GL_CURRENT_ATTRIB_NV                                 0x8626
#define GL_PROGRAM_LENGTH_NV                                 0x8627
#define GL_PROGRAM_STRING_NV                                 0x8628
#define GL_MODELVIEW_PROJECTION_NV                           0x8629
#define GL_IDENTITY_NV                                       0x862A
#define GL_INVERSE_NV                                        0x862B
#define GL_TRANSPOSE_NV                                      0x862C
#define GL_INVERSE_TRANSPOSE_NV                              0x862D
#define GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV                   0x862E
#define GL_MAX_TRACK_MATRICES_NV                             0x862F
#define GL_MATRIX0_NV                                        0x8630
#define GL_MATRIX1_NV                                        0x8631
#define GL_MATRIX2_NV                                        0x8632
#define GL_MATRIX3_NV                                        0x8633
#define GL_MATRIX4_NV                                        0x8634
#define GL_MATRIX5_NV                                        0x8635
#define GL_MATRIX6_NV                                        0x8636
#define GL_MATRIX7_NV                                        0x8637
#define GL_CURRENT_MATRIX_STACK_DEPTH_NV                     0x8640
#define GL_CURRENT_MATRIX_NV                                 0x8641
#define GL_VERTEX_PROGRAM_POINT_SIZE_NV                      0x8642
#define GL_VERTEX_PROGRAM_TWO_SIDE_NV                        0x8643
#define GL_PROGRAM_PARAMETER_NV                              0x8644
#define GL_ATTRIB_ARRAY_POINTER_NV                           0x8645
#define GL_PROGRAM_TARGET_NV                                 0x8646
#define GL_PROGRAM_RESIDENT_NV                               0x8647
#define GL_TRACK_MATRIX_NV                                   0x8648
#define GL_TRACK_MATRIX_TRANSFORM_NV                         0x8649
#define GL_VERTEX_PROGRAM_BINDING_NV                         0x864A
#define GL_PROGRAM_ERROR_POSITION_NV                         0x864B
#define GL_VERTEX_ATTRIB_ARRAY0_NV                           0x8650
#define GL_VERTEX_ATTRIB_ARRAY1_NV                           0x8651
#define GL_VERTEX_ATTRIB_ARRAY2_NV                           0x8652
#define GL_VERTEX_ATTRIB_ARRAY3_NV                           0x8653
#define GL_VERTEX_ATTRIB_ARRAY4_NV                           0x8654
#define GL_VERTEX_ATTRIB_ARRAY5_NV                           0x8655
#define GL_VERTEX_ATTRIB_ARRAY6_NV                           0x8656
#define GL_VERTEX_ATTRIB_ARRAY7_NV                           0x8657
#define GL_VERTEX_ATTRIB_ARRAY8_NV                           0x8658
#define GL_VERTEX_ATTRIB_ARRAY9_NV                           0x8659
#define GL_VERTEX_ATTRIB_ARRAY10_NV                          0x865A
#define GL_VERTEX_ATTRIB_ARRAY11_NV                          0x865B
#define GL_VERTEX_ATTRIB_ARRAY12_NV                          0x865C
#define GL_VERTEX_ATTRIB_ARRAY13_NV                          0x865D
#define GL_VERTEX_ATTRIB_ARRAY14_NV                          0x865E
#define GL_VERTEX_ATTRIB_ARRAY15_NV                          0x865F
#define GL_MAP1_VERTEX_ATTRIB0_4_NV                          0x8660
#define GL_MAP1_VERTEX_ATTRIB1_4_NV                          0x8661
#define GL_MAP1_VERTEX_ATTRIB2_4_NV                          0x8662
#define GL_MAP1_VERTEX_ATTRIB3_4_NV                          0x8663
#define GL_MAP1_VERTEX_ATTRIB4_4_NV                          0x8664
#define GL_MAP1_VERTEX_ATTRIB5_4_NV                          0x8665
#define GL_MAP1_VERTEX_ATTRIB6_4_NV                          0x8666
#define GL_MAP1_VERTEX_ATTRIB7_4_NV                          0x8667
#define GL_MAP1_VERTEX_ATTRIB8_4_NV                          0x8668
#define GL_MAP1_VERTEX_ATTRIB9_4_NV                          0x8669
#define GL_MAP1_VERTEX_ATTRIB10_4_NV                         0x866A
#define GL_MAP1_VERTEX_ATTRIB11_4_NV                         0x866B
#define GL_MAP1_VERTEX_ATTRIB12_4_NV                         0x866C
#define GL_MAP1_VERTEX_ATTRIB13_4_NV                         0x866D
#define GL_MAP1_VERTEX_ATTRIB14_4_NV                         0x866E
#define GL_MAP1_VERTEX_ATTRIB15_4_NV                         0x866F
#define GL_MAP2_VERTEX_ATTRIB0_4_NV                          0x8670
#define GL_MAP2_VERTEX_ATTRIB1_4_NV                          0x8671
#define GL_MAP2_VERTEX_ATTRIB2_4_NV                          0x8672
#define GL_MAP2_VERTEX_ATTRIB3_4_NV                          0x8673
#define GL_MAP2_VERTEX_ATTRIB4_4_NV                          0x8674
#define GL_MAP2_VERTEX_ATTRIB5_4_NV                          0x8675
#define GL_MAP2_VERTEX_ATTRIB6_4_NV                          0x8676
#define GL_MAP2_VERTEX_ATTRIB7_4_NV                          0x8677
#define GL_MAP2_VERTEX_ATTRIB8_4_NV                          0x8678
#define GL_MAP2_VERTEX_ATTRIB9_4_NV                          0x8679
#define GL_MAP2_VERTEX_ATTRIB10_4_NV                         0x867A
#define GL_MAP2_VERTEX_ATTRIB11_4_NV                         0x867B
#define GL_MAP2_VERTEX_ATTRIB12_4_NV                         0x867C
#define GL_MAP2_VERTEX_ATTRIB13_4_NV                         0x867D
#define GL_MAP2_VERTEX_ATTRIB14_4_NV                         0x867E
#define GL_MAP2_VERTEX_ATTRIB15_4_NV                         0x867F
#endif

#if GL_SGI_color_matrix
#define GL_COLOR_MATRIX_SGI                                  0x80B1
#define GL_COLOR_MATRIX_STACK_DEPTH_SGI                      0x80B2
#define GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI                  0x80B3
#define GL_POST_COLOR_MATRIX_RED_SCALE_SGI                   0x80B4
#define GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI                 0x80B5
#define GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI                  0x80B6
#define GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI                 0x80B7
#define GL_POST_COLOR_MATRIX_RED_BIAS_SGI                    0x80B8
#define GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI                  0x80B9
#define GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI                   0x80BA
#define GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI                  0x80BB
#endif

#if GL_SGI_color_table
#define GL_COLOR_TABLE_SGI                                   0x80D0
#define GL_POST_CONVOLUTION_COLOR_TABLE_SGI                  0x80D1
#define GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI                 0x80D2
#define GL_PROXY_COLOR_TABLE_SGI                             0x80D3
#define GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI            0x80D4
#define GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI           0x80D5
#define GL_COLOR_TABLE_SCALE_SGI                             0x80D6
#define GL_COLOR_TABLE_BIAS_SGI                              0x80D7
#define GL_COLOR_TABLE_FORMAT_SGI                            0x80D8
#define GL_COLOR_TABLE_WIDTH_SGI                             0x80D9
#define GL_COLOR_TABLE_RED_SIZE_SGI                          0x80DA
#define GL_COLOR_TABLE_GREEN_SIZE_SGI                        0x80DB
#define GL_COLOR_TABLE_BLUE_SIZE_SGI                         0x80DC
#define GL_COLOR_TABLE_ALPHA_SIZE_SGI                        0x80DD
#define GL_COLOR_TABLE_LUMINANCE_SIZE_SGI                    0x80DE
#define GL_COLOR_TABLE_INTENSITY_SIZE_SGI                    0x80DF
#endif

#if GL_SGIS_generate_mipmap
#define GL_GENERATE_MIPMAP_SGIS                              0x8191
#define GL_GENERATE_MIPMAP_HINT_SGIS                         0x8192
#endif

#if GL_SGIS_point_parameters
#define GL_POINT_SIZE_MIN_SGIS                               0x8126
#define GL_POINT_SIZE_MAX_SGIS                               0x8127
#define GL_POINT_FADE_THRESHOLD_SIZE_SGIS                    0x8128
#define GL_DISTANCE_ATTENUATION_SGIS                         0x8129
#endif

#if GL_SGIS_texture_edge_clamp
#define GL_CLAMP_TO_EDGE_SGIS                                0x812F
#endif

#if GL_SGIS_texture_border_clamp
#define GL_CLAMP_TO_BORDER_SGIS                              0x812D
#endif

#if GL_SGIS_texture_lod
#define GL_TEXTURE_MIN_LOD_SGIS                              0x813A
#define GL_TEXTURE_MAX_LOD_SGIS                              0x813B
#define GL_TEXTURE_BASE_LEVEL_SGIS                           0x813C
#define GL_TEXTURE_MAX_LEVEL_SGIS                            0x813D
#endif

#if GL_SGIX_depth_texture
#define GL_DEPTH_COMPONENT16_SGIX                            0x81A5
#define GL_DEPTH_COMPONENT24_SGIX                            0x81A6
#define GL_DEPTH_COMPONENT32_SGIX                            0x81A7
#endif

/*************************************************************/

#if GL_ARB_color_buffer_float
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glClampColorARBProcPtr) (GLenum target, GLenum clamp);
#else
extern void glClampColorARB(GLenum target, GLenum clamp);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ARB_draw_buffers
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glDrawBuffersARBProcPtr) (GLsizei n, const GLenum *bufs);
#else
extern void glDrawBuffersARB(GLsizei n, const GLenum *bufs);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ARB_draw_elements_base_vertex
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glDrawElementsBaseVertexProcPtr) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex);
typedef void (* glDrawRangeElementsBaseVertexProcPtr) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex);
typedef void (* glDrawElementsInstancedBaseVertexProcPtr) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint base_vertex);
typedef void (* glMultiDrawElementsBaseVertexProcPtr) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei primcount, const GLint *base_vertex);
#else
extern void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex);
extern void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex);
extern void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint base_vertex);
extern void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei primcount, const GLint *base_vertex);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ARB_draw_instanced
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glDrawArraysInstancedARBProcPtr) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void (* glDrawElementsInstancedARBProcPtr) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
#else
extern void glDrawArraysInstancedARB(GLenum mode, GLint first, GLsizei count, GLsizei primcount);
extern void glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ARB_framebuffer_object
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef GLboolean (* glIsRenderbufferProcPtr) (GLuint renderbuffer);
typedef void (* glBindRenderbufferProcPtr) (GLenum target, GLuint renderbuffer);
typedef void (* glDeleteRenderbuffersProcPtr) (GLsizei n, const GLuint *renderbuffers);
typedef void (* glGenRenderbuffersProcPtr) (GLsizei n, GLuint *renderbuffers);
typedef void (* glRenderbufferStorageProcPtr) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (* glGetRenderbufferParameterivProcPtr) (GLenum target, GLenum pname, GLint *params);
typedef GLboolean (* glIsFramebufferProcPtr) (GLuint framebuffer);
typedef void (* glBindFramebufferProcPtr) (GLenum target, GLuint framebuffer);
typedef void (* glDeleteFramebuffersProcPtr) (GLsizei n, const GLuint *framebuffers);
typedef void (* glGenFramebuffersProcPtr) (GLsizei n, GLuint *framebuffers);
typedef GLenum (* glCheckFramebufferStatusProcPtr) (GLenum target);
typedef void (* glFramebufferTexture1DProcPtr) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (* glFramebufferTexture2DProcPtr) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (* glFramebufferTexture3DProcPtr) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void (* glFramebufferRenderbufferProcPtr) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (* glGetFramebufferAttachmentParameterivProcPtr) (GLenum target, GLenum attachment, GLenum pname, GLint *params);
typedef void (* glGenerateMipmapProcPtr) (GLenum target);
typedef void (* glBlitFramebufferProcPtr) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void (* glRenderbufferStorageMultisampleProcPtr) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (* glFramebufferTextureLayerProcPtr) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
#else
extern GLboolean glIsRenderbuffer(GLuint renderbuffer);
extern void glBindRenderbuffer(GLenum target, GLuint renderbuffer);
extern void glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers);
extern void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers);
extern void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
extern void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params);
extern GLboolean glIsFramebuffer(GLuint framebuffer);
extern void glBindFramebuffer(GLenum target, GLuint framebuffer);
extern void glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers);
extern void glGenFramebuffers(GLsizei n, GLuint *framebuffers);
extern GLenum glCheckFramebufferStatus(GLenum target);
extern void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
extern void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
extern void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params);
extern void glGenerateMipmap(GLenum target);
extern void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
extern void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
extern void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ARB_instanced_arrays
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glVertexAttribDivisorARBProcPtr) (GLuint index, GLuint divisor);
#else
extern void glVertexAttribDivisorARB(GLuint index, GLuint divisor);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ARB_multisample
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glSampleCoverageARBProcPtr) (GLclampf value, GLboolean invert);
#else
extern void glSampleCoverageARB(GLclampf value, GLboolean invert);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ARB_multitexture
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glActiveTextureARBProcPtr) (GLenum texture);
typedef void (* glClientActiveTextureARBProcPtr) (GLenum texture);
typedef void (* glMultiTexCoord1dARBProcPtr) (GLenum target, GLdouble s);
typedef void (* glMultiTexCoord1dvARBProcPtr) (GLenum target, const GLdouble *v);
typedef void (* glMultiTexCoord1fARBProcPtr) (GLenum target, GLfloat s);
typedef void (* glMultiTexCoord1fvARBProcPtr) (GLenum target, const GLfloat *v);
typedef void (* glMultiTexCoord1iARBProcPtr) (GLenum target, GLint s);
typedef void (* glMultiTexCoord1ivARBProcPtr) (GLenum target, const GLint *v);
typedef void (* glMultiTexCoord1sARBProcPtr) (GLenum target, GLshort s);
typedef void (* glMultiTexCoord1svARBProcPtr) (GLenum target, const GLshort *v);
typedef void (* glMultiTexCoord2dARBProcPtr) (GLenum target, GLdouble s, GLdouble t);
typedef void (* glMultiTexCoord2dvARBProcPtr) (GLenum target, const GLdouble *v);
typedef void (* glMultiTexCoord2fARBProcPtr) (GLenum target, GLfloat s, GLfloat t);
typedef void (* glMultiTexCoord2fvARBProcPtr) (GLenum target, const GLfloat *v);
typedef void (* glMultiTexCoord2iARBProcPtr) (GLenum target, GLint s, GLint t);
typedef void (* glMultiTexCoord2ivARBProcPtr) (GLenum target, const GLint *v);
typedef void (* glMultiTexCoord2sARBProcPtr) (GLenum target, GLshort s, GLshort t);
typedef void (* glMultiTexCoord2svARBProcPtr) (GLenum target, const GLshort *v);
typedef void (* glMultiTexCoord3dARBProcPtr) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void (* glMultiTexCoord3dvARBProcPtr) (GLenum target, const GLdouble *v);
typedef void (* glMultiTexCoord3fARBProcPtr) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void (* glMultiTexCoord3fvARBProcPtr) (GLenum target, const GLfloat *v);
typedef void (* glMultiTexCoord3iARBProcPtr) (GLenum target, GLint s, GLint t, GLint r);
typedef void (* glMultiTexCoord3ivARBProcPtr) (GLenum target, const GLint *v);
typedef void (* glMultiTexCoord3sARBProcPtr) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void (* glMultiTexCoord3svARBProcPtr) (GLenum target, const GLshort *v);
typedef void (* glMultiTexCoord4dARBProcPtr) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void (* glMultiTexCoord4dvARBProcPtr) (GLenum target, const GLdouble *v);
typedef void (* glMultiTexCoord4fARBProcPtr) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void (* glMultiTexCoord4fvARBProcPtr) (GLenum target, const GLfloat *v);
typedef void (* glMultiTexCoord4iARBProcPtr) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void (* glMultiTexCoord4ivARBProcPtr) (GLenum target, const GLint *v);
typedef void (* glMultiTexCoord4sARBProcPtr) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void (* glMultiTexCoord4svARBProcPtr) (GLenum target, const GLshort *v);
#else
extern void glActiveTextureARB(GLenum texture);
extern void glClientActiveTextureARB(GLenum texture);
extern void glMultiTexCoord1dARB(GLenum target, GLdouble s);
extern void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v);
extern void glMultiTexCoord1fARB(GLenum target, GLfloat s);
extern void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v);
extern void glMultiTexCoord1iARB(GLenum target, GLint s);
extern void glMultiTexCoord1ivARB(GLenum target, const GLint *v);
extern void glMultiTexCoord1sARB(GLenum target, GLshort s);
extern void glMultiTexCoord1svARB(GLenum target, const GLshort *v);
extern void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t);
extern void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v);
extern void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t);
extern void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v);
extern void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t);
extern void glMultiTexCoord2ivARB(GLenum target, const GLint *v);
extern void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t);
extern void glMultiTexCoord2svARB(GLenum target, const GLshort *v);
extern void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r);
extern void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v);
extern void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r);
extern void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v);
extern void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r);
extern void glMultiTexCoord3ivARB(GLenum target, const GLint *v);
extern void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r);
extern void glMultiTexCoord3svARB(GLenum target, const GLshort *v);
extern void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v);
extern void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v);
extern void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q);
extern void glMultiTexCoord4ivARB(GLenum target, const GLint *v);
extern void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
extern void glMultiTexCoord4svARB(GLenum target, const GLshort *v);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ARB_occlusion_query
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glGenQueriesARBProcPtr) (GLsizei n, GLuint *ids);
typedef void (* glDeleteQueriesARBProcPtr) (GLsizei n, const GLuint *ids);
typedef GLboolean (* glIsQueryARBProcPtr) (GLuint id);
typedef void (* glBeginQueryARBProcPtr) (GLenum target, GLuint id);
typedef void (* glEndQueryARBProcPtr) (GLenum target);
typedef void (* glGetQueryivARBProcPtr) (GLenum target, GLenum pname, GLint *params);
typedef void (* glGetQueryObjectivARBProcPtr) (GLuint id, GLenum pname, GLint *params);
typedef void (* glGetQueryObjectuivARBProcPtr) (GLuint id, GLenum pname, GLuint *params);
#else
extern void glGenQueriesARB(GLsizei n, GLuint *ids);
extern void glDeleteQueriesARB(GLsizei n, const GLuint *ids);
extern GLboolean glIsQueryARB(GLuint id);
extern void glBeginQueryARB(GLenum target, GLuint id);
extern void glEndQueryARB(GLenum target);
extern void glGetQueryivARB(GLenum target, GLenum pname, GLint *params);
extern void glGetQueryObjectivARB(GLuint id, GLenum pname, GLint *params);
extern void glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint *params);
#endif
#endif

#if GL_ARB_point_parameters
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glPointParameterfARBProcPtr) (GLenum pname, GLfloat param);
typedef void (* glPointParameterfvARBProcPtr) (GLenum pname, const GLfloat *params);
#else
extern void glPointParameterfARB(GLenum pname, GLfloat param);
extern void glPointParameterfvARB(GLenum pname, const GLfloat *params);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ARB_provoking_vertex
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glProvokingVertexProcPtr) (GLenum mode);
#else
extern void glProvokingVertex(GLenum mode);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ARB_shader_objects
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glDeleteObjectARBProcPtr) (GLhandleARB obj);
typedef GLhandleARB (* glGetHandleARBProcPtr) (GLenum pname);
typedef void (* glDetachObjectARBProcPtr) (GLhandleARB containerObj, GLhandleARB attachedObj);
typedef GLhandleARB (* glCreateShaderObjectARBProcPtr) (GLenum shaderType);
typedef void (* glShaderSourceARBProcPtr) (GLhandleARB shaderObj, GLsizei count, const GLcharARB* const *string, const GLint *length);
typedef void (* glCompileShaderARBProcPtr) (GLhandleARB shaderObj);
typedef GLhandleARB (* glCreateProgramObjectARBProcPtr) (void);
typedef void (* glAttachObjectARBProcPtr) (GLhandleARB containerObj, GLhandleARB obj);
typedef void (* glLinkProgramARBProcPtr) (GLhandleARB programObj);
typedef void (* glUseProgramObjectARBProcPtr) (GLhandleARB programObj);
typedef void (* glValidateProgramARBProcPtr) (GLhandleARB programObj);
typedef void (* glUniform1fARBProcPtr) (GLint location, GLfloat v0);
typedef void (* glUniform2fARBProcPtr) (GLint location, GLfloat v0, GLfloat v1);
typedef void (* glUniform3fARBProcPtr) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (* glUniform4fARBProcPtr) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (* glUniform1iARBProcPtr) (GLint location, GLint v0);
typedef void (* glUniform2iARBProcPtr) (GLint location, GLint v0, GLint v1);
typedef void (* glUniform3iARBProcPtr) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void (* glUniform4iARBProcPtr) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (* glUniform1fvARBProcPtr) (GLint location, GLsizei count, const GLfloat *value);
typedef void (* glUniform2fvARBProcPtr) (GLint location, GLsizei count, const GLfloat *value);
typedef void (* glUniform3fvARBProcPtr) (GLint location, GLsizei count, const GLfloat *value);
typedef void (* glUniform4fvARBProcPtr) (GLint location, GLsizei count, const GLfloat *value);
typedef void (* glUniform1ivARBProcPtr) (GLint location, GLsizei count, const GLint *value);
typedef void (* glUniform2ivARBProcPtr) (GLint location, GLsizei count, const GLint *value);
typedef void (* glUniform3ivARBProcPtr) (GLint location, GLsizei count, const GLint *value);
typedef void (* glUniform4ivARBProcPtr) (GLint location, GLsizei count, const GLint *value);
typedef void (* glUniformMatrix2fvARBProcPtr) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (* glUniformMatrix3fvARBProcPtr) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (* glUniformMatrix4fvARBProcPtr) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (* glGetObjectParameterfvARBProcPtr) (GLhandleARB obj, GLenum pname, GLfloat *params);
typedef void (* glGetObjectParameterivARBProcPtr) (GLhandleARB obj, GLenum pname, GLint *params);
typedef void (* glGetInfoLogARBProcPtr) (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
typedef void (* glGetAttachedObjectsARBProcPtr) (GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj);
typedef GLint (* glGetUniformLocationARBProcPtr) (GLhandleARB programObj, const GLcharARB *name);
typedef void (* glGetActiveUniformARBProcPtr) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
typedef void (* glGetUniformfvARBProcPtr) (GLhandleARB programObj, GLint location, GLfloat *params);
typedef void (* glGetUniformivARBProcPtr) (GLhandleARB programObj, GLint location, GLint *params);
typedef void (* glGetShaderSourceARBProcPtr) (GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source);
#else
extern void glDeleteObjectARB(GLhandleARB obj);
extern GLhandleARB glGetHandleARB(GLenum pname);
extern void glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj);
extern GLhandleARB glCreateShaderObjectARB(GLenum shaderType);
extern void glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB* const *string, const GLint *length);
extern void glCompileShaderARB(GLhandleARB shaderObj);
extern GLhandleARB glCreateProgramObjectARB(void);
extern void glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj);
extern void glLinkProgramARB(GLhandleARB programObj);
extern void glUseProgramObjectARB(GLhandleARB programObj);
extern void glValidateProgramARB(GLhandleARB programObj);
extern void glUniform1fARB(GLint location, GLfloat v0);
extern void glUniform2fARB(GLint location, GLfloat v0, GLfloat v1);
extern void glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
extern void glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
extern void glUniform1iARB(GLint location, GLint v0);
extern void glUniform2iARB(GLint location, GLint v0, GLint v1);
extern void glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2);
extern void glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
extern void glUniform1fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform2fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform3fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform4fvARB(GLint location, GLsizei count, const GLfloat *value);
extern void glUniform1ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniform2ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniform3ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniform4ivARB(GLint location, GLsizei count, const GLint *value);
extern void glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
extern void glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat *params);
extern void glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params);
extern void glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
extern void glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj);
extern GLint glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name);
extern void glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
extern void glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat *params);
extern void glGetUniformivARB(GLhandleARB programObj, GLint location, GLint *params);
extern void glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ARB_sync
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef GLsync (* glFenceSyncProcPtr) (GLenum condition, GLbitfield flags);
typedef GLboolean (* glIsSyncProcPtr) (GLsync sync);
typedef void (* glDeleteSyncProcPtr) (GLsync sync);
typedef GLenum (* glClientWaitSyncProcPtr) (GLsync sync, GLbitfield flags, GLuint64 timeout);
typedef void (* glWaitSyncProcPtr)(GLsync sync, GLbitfield flags, GLuint64 timeout);
typedef void (* glGetInteger64vProcPtr) (GLenum pname, GLint64 *params);
typedef void (* glGetSyncivProcPtr) (GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
#else
extern GLsync glFenceSync(GLenum condition, GLbitfield flags);
extern GLboolean glIsSync(GLsync sync);
extern void glDeleteSync(GLsync sync);
extern GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
extern void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
extern void glGetInteger64v(GLenum pname, GLint64 *params);
extern void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ARB_texture_compression
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glCompressedTexImage3DARBProcPtr) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (* glCompressedTexImage2DARBProcPtr) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (* glCompressedTexImage1DARBProcPtr) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void (* glCompressedTexSubImage3DARBProcPtr) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (* glCompressedTexSubImage2DARBProcPtr) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (* glCompressedTexSubImage1DARBProcPtr) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void (* glGetCompressedTexImageARBProcPtr) (GLenum target, GLint level, GLvoid *data);
#else
extern void glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
extern void glGetCompressedTexImageARB(GLenum target, GLint level, GLvoid *data);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ARB_transpose_matrix
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glLoadTransposeMatrixfARBProcPtr) (const GLfloat *m);
typedef void (* glLoadTransposeMatrixdARBProcPtr) (const GLdouble *m);
typedef void (* glMultTransposeMatrixfARBProcPtr) (const GLfloat *m);
typedef void (* glMultTransposeMatrixdARBProcPtr) (const GLdouble *m);
#else
extern void glLoadTransposeMatrixfARB(const GLfloat *m);
extern void glLoadTransposeMatrixdARB(const GLdouble *m);
extern void glMultTransposeMatrixfARB(const GLfloat *m);
extern void glMultTransposeMatrixdARB(const GLdouble *m);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ARB_vertex_blend
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glWeightbvARBProcPtr) (GLint size, const GLbyte *weights);
typedef void (* glWeightsvARBProcPtr) (GLint size, const GLshort *weights);
typedef void (* glWeightivARBProcPtr) (GLint size, const GLint *weights);
typedef void (* glWeightfvARBProcPtr) (GLint size, const GLfloat *weights);
typedef void (* glWeightdvARBProcPtr) (GLint size, const GLdouble *weights);
typedef void (* glWeightubvARBProcPtr) (GLint size, const GLubyte *weights);
typedef void (* glWeightusvARBProcPtr) (GLint size, const GLushort *weights);
typedef void (* glWeightuivARBProcPtr) (GLint size, const GLuint *weights);
typedef void (* glWeightPointerARBProcPtr) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (* glVertexBlendARBProcPtr) (GLint count);
#else
extern void glWeightbvARB(GLint size, const GLbyte *weights);
extern void glWeightsvARB(GLint size, const GLshort *weights);
extern void glWeightivARB(GLint size, const GLint *weights);
extern void glWeightfvARB(GLint size, const GLfloat *weights);
extern void glWeightdvARB(GLint size, const GLdouble *weights);
extern void glWeightubvARB(GLint size, const GLubyte *weights);
extern void glWeightusvARB(GLint size, const GLushort *weights);
extern void glWeightuivARB(GLint size, const GLuint *weights);
extern void glWeightPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glVertexBlendARB(GLint count);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ARB_vertex_buffer_object
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glBindBufferARBProcPtr) (GLenum target, GLuint buffer);
typedef void (* glDeleteBuffersARBProcPtr) (GLsizei n, const GLuint *buffers);
typedef void (* glGenBuffersARBProcPtr) (GLsizei n, GLuint *buffers);
typedef GLboolean (* glIsBufferARBProcPtr) (GLuint buffer);
typedef void (* glBufferDataARBProcPtr) (GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
typedef void (* glBufferSubDataARBProcPtr) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
typedef void (* glGetBufferSubDataARBProcPtr) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
typedef GLvoid *(* glMapBufferARBProcPtr) (GLenum target, GLenum access);
typedef GLboolean (* glUnmapBufferARBProcPtr) (GLenum target);
typedef void (* glGetBufferParameterivARBProcPtr) (GLenum target, GLenum pname, GLint *params);
typedef void (* glGetBufferPointervARBProcPtr) (GLenum target, GLenum pname, GLvoid **params);
#else
extern void glBindBufferARB(GLenum target, GLuint buffer);
extern void glDeleteBuffersARB(GLsizei n, const GLuint *buffers);
extern void glGenBuffersARB(GLsizei n, GLuint *buffers);
extern GLboolean glIsBufferARB(GLuint buffer);
extern void glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
extern void glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
extern void glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
extern GLvoid *glMapBufferARB(GLenum target, GLenum access);
extern GLboolean glUnmapBufferARB(GLenum target);
extern void glGetBufferParameterivARB(GLenum target, GLenum pname, GLint *params);
extern void glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ARB_vertex_program
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glBindProgramARBProcPtr) (GLenum target, GLuint program);
typedef void (* glDeleteProgramsARBProcPtr) (GLsizei n, const GLuint *programs);
typedef void (* glGenProgramsARBProcPtr) (GLsizei n, GLuint *programs);
typedef GLboolean (* glIsProgramARBProcPtr) (GLuint program);
typedef void (* glProgramEnvParameter4dARBProcPtr) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (* glProgramEnvParameter4dvARBProcPtr) (GLenum target, GLuint index, const GLdouble *params);
typedef void (* glProgramEnvParameter4fARBProcPtr) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (* glProgramEnvParameter4fvARBProcPtr) (GLenum target, GLuint index, const GLfloat *params);
typedef void (* glProgramLocalParameter4dARBProcPtr) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (* glProgramLocalParameter4dvARBProcPtr) (GLenum target, GLuint index, const GLdouble *params);
typedef void (* glProgramLocalParameter4fARBProcPtr) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (* glProgramLocalParameter4fvARBProcPtr) (GLenum target, GLuint index, const GLfloat *params);
#if GL_EXT_gpu_program_parameters
typedef void (* glProgramEnvParameters4fvEXTProcPtr) (GLenum target, GLuint index, GLsizei count, const GLfloat *params);
typedef void (* glProgramLocalParameters4fvEXTProcPtr) (GLenum target, GLuint index, GLsizei count, const GLfloat *params);
#endif
typedef void (* glGetProgramEnvParameterdvARBProcPtr) (GLenum target, GLuint index, GLdouble *params);
typedef void (* glGetProgramEnvParameterfvARBProcPtr) (GLenum target, GLuint index, GLfloat *params);
typedef void (* glGetProgramLocalParameterdvARBProcPtr) (GLenum target, GLuint index, GLdouble *params);
typedef void (* glGetProgramLocalParameterfvARBProcPtr) (GLenum target, GLuint index, GLfloat *params);
typedef void (* glProgramStringARBProcPtr) (GLenum target, GLenum format, GLsizei len, const GLvoid *string);
typedef void (* glGetProgramStringARBProcPtr) (GLenum target, GLenum pname, GLvoid *string);
typedef void (* glGetProgramivARBProcPtr) (GLenum target, GLenum pname, GLint *params);
#else
extern void glBindProgramARB(GLenum target, GLuint program);
extern void glDeleteProgramsARB(GLsizei n, const GLuint *programs);
extern void glGenProgramsARB(GLsizei n, GLuint *programs);
extern GLboolean glIsProgramARB(GLuint program);
extern void glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble *params);
extern void glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params);
extern void glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble *params);
extern void glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params);
extern void glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble *params);
extern void glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat *params);
#if GL_EXT_gpu_program_parameters
extern void glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params);
extern void glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params);
#endif
extern void glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble *params);
extern void glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat *params);
extern void glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string);
extern void glGetProgramStringARB(GLenum target, GLenum pname, GLvoid *string);
extern void glGetProgramivARB(GLenum target, GLenum pname, GLint *params);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ARB_vertex_shader
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glBindAttribLocationARBProcPtr) (GLhandleARB programObj, GLuint index, const GLcharARB *name);
typedef void (* glGetActiveAttribARBProcPtr) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
typedef GLint (* glGetAttribLocationARBProcPtr) (GLhandleARB programObj, const GLcharARB *name);
#else
extern void glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name);
extern void glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
extern GLint glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB *name);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ARB_vertex_shader || GL_ARB_vertex_program
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glVertexAttrib1dARBProcPtr) (GLuint index, GLdouble x);
typedef void (* glVertexAttrib1dvARBProcPtr) (GLuint index, const GLdouble *v);
typedef void (* glVertexAttrib1fARBProcPtr) (GLuint index, GLfloat x);
typedef void (* glVertexAttrib1fvARBProcPtr) (GLuint index, const GLfloat *v);
typedef void (* glVertexAttrib1sARBProcPtr) (GLuint index, GLshort x);
typedef void (* glVertexAttrib1svARBProcPtr) (GLuint index, const GLshort *v);
typedef void (* glVertexAttrib2dARBProcPtr) (GLuint index, GLdouble x, GLdouble y);
typedef void (* glVertexAttrib2dvARBProcPtr) (GLuint index, const GLdouble *v);
typedef void (* glVertexAttrib2fARBProcPtr) (GLuint index, GLfloat x, GLfloat y);
typedef void (* glVertexAttrib2fvARBProcPtr) (GLuint index, const GLfloat *v);
typedef void (* glVertexAttrib2sARBProcPtr) (GLuint index, GLshort x, GLshort y);
typedef void (* glVertexAttrib2svARBProcPtr) (GLuint index, const GLshort *v);
typedef void (* glVertexAttrib3dARBProcPtr) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (* glVertexAttrib3dvARBProcPtr) (GLuint index, const GLdouble *v);
typedef void (* glVertexAttrib3fARBProcPtr) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (* glVertexAttrib3fvARBProcPtr) (GLuint index, const GLfloat *v);
typedef void (* glVertexAttrib3sARBProcPtr) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (* glVertexAttrib3svARBProcPtr) (GLuint index, const GLshort *v);
typedef void (* glVertexAttrib4NbvARBProcPtr) (GLuint index, const GLbyte *v);
typedef void (* glVertexAttrib4NivARBProcPtr) (GLuint index, const GLint *v);
typedef void (* glVertexAttrib4NsvARBProcPtr) (GLuint index, const GLshort *v);
typedef void (* glVertexAttrib4NubARBProcPtr) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (* glVertexAttrib4NubvARBProcPtr) (GLuint index, const GLubyte *v);
typedef void (* glVertexAttrib4NuivARBProcPtr) (GLuint index, const GLuint *v);
typedef void (* glVertexAttrib4NusvARBProcPtr) (GLuint index, const GLushort *v);
typedef void (* glVertexAttrib4bvARBProcPtr) (GLuint index, const GLbyte *v);
typedef void (* glVertexAttrib4dARBProcPtr) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (* glVertexAttrib4dvARBProcPtr) (GLuint index, const GLdouble *v);
typedef void (* glVertexAttrib4fARBProcPtr) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (* glVertexAttrib4fvARBProcPtr) (GLuint index, const GLfloat *v);
typedef void (* glVertexAttrib4ivARBProcPtr) (GLuint index, const GLint *v);
typedef void (* glVertexAttrib4sARBProcPtr) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (* glVertexAttrib4svARBProcPtr) (GLuint index, const GLshort *v);
typedef void (* glVertexAttrib4ubvARBProcPtr) (GLuint index, const GLubyte *v);
typedef void (* glVertexAttrib4uivARBProcPtr) (GLuint index, const GLuint *v);
typedef void (* glVertexAttrib4usvARBProcPtr) (GLuint index, const GLushort *v);
typedef void (* glVertexAttribPointerARBProcPtr) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
typedef void (* glDisableVertexAttribArrayARBProcPtr) (GLuint index);
typedef void (* glEnableVertexAttribArrayARBProcPtr) (GLuint index);
typedef void (* glGetVertexAttribPointervARBProcPtr) (GLuint index, GLenum pname, GLvoid **pointer);
typedef void (* glGetVertexAttribdvARBProcPtr) (GLuint index, GLenum pname, GLdouble *params);
typedef void (* glGetVertexAttribfvARBProcPtr) (GLuint index, GLenum pname, GLfloat *params);
typedef void (* glGetVertexAttribivARBProcPtr) (GLuint index, GLenum pname, GLint *params);
#else
extern void glVertexAttrib1dARB(GLuint index, GLdouble x);
extern void glVertexAttrib1dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib1fARB(GLuint index, GLfloat x);
extern void glVertexAttrib1fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib1sARB(GLuint index, GLshort x);
extern void glVertexAttrib1svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y);
extern void glVertexAttrib2dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y);
extern void glVertexAttrib2fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y);
extern void glVertexAttrib2svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern void glVertexAttrib3dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z);
extern void glVertexAttrib3fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z);
extern void glVertexAttrib3svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib4NbvARB(GLuint index, const GLbyte *v);
extern void glVertexAttrib4NivARB(GLuint index, const GLint *v);
extern void glVertexAttrib4NsvARB(GLuint index, const GLshort *v);
extern void glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
extern void glVertexAttrib4NubvARB(GLuint index, const GLubyte *v);
extern void glVertexAttrib4NuivARB(GLuint index, const GLuint *v);
extern void glVertexAttrib4NusvARB(GLuint index, const GLushort *v);
extern void glVertexAttrib4bvARB(GLuint index, const GLbyte *v);
extern void glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertexAttrib4dvARB(GLuint index, const GLdouble *v);
extern void glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertexAttrib4fvARB(GLuint index, const GLfloat *v);
extern void glVertexAttrib4ivARB(GLuint index, const GLint *v);
extern void glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertexAttrib4svARB(GLuint index, const GLshort *v);
extern void glVertexAttrib4ubvARB(GLuint index, const GLubyte *v);
extern void glVertexAttrib4uivARB(GLuint index, const GLuint *v);
extern void glVertexAttrib4usvARB(GLuint index, const GLushort *v);
extern void glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
extern void glDisableVertexAttribArrayARB(GLuint index);
extern void glEnableVertexAttribArrayARB(GLuint index);
extern void glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer);
extern void glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params);
extern void glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params);
extern void glGetVertexAttribivARB(GLuint index, GLenum pname, GLint *params);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ARB_window_pos
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glWindowPos2dARBProcPtr) (GLdouble x, GLdouble y);
typedef void (* glWindowPos2dvARBProcPtr) (const GLdouble *p);
typedef void (* glWindowPos2fARBProcPtr) (GLfloat x, GLfloat y);
typedef void (* glWindowPos2fvARBProcPtr) (const GLfloat *p);
typedef void (* glWindowPos2iARBProcPtr) (GLint x, GLint y);
typedef void (* glWindowPos2ivARBProcPtr) (const GLint *p);
typedef void (* glWindowPos2sARBProcPtr) (GLshort x, GLshort y);
typedef void (* glWindowPos2svARBProcPtr) (const GLshort *p);
typedef void (* glWindowPos3dARBProcPtr) (GLdouble x, GLdouble y, GLdouble z);
typedef void (* glWindowPos3dvARBProcPtr) (const GLdouble *p);
typedef void (* glWindowPos3fARBProcPtr) (GLfloat x, GLfloat y, GLfloat z);
typedef void (* glWindowPos3fvARBProcPtr) (const GLfloat *p);
typedef void (* glWindowPos3iARBProcPtr) (GLint x, GLint y, GLint z);
typedef void (* glWindowPos3ivARBProcPtr) (const GLint *p);
typedef void (* glWindowPos3sARBProcPtr) (GLshort x, GLshort y, GLshort z);
typedef void (* glWindowPos3svARBProcPtr) (const GLshort *p);
#else
extern void glWindowPos2dARB(GLdouble x, GLdouble y);
extern void glWindowPos2dvARB(const GLdouble *p);
extern void glWindowPos2fARB(GLfloat x, GLfloat y);
extern void glWindowPos2fvARB(const GLfloat *p);
extern void glWindowPos2iARB(GLint x, GLint y);
extern void glWindowPos2ivARB(const GLint *p);
extern void glWindowPos2sARB(GLshort x, GLshort y);
extern void glWindowPos2svARB(const GLshort *p);
extern void glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z);
extern void glWindowPos3dvARB(const GLdouble *p);
extern void glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z);
extern void glWindowPos3fvARB(const GLfloat *p);
extern void glWindowPos3iARB(GLint x, GLint y, GLint z);
extern void glWindowPos3ivARB(const GLint *p);
extern void glWindowPos3sARB(GLshort x, GLshort y, GLshort z);
extern void glWindowPos3svARB(const GLshort *p);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_bindable_uniform
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (*glUniformBufferEXTProcPtr) (GLuint program, GLint location, GLuint buffer);
typedef GLint (*glGetUniformBufferSizeEXTProcPtr) (GLuint program, GLint location);
typedef GLintptr (*glGetUniformOffsetEXTProcPtr) (GLuint program, GLint location);
#else
extern void glUniformBufferEXT(GLuint program, GLint location, GLuint buffer);
extern GLint glGetUniformBufferSizeEXT(GLuint program, GLint location);
extern GLintptr glGetUniformOffsetEXT(GLuint program, GLint location);
#endif
#endif /* GL_EXT_bindable_uniform */

#if GL_EXT_blend_color
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glBlendColorEXTProcPtr) (GLclampf red, GLclampf blue, GLclampf green, GLclampf alpha);
#else
extern void glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_blend_equation_separate
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glBlendEquationSeparateEXTProcPtr) (GLenum modeRGB, GLenum modeAlpha);
#else
extern void glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_blend_func_separate
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glBlendFuncSeparateEXTProcPtr) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
#else
extern void glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_blend_minmax
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glBlendEquationEXTProcPtr) (GLenum mode);
#else
extern void glBlendEquationEXT(GLenum mode);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_color_subtable
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glColorSubTableEXTProcPtr) (GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
typedef void (* glCopyColorSubTableEXTProcPtr) (GLenum, GLsizei, GLint, GLint, GLsizei);
#else
extern void glColorSubTableEXT(GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
extern void glCopyColorSubTableEXT(GLenum, GLsizei, GLint, GLint, GLsizei);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_compiled_vertex_array
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glLockArraysEXTProcPtr) (GLint first, GLsizei count);
typedef void (* glUnlockArraysEXTProcPtr) (void);
#else
extern void glLockArraysEXT(GLint first, GLsizei count);
extern void glUnlockArraysEXT(void);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_convolution
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glConvolutionFilter1DEXTProcPtr) (GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
typedef void (* glConvolutionFilter2DEXTProcPtr) (GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
typedef void (* glConvolutionParameterfEXTProcPtr) (GLenum, GLenum, GLfloat);
typedef void (* glConvolutionParameterfvEXTProcPtr) (GLenum, GLenum, const GLfloat *);
typedef void (* glConvolutionParameteriEXTProcPtr) (GLenum, GLenum, GLint);
typedef void (* glConvolutionParameterivEXTProcPtr) (GLenum, GLenum, const GLint *);
typedef void (* glCopyConvolutionFilter1DEXTProcPtr) (GLenum, GLenum, GLint, GLint, GLsizei);
typedef void (* glCopyConvolutionFilter2DEXTProcPtr) (GLenum, GLenum, GLint, GLint, GLsizei, GLsizei);
typedef void (* glGetConvolutionFilterEXTProcPtr) (GLenum, GLenum, GLenum, GLvoid *);
typedef void (* glGetConvolutionParameterfvEXTProcPtr) (GLenum, GLenum, GLfloat *);
typedef void (* glGetConvolutionParameterivEXTProcPtr) (GLenum, GLenum, GLint *);
typedef void (* glGetSeparableFilterEXTProcPtr) (GLenum, GLenum, GLenum, GLvoid *, GLvoid *, GLvoid *);
typedef void (* glSeparableFilter2DEXTProcPtr) (GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *, const GLvoid *);
#else
extern void glConvolutionFilter1DEXT(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
extern void glConvolutionFilter2DEXT(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
extern void glConvolutionParameterfEXT(GLenum, GLenum, GLfloat);
extern void glConvolutionParameterfvEXT(GLenum, GLenum, const GLfloat *);
extern void glConvolutionParameteriEXT(GLenum, GLenum, GLint);
extern void glConvolutionParameterivEXT(GLenum, GLenum, const GLint *);
extern void glCopyConvolutionFilter1DEXT(GLenum, GLenum, GLint, GLint, GLsizei);
extern void glCopyConvolutionFilter2DEXT(GLenum, GLenum, GLint, GLint, GLsizei, GLsizei);
extern void glGetConvolutionFilterEXT(GLenum, GLenum, GLenum, GLvoid *);
extern void glGetConvolutionParameterfvEXT(GLenum, GLenum, GLfloat *);
extern void glGetConvolutionParameterivEXT(GLenum, GLenum, GLint *);
extern void glGetSeparableFilterEXT(GLenum, GLenum, GLenum, GLvoid *, GLvoid *, GLvoid *);
extern void glSeparableFilter2DEXT(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *, const GLvoid *);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_copy_texture
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glCopyTexImage1DEXTProcPtr) (GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);
typedef void (* glCopyTexImage2DEXTProcPtr) (GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);
typedef void (* glCopyTexSubImage1DEXTProcPtr) (GLenum, GLint, GLint, GLint, GLint, GLsizei);
typedef void (* glCopyTexSubImage2DEXTProcPtr) (GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
typedef void (* glCopyTexSubImage3DEXTProcPtr) (GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
#else
extern void glCopyTexImage1DEXT(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);
extern void glCopyTexImage2DEXT(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);
extern void glCopyTexSubImage1DEXT(GLenum, GLint, GLint, GLint, GLint, GLsizei);
extern void glCopyTexSubImage2DEXT(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
extern void glCopyTexSubImage3DEXT(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_debug_label
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glLabelObjectEXTProcPtr) (GLenum type, GLuint object, GLsizei length, const GLchar *label);
typedef void (* glGetObjectLabelEXTProcPtr) (GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label);
#else
extern void glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar *label);
extern void glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_debug_marker
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glInsertEventMarkerEXTProcPtr) (GLsizei length, const char *marker);
typedef void (* glPushGroupMarkerEXTProcPtr) (GLsizei length, const char *marker);
typedef void (* glPopGroupMarkerEXTProcPtr) (void);
#else
extern void glInsertEventMarkerEXT(GLsizei length, const char *marker);
extern void glPushGroupMarkerEXT(GLsizei length, const char *marker);
extern void glPopGroupMarkerEXT(void);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_depth_bounds_test
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glDepthBoundsEXTProcPtr) (GLclampd zmin, GLclampd zmax);
#else
extern void glDepthBoundsEXT(GLclampd zmin, GLclampd zmax);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_draw_buffers2
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glColorMaskIndexedEXTProcPtr) (GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void (* glEnableIndexedEXTProcPtr) (GLenum target, GLuint index);
typedef void (* glDisableIndexedEXTProcPtr) (GLenum target, GLuint index);
typedef GLboolean (* glIsEnabledIndexedEXTProcPtr) (GLenum target, GLuint index);
#else
extern void glColorMaskIndexedEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
extern void glEnableIndexedEXT(GLenum target, GLuint index);
extern void glDisableIndexedEXT(GLenum target, GLuint index);
extern GLboolean glIsEnabledIndexedEXT(GLenum target, GLuint index);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_draw_range_elements
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glDrawRangeElementsEXTProcPtr) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
#else
extern void glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_fog_coord
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glFogCoordfEXTProcPtr) (GLfloat coord);
typedef void (* glFogCoordfvEXTProcPtr) (const GLfloat *coord);
typedef void (* glFogCoorddEXTProcPtr) (GLdouble coord);
typedef void (* glFogCoorddvEXTProcPtr) (const GLdouble *coord);
typedef void (* glFogCoordPointerEXTProcPtr) (GLenum type, GLsizei stride, const GLvoid *pointer);
#else
extern void glFogCoordfEXT(GLfloat coord);
extern void glFogCoordfvEXT(const GLfloat *coord);
extern void glFogCoorddEXT(GLdouble coord);
extern void glFogCoorddvEXT(const GLdouble *coord);
extern void glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_framebuffer_blit
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glBlitFramebufferEXTProcPtr) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
#else
extern void glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_framebuffer_multisample
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glRenderbufferStorageMultisampleEXTProcPtr) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
#else
extern void glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_framebuffer_object
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef GLboolean (* glIsRenderbufferEXTProcPtr) (GLuint renderbuffer);
typedef void (* glBindRenderbufferEXTProcPtr) (GLenum target, GLuint renderbuffer);
typedef void (* glDeleteRenderbuffersEXTProcPtr) (GLsizei n, const GLuint *renderbuffers);
typedef void (* glGenRenderbuffersEXTProcPtr) (GLsizei n, GLuint *renderbuffers);
typedef void (* glRenderbufferStorageEXTProcPtr) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (* glGetRenderbufferParameterivEXTProcPtr) (GLenum target, GLenum pname, GLint *params);
typedef GLboolean (* glIsFramebufferEXTProcPtr) (GLuint framebuffer);
typedef void (* glBindFramebufferEXTProcPtr) (GLenum target, GLuint framebuffer);
typedef void (* glDeleteFramebuffersEXTProcPtr) (GLsizei n, const GLuint *framebuffers);
typedef void (* glGenFramebuffersEXTProcPtr) (GLsizei n, GLuint *framebuffers);
typedef GLenum (* glCheckFramebufferStatusEXTProcPtr) (GLenum target);
typedef void (* glFramebufferTexture1DEXTProcPtr) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (* glFramebufferTexture2DEXTProcPtr) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (* glFramebufferTexture3DEXTProcPtr) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void (* glFramebufferRenderbufferEXTProcPtr) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (* glGetFramebufferAttachmentParameterivEXTProcPtr) (GLenum target, GLenum attachment, GLenum pname, GLint *params);
typedef void (* glGenerateMipmapEXTProcPtr) (GLenum target);
#else
extern GLboolean glIsRenderbufferEXT(GLuint renderbuffer);
extern void glBindRenderbufferEXT(GLenum target, GLuint renderbuffer);
extern void glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers);
extern void glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers);
extern void glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
extern void glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params);
extern GLboolean glIsFramebufferEXT(GLuint framebuffer);
extern void glBindFramebufferEXT(GLenum target, GLuint framebuffer);
extern void glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers);
extern void glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers);
extern GLenum glCheckFramebufferStatusEXT(GLenum target);
extern void glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
extern void glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
extern void glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
extern void glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params);
extern void glGenerateMipmapEXT(GLenum target);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_geometry_shader4
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glProgramParameteriEXTProcPtr) (GLuint program, GLenum pname, GLint value);
typedef void (* glFramebufferTextureEXTProcPtr) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (* glFramebufferTextureFaceEXTProcPtr) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
#else
extern void glProgramParameteriEXT(GLuint program, GLenum pname, GLint value);
extern void glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level);
extern void glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_geometry_shader4 || GL_EXT_texture_array
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glFramebufferTextureLayerEXTProcPtr) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
#else
extern void glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
#endif
#endif

#if GL_EXT_gpu_shader4
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (*glVertexAttribI1iEXTProcPtr) (GLuint index, GLint x);
typedef void (*glVertexAttribI2iEXTProcPtr) (GLuint index, GLint x, GLint y);
typedef void (*glVertexAttribI3iEXTProcPtr) (GLuint index, GLint x, GLint y, GLint z);
typedef void (*glVertexAttribI4iEXTProcPtr) (GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (*glVertexAttribI1uiEXTProcPtr) (GLuint index, GLuint x);
typedef void (*glVertexAttribI2uiEXTProcPtr) (GLuint index, GLuint x, GLuint y);
typedef void (*glVertexAttribI3uiEXTProcPtr) (GLuint index, GLuint x, GLuint y, GLuint z);
typedef void (*glVertexAttribI4uiEXTProcPtr) (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (*glVertexAttribI1ivEXTProcPtr) (GLuint index, const GLint *v);
typedef void (*glVertexAttribI2ivEXTProcPtr) (GLuint index, const GLint *v);
typedef void (*glVertexAttribI3ivEXTProcPtr) (GLuint index, const GLint *v);
typedef void (*glVertexAttribI4ivEXTProcPtr) (GLuint index, const GLint *v);
typedef void (*glVertexAttribI1uivEXTProcPtr) (GLuint index, const GLuint *v);
typedef void (*glVertexAttribI2uivEXTProcPtr) (GLuint index, const GLuint *v);
typedef void (*glVertexAttribI3uivEXTProcPtr) (GLuint index, const GLuint *v);
typedef void (*glVertexAttribI4uivEXTProcPtr) (GLuint index, const GLuint *v);
typedef void (*glVertexAttribI4bvEXTProcPtr) (GLuint index, const GLbyte *v);
typedef void (*glVertexAttribI4svEXTProcPtr) (GLuint index, const GLshort *v);
typedef void (*glVertexAttribI4ubvEXTProcPtr) (GLuint index, const GLubyte *v);
typedef void (*glVertexAttribI4usvEXTProcPtr) (GLuint index, const GLushort *v);
typedef void (*glVertexAttribIPointerEXTProcPtr) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (*glGetVertexAttribIivEXTProcPtr) (GLuint index, GLenum pname, GLint *params);
typedef void (*glGetVertexAttribIuivEXTProcPtr) (GLuint index, GLenum pname, GLuint *params);
typedef void (*glUniform1uiEXTProcPtr) (GLint location, GLuint v0);
typedef void (*glUniform2uiEXTProcPtr) (GLint location, GLuint v0, GLuint v1);
typedef void (*glUniform3uiEXTProcPtr) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (*glUniform4uiEXTProcPtr) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (*glUniform1uivEXTProcPtr) (GLint location, GLsizei count, const GLuint *value);
typedef void (*glUniform2uivEXTProcPtr) (GLint location, GLsizei count, const GLuint *value);
typedef void (*glUniform3uivEXTProcPtr) (GLint location, GLsizei count, const GLuint *value);
typedef void (*glUniform4uivEXTProcPtr) (GLint location, GLsizei count, const GLuint *value);
typedef void (*glGetUniformuivEXTProcPtr) (GLuint program, GLint location, GLuint *params);
typedef void (*glBindFragDataLocationEXTProcPtr) (GLuint program, GLuint colorNumber, const GLchar *name);
typedef GLint (*glGetFragDataLocationEXTProcPtr) (GLuint program, const GLchar *name);
#else
extern void glVertexAttribI1iEXT(GLuint index, GLint x);
extern void glVertexAttribI2iEXT(GLuint index, GLint x, GLint y);
extern void glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z);
extern void glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w);
extern void glVertexAttribI1uiEXT(GLuint index, GLuint x);
extern void glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y);
extern void glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z);
extern void glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
extern void glVertexAttribI1ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI2ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI3ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI4ivEXT(GLuint index, const GLint *v);
extern void glVertexAttribI1uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI2uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI3uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI4uivEXT(GLuint index, const GLuint *v);
extern void glVertexAttribI4bvEXT(GLuint index, const GLbyte *v);
extern void glVertexAttribI4svEXT(GLuint index, const GLshort *v);
extern void glVertexAttribI4ubvEXT(GLuint index, const GLubyte *v);
extern void glVertexAttribI4usvEXT(GLuint index, const GLushort *v);
extern void glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint *params);
extern void glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint *params);
extern void glUniform1uiEXT(GLint location, GLuint v0);
extern void glUniform2uiEXT(GLint location, GLuint v0, GLuint v1);
extern void glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2);
extern void glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
extern void glUniform1uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glUniform2uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glUniform3uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glUniform4uivEXT(GLint location, GLsizei count, const GLuint *value);
extern void glGetUniformuivEXT(GLuint program, GLint location, GLuint *params);
extern void glBindFragDataLocationEXT(GLuint program, GLuint colorNumber, const GLchar *name);
extern GLint glGetFragDataLocationEXT(GLuint program, const GLchar *name);
#endif
#endif /* GL_EXT_gpu_shader4 */

#if GL_EXT_histogram
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glGetHistogramEXTProcPtr) (GLenum, GLboolean, GLenum, GLenum, GLvoid *);
typedef void (* glGetHistogramParameterfvEXTProcPtr) (GLenum, GLenum, GLfloat *);
typedef void (* glGetHistogramParameterivEXTProcPtr) (GLenum, GLenum, GLint *);
typedef void (* glGetMinmaxEXTProcPtr) (GLenum, GLboolean, GLenum, GLenum, GLvoid *);
typedef void (* glGetMinmaxParameterfvEXTProcPtr) (GLenum, GLenum, GLfloat *);
typedef void (* glGetMinmaxParameterivEXTProcPtr) (GLenum, GLenum, GLint *);
typedef void (* glHistogramEXTProcPtr) (GLenum, GLsizei, GLenum, GLboolean);
typedef void (* glMinmaxEXTProcPtr) (GLenum, GLenum, GLboolean);
typedef void (* glResetHistogramEXTProcPtr) (GLenum);
typedef void (* glResetMinmaxEXTProcPtr) (GLenum);
#else
extern void glGetHistogramEXT(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
extern void glGetHistogramParameterfvEXT(GLenum, GLenum, GLfloat *);
extern void glGetHistogramParameterivEXT(GLenum, GLenum, GLint *);
extern void glGetMinmaxEXT(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
extern void glGetMinmaxParameterfvEXT(GLenum, GLenum, GLfloat *);
extern void glGetMinmaxParameterivEXT(GLenum, GLenum, GLint *);
extern void glHistogramEXT(GLenum, GLsizei, GLenum, GLboolean);
extern void glMinmaxEXT(GLenum, GLenum, GLboolean);
extern void glResetHistogramEXT(GLenum);
extern void glResetMinmaxEXT(GLenum);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_multi_draw_arrays
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glMultiDrawArraysEXTProcPtr) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
typedef void (* glMultiDrawElementsEXTProcPtr) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei primcount);
#else
extern void glMultiDrawArraysEXT(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
extern void glMultiDrawElementsEXT(GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei primcount);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_paletted_texture
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glColorTableEXTProcPtr) (GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
typedef void (* glColorSubTableEXTProcPtr) (GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
typedef void (* glGetColorTableEXTProcPtr) (GLenum, GLenum, GLenum, GLvoid *);
typedef void (* glGetColorTableParameterivEXTProcPtr) (GLenum, GLenum, GLint *);
typedef void (* glGetColorTableParameterfvEXTProcPtr) (GLenum, GLenum, GLfloat *);
#else
extern void glColorTableEXT(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
extern void glColorSubTableEXT(GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
extern void glGetColorTableEXT(GLenum, GLenum, GLenum, GLvoid *);
extern void glGetColorTableParameterivEXT(GLenum, GLenum, GLint *);
extern void glGetColorTableParameterfvEXT(GLenum, GLenum, GLfloat *);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_polygon_offset
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glPolygonOffsetEXTProcPtr) (GLfloat factor, GLfloat bias);
#else
extern void glPolygonOffsetEXT(GLfloat factor, GLfloat bias);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_provoking_vertex
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glProvokingVertexEXTProcPtr) (GLenum mode);
#else
extern void glProvokingVertexEXT(GLenum mode);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_secondary_color
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glSecondaryColor3bEXTProcPtr) (GLbyte red, GLbyte green, GLbyte blue);
typedef void (* glSecondaryColor3bvEXTProcPtr) (const GLbyte *v);
typedef void (* glSecondaryColor3dEXTProcPtr) (GLdouble red, GLdouble green, GLdouble blue);
typedef void (* glSecondaryColor3dvEXTProcPtr) (const GLdouble *v);
typedef void (* glSecondaryColor3fEXTProcPtr) (GLfloat red, GLfloat green, GLfloat blue);
typedef void (* glSecondaryColor3fvEXTProcPtr) (const GLfloat *v);
typedef void (* glSecondaryColor3iEXTProcPtr) (GLint red, GLint green, GLint blue);
typedef void (* glSecondaryColor3ivEXTProcPtr) (const GLint *v);
typedef void (* glSecondaryColor3sEXTProcPtr) (GLshort red, GLshort green, GLshort blue);
typedef void (* glSecondaryColor3svEXTProcPtr) (const GLshort *v);
typedef void (* glSecondaryColor3ubEXTProcPtr) (GLubyte red, GLubyte green, GLubyte blue);
typedef void (* glSecondaryColor3ubvEXTProcPtr) (const GLubyte *v);
typedef void (* glSecondaryColor3uiEXTProcPtr) (GLuint red, GLuint green, GLuint blue);
typedef void (* glSecondaryColor3uivEXTProcPtr) (const GLuint *v);
typedef void (* glSecondaryColor3usEXTProcPtr) (GLushort red, GLushort green, GLushort blue);
typedef void (* glSecondaryColor3usvEXTProcPtr) (const GLushort *v);
typedef void (* glSecondaryColorPointerEXTProcPtr) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
#else
extern void glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue);
extern void glSecondaryColor3bvEXT(const GLbyte *v);
extern void glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue);
extern void glSecondaryColor3dvEXT(const GLdouble *v);
extern void glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue);
extern void glSecondaryColor3fvEXT(const GLfloat *v);
extern void glSecondaryColor3iEXT(GLint red, GLint green, GLint blue);
extern void glSecondaryColor3ivEXT(const GLint *v);
extern void glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue);
extern void glSecondaryColor3svEXT(const GLshort *v);
extern void glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue);
extern void glSecondaryColor3ubvEXT(const GLubyte *v);
extern void glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue);
extern void glSecondaryColor3uivEXT(const GLuint *v);
extern void glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue);
extern void glSecondaryColor3usvEXT(const GLushort *v);
extern void glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_stencil_two_side
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glActiveStencilFaceEXTProcPtr) (GLenum face);
#else
extern void glActiveStencilFaceEXT(GLenum face);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_subtexture
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glTexSubImage1DEXTProcPtr) (GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *);
typedef void (* glTexSubImage2DEXTProcPtr) (GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
#else
extern void glTexSubImage1DEXT(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *);
extern void glTexSubImage2DEXT(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_texture3D
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glTexImage3DEXTProcPtr) (GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
typedef void (* glTexSubImage3DEXTProcPtr) (GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
#else
extern void glTexImage3DEXT(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
extern void glTexSubImage3DEXT(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_texture_integer
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (*glClearColorIiEXTProcPtr) ( GLint r, GLint g, GLint b, GLint a );
typedef void (*glClearColorIuiEXTProcPtr) ( GLuint r, GLuint g, GLuint b, GLuint a );
typedef void (*glTexParameterIivEXTProcPtr)( GLenum target, GLenum pname, GLint *params );
typedef void (*glTexParameterIuivEXTProcPtr)( GLenum target, GLenum pname, GLuint *params );
typedef void (*glGetTexParameterIivEXTProcPtr) ( GLenum target, GLenum pname, GLint *params);
typedef void (*glGetTexParameterIuivEXTProcPtr) ( GLenum target, GLenum pname, GLuint *params);
#else
extern void glClearColorIiEXT( GLint r, GLint g, GLint b, GLint a );
extern void glClearColorIuiEXT( GLuint r, GLuint g, GLuint b, GLuint a );
extern void glTexParameterIivEXT( GLenum target, GLenum pname, GLint *params );
extern void glTexParameterIuivEXT( GLenum target, GLenum pname, GLuint *params );
extern void glGetTexParameterIivEXT( GLenum target, GLenum pname, GLint *params);
extern void glGetTexParameterIuivEXT( GLenum target, GLenum pname, GLuint *params);
#endif
#endif /* GL_EXT_texture_integer */

#if GL_EXT_texture_object
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef GLboolean (* glAreTexturesResidentEXTProcPtr) (GLsizei, const GLuint *, GLboolean *);
typedef void (* glBindTextureEXTProcPtr) (GLenum, GLuint);
typedef void (* glDeleteTexturesEXTProcPtr) (GLsizei, const GLuint *);
typedef void (* glGenTexturesEXTProcPtr) (GLsizei, GLuint *);
typedef GLboolean (* glIsTextureEXTProcPtr) (GLuint);
typedef void (* glPrioritizeTexturesEXTProcPtr) (GLsizei, const GLuint *, const GLclampf *);
#else
extern GLboolean glAreTexturesResidentEXT(GLsizei, const GLuint *, GLboolean *);
extern void glBindTextureEXT(GLenum, GLuint);
extern void glDeleteTexturesEXT(GLsizei, const GLuint *);
extern void glGenTexturesEXT(GLsizei, GLuint *);
extern GLboolean glIsTextureEXT(GLuint);
extern void glPrioritizeTexturesEXT(GLsizei, const GLuint *, const GLclampf *);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_timer_query
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glGetQueryObjecti64vEXTProcPtr)(GLuint id, GLenum pname, GLint64EXT *params);
typedef void (* glGetQueryObjectui64vEXTProcPtr)(GLuint id, GLenum pname, GLuint64EXT *params);
#else
extern void glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT *params);
extern void glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT *params);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_EXT_transform_feedback
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glBindBufferRangeEXTProcPtr) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (* glBindBufferOffsetEXTProcPtr) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void (* glBindBufferBaseEXTProcPtr) (GLenum target, GLuint index, GLuint buffer);
typedef void (* glBeginTransformFeedbackEXTProcPtr) (GLenum primitiveMode);
typedef void (* glEndTransformFeedbackEXTProcPtr) (void);
typedef void (* glTransformFeedbackVaryingsEXTProcPtr) (GLuint program, GLsizei count, const GLchar* const *varyings, GLenum bufferMode);
typedef void (* glGetTransformFeedbackVaryingEXTProcPtr) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
#else
extern void glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
extern void glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset);
extern void glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer);
extern void glBeginTransformFeedbackEXT(GLenum primitiveMode);
extern void glEndTransformFeedbackEXT(void);
extern void glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar* const *varyings, GLenum bufferMode);
extern void glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
#endif
#endif /* GL_EXT_transform_feedback */

#if GL_EXT_transform_feedback || GL_EXT_draw_buffers2
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glGetIntegerIndexedvEXTProcPtr) (GLenum param, GLint index, GLint *values);
typedef void (* glGetBooleanIndexedvEXTProcPtr) (GLenum param, GLint index, GLboolean *values);
#else
extern void glGetIntegerIndexedvEXT(GLenum param, GLuint index, GLint *values);
extern void glGetBooleanIndexedvEXT(GLenum param, GLuint index, GLboolean *values);
#endif
#endif /* GL_EXT_transform_feedback || GL_EXT_draw_buffers2 */

#if GL_EXT_vertex_array
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glArrayElementEXTProcPtr) (GLint);
typedef void (* glColorPointerEXTProcPtr) (GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
typedef void (* glDrawArraysEXTProcPtr) (GLenum, GLint, GLsizei);
typedef void (* glEdgeFlagPointerEXTProcPtr) (GLsizei, GLsizei, const GLvoid *);
typedef void (* glGetPointervEXTProcPtr) (GLenum, GLvoid **);
typedef void (* glIndexPointerEXTProcPtr) (GLenum, GLsizei, GLsizei, const GLvoid *);
typedef void (* glNormalPointerEXTProcPtr) (GLenum, GLsizei, GLsizei, const GLvoid *);
typedef void (* glTexCoordPointerEXTProcPtr) (GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
typedef void (* glVertexPointerEXTProcPtr) (GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
#else
extern void glArrayElementEXT(GLint);
extern void glColorPointerEXT(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
extern void glDrawArraysEXT(GLenum, GLint, GLsizei);
extern void glEdgeFlagPointerEXT(GLsizei, GLsizei, const GLvoid *);
extern void glGetPointervEXT(GLenum, GLvoid **);
extern void glIndexPointerEXT(GLenum, GLsizei, GLsizei, const GLvoid *);
extern void glNormalPointerEXT(GLenum, GLsizei, GLsizei, const GLvoid *);
extern void glTexCoordPointerEXT(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
extern void glVertexPointerEXT(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_APPLE_element_array
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glElementPointerAPPLEProcPtr) (GLenum type, const GLvoid *pointer);
typedef void (* glDrawElementArrayAPPLEProcPtr) (GLenum mode, GLint first, GLsizei count);
typedef void (* glDrawRangeElementArrayAPPLEProcPtr) (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
typedef void (* glMultiDrawElementArrayAPPLEProcPtr) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
typedef void (* glMultiDrawRangeElementArrayAPPLEProcPtr) (GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount);
#else
extern void glElementPointerAPPLE(GLenum type, const GLvoid *pointer);
extern void glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count);
extern void glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
extern void glMultiDrawElementArrayAPPLE(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
extern void glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_APPLE_fence
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glGenFencesAPPLEProcPtr) (GLsizei n, GLuint *fences);
typedef void (* glDeleteFencesAPPLEProcPtr) (GLsizei n, const GLuint *fences);
typedef void (* glSetFenceAPPLEProcPtr) (GLuint fence);
typedef GLboolean (* glIsFenceAPPLEProcPtr) (GLuint fence);
typedef GLboolean (* glTestFenceAPPLEProcPtr) (GLuint fence);
typedef void (* glFinishFenceAPPLEProcPtr) (GLuint fence);
typedef GLboolean (* glTestObjectAPPLEProcPtr) (GLenum object, GLuint name);
typedef void (* glFinishObjectAPPLEProcPtr) (GLenum object, GLuint name);
#else
extern void glGenFencesAPPLE(GLsizei n, GLuint *fences);
extern void glDeleteFencesAPPLE(GLsizei n, const GLuint *fences);
extern void glSetFenceAPPLE(GLuint fence);
extern GLboolean glIsFenceAPPLE(GLuint fence);
extern GLboolean glTestFenceAPPLE(GLuint fence);
extern void glFinishFenceAPPLE(GLuint fence);
extern GLboolean glTestObjectAPPLE(GLenum object, GLuint name);
extern void glFinishObjectAPPLE(GLenum object, GLuint name);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_APPLE_flush_buffer_range
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glBufferParameteriAPPLEProcPtr) (GLenum target, GLenum pname, GLint param);
typedef void (* glFlushMappedBufferRangeAPPLEProcPtr) (GLenum target, GLintptr offset, GLsizeiptr size);
#else
extern void glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param);
extern void glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_APPLE_flush_render
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glFlushRenderAPPLEProcPtr) (void);
typedef void (* glFinishRenderAPPLEProcPtr) (void);
typedef void (* glSwapAPPLEProcPtr) (void);
#else
extern void glFlushRenderAPPLE(void);
extern void glFinishRenderAPPLE(void);
extern void glSwapAPPLE(void);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_APPLE_object_purgeable
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef GLenum (* glObjectPurgeableAPPLEProcPtr) (GLenum objectType, GLuint name, GLenum option);
typedef GLenum (* glObjectUnpurgeableAPPLEProcPtr) (GLenum objectType, GLuint name, GLenum option);
typedef void (* glGetObjectParameterivAPPLEProcPtr) (GLenum objectType, GLuint name, GLenum pname, GLint *params);
#else
extern GLenum glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);
extern GLenum glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option);
extern void glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint *params);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_APPLE_texture_range
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glTextureRangeAPPLEProcPtr) (GLenum target, GLsizei length, const GLvoid *pointer);
typedef void (* glGetTexParameterPointervAPPLEProcPtr) (GLenum target, GLenum pname, GLvoid **params);
#else
extern void glTextureRangeAPPLE(GLenum target, GLsizei length, const GLvoid *pointer);
extern void glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid **params);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_APPLE_vertex_array_object
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glBindVertexArrayAPPLEProcPtr) (GLuint id);
typedef void (* glDeleteVertexArraysAPPLEProcPtr) (GLsizei n, const GLuint *ids);
typedef void (* glGenVertexArraysAPPLEProcPtr) (GLsizei n, GLuint *ids);
typedef GLboolean (* glIsVertexArrayAPPLEProcPtr) (GLuint id);
#else
extern void glBindVertexArrayAPPLE(GLuint id);
extern void glDeleteVertexArraysAPPLE(GLsizei n, const GLuint *ids);
extern void glGenVertexArraysAPPLE(GLsizei n, GLuint *ids);
extern GLboolean glIsVertexArrayAPPLE(GLuint id);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_APPLE_vertex_array_range
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glVertexArrayRangeAPPLEProcPtr) (GLsizei length, const GLvoid *pointer);
typedef void (* glFlushVertexArrayRangeAPPLEProcPtr) (GLsizei length, const GLvoid *pointer);
typedef void (* glVertexArrayParameteriAPPLEProcPtr) (GLenum pname, GLint param);
#else
extern void glVertexArrayRangeAPPLE(GLsizei length, const GLvoid *pointer);
extern void glFlushVertexArrayRangeAPPLE(GLsizei length, const GLvoid *pointer);
extern void glVertexArrayParameteriAPPLE(GLenum pname, GLint param);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_APPLE_vertex_point_size
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glPointSizePointerAPPLEProcPtr) (GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (* glVertexPointSizefAPPLEProcPtr) (GLfloat size);
#else
extern void glPointSizePointerAPPLE(GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glVertexPointSizefAPPLE(GLfloat size);
#endif
#endif

#if GL_APPLE_vertex_program_evaluators
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glEnableVertexAttribAPPLEProcPtr) (GLuint index, GLenum pname);
typedef void (* glDisableVertexAttribAPPLEProcPtr) (GLuint index, GLenum pname);
typedef GLboolean (* glIsVertexAttribEnabledAPPLEProcPtr) (GLuint index, GLenum pname);
typedef void (* glMapVertexAttrib1dAPPLEProcPtr) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
typedef void (* glMapVertexAttrib1fAPPLEProcPtr) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
typedef void (* glMapVertexAttrib2dAPPLEProcPtr) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
typedef void (* glMapVertexAttrib2fAPPLEProcPtr) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
#else
extern void glEnableVertexAttribAPPLE(GLuint index, GLenum pname);
extern void glDisableVertexAttribAPPLE(GLuint index, GLenum pname);
extern GLboolean glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname);
extern void glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern void glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern void glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern void glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ATI_blend_equation_separate
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glBlendEquationSeparateATIProcPtr) (GLenum equationRGB, GLenum equationAlpha);
#else
extern void glBlendEquationSeparateATI(GLenum equationRGB, GLenum equationAlpha);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ATI_pn_triangles
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glPNTrianglesiATIProcPtr) (GLenum pname, GLint param);
typedef void (* glPNTrianglesfATIProcPtr) (GLenum pname, GLfloat param);
#else
extern void glPNTrianglesiATI(GLenum pname, GLint param);
extern void glPNTrianglesfATI(GLenum pname, GLfloat param);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ATI_separate_stencil
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glStencilOpSeparateATIProcPtr) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void (* glStencilFuncSeparateATIProcPtr) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
#else
extern void glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
extern void glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_ATIX_pn_triangles
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glPNTrianglesiATIXProcPtr) (GLenum pname, GLint param);
typedef void (* glPNTrianglesfATIXProcPtr) (GLenum pname, GLfloat param);
#else
extern void glPNTrianglesiATIX(GLenum pname, GLint param);
extern void glPNTrianglesfATIX(GLenum pname, GLfloat param);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_NV_conditional_render
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glBeginConditionalRenderNVProcPtr) (GLuint id, GLenum mode);
typedef void (* glEndConditionalRenderNVProcPtr) (void);
#else
extern void glBeginConditionalRenderNV(GLuint id, GLenum mode);
extern void glEndConditionalRenderNV(void);
#endif
#endif

#if GL_NV_point_sprite
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glPointParameteriNVProcPtr) (GLenum pname, GLint param);
typedef void (* glPointParameterivNVProcPtr) (GLenum pname, const GLint *params);
#else
extern void glPointParameteriNV(GLenum pname, GLint param);
extern void glPointParameterivNV(GLenum pname, const GLint *params);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_NV_register_combiners
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glCombinerParameterfvNVProcPtr) (GLenum, const GLfloat *);
typedef void (* glCombinerParameterfNVProcPtr) (GLenum, GLfloat);
typedef void (* glCombinerParameterivNVProcPtr) (GLenum, const GLint *);
typedef void (* glCombinerParameteriNVProcPtr) (GLenum, GLint);
typedef void (* glCombinerInputNVProcPtr) (GLenum, GLenum, GLenum, GLenum, GLenum, GLenum);
typedef void (* glCombinerOutputNVProcPtr) (GLenum, GLenum, GLenum, GLenum, GLenum, GLenum, GLenum, GLboolean, GLboolean, GLboolean);
typedef void (* glFinalCombinerInputNVProcPtr) (GLenum, GLenum, GLenum, GLenum);
typedef void (* glGetCombinerInputParameterfvNVProcPtr) (GLenum, GLenum, GLenum, GLenum, GLfloat *);
typedef void (* glGetCombinerInputParameterivNVProcPtr) (GLenum, GLenum, GLenum, GLenum, GLint *);
typedef void (* glGetCombinerOutputParameterfvNVProcPtr) (GLenum, GLenum, GLenum, GLfloat *);
typedef void (* glGetCombinerOutputParameterivNVProcPtr) (GLenum, GLenum, GLenum, GLint *);
typedef void (* glGetFinalCombinerInputParameterfvNVProcPtr) (GLenum, GLenum, GLfloat *);
typedef void (* glGetFinalCombinerInputParameterivNVProcPtr) (GLenum, GLenum, GLint *);
#else
extern void glCombinerParameterfvNV (GLenum, const GLfloat *);
extern void glCombinerParameterfNV (GLenum, GLfloat);
extern void glCombinerParameterivNV (GLenum, const GLint *);
extern void glCombinerParameteriNV (GLenum, GLint);
extern void glCombinerInputNV (GLenum, GLenum, GLenum, GLenum, GLenum, GLenum);
extern void glCombinerOutputNV (GLenum, GLenum, GLenum, GLenum, GLenum, GLenum, GLenum, GLboolean, GLboolean, GLboolean);
extern void glFinalCombinerInputNV (GLenum, GLenum, GLenum, GLenum);
extern void glGetCombinerInputParameterfvNV (GLenum, GLenum, GLenum, GLenum, GLfloat *);
extern void glGetCombinerInputParameterivNV (GLenum, GLenum, GLenum, GLenum, GLint *);
extern void glGetCombinerOutputParameterfvNV (GLenum, GLenum, GLenum, GLfloat *);
extern void glGetCombinerOutputParameterivNV (GLenum, GLenum, GLenum, GLint *);
extern void glGetFinalCombinerInputParameterfvNV (GLenum, GLenum, GLfloat *);
extern void glGetFinalCombinerInputParameterivNV (GLenum, GLenum, GLint *);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_NV_register_combiners2
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glCombinerStageParameterfvNVProcPtr) (GLenum, GLenum, const GLfloat *);
typedef void (* glGetCombinerStageParameterfvNVProcPtr) (GLenum, GLenum, GLfloat *);
#else
extern void glCombinerStageParameterfvNV (GLenum, GLenum, const GLfloat *);
extern void glGetCombinerStageParameterfvNV (GLenum, GLenum, GLfloat *);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_NV_texture_barrier
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glTextureBarrierNVProcPtr) (void);
#else
extern void glTextureBarrierNV (void);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_NV_vertex_array_range
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glFlushVertexArrayRangeNVProcPtr) (void);
typedef void (* glVertexArrayRangeNVProcPtr) (GLsizei, const GLvoid *);
#else
extern void glFlushVertexArrayRangeNV (void);
extern void glVertexArrayRangeNV (GLsizei, const GLvoid *);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_NV_vertex_program
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glBindProgramNVProcPtr) (GLenum target, GLuint id);
typedef void (* glDeleteProgramsNVProcPtr) (GLsizei n, const GLuint *ids);
typedef void (* glExecuteProgramNVProcPtr) (GLenum target, GLuint id, const GLfloat *params);
typedef void (* glGenProgramsNVProcPtr) (GLsizei n, GLuint *ids);
typedef GLboolean (* glAreProgramsResidentNVProcPtr) (GLsizei n, const GLuint *ids, GLboolean *residences);
typedef void (* glRequestResidentProgramsNVProcPtr) (GLsizei n, GLuint *ids);
typedef void (* glGetProgramParameterfvNVProcPtr) (GLenum target, GLuint index, GLenum pname, GLfloat *params);
typedef void (* glGetProgramParameterdvNVProcPtr) (GLenum target, GLuint index, GLenum pname, GLdouble *params);
typedef void (* glGetProgramivNVProcPtr) (GLuint id, GLenum pname, GLint *params);
typedef void (* glGetProgramStringNVProcPtr) (GLuint id, GLenum pname, GLubyte *program);
typedef void (* glGetTrackMatrixivNVProcPtr) (GLenum target, GLuint address, GLenum pname, GLint *params);
typedef void (* glGetVertexAttribdvNVProcPtr) (GLuint index, GLenum pname, GLdouble *params);
typedef void (* glGetVertexAttribfvNVProcPtr) (GLuint index, GLenum pname, GLfloat *params);
typedef void (* glGetVertexAttribivNVProcPtr) (GLuint index, GLenum pname, GLint *params);
typedef void (* glGetVertexAttribPointervNVProcPtr) (GLuint index, GLenum pname, GLvoid **pointer);
typedef GLboolean (* glIsProgramNVProcPtr) (GLuint id);
typedef void (* glLoadProgramNVProcPtr) (GLenum target, GLuint id, GLsizei len, const GLubyte *program);
typedef void (* glProgramParameter4fNVProcPtr) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (* glProgramParameter4dNVProcPtr) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (* glProgramParameter4dvNVProcPtr) (GLenum target, GLuint index, const GLdouble *params);
typedef void (* glProgramParameter4fvNVProcPtr) (GLenum target, GLuint index, const GLfloat *params);
typedef void (* glProgramParameters4dvNVProcPtr) (GLenum target, GLuint index, GLuint num, const GLdouble *params);
typedef void (* glProgramParameters4fvNVProcPtr) (GLenum target, GLuint index, GLuint num, const GLfloat *params);
typedef void (* glTrackMatrixNVProcPtr) (GLenum target, GLuint address, GLenum matrix, GLenum transform);
typedef void (* glVertexAttribPointerNVProcPtr) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (* glVertexAttrib1sNVProcPtr) (GLuint index, GLshort x);
typedef void (* glVertexAttrib1fNVProcPtr) (GLuint index, GLfloat x);
typedef void (* glVertexAttrib1dNVProcPtr) (GLuint index, GLdouble x);
typedef void (* glVertexAttrib2sNVProcPtr) (GLuint index, GLshort x, GLshort y);
typedef void (* glVertexAttrib2fNVProcPtr) (GLuint index, GLfloat x, GLfloat y);
typedef void (* glVertexAttrib2dNVProcPtr) (GLuint index, GLdouble x, GLdouble y);
typedef void (* glVertexAttrib3sNVProcPtr) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (* glVertexAttrib3fNVProcPtr) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (* glVertexAttrib3dNVProcPtr) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (* glVertexAttrib4sNVProcPtr) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (* glVertexAttrib4fNVProcPtr) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (* glVertexAttrib4dNVProcPtr) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (* glVertexAttrib4ubNVProcPtr) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (* glVertexAttrib1svNVProcPtr) (GLuint index, GLshort *v);
typedef void (* glVertexAttrib1fvNVProcPtr) (GLuint index, GLfloat *v);
typedef void (* glVertexAttrib1dvNVProcPtr) (GLuint index, GLdouble *v);
typedef void (* glVertexAttrib2svNVProcPtr) (GLuint index, GLshort *v);
typedef void (* glVertexAttrib2fvNVProcPtr) (GLuint index, GLfloat *v);
typedef void (* glVertexAttrib2dvNVProcPtr) (GLuint index, GLdouble *v);
typedef void (* glVertexAttrib3svNVProcPtr) (GLuint index, GLshort *v);
typedef void (* glVertexAttrib3fvNVProcPtr) (GLuint index, GLfloat *v);
typedef void (* glVertexAttrib3dvNVProcPtr) (GLuint index, GLdouble *v);
typedef void (* glVertexAttrib4svNVProcPtr) (GLuint index, GLshort *v);
typedef void (* glVertexAttrib4fvNVProcPtr) (GLuint index, GLfloat *v);
typedef void (* glVertexAttrib4dvNVProcPtr) (GLuint index, GLdouble *v);
typedef void (* glVertexAttrib4ubvNVProcPtr) (GLuint index, GLubyte *v);
typedef void (* glVertexAttribs1svNVProcPtr) (GLuint index, GLsizei n, GLshort *v);
typedef void (* glVertexAttribs1fvNVProcPtr) (GLuint index, GLsizei n, GLfloat *v);
typedef void (* glVertexAttribs1dvNVProcPtr) (GLuint index, GLsizei n, GLdouble *v);
typedef void (* glVertexAttribs2svNVProcPtr) (GLuint index, GLsizei n, GLshort *v);
typedef void (* glVertexAttribs2fvNVProcPtr) (GLuint index, GLsizei n, GLfloat *v);
typedef void (* glVertexAttribs2dvNVProcPtr) (GLuint index, GLsizei n, GLdouble *v);
typedef void (* glVertexAttribs3svNVProcPtr) (GLuint index, GLsizei n, GLshort *v);
typedef void (* glVertexAttribs3fvNVProcPtr) (GLuint index, GLsizei n, GLfloat *v);
typedef void (* glVertexAttribs3dvNVProcPtr) (GLuint index, GLsizei n, GLdouble *v);
typedef void (* glVertexAttribs4svNVProcPtr) (GLuint index, GLsizei n, GLshort *v);
typedef void (* glVertexAttribs4fvNVProcPtr) (GLuint index, GLsizei n, GLfloat *v);
typedef void (* glVertexAttribs4dvNVProcPtr) (GLuint index, GLsizei n, GLdouble *v);
typedef void (* glVertexAttribs4ubvNVProcPtr) (GLuint index, GLsizei n, GLubyte *v);
#else
extern void glBindProgramNV(GLenum target, GLuint id);
extern void glDeleteProgramsNV(GLsizei n, const GLuint *ids);
extern void glExecuteProgramNV(GLenum target, GLuint id, const GLfloat *params);
extern void glGenProgramsNV(GLsizei n, GLuint *ids);
extern GLboolean glAreProgramsResidentNV(GLsizei n, const GLuint *ids, GLboolean *residences);
extern void glRequestResidentProgramsNV(GLsizei n, GLuint *ids);
extern void glGetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat *params);
extern void glGetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble *params);
extern void glGetProgramivNV(GLuint id, GLenum pname, GLint *params);
extern void glGetProgramStringNV(GLuint id, GLenum pname, GLubyte *program);
extern void glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint *params);
extern void glGetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble *params);
extern void glGetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat *params);
extern void glGetVertexAttribivNV(GLuint index, GLenum pname, GLint *params);
extern void glGetVertexAttribPointervNV(GLuint index, GLenum pname, GLvoid **pointer);
extern GLboolean glIsProgramNV(GLuint id);
extern void glLoadProgramNV(GLenum target, GLuint id, GLsizei len, const GLubyte *program);
extern void glProgramParameter4fNV(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glProgramParameter4dNV(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glProgramParameter4dvNV(GLenum target, GLuint index, const GLdouble *params);
extern void glProgramParameter4fvNV(GLenum target, GLuint index, const GLfloat *params);
extern void glProgramParameters4dvNV(GLenum target, GLuint index, GLuint num, const GLdouble *params);
extern void glProgramParameters4fvNV(GLenum target, GLuint index, GLuint num, const GLfloat *params);
extern void glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix, GLenum transform);
extern void glVertexAttribPointerNV(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glVertexAttrib1sNV(GLuint index, GLshort x);
extern void glVertexAttrib1fNV(GLuint index, GLfloat x);
extern void glVertexAttrib1dNV(GLuint index, GLdouble x);
extern void glVertexAttrib2sNV(GLuint index, GLshort x, GLshort y);
extern void glVertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y);
extern void glVertexAttrib2dNV(GLuint index, GLdouble x, GLdouble y);
extern void glVertexAttrib3sNV(GLuint index, GLshort x, GLshort y, GLshort z);
extern void glVertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z);
extern void glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z);
extern void glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
extern void glVertexAttrib1svNV(GLuint index, GLshort *v);
extern void glVertexAttrib1fvNV(GLuint index, GLfloat *v);
extern void glVertexAttrib1dvNV(GLuint index, GLdouble *v);
extern void glVertexAttrib2svNV(GLuint index, GLshort *v);
extern void glVertexAttrib2fvNV(GLuint index, GLfloat *v);
extern void glVertexAttrib2dvNV(GLuint index, GLdouble *v);
extern void glVertexAttrib3svNV(GLuint index, GLshort *v);
extern void glVertexAttrib3fvNV(GLuint index, GLfloat *v);
extern void glVertexAttrib3dvNV(GLuint index, GLdouble *v);
extern void glVertexAttrib4svNV(GLuint index, GLshort *v);
extern void glVertexAttrib4fvNV(GLuint index, GLfloat *v);
extern void glVertexAttrib4dvNV(GLuint index, GLdouble *v);
extern void glVertexAttrib4ubvNV(GLuint index, GLubyte *v);
extern void glVertexAttribs1svNV(GLuint index, GLsizei n, GLshort *v);
extern void glVertexAttribs1fvNV(GLuint index, GLsizei n, GLfloat *v);
extern void glVertexAttribs1dvNV(GLuint index, GLsizei n, GLdouble *v);
extern void glVertexAttribs2svNV(GLuint index, GLsizei n, GLshort *v);
extern void glVertexAttribs2fvNV(GLuint index, GLsizei n, GLfloat *v);
extern void glVertexAttribs2dvNV(GLuint index, GLsizei n, GLdouble *v);
extern void glVertexAttribs3svNV(GLuint index, GLsizei n, GLshort *v);
extern void glVertexAttribs3fvNV(GLuint index, GLsizei n, GLfloat *v);
extern void glVertexAttribs3dvNV(GLuint index, GLsizei n, GLdouble *v);
extern void glVertexAttribs4svNV(GLuint index, GLsizei n, GLshort *v);
extern void glVertexAttribs4fvNV(GLuint index, GLsizei n, GLfloat *v);
extern void glVertexAttribs4dvNV(GLuint index, GLsizei n, GLdouble *v);
extern void glVertexAttribs4ubvNV(GLuint index, GLsizei n, GLubyte *v);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#if GL_SGI_color_table
#ifdef GL_GLEXT_FUNCTION_POINTERS
typedef void (* glColorTableSGIProcPtr) (GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
typedef void (* glColorTableParameterfvSGIProcPtr) (GLenum, GLenum, const GLfloat *);
typedef void (* glColorTableParameterivSGIProcPtr) (GLenum, GLenum, const GLint *);
typedef void (* glCopyColorTableSGIProcPtr) (GLenum, GLenum, GLint, GLint, GLsizei);
typedef void (* glGetColorTableSGIProcPtr) (GLenum, GLenum, GLenum, GLvoid *);
typedef void (* glGetColorTableParameterfvSGIProcPtr) (GLenum, GLenum, GLfloat *);
typedef void (* glGetColorTableParameterivSGIProcPtr) (GLenum, GLenum, GLint *);
#else
extern void glColorTableSGI (GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
extern void glColorTableParameterfvSGI (GLenum, GLenum, const GLfloat *);
extern void glColorTableParameterivSGI (GLenum, GLenum, const GLint *);
extern void glCopyColorTableSGI (GLenum, GLenum, GLint, GLint, GLsizei);
extern void glGetColorTableSGI (GLenum, GLenum, GLenum, GLvoid *);
extern void glGetColorTableParameterfvSGI (GLenum, GLenum, GLfloat *);
extern void glGetColorTableParameterivSGI (GLenum, GLenum, GLint *);
#endif /* GL_GLEXT_FUNCTION_POINTERS */
#endif

#ifdef __cplusplus
}
#endif

#endif
                                gliContext.h                                                                                        0100644 0001750 0001750 00000000507 12567471556 033255  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers                                                                      /*
	Copyright:	(c) 1999-2012 Apple Inc. All rights reserved.
*/

#ifndef _GLICONTEXT_H
#define _GLICONTEXT_H

#ifdef __cplusplus
extern "C" {
#endif


/*
** GL context data type
*/
typedef struct __GLIContextRec *GLIContext;
typedef struct __GLISharedRec  *GLIShared;


#ifdef __cplusplus
}
#endif

#endif /* _GLICONTEXT_H */

                                                                                                                                                                                         gliDispatch.h                                                                                       0100644 0001750 0001750 00000252655 12567471556 033405  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers                                                                      /*
	Copyright:	(c) 1999-2013 Apple Inc. All rights reserved.
*/

#ifndef _GLIDISPATCH_H
#define _GLIDISPATCH_H

#include <OpenGL/gltypes.h>
#include <OpenGL/gliContext.h>

#ifdef __cplusplus
extern "C" {
#endif


/*
** GL function dispatch table type
*/
typedef struct __GLIFunctionDispatchRec
{
	void (*accum)(GLIContext ctx, GLenum op, GLfloat value);
	void (*alpha_func)(GLIContext ctx, GLenum func, GLclampf ref);
	GLboolean (*are_textures_resident)(GLIContext ctx, GLsizei n, const GLuint *textures, GLboolean *residences);
	void (*array_element)(GLIContext ctx, GLint i);
	void (*begin)(GLIContext ctx, GLenum mode);
	void (*bind_texture)(GLIContext ctx, GLenum target, GLuint texture);
	void (*bitmap)(GLIContext ctx, GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
	void (*blend_func)(GLIContext ctx, GLenum sfactor, GLenum dfactor);
	void (*call_list)(GLIContext ctx, GLuint list);
	void (*call_lists)(GLIContext ctx, GLsizei n, GLenum type, const GLvoid *lists);
	void (*clear)(GLIContext ctx, GLbitfield mask);
	void (*clear_accum)(GLIContext ctx, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
	void (*clear_color)(GLIContext ctx, GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
	void (*clear_depth)(GLIContext ctx, GLclampd depth);
	void (*clear_index)(GLIContext ctx, GLfloat c);
	void (*clear_stencil)(GLIContext ctx, GLint s);
	void (*clip_plane)(GLIContext ctx, GLenum plane, const GLdouble *equation);
	void (*color3b)(GLIContext ctx, GLbyte red, GLbyte green, GLbyte blue);
	void (*color3bv)(GLIContext ctx, const GLbyte *v);
	void (*color3d)(GLIContext ctx, GLdouble red, GLdouble green, GLdouble blue);
	void (*color3dv)(GLIContext ctx, const GLdouble *v);
	void (*color3f)(GLIContext ctx, GLfloat red, GLfloat green, GLfloat blue);
	void (*color3fv)(GLIContext ctx, const GLfloat *v);
	void (*color3i)(GLIContext ctx, GLint red, GLint green, GLint blue);
	void (*color3iv)(GLIContext ctx, const GLint *v);
	void (*color3s)(GLIContext ctx, GLshort red, GLshort green, GLshort blue);
	void (*color3sv)(GLIContext ctx, const GLshort *v);
	void (*color3ub)(GLIContext ctx, GLubyte red, GLubyte green, GLubyte blue);
	void (*color3ubv)(GLIContext ctx, const GLubyte *v);
	void (*color3ui)(GLIContext ctx, GLuint red, GLuint green, GLuint blue);
	void (*color3uiv)(GLIContext ctx, const GLuint *v);
	void (*color3us)(GLIContext ctx, GLushort red, GLushort green, GLushort blue);
	void (*color3usv)(GLIContext ctx, const GLushort *v);
	void (*color4b)(GLIContext ctx, GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
	void (*color4bv)(GLIContext ctx, const GLbyte *v);
	void (*color4d)(GLIContext ctx, GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
	void (*color4dv)(GLIContext ctx, const GLdouble *v);
	void (*color4f)(GLIContext ctx, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
	void (*color4fv)(GLIContext ctx, const GLfloat *v);
	void (*color4i)(GLIContext ctx, GLint red, GLint green, GLint blue, GLint alpha);
	void (*color4iv)(GLIContext ctx, const GLint *v);
	void (*color4s)(GLIContext ctx, GLshort red, GLshort green, GLshort blue, GLshort alpha);
	void (*color4sv)(GLIContext ctx, const GLshort *v);
	void (*color4ub)(GLIContext ctx, GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
	void (*color4ubv)(GLIContext ctx, const GLubyte *v);
	void (*color4ui)(GLIContext ctx, GLuint red, GLuint green, GLuint blue, GLuint alpha);
	void (*color4uiv)(GLIContext ctx, const GLuint *v);
	void (*color4us)(GLIContext ctx, GLushort red, GLushort green, GLushort blue, GLushort alpha);
	void (*color4usv)(GLIContext ctx, const GLushort *v);
	void (*color_mask)(GLIContext ctx, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
	void (*color_material)(GLIContext ctx, GLenum face, GLenum mode);
	void (*color_pointer)(GLIContext ctx, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
	void (*copy_pixels)(GLIContext ctx, GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
	void (*copy_tex_image1D)(GLIContext ctx, GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
	void (*copy_tex_image2D)(GLIContext ctx, GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
	void (*copy_tex_sub_image1D)(GLIContext ctx, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
	void (*copy_tex_sub_image2D)(GLIContext ctx, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	void (*cull_face)(GLIContext ctx, GLenum mode);
	void (*delete_lists)(GLIContext ctx, GLuint list, GLsizei range);
	void (*delete_textures)(GLIContext ctx, GLsizei n, const GLuint *textures);
	void (*depth_func)(GLIContext ctx, GLenum func);
	void (*depth_mask)(GLIContext ctx, GLboolean flag);
	void (*depth_range)(GLIContext ctx, GLclampd zNear, GLclampd zFar);
	void (*disable)(GLIContext ctx, GLenum cap);
	void (*disable_client_state)(GLIContext ctx, GLenum array);
	void (*draw_arrays)(GLIContext ctx, GLenum mode, GLint first, GLsizei count);
	void (*draw_buffer)(GLIContext ctx, GLenum mode);
	void (*draw_elements)(GLIContext ctx, GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
	void (*draw_pixels)(GLIContext ctx, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
	void (*edge_flag)(GLIContext ctx, GLboolean flag);
	void (*edge_flag_pointer)(GLIContext ctx, GLsizei stride, const GLvoid *pointer);
	void (*edge_flagv)(GLIContext ctx, const GLboolean *flag);
	void (*enable)(GLIContext ctx, GLenum cap);
	void (*enable_client_state)(GLIContext ctx, GLenum array);
	void (*end)(GLIContext ctx);
	void (*end_list)(GLIContext ctx);
	void (*eval_coord1d)(GLIContext ctx, GLdouble u);
	void (*eval_coord1dv)(GLIContext ctx, const GLdouble *u);
	void (*eval_coord1f)(GLIContext ctx, GLfloat u);
	void (*eval_coord1fv)(GLIContext ctx, const GLfloat *u);
	void (*eval_coord2d)(GLIContext ctx, GLdouble u, GLdouble v);
	void (*eval_coord2dv)(GLIContext ctx, const GLdouble *u);
	void (*eval_coord2f)(GLIContext ctx, GLfloat u, GLfloat v);
	void (*eval_coord2fv)(GLIContext ctx, const GLfloat *u);
	void (*eval_mesh1)(GLIContext ctx, GLenum mode, GLint i1, GLint i2);
	void (*eval_mesh2)(GLIContext ctx, GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
	void (*eval_point1)(GLIContext ctx, GLint i);
	void (*eval_point2)(GLIContext ctx, GLint i, GLint j);
	void (*feedback_buffer)(GLIContext ctx, GLsizei size, GLenum type, GLfloat *buffer);
	void (*finish)(GLIContext ctx);
	void (*flush)(GLIContext ctx);
	void (*fogf)(GLIContext ctx, GLenum pname, GLfloat param);
	void (*fogfv)(GLIContext ctx, GLenum pname, const GLfloat *params);
	void (*fogi)(GLIContext ctx, GLenum pname, GLint param);
	void (*fogiv)(GLIContext ctx, GLenum pname, const GLint *params);
	void (*front_face)(GLIContext ctx, GLenum mode);
	void (*frustum)(GLIContext ctx, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
	GLuint (*gen_lists)(GLIContext ctx, GLsizei range);
	void (*gen_textures)(GLIContext ctx, GLsizei n, GLuint *textures);
	void (*get_booleanv)(GLIContext ctx, GLenum pname, GLboolean *params);
	void (*get_clip_plane)(GLIContext ctx, GLenum plane, GLdouble *equation);
	void (*get_doublev)(GLIContext ctx, GLenum pname, GLdouble *params);
	GLenum (*get_error)(GLIContext ctx);
	void (*get_floatv)(GLIContext ctx, GLenum pname, GLfloat *params);
	void (*get_integerv)(GLIContext ctx, GLenum pname, GLint *params);
	void (*get_lightfv)(GLIContext ctx, GLenum light, GLenum pname, GLfloat *params);
	void (*get_lightiv)(GLIContext ctx, GLenum light, GLenum pname, GLint *params);
	void (*get_mapdv)(GLIContext ctx, GLenum target, GLenum query, GLdouble *v);
	void (*get_mapfv)(GLIContext ctx, GLenum target, GLenum query, GLfloat *v);
	void (*get_mapiv)(GLIContext ctx, GLenum target, GLenum query, GLint *v);
	void (*get_materialfv)(GLIContext ctx, GLenum face, GLenum pname, GLfloat *params);
	void (*get_materialiv)(GLIContext ctx, GLenum face, GLenum pname, GLint *params);
	void (*get_pixel_mapfv)(GLIContext ctx, GLenum map, GLfloat *values);
	void (*get_pixel_mapuiv)(GLIContext ctx, GLenum map, GLuint *values);
	void (*get_pixel_mapusv)(GLIContext ctx, GLenum map, GLushort *values);
	void (*get_pointerv)(GLIContext ctx, GLenum pname, GLvoid **params);
	void (*get_polygon_stipple)(GLIContext ctx, GLubyte *mask);
	const GLubyte* (*get_string)(GLIContext ctx, GLenum name);
	void (*get_tex_envfv)(GLIContext ctx, GLenum target, GLenum pname, GLfloat *params);
	void (*get_tex_enviv)(GLIContext ctx, GLenum target, GLenum pname, GLint *params);
	void (*get_tex_gendv)(GLIContext ctx, GLenum coord, GLenum pname, GLdouble *params);
	void (*get_tex_genfv)(GLIContext ctx, GLenum coord, GLenum pname, GLfloat *params);
	void (*get_tex_geniv)(GLIContext ctx, GLenum coord, GLenum pname, GLint *params);
	void (*get_tex_image)(GLIContext ctx, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
	void (*get_tex_level_parameterfv)(GLIContext ctx, GLenum target, GLint level, GLenum pname, GLfloat *params);
	void (*get_tex_level_parameteriv)(GLIContext ctx, GLenum target, GLint level, GLenum pname, GLint *params);
	void (*get_tex_parameterfv)(GLIContext ctx, GLenum target, GLenum pname, GLfloat *params);
	void (*get_tex_parameteriv)(GLIContext ctx, GLenum target, GLenum pname, GLint *params);
	void (*hint)(GLIContext ctx, GLenum target, GLenum mode);
	void (*index_mask)(GLIContext ctx, GLuint mask);
	void (*index_pointer)(GLIContext ctx, GLenum type, GLsizei stride, const GLvoid *pointer);
	void (*indexd)(GLIContext ctx, GLdouble c);
	void (*indexdv)(GLIContext ctx, const GLdouble *c);
	void (*indexf)(GLIContext ctx, GLfloat c);
	void (*indexfv)(GLIContext ctx, const GLfloat *c);
	void (*indexi)(GLIContext ctx, GLint c);
	void (*indexiv)(GLIContext ctx, const GLint *c);
	void (*indexs)(GLIContext ctx, GLshort c);
	void (*indexsv)(GLIContext ctx, const GLshort *c);
	void (*indexub)(GLIContext ctx, GLubyte c);
	void (*indexubv)(GLIContext ctx, const GLubyte *c);
	void (*init_names)(GLIContext ctx);
	void (*interleaved_arrays)(GLIContext ctx, GLenum format, GLsizei stride, const GLvoid *pointer);
	GLboolean (*is_enabled)(GLIContext ctx, GLenum cap);
	GLboolean (*is_list)(GLIContext ctx, GLuint list);
	GLboolean (*is_texture)(GLIContext ctx, GLuint texture);
	void (*light_modelf)(GLIContext ctx, GLenum pname, GLfloat param);
	void (*light_modelfv)(GLIContext ctx, GLenum pname, const GLfloat *params);
	void (*light_modeli)(GLIContext ctx, GLenum pname, GLint param);
	void (*light_modeliv)(GLIContext ctx, GLenum pname, const GLint *params);
	void (*lightf)(GLIContext ctx, GLenum light, GLenum pname, GLfloat param);
	void (*lightfv)(GLIContext ctx, GLenum light, GLenum pname, const GLfloat *params);
	void (*lighti)(GLIContext ctx, GLenum light, GLenum pname, GLint param);
	void (*lightiv)(GLIContext ctx, GLenum light, GLenum pname, const GLint *params);
	void (*line_stipple)(GLIContext ctx, GLint factor, GLushort pattern);
	void (*line_width)(GLIContext ctx, GLfloat width);
	void (*list_base)(GLIContext ctx, GLuint base);
	void (*load_identity)(GLIContext ctx);
	void (*load_matrixd)(GLIContext ctx, const GLdouble *m);
	void (*load_matrixf)(GLIContext ctx, const GLfloat *m);
	void (*load_name)(GLIContext ctx, GLuint name);
	void (*logic_op)(GLIContext ctx, GLenum opcode);
	void (*map1d)(GLIContext ctx, GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
	void (*map1f)(GLIContext ctx, GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
	void (*map2d)(GLIContext ctx, GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
	void (*map2f)(GLIContext ctx, GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
	void (*map_grid1d)(GLIContext ctx, GLint un, GLdouble u1, GLdouble u2);
	void (*map_grid1f)(GLIContext ctx, GLint un, GLfloat u1, GLfloat u2);
	void (*map_grid2d)(GLIContext ctx, GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
	void (*map_grid2f)(GLIContext ctx, GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
	void (*materialf)(GLIContext ctx, GLenum face, GLenum pname, GLfloat param);
	void (*materialfv)(GLIContext ctx, GLenum face, GLenum pname, const GLfloat *params);
	void (*materiali)(GLIContext ctx, GLenum face, GLenum pname, GLint param);
	void (*materialiv)(GLIContext ctx, GLenum face, GLenum pname, const GLint *params);
	void (*matrix_mode)(GLIContext ctx, GLenum mode);
	void (*mult_matrixd)(GLIContext ctx, const GLdouble *m);
	void (*mult_matrixf)(GLIContext ctx, const GLfloat *m);
	void (*new_list)(GLIContext ctx, GLuint list, GLenum mode);
	void (*normal3b)(GLIContext ctx, GLbyte nx, GLbyte ny, GLbyte nz);
	void (*normal3bv)(GLIContext ctx, const GLbyte *v);
	void (*normal3d)(GLIContext ctx, GLdouble nx, GLdouble ny, GLdouble nz);
	void (*normal3dv)(GLIContext ctx, const GLdouble *v);
	void (*normal3f)(GLIContext ctx, GLfloat nx, GLfloat ny, GLfloat nz);
	void (*normal3fv)(GLIContext ctx, const GLfloat *v);
	void (*normal3i)(GLIContext ctx, GLint nx, GLint ny, GLint nz);
	void (*normal3iv)(GLIContext ctx, const GLint *v);
	void (*normal3s)(GLIContext ctx, GLshort nx, GLshort ny, GLshort nz);
	void (*normal3sv)(GLIContext ctx, const GLshort *v);
	void (*normal_pointer)(GLIContext ctx, GLenum type, GLsizei stride, const GLvoid *pointer);
	void (*ortho)(GLIContext ctx, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
	void (*pass_through)(GLIContext ctx, GLfloat token);
	void (*pixel_mapfv)(GLIContext ctx, GLenum map, GLsizei mapsize, const GLfloat *values);
	void (*pixel_mapuiv)(GLIContext ctx, GLenum map, GLsizei mapsize, const GLuint *values);
	void (*pixel_mapusv)(GLIContext ctx, GLenum map, GLsizei mapsize, const GLushort *values);
	void (*pixel_storef)(GLIContext ctx, GLenum pname, GLfloat param);
	void (*pixel_storei)(GLIContext ctx, GLenum pname, GLint param);
	void (*pixel_transferf)(GLIContext ctx, GLenum pname, GLfloat param);
	void (*pixel_transferi)(GLIContext ctx, GLenum pname, GLint param);
	void (*pixel_zoom)(GLIContext ctx, GLfloat xfactor, GLfloat yfactor);
	void (*point_size)(GLIContext ctx, GLfloat size);
	void (*polygon_mode)(GLIContext ctx, GLenum face, GLenum mode);
	void (*polygon_offset)(GLIContext ctx, GLfloat factor, GLfloat units);
	void (*polygon_stipple)(GLIContext ctx, const GLubyte *mask);
	void (*pop_attrib)(GLIContext ctx);
	void (*pop_client_attrib)(GLIContext ctx);
	void (*pop_matrix)(GLIContext ctx);
	void (*pop_name)(GLIContext ctx);
	void (*prioritize_textures)(GLIContext ctx, GLsizei n, const GLuint *textures, const GLclampf *priorities);
	void (*push_attrib)(GLIContext ctx, GLbitfield mask);
	void (*push_client_attrib)(GLIContext ctx, GLbitfield mask);
	void (*push_matrix)(GLIContext ctx);
	void (*push_name)(GLIContext ctx, GLuint name);
	void (*raster_pos2d)(GLIContext ctx, GLdouble x, GLdouble y);
	void (*raster_pos2dv)(GLIContext ctx, const GLdouble *v);
	void (*raster_pos2f)(GLIContext ctx, GLfloat x, GLfloat y);
	void (*raster_pos2fv)(GLIContext ctx, const GLfloat *v);
	void (*raster_pos2i)(GLIContext ctx, GLint x, GLint y);
	void (*raster_pos2iv)(GLIContext ctx, const GLint *v);
	void (*raster_pos2s)(GLIContext ctx, GLshort x, GLshort y);
	void (*raster_pos2sv)(GLIContext ctx, const GLshort *v);
	void (*raster_pos3d)(GLIContext ctx, GLdouble x, GLdouble y, GLdouble z);
	void (*raster_pos3dv)(GLIContext ctx, const GLdouble *v);
	void (*raster_pos3f)(GLIContext ctx, GLfloat x, GLfloat y, GLfloat z);
	void (*raster_pos3fv)(GLIContext ctx, const GLfloat *v);
	void (*raster_pos3i)(GLIContext ctx, GLint x, GLint y, GLint z);
	void (*raster_pos3iv)(GLIContext ctx, const GLint *v);
	void (*raster_pos3s)(GLIContext ctx, GLshort x, GLshort y, GLshort z);
	void (*raster_pos3sv)(GLIContext ctx, const GLshort *v);
	void (*raster_pos4d)(GLIContext ctx, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	void (*raster_pos4dv)(GLIContext ctx, const GLdouble *v);
	void (*raster_pos4f)(GLIContext ctx, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
	void (*raster_pos4fv)(GLIContext ctx, const GLfloat *v);
	void (*raster_pos4i)(GLIContext ctx, GLint x, GLint y, GLint z, GLint w);
	void (*raster_pos4iv)(GLIContext ctx, const GLint *v);
	void (*raster_pos4s)(GLIContext ctx, GLshort x, GLshort y, GLshort z, GLshort w);
	void (*raster_pos4sv)(GLIContext ctx, const GLshort *v);
	void (*read_buffer)(GLIContext ctx, GLenum mode);
	void (*read_pixels)(GLIContext ctx, GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
	void (*rectd)(GLIContext ctx, GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
	void (*rectdv)(GLIContext ctx, const GLdouble *v1, const GLdouble *v2);
	void (*rectf)(GLIContext ctx, GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
	void (*rectfv)(GLIContext ctx, const GLfloat *v1, const GLfloat *v2);
	void (*recti)(GLIContext ctx, GLint x1, GLint y1, GLint x2, GLint y2);
	void (*rectiv)(GLIContext ctx, const GLint *v1, const GLint *v2);
	void (*rects)(GLIContext ctx, GLshort x1, GLshort y1, GLshort x2, GLshort y2);
	void (*rectsv)(GLIContext ctx, const GLshort *v1, const GLshort *v2);
	GLint (*render_mode)(GLIContext ctx, GLenum mode);
	void (*rotated)(GLIContext ctx, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
	void (*rotatef)(GLIContext ctx, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
	void (*scaled)(GLIContext ctx, GLdouble x, GLdouble y, GLdouble z);
	void (*scalef)(GLIContext ctx, GLfloat x, GLfloat y, GLfloat z);
	void (*scissor)(GLIContext ctx, GLint x, GLint y, GLsizei width, GLsizei height);
	void (*select_buffer)(GLIContext ctx, GLsizei size, GLuint *buffer);
	void (*shade_model)(GLIContext ctx, GLenum mode);
	void (*stencil_func)(GLIContext ctx, GLenum func, GLint ref, GLuint mask);
	void (*stencil_mask)(GLIContext ctx, GLuint mask);
	void (*stencil_op)(GLIContext ctx, GLenum fail, GLenum zfail, GLenum zpass);
	void (*tex_coord1d)(GLIContext ctx, GLdouble s);
	void (*tex_coord1dv)(GLIContext ctx, const GLdouble *v);
	void (*tex_coord1f)(GLIContext ctx, GLfloat s);
	void (*tex_coord1fv)(GLIContext ctx, const GLfloat *v);
	void (*tex_coord1i)(GLIContext ctx, GLint s);
	void (*tex_coord1iv)(GLIContext ctx, const GLint *v);
	void (*tex_coord1s)(GLIContext ctx, GLshort s);
	void (*tex_coord1sv)(GLIContext ctx, const GLshort *v);
	void (*tex_coord2d)(GLIContext ctx, GLdouble s, GLdouble t);
	void (*tex_coord2dv)(GLIContext ctx, const GLdouble *v);
	void (*tex_coord2f)(GLIContext ctx, GLfloat s, GLfloat t);
	void (*tex_coord2fv)(GLIContext ctx, const GLfloat *v);
	void (*tex_coord2i)(GLIContext ctx, GLint s, GLint t);
	void (*tex_coord2iv)(GLIContext ctx, const GLint *v);
	void (*tex_coord2s)(GLIContext ctx, GLshort s, GLshort t);
	void (*tex_coord2sv)(GLIContext ctx, const GLshort *v);
	void (*tex_coord3d)(GLIContext ctx, GLdouble s, GLdouble t, GLdouble r);
	void (*tex_coord3dv)(GLIContext ctx, const GLdouble *v);
	void (*tex_coord3f)(GLIContext ctx, GLfloat s, GLfloat t, GLfloat r);
	void (*tex_coord3fv)(GLIContext ctx, const GLfloat *v);
	void (*tex_coord3i)(GLIContext ctx, GLint s, GLint t, GLint r);
	void (*tex_coord3iv)(GLIContext ctx, const GLint *v);
	void (*tex_coord3s)(GLIContext ctx, GLshort s, GLshort t, GLshort r);
	void (*tex_coord3sv)(GLIContext ctx, const GLshort *v);
	void (*tex_coord4d)(GLIContext ctx, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
	void (*tex_coord4dv)(GLIContext ctx, const GLdouble *v);
	void (*tex_coord4f)(GLIContext ctx, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
	void (*tex_coord4fv)(GLIContext ctx, const GLfloat *v);
	void (*tex_coord4i)(GLIContext ctx, GLint s, GLint t, GLint r, GLint q);
	void (*tex_coord4iv)(GLIContext ctx, const GLint *v);
	void (*tex_coord4s)(GLIContext ctx, GLshort s, GLshort t, GLshort r, GLshort q);
	void (*tex_coord4sv)(GLIContext ctx, const GLshort *v);
	void (*tex_coord_pointer)(GLIContext ctx, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
	void (*tex_envf)(GLIContext ctx, GLenum target, GLenum pname, GLfloat param);
	void (*tex_envfv)(GLIContext ctx, GLenum target, GLenum pname, const GLfloat *params);
	void (*tex_envi)(GLIContext ctx, GLenum target, GLenum pname, GLint param);
	void (*tex_enviv)(GLIContext ctx, GLenum target, GLenum pname, const GLint *params);
	void (*tex_gend)(GLIContext ctx, GLenum coord, GLenum pname, GLdouble param);
	void (*tex_gendv)(GLIContext ctx, GLenum coord, GLenum pname, const GLdouble *params);
	void (*tex_genf)(GLIContext ctx, GLenum coord, GLenum pname, GLfloat param);
	void (*tex_genfv)(GLIContext ctx, GLenum coord, GLenum pname, const GLfloat *params);
	void (*tex_geni)(GLIContext ctx, GLenum coord, GLenum pname, GLint param);
	void (*tex_geniv)(GLIContext ctx, GLenum coord, GLenum pname, const GLint *params);
	void (*tex_image1D)(GLIContext ctx, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
	void (*tex_image2D)(GLIContext ctx, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
	void (*tex_parameterf)(GLIContext ctx, GLenum target, GLenum pname, GLfloat param);
	void (*tex_parameterfv)(GLIContext ctx, GLenum target, GLenum pname, const GLfloat *params);
	void (*tex_parameteri)(GLIContext ctx, GLenum target, GLenum pname, GLint param);
	void (*tex_parameteriv)(GLIContext ctx, GLenum target, GLenum pname, const GLint *params);
	void (*tex_sub_image1D)(GLIContext ctx, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
	void (*tex_sub_image2D)(GLIContext ctx, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
	void (*translated)(GLIContext ctx, GLdouble x, GLdouble y, GLdouble z);
	void (*translatef)(GLIContext ctx, GLfloat x, GLfloat y, GLfloat z);
	void (*vertex2d)(GLIContext ctx, GLdouble x, GLdouble y);
	void (*vertex2dv)(GLIContext ctx, const GLdouble *v);
	void (*vertex2f)(GLIContext ctx, GLfloat x, GLfloat y);
	void (*vertex2fv)(GLIContext ctx, const GLfloat *v);
	void (*vertex2i)(GLIContext ctx, GLint x, GLint y);
	void (*vertex2iv)(GLIContext ctx, const GLint *v);
	void (*vertex2s)(GLIContext ctx, GLshort x, GLshort y);
	void (*vertex2sv)(GLIContext ctx, const GLshort *v);
	void (*vertex3d)(GLIContext ctx, GLdouble x, GLdouble y, GLdouble z);
	void (*vertex3dv)(GLIContext ctx, const GLdouble *v);
	void (*vertex3f)(GLIContext ctx, GLfloat x, GLfloat y, GLfloat z);
	void (*vertex3fv)(GLIContext ctx, const GLfloat *v);
	void (*vertex3i)(GLIContext ctx, GLint x, GLint y, GLint z);
	void (*vertex3iv)(GLIContext ctx, const GLint *v);
	void (*vertex3s)(GLIContext ctx, GLshort x, GLshort y, GLshort z);
	void (*vertex3sv)(GLIContext ctx, const GLshort *v);
	void (*vertex4d)(GLIContext ctx, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	void (*vertex4dv)(GLIContext ctx, const GLdouble *v);
	void (*vertex4f)(GLIContext ctx, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
	void (*vertex4fv)(GLIContext ctx, const GLfloat *v);
	void (*vertex4i)(GLIContext ctx, GLint x, GLint y, GLint z, GLint w);
	void (*vertex4iv)(GLIContext ctx, const GLint *v);
	void (*vertex4s)(GLIContext ctx, GLshort x, GLshort y, GLshort z, GLshort w);
	void (*vertex4sv)(GLIContext ctx, const GLshort *v);
	void (*vertex_pointer)(GLIContext ctx, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
	void (*viewport)(GLIContext ctx, GLint x, GLint y, GLsizei width, GLsizei height);
	void (*blend_func_separate)(GLIContext ctx, GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
	void (*blend_color)(GLIContext ctx, GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
	void (*blend_equation)(GLIContext ctx, GLenum mode);
	void (*lock_arrays_EXT)(GLIContext ctx, GLint first, GLsizei count);
	void (*unlock_arrays_EXT)(GLIContext ctx);
	void (*client_active_texture)(GLIContext ctx, GLenum target);
	void (*active_texture)(GLIContext ctx, GLenum target);
	void (*multi_tex_coord1d)(GLIContext ctx, GLenum target, GLdouble s);
	void (*multi_tex_coord1dv)(GLIContext ctx, GLenum target, const GLdouble *v);
	void (*multi_tex_coord1f)(GLIContext ctx, GLenum target, GLfloat s);
	void (*multi_tex_coord1fv)(GLIContext ctx, GLenum target, const GLfloat *v);
	void (*multi_tex_coord1i)(GLIContext ctx, GLenum target, GLint s);
	void (*multi_tex_coord1iv)(GLIContext ctx, GLenum target, const GLint *v);
	void (*multi_tex_coord1s)(GLIContext ctx, GLenum target, GLshort s);
	void (*multi_tex_coord1sv)(GLIContext ctx, GLenum target, const GLshort *v);
	void (*multi_tex_coord2d)(GLIContext ctx, GLenum target, GLdouble s, GLdouble t);
	void (*multi_tex_coord2dv)(GLIContext ctx, GLenum target, const GLdouble *v);
	void (*multi_tex_coord2f)(GLIContext ctx, GLenum target, GLfloat s, GLfloat t);
	void (*multi_tex_coord2fv)(GLIContext ctx, GLenum target, const GLfloat *v);
	void (*multi_tex_coord2i)(GLIContext ctx, GLenum target, GLint s, GLint t);
	void (*multi_tex_coord2iv)(GLIContext ctx, GLenum target, const GLint *v);
	void (*multi_tex_coord2s)(GLIContext ctx, GLenum target, GLshort s, GLshort t);
	void (*multi_tex_coord2sv)(GLIContext ctx, GLenum target, const GLshort *v);
	void (*multi_tex_coord3d)(GLIContext ctx, GLenum target, GLdouble s, GLdouble t, GLdouble r);
	void (*multi_tex_coord3dv)(GLIContext ctx, GLenum target, const GLdouble *v);
	void (*multi_tex_coord3f)(GLIContext ctx, GLenum target, GLfloat s, GLfloat t, GLfloat r);
	void (*multi_tex_coord3fv)(GLIContext ctx, GLenum target, const GLfloat *v);
	void (*multi_tex_coord3i)(GLIContext ctx, GLenum target, GLint s, GLint t, GLint r);
	void (*multi_tex_coord3iv)(GLIContext ctx, GLenum target, const GLint *v);
	void (*multi_tex_coord3s)(GLIContext ctx, GLenum target, GLshort s, GLshort t, GLshort r);
	void (*multi_tex_coord3sv)(GLIContext ctx, GLenum target, const GLshort *v);
	void (*multi_tex_coord4d)(GLIContext ctx, GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
	void (*multi_tex_coord4dv)(GLIContext ctx, GLenum target, const GLdouble *v);
	void (*multi_tex_coord4f)(GLIContext ctx, GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
	void (*multi_tex_coord4fv)(GLIContext ctx, GLenum target, const GLfloat *v);
	void (*multi_tex_coord4i)(GLIContext ctx, GLenum target, GLint s, GLint t, GLint r, GLint q);
	void (*multi_tex_coord4iv)(GLIContext ctx, GLenum target, const GLint *v);
	void (*multi_tex_coord4s)(GLIContext ctx, GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
	void (*multi_tex_coord4sv)(GLIContext ctx, GLenum target, const GLshort *v);
	void (*load_transpose_matrixd)(GLIContext ctx, const GLdouble *m);
	void (*load_transpose_matrixf)(GLIContext ctx, const GLfloat *m);
	void (*mult_transpose_matrixd)(GLIContext ctx, const GLdouble *m);
	void (*mult_transpose_matrixf)(GLIContext ctx, const GLfloat *m);
	void (*compressed_tex_image3D)(GLIContext ctx, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
	void (*compressed_tex_image2D)(GLIContext ctx, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
	void (*compressed_tex_image1D)(GLIContext ctx, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
	void (*compressed_tex_sub_image3D)(GLIContext ctx, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
	void (*compressed_tex_sub_image2D)(GLIContext ctx, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
	void (*compressed_tex_sub_image1D)(GLIContext ctx, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
	void (*get_compressed_tex_image)(GLIContext ctx, GLenum target, GLint level, GLvoid *img);
	void (*secondary_color3b)(GLIContext ctx, GLbyte red, GLbyte green, GLbyte blue);
	void (*secondary_color3bv)(GLIContext ctx, const GLbyte *v);
	void (*secondary_color3d)(GLIContext ctx, GLdouble red, GLdouble green, GLdouble blue);
	void (*secondary_color3dv)(GLIContext ctx, const GLdouble *v);
	void (*secondary_color3f)(GLIContext ctx, GLfloat red, GLfloat green, GLfloat blue);
	void (*secondary_color3fv)(GLIContext ctx, const GLfloat *v);
	void (*secondary_color3i)(GLIContext ctx, GLint red, GLint green, GLint blue);
	void (*secondary_color3iv)(GLIContext ctx, const GLint *v);
	void (*secondary_color3s)(GLIContext ctx, GLshort red, GLshort green, GLshort blue);
	void (*secondary_color3sv)(GLIContext ctx, const GLshort *v);
	void (*secondary_color3ub)(GLIContext ctx, GLubyte red, GLubyte green, GLubyte blue);
	void (*secondary_color3ubv)(GLIContext ctx, const GLubyte *v);
	void (*secondary_color3ui)(GLIContext ctx, GLuint red, GLuint green, GLuint blue);
	void (*secondary_color3uiv)(GLIContext ctx, const GLuint *v);
	void (*secondary_color3us)(GLIContext ctx, GLushort red, GLushort green, GLushort blue);
	void (*secondary_color3usv)(GLIContext ctx, const GLushort *v);
	void (*secondary_color_pointer)(GLIContext ctx, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
	void (*vertex_array_range_EXT)(GLIContext ctx, GLsizei count, const GLvoid *pointer);
	void (*flush_vertex_array_range_EXT)(GLIContext ctx, GLsizei count, const GLvoid *pointer);
	void (*draw_range_elements)(GLIContext ctx, GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
	void (*color_table)(GLIContext ctx, GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
	void (*color_table_parameterfv)(GLIContext ctx, GLenum target, GLenum pname, const GLfloat *params);
	void (*color_table_parameteriv)(GLIContext ctx, GLenum target, GLenum pname, const GLint *params);
	void (*copy_color_table)(GLIContext ctx, GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
	void (*get_color_table)(GLIContext ctx, GLenum target, GLenum format, GLenum type, GLvoid *table);
	void (*get_color_table_parameterfv)(GLIContext ctx, GLenum target, GLenum pname, GLfloat *params);
	void (*get_color_table_parameteriv)(GLIContext ctx, GLenum target, GLenum pname, GLint *params);
	void (*color_sub_table)(GLIContext ctx, GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
	void (*copy_color_sub_table)(GLIContext ctx, GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
	void (*convolution_filter1D)(GLIContext ctx, GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
	void (*convolution_filter2D)(GLIContext ctx, GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
	void (*convolution_parameterf)(GLIContext ctx, GLenum target, GLenum pname, GLfloat params);
	void (*convolution_parameterfv)(GLIContext ctx, GLenum target, GLenum pname, const GLfloat *params);
	void (*convolution_parameteri)(GLIContext ctx, GLenum target, GLenum pname, GLint params);
	void (*convolution_parameteriv)(GLIContext ctx, GLenum target, GLenum pname, const GLint *params);
	void (*copy_convolution_filter1D)(GLIContext ctx, GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
	void (*copy_convolution_filter2D)(GLIContext ctx, GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
	void (*get_convolution_filter)(GLIContext ctx, GLenum target, GLenum format, GLenum type, GLvoid *image);
	void (*get_convolution_parameterfv)(GLIContext ctx, GLenum target, GLenum pname, GLfloat *params);
	void (*get_convolution_parameteriv)(GLIContext ctx, GLenum target, GLenum pname, GLint *params);
	void (*get_separable_filter)(GLIContext ctx, GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
	void (*separable_filter2D)(GLIContext ctx, GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
	void (*get_histogram)(GLIContext ctx, GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
	void (*get_histogram_parameterfv)(GLIContext ctx, GLenum target, GLenum pname, GLfloat *params);
	void (*get_histogram_parameteriv)(GLIContext ctx, GLenum target, GLenum pname, GLint *params);
	void (*get_minmax)(GLIContext ctx, GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
	void (*get_minmax_parameterfv)(GLIContext ctx, GLenum target, GLenum pname, GLfloat *params);
	void (*get_minmax_parameteriv)(GLIContext ctx, GLenum target, GLenum pname, GLint *params);
	void (*histogram)(GLIContext ctx, GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
	void (*minmax)(GLIContext ctx, GLenum target, GLenum internalformat, GLboolean sink);
	void (*reset_histogram)(GLIContext ctx, GLenum target);
	void (*reset_minmax)(GLIContext ctx, GLenum target);
	void (*tex_image3D)(GLIContext ctx, GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
	void (*tex_sub_image3D)(GLIContext ctx, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
	void (*copy_tex_sub_image3D)(GLIContext ctx, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	void (*get_uniform_indices) (GLIContext ctx, GLuint program, GLsizei uniformCount, const GLchar* const *uniformNames, GLuint* uniformIndices);
	void (*get_active_uniformsiv) (GLIContext ctx, GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params);
	void (*get_active_uniform_name) (GLIContext ctx, GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName);
	GLuint (*get_uniform_block_index) (GLIContext ctx, GLuint program, const GLchar* uniformBlockName);
	void (*get_active_uniform_blockiv) (GLIContext ctx, GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params);
	void (*get_active_uniform_block_name) (GLIContext ctx, GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName);
	void (*uniform_block_binding) (GLIContext ctx, GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
	void (*get_combiner_input_parameterfv_NV)(GLIContext ctx, GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params);
	void (*get_combiner_input_parameteriv_NV)(GLIContext ctx, GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params);
	void (*get_combiner_output_parameterfv_NV)(GLIContext ctx, GLenum stage, GLenum portion, GLenum pname, GLfloat *params);
	void (*get_combiner_output_parameteriv_NV)(GLIContext ctx, GLenum stage, GLenum portion, GLenum pname, GLint *params);
	void (*get_final_combiner_input_parameterfv_NV)(GLIContext ctx, GLenum variable, GLenum pname, GLfloat *params);
	void (*get_final_combiner_input_parameteriv_NV)(GLIContext ctx, GLenum variable, GLenum pname, GLint *params);
	void (*combiner_stage_parameterfv_NV)(GLIContext ctx, GLenum stage, GLenum pname, const GLfloat *params);
	void (*get_combiner_stage_parameterfv_NV)(GLIContext ctx, GLenum stage, GLenum pname, GLfloat *params);
	void (*texture_range_APPLE)(GLIContext ctx, GLenum target, GLsizei length, const GLvoid *pointer);
	void (*get_tex_parameter_pointerv_APPLE)(GLIContext ctx, GLenum target, GLenum pname, GLvoid **params);
	void (*blend_equation_separate_EXT)(GLIContext ctx, GLenum equationRGB, GLenum equationAlpha);
	void (*sample_coverage)(GLIContext ctx, GLclampf value, GLboolean invert);
	void (*sample_pass)(GLIContext ctx, GLenum mode);
	void (*pn_trianglesi_ATI)(GLIContext ctx, GLenum pname, GLint param);
	void (*pn_trianglesf_ATI)(GLIContext ctx, GLenum pname, GLfloat param);
	void (*gen_fences_APPLE)(GLIContext ctx, GLsizei n, GLuint *fences);
	void (*delete_fences_APPLE)(GLIContext ctx, GLsizei n, const GLuint *fences);
	void (*set_fence_APPLE)(GLIContext ctx, GLuint fence);
	GLboolean (*is_fence_APPLE)(GLIContext ctx, GLuint fence);
	GLboolean (*test_fence_APPLE)(GLIContext ctx, GLuint fence);
	void (*finish_fence_APPLE)(GLIContext ctx, GLuint fence);
	GLboolean (*test_object_APPLE)(GLIContext ctx, GLenum object, GLuint name);
	void (*finish_object_APPLE)(GLIContext ctx, GLenum object, GLuint name);
	void (*bind_program_ARB)(GLIContext ctx, GLenum target, GLuint program);
	void (*delete_programs_ARB)(GLIContext ctx, GLsizei n, const GLuint *programs);
	void (*gen_programs_ARB)(GLIContext ctx, GLsizei n, GLuint *programs);
	GLboolean (*is_program_ARB)(GLIContext ctx, GLuint program);
	void (*vertex_attrib1s_ARB)(GLIContext ctx, GLuint index, GLshort x);
	void (*vertex_attrib1f_ARB)(GLIContext ctx, GLuint index, GLfloat x);
	void (*vertex_attrib1d_ARB)(GLIContext ctx, GLuint index, GLdouble x);
	void (*vertex_attrib2s_ARB)(GLIContext ctx, GLuint index, GLshort x, GLshort y);
	void (*vertex_attrib2f_ARB)(GLIContext ctx, GLuint index, GLfloat x, GLfloat y);
	void (*vertex_attrib2d_ARB)(GLIContext ctx, GLuint index, GLdouble x, GLdouble y);
	void (*vertex_attrib3s_ARB)(GLIContext ctx, GLuint index, GLshort x, GLshort y, GLshort z);
	void (*vertex_attrib3f_ARB)(GLIContext ctx, GLuint index, GLfloat x, GLfloat y, GLfloat z);
	void (*vertex_attrib3d_ARB)(GLIContext ctx, GLuint index, GLdouble x, GLdouble y, GLdouble z);
	void (*vertex_attrib4s_ARB)(GLIContext ctx, GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
	void (*vertex_attrib4f_ARB)(GLIContext ctx, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
	void (*vertex_attrib4d_ARB)(GLIContext ctx, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	void (*vertex_attrib4Nub_ARB)(GLIContext ctx, GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
	void (*vertex_attrib1sv_ARB)(GLIContext ctx, GLuint index, const GLshort *v);
	void (*vertex_attrib1fv_ARB)(GLIContext ctx, GLuint index, const GLfloat *v);
	void (*vertex_attrib1dv_ARB)(GLIContext ctx, GLuint index, const GLdouble *v);
	void (*vertex_attrib2sv_ARB)(GLIContext ctx, GLuint index, const GLshort *v);
	void (*vertex_attrib2fv_ARB)(GLIContext ctx, GLuint index, const GLfloat *v);
	void (*vertex_attrib2dv_ARB)(GLIContext ctx, GLuint index, const GLdouble *v);
	void (*vertex_attrib3sv_ARB)(GLIContext ctx, GLuint index, const GLshort *v);
	void (*vertex_attrib3fv_ARB)(GLIContext ctx, GLuint index, const GLfloat *v);
	void (*vertex_attrib3dv_ARB)(GLIContext ctx, GLuint index, const GLdouble *v);
	void (*vertex_attrib4bv_ARB)(GLIContext ctx, GLuint index, const GLbyte *v);
	void (*vertex_attrib4sv_ARB)(GLIContext ctx, GLuint index, const GLshort *v);
	void (*vertex_attrib4iv_ARB)(GLIContext ctx, GLuint index, const GLint *v);
	void (*vertex_attrib4ubv_ARB)(GLIContext ctx, GLuint index, const GLubyte *v);
	void (*vertex_attrib4usv_ARB)(GLIContext ctx, GLuint index, const GLushort *v);
	void (*vertex_attrib4uiv_ARB)(GLIContext ctx, GLuint index, const GLuint *v);
	void (*vertex_attrib4fv_ARB)(GLIContext ctx, GLuint index, const GLfloat *v);
	void (*vertex_attrib4dv_ARB)(GLIContext ctx, GLuint index, const GLdouble *v);
	void (*vertex_attrib4Nbv_ARB)(GLIContext ctx, GLuint index, const GLbyte *v);
	void (*vertex_attrib4Nsv_ARB)(GLIContext ctx, GLuint index, const GLshort *v);
	void (*vertex_attrib4Niv_ARB)(GLIContext ctx, GLuint index, const GLint *v);
	void (*vertex_attrib4Nubv_ARB)(GLIContext ctx, GLuint index, const GLubyte *v);
	void (*vertex_attrib4Nusv_ARB)(GLIContext ctx, GLuint index, const GLushort *v);
	void (*vertex_attrib4Nuiv_ARB)(GLIContext ctx, GLuint index, const GLuint *v);
	void (*vertex_attrib_pointer_ARB)(GLIContext ctx, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
	void (*enable_vertex_attrib_array_ARB)(GLIContext ctx, GLuint index);
	void (*disable_vertex_attrib_array_ARB)(GLIContext ctx, GLuint index);
	void (*get_vertex_attribdv_ARB)(GLIContext ctx, GLuint index, GLenum pname, GLdouble *params);
	void (*get_vertex_attribfv_ARB)(GLIContext ctx, GLuint index, GLenum pname, GLfloat *params);
	void (*get_vertex_attribiv_ARB)(GLIContext ctx, GLuint index, GLenum pname, GLint *params);
	void (*get_vertex_attrib_pointerv_ARB)(GLIContext ctx, GLuint index, GLenum pname, GLvoid **pointer);
	void (*program_env_parameter4d_ARB)(GLIContext ctx, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	void (*program_env_parameter4dv_ARB)(GLIContext ctx, GLenum target, GLuint index, const GLdouble *params);
	void (*program_env_parameter4f_ARB)(GLIContext ctx, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
	void (*program_env_parameter4fv_ARB)(GLIContext ctx, GLenum target, GLuint index, const GLfloat *params);
	void (*program_local_parameter4d_ARB)(GLIContext ctx, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	void (*program_local_parameter4dv_ARB)(GLIContext ctx, GLenum target, GLuint index, const GLdouble *params);
	void (*program_local_parameter4f_ARB)(GLIContext ctx, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
	void (*program_local_parameter4fv_ARB)(GLIContext ctx, GLenum target, GLuint index, const GLfloat *params);
	void (*get_program_env_parameterdv_ARB)(GLIContext ctx, GLenum target, GLuint index, GLdouble *params);
	void (*get_program_env_parameterfv_ARB)(GLIContext ctx, GLenum target, GLuint index, GLfloat *params);
	void (*get_program_local_parameterdv_ARB)(GLIContext ctx, GLenum target, GLuint index, GLdouble *params);
	void (*get_program_local_parameterfv_ARB)(GLIContext ctx, GLenum target, GLuint index, GLfloat *params);
	void (*program_string_ARB)(GLIContext ctx, GLenum target, GLenum format, GLsizei len, const GLvoid* string);
	void (*get_program_string_ARB)(GLIContext ctx, GLenum target, GLenum pname, GLvoid *string);
	void (*get_programiv_ARB)(GLIContext ctx, GLenum target, GLenum pname, GLint *params);
	void (*enable_vertex_attrib_ARB)(GLIContext ctx, GLuint index, GLenum pname);
	void (*disable_vertex_attrib_ARB)(GLIContext ctx, GLuint index, GLenum pname);
	GLboolean (*is_vertex_attrib_enabled_ARB)(GLIContext ctx, GLuint index, GLenum pname);
	void (*map_vertex_attrib1d_ARB)(GLIContext ctx, GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
	void (*map_vertex_attrib1f_ARB)(GLIContext ctx, GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
	void (*map_vertex_attrib2d_ARB)(GLIContext ctx, GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
	void (*map_vertex_attrib2f_ARB)(GLIContext ctx, GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
	void (*point_parameterf)(GLIContext ctx, GLenum pname, GLfloat param);
	void (*point_parameterfv)(GLIContext ctx, GLenum pname, const GLfloat *params);
	void (*point_parameteri)(GLIContext ctx, GLenum pname, GLint param);
	void (*point_parameteriv)(GLIContext ctx, GLenum pname, const GLint *params);
	void (*fog_coordf)(GLIContext ctx, GLfloat coord);
	void (*fog_coordfv)(GLIContext ctx, const GLfloat *coord);
	void (*fog_coordd)(GLIContext ctx, GLdouble coord);
	void (*fog_coorddv)(GLIContext ctx, const GLdouble *coord);
	void (*fog_coord_pointer)(GLIContext ctx, GLenum type, GLsizei stride, const GLvoid *pointer);
	void (*vertex_array_parameteri_EXT)(GLIContext ctx, GLenum pname, GLint param);
	void (*bind_vertex_array_EXT)(GLIContext ctx, GLuint id);
	void (*delete_vertex_arrays_EXT)(GLIContext ctx, GLsizei n, const GLuint *ids);
	void (*gen_vertex_arrays_EXT)(GLIContext ctx, GLsizei n, GLuint *ids);
	GLboolean (*is_vertex_array_EXT)(GLIContext ctx, GLuint id);
	void (*element_pointer_APPLE)(GLIContext ctx, GLenum type, const GLvoid *pointer);
	void (*draw_element_array_APPLE)(GLIContext ctx, GLenum mode, GLint first, GLsizei count);
	void (*draw_range_element_array_APPLE)(GLIContext ctx, GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
	void (*weightbv_ARB)(GLIContext ctx, GLint size, const GLbyte *weights);
	void (*weightsv_ARB)(GLIContext ctx, GLint size, const GLshort *weights);
	void (*weightiv_ARB)(GLIContext ctx, GLint size, const GLint *weights);
	void (*weightfv_ARB)(GLIContext ctx, GLint size, const GLfloat *weights);
	void (*weightdv_ARB)(GLIContext ctx, GLint size, const GLdouble *weights);
	void (*weightubv_ARB)(GLIContext ctx, GLint size, const GLubyte *weights);
	void (*weightusv_ARB)(GLIContext ctx, GLint size, const GLushort *weights);
	void (*weightuiv_ARB)(GLIContext ctx, GLint size, const GLuint *weights);
	void (*weight_pointer_ARB)(GLIContext ctx, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
	void (*vertex_blend_ARB)(GLIContext ctx, GLint count);
	void (*multi_draw_arrays)(GLIContext ctx, GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
	void (*multi_draw_elements)(GLIContext ctx, GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei drawcount);
	void (*window_pos2d) (GLIContext ctx, GLdouble x, GLdouble y);
	void (*window_pos2dv) (GLIContext ctx, const GLdouble *v);
	void (*window_pos2f) (GLIContext ctx, GLfloat x, GLfloat y);
	void (*window_pos2fv) (GLIContext ctx, const GLfloat *v);
	void (*window_pos2i) (GLIContext ctx, GLint x, GLint y);
	void (*window_pos2iv) (GLIContext ctx, const GLint *v);
	void (*window_pos2s) (GLIContext ctx, GLshort x, GLshort y);
	void (*window_pos2sv) (GLIContext ctx, const GLshort *v);
	void (*window_pos3d) (GLIContext ctx, GLdouble x, GLdouble y, GLdouble z);
	void (*window_pos3dv) (GLIContext ctx, const GLdouble *v);
	void (*window_pos3f) (GLIContext ctx, GLfloat x, GLfloat y, GLfloat z);
	void (*window_pos3fv) (GLIContext ctx, const GLfloat *v);
	void (*window_pos3i) (GLIContext ctx, GLint x, GLint y, GLint z);
	void (*window_pos3iv) (GLIContext ctx, const GLint *v);
	void (*window_pos3s) (GLIContext ctx, GLshort x, GLshort y, GLshort z);
	void (*window_pos3sv) (GLIContext ctx, const GLshort *v);
	void (*active_stencil_face_EXT) (GLIContext ctx, GLenum face);
	void (*stencil_op_separate_ATI) (GLIContext ctx, GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
	void (*stencil_func_separate_ATI) (GLIContext ctx, GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
	void (*flush_render_APPLE) (GLIContext ctx);
	void (*finish_render_APPLE) (GLIContext ctx);
	void (*swap_APPLE)(GLIContext ctx);
	void (*delete_object_ARB) (GLIContext ctx, GLhandleARB obj);
	GLhandleARB (*get_handle_ARB) (GLIContext ctx, GLenum pname);
	void (*detach_object_ARB) (GLIContext ctx, GLhandleARB containerObj, GLhandleARB attachedObj);
	GLhandleARB (*create_shader_object_ARB) (GLIContext ctx, GLenum shaderType);
	void (*shader_source_ARB) (GLIContext ctx, GLhandleARB shaderObj, GLsizei count, const GLcharARB* const *string, const GLint *length);
	void (*compile_shader_ARB) (GLIContext ctx, GLhandleARB shaderObj);
	GLhandleARB (*create_program_object_ARB) (GLIContext ctx);
	void (*attach_object_ARB) (GLIContext ctx, GLhandleARB containerObj, GLhandleARB obj);
	void (*link_program_ARB) (GLIContext ctx, GLhandleARB programObj);
	void (*use_program_object_ARB) (GLIContext ctx, GLhandleARB programObj);
	void (*validate_program_ARB) (GLIContext ctx, GLhandleARB programObj);
	void (*uniform1f_ARB) (GLIContext ctx, GLint location, GLfloat v0);
	void (*uniform2f_ARB) (GLIContext ctx, GLint location, GLfloat v0, GLfloat v1);
	void (*uniform3f_ARB) (GLIContext ctx, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
	void (*uniform4f_ARB) (GLIContext ctx, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
	void (*uniform1i_ARB) (GLIContext ctx, GLint location, GLint v0);
	void (*uniform2i_ARB) (GLIContext ctx, GLint location, GLint v0, GLint v1);
	void (*uniform3i_ARB) (GLIContext ctx, GLint location, GLint v0, GLint v1, GLint v2);
	void (*uniform4i_ARB) (GLIContext ctx, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
	void (*uniform1fv_ARB) (GLIContext ctx, GLint location, GLsizei count, const GLfloat *value);
	void (*uniform2fv_ARB) (GLIContext ctx, GLint location, GLsizei count, const GLfloat *value);
	void (*uniform3fv_ARB) (GLIContext ctx, GLint location, GLsizei count, const GLfloat *value);
	void (*uniform4fv_ARB) (GLIContext ctx, GLint location, GLsizei count, const GLfloat *value);
	void (*uniform1iv_ARB) (GLIContext ctx, GLint location, GLsizei count, const GLint *value);
	void (*uniform2iv_ARB) (GLIContext ctx, GLint location, GLsizei count, const GLint *value);
	void (*uniform3iv_ARB) (GLIContext ctx, GLint location, GLsizei count, const GLint *value);
	void (*uniform4iv_ARB) (GLIContext ctx, GLint location, GLsizei count, const GLint *value);
	void (*uniform_matrix2fv_ARB) (GLIContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	void (*uniform_matrix3fv_ARB) (GLIContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	void (*uniform_matrix4fv_ARB) (GLIContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	void (*get_object_parameterfv_ARB) (GLIContext ctx, GLhandleARB obj, GLenum pname, GLfloat *params);
	void (*get_object_parameteriv_ARB) (GLIContext ctx, GLhandleARB obj, GLenum pname, GLint *params);
	void (*get_info_log_ARB) (GLIContext ctx, GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog);
	void (*get_attached_objects_ARB) (GLIContext ctx, GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj);
	GLint (*get_uniform_location_ARB) (GLIContext ctx, GLhandleARB programObj, const GLcharARB *name);
	void (*get_active_uniform_ARB) (GLIContext ctx, GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
	void (*get_uniformfv_ARB) (GLIContext ctx, GLhandleARB programObj, GLint location, GLfloat *params);
	void (*get_uniformiv_ARB) (GLIContext ctx, GLhandleARB programObj, GLint location, GLint *params);
	void (*get_shader_source_ARB) (GLIContext ctx, GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source);
	void (*bind_attrib_location_ARB) (GLIContext ctx, GLhandleARB programObj, GLuint index, const GLcharARB *name);
	void (*get_active_attrib_ARB) (GLIContext ctx, GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name);
	GLint (*get_attrib_location_ARB) (GLIContext ctx, GLhandleARB programObj, const GLcharARB *name);
	void (*clamp_color_ARB) (GLIContext ctx, GLenum target, GLenum clamp);
	void (*gen_queries) (GLIContext ctx, GLsizei n, GLuint *ids);
	void (*delete_queries) (GLIContext ctx, GLsizei n, const GLuint *ids);
	GLboolean (*is_query) (GLIContext ctx, GLuint id);
	void (*begin_query) (GLIContext ctx, GLenum target, GLuint id);
	void (*end_query) (GLIContext ctx, GLenum target);
	void (*get_queryiv) (GLIContext ctx, GLenum target, GLenum pname, GLint *params);
	void (*get_query_objectiv) (GLIContext ctx, GLuint id, GLenum pname, GLint *params);
	void (*get_query_objectuiv) (GLIContext ctx, GLuint id, GLenum pname, GLuint *params);
	void (*bind_buffer) (GLIContext ctx, GLenum target, GLuint buffer);
	void (*delete_buffers) (GLIContext ctx, GLsizei n, const GLuint *buffers);
	void (*gen_buffers) (GLIContext ctx, GLsizei n, GLuint *buffers);
	GLboolean (*is_buffer) (GLIContext ctx, GLuint buffer);
	void (*buffer_data) (GLIContext ctx, GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
	void (*buffer_sub_data) (GLIContext ctx, GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
	void (*get_buffer_sub_data) (GLIContext ctx, GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
	GLvoid *(*map_buffer) (GLIContext ctx, GLenum target, GLenum access);
	GLboolean (*unmap_buffer) (GLIContext ctx, GLenum target);
	void (*get_buffer_parameteriv) (GLIContext ctx, GLenum target, GLenum pname, GLint *params);
	void (*get_buffer_pointerv) (GLIContext ctx, GLenum target, GLenum pname, GLvoid **params);
	void (*depth_bounds_EXT) (GLIContext ctx, GLclampd zmin, GLclampd zmax);
	void (*draw_buffers_ARB) (GLIContext ctx, GLsizei n, const GLenum *bufs);
	
	GLboolean (*is_shader) (GLIContext ctx, GLuint shader);
	GLboolean (*is_program) (GLIContext ctx, GLuint program);
	void (*get_shaderiv) (GLIContext ctx, GLuint shader, GLenum pname, GLint *params);
	void (*get_programiv) (GLIContext ctx, GLuint program, GLenum pname, GLint *params);
	void (*get_shader_info_log) (GLIContext ctx, GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
	void (*get_program_info_log) (GLIContext ctx, GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog);

	void (*stencil_func_separate) (GLIContext ctx, GLenum face, GLenum func, GLint ref, GLuint mask);
	void (*stencil_mask_separate) (GLIContext ctx, GLenum face, GLuint mask);
	
	void (*multi_draw_element_array_APPLE)(GLIContext ctx, GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
	void (*multi_draw_range_element_array_APPLE)(GLIContext ctx, GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount);

	/* EXT_framebuffer_object */
	GLboolean (*is_renderbuffer_EXT) (GLIContext ctx, GLuint renderbuffer);
	void (*bind_renderbuffer_EXT) (GLIContext ctx, GLenum target, GLuint renderbuffer);
	void (*delete_renderbuffers_EXT) (GLIContext ctx, GLsizei n, const GLuint *renderbuffers);
	void (*gen_renderbuffers_EXT) (GLIContext ctx, GLsizei n, GLuint *renderbuffers);
	void (*renderbuffer_storage_EXT) (GLIContext ctx, GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
	void (*get_renderbuffer_parameteriv_EXT) (GLIContext ctx, GLenum target, GLenum pname, GLint *params);
	GLboolean (*is_framebuffer_EXT) (GLIContext ctx, GLuint framebuffer);
	void (*bind_framebuffer_EXT) (GLIContext ctx, GLenum target, GLuint framebuffer);
	void (*delete_framebuffers_EXT) (GLIContext ctx, GLsizei n, const GLuint *framebuffers);
	void (*gen_framebuffers_EXT) (GLIContext ctx, GLsizei n, GLuint *framebuffers);
	GLenum (*check_framebuffer_status_EXT) (GLIContext ctx, GLenum target);
	void (*framebuffer_texture1D_EXT) (GLIContext ctx, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
	void (*framebuffer_texture2D_EXT) (GLIContext ctx, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
	void (*framebuffer_texture3D_EXT) (GLIContext ctx, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
	void (*framebuffer_renderbuffer_EXT) (GLIContext ctx, GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
	void (*get_framebuffer_attachment_parameteriv_EXT) (GLIContext ctx, GLenum target, GLenum attachment, GLenum pname, GLint *params);
	void (*generate_mipmap_EXT) (GLIContext ctx, GLenum target);

	void (*buffer_parameteri_APPLE) (GLIContext ctx, GLenum target, GLenum pname, GLint param);
	void (*flush_mapped_buffer_range_APPLE) (GLIContext ctx, GLenum target, GLintptr offset, GLsizeiptr size);

	void (*program_env_parameters4fv_EXT)(GLIContext ctx, GLenum target, GLuint index, GLsizei count, const GLfloat *params);
	void (*program_local_parameters4fv_EXT)(GLIContext ctx, GLenum target, GLuint index, GLsizei count, const GLfloat *params);

	GLenum (*object_purgeable_APPLE)(GLIContext ctx, GLenum objectType, GLuint name, GLenum option);
	GLenum (*object_unpurgeable_APPLE)(GLIContext ctx, GLenum objectType, GLuint name, GLenum option);
	void   (*get_object_parameteriv_APPLE) (GLIContext ctx, GLenum objectType, GLuint name, GLenum pname, GLint* params);

	/* EXT_geometry_shader4 */
	void (*program_parameteri_EXT)(GLIContext ctx, GLuint program_name, GLenum pname, GLint value);
	void (*framebuffer_texture_EXT)(GLIContext ctx, GLenum target, GLenum attachment, GLuint texture, GLint level);
	void (*framebuffer_texture_layer_EXT)(GLIContext ctx, GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
	void (*framebuffer_texture_face_EXT)(GLIContext ctx, GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
	
	/* EXT_transform_feedback */
	void (*bind_buffer_range_EXT)(GLIContext ctx, GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
	void (*bind_buffer_offset_EXT)(GLIContext ctx, GLenum target, GLuint index, GLuint buffer, GLintptr offset);
	void (*bind_buffer_base_EXT)(GLIContext ctx, GLenum target, GLuint index, GLuint buffer);
	void (*begin_transform_feedback_EXT)(GLIContext ctx, GLenum primitiveMode);
	void (*end_transform_feedback_EXT)(GLIContext ctx);
	void (*transform_feedback_varyings_EXT)(GLIContext ctx, GLuint program, GLsizei count, const GLchar* const *varyings, GLenum bufferMode);
	void (*get_transform_feedback_varying_EXT)(GLIContext ctx, GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
	void (*get_integer_indexedv_EXT)(GLIContext ctx, GLenum param, GLuint index, GLint *values); 
	void (*get_boolean_indexedv_EXT)(GLIContext ctx, GLenum param, GLuint index, GLboolean *values);

	/* EXT_bindable_uniform */
	void (*uniform_buffer_EXT)(GLIContext ctx, GLuint program, GLint location, GLuint buffer);
	GLint (*get_uniform_buffer_size_EXT)(GLIContext ctx, GLuint program, GLint location);
	GLintptr (*get_uniform_buffer_offset_EXT)(GLIContext ctx, GLuint program, GLint location);

	/* EXT_texture_integer */
	void (*clear_colorIi_EXT) (GLIContext ctx, GLint r, GLint g, GLint b, GLint a );
	void (*clear_colorIui_EXT) (GLIContext ctx, GLuint r, GLuint g, GLuint b, GLuint a );
	void (*tex_parameterIiv_EXT)(GLIContext ctx, GLenum target, GLenum pname, GLint *params );
	void (*tex_parameterIuiv_EXT)(GLIContext ctx, GLenum target, GLenum pname, GLuint *params );
	void (*get_tex_parameterIiv_EXT) (GLIContext ctx, GLenum target, GLenum pname, GLint *params);
	void (*get_tex_parameterIuiv_EXT) (GLIContext ctx, GLenum target, GLenum pname, GLuint *params);

	/* EXT_gpu_shader4 */
	void (*vertex_attribI1i_EXT)(GLIContext ctx, GLuint index, GLint x);
	void (*vertex_attribI2i_EXT)(GLIContext ctx, GLuint index, GLint x, GLint y);
	void (*vertex_attribI3i_EXT)(GLIContext ctx, GLuint index, GLint x, GLint y, GLint z);
	void (*vertex_attribI4i_EXT)(GLIContext ctx, GLuint index, GLint x, GLint y, GLint z, GLint w);
	void (*vertex_attribI1ui_EXT)(GLIContext ctx, GLuint index, GLuint x);
	void (*vertex_attribI2ui_EXT)(GLIContext ctx, GLuint index, GLuint x, GLuint y);
	void (*vertex_attribI3ui_EXT)(GLIContext ctx, GLuint index, GLuint x, GLuint y, GLuint z);
	void (*vertex_attribI4ui_EXT)(GLIContext ctx, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
	void (*vertex_attribI1iv_EXT)(GLIContext ctx, GLuint index, const GLint *v);
	void (*vertex_attribI2iv_EXT)(GLIContext ctx, GLuint index, const GLint *v);
	void (*vertex_attribI3iv_EXT)(GLIContext ctx, GLuint index, const GLint *v);
	void (*vertex_attribI4iv_EXT)(GLIContext ctx, GLuint index, const GLint *v);
	void (*vertex_attribI1uiv_EXT)(GLIContext ctx, GLuint index, const GLuint *v);
	void (*vertex_attribI2uiv_EXT)(GLIContext ctx, GLuint index, const GLuint *v);
	void (*vertex_attribI3uiv_EXT)(GLIContext ctx, GLuint index, const GLuint *v);
	void (*vertex_attribI4uiv_EXT)(GLIContext ctx, GLuint index, const GLuint *v);
	void (*vertex_attribI4bv_EXT)(GLIContext ctx, GLuint index, const GLbyte *v);
	void (*vertex_attribI4sv_EXT)(GLIContext ctx, GLuint index, const GLshort *v);
	void (*vertex_attribI4ubv_EXT)(GLIContext ctx, GLuint index, const GLubyte *v);
	void (*vertex_attribI4usv_EXT)(GLIContext ctx, GLuint index, const GLushort *v);
	void (*vertex_attribI_pointer_EXT)(GLIContext ctx, GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
	void (*get_vertex_attribIiv_EXT)(GLIContext ctx, GLuint index, GLenum pname, GLint *params);
	void (*get_vertex_attribIuiv_EXT)(GLIContext ctx, GLuint index, GLenum pname, GLuint *params);
	void (*uniform1ui_EXT)(GLIContext ctx, GLint location, GLuint v0);
	void (*uniform2ui_EXT)(GLIContext ctx, GLint location, GLuint v0, GLuint v1);
	void (*uniform3ui_EXT)(GLIContext ctx, GLint location, GLuint v0, GLuint v1, GLuint v2);
	void (*uniform4ui_EXT)(GLIContext ctx, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
	void (*uniform1uiv_EXT)(GLIContext ctx, GLint location, GLsizei count, const GLuint *value);
	void (*uniform2uiv_EXT)(GLIContext ctx, GLint location, GLsizei count, const GLuint *value);
	void (*uniform3uiv_EXT)(GLIContext ctx, GLint location, GLsizei count, const GLuint *value);
	void (*uniform4uiv_EXT)(GLIContext ctx, GLint location, GLsizei count, const GLuint *value);
	void (*get_uniformuiv_EXT)(GLIContext ctx, GLuint program, GLint location, GLuint *params);
	void (*bind_frag_data_location_EXT)(GLIContext ctx, GLuint program, GLuint colorNumber, const GLchar *name);
	GLint (*get_frag_data_location_EXT)(GLIContext ctx, GLuint program, const GLchar *name);

	/* EXT_draw_buffers2 */
	void (*color_mask_indexed_EXT) (GLIContext ctx, GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
	void (*enable_indexed_EXT) (GLIContext ctx, GLenum target, GLuint index);
	void (*disable_indexed_EXT) (GLIContext ctx, GLenum target, GLuint index);
	GLboolean (*is_enabled_indexed_EXT) (GLIContext ctx, GLenum target, GLuint index);

	/* OpenGL 2.1 */
	void (*uniform_matrix2x3fv) (GLIContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	void (*uniform_matrix3x2fv) (GLIContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	void (*uniform_matrix2x4fv) (GLIContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	void (*uniform_matrix4x2fv) (GLIContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	void (*uniform_matrix3x4fv) (GLIContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	void (*uniform_matrix4x3fv) (GLIContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);

	/* EXT_framebuffer_blit and EXT_framebuffer_multisample */
	void (*blit_framebuffer_EXT) (GLIContext ctx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
	void (*renderbuffer_storage_multisample_EXT) (GLIContext ctx, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);

	/* NV_conditional_render */
	void (*begin_conditional_render_NV)(GLIContext ctx, GLuint id, GLenum mode);
	void (*end_conditional_render_NV)(GLIContext ctx);

	void (*get_attached_shaders) (GLIContext ctx, GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
	
	/* EXT_provoking_vertex */
	void (*provoking_vertex_EXT) (GLIContext ctx, GLenum mode);
	
	/* ARB_instanced_arrays */
	void (*vertex_attrib_divisor) (GLIContext ctx, GLuint index, GLuint divisor);
	/* ARB_instanced_arrays and ARB_draw_instanced */
	void (*draw_arrays_instanced)(GLIContext ctx, GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
	void (*draw_elements_instanced)(GLIContext ctx, GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei instancecount);

	/* ARB_draw_elements_base_vertex */
	void (*draw_elements_base_vertex)(GLIContext ctx, GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex);
	void (*draw_range_elements_base_vertex)(GLIContext ctx, GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint base_vertex);
	void (*draw_elements_instanced_base_vertex)(GLIContext ctx, GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei instancecount, GLint base_vertex);
	void (*multi_draw_elements_base_vertex)(GLIContext ctx, GLenum mode, const GLsizei *count, GLenum type, const GLvoid* const *indices, GLsizei drawcount, const GLint *base_vertex);

	/* ARB_vertex_array_object / OES_vertex_array_object */
	void (*bind_vertex_array_ARB)(GLIContext ctx, GLuint array);
	void (*delete_vertex_arrays_ARB)(GLIContext ctx, GLsizei n, const GLuint *arrays);
	void (*gen_vertex_arrays_ARB)(GLIContext ctx, GLsizei n, GLuint *arrays);
	GLboolean (*is_vertex_array_ARB)(GLIContext ctx, GLuint array);

	/* APPLE_vertex_point_size */
	void (*point_size_pointer) (GLIContext ctx, GLenum type, GLsizei stride, const GLvoid *pointer);
	void (*vertex_point_sizef_APPLE) (GLIContext ctx, GLfloat size);

	/* OpenGL 3.0 */
	void (*clear_bufferiv)(GLIContext ctx, GLenum buffer, GLint drawbuffer, const GLint *value);
	void (*clear_bufferuiv)(GLIContext ctx, GLenum buffer, GLint drawbuffer, const GLuint *value);
	void (*clear_bufferfv)(GLIContext ctx, GLenum buffer, GLint drawbuffer, const GLfloat *value);
	void (*clear_bufferfi)(GLIContext ctx, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
	const GLubyte* (*get_stringi)(GLIContext ctx, GLenum name, GLuint index);
	
	/* ARB_sync */
	GLsync (*fence_sync) (GLIContext ctx, GLenum condition, GLbitfield flags);
	GLboolean (*is_sync) (GLIContext ctx, GLsync sync);
	void (*delete_sync) (GLIContext ctx, GLsync sync);
	GLenum (*client_wait_sync) (GLIContext ctx, GLsync sync, GLbitfield flags, GLuint64 timeout);
	void (*wait_sync) (GLIContext ctx, GLsync sync, GLbitfield flags, GLuint64 timeout);
	void (*get_integer64v_sync) (GLIContext ctx, GLenum pname, GLint64 *params);
	void (*get_synciv) (GLIContext ctx, GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);

	/* ARB_texture_multisample */
	void (*tex_image2D_multisample)(GLIContext ctx, GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
	void (*tex_image3D_multisample)(GLIContext ctx, GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
	void (*get_multisamplefv)(GLIContext ctx, GLenum pname, GLuint index, GLfloat *val);
	void (*sample_maski)(GLIContext ctx, GLuint index, GLbitfield mask);

	/* ARB_texture_buffer_object */
	void (*tex_buffer)(GLIContext ctx, GLenum target, GLenum internalformat, GLuint buffer);

	/* ARB_copy_buffer */
	void (*copy_buffer_sub_data)(GLIContext ctx, GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);

	/* NV_primitive_restart */
	void (*primitive_restart_index)(GLIContext ctx, GLuint index);

	/* EXT_timer_query */
	void (*get_query_objecti64v) (GLIContext ctx, GLuint id, GLenum pname, GLint64EXT *params);
	void (*get_query_objectui64v) (GLIContext ctx, GLuint id, GLenum pname, GLuint64EXT *params);

	/* ARB_map_buffer_range */
	GLvoid *(*map_buffer_range) (GLIContext ctx, GLenum target, GLintptr offset, GLsizeiptr length, GLenum access);
	void (*flush_mapped_buffer_range) (GLIContext ctx, GLenum target, GLintptr offset, GLsizeiptr length);

	/* ARB_timer_query */
	void (*query_counter) (GLIContext ctx, GLuint id, GLenum target);
	void (*get_integer64i_v) (GLIContext ctx, GLenum target, GLuint index, GLint64 *data);
	void (*get_buffer_parameteri64v)(GLIContext ctx, GLenum target, GLenum pname, GLint64 *params);

	/* ARB_sampler_object */
	void (*gen_samplers) (GLIContext ctx, GLsizei count, GLuint *samplers);
	void (*delete_samplers) (GLIContext ctx, GLsizei count, const GLuint *samplers);
	GLboolean (*is_sampler) (GLIContext ctx, GLuint sampler);
	void (*bind_sampler) (GLIContext ctx, GLuint unit, GLuint sampler);
	void (*sampler_parameteri) (GLIContext ctx, GLuint sampler, GLenum pname, GLint param);
	void (*sampler_parameteriv) (GLIContext ctx, GLuint sampler, GLenum pname, const GLint *param);
	void (*sampler_parameterf) (GLIContext ctx, GLuint sampler, GLenum pname, GLfloat param);
	void (*sampler_parameterfv) (GLIContext ctx, GLuint sampler, GLenum pname, const GLfloat *param);
	void (*sampler_parameterIiv) (GLIContext ctx, GLuint sampler, GLenum pname, const GLint *param);
	void (*sampler_parameterIuiv) (GLIContext ctx, GLuint sampler, GLenum pname, const GLuint *param);
	void (*get_sampler_parameteriv) (GLIContext ctx, GLuint sampler, GLenum pname, GLint *params);
	void (*get_sampler_parameterfv) (GLIContext ctx, GLuint sampler, GLenum pname, GLfloat *params);
	void (*get_sampler_parameterIiv) (GLIContext ctx, GLuint sampler, GLenum pname, GLint *params);
	void (*get_sampler_parameterIuiv) (GLIContext ctx, GLuint sampler, GLenum pname, GLuint *params);

	/* EXT_debug_label */
	void (*label_object_EXT)(GLIContext ctx, GLenum type, GLuint object, GLsizei length, const GLchar *label);
	void (*get_object_label_EXT)(GLIContext ctx, GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label);

	/* EXT_debug_marker */
	void (*insert_event_marker_EXT)(GLIContext ctx, GLsizei length, const GLchar *marker);
	void (*push_group_marker_EXT)(GLIContext ctx, GLsizei length, const GLchar *marker);
	void (*pop_group_marker_EXT)(GLIContext ctx);

	/* ARB_separate_shader_objects */
	void (*use_program_stages)(GLIContext ctx, GLuint pipeline, GLbitfield stages, GLuint program);
	void (*active_shader_program)(GLIContext ctx, GLuint pipeline, GLuint program);
	GLuint (*create_shader_programv)(GLIContext ctx, GLenum type, GLsizei count, const GLchar* const *strings);
	void (*bind_program_pipeline)(GLIContext ctx, GLuint pipeline);
	void (*delete_program_pipelines)(GLIContext ctx, GLsizei n, const GLuint *pipelines);
	void (*gen_program_pipelines)(GLIContext ctx, GLsizei n, GLuint *pipelines);
	GLboolean (*is_program_pipeline)(GLIContext ctx, GLuint pipeline);
	void (*get_program_pipelineiv)(GLIContext ctx, GLuint pipeline, GLenum pname, GLint *params);
	void (*validate_program_pipeline)(GLIContext ctx, GLuint pipeline);
	void (*get_program_pipeline_info_log)(GLIContext ctx, GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
	void (*program_uniform1i)(GLIContext ctx, GLuint program, GLint location, GLint x);
	void (*program_uniform2i)(GLIContext ctx, GLuint program, GLint location, GLint x, GLint y);
	void (*program_uniform3i)(GLIContext ctx, GLuint program, GLint location, GLint x, GLint y, GLint z);
	void (*program_uniform4i)(GLIContext ctx, GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w);
	void (*program_uniform1f)(GLIContext ctx, GLuint program, GLint location, GLfloat x);
	void (*program_uniform2f)(GLIContext ctx, GLuint program, GLint location, GLfloat x, GLfloat y);
	void (*program_uniform3f)(GLIContext ctx, GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z);
	void (*program_uniform4f)(GLIContext ctx, GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
	void (*program_uniform1iv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, const GLint *value);
	void (*program_uniform2iv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, const GLint *value);
	void (*program_uniform3iv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, const GLint *value);
	void (*program_uniform4iv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, const GLint *value);
	void (*program_uniform1fv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, const GLfloat *value);
	void (*program_uniform2fv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, const GLfloat *value);
	void (*program_uniform3fv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, const GLfloat *value);
	void (*program_uniform4fv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, const GLfloat *value);
	void (*program_uniform_matrix2fv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	void (*program_uniform_matrix3fv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	void (*program_uniform_matrix4fv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	void (*program_uniform1ui)(GLIContext ctx, GLuint program, GLint location, GLuint x);
	void (*program_uniform2ui)(GLIContext ctx, GLuint program, GLint location, GLuint x, GLuint y);
	void (*program_uniform3ui)(GLIContext ctx, GLuint program, GLint location, GLuint x, GLuint y, GLuint z);
	void (*program_uniform4ui)(GLIContext ctx, GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w);
	void (*program_uniform1uiv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, const GLuint *value);
	void (*program_uniform2uiv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, const GLuint *value);
	void (*program_uniform3uiv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, const GLuint *value);
	void (*program_uniform4uiv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, const GLuint *value);
	void (*program_uniform_matrix2x3fv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	void (*program_uniform_matrix3x2fv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	void (*program_uniform_matrix2x4fv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	void (*program_uniform_matrix4x2fv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	void (*program_uniform_matrix3x4fv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
	void (*program_uniform_matrix4x3fv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);

	/* ARB_blend_func_extended */
	void (*bind_frag_data_location_indexed) (GLIContext ctx, GLuint program, GLuint colorNumber, GLuint index, const GLchar *name);
	GLint (*get_frag_data_index) (GLIContext ctx, GLuint program, const GLchar *name);

	/* ARB_draw_buffers_blend */
	void (*blend_func_i) (GLIContext ctx, GLuint buf, GLenum src, GLenum dst);
	void (*blend_func_separate_i) (GLIContext ctx, GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
	void (*blend_equation_i) (GLIContext ctx, GLuint buf, GLenum mode);
	void (*blend_equation_separate_i) (GLIContext ctx, GLuint buf, GLenum modeRGB, GLenum modeAlpha);

	/* ARB_shading_language_include */
	void (*named_string_ARB) (GLIContext ctx, GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string);
	void (*delete_named_string_ARB) (GLIContext ctx, GLint namelen, const GLchar *name);
	void (*compile_shader_include_ARB) (GLIContext ctx, GLuint shader, GLsizei count, const GLchar* const *path, const GLint *length);
	GLboolean (*is_named_string_ARB) (GLIContext ctx, GLint namelen, const GLchar *name);
	void (*get_named_string_ARB) (GLIContext ctx, GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string);
	void (*get_named_string_iv_ARB) (GLIContext ctx, GLint namelen, const GLchar *name, GLenum pname, GLint *params);

	/* ARB_ES2_compatibility */
	void (*release_shader_compiler)(GLIContext ctx);
	void (*shader_binary)(GLIContext ctx, GLint n, GLuint *shaders, GLenum binaryformat, const GLvoid *binary, GLint length);
	void (*get_shader_precision_format)(GLIContext ctx, GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision);
	void (*depth_rangef) (GLIContext ctx, GLclampf zNear, GLclampf zFar);
	void (*clear_depthf) (GLIContext ctx, GLclampf depth);

	/* ARB_vertex_type_2_10_10_10_rev */
	void (*vertex_attribP1ui) (GLIContext ctx, GLuint index, GLenum type, GLboolean normalized, GLuint value);
	void (*vertex_attribP2ui) (GLIContext ctx, GLuint index, GLenum type, GLboolean normalized, GLuint value);
	void (*vertex_attribP3ui) (GLIContext ctx, GLuint index, GLenum type, GLboolean normalized, GLuint value);
	void (*vertex_attribP4ui) (GLIContext ctx, GLuint index, GLenum type, GLboolean normalized, GLuint value);
	void (*vertex_attribP1uiv) (GLIContext ctx, GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
	void (*vertex_attribP2uiv) (GLIContext ctx, GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
	void (*vertex_attribP3uiv) (GLIContext ctx, GLuint index, GLenum type, GLboolean normalized, const GLuint *value);
	void (*vertex_attribP4uiv) (GLIContext ctx, GLuint index, GLenum type, GLboolean normalized, const GLuint *value);

	/* ARB_get_program_binary */
	void (*get_program_binary) (GLIContext ctx, GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary);
	void (*program_binary) (GLIContext ctx, GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length);
	
	/* ARB_sample_shading */
	void (*min_sample_shading) (GLIContext ctx, GLclampf value);

	/* ARB_viewport_array */
	void (*viewport_arrayv) (GLIContext ctx, GLuint first, GLsizei count, const GLfloat * v);
	void (*viewport_indexedf) (GLIContext ctx, GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
	void (*viewport_indexedfv) (GLIContext ctx, GLuint index, const GLfloat * v);
	void (*scissor_arrayv) (GLIContext ctx, GLuint first, GLsizei count, const GLint * v);
	void (*scissor_indexed) (GLIContext ctx, GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
	void (*scissor_indexedv) (GLIContext ctx, GLuint index, const GLint * v);
	void (*depth_range_arrayv) (GLIContext ctx, GLuint first, GLsizei count, const GLclampd * v);
	void (*depth_range_indexed) (GLIContext ctx, GLuint index, GLclampd n, GLclampd f);
	void (*get_floati_v) (GLIContext ctx, GLenum target, GLuint index, GLfloat *data);
	void (*get_doublei_v) (GLIContext ctx, GLenum target, GLuint index, GLdouble *data);

	/* ARB_draw_indirect */
	void (*draw_arrays_indirect) (GLIContext ctx, GLenum mode, const GLvoid *indirect);
	void (*draw_elements_indirect) (GLIContext ctx, GLenum mode, GLenum type, const GLvoid *indirect);

	/* ARB_tessellation_shader */
	void (*patch_parameteri) (GLIContext ctx, GLenum pname, GLint value);
	void (*patch_parameterfv) (GLIContext ctx, GLenum pname, const GLfloat* values);

	/* ARB_transform_feedback2 */
	void (*bind_transform_feedback) (GLIContext ctx, GLenum target, GLuint name);
	void (*gen_transform_feedbacks) (GLIContext ctx, GLsizei n, GLuint* ids);
	void (*delete_transform_feedbacks) (GLIContext ctx, GLsizei n, const GLuint* ids);
	void (*pause_transform_feedback) (GLIContext ctx);
	void (*resume_transform_feedback) (GLIContext ctx);
	GLboolean (*is_transform_feedback) (GLIContext ctx, GLuint name);
	void (*draw_transform_feedback) (GLIContext ctx, GLenum mode, GLuint name);

	/* ARB_transform_feedback3 */
	void (*begin_query_indexed) (GLIContext ctx, GLenum target, GLuint index, GLuint id);
	void (*end_query_indexed) (GLIContext ctx, GLenum target, GLuint index);
	void (*get_query_indexediv) (GLIContext ctx, GLenum target, GLuint index, GLenum pname, GLint *params);
	void (*draw_transform_feedback_stream) (GLIContext ctx, GLenum mode, GLuint name, GLuint stream);

	/* ARB_separate_shader_objects && ARB_gpu_shader_fp64 */
	void (*program_uniform1d)(GLIContext ctx, GLuint program, GLint location, GLdouble x);
	void (*program_uniform2d)(GLIContext ctx, GLuint program, GLint location, GLdouble x, GLdouble y);
	void (*program_uniform3d)(GLIContext ctx, GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
	void (*program_uniform4d)(GLIContext ctx, GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	void (*program_uniform1dv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, const GLdouble *value);
	void (*program_uniform2dv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, const GLdouble *value);
	void (*program_uniform3dv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, const GLdouble *value);
	void (*program_uniform4dv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, const GLdouble *value);
	void (*program_uniform_matrix2dv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	void (*program_uniform_matrix3dv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	void (*program_uniform_matrix4dv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	void (*program_uniform_matrix2x3dv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	void (*program_uniform_matrix3x2dv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	void (*program_uniform_matrix2x4dv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	void (*program_uniform_matrix4x2dv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	void (*program_uniform_matrix3x4dv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	void (*program_uniform_matrix4x3dv)(GLIContext ctx, GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);

	/* ARB_gpu_shader_fp64 */
	void (*uniform1d)(GLIContext ctx, GLint location, GLdouble x);
	void (*uniform2d)(GLIContext ctx, GLint location, GLdouble x, GLdouble y);
	void (*uniform3d)(GLIContext ctx, GLint location, GLdouble x, GLdouble y, GLdouble z);
	void (*uniform4d)(GLIContext ctx, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	void (*uniform1dv)(GLIContext ctx, GLint location, GLsizei count, const GLdouble *value);
	void (*uniform2dv)(GLIContext ctx, GLint location, GLsizei count, const GLdouble *value);
	void (*uniform3dv)(GLIContext ctx, GLint location, GLsizei count, const GLdouble *value);
	void (*uniform4dv)(GLIContext ctx, GLint location, GLsizei count, const GLdouble *value);
	void (*uniform_matrix2dv)(GLIContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	void (*uniform_matrix3dv)(GLIContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	void (*uniform_matrix4dv)(GLIContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	void (*uniform_matrix2x3dv)(GLIContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	void (*uniform_matrix3x2dv)(GLIContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	void (*uniform_matrix2x4dv)(GLIContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	void (*uniform_matrix4x2dv)(GLIContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	void (*uniform_matrix3x4dv)(GLIContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	void (*uniform_matrix4x3dv)(GLIContext ctx, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
	void (*get_uniformdv)(GLIContext ctx, GLuint program_obj, GLint location, GLdouble *params);
	
	/* ARB_vertex_attrib_64bit */
	void (*vertex_attribl1d)(GLIContext ctx, GLuint index, GLdouble x);
	void (*vertex_attribl2d)(GLIContext ctx, GLuint index, GLdouble x, GLdouble y);
	void (*vertex_attribl3d)(GLIContext ctx, GLuint index, GLdouble x, GLdouble y, GLdouble z);
	void (*vertex_attribl4d)(GLIContext ctx, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
	void (*vertex_attribl1dv)(GLIContext ctx, GLuint index, const GLdouble *v);
	void (*vertex_attribl2dv)(GLIContext ctx, GLuint index, const GLdouble *v);
	void (*vertex_attribl3dv)(GLIContext ctx, GLuint index, const GLdouble *v);
	void (*vertex_attribl4dv)(GLIContext ctx, GLuint index, const GLdouble *v);
	void (*vertex_attrib_lpointer)(GLIContext ctx, GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
	void (*get_vertex_attrib_ldv)(GLIContext ctx, GLuint index, GLenum pname, GLdouble *params);

	/* ARB_shader_subroutine */
	GLint (*get_subroutine_uniform_location)(GLIContext ctx, GLuint program, GLenum shadertype, const GLchar *name);
	GLuint (*get_subroutine_index)(GLIContext ctx, GLuint program, GLenum shadertype, const GLchar *name);
	void (*get_active_subroutine_uniformiv)(GLIContext ctx, GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values);
	void (*get_active_subroutine_uniform_name)(GLIContext ctx, GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
	void (*get_active_subroutine_name)(GLIContext ctx, GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
	void (*uniform_subroutinesuiv)(GLIContext ctx, GLenum shadertype, GLsizei count, const GLuint *indices);
	void (*get_uniform_subroutineuiv)(GLIContext ctx, GLenum shadertype, GLint location, GLuint *params);
	void (*get_program_stageiv)(GLIContext ctx, GLuint program, GLenum shadertype, GLenum pname, GLint *values);


	/* ARB_internalformat_query */
	void (*get_internal_formativ) (GLIContext ctx, GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params);

	/* ARB_texture_storage */
	void (*tex_storage1D) (GLIContext ctx, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
	void (*tex_storage2D) (GLIContext ctx, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
	void (*tex_storage3D) (GLIContext ctx, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
	
	/* GL_APPLE_label_process */
	void (*label_object_with_responsible_process_APPLE) (GLIContext ctx, GLenum type, GLuint name, GLint pid);

	/* GL_NV_texture_barrier */
	void (*texture_barrier_NV) (GLIContext ctx);

} GLIFunctionDispatch;


#ifdef __cplusplus
}
#endif

#endif /* _GLIDISPATCH_H */
                                                                                   gltypes.h                                                                                           0100644 0001750 0001750 00000002602 12567471557 032623  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers                                                                      /*
	Copyright:	(c) 2010-2012 Apple Inc. All rights reserved.
*/
#ifndef __gltypes_h_
#define __gltypes_h_

#include <stdint.h>

typedef uint32_t GLbitfield;
typedef uint8_t  GLboolean;
typedef int8_t   GLbyte;
typedef float    GLclampf;
typedef uint32_t GLenum;
typedef float    GLfloat;
typedef int32_t  GLint;
typedef int16_t  GLshort;
typedef int32_t  GLsizei;
typedef uint8_t  GLubyte;
typedef uint32_t GLuint;
typedef uint16_t GLushort;
typedef void     GLvoid;

#if !defined(GL_VERSION_2_0)
typedef char     GLchar;
#endif
#if !defined(GL_ARB_shader_objects)
typedef char     GLcharARB;
typedef void    *GLhandleARB;
#endif
typedef double   GLdouble;
typedef double   GLclampd;
#if !defined(ARB_ES2_compatibility) && !defined(GL_VERSION_4_1)
typedef int32_t  GLfixed;
#endif
#if !defined(GL_ARB_half_float_vertex) && !defined(GL_VERSION_3_0)
typedef uint16_t GLhalf;
#endif
#if !defined(GL_ARB_half_float_pixel)
typedef uint16_t GLhalfARB;
#endif
#if !defined(GL_ARB_sync) && !defined(GL_VERSION_3_2)
typedef int64_t  GLint64;
typedef struct __GLsync *GLsync;
typedef uint64_t GLuint64;
#endif
#if !defined(GL_EXT_timer_query)
typedef int64_t  GLint64EXT;
typedef uint64_t GLuint64EXT;
#endif
#if !defined(GL_VERSION_1_5)
typedef intptr_t GLintptr;
typedef intptr_t GLsizeiptr;
#endif
#if !defined(GL_ARB_vertex_buffer_object)
typedef intptr_t GLintptrARB;
typedef intptr_t GLsizeiptrARB;
#endif

#endif
                                                                                                                              glu.h                                                                                               0100644 0001750 0001750 00000044471 12567471556 031734  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenGL.framework/Versions/A/Headers                                                                      /*
	Copyright:	(c) 1999-2012 Apple Inc. All rights reserved.
*/

#ifndef __glu_h__
#define __glu_h__

#include <OpenGL/OpenGLAvailability.h>
#include <OpenGL/gl.h>

#ifdef __cplusplus
extern "C" {
#endif


/*************************************************************/

/* Extensions */
#define GLU_EXT_object_space_tess            1
#define GLU_EXT_nurbs_tessellator            1

/* Boolean */
#define GLU_FALSE                            0
#define GLU_TRUE                             1

/* Version */
#define GLU_VERSION_1_1                      1
#define GLU_VERSION_1_2                      1
#define GLU_VERSION_1_3                      1

/* StringName */
#define GLU_VERSION                          100800
#define GLU_EXTENSIONS                       100801

/* ErrorCode */
#define GLU_INVALID_ENUM                     100900
#define GLU_INVALID_VALUE                    100901
#define GLU_OUT_OF_MEMORY                    100902
#define GLU_INCOMPATIBLE_GL_VERSION          100903
#define GLU_INVALID_OPERATION                100904


/* NurbsDisplay */
/*      GLU_FILL */
#define GLU_OUTLINE_POLYGON                  100240
#define GLU_OUTLINE_PATCH                    100241

/* NurbsCallback */
#define GLU_NURBS_ERROR                      100103
#define GLU_ERROR                            100103
#define GLU_NURBS_BEGIN                      100164
#define GLU_NURBS_BEGIN_EXT                  100164
#define GLU_NURBS_VERTEX                     100165
#define GLU_NURBS_VERTEX_EXT                 100165
#define GLU_NURBS_NORMAL                     100166
#define GLU_NURBS_NORMAL_EXT                 100166
#define GLU_NURBS_COLOR                      100167
#define GLU_NURBS_COLOR_EXT                  100167
#define GLU_NURBS_TEXTURE_COORD              100168
#define GLU_NURBS_TEX_COORD_EXT              100168
#define GLU_NURBS_END                        100169
#define GLU_NURBS_END_EXT                    100169
#define GLU_NURBS_BEGIN_DATA                 100170
#define GLU_NURBS_BEGIN_DATA_EXT             100170
#define GLU_NURBS_VERTEX_DATA                100171
#define GLU_NURBS_VERTEX_DATA_EXT            100171
#define GLU_NURBS_NORMAL_DATA                100172
#define GLU_NURBS_NORMAL_DATA_EXT            100172
#define GLU_NURBS_COLOR_DATA                 100173
#define GLU_NURBS_COLOR_DATA_EXT             100173
#define GLU_NURBS_TEXTURE_COORD_DATA         100174
#define GLU_NURBS_TEX_COORD_DATA_EXT         100174
#define GLU_NURBS_END_DATA                   100175
#define GLU_NURBS_END_DATA_EXT               100175

/* NurbsError */
#define GLU_NURBS_ERROR1                     100251   /* spline order un-supported */
#define GLU_NURBS_ERROR2                     100252   /* too few knots */
#define GLU_NURBS_ERROR3                     100253   /* valid knot range is empty */
#define GLU_NURBS_ERROR4                     100254   /* decreasing knot sequence */
#define GLU_NURBS_ERROR5                     100255   /* knot multiplicity > spline order */
#define GLU_NURBS_ERROR6                     100256   /* endcurve() must follow bgncurve() */
#define GLU_NURBS_ERROR7                     100257   /* bgncurve() must precede endcurve() */
#define GLU_NURBS_ERROR8                     100258   /* ctrlarray or knot vector is NULL */
#define GLU_NURBS_ERROR9                     100259   /* can't draw pwlcurves */
#define GLU_NURBS_ERROR10                    100260   /* missing gluNurbsCurve() */
#define GLU_NURBS_ERROR11                    100261   /* missing gluNurbsSurface() */
#define GLU_NURBS_ERROR12                    100262   /* endtrim() must precede endsurface() */
#define GLU_NURBS_ERROR13                    100263   /* bgnsurface() must precede endsurface() */
#define GLU_NURBS_ERROR14                    100264   /* curve of improper type passed as trim curve */
#define GLU_NURBS_ERROR15                    100265   /* bgnsurface() must precede bgntrim() */
#define GLU_NURBS_ERROR16                    100266   /* endtrim() must follow bgntrim() */
#define GLU_NURBS_ERROR17                    100267   /* bgntrim() must precede endtrim()*/
#define GLU_NURBS_ERROR18                    100268   /* invalid or missing trim curve*/
#define GLU_NURBS_ERROR19                    100269   /* bgntrim() must precede pwlcurve() */
#define GLU_NURBS_ERROR20                    100270   /* pwlcurve referenced twice*/
#define GLU_NURBS_ERROR21                    100271   /* pwlcurve and nurbscurve mixed */
#define GLU_NURBS_ERROR22                    100272   /* improper usage of trim data type */
#define GLU_NURBS_ERROR23                    100273   /* nurbscurve referenced twice */
#define GLU_NURBS_ERROR24                    100274   /* nurbscurve and pwlcurve mixed */
#define GLU_NURBS_ERROR25                    100275   /* nurbssurface referenced twice */
#define GLU_NURBS_ERROR26                    100276   /* invalid property */
#define GLU_NURBS_ERROR27                    100277   /* endsurface() must follow bgnsurface() */
#define GLU_NURBS_ERROR28                    100278   /* intersecting or misoriented trim curves */
#define GLU_NURBS_ERROR29                    100279   /* intersecting trim curves */
#define GLU_NURBS_ERROR30                    100280   /* UNUSED */
#define GLU_NURBS_ERROR31                    100281   /* unconnected trim curves */
#define GLU_NURBS_ERROR32                    100282   /* unknown knot error */
#define GLU_NURBS_ERROR33                    100283   /* negative vertex count encountered */
#define GLU_NURBS_ERROR34                    100284   /* negative byte-stride */
#define GLU_NURBS_ERROR35                    100285   /* unknown type descriptor */
#define GLU_NURBS_ERROR36                    100286   /* null control point reference */
#define GLU_NURBS_ERROR37                    100287   /* duplicate point on pwlcurve */

/* NurbsProperty */
#define GLU_AUTO_LOAD_MATRIX                 100200
#define GLU_CULLING                          100201
#define GLU_SAMPLING_TOLERANCE               100203
#define GLU_DISPLAY_MODE                     100204
#define GLU_PARAMETRIC_TOLERANCE             100202
#define GLU_SAMPLING_METHOD                  100205
#define GLU_U_STEP                           100206
#define GLU_V_STEP                           100207
#define GLU_NURBS_MODE                       100160
#define GLU_NURBS_MODE_EXT                   100160
#define GLU_NURBS_TESSELLATOR                100161
#define GLU_NURBS_TESSELLATOR_EXT            100161
#define GLU_NURBS_RENDERER                   100162
#define GLU_NURBS_RENDERER_EXT               100162

/* NurbsSampling */
#define GLU_OBJECT_PARAMETRIC_ERROR          100208
#define GLU_OBJECT_PARAMETRIC_ERROR_EXT      100208
#define GLU_OBJECT_PATH_LENGTH               100209
#define GLU_OBJECT_PATH_LENGTH_EXT           100209
#define GLU_PATH_LENGTH                      100215
#define GLU_PARAMETRIC_ERROR                 100216
#define GLU_DOMAIN_DISTANCE                  100217

/* NurbsTrim */
#define GLU_MAP1_TRIM_2                      100210
#define GLU_MAP1_TRIM_3                      100211

/* QuadricDrawStyle */ 
#define GLU_POINT                            100010
#define GLU_LINE                             100011
#define GLU_FILL                             100012
#define GLU_SILHOUETTE                       100013
  
/* QuadricCallback */
/*      GLU_ERROR */

/* QuadricNormal */
#define GLU_SMOOTH                           100000
#define GLU_FLAT                             100001
#define GLU_NONE                             100002
 
/* QuadricOrientation */
#define GLU_OUTSIDE                          100020
#define GLU_INSIDE                           100021

/* TessCallback */
#define GLU_TESS_BEGIN                       100100
#define GLU_BEGIN                            100100
#define GLU_TESS_VERTEX                      100101
#define GLU_VERTEX                           100101
#define GLU_TESS_END                         100102
#define GLU_END                              100102
#define GLU_TESS_ERROR                       100103
#define GLU_TESS_EDGE_FLAG                   100104
#define GLU_EDGE_FLAG                        100104
#define GLU_TESS_COMBINE                     100105
#define GLU_TESS_BEGIN_DATA                  100106
#define GLU_TESS_VERTEX_DATA                 100107
#define GLU_TESS_END_DATA                    100108
#define GLU_TESS_ERROR_DATA                  100109
#define GLU_TESS_EDGE_FLAG_DATA              100110
#define GLU_TESS_COMBINE_DATA                100111

/* TessContour */
#define GLU_CW                               100120
#define GLU_CCW                              100121
#define GLU_INTERIOR                         100122
#define GLU_EXTERIOR                         100123
#define GLU_UNKNOWN                          100124

/* TessProperty */
#define GLU_TESS_WINDING_RULE                100140
#define GLU_TESS_BOUNDARY_ONLY               100141
#define GLU_TESS_TOLERANCE                   100142

/* TessError */
#define GLU_TESS_ERROR1                      100151
#define GLU_TESS_ERROR2                      100152
#define GLU_TESS_ERROR3                      100153
#define GLU_TESS_ERROR4                      100154
#define GLU_TESS_ERROR5                      100155
#define GLU_TESS_ERROR6                      100156
#define GLU_TESS_ERROR7                      100157
#define GLU_TESS_ERROR8                      100158
#define GLU_TESS_MISSING_BEGIN_POLYGON       100151
#define GLU_TESS_MISSING_BEGIN_CONTOUR       100152
#define GLU_TESS_MISSING_END_POLYGON         100153
#define GLU_TESS_MISSING_END_CONTOUR         100154
#define GLU_TESS_COORD_TOO_LARGE             100155
#define GLU_TESS_NEED_COMBINE_CALLBACK       100156

/* TessWinding */
#define GLU_TESS_WINDING_ODD                 100130
#define GLU_TESS_WINDING_NONZERO             100131
#define GLU_TESS_WINDING_POSITIVE            100132
#define GLU_TESS_WINDING_NEGATIVE            100133
#define GLU_TESS_WINDING_ABS_GEQ_TWO         100134

/*************************************************************/


#ifdef __cplusplus
class GLUnurbs;
class GLUquadric;
class GLUtesselator;

typedef class GLUnurbs GLUnurbsObj OPENGL_DEPRECATED(10_0, 10_9);
typedef class GLUquadric GLUquadricObj OPENGL_DEPRECATED(10_0, 10_9);
typedef class GLUtesselator GLUtesselatorObj OPENGL_DEPRECATED(10_0, 10_9);
typedef class GLUtesselator GLUtriangulatorObj OPENGL_DEPRECATED(10_0, 10_9);
#else
typedef struct GLUnurbs GLUnurbs OPENGL_DEPRECATED(10_0, 10_9);
typedef struct GLUquadric GLUquadric OPENGL_DEPRECATED(10_0, 10_9);
typedef struct GLUtesselator GLUtesselator OPENGL_DEPRECATED(10_0, 10_9);

typedef struct GLUnurbs GLUnurbsObj OPENGL_DEPRECATED(10_0, 10_9);
typedef struct GLUquadric GLUquadricObj OPENGL_DEPRECATED(10_0, 10_9);
typedef struct GLUtesselator GLUtesselatorObj OPENGL_DEPRECATED(10_0, 10_9);
typedef struct GLUtesselator GLUtriangulatorObj OPENGL_DEPRECATED(10_0, 10_9);
#endif

#define GLU_TESS_MAX_COORD 1.0e150

extern void gluBeginCurve (GLUnurbs* nurb) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluBeginPolygon (GLUtesselator* tess) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluBeginSurface (GLUnurbs* nurb) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluBeginTrim (GLUnurbs* nurb) OPENGL_DEPRECATED(10_0, 10_9);
extern GLint gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data) OPENGL_DEPRECATED_MSG(10_2, 10_9, "Use glGenerateMipmap");
extern GLint gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data) OPENGL_DEPRECATED_MSG(10_0, 10_9, "Use glGenerateMipmap");
extern GLint gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data) OPENGL_DEPRECATED_MSG(10_2, 10_9, "Use glGenerateMipmap");
extern GLint gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data) OPENGL_DEPRECATED_MSG(10_0, 10_9, "Use glGenerateMipmap");
extern GLint gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data) OPENGL_DEPRECATED_MSG(10_2, 10_9, "Use glGenerateMipmap");
extern GLint gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data) OPENGL_DEPRECATED_MSG(10_2, 10_9, "Use glGenerateMipmap");
extern GLboolean gluCheckExtension (const GLubyte *extName, const GLubyte *extString) OPENGL_DEPRECATED(10_2, 10_9);
extern void gluCylinder (GLUquadric* quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluDeleteNurbsRenderer (GLUnurbs* nurb) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluDeleteQuadric (GLUquadric* quad) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluDeleteTess (GLUtesselator* tess) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluEndCurve (GLUnurbs* nurb) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluEndPolygon (GLUtesselator* tess) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluEndSurface (GLUnurbs* nurb) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluEndTrim (GLUnurbs* nurb) OPENGL_DEPRECATED(10_0, 10_9);
extern const GLubyte * gluErrorString (GLenum error) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluGetNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat* data) OPENGL_DEPRECATED(10_0, 10_9);
extern const GLubyte * gluGetString (GLenum name) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluGetTessProperty (GLUtesselator* tess, GLenum which, GLdouble* data) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluLoadSamplingMatrices (GLUnurbs* nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluLookAt (GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ) OPENGL_DEPRECATED_MSG(10_0, 10_9, "Use GLKMatrix4MakeLookAt");
extern GLUnurbs* gluNewNurbsRenderer (void) OPENGL_DEPRECATED(10_0, 10_9);
extern GLUquadric* gluNewQuadric (void) OPENGL_DEPRECATED(10_0, 10_9);
extern GLUtesselator* gluNewTess (void) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluNextContour (GLUtesselator* tess, GLenum type) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluNurbsCallback (GLUnurbs* nurb, GLenum which, GLvoid (*CallBackFunc)()) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluNurbsCallbackData (GLUnurbs* nurb, GLvoid* userData) OPENGL_DEPRECATED(10_2, 10_9);
extern void gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluNurbsCurve (GLUnurbs* nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat value) OPENGL_DEPRECATED(10_0, 10_9);
extern void gluNurbsSurface (GLUnurbs* nurb, GLint sKnotCount, GLfloat* sKnots, GL