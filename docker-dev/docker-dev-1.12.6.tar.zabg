                // dbdb
	//TODO: FCMOVU F2, F0                   // dada
	//TODO: FCMOVU F3, F0                   // dadb
	FCOMD F2, F0                            // d8d2
	FCOMD F3, F0                            // d8d3
	FCOMD (BX), F0                          // d813 or dc13
	FCOMD (R11), F0                         // 41d813 or 41dc13
	//TODO: FCOMI F2, F0                    // dbf2
	//TODO: FCOMI F3, F0                    // dbf3
	//TODO: FCOMIP F2, F0                   // dff2
	//TODO: FCOMIP F3, F0                   // dff3
	//TODO: FCOMP F2                        // d8da
	//TODO: FCOMP F3                        // d8db
	//TODO: FCOMFP (BX)                     // d81b
	//TODO: FCOMFP (R11)                    // 41d81b
	//TODO: FCOMPL (BX)                     // dc1b
	//TODO: FCOMPL (R11)                    // 41dc1b
	//TODO: FCOMPP                          // ded9
	FCOS                                    // d9ff
	FDECSTP                                 // d9f6
	FDIVD F2, F0                            // d8f2
	FDIVD F3, F0                            // d8f3
	FDIVD F0, F2                            // dcfa or dcf2
	FDIVD F0, F3                            // dcfb or dcf3
	FDIVD (BX), F0                          // d833 or dc33
	FDIVD (R11), F0                         // 41d833 or 41dc33
	//TODO: FDIVRP F0, F2                   // defa
	//TODO: FDIVRP F0, F3                   // defb
	//TODO: FDIVR F2, F0                    // d8fa
	//TODO: FDIVR F3, F0                    // d8fb
	//TODO: FDIVFR (BX)                     // d83b
	//TODO: FDIVFR (R11)                    // 41d83b
	//TODO: FDIVRL (BX)                     // dc3b
	//TODO: FDIVRL (R11)                    // 41dc3b
	//TODO: FDIVP F0, F2                    // def2
	//TODO: FDIVP F0, F3                    // def3
	//TODO: FFREE F2                        // ddc2
	//TODO: FFREE F3                        // ddc3
	//TODO: FFREEP F2                       // dfc2
	//TODO: FFREEP F3                       // dfc3
	//TODO: FIADD (BX)                      // de03
	//TODO: FIADD (R11)                     // 41de03
	//TODO: FIADDL (BX)                     // da03
	//TODO: FIADDL (R11)                    // 41da03
	//TODO: FICOM (BX)                      // de13
	//TODO: FICOM (R11)                     // 41de13
	//TODO: FICOML (BX)                     // da13
	//TODO: FICOML (R11)                    // 41da13
	//TODO: FICOMP (BX)                     // de1b
	//TODO: FICOMP (R11)                    // 41de1b
	//TODO: FICOMPL (BX)                    // da1b
	//TODO: FICOMPL (R11)                   // 41da1b
	//TODO: FIDIV (BX)                      // de33
	//TODO: FIDIV (R11)                     // 41de33
	//TODO: FIDIVL (BX)                     // da33
	//TODO: FIDIVL (R11)                    // 41da33
	//TODO: FIDIVR (BX)                     // de3b
	//TODO: FIDIVR (R11)                    // 41de3b
	//TODO: FIDIVRL (BX)                    // da3b
	//TODO: FIDIVRL (R11)                   // 41da3b
	//TODO: FILD (BX)                       // df03
	//TODO: FILD (R11)                      // 41df03
	//TODO: FILDL (BX)                      // db03
	//TODO: FILDL (R11)                     // 41db03
	//TODO: FILDLL (BX)                     // df2b
	//TODO: FILDLL (R11)                    // 41df2b
	//TODO: FIMUL (BX)                      // de0b
	//TODO: FIMUL (R11)                     // 41de0b
	//TODO: FIMULL (BX)                     // da0b
	//TODO: FIMULL (R11)                    // 41da0b
	FINCSTP                                 // d9f7
	//TODO: FIST (BX)                       // df13
	//TODO: FIST (R11)                      // 41df13
	//TODO: FISTL (BX)                      // db13
	//TODO: FISTL (R11)                     // 41db13
	//TODO: FISTP (BX)                      // df1b
	//TODO: FISTP (R11)                     // 41df1b
	//TODO: FISTPL (BX)                     // db1b
	//TODO: FISTPL (R11)                    // 41db1b
	//TODO: FISTPLL (BX)                    // df3b
	//TODO: FISTPLL (R11)                   // 41df3b
	//TODO: FISTTP (BX)                     // df0b
	//TODO: FISTTP (R11)                    // 41df0b
	//TODO: FISTTPL (BX)                    // db0b
	//TODO: FISTTPL (R11)                   // 41db0b
	//TODO: FISTTPLL (BX)                   // dd0b
	//TODO: FISTTPLL (R11)                  // 41dd0b
	//TODO: FISUB (BX)                      // de23
	//TODO: FISUB (R11)                     // 41de23
	//TODO: FISUBL (BX)                     // da23
	//TODO: FISUBL (R11)                    // 41da23
	//TODO: FISUBR (BX)                     // de2b
	//TODO: FISUBR (R11)                    // 41de2b
	//TODO: FISUBRL (BX)                    // da2b
	//TODO: FISUBRL (R11)                   // 41da2b
	//TODO: FLD F2                          // d9c2
	//TODO: FLD F3                          // d9c3
	//TODO: FLDS (BX)                       // d903
	//TODO: FLDS (R11)                      // 41d903
	//TODO: FLDL (BX)                       // dd03
	//TODO: FLDL (R11)                      // 41dd03
	//TODO: FLDT (BX)                       // db2b
	//TODO: FLDT (R11)                      // 41db2b
	FLD1                                    // d9e8
	FLDCW (BX)                              // d92b
	FLDCW (R11)                             // 41d92b
	//TODO: FLDENVL (BX)                    // d923
	//TODO: FLDENVL (R11)                   // 41d923
	FLDL2E                                  // d9ea
	FLDL2T                                  // d9e9
	FLDLG2                                  // d9ec
	FLDPI                                   // d9eb
	//TODO: FMUL F2, F0                     // d8ca
	//TODO: FMUL F3, F0                     // d8cb
	//TODO: FMUL F0, F2                     // dcca
	//TODO: FMUL F0, F3                     // dccb
	//TODO: FMULS (BX)                      // d80b
	//TODO: FMULS (R11)                     // 41d80b
	//TODO: FMULL (BX)                      // dc0b
	//TODO: FMULL (R11)                     // 41dc0b
	//TODO: FMULP F0, F2                    // deca
	//TODO: FMULP F0, F3                    // decb
	//TODO: FNCLEX                          // dbe2
	//TODO: FNINIT                          // dbe3
	FNOP                                    // d9d0
	//TODO: FNSAVEL (BX)                    // dd33
	//TODO: FNSAVEL (R11)                   // 41dd33
	//TODO: FNSTCW (BX)                     // d93b
	//TODO: FNSTCW (R11)                    // 41d93b
	//TODO: FNSTENVL (BX)                   // d933
	//TODO: FNSTENVL (R11)                  // 41d933
	//TODO: FNSTSW AX                       // dfe0
	//TODO: FNSTSW (BX)                     // dd3b
	//TODO: FNSTSW (R11)                    // 41dd3b
	FPATAN                                  // d9f3
	FPREM                                   // d9f8
	FPREM1                                  // d9f5
	FPTAN                                   // d9f2
	FRNDINT                                 // d9fc
	//TODO: FRSTORL (BX)                    // dd23
	//TODO: FRSTORL (R11)                   // 41dd23
	FSCALE                                  // d9fd
	FSIN                                    // d9fe
	FSINCOS                                 // d9fb
	FSQRT                                   // d9fa
	//TODO: FST F2                          // ddd2
	//TODO: FST F3                          // ddd3
	//TODO: FSTS (BX)                       // d913
	//TODO: FSTS (R11)                      // 41d913
	//TODO: FSTL (BX)                       // dd13
	//TODO: FSTL (R11)                      // 41dd13
	//TODO: FSTP F2                         // ddda
	//TODO: FSTP F3                         // dddb
	//TODO: FSTPS (BX)                      // d91b
	//TODO: FSTPS (R11)                     // 41d91b
	//TODO: FSTPL (BX)                      // dd1b
	//TODO: FSTPL (R11)                     // 41dd1b
	//TODO: FSTPT (BX)                      // db3b
	//TODO: FSTPT (R11)                     // 41db3b
	//TODO: FSUB F2, F0                     // d8e2
	//TODO: FSUB F3, F0                     // d8e3
	//TODO: FSUBR F0, F2                    // dcea
	//TODO: FSUBR F0, F3                    // dceb
	//TODO: FSUBS (BX)                      // d823
	//TODO: FSUBS (R11)                     // 41d823
	//TODO: FSUBL (BX)                      // dc23
	//TODO: FSUBL (R11)                     // 41dc23
	//TODO: FSUBRP F0, F2                   // deea
	//TODO: FSUBRP F0, F3                   // deeb
	//TODO: FSUBR F2, F0                    // d8ea
	//TODO: FSUBR F3, F0                    // d8eb
	//TODO: FSUB F0, F2                     // dce2
	//TODO: FSUB F0, F3                     // dce3
	//TODO: FSUBRS (BX)                     // d82b
	//TODO: FSUBRS (R11)                    // 41d82b
	//TODO: FSUBRL (BX)                     // dc2b
	//TODO: FSUBRL (R11)                    // 41dc2b
	//TODO: FSUBP F0, F2                    // dee2
	//TODO: FSUBP F0, F3                    // dee3
	FTST                                    // d9e4
	//TODO: FUCOM F2                        // dde2
	//TODO: FUCOM F3                        // dde3
	//TODO: FUCOMI F2, F0                   // dbea
	//TODO: FUCOMI F3, F0                   // dbeb
	//TODO: FUCOMIP F2, F0                  // dfea
	//TODO: FUCOMIP F3, F0                  // dfeb
	//TODO: FUCOMP F2                       // ddea
	//TODO: FUCOMP F3                       // ddeb
	//TODO: FUCOMPP                         // dae9
	//TODO: FWAIT                           // 9b
	FXAM                                    // d9e5
	//TODO: FXCH F2                         // d9ca
	//TODO: FXCH F3                         // d9cb
	FXRSTOR (BX)                            // 0fae0b
	FXRSTOR (R11)                           // 410fae0b
	FXRSTOR64 (BX)                          // 480fae0b
	FXRSTOR64 (R11)                         // 490fae0b
	FXSAVE (BX)                             // 0fae03
	FXSAVE (R11)                            // 410fae03
	FXSAVE64 (BX)                           // 480fae03
	FXSAVE64 (R11)                          // 490fae03
	FXTRACT                                 // d9f4
	FYL2X                                   // d9f1
	FYL2XP1                                 // d9f9
	HADDPD (BX), X2                         // 660f7c13
	HADDPD (R11), X2                        // 66410f7c13
	HADDPD X2, X2                           // 660f7cd2
	HADDPD X11, X2                          // 66410f7cd3
	HADDPD (BX), X11                        // 66440f7c1b
	HADDPD (R11), X11                       // 66450f7c1b
	HADDPD X2, X11                          // 66440f7cda
	HADDPD X11, X11                         // 66450f7cdb
	HADDPS (BX), X2                         // f20f7c13
	HADDPS (R11), X2                        // f2410f7c13
	HADDPS X2, X2                           // f20f7cd2
	HADDPS X11, X2                          // f2410f7cd3
	HADDPS (BX), X11                        // f2440f7c1b
	HADDPS (R11), X11                       // f2450f7c1b
	HADDPS X2, X11                          // f2440f7cda
	HADDPS X11, X11                         // f2450f7cdb
	HLT                                     // f4
	HSUBPD (BX), X2                         // 660f7d13
	HSUBPD (R11), X2                        // 66410f7d13
	HSUBPD X2, X2                           // 660f7dd2
	HSUBPD X11, X2                          // 66410f7dd3
	HSUBPD (BX), X11                        // 66440f7d1b
	HSUBPD (R11), X11                       // 66450f7d1b
	HSUBPD X2, X11                          // 66440f7dda
	HSUBPD X11, X11                         // 66450f7ddb
	HSUBPS (BX), X2                         // f20f7d13
	HSUBPS (R11), X2                        // f2410f7d13
	HSUBPS X2, X2                           // f20f7dd2
	HSUBPS X11, X2                          // f2410f7dd3
	HSUBPS (BX), X11                        // f2440f7d1b
	HSUBPS (R11), X11                       // f2450f7d1b
	HSUBPS X2, X11                          // f2440f7dda
	HSUBPS X11, X11                         // f2450f7ddb
	//TODO: ICEBP                           // f1
	IDIVW (BX)                              // 66f73b
	IDIVW (R11)                             // 6641f73b
	IDIVW DX                                // 66f7fa
	IDIVW R11                               // 6641f7fb
	IDIVL (BX)                              // f73b
	IDIVL (R11)                             // 41f73b
	IDIVL DX                                // f7fa
	IDIVL R11                               // 41f7fb
	IDIVQ (BX)                              // 48f73b
	IDIVQ (R11)                             // 49f73b
	IDIVQ DX                                // 48f7fa
	IDIVQ R11                               // 49f7fb
	IDIVB (BX)                              // f63b
	IDIVB (R11)                             // 41f63b
	IDIVB DL                                // f6fa
	IDIVB R11                               // 41f6fb
	IMULW (BX)                              // 66f72b
	IMULW (R11)                             // 6641f72b
	IMULW DX                                // 66f7ea
	IMULW R11                               // 6641f7eb
	IMULL (BX)                              // f72b
	IMULL (R11)                             // 41f72b
	IMULL DX                                // f7ea
	IMULL R11                               // 41f7eb
	IMULQ (BX)                              // 48f72b
	IMULQ (R11)                             // 49f72b
	IMULQ DX                                // 48f7ea
	IMULQ R11                               // 49f7eb
	IMULB (BX)                              // f62b
	IMULB (R11)                             // 41f62b
	IMULB DL                                // f6ea
	IMULB R11                               // 41f6eb
	IMULW (BX), DX                          // 660faf13
	IMULW (R11), DX                         // 66410faf13
	IMULW DX, DX                            // 660fafd2
	IMULW R11, DX                           // 66410fafd3
	IMULW (BX), R11                         // 66440faf1b
	IMULW (R11), R11                        // 66450faf1b
	IMULW DX, R11                           // 66440fafda
	IMULW R11, R11                          // 66450fafdb
	//TODO: IMULW $0xf123, (BX), DX         // 66691323f1
	//TODO: IMULW $0xf123, (R11), DX        // 6641691323f1
	//TODO: IMULW $0xf123, DX, DX           // 6669d223f1
	//TODO: IMULW $0xf123, R11, DX          // 664169d323f1
	//TODO: IMULW $0xf123, (BX), R11        // 6644691b23f1
	//TODO: IMULW $0xf123, (R11), R11       // 6645691b23f1
	//TODO: IMULW $0xf123, DX, R11          // 664469da23f1
	//TODO: IMULW $0xf123, R11, R11         // 664569db23f1
	//TODO: IMULW $7, (BX), DX              // 666b1307
	//TODO: IMULW $7, (R11), DX             // 66416b1307
	//TODO: IMULW $7, DX, DX                // 666bd207
	//TODO: IMULW $7, R11, DX               // 66416bd307
	//TODO: IMULW $7, (BX), R11             // 66446b1b07
	//TODO: IMULW $7, (R11), R11            // 66456b1b07
	//TODO: IMULW $7, DX, R11               // 66446bda07
	//TODO: IMULW $7, R11, R11              // 66456bdb07
	IMULL (BX), DX                          // 0faf13
	IMULL (R11), DX                         // 410faf13
	IMULL DX, DX                            // 0fafd2
	IMULL R11, DX                           // 410fafd3
	IMULL (BX), R11                         // 440faf1b
	IMULL (R11), R11                        // 450faf1b
	IMULL DX, R11                           // 440fafda
	IMULL R11, R11                          // 450fafdb
	//TODO: IMULL $0xf1234567, (BX), DX     // 6913674523f1
	//TODO: IMULL $0xf1234567, (R11), DX    // 416913674523f1
	//TODO: IMULL $0xf1234567, DX, DX       // 69d2674523f1
	//TODO: IMULL $0xf1234567, R11, DX      // 4169d3674523f1
	//TODO: IMULL $0xf1234567, (BX), R11    // 44691b674523f1
	//TODO: IMULL $0xf1234567, (R11), R11   // 45691b674523f1
	//TODO: IMULL $0xf1234567, DX, R11      // 4469da674523f1
	//TODO: IMULL $0xf1234567, R11, R11     // 4569db674523f1
	//TODO: IMULL $7, (BX), DX              // 6b1307
	//TODO: IMULL $7, (R11), DX             // 416b1307
	//TODO: IMULL $7, DX, DX                // 6bd207
	//TODO: IMULL $7, R11, DX               // 416bd307
	//TODO: IMULL $7, (BX), R11             // 446b1b07
	//TODO: IMULL $7, (R11), R11            // 456b1b07
	//TODO: IMULL $7, DX, R11               // 446bda07
	//TODO: IMULL $7, R11, R11              // 456bdb07
	IMULQ (BX), DX                          // 480faf13
	IMULQ (R11), DX                         // 490faf13
	IMULQ DX, DX                            // 480fafd2
	IMULQ R11, DX                           // 490fafd3
	IMULQ (BX), R11                         // 4c0faf1b
	IMULQ (R11), R11                        // 4d0faf1b
	IMULQ DX, R11                           // 4c0fafda
	IMULQ R11, R11                          // 4d0fafdb
	//TODO: IMULQ $0xfffffffff1234567, (BX), DX // 486913674523f1
	//TODO: IMULQ $0xfffffffff1234567, (R11), DX // 496913674523f1
	//TODO: IMULQ $0xfffffffff1234567, DX, DX // 4869d2674523f1
	//TODO: IMULQ $0xfffffffff1234567, R11, DX // 4969d3674523f1
	//TODO: IMULQ $0xfffffffff1234567, (BX), R11 // 4c691b674523f1
	//TODO: IMULQ $0xfffffffff1234567, (R11), R11 // 4d691b674523f1
	//TODO: IMULQ $0xfffffffff1234567, DX, R11 // 4c69da674523f1
	//TODO: IMULQ $0xfffffffff1234567, R11, R11 // 4d69db674523f1
	IMUL3Q $7, (BX), DX                     // 486b1307
	IMUL3Q $7, (R11), DX                    // 496b1307
	IMUL3Q $7, DX, DX                       // 486bd207
	IMUL3Q $7, R11, DX                      // 496bd307
	IMUL3Q $7, (BX), R11                    // 4c6b1b07
	IMUL3Q $7, (R11), R11                   // 4d6b1b07
	IMUL3Q $7, DX, R11                      // 4c6bda07
	IMUL3Q $7, R11, R11                     // 4d6bdb07
	//TODO: INB DX, AL                      // ec
	//TODO: INB $7, AL                      // e407
	//TODO: INW DX, AX                      // 66ed
	//TODO: INW $7, AX                      // 66e507
	//TODO: INL DX, AX                      // ed
	//TODO: INL $7, AX                      // e507
	INCW (BX)                               // 66ff03
	INCW (R11)                              // 6641ff03
	INCW DX                                 // 66ffc2
	INCW R11                                // 6641ffc3
	INCL (BX)                               // ff03
	INCL (R11)                              // 41ff03
	INCL DX                                 // ffc2
	INCL R11                                // 41ffc3
	INCQ (BX)                               // 48ff03
	INCQ (R11)                              // 49ff03
	INCQ DX                                 // 48ffc2
	INCQ R11                                // 49ffc3
	INCB (BX)                               // fe03
	INCB (R11)                              // 41fe03
	INCB DL                                 // fec2
	INCB R11                                // 41fec3
	INSB                                    // 6c
	INSL                                    // 6d
	//TODO: INSERTPS $7, (BX), X2           // 660f3a211307
	//TODO: INSERTPS $7, (R11), X2          // 66410f3a211307
	//TODO: INSERTPS $7, X2, X2             // 660f3a21d207
	//TODO: INSERTPS $7, X11, X2            // 66410f3a21d307
	//TODO: INSERTPS $7, (BX), X11          // 66440f3a211b07
	//TODO: INSERTPS $7, (R11), X11         // 66450f3a211b07
	//TODO: INSERTPS $7, X2, X11            // 66440f3a21da07
	//TODO: INSERTPS $7, X11, X11           // 66450f3a21db07
	INSW                                    // 666d
	//TODO: INT $3                          // cc
	INT $7                                  // cd07
	INVD                                    // 0f08
	INVLPG (BX)                             // 0f013b
	INVLPG (R11)                            // 410f013b
	//TODO: INVPCID (BX), DX                // 660f388213
	//TODO: INVPCID (R11), DX               // 66410f388213
	//TODO: INVPCID (BX), R11               // 66440f38821b
	//TODO: INVPCID (R11), R11              // 66450f38821b
	JCS 2(PC)
	IRETW                                   // 66cf
	JCS 2(PC)
	IRETL                                   // cf
	JCS 2(PC)
	IRETQ                                   // 48cf
	//TODO: JA .+$0x11223344                // 480f8744332211 or 0f8744332211
	//TODO: JA .+$0x11                      // 7711
	//TODO: JAE .+$0x11223344               // 0f8344332211 or 480f8344332211
	//TODO: JAE .+$0x11                     // 7311
	//TODO: JB .+$0x11223344                // 480f8244332211 or 0f8244332211
	//TODO: JB .+$0x11                      // 7211
	//TODO: JBE .+$0x11223344               // 0f8644332211 or 480f8644332211
	//TODO: JBE .+$0x11                     // 7611
	//TODO: JE .+$0x11223344                // 480f8444332211 or 0f8444332211
	//TODO: JE .+$0x11                      // 7411
	//TODO: JECXZ .+$0x11                   // e311
	//TODO: JG .+$0x11223344                // 0f8f44332211 or 480f8f44332211
	//TODO: JG .+$0x11                      // 7f11
	//TODO: JGE .+$0x11223344               // 480f8d44332211 or 0f8d44332211
	//TODO: JGE .+$0x11                     // 7d11
	//TODO: JL .+$0x11223344                // 0f8c44332211 or 480f8c44332211
	//TODO: JL .+$0x11                      // 7c11
	//TODO: JLE .+$0x11223344               // 0f8e44332211 or 480f8e44332211
	//TODO: JLE .+$0x11                     // 7e11
	JCS 2(PC)
	//TODO: JMPQ* (BX)                      // ff23
	JCS 2(PC)
	//TODO: JMPQ* (R11)                     // 41ff23
	JCS 2(PC)
	//TODO: JMPQ* DX                        // ffe2
	JCS 2(PC)
	//TODO: JMPQ* R11                       // 41ffe3
	JCS 2(PC)
	//TODO: JMP .+$0x11223344               // 48e944332211 or e944332211
	JCS 2(PC)
	JCS 2(PC)
	//TODO: JMP .+$0x11                     // eb11
	JCS 2(PC)
	//TODO: LJMPW* (BX)                     // 66ff2b
	JCS 2(PC)
	//TODO: LJMPW* (R11)                    // 6641ff2b
	JCS 2(PC)
	//TODO: LJMPL* (BX)                     // ff2b
	JCS 2(PC)
	//TODO: LJMPL* (R11)                    // 41ff2b
	JCS 2(PC)
	//TODO: LJMPQ* (BX)                     // 48ff2b
	JCS 2(PC)
	//TODO: LJMPQ* (R11)                    // 49ff2b
	//TODO: JNE .+$0x11223344               // 480f8544332211 or 0f8544332211
	//TODO: JNE .+$0x11                     // 7511
	//TODO: JNO .+$0x11223344               // 480f8144332211 or 0f8144332211
	//TODO: JNO .+$0x11                     // 7111
	//TODO: JNP .+$0x11223344               // 480f8b44332211 or 0f8b44332211
	//TODO: JNP .+$0x11                     // 7b11
	//TODO: JNS .+$0x11223344               // 0f8944332211 or 480f8944332211
	//TODO: JNS .+$0x11                     // 7911
	//TODO: JO .+$0x11223344                // 0f8044332211 or 480f8044332211
	//TODO: JO .+$0x11                      // 7011
	//TODO: JP .+$0x11223344                // 480f8a44332211 or 0f8a44332211
	//TODO: JP .+$0x11                      // 7a11
	//TODO: JRCXZ .+$0x11                   // e311
	//TODO: JS .+$0x11223344                // 480f8844332211 or 0f8844332211
	//TODO: JS .+$0x11                      // 7811
	LAHF                                    // 9f
	LARW (BX), DX                           // 660f0213
	LARW (R11), DX                          // 66410f0213
	LARW DX, DX                             // 660f02d2
	LARW R11, DX                            // 66410f02d3
	LARW (BX), R11                          // 66440f021b
	LARW (R11), R11                         // 66450f021b
	LARW DX, R11                            // 66440f02da
	LARW R11, R11                           // 66450f02db
	LARL (BX), DX                           // 0f0213
	LARL (R11), DX                          // 410f0213
	LARL DX, DX                             // 0f02d2
	LARL R11, DX                            // 410f02d3
	LARL (BX), R11                          // 440f021b
	LARL (R11), R11                         // 450f021b
	LARL DX, R11                            // 440f02da
	LARL R11, R11                           // 450f02db
	//TODO: LARQ (BX), DX                   // 480f0213
	//TODO: LARQ (R11), DX                  // 490f0213
	//TODO: LARQ DX, DX                     // 480f02d2
	//TODO: LARQ R11, DX                    // 490f02d3
	//TODO: LARQ (BX), R11                  // 4c0f021b
	//TODO: LARQ (R11), R11                 // 4d0f021b
	//TODO: LARQ DX, R11                    // 4c0f02da
	//TODO: LARQ R11, R11                   // 4d0f02db
	LDDQU (BX), X2                          // f20ff013
	LDDQU (R11), X2                         // f2410ff013
	LDDQU (BX), X11                         // f2440ff01b
	LDDQU (R11), X11                        // f2450ff01b
	LDMXCSR (BX)                            // 0fae13
	LDMXCSR (R11)                           // 410fae13
	LEAW (BX), DX                           // 668d13
	LEAW (R11), DX                          // 66418d13
	LEAW (BX), R11                          // 66448d1b
	LEAW (R11), R11                         // 66458d1b
	LEAL (BX), DX                           // 8d13
	LEAL (R11), DX                          // 418d13
	LEAL (BX), R11                          // 448d1b
	LEAL (R11), R11                         // 458d1b
	LEAQ (BX), DX                           // 488d13
	LEAQ (R11), DX                          // 498d13
	LEAQ (BX), R11                          // 4c8d1b
	LEAQ (R11), R11                         // 4d8d1b
	LEAVEQ                                  // 66c9 or c9
	LFENCE                                  // 0faee8
	//TODO: LFSW (BX), DX                   // 660fb413
	//TODO: LFSW (R11), DX                  // 66410fb413
	//TODO: LFSW (BX), R11                  // 66440fb41b
	//TODO: LFSW (R11), R11                 // 66450fb41b
	//TODO: LFSL (BX), DX                   // 0fb413
	//TODO: LFSL (R11), DX                  // 410fb413
	//TODO: LFSL (BX), R11                  // 440fb41b
	//TODO: LFSL (R11), R11                 // 450fb41b
	//TODO: LFSQ (BX), DX                   // 480fb413
	//TODO: LFSQ (R11), DX                  // 490fb413
	//TODO: LFSQ (BX), R11                  // 4c0fb41b
	//TODO: LFSQ (R11), R11                 // 4d0fb41b
	//TODO: LGDT (BX)                       // 0f0113
	//TODO: LGDT (R11)                      // 410f0113
	//TODO: LGSW (BX), DX                   // 660fb513
	//TODO: LGSW (R11), DX                  // 66410fb513
	//TODO: LGSW (BX), R11                  // 66440fb51b
	//TODO: LGSW (R11), R11                 // 66450fb51b
	//TODO: LGSL (BX), DX                   // 0fb513
	//TODO: LGSL (R11), DX                  // 410fb513
	//TODO: LGSL (BX), R11                  // 440fb51b
	//TODO: LGSL (R11), R11                 // 450fb51b
	//TODO: LGSQ (BX), DX                   // 480fb513
	//TODO: LGSQ (R11), DX                  // 490fb513
	//TODO: LGSQ (BX), R11                  // 4c0fb51b
	//TODO: LGSQ (R11), R11                 // 4d0fb51b
	//TODO: LIDT (BX)                       // 0f011b
	//TODO: LIDT (R11)                      // 410f011b
	//TODO: LLDT (BX)                       // 0f0013
	//TODO: LLDT (R11)                      // 410f0013
	//TODO: LLDT DX                         // 0f00d2
	//TODO: LLDT R11                        // 410f00d3
	//TODO: LMSW (BX)                       // 0f0133
	//TODO: LMSW (R11)                      // 410f0133
	//TODO: LMSW DX                         // 0f01f2
	//TODO: LMSW R11                        // 410f01f3
	LODSB                                   // ac
	LODSL                                   // ad
	LODSQ                                   // 48ad
	LODSW                                   // 66ad
	//TODO: LOOP .+$0x11                    // e211
	//TODO: LOOPEQ .+$0x11                  // e111
	//TODO: LOOPNE .+$0x11                  // e011
	LSLW (BX), DX                           // 660f0313
	LSLW (R11), DX                          // 66410f0313
	LSLW DX, DX                             // 660f03d2
	LSLW R11, DX                            // 66410f03d3
	LSLW (BX), R11                          // 66440f031b
	LSLW (R11), R11                         // 66450f031b
	LSLW DX, R11                            // 66440f03da
	LSLW R11, R11                           // 66450f03db
	LSLL (BX), DX                           // 0f0313
	LSLL (R11), DX                          // 410f0313
	LSLL DX, DX                             // 0f03d2
	LSLL R11, DX                            // 410f03d3
	LSLL (BX), R11                          // 440f031b
	LSLL (R11), R11                         // 450f031b
	LSLL DX, R11                            // 440f03da
	LSLL R11, R11                           // 450f03db
	//TODO: LSLQ (BX), DX                   // 480f0313
	//TODO: LSLQ (R11), DX                  // 490f0313
	//TODO: LSLQ DX, DX                     // 480f03d2
	//TODO: LSLQ R11, DX                    // 490f03d3
	//TODO: LSLQ (BX), R11                  // 4c0f031b
	//TODO: LSLQ (R11), R11                 // 4d0f031b
	//TODO: LSLQ DX, R11                    // 4c0f03da
	//TODO: LSLQ R11, R11                   // 4d0f03db
	//TODO: LSSW (BX), DX                   // 660fb213
	//TODO: LSSW (R11), DX                  // 66410fb213
	//TODO: LSSW (BX), R11                  // 66440fb21b
	//TODO: LSSW (R11), R11                 // 66450fb21b
	//TODO: LSSL (BX), DX                   // 0fb213
	//TODO: LSSL (R11), DX                  // 410fb213
	//TODO: LSSL (BX), R11                  // 440fb21b
	//TODO: LSSL (R11), R11                 // 450fb21b
	//TODO: LSSQ (BX), DX                   // 480fb213
	//TODO: LSSQ (R11), DX                  // 490fb213
	//TODO: LSSQ (BX), R11                  // 4c0fb21b
	//TODO: LSSQ (R11), R11                 // 4d0fb21b
	//TODO: LTR (BX)                        // 0f001b
	//TODO: LTR (R11)                       // 410f001b
	//TODO: LTR DX                          // 0f00da
	//TODO: LTR R11                         // 410f00db
	//TODO: LZCNTW (BX), DX                 // 66f30fbd13
	//TODO: LZCNTW (R11), DX                // 66f3410fbd13
	//TODO: LZCNTW DX, DX                   // 66f30fbdd2
	//TODO: LZCNTW R11, DX                  // 66f3410fbdd3
	//TODO: LZCNTW (BX), R11                // 66f3440fbd1b
	//TODO: LZCNTW (R11), R11               // 66f3450fbd1b
	//TODO: LZCNTW DX, R11                  // 66f3440fbdda
	//TODO: LZCNTW R11, R11                 // 66f3450fbddb
	//TODO: LZCNTL (BX), DX                 // f30fbd13
	//TODO: LZCNTL (R11), DX                // f3410fbd13
	//TODO: LZCNTL DX, DX                   // f30fbdd2
	//TODO: LZCNTL R11, DX                  // f3410fbdd3
	//TODO: LZCNTL (BX), R11                // f3440fbd1b
	//TODO: LZCNTL (R11), R11               // f3450fbd1b
	//TODO: LZCNTL DX, R11                  // f3440fbdda
	//TODO: LZCNTL R11, R11                 // f3450fbddb
	//TODO: LZCNTQ (BX), DX                 // f3480fbd13
	//TODO: LZCNTQ (R11), DX                // f3490fbd13
	//TODO: LZCNTQ DX, DX                   // f3480fbdd2
	//TODO: LZCNTQ R11, DX                  // f3490fbdd3
	//TODO: LZCNTQ (BX), R11                // f34c0fbd1b
	//TODO: LZCNTQ (R11), R11               // f34d0fbd1b
	//TODO: LZCNTQ DX, R11                  // f34c0fbdda
	//TODO: LZCNTQ R11, R11                 // f34d0fbddb
	MASKMOVOU X2, X2                        // 660ff7d2
	MASKMOVOU X11, X2                       // 66410ff7d3
	MASKMOVOU X2, X11                       // 66440ff7da
	MASKMOVOU X11, X11                      // 66450ff7db
	MASKMOVQ M2, M2                         // 0ff7d2
	MASKMOVQ M3, M2                         // 0ff7d3
	MASKMOVQ M2, M3                         // 0ff7da
	MASKMOVQ M3, M3                         // 0ff7db
	MAXPD (BX), X2                          // 660f5f13
	MAXPD (R11), X2                         // 66410f5f13
	MAXPD X2, X2                            // 660f5fd2
	MAXPD X11, X2                           // 66410f5fd3
	MAXPD (BX), X11                         // 66440f5f1b
	MAXPD (R11), X11                        // 66450f5f1b
	MAXPD X2, X11                           // 66440f5fda
	MAXPD X11, X11                          // 66450f5fdb
	MAXPS (BX), X2                          // 0f5f13
	MAXPS (R11), X2                         // 410f5f13
	MAXPS X2, X2                            // 0f5fd2
	MAXPS X11, X2                           // 410f5fd3
	MAXPS (BX), X11                         // 440f5f1b
	MAXPS (R11), X11                        // 450f5f1b
	MAXPS X2, X11                           // 440f5fda
	MAXPS X11, X11                          // 450f5fdb
	MAXSD (BX), X2                          // f20f5f13
	MAXSD (R11), X2                         // f2410f5f13
	MAXSD X2, X2                            // f20f5fd2
	MAXSD X11, X2                           // f2410f5fd3
	MAXSD (BX), X11                         // f2440f5f1b
	MAXSD (R11), X11                        // f2450f5f1b
	MAXSD X2, X11                           // f2440f5fda
	MAXSD X11, X11                          // f2450f5fdb
	MAXSS (BX), X2                          // f30f5f13
	MAXSS (R11), X2                         // f3410f5f13
	MAXSS X2, X2                            // f30f5fd2
	MAXSS X11, X2                           // f3410f5fd3
	MAXSS (BX), X11                         // f3440f5f1b
	MAXSS (R11), X11                        // f3450f5f1b
	MAXSS X2, X11                           // f3440f5fda
	MAXSS X11, X11                          // f3450f5fdb
	MFENCE                                  // 0faef0
	MINPD (BX), X2                          // 660f5d13
	MINPD (R11), X2                         // 66410f5d13
	MINPD X2, X2                            // 660f5dd2
	MINPD X11, X2                           // 66410f5dd3
	MINPD (BX), X11                         // 66440f5d1b
	MINPD (R11), X11                        // 66450f5d1b
	MINPD X2, X11                           // 66440f5dda
	MINPD X11, X11                          // 66450f5ddb
	MINPS (BX), X2                          // 0f5d13
	MINPS (R11), X2                         // 410f5d13
	MINPS X2, X2                            // 0f5dd2
	MINPS X11, X2                           // 410f5dd3
	MINPS (BX), X11                         // 440f5d1b
	MINPS (R11), X11                        // 450f5d1b
	MINPS X2, X11                           // 440f5dda
	MINPS X11, X11                          // 450f5ddb
	MINSD (BX), X2                          // f20f5d13
	MINSD (R11), X2                         // f2410f5d13
	MINSD X2, X2                            // f20f5dd2
	MINSD X11, X2                           // f2410f5dd3
	MINSD (BX), X11                         // f2440f5d1b
	MINSD (R11), X11                        // f2450f5d1b
	MINSD X2, X11                           // f2440f5dda
	MINSD X11, X11                          // f2450f5ddb
	MINSS (BX), X2                          // f30f5d13
	MINSS (R11), X2                         // f3410f5d13
	MINSS X2, X2                            // f30f5dd2
	MINSS X11, X2                           // f3410f5dd3
	MINSS (BX), X11                         // f3440f5d1b
	MINSS (R11), X11                        // f3450f5d1b
	MINSS X2, X11                           // f3440f5dda
	MINSS X11, X11                          // f3450f5ddb
	//TODO: MONITOR                         // 0f01c8
	//TODO: MOVABSB 0x123456789abcdef1, AL  // a0f1debc9a78563412
	//TODO: MOVW 0x123456789abcdef1, AX     // 66a1f1debc9a78563412
	MOVQ DX, CR2                            // 0f22d2
	MOVQ R11, CR2                           // 410f22d3
	MOVQ DX, CR3                            // 0f22da
	MOVQ R11, CR3                           // 410f22db
	//TODO: MOVQ DX, DR2                    // 0f23d2
	//TODO: MOVQ R11, DR2                   // 410f23d3
	//TODO: MOVQ DX, DR3                    // 0f23da
	//TODO: MOVQ R11, DR3                   // 410f23db
	//TODO: MOVL 0x123456789abcdef1, AX     // a1f1debc9a78563412
	//TODO: MOVQ 0x123456789abcdef1, AX     // 48a1f1debc9a78563412
	//TODO: MOVW (BX), SS                   // 668e13 or 488e13
	//TODO: MOVW (R11), SS                  // 66418e13 or 498e13
	//TODO: MOVW DX, SS                     // 668ed2 or 488ed2
	//TODO: MOVW R11, SS                    // 66418ed3 or 498ed3
	//TODO: MOVW (BX), DS                   // 668e1b or 488e1b
	//TODO: MOVW (R11), DS                  // 66418e1b or 498e1b
	//TODO: MOVW DX, DS                     // 668eda or 488eda
	//TODO: MOVW R11, DS                    // 66418edb or 498edb
	//TODO: MOVL (BX), SS                   // 8e13
	//TODO: MOVL (R11), SS                  // 418e13
	//TODO: MOVL DX, SS                     // 8ed2
	//TODO: MOVL R11, SS                    // 418ed3
	//TODO: MOVL (BX), DS                   // 8e1b
	//TODO: MOVL (R11), DS                  // 418e1b
	//TODO: MOVL DX, DS                     // 8eda
	//TODO: MOVL R11, DS                    // 418edb
	//TODO: MOVW AX, 0x123456789abcdef1     // 66a3f1debc9a78563412
	//TODO: MOVL AX, 0x123456789abcdef1     // a3f1debc9a78563412
	//TODO: MOVQ AX, 0x123456789abcdef1     // 48a3f1debc9a78563412
	//TODO: MOVABSB AL, 0x123456789abcdef1  // a2f1debc9a78563412
	//TODO: MOVW SS, (BX)                   // 668c13 or 488c13
	//TODO: MOVW DS, (BX)                   // 668c1b or 488c1b
	//TODO: MOVW SS, (R11)                  // 66418c13 or 498c13
	//TODO: MOVW DS, (R11)                  // 66418c1b or 498c1b
	//TODO: MOVW SS, DX                     // 668cd2 or 488cd2
	//TODO: MOVW DS, DX                     // 668cda or 488cda
	//TODO: MOVW SS, R11                    // 66418cd3 or 498cd3
	//TODO: MOVW DS, R11                    // 66418cdb or 498cdb
	MOVW $61731, (BX)                       // 66c70323f1
	MOVW $61731, (R11)                      // 6641c70323f1
	MOVW $61731, DX                         // 66c7c223f1 or 66ba23f1
	MOVW $61731, R11                        // 6641c7c323f1 or 6641bb23f1
	MOVW DX, (BX)                           // 668913
	MOVW R11, (BX)                          // 6644891b
	MOVW DX, (R11)                          // 66418913
	MOVW R11, (R11)                         // 6645891b
	MOVW DX, DX                             // 6689d2 or 668bd2
	MOVW R11, DX                            // 664489da or 66418bd3
	MOVW DX, R11                            // 664189d3 or 66448bda
	MOVW R11, R11                           // 664589db or 66458bdb
	//TODO: MOVL SS, (BX)                   // 8c13
	//TODO: MOVL DS, (BX)                   // 8c1b
	//TODO: MOVL SS, (R11)                  // 418c13
	//TODO: MOVL DS, (R11)                  // 418c1b
	//TODO: MOVL SS, DX                     // 8cd2
	//TODO: MOVL DS, DX                     // 8cda
	//TODO: MOVL SS, R11                    // 418cd3
	//TODO: MOVL DS, R11                    // 418cdb
	MOVL $4045620583, (BX)                  // c703674523f1
	MOVL $4045620583, (R11)                 // 41c703674523f1
	MOVL $4045620583, DX                    // c7c2674523f1 or ba674523f1
	MOVL $4045620583, R11                   // 41c7c3674523f1 or 41bb674523f1
	MOVL DX, (BX)                           // 8913
	MOVL R11, (BX)                          // 44891b
	MOVL DX, (R11)                          // 418913
	MOVL R11, (R11)                         // 45891b
	MOVL DX, DX                             // 89d2 or 8bd2
	MOVL R11, DX                            // 4489da or 418bd3
	MOVL DX, R11                            // 4189d3 or 448bda
	MOVL R11, R11                           // 4589db or 458bdb
	MOVQ $-249346713, (BX)                  // 48c703674523f1
	MOVQ $-249346713, (R11)                 // 49c703674523f1
	MOVQ $-249346713, DX                    // 48c7c2674523f1
	MOVQ $-249346713, R11                   // 49c7c3674523f1
	MOVQ DX, (BX)                           // 488913
	MOVQ R11, (BX)                          // 4c891b
	MOVQ DX, (R11)                          // 498913
	MOVQ R11, (R11)                         // 4d891b
	MOVQ DX, DX                             // 4889d2 or 488bd2
	MOVQ R11, DX                            // 4c89da or 498bd3
	MOVQ DX, R11                            // 4989d3 or 4c8bda
	MOVQ R11, R11                           // 4d89db or 4d8bdb
	MOVB $7, (BX)                           // c60307
	MOVB $7, (R11)                          // 41c60307
	MOVB $7, DL                             // c6c207 or b207
	MOVB $7, R11                            // 41c6c307 or 41b307
	MOVB DL, (BX)                           // 8813
	MOVB R11, (BX)                          // 44881b
	MOVB DL, (R11)                          // 418813
	MOVB R11, (R11)                         // 45881b
	MOVB DL, DL                             // 88d2 or 8ad2
	MOVB R11, DL                            // 4488da or 418ad3
	MOVB DL, R11                            // 4188d3 or 448ada
	MOVB R11, R11                           // 4588db or 458adb
	MOVW (BX), DX                           // 668b13
	MOVW (R11), DX                          // 66418b13
	MOVW (BX), R11                          // 66448b1b
	MOVW (R11), R11                         // 66458b1b
	MOVL (BX), DX                           // 8b13
	MOVL (R11), DX                          // 418b13
	MOVL (BX), R11                          // 448b1b
	MOVL (R11), R11                         // 458b1b
	MOVQ (BX), DX                           // 488b13
	MOVQ (R11), DX                          // 498b13
	MOVQ (BX), R11                          // 4c8b1b
	MOVQ (R11), R11                         // 4d8b1b
	MOVQ $-1070935975390360081, DX          // 48baefcdab89674523f1
	MOVQ $-1070935975390360081, R11         // 49bbefcdab89674523f1
	MOVB (BX), DL                           // 8a13
	MOVB (R11), DL                          // 418a13
	MOVB (BX), R11                          // 448a1b
	MOVB (R11), R11                         // 458a1b
	MOVQ CR2, DX                            // 0f20d2
	MOVQ CR3, DX                            // 0f20da
	MOVQ CR2, R11                           // 410f20d3
	MOVQ CR3, R11                           // 410f20db
	//TODO: MOVQ DR2, DX                    // 0f21d2
	//TODO: MOVQ DR3, DX                    // 0f21da
	//TODO: MOVQ DR2, R11                   // 410f21d3
	//TODO: MOVQ DR3, R11                   // 410f21db
	MOVAPD (BX), X2                         // 660f2813
	MOVAPD (R11), X2                        // 66410f2813
	MOVAPD X2, X2                           // 660f28d2 or 660f29d2
	MOVAPD X11, X2                          // 66410f28d3 or 66440f29da
	MOVAPD (BX), X11                        // 66440f281b
	MOVAPD (R11), X11                       // 66450f281b
	MOVAPD X2, X11                          // 66440f28da or 66410f29d3
	MOVAPD X11, X11                         // 66450f28db or 66450f29db
	MOVAPD X2, (BX)                         // 660f2913
	MOVAPD X11, (BX)                        // 66440f291b
	MOVAPD X2, (R11)                        // 66410f2913
	MOVAPD X11, (R11)                       // 66450f291b
	MOVAPS (BX), X2                         // 0f2813
	MOVAPS (R11), X2                        // 410f2813
	MOVAPS X2, X2                           // 0f28d2 or 0f29d2
	MOVAPS X11, X2                          // 410f28d3 or 440f29da
	MOVAPS (BX), X11                        // 440f281b
	MOVAPS (R11), X11                       // 450f281b
	MOVAPS X2, X11                          // 440f28da or 410f29d3
	MOVAPS X11, X11                         // 450f28db or 450f29db
	MOVAPS X2, (BX)                         // 0f2913
	MOVAPS X11, (BX)                        // 440f291b
	MOVAPS X2, (R11)                        // 410f2913
	MOVAPS X11, (R11)                       // 450f291b
	//TODO: MOVBEWW DX, (BX)                // 660f38f113
	//TODO: MOVBEWW R11, (BX)               // 66440f38f11b
	//TODO: MOVBEWW DX, (R11)               // 66410f38f113
	//TODO: MOVBEWW R11, (R11)              // 66450f38f11b
	//TODO: MOVBELL DX, (BX)                // 0f38f113
	//TODO: MOVBELL R11, (BX)               // 440f38f11b
	//TODO: MOVBELL DX, (R11)               // 410f38f113
	//TODO: MOVBELL R11, (R11)              // 450f38f11b
	//TODO: MOVBEQQ DX, (BX)                // 480f38f113
	//TODO: MOVBEQQ R11, (BX)               // 4c0f38f11b
	//TODO: MOVBEQQ DX, (R11)               // 490f38f113
	//TODO: MOVBEQQ R11, (R11)              // 4d0f38f11b
	//TODO: MOVBEWW (BX), DX                // 660f38f013
	//TODO: MOVBEWW (R11), DX               // 66410f38f013
	//TODO: MOVBEWW (BX), R11               // 66440f38f01b
	//TODO: MOVBEWW (R11), R11              // 66450f38f01b
	//TODO: MOVBELL (BX), DX                // 0f38f013
	//TODO: MOVBELL (R11), DX               // 410f38f013
	//TODO: MOVBELL (BX), R11               // 440f38f01b
	//TODO: MOVBELL (R11), R11              // 450f38f01b
	//TODO: MOVBEQQ (BX), DX                // 480f38f013
	//TODO: MOVBEQQ (R11), DX               // 490f38f013
	//TODO: MOVBEQQ (BX), R11               // 4c0f38f01b
	//TODO: MOVBEQQ (R11), R11              // 4d0f38f01b
	MOVQ (BX), M2                           // 0f6e13 or 0f6f13 or 480f6e13
	MOVQ (R11), M2                          // 410f6e13 or 410f6f13 or 490f6e13
	MOVQ DX, M2                             // 0f6ed2 or 480f6ed2
	MOVQ R11, M2                            // 410f6ed3 or 490f6ed3
	MOVQ (BX), M3                           // 0f6e1b or 0f6f1b or 480f6e1b
	MOVQ (R11), M3                          // 410f6e1b or 410f6f1b or 490f6e1b
	MOVQ DX, M3                             // 0f6eda or 480f6eda
	MOVQ R11, M3                            // 410f6edb or 490f6edb
	MOVQ M2, (BX)                           // 0f7e13 or 0f7f13 or 480f7e13
	MOVQ M3, (BX)                           // 0f7e1b or 0f7f1b or 480f7e1b
	MOVQ M2, (R11)                          // 410f7e13 or 410f7f13 or 490f7e13
	MOVQ M3, (R11)                          // 410f7e1b or 410f7f1b or 490f7e1b
	MOVQ M2, DX                             // 0f7ed2 or 480f7ed2
	MOVQ M3, DX                             // 0f7eda or 480f7eda
	MOVQ M2, R11                            // 410f7ed3 or 490f7ed3
	MOVQ M3, R11                            // 410f7edb or 490f7edb
	MOVQ X2, (BX)                           // 660f7e13 or 66480f7e13 or 660fd613
	MOVQ X11, (BX)                          // 66440f7e1b or 664c0f7e1b or 66440fd61b
	MOVQ X2, (R11)                          // 66410f7e13 or 66490f7e13 or 66410fd613
	MOVQ X11, (R11)                         // 66450f7e1b or 664d0f7e1b or 66450fd61b
	MOVQ X2, DX                             // 660f7ed2 or 66480f7ed2
	MOVQ X11, DX                            // 66440f7eda or 664c0f7eda
	MOVQ X2, R11                            // 66410f7ed3 or 66490f7ed3
	MOVQ X11, R11                           // 66450f7edb or 664d0f7edb
	MOVQ (BX), X2                           // 660f6e13 or 66480f6e13 or f30f7e13
	MOVQ (R11), X2                          // 66410f6e13 or 66490f6e13 or f3410f7e13
	MOVQ DX, X2                             // 660f6ed2 or 66480f6ed2
	MOVQ R11, X2                            // 66410f6ed3 or 66490f6ed3
	MOVQ (BX), X11                          // 66440f6e1b or 664c0f6e1b or f3440f7e1b
	MOVQ (R11), X11                         // 66450f6e1b or 664d0f6e1b or f3450f7e1b
	MOVQ DX, X11                            // 66440f6eda or 664c0f6eda
	MOVQ R11, X11                           // 66450f6edb or 664d0f6edb
	//TODO: MOVDDUP (BX), X2                // f20f1213
	//TODO: MOVDDUP (R11), X2               // f2410f1213
	//TODO: MOVDDUP X2, X2                  // f20f12d2
	//TODO: MOVDDUP X11, X2                 // f2410f12d3
	//TODO: MOVDDUP (BX), X11               // f2440f121b
	//TODO: MOVDDUP (R11), X11              // f2450f121b
	//TODO: MOVDDUP X2, X11                 // f2440f12da
	//TODO: MOVDDUP X11, X11                // f2450f12db
	MOVQ X2, M2                             // f20fd6d2
	MOVQ X11, M2                            // f2410fd6d3
	MOVQ X2, M3                             // f20fd6da
	MOVQ X11, M3                            // f2410fd6db
	MOVO (BX), X2                           // 660f6f13
	MOVO (R11), X2                          // 66410f6f13
	MOVO X2, X2                             // 660f6fd2 or 660f7fd2
	MOVO X11, X2                            // 66410f6fd3 or 66440f7fda
	MOVO (BX), X11                          // 66440f6f1b
	MOVO (R11), X11                         // 66450f6f1b
	MOVO X2, X11                            // 66440f6fda or 66410f7fd3
	MOVO X11, X11                           // 66450f6fdb or 66450f7fdb
	MOVO X2, (BX)                           // 660f7f13
	MOVO X11, (BX)                          // 66440f7f1b
	MOVO X2, (R11)                          // 66410f7f13
	MOVO X11, (R11)                         // 66450f7f1b
	MOVOU (BX), X2                          // f30f6f13
	MOVOU (R11), X2                         // f3410f6f13
	MOVOU X2, X2                            // f30f6fd2 or f30f7fd2
	MOVOU X11, X2                           // f3410f6fd3 or f3440f7fda
	MOVOU (BX), X11                         // f3440f6f1b
	MOVOU (R11), X11                        // f3450f6f1b
	MOVOU X2, X11                           // f3440f6fda or f3410f7fd3
	MOVOU X11, X11                          // f3450f6fdb or f3450f7fdb
	MOVOU X2, (BX)                          // f30f7f13
	MOVOU X11, (BX)                         // f3440f7f1b
	MOVOU X2, (R11)                         // f3410f7f13
	MOVOU X11, (R11)                        // f3450f7f1b
	MOVHLPS X2, X2                          // 0f12d2
	MOVHLPS X11, X2                         // 410f12d3
	MOVHLPS X2, X11                         // 440f12da
	MOVHLPS X11, X11                        // 450f12db
	MOVHPD X2, (BX)                         // 660f1713
	MOVHPD X11, (BX)                        // 66440f171b
	MOVHPD X2, (R11)                        // 66410f1713
	MOVHPD X11, (R11)                       // 66450f171b
	MOVHPD (BX), X2                         // 660f1613
	MOVHPD (R11), X2                        // 66410f1613
	MOVHPD (BX), X11                        // 66440f161b
	MOVHPD (R11), X11                       // 66450f161b
	MOVHPS X2, (BX)                         // 0f1713
	MOVHPS X11, (BX)                        // 440f171b
	MOVHPS X2, (R11)                        // 410f1713
	MOVHPS X11, (R11)                       // 450f171b
	MOVHPS (BX), X2                         // 0f1613
	MOVHPS (R11), X2                        // 410f1613
	MOVHPS (BX), X11                        // 440f161b
	MOVHPS (R11), X11                       // 450f161b
	MOVLHPS X2, X2                          // 0f16d2
	MOVLHPS X11, X2                         // 410f16d3
	MOVLHPS X2, X11                         // 440f16da
	MOVLHPS X11, X11                        // 450f16db
	MOVLPD X2, (BX)                         // 660f1313
	MOVLPD X11, (BX)                        // 66440f131b
	MOVLPD X2, (R11)                        // 66410f1313
	MOVLPD X11, (R11)                       // 66450f131b
	MOVLPD (BX), X2                         // 660f1213
	MOVLPD (R11), X2                        // 66410f1213
	MOVLPD (BX), X11                        // 66440f121b
	MOVLPD (R11), X11                       // 66450f121b
	MOVLPS X2, (BX)                         // 0f1313
	MOVLPS X11, (BX)                        // 440f131b
	MOVLPS X2, (R11)                        // 410f1313
	MOVLPS X11, (R11)                       // 450f131b
	MOVLPS (BX), X2                         // 0f1213
	MOVLPS (R11), X2                        // 410f1213
	MOVLPS (BX), X11                        // 440f121b
	MOVLPS (R11), X11                       // 450f121b
	MOVMSKPD X2, DX                         // 660f50d2
	MOVMSKPD X11, DX                        // 66410f50d3
	MOVMSKPD X2, R11                        // 66440f50da
	MOVMSKPD X11, R11                       // 66450f50db
	MOVMSKPS X2, DX                         // 0f50d2
	MOVMSKPS X11, DX                        // 410f50d3
	MOVMSKPS X2, R11                        // 440f50da
	MOVMSKPS X11, R11                       // 450f50db
	MOVNTO X2, (BX)                         // 660fe713
	MOVNTO X11, (BX)                        // 66440fe71b
	MOVNTO X2, (R11)                        // 66410fe713
	MOVNTO X11, (R11)                       // 66450fe71b
	//TODO: MOVNTDQA (BX), X2               // 660f382a13
	//TODO: MOVNTDQA (R11), X2              // 66410f382a13
	//TODO: MOVNTDQA (BX), X11              // 66440f382a1b
	//TODO: MOVNTDQA (R11), X11             // 66450f382a1b
	MOVNTIL DX, (BX)                        // 0fc313
	MOVNTIL R11, (BX)                       // 440fc31b
	MOVNTIL DX, (R11)                       // 410fc313
	MOVNTIL R11, (R11)                      // 450fc31b
	MOVNTIQ DX, (BX)                        // 480fc313
	MOVNTIQ R11, (BX)                       // 4c0fc31b
	MOVNTIQ DX, (R11)                       // 490fc313
	MOVNTIQ R11, (R11)                      // 4d0fc31b
	MOVNTPD X2, (BX)                        // 660f2b13
	MOVNTPD X11, (BX)                       // 66440f2b1b
	MOVNTPD X2, (R11)                       // 66410f2b13
	MOVNTPD X11, (R11)                      // 66450f2b1b
	MOVNTPS X2, (BX)                        // 0f2b13
	MOVNTPS X11, (BX)                       // 440f2b1b
	MOVNTPS X2, (R11)                       // 410f2b13
	MOVNTPS X11, (R11)                      // 450f2b1b
	MOVNTQ M2, (BX)                         // 0fe713
	MOVNTQ M3, (BX)                         // 0fe71b
	MOVNTQ M2, (R11)                        // 410fe713
	MOVNTQ M3, (R11)                        // 410fe71b
	//TODO: MOVNTSD X2, (BX)                // f20f2b13
	//TODO: MOVNTSD X11, (BX)               // f2440f2b1b
	//TODO: MOVNTSD X2, (R11)               // f2410f2b13
	//TODO: MOVNTSD X11, (R11)              // f2450f2b1b
	//TODO: MOVNTSS X2, (BX)                // f30f2b13
	//TODO: MOVNTSS X11, (BX)               // f3440f2b1b
	//TODO: MOVNTSS X2, (R11)               // f3410f2b13
	//TODO: MOVNTSS X11, (R11)              // f3450f2b1b
	//TODO: MOVQ M2, M2                     // 0f6fd2 or 0f7fd2
	//TODO: MOVQ M3, M2                     // 0f6fd3 or 0f7fda
	//TODO: MOVQ M2, M3                     // 0f6fda or 0f7fd3
	//TODO: MOVQ M3, M3                     // 0f6fdb or 0f7fdb
	MOVQ X2, X2                             // f30f7ed2 or 660fd6d2
	MOVQ X11, X2                            // f3410f7ed3 or 66440fd6da
	MOVQ X2, X11                            // f3440f7eda or 66410fd6d3
	MOVQ X11, X11                           // f3450f7edb or 66450fd6db
	MOVQOZX M2, X2                          // f30fd6d2
	MOVQOZX M3, X2                          // f30fd6d3
	MOVQOZX M2, X11                         // f3440fd6da
	MOVQOZX M3, X11                         // f3440fd6db
	MOVSB                                   // a4
	MOVSL                                   // a5
	//TODO: MOVSD (BX), X2                  // f20f1013
	//TODO: MOVSD (R11), X2                 // f2410f1013
	//TODO: MOVSD X2, X2                    // f20f10d2 or f20f11d2
	//TODO: MOVSD X11, X2                   // f2410f10d3 or f2440f11da
	//TODO: MOVSD (BX), X11                 // f2440f101b
	//TODO: MOVSD (R11), X11                // f2450f101b
	//TODO: MOVSD X2, X11                   // f2440f10da or f2410f11d3
	//TODO: MOVSD X11, X11                  // f2450f10db or f2450f11db
	//TODO: MOVSD X2, (BX)                  // f20f1113
	//TODO: MOVSD X11, (BX)                 // f2440f111b
	//TODO: MOVSD X2, (R11)                 // f2410f1113
	//TODO: MOVSD X11, (R11)                // f2450f111b
	//TODO: MOVSHDUP (BX), X2               // f30f1613
	//TODO: MOVSHDUP (R11), X2              // f3410f1613
	//TODO: MOVSHDUP X2, X2                 // f30f16d2
	//TODO: MOVSHDUP X11, X2                // f3410f16d3
	//TODO: MOVSHDUP (BX), X11              // f3440f161b
	//TODO: MOVSHDUP (R11), X11             // f3450f161b
	//TODO: MOVSHDUP X2, X11                // f3440f16da
	//TODO: MOVSHDUP X11, X11               // f3450f16db
	//TODO: MOVSLDUP (BX), X2               // f30f1213
	//TODO: MOVSLDUP (R11), X2              // f3410f1213
	//TODO: MOVSLDUP X2, X2                 // f30f12d2
	//TODO: MOVSLDUP X11, X2                // f3410f12d3
	//TODO: MOVSLDUP (BX), X11              // f3440f121b
	//TODO: MOVSLDUP (R11), X11             // f3450f121b
	//TODO: MOVSLDUP X2, X11                // f3440f12da
	//TODO: MOVSLDUP X11, X11               // f3450f12db
	MOVSQ                                   // 48a5
	MOVSS (BX), X2                          // f30f1013
	MOVSS (R11), X2                         // f3410f1013
	MOVSS X2, X2                            // f30f10d2 or f30f11d2
	MOVSS X11, X2                           // f3410f10d3 or f3440f11da
	MOVSS (BX), X11                         // f3440f101b
	MOVSS (R11), X11                        // f3450f101b
	MOVSS X2, X11                           // f3440f10da or f3410f11d3
	MOVSS X11, X11                          // f3450f10db or f3450f11db
	MOVSS X2, (BX)                          // f30f1113
	MOVSS X11, (BX)                         // f3440f111b
	MOVSS X2, (R11)                         // f3410f1113
	MOVSS X11, (R11)                        // f3450f111b
	MOVSW                                   // 66a5
	//TODO: MOVSWW (BX), DX                 // 660fbf13
	//TODO: MOVSWW (R11), DX                // 66410fbf13
	//TODO: MOVSWW DX, DX                   // 660fbfd2
	//TODO: MOVSWW R11, DX                  // 66410fbfd3
	//TODO: MOVSWW (BX), R11                // 66440fbf1b
	//TODO: MOVSWW (R11), R11               // 66450fbf1b
	//TODO: MOVSWW DX, R11                  // 66440fbfda
	//TODO: MOVSWW R11, R11                 // 66450fbfdb
	MOVBWSX (BX), DX                        // 660fbe13
	MOVBWSX (R11), DX                       // 66410fbe13
	MOVBWSX DL, DX                          // 660fbed2
	MOVBWSX R11, DX                         // 66410fbed3
	MOVBWSX (BX), R11                       // 66440fbe1b
	MOVBWSX (R11), R11                      // 66450fbe1b
	MOVBWSX DL, R11                         // 66440fbeda
	MOVBWSX R11, R11                        // 66450fbedb
	MOVWLSX (BX), DX                        // 0fbf13
	MOVWLSX (R11), DX                       // 410fbf13
	MOVWLSX DX, DX                          // 0fbfd2
	MOVWLSX R11, DX                         // 410fbfd3
	MOVWLSX (BX), R11                       // 440fbf1b
	MOVWLSX (R11), R11                      // 450fbf1b
	MOVWLSX DX, R11                         // 440fbfda
	MOVWLSX R11, R11                        // 450fbfdb
	MOVBLSX (BX), DX                        // 0fbe13
	MOVBLSX (R11), DX                       // 410fbe13
	MOVBLSX DL, DX                          // 0fbed2
	MOVBLSX R11, DX                         // 410fbed3
	MOVBLSX (BX), R11                       // 440fbe1b
	MOVBLSX (R11), R11                      // 450fbe1b
	MOVBLSX DL, R11                         // 440fbeda
	MOVBLSX R11, R11                        // 450fbedb
	MOVWQSX (BX), DX                        // 480fbf13 or 666313
	MOVWQSX (R11), DX                       // 490fbf13 or 66416313
	MOVWQSX DX, DX                          // 480fbfd2 or 6663d2
	MOVWQSX R11, DX                         // 490fbfd3 or 664163d3
	MOVWQSX (BX), R11                       // 4c0fbf1b or 6644631b
	MOVWQSX (R11), R11                      // 4d0fbf1b or 6645631b
	MOVWQSX DX, R11                         // 4c0fbfda or 664463da
	MOVWQSX R11, R11                        // 4d0fbfdb or 664563db
	MOVBQSX (BX), DX                        // 480fbe13
	MOVBQSX (R11), DX                       // 490fbe13
	MOVBQSX DL, DX                          // 480fbed2
	MOVBQSX R11, DX                         // 490fbed3
	MOVBQSX (BX), R11                       // 4c0fbe1b
	MOVBQSX (R11), R11                      // 4d0fbe1b
	MOVBQSX DL, R11                         // 4c0fbeda
	MOVBQSX R11, R11                        // 4d0fbedb
	MOVLQSX (BX), DX                        // 6313 or 486313
	MOVLQSX (R11), DX                       // 416313 or 496313
	MOVLQSX DX, DX                          // 63d2 or 4863d2
	MOVLQSX R11, DX                         // 4163d3 or 4963d3
	MOVLQSX (BX), R11                       // 44631b or 4c631b
	MOVLQSX (R11), R11                      // 45631b or 4d631b
	MOVLQSX DX, R11                         // 4463da or 4c63da
	MOVLQSX R11, R11                        // 4563db or 4d63db
	MOVUPD (BX), X2                         // 660f1013
	MOVUPD (R11), X2                        // 66410f1013
	MOVUPD X2, X2                           // 660f10d2 or 660f11d2
	MOVUPD X11, X2                          // 66410f10d3 or 66440f11da
	MOVUPD (BX), X11                        // 66440f101b
	MOVUPD (R11), X11                       // 66450f101b
	MOVUPD X2, X11                          // 66440f10da or 66410f11d3
	MOVUPD X11, X11                         // 66450f10db or 66450f11db
	MOVUPD X2, (BX)                         // 660f1113
	MOVUPD X11, (BX)                        // 66440f111b
	MOVUPD X2, (R11)                        // 66410f1113
	MOVUPD X11, (R11)                       // 66450f111b
	MOVUPS (BX), X2                         // 0f1013
	MOVUPS (R11), X2                        // 410f1013
	MOVUPS X2, X2                           // 0f10d2 or 0f11d2
	MOVUPS X11, X2                          // 410f10d3 or 440f11da
	MOVUPS (BX), X11                        // 440f101b
	MOVUPS (R11), X11                       // 450f101b
	MOVUPS X2, X11                          // 440f10da or 410f11d3
	MOVUPS X11, X11                         // 450f10db or 450f11db
	MOVUPS X2, (BX)                         // 0f1113
	MOVUPS X11, (BX)                        // 440f111b
	MOVUPS X2, (R11)                        // 410f1113
	MOVUPS X11, (R11)                       // 450f111b
	//TODO: MOVZWW (BX), DX                 // 660fb713
	//TODO: MOVZWW (R11), DX                // 66410fb713
	//TODO: MOVZWW DX, DX                   // 660fb7d2
	//TODO: MOVZWW R11, DX                  // 66410fb7d3
	//TODO: MOVZWW (BX), R11                // 66440fb71b
	//TODO: MOVZWW (R11), R11               // 66450fb71b
	//TODO: MOVZWW DX, R11                  // 66440fb7da
	//TODO: MOVZWW R11, R11                 // 66450fb7db
	MOVBWZX (BX), DX                        // 660fb613
	MOVBWZX (R11), DX                       // 66410fb613
	MOVBWZX DL, DX                          // 660fb6d2
	MOVBWZX R11, DX                         // 66410fb6d3
	MOVBWZX (BX), R11                       // 66440fb61b
	MOVBWZX (R11), R11                      // 66450fb61b
	MOVBWZX DL, R11                         // 66440fb6da
	MOVBWZX R11, R11                        // 66450fb6db
	MOVWLZX (BX), DX                        // 0fb713
	MOVWLZX (R11), DX                       // 410fb713
	MOVWLZX DX, DX                          // 0fb7d2
	MOVWLZX R11, DX                         // 410fb7d3
	MOVWLZX (BX), R11                       // 440fb71b
	MOVWLZX (R11), R11                      // 450fb71b
	MOVWLZX DX, R11                         // 440fb7da
	MOVWLZX R11, R11                        // 450fb7db
	MOVBLZX (BX), DX                        // 0fb613
	MOVBLZX (R11), DX                       // 410fb613
	MOVBLZX DL, DX                          // 0fb6d2
	MOVBLZX R11, DX                         // 410fb6d3
	MOVBLZX (BX), R11                       // 440fb61b
	MOVBLZX (R11), R11                      // 450fb61b
	MOVBLZX DL, R11                         // 440fb6da
	MOVBLZX R11, R11                        // 450fb6db
	MOVWQZX (BX), DX                        // 480fb713
	MOVWQZX (R11), DX                       // 490fb713
	MOVWQZX DX, DX                          // 480fb7d2
	MOVWQZX R11, DX                         // 490fb7d3
	MOVWQZX (BX), R11                       // 4c0fb71b
	MOVWQZX (R11), R11                      // 4d0fb71b
	MOVWQZX DX, R11                         // 4c0fb7da
	MOVWQZX R11, R11                        // 4d0fb7db
	//TODO: MOVBQZX (BX), DX                // 480fb613
	//TODO: MOVBQZX (R11), DX               // 490fb613
	//TODO: MOVBQZX DL, DX                  // 480fb6d2
	//TODO: MOVBQZX R11, DX                 // 490fb6d3
	//TODO: MOVBQZX (BX), R11               // 4c0fb61b
	//TODO: MOVBQZX (R11), R11              // 4d0fb61b
	//TODO: MOVBQZX DL, R11                 // 4c0fb6da
	//TODO: MOVBQZX R11, R11                // 4d0fb6db
	//TODO: MPSADBW $7, (BX), X2            // 660f3a421307
	//TODO: MPSADBW $7, (R11), X2           // 66410f3a421307
	//TODO: MPSADBW $7, X2, X2              // 660f3a42d207
	//TODO: MPSADBW $7, X11, X2             // 66410f3a42d307
	//TODO: MPSADBW $7, (BX), X11           // 66440f3a421b07
	//TODO: MPSADBW $7, (R11), X11          // 66450f3a421b07
	//TODO: MPSADBW $7, X2, X11             // 66440f3a42da07
	//TODO: MPSADBW $7, X11, X11            // 66450f3a42db07
	MULW (BX)                               // 66f723
	MULW (R11)                              // 6641f723
	MULW DX                                 // 66f7e2
	MULW R11                                // 6641f7e3
	MULL (BX)                               // f723
	MULL (R11)                              // 41f723
	MULL DX                                 // f7e2
	MULL R11                                // 41f7e3
	MULQ (BX)                               // 48f723
	MULQ (R11)                              // 49f723
	MULQ DX                                 // 48f7e2
	MULQ R11                                // 49f7e3
	MULB (BX)                               // f623
	MULB (R11)                              // 41f623
	MULB DL                                 // f6e2
	MULB R11                                // 41f6e3
	MULPD (BX), X2                          // 660f5913
	MULPD (R11), X2                         // 66410f5913
	MULPD X2, X2                            // 660f59d2
	MULPD X11, X2                           // 66410f59d3
	MULPD (BX), X11                         // 66440f591b
	MULPD (R11), X11                        // 66450f591b
	MULPD X2, X11                           // 66440f59da
	MULPD X11, X11                          // 66450f59db
	MULPS (BX), X2                          // 0f5913
	MULPS (R11), X2                         // 410f5913
	MULPS X2, X2                            // 0f59d2
	MULPS X11, X2                           // 410f59d3
	MULPS (BX), X11                         // 440f591b
	MULPS (R11), X11                        // 450f591b
	MULPS X2, X11                           // 440f59da
	MULPS X11, X11                          // 450f59db
	MULSD (BX), X2                          // f20f5913
	MULSD (R11), X2                         // f2410f5913
	MULSD X2, X2                            // f20f59d2
	MULSD X11, X2                           // f2410f59d3
	MULSD (BX), X11                         // f2440f591b
	MULSD (R11), X11                        // f2450f591b
	MULSD X2, X11                           // f2440f59da
	MULSD X11, X11                          // f2450f59db
	MULSS (BX), X2                          // f30f5913
	MULSS (R11), X2                         // f3410f5913
	MULSS X2, X2                            // f30f59d2
	MULSS X11, X2                           // f3410f59d3
	MULSS (BX), X11                         // f3440f591b
	MULSS (R11), X11                        // f3450f591b
	MULSS X2, X11                           // f3440f59da
	MULSS X11, X11                          // f3450f59db
	MULXL (BX), R9, DX                      // c4e233f613
	MULXL (R11), R9, DX                     // c4c233f613
	MULXL DX, R9, DX                        // c4e233f6d2
	MULXL R11, R9, DX                       // c4c233f6d3
	MULXL (BX), R9, R11                     // c46233f61b
	MULXL (R11), R9, R11                    // c44233f61b
	MULXL DX, R9, R11                       // c46233f6da
	MULXL R11, R9, R11                      // c44233f6db
	MULXQ (BX), R14, DX                     // c4e28bf613
	MULXQ (R11), R14, DX                    // c4c28bf613
	MULXQ DX, R14, DX                       // c4e28bf6d2
	MULXQ R11, R14, DX                      // c4c28bf6d3
	MULXQ (BX), R14, R11                    // c4628bf61b
	MULXQ (R11), R14, R11                   // c4428bf61b
	MULXQ DX, R14, R11                      // c4628bf6da
	MULXQ R11, R14, R11                     // c4428bf6db
	//TODO: MWAIT                           // 0f01c9
	NEGW (BX)                               // 66f71b
	NEGW (R11)                              // 6641f71b
	NEGW DX                                 // 66f7da
	NEGW R11                                // 6641f7db
	NEGL (BX)                               // f71b
	NEGL (R11)                              // 41f71b
	NEGL DX                                 // f7da
	NEGL R11                                // 41f7db
	NEGQ (BX)                               // 48f71b
	NEGQ (R11)                              // 49f71b
	NEGQ DX                                 // 48f7da
	NEGQ R11                                // 49f7db
	NEGB (BX)                               // f61b
	NEGB (R11)                              // 41f61b
	NEGB DL                                 // f6da
	NEGB R11                                // 41f6db
	//TODO: NOPW (BX)                       // 660f1f03
	//TODO: NOPW (R11)                      // 66410f1f03
	//TODO: NOPW DX                         // 660f1fc2
	//TODO: NOPW R11                        // 66410f1fc3
	//TODO: NOPL (BX)                       // 0f1f03
	//TODO: NOPL (R11)                      // 410f1f03
	//TODO: NOPL DX                         // 0f1fc2
	//TODO: NOPL R11                        // 410f1fc3
	NOTW (BX)                               // 66f713
	NOTW (R11)                              // 6641f713
	NOTW DX                                 // 66f7d2
	NOTW R11                                // 6641f7d3
	NOTL (BX)                               // f713
	NOTL (R11)                              // 41f713
	NOTL DX                                 // f7d2
	NOTL R11                                // 41f7d3
	NOTQ (BX)                               // 48f713
	NOTQ (R11)                              // 49f713
	NOTQ DX                                 // 48f7d2
	NOTQ R11                                // 49f7d3
	NOTB (BX)                               // f613
	NOTB (R11)                              // 41f613
	NOTB DL                                 // f6d2
	NOTB R11                                // 41f6d3
	ORB $7, AL                              // 0c07
	ORW $61731, AX                          // 660d23f1
	ORL $4045620583, AX                     // 0d674523f1
	ORQ $-249346713, AX                     // 480d674523f1
	ORW $61731, (BX)                        // 66810b23f1
	ORW $61731, (R11)                       // 6641810b23f1
	ORW $61731, DX                          // 6681ca23f1
	ORW $61731, R11                         // 664181cb23f1
	ORW $7, (BX)                            // 66830b07
	ORW $7, (R11)                           // 6641830b07
	ORW $7, DX                              // 6683ca07
	ORW $7, R11                             // 664183cb07
	ORW DX, (BX)                            // 660913
	ORW R11, (BX)                           // 6644091b
	ORW DX, (R11)                           // 66410913
	ORW R11, (R11)                          // 6645091b
	ORW DX, DX                              // 6609d2 or 660bd2
	ORW R11, DX                             // 664409da or 66410bd3
	ORW DX, R11                             // 664109d3 or 66440bda
	ORW R11, R11                            // 664509db or 66450bdb
	ORL $4045620583, (BX)                   // 810b674523f1
	ORL $4045620583, (R11)                  // 41810b674523f1
	ORL $4045620583, DX                     // 81ca674523f1
	ORL $4045620583, R11                    // 4181cb674523f1
	ORL $7, (BX)                            // 830b07
	ORL $7, (R11)                           // 41830b07
	ORL $7, DX                              // 83ca07
	ORL $7, R11                             // 4183cb07
	ORL DX, (BX)                            // 0913
	ORL R11, (BX)                           // 44091b
	ORL DX, (R11)                           // 410913
	ORL R11, (R11)                          // 45091b
	ORL DX, DX                              // 09d2 or 0bd2
	ORL R11, DX                             // 4409da or 410bd3
	ORL DX, R11                             // 4109d3 or 440bda
	ORL R11, R11                            // 4509db or 450bdb
	ORQ $-249346713, (BX)                   // 48810b674523f1
	ORQ $-249346713, (R11)                  // 49810b674523f1
	ORQ $-249346713, DX                     // 4881ca674523f1
	ORQ $-249346713, R11                    // 4981cb674523f1
	ORQ $7, (BX)                            // 48830b07
	ORQ $7, (R11)                           // 49830b07
	ORQ $7, DX                              // 4883ca07
	ORQ $7, R11                             // 4983cb07
	ORQ DX, (BX)                            // 480913
	ORQ R11, (BX)                           // 4c091b
	ORQ DX, (R11)                           // 490913
	ORQ R11, (R11)                          // 4d091b
	ORQ DX, DX                              // 4809d2 or 480bd2
	ORQ R11, DX                             // 4c09da or 490bd3
	ORQ DX, R11                             // 4909d3 or 4c0bda
	ORQ R11, R11                            // 4d09db or 4d0bdb
	ORB $7, (BX)                            // 800b07
	ORB $7, (R11)                           // 41800b07
	ORB $7, DL                              // 80ca07
	ORB $7, R11                             // 4180cb07
	ORB DL, (BX)                            // 0813
	ORB R11, (BX)                           // 44081b
	ORB DL, (R11)                           // 410813
	ORB R11, (R11)                          // 45081b
	ORB DL, DL                              // 08d2 or 0ad2
	ORB R11, DL                             // 4408da or 410ad3
	ORB DL, R11                             // 4108d3 or 440ada
	ORB R11, R11                            // 4508db or 450adb
	ORW (BX), DX                            // 660b13
	ORW (R11), DX                           // 66410b13
	ORW (BX), R11                           // 66440b1b
	ORW (R11), R11                          // 66450b1b
	ORL (BX), DX                            // 0b13
	ORL (R11), DX                           // 410b13
	ORL (BX), R11                           // 440b1b
	ORL (R11), R11                          // 450b1b
	ORQ (BX), DX                            // 480b13
	ORQ (R11), DX                           // 490b13
	ORQ (BX), R11                           // 4c0b1b
	ORQ (R11), R11                          // 4d0b1b
	ORB (BX), DL                            // 0a13
	ORB (R11), DL                           // 410a13
	ORB (BX), R11                           // 440a1b
	ORB (R11), R11                          // 450a1b
	ORPD (BX), X2                           // 660f5613
	ORPD (R11), X2                          // 66410f5613
	ORPD X2, X2                             // 660f56d2
	ORPD X11, X2                            // 66410f56d3
	ORPD (BX), X11                          // 66440f561b
	ORPD (R11), X11                         // 66450f561b
	ORPD X2, X11                            // 66440f56da
	ORPD X11, X11                           // 66450f56db
	ORPS (BX), X2                           // 0f5613
	ORPS (R11), X2                          // 410f5613
	ORPS X2, X2                             // 0f56d2
	ORPS X11, X2                            // 410f56d3
	ORPS (BX), X11                          // 440f561b
	ORPS (R11), X11                         // 450f561b
	ORPS X2, X11                            // 440f56da
	ORPS X11, X11                           // 450f56db
	//TODO: OUTB AL, DX                     // ee
	//TODO: OUTW AX, DX                     // 66ef
	//TODO: OUTL AX, DX                     // ef
	//TODO: OUTB AL, $7                     // e607
	//TODO: OUTW AX, $7                     // 66e707
	//TODO: OUTL AX, $7                     // e707
	OUTSB                                   // 6e
	OUTSL                                   // 6f
	OUTSW                                   // 666f
	//TODO: PABSB (BX), M2                  // 0f381c13
	//TODO: PABSB (R11), M2                 // 410f381c13
	//TODO: PABSB M2, M2                    // 0f381cd2
	//TODO: PABSB M3, M2                    // 0f381cd3
	//TODO: PABSB (BX), M3                  // 0f381c1b
	//TODO: PABSB (R11), M3                 // 410f381c1b
	//TODO: PABSB M2, M3                    // 0f381cda
	//TODO: PABSB M3, M3                    // 0f381cdb
	//TODO: PABSB (BX), X2                  // 660f381c13
	//TODO: PABSB (R11), X2                 // 66410f381c13
	//TODO: PABSB X2, X2                    // 660f381cd2
	//TODO: PABSB X11, X2                   // 66410f381cd3
	//TODO: PABSB (BX), X11                 // 66440f381c1b
	//TODO: PABSB (R11), X11                // 66450f381c1b
	//TODO: PABSB X2, X11                   // 66440f381cda
	//TODO: PABSB X11, X11                  // 66450f381cdb
	//TODO: PABSD (BX), M2                  // 0f381e13
	//TODO: PABSD (R11), M2                 // 410f381e13
	//TODO: PABSD M2, M2                    // 0f381ed2
	//TODO: PABSD M3, M2                    // 0f381ed3
	//TODO: PABSD (BX), M3                  // 0f381e1b
	//TODO: PABSD (R11), M3                 // 410f381e1b
	//TODO: PABSD M2, M3                    // 0f381eda
	//TODO: PABSD M3, M3                    // 0f381edb
	//TODO: PABSD (BX), X2                  // 660f381e13
	//TODO: PABSD (R11), X2                 // 66410f381e13
	//TODO: PABSD X2, X2                    // 660f381ed2
	//TODO: PABSD X11, X2                   // 66410f381ed3
	//TODO: PABSD (BX), X11                 // 66440f381e1b
	//TODO: PABSD (R11), X11                // 66450f381e1b
	//TODO: PABSD X2, X11                   // 66440f381eda
	//TODO: PABSD X11, X11                  // 66450f381edb
	//TODO: PABSW (BX), M2                  // 0f381d13
	//TODO: PABSW (R11), M2                 // 410f381d13
	//TODO: PABSW M2, M2                    // 0f381dd2
	//TODO: PABSW M3, M2                    // 0f381dd3
	//TODO: PABSW (BX), M3                  // 0f381d1b
	//TODO: PABSW (R11), M3                 // 410f381d1b
	//TODO: PABSW M2, M3                    // 0f381dda
	//TODO: PABSW M3, M3                    // 0f381ddb
	//TODO: PABSW (BX), X2                  // 660f381d13
	//TODO: PABSW (R11), X2                 // 66410f381d13
	//TODO: PABSW X2, X2                    // 660f381dd2
	//TODO: PABSW X11, X2                   // 66410f381dd3
	//TODO: PABSW (BX), X11                 // 66440f381d1b
	//TODO: PABSW (R11), X11                // 66450f381d1b
	//TODO: PABSW X2, X11                   // 66440f381dda
	//TODO: PABSW X11, X11                  // 66450f381ddb
	PACKSSLW (BX), M2                       // 0f6b13
	PACKSSLW (R11), M2                      // 410f6b13
	PACKSSLW M2, M2                         // 0f6bd2
	PACKSSLW M3, M2                         // 0f6bd3
	PACKSSLW (BX), M3                       // 0f6b1b
	PACKSSLW (R11), M3                      // 410f6b1b
	PACKSSLW M2, M3                         // 0f6bda
	PACKSSLW M3, M3                         // 0f6bdb
	PACKSSLW (BX), X2                       // 660f6b13
	PACKSSLW (R11), X2                      // 66410f6b13
	PACKSSLW X2, X2                         // 660f6bd2
	PACKSSLW X11, X2                        // 66410f6bd3
	PACKSSLW (BX), X11                      // 66440f6b1b
	PACKSSLW (R11), X11                     // 66450f6b1b
	PACKSSLW X2, X11                        // 66440f6bda
	PACKSSLW X11, X11                       // 66450f6bdb
	PACKSSWB (BX), M2                       // 0f6313
	PACKSSWB (R11), M2                      // 410f6313
	PACKSSWB M2, M2                         // 0f63d2
	PACKSSWB M3, M2                         // 0f63d3
	PACKSSWB (BX), M3                       // 0f631b
	PACKSSWB (R11), M3                      // 410f631b
	PACKSSWB M2, M3                         // 0f63da
	PACKSSWB M3, M3                         // 0f63db
	PACKSSWB (BX), X2                       // 660f6313
	PACKSSWB (R11), X2                      // 66410f6313
	PACKSSWB X2, X2                         // 660f63d2
	PACKSSWB X11, X2                        // 66410f63d3
	PACKSSWB (BX), X11                      // 66440f631b
	PACKSSWB (R11), X11                     // 66450f631b
	PACKSSWB X2, X11                        // 66440f63da
	PACKSSWB X11, X11                       // 66450f63db
	//TODO: PACKUSDW (BX), X2               // 660f382b13
	//TODO: PACKUSDW (R11), X2              // 66410f382b13
	//TODO: PACKUSDW X2, X2                 // 660f382bd2
	//TODO: PACKUSDW X11, X2                // 66410f382bd3
	//TODO: PACKUSDW (BX), X11              // 66440f382b1b
	//TODO: PACKUSDW (R11), X11             // 66450f382b1b
	//TODO: PACKUSDW X2, X11                // 66440f382bda
	//TODO: PACKUSDW X11, X11               // 66450f382bdb
	PACKUSWB (BX), M2                       // 0f6713
	PACKUSWB (R11), M2                      // 410f6713
	PACKUSWB M2, M2                         // 0f67d2
	PACKUSWB M3, M2                         // 0f67d3
	PACKUSWB (BX), M3                       // 0f671b
	PACKUSWB (R11), M3                      // 410f671b
	PACKUSWB M2, M3                         // 0f67da
	PACKUSWB M3, M3                         // 0f67db
	PACKUSWB (BX), X2                       // 660f6713
	PACKUSWB (R11), X2                      // 66410f6713
	PACKUSWB X2, X2                         // 660f67d2
	PACKUSWB X11, X2                        // 66410f67d3
	PACKUSWB (BX), X11                      // 66440f671b
	PACKUSWB (R11), X11                     // 66450f671b
	PACKUSWB X2, X11                        // 66440f67da
	PACKUSWB X11, X11                       // 66450f67db
	PADDB (BX), M2                          // 0ffc13
	PADDB (R11), M2                         // 410ffc13
	PADDB M2, M2                            // 0ffcd2
	PADDB M3, M2                            // 0ffcd3
	PADDB (BX), M3                          // 0ffc1b
	PADDB (R11), M3                         // 410ffc1b
	PADDB M2, M3                            // 0ffcda
	PADDB M3, M3                            // 0ffcdb
	PADDB (BX), X2                          // 660ffc13
	PADDB (R11), X2                         // 66410ffc13
	PADDB X2, X2                            // 660ffcd2
	PADDB X11, X2                           // 66410ffcd3
	PADDB (BX), X11                         // 66440ffc1b
	PADDB (R11), X11                        // 66450ffc1b
	PADDB X2, X11                           // 66440ffcda
	PADDB X11, X11                          // 66450ffcdb
	PADDL (BX), M2                          // 0ffe13
	PADDL (R11), M2                         // 410ffe13
	PADDL M2, M2                            // 0ffed2
	PADDL M3, M2                            // 0ffed3
	PADDL (BX), M3                          // 0ffe1b
	PADDL (R11), M3                         // 410ffe1b
	PADDL M2, M3                            // 0ffeda
	PADDL M3, M3                            // 0ffedb
	PADDL (BX), X2                          // 660ffe13
	PADDL (R11), X2                         // 66410ffe13
	PADDL X2, X2                            // 660ffed2
	PADDL X11, X2                           // 66410ffed3
	PADDL (BX), X11                         // 66440ffe1b
	PADDL (R11), X11                        // 66450ffe1b
	PADDL X2, X11                           // 66440ffeda
	PADDL X11, X11                          // 66450ffedb
	//TODO: PADDQ (BX), M2                  // 0fd413
	//TODO: PADDQ (R11), M2                 // 410fd413
	//TODO: PADDQ M2, M2                    // 0fd4d2
	//TODO: PADDQ M3, M2                    // 0fd4d3
	//TODO: PADDQ (BX), M3                  // 0fd41b
	//TODO: PADDQ (R11), M3                 // 410fd41b
	//TODO: PADDQ M2, M3                    // 0fd4da
	//TODO: PADDQ M3, M3                    // 0fd4db
	PADDQ (BX), X2                          // 660fd413
	PADDQ (R11), X2                         // 66410fd413
	PADDQ X2, X2                            // 660fd4d2
	PADDQ X11, X2                           // 66410fd4d3
	PADDQ (BX), X11                         // 66440fd41b
	PADDQ (R11), X11                        // 66450fd41b
	PADDQ X2, X11                           // 66440fd4da
	PADDQ X11, X11                          // 66450fd4db
	PADDSB (BX), M2                         // 0fec13
	PADDSB (R11), M2                        // 410fec13
	PADDSB M2, M2                           // 0fecd2
	PADDSB M3, M2                           // 0fecd3
	PADDSB (BX), M3                         // 0fec1b
	PADDSB (R11), M3                        // 410fec1b
	PADDSB M2, M3                           // 0fecda
	PADDSB M3, M3                           // 0fecdb
	PADDSB (BX), X2                         // 660fec13
	PADDSB (R11), X2                        // 66410fec13
	PADDSB X2, X2                           // 660fecd2
	PADDSB X11, X2                          // 66410fecd3
	PADDSB (BX), X11                        // 66440fec1b
	PADDSB (R11), X11                       // 66450fec1b
	PADDSB X2, X11                          // 66440fecda
	PADDSB X11, X11                         // 66450fecdb
	PADDSW (BX), M2                         // 0fed13
	PADDSW (R11), M2                        // 410fed13
	PADDSW M2, M2                           // 0fedd2
	PADDSW M3, M2                           // 0fedd3
	PADDSW (BX), M3                         // 0fed1b
	PADDSW (R11), M3                        // 410fed1b
	PADDSW M2, M3                           // 0fedda
	PADDSW M3, M3                           // 0feddb
	PADDSW (BX), X2                         // 660fed13
	PADDSW (R11), X2                        // 66410fed13
	PADDSW X2, X2                           // 660fedd2
	PADDSW X11, X2                          // 66410fedd3
	PADDSW (BX), X11                        // 66440fed1b
	PADDSW (R11), X11                       // 66450fed1b
	PADDSW X2, X11                          // 66440fedda
	PADDSW X11, X11                         // 66450feddb
	PADDUSB (BX), M2                        // 0fdc13
	PADDUSB (R11), M2                       // 410fdc13
	PADDUSB M2, M2                          // 0fdcd2
	PADDUSB M3, M2                          // 0fdcd3
	PADDUSB (BX), M3                        // 0fdc1b
	PADDUSB (R11), M3                       // 410fdc1b
	PADDUSB M2, M3                          // 0fdcda
	PADDUSB M3, M3                          // 0fdcdb
	PADDUSB (BX), X2                        // 660fdc13
	PADDUSB (R11), X2                       // 66410fdc13
	PADDUSB X2, X2                          // 660fdcd2
	PADDUSB X11, X2                         // 66410fdcd3
	PADDUSB (BX), X11                       // 66440fdc1b
	PADDUSB (R11), X11                      // 66450fdc1b
	PADDUSB X2, X11                         // 66440fdcda
	PADDUSB X11, X11                        // 66450fdcdb
	PADDUSW (BX), M2                        // 0fdd13
	PADDUSW (R11), M2                       // 410fdd13
	PADDUSW M2, M2                          // 0fddd2
	PADDUSW M3, M2                          // 0fddd3
	PADDUSW (BX), M3                        // 0fdd1b
	PADDUSW (R11), M3                       // 410fdd1b
	PADDUSW M2, M3                          // 0fddda
	PADDUSW M3, M3                          // 0fdddb
	PADDUSW (BX), X2                        // 660fdd13
	PADDUSW (R11), X2                       // 66410fdd13
	PADDUSW X2, X2                          // 660fddd2
	PADDUSW X11, X2                         // 66410fddd3
	PADDUSW (BX), X11                       // 66440fdd1b
	PADDUSW (R11), X11                      // 66450fdd1b
	PADDUSW X2, X11                         // 66440fddda
	PADDUSW X11, X11                        // 66450fdddb
	PADDW (BX), M2                          // 0ffd13
	PADDW (R11), M2                         // 410ffd13
	PADDW M2, M2                            // 0ffdd2
	PADDW M3, M2                            // 0ffdd3
	PADDW (BX), M3                          // 0ffd1b
	PADDW (R11), M3                         // 410ffd1b
	PADDW M2, M3                            // 0ffdda
	PADDW M3, M3                            // 0ffddb
	PADDW (BX), X2                          // 660ffd13
	PADDW (R11), X2                         // 66410ffd13
	PADDW X2, X2                            // 660ffdd2
	PADDW X11, X2                           // 66410ffdd3
	PADDW (BX), X11                         // 66440ffd1b
	PADDW (R11), X11                        // 66450ffd1b
	PADDW X2, X11                           // 66440ffdda
	PADDW X11, X11                          // 66450ffddb
	//TODO: PALIGNR $7, (BX), M2            // 0f3a0f1307
	//TODO: PALIGNR $7, (R11), M2           // 410f3a0f1307
	//TODO: PALIGNR $7, M2, M2              // 0f3a0fd207
	//TODO: PALIGNR $7, M3, M2              // 0f3a0fd307
	//TODO: PALIGNR $7, (BX), M3            // 0f3a0f1b07
	//TODO: PALIGNR $7, (R11), M3           // 410f3a0f1b07
	//TODO: PALIGNR $7, M2, M3              // 0f3a0fda07
	//TODO: PALIGNR $7, M3, M3              // 0f3a0fdb07
	//TODO: PALIGNR $7, (BX), X2            // 660f3a0f1307
	//TODO: PALIGNR $7, (R11), X2           // 66410f3a0f1307
	//TODO: PALIGNR $7, X2, X2              // 660f3a0fd207
	//TODO: PALIGNR $7, X11, X2             // 66410f3a0fd307
	//TODO: PALIGNR $7, (BX), X11           // 66440f3a0f1b07
	//TODO: PALIGNR $7, (R11), X11          // 66450f3a0f1b07
	//TODO: PALIGNR $7, X2, X11             // 66440f3a0fda07
	//TODO: PALIGNR $7, X11, X11            // 66450f3a0fdb07
	PAND (BX), M2                           // 0fdb13
	PAND (R11), M2                          // 410fdb13
	PAND M2, M2                             // 0fdbd2
	PAND M3, M2                             // 0fdbd3
	PAND (BX), M3                           // 0fdb1b
	PAND (R11), M3                          // 410fdb1b
	PAND M2, M3                             // 0fdbda
	PAND M3, M3                             // 0fdbdb
	PAND (BX), X2                           // 660fdb13
	PAND (R11), X2                          // 66410fdb13
	PAND X2, X2                             // 660fdbd2
	PAND X11, X2                            // 66410fdbd3
	PAND (BX), X11                          // 66440fdb1b
	PAND (R11), X11                         // 66450fdb1b
	PAND X2, X11                            // 66440fdbda
	PAND X11, X11                           // 66450fdbdb
	PANDN (BX), M2                          // 0fdf13
	PANDN (R11), M2                         // 410fdf13
	PANDN M2, M2                            // 0fdfd2
	PANDN M3, M2                            // 0fdfd3
	PANDN (BX), M3                          // 0fdf1b
	PANDN (R11), M3                         // 410fdf1b
	PANDN M2, M3                            // 0fdfda
	PANDN M3, M3                            // 0fdfdb
	PANDN (BX), X2                          // 660fdf13
	PANDN (R11), X2                         // 66410fdf13
	PANDN X2, X2                            // 660fdfd2
	PANDN X11, X2                           // 66410fdfd3
	PANDN (BX), X11                         // 66440fdf1b
	PANDN (R11), X11                        // 66450fdf1b
	PANDN X2, X11                           // 66440fdfda
	PANDN X11, X11                          // 66450fdfdb
	PAVGB (BX), M2                          // 0fe013
	PAVGB (R11), M2                         // 410fe013
	PAVGB M2, M2                            // 0fe0d2
	PAVGB M3, M2                            // 0fe0d3
	PAVGB (BX), M3                          // 0fe01b
	PAVGB (R11), M3                         // 410fe01b
	PAVGB M2, M3                            // 0fe0da
	PAVGB M3, M3                            // 0fe0db
	PAVGB (BX), X2                          // 660fe013
	PAVGB (R11), X2                         // 66410fe013
	PAVGB X2, X2                            // 660fe0d2
	PAVGB X11, X2                           // 66410fe0d3
	PAVGB (BX), X11                         // 66440fe01b
	PAVGB (R11), X11                        // 66450fe01b
	PAVGB X2, X11                           // 66440fe0da
	PAVGB X11, X11                          // 66450fe0db
	PAVGW (BX), M2                          // 0fe313
	PAVGW (R11), M2                         // 410fe313
	PAVGW M2, M2                            // 0fe3d2
	PAVGW M3, M2                            // 0fe3d3
	PAVGW (BX), M3                          // 0fe31b
	PAVGW (R11), M3                         // 410fe31b
	PAVGW M2, M3                            // 0fe3da
	PAVGW M3, M3                            // 0fe3db
	PAVGW (BX), X2                          // 660fe313
	PAVGW (R11), X2                         // 66410fe313
	PAVGW X2, X2                            // 660fe3d2
	PAVGW X11, X2                           // 66410fe3d3
	PAVGW (BX), X11                         // 66440fe31b
	PAVGW (R11), X11                        // 66450fe31b
	PAVGW X2, X11                           // 66440fe3da
	PAVGW X11, X11                          // 66450fe3db
	//TODO: PBLENDVB XMM0, (BX), X2         // 660f381013
	//TODO: PBLENDVB XMM0, (R11), X2        // 66410f381013
	//TODO: PBLENDVB XMM0, X2, X2           // 660f3810d2
	//TODO: PBLENDVB XMM0, X11, X2          // 66410f3810d3
	//TODO: PBLENDVB XMM0, (BX), X11        // 66440f38101b
	//TODO: PBLENDVB XMM0, (R11), X11       // 66450f38101b
	//TODO: PBLENDVB XMM0, X2, X11          // 66440f3810da
	//TODO: PBLENDVB XMM0, X11, X11         // 66450f3810db
	//TODO: PBLENDW $7, (BX), X2            // 660f3a0e1307
	//TODO: PBLENDW $7, (R11), X2           // 66410f3a0e1307
	//TODO: PBLENDW $7, X2, X2              // 660f3a0ed207
	//TODO: PBLENDW $7, X11, X2             // 66410f3a0ed307
	//TODO: PBLENDW $7, (BX), X11           // 66440f3a0e1b07
	//TODO: PBLENDW $7, (R11), X11          // 66450f3a0e1b07
	//TODO: PBLENDW $7, X2, X11             // 66440f3a0eda07
	//TODO: PBLENDW $7, X11, X11            // 66450f3a0edb07
	PCLMULQDQ $7, (BX), X2                  // 660f3a441307
	PCLMULQDQ $7, (R11), X2                 // 66410f3a441307
	PCLMULQDQ $7, X2, X2                    // 660f3a44d207
	PCLMULQDQ $7, X11, X2                   // 66410f3a44d307
	PCLMULQDQ $7, (BX), X11                 // 66440f3a441b07
	PCLMULQDQ $7, (R11), X11                // 66450f3a441b07
	PCLMULQDQ $7, X2, X11                   // 66440f3a44da07
	PCLMULQDQ $7, X11, X11                  // 66450f3a44db07
	PCMPEQB (BX), M2                        // 0f7413
	PCMPEQB (R11), M2                       // 410f7413
	PCMPEQB M2, M2                          // 0f74d2
	PCMPEQB M3, M2                          // 0f74d3
	PCMPEQB (BX), M3                        // 0f741b
	PCMPEQB (R11), M3                       // 410f741b
	PCMPEQB M2, M3                          // 0f74da
	PCMPEQB M3, M3                          // 0f74db
	PCMPEQB (BX), X2                        // 660f7413
	PCMPEQB (R11), X2                       // 66410f7413
	PCMPEQB X2, X2                          // 660f74d2
	PCMPEQB X11, X2                         // 66410f74d3
	PCMPEQB (BX), X11                       // 66440f741b
	PCMPEQB (R11), X11                      // 66450f741b
	PCMPEQB X2, X11                         // 66440f74da
	PCMPEQB X11, X11                        // 66450f74db
	PCMPEQL (BX), M2                        // 0f7613
	PCMPEQL (R11), M2                       // 410f7613
	PCMPEQL M2, M2                          // 0f76d2
	PCMPEQL M3, M2                          // 0f76d3
	PCMPEQL (BX), M3                        // 0f761b
	PCMPEQL (R11), M3                       // 410f761b
	PCMPEQL M2, M3                          // 0f76da
	PCMPEQL M3, M3                          // 0f76db
	PCMPEQL (BX), X2                        // 660f7613
	PCMPEQL (R11), X2                       // 66410f7613
	PCMPEQL X2, X2                          // 660f76d2
	PCMPEQL X11, X2                         // 66410f76d3
	PCMPEQL (BX), X11                       // 66440f761b
	PCMPEQL (R11), X11                      // 66450f761b
	PCMPEQL X2, X11                         // 66440f76da
	PCMPEQL X11, X11                        // 66450f76db
	//TODO: PCMPEQQ (BX), X2                // 660f382913
	//TODO: PCMPEQQ (R11), X2               // 66410f382913
	//TODO: PCMPEQQ X2, X2                  // 660f3829d2
	//TODO: PCMPEQQ X11, X2                 // 66410f3829d3
	//TODO: PCMPEQQ (BX), X11               // 66440f38291b
	//TODO: PCMPEQQ (R11), X11              // 66450f38291b
	//TODO: PCMPEQQ X2, X11                 // 66440f3829da
	//TODO: PCMPEQQ X11, X11                // 66450f3829db
	PCMPEQW (BX), M2                        // 0f7513
	PCMPEQW (R11), M2                       // 410f7513
	PCMPEQW M2, M2                          // 0f75d2
	PCMPEQW M3, M2                          // 0f75d3
	PCMPEQW (BX), M3                        // 0f751b
	PCMPEQW (R11), M3                       // 410f751b
	PCMPEQW M2, M3                          // 0f75da
	PCMPEQW M3, M3                          // 0f75db
	PCMPEQW (BX), X2                        // 660f7513
	PCMPEQW (R11), X2                       // 66410f7513
	PCMPEQW X2, X2                          // 660f75d2
	PCMPEQW X11, X2                         // 66410f75d3
	PCMPEQW (BX), X11                       // 66440f751b
	PCMPEQW (R11), X11                      // 66450f751b
	PCMPEQW X2, X11                         // 66440f75da
	PCMPEQW X11, X11                        // 66450f75db
	//TODO: PCMPESTRI $7, (BX), X2          // 660f3a611307
	//TODO: PCMPESTRI $7, (R11), X2         // 66410f3a611307
	//TODO: PCMPESTRI $7, X2, X2            // 660f3a61d207
	//TODO: PCMPESTRI $7, X11, X2           // 66410f3a61d307
	//TODO: PCMPESTRI $7, (BX), X11         // 66440f3a611b07
	//TODO: PCMPESTRI $7, (R11), X11        // 66450f3a611b07
	//TODO: PCMPESTRI $7, X2, X11           // 66440f3a61da07
	//TODO: PCMPESTRI $7, X11, X11          // 66450f3a61db07
	//TODO: PCMPESTRM $7, (BX), X2          // 660f3a601307
	//TODO: PCMPESTRM $7, (R11), X2         // 66410f3a601307
	//TODO: PCMPESTRM $7, X2, X2            // 660f3a60d207
	//TODO: PCMPESTRM $7, X11, X2           // 66410f3a60d307
	//TODO: PCMPESTRM $7, (BX), X11         // 66440f3a601b07
	//TODO: PCMPESTRM $7, (R11), X11        // 66450f3a601b07
	//TODO: PCMPESTRM $7, X2, X11           // 66440f3a60da07
	//TODO: PCMPESTRM $7, X11, X11          // 66450f3a60db07
	PCMPGTB (BX), M2                        // 0f6413
	PCMPGTB (R11), M2                       // 410f6413
	PCMPGTB M2, M2                          // 0f64d2
	PCMPGTB M3, M2                          // 0f64d3
	PCMPGTB (BX), M3                        // 0f641b
	PCMPGTB (R11), M3                       // 410f641b
	PCMPGTB M2, M3                          // 0f64da
	PCMPGTB M3, M3                          // 0f64db
	PCMPGTB (BX), X2                        // 660f6413
	PCMPGTB (R11), X2                       // 66410f6413
	PCMPGTB X2, X2                          // 660f64d2
	PCMPGTB X11, X2                         // 66410f64d3
	PCMPGTB (BX), X11                       // 66440f641b
	PCMPGTB (R11), X11                      // 66450f641b
	PCMPGTB X2, X11                         // 66440f64da
	PCMPGTB X11, X11                        // 66450f64db
	PCMPGTL (BX), M2                        // 0f6613
	PCMPGTL (R11), M2                       // 410f6613
	PCMPGTL M2, M2                          // 0f66d2
	PCMPGTL M3, M2                          // 0f66d3
	PCMPGTL (BX), M3                        // 0f661b
	PCMPGTL (R11), M3                       // 410f661b
	PCMPGTL M2, M3                          // 0f66da
	PCMPGTL M3, M3                          // 0f66db
	PCMPGTL (BX), X2                        // 660f6613
	PCMPGTL (R11), X2                       // 66410f6613
	PCMPGTL X2, X2                          // 660f66d2
	PCMPGTL X11, X2                         // 66410f66d3
	PCMPGTL (BX), X11                       // 66440f661b
	PCMPGTL (R11), X11                      // 66450f661b
	PCMPGTL X2, X11                         // 66440f66da
	PCMPGTL X11, X11                        // 66450f66db
	//TODO: PCMPGTQ (BX), X2                // 660f383713
	//TODO: PCMPGTQ (R11), X2               // 66410f383713
	//TODO: PCMPGTQ X2, X2                  // 660f3837d2
	//TODO: PCMPGTQ X11, X2                 // 66410f3837d3
	//TODO: PCMPGTQ (BX), X11               // 66440f38371b
	//TODO: PCMPGTQ (R11), X11              // 66450f38371b
	//TODO: PCMPGTQ X2, X11                 // 66440f3837da
	//TODO: PCMPGTQ X11, X11                // 66450f3837db
	PCMPGTW (BX), M2                        // 0f6513
	PCMPGTW (R11), M2                       // 410f6513
	PCMPGTW M2, M2                          // 0f65d2
	PCMPGTW M3, M2                          // 0f65d3
	PCMPGTW (BX), M3                        // 0f651b
	PCMPGTW (R11), M3                       // 410f651b
	PCMPGTW M2, M3                          // 0f65da
	PCMPGTW M3, M3                          // 0f65db
	PCMPGTW (BX), X2                        // 660f6513
	PCMPGTW (R11), X2                       // 66410f6513
	PCMPGTW X2, X2                          // 660f65d2
	PCMPGTW X11, X2                         // 66410f65d3
	PCMPGTW (BX), X11                       // 66440f651b
	PCMPGTW (R11), X11                      // 66450f651b
	PCMPGTW X2, X11                         // 66440f65da
	PCMPGTW X11, X11                        // 66450f65db
	//TODO: PCMPISTRI $7, (BX), X2          // 660f3a631307
	//TODO: PCMPISTRI $7, (R11), X2         // 66410f3a631307
	//TODO: PCMPISTRI $7, X2, X2            // 660f3a63d207
	//TODO: PCMPISTRI $7, X11, X2           // 66410f3a63d307
	//TODO: PCMPISTRI $7, (BX), X11         // 66440f3a631b07
	//TODO: PCMPISTRI $7, (R11), X11        // 66450f3a631b07
	//TODO: PCMPISTRI $7, X2, X11           // 66440f3a63da07
	//TODO: PCMPISTRI $7, X11, X11          // 66450f3a63db07
	//TODO: PCMPISTRM $7, (BX), X2          // 660f3a621307
	//TODO: PCMPISTRM $7, (R11), X2         // 66410f3a621307
	//TODO: PCMPISTRM $7, X2, X2            // 660f3a62d207
	//TODO: PCMPISTRM $7, X11, X2           // 66410f3a62d307
	//TODO: PCMPISTRM $7, (BX), X11         // 66440f3a621b07
	//TODO: PCMPISTRM $7, (R11), X11        // 66450f3a621b07
	//TODO: PCMPISTRM $7, X2, X11           // 66440f3a62da07
	//TODO: PCMPISTRM $7, X11, X11          // 66450f3a62db07
	PDEPL (BX), R9, DX                      // c4e233f513
	PDEPL (R11), R9, DX                     // c4c233f513
	PDEPL DX, R9, DX                        // c4e233f5d2
	PDEPL R11, R9, DX                       // c4c233f5d3
	PDEPL (BX), R9, R11                     // c46233f51b
	PDEPL (R11), R9, R11                    // c44233f51b
	PDEPL DX, R9, R11                       // c46233f5da
	PDEPL R11, R9, R11                      // c44233f5db
	PDEPQ (BX), R14, DX                     // c4e28bf513
	PDEPQ (R11), R14, DX                    // c4c28bf513
	PDEPQ DX, R14, DX                       // c4e28bf5d2
	PDEPQ R11, R14, DX                      // c4c28bf5d3
	PDEPQ (BX), R14, R11                    // c4628bf51b
	PDEPQ (R11), R14, R11                   // c4428bf51b
	PDEPQ DX, R14, R11                      // c4628bf5da
	PDEPQ R11, R14, R11                     // c4428bf5db
	PEXTL (BX), R9, DX                      // c4e232f513
	PEXTL (R11), R9, DX                     // c4c232f513
	PEXTL DX, R9, DX                        // c4e232f5d2
	PEXTL R11, R9, DX                       // c4c232f5d3
	PEXTL (BX), R9, R11                     // c46232f51b
	PEXTL (R11), R9, R11                    // c44232f51b
	PEXTL DX, R9, R11                       // c46232f5da
	PEXTL R11, R9, R11                      // c44232f5db
	PEXTQ (BX), R14, DX                     // c4e28af513
	PEXTQ (R11), R14, DX                    // c4c28af513
	PEXTQ DX, R14, DX                       // c4e28af5d2
	PEXTQ R11, R14, DX                      // c4c28af5d3
	PEXTQ (BX), R14, R11                    // c4628af51b
	PEXTQ (R11), R14, R11                   // c4428af51b
	PEXTQ DX, R14, R11                      // c4628af5da
	PEXTQ R11, R14, R11                     // c4428af5db
	PEXTRB $7, X2, (BX)                     // 660f3a141307
	PEXTRB $7, X11, (BX)                    // 66440f3a141b07
	PEXTRB $7, X2, (R11)                    // 66410f3a141307
	PEXTRB $7, X11, (R11)                   // 66450f3a141b07
	PEXTRB $7, X2, DX                       // 660f3a14d207
	PEXTRB $7, X11, DX                      // 66440f3a14da07
	PEXTRB $7, X2, R11                      // 66410f3a14d307
	PEXTRB $7, X11, R11                     // 66450f3a14db07
	PEXTRD $7, X2, (BX)                     // 660f3a161307
	PEXTRD $7, X11, (BX)                    // 66440f3a161b07
	PEXTRD $7, X2, (R11)                    // 66410f3a161307
	PEXTRD $7, X11, (R11)                   // 66450f3a161b07
	PEXTRD $7, X2, DX                       // 660f3a16d207
	PEXTRD $7, X11, DX                      // 66440f3a16da07
	PEXTRD $7, X2, R11                      // 66410f3a16d307
	PEXTRD $7, X11, R11                     // 66450f3a16db07
	PEXTRQ $7, X2, (BX)                     // 66480f3a161307
	PEXTRQ $7, X11, (BX)                    // 664c0f3a161b07
	PEXTRQ $7, X2, (R11)                    // 66490f3a161307
	PEXTRQ $7, X11, (R11)                   // 664d0f3a161b07
	PEXTRQ $7, X2, DX                       // 66480f3a16d207
	PEXTRQ $7, X11, DX                      // 664c0f3a16da07
	PEXTRQ $7, X2, R11                      // 66490f3a16d307
	PEXTRQ $7, X11, R11                     // 664d0f3a16db07
	//TODO: PEXTRW $7, M2, DX               // 0fc5d207
	//TODO: PEXTRW $7, M3, DX               // 0fc5d307
	//TODO: PEXTRW $7, M2, R11              // 440fc5da07
	//TODO: PEXTRW $7, M3, R11              // 440fc5db07
	PEXTRW $7, X2, DX                       // 660fc5d207 or 660f3a15d207
	PEXTRW $7, X11, DX                      // 66410fc5d307 or 66440f3a15da07
	PEXTRW $7, X2, R11                      // 66440fc5da07 or 66410f3a15d307
	PEXTRW $7, X11, R11                     // 66450fc5db07 or 66450f3a15db07
	//TODO: PEXTRW $7, X2, (BX)             // 660f3a151307
	//TODO: PEXTRW $7, X11, (BX)            // 66440f3a151b07
	//TODO: PEXTRW $7, X2, (R11)            // 66410f3a151307
	//TODO: PEXTRW $7, X11, (R11)           // 66450f3a151b07
	PHADDD (BX), M2                         // 0f380213
	PHADDD (R11), M2                        // 410f380213
	PHADDD M2, M2                           // 0f3802d2
	PHADDD M3, M2                           // 0f3802d3
	PHADDD (BX), M3                         // 0f38021b
	PHADDD (R11), M3                        // 410f38021b
	PHADDD M2, M3                           // 0f3802da
	PHADDD M3, M3                           // 0f3802db
	PHADDD (BX), X2                         // 660f380213
	PHADDD (R11), X2                        // 66410f380213
	PHADDD X2, X2                           // 660f3802d2
	PHADDD X11, X2                          // 66410f3802d3
	PHADDD (BX), X11                        // 66440f38021b
	PHADDD (R11), X11                       // 66450f38021b
	PHADDD X2, X11                          // 66440f3802da
	PHADDD X11, X11                         // 66450f3802db
	//TODO: PHADDSW (BX), M2                // 0f380313
	//TODO: PHADDSW (R11), M2               // 410f380313
	//TODO: PHADDSW M2, M2                  // 0f3803d2
	//TODO: PHADDSW M3, M2                  // 0f3803d3
	//TODO: PHADDSW (BX), M3                // 0f38031b
	//TODO: PHADDSW (R11), M3               // 410f38031b
	//TODO: PHADDSW M2, M3                  // 0f3803da
	//TODO: PHADDSW M3, M3                  // 0f3803db
	//TODO: PHADDSW (BX), X2                // 660f380313
	//TODO: PHADDSW (R11), X2               // 66410f380313
	//TODO: PHADDSW X2, X2                  // 660f3803d2
	//TODO: PHADDSW X11, X2                 // 66410f3803d3
	//TODO: PHADDSW (BX), X11               // 66440f38031b
	//TODO: PHADDSW (R11), X11              // 66450f38031b
	//TODO: PHADDSW X2, X11                 // 66440f3803da
	//TODO: PHADDSW X11, X11                // 66450f3803db
	//TODO: PHADDW (BX), M2                 // 0f380113
	//TODO: PHADDW (R11), M2                // 410f380113
	//TODO: PHADDW M2, M2                   // 0f3801d2
	//TODO: PHADDW M3, M2                   // 0f3801d3
	//TODO: PHADDW (BX), M3                 // 0f38011b
	//TODO: PHADDW (R11), M3                // 410f38011b
	//TODO: PHADDW M2, M3                   // 0f3801da
	//TODO: PHADDW M3, M3                   // 0f3801db
	//TODO: PHADDW (BX), X2                 // 660f380113
	//TODO: PHADDW (R11), X2                // 66410f380113
	//TODO: PHADDW X2, X2                   // 660f3801d2
	//TODO: PHADDW X11, X2                  // 66410f3801d3
	//TODO: PHADDW (BX), X11                // 66440f38011b
	//TODO: PHADDW (R11), X11               // 66450f38011b
	//TODO: PHADDW X2, X11                  // 66440f3801da
	//TODO: PHADDW X11, X11                 // 66450f3801db
	//TODO: PHMINPOSUW (BX), X2             // 660f384113
	//TODO: PHMINPOSUW (R11), X2            // 66410f384113
	//TODO: PHMINPOSUW X2, X2               // 660f3841d2
	//TODO: PHMINPOSUW X11, X2              // 66410f3841d3
	//TODO: PHMINPOSUW (BX), X11            // 66440f38411b
	//TODO: PHMINPOSUW (R11), X11           // 66450f38411b
	//TODO: PHMINPOSUW X2, X11              // 66440f3841da
	//TODO: PHMINPOSUW X11, X11             // 66450f3841db
	//TODO: PHSUBD (BX), M2                 // 0f380613
	//TODO: PHSUBD (R11), M2                // 410f380613
	//TODO: PHSUBD M2, M2                   // 0f3806d2
	//TODO: PHSUBD M3, M2                   // 0f3806d3
	//TODO: PHSUBD (BX), M3                 // 0f38061b
	//TODO: PHSUBD (R11), M3                // 410f38061b
	//TODO: PHSUBD M2, M3                   // 0f3806da
	//TODO: PHSUBD M3, M3                   // 0f3806db
	//TODO: PHSUBD (BX), X2                 // 660f380613
	//TODO: PHSUBD (R11), X2                // 66410f380613
	//TODO: PHSUBD X2, X2                   // 660f3806d2
	//TODO: PHSUBD X11, X2                  // 66410f3806d3
	//TODO: PHSUBD (BX), X11                // 66440f38061b
	//TODO: PHSUBD (R11), X11               // 66450f38061b
	//TODO: PHSUBD X2, X11                  // 66440f3806da
	//TODO: PHSUBD X11, X11                 // 66450f3806db
	//TODO: PHSUBSW (BX), M2                // 0f380713
	//TODO: PHSUBSW (R11), M2               // 410f380713
	//TODO: PHSUBSW M2, M2                  // 0f3807d2
	//TODO: PHSUBSW M3, M2                  // 0f3807d3
	//TODO: PHSUBSW (BX), M3                // 0f38071b
	//TODO: PHSUBSW (R11), M3               // 410f38071b
	//TODO: PHSUBSW M2, M3                  // 0f3807da
	//TODO: PHSUBSW M3, M3                  // 0f3807db
	//TODO: PHSUBSW (BX), X2                // 660f380713
	//TODO: PHSUBSW (R11), X2               // 66410f380713
	//TODO: PHSUBSW X2, X2                  // 660f3807d2
	//TODO: PHSUBSW X11, X2                 // 66410f3807d3
	//TODO: PHSUBSW (BX), X11               // 66440f38071b
	//TODO: PHSUBSW (R11), X11              // 66450f38071b
	//TODO: PHSUBSW X2, X11                 // 66440f3807da
	//TODO: PHSUBSW X11, X11                // 66450f3807db
	//TODO: PHSUBW (BX), M2                 // 0f380513
	//TODO: PHSUBW (R11), M2                // 410f380513
	//TODO: PHSUBW M2, M2                   // 0f3805d2
	//TODO: PHSUBW M3, M2                   // 0f3805d3
	//TODO: PHSUBW (BX), M3                 // 0f38051b
	//TODO: PHSUBW (R11), M3                // 410f38051b
	//TODO: PHSUBW M2, M3                   // 0f3805da
	//TODO: PHSUBW M3, M3                   // 0f3805db
	//TODO: PHSUBW (BX), X2                 // 660f380513
	//TODO: PHSUBW (R11), X2                // 66410f380513
	//TODO: PHSUBW X2, X2                   // 660f3805d2
	//TODO: PHSUBW X11, X2                  // 66410f3805d3
	//TODO: PHSUBW (BX), X11                // 66440f38051b
	//TODO: PHSUBW (R11), X11               // 66450f38051b
	//TODO: PHSUBW X2, X11                  // 66440f3805da
	//TODO: PHSUBW X11, X11                 // 66450f3805db
	PINSRB $7, (BX), X2                     // 660f3a201307
	PINSRB $7, (R11), X2                    // 66410f3a201307
	PINSRB $7, DX, X2                       // 660f3a20d207
	PINSRB $7, R11, X2                      // 66410f3a20d307
	PINSRB $7, (BX), X11                    // 66440f3a201b07
	PINSRB $7, (R11), X11                   // 66450f3a201b07
	PINSRB $7, DX, X11                      // 66440f3a20da07
	PINSRB $7, R11, X11                     // 66450f3a20db07
	PINSRD $7, (BX), X2                     // 660f3a221307
	PINSRD $7, (R11), X2                    // 66410f3a221307
	PINSRD $7, DX, X2                       // 660f3a22d207
	PINSRD $7, R11, X2                      // 66410f3a22d307
	PINSRD $7, (BX), X11                    // 66440f3a221b07
	PINSRD $7, (R11), X11                   // 66450f3a221b07
	PINSRD $7, DX, X11                      // 66440f3a22da07
	PINSRD $7, R11, X11                     // 66450f3a22db07
	PINSRQ $7, (BX), X2                     // 66480f3a221307
	PINSRQ $7, (R11), X2                    // 66490f3a221307
	PINSRQ $7, DX, X2                       // 66480f3a22d207
	PINSRQ $7, R11, X2                      // 66490f3a22d307
	PINSRQ $7, (BX), X11                    // 664c0f3a221b07
	PINSRQ $7, (R11), X11                   // 664d0f3a221b07
	PINSRQ $7, DX, X11                      // 664c0f3a22da07
	PINSRQ $7, R11, X11                     // 664d0f3a22db07
	//TODO: PINSRW $7, (BX), M2             // 0fc41307
	//TODO: PINSRW $7, (R11), M2            // 410fc41307
	//TODO: PINSRW $7, DX, M2               // 0fc4d207
	//TODO: PINSRW $7, R11, M2              // 410fc4d307
	//TODO: PINSRW $7, (BX), M3             // 0fc41b07
	//TODO: PINSRW $7, (R11), M3            // 410fc41b07
	//TODO: PINSRW $7, DX, M3               // 0fc4da07
	//TODO: PINSRW $7, R11, M3              // 410fc4db07
	PINSRW $7, (BX), X2                     // 660fc41307
	PINSRW $7, (R11), X2                    // 66410fc41307
	PINSRW $7, DX, X2                       // 660fc4d207
	PINSRW $7, R11, X2                      // 66410fc4d307
	PINSRW $7, (BX), X11                    // 66440fc41b07
	PINSRW $7, (R11), X11                   // 66450fc41b07
	PINSRW $7, DX, X11                      // 66440fc4da07
	PINSRW $7, R11, X11                     // 66450fc4db07
	//TODO: PMADDUBSW (BX), M2              // 0f380413
	//TODO: PMADDUBSW (R11), M2             // 410f380413
	//TODO: PMADDUBSW M2, M2                // 0f3804d2
	//TODO: PMADDUBSW M3, M2                // 0f3804d3
	//TODO: PMADDUBSW (BX), M3              // 0f38041b
	//TODO: PMADDUBSW (R11), M3             // 410f38041b
	//TODO: PMADDUBSW M2, M3                // 0f3804da
	//TODO: PMADDUBSW M3, M3                // 0f3804db
	//TODO: PMADDUBSW (BX), X2              // 660f380413
	//TODO: PMADDUBSW (R11), X2             // 66410f380413
	//TODO: PMADDUBSW X2, X2                // 660f3804d2
	//TODO: PMADDUBSW X11, X2               // 66410f3804d3
	//TODO: PMADDUBSW (BX), X11             // 66440f38041b
	//TODO: PMADDUBSW (R11), X11            // 66450f38041b
	//TODO: PMADDUBSW X2, X11               // 66440f3804da
	//TODO: PMADDUBSW X11, X11              // 66450f3804db
	PMADDWL (BX), M2                        // 0ff513
	PMADDWL (R11), M2                       // 410ff513
	PMADDWL M2, M2                          // 0ff5d2
	PMADDWL M3, M2                          // 0ff5d3
	PMADDWL (BX), M3                        // 0ff51b
	PMADDWL (R11), M3                       // 410ff51b
	PMADDWL M2, M3                          // 0ff5da
	PMADDWL M3, M3                          // 0ff5db
	PMADDWL (BX), X2                        // 660ff513
	PMADDWL (R11), X2                       // 66410ff513
	PMADDWL X2, X2                          // 660ff5d2
	PMADDWL X11, X2                         // 66410ff5d3
	PMADDWL (BX), X11                       // 66440ff51b
	PMADDWL (R11), X11                      // 66450ff51b
	PMADDWL X2, X11                         // 66440ff5da
	PMADDWL X11, X11                        // 66450ff5db
	//TODO: PMAXSB (BX), X2                 // 660f383c13
	//TODO: PMAXSB (R11), X2                // 66410f383c13
	//TODO: PMAXSB X2, X2                   // 660f383cd2
	//TODO: PMAXSB X11, X2                  // 66410f383cd3
	//TODO: PMAXSB (BX), X11                // 66440f383c1b
	//TODO: PMAXSB (R11), X11               // 66450f383c1b
	//TODO: PMAXSB X2, X11                  // 66440f383cda
	//TODO: PMAXSB X11, X11                 // 66450f383cdb
	//TODO: PMAXSD (BX), X2                 // 660f383d13
	//TODO: PMAXSD (R11), X2                // 66410f383d13
	//TODO: PMAXSD X2, X2                   // 660f383dd2
	//TODO: PMAXSD X11, X2                  // 66410f383dd3
	//TODO: PMAXSD (BX), X11                // 66440f383d1b
	//TODO: PMAXSD (R11), X11               // 66450f383d1b
	//TODO: PMAXSD X2, X11                  // 66440f383dda
	//TODO: PMAXSD X11, X11                 // 66450f383ddb
	//TODO: PMAXSW (BX), M2                 // 0fee13
	//TODO: PMAXSW (R11), M2                // 410fee13
	//TODO: PMAXSW M2, M2                   // 0feed2
	//TODO: PMAXSW M3, M2                   // 0feed3
	//TODO: PMAXSW (BX), M3                 // 0fee1b
	//TODO: PMAXSW (R11), M3                // 410fee1b
	//TODO: PMAXSW M2, M3                   // 0feeda
	//TODO: PMAXSW M3, M3                   // 0feedb
	PMAXSW (BX), X2                         // 660fee13
	PMAXSW (R11), X2                        // 66410fee13
	PMAXSW X2, X2                           // 660feed2
	PMAXSW X11, X2                          // 66410feed3
	PMAXSW (BX), X11                        // 66440fee1b
	PMAXSW (R11), X11                       // 66450fee1b
	PMAXSW X2, X11                          // 66440feeda
	PMAXSW X11, X11                         // 66450feedb
	//TODO: PMAXUB (BX), M2                 // 0fde13
	//TODO: PMAXUB (R11), M2                // 410fde13
	//TODO: PMAXUB M2, M2                   // 0fded2
	//TODO: PMAXUB M3, M2                   // 0fded3
	//TODO: PMAXUB (BX), M3                 // 0fde1b
	//TODO: PMAXUB (R11), M3                // 410fde1b
	//TODO: PMAXUB M2, M3                   // 0fdeda
	//TODO: PMAXUB M3, M3                   // 0fdedb
	PMAXUB (BX), X2                         // 660fde13
	PMAXUB (R11), X2                        // 66410fde13
	PMAXUB X2, X2                           // 660fded2
	PMAXUB X11, X2                          // 66410fded3
	PMAXUB (BX), X11                        // 66440fde1b
	PMAXUB (R11), X11                       // 66450fde1b
	PMAXUB X2, X11                          // 66440fdeda
	PMAXUB X11, X11                         // 66450fdedb
	//TODO: PMAXUD (BX), X2                 // 660f383f13
	//TODO: PMAXUD (R11), X2                // 66410f383f13
	//TODO: PMAXUD X2, X2                   // 660f383fd2
	//TODO: PMAXUD X11, X2                  // 66410f383fd3
	//TODO: PMAXUD (BX), X11                // 66440f383f1b
	//TODO: PMAXUD (R11), X11               // 66450f383f1b
	//TODO: PMAXUD X2, X11                  // 66440f383fda
	//TODO: PMAXUD X11, X11                 // 66450f383fdb
	//TODO: PMAXUW (BX), X2                 // 660f383e13
	//TODO: PMAXUW (R11), X2                // 66410f383e13
	//TODO: PMAXUW X2, X2                   // 660f383ed2
	//TODO: PMAXUW X11, X2                  // 66410f383ed3
	//TODO: PMAXUW (BX), X11                // 66440f383e1b
	//TODO: PMAXUW (R11), X11               // 66450f383e1b
	//TODO: PMAXUW X2, X11                  // 66440f383eda
	//TODO: PMAXUW X11, X11                 // 66450f383edb
	//TODO: PMINSB (BX), X2                 // 660f383813
	//TODO: PMINSB (R11), X2                // 66410f383813
	//TODO: PMINSB X2, X2                   // 660f3838d2
	//TODO: PMINSB X11, X2                  // 66410f3838d3
	//TODO: PMINSB (BX), X11                // 66440f38381b
	//TODO: PMINSB (R11), X11               // 66450f38381b
	//TODO: PMINSB X2, X11                  // 66440f3838da
	//TODO: PMINSB X11, X11                 // 66450f3838db
	//TODO: PMINSD (BX), X2                 // 660f383913
	//TODO: PMINSD (R11), X2                // 66410f383913
	//TODO: PMINSD X2, X2                   // 660f3839d2
	//TODO: PMINSD X11, X2                  // 66410f3839d3
	//TODO: PMINSD (BX), X11                // 66440f38391b
	//TODO: PMINSD (R11), X11               // 66450f38391b
	//TODO: PMINSD X2, X11                  // 66440f3839da
	//TODO: PMINSD X11, X11                 // 66450f3839db
	//TODO: PMINSW (BX), M2                 // 0fea13
	//TODO: PMINSW (R11), M2                // 410fea13
	//TODO: PMINSW M2, M2                   // 0fead2
	//TODO: PMINSW M3, M2                   // 0fead3
	//TODO: PMINSW (BX), M3                 // 0fea1b
	//TODO: PMINSW (R11), M3                // 410fea1b
	//TODO: PMINSW M2, M3                   // 0feada
	//TODO: PMINSW M3, M3                   // 0feadb
	PMINSW (BX), X2                         // 660fea13
	PMINSW (R11), X2                        // 66410fea13
	PMINSW X2, X2                           // 660fead2
	PMINSW X11, X2                          // 66410fead3
	PMINSW (BX), X11                        // 66440fea1b
	PMINSW (R11), X11                       // 66450fea1b
	PMINSW X2, X11                          // 66440feada
	PMINSW X11, X11                         // 66450feadb
	//TODO: PMINUB (BX), M2                 // 0fda13
	//TODO: PMINUB (R11), M2                // 410fda13
	//TODO: PMINUB M2, M2                   // 0fdad2
	//TODO: PMINUB M3, M2                   // 0fdad3
	//TODO: PMINUB (BX), M3                 // 0fda1b
	//TODO: PMINUB (R11), M3                // 410fda1b
	//TODO: PMINUB M2, M3                   // 0fdada
	//TODO: PMINUB M3, M3                   // 0fdadb
	PMINUB (BX), X2                         // 660fda13
	PMINUB (R11), X2                        // 66410fda13
	PMINUB X2, X2                           // 660fdad2
	PMINUB X11, X2                          // 66410fdad3
	PMINUB (BX), X11                        // 66440fda1b
	PMINUB (R11), X11                       // 66450fda1b
	PMINUB X2, X11                          // 66440fdada
	PMINUB X11, X11                         // 66450fdadb
	//TODO: PMINUD (BX), X2                 // 660f383b13
	//TODO: PMINUD (R11), X2                // 66410f383b13
	//TODO: PMINUD X2, X2                   // 660f383bd2
	//TODO: PMINUD X11, X2                  // 66410f383bd3
	//TODO: PMINUD (BX), X11                // 66440f383b1b
	//TODO: PMINUD (R11), X11               // 66450f383b1b
	//TODO: PMINUD X2, X11                  // 66440f383bda
	//TODO: PMINUD X11, X11                 // 66450f383bdb
	//TODO: PMINUW (BX), X2                 // 660f383a13
	//TODO: PMINUW (R11), X2                // 66410f383a13
	//TODO: PMINUW X2, X2                   // 660f383ad2
	//TODO: PMINUW X11, X2                  // 66410f383ad3
	//TODO: PMINUW (BX), X11                // 66440f383a1b
	//TODO: PMINUW (R11), X11               // 66450f383a1b
	//TODO: PMINUW X2, X11                  // 66440f383ada
	//TODO: PMINUW X11, X11                 // 66450f383adb
	PMOVMSKB M2, DX                         // 0fd7d2
	PMOVMSKB M3, DX                         // 0fd7d3
	PMOVMSKB M2, R11                        // 440fd7da
	PMOVMSKB M3, R11                        // 440fd7db
	PMOVMSKB X2, DX                         // 660fd7d2
	PMOVMSKB X11, DX                        // 66410fd7d3
	PMOVMSKB X2, R11                        // 66440fd7da
	PMOVMSKB X11, R11                       // 66450fd7db
	PMOVSXBD (BX), X2                       // 660f382113
	PMOVSXBD (R11), X2                      // 66410f382113
	PMOVSXBD X2, X2                         // 660f3821d2
	PMOVSXBD X11, X2                        // 66410f3821d3
	PMOVSXBD (BX), X11                      // 66440f38211b
	PMOVSXBD (R11), X11                     // 66450f38211b
	PMOVSXBD X2, X11                        // 66440f3821da
	PMOVSXBD X11, X11                       // 66450f3821db
	PMOVSXBQ (BX), X2                       // 660f382213
	PMOVSXBQ (R11), X2                      // 66410f382213
	PMOVSXBQ X2, X2                         // 660f3822d2
	PMOVSXBQ X11, X2                        // 66410f3822d3
	PMOVSXBQ (BX), X11                      // 66440f38221b
	PMOVSXBQ (R11), X11                     // 66450f38221b
	PMOVSXBQ X2, X11                        // 66440f3822da
	PMOVSXBQ X11, X11                       // 66450f3822db
	PMOVSXBW (BX), X2                       // 660f382013
	PMOVSXBW (R11), X2                      // 66410f382013
	PMOVSXBW X2, X2                         // 660f3820d2
	PMOVSXBW X11, X2                        // 66410f3820d3
	PMOVSXBW (BX), X11                      // 66440f38201b
	PMOVSXBW (R11), X11                     // 66450f38201b
	PMOVSXBW X2, X11                        // 66440f3820da
	PMOVSXBW X11, X11                       // 66450f3820db
	PMOVSXDQ (BX), X2                       // 660f382513
	PMOVSXDQ (R11), X2                      // 66410f382513
	PMOVSXDQ X2, X2                         // 660f3825d2
	PMOVSXDQ X11, X2                        // 66410f3825d3
	PMOVSXDQ (BX), X11                      // 66440f38251b
	PMOVSXDQ (R11), X11                     // 66450f38251b
	PMOVSXDQ X2, X11                        // 66440f3825da
	PMOVSXDQ X11, X11                       // 66450f3825db
	PMOVSXWD (BX), X2                       // 660f382313
	PMOVSXWD (R11), X2                      // 66410f382313
	PMOVSXWD X2, X2                         // 660f3823d2
	PMOVSXWD X11, X2                        // 66410f3823d3
	PMOVSXWD (BX), X11                      // 66440f38231b
	PMOVSXWD (R11), X11                     // 66450f38231b
	PMOVSXWD X2, X11                        // 66440f3823da
	PMOVSXWD X11, X11                       // 66450f3823db
	PMOVSXWQ (BX), X2                       // 660f382413
	PMOVSXWQ (R11), X2                      // 66410f382413
	PMOVSXWQ X2, X2                         // 660f3824d2
	PMOVSXWQ X11, X2                        // 66410f3824d3
	PMOVSXWQ (BX), X11                      // 66440f38241b
	PMOVSXWQ (R11), X11                     // 66450f38241b
	PMOVSXWQ X2, X11                        // 66440f3824da
	PMOVSXWQ X11, X11                       // 66450f3824db
	PMOVZXBD (BX), X2                       // 660f383113
	PMOVZXBD (R11), X2                      // 66410f383113
	PMOVZXBD X2, X2                         // 660f3831d2
	PMOVZXBD X11, X2                        // 66410f3831d3
	PMOVZXBD (BX), X11                      // 66440f38311b
	PMOVZXBD (R11), X11                     // 66450f38311b
	PMOVZXBD X2, X11                        // 66440f3831da
	PMOVZXBD X11, X11                       // 66450f3831db
	PMOVZXBQ (BX), X2                       // 660f383213
	PMOVZXBQ (R11), X2                      // 66410f383213
	PMOVZXBQ X2, X2                         // 660f3832d2
	PMOVZXBQ X11, X2                        // 66410f3832d3
	PMOVZXBQ (BX), X11                      // 66440f38321b
	PMOVZXBQ (R11), X11                     // 66450f38321b
	PMOVZXBQ X2, X11                        // 66440f3832da
	PMOVZXBQ X11, X11                       // 66450f3832db
	PMOVZXBW (BX), X2                       // 660f383013
	PMOVZXBW (R11), X2                      // 66410f383013
	PMOVZXBW X2, X2                         // 660f3830d2
	PMOVZXBW X11, X2                        // 66410f3830d3
	PMOVZXBW (BX), X11                      // 66440f38301b
	PMOVZXBW (R11), X11                     // 66450f38301b
	PMOVZXBW X2, X11                        // 66440f3830da
	PMOVZXBW X11, X11                       // 66450f3830db
	PMOVZXDQ (BX), X2                       // 660f383513
	PMOVZXDQ (R11), X2                      // 66410f383513
	PMOVZXDQ X2, X2                         // 660f3835d2
	PMOVZXDQ X11, X2                        // 66410f3835d3
	PMOVZXDQ (BX), X11                      // 66440f38351b
	PMOVZXDQ (R11), X11                     // 66450f38351b
	PMOVZXDQ X2, X11                        // 66440f3835da
	PMOVZXDQ X11, X11                       // 66450f3835db
	PMOVZXWD (BX), X2                       // 660f383313
	PMOVZXWD (R11), X2                      // 66410f383313
	PMOVZXWD X2, X2                         // 660f3833d2
	PMOVZXWD X11, X2                        // 66410f3833d3
	PMOVZXWD (BX), X11                      // 66440f38331b
	PMOVZXWD (R11), X11                     // 66450f38331b
	PMOVZXWD X2, X11                        // 66440f3833da
	PMOVZXWD X11, X11                       // 66450f3833db
	PMOVZXWQ (BX), X2                       // 660f383413
	PMOVZXWQ (R11), X2                      // 66410f383413
	PMOVZXWQ X2, X2                         // 660f3834d2
	PMOVZXWQ X11, X2                        // 66410f3834d3
	PMOVZXWQ (BX), X11                      // 66440f38341b
	PMOVZXWQ (R11), X11                     // 66450f38341b
	PMOVZXWQ X2, X11                        // 66440f3834da
	PMOVZXWQ X11, X11                       // 66450f3834db
	PMULDQ (BX), X2                         // 660f382813
	PMULDQ (R11), X2                        // 66410f382813
	PMULDQ X2, X2                           // 660f3828d2
	PMULDQ X11, X2                          // 66410f3828d3
	PMULDQ (BX), X11                        // 66440f38281b
	PMULDQ (R11), X11                       // 66450f38281b
	PMULDQ X2, X11                          // 66440f3828da
	PMULDQ X11, X11                         // 66450f3828db
	//TODO: PMULHRSW (BX), M2               // 0f380b13
	//TODO: PMULHRSW (R11), M2              // 410f380b13
	//TODO: PMULHRSW M2, M2                 // 0f380bd2
	//TODO: PMULHRSW M3, M2                 // 0f380bd3
	//TODO: PMULHRSW (BX), M3               // 0f380b1b
	//TODO: PMULHRSW (R11), M3              // 410f380b1b
	//TODO: PMULHRSW M2, M3                 // 0f380bda
	//TODO: PMULHRSW M3, M3                 // 0f380bdb
	//TODO: PMULHRSW (BX), X2               // 660f380b13
	//TODO: PMULHRSW (R11), X2              // 66410f380b13
	//TODO: PMULHRSW X2, X2                 // 660f380bd2
	//TODO: PMULHRSW X11, X2                // 66410f380bd3
	//TODO: PMULHRSW (BX), X11              // 66440f380b1b
	//TODO: PMULHRSW (R11), X11             // 66450f380b1b
	//TODO: PMULHRSW X2, X11                // 66440f380bda
	//TODO: PMULHRSW X11, X11               // 66450f380bdb
	PMULHUW (BX), M2                        // 0fe413
	PMULHUW (R11), M2                       // 410fe413
	PMULHUW M2, M2                          // 0fe4d2
	PMULHUW M3, M2                          // 0fe4d3
	PMULHUW (BX), M3                        // 0fe41b
	PMULHUW (R11), M3                       // 410fe41b
	PMULHUW M2, M3                          // 0fe4da
	PMULHUW M3, M3                          // 0fe4db
	PMULHUW (BX), X2                        // 660fe413
	PMULHUW (R11), X2                       // 66410fe413
	PMULHUW X2, X2                          // 660fe4d2
	PMULHUW X11, X2                         // 66410fe4d3
	PMULHUW (BX), X11                       // 66440fe41b
	PMULHUW (R11), X11                      // 66450fe41b
	PMULHUW X2, X11                         // 66440fe4da
	PMULHUW X11, X11                        // 66450fe4db
	PMULHW (BX), M2                         // 0fe513
	PMULHW (R11), M2                        // 410fe513
	PMULHW M2, M2                           // 0fe5d2
	PMULHW M3, M2                           // 0fe5d3
	PMULHW (BX), M3                         // 0fe51b
	PMULHW (R11), M3                        // 410fe51b
	PMULHW M2, M3                           // 0fe5da
	PMULHW M3, M3                           // 0fe5db
	PMULHW (BX), X2                         // 660fe513
	PMULHW (R11), X2                        // 66410fe513
	PMULHW X2, X2                           // 660fe5d2
	PMULHW X11, X2                          // 66410fe5d3
	PMULHW (BX), X11                        // 66440fe51b
	PMULHW (R11), X11                       // 66450fe51b
	PMULHW X2, X11                          // 66440fe5da
	PMULHW X11, X11                         // 66450fe5db
	PMULLD (BX), X2                         // 660f384013
	PMULLD (R11), X2                        // 66410f384013
	PMULLD X2, X2                           // 660f3840d2
	PMULLD X11, X2                          // 66410f3840d3
	PMULLD (BX), X11                        // 66440f38401b
	PMULLD (R11), X11                       // 66450f38401b
	PMULLD X2, X11                          // 66440f3840da
	PMULLD X11, X11                         // 66450f3840db
	PMULLW (BX), M2                         // 0fd513
	PMULLW (R11), M2                        // 410fd513
	PMULLW M2, M2                           // 0fd5d2
	PMULLW M3, M2                           // 0fd5d3
	PMULLW (BX), M3                         // 0fd51b
	PMULLW (R11), M3                        // 410fd51b
	PMULLW M2, M3                           // 0fd5da
	PMULLW M3, M3                           // 0fd5db
	PMULLW (BX), X2                         // 660fd513
	PMULLW (R11), X2                        // 66410fd513
	PMULLW X2, X2                           // 660fd5d2
	PMULLW X11, X2                          // 66410fd5d3
	PMULLW (BX), X11                        // 66440fd51b
	PMULLW (R11), X11                       // 66450fd51b
	PMULLW X2, X11                          // 66440fd5da
	PMULLW X11, X11                         // 66450fd5db
	PMULULQ (BX), M2                        // 0ff413
	PMULULQ (R11), M2                       // 410ff413
	PMULULQ M2, M2                          // 0ff4d2
	PMULULQ M3, M2                          // 0ff4d3
	PMULULQ (BX), M3                        // 0ff41b
	PMULULQ (R11), M3                       // 410ff41b
	PMULULQ M2, M3                          // 0ff4da
	PMULULQ M3, M3                          // 0ff4db
	PMULULQ (BX), X2                        // 660ff413
	PMULULQ (R11), X2                       // 66410ff413
	PMULULQ X2, X2                          // 660ff4d2
	PMULULQ X11, X2                         // 66410ff4d3
	PMULULQ (BX), X11                       // 66440ff41b
	PMULULQ (R11), X11                      // 66450ff41b
	PMULULQ X2, X11                         // 66440ff4da
	PMULULQ X11, X11                        // 66450ff4db
	PUSHQ AX
	POPQ FS                                 // 660fa1 or 0fa1
	PUSHQ AX
	POPQ GS                                 // 660fa9 or 0fa9
	PUSHW AX
	POPW (BX)                               // 668f03
	PUSHW AX
	POPW (R11)                              // 66418f03
	PUSHW AX
	POPW DX                                 // 668fc2 or 665a
	PUSHW AX
	POPW R11                                // 66418fc3 or 66415b
	PUSHQ AX
	POPQ (BX)                               // 8f03
	PUSHQ AX
	POPQ (R11)                              // 418f03
	PUSHQ AX
	POPQ DX                                 // 8fc2 or 5a
	PUSHQ AX
	POPQ R11                                // 418fc3 or 415b
	POPCNTW (BX), DX                        // 66f30fb813
	POPCNTW (R11), DX                       // 66f3410fb813
	POPCNTW DX, DX                          // 66f30fb8d2
	POPCNTW R11, DX                         // 66f3410fb8d3
	POPCNTW (BX), R11                       // 66f3440fb81b
	POPCNTW (R11), R11                      // 66f3450fb81b
	POPCNTW DX, R11                         // 66f3440fb8da
	POPCNTW R11, R11                        // 66f3450fb8db
	POPCNTL (BX), DX                        // f30fb813
	POPCNTL (R11), DX                       // f3410fb813
	POPCNTL DX, DX                          // f30fb8d2
	POPCNTL R11, DX                         // f3410fb8d3
	POPCNTL (BX), R11                       // f3440fb81b
	POPCNTL (R11), R11                      // f3450fb81b
	POPCNTL DX, R11                         // f3440fb8da
	POPCNTL R11, R11                        // f3450fb8db
	POPCNTQ (BX), DX                        // f3480fb813
	POPCNTQ (R11), DX                       // f3490fb813
	POPCNTQ DX, DX                          // f3480fb8d2
	POPCNTQ R11, DX                         // f3490fb8d3
	POPCNTQ (BX), R11                       // f34c0fb81b
	POPCNTQ (R11), R11                      // f34d0fb81b
	POPCNTQ DX, R11                         // f34c0fb8da
	POPCNTQ R11, R11                        // f34d0fb8db
	PUSHFW
	POPFW                                   // 669d
	PUSHFQ
	POPFQ                                   // 9d
	POR (BX), M2                            // 0feb13
	POR (R11), M2                           // 410feb13
	POR M2, M2                              // 0febd2
	POR M3, M2                              // 0febd3
	POR (BX), M3                            // 0feb1b
	POR (R11), M3                           // 410feb1b
	POR M2, M3                              // 0febda
	POR M3, M3                              // 0febdb
	POR (BX), X2                            // 660feb13
	POR (R11), X2                           // 66410feb13
	POR X2, X2                              // 660febd2
	POR X11, X2                             // 66410febd3
	POR (BX), X11                           // 66440feb1b
	POR (R11), X11                          // 66450feb1b
	POR X2, X11                             // 66440febda
	POR X11, X11                            // 66450febdb
	PREFETCHNTA (BX)                        // 0f1803
	PREFETCHNTA (R11)                       // 410f1803
	PREFETCHT0 (BX)                         // 0f180b
	PREFETCHT0 (R11)                        // 410f180b
	PREFETCHT1 (BX)                         // 0f1813
	PREFETCHT1 (R11)                        // 410f1813
	PREFETCHT2 (BX)                         // 0f181b
	PREFETCHT2 (R11)                        // 410f181b
	//TODO: PREFETCHW (BX)                  // 0f0d0b
	//TODO: PREFETCHW (R11)                 // 410f0d0b
	//TODO: PREFETCHWT1 (BX)                // 0f0d13
	//TODO: PREFETCHWT1 (R11)               // 410f0d13
	//TODO: PSADBW (BX), M2                 // 0ff613
	//TODO: PSADBW (R11), M2                // 410ff613
	//TODO: PSADBW M2, M2                   // 0ff6d2
	//TODO: PSADBW M3, M2                   // 0ff6d3
	//TODO: PSADBW (BX), M3                 // 0ff61b
	//TODO: PSADBW (R11), M3                // 410ff61b
	//TODO: PSADBW M2, M3                   // 0ff6da
	//TODO: PSADBW M3, M3                   // 0ff6db
	PSADBW (BX), X2                         // 660ff613
	PSADBW (R11), X2                        // 66410ff613
	PSADBW X2, X2                           // 660ff6d2
	PSADBW X11, X2                          // 66410ff6d3
	PSADBW (BX), X11                        // 66440ff61b
	PSADBW (R11), X11                       // 66450ff61b
	PSADBW X2, X11                          // 66440ff6da
	PSADBW X11, X11                         // 66450ff6db
	//TODO: PSHUFB (BX), M2                 // 0f380013
	//TODO: PSHUFB (R11), M2                // 410f380013
	//TODO: PSHUFB M2, M2                   // 0f3800d2
	//TODO: PSHUFB M3, M2                   // 0f3800d3
	//TODO: PSHUFB (BX), M3                 // 0f38001b
	//TODO: PSHUFB (R11), M3                // 410f38001b
	//TODO: PSHUFB M2, M3                   // 0f3800da
	//TODO: PSHUFB M3, M3                   // 0f3800db
	PSHUFB (BX), X2                         // 660f380013
	PSHUFB (R11), X2                        // 66410f380013
	PSHUFB X2, X2                           // 660f3800d2
	PSHUFB X11, X2                          // 66410f3800d3
	PSHUFB (BX), X11                        // 66440f38001b
	PSHUFB (R11), X11                       // 66450f38001b
	PSHUFB X2, X11                          // 66440f3800da
	PSHUFB X11, X11                         // 66450f3800db
	PSHUFD $7, (BX), X2                     // 660f701307
	PSHUFL $7, (BX), X2                     // 660f701307
	PSHUFD $7, (R11), X2                    // 66410f701307
	PSHUFL $7, (R11), X2                    // 66410f701307
	PSHUFD $7, X2, X2                       // 660f70d207
	PSHUFL $7, X2, X2                       // 660f70d207
	PSHUFD $7, X11, X2                      // 66410f70d307
	PSHUFL $7, X11, X2                      // 66410f70d307
	PSHUFD $7, (BX), X11                    // 66440f701b07
	PSHUFL $7, (BX), X11                    // 66440f701b07
	PSHUFD $7, (R11), X11                   // 66450f701b07
	PSHUFL $7, (R11), X11                   // 66450f701b07
	PSHUFD $7, X2, X11                      // 66440f70da07
	PSHUFL $7, X2, X11                      // 66440f70da07
	PSHUFD $7, X11, X11                     // 66450f70db07
	PSHUFL $7, X11, X11                     // 66450f70db07
	PSHUFHW $7, (BX), X2                    // f30f701307
	PSHUFHW $7, (R11), X2                   // f3410f701307
	PSHUFHW $7, X2, X2                      // f30f70d207
	PSHUFHW $7, X11, X2                     // f3410f70d307
	PSHUFHW $7, (BX), X11                   // f3440f701b07
	PSHUFHW $7, (R11), X11                  // f3450f701b07
	PSHUFHW $7, X2, X11                     // f3440f70da07
	PSHUFHW $7, X11, X11                    // f3450f70db07
	PSHUFLW $7, (BX), X2                    // f20f701307
	PSHUFLW $7, (R11), X2                   // f2410f701307
	PSHUFLW $7, X2, X2                      // f20f70d207
	PSHUFLW $7, X11, X2                     // f2410f70d307
	PSHUFLW $7, (BX), X11                   // f2440f701b07
	PSHUFLW $7, (R11), X11                  // f2450f701b07
	PSHUFLW $7, X2, X11                     // f2440f70da07
	PSHUFLW $7, X11, X11                    // f2450f70db07
	PSHUFW $7, (BX), M2                     // 0f701307
	PSHUFW $7, (R11), M2                    // 410f701307
	PSHUFW $7, M2, M2                       // 0f70d207
	PSHUFW $7, M3, M2                       // 0f70d307
	PSHUFW $7, (BX), M3                     // 0f701b07
	PSHUFW $7, (R11), M3                    // 410f701b07
	PSHUFW $7, M2, M3                       // 0f70da07
	PSHUFW $7, M3, M3                       // 0f70db07
	//TODO: PSIGNB (BX), M2                 // 0f380813
	//TODO: PSIGNB (R11), M2                // 410f380813
	//TODO: PSIGNB M2, M2                   // 0f3808d2
	//TODO: PSIGNB M3, M2                   // 0f3808d3
	//TODO: PSIGNB (BX), M3                 // 0f38081b
	//TODO: PSIGNB (R11), M3                // 410f38081b
	//TODO: PSIGNB M2, M3                   // 0f3808da
	//TODO: PSIGNB M3, M3                   // 0f3808db
	//TODO: PSIGNB (BX), X2                 // 660f380813
	//TODO: PSIGNB (R11), X2                // 66410f380813
	//TODO: PSIGNB X2, X2                   // 660f3808d2
	//TODO: PSIGNB X11, X2                  // 66410f3808d3
	//TODO: PSIGNB (BX), X11                // 66440f38081b
	//TODO: PSIGNB (R11), X11               // 66450f38081b
	//TODO: PSIGNB X2, X11                  // 66440f3808da
	//TODO: PSIGNB X11, X11                 // 66450f3808db
	//TODO: PSIGND (BX), M2                 // 0f380a13
	//TODO: PSIGND (R11), M2                // 410f380a13
	//TODO: PSIGND M2, M2                   // 0f380ad2
	//TODO: PSIGND M3, M2                   // 0f380ad3
	//TODO: PSIGND (BX), M3                 // 0f380a1b
	//TODO: PSIGND (R11), M3                // 410f380a1b
	//TODO: PSIGND M2, M3                   // 0f380ada
	//TODO: PSIGND M3, M3                   // 0f380adb
	//TODO: PSIGND (BX), X2                 // 660f380a13
	//TODO: PSIGND (R11), X2                // 66410f380a13
	//TODO: PSIGND X2, X2                   // 660f380ad2
	//TODO: PSIGND X11, X2                  // 66410f380ad3
	//TODO: PSIGND (BX), X11                // 66440f380a1b
	//TODO: PSIGND (R11), X11               // 66450f380a1b
	//TODO: PSIGND X2, X11                  // 66440f380ada
	//TODO: PSIGND X11, X11                 // 66450f380adb
	//TODO: PSIGNW (BX), M2                 // 0f380913
	//TODO: PSIGNW (R11), M2                // 410f380913
	//TODO: PSIGNW M2, M2                   // 0f3809d2
	//TODO: PSIGNW M3, M2                   // 0f3809d3
	//TODO: PSIGNW (BX), M3                 // 0f38091b
	//TODO: PSIGNW (R11), M3                // 410f38091b
	//TODO: PSIGNW M2, M3                   // 0f3809da
	//TODO: PSIGNW M3, M3                   // 0f3809db
	//TODO: PSIGNW (BX), X2                 // 660f380913
	//TODO: PSIGNW (R11), X2                // 66410f380913
	//TODO: PSIGNW X2, X2                   // 660f3809d2
	//TODO: PSIGNW X11, X2                  // 66410f3809d3
	//TODO: PSIGNW (BX), X11                // 66440f38091b
	//TODO: PSIGNW (R11), X11               // 66450f38091b
	//TODO: PSIGNW X2, X11                  // 66440f3809da
	//TODO: PSIGNW X11, X11                 // 66450f3809db
	PSLLL (BX), M2                          // 0ff213
	PSLLL (R11), M2                         // 410ff213
	PSLLL M2, M2                            // 0ff2d2
	PSLLL M3, M2                            // 0ff2d3
	PSLLL (BX), M3                          // 0ff21b
	PSLLL (R11), M3                         // 410ff21b
	PSLLL M2, M3                            // 0ff2da
	PSLLL M3, M3                            // 0ff2db
	PSLLL $7, M2                            // 0f72f207
	PSLLL $7, M3                            // 0f72f307
	PSLLL (BX), X2                          // 660ff213
	PSLLL (R11), X2                         // 66410ff213
	PSLLL X2, X2                            // 660ff2d2
	PSLLL X11, X2                           // 66410ff2d3
	PSLLL (BX), X11                         // 66440ff21b
	PSLLL (R11), X11                        // 66450ff21b
	PSLLL X2, X11                           // 66440ff2da
	PSLLL X11, X11                          // 66450ff2db
	PSLLL $7, X2                            // 660f72f207
	PSLLL $7, X11                           // 66410f72f307
	PSLLO $7, X2                            // 660f73fa07
	PSLLO $7, X11                           // 66410f73fb07
	PSLLQ (BX), M2                          // 0ff313
	PSLLQ (R11), M2                         // 410ff313
	PSLLQ M2, M2                            // 0ff3d2
	PSLLQ M3, M2                            // 0ff3d3
	PSLLQ (BX), M3                          // 0ff31b
	PSLLQ (R11), M3                         // 410ff31b
	PSLLQ M2, M3                            // 0ff3da
	PSLLQ M3, M3                            // 0ff3db
	PSLLQ $7, M2                            // 0f73f207
	PSLLQ $7, M3                            // 0f73f307
	PSLLQ (BX), X2                          // 660ff313
	PSLLQ (R11), X2                         // 66410ff313
	PSLLQ X2, X2                            // 660ff3d2
	PSLLQ X11, X2                           // 66410ff3d3
	PSLLQ (BX), X11                         // 66440ff31b
	PSLLQ (R11), X11                        // 66450ff31b
	PSLLQ X2, X11                           // 66440ff3da
	PSLLQ X11, X11                          // 66450ff3db
	PSLLQ $7, X2                            // 660f73f207
	PSLLQ $7, X11                           // 66410f73f307
	PSLLW (BX), M2                          // 0ff113
	PSLLW (R11), M2                         // 410ff113
	PSLLW M2, M2                            // 0ff1d2
	PSLLW M3, M2                            // 0ff1d3
	PSLLW (BX), M3                          // 0ff11b
	PSLLW (R11), M3                         // 410ff11b
	PSLLW M2, M3                            // 0ff1da
	PSLLW M3, M3                            // 0ff1db
	PSLLW $7, M2                            // 0f71f207
	PSLLW $7, M3                            // 0f71f307
	PSLLW (BX), X2                          // 660ff113
	PSLLW (R11), X2                         // 66410ff113
	PSLLW X2, X2                            // 660ff1d2
	PSLLW X11, X2                           // 66410ff1d3
	PSLLW (BX), X11                         // 66440ff11b
	PSLLW (R11), X11                        // 66450ff11b
	PSLLW X2, X11                           // 66440ff1da
	PSLLW X11, X11                          // 66450ff1db
	PSLLW $7, X2                            // 660f71f207
	PSLLW $7, X11                           // 66410f71f307
	PSRAL (BX), M2                          // 0fe213
	PSRAL (R11), M2                         // 410fe213
	PSRAL M2, M2                            // 0fe2d2
	PSRAL M3, M2                            // 0fe2d3
	PSRAL (BX), M3                          // 0fe21b
	PSRAL (R11), M3                         // 410fe21b
	PSRAL M2, M3                            // 0fe2da
	PSRAL M3, M3                            // 0fe2db
	PSRAL $7, M2                            // 0f72e207
	PSRAL $7, M3                            // 0f72e307
	PSRAL (BX), X2                          // 660fe213
	PSRAL (R11), X2                         // 66410fe213
	PSRAL X2, X2                            // 660fe2d2
	PSRAL X11, X2                           // 66410fe2d3
	PSRAL (BX), X11                         // 66440fe21b
	PSRAL (R11), X11                        // 66450fe21b
	PSRAL X2, X11                           // 66440fe2da
	PSRAL X11, X11                          // 66450fe2db
	PSRAL $7, X2                            // 660f72e207
	PSRAL $7, X11                           // 66410f72e307
	PSRAW (BX), M2                          // 0fe113
	PSRAW (R11), M2                         // 410fe113
	PSRAW M2, M2                            // 0fe1d2
	PSRAW M3, M2                            // 0fe1d3
	PSRAW (BX), M3                          // 0fe11b
	PSRAW (R11), M3                         // 410fe11b
	PSRAW M2, M3                            // 0fe1da
	PSRAW M3, M3                            // 0fe1db
	PSRAW $7, M2                            // 0f71e207
	PSRAW $7, M3                            // 0f71e307
	PSRAW (BX), X2                          // 660fe113
	PSRAW (R11), X2                         // 66410fe113
	PSRAW X2, X2                            // 660fe1d2
	PSRAW X11, X2                           // 66410fe1d3
	PSRAW (BX), X11                         // 66440fe11b
	PSRAW (R11), X11                        // 66450fe11b
	PSRAW X2, X11                           // 66440fe1da
	PSRAW X11, X11                          // 66450fe1db
	PSRAW $7, X2                            // 660f71e207
	PSRAW $7, X11                           // 66410f71e307
	PSRLL (BX), M2                          // 0fd213
	PSRLL (R11), M2                         // 410fd213
	PSRLL M2, M2                            // 0fd2d2
	PSRLL M3, M2                            // 0fd2d3
	PSRLL (BX), M3                          // 0fd21b
	PSRLL (R11), M3                         // 410fd21b
	PSRLL M2, M3                            // 0fd2da
	PSRLL M3, M3                            // 0fd2db
	PSRLL $7, M2                            // 0f72d207
	PSRLL $7, M3                            // 0f72d307
	PSRLL (BX), X2                          // 660fd213
	PSRLL (R11), X2                         // 66410fd213
	PSRLL X2, X2                            // 660fd2d2
	PSRLL X11, X2                           // 66410fd2d3
	PSRLL (BX), X11                         // 66440fd21b
	PSRLL (R11), X11                        // 66450fd21b
	PSRLL X2, X11                           // 66440fd2da
	PSRLL X11, X11                          // 66450fd2db
	PSRLL $7, X2                            // 660f72d207
	PSRLL $7, X11                           // 66410f72d307
	PSRLO $7, X2                            // 660f73da07
	PSRLO $7, X11                           // 66410f73db07
	PSRLQ (BX), M2                          // 0fd313
	PSRLQ (R11), M2                         // 410fd313
	PSRLQ M2, M2                            // 0fd3d2
	PSRLQ M3, M2                            // 0fd3d3
	PSRLQ (BX), M3                          // 0fd31b
	PSRLQ (R11), M3                         // 410fd31b
	PSRLQ M2, M3                            // 0fd3da
	PSRLQ M3, M3                            // 0fd3db
	PSRLQ $7, M2                            // 0f73d207
	PSRLQ $7, M3                            // 0f73d307
	PSRLQ (BX), X2                          // 660fd313
	PSRLQ (R11), X2                         // 66410fd313
	PSRLQ X2, X2                            // 660fd3d2
	PSRLQ X11, X2                           // 66410fd3d3
	PSRLQ (BX), X11                         // 66440fd31b
	PSRLQ (R11), X11                        // 66450fd31b
	PSRLQ X2, X11                           // 66440fd3da
	PSRLQ X11, X11                          // 66450fd3db
	PSRLQ $7, X2                            // 660f73d207
	PSRLQ $7, X11                           // 66410f73d307
	PSRLW (BX), M2                          // 0fd113
	PSRLW (R11), M2                         // 410fd113
	PSRLW M2, M2                            // 0fd1d2
	PSRLW M3, M2                            // 0fd1d3
	PSRLW (BX), M3                          // 0fd11b
	PSRLW (R11), M3                         // 410fd11b
	PSRLW M2, M3                            // 0fd1da
	PSRLW M3, M3                            // 0fd1db
	PSRLW $7, M2                            // 0f71d207
	PSRLW $7, M3                            // 0f71d307
	PSRLW (BX), X2                          // 660fd113
	PSRLW (R11), X2                         // 66410fd113
	PSRLW X2, X2                            // 660fd1d2
	PSRLW X11, X2                           // 66410fd1d3
	PSRLW (BX), X11                         // 66440fd11b
	PSRLW (R11), X11                        // 66450fd11b
	PSRLW X2, X11                           // 66440fd1da
	PSRLW X11, X11                          // 66450fd1db
	PSRLW $7, X2                            // 660f71d207
	PSRLW $7, X11                           // 66410f71d307
	//TODO: PSUBB (BX), M2                  // 0ff813
	//TODO: PSUBB (R11), M2                 // 410ff813
	//TODO: PSUBB M2, M2                    // 0ff8d2
	//TODO: PSUBB M3, M2                    // 0ff8d3
	//TODO: PSUBB (BX), M3                  // 0ff81b
	//TODO: PSUBB (R11), M3                 // 410ff81b
	//TODO: PSUBB M2, M3                    // 0ff8da
	//TODO: PSUBB M3, M3                    // 0ff8db
	PSUBB (BX), X2                          // 660ff813
	PSUBB (R11), X2                         // 66410ff813
	PSUBB X2, X2                            // 660ff8d2
	PSUBB X11, X2                           // 66410ff8d3
	PSUBB (BX), X11                         // 66440ff81b
	PSUBB (R11), X11                        // 66450ff81b
	PSUBB X2, X11                           // 66440ff8da
	PSUBB X11, X11                          // 66450ff8db
	//TODO: PSUBL (BX), M2                  // 0ffa13
	//TODO: PSUBL (R11), M2                 // 410ffa13
	//TODO: PSUBL M2, M2                    // 0ffad2
	//TODO: PSUBL M3, M2                    // 0ffad3
	//TODO: PSUBL (BX), M3                  // 0ffa1b
	//TODO: PSUBL (R11), M3                 // 410ffa1b
	//TODO: PSUBL M2, M3                    // 0ffada
	//TODO: PSUBL M3, M3                    // 0ffadb
	PSUBL (BX), X2                          // 660ffa13
	PSUBL (R11), X2                         // 66410ffa13
	PSUBL X2, X2                            // 660ffad2
	PSUBL X11, X2                           // 66410ffad3
	PSUBL (BX), X11                         // 66440ffa1b
	PSUBL (R11), X11                        // 66450ffa1b
	PSUBL X2, X11                           // 66440ffada
	PSUBL X11, X11                          // 66450ffadb
	//TODO: PSUBQ (BX), M2                  // 0ffb13
	//TODO: PSUBQ (R11), M2                 // 410ffb13
	//TODO: PSUBQ M2, M2                    // 0ffbd2
	//TODO: PSUBQ M3, M2                    // 0ffbd3
	//TODO: PSUBQ (BX), M3                  // 0ffb1b
	//TODO: PSUBQ (R11), M3                 // 410ffb1b
	//TODO: PSUBQ M2, M3                    // 0ffbda
	//TODO: PSUBQ M3, M3                    // 0ffbdb
	PSUBQ (BX), X2                          // 660ffb13
	PSUBQ (R11), X2                         // 66410ffb13
	PSUBQ X2, X2                            // 660ffbd2
	PSUBQ X11, X2                           // 66410ffbd3
	PSUBQ (BX), X11                         // 66440ffb1b
	PSUBQ (R11), X11                        // 66450ffb1b
	PSUBQ X2, X11                           // 66440ffbda
	PSUBQ X11, X11                          // 66450ffbdb
	//TODO: PSUBSB (BX), M2                 // 0fe813
	//TODO: PSUBSB (R11), M2                // 410fe813
	//TODO: PSUBSB M2, M2                   // 0fe8d2
	//TODO: PSUBSB M3, M2                   // 0fe8d3
	//TODO: PSUBSB (BX), M3                 // 0fe81b
	//TODO: PSUBSB (R11), M3                // 410fe81b
	//TODO: PSUBSB M2, M3                   // 0fe8da
	//TODO: PSUBSB M3, M3                   // 0fe8db
	PSUBSB (BX), X2                         // 660fe813
	PSUBSB (R11), X2                        // 66410fe813
	PSUBSB X2, X2                           // 660fe8d2
	PSUBSB X11, X2                          // 66410fe8d3
	PSUBSB (BX), X11                        // 66440fe81b
	PSUBSB (R11), X11                       // 66450fe81b
	PSUBSB X2, X11                          // 66440fe8da
	PSUBSB X11, X11                         // 66450fe8db
	//TODO: PSUBSW (BX), M2                 // 0fe913
	//TODO: PSUBSW (R11), M2                // 410fe913
	//TODO: PSUBSW M2, M2                   // 0fe9d2
	//TODO: PSUBSW M3, M2                   // 0fe9d3
	//TODO: PSUBSW (BX), M3                 // 0fe91b
	//TODO: PSUBSW (R11), M3                // 410fe91b
	//TODO: PSUBSW M2, M3                   // 0fe9da
	//TODO: PSUBSW M3, M3                   // 0fe9db
	PSUBSW (BX), X2                         // 660fe913
	PSUBSW (R11), X2                        // 66410fe913
	PSUBSW X2, X2                           // 660fe9d2
	PSUBSW X11, X2                          // 66410fe9d3
	PSUBSW (BX), X11                        // 66440fe91b
	PSUBSW (R11), X11                       // 66450fe91b
	PSUBSW X2, X11                          // 66440fe9da
	PSUBSW X11, X11                         // 66450fe9db
	//TODO: PSUBUSB (BX), M2                // 0fd813
	//TODO: PSUBUSB (R11), M2               // 410fd813
	//TODO: PSUBUSB M2, M2                  // 0fd8d2
	//TODO: PSUBUSB M3, M2                  // 0fd8d3
	//TODO: PSUBUSB (BX), M3                // 0fd81b
	//TODO: PSUBUSB (R11), M3               // 410fd81b
	//TODO: PSUBUSB M2, M3                  // 0fd8da
	//TODO: PSUBUSB M3, M3                  // 0fd8db
	PSUBUSB (BX), X2                        // 660fd813
	PSUBUSB (R11), X2                       // 66410fd813
	PSUBUSB X2, X2                          // 660fd8d2
	PSUBUSB X11, X2                         // 66410fd8d3
	PSUBUSB (BX), X11                       // 66440fd81b
	PSUBUSB (R11), X11                      // 66450fd81b
	PSUBUSB X2, X11                         // 66440fd8da
	PSUBUSB X11, X11                        // 66450fd8db
	//TODO: PSUBUSW (BX), M2                // 0fd913
	//TODO: PSUBUSW (R11), M2               // 410fd913
	//TODO: PSUBUSW M2, M2                  // 0fd9d2
	//TODO: PSUBUSW M3, M2                  // 0fd9d3
	//TODO: PSUBUSW (BX), M3                // 0fd91b
	//TODO: PSUBUSW (R11), M3               // 410fd91b
	//TODO: PSUBUSW M2, M3                  // 0fd9da
	//TODO: PSUBUSW M3, M3                  // 0fd9db
	PSUBUSW (BX), X2                        // 660fd913
	PSUBUSW (R11), X2                       // 66410fd913
	PSUBUSW X2, X2                          // 660fd9d2
	PSUBUSW X11, X2                         // 66410fd9d3
	PSUBUSW (BX), X11                       // 66440fd91b
	PSUBUSW (R11), X11                      // 66450fd91b
	PSUBUSW X2, X11                         // 66440fd9da
	PSUBUSW X11, X11                        // 66450fd9db
	//TODO: PSUBW (BX), M2                  // 0ff913
	//TODO: PSUBW (R11), M2                 // 410ff913
	//TODO: PSUBW M2, M2                    // 0ff9d2
	//TODO: PSUBW M3, M2                    // 0ff9d3
	//TODO: PSUBW (BX), M3                  // 0ff91b
	//TODO: PSUBW (R11), M3                 // 410ff91b
	//TODO: PSUBW M2, M3                    // 0ff9da
	//TODO: PSUBW M3, M3                    // 0ff9db
	PSUBW (BX), X2                          // 660ff913
	PSUBW (R11), X2                         // 66410ff913
	PSUBW X2, X2                            // 660ff9d2
	PSUBW X11, X2                           // 66410ff9d3
	PSUBW (BX), X11                         // 66440ff91b
	PSUBW (R11), X11                        // 66450ff91b
	PSUBW X2, X11                           // 66440ff9da
	PSUBW X11, X11                          // 66450ff9db
	//TODO: PTEST (BX), X2                  // 660f381713
	//TODO: PTEST (R11), X2                 // 66410f381713
	//TODO: PTEST X2, X2                    // 660f3817d2
	//TODO: PTEST X11, X2                   // 66410f3817d3
	//TODO: PTEST (BX), X11                 // 66440f38171b
	//TODO: PTEST (R11), X11                // 66450f38171b
	//TODO: PTEST X2, X11                   // 66440f3817da
	//TODO: PTEST X11, X11                  // 66450f3817db
	PUNPCKHBW (BX), M2                      // 0f6813
	PUNPCKHBW (R11), M2                     // 410f6813
	PUNPCKHBW M2, M2                        // 0f68d2
	PUNPCKHBW M3, M2                        // 0f68d3
	PUNPCKHBW (BX), M3                      // 0f681b
	PUNPCKHBW (R11), M3                     // 410f681b
	PUNPCKHBW M2, M3                        // 0f68da
	PUNPCKHBW M3, M3                        // 0f68db
	PUNPCKHBW (BX), X2                      // 660f6813
	PUNPCKHBW (R11), X2                     // 66410f6813
	PUNPCKHBW X2, X2                        // 660f68d2
	PUNPCKHBW X11, X2                       // 66410f68d3
	PUNPCKHBW (BX), X11                     // 66440f681b
	PUNPCKHBW (R11), X11                    // 66450f681b
	PUNPCKHBW X2, X11                       // 66440f68da
	PUNPCKHBW X11, X11                      // 66450f68db
	PUNPCKHLQ (BX), M2                      // 0f6a13
	PUNPCKHLQ (R11), M2                     // 410f6a13
	PUNPCKHLQ M2, M2                        // 0f6ad2
	PUNPCKHLQ M3, M2                        // 0f6ad3
	PUNPCKHLQ (BX), M3                      // 0f6a1b
	PUNPCKHLQ (R11), M3                     // 410f6a1b
	PUNPCKHLQ M2, M3                        // 0f6ada
	PUNPCKHLQ M3, M3                        // 0f6adb
	PUNPCKHLQ (BX), X2                      // 660f6a13
	PUNPCKHLQ (R11), X2                     // 66410f6a13
	PUNPCKHLQ X2, X2                        // 660f6ad2
	PUNPCKHLQ X11, X2                       // 66410f6ad3
	PUNPCKHLQ (BX), X11                     // 66440f6a1b
	PUNPCKHLQ (R11), X11                    // 66450f6a1b
	PUNPCKHLQ X2, X11                       // 66440f6ada
	PUNPCKHLQ X11, X11                      // 66450f6adb
	PUNPCKHQDQ (BX), X2                     // 660f6d13
	PUNPCKHQDQ (R11), X2                    // 66410f6d13
	PUNPCKHQDQ X2, X2                       // 660f6dd2
	PUNPCKHQDQ X11, X2                      // 66410f6dd3
	PUNPCKHQDQ (BX), X11                    // 66440f6d1b
	PUNPCKHQDQ (R11), X11                   // 66450f6d1b
	PUNPCKHQDQ X2, X11                      // 66440f6dda
	PUNPCKHQDQ X11, X11                     // 66450f6ddb
	PUNPCKHWL (BX), M2                      // 0f6913
	PUNPCKHWL (R11), M2                     // 410f6913
	PUNPCKHWL M2, M2                        // 0f69d2
	PUNPCKHWL M3, M2                        // 0f69d3
	PUNPCKHWL (BX), M3                      // 0f691b
	PUNPCKHWL (R11), M3                     // 410f691b
	PUNPCKHWL M2, M3                        // 0f69da
	PUNPCKHWL M3, M3                        // 0f69db
	PUNPCKHWL (BX), X2                      // 660f6913
	PUNPCKHWL (R11), X2                     // 66410f6913
	PUNPCKHWL X2, X2                        // 660f69d2
	PUNPCKHWL X11, X2                       // 66410f69d3
	PUNPCKHWL (BX), X11                     // 66440f691b
	PUNPCKHWL (R11), X11                    // 66450f691b
	PUNPCKHWL X2, X11                       // 66440f69da
	PUNPCKHWL X11, X11                      // 66450f69db
	PUNPCKLBW (BX), M2                      // 0f6013
	PUNPCKLBW (R11), M2                     // 410f6013
	PUNPCKLBW M2, M2                        // 0f60d2
	PUNPCKLBW M3, M2                        // 0f60d3
	PUNPCKLBW (BX), M3                      // 0f601b
	PUNPCKLBW (R11), M3                     // 410f601b
	PUNPCKLBW M2, M3                        // 0f60da
	PUNPCKLBW M3, M3                        // 0f60db
	PUNPCKLBW (BX), X2                      // 660f6013
	PUNPCKLBW (R11), X2                     // 66410f6013
	PUNPCKLBW X2, X2                        // 660f60d2
	PUNPCKLBW X11, X2                       // 66410f60d3
	PUNPCKLBW (BX), X11                     // 66440f601b
	PUNPCKLBW (R11), X11                    // 66450f601b
	PUNPCKLBW X2, X11                       // 66440f60da
	PUNPCKLBW X11, X11                      // 66450f60db
	PUNPCKLLQ (BX), M2                      // 0f6213
	PUNPCKLLQ (R11), M2                     // 410f6213
	PUNPCKLLQ M2, M2                        // 0f62d2
	PUNPCKLLQ M3, M2                        // 0f62d3
	PUNPCKLLQ (BX), M3                      // 0f621b
	PUNPCKLLQ (R11), M3                     // 410f621b
	PUNPCKLLQ M2, M3                        // 0f62da
	PUNPCKLLQ M3, M3                        // 0f62db
	PUNPCKLLQ (BX), X2                      // 660f6213
	PUNPCKLLQ (R11), X2                     // 66410f6213
	PUNPCKLLQ X2, X2                        // 660f62d2
	PUNPCKLLQ X11, X2                       // 66410f62d3
	PUNPCKLLQ (BX), X11                     // 66440f621b
	PUNPCKLLQ (R11), X11                    // 66450f621b
	PUNPCKLLQ X2, X11                       // 66440f62da
	PUNPCKLLQ X11, X11                      // 66450f62db
	PUNPCKLQDQ (BX), X2                     // 660f6c13
	PUNPCKLQDQ (R11), X2                    // 66410f6c13
	PUNPCKLQDQ X2, X2                       // 660f6cd2
	PUNPCKLQDQ X11, X2                      // 66410f6cd3
	PUNPCKLQDQ (BX), X11                    // 66440f6c1b
	PUNPCKLQDQ (R11), X11                   // 66450f6c1b
	PUNPCKLQDQ X2, X11                      // 66440f6cda
	PUNPCKLQDQ X11, X11                     // 66450f6cdb
	PUNPCKLWL (BX), M2                      // 0f6113
	PUNPCKLWL (R11), M2                     // 410f6113
	PUNPCKLWL M2, M2                        // 0f61d2
	PUNPCKLWL M3, M2                        // 0f61d3
	PUNPCKLWL (BX), M3                      // 0f611b
	PUNPCKLWL (R11), M3                     // 410f611b
	PUNPCKLWL M2, M3                        // 0f61da
	PUNPCKLWL M3, M3                        // 0f61db
	PUNPCKLWL (BX), X2                      // 660f6113
	PUNPCKLWL (R11), X2                     // 66410f6113
	PUNPCKLWL X2, X2                        // 660f61d2
	PUNPCKLWL X11, X2                       // 66410f61d3
	PUNPCKLWL (BX), X11                     // 66440f611b
	PUNPCKLWL (R11), X11                    // 66450f611b
	PUNPCKLWL X2, X11                       // 66440f61da
	PUNPCKLWL X11, X11                      // 66450f61db
	PUSHQ FS                                // 0fa0
	POPQ AX
	PUSHQ GS                                // 0fa8
	POPQ AX
	PUSHW $61731                            // 666823f1
	POPW AX
	PUSHQ $4045620583                       // 68674523f1
	POPQ AX
	PUSHQ $7                                // 6a07
	POPQ AX
	PUSHW (BX)                              // 66ff33
	POPW AX
	PUSHW (R11)                             // 6641ff33
	POPW AX
	PUSHW DX                                // 66fff2 or 6652
	POPW AX
	PUSHW R11                               // 6641fff3 or 664153
	POPW AX
	PUSHQ (BX)                              // ff33
	POPQ AX
	PUSHQ (R11)                             // 41ff33
	POPQ AX
	PUSHQ DX                                // fff2 or 52
	POPQ AX
	PUSHQ R11                               // 41fff3 or 4153
	POPQ AX
	PUSHFW                                  // 669c
	POPFW
	PUSHFQ                                  // 9c
	POPFQ
	PXOR (BX), M2                           // 0fef13
	PXOR (R11), M2                          // 410fef13
	PXOR M2, M2                             // 0fefd2
	PXOR M3, M2                             // 0fefd3
	PXOR (BX), M3                           // 0fef1b
	PXOR (R11), M3                          // 410fef1b
	PXOR M2, M3                             // 0fefda
	PXOR M3, M3                             // 0fefdb
	PXOR (BX), X2                           // 660fef13
	PXOR (R11), X2                          // 66410fef13
	PXOR X2, X2                             // 660fefd2
	PXOR X11, X2                            // 66410fefd3
	PXOR (BX), X11                          // 66440fef1b
	PXOR (R11), X11                         // 66450fef1b
	PXOR X2, X11                            // 66440fefda
	PXOR X11, X11                           // 66450fefdb
	RCLW $1, (BX)                           // 66d113
	RCLW $1, (R11)                          // 6641d113
	RCLW $1, DX                             // 66d1d2
	RCLW $1, R11                            // 6641d1d3
	RCLW CL, (BX)                           // 66d313
	RCLW CL, (R11)                          // 6641d313
	RCLW CL, DX                             // 66d3d2
	RCLW CL, R11                            // 6641d3d3
	RCLW $7, (BX)                           // 66c11307
	RCLW $7, (R11)                          // 6641c11307
	RCLW $7, DX                             // 66c1d207
	RCLW $7, R11                            // 6641c1d307
	RCLL $1, (BX)                           // d113
	RCLL $1, (R11)                          // 41d113
	RCLL $1, DX                             // d1d2
	RCLL $1, R11                            // 41d1d3
	RCLL CL, (BX)                           // d313
	RCLL CL, (R11)                          // 41d313
	RCLL CL, DX                             // d3d2
	RCLL CL, R11                            // 41d3d3
	RCLL $7, (BX)                           // c11307
	RCLL $7, (R11)                          // 41c11307
	RCLL $7, DX                             // c1d207
	RCLL $7, R11                            // 41c1d307
	RCLQ $1, (BX)                           // 48d113
	RCLQ $1, (R11)                          // 49d113
	RCLQ $1, DX                             // 48d1d2
	RCLQ $1, R11                            // 49d1d3
	RCLQ CL, (BX)                           // 48d313
	RCLQ CL, (R11)                          // 49d313
	RCLQ CL, DX                             // 48d3d2
	RCLQ CL, R11                            // 49d3d3
	RCLQ $7, (BX)                           // 48c11307
	RCLQ $7, (R11)                          // 49c11307
	RCLQ $7, DX                             // 48c1d207
	RCLQ $7, R11                            // 49c1d307
	RCLB $1, (BX)                           // d013
	RCLB $1, (R11)                          // 41d013
	RCLB $1, DL                             // d0d2
	RCLB $1, R11                            // 41d0d3
	RCLB CL, (BX)                           // d213
	RCLB CL, (R11)                          // 41d213
	RCLB CL, DL                             // d2d2
	RCLB CL, R11                            // 41d2d3
	RCLB $7, (BX)                           // c01307
	RCLB $7, (R11)                          // 41c01307
	RCLB $7, DL                             // c0d207
	RCLB $7, R11                            // 41c0d307
	RCPPS (BX), X2                          // 0f5313
	RCPPS (R11), X2                         // 410f5313
	RCPPS X2, X2                            // 0f53d2
	RCPPS X11, X2                           // 410f53d3
	RCPPS (BX), X11                         // 440f531b
	RCPPS (R11), X11                        // 450f531b
	RCPPS X2, X11                           // 440f53da
	RCPPS X11, X11                          // 450f53db
	RCPSS (BX), X2                          // f30f5313
	RCPSS (R11), X2                         // f3410f5313
	RCPSS X2, X2                            // f30f53d2
	RCPSS X11, X2                           // f3410f53d3
	RCPSS (BX), X11                         // f3440f531b
	RCPSS (R11), X11                        // f3450f531b
	RCPSS X2, X11                           // f3440f53da
	RCPSS X11, X11                          // f3450f53db
	RCRW $1, (BX)                           // 66d11b
	RCRW $1, (R11)                          // 6641d11b
	RCRW $1, DX                             // 66d1da
	RCRW $1, R11                            // 6641d1db
	RCRW CL, (BX)                           // 66d31b
	RCRW CL, (R11)                          // 6641d31b
	RCRW CL, DX                             // 66d3da
	RCRW CL, R11                            // 6641d3db
	RCRW $7, (BX)                           // 66c11b07
	RCRW $7, (R11)                          // 6641c11b07
	RCRW $7, DX                             // 66c1da07
	RCRW $7, R11                            // 6641c1db07
	RCRL $1, (BX)                           // d11b
	RCRL $1, (R11)                          // 41d11b
	RCRL $1, DX                             // d1da
	RCRL $1, R11                            // 41d1db
	RCRL CL, (BX)                           // d31b
	RCRL CL, (R11)                          // 41d31b
	RCRL CL, DX                             // d3da
	RCRL CL, R11                            // 41d3db
	RCRL $7, (BX)                           // c11b07
	RCRL $7, (R11)                          // 41c11b07
	RCRL $7, DX                             // c1da07
	RCRL $7, R11                            // 41c1db07
	RCRQ $1, (BX)                           // 48d11b
	RCRQ $1, (R11)                          // 49d11b
	RCRQ $1, DX                             // 48d1da
	RCRQ $1, R11                            // 49d1db
	RCRQ CL, (BX)                           // 48d31b
	RCRQ CL, (R11)                          // 49d31b
	RCRQ CL, DX                             // 48d3da
	RCRQ CL, R11                            // 49d3db
	RCRQ $7, (BX)                           // 48c11b07
	RCRQ $7, (R11)                          // 49c11b07
	RCRQ $7, DX                             // 48c1da07
	RCRQ $7, R11                            // 49c1db07
	RCRB $1, (BX)                           // d01b
	RCRB $1, (R11)                          // 41d01b
	RCRB $1, DL                             // d0da
	RCRB $1, R11                            // 41d0db
	RCRB CL, (BX)                           // d21b
	RCRB CL, (R11)                          // 41d21b
	RCRB CL, DL                             // d2da
	RCRB CL, R11                            // 41d2db
	RCRB $7, (BX)                           // c01b07
	RCRB $7, (R11)                          // 41c01b07
	RCRB $7, DL                             // c0da07
	RCRB $7, R11                            // 41c0db07
	//TODO: RDFSBASE DX                     // f30faec2 or f3480faec2
	//TODO: RDFSBASE R11                    // f3410faec3 or f3490faec3
	//TODO: RDGSBASE DX                     // f30faeca or f3480faeca
	//TODO: RDGSBASE R11                    // f3410faecb or f3490faecb
	RDMSR                                   // 0f32
	//TODO: RDPKRU                          // 0f01ee
	RDPMC                                   // 0f33
	//TODO: RDRAND DX                       // 660fc7f2 or 0fc7f2 or 480fc7f2
	//TODO: RDRAND R11                      // 66410fc7f3 or 410fc7f3 or 490fc7f3
	//TODO: RDSEED DX                       // 660fc7fa or 0fc7fa or 480fc7fa
	//TODO: RDSEED R11                      // 66410fc7fb or 410fc7fb or 490fc7fb
	RDTSC                                   // 0f31
	//TODO: RDTSCP                          // 0f01f9
	JCS 2(PC)
	//TODO: RETQ                            // c3
	JCS 2(PC)
	//TODO: RETQ $0xf123                    // c223f1
	JCS 2(PC)
	//TODO: RETFQ                           // cb
	JCS 2(PC)
	//TODO: RETFQ $0xf123                   // ca23f1
	ROLW $1, (BX)                           // 66d103
	ROLW $1, (R11)                          // 6641d103
	ROLW $1, DX                             // 66d1c2
	ROLW $1, R11                            // 6641d1c3
	ROLW CL, (BX)                           // 66d303
	ROLW CL, (R11)                          // 6641d303
	ROLW CL, DX                             // 66d3c2
	ROLW CL, R11                            // 6641d3c3
	ROLW $7, (BX)                           // 66c10307
	ROLW $7, (R11)                          // 6641c10307
	ROLW $7, DX                             // 66c1c207
	ROLW $7, R11                            // 6641c1c307
	ROLL $1, (BX)                           // d103
	ROLL $1, (R11)                          // 41d103
	ROLL $1, DX                             // d1c2
	ROLL $1, R11                            // 41d1c3
	ROLL CL, (BX)                           // d303
	ROLL CL, (R11)                          // 41d303
	ROLL CL, DX                             // d3c2
	ROLL CL, R11                            // 41d3c3
	ROLL $7, (BX)                           // c10307
	ROLL $7, (R11)                          // 41c10307
	ROLL $7, DX                             // c1c207
	ROLL $7, R11                            // 41c1c307
	ROLQ $1, (BX)                           // 48d103
	ROLQ $1, (R11)                          // 49d103
	ROLQ $1, DX                             // 48d1c2
	ROLQ $1, R11                            // 49d1c3
	ROLQ CL, (BX)                           // 48d303
	ROLQ CL, (R11)                          // 49d303
	ROLQ CL, DX                             // 48d3c2
	ROLQ CL, R11                            // 49d3c3
	ROLQ $7, (BX)                           // 48c10307
	ROLQ $7, (R11)                          // 49c10307
	ROLQ $7, DX                             // 48c1c207
	ROLQ $7, R11                            // 49c1c307
	ROLB $1, (BX)                           // d003
	ROLB $1, (R11)                          // 41d003
	ROLB $1, DL                             // d0c2
	ROLB $1, R11                            // 41d0c3
	ROLB CL, (BX)                           // d203
	ROLB CL, (R11)                          // 41d203
	ROLB CL, DL                             // d2c2
	ROLB CL, R11                            // 41d2c3
	ROLB $7, (BX)                           // c00307
	ROLB $7, (R11)                          // 41c00307
	ROLB $7, DL                             // c0c207
	ROLB $7, R11                            // 41c0c307
	RORW $1, (BX)                           // 66d10b
	RORW $1, (R11)                          // 6641d10b
	RORW $1, DX                             // 66d1ca
	RORW $1, R11                            // 6641d1cb
	RORW CL, (BX)                           // 66d30b
	RORW CL, (R11)                          // 6641d30b
	RORW CL, DX                             // 66d3ca
	RORW CL, R11                            // 6641d3cb
	RORW $7, (BX)                           // 66c10b07
	RORW $7, (R11)                          // 6641c10b07
	RORW $7, DX                             // 66c1ca07
	RORW $7, R11                            // 6641c1cb07
	RORL $1, (BX)                           // d10b
	RORL $1, (R11)                          // 41d10b
	RORL $1, DX                             // d1ca
	RORL $1, R11                            // 41d1cb
	RORL CL, (BX)                           // d30b
	RORL CL, (R11)                          // 41d30b
	RORL CL, DX                             // d3ca
	RORL CL, R11                            // 41d3cb
	RORL $7, (BX)                           // c10b07
	RORL $7, (R11)                          // 41c10b07
	RORL $7, DX                             // c1ca07
	RORL $7, R11                            // 41c1cb07
	RORQ $1, (BX)                           // 48d10b
	RORQ $1, (R11)                          // 49d10b
	RORQ $1, DX                             // 48d1ca
	RORQ $1, R11                            // 49d1cb
	RORQ CL, (BX)                           // 48d30b
	RORQ CL, (R11)                          // 49d30b
	RORQ CL, DX                             // 48d3ca
	RORQ CL, R11                            // 49d3cb
	RORQ $7, (BX)                           // 48c10b07
	RORQ $7, (R11)                          // 49c10b07
	RORQ $7, DX                             // 48c1ca07
	RORQ $7, R11                            // 49c1cb07
	RORB $1, (BX)                           // d00b
	RORB $1, (R11)                          // 41d00b
	RORB $1, DL                             // d0ca
	RORB $1, R11                            // 41d0cb
	RORB CL, (BX)                           // d20b
	RORB CL, (R11)                          // 41d20b
	RORB CL, DL                             // d2ca
	RORB CL, R11                            // 41d2cb
	RORB $7, (BX)                           // c00b07
	RORB $7, (R11)                          // 41c00b07
	RORB $7, DL                             // c0ca07
	RORB $7, R11                            // 41c0cb07
	//TODO: RORXL $7, (BX), DX              // c4e37bf01307
	//TODO: RORXL $7, (R11), DX             // c4c37bf01307
	//TODO: RORXL $7, DX, DX                // c4e37bf0d207
	//TODO: RORXL $7, R11, DX               // c4c37bf0d307
	//TODO: RORXL $7, (BX), R11             // c4637bf01b07
	//TODO: RORXL $7, (R11), R11            // c4437bf01b07
	//TODO: RORXL $7, DX, R11               // c4637bf0da07
	//TODO: RORXL $7, R11, R11              // c4437bf0db07
	//TODO: RORXQ $7, (BX), DX              // c4e3fbf01307
	//TODO: RORXQ $7, (R11), DX             // c4c3fbf01307
	//TODO: RORXQ $7, DX, DX                // c4e3fbf0d207
	//TODO: RORXQ $7, R11, DX               // c4c3fbf0d307
	//TODO: RORXQ $7, (BX), R11             // c463fbf01b07
	//TODO: RORXQ $7, (R11), R11            // c443fbf01b07
	//TODO: RORXQ $7, DX, R11               // c463fbf0da07
	//TODO: RORXQ $7, R11, R11              // c443fbf0db07
	ROUNDPD $7, (BX), X2                    // 660f3a091307
	ROUNDPD $7, (R11), X2                   // 66410f3a091307
	ROUNDPD $7, X2, X2                      // 660f3a09d207
	ROUNDPD $7, X11, X2                     // 66410f3a09d307
	ROUNDPD $7, (BX), X11                   // 66440f3a091b07
	ROUNDPD $7, (R11), X11                  // 66450f3a091b07
	ROUNDPD $7, X2, X11                     // 66440f3a09da07
	ROUNDPD $7, X11, X11                    // 66450f3a09db07
	ROUNDPS $7, (BX), X2                    // 660f3a081307
	ROUNDPS $7, (R11), X2                   // 66410f3a081307
	ROUNDPS $7, X2, X2                      // 660f3a08d207
	ROUNDPS $7, X11, X2                     // 66410f3a08d307
	ROUNDPS $7, (BX), X11                   // 66440f3a081b07
	ROUNDPS $7, (R11), X11                  // 66450f3a081b07
	ROUNDPS $7, X2, X11                     // 66440f3a08da07
	ROUNDPS $7, X11, X11                    // 66450f3a08db07
	ROUNDSD $7, (BX), X2                    // 660f3a0b1307
	ROUNDSD $7, (R11), X2                   // 66410f3a0b1307
	ROUNDSD $7, X2, X2                      // 660f3a0bd207
	ROUNDSD $7, X11, X2                     // 66410f3a0bd307
	ROUNDSD $7, (BX), X11                   // 66440f3a0b1b07
	ROUNDSD $7, (R11), X11                  // 66450f3a0b1b07
	ROUNDSD $7, X2, X11                     // 66440f3a0bda07
	ROUNDSD $7, X11, X11                    // 66450f3a0bdb07
	ROUNDSS $7, (BX), X2                    // 660f3a0a1307
	ROUNDSS $7, (R11), X2                   // 66410f3a0a1307
	ROUNDSS $7, X2, X2                      // 660f3a0ad207
	ROUNDSS $7, X11, X2                     // 66410f3a0ad307
	ROUNDSS $7, (BX), X11                   // 66440f3a0a1b07
	ROUNDSS $7, (R11), X11                  // 66450f3a0a1b07
	ROUNDSS $7, X2, X11                     // 66440f3a0ada07
	ROUNDSS $7, X11, X11                    // 66450f3a0adb07
	RSM                                     // 0faa
	RSQRTPS (BX), X2                        // 0f5213
	RSQRTPS (R11), X2                       // 410f5213
	RSQRTPS X2, X2                          // 0f52d2
	RSQRTPS X11, X2                         // 410f52d3
	RSQRTPS (BX), X11                       // 440f521b
	RSQRTPS (R11), X11                      // 450f521b
	RSQRTPS X2, X11                         // 440f52da
	RSQRTPS X11, X11                        // 450f52db
	RSQRTSS (BX), X2                        // f30f5213
	RSQRTSS (R11), X2                       // f3410f5213
	RSQRTSS X2, X2                          // f30f52d2
	RSQRTSS X11, X2                         // f3410f52d3
	RSQRTSS (BX), X11                       // f3440f521b
	RSQRTSS (R11), X11                      // f3450f521b
	RSQRTSS X2, X11                         // f3440f52da
	RSQRTSS X11, X11                        // f3450f52db
	//TODO: SAHF                            // 9e
	SARW $1, (BX)                           // 66d13b
	SARW $1, (R11)                          // 6641d13b
	SARW $1, DX                             // 66d1fa
	SARW $1, R11                            // 6641d1fb
	SARW CL, (BX)                           // 66d33b
	SARW CL, (R11)                          // 6641d33b
	SARW CL, DX                             // 66d3fa
	SARW CL, R11                            // 6641d3fb
	SARW $7, (BX)                           // 66c13b07
	SARW $7, (R11)                          // 6641c13b07
	SARW $7, DX                             // 66c1fa07
	SARW $7, R11                            // 6641c1fb07
	SARL $1, (BX)                           // d13b
	SARL $1, (R11)                          // 41d13b
	SARL $1, DX                             // d1fa
	SARL $1, R11                            // 41d1fb
	SARL CL, (BX)                           // d33b
	SARL CL, (R11)                          // 41d33b
	SARL CL, DX                             // d3fa
	SARL CL, R11                            // 41d3fb
	SARL $7, (BX)                           // c13b07
	SARL $7, (R11)                          // 41c13b07
	SARL $7, DX                             // c1fa07
	SARL $7, R11                            // 41c1fb07
	SARQ $1, (BX)                           // 48d13b
	SARQ $1, (R11)                          // 49d13b
	SARQ $1, DX                             // 48d1fa
	SARQ $1, R11                            // 49d1fb
	SARQ CL, (BX)                           // 48d33b
	SARQ CL, (R11)                          // 49d33b
	SARQ CL, DX                             // 48d3fa
	SARQ CL, R11                            // 49d3fb
	SARQ $7, (BX)                           // 48c13b07
	SARQ $7, (R11)                          // 49c13b07
	SARQ $7, DX                             // 48c1fa07
	SARQ $7, R11                            // 49c1fb07
	SARB $1, (BX)                           // d03b
	SARB $1, (R11)                          // 41d03b
	SARB $1, DL                             // d0fa
	SARB $1, R11                            // 41d0fb
	SARB CL, (BX)                           // d23b
	SARB CL, (R11)                          // 41d23b
	SARB CL, DL                             // d2fa
	SARB CL, R11                            // 41d2fb
	SARB $7, (BX)                           // c03b07
	SARB $7, (R11)                          // 41c03b07
	SARB $7, DL                             // c0fa07
	SARB $7, R11                            // 41c0fb07
	SARXL R9, (BX), DX                      // c4e232f713
	SARXL R9, (R11), DX                     // c4c232f713
	SARXL R9, DX, DX                        // c4e232f7d2
	SARXL R9, R11, DX                       // c4c232f7d3
	SARXL R9, (BX), R11                     // c46232f71b
	SARXL R9, (R11), R11                    // c44232f71b
	SARXL R9, DX, R11                       // c46232f7da
	SARXL R9, R11, R11                      // c44232f7db
	SARXQ R14, (BX), DX                     // c4e28af713
	SARXQ R14, (R11), DX                    // c4c28af713
	SARXQ R14, DX, DX                       // c4e28af7d2
	SARXQ R14, R11, DX                      // c4c28af7d3
	SARXQ R14, (BX), R11                    // c4628af71b
	SARXQ R14, (R11), R11                   // c4428af71b
	SARXQ R14, DX, R11                      // c4628af7da
	SARXQ R14, R11, R11                     // c4428af7db
	SBBB $7, AL                             // 1c07
	SBBW $61731, AX                         // 661d23f1
	SBBL $4045620583, AX                    // 1d674523f1
	SBBQ $-249346713, AX                    // 481d674523f1
	SBBW $61731, (BX)                       // 66811b23f1
	SBBW $61731, (R11)                      // 6641811b23f1
	SBBW $61731, DX                         // 6681da23f1
	SBBW $61731, R11                        // 664181db23f1
	SBBW $7, (BX)                           // 66831b07
	SBBW $7, (R11)                          // 6641831b07
	SBBW $7, DX                             // 6683da07
	SBBW $7, R11                            // 664183db07
	SBBW DX, (BX)                           // 661913
	SBBW R11, (BX)                          // 6644191b
	SBBW DX, (R11)                          // 66411913
	SBBW R11, (R11)                         // 6645191b
	SBBW DX, DX                             // 6619d2 or 661bd2
	SBBW R11, DX                            // 664419da or 66411bd3
	SBBW DX, R11                            // 664119d3 or 66441bda
	SBBW R11, R11                           // 664519db or 66451bdb
	SBBL $4045620583, (BX)                  // 811b674523f1
	SBBL $4045620583, (R11)                 // 41811b674523f1
	SBBL $4045620583, DX                    // 81da674523f1
	SBBL $4045620583, R11                   // 4181db674523f1
	SBBL $7, (BX)                           // 831b07
	SBBL $7, (R11)                          // 41831b07
	SBBL $7, DX                             // 83da07
	SBBL $7, R11                            // 4183db07
	SBBL DX, (BX)                           // 1913
	SBBL R11, (BX)                          // 44191b
	SBBL DX, (R11)                          // 411913
	SBBL R11, (R11)                         // 45191b
	SBBL DX, DX                             // 19d2 or 1bd2
	SBBL R11, DX                            // 4419da or 411bd3
	SBBL DX, R11                            // 4119d3 or 441bda
	SBBL R11, R11                           // 4519db or 451bdb
	SBBQ $-249346713, (BX)                  // 48811b674523f1
	SBBQ $-249346713, (R11)                 // 49811b674523f1
	SBBQ $-249346713, DX                    // 4881da674523f1
	SBBQ $-249346713, R11                   // 4981db674523f1
	SBBQ $7, (BX)                           // 48831b07
	SBBQ $7, (R11)                          // 49831b07
	SBBQ $7, DX                             // 4883da07
	SBBQ $7, R11                            // 4983db07
	SBBQ DX, (BX)                           // 481913
	SBBQ R11, (BX)                          // 4c191b
	SBBQ DX, (R11)                          // 491913
	SBBQ R11, (R11)                         // 4d191b
	SBBQ DX, DX                             // 4819d2 or 481bd2
	SBBQ R11, DX                            // 4c19da or 491bd3
	SBBQ DX, R11                            // 4919d3 or 4c1bda
	SBBQ R11, R11                           // 4d19db or 4d1bdb
	SBBB $7, (BX)                           // 801b07
	SBBB $7, (R11)                          // 41801b07
	SBBB $7, DL                             // 80da07
	SBBB $7, R11                            // 4180db07
	SBBB DL, (BX)                           // 1813
	SBBB R11, (BX)                          // 44181b
	SBBB DL, (R11)                          // 411813
	SBBB R11, (R11)                         // 45181b
	SBBB DL, DL                             // 18d2 or 1ad2
	SBBB R11, DL                            // 4418da or 411ad3
	SBBB DL, R11                            // 4118d3 or 441ada
	SBBB R11, R11                           // 4518db or 451adb
	SBBW (BX), DX                           // 661b13
	SBBW (R11), DX                          // 66411b13
	SBBW (BX), R11                          // 66441b1b
	SBBW (R11), R11                         // 66451b1b
	SBBL (BX), DX                           // 1b13
	SBBL (R11), DX                          // 411b13
	SBBL (BX), R11                          // 441b1b
	SBBL (R11), R11                         // 451b1b
	SBBQ (BX), DX                           // 481b13
	SBBQ (R11), DX                          // 491b13
	SBBQ (BX), R11                          // 4c1b1b
	SBBQ (R11), R11                         // 4d1b1b
	SBBB (BX), DL                           // 1a13
	SBBB (R11), DL                          // 411a13
	SBBB (BX), R11                          // 441a1b
	SBBB (R11), R11                         // 451a1b
	SCASB                                   // ae
	SCASL                                   // af
	SCASQ                                   // 48af
	SCASW                                   // 66af
	SETHI (BX)                              // 0f9703
	SETHI (R11)                             // 410f9703
	SETHI DL                                // 0f97c2
	SETHI R11                               // 410f97c3
	SETCC (BX)                              // 0f9303
	SETCC (R11)                             // 410f9303
	SETCC DL                                // 0f93c2
	SETCC R11                               // 410f93c3
	SETCS (BX)                              // 0f9203
	SETCS (R11)                             // 410f9203
	SETCS DL                                // 0f92c2
	SETCS R11                               // 410f92c3
	SETLS (BX)                              // 0f9603
	SETLS (R11)                             // 410f9603
	SETLS DL                                // 0f96c2
	SETLS R11                               // 410f96c3
	SETEQ (BX)                              // 0f9403
	SETEQ (R11)                             // 410f9403
	SETEQ DL                                // 0f94c2
	SETEQ R11                               // 410f94c3
	SETGT (BX)                              // 0f9f03
	SETGT (R11)                             // 410f9f03
	SETGT DL                                // 0f9fc2
	SETGT R11                               // 410f9fc3
	SETGE (BX)                              // 0f9d03
	SETGE (R11)                             // 410f9d03
	SETGE DL                                // 0f9dc2
	SETGE R11                               // 410f9dc3
	SETLT (BX)                              // 0f9c03
	SETLT (R11)                             // 410f9c03
	SETLT DL                                // 0f9cc2
	SETLT R11                               // 410f9cc3
	SETLE (BX)                              // 0f9e03
	SETLE (R11)                             // 410f9e03
	SETLE DL                                // 0f9ec2
	SETLE R11                               // 410f9ec3
	SETNE (BX)                              // 0f9503
	SETNE (R11)                             // 410f9503
	SETNE DL                                // 0f95c2
	SETNE R11                               // 410f95c3
	SETOC (BX)                              // 0f9103
	SETOC (R11)                             // 410f9103
	SETOC DL                                // 0f91c2
	SETOC R11                               // 410f91c3
	SETPC (BX)                              // 0f9b03
	SETPC (R11)                             // 410f9b03
	SETPC DL                                // 0f9bc2
	SETPC R11                               // 410f9bc3
	SETPL (BX)                              // 0f9903
	SETPL (R11)                             // 410f9903
	SETPL DL                                // 0f99c2
	SETPL R11                               // 410f99c3
	SETOS (BX)                              // 0f9003
	SETOS (R11)                             // 410f9003
	SETOS DL                                // 0f90c2
	SETOS R11                               // 410f90c3
	SETPS (BX)                              // 0f9a03
	SETPS (R11)                             // 410f9a03
	SETPS DL                                // 0f9ac2
	SETPS R11                               // 410f9ac3
	SETMI (BX)                              // 0f9803
	SETMI (R11)                             // 410f9803
	SETMI DL                                // 0f98c2
	SETMI R11                               // 410f98c3
	SFENCE                                  // 0faef8
	//TODO: SGDT (BX)                       // 0f0103
	//TODO: SGDT (R11)                      // 410f0103
	SHLW $1, (BX)                           // 66d123
	SHLW $1, (R11)                          // 6641d123
	SHLW $1, DX                             // 66d1e2
	SHLW $1, R11                            // 6641d1e3
	SHLW CL, (BX)                           // 66d323
	SHLW CL, (R11)                          // 6641d323
	SHLW CL, DX                             // 66d3e2
	SHLW CL, R11                            // 6641d3e3
	SHLW $7, (BX)                           // 66c12307
	SHLW $7, (R11)                          // 6641c12307
	SHLW $7, DX                             // 66c1e207
	SHLW $7, R11                            // 6641c1e307
	SHLL $1, (BX)                           // d123
	SHLL $1, (R11)                          // 41d123
	SHLL $1, DX                             // d1e2
	SHLL $1, R11                            // 41d1e3
	SHLL CL, (BX)                           // d323
	SHLL CL, (R11)                          // 41d323
	SHLL CL, DX                             // d3e2
	SHLL CL, R11                            // 41d3e3
	SHLL $7, (BX)                           // c12307
	SHLL $7, (R11)                          // 41c12307
	SHLL $7, DX                             // c1e207
	SHLL $7, R11                            // 41c1e307
	SHLQ $1, (BX)                           // 48d123
	SHLQ $1, (R11)                          // 49d123
	SHLQ $1, DX                             // 48d1e2
	SHLQ $1, R11                            // 49d1e3
	SHLQ CL, (BX)                           // 48d323
	SHLQ CL, (R11)                          // 49d323
	SHLQ CL, DX                             // 48d3e2
	SHLQ CL, R11                            // 49d3e3
	SHLQ $7, (BX)                           // 48c12307
	SHLQ $7, (R11)                          // 49c12307
	SHLQ $7, DX                             // 48c1e207
	SHLQ $7, R11                            // 49c1e307
	SHLB $1, (BX)                           // d023
	SHLB $1, (R11)                          // 41d023
	SHLB $1, DL                             // d0e2
	SHLB $1, R11                            // 41d0e3
	SHLB CL, (BX)                           // d223
	SHLB CL, (R11)                          // 41d223
	SHLB CL, DL                             // d2e2
	SHLB CL, R11                            // 41d2e3
	SHLB $7, (BX)                           // c02307
	SHLB $7, (R11)                          // 41c02307
	SHLB $7, DL                             // c0e207
	SHLB $7, R11                            // 41c0e307
	SHLW CL, DX, (BX)                       // 660fa513
	SHLW CL, R11, (BX)                      // 66440fa51b
	SHLW CL, DX, (R11)                      // 66410fa513
	SHLW CL, R11, (R11)                     // 66450fa51b
	SHLW CL, DX, DX                         // 660fa5d2
	SHLW CL, R11, DX                        // 66440fa5da
	SHLW CL, DX, R11                        // 66410fa5d3
	SHLW CL, R11, R11                       // 66450fa5db
	SHLW $7, DX, (BX)                       // 660fa41307
	SHLW $7, R11, (BX)                      // 66440fa41b07
	SHLW $7, DX, (R11)                      // 66410fa41307
	SHLW $7, R11, (R11)                     // 66450fa41b07
	SHLW $7, DX, DX                         // 660fa4d207
	SHLW $7, R11, DX                        // 66440fa4da07
	SHLW $7, DX, R11                        // 66410fa4d307
	SHLW $7, R11, R11                       // 66450fa4db07
	SHLL CL, DX, (BX)                       // 0fa513
	SHLL CL, R11, (BX)                      // 440fa51b
	SHLL CL, DX, (R11)                      // 410fa513
	SHLL CL, R11, (R11)                     // 450fa51b
	SHLL CL, DX, DX                         // 0fa5d2
	SHLL CL, R11, DX                        // 440fa5da
	SHLL CL, DX, R11                        // 410fa5d3
	SHLL CL, R11, R11                       // 450fa5db
	SHLL $7, DX, (BX)                       // 0fa41307
	SHLL $7, R11, (BX)                      // 440fa41b07
	SHLL $7, DX, (R11)                      // 410fa41307
	SHLL $7, R11, (R11)                     // 450fa41b07
	SHLL $7, DX, DX                         // 0fa4d207
	SHLL $7, R11, DX                        // 440fa4da07
	SHLL $7, DX, R11                        // 410fa4d307
	SHLL $7, R11, R11                       // 450fa4db07
	SHLQ CL, DX, (BX)                       // 480fa513
	SHLQ CL, R11, (BX)                      // 4c0fa51b
	SHLQ CL, DX, (R11)                      // 490fa513
	SHLQ CL, R11, (R11)                     // 4d0fa51b
	SHLQ CL, DX, DX                         // 480fa5d2
	SHLQ CL, R11, DX                        // 4c0fa5da
	SHLQ CL, DX, R11                        // 490fa5d3
	SHLQ CL, R11, R11                       // 4d0fa5db
	SHLQ $7, DX, (BX)                       // 480fa41307
	SHLQ $7, R11, (BX)                      // 4c0fa41b07
	SHLQ $7, DX, (R11)                      // 490fa41307
	SHLQ $7, R11, (R11)                     // 4d0fa41b07
	SHLQ $7, DX, DX                         // 480fa4d207
	SHLQ $7, R11, DX                        // 4c0fa4da07
	SHLQ $7, DX, R11                        // 490fa4d307
	SHLQ $7, R11, R11                       // 4d0fa4db07
	SHLXL R9, (BX), DX                      // c4e231f713
	SHLXL R9, (R11), DX                     // c4c231f713
	SHLXL R9, DX, DX                        // c4e231f7d2
	SHLXL R9, R11, DX                       // c4c231f7d3
	SHLXL R9, (BX), R11                     // c46231f71b
	SHLXL R9, (R11), R11                    // c44231f71b
	SHLXL R9, DX, R11                       // c46231f7da
	SHLXL R9, R11, R11                      // c44231f7db
	SHLXQ R14, (BX), DX                     // c4e289f713
	SHLXQ R14, (R11), DX                    // c4c289f713
	SHLXQ R14, DX, DX                       // c4e289f7d2
	SHLXQ R14, R11, DX                      // c4c289f7d3
	SHLXQ R14, (BX), R11                    // c46289f71b
	SHLXQ R14, (R11), R11                   // c44289f71b
	SHLXQ R14, DX, R11                      // c46289f7da
	SHLXQ R14, R11, R11                     // c44289f7db
	SHRW $1, (BX)                           // 66d12b
	SHRW $1, (R11)                          // 6641d12b
	SHRW $1, DX                             // 66d1ea
	SHRW $1, R11                            // 6641d1eb
	SHRW CL, (BX)                           // 66d32b
	SHRW CL, (R11)                          // 6641d32b
	SHRW CL, DX                             // 66d3ea
	SHRW CL, R11                            // 6641d3eb
	SHRW $7, (BX)                           // 66c12b07
	SHRW $7, (R11)                          // 6641c12b07
	SHRW $7, DX                             // 66c1ea07
	SHRW $7, R11                            // 6641c1eb07
	SHRL $1, (BX)                           // d12b
	SHRL $1, (R11)                          // 41d12b
	SHRL $1, DX                             // d1ea
	SHRL $1, R11                            // 41d1eb
	SHRL CL, (BX)                           // d32b
	SHRL CL, (R11)                          // 41d32b
	SHRL CL, DX                             // d3ea
	SHRL CL, R11                            // 41d3eb
	SHRL $7, (BX)                           // c12b07
	SHRL $7, (R11)                          // 41c12b07
	SHRL $7, DX                             // c1ea07
	SHRL $7, R11                            // 41c1eb07
	SHRQ $1, (BX)                           // 48d12b
	SHRQ $1, (R11)                          // 49d12b
	SHRQ $1, DX                             // 48d1ea
	SHRQ $1, R11                            // 49d1eb
	SHRQ CL, (BX)                           // 48d32b
	SHRQ CL, (R11)                          // 49d32b
	SHRQ CL, DX                             // 48d3ea
	SHRQ CL, R11                            // 49d3eb
	SHRQ $7, (BX)                           // 48c12b07
	SHRQ $7, (R11)                          // 49c12b07
	SHRQ $7, DX                             // 48c1ea07
	SHRQ $7, R11                            // 49c1eb07
	SHRB $1, (BX)                           // d02b
	SHRB $1, (R11)                          // 41d02b
	SHRB $1, DL                             // d0ea
	SHRB $1, R11                            // 41d0eb
	SHRB CL, (BX)                           // d22b
	SHRB CL, (R11)                          // 41d22b
	SHRB CL, DL                             // d2ea
	SHRB CL, R11                            // 41d2eb
	SHRB $7, (BX)                           // c02b07
	SHRB $7, (R11)                          // 41c02b07
	SHRB $7, DL                             // c0ea07
	SHRB $7, R11                            // 41c0eb07
	SHRW CL, DX, (BX)                       // 660fad13
	SHRW CL, R11, (BX)                      // 66440fad1b
	SHRW CL, DX, (R11)                      // 66410fad13
	SHRW CL, R11, (R11)                     // 66450fad1b
	SHRW CL, DX, DX                         // 660fadd2
	SHRW CL, R11, DX                        // 66440fadda
	SHRW CL, DX, R11                        // 66410fadd3
	SHRW CL, R11, R11                       // 66450faddb
	SHRW $7, DX, (BX)                       // 660fac1307
	SHRW $7, R11, (BX)                      // 66440fac1b07
	SHRW $7, DX, (R11)                      // 66410fac1307
	SHRW $7, R11, (R11)                     // 66450fac1b07
	SHRW $7, DX, DX                         // 660facd207
	SHRW $7, R11, DX                        // 66440facda07
	SHRW $7, DX, R11                        // 66410facd307
	SHRW $7, R11, R11                       // 66450facdb07
	SHRL CL, DX, (BX)                       // 0fad13
	SHRL CL, R11, (BX)                      // 440fad1b
	SHRL CL, DX, (R11)                      // 410fad13
	SHRL CL, R11, (R11)                     // 450fad1b
	SHRL CL, DX, DX                         // 0fadd2
	SHRL CL, R11, DX                        // 440fadda
	SHRL CL, DX, R11                        // 410fadd3
	SHRL CL, R11, R11                       // 450faddb
	SHRL $7, DX, (BX)                       // 0fac1307
	SHRL $7, R11, (BX)                      // 440fac1b07
	SHRL $7, DX, (R11)                      // 410fac1307
	SHRL $7, R11, (R11)                     // 450fac1b07
	SHRL $7, DX, DX                         // 0facd207
	SHRL $7, R11, DX                        // 440facda07
	SHRL $7, DX, R11                        // 410facd307
	SHRL $7, R11, R11                       // 450facdb07
	SHRQ CL, DX, (BX)                       // 480fad13
	SHRQ CL, R11, (BX)                      // 4c0fad1b
	SHRQ CL, DX, (R11)                      // 490fad13
	SHRQ CL, R11, (R11)                     // 4d0fad1b
	SHRQ CL, DX, DX                         // 480fadd2
	SHRQ CL, R11, DX                        // 4c0fadda
	SHRQ CL, DX, R11                        // 490fadd3
	SHRQ CL, R11, R11                       // 4d0faddb
	SHRQ $7, DX, (BX)                       // 480fac1307
	SHRQ $7, R11, (BX)                      // 4c0fac1b07
	SHRQ $7, DX, (R11)                      // 490fac1307
	SHRQ $7, R11, (R11)                     // 4d0fac1b07
	SHRQ $7, DX, DX                         // 480facd207
	SHRQ $7, R11, DX                        // 4c0facda07
	SHRQ $7, DX, R11                        // 490facd307
	SHRQ $7, R11, R11                       // 4d0facdb07
	SHRXL R9, (BX), DX                      // c4e233f713
	SHRXL R9, (R11), DX                     // c4c233f713
	SHRXL R9, DX, DX                        // c4e233f7d2
	SHRXL R9, R11, DX                       // c4c233f7d3
	SHRXL R9, (BX), R11                     // c46233f71b
	SHRXL R9, (R11), R11                    // c44233f71b
	SHRXL R9, DX, R11                       // c46233f7da
	SHRXL R9, R11, R11                      // c44233f7db
	SHRXQ R14, (BX), DX                     // c4e28bf713
	SHRXQ R14, (R11), DX                    // c4c28bf713
	SHRXQ R14, DX, DX                       // c4e28bf7d2
	SHRXQ R14, R11, DX                      // c4c28bf7d3
	SHRXQ R14, (BX), R11                    // c4628bf71b
	SHRXQ R14, (R11), R11                   // c4428bf71b
	SHRXQ R14, DX, R11                      // c4628bf7da
	SHRXQ R14, R11, R11                     // c4428bf7db
	SHUFPD $7, (BX), X2                     // 660fc61307
	SHUFPD $7, (R11), X2                    // 66410fc61307
	SHUFPD $7, X2, X2                       // 660fc6d207
	SHUFPD $7, X11, X2                      // 66410fc6d307
	SHUFPD $7, (BX), X11                    // 66440fc61b07
	SHUFPD $7, (R11), X11                   // 66450fc61b07
	SHUFPD $7, X2, X11                      // 66440fc6da07
	SHUFPD $7, X11, X11                     // 66450fc6db07
	SHUFPS $7, (BX), X2                     // 0fc61307
	SHUFPS $7, (R11), X2                    // 410fc61307
	SHUFPS $7, X2, X2                       // 0fc6d207
	SHUFPS $7, X11, X2                      // 410fc6d307
	SHUFPS $7, (BX), X11                    // 440fc61b07
	SHUFPS $7, (R11), X11                   // 450fc61b07
	SHUFPS $7, X2, X11                      // 440fc6da07
	SHUFPS $7, X11, X11                     // 450fc6db07
	//TODO: SIDT (BX)                       // 0f010b
	//TODO: SIDT (R11)                      // 410f010b
	//TODO: SLDTW (BX)                      // 660f0003
	//TODO: SLDTW (R11)                     // 66410f0003
	//TODO: SLDTW DX                        // 660f00c2
	//TODO: SLDTW R11                       // 66410f00c3
	//TODO: SLDTL (BX)                      // 0f0003
	//TODO: SLDTL (R11)                     // 410f0003
	//TODO: SLDTL DX                        // 0f00c2
	//TODO: SLDTL R11                       // 410f00c3
	//TODO: SLDTQ (BX)                      // 480f0003
	//TODO: SLDTQ (R11)                     // 490f0003
	//TODO: SLDTQ DX                        // 480f00c2
	//TODO: SLDTQ R11                       // 490f00c3
	//TODO: SMSWW (BX)                      // 660f0123
	//TODO: SMSWW (R11)                     // 66410f0123
	//TODO: SMSWW DX                        // 660f01e2
	//TODO: SMSWW R11                       // 66410f01e3
	//TODO: SMSWL (BX)                      // 0f0123
	//TODO: SMSWL (R11)                     // 410f0123
	//TODO: SMSWL DX                        // 0f01e2
	//TODO: SMSWL R11                       // 410f01e3
	//TODO: SMSWQ (BX)                      // 480f0123
	//TODO: SMSWQ (R11)                     // 490f0123
	//TODO: SMSWQ DX                        // 480f01e2
	//TODO: SMSWQ R11                       // 490f01e3
	SQRTPD (BX), X2                         // 660f5113
	SQRTPD (R11), X2                        // 66410f5113
	SQRTPD X2, X2                           // 660f51d2
	SQRTPD X11, X2                          // 66410f51d3
	SQRTPD (BX), X11                        // 66440f511b
	SQRTPD (R11), X11                       // 66450f511b
	SQRTPD X2, X11                          // 66440f51da
	SQRTPD X11, X11                         // 66450f51db
	SQRTPS (BX), X2                         // 0f5113
	SQRTPS (R11), X2                        // 410f5113
	SQRTPS X2, X2                           // 0f51d2
	SQRTPS X11, X2                          // 410f51d3
	SQRTPS (BX), X11                        // 440f511b
	SQRTPS (R11), X11                       // 450f511b
	SQRTPS X2, X11                          // 440f51da
	SQRTPS X11, X11                         // 450f51db
	SQRTSD (BX), X2                         // f20f5113
	SQRTSD (R11), X2                        // f2410f5113
	SQRTSD X2, X2                           // f20f51d2
	SQRTSD X11, X2                          // f2410f51d3
	SQRTSD (BX), X11                        // f2440f511b
	SQRTSD (R11), X11                       // f2450f511b
	SQRTSD X2, X11                          // f2440f51da
	SQRTSD X11, X11                         // f2450f51db
	SQRTSS (BX), X2                         // f30f5113
	SQRTSS (R11), X2                        // f3410f5113
	SQRTSS X2, X2                           // f30f51d2
	SQRTSS X11, X2                          // f3410f51d3
	SQRTSS (BX), X11                        // f3440f511b
	SQRTSS (R11), X11                       // f3450f511b
	SQRTSS X2, X11                          // f3440f51da
	SQRTSS X11, X11                         // f3450f51db
	//TODO: STAC                            // 0f01cb
	STC                                     // f9
	STD                                     // fd
	STI                                     // fb
	STMXCSR (BX)                            // 0fae1b
	STMXCSR (R11)                           // 410fae1b
	STOSB                                   // aa
	STOSL                                   // ab
	STOSQ                                   // 48ab
	STOSW                                   // 66ab
	//TODO: STRW (BX)                       // 660f000b
	//TODO: STRW (R11)                      // 66410f000b
	//TODO: STRW DX                         // 660f00ca
	//TODO: STRW R11                        // 66410f00cb
	//TODO: STRL (BX)                       // 0f000b
	//TODO: STRL (R11)                      // 410f000b
	//TODO: STRL DX                         // 0f00ca
	//TODO: STRL R11                        // 410f00cb
	//TODO: STRQ (BX)                       // 480f000b
	//TODO: STRQ (R11)                      // 490f000b
	//TODO: STRQ DX                         // 480f00ca
	//TODO: STRQ R11                        // 490f00cb
	SUBB $7, AL                             // 2c07
	SUBW $61731, AX                         // 662d23f1
	SUBL $4045620583, AX                    // 2d674523f1
	SUBQ $-249346713, AX                    // 482d674523f1
	SUBW $61731, (BX)                       // 66812b23f1
	SUBW $61731, (R11)                      // 6641812b23f1
	SUBW $61731, DX                         // 6681ea23f1
	SUBW $61731, R11                        // 664181eb23f1
	SUBW $7, (BX)                           // 66832b07
	SUBW $7, (R11)                          // 6641832b07
	SUBW $7, DX                             // 6683ea07
	SUBW $7, R11                            // 664183eb07
	SUBW DX, (BX)                           // 662913
	SUBW R11, (BX)                          // 6644291b
	SUBW DX, (R11)                          // 66412913
	SUBW R11, (R11)                         // 6645291b
	SUBW DX, DX                             // 6629d2 or 662bd2
	SUBW R11, DX                            // 664429da or 66412bd3
	SUBW DX, R11                            // 664129d3 or 66442bda
	SUBW R11, R11                           // 664529db or 66452bdb
	SUBL $4045620583, (BX)                  // 812b674523f1
	SUBL $4045620583, (R11)                 // 41812b674523f1
	SUBL $4045620583, DX                    // 81ea674523f1
	SUBL $4045620583, R11                   // 4181eb674523f1
	SUBL $7, (BX)                           // 832b07
	SUBL $7, (R11)                          // 41832b07
	SUBL $7, DX                             // 83ea07
	SUBL $7, R11                            // 4183eb07
	SUBL DX, (BX)                           // 2913
	SUBL R11, (BX)                          // 44291b
	SUBL DX, (R11)                          // 412913
	SUBL R11, (R11)                         // 45291b
	SUBL DX, DX                             // 29d2 or 2bd2
	SUBL R11, DX                            // 4429da or 412bd3
	SUBL DX, R11                            // 4129d3 or 442bda
	SUBL R11, R11                           // 4529db or 452bdb
	SUBQ $-249346713, (BX)                  // 48812b674523f1
	SUBQ $-249346713, (R11)                 // 49812b674523f1
	SUBQ $-249346713, DX                    // 4881ea674523f1
	SUBQ $-249346713, R11                   // 4981eb674523f1
	SUBQ $7, (BX)                           // 48832b07
	SUBQ $7, (R11)                          // 49832b07
	SUBQ $7, DX                             // 4883ea07
	SUBQ $7, R11                            // 4983eb07
	SUBQ DX, (BX)                           // 482913
	SUBQ R11, (BX)                          // 4c291b
	SUBQ DX, (R11)                          // 492913
	SUBQ R11, (R11)                         // 4d291b
	SUBQ DX, DX                             // 4829d2 or 482bd2
	SUBQ R11, DX                            // 4c29da or 492bd3
	SUBQ DX, R11                            // 4929d3 or 4c2bda
	SUBQ R11, R11                           // 4d29db or 4d2bdb
	SUBB $7, (BX)                           // 802b07
	SUBB $7, (R11)                          // 41802b07
	SUBB $7, DL                             // 80ea07
	SUBB $7, R11                            // 4180eb07
	SUBB DL, (BX)                           // 2813
	SUBB R11, (BX)                          // 44281b
	SUBB DL, (R11)                          // 412813
	SUBB R11, (R11)                         // 45281b
	SUBB DL, DL                             // 28d2 or 2ad2
	SUBB R11, DL                            // 4428da or 412ad3
	SUBB DL, R11                            // 4128d3 or 442ada
	SUBB R11, R11                           // 4528db or 452adb
	SUBW (BX), DX                           // 662b13
	SUBW (R11), DX                          // 66412b13
	SUBW (BX), R11                          // 66442b1b
	SUBW (R11), R11                         // 66452b1b
	SUBL (BX), DX                           // 2b13
	SUBL (R11), DX                          // 412b13
	SUBL (BX), R11                          // 442b1b
	SUBL (R11), R11                         // 452b1b
	SUBQ (BX), DX                           // 482b13
	SUBQ (R11), DX                          // 492b13
	SUBQ (BX), R11                          // 4c2b1b
	SUBQ (R11), R11                         // 4d2b1b
	SUBB (BX), DL                           // 2a13
	SUBB (R11), DL                          // 412a13
	SUBB (BX), R11                          // 442a1b
	SUBB (R11), R11                         // 452a1b
	SUBPD (BX), X2                          // 660f5c13
	SUBPD (R11), X2                         // 66410f5c13
	SUBPD X2, X2                            // 660f5cd2
	SUBPD X11, X2                           // 66410f5cd3
	SUBPD (BX), X11                         // 66440f5c1b
	SUBPD (R11), X11                        // 66450f5c1b
	SUBPD X2, X11                           // 66440f5cda
	SUBPD X11, X11                          // 66450f5cdb
	SUBPS (BX), X2                          // 0f5c13
	SUBPS (R11), X2                         // 410f5c13
	SUBPS X2, X2                            // 0f5cd2
	SUBPS X11, X2                           // 410f5cd3
	SUBPS (BX), X11                         // 440f5c1b
	SUBPS (R11), X11                        // 450f5c1b
	SUBPS X2, X11                           // 440f5cda
	SUBPS X11, X11                          // 450f5cdb
	SUBSD (BX), X2                          // f20f5c13
	SUBSD (R11), X2                         // f2410f5c13
	SUBSD X2, X2                            // f20f5cd2
	SUBSD X11, X2                           // f2410f5cd3
	SUBSD (BX), X11                         // f2440f5c1b
	SUBSD (R11), X11                        // f2450f5c1b
	SUBSD X2, X11                           // f2440f5cda
	SUBSD X11, X11                          // f2450f5cdb
	SUBSS (BX), X2                          // f30f5c13
	SUBSS (R11), X2                         // f3410f5c13
	SUBSS X2, X2                            // f30f5cd2
	SUBSS X11, X2                           // f3410f5cd3
	SUBSS (BX), X11                         // f3440f5c1b
	SUBSS (R11), X11                        // f3450f5c1b
	SUBSS X2, X11                           // f3440f5cda
	SUBSS X11, X11                          // f3450f5cdb
	SWAPGS                                  // 0f01f8
	SYSCALL                                 // 0f05
	//TODO: SYSENTER                        // 0f34
	//TODO: SYSEXIT                         // 0f35
	SYSRET                                  // 0f07
	TESTB $7, AL                            // a807
	TESTW $61731, AX                        // 66a923f1
	TESTL $4045620583, AX                   // a9674523f1
	TESTQ $-249346713, AX                   // 48a9674523f1
	TESTW $61731, (BX)                      // 66f70323f1
	TESTW $61731, (R11)                     // 6641f70323f1
	TESTW $61731, DX                        // 66f7c223f1
	TESTW $61731, R11                       // 6641f7c323f1
	TESTW DX, (BX)                          // 668513
	TESTW R11, (BX)                         // 6644851b
	TESTW DX, (R11)                         // 66418513
	TESTW R11, (R11)                        // 6645851b
	TESTW DX, DX                            // 6685d2
	TESTW R11, DX                           // 664485da
	TESTW DX, R11                           // 664185d3
	TESTW R11, R11                          // 664585db
	TESTL $4045620583, (BX)                 // f703674523f1
	TESTL $4045620583, (R11)                // 41f703674523f1
	TESTL $4045620583, DX                   // f7c2674523f1
	TESTL $4045620583, R11                  // 41f7c3674523f1
	TESTL DX, (BX)                          // 8513
	TESTL R11, (BX)                         // 44851b
	TESTL DX, (R11)                         // 418513
	TESTL R11, (R11)                        // 45851b
	TESTL DX, DX                            // 85d2
	TESTL R11, DX                           // 4485da
	TESTL DX, R11                           // 4185d3
	TESTL R11, R11                          // 4585db
	TESTQ $-249346713, (BX)                 // 48f703674523f1
	TESTQ $-249346713, (R11)                // 49f703674523f1
	TESTQ $-249346713, DX                   // 48f7c2674523f1
	TESTQ $-249346713, R11                  // 49f7c3674523f1
	TESTQ DX, (BX)                          // 488513
	TESTQ R11, (BX)                         // 4c851b
	TESTQ DX, (R11)                         // 498513
	TESTQ R11, (R11)                        // 4d851b
	TESTQ DX, DX                            // 4885d2
	TESTQ R11, DX                           // 4c85da
	TESTQ DX, R11                           // 4985d3
	TESTQ R11, R11                          // 4d85db
	TESTB $7, (BX)                          // f60307
	TESTB $7, (R11)                         // 41f60307
	TESTB $7, DL                            // f6c207
	TESTB $7, R11                           // 41f6c307
	TESTB DL, (BX)                          // 8413
	TESTB R11, (BX)                         // 44841b
	TESTB DL, (R11)                         // 418413
	TESTB R11, (R11)                        // 45841b
	TESTB DL, DL                            // 84d2
	TESTB R11, DL                           // 4484da
	TESTB DL, R11                           // 4184d3
	TESTB R11, R11                          // 4584db
	//TODO: TZCNTW (BX), DX                 // 66f30fbc13
	//TODO: TZCNTW (R11), DX                // 66f3410fbc13
	//TODO: TZCNTW DX, DX                   // 66f30fbcd2
	//TODO: TZCNTW R11, DX                  // 66f3410fbcd3
	//TODO: TZCNTW (BX), R11                // 66f3440fbc1b
	//TODO: TZCNTW (R11), R11               // 66f3450fbc1b
	//TODO: TZCNTW DX, R11                  // 66f3440fbcda
	//TODO: TZCNTW R11, R11                 // 66f3450fbcdb
	//TODO: TZCNTL (BX), DX                 // f30fbc13
	//TODO: TZCNTL (R11), DX                // f3410fbc13
	//TODO: TZCNTL DX, DX                   // f30fbcd2
	//TODO: TZCNTL R11, DX                  // f3410fbcd3
	//TODO: TZCNTL (BX), R11                // f3440fbc1b
	//TODO: TZCNTL (R11), R11               // f3450fbc1b
	//TODO: TZCNTL DX, R11                  // f3440fbcda
	//TODO: TZCNTL R11, R11                 // f3450fbcdb
	//TODO: TZCNTQ (BX), DX                 // f3480fbc13
	//TODO: TZCNTQ (R11), DX                // f3490fbc13
	//TODO: TZCNTQ DX, DX                   // f3480fbcd2
	//TODO: TZCNTQ R11, DX                  // f3490fbcd3
	//TODO: TZCNTQ (BX), R11                // f34c0fbc1b
	//TODO: TZCNTQ (R11), R11               // f34d0fbc1b
	//TODO: TZCNTQ DX, R11                  // f34c0fbcda
	//TODO: TZCNTQ R11, R11                 // f34d0fbcdb
	UCOMISD (BX), X2                        // 660f2e13
	UCOMISD (R11), X2                       // 66410f2e13
	UCOMISD X2, X2                          // 660f2ed2
	UCOMISD X11, X2                         // 66410f2ed3
	UCOMISD (BX), X11                       // 66440f2e1b
	UCOMISD (R11), X11                      // 66450f2e1b
	UCOMISD X2, X11                         // 66440f2eda
	UCOMISD X11, X11                        // 66450f2edb
	UCOMISS (BX), X2                        // 0f2e13
	UCOMISS (R11), X2                       // 410f2e13
	UCOMISS X2, X2                          // 0f2ed2
	UCOMISS X11, X2                         // 410f2ed3
	UCOMISS (BX), X11                       // 440f2e1b
	UCOMISS (R11), X11                      // 450f2e1b
	UCOMISS X2, X11                         // 440f2eda
	UCOMISS X11, X11                        // 450f2edb
	//TODO: UD1                             // 0fb9
	//TODO: UD2                             // 0f0b
	UNPCKHPD (BX), X2                       // 660f1513
	UNPCKHPD (R11), X2                      // 66410f1513
	UNPCKHPD X2, X2                         // 660f15d2
	UNPCKHPD X11, X2                        // 66410f15d3
	UNPCKHPD (BX), X11                      // 66440f151b
	UNPCKHPD (R11), X11                     // 66450f151b
	UNPCKHPD X2, X11                        // 66440f15da
	UNPCKHPD X11, X11                       // 66450f15db
	UNPCKHPS (BX), X2                       // 0f1513
	UNPCKHPS (R11), X2                      // 410f1513
	UNPCKHPS X2, X2                         // 0f15d2
	UNPCKHPS X11, X2                        // 410f15d3
	UNPCKHPS (BX), X11                      // 440f151b
	UNPCKHPS (R11), X11                     // 450f151b
	UNPCKHPS X2, X11                        // 440f15da
	UNPCKHPS X11, X11                       // 450f15db
	UNPCKLPD (BX), X2                       // 660f1413
	UNPCKLPD (R11), X2                      // 66410f1413
	UNPCKLPD X2, X2                         // 660f14d2
	UNPCKLPD X11, X2                        // 66410f14d3
	UNPCKLPD (BX), X11                      // 66440f141b
	UNPCKLPD (R11), X11                     // 66450f141b
	UNPCKLPD X2, X11                        // 66440f14da
	UNPCKLPD X11, X11                       // 66450f14db
	UNPCKLPS (BX), X2                       // 0f1413
	UNPCKLPS (R11), X2                      // 410f1413
	UNPCKLPS X2, X2                         // 0f14d2
	UNPCKLPS X11, X2                        // 410f14d3
	UNPCKLPS (BX), X11                      // 440f141b
	UNPCKLPS (R11), X11                     // 450f141b
	UNPCKLPS X2, X11                        // 440f14da
	UNPCKLPS X11, X11                       // 450f14db
	//TODO: VADDPD (BX), X9, X2             // c4e1315813 or c5b15813
	//TODO: VADDPD (R11), X9, X2            // c4c1315813
	//TODO: VADDPD X2, X9, X2               // c4e13158d2 or c5b158d2
	//TODO: VADDPD X11, X9, X2              // c4c13158d3
	//TODO: VADDPD (BX), X9, X11            // c46131581b or c531581b
	//TODO: VADDPD (R11), X9, X11           // c44131581b
	//TODO: VADDPD X2, X9, X11              // c4613158da or c53158da
	//TODO: VADDPD X11, X9, X11             // c4413158db
	//TODO: VADDPD (BX), Y15, Y2            // c4e1055813 or c5855813
	//TODO: VADDPD (R11), Y15, Y2           // c4c1055813
	//TODO: VADDPD Y2, Y15, Y2              // c4e10558d2 or c58558d2
	//TODO: VADDPD Y11, Y15, Y2             // c4c10558d3
	//TODO: VADDPD (BX), Y15, Y11           // c46105581b or c505581b
	//TODO: VADDPD (R11), Y15, Y11          // c44105581b
	//TODO: VADDPD Y2, Y15, Y11             // c4610558da or c50558da
	//TODO: VADDPD Y11, Y15, Y11            // c4410558db
	//TODO: VADDPS (BX), X9, X2             // c4e1305813 or c5b05813
	//TODO: VADDPS (R11), X9, X2            // c4c1305813
	//TODO: VADDPS X2, X9, X2               // c4e13058d2 or c5b058d2
	//TODO: VADDPS X11, X9, X2              // c4c13058d3
	//TODO: VADDPS (BX), X9, X11            // c46130581b or c530581b
	//TODO: VADDPS (R11), X9, X11           // c44130581b
	//TODO: VADDPS X2, X9, X11              // c4613058da or c53058da
	//TODO: VADDPS X11, X9, X11             // c4413058db
	//TODO: VADDPS (BX), Y15, Y2            // c4e1045813 or c5845813
	//TODO: VADDPS (R11), Y15, Y2           // c4c1045813
	//TODO: VADDPS Y2, Y15, Y2              // c4e10458d2 or c58458d2
	//TODO: VADDPS Y11, Y15, Y2             // c4c10458d3
	//TODO: VADDPS (BX), Y15, Y11           // c46104581b or c504581b
	//TODO: VADDPS (R11), Y15, Y11          // c44104581b
	//TODO: VADDPS Y2, Y15, Y11             // c4610458da or c50458da
	//TODO: VADDPS Y11, Y15, Y11            // c4410458db
	//TODO: VADDSD (BX), X9, X2             // c4e1335813 or c5b35813
	//TODO: VADDSD (R11), X9, X2            // c4c1335813
	//TODO: VADDSD X2, X9, X2               // c4e13358d2 or c5b358d2
	//TODO: VADDSD X11, X9, X2              // c4c13358d3
	//TODO: VADDSD (BX), X9, X11            // c46133581b or c533581b
	//TODO: VADDSD (R11), X9, X11           // c44133581b
	//TODO: VADDSD X2, X9, X11              // c4613358da or c53358da
	//TODO: VADDSD X11, X9, X11             // c4413358db
	//TODO: VADDSS (BX), X9, X2             // c4e1325813 or c5b25813
	//TODO: VADDSS (R11), X9, X2            // c4c1325813
	//TODO: VADDSS X2, X9, X2               // c4e13258d2 or c5b258d2
	//TODO: VADDSS X11, X9, X2              // c4c13258d3
	//TODO: VADDSS (BX), X9, X11            // c46132581b or c532581b
	//TODO: VADDSS (R11), X9, X11           // c44132581b
	//TODO: VADDSS X2, X9, X11              // c4613258da or c53258da
	//TODO: VADDSS X11, X9, X11             // c4413258db
	//TODO: VADDSUBPD (BX), X9, X2          // c4e131d013 or c5b1d013
	//TODO: VADDSUBPD (R11), X9, X2         // c4c131d013
	//TODO: VADDSUBPD X2, X9, X2            // c4e131d0d2 or c5b1d0d2
	//TODO: VADDSUBPD X11, X9, X2           // c4c131d0d3
	//TODO: VADDSUBPD (BX), X9, X11         // c46131d01b or c531d01b
	//TODO: VADDSUBPD (R11), X9, X11        // c44131d01b
	//TODO: VADDSUBPD X2, X9, X11           // c46131d0da or c531d0da
	//TODO: VADDSUBPD X11, X9, X11          // c44131d0db
	//TODO: VADDSUBPD (BX), Y15, Y2         // c4e105d013 or c585d013
	//TODO: VADDSUBPD (R11), Y15, Y2        // c4c105d013
	//TODO: VADDSUBPD Y2, Y15, Y2           // c4e105d0d2 or c585d0d2
	//TODO: VADDSUBPD Y11, Y15, Y2          // c4c105d0d3
	//TODO: VADDSUBPD (BX), Y15, Y11        // c46105d01b or c505d01b
	//TODO: VADDSUBPD (R11), Y15, Y11       // c44105d01b
	//TODO: VADDSUBPD Y2, Y15, Y11          // c46105d0da or c505d0da
	//TODO: VADDSUBPD Y11, Y15, Y11         // c44105d0db
	//TODO: VADDSUBPS (BX), X9, X2          // c4e133d013 or c5b3d013
	//TODO: VADDSUBPS (R11), X9, X2         // c4c133d013
	//TODO: VADDSUBPS X2, X9, X2            // c4e133d0d2 or c5b3d0d2
	//TODO: VADDSUBPS X11, X9, X2           // c4c133d0d3
	//TODO: VADDSUBPS (BX), X9, X11         // c46133d01b or c533d01b
	//TODO: VADDSUBPS (R11), X9, X11        // c44133d01b
	//TODO: VADDSUBPS X2, X9, X11           // c46133d0da or c533d0da
	//TODO: VADDSUBPS X11, X9, X11          // c44133d0db
	//TODO: VADDSUBPS (BX), Y15, Y2         // c4e107d013 or c587d013
	//TODO: VADDSUBPS (R11), Y15, Y2        // c4c107d013
	//TODO: VADDSUBPS Y2, Y15, Y2           // c4e107d0d2 or c587d0d2
	//TODO: VADDSUBPS Y11, Y15, Y2          // c4c107d0d3
	//TODO: VADDSUBPS (BX), Y15, Y11        // c46107d01b or c507d01b
	//TODO: VADDSUBPS (R11), Y15, Y11       // c44107d01b
	//TODO: VADDSUBPS Y2, Y15, Y11          // c46107d0da or c507d0da
	//TODO: VADDSUBPS Y11, Y15, Y11         // c44107d0db
	//TODO: VAESDEC (BX), X9, X2            // c4e231de13
	//TODO: VAESDEC (R11), X9, X2           // c4c231de13
	//TODO: VAESDEC X2, X9, X2              // c4e231ded2
	//TODO: VAESDEC X11, X9, X2             // c4c231ded3
	//TODO: VAESDEC (BX), X9, X11           // c46231de1b
	//TODO: VAESDEC (R11), X9, X11          // c44231de1b
	//TODO: VAESDEC X2, X9, X11             // c46231deda
	//TODO: VAESDEC X11, X9, X11            // c44231dedb
	//TODO: VAESDECLAST (BX), X9, X2        // c4e231df13
	//TODO: VAESDECLAST (R11), X9, X2       // c4c231df13
	//TODO: VAESDECLAST X2, X9, X2          // c4e231dfd2
	//TODO: VAESDECLAST X11, X9, X2         // c4c231dfd3
	//TODO: VAESDECLAST (BX), X9, X11       // c46231df1b
	//TODO: VAESDECLAST (R11), X9, X11      // c44231df1b
	//TODO: VAESDECLAST X2, X9, X11         // c46231dfda
	//TODO: VAESDECLAST X11, X9, X11        // c44231dfdb
	//TODO: VAESENC (BX), X9, X2            // c4e231dc13
	//TODO: VAESENC (R11), X9, X2           // c4c231dc13
	//TODO: VAESENC X2, X9, X2              // c4e231dcd2
	//TODO: VAESENC X11, X9, X2             // c4c231dcd3
	//TODO: VAESENC (BX), X9, X11           // c46231dc1b
	//TODO: VAESENC (R11), X9, X11          // c44231dc1b
	//TODO: VAESENC X2, X9, X11             // c46231dcda
	//TODO: VAESENC X11, X9, X11            // c44231dcdb
	//TODO: VAESENCLAST (BX), X9, X2        // c4e231dd13
	//TODO: VAESENCLAST (R11), X9, X2       // c4c231dd13
	//TODO: VAESENCLAST X2, X9, X2          // c4e231ddd2
	//TODO: VAESENCLAST X11, X9, X2         // c4c231ddd3
	//TODO: VAESENCLAST (BX), X9, X11       // c46231dd1b
	//TODO: VAESENCLAST (R11), X9, X11      // c44231dd1b
	//TODO: VAESENCLAST X2, X9, X11         // c46231ddda
	//TODO: VAESENCLAST X11, X9, X11        // c44231dddb
	//TODO: VAESIMC (BX), X2                // c4e279db13
	//TODO: VAESIMC (R11), X2               // c4c279db13
	//TODO: VAESIMC X2, X2                  // c4e279dbd2
	//TODO: VAESIMC X11, X2                 // c4c279dbd3
	//TODO: VAESIMC (BX), X11               // c46279db1b
	//TODO: VAESIMC (R11), X11              // c44279db1b
	//TODO: VAESIMC X2, X11                 // c46279dbda
	//TODO: VAESIMC X11, X11                // c44279dbdb
	//TODO: VAESKEYGENASSIST $7, (BX), X2   // c4e379df1307
	//TODO: VAESKEYGENASSIST $7, (R11), X2  // c4c379df1307
	//TODO: VAESKEYGENASSIST $7, X2, X2     // c4e379dfd207
	//TODO: VAESKEYGENASSIST $7, X11, X2    // c4c379dfd307
	//TODO: VAESKEYGENASSIST $7, (BX), X11  // c46379df1b07
	//TODO: VAESKEYGENASSIST $7, (R11), X11 // c44379df1b07
	//TODO: VAESKEYGENASSIST $7, X2, X11    // c46379dfda07
	//TODO: VAESKEYGENASSIST $7, X11, X11   // c44379dfdb07
	//TODO: VANDNPD (BX), X9, X2            // c4e1315513 or c5b15513
	//TODO: VANDNPD (R11), X9, X2           // c4c1315513
	//TODO: VANDNPD X2, X9, X2              // c4e13155d2 or c5b155d2
	//TODO: VANDNPD X11, X9, X2             // c4c13155d3
	//TODO: VANDNPD (BX), X9, X11           // c46131551b or c531551b
	//TODO: VANDNPD (R11), X9, X11          // c44131551b
	//TODO: VANDNPD X2, X9, X11             // c4613155da or c53155da
	//TODO: VANDNPD X11, X9, X11            // c4413155db
	//TODO: VANDNPD (BX), Y15, Y2           // c4e1055513 or c5855513
	//TODO: VANDNPD (R11), Y15, Y2          // c4c1055513
	//TODO: VANDNPD Y2, Y15, Y2             // c4e10555d2 or c58555d2
	//TODO: VANDNPD Y11, Y15, Y2            // c4c10555d3
	//TODO: VANDNPD (BX), Y15, Y11          // c46105551b or c505551b
	//TODO: VANDNPD (R11), Y15, Y11         // c44105551b
	//TODO: VANDNPD Y2, Y15, Y11            // c4610555da or c50555da
	//TODO: VANDNPD Y11, Y15, Y11           // c4410555db
	//TODO: VANDNPS (BX), X9, X2            // c4e1305513 or c5b05513
	//TODO: VANDNPS (R11), X9, X2           // c4c1305513
	//TODO: VANDNPS X2, X9, X2              // c4e13055d2 or c5b055d2
	//TODO: VANDNPS X11, X9, X2             // c4c13055d3
	//TODO: VANDNPS (BX), X9, X11           // c46130551b or c530551b
	//TODO: VANDNPS (R11), X9, X11          // c44130551b
	//TODO: VANDNPS X2, X9, X11             // c4613055da or c53055da
	//TODO: VANDNPS X11, X9, X11            // c4413055db
	//TODO: VANDNPS (BX), Y15, Y2           // c4e1045513 or c5845513
	//TODO: VANDNPS (R11), Y15, Y2          // c4c1045513
	//TODO: VANDNPS Y2, Y15, Y2             // c4e10455d2 or c58455d2
	//TODO: VANDNPS Y11, Y15, Y2            // c4c10455d3
	//TODO: VANDNPS (BX), Y15, Y11          // c46104551b or c504551b
	//TODO: VANDNPS (R11), Y15, Y11         // c44104551b
	//TODO: VANDNPS Y2, Y15, Y11            // c4610455da or c50455da
	//TODO: VANDNPS Y11, Y15, Y11           // c4410455db
	//TODO: VANDPD (BX), X9, X2             // c4e1315413 or c5b15413
	//TODO: VANDPD (R11), X9, X2            // c4c1315413
	//TODO: VANDPD X2, X9, X2               // c4e13154d2 or c5b154d2
	//TODO: VANDPD X11, X9, X2              // c4c13154d3
	//TODO: VANDPD (BX), X9, X11            // c46131541b or c531541b
	//TODO: VANDPD (R11), X9, X11           // c44131541b
	//TODO: VANDPD X2, X9, X11              // c4613154da or c53154da
	//TODO: VANDPD X11, X9, X11             // c4413154db
	//TODO: VANDPD (BX), Y15, Y2            // c4e1055413 or c5855413
	//TODO: VANDPD (R11), Y15, Y2           // c4c1055413
	//TODO: VANDPD Y2, Y15, Y2              // c4e10554d2 or c58554d2
	//TODO: VANDPD Y11, Y15, Y2             // c4c10554d3
	//TODO: VANDPD (BX), Y15, Y11           // c46105541b or c505541b
	//TODO: VANDPD (R11), Y15, Y11          // c44105541b
	//TODO: VANDPD Y2, Y15, Y11             // c4610554da or c50554da
	//TODO: VANDPD Y11, Y15, Y11            // c4410554db
	//TODO: VANDPS (BX), X9, X2             // c4e1305413 or c5b05413
	//TODO: VANDPS (R11), X9, X2            // c4c1305413
	//TODO: VANDPS X2, X9, X2               // c4e13054d2 or c5b054d2
	//TODO: VANDPS X11, X9, X2              // c4c13054d3
	//TODO: VANDPS (BX), X9, X11            // c46130541b or c530541b
	//TODO: VANDPS (R11), X9, X11           // c44130541b
	//TODO: VANDPS X2, X9, X11              // c4613054da or c53054da
	//TODO: VANDPS X11, X9, X11             // c4413054db
	//TODO: VANDPS (BX), Y15, Y2            // c4e1045413 or c5845413
	//TODO: VANDPS (R11), Y15, Y2           // c4c1045413
	//TODO: VANDPS Y2, Y15, Y2              // c4e10454d2 or c58454d2
	//TODO: VANDPS Y11, Y15, Y2             // c4c10454d3
	//TODO: VANDPS (BX), Y15, Y11           // c46104541b or c504541b
	//TODO: VANDPS (R11), Y15, Y11          // c44104541b
	//TODO: VANDPS Y2, Y15, Y11             // c4610454da or c50454da
	//TODO: VANDPS Y11, Y15, Y11            // c4410454db
	//TODO: VBLENDPD $7, (BX), X9, X2       // c4e3310d1307
	//TODO: VBLENDPD $7, (R11), X9, X2      // c4c3310d1307
	//TODO: VBLENDPD $7, X2, X9, X2         // c4e3310dd207
	//TODO: VBLENDPD $7, X11, X9, X2        // c4c3310dd307
	//TODO: VBLENDPD $7, (BX), X9, X11      // c463310d1b07
	//TODO: VBLENDPD $7, (R11), X9, X11     // c443310d1b07
	//TODO: VBLENDPD $7, X2, X9, X11        // c463310dda07
	//TODO: VBLENDPD $7, X11, X9, X11       // c443310ddb07
	//TODO: VBLENDPD $7, (BX), Y15, Y2      // c4e3050d1307
	//TODO: VBLENDPD $7, (R11), Y15, Y2     // c4c3050d1307
	//TODO: VBLENDPD $7, Y2, Y15, Y2        // c4e3050dd207
	//TODO: VBLENDPD $7, Y11, Y15, Y2       // c4c3050dd307
	//TODO: VBLENDPD $7, (BX), Y15, Y11     // c463050d1b07
	//TODO: VBLENDPD $7, (R11), Y15, Y11    // c443050d1b07
	//TODO: VBLENDPD $7, Y2, Y15, Y11       // c463050dda07
	//TODO: VBLENDPD $7, Y11, Y15, Y11      // c443050ddb07
	//TODO: VBLENDPS $7, (BX), X9, X2       // c4e3310c1307
	//TODO: VBLENDPS $7, (R11), X9, X2      // c4c3310c1307
	//TODO: VBLENDPS $7, X2, X9, X2         // c4e3310cd207
	//TODO: VBLENDPS $7, X11, X9, X2        // c4c3310cd307
	//TODO: VBLENDPS $7, (BX), X9, X11      // c463310c1b07
	//TODO: VBLENDPS $7, (R11), X9, X11     // c443310c1b07
	//TODO: VBLENDPS $7, X2, X9, X11        // c463310cda07
	//TODO: VBLENDPS $7, X11, X9, X11       // c443310cdb07
	//TODO: VBLENDPS $7, (BX), Y15, Y2      // c4e3050c1307
	//TODO: VBLENDPS $7, (R11), Y15, Y2     // c4c3050c1307
	//TODO: VBLENDPS $7, Y2, Y15, Y2        // c4e3050cd207
	//TODO: VBLENDPS $7, Y11, Y15, Y2       // c4c3050cd307
	//TODO: VBLENDPS $7, (BX), Y15, Y11     // c463050c1b07
	//TODO: VBLENDPS $7, (R11), Y15, Y11    // c443050c1b07
	//TODO: VBLENDPS $7, Y2, Y15, Y11       // c463050cda07
	//TODO: VBLENDPS $7, Y11, Y15, Y11      // c443050cdb07
	//TODO: VBLENDVPD XMM12, (BX), X9, X2   // c4e3314b13c0
	//TODO: VBLENDVPD XMM12, (R11), X9, X2  // c4c3314b13c0
	//TODO: VBLENDVPD XMM12, X2, X9, X2     // c4e3314bd2c0
	//TODO: VBLENDVPD XMM12, X11, X9, X2    // c4c3314bd3c0
	//TODO: VBLENDVPD XMM12, (BX), X9, X11  // c463314b1bc0
	//TODO: VBLENDVPD XMM12, (R11), X9, X11 // c443314b1bc0
	//TODO: VBLENDVPD XMM12, X2, X9, X11    // c463314bdac0
	//TODO: VBLENDVPD XMM12, X11, X9, X11   // c443314bdbc0
	//TODO: VBLENDVPD YMM13, (BX), Y15, Y2  // c4e3054b13d0
	//TODO: VBLENDVPD YMM13, (R11), Y15, Y2 // c4c3054b13d0
	//TODO: VBLENDVPD YMM13, Y2, Y15, Y2    // c4e3054bd2d0
	//TODO: VBLENDVPD YMM13, Y11, Y15, Y2   // c4c3054bd3d0
	//TODO: VBLENDVPD YMM13, (BX), Y15, Y11 // c463054b1bd0
	//TODO: VBLENDVPD YMM13, (R11), Y15, Y11 // c443054b1bd0
	//TODO: VBLENDVPD YMM13, Y2, Y15, Y11   // c463054bdad0
	//TODO: VBLENDVPD YMM13, Y11, Y15, Y11  // c443054bdbd0
	//TODO: VBLENDVPS XMM12, (BX), X9, X2   // c4e3314a13c0
	//TODO: VBLENDVPS XMM12, (R11), X9, X2  // c4c3314a13c0
	//TODO: VBLENDVPS XMM12, X2, X9, X2     // c4e3314ad2c0
	//TODO: VBLENDVPS XMM12, X11, X9, X2    // c4c3314ad3c0
	//TODO: VBLENDVPS XMM12, (BX), X9, X11  // c463314a1bc0
	//TODO: VBLENDVPS XMM12, (R11), X9, X11 // c443314a1bc0
	//TODO: VBLENDVPS XMM12, X2, X9, X11    // c463314adac0
	//TODO: VBLENDVPS XMM12, X11, X9, X11   // c443314adbc0
	//TODO: VBLENDVPS YMM13, (BX), Y15, Y2  // c4e3054a13d0
	//TODO: VBLENDVPS YMM13, (R11), Y15, Y2 // c4c3054a13d0
	//TODO: VBLENDVPS YMM13, Y2, Y15, Y2    // c4e3054ad2d0
	//TODO: VBLENDVPS YMM13, Y11, Y15, Y2   // c4c3054ad3d0
	//TODO: VBLENDVPS YMM13, (BX), Y15, Y11 // c463054a1bd0
	//TODO: VBLENDVPS YMM13, (R11), Y15, Y11 // c443054a1bd0
	//TODO: VBLENDVPS YMM13, Y2, Y15, Y11   // c463054adad0
	//TODO: VBLENDVPS YMM13, Y11, Y15, Y11  // c443054adbd0
	//TODO: VBROADCASTF128 (BX), Y2         // c4e27d1a13
	//TODO: VBROADCASTF128 (R11), Y2        // c4c27d1a13
	//TODO: VBROADCASTF128 (BX), Y11        // c4627d1a1b
	//TODO: VBROADCASTF128 (R11), Y11       // c4427d1a1b
	//TODO: VBROADCASTI128 (BX), Y2         // c4e27d5a13
	//TODO: VBROADCASTI128 (R11), Y2        // c4c27d5a13
	//TODO: VBROADCASTI128 (BX), Y11        // c4627d5a1b
	//TODO: VBROADCASTI128 (R11), Y11       // c4427d5a1b
	//TODO: VBROADCASTSD (BX), Y2           // c4e27d1913
	//TODO: VBROADCASTSD (R11), Y2          // c4c27d1913
	//TODO: VBROADCASTSD (BX), Y11          // c4627d191b
	//TODO: VBROADCASTSD (R11), Y11         // c4427d191b
	//TODO: VBROADCASTSD X2, Y2             // c4e27d19d2
	//TODO: VBROADCASTSD X11, Y2            // c4c27d19d3
	//TODO: VBROADCASTSD X2, Y11            // c4627d19da
	//TODO: VBROADCASTSD X11, Y11           // c4427d19db
	//TODO: VBROADCASTSS (BX), X2           // c4e2791813
	//TODO: VBROADCASTSS (R11), X2          // c4c2791813
	//TODO: VBROADCASTSS (BX), X11          // c46279181b
	//TODO: VBROADCASTSS (R11), X11         // c44279181b
	//TODO: VBROADCASTSS X2, X2             // c4e27918d2
	//TODO: VBROADCASTSS X11, X2            // c4c27918d3
	//TODO: VBROADCASTSS X2, X11            // c4627918da
	//TODO: VBROADCASTSS X11, X11           // c4427918db
	//TODO: VBROADCASTSS (BX), Y2           // c4e27d1813
	//TODO: VBROADCASTSS (R11), Y2          // c4c27d1813
	//TODO: VBROADCASTSS (BX), Y11          // c4627d181b
	//TODO: VBROADCASTSS (R11), Y11         // c4427d181b
	//TODO: VBROADCASTSS X2, Y2             // c4e27d18d2
	//TODO: VBROADCASTSS X11, Y2            // c4c27d18d3
	//TODO: VBROADCASTSS X2, Y11            // c4627d18da
	//TODO: VBROADCASTSS X11, Y11           // c4427d18db
	//TODO: VCMPPD $7, (BX), X9, X2         // c4e131c21307 or c5b1c21307
	//TODO: VCMPPD $7, (R11), X9, X2        // c4c131c21307
	//TODO: VCMPPD $7, X2, X9, X2           // c4e131c2d207 or c5b1c2d207
	//TODO: VCMPPD $7, X11, X9, X2          // c4c131c2d307
	//TODO: VCMPPD $7, (BX), X9, X11        // c46131c21b07 or c531c21b07
	//TODO: VCMPPD $7, (R11), X9, X11       // c44131c21b07
	//TODO: VCMPPD $7, X2, X9, X11          // c46131c2da07 or c531c2da07
	//TODO: VCMPPD $7, X11, X9, X11         // c44131c2db07
	//TODO: VCMPPD $7, (BX), Y15, Y2        // c4e105c21307 or c585c21307
	//TODO: VCMPPD $7, (R11), Y15, Y2       // c4c105c21307
	//TODO: VCMPPD $7, Y2, Y15, Y2          // c4e105c2d207 or c585c2d207
	//TODO: VCMPPD $7, Y11, Y15, Y2         // c4c105c2d307
	//TODO: VCMPPD $7, (BX), Y15, Y11       // c46105c21b07 or c505c21b07
	//TODO: VCMPPD $7, (R11), Y15, Y11      // c44105c21b07
	//TODO: VCMPPD $7, Y2, Y15, Y11         // c46105c2da07 or c505c2da07
	//TODO: VCMPPD $7, Y11, Y15, Y11        // c44105c2db07
	//TODO: VCMPPS $7, (BX), X9, X2         // c4e130c21307 or c5b0c21307
	//TODO: VCMPPS $7, (R11), X9, X2        // c4c130c21307
	//TODO: VCMPPS $7, X2, X9, X2           // c4e130c2d207 or c5b0c2d207
	//TODO: VCMPPS $7, X11, X9, X2          // c4c130c2d307
	//TODO: VCMPPS $7, (BX), X9, X11        // c46130c21b07 or c530c21b07
	//TODO: VCMPPS $7, (R11), X9, X11       // c44130c21b07
	//TODO: VCMPPS $7, X2, X9, X11          // c46130c2da07 or c530c2da07
	//TODO: VCMPPS $7, X11, X9, X11         // c44130c2db07
	//TODO: VCMPPS $7, (BX), Y15, Y2        // c4e104c21307 or c584c21307
	//TODO: VCMPPS $7, (R11), Y15, Y2       // c4c104c21307
	//TODO: VCMPPS $7, Y2, Y15, Y2          // c4e104c2d207 or c584c2d207
	//TODO: VCMPPS $7, Y11, Y15, Y2         // c4c104c2d307
	//TODO: VCMPPS $7, (BX), Y15, Y11       // c46104c21b07 or c504c21b07
	//TODO: VCMPPS $7, (R11), Y15, Y11      // c44104c21b07
	//TODO: VCMPPS $7, Y2, Y15, Y11         // c46104c2da07 or c504c2da07
	//TODO: VCMPPS $7, Y11, Y15, Y11        // c44104c2db07
	//TODO: VCMPSD $7, (BX), X9, X2         // c4e133c21307 or c5b3c21307
	//TODO: VCMPSD $7, (R11), X9, X2        // c4c133c21307
	//TODO: VCMPSD $7, X2, X9, X2           // c4e133c2d207 or c5b3c2d207
	//TODO: VCMPSD $7, X11, X9, X2          // c4c133c2d307
	//TODO: VCMPSD $7, (BX), X9, X11        // c46133c21b07 or c533c21b07
	//TODO: VCMPSD $7, (R11), X9, X11       // c44133c21b07
	//TODO: VCMPSD $7, X2, X9, X11          // c46133c2da07 or c533c2da07
	//TODO: VCMPSD $7, X11, X9, X11         // c44133c2db07
	//TODO: VCMPSS $7, (BX), X9, X2         // c4e132c21307 or c5b2c21307
	//TODO: VCMPSS $7, (R11), X9, X2        // c4c132c21307
	//TODO: VCMPSS $7, X2, X9, X2           // c4e132c2d207 or c5b2c2d207
	//TODO: VCMPSS $7, X11, X9, X2          // c4c132c2d307
	//TODO: VCMPSS $7, (BX), X9, X11        // c46132c21b07 or c532c21b07
	//TODO: VCMPSS $7, (R11), X9, X11       // c44132c21b07
	//TODO: VCMPSS $7, X2, X9, X11          // c46132c2da07 or c532c2da07
	//TODO: VCMPSS $7, X11, X9, X11         // c44132c2db07
	//TODO: VCOMISD (BX), X2                // c4e1792f13 or c5f92f13
	//TODO: VCOMISD (R11), X2               // c4c1792f13
	//TODO: VCOMISD X2, X2                  // c4e1792fd2 or c5f92fd2
	//TODO: VCOMISD X11, X2                 // c4c1792fd3
	//TODO: VCOMISD (BX), X11               // c461792f1b or c5792f1b
	//TODO: VCOMISD (R11), X11              // c441792f1b
	//TODO: VCOMISD X2, X11                 // c461792fda or c5792fda
	//TODO: VCOMISD X11, X11                // c441792fdb
	//TODO: VCOMISS (BX), X2                // c4e1782f13 or c5f82f13
	//TODO: VCOMISS (R11), X2               // c4c1782f13
	//TODO: VCOMISS X2, X2                  // c4e1782fd2 or c5f82fd2
	//TODO: VCOMISS X11, X2                 // c4c1782fd3
	//TODO: VCOMISS (BX), X11               // c461782f1b or c5782f1b
	//TODO: VCOMISS (R11), X11              // c441782f1b
	//TODO: VCOMISS X2, X11                 // c461782fda or c5782fda
	//TODO: VCOMISS X11, X11                // c441782fdb
	//TODO: VCVTDQ2PD (BX), X2              // c4e17ae613 or c5fae613
	//TODO: VCVTDQ2PD (R11), X2             // c4c17ae613
	//TODO: VCVTDQ2PD X2, X2                // c4e17ae6d2 or c5fae6d2
	//TODO: VCVTDQ2PD X11, X2               // c4c17ae6d3
	//TODO: VCVTDQ2PD (BX), X11             // c4617ae61b or c57ae61b
	//TODO: VCVTDQ2PD (R11), X11            // c4417ae61b
	//TODO: VCVTDQ2PD X2, X11               // c4617ae6da or c57ae6da
	//TODO: VCVTDQ2PD X11, X11              // c4417ae6db
	//TODO: VCVTDQ2PD (BX), Y2              // c4e17ee613 or c5fee613
	//TODO: VCVTDQ2PD (R11), Y2             // c4c17ee613
	//TODO: VCVTDQ2PD X2, Y2                // c4e17ee6d2 or c5fee6d2
	//TODO: VCVTDQ2PD X11, Y2               // c4c17ee6d3
	//TODO: VCVTDQ2PD (BX), Y11             // c4617ee61b or c57ee61b
	//TODO: VCVTDQ2PD (R11), Y11            // c4417ee61b
	//TODO: VCVTDQ2PD X2, Y11               // c4617ee6da or c57ee6da
	//TODO: VCVTDQ2PD X11, Y11              // c4417ee6db
	//TODO: VCVTDQ2PS (BX), X2              // c4e1785b13 or c5f85b13
	//TODO: VCVTDQ2PS (R11), X2             // c4c1785b13
	//TODO: VCVTDQ2PS X2, X2                // c4e1785bd2 or c5f85bd2
	//TODO: VCVTDQ2PS X11, X2               // c4c1785bd3
	//TODO: VCVTDQ2PS (BX), X11             // c461785b1b or c5785b1b
	//TODO: VCVTDQ2PS (R11), X11            // c441785b1b
	//TODO: VCVTDQ2PS X2, X11               // c461785bda or c5785bda
	//TODO: VCVTDQ2PS X11, X11              // c441785bdb
	//TODO: VCVTDQ2PS (BX), Y2              // c4e17c5b13 or c5fc5b13
	//TODO: VCVTDQ2PS (R11), Y2             // c4c17c5b13
	//TODO: VCVTDQ2PS Y2, Y2                // c4e17c5bd2 or c5fc5bd2
	//TODO: VCVTDQ2PS Y11, Y2               // c4c17c5bd3
	//TODO: VCVTDQ2PS (BX), Y11             // c4617c5b1b or c57c5b1b
	//TODO: VCVTDQ2PS (R11), Y11            // c4417c5b1b
	//TODO: VCVTDQ2PS Y2, Y11               // c4617c5bda or c57c5bda
	//TODO: VCVTDQ2PS Y11, Y11              // c4417c5bdb
	//TODO: VCVTPD2DQX (BX), X2             // c4e17be613 or c5fbe613
	//TODO: VCVTPD2DQX (R11), X2            // c4c17be613
	//TODO: VCVTPD2DQX X2, X2               // c4e17be6d2 or c5fbe6d2
	//TODO: VCVTPD2DQX X11, X2              // c4c17be6d3
	//TODO: VCVTPD2DQX (BX), X11            // c4617be61b or c57be61b
	//TODO: VCVTPD2DQX (R11), X11           // c4417be61b
	//TODO: VCVTPD2DQX X2, X11              // c4617be6da or c57be6da
	//TODO: VCVTPD2DQX X11, X11             // c4417be6db
	//TODO: VCVTPD2DQY (BX), X2             // c4e17fe613 or c5ffe613
	//TODO: VCVTPD2DQY (R11), X2            // c4c17fe613
	//TODO: VCVTPD2DQY Y2, X2               // c4e17fe6d2 or c5ffe6d2
	//TODO: VCVTPD2DQY Y11, X2              // c4c17fe6d3
	//TODO: VCVTPD2DQY (BX), X11            // c4617fe61b or c57fe61b
	//TODO: VCVTPD2DQY (R11), X11           // c4417fe61b
	//TODO: VCVTPD2DQY Y2, X11              // c4617fe6da or c57fe6da
	//TODO: VCVTPD2DQY Y11, X11             // c4417fe6db
	//TODO: VCVTPD2PSX (BX), X2             // c4e1795a13 or c5f95a13
	//TODO: VCVTPD2PSX (R11), X2            // c4c1795a13
	//TODO: VCVTPD2PSX X2, X2               // c4e1795ad2 or c5f95ad2
	//TODO: VCVTPD2PSX X11, X2              // c4c1795ad3
	//TODO: VCVTPD2PSX (BX), X11            // c461795a1b or c5795a1b
	//TODO: VCVTPD2PSX (R11), X11           // c441795a1b
	//TODO: VCVTPD2PSX X2, X11              // c461795ada or c5795ada
	//TODO: VCVTPD2PSX X11, X11             // c441795adb
	//TODO: VCVTPD2PSY (BX), X2             // c4e17d5a13 or c5fd5a13
	//TODO: VCVTPD2PSY (R11), X2            // c4c17d5a13
	//TODO: VCVTPD2PSY Y2, X2               // c4e17d5ad2 or c5fd5ad2
	//TODO: VCVTPD2PSY Y11, X2              // c4c17d5ad3
	//TODO: VCVTPD2PSY (BX), X11            // c4617d5a1b or c57d5a1b
	//TODO: VCVTPD2PSY (R11), X11           // c4417d5a1b
	//TODO: VCVTPD2PSY Y2, X11              // c4617d5ada or c57d5ada
	//TODO: VCVTPD2PSY Y11, X11             // c4417d5adb
	//TODO: VCVTPH2PS (BX), X2              // c4e2791313
	//TODO: VCVTPH2PS (R11), X2             // c4c2791313
	//TODO: VCVTPH2PS X2, X2                // c4e27913d2
	//TODO: VCVTPH2PS X11, X2               // c4c27913d3
	//TODO: VCVTPH2PS (BX), X11             // c46279131b
	//TODO: VCVTPH2PS (R11), X11            // c44279131b
	//TODO: VCVTPH2PS X2, X11               // c4627913da
	//TODO: VCVTPH2PS X11, X11              // c4427913db
	//TODO: VCVTPH2PS (BX), Y2              // c4e27d1313
	//TODO: VCVTPH2PS (R11), Y2             // c4c27d1313
	//TODO: VCVTPH2PS X2, Y2                // c4e27d13d2
	//TODO: VCVTPH2PS X11, Y2               // c4c27d13d3
	//TODO: VCVTPH2PS (BX), Y11             // c4627d131b
	//TODO: VCVTPH2PS (R11), Y11            // c4427d131b
	//TODO: VCVTPH2PS X2, Y11               // c4627d13da
	//TODO: VCVTPH2PS X11, Y11              // c4427d13db
	//TODO: VCVTPS2DQ (BX), X2              // c4e1795b13 or c5f95b13
	//TODO: VCVTPS2DQ (R11), X2             // c4c1795b13
	//TODO: VCVTPS2DQ X2, X2                // c4e1795bd2 or c5f95bd2
	//TODO: VCVTPS2DQ X11, X2               // c4c1795bd3
	//TODO: VCVTPS2DQ (BX), X11             // c461795b1b or c5795b1b
	//TODO: VCVTPS2DQ (R11), X11            // c441795b1b
	//TODO: VCVTPS2DQ X2, X11               // c461795bda or c5795bda
	//TODO: VCVTPS2DQ X11, X11              // c441795bdb
	//TODO: VCVTPS2DQ (BX), Y2              // c4e17d5b13 or c5fd5b13
	//TODO: VCVTPS2DQ (R11), Y2             // c4c17d5b13
	//TODO: VCVTPS2DQ Y2, Y2                // c4e17d5bd2 or c5fd5bd2
	//TODO: VCVTPS2DQ Y11, Y2               // c4c17d5bd3
	//TODO: VCVTPS2DQ (BX), Y11             // c4617d5b1b or c57d5b1b
	//TODO: VCVTPS2DQ (R11), Y11            // c4417d5b1b
	//TODO: VCVTPS2DQ Y2, Y11               // c4617d5bda or c57d5bda
	//TODO: VCVTPS2DQ Y11, Y11              // c4417d5bdb
	//TODO: VCVTPS2PD (BX), X2              // c4e1785a13 or c5f85a13
	//TODO: VCVTPS2PD (R11), X2             // c4c1785a13
	//TODO: VCVTPS2PD X2, X2                // c4e1785ad2 or c5f85ad2
	//TODO: VCVTPS2PD X11, X2               // c4c1785ad3
	//TODO: VCVTPS2PD (BX), X11             // c461785a1b or c5785a1b
	//TODO: VCVTPS2PD (R11), X11            // c441785a1b
	//TODO: VCVTPS2PD X2, X11               // c461785ada or c5785ada
	//TODO: VCVTPS2PD X11, X11              // c441785adb
	//TODO: VCVTPS2PD (BX), Y2              // c4e17c5a13 or c5fc5a13
	//TODO: VCVTPS2PD (R11), Y2             // c4c17c5a13
	//TODO: VCVTPS2PD X2, Y2                // c4e17c5ad2 or c5fc5ad2
	//TODO: VCVTPS2PD X11, Y2               // c4c17c5ad3
	//TODO: VCVTPS2PD (BX), Y11             // c4617c5a1b or c57c5a1b
	//TODO: VCVTPS2PD (R11), Y11            // c4417c5a1b
	//TODO: VCVTPS2PD X2, Y11               // c4617c5ada or c57c5ada
	//TODO: VCVTPS2PD X11, Y11              // c4417c5adb
	//TODO: VCVTPS2PH $7, Y2, (BX)          // c4e37d1d1307
	//TODO: VCVTPS2PH $7, Y11, (BX)         // c4637d1d1b07
	//TODO: VCVTPS2PH $7, Y2, (R11)         // c4c37d1d1307
	//TODO: VCVTPS2PH $7, Y11, (R11)        // c4437d1d1b07
	//TODO: VCVTPS2PH $7, Y2, X2            // c4e37d1dd207
	//TODO: VCVTPS2PH $7, Y11, X2           // c4637d1dda07
	//TODO: VCVTPS2PH $7, Y2, X11           // c4c37d1dd307
	//TODO: VCVTPS2PH $7, Y11, X11          // c4437d1ddb07
	//TODO: VCVTPS2PH $7, X2, (BX)          // c4e3791d1307
	//TODO: VCVTPS2PH $7, X11, (BX)         // c463791d1b07
	//TODO: VCVTPS2PH $7, X2, (R11)         // c4c3791d1307
	//TODO: VCVTPS2PH $7, X11, (R11)        // c443791d1b07
	//TODO: VCVTPS2PH $7, X2, X2            // c4e3791dd207
	//TODO: VCVTPS2PH $7, X11, X2           // c463791dda07
	//TODO: VCVTPS2PH $7, X2, X11           // c4c3791dd307
	//TODO: VCVTPS2PH $7, X11, X11          // c443791ddb07
	//TODO: VCVTSD2SI (BX), DX              // c4e17b2d13 or c5fb2d13
	//TODO: VCVTSD2SI (R11), DX             // c4c17b2d13
	//TODO: VCVTSD2SI X2, DX                // c4e17b2dd2 or c5fb2dd2
	//TODO: VCVTSD2SI X11, DX               // c4c17b2dd3
	//TODO: VCVTSD2SI (BX), R11             // c4617b2d1b or c57b2d1b
	//TODO: VCVTSD2SI (R11), R11            // c4417b2d1b
	//TODO: VCVTSD2SI X2, R11               // c4617b2dda or c57b2dda
	//TODO: VCVTSD2SI X11, R11              // c4417b2ddb
	//TODO: VCVTSD2SIQ (BX), DX             // c4e1fb2d13
	//TODO: VCVTSD2SIQ (R11), DX            // c4c1fb2d13
	//TODO: VCVTSD2SIQ X2, DX               // c4e1fb2dd2
	//TODO: VCVTSD2SIQ X11, DX              // c4c1fb2dd3
	//TODO: VCVTSD2SIQ (BX), R11            // c461fb2d1b
	//TODO: VCVTSD2SIQ (R11), R11           // c441fb2d1b
	//TODO: VCVTSD2SIQ X2, R11              // c461fb2dda
	//TODO: VCVTSD2SIQ X11, R11             // c441fb2ddb
	//TODO: VCVTSD2SS (BX), X9, X2          // c4e1335a13 or c5b35a13
	//TODO: VCVTSD2SS (R11), X9, X2         // c4c1335a13
	//TODO: VCVTSD2SS X2, X9, X2            // c4e1335ad2 or c5b35ad2
	//TODO: VCVTSD2SS X11, X9, X2           // c4c1335ad3
	//TODO: VCVTSD2SS (BX), X9, X11         // c461335a1b or c5335a1b
	//TODO: VCVTSD2SS (R11), X9, X11        // c441335a1b
	//TODO: VCVTSD2SS X2, X9, X11           // c461335ada or c5335ada
	//TODO: VCVTSD2SS X11, X9, X11          // c441335adb
	//TODO: VCVTSI2SDL (BX), X9, X2         // c4e1332a13 or c5b32a13
	//TODO: VCVTSI2SDL (R11), X9, X2        // c4c1332a13
	//TODO: VCVTSI2SDL DX, X9, X2           // c4e1332ad2 or c5b32ad2
	//TODO: VCVTSI2SDL R11, X9, X2          // c4c1332ad3
	//TODO: VCVTSI2SDL (BX), X9, X11        // c461332a1b or c5332a1b
	//TODO: VCVTSI2SDL (R11), X9, X11       // c441332a1b
	//TODO: VCVTSI2SDL DX, X9, X11          // c461332ada or c5332ada
	//TODO: VCVTSI2SDL R11, X9, X11         // c441332adb
	//TODO: VCVTSI2SDQ (BX), X9, X2         // c4e1b32a13
	//TODO: VCVTSI2SDQ (R11), X9, X2        // c4c1b32a13
	//TODO: VCVTSI2SDQ DX, X9, X2           // c4e1b32ad2
	//TODO: VCVTSI2SDQ R11, X9, X2          // c4c1b32ad3
	//TODO: VCVTSI2SDQ (BX), X9, X11        // c461b32a1b
	//TODO: VCVTSI2SDQ (R11), X9, X11       // c441b32a1b
	//TODO: VCVTSI2SDQ DX, X9, X11          // c461b32ada
	//TODO: VCVTSI2SDQ R11, X9, X11         // c441b32adb
	//TODO: VCVTSI2SSL (BX), X9, X2         // c4e1322a13 or c5b22a13
	//TODO: VCVTSI2SSL (R11), X9, X2        // c4c1322a13
	//TODO: VCVTSI2SSL DX, X9, X2           // c4e1322ad2 or c5b22ad2
	//TODO: VCVTSI2SSL R11, X9, X2          // c4c1322ad3
	//TODO: VCVTSI2SSL (BX), X9, X11        // c461322a1b or c5322a1b
	//TODO: VCVTSI2SSL (R11), X9, X11       // c441322a1b
	//TODO: VCVTSI2SSL DX, X9, X11          // c461322ada or c5322ada
	//TODO: VCVTSI2SSL R11, X9, X11         // c441322adb
	//TODO: VCVTSI2SSQ (BX), X9, X2         // c4e1b22a13
	//TODO: VCVTSI2SSQ (R11), X9, X2        // c4c1b22a13
	//TODO: VCVTSI2SSQ DX, X9, X2           // c4e1b22ad2
	//TODO: VCVTSI2SSQ R11, X9, X2          // c4c1b22ad3
	//TODO: VCVTSI2SSQ (BX), X9, X11        // c461b22a1b
	//TODO: VCVTSI2SSQ (R11), X9, X11       // c441b22a1b
	//TODO: VCVTSI2SSQ DX, X9, X11          // c461b22ada
	//TODO: VCVTSI2SSQ R11, X9, X11         // c441b22adb
	//TODO: VCVTSS2SD (BX), X9, X2          // c4e1325a13 or c5b25a13
	//TODO: VCVTSS2SD (R11), X9, X2         // c4c1325a13
	//TODO: VCVTSS2SD X2, X9, X2            // c4e1325ad2 or c5b25ad2
	//TODO: VCVTSS2SD X11, X9, X2           // c4c1325ad3
	//TODO: VCVTSS2SD (BX), X9, X11         // c461325a1b or c5325a1b
	//TODO: VCVTSS2SD (R11), X9, X11        // c441325a1b
	//TODO: VCVTSS2SD X2, X9, X11           // c461325ada or c5325ada
	//TODO: VCVTSS2SD X11, X9, X11          // c441325adb
	//TODO: VCVTSS2SI (BX), DX              // c4e17a2d13 or c5fa2d13
	//TODO: VCVTSS2SI (R11), DX             // c4c17a2d13
	//TODO: VCVTSS2SI X2, DX                // c4e17a2dd2 or c5fa2dd2
	//TODO: VCVTSS2SI X11, DX               // c4c17a2dd3
	//TODO: VCVTSS2SI (BX), R11             // c4617a2d1b or c57a2d1b
	//TODO: VCVTSS2SI (R11), R11            // c4417a2d1b
	//TODO: VCVTSS2SI X2, R11               // c4617a2dda or c57a2dda
	//TODO: VCVTSS2SI X11, R11              // c4417a2ddb
	//TODO: VCVTSS2SIQ (BX), DX             // c4e1fa2d13
	//TODO: VCVTSS2SIQ (R11), DX            // c4c1fa2d13
	//TODO: VCVTSS2SIQ X2, DX               // c4e1fa2dd2
	//TODO: VCVTSS2SIQ X11, DX              // c4c1fa2dd3
	//TODO: VCVTSS2SIQ (BX), R11            // c461fa2d1b
	//TODO: VCVTSS2SIQ (R11), R11           // c441fa2d1b
	//TODO: VCVTSS2SIQ X2, R11              // c461fa2dda
	//TODO: VCVTSS2SIQ X11, R11             // c441fa2ddb
	//TODO: VCVTTPD2DQX (BX), X2            // c4e179e613 or c5f9e613
	//TODO: VCVTTPD2DQX (R11), X2           // c4c179e613
	//TODO: VCVTTPD2DQX X2, X2              // c4e179e6d2 or c5f9e6d2
	//TODO: VCVTTPD2DQX X11, X2             // c4c179e6d3
	//TODO: VCVTTPD2DQX (BX), X11           // c46179e61b or c579e61b
	//TODO: VCVTTPD2DQX (R11), X11          // c44179e61b
	//TODO: VCVTTPD2DQX X2, X11             // c46179e6da or c579e6da
	//TODO: VCVTTPD2DQX X11, X11            // c44179e6db
	//TODO: VCVTTPD2DQY (BX), X2            // c4e17de613 or c5fde613
	//TODO: VCVTTPD2DQY (R11), X2           // c4c17de613
	//TODO: VCVTTPD2DQY Y2, X2              // c4e17de6d2 or c5fde6d2
	//TODO: VCVTTPD2DQY Y11, X2             // c4c17de6d3
	//TODO: VCVTTPD2DQY (BX), X11           // c4617de61b or c57de61b
	//TODO: VCVTTPD2DQY (R11), X11          // c4417de61b
	//TODO: VCVTTPD2DQY Y2, X11             // c4617de6da or c57de6da
	//TODO: VCVTTPD2DQY Y11, X11            // c4417de6db
	//TODO: VCVTTPS2DQ (BX), X2             // c4e17a5b13 or c5fa5b13
	//TODO: VCVTTPS2DQ (R11), X2            // c4c17a5b13
	//TODO: VCVTTPS2DQ X2, X2               // c4e17a5bd2 or c5fa5bd2
	//TODO: VCVTTPS2DQ X11, X2              // c4c17a5bd3
	//TODO: VCVTTPS2DQ (BX), X11            // c4617a5b1b or c57a5b1b
	//TODO: VCVTTPS2DQ (R11), X11           // c4417a5b1b
	//TODO: VCVTTPS2DQ X2, X11              // c4617a5bda or c57a5bda
	//TODO: VCVTTPS2DQ X11, X11             // c4417a5bdb
	//TODO: VCVTTPS2DQ (BX), Y2             // c4e17e5b13 or c5fe5b13
	//TODO: VCVTTPS2DQ (R11), Y2            // c4c17e5b13
	//TODO: VCVTTPS2DQ Y2, Y2               // c4e17e5bd2 or c5fe5bd2
	//TODO: VCVTTPS2DQ Y11, Y2              // c4c17e5bd3
	//TODO: VCVTTPS2DQ (BX), Y11            // c4617e5b1b or c57e5b1b
	//TODO: VCVTTPS2DQ (R11), Y11           // c4417e5b1b
	//TODO: VCVTTPS2DQ Y2, Y11              // c4617e5bda or c57e5bda
	//TODO: VCVTTPS2DQ Y11, Y11             // c4417e5bdb
	//TODO: VCVTTSD2SI (BX), DX             // c4e17b2c13 or c5fb2c13
	//TODO: VCVTTSD2SI (R11), DX            // c4c17b2c13
	//TODO: VCVTTSD2SI X2, DX               // c4e17b2cd2 or c5fb2cd2
	//TODO: VCVTTSD2SI X11, DX              // c4c17b2cd3
	//TODO: VCVTTSD2SI (BX), R11            // c4617b2c1b or c57b2c1b
	//TODO: VCVTTSD2SI (R11), R11           // c4417b2c1b
	//TODO: VCVTTSD2SI X2, R11              // c4617b2cda or c57b2cda
	//TODO: VCVTTSD2SI X11, R11             // c4417b2cdb
	//TODO: VCVTTSD2SIQ (BX), DX            // c4e1fb2c13
	//TODO: VCVTTSD2SIQ (R11), DX           // c4c1fb2c13
	//TODO: VCVTTSD2SIQ X2, DX              // c4e1fb2cd2
	//TODO: VCVTTSD2SIQ X11, DX             // c4c1fb2cd3
	//TODO: VCVTTSD2SIQ (BX), R11           // c461fb2c1b
	//TODO: VCVTTSD2SIQ (R11), R11          // c441fb2c1b
	//TODO: VCVTTSD2SIQ X2, R11             // c461fb2cda
	//TODO: VCVTTSD2SIQ X11, R11            // c441fb2cdb
	//TODO: VCVTTSS2SI (BX), DX             // c4e17a2c13 or c5fa2c13
	//TODO: VCVTTSS2SI (R11), DX            // c4c17a2c13
	//TODO: VCVTTSS2SI X2, DX               // c4e17a2cd2 or c5fa2cd2
	//TODO: VCVTTSS2SI X11, DX              // c4c17a2cd3
	//TODO: VCVTTSS2SI (BX), R11            // c4617a2c1b or c57a2c1b
	//TODO: VCVTTSS2SI (R11), R11           // c4417a2c1b
	//TODO: VCVTTSS2SI X2, R11              // c4617a2cda or c57a2cda
	//TODO: VCVTTSS2SI X11, R11             // c4417a2cdb
	//TODO: VCVTTSS2SIQ (BX), DX            // c4e1fa2c13
	//TODO: VCVTTSS2SIQ (R11), DX           // c4c1fa2c13
	//TODO: VCVTTSS2SIQ X2, DX              // c4e1fa2cd2
	//TODO: VCVTTSS2SIQ X11, DX             // c4c1fa2cd3
	//TODO: VCVTTSS2SIQ (BX), R11           // c461fa2c1b
	//TODO: VCVTTSS2SIQ (R11), R11          // c441fa2c1b
	//TODO: VCVTTSS2SIQ X2, R11             // c461fa2cda
	//TODO: VCVTTSS2SIQ X11, R11            // c441fa2cdb
	//TODO: VDIVPD (BX), X9, X2             // c4e1315e13 or c5b15e13
	//TODO: VDIVPD (R11), X9, X2            // c4c1315e13
	//TODO: VDIVPD X2, X9, X2               // c4e1315ed2 or c5b15ed2
	//TODO: VDIVPD X11, X9, X2              // c4c1315ed3
	//TODO: VDIVPD (BX), X9, X11            // c461315e1b or c5315e1b
	//TODO: VDIVPD (R11), X9, X11           // c441315e1b
	//TODO: VDIVPD X2, X9, X11              // c461315eda or c5315eda
	//TODO: VDIVPD X11, X9, X11             // c441315edb
	//TODO: VDIVPD (BX), Y15, Y2            // c4e1055e13 or c5855e13
	//TODO: VDIVPD (R11), Y15, Y2           // c4c1055e13
	//TODO: VDIVPD Y2, Y15, Y2              // c4e1055ed2 or c5855ed2
	//TODO: VDIVPD Y11, Y15, Y2             // c4c1055ed3
	//TODO: VDIVPD (BX), Y15, Y11           // c461055e1b or c5055e1b
	//TODO: VDIVPD (R11), Y15, Y11          // c441055e1b
	//TODO: VDIVPD Y2, Y15, Y11             // c461055eda or c5055eda
	//TODO: VDIVPD Y11, Y15, Y11            // c441055edb
	//TODO: VDIVPS (BX), X9, X2             // c4e1305e13 or c5b05e13
	//TODO: VDIVPS (R11), X9, X2            // c4c1305e13
	//TODO: VDIVPS X2, X9, X2               // c4e1305ed2 or c5b05ed2
	//TODO: VDIVPS X11, X9, X2              // c4c1305ed3
	//TODO: VDIVPS (BX), X9, X11            // c461305e1b or c5305e1b
	//TODO: VDIVPS (R11), X9, X11           // c441305e1b
	//TODO: VDIVPS X2, X9, X11              // c461305eda or c5305eda
	//TODO: VDIVPS X11, X9, X11             // c441305edb
	//TODO: VDIVPS (BX), Y15, Y2            // c4e1045e13 or c5845e13
	//TODO: VDIVPS (R11), Y15, Y2           // c4c1045e13
	//TODO: VDIVPS Y2, Y15, Y2              // c4e1045ed2 or c5845ed2
	//TODO: VDIVPS Y11, Y15, Y2             // c4c1045ed3
	//TODO: VDIVPS (BX), Y15, Y11           // c461045e1b or c5045e1b
	//TODO: VDIVPS (R11), Y15, Y11          // c441045e1b
	//TODO: VDIVPS Y2, Y15, Y11             // c461045eda or c5045eda
	//TODO: VDIVPS Y11, Y15, Y11            // c441045edb
	//TODO: VDIVSD (BX), X9, X2             // c4e1335e13 or c5b35e13
	//TODO: VDIVSD (R11), X9, X2            // c4c1335e13
	//TODO: VDIVSD X2, X9, X2               // c4e1335ed2 or c5b35ed2
	//TODO: VDIVSD X11, X9, X2              // c4c1335ed3
	//TODO: VDIVSD (BX), X9, X11            // c461335e1b or c5335e1b
	//TODO: VDIVSD (R11), X9, X11           // c441335e1b
	//TODO: VDIVSD X2, X9, X11              // c461335eda or c5335eda
	//TODO: VDIVSD X11, X9, X11             // c441335edb
	//TODO: VDIVSS (BX), X9, X2             // c4e1325e13 or c5b25e13
	//TODO: VDIVSS (R11), X9, X2            // c4c1325e13
	//TODO: VDIVSS X2, X9, X2               // c4e1325ed2 or c5b25ed2
	//TODO: VDIVSS X11, X9, X2              // c4c1325ed3
	//TODO: VDIVSS (BX), X9, X11            // c461325e1b or c5325e1b
	//TODO: VDIVSS (R11), X9, X11           // c441325e1b
	//TODO: VDIVSS X2, X9, X11              // c461325eda or c5325eda
	//TODO: VDIVSS X11, X9, X11             // c441325edb
	//TODO: VDPPD $7, (BX), X9, X2          // c4e331411307
	//TODO: VDPPD $7, (R11), X9, X2         // c4c331411307
	//TODO: VDPPD $7, X2, X9, X2            // c4e33141d207
	//TODO: VDPPD $7, X11, X9, X2           // c4c33141d307
	//TODO: VDPPD $7, (BX), X9, X11         // c46331411b07
	//TODO: VDPPD $7, (R11), X9, X11        // c44331411b07
	//TODO: VDPPD $7, X2, X9, X11           // c4633141da07
	//TODO: VDPPD $7, X11, X9, X11          // c4433141db07
	//TODO: VDPPS $7, (BX), X9, X2          // c4e331401307
	//TODO: VDPPS $7, (R11), X9, X2         // c4c331401307
	//TODO: VDPPS $7, X2, X9, X2            // c4e33140d207
	//TODO: VDPPS $7, X11, X9, X2           // c4c33140d307
	//TODO: VDPPS $7, (BX), X9, X11         // c46331401b07
	//TODO: VDPPS $7, (R11), X9, X11        // c44331401b07
	//TODO: VDPPS $7, X2, X9, X11           // c4633140da07
	//TODO: VDPPS $7, X11, X9, X11          // c4433140db07
	//TODO: VDPPS $7, (BX), Y15, Y2         // c4e305401307
	//TODO: VDPPS $7, (R11), Y15, Y2        // c4c305401307
	//TODO: VDPPS $7, Y2, Y15, Y2           // c4e30540d207
	//TODO: VDPPS $7, Y11, Y15, Y2          // c4c30540d307
	//TODO: VDPPS $7, (BX), Y15, Y11        // c46305401b07
	//TODO: VDPPS $7, (R11), Y15, Y11       // c44305401b07
	//TODO: VDPPS $7, Y2, Y15, Y11          // c4630540da07
	//TODO: VDPPS $7, Y11, Y15, Y11         // c4430540db07
	VERR (BX)                               // 0f0023
	VERR (R11)                              // 410f0023
	VERR DX                                 // 0f00e2
	VERR R11                                // 410f00e3
	VERW (BX)                               // 0f002b
	VERW (R11)                              // 410f002b
	VERW DX                                 // 0f00ea
	VERW R11                                // 410f00eb
	//TODO: VEXTRACTF128 $7, Y2, (BX)       // c4e37d191307
	//TODO: VEXTRACTF128 $7, Y11, (BX)      // c4637d191b07
	//TODO: VEXTRACTF128 $7, Y2, (R11)      // c4c37d191307
	//TODO: VEXTRACTF128 $7, Y11, (R11)     // c4437d191b07
	//TODO: VEXTRACTF128 $7, Y2, X2         // c4e37d19d207
	//TODO: VEXTRACTF128 $7, Y11, X2        // c4637d19da07
	//TODO: VEXTRACTF128 $7, Y2, X11        // c4c37d19d307
	//TODO: VEXTRACTF128 $7, Y11, X11       // c4437d19db07
	//TODO: VEXTRACTI128 $7, Y2, (BX)       // c4e37d391307
	//TODO: VEXTRACTI128 $7, Y11, (BX)      // c4637d391b07
	//TODO: VEXTRACTI128 $7, Y2, (R11)      // c4c37d391307
	//TODO: VEXTRACTI128 $7, Y11, (R11)     // c4437d391b07
	//TODO: VEXTRACTI128 $7, Y2, X2         // c4e37d39d207
	//TODO: VEXTRACTI128 $7, Y11, X2        // c4637d39da07
	//TODO: VEXTRACTI128 $7, Y2, X11        // c4c37d39d307
	//TODO: VEXTRACTI128 $7, Y11, X11       // c4437d39db07
	//TODO: VEXTRACTPS $7, X2, (BX)         // c4e379171307
	//TODO: VEXTRACTPS $7, X11, (BX)        // c46379171b07
	//TODO: VEXTRACTPS $7, X2, (R11)        // c4c379171307
	//TODO: VEXTRACTPS $7, X11, (R11)       // c44379171b07
	//TODO: VEXTRACTPS $7, X2, DX           // c4e37917d207
	//TODO: VEXTRACTPS $7, X11, DX          // c4637917da07
	//TODO: VEXTRACTPS $7, X2, R11          // c4c37917d307
	//TODO: VEXTRACTPS $7, X11, R11         // c4437917db07
	//TODO: VFMADD132PD (BX), X9, X2        // c4e2b19813
	//TODO: VFMADD132PD (R11), X9, X2       // c4c2b19813
	//TODO: VFMADD132PD X2, X9, X2          // c4e2b198d2
	//TODO: VFMADD132PD X11, X9, X2         // c4c2b198d3
	//TODO: VFMADD132PD (BX), X9, X11       // c462b1981b
	//TODO: VFMADD132PD (R11), X9, X11      // c442b1981b
	//TODO: VFMADD132PD X2, X9, X11         // c462b198da
	//TODO: VFMADD132PD X11, X9, X11        // c442b198db
	//TODO: VFMADD132PD (BX), Y15, Y2       // c4e2859813
	//TODO: VFMADD132PD (R11), Y15, Y2      // c4c2859813
	//TODO: VFMADD132PD Y2, Y15, Y2         // c4e28598d2
	//TODO: VFMADD132PD Y11, Y15, Y2        // c4c28598d3
	//TODO: VFMADD132PD (BX), Y15, Y11      // c46285981b
	//TODO: VFMADD132PD (R11), Y15, Y11     // c44285981b
	//TODO: VFMADD132PD Y2, Y15, Y11        // c4628598da
	//TODO: VFMADD132PD Y11, Y15, Y11       // c4428598db
	//TODO: VFMADD132PS (BX), X9, X2        // c4e2319813
	//TODO: VFMADD132PS (R11), X9, X2       // c4c2319813
	//TODO: VFMADD132PS X2, X9, X2          // c4e23198d2
	//TODO: VFMADD132PS X11, X9, X2         // c4c23198d3
	//TODO: VFMADD132PS (BX), X9, X11       // c46231981b
	//TODO: VFMADD132PS (R11), X9, X11      // c44231981b
	//TODO: VFMADD132PS X2, X9, X11         // c4623198da
	//TODO: VFMADD132PS X11, X9, X11        // c4423198db
	//TODO: VFMADD132PS (BX), Y15, Y2       // c4e2059813
	//TODO: VFMADD132PS (R11), Y15, Y2      // c4c2059813
	//TODO: VFMADD132PS Y2, Y15, Y2         // c4e20598d2
	//TODO: VFMADD132PS Y11, Y15, Y2        // c4c20598d3
	//TODO: VFMADD132PS (BX), Y15, Y11      // c46205981b
	//TODO: VFMADD132PS (R11), Y15, Y11     // c44205981b
	//TODO: VFMADD132PS Y2, Y15, Y11        // c4620598da
	//TODO: VFMADD132PS Y11, Y15, Y11       // c4420598db
	//TODO: VFMADD132SD (BX), X9, X2        // c4e2b19913
	//TODO: VFMADD132SD (R11), X9, X2       // c4c2b19913
	//TODO: VFMADD132SD X2, X9, X2          // c4e2b199d2
	//TODO: VFMADD132SD X11, X9, X2         // c4c2b199d3
	//TODO: VFMADD132SD (BX), X9, X11       // c462b1991b
	//TODO: VFMADD132SD (R11), X9, X11      // c442b1991b
	//TODO: VFMADD132SD X2, X9, X11         // c462b199da
	//TODO: VFMADD132SD X11, X9, X11        // c442b199db
	//TODO: VFMADD132SS (BX), X9, X2        // c4e2319913
	//TODO: VFMADD132SS (R11), X9, X2       // c4c2319913
	//TODO: VFMADD132SS X2, X9, X2          // c4e23199d2
	//TODO: VFMADD132SS X11, X9, X2         // c4c23199d3
	//TODO: VFMADD132SS (BX), X9, X11       // c46231991b
	//TODO: VFMADD132SS (R11), X9, X11      // c44231991b
	//TODO: VFMADD132SS X2, X9, X11         // c4623199da
	//TODO: VFMADD132SS X11, X9, X11        // c4423199db
	//TODO: VFMADD213PD (BX), X9, X2        // c4e2b1a813
	//TODO: VFMADD213PD (R11), X9, X2       // c4c2b1a813
	//TODO: VFMADD213PD X2, X9, X2          // c4e2b1a8d2
	//TODO: VFMADD213PD X11, X9, X2         // c4c2b1a8d3
	//TODO: VFMADD213PD (BX), X9, X11       // c462b1a81b
	//TODO: VFMADD213PD (R11), X9, X11      // c442b1a81b
	//TODO: VFMADD213PD X2, X9, X11         // c462b1a8da
	//TODO: VFMADD213PD X11, X9, X11        // c442b1a8db
	//TODO: VFMADD213PD (BX), Y15, Y2       // c4e285a813
	//TODO: VFMADD213PD (R11), Y15, Y2      // c4c285a813
	//TODO: VFMADD213PD Y2, Y15, Y2         // c4e285a8d2
	//TODO: VFMADD213PD Y11, Y15, Y2        // c4c285a8d3
	//TODO: VFMADD213PD (BX), Y15, Y11      // c46285a81b
	//TODO: VFMADD213PD (R11), Y15, Y11     // c44285a81b
	//TODO: VFMADD213PD Y2, Y15, Y11        // c46285a8da
	//TODO: VFMADD213PD Y11, Y15, Y11       // c44285a8db
	//TODO: VFMADD213PS (BX), X9, X2        // c4e231a813
	//TODO: VFMADD213PS (R11), X9, X2       // c4c231a813
	//TODO: VFMADD213PS X2, X9, X2          // c4e231a8d2
	//TODO: VFMADD213PS X11, X9, X2         // c4c231a8d3
	//TODO: VFMADD213PS (BX), X9, X11       // c46231a81b
	//TODO: VFMADD213PS (R11), X9, X11      // c44231a81b
	//TODO: VFMADD213PS X2, X9, X11         // c46231a8da
	//TODO: VFMADD213PS X11, X9, X11        // c44231a8db
	//TODO: VFMADD213PS (BX), Y15, Y2       // c4e205a813
	//TODO: VFMADD213PS (R11), Y15, Y2      // c4c205a813
	//TODO: VFMADD213PS Y2, Y15, Y2         // c4e205a8d2
	//TODO: VFMADD213PS Y11, Y15, Y2        // c4c205a8d3
	//TODO: VFMADD213PS (BX), Y15, Y11      // c46205a81b
	//TODO: VFMADD213PS (R11), Y15, Y11     // c44205a81b
	//TODO: VFMADD213PS Y2, Y15, Y11        // c46205a8da
	//TODO: VFMADD213PS Y11, Y15, Y11       // c44205a8db
	//TODO: VFMADD213SD (BX), X9, X2        // c4e2b1a913
	//TODO: VFMADD213SD (R11), X9, X2       // c4c2b1a913
	//TODO: VFMADD213SD X2, X9, X2          // c4e2b1a9d2
	//TODO: VFMADD213SD X11, X9, X2         // c4c2b1a9d3
	//TODO: VFMADD213SD (BX), X9, X11       // c462b1a91b
	//TODO: VFMADD213SD (R11), X9, X11      // c442b1a91b
	//TODO: VFMADD213SD X2, X9, X11         // c462b1a9da
	//TODO: VFMADD213SD X11, X9, X11        // c442b1a9db
	//TODO: VFMADD213SS (BX), X9, X2        // c4e231a913
	//TODO: VFMADD213SS (R11), X9, X2       // c4c231a913
	//TODO: VFMADD213SS X2, X9, X2          // c4e231a9d2
	//TODO: VFMADD213SS X11, X9, X2         // c4c231a9d3
	//TODO: VFMADD213SS (BX), X9, X11       // c46231a91b
	//TODO: VFMADD213SS (R11), X9, X11      // c44231a91b
	//TODO: VFMADD213SS X2, X9, X11         // c46231a9da
	//TODO: VFMADD213SS X11, X9, X11        // c44231a9db
	//TODO: VFMADD231PD (BX), X9, X2        // c4e2b1b813
	//TODO: VFMADD231PD (R11), X9, X2       // c4c2b1b813
	//TODO: VFMADD231PD X2, X9, X2          // c4e2b1b8d2
	//TODO: VFMADD231PD X11, X9, X2         // c4c2b1b8d3
	//TODO: VFMADD231PD (BX), X9, X11       // c462b1b81b
	//TODO: VFMADD231PD (R11), X9, X11      // c442b1b81b
	//TODO: VFMADD231PD X2, X9, X11         // c462b1b8da
	//TODO: VFMADD231PD X11, X9, X11        // c442b1b8db
	//TODO: VFMADD231PD (BX), Y15, Y2       // c4e285b813
	//TODO: VFMADD231PD (R11), Y15, Y2      // c4c285b813
	//TODO: VFMADD231PD Y2, Y15, Y2         // c4e285b8d2
	//TODO: VFMADD231PD Y11, Y15, Y2        // c4c285b8d3
	//TODO: VFMADD231PD (BX), Y15, Y11      // c46285b81b
	//TODO: VFMADD231PD (R11), Y15, Y11     // c44285b81b
	//TODO: VFMADD231PD Y2, Y15, Y11        // c46285b8da
	//TODO: VFMADD231PD Y11, Y15, Y11       // c44285b8db
	//TODO: VFMADD231PS (BX), X9, X2        // c4e231b813
	//TODO: VFMADD231PS (R11), X9, X2       // c4c231b813
	//TODO: VFMADD231PS X2, X9, X2          // c4e231b8d2
	//TODO: VFMADD231PS X11, X9, X2         // c4c231b8d3
	//TODO: VFMADD231PS (BX), X9, X11       // c46231b81b
	//TODO: VFMADD231PS (R11), X9, X11      // c44231b81b
	//TODO: VFMADD231PS X2, X9, X11         // c46231b8da
	//TODO: VFMADD231PS X11, X9, X11        // c44231b8db
	//TODO: VFMADD231PS (BX), Y15, Y2       // c4e205b813
	//TODO: VFMADD231PS (R11), Y15, Y2      // c4c205b813
	//TODO: VFMADD231PS Y2, Y15, Y2         // c4e205b8d2
	//TODO: VFMADD231PS Y11, Y15, Y2        // c4c205b8d3
	//TODO: VFMADD231PS (BX), Y15, Y11      // c46205b81b
	//TODO: VFMADD231PS (R11), Y15, Y11     // c44205b81b
	//TODO: VFMADD231PS Y2, Y15, Y11        // c46205b8da
	//TODO: VFMADD231PS Y11, Y15, Y11       // c44205b8db
	//TODO: VFMADD231SD (BX), X9, X2        // c4e2b1b913
	//TODO: VFMADD231SD (R11), X9, X2       // c4c2b1b913
	//TODO: VFMADD231SD X2, X9, X2          // c4e2b1b9d2
	//TODO: VFMADD231SD X11, X9, X2         // c4c2b1b9d3
	//TODO: VFMADD231SD (BX), X9, X11       // c462b1b91b
	//TODO: VFMADD231SD (R11), X9, X11      // c442b1b91b
	//TODO: VFMADD231SD X2, X9, X11         // c462b1b9da
	//TODO: VFMADD231SD X11, X9, X11        // c442b1b9db
	//TODO: VFMADD231SS (BX), X9, X2        // c4e231b913
	//TODO: VFMADD231SS (R11), X9, X2       // c4c231b913
	//TODO: VFMADD231SS X2, X9, X2          // c4e231b9d2
	//TODO: VFMADD231SS X11, X9, X2         // c4c231b9d3
	//TODO: VFMADD231SS (BX), X9, X11       // c46231b91b
	//TODO: VFMADD231SS (R11), X9, X11      // c44231b91b
	//TODO: VFMADD231SS X2, X9, X11         // c46231b9da
	//TODO: VFMADD231SS X11, X9, X11        // c44231b9db
	//TODO: VFMADDSUB132PD (BX), X9, X2     // c4e2b19613
	//TODO: VFMADDSUB132PD (R11), X9, X2    // c4c2b19613
	//TODO: VFMADDSUB132PD X2, X9, X2       // c4e2b196d2
	//TODO: VFMADDSUB132PD X11, X9, X2      // c4c2b196d3
	//TODO: VFMADDSUB132PD (BX), X9, X11    // c462b1961b
	//TODO: VFMADDSUB132PD (R11), X9, X11   // c442b1961b
	//TODO: VFMADDSUB132PD X2, X9, X11      // c462b196da
	//TODO: VFMADDSUB132PD X11, X9, X11     // c442b196db
	//TODO: VFMADDSUB132PD (BX), Y15, Y2    // c4e2859613
	//TODO: VFMADDSUB132PD (R11), Y15, Y2   // c4c2859613
	//TODO: VFMADDSUB132PD Y2, Y15, Y2      // c4e28596d2
	//TODO: VFMADDSUB132PD Y11, Y15, Y2     // c4c28596d3
	//TODO: VFMADDSUB132PD (BX), Y15, Y11   // c46285961b
	//TODO: VFMADDSUB132PD (R11), Y15, Y11  // c44285961b
	//TODO: VFMADDSUB132PD Y2, Y15, Y11     // c4628596da
	//TODO: VFMADDSUB132PD Y11, Y15, Y11    // c4428596db
	//TODO: VFMADDSUB132PS (BX), X9, X2     // c4e2319613
	//TODO: VFMADDSUB132PS (R11), X9, X2    // c4c2319613
	//TODO: VFMADDSUB132PS X2, X9, X2       // c4e23196d2
	//TODO: VFMADDSUB132PS X11, X9, X2      // c4c23196d3
	//TODO: VFMADDSUB132PS (BX), X9, X11    // c46231961b
	//TODO: VFMADDSUB132PS (R11), X9, X11   // c44231961b
	//TODO: VFMADDSUB132PS X2, X9, X11      // c4623196da
	//TODO: VFMADDSUB132PS X11, X9, X11     // c4423196db
	//TODO: VFMADDSUB132PS (BX), Y15, Y2    // c4e2059613
	//TODO: VFMADDSUB132PS (R11), Y15, Y2   // c4c2059613
	//TODO: VFMADDSUB132PS Y2, Y15, Y2      // c4e20596d2
	//TODO: VFMADDSUB132PS Y11, Y15, Y2     // c4c20596d3
	//TODO: VFMADDSUB132PS (BX), Y15, Y11   // c46205961b
	//TODO: VFMADDSUB132PS (R11), Y15, Y11  // c44205961b
	//TODO: VFMADDSUB132PS Y2, Y15, Y11     // c4620596da
	//TODO: VFMADDSUB132PS Y11, Y15, Y11    // c4420596db
	//TODO: VFMADDSUB213PD (BX), X9, X2     // c4e2b1a613
	//TODO: VFMADDSUB213PD (R11), X9, X2    // c4c2b1a613
	//TODO: VFMADDSUB213PD X2, X9, X2       // c4e2b1a6d2
	//TODO: VFMADDSUB213PD X11, X9, X2      // c4c2b1a6d3
	//TODO: VFMADDSUB213PD (BX), X9, X11    // c462b1a61b
	//TODO: VFMADDSUB213PD (R11), X9, X11   // c442b1a61b
	//TODO: VFMADDSUB213PD X2, X9, X11      // c462b1a6da
	//TODO: VFMADDSUB213PD X11, X9, X11     // c442b1a6db
	//TODO: VFMADDSUB213PD (BX), Y15, Y2    // c4e285a613
	//TODO: VFMADDSUB213PD (R11), Y15, Y2   // c4c285a613
	//TODO: VFMADDSUB213PD Y2, Y15, Y2      // c4e285a6d2
	//TODO: VFMADDSUB213PD Y11, Y15, Y2     // c4c285a6d3
	//TODO: VFMADDSUB213PD (BX), Y15, Y11   // c46285a61b
	//TODO: VFMADDSUB213PD (R11), Y15, Y11  // c44285a61b
	//TODO: VFMADDSUB213PD Y2, Y15, Y11     // c46285a6da
	//TODO: VFMADDSUB213PD Y11, Y15, Y11    // c44285a6db
	//TODO: VFMADDSUB213PS (BX), X9, X2     // c4e231a613
	//TODO: VFMADDSUB213PS (R11), X9, X2    // c4c231a613
	//TODO: VFMADDSUB213PS X2, X9, X2       // c4e231a6d2
	//TODO: VFMADDSUB213PS X11, X9, X2      // c4c231a6d3
	//TODO: VFMADDSUB213PS (BX), X9, X11    // c46231a61b
	//TODO: VFMADDSUB213PS (R11), X9, X11   // c44231a61b
	//TODO: VFMADDSUB213PS X2, X9, X11      // c46231a6da
	//TODO: VFMADDSUB213PS X11, X9, X11     // c44231a6db
	//TODO: VFMADDSUB213PS (BX), Y15, Y2    // c4e205a613
	//TODO: VFMADDSUB213PS (R11), Y15, Y2   // c4c205a613
	//TODO: VFMADDSUB213PS Y2, Y15, Y2      // c4e205a6d2
	//TODO: VFMADDSUB213PS Y11, Y15, Y2     // c4c205a6d3
	//TODO: VFMADDSUB213PS (BX), Y15, Y11   // c46205a61b
	//TODO: VFMADDSUB213PS (R11), Y15, Y11  // c44205a61b
	//TODO: VFMADDSUB213PS Y2, Y15, Y11     // c46205a6da
	//TODO: VFMADDSUB213PS Y11, Y15, Y11    // c44205a6db
	//TODO: VFMADDSUB231PD (BX), X9, X2     // c4e2b1b613
	//TODO: VFMADDSUB231PD (R11), X9, X2    // c4c2b1b613
	//TODO: VFMADDSUB231PD X2, X9, X2       // c4e2b1b6d2
	//TODO: VFMADDSUB231PD X11, X9, X2      // c4c2b1b6d3
	//TODO: VFMADDSUB231PD (BX), X9, X11    // c462b1b61b
	//TODO: VFMADDSUB231PD (R11), X9, X11   // c442b1b61b
	//TODO: VFMADDSUB231PD X2, X9, X11      // c462b1b6da
	//TODO: VFMADDSUB231PD X11, X9, X11     // c442b1b6db
	//TODO: VFMADDSUB231PD (BX), Y15, Y2    // c4e285b613
	//TODO: VFMADDSUB231PD (R11), Y15, Y2   // c4c285b613
	//TODO: VFMADDSUB231PD Y2, Y15, Y2      // c4e285b6d2
	//TODO: VFMADDSUB231PD Y11, Y15, Y2     // c4c285b6d3
	//TODO: VFMADDSUB231PD (BX), Y15, Y11   // c46285b61b
	//TODO: VFMADDSUB231PD (R11), Y15, Y11  // c44285b61b
	//TODO: VFMADDSUB231PD Y2, Y15, Y11     // c46285b6da
	//TODO: VFMADDSUB231PD Y11, Y15, Y11    // c44285b6db
	//TODO: VFMADDSUB231PS (BX), X9, X2     // c4e231b613
	//TODO: VFMADDSUB231PS (R11), X9, X2    // c4c231b613
	//TODO: VFMADDSUB231PS X2, X9, X2       // c4e231b6d2
	//TODO: VFMADDSUB231PS X11, X9, X2      // c4c231b6d3
	//TODO: VFMADDSUB231PS (BX), X9, X11    // c46231b61b
	//TODO: VFMADDSUB231PS (R11), X9, X11   // c44231b61b
	//TODO: VFMADDSUB231PS X2, X9, X11      // c46231b6da
	//TODO: VFMADDSUB231PS X11, X9, X11     // c44231b6db
	//TODO: VFMADDSUB231PS (BX), Y15, Y2    // c4e205b613
	//TODO: VFMADDSUB231PS (R11), Y15, Y2   // c4c205b613
	//TODO: VFMADDSUB231PS Y2, Y15, Y2      // c4e205b6d2
	//TODO: VFMADDSUB231PS Y11, Y15, Y2     // c4c205b6d3
	//TODO: VFMADDSUB231PS (BX), Y15, Y11   // c46205b61b
	//TODO: VFMADDSUB231PS (R11), Y15, Y11  // c44205b61b
	//TODO: VFMADDSUB231PS Y2, Y15, Y11     // c46205b6da
	//TODO: VFMADDSUB231PS Y11, Y15, Y11    // c44205b6db
	//TODO: VFMSUB132PD (BX), X9, X2        // c4e2b19a13
	//TODO: VFMSUB132PD (R11), X9, X2       // c4c2b19a13
	//TODO: VFMSUB132PD X2, X9, X2          // c4e2b19ad2
	//TODO: VFMSUB132PD X11, X9, X2         // c4c2b19ad3
	//TODO: VFMSUB132PD (BX), X9, X11       // c462b19a1b
	//TODO: VFMSUB132PD (R11), X9, X11      // c442b19a1b
	//TODO: VFMSUB132PD X2, X9, X11         // c462b19ada
	//TODO: VFMSUB132PD X11, X9, X11        // c442b19adb
	//TODO: VFMSUB132PD (BX), Y15, Y2       // c4e2859a13
	//TODO: VFMSUB132PD (R11), Y15, Y2      // c4c2859a13
	//TODO: VFMSUB132PD Y2, Y15, Y2         // c4e2859ad2
	//TODO: VFMSUB132PD Y11, Y15, Y2        // c4c2859ad3
	//TODO: VFMSUB132PD (BX), Y15, Y11      // c462859a1b
	//TODO: VFMSUB132PD (R11), Y15, Y11     // c442859a1b
	//TODO: VFMSUB132PD Y2, Y15, Y11        // c462859ada
	//TODO: VFMSUB132PD Y11, Y15, Y11       // c442859adb
	//TODO: VFMSUB132PS (BX), X9, X2        // c4e2319a13
	//TODO: VFMSUB132PS (R11), X9, X2       // c4c2319a13
	//TODO: VFMSUB132PS X2, X9, X2          // c4e2319ad2
	//TODO: VFMSUB132PS X11, X9, X2         // c4c2319ad3
	//TODO: VFMSUB132PS (BX), X9, X11       // c462319a1b
	//TODO: VFMSUB132PS (R11), X9, X11      // c442319a1b
	//TODO: VFMSUB132PS X2, X9, X11         // c462319ada
	//TODO: VFMSUB132PS X11, X9, X11        // c442319adb
	//TODO: VFMSUB132PS (BX), Y15, Y2       // c4e2059a13
	//TODO: VFMSUB132PS (R11), Y15, Y2      // c4c2059a13
	//TODO: VFMSUB132PS Y2, Y15, Y2         // c4e2059ad2
	//TODO: VFMSUB132PS Y11, Y15, Y2        // c4c2059ad3
	//TODO: VFMSUB132PS (BX), Y15, Y11      // c462059a1b
	//TODO: VFMSUB132PS (R11), Y15, Y11     // c442059a1b
	//TODO: VFMSUB132PS Y2, Y15, Y11        // c462059ada
	//TODO: VFMSUB132PS Y11, Y15, Y11       // c442059adb
	//TODO: VFMSUB132SD (BX), X9, X2        // c4e2b19b13
	//TODO: VFMSUB132SD (R11), X9, X2       // c4c2b19b13
	//TODO: VFMSUB132SD X2, X9, X2          // c4e2b19bd2
	//TODO: VFMSUB132SD X11, X9, X2         // c4c2b19bd3
	//TODO: VFMSUB132SD (BX), X9, X11       // c462b19b1b
	//TODO: VFMSUB132SD (R11), X9, X11      // c442b19b1b
	//TODO: VFMSUB132SD X2, X9, X11         // c462b19bda
	//TODO: VFMSUB132SD X11, X9, X11        // c442b19bdb
	//TODO: VFMSUB132SS (BX), X9, X2        // c4e2319b13
	//TODO: VFMSUB132SS (R11), X9, X2       // c4c2319b13
	//TODO: VFMSUB132SS X2, X9, X2          // c4e2319bd2
	//TODO: VFMSUB132SS X11, X9, X2         // c4c2319bd3
	//TODO: VFMSUB132SS (BX), X9, X11       // c462319b1b
	//TODO: VFMSUB132SS (R11), X9, X11      // c442319b1b
	//TODO: VFMSUB132SS X2, X9, X11         // c462319bda
	//TODO: VFMSUB132SS X11, X9, X11        // c442319bdb
	//TODO: VFMSUB213PD (BX), X9, X2        // c4e2b1aa13
	//TODO: VFMSUB213PD (R11), X9, X2       // c4c2b1aa13
	//TODO: VFMSUB213PD X2, X9, X2          // c4e2b1aad2
	//TODO: VFMSUB213PD X11, X9, X2         // c4c2b1aad3
	//TODO: VFMSUB213PD (BX), X9, X11       // c462b1aa1b
	//TODO: VFMSUB213PD (R11), X9, X11      // c442b1aa1b
	//TODO: VFMSUB213PD X2, X9, X11         // c462b1aada
	//TODO: VFMSUB213PD X11, X9, X11        // c442b1aadb
	//TODO: VFMSUB213PD (BX), Y15, Y2       // c4e285aa13
	//TODO: VFMSUB213PD (R11), Y15, Y2      // c4c285aa13
	//TODO: VFMSUB213PD Y2, Y15, Y2         // c4e285aad2
	//TODO: VFMSUB213PD Y11, Y15, Y2        // c4c285aad3
	//TODO: VFMSUB213PD (BX), Y15, Y11      // c46285aa1b
	//TODO: VFMSUB213PD (R11), Y15, Y11     // c44285aa1b
	//TODO: VFMSUB213PD Y2, Y15, Y11        // c46285aada
	//TODO: VFMSUB213PD Y11, Y15, Y11       // c44285aadb
	//TODO: VFMSUB213PS (BX), X9, X2        // c4e231aa13
	//TODO: VFMSUB213PS (R11), X9, X2       // c4c231aa13
	//TODO: VFMSUB213PS X2, X9, X2          // c4e231aad2
	//TODO: VFMSUB213PS X11, X9, X2         // c4c231aad3
	//TODO: VFMSUB213PS (BX), X9, X11       // c46231aa1b
	//TODO: VFMSUB213PS (R11), X9, X11      // c44231aa1b
	//TODO: VFMSUB213PS X2, X9, X11         // c46231aada
	//TODO: VFMSUB213PS X11, X9, X11        // c44231aadb
	//TODO: VFMSUB213PS (BX), Y15, Y2       // c4e205aa13
	//TODO: VFMSUB213PS (R11), Y15, Y2      // c4c205aa13
	//TODO: VFMSUB213PS Y2, Y15, Y2         // c4e205aad2
	//TODO: VFMSUB213PS Y11, Y15, Y2        // c4c205aad3
	//TODO: VFMSUB213PS (BX), Y15, Y11      // c46205aa1b
	//TODO: VFMSUB213PS (R11), Y15, Y11     // c44205aa1b
	//TODO: VFMSUB213PS Y2, Y15, Y11        // c46205aada
	//TODO: VFMSUB213PS Y11, Y15, Y11       // c44205aadb
	//TODO: VFMSUB213SD (BX), X9, X2        // c4e2b1ab13
	//TODO: VFMSUB213SD (R11), X9, X2       // c4c2b1ab13
	//TODO: VFMSUB213SD X2, X9, X2          // c4e2b1abd2
	//TODO: VFMSUB213SD X11, X9, X2         // c4c2b1abd3
	//TODO: VFMSUB213SD (BX), X9, X11       // c462b1ab1b
	//TODO: VFMSUB213SD (R11), X9, X11      // c442b1ab1b
	//TODO: VFMSUB213SD X2, X9, X11         // c462b1abda
	//TODO: VFMSUB213SD X11, X9, X11        // c442b1abdb
	//TODO: VFMSUB213SS (BX), X9, X2        // c4e231ab13
	//TODO: VFMSUB213SS (R11), X9, X2       // c4c231ab13
	//TODO: VFMSUB213SS X2, X9, X2          // c4e231abd2
	//TODO: VFMSUB213SS X11, X9, X2         // c4c231abd3
	//TODO: VFMSUB213SS (BX), X9, X11       // c46231ab1b
	//TODO: VFMSUB213SS (R11), X9, X11      // c44231ab1b
	//TODO: VFMSUB213SS X2, X9, X11         // c46231abda
	//TODO: VFMSUB213SS X11, X9, X11        // c44231abdb
	//TODO: VFMSUB231PD (BX), X9, X2        // c4e2b1ba13
	//TODO: VFMSUB231PD (R11), X9, X2       // c4c2b1ba13
	//TODO: VFMSUB231PD X2, X9, X2          // c4e2b1bad2
	//TODO: VFMSUB231PD X11, X9, X2         // c4c2b1bad3
	//TODO: VFMSUB231PD (BX), X9, X11       // c462b1ba1b
	//TODO: VFMSUB231PD (R11), X9, X11      // c442b1ba1b
	//TODO: VFMSUB231PD X2, X9, X11         // c462b1bada
	//TODO: VFMSUB231PD X11, X9, X11        // c442b1badb
	//TODO: VFMSUB231PD (BX), Y15, Y2       // c4e285ba13
	//TODO: VFMSUB231PD (R11), Y15, Y2      // c4c285ba13
	//TODO: VFMSUB231PD Y2, Y15, Y2         // c4e285bad2
	//TODO: VFMSUB231PD Y11, Y15, Y2        // c4c285bad3
	//TODO: VFMSUB231PD (BX), Y15, Y11      // c46285ba1b
	//TODO: VFMSUB231PD (R11), Y15, Y11     // c44285ba1b
	//TODO: VFMSUB231PD Y2, Y15, Y11        // c46285bada
	//TODO: VFMSUB231PD Y11, Y15, Y11       // c44285badb
	//TODO: VFMSUB231PS (BX), X9, X2        // c4e231ba13
	//TODO: VFMSUB231PS (R11), X9, X2       // c4c231ba13
	//TODO: VFMSUB231PS X2, X9, X2          // c4e231bad2
	//TODO: VFMSUB231PS X11, X9, X2         // c4c231bad3
	//TODO: VFMSUB231PS (BX), X9, X11       // c46231ba1b
	//TODO: VFMSUB231PS (R11), X9, X11      // c44231ba1b
	//TODO: VFMSUB231PS X2, X9, X11         // c46231bada
	//TODO: VFMSUB231PS X11, X9, X11        // c44231badb
	//TODO: VFMSUB231PS (BX), Y15, Y2       // c4e205ba13
	//TODO: VFMSUB231PS (R11), Y15, Y2      // c4c205ba13
	//TODO: VFMSUB231PS Y2, Y15, Y2         // c4e205bad2
	//TODO: VFMSUB231PS Y11, Y15, Y2        // c4c205bad3
	//TODO: VFMSUB231PS (BX), Y15, Y11      // c46205ba1b
	//TODO: VFMSUB231PS (R11), Y15, Y11     // c44205ba1b
	//TODO: VFMSUB231PS Y2, Y15, Y11        // c46205bada
	//TODO: VFMSUB231PS Y11, Y15, Y11       // c44205badb
	//TODO: VFMSUB231SD (BX), X9, X2        // c4e2b1bb13
	//TODO: VFMSUB231SD (R11), X9, X2       // c4c2b1bb13
	//TODO: VFMSUB231SD X2, X9, X2          // c4e2b1bbd2
	//TODO: VFMSUB231SD X11, X9, X2         // c4c2b1bbd3
	//TODO: VFMSUB231SD (BX), X9, X11       // c462b1bb1b
	//TODO: VFMSUB231SD (R11), X9, X11      // c442b1bb1b
	//TODO: VFMSUB231SD X2, X9, X11         // c462b1bbda
	//TODO: VFMSUB231SD X11, X9, X11        // c442b1bbdb
	//TODO: VFMSUB231SS (BX), X9, X2        // c4e231bb13
	//TODO: VFMSUB231SS (R11), X9, X2       // c4c231bb13
	//TODO: VFMSUB231SS X2, X9, X2          // c4e231bbd2
	//TODO: VFMSUB231SS X11, X9, X2         // c4c231bbd3
	//TODO: VFMSUB231SS (BX), X9, X11       // c46231bb1b
	//TODO: VFMSUB231SS (R11), X9, X11      // c44231bb1b
	//TODO: VFMSUB231SS X2, X9, X11         // c46231bbda
	//TODO: VFMSUB231SS X11, X9, X11        // c44231bbdb
	//TODO: VFMSUBADD132PD (BX), X9, X2     // c4e2b19713
	//TODO: VFMSUBADD132PD (R11), X9, X2    // c4c2b19713
	//TODO: VFMSUBADD132PD X2, X9, X2       // c4e2b197d2
	//TODO: VFMSUBADD132PD X11, X9, X2      // c4c2b197d3
	//TODO: VFMSUBADD132PD (BX), X9, X11    // c462b1971b
	//TODO: VFMSUBADD132PD (R11), X9, X11   // c442b1971b
	//TODO: VFMSUBADD132PD X2, X9, X11      // c462b197da
	//TODO: VFMSUBADD132PD X11, X9, X11     // c442b197db
	//TODO: VFMSUBADD132PD (BX), Y15, Y2    // c4e2859713
	//TODO: VFMSUBADD132PD (R11), Y15, Y2   // c4c2859713
	//TODO: VFMSUBADD132PD Y2, Y15, Y2      // c4e28597d2
	//TODO: VFMSUBADD132PD Y11, Y15, Y2     // c4c28597d3
	//TODO: VFMSUBADD132PD (BX), Y15, Y11   // c46285971b
	//TODO: VFMSUBADD132PD (R11), Y15, Y11  // c44285971b
	//TODO: VFMSUBADD132PD Y2, Y15, Y11     // c4628597da
	//TODO: VFMSUBADD132PD Y11, Y15, Y11    // c4428597db
	//TODO: VFMSUBADD132PS (BX), X9, X2     // c4e2319713
	//TODO: VFMSUBADD132PS (R11), X9, X2    // c4c2319713
	//TODO: VFMSUBADD132PS X2, X9, X2       // c4e23197d2
	//TODO: VFMSUBADD132PS X11, X9, X2      // c4c23197d3
	//TODO: VFMSUBADD132PS (BX), X9, X11    // c46231971b
	//TODO: VFMSUBADD132PS (R11), X9, X11   // c44231971b
	//TODO: VFMSUBADD132PS X2, X9, X11      // c4623197da
	//TODO: VFMSUBADD132PS X11, X9, X11     // c4423197db
	//TODO: VFMSUBADD132PS (BX), Y15, Y2    // c4e2059713
	//TODO: VFMSUBADD132PS (R11), Y15, Y2   // c4c2059713
	//TODO: VFMSUBADD132PS Y2, Y15, Y2      // c4e20597d2
	//TODO: VFMSUBADD132PS Y11, Y15, Y2     // c4c20597d3
	//TODO: VFMSUBADD132PS (BX), Y15, Y11   // c46205971b
	//TODO: VFMSUBADD132PS (R11), Y15, Y11  // c44205971b
	//TODO: VFMSUBADD132PS Y2, Y15, Y11     // c4620597da
	//TODO: VFMSUBADD132PS Y11, Y15, Y11    // c4420597db
	//TODO: VFMSUBADD213PD (BX), X9, X2     // c4e2b1a713
	//TODO: VFMSUBADD213PD (R11), X9, X2    // c4c2b1a713
	//TODO: VFMSUBADD213PD X2, X9, X2       // c4e2b1a7d2
	//TODO: VFMSUBADD213PD X11, X9, X2      // c4c2b1a7d3
	//TODO: VFMSUBADD213PD (BX), X9, X11    // c462b1a71b
	//TODO: VFMSUBADD213PD (R11), X9, X11   // c442b1a71b
	//TODO: VFMSUBADD213PD X2, X9, X11      // c462b1a7da
	//TODO: VFMSUBADD213PD X11, X9, X11     // c442b1a7db
	//TODO: VFMSUBADD213PD (BX), Y15, Y2    // c4e285a713
	//TODO: VFMSUBADD213PD (R11), Y15, Y2   // c4c285a713
	//TODO: VFMSUBADD213PD Y2, Y15, Y2      // c4e285a7d2
	//TODO: VFMSUBADD213PD Y11, Y15, Y2     // c4c285a7d3
	//TODO: VFMSUBADD213PD (BX), Y15, Y11   // c46285a71b
	//TODO: VFMSUBADD213PD (R11), Y15, Y11  // c44285a71b
	//TODO: VFMSUBADD213PD Y2, Y15, Y11     // c46285a7da
	//TODO: VFMSUBADD213PD Y11, Y15, Y11    // c44285a7db
	//TODO: VFMSUBADD213PS (BX), X9, X2     // c4e231a713
	//TODO: VFMSUBADD213PS (R11), X9, X2    // c4c231a713
	//TODO: VFMSUBADD213PS X2, X9, X2       // c4e231a7d2
	//TODO: VFMSUBADD213PS X11, X9, X2      // c4c231a7d3
	//TODO: VFMSUBADD213PS (BX), X9, X11    // c46231a71b
	//TODO: VFMSUBADD213PS (R11), X9, X11   // c44231a71b
	//TODO: VFMSUBADD213PS X2, X9, X11      // c46231a7da
	//TODO: VFMSUBADD213PS X11, X9, X11     // c44231a7db
	//TODO: VFMSUBADD213PS (BX), Y15, Y2    // c4e205a713
	//TODO: VFMSUBADD213PS (R11), Y15, Y2   // c4c205a713
	//TODO: VFMSUBADD213PS Y2, Y15, Y2      // c4e205a7d2
	//TODO: VFMSUBADD213PS Y11, Y15, Y2     // c4c205a7d3
	//TODO: VFMSUBADD213PS (BX), Y15, Y11   // c46205a71b
	//TODO: VFMSUBADD213PS (R11), Y15, Y11  // c44205a71b
	//TODO: VFMSUBADD213PS Y2, Y15, Y11     // c46205a7da
	//TODO: VFMSUBADD213PS Y11, Y15, Y11    // c44205a7db
	//TODO: VFMSUBADD231PD (BX), X9, X2     // c4e2b1b713
	//TODO: VFMSUBADD231PD (R11), X9, X2    // c4c2b1b713
	//TODO: VFMSUBADD231PD X2, X9, X2       // c4e2b1b7d2
	//TODO: VFMSUBADD231PD X11, X9, X2      // c4c2b1b7d3
	//TODO: VFMSUBADD231PD (BX), X9, X11    // c462b1b71b
	//TODO: VFMSUBADD231PD (R11), X9, X11   // c442b1b71b
	//TODO: VFMSUBADD231PD X2, X9, X11      // c462b1b7da
	//TODO: VFMSUBADD231PD X11, X9, X11     // c442b1b7db
	//TODO: VFMSUBADD231PD (BX), Y15, Y2    // c4e285b713
	//TODO: VFMSUBADD231PD (R11), Y15, Y2   // c4c285b713
	//TODO: VFMSUBADD231PD Y2, Y15, Y2      // c4e285b7d2
	//TODO: VFMSUBADD231PD Y11, Y15, Y2     // c4c285b7d3
	//TODO: VFMSUBADD231PD (BX), Y15, Y11   // c46285b71b
	//TODO: VFMSUBADD231PD (R11), Y15, Y11  // c44285b71b
	//TODO: VFMSUBADD231PD Y2, Y15, Y11     // c46285b7da
	//TODO: VFMSUBADD231PD Y11, Y15, Y11    // c44285b7db
	//TODO: VFMSUBADD231PS (BX), X9, X2     // c4e231b713
	//TODO: VFMSUBADD231PS (R11), X9, X2    // c4c231b713
	//TODO: VFMSUBADD231PS X2, X9, X2       // c4e231b7d2
	//TODO: VFMSUBADD231PS X11, X9, X2      // c4c231b7d3
	//TODO: VFMSUBADD231PS (BX), X9, X11    // c46231b71b
	//TODO: VFMSUBADD231PS (R11), X9, X11   // c44231b71b
	//TODO: VFMSUBADD231PS X2, X9, X11      // c46231b7da
	//TODO: VFMSUBADD231PS X11, X9, X11     // c44231b7db
	//TODO: VFMSUBADD231PS (BX), Y15, Y2    // c4e205b713
	//TODO: VFMSUBADD231PS (R11), Y15, Y2   // c4c205b713
	//TODO: VFMSUBADD231PS Y2, Y15, Y2      // c4e205b7d2
	//TODO: VFMSUBADD231PS Y11, Y15, Y2     // c4c205b7d3
	//TODO: VFMSUBADD231PS (BX), Y15, Y11   // c46205b71b
	//TODO: VFMSUBADD231PS (R11), Y15, Y11  // c44205b71b
	//TODO: VFMSUBADD231PS Y2, Y15, Y11     // c46205b7da
	//TODO: VFMSUBADD231PS Y11, Y15, Y11    // c44205b7db
	//TODO: VFNMADD132PD (BX), X9, X2       // c4e2b19c13
	//TODO: VFNMADD132PD (R11), X9, X2      // c4c2b19c13
	//TODO: VFNMADD132PD X2, X9, X2         // c4e2b19cd2
	//TODO: VFNMADD132PD X11, X9, X2        // c4c2b19cd3
	//TODO: VFNMADD132PD (BX), X9, X11      // c462b19c1b
	//TODO: VFNMADD132PD (R11), X9, X11     // c442b19c1b
	//TODO: VFNMADD132PD X2, X9, X11        // c462b19cda
	//TODO: VFNMADD132PD X11, X9, X11       // c442b19cdb
	//TODO: VFNMADD132PD (BX), Y15, Y2      // c4e2859c13
	//TODO: VFNMADD132PD (R11), Y15, Y2     // c4c2859c13
	//TODO: VFNMADD132PD Y2, Y15, Y2        // c4e2859cd2
	//TODO: VFNMADD132PD Y11, Y15, Y2       // c4c2859cd3
	//TODO: VFNMADD132PD (BX), Y15, Y11     // c462859c1b
	//TODO: VFNMADD132PD (R11), Y15, Y11    // c442859c1b
	//TODO: VFNMADD132PD Y2, Y15, Y11       // c462859cda
	//TODO: VFNMADD132PD Y11, Y15, Y11      // c442859cdb
	//TODO: VFNMADD132PS (BX), X9, X2       // c4e2319c13
	//TODO: VFNMADD132PS (R11), X9, X2      // c4c2319c13
	//TODO: VFNMADD132PS X2, X9, X2         // c4e2319cd2
	//TODO: VFNMADD132PS X11, X9, X2        // c4c2319cd3
	//TODO: VFNMADD132PS (BX), X9, X11      // c462319c1b
	//TODO: VFNMADD132PS (R11), X9, X11     // c442319c1b
	//TODO: VFNMADD132PS X2, X9, X11        // c462319cda
	//TODO: VFNMADD132PS X11, X9, X11       // c442319cdb
	//TODO: VFNMADD132PS (BX), Y15, Y2      // c4e2059c13
	//TODO: VFNMADD132PS (R11), Y15, Y2     // c4c2059c13
	//TODO: VFNMADD132PS Y2, Y15, Y2        // c4e2059cd2
	//TODO: VFNMADD132PS Y11, Y15, Y2       // c4c2059cd3
	//TODO: VFNMADD132PS (BX), Y15, Y11     // c462059c1b
	//TODO: VFNMADD132PS (R11), Y15, Y11    // c442059c1b
	//TODO: VFNMADD132PS Y2, Y15, Y11       // c462059cda
	//TODO: VFNMADD132PS Y11, Y15, Y11      // c442059cdb
	//TODO: VFNMADD132SD (BX), X9, X2       // c4e2b19d13
	//TODO: VFNMADD132SD (R11), X9, X2      // c4c2b19d13
	//TODO: VFNMADD132SD X2, X9, X2         // c4e2b19dd2
	//TODO: VFNMADD132SD X11, X9, X2        // c4c2b19dd3
	//TODO: VFNMADD132SD (BX), X9, X11      // c462b19d1b
	//TODO: VFNMADD132SD (R11), X9, X11     // c442b19d1b
	//TODO: VFNMADD132SD X2, X9, X11        // c462b19dda
	//TODO: VFNMADD132SD X11, X9, X11       // c442b19ddb
	//TODO: VFNMADD132SS (BX), X9, X2       // c4e2319d13
	//TODO: VFNMADD132SS (R11), X9, X2      // c4c2319d13
	//TODO: VFNMADD132SS X2, X9, X2         // c4e2319dd2
	//TODO: VFNMADD132SS X11, X9, X2        // c4c2319dd3
	//TODO: VFNMADD132SS (BX), X9, X11      // c462319d1b
	//TODO: VFNMADD132SS (R11), X9, X11     // c442319d1b
	//TODO: VFNMADD132SS X2, X9, X11        // c462319dda
	//TODO: VFNMADD132SS X11, X9, X11       // c442319ddb
	//TODO: VFNMADD213PD (BX), X9, X2       // c4e2b1ac13
	//TODO: VFNMADD213PD (R11), X9, X2      // c4c2b1ac13
	//TODO: VFNMADD213PD X2, X9, X2         // c4e2b1acd2
	//TODO: VFNMADD213PD X11, X9, X2        // c4c2b1acd3
	//TODO: VFNMADD213PD (BX), X9, X11      // c462b1ac1b
	//TODO: VFNMADD213PD (R11), X9, X11     // c442b1ac1b
	//TODO: VFNMADD213PD X2, X9, X11        // c462b1acda
	//TODO: VFNMADD213PD X11, X9, X11       // c442b1acdb
	//TODO: VFNMADD213PD (BX), Y15, Y2      // c4e285ac13
	//TODO: VFNMADD213PD (R11), Y15, Y2     // c4c285ac13
	//TODO: VFNMADD213PD Y2, Y15, Y2        // c4e285acd2
	//TODO: VFNMADD213PD Y11, Y15, Y2       // c4c285acd3
	//TODO: VFNMADD213PD (BX), Y15, Y11     // c46285ac1b
	//TODO: VFNMADD213PD (R11), Y15, Y11    // c44285ac1b
	//TODO: VFNMADD213PD Y2, Y15, Y11       // c46285acda
	//TODO: VFNMADD213PD Y11, Y15, Y11      // c44285acdb
	//TODO: VFNMADD213PS (BX), X9, X2       // c4e231ac13
	//TODO: VFNMADD213PS (R11), X9, X2      // c4c231ac13
	//TODO: VFNMADD213PS X2, X9, X2         // c4e231acd2
	//TODO: VFNMADD213PS X11, X9, X2        // c4c231acd3
	//TODO: VFNMADD213PS (BX), X9, X11      // c46231ac1b
	//TODO: VFNMADD213PS (R11), X9, X11     // c44231ac1b
	//TODO: VFNMADD213PS X2, X9, X11        // c46231acda
	//TODO: VFNMADD213PS X11, X9, X11       // c44231acdb
	//TODO: VFNMADD213PS (BX), Y15, Y2      // c4e205ac13
	//TODO: VFNMADD213PS (R11), Y15, Y2     // c4c205ac13
	//TODO: VFNMADD213PS Y2, Y15, Y2        // c4e205acd2
	//TODO: VFNMADD213PS Y11, Y15, Y2       // c4c205acd3
	//TODO: VFNMADD213PS (BX), Y15, Y11     // c46205ac1b
	//TODO: VFNMADD213PS (R11), Y15, Y11    // c44205ac1b
	//TODO: VFNMADD213PS Y2, Y15, Y11       // c46205acda
	//TODO: VFNMADD213PS Y11, Y15, Y11      // c44205acdb
	//TODO: VFNMADD213SD (BX), X9, X2       // c4e2b1ad13
	//TODO: VFNMADD213SD (R11), X9, X2      // c4c2b1ad13
	//TODO: VFNMADD213SD X2, X9, X2         // c4e2b1add2
	//TODO: VFNMADD213SD X11, X9, X2        // c4c2b1add3
	//TODO: VFNMADD213SD (BX), X9, X11      // c462b1ad1b
	//TODO: VFNMADD213SD (R11), X9, X11     // c442b1ad1b
	//TODO: VFNMADD213SD X2, X9, X11        // c462b1adda
	//TODO: VFNMADD213SD X11, X9, X11       // c442b1addb
	//TODO: VFNMADD213SS (BX), X9, X2       // c4e231ad13
	//TODO: VFNMADD213SS (R11), X9, X2      // c4c231ad13
	//TODO: VFNMADD213SS X2, X9, X2         // c4e231add2
	//TODO: VFNMADD213SS X11, X9, X2        // c4c231add3
	//TODO: VFNMADD213SS (BX), X9, X11      // c46231ad1b
	//TODO: VFNMADD213SS (R11), X9, X11     // c44231ad1b
	//TODO: VFNMADD213SS X2, X9, X11        // c46231adda
	//TODO: VFNMADD213SS X11, X9, X11       // c44231addb
	//TODO: VFNMADD231PD (BX), X9, X2       // c4e2b1bc13
	//TODO: VFNMADD231PD (R11), X9, X2      // c4c2b1bc13
	//TODO: VFNMADD231PD X2, X9, X2         // c4e2b1bcd2
	//TODO: VFNMADD231PD X11, X9, X2        // c4c2b1bcd3
	//TODO: VFNMADD231PD (BX), X9, X11      // c462b1bc1b
	//TODO: VFNMADD231PD (R11), X9, X11     // c442b1bc1b
	//TODO: VFNMADD231PD X2, X9, X11        // c462b1bcda
	//TODO: VFNMADD231PD X11, X9, X11       // c442b1bcdb
	//TODO: VFNMADD231PD (BX), Y15, Y2      // c4e285bc13
	//TODO: VFNMADD231PD (R11), Y15, Y2     // c4c285bc13
	//TODO: VFNMADD231PD Y2, Y15, Y2        // c4e285bcd2
	//TODO: VFNMADD231PD Y11, Y15, Y2       // c4c285bcd3
	//TODO: VFNMADD231PD (BX), Y15, Y11     // c46285bc1b
	//TODO: VFNMADD231PD (R11), Y15, Y11    // c44285bc1b
	//TODO: VFNMADD231PD Y2, Y15, Y11       // c46285bcda
	//TODO: VFNMADD231PD Y11, Y15, Y11      // c44285bcdb
	//TODO: VFNMADD231PS (BX), X9, X2       // c4e231bc13
	//TODO: VFNMADD231PS (R11), X9, X2      // c4c231bc13
	//TODO: VFNMADD231PS X2, X9, X2         // c4e231bcd2
	//TODO: VFNMADD231PS X11, X9, X2        // c4c231bcd3
	//TODO: VFNMADD231PS (BX), X9, X11      // c46231bc1b
	//TODO: VFNMADD231PS (R11), X9, X11     // c44231bc1b
	//TODO: VFNMADD231PS X2, X9, X11        // c46231bcda
	//TODO: VFNMADD231PS X11, X9, X11       // c44231bcdb
	//TODO: VFNMADD231PS (BX), Y15, Y2      // c4e205bc13
	//TODO: VFNMADD231PS (R11), Y15, Y2     // c4c205bc13
	//TODO: VFNMADD231PS Y2, Y15, Y2        // c4e205bcd2
	//TODO: VFNMADD231PS Y11, Y15, Y2       // c4c205bcd3
	//TODO: VFNMADD231PS (BX), Y15, Y11     // c46205bc1b
	//TODO: VFNMADD231PS (R11), Y15, Y11    // c44205bc1b
	//TODO: VFNMADD231PS Y2, Y15, Y11       // c46205bcda
	//TODO: VFNMADD231PS Y11, Y15, Y11      // c44205bcdb
	//TODO: VFNMADD231SD (BX), X9, X2       // c4e2b1bd13
	//TODO: VFNMADD231SD (R11), X9, X2      // c4c2b1bd13
	//TODO: VFNMADD231SD X2, X9, X2         // c4e2b1bdd2
	//TODO: VFNMADD231SD X11, X9, X2        // c4c2b1bdd3
	//TODO: VFNMADD231SD (BX), X9, X11      // c462b1bd1b
	//TODO: VFNMADD231SD (R11), X9, X11     // c442b1bd1b
	//TODO: VFNMADD231SD X2, X9, X11        // c462b1bdda
	//TODO: VFNMADD231SD X11, X9, X11       // c442b1bddb
	//TODO: VFNMADD231SS (BX), X9, X2       // c4e231bd13
	//TODO: VFNMADD231SS (R11), X9, X2      // c4c231bd13
	//TODO: VFNMADD231SS X2, X9, X2         // c4e231bdd2
	//TODO: VFNMADD231SS X11, X9, X2        // c4c231bdd3
	//TODO: VFNMADD231SS (BX), X9, X11      // c46231bd1b
	//TODO: VFNMADD231SS (R11), X9, X11     // c44231bd1b
	//TODO: VFNMADD231SS X2, X9, X11        // c46231bdda
	//TODO: VFNMADD231SS X11, X9, X11       // c44231bddb
	//TODO: VFNMSUB132PD (BX), X9, X2       // c4e2b19e13
	//TODO: VFNMSUB132PD (R11), X9, X2      // c4c2b19e13
	//TODO: VFNMSUB132PD X2, X9, X2         // c4e2b19ed2
	//TODO: VFNMSUB132PD X11, X9, X2        // c4c2b19ed3
	//TODO: VFNMSUB132PD (BX), X9, X11      // c462b19e1b
	//TODO: VFNMSUB132PD (R11), X9, X11     // c442b19e1b
	//TODO: VFNMSUB132PD X2, X9, X11        // c462b19eda
	//TODO: VFNMSUB132PD X11, X9, X11       // c442b19edb
	//TODO: VFNMSUB132PD (BX), Y15, Y2      // c4e2859e13
	//TODO: VFNMSUB132PD (R11), Y15, Y2     // c4c2859e13
	//TODO: VFNMSUB132PD Y2, Y15, Y2        // c4e2859ed2
	//TODO: VFNMSUB132PD Y11, Y15, Y2       // c4c2859ed3
	//TODO: VFNMSUB132PD (BX), Y15, Y11     // c462859e1b
	//TODO: VFNMSUB132PD (R11), Y15, Y11    // c442859e1b
	//TODO: VFNMSUB132PD Y2, Y15, Y11       // c462859eda
	//TODO: VFNMSUB132PD Y11, Y15, Y11      // c442859edb
	//TODO: VFNMSUB132PS (BX), X9, X2       // c4e2319e13
	//TODO: VFNMSUB132PS (R11), X9, X2      // c4c2319e13
	//TODO: VFNMSUB132PS X2, X9, X2         // c4e2319ed2
	//TODO: VFNMSUB132PS X11, X9, X2        // c4c2319ed3
	//TODO: VFNMSUB132PS (BX), X9, X11      // c462319e1b
	//TODO: VFNMSUB132PS (R11), X9, X11     // c442319e1b
	//TODO: VFNMSUB132PS X2, X9, X11        // c462319eda
	//TODO: VFNMSUB132PS X11, X9, X11       // c442319edb
	//TODO: VFNMSUB132PS (BX), Y15, Y2      // c4e2059e13
	//TODO: VFNMSUB132PS (R11), Y15, Y2     // c4c2059e13
	//TODO: VFNMSUB132PS Y2, Y15, Y2        // c4e2059ed2
	//TODO: VFNMSUB132PS Y11, Y15, Y2       // c4c2059ed3
	//TODO: VFNMSUB132PS (BX), Y15, Y11     // c462059e1b
	//TODO: VFNMSUB132PS (R11), Y15, Y11    // c442059e1b
	//TODO: VFNMSUB132PS Y2, Y15, Y11       // c462059eda
	//TODO: VFNMSUB132PS Y11, Y15, Y11      // c442059edb
	//TODO: VFNMSUB132SD (BX), X9, X2       // c4e2b19f13
	//TODO: VFNMSUB132SD (R11), X9, X2      // c4c2b19f13
	//TODO: VFNMSUB132SD X2, X9, X2         // c4e2b19fd2
	//TODO: VFNMSUB132SD X11, X9, X2        // c4c2b19fd3
	//TODO: VFNMSUB132SD (BX), X9, X11      // c462b19f1b
	//TODO: VFNMSUB132SD (R11), X9, X11     // c442b19f1b
	//TODO: VFNMSUB132SD X2, X9, X11        // c462b19fda
	//TODO: VFNMSUB132SD X11, X9, X11       // c442b19fdb
	//TODO: VFNMSUB132SS (BX), X9, X2       // c4e2319f13
	//TODO: VFNMSUB132SS (R11), X9, X2      // c4c2319f13
	//TODO: VFNMSUB132SS X2, X9, X2         // c4e2319fd2
	//TODO: VFNMSUB132SS X11, X9, X2        // c4c2319fd3
	//TODO: VFNMSUB132SS (BX), X9, X11      // c462319f1b
	//TODO: VFNMSUB132SS (R11), X9, X11     // c442319f1b
	//TODO: VFNMSUB132SS X2, X9, X11        // c462319fda
	//TODO: VFNMSUB132SS X11, X9, X11       // c442319fdb
	//TODO: VFNMSUB213PD (BX), X9, X2       // c4e2b1ae13
	//TODO: VFNMSUB213PD (R11), X9, X2      // c4c2b1ae13
	//TODO: VFNMSUB213PD X2, X9, X2         // c4e2b1aed2
	//TODO: VFNMSUB213PD X11, X9, X2        // c4c2b1aed3
	//TODO: VFNMSUB213PD (BX), X9, X11      // c462b1ae1b
	//TODO: VFNMSUB213PD (R11), X9, X11     // c442b1ae1b
	//TODO: VFNMSUB213PD X2, X9, X11        // c462b1aeda
	//TODO: VFNMSUB213PD X11, X9, X11       // c442b1aedb
	//TODO: VFNMSUB213PD (BX), Y15, Y2      // c4e285ae13
	//TODO: VFNMSUB213PD (R11), Y15, Y2     // c4c285ae13
	//TODO: VFNMSUB213PD Y2, Y15, Y2        // c4e285aed2
	//TODO: VFNMSUB213PD Y11, Y15, Y2       // c4c285aed3
	//TODO: VFNMSUB213PD (BX), Y15, Y11     // c46285ae1b
	//TODO: VFNMSUB213PD (R11), Y15, Y11    // c44285ae1b
	//TODO: VFNMSUB213PD Y2, Y15, Y11       // c46285aeda
	//TODO: VFNMSUB213PD Y11, Y15, Y11      // c44285aedb
	//TODO: VFNMSUB213PS (BX), X9, X2       // c4e231ae13
	//TODO: VFNMSUB213PS (R11), X9, X2      // c4c231ae13
	//TODO: VFNMSUB213PS X2, X9, X2         // c4e231aed2
	//TODO: VFNMSUB213PS X11, X9, X2        // c4c231aed3
	//TODO: VFNMSUB213PS (BX), X9, X11      // c46231ae1b
	//TODO: VFNMSUB213PS (R11), X9, X11     // c44231ae1b
	//TODO: VFNMSUB213PS X2, X9, X11        // c46231aeda
	//TODO: VFNMSUB213PS X11, X9, X11       // c44231aedb
	//TODO: VFNMSUB213PS (BX), Y15, Y2      // c4e205ae13
	//TODO: VFNMSUB213PS (R11), Y15, Y2     // c4c205ae13
	//TODO: VFNMSUB213PS Y2, Y15, Y2        // c4e205aed2
	//TODO: VFNMSUB213PS Y11, Y15, Y2       // c4c205aed3
	//TODO: VFNMSUB213PS (BX), Y15, Y11     // c46205ae1b
	//TODO: VFNMSUB213PS (R11), Y15, Y11    // c44205ae1b
	//TODO: VFNMSUB213PS Y2, Y15, Y11       // c46205aeda
	//TODO: VFNMSUB213PS Y11, Y15, Y11      // c44205aedb
	//TODO: VFNMSUB213SD (BX), X9, X2       // c4e2b1af13
	//TODO: VFNMSUB213SD (R11), X9, X2      // c4c2b1af13
	//TODO: VFNMSUB213SD X2, X9, X2         // c4e2b1afd2
	//TODO: VFNMSUB213SD X11, X9, X2        // c4c2b1afd3
	//TODO: VFNMSUB213SD (BX), X9, X11      // c462b1af1b
	//TODO: VFNMSUB213SD (R11), X9, X11     // c442b1af1b
	//TODO: VFNMSUB213SD X2, X9, X11        // c462b1afda
	//TODO: VFNMSUB213SD X11, X9, X11       // c442b1afdb
	//TODO: VFNMSUB213SS (BX), X9, X2       // c4e231af13
	//TODO: VFNMSUB213SS (R11), X9, X2      // c4c231af13
	//TODO: VFNMSUB213SS X2, X9, X2         // c4e231afd2
	//TODO: VFNMSUB213SS X11, X9, X2        // c4c231afd3
	//TODO: VFNMSUB213SS (BX), X9, X11      // c46231af1b
	//TODO: VFNMSUB213SS (R11), X9, X11     // c44231af1b
	//TODO: VFNMSUB213SS X2, X9, X11        // c46231afda
	//TODO: VFNMSUB213SS X11, X9, X11       // c44231afdb
	//TODO: VFNMSUB231PD (BX), X9, X2       // c4e2b1be13
	//TODO: VFNMSUB231PD (R11), X9, X2      // c4c2b1be13
	//TODO: VFNMSUB231PD X2, X9, X2         // c4e2b1bed2
	//TODO: VFNMSUB231PD X11, X9, X2        // c4c2b1bed3
	//TODO: VFNMSUB231PD (BX), X9, X11      // c462b1be1b
	//TODO: VFNMSUB231PD (R11), X9, X11     // c442b1be1b
	//TODO: VFNMSUB231PD X2, X9, X11        // c462b1beda
	//TODO: VFNMSUB231PD X11, X9, X11       // c442b1bedb
	//TODO: VFNMSUB231PD (BX), Y15, Y2      // c4e285be13
	//TODO: VFNMSUB231PD (R11), Y15, Y2     // c4c285be13
	//TODO: VFNMSUB231PD Y2, Y15, Y2        // c4e285bed2
	//TODO: VFNMSUB231PD Y11, Y15, Y2       // c4c285bed3
	//TODO: VFNMSUB231PD (BX), Y15, Y11     // c46285be1b
	//TODO: VFNMSUB231PD (R11), Y15, Y11    // c44285be1b
	//TODO: VFNMSUB231PD Y2, Y15, Y11       // c46285beda
	//TODO: VFNMSUB231PD Y11, Y15, Y11      // c44285bedb
	//TODO: VFNMSUB231PS (BX), X9, X2       // c4e231be13
	//TODO: VFNMSUB231PS (R11), X9, X2      // c4c231be13
	//TODO: VFNMSUB231PS X2, X9, X2         // c4e231bed2
	//TODO: VFNMSUB231PS X11, X9, X2        // c4c231bed3
	//TODO: VFNMSUB231PS (BX), X9, X11      // c46231be1b
	//TODO: VFNMSUB231PS (R11), X9, X11     // c44231be1b
	//TODO: VFNMSUB231PS X2, X9, X11        // c46231beda
	//TODO: VFNMSUB231PS X11, X9, X11       // c44231bedb
	//TODO: VFNMSUB231PS (BX), Y15, Y2      // c4e205be13
	//TODO: VFNMSUB231PS (R11), Y15, Y2     // c4c205be13
	//TODO: VFNMSUB231PS Y2, Y15, Y2        // c4e205bed2
	//TODO: VFNMSUB231PS Y11, Y15, Y2       // c4c205bed3
	//TODO: VFNMSUB231PS (BX), Y15, Y11     // c46205be1b
	//TODO: VFNMSUB231PS (R11), Y15, Y11    // c44205be1b
	//TODO: VFNMSUB231PS Y2, Y15, Y11       // c46205beda
	//TODO: VFNMSUB231PS Y11, Y15, Y11      // c44205bedb
	//TODO: VFNMSUB231SD (BX), X9, X2       // c4e2b1bf13
	//TODO: VFNMSUB231SD (R11), X9, X2      // c4c2b1bf13
	//TODO: VFNMSUB231SD X2, X9, X2         // c4e2b1bfd2
	//TODO: VFNMSUB231SD X11, X9, X2        // c4c2b1bfd3
	//TODO: VFNMSUB231SD (BX), X9, X11      // c462b1bf1b
	//TODO: VFNMSUB231SD (R11), X9, X11     // c442b1bf1b
	//TODO: VFNMSUB231SD X2, X9, X11        // c462b1bfda
	//TODO: VFNMSUB231SD X11, X9, X11       // c442b1bfdb
	//TODO: VFNMSUB231SS (BX), X9, X2       // c4e231bf13
	//TODO: VFNMSUB231SS (R11), X9, X2      // c4c231bf13
	//TODO: VFNMSUB231SS X2, X9, X2         // c4e231bfd2
	//TODO: VFNMSUB231SS X11, X9, X2        // c4c231bfd3
	//TODO: VFNMSUB231SS (BX), X9, X11      // c46231bf1b
	//TODO: VFNMSUB231SS (R11), X9, X11     // c44231bf1b
	//TODO: VFNMSUB231SS X2, X9, X11        // c46231bfda
	//TODO: VFNMSUB231SS X11, X9, X11       // c44231bfdb
	//TODO: VHADDPD (BX), X9, X2            // c4e1317c13 or c5b17c13
	//TODO: VHADDPD (R11), X9, X2           // c4c1317c13
	//TODO: VHADDPD X2, X9, X2              // c4e1317cd2 or c5b17cd2
	//TODO: VHADDPD X11, X9, X2             // c4c1317cd3
	//TODO: VHADDPD (BX), X9, X11           // c461317c1b or c5317c1b
	//TODO: VHADDPD (R11), X9, X11          // c441317c1b
	//TODO: VHADDPD X2, X9, X11             // c461317cda or c5317cda
	//TODO: VHADDPD X11, X9, X11            // c441317cdb
	//TODO: VHADDPD (BX), Y15, Y2           // c4e1057c13 or c5857c13
	//TODO: VHADDPD (R11), Y15, Y2          // c4c1057c13
	//TODO: VHADDPD Y2, Y15, Y2             // c4e1057cd2 or c5857cd2
	//TODO: VHADDPD Y11, Y15, Y2            // c4c1057cd3
	//TODO: VHADDPD (BX), Y15, Y11          // c461057c1b or c5057c1b
	//TODO: VHADDPD (R11), Y15, Y11         // c441057c1b
	//TODO: VHADDPD Y2, Y15, Y11            // c461057cda or c5057cda
	//TODO: VHADDPD Y11, Y15, Y11           // c441057cdb
	//TODO: VHADDPS (BX), X9, X2            // c4e1337c13 or c5b37c13
	//TODO: VHADDPS (R11), X9, X2           // c4c1337c13
	//TODO: VHADDPS X2, X9, X2              // c4e1337cd2 or c5b37cd2
	//TODO: VHADDPS X11, X9, X2             // c4c1337cd3
	//TODO: VHADDPS (BX), X9, X11           // c461337c1b or c5337c1b
	//TODO: VHADDPS (R11), X9, X11          // c441337c1b
	//TODO: VHADDPS X2, X9, X11             // c461337cda or c5337cda
	//TODO: VHADDPS X11, X9, X11            // c441337cdb
	//TODO: VHADDPS (BX), Y15, Y2           // c4e1077c13 or c5877c13
	//TODO: VHADDPS (R11), Y15, Y2          // c4c1077c13
	//TODO: VHADDPS Y2, Y15, Y2             // c4e1077cd2 or c5877cd2
	//TODO: VHADDPS Y11, Y15, Y2            // c4c1077cd3
	//TODO: VHADDPS (BX), Y15, Y11          // c461077c1b or c5077c1b
	//TODO: VHADDPS (R11), Y15, Y11         // c441077c1b
	//TODO: VHADDPS Y2, Y15, Y11            // c461077cda or c5077cda
	//TODO: VHADDPS Y11, Y15, Y11           // c441077cdb
	//TODO: VHSUBPD (BX), X9, X2            // c4e1317d13 or c5b17d13
	//TODO: VHSUBPD (R11), X9, X2           // c4c1317d13
	//TODO: VHSUBPD X2, X9, X2              // c4e1317dd2 or c5b17dd2
	//TODO: VHSUBPD X11, X9, X2             // c4c1317dd3
	//TODO: VHSUBPD (BX), X9, X11           // c461317d1b or c5317d1b
	//TODO: VHSUBPD (R11), X9, X11          // c441317d1b
	//TODO: VHSUBPD X2, X9, X11             // c461317dda or c5317dda
	//TODO: VHSUBPD X11, X9, X11            // c441317ddb
	//TODO: VHSUBPD (BX), Y15, Y2           // c4e1057d13 or c5857d13
	//TODO: VHSUBPD (R11), Y15, Y2          // c4c1057d13
	//TODO: VHSUBPD Y2, Y15, Y2             // c4e1057dd2 or c5857dd2
	//TODO: VHSUBPD Y11, Y15, Y2            // c4c1057dd3
	//TODO: VHSUBPD (BX), Y15, Y11          // c461057d1b or c5057d1b
	//TODO: VHSUBPD (R11), Y15, Y11         // c441057d1b
	//TODO: VHSUBPD Y2, Y15, Y11            // c461057dda or c5057dda
	//TODO: VHSUBPD Y11, Y15, Y11           // c441057ddb
	//TODO: VHSUBPS (BX), X9, X2            // c4e1337d13 or c5b37d13
	//TODO: VHSUBPS (R11), X9, X2           // c4c1337d13
	//TODO: VHSUBPS X2, X9, X2              // c4e1337dd2 or c5b37dd2
	//TODO: VHSUBPS X11, X9, X2             // c4c1337dd3
	//TODO: VHSUBPS (BX), X9, X11           // c461337d1b or c5337d1b
	//TODO: VHSUBPS (R11), X9, X11          // c441337d1b
	//TODO: VHSUBPS X2, X9, X11             // c461337dda or c5337dda
	//TODO: VHSUBPS X11, X9, X11            // c441337ddb
	//TODO: VHSUBPS (BX), Y15, Y2           // c4e1077d13 or c5877d13
	//TODO: VHSUBPS (R11), Y15, Y2          // c4c1077d13
	//TODO: VHSUBPS Y2, Y15, Y2             // c4e1077dd2 or c5877dd2
	//TODO: VHSUBPS Y11, Y15, Y2            // c4c1077dd3
	//TODO: VHSUBPS (BX), Y15, Y11          // c461077d1b or c5077d1b
	//TODO: VHSUBPS (R11), Y15, Y11         // c441077d1b
	//TODO: VHSUBPS Y2, Y15, Y11            // c461077dda or c5077dda
	//TODO: VHSUBPS Y11, Y15, Y11           // c441077ddb
	//TODO: VINSERTF128 $7, (BX), Y15, Y2   // c4e305181307
	//TODO: VINSERTF128 $7, (R11), Y15, Y2  // c4c305181307
	//TODO: VINSERTF128 $7, X2, Y15, Y2     // c4e30518d207
	//TODO: VINSERTF128 $7, X11, Y15, Y2    // c4c30518d307
	//TODO: VINSERTF128 $7, (BX), Y15, Y11  // c46305181b07
	//TODO: VINSERTF128 $7, (R11), Y15, Y11 // c44305181b07
	//TODO: VINSERTF128 $7, X2, Y15, Y11    // c4630518da07
	//TODO: VINSERTF128 $7, X11, Y15, Y11   // c4430518db07
	//TODO: VINSERTI128 $7, (BX), Y15, Y2   // c4e305381307
	//TODO: VINSERTI128 $7, (R11), Y15, Y2  // c4c305381307
	//TODO: VINSERTI128 $7, X2, Y15, Y2     // c4e30538d207
	//TODO: VINSERTI128 $7, X11, Y15, Y2    // c4c30538d307
	//TODO: VINSERTI128 $7, (BX), Y15, Y11  // c46305381b07
	//TODO: VINSERTI128 $7, (R11), Y15, Y11 // c44305381b07
	//TODO: VINSERTI128 $7, X2, Y15, Y11    // c4630538da07
	//TODO: VINSERTI128 $7, X11, Y15, Y11   // c4430538db07
	//TODO: VINSERTPS $7, (BX), X9, X2      // c4e331211307
	//TODO: VINSERTPS $7, (R11), X9, X2     // c4c331211307
	//TODO: VINSERTPS $7, X2, X9, X2        // c4e33121d207
	//TODO: VINSERTPS $7, X11, X9, X2       // c4c33121d307
	//TODO: VINSERTPS $7, (BX), X9, X11     // c46331211b07
	//TODO: VINSERTPS $7, (R11), X9, X11    // c44331211b07
	//TODO: VINSERTPS $7, X2, X9, X11       // c4633121da07
	//TODO: VINSERTPS $7, X11, X9, X11      // c4433121db07
	//TODO: VLDDQU (BX), X2                 // c4e17bf013 or c5fbf013
	//TODO: VLDDQU (R11), X2                // c4c17bf013
	//TODO: VLDDQU (BX), X11                // c4617bf01b or c57bf01b
	//TODO: VLDDQU (R11), X11               // c4417bf01b
	//TODO: VLDDQU (BX), Y2                 // c4e17ff013 or c5fff013
	//TODO: VLDDQU (R11), Y2                // c4c17ff013
	//TODO: VLDDQU (BX), Y11                // c4617ff01b or c57ff01b
	//TODO: VLDDQU (R11), Y11               // c4417ff01b
	//TODO: VLDMXCSR (BX)                   // c4e178ae13 or c5f8ae13
	//TODO: VLDMXCSR (R11)                  // c4c178ae13
	//TODO: VMASKMOVDQU X2, X2              // c4e179f7d2 or c5f9f7d2
	//TODO: VMASKMOVDQU X11, X2             // c4c179f7d3
	//TODO: VMASKMOVDQU X2, X11             // c46179f7da or c579f7da
	//TODO: VMASKMOVDQU X11, X11            // c44179f7db
	//TODO: VMASKMOVPD X2, X9, (BX)         // c4e2312f13
	//TODO: VMASKMOVPD X11, X9, (BX)        // c462312f1b
	//TODO: VMASKMOVPD X2, X9, (R11)        // c4c2312f13
	//TODO: VMASKMOVPD X11, X9, (R11)       // c442312f1b
	//TODO: VMASKMOVPD Y2, Y15, (BX)        // c4e2052f13
	//TODO: VMASKMOVPD Y11, Y15, (BX)       // c462052f1b
	//TODO: VMASKMOVPD Y2, Y15, (R11)       // c4c2052f13
	//TODO: VMASKMOVPD Y11, Y15, (R11)      // c442052f1b
	//TODO: VMASKMOVPD (BX), X9, X2         // c4e2312d13
	//TODO: VMASKMOVPD (R11), X9, X2        // c4c2312d13
	//TODO: VMASKMOVPD (BX), X9, X11        // c462312d1b
	//TODO: VMASKMOVPD (R11), X9, X11       // c442312d1b
	//TODO: VMASKMOVPD (BX), Y15, Y2        // c4e2052d13
	//TODO: VMASKMOVPD (R11), Y15, Y2       // c4c2052d13
	//TODO: VMASKMOVPD (BX), Y15, Y11       // c462052d1b
	//TODO: VMASKMOVPD (R11), Y15, Y11      // c442052d1b
	//TODO: VMASKMOVPS X2, X9, (BX)         // c4e2312e13
	//TODO: VMASKMOVPS X11, X9, (BX)        // c462312e1b
	//TODO: VMASKMOVPS X2, X9, (R11)        // c4c2312e13
	//TODO: VMASKMOVPS X11, X9, (R11)       // c442312e1b
	//TODO: VMASKMOVPS Y2, Y15, (BX)        // c4e2052e13
	//TODO: VMASKMOVPS Y11, Y15, (BX)       // c462052e1b
	//TODO: VMASKMOVPS Y2, Y15, (R11)       // c4c2052e13
	//TODO: VMASKMOVPS Y11, Y15, (R11)      // c442052e1b
	//TODO: VMASKMOVPS (BX), X9, X2         // c4e2312c13
	//TODO: VMASKMOVPS (R11), X9, X2        // c4c2312c13
	//TODO: VMASKMOVPS (BX), X9, X11        // c462312c1b
	//TODO: VMASKMOVPS (R11), X9, X11       // c442312c1b
	//TODO: VMASKMOVPS (BX), Y15, Y2        // c4e2052c13
	//TODO: VMASKMOVPS (R11), Y15, Y2       // c4c2052c13
	//TODO: VMASKMOVPS (BX), Y15, Y11       // c462052c1b
	//TODO: VMASKMOVPS (R11), Y15, Y11      // c442052c1b
	//TODO: VMAXPD (BX), X9, X2             // c4e1315f13 or c5b15f13
	//TODO: VMAXPD (R11), X9, X2            // c4c1315f13
	//TODO: VMAXPD X2, X9, X2               // c4e1315fd2 or c5b15fd2
	//TODO: VMAXPD X11, X9, X2              // c4c1315fd3
	//TODO: VMAXPD (BX), X9, X11            // c461315f1b or c5315f1b
	//TODO: VMAXPD (R11), X9, X11           // c441315f1b
	//TODO: VMAXPD X2, X9, X11              // c461315fda or c5315fda
	//TODO: VMAXPD X11, X9, X11             // c441315fdb
	//TODO: VMAXPD (BX), Y15, Y2            // c4e1055f13 or c5855f13
	//TODO: VMAXPD (R11), Y15, Y2           // c4c1055f13
	//TODO: VMAXPD Y2, Y15, Y2              // c4e1055fd2 or c5855fd2
	//TODO: VMAXPD Y11, Y15, Y2             // c4c1055fd3
	//TODO: VMAXPD (BX), Y15, Y11           // c461055f1b or c5055f1b
	//TODO: VMAXPD (R11), Y15, Y11          // c441055f1b
	//TODO: VMAXPD Y2, Y15, Y11             // c461055fda or c5055fda
	//TODO: VMAXPD Y11, Y15, Y11            // c441055fdb
	//TODO: VMAXPS (BX), X9, X2             // c4e1305f13 or c5b05f13
	//TODO: VMAXPS (R11), X9, X2            // c4c1305f13
	//TODO: VMAXPS X2, X9, X2               // c4e1305fd2 or c5b05fd2
	//TODO: VMAXPS X11, X9, X2              // c4c1305fd3
	//TODO: VMAXPS (BX), X9, X11            // c461305f1b or c5305f1b
	//TODO: VMAXPS (R11), X9, X11           // c441305f1b
	//TODO: VMAXPS X2, X9, X11              // c461305fda or c5305fda
	//TODO: VMAXPS X11, X9, X11             // c441305fdb
	//TODO: VMAXPS (BX), Y15, Y2            // c4e1045f13 or c5845f13
	//TODO: VMAXPS (R11), Y15, Y2           // c4c1045f13
	//TODO: VMAXPS Y2, Y15, Y2              // c4e1045fd2 or c5845fd2
	//TODO: VMAXPS Y11, Y15, Y2             // c4c1045fd3
	//TODO: VMAXPS (BX), Y15, Y11           // c461045f1b or c5045f1b
	//TODO: VMAXPS (R11), Y15, Y11          // c441045f1b
	//TODO: VMAXPS Y2, Y15, Y11             // c461045fda or c5045fda
	//TODO: VMAXPS Y11, Y15, Y11            // c441045fdb
	//TODO: VMAXSD (BX), X9, X2             // c4e1335f13 or c5b35f13
	//TODO: VMAXSD (R11), X9, X2            // c4c1335f13
	//TODO: VMAXSD X2, X9, X2               // c4e1335fd2 or c5b35fd2
	//TODO: VMAXSD X11, X9, X2              // c4c1335fd3
	//TODO: VMAXSD (BX), X9, X11            // c461335f1b or c5335f1b
	//TODO: VMAXSD (R11), X9, X11           // c441335f1b
	//TODO: VMAXSD X2, X9, X11              // c461335fda or c5335fda
	//TODO: VMAXSD X11, X9, X11             // c441335fdb
	//TODO: VMAXSS (BX), X9, X2             // c4e1325f13 or c5b25f13
	//TODO: VMAXSS (R11), X9, X2            // c4c1325f13
	//TODO: VMAXSS X2, X9, X2               // c4e1325fd2 or c5b25fd2
	//TODO: VMAXSS X11, X9, X2              // c4c1325fd3
	//TODO: VMAXSS (BX), X9, X11            // c461325f1b or c5325f1b
	//TODO: VMAXSS (R11), X9, X11           // c441325f1b
	//TODO: VMAXSS X2, X9, X11              // c461325fda or c5325fda
	//TODO: VMAXSS X11, X9, X11             // c441325fdb
	//TODO: VMINPD (BX), X9, X2             // c4e1315d13 or c5b15d13
	//TODO: VMINPD (R11), X9, X2            // c4c1315d13
	//TODO: VMINPD X2, X9, X2               // c4e1315dd2 or c5b15dd2
	//TODO: VMINPD X11, X9, X2              // c4c1315dd3
	//TODO: VMINPD (BX), X9, X11            // c461315d1b or c5315d1b
	//TODO: VMINPD (R11), X9, X11           // c441315d1b
	//TODO: VMINPD X2, X9, X11              // c461315dda or c5315dda
	//TODO: VMINPD X11, X9, X11             // c441315ddb
	//TODO: VMINPD (BX), Y15, Y2            // c4e1055d13 or c5855d13
	//TODO: VMINPD (R11), Y15, Y2           // c4c1055d13
	//TODO: VMINPD Y2, Y15, Y2              // c4e1055dd2 or c5855dd2
	//TODO: VMINPD Y11, Y15, Y2             // c4c1055dd3
	//TODO: VMINPD (BX), Y15, Y11           // c461055d1b or c5055d1b
	//TODO: VMINPD (R11), Y15, Y11          // c441055d1b
	//TODO: VMINPD Y2, Y15, Y11             // c461055dda or c5055dda
	//TODO: VMINPD Y11, Y15, Y11            // c441055ddb
	//TODO: VMINPS (BX), X9, X2             // c4e1305d13 or c5b05d13
	//TODO: VMINPS (R11), X9, X2            // c4c1305d13
	//TODO: VMINPS X2, X9, X2               // c4e1305dd2 or c5b05dd2
	//TODO: VMINPS X11, X9, X2              // c4c1305dd3
	//TODO: VMINPS (BX), X9, X11            // c461305d1b or c5305d1b
	//TODO: VMINPS (R11), X9, X11           // c441305d1b
	//TODO: VMINPS X2, X9, X11              // c461305dda or c5305dda
	//TODO: VMINPS X11, X9, X11             // c441305ddb
	//TODO: VMINPS (BX), Y15, Y2            // c4e1045d13 or c5845d13
	//TODO: VMINPS (R11), Y15, Y2           // c4c1045d13
	//TODO: VMINPS Y2, Y15, Y2              // c4e1045dd2 or c5845dd2
	//TODO: VMINPS Y11, Y15, Y2             // c4c1045dd3
	//TODO: VMINPS (BX), Y15, Y11           // c461045d1b or c5045d1b
	//TODO: VMINPS (R11), Y15, Y11          // c441045d1b
	//TODO: VMINPS Y2, Y15, Y11             // c461045dda or c5045dda
	//TODO: VMINPS Y11, Y15, Y11            // c441045ddb
	//TODO: VMINSD (BX), X9, X2             // c4e1335d13 or c5b35d13
	//TODO: VMINSD (R11), X9, X2            // c4c1335d13
	//TODO: VMINSD X2, X9, X2               // c4e1335dd2 or c5b35dd2
	//TODO: VMINSD X11, X9, X2              // c4c1335dd3
	//TODO: VMINSD (BX), X9, X11            // c461335d1b or c5335d1b
	//TODO: VMINSD (R11), X9, X11           // c441335d1b
	//TODO: VMINSD X2, X9, X11              // c461335dda or c5335dda
	//TODO: VMINSD X11, X9, X11             // c441335ddb
	//TODO: VMINSS (BX), X9, X2             // c4e1325d13 or c5b25d13
	//TODO: VMINSS (R11), X9, X2            // c4c1325d13
	//TODO: VMINSS X2, X9, X2               // c4e1325dd2 or c5b25dd2
	//TODO: VMINSS X11, X9, X2              // c4c1325dd3
	//TODO: VMINSS (BX), X9, X11            // c461325d1b or c5325d1b
	//TODO: VMINSS (R11), X9, X11           // c441325d1b
	//TODO: VMINSS X2, X9, X11              // c461325dda or c5325dda
	//TODO: VMINSS X11, X9, X11             // c441325ddb
	//TODO: VMOVAPD (BX), X2                // c4e1792813 or c5f92813
	//TODO: VMOVAPD (R11), X2               // c4c1792813
	//TODO: VMOVAPD X2, X2                  // c4e17928d2 or c5f928d2 or c4e17929d2 or c5f929d2
	//TODO: VMOVAPD X11, X2                 // c4c17928d3 or c4617929da or c57929da
	//TODO: VMOVAPD (BX), X11               // c46179281b or c579281b
	//TODO: VMOVAPD (R11), X11              // c44179281b
	//TODO: VMOVAPD X2, X11                 // c4617928da or c57928da or c4c17929d3
	//TODO: VMOVAPD X11, X11                // c4417928db or c4417929db
	//TODO: VMOVAPD X2, (BX)                // c4e1792913 or c5f92913
	//TODO: VMOVAPD X11, (BX)               // c46179291b or c579291b
	//TODO: VMOVAPD X2, (R11)               // c4c1792913
	//TODO: VMOVAPD X11, (R11)              // c44179291b
	//TODO: VMOVAPD (BX), Y2                // c4e17d2813 or c5fd2813
	//TODO: VMOVAPD (R11), Y2               // c4c17d2813
	//TODO: VMOVAPD Y2, Y2                  // c4e17d28d2 or c5fd28d2 or c4e17d29d2 or c5fd29d2
	//TODO: VMOVAPD Y11, Y2                 // c4c17d28d3 or c4617d29da or c57d29da
	//TODO: VMOVAPD (BX), Y11               // c4617d281b or c57d281b
	//TODO: VMOVAPD (R11), Y11              // c4417d281b
	//TODO: VMOVAPD Y2, Y11                 // c4617d28da or c57d28da or c4c17d29d3
	//TODO: VMOVAPD Y11, Y11                // c4417d28db or c4417d29db
	//TODO: VMOVAPD Y2, (BX)                // c4e17d2913 or c5fd2913
	//TODO: VMOVAPD Y11, (BX)               // c4617d291b or c57d291b
	//TODO: VMOVAPD Y2, (R11)               // c4c17d2913
	//TODO: VMOVAPD Y11, (R11)              // c4417d291b
	//TODO: VMOVAPS (BX), X2                // c4e1782813 or c5f82813
	//TODO: VMOVAPS (R11), X2               // c4c1782813
	//TODO: VMOVAPS X2, X2                  // c4e17828d2 or c5f828d2 or c4e17829d2 or c5f829d2
	//TODO: VMOVAPS X11, X2                 // c4c17828d3 or c4617829da or c57829da
	//TODO: VMOVAPS (BX), X11               // c46178281b or c578281b
	//TODO: VMOVAPS (R11), X11              // c44178281b
	//TODO: VMOVAPS X2, X11                 // c4617828da or c57828da or c4c17829d3
	//TODO: VMOVAPS X11, X11                // c4417828db or c4417829db
	//TODO: VMOVAPS X2, (BX)                // c4e1782913 or c5f82913
	//TODO: VMOVAPS X11, (BX)               // c46178291b or c578291b
	//TODO: VMOVAPS X2, (R11)               // c4c1782913
	//TODO: VMOVAPS X11, (R11)              // c44178291b
	//TODO: VMOVAPS (BX), Y2                // c4e17c2813 or c5fc2813
	//TODO: VMOVAPS (R11), Y2               // c4c17c2813
	//TODO: VMOVAPS Y2, Y2                  // c4e17c28d2 or c5fc28d2 or c4e17c29d2 or c5fc29d2
	//TODO: VMOVAPS Y11, Y2                 // c4c17c28d3 or c4617c29da or c57c29da
	//TODO: VMOVAPS (BX), Y11               // c4617c281b or c57c281b
	//TODO: VMOVAPS (R11), Y11              // c4417c281b
	//TODO: VMOVAPS Y2, Y11                 // c4617c28da or c57c28da or c4c17c29d3
	//TODO: VMOVAPS Y11, Y11                // c4417c28db or c4417c29db
	//TODO: VMOVAPS Y2, (BX)                // c4e17c2913 or c5fc2913
	//TODO: VMOVAPS Y11, (BX)               // c4617c291b or c57c291b
	//TODO: VMOVAPS Y2, (R11)               // c4c17c2913
	//TODO: VMOVAPS Y11, (R11)              // c4417c291b
	//TODO: VMOVD X2, (BX)                  // c4e1797e13 or c5f97e13
	//TODO: VMOVD X11, (BX)                 // c461797e1b or c5797e1b
	//TODO: VMOVD X2, (R11)                 // c4c1797e13
	//TODO: VMOVD X11, (R11)                // c441797e1b
	//TODO: VMOVD X2, DX                    // c4e1797ed2 or c5f97ed2
	//TODO: VMOVD X11, DX                   // c461797eda or c5797eda
	//TODO: VMOVD X2, R11                   // c4c1797ed3
	//TODO: VMOVD X11, R11                  // c441797edb
	//TODO: VMOVD (BX), X2                  // c4e1796e13 or c5f96e13
	//TODO: VMOVD (R11), X2                 // c4c1796e13
	//TODO: VMOVD DX, X2                    // c4e1796ed2 or c5f96ed2
	//TODO: VMOVD R11, X2                   // c4c1796ed3
	//TODO: VMOVD (BX), X11                 // c461796e1b or c5796e1b
	//TODO: VMOVD (R11), X11                // c441796e1b
	//TODO: VMOVD DX, X11                   // c461796eda or c5796eda
	//TODO: VMOVD R11, X11                  // c441796edb
	//TODO: VMOVDDUP (BX), X2               // c4e17b1213 or c5fb1213
	//TODO: VMOVDDUP (R11), X2              // c4c17b1213
	//TODO: VMOVDDUP X2, X2                 // c4e17b12d2 or c5fb12d2
	//TODO: VMOVDDUP X11, X2                // c4c17b12d3
	//TODO: VMOVDDUP (BX), X11              // c4617b121b or c57b121b
	//TODO: VMOVDDUP (R11), X11             // c4417b121b
	//TODO: VMOVDDUP X2, X11                // c4617b12da or c57b12da
	//TODO: VMOVDDUP X11, X11               // c4417b12db
	//TODO: VMOVDDUP (BX), Y2               // c4e17f1213 or c5ff1213
	//TODO: VMOVDDUP (R11), Y2              // c4c17f1213
	//TODO: VMOVDDUP Y2, Y2                 // c4e17f12d2 or c5ff12d2
	//TODO: VMOVDDUP Y11, Y2                // c4c17f12d3
	//TODO: VMOVDDUP (BX), Y11              // c4617f121b or c57f121b
	//TODO: VMOVDDUP (R11), Y11             // c4417f121b
	//TODO: VMOVDDUP Y2, Y11                // c4617f12da or c57f12da
	//TODO: VMOVDDUP Y11, Y11               // c4417f12db
	VMOVDQA (BX), X2                        // c4e1796f13 or c5f96f13
	VMOVDQA (R11), X2                       // c4c1796f13
	VMOVDQA X2, X2                          // c4e1796fd2 or c5f96fd2 or c4e1797fd2 or c5f97fd2
	VMOVDQA X11, X2                         // c4c1796fd3 or c461797fda or c5797fda
	VMOVDQA (BX), X11                       // c461796f1b or c5796f1b
	VMOVDQA (R11), X11                      // c441796f1b
	VMOVDQA X2, X11                         // c461796fda or c5796fda or c4c1797fd3
	VMOVDQA X11, X11                        // c441796fdb or c441797fdb
	VMOVDQA X2, (BX)                        // c4e1797f13 or c5f97f13
	VMOVDQA X11, (BX)                       // c461797f1b or c5797f1b
	VMOVDQA X2, (R11)                       // c4c1797f13
	VMOVDQA X11, (R11)                      // c441797f1b
	VMOVDQA (BX), Y2                        // c4e17d6f13 or c5fd6f13
	VMOVDQA (R11), Y2                       // c4c17d6f13
	VMOVDQA Y2, Y2                          // c4e17d6fd2 or c5fd6fd2 or c4e17d7fd2 or c5fd7fd2
	VMOVDQA Y11, Y2                         // c4c17d6fd3 or c4617d7fda or c57d7fda
	VMOVDQA (BX), Y11                       // c4617d6f1b or c57d6f1b
	VMOVDQA (R11), Y11                      // c4417d6f1b
	VMOVDQA Y2, Y11                         // c4617d6fda or c57d6fda or c4c17d7fd3
	VMOVDQA Y11, Y11                        // c4417d6fdb or c4417d7fdb
	VMOVDQA Y2, (BX)                        // c4e17d7f13 or c5fd7f13
	VMOVDQA Y11, (BX)                       // c4617d7f1b or c57d7f1b
	VMOVDQA Y2, (R11)                       // c4c17d7f13
	VMOVDQA Y11, (R11)                      // c4417d7f1b
	VMOVDQU (BX), X2                        // c4e17a6f13 or c5fa6f13
	VMOVDQU (R11), X2                       // c4c17a6f13
	VMOVDQU X2, X2                          // c4e17a6fd2 or c5fa6fd2 or c4e17a7fd2 or c5fa7fd2
	VMOVDQU X11, X2                         // c4c17a6fd3 or c4617a7fda or c57a7fda
	VMOVDQU (BX), X11                       // c4617a6f1b or c57a6f1b
	VMOVDQU (R11), X11                      // c4417a6f1b
	VMOVDQU X2, X11                         // c4617a6fda or c57a6fda or c4c17a7fd3
	VMOVDQU X11, X11                        // c4417a6fdb or c4417a7fdb
	VMOVDQU X2, (BX)                        // c4e17a7f13 or c5fa7f13
	VMOVDQU X11, (BX)                       // c4617a7f1b or c57a7f1b
	VMOVDQU X2, (R11)                       // c4c17a7f13
	VMOVDQU X11, (R11)                      // c4417a7f1b
	VMOVDQU (BX), Y2                        // c4e17e6f13 or c5fe6f13
	VMOVDQU (R11), Y2                       // c4c17e6f13
	VMOVDQU Y2, Y2                          // c4e17e6fd2 or c5fe6fd2 or c4e17e7fd2 or c5fe7fd2
	VMOVDQU Y11, Y2                         // c4c17e6fd3 or c4617e7fda or c57e7fda
	VMOVDQU (BX), Y11                       // c4617e6f1b or c57e6f1b
	VMOVDQU (R11), Y11                      // c4417e6f1b
	VMOVDQU Y2, Y11                         // c4617e6fda or c57e6fda or c4c17e7fd3
	VMOVDQU Y11, Y11                        // c4417e6fdb or c4417e7fdb
	VMOVDQU Y2, (BX)                        // c4e17e7f13 or c5fe7f13
	VMOVDQU Y11, (BX)                       // c4617e7f1b or c57e7f1b
	VMOVDQU Y2, (R11)                       // c4c17e7f13
	VMOVDQU Y11, (R11)                      // c4417e7f1b
	//TODO: VMOVHLPS X2, X9, X2             // c4e13012d2 or c5b012d2
	//TODO: VMOVHLPS X11, X9, X2            // c4c13012d3
	//TODO: VMOVHLPS X2, X9, X11            // c4613012da or c53012da
	//TODO: VMOVHLPS X11, X9, X11           // c4413012db
	//TODO: VMOVHPD X2, (BX)                // c4e1791713 or c5f91713
	//TODO: VMOVHPD X11, (BX)               // c46179171b or c579171b
	//TODO: VMOVHPD X2, (R11)               // c4c1791713
	//TODO: VMOVHPD X11, (R11)              // c44179171b
	//TODO: VMOVHPD (BX), X9, X2            // c4e1311613 or c5b11613
	//TODO: VMOVHPD (R11), X9, X2           // c4c1311613
	//TODO: VMOVHPD (BX), X9, X11           // c46131161b or c531161b
	//TODO: VMOVHPD (R11), X9, X11          // c44131161b
	//TODO: VMOVHPS X2, (BX)                // c4e1781713 or c5f81713
	//TODO: VMOVHPS X11, (BX)               // c46178171b or c578171b
	//TODO: VMOVHPS X2, (R11)               // c4c1781713
	//TODO: VMOVHPS X11, (R11)              // c44178171b
	//TODO: VMOVHPS (BX), X9, X2            // c4e1301613 or c5b01613
	//TODO: VMOVHPS (R11), X9, X2           // c4c1301613
	//TODO: VMOVHPS (BX), X9, X11           // c46130161b or c530161b
	//TODO: VMOVHPS (R11), X9, X11          // c44130161b
	//TODO: VMOVLHPS X2, X9, X2             // c4e13016d2 or c5b016d2
	//TODO: VMOVLHPS X11, X9, X2            // c4c13016d3
	//TODO: VMOVLHPS X2, X9, X11            // c4613016da or c53016da
	//TODO: VMOVLHPS X11, X9, X11           // c4413016db
	//TODO: VMOVLPD X2, (BX)                // c4e1791313 or c5f91313
	//TODO: VMOVLPD X11, (BX)               // c46179131b or c579131b
	//TODO: VMOVLPD X2, (R11)               // c4c1791313
	//TODO: VMOVLPD X11, (R11)              // c44179131b
	//TODO: VMOVLPD (BX), X9, X2            // c4e1311213 or c5b11213
	//TODO: VMOVLPD (R11), X9, X2           // c4c1311213
	//TODO: VMOVLPD (BX), X9, X11           // c46131121b or c531121b
	//TODO: VMOVLPD (R11), X9, X11          // c44131121b
	//TODO: VMOVLPS X2, (BX)                // c4e1781313 or c5f81313
	//TODO: VMOVLPS X11, (BX)               // c46178131b or c578131b
	//TODO: VMOVLPS X2, (R11)               // c4c1781313
	//TODO: VMOVLPS X11, (R11)              // c44178131b
	//TODO: VMOVLPS (BX), X9, X2            // c4e1301213 or c5b01213
	//TODO: VMOVLPS (R11), X9, X2           // c4c1301213
	//TODO: VMOVLPS (BX), X9, X11           // c46130121b or c530121b
	//TODO: VMOVLPS (R11), X9, X11          // c44130121b
	//TODO: VMOVMSKPD X2, DX                // c4e17950d2 or c5f950d2
	//TODO: VMOVMSKPD X11, DX               // c4c17950d3
	//TODO: VMOVMSKPD X2, R11               // c4617950da or c57950da
	//TODO: VMOVMSKPD X11, R11              // c4417950db
	//TODO: VMOVMSKPD Y2, DX                // c4e17d50d2 or c5fd50d2
	//TODO: VMOVMSKPD Y11, DX               // c4c17d50d3
	//TODO: VMOVMSKPD Y2, R11               // c4617d50da or c57d50da
	//TODO: VMOVMSKPD Y11, R11              // c4417d50db
	//TODO: VMOVMSKPS X2, DX                // c4e17850d2 or c5f850d2
	//TODO: VMOVMSKPS X11, DX               // c4c17850d3
	//TODO: VMOVMSKPS X2, R11               // c4617850da or c57850da
	//TODO: VMOVMSKPS X11, R11              // c4417850db
	//TODO: VMOVMSKPS Y2, DX                // c4e17c50d2 or c5fc50d2
	//TODO: VMOVMSKPS Y11, DX               // c4c17c50d3
	//TODO: VMOVMSKPS Y2, R11               // c4617c50da or c57c50da
	//TODO: VMOVMSKPS Y11, R11              // c4417c50db
	VMOVNTDQ X2, (BX)                       // c4e179e713 or c5f9e713
	VMOVNTDQ X11, (BX)                      // c46179e71b or c579e71b
	VMOVNTDQ X2, (R11)                      // c4c179e713
	VMOVNTDQ X11, (R11)                     // c44179e71b
	VMOVNTDQ Y2, (BX)                       // c4e17de713 or c5fde713
	VMOVNTDQ Y11, (BX)                      // c4617de71b or c57de71b
	VMOVNTDQ Y2, (R11)                      // c4c17de713
	VMOVNTDQ Y11, (R11)                     // c4417de71b
	//TODO: VMOVNTDQA (BX), X2              // c4e2792a13
	//TODO: VMOVNTDQA (R11), X2             // c4c2792a13
	//TODO: VMOVNTDQA (BX), X11             // c462792a1b
	//TODO: VMOVNTDQA (R11), X11            // c442792a1b
	//TODO: VMOVNTDQA (BX), Y2              // c4e27d2a13
	//TODO: VMOVNTDQA (R11), Y2             // c4c27d2a13
	//TODO: VMOVNTDQA (BX), Y11             // c4627d2a1b
	//TODO: VMOVNTDQA (R11), Y11            // c4427d2a1b
	//TODO: VMOVNTPD X2, (BX)               // c4e1792b13 or c5f92b13
	//TODO: VMOVNTPD X11, (BX)              // c461792b1b or c5792b1b
	//TODO: VMOVNTPD X2, (R11)              // c4c1792b13
	//TODO: VMOVNTPD X11, (R11)             // c441792b1b
	//TODO: VMOVNTPD Y2, (BX)               // c4e17d2b13 or c5fd2b13
	//TODO: VMOVNTPD Y11, (BX)              // c4617d2b1b or c57d2b1b
	//TODO: VMOVNTPD Y2, (R11)              // c4c17d2b13
	//TODO: VMOVNTPD Y11, (R11)             // c4417d2b1b
	//TODO: VMOVNTPS X2, (BX)               // c4e1782b13 or c5f82b13
	//TODO: VMOVNTPS X11, (BX)              // c461782b1b or c5782b1b
	//TODO: VMOVNTPS X2, (R11)              // c4c1782b13
	//TODO: VMOVNTPS X11, (R11)             // c441782b1b
	//TODO: VMOVNTPS Y2, (BX)               // c4e17c2b13 or c5fc2b13
	//TODO: VMOVNTPS Y11, (BX)              // c4617c2b1b or c57c2b1b
	//TODO: VMOVNTPS Y2, (R11)              // c4c17c2b13
	//TODO: VMOVNTPS Y11, (R11)             // c4417c2b1b
	//TODO: VMOVQ X2, (BX)                  // c4e1f97e13 or c4e179d613 or c5f9d613
	//TODO: VMOVQ X11, (BX)                 // c461f97e1b or c46179d61b or c579d61b
	//TODO: VMOVQ X2, (R11)                 // c4c1f97e13 or c4c179d613
	//TODO: VMOVQ X11, (R11)                // c441f97e1b or c44179d61b
	//TODO: VMOVQ X2, DX                    // c4e1f97ed2
	//TODO: VMOVQ X11, DX                   // c461f97eda
	//TODO: VMOVQ X2, R11                   // c4c1f97ed3
	//TODO: VMOVQ X11, R11                  // c441f97edb
	//TODO: VMOVQ (BX), X2                  // c4e17a7e13 or c5fa7e13 or c4e1f96e13
	//TODO: VMOVQ (R11), X2                 // c4c17a7e13 or c4c1f96e13
	//TODO: VMOVQ (BX), X11                 // c4617a7e1b or c57a7e1b or c461f96e1b
	//TODO: VMOVQ (R11), X11                // c4417a7e1b or c441f96e1b
	//TODO: VMOVQ DX, X2                    // c4e1f96ed2
	//TODO: VMOVQ R11, X2                   // c4c1f96ed3
	//TODO: VMOVQ DX, X11                   // c461f96eda
	//TODO: VMOVQ R11, X11                  // c441f96edb
	//TODO: VMOVQ X2, X2                    // c4e17a7ed2 or c5fa7ed2 or c4e179d6d2 or c5f9d6d2
	//TODO: VMOVQ X11, X2                   // c4c17a7ed3 or c46179d6da or c579d6da
	//TODO: VMOVQ X2, X11                   // c4617a7eda or c57a7eda or c4c179d6d3
	//TODO: VMOVQ X11, X11                  // c4417a7edb or c44179d6db
	//TODO: VMOVSD X2, (BX)                 // c4e17b1113 or c5fb1113
	//TODO: VMOVSD X11, (BX)                // c4617b111b or c57b111b
	//TODO: VMOVSD X2, (R11)                // c4c17b1113
	//TODO: VMOVSD X11, (R11)               // c4417b111b
	//TODO: VMOVSD (BX), X2                 // c4e17b1013 or c5fb1013
	//TODO: VMOVSD (R11), X2                // c4c17b1013
	//TODO: VMOVSD (BX), X11                // c4617b101b or c57b101b
	//TODO: VMOVSD (R11), X11               // c4417b101b
	//TODO: VMOVSD X2, X9, X2               // c4e13310d2 or c5b310d2 or c4e13311d2 or c5b311d2
	//TODO: VMOVSD X11, X9, X2              // c4c13310d3 or c4613311da or c53311da
	//TODO: VMOVSD X2, X9, X11              // c4613310da or c53310da or c4c13311d3
	//TODO: VMOVSD X11, X9, X11             // c4413310db or c4413311db
	//TODO: VMOVSHDUP (BX), X2              // c4e17a1613 or c5fa1613
	//TODO: VMOVSHDUP (R11), X2             // c4c17a1613
	//TODO: VMOVSHDUP X2, X2                // c4e17a16d2 or c5fa16d2
	//TODO: VMOVSHDUP X11, X2               // c4c17a16d3
	//TODO: VMOVSHDUP (BX), X11             // c4617a161b or c57a161b
	//TODO: VMOVSHDUP (R11), X11            // c4417a161b
	//TODO: VMOVSHDUP X2, X11               // c4617a16da or c57a16da
	//TODO: VMOVSHDUP X11, X11              // c4417a16db
	//TODO: VMOVSHDUP (BX), Y2              // c4e17e1613 or c5fe1613
	//TODO: VMOVSHDUP (R11), Y2             // c4c17e1613
	//TODO: VMOVSHDUP Y2, Y2                // c4e17e16d2 or c5fe16d2
	//TODO: VMOVSHDUP Y11, Y2               // c4c17e16d3
	//TODO: VMOVSHDUP (BX), Y11             // c4617e161b or c57e161b
	//TODO: VMOVSHDUP (R11), Y11            // c4417e161b
	//TODO: VMOVSHDUP Y2, Y11               // c4617e16da or c57e16da
	//TODO: VMOVSHDUP Y11, Y11              // c4417e16db
	//TODO: VMOVSLDUP (BX), X2              // c4e17a1213 or c5fa1213
	//TODO: VMOVSLDUP (R11), X2             // c4c17a1213
	//TODO: VMOVSLDUP X2, X2                // c4e17a12d2 or c5fa12d2
	//TODO: VMOVSLDUP X11, X2               // c4c17a12d3
	//TODO: VMOVSLDUP (BX), X11             // c4617a121b or c57a121b
	//TODO: VMOVSLDUP (R11), X11            // c4417a121b
	//TODO: VMOVSLDUP X2, X11               // c4617a12da or c57a12da
	//TODO: VMOVSLDUP X11, X11              // c4417a12db
	//TODO: VMOVSLDUP (BX), Y2              // c4e17e1213 or c5fe1213
	//TODO: VMOVSLDUP (R11), Y2             // c4c17e1213
	//TODO: VMOVSLDUP Y2, Y2                // c4e17e12d2 or c5fe12d2
	//TODO: VMOVSLDUP Y11, Y2               // c4c17e12d3
	//TODO: VMOVSLDUP (BX), Y11             // c4617e121b or c57e121b
	//TODO: VMOVSLDUP (R11), Y11            // c4417e121b
	//TODO: VMOVSLDUP Y2, Y11               // c4617e12da or c57e12da
	//TODO: VMOVSLDUP Y11, Y11              // c4417e12db
	//TODO: VMOVSS X2, (BX)                 // c4e17a1113 or c5fa1113
	//TODO: VMOVSS X11, (BX)                // c4617a111b or c57a111b
	//TODO: VMOVSS X2, (R11)                // c4c17a1113
	//TODO: VMOVSS X11, (R11)               // c4417a111b
	//TODO: VMOVSS (BX), X2                 // c4e17a1013 or c5fa1013
	//TODO: VMOVSS (R11), X2                // c4c17a1013
	//TODO: VMOVSS (BX), X11                // c4617a101b or c57a101b
	//TODO: VMOVSS (R11), X11               // c4417a101b
	//TODO: VMOVSS X2, X9, X2               // c4e13210d2 or c5b210d2 or c4e13211d2 or c5b211d2
	//TODO: VMOVSS X11, X9, X2              // c4c13210d3 or c4613211da or c53211da
	//TODO: VMOVSS X2, X9, X11              // c4613210da or c53210da or c4c13211d3
	//TODO: VMOVSS X11, X9, X11             // c4413210db or c4413211db
	//TODO: VMOVUPD (BX), X2                // c4e1791013 or c5f91013
	//TODO: VMOVUPD (R11), X2               // c4c1791013
	//TODO: VMOVUPD X2, X2                  // c4e17910d2 or c5f910d2 or c4e17911d2 or c5f911d2
	//TODO: VMOVUPD X11, X2                 // c4c17910d3 or c4617911da or c57911da
	//TODO: VMOVUPD (BX), X11               // c46179101b or c579101b
	//TODO: VMOVUPD (R11), X11              // c44179101b
	//TODO: VMOVUPD X2, X11                 // c4617910da or c57910da or c4c17911d3
	//TODO: VMOVUPD X11, X11                // c4417910db or c4417911db
	//TODO: VMOVUPD X2, (BX)                // c4e1791113 or c5f91113
	//TODO: VMOVUPD X11, (BX)               // c46179111b or c579111b
	//TODO: VMOVUPD X2, (R11)               // c4c1791113
	//TODO: VMOVUPD X11, (R11)              // c44179111b
	//TODO: VMOVUPD (BX), Y2                // c4e17d1013 or c5fd1013
	//TODO: VMOVUPD (R11), Y2               // c4c17d1013
	//TODO: VMOVUPD Y2, Y2                  // c4e17d10d2 or c5fd10d2 or c4e17d11d2 or c5fd11d2
	//TODO: VMOVUPD Y11, Y2                 // c4c17d10d3 or c4617d11da or c57d11da
	//TODO: VMOVUPD (BX), Y11               // c4617d101b or c57d101b
	//TODO: VMOVUPD (R11), Y11              // c4417d101b
	//TODO: VMOVUPD Y2, Y11                 // c4617d10da or c57d10da or c4c17d11d3
	//TODO: VMOVUPD Y11, Y11                // c4417d10db or c4417d11db
	//TODO: VMOVUPD Y2, (BX)                // c4e17d1113 or c5fd1113
	//TODO: VMOVUPD Y11, (BX)               // c4617d111b or c57d111b
	//TODO: VMOVUPD Y2, (R11)               // c4c17d1113
	//TODO: VMOVUPD Y11, (R11)              // c4417d111b
	//TODO: VMOVUPS (BX), X2                // c4e1781013 or c5f81013
	//TODO: VMOVUPS (R11), X2               // c4c1781013
	//TODO: VMOVUPS X2, X2                  // c4e17810d2 or c5f810d2 or c4e17811d2 or c5f811d2
	//TODO: VMOVUPS X11, X2                 // c4c17810d3 or c4617811da or c57811da
	//TODO: VMOVUPS (BX), X11               // c46178101b or c578101b
	//TODO: VMOVUPS (R11), X11              // c44178101b
	//TODO: VMOVUPS X2, X11                 // c4617810da or c57810da or c4c17811d3
	//TODO: VMOVUPS X11, X11                // c4417810db or c4417811db
	//TODO: VMOVUPS X2, (BX)                // c4e1781113 or c5f81113
	//TODO: VMOVUPS X11, (BX)               // c46178111b or c578111b
	//TODO: VMOVUPS X2, (R11)               // c4c1781113
	//TODO: VMOVUPS X11, (R11)              // c44178111b
	//TODO: VMOVUPS (BX), Y2                // c4e17c1013 or c5fc1013
	//TODO: VMOVUPS (R11), Y2               // c4c17c1013
	//TODO: VMOVUPS Y2, Y2                  // c4e17c10d2 or c5fc10d2 or c4e17c11d2 or c5fc11d2
	//TODO: VMOVUPS Y11, Y2                 // c4c17c10d3 or c4617c11da or c57c11da
	//TODO: VMOVUPS (BX), Y11               // c4617c101b or c57c101b
	//TODO: VMOVUPS (R11), Y11              // c4417c101b
	//TODO: VMOVUPS Y2, Y11                 // c4617c10da or c57c10da or c4c17c11d3
	//TODO: VMOVUPS Y11, Y11                // c4417c10db or c4417c11db
	//TODO: VMOVUPS Y2, (BX)                // c4e17c1113 or c5fc1113
	//TODO: VMOVUPS Y11, (BX)               // c4617c111b or c57c111b
	//TODO: VMOVUPS Y2, (R11)               // c4c17c1113
	//TODO: VMOVUPS Y11, (R11)              // c4417c111b
	//TODO: VMPSADBW $7, (BX), X9, X2       // c4e331421307
	//TODO: VMPSADBW $7, (R11), X9, X2      // c4c331421307
	//TODO: VMPSADBW $7, X2, X9, X2         // c4e33142d207
	//TODO: VMPSADBW $7, X11, X9, X2        // c4c33142d307
	//TODO: VMPSADBW $7, (BX), X9, X11      // c46331421b07
	//TODO: VMPSADBW $7, (R11), X9, X11     // c44331421b07
	//TODO: VMPSADBW $7, X2, X9, X11        // c4633142da07
	//TODO: VMPSADBW $7, X11, X9, X11       // c4433142db07
	//TODO: VMPSADBW $7, (BX), Y15, Y2      // c4e305421307
	//TODO: VMPSADBW $7, (R11), Y15, Y2     // c4c305421307
	//TODO: VMPSADBW $7, Y2, Y15, Y2        // c4e30542d207
	//TODO: VMPSADBW $7, Y11, Y15, Y2       // c4c30542d307
	//TODO: VMPSADBW $7, (BX), Y15, Y11     // c46305421b07
	//TODO: VMPSADBW $7, (R11), Y15, Y11    // c44305421b07
	//TODO: VMPSADBW $7, Y2, Y15, Y11       // c4630542da07
	//TODO: VMPSADBW $7, Y11, Y15, Y11      // c4430542db07
	//TODO: VMULPD (BX), X9, X2             // c4e1315913 or c5b15913
	//TODO: VMULPD (R11), X9, X2            // c4c1315913
	//TODO: VMULPD X2, X9, X2               // c4e13159d2 or c5b159d2
	//TODO: VMULPD X11, X9, X2              // c4c13159d3
	//TODO: VMULPD (BX), X9, X11            // c46131591b or c531591b
	//TODO: VMULPD (R11), X9, X11           // c44131591b
	//TODO: VMULPD X2, X9, X11              // c4613159da or c53159da
	//TODO: VMULPD X11, X9, X11             // c4413159db
	//TODO: VMULPD (BX), Y15, Y2            // c4e1055913 or c5855913
	//TODO: VMULPD (R11), Y15, Y2           // c4c1055913
	//TODO: VMULPD Y2, Y15, Y2              // c4e10559d2 or c58559d2
	//TODO: VMULPD Y11, Y15, Y2             // c4c10559d3
	//TODO: VMULPD (BX), Y15, Y11           // c46105591b or c505591b
	//TODO: VMULPD (R11), Y15, Y11          // c44105591b
	//TODO: VMULPD Y2, Y15, Y11             // c4610559da or c50559da
	//TODO: VMULPD Y11, Y15, Y11            // c4410559db
	//TODO: VMULPS (BX), X9, X2             // c4e1305913 or c5b05913
	//TODO: VMULPS (R11), X9, X2            // c4c1305913
	//TODO: VMULPS X2, X9, X2               // c4e13059d2 or c5b059d2
	//TODO: VMULPS X11, X9, X2              // c4c13059d3
	//TODO: VMULPS (BX), X9, X11            // c46130591b or c530591b
	//TODO: VMULPS (R11), X9, X11           // c44130591b
	//TODO: VMULPS X2, X9, X11              // c4613059da or c53059da
	//TODO: VMULPS X11, X9, X11             // c4413059db
	//TODO: VMULPS (BX), Y15, Y2            // c4e1045913 or c5845913
	//TODO: VMULPS (R11), Y15, Y2           // c4c1045913
	//TODO: VMULPS Y2, Y15, Y2              // c4e10459d2 or c58459d2
	//TODO: VMULPS Y11, Y15, Y2             // c4c10459d3
	//TODO: VMULPS (BX), Y15, Y11           // c46104591b or c504591b
	//TODO: VMULPS (R11), Y15, Y11          // c44104591b
	//TODO: VMULPS Y2, Y15, Y11             // c4610459da or c50459da
	//TODO: VMULPS Y11, Y15, Y11            // c4410459db
	//TODO: VMULSD (BX), X9, X2             // c4e1335913 or c5b35913
	//TODO: VMULSD (R11), X9, X2            // c4c1335913
	//TODO: VMULSD X2, X9, X2               // c4e13359d2 or c5b359d2
	//TODO: VMULSD X11, X9, X2              // c4c13359d3
	//TODO: VMULSD (BX), X9, X11            // c46133591b or c533591b
	//TODO: VMULSD (R11), X9, X11           // c44133591b
	//TODO: VMULSD X2, X9, X11              // c4613359da or c53359da
	//TODO: VMULSD X11, X9, X11             // c4413359db
	//TODO: VMULSS (BX), X9, X2             // c4e1325913 or c5b25913
	//TODO: VMULSS (R11), X9, X2            // c4c1325913
	//TODO: VMULSS X2, X9, X2               // c4e13259d2 or c5b259d2
	//TODO: VMULSS X11, X9, X2              // c4c13259d3
	//TODO: VMULSS (BX), X9, X11            // c46132591b or c532591b
	//TODO: VMULSS (R11), X9, X11           // c44132591b
	//TODO: VMULSS X2, X9, X11              // c4613259da or c53259da
	//TODO: VMULSS X11, X9, X11             // c4413259db
	//TODO: VORPD (BX), X9, X2              // c4e1315613 or c5b15613
	//TODO: VORPD (R11), X9, X2             // c4c1315613
	//TODO: VORPD X2, X9, X2                // c4e13156d2 or c5b156d2
	//TODO: VORPD X11, X9, X2               // c4c13156d3
	//TODO: VORPD (BX), X9, X11             // c46131561b or c531561b
	//TODO: VORPD (R11), X9, X11            // c44131561b
	//TODO: VORPD X2, X9, X11               // c4613156da or c53156da
	//TODO: VORPD X11, X9, X11              // c4413156db
	//TODO: VORPD (BX), Y15, Y2             // c4e1055613 or c5855613
	//TODO: VORPD (R11), Y15, Y2            // c4c1055613
	//TODO: VORPD Y2, Y15, Y2               // c4e10556d2 or c58556d2
	//TODO: VORPD Y11, Y15, Y2              // c4c10556d3
	//TODO: VORPD (BX), Y15, Y11            // c46105561b or c505561b
	//TODO: VORPD (R11), Y15, Y11           // c44105561b
	//TODO: VORPD Y2, Y15, Y11              // c4610556da or c50556da
	//TODO: VORPD Y11, Y15, Y11             // c4410556db
	//TODO: VORPS (BX), X9, X2              // c4e1305613 or c5b05613
	//TODO: VORPS (R11), X9, X2             // c4c1305613
	//TODO: VORPS X2, X9, X2                // c4e13056d2 or c5b056d2
	//TODO: VORPS X11, X9, X2               // c4c13056d3
	//TODO: VORPS (BX), X9, X11             // c46130561b or c530561b
	//TODO: VORPS (R11), X9, X11            // c44130561b
	//TODO: VORPS X2, X9, X11               // c4613056da or c53056da
	//TODO: VORPS X11, X9, X11              // c4413056db
	//TODO: VORPS (BX), Y15, Y2             // c4e1045613 or c5845613
	//TODO: VORPS (R11), Y15, Y2            // c4c1045613
	//TODO: VORPS Y2, Y15, Y2               // c4e10456d2 or c58456d2
	//TODO: VORPS Y11, Y15, Y2              // c4c10456d3
	//TODO: VORPS (BX), Y15, Y11            // c46104561b or c504561b
	//TODO: VORPS (R11), Y15, Y11           // c44104561b
	//TODO: VORPS Y2, Y15, Y11              // c4610456da or c50456da
	//TODO: VORPS Y11, Y15, Y11             // c4410456db
	//TODO: VPABSB (BX), X2                 // c4e2791c13
	//TODO: VPABSB (R11), X2                // c4c2791c13
	//TODO: VPABSB X2, X2                   // c4e2791cd2
	//TODO: VPABSB X11, X2                  // c4c2791cd3
	//TODO: VPABSB (BX), X11                // c462791c1b
	//TODO: VPABSB (R11), X11               // c442791c1b
	//TODO: VPABSB X2, X11                  // c462791cda
	//TODO: VPABSB X11, X11                 // c442791cdb
	//TODO: VPABSB (BX), Y2                 // c4e27d1c13
	//TODO: VPABSB (R11), Y2                // c4c27d1c13
	//TODO: VPABSB Y2, Y2                   // c4e27d1cd2
	//TODO: VPABSB Y11, Y2                  // c4c27d1cd3
	//TODO: VPABSB (BX), Y11                // c4627d1c1b
	//TODO: VPABSB (R11), Y11               // c4427d1c1b
	//TODO: VPABSB Y2, Y11                  // c4627d1cda
	//TODO: VPABSB Y11, Y11                 // c4427d1cdb
	//TODO: VPABSD (BX), X2                 // c4e2791e13
	//TODO: VPABSD (R11), X2                // c4c2791e13
	//TODO: VPABSD X2, X2                   // c4e2791ed2
	//TODO: VPABSD X11, X2                  // c4c2791ed3
	//TODO: VPABSD (BX), X11                // c462791e1b
	//TODO: VPABSD (R11), X11               // c442791e1b
	//TODO: VPABSD X2, X11                  // c462791eda
	//TODO: VPABSD X11, X11                 // c442791edb
	//TODO: VPABSD (BX), Y2                 // c4e27d1e13
	//TODO: VPABSD (R11), Y2                // c4c27d1e13
	//TODO: VPABSD Y2, Y2                   // c4e27d1ed2
	//TODO: VPABSD Y11, Y2                  // c4c27d1ed3
	//TODO: VPABSD (BX), Y11                // c4627d1e1b
	//TODO: VPABSD (R11), Y11               // c4427d1e1b
	//TODO: VPABSD Y2, Y11                  // c4627d1eda
	//TODO: VPABSD Y11, Y11                 // c4427d1edb
	//TODO: VPABSW (BX), X2                 // c4e2791d13
	//TODO: VPABSW (R11), X2                // c4c2791d13
	//TODO: VPABSW X2, X2                   // c4e2791dd2
	//TODO: VPABSW X11, X2                  // c4c2791dd3
	//TODO: VPABSW (BX), X11                // c462791d1b
	//TODO: VPABSW (R11), X11               // c442791d1b
	//TODO: VPABSW X2, X11                  // c462791dda
	//TODO: VPABSW X11, X11                 // c442791ddb
	//TODO: VPABSW (BX), Y2                 // c4e27d1d13
	//TODO: VPABSW (R11), Y2                // c4c27d1d13
	//TODO: VPABSW Y2, Y2                   // c4e27d1dd2
	//TODO: VPABSW Y11, Y2                  // c4c27d1dd3
	//TODO: VPABSW (BX), Y11                // c4627d1d1b
	//TODO: VPABSW (R11), Y11               // c4427d1d1b
	//TODO: VPABSW Y2, Y11                  // c4627d1dda
	//TODO: VPABSW Y11, Y11                 // c4427d1ddb
	//TODO: VPACKSSDW (BX), X9, X2          // c4e1316b13 or c5b16b13
	//TODO: VPACKSSDW (R11), X9, X2         // c4c1316b13
	//TODO: VPACKSSDW X2, X9, X2            // c4e1316bd2 or c5b16bd2
	//TODO: VPACKSSDW X11, X9, X2           // c4c1316bd3
	//TODO: VPACKSSDW (BX), X9, X11         // c461316b1b or c5316b1b
	//TODO: VPACKSSDW (R11), X9, X11        // c441316b1b
	//TODO: VPACKSSDW X2, X9, X11           // c461316bda or c5316bda
	//TODO: VPACKSSDW X11, X9, X11          // c441316bdb
	//TODO: VPACKSSDW (BX), Y15, Y2         // c4e1056b13 or c5856b13
	//TODO: VPACKSSDW (R11), Y15, Y2        // c4c1056b13
	//TODO: VPACKSSDW Y2, Y15, Y2           // c4e1056bd2 or c5856bd2
	//TODO: VPACKSSDW Y11, Y15, Y2          // c4c1056bd3
	//TODO: VPACKSSDW (BX), Y15, Y11        // c461056b1b or c5056b1b
	//TODO: VPACKSSDW (R11), Y15, Y11       // c441056b1b
	//TODO: VPACKSSDW Y2, Y15, Y11          // c461056bda or c5056bda
	//TODO: VPACKSSDW Y11, Y15, Y11         // c441056bdb
	//TODO: VPACKSSWB (BX), X9, X2          // c4e1316313 or c5b16313
	//TODO: VPACKSSWB (R11), X9, X2         // c4c1316313
	//TODO: VPACKSSWB X2, X9, X2            // c4e13163d2 or c5b163d2
	//TODO: VPACKSSWB X11, X9, X2           // c4c13163d3
	//TODO: VPACKSSWB (BX), X9, X11         // c46131631b or c531631b
	//TODO: VPACKSSWB (R11), X9, X11        // c44131631b
	//TODO: VPACKSSWB X2, X9, X11           // c4613163da or c53163da
	//TODO: VPACKSSWB X11, X9, X11          // c4413163db
	//TODO: VPACKSSWB (BX), Y15, Y2         // c4e1056313 or c5856313
	//TODO: VPACKSSWB (R11), Y15, Y2        // c4c1056313
	//TODO: VPACKSSWB Y2, Y15, Y2           // c4e10563d2 or c58563d2
	//TODO: VPACKSSWB Y11, Y15, Y2          // c4c10563d3
	//TODO: VPACKSSWB (BX), Y15, Y11        // c46105631b or c505631b
	//TODO: VPACKSSWB (R11), Y15, Y11       // c44105631b
	//TODO: VPACKSSWB Y2, Y15, Y11          // c4610563da or c50563da
	//TODO: VPACKSSWB Y11, Y15, Y11         // c4410563db
	//TODO: VPACKUSDW (BX), X9, X2          // c4e2312b13
	//TODO: VPACKUSDW (R11), X9, X2         // c4c2312b13
	//TODO: VPACKUSDW X2, X9, X2            // c4e2312bd2
	//TODO: VPACKUSDW X11, X9, X2           // c4c2312bd3
	//TODO: VPACKUSDW (BX), X9, X11         // c462312b1b
	//TODO: VPACKUSDW (R11), X9, X11        // c442312b1b
	//TODO: VPACKUSDW X2, X9, X11           // c462312bda
	//TODO: VPACKUSDW X11, X9, X11          // c442312bdb
	//TODO: VPACKUSDW (BX), Y15, Y2         // c4e2052b13
	//TODO: VPACKUSDW (R11), Y15, Y2        // c4c2052b13
	//TODO: VPACKUSDW Y2, Y15, Y2           // c4e2052bd2
	//TODO: VPACKUSDW Y11, Y15, Y2          // c4c2052bd3
	//TODO: VPACKUSDW (BX), Y15, Y11        // c462052b1b
	//TODO: VPACKUSDW (R11), Y15, Y11       // c442052b1b
	//TODO: VPACKUSDW Y2, Y15, Y11          // c462052bda
	//TODO: VPACKUSDW Y11, Y15, Y11         // c442052bdb
	//TODO: VPACKUSWB (BX), X9, X2          // c4e1316713 or c5b16713
	//TODO: VPACKUSWB (R11), X9, X2         // c4c1316713
	//TODO: VPACKUSWB X2, X9, X2            // c4e13167d2 or c5b167d2
	//TODO: VPACKUSWB X11, X9, X2           // c4c13167d3
	//TODO: VPACKUSWB (BX), X9, X11         // c46131671b or c531671b
	//TODO: VPACKUSWB (R11), X9, X11        // c44131671b
	//TODO: VPACKUSWB X2, X9, X11           // c4613167da or c53167da
	//TODO: VPACKUSWB X11, X9, X11          // c4413167db
	//TODO: VPACKUSWB (BX), Y15, Y2         // c4e1056713 or c5856713
	//TODO: VPACKUSWB (R11), Y15, Y2        // c4c1056713
	//TODO: VPACKUSWB Y2, Y15, Y2           // c4e10567d2 or c58567d2
	//TODO: VPACKUSWB Y11, Y15, Y2          // c4c10567d3
	//TODO: VPACKUSWB (BX), Y15, Y11        // c46105671b or c505671b
	//TODO: VPACKUSWB (R11), Y15, Y11       // c44105671b
	//TODO: VPACKUSWB Y2, Y15, Y11          // c4610567da or c50567da
	//TODO: VPACKUSWB Y11, Y15, Y11         // c4410567db
	//TODO: VPADDB (BX), X9, X2             // c4e131fc13 or c5b1fc13
	//TODO: VPADDB (R11), X9, X2            // c4c131fc13
	//TODO: VPADDB X2, X9, X2               // c4e131fcd2 or c5b1fcd2
	//TODO: VPADDB X11, X9, X2              // c4c131fcd3
	//TODO: VPADDB (BX), X9, X11            // c46131fc1b or c531fc1b
	//TODO: VPADDB (R11), X9, X11           // c44131fc1b
	//TODO: VPADDB X2, X9, X11              // c46131fcda or c531fcda
	//TODO: VPADDB X11, X9, X11             // c44131fcdb
	//TODO: VPADDB (BX), Y15, Y2            // c4e105fc13 or c585fc13
	//TODO: VPADDB (R11), Y15, Y2           // c4c105fc13
	//TODO: VPADDB Y2, Y15, Y2              // c4e105fcd2 or c585fcd2
	//TODO: VPADDB Y11, Y15, Y2             // c4c105fcd3
	//TODO: VPADDB (BX), Y15, Y11           // c46105fc1b or c505fc1b
	//TODO: VPADDB (R11), Y15, Y11          // c44105fc1b
	//TODO: VPADDB Y2, Y15, Y11             // c46105fcda or c505fcda
	//TODO: VPADDB Y11, Y15, Y11            // c44105fcdb
	//TODO: VPADDD (BX), X9, X2             // c4e131fe13 or c5b1fe13
	//TODO: VPADDD (R11), X9, X2            // c4c131fe13
	//TODO: VPADDD X2, X9, X2               // c4e131fed2 or c5b1fed2
	//TODO: VPADDD X11, X9, X2              // c4c131fed3
	//TODO: VPADDD (BX), X9, X11            // c46131fe1b or c531fe1b
	//TODO: VPADDD (R11), X9, X11           // c44131fe1b
	//TODO: VPADDD X2, X9, X11              // c46131feda or c531feda
	//TODO: VPADDD X11, X9, X11             // c44131fedb
	//TODO: VPADDD (BX), Y15, Y2            // c4e105fe13 or c585fe13
	//TODO: VPADDD (R11), Y15, Y2           // c4c105fe13
	//TODO: VPADDD Y2, Y15, Y2              // c4e105fed2 or c585fed2
	//TODO: VPADDD Y11, Y15, Y2             // c4c105fed3
	//TODO: VPADDD (BX), Y15, Y11           // c46105fe1b or c505fe1b
	//TODO: VPADDD (R11), Y15, Y11          // c44105fe1b
	//TODO: VPADDD Y2, Y15, Y11             // c46105feda or c505feda
	//TODO: VPADDD Y11, Y15, Y11            // c44105fedb
	//TODO: VPADDQ (BX), X9, X2             // c4e131d413 or c5b1d413
	//TODO: VPADDQ (R11), X9, X2            // c4c131d413
	//TODO: VPADDQ X2, X9, X2               // c4e131d4d2 or c5b1d4d2
	//TODO: VPADDQ X11, X9, X2              // c4c131d4d3
	//TODO: VPADDQ (BX), X9, X11            // c46131d41b or c531d41b
	//TODO: VPADDQ (R11), X9, X11           // c44131d41b
	//TODO: VPADDQ X2, X9, X11              // c46131d4da or c531d4da
	//TODO: VPADDQ X11, X9, X11             // c44131d4db
	//TODO: VPADDQ (BX), Y15, Y2            // c4e105d413 or c585d413
	//TODO: VPADDQ (R11), Y15, Y2           // c4c105d413
	//TODO: VPADDQ Y2, Y15, Y2              // c4e105d4d2 or c585d4d2
	//TODO: VPADDQ Y11, Y15, Y2             // c4c105d4d3
	//TODO: VPADDQ (BX), Y15, Y11           // c46105d41b or c505d41b
	//TODO: VPADDQ (R11), Y15, Y11          // c44105d41b
	//TODO: VPADDQ Y2, Y15, Y11             // c46105d4da or c505d4da
	//TODO: VPADDQ Y11, Y15, Y11            // c44105d4db
	//TODO: VPADDSB (BX), X9, X2            // c4e131ec13 or c5b1ec13
	//TODO: VPADDSB (R11), X9, X2           // c4c131ec13
	//TODO: VPADDSB X2, X9, X2              // c4e131ecd2 or c5b1ecd2
	//TODO: VPADDSB X11, X9, X2             // c4c131ecd3
	//TODO: VPADDSB (BX), X9, X11           // c46131ec1b or c531ec1b
	//TODO: VPADDSB (R11), X9, X11          // c44131ec1b
	//TODO: VPADDSB X2, X9, X11             // c46131ecda or c531ecda
	//TODO: VPADDSB X11, X9, X11            // c44131ecdb
	//TODO: VPADDSB (BX), Y15, Y2           // c4e105ec13 or c585ec13
	//TODO: VPADDSB (R11), Y15, Y2          // c4c105ec13
	//TODO: VPADDSB Y2, Y15, Y2             // c4e105ecd2 or c585ecd2
	//TODO: VPADDSB Y11, Y15, Y2            // c4c105ecd3
	//TODO: VPADDSB (BX), Y15, Y11          // c46105ec1b or c505ec1b
	//TODO: VPADDSB (R11), Y15, Y11         // c44105ec1b
	//TODO: VPADDSB Y2, Y15, Y11            // c46105ecda or c505ecda
	//TODO: VPADDSB Y11, Y15, Y11           // c44105ecdb
	//TODO: VPADDSW (BX), X9, X2            // c4e131ed13 or c5b1ed13
	//TODO: VPADDSW (R11), X9, X2           // c4c131ed13
	//TODO: VPADDSW X2, X9, X2              // c4e131edd2 or c5b1edd2
	//TODO: VPADDSW X11, X9, X2             // c4c131edd3
	//TODO: VPADDSW (BX), X9, X11           // c46131ed1b or c531ed1b
	//TODO: VPADDSW (R11), X9, X11          // c44131ed1b
	//TODO: VPADDSW X2, X9, X11             // c46131edda or c531edda
	//TODO: VPADDSW X11, X9, X11            // c44131eddb
	//TODO: VPADDSW (BX), Y15, Y2           // c4e105ed13 or c585ed13
	//TODO: VPADDSW (R11), Y15, Y2          // c4c105ed13
	//TODO: VPADDSW Y2, Y15, Y2             // c4e105edd2 or c585edd2
	//TODO: VPADDSW Y11, Y15, Y2            // c4c105edd3
	//TODO: VPADDSW (BX), Y15, Y11          // c46105ed1b or c505ed1b
	//TODO: VPADDSW (R11), Y15, Y11         // c44105ed1b
	//TODO: VPADDSW Y2, Y15, Y11            // c46105edda or c505edda
	//TODO: VPADDSW Y11, Y15, Y11           // c44105eddb
	//TODO: VPADDUSB (BX), X9, X2           // c4e131dc13 or c5b1dc13
	//TODO: VPADDUSB (R11), X9, X2          // c4c131dc13
	//TODO: VPADDUSB X2, X9, X2             // c4e131dcd2 or c5b1dcd2
	//TODO: VPADDUSB X11, X9, X2            // c4c131dcd3
	//TODO: VPADDUSB (BX), X9, X11          // c46131dc1b or c531dc1b
	//TODO: VPADDUSB (R11), X9, X11         // c44131dc1b
	//TODO: VPADDUSB X2, X9, X11            // c46131dcda or c531dcda
	//TODO: VPADDUSB X11, X9, X11           // c44131dcdb
	//TODO: VPADDUSB (BX), Y15, Y2          // c4e105dc13 or c585dc13
	//TODO: VPADDUSB (R11), Y15, Y2         // c4c105dc13
	//TODO: VPADDUSB Y2, Y15, Y2            // c4e105dcd2 or c585dcd2
	//TODO: VPADDUSB Y11, Y15, Y2           // c4c105dcd3
	//TODO: VPADDUSB (BX), Y15, Y11         // c46105dc1b or c505dc1b
	//TODO: VPADDUSB (R11), Y15, Y11        // c44105dc1b
	//TODO: VPADDUSB Y2, Y15, Y11           // c46105dcda or c505dcda
	//TODO: VPADDUSB Y11, Y15, Y11          // c44105dcdb
	//TODO: VPADDUSW (BX), X9, X2           // c4e131dd13 or c5b1dd13
	//TODO: VPADDUSW (R11), X9, X2          // c4c131dd13
	//TODO: VPADDUSW X2, X9, X2             // c4e131ddd2 or c5b1ddd2
	//TODO: VPADDUSW X11, X9, X2            // c4c131ddd3
	//TODO: VPADDUSW (BX), X9, X11          // c46131dd1b or c531dd1b
	//TODO: VPADDUSW (R11), X9, X11         // c44131dd1b
	//TODO: VPADDUSW X2, X9, X11            // c46131ddda or c531ddda
	//TODO: VPADDUSW X11, X9, X11           // c44131dddb
	//TODO: VPADDUSW (BX), Y15, Y2          // c4e105dd13 or c585dd13
	//TODO: VPADDUSW (R11), Y15, Y2         // c4c105dd13
	//TODO: VPADDUSW Y2, Y15, Y2            // c4e105ddd2 or c585ddd2
	//TODO: VPADDUSW Y11, Y15, Y2           // c4c105ddd3
	//TODO: VPADDUSW (BX), Y15, Y11         // c46105dd1b or c505dd1b
	//TODO: VPADDUSW (R11), Y15, Y11        // c44105dd1b
	//TODO: VPADDUSW Y2, Y15, Y11           // c46105ddda or c505ddda
	//TODO: VPADDUSW Y11, Y15, Y11          // c44105dddb
	//TODO: VPADDW (BX), X9, X2             // c4e131fd13 or c5b1fd13
	//TODO: VPADDW (R11), X9, X2            // c4c131fd13
	//TODO: VPADDW X2, X9, X2               // c4e131fdd2 or c5b1fdd2
	//TODO: VPADDW X11, X9, X2              // c4c131fdd3
	//TODO: VPADDW (BX), X9, X11            // c46131fd1b or c531fd1b
	//TODO: VPADDW (R11), X9, X11           // c44131fd1b
	//TODO: VPADDW X2, X9, X11              // c46131fdda or c531fdda
	//TODO: VPADDW X11, X9, X11             // c44131fddb
	//TODO: VPADDW (BX), Y15, Y2            // c4e105fd13 or c585fd13
	//TODO: VPADDW (R11), Y15, Y2           // c4c105fd13
	//TODO: VPADDW Y2, Y15, Y2              // c4e105fdd2 or c585fdd2
	//TODO: VPADDW Y11, Y15, Y2             // c4c105fdd3
	//TODO: VPADDW (BX), Y15, Y11           // c46105fd1b or c505fd1b
	//TODO: VPADDW (R11), Y15, Y11          // c44105fd1b
	//TODO: VPADDW Y2, Y15, Y11             // c46105fdda or c505fdda
	//TODO: VPADDW Y11, Y15, Y11            // c44105fddb
	//TODO: VPALIGNR $7, (BX), X9, X2       // c4e3310f1307
	//TODO: VPALIGNR $7, (R11), X9, X2      // c4c3310f1307
	//TODO: VPALIGNR $7, X2, X9, X2         // c4e3310fd207
	//TODO: VPALIGNR $7, X11, X9, X2        // c4c3310fd307
	//TODO: VPALIGNR $7, (BX), X9, X11      // c463310f1b07
	//TODO: VPALIGNR $7, (R11), X9, X11     // c443310f1b07
	//TODO: VPALIGNR $7, X2, X9, X11        // c463310fda07
	//TODO: VPALIGNR $7, X11, X9, X11       // c443310fdb07
	//TODO: VPALIGNR $7, (BX), Y15, Y2      // c4e3050f1307
	//TODO: VPALIGNR $7, (R11), Y15, Y2     // c4c3050f1307
	//TODO: VPALIGNR $7, Y2, Y15, Y2        // c4e3050fd207
	//TODO: VPALIGNR $7, Y11, Y15, Y2       // c4c3050fd307
	//TODO: VPALIGNR $7, (BX), Y15, Y11     // c463050f1b07
	//TODO: VPALIGNR $7, (R11), Y15, Y11    // c443050f1b07
	//TODO: VPALIGNR $7, Y2, Y15, Y11       // c463050fda07
	//TODO: VPALIGNR $7, Y11, Y15, Y11      // c443050fdb07
	VPAND (BX), X9, X2                      // c4e131db13 or c5b1db13
	VPAND (R11), X9, X2                     // c4c131db13
	VPAND X2, X9, X2                        // c4e131dbd2 or c5b1dbd2
	VPAND X11, X9, X2                       // c4c131dbd3
	VPAND (BX), X9, X11                     // c46131db1b or c531db1b
	VPAND (R11), X9, X11                    // c44131db1b
	VPAND X2, X9, X11                       // c46131dbda or c531dbda
	VPAND X11, X9, X11                      // c44131dbdb
	VPAND (BX), Y15, Y2                     // c4e105db13 or c585db13
	VPAND (R11), Y15, Y2                    // c4c105db13
	VPAND Y2, Y15, Y2                       // c4e105dbd2 or c585dbd2
	VPAND Y11, Y15, Y2                      // c4c105dbd3
	VPAND (BX), Y15, Y11                    // c46105db1b or c505db1b
	VPAND (R11), Y15, Y11                   // c44105db1b
	VPAND Y2, Y15, Y11                      // c46105dbda or c505dbda
	VPAND Y11, Y15, Y11                     // c44105dbdb
	//TODO: VPANDN (BX), X9, X2             // c4e131df13 or c5b1df13
	//TODO: VPANDN (R11), X9, X2            // c4c131df13
	//TODO: VPANDN X2, X9, X2               // c4e131dfd2 or c5b1dfd2
	//TODO: VPANDN X11, X9, X2              // c4c131dfd3
	//TODO: VPANDN (BX), X9, X11            // c46131df1b or c531df1b
	//TODO: VPANDN (R11), X9, X11           // c44131df1b
	//TODO: VPANDN X2, X9, X11              // c46131dfda or c531dfda
	//TODO: VPANDN X11, X9, X11             // c44131dfdb
	//TODO: VPANDN (BX), Y15, Y2            // c4e105df13 or c585df13
	//TODO: VPANDN (R11), Y15, Y2           // c4c105df13
	//TODO: VPANDN Y2, Y15, Y2              // c4e105dfd2 or c585dfd2
	//TODO: VPANDN Y11, Y15, Y2             // c4c105dfd3
	//TODO: VPANDN (BX), Y15, Y11           // c46105df1b or c505df1b
	//TODO: VPANDN (R11), Y15, Y11          // c44105df1b
	//TODO: VPANDN Y2, Y15, Y11             // c46105dfda or c505dfda
	//TODO: VPANDN Y11, Y15, Y11            // c44105dfdb
	//TODO: VPAVGB (BX), X9, X2             // c4e131e013 or c5b1e013
	//TODO: VPAVGB (R11), X9, X2            // c4c131e013
	//TODO: VPAVGB X2, X9, X2               // c4e131e0d2 or c5b1e0d2
	//TODO: VPAVGB X11, X9, X2              // c4c131e0d3
	//TODO: VPAVGB (BX), X9, X11            // c46131e01b or c531e01b
	//TODO: VPAVGB (R11), X9, X11           // c44131e01b
	//TODO: VPAVGB X2, X9, X11              // c46131e0da or c531e0da
	//TODO: VPAVGB X11, X9, X11             // c44131e0db
	//TODO: VPAVGB (BX), Y15, Y2            // c4e105e013 or c585e013
	//TODO: VPAVGB (R11), Y15, Y2           // c4c105e013
	//TODO: VPAVGB Y2, Y15, Y2              // c4e105e0d2 or c585e0d2
	//TODO: VPAVGB Y11, Y15, Y2             // c4c105e0d3
	//TODO: VPAVGB (BX), Y15, Y11           // c46105e01b or c505e01b
	//TODO: VPAVGB (R11), Y15, Y11          // c44105e01b
	//TODO: VPAVGB Y2, Y15, Y11             // c46105e0da or c505e0da
	//TODO: VPAVGB Y11, Y15, Y11            // c44105e0db
	//TODO: VPAVGW (BX), X9, X2             // c4e131e313 or c5b1e313
	//TODO: VPAVGW (R11), X9, X2            // c4c131e313
	//TODO: VPAVGW X2, X9, X2               // c4e131e3d2 or c5b1e3d2
	//TODO: VPAVGW X11, X9, X2              // c4c131e3d3
	//TODO: VPAVGW (BX), X9, X11            // c46131e31b or c531e31b
	//TODO: VPAVGW (R11), X9, X11           // c44131e31b
	//TODO: VPAVGW X2, X9, X11              // c46131e3da or c531e3da
	//TODO: VPAVGW X11, X9, X11             // c44131e3db
	//TODO: VPAVGW (BX), Y15, Y2            // c4e105e313 or c585e313
	//TODO: VPAVGW (R11), Y15, Y2           // c4c105e313
	//TODO: VPAVGW Y2, Y15, Y2              // c4e105e3d2 or c585e3d2
	//TODO: VPAVGW Y11, Y15, Y2             // c4c105e3d3
	//TODO: VPAVGW (BX), Y15, Y11           // c46105e31b or c505e31b
	//TODO: VPAVGW (R11), Y15, Y11          // c44105e31b
	//TODO: VPAVGW Y2, Y15, Y11             // c46105e3da or c505e3da
	//TODO: VPAVGW Y11, Y15, Y11            // c44105e3db
	//TODO: VPBLENDD $7, (BX), X9, X2       // c4e331021307
	//TODO: VPBLENDD $7, (R11), X9, X2      // c4c331021307
	//TODO: VPBLENDD $7, X2, X9, X2         // c4e33102d207
	//TODO: VPBLENDD $7, X11, X9, X2        // c4c33102d307
	//TODO: VPBLENDD $7, (BX), X9, X11      // c46331021b07
	//TODO: VPBLENDD $7, (R11), X9, X11     // c44331021b07
	//TODO: VPBLENDD $7, X2, X9, X11        // c4633102da07
	//TODO: VPBLENDD $7, X11, X9, X11       // c4433102db07
	//TODO: VPBLENDD $7, (BX), Y15, Y2      // c4e305021307
	//TODO: VPBLENDD $7, (R11), Y15, Y2     // c4c305021307
	//TODO: VPBLENDD $7, Y2, Y15, Y2        // c4e30502d207
	//TODO: VPBLENDD $7, Y11, Y15, Y2       // c4c30502d307
	//TODO: VPBLENDD $7, (BX), Y15, Y11     // c46305021b07
	//TODO: VPBLENDD $7, (R11), Y15, Y11    // c44305021b07
	//TODO: VPBLENDD $7, Y2, Y15, Y11       // c4630502da07
	//TODO: VPBLENDD $7, Y11, Y15, Y11      // c4430502db07
	//TODO: VPBLENDVB XMM12, (BX), X9, X2   // c4e3314c13c0
	//TODO: VPBLENDVB XMM12, (R11), X9, X2  // c4c3314c13c0
	//TODO: VPBLENDVB XMM12, X2, X9, X2     // c4e3314cd2c0
	//TODO: VPBLENDVB XMM12, X11, X9, X2    // c4c3314cd3c0
	//TODO: VPBLENDVB XMM12, (BX), X9, X11  // c463314c1bc0
	//TODO: VPBLENDVB XMM12, (R11), X9, X11 // c443314c1bc0
	//TODO: VPBLENDVB XMM12, X2, X9, X11    // c463314cdac0
	//TODO: VPBLENDVB XMM12, X11, X9, X11   // c443314cdbc0
	//TODO: VPBLENDVB YMM13, (BX), Y15, Y2  // c4e3054c13d0
	//TODO: VPBLENDVB YMM13, (R11), Y15, Y2 // c4c3054c13d0
	//TODO: VPBLENDVB YMM13, Y2, Y15, Y2    // c4e3054cd2d0
	//TODO: VPBLENDVB YMM13, Y11, Y15, Y2   // c4c3054cd3d0
	//TODO: VPBLENDVB YMM13, (BX), Y15, Y11 // c463054c1bd0
	//TODO: VPBLENDVB YMM13, (R11), Y15, Y11 // c443054c1bd0
	//TODO: VPBLENDVB YMM13, Y2, Y15, Y11   // c463054cdad0
	//TODO: VPBLENDVB YMM13, Y11, Y15, Y11  // c443054cdbd0
	//TODO: VPBLENDW $7, (BX), X9, X2       // c4e3310e1307
	//TODO: VPBLENDW $7, (R11), X9, X2      // c4c3310e1307
	//TODO: VPBLENDW $7, X2, X9, X2         // c4e3310ed207
	//TODO: VPBLENDW $7, X11, X9, X2        // c4c3310ed307
	//TODO: VPBLENDW $7, (BX), X9, X11      // c463310e1b07
	//TODO: VPBLENDW $7, (R11), X9, X11     // c443310e1b07
	//TODO: VPBLENDW $7, X2, X9, X11        // c463310eda07
	//TODO: VPBLENDW $7, X11, X9, X11       // c443310edb07
	//TODO: VPBLENDW $7, (BX), Y15, Y2      // c4e3050e1307
	//TODO: VPBLENDW $7, (R11), Y15, Y2     // c4c3050e1307
	//TODO: VPBLENDW $7, Y2, Y15, Y2        // c4e3050ed207
	//TODO: VPBLENDW $7, Y11, Y15, Y2       // c4c3050ed307
	//TODO: VPBLENDW $7, (BX), Y15, Y11     // c463050e1b07
	//TODO: VPBLENDW $7, (R11), Y15, Y11    // c443050e1b07
	//TODO: VPBLENDW $7, Y2, Y15, Y11       // c463050eda07
	//TODO: VPBLENDW $7, Y11, Y15, Y11      // c443050edb07
	VPBROADCASTB (BX), X2                   // c4e2797813
	VPBROADCASTB (R11), X2                  // c4c2797813
	VPBROADCASTB X2, X2                     // c4e27978d2
	VPBROADCASTB X11, X2                    // c4c27978d3
	VPBROADCASTB (BX), X11                  // c46279781b
	VPBROADCASTB (R11), X11                 // c44279781b
	VPBROADCASTB X2, X11                    // c4627978da
	VPBROADCASTB X11, X11                   // c4427978db
	VPBROADCASTB (BX), Y2                   // c4e27d7813
	VPBROADCASTB (R11), Y2                  // c4c27d7813
	VPBROADCASTB X2, Y2                     // c4e27d78d2
	VPBROADCASTB X11, Y2                    // c4c27d78d3
	VPBROADCASTB (BX), Y11                  // c4627d781b
	VPBROADCASTB (R11), Y11                 // c4427d781b
	VPBROADCASTB X2, Y11                    // c4627d78da
	VPBROADCASTB X11, Y11                   // c4427d78db
	//TODO: VPBROADCASTD (BX), X2           // c4e2795813
	//TODO: VPBROADCASTD (R11), X2          // c4c2795813
	//TODO: VPBROADCASTD X2, X2             // c4e27958d2
	//TODO: VPBROADCASTD X11, X2            // c4c27958d3
	//TODO: VPBROADCASTD (BX), X11          // c46279581b
	//TODO: VPBROADCASTD (R11), X11         // c44279581b
	//TODO: VPBROADCASTD X2, X11            // c4627958da
	//TODO: VPBROADCASTD X11, X11           // c4427958db
	//TODO: VPBROADCASTD (BX), Y2           // c4e27d5813
	//TODO: VPBROADCASTD (R11), Y2          // c4c27d5813
	//TODO: VPBROADCASTD X2, Y2             // c4e27d58d2
	//TODO: VPBROADCASTD X11, Y2            // c4c27d58d3
	//TODO: VPBROADCASTD (BX), Y11          // c4627d581b
	//TODO: VPBROADCASTD (R11), Y11         // c4427d581b
	//TODO: VPBROADCASTD X2, Y11            // c4627d58da
	//TODO: VPBROADCASTD X11, Y11           // c4427d58db
	//TODO: VPBROADCASTQ (BX), X2           // c4e2795913
	//TODO: VPBROADCASTQ (R11), X2          // c4c2795913
	//TODO: VPBROADCASTQ X2, X2             // c4e27959d2
	//TODO: VPBROADCASTQ X11, X2            // c4c27959d3
	//TODO: VPBROADCASTQ (BX), X11          // c46279591b
	//TODO: VPBROADCASTQ (R11), X11         // c44279591b
	//TODO: VPBROADCASTQ X2, X11            // c4627959da
	//TODO: VPBROADCASTQ X11, X11           // c4427959db
	//TODO: VPBROADCASTQ (BX), Y2           // c4e27d5913
	//TODO: VPBROADCASTQ (R11), Y2          // c4c27d5913
	//TODO: VPBROADCASTQ X2, Y2             // c4e27d59d2
	//TODO: VPBROADCASTQ X11, Y2            // c4c27d59d3
	//TODO: VPBROADCASTQ (BX), Y11          // c4627d591b
	//TODO: VPBROADCASTQ (R11), Y11         // c4427d591b
	//TODO: VPBROADCASTQ X2, Y11            // c4627d59da
	//TODO: VPBROADCASTQ X11, Y11           // c4427d59db
	//TODO: VPBROADCASTW (BX), X2           // c4e2797913
	//TODO: VPBROADCASTW (R11), X2          // c4c2797913
	//TODO: VPBROADCASTW X2, X2             // c4e27979d2
	//TODO: VPBROADCASTW X11, X2            // c4c27979d3
	//TODO: VPBROADCASTW (BX), X11          // c46279791b
	//TODO: VPBROADCASTW (R11), X11         // c44279791b
	//TODO: VPBROADCASTW X2, X11            // c4627979da
	//TODO: VPBROADCASTW X11, X11           // c4427979db
	//TODO: VPBROADCASTW (BX), Y2           // c4e27d7913
	//TODO: VPBROADCASTW (R11), Y2          // c4c27d7913
	//TODO: VPBROADCASTW X2, Y2             // c4e27d79d2
	//TODO: VPBROADCASTW X11, Y2            // c4c27d79d3
	//TODO: VPBROADCASTW (BX), Y11          // c4627d791b
	//TODO: VPBROADCASTW (R11), Y11         // c4427d791b
	//TODO: VPBROADCASTW X2, Y11            // c4627d79da
	//TODO: VPBROADCASTW X11, Y11           // c4427d79db
	//TODO: VPCLMULQDQ $7, (BX), X9, X2     // c4e331441307
	//TODO: VPCLMULQDQ $7, (R11), X9, X2    // c4c331441307
	//TODO: VPCLMULQDQ $7, X2, X9, X2       // c4e33144d207
	//TODO: VPCLMULQDQ $7, X11, X9, X2      // c4c33144d307
	//TODO: VPCLMULQDQ $7, (BX), X9, X11    // c46331441b07
	//TODO: VPCLMULQDQ $7, (R11), X9, X11   // c44331441b07
	//TODO: VPCLMULQDQ $7, X2, X9, X11      // c4633144da07
	//TODO: VPCLMULQDQ $7, X11, X9, X11     // c4433144db07
	VPCMPEQB (BX), X9, X2                   // c4e1317413 or c5b17413
	VPCMPEQB (R11), X9, X2                  // c4c1317413
	VPCMPEQB X2, X9, X2                     // c4e13174d2 or c5b174d2
	VPCMPEQB X11, X9, X2                    // c4c13174d3
	VPCMPEQB (BX), X9, X11                  // c46131741b or c531741b
	VPCMPEQB (R11), X9, X11                 // c44131741b
	VPCMPEQB X2, X9, X11                    // c4613174da or c53174da
	VPCMPEQB X11, X9, X11                   // c4413174db
	VPCMPEQB (BX), Y15, Y2                  // c4e1057413 or c5857413
	VPCMPEQB (R11), Y15, Y2                 // c4c1057413
	VPCMPEQB Y2, Y15, Y2                    // c4e10574d2 or c58574d2
	VPCMPEQB Y11, Y15, Y2                   // c4c10574d3
	VPCMPEQB (BX), Y15, Y11                 // c46105741b or c505741b
	VPCMPEQB (R11), Y15, Y11                // c44105741b
	VPCMPEQB Y2, Y15, Y11                   // c4610574da or c50574da
	VPCMPEQB Y11, Y15, Y11                  // c4410574db
	//TODO: VPCMPEQD (BX), X9, X2           // c4e1317613 or c5b17613
	//TODO: VPCMPEQD (R11), X9, X2          // c4c1317613
	//TODO: VPCMPEQD X2, X9, X2             // c4e13176d2 or c5b176d2
	//TODO: VPCMPEQD X11, X9, X2            // c4c13176d3
	//TODO: VPCMPEQD (BX), X9, X11          // c46131761b or c531761b
	//TODO: VPCMPEQD (R11), X9, X11         // c44131761b
	//TODO: VPCMPEQD X2, X9, X11            // c4613176da or c53176da
	//TODO: VPCMPEQD X11, X9, X11           // c4413176db
	//TODO: VPCMPEQD (BX), Y15, Y2          // c4e1057613 or c5857613
	//TODO: VPCMPEQD (R11), Y15, Y2         // c4c1057613
	//TODO: VPCMPEQD Y2, Y15, Y2            // c4e10576d2 or c58576d2
	//TODO: VPCMPEQD Y11, Y15, Y2           // c4c10576d3
	//TODO: VPCMPEQD (BX), Y15, Y11         // c46105761b or c505761b
	//TODO: VPCMPEQD (R11), Y15, Y11        // c44105761b
	//TODO: VPCMPEQD Y2, Y15, Y11           // c4610576da or c50576da
	//TODO: VPCMPEQD Y11, Y15, Y11          // c4410576db
	//TODO: VPCMPEQQ (BX), X9, X2           // c4e2312913
	//TODO: VPCMPEQQ (R11), X9, X2          // c4c2312913
	//TODO: VPCMPEQQ X2, X9, X2             // c4e23129d2
	//TODO: VPCMPEQQ X11, X9, X2            // c4c23129d3
	//TODO: VPCMPEQQ (BX), X9, X11          // c46231291b
	//TODO: VPCMPEQQ (R11), X9, X11         // c44231291b
	//TODO: VPCMPEQQ X2, X9, X11            // c4623129da
	//TODO: VPCMPEQQ X11, X9, X11           // c4423129db
	//TODO: VPCMPEQQ (BX), Y15, Y2          // c4e2052913
	//TODO: VPCMPEQQ (R11), Y15, Y2         // c4c2052913
	//TODO: VPCMPEQQ Y2, Y15, Y2            // c4e20529d2
	//TODO: VPCMPEQQ Y11, Y15, Y2           // c4c20529d3
	//TODO: VPCMPEQQ (BX), Y15, Y11         // c46205291b
	//TODO: VPCMPEQQ (R11), Y15, Y11        // c44205291b
	//TODO: VPCMPEQQ Y2, Y15, Y11           // c4620529da
	//TODO: VPCMPEQQ Y11, Y15, Y11          // c4420529db
	//TODO: VPCMPEQW (BX), X9, X2           // c4e1317513 or c5b17513
	//TODO: VPCMPEQW (R11), X9, X2          // c4c1317513
	//TODO: VPCMPEQW X2, X9, X2             // c4e13175d2 or c5b175d2
	//TODO: VPCMPEQW X11, X9, X2            // c4c13175d3
	//TODO: VPCMPEQW (BX), X9, X11          // c46131751b or c531751b
	//TODO: VPCMPEQW (R11), X9, X11         // c44131751b
	//TODO: VPCMPEQW X2, X9, X11            // c4613175da or c53175da
	//TODO: VPCMPEQW X11, X9, X11           // c4413175db
	//TODO: VPCMPEQW (BX), Y15, Y2          // c4e1057513 or c5857513
	//TODO: VPCMPEQW (R11), Y15, Y2         // c4c1057513
	//TODO: VPCMPEQW Y2, Y15, Y2            // c4e10575d2 or c58575d2
	//TODO: VPCMPEQW Y11, Y15, Y2           // c4c10575d3
	//TODO: VPCMPEQW (BX), Y15, Y11         // c46105751b or c505751b
	//TODO: VPCMPEQW (R11), Y15, Y11        // c44105751b
	//TODO: VPCMPEQW Y2, Y15, Y11           // c4610575da or c50575da
	//TODO: VPCMPEQW Y11, Y15, Y11          // c4410575db
	//TODO: VPCMPESTRI $7, (BX), X2         // c4e379611307
	//TODO: VPCMPESTRI $7, (R11), X2        // c4c379611307
	//TODO: VPCMPESTRI $7, X2, X2           // c4e37961d207
	//TODO: VPCMPESTRI $7, X11, X2          // c4c37961d307
	//TODO: VPCMPESTRI $7, (BX), X11        // c46379611b07
	//TODO: VPCMPESTRI $7, (R11), X11       // c44379611b07
	//TODO: VPCMPESTRI $7, X2, X11          // c4637961da07
	//TODO: VPCMPESTRI $7, X11, X11         // c4437961db07
	//TODO: VPCMPESTRM $7, (BX), X2         // c4e379601307
	//TODO: VPCMPESTRM $7, (R11), X2        // c4c379601307
	//TODO: VPCMPESTRM $7, X2, X2           // c4e37960d207
	//TODO: VPCMPESTRM $7, X11, X2          // c4c37960d307
	//TODO: VPCMPESTRM $7, (BX), X11        // c46379601b07
	//TODO: VPCMPESTRM $7, (R11), X11       // c44379601b07
	//TODO: VPCMPESTRM $7, X2, X11          // c4637960da07
	//TODO: VPCMPESTRM $7, X11, X11         // c4437960db07
	//TODO: VPCMPGTB (BX), X9, X2           // c4e1316413 or c5b16413
	//TODO: VPCMPGTB (R11), X9, X2          // c4c1316413
	//TODO: VPCMPGTB X2, X9, X2             // c4e13164d2 or c5b164d2
	//TODO: VPCMPGTB X11, X9, X2            // c4c13164d3
	//TODO: VPCMPGTB (BX), X9, X11          // c46131641b or c531641b
	//TODO: VPCMPGTB (R11), X9, X11         // c44131641b
	//TODO: VPCMPGTB X2, X9, X11            // c4613164da or c53164da
	//TODO: VPCMPGTB X11, X9, X11           // c4413164db
	//TODO: VPCMPGTB (BX), Y15, Y2          // c4e1056413 or c5856413
	//TODO: VPCMPGTB (R11), Y15, Y2         // c4c1056413
	//TODO: VPCMPGTB Y2, Y15, Y2            // c4e10564d2 or c58564d2
	//TODO: VPCMPGTB Y11, Y15, Y2           // c4c10564d3
	//TODO: VPCMPGTB (BX), Y15, Y11         // c46105641b or c505641b
	//TODO: VPCMPGTB (R11), Y15, Y11        // c44105641b
	//TODO: VPCMPGTB Y2, Y15, Y11           // c4610564da or c50564da
	//TODO: VPCMPGTB Y11, Y15, Y11          // c4410564db
	//TODO: VPCMPGTD (BX), X9, X2           // c4e1316613 or c5b16613
	//TODO: VPCMPGTD (R11), X9, X2          // c4c1316613
	//TODO: VPCMPGTD X2, X9, X2             // c4e13166d2 or c5b166d2
	//TODO: VPCMPGTD X11, X9, X2            // c4c13166d3
	//TODO: VPCMPGTD (BX), X9, X11          // c46131661b or c531661b
	//TODO: VPCMPGTD (R11), X9, X11         // c44131661b
	//TODO: VPCMPGTD X2, X9, X11            // c4613166da or c53166da
	//TODO: VPCMPGTD X11, X9, X11           // c4413166db
	//TODO: VPCMPGTD (BX), Y15, Y2          // c4e1056613 or c5856613
	//TODO: VPCMPGTD (R11), Y15, Y2         // c4c1056613
	//TODO: VPCMPGTD Y2, Y15, Y2            // c4e10566d2 or c58566d2
	//TODO: VPCMPGTD Y11, Y15, Y2           // c4c10566d3
	//TODO: VPCMPGTD (BX), Y15, Y11         // c46105661b or c505661b
	//TODO: VPCMPGTD (R11), Y15, Y11        // c44105661b
	//TODO: VPCMPGTD Y2, Y15, Y11           // c4610566da or c50566da
	//TODO: VPCMPGTD Y11, Y15, Y11          // c4410566db
	//TODO: VPCMPGTQ (BX), X9, X2           // c4e2313713
	//TODO: VPCMPGTQ (R11), X9, X2          // c4c2313713
	//TODO: VPCMPGTQ X2, X9, X2             // c4e23137d2
	//TODO: VPCMPGTQ X11, X9, X2            // c4c23137d3
	//TODO: VPCMPGTQ (BX), X9, X11          // c46231371b
	//TODO: VPCMPGTQ (R11), X9, X11         // c44231371b
	//TODO: VPCMPGTQ X2, X9, X11            // c4623137da
	//TODO: VPCMPGTQ X11, X9, X11           // c4423137db
	//TODO: VPCMPGTQ (BX), Y15, Y2          // c4e2053713
	//TODO: VPCMPGTQ (R11), Y15, Y2         // c4c2053713
	//TODO: VPCMPGTQ Y2, Y15, Y2            // c4e20537d2
	//TODO: VPCMPGTQ Y11, Y15, Y2           // c4c20537d3
	//TODO: VPCMPGTQ (BX), Y15, Y11         // c46205371b
	//TODO: VPCMPGTQ (R11), Y15, Y11        // c44205371b
	//TODO: VPCMPGTQ Y2, Y15, Y11           // c4620537da
	//TODO: VPCMPGTQ Y11, Y15, Y11          // c4420537db
	//TODO: VPCMPGTW (BX), X9, X2           // c4e1316513 or c5b16513
	//TODO: VPCMPGTW (R11), X9, X2          // c4c1316513
	//TODO: VPCMPGTW X2, X9, X2             // c4e13165d2 or c5b165d2
	//TODO: VPCMPGTW X11, X9, X2            // c4c13165d3
	//TODO: VPCMPGTW (BX), X9, X11          // c46131651b or c531651b
	//TODO: VPCMPGTW (R11), X9, X11         // c44131651b
	//TODO: VPCMPGTW X2, X9, X11            // c4613165da or c53165da
	//TODO: VPCMPGTW X11, X9, X11           // c4413165db
	//TODO: VPCMPGTW (BX), Y15, Y2          // c4e1056513 or c5856513
	//TODO: VPCMPGTW (R11), Y15, Y2         // c4c1056513
	//TODO: VPCMPGTW Y2, Y15, Y2            // c4e10565d2 or c58565d2
	//TODO: VPCMPGTW Y11, Y15, Y2           // c4c10565d3
	//TODO: VPCMPGTW (BX), Y15, Y11         // c46105651b or c505651b
	//TODO: VPCMPGTW (R11), Y15, Y11        // c44105651b
	//TODO: VPCMPGTW Y2, Y15, Y11           // c4610565da or c50565da
	//TODO: VPCMPGTW Y11, Y15, Y11          // c4410565db
	//TODO: VPCMPISTRI $7, (BX), X2         // c4e379631307
	//TODO: VPCMPISTRI $7, (R11), X2        // c4c379631307
	//TODO: VPCMPISTRI $7, X2, X2           // c4e37963d207
	//TODO: VPCMPISTRI $7, X11, X2          // c4c37963d307
	//TODO: VPCMPISTRI $7, (BX), X11        // c46379631b07
	//TODO: VPCMPISTRI $7, (R11), X11       // c44379631b07
	//TODO: VPCMPISTRI $7, X2, X11          // c4637963da07
	//TODO: VPCMPISTRI $7, X11, X11         // c4437963db07
	//TODO: VPCMPISTRM $7, (BX), X2         // c4e379621307
	//TODO: VPCMPISTRM $7, (R11), X2        // c4c379621307
	//TODO: VPCMPISTRM $7, X2, X2           // c4e37962d207
	//TODO: VPCMPISTRM $7, X11, X2          // c4c37962d307
	//TODO: VPCMPISTRM $7, (BX), X11        // c46379621b07
	//TODO: VPCMPISTRM $7, (R11), X11       // c44379621b07
	//TODO: VPCMPISTRM $7, X2, X11          // c4637962da07
	//TODO: VPCMPISTRM $7, X11, X11         // c4437962db07
	//TODO: VPERM2F128 $7, (BX), Y15, Y2    // c4e305061307
	//TODO: VPERM2F128 $7, (R11), Y15, Y2   // c4c305061307
	//TODO: VPERM2F128 $7, Y2, Y15, Y2      // c4e30506d207
	//TODO: VPERM2F128 $7, Y11, Y15, Y2     // c4c30506d307
	//TODO: VPERM2F128 $7, (BX), Y15, Y11   // c46305061b07
	//TODO: VPERM2F128 $7, (R11), Y15, Y11  // c44305061b07
	//TODO: VPERM2F128 $7, Y2, Y15, Y11     // c4630506da07
	//TODO: VPERM2F128 $7, Y11, Y15, Y11    // c4430506db07
	//TODO: VPERM2I128 $7, (BX), Y15, Y2    // c4e305461307
	//TODO: VPERM2I128 $7, (R11), Y15, Y2   // c4c305461307
	//TODO: VPERM2I128 $7, Y2, Y15, Y2      // c4e30546d207
	//TODO: VPERM2I128 $7, Y11, Y15, Y2     // c4c30546d307
	//TODO: VPERM2I128 $7, (BX), Y15, Y11   // c46305461b07
	//TODO: VPERM2I128 $7, (R11), Y15, Y11  // c44305461b07
	//TODO: VPERM2I128 $7, Y2, Y15, Y11     // c4630546da07
	//TODO: VPERM2I128 $7, Y11, Y15, Y11    // c4430546db07
	//TODO: VPERMD (BX), Y15, Y2            // c4e2053613
	//TODO: VPERMD (R11), Y15, Y2           // c4c2053613
	//TODO: VPERMD Y2, Y15, Y2              // c4e20536d2
	//TODO: VPERMD Y11, Y15, Y2             // c4c20536d3
	//TODO: VPERMD (BX), Y15, Y11           // c46205361b
	//TODO: VPERMD (R11), Y15, Y11          // c44205361b
	//TODO: VPERMD Y2, Y15, Y11             // c4620536da
	//TODO: VPERMD Y11, Y15, Y11            // c4420536db
	//TODO: VPERMILPD $7, (BX), X2          // c4e379051307
	//TODO: VPERMILPD $7, (R11), X2         // c4c379051307
	//TODO: VPERMILPD $7, X2, X2            // c4e37905d207
	//TODO: VPERMILPD $7, X11, X2           // c4c37905d307
	//TODO: VPERMILPD $7, (BX), X11         // c46379051b07
	//TODO: VPERMILPD $7, (R11), X11        // c44379051b07
	//TODO: VPERMILPD $7, X2, X11           // c4637905da07
	//TODO: VPERMILPD $7, X11, X11          // c4437905db07
	//TODO: VPERMILPD (BX), X9, X2          // c4e2310d13
	//TODO: VPERMILPD (R11), X9, X2         // c4c2310d13
	//TODO: VPERMILPD X2, X9, X2            // c4e2310dd2
	//TODO: VPERMILPD X11, X9, X2           // c4c2310dd3
	//TODO: VPERMILPD (BX), X9, X11         // c462310d1b
	//TODO: VPERMILPD (R11), X9, X11        // c442310d1b
	//TODO: VPERMILPD X2, X9, X11           // c462310dda
	//TODO: VPERMILPD X11, X9, X11          // c442310ddb
	//TODO: VPERMILPD $7, (BX), Y2          // c4e37d051307
	//TODO: VPERMILPD $7, (R11), Y2         // c4c37d051307
	//TODO: VPERMILPD $7, Y2, Y2            // c4e37d05d207
	//TODO: VPERMILPD $7, Y11, Y2           // c4c37d05d307
	//TODO: VPERMILPD $7, (BX), Y11         // c4637d051b07
	//TODO: VPERMILPD $7, (R11), Y11        // c4437d051b07
	//TODO: VPERMILPD $7, Y2, Y11           // c4637d05da07
	//TODO: VPERMILPD $7, Y11, Y11          // c4437d05db07
	//TODO: VPERMILPD (BX), Y15, Y2         // c4e2050d13
	//TODO: VPERMILPD (R11), Y15, Y2        // c4c2050d13
	//TODO: VPERMILPD Y2, Y15, Y2           // c4e2050dd2
	//TODO: VPERMILPD Y11, Y15, Y2          // c4c2050dd3
	//TODO: VPERMILPD (BX), Y15, Y11        // c462050d1b
	//TODO: VPERMILPD (R11), Y15, Y11       // c442050d1b
	//TODO: VPERMILPD Y2, Y15, Y11          // c462050dda
	//TODO: VPERMILPD Y11, Y15, Y11         // c442050ddb
	//TODO: VPERMILPS $7, (BX), X2          // c4e379041307
	//TODO: VPERMILPS $7, (R11), X2         // c4c379041307
	//TODO: VPERMILPS $7, X2, X2            // c4e37904d207
	//TODO: VPERMILPS $7, X11, X2           // c4c37904d307
	//TODO: VPERMILPS $7, (BX), X11         // c46379041b07
	//TODO: VPERMILPS $7, (R11), X11        // c44379041b07
	//TODO: VPERMILPS $7, X2, X11           // c4637904da07
	//TODO: VPERMILPS $7, X11, X11          // c4437904db07
	//TODO: VPERMILPS (BX), X9, X2          // c4e2310c13
	//TODO: VPERMILPS (R11), X9, X2         // c4c2310c13
	//TODO: VPERMILPS X2, X9, X2            // c4e2310cd2
	//TODO: VPERMILPS X11, X9, X2           // c4c2310cd3
	//TODO: VPERMILPS (BX), X9, X11         // c462310c1b
	//TODO: VPERMILPS (R11), X9, X11        // c442310c1b
	//TODO: VPERMILPS X2, X9, X11           // c462310cda
	//TODO: VPERMILPS X11, X9, X11          // c442310cdb
	//TODO: VPERMILPS $7, (BX), Y2          // c4e37d041307
	//TODO: VPERMILPS $7, (R11), Y2         // c4c37d041307
	//TODO: VPERMILPS $7, Y2, Y2            // c4e37d04d207
	//TODO: VPERMILPS $7, Y11, Y2           // c4c37d04d307
	//TODO: VPERMILPS $7, (BX), Y11         // c4637d041b07
	//TODO: VPERMILPS $7, (R11), Y11        // c4437d041b07
	//TODO: VPERMILPS $7, Y2, Y11           // c4637d04da07
	//TODO: VPERMILPS $7, Y11, Y11          // c4437d04db07
	//TODO: VPERMILPS (BX), Y15, Y2         // c4e2050c13
	//TODO: VPERMILPS (R11), Y15, Y2        // c4c2050c13
	//TODO: VPERMILPS Y2, Y15, Y2           // c4e2050cd2
	//TODO: VPERMILPS Y11, Y15, Y2          // c4c2050cd3
	//TODO: VPERMILPS (BX), Y15, Y11        // c462050c1b
	//TODO: VPERMILPS (R11), Y15, Y11       // c442050c1b
	//TODO: VPERMILPS Y2, Y15, Y11          // c462050cda
	//TODO: VPERMILPS Y11, Y15, Y11         // c442050cdb
	//TODO: VPERMPD $7, (BX), Y2            // c4e3fd011307
	//TODO: VPERMPD $7, (R11), Y2           // c4c3fd011307
	//TODO: VPERMPD $7, Y2, Y2              // c4e3fd01d207
	//TODO: VPERMPD $7, Y11, Y2             // c4c3fd01d307
	//TODO: VPERMPD $7, (BX), Y11           // c463fd011b07
	//TODO: VPERMPD $7, (R11), Y11          // c443fd011b07
	//TODO: VPERMPD $7, Y2, Y11             // c463fd01da07
	//TODO: VPERMPD $7, Y11, Y11            // c443fd01db07
	//TODO: VPERMPS (BX), Y15, Y2           // c4e2051613
	//TODO: VPERMPS (R11), Y15, Y2          // c4c2051613
	//TODO: VPERMPS Y2, Y15, Y2             // c4e20516d2
	//TODO: VPERMPS Y11, Y15, Y2            // c4c20516d3
	//TODO: VPERMPS (BX), Y15, Y11          // c46205161b
	//TODO: VPERMPS (R11), Y15, Y11         // c44205161b
	//TODO: VPERMPS Y2, Y15, Y11            // c4620516da
	//TODO: VPERMPS Y11, Y15, Y11           // c4420516db
	//TODO: VPERMQ $7, (BX), Y2             // c4e3fd001307
	//TODO: VPERMQ $7, (R11), Y2            // c4c3fd001307
	//TODO: VPERMQ $7, Y2, Y2               // c4e3fd00d207
	//TODO: VPERMQ $7, Y11, Y2              // c4c3fd00d307
	//TODO: VPERMQ $7, (BX), Y11            // c463fd001b07
	//TODO: VPERMQ $7, (R11), Y11           // c443fd001b07
	//TODO: VPERMQ $7, Y2, Y11              // c463fd00da07
	//TODO: VPERMQ $7, Y11, Y11             // c443fd00db07
	//TODO: VPEXTRB $7, X2, (BX)            // c4e379141307
	//TODO: VPEXTRB $7, X11, (BX)           // c46379141b07
	//TODO: VPEXTRB $7, X2, (R11)           // c4c379141307
	//TODO: VPEXTRB $7, X11, (R11)          // c44379141b07
	//TODO: VPEXTRB $7, X2, DX              // c4e37914d207
	//TODO: VPEXTRB $7, X11, DX             // c4637914da07
	//TODO: VPEXTRB $7, X2, R11             // c4c37914d307
	//TODO: VPEXTRB $7, X11, R11            // c4437914db07
	//TODO: VPEXTRD $7, X2, (BX)            // c4e379161307
	//TODO: VPEXTRD $7, X11, (BX)           // c46379161b07
	//TODO: VPEXTRD $7, X2, (R11)           // c4c379161307
	//TODO: VPEXTRD $7, X11, (R11)          // c44379161b07
	//TODO: VPEXTRD $7, X2, DX              // c4e37916d207
	//TODO: VPEXTRD $7, X11, DX             // c4637916da07
	//TODO: VPEXTRD $7, X2, R11             // c4c37916d307
	//TODO: VPEXTRD $7, X11, R11            // c4437916db07
	//TODO: VPEXTRQ $7, X2, (BX)            // c4e3f9161307
	//TODO: VPEXTRQ $7, X11, (BX)           // c463f9161b07
	//TODO: VPEXTRQ $7, X2, (R11)           // c4c3f9161307
	//TODO: VPEXTRQ $7, X11, (R11)          // c443f9161b07
	//TODO: VPEXTRQ $7, X2, DX              // c4e3f916d207
	//TODO: VPEXTRQ $7, X11, DX             // c463f916da07
	//TODO: VPEXTRQ $7, X2, R11             // c4c3f916d307
	//TODO: VPEXTRQ $7, X11, R11            // c443f916db07
	//TODO: VPEXTRW $7, X2, DX              // c4e179c5d207 or c5f9c5d207 or c4e37915d207
	//TODO: VPEXTRW $7, X11, DX             // c4c179c5d307 or c4637915da07
	//TODO: VPEXTRW $7, X2, R11             // c46179c5da07 or c579c5da07 or c4c37915d307
	//TODO: VPEXTRW $7, X11, R11            // c44179c5db07 or c4437915db07
	//TODO: VPEXTRW $7, X2, (BX)            // c4e379151307
	//TODO: VPEXTRW $7, X11, (BX)           // c46379151b07
	//TODO: VPEXTRW $7, X2, (R11)           // c4c379151307
	//TODO: VPEXTRW $7, X11, (R11)          // c44379151b07
	//TODO: VPHADDD (BX), X9, X2            // c4e2310213
	//TODO: VPHADDD (R11), X9, X2           // c4c2310213
	//TODO: VPHADDD X2, X9, X2              // c4e23102d2
	//TODO: VPHADDD X11, X9, X2             // c4c23102d3
	//TODO: VPHADDD (BX), X9, X11           // c46231021b
	//TODO: VPHADDD (R11), X9, X11          // c44231021b
	//TODO: VPHADDD X2, X9, X11             // c4623102da
	//TODO: VPHADDD X11, X9, X11            // c4423102db
	//TODO: VPHADDD (BX), Y15, Y2           // c4e2050213
	//TODO: VPHADDD (R11), Y15, Y2          // c4c2050213
	//TODO: VPHADDD Y2, Y15, Y2             // c4e20502d2
	//TODO: VPHADDD Y11, Y15, Y2            // c4c20502d3
	//TODO: VPHADDD (BX), Y15, Y11          // c46205021b
	//TODO: VPHADDD (R11), Y15, Y11         // c44205021b
	//TODO: VPHADDD Y2, Y15, Y11            // c4620502da
	//TODO: VPHADDD Y11, Y15, Y11           // c4420502db
	//TODO: VPHADDSW (BX), X9, X2           // c4e2310313
	//TODO: VPHADDSW (R11), X9, X2          // c4c2310313
	//TODO: VPHADDSW X2, X9, X2             // c4e23103d2
	//TODO: VPHADDSW X11, X9, X2            // c4c23103d3
	//TODO: VPHADDSW (BX), X9, X11          // c46231031b
	//TODO: VPHADDSW (R11), X9, X11         // c44231031b
	//TODO: VPHADDSW X2, X9, X11            // c4623103da
	//TODO: VPHADDSW X11, X9, X11           // c4423103db
	//TODO: VPHADDSW (BX), Y15, Y2          // c4e2050313
	//TODO: VPHADDSW (R11), Y15, Y2         // c4c2050313
	//TODO: VPHADDSW Y2, Y15, Y2            // c4e20503d2
	//TODO: VPHADDSW Y11, Y15, Y2           // c4c20503d3
	//TODO: VPHADDSW (BX), Y15, Y11         // c46205031b
	//TODO: VPHADDSW (R11), Y15, Y11        // c44205031b
	//TODO: VPHADDSW Y2, Y15, Y11           // c4620503da
	//TODO: VPHADDSW Y11, Y15, Y11          // c4420503db
	//TODO: VPHADDW (BX), X9, X2            // c4e2310113
	//TODO: VPHADDW (R11), X9, X2           // c4c2310113
	//TODO: VPHADDW X2, X9, X2              // c4e23101d2
	//TODO: VPHADDW X11, X9, X2             // c4c23101d3
	//TODO: VPHADDW (BX), X9, X11           // c46231011b
	//TODO: VPHADDW (R11), X9, X11          // c44231011b
	//TODO: VPHADDW X2, X9, X11             // c4623101da
	//TODO: VPHADDW X11, X9, X11            // c4423101db
	//TODO: VPHADDW (BX), Y15, Y2           // c4e2050113
	//TODO: VPHADDW (R11), Y15, Y2          // c4c2050113
	//TODO: VPHADDW Y2, Y15, Y2             // c4e20501d2
	//TODO: VPHADDW Y11, Y15, Y2            // c4c20501d3
	//TODO: VPHADDW (BX), Y15, Y11          // c46205011b
	//TODO: VPHADDW (R11), Y15, Y11         // c44205011b
	//TODO: VPHADDW Y2, Y15, Y11            // c4620501da
	//TODO: VPHADDW Y11, Y15, Y11           // c4420501db
	//TODO: VPHMINPOSUW (BX), X2            // c4e2794113
	//TODO: VPHMINPOSUW (R11), X2           // c4c2794113
	//TODO: VPHMINPOSUW X2, X2              // c4e27941d2
	//TODO: VPHMINPOSUW X11, X2             // c4c27941d3
	//TODO: VPHMINPOSUW (BX), X11           // c46279411b
	//TODO: VPHMINPOSUW (R11), X11          // c44279411b
	//TODO: VPHMINPOSUW X2, X11             // c4627941da
	//TODO: VPHMINPOSUW X11, X11            // c4427941db
	//TODO: VPHSUBD (BX), X9, X2            // c4e2310613
	//TODO: VPHSUBD (R11), X9, X2           // c4c2310613
	//TODO: VPHSUBD X2, X9, X2              // c4e23106d2
	//TODO: VPHSUBD X11, X9, X2             // c4c23106d3
	//TODO: VPHSUBD (BX), X9, X11           // c46231061b
	//TODO: VPHSUBD (R11), X9, X11          // c44231061b
	//TODO: VPHSUBD X2, X9, X11             // c4623106da
	//TODO: VPHSUBD X11, X9, X11            // c4423106db
	//TODO: VPHSUBD (BX), Y15, Y2           // c4e2050613
	//TODO: VPHSUBD (R11), Y15, Y2          // c4c2050613
	//TODO: VPHSUBD Y2, Y15, Y2             // c4e20506d2
	//TODO: VPHSUBD Y11, Y15, Y2            // c4c20506d3
	//TODO: VPHSUBD (BX), Y15, Y11          // c46205061b
	//TODO: VPHSUBD (R11), Y15, Y11         // c44205061b
	//TODO: VPHSUBD Y2, Y15, Y11            // c4620506da
	//TODO: VPHSUBD Y11, Y15, Y11           // c4420506db
	//TODO: VPHSUBSW (BX), X9, X2           // c4e2310713
	//TODO: VPHSUBSW (R11), X9, X2          // c4c2310713
	//TODO: VPHSUBSW X2, X9, X2             // c4e23107d2
	//TODO: VPHSUBSW X11, X9, X2            // c4c23107d3
	//TODO: VPHSUBSW (BX), X9, X11          // c46231071b
	//TODO: VPHSUBSW (R11), X9, X11         // c44231071b
	//TODO: VPHSUBSW X2, X9, X11            // c4623107da
	//TODO: VPHSUBSW X11, X9, X11           // c4423107db
	//TODO: VPHSUBSW (BX), Y15, Y2          // c4e2050713
	//TODO: VPHSUBSW (R11), Y15, Y2         // c4c2050713
	//TODO: VPHSUBSW Y2, Y15, Y2            // c4e20507d2
	//TODO: VPHSUBSW Y11, Y15, Y2           // c4c20507d3
	//TODO: VPHSUBSW (BX), Y15, Y11         // c46205071b
	//TODO: VPHSUBSW (R11), Y15, Y11        // c44205071b
	//TODO: VPHSUBSW Y2, Y15, Y11           // c4620507da
	//TODO: VPHSUBSW Y11, Y15, Y11          // c4420507db
	//TODO: VPHSUBW (BX), X9, X2            // c4e2310513
	//TODO: VPHSUBW (R11), X9, X2           // c4c2310513
	//TODO: VPHSUBW X2, X9, X2              // c4e23105d2
	//TODO: VPHSUBW X11, X9, X2             // c4c23105d3
	//TODO: VPHSUBW (BX), X9, X11           // c46231051b
	//TODO: VPHSUBW (R11), X9, X11          // c44231051b
	//TODO: VPHSUBW X2, X9, X11             // c4623105da
	//TODO: VPHSUBW X11, X9, X11            // c4423105db
	//TODO: VPHSUBW (BX), Y15, Y2           // c4e2050513
	//TODO: VPHSUBW (R11), Y15, Y2          // c4c2050513
	//TODO: VPHSUBW Y2, Y15, Y2             // c4e20505d2
	//TODO: VPHSUBW Y11, Y15, Y2            // c4c20505d3
	//TODO: VPHSUBW (BX), Y15, Y11          // c46205051b
	//TODO: VPHSUBW (R11), Y15, Y11         // c44205051b
	//TODO: VPHSUBW Y2, Y15, Y11            // c4620505da
	//TODO: VPHSUBW Y11, Y15, Y11           // c4420505db
	//TODO: VPINSRB $7, (BX), X9, X2        // c4e331201307
	//TODO: VPINSRB $7, (R11), X9, X2       // c4c331201307
	//TODO: VPINSRB $7, DX, X9, X2          // c4e33120d207
	//TODO: VPINSRB $7, R11, X9, X2         // c4c33120d307
	//TODO: VPINSRB $7, (BX), X9, X11       // c46331201b07
	//TODO: VPINSRB $7, (R11), X9, X11      // c44331201b07
	//TODO: VPINSRB $7, DX, X9, X11         // c4633120da07
	//TODO: VPINSRB $7, R11, X9, X11        // c4433120db07
	//TODO: VPINSRD $7, (BX), X9, X2        // c4e331221307
	//TODO: VPINSRD $7, (R11), X9, X2       // c4c331221307
	//TODO: VPINSRD $7, DX, X9, X2          // c4e33122d207
	//TODO: VPINSRD $7, R11, X9, X2         // c4c33122d307
	//TODO: VPINSRD $7, (BX), X9, X11       // c46331221b07
	//TODO: VPINSRD $7, (R11), X9, X11      // c44331221b07
	//TODO: VPINSRD $7, DX, X9, X11         // c4633122da07
	//TODO: VPINSRD $7, R11, X9, X11        // c4433122db07
	//TODO: VPINSRQ $7, (BX), X9, X2        // c4e3b1221307
	//TODO: VPINSRQ $7, (R11), X9, X2       // c4c3b1221307
	//TODO: VPINSRQ $7, DX, X9, X2          // c4e3b122d207
	//TODO: VPINSRQ $7, R11, X9, X2         // c4c3b122d307
	//TODO: VPINSRQ $7, (BX), X9, X11       // c463b1221b07
	//TODO: VPINSRQ $7, (R11), X9, X11      // c443b1221b07
	//TODO: VPINSRQ $7, DX, X9, X11         // c463b122da07
	//TODO: VPINSRQ $7, R11, X9, X11        // c443b122db07
	//TODO: VPINSRW $7, (BX), X9, X2        // c4e131c41307 or c5b1c41307
	//TODO: VPINSRW $7, (R11), X9, X2       // c4c131c41307
	//TODO: VPINSRW $7, DX, X9, X2          // c4e131c4d207 or c5b1c4d207
	//TODO: VPINSRW $7, R11, X9, X2         // c4c131c4d307
	//TODO: VPINSRW $7, (BX), X9, X11       // c46131c41b07 or c531c41b07
	//TODO: VPINSRW $7, (R11), X9, X11      // c44131c41b07
	//TODO: VPINSRW $7, DX, X9, X11         // c46131c4da07 or c531c4da07
	//TODO: VPINSRW $7, R11, X9, X11        // c44131c4db07
	//TODO: VPMADDUBSW (BX), X9, X2         // c4e2310413
	//TODO: VPMADDUBSW (R11), X9, X2        // c4c2310413
	//TODO: VPMADDUBSW X2, X9, X2           // c4e23104d2
	//TODO: VPMADDUBSW X11, X9, X2          // c4c23104d3
	//TODO: VPMADDUBSW (BX), X9, X11        // c46231041b
	//TODO: VPMADDUBSW (R11), X9, X11       // c44231041b
	//TODO: VPMADDUBSW X2, X9, X11          // c4623104da
	//TODO: VPMADDUBSW X11, X9, X11         // c4423104db
	//TODO: VPMADDUBSW (BX), Y15, Y2        // c4e2050413
	//TODO: VPMADDUBSW (R11), Y15, Y2       // c4c2050413
	//TODO: VPMADDUBSW Y2, Y15, Y2          // c4e20504d2
	//TODO: VPMADDUBSW Y11, Y15, Y2         // c4c20504d3
	//TODO: VPMADDUBSW (BX), Y15, Y11       // c46205041b
	//TODO: VPMADDUBSW (R11), Y15, Y11      // c44205041b
	//TODO: VPMADDUBSW Y2, Y15, Y11         // c4620504da
	//TODO: VPMADDUBSW Y11, Y15, Y11        // c4420504db
	//TODO: VPMADDWD (BX), X9, X2           // c4e131f513 or c5b1f513
	//TODO: VPMADDWD (R11), X9, X2          // c4c131f513
	//TODO: VPMADDWD X2, X9, X2             // c4e131f5d2 or c5b1f5d2
	//TODO: VPMADDWD X11, X9, X2            // c4c131f5d3
	//TODO: VPMADDWD (BX), X9, X11          // c46131f51b or c531f51b
	//TODO: VPMADDWD (R11), X9, X11         // c44131f51b
	//TODO: VPMADDWD X2, X9, X11            // c46131f5da or c531f5da
	//TODO: VPMADDWD X11, X9, X11           // c44131f5db
	//TODO: VPMADDWD (BX), Y15, Y2          // c4e105f513 or c585f513
	//TODO: VPMADDWD (R11), Y15, Y2         // c4c105f513
	//TODO: VPMADDWD Y2, Y15, Y2            // c4e105f5d2 or c585f5d2
	//TODO: VPMADDWD Y11, Y15, Y2           // c4c105f5d3
	//TODO: VPMADDWD (BX), Y15, Y11         // c46105f51b or c505f51b
	//TODO: VPMADDWD (R11), Y15, Y11        // c44105f51b
	//TODO: VPMADDWD Y2, Y15, Y11           // c46105f5da or c505f5da
	//TODO: VPMADDWD Y11, Y15, Y11          // c44105f5db
	//TODO: VPMASKMOVD X2, X9, (BX)         // c4e2318e13
	//TODO: VPMASKMOVD X11, X9, (BX)        // c462318e1b
	//TODO: VPMASKMOVD X2, X9, (R11)        // c4c2318e13
	//TODO: VPMASKMOVD X11, X9, (R11)       // c442318e1b
	//TODO: VPMASKMOVD Y2, Y15, (BX)        // c4e2058e13
	//TODO: VPMASKMOVD Y11, Y15, (BX)       // c462058e1b
	//TODO: VPMASKMOVD Y2, Y15, (R11)       // c4c2058e13
	//TODO: VPMASKMOVD Y11, Y15, (R11)      // c442058e1b
	//TODO: VPMASKMOVD (BX), X9, X2         // c4e2318c13
	//TODO: VPMASKMOVD (R11), X9, X2        // c4c2318c13
	//TODO: VPMASKMOVD (BX), X9, X11        // c462318c1b
	//TODO: VPMASKMOVD (R11), X9, X11       // c442318c1b
	//TODO: VPMASKMOVD (BX), Y15, Y2        // c4e2058c13
	//TODO: VPMASKMOVD (R11), Y15, Y2       // c4c2058c13
	//TODO: VPMASKMOVD (BX), Y15, Y11       // c462058c1b
	//TODO: VPMASKMOVD (R11), Y15, Y11      // c442058c1b
	//TODO: VPMASKMOVQ X2, X9, (BX)         // c4e2b18e13
	//TODO: VPMASKMOVQ X11, X9, (BX)        // c462b18e1b
	//TODO: VPMASKMOVQ X2, X9, (R11)        // c4c2b18e13
	//TODO: VPMASKMOVQ X11, X9, (R11)       // c442b18e1b
	//TODO: VPMASKMOVQ Y2, Y15, (BX)        // c4e2858e13
	//TODO: VPMASKMOVQ Y11, Y15, (BX)       // c462858e1b
	//TODO: VPMASKMOVQ Y2, Y15, (R11)       // c4c2858e13
	//TODO: VPMASKMOVQ Y11, Y15, (R11)      // c442858e1b
	//TODO: VPMASKMOVQ (BX), X9, X2         // c4e2b18c13
	//TODO: VPMASKMOVQ (R11), X9, X2        // c4c2b18c13
	//TODO: VPMASKMOVQ (BX), X9, X11        // c462b18c1b
	//TODO: VPMASKMOVQ (R11), X9, X11       // c442b18c1b
	//TODO: VPMASKMOVQ (BX), Y15, Y2        // c4e2858c13
	//TODO: VPMASKMOVQ (R11), Y15, Y2       // c4c2858c13
	//TODO: VPMASKMOVQ (BX), Y15, Y11       // c462858c1b
	//TODO: VPMASKMOVQ (R11), Y15, Y11      // c442858c1b
	//TODO: VPMAXSB (BX), X9, X2            // c4e2313c13
	//TODO: VPMAXSB (R11), X9, X2           // c4c2313c13
	//TODO: VPMAXSB X2, X9, X2              // c4e2313cd2
	//TODO: VPMAXSB X11, X9, X2             // c4c2313cd3
	//TODO: VPMAXSB (BX), X9, X11           // c462313c1b
	//TODO: VPMAXSB (R11), X9, X11          // c442313c1b
	//TODO: VPMAXSB X2, X9, X11             // c462313cda
	//TODO: VPMAXSB X11, X9, X11            // c442313cdb
	//TODO: VPMAXSB (BX), Y15, Y2           // c4e2053c13
	//TODO: VPMAXSB (R11), Y15, Y2          // c4c2053c13
	//TODO: VPMAXSB Y2, Y15, Y2             // c4e2053cd2
	//TODO: VPMAXSB Y11, Y15, Y2            // c4c2053cd3
	//TODO: VPMAXSB (BX), Y15, Y11          // c462053c1b
	//TODO: VPMAXSB (R11), Y15, Y11         // c442053c1b
	//TODO: VPMAXSB Y2, Y15, Y11            // c462053cda
	//TODO: VPMAXSB Y11, Y15, Y11           // c442053cdb
	//TODO: VPMAXSD (BX), X9, X2            // c4e2313d13
	//TODO: VPMAXSD (R11), X9, X2           // c4c2313d13
	//TODO: VPMAXSD X2, X9, X2              // c4e2313dd2
	//TODO: VPMAXSD X11, X9, X2             // c4c2313dd3
	//TODO: VPMAXSD (BX), X9, X11           // c462313d1b
	//TODO: VPMAXSD (R11), X9, X11          // c442313d1b
	//TODO: VPMAXSD X2, X9, X11             // c462313dda
	//TODO: VPMAXSD X11, X9, X11            // c442313ddb
	//TODO: VPMAXSD (BX), Y15, Y2           // c4e2053d13
	//TODO: VPMAXSD (R11), Y15, Y2          // c4c2053d13
	//TODO: VPMAXSD Y2, Y15, Y2             // c4e2053dd2
	//TODO: VPMAXSD Y11, Y15, Y2            // c4c2053dd3
	//TODO: VPMAXSD (BX), Y15, Y11          // c462053d1b
	//TODO: VPMAXSD (R11), Y15, Y11         // c442053d1b
	//TODO: VPMAXSD Y2, Y15, Y11            // c462053dda
	//TODO: VPMAXSD Y11, Y15, Y11           // c442053ddb
	//TODO: VPMAXSW (BX), X9, X2            // c4e131ee13 or c5b1ee13
	//TODO: VPMAXSW (R11), X9, X2           // c4c131ee13
	//TODO: VPMAXSW X2, X9, X2              // c4e131eed2 or c5b1eed2
	//TODO: VPMAXSW X11, X9, X2             // c4c131eed3
	//TODO: VPMAXSW (BX), X9, X11           // c46131ee1b or c531ee1b
	//TODO: VPMAXSW (R11), X9, X11          // c44131ee1b
	//TODO: VPMAXSW X2, X9, X11             // c46131eeda or c531eeda
	//TODO: VPMAXSW X11, X9, X11            // c44131eedb
	//TODO: VPMAXSW (BX), Y15, Y2           // c4e105ee13 or c585ee13
	//TODO: VPMAXSW (R11), Y15, Y2          // c4c105ee13
	//TODO: VPMAXSW Y2, Y15, Y2             // c4e105eed2 or c585eed2
	//TODO: VPMAXSW Y11, Y15, Y2            // c4c105eed3
	//TODO: VPMAXSW (BX), Y15, Y11          // c46105ee1b or c505ee1b
	//TODO: VPMAXSW (R11), Y15, Y11         // c44105ee1b
	//TODO: VPMAXSW Y2, Y15, Y11            // c46105eeda or c505eeda
	//TODO: VPMAXSW Y11, Y15, Y11           // c44105eedb
	//TODO: VPMAXUB (BX), X9, X2            // c4e131de13 or c5b1de13
	//TODO: VPMAXUB (R11), X9, X2           // c4c131de13
	//TODO: VPMAXUB X2, X9, X2              // c4e131ded2 or c5b1ded2
	//TODO: VPMAXUB X11, X9, X2             // c4c131ded3
	//TODO: VPMAXUB (BX), X9, X11           // c46131de1b or c531de1b
	//TODO: VPMAXUB (R11), X9, X11          // c44131de1b
	//TODO: VPMAXUB X2, X9, X11             // c46131deda or c531deda
	//TODO: VPMAXUB X11, X9, X11            // c44131dedb
	//TODO: VPMAXUB (BX), Y15, Y2           // c4e105de13 or c585de13
	//TODO: VPMAXUB (R11), Y15, Y2          // c4c105de13
	//TODO: VPMAXUB Y2, Y15, Y2             // c4e105ded2 or c585ded2
	//TODO: VPMAXUB Y11, Y15, Y2            // c4c105ded3
	//TODO: VPMAXUB (BX), Y15, Y11          // c46105de1b or c505de1b
	//TODO: VPMAXUB (R11), Y15, Y11         // c44105de1b
	//TODO: VPMAXUB Y2, Y15, Y11            // c46105deda or c505deda
	//TODO: VPMAXUB Y11, Y15, Y11           // c44105dedb
	//TODO: VPMAXUD (BX), X9, X2            // c4e2313f13
	//TODO: VPMAXUD (R11), X9, X2           // c4c2313f13
	//TODO: VPMAXUD X2, X9, X2              // c4e2313fd2
	//TODO: VPMAXUD X11, X9, X2             // c4c2313fd3
	//TODO: VPMAXUD (BX), X9, X11           // c462313f1b
	//TODO: VPMAXUD (R11), X9, X11          // c442313f1b
	//TODO: VPMAXUD X2, X9, X11             // c462313fda
	//TODO: VPMAXUD X11, X9, X11            // c442313fdb
	//TODO: VPMAXUD (BX), Y15, Y2           // c4e2053f13
	//TODO: VPMAXUD (R11), Y15, Y2          // c4c2053f13
	//TODO: VPMAXUD Y2, Y15, Y2             // c4e2053fd2
	//TODO: VPMAXUD Y11, Y15, Y2            // c4c2053fd3
	//TODO: VPMAXUD (BX), Y15, Y11          // c462053f1b
	//TODO: VPMAXUD (R11), Y15, Y11         // c442053f1b
	//TODO: VPMAXUD Y2, Y15, Y11            // c462053fda
	//TODO: VPMAXUD Y11, Y15, Y11           // c442053fdb
	//TODO: VPMAXUW (BX), X9, X2            // c4e2313e13
	//TODO: VPMAXUW (R11), X9, X2           // c4c2313e13
	//TODO: VPMAXUW X2, X9, X2              // c4e2313ed2
	//TODO: VPMAXUW X11, X9, X2             // c4c2313ed3
	//TODO: VPMAXUW (BX), X9, X11           // c462313e1b
	//TODO: VPMAXUW (R11), X9, X11          // c442313e1b
	//TODO: VPMAXUW X2, X9, X11             // c462313eda
	//TODO: VPMAXUW X11, X9, X11            // c442313edb
	//TODO: VPMAXUW (BX), Y15, Y2           // c4e2053e13
	//TODO: VPMAXUW (R11), Y15, Y2          // c4c2053e13
	//TODO: VPMAXUW Y2, Y15, Y2             // c4e2053ed2
	//TODO: VPMAXUW Y11, Y15, Y2            // c4c2053ed3
	//TODO: VPMAXUW (BX), Y15, Y11          // c462053e1b
	//TODO: VPMAXUW (R11), Y15, Y11         // c442053e1b
	//TODO: VPMAXUW Y2, Y15, Y11            // c462053eda
	//TODO: VPMAXUW Y11, Y15, Y11           // c442053edb
	//TODO: VPMINSB (BX), X9, X2            // c4e2313813
	//TODO: VPMINSB (R11), X9, X2           // c4c2313813
	//TODO: VPMINSB X2, X9, X2              // c4e23138d2
	//TODO: VPMINSB X11, X9, X2             // c4c23138d3
	//TODO: VPMINSB (BX), X9, X11           // c46231381b
	//TODO: VPMINSB (R11), X9, X11          // c44231381b
	//TODO: VPMINSB X2, X9, X11             // c4623138da
	//TODO: VPMINSB X11, X9, X11            // c4423138db
	//TODO: VPMINSB (BX), Y15, Y2           // c4e2053813
	//TODO: VPMINSB (R11), Y15, Y2          // c4c2053813
	//TODO: VPMINSB Y2, Y15, Y2             // c4e20538d2
	//TODO: VPMINSB Y11, Y15, Y2            // c4c20538d3
	//TODO: VPMINSB (BX), Y15, Y11          // c46205381b
	//TODO: VPMINSB (R11), Y15, Y11         // c44205381b
	//TODO: VPMINSB Y2, Y15, Y11            // c4620538da
	//TODO: VPMINSB Y11, Y15, Y11           // c4420538db
	//TODO: VPMINSD (BX), X9, X2            // c4e2313913
	//TODO: VPMINSD (R11), X9, X2           // c4c2313913
	//TODO: VPMINSD X2, X9, X2              // c4e23139d2
	//TODO: VPMINSD X11, X9, X2             // c4c23139d3
	//TODO: VPMINSD (BX), X9, X11           // c46231391b
	//TODO: VPMINSD (R11), X9, X11          // c44231391b
	//TODO: VPMINSD X2, X9, X11             // c4623139da
	//TODO: VPMINSD X11, X9, X11            // c4423139db
	//TODO: VPMINSD (BX), Y15, Y2           // c4e2053913
	//TODO: VPMINSD (R11), Y15, Y2          // c4c2053913
	//TODO: VPMINSD Y2, Y15, Y2             // c4e20539d2
	//TODO: VPMINSD Y11, Y15, Y2            // c4c20539d3
	//TODO: VPMINSD (BX), Y15, Y11          // c46205391b
	//TODO: VPMINSD (R11), Y15, Y11         // c44205391b
	//TODO: VPMINSD Y2, Y15, Y11            // c4620539da
	//TODO: VPMINSD Y11, Y15, Y11           // c4420539db
	//TODO: VPMINSW (BX), X9, X2            // c4e131ea13 or c5b1ea13
	//TODO: VPMINSW (R11), X9, X2           // c4c131ea13
	//TODO: VPMINSW X2, X9, X2              // c4e131ead2 or c5b1ead2
	//TODO: VPMINSW X11, X9, X2             // c4c131ead3
	//TODO: VPMINSW (BX), X9, X11           // c46131ea1b or c531ea1b
	//TODO: VPMINSW (R11), X9, X11          // c44131ea1b
	//TODO: VPMINSW X2, X9, X11             // c46131eada or c531eada
	//TODO: VPMINSW X11, X9, X11            // c44131eadb
	//TODO: VPMINSW (BX), Y15, Y2           // c4e105ea13 or c585ea13
	//TODO: VPMINSW (R11), Y15, Y2          // c4c105ea13
	//TODO: VPMINSW Y2, Y15, Y2             // c4e105ead2 or c585ead2
	//TODO: VPMINSW Y11, Y15, Y2            // c4c105ead3
	//TODO: VPMINSW (BX), Y15, Y11          // c46105ea1b or c505ea1b
	//TODO: VPMINSW (R11), Y15, Y11         // c44105ea1b
	//TODO: VPMINSW Y2, Y15, Y11            // c46105eada or c505eada
	//TODO: VPMINSW Y11, Y15, Y11           // c44105eadb
	//TODO: VPMINUB (BX), X9, X2            // c4e131da13 or c5b1da13
	//TODO: VPMINUB (R11), X9, X2           // c4c131da13
	//TODO: VPMINUB X2, X9, X2              // c4e131dad2 or c5b1dad2
	//TODO: VPMINUB X11, X9, X2             // c4c131dad3
	//TODO: VPMINUB (BX), X9, X11           // c46131da1b or c531da1b
	//TODO: VPMINUB (R11), X9, X11          // c44131da1b
	//TODO: VPMINUB X2, X9, X11             // c46131dada or c531dada
	//TODO: VPMINUB X11, X9, X11            // c44131dadb
	//TODO: VPMINUB (BX), Y15, Y2           // c4e105da13 or c585da13
	//TODO: VPMINUB (R11), Y15, Y2          // c4c105da13
	//TODO: VPMINUB Y2, Y15, Y2             // c4e105dad2 or c585dad2
	//TODO: VPMINUB Y11, Y15, Y2            // c4c105dad3
	//TODO: VPMINUB (BX), Y15, Y11          // c46105da1b or c505da1b
	//TODO: VPMINUB (R11), Y15, Y11         // c44105da1b
	//TODO: VPMINUB Y2, Y15, Y11            // c46105dada or c505dada
	//TODO: VPMINUB Y11, Y15, Y11           // c44105dadb
	//TODO: VPMINUD (BX), X9, X2            // c4e2313b13
	//TODO: VPMINUD (R11), X9, X2           // c4c2313b13
	//TODO: VPMINUD X2, X9, X2              // c4e2313bd2
	//TODO: VPMINUD X11, X9, X2             // c4c2313bd3
	//TODO: VPMINUD (BX), X9, X11           // c462313b1b
	//TODO: VPMINUD (R11), X9, X11          // c442313b1b
	//TODO: VPMINUD X2, X9, X11             // c462313bda
	//TODO: VPMINUD X11, X9, X11            // c442313bdb
	//TODO: VPMINUD (BX), Y15, Y2           // c4e2053b13
	//TODO: VPMINUD (R11), Y15, Y2          // c4c2053b13
	//TODO: VPMINUD Y2, Y15, Y2             // c4e2053bd2
	//TODO: VPMINUD Y11, Y15, Y2            // c4c2053bd3
	//TODO: VPMINUD (BX), Y15, Y11          // c462053b1b
	//TODO: VPMINUD (R11), Y15, Y11         // c442053b1b
	//TODO: VPMINUD Y2, Y15, Y11            // c462053bda
	//TODO: VPMINUD Y11, Y15, Y11           // c442053bdb
	//TODO: VPMINUW (BX), X9, X2            // c4e2313a13
	//TODO: VPMINUW (R11), X9, X2           // c4c2313a13
	//TODO: VPMINUW X2, X9, X2              // c4e2313ad2
	//TODO: VPMINUW X11, X9, X2             // c4c2313ad3
	//TODO: VPMINUW (BX), X9, X11           // c462313a1b
	//TODO: VPMINUW (R11), X9, X11          // c442313a1b
	//TODO: VPMINUW X2, X9, X11             // c462313ada
	//TODO: VPMINUW X11, X9, X11            // c442313adb
	//TODO: VPMINUW (BX), Y15, Y2           // c4e2053a13
	//TODO: VPMINUW (R11), Y15, Y2          // c4c2053a13
	//TODO: VPMINUW Y2, Y15, Y2             // c4e2053ad2
	//TODO: VPMINUW Y11, Y15, Y2            // c4c2053ad3
	//TODO: VPMINUW (BX), Y15, Y11          // c462053a1b
	//TODO: VPMINUW (R11), Y15, Y11         // c442053a1b
	//TODO: VPMINUW Y2, Y15, Y11            // c462053ada
	//TODO: VPMINUW Y11, Y15, Y11           // c442053adb
	VPMOVMSKB X2, DX                        // c4e179d7d2 or c5f9d7d2
	VPMOVMSKB X11, DX                       // c4c179d7d3
	VPMOVMSKB X2, R11                       // c46179d7da or c579d7da
	VPMOVMSKB X11, R11                      // c44179d7db
	VPMOVMSKB Y2, DX                        // c4e17dd7d2 or c5fdd7d2
	VPMOVMSKB Y11, DX                       // c4c17dd7d3
	VPMOVMSKB Y2, R11                       // c4617dd7da or c57dd7da
	VPMOVMSKB Y11, R11                      // c4417dd7db
	//TODO: VPMOVSXBD (BX), X2              // c4e2792113
	//TODO: VPMOVSXBD (R11), X2             // c4c2792113
	//TODO: VPMOVSXBD X2, X2                // c4e27921d2
	//TODO: VPMOVSXBD X11, X2               // c4c27921d3
	//TODO: VPMOVSXBD (BX), X11             // c46279211b
	//TODO: VPMOVSXBD (R11), X11            // c44279211b
	//TODO: VPMOVSXBD X2, X11               // c4627921da
	//TODO: VPMOVSXBD X11, X11              // c4427921db
	//TODO: VPMOVSXBD (BX), Y2              // c4e27d2113
	//TODO: VPMOVSXBD (R11), Y2             // c4c27d2113
	//TODO: VPMOVSXBD X2, Y2                // c4e27d21d2
	//TODO: VPMOVSXBD X11, Y2               // c4c27d21d3
	//TODO: VPMOVSXBD (BX), Y11             // c4627d211b
	//TODO: VPMOVSXBD (R11), Y11            // c4427d211b
	//TODO: VPMOVSXBD X2, Y11               // c4627d21da
	//TODO: VPMOVSXBD X11, Y11              // c4427d21db
	//TODO: VPMOVSXBQ (BX), X2              // c4e2792213
	//TODO: VPMOVSXBQ (R11), X2             // c4c2792213
	//TODO: VPMOVSXBQ X2, X2                // c4e27922d2
	//TODO: VPMOVSXBQ X11, X2               // c4c27922d3
	//TODO: VPMOVSXBQ (BX), X11             // c46279221b
	//TODO: VPMOVSXBQ (R11), X11            // c44279221b
	//TODO: VPMOVSXBQ X2, X11               // c4627922da
	//TODO: VPMOVSXBQ X11, X11              // c4427922db
	//TODO: VPMOVSXBQ (BX), Y2              // c4e27d2213
	//TODO: VPMOVSXBQ (R11), Y2             // c4c27d2213
	//TODO: VPMOVSXBQ X2, Y2                // c4e27d22d2
	//TODO: VPMOVSXBQ X11, Y2               // c4c27d22d3
	//TODO: VPMOVSXBQ (BX), Y11             // c4627d221b
	//TODO: VPMOVSXBQ (R11), Y11            // c4427d221b
	//TODO: VPMOVSXBQ X2, Y11               // c4627d22da
	//TODO: VPMOVSXBQ X11, Y11              // c4427d22db
	//TODO: VPMOVSXBW (BX), X2              // c4e2792013
	//TODO: VPMOVSXBW (R11), X2             // c4c2792013
	//TODO: VPMOVSXBW X2, X2                // c4e27920d2
	//TODO: VPMOVSXBW X11, X2               // c4c27920d3
	//TODO: VPMOVSXBW (BX), X11             // c46279201b
	//TODO: VPMOVSXBW (R11), X11            // c44279201b
	//TODO: VPMOVSXBW X2, X11               // c4627920da
	//TODO: VPMOVSXBW X11, X11              // c4427920db
	//TODO: VPMOVSXBW (BX), Y2              // c4e27d2013
	//TODO: VPMOVSXBW (R11), Y2             // c4c27d2013
	//TODO: VPMOVSXBW X2, Y2                // c4e27d20d2
	//TODO: VPMOVSXBW X11, Y2               // c4c27d20d3
	//TODO: VPMOVSXBW (BX), Y11             // c4627d201b
	//TODO: VPMOVSXBW (R11), Y11            // c4427d201b
	//TODO: VPMOVSXBW X2, Y11               // c4627d20da
	//TODO: VPMOVSXBW X11, Y11              // c4427d20db
	//TODO: VPMOVSXDQ (BX), X2              // c4e2792513
	//TODO: VPMOVSXDQ (R11), X2             // c4c2792513
	//TODO: VPMOVSXDQ X2, X2                // c4e27925d2
	//TODO: VPMOVSXDQ X11, X2               // c4c27925d3
	//TODO: VPMOVSXDQ (BX), X11             // c46279251b
	//TODO: VPMOVSXDQ (R11), X11            // c44279251b
	//TODO: VPMOVSXDQ X2, X11               // c4627925da
	//TODO: VPMOVSXDQ X11, X11              // c4427925db
	//TODO: VPMOVSXDQ (BX), Y2              // c4e27d2513
	//TODO: VPMOVSXDQ (R11), Y2             // c4c27d2513
	//TODO: VPMOVSXDQ X2, Y2                // c4e27d25d2
	//TODO: VPMOVSXDQ X11, Y2               // c4c27d25d3
	//TODO: VPMOVSXDQ (BX), Y11             // c4627d251b
	//TODO: VPMOVSXDQ (R11), Y11            // c4427d251b
	//TODO: VPMOVSXDQ X2, Y11               // c4627d25da
	//TODO: VPMOVSXDQ X11, Y11              // c4427d25db
	//TODO: VPMOVSXWD (BX), X2              // c4e2792313
	//TODO: VPMOVSXWD (R11), X2             // c4c2792313
	//TODO: VPMOVSXWD X2, X2                // c4e27923d2
	//TODO: VPMOVSXWD X11, X2               // c4c27923d3
	//TODO: VPMOVSXWD (BX), X11             // c46279231b
	//TODO: VPMOVSXWD (R11), X11            // c44279231b
	//TODO: VPMOVSXWD X2, X11               // c4627923da
	//TODO: VPMOVSXWD X11, X11              // c4427923db
	//TODO: VPMOVSXWD (BX), Y2              // c4e27d2313
	//TODO: VPMOVSXWD (R11), Y2             // c4c27d2313
	//TODO: VPMOVSXWD X2, Y2                // c4e27d23d2
	//TODO: VPMOVSXWD X11, Y2               // c4c27d23d3
	//TODO: VPMOVSXWD (BX), Y11             // c4627d231b
	//TODO: VPMOVSXWD (R11), Y11            // c4427d231b
	//TODO: VPMOVSXWD X2, Y11               // c4627d23da
	//TODO: VPMOVSXWD X11, Y11              // c4427d23db
	//TODO: VPMOVSXWQ (BX), X2              // c4e2792413
	//TODO: VPMOVSXWQ (R11), X2             // c4c2792413
	//TODO: VPMOVSXWQ X2, X2                // c4e27924d2
	//TODO: VPMOVSXWQ X11, X2               // c4c27924d3
	//TODO: VPMOVSXWQ (BX), X11             // c46279241b
	//TODO: VPMOVSXWQ (R11), X11            // c44279241b
	//TODO: VPMOVSXWQ X2, X11               // c4627924da
	//TODO: VPMOVSXWQ X11, X11              // c4427924db
	//TODO: VPMOVSXWQ (BX), Y2              // c4e27d2413
	//TODO: VPMOVSXWQ (R11), Y2             // c4c27d2413
	//TODO: VPMOVSXWQ X2, Y2                // c4e27d24d2
	//TODO: VPMOVSXWQ X11, Y2               // c4c27d24d3
	//TODO: VPMOVSXWQ (BX), Y11             // c4627d241b
	//TODO: VPMOVSXWQ (R11), Y11            // c4427d241b
	//TODO: VPMOVSXWQ X2, Y11               // c4627d24da
	//TODO: VPMOVSXWQ X11, Y11              // c4427d24db
	//TODO: VPMOVZXBD (BX), X2              // c4e2793113
	//TODO: VPMOVZXBD (R11), X2             // c4c2793113
	//TODO: VPMOVZXBD X2, X2                // c4e27931d2
	//TODO: VPMOVZXBD X11, X2               // c4c27931d3
	//TODO: VPMOVZXBD (BX), X11             // c46279311b
	//TODO: VPMOVZXBD (R11), X11            // c44279311b
	//TODO: VPMOVZXBD X2, X11               // c4627931da
	//TODO: VPMOVZXBD X11, X11              // c4427931db
	//TODO: VPMOVZXBD (BX), Y2              // c4e27d3113
	//TODO: VPMOVZXBD (R11), Y2             // c4c27d3113
	//TODO: VPMOVZXBD X2, Y2                // c4e27d31d2
	//TODO: VPMOVZXBD X11, Y2               // c4c27d31d3
	//TODO: VPMOVZXBD (BX), Y11             // c4627d311b
	//TODO: VPMOVZXBD (R11), Y11            // c4427d311b
	//TODO: VPMOVZXBD X2, Y11               // c4627d31da
	//TODO: VPMOVZXBD X11, Y11              // c4427d31db
	//TODO: VPMOVZXBQ (BX), X2              // c4e2793213
	//TODO: VPMOVZXBQ (R11), X2             // c4c2793213
	//TODO: VPMOVZXBQ X2, X2                // c4e27932d2
	//TODO: VPMOVZXBQ X11, X2               // c4c27932d3
	//TODO: VPMOVZXBQ (BX), X11             // c46279321b
	//TODO: VPMOVZXBQ (R11), X11            // c44279321b
	//TODO: VPMOVZXBQ X2, X11               // c4627932da
	//TODO: VPMOVZXBQ X11, X11              // c4427932db
	//TODO: VPMOVZXBQ (BX), Y2              // c4e27d3213
	//TODO: VPMOVZXBQ (R11), Y2             // c4c27d3213
	//TODO: VPMOVZXBQ X2, Y2                // c4e27d32d2
	//TODO: VPMOVZXBQ X11, Y2               // c4c27d32d3
	//TODO: VPMOVZXBQ (BX), Y11             // c4627d321b
	//TODO: VPMOVZXBQ (R11), Y11            // c4427d321b
	//TODO: VPMOVZXBQ X2, Y11               // c4627d32da
	//TODO: VPMOVZXBQ X11, Y11              // c4427d32db
	//TODO: VPMOVZXBW (BX), X2              // c4e2793013
	//TODO: VPMOVZXBW (R11), X2             // c4c2793013
	//TODO: VPMOVZXBW X2, X2                // c4e27930d2
	//TODO: VPMOVZXBW X11, X2               // c4c27930d3
	//TODO: VPMOVZXBW (BX), X11             // c46279301b
	//TODO: VPMOVZXBW (R11), X11            // c44279301b
	//TODO: VPMOVZXBW X2, X11               // c4627930da
	//TODO: VPMOVZXBW X11, X11              // c4427930db
	//TODO: VPMOVZXBW (BX), Y2              // c4e27d3013
	//TODO: VPMOVZXBW (R11), Y2             // c4c27d3013
	//TODO: VPMOVZXBW X2, Y2                // c4e27d30d2
	//TODO: VPMOVZXBW X11, Y2               // c4c27d30d3
	//TODO: VPMOVZXBW (BX), Y11             // c4627d301b
	//TODO: VPMOVZXBW (R11), Y11            // c4427d301b
	//TODO: VPMOVZXBW X2, Y11               // c4627d30da
	//TODO: VPMOVZXBW X11, Y11              // c4427d30db
	//TODO: VPMOVZXDQ (BX), X2              // c4e2793513
	//TODO: VPMOVZXDQ (R11), X2             // c4c2793513
	//TODO: VPMOVZXDQ X2, X2                // c4e27935d2
	//TODO: VPMOVZXDQ X11, X2               // c4c27935d3
	//TODO: VPMOVZXDQ (BX), X11             // c46279351b
	//TODO: VPMOVZXDQ (R11), X11            // c44279351b
	//TODO: VPMOVZXDQ X2, X11               // c4627935da
	//TODO: VPMOVZXDQ X11, X11              // c4427935db
	//TODO: VPMOVZXDQ (BX), Y2              // c4e27d3513
	//TODO: VPMOVZXDQ (R11), Y2             // c4c27d3513
	//TODO: VPMOVZXDQ X2, Y2                // c4e27d35d2
	//TODO: VPMOVZXDQ X11, Y2               // c4c27d35d3
	//TODO: VPMOVZXDQ (BX), Y11             // c4627d351b
	//TODO: VPMOVZXDQ (R11), Y11            // c4427d351b
	//TODO: VPMOVZXDQ X2, Y11               // c4627d35da
	//TODO: VPMOVZXDQ X11, Y11              // c4427d35db
	//TODO: VPMOVZXWD (BX), X2              // c4e2793313
	//TODO: VPMOVZXWD (R11), X2             // c4c2793313
	//TODO: VPMOVZXWD X2, X2                // c4e27933d2
	//TODO: VPMOVZXWD X11, X2               // c4c27933d3
	//TODO: VPMOVZXWD (BX), X11             // c46279331b
	//TODO: VPMOVZXWD (R11), X11            // c44279331b
	//TODO: VPMOVZXWD X2, X11               // c4627933da
	//TODO: VPMOVZXWD X11, X11              // c4427933db
	//TODO: VPMOVZXWD (BX), Y2              // c4e27d3313
	//TODO: VPMOVZXWD (R11), Y2             // c4c27d3313
	//TODO: VPMOVZXWD X2, Y2                // c4e27d33d2
	//TODO: VPMOVZXWD X11, Y2               // c4c27d33d3
	//TODO: VPMOVZXWD (BX), Y11             // c4627d331b
	//TODO: VPMOVZXWD (R11), Y11            // c4427d331b
	//TODO: VPMOVZXWD X2, Y11               // c4627d33da
	//TODO: VPMOVZXWD X11, Y11              // c4427d33db
	//TODO: VPMOVZXWQ (BX), X2              // c4e2793413
	//TODO: VPMOVZXWQ (R11), X2             // c4c2793413
	//TODO: VPMOVZXWQ X2, X2                // c4e27934d2
	//TODO: VPMOVZXWQ X11, X2               // c4c27934d3
	//TODO: VPMOVZXWQ (BX), X11             // c46279341b
	//TODO: VPMOVZXWQ (R11), X11            // c44279341b
	//TODO: VPMOVZXWQ X2, X11               // c4627934da
	//TODO: VPMOVZXWQ X11, X11              // c4427934db
	//TODO: VPMOVZXWQ (BX), Y2              // c4e27d3413
	//TODO: VPMOVZXWQ (R11), Y2             // c4c27d3413
	//TODO: VPMOVZXWQ X2, Y2                // c4e27d34d2
	//TODO: VPMOVZXWQ X11, Y2               // c4c27d34d3
	//TODO: VPMOVZXWQ (BX), Y11             // c4627d341b
	//TODO: VPMOVZXWQ (R11), Y11            // c4427d341b
	//TODO: VPMOVZXWQ X2, Y11               // c4627d34da
	//TODO: VPMOVZXWQ X11, Y11              // c4427d34db
	//TODO: VPMULDQ (BX), X9, X2            // c4e2312813
	//TODO: VPMULDQ (R11), X9, X2           // c4c2312813
	//TODO: VPMULDQ X2, X9, X2              // c4e23128d2
	//TODO: VPMULDQ X11, X9, X2             // c4c23128d3
	//TODO: VPMULDQ (BX), X9, X11           // c46231281b
	//TODO: VPMULDQ (R11), X9, X11          // c44231281b
	//TODO: VPMULDQ X2, X9, X11             // c4623128da
	//TODO: VPMULDQ X11, X9, X11            // c4423128db
	//TODO: VPMULDQ (BX), Y15, Y2           // c4e2052813
	//TODO: VPMULDQ (R11), Y15, Y2          // c4c2052813
	//TODO: VPMULDQ Y2, Y15, Y2             // c4e20528d2
	//TODO: VPMULDQ Y11, Y15, Y2            // c4c20528d3
	//TODO: VPMULDQ (BX), Y15, Y11          // c46205281b
	//TODO: VPMULDQ (R11), Y15, Y11         // c44205281b
	//TODO: VPMULDQ Y2, Y15, Y11            // c4620528da
	//TODO: VPMULDQ Y11, Y15, Y11           // c4420528db
	//TODO: VPMULHRSW (BX), X9, X2          // c4e2310b13
	//TODO: VPMULHRSW (R11), X9, X2         // c4c2310b13
	//TODO: VPMULHRSW X2, X9, X2            // c4e2310bd2
	//TODO: VPMULHRSW X11, X9, X2           // c4c2310bd3
	//TODO: VPMULHRSW (BX), X9, X11         // c462310b1b
	//TODO: VPMULHRSW (R11), X9, X11        // c442310b1b
	//TODO: VPMULHRSW X2, X9, X11           // c462310bda
	//TODO: VPMULHRSW X11, X9, X11          // c442310bdb
	//TODO: VPMULHRSW (BX), Y15, Y2         // c4e2050b13
	//TODO: VPMULHRSW (R11), Y15, Y2        // c4c2050b13
	//TODO: VPMULHRSW Y2, Y15, Y2           // c4e2050bd2
	//TODO: VPMULHRSW Y11, Y15, Y2          // c4c2050bd3
	//TODO: VPMULHRSW (BX), Y15, Y11        // c462050b1b
	//TODO: VPMULHRSW (R11), Y15, Y11       // c442050b1b
	//TODO: VPMULHRSW Y2, Y15, Y11          // c462050bda
	//TODO: VPMULHRSW Y11, Y15, Y11         // c442050bdb
	//TODO: VPMULHUW (BX), X9, X2           // c4e131e413 or c5b1e413
	//TODO: VPMULHUW (R11), X9, X2          // c4c131e413
	//TODO: VPMULHUW X2, X9, X2             // c4e131e4d2 or c5b1e4d2
	//TODO: VPMULHUW X11, X9, X2            // c4c131e4d3
	//TODO: VPMULHUW (BX), X9, X11          // c46131e41b or c531e41b
	//TODO: VPMULHUW (R11), X9, X11         // c44131e41b
	//TODO: VPMULHUW X2, X9, X11            // c46131e4da or c531e4da
	//TODO: VPMULHUW X11, X9, X11           // c44131e4db
	//TODO: VPMULHUW (BX), Y15, Y2          // c4e105e413 or c585e413
	//TODO: VPMULHUW (R11), Y15, Y2         // c4c105e413
	//TODO: VPMULHUW Y2, Y15, Y2            // c4e105e4d2 or c585e4d2
	//TODO: VPMULHUW Y11, Y15, Y2           // c4c105e4d3
	//TODO: VPMULHUW (BX), Y15, Y11         // c46105e41b or c505e41b
	//TODO: VPMULHUW (R11), Y15, Y11        // c44105e41b
	//TODO: VPMULHUW Y2, Y15, Y11           // c46105e4da or c505e4da
	//TODO: VPMULHUW Y11, Y15, Y11          // c44105e4db
	//TODO: VPMULHW (BX), X9, X2            // c4e131e513 or c5b1e513
	//TODO: VPMULHW (R11), X9, X2           // c4c131e513
	//TODO: VPMULHW X2, X9, X2              // c4e131e5d2 or c5b1e5d2
	//TODO: VPMULHW X11, X9, X2             // c4c131e5d3
	//TODO: VPMULHW (BX), X9, X11           // c46131e51b or c531e51b
	//TODO: VPMULHW (R11), X9, X11          // c44131e51b
	//TODO: VPMULHW X2, X9, X11             // c46131e5da or c531e5da
	//TODO: VPMULHW X11, X9, X11            // c44131e5db
	//TODO: VPMULHW (BX), Y15, Y2           // c4e105e513 or c585e513
	//TODO: VPMULHW (R11), Y15, Y2          // c4c105e513
	//TODO: VPMULHW Y2, Y15, Y2             // c4e105e5d2 or c585e5d2
	//TODO: VPMULHW Y11, Y15, Y2            // c4c105e5d3
	//TODO: VPMULHW (BX), Y15, Y11          // c46105e51b or c505e51b
	//TODO: VPMULHW (R11), Y15, Y11         // c44105e51b
	//TODO: VPMULHW Y2, Y15, Y11            // c46105e5da or c505e5da
	//TODO: VPMULHW Y11, Y15, Y11           // c44105e5db
	//TODO: VPMULLD (BX), X9, X2            // c4e2314013
	//TODO: VPMULLD (R11), X9, X2           // c4c2314013
	//TODO: VPMULLD X2, X9, X2              // c4e23140d2
	//TODO: VPMULLD X11, X9, X2             // c4c23140d3
	//TODO: VPMULLD (BX), X9, X11           // c46231401b
	//TODO: VPMULLD (R11), X9, X11          // c44231401b
	//TODO: VPMULLD X2, X9, X11             // c4623140da
	//TODO: VPMULLD X11, X9, X11            // c4423140db
	//TODO: VPMULLD (BX), Y15, Y2           // c4e2054013
	//TODO: VPMULLD (R11), Y15, Y2          // c4c2054013
	//TODO: VPMULLD Y2, Y15, Y2             // c4e20540d2
	//TODO: VPMULLD Y11, Y15, Y2            // c4c20540d3
	//TODO: VPMULLD (BX), Y15, Y11          // c46205401b
	//TODO: VPMULLD (R11), Y15, Y11         // c44205401b
	//TODO: VPMULLD Y2, Y15, Y11            // c4620540da
	//TODO: VPMULLD Y11, Y15, Y11           // c4420540db
	//TODO: VPMULLW (BX), X9, X2            // c4e131d513 or c5b1d513
	//TODO: VPMULLW (R11), X9, X2           // c4c131d513
	//TODO: VPMULLW X2, X9, X2              // c4e131d5d2 or c5b1d5d2
	//TODO: VPMULLW X11, X9, X2             // c4c131d5d3
	//TODO: VPMULLW (BX), X9, X11           // c46131d51b or c531d51b
	//TODO: VPMULLW (R11), X9, X11          // c44131d51b
	//TODO: VPMULLW X2, X9, X11             // c46131d5da or c531d5da
	//TODO: VPMULLW X11, X9, X11            // c44131d5db
	//TODO: VPMULLW (BX), Y15, Y2           // c4e105d513 or c585d513
	//TODO: VPMULLW (R11), Y15, Y2          // c4c105d513
	//TODO: VPMULLW Y2, Y15, Y2             // c4e105d5d2 or c585d5d2
	//TODO: VPMULLW Y11, Y15, Y2            // c4c105d5d3
	//TODO: VPMULLW (BX), Y15, Y11          // c46105d51b or c505d51b
	//TODO: VPMULLW (R11), Y15, Y11         // c44105d51b
	//TODO: VPMULLW Y2, Y15, Y11            // c46105d5da or c505d5da
	//TODO: VPMULLW Y11, Y15, Y11           // c44105d5db
	//TODO: VPMULUDQ (BX), X9, X2           // c4e131f413 or c5b1f413
	//TODO: VPMULUDQ (R11), X9, X2          // c4c131f413
	//TODO: VPMULUDQ X2, X9, X2             // c4e131f4d2 or c5b1f4d2
	//TODO: VPMULUDQ X11, X9, X2            // c4c131f4d3
	//TODO: VPMULUDQ (BX), X9, X11          // c46131f41b or c531f41b
	//TODO: VPMULUDQ (R11), X9, X11         // c44131f41b
	//TODO: VPMULUDQ X2, X9, X11            // c46131f4da or c531f4da
	//TODO: VPMULUDQ X11, X9, X11           // c44131f4db
	//TODO: VPMULUDQ (BX), Y15, Y2          // c4e105f413 or c585f413
	//TODO: VPMULUDQ (R11), Y15, Y2         // c4c105f413
	//TODO: VPMULUDQ Y2, Y15, Y2            // c4e105f4d2 or c585f4d2
	//TODO: VPMULUDQ Y11, Y15, Y2           // c4c105f4d3
	//TODO: VPMULUDQ (BX), Y15, Y11         // c46105f41b or c505f41b
	//TODO: VPMULUDQ (R11), Y15, Y11        // c44105f41b
	//TODO: VPMULUDQ Y2, Y15, Y11           // c46105f4da or c505f4da
	//TODO: VPMULUDQ Y11, Y15, Y11          // c44105f4db
	//TODO: VPOR (BX), X9, X2               // c4e131eb13 or c5b1eb13
	//TODO: VPOR (R11), X9, X2              // c4c131eb13
	//TODO: VPOR X2, X9, X2                 // c4e131ebd2 or c5b1ebd2
	//TODO: VPOR X11, X9, X2                // c4c131ebd3
	//TODO: VPOR (BX), X9, X11              // c46131eb1b or c531eb1b
	//TODO: VPOR (R11), X9, X11             // c44131eb1b
	//TODO: VPOR X2, X9, X11                // c46131ebda or c531ebda
	//TODO: VPOR X11, X9, X11               // c44131ebdb
	//TODO: VPOR (BX), Y15, Y2              // c4e105eb13 or c585eb13
	//TODO: VPOR (R11), Y15, Y2             // c4c105eb13
	//TODO: VPOR Y2, Y15, Y2                // c4e105ebd2 or c585ebd2
	//TODO: VPOR Y11, Y15, Y2               // c4c105ebd3
	//TODO: VPOR (BX), Y15, Y11             // c46105eb1b or c505eb1b
	//TODO: VPOR (R11), Y15, Y11            // c44105eb1b
	//TODO: VPOR Y2, Y15, Y11               // c46105ebda or c505ebda
	//TODO: VPOR Y11, Y15, Y11              // c44105ebdb
	//TODO: VPSADBW (BX), X9, X2            // c4e131f613 or c5b1f613
	//TODO: VPSADBW (R11), X9, X2           // c4c131f613
	//TODO: VPSADBW X2, X9, X2              // c4e131f6d2 or c5b1f6d2
	//TODO: VPSADBW X11, X9, X2             // c4c131f6d3
	//TODO: VPSADBW (BX), X9, X11           // c46131f61b or c531f61b
	//TODO: VPSADBW (R11), X9, X11          // c44131f61b
	//TODO: VPSADBW X2, X9, X11             // c46131f6da or c531f6da
	//TODO: VPSADBW X11, X9, X11            // c44131f6db
	//TODO: VPSADBW (BX), Y15, Y2           // c4e105f613 or c585f613
	//TODO: VPSADBW (R11), Y15, Y2          // c4c105f613
	//TODO: VPSADBW Y2, Y15, Y2             // c4e105f6d2 or c585f6d2
	//TODO: VPSADBW Y11, Y15, Y2            // c4c105f6d3
	//TODO: VPSADBW (BX), Y15, Y11          // c46105f61b or c505f61b
	//TODO: VPSADBW (R11), Y15, Y11         // c44105f61b
	//TODO: VPSADBW Y2, Y15, Y11            // c46105f6da or c505f6da
	//TODO: VPSADBW Y11, Y15, Y11           // c44105f6db
	//TODO: VPSHUFB (BX), X9, X2            // c4e2310013
	//TODO: VPSHUFB (R11), X9, X2           // c4c2310013
	//TODO: VPSHUFB X2, X9, X2              // c4e23100d2
	//TODO: VPSHUFB X11, X9, X2             // c4c23100d3
	//TODO: VPSHUFB (BX), X9, X11           // c46231001b
	//TODO: VPSHUFB (R11), X9, X11          // c44231001b
	//TODO: VPSHUFB X2, X9, X11             // c4623100da
	//TODO: VPSHUFB X11, X9, X11            // c4423100db
	//TODO: VPSHUFB (BX), Y15, Y2           // c4e2050013
	//TODO: VPSHUFB (R11), Y15, Y2          // c4c2050013
	//TODO: VPSHUFB Y2, Y15, Y2             // c4e20500d2
	//TODO: VPSHUFB Y11, Y15, Y2            // c4c20500d3
	//TODO: VPSHUFB (BX), Y15, Y11          // c46205001b
	//TODO: VPSHUFB (R11), Y15, Y11         // c44205001b
	//TODO: VPSHUFB Y2, Y15, Y11            // c4620500da
	//TODO: VPSHUFB Y11, Y15, Y11           // c4420500db
	//TODO: VPSHUFD $7, (BX), X2            // c4e179701307 or c5f9701307
	//TODO: VPSHUFD $7, (R11), X2           // c4c179701307
	//TODO: VPSHUFD $7, X2, X2              // c4e17970d207 or c5f970d207
	//TODO: VPSHUFD $7, X11, X2             // c4c17970d307
	//TODO: VPSHUFD $7, (BX), X11           // c46179701b07 or c579701b07
	//TODO: VPSHUFD $7, (R11), X11          // c44179701b07
	//TODO: VPSHUFD $7, X2, X11             // c4617970da07 or c57970da07
	//TODO: VPSHUFD $7, X11, X11            // c4417970db07
	//TODO: VPSHUFD $7, (BX), Y2            // c4e17d701307 or c5fd701307
	//TODO: VPSHUFD $7, (R11), Y2           // c4c17d701307
	//TODO: VPSHUFD $7, Y2, Y2              // c4e17d70d207 or c5fd70d207
	//TODO: VPSHUFD $7, Y11, Y2             // c4c17d70d307
	//TODO: VPSHUFD $7, (BX), Y11           // c4617d701b07 or c57d701b07
	//TODO: VPSHUFD $7, (R11), Y11          // c4417d701b07
	//TODO: VPSHUFD $7, Y2, Y11             // c4617d70da07 or c57d70da07
	//TODO: VPSHUFD $7, Y11, Y11            // c4417d70db07
	//TODO: VPSHUFHW $7, (BX), X2           // c4e17a701307 or c5fa701307
	//TODO: VPSHUFHW $7, (R11), X2          // c4c17a701307
	//TODO: VPSHUFHW $7, X2, X2             // c4e17a70d207 or c5fa70d207
	//TODO: VPSHUFHW $7, X11, X2            // c4c17a70d307
	//TODO: VPSHUFHW $7, (BX), X11          // c4617a701b07 or c57a701b07
	//TODO: VPSHUFHW $7, (R11), X11         // c4417a701b07
	//TODO: VPSHUFHW $7, X2, X11            // c4617a70da07 or c57a70da07
	//TODO: VPSHUFHW $7, X11, X11           // c4417a70db07
	//TODO: VPSHUFHW $7, (BX), Y2           // c4e17e701307 or c5fe701307
	//TODO: VPSHUFHW $7, (R11), Y2          // c4c17e701307
	//TODO: VPSHUFHW $7, Y2, Y2             // c4e17e70d207 or c5fe70d207
	//TODO: VPSHUFHW $7, Y11, Y2            // c4c17e70d307
	//TODO: VPSHUFHW $7, (BX), Y11          // c4617e701b07 or c57e701b07
	//TODO: VPSHUFHW $7, (R11), Y11         // c4417e701b07
	//TODO: VPSHUFHW $7, Y2, Y11            // c4617e70da07 or c57e70da07
	//TODO: VPSHUFHW $7, Y11, Y11           // c4417e70db07
	//TODO: VPSHUFLW $7, (BX), X2           // c4e17b701307 or c5fb701307
	//TODO: VPSHUFLW $7, (R11), X2          // c4c17b701307
	//TODO: VPSHUFLW $7, X2, X2             // c4e17b70d207 or c5fb70d207
	//TODO: VPSHUFLW $7, X11, X2            // c4c17b70d307
	//TODO: VPSHUFLW $7, (BX), X11          // c4617b701b07 or c57b701b07
	//TODO: VPSHUFLW $7, (R11), X11         // c4417b701b07
	//TODO: VPSHUFLW $7, X2, X11            // c4617b70da07 or c57b70da07
	//TODO: VPSHUFLW $7, X11, X11           // c4417b70db07
	//TODO: VPSHUFLW $7, (BX), Y2           // c4e17f701307 or c5ff701307
	//TODO: VPSHUFLW $7, (R11), Y2          // c4c17f701307
	//TODO: VPSHUFLW $7, Y2, Y2             // c4e17f70d207 or c5ff70d207
	//TODO: VPSHUFLW $7, Y11, Y2            // c4c17f70d307
	//TODO: VPSHUFLW $7, (BX), Y11          // c4617f701b07 or c57f701b07
	//TODO: VPSHUFLW $7, (R11), Y11         // c4417f701b07
	//TODO: VPSHUFLW $7, Y2, Y11            // c4617f70da07 or c57f70da07
	//TODO: VPSHUFLW $7, Y11, Y11           // c4417f70db07
	//TODO: VPSIGNB (BX), X9, X2            // c4e2310813
	//TODO: VPSIGNB (R11), X9, X2           // c4c2310813
	//TODO: VPSIGNB X2, X9, X2              // c4e23108d2
	//TODO: VPSIGNB X11, X9, X2             // c4c23108d3
	//TODO: VPSIGNB (BX), X9, X11           // c46231081b
	//TODO: VPSIGNB (R11), X9, X11          // c44231081b
	//TODO: VPSIGNB X2, X9, X11             // c4623108da
	//TODO: VPSIGNB X11, X9, X11            // c4423108db
	//TODO: VPSIGNB (BX), Y15, Y2           // c4e2050813
	//TODO: VPSIGNB (R11), Y15, Y2          // c4c2050813
	//TODO: VPSIGNB Y2, Y15, Y2             // c4e20508d2
	//TODO: VPSIGNB Y11, Y15, Y2            // c4c20508d3
	//TODO: VPSIGNB (BX), Y15, Y11          // c46205081b
	//TODO: VPSIGNB (R11), Y15, Y11         // c44205081b
	//TODO: VPSIGNB Y2, Y15, Y11            // c4620508da
	//TODO: VPSIGNB Y11, Y15, Y11           // c4420508db
	//TODO: VPSIGND (BX), X9, X2            // c4e2310a13
	//TODO: VPSIGND (R11), X9, X2           // c4c2310a13
	//TODO: VPSIGND X2, X9, X2              // c4e2310ad2
	//TODO: VPSIGND X11, X9, X2             // c4c2310ad3
	//TODO: VPSIGND (BX), X9, X11           // c462310a1b
	//TODO: VPSIGND (R11), X9, X11          // c442310a1b
	//TODO: VPSIGND X2, X9, X11             // c462310ada
	//TODO: VPSIGND X11, X9, X11            // c442310adb
	//TODO: VPSIGND (BX), Y15, Y2           // c4e2050a13
	//TODO: VPSIGND (R11), Y15, Y2          // c4c2050a13
	//TODO: VPSIGND Y2, Y15, Y2             // c4e2050ad2
	//TODO: VPSIGND Y11, Y15, Y2            // c4c2050ad3
	//TODO: VPSIGND (BX), Y15, Y11          // c462050a1b
	//TODO: VPSIGND (R11), Y15, Y11         // c442050a1b
	//TODO: VPSIGND Y2, Y15, Y11            // c462050ada
	//TODO: VPSIGND Y11, Y15, Y11           // c442050adb
	//TODO: VPSIGNW (BX), X9, X2            // c4e2310913
	//TODO: VPSIGNW (R11), X9, X2           // c4c2310913
	//TODO: VPSIGNW X2, X9, X2              // c4e23109d2
	//TODO: VPSIGNW X11, X9, X2             // c4c23109d3
	//TODO: VPSIGNW (BX), X9, X11           // c46231091b
	//TODO: VPSIGNW (R11), X9, X11          // c44231091b
	//TODO: VPSIGNW X2, X9, X11             // c4623109da
	//TODO: VPSIGNW X11, X9, X11            // c4423109db
	//TODO: VPSIGNW (BX), Y15, Y2           // c4e2050913
	//TODO: VPSIGNW (R11), Y15, Y2          // c4c2050913
	//TODO: VPSIGNW Y2, Y15, Y2             // c4e20509d2
	//TODO: VPSIGNW Y11, Y15, Y2            // c4c20509d3
	//TODO: VPSIGNW (BX), Y15, Y11          // c46205091b
	//TODO: VPSIGNW (R11), Y15, Y11         // c44205091b
	//TODO: VPSIGNW Y2, Y15, Y11            // c4620509da
	//TODO: VPSIGNW Y11, Y15, Y11           // c4420509db
	//TODO: VPSLLD (BX), X9, X2             // c4e131f213 or c5b1f213
	//TODO: VPSLLD (R11), X9, X2            // c4c131f213
	//TODO: VPSLLD X2, X9, X2               // c4e131f2d2 or c5b1f2d2
	//TODO: VPSLLD X11, X9, X2              // c4c131f2d3
	//TODO: VPSLLD (BX), X9, X11            // c46131f21b or c531f21b
	//TODO: VPSLLD (R11), X9, X11           // c44131f21b
	//TODO: VPSLLD X2, X9, X11              // c46131f2da or c531f2da
	//TODO: VPSLLD X11, X9, X11             // c44131f2db
	//TODO: VPSLLD $7, X2, X9               // c4e13172f207 or c5b172f207
	//TODO: VPSLLD $7, X11, X9              // c4c13172f307
	//TODO: VPSLLDQ $7, X2, X9              // c4e13173fa07 or c5b173fa07
	//TODO: VPSLLDQ $7, X11, X9             // c4c13173fb07
	//TODO: VPSLLDQ $7, Y2, Y15             // c4e10573fa07 or c58573fa07
	//TODO: VPSLLDQ $7, Y11, Y15            // c4c10573fb07
	//TODO: VPSLLQ (BX), X9, X2             // c4e131f313 or c5b1f313
	//TODO: VPSLLQ (R11), X9, X2            // c4c131f313
	//TODO: VPSLLQ X2, X9, X2               // c4e131f3d2 or c5b1f3d2
	//TODO: VPSLLQ X11, X9, X2              // c4c131f3d3
	//TODO: VPSLLQ (BX), X9, X11            // c46131f31b or c531f31b
	//TODO: VPSLLQ (R11), X9, X11           // c44131f31b
	//TODO: VPSLLQ X2, X9, X11              // c46131f3da or c531f3da
	//TODO: VPSLLQ X11, X9, X11             // c44131f3db
	//TODO: VPSLLQ $7, X2, X9               // c4e13173f207 or c5b173f207
	//TODO: VPSLLQ $7, X11, X9              // c4c13173f307
	//TODO: VPSLLVD (BX), X9, X2            // c4e2314713
	//TODO: VPSLLVD (R11), X9, X2           // c4c2314713
	//TODO: VPSLLVD X2, X9, X2              // c4e23147d2
	//TODO: VPSLLVD X11, X9, X2             // c4c23147d3
	//TODO: VPSLLVD (BX), X9, X11           // c46231471b
	//TODO: VPSLLVD (R11), X9, X11          // c44231471b
	//TODO: VPSLLVD X2, X9, X11             // c4623147da
	//TODO: VPSLLVD X11, X9, X11            // c4423147db
	//TODO: VPSLLVD (BX), Y15, Y2           // c4e2054713
	//TODO: VPSLLVD (R11), Y15, Y2          // c4c2054713
	//TODO: VPSLLVD Y2, Y15, Y2             // c4e20547d2
	//TODO: VPSLLVD Y11, Y15, Y2            // c4c20547d3
	//TODO: VPSLLVD (BX), Y15, Y11          // c46205471b
	//TODO: VPSLLVD (R11), Y15, Y11         // c44205471b
	//TODO: VPSLLVD Y2, Y15, Y11            // c4620547da
	//TODO: VPSLLVD Y11, Y15, Y11           // c4420547db
	//TODO: VPSLLVQ (BX), X9, X2            // c4e2b14713
	//TODO: VPSLLVQ (R11), X9, X2           // c4c2b14713
	//TODO: VPSLLVQ X2, X9, X2              // c4e2b147d2
	//TODO: VPSLLVQ X11, X9, X2             // c4c2b147d3
	//TODO: VPSLLVQ (BX), X9, X11           // c462b1471b
	//TODO: VPSLLVQ (R11), X9, X11          // c442b1471b
	//TODO: VPSLLVQ X2, X9, X11             // c462b147da
	//TODO: VPSLLVQ X11, X9, X11            // c442b147db
	//TODO: VPSLLVQ (BX), Y15, Y2           // c4e2854713
	//TODO: VPSLLVQ (R11), Y15, Y2          // c4c2854713
	//TODO: VPSLLVQ Y2, Y15, Y2             // c4e28547d2
	//TODO: VPSLLVQ Y11, Y15, Y2            // c4c28547d3
	//TODO: VPSLLVQ (BX), Y15, Y11          // c46285471b
	//TODO: VPSLLVQ (R11), Y15, Y11         // c44285471b
	//TODO: VPSLLVQ Y2, Y15, Y11            // c4628547da
	//TODO: VPSLLVQ Y11, Y15, Y11           // c4428547db
	//TODO: VPSLLW (BX), X9, X2             // c4e131f113 or c5b1f113
	//TODO: VPSLLW (R11), X9, X2            // c4c131f113
	//TODO: VPSLLW X2, X9, X2               // c4e131f1d2 or c5b1f1d2
	//TODO: VPSLLW X11, X9, X2              // c4c131f1d3
	//TODO: VPSLLW (BX), X9, X11            // c46131f11b or c531f11b
	//TODO: VPSLLW (R11), X9, X11           // c44131f11b
	//TODO: VPSLLW X2, X9, X11              // c46131f1da or c531f1da
	//TODO: VPSLLW X11, X9, X11             // c44131f1db
	//TODO: VPSLLW $7, X2, X9               // c4e13171f207 or c5b171f207
	//TODO: VPSLLW $7, X11, X9              // c4c13171f307
	//TODO: VPSLLW (BX), Y15, Y2            // c4e105f113 or c585f113
	//TODO: VPSLLW (R11), Y15, Y2           // c4c105f113
	//TODO: VPSLLW X2, Y15, Y2              // c4e105f1d2 or c585f1d2
	//TODO: VPSLLW X11, Y15, Y2             // c4c105f1d3
	//TODO: VPSLLW (BX), Y15, Y11           // c46105f11b or c505f11b
	//TODO: VPSLLW (R11), Y15, Y11          // c44105f11b
	//TODO: VPSLLW X2, Y15, Y11             // c46105f1da or c505f1da
	//TODO: VPSLLW X11, Y15, Y11            // c44105f1db
	//TODO: VPSLLW $7, Y2, Y15              // c4e10571f207 or c58571f207
	//TODO: VPSLLW $7, Y11, Y15             // c4c10571f307
	//TODO: VPSRAD (BX), X9, X2             // c4e131e213 or c5b1e213
	//TODO: VPSRAD (R11), X9, X2            // c4c131e213
	//TODO: VPSRAD X2, X9, X2               // c4e131e2d2 or c5b1e2d2
	//TODO: VPSRAD X11, X9, X2              // c4c131e2d3
	//TODO: VPSRAD (BX), X9, X11            // c46131e21b or c531e21b
	//TODO: VPSRAD (R11), X9, X11           // c44131e21b
	//TODO: VPSRAD X2, X9, X11              // c46131e2da or c531e2da
	//TODO: VPSRAD X11, X9, X11             // c44131e2db
	//TODO: VPSRAD $7, X2, X9               // c4e13172e207 or c5b172e207
	//TODO: VPSRAD $7, X11, X9              // c4c13172e307
	//TODO: VPSRAD (BX), Y15, Y2            // c4e105e213 or c585e213
	//TODO: VPSRAD (R11), Y15, Y2           // c4c105e213
	//TODO: VPSRAD X2, Y15, Y2              // c4e105e2d2 or c585e2d2
	//TODO: VPSRAD X11, Y15, Y2             // c4c105e2d3
	//TODO: VPSRAD (BX), Y15, Y11           // c46105e21b or c505e21b
	//TODO: VPSRAD (R11), Y15, Y11          // c44105e21b
	//TODO: VPSRAD X2, Y15, Y11             // c46105e2da or c505e2da
	//TODO: VPSRAD X11, Y15, Y11            // c44105e2db
	//TODO: VPSRAD $7, Y2, Y15              // c4e10572e207 or c58572e207
	//TODO: VPSRAD $7, Y11, Y15             // c4c10572e307
	//TODO: VPSRAVD (BX), X9, X2            // c4e2314613
	//TODO: VPSRAVD (R11), X9, X2           // c4c2314613
	//TODO: VPSRAVD X2, X9, X2              // c4e23146d2
	//TODO: VPSRAVD X11, X9, X2             // c4c23146d3
	//TODO: VPSRAVD (BX), X9, X11           // c46231461b
	//TODO: VPSRAVD (R11), X9, X11          // c44231461b
	//TODO: VPSRAVD X2, X9, X11             // c4623146da
	//TODO: VPSRAVD X11, X9, X11            // c4423146db
	//TODO: VPSRAVD (BX), Y15, Y2           // c4e2054613
	//TODO: VPSRAVD (R11), Y15, Y2          // c4c2054613
	//TODO: VPSRAVD Y2, Y15, Y2             // c4e20546d2
	//TODO: VPSRAVD Y11, Y15, Y2            // c4c20546d3
	//TODO: VPSRAVD (BX), Y15, Y11          // c46205461b
	//TODO: VPSRAVD (R11), Y15, Y11         // c44205461b
	//TODO: VPSRAVD Y2, Y15, Y11            // c4620546da
	//TODO: VPSRAVD Y11, Y15, Y11           // c4420546db
	//TODO: VPSRAW (BX), X9, X2             // c4e131e113 or c5b1e113
	//TODO: VPSRAW (R11), X9, X2            // c4c131e113
	//TODO: VPSRAW X2, X9, X2               // c4e131e1d2 or c5b1e1d2
	//TODO: VPSRAW X11, X9, X2              // c4c131e1d3
	//TODO: VPSRAW (BX), X9, X11            // c46131e11b or c531e11b
	//TODO: VPSRAW (R11), X9, X11           // c44131e11b
	//TODO: VPSRAW X2, X9, X11              // c46131e1da or c531e1da
	//TODO: VPSRAW X11, X9, X11             // c44131e1db
	//TODO: VPSRAW $7, X2, X9               // c4e13171e207 or c5b171e207
	//TODO: VPSRAW $7, X11, X9              // c4c13171e307
	//TODO: VPSRAW (BX), Y15, Y2            // c4e105e113 or c585e113
	//TODO: VPSRAW (R11), Y15, Y2           // c4c105e113
	//TODO: VPSRAW X2, Y15, Y2              // c4e105e1d2 or c585e1d2
	//TODO: VPSRAW X11, Y15, Y2             // c4c105e1d3
	//TODO: VPSRAW (BX), Y15, Y11           // c46105e11b or c505e11b
	//TODO: VPSRAW (R11), Y15, Y11          // c44105e11b
	//TODO: VPSRAW X2, Y15, Y11             // c46105e1da or c505e1da
	//TODO: VPSRAW X11, Y15, Y11            // c44105e1db
	//TODO: VPSRAW $7, Y2, Y15              // c4e10571e207 or c58571e207
	//TODO: VPSRAW $7, Y11, Y15             // c4c10571e307
	//TODO: VPSRLD (BX), X9, X2             // c4e131d213 or c5b1d213
	//TODO: VPSRLD (R11), X9, X2            // c4c131d213
	//TODO: VPSRLD X2, X9, X2               // c4e131d2d2 or c5b1d2d2
	//TODO: VPSRLD X11, X9, X2              // c4c131d2d3
	//TODO: VPSRLD (BX), X9, X11            // c46131d21b or c531d21b
	//TODO: VPSRLD (R11), X9, X11           // c44131d21b
	//TODO: VPSRLD X2, X9, X11              // c46131d2da or c531d2da
	//TODO: VPSRLD X11, X9, X11             // c44131d2db
	//TODO: VPSRLD $7, X2, X9               // c4e13172d207 or c5b172d207
	//TODO: VPSRLD $7, X11, X9              // c4c13172d307
	//TODO: VPSRLDQ $7, X2, X9              // c4e13173da07 or c5b173da07
	//TODO: VPSRLDQ $7, X11, X9             // c4c13173db07
	//TODO: VPSRLDQ $7, Y2, Y15             // c4e10573da07 or c58573da07
	//TODO: VPSRLDQ $7, Y11, Y15            // c4c10573db07
	//TODO: VPSRLQ (BX), X9, X2             // c4e131d313 or c5b1d313
	//TODO: VPSRLQ (R11), X9, X2            // c4c131d313
	//TODO: VPSRLQ X2, X9, X2               // c4e131d3d2 or c5b1d3d2
	//TODO: VPSRLQ X11, X9, X2              // c4c131d3d3
	//TODO: VPSRLQ (BX), X9, X11            // c46131d31b or c531d31b
	//TODO: VPSRLQ (R11), X9, X11           // c44131d31b
	//TODO: VPSRLQ X2, X9, X11              // c46131d3da or c531d3da
	//TODO: VPSRLQ X11, X9, X11             // c44131d3db
	//TODO: VPSRLQ $7, X2, X9               // c4e13173d207 or c5b173d207
	//TODO: VPSRLQ $7, X11, X9              // c4c13173d307
	//TODO: VPSRLVD (BX), X9, X2            // c4e2314513
	//TODO: VPSRLVD (R11), X9, X2           // c4c2314513
	//TODO: VPSRLVD X2, X9, X2              // c4e23145d2
	//TODO: VPSRLVD X11, X9, X2             // c4c23145d3
	//TODO: VPSRLVD (BX), X9, X11           // c46231451b
	//TODO: VPSRLVD (R11), X9, X11          // c44231451b
	//TODO: VPSRLVD X2, X9, X11             // c4623145da
	//TODO: VPSRLVD X11, X9, X11            // c4423145db
	//TODO: VPSRLVD (BX), Y15, Y2           // c4e2054513
	//TODO: VPSRLVD (R11), Y15, Y2          // c4c2054513
	//TODO: VPSRLVD Y2, Y15, Y2             // c4e20545d2
	//TODO: VPSRLVD Y11, Y15, Y2            // c4c20545d3
	//TODO: VPSRLVD (BX), Y15, Y11          // c46205451b
	//TODO: VPSRLVD (R11), Y15, Y11         // c44205451b
	//TODO: VPSRLVD Y2, Y15, Y11            // c4620545da
	//TODO: VPSRLVD Y11, Y15, Y11           // c4420545db
	//TODO: VPSRLVQ (BX), X9, X2            // c4e2b14513
	//TODO: VPSRLVQ (R11), X9, X2           // c4c2b14513
	//TODO: VPSRLVQ X2, X9, X2              // c4e2b145d2
	//TODO: VPSRLVQ X11, X9, X2             // c4c2b145d3
	//TODO: VPSRLVQ (BX), X9, X11           // c462b1451b
	//TODO: VPSRLVQ (R11), X9, X11          // c442b1451b
	//TODO: VPSRLVQ X2, X9, X11             // c462b145da
	//TODO: VPSRLVQ X11, X9, X11            // c442b145db
	//TODO: VPSRLVQ (BX), Y15, Y2           // c4e2854513
	//TODO: VPSRLVQ (R11), Y15, Y2          // c4c2854513
	//TODO: VPSRLVQ Y2, Y15, Y2             // c4e28545d2
	//TODO: VPSRLVQ Y11, Y15, Y2            // c4c28545d3
	//TODO: VPSRLVQ (BX), Y15, Y11          // c46285451b
	//TODO: VPSRLVQ (R11), Y15, Y11         // c44285451b
	//TODO: VPSRLVQ Y2, Y15, Y11            // c4628545da
	//TODO: VPSRLVQ Y11, Y15, Y11           // c4428545db
	//TODO: VPSRLW (BX), X9, X2             // c4e131d113 or c5b1d113
	//TODO: VPSRLW (R11), X9, X2            // c4c131d113
	//TODO: VPSRLW X2, X9, X2               // c4e131d1d2 or c5b1d1d2
	//TODO: VPSRLW X11, X9, X2              // c4c131d1d3
	//TODO: VPSRLW (BX), X9, X11            // c46131d11b or c531d11b
	//TODO: VPSRLW (R11), X9, X11           // c44131d11b
	//TODO: VPSRLW X2, X9, X11              // c46131d1da or c531d1da
	//TODO: VPSRLW X11, X9, X11             // c44131d1db
	//TODO: VPSRLW $7, X2, X9               // c4e13171d207 or c5b171d207
	//TODO: VPSRLW $7, X11, X9              // c4c13171d307
	//TODO: VPSRLW (BX), Y15, Y2            // c4e105d113 or c585d113
	//TODO: VPSRLW (R11), Y15, Y2           // c4c105d113
	//TODO: VPSRLW X2, Y15, Y2              // c4e105d1d2 or c585d1d2
	//TODO: VPSRLW X11, Y15, Y2             // c4c105d1d3
	//TODO: VPSRLW (BX), Y15, Y11           // c46105d11b or c505d11b
	//TODO: VPSRLW (R11), Y15, Y11          // c44105d11b
	//TODO: VPSRLW X2, Y15, Y11             // c46105d1da or c505d1da
	//TODO: VPSRLW X11, Y15, Y11            // c44105d1db
	//TODO: VPSRLW $7, Y2, Y15              // c4e10571d207 or c58571d207
	//TODO: VPSRLW $7, Y11, Y15             // c4c10571d307
	//TODO: VPSUBB (BX), X9, X2             // c4e131f813 or c5b1f813
	//TODO: VPSUBB (R11), X9, X2            // c4c131f813
	//TODO: VPSUBB X2, X9, X2               // c4e131f8d2 or c5b1f8d2
	//TODO: VPSUBB X11, X9, X2              // c4c131f8d3
	//TODO: VPSUBB (BX), X9, X11            // c46131f81b or c531f81b
	//TODO: VPSUBB (R11), X9, X11           // c44131f81b
	//TODO: VPSUBB X2, X9, X11              // c46131f8da or c531f8da
	//TODO: VPSUBB X11, X9, X11             // c44131f8db
	//TODO: VPSUBB (BX), Y15, Y2            // c4e105f813 or c585f813
	//TODO: VPSUBB (R11), Y15, Y2           // c4c105f813
	//TODO: VPSUBB Y2, Y15, Y2              // c4e105f8d2 or c585f8d2
	//TODO: VPSUBB Y11, Y15, Y2             // c4c105f8d3
	//TODO: VPSUBB (BX), Y15, Y11           // c46105f81b or c505f81b
	//TODO: VPSUBB (R11), Y15, Y11          // c44105f81b
	//TODO: VPSUBB Y2, Y15, Y11             // c46105f8da or c505f8da
	//TODO: VPSUBB Y11, Y15, Y11            // c44105f8db
	//TODO: VPSUBD (BX), X9, X2             // c4e131fa13 or c5b1fa13
	//TODO: VPSUBD (R11), X9, X2            // c4c131fa13
	//TODO: VPSUBD X2, X9, X2               // c4e131fad2 or c5b1fad2
	//TODO: VPSUBD X11, X9, X2              // c4c131fad3
	//TODO: VPSUBD (BX), X9, X11            // c46131fa1b or c531fa1b
	//TODO: VPSUBD (R11), X9, X11           // c44131fa1b
	//TODO: VPSUBD X2, X9, X11              // c46131fada or c531fada
	//TODO: VPSUBD X11, X9, X11             // c44131fadb
	//TODO: VPSUBD (BX), Y15, Y2            // c4e105fa13 or c585fa13
	//TODO: VPSUBD (R11), Y15, Y2           // c4c105fa13
	//TODO: VPSUBD Y2, Y15, Y2              // c4e105fad2 or c585fad2
	//TODO: VPSUBD Y11, Y15, Y2             // c4c105fad3
	//TODO: VPSUBD (BX), Y15, Y11           // c46105fa1b or c505fa1b
	//TODO: VPSUBD (R11), Y15, Y11          // c44105fa1b
	//TODO: VPSUBD Y2, Y15, Y11             // c46105fada or c505fada
	//TODO: VPSUBD Y11, Y15, Y11            // c44105fadb
	//TODO: VPSUBQ (BX), X9, X2             // c4e131fb13 or c5b1fb13
	//TODO: VPSUBQ (R11), X9, X2            // c4c131fb13
	//TODO: VPSUBQ X2, X9, X2               // c4e131fbd2 or c5b1fbd2
	//TODO: VPSUBQ X11, X9, X2              // c4c131fbd3
	//TODO: VPSUBQ (BX), X9, X11            // c46131fb1b or c531fb1b
	//TODO: VPSUBQ (R11), X9, X11           // c44131fb1b
	//TODO: VPSUBQ X2, X9, X11              // c46131fbda or c531fbda
	//TODO: VPSUBQ X11, X9, X11             // c44131fbdb
	//TODO: VPSUBQ (BX), Y15, Y2            // c4e105fb13 or c585fb13
	//TODO: VPSUBQ (R11), Y15, Y2           // c4c105fb13
	//TODO: VPSUBQ Y2, Y15, Y2              // c4e105fbd2 or c585fbd2
	//TODO: VPSUBQ Y11, Y15, Y2             // c4c105fbd3
	//TODO: VPSUBQ (BX), Y15, Y11           // c46105fb1b or c505fb1b
	//TODO: VPSUBQ (R11), Y15, Y11          // c44105fb1b
	//TODO: VPSUBQ Y2, Y15, Y11             // c46105fbda or c505fbda
	//TODO: VPSUBQ Y11, Y15, Y11            // c44105fbdb
	//TODO: VPSUBSB (BX), X9, X2            // c4e131e813 or c5b1e813
	//TODO: VPSUBSB (R11), X9, X2           // c4c131e813
	//TODO: VPSUBSB X2, X9, X2              // c4e131e8d2 or c5b1e8d2
	//TODO: VPSUBSB X11, X9, X2             // c4c131e8d3
	//TODO: VPSUBSB (BX), X9, X11           // c46131e81b or c531e81b
	//TODO: VPSUBSB (R11), X9, X11          // c44131e81b
	//TODO: VPSUBSB X2, X9, X11             // c46131e8da or c531e8da
	//TODO: VPSUBSB X11, X9, X11            // c44131e8db
	//TODO: VPSUBSB (BX), Y15, Y2           // c4e105e813 or c585e813
	//TODO: VPSUBSB (R11), Y15, Y2          // c4c105e813
	//TODO: VPSUBSB Y2, Y15, Y2             // c4e105e8d2 or c585e8d2
	//TODO: VPSUBSB Y11, Y15, Y2            // c4c105e8d3
	//TODO: VPSUBSB (BX), Y15, Y11          // c46105e81b or c505e81b
	//TODO: VPSUBSB (R11), Y15, Y11         // c44105e81b
	//TODO: VPSUBSB Y2, Y15, Y11            // c46105e8da or c505e8da
	//TODO: VPSUBSB Y11, Y15, Y11           // c44105e8db
	//TODO: VPSUBSW (BX), X9, X2            // c4e131e913 or c5b1e913
	//TODO: VPSUBSW (R11), X9, X2           // c4c131e913
	//TODO: VPSUBSW X2, X9, X2              // c4e131e9d2 or c5b1e9d2
	//TODO: VPSUBSW X11, X9, X2             // c4c131e9d3
	//TODO: VPSUBSW (BX), X9, X11           // c46131e91b or c531e91b
	//TODO: VPSUBSW (R11), X9, X11          // c44131e91b
	//TODO: VPSUBSW X2, X9, X11             // c46131e9da or c531e9da
	//TODO: VPSUBSW X11, X9, X11            // c44131e9db
	//TODO: VPSUBSW (BX), Y15, Y2           // c4e105e913 or c585e913
	//TODO: VPSUBSW (R11), Y15, Y2          // c4c105e913
	//TODO: VPSUBSW Y2, Y15, Y2             // c4e105e9d2 or c585e9d2
	//TODO: VPSUBSW Y11, Y15, Y2            // c4c105e9d3
	//TODO: VPSUBSW (BX), Y15, Y11          // c46105e91b or c505e91b
	//TODO: VPSUBSW (R11), Y15, Y11         // c44105e91b
	//TODO: VPSUBSW Y2, Y15, Y11            // c46105e9da or c505e9da
	//TODO: VPSUBSW Y11, Y15, Y11           // c44105e9db
	//TODO: VPSUBUSB (BX), X9, X2           // c4e131d813 or c5b1d813
	//TODO: VPSUBUSB (R11), X9, X2          // c4c131d813
	//TODO: VPSUBUSB X2, X9, X2             // c4e131d8d2 or c5b1d8d2
	//TODO: VPSUBUSB X11, X9, X2            // c4c131d8d3
	//TODO: VPSUBUSB (BX), X9, X11          // c46131d81b or c531d81b
	//TODO: VPSUBUSB (R11), X9, X11         // c44131d81b
	//TODO: VPSUBUSB X2, X9, X11            // c46131d8da or c531d8da
	//TODO: VPSUBUSB X11, X9, X11           // c44131d8db
	//TODO: VPSUBUSB (BX), Y15, Y2          // c4e105d813 or c585d813
	//TODO: VPSUBUSB (R11), Y15, Y2         // c4c105d813
	//TODO: VPSUBUSB Y2, Y15, Y2            // c4e105d8d2 or c585d8d2
	//TODO: VPSUBUSB Y11, Y15, Y2           // c4c105d8d3
	//TODO: VPSUBUSB (BX), Y15, Y11         // c46105d81b or c505d81b
	//TODO: VPSUBUSB (R11), Y15, Y11        // c44105d81b
	//TODO: VPSUBUSB Y2, Y15, Y11           // c46105d8da or c505d8da
	//TODO: VPSUBUSB Y11, Y15, Y11          // c44105d8db
	//TODO: VPSUBUSW (BX), X9, X2           // c4e131d913 or c5b1d913
	//TODO: VPSUBUSW (R11), X9, X2          // c4c131d913
	//TODO: VPSUBUSW X2, X9, X2             // c4e131d9d2 or c5b1d9d2
	//TODO: VPSUBUSW X11, X9, X2            // c4c131d9d3
	//TODO: VPSUBUSW (BX), X9, X11          // c46131d91b or c531d91b
	//TODO: VPSUBUSW (R11), X9, X11         // c44131d91b
	//TODO: VPSUBUSW X2, X9, X11            // c46131d9da or c531d9da
	//TODO: VPSUBUSW X11, X9, X11           // c44131d9db
	//TODO: VPSUBUSW (BX), Y15, Y2          // c4e105d913 or c585d913
	//TODO: VPSUBUSW (R11), Y15, Y2         // c4c105d913
	//TODO: VPSUBUSW Y2, Y15, Y2            // c4e105d9d2 or c585d9d2
	//TODO: VPSUBUSW Y11, Y15, Y2           // c4c105d9d3
	//TODO: VPSUBUSW (BX), Y15, Y11         // c46105d91b or c505d91b
	//TODO: VPSUBUSW (R11), Y15, Y11        // c44105d91b
	//TODO: VPSUBUSW Y2, Y15, Y11           // c46105d9da or c505d9da
	//TODO: VPSUBUSW Y11, Y15, Y11          // c44105d9db
	//TODO: VPSUBW (BX), X9, X2             // c4e131f913 or c5b1f913
	//TODO: VPSUBW (R11), X9, X2            // c4c131f913
	//TODO: VPSUBW X2, X9, X2               // c4e131f9d2 or c5b1f9d2
	//TODO: VPSUBW X11, X9, X2              // c4c131f9d3
	//TODO: VPSUBW (BX), X9, X11            // c46131f91b or c531f91b
	//TODO: VPSUBW (R11), X9, X11           // c44131f91b
	//TODO: VPSUBW X2, X9, X11              // c46131f9da or c531f9da
	//TODO: VPSUBW X11, X9, X11             // c44131f9db
	//TODO: VPSUBW (BX), Y15, Y2            // c4e105f913 or c585f913
	//TODO: VPSUBW (R11), Y15, Y2           // c4c105f913
	//TODO: VPSUBW Y2, Y15, Y2              // c4e105f9d2 or c585f9d2
	//TODO: VPSUBW Y11, Y15, Y2             // c4c105f9d3
	//TODO: VPSUBW (BX), Y15, Y11           // c46105f91b or c505f91b
	//TODO: VPSUBW (R11), Y15, Y11          // c44105f91b
	//TODO: VPSUBW Y2, Y15, Y11             // c46105f9da or c505f9da
	//TODO: VPSUBW Y11, Y15, Y11            // c44105f9db
	VPTEST (BX), X2                         // c4e2791713
	VPTEST (R11), X2                        // c4c2791713
	VPTEST X2, X2                           // c4e27917d2
	VPTEST X11, X2                          // c4c27917d3
	VPTEST (BX), X11                        // c46279171b
	VPTEST (R11), X11                       // c44279171b
	VPTEST X2, X11                          // c4627917da
	VPTEST X11, X11                         // c4427917db
	VPTEST (BX), Y2                         // c4e27d1713
	VPTEST (R11), Y2                        // c4c27d1713
	VPTEST Y2, Y2                           // c4e27d17d2
	VPTEST Y11, Y2                          // c4c27d17d3
	VPTEST (BX), Y11                        // c4627d171b
	VPTEST (R11), Y11                       // c4427d171b
	VPTEST Y2, Y11                          // c4627d17da
	VPTEST Y11, Y11                         // c4427d17db
	//TODO: VPUNPCKHBW (BX), X9, X2         // c4e1316813 or c5b16813
	//TODO: VPUNPCKHBW (R11), X9, X2        // c4c1316813
	//TODO: VPUNPCKHBW X2, X9, X2           // c4e13168d2 or c5b168d2
	//TODO: VPUNPCKHBW X11, X9, X2          // c4c13168d3
	//TODO: VPUNPCKHBW (BX), X9, X11        // c46131681b or c531681b
	//TODO: VPUNPCKHBW (R11), X9, X11       // c44131681b
	//TODO: VPUNPCKHBW X2, X9, X11          // c4613168da or c53168da
	//TODO: VPUNPCKHBW X11, X9, X11         // c4413168db
	//TODO: VPUNPCKHBW (BX), Y15, Y2        // c4e1056813 or c5856813
	//TODO: VPUNPCKHBW (R11), Y15, Y2       // c4c1056813
	//TODO: VPUNPCKHBW Y2, Y15, Y2          // c4e10568d2 or c58568d2
	//TODO: VPUNPCKHBW Y11, Y15, Y2         // c4c10568d3
	//TODO: VPUNPCKHBW (BX), Y15, Y11       // c46105681b or c505681b
	//TODO: VPUNPCKHBW (R11), Y15, Y11      // c44105681b
	//TODO: VPUNPCKHBW Y2, Y15, Y11         // c4610568da or c50568da
	//TODO: VPUNPCKHBW Y11, Y15, Y11        // c4410568db
	//TODO: VPUNPCKHDQ (BX), X9, X2         // c4e1316a13 or c5b16a13
	//TODO: VPUNPCKHDQ (R11), X9, X2        // c4c1316a13
	//TODO: VPUNPCKHDQ X2, X9, X2           // c4e1316ad2 or c5b16ad2
	//TODO: VPUNPCKHDQ X11, X9, X2          // c4c1316ad3
	//TODO: VPUNPCKHDQ (BX), X9, X11        // c461316a1b or c5316a1b
	//TODO: VPUNPCKHDQ (R11), X9, X11       // c441316a1b
	//TODO: VPUNPCKHDQ X2, X9, X11          // c461316ada or c5316ada
	//TODO: VPUNPCKHDQ X11, X9, X11         // c441316adb
	//TODO: VPUNPCKHDQ (BX), Y15, Y2        // c4e1056a13 or c5856a13
	//TODO: VPUNPCKHDQ (R11), Y15, Y2       // c4c1056a13
	//TODO: VPUNPCKHDQ Y2, Y15, Y2          // c4e1056ad2 or c5856ad2
	//TODO: VPUNPCKHDQ Y11, Y15, Y2         // c4c1056ad3
	//TODO: VPUNPCKHDQ (BX), Y15, Y11       // c461056a1b or c5056a1b
	//TODO: VPUNPCKHDQ (R11), Y15, Y11      // c441056a1b
	//TODO: VPUNPCKHDQ Y2, Y15, Y11         // c461056ada or c5056ada
	//TODO: VPUNPCKHDQ Y11, Y15, Y11        // c441056adb
	//TODO: VPUNPCKHQDQ (BX), X9, X2        // c4e1316d13 or c5b16d13
	//TODO: VPUNPCKHQDQ (R11), X9, X2       // c4c1316d13
	//TODO: VPUNPCKHQDQ X2, X9, X2          // c4e1316dd2 or c5b16dd2
	//TODO: VPUNPCKHQDQ X11, X9, X2         // c4c1316dd3
	//TODO: VPUNPCKHQDQ (BX), X9, X11       // c461316d1b or c5316d1b
	//TODO: VPUNPCKHQDQ (R11), X9, X11      // c441316d1b
	//TODO: VPUNPCKHQDQ X2, X9, X11         // c461316dda or c5316dda
	//TODO: VPUNPCKHQDQ X11, X9, X11        // c441316ddb
	//TODO: VPUNPCKHQDQ (BX), Y15, Y2       // c4e1056d13 or c5856d13
	//TODO: VPUNPCKHQDQ (R11), Y15, Y2      // c4c1056d13
	//TODO: VPUNPCKHQDQ Y2, Y15, Y2         // c4e1056dd2 or c5856dd2
	//TODO: VPUNPCKHQDQ Y11, Y15, Y2        // c4c1056dd3
	//TODO: VPUNPCKHQDQ (BX), Y15, Y11      // c461056d1b or c5056d1b
	//TODO: VPUNPCKHQDQ (R11), Y15, Y11     // c441056d1b
	//TODO: VPUNPCKHQDQ Y2, Y15, Y11        // c461056dda or c5056dda
	//TODO: VPUNPCKHQDQ Y11, Y15, Y11       // c441056ddb
	//TODO: VPUNPCKHWD (BX), X9, X2         // c4e1316913 or c5b16913
	//TODO: VPUNPCKHWD (R11), X9, X2        // c4c1316913
	//TODO: VPUNPCKHWD X2, X9, X2           // c4e13169d2 or c5b169d2
	//TODO: VPUNPCKHWD X11, X9, X2          // c4c13169d3
	//TODO: VPUNPCKHWD (BX), X9, X11        // c46131691b or c531691b
	//TODO: VPUNPCKHWD (R11), X9, X11       // c44131691b
	//TODO: VPUNPCKHWD X2, X9, X11          // c4613169da or c53169da
	//TODO: VPUNPCKHWD X11, X9, X11         // c4413169db
	//TODO: VPUNPCKHWD (BX), Y15, Y2        // c4e1056913 or c5856913
	//TODO: VPUNPCKHWD (R11), Y15, Y2       // c4c1056913
	//TODO: VPUNPCKHWD Y2, Y15, Y2          // c4e10569d2 or c58569d2
	//TODO: VPUNPCKHWD Y11, Y15, Y2         // c4c10569d3
	//TODO: VPUNPCKHWD (BX), Y15, Y11       // c46105691b or c505691b
	//TODO: VPUNPCKHWD (R11), Y15, Y11      // c44105691b
	//TODO: VPUNPCKHWD Y2, Y15, Y11         // c4610569da or c50569da
	//TODO: VPUNPCKHWD Y11, Y15, Y11        // c4410569db
	//TODO: VPUNPCKLBW (BX), X9, X2         // c4e1316013 or c5b16013
	//TODO: VPUNPCKLBW (R11), X9, X2        // c4c1316013
	//TODO: VPUNPCKLBW X2, X9, X2           // c4e13160d2 or c5b160d2
	//TODO: VPUNPCKLBW X11, X9, X2          // c4c13160d3
	//TODO: VPUNPCKLBW (BX), X9, X11        // c46131601b or c531601b
	//TODO: VPUNPCKLBW (R11), X9, X11       // c44131601b
	//TODO: VPUNPCKLBW X2, X9, X11          // c4613160da or c53160da
	//TODO: VPUNPCKLBW X11, X9, X11         // c4413160db
	//TODO: VPUNPCKLBW (BX), Y15, Y2        // c4e1056013 or c5856013
	//TODO: VPUNPCKLBW (R11), Y15, Y2       // c4c1056013
	//TODO: VPUNPCKLBW Y2, Y15, Y2          // c4e10560d2 or c58560d2
	//TODO: VPUNPCKLBW Y11, Y15, Y2         // c4c10560d3
	//TODO: VPUNPCKLBW (BX), Y15, Y11       // c46105601b or c505601b
	//TODO: VPUNPCKLBW (R11), Y15, Y11      // c44105601b
	//TODO: VPUNPCKLBW Y2, Y15, Y11         // c4610560da or c50560da
	//TODO: VPUNPCKLBW Y11, Y15, Y11        // c4410560db
	//TODO: VPUNPCKLDQ (BX), X9, X2         // c4e1316213 or c5b16213
	//TODO: VPUNPCKLDQ (R11), X9, X2        // c4c1316213
	//TODO: VPUNPCKLDQ X2, X9, X2           // c4e13162d2 or c5b162d2
	//TODO: VPUNPCKLDQ X11, X9, X2          // c4c13162d3
	//TODO: VPUNPCKLDQ (BX), X9, X11        // c46131621b or c531621b
	//TODO: VPUNPCKLDQ (R11), X9, X11       // c44131621b
	//TODO: VPUNPCKLDQ X2, X9, X11          // c4613162da or c53162da
	//TODO: VPUNPCKLDQ X11, X9, X11         // c4413162db
	//TODO: VPUNPCKLDQ (BX), Y15, Y2        // c4e1056213 or c5856213
	//TODO: VPUNPCKLDQ (R11), Y15, Y2       // c4c1056213
	//TODO: VPUNPCKLDQ Y2, Y15, Y2          // c4e10562d2 or c58562d2
	//TODO: VPUNPCKLDQ Y11, Y15, Y2         // c4c10562d3
	//TODO: VPUNPCKLDQ (BX), Y15, Y11       // c46105621b or c505621b
	//TODO: VPUNPCKLDQ (R11), Y15, Y11      // c44105621b
	//TODO: VPUNPCKLDQ Y2, Y15, Y11         // c4610562da or c50562da
	//TODO: VPUNPCKLDQ Y11, Y15, Y11        // c4410562db
	//TODO: VPUNPCKLQDQ (BX), X9, X2        // c4e1316c13 or c5b16c13
	//TODO: VPUNPCKLQDQ (R11), X9, X2       // c4c1316c13
	//TODO: VPUNPCKLQDQ X2, X9, X2          // c4e1316cd2 or c5b16cd2
	//TODO: VPUNPCKLQDQ X11, X9, X2         // c4c1316cd3
	//TODO: VPUNPCKLQDQ (BX), X9, X11       // c461316c1b or c5316c1b
	//TODO: VPUNPCKLQDQ (R11), X9, X11      // c441316c1b
	//TODO: VPUNPCKLQDQ X2, X9, X11         // c461316cda or c5316cda
	//TODO: VPUNPCKLQDQ X11, X9, X11        // c441316cdb
	//TODO: VPUNPCKLQDQ (BX), Y15, Y2       // c4e1056c13 or c5856c13
	//TODO: VPUNPCKLQDQ (R11), Y15, Y2      // c4c1056c13
	//TODO: VPUNPCKLQDQ Y2, Y15, Y2         // c4e1056cd2 or c5856cd2
	//TODO: VPUNPCKLQDQ Y11, Y15, Y2        // c4c1056cd3
	//TODO: VPUNPCKLQDQ (BX), Y15, Y11      // c461056c1b or c5056c1b
	//TODO: VPUNPCKLQDQ (R11), Y15, Y11     // c441056c1b
	//TODO: VPUNPCKLQDQ Y2, Y15, Y11        // c461056cda or c5056cda
	//TODO: VPUNPCKLQDQ Y11, Y15, Y11       // c441056cdb
	//TODO: VPUNPCKLWD (BX), X9, X2         // c4e1316113 or c5b16113
	//TODO: VPUNPCKLWD (R11), X9, X2        // c4c1316113
	//TODO: VPUNPCKLWD X2, X9, X2           // c4e13161d2 or c5b161d2
	//TODO: VPUNPCKLWD X11, X9, X2          // c4c13161d3
	//TODO: VPUNPCKLWD (BX), X9, X11        // c46131611b or c531611b
	//TODO: VPUNPCKLWD (R11), X9, X11       // c44131611b
	//TODO: VPUNPCKLWD X2, X9, X11          // c4613161da or c53161da
	//TODO: VPUNPCKLWD X11, X9, X11         // c4413161db
	//TODO: VPUNPCKLWD (BX), Y15, Y2        // c4e1056113 or c5856113
	//TODO: VPUNPCKLWD (R11), Y15, Y2       // c4c1056113
	//TODO: VPUNPCKLWD Y2, Y15, Y2          // c4e10561d2 or c58561d2
	//TODO: VPUNPCKLWD Y11, Y15, Y2         // c4c10561d3
	//TODO: VPUNPCKLWD (BX), Y15, Y11       // c46105611b or c505611b
	//TODO: VPUNPCKLWD (R11), Y15, Y11      // c44105611b
	//TODO: VPUNPCKLWD Y2, Y15, Y11         // c4610561da or c50561da
	//TODO: VPUNPCKLWD Y11, Y15, Y11        // c4410561db
	VPXOR (BX), X9, X2                      // c4e131ef13 or c5b1ef13
	VPXOR (R11), X9, X2                     // c4c131ef13
	VPXOR X2, X9, X2                        // c4e131efd2 or c5b1efd2
	VPXOR X11, X9, X2                       // c4c131efd3
	VPXOR (BX), X9, X11                     // c46131ef1b or c531ef1b
	VPXOR (R11), X9, X11                    // c44131ef1b
	VPXOR X2, X9, X11                       // c46131efda or c531efda
	VPXOR X11, X9, X11                      // c44131efdb
	VPXOR (BX), Y15, Y2                     // c4e105ef13 or c585ef13
	VPXOR (R11), Y15, Y2                    // c4c105ef13
	VPXOR Y2, Y15, Y2                       // c4e105efd2 or c585efd2
	VPXOR Y11, Y15, Y2                      // c4c105efd3
	VPXOR (BX), Y15, Y11                    // c46105ef1b or c505ef1b
	VPXOR (R11), Y15, Y11                   // c44105ef1b
	VPXOR Y2, Y15, Y11                      // c46105efda or c505efda
	VPXOR Y11, Y15, Y11                     // c44105efdb
	//TODO: VRCPPS (BX), X2                 // c4e1785313 or c5f85313
	//TODO: VRCPPS (R11), X2                // c4c1785313
	//TODO: VRCPPS X2, X2                   // c4e17853d2 or c5f853d2
	//TODO: VRCPPS X11, X2                  // c4c17853d3
	//TODO: VRCPPS (BX), X11                // c46178531b or c578531b
	//TODO: VRCPPS (R11), X11               // c44178531b
	//TODO: VRCPPS X2, X11                  // c4617853da or c57853da
	//TODO: VRCPPS X11, X11                 // c4417853db
	//TODO: VRCPPS (BX), Y2                 // c4e17c5313 or c5fc5313
	//TODO: VRCPPS (R11), Y2                // c4c17c5313
	//TODO: VRCPPS Y2, Y2                   // c4e17c53d2 or c5fc53d2
	//TODO: VRCPPS Y11, Y2                  // c4c17c53d3
	//TODO: VRCPPS (BX), Y11                // c4617c531b or c57c531b
	//TODO: VRCPPS (R11), Y11               // c4417c531b
	//TODO: VRCPPS Y2, Y11                  // c4617c53da or c57c53da
	//TODO: VRCPPS Y11, Y11                 // c4417c53db
	//TODO: VRCPSS (BX), X9, X2             // c4e1325313 or c5b25313
	//TODO: VRCPSS (R11), X9, X2            // c4c1325313
	//TODO: VRCPSS X2, X9, X2               // c4e13253d2 or c5b253d2
	//TODO: VRCPSS X11, X9, X2              // c4c13253d3
	//TODO: VRCPSS (BX), X9, X11            // c46132531b or c532531b
	//TODO: VRCPSS (R11), X9, X11           // c44132531b
	//TODO: VRCPSS X2, X9, X11              // c4613253da or c53253da
	//TODO: VRCPSS X11, X9, X11             // c4413253db
	//TODO: VROUNDPD $7, (BX), X2           // c4e379091307
	//TODO: VROUNDPD $7, (R11), X2          // c4c379091307
	//TODO: VROUNDPD $7, X2, X2             // c4e37909d207
	//TODO: VROUNDPD $7, X11, X2            // c4c37909d307
	//TODO: VROUNDPD $7, (BX), X11          // c46379091b07
	//TODO: VROUNDPD $7, (R11), X11         // c44379091b07
	//TODO: VROUNDPD $7, X2, X11            // c4637909da07
	//TODO: VROUNDPD $7, X11, X11           // c4437909db07
	//TODO: VROUNDPD $7, (BX), Y2           // c4e37d091307
	//TODO: VROUNDPD $7, (R11), Y2          // c4c37d091307
	//TODO: VROUNDPD $7, Y2, Y2             // c4e37d09d207
	//TODO: VROUNDPD $7, Y11, Y2            // c4c37d09d307
	//TODO: VROUNDPD $7, (BX), Y11          // c4637d091b07
	//TODO: VROUNDPD $7, (R11), Y11         // c4437d091b07
	//TODO: VROUNDPD $7, Y2, Y11            // c4637d09da07
	//TODO: VROUNDPD $7, Y11, Y11           // c4437d09db07
	//TODO: VROUNDPS $7, (BX), X2           // c4e379081307
	//TODO: VROUNDPS $7, (R11), X2          // c4c379081307
	//TODO: VROUNDPS $7, X2, X2             // c4e37908d207
	//TODO: VROUNDPS $7, X11, X2            // c4c37908d307
	//TODO: VROUNDPS $7, (BX), X11          // c46379081b07
	//TODO: VROUNDPS $7, (R11), X11         // c44379081b07
	//TODO: VROUNDPS $7, X2, X11            // c4637908da07
	//TODO: VROUNDPS $7, X11, X11           // c4437908db07
	//TODO: VROUNDPS $7, (BX), Y2           // c4e37d081307
	//TODO: VROUNDPS $7, (R11), Y2          // c4c37d081307
	//TODO: VROUNDPS $7, Y2, Y2             // c4e37d08d207
	//TODO: VROUNDPS $7, Y11, Y2            // c4c37d08d307
	//TODO: VROUNDPS $7, (BX), Y11          // c4637d081b07
	//TODO: VROUNDPS $7, (R11), Y11         // c4437d081b07
	//TODO: VROUNDPS $7, Y2, Y11            // c4637d08da07
	//TODO: VROUNDPS $7, Y11, Y11           // c4437d08db07
	//TODO: VROUNDSD $7, (BX), X9, X2       // c4e3310b1307
	//TODO: VROUNDSD $7, (R11), X9, X2      // c4c3310b1307
	//TODO: VROUNDSD $7, X2, X9, X2         // c4e3310bd207
	//TODO: VROUNDSD $7, X11, X9, X2        // c4c3310bd307
	//TODO: VROUNDSD $7, (BX), X9, X11      // c463310b1b07
	//TODO: VROUNDSD $7, (R11), X9, X11     // c443310b1b07
	//TODO: VROUNDSD $7, X2, X9, X11        // c463310bda07
	//TODO: VROUNDSD $7, X11, X9, X11       // c443310bdb07
	//TODO: VROUNDSS $7, (BX), X9, X2       // c4e3310a1307
	//TODO: VROUNDSS $7, (R11), X9, X2      // c4c3310a1307
	//TODO: VROUNDSS $7, X2, X9, X2         // c4e3310ad207
	//TODO: VROUNDSS $7, X11, X9, X2        // c4c3310ad307
	//TODO: VROUNDSS $7, (BX), X9, X11      // c463310a1b07
	//TODO: VROUNDSS $7, (R11), X9, X11     // c443310a1b07
	//TODO: VROUNDSS $7, X2, X9, X11        // c463310ada07
	//TODO: VROUNDSS $7, X11, X9, X11       // c443310adb07
	//TODO: VRSQRTPS (BX), X2               // c4e1785213 or c5f85213
	//TODO: VRSQRTPS (R11), X2              // c4c1785213
	//TODO: VRSQRTPS X2, X2                 // c4e17852d2 or c5f852d2
	//TODO: VRSQRTPS X11, X2                // c4c17852d3
	//TODO: VRSQRTPS (BX), X11              // c46178521b or c578521b
	//TODO: VRSQRTPS (R11), X11             // c44178521b
	//TODO: VRSQRTPS X2, X11                // c4617852da or c57852da
	//TODO: VRSQRTPS X11, X11               // c4417852db
	//TODO: VRSQRTPS (BX), Y2               // c4e17c5213 or c5fc5213
	//TODO: VRSQRTPS (R11), Y2              // c4c17c5213
	//TODO: VRSQRTPS Y2, Y2                 // c4e17c52d2 or c5fc52d2
	//TODO: VRSQRTPS Y11, Y2                // c4c17c52d3
	//TODO: VRSQRTPS (BX), Y11              // c4617c521b or c57c521b
	//TODO: VRSQRTPS (R11), Y11             // c4417c521b
	//TODO: VRSQRTPS Y2, Y11                // c4617c52da or c57c52da
	//TODO: VRSQRTPS Y11, Y11               // c4417c52db
	//TODO: VRSQRTSS (BX), X9, X2           // c4e1325213 or c5b25213
	//TODO: VRSQRTSS (R11), X9, X2          // c4c1325213
	//TODO: VRSQRTSS X2, X9, X2             // c4e13252d2 or c5b252d2
	//TODO: VRSQRTSS X11, X9, X2            // c4c13252d3
	//TODO: VRSQRTSS (BX), X9, X11          // c46132521b or c532521b
	//TODO: VRSQRTSS (R11), X9, X11         // c44132521b
	//TODO: VRSQRTSS X2, X9, X11            // c4613252da or c53252da
	//TODO: VRSQRTSS X11, X9, X11           // c4413252db
	//TODO: VSHUFPD $7, (BX), X9, X2        // c4e131c61307 or c5b1c61307
	//TODO: VSHUFPD $7, (R11), X9, X2       // c4c131c61307
	//TODO: VSHUFPD $7, X2, X9, X2          // c4e131c6d207 or c5b1c6d207
	//TODO: VSHUFPD $7, X11, X9, X2         // c4c131c6d307
	//TODO: VSHUFPD $7, (BX), X9, X11       // c46131c61b07 or c531c61b07
	//TODO: VSHUFPD $7, (R11), X9, X11      // c44131c61b07
	//TODO: VSHUFPD $7, X2, X9, X11         // c46131c6da07 or c531c6da07
	//TODO: VSHUFPD $7, X11, X9, X11        // c44131c6db07
	//TODO: VSHUFPD $7, (BX), Y15, Y2       // c4e105c61307 or c585c61307
	//TODO: VSHUFPD $7, (R11), Y15, Y2      // c4c105c61307
	//TODO: VSHUFPD $7, Y2, Y15, Y2         // c4e105c6d207 or c585c6d207
	//TODO: VSHUFPD $7, Y11, Y15, Y2        // c4c105c6d307
	//TODO: VSHUFPD $7, (BX), Y15, Y11      // c46105c61b07 or c505c61b07
	//TODO: VSHUFPD $7, (R11), Y15, Y11     // c44105c61b07
	//TODO: VSHUFPD $7, Y2, Y15, Y11        // c46105c6da07 or c505c6da07
	//TODO: VSHUFPD $7, Y11, Y15, Y11       // c44105c6db07
	//TODO: VSHUFPS $7, (BX), X9, X2        // c4e130c61307 or c5b0c61307
	//TODO: VSHUFPS $7, (R11), X9, X2       // c4c130c61307
	//TODO: VSHUFPS $7, X2, X9, X2          // c4e130c6d207 or c5b0c6d207
	//TODO: VSHUFPS $7, X11, X9, X2         // c4c130c6d307
	//TODO: VSHUFPS $7, (BX), X9, X11       // c46130c61b07 or c530c61b07
	//TODO: VSHUFPS $7, (R11), X9, X11      // c44130c61b07
	//TODO: VSHUFPS $7, X2, X9, X11         // c46130c6da07 or c530c6da07
	//TODO: VSHUFPS $7, X11, X9, X11        // c44130c6db07
	//TODO: VSHUFPS $7, (BX), Y15, Y2       // c4e104c61307 or c584c61307
	//TODO: VSHUFPS $7, (R11), Y15, Y2      // c4c104c61307
	//TODO: VSHUFPS $7, Y2, Y15, Y2         // c4e104c6d207 or c584c6d207
	//TODO: VSHUFPS $7, Y11, Y15, Y2        // c4c104c6d307
	//TODO: VSHUFPS $7, (BX), Y15, Y11      // c46104c61b07 or c504c61b07
	//TODO: VSHUFPS $7, (R11), Y15, Y11     // c44104c61b07
	//TODO: VSHUFPS $7, Y2, Y15, Y11        // c46104c6da07 or c504c6da07
	//TODO: VSHUFPS $7, Y11, Y15, Y11       // c44104c6db07
	//TODO: VSQRTPD (BX), X2                // c4e1795113 or c5f95113
	//TODO: VSQRTPD (R11), X2               // c4c1795113
	//TODO: VSQRTPD X2, X2                  // c4e17951d2 or c5f951d2
	//TODO: VSQRTPD X11, X2                 // c4c17951d3
	//TODO: VSQRTPD (BX), X11               // c46179511b or c579511b
	//TODO: VSQRTPD (R11), X11              // c44179511b
	//TODO: VSQRTPD X2, X11                 // c4617951da or c57951da
	//TODO: VSQRTPD X11, X11                // c4417951db
	//TODO: VSQRTPD (BX), Y2                // c4e17d5113 or c5fd5113
	//TODO: VSQRTPD (R11), Y2               // c4c17d5113
	//TODO: VSQRTPD Y2, Y2                  // c4e17d51d2 or c5fd51d2
	//TODO: VSQRTPD Y11, Y2                 // c4c17d51d3
	//TODO: VSQRTPD (BX), Y11               // c4617d511b or c57d511b
	//TODO: VSQRTPD (R11), Y11              // c4417d511b
	//TODO: VSQRTPD Y2, Y11                 // c4617d51da or c57d51da
	//TODO: VSQRTPD Y11, Y11                // c4417d51db
	//TODO: VSQRTPS (BX), X2                // c4e1785113 or c5f85113
	//TODO: VSQRTPS (R11), X2               // c4c1785113
	//TODO: VSQRTPS X2, X2                  // c4e17851d2 or c5f851d2
	//TODO: VSQRTPS X11, X2                 // c4c17851d3
	//TODO: VSQRTPS (BX), X11               // c46178511b or c578511b
	//TODO: VSQRTPS (R11), X11              // c44178511b
	//TODO: VSQRTPS X2, X11                 // c4617851da or c57851da
	//TODO: VSQRTPS X11, X11                // c4417851db
	//TODO: VSQRTPS (BX), Y2                // c4e17c5113 or c5fc5113
	//TODO: VSQRTPS (R11), Y2               // c4c17c5113
	//TODO: VSQRTPS Y2, Y2                  // c4e17c51d2 or c5fc51d2
	//TODO: VSQRTPS Y11, Y2                 // c4c17c51d3
	//TODO: VSQRTPS (BX), Y11               // c4617c511b or c57c511b
	//TODO: VSQRTPS (R11), Y11              // c4417c511b
	//TODO: VSQRTPS Y2, Y11                 // c4617c51da or c57c51da
	//TODO: VSQRTPS Y11, Y11                // c4417c51db
	//TODO: VSQRTSD (BX), X9, X2            // c4e1335113 or c5b35113
	//TODO: VSQRTSD (R11), X9, X2           // c4c1335113
	//TODO: VSQRTSD X2, X9, X2              // c4e13351d2 or c5b351d2
	//TODO: VSQRTSD X11, X9, X2             // c4c13351d3
	//TODO: VSQRTSD (BX), X9, X11           // c46133511b or c533511b
	//TODO: VSQRTSD (R11), X9, X11          // c44133511b
	//TODO: VSQRTSD X2, X9, X11             // c4613351da or c53351da
	//TODO: VSQRTSD X11, X9, X11            // c4413351db
	//TODO: VSQRTSS (BX), X9, X2            // c4e1325113 or c5b25113
	//TODO: VSQRTSS (R11), X9, X2           // c4c1325113
	//TODO: VSQRTSS X2, X9, X2              // c4e13251d2 or c5b251d2
	//TODO: VSQRTSS X11, X9, X2             // c4c13251d3
	//TODO: VSQRTSS (BX), X9, X11           // c46132511b or c532511b
	//TODO: VSQRTSS (R11), X9, X11          // c44132511b
	//TODO: VSQRTSS X2, X9, X11             // c4613251da or c53251da
	//TODO: VSQRTSS X11, X9, X11            // c4413251db
	//TODO: VSTMXCSR (BX)                   // c4e178ae1b or c5f8ae1b
	//TODO: VSTMXCSR (R11)                  // c4c178ae1b
	//TODO: VSUBPD (BX), X9, X2             // c4e1315c13 or c5b15c13
	//TODO: VSUBPD (R11), X9, X2            // c4c1315c13
	//TODO: VSUBPD X2, X9, X2               // c4e1315cd2 or c5b15cd2
	//TODO: VSUBPD X11, X9, X2              // c4c1315cd3
	//TODO: VSUBPD (BX), X9, X11            // c461315c1b or c5315c1b
	//TODO: VSUBPD (R11), X9, X11           // c441315c1b
	//TODO: VSUBPD X2, X9, X11              // c461315cda or c5315cda
	//TODO: VSUBPD X11, X9, X11             // c441315cdb
	//TODO: VSUBPD (BX), Y15, Y2            // c4e1055c13 or c5855c13
	//TODO: VSUBPD (R11), Y15, Y2           // c4c1055c13
	//TODO: VSUBPD Y2, Y15, Y2              // c4e1055cd2 or c5855cd2
	//TODO: VSUBPD Y11, Y15, Y2             // c4c1055cd3
	//TODO: VSUBPD (BX), Y15, Y11           // c461055c1b or c5055c1b
	//TODO: VSUBPD (R11), Y15, Y11          // c441055c1b
	//TODO: VSUBPD Y2, Y15, Y11             // c461055cda or c5055cda
	//TODO: VSUBPD Y11, Y15, Y11            // c441055cdb
	//TODO: VSUBPS (BX), X9, X2             // c4e1305c13 or c5b05c13
	//TODO: VSUBPS (R11), X9, X2            // c4c1305c13
	//TODO: VSUBPS X2, X9, X2               // c4e1305cd2 or c5b05cd2
	//TODO: VSUBPS X11, X9, X2              // c4c1305cd3
	//TODO: VSUBPS (BX), X9, X11            // c461305c1b or c5305c1b
	//TODO: VSUBPS (R11), X9, X11           // c441305c1b
	//TODO: VSUBPS X2, X9, X11              // c461305cda or c5305cda
	//TODO: VSUBPS X11, X9, X11             // c441305cdb
	//TODO: VSUBPS (BX), Y15, Y2            // c4e1045c13 or c5845c13
	//TODO: VSUBPS (R11), Y15, Y2           // c4c1045c13
	//TODO: VSUBPS Y2, Y15, Y2              // c4e1045cd2 or c5845cd2
	//TODO: VSUBPS Y11, Y15, Y2             // c4c1045cd3
	//TODO: VSUBPS (BX), Y15, Y11           // c461045c1b or c5045c1b
	//TODO: VSUBPS (R11), Y15, Y11          // c441045c1b
	//TODO: VSUBPS Y2, Y15, Y11             // c461045cda or c5045cda
	//TODO: VSUBPS Y11, Y15, Y11            // c441045cdb
	//TODO: VSUBSD (BX), X9, X2             // c4e1335c13 or c5b35c13
	//TODO: VSUBSD (R11), X9, X2            // c4c1335c13
	//TODO: VSUBSD X2, X9, X2               // c4e1335cd2 or c5b35cd2
	//TODO: VSUBSD X11, X9, X2              // c4c1335cd3
	//TODO: VSUBSD (BX), X9, X11            // c461335c1b or c5335c1b
	//TODO: VSUBSD (R11), X9, X11           // c441335c1b
	//TODO: VSUBSD X2, X9, X11              // c461335cda or c5335cda
	//TODO: VSUBSD X11, X9, X11             // c441335cdb
	//TODO: VSUBSS (BX), X9, X2             // c4e1325c13 or c5b25c13
	//TODO: VSUBSS (R11), X9, X2            // c4c1325c13
	//TODO: VSUBSS X2, X9, X2               // c4e1325cd2 or c5b25cd2
	//TODO: VSUBSS X11, X9, X2              // c4c1325cd3
	//TODO: VSUBSS (BX), X9, X11            // c461325c1b or c5325c1b
	//TODO: VSUBSS (R11), X9, X11           // c441325c1b
	//TODO: VSUBSS X2, X9, X11              // c461325cda or c5325cda
	//TODO: VSUBSS X11, X9, X11             // c441325cdb
	//TODO: VTESTPD (BX), X2                // c4e2790f13
	//TODO: VTESTPD (R11), X2               // c4c2790f13
	//TODO: VTESTPD X2, X2                  // c4e2790fd2
	//TODO: VTESTPD X11, X2                 // c4c2790fd3
	//TODO: VTESTPD (BX), X11               // c462790f1b
	//TODO: VTESTPD (R11), X11              // c442790f1b
	//TODO: VTESTPD X2, X11                 // c462790fda
	//TODO: VTESTPD X11, X11                // c442790fdb
	//TODO: VTESTPD (BX), Y2                // c4e27d0f13
	//TODO: VTESTPD (R11), Y2               // c4c27d0f13
	//TODO: VTESTPD Y2, Y2                  // c4e27d0fd2
	//TODO: VTESTPD Y11, Y2                 // c4c27d0fd3
	//TODO: VTESTPD (BX), Y11               // c4627d0f1b
	//TODO: VTESTPD (R11), Y11              // c4427d0f1b
	//TODO: VTESTPD Y2, Y11                 // c4627d0fda
	//TODO: VTESTPD Y11, Y11                // c4427d0fdb
	//TODO: VTESTPS (BX), X2                // c4e2790e13
	//TODO: VTESTPS (R11), X2               // c4c2790e13
	//TODO: VTESTPS X2, X2                  // c4e2790ed2
	//TODO: VTESTPS X11, X2                 // c4c2790ed3
	//TODO: VTESTPS (BX), X11               // c462790e1b
	//TODO: VTESTPS (R11), X11              // c442790e1b
	//TODO: VTESTPS X2, X11                 // c462790eda
	//TODO: VTESTPS X11, X11                // c442790edb
	//TODO: VTESTPS (BX), Y2                // c4e27d0e13
	//TODO: VTESTPS (R11), Y2               // c4c27d0e13
	//TODO: VTESTPS Y2, Y2                  // c4e27d0ed2
	//TODO: VTESTPS Y11, Y2                 // c4c27d0ed3
	//TODO: VTESTPS (BX), Y11               // c4627d0e1b
	//TODO: VTESTPS (R11), Y11              // c4427d0e1b
	//TODO: VTESTPS Y2, Y11                 // c4627d0eda
	//TODO: VTESTPS Y11, Y11                // c4427d0edb
	//TODO: VUCOMISD (BX), X2               // c4e1792e13 or c5f92e13
	//TODO: VUCOMISD (R11), X2              // c4c1792e13
	//TODO: VUCOMISD X2, X2                 // c4e1792ed2 or c5f92ed2
	//TODO: VUCOMISD X11, X2                // c4c1792ed3
	//TODO: VUCOMISD (BX), X11              // c461792e1b or c5792e1b
	//TODO: VUCOMISD (R11), X11             // c441792e1b
	//TODO: VUCOMISD X2, X11                // c461792eda or c5792eda
	//TODO: VUCOMISD X11, X11               // c441792edb
	//TODO: VUCOMISS (BX), X2               // c4e1782e13 or c5f82e13
	//TODO: VUCOMISS (R11), X2              // c4c1782e13
	//TODO: VUCOMISS X2, X2                 // c4e1782ed2 or c5f82ed2
	//TODO: VUCOMISS X11, X2                // c4c1782ed3
	//TODO: VUCOMISS (BX), X11              // c461782e1b or c5782e1b
	//TODO: VUCOMISS (R11), X11             // c441782e1b
	//TODO: VUCOMISS X2, X11                // c461782eda or c5782eda
	//TODO: VUCOMISS X11, X11               // c441782edb
	//TODO: VUNPCKHPD (BX), X9, X2          // c4e1311513 or c5b11513
	//TODO: VUNPCKHPD (R11), X9, X2         // c4c1311513
	//TODO: VUNPCKHPD X2, X9, X2            // c4e13115d2 or c5b115d2
	//TODO: VUNPCKHPD X11, X9, X2           // c4c13115d3
	//TODO: VUNPCKHPD (BX), X9, X11         // c46131151b or c531151b
	//TODO: VUNPCKHPD (R11), X9, X11        // c44131151b
	//TODO: VUNPCKHPD X2, X9, X11           // c4613115da or c53115da
	//TODO: VUNPCKHPD X11, X9, X11          // c4413115db
	//TODO: VUNPCKHPD (BX), Y15, Y2         // c4e1051513 or c5851513
	//TODO: VUNPCKHPD (R11), Y15, Y2        // c4c1051513
	//TODO: VUNPCKHPD Y2, Y15, Y2           // c4e10515d2 or c58515d2
	//TODO: VUNPCKHPD Y11, Y15, Y2          // c4c10515d3
	//TODO: VUNPCKHPD (BX), Y15, Y11        // c46105151b or c505151b
	//TODO: VUNPCKHPD (R11), Y15, Y11       // c44105151b
	//TODO: VUNPCKHPD Y2, Y15, Y11          // c4610515da or c50515da
	//TODO: VUNPCKHPD Y11, Y15, Y11         // c4410515db
	//TODO: VUNPCKHPS (BX), X9, X2          // c4e1301513 or c5b01513
	//TODO: VUNPCKHPS (R11), X9, X2         // c4c1301513
	//TODO: VUNPCKHPS X2, X9, X2            // c4e13015d2 or c5b015d2
	//TODO: VUNPCKHPS X11, X9, X2           // c4c13015d3
	//TODO: VUNPCKHPS (BX), X9, X11         // c46130151b or c530151b
	//TODO: VUNPCKHPS (R11), X9, X11        // c44130151b
	//TODO: VUNPCKHPS X2, X9, X11           // c4613015da or c53015da
	//TODO: VUNPCKHPS X11, X9, X11          // c4413015db
	//TODO: VUNPCKHPS (BX), Y15, Y2         // c4e1041513 or c5841513
	//TODO: VUNPCKHPS (R11), Y15, Y2        // c4c1041513
	//TODO: VUNPCKHPS Y2, Y15, Y2           // c4e10415d2 or c58415d2
	//TODO: VUNPCKHPS Y11, Y15, Y2          // c4c10415d3
	//TODO: VUNPCKHPS (BX), Y15, Y11        // c46104151b or c504151b
	//TODO: VUNPCKHPS (R11), Y15, Y11       // c44104151b
	//TODO: VUNPCKHPS Y2, Y15, Y11          // c4610415da or c50415da
	//TODO: VUNPCKHPS Y11, Y15, Y11         // c4410415db
	//TODO: VUNPCKLPD (BX), X9, X2          // c4e1311413 or c5b11413
	//TODO: VUNPCKLPD (R11), X9, X2         // c4c1311413
	//TODO: VUNPCKLPD X2, X9, X2            // c4e13114d2 or c5b114d2
	//TODO: VUNPCKLPD X11, X9, X2           // c4c13114d3
	//TODO: VUNPCKLPD (BX), X9, X11         // c46131141b or c531141b
	//TODO: VUNPCKLPD (R11), X9, X11        // c44131141b
	//TODO: VUNPCKLPD X2, X9, X11           // c4613114da or c53114da
	//TODO: VUNPCKLPD X11, X9, X11          // c4413114db
	//TODO: VUNPCKLPD (BX), Y15, Y2         // c4e1051413 or c5851413
	//TODO: VUNPCKLPD (R11), Y15, Y2        // c4c1051413
	//TODO: VUNPCKLPD Y2, Y15, Y2           // c4e10514d2 or c58514d2
	//TODO: VUNPCKLPD Y11, Y15, Y2          // c4c10514d3
	//TODO: VUNPCKLPD (BX), Y15, Y11        // c46105141b or c505141b
	//TODO: VUNPCKLPD (R11), Y15, Y11       // c44105141b
	//TODO: VUNPCKLPD Y2, Y15, Y11          // c4610514da or c50514da
	//TODO: VUNPCKLPD Y11, Y15, Y11         // c4410514db
	//TODO: VUNPCKLPS (BX), X9, X2          // c4e1301413 or c5b01413
	//TODO: VUNPCKLPS (R11), X9, X2         // c4c1301413
	//TODO: VUNPCKLPS X2, X9, X2            // c4e13014d2 or c5b014d2
	//TODO: VUNPCKLPS X11, X9, X2           // c4c13014d3
	//TODO: VUNPCKLPS (BX), X9, X11         // c46130141b or c530141b
	//TODO: VUNPCKLPS (R11), X9, X11        // c44130141b
	//TODO: VUNPCKLPS X2, X9, X11           // c4613014da or c53014da
	//TODO: VUNPCKLPS X11, X9, X11          // c4413014db
	//TODO: VUNPCKLPS (BX), Y15, Y2         // c4e1041413 or c5841413
	//TODO: VUNPCKLPS (R11), Y15, Y2        // c4c1041413
	//TODO: VUNPCKLPS Y2, Y15, Y2           // c4e10414d2 or c58414d2
	//TODO: VUNPCKLPS Y11, Y15, Y2          // c4c10414d3
	//TODO: VUNPCKLPS (BX), Y15, Y11        // c46104141b or c504141b
	//TODO: VUNPCKLPS (R11), Y15, Y11       // c44104141b
	//TODO: VUNPCKLPS Y2, Y15, Y11          // c4610414da or c50414da
	//TODO: VUNPCKLPS Y11, Y15, Y11         // c4410414db
	//TODO: VXORPD (BX), X9, X2             // c4e1315713 or c5b15713
	//TODO: VXORPD (R11), X9, X2            // c4c1315713
	//TODO: VXORPD X2, X9, X2               // c4e13157d2 or c5b157d2
	//TODO: VXORPD X11, X9, X2              // c4c13157d3
	//TODO: VXORPD (BX), X9, X11            // c46131571b or c531571b
	//TODO: VXORPD (R11), X9, X11           // c44131571b
	//TODO: VXORPD X2, X9, X11              // c4613157da or c53157da
	//TODO: VXORPD X11, X9, X11             // c4413157db
	//TODO: VXORPD (BX), Y15, Y2            // c4e1055713 or c5855713
	//TODO: VXORPD (R11), Y15, Y2           // c4c1055713
	//TODO: VXORPD Y2, Y15, Y2              // c4e10557d2 or c58557d2
	//TODO: VXORPD Y11, Y15, Y2             // c4c10557d3
	//TODO: VXORPD (BX), Y15, Y11           // c46105571b or c505571b
	//TODO: VXORPD (R11), Y15, Y11          // c44105571b
	//TODO: VXORPD Y2, Y15, Y11             // c4610557da or c50557da
	//TODO: VXORPD Y11, Y15, Y11            // c4410557db
	//TODO: VXORPS (BX), X9, X2             // c4e1305713 or c5b05713
	//TODO: VXORPS (R11), X9, X2            // c4c1305713
	//TODO: VXORPS X2, X9, X2               // c4e13057d2 or c5b057d2
	//TODO: VXORPS X11, X9, X2              // c4c13057d3
	//TODO: VXORPS (BX), X9, X11            // c46130571b or c530571b
	//TODO: VXORPS (R11), X9, X11           // c44130571b
	//TODO: VXORPS X2, X9, X11              // c4613057da or c53057da
	//TODO: VXORPS X11, X9, X11             // c4413057db
	//TODO: VXORPS (BX), Y15, Y2            // c4e1045713 or c5845713
	//TODO: VXORPS (R11), Y15, Y2           // c4c1045713
	//TODO: VXORPS Y2, Y15, Y2              // c4e10457d2 or c58457d2
	//TODO: VXORPS Y11, Y15, Y2             // c4c10457d3
	//TODO: VXORPS (BX), Y15, Y11           // c46104571b or c504571b
	//TODO: VXORPS (R11), Y15, Y11          // c44104571b
	//TODO: VXORPS Y2, Y15, Y11             // c4610457da or c50457da
	//TODO: VXORPS Y11, Y15, Y11            // c4410457db
	//TODO: VZEROALL                        // c4e17c77 or c5fc77
	VZEROUPPER                              // c4e17877 or c5f877
	WBINVD                                  // 0f09
	//TODO: WRFSBASE DX                     // f30faed2 or f3480faed2
	//TODO: WRFSBASE R11                    // f3410faed3 or f3490faed3
	//TODO: WRGSBASE DX                     // f30faeda or f3480faeda
	//TODO: WRGSBASE R11                    // f3410faedb or f3490faedb
	WRMSR                                   // 0f30
	//TODO: WRPKRU                          // 0f01ef
	XABORT $7                               // c6f807
	XADDW DX, (BX)                          // 660fc113
	XADDW R11, (BX)                         // 66440fc11b
	XADDW DX, (R11)                         // 66410fc113
	XADDW R11, (R11)                        // 66450fc11b
	XADDW DX, DX                            // 660fc1d2
	XADDW R11, DX                           // 66440fc1da
	XADDW DX, R11                           // 66410fc1d3
	XADDW R11, R11                          // 66450fc1db
	XADDL DX, (BX)                          // 0fc113
	XADDL R11, (BX)                         // 440fc11b
	XADDL DX, (R11)                         // 410fc113
	XADDL R11, (R11)                        // 450fc11b
	XADDL DX, DX                            // 0fc1d2
	XADDL R11, DX                           // 440fc1da
	XADDL DX, R11                           // 410fc1d3
	XADDL R11, R11                          // 450fc1db
	XADDQ DX, (BX)                          // 480fc113
	XADDQ R11, (BX)                         // 4c0fc11b
	XADDQ DX, (R11)                         // 490fc113
	XADDQ R11, (R11)                        // 4d0fc11b
	XADDQ DX, DX                            // 480fc1d2
	XADDQ R11, DX                           // 4c0fc1da
	XADDQ DX, R11                           // 490fc1d3
	XADDQ R11, R11                          // 4d0fc1db
	XADDB DL, (BX)                          // 0fc013
	XADDB R11, (BX)                         // 440fc01b
	XADDB DL, (R11)                         // 410fc013
	XADDB R11, (R11)                        // 450fc01b
	XADDB DL, DL                            // 0fc0d2
	XADDB R11, DL                           // 440fc0da
	XADDB DL, R11                           // 410fc0d3
	XADDB R11, R11                          // 450fc0db
	//TODO: XBEGIN .+$0x1122                // 66c7f82211
	//TODO: XBEGIN .+$0x11223344            // c7f844332211
	XCHGW DX, (BX)                          // 668713
	XCHGW R11, (BX)                         // 6644871b
	XCHGW DX, (R11)                         // 66418713
	XCHGW R11, (R11)                        // 6645871b
	XCHGW DX, DX                            // 6687d2
	XCHGW R11, DX                           // 664487da
	XCHGW DX, R11                           // 664187d3
	XCHGW R11, R11                          // 664587db
	XCHGL DX, (BX)                          // 8713
	XCHGL R11, (BX)                         // 44871b
	XCHGL DX, (R11)                         // 418713
	XCHGL R11, (R11)                        // 45871b
	XCHGL DX, DX                            // 87d2
	XCHGL R11, DX                           // 4487da
	XCHGL DX, R11                           // 4187d3
	XCHGL R11, R11                          // 4587db
	XCHGQ DX, (BX)                          // 488713
	XCHGQ R11, (BX)                         // 4c871b
	XCHGQ DX, (R11)                         // 498713
	XCHGQ R11, (R11)                        // 4d871b
	XCHGQ DX, DX                            // 4887d2
	XCHGQ R11, DX                           // 4c87da
	XCHGQ DX, R11                           // 4987d3
	XCHGQ R11, R11                          // 4d87db
	XCHGB DL, (BX)                          // 8613
	XCHGB R11, (BX)                         // 44861b
	XCHGB DL, (R11)                         // 418613
	XCHGB R11, (R11)                        // 45861b
	XCHGB DL, DL                            // 86d2
	XCHGB R11, DL                           // 4486da
	XCHGB DL, R11                           // 4186d3
	XCHGB R11, R11                          // 4586db
	XCHGW AX, DX                            // 6692
	XCHGW AX, R11                           // 664193
	XCHGL AX, DX                            // 92
	XCHGL AX, R11                           // 4193
	XCHGQ AX, DX                            // 4892
	XCHGQ AX, R11                           // 4993
	XEND                                    // 0f01d5
	XGETBV                                  // 0f01d0
	XLAT                                    // d7
	XORB $7, AL                             // 3407
	XORW $61731, AX                         // 663523f1
	XORL $4045620583, AX                    // 35674523f1
	XORQ $-249346713, AX                    // 4835674523f1
	XORW $61731, (BX)                       // 66813323f1
	XORW $61731, (R11)                      // 6641813323f1
	XORW $61731, DX                         // 6681f223f1
	XORW $61731, R11                        // 664181f323f1
	XORW $7, (BX)                           // 66833307
	XORW $7, (R11)                          // 6641833307
	XORW $7, DX                             // 6683f207
	XORW $7, R11                            // 664183f307
	XORW DX, (BX)                           // 663113
	XORW R11, (BX)                          // 6644311b
	XORW DX, (R11)                          // 66413113
	XORW R11, (R11)                         // 6645311b
	XORW DX, DX                             // 6631d2 or 6633d2
	XORW R11, DX                            // 664431da or 664133d3
	XORW DX, R11                            // 664131d3 or 664433da
	XORW R11, R11                           // 664531db or 664533db
	XORL $4045620583, (BX)                  // 8133674523f1
	XORL $4045620583, (R11)                 // 418133674523f1
	XORL $4045620583, DX                    // 81f2674523f1
	XORL $4045620583, R11                   // 4181f3674523f1
	XORL $7, (BX)                           // 833307
	XORL $7, (R11)                          // 41833307
	XORL $7, DX                             // 83f207
	XORL $7, R11                            // 4183f307
	XORL DX, (BX)                           // 3113
	XORL R11, (BX)                          // 44311b
	XORL DX, (R11)                          // 413113
	XORL R11, (R11)                         // 45311b
	XORL DX, DX                             // 31d2 or 33d2
	XORL R11, DX                            // 4431da or 4133d3
	XORL DX, R11                            // 4131d3 or 4433da
	XORL R11, R11                           // 4531db or 4533db
	XORQ $-249346713, (BX)                  // 488133674523f1
	XORQ $-249346713, (R11)                 // 498133674523f1
	XORQ $-249346713, DX                    // 4881f2674523f1
	XORQ $-249346713, R11                   // 4981f3674523f1
	XORQ $7, (BX)                           // 48833307
	XORQ $7, (R11)                          // 49833307
	XORQ $7, DX                             // 4883f207
	XORQ $7, R11                            // 4983f307
	XORQ DX, (BX)                           // 483113
	XORQ R11, (BX)                          // 4c311b
	XORQ DX, (R11)                          // 493113
	XORQ R11, (R11)                         // 4d311b
	XORQ DX, DX                             // 4831d2 or 4833d2
	XORQ R11, DX                            // 4c31da or 4933d3
	XORQ DX, R11                            // 4931d3 or 4c33da
	XORQ R11, R11                           // 4d31db or 4d33db
	XORB $7, (BX)                           // 803307
	XORB $7, (R11)                          // 41803307
	XORB $7, DL                             // 80f207
	XORB $7, R11                            // 4180f307
	XORB DL, (BX)                           // 3013
	XORB R11, (BX)                          // 44301b
	XORB DL, (R11)                          // 413013
	XORB R11, (R11)                         // 45301b
	XORB DL, DL                             // 30d2 or 32d2
	XORB R11, DL                            // 4430da or 4132d3
	XORB DL, R11                            // 4130d3 or 4432da
	XORB R11, R11                           // 4530db or 4532db
	XORW (BX), DX                           // 663313
	XORW (R11), DX                          // 66413313
	XORW (BX), R11                          // 6644331b
	XORW (R11), R11                         // 6645331b
	XORL (BX), DX                           // 3313
	XORL (R11), DX                          // 413313
	XORL (BX), R11                          // 44331b
	XORL (R11), R11                         // 45331b
	XORQ (BX), DX                           // 483313
	XORQ (R11), DX                          // 493313
	XORQ (BX), R11                          // 4c331b
	XORQ (R11), R11                         // 4d331b
	XORB (BX), DL                           // 3213
	XORB (R11), DL                          // 413213
	XORB (BX), R11                          // 44321b
	XORB (R11), R11                         // 45321b
	XORPD (BX), X2                          // 660f5713
	XORPD (R11), X2                         // 66410f5713
	XORPD X2, X2                            // 660f57d2
	XORPD X11, X2                           // 66410f57d3
	XORPD (BX), X11                         // 66440f571b
	XORPD (R11), X11                        // 66450f571b
	XORPD X2, X11                           // 66440f57da
	XORPD X11, X11                          // 66450f57db
	XORPS (BX), X2                          // 0f5713
	XORPS (R11), X2                         // 410f5713
	XORPS X2, X2                            // 0f57d2
	XORPS X11, X2                           // 410f57d3
	XORPS (BX), X11                         // 440f571b
	XORPS (R11), X11                        // 450f571b
	XORPS X2, X11                           // 440f57da
	XORPS X11, X11                          // 450f57db
	//TODO: XRSTOR (BX)                     // 0fae2b
	//TODO: XRSTOR (R11)                    // 410fae2b
	//TODO: XRSTOR64 (BX)                   // 480fae2b
	//TODO: XRSTOR64 (R11)                  // 490fae2b
	//TODO: XRSTORS (BX)                    // 0fc71b
	//TODO: XRSTORS (R11)                   // 410fc71b
	//TODO: XRSTORS64 (BX)                  // 480fc71b
	//TODO: XRSTORS64 (R11)                 // 490fc71b
	//TODO: XSAVE (BX)                      // 0fae23
	//TODO: XSAVE (R11)                     // 410fae23
	//TODO: XSAVE64 (BX)                    // 480fae23
	//TODO: XSAVE64 (R11)                   // 490fae23
	//TODO: XSAVEC (BX)                     // 0fc723
	//TODO: XSAVEC (R11)                    // 410fc723
	//TODO: XSAVEC64 (BX)                   // 480fc723
	//TODO: XSAVEC64 (R11)                  // 490fc723
	//TODO: XSAVEOPT (BX)                   // 0fae33
	//TODO: XSAVEOPT (R11)                  // 410fae33
	//TODO: XSAVEOPT64 (BX)                 // 480fae33
	//TODO: XSAVEOPT64 (R11)                // 490fae33
	//TODO: XSAVES (BX)                     // 0fc72b
	//TODO: XSAVES (R11)                    // 410fc72b
	//TODO: XSAVES64 (BX)                   // 480fc72b
	//TODO: XSAVES64 (R11)                  // 490fc72b
	//TODO: XSETBV                          // 0f01d1
	XTEST                                   // 0f01d6
	RET
                                                                                                                                                                                                                                                                                          usr/local/go/src/cmd/asm/internal/asm/testdata/amd64error.s                                         0100644 0000000 0000000 00000000360 13020111411 022224  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2016 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

TEXT errors(SB),$0
	MOVL	foo<>(SB)(AX), AX // ERROR "invalid instruction"
	RET
                                                                                                                                                                                                                                                                                usr/local/go/src/cmd/asm/internal/asm/testdata/arm.s                                                0100644 0000000 0000000 00000012114 13020111411 021016  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2015 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This input was created by taking the instruction productions in
// the old assembler's (5a's) grammar and hand-writing complete
// instructions for each rule, to guarantee we cover the same space.

TEXT	foo(SB), 7, $0

// ADD
//
//	LTYPE1 cond imsr ',' spreg ',' reg
//	{
//		outcode($1, $2, &$3, $5, &$7);
//	}
// Cover some operand space here too.
	ADD	$1, R2, R3
	ADD	R1<<R2, R3, R4
	ADD	R1>>R2, R3, R4
	ADD	R1@>R2, R3, R4
	ADD	R1->R2, R3, R4
	ADD	R1, R2, R3
	ADD	R(1)<<R(2), R(3), R(4) // ADD	R1<<R2, R3, R4

//	LTYPE1 cond imsr ',' spreg ',' // asm doesn't support trailing comma.
//	{
//		outcode($1, $2, &$3, $5, &nullgen);
//	}
//	LTYPE1 cond imsr ',' reg
//	{
//		outcode($1, $2, &$3, 0, &$5);
//	}
	ADD	$1, R2
	ADD	R1<<R2, R3
	ADD	R1>>R2, R3
	ADD	R1@>R2, R3
	ADD	R1->R2, R3
	ADD	R1, R2

//
// MVN
//
//	LTYPE2 cond imsr ',' reg
//	{
//		outcode($1, $2, &$3, 0, &$5);
//	}
	CLZ.S	R1, R2

//
// MOVW
//
//	LTYPE3 cond gen ',' gen
//	{
//		outcode($1, $2, &$3, 0, &$5);
//	}
	MOVW.S	R1, R2
	MOVW.S	$1, R2
	MOVW.S	R1<<R2, R3

//
// B/BL
//
//	LTYPE4 cond comma rel
//	{
//		outcode($1, $2, &nullgen, 0, &$4);
//	}
	B.EQ	1(PC) // BEQ 1(PC)

//	LTYPE4 cond comma nireg
//	{
//		outcode($1, $2, &nullgen, 0, &$4);
//	}
	BEQ	2(PC)
	B	foo(SB) // JMP foo(SB)
	BEQ	2(PC)
	B	bar<>(SB) // JMP bar<>(SB)

//
// BX
//
//	LTYPEBX comma ireg
//	{
//		outcode($1, Always, &nullgen, 0, &$3);
//	}
	BX	(R0)

//
// BEQ
//
//	LTYPE5 comma rel
//	{
//		outcode($1, Always, &nullgen, 0, &$3);
//	}
	BEQ	1(PC)

//
// SWI
//
//	LTYPE6 cond comma gen
//	{
//		outcode($1, $2, &nullgen, 0, &$4);
//	}
	SWI.S	$2
	SWI.S	(R1)
//	SWI.S	foo(SB) - TODO: classifying foo(SB) as C_TLS_LE

//
// CMP
//
//	LTYPE7 cond imsr ',' spreg
//	{
//		outcode($1, $2, &$3, $5, &nullgen);
//	}
	CMP.S	$1, R2
	CMP.S	R1<<R2, R3
	CMP.S	R1, R2

//
// MOVM
//
//	LTYPE8 cond ioreg ',' '[' reglist ']'
//	{
//		var g obj.Addr
//
//		g = nullgen;
//		g.Type = obj.TYPE_CONST;
//		g.Offset = int64($6);
//		outcode($1, $2, &$3, 0, &g);
//	}
	MOVM	0(R1), [R2,R5,R8,g] // MOVM	(R1), [R2,R5,R8,g]
	MOVM	(R1), [R2-R5] // MOVM (R1), [R2,R3,R4,R5]
	MOVM.S	(R1), [R2]

//	LTYPE8 cond '[' reglist ']' ',' ioreg
//	{
//		var g obj.Addr
//
//		g = nullgen;
//		g.Type = obj.TYPE_CONST;
//		g.Offset = int64($4);
//		outcode($1, $2, &g, 0, &$7);
//	}
	MOVM	[R2,R5,R8,g], 0(R1) // MOVM	[R2,R5,R8,g], (R1)
	MOVM	[R2-R5], (R1) // MOVM [R2,R3,R4,R5], (R1)
	MOVM.S	[R2], (R1)

//
// SWAP
//
//	LTYPE9 cond reg ',' ireg ',' reg
//	{
//		outcode($1, $2, &$5, int32($3.Reg), &$7);
//	}
	STREX.S	R1, (R2), R3 // STREX.S (R2), R1, R3

//	LTYPE9 cond reg ',' ireg
//	{
//		outcode($1, $2, &$5, int32($3.Reg), &$3);
//	}
	STREX.S	R1, (R2) // STREX.S (R2), R1, R1

//	LTYPE9 cond comma ireg ',' reg
//	{
//		outcode($1, $2, &$4, int32($6.Reg), &$6);
//	}
	STREX.S	(R2), R3 // STREX.S (R2), R3, R3

//
// word
//
//	LTYPEH comma ximm
//	{
//		outcode($1, Always, &nullgen, 0, &$3);
//	}
	WORD	$1234

//
// floating-point coprocessor
//
//	LTYPEI cond freg ',' freg
//	{
//		outcode($1, $2, &$3, 0, &$5);
//	}
	ABSF.S	F1, F2

//	LTYPEK cond frcon ',' freg
//	{
//		outcode($1, $2, &$3, 0, &$5);
//	}
	ADDD.S	F1, F2
	MOVF	$0.5, F2 // MOVF $(0.5), F2

//	LTYPEK cond frcon ',' LFREG ',' freg
//	{
//		outcode($1, $2, &$3, $5, &$7);
//	}
	ADDD.S	F1, F2, F3

//	LTYPEL cond freg ',' freg
//	{
//		outcode($1, $2, &$3, int32($5.Reg), &nullgen);
//	}
	CMPD.S	F1, F2

//
// MCR MRC
//
//	LTYPEJ cond con ',' expr ',' spreg ',' creg ',' creg oexpr
//	{
//		var g obj.Addr
//
//		g = nullgen;
//		g.Type = obj.TYPE_CONST;
//		g.Offset = int64(
//			(0xe << 24) |		/* opcode */
//			($1 << 20) |		/* MCR/MRC */
//			(($2^C_SCOND_XOR) << 28) |		/* scond */
//			(($3 & 15) << 8) |	/* coprocessor number */
//			(($5 & 7) << 21) |	/* coprocessor operation */
//			(($7 & 15) << 12) |	/* arm register */
//			(($9 & 15) << 16) |	/* Crn */
//			(($11 & 15) << 0) |	/* Crm */
//			(($12 & 7) << 5) |	/* coprocessor information */
//			(1<<4));			/* must be set */
//		outcode(AMRC, Always, &nullgen, 0, &g);
//	}
	MRC.S	4, 6, R1, C2, C3, 7 // MRC $8301712627
	MCR.S	4, 6, R1, C2, C3, 7 // MRC $8300664051

//
// MULL r1,r2,(hi,lo)
//
//	LTYPEM cond reg ',' reg ',' regreg
//	{
//		outcode($1, $2, &$3, int32($5.Reg), &$7);
//	}
	MULL	R1, R2, (R3,R4)

//
// MULA r1,r2,r3,r4: (r1*r2+r3) & 0xffffffff . r4
// MULAW{T,B} r1,r2,r3,r4
//
//	LTYPEN cond reg ',' reg ',' reg ',' spreg
//	{
//		$7.Type = obj.TYPE_REGREG2;
//		$7.Offset = int64($9);
//		outcode($1, $2, &$3, int32($5.Reg), &$7);
//	}
	MULAWT	R1, R2, R3, R4
//
// PLD
//
//	LTYPEPLD oreg
//	{
//		outcode($1, Always, &$2, 0, &nullgen);
//	}
	PLD	(R1)
	PLD	4(R1)

//
// RET
//
//	LTYPEA cond
//	{
//		outcode($1, $2, &nullgen, 0, &nullgen);
//	}
	BEQ	2(PC)
	RET

// More B/BL cases, and canonical names JMP, CALL.

	BEQ	2(PC)
	B	foo(SB) // JMP foo(SB)
	BL	foo(SB) // CALL foo(SB)
	BEQ	2(PC)
	JMP	foo(SB)
	CALL	foo(SB)

// CMPF and CMPD are special.
	CMPF F1, F2
	CMPD F1, F2

//
// END
//
//	LTYPEE
//	{
//		outcode($1, Always, &nullgen, 0, &nullgen);
//	}
	END
                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/local/go/src/cmd/asm/internal/asm/testdata/arm64.s                                              0100644 0000000 0000000 00000007705 13020111411 021202  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2015 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This input was created by taking the instruction productions in
// the old assembler's (7a's) grammar and hand-writing complete
// instructions for each rule, to guarantee we cover the same space.

TEXT	foo(SB), 7, $-8

//
// ADD
//
//	LTYPE1 imsr ',' spreg ',' reg
//	{
//		outcode($1, &$2, $4, &$6);
//	}
// imsr comes from the old 7a, we only support immediates and registers
// at the moment, no shifted registers.
	ADDW	$1, R2, R3
	ADDW	R1, R2, R3
	ADDW	R1, ZR, R3
	ADD	$1, R2, R3
	ADD	R1, R2, R3
	ADD	R1, ZR, R3
	ADD	$1, R2, R3

//	LTYPE1 imsr ',' spreg ','
//	{
//		outcode($1, &$2, $4, &nullgen);
//	}
//	LTYPE1 imsr ',' reg
//	{
//		outcode($1, &$2, NREG, &$4);
//	}
	ADDW	$1, R2
	ADDW	R1, R2
	ADD	$1, R2
	ADD	R1, R2

//
// CLS
//
//	LTYPE2 imsr ',' reg
//	{
//		outcode($1, &$2, NREG, &$4);
//	}
	CLSW	R1, R2
	CLS	R1, R2

//
// MOV
//
//	LTYPE3 addr ',' addr
//	{
//		outcode($1, &$2, NREG, &$4);
//	}
	MOVW	R1, R2
	MOVW	ZR, R1
	MOVW	R1, ZR
	MOVW	$1, ZR
	MOVW	$1, R1
	MOVW	ZR, (R1)
	MOVD	R1, R2
	MOVD	ZR, R1
	MOVD	$1, ZR
	MOVD	$1, R1
	MOVD	ZR, (R1)

//
// MOVK
//
//		LMOVK imm ',' reg
//	{
//		outcode($1, &$2, NREG, &$4);
//	}
	MOVK	$1, R1

//
// B/BL
//
//		LTYPE4 comma rel
//	{
//		outcode($1, &nullgen, NREG, &$3);
//	}
	BL	1(PC) // CALL 1(PC)

//		LTYPE4 comma nireg
//	{
//		outcode($1, &nullgen, NREG, &$3);
//	}
	BL	(R2) // CALL (R2)
	BL	foo(SB) // CALL foo(SB)
	BL	bar<>(SB) // CALL bar<>(SB)
//
// BEQ
//
//		LTYPE5 comma rel
//	{
//		outcode($1, &nullgen, NREG, &$3);
//	}
	BEQ	1(PC)
//
// SVC
//
//		LTYPE6
//	{
//		outcode($1, &nullgen, NREG, &nullgen);
//	}
	SVC

//
// CMP
//
//		LTYPE7 imsr ',' spreg comma
//	{
//		outcode($1, &$2, $4, &nullgen);
//	}
	CMP	$3, R2
	CMP	R1, R2

//
// CBZ
//
//		LTYPE8 reg ',' rel
//	{
//		outcode($1, &$2, NREG, &$4);
//	}
again:
	CBZ	R1, again // CBZ R1

//
// CSET
//
//		LTYPER cond ',' reg
//	{
//		outcode($1, &$2, NREG, &$4);
//	}
	CSET	GT, R1
//
// CSEL/CSINC/CSNEG/CSINV
//
//		LTYPES cond ',' reg ',' reg ',' reg
//	{
//		outgcode($1, &$2, $6.reg, &$4, &$8);
//	}
	CSEL	LT, R1, R2, ZR
	CSINC	GT, R1, ZR, R3
	CSNEG	MI, R1, R2, R3
	CSINV	CS, R1, R2, R3 // CSINV HS, R1, R2, R3

//		LTYPES cond ',' reg ',' reg
//	{
//		outcode($1, &$2, $4.reg, &$6);
//	}
	CSEL	LT, R1, R2
//
// CCMN
//
//		LTYPEU cond ',' imsr ',' reg ',' imm comma
//	{
//		outgcode($1, &$2, $6.reg, &$4, &$8);
//	}
	CCMN	MI, ZR, R1, $4

//
// FADDD
//
//		LTYPEK frcon ',' freg
//	{
//		outcode($1, &$2, NREG, &$4);
//	}
	FADDD	$0.5, F1 // FADDD $(0.5), F1
	FADDD	F1, F2

//		LTYPEK frcon ',' freg ',' freg
//	{
//		outcode($1, &$2, $4.reg, &$6);
//	}
	FADDD	$0.7, F1, F2 // FADDD	$(0.69999999999999996), F1, F2
	FADDD	F1, F2, F3

//
// FCMP
//
//		LTYPEL frcon ',' freg comma
//	{
//		outcode($1, &$2, $4.reg, &nullgen);
//	}
//	FCMP	$0.2, F1
//	FCMP	F1, F2

//
// FCCMP
//
//		LTYPEF cond ',' freg ',' freg ',' imm comma
//	{
//		outgcode($1, &$2, $6.reg, &$4, &$8);
//	}
//	FCCMP	LT, F1, F2, $1

//
// FMULA
//
//		LTYPE9 freg ',' freg ',' freg ',' freg comma
//	{
//		outgcode($1, &$2, $4.reg, &$6, &$8);
//	}
//	FMULA	F1, F2, F3, F4

//
// FCSEL
//
//		LFCSEL cond ',' freg ',' freg ',' freg
//	{
//		outgcode($1, &$2, $6.reg, &$4, &$8);
//	}
//
// MADD Rn,Rm,Ra,Rd
//
//		LTYPEM reg ',' reg ',' sreg ',' reg
//	{
//		outgcode($1, &$2, $6, &$4, &$8);
//	}
//	MADD	R1, R2, R3, R4

// DMB, HINT
//
//		LDMB imm
//	{
//		outcode($1, &$2, NREG, &nullgen);
//	}
	DMB	$1

//
// STXR
//
//		LSTXR reg ',' addr ',' reg
//	{
//		outtcode($1, &$2, &$4, &$6);
//	}
	LDAXRW	(R0), R2
	STLXRW	R1, (R0), R3

// RET
//
//		LTYPEA comma
//	{
//		outcode($1, &nullgen, NREG, &nullgen);
//	}
	BEQ	2(PC)
	RET

// More B/BL cases, and canonical names JMP, CALL.

	BEQ	2(PC)
	B	foo(SB) // JMP foo(SB)
	BL	foo(SB) // CALL foo(SB)
	BEQ	2(PC)
	JMP	foo(SB)
	CALL	foo(SB)

// END
//
//	LTYPEE comma
//	{
//		outcode($1, &nullgen, NREG, &nullgen);
//	}
	END
                                                           usr/local/go/src/cmd/asm/internal/asm/testdata/mips64.s                                             0100644 0000000 0000000 00000013603 13020111411 021365  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2015 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This input was created by taking the ppc64 testcase and modified
// by hand.

TEXT foo(SB),7,$0

//inst:
//
// load ints and bytes
//
//	LMOVW rreg ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	R1, R2
	MOVW	LO, R1
	MOVW	HI, R1
	MOVW	R1, LO
	MOVW	R1, HI
	MOVV	R1, R2
	MOVV	LO, R1
	MOVV	HI, R1
	MOVV	R1, LO
	MOVV	R1, HI

//	LMOVW addr ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	foo<>+3(SB), R2
	MOVW	16(R1), R2
	MOVW	(R1), R2
	MOVV	foo<>+3(SB), R2
	MOVV	16(R1), R2
	MOVV	(R1), R2

//	LMOVB rreg ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVB	R1, R2

//	LMOVB addr ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVB	foo<>+3(SB), R2
	MOVB	16(R1), R2
	MOVB	(R1), R2

//
// load floats
//
//	LFMOV addr ',' freg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVD	foo<>+3(SB), F2
	MOVD	16(R1), F2
	MOVD	(R1), F2

//	LFMOV fimm ',' freg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVD	$0.1, F2 // MOVD $(0.10000000000000001), F2

//	LFMOV freg ',' freg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVD	F1, F2

//	LFMOV freg ',' addr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVD	F2, foo<>+3(SB)
	MOVD	F2, 16(R1)
	MOVD	F2, (R1)

//
// store ints and bytes
//
//	LMOVW rreg ',' addr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	R1, foo<>+3(SB)
	MOVW	R1, 16(R2)
	MOVW	R1, (R2)
	MOVV	R1, foo<>+3(SB)
	MOVV	R1, 16(R2)
	MOVV	R1, (R2)

//	LMOVB rreg ',' addr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVB	R1, foo<>+3(SB)
	MOVB	R1, 16(R2)
	MOVB	R1, (R2)

//
// store floats
//
//	LMOVW freg ',' addr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVD	F1, foo<>+3(SB)
	MOVD	F1, 16(R2)
	MOVD	F1, (R2)

//
// floating point status
//
//	LMOVW fpscr ',' freg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	FCR0, R1

//	LMOVW freg ','  fpscr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	R1, FCR0

//	LMOVW rreg ',' mreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	R1, M1
	MOVV	R1, M1

//	LMOVW mreg ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	M1, R1
	MOVV	M1, R1


//
// integer operations
// logical instructions
// shift instructions
// unary instructions
//
//	LADDW rreg ',' sreg ',' rreg
//	{
//		outcode(int($1), &$2, int($4), &$6);
//	}
	ADD	R1, R2, R3

//	LADDW imm ',' sreg ',' rreg
//	{
//		outcode(int($1), &$2, int($4), &$6);
//	}
	ADD	$1, R2, R3

//	LADDW rreg ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	ADD	R1, R2

//	LADDW imm ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	ADD	$4, R1

//	LMUL rreg ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MUL	R1, R2

//	LSHW rreg ',' sreg ',' rreg
//	{
//		outcode(int($1), &$2, int($4), &$6);
//	}
	SLL	R1, R2, R3

//	LSHW rreg ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	SLL	R1, R2

//	LSHW imm ',' sreg ',' rreg
//	{
//		outcode(int($1), &$2, int($4), &$6);
//	}
	SLL	$4, R1, R2

//	LSHW imm ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	SLL	$4, R1

//
// move immediate: macro for lui+or, addi, addis, and other combinations
//
//	LMOVW imm ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	$1, R1
	MOVV	$1, R1

//	LMOVW ximm ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	$1, R1
	MOVW	$foo(SB), R1
	MOVV	$1, R1
	MOVV	$foo(SB), R1


//
// branch
//
//	LBRA rel
//	{
//		outcode(int($1), &nullgen, 0, &$2);
//	}
	BEQ	R1, 2(PC)
label0:
	JMP	1(PC)
	BEQ	R1, 2(PC)
	JMP	label0+0 // JMP 64
	BEQ	R1, 2(PC)
	JAL	1(PC) // CALL 1(PC)
	BEQ	R1, 2(PC)
	JAL	label0+0 // CALL 64

//	LBRA addr
//	{
//		outcode(int($1), &nullgen, 0, &$2);
//	}
	BEQ	R1, 2(PC)
	JMP	0(R1) // JMP (R1)
	BEQ	R1, 2(PC)
	JMP	foo+0(SB) // JMP foo(SB)
	BEQ	R1, 2(PC)
	JAL	0(R1) // CALL (R1)
	BEQ	R1, 2(PC)
	JAL	foo+0(SB) // CALL foo(SB)

//
// BEQ/BNE
//
//	LBRA rreg ',' rel
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
label1:
	BEQ	R1, 1(PC)
	BEQ	R1, label1 // BEQ R1, 79

//	LBRA rreg ',' sreg ',' rel
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
label2:
	BEQ	R1, R2, 1(PC)
	BEQ	R1, R2, label2 // BEQ R1, R2, 81

//
// other integer conditional branch
//
//	LBRA rreg ',' rel
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
label3:
	BLTZ	R1, 1(PC)
	BLTZ	R1, label3 // BLTZ R1, 83

//
// floating point conditional branch
//
//	LBRA rel
label4:
	BFPT	1(PC)
	BFPT	label4 // BFPT 85


//
// floating point operate
//
//	LFCONV freg ',' freg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	ABSD	F1, F2

//	LFADD freg ',' freg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	ADDD	F1, F2

//	LFADD freg ',' freg ',' freg
//	{
//		outcode(int($1), &$2, int($4.Reg), &$6);
//	}
	ADDD	F1, F2, F3

//	LFCMP freg ',' freg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	CMPEQD	F1, F2


//
// WORD
//
	WORD	$1
	WORD	$foo(SB)

//
// NOP
//
//	LNOP comma // asm doesn't support the trailing comma.
//	{
//		outcode(int($1), &nullgen, 0, &nullgen);
//	}
	NOP

//	LNOP rreg comma // asm doesn't support the trailing comma.
//	{
//		outcode(int($1), &$2, 0, &nullgen);
//	}
	NOP R2

//	LNOP freg comma // asm doesn't support the trailing comma.
//	{
//		outcode(int($1), &$2, 0, &nullgen);
//	}
	NOP	F2

//	LNOP ',' rreg // asm doesn't support the leading comma.
//	{
//		outcode(int($1), &nullgen, 0, &$3);
//	}
	NOP	R2

//	LNOP ',' freg // asm doesn't support the leading comma.
//	{
//		outcode(int($1), &nullgen, 0, &$3);
//	}
	NOP	F2

//	LNOP imm
//	{
//		outcode(int($1), &$2, 0, &nullgen);
//	}
	NOP	$4

//
// special
//
	SYSCALL
	BREAK
	// overloaded cache opcode:
	BREAK	R1, (R1)

//
// RET
//
//	LRETRN	comma // asm doesn't support the trailing comma.
//	{
//		outcode(int($1), &nullgen, 0, &nullgen);
//	}
	SYSCALL
	BEQ	R1, 2(PC)
	RET


// More JMP/JAL cases, and canonical names JMP, CALL.

	JAL	foo(SB) // CALL foo(SB)
	BEQ	R1, 2(PC)
	JMP	foo(SB)
	CALL	foo(SB)

// END
//
//	LEND	comma // asm doesn't support the trailing comma.
//	{
//		outcode(int($1), &nullgen, 0, &nullgen);
//	}
	END
                                                                                                                             usr/local/go/src/cmd/asm/internal/asm/testdata/ppc64.s                                              0100644 0000000 0000000 00000031115 13020111411 021175  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2015 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This input was created by taking the instruction productions in
// the old assembler's (9a's) grammar and hand-writing complete
// instructions for each rule, to guarantee we cover the same space.

TEXT foo(SB),7,$0

//inst:
//
// load ints and bytes
//
//	LMOVW rreg ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	R1, R2

//	LMOVW addr ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	foo<>+3(SB), R2
	MOVW	16(R1), R2

//	LMOVW regaddr ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	(R1), R2
	MOVW	(R1+R2), R3 // MOVW (R1)(R2*1), R3

//	LMOVB rreg ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	R1, R2

//	LMOVB addr ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVB	foo<>+3(SB), R2
	MOVB	16(R1), R2

//	LMOVB regaddr ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVB	(R1), R2
	MOVB	(R1+R2), R3 // MOVB (R1)(R2*1), R3

//
// load floats
//
//	LFMOV addr ',' freg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	FMOVD	foo<>+3(SB), F2
	FMOVD	16(R1), F2

//	LFMOV regaddr ',' freg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	FMOVD	(R1), F2

//	LFMOV fimm ',' freg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	FMOVD	$0.1, F2 // FMOVD $(0.10000000000000001), F2

//	LFMOV freg ',' freg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	FMOVD	F1, F2

//	LFMOV freg ',' addr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	FMOVD	F2, foo<>+3(SB)
	FMOVD	F2, 16(R1)

//	LFMOV freg ',' regaddr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	FMOVD	F2, (R1)

//
// store ints and bytes
//
//	LMOVW rreg ',' addr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	R1, foo<>+3(SB)
	MOVW	R1, 16(R2)

//	LMOVW rreg ',' regaddr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	R1, (R1)
	MOVW	R1, (R2+R3) // MOVW R1, (R2)(R3*1)

//	LMOVB rreg ',' addr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVB	R1, foo<>+3(SB)
	MOVB	R1, 16(R2)

//	LMOVB rreg ',' regaddr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVB	R1, (R1)
	MOVB	R1, (R2+R3) // MOVB R1, (R2)(R3*1)
//
// store floats
//
//	LMOVW freg ',' addr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	FMOVD	F1, foo<>+3(SB)
	FMOVD	F1, 16(R2)

//	LMOVW freg ',' regaddr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	FMOVD	F1, (R1)

//
// floating point status
//
//	LMOVW fpscr ',' freg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVFL	FPSCR, F1

//	LMOVW freg ','  fpscr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVFL	F1, FPSCR

//	LMOVW freg ',' imm ',' fpscr
//	{
//		outgcode(int($1), &$2, 0, &$4, &$6);
//	}
	MOVFL	F1, $4, FPSCR

//	LMOVW fpscr ',' creg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVFL	FPSCR, CR0

//	LMTFSB imm ',' con
//	{
//		outcode(int($1), &$2, int($4), &nullgen);
//	}
//TODO	9a doesn't work MTFSB0	$4, 4

//
// field moves (mtcrf)
//
//	LMOVW rreg ',' imm ',' lcr
//	{
//		outgcode(int($1), &$2, 0, &$4, &$6);
//	}
// TODO 9a doesn't work	MOVFL	R1,$4,CR

//	LMOVW rreg ',' creg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
		MOVW	R1, CR1

//	LMOVW rreg ',' lcr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	R1, CR

//
// integer operations
// logical instructions
// shift instructions
// unary instructions
//
//	LADDW rreg ',' sreg ',' rreg
//	{
//		outcode(int($1), &$2, int($4), &$6);
//	}
	ADD	R1, R2, R3

//	LADDW imm ',' sreg ',' rreg
//	{
//		outcode(int($1), &$2, int($4), &$6);
//	}
	ADD	$1, R2, R3

//	LADDW rreg ',' imm ',' rreg
//	{
//		outgcode(int($1), &$2, 0, &$4, &$6);
//	}
//TODO 9a trouble	ADD	R1, $2, R3 maybe swap rreg and imm

//	LADDW rreg ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	ADD	R1, R2

//	LADDW imm ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	ADD	$4, R1

//	LLOGW rreg ',' sreg ',' rreg
//	{
//		outcode(int($1), &$2, int($4), &$6);
//	}
	ADDE	R1, R2, R3

//	LLOGW rreg ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	ADDE	R1, R2

//	LSHW rreg ',' sreg ',' rreg
//	{
//		outcode(int($1), &$2, int($4), &$6);
//	}
	SLW	R1, R2, R3

//	LSHW rreg ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	SLW	R1, R2

//	LSHW imm ',' sreg ',' rreg
//	{
//		outcode(int($1), &$2, int($4), &$6);
//	}
	SLW	$4, R1, R2

//	LSHW imm ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	SLW	$4, R1

//	LABS rreg ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	SLW	$4, R1

//	LABS rreg
//	{
//		outcode(int($1), &$2, 0, &$2);
//	}
	SUBME	R1 // SUBME R1, R1

//
// multiply-accumulate
//
//	LMA rreg ',' sreg ',' rreg
//	{
//		outcode(int($1), &$2, int($4), &$6);
//	}
//TODO this instruction is undefined in lex.go	LMA R1, R2, R3 NOT SUPPORTED (called MAC)

//
// move immediate: macro for cau+or, addi, addis, and other combinations
//
//	LMOVW imm ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	$1, R1

//	LMOVW ximm ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	$1, R1
	MOVW	$foo(SB), R1

// condition register operations
//
//	LCROP cbit ',' cbit
//	{
//		outcode(int($1), &$2, int($4.Reg), &$4);
//	}
//TODO 9a trouble	CREQV	1, 2 delete? liblink encodes like a divide (maybe wrong too)

//	LCROP cbit ',' con ',' cbit
//	{
//		outcode(int($1), &$2, int($4), &$6);
//	}
//TODO 9a trouble	CREQV	1, 2, 3

//
// condition register moves
// move from machine state register
//
//	LMOVW creg ',' creg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVFL	CR0, CR1

//	LMOVW psr ',' creg // TODO: should psr should be fpscr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
//TODO 9a trouble	MOVW	FPSCR, CR1

//	LMOVW lcr ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	CR, R1

//	LMOVW psr ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	SPR(0), R1
	MOVW	SPR(7), R1

//	LMOVW xlreg ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	LR, R1
	MOVW	CTR, R1

//	LMOVW rreg ',' xlreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	R1, LR
	MOVW	R1, CTR

//	LMOVW creg ',' psr // TODO doesn't exist
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
//TODO 9a trouble	MOVW	CR1, SPR(7)

//	LMOVW rreg ',' psr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVW	R1, SPR(7)

//
// branch, branch conditional
// branch conditional register
// branch conditional to count register
//
//	LBRA rel
//	{
//		outcode(int($1), &nullgen, 0, &$2);
//	}
	BEQ	CR1, 2(PC)
label0:
	BR	1(PC) // JMP 1(PC)
	BEQ	CR1, 2(PC)
	BR	label0+0 // JMP 62

//	LBRA addr
//	{
//		outcode(int($1), &nullgen, 0, &$2);
//	}
	BEQ	CR1, 2(PC)
	BR	LR // JMP LR
	BEQ	CR1, 2(PC)
//	BR	0(R1)	// TODO should work
	BEQ	CR1, 2(PC)
	BR	foo+0(SB) // JMP foo(SB)

//	LBRA '(' xlreg ')'
//	{
//		outcode(int($1), &nullgen, 0, &$3);
//	}
	BEQ	CR1, 2(PC)
	BR	(CTR) // JMP CTR

//	LBRA ',' rel  // asm doesn't support the leading comma
//	{
//		outcode(int($1), &nullgen, 0, &$3);
//	}
//	LBRA ',' addr  // asm doesn't support the leading comma
//	{
//		outcode(int($1), &nullgen, 0, &$3);
//	}
//	LBRA ',' '(' xlreg ')'  // asm doesn't support the leading comma
//	{
//		outcode(int($1), &nullgen, 0, &$4);
//	}
//	LBRA creg ',' rel
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
label1:
	BEQ	CR1, 1(PC)
	BEQ	CR1, label1 // BEQ CR1, 72

//	LBRA creg ',' addr // TODO DOES NOT WORK in 9a
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}

//	LBRA creg ',' '(' xlreg ')' // TODO DOES NOT WORK in 9a
//	{
//		outcode(int($1), &$2, 0, &$5);
//	}

//	LBRA con ',' rel // TODO DOES NOT WORK in 9a
//	{
//		outcode(int($1), &nullgen, int($2), &$4);
//	}

//	LBRA con ',' addr // TODO DOES NOT WORK in 9a
//	{
//		outcode(int($1), &nullgen, int($2), &$4);
//	}

//	LBRA con ',' '(' xlreg ')'
//	{
//		outcode(int($1), &nullgen, int($2), &$5);
//	}
//	BC	4, (CTR)	// TODO - should work

//	LBRA con ',' con ',' rel
//	{
//		var g obj.Addr
//		g = nullgen;
//		g.Type = obj.TYPE_CONST;
//		g.Offset = $2;
//		outcode(int($1), &g, int(REG_R0+$4), &$6);
//	}
//	BC	3, 4, label1 // TODO - should work

//	LBRA con ',' con ',' addr // TODO mystery
//	{
//		var g obj.Addr
//		g = nullgen;
//		g.Type = obj.TYPE_CONST;
//		g.Offset = $2;
//		outcode(int($1), &g, int(REG_R0+$4), &$6);
//	}
//TODO 9a trouble	BC	3, 3, 4(R1)

//	LBRA con ',' con ',' '(' xlreg ')'
//	{
//		var g obj.Addr
//		g = nullgen;
//		g.Type = obj.TYPE_CONST;
//		g.Offset = $2;
//		outcode(int($1), &g, int(REG_R0+$4), &$7);
//	}
	BC	3, 3, (LR) // BC $3, R3, LR

//
// conditional trap // TODO NOT DEFINED
// TODO these instructions are not in lex.go
//
//	LTRAP rreg ',' sreg
//	{
//		outcode(int($1), &$2, int($4), &nullgen);
//	}
//	LTRAP imm ',' sreg
//	{
//		outcode(int($1), &$2, int($4), &nullgen);
//	}
//	LTRAP rreg comma
//	{
//		outcode(int($1), &$2, 0, &nullgen);
//	}
//	LTRAP comma
//	{
//		outcode(int($1), &nullgen, 0, &nullgen);
//	}

//
// floating point operate
//
//	LFCONV freg ',' freg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	FABS	F1, F2

//	LFADD freg ',' freg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	FADD	F1, F2

//	LFADD freg ',' freg ',' freg
//	{
//		outcode(int($1), &$2, int($4.Reg), &$6);
//	}
	FADD	F1, F2, F3

//	LFMA freg ',' freg ',' freg ',' freg
//	{
//		outgcode(int($1), &$2, int($4.Reg), &$6, &$8);
//	}
	FMADD	F1, F2, F3, F4

//	LFCMP freg ',' freg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	FCMPU	F1, F2

//	LFCMP freg ',' freg ',' creg
//	{
//		outcode(int($1), &$2, int($6.Reg), &$4);
//	}
//	FCMPU	F1, F2, CR0

//
// CMP
//
//	LCMP rreg ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	CMP	R1, R2

//	LCMP rreg ',' imm
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	CMP	R1, $4

//	LCMP rreg ',' rreg ',' creg
//	{
//		outcode(int($1), &$2, int($6.Reg), &$4);
//	}
	CMP	R1, R2, CR0 // CMP R1, CR0, R2

//	LCMP rreg ',' imm ',' creg
//	{
//		outcode(int($1), &$2, int($6.Reg), &$4);
//	}
	CMP	R1, $4, CR0 // CMP R1, CR0, $4

//
// rotate and mask
//
//	LRLWM  imm ',' rreg ',' imm ',' rreg
//	{
//		outgcode(int($1), &$2, int($4.Reg), &$6, &$8);
//	}
	RLDC $4, R1, $16, R2

//	LRLWM  imm ',' rreg ',' mask ',' rreg
//	{
//		outgcode(int($1), &$2, int($4.Reg), &$6, &$8);
//	}
	RLDC $26, R1, 4, 5, R2 // RLDC $26, R1, $201326592, R2

//	LRLWM  rreg ',' rreg ',' imm ',' rreg
//	{
//		outgcode(int($1), &$2, int($4.Reg), &$6, &$8);
//	}
	RLDCL	R1, R2, $7, R3

//	LRLWM  rreg ',' rreg ',' mask ',' rreg
//	{
//		outgcode(int($1), &$2, int($4.Reg), &$6, &$8);
//	}
	RLWMI	R1, R2, 4, 5, R3 // RLWMI	R1, R2, $201326592, R3

//
// load/store multiple
//
//	LMOVMW addr ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
//	MOVMW	foo+0(SB), R2 // TODO TLS broke this!
	MOVMW	4(R1), R2

//	LMOVMW rreg ',' addr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
//	MOVMW	R1, foo+0(SB) // TODO TLS broke this!
	MOVMW	R1, 4(R2)

//
// various indexed load/store
// indexed unary (eg, cache clear)
//
//	LXLD regaddr ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	LSW	(R1), R2
	LSW	(R1+R2), R3 // LSW	(R1)(R2*1), R3

//	LXLD regaddr ',' imm ',' rreg
//	{
//		outgcode(int($1), &$2, 0, &$4, &$6);
//	}
	LSW	(R1), $1, R2
	LSW	(R1+R2), $1, R3 // LSW	(R1)(R2*1), $1, R3

//	LXST rreg ',' regaddr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	STSW	R1, (R2)
	STSW	R1, (R2+R3) // STSW	R1, (R2)(R3*1)

//	LXST rreg ',' imm ',' regaddr
//	{
//		outgcode(int($1), &$2, 0, &$4, &$6);
//	}
	STSW	R1, $1, (R2)
	STSW	R1, $1, (R2+R3) // STSW	R1, $1, (R2)(R3*1)

//	LXMV regaddr ',' rreg
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVHBR	(R1), R2
	MOVHBR	(R1+R2), R3 // MOVHBR	(R1)(R2*1), R3

//	LXMV rreg ',' regaddr
//	{
//		outcode(int($1), &$2, 0, &$4);
//	}
	MOVHBR	R1, (R2)
	MOVHBR	R1, (R2+R3) // MOVHBR	R1, (R2)(R3*1)

//	LXOP regaddr
//	{
//		outcode(int($1), &$2, 0, &nullgen);
//	}
	DCBF	(R1)
	DCBF	(R1+R2) // DCBF	(R1)(R2*1)

//
// NOP
//
//	LNOP comma // asm doesn't support the trailing comma.
//	{
//		outcode(int($1), &nullgen, 0, &nullgen);
//	}
	NOP

//	LNOP rreg comma // asm doesn't support the trailing comma.
//	{
//		outcode(int($1), &$2, 0, &nullgen);
//	}
	NOP R2

//	LNOP freg comma // asm doesn't support the trailing comma.
//	{
//		outcode(int($1), &$2, 0, &nullgen);
//	}
	NOP	F2

//	LNOP ',' rreg // asm doesn't support the leading comma.
//	{
//		outcode(int($1), &nullgen, 0, &$3);
//	}
	NOP	R2

//	LNOP ',' freg // asm doesn't support the leading comma.
//	{
//		outcode(int($1), &nullgen, 0, &$3);
//	}
	NOP	F2

//	LNOP imm // SYSCALL $num: load $num to R0 before syscall and restore R0 to 0 afterwards.
//	{
//		outcode(int($1), &$2, 0, &nullgen);
//	}
	NOP	$4

// RET
//
//	LRETRN	comma // asm doesn't support the trailing comma.
//	{
//		outcode(int($1), &nullgen, 0, &nullgen);
//	}
	BEQ	2(PC)
	RET

// More BR/BL cases, and canonical names JMP, CALL.

	BEQ	2(PC)
	BR	foo(SB) // JMP foo(SB)
	BL	foo(SB) //  CALL foo(SB)
	BEQ	2(PC)
	JMP	foo(SB)
	CALL	foo(SB)

// END
//
//	LEND	comma // asm doesn't support the trailing comma.
//	{
//		outcode(int($1), &nullgen, 0, &nullgen);
//	}
	END
                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/local/go/src/cmd/asm/internal/flags/                                                            0040755 0000000 0000000 00000000000 13020111411 016562  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/cmd/asm/internal/flags/flags.go                                                    0100644 0000000 0000000 00000003602 13020111411 020203  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package flags implements top-level flags and the usage message for the assembler.
package flags

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

var (
	Debug      = flag.Bool("debug", false, "dump instructions as they are parsed")
	OutputFile = flag.String("o", "", "output file; default foo.6 for /a/b/c/foo.s on amd64")
	PrintOut   = flag.Bool("S", false, "print assembly and machine code")
	TrimPath   = flag.String("trimpath", "", "remove prefix from recorded source file paths")
	Shared     = flag.Bool("shared", false, "generate code that can be linked into a shared library")
	Dynlink    = flag.Bool("dynlink", false, "support references to Go symbols defined in other shared libraries")
	AllErrors = flag.Bool("e", false, "no limit on number of errors reported")
)

var (
	D MultiFlag
	I MultiFlag
)

func init() {
	flag.Var(&D, "D", "predefined symbol with optional simple value -D=identifer=value; can be set multiple times")
	flag.Var(&I, "I", "include directory; can be set multiple times")
}

// MultiFlag allows setting a value multiple times to collect a list, as in -I=dir1 -I=dir2.
type MultiFlag []string

func (m *MultiFlag) String() string {
	if len(*m) == 0 {
		return ""
	}
	return fmt.Sprint(*m)
}

func (m *MultiFlag) Set(val string) error {
	(*m) = append(*m, val)
	return nil
}

func Usage() {
	fmt.Fprintf(os.Stderr, "usage: asm [options] file.s\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
	os.Exit(2)
}

func Parse() {
	flag.Usage = Usage
	flag.Parse()
	if flag.NArg() != 1 {
		flag.Usage()
	}

	// Flag refinement.
	if *OutputFile == "" {
		input := filepath.Base(flag.Arg(0))
		if strings.HasSuffix(input, ".s") {
			input = input[:len(input)-2]
		}
		*OutputFile = fmt.Sprintf("%s.o", input)
	}
}
                                                                                                                              usr/local/go/src/cmd/asm/internal/lex/                                                              0040755 0000000 0000000 00000000000 13020111411 016256  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/cmd/asm/internal/lex/input.go                                                      0100644 0000000 0000000 00000030501 13020111411 017740  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package lex

import (
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/scanner"

	"cmd/asm/internal/flags"
)

// Input is the main input: a stack of readers and some macro definitions.
// It also handles #include processing (by pushing onto the input stack)
// and parses and instantiates macro definitions.
type Input struct {
	Stack
	includes        []string
	beginningOfLine bool
	ifdefStack      []bool
	macros          map[string]*Macro
	text            string // Text of last token returned by Next.
	peek            bool
	peekToken       ScanToken
	peekText        string
}

// NewInput returns a
func NewInput(name string) *Input {
	return &Input{
		// include directories: look in source dir, then -I directories.
		includes:        append([]string{filepath.Dir(name)}, flags.I...),
		beginningOfLine: true,
		macros:          predefine(flags.D),
	}
}

// predefine installs the macros set by the -D flag on the command line.
func predefine(defines flags.MultiFlag) map[string]*Macro {
	macros := make(map[string]*Macro)
	for _, name := range defines {
		value := "1"
		i := strings.IndexRune(name, '=')
		if i > 0 {
			name, value = name[:i], name[i+1:]
		}
		tokens := Tokenize(name)
		if len(tokens) != 1 || tokens[0].ScanToken != scanner.Ident {
			fmt.Fprintf(os.Stderr, "asm: parsing -D: %q is not a valid identifier name\n", tokens[0])
			flags.Usage()
		}
		macros[name] = &Macro{
			name:   name,
			args:   nil,
			tokens: Tokenize(value),
		}
	}
	return macros
}

var panicOnError bool // For testing.

func (in *Input) Error(args ...interface{}) {
	if panicOnError {
		panic(fmt.Errorf("%s:%d: %s", in.File(), in.Line(), fmt.Sprintln(args...)))
	}
	fmt.Fprintf(os.Stderr, "%s:%d: %s", in.File(), in.Line(), fmt.Sprintln(args...))
	os.Exit(1)
}

// expectText is like Error but adds "got XXX" where XXX is a quoted representation of the most recent token.
func (in *Input) expectText(args ...interface{}) {
	in.Error(append(args, "; got", strconv.Quote(in.Stack.Text()))...)
}

// enabled reports whether the input is enabled by an ifdef, or is at the top level.
func (in *Input) enabled() bool {
	return len(in.ifdefStack) == 0 || in.ifdefStack[len(in.ifdefStack)-1]
}

func (in *Input) expectNewline(directive string) {
	tok := in.Stack.Next()
	if tok != '\n' {
		in.expectText("expected newline after", directive)
	}
}

func (in *Input) Next() ScanToken {
	if in.peek {
		in.peek = false
		tok := in.peekToken
		in.text = in.peekText
		return tok
	}
	// If we cannot generate a token after 100 macro invocations, we're in trouble.
	// The usual case is caught by Push, below, but be safe.
	for nesting := 0; nesting < 100; {
		tok := in.Stack.Next()
		switch tok {
		case '#':
			if !in.beginningOfLine {
				in.Error("'#' must be first item on line")
			}
			in.beginningOfLine = in.hash()
		case scanner.Ident:
			// Is it a macro name?
			name := in.Stack.Text()
			macro := in.macros[name]
			if macro != nil {
				nesting++
				in.invokeMacro(macro)
				continue
			}
			fallthrough
		default:
			if tok == scanner.EOF && len(in.ifdefStack) > 0 {
				// We're skipping text but have run out of input with no #endif.
				in.Error("unclosed #ifdef or #ifndef")
			}
			in.beginningOfLine = tok == '\n'
			if in.enabled() {
				in.text = in.Stack.Text()
				return tok
			}
		}
	}
	in.Error("recursive macro invocation")
	return 0
}

func (in *Input) Text() string {
	return in.text
}

// hash processes a # preprocessor directive. It returns true iff it completes.
func (in *Input) hash() bool {
	// We have a '#'; it must be followed by a known word (define, include, etc.).
	tok := in.Stack.Next()
	if tok != scanner.Ident {
		in.expectText("expected identifier after '#'")
	}
	if !in.enabled() {
		// Can only start including again if we are at #else or #endif but also
		// need to keep track of nested #if[n]defs.
		// We let #line through because it might affect errors.
		switch in.Stack.Text() {
		case "else", "endif", "ifdef", "ifndef", "line":
			// Press on.
		default:
			return false
		}
	}
	switch in.Stack.Text() {
	case "define":
		in.define()
	case "else":
		in.else_()
	case "endif":
		in.endif()
	case "ifdef":
		in.ifdef(true)
	case "ifndef":
		in.ifdef(false)
	case "include":
		in.include()
	case "line":
		in.line()
	case "undef":
		in.undef()
	default:
		in.Error("unexpected token after '#':", in.Stack.Text())
	}
	return true
}

// macroName returns the name for the macro being referenced.
func (in *Input) macroName() string {
	// We use the Stack's input method; no macro processing at this stage.
	tok := in.Stack.Next()
	if tok != scanner.Ident {
		in.expectText("expected identifier after # directive")
	}
	// Name is alphanumeric by definition.
	return in.Stack.Text()
}

// #define processing.
func (in *Input) define() {
	name := in.macroName()
	args, tokens := in.macroDefinition(name)
	in.defineMacro(name, args, tokens)
}

// defineMacro stores the macro definition in the Input.
func (in *Input) defineMacro(name string, args []string, tokens []Token) {
	if in.macros[name] != nil {
		in.Error("redefinition of macro:", name)
	}
	in.macros[name] = &Macro{
		name:   name,
		args:   args,
		tokens: tokens,
	}
}

// macroDefinition returns the list of formals and the tokens of the definition.
// The argument list is nil for no parens on the definition; otherwise a list of
// formal argument names.
func (in *Input) macroDefinition(name string) ([]string, []Token) {
	prevCol := in.Stack.Col()
	tok := in.Stack.Next()
	if tok == '\n' || tok == scanner.EOF {
		return nil, nil // No definition for macro
	}
	var args []string
	// The C preprocessor treats
	//	#define A(x)
	// and
	//	#define A (x)
	// distinctly: the first is a macro with arguments, the second without.
	// Distinguish these cases using the column number, since we don't
	// see the space itself. Note that text/scanner reports the position at the
	// end of the token. It's where you are now, and you just read this token.
	if tok == '(' && in.Stack.Col() == prevCol+1 {
		// Macro has arguments. Scan list of formals.
		acceptArg := true
		args = []string{} // Zero length but not nil.
	Loop:
		for {
			tok = in.Stack.Next()
			switch tok {
			case ')':
				tok = in.Stack.Next() // First token of macro definition.
				break Loop
			case ',':
				if acceptArg {
					in.Error("bad syntax in definition for macro:", name)
				}
				acceptArg = true
			case scanner.Ident:
				if !acceptArg {
					in.Error("bad syntax in definition for macro:", name)
				}
				arg := in.Stack.Text()
				if i := lookup(args, arg); i >= 0 {
					in.Error("duplicate argument", arg, "in definition for macro:", name)
				}
				args = append(args, arg)
				acceptArg = false
			default:
				in.Error("bad definition for macro:", name)
			}
		}
	}
	var tokens []Token
	// Scan to newline. Backslashes escape newlines.
	for tok != '\n' {
		if tok == scanner.EOF {
			in.Error("missing newline in definition for macro:", name)
		}
		if tok == '\\' {
			tok = in.Stack.Next()
			if tok != '\n' && tok != '\\' {
				in.Error(`can only escape \ or \n in definition for macro:`, name)
			}
		}
		tokens = append(tokens, Make(tok, in.Stack.Text()))
		tok = in.Stack.Next()
	}
	return args, tokens
}

func lookup(args []string, arg string) int {
	for i, a := range args {
		if a == arg {
			return i
		}
	}
	return -1
}

// invokeMacro pushes onto the input Stack a Slice that holds the macro definition with the actual
// parameters substituted for the formals.
// Invoking a macro does not touch the PC/line history.
func (in *Input) invokeMacro(macro *Macro) {
	// If the macro has no arguments, just substitute the text.
	if macro.args == nil {
		in.Push(NewSlice(in.File(), in.Line(), macro.tokens))
		return
	}
	tok := in.Stack.Next()
	if tok != '(' {
		// If the macro has arguments but is invoked without them, all we push is the macro name.
		// First, put back the token.
		in.peekToken = tok
		in.peekText = in.text
		in.peek = true
		in.Push(NewSlice(in.File(), in.Line(), []Token{Make(macroName, macro.name)}))
		return
	}
	actuals := in.argsFor(macro)
	var tokens []Token
	for _, tok := range macro.tokens {
		if tok.ScanToken != scanner.Ident {
			tokens = append(tokens, tok)
			continue
		}
		substitution := actuals[tok.text]
		if substitution == nil {
			tokens = append(tokens, tok)
			continue
		}
		tokens = append(tokens, substitution...)
	}
	in.Push(NewSlice(in.File(), in.Line(), tokens))
}

// argsFor returns a map from formal name to actual value for this argumented macro invocation.
// The opening parenthesis has been absorbed.
func (in *Input) argsFor(macro *Macro) map[string][]Token {
	var args [][]Token
	// One macro argument per iteration. Collect them all and check counts afterwards.
	for argNum := 0; ; argNum++ {
		tokens, tok := in.collectArgument(macro)
		args = append(args, tokens)
		if tok == ')' {
			break
		}
	}
	// Zero-argument macros are tricky.
	if len(macro.args) == 0 && len(args) == 1 && args[0] == nil {
		args = nil
	} else if len(args) != len(macro.args) {
		in.Error("wrong arg count for macro", macro.name)
	}
	argMap := make(map[string][]Token)
	for i, arg := range args {
		argMap[macro.args[i]] = arg
	}
	return argMap
}

// collectArgument returns the actual tokens for a single argument of a macro.
// It also returns the token that terminated the argument, which will always
// be either ',' or ')'. The starting '(' has been scanned.
func (in *Input) collectArgument(macro *Macro) ([]Token, ScanToken) {
	nesting := 0
	var tokens []Token
	for {
		tok := in.Stack.Next()
		if tok == scanner.EOF || tok == '\n' {
			in.Error("unterminated arg list invoking macro:", macro.name)
		}
		if nesting == 0 && (tok == ')' || tok == ',') {
			return tokens, tok
		}
		if tok == '(' {
			nesting++
		}
		if tok == ')' {
			nesting--
		}
		tokens = append(tokens, Make(tok, in.Stack.Text()))
	}
}

// #ifdef and #ifndef processing.
func (in *Input) ifdef(truth bool) {
	name := in.macroName()
	in.expectNewline("#if[n]def")
	if !in.enabled() {
		truth = false
	} else if _, defined := in.macros[name]; !defined {
		truth = !truth
	}
	in.ifdefStack = append(in.ifdefStack, truth)
}

// #else processing
func (in *Input) else_() {
	in.expectNewline("#else")
	if len(in.ifdefStack) == 0 {
		in.Error("unmatched #else")
	}
	if len(in.ifdefStack) == 1 || in.ifdefStack[len(in.ifdefStack)-2] {
		in.ifdefStack[len(in.ifdefStack)-1] = !in.ifdefStack[len(in.ifdefStack)-1]
	}
}

// #endif processing.
func (in *Input) endif() {
	in.expectNewline("#endif")
	if len(in.ifdefStack) == 0 {
		in.Error("unmatched #endif")
	}
	in.ifdefStack = in.ifdefStack[:len(in.ifdefStack)-1]
}

// #include processing.
func (in *Input) include() {
	// Find and parse string.
	tok := in.Stack.Next()
	if tok != scanner.String {
		in.expectText("expected string after #include")
	}
	name, err := strconv.Unquote(in.Stack.Text())
	if err != nil {
		in.Error("unquoting include file name: ", err)
	}
	in.expectNewline("#include")
	// Push tokenizer for file onto stack.
	fd, err := os.Open(name)
	if err != nil {
		for _, dir := range in.includes {
			fd, err = os.Open(filepath.Join(dir, name))
			if err == nil {
				break
			}
		}
		if err != nil {
			in.Error("#include:", err)
		}
	}
	in.Push(NewTokenizer(name, fd, fd))
}

// #line processing.
func (in *Input) line() {
	// Only need to handle Plan 9 format: #line 337 "filename"
	tok := in.Stack.Next()
	if tok != scanner.Int {
		in.expectText("expected line number after #line")
	}
	line, err := strconv.Atoi(in.Stack.Text())
	if err != nil {
		in.Error("error parsing #line (cannot happen):", err)
	}
	tok = in.Stack.Next()
	if tok != scanner.String {
		in.expectText("expected file name in #line")
	}
	file, err := strconv.Unquote(in.Stack.Text())
	if err != nil {
		in.Error("unquoting #line file name: ", err)
	}
	tok = in.Stack.Next()
	if tok != '\n' {
		in.Error("unexpected token at end of #line: ", tok)
	}
	linkCtxt.LineHist.Update(histLine, file, line)
	in.Stack.SetPos(line, file)
}

// #undef processing
func (in *Input) undef() {
	name := in.macroName()
	if in.macros[name] == nil {
		in.Error("#undef for undefined macro:", name)
	}
	// Newline must be next.
	tok := in.Stack.Next()
	if tok != '\n' {
		in.Error("syntax error in #undef for macro:", name)
	}
	delete(in.macros, name)
}

func (in *Input) Push(r TokenReader) {
	if len(in.tr) > 100 {
		in.Error("input recursion")
	}
	in.Stack.Push(r)
}

func (in *Input) Close() {
}
                                                                                                                                                                                               usr/local/go/src/cmd/asm/internal/lex/lex.go                                                        0100644 0000000 0000000 00000011231 13020111411 017370  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package lex implements lexical analysis for the assembler.
package lex

import (
	"fmt"
	"log"
	"os"
	"strings"
	"text/scanner"

	"cmd/internal/obj"
)

// A ScanToken represents an input item. It is a simple wrapping of rune, as
// returned by text/scanner.Scanner, plus a couple of extra values.
type ScanToken rune

const (
	// Asm defines some two-character lexemes. We make up
	// a rune/ScanToken value for them - ugly but simple.
	LSH       ScanToken = -1000 - iota // << Left shift.
	RSH                                // >> Logical right shift.
	ARR                                // -> Used on ARM for shift type 3, arithmetic right shift.
	ROT                                // @> Used on ARM for shift type 4, rotate right.
	macroName                          // name of macro that should not be expanded
)

// IsRegisterShift reports whether the token is one of the ARM register shift operators.
func IsRegisterShift(r ScanToken) bool {
	return ROT <= r && r <= LSH // Order looks backwards because these are negative.
}

func (t ScanToken) String() string {
	switch t {
	case scanner.EOF:
		return "EOF"
	case scanner.Ident:
		return "identifier"
	case scanner.Int:
		return "integer constant"
	case scanner.Float:
		return "float constant"
	case scanner.Char:
		return "rune constant"
	case scanner.String:
		return "string constant"
	case scanner.RawString:
		return "raw string constant"
	case scanner.Comment:
		return "comment"
	default:
		return fmt.Sprintf("%q", rune(t))
	}
}

var (
	// It might be nice if these weren't global.
	linkCtxt *obj.Link     // The link context for all instructions.
	histLine int       = 1 // The cumulative count of lines processed.
)

// HistLine reports the cumulative source line number of the token,
// for use in the Prog structure for the linker. (It's always handling the
// instruction from the current lex line.)
// It returns int32 because that's what type ../asm prefers.
func HistLine() int32 {
	return int32(histLine)
}

// NewLexer returns a lexer for the named file and the given link context.
func NewLexer(name string, ctxt *obj.Link) TokenReader {
	linkCtxt = ctxt
	input := NewInput(name)
	fd, err := os.Open(name)
	if err != nil {
		log.Fatalf("asm: %s\n", err)
	}
	input.Push(NewTokenizer(name, fd, fd))
	return input
}

// InitHist sets the line count to 1, for reproducible testing.
func InitHist() {
	histLine = 1
}

// The other files in this directory each contain an implementation of TokenReader.

// A TokenReader is like a reader, but returns lex tokens of type Token. It also can tell you what
// the text of the most recently returned token is, and where it was found.
// The underlying scanner elides all spaces except newline, so the input looks like a  stream of
// Tokens; original spacing is lost but we don't need it.
type TokenReader interface {
	// Next returns the next token.
	Next() ScanToken
	// The following methods all refer to the most recent token returned by Next.
	// Text returns the original string representation of the token.
	Text() string
	// File reports the source file name of the token.
	File() string
	// Line reports the source line number of the token.
	Line() int
	// Col reports the source column number of the token.
	Col() int
	// SetPos sets the file and line number.
	SetPos(line int, file string)
	// Close does any teardown required.
	Close()
}

// A Token is a scan token plus its string value.
// A macro is stored as a sequence of Tokens with spaces stripped.
type Token struct {
	ScanToken
	text string
}

// Make returns a Token with the given rune (ScanToken) and text representation.
func Make(token ScanToken, text string) Token {
	// If the symbol starts with center dot, as in ·x, rewrite it as ""·x
	if token == scanner.Ident && strings.HasPrefix(text, "\u00B7") {
		text = `""` + text
	}
	// Substitute the substitutes for . and /.
	text = strings.Replace(text, "\u00B7", ".", -1)
	text = strings.Replace(text, "\u2215", "/", -1)
	return Token{ScanToken: token, text: text}
}

func (l Token) String() string {
	return l.text
}

// A Macro represents the definition of a #defined macro.
type Macro struct {
	name   string   // The #define name.
	args   []string // Formal arguments.
	tokens []Token  // Body of macro.
}

// Tokenize turns a string into a list of Tokens; used to parse the -D flag and in tests.
func Tokenize(str string) []Token {
	t := NewTokenizer("command line", strings.NewReader(str), nil)
	var tokens []Token
	for {
		tok := t.Next()
		if tok == scanner.EOF {
			break
		}
		tokens = append(tokens, Make(tok, t.Text()))
	}
	return tokens
}
                                                                                                                                                                                                                                                                                                                                                                       usr/local/go/src/cmd/asm/internal/lex/lex_test.go                                                   0100644 0000000 0000000 00000013472 13020111411 020440  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package lex

import (
	"bytes"
	"strings"
	"testing"
	"text/scanner"
)

type lexTest struct {
	name   string
	input  string
	output string
}

var lexTests = []lexTest{
	{
		"empty",
		"",
		"",
	},
	{
		"simple",
		"1 (a)",
		"1.(.a.)",
	},
	{
		"simple define",
		lines(
			"#define A 1234",
			"A",
		),
		"1234.\n",
	},
	{
		"define without value",
		"#define A",
		"",
	},
	{
		"macro without arguments",
		"#define A() 1234\n" + "A()\n",
		"1234.\n",
	},
	{
		"macro with just parens as body",
		"#define A () \n" + "A\n",
		"(.).\n",
	},
	{
		"macro with parens but no arguments",
		"#define A (x) \n" + "A\n",
		"(.x.).\n",
	},
	{
		"macro with arguments",
		"#define A(x, y, z) x+z+y\n" + "A(1, 2, 3)\n",
		"1.+.3.+.2.\n",
	},
	{
		"argumented macro invoked without arguments",
		lines(
			"#define X() foo ",
			"X()",
			"X",
		),
		"foo.\n.X.\n",
	},
	{
		"multiline macro without arguments",
		lines(
			"#define A 1\\",
			"\t2\\",
			"\t3",
			"before",
			"A",
			"after",
		),
		"before.\n.1.\n.2.\n.3.\n.after.\n",
	},
	{
		"multiline macro with arguments",
		lines(
			"#define A(a, b, c) a\\",
			"\tb\\",
			"\tc",
			"before",
			"A(1, 2, 3)",
			"after",
		),
		"before.\n.1.\n.2.\n.3.\n.after.\n",
	},
	{
		"LOAD macro",
		lines(
			"#define LOAD(off, reg) \\",
			"\tMOVBLZX	(off*4)(R12),	reg \\",
			"\tADDB	reg,		DX",
			"",
			"LOAD(8, AX)",
		),
		"\n.\n.MOVBLZX.(.8.*.4.).(.R12.).,.AX.\n.ADDB.AX.,.DX.\n",
	},
	{
		"nested multiline macro",
		lines(
			"#define KEYROUND(xmm, load, off, r1, r2, index) \\",
			"\tMOVBLZX	(BP)(DX*4),	R8 \\",
			"\tload((off+1), r2) \\",
			"\tMOVB	R8,		(off*4)(R12) \\",
			"\tPINSRW	$index, (BP)(R8*4), xmm",
			"#define LOAD(off, reg) \\",
			"\tMOVBLZX	(off*4)(R12),	reg \\",
			"\tADDB	reg,		DX",
			"KEYROUND(X0, LOAD, 8, AX, BX, 0)",
		),
		"\n.MOVBLZX.(.BP.).(.DX.*.4.).,.R8.\n.\n.MOVBLZX.(.(.8.+.1.).*.4.).(.R12.).,.BX.\n.ADDB.BX.,.DX.\n.MOVB.R8.,.(.8.*.4.).(.R12.).\n.PINSRW.$.0.,.(.BP.).(.R8.*.4.).,.X0.\n",
	},
	{
		"taken #ifdef",
		lines(
			"#define A",
			"#ifdef A",
			"#define B 1234",
			"#endif",
			"B",
		),
		"1234.\n",
	},
	{
		"not taken #ifdef",
		lines(
			"#ifdef A",
			"#define B 1234",
			"#endif",
			"B",
		),
		"B.\n",
	},
	{
		"taken #ifdef with else",
		lines(
			"#define A",
			"#ifdef A",
			"#define B 1234",
			"#else",
			"#define B 5678",
			"#endif",
			"B",
		),
		"1234.\n",
	},
	{
		"not taken #ifdef with else",
		lines(
			"#ifdef A",
			"#define B 1234",
			"#else",
			"#define B 5678",
			"#endif",
			"B",
		),
		"5678.\n",
	},
	{
		"nested taken/taken #ifdef",
		lines(
			"#define A",
			"#define B",
			"#ifdef A",
			"#ifdef B",
			"#define C 1234",
			"#else",
			"#define C 5678",
			"#endif",
			"#endif",
			"C",
		),
		"1234.\n",
	},
	{
		"nested taken/not-taken #ifdef",
		lines(
			"#define A",
			"#ifdef A",
			"#ifdef B",
			"#define C 1234",
			"#else",
			"#define C 5678",
			"#endif",
			"#endif",
			"C",
		),
		"5678.\n",
	},
	{
		"nested not-taken/would-be-taken #ifdef",
		lines(
			"#define B",
			"#ifdef A",
			"#ifdef B",
			"#define C 1234",
			"#else",
			"#define C 5678",
			"#endif",
			"#endif",
			"C",
		),
		"C.\n",
	},
	{
		"nested not-taken/not-taken #ifdef",
		lines(
			"#ifdef A",
			"#ifdef B",
			"#define C 1234",
			"#else",
			"#define C 5678",
			"#endif",
			"#endif",
			"C",
		),
		"C.\n",
	},
	{
		"nested #define",
		lines(
			"#define A #define B THIS",
			"A",
			"B",
		),
		"THIS.\n",
	},
	{
		"nested #define with args",
		lines(
			"#define A #define B(x) x",
			"A",
			"B(THIS)",
		),
		"THIS.\n",
	},
	/* This one fails. See comment in Slice.Col.
	{
		"nested #define with args",
		lines(
			"#define A #define B (x) x",
			"A",
			"B(THIS)",
		),
		"x.\n",
	},
	*/
}

func TestLex(t *testing.T) {
	for _, test := range lexTests {
		input := NewInput(test.name)
		input.Push(NewTokenizer(test.name, strings.NewReader(test.input), nil))
		result := drain(input)
		if result != test.output {
			t.Errorf("%s: got %q expected %q", test.name, result, test.output)
		}
	}
}

// lines joins the arguments together as complete lines.
func lines(a ...string) string {
	return strings.Join(a, "\n") + "\n"
}

// drain returns a single string representing the processed input tokens.
func drain(input *Input) string {
	var buf bytes.Buffer
	for {
		tok := input.Next()
		if tok == scanner.EOF {
			return buf.String()
		}
		if buf.Len() > 0 {
			buf.WriteByte('.')
		}
		buf.WriteString(input.Text())
	}
}

type badLexTest struct {
	input string
	error string
}

var badLexTests = []badLexTest{
	{
		"3 #define foo bar\n",
		"'#' must be first item on line",
	},
	{
		"#ifdef foo\nhello",
		"unclosed #ifdef or #ifndef",
	},
	{
		"#ifndef foo\nhello",
		"unclosed #ifdef or #ifndef",
	},
	{
		"#ifdef foo\nhello\n#else\nbye",
		"unclosed #ifdef or #ifndef",
	},
	{
		"#define A() A()\nA()",
		"recursive macro invocation",
	},
	{
		"#define A a\n#define A a\n",
		"redefinition of macro",
	},
	{
		"#define A a",
		"no newline after macro definition",
	},
}

func TestBadLex(t *testing.T) {
	for _, test := range badLexTests {
		input := NewInput(test.error)
		input.Push(NewTokenizer(test.error, strings.NewReader(test.input), nil))
		err := firstError(input)
		if err == nil {
			t.Errorf("%s: got no error", test.error)
			continue
		}
		if !strings.Contains(err.Error(), test.error) {
			t.Errorf("got error %q expected %q", err.Error(), test.error)
		}
	}
}

// firstError returns the first error value triggered by the input.
func firstError(input *Input) (err error) {
	panicOnError = true
	defer func() {
		panicOnError = false
		switch e := recover(); e := e.(type) {
		case nil:
		case error:
			err = e
		default:
			panic(e)
		}
	}()

	for {
		tok := input.Next()
		if tok == scanner.EOF {
			return
		}
	}
}
                                                                                                                                                                                                      usr/local/go/src/cmd/asm/internal/lex/slice.go                                                      0100644 0000000 0000000 00000003115 13020111411 017701  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package lex

import "text/scanner"

// A Slice reads from a slice of Tokens.
type Slice struct {
	tokens   []Token
	fileName string
	line     int
	pos      int
}

func NewSlice(fileName string, line int, tokens []Token) *Slice {
	return &Slice{
		tokens:   tokens,
		fileName: fileName,
		line:     line,
		pos:      -1, // Next will advance to zero.
	}
}

func (s *Slice) Next() ScanToken {
	s.pos++
	if s.pos >= len(s.tokens) {
		return scanner.EOF
	}
	return s.tokens[s.pos].ScanToken
}

func (s *Slice) Text() string {
	return s.tokens[s.pos].text
}

func (s *Slice) File() string {
	return s.fileName
}

func (s *Slice) Line() int {
	return s.line
}

func (s *Slice) Col() int {
	// TODO: Col is only called when defining a macro and all it cares about is increasing
	// position to discover whether there is a blank before the parenthesis.
	// We only get here if defining a macro inside a macro.
	// This imperfect implementation means we cannot tell the difference between
	//	#define A #define B(x) x
	// and
	//	#define A #define B (x) x
	// The first has definition of B has an argument, the second doesn't. Because we let
	// text/scanner strip the blanks for us, this is extremely rare, hard to fix, and not worth it.
	return s.pos
}

func (s *Slice) SetPos(line int, file string) {
	// Cannot happen because we only have slices of already-scanned
	// text, but be prepared.
	s.line = line
	s.fileName = file
}

func (s *Slice) Close() {
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/local/go/src/cmd/asm/internal/lex/stack.go                                                      0100644 0000000 0000000 00000002223 13020111411 017706  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package lex

import "text/scanner"

// A Stack is a stack of TokenReaders. As the top TokenReader hits EOF,
// it resumes reading the next one down.
type Stack struct {
	tr []TokenReader
}

// Push adds tr to the top (end) of the input stack. (Popping happens automatically.)
func (s *Stack) Push(tr TokenReader) {
	s.tr = append(s.tr, tr)
}

func (s *Stack) Next() ScanToken {
	tos := s.tr[len(s.tr)-1]
	tok := tos.Next()
	for tok == scanner.EOF && len(s.tr) > 1 {
		tos.Close()
		// Pop the topmost item from the stack and resume with the next one down.
		s.tr = s.tr[:len(s.tr)-1]
		tok = s.Next()
	}
	return tok
}

func (s *Stack) Text() string {
	return s.tr[len(s.tr)-1].Text()
}

func (s *Stack) File() string {
	return s.tr[len(s.tr)-1].File()
}

func (s *Stack) Line() int {
	return s.tr[len(s.tr)-1].Line()
}

func (s *Stack) Col() int {
	return s.tr[len(s.tr)-1].Col()
}

func (s *Stack) SetPos(line int, file string) {
	s.tr[len(s.tr)-1].SetPos(line, file)
}

func (s *Stack) Close() { // Unused.
}
                                                                                                                                                                                                                                                                                                                                                                             usr/local/go/src/cmd/asm/internal/lex/tokenizer.go                                                  0100644 0000000 0000000 00000006034 13020111411 020617  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package lex

import (
	"io"
	"os"
	"strings"
	"text/scanner"
	"unicode"
)

// A Tokenizer is a simple wrapping of text/scanner.Scanner, configured
// for our purposes and made a TokenReader. It forms the lowest level,
// turning text from readers into tokens.
type Tokenizer struct {
	tok      ScanToken
	s        *scanner.Scanner
	line     int
	fileName string
	file     *os.File // If non-nil, file descriptor to close.
}

func NewTokenizer(name string, r io.Reader, file *os.File) *Tokenizer {
	var s scanner.Scanner
	s.Init(r)
	// Newline is like a semicolon; other space characters are fine.
	s.Whitespace = 1<<'\t' | 1<<'\r' | 1<<' '
	// Don't skip comments: we need to count newlines.
	s.Mode = scanner.ScanChars |
		scanner.ScanFloats |
		scanner.ScanIdents |
		scanner.ScanInts |
		scanner.ScanStrings |
		scanner.ScanComments
	s.Position.Filename = name
	s.IsIdentRune = isIdentRune
	if file != nil {
		linkCtxt.LineHist.Push(histLine, name)
	}
	return &Tokenizer{
		s:        &s,
		line:     1,
		fileName: name,
		file:     file,
	}
}

// We want center dot (·) and division slash (∕) to work as identifier characters.
func isIdentRune(ch rune, i int) bool {
	if unicode.IsLetter(ch) {
		return true
	}
	switch ch {
	case '_': // Underscore; traditional.
		return true
	case '\u00B7': // Represents the period in runtime.exit. U+00B7 '·' middle dot
		return true
	case '\u2215': // Represents the slash in runtime/debug.setGCPercent. U+2215 '∕' division slash
		return true
	}
	// Digits are OK only after the first character.
	return i > 0 && unicode.IsDigit(ch)
}

func (t *Tokenizer) Text() string {
	switch t.tok {
	case LSH:
		return "<<"
	case RSH:
		return ">>"
	case ARR:
		return "->"
	case ROT:
		return "@>"
	}
	return t.s.TokenText()
}

func (t *Tokenizer) File() string {
	return t.fileName
}

func (t *Tokenizer) Line() int {
	return t.line
}

func (t *Tokenizer) Col() int {
	return t.s.Pos().Column
}

func (t *Tokenizer) SetPos(line int, file string) {
	t.line = line
	t.fileName = file
}

func (t *Tokenizer) Next() ScanToken {
	s := t.s
	for {
		t.tok = ScanToken(s.Scan())
		if t.tok != scanner.Comment {
			break
		}
		length := strings.Count(s.TokenText(), "\n")
		t.line += length
		histLine += length
		// TODO: If we ever have //go: comments in assembly, will need to keep them here.
		// For now, just discard all comments.
	}
	switch t.tok {
	case '\n':
		if t.file != nil {
			histLine++
		}
		t.line++
	case '-':
		if s.Peek() == '>' {
			s.Next()
			t.tok = ARR
			return ARR
		}
	case '@':
		if s.Peek() == '>' {
			s.Next()
			t.tok = ROT
			return ROT
		}
	case '<':
		if s.Peek() == '<' {
			s.Next()
			t.tok = LSH
			return LSH
		}
	case '>':
		if s.Peek() == '>' {
			s.Next()
			t.tok = RSH
			return RSH
		}
	}
	return t.tok
}

func (t *Tokenizer) Close() {
	if t.file != nil {
		t.file.Close()
		// It's an open file, so pop the line history.
		linkCtxt.LineHist.Pop(histLine)
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/local/go/src/cmd/asm/main.go                                                                    0100644 0000000 0000000 00000003151 13020111411 015122  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"flag"
	"fmt"
	"log"
	"os"

	"cmd/asm/internal/arch"
	"cmd/asm/internal/asm"
	"cmd/asm/internal/flags"
	"cmd/asm/internal/lex"

	"cmd/internal/obj"
)

func main() {
	log.SetFlags(0)
	log.SetPrefix("asm: ")

	GOARCH := obj.Getgoarch()

	architecture := arch.Set(GOARCH)
	if architecture == nil {
		log.Fatalf("asm: unrecognized architecture %s", GOARCH)
	}

	flags.Parse()

	// Create object file, write header.
	fd, err := os.Create(*flags.OutputFile)
	if err != nil {
		log.Fatal(err)
	}
	ctxt := obj.Linknew(architecture.LinkArch)
	if *flags.PrintOut {
		ctxt.Debugasm = 1
	}
	ctxt.LineHist.TrimPathPrefix = *flags.TrimPath
	ctxt.Flag_dynlink = *flags.Dynlink
	if *flags.Shared || *flags.Dynlink {
		ctxt.Flag_shared = 1
	}
	ctxt.Bso = obj.Binitw(os.Stdout)
	defer ctxt.Bso.Flush()
	output := obj.Binitw(fd)
	fmt.Fprintf(output, "go object %s %s %s\n", obj.Getgoos(), obj.Getgoarch(), obj.Getgoversion())
	fmt.Fprintf(output, "!\n")

	lexer := lex.NewLexer(flag.Arg(0), ctxt)
	parser := asm.NewParser(ctxt, architecture, lexer)
	diag := false
	ctxt.DiagFunc = func(format string, args ...interface{}) {
		diag = true
		log.Printf(format, args...)
	}
	pList := obj.Linknewplist(ctxt)
	var ok bool
	pList.Firstpc, ok = parser.Parse()
	if ok {
		// reports errors to parser.Errorf
		obj.Writeobjdirect(ctxt, output)
	}
	if !ok || diag {
		log.Printf("asm: assembly of %s failed", flag.Arg(0))
		os.Remove(*flags.OutputFile)
		os.Exit(1)
	}
	output.Flush()
}
                                                                                                                                                                                                                                                                                                                                                                                                                       usr/local/go/src/cmd/cgo/                                                                           0040755 0000000 0000000 00000000000 13101127300 013646  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/cmd/cgo/ast.go                                                                     0100644 0000000 0000000 00000027030 13020111411 014757  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Parse input AST and prepare Prog structure.

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/scanner"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

func parse(name string, flags parser.Mode) *ast.File {
	ast1, err := parser.ParseFile(fset, name, nil, flags)
	if err != nil {
		if list, ok := err.(scanner.ErrorList); ok {
			// If err is a scanner.ErrorList, its String will print just
			// the first error and then (+n more errors).
			// Instead, turn it into a new Error that will return
			// details for all the errors.
			for _, e := range list {
				fmt.Fprintln(os.Stderr, e)
			}
			os.Exit(2)
		}
		fatalf("parsing %s: %s", name, err)
	}
	return ast1
}

func sourceLine(n ast.Node) int {
	return fset.Position(n.Pos()).Line
}

// ReadGo populates f with information learned from reading the
// Go source file with the given file name.  It gathers the C preamble
// attached to the import "C" comment, a list of references to C.xxx,
// a list of exported functions, and the actual AST, to be rewritten and
// printed.
func (f *File) ReadGo(name string) {
	// Create absolute path for file, so that it will be used in error
	// messages and recorded in debug line number information.
	// This matches the rest of the toolchain. See golang.org/issue/5122.
	if aname, err := filepath.Abs(name); err == nil {
		name = aname
	}

	// Two different parses: once with comments, once without.
	// The printer is not good enough at printing comments in the
	// right place when we start editing the AST behind its back,
	// so we use ast1 to look for the doc comments on import "C"
	// and on exported functions, and we use ast2 for translating
	// and reprinting.
	ast1 := parse(name, parser.ParseComments)
	ast2 := parse(name, 0)

	f.Package = ast1.Name.Name
	f.Name = make(map[string]*Name)

	// In ast1, find the import "C" line and get any extra C preamble.
	sawC := false
	for _, decl := range ast1.Decls {
		d, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		for _, spec := range d.Specs {
			s, ok := spec.(*ast.ImportSpec)
			if !ok || string(s.Path.Value) != `"C"` {
				continue
			}
			sawC = true
			if s.Name != nil {
				error_(s.Path.Pos(), `cannot rename import "C"`)
			}
			cg := s.Doc
			if cg == nil && len(d.Specs) == 1 {
				cg = d.Doc
			}
			if cg != nil {
				f.Preamble += fmt.Sprintf("#line %d %q\n", sourceLine(cg), name)
				f.Preamble += commentText(cg) + "\n"
			}
		}
	}
	if !sawC {
		error_(token.NoPos, `cannot find import "C"`)
	}

	// In ast2, strip the import "C" line.
	w := 0
	for _, decl := range ast2.Decls {
		d, ok := decl.(*ast.GenDecl)
		if !ok {
			ast2.Decls[w] = decl
			w++
			continue
		}
		ws := 0
		for _, spec := range d.Specs {
			s, ok := spec.(*ast.ImportSpec)
			if !ok || string(s.Path.Value) != `"C"` {
				d.Specs[ws] = spec
				ws++
			}
		}
		if ws == 0 {
			continue
		}
		d.Specs = d.Specs[0:ws]
		ast2.Decls[w] = d
		w++
	}
	ast2.Decls = ast2.Decls[0:w]

	// Accumulate pointers to uses of C.x.
	if f.Ref == nil {
		f.Ref = make([]*Ref, 0, 8)
	}
	f.walk(ast2, "prog", (*File).saveExprs)

	// Accumulate exported functions.
	// The comments are only on ast1 but we need to
	// save the function bodies from ast2.
	// The first walk fills in ExpFunc, and the
	// second walk changes the entries to
	// refer to ast2 instead.
	f.walk(ast1, "prog", (*File).saveExport)
	f.walk(ast2, "prog", (*File).saveExport2)

	f.Comments = ast1.Comments
	f.AST = ast2
}

// Like ast.CommentGroup's Text method but preserves
// leading blank lines, so that line numbers line up.
func commentText(g *ast.CommentGroup) string {
	if g == nil {
		return ""
	}
	var pieces []string
	for _, com := range g.List {
		c := string(com.Text)
		// Remove comment markers.
		// The parser has given us exactly the comment text.
		switch c[1] {
		case '/':
			//-style comment (no newline at the end)
			c = c[2:] + "\n"
		case '*':
			/*-style comment */
			c = c[2 : len(c)-2]
		}
		pieces = append(pieces, c)
	}
	return strings.Join(pieces, "")
}

// Save various references we are going to need later.
func (f *File) saveExprs(x interface{}, context string) {
	switch x := x.(type) {
	case *ast.Expr:
		switch (*x).(type) {
		case *ast.SelectorExpr:
			f.saveRef(x, context)
		}
	case *ast.CallExpr:
		f.saveCall(x)
	}
}

// Save references to C.xxx for later processing.
func (f *File) saveRef(n *ast.Expr, context string) {
	sel := (*n).(*ast.SelectorExpr)
	// For now, assume that the only instance of capital C is when
	// used as the imported package identifier.
	// The parser should take care of scoping in the future, so
	// that we will be able to distinguish a "top-level C" from a
	// local C.
	if l, ok := sel.X.(*ast.Ident); !ok || l.Name != "C" {
		return
	}
	if context == "as2" {
		context = "expr"
	}
	if context == "embed-type" {
		error_(sel.Pos(), "cannot embed C type")
	}
	goname := sel.Sel.Name
	if goname == "errno" {
		error_(sel.Pos(), "cannot refer to errno directly; see documentation")
		return
	}
	if goname == "_CMalloc" {
		error_(sel.Pos(), "cannot refer to C._CMalloc; use C.malloc")
		return
	}
	if goname == "malloc" {
		goname = "_CMalloc"
	}
	name := f.Name[goname]
	if name == nil {
		name = &Name{
			Go: goname,
		}
		f.Name[goname] = name
	}
	f.Ref = append(f.Ref, &Ref{
		Name:    name,
		Expr:    n,
		Context: context,
	})
}

// Save calls to C.xxx for later processing.
func (f *File) saveCall(call *ast.CallExpr) {
	sel, ok := call.Fun.(*ast.SelectorExpr)
	if !ok {
		return
	}
	if l, ok := sel.X.(*ast.Ident); !ok || l.Name != "C" {
		return
	}
	f.Calls = append(f.Calls, call)
}

// If a function should be exported add it to ExpFunc.
func (f *File) saveExport(x interface{}, context string) {
	n, ok := x.(*ast.FuncDecl)
	if !ok {
		return
	}

	if n.Doc == nil {
		return
	}
	for _, c := range n.Doc.List {
		if !strings.HasPrefix(string(c.Text), "//export ") {
			continue
		}

		name := strings.TrimSpace(string(c.Text[9:]))
		if name == "" {
			error_(c.Pos(), "export missing name")
		}

		if name != n.Name.Name {
			error_(c.Pos(), "export comment has wrong name %q, want %q", name, n.Name.Name)
		}

		doc := ""
		for _, c1 := range n.Doc.List {
			if c1 != c {
				doc += c1.Text + "\n"
			}
		}

		f.ExpFunc = append(f.ExpFunc, &ExpFunc{
			Func:    n,
			ExpName: name,
			Doc:     doc,
		})
		break
	}
}

// Make f.ExpFunc[i] point at the Func from this AST instead of the other one.
func (f *File) saveExport2(x interface{}, context string) {
	n, ok := x.(*ast.FuncDecl)
	if !ok {
		return
	}

	for _, exp := range f.ExpFunc {
		if exp.Func.Name.Name == n.Name.Name {
			exp.Func = n
			break
		}
	}
}

// walk walks the AST x, calling visit(f, x, context) for each node.
func (f *File) walk(x interface{}, context string, visit func(*File, interface{}, string)) {
	visit(f, x, context)
	switch n := x.(type) {
	case *ast.Expr:
		f.walk(*n, context, visit)

	// everything else just recurs
	default:
		error_(token.NoPos, "unexpected type %T in walk", x, visit)
		panic("unexpected type")

	case nil:

	// These are ordered and grouped to match ../../go/ast/ast.go
	case *ast.Field:
		if len(n.Names) == 0 && context == "field" {
			f.walk(&n.Type, "embed-type", visit)
		} else {
			f.walk(&n.Type, "type", visit)
		}
	case *ast.FieldList:
		for _, field := range n.List {
			f.walk(field, context, visit)
		}
	case *ast.BadExpr:
	case *ast.Ident:
	case *ast.Ellipsis:
	case *ast.BasicLit:
	case *ast.FuncLit:
		f.walk(n.Type, "type", visit)
		f.walk(n.Body, "stmt", visit)
	case *ast.CompositeLit:
		f.walk(&n.Type, "type", visit)
		f.walk(n.Elts, "expr", visit)
	case *ast.ParenExpr:
		f.walk(&n.X, context, visit)
	case *ast.SelectorExpr:
		f.walk(&n.X, "selector", visit)
	case *ast.IndexExpr:
		f.walk(&n.X, "expr", visit)
		f.walk(&n.Index, "expr", visit)
	case *ast.SliceExpr:
		f.walk(&n.X, "expr", visit)
		if n.Low != nil {
			f.walk(&n.Low, "expr", visit)
		}
		if n.High != nil {
			f.walk(&n.High, "expr", visit)
		}
		if n.Max != nil {
			f.walk(&n.Max, "expr", visit)
		}
	case *ast.TypeAssertExpr:
		f.walk(&n.X, "expr", visit)
		f.walk(&n.Type, "type", visit)
	case *ast.CallExpr:
		if context == "as2" {
			f.walk(&n.Fun, "call2", visit)
		} else {
			f.walk(&n.Fun, "call", visit)
		}
		f.walk(n.Args, "expr", visit)
	case *ast.StarExpr:
		f.walk(&n.X, context, visit)
	case *ast.UnaryExpr:
		f.walk(&n.X, "expr", visit)
	case *ast.BinaryExpr:
		f.walk(&n.X, "expr", visit)
		f.walk(&n.Y, "expr", visit)
	case *ast.KeyValueExpr:
		f.walk(&n.Key, "expr", visit)
		f.walk(&n.Value, "expr", visit)

	case *ast.ArrayType:
		f.walk(&n.Len, "expr", visit)
		f.walk(&n.Elt, "type", visit)
	case *ast.StructType:
		f.walk(n.Fields, "field", visit)
	case *ast.FuncType:
		f.walk(n.Params, "param", visit)
		if n.Results != nil {
			f.walk(n.Results, "param", visit)
		}
	case *ast.InterfaceType:
		f.walk(n.Methods, "field", visit)
	case *ast.MapType:
		f.walk(&n.Key, "type", visit)
		f.walk(&n.Value, "type", visit)
	case *ast.ChanType:
		f.walk(&n.Value, "type", visit)

	case *ast.BadStmt:
	case *ast.DeclStmt:
		f.walk(n.Decl, "decl", visit)
	case *ast.EmptyStmt:
	case *ast.LabeledStmt:
		f.walk(n.Stmt, "stmt", visit)
	case *ast.ExprStmt:
		f.walk(&n.X, "expr", visit)
	case *ast.SendStmt:
		f.walk(&n.Chan, "expr", visit)
		f.walk(&n.Value, "expr", visit)
	case *ast.IncDecStmt:
		f.walk(&n.X, "expr", visit)
	case *ast.AssignStmt:
		f.walk(n.Lhs, "expr", visit)
		if len(n.Lhs) == 2 && len(n.Rhs) == 1 {
			f.walk(n.Rhs, "as2", visit)
		} else {
			f.walk(n.Rhs, "expr", visit)
		}
	case *ast.GoStmt:
		f.walk(n.Call, "expr", visit)
	case *ast.DeferStmt:
		f.walk(n.Call, "expr", visit)
	case *ast.ReturnStmt:
		f.walk(n.Results, "expr", visit)
	case *ast.BranchStmt:
	case *ast.BlockStmt:
		f.walk(n.List, context, visit)
	case *ast.IfStmt:
		f.walk(n.Init, "stmt", visit)
		f.walk(&n.Cond, "expr", visit)
		f.walk(n.Body, "stmt", visit)
		f.walk(n.Else, "stmt", visit)
	case *ast.CaseClause:
		if context == "typeswitch" {
			context = "type"
		} else {
			context = "expr"
		}
		f.walk(n.List, context, visit)
		f.walk(n.Body, "stmt", visit)
	case *ast.SwitchStmt:
		f.walk(n.Init, "stmt", visit)
		f.walk(&n.Tag, "expr", visit)
		f.walk(n.Body, "switch", visit)
	case *ast.TypeSwitchStmt:
		f.walk(n.Init, "stmt", visit)
		f.walk(n.Assign, "stmt", visit)
		f.walk(n.Body, "typeswitch", visit)
	case *ast.CommClause:
		f.walk(n.Comm, "stmt", visit)
		f.walk(n.Body, "stmt", visit)
	case *ast.SelectStmt:
		f.walk(n.Body, "stmt", visit)
	case *ast.ForStmt:
		f.walk(n.Init, "stmt", visit)
		f.walk(&n.Cond, "expr", visit)
		f.walk(n.Post, "stmt", visit)
		f.walk(n.Body, "stmt", visit)
	case *ast.RangeStmt:
		f.walk(&n.Key, "expr", visit)
		f.walk(&n.Value, "expr", visit)
		f.walk(&n.X, "expr", visit)
		f.walk(n.Body, "stmt", visit)

	case *ast.ImportSpec:
	case *ast.ValueSpec:
		f.walk(&n.Type, "type", visit)
		f.walk(n.Values, "expr", visit)
	case *ast.TypeSpec:
		f.walk(&n.Type, "type", visit)

	case *ast.BadDecl:
	case *ast.GenDecl:
		f.walk(n.Specs, "spec", visit)
	case *ast.FuncDecl:
		if n.Recv != nil {
			f.walk(n.Recv, "param", visit)
		}
		f.walk(n.Type, "type", visit)
		if n.Body != nil {
			f.walk(n.Body, "stmt", visit)
		}

	case *ast.File:
		f.walk(n.Decls, "decl", visit)

	case *ast.Package:
		for _, file := range n.Files {
			f.walk(file, "file", visit)
		}

	case []ast.Decl:
		for _, d := range n {
			f.walk(d, context, visit)
		}
	case []ast.Expr:
		for i := range n {
			f.walk(&n[i], context, visit)
		}
	case []ast.Stmt:
		for _, s := range n {
			f.walk(s, context, visit)
		}
	case []ast.Spec:
		for _, s := range n {
			f.walk(s, context, visit)
		}
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        usr/local/go/src/cmd/cgo/doc.go                                                                     0100644 0000000 0000000 00000100454 13020111411 014737  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

/*

Cgo enables the creation of Go packages that call C code.

Using cgo with the go command

To use cgo write normal Go code that imports a pseudo-package "C".
The Go code can then refer to types such as C.size_t, variables such
as C.stdout, or functions such as C.putchar.

If the import of "C" is immediately preceded by a comment, that
comment, called the preamble, is used as a header when compiling
the C parts of the package.  For example:

	// #include <stdio.h>
	// #include <errno.h>
	import "C"

The preamble may contain any C code, including function and variable
declarations and definitions.  These may then be referred to from Go
code as though they were defined in the package "C".  All names
declared in the preamble may be used, even if they start with a
lower-case letter.  Exception: static variables in the preamble may
not be referenced from Go code; static functions are permitted.

See $GOROOT/misc/cgo/stdio and $GOROOT/misc/cgo/gmp for examples.  See
"C? Go? Cgo!" for an introduction to using cgo:
https://golang.org/doc/articles/c_go_cgo.html.

CFLAGS, CPPFLAGS, CXXFLAGS and LDFLAGS may be defined with pseudo #cgo
directives within these comments to tweak the behavior of the C or C++
compiler.  Values defined in multiple directives are concatenated
together.  The directive can include a list of build constraints limiting its
effect to systems satisfying one of the constraints
(see https://golang.org/pkg/go/build/#hdr-Build_Constraints for details about the constraint syntax).
For example:

	// #cgo CFLAGS: -DPNG_DEBUG=1
	// #cgo amd64 386 CFLAGS: -DX86=1
	// #cgo LDFLAGS: -lpng
	// #include <png.h>
	import "C"

Alternatively, CPPFLAGS and LDFLAGS may be obtained via the pkg-config
tool using a '#cgo pkg-config:' directive followed by the package names.
For example:

	// #cgo pkg-config: png cairo
	// #include <png.h>
	import "C"

When building, the CGO_CFLAGS, CGO_CPPFLAGS, CGO_CXXFLAGS and
CGO_LDFLAGS environment variables are added to the flags derived from
these directives.  Package-specific flags should be set using the
directives, not the environment variables, so that builds work in
unmodified environments.

All the cgo CPPFLAGS and CFLAGS directives in a package are concatenated and
used to compile C files in that package.  All the CPPFLAGS and CXXFLAGS
directives in a package are concatenated and used to compile C++ files in that
package.  All the LDFLAGS directives in any package in the program are
concatenated and used at link time.  All the pkg-config directives are
concatenated and sent to pkg-config simultaneously to add to each appropriate
set of command-line flags.

When the cgo directives are parsed, any occurrence of the string ${SRCDIR}
will be replaced by the absolute path to the directory containing the source
file. This allows pre-compiled static libraries to be included in the package
directory and linked properly.
For example if package foo is in the directory /go/src/foo:

       // #cgo LDFLAGS: -L${SRCDIR}/libs -lfoo

Will be expanded to:

       // #cgo LDFLAGS: -L/go/src/foo/libs -lfoo

When the Go tool sees that one or more Go files use the special import
"C", it will look for other non-Go files in the directory and compile
them as part of the Go package.  Any .c, .s, or .S files will be
compiled with the C compiler.  Any .cc, .cpp, or .cxx files will be
compiled with the C++ compiler.  Any .h, .hh, .hpp, or .hxx files will
not be compiled separately, but, if these header files are changed,
the C and C++ files will be recompiled.  The default C and C++
compilers may be changed by the CC and CXX environment variables,
respectively; those environment variables may include command line
options.

The cgo tool is enabled by default for native builds on systems where
it is expected to work.  It is disabled by default when
cross-compiling.  You can control this by setting the CGO_ENABLED
environment variable when running the go tool: set it to 1 to enable
the use of cgo, and to 0 to disable it.  The go tool will set the
build constraint "cgo" if cgo is enabled.

When cross-compiling, you must specify a C cross-compiler for cgo to
use.  You can do this by setting the CC_FOR_TARGET environment
variable when building the toolchain using make.bash, or by setting
the CC environment variable any time you run the go tool.  The
CXX_FOR_TARGET and CXX environment variables work in a similar way for
C++ code.

Go references to C

Within the Go file, C's struct field names that are keywords in Go
can be accessed by prefixing them with an underscore: if x points at a C
struct with a field named "type", x._type accesses the field.
C struct fields that cannot be expressed in Go, such as bit fields
or misaligned data, are omitted in the Go struct, replaced by
appropriate padding to reach the next field or the end of the struct.

The standard C numeric types are available under the names
C.char, C.schar (signed char), C.uchar (unsigned char),
C.short, C.ushort (unsigned short), C.int, C.uint (unsigned int),
C.long, C.ulong (unsigned long), C.longlong (long long),
C.ulonglong (unsigned long long), C.float, C.double,
C.complexfloat (complex float), and C.complexdouble (complex double).
The C type void* is represented by Go's unsafe.Pointer.
The C types __int128_t and __uint128_t are represented by [16]byte.

To access a struct, union, or enum type directly, prefix it with
struct_, union_, or enum_, as in C.struct_stat.

The size of any C type T is available as C.sizeof_T, as in
C.sizeof_struct_stat.

As Go doesn't have support for C's union type in the general case,
C's union types are represented as a Go byte array with the same length.

Go structs cannot embed fields with C types.

Go code can not refer to zero-sized fields that occur at the end of
non-empty C structs.  To get the address of such a field (which is the
only operation you can do with a zero-sized field) you must take the
address of the struct and add the size of the struct.

Cgo translates C types into equivalent unexported Go types.
Because the translations are unexported, a Go package should not
expose C types in its exported API: a C type used in one Go package
is different from the same C type used in another.

Any C function (even void functions) may be called in a multiple
assignment context to retrieve both the return value (if any) and the
C errno variable as an error (use _ to skip the result value if the
function returns void).  For example:

	n, err := C.sqrt(-1)
	_, err := C.voidFunc()

Calling C function pointers is currently not supported, however you can
declare Go variables which hold C function pointers and pass them
back and forth between Go and C. C code may call function pointers
received from Go. For example:

	package main

	// typedef int (*intFunc) ();
	//
	// int
	// bridge_int_func(intFunc f)
	// {
	//		return f();
	// }
	//
	// int fortytwo()
	// {
	//	    return 42;
	// }
	import "C"
	import "fmt"

	func main() {
		f := C.intFunc(C.fortytwo)
		fmt.Println(int(C.bridge_int_func(f)))
		// Output: 42
	}

In C, a function argument written as a fixed size array
actually requires a pointer to the first element of the array.
C compilers are aware of this calling convention and adjust
the call accordingly, but Go cannot.  In Go, you must pass
the pointer to the first element explicitly: C.f(&C.x[0]).

A few special functions convert between Go and C types
by making copies of the data.  In pseudo-Go definitions:

	// Go string to C string
	// The C string is allocated in the C heap using malloc.
	// It is the caller's responsibility to arrange for it to be
	// freed, such as by calling C.free (be sure to include stdlib.h
	// if C.free is needed).
	func C.CString(string) *C.char

	// C string to Go string
	func C.GoString(*C.char) string

	// C data with explicit length to Go string
	func C.GoStringN(*C.char, C.int) string

	// C data with explicit length to Go []byte
	func C.GoBytes(unsafe.Pointer, C.int) []byte

C references to Go

Go functions can be exported for use by C code in the following way:

	//export MyFunction
	func MyFunction(arg1, arg2 int, arg3 string) int64 {...}

	//export MyFunction2
	func MyFunction2(arg1, arg2 int, arg3 string) (int64, *C.char) {...}

They will be available in the C code as:

	extern int64 MyFunction(int arg1, int arg2, GoString arg3);
	extern struct MyFunction2_return MyFunction2(int arg1, int arg2, GoString arg3);

found in the _cgo_export.h generated header, after any preambles
copied from the cgo input files. Functions with multiple
return values are mapped to functions returning a struct.
Not all Go types can be mapped to C types in a useful way.

Using //export in a file places a restriction on the preamble:
since it is copied into two different C output files, it must not
contain any definitions, only declarations. If a file contains both
definitions and declarations, then the two output files will produce
duplicate symbols and the linker will fail. To avoid this, definitions
must be placed in preambles in other files, or in C source files.

Passing pointers

Go is a garbage collected language, and the garbage collector needs to
know the location of every pointer to Go memory.  Because of this,
there are restrictions on passing pointers between Go and C.

In this section the term Go pointer means a pointer to memory
allocated by Go (such as by using the & operator or calling the
predefined new function) and the term C pointer means a pointer to
memory allocated by C (such as by a call to C.malloc).  Whether a
pointer is a Go pointer or a C pointer is a dynamic property
determined by how the memory was allocated; it has nothing to do with
the type of the pointer.

Go code may pass a Go pointer to C provided the Go memory to which it
points does not contain any Go pointers.  The C code must preserve
this property: it must not store any Go pointers in Go memory, even
temporarily.  When passing a pointer to a field in a struct, the Go
memory in question is the memory occupied by the field, not the entire
struct.  When passing a pointer to an element in an array or slice,
the Go memory in question is the entire array or the entire backing
array of the slice.

C code may not keep a copy of a Go pointer after the call returns.

A Go function called by C code may not return a Go pointer.  A Go
function called by C code may take C pointers as arguments, and it may
store non-pointer or C pointer data through those pointers, but it may
not store a Go pointer in memory pointed to by a C pointer.  A Go
function called by C code may take a Go pointer as an argument, but it
must preserve the property that the Go memory to which it points does
not contain any Go pointers.

Go code may not store a Go pointer in C memory.  C code may store Go
pointers in C memory, subject to the rule above: it must stop storing
the Go pointer when the C function returns.

These rules are checked dynamically at runtime.  The checking is
controlled by the cgocheck setting of the GODEBUG environment
variable.  The default setting is GODEBUG=cgocheck=1, which implements
reasonably cheap dynamic checks.  These checks may be disabled
entirely using GODEBUG=cgocheck=0.  Complete checking of pointer
handling, at some cost in run time, is available via GODEBUG=cgocheck=2.

It is possible to defeat this enforcement by using the unsafe package,
and of course there is nothing stopping the C code from doing anything
it likes.  However, programs that break these rules are likely to fail
in unexpected and unpredictable ways.

Using cgo directly

Usage:
	go tool cgo [cgo options] [-- compiler options] gofiles...

Cgo transforms the specified input Go source files into several output
Go and C source files.

The compiler options are passed through uninterpreted when
invoking the C compiler to compile the C parts of the package.

The following options are available when running cgo directly:

	-dynimport file
		Write list of symbols imported by file. Write to
		-dynout argument or to standard output. Used by go
		build when building a cgo package.
	-dynout file
		Write -dynimport output to file.
	-dynpackage package
		Set Go package for -dynimport output.
	-dynlinker
		Write dynamic linker as part of -dynimport output.
	-godefs
		Write out input file in Go syntax replacing C package
		names with real values. Used to generate files in the
		syscall package when bootstrapping a new target.
	-objdir directory
		Put all generated files in directory.
	-importpath string
		The import path for the Go package. Optional; used for
		nicer comments in the generated files.
	-exportheader file
		If there are any exported functions, write the
		generated export declarations to file.
		C code can #include this to see the declarations.
	-gccgo
		Generate output for the gccgo compiler rather than the
		gc compiler.
	-gccgoprefix prefix
		The -fgo-prefix option to be used with gccgo.
	-gccgopkgpath path
		The -fgo-pkgpath option to be used with gccgo.
	-import_runtime_cgo
		If set (which it is by default) import runtime/cgo in
		generated output.
	-import_syscall
		If set (which it is by default) import syscall in
		generated output.
	-debug-define
		Debugging option. Print #defines.
	-debug-gcc
		Debugging option. Trace C compiler execution and output.
*/
package main

/*
Implementation details.

Cgo provides a way for Go programs to call C code linked into the same
address space. This comment explains the operation of cgo.

Cgo reads a set of Go source files and looks for statements saying
import "C". If the import has a doc comment, that comment is
taken as literal C code to be used as a preamble to any C code
generated by cgo. A typical preamble #includes necessary definitions:

	// #include <stdio.h>
	import "C"

For more details about the usage of cgo, see the documentation
comment at the top of this file.

Understanding C

Cgo scans the Go source files that import "C" for uses of that
package, such as C.puts. It collects all such identifiers. The next
step is to determine each kind of name. In C.xxx the xxx might refer
to a type, a function, a constant, or a global variable. Cgo must
decide which.

The obvious thing for cgo to do is to process the preamble, expanding
#includes and processing the corresponding C code. That would require
a full C parser and type checker that was also aware of any extensions
known to the system compiler (for example, all the GNU C extensions) as
well as the system-specific header locations and system-specific
pre-#defined macros. This is certainly possible to do, but it is an
enormous amount of work.

Cgo takes a different approach. It determines the meaning of C
identifiers not by parsing C code but by feeding carefully constructed
programs into the system C compiler and interpreting the generated
error messages, debug information, and object files. In practice,
parsing these is significantly less work and more robust than parsing
C source.

Cgo first invokes gcc -E -dM on the preamble, in order to find out
about simple #defines for constants and the like. These are recorded
for later use.

Next, cgo needs to identify the kinds for each identifier. For the
identifiers C.foo and C.bar, cgo generates this C program:

	<preamble>
	#line 1 "not-declared"
	void __cgo_f_xxx_1(void) { __typeof__(foo) *__cgo_undefined__; }
	#line 1 "not-type"
	void __cgo_f_xxx_2(void) { foo *__cgo_undefined__; }
	#line 1 "not-const"
	void __cgo_f_xxx_3(void) { enum { __cgo_undefined__ = (foo)*1 }; }
	#line 2 "not-declared"
	void __cgo_f_xxx_1(void) { __typeof__(bar) *__cgo_undefined__; }
	#line 2 "not-type"
	void __cgo_f_xxx_2(void) { bar *__cgo_undefined__; }
	#line 2 "not-const"
	void __cgo_f_xxx_3(void) { enum { __cgo_undefined__ = (bar)*1 }; }

This program will not compile, but cgo can use the presence or absence
of an error message on a given line to deduce the information it
needs. The program is syntactically valid regardless of whether each
name is a type or an ordinary identifier, so there will be no syntax
errors that might stop parsing early.

An error on not-declared:1 indicates that foo is undeclared.
An error on not-type:1 indicates that foo is not a type (if declared at all, it is an identifier).
An error on not-const:1 indicates that foo is not an integer constant.

The line number specifies the name involved. In the example, 1 is foo and 2 is bar.

Next, cgo must learn the details of each type, variable, function, or
constant. It can do this by reading object files. If cgo has decided
that t1 is a type, v2 and v3 are variables or functions, and c4, c5,
and c6 are constants, it generates:

	<preamble>
	__typeof__(t1) *__cgo__1;
	__typeof__(v2) *__cgo__2;
	__typeof__(v3) *__cgo__3;
	__typeof__(c4) *__cgo__4;
	enum { __cgo_enum__4 = c4 };
	__typeof__(c5) *__cgo__5;
	enum { __cgo_enum__5 = c5 };
	__typeof__(c6) *__cgo__6;
	enum { __cgo_enum__6 = c6 };

	long long __cgo_debug_data[] = {
		0, // t1
		0, // v2
		0, // v3
		c4,
		c5,
		c6,
		1
	};

and again invokes the system C compiler, to produce an object file
containing debug information. Cgo parses the DWARF debug information
for __cgo__N to learn the type of each identifier. (The types also
distinguish functions from global variables.) If using a standard gcc,
cgo can parse the DWARF debug information for the __cgo_enum__N to
learn the identifier's value. The LLVM-based gcc on OS X emits
incomplete DWARF information for enums; in that case cgo reads the
constant values from the __cgo_debug_data from the object file's data
segment.

At this point cgo knows the meaning of each C.xxx well enough to start
the translation process.

Translating Go

Given the input Go files x.go and y.go, cgo generates these source
files:

	x.cgo1.go       # for gc (cmd/compile)
	y.cgo1.go       # for gc
	_cgo_gotypes.go # for gc
	_cgo_import.go  # for gc (if -dynout _cgo_import.go)
	x.cgo2.c        # for gcc
	y.cgo2.c        # for gcc
	_cgo_defun.c    # for gcc (if -gccgo)
	_cgo_export.c   # for gcc
	_cgo_export.h   # for gcc
	_cgo_main.c     # for gcc
	_cgo_flags      # for alternative build tools

The file x.cgo1.go is a copy of x.go with the import "C" removed and
references to C.xxx replaced with names like _Cfunc_xxx or _Ctype_xxx.
The definitions of those identifiers, written as Go functions, types,
or variables, are provided in _cgo_gotypes.go.

Here is a _cgo_gotypes.go containing definitions for needed C types:

	type _Ctype_char int8
	type _Ctype_int int32
	type _Ctype_void [0]byte

The _cgo_gotypes.go file also contains the definitions of the
functions.  They all have similar bodies that invoke runtime·cgocall
to make a switch from the Go runtime world to the system C (GCC-based)
world.

For example, here is the definition of _Cfunc_puts:

	//go:cgo_import_static _cgo_be59f0f25121_Cfunc_puts
	//go:linkname __cgofn__cgo_be59f0f25121_Cfunc_puts _cgo_be59f0f25121_Cfunc_puts
	var __cgofn__cgo_be59f0f25121_Cfunc_puts byte
	var _cgo_be59f0f25121_Cfunc_puts = unsafe.Pointer(&__cgofn__cgo_be59f0f25121_Cfunc_puts)

	func _Cfunc_puts(p0 *_Ctype_char) (r1 _Ctype_int) {
		_cgo_runtime_cgocall(_cgo_be59f0f25121_Cfunc_puts, uintptr(unsafe.Pointer(&p0)))
		return
	}

The hexadecimal number is a hash of cgo's input, chosen to be
deterministic yet unlikely to collide with other uses. The actual
function _cgo_be59f0f25121_Cfunc_puts is implemented in a C source
file compiled by gcc, the file x.cgo2.c:

	void
	_cgo_be59f0f25121_Cfunc_puts(void *v)
	{
		_cgo_wait_runtime_init_done();
		struct {
			char* p0;
			int r;
			char __pad12[4];
		} __attribute__((__packed__, __gcc_struct__)) *a = v;
		a->r = puts((void*)a->p0);
	}

It waits for Go runtime to be initialized (required for shared libraries),
extracts the arguments from the pointer to _Cfunc_puts's argument
frame, invokes the system C function (in this case, puts), stores the
result in the frame, and returns.

Linking

Once the _cgo_export.c and *.cgo2.c files have been compiled with gcc,
they need to be linked into the final binary, along with the libraries
they might depend on (in the case of puts, stdio). cmd/link has been
extended to understand basic ELF files, but it does not understand ELF
in the full complexity that modern C libraries embrace, so it cannot
in general generate direct references to the system libraries.

Instead, the build process generates an object file using dynamic
linkage to the desired libraries. The main function is provided by
_cgo_main.c:

	int main() { return 0; }
	void crosscall2(void(*fn)(void*, int), void *a, int c) { }
	void _cgo_wait_runtime_init_done() { }
	void _cgo_allocate(void *a, int c) { }
	void _cgo_panic(void *a, int c) { }

The extra functions here are stubs to satisfy the references in the C
code generated for gcc. The build process links this stub, along with
_cgo_export.c and *.cgo2.c, into a dynamic executable and then lets
cgo examine the executable. Cgo records the list of shared library
references and resolved names and writes them into a new file
_cgo_import.go, which looks like:

	//go:cgo_dynamic_linker "/lib64/ld-linux-x86-64.so.2"
	//go:cgo_import_dynamic puts puts#GLIBC_2.2.5 "libc.so.6"
	//go:cgo_import_dynamic __libc_start_main __libc_start_main#GLIBC_2.2.5 "libc.so.6"
	//go:cgo_import_dynamic stdout stdout#GLIBC_2.2.5 "libc.so.6"
	//go:cgo_import_dynamic fflush fflush#GLIBC_2.2.5 "libc.so.6"
	//go:cgo_import_dynamic _ _ "libpthread.so.0"
	//go:cgo_import_dynamic _ _ "libc.so.6"

In the end, the compiled Go package, which will eventually be
presented to cmd/link as part of a larger program, contains:

	_go_.o        # gc-compiled object for _cgo_gotypes.go, _cgo_import.go, *.cgo1.go
	_all.o        # gcc-compiled object for _cgo_export.c, *.cgo2.c

The final program will be a dynamic executable, so that cmd/link can avoid
needing to process arbitrary .o files. It only needs to process the .o
files generated from C files that cgo writes, and those are much more
limited in the ELF or other features that they use.

In essence, the _cgo_import.o file includes the extra linking
directives that cmd/link is not sophisticated enough to derive from _all.o
on its own. Similarly, the _all.o uses dynamic references to real
system object code because cmd/link is not sophisticated enough to process
the real code.

The main benefits of this system are that cmd/link remains relatively simple
(it does not need to implement a complete ELF and Mach-O linker) and
that gcc is not needed after the package is compiled. For example,
package net uses cgo for access to name resolution functions provided
by libc. Although gcc is needed to compile package net, gcc is not
needed to link programs that import package net.

Runtime

When using cgo, Go must not assume that it owns all details of the
process. In particular it needs to coordinate with C in the use of
threads and thread-local storage. The runtime package declares a few
variables:

	var (
		iscgo             bool
		_cgo_init         unsafe.Pointer
		_cgo_thread_start unsafe.Pointer
	)

Any package using cgo imports "runtime/cgo", which provides
initializations for these variables. It sets iscgo to true, _cgo_init
to a gcc-compiled function that can be called early during program
startup, and _cgo_thread_start to a gcc-compiled function that can be
used to create a new thread, in place of the runtime's usual direct
system calls.

Internal and External Linking

The text above describes "internal" linking, in which cmd/link parses and
links host object files (ELF, Mach-O, PE, and so on) into the final
executable itself. Keeping cmd/link simple means we cannot possibly
implement the full semantics of the host linker, so the kinds of
objects that can be linked directly into the binary is limited (other
code can only be used as a dynamic library). On the other hand, when
using internal linking, cmd/link can generate Go binaries by itself.

In order to allow linking arbitrary object files without requiring
dynamic libraries, cgo supports an "external" linking mode too. In
external linking mode, cmd/link does not process any host object files.
Instead, it collects all the Go code and writes a single go.o object
file containing it. Then it invokes the host linker (usually gcc) to
combine the go.o object file and any supporting non-Go code into a
final executable. External linking avoids the dynamic library
requirement but introduces a requirement that the host linker be
present to create such a binary.

Most builds both compile source code and invoke the linker to create a
binary. When cgo is involved, the compile step already requires gcc, so
it is not problematic for the link step to require gcc too.

An important exception is builds using a pre-compiled copy of the
standard library. In particular, package net uses cgo on most systems,
and we want to preserve the ability to compile pure Go code that
imports net without requiring gcc to be present at link time. (In this
case, the dynamic library requirement is less significant, because the
only library involved is libc.so, which can usually be assumed
present.)

This conflict between functionality and the gcc requirement means we
must support both internal and external linking, depending on the
circumstances: if net is the only cgo-using package, then internal
linking is probably fine, but if other packages are involved, so that there
are dependencies on libraries beyond libc, external linking is likely
to work better. The compilation of a package records the relevant
information to support both linking modes, leaving the decision
to be made when linking the final binary.

Linking Directives

In either linking mode, package-specific directives must be passed
through to cmd/link. These are communicated by writing //go: directives in a
Go source file compiled by gc. The directives are copied into the .o
object file and then processed by the linker.

The directives are:

//go:cgo_import_dynamic <local> [<remote> ["<library>"]]

	In internal linking mode, allow an unresolved reference to
	<local>, assuming it will be resolved by a dynamic library
	symbol. The optional <remote> specifies the symbol's name and
	possibly version in the dynamic library, and the optional "<library>"
	names the specific library where the symbol should be found.

	In the <remote>, # or @ can be used to introduce a symbol version.

	Examples:
	//go:cgo_import_dynamic puts
	//go:cgo_import_dynamic puts puts#GLIBC_2.2.5
	//go:cgo_import_dynamic puts puts#GLIBC_2.2.5 "libc.so.6"

	A side effect of the cgo_import_dynamic directive with a
	library is to make the final binary depend on that dynamic
	library. To get the dependency without importing any specific
	symbols, use _ for local and remote.

	Example:
	//go:cgo_import_dynamic _ _ "libc.so.6"

	For compatibility with current versions of SWIG,
	#pragma dynimport is an alias for //go:cgo_import_dynamic.

//go:cgo_dynamic_linker "<path>"

	In internal linking mode, use "<path>" as the dynamic linker
	in the final binary. This directive is only needed from one
	package when constructing a binary; by convention it is
	supplied by runtime/cgo.

	Example:
	//go:cgo_dynamic_linker "/lib/ld-linux.so.2"

//go:cgo_export_dynamic <local> <remote>

	In internal linking mode, put the Go symbol
	named <local> into the program's exported symbol table as
	<remote>, so that C code can refer to it by that name. This
	mechanism makes it possible for C code to call back into Go or
	to share Go's data.

	For compatibility with current versions of SWIG,
	#pragma dynexport is an alias for //go:cgo_export_dynamic.

//go:cgo_import_static <local>

	In external linking mode, allow unresolved references to
	<local> in the go.o object file prepared for the host linker,
	under the assumption that <local> will be supplied by the
	other object files that will be linked with go.o.

	Example:
	//go:cgo_import_static puts_wrapper

//go:cgo_export_static <local> <remote>

	In external linking mode, put the Go symbol
	named <local> into the program's exported symbol table as
	<remote>, so that C code can refer to it by that name. This
	mechanism makes it possible for C code to call back into Go or
	to share Go's data.

//go:cgo_ldflag "<arg>"

	In external linking mode, invoke the host linker (usually gcc)
	with "<arg>" as a command-line argument following the .o files.
	Note that the arguments are for "gcc", not "ld".

	Example:
	//go:cgo_ldflag "-lpthread"
	//go:cgo_ldflag "-L/usr/local/sqlite3/lib"

A package compiled with cgo will include directives for both
internal and external linking; the linker will select the appropriate
subset for the chosen linking mode.

Example

As a simple example, consider a package that uses cgo to call C.sin.
The following code will be generated by cgo:

	// compiled by gc

	//go:cgo_ldflag "-lm"

	type _Ctype_double float64

	//go:cgo_import_static _cgo_gcc_Cfunc_sin
	//go:linkname __cgo_gcc_Cfunc_sin _cgo_gcc_Cfunc_sin
	var __cgo_gcc_Cfunc_sin byte
	var _cgo_gcc_Cfunc_sin = unsafe.Pointer(&__cgo_gcc_Cfunc_sin)

	func _Cfunc_sin(p0 _Ctype_double) (r1 _Ctype_double) {
		_cgo_runtime_cgocall(_cgo_gcc_Cfunc_sin, uintptr(unsafe.Pointer(&p0)))
		return
	}

	// compiled by gcc, into foo.cgo2.o

	void
	_cgo_gcc_Cfunc_sin(void *v)
	{
		struct {
			double p0;
			double r;
		} __attribute__((__packed__)) *a = v;
		a->r = sin(a->p0);
	}

What happens at link time depends on whether the final binary is linked
using the internal or external mode. If other packages are compiled in
"external only" mode, then the final link will be an external one.
Otherwise the link will be an internal one.

The linking directives are used according to the kind of final link
used.

In internal mode, cmd/link itself processes all the host object files, in
particular foo.cgo2.o. To do so, it uses the cgo_import_dynamic and
cgo_dynamic_linker directives to learn that the otherwise undefined
reference to sin in foo.cgo2.o should be rewritten to refer to the
symbol sin with version GLIBC_2.2.5 from the dynamic library
"libm.so.6", and the binary should request "/lib/ld-linux.so.2" as its
runtime dynamic linker.

In external mode, cmd/link does not process any host object files, in
particular foo.cgo2.o. It links together the gc-generated object
files, along with any other Go code, into a go.o file. While doing
that, cmd/link will discover that there is no definition for
_cgo_gcc_Cfunc_sin, referred to by the gc-compiled source file. This
is okay, because cmd/link also processes the cgo_import_static directive and
knows that _cgo_gcc_Cfunc_sin is expected to be supplied by a host
object file, so cmd/link does not treat the missing symbol as an error when
creating go.o. Indeed, the definition for _cgo_gcc_Cfunc_sin will be
provided to the host linker by foo2.cgo.o, which in turn will need the
symbol 'sin'. cmd/link also processes the cgo_ldflag directives, so that it
knows that the eventual host link command must include the -lm
argument, so that the host linker will be able to find 'sin' in the
math library.

cmd/link Command Line Interface

The go command and any other Go-aware build systems invoke cmd/link
to link a collection of packages into a single binary. By default, cmd/link will
present the same interface it does today:

	cmd/link main.a

produces a file named a.out, even if cmd/link does so by invoking the host
linker in external linking mode.

By default, cmd/link will decide the linking mode as follows: if the only
packages using cgo are those on a whitelist of standard library
packages (net, os/user, runtime/cgo), cmd/link will use internal linking
mode. Otherwise, there are non-standard cgo packages involved, and cmd/link
will use external linking mode. The first rule means that a build of
the godoc binary, which uses net but no other cgo, can run without
needing gcc available. The second rule means that a build of a
cgo-wrapped library like sqlite3 can generate a standalone executable
instead of needing to refer to a dynamic library. The specific choice
can be overridden using a command line flag: cmd/link -linkmode=internal or
cmd/link -linkmode=external.

In an external link, cmd/link will create a temporary directory, write any
host object files found in package archives to that directory (renamed
to avoid conflicts), write the go.o file to that directory, and invoke
the host linker. The default value for the host linker is $CC, split
into fields, or else "gcc". The specific host linker command line can
be overridden using command line flags: cmd/link -extld=clang
-extldflags='-ggdb -O3'.  If any package in a build includes a .cc or
other file compiled by the C++ compiler, the go tool will use the
-extld option to set the host linker to the C++ compiler.

These defaults mean that Go-aware build systems can ignore the linking
changes and keep running plain 'cmd/link' and get reasonable results, but
they can also control the linking details if desired.

*/
                                                                                                                                                                                                                    usr/local/go/src/cmd/cgo/gcc.go                                                                     0100644 0000000 0000000 00000164142 13020111411 014732  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Annotate Ref in Prog with C types by parsing gcc debug output.
// Conversion of debug output to Go types.

package main

import (
	"bytes"
	"debug/dwarf"
	"debug/elf"
	"debug/macho"
	"debug/pe"
	"encoding/binary"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"
)

var debugDefine = flag.Bool("debug-define", false, "print relevant #defines")
var debugGcc = flag.Bool("debug-gcc", false, "print gcc invocations")

var nameToC = map[string]string{
	"schar":         "signed char",
	"uchar":         "unsigned char",
	"ushort":        "unsigned short",
	"uint":          "unsigned int",
	"ulong":         "unsigned long",
	"longlong":      "long long",
	"ulonglong":     "unsigned long long",
	"complexfloat":  "float _Complex",
	"complexdouble": "double _Complex",
}

// cname returns the C name to use for C.s.
// The expansions are listed in nameToC and also
// struct_foo becomes "struct foo", and similarly for
// union and enum.
func cname(s string) string {
	if t, ok := nameToC[s]; ok {
		return t
	}

	if strings.HasPrefix(s, "struct_") {
		return "struct " + s[len("struct_"):]
	}
	if strings.HasPrefix(s, "union_") {
		return "union " + s[len("union_"):]
	}
	if strings.HasPrefix(s, "enum_") {
		return "enum " + s[len("enum_"):]
	}
	if strings.HasPrefix(s, "sizeof_") {
		return "sizeof(" + cname(s[len("sizeof_"):]) + ")"
	}
	return s
}

// DiscardCgoDirectives processes the import C preamble, and discards
// all #cgo CFLAGS and LDFLAGS directives, so they don't make their
// way into _cgo_export.h.
func (f *File) DiscardCgoDirectives() {
	linesIn := strings.Split(f.Preamble, "\n")
	linesOut := make([]string, 0, len(linesIn))
	for _, line := range linesIn {
		l := strings.TrimSpace(line)
		if len(l) < 5 || l[:4] != "#cgo" || !unicode.IsSpace(rune(l[4])) {
			linesOut = append(linesOut, line)
		} else {
			linesOut = append(linesOut, "")
		}
	}
	f.Preamble = strings.Join(linesOut, "\n")
}

// addToFlag appends args to flag.  All flags are later written out onto the
// _cgo_flags file for the build system to use.
func (p *Package) addToFlag(flag string, args []string) {
	p.CgoFlags[flag] = append(p.CgoFlags[flag], args...)
	if flag == "CFLAGS" {
		// We'll also need these when preprocessing for dwarf information.
		p.GccOptions = append(p.GccOptions, args...)
	}
}

// splitQuoted splits the string s around each instance of one or more consecutive
// white space characters while taking into account quotes and escaping, and
// returns an array of substrings of s or an empty list if s contains only white space.
// Single quotes and double quotes are recognized to prevent splitting within the
// quoted region, and are removed from the resulting substrings. If a quote in s
// isn't closed err will be set and r will have the unclosed argument as the
// last element.  The backslash is used for escaping.
//
// For example, the following string:
//
//     `a b:"c d" 'e''f'  "g\""`
//
// Would be parsed as:
//
//     []string{"a", "b:c d", "ef", `g"`}
//
func splitQuoted(s string) (r []string, err error) {
	var args []string
	arg := make([]rune, len(s))
	escaped := false
	quoted := false
	quote := '\x00'
	i := 0
	for _, r := range s {
		switch {
		case escaped:
			escaped = false
		case r == '\\':
			escaped = true
			continue
		case quote != 0:
			if r == quote {
				quote = 0
				continue
			}
		case r == '"' || r == '\'':
			quoted = true
			quote = r
			continue
		case unicode.IsSpace(r):
			if quoted || i > 0 {
				quoted = false
				args = append(args, string(arg[:i]))
				i = 0
			}
			continue
		}
		arg[i] = r
		i++
	}
	if quoted || i > 0 {
		args = append(args, string(arg[:i]))
	}
	if quote != 0 {
		err = errors.New("unclosed quote")
	} else if escaped {
		err = errors.New("unfinished escaping")
	}
	return args, err
}

// Translate rewrites f.AST, the original Go input, to remove
// references to the imported package C, replacing them with
// references to the equivalent Go types, functions, and variables.
func (p *Package) Translate(f *File) {
	for _, cref := range f.Ref {
		// Convert C.ulong to C.unsigned long, etc.
		cref.Name.C = cname(cref.Name.Go)
	}
	p.loadDefines(f)
	needType := p.guessKinds(f)
	if len(needType) > 0 {
		p.loadDWARF(f, needType)
	}
	p.rewriteCalls(f)
	p.rewriteRef(f)
}

// loadDefines coerces gcc into spitting out the #defines in use
// in the file f and saves relevant renamings in f.Name[name].Define.
func (p *Package) loadDefines(f *File) {
	var b bytes.Buffer
	b.WriteString(f.Preamble)
	b.WriteString(builtinProlog)
	stdout := p.gccDefines(b.Bytes())

	for _, line := range strings.Split(stdout, "\n") {
		if len(line) < 9 || line[0:7] != "#define" {
			continue
		}

		line = strings.TrimSpace(line[8:])

		var key, val string
		spaceIndex := strings.Index(line, " ")
		tabIndex := strings.Index(line, "\t")

		if spaceIndex == -1 && tabIndex == -1 {
			continue
		} else if tabIndex == -1 || (spaceIndex != -1 && spaceIndex < tabIndex) {
			key = line[0:spaceIndex]
			val = strings.TrimSpace(line[spaceIndex:])
		} else {
			key = line[0:tabIndex]
			val = strings.TrimSpace(line[tabIndex:])
		}

		if key == "__clang__" {
			p.GccIsClang = true
		}

		if n := f.Name[key]; n != nil {
			if *debugDefine {
				fmt.Fprintf(os.Stderr, "#define %s %s\n", key, val)
			}
			n.Define = val
		}
	}
}

// guessKinds tricks gcc into revealing the kind of each
// name xxx for the references C.xxx in the Go input.
// The kind is either a constant, type, or variable.
func (p *Package) guessKinds(f *File) []*Name {
	// Determine kinds for names we already know about,
	// like #defines or 'struct foo', before bothering with gcc.
	var names, needType []*Name
	for _, key := range nameKeys(f.Name) {
		n := f.Name[key]
		// If we've already found this name as a #define
		// and we can translate it as a constant value, do so.
		if n.Define != "" {
			isConst := false
			if _, err := strconv.Atoi(n.Define); err == nil {
				isConst = true
			} else if n.Define[0] == '"' || n.Define[0] == '\'' {
				if _, err := parser.ParseExpr(n.Define); err == nil {
					isConst = true
				}
			}
			if isConst {
				n.Kind = "const"
				// Turn decimal into hex, just for consistency
				// with enum-derived constants.  Otherwise
				// in the cgo -godefs output half the constants
				// are in hex and half are in whatever the #define used.
				i, err := strconv.ParseInt(n.Define, 0, 64)
				if err == nil {
					n.Const = fmt.Sprintf("%#x", i)
				} else {
					n.Const = n.Define
				}
				continue
			}

			if isName(n.Define) {
				n.C = n.Define
			}
		}

		needType = append(needType, n)

		// If this is a struct, union, or enum type name, no need to guess the kind.
		if strings.HasPrefix(n.C, "struct ") || strings.HasPrefix(n.C, "union ") || strings.HasPrefix(n.C, "enum ") {
			n.Kind = "type"
			continue
		}

		// Otherwise, we'll need to find out from gcc.
		names = append(names, n)
	}

	// Bypass gcc if there's nothing left to find out.
	if len(names) == 0 {
		return needType
	}

	// Coerce gcc into telling us whether each name is a type, a value, or undeclared.
	// For names, find out whether they are integer constants.
	// We used to look at specific warning or error messages here, but that tied the
	// behavior too closely to specific versions of the compilers.
	// Instead, arrange that we can infer what we need from only the presence or absence
	// of an error on a specific line.
	//
	// For each name, we generate these lines, where xxx is the index in toSniff plus one.
	//
	//	#line xxx "not-declared"
	//	void __cgo_f_xxx_1(void) { __typeof__(name) *__cgo_undefined__; }
	//	#line xxx "not-type"
	//	void __cgo_f_xxx_2(void) { name *__cgo_undefined__; }
	//	#line xxx "not-const"
	//	void __cgo_f_xxx_3(void) { enum { __cgo_undefined__ = (name)*1 }; }
	//
	// If we see an error at not-declared:xxx, the corresponding name is not declared.
	// If we see an error at not-type:xxx, the corresponding name is a type.
	// If we see an error at not-const:xxx, the corresponding name is not an integer constant.
	// If we see no errors, we assume the name is an expression but not a constant
	// (so a variable or a function).
	//
	// The specific input forms are chosen so that they are valid C syntax regardless of
	// whether name denotes a type or an expression.

	var b bytes.Buffer
	b.WriteString(f.Preamble)
	b.WriteString(builtinProlog)

	for i, n := range names {
		fmt.Fprintf(&b, "#line %d \"not-declared\"\n"+
			"void __cgo_f_%d_1(void) { __typeof__(%s) *__cgo_undefined__; }\n"+
			"#line %d \"not-type\"\n"+
			"void __cgo_f_%d_2(void) { %s *__cgo_undefined__; }\n"+
			"#line %d \"not-const\"\n"+
			"void __cgo_f_%d_3(void) { enum { __cgo__undefined__ = (%s)*1 }; }\n",
			i+1, i+1, n.C,
			i+1, i+1, n.C,
			i+1, i+1, n.C)
	}
	fmt.Fprintf(&b, "#line 1 \"completed\"\n"+
		"int __cgo__1 = __cgo__2;\n")

	stderr := p.gccErrors(b.Bytes())
	if stderr == "" {
		fatalf("%s produced no output\non input:\n%s", p.gccBaseCmd()[0], b.Bytes())
	}

	completed := false
	sniff := make([]int, len(names))
	const (
		notType = 1 << iota
		notConst
		notDeclared
	)
	for _, line := range strings.Split(stderr, "\n") {
		if !strings.Contains(line, ": error:") {
			// we only care about errors.
			// we tried to turn off warnings on the command line, but one never knows.
			continue
		}

		c1 := strings.Index(line, ":")
		if c1 < 0 {
			continue
		}
		c2 := strings.Index(line[c1+1:], ":")
		if c2 < 0 {
			continue
		}
		c2 += c1 + 1

		filename := line[:c1]
		i, _ := strconv.Atoi(line[c1+1 : c2])
		i--
		if i < 0 || i >= len(names) {
			continue
		}

		switch filename {
		case "completed":
			// Strictly speaking, there is no guarantee that seeing the error at completed:1
			// (at the end of the file) means we've seen all the errors from earlier in the file,
			// but usually it does. Certainly if we don't see the completed:1 error, we did
			// not get all the errors we expected.
			completed = true

		case "not-declared":
			sniff[i] |= notDeclared
		case "not-type":
			sniff[i] |= notType
		case "not-const":
			sniff[i] |= notConst
		}
	}

	if !completed {
		fatalf("%s did not produce error at completed:1\non input:\n%s\nfull error output:\n%s", p.gccBaseCmd()[0], b.Bytes(), stderr)
	}

	for i, n := range names {
		switch sniff[i] {
		default:
			error_(token.NoPos, "could not determine kind of name for C.%s", fixGo(n.Go))
		case notType:
			n.Kind = "const"
		case notConst:
			n.Kind = "type"
		case notConst | notType:
			n.Kind = "not-type"
		}
	}
	if nerrors > 0 {
		// Check if compiling the preamble by itself causes any errors,
		// because the messages we've printed out so far aren't helpful
		// to users debugging preamble mistakes.  See issue 8442.
		preambleErrors := p.gccErrors([]byte(f.Preamble))
		if len(preambleErrors) > 0 {
			error_(token.NoPos, "\n%s errors for preamble:\n%s", p.gccBaseCmd()[0], preambleErrors)
		}

		fatalf("unresolved names")
	}

	needType = append(needType, names...)
	return needType
}

// loadDWARF parses the DWARF debug information generated
// by gcc to learn the details of the constants, variables, and types
// being referred to as C.xxx.
func (p *Package) loadDWARF(f *File, names []*Name) {
	// Extract the types from the DWARF section of an object
	// from a well-formed C program.  Gcc only generates DWARF info
	// for symbols in the object file, so it is not enough to print the
	// preamble and hope the symbols we care about will be there.
	// Instead, emit
	//	__typeof__(names[i]) *__cgo__i;
	// for each entry in names and then dereference the type we
	// learn for __cgo__i.
	var b bytes.Buffer
	b.WriteString(f.Preamble)
	b.WriteString(builtinProlog)
	for i, n := range names {
		fmt.Fprintf(&b, "__typeof__(%s) *__cgo__%d;\n", n.C, i)
		if n.Kind == "const" {
			fmt.Fprintf(&b, "enum { __cgo_enum__%d = %s };\n", i, n.C)
		}
	}

	// Apple's LLVM-based gcc does not include the enumeration
	// names and values in its DWARF debug output.  In case we're
	// using such a gcc, create a data block initialized with the values.
	// We can read them out of the object file.
	fmt.Fprintf(&b, "long long __cgodebug_data[] = {\n")
	for _, n := range names {
		if n.Kind == "const" {
			fmt.Fprintf(&b, "\t%s,\n", n.C)
		} else {
			fmt.Fprintf(&b, "\t0,\n")
		}
	}
	// for the last entry, we can not use 0, otherwise
	// in case all __cgodebug_data is zero initialized,
	// LLVM-based gcc will place the it in the __DATA.__common
	// zero-filled section (our debug/macho doesn't support
	// this)
	fmt.Fprintf(&b, "\t1\n")
	fmt.Fprintf(&b, "};\n")

	d, bo, debugData := p.gccDebug(b.Bytes())
	enumVal := make([]int64, len(debugData)/8)
	for i := range enumVal {
		enumVal[i] = int64(bo.Uint64(debugData[i*8:]))
	}

	// Scan DWARF info for top-level TagVariable entries with AttrName __cgo__i.
	types := make([]dwarf.Type, len(names))
	enums := make([]dwarf.Offset, len(names))
	nameToIndex := make(map[*Name]int)
	for i, n := range names {
		nameToIndex[n] = i
	}
	nameToRef := make(map[*Name]*Ref)
	for _, ref := range f.Ref {
		nameToRef[ref.Name] = ref
	}
	r := d.Reader()
	for {
		e, err := r.Next()
		if err != nil {
			fatalf("reading DWARF entry: %s", err)
		}
		if e == nil {
			break
		}
		switch e.Tag {
		case dwarf.TagEnumerationType:
			offset := e.Offset
			for {
				e, err := r.Next()
				if err != nil {
					fatalf("reading DWARF entry: %s", err)
				}
				if e.Tag == 0 {
					break
				}
				if e.Tag == dwarf.TagEnumerator {
					entryName := e.Val(dwarf.AttrName).(string)
					if strings.HasPrefix(entryName, "__cgo_enum__") {
						n, _ := strconv.Atoi(entryName[len("__cgo_enum__"):])
						if 0 <= n && n < len(names) {
							enums[n] = offset
						}
					}
				}
			}
		case dwarf.TagVariable:
			name, _ := e.Val(dwarf.AttrName).(string)
			typOff, _ := e.Val(dwarf.AttrType).(dwarf.Offset)
			if name == "" || typOff == 0 {
				if e.Val(dwarf.AttrSpecification) != nil {
					// Since we are reading all the DWARF,
					// assume we will see the variable elsewhere.
					break
				}
				fatalf("malformed DWARF TagVariable entry")
			}
			if !strings.HasPrefix(name, "__cgo__") {
				break
			}
			typ, err := d.Type(typOff)
			if err != nil {
				fatalf("loading DWARF type: %s", err)
			}
			t, ok := typ.(*dwarf.PtrType)
			if !ok || t == nil {
				fatalf("internal error: %s has non-pointer type", name)
			}
			i, err := strconv.Atoi(name[7:])
			if err != nil {
				fatalf("malformed __cgo__ name: %s", name)
			}
			if enums[i] != 0 {
				t, err := d.Type(enums[i])
				if err != nil {
					fatalf("loading DWARF type: %s", err)
				}
				types[i] = t
			} else {
				types[i] = t.Type
			}
		}
		if e.Tag != dwarf.TagCompileUnit {
			r.SkipChildren()
		}
	}

	// Record types and typedef information.
	var conv typeConv
	conv.Init(p.PtrSize, p.IntSize)
	for i, n := range names {
		if types[i] == nil {
			continue
		}
		pos := token.NoPos
		if ref, ok := nameToRef[n]; ok {
			pos = ref.Pos()
		}
		f, fok := types[i].(*dwarf.FuncType)
		if n.Kind != "type" && fok {
			n.Kind = "func"
			n.FuncType = conv.FuncType(f, pos)
		} else {
			n.Type = conv.Type(types[i], pos)
			if enums[i] != 0 && n.Type.EnumValues != nil {
				k := fmt.Sprintf("__cgo_enum__%d", i)
				n.Kind = "const"
				n.Const = fmt.Sprintf("%#x", n.Type.EnumValues[k])
				// Remove injected enum to ensure the value will deep-compare
				// equally in future loads of the same constant.
				delete(n.Type.EnumValues, k)
			}
			// Prefer debug data over DWARF debug output, if we have it.
			if n.Kind == "const" && i < len(enumVal) {
				n.Const = fmt.Sprintf("%#x", enumVal[i])
			}
		}
		conv.FinishType(pos)
	}
}

// mangleName does name mangling to translate names
// from the original Go source files to the names
// used in the final Go files generated by cgo.
func (p *Package) mangleName(n *Name) {
	// When using gccgo variables have to be
	// exported so that they become global symbols
	// that the C code can refer to.
	prefix := "_C"
	if *gccgo && n.IsVar() {
		prefix = "C"
	}
	n.Mangle = prefix + n.Kind + "_" + n.Go
}

// rewriteCalls rewrites all calls that pass pointers to check that
// they follow the rules for passing pointers between Go and C.
func (p *Package) rewriteCalls(f *File) {
	for _, call := range f.Calls {
		// This is a call to C.xxx; set goname to "xxx".
		goname := call.Fun.(*ast.SelectorExpr).Sel.Name
		if goname == "malloc" {
			continue
		}
		name := f.Name[goname]
		if name.Kind != "func" {
			// Probably a type conversion.
			continue
		}
		p.rewriteCall(f, call, name)
	}
}

// rewriteCall rewrites one call to add pointer checks.  We replace
// each pointer argument x with _cgoCheckPointer(x).(T).
func (p *Package) rewriteCall(f *File, call *ast.CallExpr, name *Name) {
	for i, param := range name.FuncType.Params {
		if len(call.Args) <= i {
			// Avoid a crash; this will be caught when the
			// generated file is compiled.
			return
		}

		// An untyped nil does not need a pointer check, and
		// when _cgoCheckPointer returns the untyped nil the
		// type assertion we are going to insert will fail.
		// Easier to just skip nil arguments.
		// TODO: Note that this fails if nil is shadowed.
		if id, ok := call.Args[i].(*ast.Ident); ok && id.Name == "nil" {
			continue
		}

		if !p.needsPointerCheck(f, param.Go) {
			continue
		}

		c := &ast.CallExpr{
			Fun: ast.NewIdent("_cgoCheckPointer"),
			Args: []ast.Expr{
				call.Args[i],
			},
		}

		// Add optional additional arguments for an address
		// expression.
		c.Args = p.checkAddrArgs(f, c.Args, call.Args[i])

		// _cgoCheckPointer returns interface{}.
		// We need to type assert that to the type we want.
		// If the Go version of this C type uses
		// unsafe.Pointer, we can't use a type assertion,
		// because the Go file might not import unsafe.
		// Instead we use a local variant of _cgoCheckPointer.

		var arg ast.Expr
		if n := p.unsafeCheckPointerName(param.Go); n != "" {
			c.Fun = ast.NewIdent(n)
			arg = c
		} else {
			// In order for the type assertion to succeed,
			// we need it to match the actual type of the
			// argument.  The only type we have is the
			// type of the function parameter.  We know
			// that the argument type must be assignable
			// to the function parameter type, or the code
			// would not compile, but there is nothing
			// requiring that the types be exactly the
			// same.  Add a type conversion to the
			// argument so that the type assertion will
			// succeed.
			c.Args[0] = &ast.CallExpr{
				Fun: param.Go,
				Args: []ast.Expr{
					c.Args[0],
				},
			}

			arg = &ast.TypeAssertExpr{
				X:    c,
				Type: param.Go,
			}
		}

		call.Args[i] = arg
	}
}

// needsPointerCheck returns whether the type t needs a pointer check.
// This is true if t is a pointer and if the value to which it points
// might contain a pointer.
func (p *Package) needsPointerCheck(f *File, t ast.Expr) bool {
	return p.hasPointer(f, t, true)
}

// hasPointer is used by needsPointerCheck.  If top is true it returns
// whether t is or contains a pointer that might point to a pointer.
// If top is false it returns whether t is or contains a pointer.
// f may be nil.
func (p *Package) hasPointer(f *File, t ast.Expr, top bool) bool {
	switch t := t.(type) {
	case *ast.ArrayType:
		if t.Len == nil {
			if !top {
				return true
			}
			return p.hasPointer(f, t.Elt, false)
		}
		return p.hasPointer(f, t.Elt, top)
	case *ast.StructType:
		for _, field := range t.Fields.List {
			if p.hasPointer(f, field.Type, top) {
				return true
			}
		}
		return false
	case *ast.StarExpr: // Pointer type.
		if !top {
			return true
		}
		return p.hasPointer(f, t.X, false)
	case *ast.FuncType, *ast.InterfaceType, *ast.MapType, *ast.ChanType:
		return true
	case *ast.Ident:
		// TODO: Handle types defined within function.
		for _, d := range p.Decl {
			gd, ok := d.(*ast.GenDecl)
			if !ok || gd.Tok != token.TYPE {
				continue
			}
			for _, spec := range gd.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				if ts.Name.Name == t.Name {
					return p.hasPointer(f, ts.Type, top)
				}
			}
		}
		if def := typedef[t.Name]; def != nil {
			return p.hasPointer(f, def.Go, top)
		}
		if t.Name == "string" {
			return !top
		}
		if t.Name == "error" {
			return true
		}
		if goTypes[t.Name] != nil {
			return false
		}
		// We can't figure out the type.  Conservative
		// approach is to assume it has a pointer.
		return true
	case *ast.SelectorExpr:
		if l, ok := t.X.(*ast.Ident); !ok || l.Name != "C" {
			// Type defined in a different package.
			// Conservative approach is to assume it has a
			// pointer.
			return true
		}
		if f == nil {
			// Conservative approach: assume pointer.
			return true
		}
		name := f.Name[t.Sel.Name]
		if name != nil && name.Kind == "type" && name.Type != nil && name.Type.Go != nil {
			return p.hasPointer(f, name.Type.Go, top)
		}
		// We can't figure out the type.  Conservative
		// approach is to assume it has a pointer.
		return true
	default:
		error_(t.Pos(), "could not understand type %s", gofmt(t))
		return true
	}
}

// checkAddrArgs tries to add arguments to the call of
// _cgoCheckPointer when the argument is an address expression.  We
// pass true to mean that the argument is an address operation of
// something other than a slice index, which means that it's only
// necessary to check the specific element pointed to, not the entire
// object.  This is for &s.f, where f is a field in a struct.  We can
// pass a slice or array, meaning that we should check the entire
// slice or array but need not check any other part of the object.
// This is for &s.a[i], where we need to check all of a.  However, we
// only pass the slice or array if we can refer to it without side
// effects.
func (p *Package) checkAddrArgs(f *File, args []ast.Expr, x ast.Expr) []ast.Expr {
	// Strip type conversions.
	for {
		c, ok := x.(*ast.CallExpr)
		if !ok || len(c.Args) != 1 || !p.isType(c.Fun) {
			break
		}
		x = c.Args[0]
	}
	u, ok := x.(*ast.UnaryExpr)
	if !ok || u.Op != token.AND {
		return args
	}
	index, ok := u.X.(*ast.IndexExpr)
	if !ok {
		// This is the address of something that is not an
		// index expression.  We only need to examine the
		// single value to which it points.
		// TODO: what if true is shadowed?
		return append(args, ast.NewIdent("true"))
	}
	if !p.hasSideEffects(f, index.X) {
		// Examine the entire slice.
		return append(args, index.X)
	}
	// Treat the pointer as unknown.
	return args
}

// hasSideEffects returns whether the expression x has any side
// effects.  x is an expression, not a statement, so the only side
// effect is a function call.
func (p *Package) hasSideEffects(f *File, x ast.Expr) bool {
	found := false
	f.walk(x, "expr",
		func(f *File, x interface{}, context string) {
			switch x.(type) {
			case *ast.CallExpr:
				found = true
			}
		})
	return found
}

// isType returns whether the expression is definitely a type.
// This is conservative--it returns false for an unknown identifier.
func (p *Package) isType(t ast.Expr) bool {
	switch t := t.(type) {
	case *ast.SelectorExpr:
		id, ok := t.X.(*ast.Ident)
		if !ok {
			return false
		}
		if id.Name == "unsafe" && t.Sel.Name == "Pointer" {
			return true
		}
		if id.Name == "C" && typedef["_Ctype_"+t.Sel.Name] != nil {
			return true
		}
		return false
	case *ast.Ident:
		// TODO: This ignores shadowing.
		switch t.Name {
		case "unsafe.Pointer", "bool", "byte",
			"complex64", "complex128",
			"error",
			"float32", "float64",
			"int", "int8", "int16", "int32", "int64",
			"rune", "string",
			"uint", "uint8", "uint16", "uint32", "uint64", "uintptr":

			return true
		}
	case *ast.StarExpr:
		return p.isType(t.X)
	case *ast.ArrayType, *ast.StructType, *ast.FuncType, *ast.InterfaceType,
		*ast.MapType, *ast.ChanType:

		return true
	}
	return false
}

// unsafeCheckPointerName is given the Go version of a C type.  If the
// type uses unsafe.Pointer, we arrange to build a version of
// _cgoCheckPointer that returns that type.  This avoids using a type
// assertion to unsafe.Pointer in our copy of user code.  We return
// the name of the _cgoCheckPointer function we are going to build, or
// the empty string if the type does not use unsafe.Pointer.
func (p *Package) unsafeCheckPointerName(t ast.Expr) string {
	if !p.hasUnsafePointer(t) {
		return ""
	}
	var buf bytes.Buffer
	conf.Fprint(&buf, fset, t)
	s := buf.String()
	for i, t := range p.CgoChecks {
		if s == t {
			return p.unsafeCheckPointerNameIndex(i)
		}
	}
	p.CgoChecks = append(p.CgoChecks, s)
	return p.unsafeCheckPointerNameIndex(len(p.CgoChecks) - 1)
}

// hasUnsafePointer returns whether the Go type t uses unsafe.Pointer.
// t is the Go version of a C type, so we don't need to handle every case.
// We only care about direct references, not references via typedefs.
func (p *Package) hasUnsafePointer(t ast.Expr) bool {
	switch t := t.(type) {
	case *ast.Ident:
		// We don't see a SelectorExpr for unsafe.Pointer;
		// this is created by code in this file.
		return t.Name == "unsafe.Pointer"
	case *ast.ArrayType:
		return p.hasUnsafePointer(t.Elt)
	case *ast.StructType:
		for _, f := range t.Fields.List {
			if p.hasUnsafePointer(f.Type) {
				return true
			}
		}
	case *ast.StarExpr: // Pointer type.
		return p.hasUnsafePointer(t.X)
	}
	return false
}

// unsafeCheckPointerNameIndex returns the name to use for a
// _cgoCheckPointer variant based on the index in the CgoChecks slice.
func (p *Package) unsafeCheckPointerNameIndex(i int) string {
	return fmt.Sprintf("_cgoCheckPointer%d", i)
}

// rewriteRef rewrites all the C.xxx references in f.AST to refer to the
// Go equivalents, now that we have figured out the meaning of all
// the xxx.  In *godefs mode, rewriteRef replaces the names
// with full definitions instead of mangled names.
func (p *Package) rewriteRef(f *File) {
	// Keep a list of all the functions, to remove the ones
	// only used as expressions and avoid generating bridge
	// code for them.
	functions := make(map[string]bool)

	// Assign mangled names.
	for _, n := range f.Name {
		if n.Kind == "not-type" {
			n.Kind = "var"
		}
		if n.Mangle == "" {
			p.mangleName(n)
		}
		if n.Kind == "func" {
			functions[n.Go] = false
		}
	}

	// Now that we have all the name types filled in,
	// scan through the Refs to identify the ones that
	// are trying to do a ,err call.  Also check that
	// functions are only used in calls.
	for _, r := range f.Ref {
		if r.Name.Kind == "const" && r.Name.Const == "" {
			error_(r.Pos(), "unable to find value of constant C.%s", fixGo(r.Name.Go))
		}
		var expr ast.Expr = ast.NewIdent(r.Name.Mangle) // default
		switch r.Context {
		case "call", "call2":
			if r.Name.Kind != "func" {
				if r.Name.Kind == "type" {
					r.Context = "type"
					if r.Name.Type == nil {
						error_(r.Pos(), "invalid conversion to C.%s: undefined C type '%s'", fixGo(r.Name.Go), r.Name.C)
						break
					}
					expr = r.Name.Type.Go
					break
				}
				error_(r.Pos(), "call of non-function C.%s", fixGo(r.Name.Go))
				break
			}
			functions[r.Name.Go] = true
			if r.Context == "call2" {
				if r.Name.Go == "_CMalloc" {
					error_(r.Pos(), "no two-result form for C.malloc")
					break
				}
				// Invent new Name for the two-result function.
				n := f.Name["2"+r.Name.Go]
				if n == nil {
					n = new(Name)
					*n = *r.Name
					n.AddError = true
					n.Mangle = "_C2func_" + n.Go
					f.Name["2"+r.Name.Go] = n
				}
				expr = ast.NewIdent(n.Mangle)
				r.Name = n
				break
			}
		case "expr":
			if r.Name.Kind == "func" {
				// Function is being used in an expression, to e.g. pass around a C function pointer.
				// Create a new Name for this Ref which causes the variable to be declared in Go land.
				fpName := "fp_" + r.Name.Go
				name := f.Name[fpName]
				if name == nil {
					name = &Name{
						Go:   fpName,
						C:    r.Name.C,
						Kind: "fpvar",
						Type: &Type{Size: p.PtrSize, Align: p.PtrSize, C: c("void*"), Go: ast.NewIdent("unsafe.Pointer")},
					}
					p.mangleName(name)
					f.Name[fpName] = name
				}
				r.Name = name
				// Rewrite into call to _Cgo_ptr to prevent assignments.  The _Cgo_ptr
				// function is defined in out.go and simply returns its argument. See
				// issue 7757.
				expr = &ast.CallExpr{
					Fun:  &ast.Ident{NamePos: (*r.Expr).Pos(), Name: "_Cgo_ptr"},
					Args: []ast.Expr{ast.NewIdent(name.Mangle)},
				}
			} else if r.Name.Kind == "type" {
				// Okay - might be new(T)
				if r.Name.Type == nil {
					error_(r.Pos(), "expression C.%s: undefined C type '%s'", fixGo(r.Name.Go), r.Name.C)
					break
				}
				expr = r.Name.Type.Go
			} else if r.Name.Kind == "var" {
				expr = &ast.StarExpr{Star: (*r.Expr).Pos(), X: expr}
			}

		case "selector":
			if r.Name.Kind == "var" {
				expr = &ast.StarExpr{Star: (*r.Expr).Pos(), X: expr}
			} else {
				error_(r.Pos(), "only C variables allowed in selector expression", fixGo(r.Name.Go))
			}

		case "type":
			if r.Name.Kind != "type" {
				error_(r.Pos(), "expression C.%s used as type", fixGo(r.Name.Go))
			} else if r.Name.Type == nil {
				// Use of C.enum_x, C.struct_x or C.union_x without C definition.
				// GCC won't raise an error when using pointers to such unknown types.
				error_(r.Pos(), "type C.%s: undefined C type '%s'", fixGo(r.Name.Go), r.Name.C)
			} else {
				expr = r.Name.Type.Go
			}
		default:
			if r.Name.Kind == "func" {
				error_(r.Pos(), "must call C.%s", fixGo(r.Name.Go))
			}
		}
		if *godefs {
			// Substitute definition for mangled type name.
			if id, ok := expr.(*ast.Ident); ok {
				if t := typedef[id.Name]; t != nil {
					expr = t.Go
				}
				if id.Name == r.Name.Mangle && r.Name.Const != "" {
					expr = ast.NewIdent(r.Name.Const)
				}
			}
		}

		// Copy position information from old expr into new expr,
		// in case expression being replaced is first on line.
		// See golang.org/issue/6563.
		pos := (*r.Expr).Pos()
		switch x := expr.(type) {
		case *ast.Ident:
			expr = &ast.Ident{NamePos: pos, Name: x.Name}
		}

		*r.Expr = expr
	}

	// Remove functions only used as expressions, so their respective
	// bridge functions are not generated.
	for name, used := range functions {
		if !used {
			delete(f.Name, name)
		}
	}
}

// gccBaseCmd returns the start of the compiler command line.
// It uses $CC if set, or else $GCC, or else the compiler recorded
// during the initial build as defaultCC.
// defaultCC is defined in zdefaultcc.go, written by cmd/dist.
func (p *Package) gccBaseCmd() []string {
	// Use $CC if set, since that's what the build uses.
	if ret := strings.Fields(os.Getenv("CC")); len(ret) > 0 {
		return ret
	}
	// Try $GCC if set, since that's what we used to use.
	if ret := strings.Fields(os.Getenv("GCC")); len(ret) > 0 {
		return ret
	}
	return strings.Fields(defaultCC)
}

// gccMachine returns the gcc -m flag to use, either "-m32", "-m64" or "-marm".
func (p *Package) gccMachine() []string {
	switch goarch {
	case "amd64":
		return []string{"-m64"}
	case "386":
		return []string{"-m32"}
	case "arm":
		return []string{"-marm"} // not thumb
	case "s390":
		return []string{"-m31"}
	case "s390x":
		return []string{"-m64"}
	}
	return nil
}

func gccTmp() string {
	return *objDir + "_cgo_.o"
}

// gccCmd returns the gcc command line to use for compiling
// the input.
func (p *Package) gccCmd() []string {
	c := append(p.gccBaseCmd(),
		"-w",          // no warnings
		"-Wno-error",  // warnings are not errors
		"-o"+gccTmp(), // write object to tmp
		"-gdwarf-2",   // generate DWARF v2 debugging symbols
		"-c",          // do not link
		"-xc",         // input language is C
	)
	if p.GccIsClang {
		c = append(c,
			"-ferror-limit=0",
			// Apple clang version 1.7 (tags/Apple/clang-77) (based on LLVM 2.9svn)
			// doesn't have -Wno-unneeded-internal-declaration, so we need yet another
			// flag to disable the warning. Yes, really good diagnostics, clang.
			"-Wno-unknown-warning-option",
			"-Wno-unneeded-internal-declaration",
			"-Wno-unused-function",
			"-Qunused-arguments",
			// Clang embeds prototypes for some builtin functions,
			// like malloc and calloc, but all size_t parameters are
			// incorrectly typed unsigned long. We work around that
			// by disabling the builtin functions (this is safe as
			// it won't affect the actual compilation of the C code).
			// See: https://golang.org/issue/6506.
			"-fno-builtin",
		)
	}

	c = append(c, p.GccOptions...)
	c = append(c, p.gccMachine()...)
	c = append(c, "-") //read input from standard input
	return c
}

// gccDebug runs gcc -gdwarf-2 over the C program stdin and
// returns the corresponding DWARF data and, if present, debug data block.
func (p *Package) gccDebug(stdin []byte) (*dwarf.Data, binary.ByteOrder, []byte) {
	runGcc(stdin, p.gccCmd())

	isDebugData := func(s string) bool {
		// Some systems use leading _ to denote non-assembly symbols.
		return s == "__cgodebug_data" || s == "___cgodebug_data"
	}

	if f, err := macho.Open(gccTmp()); err == nil {
		defer f.Close()
		d, err := f.DWARF()
		if err != nil {
			fatalf("cannot load DWARF output from %s: %v", gccTmp(), err)
		}
		var data []byte
		if f.Symtab != nil {
			for i := range f.Symtab.Syms {
				s := &f.Symtab.Syms[i]
				if isDebugData(s.Name) {
					// Found it.  Now find data section.
					if i := int(s.Sect) - 1; 0 <= i && i < len(f.Sections) {
						sect := f.Sections[i]
						if sect.Addr <= s.Value && s.Value < sect.Addr+sect.Size {
							if sdat, err := sect.Data(); err == nil {
								data = sdat[s.Value-sect.Addr:]
							}
						}
					}
				}
			}
		}
		return d, f.ByteOrder, data
	}

	if f, err := elf.Open(gccTmp()); err == nil {
		defer f.Close()
		d, err := f.DWARF()
		if err != nil {
			fatalf("cannot load DWARF output from %s: %v", gccTmp(), err)
		}
		var data []byte
		symtab, err := f.Symbols()
		if err == nil {
			for i := range symtab {
				s := &symtab[i]
				if isDebugData(s.Name) {
					// Found it.  Now find data section.
					if i := int(s.Section); 0 <= i && i < len(f.Sections) {
						sect := f.Sections[i]
						if sect.Addr <= s.Value && s.Value < sect.Addr+sect.Size {
							if sdat, err := sect.Data(); err == nil {
								data = sdat[s.Value-sect.Addr:]
							}
						}
					}
				}
			}
		}
		return d, f.ByteOrder, data
	}

	if f, err := pe.Open(gccTmp()); err == nil {
		defer f.Close()
		d, err := f.DWARF()
		if err != nil {
			fatalf("cannot load DWARF output from %s: %v", gccTmp(), err)
		}
		var data []byte
		for _, s := range f.Symbols {
			if isDebugData(s.Name) {
				if i := int(s.SectionNumber) - 1; 0 <= i && i < len(f.Sections) {
					sect := f.Sections[i]
					if s.Value < sect.Size {
						if sdat, err := sect.Data(); err == nil {
							data = sdat[s.Value:]
						}
					}
				}
			}
		}
		return d, binary.LittleEndian, data
	}

	fatalf("cannot parse gcc output %s as ELF, Mach-O, PE object", gccTmp())
	panic("not reached")
}

// gccDefines runs gcc -E -dM -xc - over the C program stdin
// and returns the corresponding standard output, which is the
// #defines that gcc encountered while processing the input
// and its included files.
func (p *Package) gccDefines(stdin []byte) string {
	base := append(p.gccBaseCmd(), "-E", "-dM", "-xc")
	base = append(base, p.gccMachine()...)
	stdout, _ := runGcc(stdin, append(append(base, p.GccOptions...), "-"))
	return stdout
}

// gccErrors runs gcc over the C program stdin and returns
// the errors that gcc prints.  That is, this function expects
// gcc to fail.
func (p *Package) gccErrors(stdin []byte) string {
	// TODO(rsc): require failure
	args := p.gccCmd()

	if *debugGcc {
		fmt.Fprintf(os.Stderr, "$ %s <<EOF\n", strings.Join(args, " "))
		os.Stderr.Write(stdin)
		fmt.Fprint(os.Stderr, "EOF\n")
	}
	stdout, stderr, _ := run(stdin, args)
	if *debugGcc {
		os.Stderr.Write(stdout)
		os.Stderr.Write(stderr)
	}
	return string(stderr)
}

// runGcc runs the gcc command line args with stdin on standard input.
// If the command exits with a non-zero exit status, runGcc prints
// details about what was run and exits.
// Otherwise runGcc returns the data written to standard output and standard error.
// Note that for some of the uses we expect useful data back
// on standard error, but for those uses gcc must still exit 0.
func runGcc(stdin []byte, args []string) (string, string) {
	if *debugGcc {
		fmt.Fprintf(os.Stderr, "$ %s <<EOF\n", strings.Join(args, " "))
		os.Stderr.Write(stdin)
		fmt.Fprint(os.Stderr, "EOF\n")
	}
	stdout, stderr, ok := run(stdin, args)
	if *debugGcc {
		os.Stderr.Write(stdout)
		os.Stderr.Write(stderr)
	}
	if !ok {
		os.Stderr.Write(stderr)
		os.Exit(2)
	}
	return string(stdout), string(stderr)
}

// A typeConv is a translator from dwarf types to Go types
// with equivalent memory layout.
type typeConv struct {
	// Cache of already-translated or in-progress types.
	m       map[dwarf.Type]*Type
	typedef map[string]ast.Expr

	// Map from types to incomplete pointers to those types.
	ptrs map[dwarf.Type][]*Type
	// Keys of ptrs in insertion order (deterministic worklist)
	ptrKeys []dwarf.Type

	// Predeclared types.
	bool                                   ast.Expr
	byte                                   ast.Expr // denotes padding
	int8, int16, int32, int64              ast.Expr
	uint8, uint16, uint32, uint64, uintptr ast.Expr
	float32, float64                       ast.Expr
	complex64, complex128                  ast.Expr
	void                                   ast.Expr
	string                                 ast.Expr
	goVoid                                 ast.Expr // _Ctype_void, denotes C's void
	goVoidPtr                              ast.Expr // unsafe.Pointer or *byte

	ptrSize int64
	intSize int64
}

var tagGen int
var typedef = make(map[string]*Type)
var goIdent = make(map[string]*ast.Ident)

func (c *typeConv) Init(ptrSize, intSize int64) {
	c.ptrSize = ptrSize
	c.intSize = intSize
	c.m = make(map[dwarf.Type]*Type)
	c.ptrs = make(map[dwarf.Type][]*Type)
	c.bool = c.Ident("bool")
	c.byte = c.Ident("byte")
	c.int8 = c.Ident("int8")
	c.int16 = c.Ident("int16")
	c.int32 = c.Ident("int32")
	c.int64 = c.Ident("int64")
	c.uint8 = c.Ident("uint8")
	c.uint16 = c.Ident("uint16")
	c.uint32 = c.Ident("uint32")
	c.uint64 = c.Ident("uint64")
	c.uintptr = c.Ident("uintptr")
	c.float32 = c.Ident("float32")
	c.float64 = c.Ident("float64")
	c.complex64 = c.Ident("complex64")
	c.complex128 = c.Ident("complex128")
	c.void = c.Ident("void")
	c.string = c.Ident("string")
	c.goVoid = c.Ident("_Ctype_void")

	// Normally cgo translates void* to unsafe.Pointer,
	// but for historical reasons -godefs uses *byte instead.
	if *godefs {
		c.goVoidPtr = &ast.StarExpr{X: c.byte}
	} else {
		c.goVoidPtr = c.Ident("unsafe.Pointer")
	}
}

// base strips away qualifiers and typedefs to get the underlying type
func base(dt dwarf.Type) dwarf.Type {
	for {
		if d, ok := dt.(*dwarf.QualType); ok {
			dt = d.Type
			continue
		}
		if d, ok := dt.(*dwarf.TypedefType); ok {
			dt = d.Type
			continue
		}
		break
	}
	return dt
}

// Map from dwarf text names to aliases we use in package "C".
var dwarfToName = map[string]string{
	"long int":               "long",
	"long unsigned int":      "ulong",
	"unsigned int":           "uint",
	"short unsigned int":     "ushort",
	"unsigned short":         "ushort", // Used by Clang; issue 13129.
	"short int":              "short",
	"long long int":          "longlong",
	"long long unsigned int": "ulonglong",
	"signed char":            "schar",
	"unsigned char":          "uchar",
}

const signedDelta = 64

// String returns the current type representation.  Format arguments
// are assembled within this method so that any changes in mutable
// values are taken into account.
func (tr *TypeRepr) String() string {
	if len(tr.Repr) == 0 {
		return ""
	}
	if len(tr.FormatArgs) == 0 {
		return tr.Repr
	}
	return fmt.Sprintf(tr.Repr, tr.FormatArgs...)
}

// Empty reports whether the result of String would be "".
func (tr *TypeRepr) Empty() bool {
	return len(tr.Repr) == 0
}

// Set modifies the type representation.
// If fargs are provided, repr is used as a format for fmt.Sprintf.
// Otherwise, repr is used unprocessed as the type representation.
func (tr *TypeRepr) Set(repr string, fargs ...interface{}) {
	tr.Repr = repr
	tr.FormatArgs = fargs
}

// FinishType completes any outstanding type mapping work.
// In particular, it resolves incomplete pointer types.
func (c *typeConv) FinishType(pos token.Pos) {
	// Completing one pointer type might produce more to complete.
	// Keep looping until they're all done.
	for len(c.ptrKeys) > 0 {
		dtype := c.ptrKeys[0]
		c.ptrKeys = c.ptrKeys[1:]

		// Note Type might invalidate c.ptrs[dtype].
		t := c.Type(dtype, pos)
		for _, ptr := range c.ptrs[dtype] {
			ptr.Go.(*ast.StarExpr).X = t.Go
			ptr.C.Set("%s*", t.C)
		}
		c.ptrs[dtype] = nil // retain the map key
	}
}

// Type returns a *Type with the same memory layout as
// dtype when used as the type of a variable or a struct field.
func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {
	if t, ok := c.m[dtype]; ok {
		if t.Go == nil {
			fatalf("%s: type conversion loop at %s", lineno(pos), dtype)
		}
		return t
	}

	t := new(Type)
	t.Size = dtype.Size() // note: wrong for array of pointers, corrected below
	t.Align = -1
	t.C = &TypeRepr{Repr: dtype.Common().Name}
	c.m[dtype] = t

	switch dt := dtype.(type) {
	default:
		fatalf("%s: unexpected type: %s", lineno(pos), dtype)

	case *dwarf.AddrType:
		if t.Size != c.ptrSize {
			fatalf("%s: unexpected: %d-byte address type - %s", lineno(pos), t.Size, dtype)
		}
		t.Go = c.uintptr
		t.Align = t.Size

	case *dwarf.ArrayType:
		if dt.StrideBitSize > 0 {
			// Cannot represent bit-sized elements in Go.
			t.Go = c.Opaque(t.Size)
			break
		}
		count := dt.Count
		if count == -1 {
			// Indicates flexible array member, which Go doesn't support.
			// Translate to zero-length array instead.
			count = 0
		}
		sub := c.Type(dt.Type, pos)
		t.Align = sub.Align
		t.Go = &ast.ArrayType{
			Len: c.intExpr(count),
			Elt: sub.Go,
		}
		// Recalculate t.Size now that we know sub.Size.
		t.Size = count * sub.Size
		t.C.Set("__typeof__(%s[%d])", sub.C, dt.Count)

	case *dwarf.BoolType:
		t.Go = c.bool
		t.Align = 1

	case *dwarf.CharType:
		if t.Size != 1 {
			fatalf("%s: unexpected: %d-byte char type - %s", lineno(pos), t.Size, dtype)
		}
		t.Go = c.int8
		t.Align = 1

	case *dwarf.EnumType:
		if t.Align = t.Size; t.Align >= c.ptrSize {
			t.Align = c.ptrSize
		}
		t.C.Set("enum " + dt.EnumName)
		signed := 0
		t.EnumValues = make(map[string]int64)
		for _, ev := range dt.Val {
			t.EnumValues[ev.Name] = ev.Val
			if ev.Val < 0 {
				signed = signedDelta
			}
		}
		switch t.Size + int64(signed) {
		default:
			fatalf("%s: unexpected: %d-byte enum type - %s", lineno(pos), t.Size, dtype)
		case 1:
			t.Go = c.uint8
		case 2:
			t.Go = c.uint16
		case 4:
			t.Go = c.uint32
		case 8:
			t.Go = c.uint64
		case 1 + signedDelta:
			t.Go = c.int8
		case 2 + signedDelta:
			t.Go = c.int16
		case 4 + signedDelta:
			t.Go = c.int32
		case 8 + signedDelta:
			t.Go = c.int64
		}

	case *dwarf.FloatType:
		switch t.Size {
		default:
			fatalf("%s: unexpected: %d-byte float type - %s", lineno(pos), t.Size, dtype)
		case 4:
			t.Go = c.float32
		case 8:
			t.Go = c.float64
		}
		if t.Align = t.Size; t.Align >= c.ptrSize {
			t.Align = c.ptrSize
		}

	case *dwarf.ComplexType:
		switch t.Size {
		default:
			fatalf("%s: unexpected: %d-byte complex type - %s", lineno(pos), t.Size, dtype)
		case 8:
			t.Go = c.complex64
		case 16:
			t.Go = c.complex128
		}
		if t.Align = t.Size; t.Align >= c.ptrSize {
			t.Align = c.ptrSize
		}

	case *dwarf.FuncType:
		// No attempt at translation: would enable calls
		// directly between worlds, but we need to moderate those.
		t.Go = c.uintptr
		t.Align = c.ptrSize

	case *dwarf.IntType:
		if dt.BitSize > 0 {
			fatalf("%s: unexpected: %d-bit int type - %s", lineno(pos), dt.BitSize, dtype)
		}
		switch t.Size {
		default:
			fatalf("%s: unexpected: %d-byte int type - %s", lineno(pos), t.Size, dtype)
		case 1:
			t.Go = c.int8
		case 2:
			t.Go = c.int16
		case 4:
			t.Go = c.int32
		case 8:
			t.Go = c.int64
		case 16:
			t.Go = &ast.ArrayType{
				Len: c.intExpr(t.Size),
				Elt: c.uint8,
			}
		}
		if t.Align = t.Size; t.Align >= c.ptrSize {
			t.Align = c.ptrSize
		}

	case *dwarf.PtrType:
		// Clang doesn't emit DW_AT_byte_size for pointer types.
		if t.Size != c.ptrSize && t.Size != -1 {
			fatalf("%s: unexpected: %d-byte pointer type - %s", lineno(pos), t.Size, dtype)
		}
		t.Size = c.ptrSize
		t.Align = c.ptrSize

		if _, ok := base(dt.Type).(*dwarf.VoidType); ok {
			t.Go = c.goVoidPtr
			t.C.Set("void*")
			break
		}

		// Placeholder initialization; completed in FinishType.
		t.Go = &ast.StarExpr{}
		t.C.Set("<incomplete>*")
		if _, ok := c.ptrs[dt.Type]; !ok {
			c.ptrKeys = append(c.ptrKeys, dt.Type)
		}
		c.ptrs[dt.Type] = append(c.ptrs[dt.Type], t)

	case *dwarf.QualType:
		// Ignore qualifier.
		t = c.Type(dt.Type, pos)
		c.m[dtype] = t
		return t

	case *dwarf.StructType:
		// Convert to Go struct, being careful about alignment.
		// Have to give it a name to simulate C "struct foo" references.
		tag := dt.StructName
		if dt.ByteSize < 0 && tag == "" { // opaque unnamed struct - should not be possible
			break
		}
		if tag == "" {
			tag = "__" + strconv.Itoa(tagGen)
			tagGen++
		} else if t.C.Empty() {
			t.C.Set(dt.Kind + " " + tag)
		}
		name := c.Ident("_Ctype_" + dt.Kind + "_" + tag)
		t.Go = name // publish before recursive calls
		goIdent[name.Name] = name
		if dt.ByteSize < 0 {
			// Size calculation in c.Struct/c.Opaque will die with size=-1 (unknown),
			// so execute the basic things that the struct case would do
			// other than try to determine a Go representation.
			tt := *t
			tt.C = &TypeRepr{"%s %s", []interface{}{dt.Kind, tag}}
			tt.Go = c.Ident("struct{}")
			typedef[name.Name] = &tt
			break
		}
		switch dt.Kind {
		case "class", "union":
			t.Go = c.Opaque(t.Size)
			if t.C.Empty() {
				t.C.Set("__typeof__(unsigned char[%d])", t.Size)
			}
			t.Align = 1 // TODO: should probably base this on field alignment.
			typedef[name.Name] = t
		case "struct":
			g, csyntax, align := c.Struct(dt, pos)
			if t.C.Empty() {
				t.C.Set(csyntax)
			}
			t.Align = align
			tt := *t
			if tag != "" {
				tt.C = &TypeRepr{"struct %s", []interface{}{tag}}
			}
			tt.Go = g
			typedef[name.Name] = &tt
		}

	case *dwarf.TypedefType:
		// Record typedef for printing.
		if dt.Name == "_GoString_" {
			// Special C name for Go string type.
			// Knows string layout used by compilers: pointer plus length,
			// which rounds up to 2 pointers after alignment.
			t.Go = c.string
			t.Size = c.ptrSize * 2
			t.Align = c.ptrSize
			break
		}
		if dt.Name == "_GoBytes_" {
			// Special C name for Go []byte type.
			// Knows slice layout used by compilers: pointer, length, cap.
			t.Go = c.Ident("[]byte")
			t.Size = c.ptrSize + 4 + 4
			t.Align = c.ptrSize
			break
		}
		name := c.Ident("_Ctype_" + dt.Name)
		goIdent[name.Name] = name
		sub := c.Type(dt.Type, pos)
		t.Go = name
		t.Size = sub.Size
		t.Align = sub.Align
		oldType := typedef[name.Name]
		if oldType == nil {
			tt := *t
			tt.Go = sub.Go
			typedef[name.Name] = &tt
		}

		// If sub.Go.Name is "_Ctype_struct_foo" or "_Ctype_union_foo" or "_Ctype_class_foo",
		// use that as the Go form for this typedef too, so that the typedef will be interchangeable
		// with the base type.
		// In -godefs mode, do this for all typedefs.
		if isStructUnionClass(sub.Go) || *godefs {
			t.Go = sub.Go

			if isStructUnionClass(sub.Go) {
				// Use the typedef name for C code.
				typedef[sub.Go.(*ast.Ident).Name].C = t.C
			}

			// If we've seen this typedef before, and it
			// was an anonymous struct/union/class before
			// too, use the old definition.
			// TODO: it would be safer to only do this if
			// we verify that the types are the same.
			if oldType != nil && isStructUnionClass(oldType.Go) {
				t.Go = oldType.Go
			}
		}

	case *dwarf.UcharType:
		if t.Size != 1 {
			fatalf("%s: unexpected: %d-byte uchar type - %s", lineno(pos), t.Size, dtype)
		}
		t.Go = c.uint8
		t.Align = 1

	case *dwarf.UintType:
		if dt.BitSize > 0 {
			fatalf("%s: unexpected: %d-bit uint type - %s", lineno(pos), dt.BitSize, dtype)
		}
		switch t.Size {
		default:
			fatalf("%s: unexpected: %d-byte uint type - %s", lineno(pos), t.Size, dtype)
		case 1:
			t.Go = c.uint8
		case 2:
			t.Go = c.uint16
		case 4:
			t.Go = c.uint32
		case 8:
			t.Go = c.uint64
		case 16:
			t.Go = &ast.ArrayType{
				Len: c.intExpr(t.Size),
				Elt: c.uint8,
			}
		}
		if t.Align = t.Size; t.Align >= c.ptrSize {
			t.Align = c.ptrSize
		}

	case *dwarf.VoidType:
		t.Go = c.goVoid
		t.C.Set("void")
		t.Align = 1
	}

	switch dtype.(type) {
	case *dwarf.AddrType, *dwarf.BoolType, *dwarf.CharType, *dwarf.ComplexType, *dwarf.IntType, *dwarf.FloatType, *dwarf.UcharType, *dwarf.UintType:
		s := dtype.Common().Name
		if s != "" {
			if ss, ok := dwarfToName[s]; ok {
				s = ss
			}
			s = strings.Join(strings.Split(s, " "), "") // strip spaces
			name := c.Ident("_Ctype_" + s)
			tt := *t
			typedef[name.Name] = &tt
			if !*godefs {
				t.Go = name
			}
		}
	}

	if t.Size < 0 {
		// Unsized types are [0]byte, unless they're typedefs of other types
		// or structs with tags.
		// if so, use the name we've already defined.
		t.Size = 0
		switch dt := dtype.(type) {
		case *dwarf.TypedefType:
			// ok
		case *dwarf.StructType:
			if dt.StructName != "" {
				break
			}
			t.Go = c.Opaque(0)
		default:
			t.Go = c.Opaque(0)
		}
		if t.C.Empty() {
			t.C.Set("void")
		}
	}

	if t.C.Empty() {
		fatalf("%s: internal error: did not create C name for %s", lineno(pos), dtype)
	}

	return t
}

// isStructUnionClass reports whether the type described by the Go syntax x
// is a struct, union, or class with a tag.
func isStructUnionClass(x ast.Expr) bool {
	id, ok := x.(*ast.Ident)
	if !ok {
		return false
	}
	name := id.Name
	return strings.HasPrefix(name, "_Ctype_struct_") ||
		strings.HasPrefix(name, "_Ctype_union_") ||
		strings.HasPrefix(name, "_Ctype_class_")
}

// FuncArg returns a Go type with the same memory layout as
// dtype when used as the type of a C function argument.
func (c *typeConv) FuncArg(dtype dwarf.Type, pos token.Pos) *Type {
	t := c.Type(dtype, pos)
	switch dt := dtype.(type) {
	case *dwarf.ArrayType:
		// Arrays are passed implicitly as pointers in C.
		// In Go, we must be explicit.
		tr := &TypeRepr{}
		tr.Set("%s*", t.C)
		return &Type{
			Size:  c.ptrSize,
			Align: c.ptrSize,
			Go:    &ast.StarExpr{X: t.Go},
			C:     tr,
		}
	case *dwarf.TypedefType:
		// C has much more relaxed rules than Go for
		// implicit type conversions.  When the parameter
		// is type T defined as *X, simulate a little of the
		// laxness of C by making the argument *X instead of T.
		if ptr, ok := base(dt.Type).(*dwarf.PtrType); ok {
			// Unless the typedef happens to point to void* since
			// Go has special rules around using unsafe.Pointer.
			if _, void := base(ptr.Type).(*dwarf.VoidType); void {
				break
			}

			t = c.Type(ptr, pos)
			if t == nil {
				return nil
			}

			// Remember the C spelling, in case the struct
			// has __attribute__((unavailable)) on it.  See issue 2888.
			t.Typedef = dt.Name
		}
	}
	return t
}

// FuncType returns the Go type analogous to dtype.
// There is no guarantee about matching memory layout.
func (c *typeConv) FuncType(dtype *dwarf.FuncType, pos token.Pos) *FuncType {
	p := make([]*Type, len(dtype.ParamType))
	gp := make([]*ast.Field, len(dtype.ParamType))
	for i, f := range dtype.ParamType {
		// gcc's DWARF generator outputs a single DotDotDotType parameter for
		// function pointers that specify no parameters (e.g. void
		// (*__cgo_0)()).  Treat this special case as void.  This case is
		// invalid according to ISO C anyway (i.e. void (*__cgo_1)(...) is not
		// legal).
		if _, ok := f.(*dwarf.DotDotDotType); ok && i == 0 {
			p, gp = nil, nil
			break
		}
		p[i] = c.FuncArg(f, pos)
		gp[i] = &ast.Field{Type: p[i].Go}
	}
	var r *Type
	var gr []*ast.Field
	if _, ok := dtype.ReturnType.(*dwarf.VoidType); ok {
		gr = []*ast.Field{{Type: c.goVoid}}
	} else if dtype.ReturnType != nil {
		r = c.Type(dtype.ReturnType, pos)
		gr = []*ast.Field{{Type: r.Go}}
	}
	return &FuncType{
		Params: p,
		Result: r,
		Go: &ast.FuncType{
			Params:  &ast.FieldList{List: gp},
			Results: &ast.FieldList{List: gr},
		},
	}
}

// Identifier
func (c *typeConv) Ident(s string) *ast.Ident {
	return ast.NewIdent(s)
}

// Opaque type of n bytes.
func (c *typeConv) Opaque(n int64) ast.Expr {
	return &ast.ArrayType{
		Len: c.intExpr(n),
		Elt: c.byte,
	}
}

// Expr for integer n.
func (c *typeConv) intExpr(n int64) ast.Expr {
	return &ast.BasicLit{
		Kind:  token.INT,
		Value: strconv.FormatInt(n, 10),
	}
}

// Add padding of given size to fld.
func (c *typeConv) pad(fld []*ast.Field, sizes []int64, size int64) ([]*ast.Field, []int64) {
	n := len(fld)
	fld = fld[0 : n+1]
	fld[n] = &ast.Field{Names: []*ast.Ident{c.Ident("_")}, Type: c.Opaque(size)}
	sizes = sizes[0 : n+1]
	sizes[n] = size
	return fld, sizes
}

// Struct conversion: return Go and (gc) C syntax for type.
func (c *typeConv) Struct(dt *dwarf.StructType, pos token.Pos) (expr *ast.StructType, csyntax string, align int64) {
	// Minimum alignment for a struct is 1 byte.
	align = 1

	var buf bytes.Buffer
	buf.WriteString("struct {")
	fld := make([]*ast.Field, 0, 2*len(dt.Field)+1) // enough for padding around every field
	sizes := make([]int64, 0, 2*len(dt.Field)+1)
	off := int64(0)

	// Rename struct fields that happen to be named Go keywords into
	// _{keyword}.  Create a map from C ident -> Go ident.  The Go ident will
	// be mangled.  Any existing identifier that already has the same name on
	// the C-side will cause the Go-mangled version to be prefixed with _.
	// (e.g. in a struct with fields '_type' and 'type', the latter would be
	// rendered as '__type' in Go).
	ident := make(map[string]string)
	used := make(map[string]bool)
	for _, f := range dt.Field {
		ident[f.Name] = f.Name
		used[f.Name] = true
	}

	if !*godefs {
		for cid, goid := range ident {
			if token.Lookup(goid).IsKeyword() {
				// Avoid keyword
				goid = "_" + goid

				// Also avoid existing fields
				for _, exist := used[goid]; exist; _, exist = used[goid] {
					goid = "_" + goid
				}

				used[goid] = true
				ident[cid] = goid
			}
		}
	}

	anon := 0
	for _, f := range dt.Field {
		if f.ByteOffset > off {
			fld, sizes = c.pad(fld, sizes, f.ByteOffset-off)
			off = f.ByteOffset
		}

		name := f.Name
		ft := f.Type

		// In godefs mode, if this field is a C11
		// anonymous union then treat the first field in the
		// union as the field in the struct.  This handles
		// cases like the glibc <sys/resource.h> file; see
		// issue 6677.
		if *godefs {
			if st, ok := f.Type.(*dwarf.StructType); ok && name == "" && st.Kind == "union" && len(st.Field) > 0 && !used[st.Field[0].Name] {
				name = st.Field[0].Name
				ident[name] = name
				ft = st.Field[0].Type
			}
		}

		// TODO: Handle fields that are anonymous structs by
		// promoting the fields of the inner struct.

		t := c.Type(ft, pos)
		tgo := t.Go
		size := t.Size
		talign := t.Align
		if f.BitSize > 0 {
			if f.BitSize%8 != 0 {
				continue
			}
			size = f.BitSize / 8
			name := tgo.(*ast.Ident).String()
			if strings.HasPrefix(name, "int") {
				name = "int"
			} else {
				name = "uint"
			}
			tgo = ast.NewIdent(name + fmt.Sprint(f.BitSize))
			talign = size
		}

		if talign > 0 && f.ByteOffset%talign != 0 {
			// Drop misaligned fields, the same way we drop integer bit fields.
			// The goal is to make available what can be made available.
			// Otherwise one bad and unneeded field in an otherwise okay struct
			// makes the whole program not compile. Much of the time these
			// structs are in system headers that cannot be corrected.
			continue
		}
		n := len(fld)
		fld = fld[0 : n+1]
		if name == "" {
			name = fmt.Sprintf("anon%d", anon)
			anon++
			ident[name] = name
		}
		fld[n] = &ast.Field{Names: []*ast.Ident{c.Ident(ident[name])}, Type: tgo}
		sizes = sizes[0 : n+1]
		sizes[n] = size
		off += size
		buf.WriteString(t.C.String())
		buf.WriteString(" ")
		buf.WriteString(name)
		buf.WriteString("; ")
		if talign > align {
			align = talign
		}
	}
	if off < dt.ByteSize {
		fld, sizes = c.pad(fld, sizes, dt.ByteSize-off)
		off = dt.ByteSize
	}

	// If the last field in a non-zero-sized struct is zero-sized
	// the compiler is going to pad it by one (see issue 9401).
	// We can't permit that, because then the size of the Go
	// struct will not be the same as the size of the C struct.
	// Our only option in such a case is to remove the field,
	// which means that it can not be referenced from Go.
	for off > 0 && sizes[len(sizes)-1] == 0 {
		n := len(sizes)
		fld = fld[0 : n-1]
		sizes = sizes[0 : n-1]
	}

	if off != dt.ByteSize {
		fatalf("%s: struct size calculation error off=%d bytesize=%d", lineno(pos), off, dt.ByteSize)
	}
	buf.WriteString("}")
	csyntax = buf.String()

	if *godefs {
		godefsFields(fld)
	}
	expr = &ast.StructType{Fields: &ast.FieldList{List: fld}}
	return
}

func upper(s string) string {
	if s == "" {
		return ""
	}
	r, size := utf8.DecodeRuneInString(s)
	if r == '_' {
		return "X" + s
	}
	return string(unicode.ToUpper(r)) + s[size:]
}

// godefsFields rewrites field names for use in Go or C definitions.
// It strips leading common prefixes (like tv_ in tv_sec, tv_usec)
// converts names to upper case, and rewrites _ into Pad_godefs_n,
// so that all fields are exported.
func godefsFields(fld []*ast.Field) {
	prefix := fieldPrefix(fld)
	npad := 0
	for _, f := range fld {
		for _, n := range f.Names {
			if n.Name != prefix {
				n.Name = strings.TrimPrefix(n.Name, prefix)
			}
			if n.Name == "_" {
				// Use exported name instead.
				n.Name = "Pad_cgo_" + strconv.Itoa(npad)
				npad++
			}
			n.Name = upper(n.Name)
		}
	}
}

// fieldPrefix returns the prefix that should be removed from all the
// field names when generating the C or Go code.  For generated
// C, we leave the names as is (tv_sec, tv_usec), since that's what
// people are used to seeing in C.  For generated Go code, such as
// package syscall's data structures, we drop a common prefix
// (so sec, usec, which will get turned into Sec, Usec for exporting).
func fieldPrefix(fld []*ast.Field) string {
	prefix := ""
	for _, f := range fld {
		for _, n := range f.Names {
			// Ignore field names that don't have the prefix we're
			// looking for.  It is common in C headers to have fields
			// named, say, _pad in an otherwise prefixed header.
			// If the struct has 3 fields tv_sec, tv_usec, _pad1, then we
			// still want to remove the tv_ prefix.
			// The check for "orig_" here handles orig_eax in the
			// x86 ptrace register sets, which otherwise have all fields
			// with reg_ prefixes.
			if strings.HasPrefix(n.Name, "orig_") || strings.HasPrefix(n.Name, "_") {
				continue
			}
			i := strings.Index(n.Name, "_")
			if i < 0 {
				continue
			}
			if prefix == "" {
				prefix = n.Name[:i+1]
			} else if prefix != n.Name[:i+1] {
				return ""
			}
		}
	}
	return prefix
}
                                                                                                                                                                                                                                                                                                                                                                                                                              usr/local/go/src/cmd/cgo/godefs.go                                                                  0100644 0000000 0000000 00000006351 13020111411 015442  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

// godefs returns the output for -godefs mode.
func (p *Package) godefs(f *File, srcfile string) string {
	var buf bytes.Buffer

	fmt.Fprintf(&buf, "// Created by cgo -godefs - DO NOT EDIT\n")
	fmt.Fprintf(&buf, "// %s %s\n", filepath.Base(os.Args[0]), strings.Join(os.Args[1:], " "))
	fmt.Fprintf(&buf, "\n")

	override := make(map[string]string)

	// Allow source file to specify override mappings.
	// For example, the socket data structures refer
	// to in_addr and in_addr6 structs but we want to be
	// able to treat them as byte arrays, so the godefs
	// inputs in package syscall say
	//
	//	// +godefs map struct_in_addr [4]byte
	//	// +godefs map struct_in_addr6 [16]byte
	//
	for _, g := range f.Comments {
		for _, c := range g.List {
			i := strings.Index(c.Text, "+godefs map")
			if i < 0 {
				continue
			}
			s := strings.TrimSpace(c.Text[i+len("+godefs map"):])
			i = strings.Index(s, " ")
			if i < 0 {
				fmt.Fprintf(os.Stderr, "invalid +godefs map comment: %s\n", c.Text)
				continue
			}
			override["_Ctype_"+strings.TrimSpace(s[:i])] = strings.TrimSpace(s[i:])
		}
	}
	for _, n := range f.Name {
		if s := override[n.Go]; s != "" {
			override[n.Mangle] = s
		}
	}

	// Otherwise, if the source file says type T C.whatever,
	// use "T" as the mangling of C.whatever,
	// except in the definition (handled at end of function).
	refName := make(map[*ast.Expr]*Name)
	for _, r := range f.Ref {
		refName[r.Expr] = r.Name
	}
	for _, d := range f.AST.Decls {
		d, ok := d.(*ast.GenDecl)
		if !ok || d.Tok != token.TYPE {
			continue
		}
		for _, s := range d.Specs {
			s := s.(*ast.TypeSpec)
			n := refName[&s.Type]
			if n != nil && n.Mangle != "" {
				override[n.Mangle] = s.Name.Name
			}
		}
	}

	// Extend overrides using typedefs:
	// If we know that C.xxx should format as T
	// and xxx is a typedef for yyy, make C.yyy format as T.
	for typ, def := range typedef {
		if new := override[typ]; new != "" {
			if id, ok := def.Go.(*ast.Ident); ok {
				override[id.Name] = new
			}
		}
	}

	// Apply overrides.
	for old, new := range override {
		if id := goIdent[old]; id != nil {
			id.Name = new
		}
	}

	// Any names still using the _C syntax are not going to compile,
	// although in general we don't know whether they all made it
	// into the file, so we can't warn here.
	//
	// The most common case is union types, which begin with
	// _Ctype_union and for which typedef[name] is a Go byte
	// array of the appropriate size (such as [4]byte).
	// Substitute those union types with byte arrays.
	for name, id := range goIdent {
		if id.Name == name && strings.Contains(name, "_Ctype_union") {
			if def := typedef[name]; def != nil {
				id.Name = gofmt(def)
			}
		}
	}

	conf.Fprint(&buf, fset, f.AST)

	return buf.String()
}

var gofmtBuf bytes.Buffer

// gofmt returns the gofmt-formatted string for an AST node.
func gofmt(n interface{}) string {
	gofmtBuf.Reset()
	err := printer.Fprint(&gofmtBuf, fset, n)
	if err != nil {
		return "<" + err.Error() + ">"
	}
	return gofmtBuf.String()
}
                                                                                                                                                                                                                                                                                       usr/local/go/src/cmd/cgo/main.go                                                                    0100644 0000000 0000000 00000022566 13020111411 015125  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Cgo; see gmp.go for an overview.

// TODO(rsc):
//	Emit correct line number annotations.
//	Make gc understand the annotations.

package main

import (
	"crypto/md5"
	"flag"
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"io"
	"os"
	"path/filepath"
	"reflect"
	"runtime"
	"sort"
	"strings"
)

// A Package collects information about the package we're going to write.
type Package struct {
	PackageName string // name of package
	PackagePath string
	PtrSize     int64
	IntSize     int64
	GccOptions  []string
	GccIsClang  bool
	CgoFlags    map[string][]string // #cgo flags (CFLAGS, LDFLAGS)
	Written     map[string]bool
	Name        map[string]*Name // accumulated Name from Files
	ExpFunc     []*ExpFunc       // accumulated ExpFunc from Files
	Decl        []ast.Decl
	GoFiles     []string // list of Go files
	GccFiles    []string // list of gcc output files
	Preamble    string   // collected preamble for _cgo_export.h
	CgoChecks   []string // see unsafeCheckPointerName
}

// A File collects information about a single Go input file.
type File struct {
	AST      *ast.File           // parsed AST
	Comments []*ast.CommentGroup // comments from file
	Package  string              // Package name
	Preamble string              // C preamble (doc comment on import "C")
	Ref      []*Ref              // all references to C.xxx in AST
	Calls    []*ast.CallExpr     // all calls to C.xxx in AST
	ExpFunc  []*ExpFunc          // exported functions for this file
	Name     map[string]*Name    // map from Go name to Name
}

func nameKeys(m map[string]*Name) []string {
	var ks []string
	for k := range m {
		ks = append(ks, k)
	}
	sort.Strings(ks)
	return ks
}

// A Ref refers to an expression of the form C.xxx in the AST.
type Ref struct {
	Name    *Name
	Expr    *ast.Expr
	Context string // "type", "expr", "call", or "call2"
}

func (r *Ref) Pos() token.Pos {
	return (*r.Expr).Pos()
}

// A Name collects information about C.xxx.
type Name struct {
	Go       string // name used in Go referring to package C
	Mangle   string // name used in generated Go
	C        string // name used in C
	Define   string // #define expansion
	Kind     string // "const", "type", "var", "fpvar", "func", "not-type"
	Type     *Type  // the type of xxx
	FuncType *FuncType
	AddError bool
	Const    string // constant definition
}

// IsVar reports whether Kind is either "var" or "fpvar"
func (n *Name) IsVar() bool {
	return n.Kind == "var" || n.Kind == "fpvar"
}

// A ExpFunc is an exported function, callable from C.
// Such functions are identified in the Go input file
// by doc comments containing the line //export ExpName
type ExpFunc struct {
	Func    *ast.FuncDecl
	ExpName string // name to use from C
	Doc     string
}

// A TypeRepr contains the string representation of a type.
type TypeRepr struct {
	Repr       string
	FormatArgs []interface{}
}

// A Type collects information about a type in both the C and Go worlds.
type Type struct {
	Size       int64
	Align      int64
	C          *TypeRepr
	Go         ast.Expr
	EnumValues map[string]int64
	Typedef    string
}

// A FuncType collects information about a function type in both the C and Go worlds.
type FuncType struct {
	Params []*Type
	Result *Type
	Go     *ast.FuncType
}

func usage() {
	fmt.Fprint(os.Stderr, "usage: cgo -- [compiler options] file.go ...\n")
	flag.PrintDefaults()
	os.Exit(2)
}

var ptrSizeMap = map[string]int64{
	"386":      4,
	"amd64":    8,
	"arm":      4,
	"arm64":    8,
	"mips64":   8,
	"mips64le": 8,
	"ppc64":    8,
	"ppc64le":  8,
	"s390":     4,
	"s390x":    8,
}

var intSizeMap = map[string]int64{
	"386":      4,
	"amd64":    8,
	"arm":      4,
	"arm64":    8,
	"mips64":   8,
	"mips64le": 8,
	"ppc64":    8,
	"ppc64le":  8,
	"s390":     4,
	"s390x":    4,
}

var cPrefix string

var fset = token.NewFileSet()

var dynobj = flag.String("dynimport", "", "if non-empty, print dynamic import data for that file")
var dynout = flag.String("dynout", "", "write -dynimport output to this file")
var dynpackage = flag.String("dynpackage", "main", "set Go package for -dynimport output")
var dynlinker = flag.Bool("dynlinker", false, "record dynamic linker information in -dynimport mode")

// This flag is for bootstrapping a new Go implementation,
// to generate Go types that match the data layout and
// constant values used in the host's C libraries and system calls.
var godefs = flag.Bool("godefs", false, "for bootstrap: write Go definitions for C file to standard output")

var objDir = flag.String("objdir", "", "object directory")
var importPath = flag.String("importpath", "", "import path of package being built (for comments in generated files)")
var exportHeader = flag.String("exportheader", "", "where to write export header if any exported functions")

var gccgo = flag.Bool("gccgo", false, "generate files for use with gccgo")
var gccgoprefix = flag.String("gccgoprefix", "", "-fgo-prefix option used with gccgo")
var gccgopkgpath = flag.String("gccgopkgpath", "", "-fgo-pkgpath option used with gccgo")
var importRuntimeCgo = flag.Bool("import_runtime_cgo", true, "import runtime/cgo in generated code")
var importSyscall = flag.Bool("import_syscall", true, "import syscall in generated code")
var goarch, goos string

func main() {
	flag.Usage = usage
	flag.Parse()

	if *dynobj != "" {
		// cgo -dynimport is essentially a separate helper command
		// built into the cgo binary.  It scans a gcc-produced executable
		// and dumps information about the imported symbols and the
		// imported libraries.  The 'go build' rules for cgo prepare an
		// appropriate executable and then use its import information
		// instead of needing to make the linkers duplicate all the
		// specialized knowledge gcc has about where to look for imported
		// symbols and which ones to use.
		dynimport(*dynobj)
		return
	}

	if *godefs {
		// Generating definitions pulled from header files,
		// to be checked into Go repositories.
		// Line numbers are just noise.
		conf.Mode &^= printer.SourcePos
	}

	args := flag.Args()
	if len(args) < 1 {
		usage()
	}

	// Find first arg that looks like a go file and assume everything before
	// that are options to pass to gcc.
	var i int
	for i = len(args); i > 0; i-- {
		if !strings.HasSuffix(args[i-1], ".go") {
			break
		}
	}
	if i == len(args) {
		usage()
	}

	goFiles := args[i:]

	p := newPackage(args[:i])

	// Record CGO_LDFLAGS from the environment for external linking.
	if ldflags := os.Getenv("CGO_LDFLAGS"); ldflags != "" {
		args, err := splitQuoted(ldflags)
		if err != nil {
			fatalf("bad CGO_LDFLAGS: %q (%s)", ldflags, err)
		}
		p.addToFlag("LDFLAGS", args)
	}

	// Need a unique prefix for the global C symbols that
	// we use to coordinate between gcc and ourselves.
	// We already put _cgo_ at the beginning, so the main
	// concern is other cgo wrappers for the same functions.
	// Use the beginning of the md5 of the input to disambiguate.
	h := md5.New()
	for _, input := range goFiles {
		f, err := os.Open(input)
		if err != nil {
			fatalf("%s", err)
		}
		io.Copy(h, f)
		f.Close()
	}
	cPrefix = fmt.Sprintf("_%x", h.Sum(nil)[0:6])

	fs := make([]*File, len(goFiles))
	for i, input := range goFiles {
		f := new(File)
		f.ReadGo(input)
		f.DiscardCgoDirectives()
		fs[i] = f
	}

	if *objDir == "" {
		// make sure that _obj directory exists, so that we can write
		// all the output files there.
		os.Mkdir("_obj", 0777)
		*objDir = "_obj"
	}
	*objDir += string(filepath.Separator)

	for i, input := range goFiles {
		f := fs[i]
		p.Translate(f)
		for _, cref := range f.Ref {
			switch cref.Context {
			case "call", "call2":
				if cref.Name.Kind != "type" {
					break
				}
				*cref.Expr = cref.Name.Type.Go
			}
		}
		if nerrors > 0 {
			os.Exit(2)
		}
		p.PackagePath = f.Package
		p.Record(f)
		if *godefs {
			os.Stdout.WriteString(p.godefs(f, input))
		} else {
			p.writeOutput(f, input)
		}
	}

	if !*godefs {
		p.writeDefs()
	}
	if nerrors > 0 {
		os.Exit(2)
	}
}

// newPackage returns a new Package that will invoke
// gcc with the additional arguments specified in args.
func newPackage(args []string) *Package {
	goarch = runtime.GOARCH
	if s := os.Getenv("GOARCH"); s != "" {
		goarch = s
	}
	goos = runtime.GOOS
	if s := os.Getenv("GOOS"); s != "" {
		goos = s
	}
	ptrSize := ptrSizeMap[goarch]
	if ptrSize == 0 {
		fatalf("unknown ptrSize for $GOARCH %q", goarch)
	}
	intSize := intSizeMap[goarch]
	if intSize == 0 {
		fatalf("unknown intSize for $GOARCH %q", goarch)
	}

	// Reset locale variables so gcc emits English errors [sic].
	os.Setenv("LANG", "en_US.UTF-8")
	os.Setenv("LC_ALL", "C")

	p := &Package{
		PtrSize:  ptrSize,
		IntSize:  intSize,
		CgoFlags: make(map[string][]string),
		Written:  make(map[string]bool),
	}
	p.addToFlag("CFLAGS", args)
	return p
}

// Record what needs to be recorded about f.
func (p *Package) Record(f *File) {
	if p.PackageName == "" {
		p.PackageName = f.Package
	} else if p.PackageName != f.Package {
		error_(token.NoPos, "inconsistent package names: %s, %s", p.PackageName, f.Package)
	}

	if p.Name == nil {
		p.Name = f.Name
	} else {
		for k, v := range f.Name {
			if p.Name[k] == nil {
				p.Name[k] = v
			} else if !reflect.DeepEqual(p.Name[k], v) {
				error_(token.NoPos, "inconsistent definitions for C.%s", fixGo(k))
			}
		}
	}

	if f.ExpFunc != nil {
		p.ExpFunc = append(p.ExpFunc, f.ExpFunc...)
		p.Preamble += "\n" + f.Preamble
	}
	p.Decl = append(p.Decl, f.AST.Decls...)
}
                                                                                                                                          usr/local/go/src/cmd/cgo/out.go                                                                     0100644 0000000 0000000 00000122425 13020111411 015003  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"debug/elf"
	"debug/macho"
	"debug/pe"
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"io"
	"os"
	"sort"
	"strings"
)

var conf = printer.Config{Mode: printer.SourcePos, Tabwidth: 8}

// writeDefs creates output files to be compiled by gc and gcc.
func (p *Package) writeDefs() {
	var fgo2, fc io.Writer
	f := creat(*objDir + "_cgo_gotypes.go")
	defer f.Close()
	fgo2 = f
	if *gccgo {
		f := creat(*objDir + "_cgo_defun.c")
		defer f.Close()
		fc = f
	}
	fm := creat(*objDir + "_cgo_main.c")

	var gccgoInit bytes.Buffer

	fflg := creat(*objDir + "_cgo_flags")
	for k, v := range p.CgoFlags {
		fmt.Fprintf(fflg, "_CGO_%s=%s\n", k, strings.Join(v, " "))
		if k == "LDFLAGS" && !*gccgo {
			for _, arg := range v {
				fmt.Fprintf(fgo2, "//go:cgo_ldflag %q\n", arg)
			}
		}
	}
	fflg.Close()

	// Write C main file for using gcc to resolve imports.
	fmt.Fprintf(fm, "int main() { return 0; }\n")
	if *importRuntimeCgo {
		fmt.Fprintf(fm, "void crosscall2(void(*fn)(void*, int), void *a, int c) { }\n")
		fmt.Fprintf(fm, "void _cgo_wait_runtime_init_done() { }\n")
		fmt.Fprintf(fm, "char* _cgo_topofstack(void) { return (char*)0; }\n")
	} else {
		// If we're not importing runtime/cgo, we *are* runtime/cgo,
		// which provides these functions.  We just need a prototype.
		fmt.Fprintf(fm, "void crosscall2(void(*fn)(void*, int), void *a, int c);\n")
		fmt.Fprintf(fm, "void _cgo_wait_runtime_init_done();\n")
	}
	fmt.Fprintf(fm, "void _cgo_allocate(void *a, int c) { }\n")
	fmt.Fprintf(fm, "void _cgo_panic(void *a, int c) { }\n")
	fmt.Fprintf(fm, "void _cgo_reginit(void) { }\n")

	// Write second Go output: definitions of _C_xxx.
	// In a separate file so that the import of "unsafe" does not
	// pollute the original file.
	fmt.Fprintf(fgo2, "// Created by cgo - DO NOT EDIT\n\n")
	fmt.Fprintf(fgo2, "package %s\n\n", p.PackageName)
	fmt.Fprintf(fgo2, "import \"unsafe\"\n\n")
	if !*gccgo && *importRuntimeCgo {
		fmt.Fprintf(fgo2, "import _ \"runtime/cgo\"\n\n")
	}
	if *importSyscall {
		fmt.Fprintf(fgo2, "import \"syscall\"\n\n")
		fmt.Fprintf(fgo2, "var _ syscall.Errno\n")
	}
	fmt.Fprintf(fgo2, "func _Cgo_ptr(ptr unsafe.Pointer) unsafe.Pointer { return ptr }\n\n")

	if !*gccgo {
		fmt.Fprintf(fgo2, "//go:linkname _Cgo_always_false runtime.cgoAlwaysFalse\n")
		fmt.Fprintf(fgo2, "var _Cgo_always_false bool\n")
		fmt.Fprintf(fgo2, "//go:linkname _Cgo_use runtime.cgoUse\n")
		fmt.Fprintf(fgo2, "func _Cgo_use(interface{})\n")
	}

	typedefNames := make([]string, 0, len(typedef))
	for name := range typedef {
		typedefNames = append(typedefNames, name)
	}
	sort.Strings(typedefNames)
	for _, name := range typedefNames {
		def := typedef[name]
		fmt.Fprintf(fgo2, "type %s ", name)
		conf.Fprint(fgo2, fset, def.Go)
		fmt.Fprintf(fgo2, "\n\n")
	}
	if *gccgo {
		fmt.Fprintf(fgo2, "type _Ctype_void byte\n")
	} else {
		fmt.Fprintf(fgo2, "type _Ctype_void [0]byte\n")
	}

	if *gccgo {
		fmt.Fprint(fgo2, gccgoGoProlog)
		fmt.Fprint(fc, p.cPrologGccgo())
	} else {
		fmt.Fprint(fgo2, goProlog)
	}

	for i, t := range p.CgoChecks {
		n := p.unsafeCheckPointerNameIndex(i)
		fmt.Fprintf(fgo2, "\nfunc %s(p interface{}, args ...interface{}) %s {\n", n, t)
		fmt.Fprintf(fgo2, "\treturn _cgoCheckPointer(p, args...).(%s)\n", t)
		fmt.Fprintf(fgo2, "}\n")
	}

	gccgoSymbolPrefix := p.gccgoSymbolPrefix()

	cVars := make(map[string]bool)
	for _, key := range nameKeys(p.Name) {
		n := p.Name[key]
		if !n.IsVar() {
			continue
		}

		if !cVars[n.C] {
			if *gccgo {
				fmt.Fprintf(fc, "extern byte *%s;\n", n.C)
			} else {
				fmt.Fprintf(fm, "extern char %s[];\n", n.C)
				fmt.Fprintf(fm, "void *_cgohack_%s = %s;\n\n", n.C, n.C)
				fmt.Fprintf(fgo2, "//go:linkname __cgo_%s %s\n", n.C, n.C)
				fmt.Fprintf(fgo2, "//go:cgo_import_static %s\n", n.C)
				fmt.Fprintf(fgo2, "var __cgo_%s byte\n", n.C)
			}
			cVars[n.C] = true
		}

		var node ast.Node
		if n.Kind == "var" {
			node = &ast.StarExpr{X: n.Type.Go}
		} else if n.Kind == "fpvar" {
			node = n.Type.Go
		} else {
			panic(fmt.Errorf("invalid var kind %q", n.Kind))
		}
		if *gccgo {
			fmt.Fprintf(fc, `extern void *%s __asm__("%s.%s");`, n.Mangle, gccgoSymbolPrefix, n.Mangle)
			fmt.Fprintf(&gccgoInit, "\t%s = &%s;\n", n.Mangle, n.C)
			fmt.Fprintf(fc, "\n")
		}

		fmt.Fprintf(fgo2, "var %s ", n.Mangle)
		conf.Fprint(fgo2, fset, node)
		if !*gccgo {
			fmt.Fprintf(fgo2, " = (")
			conf.Fprint(fgo2, fset, node)
			fmt.Fprintf(fgo2, ")(unsafe.Pointer(&__cgo_%s))", n.C)
		}
		fmt.Fprintf(fgo2, "\n")
	}
	if *gccgo {
		fmt.Fprintf(fc, "\n")
	}

	for _, key := range nameKeys(p.Name) {
		n := p.Name[key]
		if n.Const != "" {
			fmt.Fprintf(fgo2, "const _Cconst_%s = %s\n", n.Go, n.Const)
		}
	}
	fmt.Fprintf(fgo2, "\n")

	for _, key := range nameKeys(p.Name) {
		n := p.Name[key]
		if n.FuncType != nil {
			p.writeDefsFunc(fgo2, n)
		}
	}

	fgcc := creat(*objDir + "_cgo_export.c")
	fgcch := creat(*objDir + "_cgo_export.h")
	if *gccgo {
		p.writeGccgoExports(fgo2, fm, fgcc, fgcch)
	} else {
		p.writeExports(fgo2, fm, fgcc, fgcch)
	}
	if err := fgcc.Close(); err != nil {
		fatalf("%s", err)
	}
	if err := fgcch.Close(); err != nil {
		fatalf("%s", err)
	}

	if *exportHeader != "" && len(p.ExpFunc) > 0 {
		fexp := creat(*exportHeader)
		fgcch, err := os.Open(*objDir + "_cgo_export.h")
		if err != nil {
			fatalf("%s", err)
		}
		_, err = io.Copy(fexp, fgcch)
		if err != nil {
			fatalf("%s", err)
		}
		if err = fexp.Close(); err != nil {
			fatalf("%s", err)
		}
	}

	init := gccgoInit.String()
	if init != "" {
		fmt.Fprintln(fc, "static void init(void) __attribute__ ((constructor));")
		fmt.Fprintln(fc, "static void init(void) {")
		fmt.Fprint(fc, init)
		fmt.Fprintln(fc, "}")
	}
}

func dynimport(obj string) {
	stdout := os.Stdout
	if *dynout != "" {
		f, err := os.Create(*dynout)
		if err != nil {
			fatalf("%s", err)
		}
		stdout = f
	}

	fmt.Fprintf(stdout, "package %s\n", *dynpackage)

	if f, err := elf.Open(obj); err == nil {
		if *dynlinker {
			// Emit the cgo_dynamic_linker line.
			if sec := f.Section(".interp"); sec != nil {
				if data, err := sec.Data(); err == nil && len(data) > 1 {
					// skip trailing \0 in data
					fmt.Fprintf(stdout, "//go:cgo_dynamic_linker %q\n", string(data[:len(data)-1]))
				}
			}
		}
		sym, err := f.ImportedSymbols()
		if err != nil {
			fatalf("cannot load imported symbols from ELF file %s: %v", obj, err)
		}
		for _, s := range sym {
			targ := s.Name
			if s.Version != "" {
				targ += "#" + s.Version
			}
			fmt.Fprintf(stdout, "//go:cgo_import_dynamic %s %s %q\n", s.Name, targ, s.Library)
		}
		lib, err := f.ImportedLibraries()
		if err != nil {
			fatalf("cannot load imported libraries from ELF file %s: %v", obj, err)
		}
		for _, l := range lib {
			fmt.Fprintf(stdout, "//go:cgo_import_dynamic _ _ %q\n", l)
		}
		return
	}

	if f, err := macho.Open(obj); err == nil {
		sym, err := f.ImportedSymbols()
		if err != nil {
			fatalf("cannot load imported symbols from Mach-O file %s: %v", obj, err)
		}
		for _, s := range sym {
			if len(s) > 0 && s[0] == '_' {
				s = s[1:]
			}
			fmt.Fprintf(stdout, "//go:cgo_import_dynamic %s %s %q\n", s, s, "")
		}
		lib, err := f.ImportedLibraries()
		if err != nil {
			fatalf("cannot load imported libraries from Mach-O file %s: %v", obj, err)
		}
		for _, l := range lib {
			fmt.Fprintf(stdout, "//go:cgo_import_dynamic _ _ %q\n", l)
		}
		return
	}

	if f, err := pe.Open(obj); err == nil {
		sym, err := f.ImportedSymbols()
		if err != nil {
			fatalf("cannot load imported symbols from PE file %s: %v", obj, err)
		}
		for _, s := range sym {
			ss := strings.Split(s, ":")
			name := strings.Split(ss[0], "@")[0]
			fmt.Fprintf(stdout, "//go:cgo_import_dynamic %s %s %q\n", name, ss[0], strings.ToLower(ss[1]))
		}
		return
	}

	fatalf("cannot parse %s as ELF, Mach-O or PE", obj)
}

// Construct a gcc struct matching the gc argument frame.
// Assumes that in gcc, char is 1 byte, short 2 bytes, int 4 bytes, long long 8 bytes.
// These assumptions are checked by the gccProlog.
// Also assumes that gc convention is to word-align the
// input and output parameters.
func (p *Package) structType(n *Name) (string, int64) {
	var buf bytes.Buffer
	fmt.Fprint(&buf, "struct {\n")
	off := int64(0)
	for i, t := range n.FuncType.Params {
		if off%t.Align != 0 {
			pad := t.Align - off%t.Align
			fmt.Fprintf(&buf, "\t\tchar __pad%d[%d];\n", off, pad)
			off += pad
		}
		c := t.Typedef
		if c == "" {
			c = t.C.String()
		}
		fmt.Fprintf(&buf, "\t\t%s p%d;\n", c, i)
		off += t.Size
	}
	if off%p.PtrSize != 0 {
		pad := p.PtrSize - off%p.PtrSize
		fmt.Fprintf(&buf, "\t\tchar __pad%d[%d];\n", off, pad)
		off += pad
	}
	if t := n.FuncType.Result; t != nil {
		if off%t.Align != 0 {
			pad := t.Align - off%t.Align
			fmt.Fprintf(&buf, "\t\tchar __pad%d[%d];\n", off, pad)
			off += pad
		}
		qual := ""
		if c := t.C.String(); c[len(c)-1] == '*' {
			qual = "const "
		}
		fmt.Fprintf(&buf, "\t\t%s%s r;\n", qual, t.C)
		off += t.Size
	}
	if off%p.PtrSize != 0 {
		pad := p.PtrSize - off%p.PtrSize
		fmt.Fprintf(&buf, "\t\tchar __pad%d[%d];\n", off, pad)
		off += pad
	}
	if off == 0 {
		fmt.Fprintf(&buf, "\t\tchar unused;\n") // avoid empty struct
	}
	fmt.Fprintf(&buf, "\t}")
	return buf.String(), off
}

func (p *Package) writeDefsFunc(fgo2 io.Writer, n *Name) {
	name := n.Go
	gtype := n.FuncType.Go
	void := gtype.Results == nil || len(gtype.Results.List) == 0
	if n.AddError {
		// Add "error" to return type list.
		// Type list is known to be 0 or 1 element - it's a C function.
		err := &ast.Field{Type: ast.NewIdent("error")}
		l := gtype.Results.List
		if len(l) == 0 {
			l = []*ast.Field{err}
		} else {
			l = []*ast.Field{l[0], err}
		}
		t := new(ast.FuncType)
		*t = *gtype
		t.Results = &ast.FieldList{List: l}
		gtype = t
	}

	// Go func declaration.
	d := &ast.FuncDecl{
		Name: ast.NewIdent(n.Mangle),
		Type: gtype,
	}

	// Builtins defined in the C prolog.
	inProlog := builtinDefs[name] != ""
	cname := fmt.Sprintf("_cgo%s%s", cPrefix, n.Mangle)
	paramnames := []string(nil)
	for i, param := range d.Type.Params.List {
		paramName := fmt.Sprintf("p%d", i)
		param.Names = []*ast.Ident{ast.NewIdent(paramName)}
		paramnames = append(paramnames, paramName)
	}

	if *gccgo {
		// Gccgo style hooks.
		fmt.Fprint(fgo2, "\n")
		conf.Fprint(fgo2, fset, d)
		fmt.Fprint(fgo2, " {\n")
		if !inProlog {
			fmt.Fprint(fgo2, "\tdefer syscall.CgocallDone()\n")
			fmt.Fprint(fgo2, "\tsyscall.Cgocall()\n")
		}
		if n.AddError {
			fmt.Fprint(fgo2, "\tsyscall.SetErrno(0)\n")
		}
		fmt.Fprint(fgo2, "\t")
		if !void {
			fmt.Fprint(fgo2, "r := ")
		}
		fmt.Fprintf(fgo2, "%s(%s)\n", cname, strings.Join(paramnames, ", "))

		if n.AddError {
			fmt.Fprint(fgo2, "\te := syscall.GetErrno()\n")
			fmt.Fprint(fgo2, "\tif e != 0 {\n")
			fmt.Fprint(fgo2, "\t\treturn ")
			if !void {
				fmt.Fprint(fgo2, "r, ")
			}
			fmt.Fprint(fgo2, "e\n")
			fmt.Fprint(fgo2, "\t}\n")
			fmt.Fprint(fgo2, "\treturn ")
			if !void {
				fmt.Fprint(fgo2, "r, ")
			}
			fmt.Fprint(fgo2, "nil\n")
		} else if !void {
			fmt.Fprint(fgo2, "\treturn r\n")
		}

		fmt.Fprint(fgo2, "}\n")

		// declare the C function.
		fmt.Fprintf(fgo2, "//extern %s\n", cname)
		d.Name = ast.NewIdent(cname)
		if n.AddError {
			l := d.Type.Results.List
			d.Type.Results.List = l[:len(l)-1]
		}
		conf.Fprint(fgo2, fset, d)
		fmt.Fprint(fgo2, "\n")

		return
	}

	if inProlog {
		fmt.Fprint(fgo2, builtinDefs[name])
		return
	}

	// Wrapper calls into gcc, passing a pointer to the argument frame.
	fmt.Fprintf(fgo2, "//go:cgo_import_static %s\n", cname)
	fmt.Fprintf(fgo2, "//go:linkname __cgofn_%s %s\n", cname, cname)
	fmt.Fprintf(fgo2, "var __cgofn_%s byte\n", cname)
	fmt.Fprintf(fgo2, "var %s = unsafe.Pointer(&__cgofn_%s)\n", cname, cname)

	nret := 0
	if !void {
		d.Type.Results.List[0].Names = []*ast.Ident{ast.NewIdent("r1")}
		nret = 1
	}
	if n.AddError {
		d.Type.Results.List[nret].Names = []*ast.Ident{ast.NewIdent("r2")}
	}

	fmt.Fprint(fgo2, "\n")
	conf.Fprint(fgo2, fset, d)
	fmt.Fprint(fgo2, " {\n")

	// NOTE: Using uintptr to hide from escape analysis.
	arg := "0"
	if len(paramnames) > 0 {
		arg = "uintptr(unsafe.Pointer(&p0))"
	} else if !void {
		arg = "uintptr(unsafe.Pointer(&r1))"
	}

	prefix := ""
	if n.AddError {
		prefix = "errno := "
	}
	fmt.Fprintf(fgo2, "\t%s_cgo_runtime_cgocall(%s, %s)\n", prefix, cname, arg)
	if n.AddError {
		fmt.Fprintf(fgo2, "\tif errno != 0 { r2 = syscall.Errno(errno) }\n")
	}
	fmt.Fprintf(fgo2, "\tif _Cgo_always_false {\n")
	for i := range d.Type.Params.List {
		fmt.Fprintf(fgo2, "\t\t_Cgo_use(p%d)\n", i)
	}
	fmt.Fprintf(fgo2, "\t}\n")
	fmt.Fprintf(fgo2, "\treturn\n")
	fmt.Fprintf(fgo2, "}\n")
}

// writeOutput creates stubs for a specific source file to be compiled by gc
func (p *Package) writeOutput(f *File, srcfile string) {
	base := srcfile
	if strings.HasSuffix(base, ".go") {
		base = base[0 : len(base)-3]
	}
	base = strings.Map(slashToUnderscore, base)
	fgo1 := creat(*objDir + base + ".cgo1.go")
	fgcc := creat(*objDir + base + ".cgo2.c")

	p.GoFiles = append(p.GoFiles, base+".cgo1.go")
	p.GccFiles = append(p.GccFiles, base+".cgo2.c")

	// Write Go output: Go input with rewrites of C.xxx to _C_xxx.
	fmt.Fprintf(fgo1, "// Created by cgo - DO NOT EDIT\n\n")
	conf.Fprint(fgo1, fset, f.AST)

	// While we process the vars and funcs, also write gcc output.
	// Gcc output starts with the preamble.
	fmt.Fprintf(fgcc, "%s\n", f.Preamble)
	fmt.Fprintf(fgcc, "%s\n", gccProlog)

	for _, key := range nameKeys(f.Name) {
		n := f.Name[key]
		if n.FuncType != nil {
			p.writeOutputFunc(fgcc, n)
		}
	}

	fgo1.Close()
	fgcc.Close()
}

// fixGo converts the internal Name.Go field into the name we should show
// to users in error messages. There's only one for now: on input we rewrite
// C.malloc into C._CMalloc, so change it back here.
func fixGo(name string) string {
	if name == "_CMalloc" {
		return "malloc"
	}
	return name
}

var isBuiltin = map[string]bool{
	"_Cfunc_CString":   true,
	"_Cfunc_GoString":  true,
	"_Cfunc_GoStringN": true,
	"_Cfunc_GoBytes":   true,
	"_Cfunc__CMalloc":  true,
}

func (p *Package) writeOutputFunc(fgcc *os.File, n *Name) {
	name := n.Mangle
	if isBuiltin[name] || p.Written[name] {
		// The builtins are already defined in the C prolog, and we don't
		// want to duplicate function definitions we've already done.
		return
	}
	p.Written[name] = true

	if *gccgo {
		p.writeGccgoOutputFunc(fgcc, n)
		return
	}

	ctype, _ := p.structType(n)

	// Gcc wrapper unpacks the C argument struct
	// and calls the actual C function.
	if n.AddError {
		fmt.Fprintf(fgcc, "int\n")
	} else {
		fmt.Fprintf(fgcc, "void\n")
	}
	fmt.Fprintf(fgcc, "_cgo%s%s(void *v)\n", cPrefix, n.Mangle)
	fmt.Fprintf(fgcc, "{\n")
	if n.AddError {
		fmt.Fprintf(fgcc, "\terrno = 0;\n")
	}
	// We're trying to write a gcc struct that matches gc's layout.
	// Use packed attribute to force no padding in this struct in case
	// gcc has different packing requirements.
	fmt.Fprintf(fgcc, "\t%s %v *a = v;\n", ctype, p.packedAttribute())
	if n.FuncType.Result != nil {
		// Save the stack top for use below.
		fmt.Fprintf(fgcc, "\tchar *stktop = _cgo_topofstack();\n")
	}
	fmt.Fprintf(fgcc, "\t")
	if t := n.FuncType.Result; t != nil {
		fmt.Fprintf(fgcc, "__typeof__(a->r) r = ")
		if c := t.C.String(); c[len(c)-1] == '*' {
			fmt.Fprint(fgcc, "(__typeof__(a->r)) ")
		}
	}
	fmt.Fprintf(fgcc, "%s(", n.C)
	for i, t := range n.FuncType.Params {
		if i > 0 {
			fmt.Fprintf(fgcc, ", ")
		}
		// We know the type params are correct, because
		// the Go equivalents had good type params.
		// However, our version of the type omits the magic
		// words const and volatile, which can provoke
		// C compiler warnings.  Silence them by casting
		// all pointers to void*.  (Eventually that will produce
		// other warnings.)
		if c := t.C.String(); c[len(c)-1] == '*' {
			fmt.Fprintf(fgcc, "(void*)")
		}
		fmt.Fprintf(fgcc, "a->p%d", i)
	}
	fmt.Fprintf(fgcc, ");\n")
	if n.FuncType.Result != nil {
		// The cgo call may have caused a stack copy (via a callback).
		// Adjust the return value pointer appropriately.
		fmt.Fprintf(fgcc, "\ta = (void*)((char*)a + (_cgo_topofstack() - stktop));\n")
		// Save the return value.
		fmt.Fprintf(fgcc, "\ta->r = r;\n")
	}
	if n.AddError {
		fmt.Fprintf(fgcc, "\treturn errno;\n")
	}
	fmt.Fprintf(fgcc, "}\n")
	fmt.Fprintf(fgcc, "\n")
}

// Write out a wrapper for a function when using gccgo.  This is a
// simple wrapper that just calls the real function.  We only need a
// wrapper to support static functions in the prologue--without a
// wrapper, we can't refer to the function, since the reference is in
// a different file.
func (p *Package) writeGccgoOutputFunc(fgcc *os.File, n *Name) {
	if t := n.FuncType.Result; t != nil {
		fmt.Fprintf(fgcc, "%s\n", t.C.String())
	} else {
		fmt.Fprintf(fgcc, "void\n")
	}
	fmt.Fprintf(fgcc, "_cgo%s%s(", cPrefix, n.Mangle)
	for i, t := range n.FuncType.Params {
		if i > 0 {
			fmt.Fprintf(fgcc, ", ")
		}
		c := t.Typedef
		if c == "" {
			c = t.C.String()
		}
		fmt.Fprintf(fgcc, "%s p%d", c, i)
	}
	fmt.Fprintf(fgcc, ")\n")
	fmt.Fprintf(fgcc, "{\n")
	fmt.Fprintf(fgcc, "\t")
	if t := n.FuncType.Result; t != nil {
		fmt.Fprintf(fgcc, "return ")
		// Cast to void* to avoid warnings due to omitted qualifiers.
		if c := t.C.String(); c[len(c)-1] == '*' {
			fmt.Fprintf(fgcc, "(void*)")
		}
	}
	fmt.Fprintf(fgcc, "%s(", n.C)
	for i, t := range n.FuncType.Params {
		if i > 0 {
			fmt.Fprintf(fgcc, ", ")
		}
		// Cast to void* to avoid warnings due to omitted qualifiers.
		if c := t.C.String(); c[len(c)-1] == '*' {
			fmt.Fprintf(fgcc, "(void*)")
		}
		fmt.Fprintf(fgcc, "p%d", i)
	}
	fmt.Fprintf(fgcc, ");\n")
	fmt.Fprintf(fgcc, "}\n")
	fmt.Fprintf(fgcc, "\n")
}

// packedAttribute returns host compiler struct attribute that will be
// used to match gc's struct layout. For example, on 386 Windows,
// gcc wants to 8-align int64s, but gc does not.
// Use __gcc_struct__ to work around http://gcc.gnu.org/PR52991 on x86,
// and https://golang.org/issue/5603.
func (p *Package) packedAttribute() string {
	s := "__attribute__((__packed__"
	if !p.GccIsClang && (goarch == "amd64" || goarch == "386") {
		s += ", __gcc_struct__"
	}
	return s + "))"
}

// Write out the various stubs we need to support functions exported
// from Go so that they are callable from C.
func (p *Package) writeExports(fgo2, fm, fgcc, fgcch io.Writer) {
	p.writeExportHeader(fgcch)

	fmt.Fprintf(fgcc, "/* Created by cgo - DO NOT EDIT. */\n")
	fmt.Fprintf(fgcc, "#include \"_cgo_export.h\"\n\n")

	fmt.Fprintf(fgcc, "extern void crosscall2(void (*fn)(void *, int), void *, int);\n")
	fmt.Fprintf(fgcc, "extern void _cgo_wait_runtime_init_done();\n\n")

	for _, exp := range p.ExpFunc {
		fn := exp.Func

		// Construct a gcc struct matching the gc argument and
		// result frame.  The gcc struct will be compiled with
		// __attribute__((packed)) so all padding must be accounted
		// for explicitly.
		ctype := "struct {\n"
		off := int64(0)
		npad := 0
		if fn.Recv != nil {
			t := p.cgoType(fn.Recv.List[0].Type)
			ctype += fmt.Sprintf("\t\t%s recv;\n", t.C)
			off += t.Size
		}
		fntype := fn.Type
		forFieldList(fntype.Params,
			func(i int, aname string, atype ast.Expr) {
				t := p.cgoType(atype)
				if off%t.Align != 0 {
					pad := t.Align - off%t.Align
					ctype += fmt.Sprintf("\t\tchar __pad%d[%d];\n", npad, pad)
					off += pad
					npad++
				}
				ctype += fmt.Sprintf("\t\t%s p%d;\n", t.C, i)
				off += t.Size
			})
		if off%p.PtrSize != 0 {
			pad := p.PtrSize - off%p.PtrSize
			ctype += fmt.Sprintf("\t\tchar __pad%d[%d];\n", npad, pad)
			off += pad
			npad++
		}
		forFieldList(fntype.Results,
			func(i int, aname string, atype ast.Expr) {
				t := p.cgoType(atype)
				if off%t.Align != 0 {
					pad := t.Align - off%t.Align
					ctype += fmt.Sprintf("\t\tchar __pad%d[%d];\n", npad, pad)
					off += pad
					npad++
				}
				ctype += fmt.Sprintf("\t\t%s r%d;\n", t.C, i)
				off += t.Size
			})
		if off%p.PtrSize != 0 {
			pad := p.PtrSize - off%p.PtrSize
			ctype += fmt.Sprintf("\t\tchar __pad%d[%d];\n", npad, pad)
			off += pad
			npad++
		}
		if ctype == "struct {\n" {
			ctype += "\t\tchar unused;\n" // avoid empty struct
		}
		ctype += "\t}"

		// Get the return type of the wrapper function
		// compiled by gcc.
		gccResult := ""
		if fntype.Results == nil || len(fntype.Results.List) == 0 {
			gccResult = "void"
		} else if len(fntype.Results.List) == 1 && len(fntype.Results.List[0].Names) <= 1 {
			gccResult = p.cgoType(fntype.Results.List[0].Type).C.String()
		} else {
			fmt.Fprintf(fgcch, "\n/* Return type for %s */\n", exp.ExpName)
			fmt.Fprintf(fgcch, "struct %s_return {\n", exp.ExpName)
			forFieldList(fntype.Results,
				func(i int, aname string, atype ast.Expr) {
					fmt.Fprintf(fgcch, "\t%s r%d;", p.cgoType(atype).C, i)
					if len(aname) > 0 {
						fmt.Fprintf(fgcch, " /* %s */", aname)
					}
					fmt.Fprint(fgcch, "\n")
				})
			fmt.Fprintf(fgcch, "};\n")
			gccResult = "struct " + exp.ExpName + "_return"
		}

		// Build the wrapper function compiled by gcc.
		s := fmt.Sprintf("%s %s(", gccResult, exp.ExpName)
		if fn.Recv != nil {
			s += p.cgoType(fn.Recv.List[0].Type).C.String()
			s += " recv"
		}
		forFieldList(fntype.Params,
			func(i int, aname string, atype ast.Expr) {
				if i > 0 || fn.Recv != nil {
					s += ", "
				}
				s += fmt.Sprintf("%s p%d", p.cgoType(atype).C, i)
			})
		s += ")"

		if len(exp.Doc) > 0 {
			fmt.Fprintf(fgcch, "\n%s", exp.Doc)
		}
		fmt.Fprintf(fgcch, "\nextern %s;\n", s)

		fmt.Fprintf(fgcc, "extern void _cgoexp%s_%s(void *, int);\n", cPrefix, exp.ExpName)
		fmt.Fprintf(fgcc, "\n%s\n", s)
		fmt.Fprintf(fgcc, "{\n")
		fmt.Fprintf(fgcc, "\t_cgo_wait_runtime_init_done();\n")
		fmt.Fprintf(fgcc, "\t%s %v a;\n", ctype, p.packedAttribute())
		if gccResult != "void" && (len(fntype.Results.List) > 1 || len(fntype.Results.List[0].Names) > 1) {
			fmt.Fprintf(fgcc, "\t%s r;\n", gccResult)
		}
		if fn.Recv != nil {
			fmt.Fprintf(fgcc, "\ta.recv = recv;\n")
		}
		forFieldList(fntype.Params,
			func(i int, aname string, atype ast.Expr) {
				fmt.Fprintf(fgcc, "\ta.p%d = p%d;\n", i, i)
			})
		fmt.Fprintf(fgcc, "\tcrosscall2(_cgoexp%s_%s, &a, %d);\n", cPrefix, exp.ExpName, off)
		if gccResult != "void" {
			if len(fntype.Results.List) == 1 && len(fntype.Results.List[0].Names) <= 1 {
				fmt.Fprintf(fgcc, "\treturn a.r0;\n")
			} else {
				forFieldList(fntype.Results,
					func(i int, aname string, atype ast.Expr) {
						fmt.Fprintf(fgcc, "\tr.r%d = a.r%d;\n", i, i)
					})
				fmt.Fprintf(fgcc, "\treturn r;\n")
			}
		}
		fmt.Fprintf(fgcc, "}\n")

		// Build the wrapper function compiled by cmd/compile.
		goname := "_cgoexpwrap" + cPrefix + "_"
		if fn.Recv != nil {
			goname += fn.Recv.List[0].Names[0].Name + "_"
		}
		goname += exp.Func.Name.Name
		fmt.Fprintf(fgo2, "//go:cgo_export_dynamic %s\n", exp.ExpName)
		fmt.Fprintf(fgo2, "//go:linkname _cgoexp%s_%s _cgoexp%s_%s\n", cPrefix, exp.ExpName, cPrefix, exp.ExpName)
		fmt.Fprintf(fgo2, "//go:cgo_export_static _cgoexp%s_%s\n", cPrefix, exp.ExpName)
		fmt.Fprintf(fgo2, "//go:nosplit\n") // no split stack, so no use of m or g
		fmt.Fprintf(fgo2, "//go:norace\n")  // must not have race detector calls inserted
		fmt.Fprintf(fgo2, "func _cgoexp%s_%s(a unsafe.Pointer, n int32) {\n", cPrefix, exp.ExpName)
		fmt.Fprintf(fgo2, "\tfn := %s\n", goname)
		// The indirect here is converting from a Go function pointer to a C function pointer.
		fmt.Fprintf(fgo2, "\t_cgo_runtime_cgocallback(**(**unsafe.Pointer)(unsafe.Pointer(&fn)), a, uintptr(n));\n")
		fmt.Fprintf(fgo2, "}\n")

		fmt.Fprintf(fm, "int _cgoexp%s_%s;\n", cPrefix, exp.ExpName)

		// This code uses printer.Fprint, not conf.Fprint,
		// because we don't want //line comments in the middle
		// of the function types.
		fmt.Fprintf(fgo2, "\n")
		fmt.Fprintf(fgo2, "func %s(", goname)
		comma := false
		if fn.Recv != nil {
			fmt.Fprintf(fgo2, "recv ")
			printer.Fprint(fgo2, fset, fn.Recv.List[0].Type)
			comma = true
		}
		forFieldList(fntype.Params,
			func(i int, aname string, atype ast.Expr) {
				if comma {
					fmt.Fprintf(fgo2, ", ")
				}
				fmt.Fprintf(fgo2, "p%d ", i)
				printer.Fprint(fgo2, fset, atype)
				comma = true
			})
		fmt.Fprintf(fgo2, ")")
		if gccResult != "void" {
			fmt.Fprint(fgo2, " (")
			forFieldList(fntype.Results,
				func(i int, aname string, atype ast.Expr) {
					if i > 0 {
						fmt.Fprint(fgo2, ", ")
					}
					fmt.Fprintf(fgo2, "r%d ", i)
					printer.Fprint(fgo2, fset, atype)
				})
			fmt.Fprint(fgo2, ")")
		}
		fmt.Fprint(fgo2, " {\n")
		if gccResult == "void" {
			fmt.Fprint(fgo2, "\t")
		} else {
			// Verify that any results don't contain any
			// Go pointers.
			addedDefer := false
			forFieldList(fntype.Results,
				func(i int, aname string, atype ast.Expr) {
					if !p.hasPointer(nil, atype, false) {
						return
					}
					if !addedDefer {
						fmt.Fprint(fgo2, "\tdefer func() {\n")
						addedDefer = true
					}
					fmt.Fprintf(fgo2, "\t\t_cgoCheckResult(r%d)\n", i)
				})
			if addedDefer {
				fmt.Fprint(fgo2, "\t}()\n")
			}
			fmt.Fprint(fgo2, "\treturn ")
		}
		if fn.Recv != nil {
			fmt.Fprintf(fgo2, "recv.")
		}
		fmt.Fprintf(fgo2, "%s(", exp.Func.Name)
		forFieldList(fntype.Params,
			func(i int, aname string, atype ast.Expr) {
				if i > 0 {
					fmt.Fprint(fgo2, ", ")
				}
				fmt.Fprintf(fgo2, "p%d", i)
			})
		fmt.Fprint(fgo2, ")\n")
		fmt.Fprint(fgo2, "}\n")
	}

	fmt.Fprintf(fgcch, "%s", gccExportHeaderEpilog)
}

// Write out the C header allowing C code to call exported gccgo functions.
func (p *Package) writeGccgoExports(fgo2, fm, fgcc, fgcch io.Writer) {
	gccgoSymbolPrefix := p.gccgoSymbolPrefix()

	p.writeExportHeader(fgcch)

	fmt.Fprintf(fgcc, "/* Created by cgo - DO NOT EDIT. */\n")
	fmt.Fprintf(fgcc, "#include \"_cgo_export.h\"\n")

	fmt.Fprintf(fgcc, "%s\n", gccgoExportFileProlog)

	for _, exp := range p.ExpFunc {
		fn := exp.Func
		fntype := fn.Type

		cdeclBuf := new(bytes.Buffer)
		resultCount := 0
		forFieldList(fntype.Results,
			func(i int, aname string, atype ast.Expr) { resultCount++ })
		switch resultCount {
		case 0:
			fmt.Fprintf(cdeclBuf, "void")
		case 1:
			forFieldList(fntype.Results,
				func(i int, aname string, atype ast.Expr) {
					t := p.cgoType(atype)
					fmt.Fprintf(cdeclBuf, "%s", t.C)
				})
		default:
			// Declare a result struct.
			fmt.Fprintf(fgcch, "\n/* Return type for %s */\n", exp.ExpName)
			fmt.Fprintf(fgcch, "struct %s_result {\n", exp.ExpName)
			forFieldList(fntype.Results,
				func(i int, aname string, atype ast.Expr) {
					t := p.cgoType(atype)
					fmt.Fprintf(fgcch, "\t%s r%d;", t.C, i)
					if len(aname) > 0 {
						fmt.Fprintf(fgcch, " /* %s */", aname)
					}
					fmt.Fprint(fgcch, "\n")
				})
			fmt.Fprintf(fgcch, "};\n")
			fmt.Fprintf(cdeclBuf, "struct %s_result", exp.ExpName)
		}

		cRet := cdeclBuf.String()

		cdeclBuf = new(bytes.Buffer)
		fmt.Fprintf(cdeclBuf, "(")
		if fn.Recv != nil {
			fmt.Fprintf(cdeclBuf, "%s recv", p.cgoType(fn.Recv.List[0].Type).C.String())
		}
		// Function parameters.
		forFieldList(fntype.Params,
			func(i int, aname string, atype ast.Expr) {
				if i > 0 || fn.Recv != nil {
					fmt.Fprintf(cdeclBuf, ", ")
				}
				t := p.cgoType(atype)
				fmt.Fprintf(cdeclBuf, "%s p%d", t.C, i)
			})
		fmt.Fprintf(cdeclBuf, ")")
		cParams := cdeclBuf.String()

		if len(exp.Doc) > 0 {
			fmt.Fprintf(fgcch, "\n%s", exp.Doc)
		}

		fmt.Fprintf(fgcch, "extern %s %s %s;\n", cRet, exp.ExpName, cParams)

		// We need to use a name that will be exported by the
		// Go code; otherwise gccgo will make it static and we
		// will not be able to link against it from the C
		// code.
		goName := "Cgoexp_" + exp.ExpName
		fmt.Fprintf(fgcc, `extern %s %s %s __asm__("%s.%s");`, cRet, goName, cParams, gccgoSymbolPrefix, goName)
		fmt.Fprint(fgcc, "\n")

		fmt.Fprint(fgcc, "\n")
		fmt.Fprintf(fgcc, "%s %s %s {\n", cRet, exp.ExpName, cParams)
		fmt.Fprintf(fgcc, "\tif(_cgo_wait_runtime_init_done)\n")
		fmt.Fprintf(fgcc, "\t\t_cgo_wait_runtime_init_done();\n")
		fmt.Fprint(fgcc, "\t")
		if resultCount > 0 {
			fmt.Fprint(fgcc, "return ")
		}
		fmt.Fprintf(fgcc, "%s(", goName)
		if fn.Recv != nil {
			fmt.Fprint(fgcc, "recv")
		}
		forFieldList(fntype.Params,
			func(i int, aname string, atype ast.Expr) {
				if i > 0 || fn.Recv != nil {
					fmt.Fprintf(fgcc, ", ")
				}
				fmt.Fprintf(fgcc, "p%d", i)
			})
		fmt.Fprint(fgcc, ");\n")
		fmt.Fprint(fgcc, "}\n")

		// Dummy declaration for _cgo_main.c
		fmt.Fprintf(fm, `char %s[1] __asm__("%s.%s");`, goName, gccgoSymbolPrefix, goName)
		fmt.Fprint(fm, "\n")

		// For gccgo we use a wrapper function in Go, in order
		// to call CgocallBack and CgocallBackDone.

		// This code uses printer.Fprint, not conf.Fprint,
		// because we don't want //line comments in the middle
		// of the function types.
		fmt.Fprint(fgo2, "\n")
		fmt.Fprintf(fgo2, "func %s(", goName)
		if fn.Recv != nil {
			fmt.Fprint(fgo2, "recv ")
			printer.Fprint(fgo2, fset, fn.Recv.List[0].Type)
		}
		forFieldList(fntype.Params,
			func(i int, aname string, atype ast.Expr) {
				if i > 0 || fn.Recv != nil {
					fmt.Fprintf(fgo2, ", ")
				}
				fmt.Fprintf(fgo2, "p%d ", i)
				printer.Fprint(fgo2, fset, atype)
			})
		fmt.Fprintf(fgo2, ")")
		if resultCount > 0 {
			fmt.Fprintf(fgo2, " (")
			forFieldList(fntype.Results,
				func(i int, aname string, atype ast.Expr) {
					if i > 0 {
						fmt.Fprint(fgo2, ", ")
					}
					printer.Fprint(fgo2, fset, atype)
				})
			fmt.Fprint(fgo2, ")")
		}
		fmt.Fprint(fgo2, " {\n")
		fmt.Fprint(fgo2, "\tsyscall.CgocallBack()\n")
		fmt.Fprint(fgo2, "\tdefer syscall.CgocallBackDone()\n")
		fmt.Fprint(fgo2, "\t")
		if resultCount > 0 {
			fmt.Fprint(fgo2, "return ")
		}
		if fn.Recv != nil {
			fmt.Fprint(fgo2, "recv.")
		}
		fmt.Fprintf(fgo2, "%s(", exp.Func.Name)
		forFieldList(fntype.Params,
			func(i int, aname string, atype ast.Expr) {
				if i > 0 {
					fmt.Fprint(fgo2, ", ")
				}
				fmt.Fprintf(fgo2, "p%d", i)
			})
		fmt.Fprint(fgo2, ")\n")
		fmt.Fprint(fgo2, "}\n")
	}

	fmt.Fprintf(fgcch, "%s", gccExportHeaderEpilog)
}

// writeExportHeader writes out the start of the _cgo_export.h file.
func (p *Package) writeExportHeader(fgcch io.Writer) {
	fmt.Fprintf(fgcch, "/* Created by \"go tool cgo\" - DO NOT EDIT. */\n\n")
	pkg := *importPath
	if pkg == "" {
		pkg = p.PackagePath
	}
	fmt.Fprintf(fgcch, "/* package %s */\n\n", pkg)

	fmt.Fprintf(fgcch, "/* Start of preamble from import \"C\" comments.  */\n\n")
	fmt.Fprintf(fgcch, "%s\n", p.Preamble)
	fmt.Fprintf(fgcch, "\n/* End of preamble from import \"C\" comments.  */\n\n")

	fmt.Fprintf(fgcch, "%s\n", p.gccExportHeaderProlog())
}

// Return the package prefix when using gccgo.
func (p *Package) gccgoSymbolPrefix() string {
	if !*gccgo {
		return ""
	}

	clean := func(r rune) rune {
		switch {
		case 'A' <= r && r <= 'Z', 'a' <= r && r <= 'z',
			'0' <= r && r <= '9':
			return r
		}
		return '_'
	}

	if *gccgopkgpath != "" {
		return strings.Map(clean, *gccgopkgpath)
	}
	if *gccgoprefix == "" && p.PackageName == "main" {
		return "main"
	}
	prefix := strings.Map(clean, *gccgoprefix)
	if prefix == "" {
		prefix = "go"
	}
	return prefix + "." + p.PackageName
}

// Call a function for each entry in an ast.FieldList, passing the
// index into the list, the name if any, and the type.
func forFieldList(fl *ast.FieldList, fn func(int, string, ast.Expr)) {
	if fl == nil {
		return
	}
	i := 0
	for _, r := range fl.List {
		if r.Names == nil {
			fn(i, "", r.Type)
			i++
		} else {
			for _, n := range r.Names {
				fn(i, n.Name, r.Type)
				i++
			}
		}
	}
}

func c(repr string, args ...interface{}) *TypeRepr {
	return &TypeRepr{repr, args}
}

// Map predeclared Go types to Type.
var goTypes = map[string]*Type{
	"bool":       {Size: 1, Align: 1, C: c("GoUint8")},
	"byte":       {Size: 1, Align: 1, C: c("GoUint8")},
	"int":        {Size: 0, Align: 0, C: c("GoInt")},
	"uint":       {Size: 0, Align: 0, C: c("GoUint")},
	"rune":       {Size: 4, Align: 4, C: c("GoInt32")},
	"int8":       {Size: 1, Align: 1, C: c("GoInt8")},
	"uint8":      {Size: 1, Align: 1, C: c("GoUint8")},
	"int16":      {Size: 2, Align: 2, C: c("GoInt16")},
	"uint16":     {Size: 2, Align: 2, C: c("GoUint16")},
	"int32":      {Size: 4, Align: 4, C: c("GoInt32")},
	"uint32":     {Size: 4, Align: 4, C: c("GoUint32")},
	"int64":      {Size: 8, Align: 8, C: c("GoInt64")},
	"uint64":     {Size: 8, Align: 8, C: c("GoUint64")},
	"float32":    {Size: 4, Align: 4, C: c("GoFloat32")},
	"float64":    {Size: 8, Align: 8, C: c("GoFloat64")},
	"complex64":  {Size: 8, Align: 8, C: c("GoComplex64")},
	"complex128": {Size: 16, Align: 16, C: c("GoComplex128")},
}

// Map an ast type to a Type.
func (p *Package) cgoType(e ast.Expr) *Type {
	switch t := e.(type) {
	case *ast.StarExpr:
		x := p.cgoType(t.X)
		return &Type{Size: p.PtrSize, Align: p.PtrSize, C: c("%s*", x.C)}
	case *ast.ArrayType:
		if t.Len == nil {
			// Slice: pointer, len, cap.
			return &Type{Size: p.PtrSize * 3, Align: p.PtrSize, C: c("GoSlice")}
		}
	case *ast.StructType:
		// TODO
	case *ast.FuncType:
		return &Type{Size: p.PtrSize, Align: p.PtrSize, C: c("void*")}
	case *ast.InterfaceType:
		return &Type{Size: 2 * p.PtrSize, Align: p.PtrSize, C: c("GoInterface")}
	case *ast.MapType:
		return &Type{Size: p.PtrSize, Align: p.PtrSize, C: c("GoMap")}
	case *ast.ChanType:
		return &Type{Size: p.PtrSize, Align: p.PtrSize, C: c("GoChan")}
	case *ast.Ident:
		// Look up the type in the top level declarations.
		// TODO: Handle types defined within a function.
		for _, d := range p.Decl {
			gd, ok := d.(*ast.GenDecl)
			if !ok || gd.Tok != token.TYPE {
				continue
			}
			for _, spec := range gd.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				if ts.Name.Name == t.Name {
					return p.cgoType(ts.Type)
				}
			}
		}
		if def := typedef[t.Name]; def != nil {
			return def
		}
		if t.Name == "uintptr" {
			return &Type{Size: p.PtrSize, Align: p.PtrSize, C: c("GoUintptr")}
		}
		if t.Name == "string" {
			// The string data is 1 pointer + 1 (pointer-sized) int.
			return &Type{Size: 2 * p.PtrSize, Align: p.PtrSize, C: c("GoString")}
		}
		if t.Name == "error" {
			return &Type{Size: 2 * p.PtrSize, Align: p.PtrSize, C: c("GoInterface")}
		}
		if r, ok := goTypes[t.Name]; ok {
			if r.Size == 0 { // int or uint
				rr := new(Type)
				*rr = *r
				rr.Size = p.IntSize
				rr.Align = p.IntSize
				r = rr
			}
			if r.Align > p.PtrSize {
				r.Align = p.PtrSize
			}
			return r
		}
		error_(e.Pos(), "unrecognized Go type %s", t.Name)
		return &Type{Size: 4, Align: 4, C: c("int")}
	case *ast.SelectorExpr:
		id, ok := t.X.(*ast.Ident)
		if ok && id.Name == "unsafe" && t.Sel.Name == "Pointer" {
			return &Type{Size: p.PtrSize, Align: p.PtrSize, C: c("void*")}
		}
	}
	error_(e.Pos(), "Go type not supported in export: %s", gofmt(e))
	return &Type{Size: 4, Align: 4, C: c("int")}
}

const gccProlog = `
/*
  If x and y are not equal, the type will be invalid
  (have a negative array count) and an inscrutable error will come
  out of the compiler and hopefully mention "name".
*/
#define __cgo_compile_assert_eq(x, y, name) typedef char name[(x-y)*(x-y)*-2+1];

// Check at compile time that the sizes we use match our expectations.
#define __cgo_size_assert(t, n) __cgo_compile_assert_eq(sizeof(t), n, _cgo_sizeof_##t##_is_not_##n)

__cgo_size_assert(char, 1)
__cgo_size_assert(short, 2)
__cgo_size_assert(int, 4)
typedef long long __cgo_long_long;
__cgo_size_assert(__cgo_long_long, 8)
__cgo_size_assert(float, 4)
__cgo_size_assert(double, 8)

extern char* _cgo_topofstack(void);

#include <errno.h>
#include <string.h>
`

const builtinProlog = `
#include <stddef.h> /* for ptrdiff_t and size_t below */

/* Define intgo when compiling with GCC.  */
typedef ptrdiff_t intgo;

typedef struct { char *p; intgo n; } _GoString_;
typedef struct { char *p; intgo n; intgo c; } _GoBytes_;
_GoString_ GoString(char *p);
_GoString_ GoStringN(char *p, int l);
_GoBytes_ GoBytes(void *p, int n);
char *CString(_GoString_);
void *_CMalloc(size_t);
`

const goProlog = `
//go:linkname _cgo_runtime_cgocall runtime.cgocall
func _cgo_runtime_cgocall(unsafe.Pointer, uintptr) int32

//go:linkname _cgo_runtime_cmalloc runtime.cmalloc
func _cgo_runtime_cmalloc(uintptr) unsafe.Pointer

//go:linkname _cgo_runtime_cgocallback runtime.cgocallback
func _cgo_runtime_cgocallback(unsafe.Pointer, unsafe.Pointer, uintptr)

//go:linkname _cgoCheckPointer runtime.cgoCheckPointer
func _cgoCheckPointer(interface{}, ...interface{}) interface{}

//go:linkname _cgoCheckResult runtime.cgoCheckResult
func _cgoCheckResult(interface{})
`

const gccgoGoProlog = `
func _cgoCheckPointer(interface{}, ...interface{}) interface{}

func _cgoCheckResult(interface{})
`

const goStringDef = `
//go:linkname _cgo_runtime_gostring runtime.gostring
func _cgo_runtime_gostring(*_Ctype_char) string

func _Cfunc_GoString(p *_Ctype_char) string {
	return _cgo_runtime_gostring(p)
}
`

const goStringNDef = `
//go:linkname _cgo_runtime_gostringn runtime.gostringn
func _cgo_runtime_gostringn(*_Ctype_char, int) string

func _Cfunc_GoStringN(p *_Ctype_char, l _Ctype_int) string {
	return _cgo_runtime_gostringn(p, int(l))
}
`

const goBytesDef = `
//go:linkname _cgo_runtime_gobytes runtime.gobytes
func _cgo_runtime_gobytes(unsafe.Pointer, int) []byte

func _Cfunc_GoBytes(p unsafe.Pointer, l _Ctype_int) []byte {
	return _cgo_runtime_gobytes(p, int(l))
}
`

const cStringDef = `
func _Cfunc_CString(s string) *_Ctype_char {
	p := _cgo_runtime_cmalloc(uintptr(len(s)+1))
	pp := (*[1<<30]byte)(p)
	copy(pp[:], s)
	pp[len(s)] = 0
	return (*_Ctype_char)(p)
}
`

const cMallocDef = `
func _Cfunc__CMalloc(n _Ctype_size_t) unsafe.Pointer {
	return _cgo_runtime_cmalloc(uintptr(n))
}
`

var builtinDefs = map[string]string{
	"GoString":  goStringDef,
	"GoStringN": goStringNDef,
	"GoBytes":   goBytesDef,
	"CString":   cStringDef,
	"_CMalloc":  cMallocDef,
}

func (p *Package) cPrologGccgo() string {
	return strings.Replace(strings.Replace(cPrologGccgo, "PREFIX", cPrefix, -1),
		"GCCGOSYMBOLPREF", p.gccgoSymbolPrefix(), -1)
}

const cPrologGccgo = `
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

typedef unsigned char byte;
typedef intptr_t intgo;

struct __go_string {
	const unsigned char *__data;
	intgo __length;
};

typedef struct __go_open_array {
	void* __values;
	intgo __count;
	intgo __capacity;
} Slice;

struct __go_string __go_byte_array_to_string(const void* p, intgo len);
struct __go_open_array __go_string_to_byte_array (struct __go_string str);

const char *_cgoPREFIX_Cfunc_CString(struct __go_string s) {
	char *p = malloc(s.__length+1);
	memmove(p, s.__data, s.__length);
	p[s.__length] = 0;
	return p;
}

struct __go_string _cgoPREFIX_Cfunc_GoString(char *p) {
	intgo len = (p != NULL) ? strlen(p) : 0;
	return __go_byte_array_to_string(p, len);
}

struct __go_string _cgoPREFIX_Cfunc_GoStringN(char *p, int32_t n) {
	return __go_byte_array_to_string(p, n);
}

Slice _cgoPREFIX_Cfunc_GoBytes(char *p, int32_t n) {
	struct __go_string s = { (const unsigned char *)p, n };
	return __go_string_to_byte_array(s);
}

extern void runtime_throw(const char *);
void *_cgoPREFIX_Cfunc__CMalloc(size_t n) {
        void *p = malloc(n);
        if(p == NULL && n == 0)
                p = malloc(1);
        if(p == NULL)
                runtime_throw("runtime: C malloc failed");
        return p;
}

struct __go_type_descriptor;
typedef struct __go_empty_interface {
	const struct __go_type_descriptor *__type_descriptor;
	void *__object;
} Eface;

extern Eface runtimeCgoCheckPointer(Eface, Slice)
	__asm__("runtime.cgoCheckPointer")
	__attribute__((weak));

extern Eface localCgoCheckPointer(Eface, Slice)
	__asm__("GCCGOSYMBOLPREF._cgoCheckPointer");

Eface localCgoCheckPointer(Eface ptr, Slice args) {
	if(runtimeCgoCheckPointer) {
		return runtimeCgoCheckPointer(ptr, args);
	}
	return ptr;
}

extern void runtimeCgoCheckResult(Eface)
	__asm__("runtime.cgoCheckResult")
	__attribute__((weak));

extern void localCgoCheckResult(Eface)
	__asm__("GCCGOSYMBOLPREF._cgoCheckResult");

void localCgoCheckResult(Eface val) {
	if(runtimeCgoCheckResult) {
		runtimeCgoCheckResult(val);
	}
}
`

func (p *Package) gccExportHeaderProlog() string {
	return strings.Replace(gccExportHeaderProlog, "GOINTBITS", fmt.Sprint(8*p.IntSize), -1)
}

const gccExportHeaderProlog = `
/* Start of boilerplate cgo prologue.  */

#ifndef GO_CGO_PROLOGUE_H
#define GO_CGO_PROLOGUE_H

typedef signed char GoInt8;
typedef unsigned char GoUint8;
typedef short GoInt16;
typedef unsigned short GoUint16;
typedef int GoInt32;
typedef unsigned int GoUint32;
typedef long long GoInt64;
typedef unsigned long long GoUint64;
typedef GoIntGOINTBITS GoInt;
typedef GoUintGOINTBITS GoUint;
typedef __SIZE_TYPE__ GoUintptr;
typedef float GoFloat32;
typedef double GoFloat64;
typedef float _Complex GoComplex64;
typedef double _Complex GoComplex128;

/*
  static assertion to make sure the file is being used on architecture
  at least with matching size of GoInt.
*/
typedef char _check_for_GOINTBITS_bit_pointer_matching_GoInt[sizeof(void*)==GOINTBITS/8 ? 1:-1];

typedef struct { const char *p; GoInt n; } GoString;
typedef void *GoMap;
typedef void *GoChan;
typedef struct { void *t; void *v; } GoInterface;
typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;

#endif

/* End of boilerplate cgo prologue.  */

#ifdef __cplusplus
extern "C" {
#endif
`

// gccExportHeaderEpilog goes at the end of the generated header file.
const gccExportHeaderEpilog = `
#ifdef __cplusplus
}
#endif
`

// gccgoExportFileProlog is written to the _cgo_export.c file when
// using gccgo.
// We use weak declarations, and test the addresses, so that this code
// works with older versions of gccgo.
const gccgoExportFileProlog = `
extern _Bool runtime_iscgo __attribute__ ((weak));

static void GoInit(void) __attribute__ ((constructor));
static void GoInit(void) {
	if(&runtime_iscgo)
		runtime_iscgo = 1;
}

extern void _cgo_wait_runtime_init_done() __attribute__ ((weak));
`
                                                                                                                                                                                                                                           usr/local/go/src/cmd/cgo/util.go                                                                    0100644 0000000 0000000 00000003576 13020111411 015156  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"fmt"
	"go/token"
	"os"
	"os/exec"
)

// run runs the command argv, feeding in stdin on standard input.
// It returns the output to standard output and standard error.
// ok indicates whether the command exited successfully.
func run(stdin []byte, argv []string) (stdout, stderr []byte, ok bool) {
	p := exec.Command(argv[0], argv[1:]...)
	p.Stdin = bytes.NewReader(stdin)
	var bout, berr bytes.Buffer
	p.Stdout = &bout
	p.Stderr = &berr
	err := p.Run()
	if _, ok := err.(*exec.ExitError); err != nil && !ok {
		fatalf("%s", err)
	}
	ok = p.ProcessState.Success()
	stdout, stderr = bout.Bytes(), berr.Bytes()
	return
}

func lineno(pos token.Pos) string {
	return fset.Position(pos).String()
}

// Die with an error message.
func fatalf(msg string, args ...interface{}) {
	// If we've already printed other errors, they might have
	// caused the fatal condition.  Assume they're enough.
	if nerrors == 0 {
		fmt.Fprintf(os.Stderr, msg+"\n", args...)
	}
	os.Exit(2)
}

var nerrors int

func error_(pos token.Pos, msg string, args ...interface{}) {
	nerrors++
	if pos.IsValid() {
		fmt.Fprintf(os.Stderr, "%s: ", fset.Position(pos).String())
	}
	fmt.Fprintf(os.Stderr, msg, args...)
	fmt.Fprintf(os.Stderr, "\n")
}

// isName reports whether s is a valid C identifier
func isName(s string) bool {
	for i, v := range s {
		if v != '_' && (v < 'A' || v > 'Z') && (v < 'a' || v > 'z') && (v < '0' || v > '9') {
			return false
		}
		if i == 0 && '0' <= v && v <= '9' {
			return false
		}
	}
	return s != ""
}

func creat(name string) *os.File {
	f, err := os.Create(name)
	if err != nil {
		fatalf("%s", err)
	}
	return f
}

func slashToUnderscore(c rune) rune {
	if c == '/' || c == '\\' || c == ':' {
		c = '_'
	}
	return c
}
                                                                                                                                  usr/local/go/src/cmd/cgo/zdefaultcc.go                                                              0100644 0000000 0000000 00000000142 13101127300 016313  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // auto generated by go tool dist

package main

const defaultCC = `gcc`
const defaultCXX = `g++`
                                                                                                                                                                                                                                                                                                                                                                                                                              usr/local/go/src/cmd/compile/                                                                       0040755 0000000 0000000 00000000000 13020111411 014522  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/cmd/compile/doc.go                                                                 0100644 0000000 0000000 00000012111 13020111411 015607  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

/*
Compile, typically invoked as ``go tool compile,'' compiles a single Go package
comprising the files named on the command line. It then writes a single
object file named for the basename of the first source file with a .o suffix.
The object file can then be combined with other objects into a package archive
or passed directly to the linker (``go tool link''). If invoked with -pack, the compiler
writes an archive directly, bypassing the intermediate object file.

The generated files contain type information about the symbols exported by
the package and about types used by symbols imported by the package from
other packages. It is therefore not necessary when compiling client C of
package P to read the files of P's dependencies, only the compiled output of P.

Command Line

Usage:

	go tool compile [flags] file...

The specified files must be Go source files and all part of the same package.
The same compiler is used for all target operating systems and architectures.
The GOOS and GOARCH environment variables set the desired target.

Flags:

	-D path
		Set relative path for local imports.
	-I dir1 -I dir2
		Search for imported packages in dir1, dir2, etc,
		after consulting $GOROOT/pkg/$GOOS_$GOARCH.
	-L
		Show complete file path in error messages.
	-N
		Disable optimizations.
	-S
		Print assembly listing to standard output (code only).
	-S -S
		Print assembly listing to standard output (code and data).
	-V
		Print compiler version and exit.
	-asmhdr file
		Write assembly header to file.
	-complete
		Assume package has no non-Go components.
	-cpuprofile file
		Write a CPU profile for the compilation to file.
	-dynlink
		Allow references to Go symbols in shared libraries (experimental).
	-e
		Remove the limit on the number of errors reported (default limit is 10).
	-h
		Halt with a stack trace at the first error detected.
	-importmap old=new
		Interpret import "old" as import "new" during compilation.
		The option may be repeated to add multiple mappings.
	-installsuffix suffix
		Look for packages in $GOROOT/pkg/$GOOS_$GOARCH_suffix
		instead of $GOROOT/pkg/$GOOS_$GOARCH.
	-largemodel
		Generated code that assumes a large memory model.
	-memprofile file
		Write memory profile for the compilation to file.
	-memprofilerate rate
		Set runtime.MemProfileRate for the compilation to rate.
	-msan
		Insert calls to C/C++ memory sanitizer.
	-nolocalimports
		Disallow local (relative) imports.
	-o file
		Write object to file (default file.o or, with -pack, file.a).
	-p path
		Set expected package import path for the code being compiled,
		and diagnose imports that would cause a circular dependency.
	-pack
		Write a package (archive) file rather than an object file
	-race
		Compile with race detector enabled.
	-trimpath prefix
		Remove prefix from recorded source file paths.
	-u
		Disallow importing packages not marked as safe; implies -nolocalimports.

There are also a number of debugging flags; run the command with no arguments
for a usage message.

Compiler Directives

The compiler accepts compiler directives in the form of // comments at the
beginning of a line. To distinguish them from non-directive comments, the directives
require no space between the slashes and the name of the directive. However, since
they are comments, tools unaware of the directive convention or of a particular
directive can skip over a directive like any other comment.

	//line path/to/file:linenumber

The //line directive specifies that the source line that follows should be recorded
as having come from the given file path and line number. Successive lines are
recorded using increasing line numbers, until the next directive. This directive
typically appears in machine-generated code, so that compilers and debuggers
will show lines in the original input to the generator.

The //line directive is an historical special case; all other directives are of the form
//go:name, indicating that the directive is defined by the Go toolchain.

	//go:noescape

The //go:noescape directive specifies that the next declaration in the file, which
must be a func without a body (meaning that it has an implementation not written
in Go) does not allow any of the pointers passed as arguments to escape into the
heap or into the values returned from the function. This information can be used
during the compiler's escape analysis of Go code calling the function.

	//go:nosplit

The //go:nosplit directive specifies that the next function declared in the file must
not include a stack overflow check. This is most commonly used by low-level
runtime sources invoked at times when it is unsafe for the calling goroutine to be
preempted.

	//go:linkname localname importpath.name

The //go:linkname directive instructs the compiler to use ``importpath.name'' as the
object file symbol name for the variable or function declared as ``localname'' in the
source code. Because this directive can subvert the type system and package
modularity, it is only enabled in files that have imported "unsafe".
*/
package main
                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/local/go/src/cmd/compile/internal/                                                              0040755 0000000 0000000 00000000000 13020111411 016336  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/cmd/compile/internal/amd64/                                                        0040755 0000000 0000000 00000000000 13020111411 017251  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/cmd/compile/internal/amd64/cgen.go                                                 0100644 0000000 0000000 00000007403 13020111411 020515  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package amd64

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/x86"
)

func blockcopy(n, ns *gc.Node, osrc, odst, w int64) {
	var noddi gc.Node
	gc.Nodreg(&noddi, gc.Types[gc.Tptr], x86.REG_DI)
	var nodsi gc.Node
	gc.Nodreg(&nodsi, gc.Types[gc.Tptr], x86.REG_SI)

	var nodl gc.Node
	var nodr gc.Node
	if n.Ullman >= ns.Ullman {
		gc.Agenr(n, &nodr, &nodsi)
		if ns.Op == gc.ONAME {
			gc.Gvardef(ns)
		}
		gc.Agenr(ns, &nodl, &noddi)
	} else {
		if ns.Op == gc.ONAME {
			gc.Gvardef(ns)
		}
		gc.Agenr(ns, &nodl, &noddi)
		gc.Agenr(n, &nodr, &nodsi)
	}

	if nodl.Reg != x86.REG_DI {
		gmove(&nodl, &noddi)
	}
	if nodr.Reg != x86.REG_SI {
		gmove(&nodr, &nodsi)
	}
	gc.Regfree(&nodl)
	gc.Regfree(&nodr)

	c := w % 8 // bytes
	q := w / 8 // quads

	var oldcx gc.Node
	var cx gc.Node
	savex(x86.REG_CX, &cx, &oldcx, nil, gc.Types[gc.TINT64])

	// if we are copying forward on the stack and
	// the src and dst overlap, then reverse direction
	if osrc < odst && odst < osrc+w {
		// reverse direction
		gins(x86.ASTD, nil, nil) // set direction flag
		if c > 0 {
			gconreg(addptr, w-1, x86.REG_SI)
			gconreg(addptr, w-1, x86.REG_DI)

			gconreg(movptr, c, x86.REG_CX)
			gins(x86.AREP, nil, nil)   // repeat
			gins(x86.AMOVSB, nil, nil) // MOVB *(SI)-,*(DI)-
		}

		if q > 0 {
			if c > 0 {
				gconreg(addptr, -7, x86.REG_SI)
				gconreg(addptr, -7, x86.REG_DI)
			} else {
				gconreg(addptr, w-8, x86.REG_SI)
				gconreg(addptr, w-8, x86.REG_DI)
			}

			gconreg(movptr, q, x86.REG_CX)
			gins(x86.AREP, nil, nil)   // repeat
			gins(x86.AMOVSQ, nil, nil) // MOVQ *(SI)-,*(DI)-
		}

		// we leave with the flag clear
		gins(x86.ACLD, nil, nil)
	} else {
		// normal direction
		if q > 128 || (gc.Nacl && q >= 4) || (obj.Getgoos() == "plan9" && q >= 4) {
			gconreg(movptr, q, x86.REG_CX)
			gins(x86.AREP, nil, nil)   // repeat
			gins(x86.AMOVSQ, nil, nil) // MOVQ *(SI)+,*(DI)+
		} else if q >= 4 {
			var oldx0 gc.Node
			var x0 gc.Node
			savex(x86.REG_X0, &x0, &oldx0, nil, gc.Types[gc.TFLOAT64])

			p := gins(obj.ADUFFCOPY, nil, nil)
			p.To.Type = obj.TYPE_ADDR
			p.To.Sym = gc.Linksym(gc.Pkglookup("duffcopy", gc.Runtimepkg))

			// 64 blocks taking 14 bytes each
			// see ../../../../runtime/mkduff.go
			p.To.Offset = 14 * (64 - q/2)
			restx(&x0, &oldx0)

			if q%2 != 0 {
				gins(x86.AMOVSQ, nil, nil) // MOVQ *(SI)+,*(DI)+
			}
		} else if !gc.Nacl && c == 0 {
			// We don't need the MOVSQ side-effect of updating SI and DI,
			// and issuing a sequence of MOVQs directly is faster.
			nodsi.Op = gc.OINDREG

			noddi.Op = gc.OINDREG
			for q > 0 {
				gmove(&nodsi, &cx) // MOVQ x+(SI),CX
				gmove(&cx, &noddi) // MOVQ CX,x+(DI)
				nodsi.Xoffset += 8
				noddi.Xoffset += 8
				q--
			}
		} else {
			for q > 0 {
				gins(x86.AMOVSQ, nil, nil) // MOVQ *(SI)+,*(DI)+
				q--
			}
		}

		// copy the remaining c bytes
		if w < 4 || c <= 1 || (odst < osrc && osrc < odst+w) {
			for c > 0 {
				gins(x86.AMOVSB, nil, nil) // MOVB *(SI)+,*(DI)+
				c--
			}
		} else if w < 8 || c <= 4 {
			nodsi.Op = gc.OINDREG
			noddi.Op = gc.OINDREG
			cx.Type = gc.Types[gc.TINT32]
			nodsi.Type = gc.Types[gc.TINT32]
			noddi.Type = gc.Types[gc.TINT32]
			if c > 4 {
				nodsi.Xoffset = 0
				noddi.Xoffset = 0
				gmove(&nodsi, &cx)
				gmove(&cx, &noddi)
			}

			nodsi.Xoffset = c - 4
			noddi.Xoffset = c - 4
			gmove(&nodsi, &cx)
			gmove(&cx, &noddi)
		} else {
			nodsi.Op = gc.OINDREG
			noddi.Op = gc.OINDREG
			cx.Type = gc.Types[gc.TINT64]
			nodsi.Type = gc.Types[gc.TINT64]
			noddi.Type = gc.Types[gc.TINT64]
			nodsi.Xoffset = c - 8
			noddi.Xoffset = c - 8
			gmove(&nodsi, &cx)
			gmove(&cx, &noddi)
		}
	}

	restx(&cx, &oldcx)
}
                                                                                                                                                                                                                                                             usr/local/go/src/cmd/compile/internal/amd64/galign.go                                               0100644 0000000 0000000 00000006142 13020111411 021041  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package amd64

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/x86"
)

var (
	thechar     int           = '6'
	thestring   string        = "amd64"
	thelinkarch *obj.LinkArch = &x86.Linkamd64
)

func linkarchinit() {
	if obj.Getgoarch() == "amd64p32" {
		thelinkarch = &x86.Linkamd64p32
		gc.Thearch.Thelinkarch = thelinkarch
		thestring = "amd64p32"
		gc.Thearch.Thestring = "amd64p32"
	}
}

var MAXWIDTH int64 = 1 << 50

var (
	addptr int = x86.AADDQ
	movptr int = x86.AMOVQ
	leaptr int = x86.ALEAQ
	cmpptr int = x86.ACMPQ
)

/*
 * go declares several platform-specific type aliases:
 * int, uint, and uintptr
 */
var typedefs = []gc.Typedef{
	{"int", gc.TINT, gc.TINT64},
	{"uint", gc.TUINT, gc.TUINT64},
	{"uintptr", gc.TUINTPTR, gc.TUINT64},
}

func betypeinit() {
	gc.Widthptr = 8
	gc.Widthint = 8
	gc.Widthreg = 8
	if obj.Getgoarch() == "amd64p32" {
		gc.Widthptr = 4
		gc.Widthint = 4
		addptr = x86.AADDL
		movptr = x86.AMOVL
		leaptr = x86.ALEAL
		cmpptr = x86.ACMPL
		typedefs[0].Sameas = gc.TINT32
		typedefs[1].Sameas = gc.TUINT32
		typedefs[2].Sameas = gc.TUINT32
	}

	if gc.Ctxt.Flag_dynlink {
		gc.Thearch.ReservedRegs = append(gc.Thearch.ReservedRegs, x86.REG_R15)
	}
}

func Main() {
	if obj.Getgoos() == "nacl" {
		resvd = append(resvd, x86.REG_BP, x86.REG_R15)
	} else if obj.Framepointer_enabled != 0 {
		resvd = append(resvd, x86.REG_BP)
	}

	gc.Thearch.Thechar = thechar
	gc.Thearch.Thestring = thestring
	gc.Thearch.Thelinkarch = thelinkarch
	gc.Thearch.Typedefs = typedefs
	gc.Thearch.REGSP = x86.REGSP
	gc.Thearch.REGCTXT = x86.REGCTXT
	gc.Thearch.REGCALLX = x86.REG_BX
	gc.Thearch.REGCALLX2 = x86.REG_AX
	gc.Thearch.REGRETURN = x86.REG_AX
	gc.Thearch.REGMIN = x86.REG_AX
	gc.Thearch.REGMAX = x86.REG_R15
	gc.Thearch.FREGMIN = x86.REG_X0
	gc.Thearch.FREGMAX = x86.REG_X15
	gc.Thearch.MAXWIDTH = MAXWIDTH
	gc.Thearch.ReservedRegs = resvd

	gc.Thearch.AddIndex = addindex
	gc.Thearch.Betypeinit = betypeinit
	gc.Thearch.Cgen_bmul = cgen_bmul
	gc.Thearch.Cgen_hmul = cgen_hmul
	gc.Thearch.Cgen_shift = cgen_shift
	gc.Thearch.Clearfat = clearfat
	gc.Thearch.Defframe = defframe
	gc.Thearch.Dodiv = dodiv
	gc.Thearch.Excise = excise
	gc.Thearch.Expandchecks = expandchecks
	gc.Thearch.Getg = getg
	gc.Thearch.Gins = gins
	gc.Thearch.Ginsboolval = ginsboolval
	gc.Thearch.Ginscmp = ginscmp
	gc.Thearch.Ginscon = ginscon
	gc.Thearch.Ginsnop = ginsnop
	gc.Thearch.Gmove = gmove
	gc.Thearch.Linkarchinit = linkarchinit
	gc.Thearch.Peep = peep
	gc.Thearch.Proginfo = proginfo
	gc.Thearch.Regtyp = regtyp
	gc.Thearch.Sameaddr = sameaddr
	gc.Thearch.Smallindir = smallindir
	gc.Thearch.Stackaddr = stackaddr
	gc.Thearch.Blockcopy = blockcopy
	gc.Thearch.Sudoaddable = sudoaddable
	gc.Thearch.Sudoclean = sudoclean
	gc.Thearch.Excludedregs = excludedregs
	gc.Thearch.RtoB = RtoB
	gc.Thearch.FtoB = FtoB
	gc.Thearch.BtoR = BtoR
	gc.Thearch.BtoF = BtoF
	gc.Thearch.Optoas = optoas
	gc.Thearch.Doregbits = doregbits
	gc.Thearch.Regnames = regnames

	gc.Main()
	gc.Exit(0)
}
                                                                                                                                                                                                                                                                                                                                                                                                                              usr/local/go/src/cmd/compile/internal/amd64/ggen.go                                                 0100644 0000000 0000000 00000043376 13020111411 020532  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package amd64

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/x86"
)

func defframe(ptxt *obj.Prog) {
	var n *gc.Node

	// fill in argument size, stack size
	ptxt.To.Type = obj.TYPE_TEXTSIZE

	ptxt.To.Val = int32(gc.Rnd(gc.Curfn.Type.Argwid, int64(gc.Widthptr)))
	frame := uint32(gc.Rnd(gc.Stksize+gc.Maxarg, int64(gc.Widthreg)))
	ptxt.To.Offset = int64(frame)

	// insert code to zero ambiguously live variables
	// so that the garbage collector only sees initialized values
	// when it looks for pointers.
	p := ptxt

	hi := int64(0)
	lo := hi
	ax := uint32(0)
	x0 := uint32(0)

	// iterate through declarations - they are sorted in decreasing xoffset order.
	for l := gc.Curfn.Func.Dcl; l != nil; l = l.Next {
		n = l.N
		if !n.Name.Needzero {
			continue
		}
		if n.Class != gc.PAUTO {
			gc.Fatalf("needzero class %d", n.Class)
		}
		if n.Type.Width%int64(gc.Widthptr) != 0 || n.Xoffset%int64(gc.Widthptr) != 0 || n.Type.Width == 0 {
			gc.Fatalf("var %v has size %d offset %d", gc.Nconv(n, obj.FmtLong), int(n.Type.Width), int(n.Xoffset))
		}

		if lo != hi && n.Xoffset+n.Type.Width >= lo-int64(2*gc.Widthreg) {
			// merge with range we already have
			lo = n.Xoffset

			continue
		}

		// zero old range
		p = zerorange(p, int64(frame), lo, hi, &ax, &x0)

		// set new range
		hi = n.Xoffset + n.Type.Width

		lo = n.Xoffset
	}

	// zero final range
	zerorange(p, int64(frame), lo, hi, &ax, &x0)
}

// DUFFZERO consists of repeated blocks of 4 MOVUPSs + ADD,
// See runtime/mkduff.go.
const (
	dzBlocks    = 16 // number of MOV/ADD blocks
	dzBlockLen  = 4  // number of clears per block
	dzBlockSize = 19 // size of instructions in a single block
	dzMovSize   = 4  // size of single MOV instruction w/ offset
	dzAddSize   = 4  // size of single ADD instruction
	dzClearStep = 16 // number of bytes cleared by each MOV instruction

	dzClearLen = dzClearStep * dzBlockLen // bytes cleared by one block
	dzSize     = dzBlocks * dzBlockSize
)

// dzOff returns the offset for a jump into DUFFZERO.
// b is the number of bytes to zero.
func dzOff(b int64) int64 {
	off := int64(dzSize)
	off -= b / dzClearLen * dzBlockSize
	tailLen := b % dzClearLen
	if tailLen >= dzClearStep {
		off -= dzAddSize + dzMovSize*(tailLen/dzClearStep)
	}
	return off
}

// duffzeroDI returns the pre-adjustment to DI for a call to DUFFZERO.
// b is the number of bytes to zero.
func dzDI(b int64) int64 {
	tailLen := b % dzClearLen
	if tailLen < dzClearStep {
		return 0
	}
	tailSteps := tailLen / dzClearStep
	return -dzClearStep * (dzBlockLen - tailSteps)
}

func zerorange(p *obj.Prog, frame int64, lo int64, hi int64, ax *uint32, x0 *uint32) *obj.Prog {
	cnt := hi - lo
	if cnt == 0 {
		return p
	}

	if cnt%int64(gc.Widthreg) != 0 {
		// should only happen with nacl
		if cnt%int64(gc.Widthptr) != 0 {
			gc.Fatalf("zerorange count not a multiple of widthptr %d", cnt)
		}
		if *ax == 0 {
			p = appendpp(p, x86.AMOVQ, obj.TYPE_CONST, 0, 0, obj.TYPE_REG, x86.REG_AX, 0)
			*ax = 1
		}
		p = appendpp(p, x86.AMOVL, obj.TYPE_REG, x86.REG_AX, 0, obj.TYPE_MEM, x86.REG_SP, frame+lo)
		lo += int64(gc.Widthptr)
		cnt -= int64(gc.Widthptr)
	}

	if cnt == 8 {
		if *ax == 0 {
			p = appendpp(p, x86.AMOVQ, obj.TYPE_CONST, 0, 0, obj.TYPE_REG, x86.REG_AX, 0)
			*ax = 1
		}
		p = appendpp(p, x86.AMOVQ, obj.TYPE_REG, x86.REG_AX, 0, obj.TYPE_MEM, x86.REG_SP, frame+lo)
	} else if cnt <= int64(8*gc.Widthreg) {
		if *x0 == 0 {
			p = appendpp(p, x86.AXORPS, obj.TYPE_REG, x86.REG_X0, 0, obj.TYPE_REG, x86.REG_X0, 0)
			*x0 = 1
		}

		for i := int64(0); i < cnt/16; i++ {
			p = appendpp(p, x86.AMOVUPS, obj.TYPE_REG, x86.REG_X0, 0, obj.TYPE_MEM, x86.REG_SP, frame+lo+i*16)
		}

		if cnt%16 != 0 {
			p = appendpp(p, x86.AMOVUPS, obj.TYPE_REG, x86.REG_X0, 0, obj.TYPE_MEM, x86.REG_SP, frame+lo+cnt-int64(16))
		}
	} else if !gc.Nacl && (cnt <= int64(128*gc.Widthreg)) {
		if *x0 == 0 {
			p = appendpp(p, x86.AXORPS, obj.TYPE_REG, x86.REG_X0, 0, obj.TYPE_REG, x86.REG_X0, 0)
			*x0 = 1
		}

		p = appendpp(p, leaptr, obj.TYPE_MEM, x86.REG_SP, frame+lo+dzDI(cnt), obj.TYPE_REG, x86.REG_DI, 0)
		p = appendpp(p, obj.ADUFFZERO, obj.TYPE_NONE, 0, 0, obj.TYPE_ADDR, 0, dzOff(cnt))
		p.To.Sym = gc.Linksym(gc.Pkglookup("duffzero", gc.Runtimepkg))

		if cnt%16 != 0 {
			p = appendpp(p, x86.AMOVUPS, obj.TYPE_REG, x86.REG_X0, 0, obj.TYPE_MEM, x86.REG_DI, -int64(8))
		}
	} else {
		if *ax == 0 {
			p = appendpp(p, x86.AMOVQ, obj.TYPE_CONST, 0, 0, obj.TYPE_REG, x86.REG_AX, 0)
			*ax = 1
		}

		p = appendpp(p, x86.AMOVQ, obj.TYPE_CONST, 0, cnt/int64(gc.Widthreg), obj.TYPE_REG, x86.REG_CX, 0)
		p = appendpp(p, leaptr, obj.TYPE_MEM, x86.REG_SP, frame+lo, obj.TYPE_REG, x86.REG_DI, 0)
		p = appendpp(p, x86.AREP, obj.TYPE_NONE, 0, 0, obj.TYPE_NONE, 0, 0)
		p = appendpp(p, x86.ASTOSQ, obj.TYPE_NONE, 0, 0, obj.TYPE_NONE, 0, 0)
	}

	return p
}

func appendpp(p *obj.Prog, as int, ftype int, freg int, foffset int64, ttype int, treg int, toffset int64) *obj.Prog {
	q := gc.Ctxt.NewProg()
	gc.Clearp(q)
	q.As = int16(as)
	q.Lineno = p.Lineno
	q.From.Type = int16(ftype)
	q.From.Reg = int16(freg)
	q.From.Offset = foffset
	q.To.Type = int16(ttype)
	q.To.Reg = int16(treg)
	q.To.Offset = toffset
	q.Link = p.Link
	p.Link = q
	return q
}

var panicdiv *gc.Node

/*
 * generate division.
 * generates one of:
 *	res = nl / nr
 *	res = nl % nr
 * according to op.
 */
func dodiv(op gc.Op, nl *gc.Node, nr *gc.Node, res *gc.Node) {
	// Have to be careful about handling
	// most negative int divided by -1 correctly.
	// The hardware will trap.
	// Also the byte divide instruction needs AH,
	// which we otherwise don't have to deal with.
	// Easiest way to avoid for int8, int16: use int32.
	// For int32 and int64, use explicit test.
	// Could use int64 hw for int32.
	t := nl.Type

	t0 := t
	check := false
	if gc.Issigned[t.Etype] {
		check = true
		if gc.Isconst(nl, gc.CTINT) && nl.Int() != -(1<<uint64(t.Width*8-1)) {
			check = false
		} else if gc.Isconst(nr, gc.CTINT) && nr.Int() != -1 {
			check = false
		}
	}

	if t.Width < 4 {
		if gc.Issigned[t.Etype] {
			t = gc.Types[gc.TINT32]
		} else {
			t = gc.Types[gc.TUINT32]
		}
		check = false
	}

	a := optoas(op, t)

	var n3 gc.Node
	gc.Regalloc(&n3, t0, nil)
	var ax gc.Node
	var oldax gc.Node
	if nl.Ullman >= nr.Ullman {
		savex(x86.REG_AX, &ax, &oldax, res, t0)
		gc.Cgen(nl, &ax)
		gc.Regalloc(&ax, t0, &ax) // mark ax live during cgen
		gc.Cgen(nr, &n3)
		gc.Regfree(&ax)
	} else {
		gc.Cgen(nr, &n3)
		savex(x86.REG_AX, &ax, &oldax, res, t0)
		gc.Cgen(nl, &ax)
	}

	if t != t0 {
		// Convert
		ax1 := ax

		n31 := n3
		ax.Type = t
		n3.Type = t
		gmove(&ax1, &ax)
		gmove(&n31, &n3)
	}

	var n4 gc.Node
	if gc.Nacl {
		// Native Client does not relay the divide-by-zero trap
		// to the executing program, so we must insert a check
		// for ourselves.
		gc.Nodconst(&n4, t, 0)

		gins(optoas(gc.OCMP, t), &n3, &n4)
		p1 := gc.Gbranch(optoas(gc.ONE, t), nil, +1)
		if panicdiv == nil {
			panicdiv = gc.Sysfunc("panicdivide")
		}
		gc.Ginscall(panicdiv, -1)
		gc.Patch(p1, gc.Pc)
	}

	var p2 *obj.Prog
	if check {
		gc.Nodconst(&n4, t, -1)
		gins(optoas(gc.OCMP, t), &n3, &n4)
		p1 := gc.Gbranch(optoas(gc.ONE, t), nil, +1)
		if op == gc.ODIV {
			// a / (-1) is -a.
			gins(optoas(gc.OMINUS, t), nil, &ax)

			gmove(&ax, res)
		} else {
			// a % (-1) is 0.
			gc.Nodconst(&n4, t, 0)

			gmove(&n4, res)
		}

		p2 = gc.Gbranch(obj.AJMP, nil, 0)
		gc.Patch(p1, gc.Pc)
	}

	var olddx gc.Node
	var dx gc.Node
	savex(x86.REG_DX, &dx, &olddx, res, t)
	if !gc.Issigned[t.Etype] {
		gc.Nodconst(&n4, t, 0)
		gmove(&n4, &dx)
	} else {
		gins(optoas(gc.OEXTEND, t), nil, nil)
	}
	gins(a, &n3, nil)
	gc.Regfree(&n3)
	if op == gc.ODIV {
		gmove(&ax, res)
	} else {
		gmove(&dx, res)
	}
	restx(&dx, &olddx)
	if check {
		gc.Patch(p2, gc.Pc)
	}
	restx(&ax, &oldax)
}

/*
 * register dr is one of the special ones (AX, CX, DI, SI, etc.).
 * we need to use it.  if it is already allocated as a temporary
 * (r > 1; can only happen if a routine like sgen passed a
 * special as cgen's res and then cgen used regalloc to reuse
 * it as its own temporary), then move it for now to another
 * register.  caller must call restx to move it back.
 * the move is not necessary if dr == res, because res is
 * known to be dead.
 */
func savex(dr int, x *gc.Node, oldx *gc.Node, res *gc.Node, t *gc.Type) {
	r := uint8(gc.GetReg(dr))

	// save current ax and dx if they are live
	// and not the destination
	*oldx = gc.Node{}

	gc.Nodreg(x, t, dr)
	if r > 1 && !gc.Samereg(x, res) {
		gc.Regalloc(oldx, gc.Types[gc.TINT64], nil)
		x.Type = gc.Types[gc.TINT64]
		gmove(x, oldx)
		x.Type = t
		// TODO(marvin): Fix Node.EType type union.
		oldx.Etype = gc.EType(r) // squirrel away old r value
		gc.SetReg(dr, 1)
	}
}

func restx(x *gc.Node, oldx *gc.Node) {
	if oldx.Op != 0 {
		x.Type = gc.Types[gc.TINT64]
		gc.SetReg(int(x.Reg), int(oldx.Etype))
		gmove(oldx, x)
		gc.Regfree(oldx)
	}
}

/*
 * generate high multiply:
 *   res = (nl*nr) >> width
 */
func cgen_hmul(nl *gc.Node, nr *gc.Node, res *gc.Node) {
	t := nl.Type
	a := optoas(gc.OHMUL, t)
	if nl.Ullman < nr.Ullman {
		nl, nr = nr, nl
	}

	var n1 gc.Node
	gc.Cgenr(nl, &n1, res)
	var n2 gc.Node
	gc.Cgenr(nr, &n2, nil)
	var ax, oldax, dx, olddx gc.Node
	savex(x86.REG_AX, &ax, &oldax, res, gc.Types[gc.TUINT64])
	savex(x86.REG_DX, &dx, &olddx, res, gc.Types[gc.TUINT64])
	gmove(&n1, &ax)
	gins(a, &n2, nil)
	gc.Regfree(&n2)
	gc.Regfree(&n1)

	if t.Width == 1 {
		// byte multiply behaves differently.
		var byteAH, byteDX gc.Node
		gc.Nodreg(&byteAH, t, x86.REG_AH)
		gc.Nodreg(&byteDX, t, x86.REG_DX)
		gmove(&byteAH, &byteDX)
	}
	gmove(&dx, res)

	restx(&ax, &oldax)
	restx(&dx, &olddx)
}

/*
 * generate shift according to op, one of:
 *	res = nl << nr
 *	res = nl >> nr
 */
func cgen_shift(op gc.Op, bounded bool, nl *gc.Node, nr *gc.Node, res *gc.Node) {
	a := optoas(op, nl.Type)

	if nr.Op == gc.OLITERAL {
		var n1 gc.Node
		gc.Regalloc(&n1, nl.Type, res)
		gc.Cgen(nl, &n1)
		sc := uint64(nr.Int())
		if sc >= uint64(nl.Type.Width*8) {
			// large shift gets 2 shifts by width-1
			var n3 gc.Node
			gc.Nodconst(&n3, gc.Types[gc.TUINT32], nl.Type.Width*8-1)

			gins(a, &n3, &n1)
			gins(a, &n3, &n1)
		} else {
			gins(a, nr, &n1)
		}
		gmove(&n1, res)
		gc.Regfree(&n1)
		return
	}

	if nl.Ullman >= gc.UINF {
		var n4 gc.Node
		gc.Tempname(&n4, nl.Type)
		gc.Cgen(nl, &n4)
		nl = &n4
	}

	if nr.Ullman >= gc.UINF {
		var n5 gc.Node
		gc.Tempname(&n5, nr.Type)
		gc.Cgen(nr, &n5)
		nr = &n5
	}

	rcx := gc.GetReg(x86.REG_CX)
	var n1 gc.Node
	gc.Nodreg(&n1, gc.Types[gc.TUINT32], x86.REG_CX)

	// Allow either uint32 or uint64 as shift type,
	// to avoid unnecessary conversion from uint32 to uint64
	// just to do the comparison.
	tcount := gc.Types[gc.Simtype[nr.Type.Etype]]

	if tcount.Etype < gc.TUINT32 {
		tcount = gc.Types[gc.TUINT32]
	}

	gc.Regalloc(&n1, nr.Type, &n1) // to hold the shift type in CX
	var n3 gc.Node
	gc.Regalloc(&n3, tcount, &n1) // to clear high bits of CX

	var cx gc.Node
	gc.Nodreg(&cx, gc.Types[gc.TUINT64], x86.REG_CX)

	var oldcx gc.Node
	if rcx > 0 && !gc.Samereg(&cx, res) {
		gc.Regalloc(&oldcx, gc.Types[gc.TUINT64], nil)
		gmove(&cx, &oldcx)
	}

	cx.Type = tcount

	var n2 gc.Node
	if gc.Samereg(&cx, res) {
		gc.Regalloc(&n2, nl.Type, nil)
	} else {
		gc.Regalloc(&n2, nl.Type, res)
	}
	if nl.Ullman >= nr.Ullman {
		gc.Cgen(nl, &n2)
		gc.Cgen(nr, &n1)
		gmove(&n1, &n3)
	} else {
		gc.Cgen(nr, &n1)
		gmove(&n1, &n3)
		gc.Cgen(nl, &n2)
	}

	gc.Regfree(&n3)

	// test and fix up large shifts
	if !bounded {
		gc.Nodconst(&n3, tcount, nl.Type.Width*8)
		gins(optoas(gc.OCMP, tcount), &n1, &n3)
		p1 := gc.Gbranch(optoas(gc.OLT, tcount), nil, +1)
		if op == gc.ORSH && gc.Issigned[nl.Type.Etype] {
			gc.Nodconst(&n3, gc.Types[gc.TUINT32], nl.Type.Width*8-1)
			gins(a, &n3, &n2)
		} else {
			gc.Nodconst(&n3, nl.Type, 0)
			gmove(&n3, &n2)
		}

		gc.Patch(p1, gc.Pc)
	}

	gins(a, &n1, &n2)

	if oldcx.Op != 0 {
		cx.Type = gc.Types[gc.TUINT64]
		gmove(&oldcx, &cx)
		gc.Regfree(&oldcx)
	}

	gmove(&n2, res)

	gc.Regfree(&n1)
	gc.Regfree(&n2)
}

/*
 * generate byte multiply:
 *	res = nl * nr
 * there is no 2-operand byte multiply instruction so
 * we do a full-width multiplication and truncate afterwards.
 */
func cgen_bmul(op gc.Op, nl *gc.Node, nr *gc.Node, res *gc.Node) bool {
	if optoas(op, nl.Type) != x86.AIMULB {
		return false
	}

	// largest ullman on left.
	if nl.Ullman < nr.Ullman {
		nl, nr = nr, nl
	}

	// generate operands in "8-bit" registers.
	var n1b gc.Node
	gc.Regalloc(&n1b, nl.Type, res)

	gc.Cgen(nl, &n1b)
	var n2b gc.Node
	gc.Regalloc(&n2b, nr.Type, nil)
	gc.Cgen(nr, &n2b)

	// perform full-width multiplication.
	t := gc.Types[gc.TUINT64]

	if gc.Issigned[nl.Type.Etype] {
		t = gc.Types[gc.TINT64]
	}
	var n1 gc.Node
	gc.Nodreg(&n1, t, int(n1b.Reg))
	var n2 gc.Node
	gc.Nodreg(&n2, t, int(n2b.Reg))
	a := optoas(op, t)
	gins(a, &n2, &n1)

	// truncate.
	gmove(&n1, res)

	gc.Regfree(&n1b)
	gc.Regfree(&n2b)
	return true
}

func clearfat(nl *gc.Node) {
	/* clear a fat object */
	if gc.Debug['g'] != 0 {
		gc.Dump("\nclearfat", nl)
	}

	// Avoid taking the address for simple enough types.
	if gc.Componentgen(nil, nl) {
		return
	}

	w := nl.Type.Width

	if w > 1024 || (gc.Nacl && w >= 64) {
		var oldn1 gc.Node
		var n1 gc.Node
		savex(x86.REG_DI, &n1, &oldn1, nil, gc.Types[gc.Tptr])
		gc.Agen(nl, &n1)

		var ax gc.Node
		var oldax gc.Node
		savex(x86.REG_AX, &ax, &oldax, nil, gc.Types[gc.Tptr])
		gconreg(x86.AMOVL, 0, x86.REG_AX)
		gconreg(movptr, w/8, x86.REG_CX)

		gins(x86.AREP, nil, nil)   // repeat
		gins(x86.ASTOSQ, nil, nil) // STOQ AL,*(DI)+

		if w%8 != 0 {
			n1.Op = gc.OINDREG
			clearfat_tail(&n1, w%8)
		}

		restx(&n1, &oldn1)
		restx(&ax, &oldax)
		return
	}

	if w >= 64 {
		var oldn1 gc.Node
		var n1 gc.Node
		savex(x86.REG_DI, &n1, &oldn1, nil, gc.Types[gc.Tptr])
		gc.Agen(nl, &n1)

		var vec_zero gc.Node
		var old_x0 gc.Node
		savex(x86.REG_X0, &vec_zero, &old_x0, nil, gc.Types[gc.TFLOAT64])
		gins(x86.AXORPS, &vec_zero, &vec_zero)

		if di := dzDI(w); di != 0 {
			gconreg(addptr, di, x86.REG_DI)
		}
		p := gins(obj.ADUFFZERO, nil, nil)
		p.To.Type = obj.TYPE_ADDR
		p.To.Sym = gc.Linksym(gc.Pkglookup("duffzero", gc.Runtimepkg))
		p.To.Offset = dzOff(w)

		if w%16 != 0 {
			n1.Op = gc.OINDREG
			n1.Xoffset -= 16 - w%16
			gins(x86.AMOVUPS, &vec_zero, &n1)
		}

		restx(&vec_zero, &old_x0)
		restx(&n1, &oldn1)
		return
	}

	// NOTE: Must use agen, not igen, so that optimizer sees address
	// being taken. We are not writing on field boundaries.
	var n1 gc.Node
	gc.Agenr(nl, &n1, nil)
	n1.Op = gc.OINDREG

	clearfat_tail(&n1, w)

	gc.Regfree(&n1)
}

func clearfat_tail(n1 *gc.Node, b int64) {
	if b >= 16 {
		var vec_zero gc.Node
		gc.Regalloc(&vec_zero, gc.Types[gc.TFLOAT64], nil)
		gins(x86.AXORPS, &vec_zero, &vec_zero)

		for b >= 16 {
			gins(x86.AMOVUPS, &vec_zero, n1)
			n1.Xoffset += 16
			b -= 16
		}

		// MOVUPS X0, off(base) is a few bytes shorter than MOV 0, off(base)
		if b != 0 {
			n1.Xoffset -= 16 - b
			gins(x86.AMOVUPS, &vec_zero, n1)
		}

		gc.Regfree(&vec_zero)
		return
	}

	// Write sequence of MOV 0, off(base) instead of using STOSQ.
	// The hope is that although the code will be slightly longer,
	// the MOVs will have no dependencies and pipeline better
	// than the unrolled STOSQ loop.
	var z gc.Node
	gc.Nodconst(&z, gc.Types[gc.TUINT64], 0)
	if b >= 8 {
		n1.Type = z.Type
		gins(x86.AMOVQ, &z, n1)
		n1.Xoffset += 8
		b -= 8

		if b != 0 {
			n1.Xoffset -= 8 - b
			gins(x86.AMOVQ, &z, n1)
		}
		return
	}

	if b >= 4 {
		gc.Nodconst(&z, gc.Types[gc.TUINT32], 0)
		n1.Type = z.Type
		gins(x86.AMOVL, &z, n1)
		n1.Xoffset += 4
		b -= 4

		if b != 0 {
			n1.Xoffset -= 4 - b
			gins(x86.AMOVL, &z, n1)
		}
		return
	}

	if b >= 2 {
		gc.Nodconst(&z, gc.Types[gc.TUINT16], 0)
		n1.Type = z.Type
		gins(x86.AMOVW, &z, n1)
		n1.Xoffset += 2
		b -= 2
	}

	gc.Nodconst(&z, gc.Types[gc.TUINT8], 0)
	for b > 0 {
		n1.Type = z.Type
		gins(x86.AMOVB, &z, n1)
		n1.Xoffset++
		b--
	}

}

// Called after regopt and peep have run.
// Expand CHECKNIL pseudo-op into actual nil pointer check.
func expandchecks(firstp *obj.Prog) {
	var p1 *obj.Prog
	var p2 *obj.Prog

	for p := firstp; p != nil; p = p.Link {
		if p.As != obj.ACHECKNIL {
			continue
		}
		if gc.Debug_checknil != 0 && p.Lineno > 1 { // p->lineno==1 in generated wrappers
			gc.Warnl(int(p.Lineno), "generated nil check")
		}

		// check is
		//	CMP arg, $0
		//	JNE 2(PC) (likely)
		//	MOV AX, 0
		p1 = gc.Ctxt.NewProg()

		p2 = gc.Ctxt.NewProg()
		gc.Clearp(p1)
		gc.Clearp(p2)
		p1.Link = p2
		p2.Link = p.Link
		p.Link = p1
		p1.Lineno = p.Lineno
		p2.Lineno = p.Lineno
		p1.Pc = 9999
		p2.Pc = 9999
		p.As = int16(cmpptr)
		p.To.Type = obj.TYPE_CONST
		p.To.Offset = 0
		p1.As = x86.AJNE
		p1.From.Type = obj.TYPE_CONST
		p1.From.Offset = 1 // likely
		p1.To.Type = obj.TYPE_BRANCH
		p1.To.Val = p2.Link

		// crash by write to memory address 0.
		// if possible, since we know arg is 0, use 0(arg),
		// which will be shorter to encode than plain 0.
		p2.As = x86.AMOVL

		p2.From.Type = obj.TYPE_REG
		p2.From.Reg = x86.REG_AX
		if regtyp(&p.From) {
			p2.To.Type = obj.TYPE_MEM
			p2.To.Reg = p.From.Reg
		} else {
			p2.To.Type = obj.TYPE_MEM
			p2.To.Reg = x86.REG_NONE
		}

		p2.To.Offset = 0
	}
}

// addr += index*width if possible.
func addindex(index *gc.Node, width int64, addr *gc.Node) bool {
	switch width {
	case 1, 2, 4, 8:
		p1 := gins(x86.ALEAQ, index, addr)
		p1.From.Type = obj.TYPE_MEM
		p1.From.Scale = int16(width)
		p1.From.Index = p1.From.Reg
		p1.From.Reg = p1.To.Reg
		return true
	}
	return false
}

// res = runtime.getg()
func getg(res *gc.Node) {
	var n1 gc.Node
	gc.Regalloc(&n1, res.Type, res)
	mov := optoas(gc.OAS, gc.Types[gc.Tptr])
	p := gins(mov, nil, &n1)
	p.From.Type = obj.TYPE_REG
	p.From.Reg = x86.REG_TLS
	p = gins(mov, nil, &n1)
	p.From = p.To
	p.From.Type = obj.TYPE_MEM
	p.From.Index = x86.REG_TLS
	p.From.Scale = 1
	gmove(&n1, res)
	gc.Regfree(&n1)
}
                                                                                                                                                                                                                                                                  usr/local/go/src/cmd/compile/internal/amd64/gsubr.go                                                0100644 0000000 0000000 00000066717 13020111411 020740  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Derived from Inferno utils/6c/txt.c
// http://code.google.com/p/inferno-os/source/browse/utils/6c/txt.c
//
//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright © 1997-1999 Vita Nuova Limited
//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright © 2004,2006 Bruce Ellis
//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package amd64

import (
	"cmd/compile/internal/big"
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/x86"
	"fmt"
)

var resvd = []int{
	x86.REG_DI, // for movstring
	x86.REG_SI, // for movstring

	x86.REG_AX, // for divide
	x86.REG_CX, // for shift
	x86.REG_DX, // for divide
	x86.REG_SP, // for stack
}

/*
 * generate
 *	as $c, reg
 */
func gconreg(as int, c int64, reg int) {
	var nr gc.Node

	switch as {
	case x86.AADDL,
		x86.AMOVL,
		x86.ALEAL:
		gc.Nodreg(&nr, gc.Types[gc.TINT32], reg)

	default:
		gc.Nodreg(&nr, gc.Types[gc.TINT64], reg)
	}

	ginscon(as, c, &nr)
}

/*
 * generate
 *	as $c, n
 */
func ginscon(as int, c int64, n2 *gc.Node) {
	var n1 gc.Node

	switch as {
	case x86.AADDL,
		x86.AMOVL,
		x86.ALEAL:
		gc.Nodconst(&n1, gc.Types[gc.TINT32], c)

	default:
		gc.Nodconst(&n1, gc.Types[gc.TINT64], c)
	}

	if as != x86.AMOVQ && (c < -(1<<31) || c >= 1<<31) {
		// cannot have 64-bit immediate in ADD, etc.
		// instead, MOV into register first.
		var ntmp gc.Node
		gc.Regalloc(&ntmp, gc.Types[gc.TINT64], nil)

		gins(x86.AMOVQ, &n1, &ntmp)
		gins(as, &ntmp, n2)
		gc.Regfree(&ntmp)
		return
	}

	gins(as, &n1, n2)
}

func ginscmp(op gc.Op, t *gc.Type, n1, n2 *gc.Node, likely int) *obj.Prog {
	if gc.Isint[t.Etype] && n1.Op == gc.OLITERAL && gc.Smallintconst(n1) && n2.Op != gc.OLITERAL {
		// Reverse comparison to place constant last.
		op = gc.Brrev(op)
		n1, n2 = n2, n1
	}
	// General case.
	var r1, r2, g1, g2 gc.Node

	// A special case to make write barriers more efficient.
	// Comparing the first field of a named struct can be done directly.
	base := n1
	if n1.Op == gc.ODOT && n1.Left.Type.Etype == gc.TSTRUCT && n1.Left.Type.Type.Sym == n1.Right.Sym {
		base = n1.Left
	}

	if base.Op == gc.ONAME && base.Class&gc.PHEAP == 0 || n1.Op == gc.OINDREG {
		r1 = *n1
	} else {
		gc.Regalloc(&r1, t, n1)
		gc.Regalloc(&g1, n1.Type, &r1)
		gc.Cgen(n1, &g1)
		gmove(&g1, &r1)
	}
	if n2.Op == gc.OLITERAL && gc.Isint[t.Etype] && gc.Smallintconst(n2) {
		r2 = *n2
	} else {
		gc.Regalloc(&r2, t, n2)
		gc.Regalloc(&g2, n1.Type, &r2)
		gc.Cgen(n2, &g2)
		gmove(&g2, &r2)
	}
	gins(optoas(gc.OCMP, t), &r1, &r2)
	if r1.Op == gc.OREGISTER {
		gc.Regfree(&g1)
		gc.Regfree(&r1)
	}
	if r2.Op == gc.OREGISTER {
		gc.Regfree(&g2)
		gc.Regfree(&r2)
	}
	return gc.Gbranch(optoas(op, t), nil, likely)
}

func ginsboolval(a int, n *gc.Node) {
	gins(jmptoset(a), nil, n)
}

// set up nodes representing 2^63
var (
	bigi         gc.Node
	bigf         gc.Node
	bignodes_did bool
)

func bignodes() {
	if bignodes_did {
		return
	}
	bignodes_did = true

	var i big.Int
	i.SetInt64(1)
	i.Lsh(&i, 63)

	gc.Nodconst(&bigi, gc.Types[gc.TUINT64], 0)
	bigi.SetBigInt(&i)

	bigi.Convconst(&bigf, gc.Types[gc.TFLOAT64])
}

/*
 * generate move:
 *	t = f
 * hard part is conversions.
 */
func gmove(f *gc.Node, t *gc.Node) {
	if gc.Debug['M'] != 0 {
		fmt.Printf("gmove %v -> %v\n", gc.Nconv(f, obj.FmtLong), gc.Nconv(t, obj.FmtLong))
	}

	ft := gc.Simsimtype(f.Type)
	tt := gc.Simsimtype(t.Type)
	cvt := t.Type

	if gc.Iscomplex[ft] || gc.Iscomplex[tt] {
		gc.Complexmove(f, t)
		return
	}

	// cannot have two memory operands
	var a int
	if gc.Ismem(f) && gc.Ismem(t) {
		goto hard
	}

	// convert constant to desired type
	if f.Op == gc.OLITERAL {
		var con gc.Node
		f.Convconst(&con, t.Type)
		f = &con
		ft = tt // so big switch will choose a simple mov

		// some constants can't move directly to memory.
		if gc.Ismem(t) {
			// float constants come from memory.
			if gc.Isfloat[tt] {
				goto hard
			}

			// 64-bit immediates are really 32-bit sign-extended
			// unless moving into a register.
			if gc.Isint[tt] {
				if i := con.Int(); int64(int32(i)) != i {
					goto hard
				}
			}
		}
	}

	// value -> value copy, only one memory operand.
	// figure out the instruction to use.
	// break out of switch for one-instruction gins.
	// goto rdst for "destination must be register".
	// goto hard for "convert to cvt type first".
	// otherwise handle and return.

	switch uint32(ft)<<16 | uint32(tt) {
	default:
		gc.Fatalf("gmove %v -> %v", gc.Tconv(f.Type, obj.FmtLong), gc.Tconv(t.Type, obj.FmtLong))

		/*
		 * integer copy and truncate
		 */
	case gc.TINT8<<16 | gc.TINT8, // same size
		gc.TINT8<<16 | gc.TUINT8,
		gc.TUINT8<<16 | gc.TINT8,
		gc.TUINT8<<16 | gc.TUINT8,
		gc.TINT16<<16 | gc.TINT8,
		// truncate
		gc.TUINT16<<16 | gc.TINT8,
		gc.TINT32<<16 | gc.TINT8,
		gc.TUINT32<<16 | gc.TINT8,
		gc.TINT64<<16 | gc.TINT8,
		gc.TUINT64<<16 | gc.TINT8,
		gc.TINT16<<16 | gc.TUINT8,
		gc.TUINT16<<16 | gc.TUINT8,
		gc.TINT32<<16 | gc.TUINT8,
		gc.TUINT32<<16 | gc.TUINT8,
		gc.TINT64<<16 | gc.TUINT8,
		gc.TUINT64<<16 | gc.TUINT8:
		a = x86.AMOVB

	case gc.TINT16<<16 | gc.TINT16, // same size
		gc.TINT16<<16 | gc.TUINT16,
		gc.TUINT16<<16 | gc.TINT16,
		gc.TUINT16<<16 | gc.TUINT16,
		gc.TINT32<<16 | gc.TINT16,
		// truncate
		gc.TUINT32<<16 | gc.TINT16,
		gc.TINT64<<16 | gc.TINT16,
		gc.TUINT64<<16 | gc.TINT16,
		gc.TINT32<<16 | gc.TUINT16,
		gc.TUINT32<<16 | gc.TUINT16,
		gc.TINT64<<16 | gc.TUINT16,
		gc.TUINT64<<16 | gc.TUINT16:
		a = x86.AMOVW

	case gc.TINT32<<16 | gc.TINT32, // same size
		gc.TINT32<<16 | gc.TUINT32,
		gc.TUINT32<<16 | gc.TINT32,
		gc.TUINT32<<16 | gc.TUINT32:
		a = x86.AMOVL

	case gc.TINT64<<16 | gc.TINT32, // truncate
		gc.TUINT64<<16 | gc.TINT32,
		gc.TINT64<<16 | gc.TUINT32,
		gc.TUINT64<<16 | gc.TUINT32:
		a = x86.AMOVQL

	case gc.TINT64<<16 | gc.TINT64, // same size
		gc.TINT64<<16 | gc.TUINT64,
		gc.TUINT64<<16 | gc.TINT64,
		gc.TUINT64<<16 | gc.TUINT64:
		a = x86.AMOVQ

		/*
		 * integer up-conversions
		 */
	case gc.TINT8<<16 | gc.TINT16, // sign extend int8
		gc.TINT8<<16 | gc.TUINT16:
		a = x86.AMOVBWSX

		goto rdst

	case gc.TINT8<<16 | gc.TINT32,
		gc.TINT8<<16 | gc.TUINT32:
		a = x86.AMOVBLSX
		goto rdst

	case gc.TINT8<<16 | gc.TINT64,
		gc.TINT8<<16 | gc.TUINT64:
		a = x86.AMOVBQSX
		goto rdst

	case gc.TUINT8<<16 | gc.TINT16, // zero extend uint8
		gc.TUINT8<<16 | gc.TUINT16:
		a = x86.AMOVBWZX

		goto rdst

	case gc.TUINT8<<16 | gc.TINT32,
		gc.TUINT8<<16 | gc.TUINT32:
		a = x86.AMOVBLZX
		goto rdst

	case gc.TUINT8<<16 | gc.TINT64,
		gc.TUINT8<<16 | gc.TUINT64:
		a = x86.AMOVBQZX
		goto rdst

	case gc.TINT16<<16 | gc.TINT32, // sign extend int16
		gc.TINT16<<16 | gc.TUINT32:
		a = x86.AMOVWLSX

		goto rdst

	case gc.TINT16<<16 | gc.TINT64,
		gc.TINT16<<16 | gc.TUINT64:
		a = x86.AMOVWQSX
		goto rdst

	case gc.TUINT16<<16 | gc.TINT32, // zero extend uint16
		gc.TUINT16<<16 | gc.TUINT32:
		a = x86.AMOVWLZX

		goto rdst

	case gc.TUINT16<<16 | gc.TINT64,
		gc.TUINT16<<16 | gc.TUINT64:
		a = x86.AMOVWQZX
		goto rdst

	case gc.TINT32<<16 | gc.TINT64, // sign extend int32
		gc.TINT32<<16 | gc.TUINT64:
		a = x86.AMOVLQSX

		goto rdst

		// AMOVL into a register zeros the top of the register,
	// so this is not always necessary, but if we rely on AMOVL
	// the optimizer is almost certain to screw with us.
	case gc.TUINT32<<16 | gc.TINT64, // zero extend uint32
		gc.TUINT32<<16 | gc.TUINT64:
		a = x86.AMOVLQZX

		goto rdst

		/*
		* float to integer
		 */
	case gc.TFLOAT32<<16 | gc.TINT32:
		a = x86.ACVTTSS2SL

		goto rdst

	case gc.TFLOAT64<<16 | gc.TINT32:
		a = x86.ACVTTSD2SL
		goto rdst

	case gc.TFLOAT32<<16 | gc.TINT64:
		a = x86.ACVTTSS2SQ
		goto rdst

	case gc.TFLOAT64<<16 | gc.TINT64:
		a = x86.ACVTTSD2SQ
		goto rdst

		// convert via int32.
	case gc.TFLOAT32<<16 | gc.TINT16,
		gc.TFLOAT32<<16 | gc.TINT8,
		gc.TFLOAT32<<16 | gc.TUINT16,
		gc.TFLOAT32<<16 | gc.TUINT8,
		gc.TFLOAT64<<16 | gc.TINT16,
		gc.TFLOAT64<<16 | gc.TINT8,
		gc.TFLOAT64<<16 | gc.TUINT16,
		gc.TFLOAT64<<16 | gc.TUINT8:
		cvt = gc.Types[gc.TINT32]

		goto hard

		// convert via int64.
	case gc.TFLOAT32<<16 | gc.TUINT32,
		gc.TFLOAT64<<16 | gc.TUINT32:
		cvt = gc.Types[gc.TINT64]

		goto hard

		// algorithm is:
	//	if small enough, use native float64 -> int64 conversion.
	//	otherwise, subtract 2^63, convert, and add it back.
	case gc.TFLOAT32<<16 | gc.TUINT64,
		gc.TFLOAT64<<16 | gc.TUINT64:
		a := x86.ACVTTSS2SQ

		if ft == gc.TFLOAT64 {
			a = x86.ACVTTSD2SQ
		}
		bignodes()
		var r1 gc.Node
		gc.Regalloc(&r1, gc.Types[ft], nil)
		var r2 gc.Node
		gc.Regalloc(&r2, gc.Types[tt], t)
		var r3 gc.Node
		gc.Regalloc(&r3, gc.Types[ft], nil)
		var r4 gc.Node
		gc.Regalloc(&r4, gc.Types[tt], nil)
		gins(optoas(gc.OAS, f.Type), f, &r1)
		gins(optoas(gc.OCMP, f.Type), &bigf, &r1)
		p1 := gc.Gbranch(optoas(gc.OLE, f.Type), nil, +1)
		gins(a, &r1, &r2)
		p2 := gc.Gbranch(obj.AJMP, nil, 0)
		gc.Patch(p1, gc.Pc)
		gins(optoas(gc.OAS, f.Type), &bigf, &r3)
		gins(optoas(gc.OSUB, f.Type), &r3, &r1)
		gins(a, &r1, &r2)
		gins(x86.AMOVQ, &bigi, &r4)
		gins(x86.AXORQ, &r4, &r2)
		gc.Patch(p2, gc.Pc)
		gmove(&r2, t)
		gc.Regfree(&r4)
		gc.Regfree(&r3)
		gc.Regfree(&r2)
		gc.Regfree(&r1)
		return

		/*
		 * integer to float
		 */
	case gc.TINT32<<16 | gc.TFLOAT32:
		a = x86.ACVTSL2SS

		goto rdst

	case gc.TINT32<<16 | gc.TFLOAT64:
		a = x86.ACVTSL2SD
		goto rdst

	case gc.TINT64<<16 | gc.TFLOAT32:
		a = x86.ACVTSQ2SS
		goto rdst

	case gc.TINT64<<16 | gc.TFLOAT64:
		a = x86.ACVTSQ2SD
		goto rdst

		// convert via int32
	case gc.TINT16<<16 | gc.TFLOAT32,
		gc.TINT16<<16 | gc.TFLOAT64,
		gc.TINT8<<16 | gc.TFLOAT32,
		gc.TINT8<<16 | gc.TFLOAT64,
		gc.TUINT16<<16 | gc.TFLOAT32,
		gc.TUINT16<<16 | gc.TFLOAT64,
		gc.TUINT8<<16 | gc.TFLOAT32,
		gc.TUINT8<<16 | gc.TFLOAT64:
		cvt = gc.Types[gc.TINT32]

		goto hard

		// convert via int64.
	case gc.TUINT32<<16 | gc.TFLOAT32,
		gc.TUINT32<<16 | gc.TFLOAT64:
		cvt = gc.Types[gc.TINT64]

		goto hard

		// algorithm is:
	//	if small enough, use native int64 -> uint64 conversion.
	//	otherwise, halve (rounding to odd?), convert, and double.
	case gc.TUINT64<<16 | gc.TFLOAT32,
		gc.TUINT64<<16 | gc.TFLOAT64:
		a := x86.ACVTSQ2SS

		if tt == gc.TFLOAT64 {
			a = x86.ACVTSQ2SD
		}
		var zero gc.Node
		gc.Nodconst(&zero, gc.Types[gc.TUINT64], 0)
		var one gc.Node
		gc.Nodconst(&one, gc.Types[gc.TUINT64], 1)
		var r1 gc.Node
		gc.Regalloc(&r1, f.Type, f)
		var r2 gc.Node
		gc.Regalloc(&r2, t.Type, t)
		var r3 gc.Node
		gc.Regalloc(&r3, f.Type, nil)
		var r4 gc.Node
		gc.Regalloc(&r4, f.Type, nil)
		gmove(f, &r1)
		gins(x86.ACMPQ, &r1, &zero)
		p1 := gc.Gbranch(x86.AJLT, nil, +1)
		gins(a, &r1, &r2)
		p2 := gc.Gbranch(obj.AJMP, nil, 0)
		gc.Patch(p1, gc.Pc)
		gmove(&r1, &r3)
		gins(x86.ASHRQ, &one, &r3)
		gmove(&r1, &r4)
		gins(x86.AANDL, &one, &r4)
		gins(x86.AORQ, &r4, &r3)
		gins(a, &r3, &r2)
		gins(optoas(gc.OADD, t.Type), &r2, &r2)
		gc.Patch(p2, gc.Pc)
		gmove(&r2, t)
		gc.Regfree(&r4)
		gc.Regfree(&r3)
		gc.Regfree(&r2)
		gc.Regfree(&r1)
		return

		/*
		 * float to float
		 */
	case gc.TFLOAT32<<16 | gc.TFLOAT32:
		a = x86.AMOVSS

	case gc.TFLOAT64<<16 | gc.TFLOAT64:
		a = x86.AMOVSD

	case gc.TFLOAT32<<16 | gc.TFLOAT64:
		a = x86.ACVTSS2SD
		goto rdst

	case gc.TFLOAT64<<16 | gc.TFLOAT32:
		a = x86.ACVTSD2SS
		goto rdst
	}

	gins(a, f, t)
	return

	// requires register destination
rdst:
	{
		var r1 gc.Node
		gc.Regalloc(&r1, t.Type, t)

		gins(a, f, &r1)
		gmove(&r1, t)
		gc.Regfree(&r1)
		return
	}

	// requires register intermediate
hard:
	var r1 gc.Node
	gc.Regalloc(&r1, cvt, t)

	gmove(f, &r1)
	gmove(&r1, t)
	gc.Regfree(&r1)
	return
}

func samaddr(f *gc.Node, t *gc.Node) bool {
	if f.Op != t.Op {
		return false
	}

	switch f.Op {
	case gc.OREGISTER:
		if f.Reg != t.Reg {
			break
		}
		return true
	}

	return false
}

/*
 * generate one instruction:
 *	as f, t
 */
func gins(as int, f *gc.Node, t *gc.Node) *obj.Prog {
	//	Node nod;

	//	if(f != N && f->op == OINDEX) {
	//		gc.Regalloc(&nod, &regnode, Z);
	//		v = constnode.vconst;
	//		gc.Cgen(f->right, &nod);
	//		constnode.vconst = v;
	//		idx.reg = nod.reg;
	//		gc.Regfree(&nod);
	//	}
	//	if(t != N && t->op == OINDEX) {
	//		gc.Regalloc(&nod, &regnode, Z);
	//		v = constnode.vconst;
	//		gc.Cgen(t->right, &nod);
	//		constnode.vconst = v;
	//		idx.reg = nod.reg;
	//		gc.Regfree(&nod);
	//	}

	if f != nil && f.Op == gc.OADDR && (as == x86.AMOVL || as == x86.AMOVQ) {
		// Turn MOVL $xxx into LEAL xxx.
		// These should be equivalent but most of the backend
		// only expects to see LEAL, because that's what we had
		// historically generated. Various hidden assumptions are baked in by now.
		if as == x86.AMOVL {
			as = x86.ALEAL
		} else {
			as = x86.ALEAQ
		}
		f = f.Left
	}

	switch as {
	case x86.AMOVB,
		x86.AMOVW,
		x86.AMOVL,
		x86.AMOVQ,
		x86.AMOVSS,
		x86.AMOVSD:
		if f != nil && t != nil && samaddr(f, t) {
			return nil
		}

	case x86.ALEAQ:
		if f != nil && gc.Isconst(f, gc.CTNIL) {
			gc.Fatalf("gins LEAQ nil %v", f.Type)
		}
	}

	p := gc.Prog(as)
	gc.Naddr(&p.From, f)
	gc.Naddr(&p.To, t)

	if gc.Debug['g'] != 0 {
		fmt.Printf("%v\n", p)
	}

	w := int32(0)
	switch as {
	case x86.AMOVB:
		w = 1

	case x86.AMOVW:
		w = 2

	case x86.AMOVL:
		w = 4

	case x86.AMOVQ:
		w = 8
	}

	if w != 0 && ((f != nil && p.From.Width < int64(w)) || (t != nil && p.To.Width > int64(w))) {
		gc.Dump("f", f)
		gc.Dump("t", t)
		gc.Fatalf("bad width: %v (%d, %d)\n", p, p.From.Width, p.To.Width)
	}

	if p.To.Type == obj.TYPE_ADDR && w > 0 {
		gc.Fatalf("bad use of addr: %v", p)
	}

	return p
}

func ginsnop() {
	// This is actually not the x86 NOP anymore,
	// but at the point where it gets used, AX is dead
	// so it's okay if we lose the high bits.
	var reg gc.Node
	gc.Nodreg(&reg, gc.Types[gc.TINT], x86.REG_AX)
	gins(x86.AXCHGL, &reg, &reg)
}

/*
 * return Axxx for Oxxx on type t.
 */
func optoas(op gc.Op, t *gc.Type) int {
	if t == nil {
		gc.Fatalf("optoas: t is nil")
	}

	// avoid constant conversions in switches below
	const (
		OMINUS_  = uint32(gc.OMINUS) << 16
		OLSH_    = uint32(gc.OLSH) << 16
		ORSH_    = uint32(gc.ORSH) << 16
		OADD_    = uint32(gc.OADD) << 16
		OSUB_    = uint32(gc.OSUB) << 16
		OMUL_    = uint32(gc.OMUL) << 16
		ODIV_    = uint32(gc.ODIV) << 16
		OMOD_    = uint32(gc.OMOD) << 16
		OOR_     = uint32(gc.OOR) << 16
		OAND_    = uint32(gc.OAND) << 16
		OXOR_    = uint32(gc.OXOR) << 16
		OEQ_     = uint32(gc.OEQ) << 16
		ONE_     = uint32(gc.ONE) << 16
		OLT_     = uint32(gc.OLT) << 16
		OLE_     = uint32(gc.OLE) << 16
		OGE_     = uint32(gc.OGE) << 16
		OGT_     = uint32(gc.OGT) << 16
		OCMP_    = uint32(gc.OCMP) << 16
		OPS_     = uint32(gc.OPS) << 16
		OPC_     = uint32(gc.OPC) << 16
		OAS_     = uint32(gc.OAS) << 16
		OHMUL_   = uint32(gc.OHMUL) << 16
		OSQRT_   = uint32(gc.OSQRT) << 16
		OADDR_   = uint32(gc.OADDR) << 16
		OINC_    = uint32(gc.OINC) << 16
		ODEC_    = uint32(gc.ODEC) << 16
		OLROT_   = uint32(gc.OLROT) << 16
		ORROTC_  = uint32(gc.ORROTC) << 16
		OEXTEND_ = uint32(gc.OEXTEND) << 16
	)

	a := obj.AXXX
	switch uint32(op)<<16 | uint32(gc.Simtype[t.Etype]) {
	default:
		gc.Fatalf("optoas: no entry %v-%v", gc.Oconv(int(op), 0), t)

	case OADDR_ | gc.TPTR32:
		a = x86.ALEAL

	case OADDR_ | gc.TPTR64:
		a = x86.ALEAQ

	case OEQ_ | gc.TBOOL,
		OEQ_ | gc.TINT8,
		OEQ_ | gc.TUINT8,
		OEQ_ | gc.TINT16,
		OEQ_ | gc.TUINT16,
		OEQ_ | gc.TINT32,
		OEQ_ | gc.TUINT32,
		OEQ_ | gc.TINT64,
		OEQ_ | gc.TUINT64,
		OEQ_ | gc.TPTR32,
		OEQ_ | gc.TPTR64,
		OEQ_ | gc.TFLOAT32,
		OEQ_ | gc.TFLOAT64:
		a = x86.AJEQ

	case ONE_ | gc.TBOOL,
		ONE_ | gc.TINT8,
		ONE_ | gc.TUINT8,
		ONE_ | gc.TINT16,
		ONE_ | gc.TUINT16,
		ONE_ | gc.TINT32,
		ONE_ | gc.TUINT32,
		ONE_ | gc.TINT64,
		ONE_ | gc.TUINT64,
		ONE_ | gc.TPTR32,
		ONE_ | gc.TPTR64,
		ONE_ | gc.TFLOAT32,
		ONE_ | gc.TFLOAT64:
		a = x86.AJNE

	case OPS_ | gc.TBOOL,
		OPS_ | gc.TINT8,
		OPS_ | gc.TUINT8,
		OPS_ | gc.TINT16,
		OPS_ | gc.TUINT16,
		OPS_ | gc.TINT32,
		OPS_ | gc.TUINT32,
		OPS_ | gc.TINT64,
		OPS_ | gc.TUINT64,
		OPS_ | gc.TPTR32,
		OPS_ | gc.TPTR64,
		OPS_ | gc.TFLOAT32,
		OPS_ | gc.TFLOAT64:
		a = x86.AJPS

	case OPC_ | gc.TBOOL,
		OPC_ | gc.TINT8,
		OPC_ | gc.TUINT8,
		OPC_ | gc.TINT16,
		OPC_ | gc.TUINT16,
		OPC_ | gc.TINT32,
		OPC_ | gc.TUINT32,
		OPC_ | gc.TINT64,
		OPC_ | gc.TUINT64,
		OPC_ | gc.TPTR32,
		OPC_ | gc.TPTR64,
		OPC_ | gc.TFLOAT32,
		OPC_ | gc.TFLOAT64:
		a = x86.AJPC

	case OLT_ | gc.TINT8,
		OLT_ | gc.TINT16,
		OLT_ | gc.TINT32,
		OLT_ | gc.TINT64:
		a = x86.AJLT

	case OLT_ | gc.TUINT8,
		OLT_ | gc.TUINT16,
		OLT_ | gc.TUINT32,
		OLT_ | gc.TUINT64:
		a = x86.AJCS

	case OLE_ | gc.TINT8,
		OLE_ | gc.TINT16,
		OLE_ | gc.TINT32,
		OLE_ | gc.TINT64:
		a = x86.AJLE

	case OLE_ | gc.TUINT8,
		OLE_ | gc.TUINT16,
		OLE_ | gc.TUINT32,
		OLE_ | gc.TUINT64:
		a = x86.AJLS

	case OGT_ | gc.TINT8,
		OGT_ | gc.TINT16,
		OGT_ | gc.TINT32,
		OGT_ | gc.TINT64:
		a = x86.AJGT

	case OGT_ | gc.TUINT8,
		OGT_ | gc.TUINT16,
		OGT_ | gc.TUINT32,
		OGT_ | gc.TUINT64,
		OLT_ | gc.TFLOAT32,
		OLT_ | gc.TFLOAT64:
		a = x86.AJHI

	case OGE_ | gc.TINT8,
		OGE_ | gc.TINT16,
		OGE_ | gc.TINT32,
		OGE_ | gc.TINT64:
		a = x86.AJGE

	case OGE_ | gc.TUINT8,
		OGE_ | gc.TUINT16,
		OGE_ | gc.TUINT32,
		OGE_ | gc.TUINT64,
		OLE_ | gc.TFLOAT32,
		OLE_ | gc.TFLOAT64:
		a = x86.AJCC

	case OCMP_ | gc.TBOOL,
		OCMP_ | gc.TINT8,
		OCMP_ | gc.TUINT8:
		a = x86.ACMPB

	case OCMP_ | gc.TINT16,
		OCMP_ | gc.TUINT16:
		a = x86.ACMPW

	case OCMP_ | gc.TINT32,
		OCMP_ | gc.TUINT32,
		OCMP_ | gc.TPTR32:
		a = x86.ACMPL

	case OCMP_ | gc.TINT64,
		OCMP_ | gc.TUINT64,
		OCMP_ | gc.TPTR64:
		a = x86.ACMPQ

	case OCMP_ | gc.TFLOAT32:
		a = x86.AUCOMISS

	case OCMP_ | gc.TFLOAT64:
		a = x86.AUCOMISD

	case OAS_ | gc.TBOOL,
		OAS_ | gc.TINT8,
		OAS_ | gc.TUINT8:
		a = x86.AMOVB

	case OAS_ | gc.TINT16,
		OAS_ | gc.TUINT16:
		a = x86.AMOVW

	case OAS_ | gc.TINT32,
		OAS_ | gc.TUINT32,
		OAS_ | gc.TPTR32:
		a = x86.AMOVL

	case OAS_ | gc.TINT64,
		OAS_ | gc.TUINT64,
		OAS_ | gc.TPTR64:
		a = x86.AMOVQ

	case OAS_ | gc.TFLOAT32:
		a = x86.AMOVSS

	case OAS_ | gc.TFLOAT64:
		a = x86.AMOVSD

	case OADD_ | gc.TINT8,
		OADD_ | gc.TUINT8:
		a = x86.AADDB

	case OADD_ | gc.TINT16,
		OADD_ | gc.TUINT16:
		a = x86.AADDW

	case OADD_ | gc.TINT32,
		OADD_ | gc.TUINT32,
		OADD_ | gc.TPTR32:
		a = x86.AADDL

	case OADD_ | gc.TINT64,
		OADD_ | gc.TUINT64,
		OADD_ | gc.TPTR64:
		a = x86.AADDQ

	case OADD_ | gc.TFLOAT32:
		a = x86.AADDSS

	case OADD_ | gc.TFLOAT64:
		a = x86.AADDSD

	case OSUB_ | gc.TINT8,
		OSUB_ | gc.TUINT8:
		a = x86.ASUBB

	case OSUB_ | gc.TINT16,
		OSUB_ | gc.TUINT16:
		a = x86.ASUBW

	case OSUB_ | gc.TINT32,
		OSUB_ | gc.TUINT32,
		OSUB_ | gc.TPTR32:
		a = x86.ASUBL

	case OSUB_ | gc.TINT64,
		OSUB_ | gc.TUINT64,
		OSUB_ | gc.TPTR64:
		a = x86.ASUBQ

	case OSUB_ | gc.TFLOAT32:
		a = x86.ASUBSS

	case OSUB_ | gc.TFLOAT64:
		a = x86.ASUBSD

	case OINC_ | gc.TINT8,
		OINC_ | gc.TUINT8:
		a = x86.AINCB

	case OINC_ | gc.TINT16,
		OINC_ | gc.TUINT16:
		a = x86.AINCW

	case OINC_ | gc.TINT32,
		OINC_ | gc.TUINT32,
		OINC_ | gc.TPTR32:
		a = x86.AINCL

	case OINC_ | gc.TINT64,
		OINC_ | gc.TUINT64,
		OINC_ | gc.TPTR64:
		a = x86.AINCQ

	case ODEC_ | gc.TINT8,
		ODEC_ | gc.TUINT8:
		a = x86.ADECB

	case ODEC_ | gc.TINT16,
		ODEC_ | gc.TUINT16:
		a = x86.ADECW

	case ODEC_ | gc.TINT32,
		ODEC_ | gc.TUINT32,
		ODEC_ | gc.TPTR32:
		a = x86.ADECL

	case ODEC_ | gc.TINT64,
		ODEC_ | gc.TUINT64,
		ODEC_ | gc.TPTR64:
		a = x86.ADECQ

	case OMINUS_ | gc.TINT8,
		OMINUS_ | gc.TUINT8:
		a = x86.ANEGB

	case OMINUS_ | gc.TINT16,
		OMINUS_ | gc.TUINT16:
		a = x86.ANEGW

	case OMINUS_ | gc.TINT32,
		OMINUS_ | gc.TUINT32,
		OMINUS_ | gc.TPTR32:
		a = x86.ANEGL

	case OMINUS_ | gc.TINT64,
		OMINUS_ | gc.TUINT64,
		OMINUS_ | gc.TPTR64:
		a = x86.ANEGQ

	case OAND_ | gc.TBOOL,
		OAND_ | gc.TINT8,
		OAND_ | gc.TUINT8:
		a = x86.AANDB

	case OAND_ | gc.TINT16,
		OAND_ | gc.TUINT16:
		a = x86.AANDW

	case OAND_ | gc.TINT32,
		OAND_ | gc.TUINT32,
		OAND_ | gc.TPTR32:
		a = x86.AANDL

	case OAND_ | gc.TINT64,
		OAND_ | gc.TUINT64,
		OAND_ | gc.TPTR64:
		a = x86.AANDQ

	case OOR_ | gc.TBOOL,
		OOR_ | gc.TINT8,
		OOR_ | gc.TUINT8:
		a = x86.AORB

	case OOR_ | gc.TINT16,
		OOR_ | gc.TUINT16:
		a = x86.AORW

	case OOR_ | gc.TINT32,
		OOR_ | gc.TUINT32,
		OOR_ | gc.TPTR32:
		a = x86.AORL

	case OOR_ | gc.TINT64,
		OOR_ | gc.TUINT64,
		OOR_ | gc.TPTR64:
		a = x86.AORQ

	case OXOR_ | gc.TINT8,
		OXOR_ | gc.TUINT8:
		a = x86.AXORB

	case OXOR_ | gc.TINT16,
		OXOR_ | gc.TUINT16:
		a = x86.AXORW

	case OXOR_ | gc.TINT32,
		OXOR_ | gc.TUINT32,
		OXOR_ | gc.TPTR32:
		a = x86.AXORL

	case OXOR_ | gc.TINT64,
		OXOR_ | gc.TUINT64,
		OXOR_ | gc.TPTR64:
		a = x86.AXORQ

	case OLROT_ | gc.TINT8,
		OLROT_ | gc.TUINT8:
		a = x86.AROLB

	case OLROT_ | gc.TINT16,
		OLROT_ | gc.TUINT16:
		a = x86.AROLW

	case OLROT_ | gc.TINT32,
		OLROT_ | gc.TUINT32,
		OLROT_ | gc.TPTR32:
		a = x86.AROLL

	case OLROT_ | gc.TINT64,
		OLROT_ | gc.TUINT64,
		OLROT_ | gc.TPTR64:
		a = x86.AROLQ

	case OLSH_ | gc.TINT8,
		OLSH_ | gc.TUINT8:
		a = x86.ASHLB

	case OLSH_ | gc.TINT16,
		OLSH_ | gc.TUINT16:
		a = x86.ASHLW

	case OLSH_ | gc.TINT32,
		OLSH_ | gc.TUINT32,
		OLSH_ | gc.TPTR32:
		a = x86.ASHLL

	case OLSH_ | gc.TINT64,
		OLSH_ | gc.TUINT64,
		OLSH_ | gc.TPTR64:
		a = x86.ASHLQ

	case ORSH_ | gc.TUINT8:
		a = x86.ASHRB

	case ORSH_ | gc.TUINT16:
		a = x86.ASHRW

	case ORSH_ | gc.TUINT32,
		ORSH_ | gc.TPTR32:
		a = x86.ASHRL

	case ORSH_ | gc.TUINT64,
		ORSH_ | gc.TPTR64:
		a = x86.ASHRQ

	case ORSH_ | gc.TINT8:
		a = x86.ASARB

	case ORSH_ | gc.TINT16:
		a = x86.ASARW

	case ORSH_ | gc.TINT32:
		a = x86.ASARL

	case ORSH_ | gc.TINT64:
		a = x86.ASARQ

	case ORROTC_ | gc.TINT8,
		ORROTC_ | gc.TUINT8:
		a = x86.ARCRB

	case ORROTC_ | gc.TINT16,
		ORROTC_ | gc.TUINT16:
		a = x86.ARCRW

	case ORROTC_ | gc.TINT32,
		ORROTC_ | gc.TUINT32:
		a = x86.ARCRL

	case ORROTC_ | gc.TINT64,
		ORROTC_ | gc.TUINT64:
		a = x86.ARCRQ

	case OHMUL_ | gc.TINT8,
		OMUL_ | gc.TINT8,
		OMUL_ | gc.TUINT8:
		a = x86.AIMULB

	case OHMUL_ | gc.TINT16,
		OMUL_ | gc.TINT16,
		OMUL_ | gc.TUINT16:
		a = x86.AIMULW

	case OHMUL_ | gc.TINT32,
		OMUL_ | gc.TINT32,
		OMUL_ | gc.TUINT32,
		OMUL_ | gc.TPTR32:
		a = x86.AIMULL

	case OHMUL_ | gc.TINT64,
		OMUL_ | gc.TINT64,
		OMUL_ | gc.TUINT64,
		OMUL_ | gc.TPTR64:
		a = x86.AIMULQ

	case OHMUL_ | gc.TUINT8:
		a = x86.AMULB

	case OHMUL_ | gc.TUINT16:
		a = x86.AMULW

	case OHMUL_ | gc.TUINT32,
		OHMUL_ | gc.TPTR32:
		a = x86.AMULL

	case OHMUL_ | gc.TUINT64,
		OHMUL_ | gc.TPTR64:
		a = x86.AMULQ

	case OMUL_ | gc.TFLOAT32:
		a = x86.AMULSS

	case OMUL_ | gc.TFLOAT64:
		a = x86.AMULSD

	case ODIV_ | gc.TINT8,
		OMOD_ | gc.TINT8:
		a = x86.AIDIVB

	case ODIV_ | gc.TUINT8,
		OMOD_ | gc.TUINT8:
		a = x86.ADIVB

	case ODIV_ | gc.TINT16,
		OMOD_ | gc.TINT16:
		a = x86.AIDIVW

	case ODIV_ | gc.TUINT16,
		OMOD_ | gc.TUINT16:
		a = x86.ADIVW

	case ODIV_ | gc.TINT32,
		OMOD_ | gc.TINT32:
		a = x86.AIDIVL

	case ODIV_ | gc.TUINT32,
		ODIV_ | gc.TPTR32,
		OMOD_ | gc.TUINT32,
		OMOD_ | gc.TPTR32:
		a = x86.ADIVL

	case ODIV_ | gc.TINT64,
		OMOD_ | gc.TINT64:
		a = x86.AIDIVQ

	case ODIV_ | gc.TUINT64,
		ODIV_ | gc.TPTR64,
		OMOD_ | gc.TUINT64,
		OMOD_ | gc.TPTR64:
		a = x86.ADIVQ

	case OEXTEND_ | gc.TINT16:
		a = x86.ACWD

	case OEXTEND_ | gc.TINT32:
		a = x86.ACDQ

	case OEXTEND_ | gc.TINT64:
		a = x86.ACQO

	case ODIV_ | gc.TFLOAT32:
		a = x86.ADIVSS

	case ODIV_ | gc.TFLOAT64:
		a = x86.ADIVSD

	case OSQRT_ | gc.TFLOAT64:
		a = x86.ASQRTSD
	}

	return a
}

// jmptoset returns ASETxx for AJxx.
func jmptoset(jmp int) int {
	switch jmp {
	case x86.AJEQ:
		return x86.ASETEQ
	case x86.AJNE:
		return x86.ASETNE
	case x86.AJLT:
		return x86.ASETLT
	case x86.AJCS:
		return x86.ASETCS
	case x86.AJLE:
		return x86.ASETLE
	case x86.AJLS:
		return x86.ASETLS
	case x86.AJGT:
		return x86.ASETGT
	case x86.AJHI:
		return x86.ASETHI
	case x86.AJGE:
		return x86.ASETGE
	case x86.AJCC:
		return x86.ASETCC
	case x86.AJMI:
		return x86.ASETMI
	case x86.AJOC:
		return x86.ASETOC
	case x86.AJOS:
		return x86.ASETOS
	case x86.AJPC:
		return x86.ASETPC
	case x86.AJPL:
		return x86.ASETPL
	case x86.AJPS:
		return x86.ASETPS
	}
	gc.Fatalf("jmptoset: no entry for %v", gc.Oconv(jmp, 0))
	panic("unreachable")
}

const (
	ODynam   = 1 << 0
	OAddable = 1 << 1
)

var clean [20]gc.Node

var cleani int = 0

func sudoclean() {
	if clean[cleani-1].Op != gc.OEMPTY {
		gc.Regfree(&clean[cleani-1])
	}
	if clean[cleani-2].Op != gc.OEMPTY {
		gc.Regfree(&clean[cleani-2])
	}
	cleani -= 2
}

/*
 * generate code to compute address of n,
 * a reference to a (perhaps nested) field inside
 * an array or struct.
 * return 0 on failure, 1 on success.
 * on success, leaves usable address in a.
 *
 * caller is responsible for calling sudoclean
 * after successful sudoaddable,
 * to release the register used for a.
 */
func sudoaddable(as int, n *gc.Node, a *obj.Addr) bool {
	if n.Type == nil {
		return false
	}

	*a = obj.Addr{}

	switch n.Op {
	case gc.OLITERAL:
		if !gc.Isconst(n, gc.CTINT) {
			break
		}
		v := n.Int()
		if v >= 32000 || v <= -32000 {
			break
		}
		switch as {
		default:
			return false

		case x86.AADDB,
			x86.AADDW,
			x86.AADDL,
			x86.AADDQ,
			x86.ASUBB,
			x86.ASUBW,
			x86.ASUBL,
			x86.ASUBQ,
			x86.AANDB,
			x86.AANDW,
			x86.AANDL,
			x86.AANDQ,
			x86.AORB,
			x86.AORW,
			x86.AORL,
			x86.AORQ,
			x86.AXORB,
			x86.AXORW,
			x86.AXORL,
			x86.AXORQ,
			x86.AINCB,
			x86.AINCW,
			x86.AINCL,
			x86.AINCQ,
			x86.ADECB,
			x86.ADECW,
			x86.ADECL,
			x86.ADECQ,
			x86.AMOVB,
			x86.AMOVW,
			x86.AMOVL,
			x86.AMOVQ:
			break
		}

		cleani += 2
		reg := &clean[cleani-1]
		reg1 := &clean[cleani-2]
		reg.Op = gc.OEMPTY
		reg1.Op = gc.OEMPTY
		gc.Naddr(a, n)
		return true

	case gc.ODOT,
		gc.ODOTPTR:
		cleani += 2
		reg := &clean[cleani-1]
		reg1 := &clean[cleani-2]
		reg.Op = gc.OEMPTY
		reg1.Op = gc.OEMPTY
		var nn *gc.Node
		var oary [10]int64
		o := gc.Dotoffset(n, oary[:], &nn)
		if nn == nil {
			sudoclean()
			return false
		}

		if nn.Addable && o == 1 && oary[0] >= 0 {
			// directly addressable set of DOTs
			n1 := *nn

			n1.Type = n.Type
			n1.Xoffset += oary[0]
			gc.Naddr(a, &n1)
			return true
		}

		gc.Regalloc(reg, gc.Types[gc.Tptr], nil)
		n1 := *reg
		n1.Op = gc.OINDREG
		if oary[0] >= 0 {
			gc.Agen(nn, reg)
			n1.Xoffset = oary[0]
		} else {
			gc.Cgen(nn, reg)
			gc.Cgen_checknil(reg)
			n1.Xoffset = -(oary[0] + 1)
		}

		for i := 1; i < o; i++ {
			if oary[i] >= 0 {
				gc.Fatalf("can't happen")
			}
			gins(movptr, &n1, reg)
			gc.Cgen_checknil(reg)
			n1.Xoffset = -(oary[i] + 1)
		}

		a.Type = obj.TYPE_NONE
		a.Index = obj.TYPE_NONE
		gc.Fixlargeoffset(&n1)
		gc.Naddr(a, &n1)
		return true

	case gc.OINDEX:
		return false
	}

	return false
}
                                                 usr/local/go/src/cmd/compile/internal/amd64/peep.go                                                 0100644 0000000 0000000 00000051560 13020111411 020535  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Derived from Inferno utils/6c/peep.c
// http://code.google.com/p/inferno-os/source/browse/utils/6c/peep.c
//
//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright © 1997-1999 Vita Nuova Limited
//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright © 2004,2006 Bruce Ellis
//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package amd64

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/x86"
	"fmt"
)

var gactive uint32

const (
	exregoffset = x86.REG_R15
)

// do we need the carry bit
func needc(p *obj.Prog) bool {
	for p != nil {
		flags := progcarryflags(p)
		if flags&gc.UseCarry != 0 {
			return true
		}
		if flags&(gc.SetCarry|gc.KillCarry) != 0 {
			return false
		}
		p = p.Link
	}

	return false
}

func rnops(r *gc.Flow) *gc.Flow {
	if r != nil {
		var p *obj.Prog
		var r1 *gc.Flow
		for {
			p = r.Prog
			if p.As != obj.ANOP || p.From.Type != obj.TYPE_NONE || p.To.Type != obj.TYPE_NONE {
				break
			}
			r1 = gc.Uniqs(r)
			if r1 == nil {
				break
			}
			r = r1
		}
	}

	return r
}

func peep(firstp *obj.Prog) {
	g := (*gc.Graph)(gc.Flowstart(firstp, nil))
	if g == nil {
		return
	}
	gactive = 0

	// byte, word arithmetic elimination.
	elimshortmov(g)

	// constant propagation
	// find MOV $con,R followed by
	// another MOV $con,R without
	// setting R in the interim
	var p *obj.Prog
	for r := (*gc.Flow)(g.Start); r != nil; r = r.Link {
		p = r.Prog
		switch p.As {
		case x86.ALEAL,
			x86.ALEAQ:
			if regtyp(&p.To) {
				if p.From.Sym != nil {
					if p.From.Index == x86.REG_NONE {
						conprop(r)
					}
				}
			}

		case x86.AMOVB,
			x86.AMOVW,
			x86.AMOVL,
			x86.AMOVQ,
			x86.AMOVSS,
			x86.AMOVSD:
			if regtyp(&p.To) {
				if p.From.Type == obj.TYPE_CONST || p.From.Type == obj.TYPE_FCONST {
					conprop(r)
				}
			}
		}
	}

	var r *gc.Flow
	var r1 *gc.Flow
	var p1 *obj.Prog
	var t int
loop1:
	if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
		gc.Dumpit("loop1", g.Start, 0)
	}

	t = 0
	for r = g.Start; r != nil; r = r.Link {
		p = r.Prog
		switch p.As {
		case x86.AMOVL,
			x86.AMOVQ,
			x86.AMOVSS,
			x86.AMOVSD:
			if regtyp(&p.To) {
				if regtyp(&p.From) {
					if copyprop(g, r) {
						excise(r)
						t++
					} else if subprop(r) && copyprop(g, r) {
						excise(r)
						t++
					}
				}
			}

		case x86.AMOVBLZX,
			x86.AMOVWLZX,
			x86.AMOVBLSX,
			x86.AMOVWLSX:
			if regtyp(&p.To) {
				r1 = rnops(gc.Uniqs(r))
				if r1 != nil {
					p1 = r1.Prog
					if p.As == p1.As && p.To.Type == p1.From.Type && p.To.Reg == p1.From.Reg {
						p1.As = x86.AMOVL
						t++
					}
				}
			}

		case x86.AMOVBQSX,
			x86.AMOVBQZX,
			x86.AMOVWQSX,
			x86.AMOVWQZX,
			x86.AMOVLQSX,
			x86.AMOVLQZX,
			x86.AMOVQL:
			if regtyp(&p.To) {
				r1 = rnops(gc.Uniqs(r))
				if r1 != nil {
					p1 = r1.Prog
					if p.As == p1.As && p.To.Type == p1.From.Type && p.To.Reg == p1.From.Reg {
						p1.As = x86.AMOVQ
						t++
					}
				}
			}

		case x86.AADDL,
			x86.AADDQ,
			x86.AADDW:
			if p.From.Type != obj.TYPE_CONST || needc(p.Link) {
				break
			}
			if p.From.Offset == -1 {
				if p.As == x86.AADDQ {
					p.As = x86.ADECQ
				} else if p.As == x86.AADDL {
					p.As = x86.ADECL
				} else {
					p.As = x86.ADECW
				}
				p.From = obj.Addr{}
				break
			}

			if p.From.Offset == 1 {
				if p.As == x86.AADDQ {
					p.As = x86.AINCQ
				} else if p.As == x86.AADDL {
					p.As = x86.AINCL
				} else {
					p.As = x86.AINCW
				}
				p.From = obj.Addr{}
				break
			}

		case x86.ASUBL,
			x86.ASUBQ,
			x86.ASUBW:
			if p.From.Type != obj.TYPE_CONST || needc(p.Link) {
				break
			}
			if p.From.Offset == -1 {
				if p.As == x86.ASUBQ {
					p.As = x86.AINCQ
				} else if p.As == x86.ASUBL {
					p.As = x86.AINCL
				} else {
					p.As = x86.AINCW
				}
				p.From = obj.Addr{}
				break
			}

			if p.From.Offset == 1 {
				if p.As == x86.ASUBQ {
					p.As = x86.ADECQ
				} else if p.As == x86.ASUBL {
					p.As = x86.ADECL
				} else {
					p.As = x86.ADECW
				}
				p.From = obj.Addr{}
				break
			}
		}
	}

	if t != 0 {
		goto loop1
	}

	// MOVLQZX removal.
	// The MOVLQZX exists to avoid being confused for a
	// MOVL that is just copying 32-bit data around during
	// copyprop.  Now that copyprop is done, remov MOVLQZX R1, R2
	// if it is dominated by an earlier ADDL/MOVL/etc into R1 that
	// will have already cleared the high bits.
	//
	// MOVSD removal.
	// We never use packed registers, so a MOVSD between registers
	// can be replaced by MOVAPD, which moves the pair of float64s
	// instead of just the lower one.  We only use the lower one, but
	// the processor can do better if we do moves using both.
	for r := (*gc.Flow)(g.Start); r != nil; r = r.Link {
		p = r.Prog
		if p.As == x86.AMOVLQZX {
			if regtyp(&p.From) {
				if p.From.Type == p.To.Type && p.From.Reg == p.To.Reg {
					if prevl(r, int(p.From.Reg)) {
						excise(r)
					}
				}
			}
		}

		if p.As == x86.AMOVSD {
			if regtyp(&p.From) {
				if regtyp(&p.To) {
					p.As = x86.AMOVAPD
				}
			}
		}
	}

	// load pipelining
	// push any load from memory as early as possible
	// to give it time to complete before use.
	for r := (*gc.Flow)(g.Start); r != nil; r = r.Link {
		p = r.Prog
		switch p.As {
		case x86.AMOVB,
			x86.AMOVW,
			x86.AMOVL,
			x86.AMOVQ,
			x86.AMOVLQZX:
			if regtyp(&p.To) && !regconsttyp(&p.From) {
				pushback(r)
			}
		}
	}

	gc.Flowend(g)
}

func pushback(r0 *gc.Flow) {
	var r *gc.Flow
	var p *obj.Prog

	var b *gc.Flow
	p0 := (*obj.Prog)(r0.Prog)
	for r = gc.Uniqp(r0); r != nil && gc.Uniqs(r) != nil; r = gc.Uniqp(r) {
		p = r.Prog
		if p.As != obj.ANOP {
			if !regconsttyp(&p.From) || !regtyp(&p.To) {
				break
			}
			if copyu(p, &p0.To, nil) != 0 || copyu(p0, &p.To, nil) != 0 {
				break
			}
		}

		if p.As == obj.ACALL {
			break
		}
		b = r
	}

	if b == nil {
		if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
			fmt.Printf("no pushback: %v\n", r0.Prog)
			if r != nil {
				fmt.Printf("\t%v [%v]\n", r.Prog, gc.Uniqs(r) != nil)
			}
		}

		return
	}

	if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
		fmt.Printf("pushback\n")
		for r := (*gc.Flow)(b); ; r = r.Link {
			fmt.Printf("\t%v\n", r.Prog)
			if r == r0 {
				break
			}
		}
	}

	t := obj.Prog(*r0.Prog)
	for r = gc.Uniqp(r0); ; r = gc.Uniqp(r) {
		p0 = r.Link.Prog
		p = r.Prog
		p0.As = p.As
		p0.Lineno = p.Lineno
		p0.From = p.From
		p0.To = p.To

		if r == b {
			break
		}
	}

	p0 = r.Prog
	p0.As = t.As
	p0.Lineno = t.Lineno
	p0.From = t.From
	p0.To = t.To

	if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
		fmt.Printf("\tafter\n")
		for r := (*gc.Flow)(b); ; r = r.Link {
			fmt.Printf("\t%v\n", r.Prog)
			if r == r0 {
				break
			}
		}
	}
}

func excise(r *gc.Flow) {
	p := (*obj.Prog)(r.Prog)
	if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
		fmt.Printf("%v ===delete===\n", p)
	}

	obj.Nopout(p)

	gc.Ostats.Ndelmov++
}

func regtyp(a *obj.Addr) bool {
	return a.Type == obj.TYPE_REG && (x86.REG_AX <= a.Reg && a.Reg <= x86.REG_R15 || x86.REG_X0 <= a.Reg && a.Reg <= x86.REG_X15)
}

// movb elimination.
// movb is simulated by the linker
// when a register other than ax, bx, cx, dx
// is used, so rewrite to other instructions
// when possible.  a movb into a register
// can smash the entire 32-bit register without
// causing any trouble.
//
// TODO: Using the Q forms here instead of the L forms
// seems unnecessary, and it makes the instructions longer.
func elimshortmov(g *gc.Graph) {
	var p *obj.Prog

	for r := (*gc.Flow)(g.Start); r != nil; r = r.Link {
		p = r.Prog
		if regtyp(&p.To) {
			switch p.As {
			case x86.AINCB,
				x86.AINCW:
				p.As = x86.AINCQ

			case x86.ADECB,
				x86.ADECW:
				p.As = x86.ADECQ

			case x86.ANEGB,
				x86.ANEGW:
				p.As = x86.ANEGQ

			case x86.ANOTB,
				x86.ANOTW:
				p.As = x86.ANOTQ
			}

			if regtyp(&p.From) || p.From.Type == obj.TYPE_CONST {
				// move or artihmetic into partial register.
				// from another register or constant can be movl.
				// we don't switch to 64-bit arithmetic if it can
				// change how the carry bit is set (and the carry bit is needed).
				switch p.As {
				case x86.AMOVB,
					x86.AMOVW:
					p.As = x86.AMOVQ

				case x86.AADDB,
					x86.AADDW:
					if !needc(p.Link) {
						p.As = x86.AADDQ
					}

				case x86.ASUBB,
					x86.ASUBW:
					if !needc(p.Link) {
						p.As = x86.ASUBQ
					}

				case x86.AMULB,
					x86.AMULW:
					p.As = x86.AMULQ

				case x86.AIMULB,
					x86.AIMULW:
					p.As = x86.AIMULQ

				case x86.AANDB,
					x86.AANDW:
					p.As = x86.AANDQ

				case x86.AORB,
					x86.AORW:
					p.As = x86.AORQ

				case x86.AXORB,
					x86.AXORW:
					p.As = x86.AXORQ

				case x86.ASHLB,
					x86.ASHLW:
					p.As = x86.ASHLQ
				}
			} else if p.From.Type != obj.TYPE_REG {
				// explicit zero extension, but don't
				// do that if source is a byte register
				// (only AH can occur and it's forbidden).
				switch p.As {
				case x86.AMOVB:
					p.As = x86.AMOVBQZX

				case x86.AMOVW:
					p.As = x86.AMOVWQZX
				}
			}
		}
	}
}

// is 'a' a register or constant?
func regconsttyp(a *obj.Addr) bool {
	if regtyp(a) {
		return true
	}
	switch a.Type {
	case obj.TYPE_CONST,
		obj.TYPE_FCONST,
		obj.TYPE_SCONST,
		obj.TYPE_ADDR: // TODO(rsc): Not all TYPE_ADDRs are constants.
		return true
	}

	return false
}

// is reg guaranteed to be truncated by a previous L instruction?
func prevl(r0 *gc.Flow, reg int) bool {
	for r := (*gc.Flow)(gc.Uniqp(r0)); r != nil; r = gc.Uniqp(r) {
		p := r.Prog
		if p.To.Type == obj.TYPE_REG && int(p.To.Reg) == reg {
			flags := progflags(p)
			if flags&gc.RightWrite != 0 {
				if flags&gc.SizeL != 0 {
					return true
				}
				return false
			}
		}
	}

	return false
}

/*
 * the idea is to substitute
 * one register for another
 * from one MOV to another
 *	MOV	a, R0
 *	ADD	b, R0	/ no use of R1
 *	MOV	R0, R1
 * would be converted to
 *	MOV	a, R1
 *	ADD	b, R1
 *	MOV	R1, R0
 * hopefully, then the former or latter MOV
 * will be eliminated by copy propagation.
 */
func subprop(r0 *gc.Flow) bool {
	if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
		fmt.Printf("subprop %v\n", r0.Prog)
	}
	p := (*obj.Prog)(r0.Prog)
	v1 := (*obj.Addr)(&p.From)
	if !regtyp(v1) {
		if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
			fmt.Printf("\tnot regtype %v; return 0\n", gc.Ctxt.Dconv(v1))
		}
		return false
	}

	v2 := (*obj.Addr)(&p.To)
	if !regtyp(v2) {
		if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
			fmt.Printf("\tnot regtype %v; return 0\n", gc.Ctxt.Dconv(v2))
		}
		return false
	}

	for r := gc.Uniqp(r0); r != nil; r = gc.Uniqp(r) {
		if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
			fmt.Printf("\t? %v\n", r.Prog)
		}
		if gc.Uniqs(r) == nil {
			if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
				fmt.Printf("\tno unique successor\n")
			}
			break
		}

		p = r.Prog
		if p.As == obj.AVARDEF || p.As == obj.AVARKILL {
			continue
		}
		if p.Info.Flags&gc.Call != 0 {
			if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
				fmt.Printf("\tfound %v; return 0\n", p)
			}
			return false
		}

		if p.Info.Reguse|p.Info.Regset != 0 {
			if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
				fmt.Printf("\tfound %v; return 0\n", p)
			}
			return false
		}

		if (p.Info.Flags&gc.Move != 0) && (p.Info.Flags&(gc.SizeL|gc.SizeQ|gc.SizeF|gc.SizeD) != 0) && p.To.Type == v1.Type && p.To.Reg == v1.Reg {
			copysub(&p.To, v1, v2, 1)
			if gc.Debug['P'] != 0 {
				fmt.Printf("gotit: %v->%v\n%v", gc.Ctxt.Dconv(v1), gc.Ctxt.Dconv(v2), r.Prog)
				if p.From.Type == v2.Type && p.From.Reg == v2.Reg {
					fmt.Printf(" excise")
				}
				fmt.Printf("\n")
			}

			for r = gc.Uniqs(r); r != r0; r = gc.Uniqs(r) {
				p = r.Prog
				copysub(&p.From, v1, v2, 1)
				copysub(&p.To, v1, v2, 1)
				if gc.Debug['P'] != 0 {
					fmt.Printf("%v\n", r.Prog)
				}
			}

			t := int(int(v1.Reg))
			v1.Reg = v2.Reg
			v2.Reg = int16(t)
			if gc.Debug['P'] != 0 {
				fmt.Printf("%v last\n", r.Prog)
			}
			return true
		}

		if copyau(&p.From, v2) || copyau(&p.To, v2) {
			if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
				fmt.Printf("\tcopyau %v failed\n", gc.Ctxt.Dconv(v2))
			}
			break
		}

		if copysub(&p.From, v1, v2, 0) != 0 || copysub(&p.To, v1, v2, 0) != 0 {
			if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
				fmt.Printf("\tcopysub failed\n")
			}
			break
		}
	}

	if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
		fmt.Printf("\tran off end; return 0\n")
	}
	return false
}

/*
 * The idea is to remove redundant copies.
 *	v1->v2	F=0
 *	(use v2	s/v2/v1/)*
 *	set v1	F=1
 *	use v2	return fail
 *	-----------------
 *	v1->v2	F=0
 *	(use v2	s/v2/v1/)*
 *	set v1	F=1
 *	set v2	return success
 */
func copyprop(g *gc.Graph, r0 *gc.Flow) bool {
	if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
		fmt.Printf("copyprop %v\n", r0.Prog)
	}
	p := (*obj.Prog)(r0.Prog)
	v1 := (*obj.Addr)(&p.From)
	v2 := (*obj.Addr)(&p.To)
	if copyas(v1, v2) {
		return true
	}
	gactive++
	return copy1(v1, v2, r0.S1, 0)
}

func copy1(v1 *obj.Addr, v2 *obj.Addr, r *gc.Flow, f int) bool {
	if uint32(r.Active) == gactive {
		if gc.Debug['P'] != 0 {
			fmt.Printf("act set; return 1\n")
		}
		return true
	}

	r.Active = int32(gactive)
	if gc.Debug['P'] != 0 {
		fmt.Printf("copy %v->%v f=%d\n", gc.Ctxt.Dconv(v1), gc.Ctxt.Dconv(v2), f)
	}
	var t int
	var p *obj.Prog
	for ; r != nil; r = r.S1 {
		p = r.Prog
		if gc.Debug['P'] != 0 {
			fmt.Printf("%v", p)
		}
		if f == 0 && gc.Uniqp(r) == nil {
			f = 1
			if gc.Debug['P'] != 0 {
				fmt.Printf("; merge; f=%d", f)
			}
		}

		t = copyu(p, v2, nil)
		switch t {
		case 2: /* rar, can't split */
			if gc.Debug['P'] != 0 {
				fmt.Printf("; %v rar; return 0\n", gc.Ctxt.Dconv(v2))
			}
			return false

		case 3: /* set */
			if gc.Debug['P'] != 0 {
				fmt.Printf("; %v set; return 1\n", gc.Ctxt.Dconv(v2))
			}
			return true

		case 1, /* used, substitute */
			4: /* use and set */
			if f != 0 {
				if gc.Debug['P'] == 0 {
					return false
				}
				if t == 4 {
					fmt.Printf("; %v used+set and f=%d; return 0\n", gc.Ctxt.Dconv(v2), f)
				} else {
					fmt.Printf("; %v used and f=%d; return 0\n", gc.Ctxt.Dconv(v2), f)
				}
				return false
			}

			if copyu(p, v2, v1) != 0 {
				if gc.Debug['P'] != 0 {
					fmt.Printf("; sub fail; return 0\n")
				}
				return false
			}

			if gc.Debug['P'] != 0 {
				fmt.Printf("; sub %v/%v", gc.Ctxt.Dconv(v2), gc.Ctxt.Dconv(v1))
			}
			if t == 4 {
				if gc.Debug['P'] != 0 {
					fmt.Printf("; %v used+set; return 1\n", gc.Ctxt.Dconv(v2))
				}
				return true
			}
		}

		if f == 0 {
			t = copyu(p, v1, nil)
			if f == 0 && (t == 2 || t == 3 || t == 4) {
				f = 1
				if gc.Debug['P'] != 0 {
					fmt.Printf("; %v set and !f; f=%d", gc.Ctxt.Dconv(v1), f)
				}
			}
		}

		if gc.Debug['P'] != 0 {
			fmt.Printf("\n")
		}
		if r.S2 != nil {
			if !copy1(v1, v2, r.S2, f) {
				return false
			}
		}
	}

	return true
}

/*
 * return
 * 1 if v only used (and substitute),
 * 2 if read-alter-rewrite
 * 3 if set
 * 4 if set and used
 * 0 otherwise (not touched)
 */
func copyu(p *obj.Prog, v *obj.Addr, s *obj.Addr) int {
	switch p.As {
	case obj.AJMP:
		if s != nil {
			if copysub(&p.To, v, s, 1) != 0 {
				return 1
			}
			return 0
		}

		if copyau(&p.To, v) {
			return 1
		}
		return 0

	case obj.ARET:
		if s != nil {
			return 1
		}
		return 3

	case obj.ACALL:
		if x86.REGEXT != 0 /*TypeKind(100016)*/ && v.Type == obj.TYPE_REG && v.Reg <= x86.REGEXT && v.Reg > exregoffset {
			return 2
		}
		if x86.REGARG >= 0 && v.Type == obj.TYPE_REG && v.Reg == x86.REGARG {
			return 2
		}
		if v.Type == p.From.Type && v.Reg == p.From.Reg {
			return 2
		}

		if s != nil {
			if copysub(&p.To, v, s, 1) != 0 {
				return 1
			}
			return 0
		}

		if copyau(&p.To, v) {
			return 4
		}
		return 3

	case obj.ATEXT:
		if x86.REGARG >= 0 && v.Type == obj.TYPE_REG && v.Reg == x86.REGARG {
			return 3
		}
		return 0
	}

	if p.As == obj.AVARDEF || p.As == obj.AVARKILL {
		return 0
	}

	if (p.Info.Reguse|p.Info.Regset)&RtoB(int(v.Reg)) != 0 {
		return 2
	}

	if (p.Info.Reguse|p.Info.Regset)&FtoB(int(v.Reg)) != 0 {
		return 2
	}

	if p.Info.Flags&gc.LeftAddr != 0 {
		if copyas(&p.From, v) {
			return 2
		}
	}

	if p.Info.Flags&(gc.RightRead|gc.RightWrite) == gc.RightRead|gc.RightWrite {
		if copyas(&p.To, v) {
			return 2
		}
	}

	if p.Info.Flags&gc.RightWrite != 0 {
		if copyas(&p.To, v) {
			if s != nil {
				return copysub(&p.From, v, s, 1)
			}
			if copyau(&p.From, v) {
				return 4
			}
			return 3
		}
	}

	if p.Info.Flags&(gc.LeftAddr|gc.LeftRead|gc.LeftWrite|gc.RightAddr|gc.RightRead|gc.RightWrite) != 0 {
		if s != nil {
			if copysub(&p.From, v, s, 1) != 0 {
				return 1
			}
			return copysub(&p.To, v, s, 1)
		}

		if copyau(&p.From, v) {
			return 1
		}
		if copyau(&p.To, v) {
			return 1
		}
	}

	return 0
}

/*
 * direct reference,
 * could be set/use depending on
 * semantics
 */
func copyas(a *obj.Addr, v *obj.Addr) bool {
	if x86.REG_AL <= a.Reg && a.Reg <= x86.REG_R15B {
		gc.Fatalf("use of byte register")
	}
	if x86.REG_AL <= v.Reg && v.Reg <= x86.REG_R15B {
		gc.Fatalf("use of byte register")
	}

	if a.Type != v.Type || a.Name != v.Name || a.Reg != v.Reg {
		return false
	}
	if regtyp(v) {
		return true
	}
	if v.Type == obj.TYPE_MEM && (v.Name == obj.NAME_AUTO || v.Name == obj.NAME_PARAM) {
		if v.Offset == a.Offset {
			return true
		}
	}
	return false
}

func sameaddr(a *obj.Addr, v *obj.Addr) bool {
	if a.Type != v.Type || a.Name != v.Name || a.Reg != v.Reg {
		return false
	}
	if regtyp(v) {
		return true
	}
	if v.Type == obj.TYPE_MEM && (v.Name == obj.NAME_AUTO || v.Name == obj.NAME_PARAM) {
		if v.Offset == a.Offset {
			return true
		}
	}
	return false
}

/*
 * either direct or indirect
 */
func copyau(a *obj.Addr, v *obj.Addr) bool {
	if copyas(a, v) {
		if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
			fmt.Printf("\tcopyau: copyas returned 1\n")
		}
		return true
	}

	if regtyp(v) {
		if a.Type == obj.TYPE_MEM && a.Reg == v.Reg {
			if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
				fmt.Printf("\tcopyau: found indir use - return 1\n")
			}
			return true
		}

		if a.Index == v.Reg {
			if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
				fmt.Printf("\tcopyau: found index use - return 1\n")
			}
			return true
		}
	}

	return false
}

/*
 * substitute s for v in a
 * return failure to substitute
 */
func copysub(a *obj.Addr, v *obj.Addr, s *obj.Addr, f int) int {
	if copyas(a, v) {
		reg := int(int(s.Reg))
		if reg >= x86.REG_AX && reg <= x86.REG_R15 || reg >= x86.REG_X0 && reg <= x86.REG_X0+15 {
			if f != 0 {
				a.Reg = int16(reg)
			}
		}

		return 0
	}

	if regtyp(v) {
		reg := int(int(v.Reg))
		if a.Type == obj.TYPE_MEM && int(a.Reg) == reg {
			if (s.Reg == x86.REG_BP || s.Reg == x86.REG_R13) && a.Index != x86.REG_NONE {
				return 1 /* can't use BP-base with index */
			}
			if f != 0 {
				a.Reg = s.Reg
			}
		}

		//			return 0;
		if int(a.Index) == reg {
			if f != 0 {
				a.Index = s.Reg
			}
			return 0
		}

		return 0
	}

	return 0
}

func conprop(r0 *gc.Flow) {
	var p *obj.Prog
	var t int

	p0 := (*obj.Prog)(r0.Prog)
	v0 := (*obj.Addr)(&p0.To)
	r := (*gc.Flow)(r0)

loop:
	r = gc.Uniqs(r)
	if r == nil || r == r0 {
		return
	}
	if gc.Uniqp(r) == nil {
		return
	}

	p = r.Prog
	t = copyu(p, v0, nil)
	switch t {
	case 0, // miss
		1: // use
		goto loop

	case 2, // rar
		4: // use and set
		break

	case 3: // set
		if p.As == p0.As {
			if p.From.Type == p0.From.Type {
				if p.From.Reg == p0.From.Reg {
					if p.From.Node == p0.From.Node {
						if p.From.Offset == p0.From.Offset {
							if p.From.Scale == p0.From.Scale {
								if p.From.Type == obj.TYPE_FCONST && p.From.Val.(float64) == p0.From.Val.(float64) {
									if p.From.Index == p0.From.Index {
										excise(r)
										goto loop
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

func smallindir(a *obj.Addr, reg *obj.Addr) bool {
	return regtyp(reg) && a.Type == obj.TYPE_MEM && a.Reg == reg.Reg && a.Index == x86.REG_NONE && 0 <= a.Offset && a.Offset < 4096
}

func stackaddr(a *obj.Addr) bool {
	return a.Type == obj.TYPE_REG && a.Reg == x86.REG_SP
}
                                                                                                                                                usr/local/go/src/cmd/compile/internal/amd64/prog.go                                                 0100644 0000000 0000000 00000043004 13020111411 020545  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package amd64

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/x86"
)

const (
	LeftRdwr  uint32 = gc.LeftRead | gc.LeftWrite
	RightRdwr uint32 = gc.RightRead | gc.RightWrite
)

// This table gives the basic information about instruction
// generated by the compiler and processed in the optimizer.
// See opt.h for bit definitions.
//
// Instructions not generated need not be listed.
// As an exception to that rule, we typically write down all the
// size variants of an operation even if we just use a subset.
//
// The table is formatted for 8-space tabs.
var progtable = [x86.ALAST]obj.ProgInfo{
	obj.ATYPE:     {Flags: gc.Pseudo | gc.Skip},
	obj.ATEXT:     {Flags: gc.Pseudo},
	obj.AFUNCDATA: {Flags: gc.Pseudo},
	obj.APCDATA:   {Flags: gc.Pseudo},
	obj.AUNDEF:    {Flags: gc.Break},
	obj.AUSEFIELD: {Flags: gc.OK},
	obj.ACHECKNIL: {Flags: gc.LeftRead},
	obj.AVARDEF:   {Flags: gc.Pseudo | gc.RightWrite},
	obj.AVARKILL:  {Flags: gc.Pseudo | gc.RightWrite},
	obj.AVARLIVE:  {Flags: gc.Pseudo | gc.LeftRead},

	// NOP is an internal no-op that also stands
	// for USED and SET annotations, not the Intel opcode.
	obj.ANOP:       {Flags: gc.LeftRead | gc.RightWrite},
	x86.AADCL:      {Flags: gc.SizeL | gc.LeftRead | RightRdwr | gc.SetCarry | gc.UseCarry},
	x86.AADCQ:      {Flags: gc.SizeQ | gc.LeftRead | RightRdwr | gc.SetCarry | gc.UseCarry},
	x86.AADCW:      {Flags: gc.SizeW | gc.LeftRead | RightRdwr | gc.SetCarry | gc.UseCarry},
	x86.AADDB:      {Flags: gc.SizeB | gc.LeftRead | RightRdwr | gc.SetCarry},
	x86.AADDL:      {Flags: gc.SizeL | gc.LeftRead | RightRdwr | gc.SetCarry},
	x86.AADDW:      {Flags: gc.SizeW | gc.LeftRead | RightRdwr | gc.SetCarry},
	x86.AADDQ:      {Flags: gc.SizeQ | gc.LeftRead | RightRdwr | gc.SetCarry},
	x86.AADDSD:     {Flags: gc.SizeD | gc.LeftRead | RightRdwr},
	x86.AADDSS:     {Flags: gc.SizeF | gc.LeftRead | RightRdwr},
	x86.AANDB:      {Flags: gc.SizeB | gc.LeftRead | RightRdwr | gc.SetCarry},
	x86.AANDL:      {Flags: gc.SizeL | gc.LeftRead | RightRdwr | gc.SetCarry},
	x86.AANDQ:      {Flags: gc.SizeQ | gc.LeftRead | RightRdwr | gc.SetCarry},
	x86.AANDW:      {Flags: gc.SizeW | gc.LeftRead | RightRdwr | gc.SetCarry},
	obj.ACALL:      {Flags: gc.RightAddr | gc.Call | gc.KillCarry},
	x86.ACDQ:       {Flags: gc.OK, Reguse: AX, Regset: AX | DX},
	x86.ACQO:       {Flags: gc.OK, Reguse: AX, Regset: AX | DX},
	x86.ACWD:       {Flags: gc.OK, Reguse: AX, Regset: AX | DX},
	x86.ACLD:       {Flags: gc.OK},
	x86.ASTD:       {Flags: gc.OK},
	x86.ACMPB:      {Flags: gc.SizeB | gc.LeftRead | gc.RightRead | gc.SetCarry},
	x86.ACMPL:      {Flags: gc.SizeL | gc.LeftRead | gc.RightRead | gc.SetCarry},
	x86.ACMPQ:      {Flags: gc.SizeQ | gc.LeftRead | gc.RightRead | gc.SetCarry},
	x86.ACMPW:      {Flags: gc.SizeW | gc.LeftRead | gc.RightRead | gc.SetCarry},
	x86.ACOMISD:    {Flags: gc.SizeD | gc.LeftRead | gc.RightRead | gc.SetCarry},
	x86.ACOMISS:    {Flags: gc.SizeF | gc.LeftRead | gc.RightRead | gc.SetCarry},
	x86.ACVTSD2SL:  {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.ACVTSD2SQ:  {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.ACVTSD2SS:  {Flags: gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.ACVTSL2SD:  {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.ACVTSL2SS:  {Flags: gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.ACVTSQ2SD:  {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.ACVTSQ2SS:  {Flags: gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.ACVTSS2SD:  {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.ACVTSS2SL:  {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.ACVTSS2SQ:  {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.ACVTTSD2SL: {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.ACVTTSD2SQ: {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.ACVTTSS2SL: {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.ACVTTSS2SQ: {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.ADECB:      {Flags: gc.SizeB | RightRdwr},
	x86.ADECL:      {Flags: gc.SizeL | RightRdwr},
	x86.ADECQ:      {Flags: gc.SizeQ | RightRdwr},
	x86.ADECW:      {Flags: gc.SizeW | RightRdwr},
	x86.ADIVB:      {Flags: gc.SizeB | gc.LeftRead | gc.SetCarry, Reguse: AX, Regset: AX},
	x86.ADIVL:      {Flags: gc.SizeL | gc.LeftRead | gc.SetCarry, Reguse: AX | DX, Regset: AX | DX},
	x86.ADIVQ:      {Flags: gc.SizeQ | gc.LeftRead | gc.SetCarry, Reguse: AX | DX, Regset: AX | DX},
	x86.ADIVW:      {Flags: gc.SizeW | gc.LeftRead | gc.SetCarry, Reguse: AX | DX, Regset: AX | DX},
	x86.ADIVSD:     {Flags: gc.SizeD | gc.LeftRead | RightRdwr},
	x86.ADIVSS:     {Flags: gc.SizeF | gc.LeftRead | RightRdwr},
	x86.AIDIVB:     {Flags: gc.SizeB | gc.LeftRead | gc.SetCarry, Reguse: AX, Regset: AX},
	x86.AIDIVL:     {Flags: gc.SizeL | gc.LeftRead | gc.SetCarry, Reguse: AX | DX, Regset: AX | DX},
	x86.AIDIVQ:     {Flags: gc.SizeQ | gc.LeftRead | gc.SetCarry, Reguse: AX | DX, Regset: AX | DX},
	x86.AIDIVW:     {Flags: gc.SizeW | gc.LeftRead | gc.SetCarry, Reguse: AX | DX, Regset: AX | DX},
	x86.AIMULB:     {Flags: gc.SizeB | gc.LeftRead | gc.SetCarry, Reguse: AX, Regset: AX},
	x86.AIMULL:     {Flags: gc.SizeL | gc.LeftRead | gc.ImulAXDX | gc.SetCarry},
	x86.AIMULQ:     {Flags: gc.SizeQ | gc.LeftRead | gc.ImulAXDX | gc.SetCarry},
	x86.AIMULW:     {Flags: gc.SizeW | gc.LeftRead | gc.ImulAXDX | gc.SetCarry},
	x86.AINCB:      {Flags: gc.SizeB | RightRdwr},
	x86.AINCL:      {Flags: gc.SizeL | RightRdwr},
	x86.AINCQ:      {Flags: gc.SizeQ | RightRdwr},
	x86.AINCW:      {Flags: gc.SizeW | RightRdwr},
	x86.AJCC:       {Flags: gc.Cjmp | gc.UseCarry},
	x86.AJCS:       {Flags: gc.Cjmp | gc.UseCarry},
	x86.AJEQ:       {Flags: gc.Cjmp | gc.UseCarry},
	x86.AJGE:       {Flags: gc.Cjmp | gc.UseCarry},
	x86.AJGT:       {Flags: gc.Cjmp | gc.UseCarry},
	x86.AJHI:       {Flags: gc.Cjmp | gc.UseCarry},
	x86.AJLE:       {Flags: gc.Cjmp | gc.UseCarry},
	x86.AJLS:       {Flags: gc.Cjmp | gc.UseCarry},
	x86.AJLT:       {Flags: gc.Cjmp | gc.UseCarry},
	x86.AJMI:       {Flags: gc.Cjmp | gc.UseCarry},
	x86.AJNE:       {Flags: gc.Cjmp | gc.UseCarry},
	x86.AJOC:       {Flags: gc.Cjmp | gc.UseCarry},
	x86.AJOS:       {Flags: gc.Cjmp | gc.UseCarry},
	x86.AJPC:       {Flags: gc.Cjmp | gc.UseCarry},
	x86.AJPL:       {Flags: gc.Cjmp | gc.UseCarry},
	x86.AJPS:       {Flags: gc.Cjmp | gc.UseCarry},
	obj.AJMP:       {Flags: gc.Jump | gc.Break | gc.KillCarry},
	x86.ALEAL:      {Flags: gc.LeftAddr | gc.RightWrite},
	x86.ALEAQ:      {Flags: gc.LeftAddr | gc.RightWrite},
	x86.AMOVBLSX:   {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.AMOVBLZX:   {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.AMOVBQSX:   {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.AMOVBQZX:   {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.AMOVBWSX:   {Flags: gc.SizeW | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.AMOVBWZX:   {Flags: gc.SizeW | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.AMOVLQSX:   {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.AMOVLQZX:   {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.AMOVWLSX:   {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.AMOVWLZX:   {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.AMOVWQSX:   {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.AMOVWQZX:   {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.AMOVQL:     {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv},
	x86.AMOVB:      {Flags: gc.SizeB | gc.LeftRead | gc.RightWrite | gc.Move},
	x86.AMOVL:      {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Move},
	x86.AMOVQ:      {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Move},
	x86.AMOVW:      {Flags: gc.SizeW | gc.LeftRead | gc.RightWrite | gc.Move},
	x86.AMOVUPS:    {Flags: gc.LeftRead | gc.RightWrite | gc.Move},
	x86.AMOVSB:     {Flags: gc.OK, Reguse: DI | SI, Regset: DI | SI},
	x86.AMOVSL:     {Flags: gc.OK, Reguse: DI | SI, Regset: DI | SI},
	x86.AMOVSQ:     {Flags: gc.OK, Reguse: DI | SI, Regset: DI | SI},
	x86.AMOVSW:     {Flags: gc.OK, Reguse: DI | SI, Regset: DI | SI},
	obj.ADUFFCOPY:  {Flags: gc.OK, Reguse: DI | SI, Regset: DI | SI | X0},
	x86.AMOVSD:     {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Move},
	x86.AMOVSS:     {Flags: gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Move},

	// We use MOVAPD as a faster synonym for MOVSD.
	x86.AMOVAPD:   {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Move},
	x86.AMULB:     {Flags: gc.SizeB | gc.LeftRead | gc.SetCarry, Reguse: AX, Regset: AX},
	x86.AMULL:     {Flags: gc.SizeL | gc.LeftRead | gc.SetCarry, Reguse: AX, Regset: AX | DX},
	x86.AMULQ:     {Flags: gc.SizeQ | gc.LeftRead | gc.SetCarry, Reguse: AX, Regset: AX | DX},
	x86.AMULW:     {Flags: gc.SizeW | gc.LeftRead | gc.SetCarry, Reguse: AX, Regset: AX | DX},
	x86.AMULSD:    {Flags: gc.SizeD | gc.LeftRead | RightRdwr},
	x86.AMULSS:    {Flags: gc.SizeF | gc.LeftRead | RightRdwr},
	x86.ANEGB:     {Flags: gc.SizeB | RightRdwr | gc.SetCarry},
	x86.ANEGL:     {Flags: gc.SizeL | RightRdwr | gc.SetCarry},
	x86.ANEGQ:     {Flags: gc.SizeQ | RightRdwr | gc.SetCarry},
	x86.ANEGW:     {Flags: gc.SizeW | RightRdwr | gc.SetCarry},
	x86.ANOTB:     {Flags: gc.SizeB | RightRdwr},
	x86.ANOTL:     {Flags: gc.SizeL | RightRdwr},
	x86.ANOTQ:     {Flags: gc.SizeQ | RightRdwr},
	x86.ANOTW:     {Flags: gc.SizeW | RightRdwr},
	x86.AORB:      {Flags: gc.SizeB | gc.LeftRead | RightRdwr | gc.SetCarry},
	x86.AORL:      {Flags: gc.SizeL | gc.LeftRead | RightRdwr | gc.SetCarry},
	x86.AORQ:      {Flags: gc.SizeQ | gc.LeftRead | RightRdwr | gc.SetCarry},
	x86.AORW:      {Flags: gc.SizeW | gc.LeftRead | RightRdwr | gc.SetCarry},
	x86.APOPQ:     {Flags: gc.SizeQ | gc.RightWrite},
	x86.APUSHQ:    {Flags: gc.SizeQ | gc.LeftRead},
	x86.ARCLB:     {Flags: gc.SizeB | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry | gc.UseCarry},
	x86.ARCLL:     {Flags: gc.SizeL | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry | gc.UseCarry},
	x86.ARCLQ:     {Flags: gc.SizeQ | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry | gc.UseCarry},
	x86.ARCLW:     {Flags: gc.SizeW | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry | gc.UseCarry},
	x86.ARCRB:     {Flags: gc.SizeB | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry | gc.UseCarry},
	x86.ARCRL:     {Flags: gc.SizeL | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry | gc.UseCarry},
	x86.ARCRQ:     {Flags: gc.SizeQ | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry | gc.UseCarry},
	x86.ARCRW:     {Flags: gc.SizeW | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry | gc.UseCarry},
	x86.AREP:      {Flags: gc.OK, Reguse: CX, Regset: CX},
	x86.AREPN:     {Flags: gc.OK, Reguse: CX, Regset: CX},
	obj.ARET:      {Flags: gc.Break | gc.KillCarry},
	x86.AROLB:     {Flags: gc.SizeB | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.AROLL:     {Flags: gc.SizeL | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.AROLQ:     {Flags: gc.SizeQ | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.AROLW:     {Flags: gc.SizeW | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ARORB:     {Flags: gc.SizeB | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ARORL:     {Flags: gc.SizeL | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ARORQ:     {Flags: gc.SizeQ | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ARORW:     {Flags: gc.SizeW | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ASALB:     {Flags: gc.SizeB | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ASALL:     {Flags: gc.SizeL | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ASALQ:     {Flags: gc.SizeQ | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ASALW:     {Flags: gc.SizeW | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ASARB:     {Flags: gc.SizeB | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ASARL:     {Flags: gc.SizeL | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ASARQ:     {Flags: gc.SizeQ | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ASARW:     {Flags: gc.SizeW | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ASBBB:     {Flags: gc.SizeB | gc.LeftRead | RightRdwr | gc.SetCarry | gc.UseCarry},
	x86.ASBBL:     {Flags: gc.SizeL | gc.LeftRead | RightRdwr | gc.SetCarry | gc.UseCarry},
	x86.ASBBQ:     {Flags: gc.SizeQ | gc.LeftRead | RightRdwr | gc.SetCarry | gc.UseCarry},
	x86.ASBBW:     {Flags: gc.SizeW | gc.LeftRead | RightRdwr | gc.SetCarry | gc.UseCarry},
	x86.ASETCC:    {Flags: gc.SizeB | gc.RightWrite | gc.UseCarry},
	x86.ASETCS:    {Flags: gc.SizeB | gc.RightWrite | gc.UseCarry},
	x86.ASETEQ:    {Flags: gc.SizeB | gc.RightWrite | gc.UseCarry},
	x86.ASETGE:    {Flags: gc.SizeB | gc.RightWrite | gc.UseCarry},
	x86.ASETGT:    {Flags: gc.SizeB | gc.RightWrite | gc.UseCarry},
	x86.ASETHI:    {Flags: gc.SizeB | gc.RightWrite | gc.UseCarry},
	x86.ASETLE:    {Flags: gc.SizeB | gc.RightWrite | gc.UseCarry},
	x86.ASETLS:    {Flags: gc.SizeB | gc.RightWrite | gc.UseCarry},
	x86.ASETLT:    {Flags: gc.SizeB | gc.RightWrite | gc.UseCarry},
	x86.ASETMI:    {Flags: gc.SizeB | gc.RightWrite | gc.UseCarry},
	x86.ASETNE:    {Flags: gc.SizeB | gc.RightWrite | gc.UseCarry},
	x86.ASETOC:    {Flags: gc.SizeB | gc.RightWrite | gc.UseCarry},
	x86.ASETOS:    {Flags: gc.SizeB | gc.RightWrite | gc.UseCarry},
	x86.ASETPC:    {Flags: gc.SizeB | gc.RightWrite | gc.UseCarry},
	x86.ASETPL:    {Flags: gc.SizeB | gc.RightWrite | gc.UseCarry},
	x86.ASETPS:    {Flags: gc.SizeB | gc.RightWrite | gc.UseCarry},
	x86.ASHLB:     {Flags: gc.SizeB | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ASHLL:     {Flags: gc.SizeL | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ASHLQ:     {Flags: gc.SizeQ | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ASHLW:     {Flags: gc.SizeW | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ASHRB:     {Flags: gc.SizeB | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ASHRL:     {Flags: gc.SizeL | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ASHRQ:     {Flags: gc.SizeQ | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ASHRW:     {Flags: gc.SizeW | gc.LeftRead | RightRdwr | gc.ShiftCX | gc.SetCarry},
	x86.ASQRTSD:   {Flags: gc.SizeD | gc.LeftRead | RightRdwr},
	x86.ASTOSB:    {Flags: gc.OK, Reguse: AX | DI, Regset: DI},
	x86.ASTOSL:    {Flags: gc.OK, Reguse: AX | DI, Regset: DI},
	x86.ASTOSQ:    {Flags: gc.OK, Reguse: AX | DI, Regset: DI},
	x86.ASTOSW:    {Flags: gc.OK, Reguse: AX | DI, Regset: DI},
	obj.ADUFFZERO: {Flags: gc.OK, Reguse: X0 | DI, Regset: DI},
	x86.ASUBB:     {Flags: gc.SizeB | gc.LeftRead | RightRdwr | gc.SetCarry},
	x86.ASUBL:     {Flags: gc.SizeL | gc.LeftRead | RightRdwr | gc.SetCarry},
	x86.ASUBQ:     {Flags: gc.SizeQ | gc.LeftRead | RightRdwr | gc.SetCarry},
	x86.ASUBW:     {Flags: gc.SizeW | gc.LeftRead | RightRdwr | gc.SetCarry},
	x86.ASUBSD:    {Flags: gc.SizeD | gc.LeftRead | RightRdwr},
	x86.ASUBSS:    {Flags: gc.SizeF | gc.LeftRead | RightRdwr},
	x86.ATESTB:    {Flags: gc.SizeB | gc.LeftRead | gc.RightRead | gc.SetCarry},
	x86.ATESTL:    {Flags: gc.SizeL | gc.LeftRead | gc.RightRead | gc.SetCarry},
	x86.ATESTQ:    {Flags: gc.SizeQ | gc.LeftRead | gc.RightRead | gc.SetCarry},
	x86.ATESTW:    {Flags: gc.SizeW | gc.LeftRead | gc.RightRead | gc.SetCarry},
	x86.AUCOMISD:  {Flags: gc.SizeD | gc.LeftRead | gc.RightRead},
	x86.AUCOMISS:  {Flags: gc.SizeF | gc.LeftRead | gc.RightRead},
	x86.AXCHGB:    {Flags: gc.SizeB | LeftRdwr | RightRdwr},
	x86.AXCHGL:    {Flags: gc.SizeL | LeftRdwr | RightRdwr},
	x86.AXCHGQ:    {Flags: gc.SizeQ | LeftRdwr | RightRdwr},
	x86.AXCHGW:    {Flags: gc.SizeW | LeftRdwr | RightRdwr},
	x86.AXORB:     {Flags: gc.SizeB | gc.LeftRead | RightRdwr | gc.SetCarry},
	x86.AXORL:     {Flags: gc.SizeL | gc.LeftRead | RightRdwr | gc.SetCarry},
	x86.AXORQ:     {Flags: gc.SizeQ | gc.LeftRead | RightRdwr | gc.SetCarry},
	x86.AXORW:     {Flags: gc.SizeW | gc.LeftRead | RightRdwr | gc.SetCarry},
	x86.AXORPS:    {Flags: gc.LeftRead | RightRdwr},
}

func progflags(p *obj.Prog) uint32 {
	flags := progtable[p.As].Flags
	if flags&gc.ImulAXDX != 0 && p.To.Type != obj.TYPE_NONE {
		flags |= RightRdwr
	}
	return flags
}

func progcarryflags(p *obj.Prog) uint32 {
	return progtable[p.As].Flags
}

func proginfo(p *obj.Prog) {
	info := &p.Info
	*info = progtable[p.As]
	if info.Flags == 0 {
		gc.Fatalf("unknown instruction %v", p)
	}

	if (info.Flags&gc.ShiftCX != 0) && p.From.Type != obj.TYPE_CONST {
		info.Reguse |= CX
	}

	if info.Flags&gc.ImulAXDX != 0 {
		if p.To.Type == obj.TYPE_NONE {
			info.Reguse |= AX
			info.Regset |= AX | DX
		} else {
			info.Flags |= RightRdwr
		}
	}

	// Addressing makes some registers used.
	if p.From.Type == obj.TYPE_MEM && p.From.Name == obj.NAME_NONE {
		info.Regindex |= RtoB(int(p.From.Reg))
	}
	if p.From.Index != x86.REG_NONE {
		info.Regindex |= RtoB(int(p.From.Index))
	}
	if p.To.Type == obj.TYPE_MEM && p.To.Name == obj.NAME_NONE {
		info.Regindex |= RtoB(int(p.To.Reg))
	}
	if p.To.Index != x86.REG_NONE {
		info.Regindex |= RtoB(int(p.To.Index))
	}
	if gc.Ctxt.Flag_dynlink {
		// When -dynlink is passed, many operations on external names (and
		// also calling duffzero/duffcopy) use R15 as a scratch register.
		if p.As == x86.ALEAQ || info.Flags == gc.Pseudo || p.As == obj.ACALL || p.As == obj.ARET || p.As == obj.AJMP {
			return
		}
		if p.As == obj.ADUFFZERO || p.As == obj.ADUFFCOPY || (p.From.Name == obj.NAME_EXTERN && !p.From.Sym.Local) || (p.To.Name == obj.NAME_EXTERN && !p.To.Sym.Local) {
			info.Reguse |= R15
			info.Regset |= R15
			return
		}
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/local/go/src/cmd/compile/internal/amd64/reg.go                                                  0100644 0000000 0000000 00000007123 13020111411 020355  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Derived from Inferno utils/6c/reg.c
// http://code.google.com/p/inferno-os/source/browse/utils/6c/reg.c
//
//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright © 1997-1999 Vita Nuova Limited
//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright © 2004,2006 Bruce Ellis
//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package amd64

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/x86"
)

const (
	NREGVAR = 32
)

var regname = []string{
	".AX",
	".CX",
	".DX",
	".BX",
	".SP",
	".BP",
	".SI",
	".DI",
	".R8",
	".R9",
	".R10",
	".R11",
	".R12",
	".R13",
	".R14",
	".R15",
	".X0",
	".X1",
	".X2",
	".X3",
	".X4",
	".X5",
	".X6",
	".X7",
	".X8",
	".X9",
	".X10",
	".X11",
	".X12",
	".X13",
	".X14",
	".X15",
}

func regnames(n *int) []string {
	*n = NREGVAR
	return regname
}

func excludedregs() uint64 {
	return RtoB(x86.REG_SP)
}

func doregbits(r int) uint64 {
	b := uint64(0)
	if r >= x86.REG_AX && r <= x86.REG_R15 {
		b |= RtoB(r)
	} else if r >= x86.REG_AL && r <= x86.REG_R15B {
		b |= RtoB(r - x86.REG_AL + x86.REG_AX)
	} else if r >= x86.REG_AH && r <= x86.REG_BH {
		b |= RtoB(r - x86.REG_AH + x86.REG_AX)
	} else if r >= x86.REG_X0 && r <= x86.REG_X0+15 {
		b |= FtoB(r)
	}
	return b
}

// For ProgInfo.
const (
	AX  = 1 << (x86.REG_AX - x86.REG_AX)
	BX  = 1 << (x86.REG_BX - x86.REG_AX)
	CX  = 1 << (x86.REG_CX - x86.REG_AX)
	DX  = 1 << (x86.REG_DX - x86.REG_AX)
	DI  = 1 << (x86.REG_DI - x86.REG_AX)
	SI  = 1 << (x86.REG_SI - x86.REG_AX)
	R15 = 1 << (x86.REG_R15 - x86.REG_AX)
	X0  = 1 << 16
)

func RtoB(r int) uint64 {
	if r < x86.REG_AX || r > x86.REG_R15 {
		return 0
	}
	return 1 << uint(r-x86.REG_AX)
}

func BtoR(b uint64) int {
	b &= 0xffff
	if gc.Nacl {
		b &^= (1<<(x86.REG_BP-x86.REG_AX) | 1<<(x86.REG_R15-x86.REG_AX))
	} else if obj.Framepointer_enabled != 0 {
		// BP is part of the calling convention if framepointer_enabled.
		b &^= (1 << (x86.REG_BP - x86.REG_AX))
	}
	if b == 0 {
		return 0
	}
	return gc.Bitno(b) + x86.REG_AX
}

/*
 *	bit	reg
 *	16	X0
 *	...
 *	31	X15
 */
func FtoB(f int) uint64 {
	if f < x86.REG_X0 || f > x86.REG_X15 {
		return 0
	}
	return 1 << uint(f-x86.REG_X0+16)
}

func BtoF(b uint64) int {
	b &= 0xFFFF0000
	if b == 0 {
		return 0
	}
	return gc.Bitno(b) - 16 + x86.REG_X0
}
                                                                                                                                                                                                                                                                                                                                                                                                                                             usr/local/go/src/cmd/compile/internal/arm/                                                          0040755 0000000 0000000 00000000000 13020111411 017115  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/cmd/compile/internal/arm/cgen.go                                                   0100644 0000000 0000000 00000011157 13020111411 020362  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package arm

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/arm"
)

/*
 * generate array index into res.
 * n might be any size; res is 32-bit.
 * returns Prog* to patch to panic call.
 */
func cgenindex(n *gc.Node, res *gc.Node, bounded bool) *obj.Prog {
	if !gc.Is64(n.Type) {
		gc.Cgen(n, res)
		return nil
	}

	var tmp gc.Node
	gc.Tempname(&tmp, gc.Types[gc.TINT64])
	gc.Cgen(n, &tmp)
	var lo gc.Node
	var hi gc.Node
	split64(&tmp, &lo, &hi)
	gmove(&lo, res)
	if bounded {
		splitclean()
		return nil
	}

	var n1 gc.Node
	gc.Regalloc(&n1, gc.Types[gc.TINT32], nil)
	var n2 gc.Node
	gc.Regalloc(&n2, gc.Types[gc.TINT32], nil)
	var zero gc.Node
	gc.Nodconst(&zero, gc.Types[gc.TINT32], 0)
	gmove(&hi, &n1)
	gmove(&zero, &n2)
	gins(arm.ACMP, &n1, &n2)
	gc.Regfree(&n2)
	gc.Regfree(&n1)
	splitclean()
	return gc.Gbranch(arm.ABNE, nil, -1)
}

func igenindex(n *gc.Node, res *gc.Node, bounded bool) *obj.Prog {
	gc.Tempname(res, n.Type)
	return cgenindex(n, res, bounded)
}

func blockcopy(n, res *gc.Node, osrc, odst, w int64) {
	// determine alignment.
	// want to avoid unaligned access, so have to use
	// smaller operations for less aligned types.
	// for example moving [4]byte must use 4 MOVB not 1 MOVW.
	align := int(n.Type.Align)

	var op int
	switch align {
	default:
		gc.Fatalf("sgen: invalid alignment %d for %v", align, n.Type)

	case 1:
		op = arm.AMOVB

	case 2:
		op = arm.AMOVH

	case 4:
		op = arm.AMOVW
	}

	if w%int64(align) != 0 {
		gc.Fatalf("sgen: unaligned size %d (align=%d) for %v", w, align, n.Type)
	}
	c := int32(w / int64(align))

	if osrc%int64(align) != 0 || odst%int64(align) != 0 {
		gc.Fatalf("sgen: unaligned offset src %d or dst %d (align %d)", osrc, odst, align)
	}

	// if we are copying forward on the stack and
	// the src and dst overlap, then reverse direction
	dir := align
	if osrc < odst && int64(odst) < int64(osrc)+w {
		dir = -dir
	}

	if op == arm.AMOVW && !gc.Nacl && dir > 0 && c >= 4 && c <= 128 {
		var r0 gc.Node
		r0.Op = gc.OREGISTER
		r0.Reg = arm.REG_R0
		var r1 gc.Node
		r1.Op = gc.OREGISTER
		r1.Reg = arm.REG_R0 + 1
		var r2 gc.Node
		r2.Op = gc.OREGISTER
		r2.Reg = arm.REG_R0 + 2

		var src gc.Node
		gc.Regalloc(&src, gc.Types[gc.Tptr], &r1)
		var dst gc.Node
		gc.Regalloc(&dst, gc.Types[gc.Tptr], &r2)
		if n.Ullman >= res.Ullman {
			// eval n first
			gc.Agen(n, &src)

			if res.Op == gc.ONAME {
				gc.Gvardef(res)
			}
			gc.Agen(res, &dst)
		} else {
			// eval res first
			if res.Op == gc.ONAME {
				gc.Gvardef(res)
			}
			gc.Agen(res, &dst)
			gc.Agen(n, &src)
		}

		var tmp gc.Node
		gc.Regalloc(&tmp, gc.Types[gc.Tptr], &r0)
		f := gc.Sysfunc("duffcopy")
		p := gins(obj.ADUFFCOPY, nil, f)
		gc.Afunclit(&p.To, f)

		// 8 and 128 = magic constants: see ../../runtime/asm_arm.s
		p.To.Offset = 8 * (128 - int64(c))

		gc.Regfree(&tmp)
		gc.Regfree(&src)
		gc.Regfree(&dst)
		return
	}

	var dst gc.Node
	var src gc.Node
	if n.Ullman >= res.Ullman {
		gc.Agenr(n, &dst, res) // temporarily use dst
		gc.Regalloc(&src, gc.Types[gc.Tptr], nil)
		gins(arm.AMOVW, &dst, &src)
		if res.Op == gc.ONAME {
			gc.Gvardef(res)
		}
		gc.Agen(res, &dst)
	} else {
		if res.Op == gc.ONAME {
			gc.Gvardef(res)
		}
		gc.Agenr(res, &dst, res)
		gc.Agenr(n, &src, nil)
	}

	var tmp gc.Node
	gc.Regalloc(&tmp, gc.Types[gc.TUINT32], nil)

	// set up end marker
	var nend gc.Node

	if c >= 4 {
		gc.Regalloc(&nend, gc.Types[gc.TUINT32], nil)

		p := gins(arm.AMOVW, &src, &nend)
		p.From.Type = obj.TYPE_ADDR
		if dir < 0 {
			p.From.Offset = int64(dir)
		} else {
			p.From.Offset = w
		}
	}

	// move src and dest to the end of block if necessary
	if dir < 0 {
		p := gins(arm.AMOVW, &src, &src)
		p.From.Type = obj.TYPE_ADDR
		p.From.Offset = w + int64(dir)

		p = gins(arm.AMOVW, &dst, &dst)
		p.From.Type = obj.TYPE_ADDR
		p.From.Offset = w + int64(dir)
	}

	// move
	if c >= 4 {
		p := gins(op, &src, &tmp)
		p.From.Type = obj.TYPE_MEM
		p.From.Offset = int64(dir)
		p.Scond |= arm.C_PBIT
		ploop := p

		p = gins(op, &tmp, &dst)
		p.To.Type = obj.TYPE_MEM
		p.To.Offset = int64(dir)
		p.Scond |= arm.C_PBIT

		p = gins(arm.ACMP, &src, nil)
		raddr(&nend, p)

		gc.Patch(gc.Gbranch(arm.ABNE, nil, 0), ploop)
		gc.Regfree(&nend)
	} else {
		var p *obj.Prog
		for ; c > 0; c-- {
			p = gins(op, &src, &tmp)
			p.From.Type = obj.TYPE_MEM
			p.From.Offset = int64(dir)
			p.Scond |= arm.C_PBIT

			p = gins(op, &tmp, &dst)
			p.To.Type = obj.TYPE_MEM
			p.To.Offset = int64(dir)
			p.Scond |= arm.C_PBIT
		}
	}

	gc.Regfree(&dst)
	gc.Regfree(&src)
	gc.Regfree(&tmp)
}
                                                                                                                                                                                                                                                                                                                                                                                                                 usr/local/go/src/cmd/compile/internal/arm/cgen64.go                                                 0100644 0000000 0000000 00000042302 13020111411 020530  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package arm

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/arm"
)

/*
 * attempt to generate 64-bit
 *	res = n
 * return 1 on success, 0 if op not handled.
 */
func cgen64(n *gc.Node, res *gc.Node) {
	if res.Op != gc.OINDREG && res.Op != gc.ONAME {
		gc.Dump("n", n)
		gc.Dump("res", res)
		gc.Fatalf("cgen64 %v of %v", gc.Oconv(int(n.Op), 0), gc.Oconv(int(res.Op), 0))
	}

	l := n.Left
	var t1 gc.Node
	if !l.Addable {
		gc.Tempname(&t1, l.Type)
		gc.Cgen(l, &t1)
		l = &t1
	}

	var hi1 gc.Node
	var lo1 gc.Node
	split64(l, &lo1, &hi1)
	switch n.Op {
	default:
		gc.Fatalf("cgen64 %v", gc.Oconv(int(n.Op), 0))

	case gc.OMINUS:
		var lo2 gc.Node
		var hi2 gc.Node
		split64(res, &lo2, &hi2)

		gc.Regalloc(&t1, lo1.Type, nil)
		var al gc.Node
		gc.Regalloc(&al, lo1.Type, nil)
		var ah gc.Node
		gc.Regalloc(&ah, hi1.Type, nil)

		gins(arm.AMOVW, &lo1, &al)
		gins(arm.AMOVW, &hi1, &ah)

		gmove(ncon(0), &t1)
		p1 := gins(arm.ASUB, &al, &t1)
		p1.Scond |= arm.C_SBIT
		gins(arm.AMOVW, &t1, &lo2)

		gmove(ncon(0), &t1)
		gins(arm.ASBC, &ah, &t1)
		gins(arm.AMOVW, &t1, &hi2)

		gc.Regfree(&t1)
		gc.Regfree(&al)
		gc.Regfree(&ah)
		splitclean()
		splitclean()
		return

	case gc.OCOM:
		gc.Regalloc(&t1, lo1.Type, nil)
		gmove(ncon(^uint32(0)), &t1)

		var lo2 gc.Node
		var hi2 gc.Node
		split64(res, &lo2, &hi2)
		var n1 gc.Node
		gc.Regalloc(&n1, lo1.Type, nil)

		gins(arm.AMOVW, &lo1, &n1)
		gins(arm.AEOR, &t1, &n1)
		gins(arm.AMOVW, &n1, &lo2)

		gins(arm.AMOVW, &hi1, &n1)
		gins(arm.AEOR, &t1, &n1)
		gins(arm.AMOVW, &n1, &hi2)

		gc.Regfree(&t1)
		gc.Regfree(&n1)
		splitclean()
		splitclean()
		return

		// binary operators.
	// common setup below.
	case gc.OADD,
		gc.OSUB,
		gc.OMUL,
		gc.OLSH,
		gc.ORSH,
		gc.OAND,
		gc.OOR,
		gc.OXOR,
		gc.OLROT:
		break
	}

	// setup for binary operators
	r := n.Right

	if r != nil && !r.Addable {
		var t2 gc.Node
		gc.Tempname(&t2, r.Type)
		gc.Cgen(r, &t2)
		r = &t2
	}

	var hi2 gc.Node
	var lo2 gc.Node
	if gc.Is64(r.Type) {
		split64(r, &lo2, &hi2)
	}

	var al gc.Node
	gc.Regalloc(&al, lo1.Type, nil)
	var ah gc.Node
	gc.Regalloc(&ah, hi1.Type, nil)

	// Do op.  Leave result in ah:al.
	switch n.Op {
	default:
		gc.Fatalf("cgen64: not implemented: %v\n", n)

		// TODO: Constants
	case gc.OADD:
		var bl gc.Node
		gc.Regalloc(&bl, gc.Types[gc.TPTR32], nil)

		var bh gc.Node
		gc.Regalloc(&bh, gc.Types[gc.TPTR32], nil)
		gins(arm.AMOVW, &hi1, &ah)
		gins(arm.AMOVW, &lo1, &al)
		gins(arm.AMOVW, &hi2, &bh)
		gins(arm.AMOVW, &lo2, &bl)
		p1 := gins(arm.AADD, &bl, &al)
		p1.Scond |= arm.C_SBIT
		gins(arm.AADC, &bh, &ah)
		gc.Regfree(&bl)
		gc.Regfree(&bh)

		// TODO: Constants.
	case gc.OSUB:
		var bl gc.Node
		gc.Regalloc(&bl, gc.Types[gc.TPTR32], nil)

		var bh gc.Node
		gc.Regalloc(&bh, gc.Types[gc.TPTR32], nil)
		gins(arm.AMOVW, &lo1, &al)
		gins(arm.AMOVW, &hi1, &ah)
		gins(arm.AMOVW, &lo2, &bl)
		gins(arm.AMOVW, &hi2, &bh)
		p1 := gins(arm.ASUB, &bl, &al)
		p1.Scond |= arm.C_SBIT
		gins(arm.ASBC, &bh, &ah)
		gc.Regfree(&bl)
		gc.Regfree(&bh)

		// TODO(kaib): this can be done with 4 regs and does not need 6
	case gc.OMUL:
		var bl gc.Node
		gc.Regalloc(&bl, gc.Types[gc.TPTR32], nil)

		var bh gc.Node
		gc.Regalloc(&bh, gc.Types[gc.TPTR32], nil)
		var cl gc.Node
		gc.Regalloc(&cl, gc.Types[gc.TPTR32], nil)
		var ch gc.Node
		gc.Regalloc(&ch, gc.Types[gc.TPTR32], nil)

		// load args into bh:bl and bh:bl.
		gins(arm.AMOVW, &hi1, &bh)

		gins(arm.AMOVW, &lo1, &bl)
		gins(arm.AMOVW, &hi2, &ch)
		gins(arm.AMOVW, &lo2, &cl)

		// bl * cl -> ah al
		p1 := gins(arm.AMULLU, nil, nil)

		p1.From.Type = obj.TYPE_REG
		p1.From.Reg = bl.Reg
		p1.Reg = cl.Reg
		p1.To.Type = obj.TYPE_REGREG
		p1.To.Reg = ah.Reg
		p1.To.Offset = int64(al.Reg)

		//print("%v\n", p1);

		// bl * ch + ah -> ah
		p1 = gins(arm.AMULA, nil, nil)

		p1.From.Type = obj.TYPE_REG
		p1.From.Reg = bl.Reg
		p1.Reg = ch.Reg
		p1.To.Type = obj.TYPE_REGREG2
		p1.To.Reg = ah.Reg
		p1.To.Offset = int64(ah.Reg)

		//print("%v\n", p1);

		// bh * cl + ah -> ah
		p1 = gins(arm.AMULA, nil, nil)

		p1.From.Type = obj.TYPE_REG
		p1.From.Reg = bh.Reg
		p1.Reg = cl.Reg
		p1.To.Type = obj.TYPE_REGREG2
		p1.To.Reg = ah.Reg
		p1.To.Offset = int64(ah.Reg)

		//print("%v\n", p1);

		gc.Regfree(&bh)

		gc.Regfree(&bl)
		gc.Regfree(&ch)
		gc.Regfree(&cl)

		// We only rotate by a constant c in [0,64).
	// if c >= 32:
	//	lo, hi = hi, lo
	//	c -= 32
	// if c == 0:
	//	no-op
	// else:
	//	t = hi
	//	shld hi:lo, c
	//	shld lo:t, c
	case gc.OLROT:
		v := uint64(r.Int())

		var bl gc.Node
		gc.Regalloc(&bl, lo1.Type, nil)
		var bh gc.Node
		gc.Regalloc(&bh, hi1.Type, nil)
		if v >= 32 {
			// reverse during load to do the first 32 bits of rotate
			v -= 32

			gins(arm.AMOVW, &hi1, &bl)
			gins(arm.AMOVW, &lo1, &bh)
		} else {
			gins(arm.AMOVW, &hi1, &bh)
			gins(arm.AMOVW, &lo1, &bl)
		}

		if v == 0 {
			gins(arm.AMOVW, &bh, &ah)
			gins(arm.AMOVW, &bl, &al)
		} else {
			// rotate by 1 <= v <= 31
			//	MOVW	bl<<v, al
			//	MOVW	bh<<v, ah
			//	OR		bl>>(32-v), ah
			//	OR		bh>>(32-v), al
			gshift(arm.AMOVW, &bl, arm.SHIFT_LL, int32(v), &al)

			gshift(arm.AMOVW, &bh, arm.SHIFT_LL, int32(v), &ah)
			gshift(arm.AORR, &bl, arm.SHIFT_LR, int32(32-v), &ah)
			gshift(arm.AORR, &bh, arm.SHIFT_LR, int32(32-v), &al)
		}

		gc.Regfree(&bl)
		gc.Regfree(&bh)

	case gc.OLSH:
		var bl gc.Node
		gc.Regalloc(&bl, lo1.Type, nil)
		var bh gc.Node
		gc.Regalloc(&bh, hi1.Type, nil)
		gins(arm.AMOVW, &hi1, &bh)
		gins(arm.AMOVW, &lo1, &bl)

		var p6 *obj.Prog
		var s gc.Node
		var n1 gc.Node
		var creg gc.Node
		var p1 *obj.Prog
		var p2 *obj.Prog
		var p3 *obj.Prog
		var p4 *obj.Prog
		var p5 *obj.Prog
		if r.Op == gc.OLITERAL {
			v := uint64(r.Int())
			if v >= 64 {
				// TODO(kaib): replace with gins(AMOVW, nodintconst(0), &al)
				// here and below (verify it optimizes to EOR)
				gins(arm.AEOR, &al, &al)

				gins(arm.AEOR, &ah, &ah)
			} else if v > 32 {
				gins(arm.AEOR, &al, &al)

				//	MOVW	bl<<(v-32), ah
				gshift(arm.AMOVW, &bl, arm.SHIFT_LL, int32(v-32), &ah)
			} else if v == 32 {
				gins(arm.AEOR, &al, &al)
				gins(arm.AMOVW, &bl, &ah)
			} else if v > 0 {
				//	MOVW	bl<<v, al
				gshift(arm.AMOVW, &bl, arm.SHIFT_LL, int32(v), &al)

				//	MOVW	bh<<v, ah
				gshift(arm.AMOVW, &bh, arm.SHIFT_LL, int32(v), &ah)

				//	OR		bl>>(32-v), ah
				gshift(arm.AORR, &bl, arm.SHIFT_LR, int32(32-v), &ah)
			} else {
				gins(arm.AMOVW, &bl, &al)
				gins(arm.AMOVW, &bh, &ah)
			}

			goto olsh_break
		}

		gc.Regalloc(&s, gc.Types[gc.TUINT32], nil)
		gc.Regalloc(&creg, gc.Types[gc.TUINT32], nil)
		if gc.Is64(r.Type) {
			// shift is >= 1<<32
			var cl gc.Node
			var ch gc.Node
			split64(r, &cl, &ch)

			gmove(&ch, &s)
			gins(arm.ATST, &s, nil)
			p6 = gc.Gbranch(arm.ABNE, nil, 0)
			gmove(&cl, &s)
			splitclean()
		} else {
			gmove(r, &s)
			p6 = nil
		}

		gins(arm.ATST, &s, nil)

		// shift == 0
		p1 = gins(arm.AMOVW, &bl, &al)

		p1.Scond = arm.C_SCOND_EQ
		p1 = gins(arm.AMOVW, &bh, &ah)
		p1.Scond = arm.C_SCOND_EQ
		p2 = gc.Gbranch(arm.ABEQ, nil, 0)

		// shift is < 32
		gc.Nodconst(&n1, gc.Types[gc.TUINT32], 32)

		gmove(&n1, &creg)
		gins(arm.ACMP, &s, &creg)

		//	MOVW.LO		bl<<s, al
		p1 = gregshift(arm.AMOVW, &bl, arm.SHIFT_LL, &s, &al)

		p1.Scond = arm.C_SCOND_LO

		//	MOVW.LO		bh<<s, ah
		p1 = gregshift(arm.AMOVW, &bh, arm.SHIFT_LL, &s, &ah)

		p1.Scond = arm.C_SCOND_LO

		//	SUB.LO		s, creg
		p1 = gins(arm.ASUB, &s, &creg)

		p1.Scond = arm.C_SCOND_LO

		//	OR.LO		bl>>creg, ah
		p1 = gregshift(arm.AORR, &bl, arm.SHIFT_LR, &creg, &ah)

		p1.Scond = arm.C_SCOND_LO

		//	BLO	end
		p3 = gc.Gbranch(arm.ABLO, nil, 0)

		// shift == 32
		p1 = gins(arm.AEOR, &al, &al)

		p1.Scond = arm.C_SCOND_EQ
		p1 = gins(arm.AMOVW, &bl, &ah)
		p1.Scond = arm.C_SCOND_EQ
		p4 = gc.Gbranch(arm.ABEQ, nil, 0)

		// shift is < 64
		gc.Nodconst(&n1, gc.Types[gc.TUINT32], 64)

		gmove(&n1, &creg)
		gins(arm.ACMP, &s, &creg)

		//	EOR.LO	al, al
		p1 = gins(arm.AEOR, &al, &al)

		p1.Scond = arm.C_SCOND_LO

		//	MOVW.LO		creg>>1, creg
		p1 = gshift(arm.AMOVW, &creg, arm.SHIFT_LR, 1, &creg)

		p1.Scond = arm.C_SCOND_LO

		//	SUB.LO		creg, s
		p1 = gins(arm.ASUB, &creg, &s)

		p1.Scond = arm.C_SCOND_LO

		//	MOVW	bl<<s, ah
		p1 = gregshift(arm.AMOVW, &bl, arm.SHIFT_LL, &s, &ah)

		p1.Scond = arm.C_SCOND_LO

		p5 = gc.Gbranch(arm.ABLO, nil, 0)

		// shift >= 64
		if p6 != nil {
			gc.Patch(p6, gc.Pc)
		}
		gins(arm.AEOR, &al, &al)
		gins(arm.AEOR, &ah, &ah)

		gc.Patch(p2, gc.Pc)
		gc.Patch(p3, gc.Pc)
		gc.Patch(p4, gc.Pc)
		gc.Patch(p5, gc.Pc)
		gc.Regfree(&s)
		gc.Regfree(&creg)

	olsh_break:
		gc.Regfree(&bl)
		gc.Regfree(&bh)

	case gc.ORSH:
		var bl gc.Node
		gc.Regalloc(&bl, lo1.Type, nil)
		var bh gc.Node
		gc.Regalloc(&bh, hi1.Type, nil)
		gins(arm.AMOVW, &hi1, &bh)
		gins(arm.AMOVW, &lo1, &bl)

		var p4 *obj.Prog
		var p5 *obj.Prog
		var n1 gc.Node
		var p6 *obj.Prog
		var s gc.Node
		var p1 *obj.Prog
		var p2 *obj.Prog
		var creg gc.Node
		var p3 *obj.Prog
		if r.Op == gc.OLITERAL {
			v := uint64(r.Int())
			if v >= 64 {
				if bh.Type.Etype == gc.TINT32 {
					//	MOVW	bh->31, al
					gshift(arm.AMOVW, &bh, arm.SHIFT_AR, 31, &al)

					//	MOVW	bh->31, ah
					gshift(arm.AMOVW, &bh, arm.SHIFT_AR, 31, &ah)
				} else {
					gins(arm.AEOR, &al, &al)
					gins(arm.AEOR, &ah, &ah)
				}
			} else if v > 32 {
				if bh.Type.Etype == gc.TINT32 {
					//	MOVW	bh->(v-32), al
					gshift(arm.AMOVW, &bh, arm.SHIFT_AR, int32(v-32), &al)

					//	MOVW	bh->31, ah
					gshift(arm.AMOVW, &bh, arm.SHIFT_AR, 31, &ah)
				} else {
					//	MOVW	bh>>(v-32), al
					gshift(arm.AMOVW, &bh, arm.SHIFT_LR, int32(v-32), &al)

					gins(arm.AEOR, &ah, &ah)
				}
			} else if v == 32 {
				gins(arm.AMOVW, &bh, &al)
				if bh.Type.Etype == gc.TINT32 {
					//	MOVW	bh->31, ah
					gshift(arm.AMOVW, &bh, arm.SHIFT_AR, 31, &ah)
				} else {
					gins(arm.AEOR, &ah, &ah)
				}
			} else if v > 0 {
				//	MOVW	bl>>v, al
				gshift(arm.AMOVW, &bl, arm.SHIFT_LR, int32(v), &al)

				//	OR		bh<<(32-v), al
				gshift(arm.AORR, &bh, arm.SHIFT_LL, int32(32-v), &al)

				if bh.Type.Etype == gc.TINT32 {
					//	MOVW	bh->v, ah
					gshift(arm.AMOVW, &bh, arm.SHIFT_AR, int32(v), &ah)
				} else {
					//	MOVW	bh>>v, ah
					gshift(arm.AMOVW, &bh, arm.SHIFT_LR, int32(v), &ah)
				}
			} else {
				gins(arm.AMOVW, &bl, &al)
				gins(arm.AMOVW, &bh, &ah)
			}

			goto orsh_break
		}

		gc.Regalloc(&s, gc.Types[gc.TUINT32], nil)
		gc.Regalloc(&creg, gc.Types[gc.TUINT32], nil)
		if gc.Is64(r.Type) {
			// shift is >= 1<<32
			var ch gc.Node
			var cl gc.Node
			split64(r, &cl, &ch)

			gmove(&ch, &s)
			gins(arm.ATST, &s, nil)
			var p1 *obj.Prog
			if bh.Type.Etype == gc.TINT32 {
				p1 = gshift(arm.AMOVW, &bh, arm.SHIFT_AR, 31, &ah)
			} else {
				p1 = gins(arm.AEOR, &ah, &ah)
			}
			p1.Scond = arm.C_SCOND_NE
			p6 = gc.Gbranch(arm.ABNE, nil, 0)
			gmove(&cl, &s)
			splitclean()
		} else {
			gmove(r, &s)
			p6 = nil
		}

		gins(arm.ATST, &s, nil)

		// shift == 0
		p1 = gins(arm.AMOVW, &bl, &al)

		p1.Scond = arm.C_SCOND_EQ
		p1 = gins(arm.AMOVW, &bh, &ah)
		p1.Scond = arm.C_SCOND_EQ
		p2 = gc.Gbranch(arm.ABEQ, nil, 0)

		// check if shift is < 32
		gc.Nodconst(&n1, gc.Types[gc.TUINT32], 32)

		gmove(&n1, &creg)
		gins(arm.ACMP, &s, &creg)

		//	MOVW.LO		bl>>s, al
		p1 = gregshift(arm.AMOVW, &bl, arm.SHIFT_LR, &s, &al)

		p1.Scond = arm.C_SCOND_LO

		//	SUB.LO		s,creg
		p1 = gins(arm.ASUB, &s, &creg)

		p1.Scond = arm.C_SCOND_LO

		//	OR.LO		bh<<(32-s), al
		p1 = gregshift(arm.AORR, &bh, arm.SHIFT_LL, &creg, &al)

		p1.Scond = arm.C_SCOND_LO

		if bh.Type.Etype == gc.TINT32 {
			//	MOVW	bh->s, ah
			p1 = gregshift(arm.AMOVW, &bh, arm.SHIFT_AR, &s, &ah)
		} else {
			//	MOVW	bh>>s, ah
			p1 = gregshift(arm.AMOVW, &bh, arm.SHIFT_LR, &s, &ah)
		}

		p1.Scond = arm.C_SCOND_LO

		//	BLO	end
		p3 = gc.Gbranch(arm.ABLO, nil, 0)

		// shift == 32
		p1 = gins(arm.AMOVW, &bh, &al)

		p1.Scond = arm.C_SCOND_EQ
		if bh.Type.Etype == gc.TINT32 {
			gshift(arm.AMOVW, &bh, arm.SHIFT_AR, 31, &ah)
		} else {
			gins(arm.AEOR, &ah, &ah)
		}
		p4 = gc.Gbranch(arm.ABEQ, nil, 0)

		// check if shift is < 64
		gc.Nodconst(&n1, gc.Types[gc.TUINT32], 64)

		gmove(&n1, &creg)
		gins(arm.ACMP, &s, &creg)

		//	MOVW.LO		creg>>1, creg
		p1 = gshift(arm.AMOVW, &creg, arm.SHIFT_LR, 1, &creg)

		p1.Scond = arm.C_SCOND_LO

		//	SUB.LO		creg, s
		p1 = gins(arm.ASUB, &creg, &s)

		p1.Scond = arm.C_SCOND_LO

		if bh.Type.Etype == gc.TINT32 {
			//	MOVW	bh->(s-32), al
			p1 := gregshift(arm.AMOVW, &bh, arm.SHIFT_AR, &s, &al)

			p1.Scond = arm.C_SCOND_LO
		} else {
			//	MOVW	bh>>(v-32), al
			p1 := gregshift(arm.AMOVW, &bh, arm.SHIFT_LR, &s, &al)

			p1.Scond = arm.C_SCOND_LO
		}

		//	BLO	end
		p5 = gc.Gbranch(arm.ABLO, nil, 0)

		// s >= 64
		if p6 != nil {
			gc.Patch(p6, gc.Pc)
		}
		if bh.Type.Etype == gc.TINT32 {
			//	MOVW	bh->31, al
			gshift(arm.AMOVW, &bh, arm.SHIFT_AR, 31, &al)
		} else {
			gins(arm.AEOR, &al, &al)
		}

		gc.Patch(p2, gc.Pc)
		gc.Patch(p3, gc.Pc)
		gc.Patch(p4, gc.Pc)
		gc.Patch(p5, gc.Pc)
		gc.Regfree(&s)
		gc.Regfree(&creg)

	orsh_break:
		gc.Regfree(&bl)
		gc.Regfree(&bh)

		// TODO(kaib): literal optimizations
	// make constant the right side (it usually is anyway).
	//		if(lo1.op == OLITERAL) {
	//			nswap(&lo1, &lo2);
	//			nswap(&hi1, &hi2);
	//		}
	//		if(lo2.op == OLITERAL) {
	//			// special cases for constants.
	//			lv = mpgetfix(lo2.val.u.xval);
	//			hv = mpgetfix(hi2.val.u.xval);
	//			splitclean();	// right side
	//			split64(res, &lo2, &hi2);
	//			switch(n->op) {
	//			case OXOR:
	//				gmove(&lo1, &lo2);
	//				gmove(&hi1, &hi2);
	//				switch(lv) {
	//				case 0:
	//					break;
	//				case 0xffffffffu:
	//					gins(ANOTL, N, &lo2);
	//					break;
	//				default:
	//					gins(AXORL, ncon(lv), &lo2);
	//					break;
	//				}
	//				switch(hv) {
	//				case 0:
	//					break;
	//				case 0xffffffffu:
	//					gins(ANOTL, N, &hi2);
	//					break;
	//				default:
	//					gins(AXORL, ncon(hv), &hi2);
	//					break;
	//				}
	//				break;

	//			case OAND:
	//				switch(lv) {
	//				case 0:
	//					gins(AMOVL, ncon(0), &lo2);
	//					break;
	//				default:
	//					gmove(&lo1, &lo2);
	//					if(lv != 0xffffffffu)
	//						gins(AANDL, ncon(lv), &lo2);
	//					break;
	//				}
	//				switch(hv) {
	//				case 0:
	//					gins(AMOVL, ncon(0), &hi2);
	//					break;
	//				default:
	//					gmove(&hi1, &hi2);
	//					if(hv != 0xffffffffu)
	//						gins(AANDL, ncon(hv), &hi2);
	//					break;
	//				}
	//				break;

	//			case OOR:
	//				switch(lv) {
	//				case 0:
	//					gmove(&lo1, &lo2);
	//					break;
	//				case 0xffffffffu:
	//					gins(AMOVL, ncon(0xffffffffu), &lo2);
	//					break;
	//				default:
	//					gmove(&lo1, &lo2);
	//					gins(AORL, ncon(lv), &lo2);
	//					break;
	//				}
	//				switch(hv) {
	//				case 0:
	//					gmove(&hi1, &hi2);
	//					break;
	//				case 0xffffffffu:
	//					gins(AMOVL, ncon(0xffffffffu), &hi2);
	//					break;
	//				default:
	//					gmove(&hi1, &hi2);
	//					gins(AORL, ncon(hv), &hi2);
	//					break;
	//				}
	//				break;
	//			}
	//			splitclean();
	//			splitclean();
	//			goto out;
	//		}
	case gc.OXOR,
		gc.OAND,
		gc.OOR:
		var n1 gc.Node
		gc.Regalloc(&n1, lo1.Type, nil)

		gins(arm.AMOVW, &lo1, &al)
		gins(arm.AMOVW, &hi1, &ah)
		gins(arm.AMOVW, &lo2, &n1)
		gins(optoas(n.Op, lo1.Type), &n1, &al)
		gins(arm.AMOVW, &hi2, &n1)
		gins(optoas(n.Op, lo1.Type), &n1, &ah)
		gc.Regfree(&n1)
	}

	if gc.Is64(r.Type) {
		splitclean()
	}
	splitclean()

	split64(res, &lo1, &hi1)
	gins(arm.AMOVW, &al, &lo1)
	gins(arm.AMOVW, &ah, &hi1)
	splitclean()

	//out:
	gc.Regfree(&al)

	gc.Regfree(&ah)
}

/*
 * generate comparison of nl, nr, both 64-bit.
 * nl is memory; nr is constant or memory.
 */
func cmp64(nl *gc.Node, nr *gc.Node, op gc.Op, likely int, to *obj.Prog) {
	var lo1 gc.Node
	var hi1 gc.Node
	var lo2 gc.Node
	var hi2 gc.Node
	var r1 gc.Node
	var r2 gc.Node

	split64(nl, &lo1, &hi1)
	split64(nr, &lo2, &hi2)

	// compare most significant word;
	// if they differ, we're done.
	t := hi1.Type

	gc.Regalloc(&r1, gc.Types[gc.TINT32], nil)
	gc.Regalloc(&r2, gc.Types[gc.TINT32], nil)
	gins(arm.AMOVW, &hi1, &r1)
	gins(arm.AMOVW, &hi2, &r2)
	gins(arm.ACMP, &r1, &r2)
	gc.Regfree(&r1)
	gc.Regfree(&r2)

	var br *obj.Prog
	switch op {
	default:
		gc.Fatalf("cmp64 %v %v", gc.Oconv(int(op), 0), t)

		// cmp hi
	// bne L
	// cmp lo
	// beq to
	// L:
	case gc.OEQ:
		br = gc.Gbranch(arm.ABNE, nil, -likely)

		// cmp hi
	// bne to
	// cmp lo
	// bne to
	case gc.ONE:
		gc.Patch(gc.Gbranch(arm.ABNE, nil, likely), to)

		// cmp hi
	// bgt to
	// blt L
	// cmp lo
	// bge to (or bgt to)
	// L:
	case gc.OGE,
		gc.OGT:
		gc.Patch(gc.Gbranch(optoas(gc.OGT, t), nil, likely), to)

		br = gc.Gbranch(optoas(gc.OLT, t), nil, -likely)

		// cmp hi
	// blt to
	// bgt L
	// cmp lo
	// ble to (or jlt to)
	// L:
	case gc.OLE,
		gc.OLT:
		gc.Patch(gc.Gbranch(optoas(gc.OLT, t), nil, likely), to)

		br = gc.Gbranch(optoas(gc.OGT, t), nil, -likely)
	}

	// compare least significant word
	t = lo1.Type

	gc.Regalloc(&r1, gc.Types[gc.TINT32], nil)
	gc.Regalloc(&r2, gc.Types[gc.TINT32], nil)
	gins(arm.AMOVW, &lo1, &r1)
	gins(arm.AMOVW, &lo2, &r2)
	gins(arm.ACMP, &r1, &r2)
	gc.Regfree(&r1)
	gc.Regfree(&r2)

	// jump again
	gc.Patch(gc.Gbranch(optoas(op, t), nil, likely), to)

	// point first branch down here if appropriate
	if br != nil {
		gc.Patch(br, gc.Pc)
	}

	splitclean()
	splitclean()
}
                                                                                                                                                                                                                                                                                                                              usr/local/go/src/cmd/compile/internal/arm/galign.go                                                 0100644 0000000 0000000 00000004377 13020111411 020715  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package arm

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/arm"
)

var thechar int = '5'

var thestring string = "arm"

var thelinkarch *obj.LinkArch = &arm.Linkarm

func linkarchinit() {
}

var MAXWIDTH int64 = (1 << 32) - 1

/*
 * go declares several platform-specific type aliases:
 * int, uint, and uintptr
 */
var typedefs = []gc.Typedef{
	{"int", gc.TINT, gc.TINT32},
	{"uint", gc.TUINT, gc.TUINT32},
	{"uintptr", gc.TUINTPTR, gc.TUINT32},
}

func betypeinit() {
	gc.Widthptr = 4
	gc.Widthint = 4
	gc.Widthreg = 4
}

func Main() {
	gc.Thearch.Thechar = thechar
	gc.Thearch.Thestring = thestring
	gc.Thearch.Thelinkarch = thelinkarch
	gc.Thearch.Typedefs = typedefs
	gc.Thearch.REGSP = arm.REGSP
	gc.Thearch.REGCTXT = arm.REGCTXT
	gc.Thearch.REGCALLX = arm.REG_R1
	gc.Thearch.REGCALLX2 = arm.REG_R2
	gc.Thearch.REGRETURN = arm.REG_R0
	gc.Thearch.REGMIN = arm.REG_R0
	gc.Thearch.REGMAX = arm.REGEXT
	gc.Thearch.FREGMIN = arm.REG_F0
	gc.Thearch.FREGMAX = arm.FREGEXT
	gc.Thearch.MAXWIDTH = MAXWIDTH
	gc.Thearch.ReservedRegs = resvd

	gc.Thearch.Betypeinit = betypeinit
	gc.Thearch.Cgen64 = cgen64
	gc.Thearch.Cgen_hmul = cgen_hmul
	gc.Thearch.Cgen_shift = cgen_shift
	gc.Thearch.Clearfat = clearfat
	gc.Thearch.Cmp64 = cmp64
	gc.Thearch.Defframe = defframe
	gc.Thearch.Excise = excise
	gc.Thearch.Expandchecks = expandchecks
	gc.Thearch.Getg = getg
	gc.Thearch.Gins = gins
	gc.Thearch.Ginscmp = ginscmp
	gc.Thearch.Ginscon = ginscon
	gc.Thearch.Ginsnop = ginsnop
	gc.Thearch.Gmove = gmove
	gc.Thearch.Cgenindex = cgenindex
	gc.Thearch.Linkarchinit = linkarchinit
	gc.Thearch.Peep = peep
	gc.Thearch.Proginfo = proginfo
	gc.Thearch.Regtyp = regtyp
	gc.Thearch.Sameaddr = sameaddr
	gc.Thearch.Smallindir = smallindir
	gc.Thearch.Stackaddr = stackaddr
	gc.Thearch.Blockcopy = blockcopy
	gc.Thearch.Sudoaddable = sudoaddable
	gc.Thearch.Sudoclean = sudoclean
	gc.Thearch.Excludedregs = excludedregs
	gc.Thearch.RtoB = RtoB
	gc.Thearch.FtoB = RtoB
	gc.Thearch.BtoR = BtoR
	gc.Thearch.BtoF = BtoF
	gc.Thearch.Optoas = optoas
	gc.Thearch.Doregbits = doregbits
	gc.Thearch.Regnames = regnames

	gc.Main()
	gc.Exit(0)
}
                                                                                                                                                                                                                                                                 usr/local/go/src/cmd/compile/internal/arm/ggen.go                                                   0100644 0000000 0000000 00000027475 13020111411 020400  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package arm

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/arm"
)

func defframe(ptxt *obj.Prog) {
	var n *gc.Node

	// fill in argument size, stack size
	ptxt.To.Type = obj.TYPE_TEXTSIZE

	ptxt.To.Val = int32(gc.Rnd(gc.Curfn.Type.Argwid, int64(gc.Widthptr)))
	frame := uint32(gc.Rnd(gc.Stksize+gc.Maxarg, int64(gc.Widthreg)))
	ptxt.To.Offset = int64(frame)

	// insert code to contain ambiguously live variables
	// so that garbage collector only sees initialized values
	// when it looks for pointers.
	p := ptxt

	hi := int64(0)
	lo := hi
	r0 := uint32(0)
	for l := gc.Curfn.Func.Dcl; l != nil; l = l.Next {
		n = l.N
		if !n.Name.Needzero {
			continue
		}
		if n.Class != gc.PAUTO {
			gc.Fatalf("needzero class %d", n.Class)
		}
		if n.Type.Width%int64(gc.Widthptr) != 0 || n.Xoffset%int64(gc.Widthptr) != 0 || n.Type.Width == 0 {
			gc.Fatalf("var %v has size %d offset %d", gc.Nconv(n, obj.FmtLong), int(n.Type.Width), int(n.Xoffset))
		}
		if lo != hi && n.Xoffset+n.Type.Width >= lo-int64(2*gc.Widthptr) {
			// merge with range we already have
			lo = gc.Rnd(n.Xoffset, int64(gc.Widthptr))

			continue
		}

		// zero old range
		p = zerorange(p, int64(frame), lo, hi, &r0)

		// set new range
		hi = n.Xoffset + n.Type.Width

		lo = n.Xoffset
	}

	// zero final range
	zerorange(p, int64(frame), lo, hi, &r0)
}

func zerorange(p *obj.Prog, frame int64, lo int64, hi int64, r0 *uint32) *obj.Prog {
	cnt := hi - lo
	if cnt == 0 {
		return p
	}
	if *r0 == 0 {
		p = appendpp(p, arm.AMOVW, obj.TYPE_CONST, 0, 0, obj.TYPE_REG, arm.REG_R0, 0)
		*r0 = 1
	}

	if cnt < int64(4*gc.Widthptr) {
		for i := int64(0); i < cnt; i += int64(gc.Widthptr) {
			p = appendpp(p, arm.AMOVW, obj.TYPE_REG, arm.REG_R0, 0, obj.TYPE_MEM, arm.REGSP, int32(4+frame+lo+i))
		}
	} else if !gc.Nacl && (cnt <= int64(128*gc.Widthptr)) {
		p = appendpp(p, arm.AADD, obj.TYPE_CONST, 0, int32(4+frame+lo), obj.TYPE_REG, arm.REG_R1, 0)
		p.Reg = arm.REGSP
		p = appendpp(p, obj.ADUFFZERO, obj.TYPE_NONE, 0, 0, obj.TYPE_MEM, 0, 0)
		f := gc.Sysfunc("duffzero")
		gc.Naddr(&p.To, f)
		gc.Afunclit(&p.To, f)
		p.To.Offset = 4 * (128 - cnt/int64(gc.Widthptr))
	} else {
		p = appendpp(p, arm.AADD, obj.TYPE_CONST, 0, int32(4+frame+lo), obj.TYPE_REG, arm.REG_R1, 0)
		p.Reg = arm.REGSP
		p = appendpp(p, arm.AADD, obj.TYPE_CONST, 0, int32(cnt), obj.TYPE_REG, arm.REG_R2, 0)
		p.Reg = arm.REG_R1
		p = appendpp(p, arm.AMOVW, obj.TYPE_REG, arm.REG_R0, 0, obj.TYPE_MEM, arm.REG_R1, 4)
		p1 := p
		p.Scond |= arm.C_PBIT
		p = appendpp(p, arm.ACMP, obj.TYPE_REG, arm.REG_R1, 0, obj.TYPE_NONE, 0, 0)
		p.Reg = arm.REG_R2
		p = appendpp(p, arm.ABNE, obj.TYPE_NONE, 0, 0, obj.TYPE_BRANCH, 0, 0)
		gc.Patch(p, p1)
	}

	return p
}

func appendpp(p *obj.Prog, as int, ftype int, freg int, foffset int32, ttype int, treg int, toffset int32) *obj.Prog {
	q := gc.Ctxt.NewProg()
	gc.Clearp(q)
	q.As = int16(as)
	q.Lineno = p.Lineno
	q.From.Type = int16(ftype)
	q.From.Reg = int16(freg)
	q.From.Offset = int64(foffset)
	q.To.Type = int16(ttype)
	q.To.Reg = int16(treg)
	q.To.Offset = int64(toffset)
	q.Link = p.Link
	p.Link = q
	return q
}

/*
 * generate high multiply
 *  res = (nl * nr) >> wordsize
 */
func cgen_hmul(nl *gc.Node, nr *gc.Node, res *gc.Node) {
	if nl.Ullman < nr.Ullman {
		nl, nr = nr, nl
	}

	t := nl.Type
	w := int(t.Width * 8)
	var n1 gc.Node
	gc.Regalloc(&n1, t, res)
	gc.Cgen(nl, &n1)
	var n2 gc.Node
	gc.Regalloc(&n2, t, nil)
	gc.Cgen(nr, &n2)
	switch gc.Simtype[t.Etype] {
	case gc.TINT8,
		gc.TINT16:
		gins(optoas(gc.OMUL, t), &n2, &n1)
		gshift(arm.AMOVW, &n1, arm.SHIFT_AR, int32(w), &n1)

	case gc.TUINT8,
		gc.TUINT16:
		gins(optoas(gc.OMUL, t), &n2, &n1)
		gshift(arm.AMOVW, &n1, arm.SHIFT_LR, int32(w), &n1)

		// perform a long multiplication.
	case gc.TINT32,
		gc.TUINT32:
		var p *obj.Prog
		if gc.Issigned[t.Etype] {
			p = gins(arm.AMULL, &n2, nil)
		} else {
			p = gins(arm.AMULLU, &n2, nil)
		}

		// n2 * n1 -> (n1 n2)
		p.Reg = n1.Reg

		p.To.Type = obj.TYPE_REGREG
		p.To.Reg = n1.Reg
		p.To.Offset = int64(n2.Reg)

	default:
		gc.Fatalf("cgen_hmul %v", t)
	}

	gc.Cgen(&n1, res)
	gc.Regfree(&n1)
	gc.Regfree(&n2)
}

/*
 * generate shift according to op, one of:
 *	res = nl << nr
 *	res = nl >> nr
 */
func cgen_shift(op gc.Op, bounded bool, nl *gc.Node, nr *gc.Node, res *gc.Node) {
	if nl.Type.Width > 4 {
		gc.Fatalf("cgen_shift %v", nl.Type)
	}

	w := int(nl.Type.Width * 8)

	if op == gc.OLROT {
		v := nr.Int()
		var n1 gc.Node
		gc.Regalloc(&n1, nl.Type, res)
		if w == 32 {
			gc.Cgen(nl, &n1)
			gshift(arm.AMOVW, &n1, arm.SHIFT_RR, int32(w)-int32(v), &n1)
		} else {
			var n2 gc.Node
			gc.Regalloc(&n2, nl.Type, nil)
			gc.Cgen(nl, &n2)
			gshift(arm.AMOVW, &n2, arm.SHIFT_LL, int32(v), &n1)
			gshift(arm.AORR, &n2, arm.SHIFT_LR, int32(w)-int32(v), &n1)
			gc.Regfree(&n2)

			// Ensure sign/zero-extended result.
			gins(optoas(gc.OAS, nl.Type), &n1, &n1)
		}

		gmove(&n1, res)
		gc.Regfree(&n1)
		return
	}

	if nr.Op == gc.OLITERAL {
		var n1 gc.Node
		gc.Regalloc(&n1, nl.Type, res)
		gc.Cgen(nl, &n1)
		sc := uint64(nr.Int())
		if sc == 0 {
		} else // nothing to do
		if sc >= uint64(nl.Type.Width*8) {
			if op == gc.ORSH && gc.Issigned[nl.Type.Etype] {
				gshift(arm.AMOVW, &n1, arm.SHIFT_AR, int32(w), &n1)
			} else {
				gins(arm.AEOR, &n1, &n1)
			}
		} else {
			if op == gc.ORSH && gc.Issigned[nl.Type.Etype] {
				gshift(arm.AMOVW, &n1, arm.SHIFT_AR, int32(sc), &n1)
			} else if op == gc.ORSH {
				gshift(arm.AMOVW, &n1, arm.SHIFT_LR, int32(sc), &n1) // OLSH
			} else {
				gshift(arm.AMOVW, &n1, arm.SHIFT_LL, int32(sc), &n1)
			}
		}

		if w < 32 && op == gc.OLSH {
			gins(optoas(gc.OAS, nl.Type), &n1, &n1)
		}
		gmove(&n1, res)
		gc.Regfree(&n1)
		return
	}

	tr := nr.Type
	var t gc.Node
	var n1 gc.Node
	var n2 gc.Node
	var n3 gc.Node
	if tr.Width > 4 {
		var nt gc.Node
		gc.Tempname(&nt, nr.Type)
		if nl.Ullman >= nr.Ullman {
			gc.Regalloc(&n2, nl.Type, res)
			gc.Cgen(nl, &n2)
			gc.Cgen(nr, &nt)
			n1 = nt
		} else {
			gc.Cgen(nr, &nt)
			gc.Regalloc(&n2, nl.Type, res)
			gc.Cgen(nl, &n2)
		}

		var hi gc.Node
		var lo gc.Node
		split64(&nt, &lo, &hi)
		gc.Regalloc(&n1, gc.Types[gc.TUINT32], nil)
		gc.Regalloc(&n3, gc.Types[gc.TUINT32], nil)
		gmove(&lo, &n1)
		gmove(&hi, &n3)
		splitclean()
		gins(arm.ATST, &n3, nil)
		gc.Nodconst(&t, gc.Types[gc.TUINT32], int64(w))
		p1 := gins(arm.AMOVW, &t, &n1)
		p1.Scond = arm.C_SCOND_NE
		tr = gc.Types[gc.TUINT32]
		gc.Regfree(&n3)
	} else {
		if nl.Ullman >= nr.Ullman {
			gc.Regalloc(&n2, nl.Type, res)
			gc.Cgen(nl, &n2)
			gc.Regalloc(&n1, nr.Type, nil)
			gc.Cgen(nr, &n1)
		} else {
			gc.Regalloc(&n1, nr.Type, nil)
			gc.Cgen(nr, &n1)
			gc.Regalloc(&n2, nl.Type, res)
			gc.Cgen(nl, &n2)
		}
	}

	// test for shift being 0
	gins(arm.ATST, &n1, nil)

	p3 := gc.Gbranch(arm.ABEQ, nil, -1)

	// test and fix up large shifts
	// TODO: if(!bounded), don't emit some of this.
	gc.Regalloc(&n3, tr, nil)

	gc.Nodconst(&t, gc.Types[gc.TUINT32], int64(w))
	gmove(&t, &n3)
	gins(arm.ACMP, &n1, &n3)
	if op == gc.ORSH {
		var p1 *obj.Prog
		var p2 *obj.Prog
		if gc.Issigned[nl.Type.Etype] {
			p1 = gshift(arm.AMOVW, &n2, arm.SHIFT_AR, int32(w)-1, &n2)
			p2 = gregshift(arm.AMOVW, &n2, arm.SHIFT_AR, &n1, &n2)
		} else {
			p1 = gins(arm.AEOR, &n2, &n2)
			p2 = gregshift(arm.AMOVW, &n2, arm.SHIFT_LR, &n1, &n2)
		}

		p1.Scond = arm.C_SCOND_HS
		p2.Scond = arm.C_SCOND_LO
	} else {
		p1 := gins(arm.AEOR, &n2, &n2)
		p2 := gregshift(arm.AMOVW, &n2, arm.SHIFT_LL, &n1, &n2)
		p1.Scond = arm.C_SCOND_HS
		p2.Scond = arm.C_SCOND_LO
	}

	gc.Regfree(&n3)

	gc.Patch(p3, gc.Pc)

	// Left-shift of smaller word must be sign/zero-extended.
	if w < 32 && op == gc.OLSH {
		gins(optoas(gc.OAS, nl.Type), &n2, &n2)
	}
	gmove(&n2, res)

	gc.Regfree(&n1)
	gc.Regfree(&n2)
}

func clearfat(nl *gc.Node) {
	/* clear a fat object */
	if gc.Debug['g'] != 0 {
		gc.Dump("\nclearfat", nl)
	}

	w := uint32(nl.Type.Width)

	// Avoid taking the address for simple enough types.
	if gc.Componentgen(nil, nl) {
		return
	}

	c := w % 4 // bytes
	q := w / 4 // quads

	var r0 gc.Node
	r0.Op = gc.OREGISTER

	r0.Reg = arm.REG_R0
	var r1 gc.Node
	r1.Op = gc.OREGISTER
	r1.Reg = arm.REG_R1
	var dst gc.Node
	gc.Regalloc(&dst, gc.Types[gc.Tptr], &r1)
	gc.Agen(nl, &dst)
	var nc gc.Node
	gc.Nodconst(&nc, gc.Types[gc.TUINT32], 0)
	var nz gc.Node
	gc.Regalloc(&nz, gc.Types[gc.TUINT32], &r0)
	gc.Cgen(&nc, &nz)

	if q > 128 {
		var end gc.Node
		gc.Regalloc(&end, gc.Types[gc.Tptr], nil)
		p := gins(arm.AMOVW, &dst, &end)
		p.From.Type = obj.TYPE_ADDR
		p.From.Offset = int64(q) * 4

		p = gins(arm.AMOVW, &nz, &dst)
		p.To.Type = obj.TYPE_MEM
		p.To.Offset = 4
		p.Scond |= arm.C_PBIT
		pl := p

		p = gins(arm.ACMP, &dst, nil)
		raddr(&end, p)
		gc.Patch(gc.Gbranch(arm.ABNE, nil, 0), pl)

		gc.Regfree(&end)
	} else if q >= 4 && !gc.Nacl {
		f := gc.Sysfunc("duffzero")
		p := gins(obj.ADUFFZERO, nil, f)
		gc.Afunclit(&p.To, f)

		// 4 and 128 = magic constants: see ../../runtime/asm_arm.s
		p.To.Offset = 4 * (128 - int64(q))
	} else {
		var p *obj.Prog
		for q > 0 {
			p = gins(arm.AMOVW, &nz, &dst)
			p.To.Type = obj.TYPE_MEM
			p.To.Offset = 4
			p.Scond |= arm.C_PBIT

			//print("1. %v\n", p);
			q--
		}
	}

	var p *obj.Prog
	for c > 0 {
		p = gins(arm.AMOVB, &nz, &dst)
		p.To.Type = obj.TYPE_MEM
		p.To.Offset = 1
		p.Scond |= arm.C_PBIT

		//print("2. %v\n", p);
		c--
	}

	gc.Regfree(&dst)
	gc.Regfree(&nz)
}

// Called after regopt and peep have run.
// Expand CHECKNIL pseudo-op into actual nil pointer check.
func expandchecks(firstp *obj.Prog) {
	var reg int
	var p1 *obj.Prog

	for p := firstp; p != nil; p = p.Link {
		if p.As != obj.ACHECKNIL {
			continue
		}
		if gc.Debug_checknil != 0 && p.Lineno > 1 { // p->lineno==1 in generated wrappers
			gc.Warnl(int(p.Lineno), "generated nil check")
		}
		if p.From.Type != obj.TYPE_REG {
			gc.Fatalf("invalid nil check %v", p)
		}
		reg = int(p.From.Reg)

		// check is
		//	CMP arg, $0
		//	MOV.EQ arg, 0(arg)
		p1 = gc.Ctxt.NewProg()

		gc.Clearp(p1)
		p1.Link = p.Link
		p.Link = p1
		p1.Lineno = p.Lineno
		p1.Pc = 9999
		p1.As = arm.AMOVW
		p1.From.Type = obj.TYPE_REG
		p1.From.Reg = int16(reg)
		p1.To.Type = obj.TYPE_MEM
		p1.To.Reg = int16(reg)
		p1.To.Offset = 0
		p1.Scond = arm.C_SCOND_EQ
		p.As = arm.ACMP
		p.From.Type = obj.TYPE_CONST
		p.From.Reg = 0
		p.From.Offset = 0
		p.Reg = int16(reg)
	}
}

func ginsnop() {
	var r gc.Node
	gc.Nodreg(&r, gc.Types[gc.TINT], arm.REG_R0)
	p := gins(arm.AAND, &r, &r)
	p.Scond = arm.C_SCOND_EQ
}

/*
 * generate
 *	as $c, n
 */
func ginscon(as int, c int64, n *gc.Node) {
	var n1 gc.Node
	gc.Nodconst(&n1, gc.Types[gc.TINT32], c)
	var n2 gc.Node
	gc.Regalloc(&n2, gc.Types[gc.TINT32], nil)
	gmove(&n1, &n2)
	gins(as, &n2, n)
	gc.Regfree(&n2)
}

func ginscmp(op gc.Op, t *gc.Type, n1, n2 *gc.Node, likely int) *obj.Prog {
	if gc.Isint[t.Etype] && n1.Op == gc.OLITERAL && n1.Int() == 0 && n2.Op != gc.OLITERAL {
		op = gc.Brrev(op)
		n1, n2 = n2, n1
	}
	var r1, r2, g1, g2 gc.Node
	gc.Regalloc(&r1, t, n1)
	gc.Regalloc(&g1, n1.Type, &r1)
	gc.Cgen(n1, &g1)
	gmove(&g1, &r1)
	if gc.Isint[t.Etype] && n2.Op == gc.OLITERAL && n2.Int() == 0 {
		gins(arm.ACMP, &r1, n2)
	} else {
		gc.Regalloc(&r2, t, n2)
		gc.Regalloc(&g2, n1.Type, &r2)
		gc.Cgen(n2, &g2)
		gmove(&g2, &r2)
		gins(optoas(gc.OCMP, t), &r1, &r2)
		gc.Regfree(&g2)
		gc.Regfree(&r2)
	}
	gc.Regfree(&g1)
	gc.Regfree(&r1)
	return gc.Gbranch(optoas(op, t), nil, likely)
}

// addr += index*width if possible.
func addindex(index *gc.Node, width int64, addr *gc.Node) bool {
	switch width {
	case 2:
		gshift(arm.AADD, index, arm.SHIFT_LL, 1, addr)
		return true
	case 4:
		gshift(arm.AADD, index, arm.SHIFT_LL, 2, addr)
		return true
	case 8:
		gshift(arm.AADD, index, arm.SHIFT_LL, 3, addr)
		return true
	}
	return false
}

// res = runtime.getg()
func getg(res *gc.Node) {
	var n1 gc.Node
	gc.Nodreg(&n1, res.Type, arm.REGG)
	gmove(&n1, res)
}
                                                                                                                                                                                                   usr/local/go/src/cmd/compile/internal/arm/gsubr.go                                                  0100644 0000000 0000000 00000060317 13020111411 020572  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Derived from Inferno utils/5c/txt.c
// http://code.google.com/p/inferno-os/source/browse/utils/5c/txt.c
//
//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright © 1997-1999 Vita Nuova Limited
//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright © 2004,2006 Bruce Ellis
//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package arm

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/arm"
	"fmt"
)

var resvd = []int{
	arm.REG_R9,  // formerly reserved for m; might be okay to reuse now; not sure about NaCl
	arm.REG_R10, // reserved for g
}

/*
 * return constant i node.
 * overwritten by next call, but useful in calls to gins.
 */

var ncon_n gc.Node

func ncon(i uint32) *gc.Node {
	if ncon_n.Type == nil {
		gc.Nodconst(&ncon_n, gc.Types[gc.TUINT32], 0)
	}
	ncon_n.SetInt(int64(i))
	return &ncon_n
}

var sclean [10]gc.Node

var nsclean int

/*
 * n is a 64-bit value.  fill in lo and hi to refer to its 32-bit halves.
 */
func split64(n *gc.Node, lo *gc.Node, hi *gc.Node) {
	if !gc.Is64(n.Type) {
		gc.Fatalf("split64 %v", n.Type)
	}

	if nsclean >= len(sclean) {
		gc.Fatalf("split64 clean")
	}
	sclean[nsclean].Op = gc.OEMPTY
	nsclean++
	switch n.Op {
	default:
		switch n.Op {
		default:
			var n1 gc.Node
			if !dotaddable(n, &n1) {
				gc.Igen(n, &n1, nil)
				sclean[nsclean-1] = n1
			}

			n = &n1

		case gc.ONAME:
			if n.Class == gc.PPARAMREF {
				var n1 gc.Node
				gc.Cgen(n.Name.Heapaddr, &n1)
				sclean[nsclean-1] = n1
				n = &n1
			}

			// nothing
		case gc.OINDREG:
			break
		}

		*lo = *n
		*hi = *n
		lo.Type = gc.Types[gc.TUINT32]
		if n.Type.Etype == gc.TINT64 {
			hi.Type = gc.Types[gc.TINT32]
		} else {
			hi.Type = gc.Types[gc.TUINT32]
		}
		hi.Xoffset += 4

	case gc.OLITERAL:
		var n1 gc.Node
		n.Convconst(&n1, n.Type)
		i := n1.Int()
		gc.Nodconst(lo, gc.Types[gc.TUINT32], int64(uint32(i)))
		i >>= 32
		if n.Type.Etype == gc.TINT64 {
			gc.Nodconst(hi, gc.Types[gc.TINT32], int64(int32(i)))
		} else {
			gc.Nodconst(hi, gc.Types[gc.TUINT32], int64(uint32(i)))
		}
	}
}

func splitclean() {
	if nsclean <= 0 {
		gc.Fatalf("splitclean")
	}
	nsclean--
	if sclean[nsclean].Op != gc.OEMPTY {
		gc.Regfree(&sclean[nsclean])
	}
}

func gmove(f *gc.Node, t *gc.Node) {
	if gc.Debug['M'] != 0 {
		fmt.Printf("gmove %v -> %v\n", f, t)
	}

	ft := gc.Simsimtype(f.Type)
	tt := gc.Simsimtype(t.Type)
	cvt := t.Type

	if gc.Iscomplex[ft] || gc.Iscomplex[tt] {
		gc.Complexmove(f, t)
		return
	}

	// cannot have two memory operands;
	// except 64-bit, which always copies via registers anyway.
	var a int
	var r1 gc.Node
	if !gc.Is64(f.Type) && !gc.Is64(t.Type) && gc.Ismem(f) && gc.Ismem(t) {
		goto hard
	}

	// convert constant to desired type
	if f.Op == gc.OLITERAL {
		var con gc.Node
		switch tt {
		default:
			f.Convconst(&con, t.Type)

		case gc.TINT16,
			gc.TINT8:
			var con gc.Node
			f.Convconst(&con, gc.Types[gc.TINT32])
			var r1 gc.Node
			gc.Regalloc(&r1, con.Type, t)
			gins(arm.AMOVW, &con, &r1)
			gmove(&r1, t)
			gc.Regfree(&r1)
			return

		case gc.TUINT16,
			gc.TUINT8:
			var con gc.Node
			f.Convconst(&con, gc.Types[gc.TUINT32])
			var r1 gc.Node
			gc.Regalloc(&r1, con.Type, t)
			gins(arm.AMOVW, &con, &r1)
			gmove(&r1, t)
			gc.Regfree(&r1)
			return
		}

		f = &con
		ft = gc.Simsimtype(con.Type)

		// constants can't move directly to memory
		if gc.Ismem(t) && !gc.Is64(t.Type) {
			goto hard
		}
	}

	// value -> value copy, only one memory operand.
	// figure out the instruction to use.
	// break out of switch for one-instruction gins.
	// goto rdst for "destination must be register".
	// goto hard for "convert to cvt type first".
	// otherwise handle and return.

	switch uint32(ft)<<16 | uint32(tt) {
	default:
		// should not happen
		gc.Fatalf("gmove %v -> %v", f, t)
		return

		/*
		 * integer copy and truncate
		 */
	case gc.TINT8<<16 | gc.TINT8: // same size
		if !gc.Ismem(f) {
			a = arm.AMOVB
			break
		}
		fallthrough

	case gc.TUINT8<<16 | gc.TINT8,
		gc.TINT16<<16 | gc.TINT8, // truncate
		gc.TUINT16<<16 | gc.TINT8,
		gc.TINT32<<16 | gc.TINT8,
		gc.TUINT32<<16 | gc.TINT8:
		a = arm.AMOVBS

	case gc.TUINT8<<16 | gc.TUINT8:
		if !gc.Ismem(f) {
			a = arm.AMOVB
			break
		}
		fallthrough

	case gc.TINT8<<16 | gc.TUINT8,
		gc.TINT16<<16 | gc.TUINT8,
		gc.TUINT16<<16 | gc.TUINT8,
		gc.TINT32<<16 | gc.TUINT8,
		gc.TUINT32<<16 | gc.TUINT8:
		a = arm.AMOVBU

	case gc.TINT64<<16 | gc.TINT8, // truncate low word
		gc.TUINT64<<16 | gc.TINT8:
		a = arm.AMOVBS

		goto trunc64

	case gc.TINT64<<16 | gc.TUINT8,
		gc.TUINT64<<16 | gc.TUINT8:
		a = arm.AMOVBU
		goto trunc64

	case gc.TINT16<<16 | gc.TINT16: // same size
		if !gc.Ismem(f) {
			a = arm.AMOVH
			break
		}
		fallthrough

	case gc.TUINT16<<16 | gc.TINT16,
		gc.TINT32<<16 | gc.TINT16, // truncate
		gc.TUINT32<<16 | gc.TINT16:
		a = arm.AMOVHS

	case gc.TUINT16<<16 | gc.TUINT16:
		if !gc.Ismem(f) {
			a = arm.AMOVH
			break
		}
		fallthrough

	case gc.TINT16<<16 | gc.TUINT16,
		gc.TINT32<<16 | gc.TUINT16,
		gc.TUINT32<<16 | gc.TUINT16:
		a = arm.AMOVHU

	case gc.TINT64<<16 | gc.TINT16, // truncate low word
		gc.TUINT64<<16 | gc.TINT16:
		a = arm.AMOVHS

		goto trunc64

	case gc.TINT64<<16 | gc.TUINT16,
		gc.TUINT64<<16 | gc.TUINT16:
		a = arm.AMOVHU
		goto trunc64

	case gc.TINT32<<16 | gc.TINT32, // same size
		gc.TINT32<<16 | gc.TUINT32,
		gc.TUINT32<<16 | gc.TINT32,
		gc.TUINT32<<16 | gc.TUINT32:
		a = arm.AMOVW

	case gc.TINT64<<16 | gc.TINT32, // truncate
		gc.TUINT64<<16 | gc.TINT32,
		gc.TINT64<<16 | gc.TUINT32,
		gc.TUINT64<<16 | gc.TUINT32:
		var flo gc.Node
		var fhi gc.Node
		split64(f, &flo, &fhi)

		var r1 gc.Node
		gc.Regalloc(&r1, t.Type, nil)
		gins(arm.AMOVW, &flo, &r1)
		gins(arm.AMOVW, &r1, t)
		gc.Regfree(&r1)
		splitclean()
		return

	case gc.TINT64<<16 | gc.TINT64, // same size
		gc.TINT64<<16 | gc.TUINT64,
		gc.TUINT64<<16 | gc.TINT64,
		gc.TUINT64<<16 | gc.TUINT64:
		var fhi gc.Node
		var flo gc.Node
		split64(f, &flo, &fhi)

		var tlo gc.Node
		var thi gc.Node
		split64(t, &tlo, &thi)
		var r1 gc.Node
		gc.Regalloc(&r1, flo.Type, nil)
		var r2 gc.Node
		gc.Regalloc(&r2, fhi.Type, nil)
		gins(arm.AMOVW, &flo, &r1)
		gins(arm.AMOVW, &fhi, &r2)
		gins(arm.AMOVW, &r1, &tlo)
		gins(arm.AMOVW, &r2, &thi)
		gc.Regfree(&r1)
		gc.Regfree(&r2)
		splitclean()
		splitclean()
		return

		/*
		 * integer up-conversions
		 */
	case gc.TINT8<<16 | gc.TINT16, // sign extend int8
		gc.TINT8<<16 | gc.TUINT16,
		gc.TINT8<<16 | gc.TINT32,
		gc.TINT8<<16 | gc.TUINT32:
		a = arm.AMOVBS

		goto rdst

	case gc.TINT8<<16 | gc.TINT64, // convert via int32
		gc.TINT8<<16 | gc.TUINT64:
		cvt = gc.Types[gc.TINT32]

		goto hard

	case gc.TUINT8<<16 | gc.TINT16, // zero extend uint8
		gc.TUINT8<<16 | gc.TUINT16,
		gc.TUINT8<<16 | gc.TINT32,
		gc.TUINT8<<16 | gc.TUINT32:
		a = arm.AMOVBU

		goto rdst

	case gc.TUINT8<<16 | gc.TINT64, // convert via uint32
		gc.TUINT8<<16 | gc.TUINT64:
		cvt = gc.Types[gc.TUINT32]

		goto hard

	case gc.TINT16<<16 | gc.TINT32, // sign extend int16
		gc.TINT16<<16 | gc.TUINT32:
		a = arm.AMOVHS

		goto rdst

	case gc.TINT16<<16 | gc.TINT64, // convert via int32
		gc.TINT16<<16 | gc.TUINT64:
		cvt = gc.Types[gc.TINT32]

		goto hard

	case gc.TUINT16<<16 | gc.TINT32, // zero extend uint16
		gc.TUINT16<<16 | gc.TUINT32:
		a = arm.AMOVHU

		goto rdst

	case gc.TUINT16<<16 | gc.TINT64, // convert via uint32
		gc.TUINT16<<16 | gc.TUINT64:
		cvt = gc.Types[gc.TUINT32]

		goto hard

	case gc.TINT32<<16 | gc.TINT64, // sign extend int32
		gc.TINT32<<16 | gc.TUINT64:
		var tlo gc.Node
		var thi gc.Node
		split64(t, &tlo, &thi)

		var r1 gc.Node
		gc.Regalloc(&r1, tlo.Type, nil)
		var r2 gc.Node
		gc.Regalloc(&r2, thi.Type, nil)
		gmove(f, &r1)
		p1 := gins(arm.AMOVW, &r1, &r2)
		p1.From.Type = obj.TYPE_SHIFT
		p1.From.Offset = 2<<5 | 31<<7 | int64(r1.Reg)&15 // r1->31
		p1.From.Reg = 0

		//print("gmove: %v\n", p1);
		gins(arm.AMOVW, &r1, &tlo)

		gins(arm.AMOVW, &r2, &thi)
		gc.Regfree(&r1)
		gc.Regfree(&r2)
		splitclean()
		return

	case gc.TUINT32<<16 | gc.TINT64, // zero extend uint32
		gc.TUINT32<<16 | gc.TUINT64:
		var thi gc.Node
		var tlo gc.Node
		split64(t, &tlo, &thi)

		gmove(f, &tlo)
		var r1 gc.Node
		gc.Regalloc(&r1, thi.Type, nil)
		gins(arm.AMOVW, ncon(0), &r1)
		gins(arm.AMOVW, &r1, &thi)
		gc.Regfree(&r1)
		splitclean()
		return

		//	case CASE(TFLOAT64, TUINT64):
	/*
	* float to integer
	 */
	case gc.TFLOAT32<<16 | gc.TINT8,
		gc.TFLOAT32<<16 | gc.TUINT8,
		gc.TFLOAT32<<16 | gc.TINT16,
		gc.TFLOAT32<<16 | gc.TUINT16,
		gc.TFLOAT32<<16 | gc.TINT32,
		gc.TFLOAT32<<16 | gc.TUINT32,

		//	case CASE(TFLOAT32, TUINT64):

		gc.TFLOAT64<<16 | gc.TINT8,
		gc.TFLOAT64<<16 | gc.TUINT8,
		gc.TFLOAT64<<16 | gc.TINT16,
		gc.TFLOAT64<<16 | gc.TUINT16,
		gc.TFLOAT64<<16 | gc.TINT32,
		gc.TFLOAT64<<16 | gc.TUINT32:
		fa := arm.AMOVF

		a := arm.AMOVFW
		if ft == gc.TFLOAT64 {
			fa = arm.AMOVD
			a = arm.AMOVDW
		}

		ta := arm.AMOVW
		switch tt {
		case gc.TINT8:
			ta = arm.AMOVBS

		case gc.TUINT8:
			ta = arm.AMOVBU

		case gc.TINT16:
			ta = arm.AMOVHS

		case gc.TUINT16:
			ta = arm.AMOVHU
		}

		var r1 gc.Node
		gc.Regalloc(&r1, gc.Types[ft], f)
		var r2 gc.Node
		gc.Regalloc(&r2, gc.Types[tt], t)
		gins(fa, f, &r1)        // load to fpu
		p1 := gins(a, &r1, &r1) // convert to w
		switch tt {
		case gc.TUINT8,
			gc.TUINT16,
			gc.TUINT32:
			p1.Scond |= arm.C_UBIT
		}

		gins(arm.AMOVW, &r1, &r2) // copy to cpu
		gins(ta, &r2, t)          // store
		gc.Regfree(&r1)
		gc.Regfree(&r2)
		return

		/*
		 * integer to float
		 */
	case gc.TINT8<<16 | gc.TFLOAT32,
		gc.TUINT8<<16 | gc.TFLOAT32,
		gc.TINT16<<16 | gc.TFLOAT32,
		gc.TUINT16<<16 | gc.TFLOAT32,
		gc.TINT32<<16 | gc.TFLOAT32,
		gc.TUINT32<<16 | gc.TFLOAT32,
		gc.TINT8<<16 | gc.TFLOAT64,
		gc.TUINT8<<16 | gc.TFLOAT64,
		gc.TINT16<<16 | gc.TFLOAT64,
		gc.TUINT16<<16 | gc.TFLOAT64,
		gc.TINT32<<16 | gc.TFLOAT64,
		gc.TUINT32<<16 | gc.TFLOAT64:
		fa := arm.AMOVW

		switch ft {
		case gc.TINT8:
			fa = arm.AMOVBS

		case gc.TUINT8:
			fa = arm.AMOVBU

		case gc.TINT16:
			fa = arm.AMOVHS

		case gc.TUINT16:
			fa = arm.AMOVHU
		}

		a := arm.AMOVWF
		ta := arm.AMOVF
		if tt == gc.TFLOAT64 {
			a = arm.AMOVWD
			ta = arm.AMOVD
		}

		var r1 gc.Node
		gc.Regalloc(&r1, gc.Types[ft], f)
		var r2 gc.Node
		gc.Regalloc(&r2, gc.Types[tt], t)
		gins(fa, f, &r1)          // load to cpu
		gins(arm.AMOVW, &r1, &r2) // copy to fpu
		p1 := gins(a, &r2, &r2)   // convert
		switch ft {
		case gc.TUINT8,
			gc.TUINT16,
			gc.TUINT32:
			p1.Scond |= arm.C_UBIT
		}

		gins(ta, &r2, t) // store
		gc.Regfree(&r1)
		gc.Regfree(&r2)
		return

	case gc.TUINT64<<16 | gc.TFLOAT32,
		gc.TUINT64<<16 | gc.TFLOAT64:
		gc.Fatalf("gmove UINT64, TFLOAT not implemented")
		return

		/*
		 * float to float
		 */
	case gc.TFLOAT32<<16 | gc.TFLOAT32:
		a = arm.AMOVF

	case gc.TFLOAT64<<16 | gc.TFLOAT64:
		a = arm.AMOVD

	case gc.TFLOAT32<<16 | gc.TFLOAT64:
		var r1 gc.Node
		gc.Regalloc(&r1, gc.Types[gc.TFLOAT64], t)
		gins(arm.AMOVF, f, &r1)
		gins(arm.AMOVFD, &r1, &r1)
		gins(arm.AMOVD, &r1, t)
		gc.Regfree(&r1)
		return

	case gc.TFLOAT64<<16 | gc.TFLOAT32:
		var r1 gc.Node
		gc.Regalloc(&r1, gc.Types[gc.TFLOAT64], t)
		gins(arm.AMOVD, f, &r1)
		gins(arm.AMOVDF, &r1, &r1)
		gins(arm.AMOVF, &r1, t)
		gc.Regfree(&r1)
		return
	}

	gins(a, f, t)
	return

	// TODO(kaib): we almost always require a register dest anyway, this can probably be
	// removed.
	// requires register destination
rdst:
	{
		gc.Regalloc(&r1, t.Type, t)

		gins(a, f, &r1)
		gmove(&r1, t)
		gc.Regfree(&r1)
		return
	}

	// requires register intermediate
hard:
	gc.Regalloc(&r1, cvt, t)

	gmove(f, &r1)
	gmove(&r1, t)
	gc.Regfree(&r1)
	return

	// truncate 64 bit integer
trunc64:
	var fhi gc.Node
	var flo gc.Node
	split64(f, &flo, &fhi)

	gc.Regalloc(&r1, t.Type, nil)
	gins(a, &flo, &r1)
	gins(a, &r1, t)
	gc.Regfree(&r1)
	splitclean()
	return
}

func samaddr(f *gc.Node, t *gc.Node) bool {
	if f.Op != t.Op {
		return false
	}

	switch f.Op {
	case gc.OREGISTER:
		if f.Reg != t.Reg {
			break
		}
		return true
	}

	return false
}

/*
 * generate one instruction:
 *	as f, t
 */
func gins(as int, f *gc.Node, t *gc.Node) *obj.Prog {
	//	Node nod;
	//	int32 v;

	if f != nil && f.Op == gc.OINDEX {
		gc.Fatalf("gins OINDEX not implemented")
	}

	//		gc.Regalloc(&nod, &regnode, Z);
	//		v = constnode.vconst;
	//		gc.Cgen(f->right, &nod);
	//		constnode.vconst = v;
	//		idx.reg = nod.reg;
	//		gc.Regfree(&nod);
	if t != nil && t.Op == gc.OINDEX {
		gc.Fatalf("gins OINDEX not implemented")
	}

	//		gc.Regalloc(&nod, &regnode, Z);
	//		v = constnode.vconst;
	//		gc.Cgen(t->right, &nod);
	//		constnode.vconst = v;
	//		idx.reg = nod.reg;
	//		gc.Regfree(&nod);

	p := gc.Prog(as)
	gc.Naddr(&p.From, f)
	gc.Naddr(&p.To, t)

	switch as {
	case arm.ABL:
		if p.To.Type == obj.TYPE_REG {
			p.To.Type = obj.TYPE_MEM
		}

	case arm.ACMP, arm.ACMPF, arm.ACMPD:
		if t != nil {
			if f.Op != gc.OREGISTER {
				/* generate a comparison
				TODO(kaib): one of the args can actually be a small constant. relax the constraint and fix call sites.
				*/
				gc.Fatalf("bad operands to gcmp")
			}
			p.From = p.To
			p.To = obj.Addr{}
			raddr(f, p)
		}

	case arm.AMULU:
		if f != nil && f.Op != gc.OREGISTER {
			gc.Fatalf("bad operands to mul")
		}

	case arm.AMOVW:
		if (p.From.Type == obj.TYPE_MEM || p.From.Type == obj.TYPE_ADDR || p.From.Type == obj.TYPE_CONST) && (p.To.Type == obj.TYPE_MEM || p.To.Type == obj.TYPE_ADDR) {
			gc.Fatalf("gins double memory")
		}

	case arm.AADD:
		if p.To.Type == obj.TYPE_MEM {
			gc.Fatalf("gins arith to mem")
		}

	case arm.ARSB:
		if p.From.Type == obj.TYPE_NONE {
			gc.Fatalf("rsb with no from")
		}
	}

	if gc.Debug['g'] != 0 {
		fmt.Printf("%v\n", p)
	}
	return p
}

/*
 * insert n into reg slot of p
 */
func raddr(n *gc.Node, p *obj.Prog) {
	var a obj.Addr
	gc.Naddr(&a, n)
	if a.Type != obj.TYPE_REG {
		if n != nil {
			gc.Fatalf("bad in raddr: %v", gc.Oconv(int(n.Op), 0))
		} else {
			gc.Fatalf("bad in raddr: <null>")
		}
		p.Reg = 0
	} else {
		p.Reg = a.Reg
	}
}

/* generate a constant shift
 * arm encodes a shift by 32 as 0, thus asking for 0 shift is illegal.
 */
func gshift(as int, lhs *gc.Node, stype int32, sval int32, rhs *gc.Node) *obj.Prog {
	if sval <= 0 || sval > 32 {
		gc.Fatalf("bad shift value: %d", sval)
	}

	sval = sval & 0x1f

	p := gins(as, nil, rhs)
	p.From.Type = obj.TYPE_SHIFT
	p.From.Offset = int64(stype) | int64(sval)<<7 | int64(lhs.Reg)&15
	return p
}

/* generate a register shift
 */
func gregshift(as int, lhs *gc.Node, stype int32, reg *gc.Node, rhs *gc.Node) *obj.Prog {
	p := gins(as, nil, rhs)
	p.From.Type = obj.TYPE_SHIFT
	p.From.Offset = int64(stype) | (int64(reg.Reg)&15)<<8 | 1<<4 | int64(lhs.Reg)&15
	return p
}

/*
 * return Axxx for Oxxx on type t.
 */
func optoas(op gc.Op, t *gc.Type) int {
	if t == nil {
		gc.Fatalf("optoas: t is nil")
	}

	// avoid constant conversions in switches below
	const (
		OMINUS_ = uint32(gc.OMINUS) << 16
		OLSH_   = uint32(gc.OLSH) << 16
		ORSH_   = uint32(gc.ORSH) << 16
		OADD_   = uint32(gc.OADD) << 16
		OSUB_   = uint32(gc.OSUB) << 16
		OMUL_   = uint32(gc.OMUL) << 16
		ODIV_   = uint32(gc.ODIV) << 16
		OMOD_   = uint32(gc.OMOD) << 16
		OOR_    = uint32(gc.OOR) << 16
		OAND_   = uint32(gc.OAND) << 16
		OXOR_   = uint32(gc.OXOR) << 16
		OEQ_    = uint32(gc.OEQ) << 16
		ONE_    = uint32(gc.ONE) << 16
		OLT_    = uint32(gc.OLT) << 16
		OLE_    = uint32(gc.OLE) << 16
		OGE_    = uint32(gc.OGE) << 16
		OGT_    = uint32(gc.OGT) << 16
		OCMP_   = uint32(gc.OCMP) << 16
		OPS_    = uint32(gc.OPS) << 16
		OAS_    = uint32(gc.OAS) << 16
		OSQRT_  = uint32(gc.OSQRT) << 16
	)

	a := obj.AXXX
	switch uint32(op)<<16 | uint32(gc.Simtype[t.Etype]) {
	default:
		gc.Fatalf("optoas: no entry %v-%v etype %v simtype %v", gc.Oconv(int(op), 0), t, gc.Types[t.Etype], gc.Types[gc.Simtype[t.Etype]])

		/*	case CASE(OADDR, TPTR32):
				a = ALEAL;
				break;

			case CASE(OADDR, TPTR64):
				a = ALEAQ;
				break;
		*/
	// TODO(kaib): make sure the conditional branches work on all edge cases
	case OEQ_ | gc.TBOOL,
		OEQ_ | gc.TINT8,
		OEQ_ | gc.TUINT8,
		OEQ_ | gc.TINT16,
		OEQ_ | gc.TUINT16,
		OEQ_ | gc.TINT32,
		OEQ_ | gc.TUINT32,
		OEQ_ | gc.TINT64,
		OEQ_ | gc.TUINT64,
		OEQ_ | gc.TPTR32,
		OEQ_ | gc.TPTR64,
		OEQ_ | gc.TFLOAT32,
		OEQ_ | gc.TFLOAT64:
		a = arm.ABEQ

	case ONE_ | gc.TBOOL,
		ONE_ | gc.TINT8,
		ONE_ | gc.TUINT8,
		ONE_ | gc.TINT16,
		ONE_ | gc.TUINT16,
		ONE_ | gc.TINT32,
		ONE_ | gc.TUINT32,
		ONE_ | gc.TINT64,
		ONE_ | gc.TUINT64,
		ONE_ | gc.TPTR32,
		ONE_ | gc.TPTR64,
		ONE_ | gc.TFLOAT32,
		ONE_ | gc.TFLOAT64:
		a = arm.ABNE

	case OLT_ | gc.TINT8,
		OLT_ | gc.TINT16,
		OLT_ | gc.TINT32,
		OLT_ | gc.TINT64,
		OLT_ | gc.TFLOAT32,
		OLT_ | gc.TFLOAT64:
		a = arm.ABLT

	case OLT_ | gc.TUINT8,
		OLT_ | gc.TUINT16,
		OLT_ | gc.TUINT32,
		OLT_ | gc.TUINT64:
		a = arm.ABLO

	case OLE_ | gc.TINT8,
		OLE_ | gc.TINT16,
		OLE_ | gc.TINT32,
		OLE_ | gc.TINT64,
		OLE_ | gc.TFLOAT32,
		OLE_ | gc.TFLOAT64:
		a = arm.ABLE

	case OLE_ | gc.TUINT8,
		OLE_ | gc.TUINT16,
		OLE_ | gc.TUINT32,
		OLE_ | gc.TUINT64:
		a = arm.ABLS

	case OGT_ | gc.TINT8,
		OGT_ | gc.TINT16,
		OGT_ | gc.TINT32,
		OGT_ | gc.TINT64,
		OGT_ | gc.TFLOAT32,
		OGT_ | gc.TFLOAT64:
		a = arm.ABGT

	case OGT_ | gc.TUINT8,
		OGT_ | gc.TUINT16,
		OGT_ | gc.TUINT32,
		OGT_ | gc.TUINT64:
		a = arm.ABHI

	case OGE_ | gc.TINT8,
		OGE_ | gc.TINT16,
		OGE_ | gc.TINT32,
		OGE_ | gc.TINT64,
		OGE_ | gc.TFLOAT32,
		OGE_ | gc.TFLOAT64:
		a = arm.ABGE

	case OGE_ | gc.TUINT8,
		OGE_ | gc.TUINT16,
		OGE_ | gc.TUINT32,
		OGE_ | gc.TUINT64:
		a = arm.ABHS

	case OCMP_ | gc.TBOOL,
		OCMP_ | gc.TINT8,
		OCMP_ | gc.TUINT8,
		OCMP_ | gc.TINT16,
		OCMP_ | gc.TUINT16,
		OCMP_ | gc.TINT32,
		OCMP_ | gc.TUINT32,
		OCMP_ | gc.TPTR32:
		a = arm.ACMP

	case OCMP_ | gc.TFLOAT32:
		a = arm.ACMPF

	case OCMP_ | gc.TFLOAT64:
		a = arm.ACMPD

	case OPS_ | gc.TFLOAT32,
		OPS_ | gc.TFLOAT64:
		a = arm.ABVS

	case OAS_ | gc.TBOOL:
		a = arm.AMOVB

	case OAS_ | gc.TINT8:
		a = arm.AMOVBS

	case OAS_ | gc.TUINT8:
		a = arm.AMOVBU

	case OAS_ | gc.TINT16:
		a = arm.AMOVHS

	case OAS_ | gc.TUINT16:
		a = arm.AMOVHU

	case OAS_ | gc.TINT32,
		OAS_ | gc.TUINT32,
		OAS_ | gc.TPTR32:
		a = arm.AMOVW

	case OAS_ | gc.TFLOAT32:
		a = arm.AMOVF

	case OAS_ | gc.TFLOAT64:
		a = arm.AMOVD

	case OADD_ | gc.TINT8,
		OADD_ | gc.TUINT8,
		OADD_ | gc.TINT16,
		OADD_ | gc.TUINT16,
		OADD_ | gc.TINT32,
		OADD_ | gc.TUINT32,
		OADD_ | gc.TPTR32:
		a = arm.AADD

	case OADD_ | gc.TFLOAT32:
		a = arm.AADDF

	case OADD_ | gc.TFLOAT64:
		a = arm.AADDD

	case OSUB_ | gc.TINT8,
		OSUB_ | gc.TUINT8,
		OSUB_ | gc.TINT16,
		OSUB_ | gc.TUINT16,
		OSUB_ | gc.TINT32,
		OSUB_ | gc.TUINT32,
		OSUB_ | gc.TPTR32:
		a = arm.ASUB

	case OSUB_ | gc.TFLOAT32:
		a = arm.ASUBF

	case OSUB_ | gc.TFLOAT64:
		a = arm.ASUBD

	case OMINUS_ | gc.TINT8,
		OMINUS_ | gc.TUINT8,
		OMINUS_ | gc.TINT16,
		OMINUS_ | gc.TUINT16,
		OMINUS_ | gc.TINT32,
		OMINUS_ | gc.TUINT32,
		OMINUS_ | gc.TPTR32:
		a = arm.ARSB

	case OAND_ | gc.TINT8,
		OAND_ | gc.TUINT8,
		OAND_ | gc.TINT16,
		OAND_ | gc.TUINT16,
		OAND_ | gc.TINT32,
		OAND_ | gc.TUINT32,
		OAND_ | gc.TPTR32:
		a = arm.AAND

	case OOR_ | gc.TINT8,
		OOR_ | gc.TUINT8,
		OOR_ | gc.TINT16,
		OOR_ | gc.TUINT16,
		OOR_ | gc.TINT32,
		OOR_ | gc.TUINT32,
		OOR_ | gc.TPTR32:
		a = arm.AORR

	case OXOR_ | gc.TINT8,
		OXOR_ | gc.TUINT8,
		OXOR_ | gc.TINT16,
		OXOR_ | gc.TUINT16,
		OXOR_ | gc.TINT32,
		OXOR_ | gc.TUINT32,
		OXOR_ | gc.TPTR32:
		a = arm.AEOR

	case OLSH_ | gc.TINT8,
		OLSH_ | gc.TUINT8,
		OLSH_ | gc.TINT16,
		OLSH_ | gc.TUINT16,
		OLSH_ | gc.TINT32,
		OLSH_ | gc.TUINT32,
		OLSH_ | gc.TPTR32:
		a = arm.ASLL

	case ORSH_ | gc.TUINT8,
		ORSH_ | gc.TUINT16,
		ORSH_ | gc.TUINT32,
		ORSH_ | gc.TPTR32:
		a = arm.ASRL

	case ORSH_ | gc.TINT8,
		ORSH_ | gc.TINT16,
		ORSH_ | gc.TINT32:
		a = arm.ASRA

	case OMUL_ | gc.TUINT8,
		OMUL_ | gc.TUINT16,
		OMUL_ | gc.TUINT32,
		OMUL_ | gc.TPTR32:
		a = arm.AMULU

	case OMUL_ | gc.TINT8,
		OMUL_ | gc.TINT16,
		OMUL_ | gc.TINT32:
		a = arm.AMUL

	case OMUL_ | gc.TFLOAT32:
		a = arm.AMULF

	case OMUL_ | gc.TFLOAT64:
		a = arm.AMULD

	case ODIV_ | gc.TUINT8,
		ODIV_ | gc.TUINT16,
		ODIV_ | gc.TUINT32,
		ODIV_ | gc.TPTR32:
		a = arm.ADIVU

	case ODIV_ | gc.TINT8,
		ODIV_ | gc.TINT16,
		ODIV_ | gc.TINT32:
		a = arm.ADIV

	case OMOD_ | gc.TUINT8,
		OMOD_ | gc.TUINT16,
		OMOD_ | gc.TUINT32,
		OMOD_ | gc.TPTR32:
		a = arm.AMODU

	case OMOD_ | gc.TINT8,
		OMOD_ | gc.TINT16,
		OMOD_ | gc.TINT32:
		a = arm.AMOD

		//	case CASE(OEXTEND, TINT16):
	//		a = ACWD;
	//		break;

	//	case CASE(OEXTEND, TINT32):
	//		a = ACDQ;
	//		break;

	//	case CASE(OEXTEND, TINT64):
	//		a = ACQO;
	//		break;

	case ODIV_ | gc.TFLOAT32:
		a = arm.ADIVF

	case ODIV_ | gc.TFLOAT64:
		a = arm.ADIVD

	case OSQRT_ | gc.TFLOAT64:
		a = arm.ASQRTD
	}

	return a
}

const (
	ODynam = 1 << 0
	OPtrto = 1 << 1
)

var clean [20]gc.Node

var cleani int = 0

func sudoclean() {
	if clean[cleani-1].Op != gc.OEMPTY {
		gc.Regfree(&clean[cleani-1])
	}
	if clean[cleani-2].Op != gc.OEMPTY {
		gc.Regfree(&clean[cleani-2])
	}
	cleani -= 2
}

func dotaddable(n *gc.Node, n1 *gc.Node) bool {
	if n.Op != gc.ODOT {
		return false
	}

	var oary [10]int64
	var nn *gc.Node
	o := gc.Dotoffset(n, oary[:], &nn)
	if nn != nil && nn.Addable && o == 1 && oary[0] >= 0 {
		*n1 = *nn
		n1.Type = n.Type
		n1.Xoffset += oary[0]
		return true
	}

	return false
}

/*
 * generate code to compute address of n,
 * a reference to a (perhaps nested) field inside
 * an array or struct.
 * return 0 on failure, 1 on success.
 * on success, leaves usable address in a.
 *
 * caller is responsible for calling sudoclean
 * after successful sudoaddable,
 * to release the register used for a.
 */
func sudoaddable(as int, n *gc.Node, a *obj.Addr) bool {
	if n.Type == nil {
		return false
	}

	*a = obj.Addr{}

	switch n.Op {
	case gc.OLITERAL:
		if !gc.Isconst(n, gc.CTINT) {
			break
		}
		v := n.Int()
		if v >= 32000 || v <= -32000 {
			break
		}
		switch as {
		default:
			return false

		case arm.AADD,
			arm.ASUB,
			arm.AAND,
			arm.AORR,
			arm.AEOR,
			arm.AMOVB,
			arm.AMOVBS,
			arm.AMOVBU,
			arm.AMOVH,
			arm.AMOVHS,
			arm.AMOVHU,
			arm.AMOVW:
			break
		}

		cleani += 2
		reg := &clean[cleani-1]
		reg1 := &clean[cleani-2]
		reg.Op = gc.OEMPTY
		reg1.Op = gc.OEMPTY
		gc.Naddr(a, n)
		return true

	case gc.ODOT,
		gc.ODOTPTR:
		cleani += 2
		reg := &clean[cleani-1]
		reg1 := &clean[cleani-2]
		reg.Op = gc.OEMPTY
		reg1.Op = gc.OEMPTY
		var nn *gc.Node
		var oary [10]int64
		o := gc.Dotoffset(n, oary[:], &nn)
		if nn == nil {
			sudoclean()
			return false
		}

		if nn.Addable && o == 1 && oary[0] >= 0 {
			// directly addressable set of DOTs
			n1 := *nn

			n1.Type = n.Type
			n1.Xoffset += oary[0]
			gc.Naddr(a, &n1)
			return true
		}

		gc.Regalloc(reg, gc.Types[gc.Tptr], nil)
		n1 := *reg
		n1.Op = gc.OINDREG
		if oary[0] >= 0 {
			gc.Agen(nn, reg)
			n1.Xoffset = oary[0]
		} else {
			gc.Cgen(nn, reg)
			gc.Cgen_checknil(reg)
			n1.Xoffset = -(oary[0] + 1)
		}

		for i := 1; i < o; i++ {
			if oary[i] >= 0 {
				gc.Fatalf("can't happen")
			}
			gins(arm.AMOVW, &n1, reg)
			gc.Cgen_checknil(reg)
			n1.Xoffset = -(oary[i] + 1)
		}

		a.Type = obj.TYPE_NONE
		a.Name = obj.NAME_NONE
		n1.Type = n.Type
		gc.Naddr(a, &n1)
		return true

	case gc.OINDEX:
		return false
	}

	return false
}
                                                                                                                                                                                                                                                                                                                 usr/local/go/src/cmd/compile/internal/arm/peep.go                                                   0100644 0000000 0000000 00000100630 13020111411 020372  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Inferno utils/5c/peep.c
// http://code.google.com/p/inferno-os/source/browse/utils/5c/peep.c
//
//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright © 1997-1999 Vita Nuova Limited
//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright © 2004,2006 Bruce Ellis
//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package arm

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/arm"
	"fmt"
)

var gactive uint32

// UNUSED
func peep(firstp *obj.Prog) {
	g := (*gc.Graph)(gc.Flowstart(firstp, nil))
	if g == nil {
		return
	}
	gactive = 0

	var r *gc.Flow
	var p *obj.Prog
	var t int
loop1:
	if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
		gc.Dumpit("loop1", g.Start, 0)
	}

	t = 0
	for r = g.Start; r != nil; r = r.Link {
		p = r.Prog
		switch p.As {
		/*
		 * elide shift into TYPE_SHIFT operand of subsequent instruction
		 */
		//			if(shiftprop(r)) {
		//				excise(r);
		//				t++;
		//				break;
		//			}
		case arm.ASLL,
			arm.ASRL,
			arm.ASRA:
			break

		case arm.AMOVB,
			arm.AMOVH,
			arm.AMOVW,
			arm.AMOVF,
			arm.AMOVD:
			if regtyp(&p.From) {
				if p.From.Type == p.To.Type && isfloatreg(&p.From) == isfloatreg(&p.To) {
					if p.Scond == arm.C_SCOND_NONE {
						if copyprop(g, r) {
							excise(r)
							t++
							break
						}

						if subprop(r) && copyprop(g, r) {
							excise(r)
							t++
							break
						}
					}
				}
			}

		case arm.AMOVHS,
			arm.AMOVHU,
			arm.AMOVBS,
			arm.AMOVBU:
			if p.From.Type == obj.TYPE_REG {
				if shortprop(r) {
					t++
				}
			}
		}
	}

	/*
		if(p->scond == C_SCOND_NONE)
		if(regtyp(&p->to))
		if(isdconst(&p->from)) {
			constprop(&p->from, &p->to, r->s1);
		}
		break;
	*/
	if t != 0 {
		goto loop1
	}

	for r := (*gc.Flow)(g.Start); r != nil; r = r.Link {
		p = r.Prog
		switch p.As {
		/*
		 * EOR -1,x,y => MVN x,y
		 */
		case arm.AEOR:
			if isdconst(&p.From) && p.From.Offset == -1 {
				p.As = arm.AMVN
				p.From.Type = obj.TYPE_REG
				if p.Reg != 0 {
					p.From.Reg = p.Reg
				} else {
					p.From.Reg = p.To.Reg
				}
				p.Reg = 0
			}
		}
	}

	for r := (*gc.Flow)(g.Start); r != nil; r = r.Link {
		p = r.Prog
		switch p.As {
		case arm.AMOVW,
			arm.AMOVB,
			arm.AMOVBS,
			arm.AMOVBU:
			if p.From.Type == obj.TYPE_MEM && p.From.Offset == 0 {
				xtramodes(g, r, &p.From)
			} else if p.To.Type == obj.TYPE_MEM && p.To.Offset == 0 {
				xtramodes(g, r, &p.To)
			} else {
				continue
			}
		}
	}

	//		case ACMP:
	//			/*
	//			 * elide CMP $0,x if calculation of x can set condition codes
	//			 */
	//			if(isdconst(&p->from) || p->from.offset != 0)
	//				continue;
	//			r2 = r->s1;
	//			if(r2 == nil)
	//				continue;
	//			t = r2->prog->as;
	//			switch(t) {
	//			default:
	//				continue;
	//			case ABEQ:
	//			case ABNE:
	//			case ABMI:
	//			case ABPL:
	//				break;
	//			case ABGE:
	//				t = ABPL;
	//				break;
	//			case ABLT:
	//				t = ABMI;
	//				break;
	//			case ABHI:
	//				t = ABNE;
	//				break;
	//			case ABLS:
	//				t = ABEQ;
	//				break;
	//			}
	//			r1 = r;
	//			do
	//				r1 = uniqp(r1);
	//			while (r1 != nil && r1->prog->as == ANOP);
	//			if(r1 == nil)
	//				continue;
	//			p1 = r1->prog;
	//			if(p1->to.type != TYPE_REG)
	//				continue;
	//			if(p1->to.reg != p->reg)
	//			if(!(p1->as == AMOVW && p1->from.type == TYPE_REG && p1->from.reg == p->reg))
	//				continue;
	//
	//			switch(p1->as) {
	//			default:
	//				continue;
	//			case AMOVW:
	//				if(p1->from.type != TYPE_REG)
	//					continue;
	//			case AAND:
	//			case AEOR:
	//			case AORR:
	//			case ABIC:
	//			case AMVN:
	//			case ASUB:
	//			case ARSB:
	//			case AADD:
	//			case AADC:
	//			case ASBC:
	//			case ARSC:
	//				break;
	//			}
	//			p1->scond |= C_SBIT;
	//			r2->prog->as = t;
	//			excise(r);
	//			continue;

	//	predicate(g);

	gc.Flowend(g)
}

func regtyp(a *obj.Addr) bool {
	return a.Type == obj.TYPE_REG && (arm.REG_R0 <= a.Reg && a.Reg <= arm.REG_R15 || arm.REG_F0 <= a.Reg && a.Reg <= arm.REG_F15)
}

/*
 * the idea is to substitute
 * one register for another
 * from one MOV to another
 *	MOV	a, R0
 *	ADD	b, R0	/ no use of R1
 *	MOV	R0, R1
 * would be converted to
 *	MOV	a, R1
 *	ADD	b, R1
 *	MOV	R1, R0
 * hopefully, then the former or latter MOV
 * will be eliminated by copy propagation.
 */
func subprop(r0 *gc.Flow) bool {
	p := (*obj.Prog)(r0.Prog)
	v1 := (*obj.Addr)(&p.From)
	if !regtyp(v1) {
		return false
	}
	v2 := (*obj.Addr)(&p.To)
	if !regtyp(v2) {
		return false
	}
	for r := gc.Uniqp(r0); r != nil; r = gc.Uniqp(r) {
		if gc.Uniqs(r) == nil {
			break
		}
		p = r.Prog
		if p.As == obj.AVARDEF || p.As == obj.AVARKILL {
			continue
		}
		if p.Info.Flags&gc.Call != 0 {
			return false
		}

		// TODO(rsc): Whatever invalidated the info should have done this call.
		proginfo(p)

		if (p.Info.Flags&gc.CanRegRead != 0) && p.To.Type == obj.TYPE_REG {
			p.Info.Flags |= gc.RegRead
			p.Info.Flags &^= (gc.CanRegRead | gc.RightRead)
			p.Reg = p.To.Reg
		}

		switch p.As {
		case arm.AMULLU,
			arm.AMULA,
			arm.AMVN:
			return false
		}

		if p.Info.Flags&(gc.RightRead|gc.RightWrite) == gc.RightWrite {
			if p.To.Type == v1.Type {
				if p.To.Reg == v1.Reg {
					if p.Scond == arm.C_SCOND_NONE {
						copysub(&p.To, v1, v2, 1)
						if gc.Debug['P'] != 0 {
							fmt.Printf("gotit: %v->%v\n%v", gc.Ctxt.Dconv(v1), gc.Ctxt.Dconv(v2), r.Prog)
							if p.From.Type == v2.Type {
								fmt.Printf(" excise")
							}
							fmt.Printf("\n")
						}

						for r = gc.Uniqs(r); r != r0; r = gc.Uniqs(r) {
							p = r.Prog
							copysub(&p.From, v1, v2, 1)
							copysub1(p, v1, v2, 1)
							copysub(&p.To, v1, v2, 1)
							if gc.Debug['P'] != 0 {
								fmt.Printf("%v\n", r.Prog)
							}
						}

						t := int(int(v1.Reg))
						v1.Reg = v2.Reg
						v2.Reg = int16(t)
						if gc.Debug['P'] != 0 {
							fmt.Printf("%v last\n", r.Prog)
						}
						return true
					}
				}
			}
		}

		if copyau(&p.From, v2) || copyau1(p, v2) || copyau(&p.To, v2) {
			break
		}
		if copysub(&p.From, v1, v2, 0) != 0 || copysub1(p, v1, v2, 0) != 0 || copysub(&p.To, v1, v2, 0) != 0 {
			break
		}
	}

	return false
}

/*
 * The idea is to remove redundant copies.
 *	v1->v2	F=0
 *	(use v2	s/v2/v1/)*
 *	set v1	F=1
 *	use v2	return fail
 *	-----------------
 *	v1->v2	F=0
 *	(use v2	s/v2/v1/)*
 *	set v1	F=1
 *	set v2	return success
 */
func copyprop(g *gc.Graph, r0 *gc.Flow) bool {
	p := (*obj.Prog)(r0.Prog)
	v1 := (*obj.Addr)(&p.From)
	v2 := (*obj.Addr)(&p.To)
	if copyas(v1, v2) {
		return true
	}
	gactive++
	return copy1(v1, v2, r0.S1, 0)
}

func copy1(v1 *obj.Addr, v2 *obj.Addr, r *gc.Flow, f int) bool {
	if uint32(r.Active) == gactive {
		if gc.Debug['P'] != 0 {
			fmt.Printf("act set; return 1\n")
		}
		return true
	}

	r.Active = int32(gactive)
	if gc.Debug['P'] != 0 {
		fmt.Printf("copy %v->%v f=%d\n", gc.Ctxt.Dconv(v1), gc.Ctxt.Dconv(v2), f)
	}
	var t int
	var p *obj.Prog
	for ; r != nil; r = r.S1 {
		p = r.Prog
		if gc.Debug['P'] != 0 {
			fmt.Printf("%v", p)
		}
		if f == 0 && gc.Uniqp(r) == nil {
			f = 1
			if gc.Debug['P'] != 0 {
				fmt.Printf("; merge; f=%d", f)
			}
		}

		t = copyu(p, v2, nil)
		switch t {
		case 2: /* rar, can't split */
			if gc.Debug['P'] != 0 {
				fmt.Printf("; %vrar; return 0\n", gc.Ctxt.Dconv(v2))
			}
			return false

		case 3: /* set */
			if gc.Debug['P'] != 0 {
				fmt.Printf("; %vset; return 1\n", gc.Ctxt.Dconv(v2))
			}
			return true

		case 1, /* used, substitute */
			4: /* use and set */
			if f != 0 {
				if gc.Debug['P'] == 0 {
					return false
				}
				if t == 4 {
					fmt.Printf("; %vused+set and f=%d; return 0\n", gc.Ctxt.Dconv(v2), f)
				} else {
					fmt.Printf("; %vused and f=%d; return 0\n", gc.Ctxt.Dconv(v2), f)
				}
				return false
			}

			if copyu(p, v2, v1) != 0 {
				if gc.Debug['P'] != 0 {
					fmt.Printf("; sub fail; return 0\n")
				}
				return false
			}

			if gc.Debug['P'] != 0 {
				fmt.Printf("; sub%v/%v", gc.Ctxt.Dconv(v2), gc.Ctxt.Dconv(v1))
			}
			if t == 4 {
				if gc.Debug['P'] != 0 {
					fmt.Printf("; %vused+set; return 1\n", gc.Ctxt.Dconv(v2))
				}
				return true
			}
		}

		if f == 0 {
			t = copyu(p, v1, nil)
			if f == 0 && (t == 2 || t == 3 || t == 4) {
				f = 1
				if gc.Debug['P'] != 0 {
					fmt.Printf("; %vset and !f; f=%d", gc.Ctxt.Dconv(v1), f)
				}
			}
		}

		if gc.Debug['P'] != 0 {
			fmt.Printf("\n")
		}
		if r.S2 != nil {
			if !copy1(v1, v2, r.S2, f) {
				return false
			}
		}
	}

	return true
}

// UNUSED
/*
 * The idea is to remove redundant constants.
 *	$c1->v1
 *	($c1->v2 s/$c1/v1)*
 *	set v1  return
 * The v1->v2 should be eliminated by copy propagation.
 */
func constprop(c1 *obj.Addr, v1 *obj.Addr, r *gc.Flow) {
	if gc.Debug['P'] != 0 {
		fmt.Printf("constprop %v->%v\n", gc.Ctxt.Dconv(c1), gc.Ctxt.Dconv(v1))
	}
	var p *obj.Prog
	for ; r != nil; r = r.S1 {
		p = r.Prog
		if gc.Debug['P'] != 0 {
			fmt.Printf("%v", p)
		}
		if gc.Uniqp(r) == nil {
			if gc.Debug['P'] != 0 {
				fmt.Printf("; merge; return\n")
			}
			return
		}

		if p.As == arm.AMOVW && copyas(&p.From, c1) {
			if gc.Debug['P'] != 0 {
				fmt.Printf("; sub%v/%v", gc.Ctxt.Dconv(&p.From), gc.Ctxt.Dconv(v1))
			}
			p.From = *v1
		} else if copyu(p, v1, nil) > 1 {
			if gc.Debug['P'] != 0 {
				fmt.Printf("; %vset; return\n", gc.Ctxt.Dconv(v1))
			}
			return
		}

		if gc.Debug['P'] != 0 {
			fmt.Printf("\n")
		}
		if r.S2 != nil {
			constprop(c1, v1, r.S2)
		}
	}
}

/*
 * shortprop eliminates redundant zero/sign extensions.
 *
 *   MOVBS x, R
 *   <no use R>
 *   MOVBS R, R'
 *
 * changed to
 *
 *   MOVBS x, R
 *   ...
 *   MOVB  R, R' (compiled to mov)
 *
 * MOVBS above can be a MOVBS, MOVBU, MOVHS or MOVHU.
 */
func shortprop(r *gc.Flow) bool {
	p := (*obj.Prog)(r.Prog)
	r1 := (*gc.Flow)(findpre(r, &p.From))
	if r1 == nil {
		return false
	}

	p1 := (*obj.Prog)(r1.Prog)
	if p1.As == p.As {
		// Two consecutive extensions.
		goto gotit
	}

	if p1.As == arm.AMOVW && isdconst(&p1.From) && p1.From.Offset >= 0 && p1.From.Offset < 128 {
		// Loaded an immediate.
		goto gotit
	}

	return false

gotit:
	if gc.Debug['P'] != 0 {
		fmt.Printf("shortprop\n%v\n%v", p1, p)
	}
	switch p.As {
	case arm.AMOVBS,
		arm.AMOVBU:
		p.As = arm.AMOVB

	case arm.AMOVHS,
		arm.AMOVHU:
		p.As = arm.AMOVH
	}

	if gc.Debug['P'] != 0 {
		fmt.Printf(" => %v\n", obj.Aconv(int(p.As)))
	}
	return true
}

// UNUSED
/*
 * ASLL x,y,w
 * .. (not use w, not set x y w)
 * AXXX w,a,b (a != w)
 * .. (not use w)
 * (set w)
 * ----------- changed to
 * ..
 * AXXX (x<<y),a,b
 * ..
 */
func shiftprop(r *gc.Flow) bool {
	p := (*obj.Prog)(r.Prog)
	if p.To.Type != obj.TYPE_REG {
		if gc.Debug['P'] != 0 {
			fmt.Printf("\tBOTCH: result not reg; FAILURE\n")
		}
		return false
	}

	n := int(int(p.To.Reg))
	a := obj.Addr(obj.Addr{})
	if p.Reg != 0 && p.Reg != p.To.Reg {
		a.Type = obj.TYPE_REG
		a.Reg = p.Reg
	}

	if gc.Debug['P'] != 0 {
		fmt.Printf("shiftprop\n%v", p)
	}
	r1 := (*gc.Flow)(r)
	var p1 *obj.Prog
	for {
		/* find first use of shift result; abort if shift operands or result are changed */
		r1 = gc.Uniqs(r1)

		if r1 == nil {
			if gc.Debug['P'] != 0 {
				fmt.Printf("\tbranch; FAILURE\n")
			}
			return false
		}

		if gc.Uniqp(r1) == nil {
			if gc.Debug['P'] != 0 {
				fmt.Printf("\tmerge; FAILURE\n")
			}
			return false
		}

		p1 = r1.Prog
		if gc.Debug['P'] != 0 {
			fmt.Printf("\n%v", p1)
		}
		switch copyu(p1, &p.To, nil) {
		case 0: /* not used or set */
			if (p.From.Type == obj.TYPE_REG && copyu(p1, &p.From, nil) > 1) || (a.Type == obj.TYPE_REG && copyu(p1, &a, nil) > 1) {
				if gc.Debug['P'] != 0 {
					fmt.Printf("\targs modified; FAILURE\n")
				}
				return false
			}

			continue
		case 3: /* set, not used */
			{
				if gc.Debug['P'] != 0 {
					fmt.Printf("\tBOTCH: noref; FAILURE\n")
				}
				return false
			}
		}

		break
	}

	/* check whether substitution can be done */
	switch p1.As {
	default:
		if gc.Debug['P'] != 0 {
			fmt.Printf("\tnon-dpi; FAILURE\n")
		}
		return false

	case arm.AAND,
		arm.AEOR,
		arm.AADD,
		arm.AADC,
		arm.AORR,
		arm.ASUB,
		arm.ASBC,
		arm.ARSB,
		arm.ARSC:
		if int(p1.Reg) == n || (p1.Reg == 0 && p1.To.Type == obj.TYPE_REG && int(p1.To.Reg) == n) {
			if p1.From.Type != obj.TYPE_REG {
				if gc.Debug['P'] != 0 {
					fmt.Printf("\tcan't swap; FAILURE\n")
				}
				return false
			}

			p1.Reg = p1.From.Reg
			p1.From.Reg = int16(n)
			switch p1.As {
			case arm.ASUB:
				p1.As = arm.ARSB

			case arm.ARSB:
				p1.As = arm.ASUB

			case arm.ASBC:
				p1.As = arm.ARSC

			case arm.ARSC:
				p1.As = arm.ASBC
			}

			if gc.Debug['P'] != 0 {
				fmt.Printf("\t=>%v", p1)
			}
		}
		fallthrough

	case arm.ABIC,
		arm.ATST,
		arm.ACMP,
		arm.ACMN:
		if int(p1.Reg) == n {
			if gc.Debug['P'] != 0 {
				fmt.Printf("\tcan't swap; FAILURE\n")
			}
			return false
		}

		if p1.Reg == 0 && int(p1.To.Reg) == n {
			if gc.Debug['P'] != 0 {
				fmt.Printf("\tshift result used twice; FAILURE\n")
			}
			return false
		}

		//	case AMVN:
		if p1.From.Type == obj.TYPE_SHIFT {
			if gc.Debug['P'] != 0 {
				fmt.Printf("\tshift result used in shift; FAILURE\n")
			}
			return false
		}

		if p1.From.Type != obj.TYPE_REG || int(p1.From.Reg) != n {
			if gc.Debug['P'] != 0 {
				fmt.Printf("\tBOTCH: where is it used?; FAILURE\n")
			}
			return false
		}
	}

	/* check whether shift result is used subsequently */
	p2 := (*obj.Prog)(p1)

	if int(p1.To.Reg) != n {
		var p1 *obj.Prog
		for {
			r1 = gc.Uniqs(r1)
			if r1 == nil {
				if gc.Debug['P'] != 0 {
					fmt.Printf("\tinconclusive; FAILURE\n")
				}
				return false
			}

			p1 = r1.Prog
			if gc.Debug['P'] != 0 {
				fmt.Printf("\n%v", p1)
			}
			switch copyu(p1, &p.To, nil) {
			case 0: /* not used or set */
				continue

			case 3: /* set, not used */
				break

			default: /* used */
				if gc.Debug['P'] != 0 {
					fmt.Printf("\treused; FAILURE\n")
				}
				return false
			}

			break
		}
	}

	/* make the substitution */
	p2.From.Reg = 0

	o := int(int(p.Reg))
	if o == 0 {
		o = int(p.To.Reg)
	}
	o &= 15

	switch p.From.Type {
	case obj.TYPE_CONST:
		o |= int((p.From.Offset & 0x1f) << 7)

	case obj.TYPE_REG:
		o |= 1<<4 | (int(p.From.Reg)&15)<<8
	}

	switch p.As {
	case arm.ASLL:
		o |= 0 << 5

	case arm.ASRL:
		o |= 1 << 5

	case arm.ASRA:
		o |= 2 << 5
	}

	p2.From = obj.Addr{}
	p2.From.Type = obj.TYPE_SHIFT
	p2.From.Offset = int64(o)
	if gc.Debug['P'] != 0 {
		fmt.Printf("\t=>%v\tSUCCEED\n", p2)
	}
	return true
}

/*
 * findpre returns the last instruction mentioning v
 * before r. It must be a set, and there must be
 * a unique path from that instruction to r.
 */
func findpre(r *gc.Flow, v *obj.Addr) *gc.Flow {
	var r1 *gc.Flow

	for r1 = gc.Uniqp(r); r1 != nil; r, r1 = r1, gc.Uniqp(r1) {
		if gc.Uniqs(r1) != r {
			return nil
		}
		switch copyu(r1.Prog, v, nil) {
		case 1, /* used */
			2: /* read-alter-rewrite */
			return nil

		case 3, /* set */
			4: /* set and used */
			return r1
		}
	}

	return nil
}

/*
 * findinc finds ADD instructions with a constant
 * argument which falls within the immed_12 range.
 */
func findinc(r *gc.Flow, r2 *gc.Flow, v *obj.Addr) *gc.Flow {
	var r1 *gc.Flow
	var p *obj.Prog

	for r1 = gc.Uniqs(r); r1 != nil && r1 != r2; r, r1 = r1, gc.Uniqs(r1) {
		if gc.Uniqp(r1) != r {
			return nil
		}
		switch copyu(r1.Prog, v, nil) {
		case 0: /* not touched */
			continue

		case 4: /* set and used */
			p = r1.Prog

			if p.As == arm.AADD {
				if isdconst(&p.From) {
					if p.From.Offset > -4096 && p.From.Offset < 4096 {
						return r1
					}
				}
			}
			fallthrough

		default:
			return nil
		}
	}

	return nil
}

func nochange(r *gc.Flow, r2 *gc.Flow, p *obj.Prog) bool {
	if r == r2 {
		return true
	}
	n := int(0)
	var a [3]obj.Addr
	if p.Reg != 0 && p.Reg != p.To.Reg {
		a[n].Type = obj.TYPE_REG
		a[n].Reg = p.Reg
		n++
	}

	switch p.From.Type {
	case obj.TYPE_SHIFT:
		a[n].Type = obj.TYPE_REG
		a[n].Reg = int16(arm.REG_R0 + (p.From.Offset & 0xf))
		n++
		fallthrough

	case obj.TYPE_REG:
		a[n].Type = obj.TYPE_REG
		a[n].Reg = p.From.Reg
		n++
	}

	if n == 0 {
		return true
	}
	var i int
	for ; r != nil && r != r2; r = gc.Uniqs(r) {
		p = r.Prog
		for i = 0; i < n; i++ {
			if copyu(p, &a[i], nil) > 1 {
				return false
			}
		}
	}

	return true
}

func findu1(r *gc.Flow, v *obj.Addr) bool {
	for ; r != nil; r = r.S1 {
		if r.Active != 0 {
			return false
		}
		r.Active = 1
		switch copyu(r.Prog, v, nil) {
		case 1, /* used */
			2, /* read-alter-rewrite */
			4: /* set and used */
			return true

		case 3: /* set */
			return false
		}

		if r.S2 != nil {
			if findu1(r.S2, v) {
				return true
			}
		}
	}

	return false
}

func finduse(g *gc.Graph, r *gc.Flow, v *obj.Addr) bool {
	for r1 := (*gc.Flow)(g.Start); r1 != nil; r1 = r1.Link {
		r1.Active = 0
	}
	return findu1(r, v)
}

/*
 * xtramodes enables the ARM post increment and
 * shift offset addressing modes to transform
 *   MOVW   0(R3),R1
 *   ADD    $4,R3,R3
 * into
 *   MOVW.P 4(R3),R1
 * and
 *   ADD    R0,R1
 *   MOVBU  0(R1),R0
 * into
 *   MOVBU  R0<<0(R1),R0
 */
func xtramodes(g *gc.Graph, r *gc.Flow, a *obj.Addr) bool {
	p := (*obj.Prog)(r.Prog)
	v := obj.Addr(*a)
	v.Type = obj.TYPE_REG
	r1 := (*gc.Flow)(findpre(r, &v))
	if r1 != nil {
		p1 := r1.Prog
		if p1.To.Type == obj.TYPE_REG && p1.To.Reg == v.Reg {
			switch p1.As {
			case arm.AADD:
				if p1.Scond&arm.C_SBIT != 0 {
					// avoid altering ADD.S/ADC sequences.
					break
				}

				if p1.From.Type == obj.TYPE_REG || (p1.From.Type == obj.TYPE_SHIFT && p1.From.Offset&(1<<4) == 0 && ((p.As != arm.AMOVB && p.As != arm.AMOVBS) || (a == &p.From && p1.From.Offset&^0xf == 0))) || ((p1.From.Type == obj.TYPE_ADDR || p1.From.Type == obj.TYPE_CONST) && p1.From.Offset > -4096 && p1.From.Offset < 4096) {
					if nochange(gc.Uniqs(r1), r, p1) {
						if a != &p.From || v.Reg != p.To.Reg {
							if finduse(g, r.S1, &v) {
								if p1.Reg == 0 || p1.Reg == v.Reg {
									/* pre-indexing */
									p.Scond |= arm.C_WBIT
								} else {
									return false
								}
							}
						}

						switch p1.From.Type {
						/* register offset */
						case obj.TYPE_REG:
							if gc.Nacl {
								return false
							}
							*a = obj.Addr{}
							a.Type = obj.TYPE_SHIFT
							a.Offset = int64(p1.From.Reg) & 15

							/* scaled register offset */
						case obj.TYPE_SHIFT:
							if gc.Nacl {
								return false
							}
							*a = obj.Addr{}
							a.Type = obj.TYPE_SHIFT
							fallthrough

							/* immediate offset */
						case obj.TYPE_CONST,
							obj.TYPE_ADDR:
							a.Offset = p1.From.Offset
						}

						if p1.Reg != 0 {
							a.Reg = p1.Reg
						}
						excise(r1)
						return true
					}
				}

			case arm.AMOVW:
				if p1.From.Type == obj.TYPE_REG {
					r2 := (*gc.Flow)(findinc(r1, r, &p1.From))
					if r2 != nil {
						var r3 *gc.Flow
						for r3 = gc.Uniqs(r2); r3.Prog.As == obj.ANOP; r3 = gc.Uniqs(r3) {
						}
						if r3 == r {
							/* post-indexing */
							p1 := r2.Prog

							a.Reg = p1.To.Reg
							a.Offset = p1.From.Offset
							p.Scond |= arm.C_PBIT
							if !finduse(g, r, &r1.Prog.To) {
								excise(r1)
							}
							excise(r2)
							return true
						}
					}
				}
			}
		}
	}

	if a != &p.From || a.Reg != p.To.Reg {
		r1 := (*gc.Flow)(findinc(r, nil, &v))
		if r1 != nil {
			/* post-indexing */
			p1 := r1.Prog

			a.Offset = p1.From.Offset
			p.Scond |= arm.C_PBIT
			excise(r1)
			return true
		}
	}

	return false
}

/*
 * return
 * 1 if v only used (and substitute),
 * 2 if read-alter-rewrite
 * 3 if set
 * 4 if set and used
 * 0 otherwise (not touched)
 */
func copyu(p *obj.Prog, v *obj.Addr, s *obj.Addr) int {
	switch p.As {
	default:
		fmt.Printf("copyu: can't find %v\n", obj.Aconv(int(p.As)))
		return 2

	case arm.AMOVM:
		if v.Type != obj.TYPE_REG {
			return 0
		}
		if p.From.Type == obj.TYPE_CONST { /* read reglist, read/rar */
			if s != nil {
				if p.From.Offset&(1<<uint(v.Reg)) != 0 {
					return 1
				}
				if copysub(&p.To, v, s, 1) != 0 {
					return 1
				}
				return 0
			}

			if copyau(&p.To, v) {
				if p.Scond&arm.C_WBIT != 0 {
					return 2
				}
				return 1
			}

			if p.From.Offset&(1<<uint(v.Reg)) != 0 {
				return 1 /* read/rar, write reglist */
			}
		} else {
			if s != nil {
				if p.To.Offset&(1<<uint(v.Reg)) != 0 {
					return 1
				}
				if copysub(&p.From, v, s, 1) != 0 {
					return 1
				}
				return 0
			}

			if copyau(&p.From, v) {
				if p.Scond&arm.C_WBIT != 0 {
					return 2
				}
				if p.To.Offset&(1<<uint(v.Reg)) != 0 {
					return 4
				}
				return 1
			}

			if p.To.Offset&(1<<uint(v.Reg)) != 0 {
				return 3
			}
		}

		return 0

	case obj.ANOP, /* read,, write */
		arm.ASQRTD,
		arm.AMOVW,
		arm.AMOVF,
		arm.AMOVD,
		arm.AMOVH,
		arm.AMOVHS,
		arm.AMOVHU,
		arm.AMOVB,
		arm.AMOVBS,
		arm.AMOVBU,
		arm.AMOVFW,
		arm.AMOVWF,
		arm.AMOVDW,
		arm.AMOVWD,
		arm.AMOVFD,
		arm.AMOVDF:
		if p.Scond&(arm.C_WBIT|arm.C_PBIT) != 0 {
			if v.Type == obj.TYPE_REG {
				if p.From.Type == obj.TYPE_MEM || p.From.Type == obj.TYPE_SHIFT {
					if p.From.Reg == v.Reg {
						return 2
					}
				} else {
					if p.To.Reg == v.Reg {
						return 2
					}
				}
			}
		}

		if s != nil {
			if copysub(&p.From, v, s, 1) != 0 {
				return 1
			}
			if !copyas(&p.To, v) {
				if copysub(&p.To, v, s, 1) != 0 {
					return 1
				}
			}
			return 0
		}

		if copyas(&p.To, v) {
			if p.Scond != arm.C_SCOND_NONE {
				return 2
			}
			if copyau(&p.From, v) {
				return 4
			}
			return 3
		}

		if copyau(&p.From, v) {
			return 1
		}
		if copyau(&p.To, v) {
			return 1
		}
		return 0

	case arm.AMULLU, /* read, read, write, write */
		arm.AMULL,
		arm.AMULA,
		arm.AMVN:
		return 2

	case arm.AADD, /* read, read, write */
		arm.AADC,
		arm.ASUB,
		arm.ASBC,
		arm.ARSB,
		arm.ASLL,
		arm.ASRL,
		arm.ASRA,
		arm.AORR,
		arm.AAND,
		arm.AEOR,
		arm.AMUL,
		arm.AMULU,
		arm.ADIV,
		arm.ADIVU,
		arm.AMOD,
		arm.AMODU,
		arm.AADDF,
		arm.AADDD,
		arm.ASUBF,
		arm.ASUBD,
		arm.AMULF,
		arm.AMULD,
		arm.ADIVF,
		arm.ADIVD,
		obj.ACHECKNIL,
		/* read */
		arm.ACMPF, /* read, read, */
		arm.ACMPD,
		arm.ACMP,
		arm.ACMN,
		arm.ATST:
		/* read,, */
		if s != nil {
			if copysub(&p.From, v, s, 1) != 0 {
				return 1
			}
			if copysub1(p, v, s, 1) != 0 {
				return 1
			}
			if !copyas(&p.To, v) {
				if copysub(&p.To, v, s, 1) != 0 {
					return 1
				}
			}
			return 0
		}

		if copyas(&p.To, v) {
			if p.Scond != arm.C_SCOND_NONE {
				return 2
			}
			if p.Reg == 0 {
				p.Reg = p.To.Reg
			}
			if copyau(&p.From, v) {
				return 4
			}
			if copyau1(p, v) {
				return 4
			}
			return 3
		}

		if copyau(&p.From, v) {
			return 1
		}
		if copyau1(p, v) {
			return 1
		}
		if copyau(&p.To, v) {
			return 1
		}
		return 0

	case arm.ABEQ, /* read, read */
		arm.ABNE,
		arm.ABCS,
		arm.ABHS,
		arm.ABCC,
		arm.ABLO,
		arm.ABMI,
		arm.ABPL,
		arm.ABVS,
		arm.ABVC,
		arm.ABHI,
		arm.ABLS,
		arm.ABGE,
		arm.ABLT,
		arm.ABGT,
		arm.ABLE:
		if s != nil {
			if copysub(&p.From, v, s, 1) != 0 {
				return 1
			}
			return copysub1(p, v, s, 1)
		}

		if copyau(&p.From, v) {
			return 1
		}
		if copyau1(p, v) {
			return 1
		}
		return 0

	case arm.AB: /* funny */
		if s != nil {
			if copysub(&p.To, v, s, 1) != 0 {
				return 1
			}
			return 0
		}

		if copyau(&p.To, v) {
			return 1
		}
		return 0

	case obj.ARET: /* funny */
		if s != nil {
			return 1
		}
		return 3

	case arm.ABL: /* funny */
		if v.Type == obj.TYPE_REG {
			// TODO(rsc): REG_R0 and REG_F0 used to be
			// (when register numbers started at 0) exregoffset and exfregoffset,
			// which are unset entirely.
			// It's strange that this handles R0 and F0 differently from the other
			// registers. Possible failure to optimize?
			if arm.REG_R0 < v.Reg && v.Reg <= arm.REGEXT {
				return 2
			}
			if v.Reg == arm.REGARG {
				return 2
			}
			if arm.REG_F0 < v.Reg && v.Reg <= arm.FREGEXT {
				return 2
			}
		}

		if p.From.Type == obj.TYPE_REG && v.Type == obj.TYPE_REG && p.From.Reg == v.Reg {
			return 2
		}

		if s != nil {
			if copysub(&p.To, v, s, 1) != 0 {
				return 1
			}
			return 0
		}

		if copyau(&p.To, v) {
			return 4
		}
		return 3

		// R0 is zero, used by DUFFZERO, cannot be substituted.
	// R1 is ptr to memory, used and set, cannot be substituted.
	case obj.ADUFFZERO:
		if v.Type == obj.TYPE_REG {
			if v.Reg == arm.REG_R0 {
				return 1
			}
			if v.Reg == arm.REG_R0+1 {
				return 2
			}
		}

		return 0

		// R0 is scratch, set by DUFFCOPY, cannot be substituted.
	// R1, R2 areptr to src, dst, used and set, cannot be substituted.
	case obj.ADUFFCOPY:
		if v.Type == obj.TYPE_REG {
			if v.Reg == arm.REG_R0 {
				return 3
			}
			if v.Reg == arm.REG_R0+1 || v.Reg == arm.REG_R0+2 {
				return 2
			}
		}

		return 0

	case obj.ATEXT: /* funny */
		if v.Type == obj.TYPE_REG {
			if v.Reg == arm.REGARG {
				return 3
			}
		}
		return 0

	case obj.APCDATA,
		obj.AFUNCDATA,
		obj.AVARDEF,
		obj.AVARKILL,
		obj.AVARLIVE,
		obj.AUSEFIELD:
		return 0
	}
}

/*
 * direct reference,
 * could be set/use depending on
 * semantics
 */
func copyas(a *obj.Addr, v *obj.Addr) bool {
	if regtyp(v) {
		if a.Type == v.Type {
			if a.Reg == v.Reg {
				return true
			}
		}
	} else if v.Type == obj.TYPE_CONST { /* for constprop */
		if a.Type == v.Type {
			if a.Name == v.Name {
				if a.Sym == v.Sym {
					if a.Reg == v.Reg {
						if a.Offset == v.Offset {
							return true
						}
					}
				}
			}
		}
	}

	return false
}

func sameaddr(a *obj.Addr, v *obj.Addr) bool {
	if a.Type != v.Type {
		return false
	}
	if regtyp(v) && a.Reg == v.Reg {
		return true
	}

	// TODO(rsc): Change v->type to v->name and enable.
	//if(v->type == NAME_AUTO || v->type == NAME_PARAM) {
	//	if(v->offset == a->offset)
	//		return 1;
	//}
	return false
}

/*
 * either direct or indirect
 */
func copyau(a *obj.Addr, v *obj.Addr) bool {
	if copyas(a, v) {
		return true
	}
	if v.Type == obj.TYPE_REG {
		if a.Type == obj.TYPE_ADDR && a.Reg != 0 {
			if a.Reg == v.Reg {
				return true
			}
		} else if a.Type == obj.TYPE_MEM {
			if a.Reg == v.Reg {
				return true
			}
		} else if a.Type == obj.TYPE_REGREG || a.Type == obj.TYPE_REGREG2 {
			if a.Reg == v.Reg {
				return true
			}
			if a.Offset == int64(v.Reg) {
				return true
			}
		} else if a.Type == obj.TYPE_SHIFT {
			if a.Offset&0xf == int64(v.Reg-arm.REG_R0) {
				return true
			}
			if (a.Offset&(1<<4) != 0) && (a.Offset>>8)&0xf == int64(v.Reg-arm.REG_R0) {
				return true
			}
		}
	}

	return false
}

/*
 * compare v to the center
 * register in p (p->reg)
 */
func copyau1(p *obj.Prog, v *obj.Addr) bool {
	if v.Type == obj.TYPE_REG && v.Reg == 0 {
		return false
	}
	return p.Reg == v.Reg
}

/*
 * substitute s for v in a
 * return failure to substitute
 */
func copysub(a *obj.Addr, v *obj.Addr, s *obj.Addr, f int) int {
	if f != 0 {
		if copyau(a, v) {
			if a.Type == obj.TYPE_SHIFT {
				if a.Offset&0xf == int64(v.Reg-arm.REG_R0) {
					a.Offset = a.Offset&^0xf | int64(s.Reg)&0xf
				}
				if (a.Offset&(1<<4) != 0) && (a.Offset>>8)&0xf == int64(v.Reg-arm.REG_R0) {
					a.Offset = a.Offset&^(0xf<<8) | (int64(s.Reg)&0xf)<<8
				}
			} else if a.Type == obj.TYPE_REGREG || a.Type == obj.TYPE_REGREG2 {
				if a.Offset == int64(v.Reg) {
					a.Offset = int64(s.Reg)
				}
				if a.Reg == v.Reg {
					a.Reg = s.Reg
				}
			} else {
				a.Reg = s.Reg
			}
		}
	}

	return 0
}

func copysub1(p1 *obj.Prog, v *obj.Addr, s *obj.Addr, f int) int {
	if f != 0 {
		if copyau1(p1, v) {
			p1.Reg = s.Reg
		}
	}
	return 0
}

var predinfo = []struct {
	opcode    int
	notopcode int
	scond     int
	notscond  int
}{
	{arm.ABEQ, arm.ABNE, 0x0, 0x1},
	{arm.ABNE, arm.ABEQ, 0x1, 0x0},
	{arm.ABCS, arm.ABCC, 0x2, 0x3},
	{arm.ABHS, arm.ABLO, 0x2, 0x3},
	{arm.ABCC, arm.ABCS, 0x3, 0x2},
	{arm.ABLO, arm.ABHS, 0x3, 0x2},
	{arm.ABMI, arm.ABPL, 0x4, 0x5},
	{arm.ABPL, arm.ABMI, 0x5, 0x4},
	{arm.ABVS, arm.ABVC, 0x6, 0x7},
	{arm.ABVC, arm.ABVS, 0x7, 0x6},
	{arm.ABHI, arm.ABLS, 0x8, 0x9},
	{arm.ABLS, arm.ABHI, 0x9, 0x8},
	{arm.ABGE, arm.ABLT, 0xA, 0xB},
	{arm.ABLT, arm.ABGE, 0xB, 0xA},
	{arm.ABGT, arm.ABLE, 0xC, 0xD},
	{arm.ABLE, arm.ABGT, 0xD, 0xC},
}

type Joininfo struct {
	start *gc.Flow
	last  *gc.Flow
	end   *gc.Flow
	len   int
}

const (
	Join = iota
	Split
	End
	Branch
	Setcond
	Toolong
)

const (
	Falsecond = iota
	Truecond
	Delbranch
	Keepbranch
)

func isbranch(p *obj.Prog) bool {
	return (arm.ABEQ <= p.As) && (p.As <= arm.ABLE)
}

func predicable(p *obj.Prog) bool {
	switch p.As {
	case obj.ANOP,
		obj.AXXX,
		obj.ADATA,
		obj.AGLOBL,
		obj.ATEXT,
		arm.AWORD:
		return false
	}

	if isbranch(p) {
		return false
	}
	return true
}

/*
 * Depends on an analysis of the encodings performed by 5l.
 * These seem to be all of the opcodes that lead to the "S" bit
 * being set in the instruction encodings.
 *
 * C_SBIT may also have been set explicitly in p->scond.
 */
func modifiescpsr(p *obj.Prog) bool {
	switch p.As {
	case arm.AMULLU,
		arm.AMULA,
		arm.AMULU,
		arm.ADIVU,
		arm.ATEQ,
		arm.ACMN,
		arm.ATST,
		arm.ACMP,
		arm.AMUL,
		arm.ADIV,
		arm.AMOD,
		arm.AMODU,
		arm.ABL:
		return true
	}

	if p.Scond&arm.C_SBIT != 0 {
		return true
	}
	return false
}

/*
 * Find the maximal chain of instructions starting with r which could
 * be executed conditionally
 */
func joinsplit(r *gc.Flow, j *Joininfo) int {
	j.start = r
	j.last = r
	j.len = 0
	for {
		if r.P2 != nil && (r.P1 != nil || r.P2.P2link != nil) {
			j.end = r
			return Join
		}

		if r.S1 != nil && r.S2 != nil {
			j.end = r
			return Split
		}

		j.last = r
		if r.Prog.As != obj.ANOP {
			j.len++
		}
		if r.S1 == nil && r.S2 == nil {
			j.end = r.Link
			return End
		}

		if r.S2 != nil {
			j.end = r.S2
			return Branch
		}

		if modifiescpsr(r.Prog) {
			j.end = r.S1
			return Setcond
		}

		r = r.S1
		if j.len >= 4 {
			break
		}
	}

	j.end = r
	return Toolong
}

func successor(r *gc.Flow) *gc.Flow {
	if r.S1 != nil {
		return r.S1
	} else {
		return r.S2
	}
}

func applypred(rstart *gc.Flow, j *Joininfo, cond int, branch int) {
	if j.len == 0 {
		return
	}
	var pred int
	if cond == Truecond {
		pred = predinfo[rstart.Prog.As-arm.ABEQ].scond
	} else {
		pred = predinfo[rstart.Prog.As-arm.ABEQ].notscond
	}

	for r := (*gc.Flow)(j.start); ; r = successor(r) {
		if r.Prog.As == arm.AB {
			if r != j.last || branch == Delbranch {
				excise(r)
			} else {
				if cond == Truecond {
					r.Prog.As = int16(predinfo[rstart.Prog.As-arm.ABEQ].opcode)
				} else {
					r.Prog.As = int16(predinfo[rstart.Prog.As-arm.ABEQ].notopcode)
				}
			}
		} else if predicable(r.Prog) {
			r.Prog.Scond = uint8(int(r.Prog.Scond&^arm.C_SCOND) | pred)
		}
		if r.S1 != r.Link {
			r.S1 = r.Link
			r.Link.P1 = r
		}

		if r == j.last {
			break
		}
	}
}

func predicate(g *gc.Graph) {
	var t1 int
	var t2 int
	var j1 Joininfo
	var j2 Joininfo

	for r := (*gc.Flow)(g.Start); r != nil; r = r.Link {
		if isbranch(r.Prog) {
			t1 = joinsplit(r.S1, &j1)
			t2 = joinsplit(r.S2, &j2)
			if j1.last.Link != j2.start {
				continue
			}
			if j1.end == j2.end {
				if (t1 == Branch && (t2 == Join || t2 == Setcond)) || (t2 == Join && (t1 == Join || t1 == Setcond)) {
					applypred(r, &j1, Falsecond, Delbranch)
					applypred(r, &j2, Truecond, Delbranch)
					excise(r)
					continue
				}
			}

			if t1 == End || t1 == Branch {
				applypred(r, &j1, Falsecond, Keepbranch)
				excise(r)
				continue
			}
		}
	}
}

func isdconst(a *obj.Addr) bool {
	return a.Type == obj.TYPE_CONST
}

func isfloatreg(a *obj.Addr) bool {
	return arm.REG_F0 <= a.Reg && a.Reg <= arm.REG_F15
}

func stackaddr(a *obj.Addr) bool {
	return regtyp(a) && a.Reg == arm.REGSP
}

func smallindir(a *obj.Addr, reg *obj.Addr) bool {
	return reg.Type == obj.TYPE_REG && a.Type == obj.TYPE_MEM && a.Reg == reg.Reg && 0 <= a.Offset && a.Offset < 4096
}

func excise(r *gc.Flow) {
	p := (*obj.Prog)(r.Prog)
	obj.Nopout(p)
}
                                                                                                        usr/local/go/src/cmd/compile/internal/arm/prog.go                                                   0100644 0000000 0000000 00000015165 13020111411 020420  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package arm

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/arm"
)

const (
	RightRdwr = gc.RightRead | gc.RightWrite
)

// This table gives the basic information about instruction
// generated by the compiler and processed in the optimizer.
// See opt.h for bit definitions.
//
// Instructions not generated need not be listed.
// As an exception to that rule, we typically write down all the
// size variants of an operation even if we just use a subset.
//
// The table is formatted for 8-space tabs.
var progtable = [arm.ALAST]obj.ProgInfo{
	obj.ATYPE:     {Flags: gc.Pseudo | gc.Skip},
	obj.ATEXT:     {Flags: gc.Pseudo},
	obj.AFUNCDATA: {Flags: gc.Pseudo},
	obj.APCDATA:   {Flags: gc.Pseudo},
	obj.AUNDEF:    {Flags: gc.Break},
	obj.AUSEFIELD: {Flags: gc.OK},
	obj.ACHECKNIL: {Flags: gc.LeftRead},
	obj.AVARDEF:   {Flags: gc.Pseudo | gc.RightWrite},
	obj.AVARKILL:  {Flags: gc.Pseudo | gc.RightWrite},
	obj.AVARLIVE:  {Flags: gc.Pseudo | gc.LeftRead},

	// NOP is an internal no-op that also stands
	// for USED and SET annotations, not the Intel opcode.
	obj.ANOP: {Flags: gc.LeftRead | gc.RightWrite},

	// Integer.
	arm.AADC:    {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.AADD:    {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.AAND:    {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.ABIC:    {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.ACMN:    {Flags: gc.SizeL | gc.LeftRead | gc.RightRead},
	arm.ACMP:    {Flags: gc.SizeL | gc.LeftRead | gc.RightRead},
	arm.ADIVU:   {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.ADIV:    {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.AEOR:    {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.AMODU:   {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.AMOD:    {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.AMULALU: {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | RightRdwr},
	arm.AMULAL:  {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | RightRdwr},
	arm.AMULA:   {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | RightRdwr},
	arm.AMULU:   {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.AMUL:    {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.AMULL:   {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.AMULLU:  {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.AMVN:    {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite},
	arm.AORR:    {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.ARSB:    {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.ARSC:    {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.ASBC:    {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.ASLL:    {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.ASRA:    {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.ASRL:    {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.ASUB:    {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm.ATEQ:    {Flags: gc.SizeL | gc.LeftRead | gc.RightRead},
	arm.ATST:    {Flags: gc.SizeL | gc.LeftRead | gc.RightRead},

	// Floating point.
	arm.AADDD:  {Flags: gc.SizeD | gc.LeftRead | RightRdwr},
	arm.AADDF:  {Flags: gc.SizeF | gc.LeftRead | RightRdwr},
	arm.ACMPD:  {Flags: gc.SizeD | gc.LeftRead | gc.RightRead},
	arm.ACMPF:  {Flags: gc.SizeF | gc.LeftRead | gc.RightRead},
	arm.ADIVD:  {Flags: gc.SizeD | gc.LeftRead | RightRdwr},
	arm.ADIVF:  {Flags: gc.SizeF | gc.LeftRead | RightRdwr},
	arm.AMULD:  {Flags: gc.SizeD | gc.LeftRead | RightRdwr},
	arm.AMULF:  {Flags: gc.SizeF | gc.LeftRead | RightRdwr},
	arm.ASUBD:  {Flags: gc.SizeD | gc.LeftRead | RightRdwr},
	arm.ASUBF:  {Flags: gc.SizeF | gc.LeftRead | RightRdwr},
	arm.ASQRTD: {Flags: gc.SizeD | gc.LeftRead | RightRdwr},

	// Conversions.
	arm.AMOVWD: {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm.AMOVWF: {Flags: gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm.AMOVDF: {Flags: gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm.AMOVDW: {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm.AMOVFD: {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm.AMOVFW: {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv},

	// Moves.
	arm.AMOVB: {Flags: gc.SizeB | gc.LeftRead | gc.RightWrite | gc.Move},
	arm.AMOVD: {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Move},
	arm.AMOVF: {Flags: gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Move},
	arm.AMOVH: {Flags: gc.SizeW | gc.LeftRead | gc.RightWrite | gc.Move},
	arm.AMOVW: {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Move},

	// In addtion, duffzero reads R0,R1 and writes R1.  This fact is
	// encoded in peep.c
	obj.ADUFFZERO: {Flags: gc.Call},

	// In addtion, duffcopy reads R1,R2 and writes R0,R1,R2.  This fact is
	// encoded in peep.c
	obj.ADUFFCOPY: {Flags: gc.Call},

	// These should be split into the two different conversions instead
	// of overloading the one.
	arm.AMOVBS: {Flags: gc.SizeB | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm.AMOVBU: {Flags: gc.SizeB | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm.AMOVHS: {Flags: gc.SizeW | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm.AMOVHU: {Flags: gc.SizeW | gc.LeftRead | gc.RightWrite | gc.Conv},

	// Jumps.
	arm.AB:   {Flags: gc.Jump | gc.Break},
	arm.ABL:  {Flags: gc.Call},
	arm.ABEQ: {Flags: gc.Cjmp},
	arm.ABNE: {Flags: gc.Cjmp},
	arm.ABCS: {Flags: gc.Cjmp},
	arm.ABHS: {Flags: gc.Cjmp},
	arm.ABCC: {Flags: gc.Cjmp},
	arm.ABLO: {Flags: gc.Cjmp},
	arm.ABMI: {Flags: gc.Cjmp},
	arm.ABPL: {Flags: gc.Cjmp},
	arm.ABVS: {Flags: gc.Cjmp},
	arm.ABVC: {Flags: gc.Cjmp},
	arm.ABHI: {Flags: gc.Cjmp},
	arm.ABLS: {Flags: gc.Cjmp},
	arm.ABGE: {Flags: gc.Cjmp},
	arm.ABLT: {Flags: gc.Cjmp},
	arm.ABGT: {Flags: gc.Cjmp},
	arm.ABLE: {Flags: gc.Cjmp},
	obj.ARET: {Flags: gc.Break},
}

func proginfo(p *obj.Prog) {
	info := &p.Info
	*info = progtable[p.As]
	if info.Flags == 0 {
		gc.Fatalf("unknown instruction %v", p)
	}

	if p.From.Type == obj.TYPE_ADDR && p.From.Sym != nil && (info.Flags&gc.LeftRead != 0) {
		info.Flags &^= gc.LeftRead
		info.Flags |= gc.LeftAddr
	}

	if (info.Flags&gc.RegRead != 0) && p.Reg == 0 {
		info.Flags &^= gc.RegRead
		info.Flags |= gc.CanRegRead | gc.RightRead
	}

	if (p.Scond&arm.C_SCOND != arm.C_SCOND_NONE) && (info.Flags&gc.RightWrite != 0) {
		info.Flags |= gc.RightRead
	}

	switch p.As {
	case arm.ADIV,
		arm.ADIVU,
		arm.AMOD,
		arm.AMODU:
		info.Regset |= RtoB(arm.REG_R12)
	}
}
                                                                                                                                                                                                                                                                                                                                                                                                           usr/local/go/src/cmd/compile/internal/arm/reg.go                                                    0100644 0000000 0000000 00000006166 13020111411 020227  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Inferno utils/5c/reg.c
// http://code.google.com/p/inferno-os/source/browse/utils/5c/reg.c
//
//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright © 1997-1999 Vita Nuova Limited
//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright © 2004,2006 Bruce Ellis
//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package arm

import "cmd/internal/obj/arm"
import "cmd/compile/internal/gc"

const (
	NREGVAR = 32
)

var regname = []string{
	".R0",
	".R1",
	".R2",
	".R3",
	".R4",
	".R5",
	".R6",
	".R7",
	".R8",
	".R9",
	".R10",
	".R11",
	".R12",
	".R13",
	".R14",
	".R15",
	".F0",
	".F1",
	".F2",
	".F3",
	".F4",
	".F5",
	".F6",
	".F7",
	".F8",
	".F9",
	".F10",
	".F11",
	".F12",
	".F13",
	".F14",
	".F15",
}

func regnames(n *int) []string {
	*n = NREGVAR
	return regname
}

func excludedregs() uint64 {
	return RtoB(arm.REGSP) | RtoB(arm.REGLINK) | RtoB(arm.REGPC)
}

func doregbits(r int) uint64 {
	return 0
}

/*
 *	bit	reg
 *	0	R0
 *	1	R1
 *	...	...
 *	10	R10
 *	12  R12
 *
 *	bit	reg
 *	18	F2
 *	19	F3
 *	...	...
 *	31	F15
 */
func RtoB(r int) uint64 {
	if arm.REG_R0 <= r && r <= arm.REG_R15 {
		if r >= arm.REGTMP-2 && r != arm.REG_R12 { // excluded R9 and R10 for m and g, but not R12
			return 0
		}
		return 1 << uint(r-arm.REG_R0)
	}

	if arm.REG_F0 <= r && r <= arm.REG_F15 {
		if r < arm.REG_F2 || r > arm.REG_F0+arm.NFREG-1 {
			return 0
		}
		return 1 << uint((r-arm.REG_F0)+16)
	}

	return 0
}

func BtoR(b uint64) int {
	// TODO Allow R0 and R1, but be careful with a 0 return
	// TODO Allow R9. Only R10 is reserved now (just g, not m).
	b &= 0x11fc // excluded R9 and R10 for m and g, but not R12
	if b == 0 {
		return 0
	}
	return gc.Bitno(b) + arm.REG_R0
}

func BtoF(b uint64) int {
	b &= 0xfffc0000
	if b == 0 {
		return 0
	}
	return gc.Bitno(b) - 16 + arm.REG_F0
}
                                                                                                                                                                                                                                                                                                                                                                                                          usr/local/go/src/cmd/compile/internal/arm64/                                                        0040755 0000000 0000000 00000000000 13020111411 017267  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/cmd/compile/internal/arm64/cgen.go                                                 0100644 0000000 0000000 00000006440 13020111411 020533  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package arm64

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/arm64"
)

func blockcopy(n, res *gc.Node, osrc, odst, w int64) {
	// determine alignment.
	// want to avoid unaligned access, so have to use
	// smaller operations for less aligned types.
	// for example moving [4]byte must use 4 MOVB not 1 MOVW.
	align := int(n.Type.Align)

	var op int
	switch align {
	default:
		gc.Fatalf("sgen: invalid alignment %d for %v", align, n.Type)

	case 1:
		op = arm64.AMOVB

	case 2:
		op = arm64.AMOVH

	case 4:
		op = arm64.AMOVW

	case 8:
		op = arm64.AMOVD
	}

	if w%int64(align) != 0 {
		gc.Fatalf("sgen: unaligned size %d (align=%d) for %v", w, align, n.Type)
	}
	c := int32(w / int64(align))

	if osrc%int64(align) != 0 || odst%int64(align) != 0 {
		gc.Fatalf("sgen: unaligned offset src %d or dst %d (align %d)", osrc, odst, align)
	}

	// if we are copying forward on the stack and
	// the src and dst overlap, then reverse direction
	dir := align

	if osrc < odst && int64(odst) < int64(osrc)+w {
		dir = -dir
	}

	var dst gc.Node
	var src gc.Node
	if n.Ullman >= res.Ullman {
		gc.Agenr(n, &dst, res) // temporarily use dst
		gc.Regalloc(&src, gc.Types[gc.Tptr], nil)
		gins(arm64.AMOVD, &dst, &src)
		if res.Op == gc.ONAME {
			gc.Gvardef(res)
		}
		gc.Agen(res, &dst)
	} else {
		if res.Op == gc.ONAME {
			gc.Gvardef(res)
		}
		gc.Agenr(res, &dst, res)
		gc.Agenr(n, &src, nil)
	}

	var tmp gc.Node
	gc.Regalloc(&tmp, gc.Types[gc.Tptr], nil)

	// set up end marker
	var nend gc.Node

	// move src and dest to the end of block if necessary
	if dir < 0 {
		if c >= 4 {
			gc.Regalloc(&nend, gc.Types[gc.Tptr], nil)
			gins(arm64.AMOVD, &src, &nend)
		}

		p := gins(arm64.AADD, nil, &src)
		p.From.Type = obj.TYPE_CONST
		p.From.Offset = w

		p = gins(arm64.AADD, nil, &dst)
		p.From.Type = obj.TYPE_CONST
		p.From.Offset = w
	} else {
		p := gins(arm64.AADD, nil, &src)
		p.From.Type = obj.TYPE_CONST
		p.From.Offset = int64(-dir)

		p = gins(arm64.AADD, nil, &dst)
		p.From.Type = obj.TYPE_CONST
		p.From.Offset = int64(-dir)

		if c >= 4 {
			gc.Regalloc(&nend, gc.Types[gc.Tptr], nil)
			p := gins(arm64.AMOVD, &src, &nend)
			p.From.Type = obj.TYPE_ADDR
			p.From.Offset = w
		}
	}

	// move
	// TODO: enable duffcopy for larger copies.
	if c >= 4 {
		p := gins(op, &src, &tmp)
		p.From.Type = obj.TYPE_MEM
		p.From.Offset = int64(dir)
		p.Scond = arm64.C_XPRE
		ploop := p

		p = gins(op, &tmp, &dst)
		p.To.Type = obj.TYPE_MEM
		p.To.Offset = int64(dir)
		p.Scond = arm64.C_XPRE

		p = gcmp(arm64.ACMP, &src, &nend)

		gc.Patch(gc.Gbranch(arm64.ABNE, nil, 0), ploop)
		gc.Regfree(&nend)
	} else {
		// TODO(austin): Instead of generating ADD $-8,R8; ADD
		// $-8,R7; n*(MOVDU 8(R8),R9; MOVDU R9,8(R7);) just
		// generate the offsets directly and eliminate the
		// ADDs.  That will produce shorter, more
		// pipeline-able code.
		var p *obj.Prog
		for ; c > 0; c-- {
			p = gins(op, &src, &tmp)
			p.From.Type = obj.TYPE_MEM
			p.From.Offset = int64(dir)
			p.Scond = arm64.C_XPRE

			p = gins(op, &tmp, &dst)
			p.To.Type = obj.TYPE_MEM
			p.To.Offset = int64(dir)
			p.Scond = arm64.C_XPRE
		}
	}

	gc.Regfree(&dst)
	gc.Regfree(&src)
	gc.Regfree(&tmp)
}
                                                                                                                                                                                                                                usr/local/go/src/cmd/compile/internal/arm64/galign.go                                               0100644 0000000 0000000 00000004374 13020111411 021064  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package arm64

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/arm64"
)

var thechar int = '7'

var thestring string = "arm64"

var thelinkarch *obj.LinkArch = &arm64.Linkarm64

func linkarchinit() {
}

var MAXWIDTH int64 = 1 << 50

/*
 * go declares several platform-specific type aliases:
 * int, uint, and uintptr
 */
var typedefs = []gc.Typedef{
	{"int", gc.TINT, gc.TINT64},
	{"uint", gc.TUINT, gc.TUINT64},
	{"uintptr", gc.TUINTPTR, gc.TUINT64},
}

func betypeinit() {
	gc.Widthptr = 8
	gc.Widthint = 8
	gc.Widthreg = 8
}

func Main() {
	gc.Thearch.Thechar = thechar
	gc.Thearch.Thestring = thestring
	gc.Thearch.Thelinkarch = thelinkarch
	gc.Thearch.Typedefs = typedefs
	gc.Thearch.REGSP = arm64.REGSP
	gc.Thearch.REGCTXT = arm64.REGCTXT
	gc.Thearch.REGCALLX = arm64.REGRT1
	gc.Thearch.REGCALLX2 = arm64.REGRT2
	gc.Thearch.REGRETURN = arm64.REG_R0
	gc.Thearch.REGMIN = arm64.REG_R0
	gc.Thearch.REGMAX = arm64.REG_R31
	gc.Thearch.REGZERO = arm64.REGZERO
	gc.Thearch.FREGMIN = arm64.REG_F0
	gc.Thearch.FREGMAX = arm64.REG_F31
	gc.Thearch.MAXWIDTH = MAXWIDTH
	gc.Thearch.ReservedRegs = resvd

	gc.Thearch.Betypeinit = betypeinit
	gc.Thearch.Cgen_hmul = cgen_hmul
	gc.Thearch.Cgen_shift = cgen_shift
	gc.Thearch.Clearfat = clearfat
	gc.Thearch.Defframe = defframe
	gc.Thearch.Dodiv = dodiv
	gc.Thearch.Excise = excise
	gc.Thearch.Expandchecks = expandchecks
	gc.Thearch.Getg = getg
	gc.Thearch.Gins = gins
	gc.Thearch.Ginscmp = ginscmp
	gc.Thearch.Ginscon = ginscon
	gc.Thearch.Ginsnop = ginsnop
	gc.Thearch.Gmove = gmove
	gc.Thearch.Linkarchinit = linkarchinit
	gc.Thearch.Peep = peep
	gc.Thearch.Proginfo = proginfo
	gc.Thearch.Regtyp = regtyp
	gc.Thearch.Sameaddr = sameaddr
	gc.Thearch.Smallindir = smallindir
	gc.Thearch.Stackaddr = stackaddr
	gc.Thearch.Blockcopy = blockcopy
	gc.Thearch.Sudoaddable = sudoaddable
	gc.Thearch.Sudoclean = sudoclean
	gc.Thearch.Excludedregs = excludedregs
	gc.Thearch.RtoB = RtoB
	gc.Thearch.FtoB = RtoB
	gc.Thearch.BtoR = BtoR
	gc.Thearch.BtoF = BtoF
	gc.Thearch.Optoas = optoas
	gc.Thearch.Doregbits = doregbits
	gc.Thearch.Regnames = regnames

	gc.Main()
	gc.Exit(0)
}
                                                                                                                                                                                                                                                                    usr/local/go/src/cmd/compile/internal/arm64/ggen.go                                                 0100644 0000000 0000000 00000030074 13020111411 020537  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package arm64

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/arm64"
	"fmt"
)

func defframe(ptxt *obj.Prog) {
	var n *gc.Node

	// fill in argument size, stack size
	ptxt.To.Type = obj.TYPE_TEXTSIZE

	ptxt.To.Val = int32(gc.Rnd(gc.Curfn.Type.Argwid, int64(gc.Widthptr)))
	frame := uint32(gc.Rnd(gc.Stksize+gc.Maxarg, int64(gc.Widthreg)))

	// arm64 requires that the frame size (not counting saved LR)
	// be empty or be 8 mod 16. If not, pad it.
	if frame != 0 && frame%16 != 8 {
		frame += 8
	}

	ptxt.To.Offset = int64(frame)

	// insert code to zero ambiguously live variables
	// so that the garbage collector only sees initialized values
	// when it looks for pointers.
	p := ptxt

	hi := int64(0)
	lo := hi

	// iterate through declarations - they are sorted in decreasing xoffset order.
	for l := gc.Curfn.Func.Dcl; l != nil; l = l.Next {
		n = l.N
		if !n.Name.Needzero {
			continue
		}
		if n.Class != gc.PAUTO {
			gc.Fatalf("needzero class %d", n.Class)
		}
		if n.Type.Width%int64(gc.Widthptr) != 0 || n.Xoffset%int64(gc.Widthptr) != 0 || n.Type.Width == 0 {
			gc.Fatalf("var %v has size %d offset %d", gc.Nconv(n, obj.FmtLong), int(n.Type.Width), int(n.Xoffset))
		}

		if lo != hi && n.Xoffset+n.Type.Width >= lo-int64(2*gc.Widthreg) {
			// merge with range we already have
			lo = n.Xoffset

			continue
		}

		// zero old range
		p = zerorange(p, int64(frame), lo, hi)

		// set new range
		hi = n.Xoffset + n.Type.Width

		lo = n.Xoffset
	}

	// zero final range
	zerorange(p, int64(frame), lo, hi)
}

var darwin = obj.Getgoos() == "darwin"

func zerorange(p *obj.Prog, frame int64, lo int64, hi int64) *obj.Prog {
	cnt := hi - lo
	if cnt == 0 {
		return p
	}
	if cnt < int64(4*gc.Widthptr) {
		for i := int64(0); i < cnt; i += int64(gc.Widthptr) {
			p = appendpp(p, arm64.AMOVD, obj.TYPE_REG, arm64.REGZERO, 0, obj.TYPE_MEM, arm64.REGSP, 8+frame+lo+i)
		}
	} else if cnt <= int64(128*gc.Widthptr) && !darwin { // darwin ld64 cannot handle BR26 reloc with non-zero addend
		p = appendpp(p, arm64.AMOVD, obj.TYPE_REG, arm64.REGSP, 0, obj.TYPE_REG, arm64.REGRT1, 0)
		p = appendpp(p, arm64.AADD, obj.TYPE_CONST, 0, 8+frame+lo-8, obj.TYPE_REG, arm64.REGRT1, 0)
		p.Reg = arm64.REGRT1
		p = appendpp(p, obj.ADUFFZERO, obj.TYPE_NONE, 0, 0, obj.TYPE_MEM, 0, 0)
		f := gc.Sysfunc("duffzero")
		gc.Naddr(&p.To, f)
		gc.Afunclit(&p.To, f)
		p.To.Offset = 4 * (128 - cnt/int64(gc.Widthptr))
	} else {
		p = appendpp(p, arm64.AMOVD, obj.TYPE_CONST, 0, 8+frame+lo-8, obj.TYPE_REG, arm64.REGTMP, 0)
		p = appendpp(p, arm64.AMOVD, obj.TYPE_REG, arm64.REGSP, 0, obj.TYPE_REG, arm64.REGRT1, 0)
		p = appendpp(p, arm64.AADD, obj.TYPE_REG, arm64.REGTMP, 0, obj.TYPE_REG, arm64.REGRT1, 0)
		p.Reg = arm64.REGRT1
		p = appendpp(p, arm64.AMOVD, obj.TYPE_CONST, 0, cnt, obj.TYPE_REG, arm64.REGTMP, 0)
		p = appendpp(p, arm64.AADD, obj.TYPE_REG, arm64.REGTMP, 0, obj.TYPE_REG, arm64.REGRT2, 0)
		p.Reg = arm64.REGRT1
		p = appendpp(p, arm64.AMOVD, obj.TYPE_REG, arm64.REGZERO, 0, obj.TYPE_MEM, arm64.REGRT1, int64(gc.Widthptr))
		p.Scond = arm64.C_XPRE
		p1 := p
		p = appendpp(p, arm64.ACMP, obj.TYPE_REG, arm64.REGRT1, 0, obj.TYPE_NONE, 0, 0)
		p.Reg = arm64.REGRT2
		p = appendpp(p, arm64.ABNE, obj.TYPE_NONE, 0, 0, obj.TYPE_BRANCH, 0, 0)
		gc.Patch(p, p1)
	}

	return p
}

func appendpp(p *obj.Prog, as int, ftype int, freg int, foffset int64, ttype int, treg int, toffset int64) *obj.Prog {
	q := gc.Ctxt.NewProg()
	gc.Clearp(q)
	q.As = int16(as)
	q.Lineno = p.Lineno
	q.From.Type = int16(ftype)
	q.From.Reg = int16(freg)
	q.From.Offset = foffset
	q.To.Type = int16(ttype)
	q.To.Reg = int16(treg)
	q.To.Offset = toffset
	q.Link = p.Link
	p.Link = q
	return q
}

func ginsnop() {
	var con gc.Node
	gc.Nodconst(&con, gc.Types[gc.TINT], 0)
	gins(arm64.AHINT, &con, nil)
}

var panicdiv *gc.Node

/*
 * generate division.
 * generates one of:
 *	res = nl / nr
 *	res = nl % nr
 * according to op.
 */
func dodiv(op gc.Op, nl *gc.Node, nr *gc.Node, res *gc.Node) {
	// Have to be careful about handling
	// most negative int divided by -1 correctly.
	// The hardware will generate undefined result.
	// Also need to explicitly trap on division on zero,
	// the hardware will silently generate undefined result.
	// DIVW will leave unpredicable result in higher 32-bit,
	// so always use DIVD/DIVDU.
	t := nl.Type

	t0 := t
	check := false
	if gc.Issigned[t.Etype] {
		check = true
		if gc.Isconst(nl, gc.CTINT) && nl.Int() != -(1<<uint64(t.Width*8-1)) {
			check = false
		} else if gc.Isconst(nr, gc.CTINT) && nr.Int() != -1 {
			check = false
		}
	}

	if t.Width < 8 {
		if gc.Issigned[t.Etype] {
			t = gc.Types[gc.TINT64]
		} else {
			t = gc.Types[gc.TUINT64]
		}
		check = false
	}

	a := optoas(gc.ODIV, t)

	var tl gc.Node
	gc.Regalloc(&tl, t0, nil)
	var tr gc.Node
	gc.Regalloc(&tr, t0, nil)
	if nl.Ullman >= nr.Ullman {
		gc.Cgen(nl, &tl)
		gc.Cgen(nr, &tr)
	} else {
		gc.Cgen(nr, &tr)
		gc.Cgen(nl, &tl)
	}

	if t != t0 {
		// Convert
		tl2 := tl

		tr2 := tr
		tl.Type = t
		tr.Type = t
		gmove(&tl2, &tl)
		gmove(&tr2, &tr)
	}

	// Handle divide-by-zero panic.
	p1 := gins(optoas(gc.OCMP, t), &tr, nil)
	p1.Reg = arm64.REGZERO
	p1 = gc.Gbranch(optoas(gc.ONE, t), nil, +1)
	if panicdiv == nil {
		panicdiv = gc.Sysfunc("panicdivide")
	}
	gc.Ginscall(panicdiv, -1)
	gc.Patch(p1, gc.Pc)

	var p2 *obj.Prog
	if check {
		var nm1 gc.Node
		gc.Nodconst(&nm1, t, -1)
		gcmp(optoas(gc.OCMP, t), &tr, &nm1)
		p1 := gc.Gbranch(optoas(gc.ONE, t), nil, +1)
		if op == gc.ODIV {
			// a / (-1) is -a.
			gins(optoas(gc.OMINUS, t), &tl, &tl)

			gmove(&tl, res)
		} else {
			// a % (-1) is 0.
			var nz gc.Node
			gc.Nodconst(&nz, t, 0)

			gmove(&nz, res)
		}

		p2 = gc.Gbranch(obj.AJMP, nil, 0)
		gc.Patch(p1, gc.Pc)
	}

	p1 = gins(a, &tr, &tl)
	if op == gc.ODIV {
		gc.Regfree(&tr)
		gmove(&tl, res)
	} else {
		// A%B = A-(A/B*B)
		var tm gc.Node
		gc.Regalloc(&tm, t, nil)

		// patch div to use the 3 register form
		// TODO(minux): add gins3?
		p1.Reg = p1.To.Reg

		p1.To.Reg = tm.Reg
		gins(optoas(gc.OMUL, t), &tr, &tm)
		gc.Regfree(&tr)
		gins(optoas(gc.OSUB, t), &tm, &tl)
		gc.Regfree(&tm)
		gmove(&tl, res)
	}

	gc.Regfree(&tl)
	if check {
		gc.Patch(p2, gc.Pc)
	}
}

/*
 * generate high multiply:
 *   res = (nl*nr) >> width
 */
func cgen_hmul(nl *gc.Node, nr *gc.Node, res *gc.Node) {
	// largest ullman on left.
	if nl.Ullman < nr.Ullman {
		nl, nr = nr, nl
	}

	t := (*gc.Type)(nl.Type)
	w := int(int(t.Width * 8))
	var n1 gc.Node
	gc.Cgenr(nl, &n1, res)
	var n2 gc.Node
	gc.Cgenr(nr, &n2, nil)
	switch gc.Simtype[t.Etype] {
	case gc.TINT8,
		gc.TINT16,
		gc.TINT32:
		gins(optoas(gc.OMUL, t), &n2, &n1)
		p := (*obj.Prog)(gins(arm64.AASR, nil, &n1))
		p.From.Type = obj.TYPE_CONST
		p.From.Offset = int64(w)

	case gc.TUINT8,
		gc.TUINT16,
		gc.TUINT32:
		gins(optoas(gc.OMUL, t), &n2, &n1)
		p := (*obj.Prog)(gins(arm64.ALSR, nil, &n1))
		p.From.Type = obj.TYPE_CONST
		p.From.Offset = int64(w)

	case gc.TINT64,
		gc.TUINT64:
		if gc.Issigned[t.Etype] {
			gins(arm64.ASMULH, &n2, &n1)
		} else {
			gins(arm64.AUMULH, &n2, &n1)
		}

	default:
		gc.Fatalf("cgen_hmul %v", t)
	}

	gc.Cgen(&n1, res)
	gc.Regfree(&n1)
	gc.Regfree(&n2)
}

/*
 * generate shift according to op, one of:
 *	res = nl << nr
 *	res = nl >> nr
 */
func cgen_shift(op gc.Op, bounded bool, nl *gc.Node, nr *gc.Node, res *gc.Node) {
	a := int(optoas(op, nl.Type))

	if nr.Op == gc.OLITERAL {
		var n1 gc.Node
		gc.Regalloc(&n1, nl.Type, res)
		gc.Cgen(nl, &n1)
		sc := uint64(nr.Int())
		if sc >= uint64(nl.Type.Width*8) {
			// large shift gets 2 shifts by width-1
			var n3 gc.Node
			gc.Nodconst(&n3, gc.Types[gc.TUINT32], nl.Type.Width*8-1)

			gins(a, &n3, &n1)
			gins(a, &n3, &n1)
		} else {
			gins(a, nr, &n1)
		}
		gmove(&n1, res)
		gc.Regfree(&n1)
		return
	}

	if nl.Ullman >= gc.UINF {
		var n4 gc.Node
		gc.Tempname(&n4, nl.Type)
		gc.Cgen(nl, &n4)
		nl = &n4
	}

	if nr.Ullman >= gc.UINF {
		var n5 gc.Node
		gc.Tempname(&n5, nr.Type)
		gc.Cgen(nr, &n5)
		nr = &n5
	}

	// Allow either uint32 or uint64 as shift type,
	// to avoid unnecessary conversion from uint32 to uint64
	// just to do the comparison.
	tcount := gc.Types[gc.Simtype[nr.Type.Etype]]

	if tcount.Etype < gc.TUINT32 {
		tcount = gc.Types[gc.TUINT32]
	}

	var n1 gc.Node
	gc.Regalloc(&n1, nr.Type, nil) // to hold the shift type in CX
	var n3 gc.Node
	gc.Regalloc(&n3, tcount, &n1) // to clear high bits of CX

	var n2 gc.Node
	gc.Regalloc(&n2, nl.Type, res)

	if nl.Ullman >= nr.Ullman {
		gc.Cgen(nl, &n2)
		gc.Cgen(nr, &n1)
		gmove(&n1, &n3)
	} else {
		gc.Cgen(nr, &n1)
		gmove(&n1, &n3)
		gc.Cgen(nl, &n2)
	}

	gc.Regfree(&n3)

	// test and fix up large shifts
	if !bounded {
		gc.Nodconst(&n3, tcount, nl.Type.Width*8)
		gcmp(optoas(gc.OCMP, tcount), &n1, &n3)
		p1 := (*obj.Prog)(gc.Gbranch(optoas(gc.OLT, tcount), nil, +1))
		if op == gc.ORSH && gc.Issigned[nl.Type.Etype] {
			gc.Nodconst(&n3, gc.Types[gc.TUINT32], nl.Type.Width*8-1)
			gins(a, &n3, &n2)
		} else {
			gc.Nodconst(&n3, nl.Type, 0)
			gmove(&n3, &n2)
		}

		gc.Patch(p1, gc.Pc)
	}

	gins(a, &n1, &n2)

	gmove(&n2, res)

	gc.Regfree(&n1)
	gc.Regfree(&n2)
}

func clearfat(nl *gc.Node) {
	/* clear a fat object */
	if gc.Debug['g'] != 0 {
		fmt.Printf("clearfat %v (%v, size: %d)\n", nl, nl.Type, nl.Type.Width)
	}

	w := uint64(uint64(nl.Type.Width))

	// Avoid taking the address for simple enough types.
	if gc.Componentgen(nil, nl) {
		return
	}

	c := uint64(w % 8) // bytes
	q := uint64(w / 8) // dwords

	var r0 gc.Node
	gc.Nodreg(&r0, gc.Types[gc.TUINT64], arm64.REGZERO)
	var dst gc.Node

	// REGRT1 is reserved on arm64, see arm64/gsubr.go.
	gc.Nodreg(&dst, gc.Types[gc.Tptr], arm64.REGRT1)
	gc.Agen(nl, &dst)

	var boff uint64
	if q > 128 {
		p := gins(arm64.ASUB, nil, &dst)
		p.From.Type = obj.TYPE_CONST
		p.From.Offset = 8

		var end gc.Node
		gc.Regalloc(&end, gc.Types[gc.Tptr], nil)
		p = gins(arm64.AMOVD, &dst, &end)
		p.From.Type = obj.TYPE_ADDR
		p.From.Offset = int64(q * 8)

		p = gins(arm64.AMOVD, &r0, &dst)
		p.To.Type = obj.TYPE_MEM
		p.To.Offset = 8
		p.Scond = arm64.C_XPRE
		pl := (*obj.Prog)(p)

		p = gcmp(arm64.ACMP, &dst, &end)
		gc.Patch(gc.Gbranch(arm64.ABNE, nil, 0), pl)

		gc.Regfree(&end)

		// The loop leaves R16 on the last zeroed dword
		boff = 8
	} else if q >= 4 && !darwin { // darwin ld64 cannot handle BR26 reloc with non-zero addend
		p := gins(arm64.ASUB, nil, &dst)
		p.From.Type = obj.TYPE_CONST
		p.From.Offset = 8
		f := (*gc.Node)(gc.Sysfunc("duffzero"))
		p = gins(obj.ADUFFZERO, nil, f)
		gc.Afunclit(&p.To, f)

		// 4 and 128 = magic constants: see ../../runtime/asm_arm64x.s
		p.To.Offset = int64(4 * (128 - q))

		// duffzero leaves R16 on the last zeroed dword
		boff = 8
	} else {
		var p *obj.Prog
		for t := uint64(0); t < q; t++ {
			p = gins(arm64.AMOVD, &r0, &dst)
			p.To.Type = obj.TYPE_MEM
			p.To.Offset = int64(8 * t)
		}

		boff = 8 * q
	}

	var p *obj.Prog
	for t := uint64(0); t < c; t++ {
		p = gins(arm64.AMOVB, &r0, &dst)
		p.To.Type = obj.TYPE_MEM
		p.To.Offset = int64(t + boff)
	}
}

// Called after regopt and peep have run.
// Expand CHECKNIL pseudo-op into actual nil pointer check.
func expandchecks(firstp *obj.Prog) {
	var p1 *obj.Prog

	for p := (*obj.Prog)(firstp); p != nil; p = p.Link {
		if gc.Debug_checknil != 0 && gc.Ctxt.Debugvlog != 0 {
			fmt.Printf("expandchecks: %v\n", p)
		}
		if p.As != obj.ACHECKNIL {
			continue
		}
		if gc.Debug_checknil != 0 && p.Lineno > 1 { // p->lineno==1 in generated wrappers
			gc.Warnl(int(p.Lineno), "generated nil check")
		}
		if p.From.Type != obj.TYPE_REG {
			gc.Fatalf("invalid nil check %v\n", p)
		}

		// check is
		//	CBNZ arg, 2(PC)
		//	MOVD ZR, 0(arg)
		p1 = gc.Ctxt.NewProg()
		gc.Clearp(p1)
		p1.Link = p.Link
		p.Link = p1
		p1.Lineno = p.Lineno
		p1.Pc = 9999

		p.As = arm64.ACBNZ
		p.To.Type = obj.TYPE_BRANCH
		p.To.Val = p1.Link

		// crash by write to memory address 0.
		p1.As = arm64.AMOVD
		p1.From.Type = obj.TYPE_REG
		p1.From.Reg = arm64.REGZERO
		p1.To.Type = obj.TYPE_MEM
		p1.To.Reg = p.From.Reg
		p1.To.Offset = 0
	}
}

// res = runtime.getg()
func getg(res *gc.Node) {
	var n1 gc.Node
	gc.Nodreg(&n1, res.Type, arm64.REGG)
	gmove(&n1, res)
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    usr/local/go/src/cmd/compile/internal/arm64/gsubr.go                                                0100644 0000000 0000000 00000050760 13020111411 020745  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Derived from Inferno utils/6c/txt.c
// http://code.google.com/p/inferno-os/source/browse/utils/6c/txt.c
//
//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright © 1997-1999 Vita Nuova Limited
//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright © 2004,2006 Bruce Ellis
//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package arm64

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/arm64"
	"fmt"
)

var resvd = []int{
	arm64.REGTMP,
	arm64.REGG,
	arm64.REGRT1,
	arm64.REGRT2,
	arm64.REG_R31, // REGZERO and REGSP
	arm64.FREGZERO,
	arm64.FREGHALF,
	arm64.FREGONE,
	arm64.FREGTWO,
}

/*
 * generate
 *	as $c, n
 */
func ginscon(as int, c int64, n2 *gc.Node) {
	var n1 gc.Node

	gc.Nodconst(&n1, gc.Types[gc.TINT64], c)

	if as != arm64.AMOVD && (c < -arm64.BIG || c > arm64.BIG) || as == arm64.AMUL || n2 != nil && n2.Op != gc.OREGISTER {
		// cannot have more than 16-bit of immediate in ADD, etc.
		// instead, MOV into register first.
		var ntmp gc.Node
		gc.Regalloc(&ntmp, gc.Types[gc.TINT64], nil)

		gins(arm64.AMOVD, &n1, &ntmp)
		gins(as, &ntmp, n2)
		gc.Regfree(&ntmp)
		return
	}

	rawgins(as, &n1, n2)
}

/*
 * generate
 *	as n, $c (CMP)
 */
func ginscon2(as int, n2 *gc.Node, c int64) {
	var n1 gc.Node

	gc.Nodconst(&n1, gc.Types[gc.TINT64], c)

	switch as {
	default:
		gc.Fatalf("ginscon2")

	case arm64.ACMP:
		if -arm64.BIG <= c && c <= arm64.BIG {
			gcmp(as, n2, &n1)
			return
		}
	}

	// MOV n1 into register first
	var ntmp gc.Node
	gc.Regalloc(&ntmp, gc.Types[gc.TINT64], nil)

	rawgins(arm64.AMOVD, &n1, &ntmp)
	gcmp(as, n2, &ntmp)
	gc.Regfree(&ntmp)
}

func ginscmp(op gc.Op, t *gc.Type, n1, n2 *gc.Node, likely int) *obj.Prog {
	if gc.Isint[t.Etype] && n1.Op == gc.OLITERAL && n2.Op != gc.OLITERAL {
		// Reverse comparison to place constant last.
		op = gc.Brrev(op)
		n1, n2 = n2, n1
	}

	var r1, r2, g1, g2 gc.Node
	gc.Regalloc(&r1, t, n1)
	gc.Regalloc(&g1, n1.Type, &r1)
	gc.Cgen(n1, &g1)
	gmove(&g1, &r1)
	if gc.Isint[t.Etype] && gc.Isconst(n2, gc.CTINT) {
		ginscon2(optoas(gc.OCMP, t), &r1, n2.Int())
	} else {
		gc.Regalloc(&r2, t, n2)
		gc.Regalloc(&g2, n1.Type, &r2)
		gc.Cgen(n2, &g2)
		gmove(&g2, &r2)
		gcmp(optoas(gc.OCMP, t), &r1, &r2)
		gc.Regfree(&g2)
		gc.Regfree(&r2)
	}
	gc.Regfree(&g1)
	gc.Regfree(&r1)
	return gc.Gbranch(optoas(op, t), nil, likely)
}

/*
 * generate move:
 *	t = f
 * hard part is conversions.
 */
func gmove(f *gc.Node, t *gc.Node) {
	if gc.Debug['M'] != 0 {
		fmt.Printf("gmove %v -> %v\n", gc.Nconv(f, obj.FmtLong), gc.Nconv(t, obj.FmtLong))
	}

	ft := int(gc.Simsimtype(f.Type))
	tt := int(gc.Simsimtype(t.Type))
	cvt := (*gc.Type)(t.Type)

	if gc.Iscomplex[ft] || gc.Iscomplex[tt] {
		gc.Complexmove(f, t)
		return
	}

	// cannot have two memory operands
	var r1 gc.Node
	var a int
	if gc.Ismem(f) && gc.Ismem(t) {
		goto hard
	}

	// convert constant to desired type
	if f.Op == gc.OLITERAL {
		var con gc.Node
		switch tt {
		default:
			f.Convconst(&con, t.Type)

		case gc.TINT32,
			gc.TINT16,
			gc.TINT8:
			var con gc.Node
			f.Convconst(&con, gc.Types[gc.TINT64])
			var r1 gc.Node
			gc.Regalloc(&r1, con.Type, t)
			gins(arm64.AMOVD, &con, &r1)
			gmove(&r1, t)
			gc.Regfree(&r1)
			return

		case gc.TUINT32,
			gc.TUINT16,
			gc.TUINT8:
			var con gc.Node
			f.Convconst(&con, gc.Types[gc.TUINT64])
			var r1 gc.Node
			gc.Regalloc(&r1, con.Type, t)
			gins(arm64.AMOVD, &con, &r1)
			gmove(&r1, t)
			gc.Regfree(&r1)
			return
		}

		f = &con
		ft = tt // so big switch will choose a simple mov

		// constants can't move directly to memory.
		if gc.Ismem(t) {
			goto hard
		}
	}

	// value -> value copy, first operand in memory.
	// any floating point operand requires register
	// src, so goto hard to copy to register first.
	if gc.Ismem(f) && ft != tt && (gc.Isfloat[ft] || gc.Isfloat[tt]) {
		cvt = gc.Types[ft]
		goto hard
	}

	// value -> value copy, only one memory operand.
	// figure out the instruction to use.
	// break out of switch for one-instruction gins.
	// goto rdst for "destination must be register".
	// goto hard for "convert to cvt type first".
	// otherwise handle and return.

	switch uint32(ft)<<16 | uint32(tt) {
	default:
		gc.Fatalf("gmove %v -> %v", gc.Tconv(f.Type, obj.FmtLong), gc.Tconv(t.Type, obj.FmtLong))

		/*
		 * integer copy and truncate
		 */
	case gc.TINT8<<16 | gc.TINT8, // same size
		gc.TUINT8<<16 | gc.TINT8,
		gc.TINT16<<16 | gc.TINT8,
		// truncate
		gc.TUINT16<<16 | gc.TINT8,
		gc.TINT32<<16 | gc.TINT8,
		gc.TUINT32<<16 | gc.TINT8,
		gc.TINT64<<16 | gc.TINT8,
		gc.TUINT64<<16 | gc.TINT8:
		a = arm64.AMOVB

	case gc.TINT8<<16 | gc.TUINT8, // same size
		gc.TUINT8<<16 | gc.TUINT8,
		gc.TINT16<<16 | gc.TUINT8,
		// truncate
		gc.TUINT16<<16 | gc.TUINT8,
		gc.TINT32<<16 | gc.TUINT8,
		gc.TUINT32<<16 | gc.TUINT8,
		gc.TINT64<<16 | gc.TUINT8,
		gc.TUINT64<<16 | gc.TUINT8:
		a = arm64.AMOVBU

	case gc.TINT16<<16 | gc.TINT16, // same size
		gc.TUINT16<<16 | gc.TINT16,
		gc.TINT32<<16 | gc.TINT16,
		// truncate
		gc.TUINT32<<16 | gc.TINT16,
		gc.TINT64<<16 | gc.TINT16,
		gc.TUINT64<<16 | gc.TINT16:
		a = arm64.AMOVH

	case gc.TINT16<<16 | gc.TUINT16, // same size
		gc.TUINT16<<16 | gc.TUINT16,
		gc.TINT32<<16 | gc.TUINT16,
		// truncate
		gc.TUINT32<<16 | gc.TUINT16,
		gc.TINT64<<16 | gc.TUINT16,
		gc.TUINT64<<16 | gc.TUINT16:
		a = arm64.AMOVHU

	case gc.TINT32<<16 | gc.TINT32, // same size
		gc.TUINT32<<16 | gc.TINT32,
		gc.TINT64<<16 | gc.TINT32,
		// truncate
		gc.TUINT64<<16 | gc.TINT32:
		a = arm64.AMOVW

	case gc.TINT32<<16 | gc.TUINT32, // same size
		gc.TUINT32<<16 | gc.TUINT32,
		gc.TINT64<<16 | gc.TUINT32,
		gc.TUINT64<<16 | gc.TUINT32:
		a = arm64.AMOVWU

	case gc.TINT64<<16 | gc.TINT64, // same size
		gc.TINT64<<16 | gc.TUINT64,
		gc.TUINT64<<16 | gc.TINT64,
		gc.TUINT64<<16 | gc.TUINT64:
		a = arm64.AMOVD

		/*
		 * integer up-conversions
		 */
	case gc.TINT8<<16 | gc.TINT16, // sign extend int8
		gc.TINT8<<16 | gc.TUINT16,
		gc.TINT8<<16 | gc.TINT32,
		gc.TINT8<<16 | gc.TUINT32,
		gc.TINT8<<16 | gc.TINT64,
		gc.TINT8<<16 | gc.TUINT64:
		a = arm64.AMOVB

		goto rdst

	case gc.TUINT8<<16 | gc.TINT16, // zero extend uint8
		gc.TUINT8<<16 | gc.TUINT16,
		gc.TUINT8<<16 | gc.TINT32,
		gc.TUINT8<<16 | gc.TUINT32,
		gc.TUINT8<<16 | gc.TINT64,
		gc.TUINT8<<16 | gc.TUINT64:
		a = arm64.AMOVBU

		goto rdst

	case gc.TINT16<<16 | gc.TINT32, // sign extend int16
		gc.TINT16<<16 | gc.TUINT32,
		gc.TINT16<<16 | gc.TINT64,
		gc.TINT16<<16 | gc.TUINT64:
		a = arm64.AMOVH

		goto rdst

	case gc.TUINT16<<16 | gc.TINT32, // zero extend uint16
		gc.TUINT16<<16 | gc.TUINT32,
		gc.TUINT16<<16 | gc.TINT64,
		gc.TUINT16<<16 | gc.TUINT64:
		a = arm64.AMOVHU

		goto rdst

	case gc.TINT32<<16 | gc.TINT64, // sign extend int32
		gc.TINT32<<16 | gc.TUINT64:
		a = arm64.AMOVW

		goto rdst

	case gc.TUINT32<<16 | gc.TINT64, // zero extend uint32
		gc.TUINT32<<16 | gc.TUINT64:
		a = arm64.AMOVWU

		goto rdst

	/*
	* float to integer
	 */
	case gc.TFLOAT32<<16 | gc.TINT32:
		a = arm64.AFCVTZSSW
		goto rdst

	case gc.TFLOAT64<<16 | gc.TINT32:
		a = arm64.AFCVTZSDW
		goto rdst

	case gc.TFLOAT32<<16 | gc.TINT64:
		a = arm64.AFCVTZSS
		goto rdst

	case gc.TFLOAT64<<16 | gc.TINT64:
		a = arm64.AFCVTZSD
		goto rdst

	case gc.TFLOAT32<<16 | gc.TUINT32:
		a = arm64.AFCVTZUSW
		goto rdst

	case gc.TFLOAT64<<16 | gc.TUINT32:
		a = arm64.AFCVTZUDW
		goto rdst

	case gc.TFLOAT32<<16 | gc.TUINT64:
		a = arm64.AFCVTZUS
		goto rdst

	case gc.TFLOAT64<<16 | gc.TUINT64:
		a = arm64.AFCVTZUD
		goto rdst

	case gc.TFLOAT32<<16 | gc.TINT16,
		gc.TFLOAT32<<16 | gc.TINT8,
		gc.TFLOAT64<<16 | gc.TINT16,
		gc.TFLOAT64<<16 | gc.TINT8:
		cvt = gc.Types[gc.TINT32]

		goto hard

	case gc.TFLOAT32<<16 | gc.TUINT16,
		gc.TFLOAT32<<16 | gc.TUINT8,
		gc.TFLOAT64<<16 | gc.TUINT16,
		gc.TFLOAT64<<16 | gc.TUINT8:
		cvt = gc.Types[gc.TUINT32]

		goto hard

	/*
	 * integer to float
	 */
	case gc.TINT8<<16 | gc.TFLOAT32,
		gc.TINT16<<16 | gc.TFLOAT32,
		gc.TINT32<<16 | gc.TFLOAT32:
		a = arm64.ASCVTFWS

		goto rdst

	case gc.TINT8<<16 | gc.TFLOAT64,
		gc.TINT16<<16 | gc.TFLOAT64,
		gc.TINT32<<16 | gc.TFLOAT64:
		a = arm64.ASCVTFWD

		goto rdst

	case gc.TINT64<<16 | gc.TFLOAT32:
		a = arm64.ASCVTFS
		goto rdst

	case gc.TINT64<<16 | gc.TFLOAT64:
		a = arm64.ASCVTFD
		goto rdst

	case gc.TUINT8<<16 | gc.TFLOAT32,
		gc.TUINT16<<16 | gc.TFLOAT32,
		gc.TUINT32<<16 | gc.TFLOAT32:
		a = arm64.AUCVTFWS

		goto rdst

	case gc.TUINT8<<16 | gc.TFLOAT64,
		gc.TUINT16<<16 | gc.TFLOAT64,
		gc.TUINT32<<16 | gc.TFLOAT64:
		a = arm64.AUCVTFWD

		goto rdst

	case gc.TUINT64<<16 | gc.TFLOAT32:
		a = arm64.AUCVTFS
		goto rdst

	case gc.TUINT64<<16 | gc.TFLOAT64:
		a = arm64.AUCVTFD
		goto rdst

		/*
		 * float to float
		 */
	case gc.TFLOAT32<<16 | gc.TFLOAT32:
		a = arm64.AFMOVS

	case gc.TFLOAT64<<16 | gc.TFLOAT64:
		a = arm64.AFMOVD

	case gc.TFLOAT32<<16 | gc.TFLOAT64:
		a = arm64.AFCVTSD
		goto rdst

	case gc.TFLOAT64<<16 | gc.TFLOAT32:
		a = arm64.AFCVTDS
		goto rdst
	}

	gins(a, f, t)
	return

	// requires register destination
rdst:
	gc.Regalloc(&r1, t.Type, t)

	gins(a, f, &r1)
	gmove(&r1, t)
	gc.Regfree(&r1)
	return

	// requires register intermediate
hard:
	gc.Regalloc(&r1, cvt, t)

	gmove(f, &r1)
	gmove(&r1, t)
	gc.Regfree(&r1)
	return
}

// gins is called by the front end.
// It synthesizes some multiple-instruction sequences
// so the front end can stay simpler.
func gins(as int, f, t *gc.Node) *obj.Prog {
	if as >= obj.A_ARCHSPECIFIC {
		if x, ok := f.IntLiteral(); ok {
			ginscon(as, x, t)
			return nil // caller must not use
		}
	}
	if as == arm64.ACMP {
		if x, ok := t.IntLiteral(); ok {
			ginscon2(as, f, x)
			return nil // caller must not use
		}
	}
	return rawgins(as, f, t)
}

/*
 * generate one instruction:
 *	as f, t
 */
func rawgins(as int, f *gc.Node, t *gc.Node) *obj.Prog {
	// TODO(austin): Add self-move test like in 6g (but be careful
	// of truncation moves)

	p := gc.Prog(as)
	gc.Naddr(&p.From, f)
	gc.Naddr(&p.To, t)

	switch as {
	case arm64.ACMP, arm64.AFCMPS, arm64.AFCMPD:
		if t != nil {
			if f.Op != gc.OREGISTER {
				gc.Fatalf("bad operands to gcmp")
			}
			p.From = p.To
			p.To = obj.Addr{}
			raddr(f, p)
		}
	}

	// Bad things the front end has done to us. Crash to find call stack.
	switch as {
	case arm64.AAND, arm64.AMUL:
		if p.From.Type == obj.TYPE_CONST {
			gc.Debug['h'] = 1
			gc.Fatalf("bad inst: %v", p)
		}
	case arm64.ACMP:
		if p.From.Type == obj.TYPE_MEM || p.To.Type == obj.TYPE_MEM {
			gc.Debug['h'] = 1
			gc.Fatalf("bad inst: %v", p)
		}
	}

	if gc.Debug['g'] != 0 {
		fmt.Printf("%v\n", p)
	}

	w := int32(0)
	switch as {
	case arm64.AMOVB,
		arm64.AMOVBU:
		w = 1

	case arm64.AMOVH,
		arm64.AMOVHU:
		w = 2

	case arm64.AMOVW,
		arm64.AMOVWU:
		w = 4

	case arm64.AMOVD:
		if p.From.Type == obj.TYPE_CONST || p.From.Type == obj.TYPE_ADDR {
			break
		}
		w = 8
	}

	if w != 0 && ((f != nil && p.From.Width < int64(w)) || (t != nil && p.To.Type != obj.TYPE_REG && p.To.Width > int64(w))) {
		gc.Dump("f", f)
		gc.Dump("t", t)
		gc.Fatalf("bad width: %v (%d, %d)\n", p, p.From.Width, p.To.Width)
	}

	return p
}

/*
 * insert n into reg slot of p
 */
func raddr(n *gc.Node, p *obj.Prog) {
	var a obj.Addr

	gc.Naddr(&a, n)
	if a.Type != obj.TYPE_REG {
		if n != nil {
			gc.Fatalf("bad in raddr: %v", gc.Oconv(int(n.Op), 0))
		} else {
			gc.Fatalf("bad in raddr: <null>")
		}
		p.Reg = 0
	} else {
		p.Reg = a.Reg
	}
}

func gcmp(as int, lhs *gc.Node, rhs *gc.Node) *obj.Prog {
	if lhs.Op != gc.OREGISTER {
		gc.Fatalf("bad operands to gcmp: %v %v", gc.Oconv(int(lhs.Op), 0), gc.Oconv(int(rhs.Op), 0))
	}

	p := rawgins(as, rhs, nil)
	raddr(lhs, p)
	return p
}

/*
 * return Axxx for Oxxx on type t.
 */
func optoas(op gc.Op, t *gc.Type) int {
	if t == nil {
		gc.Fatalf("optoas: t is nil")
	}

	// avoid constant conversions in switches below
	const (
		OMINUS_ = uint32(gc.OMINUS) << 16
		OLSH_   = uint32(gc.OLSH) << 16
		ORSH_   = uint32(gc.ORSH) << 16
		OADD_   = uint32(gc.OADD) << 16
		OSUB_   = uint32(gc.OSUB) << 16
		OMUL_   = uint32(gc.OMUL) << 16
		ODIV_   = uint32(gc.ODIV) << 16
		OOR_    = uint32(gc.OOR) << 16
		OAND_   = uint32(gc.OAND) << 16
		OXOR_   = uint32(gc.OXOR) << 16
		OEQ_    = uint32(gc.OEQ) << 16
		ONE_    = uint32(gc.ONE) << 16
		OLT_    = uint32(gc.OLT) << 16
		OLE_    = uint32(gc.OLE) << 16
		OGE_    = uint32(gc.OGE) << 16
		OGT_    = uint32(gc.OGT) << 16
		OCMP_   = uint32(gc.OCMP) << 16
		OAS_    = uint32(gc.OAS) << 16
		OHMUL_  = uint32(gc.OHMUL) << 16
		OSQRT_  = uint32(gc.OSQRT) << 16
	)

	a := int(obj.AXXX)
	switch uint32(op)<<16 | uint32(gc.Simtype[t.Etype]) {
	default:
		gc.Fatalf("optoas: no entry for op=%v type=%v", gc.Oconv(int(op), 0), t)

	case OEQ_ | gc.TBOOL,
		OEQ_ | gc.TINT8,
		OEQ_ | gc.TUINT8,
		OEQ_ | gc.TINT16,
		OEQ_ | gc.TUINT16,
		OEQ_ | gc.TINT32,
		OEQ_ | gc.TUINT32,
		OEQ_ | gc.TINT64,
		OEQ_ | gc.TUINT64,
		OEQ_ | gc.TPTR32,
		OEQ_ | gc.TPTR64,
		OEQ_ | gc.TFLOAT32,
		OEQ_ | gc.TFLOAT64:
		a = arm64.ABEQ

	case ONE_ | gc.TBOOL,
		ONE_ | gc.TINT8,
		ONE_ | gc.TUINT8,
		ONE_ | gc.TINT16,
		ONE_ | gc.TUINT16,
		ONE_ | gc.TINT32,
		ONE_ | gc.TUINT32,
		ONE_ | gc.TINT64,
		ONE_ | gc.TUINT64,
		ONE_ | gc.TPTR32,
		ONE_ | gc.TPTR64,
		ONE_ | gc.TFLOAT32,
		ONE_ | gc.TFLOAT64:
		a = arm64.ABNE

	case OLT_ | gc.TINT8,
		OLT_ | gc.TINT16,
		OLT_ | gc.TINT32,
		OLT_ | gc.TINT64:
		a = arm64.ABLT

	case OLT_ | gc.TUINT8,
		OLT_ | gc.TUINT16,
		OLT_ | gc.TUINT32,
		OLT_ | gc.TUINT64,
		OLT_ | gc.TFLOAT32,
		OLT_ | gc.TFLOAT64:
		a = arm64.ABLO

	case OLE_ | gc.TINT8,
		OLE_ | gc.TINT16,
		OLE_ | gc.TINT32,
		OLE_ | gc.TINT64:
		a = arm64.ABLE

	case OLE_ | gc.TUINT8,
		OLE_ | gc.TUINT16,
		OLE_ | gc.TUINT32,
		OLE_ | gc.TUINT64,
		OLE_ | gc.TFLOAT32,
		OLE_ | gc.TFLOAT64:
		a = arm64.ABLS

	case OGT_ | gc.TINT8,
		OGT_ | gc.TINT16,
		OGT_ | gc.TINT32,
		OGT_ | gc.TINT64,
		OGT_ | gc.TFLOAT32,
		OGT_ | gc.TFLOAT64:
		a = arm64.ABGT

	case OGT_ | gc.TUINT8,
		OGT_ | gc.TUINT16,
		OGT_ | gc.TUINT32,
		OGT_ | gc.TUINT64:
		a = arm64.ABHI

	case OGE_ | gc.TINT8,
		OGE_ | gc.TINT16,
		OGE_ | gc.TINT32,
		OGE_ | gc.TINT64,
		OGE_ | gc.TFLOAT32,
		OGE_ | gc.TFLOAT64:
		a = arm64.ABGE

	case OGE_ | gc.TUINT8,
		OGE_ | gc.TUINT16,
		OGE_ | gc.TUINT32,
		OGE_ | gc.TUINT64:
		a = arm64.ABHS

	case OCMP_ | gc.TBOOL,
		OCMP_ | gc.TINT8,
		OCMP_ | gc.TINT16,
		OCMP_ | gc.TINT32,
		OCMP_ | gc.TPTR32,
		OCMP_ | gc.TINT64,
		OCMP_ | gc.TUINT8,
		OCMP_ | gc.TUINT16,
		OCMP_ | gc.TUINT32,
		OCMP_ | gc.TUINT64,
		OCMP_ | gc.TPTR64:
		a = arm64.ACMP

	case OCMP_ | gc.TFLOAT32:
		a = arm64.AFCMPS

	case OCMP_ | gc.TFLOAT64:
		a = arm64.AFCMPD

	case OAS_ | gc.TBOOL,
		OAS_ | gc.TINT8:
		a = arm64.AMOVB

	case OAS_ | gc.TUINT8:
		a = arm64.AMOVBU

	case OAS_ | gc.TINT16:
		a = arm64.AMOVH

	case OAS_ | gc.TUINT16:
		a = arm64.AMOVHU

	case OAS_ | gc.TINT32:
		a = arm64.AMOVW

	case OAS_ | gc.TUINT32,
		OAS_ | gc.TPTR32:
		a = arm64.AMOVWU

	case OAS_ | gc.TINT64,
		OAS_ | gc.TUINT64,
		OAS_ | gc.TPTR64:
		a = arm64.AMOVD

	case OAS_ | gc.TFLOAT32:
		a = arm64.AFMOVS

	case OAS_ | gc.TFLOAT64:
		a = arm64.AFMOVD

	case OADD_ | gc.TINT8,
		OADD_ | gc.TUINT8,
		OADD_ | gc.TINT16,
		OADD_ | gc.TUINT16,
		OADD_ | gc.TINT32,
		OADD_ | gc.TUINT32,
		OADD_ | gc.TPTR32,
		OADD_ | gc.TINT64,
		OADD_ | gc.TUINT64,
		OADD_ | gc.TPTR64:
		a = arm64.AADD

	case OADD_ | gc.TFLOAT32:
		a = arm64.AFADDS

	case OADD_ | gc.TFLOAT64:
		a = arm64.AFADDD

	case OSUB_ | gc.TINT8,
		OSUB_ | gc.TUINT8,
		OSUB_ | gc.TINT16,
		OSUB_ | gc.TUINT16,
		OSUB_ | gc.TINT32,
		OSUB_ | gc.TUINT32,
		OSUB_ | gc.TPTR32,
		OSUB_ | gc.TINT64,
		OSUB_ | gc.TUINT64,
		OSUB_ | gc.TPTR64:
		a = arm64.ASUB

	case OSUB_ | gc.TFLOAT32:
		a = arm64.AFSUBS

	case OSUB_ | gc.TFLOAT64:
		a = arm64.AFSUBD

	case OMINUS_ | gc.TINT8,
		OMINUS_ | gc.TUINT8,
		OMINUS_ | gc.TINT16,
		OMINUS_ | gc.TUINT16,
		OMINUS_ | gc.TINT32,
		OMINUS_ | gc.TUINT32,
		OMINUS_ | gc.TPTR32,
		OMINUS_ | gc.TINT64,
		OMINUS_ | gc.TUINT64,
		OMINUS_ | gc.TPTR64:
		a = arm64.ANEG

	case OMINUS_ | gc.TFLOAT32:
		a = arm64.AFNEGS

	case OMINUS_ | gc.TFLOAT64:
		a = arm64.AFNEGD

	case OAND_ | gc.TINT8,
		OAND_ | gc.TUINT8,
		OAND_ | gc.TINT16,
		OAND_ | gc.TUINT16,
		OAND_ | gc.TINT32,
		OAND_ | gc.TUINT32,
		OAND_ | gc.TPTR32,
		OAND_ | gc.TINT64,
		OAND_ | gc.TUINT64,
		OAND_ | gc.TPTR64:
		a = arm64.AAND

	case OOR_ | gc.TINT8,
		OOR_ | gc.TUINT8,
		OOR_ | gc.TINT16,
		OOR_ | gc.TUINT16,
		OOR_ | gc.TINT32,
		OOR_ | gc.TUINT32,
		OOR_ | gc.TPTR32,
		OOR_ | gc.TINT64,
		OOR_ | gc.TUINT64,
		OOR_ | gc.TPTR64:
		a = arm64.AORR

	case OXOR_ | gc.TINT8,
		OXOR_ | gc.TUINT8,
		OXOR_ | gc.TINT16,
		OXOR_ | gc.TUINT16,
		OXOR_ | gc.TINT32,
		OXOR_ | gc.TUINT32,
		OXOR_ | gc.TPTR32,
		OXOR_ | gc.TINT64,
		OXOR_ | gc.TUINT64,
		OXOR_ | gc.TPTR64:
		a = arm64.AEOR

		// TODO(minux): handle rotates
	//case CASE(OLROT, TINT8):
	//case CASE(OLROT, TUINT8):
	//case CASE(OLROT, TINT16):
	//case CASE(OLROT, TUINT16):
	//case CASE(OLROT, TINT32):
	//case CASE(OLROT, TUINT32):
	//case CASE(OLROT, TPTR32):
	//case CASE(OLROT, TINT64):
	//case CASE(OLROT, TUINT64):
	//case CASE(OLROT, TPTR64):
	//	a = 0//???; RLDC?
	//	break;

	case OLSH_ | gc.TINT8,
		OLSH_ | gc.TUINT8,
		OLSH_ | gc.TINT16,
		OLSH_ | gc.TUINT16,
		OLSH_ | gc.TINT32,
		OLSH_ | gc.TUINT32,
		OLSH_ | gc.TPTR32,
		OLSH_ | gc.TINT64,
		OLSH_ | gc.TUINT64,
		OLSH_ | gc.TPTR64:
		a = arm64.ALSL

	case ORSH_ | gc.TUINT8,
		ORSH_ | gc.TUINT16,
		ORSH_ | gc.TUINT32,
		ORSH_ | gc.TPTR32,
		ORSH_ | gc.TUINT64,
		ORSH_ | gc.TPTR64:
		a = arm64.ALSR

	case ORSH_ | gc.TINT8,
		ORSH_ | gc.TINT16,
		ORSH_ | gc.TINT32,
		ORSH_ | gc.TINT64:
		a = arm64.AASR

		// TODO(minux): handle rotates
	//case CASE(ORROTC, TINT8):
	//case CASE(ORROTC, TUINT8):
	//case CASE(ORROTC, TINT16):
	//case CASE(ORROTC, TUINT16):
	//case CASE(ORROTC, TINT32):
	//case CASE(ORROTC, TUINT32):
	//case CASE(ORROTC, TINT64):
	//case CASE(ORROTC, TUINT64):
	//	a = 0//??? RLDC??
	//	break;

	case OHMUL_ | gc.TINT64:
		a = arm64.ASMULH

	case OHMUL_ | gc.TUINT64,
		OHMUL_ | gc.TPTR64:
		a = arm64.AUMULH

	case OMUL_ | gc.TINT8,
		OMUL_ | gc.TINT16,
		OMUL_ | gc.TINT32:
		a = arm64.ASMULL

	case OMUL_ | gc.TINT64:
		a = arm64.AMUL

	case OMUL_ | gc.TUINT8,
		OMUL_ | gc.TUINT16,
		OMUL_ | gc.TUINT32,
		OMUL_ | gc.TPTR32:
		// don't use word multiply, the high 32-bit are undefined.
		a = arm64.AUMULL

	case OMUL_ | gc.TUINT64,
		OMUL_ | gc.TPTR64:
		a = arm64.AMUL // for 64-bit multiplies, signedness doesn't matter.

	case OMUL_ | gc.TFLOAT32:
		a = arm64.AFMULS

	case OMUL_ | gc.TFLOAT64:
		a = arm64.AFMULD

	case ODIV_ | gc.TINT8,
		ODIV_ | gc.TINT16,
		ODIV_ | gc.TINT32,
		ODIV_ | gc.TINT64:
		a = arm64.ASDIV

	case ODIV_ | gc.TUINT8,
		ODIV_ | gc.TUINT16,
		ODIV_ | gc.TUINT32,
		ODIV_ | gc.TPTR32,
		ODIV_ | gc.TUINT64,
		ODIV_ | gc.TPTR64:
		a = arm64.AUDIV

	case ODIV_ | gc.TFLOAT32:
		a = arm64.AFDIVS

	case ODIV_ | gc.TFLOAT64:
		a = arm64.AFDIVD

	case OSQRT_ | gc.TFLOAT64:
		a = arm64.AFSQRTD
	}

	return a
}

const (
	ODynam   = 1 << 0
	OAddable = 1 << 1
)

func xgen(n *gc.Node, a *gc.Node, o int) bool {
	// TODO(minux)

	return -1 != 0 /*TypeKind(100016)*/
}

func sudoclean() {
	return
}

/*
 * generate code to compute address of n,
 * a reference to a (perhaps nested) field inside
 * an array or struct.
 * return 0 on failure, 1 on success.
 * on success, leaves usable address in a.
 *
 * caller is responsible for calling sudoclean
 * after successful sudoaddable,
 * to release the register used for a.
 */
func sudoaddable(as int, n *gc.Node, a *obj.Addr) bool {
	// TODO(minux)

	*a = obj.Addr{}
	return false
}
                usr/local/go/src/cmd/compile/internal/arm64/peep.go                                                 0100644 0000000 0000000 00000042133 13020111411 020547  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Derived from Inferno utils/6c/peep.c
// http://code.google.com/p/inferno-os/source/browse/utils/6c/peep.c
//
//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright © 1997-1999 Vita Nuova Limited
//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright © 2004,2006 Bruce Ellis
//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package arm64

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/arm64"
	"fmt"
)

var gactive uint32

func peep(firstp *obj.Prog) {
	g := (*gc.Graph)(gc.Flowstart(firstp, nil))
	if g == nil {
		return
	}
	gactive = 0

	var p *obj.Prog
	var r *gc.Flow
	var t int
loop1:
	if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
		gc.Dumpit("loop1", g.Start, 0)
	}

	t = 0
	for r = g.Start; r != nil; r = r.Link {
		p = r.Prog

		// TODO(minux) Handle smaller moves. arm and amd64
		// distinguish between moves that *must* sign/zero
		// extend and moves that don't care so they
		// can eliminate moves that don't care without
		// breaking moves that do care. This might let us
		// simplify or remove the next peep loop, too.
		if p.As == arm64.AMOVD || p.As == arm64.AFMOVD {
			if regtyp(&p.To) {
				// Try to eliminate reg->reg moves
				if regtyp(&p.From) {
					if p.From.Type == p.To.Type {
						if copyprop(r) {
							excise(r)
							t++
						} else if subprop(r) && copyprop(r) {
							excise(r)
							t++
						}
					}
				}
			}
		}
	}

	if t != 0 {
		goto loop1
	}

	/*
	 * look for MOVB x,R; MOVB R,R (for small MOVs not handled above)
	 */
	var p1 *obj.Prog
	var r1 *gc.Flow
	for r := (*gc.Flow)(g.Start); r != nil; r = r.Link {
		p = r.Prog
		switch p.As {
		default:
			continue

		case arm64.AMOVH,
			arm64.AMOVHU,
			arm64.AMOVB,
			arm64.AMOVBU,
			arm64.AMOVW,
			arm64.AMOVWU:
			if p.To.Type != obj.TYPE_REG {
				continue
			}
		}

		r1 = r.Link
		if r1 == nil {
			continue
		}
		p1 = r1.Prog
		if p1.As != p.As {
			continue
		}
		if p1.From.Type != obj.TYPE_REG || p1.From.Reg != p.To.Reg {
			continue
		}
		if p1.To.Type != obj.TYPE_REG || p1.To.Reg != p.To.Reg {
			continue
		}
		excise(r1)
	}

	if gc.Debug['D'] > 1 {
		goto ret /* allow following code improvement to be suppressed */
	}

	// MOVD $c, R'; ADD R', R (R' unused) -> ADD $c, R
	for r := (*gc.Flow)(g.Start); r != nil; r = r.Link {
		p = r.Prog
		switch p.As {
		default:
			continue

		case arm64.AMOVD:
			if p.To.Type != obj.TYPE_REG {
				continue
			}
			if p.From.Type != obj.TYPE_CONST {
				continue
			}
			if p.From.Offset < 0 || 4096 <= p.From.Offset {
				continue
			}
		}
		r1 = r.Link
		if r1 == nil {
			continue
		}
		p1 = r1.Prog
		if p1.As != arm64.AADD && p1.As != arm64.ASUB { // TODO(aram): also logical after we have bimm.
			continue
		}
		if p1.From.Type != obj.TYPE_REG || p1.From.Reg != p.To.Reg {
			continue
		}
		if p1.To.Type != obj.TYPE_REG {
			continue
		}
		if gc.Debug['P'] != 0 {
			fmt.Printf("encoding $%d directly into %v in:\n%v\n%v\n", p.From.Offset, obj.Aconv(int(p1.As)), p, p1)
		}
		p1.From.Type = obj.TYPE_CONST
		p1.From = p.From
		excise(r)
	}

	/* TODO(minux):
	 * look for OP x,y,R; CMP R, $0 -> OP.S x,y,R
	 * when OP can set condition codes correctly
	 */

ret:
	gc.Flowend(g)
}

func excise(r *gc.Flow) {
	p := (*obj.Prog)(r.Prog)
	if gc.Debug['P'] != 0 && gc.Debug['v'] != 0 {
		fmt.Printf("%v ===delete===\n", p)
	}
	obj.Nopout(p)
	gc.Ostats.Ndelmov++
}

func regtyp(a *obj.Addr) bool {
	// TODO(rsc): Floating point register exclusions?
	return a.Type == obj.TYPE_REG && arm64.REG_R0 <= a.Reg && a.Reg <= arm64.REG_F31 && a.Reg != arm64.REGZERO
}

/*
 * the idea is to substitute
 * one register for another
 * from one MOV to another
 *	MOV	a, R1
 *	ADD	b, R1	/ no use of R2
 *	MOV	R1, R2
 * would be converted to
 *	MOV	a, R2
 *	ADD	b, R2
 *	MOV	R2, R1
 * hopefully, then the former or latter MOV
 * will be eliminated by copy propagation.
 *
 * r0 (the argument, not the register) is the MOV at the end of the
 * above sequences. This returns 1 if it modified any instructions.
 */
func subprop(r0 *gc.Flow) bool {
	p := (*obj.Prog)(r0.Prog)
	v1 := (*obj.Addr)(&p.From)
	if !regtyp(v1) {
		return false
	}
	v2 := (*obj.Addr)(&p.To)
	if !regtyp(v2) {
		return false
	}
	for r := gc.Uniqp(r0); r != nil; r = gc.Uniqp(r) {
		if gc.Uniqs(r) == nil {
			break
		}
		p = r.Prog
		if p.As == obj.AVARDEF || p.As == obj.AVARKILL {
			continue
		}
		if p.Info.Flags&gc.Call != 0 {
			return false
		}

		if p.Info.Flags&(gc.RightRead|gc.RightWrite) == gc.RightWrite {
			if p.To.Type == v1.Type {
				if p.To.Reg == v1.Reg {
					copysub(&p.To, v1, v2, 1)
					if gc.Debug['P'] != 0 {
						fmt.Printf("gotit: %v->%v\n%v", gc.Ctxt.Dconv(v1), gc.Ctxt.Dconv(v2), r.Prog)
						if p.From.Type == v2.Type {
							fmt.Printf(" excise")
						}
						fmt.Printf("\n")
					}

					for r = gc.Uniqs(r); r != r0; r = gc.Uniqs(r) {
						p = r.Prog
						copysub(&p.From, v1, v2, 1)
						copysub1(p, v1, v2, 1)
						copysub(&p.To, v1, v2, 1)
						if gc.Debug['P'] != 0 {
							fmt.Printf("%v\n", r.Prog)
						}
					}

					t := int(int(v1.Reg))
					v1.Reg = v2.Reg
					v2.Reg = int16(t)
					if gc.Debug['P'] != 0 {
						fmt.Printf("%v last\n", r.Prog)
					}
					return true
				}
			}
		}

		if copyau(&p.From, v2) || copyau1(p, v2) || copyau(&p.To, v2) {
			break
		}
		if copysub(&p.From, v1, v2, 0) != 0 || copysub1(p, v1, v2, 0) != 0 || copysub(&p.To, v1, v2, 0) != 0 {
			break
		}
	}

	return false
}

/*
 * The idea is to remove redundant copies.
 *	v1->v2	F=0
 *	(use v2	s/v2/v1/)*
 *	set v1	F=1
 *	use v2	return fail (v1->v2 move must remain)
 *	-----------------
 *	v1->v2	F=0
 *	(use v2	s/v2/v1/)*
 *	set v1	F=1
 *	set v2	return success (caller can remove v1->v2 move)
 */
func copyprop(r0 *gc.Flow) bool {
	p := (*obj.Prog)(r0.Prog)
	v1 := (*obj.Addr)(&p.From)
	v2 := (*obj.Addr)(&p.To)
	if copyas(v1, v2) {
		if gc.Debug['P'] != 0 {
			fmt.Printf("eliminating self-move: %v\n", r0.Prog)
		}
		return true
	}

	gactive++
	if gc.Debug['P'] != 0 {
		fmt.Printf("trying to eliminate %v->%v move from:\n%v\n", gc.Ctxt.Dconv(v1), gc.Ctxt.Dconv(v2), r0.Prog)
	}
	return copy1(v1, v2, r0.S1, 0)
}

// copy1 replaces uses of v2 with v1 starting at r and returns 1 if
// all uses were rewritten.
func copy1(v1 *obj.Addr, v2 *obj.Addr, r *gc.Flow, f int) bool {
	if uint32(r.Active) == gactive {
		if gc.Debug['P'] != 0 {
			fmt.Printf("act set; return 1\n")
		}
		return true
	}

	r.Active = int32(gactive)
	if gc.Debug['P'] != 0 {
		fmt.Printf("copy1 replace %v with %v f=%d\n", gc.Ctxt.Dconv(v2), gc.Ctxt.Dconv(v1), f)
	}
	var t int
	var p *obj.Prog
	for ; r != nil; r = r.S1 {
		p = r.Prog
		if gc.Debug['P'] != 0 {
			fmt.Printf("%v", p)
		}
		if f == 0 && gc.Uniqp(r) == nil {
			// Multiple predecessors; conservatively
			// assume v1 was set on other path
			f = 1

			if gc.Debug['P'] != 0 {
				fmt.Printf("; merge; f=%d", f)
			}
		}

		t = copyu(p, v2, nil)
		switch t {
		case 2: /* rar, can't split */
			if gc.Debug['P'] != 0 {
				fmt.Printf("; %v rar; return 0\n", gc.Ctxt.Dconv(v2))
			}
			return false

		case 3: /* set */
			if gc.Debug['P'] != 0 {
				fmt.Printf("; %v set; return 1\n", gc.Ctxt.Dconv(v2))
			}
			return true

		case 1, /* used, substitute */
			4: /* use and set */
			if f != 0 {
				if gc.Debug['P'] == 0 {
					return false
				}
				if t == 4 {
					fmt.Printf("; %v used+set and f=%d; return 0\n", gc.Ctxt.Dconv(v2), f)
				} else {
					fmt.Printf("; %v used and f=%d; return 0\n", gc.Ctxt.Dconv(v2), f)
				}
				return false
			}

			if copyu(p, v2, v1) != 0 {
				if gc.Debug['P'] != 0 {
					fmt.Printf("; sub fail; return 0\n")
				}
				return false
			}

			if gc.Debug['P'] != 0 {
				fmt.Printf("; sub %v->%v\n => %v", gc.Ctxt.Dconv(v2), gc.Ctxt.Dconv(v1), p)
			}
			if t == 4 {
				if gc.Debug['P'] != 0 {
					fmt.Printf("; %v used+set; return 1\n", gc.Ctxt.Dconv(v2))
				}
				return true
			}
		}

		if f == 0 {
			t = copyu(p, v1, nil)
			if f == 0 && (t == 2 || t == 3 || t == 4) {
				f = 1
				if gc.Debug['P'] != 0 {
					fmt.Printf("; %v set and !f; f=%d", gc.Ctxt.Dconv(v1), f)
				}
			}
		}

		if gc.Debug['P'] != 0 {
			fmt.Printf("\n")
		}
		if r.S2 != nil {
			if !copy1(v1, v2, r.S2, f) {
				return false
			}
		}
	}

	return true
}

// If s==nil, copyu returns the set/use of v in p; otherwise, it
// modifies p to replace reads of v with reads of s and returns 0 for
// success or non-zero for failure.
//
// If s==nil, copy returns one of the following values:
//	1 if v only used
//	2 if v is set and used in one address (read-alter-rewrite;
//	  can't substitute)
//	3 if v is only set
//	4 if v is set in one address and used in another (so addresses
//	  can be rewritten independently)
//	0 otherwise (not touched)
func copyu(p *obj.Prog, v *obj.Addr, s *obj.Addr) int {
	if p.From3Type() != obj.TYPE_NONE {
		// 7g never generates a from3
		fmt.Printf("copyu: from3 (%v) not implemented\n", gc.Ctxt.Dconv(p.From3))
	}
	if p.RegTo2 != obj.REG_NONE {
		// 7g never generates a to2
		fmt.Printf("copyu: RegTo2 (%v) not implemented\n", obj.Rconv(int(p.RegTo2)))
	}

	switch p.As {
	default:
		fmt.Printf("copyu: can't find %v\n", obj.Aconv(int(p.As)))
		return 2

	case obj.ANOP, /* read p->from, write p->to */
		arm64.ANEG,
		arm64.AFNEGD,
		arm64.AFNEGS,
		arm64.AFSQRTD,
		arm64.AFCVTZSD,
		arm64.AFCVTZSS,
		arm64.AFCVTZSDW,
		arm64.AFCVTZSSW,
		arm64.AFCVTZUD,
		arm64.AFCVTZUS,
		arm64.AFCVTZUDW,
		arm64.AFCVTZUSW,
		arm64.AFCVTSD,
		arm64.AFCVTDS,
		arm64.ASCVTFD,
		arm64.ASCVTFS,
		arm64.ASCVTFWD,
		arm64.ASCVTFWS,
		arm64.AUCVTFD,
		arm64.AUCVTFS,
		arm64.AUCVTFWD,
		arm64.AUCVTFWS,
		arm64.AMOVB,
		arm64.AMOVBU,
		arm64.AMOVH,
		arm64.AMOVHU,
		arm64.AMOVW,
		arm64.AMOVWU,
		arm64.AMOVD,
		arm64.AFMOVS,
		arm64.AFMOVD:
		if p.Scond == 0 {
			if s != nil {
				if copysub(&p.From, v, s, 1) != 0 {
					return 1
				}

				// Update only indirect uses of v in p->to
				if !copyas(&p.To, v) {
					if copysub(&p.To, v, s, 1) != 0 {
						return 1
					}
				}
				return 0
			}

			if copyas(&p.To, v) {
				// Fix up implicit from
				if p.From.Type == obj.TYPE_NONE {
					p.From = p.To
				}
				if copyau(&p.From, v) {
					return 4
				}
				return 3
			}

			if copyau(&p.From, v) {
				return 1
			}
			if copyau(&p.To, v) {
				// p->to only indirectly uses v
				return 1
			}

			return 0
		}

		/* rar p->from, write p->to or read p->from, rar p->to */
		if p.From.Type == obj.TYPE_MEM {
			if copyas(&p.From, v) {
				// No s!=nil check; need to fail
				// anyway in that case
				return 2
			}

			if s != nil {
				if copysub(&p.To, v, s, 1) != 0 {
					return 1
				}
				return 0
			}

			if copyas(&p.To, v) {
				return 3
			}
		} else if p.To.Type == obj.TYPE_MEM {
			if copyas(&p.To, v) {
				return 2
			}
			if s != nil {
				if copysub(&p.From, v, s, 1) != 0 {
					return 1
				}
				return 0
			}

			if copyau(&p.From, v) {
				return 1
			}
		} else {
			fmt.Printf("copyu: bad %v\n", p)
		}

		return 0

	case arm64.AADD, /* read p->from, read p->reg, write p->to */
		arm64.ASUB,
		arm64.AAND,
		arm64.AORR,
		arm64.AEOR,
		arm64.AMUL,
		arm64.ASMULL,
		arm64.AUMULL,
		arm64.ASMULH,
		arm64.AUMULH,
		arm64.ASDIV,
		arm64.AUDIV,
		arm64.ALSL,
		arm64.ALSR,
		arm64.AASR,
		arm64.AFADDD,
		arm64.AFADDS,
		arm64.AFSUBD,
		arm64.AFSUBS,
		arm64.AFMULD,
		arm64.AFMULS,
		arm64.AFDIVD,
		arm64.AFDIVS:
		if s != nil {
			if copysub(&p.From, v, s, 1) != 0 {
				return 1
			}
			if copysub1(p, v, s, 1) != 0 {
				return 1
			}

			// Update only indirect uses of v in p->to
			if !copyas(&p.To, v) {
				if copysub(&p.To, v, s, 1) != 0 {
					return 1
				}
			}
			return 0
		}

		if copyas(&p.To, v) {
			if p.Reg == 0 {
				// Fix up implicit reg (e.g., ADD
				// R3,R4 -> ADD R3,R4,R4) so we can
				// update reg and to separately.
				p.Reg = p.To.Reg
			}

			if copyau(&p.From, v) {
				return 4
			}
			if copyau1(p, v) {
				return 4
			}
			return 3
		}

		if copyau(&p.From, v) {
			return 1
		}
		if copyau1(p, v) {
			return 1
		}
		if copyau(&p.To, v) {
			return 1
		}
		return 0

	case arm64.ABEQ,
		arm64.ABNE,
		arm64.ABGE,
		arm64.ABLT,
		arm64.ABGT,
		arm64.ABLE,
		arm64.ABLO,
		arm64.ABLS,
		arm64.ABHI,
		arm64.ABHS:
		return 0

	case obj.ACHECKNIL, /* read p->from */
		arm64.ACMP, /* read p->from, read p->reg */
		arm64.AFCMPD,
		arm64.AFCMPS:
		if s != nil {
			if copysub(&p.From, v, s, 1) != 0 {
				return 1
			}
			return copysub1(p, v, s, 1)
		}

		if copyau(&p.From, v) {
			return 1
		}
		if copyau1(p, v) {
			return 1
		}
		return 0

	case arm64.AB: /* read p->to */
		if s != nil {
			if copysub(&p.To, v, s, 1) != 0 {
				return 1
			}
			return 0
		}

		if copyau(&p.To, v) {
			return 1
		}
		return 0

	case obj.ARET: /* funny */
		if s != nil {
			return 0
		}

		// All registers die at this point, so claim
		// everything is set (and not used).
		return 3

	case arm64.ABL: /* funny */
		if p.From.Type == obj.TYPE_REG && v.Type == obj.TYPE_REG && p.From.Reg == v.Reg {
			return 2
		}

		if s != nil {
			if copysub(&p.To, v, s, 1) != 0 {
				return 1
			}
			return 0
		}

		if copyau(&p.To, v) {
			return 4
		}
		return 3

	// R31 is zero, used by DUFFZERO, cannot be substituted.
	// R16 is ptr to memory, used and set, cannot be substituted.
	case obj.ADUFFZERO:
		if v.Type == obj.TYPE_REG {
			if v.Reg == 31 {
				return 1
			}
			if v.Reg == 16 {
				return 2
			}
		}

		return 0

	// R16, R17 are ptr to src, dst, used and set, cannot be substituted.
	// R27 is scratch, set by DUFFCOPY, cannot be substituted.
	case obj.ADUFFCOPY:
		if v.Type == obj.TYPE_REG {
			if v.Reg == 16 || v.Reg == 17 {
				return 2
			}
			if v.Reg == 27 {
				return 3
			}
		}

		return 0

	case arm64.AHINT,
		obj.ATEXT,
		obj.APCDATA,
		obj.AFUNCDATA,
		obj.AVARDEF,
		obj.AVARKILL,
		obj.AVARLIVE,
		obj.AUSEFIELD:
		return 0
	}
}

// copyas returns 1 if a and v address the same register.
//
// If a is the from operand, this means this operation reads the
// register in v. If a is the to operand, this means this operation
// writes the register in v.
func copyas(a *obj.Addr, v *obj.Addr) bool {
	if regtyp(v) {
		if a.Type == v.Type {
			if a.Reg == v.Reg {
				return true
			}
		}
	}
	return false
}

// copyau returns 1 if a either directly or indirectly addresses the
// same register as v.
//
// If a is the from operand, this means this operation reads the
// register in v. If a is the to operand, this means the operation
// either reads or writes the register in v (if !copyas(a, v), then
// the operation reads the register in v).
func copyau(a *obj.Addr, v *obj.Addr) bool {
	if copyas(a, v) {
		return true
	}
	if v.Type == obj.TYPE_REG {
		if a.Type == obj.TYPE_MEM || (a.Type == obj.TYPE_ADDR && a.Reg != 0) {
			if v.Reg == a.Reg {
				return true
			}
		}
	}
	return false
}

// copyau1 returns 1 if p->reg references the same register as v and v
// is a direct reference.
func copyau1(p *obj.Prog, v *obj.Addr) bool {
	if regtyp(v) && v.Reg != 0 {
		if p.Reg == v.Reg {
			return true
		}
	}
	return false
}

// copysub replaces v with s in a if f!=0 or indicates it if could if f==0.
// Returns 1 on failure to substitute (it always succeeds on arm64).
func copysub(a *obj.Addr, v *obj.Addr, s *obj.Addr, f int) int {
	if f != 0 {
		if copyau(a, v) {
			a.Reg = s.Reg
		}
	}
	return 0
}

// copysub1 replaces v with s in p1->reg if f!=0 or indicates if it could if f==0.
// Returns 1 on failure to substitute (it always succeeds on arm64).
func copysub1(p1 *obj.Prog, v *obj.Addr, s *obj.Addr, f int) int {
	if f != 0 {
		if copyau1(p1, v) {
			p1.Reg = s.Reg
		}
	}
	return 0
}

func sameaddr(a *obj.Addr, v *obj.Addr) bool {
	if a.Type != v.Type {
		return false
	}
	if regtyp(v) && a.Reg == v.Reg {
		return true
	}
	if v.Type == obj.NAME_AUTO || v.Type == obj.NAME_PARAM {
		if v.Offset == a.Offset {
			return true
		}
	}
	return false
}

func smallindir(a *obj.Addr, reg *obj.Addr) bool {
	return reg.Type == obj.TYPE_REG && a.Type == obj.TYPE_MEM && a.Reg == reg.Reg && 0 <= a.Offset && a.Offset < 4096
}

func stackaddr(a *obj.Addr) bool {
	return a.Type == obj.TYPE_REG && a.Reg == arm64.REGSP
}
                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/local/go/src/cmd/compile/internal/arm64/prog.go                                                 0100644 0000000 0000000 00000016642 13020111411 020573  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package arm64

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj"
	"cmd/internal/obj/arm64"
)

const (
	LeftRdwr  uint32 = gc.LeftRead | gc.LeftWrite
	RightRdwr uint32 = gc.RightRead | gc.RightWrite
)

// This table gives the basic information about instruction
// generated by the compiler and processed in the optimizer.
// See opt.h for bit definitions.
//
// Instructions not generated need not be listed.
// As an exception to that rule, we typically write down all the
// size variants of an operation even if we just use a subset.
//
// The table is formatted for 8-space tabs.
var progtable = [arm64.ALAST]obj.ProgInfo{
	obj.ATYPE:     {Flags: gc.Pseudo | gc.Skip},
	obj.ATEXT:     {Flags: gc.Pseudo},
	obj.AFUNCDATA: {Flags: gc.Pseudo},
	obj.APCDATA:   {Flags: gc.Pseudo},
	obj.AUNDEF:    {Flags: gc.Break},
	obj.AUSEFIELD: {Flags: gc.OK},
	obj.ACHECKNIL: {Flags: gc.LeftRead},
	obj.AVARDEF:   {Flags: gc.Pseudo | gc.RightWrite},
	obj.AVARKILL:  {Flags: gc.Pseudo | gc.RightWrite},
	obj.AVARLIVE:  {Flags: gc.Pseudo | gc.LeftRead},

	// NOP is an internal no-op that also stands
	// for USED and SET annotations, not the Power opcode.
	obj.ANOP:    {Flags: gc.LeftRead | gc.RightWrite},
	arm64.AHINT: {Flags: gc.OK},

	// Integer
	arm64.AADD:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.ASUB:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.ANEG:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.AAND:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.AORR:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.AEOR:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.AMUL:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.ASMULL: {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.AUMULL: {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.ASMULH: {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.AUMULH: {Flags: gc.SizeL | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.ASDIV:  {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.AUDIV:  {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.ALSL:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.ALSR:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.AASR:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.ACMP:   {Flags: gc.SizeQ | gc.LeftRead | gc.RegRead},

	// Floating point.
	arm64.AFADDD:  {Flags: gc.SizeD | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.AFADDS:  {Flags: gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.AFSUBD:  {Flags: gc.SizeD | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.AFSUBS:  {Flags: gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.AFNEGD:  {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite},
	arm64.AFNEGS:  {Flags: gc.SizeF | gc.LeftRead | gc.RightWrite},
	arm64.AFSQRTD: {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite},
	arm64.AFMULD:  {Flags: gc.SizeD | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.AFMULS:  {Flags: gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.AFDIVD:  {Flags: gc.SizeD | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.AFDIVS:  {Flags: gc.SizeF | gc.LeftRead | gc.RegRead | gc.RightWrite},
	arm64.AFCMPD:  {Flags: gc.SizeD | gc.LeftRead | gc.RegRead},
	arm64.AFCMPS:  {Flags: gc.SizeF | gc.LeftRead | gc.RegRead},

	// float -> integer
	arm64.AFCVTZSD:  {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm64.AFCVTZSS:  {Flags: gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm64.AFCVTZSDW: {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm64.AFCVTZSSW: {Flags: gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm64.AFCVTZUD:  {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm64.AFCVTZUS:  {Flags: gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm64.AFCVTZUDW: {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm64.AFCVTZUSW: {Flags: gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Conv},

	// float -> float
	arm64.AFCVTSD: {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm64.AFCVTDS: {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Conv},

	// integer -> float
	arm64.ASCVTFD:  {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm64.ASCVTFS:  {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm64.ASCVTFWD: {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm64.ASCVTFWS: {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm64.AUCVTFD:  {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm64.AUCVTFS:  {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm64.AUCVTFWD: {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv},
	arm64.AUCVTFWS: {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Conv},

	// Moves
	arm64.AMOVB:  {Flags: gc.SizeB | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv},
	arm64.AMOVBU: {Flags: gc.SizeB | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv},
	arm64.AMOVH:  {Flags: gc.SizeW | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv},
	arm64.AMOVHU: {Flags: gc.SizeW | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv},
	arm64.AMOVW:  {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv},
	arm64.AMOVWU: {Flags: gc.SizeL | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv},
	arm64.AMOVD:  {Flags: gc.SizeQ | gc.LeftRead | gc.RightWrite | gc.Move},
	arm64.AFMOVS: {Flags: gc.SizeF | gc.LeftRead | gc.RightWrite | gc.Move | gc.Conv},
	arm64.AFMOVD: {Flags: gc.SizeD | gc.LeftRead | gc.RightWrite | gc.Move},

	// Jumps
	arm64.AB:      {Flags: gc.Jump | gc.Break},
	arm64.ABL:     {Flags: gc.Call},
	arm64.ABEQ:    {Flags: gc.Cjmp},
	arm64.ABNE:    {Flags: gc.Cjmp},
	arm64.ABGE:    {Flags: gc.Cjmp},
	arm64.ABLT:    {Flags: gc.Cjmp},
	arm64.ABGT:    {Flags: gc.Cjmp},
	arm64.ABLE:    {Flags: gc.Cjmp},
	arm64.ABLO:    {Flags: gc.Cjmp},
	arm64.ABLS:    {Flags: gc.Cjmp},
	arm64.ABHI:    {Flags: gc.Cjmp},
	arm64.ABHS:    {Flags: gc.Cjmp},
	arm64.ACBZ:    {Flags: gc.Cjmp},
	arm64.ACBNZ:   {Flags: gc.Cjmp},
	obj.ARET:      {Flags: gc.Break},
	obj.ADUFFZERO: {Flags: gc.Call},
	obj.ADUFFCOPY: {Flags: gc.Call},
}

func proginfo(p *obj.Prog) {
	info := &p.Info
	*info = progtable[p.As]
	if info.Flags == 0 {
		gc.Fatalf("proginfo: unknown instruction %v", p)
	}

	if (info.Flags&gc.RegRead != 0) && p.Reg == 0 {
		info.Flags &^= gc.RegRead
		info.Flags |= gc.RightRead /*CanRegRead |*/
	}

	if (p.From.Type == obj.TYPE_MEM || p.From.Type == obj.TYPE_ADDR) && p.From.Reg != 0 {
		info.Regindex |= RtoB(int(p.From.Reg))
		if p.Scond != 0 {
			info.Regset |= RtoB(int(p.From.Reg))
		}
	}

	if (p.To.Type == obj.TYPE_MEM || p.To.Type == obj.TYPE_ADDR) && p.To.Reg != 0 {
		info.Regindex |= RtoB(int(p.To.Reg))
		if p.Scond != 0 {
			info.Regset |= RtoB(int(p.To.Reg))
		}
	}

	if p.From.Type == obj.TYPE_ADDR && p.From.Sym != nil && (info.Flags&gc.LeftRead != 0) {
		info.Flags &^= gc.LeftRead
		info.Flags |= gc.LeftAddr
	}

	if p.As == obj.ADUFFZERO {
		info.Reguse |= RtoB(arm64.REGRT1)
		info.Regset |= RtoB(arm64.REGRT1)
	}

	if p.As == obj.ADUFFCOPY {
		// TODO(austin) Revisit when duffcopy is implemented
		info.Reguse |= RtoB(arm64.REGRT1) | RtoB(arm64.REGRT2) | RtoB(arm64.REG_R5)

		info.Regset |= RtoB(arm64.REGRT1) | RtoB(arm64.REGRT2)
	}
}
                                                                                              usr/local/go/src/cmd/compile/internal/arm64/reg.go                                                  0100644 0000000 0000000 00000007006 13020111411 020373  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Derived from Inferno utils/6c/reg.c
// http://code.google.com/p/inferno-os/source/browse/utils/6c/reg.c
//
//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright © 1997-1999 Vita Nuova Limited
//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright © 2004,2006 Bruce Ellis
//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package arm64

import (
	"cmd/compile/internal/gc"
	"cmd/internal/obj/arm64"
)

const (
	NREGVAR = 64 /* 32 general + 32 floating */
)

var regname = []string{
	".R0",
	".R1",
	".R2",
	".R3",
	".R4",
	".R5",
	".R6",
	".R7",
	".R8",
	".R9",
	".R10",
	".R11",
	".R12",
	".R13",
	".R14",
	".R15",
	".R16",
	".R17",
	".R18",
	".R19",
	".R20",
	".R21",
	".R22",
	".R23",
	".R24",
	".R25",
	".R26",
	".R27",
	".R28",
	".R29",
	".R30",
	".R31",
	".F0",
	".F1",
	".F2",
	".F3",
	".F4",
	".F5",
	".F6",
	".F7",
	".F8",
	".F9",
	".F10",
	".F11",
	".F12",
	".F13",
	".F14",
	".F15",
	".F16",
	".F17",
	".F18",
	".F19",
	".F20",
	".F21",
	".F22",
	".F23",
	".F24",
	".F25",
	".F26",
	".F27",
	".F28",
	".F29",
	".F30",
	".F31",
}

func regnames(n *int) []string {
	*n = NREGVAR
	return regname
}

func excludedregs() uint64 {
	// Exclude registers with fixed functions
	regbits := uint64(RtoB(arm64.REGRT1) | RtoB(arm64.REGRT2) | RtoB(arm64.REGPR))

	// Exclude R26 - R31.
	for r := arm64.REGMAX + 1; r <= arm64.REGZERO; r++ {
		regbits |= RtoB(r)
	}

	// Also exclude floating point registers with fixed constants
	regbits |= RtoB(arm64.REG_F27) | RtoB(arm64.REG_F28) | RtoB(arm64.REG_F29) | RtoB(arm64.REG_F30) | RtoB(arm64.REG_F31)

	return regbits
}

func doregbits(r int) uint64 {
	return 0
}

/*
 * track register variables including external registers:
 *	bit	reg
 *	0	R0
 *	1	R1
 *	...	...
 *	31	R31
 *	32+0	F0
 *	32+1	F1
 *	...	...
 *	32+31	F31
 */
func RtoB(r int) uint64 {
	if r >= arm64.REG_R0 && r <= arm64.REG_R31 {
		return 1 << uint(r-arm64.REG_R0)
	}
	if r >= arm64.REG_F0 && r <= arm64.REG_F31 {
		return 1 << uint(32+r-arm64.REG_F0)
	}
	return 0
}

func BtoR(b uint64) int {
	b &= 0xffffffff
	if b == 0 {
		return 0
	}
	return gc.Bitno(b) + arm64.REG_R0
}

func BtoF(b uint64) int {
	b >>= 32
	if b == 0 {
		return 0
	}
	return gc.Bitno(b) + arm64.REG_F0
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/local/go/src/cmd/compile/internal/big/                                                          0040755 0000000 0000000 00000000000 13020111411 017077  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/local/go/src/cmd/compile/internal/big/accuracy_string.go                                        0100644 0000000 0000000 00000000575 13020111411 022612  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // generated by stringer -type=Accuracy; DO NOT EDIT

package big

import "fmt"

const _Accuracy_name = "BelowExactAbove"

var _Accuracy_index = [...]uint8{0, 5, 10, 15}

func (i Accuracy) String() string {
	i -= -1
	if i < 0 || i+1 >= Accuracy(len(_Accuracy_index)) {
		return fmt.Sprintf("Accuracy(%d)", i+-1)
	}
	return _Accuracy_name[_Accuracy_index[i]:_Accuracy_index[i+1]]
}
                                                                                                                                   usr/local/go/src/cmd/compile/internal/big/arith.go                                                  0100644 0000000 0000000 00000012704 13020111411 020536  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file provides Go implementations of elementary multi-precision
// arithmetic operations on word vectors. Needed for platforms without
// assembly implementations of these routines.

package big

// A Word represents a single digit of a multi-precision unsigned integer.
type Word uintptr

const (
	// Compute the size _S of a Word in bytes.
	_m    = ^Word(0)
	_logS = _m>>8&1 + _m>>16&1 + _m>>32&1
	_S    = 1 << _logS

	_W = _S << 3 // word size in bits
	_B = 1 << _W // digit base
	_M = _B - 1  // digit mask

	_W2 = _W / 2   // half word size in bits
	_B2 = 1 << _W2 // half digit base
	_M2 = _B2 - 1  // half digit mask
)

// ----------------------------------------------------------------------------
// Elementary operations on words
//
// These operations are used by the vector operations below.

// z1<<_W + z0 = x+y+c, with c == 0 or 1
func addWW_g(x, y, c Word) (z1, z0 Word) {
	yc := y + c
	z0 = x + yc
	if z0 < x || yc < y {
		z1 = 1
	}
	return
}

// z1<<_W + z0 = x-y-c, with c == 0 or 1
func subWW_g(x, y, c Word) (z1, z0 Word) {
	yc := y + c
	z0 = x - yc
	if z0 > x || yc < y {
		z1 = 1
	}
	return
}

// z1<<_W + z0 = x*y
// Adapted from Warren, Hacker's Delight, p. 132.
func mulWW_g(x, y Word) (z1, z0 Word) {
	x0 := x & _M2
	x1 := x >> _W2
	y0 := y & _M2
	y1 := y >> _W2
	w0 := x0 * y0
	t := x1*y0 + w0>>_W2
	w1 := t & _M2
	w2 := t >> _W2
	w1 += x0 * y1
	z1 = x1*y1 + w2 + w1>>_W2
	z0 = x * y
	return
}

// z1<<_W + z0 = x*y + c
func mulAddWWW_g(x, y, c Word) (z1, z0 Word) {
	z1, zz0 := mulWW_g(x, y)
	if z0 = zz0 + c; z0 < zz0 {
		z1++
	}
	return
}

// Length of x in bits.
func bitLen_g(x Word) (n int) {
	for ; x >= 0x8000; x >>= 16 {
		n += 16
	}
	if x >= 0x80 {
		x >>= 8
		n += 8
	}
	if x >= 0x8 {
		x >>= 4
		n += 4
	}
	if x >= 0x2 {
		x >>= 2
		n += 2
	}
	if x >= 0x1 {
		n++
	}
	return
}

// log2 computes the integer binary logarithm of x.
// The result is the integer n for which 2^n <= x < 2^(n+1).
// If x == 0, the result is -1.
func log2(x Word) int {
	return bitLen(x) - 1
}

// nlz returns the number of leading zeros in x.
func nlz(x Word) uint {
	return uint(_W - bitLen(x))
}

// nlz64 returns the number of leading zeros in x.
func nlz64(x uint64) uint {
	switch _W {
	case 32:
		w := x >> 32
		if w == 0 {
			return 32 + nlz(Word(x))
		}
		return nlz(Word(w))
	case 64:
		return nlz(Word(x))
	}
	panic("unreachable")
}

// q = (u1<<_W + u0 - r)/y
// Adapted from Warren, Hacker's Delight, p. 152.
func divWW_g(u1, u0, v Word) (q, r Word) {
	if u1 >= v {
		return 1<<_W - 1, 1<<_W - 1
	}

	s := nlz(v)
	v <<= s

	vn1 := v >> _W2
	vn0 := v & _M2
	un32 := u1<<s | u0>>(_W-s)
	un10 := u0 << s
	un1 := un10 >> _W2
	un0 := un10 & _M2
	q1 := un32 / vn1
	rhat := un32 - q1*vn1

	for q1 >= _B2 || q1*vn0 > _B2*rhat+un1 {
		q1--
		rhat += vn1
		if rhat >= _B2 {
			break
		}
	}

	un21 := un32*_B2 + un1 - q1*v
	q0 := un21 / vn1
	rhat = un21 - q0*vn1

	for q0 >= _B2 || q0*vn0 > _B2*rhat+un0 {
		q0--
		rhat += vn1
		if rhat >= _B2 {
			break
		}
	}

	return q1*_B2 + q0, (un21*_B2 + un0 - q0*v) >> s
}

// Keep for performance debugging.
// Using addWW_g is likely slower.
const use_addWW_g = false

// The resulting carry c is either 0 or 1.
func addVV_g(z, x, y []Word) (c Word) {
	if use_addWW_g {
		for i := range z {
			c, z[i] = addWW_g(x[i], y[i], c)
		}
		return
	}

	for i, xi := range x[:len(z)] {
		yi := y[i]
		zi := xi + yi + c
		z[i] = zi
		// see "Hacker's Delight", section 2-12 (overflow detection)
		c = (xi&yi | (xi|yi)&^zi) >> (_W - 1)
	}
	return
}

// The resulting carry c is either 0 or 1.
func subVV_g(z, x, y []Word) (c Word) {
	if use_addWW_g {
		for i := range z {
			c, z[i] = subWW_g(x[i], y[i], c)
		}
		return
	}

	for i, xi := range x[:len(z)] {
		yi := y[i]
		zi := xi - yi - c
		z[i] = zi
		// see "Hacker's Delight", section 2-12 (overflow detection)
		c = (yi&^xi | (yi|^xi)&zi) >> (_W - 1)
	}
	return
}

// The resulting carry c is either 0 or 1.
func addVW_g(z, x []Word, y Word) (c Word) {
	if use_addWW_g {
		c = y
		for i := range z {
			c, z[i] = addWW_g(x[i], c, 0)
		}
		return
	}

	c = y
	for i, xi := range x[:len(z)] {
		zi := xi + c
		z[i] = zi
		c = xi &^ zi >> (_W - 1)
	}
	return
}

func subVW_g(z, x []Word, y Word) (c Word) {
	if use_addWW_g {
		c = y
		for i := range z {
			c, z[i] = subWW_g(x[i], c, 0)
		}
		return
	}

	c = y
	for i, xi := range x[:len(z)] {
		zi := xi - c
		z[i] = zi
		c = (zi &^ xi) >> (_W - 1)
	}
	return
}

func shlVU_g(z, x []Wo