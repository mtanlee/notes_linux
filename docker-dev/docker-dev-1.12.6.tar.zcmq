MI\s0 are known to be very
buggy, beware!
.Sp
Only the latest runtime is supported, currently \f(CW\*(C`0.9d fix 03\*(C'\fR. Perl may run
under earlier versions of \s-1EMX,\s0 but this is not tested.
.Sp
One can get different parts of \s-1EMX\s0 from, say
.Sp
.Vb 2
\&  ftp://crydee.sai.msu.ru/pub/comp/os/os2/leo/gnu/emx+gcc/
\&  http://hobbes.nmsu.edu/h\-browse.php?dir=/pub/os2/dev/emx/v0.9d/
.Ve
.Sp
The runtime component should have the name \fIemxrt.zip\fR.
.Sp
\&\fB\s-1NOTE\s0\fR. When using \fIemx.exe\fR/\fIrsx.exe\fR, it is enough to have them on your path. One
does not need to specify them explicitly (though this
.Sp
.Vb 1
\&  emx perl_.exe \-de 0
.Ve
.Sp
will work as well.)
.IP "\s-1RSX\s0" 6
.IX Item "RSX"
To run Perl on \s-1DPMI\s0 platforms one needs \s-1RSX\s0 runtime. This is
needed under DOS\-inside\-OS/2, Win0.3*, Win0.95 and WinNT (see 
\&\*(L"Other OSes\*(R"). \s-1RSX\s0 would not work with \s-1VCPI\s0
only, as \s-1EMX\s0 would, it requires \s-1DMPI.\s0
.Sp
Having \s-1RSX\s0 and the latest \fIsh.exe\fR one gets a fully functional
\&\fB*nix\fR\-ish environment under \s-1DOS,\s0 say, \f(CW\*(C`fork\*(C'\fR, \f(CW\*(C`\`\`\*(C'\fR and
pipe\-\f(CW\*(C`open\*(C'\fR work. In fact, MakeMaker works (for static build), so one
can have Perl development environment under \s-1DOS. \s0
.Sp
One can get \s-1RSX\s0 from, say
.Sp
.Vb 2
\&  http://cd.textfiles.com/hobbesos29804/disk1/EMX09C/
\&  ftp://crydee.sai.msu.ru/pub/comp/os/os2/leo/gnu/emx+gcc/contrib/
.Ve
.Sp
Contact the author on \f(CW\*(C`rainer@mathematik.uni\-bielefeld.de\*(C'\fR.
.Sp
The latest \fIsh.exe\fR with \s-1DOS\s0 hooks is available in
.Sp
.Vb 1
\&  http://www.ilyaz.org/software/os2/
.Ve
.Sp
as \fIsh_dos.zip\fR or under similar names starting with \f(CW\*(C`sh\*(C'\fR, \f(CW\*(C`pdksh\*(C'\fR etc.
.IP "\s-1HPFS\s0" 6
.IX Item "HPFS"
Perl does not care about file systems, but the perl library contains
many files with long names, so to install it intact one needs a file
system which supports long file names.
.Sp
Note that if you do not plan to build the perl itself, it may be
possible to fool \s-1EMX\s0 to truncate file names. This is not supported,
read \s-1EMX\s0 docs to see how to do it.
.IP "pdksh" 6
.IX Item "pdksh"
To start external programs with complicated command lines (like with
pipes in between, and/or quoting of arguments), Perl uses an external
shell. With \s-1EMX\s0 port such shell should be named \fIsh.exe\fR, and located
either in the wired-in-during-compile locations (usually \fIF:/bin\fR),
or in configurable location (see \*(L"\s-1PERL_SH_DIR\*(R"\s0).
.Sp
For best results use \s-1EMX\s0 pdksh. The standard binary (5.2.14 or later) runs
under \s-1DOS \s0(with \*(L"\s-1RSX\*(R"\s0) as well, see
.Sp
.Vb 1
\&  http://www.ilyaz.org/software/os2/
.Ve
.SS "Starting Perl programs under \s-1OS/2 \s0(and \s-1DOS\s0 and...)"
.IX Subsection "Starting Perl programs under OS/2 (and DOS and...)"
Start your Perl program \fIfoo.pl\fR with arguments \f(CW\*(C`arg1 arg2 arg3\*(C'\fR the
same way as on any other platform, by
.PP
.Vb 1
\&        perl foo.pl arg1 arg2 arg3
.Ve
.PP
If you want to specify perl options \f(CW\*(C`\-my_opts\*(C'\fR to the perl itself (as
opposed to your program), use
.PP
.Vb 1
\&        perl \-my_opts foo.pl arg1 arg2 arg3
.Ve
.PP
Alternately, if you use OS/2\-ish shell, like \s-1CMD\s0 or 4os2, put
the following at the start of your perl script:
.PP
.Vb 1
\&        extproc perl \-S \-my_opts
.Ve
.PP
rename your program to \fIfoo.cmd\fR, and start it by typing
.PP
.Vb 1
\&        foo arg1 arg2 arg3
.Ve
.PP
Note that because of stupid \s-1OS/2\s0 limitations the full path of the perl
script is not available when you use \f(CW\*(C`extproc\*(C'\fR, thus you are forced to
use \f(CW\*(C`\-S\*(C'\fR perl switch, and your script should be on the \f(CW\*(C`PATH\*(C'\fR. As a plus
side, if you know a full path to your script, you may still start it
with
.PP
.Vb 1
\&        perl ../../blah/foo.cmd arg1 arg2 arg3
.Ve
.PP
(note that the argument \f(CW\*(C`\-my_opts\*(C'\fR is taken care of by the \f(CW\*(C`extproc\*(C'\fR line
in your script, see "\f(CW\*(C`extproc\*(C'\fR on the first line").
.PP
To understand what the above \fImagic\fR does, read perl docs about \f(CW\*(C`\-S\*(C'\fR
switch \- see perlrun, and cmdref about \f(CW\*(C`extproc\*(C'\fR:
.PP
.Vb 4
\&        view perl perlrun
\&        man perlrun
\&        view cmdref extproc
\&        help extproc
.Ve
.PP
or whatever method you prefer.
.PP
There are also endless possibilities to use \fIexecutable extensions\fR of
4os2, \fIassociations\fR of \s-1WPS\s0 and so on... However, if you use
*nixish shell (like \fIsh.exe\fR supplied in the binary distribution),
you need to follow the syntax specified in \*(L"Command Switches\*(R" in perlrun.
.PP
Note that \fB\-S\fR switch supports scripts with additional extensions 
\&\fI.cmd\fR, \fI.btm\fR, \fI.bat\fR, \fI.pl\fR as well.
.SS "Starting \s-1OS/2 \s0(and \s-1DOS\s0) programs under Perl"
.IX Subsection "Starting OS/2 (and DOS) programs under Perl"
This is what \fIsystem()\fR (see \*(L"system\*(R" in perlfunc), \f(CW\*(C`\`\`\*(C'\fR (see
\&\*(L"I/O Operators\*(R" in perlop), and \fIopen pipe\fR (see \*(L"open\*(R" in perlfunc)
are for. (Avoid \fIexec()\fR (see \*(L"exec\*(R" in perlfunc) unless you know what you
do).
.PP
Note however that to use some of these operators you need to have a
sh-syntax shell installed (see \*(L"Pdksh\*(R", 
\&\*(L"Frequently asked questions\*(R"), and perl should be able to find it
(see \*(L"\s-1PERL_SH_DIR\*(R"\s0).
.PP
The cases when the shell is used are:
.IP "1." 4
One-argument \fIsystem()\fR (see \*(L"system\*(R" in perlfunc), \fIexec()\fR (see \*(L"exec\*(R" in perlfunc)
with redirection or shell meta-characters;
.IP "2." 4
Pipe-open (see \*(L"open\*(R" in perlfunc) with the command which contains redirection 
or shell meta-characters;
.IP "3." 4
Backticks \f(CW\*(C`\`\`\*(C'\fR (see \*(L"I/O Operators\*(R" in perlop) with the command which contains
redirection or shell meta-characters;
.IP "4." 4
If the executable called by \fIsystem()\fR/\fIexec()\fR/pipe\-\fIopen()\fR/\f(CW\*(C`\`\`\*(C'\fR is a script
with the \*(L"magic\*(R" \f(CW\*(C`#!\*(C'\fR line or \f(CW\*(C`extproc\*(C'\fR line which specifies shell;
.IP "5." 4
If the executable called by \fIsystem()\fR/\fIexec()\fR/pipe\-\fIopen()\fR/\f(CW\*(C`\`\`\*(C'\fR is a script
without \*(L"magic\*(R" line, and \f(CW$ENV{EXECSHELL}\fR is set to shell;
.IP "6." 4
If the executable called by \fIsystem()\fR/\fIexec()\fR/pipe\-\fIopen()\fR/\f(CW\*(C`\`\`\*(C'\fR is not
found (is not this remark obsolete?);
.IP "7." 4
For globbing (see \*(L"glob\*(R" in perlfunc, \*(L"I/O Operators\*(R" in perlop)
(obsolete? Perl uses builtin globbing nowadays...).
.PP
For the sake of speed for a common case, in the above algorithms 
backslashes in the command name are not considered as shell metacharacters.
.PP
Perl starts scripts which begin with cookies
\&\f(CW\*(C`extproc\*(C'\fR or \f(CW\*(C`#!\*(C'\fR directly, without an intervention of shell.  Perl uses the
same algorithm to find the executable as \fIpdksh\fR: if the path
on \f(CW\*(C`#!\*(C'\fR line does not work, and contains \f(CW\*(C`/\*(C'\fR, then the directory
part of the executable is ignored, and the executable
is searched in \fI.\fR and on \f(CW\*(C`PATH\*(C'\fR.  To find arguments for these scripts
Perl uses a different algorithm than \fIpdksh\fR: up to 3 arguments are 
recognized, and trailing whitespace is stripped.
.PP
If a script
does not contain such a cooky, then to avoid calling \fIsh.exe\fR, Perl uses
the same algorithm as \fIpdksh\fR: if \f(CW$ENV{EXECSHELL}\fR is set, the
script is given as the first argument to this command, if not set, then
\&\f(CW\*(C`$ENV{COMSPEC} /c\*(C'\fR is used (or a hardwired guess if \f(CW$ENV{COMSPEC}\fR is
not set).
.PP
When starting scripts directly, Perl uses exactly the same algorithm as for 
the search of script given by \fB\-S\fR command-line option: it will look in
the current directory, then on components of \f(CW$ENV{PATH}\fR using the 
following order of appended extensions: no extension, \fI.cmd\fR, \fI.btm\fR, 
\&\fI.bat\fR, \fI.pl\fR.
.PP
Note that Perl will start to look for scripts only if \s-1OS/2\s0 cannot start the
specified application, thus \f(CW\*(C`system \*(Aqblah\*(Aq\*(C'\fR will not look for a script if 
there is an executable file \fIblah.exe\fR \fIanywhere\fR on \f(CW\*(C`PATH\*(C'\fR.  In
other words, \f(CW\*(C`PATH\*(C'\fR is essentially searched twice: once by the \s-1OS\s0 for
an executable, then by Perl for scripts.
.PP
Note also that executable files on \s-1OS/2\s0 can have an arbitrary extension, 
but \fI.exe\fR will be automatically appended if no dot is present in the name.  
The workaround is as simple as that:  since \fIblah.\fR and \fIblah\fR denote the 
same file (at list on \s-1FAT\s0 and \s-1HPFS\s0 file systems), to start an executable residing in file \fIn:/bin/blah\fR (no 
extension) give an argument \f(CW\*(C`n:/bin/blah.\*(C'\fR (dot appended) to \fIsystem()\fR.
.PP
Perl will start \s-1PM\s0 programs from \s-1VIO \s0(=text\-mode) Perl process in a
separate \s-1PM\s0 session;
the opposite is not true: when you start a non-PM program from a \s-1PM\s0
Perl process, Perl would not run it in a separate session.  If a separate
session is desired, either ensure
that shell will be used, as in \f(CW\*(C`system \*(Aqcmd /c myprog\*(Aq\*(C'\fR, or start it using
optional arguments to \fIsystem()\fR documented in \f(CW\*(C`OS2::Process\*(C'\fR module.  This
is considered to be a feature.
.SH "Frequently asked questions"
.IX Header "Frequently asked questions"
.ie n .SS """It does not work"""
.el .SS "``It does not work''"
.IX Subsection "It does not work"
Perl binary distributions come with a \fItestperl.cmd\fR script which tries
to detect common problems with misconfigured installations.  There is a
pretty large chance it will discover which step of the installation you
managed to goof.  \f(CW\*(C`;\-)\*(C'\fR
.SS "I cannot run external programs"
.IX Subsection "I cannot run external programs"
.IP "\(bu" 4
Did you run your programs with \f(CW\*(C`\-w\*(C'\fR switch? See 
\&\*(L"Starting \s-1OS/2 \s0(and \s-1DOS\s0) programs under Perl\*(R".
.IP "\(bu" 4
Do you try to run \fIinternal\fR shell commands, like \f(CW\*(C`\`copy a b\`\*(C'\fR
(internal for \fIcmd.exe\fR), or \f(CW\*(C`\`glob a*b\`\*(C'\fR (internal for ksh)? You
need to specify your shell explicitly, like \f(CW\*(C`\`cmd /c copy a b\`\*(C'\fR,
since Perl cannot deduce which commands are internal to your shell.
.SS "I cannot embed perl into my program, or use \fIperl.dll\fP from my program."
.IX Subsection "I cannot embed perl into my program, or use perl.dll from my program."
.ie n .IP "Is your program EMX-compiled with ""\-Zmt \-Zcrtdll""?" 4
.el .IP "Is your program EMX-compiled with \f(CW\-Zmt \-Zcrtdll\fR?" 4
.IX Item "Is your program EMX-compiled with -Zmt -Zcrtdll?"
Well, nowadays Perl \s-1DLL\s0 should be usable from a differently compiled
program too...  If you can run Perl code from \s-1REXX\s0 scripts (see
\&\s-1OS2::REXX\s0), then there are some other aspect of interaction which
are overlooked by the current hackish code to support
differently-compiled principal programs.
.Sp
If everything else fails, you need to build a stand-alone \s-1DLL\s0 for
perl. Contact me, I did it once. Sockets would not work, as a lot of
other stuff.
.IP "Did you use ExtUtils::Embed?" 4
.IX Item "Did you use ExtUtils::Embed?"
Some time ago I had reports it does not work.  Nowadays it is checked
in the Perl test suite, so grep \fI./t\fR subdirectory of the build tree
(as well as \fI*.t\fR files in the \fI./lib\fR subdirectory) to find how it
should be done \*(L"correctly\*(R".
.ie n .SS """\`\`"" and pipe\-""open"" do not work under \s-1DOS.\s0"
.el .SS "\f(CW\`\`\fP and pipe\-\f(CWopen\fP do not work under \s-1DOS.\s0"
.IX Subsection " and pipe-open do not work under DOS."
This may a variant of just \*(L"I cannot run external programs\*(R", or a
deeper problem. Basically: you \fIneed\fR \s-1RSX \s0(see \*(L"Prerequisites\*(R")
for these commands to work, and you may need a port of \fIsh.exe\fR which
understands command arguments. One of such ports is listed in
\&\*(L"Prerequisites\*(R" under \s-1RSX.\s0 Do not forget to set variable
\&\f(CW"PERL_SH_DIR"\fR as well.
.PP
\&\s-1DPMI\s0 is required for \s-1RSX.\s0
.ie n .SS "Cannot start ""find.exe ""pattern"" file"""
.el .SS "Cannot start \f(CWfind.exe ``pattern'' file\fP"
.IX Subsection "Cannot start find.exe ""pattern"" file"
The whole idea of the \*(L"standard C \s-1API\s0 to start applications\*(R" is that
the forms \f(CW\*(C`foo\*(C'\fR and \f(CW"foo"\fR of program arguments are completely
interchangeable.  \fIfind\fR breaks this paradigm;
.PP
.Vb 2
\&  find "pattern" file
\&  find pattern file
.Ve
.PP
are not equivalent; \fIfind\fR cannot be started directly using the above
\&\s-1API. \s0 One needs a way to surround the doublequotes in some other
quoting construction, necessarily having an extra non-Unixish shell in
between.
.PP
Use one of
.PP
.Vb 2
\&  system \*(Aqcmd\*(Aq, \*(Aq/c\*(Aq, \*(Aqfind "pattern" file\*(Aq;
\&  \`cmd /c \*(Aqfind "pattern" file\*(Aq\`
.Ve
.PP
This would start \fIfind.exe\fR via \fIcmd.exe\fR via \f(CW\*(C`sh.exe\*(C'\fR via
\&\f(CW\*(C`perl.exe\*(C'\fR, but this is a price to pay if you want to use
non-conforming program.
.SH "INSTALLATION"
.IX Header "INSTALLATION"
.SS "Automatic binary installation"
.IX Subsection "Automatic binary installation"
The most convenient way of installing a binary distribution of perl is via perl installer
\&\fIinstall.exe\fR. Just follow the instructions, and 99% of the
installation blues would go away.
.PP
Note however, that you need to have \fIunzip.exe\fR on your path, and
\&\s-1EMX\s0 environment \fIrunning\fR. The latter means that if you just
installed \s-1EMX,\s0 and made all the needed changes to \fIConfig.sys\fR,
you may need to reboot in between. Check \s-1EMX\s0 runtime by running
.PP
.Vb 1
\&        emxrev
.Ve
.PP
Binary installer also creates a folder on your desktop with some useful
objects.  If you need to change some aspects of the work of the binary
installer, feel free to edit the file \fIPerl.pkg\fR.  This may be useful
e.g., if you need to run the installer many times and do not want to
make many interactive changes in the \s-1GUI.\s0
.PP
\&\fBThings not taken care of by automatic binary installation:\fR
.ie n .IP """PERL_BADLANG""" 15
.el .IP "\f(CWPERL_BADLANG\fR" 15
.IX Item "PERL_BADLANG"
may be needed if you change your codepage \fIafter\fR perl installation,
and the new value is not supported by \s-1EMX.\s0 See \*(L"\s-1PERL_BADLANG\*(R"\s0.
.ie n .IP """PERL_BADFREE""" 15
.el .IP "\f(CWPERL_BADFREE\fR" 15
.IX Item "PERL_BADFREE"
see \*(L"\s-1PERL_BADFREE\*(R"\s0.
.IP "\fIConfig.pm\fR" 15
.IX Item "Config.pm"
This file resides somewhere deep in the location you installed your
perl library, find it out by
.Sp
.Vb 1
\&  perl \-MConfig \-le "print $INC{\*(AqConfig.pm\*(Aq}"
.Ve
.Sp
While most important values in this file \fIare\fR updated by the binary
installer, some of them may need to be hand-edited. I know no such
data, please keep me informed if you find one.  Moreover, manual
changes to the installed version may need to be accompanied by an edit
of this file.
.PP
\&\fB\s-1NOTE\s0\fR. Because of a typo the binary installer of 5.00305
would install a variable \f(CW\*(C`PERL_SHPATH\*(C'\fR into \fIConfig.sys\fR. Please
remove this variable and put \f(CW"PERL_SH_DIR"\fR instead.
.SS "Manual binary installation"
.IX Subsection "Manual binary installation"
As of version 5.00305, \s-1OS/2\s0 perl binary distribution comes split
into 11 components. Unfortunately, to enable configurable binary
installation, the file paths in the zip files are not absolute, but
relative to some directory.
.PP
Note that the extraction with the stored paths is still necessary
(default with unzip, specify \f(CW\*(C`\-d\*(C'\fR to pkunzip). However, you
need to know where to extract the files. You need also to manually
change entries in \fIConfig.sys\fR to reflect where did you put the
files. Note that if you have some primitive unzipper (like
\&\f(CW\*(C`pkunzip\*(C'\fR), you may get a lot of warnings/errors during
unzipping. Upgrade to \f(CW\*(C`(w)unzip\*(C'\fR.
.PP
Below is the sample of what to do to reproduce the configuration on my
machine.  In \fI\s-1VIEW.EXE\s0\fR you can press \f(CW\*(C`Ctrl\-Insert\*(C'\fR now, and
cut-and-paste from the resulting file \- created in the directory you
started \fI\s-1VIEW.EXE\s0\fR from.
.PP
For each component, we mention environment variables related to each
installation directory.  Either choose directories to match your
values of the variables, or create/append\-to variables to take into
account the directories.
.IP "Perl \s-1VIO\s0 and \s-1PM\s0 executables (dynamically linked)" 3
.IX Item "Perl VIO and PM executables (dynamically linked)"
.Vb 2
\&  unzip perl_exc.zip *.exe *.ico \-d f:/emx.add/bin
\&  unzip perl_exc.zip *.dll \-d f:/emx.add/dll
.Ve
.Sp
(have the directories with \f(CW\*(C`*.exe\*(C'\fR on \s-1PATH,\s0 and \f(CW\*(C`*.dll\*(C'\fR on
\&\s-1LIBPATH\s0);
.IP "Perl_ \s-1VIO\s0 executable (statically linked)" 3
.IX Item "Perl_ VIO executable (statically linked)"
.Vb 1
\&  unzip perl_aou.zip \-d f:/emx.add/bin
.Ve
.Sp
(have the directory on \s-1PATH\s0);
.IP "Executables for Perl utilities" 3
.IX Item "Executables for Perl utilities"
.Vb 1
\&  unzip perl_utl.zip \-d f:/emx.add/bin
.Ve
.Sp
(have the directory on \s-1PATH\s0);
.IP "Main Perl library" 3
.IX Item "Main Perl library"
.Vb 1
\&  unzip perl_mlb.zip \-d f:/perllib/lib
.Ve
.Sp
If this directory is exactly the same as the prefix which was compiled
into \fIperl.exe\fR, you do not need to change
anything. However, for perl to find the library if you use a different
path, you need to
\&\f(CW\*(C`set PERLLIB_PREFIX\*(C'\fR in \fIConfig.sys\fR, see \*(L"\s-1PERLLIB_PREFIX\*(R"\s0.
.IP "Additional Perl modules" 3
.IX Item "Additional Perl modules"
.Vb 1
\&  unzip perl_ste.zip \-d f:/perllib/lib/site_perl/5.18.2/
.Ve
.Sp
Same remark as above applies.  Additionally, if this directory is not
one of directories on \f(CW@INC\fR (and \f(CW@INC\fR is influenced by \f(CW\*(C`PERLLIB_PREFIX\*(C'\fR), you
need to put this
directory and subdirectory \fI./os2\fR in \f(CW\*(C`PERLLIB\*(C'\fR or \f(CW\*(C`PERL5LIB\*(C'\fR
variable. Do not use \f(CW\*(C`PERL5LIB\*(C'\fR unless you have it set already. See
\&\*(L"\s-1ENVIRONMENT\*(R"\s0 in perl.
.Sp
\&\fB[Check whether this extraction directory is still applicable with
the new directory structure layout!]\fR
.IP "Tools to compile Perl modules" 3
.IX Item "Tools to compile Perl modules"
.Vb 1
\&  unzip perl_blb.zip \-d f:/perllib/lib
.Ve
.Sp
Same remark as for \fIperl_ste.zip\fR.
.IP "Manpages for Perl and utilities" 3
.IX Item "Manpages for Perl and utilities"
.Vb 1
\&  unzip perl_man.zip \-d f:/perllib/man
.Ve
.Sp
This directory should better be on \f(CW\*(C`MANPATH\*(C'\fR. You need to have a
working \fIman\fR to access these files.
.IP "Manpages for Perl modules" 3
.IX Item "Manpages for Perl modules"
.Vb 1
\&  unzip perl_mam.zip \-d f:/perllib/man
.Ve
.Sp
This directory should better be on \f(CW\*(C`MANPATH\*(C'\fR. You need to have a
working man to access these files.
.IP "Source for Perl documentation" 3
.IX Item "Source for Perl documentation"
.Vb 1
\&  unzip perl_pod.zip \-d f:/perllib/lib
.Ve
.Sp
This is used by the \f(CW\*(C`perldoc\*(C'\fR program (see perldoc), and may be used to
generate \s-1HTML\s0 documentation usable by \s-1WWW\s0 browsers, and
documentation in zillions of other formats: \f(CW\*(C`info\*(C'\fR, \f(CW\*(C`LaTeX\*(C'\fR,
\&\f(CW\*(C`Acrobat\*(C'\fR, \f(CW\*(C`FrameMaker\*(C'\fR and so on.  [Use programs such as
\&\fIpod2latex\fR etc.]
.IP "Perl manual in \fI.INF\fR format" 3
.IX Item "Perl manual in .INF format"
.Vb 1
\&  unzip perl_inf.zip \-d d:/os2/book
.Ve
.Sp
This directory should better be on \f(CW\*(C`BOOKSHELF\*(C'\fR.
.IP "Pdksh" 3
.IX Item "Pdksh"
.Vb 1
\&  unzip perl_sh.zip \-d f:/bin
.Ve
.Sp
This is used by perl to run external commands which explicitly
require shell, like the commands using \fIredirection\fR and \fIshell
metacharacters\fR. It is also used instead of explicit \fI/bin/sh\fR.
.Sp
Set \f(CW\*(C`PERL_SH_DIR\*(C'\fR (see \*(L"\s-1PERL_SH_DIR\*(R"\s0) if you move \fIsh.exe\fR from
the above location.
.Sp
\&\fBNote.\fR It may be possible to use some other sh-compatible shell (untested).
.PP
After you installed the components you needed and updated the
\&\fIConfig.sys\fR correspondingly, you need to hand-edit
\&\fIConfig.pm\fR. This file resides somewhere deep in the location you
installed your perl library, find it out by
.PP
.Vb 1
\&  perl \-MConfig \-le "print $INC{\*(AqConfig.pm\*(Aq}"
.Ve
.PP
You need to correct all the entries which look like file paths (they
currently start with \f(CW\*(C`f:/\*(C'\fR).
.SS "\fBWarning\fP"
.IX Subsection "Warning"
The automatic and manual perl installation leave precompiled paths
inside perl executables. While these paths are overwriteable (see
\&\*(L"\s-1PERLLIB_PREFIX\*(R"\s0, \*(L"\s-1PERL_SH_DIR\*(R"\s0), some people may prefer
binary editing of paths inside the executables/DLLs.
.SH "Accessing documentation"
.IX Header "Accessing documentation"
Depending on how you built/installed perl you may have (otherwise
identical) Perl documentation in the following formats:
.SS "\s-1OS/2 \s0\fI.INF\fP file"
.IX Subsection "OS/2 .INF file"
Most probably the most convenient form. Under \s-1OS/2\s0 view it as
.PP
.Vb 4
\&  view perl
\&  view perl perlfunc
\&  view perl less
\&  view perl ExtUtils::MakeMaker
.Ve
.PP
(currently the last two may hit a wrong location, but this may improve
soon). Under Win* see \*(L"\s-1SYNOPSIS\*(R"\s0.
.PP
If you want to build the docs yourself, and have \fI\s-1OS/2\s0 toolkit\fR, run
.PP
.Vb 1
\&        pod2ipf > perl.ipf
.Ve
.PP
in \fI/perllib/lib/pod\fR directory, then
.PP
.Vb 1
\&        ipfc /inf perl.ipf
.Ve
.PP
(Expect a lot of errors during the both steps.) Now move it on your
\&\s-1BOOKSHELF\s0 path.
.SS "Plain text"
.IX Subsection "Plain text"
If you have perl documentation in the source form, perl utilities
installed, and \s-1GNU\s0 groff installed, you may use
.PP
.Vb 3
\&        perldoc perlfunc
\&        perldoc less
\&        perldoc ExtUtils::MakeMaker
.Ve
.PP
to access the perl documentation in the text form (note that you may get
better results using perl manpages).
.PP
Alternately, try running pod2text on \fI.pod\fR files.
.SS "Manpages"
.IX Subsection "Manpages"
If you have \fIman\fR installed on your system, and you installed perl
manpages, use something like this:
.PP
.Vb 3
\&        man perlfunc
\&        man 3 less
\&        man ExtUtils.MakeMaker
.Ve
.PP
to access documentation for different components of Perl. Start with
.PP
.Vb 1
\&        man perl
.Ve
.PP
Note that dot (\fI.\fR) is used as a package separator for documentation
for packages, and as usual, sometimes you need to give the section \- \f(CW3\fR
above \- to avoid shadowing by the \fI\fIless\fI\|(1) manpage\fR.
.PP
Make sure that the directory \fBabove\fR the directory with manpages is
on our \f(CW\*(C`MANPATH\*(C'\fR, like this
.PP
.Vb 1
\&  set MANPATH=c:/man;f:/perllib/man
.Ve
.PP
for Perl manpages in \f(CW\*(C`f:/perllib/man/man1/\*(C'\fR etc.
.SS "\s-1HTML\s0"
.IX Subsection "HTML"
If you have some \s-1WWW\s0 browser available, installed the Perl
documentation in the source form, and Perl utilities, you can build
\&\s-1HTML\s0 docs. Cd to directory with \fI.pod\fR files, and do like this
.PP
.Vb 2
\&        cd f:/perllib/lib/pod
\&        pod2html
.Ve
.PP
After this you can direct your browser the file \fIperl.html\fR in this
directory, and go ahead with reading docs, like this:
.PP
.Vb 1
\&        explore file:///f:/perllib/lib/pod/perl.html
.Ve
.PP
Alternatively you may be able to get these docs prebuilt from \s-1CPAN.\s0
.ie n .SS "\s-1GNU \s0""info"" files"
.el .SS "\s-1GNU \s0\f(CWinfo\fP files"
.IX Subsection "GNU info files"
Users of Emacs would appreciate it very much, especially with
\&\f(CW\*(C`CPerl\*(C'\fR mode loaded. You need to get latest \f(CW\*(C`pod2texi\*(C'\fR from \f(CW\*(C`CPAN\*(C'\fR,
or, alternately, the prebuilt info pages.
.SS "\fI\s-1PDF\s0\fP files"
.IX Subsection "PDF files"
for \f(CW\*(C`Acrobat\*(C'\fR are available on \s-1CPAN \s0(may be for slightly older version of
perl).
.ie n .SS """LaTeX"" docs"
.el .SS "\f(CWLaTeX\fP docs"
.IX Subsection "LaTeX docs"
can be constructed using \f(CW\*(C`pod2latex\*(C'\fR.
.SH "BUILD"
.IX Header "BUILD"
Here we discuss how to build Perl under \s-1OS/2.\s0
.SS "The short story"
.IX Subsection "The short story"
Assume that you are a seasoned porter, so are sure that all the necessary
tools are already present on your system, and you know how to get the Perl
source distribution.  Untar it, change to the extract directory, and
.PP
.Vb 7
\&  gnupatch \-p0 < os2\ediff.configure
\&  sh Configure \-des \-D prefix=f:/perllib
\&  make
\&  make test
\&  make install
\&  make aout_test
\&  make aout_install
.Ve
.PP
This puts the executables in f:/perllib/bin.  Manually move them to the
\&\f(CW\*(C`PATH\*(C'\fR, manually move the built \fIperl*.dll\fR to \f(CW\*(C`LIBPATH\*(C'\fR (here for
Perl \s-1DLL \s0\fI*\fR is a not-very-meaningful hex checksum), and run
.PP
.Vb 1
\&  make installcmd INSTALLCMDDIR=d:/ir/on/path
.Ve
.PP
Assuming that the \f(CW\*(C`man\*(C'\fR\-files were put on an appropriate location,
this completes the installation of minimal Perl system.  (The binary
distribution contains also a lot of additional modules, and the
documentation in \s-1INF\s0 format.)
.PP
What follows is a detailed guide through these steps.
.SS "Prerequisites"
.IX Subsection "Prerequisites"
You need to have the latest \s-1EMX\s0 development environment, the full
\&\s-1GNU\s0 tool suite (gawk renamed to awk, and \s-1GNU \s0\fIfind.exe\fR
earlier on path than the \s-1OS/2 \s0\fIfind.exe\fR, same with \fIsort.exe\fR, to
check use
.PP
.Vb 2
\&  find \-\-version
\&  sort \-\-version
.Ve
.PP
). You need the latest version of \fIpdksh\fR installed as \fIsh.exe\fR.
.PP
Check that you have \fB\s-1BSD\s0\fR libraries and headers installed, and \- 
optionally \- Berkeley \s-1DB\s0 headers and libraries, and crypt.
.PP
Possible locations to get the files:
.PP
.Vb 4
\&  ftp://ftp.uni\-heidelberg.de/pub/os2/unix/
\&  http://hobbes.nmsu.edu/h\-browse.php?dir=/pub/os2
\&  http://cd.textfiles.com/hobbesos29804/disk1/DEV32/
\&  http://cd.textfiles.com/hobbesos29804/disk1/EMX09C/
.Ve
.PP
It is reported that the following archives contain enough utils to
build perl: \fIgnufutil.zip\fR, \fIgnusutil.zip\fR, \fIgnututil.zip\fR, \fIgnused.zip\fR,
\&\fIgnupatch.zip\fR, \fIgnuawk.zip\fR, \fIgnumake.zip\fR, \fIgnugrep.zip\fR, \fIbsddev.zip\fR and
\&\fIksh527rt.zip\fR (or a later version).  Note that all these utilities are
known to be available from \s-1LEO:\s0
.PP
.Vb 1
\&  ftp://crydee.sai.msu.ru/pub/comp/os/os2/leo/gnu/
.Ve
.PP
Note also that the \fIdb.lib\fR and \fIdb.a\fR from the \s-1EMX\s0 distribution
are not suitable for multi-threaded compile (even single-threaded
flavor of Perl uses multi-threaded C \s-1RTL,\s0 for
compatibility with XFree86\-OS/2). Get a corrected one from
.PP
.Vb 1
\&  http://www.ilyaz.org/software/os2/db_mt.zip
.Ve
.PP
If you have \fIexactly the same version of Perl\fR installed already,
make sure that no copies or perl are currently running.  Later steps
of the build may fail since an older version of \fIperl.dll\fR loaded into
memory may be found.  Running \f(CW\*(C`make test\*(C'\fR becomes meaningless, since
the test are checking a previous build of perl (this situation is detected
and reported by \fIlib/os2_base.t\fR test).  Do not forget to unset
\&\f(CW\*(C`PERL_EMXLOAD_SEC\*(C'\fR in environment.
.PP
Also make sure that you have \fI/tmp\fR directory on the current drive,
and \fI.\fR directory in your \f(CW\*(C`LIBPATH\*(C'\fR. One may try to correct the
latter condition by
.PP
.Vb 1
\&  set BEGINLIBPATH .\e.
.Ve
.PP
if you use something like \fI\s-1CMD.EXE\s0\fR or latest versions of
\&\fI4os2.exe\fR.  (Setting \s-1BEGINLIBPATH\s0 to just \f(CW\*(C`.\*(C'\fR is ignored by the
\&\s-1OS/2\s0 kernel.)
.PP
Make sure your gcc is good for \f(CW\*(C`\-Zomf\*(C'\fR linking: run \f(CW\*(C`omflibs\*(C'\fR
script in \fI/emx/lib\fR directory.
.PP
Check that you have link386 installed. It comes standard with \s-1OS/2,\s0
but may be not installed due to customization. If typing
.PP
.Vb 1
\&  link386
.Ve
.PP
shows you do not have it, do \fISelective install\fR, and choose \f(CW\*(C`Link
object modules\*(C'\fR in \fIOptional system utilities/More\fR. If you get into
link386 prompts, press \f(CW\*(C`Ctrl\-C\*(C'\fR to exit.
.SS "Getting perl source"
.IX Subsection "Getting perl source"
You need to fetch the latest perl source (including developers
releases). With some probability it is located in
.PP
.Vb 2
\&  http://www.cpan.org/src/
\&  http://www.cpan.org/src/unsupported
.Ve
.PP
If not, you may need to dig in the indices to find it in the directory
of the current maintainer.
.PP
Quick cycle of developers release may break the \s-1OS/2\s0 build time to
time, looking into
.PP
.Vb 1
\&  http://www.cpan.org/ports/os2/
.Ve
.PP
may indicate the latest release which was publicly released by the
maintainer. Note that the release may include some additional patches
to apply to the current source of perl.
.PP
Extract it like this
.PP
.Vb 1
\&  tar vzxf perl5.00409.tar.gz
.Ve
.PP
You may see a message about errors while extracting \fIConfigure\fR. This is
because there is a conflict with a similarly-named file \fIconfigure\fR.
.PP
Change to the directory of extraction.
.SS "Application of the patches"
.IX Subsection "Application of the patches"
You need to apply the patches in \fI./os2/diff.*\fR like this:
.PP
.Vb 1
\&  gnupatch \-p0 < os2\ediff.configure
.Ve
.PP
You may also need to apply the patches supplied with the binary
distribution of perl.  It also makes sense to look on the
perl5\-porters mailing list for the latest OS/2\-related patches (see
<http://www.xray.mpe.mpg.de/mailing\-lists/perl5\-porters/>).  Such
patches usually contain strings \f(CW\*(C`/os2/\*(C'\fR and \f(CW\*(C`patch\*(C'\fR, so it makes
sense looking for these strings.
.SS "Hand-editing"
.IX Subsection "Hand-editing"
You may look into the file \fI./hints/os2.sh\fR and correct anything
wrong you find there. I do not expect it is needed anywhere.
.SS "Making"
.IX Subsection "Making"
.Vb 1
\&  sh Configure \-des \-D prefix=f:/perllib
.Ve
.PP
\&\f(CW\*(C`prefix\*(C'\fR means: where to install the resulting perl library. Giving
correct prefix you may avoid the need to specify \f(CW\*(C`PERLLIB_PREFIX\*(C'\fR,
see \*(L"\s-1PERLLIB_PREFIX\*(R"\s0.
.PP
\&\fIIgnore the message about missing \f(CI\*(C`ln\*(C'\fI, and about \f(CI\*(C`\-c\*(C'\fI option to
tr\fR. The latter is most probably already fixed, if you see it and can trace
where the latter spurious warning comes from, please inform me.
.PP
Now
.PP
.Vb 1
\&  make
.Ve
.PP
At some moment the built may die, reporting a \fIversion mismatch\fR or
\&\fIunable to run \fIperl\fI\fR.  This means that you do not have \fI.\fR in
your \s-1LIBPATH,\s0 so \fIperl.exe\fR cannot find the needed \fIperl67B2.dll\fR (treat
these hex digits as line noise).  After this is fixed the build
should finish without a lot of fuss.
.SS "Testing"
.IX Subsection "Testing"
Now run
.PP
.Vb 1
\&  make test
.Ve
.PP
All tests should succeed (with some of them skipped).  If you have the
same version of Perl installed, it is crucial that you have \f(CW\*(C`.\*(C'\fR early
in your \s-1LIBPATH \s0(or in \s-1BEGINLIBPATH\s0), otherwise your tests will most
probably test the wrong version of Perl.
.PP
Some tests may generate extra messages similar to
.ie n .IP "A lot of ""bad free""" 4
.el .IP "A lot of \f(CWbad free\fR" 4
.IX Item "A lot of bad free"
in database tests related to Berkeley \s-1DB. \s0\fIThis should be fixed already.\fR
If it persists, you may disable this warnings, see \*(L"\s-1PERL_BADFREE\*(R"\s0.
.IP "Process terminated by \s-1SIGTERM/SIGINT\s0" 4
.IX Item "Process terminated by SIGTERM/SIGINT"
This is a standard message issued by \s-1OS/2\s0 applications. *nix
applications die in silence. It is considered to be a feature. One can
easily disable this by appropriate sighandlers.
.Sp
However the test engine bleeds these message to screen in unexpected
moments. Two messages of this kind \fIshould\fR be present during
testing.
.PP
To get finer test reports, call
.PP
.Vb 1
\&  perl t/harness
.Ve
.PP
The report with \fIio/pipe.t\fR failing may look like this:
.PP
.Vb 5
\&  Failed Test  Status Wstat Total Fail  Failed  List of failed
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  io/pipe.t                    12    1   8.33%  9
\&  7 tests skipped, plus 56 subtests skipped.
\&  Failed 1/195 test scripts, 99.49% okay. 1/6542 subtests failed, 99.98% okay.
.Ve
.PP
The reasons for most important skipped tests are:
.IP "\fIop/fs.t\fR" 8
.IX Item "op/fs.t"
.RS 8
.PD 0
.IP "18" 4
.IX Item "18"
.PD
Checks \f(CW\*(C`atime\*(C'\fR and \f(CW\*(C`mtime\*(C'\fR of \f(CW\*(C`stat()\*(C'\fR \- unfortunately, \s-1HPFS\s0
provides only 2sec time granularity (for compatibility with \s-1FAT\s0?).
.IP "25" 4
.IX Item "25"
Checks \f(CW\*(C`truncate()\*(C'\fR on a filehandle just opened for write \- I do not
know why this should or should not work.
.RE
.RS 8
.RE
.IP "\fIop/stat.t\fR" 8
.IX Item "op/stat.t"
Checks \f(CW\*(C`stat()\*(C'\fR. Tests:
.RS 8
.IP "4" 4
.IX Item "4"
Checks \f(CW\*(C`atime\*(C'\fR and \f(CW\*(C`mtime\*(C'\fR of \f(CW\*(C`stat()\*(C'\fR \- unfortunately, \s-1HPFS\s0
provides only 2sec time granularity (for compatibility with \s-1FAT\s0?).
.RE
.RS 8
.RE
.SS "Installing the built perl"
.IX Subsection "Installing the built perl"
If you haven't yet moved \f(CW\*(C`perl*.dll\*(C'\fR onto \s-1LIBPATH,\s0 do it now.
.PP
Run
.PP
.Vb 1
\&  make install
.Ve
.PP
It would put the generated files into needed locations. Manually put
\&\fIperl.exe\fR, \fIperl_\|_.exe\fR and \fIperl_\|_\|_.exe\fR to a location on your
\&\s-1PATH, \s0\fIperl.dll\fR to a location on your \s-1LIBPATH.\s0
.PP
Run
.PP
.Vb 1
\&  make installcmd INSTALLCMDDIR=d:/ir/on/path
.Ve
.PP
to convert perl utilities to \fI.cmd\fR files and put them on
\&\s-1PATH.\s0 You need to put \fI.EXE\fR\-utilities on path manually. They are
installed in \f(CW\*(C`$prefix/bin\*(C'\fR, here \f(CW$prefix\fR is what you gave to
\&\fIConfigure\fR, see \*(L"Making\*(R".
.PP
If you use \f(CW\*(C`man\*(C'\fR, either move the installed \fI*/man/\fR directories to
your \f(CW\*(C`MANPATH\*(C'\fR, or modify \f(CW\*(C`MANPATH\*(C'\fR to match the location.  (One
could have avoided this by providing a correct \f(CW\*(C`manpath\*(C'\fR option to
\&\fI./Configure\fR, or editing \fI./config.sh\fR between configuring and
making steps.)
.ie n .SS """a.out""\-style build"
.el .SS "\f(CWa.out\fP\-style build"
.IX Subsection "a.out-style build"
Proceed as above, but make \fIperl_.exe\fR (see \*(L"perl_.exe\*(R") by
.PP
.Vb 1
\&  make perl_
.Ve
.PP
test and install by
.PP
.Vb 2
\&  make aout_test
\&  make aout_install
.Ve
.PP
Manually put \fIperl_.exe\fR to a location on your \s-1PATH.\s0
.PP
\&\fBNote.\fR The build process for \f(CW\*(C`perl_\*(C'\fR \fIdoes not know\fR about all the
dependencies, so you should make sure that anything is up-to-date,
say, by doing
.PP
.Vb 1
\&  make perl_dll
.Ve
.PP
first.
.SH "Building a binary distribution"
.IX Header "Building a binary distribution"
[This section provides a short overview only...]
.PP
Building should proceed differently depending on whether the version of perl
you install is already present and used on your system, or is a new version
not yet used.  The description below assumes that the version is new, so
installing its DLLs and \fI.pm\fR files will not disrupt the operation of your
system even if some intermediate steps are not yet fully working.
.PP
The other cases require a little bit more convoluted procedures.  Below I
suppose that the current version of Perl is \f(CW5.8.2\fR, so the executables are
named accordingly.
.IP "1." 4
Fully build and test the Perl distribution.  Make sure that no tests are
failing with \f(CW\*(C`test\*(C'\fR and \f(CW\*(C`aout_test\*(C'\fR targets; fix the bugs in Perl and
the Perl test suite detected by these tests.  Make sure that \f(CW\*(C`all_test\*(C'\fR
make target runs as clean as possible.  Check that \fIos2/perlrexx.cmd\fR
runs fine.
.IP "2." 4
Fully install Perl, including \f(CW\*(C`installcmd\*(C'\fR target.  Copy the generated DLLs
to \f(CW\*(C`LIBPATH\*(C'\fR; copy the numbered Perl executables (as in \fIperl5.8.2.exe\fR)
to \f(CW\*(C`PATH\*(C'\fR; copy \f(CW\*(C`perl_.exe\*(C'\fR to \f(CW\*(C`PATH\*(C'\fR as \f(CW\*(C`perl_5.8.2.exe\*(C'\fR.  Think whether
you need backward-compatibility DLLs.  In most cases you do not need to install
them yet; but sometime this may simplify the following steps.
.IP "3." 4
Make sure that \f(CW\*(C`CPAN.pm\*(C'\fR can download files from \s-1CPAN. \s0 If not, you may need
to manually install \f(CW\*(C`Net::FTP\*(C'\fR.
.IP "4." 4
Install the bundle \f(CW\*(C`Bundle::OS2_default\*(C'\fR
.Sp
.Vb 1
\&  perl5.8.2 \-MCPAN \-e "install Bundle::OS2_default" < nul |& tee 00cpan_i_1
.Ve
.Sp
This may take a couple of hours on 1GHz processor (when run the first time).
And this should not be necessarily a smooth procedure.  Some modules may not
specify required dependencies, so one may need to repeat this procedure several
times until the results stabilize.
.Sp
.Vb 2
\&  perl5.8.2 \-MCPAN \-e "install Bundle::OS2_default" < nul |& tee 00cpan_i_2
\&  perl5.8.2 \-MCPAN \-e "install Bundle::OS2_default" < nul |& tee 00cpan_i_3
.Ve
.Sp
Even after they stabilize, some tests may fail.
.Sp
Fix as many discovered bugs as possible.  Document all the bugs which are not
fixed, and all the failures with unknown reasons.  Inspect the produced logs
\&\fI00cpan_i_1\fR to find suspiciously skipped tests, and other fishy events.
.Sp
Keep in mind that \fIinstallation\fR of some modules may fail too: for example,
the DLLs to update may be already loaded by \fI\s-1CPAN\s0.pm\fR.  Inspect the \f(CW\*(C`install\*(C'\fR
logs (in the example above \fI00cpan_i_1\fR etc) for errors, and install things
manually, as in
.Sp
.Vb 2
\&  cd $CPANHOME/.cpan/build/Digest\-MD5\-2.31
\&  make install
.Ve
.Sp
Some distributions may fail some tests, but you may want to install them
anyway (as above, or via \f(CW\*(C`force install\*(C'\fR command of \f(CW\*(C`CPAN.pm\*(C'\fR shell-mode).
.Sp
Since this procedure may take quite a long time to complete, it makes sense
to \*(L"freeze\*(R" your \s-1CPAN\s0 configuration by disabling periodic updates of the
local copy of \s-1CPAN\s0 index: set \f(CW\*(C`index_expire\*(C'\fR to some big value (I use 365),
then save the settings
.Sp
.Vb 2
\&  CPAN> o conf index_expire 365
\&  CPAN> o conf commit
.Ve
.Sp
Reset back to the default value \f(CW1\fR when you are finished.
.IP "5." 4
When satisfied with the results, rerun the \f(CW\*(C`installcmd\*(C'\fR target.  Now you
can copy \f(CW\*(C`perl5.8.2.exe\*(C'\fR to \f(CW\*(C`perl.exe\*(C'\fR, and install the other OMF-build
executables: \f(CW\*(C`perl_\|_.exe\*(C'\fR etc.  They are ready to be used.
.IP "6." 4
Change to the \f(CW\*(C`./pod\*(C'\fR directory of the build tree, download the Perl logo
\&\fICamelGrayBig.BMP\fR, and run
.Sp
.Vb 2
\&  ( perl2ipf > perl.ipf ) |& tee 00ipf
\&  ipfc /INF perl.ipf |& tee 00inf
.Ve
.Sp
This produces the Perl docs online book \f(CW\*(C`perl.INF\*(C'\fR.  Install in on
\&\f(CW\*(C`BOOKSHELF\*(C'\fR path.
.IP "7." 4
Now is the time to build statically linked executable \fIperl_.exe\fR which
includes newly-installed via \f(CW\*(C`Bundle::OS2_default\*(C'\fR modules.  Doing testing
via \f(CW\*(C`CPAN.pm\*(C'\fR is going to be painfully slow, since it statically links
a new executable per \s-1XS\s0 extension.
.Sp
Here is a possible workaround: create a toplevel \fIMakefile.PL\fR in
\&\fI\f(CI$CPANHOME\fI/.cpan/build/\fR with contents being (compare with \*(L"Making
executables with a custom collection of statically loaded extensions\*(R")
.Sp
.Vb 2
\&  use ExtUtils::MakeMaker;
\&  WriteMakefile NAME => \*(Aqdummy\*(Aq;
.Ve
.Sp
execute this as
.Sp
.Vb 2
\&  perl_5.8.2.exe Makefile.PL <nul |& tee 00aout_c1
\&  make \-k all test <nul |& 00aout_t1
.Ve
.Sp
Again, this procedure should not be absolutely smooth.  Some \f(CW\*(C`Makefile.PL\*(C'\fR's
in subdirectories may be buggy, and would not run as \*(L"child\*(R" scripts.  The
interdependency of modules can strike you; however, since non-XS modules
are already installed, the prerequisites of most modules have a very good
chance to be present.
.Sp
If you discover some glitches, move directories of problematic modules to a
different location; if these modules are non-XS modules, you may just ignore
them \- they are already installed; the remaining, \s-1XS,\s0 modules you need to
install manually one by one.
.Sp
After each such removal you need to rerun the \f(CW\*(C`Makefile.PL\*(C'\fR/\f(CW\*(C`make\*(C'\fR process;
usually this procedure converges soon.  (But be sure to convert all the
necessary external C libraries from \fI.lib\fR format to \fI.a\fR format: run one of
.Sp
.Vb 2
\&  emxaout foo.lib
\&  emximp \-o foo.a foo.lib
.Ve
.Sp
whichever is appropriate.)  Also, make sure that the DLLs for external
libraries are usable with with executables compiled without \f(CW\*(C`\-Zmtd\*(C'\fR options.
.Sp
When you are sure that only a few subdirectories
lead to failures, you may want to add \f(CW\*(C`\-j4\*(C'\fR option to \f(CW\*(C`make\*(C'\fR to speed up
skipping subdirectories with already finished build.
.Sp
When you are satisfied with the results of tests, install the build C libraries
for extensions:
.Sp
.Vb 1
\&  make install |& tee 00aout_i
.Ve
.Sp
Now you can rename the file \fI./perl.exe\fR generated during the last phase
to \fIperl_5.8.2.exe\fR; place it on \f(CW\*(C`PATH\*(C'\fR; if there is an inter-dependency
between some \s-1XS\s0 modules, you may need to repeat the \f(CW\*(C`test\*(C'\fR/\f(CW\*(C`install\*(C'\fR loop
with this new executable and some excluded modules \- until the procedure
converges.
.Sp
Now you have all the necessary \fI.a\fR libraries for these Perl modules in the
places where Perl builder can find it.  Use the perl builder: change to an
empty directory, create a \*(L"dummy\*(R" \fIMakefile.PL\fR again, and run
.Sp
.Vb 2
\&  perl_5.8.2.exe Makefile.PL |& tee 00c
\&  make perl                  |& tee 00p
.Ve
.Sp
This should create an executable \fI./perl.exe\fR with all the statically loaded
extensions built in.  Compare the generated \fIperlmain.c\fR files to make sure
that during the iterations the number of loaded extensions only increases.
Rename \fI./perl.exe\fR to \fIperl_5.8.2.exe\fR on \f(CW\*(C`PATH\*(C'\fR.
.Sp
When it converges, you got a functional variant of \fIperl_5.8.2.exe\fR; copy it
to \f(CW\*(C`perl_.exe\*(C'\fR.  You are done with generation of the local Perl installation.
.IP "8." 4
Make sure that the installed modules are actually installed in the location
of the new Perl, and are not inherited from entries of \f(CW@INC\fR given for
inheritance from the older versions of Perl: set \f(CW\*(C`PERLLIB_582_PREFIX\*(C'\fR to
redirect the new version of Perl to a new location, and copy the installed
files to this new location.  Redo the tests to make sure that the versions of
modules inherited from older versions of Perl are not needed.
.Sp
Actually, the log output of \fIpod2ipf\fR\|(1) during the step 6 gives a very detailed
info about which modules are loaded from which place; so you may use it as
an additional verification tool.
.Sp
Check that some temporary files did not make into the perl install tree.
Run something like this
.Sp
.Vb 1
\&  pfind . \-f "!(/\e.(pm|pl|ix|al|h|a|lib|txt|pod|imp|bs|dll|ld|bs|inc|xbm|yml|cgi|uu|e2x|skip|packlist|eg|cfg|html|pub|enc|all|ini|po|pot)$/i or /^\ew+$/") | less
.Ve
.Sp
in the install tree (both top one and \fIsitelib\fR one).
.Sp
Compress all the DLLs with \fIlxlite\fR.  The tiny \fI.exe\fR can be compressed with
\&\f(CW\*(C`/c:max\*(C'\fR (the bug only appears when there is a fixup in the last 6 bytes of a
page (?); since the tiny executables are much smaller than a page, the bug
will not hit).  Do not compress \f(CW\*(C`perl_.exe\*(C'\fR \- it would not work under \s-1DOS.\s0
.IP "9." 4
Now you can generate the binary distribution.  This is done by running the
test of the \s-1CPAN\s0 distribution \f(CW\*(C`OS2::SoftInstaller\*(C'\fR.  Tune up the file
\&\fItest.pl\fR to suit the layout of current version of Perl first.  Do not
forget to pack the necessary external DLLs accordingly.  Include the
description of the bugs and test suite failures you could not fix.  Include
the small-stack versions of Perl executables from Perl build directory.
.Sp
Include \fIperl5.def\fR so that people can relink the perl \s-1DLL\s0 preserving
the binary compatibility, or can create compatibility DLLs.  Include the diff
files (\f(CW\*(C`diff \-pu old new\*(C'\fR) of fixes you did so that people can rebuild your
version.  Include \fIperl5.map\fR so that one can use remote debugging.
.IP "10." 4
Share what you did with the other people.  Relax.  Enjoy fruits of your work.
.IP "11." 4
Brace yourself for thanks, bug reports, hate mail and spam coming as result
of the previous step.  No good deed should remain unpunished!
.SH "Building custom \fI.EXE\fP files"
.IX Header "Building custom .EXE files"
The Perl executables can be easily rebuilt at any moment.  Moreover, one can
use the \fIembedding\fR interface (see perlembed) to make very customized
executables.
.SS "Making executables with a custom collection of statically loaded extensions"
.IX Subsection "Making executables with a custom collection of statically loaded extensions"
It is a little bit easier to do so while \fIdecreasing\fR the list of statically
loaded extensions.  We discuss this case only here.
.IP "1." 4
Change to an empty directory, and create a placeholder <Makefile.PL>:
.Sp
.Vb 2
\&  use ExtUtils::MakeMaker;
\&  WriteMakefile NAME => \*(Aqdummy\*(Aq;
.Ve
.IP "2." 4
Run it with the flavor of Perl (\fIperl.exe\fR or \fIperl_.exe\fR) you want to
rebuild.
.Sp
.Vb 1
\&  perl_ Makefile.PL
.Ve
.IP "3." 4
Ask it to create new Perl executable:
.Sp
.Vb 1
\&  make perl
.Ve
.Sp
(you may need to manually add \f(CW\*(C`PERLTYPE=\-DPERL_CORE\*(C'\fR to this commandline on
some versions of Perl; the symptom is that the command-line globbing does not
work from \s-1OS/2\s0 shells with the newly-compiled executable; check with
.Sp
.Vb 1
\&  .\eperl.exe \-wle "print for @ARGV" *
.Ve
.Sp
).
.IP "4." 4
The previous step created \fIperlmain.c\fR which contains a list of \fInewXS()\fR calls
near the end.  Removing unnecessary calls, and rerunning
.Sp
.Vb 1
\&  make perl
.Ve
.Sp
will produce a customized executable.
.SS "Making executables with a custom search-paths"
.IX Subsection "Making executables with a custom search-paths"
The default perl executable is flexible enough to support most usages.
However, one may want something yet more flexible; for example, one may want
to find Perl \s-1DLL\s0 relatively to the location of the \s-1EXE\s0 file; or one may want
to ignore the environment when setting the Perl-library search patch, etc.
.PP
If you fill comfortable with \fIembedding\fR interface (see perlembed), such
things are easy to do repeating the steps outlined in \*(L"Making
executables with a custom collection of statically loaded extensions\*(R", and
doing more comprehensive edits to \fImain()\fR of \fIperlmain.c\fR.  The people with
little desire to understand Perl can just rename \fImain()\fR, and do necessary
modification in a custom \fImain()\fR which calls the renamed function in appropriate
time.
.PP
However, there is a third way: perl \s-1DLL\s0 exports the \fImain()\fR function and several
callbacks to customize the search path.  Below is a complete example of a
\&\*(L"Perl loader\*(R" which
.IP "1." 4
Looks for Perl \s-1DLL\s0 in the directory \f(CW\*(C`$exedir/../dll\*(C'\fR;
.IP "2." 4
Prepends the above directory to \f(CW\*(C`BEGINLIBPATH\*(C'\fR;
.IP "3." 4
Fails if the Perl \s-1DLL\s0 found via \f(CW\*(C`BEGINLIBPATH\*(C'\fR is different from what was
loaded on step 1; e.g., another process could have loaded it from \f(CW\*(C`LIBPATH\*(C'\fR
or from a different value of \f(CW\*(C`BEGINLIBPATH\*(C'\fR.  In these cases one needs to
modify the setting of the system so that this other process either does not
run, or loads the \s-1DLL\s0 from \f(CW\*(C`BEGINLIBPATH\*(C'\fR with \f(CW\*(C`LIBPATHSTRICT=T\*(C'\fR (available
with kernels after September 2000).
.IP "4." 4
Loads Perl library from \f(CW\*(C`$exedir/../dll/lib/\*(C'\fR.
.IP "5." 4
Uses Bourne shell from \f(CW\*(C`$exedir/../dll/sh/ksh.exe\*(C'\fR.
.PP
For best results compile the C file below with the same options as the Perl
\&\s-1DLL. \s0 However, a lot of functionality will work even if the executable is not
an \s-1EMX\s0 applications, e.g., if compiled with
.PP
.Vb 1
\&  gcc \-Wall \-DDOSISH \-DOS2=1 \-O2 \-s \-Zomf \-Zsys perl\-starter.c \-DPERL_DLL_BASENAME=\e"perl312F\e" \-Zstack 8192 \-Zlinker /PM:VIO
.Ve
.PP
Here is the sample C file:
.PP
.Vb 5
\&  #define INCL_DOS
\&  #define INCL_NOPM
\&  /* These are needed for compile if os2.h includes os2tk.h, not os2emx.h */
\&  #define INCL_DOSPROCESS
\&  #include <os2.h>
\&
\&  #include "EXTERN.h"
\&  #define PERL_IN_MINIPERLMAIN_C
\&  #include "perl.h"
\&
\&  static char *me;
\&  HMODULE handle;
\&
\&  static void
\&  die_with(char *msg1, char *msg2, char *msg3, char *msg4)
\&  {
\&     ULONG c;
\&     char *s = " error: ";
\&
\&     DosWrite(2, me, strlen(me), &c);
\&     DosWrite(2, s, strlen(s), &c);
\&     DosWrite(2, msg1, strlen(msg1), &c);
\&     DosWrite(2, msg2, strlen(msg2), &c);
\&     DosWrite(2, msg3, strlen(msg3), &c);
\&     DosWrite(2, msg4, strlen(msg4), &c);
\&     DosWrite(2, "\er\en", 2, &c);
\&     exit(255);
\&  }
\&
\&  typedef ULONG (*fill_extLibpath_t)(int type, char *pre, char *post, int replace, char *msg);
\&  typedef int (*main_t)(int type, char *argv[], char *env[]);
\&  typedef int (*handler_t)(void* data, int which);
\&
\&  #ifndef PERL_DLL_BASENAME
\&  #  define PERL_DLL_BASENAME "perl"
\&  #endif
\&
\&  static HMODULE
\&  load_perl_dll(char *basename)
\&  {
\&      char buf[300], fail[260];
\&      STRLEN l, dirl;
\&      fill_extLibpath_t f;
\&      ULONG rc_fullname;
\&      HMODULE handle, handle1;
\&
\&      if (_execname(buf, sizeof(buf) \- 13) != 0)
\&          die_with("Can\*(Aqt find full path: ", strerror(errno), "", "");
\&      /* XXXX Fill \*(Aqme\*(Aq with new value */
\&      l = strlen(buf);
\&      while (l && buf[l\-1] != \*(Aq/\*(Aq && buf[l\-1] != \*(Aq\e\e\*(Aq)
\&          l\-\-;
\&      dirl = l \- 1;
\&      strcpy(buf + l, basename);
\&      l += strlen(basename);
\&      strcpy(buf + l, ".dll");
\&      if ( (rc_fullname = DosLoadModule(fail, sizeof fail, buf, &handle)) != 0
\&           && DosLoadModule(fail, sizeof fail, basename, &handle) != 0 )
\&          die_with("Can\*(Aqt load DLL ", buf, "", "");
\&      if (rc_fullname)
\&          return handle;                /* was loaded with short name; all is fine */
\&      if (DosQueryProcAddr(handle, 0, "fill_extLibpath", (PFN*)&f))
\&          die_with(buf, ": DLL exports no symbol ", "fill_extLibpath", "");
\&      buf[dirl] = 0;
\&      if (f(0 /*BEGINLIBPATH*/, buf /* prepend */, NULL /* append */,
\&            0 /* keep old value */, me))
\&          die_with(me, ": prepending BEGINLIBPATH", "", "");
\&      if (DosLoadModule(fail, sizeof fail, basename, &handle1) != 0)
\&          die_with(me, ": finding perl DLL again via BEGINLIBPATH", "", "");
\&      buf[dirl] = \*(Aq\e\e\*(Aq;     
\&      if (handle1 != handle) {
\&          if (DosQueryModuleName(handle1, sizeof(fail), fail))
\&              strcpy(fail, "???");
\&          die_with(buf, ":\en\etperl DLL via BEGINLIBPATH is different: \en\et",
\&                   fail,
\&                   "\en\etYou may need to manipulate global BEGINLIBPATH and LIBPATHSTRICT"
\&                   "\en\etso that the other copy is loaded via BEGINLIBPATH.");
\&      }
\&      return handle;
\&  }
\&
\&  int
\&  main(int argc, char **argv, char **env)
\&  {
\&      main_t f;
\&      handler_t h;
\&
\&      me = argv[0];
\&      /**/
\&      handle = load_perl_dll(PERL_DLL_BASENAME);
\&
\&      if (DosQueryProcAddr(handle, 0, "Perl_OS2_handler_install", (PFN*)&h))
\&          die_with(PERL_DLL_BASENAME, ": DLL exports no symbol ", "Perl_OS2_handler_install", "");
\&      if ( !h((void *)"~installprefix", Perlos2_handler_perllib_from)
\&           || !h((void *)"~dll", Perlos2_handler_perllib_to)
\&           || !h((void *)"~dll/sh/ksh.exe", Perlos2_handler_perl_sh) )
\&          die_with(PERL_DLL_BASENAME, ": Can\*(Aqt install @INC manglers", "", "");
\&
\&      if (DosQueryProcAddr(handle, 0, "dll_perlmain", (PFN*)&f))
\&          die_with(PERL_DLL_BASENAME, ": DLL exports no symbol ", "dll_perlmain", "");
\&      return f(argc, argv, env);
\&  }
.Ve
.SH "Build FAQ"
.IX Header "Build FAQ"
.ie n .SS "Some ""/"" became ""\e"" in pdksh."
.el .SS "Some \f(CW/\fP became \f(CW\e\fP in pdksh."
.IX Subsection "Some / became in pdksh."
You have a very old pdksh. See \*(L"Prerequisites\*(R".
.ie n .SS "\*(Aqerrno\*(Aq \- unresolved external"
.el .SS "\f(CW\*(Aqerrno\*(Aq\fP \- unresolved external"
.IX Subsection "errno - unresolved external"
You do not have MT-safe \fIdb.lib\fR. See \*(L"Prerequisites\*(R".
.SS "Problems with tr or sed"
.IX Subsection "Problems with tr or sed"
reported with very old version of tr and sed.
.SS "Some problem (forget which ;\-)"
.IX Subsection "Some problem (forget which ;-)"
You have an older version of \fIperl.dll\fR on your \s-1LIBPATH,\s0 which
broke the build of extensions.
.SS "Library ... not found"
.IX Subsection "Library ... not found"
You did not run \f(CW\*(C`omflibs\*(C'\fR. See \*(L"Prerequisites\*(R".
.SS "Segfault in make"
.IX Subsection "Segfault in make"
You use an old version of \s-1GNU\s0 make. See \*(L"Prerequisites\*(R".
.SS "op/sprintf test failure"
.IX Subsection "op/sprintf test failure"
This can result from a bug in emx sprintf which was fixed in 0.9d fix 03.
.SH "Specific (mis)features of OS/2 port"
.IX Header "Specific (mis)features of OS/2 port"
.ie n .SS """setpriority"", ""getpriority"""
.el .SS "\f(CWsetpriority\fP, \f(CWgetpriority\fP"
.IX Subsection "setpriority, getpriority"
Note that these functions are compatible with *nix, not with the older
ports of '94 \- 95. The priorities are absolute, go from 32 to \-95,
lower is quicker. 0 is the default priority.
.PP
\&\fB\s-1WARNING\s0\fR.  Calling \f(CW\*(C`getpriority\*(C'\fR on a non-existing process could lock
the system before Warp3 fixpak22.  Starting with Warp3, Perl will use
a workaround: it aborts \fIgetpriority()\fR if the process is not present.
This is not possible on older versions \f(CW\*(C`2.*\*(C'\fR, and has a race
condition anyway.
.ie n .SS """system()"""
.el .SS "\f(CWsystem()\fP"
.IX Subsection "system()"
Multi-argument form of \f(CW\*(C`system()\*(C'\fR allows an additional numeric
argument. The meaning of this argument is described in
OS2::Process.
.PP
When finding a program to run, Perl first asks the \s-1OS\s0 to look for executables
on \f(CW\*(C`PATH\*(C'\fR (\s-1OS/2\s0 adds extension \fI.exe\fR if no extension is present).
If not found, it looks for a script with possible extensions 
added in this order: no extension, \fI.cmd\fR, \fI.btm\fR, 
\&\fI.bat\fR, \fI.pl\fR.  If found, Perl checks the start of the file for magic
strings \f(CW"#!"\fR and \f(CW"extproc "\fR.  If found, Perl uses the rest of the
first line as the beginning of the command line to run this script.  The
only mangling done to the first line is extraction of arguments (currently
up to 3), and ignoring of the path-part of the \*(L"interpreter\*(R" name if it can't
be found using the full path.
.PP
E.g., \f(CW\*(C`system \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq\*(C'\fR may lead Perl to finding
\&\fIC:/emx/bin/foo.cmd\fR with the first line being
.PP
.Vb 1
\& extproc /bin/bash    \-x   \-c
.Ve
.PP
If \fI/bin/bash.exe\fR is not found, then Perl looks for an executable \fIbash.exe\fR on
\&\f(CW\*(C`PATH\*(C'\fR.  If found in \fIC:/emx.add/bin/bash.exe\fR, then the above \fIsystem()\fR is
translated to
.PP
.Vb 1
\&  system qw(C:/emx.add/bin/bash.exe \-x \-c C:/emx/bin/foo.cmd bar baz)
.Ve
.PP
One additional translation is performed: instead of \fI/bin/sh\fR Perl uses
the hardwired-or-customized shell (see \f(CW"PERL_SH_DIR"\fR).
.PP
The above search for \*(L"interpreter\*(R" is recursive: if \fIbash\fR executable is not
found, but \fIbash.btm\fR is found, Perl will investigate its first line etc.
The only hardwired limit on the recursion depth is implicit: there is a limit
4 on the number of additional arguments inserted before the actual arguments
given to \fIsystem()\fR.  In particular, if no additional arguments are specified
on the \*(L"magic\*(R" first lines, then the limit on the depth is 4.
.PP
If Perl finds that the found executable is of \s-1PM\s0 type when the
current session is not, it will start the new process in a separate session of
necessary type.  Call via \f(CW\*(C`OS2::Process\*(C'\fR to disable this magic.
.PP
\&\fB\s-1WARNING\s0\fR.  Due to the described logic, you need to explicitly
specify \fI.com\fR extension if needed.  Moreover, if the executable
\&\fIperl5.6.1\fR is requested, Perl will not look for \fIperl5.6.1.exe\fR.
[This may change in the future.]
.ie n .SS """extproc"" on the first line"
.el .SS "\f(CWextproc\fP on the first line"
.IX Subsection "extproc on the first line"
If the first chars of a Perl script are \f(CW"extproc "\fR, this line is treated
as \f(CW\*(C`#!\*(C'\fR\-line, thus all the switches on this line are processed (twice
if script was started via cmd.exe).  See \*(L"\s-1DESCRIPTION\*(R"\s0 in perlrun.
.SS "Additional modules:"
.IX Subsection "Additional modules:"
OS2::Process, \s-1OS2::DLL\s0, \s-1OS2::REXX\s0, OS2::PrfDB, OS2::ExtAttr. These
modules provide access to additional numeric argument for \f(CW\*(C`system\*(C'\fR
and to the information about the running process,
to DLLs having functions with \s-1REXX\s0 signature and to the \s-1REXX\s0 runtime, to
\&\s-1OS/2\s0 databases in the \fI.INI\fR format, and to Extended Attributes.
.PP
Two additional extensions by Andreas Kaiser, \f(CW\*(C`OS2::UPM\*(C'\fR, and
\&\f(CW\*(C`OS2::FTP\*(C'\fR, are included into \f(CW\*(C`ILYAZ\*(C'\fR directory, mirrored on \s-1CPAN.\s0
Other OS/2\-related extensions are available too.
.SS "Prebuilt methods:"
.IX Subsection "Prebuilt methods:"
.ie n .IP """File::Copy::syscopy""" 4
.el .IP "\f(CWFile::Copy::syscopy\fR" 4
.IX Item "File::Copy::syscopy"
used by \f(CW\*(C`File::Copy::copy\*(C'\fR, see File::Copy.
.ie n .IP """DynaLoader::mod2fname""" 4
.el .IP "\f(CWDynaLoader::mod2fname\fR" 4
.IX Item "DynaLoader::mod2fname"
used by \f(CW\*(C`DynaLoader\*(C'\fR for \s-1DLL\s0 name mangling.
.ie n .IP """Cwd::current_drive()""" 4
.el .IP "\f(CWCwd::current_drive()\fR" 4
.IX Item "Cwd::current_drive()"
Self explanatory.
.ie n .IP """Cwd::sys_chdir(name)""" 4
.el .IP "\f(CWCwd::sys_chdir(name)\fR" 4
.IX Item "Cwd::sys_chdir(name)"
leaves drive as it is.
.ie n .IP """Cwd::change_drive(name)""" 4
.el .IP "\f(CWCwd::change_drive(name)\fR" 4
.IX Item "Cwd::change_drive(name)"
changes the \*(L"current\*(R" drive.
.ie n .IP """Cwd::sys_is_absolute(name)""" 4
.el .IP "\f(CWCwd::sys_is_absolute(name)\fR" 4
.IX Item "Cwd::sys_is_absolute(name)"
means has drive letter and is_rooted.
.ie n .IP """Cwd::sys_is_rooted(name)""" 4
.el .IP "\f(CWCwd::sys_is_rooted(name)\fR" 4
.IX Item "Cwd::sys_is_rooted(name)"
means has leading \f(CW\*(C`[/\e\e]\*(C'\fR (maybe after a drive-letter:).
.ie n .IP """Cwd::sys_is_relative(name)""" 4
.el .IP "\f(CWCwd::sys_is_relative(name)\fR" 4
.IX Item "Cwd::sys_is_relative(name)"
means changes with current dir.
.ie n .IP """Cwd::sys_cwd(name)""" 4
.el .IP "\f(CWCwd::sys_cwd(name)\fR" 4
.IX Item "Cwd::sys_cwd(name)"
Interface to cwd from \s-1EMX.\s0 Used by \f(CW\*(C`Cwd::cwd\*(C'\fR.
.ie n .IP """Cwd::sys_abspath(name, dir)""" 4
.el .IP "\f(CWCwd::sys_abspath(name, dir)\fR" 4
.IX Item "Cwd::sys_abspath(name, dir)"
Really really odious function to implement. Returns absolute name of
file which would have \f(CW\*(C`name\*(C'\fR if \s-1CWD\s0 were \f(CW\*(C`dir\*(C'\fR.  \f(CW\*(C`Dir\*(C'\fR defaults to the
current dir.
.ie n .IP """Cwd::extLibpath([type])""" 4
.el .IP "\f(CWCwd::extLibpath([type])\fR" 4
.IX Item "Cwd::extLibpath([type])"
Get current value of extended library search path. If \f(CW\*(C`type\*(C'\fR is
present and positive, works with \f(CW\*(C`END_LIBPATH\*(C'\fR, if negative, works
with \f(CW\*(C`LIBPATHSTRICT\*(C'\fR, otherwise with \f(CW\*(C`BEGIN_LIBPATH\*(C'\fR.
.ie n .IP """Cwd::extLibpath_set( path [, type ] )""" 4
.el .IP "\f(CWCwd::extLibpath_set( path [, type ] )\fR" 4
.IX Item "Cwd::extLibpath_set( path [, type ] )"
Set current value of extended library search path. If \f(CW\*(C`type\*(C'\fR is
present and positive, works with <\s-1END_LIBPATH\s0>, if negative, works
with \f(CW\*(C`LIBPATHSTRICT\*(C'\fR, otherwise with \f(CW\*(C`BEGIN_LIBPATH\*(C'\fR.
.ie n .IP """OS2::Error(do_harderror,do_exception)""" 4
.el .IP "\f(CWOS2::Error(do_harderror,do_exception)\fR" 4
.IX Item "OS2::Error(do_harderror,do_exception)"
Returns	\f(CW\*(C`undef\*(C'\fR if it was not called yet, otherwise bit 1 is
set if on the previous call do_harderror was enabled, bit
2 is set if on previous call do_exception was enabled.
.Sp
This function enables/disables error popups associated with 
hardware errors (Disk not ready etc.) and software exceptions.
.Sp
I know of no way to find out the state of popups \fIbefore\fR the first call
to this function.
.ie n .IP """OS2::Errors2Drive(drive)""" 4
.el .IP "\f(CWOS2::Errors2Drive(drive)\fR" 4
.IX Item "OS2::Errors2Drive(drive)"
Returns \f(CW\*(C`undef\*(C'\fR if it was not called yet, otherwise return false if errors
were not requested to be written to a hard drive, or the drive letter if
this was requested.
.Sp
This function may redirect error popups associated with hardware errors
(Disk not ready etc.) and software exceptions to the file \s-1POPUPLOG.OS2\s0 at
the root directory of the specified drive.  Overrides \fIOS2::Error()\fR specified
by individual programs.  Given argument undef will disable redirection.
.Sp
Has global effect, persists after the application exits.
.Sp
I know of no way to find out the state of redirection of popups to the disk
\&\fIbefore\fR the first call to this function.
.IP "\fIOS2::SysInfo()\fR" 4
.IX Item "OS2::SysInfo()"
Returns a hash with system information. The keys of the hash are
.Sp
.Vb 8
\&        MAX_PATH_LENGTH, MAX_TEXT_SESSIONS, MAX_PM_SESSIONS,
\&        MAX_VDM_SESSIONS, BOOT_DRIVE, DYN_PRI_VARIATION,
\&        MAX_WAIT, MIN_SLICE, MAX_SLICE, PAGE_SIZE,
\&        VERSION_MAJOR, VERSION_MINOR, VERSION_REVISION,
\&        MS_COUNT, TIME_LOW, TIME_HIGH, TOTPHYSMEM, TOTRESMEM,
\&        TOTAVAILMEM, MAXPRMEM, MAXSHMEM, TIMER_INTERVAL,
\&        MAX_COMP_LENGTH, FOREGROUND_FS_SESSION,
\&        FOREGROUND_PROCESS
.Ve
.IP "\fIOS2::BootDrive()\fR" 4
.IX Item "OS2::BootDrive()"
Returns a letter without colon.
.ie n .IP """OS2::MorphPM(serve)"", ""OS2::UnMorphPM(serve)""" 4
.el .IP "\f(CWOS2::MorphPM(serve)\fR, \f(CWOS2::UnMorphPM(serve)\fR" 4
.IX Item "OS2::MorphPM(serve), OS2::UnMorphPM(serve)"
Transforms the current application into a \s-1PM\s0 application and back.
The argument true means that a real message loop is going to be served.
\&\fIOS2::MorphPM()\fR returns the \s-1PM\s0 message queue handle as an integer.
.Sp
See \*(L"Centralized management of resources\*(R" for additional details.
.ie n .IP """OS2::Serve_Messages(force)""" 4
.el .IP "\f(CWOS2::Serve_Messages(force)\fR" 4
.IX Item "OS2::Serve_Messages(force)"
Fake on-demand retrieval of outstanding \s-1PM\s0 messages.  If \f(CW\*(C`force\*(C'\fR is false,
will not dispatch messages if a real message loop is known to
be present.  Returns number of messages retrieved.
.Sp
Dies with \*(L"QUITing...\*(R" if \s-1WM_QUIT\s0 message is obtained.
.ie n .IP """OS2::Process_Messages(force [, cnt])""" 4
.el .IP "\f(CWOS2::Process_Messages(force [, cnt])\fR" 4
.IX Item "OS2::Process_Messages(force [, cnt])"
Retrieval of \s-1PM\s0 messages until window creation/destruction.  
If \f(CW\*(C`force\*(C'\fR is false, will not dispatch messages if a real message loop
is known to be present.
.Sp
Returns change in number of windows.  If \f(CW\*(C`cnt\*(C'\fR is given,
it is incremented by the number of messages retrieved.
.Sp
Dies with \*(L"QUITing...\*(R" if \s-1WM_QUIT\s0 message is obtained.
.ie n .IP """OS2::_control87(new,mask)""" 4
.el .IP "\f(CWOS2::_control87(new,mask)\fR" 4
.IX Item "OS2::_control87(new,mask)"
the same as \fI_control87\fR\|(3) of \s-1EMX. \s0 Takes integers as arguments, returns
the previous coprocessor control word as an integer.  Only bits in \f(CW\*(C`new\*(C'\fR which
are present in \f(CW\*(C`mask\*(C'\fR are changed in the control word.
.IP "\fIOS2::get_control87()\fR" 4
.IX Item "OS2::get_control87()"
gets the coprocessor control word as an integer.
.ie n .IP """OS2::set_control87_em(new=MCW_EM,mask=MCW_EM)""" 4
.el .IP "\f(CWOS2::set_control87_em(new=MCW_EM,mask=MCW_EM)\fR" 4
.IX Item "OS2::set_control87_em(new=MCW_EM,mask=MCW_EM)"
The variant of \fIOS2::_control87()\fR with default values good for
handling exception mask: if no \f(CW\*(C`mask\*(C'\fR, uses exception mask part of \f(CW\*(C`new\*(C'\fR
only.  If no \f(CW\*(C`new\*(C'\fR, disables all the floating point exceptions.
.Sp
See \*(L"Misfeatures\*(R" for details.
.ie n .IP """OS2::DLLname([how [, \e&xsub]])""" 4
.el .IP "\f(CWOS2::DLLname([how [, \e&xsub]])\fR" 4
.IX Item "OS2::DLLname([how [, &xsub]])"
Gives the information about the Perl \s-1DLL\s0 or the \s-1DLL\s0 containing the C
function bound to by \f(CW&xsub\fR.  The meaning of \f(CW\*(C`how\*(C'\fR is: default (2):
full name; 0: handle; 1: module name.
.PP
(Note that some of these may be moved to different libraries \-
eventually).
.SS "Prebuilt variables:"
.IX Subsection "Prebuilt variables:"
.ie n .IP "$OS2::emx_rev" 4
.el .IP "\f(CW$OS2::emx_rev\fR" 4
.IX Item "$OS2::emx_rev"
numeric value is the same as _emx_rev of \s-1EMX,\s0 a string value the same
as _emx_vprt (similar to \f(CW\*(C`0.9c\*(C'\fR).
.ie n .IP "$OS2::emx_env" 4
.el .IP "\f(CW$OS2::emx_env\fR" 4
.IX Item "$OS2::emx_env"
same as _emx_env of \s-1EMX,\s0 a number similar to 0x8001.
.ie n .IP "$OS2::os_ver" 4
.el .IP "\f(CW$OS2::os_ver\fR" 4
.IX Item "$OS2::os_ver"
a number \f(CW\*(C`OS_MAJOR + 0.001 * OS_MINOR\*(C'\fR.
.ie n .IP "$OS2::is_aout" 4
.el .IP "\f(CW$OS2::is_aout\fR" 4
.IX Item "$OS2::is_aout"
true if the Perl library was compiled in \s-1AOUT\s0 format.
.ie n .IP "$OS2::can_fork" 4
.el .IP "\f(CW$OS2::can_fork\fR" 4
.IX Item "$OS2::can_fork"
true if the current executable is an \s-1AOUT EMX\s0 executable, so Perl can
fork.  Do not use this, use the portable check for
\&\f(CW$Config::Config\fR{dfork}.
.ie n .IP "$OS2::nsyserror" 4
.el .IP "\f(CW$OS2::nsyserror\fR" 4
.IX Item "$OS2::nsyserror"
This variable (default is 1) controls whether to enforce the contents
of $^E to start with \f(CW\*(C`SYS0003\*(C'\fR\-like id.  If set to 0, then the string
value of $^E is what is available from the \s-1OS/2\s0 message file.  (Some
messages in this file have an \f(CW\*(C`SYS0003\*(C'\fR\-like id prepended, some not.)
.SS "Misfeatures"
.IX Subsection "Misfeatures"
.IP "\(bu" 4
Since \fIflock\fR\|(3) is present in \s-1EMX,\s0 but is not functional, it is 
emulated by perl.  To disable the emulations, set environment variable
\&\f(CW\*(C`USE_PERL_FLOCK=0\*(C'\fR.
.IP "\(bu" 4
Here is the list of things which may be \*(L"broken\*(R" on
\&\s-1EMX \s0(from \s-1EMX\s0 docs):
.RS 4
.IP "\(bu" 4
The functions \fIrecvmsg\fR\|(3), \fIsendmsg\fR\|(3), and \fIsocketpair\fR\|(3) are not
implemented.
.IP "\(bu" 4
\&\fIsock_init\fR\|(3) is not required and not implemented.
.IP "\(bu" 4
\&\fIflock\fR\|(3) is not yet implemented (dummy function).  (Perl has a workaround.)
.IP "\(bu" 4
\&\fIkill\fR\|(3):  Special treatment of PID=0, PID=1 and PID=\-1 is not implemented.
.IP "\(bu" 4
\&\fIwaitpid\fR\|(3):
.Sp
.Vb 3
\&      WUNTRACED
\&              Not implemented.
\&      waitpid() is not implemented for negative values of PID.
.Ve
.RE
.RS 4
.Sp
Note that \f(CW\*(C`kill \-9\*(C'\fR does not work with the current version of \s-1EMX.\s0
.RE
.IP "\(bu" 4
See \*(L"Text-mode filehandles\*(R".
.IP "\(bu" 4
Unix-domain sockets on \s-1OS/2\s0 live in a pseudo-file-system \f(CW\*(C`/sockets/...\*(C'\fR.
To avoid a failure to create a socket with a name of a different form,
\&\f(CW"/socket/"\fR is prepended to the socket name (unless it starts with this
already).
.Sp
This may lead to problems later in case the socket is accessed via the
\&\*(L"usual\*(R" file-system calls using the \*(L"initial\*(R" name.
.IP "\(bu" 4
Apparently, \s-1IBM\s0 used a compiler (for some period of time around '95?) which
changes \s-1FP\s0 mask right and left.  This is not \fIthat\fR bad for \s-1IBM\s0's
programs, but the same compiler was used for DLLs which are used with
general-purpose applications.  When these DLLs are used, the state of
floating-point flags in the application is not predictable.
.Sp
What is much worse, some DLLs change the floating point flags when in
\&\fI_DLLInitTerm()\fR (e.g., \fI\s-1TCP32IP\s0\fR).  This means that even if you do not \fIcall\fR
any function in the \s-1DLL,\s0 just the act of loading this \s-1DLL\s0 will reset your
flags.  What is worse, the same compiler was used to compile some \s-1HOOK\s0 DLLs.
Given that \s-1HOOK\s0 dlls are executed in the context of \fIall\fR the applications
in the system, this means a complete unpredictability of floating point
flags on systems using such \s-1HOOK\s0 DLLs.  E.g., \fI\s-1GAMESRVR.DLL\s0\fR of \fB\s-1DIVE\s0\fR
origin changes the floating point flags on each write to the \s-1TTY\s0 of a \s-1VIO
\&\s0(windowed text-mode) applications.
.Sp
Some other (not completely debugged) situations when \s-1FP\s0 flags change include
some video drivers (?), and some operations related to creation of the windows.
People who code \fBOpenGL\fR may have more experience on this.
.Sp
Perl is generally used in the situation when all the floating-point
exceptions are ignored, as is the default under \s-1EMX. \s0 If they are not ignored,
some benign Perl programs would get a \f(CW\*(C`SIGFPE\*(C'\fR and would die a horrible death.
.Sp
To circumvent this, Perl uses two hacks.  They help against \fIone\fR type of
damage only: \s-1FP\s0 flags changed when loading a \s-1DLL.\s0
.Sp
One of the hacks is to disable floating point exceptions on Perl startup (as
is the default with \s-1EMX\s0).  This helps only with compile-time-linked DLLs
changing the flags before \fImain()\fR had a chance to be called.
.Sp
The other hack is to restore \s-1FP\s0 flags after a call to \fIdlopen()\fR.  This helps
against similar damage done by DLLs \fI_DLLInitTerm()\fR at runtime.  Currently
no way to switch these hacks off is provided.
.SS "Modifications"
.IX Subsection "Modifications"
Perl modifies some standard C library calls in the following ways:
.ie n .IP """popen""" 9
.el .IP "\f(CWpopen\fR" 9
.IX Item "popen"
\&\f(CW\*(C`my_popen\*(C'\fR uses \fIsh.exe\fR if shell is required, cf. \*(L"\s-1PERL_SH_DIR\*(R"\s0.
.ie n .IP """tmpnam""" 9
.el .IP "\f(CWtmpnam\fR" 9
.IX Item "tmpnam"
is created using \f(CW\*(C`TMP\*(C'\fR or \f(CW\*(C`TEMP\*(C'\fR environment variable, via
\&\f(CW\*(C`tempnam\*(C'\fR.
.ie n .IP """tmpfile""" 9
.el .IP "\f(CWtmpfile\fR" 9
.IX Item "tmpfile"
If the current directory is not writable, file is created using modified
\&\f(CW\*(C`tmpnam\*(C'\fR, so there may be a race condition.
.ie n .IP """ctermid""" 9
.el .IP "\f(CWctermid\fR" 9
.IX Item "ctermid"
a dummy implementation.
.ie n .IP """stat""" 9
.el .IP "\f(CWstat\fR" 9
.IX Item "stat"
\&\f(CW\*(C`os2_stat\*(C'\fR special-cases \fI/dev/tty\fR and \fI/dev/con\fR.
.ie n .IP """mkdir"", ""rmdir""" 9
.el .IP "\f(CWmkdir\fR, \f(CWrmdir\fR" 9
.IX Item "mkdir, rmdir"
these \s-1EMX\s0 functions do not work if the path contains a trailing \f(CW\*(C`/\*(C'\fR.
Perl contains a workaround for this.
.ie n .IP """flock""" 9
.el .IP "\f(CWflock\fR" 9
.IX Item "flock"
Since \fIflock\fR\|(3) is present in \s-1EMX,\s0 but is not functional, it is 
emulated by perl.  To disable the emulations, set environment variable
\&\f(CW\*(C`USE_PERL_FLOCK=0\*(C'\fR.
.SS "Identifying DLLs"
.IX Subsection "Identifying DLLs"
All the DLLs built with the current versions of Perl have \s-1ID\s0 strings
identifying the name of the extension, its version, and the version
of Perl required for this \s-1DLL. \s0 Run \f(CW\*(C`bldlevel DLL\-name\*(C'\fR to find this
info.
.SS "Centralized management of resources"
.IX Subsection "Centralized management of resources"
Since to call certain \s-1OS/2 API\s0 one needs to have a correctly initialized
\&\f(CW\*(C`Win\*(C'\fR subsystem, OS/2\-specific extensions may require getting \f(CW\*(C`HAB\*(C'\fRs and
\&\f(CW\*(C`HMQ\*(C'\fRs.  If an extension would do it on its own, another extension could
fail to initialize.
.PP
Perl provides a centralized management of these resources:
.ie n .IP """HAB""" 4
.el .IP "\f(CWHAB\fR" 4
.IX Item "HAB"
To get the \s-1HAB,\s0 the extension should call \f(CW\*(C`hab = perl_hab_GET()\*(C'\fR in C.  After
this call is performed, \f(CW\*(C`hab\*(C'\fR may be accessed as \f(CW\*(C`Perl_hab\*(C'\fR.  There is
no need to release the \s-1HAB\s0 after it is used.
.Sp
If by some reasons \fIperl.h\fR cannot be included, use
.Sp
.Vb 1
\&  extern int Perl_hab_GET(void);
.Ve
.Sp
instead.
.ie n .IP """HMQ""" 4
.el .IP "\f(CWHMQ\fR" 4
.IX Item "HMQ"
There are two cases:
.RS 4
.IP "\(bu" 4
the extension needs an \f(CW\*(C`HMQ\*(C'\fR only because some \s-1API\s0 will not work otherwise.
Use \f(CW\*(C`serve = 0\*(C'\fR below.
.IP "\(bu" 4
the extension needs an \f(CW\*(C`HMQ\*(C'\fR since it wants to engage in a \s-1PM\s0 event loop.
Use \f(CW\*(C`serve = 1\*(C'\fR below.
.RE
.RS 4
.Sp
To get an \f(CW\*(C`HMQ\*(C'\fR, the extension should call \f(CW\*(C`hmq = perl_hmq_GET(serve)\*(C'\fR in C.
After this call is performed, \f(CW\*(C`hmq\*(C'\fR may be accessed as \f(CW\*(C`Perl_hmq\*(C'\fR.
.Sp
To signal to Perl that \s-1HMQ\s0 is not needed any more, call
\&\f(CW\*(C`perl_hmq_UNSET(serve)\*(C'\fR.  Perl process will automatically morph/unmorph itself
into/from a \s-1PM\s0 process if \s-1HMQ\s0 is needed/not\-needed.  Perl will automatically
enable/disable \f(CW\*(C`WM_QUIT\*(C'\fR message during shutdown if the message queue is
served/not\-served.
.Sp
\&\fB\s-1NOTE\s0\fR.  If during a shutdown there is a message queue which did not disable
\&\s-1WM_QUIT,\s0 and which did not process the received \s-1WM_QUIT\s0 message, the
shutdown will be automatically cancelled.  Do not call \f(CWperl_hmq_GET(1)\fR
unless you are going to process messages on an orderly basis.
.RE
.IP "Treating errors reported by \s-1OS/2 API\s0" 4
.IX Item "Treating errors reported by OS/2 API"
There are two principal conventions (it is useful to call them \f(CW\*(C`Dos*\*(C'\fR
and \f(CW\*(C`Win*\*(C'\fR \- though this part of the function signature is not always
determined by the name of the \s-1API\s0) of reporting the error conditions
of \s-1OS/2 API. \s0 Most of \f(CW\*(C`Dos*\*(C'\fR APIs report the error code as the result
of the call (so 0 means success, and there are many types of errors).
Most of \f(CW\*(C`Win*\*(C'\fR \s-1API\s0 report success/fail via the result being
\&\f(CW\*(C`TRUE\*(C'\fR/\f(CW\*(C`FALSE\*(C'\fR; to find the reason for the failure one should call
\&\fIWinGetLastError()\fR \s-1API.\s0
.Sp
Some \f(CW\*(C`Win*\*(C'\fR entry points also overload a \*(L"meaningful\*(R" return value
with the error indicator; having a 0 return value indicates an error.
Yet some other \f(CW\*(C`Win*\*(C'\fR entry points overload things even more, and 0
return value may mean a successful call returning a valid value 0, as
well as an error condition; in the case of a 0 return value one should
call \fIWinGetLastError()\fR \s-1API\s0 to distinguish a successful call from a
failing one.
.Sp
By convention, all the calls to \s-1OS/2 API\s0 should indicate their
failures by resetting $^E.  All the Perl-accessible functions which
call \s-1OS/2 API\s0 may be broken into two classes: some \fIdie()\fRs when an \s-1API\s0
error is encountered, the other report the error via a false return
value (of course, this does not concern Perl-accessible functions
which \fIexpect\fR a failure of the \s-1OS/2 API\s0 call, having some workarounds
coded).
.Sp
Obviously, in the situation of the last type of the signature of an \s-1OS/2
API,\s0 it is must more convenient for the users if the failure is
indicated by \fIdie()\fRing: one does not need to check $^E to know that
something went wrong.  If, however, this solution is not desirable by
some reason, the code in question should reset $^E to 0 before making
this \s-1OS/2 API\s0 call, so that the caller of this Perl-accessible
function has a chance to distinguish a success\-but\-0\-return value from
a failure.  (One may return undef as an alternative way of reporting
an error.)
.Sp
The macros to simplify this type of error propagation are
.RS 4
.ie n .IP """CheckOSError(expr)""" 4
.el .IP "\f(CWCheckOSError(expr)\fR" 4
.IX Item "CheckOSError(expr)"
Returns true on error, sets $^E.  Expects \fIexpr()\fR be a call of
\&\f(CW\*(C`Dos*\*(C'\fR\-style \s-1API.\s0
.ie n .IP """CheckWinError(expr)""" 4
.el .IP "\f(CWCheckWinError(expr)\fR" 4
.IX Item "CheckWinError(expr)"
Returns true on error, sets $^E.  Expects \fIexpr()\fR be a call of
\&\f(CW\*(C`Win*\*(C'\fR\-style \s-1API.\s0
.ie n .IP """SaveWinError(expr)""" 4
.el .IP "\f(CWSaveWinError(expr)\fR" 4
.IX Item "SaveWinError(expr)"
Returns \f(CW\*(C`expr\*(C'\fR, sets $^E from \fIWinGetLastError()\fR if \f(CW\*(C`expr\*(C'\fR is false.
.ie n .IP """SaveCroakWinError(expr,die,name1,name2)""" 4
.el .IP "\f(CWSaveCroakWinError(expr,die,name1,name2)\fR" 4
.IX Item "SaveCroakWinError(expr,die,name1,name2)"
Returns \f(CW\*(C`expr\*(C'\fR, sets $^E from \fIWinGetLastError()\fR if \f(CW\*(C`expr\*(C'\fR is false,
and \fIdie()\fRs if \f(CW\*(C`die\*(C'\fR and $^E are true.  The message to die is the
concatenated strings \f(CW\*(C`name1\*(C'\fR and \f(CW\*(C`name2\*(C'\fR, separated by \f(CW": "\fR from
the contents of $^E.
.ie n .IP """WinError_2_Perl_rc""" 4
.el .IP "\f(CWWinError_2_Perl_rc\fR" 4
.IX Item "WinError_2_Perl_rc"
Sets \f(CW\*(C`Perl_rc\*(C'\fR to the return value of \fIWinGetLastError()\fR.
.ie n .IP """FillWinError""" 4
.el .IP "\f(CWFillWinError\fR" 4
.IX Item "FillWinError"
Sets \f(CW\*(C`Perl_rc\*(C'\fR to the return value of \fIWinGetLastError()\fR, and sets $^E
to the corresponding value.
.ie n .IP """FillOSError(rc)""" 4
.el .IP "\f(CWFillOSError(rc)\fR" 4
.IX Item "FillOSError(rc)"
Sets \f(CW\*(C`Perl_rc\*(C'\fR to \f(CW\*(C`rc\*(C'\fR, and sets $^E to the corresponding value.
.RE
.RS 4
.RE
.IP "Loading DLLs and ordinals in DLLs" 4
.IX Item "Loading DLLs and ordinals in DLLs"
Some DLLs are only present in some versions of \s-1OS/2,\s0 or in some
configurations of \s-1OS/2. \s0 Some exported entry points are present only
in DLLs shipped with some versions of \s-1OS/2. \s0 If these DLLs and entry
points were linked directly for a Perl executable/DLL or from a Perl
extensions, this binary would work only with the specified
versions/setups.  Even if these entry points were not needed, the
\&\fIload\fR of the executable (or \s-1DLL\s0) would fail.
.Sp
For example, many newer useful APIs are not present in \s-1OS/2\s0 v2; many
PM-related APIs require DLLs not available on floppy-boot setup.
.Sp
To make these calls fail \fIonly when the calls are executed\fR, one
should call these \s-1API\s0 via a dynamic linking \s-1API. \s0 There is a subsystem
in Perl to simplify such type of calls.  A large number of entry
points available for such linking is provided (see \f(CW\*(C`entries_ordinals\*(C'\fR
\&\- and also \f(CW\*(C`PMWIN_entries\*(C'\fR \- in \fIos2ish.h\fR).  These ordinals can be
accessed via the APIs:
.Sp
.Vb 6
\&  CallORD(), DeclFuncByORD(), DeclVoidFuncByORD(),
\&  DeclOSFuncByORD(), DeclWinFuncByORD(), AssignFuncPByORD(),
\&  DeclWinFuncByORD_CACHE(), DeclWinFuncByORD_CACHE_survive(),
\&  DeclWinFuncByORD_CACHE_resetError_survive(),
\&  DeclWinFunc_CACHE(), DeclWinFunc_CACHE_resetError(),
\&  DeclWinFunc_CACHE_survive(), DeclWinFunc_CACHE_resetError_survive()
.Ve
.Sp
See the header files and the C code in the supplied OS/2\-related
modules for the details on usage of these functions.
.Sp
Some of these functions also combine dynaloading semantic with the
error-propagation semantic discussed above.
.SH "Perl flavors"
.IX Header "Perl flavors"
Because of idiosyncrasies of \s-1OS/2\s0 one cannot have all the eggs in the
same basket (though \s-1EMX\s0 environment tries hard to overcome this
limitations, so the situation may somehow improve). There are 4
executables for Perl provided by the distribution:
.SS "\fIperl.exe\fP"
.IX Subsection "perl.exe"
The main workhorse. This is a chimera executable: it is compiled as an
\&\f(CW\*(C`a.out\*(C'\fR\-style executable, but is linked with \f(CW\*(C`omf\*(C'\fR\-style dynamic
library \fIperl.dll\fR, and with dynamic \s-1CRT DLL.\s0 This executable is a
\&\s-1VIO\s0 application.
.PP
It can load perl dynamic extensions, and it can \fIfork()\fR.
.PP
\&\fBNote.\fR Keep in mind that \fIfork()\fR is needed to open a pipe to yourself.
.SS "\fIperl_.exe\fP"
.IX Subsection "perl_.exe"
This is a statically linked \f(CW\*(C`a.out\*(C'\fR\-style executable. It cannot
load dynamic Perl extensions. The executable supplied in binary
distributions has a lot of extensions prebuilt, thus the above restriction is 
important only if you use custom-built extensions. This executable is a \s-1VIO\s0
application.
.PP
\&\fIThis is the only executable with does not require \s-1OS/2.\s0\fR The
friends locked into \f(CW\*(C`M$\*(C'\fR world would appreciate the fact that this
executable runs under \s-1DOS,\s0 Win0.3*, Win0.95 and WinNT with an
appropriate extender. See \*(L"Other OSes\*(R".
.SS "\fIperl_\|_.exe\fP"
.IX Subsection "perl__.exe"
This is the same executable as \fIperl_\|_\|_.exe\fR, but it is a \s-1PM\s0
application.
.PP
\&\fBNote.\fR Usually (unless explicitly redirected during the startup)
\&\s-1STDIN, STDERR,\s0 and \s-1STDOUT\s0 of a \s-1PM\s0
application are redirected to \fInul\fR. However, it is possible to \fIsee\fR
them if you start \f(CW\*(C`perl_\|_.exe\*(C'\fR from a \s-1PM\s0 program which emulates a
console window, like \fIShell mode\fR of Emacs or \s-1EPM.\s0 Thus it \fIis
possible\fR to use Perl debugger (see perldebug) to debug your \s-1PM\s0
application (but beware of the message loop lockups \- this will not
work if you have a message queue to serve, unless you hook the serving
into the \fIgetc()\fR function of the debugger).
.PP
Another way to see the output of a \s-1PM\s0 program is to run it as
.PP
.Vb 1
\&  pm_prog args 2>&1 | cat \-
.Ve
.PP
with a shell \fIdifferent\fR from \fIcmd.exe\fR, so that it does not create
a link between a \s-1VIO\s0 session and the session of \f(CW\*(C`pm_porg\*(C'\fR.  (Such a link
closes the \s-1VIO\s0 window.)  E.g., this works with \fIsh.exe\fR \- or with Perl!
.PP
.Vb 2
\&  open P, \*(Aqpm_prog args 2>&1 |\*(Aq or die;
\&  print while <P>;
.Ve
.PP
The flavor \fIperl_\|_.exe\fR is required if you want to start your program without
a \s-1VIO\s0 window present, but not \f(CW\*(C`detach\*(C'\fRed (run \f(CW\*(C`help detach\*(C'\fR for more info).
Very useful for extensions which use \s-1PM,\s0 like \f(CW\*(C`Perl/Tk\*(C'\fR or \f(CW\*(C`OpenGL\*(C'\fR.
.PP
Note also that the differences between \s-1PM\s0 and \s-1VIO\s0 executables are only
in the \fIdefault\fR behaviour.  One can start \fIany\fR executable in
\&\fIany\fR kind of session by using the arguments \f(CW\*(C`/fs\*(C'\fR, \f(CW\*(C`/pm\*(C'\fR or
\&\f(CW\*(C`/win\*(C'\fR switches of the command \f(CW\*(C`start\*(C'\fR (of \fI\s-1CMD.EXE\s0\fR or a similar
shell).  Alternatively, one can use the numeric first argument of the
\&\f(CW\*(C`system\*(C'\fR Perl function (see OS2::Process).
.SS "\fIperl_\|_\|_.exe\fP"
.IX Subsection "perl___.exe"
This is an \f(CW\*(C`omf\*(C'\fR\-style executable which is dynamically linked to
\&\fIperl.dll\fR and \s-1CRT DLL. I\s0 know no advantages of this executable
over \f(CW\*(C`perl.exe\*(C'\fR, but it cannot \fIfork()\fR at all. Well, one advantage is
that the build process is not so convoluted as with \f(CW\*(C`perl.exe\*(C'\fR.
.PP
It is a \s-1VIO\s0 application.
.SS "Why strange names?"
.IX Subsection "Why strange names?"
Since Perl processes the \f(CW\*(C`#!\*(C'\fR\-line (cf. 
\&\*(L"\s-1DESCRIPTION\*(R"\s0 in perlrun, \*(L"Command Switches\*(R" in perlrun,
\&\*(L"No Perl script found in input\*(R" in perldiag), it should know when a
program \fIis a Perl\fR. There is some naming convention which allows
Perl to distinguish correct lines from wrong ones. The above names are
almost the only names allowed by this convention which do not contain
digits (which have absolutely different semantics).
.SS "Why dynamic linking?"
.IX Subsection "Why dynamic linking?"
Well, having several executables dynamically linked to the same huge
library has its advantages, but this would not substantiate the
additional work to make it compile. The reason is the complicated-to-developers
but very quick and convenient-to-users \*(L"hard\*(R" dynamic linking used by \s-1OS/2.\s0
.PP
There are two distinctive features of the dyna-linking model of \s-1OS/2:\s0
first, all the references to external functions are resolved at the compile time;
second, there is no runtime fixup of the DLLs after they are loaded into memory.
The first feature is an enormous advantage over other models: it avoids
conflicts when several DLLs used by an application export entries with
the same name.  In such cases \*(L"other\*(R" models of dyna-linking just choose
between these two entry points using some random criterion \- with predictable
disasters as results.  But it is the second feature which requires the build
of \fIperl.dll\fR.
.PP
The address tables of DLLs are patched only once, when they are
loaded. The addresses of the entry points into DLLs are guaranteed to be
the same for all the programs which use the same \s-1DLL. \s0 This removes the
runtime fixup \- once \s-1DLL\s0 is loaded, its code is read-only.
.PP
While this allows some (significant?) performance advantages, this makes life
much harder for developers, since the above scheme makes it impossible
for a \s-1DLL\s0 to be \*(L"linked\*(R" to a symbol in the \fI.EXE\fR file.  Indeed, this
would need a \s-1DLL\s0 to have different relocations tables for the
(different) executables which use this \s-1DLL.\s0
.PP
However, a dynamically loaded Perl extension is forced to use some symbols
from the perl
executable, e.g., to know how to find the arguments to the functions:
the arguments live on the perl
internal evaluation stack. The solution is to put the main code of
the interpreter into a \s-1DLL,\s0 and make the \fI.EXE\fR file which just loads
this \s-1DLL\s0 into memory and supplies command-arguments.  The extension \s-1DLL\s0
cannot link to symbols in \fI.EXE\fR, but it has no problem linking
to symbols in the \fI.DLL\fR.
.PP
This \fIgreatly\fR increases the load time for the application (as well as
complexity of the compilation). Since interpreter is in a \s-1DLL,\s0
the C \s-1RTL\s0 is basically forced to reside in a \s-1DLL\s0 as well (otherwise
extensions would not be able to use \s-1CRT\s0).  There are some advantages if
you use different flavors of perl, such as running \fIperl.exe\fR and
\&\fIperl_\|_.exe\fR simultaneously: they share the memory of \fIperl.dll\fR.
.PP
\&\fB\s-1NOTE\s0\fR.  There is one additional effect which makes DLLs more wasteful:
DLLs are loaded in the shared memory region, which is a scarse resource
given the 512M barrier of the \*(L"standard\*(R" \s-1OS/2\s0 virtual memory.  The code of
\&\fI.EXE\fR files is also shared by all the processes which use the particular
\&\fI.EXE\fR, but they are \*(L"shared in the private address space of the process\*(R";
this is possible because the address at which different sections
of the \fI.EXE\fR file are loaded is decided at compile-time, thus all the
processes have these sections loaded at same addresses, and no fixup
of internal links inside the \fI.EXE\fR is needed.
.PP
Since DLLs may be loaded at run time, to have the same mechanism for DLLs
one needs to have the address range of \fIany of the loaded\fR DLLs in the
system to be available \fIin all the processes\fR which did not load a particular
\&\s-1DLL\s0 yet.  This is why the DLLs are mapped to the shared memory region.
.SS "Why chimera build?"
.IX Subsection "Why chimera build?"
Current \s-1EMX\s0 environment does not allow DLLs compiled using Unixish
\&\f(CW\*(C`a.out\*(C'\fR format to export symbols for data (or at least some types of
data). This forces \f(CW\*(C`omf\*(C'\fR\-style compile of \fIperl.dll\fR.
.PP
Current \s-1EMX\s0 environment does not allow \fI.EXE\fR files compiled in
\&\f(CW\*(C`omf\*(C'\fR format to \fIfork()\fR. \fIfork()\fR is needed for exactly three Perl
operations:
.IP "\(bu" 4
explicit \fIfork()\fR in the script,
.IP "\(bu" 4
\&\f(CW\*(C`open FH, "|\-"\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`open FH, "\-|"\*(C'\fR, in other words, opening pipes to itself.
.PP
While these operations are not questions of life and death, they are
needed for a lot of
useful scripts. This forces \f(CW\*(C`a.out\*(C'\fR\-style compile of
\&\fIperl.exe\fR.
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
Here we list environment variables with are either \s-1OS/2\-\s0 and \s-1DOS\-\s0 and
Win*\-specific, or are more important under \s-1OS/2\s0 than under other OSes.
.ie n .SS """PERLLIB_PREFIX"""
.el .SS "\f(CWPERLLIB_PREFIX\fP"
.IX Subsection "PERLLIB_PREFIX"
Specific for \s-1EMX\s0 port. Should have the form
.PP
.Vb 1
\&  path1;path2
.Ve
.PP
or
.PP
.Vb 1
\&  path1 path2
.Ve
.PP
If the beginning of some prebuilt path matches \fIpath1\fR, it is
substituted with \fIpath2\fR.
.PP
Should be used if the perl library is moved from the default
location in preference to \f(CW\*(C`PERL(5)LIB\*(C'\fR, since this would not leave wrong
entries in \f(CW@INC\fR.  For example, if the compiled version of perl looks for \f(CW@INC\fR
in \fIf:/perllib/lib\fR, and you want to install the library in
\&\fIh:/opt/gnu\fR, do
.PP
.Vb 1
\&  set PERLLIB_PREFIX=f:/perllib/lib;h:/opt/gnu
.Ve
.PP
This will cause Perl with the prebuilt \f(CW@INC\fR of
.PP
.Vb 5
\&  f:/perllib/lib/5.00553/os2
\&  f:/perllib/lib/5.00553
\&  f:/perllib/lib/site_perl/5.00553/os2
\&  f:/perllib/lib/site_perl/5.00553
\&  .
.Ve
.PP
to use the following \f(CW@INC:\fR
.PP
.Vb 5
\&  h:/opt/gnu/5.00553/os2
\&  h:/opt/gnu/5.00553
\&  h:/opt/gnu/site_perl/5.00553/os2
\&  h:/opt/gnu/site_perl/5.00553
\&  .
.Ve
.ie n .SS """PERL_BADLANG"""
.el .SS "\f(CWPERL_BADLANG\fP"
.IX Subsection "PERL_BADLANG"
If 0, perl ignores \fIsetlocale()\fR failing. May be useful with some
strange \fIlocale\fRs.
.ie n .SS """PERL_BADFREE"""
.el .SS "\f(CWPERL_BADFREE\fP"
.IX Subsection "PERL_BADFREE"
If 0, perl would not warn of in case of unwarranted \fIfree()\fR. With older
perls this might be
useful in conjunction with the module DB_File, which was buggy when
dynamically linked and OMF-built.
.PP
Should not be set with newer Perls, since this may hide some \fIreal\fR problems.
.ie n .SS """PERL_SH_DIR"""
.el .SS "\f(CWPERL_SH_DIR\fP"
.IX Subsection "PERL_SH_DIR"
Specific for \s-1EMX\s0 port. Gives the directory part of the location for
\&\fIsh.exe\fR.
.ie n .SS """USE_PERL_FLOCK"""
.el .SS "\f(CWUSE_PERL_FLOCK\fP"
.IX Subsection "USE_PERL_FLOCK"
Specific for \s-1EMX\s0 port. Since \fIflock\fR\|(3) is present in \s-1EMX,\s0 but is not 
functional, it is emulated by perl.  To disable the emulations, set 
environment variable \f(CW\*(C`USE_PERL_FLOCK=0\*(C'\fR.
.ie n .SS """TMP"" or ""TEMP"""
.el .SS "\f(CWTMP\fP or \f(CWTEMP\fP"
.IX Subsection "TMP or TEMP"
Specific for \s-1EMX\s0 port. Used as storage place for temporary files.
.SH "Evolution"
.IX Header "Evolution"
Here we list major changes which could make you by surprise.
.SS "Text-mode filehandles"
.IX Subsection "Text-mode filehandles"
Starting from version 5.8, Perl uses a builtin translation layer for
text-mode files.  This replaces the efficient well-tested \s-1EMX\s0 layer by
some code which should be best characterized as a \*(L"quick hack\*(R".
.PP
In addition to possible bugs and an inability to follow changes to the
translation policy with off/on switches of \s-1TERMIO\s0 translation, this
introduces a serious incompatible change: before \fIsysread()\fR on
text-mode filehandles would go through the translation layer, now it
would not.
.SS "Priorities"
.IX Subsection "Priorities"
\&\f(CW\*(C`setpriority\*(C'\fR and \f(CW\*(C`getpriority\*(C'\fR are not compatible with earlier
ports by Andreas Kaiser. See \f(CW"setpriority, getpriority"\fR.
.SS "\s-1DLL\s0 name mangling: pre 5.6.2"
.IX Subsection "DLL name mangling: pre 5.6.2"
With the release 5.003_01 the dynamically loadable libraries
should be rebuilt when a different version of Perl is compiled. In particular,
DLLs (including \fIperl.dll\fR) are now created with the names
which contain a checksum, thus allowing workaround for \s-1OS/2\s0 scheme of
caching DLLs.
.PP
It may be possible to code a simple workaround which would
.IP "\(bu" 4
find the old DLLs looking through the old \f(CW@INC\fR;
.IP "\(bu" 4
mangle the names according to the scheme of new perl and copy the DLLs to
these names;
.IP "\(bu" 4
edit the internal \f(CW\*(C`LX\*(C'\fR tables of \s-1DLL\s0 to reflect the change of the name
(probably not needed for Perl extension DLLs, since the internally coded names
are not used for \*(L"specific\*(R" DLLs, they used only for \*(L"global\*(R" DLLs).
.IP "\(bu" 4
edit the internal \f(CW\*(C`IMPORT\*(C'\fR tables and change the name of the \*(L"old\*(R"
\&\fIperl????.dll\fR to the \*(L"new\*(R" \fIperl????.dll\fR.
.SS "\s-1DLL\s0 name mangling: 5.6.2 and beyond"
.IX Subsection "DLL name mangling: 5.6.2 and beyond"
In fact mangling of \fIextension\fR DLLs was done due to misunderstanding
of the \s-1OS/2\s0 dynaloading model.  \s-1OS/2 \s0(effectively) maintains two
different tables of loaded \s-1DLL:\s0
.IP "Global DLLs" 4
.IX Item "Global DLLs"
those loaded by the base name from \f(CW\*(C`LIBPATH\*(C'\fR; including those
associated at link time;
.IP "specific DLLs" 4
.IX Item "specific DLLs"
loaded by the full name.
.PP
When resolving a request for a global \s-1DLL,\s0 the table of already-loaded
specific DLLs is (effectively) ignored; moreover, specific DLLs are
\&\fIalways\fR loaded from the prescribed path.
.PP
There is/was a minor twist which makes this scheme fragile: what to do
with DLLs loaded from
.ie n .IP """BEGINLIBPATH"" and ""ENDLIBPATH""" 4
.el .IP "\f(CWBEGINLIBPATH\fR and \f(CWENDLIBPATH\fR" 4
.IX Item "BEGINLIBPATH and ENDLIBPATH"
(which depend on the process)
.ie n .IP "\fI.\fR from ""LIBPATH""" 4
.el .IP "\fI.\fR from \f(CWLIBPATH\fR" 4
.IX Item ". from LIBPATH"
which \fIeffectively\fR depends on the process (although \f(CW\*(C`LIBPATH\*(C'\fR is the
same for all the processes).
.PP
Unless \f(CW\*(C`LIBPATHSTRICT\*(C'\fR is set to \f(CW\*(C`T\*(C'\fR (and the kernel is after
2000/09/01), such DLLs are considered to be global.  When loading a
global \s-1DLL\s0 it is first looked in the table of already-loaded global
DLLs.  Because of this the fact that one executable loaded a \s-1DLL\s0 from
\&\f(CW\*(C`BEGINLIBPATH\*(C'\fR and \f(CW\*(C`ENDLIBPATH\*(C'\fR, or \fI.\fR from \f(CW\*(C`LIBPATH\*(C'\fR may affect
\&\fIwhich\fR \s-1DLL\s0 is loaded when \fIanother\fR executable requests a \s-1DLL\s0 with
the same name.  \fIThis\fR is the reason for version-specific mangling of
the \s-1DLL\s0 name for perl \s-1DLL.\s0
.PP
Since the Perl extension DLLs are always loaded with the full path,
there is no need to mangle their names in a version-specific ways:
their directory already reflects the corresponding version of perl,
and \f(CW@INC\fR takes into account binary compatibility with older version.
Starting from \f(CW5.6.2\fR the name mangling scheme is fixed to be the
same as for Perl 5.005_53 (same as in a popular binary release).  Thus
new Perls will be able to \fIresolve the names\fR of old extension DLLs
if \f(CW@INC\fR allows finding their directories.
.PP
However, this still does not guarantee that these \s-1DLL\s0 may be loaded.
The reason is the mangling of the name of the \fIPerl \s-1DLL\s0\fR.  And since
the extension DLLs link with the Perl \s-1DLL,\s0 extension DLLs for older
versions would load an older Perl \s-1DLL,\s0 and would most probably
segfault (since the data in this \s-1DLL\s0 is not properly initialized).
.PP
There is a partial workaround (which can be made complete with newer
\&\s-1OS/2\s0 kernels): create a forwarder \s-1DLL\s0 with the same name as the \s-1DLL\s0 of
the older version of Perl, which forwards the entry points to the
newer Perl's \s-1DLL. \s0 Make this \s-1DLL\s0 accessible on (say) the \f(CW\*(C`BEGINLIBPATH\*(C'\fR of
the new Perl executable.  When the new executable accesses old Perl's
extension DLLs, they would request the old Perl's \s-1DLL\s0 by name, get the
forwarder instead, so effectively will link with the currently running
(new) Perl \s-1DLL.\s0
.PP
This may break in two ways:
.IP "\(bu" 4
Old perl executable is started when a new executable is running has
loaded an extension compiled for the old executable (ouph!).  In this
case the old executable will get a forwarder \s-1DLL\s0 instead of the old
perl \s-1DLL,\s0 so would link with the new perl \s-1DLL. \s0 While not directly
fatal, it will behave the same as new executable.  This beats the whole
purpose of explicitly starting an old executable.
.IP "\(bu" 4
A new executable loads an extension compiled for the old executable
when an old perl executable is running.  In this case the extension
will not pick up the forwarder \- with fatal results.
.PP
With support for \f(CW\*(C`LIBPATHSTRICT\*(C'\fR this may be circumvented \- unless
one of DLLs is started from \fI.\fR from \f(CW\*(C`LIBPATH\*(C'\fR (I do not know
whether \f(CW\*(C`LIBPATHSTRICT\*(C'\fR affects this case).
.PP
\&\fB\s-1REMARK\s0\fR.  Unless newer kernels allow \fI.\fR in \f(CW\*(C`BEGINLIBPATH\*(C'\fR (older
do not), this mess cannot be completely cleaned.  (It turns out that
as of the beginning of 2002, \fI.\fR is not allowed, but \fI.\e.\fR is \- and
it has the same effect.)
.PP
\&\fB\s-1REMARK\s0\fR.  \f(CW\*(C`LIBPATHSTRICT\*(C'\fR, \f(CW\*(C`BEGINLIBPATH\*(C'\fR and \f(CW\*(C`ENDLIBPATH\*(C'\fR are
not environment variables, although \fIcmd.exe\fR emulates them on \f(CW\*(C`SET
\&...\*(C'\fR lines.  From Perl they may be accessed by
Cwd::extLibpath and
Cwd::extLibpath_set.
.SS "\s-1DLL\s0 forwarder generation"
.IX Subsection "DLL forwarder generation"
Assume that the old \s-1DLL\s0 is named \fIperlE0AC.dll\fR (as is one for
5.005_53), and the new version is 5.6.1.  Create a file
\&\fIperl5shim.def\-leader\fR with
.PP
.Vb 5
\&  LIBRARY \*(AqperlE0AC\*(Aq INITINSTANCE TERMINSTANCE
\&  DESCRIPTION \*(Aq@#perl5\-porters@perl.org:5.006001#@ Perl module for 5.00553 \-> Perl 5.6.1 forwarder\*(Aq
\&  CODE LOADONCALL
\&  DATA LOADONCALL NONSHARED MULTIPLE
\&  EXPORTS
.Ve
.PP
modifying the versions/names as needed.  Run
.PP
.Vb 1
\& perl \-wnle "next if 0../EXPORTS/; print qq(  \e"$1\e") if /\e"(\ew+)\e"/" perl5.def >lst
.Ve
.PP
in the Perl build directory (to make the \s-1DLL\s0 smaller replace perl5.def
with the definition file for the older version of Perl if present).
.PP
.Vb 2
\& cat perl5shim.def\-leader lst >perl5shim.def
\& gcc \-Zomf \-Zdll \-o perlE0AC.dll perl5shim.def \-s \-llibperl
.Ve
.PP
(ignore multiple \f(CW\*(C`warning L4085\*(C'\fR).
.SS "Threading"
.IX Subsection "Threading"
As of release 5.003_01 perl is linked to multithreaded C \s-1RTL
DLL. \s0 If perl itself is not compiled multithread-enabled, so will not be perl's
\&\fImalloc()\fR. However, extensions may use multiple thread on their own
risk.
.PP
This was needed to compile \f(CW\*(C`Perl/Tk\*(C'\fR for XFree86\-OS/2 out-of-the-box, and
link with DLLs for other useful libraries, which typically are compiled
with \f(CW\*(C`\-Zmt \-Zcrtdll\*(C'\fR.
.SS "Calls to external programs"
.IX Subsection "Calls to external programs"
Due to a popular demand the perl external program calling has been
changed wrt Andreas Kaiser's port.  \fIIf\fR perl needs to call an
external program \fIvia shell\fR, the \fIf:/bin/sh.exe\fR will be called, or
whatever is the override, see \*(L"\s-1PERL_SH_DIR\*(R"\s0.
.PP
Thus means that you need to get some copy of a \fIsh.exe\fR as well (I
use one from pdksh). The path \fIF:/bin\fR above is set up automatically during
the build to a correct value on the builder machine, but is
overridable at runtime,
.PP
\&\fBReasons:\fR a consensus on \f(CW\*(C`perl5\-porters\*(C'\fR was that perl should use
one non-overridable shell per platform. The obvious choices for \s-1OS/2\s0
are \fIcmd.exe\fR and \fIsh.exe\fR. Having perl build itself would be impossible
with \fIcmd.exe\fR as a shell, thus I picked up \f(CW\*(C`sh.exe\*(C'\fR. This assures almost
100% compatibility with the scripts coming from *nix. As an added benefit 
this works as well under \s-1DOS\s0 if you use DOS-enabled port of pdksh 
(see \*(L"Prerequisites\*(R").
.PP
\&\fBDisadvantages:\fR currently \fIsh.exe\fR of pdksh calls external programs
via \fIfork()\fR/\fIexec()\fR, and there is \fIno\fR functioning \fIexec()\fR on
\&\s-1OS/2.\s0 \fIexec()\fR is emulated by \s-1EMX\s0 by an asynchronous call while the caller
waits for child completion (to pretend that the \f(CW\*(C`pid\*(C'\fR did not change). This
means that 1 \fIextra\fR copy of \fIsh.exe\fR is made active via \fIfork()\fR/\fIexec()\fR,
which may lead to some resources taken from the system (even if we do
not count extra work needed for \fIfork()\fRing).
.PP
Note that this a lesser issue now when we do not spawn \fIsh.exe\fR
unless needed (metachars found).
.PP
One can always start \fIcmd.exe\fR explicitly via
.PP
.Vb 1
\&  system \*(Aqcmd\*(Aq, \*(Aq/c\*(Aq, \*(Aqmycmd\*(Aq, \*(Aqarg1\*(Aq, \*(Aqarg2\*(Aq, ...
.Ve
.PP
If you need to use \fIcmd.exe\fR, and do not want to hand-edit thousands of your
scripts, the long-term solution proposed on p5\-p is to have a directive
.PP
.Vb 1
\&  use OS2::Cmd;
.Ve
.PP
which will override \fIsystem()\fR, \fIexec()\fR, \f(CW\*(C`\`\`\*(C'\fR, and
\&\f(CW\*(C`open(,\*(Aq...|\*(Aq)\*(C'\fR. With current perl you may override only \fIsystem()\fR,
\&\fIreadpipe()\fR \- the explicit version of \f(CW\*(C`\`\`\*(C'\fR, and maybe \fIexec()\fR. The code
will substitute the one-argument call to \fIsystem()\fR by
\&\f(CW\*(C`CORE::system(\*(Aqcmd.exe\*(Aq, \*(Aq/c\*(Aq, shift)\*(C'\fR.
.PP
If you have some working code for \f(CW\*(C`OS2::Cmd\*(C'\fR, please send it to me,
I will include it into distribution. I have no need for such a module, so
cannot test it.
.PP
For the details of the current situation with calling external programs,
see \*(L"Starting \s-1OS/2 \s0(and \s-1DOS\s0) programs under Perl\*(R".  Set us mention a couple
of features:
.IP "\(bu" 4
External scripts may be called by their basename.  Perl will try the same
extensions as when processing \fB\-S\fR command-line switch.
.IP "\(bu" 4
External scripts starting with \f(CW\*(C`#!\*(C'\fR or \f(CW\*(C`extproc \*(C'\fR will be executed directly,
without calling the shell, by calling the program specified on the rest of
the first line.
.SS "Memory allocation"
.IX Subsection "Memory allocation"
Perl uses its own \fImalloc()\fR under \s-1OS/2 \-\s0 interpreters are usually malloc-bound
for speed, but perl is not, since its malloc is lightning-fast.
Perl-memory-usage-tuned benchmarks show that Perl's malloc is 5 times quicker
than \s-1EMX\s0 one.  I do not have convincing data about memory footprint, but
a (pretty random) benchmark showed that Perl's one is 5% better.
.PP
Combination of perl's \fImalloc()\fR and rigid \s-1DLL\s0 name resolution creates
a special problem with library functions which expect their return value to
be \fIfree()\fRd by system's \fIfree()\fR. To facilitate extensions which need to call 
such functions, system memory-allocation functions are still available with
the prefix \f(CW\*(C`emx_\*(C'\fR added. (Currently only \s-1DLL\s0 perl has this, it should 
propagate to \fIperl_.exe\fR shortly.)
.SS "Threads"
.IX Subsection "Threads"
One can build perl with thread support enabled by providing \f(CW\*(C`\-D usethreads\*(C'\fR
option to \fIConfigure\fR.  Currently \s-1OS/2\s0 support of threads is very 
preliminary.
.PP
Most notable problems:
.ie n .IP """COND_WAIT""" 4
.el .IP "\f(CWCOND_WAIT\fR" 4
.IX Item "COND_WAIT"
may have a race condition (but probably does not due to edge-triggered
nature of \s-1OS/2\s0 Event semaphores).  (Needs a reimplementation (in terms of chaining
waiting threads, with the linked list stored in per-thread structure?)?)
.IP "\fIos2.c\fR" 4
.IX Item "os2.c"
has a couple of static variables used in OS/2\-specific functions.  (Need to be
moved to per-thread structure, or serialized?)
.PP
Note that these problems should not discourage experimenting, since they
have a low probability of affecting small programs.
.SH "BUGS"
.IX Header "BUGS"
This description is not updated often (since 5.6.1?), see \fI./os2/Changes\fR
for more info.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ilya Zakharevich, cpan@ilyaz.org
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1).
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 1023:" 4
.IX Item "Around line 1023:"
Expected text after =item, not a number
                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlos390.1                                  0100644 0001750 0001750 00000052016 12566207443 022505  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLOS390 1"
.TH PERLOS390 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlos390 \- building and installing Perl for OS/390 and z/OS
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This document will help you Configure, build, test and install Perl
on \s-1OS/390 \s0(aka z/OS) Unix System Services.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a fully ported Perl for \s-1OS/390\s0 Version 2 Release 3, 5, 6, 7,
8, and 9.  It may work on other versions or releases, but those are
the ones we've tested it on.
.PP
You may need to carry out some system configuration tasks before
running the Configure script for Perl.
.SS "Tools"
.IX Subsection "Tools"
The z/OS Unix Tools and Toys list may prove helpful and contains links
to ports of much of the software helpful for building Perl.
http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html
.SS "Unpacking Perl distribution on \s-1OS/390\s0"
.IX Subsection "Unpacking Perl distribution on OS/390"
If using ftp remember to transfer the distribution in binary format.
.PP
Gunzip/gzip for \s-1OS/390\s0 is discussed at:
.PP
.Vb 1
\&  http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1ty1.html
.Ve
.PP
to extract an \s-1ASCII\s0 tar archive on \s-1OS/390,\s0 try this:
.PP
.Vb 1
\&   pax \-o to=IBM\-1047,from=ISO8859\-1 \-r < latest.tar
.Ve
.PP
or
.PP
.Vb 1
\&   zcat latest.tar.Z | pax \-o to=IBM\-1047,from=ISO8859\-1 \-r
.Ve
.PP
If you get lots of errors of the form
.PP
.Vb 1
\&  tar: FSUM7171 ...: cannot set uid/gid: EDC5139I Operation not permitted.
.Ve
.PP
you didn't read the above and tried to use tar instead of pax, you'll
first have to remove the (now corrupt) perl directory
.PP
.Vb 1
\&   rm \-rf perl\-...
.Ve
.PP
and then use pax.
.SS "Setup and utilities for Perl on \s-1OS/390\s0"
.IX Subsection "Setup and utilities for Perl on OS/390"
Be sure that your yacc installation is in place including any necessary
parser template files. If you have not already done so then be sure to:
.PP
.Vb 1
\&  cp /samples/yyparse.c /etc
.Ve
.PP
This may also be a good time to ensure that your /etc/protocol file
and either your /etc/resolv.conf or /etc/hosts files are in place.
The \s-1IBM\s0 document that described such \s-1USS\s0 system setup issues was
\&\s-1SC28\-1890\-07 \*(L"OS/390 UNIX\s0 System Services Planning\*(R", in particular
Chapter 6 on customizing the \s-1OE\s0 shell.
.PP
\&\s-1GNU\s0 make for \s-1OS/390,\s0 which is recommended for the build of perl (as
well as building \s-1CPAN\s0 modules and extensions), is available from the
\&\*(L"Tools\*(R".
.PP
Some people have reported encountering \*(L"Out of memory!\*(R" errors while
trying to build Perl using \s-1GNU\s0 make binaries.  If you encounter such
trouble then try to download the source code kit and build \s-1GNU\s0 make
from source to eliminate any such trouble.  You might also find \s-1GNU\s0 make
(as well as Perl and Apache) in the red\-piece/book \*(L"Open Source Software
for \s-1OS/390 UNIX\*(R", SG24\-5944\-00\s0 from \s-1IBM.\s0
.PP
If instead of the recommended \s-1GNU\s0 make you would like to use the system
supplied make program then be sure to install the default rules file
properly via the shell command:
.PP
.Vb 1
\&    cp /samples/startup.mk /etc
.Ve
.PP
and be sure to also set the environment variable _C89_CCMODE=1 (exporting
_C89_CCMODE=1 is also a good idea for users of \s-1GNU\s0 make).
.PP
You might also want to have \s-1GNU\s0 groff for \s-1OS/390\s0 installed before
running the \*(L"make install\*(R" step for Perl.
.PP
There is a syntax error in the /usr/include/sys/socket.h header file
that \s-1IBM\s0 supplies with \s-1USS V2R7, V2R8,\s0 and possibly V2R9.  The problem with
the header file is that near the definition of the \s-1SO_REUSEPORT\s0 constant
there is a spurious extra '/' character outside of a comment like so:
.PP
.Vb 2
\& #define SO_REUSEPORT    0x0200    /* allow local address & port
\&                                      reuse */                    /
.Ve
.PP
You could edit that header yourself to remove that last '/', or you might
note that Language Environment (\s-1LE\s0) \s-1APAR PQ39997\s0 describes the problem
and \s-1PTF\s0's \s-1UQ46272\s0 and \s-1UQ46271\s0 are the (R8 at least) fixes and apply them.
If left unattended that syntax error will turn up as an inability for Perl
to build its \*(L"Socket\*(R" extension.
.PP
For successful testing you may need to turn on the sticky bit for your
world readable /tmp directory if you have not already done so (see man chmod).
.SS "Configure Perl on \s-1OS/390\s0"
.IX Subsection "Configure Perl on OS/390"
Once you've unpacked the distribution, run \*(L"sh Configure\*(R" (see \s-1INSTALL\s0
for a full discussion of the Configure options).  There is a \*(L"hints\*(R" file
for os390 that specifies the correct values for most things.  Some things
to watch out for include:
.IP "\(bu" 4
A message of the form:
.Sp
.Vb 2
\& (I see you are using the Korn shell.  Some ksh\*(Aqs blow up on Configure,
\& mainly on older exotic systems.  If yours does, try the Bourne shell instead.)
.Ve
.Sp
is nothing to worry about at all.
.IP "\(bu" 4
Some of the parser default template files in /samples are needed in /etc.
In particular be sure that you at least copy /samples/yyparse.c to /etc
before running Perl's Configure.  This step ensures successful extraction
of \s-1EBCDIC\s0 versions of parser files such as perly.c, perly.h, and x2p/a2p.c.
This has to be done before running Configure the first time.  If you failed
to do so then the easiest way to re-Configure Perl is to delete your
misconfigured build root and re-extract the source from the tar ball.
Then you must ensure that /etc/yyparse.c is properly in place before
attempting to re-run Configure.
.IP "\(bu" 4
This port will support dynamic loading, but it is not selected by
default.  If you would like to experiment with dynamic loading then
be sure to specify \-Dusedl in the arguments to the Configure script.
See the comments in hints/os390.sh for more information on dynamic loading.
If you build with dynamic loading then you will need to add the
\&\f(CW$archlibexp\fR/CORE directory to your \s-1LIBPATH\s0 environment variable in order
for perl to work.  See the config.sh file for the value of \f(CW$archlibexp\fR.
If in trying to use Perl you see an error message similar to:
.Sp
.Vb 2
\& CEE3501S The module libperl.dll was not found.
\&         From entry point _\|_dllstaticinit at compile unit offset +00000194 at
.Ve
.Sp
then your \s-1LIBPATH\s0 does not have the location of libperl.x and either
libperl.dll or libperl.so in it.  Add that directory to your \s-1LIBPATH\s0 and
proceed.
.IP "\(bu" 4
Do not turn on the compiler optimization flag \*(L"\-O\*(R".  There is
a bug in either the optimizer or perl that causes perl to
not work correctly when the optimizer is on.
.IP "\(bu" 4
Some of the configuration files in /etc used by the
networking APIs are either missing or have the wrong
names.  In particular, make sure that there's either
an /etc/resolv.conf or an /etc/hosts, so that
\&\fIgethostbyname()\fR works, and make sure that the file
/etc/proto has been renamed to /etc/protocol (\s-1NOT\s0
/etc/protocols, as used by other Unix systems).
You may have to look for things like \s-1HOSTNAME\s0 and \s-1DOMAINORIGIN\s0
in the \*(L"//'\s-1SYS1.TCPPARMS\s0(\s-1TCPDATA\s0)'\*(R" \s-1PDS\s0 member in order to
properly set up your /etc networking files.
.SS "Build, Test, Install Perl on \s-1OS/390\s0"
.IX Subsection "Build, Test, Install Perl on OS/390"
Simply put:
.PP
.Vb 3
\&    sh Configure
\&    make
\&    make test
.Ve
.PP
if everything looks ok (see the next section for test/IVP diagnosis) then:
.PP
.Vb 1
\&    make install
.Ve
.PP
this last step may or may not require UID=0 privileges depending
on how you answered the questions that Configure asked and whether
or not you have write access to the directories you specified.
.SS "Build Anomalies with Perl on \s-1OS/390\s0"
.IX Subsection "Build Anomalies with Perl on OS/390"
\&\*(L"Out of memory!\*(R" messages during the build of Perl are most often fixed
by re building the \s-1GNU\s0 make utility for \s-1OS/390\s0 from a source code kit.
.PP
Another memory limiting item to check is your \s-1MAXASSIZE\s0 parameter in your
\&'\s-1SYS1.PARMLIB\s0(BPXPRMxx)' data set (note too that as of V2R8 address space
limits can be set on a per user \s-1ID\s0 basis in the \s-1USS\s0 segment of a \s-1RACF\s0
profile).  People have reported successful builds of Perl with \s-1MAXASSIZE\s0
parameters as small as 503316480 (and it may be possible to build Perl
with a \s-1MAXASSIZE\s0 smaller than that).
.PP
Within \s-1USS\s0 your /etc/profile or \f(CW$HOME\fR/.profile may limit your ulimit
settings.  Check that the following command returns reasonable values:
.PP
.Vb 1
\&    ulimit \-a
.Ve
.PP
To conserve memory you should have your compiler modules loaded into the
Link Pack Area (\s-1LPA/ELPA\s0) rather than in a link list or step lib.
.PP
If the c89 compiler complains of syntax errors during the build of the
Socket extension then be sure to fix the syntax error in the system
header /usr/include/sys/socket.h.
.SS "Testing Anomalies with Perl on \s-1OS/390\s0"
.IX Subsection "Testing Anomalies with Perl on OS/390"
The \*(L"make test\*(R" step runs a Perl Verification Procedure, usually before
installation.  You might encounter \s-1STDERR\s0 messages even during a successful
run of \*(L"make test\*(R".  Here is a guide to some of the more commonly seen
anomalies:
.IP "\(bu" 4
A message of the form:
.Sp
.Vb 4
\& io/openpid...........CEE5210S The signal SIGHUP was received.
\& CEE5210S The signal SIGHUP was received.
\& CEE5210S The signal SIGHUP was received.
\& ok
.Ve
.Sp
indicates that the t/io/openpid.t test of Perl has passed but done so
with extraneous messages on stderr from \s-1CEE.\s0
.IP "\(bu" 4
A message of the form:
.Sp
.Vb 5
\& lib/ftmp\-security....File::Temp::_gettemp: Parent directory (/tmp/) is not safe
\& (sticky bit not set when world writable?) at lib/ftmp\-security.t line 100
\& File::Temp::_gettemp: Parent directory (/tmp/) is not safe (sticky bit not
\& set when world writable?) at lib/ftmp\-security.t line 100
\& ok
.Ve
.Sp
indicates a problem with the permissions on your /tmp directory within the \s-1HFS.\s0
To correct that problem issue the command:
.Sp
.Vb 1
\&     chmod a+t /tmp
.Ve
.Sp
from an account with write access to the directory entry for /tmp.
.IP "\(bu" 4
Out of Memory!
.Sp
Recent perl test suite is quite memory hungry. In addition to the comments
above on memory limitations it is also worth checking for _CEE_RUNOPTS
in your environment. Perl now has (in miniperlmain.c) a C #pragma
to set \s-1CEE\s0 run options, but the environment variable wins.
.Sp
The C code asks for:
.Sp
.Vb 1
\& #pragma runopts(HEAP(2M,500K,ANYWHERE,KEEP,8K,4K) STACK(,,ANY,) ALL31(ON))
.Ve
.Sp
The important parts of that are the second argument (the increment) to \s-1HEAP,\s0
and allowing the stack to be \*(L"Above the (16M) line\*(R". If the heap
increment is too small then when perl (for example loading unicode/Name.pl) tries
to create a \*(L"big\*(R" (400K+) string it cannot fit in a single segment
and you get \*(L"Out of Memory!\*(R" \- even if there is still plenty of memory
available.
.Sp
A related issue is use with perl's malloc. Perl's malloc uses \f(CW\*(C`sbrk()\*(C'\fR
to get memory, and \f(CW\*(C`sbrk()\*(C'\fR is limited to the first allocation so in this
case something like:
.Sp
.Vb 1
\&  HEAP(8M,500K,ANYWHERE,KEEP,8K,4K)
.Ve
.Sp
is needed to get through the test suite.
.SS "Installation Anomalies with Perl on \s-1OS/390\s0"
.IX Subsection "Installation Anomalies with Perl on OS/390"
The installman script will try to run on \s-1OS/390. \s0 There will be fewer errors
if you have a roff utility installed.  You can obtain \s-1GNU\s0 groff from the
Redbook \s-1SG24\-5944\-00\s0 ftp site.
.SS "Usage Hints for Perl on \s-1OS/390\s0"
.IX Subsection "Usage Hints for Perl on OS/390"
When using perl on \s-1OS/390\s0 please keep in mind that the \s-1EBCDIC\s0 and \s-1ASCII\s0
character sets are different.  See perlebcdic.pod for more on such character
set issues.  Perl builtin functions that may behave differently under
\&\s-1EBCDIC\s0 are also mentioned in the perlport.pod document.
.PP
Open Edition (\s-1UNIX\s0 System Services) from V2R8 onward does support
#!/path/to/perl script invocation.  There is a \s-1PTF\s0 available from
\&\s-1IBM\s0 for V2R7 that will allow shell/kernel support for #!.  \s-1USS\s0
releases prior to V2R7 did not support the #! means of script invocation.
If you are running V2R6 or earlier then see:
.PP
.Vb 1
\&    head \`whence perldoc\`
.Ve
.PP
for an example of how to use the \*(L"eval exec\*(R" trick to ask the shell to
have Perl run your scripts on those older releases of Unix System Services.
.PP
If you are having trouble with square brackets then consider switching your
rlogin or telnet client.  Try to avoid older 3270 emulators and \s-1ISHELL\s0 for
working with Perl on \s-1USS.\s0
.SS "Floating Point Anomalies with Perl on \s-1OS/390\s0"
.IX Subsection "Floating Point Anomalies with Perl on OS/390"
There appears to be a bug in the floating point implementation on S/390
systems such that calling \fIint()\fR on the product of a number and a small
magnitude number is not the same as calling \fIint()\fR on the quotient of
that number and a large magnitude number.  For example, in the following
Perl code:
.PP
.Vb 4
\&    my $x = 100000.0;
\&    my $y = int($x * 1e\-5) * 1e5; # \*(Aq0\*(Aq
\&    my $z = int($x / 1e+5) * 1e5;  # \*(Aq100000\*(Aq
\&    print "\e$y is $y and \e$z is $z\en"; # $y is 0 and $z is 100000
.Ve
.PP
Although one would expect the quantities \f(CW$y\fR and \f(CW$z\fR to be the same and equal
to 100000 they will differ and instead will be 0 and 100000 respectively.
.PP
The problem can be further examined in a roughly equivalent C program:
.PP
.Vb 10
\&    #include <stdio.h>
\&    #include <math.h>
\&    main()
\&    {
\&    double r1,r2;
\&    double x = 100000.0;
\&    double y = 0.0;
\&    double z = 0.0;
\&    x = 100000.0 * 1e\-5;
\&    r1 = modf (x,&y);
\&    x = 100000.0 / 1e+5;
\&    r2 = modf (x,&z);
\&    printf("y is %e and z is %e\en",y*1e5,z*1e5);
\&    /* y is 0.000000e+00 and z is 1.000000e+05 (with c89) */
\&    }
.Ve
.SS "Modules and Extensions for Perl on \s-1OS/390\s0"
.IX Subsection "Modules and Extensions for Perl on OS/390"
Pure pure (that is non xs) modules may be installed via the usual:
.PP
.Vb 4
\&    perl Makefile.PL
\&    make
\&    make test
\&    make install
.Ve
.PP
If you built perl with dynamic loading capability then that would also
be the way to build xs based extensions.  However, if you built perl with
the default static linking you can still build xs based extensions for \s-1OS/390\s0
but you will need to follow the instructions in ExtUtils::MakeMaker for
building statically linked perl binaries.  In the simplest configurations
building a static perl + xs extension boils down to:
.PP
.Vb 6
\&    perl Makefile.PL
\&    make
\&    make perl
\&    make test
\&    make install
\&    make \-f Makefile.aperl inst_perl MAP_TARGET=perl
.Ve
.PP
In most cases people have reported better results with \s-1GNU\s0 make rather
than the system's /bin/make program, whether for plain modules or for
xs based extensions.
.PP
If the make process encounters trouble with either compilation or
linking then try setting the _C89_CCMODE to 1.  Assuming sh is your
login shell then run:
.PP
.Vb 1
\&    export _C89_CCMODE=1
.Ve
.PP
If tcsh is your login shell then use the setenv command.
.SH "AUTHORS"
.IX Header "AUTHORS"
David Fiander and Peter Prymmer with thanks to Dennis Longnecker
and William Raffloer for valuable reports, \s-1LPAR\s0 and \s-1PTF\s0 feedback.
Thanks to Mike MacIsaac and Egon Terwedow for \s-1SG24\-5944\-00.\s0
Thanks to Ignasi Roca for pointing out the floating point problems.
Thanks to John Goodyear for dynamic loading help.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1INSTALL\s0, perlport, perlebcdic, ExtUtils::MakeMaker.
.PP
.Vb 1
\&    http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html
\&
\&    http://www.redbooks.ibm.com/redbooks/SG245944.html
\&
\&    http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1ty1.html#opensrc
\&
\&    http://www.xray.mpe.mpg.de/mailing\-lists/perl\-mvs/
\&
\&    http://publibz.boulder.ibm.com:80/cgi\-bin/bookmgr_OS390/BOOKS/ceea3030/
\&
\&    http://publibz.boulder.ibm.com:80/cgi\-bin/bookmgr_OS390/BOOKS/CBCUG030/
.Ve
.SS "Mailing list for Perl on \s-1OS/390\s0"
.IX Subsection "Mailing list for Perl on OS/390"
If you are interested in the z/OS (formerly known as \s-1OS/390\s0)
and POSIX-BC (\s-1BS2000\s0) ports of Perl then see the perl-mvs mailing list.
To subscribe, send an empty message to perl\-mvs\-subscribe@perl.org.
.PP
See also:
.PP
.Vb 1
\&    http://lists.perl.org/list/perl\-mvs.html
.Ve
.PP
There are web archives of the mailing list at:
.PP
.Vb 2
\&    http://www.xray.mpe.mpg.de/mailing\-lists/perl\-mvs/
\&    http://archive.develooper.com/perl\-mvs@perl.org/
.Ve
.SH "HISTORY"
.IX Header "HISTORY"
This document was originally written by David Fiander for the 5.005
release of Perl.
.PP
This document was podified for the 5.005_03 release of Perl 11 March 1999.
.PP
Updated 28 November 2001 for broken URLs.
.PP
Updated 12 November 2000 for the 5.7.1 release of Perl.
.PP
Updated 15 January 2001 for the 5.7.1 release of Perl.
.PP
Updated 24 January 2001 to mention dynamic loading.
.PP
Updated 12 March 2001 to mention //'\s-1SYS1.TCPPARMS\s0(\s-1TCPDATA\s0)'.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlos3905.16.1                              0100644 0001750 0001750 00000051557 12566207422 023025  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLOS390 1"
.TH PERLOS390 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlos390 \- building and installing Perl for OS/390 and z/OS
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This document will help you Configure, build, test and install Perl
on \s-1OS/390\s0 (aka z/OS) Unix System Services.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a fully ported Perl for \s-1OS/390\s0 Version 2 Release 3, 5, 6, 7,
8, and 9.  It may work on other versions or releases, but those are
the ones we've tested it on.
.PP
You may need to carry out some system configuration tasks before
running the Configure script for Perl.
.SS "Tools"
.IX Subsection "Tools"
The z/OS Unix Tools and Toys list may prove helpful and contains links
to ports of much of the software helpful for building Perl.
http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html
.SS "Unpacking Perl distribution on \s-1OS/390\s0"
.IX Subsection "Unpacking Perl distribution on OS/390"
If using ftp remember to transfer the distribution in binary format.
.PP
Gunzip/gzip for \s-1OS/390\s0 is discussed at:
.PP
.Vb 1
\&  http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1ty1.html
.Ve
.PP
to extract an \s-1ASCII\s0 tar archive on \s-1OS/390\s0, try this:
.PP
.Vb 1
\&   pax \-o to=IBM\-1047,from=ISO8859\-1 \-r < latest.tar
.Ve
.PP
or
.PP
.Vb 1
\&   zcat latest.tar.Z | pax \-o to=IBM\-1047,from=ISO8859\-1 \-r
.Ve
.PP
If you get lots of errors of the form
.PP
.Vb 1
\&  tar: FSUM7171 ...: cannot set uid/gid: EDC5139I Operation not permitted.
.Ve
.PP
you didn't read the above and tried to use tar instead of pax, you'll
first have to remove the (now corrupt) perl directory
.PP
.Vb 1
\&   rm \-rf perl\-...
.Ve
.PP
and then use pax.
.SS "Setup and utilities for Perl on \s-1OS/390\s0"
.IX Subsection "Setup and utilities for Perl on OS/390"
Be sure that your yacc installation is in place including any necessary
parser template files. If you have not already done so then be sure to:
.PP
.Vb 1
\&  cp /samples/yyparse.c /etc
.Ve
.PP
This may also be a good time to ensure that your /etc/protocol file
and either your /etc/resolv.conf or /etc/hosts files are in place.
The \s-1IBM\s0 document that described such \s-1USS\s0 system setup issues was
\&\s-1SC28\-1890\-07\s0 \*(L"\s-1OS/390\s0 \s-1UNIX\s0 System Services Planning\*(R", in particular
Chapter 6 on customizing the \s-1OE\s0 shell.
.PP
\&\s-1GNU\s0 make for \s-1OS/390\s0, which is recommended for the build of perl (as
well as building \s-1CPAN\s0 modules and extensions), is available from the
\&\*(L"Tools\*(R".
.PP
Some people have reported encountering \*(L"Out of memory!\*(R" errors while
trying to build Perl using \s-1GNU\s0 make binaries.  If you encounter such
trouble then try to download the source code kit and build \s-1GNU\s0 make
from source to eliminate any such trouble.  You might also find \s-1GNU\s0 make
(as well as Perl and Apache) in the red\-piece/book \*(L"Open Source Software
for \s-1OS/390\s0 \s-1UNIX\s0\*(R", \s-1SG24\-5944\-00\s0 from \s-1IBM\s0.
.PP
If instead of the recommended \s-1GNU\s0 make you would like to use the system
supplied make program then be sure to install the default rules file
properly via the shell command:
.PP
.Vb 1
\&    cp /samples/startup.mk /etc
.Ve
.PP
and be sure to also set the environment variable _C89_CCMODE=1 (exporting
_C89_CCMODE=1 is also a good idea for users of \s-1GNU\s0 make).
.PP
You might also want to have \s-1GNU\s0 groff for \s-1OS/390\s0 installed before
running the \*(L"make install\*(R" step for Perl.
.PP
There is a syntax error in the /usr/include/sys/socket.h header file
that \s-1IBM\s0 supplies with \s-1USS\s0 V2R7, V2R8, and possibly V2R9.  The problem with
the header file is that near the definition of the \s-1SO_REUSEPORT\s0 constant
there is a spurious extra '/' character outside of a comment like so:
.PP
.Vb 2
\& #define SO_REUSEPORT    0x0200    /* allow local address & port
\&                                      reuse */                    /
.Ve
.PP
You could edit that header yourself to remove that last '/', or you might
note that Language Environment (\s-1LE\s0) \s-1APAR\s0 \s-1PQ39997\s0 describes the problem
and \s-1PTF\s0's \s-1UQ46272\s0 and \s-1UQ46271\s0 are the (R8 at least) fixes and apply them.
If left unattended that syntax error will turn up as an inability for Perl
to build its \*(L"Socket\*(R" extension.
.PP
For successful testing you may need to turn on the sticky bit for your
world readable /tmp directory if you have not already done so (see man chmod).
.SS "Configure Perl on \s-1OS/390\s0"
.IX Subsection "Configure Perl on OS/390"
Once you've unpacked the distribution, run \*(L"sh Configure\*(R" (see \s-1INSTALL\s0
for a full discussion of the Configure options).  There is a \*(L"hints\*(R" file
for os390 that specifies the correct values for most things.  Some things
to watch out for include:
.IP "\(bu" 4
A message of the form:
.Sp
.Vb 2
\& (I see you are using the Korn shell.  Some ksh\*(Aqs blow up on Configure,
\& mainly on older exotic systems.  If yours does, try the Bourne shell instead.)
.Ve
.Sp
is nothing to worry about at all.
.IP "\(bu" 4
Some of the parser default template files in /samples are needed in /etc.
In particular be sure that you at least copy /samples/yyparse.c to /etc
before running Perl's Configure.  This step ensures successful extraction
of \s-1EBCDIC\s0 versions of parser files such as perly.c, perly.h, and x2p/a2p.c.
This has to be done before running Configure the first time.  If you failed
to do so then the easiest way to re-Configure Perl is to delete your
misconfigured build root and re-extract the source from the tar ball.
Then you must ensure that /etc/yyparse.c is properly in place before
attempting to re-run Configure.
.IP "\(bu" 4
This port will support dynamic loading, but it is not selected by
default.  If you would like to experiment with dynamic loading then
be sure to specify \-Dusedl in the arguments to the Configure script.
See the comments in hints/os390.sh for more information on dynamic loading.
If you build with dynamic loading then you will need to add the
\&\f(CW$archlibexp\fR/CORE directory to your \s-1LIBPATH\s0 environment variable in order
for perl to work.  See the config.sh file for the value of \f(CW$archlibexp\fR.
If in trying to use Perl you see an error message similar to:
.Sp
.Vb 2
\& CEE3501S The module libperl.dll was not found.
\&         From entry point _\|_dllstaticinit at compile unit offset +00000194 at
.Ve
.Sp
then your \s-1LIBPATH\s0 does not have the location of libperl.x and either
libperl.dll or libperl.so in it.  Add that directory to your \s-1LIBPATH\s0 and
proceed.
.IP "\(bu" 4
Do not turn on the compiler optimization flag \*(L"\-O\*(R".  There is
a bug in either the optimizer or perl that causes perl to
not work correctly when the optimizer is on.
.IP "\(bu" 4
Some of the configuration files in /etc used by the
networking APIs are either missing or have the wrong
names.  In particular, make sure that there's either
an /etc/resolv.conf or an /etc/hosts, so that
\&\fIgethostbyname()\fR works, and make sure that the file
/etc/proto has been renamed to /etc/protocol (\s-1NOT\s0
/etc/protocols, as used by other Unix systems).
You may have to look for things like \s-1HOSTNAME\s0 and \s-1DOMAINORIGIN\s0
in the \*(L"//'\s-1SYS1\s0.TCPPARMS(\s-1TCPDATA\s0)'\*(R" \s-1PDS\s0 member in order to
properly set up your /etc networking files.
.SS "Build, Test, Install Perl on \s-1OS/390\s0"
.IX Subsection "Build, Test, Install Perl on OS/390"
Simply put:
.PP
.Vb 3
\&    sh Configure
\&    make
\&    make test
.Ve
.PP
if everything looks ok (see the next section for test/IVP diagnosis) then:
.PP
.Vb 1
\&    make install
.Ve
.PP
this last step may or may not require UID=0 privileges depending
on how you answered the questions that Configure asked and whether
or not you have write access to the directories you specified.
.SS "Build Anomalies with Perl on \s-1OS/390\s0"
.IX Subsection "Build Anomalies with Perl on OS/390"
\&\*(L"Out of memory!\*(R" messages during the build of Perl are most often fixed
by re building the \s-1GNU\s0 make utility for \s-1OS/390\s0 from a source code kit.
.PP
Another memory limiting item to check is your \s-1MAXASSIZE\s0 parameter in your
\&'\s-1SYS1\s0.PARMLIB(BPXPRMxx)' data set (note too that as of V2R8 address space
limits can be set on a per user \s-1ID\s0 basis in the \s-1USS\s0 segment of a \s-1RACF\s0
profile).  People have reported successful builds of Perl with \s-1MAXASSIZE\s0
parameters as small as 503316480 (and it may be possible to build Perl
with a \s-1MAXASSIZE\s0 smaller than that).
.PP
Within \s-1USS\s0 your /etc/profile or \f(CW$HOME\fR/.profile may limit your ulimit
settings.  Check that the following command returns reasonable values:
.PP
.Vb 1
\&    ulimit \-a
.Ve
.PP
To conserve memory you should have your compiler modules loaded into the
Link Pack Area (\s-1LPA/ELPA\s0) rather than in a link list or step lib.
.PP
If the c89 compiler complains of syntax errors during the build of the
Socket extension then be sure to fix the syntax error in the system
header /usr/include/sys/socket.h.
.SS "Testing Anomalies with Perl on \s-1OS/390\s0"
.IX Subsection "Testing Anomalies with Perl on OS/390"
The \*(L"make test\*(R" step runs a Perl Verification Procedure, usually before
installation.  You might encounter \s-1STDERR\s0 messages even during a successful
run of \*(L"make test\*(R".  Here is a guide to some of the more commonly seen
anomalies:
.IP "\(bu" 4
A message of the form:
.Sp
.Vb 4
\& io/openpid...........CEE5210S The signal SIGHUP was received.
\& CEE5210S The signal SIGHUP was received.
\& CEE5210S The signal SIGHUP was received.
\& ok
.Ve
.Sp
indicates that the t/io/openpid.t test of Perl has passed but done so
with extraneous messages on stderr from \s-1CEE\s0.
.IP "\(bu" 4
A message of the form:
.Sp
.Vb 5
\& lib/ftmp\-security....File::Temp::_gettemp: Parent directory (/tmp/) is not safe
\& (sticky bit not set when world writable?) at lib/ftmp\-security.t line 100
\& File::Temp::_gettemp: Parent directory (/tmp/) is not safe (sticky bit not
\& set when world writable?) at lib/ftmp\-security.t line 100
\& ok
.Ve
.Sp
indicates a problem with the permissions on your /tmp directory within the \s-1HFS\s0.
To correct that problem issue the command:
.Sp
.Vb 1
\&     chmod a+t /tmp
.Ve
.Sp
from an account with write access to the directory entry for /tmp.
.IP "\(bu" 4
Out of Memory!
.Sp
Recent perl test suite is quite memory hungry. In addition to the comments
above on memory limitations it is also worth checking for _CEE_RUNOPTS
in your environment. Perl now has (in miniperlmain.c) a C #pragma
to set \s-1CEE\s0 run options, but the environment variable wins.
.Sp
The C code asks for:
.Sp
.Vb 1
\& #pragma runopts(HEAP(2M,500K,ANYWHERE,KEEP,8K,4K) STACK(,,ANY,) ALL31(ON))
.Ve
.Sp
The important parts of that are the second argument (the increment) to \s-1HEAP\s0,
and allowing the stack to be \*(L"Above the (16M) line\*(R". If the heap
increment is too small then when perl (for example loading unicode/Name.pl) tries
to create a \*(L"big\*(R" (400K+) string it cannot fit in a single segment
and you get \*(L"Out of Memory!\*(R" \- even if there is still plenty of memory
available.
.Sp
A related issue is use with perl's malloc. Perl's malloc uses \f(CW\*(C`sbrk()\*(C'\fR
to get memory, and \f(CW\*(C`sbrk()\*(C'\fR is limited to the first allocation so in this
case something like:
.Sp
.Vb 1
\&  HEAP(8M,500K,ANYWHERE,KEEP,8K,4K)
.Ve
.Sp
is needed to get through the test suite.
.SS "Installation Anomalies with Perl on \s-1OS/390\s0"
.IX Subsection "Installation Anomalies with Perl on OS/390"
The installman script will try to run on \s-1OS/390\s0.  There will be fewer errors
if you have a roff utility installed.  You can obtain \s-1GNU\s0 groff from the
Redbook \s-1SG24\-5944\-00\s0 ftp site.
.SS "Usage Hints for Perl on \s-1OS/390\s0"
.IX Subsection "Usage Hints for Perl on OS/390"
When using perl on \s-1OS/390\s0 please keep in mind that the \s-1EBCDIC\s0 and \s-1ASCII\s0
character sets are different.  See perlebcdic.pod for more on such character
set issues.  Perl builtin functions that may behave differently under
\&\s-1EBCDIC\s0 are also mentioned in the perlport.pod document.
.PP
Open Edition (\s-1UNIX\s0 System Services) from V2R8 onward does support
#!/path/to/perl script invocation.  There is a \s-1PTF\s0 available from
\&\s-1IBM\s0 for V2R7 that will allow shell/kernel support for #!.  \s-1USS\s0
releases prior to V2R7 did not support the #! means of script invocation.
If you are running V2R6 or earlier then see:
.PP
.Vb 1
\&    head \`whence perldoc\`
.Ve
.PP
for an example of how to use the \*(L"eval exec\*(R" trick to ask the shell to
have Perl run your scripts on those older releases of Unix System Services.
.PP
If you are having trouble with square brackets then consider switching your
rlogin or telnet client.  Try to avoid older 3270 emulators and \s-1ISHELL\s0 for
working with Perl on \s-1USS\s0.
.SS "Floating Point Anomalies with Perl on \s-1OS/390\s0"
.IX Subsection "Floating Point Anomalies with Perl on OS/390"
There appears to be a bug in the floating point implementation on S/390
systems such that calling \fIint()\fR on the product of a number and a small
magnitude number is not the same as calling \fIint()\fR on the quotient of
that number and a large magnitude number.  For example, in the following
Perl code:
.PP
.Vb 4
\&    my $x = 100000.0;
\&    my $y = int($x * 1e\-5) * 1e5; # \*(Aq0\*(Aq
\&    my $z = int($x / 1e+5) * 1e5;  # \*(Aq100000\*(Aq
\&    print "\e$y is $y and \e$z is $z\en"; # $y is 0 and $z is 100000
.Ve
.PP
Although one would expect the quantities \f(CW$y\fR and \f(CW$z\fR to be the same and equal
to 100000 they will differ and instead will be 0 and 100000 respectively.
.PP
The problem can be further examined in a roughly equivalent C program:
.PP
.Vb 10
\&    #include <stdio.h>
\&    #include <math.h>
\&    main()
\&    {
\&    double r1,r2;
\&    double x = 100000.0;
\&    double y = 0.0;
\&    double z = 0.0;
\&    x = 100000.0 * 1e\-5;
\&    r1 = modf (x,&y);
\&    x = 100000.0 / 1e+5;
\&    r2 = modf (x,&z);
\&    printf("y is %e and z is %e\en",y*1e5,z*1e5);
\&    /* y is 0.000000e+00 and z is 1.000000e+05 (with c89) */
\&    }
.Ve
.SS "Modules and Extensions for Perl on \s-1OS/390\s0"
.IX Subsection "Modules and Extensions for Perl on OS/390"
Pure pure (that is non xs) modules may be installed via the usual:
.PP
.Vb 4
\&    perl Makefile.PL
\&    make
\&    make test
\&    make install
.Ve
.PP
If you built perl with dynamic loading capability then that would also
be the way to build xs based extensions.  However, if you built perl with
the default static linking you can still build xs based extensions for \s-1OS/390\s0
but you will need to follow the instructions in ExtUtils::MakeMaker for
building statically linked perl binaries.  In the simplest configurations
building a static perl + xs extension boils down to:
.PP
.Vb 6
\&    perl Makefile.PL
\&    make
\&    make perl
\&    make test
\&    make install
\&    make \-f Makefile.aperl inst_perl MAP_TARGET=perl
.Ve
.PP
In most cases people have reported better results with \s-1GNU\s0 make rather
than the system's /bin/make program, whether for plain modules or for
xs based extensions.
.PP
If the make process encounters trouble with either compilation or
linking then try setting the _C89_CCMODE to 1.  Assuming sh is your
login shell then run:
.PP
.Vb 1
\&    export _C89_CCMODE=1
.Ve
.PP
If tcsh is your login shell then use the setenv command.
.SH "AUTHORS"
.IX Header "AUTHORS"
David Fiander and Peter Prymmer with thanks to Dennis Longnecker
and William Raffloer for valuable reports, \s-1LPAR\s0 and \s-1PTF\s0 feedback.
Thanks to Mike MacIsaac and Egon Terwedow for \s-1SG24\-5944\-00\s0.
Thanks to Ignasi Roca for pointing out the floating point problems.
Thanks to John Goodyear for dynamic loading help.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1INSTALL\s0, perlport, perlebcdic, ExtUtils::MakeMaker.
.PP
.Vb 1
\&    http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html
\&
\&    http://www.redbooks.ibm.com/redbooks/SG245944.html
\&
\&    http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1ty1.html#opensrc
\&
\&    http://www.xray.mpe.mpg.de/mailing\-lists/perl\-mvs/
\&
\&    http://publibz.boulder.ibm.com:80/cgi\-bin/bookmgr_OS390/BOOKS/ceea3030/
\&
\&    http://publibz.boulder.ibm.com:80/cgi\-bin/bookmgr_OS390/BOOKS/CBCUG030/
.Ve
.SS "Mailing list for Perl on \s-1OS/390\s0"
.IX Subsection "Mailing list for Perl on OS/390"
If you are interested in the \s-1VM/ESA\s0, z/OS (formerly known as \s-1OS/390\s0)
and POSIX-BC (\s-1BS2000\s0) ports of Perl then see the perl-mvs mailing list.
To subscribe, send an empty message to perl\-mvs\-subscribe@perl.org.
.PP
See also:
.PP
.Vb 1
\&    http://lists.perl.org/list/perl\-mvs.html
.Ve
.PP
There are web archives of the mailing list at:
.PP
.Vb 2
\&    http://www.xray.mpe.mpg.de/mailing\-lists/perl\-mvs/
\&    http://archive.develooper.com/perl\-mvs@perl.org/
.Ve
.SH "HISTORY"
.IX Header "HISTORY"
This document was originally written by David Fiander for the 5.005
release of Perl.
.PP
This document was podified for the 5.005_03 release of Perl 11 March 1999.
.PP
Updated 28 November 2001 for broken URLs.
.PP
Updated 12 November 2000 for the 5.7.1 release of Perl.
.PP
Updated 15 January 2001 for the 5.7.1 release of Perl.
.PP
Updated 24 January 2001 to mention dynamic loading.
.PP
Updated 12 March 2001 to mention //'\s-1SYS1\s0.TCPPARMS(\s-1TCPDATA\s0)'.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlos3905.18.1                              0100644 0001750 0001750 00000052016 12566207443 023021  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLOS390 1"
.TH PERLOS390 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlos390 \- building and installing Perl for OS/390 and z/OS
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This document will help you Configure, build, test and install Perl
on \s-1OS/390 \s0(aka z/OS) Unix System Services.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a fully ported Perl for \s-1OS/390\s0 Version 2 Release 3, 5, 6, 7,
8, and 9.  It may work on other versions or releases, but those are
the ones we've tested it on.
.PP
You may need to carry out some system configuration tasks before
running the Configure script for Perl.
.SS "Tools"
.IX Subsection "Tools"
The z/OS Unix Tools and Toys list may prove helpful and contains links
to ports of much of the software helpful for building Perl.
http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html
.SS "Unpacking Perl distribution on \s-1OS/390\s0"
.IX Subsection "Unpacking Perl distribution on OS/390"
If using ftp remember to transfer the distribution in binary format.
.PP
Gunzip/gzip for \s-1OS/390\s0 is discussed at:
.PP
.Vb 1
\&  http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1ty1.html
.Ve
.PP
to extract an \s-1ASCII\s0 tar archive on \s-1OS/390,\s0 try this:
.PP
.Vb 1
\&   pax \-o to=IBM\-1047,from=ISO8859\-1 \-r < latest.tar
.Ve
.PP
or
.PP
.Vb 1
\&   zcat latest.tar.Z | pax \-o to=IBM\-1047,from=ISO8859\-1 \-r
.Ve
.PP
If you get lots of errors of the form
.PP
.Vb 1
\&  tar: FSUM7171 ...: cannot set uid/gid: EDC5139I Operation not permitted.
.Ve
.PP
you didn't read the above and tried to use tar instead of pax, you'll
first have to remove the (now corrupt) perl directory
.PP
.Vb 1
\&   rm \-rf perl\-...
.Ve
.PP
and then use pax.
.SS "Setup and utilities for Perl on \s-1OS/390\s0"
.IX Subsection "Setup and utilities for Perl on OS/390"
Be sure that your yacc installation is in place including any necessary
parser template files. If you have not already done so then be sure to:
.PP
.Vb 1
\&  cp /samples/yyparse.c /etc
.Ve
.PP
This may also be a good time to ensure that your /etc/protocol file
and either your /etc/resolv.conf or /etc/hosts files are in place.
The \s-1IBM\s0 document that described such \s-1USS\s0 system setup issues was
\&\s-1SC28\-1890\-07 \*(L"OS/390 UNIX\s0 System Services Planning\*(R", in particular
Chapter 6 on customizing the \s-1OE\s0 shell.
.PP
\&\s-1GNU\s0 make for \s-1OS/390,\s0 which is recommended for the build of perl (as
well as building \s-1CPAN\s0 modules and extensions), is available from the
\&\*(L"Tools\*(R".
.PP
Some people have reported encountering \*(L"Out of memory!\*(R" errors while
trying to build Perl using \s-1GNU\s0 make binaries.  If you encounter such
trouble then try to download the source code kit and build \s-1GNU\s0 make
from source to eliminate any such trouble.  You might also find \s-1GNU\s0 make
(as well as Perl and Apache) in the red\-piece/book \*(L"Open Source Software
for \s-1OS/390 UNIX\*(R", SG24\-5944\-00\s0 from \s-1IBM.\s0
.PP
If instead of the recommended \s-1GNU\s0 make you would like to use the system
supplied make program then be sure to install the default rules file
properly via the shell command:
.PP
.Vb 1
\&    cp /samples/startup.mk /etc
.Ve
.PP
and be sure to also set the environment variable _C89_CCMODE=1 (exporting
_C89_CCMODE=1 is also a good idea for users of \s-1GNU\s0 make).
.PP
You might also want to have \s-1GNU\s0 groff for \s-1OS/390\s0 installed before
running the \*(L"make install\*(R" step for Perl.
.PP
There is a syntax error in the /usr/include/sys/socket.h header file
that \s-1IBM\s0 supplies with \s-1USS V2R7, V2R8,\s0 and possibly V2R9.  The problem with
the header file is that near the definition of the \s-1SO_REUSEPORT\s0 constant
there is a spurious extra '/' character outside of a comment like so:
.PP
.Vb 2
\& #define SO_REUSEPORT    0x0200    /* allow local address & port
\&                                      reuse */                    /
.Ve
.PP
You could edit that header yourself to remove that last '/', or you might
note that Language Environment (\s-1LE\s0) \s-1APAR PQ39997\s0 describes the problem
and \s-1PTF\s0's \s-1UQ46272\s0 and \s-1UQ46271\s0 are the (R8 at least) fixes and apply them.
If left unattended that syntax error will turn up as an inability for Perl
to build its \*(L"Socket\*(R" extension.
.PP
For successful testing you may need to turn on the sticky bit for your
world readable /tmp directory if you have not already done so (see man chmod).
.SS "Configure Perl on \s-1OS/390\s0"
.IX Subsection "Configure Perl on OS/390"
Once you've unpacked the distribution, run \*(L"sh Configure\*(R" (see \s-1INSTALL\s0
for a full discussion of the Configure options).  There is a \*(L"hints\*(R" file
for os390 that specifies the correct values for most things.  Some things
to watch out for include:
.IP "\(bu" 4
A message of the form:
.Sp
.Vb 2
\& (I see you are using the Korn shell.  Some ksh\*(Aqs blow up on Configure,
\& mainly on older exotic systems.  If yours does, try the Bourne shell instead.)
.Ve
.Sp
is nothing to worry about at all.
.IP "\(bu" 4
Some of the parser default template files in /samples are needed in /etc.
In particular be sure that you at least copy /samples/yyparse.c to /etc
before running Perl's Configure.  This step ensures successful extraction
of \s-1EBCDIC\s0 versions of parser files such as perly.c, perly.h, and x2p/a2p.c.
This has to be done before running Configure the first time.  If you failed
to do so then the easiest way to re-Configure Perl is to delete your
misconfigured build root and re-extract the source from the tar ball.
Then you must ensure that /etc/yyparse.c is properly in place before
attempting to re-run Configure.
.IP "\(bu" 4
This port will support dynamic loading, but it is not selected by
default.  If you would like to experiment with dynamic loading then
be sure to specify \-Dusedl in the arguments to the Configure script.
See the comments in hints/os390.sh for more information on dynamic loading.
If you build with dynamic loading then you will need to add the
\&\f(CW$archlibexp\fR/CORE directory to your \s-1LIBPATH\s0 environment variable in order
for perl to work.  See the config.sh file for the value of \f(CW$archlibexp\fR.
If in trying to use Perl you see an error message similar to:
.Sp
.Vb 2
\& CEE3501S The module libperl.dll was not found.
\&         From entry point _\|_dllstaticinit at compile unit offset +00000194 at
.Ve
.Sp
then your \s-1LIBPATH\s0 does not have the location of libperl.x and either
libperl.dll or libperl.so in it.  Add that directory to your \s-1LIBPATH\s0 and
proceed.
.IP "\(bu" 4
Do not turn on the compiler optimization flag \*(L"\-O\*(R".  There is
a bug in either the optimizer or perl that causes perl to
not work correctly when the optimizer is on.
.IP "\(bu" 4
Some of the configuration files in /etc used by the
networking APIs are either missing or have the wrong
names.  In particular, make sure that there's either
an /etc/resolv.conf or an /etc/hosts, so that
\&\fIgethostbyname()\fR works, and make sure that the file
/etc/proto has been renamed to /etc/protocol (\s-1NOT\s0
/etc/protocols, as used by other Unix systems).
You may have to look for things like \s-1HOSTNAME\s0 and \s-1DOMAINORIGIN\s0
in the \*(L"//'\s-1SYS1.TCPPARMS\s0(\s-1TCPDATA\s0)'\*(R" \s-1PDS\s0 member in order to
properly set up your /etc networking files.
.SS "Build, Test, Install Perl on \s-1OS/390\s0"
.IX Subsection "Build, Test, Install Perl on OS/390"
Simply put:
.PP
.Vb 3
\&    sh Configure
\&    make
\&    make test
.Ve
.PP
if everything looks ok (see the next section for test/IVP diagnosis) then:
.PP
.Vb 1
\&    make install
.Ve
.PP
this last step may or may not require UID=0 privileges depending
on how you answered the questions that Configure asked and whether
or not you have write access to the directories you specified.
.SS "Build Anomalies with Perl on \s-1OS/390\s0"
.IX Subsection "Build Anomalies with Perl on OS/390"
\&\*(L"Out of memory!\*(R" messages during the build of Perl are most often fixed
by re building the \s-1GNU\s0 make utility for \s-1OS/390\s0 from a source code kit.
.PP
Another memory limiting item to check is your \s-1MAXASSIZE\s0 parameter in your
\&'\s-1SYS1.PARMLIB\s0(BPXPRMxx)' data set (note too that as of V2R8 address space
limits can be set on a per user \s-1ID\s0 basis in the \s-1USS\s0 segment of a \s-1RACF\s0
profile).  People have reported successful builds of Perl with \s-1MAXASSIZE\s0
parameters as small as 503316480 (and it may be possible to build Perl
with a \s-1MAXASSIZE\s0 smaller than that).
.PP
Within \s-1USS\s0 your /etc/profile or \f(CW$HOME\fR/.profile may limit your ulimit
settings.  Check that the following command returns reasonable values:
.PP
.Vb 1
\&    ulimit \-a
.Ve
.PP
To conserve memory you should have your compiler modules loaded into the
Link Pack Area (\s-1LPA/ELPA\s0) rather than in a link list or step lib.
.PP
If the c89 compiler complains of syntax errors during the build of the
Socket extension then be sure to fix the syntax error in the system
header /usr/include/sys/socket.h.
.SS "Testing Anomalies with Perl on \s-1OS/390\s0"
.IX Subsection "Testing Anomalies with Perl on OS/390"
The \*(L"make test\*(R" step runs a Perl Verification Procedure, usually before
installation.  You might encounter \s-1STDERR\s0 messages even during a successful
run of \*(L"make test\*(R".  Here is a guide to some of the more commonly seen
anomalies:
.IP "\(bu" 4
A message of the form:
.Sp
.Vb 4
\& io/openpid...........CEE5210S The signal SIGHUP was received.
\& CEE5210S The signal SIGHUP was received.
\& CEE5210S The signal SIGHUP was received.
\& ok
.Ve
.Sp
indicates that the t/io/openpid.t test of Perl has passed but done so
with extraneous messages on stderr from \s-1CEE.\s0
.IP "\(bu" 4
A message of the form:
.Sp
.Vb 5
\& lib/ftmp\-security....File::Temp::_gettemp: Parent directory (/tmp/) is not safe
\& (sticky bit not set when world writable?) at lib/ftmp\-security.t line 100
\& File::Temp::_gettemp: Parent directory (/tmp/) is not safe (sticky bit not
\& set when world writable?) at lib/ftmp\-security.t line 100
\& ok
.Ve
.Sp
indicates a problem with the permissions on your /tmp directory within the \s-1HFS.\s0
To correct that problem issue the command:
.Sp
.Vb 1
\&     chmod a+t /tmp
.Ve
.Sp
from an account with write access to the directory entry for /tmp.
.IP "\(bu" 4
Out of Memory!
.Sp
Recent perl test suite is quite memory hungry. In addition to the comments
above on memory limitations it is also worth checking for _CEE_RUNOPTS
in your environment. Perl now has (in miniperlmain.c) a C #pragma
to set \s-1CEE\s0 run options, but the environment variable wins.
.Sp
The C code asks for:
.Sp
.Vb 1
\& #pragma runopts(HEAP(2M,500K,ANYWHERE,KEEP,8K,4K) STACK(,,ANY,) ALL31(ON))
.Ve
.Sp
The important parts of that are the second argument (the increment) to \s-1HEAP,\s0
and allowing the stack to be \*(L"Above the (16M) line\*(R". If the heap
increment is too small then when perl (for example loading unicode/Name.pl) tries
to create a \*(L"big\*(R" (400K+) string it cannot fit in a single segment
and you get \*(L"Out of Memory!\*(R" \- even if there is still plenty of memory
available.
.Sp
A related issue is use with perl's malloc. Perl's malloc uses \f(CW\*(C`sbrk()\*(C'\fR
to get memory, and \f(CW\*(C`sbrk()\*(C'\fR is limited to the first allocation so in this
case something like:
.Sp
.Vb 1
\&  HEAP(8M,500K,ANYWHERE,KEEP,8K,4K)
.Ve
.Sp
is needed to get through the test suite.
.SS "Installation Anomalies with Perl on \s-1OS/390\s0"
.IX Subsection "Installation Anomalies with Perl on OS/390"
The installman script will try to run on \s-1OS/390. \s0 There will be fewer errors
if you have a roff utility installed.  You can obtain \s-1GNU\s0 groff from the
Redbook \s-1SG24\-5944\-00\s0 ftp site.
.SS "Usage Hints for Perl on \s-1OS/390\s0"
.IX Subsection "Usage Hints for Perl on OS/390"
When using perl on \s-1OS/390\s0 please keep in mind that the \s-1EBCDIC\s0 and \s-1ASCII\s0
character sets are different.  See perlebcdic.pod for more on such character
set issues.  Perl builtin functions that may behave differently under
\&\s-1EBCDIC\s0 are also mentioned in the perlport.pod document.
.PP
Open Edition (\s-1UNIX\s0 System Services) from V2R8 onward does support
#!/path/to/perl script invocation.  There is a \s-1PTF\s0 available from
\&\s-1IBM\s0 for V2R7 that will allow shell/kernel support for #!.  \s-1USS\s0
releases prior to V2R7 did not support the #! means of script invocation.
If you are running V2R6 or earlier then see:
.PP
.Vb 1
\&    head \`whence perldoc\`
.Ve
.PP
for an example of how to use the \*(L"eval exec\*(R" trick to ask the shell to
have Perl run your scripts on those older releases of Unix System Services.
.PP
If you are having trouble with square brackets then consider switching your
rlogin or telnet client.  Try to avoid older 3270 emulators and \s-1ISHELL\s0 for
working with Perl on \s-1USS.\s0
.SS "Floating Point Anomalies with Perl on \s-1OS/390\s0"
.IX Subsection "Floating Point Anomalies with Perl on OS/390"
There appears to be a bug in the floating point implementation on S/390
systems such that calling \fIint()\fR on the product of a number and a small
magnitude number is not the same as calling \fIint()\fR on the quotient of
that number and a large magnitude number.  For example, in the following
Perl code:
.PP
.Vb 4
\&    my $x = 100000.0;
\&    my $y = int($x * 1e\-5) * 1e5; # \*(Aq0\*(Aq
\&    my $z = int($x / 1e+5) * 1e5;  # \*(Aq100000\*(Aq
\&    print "\e$y is $y and \e$z is $z\en"; # $y is 0 and $z is 100000
.Ve
.PP
Although one would expect the quantities \f(CW$y\fR and \f(CW$z\fR to be the same and equal
to 100000 they will differ and instead will be 0 and 100000 respectively.
.PP
The problem can be further examined in a roughly equivalent C program:
.PP
.Vb 10
\&    #include <stdio.h>
\&    #include <math.h>
\&    main()
\&    {
\&    double r1,r2;
\&    double x = 100000.0;
\&    double y = 0.0;
\&    double z = 0.0;
\&    x = 100000.0 * 1e\-5;
\&    r1 = modf (x,&y);
\&    x = 100000.0 / 1e+5;
\&    r2 = modf (x,&z);
\&    printf("y is %e and z is %e\en",y*1e5,z*1e5);
\&    /* y is 0.000000e+00 and z is 1.000000e+05 (with c89) */
\&    }
.Ve
.SS "Modules and Extensions for Perl on \s-1OS/390\s0"
.IX Subsection "Modules and Extensions for Perl on OS/390"
Pure pure (that is non xs) modules may be installed via the usual:
.PP
.Vb 4
\&    perl Makefile.PL
\&    make
\&    make test
\&    make install
.Ve
.PP
If you built perl with dynamic loading capability then that would also
be the way to build xs based extensions.  However, if you built perl with
the default static linking you can still build xs based extensions for \s-1OS/390\s0
but you will need to follow the instructions in ExtUtils::MakeMaker for
building statically linked perl binaries.  In the simplest configurations
building a static perl + xs extension boils down to:
.PP
.Vb 6
\&    perl Makefile.PL
\&    make
\&    make perl
\&    make test
\&    make install
\&    make \-f Makefile.aperl inst_perl MAP_TARGET=perl
.Ve
.PP
In most cases people have reported better results with \s-1GNU\s0 make rather
than the system's /bin/make program, whether for plain modules or for
xs based extensions.
.PP
If the make process encounters trouble with either compilation or
linking then try setting the _C89_CCMODE to 1.  Assuming sh is your
login shell then run:
.PP
.Vb 1
\&    export _C89_CCMODE=1
.Ve
.PP
If tcsh is your login shell then use the setenv command.
.SH "AUTHORS"
.IX Header "AUTHORS"
David Fiander and Peter Prymmer with thanks to Dennis Longnecker
and William Raffloer for valuable reports, \s-1LPAR\s0 and \s-1PTF\s0 feedback.
Thanks to Mike MacIsaac and Egon Terwedow for \s-1SG24\-5944\-00.\s0
Thanks to Ignasi Roca for pointing out the floating point problems.
Thanks to John Goodyear for dynamic loading help.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1INSTALL\s0, perlport, perlebcdic, ExtUtils::MakeMaker.
.PP
.Vb 1
\&    http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html
\&
\&    http://www.redbooks.ibm.com/redbooks/SG245944.html
\&
\&    http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1ty1.html#opensrc
\&
\&    http://www.xray.mpe.mpg.de/mailing\-lists/perl\-mvs/
\&
\&    http://publibz.boulder.ibm.com:80/cgi\-bin/bookmgr_OS390/BOOKS/ceea3030/
\&
\&    http://publibz.boulder.ibm.com:80/cgi\-bin/bookmgr_OS390/BOOKS/CBCUG030/
.Ve
.SS "Mailing list for Perl on \s-1OS/390\s0"
.IX Subsection "Mailing list for Perl on OS/390"
If you are interested in the z/OS (formerly known as \s-1OS/390\s0)
and POSIX-BC (\s-1BS2000\s0) ports of Perl then see the perl-mvs mailing list.
To subscribe, send an empty message to perl\-mvs\-subscribe@perl.org.
.PP
See also:
.PP
.Vb 1
\&    http://lists.perl.org/list/perl\-mvs.html
.Ve
.PP
There are web archives of the mailing list at:
.PP
.Vb 2
\&    http://www.xray.mpe.mpg.de/mailing\-lists/perl\-mvs/
\&    http://archive.develooper.com/perl\-mvs@perl.org/
.Ve
.SH "HISTORY"
.IX Header "HISTORY"
This document was originally written by David Fiander for the 5.005
release of Perl.
.PP
This document was podified for the 5.005_03 release of Perl 11 March 1999.
.PP
Updated 28 November 2001 for broken URLs.
.PP
Updated 12 November 2000 for the 5.7.1 release of Perl.
.PP
Updated 15 January 2001 for the 5.7.1 release of Perl.
.PP
Updated 24 January 2001 to mention dynamic loading.
.PP
Updated 12 March 2001 to mention //'\s-1SYS1.TCPPARMS\s0(\s-1TCPDATA\s0)'.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlos400.1                                  0100644 0001750 0001750 00000021653 12566207443 022500  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLOS400 1"
.TH PERLOS400 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlos400 \- Perl version 5 on OS/400
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes various features of \s-1IBM\s0's \s-1OS/400\s0 operating
system that will affect how Perl version 5 (hereafter just Perl) is
compiled and/or runs.
.PP
By far the easiest way to build Perl for \s-1OS/400\s0 is to use the \s-1PASE
\&\s0(Portable Application Solutions Environment), for more information see
<http://www.iseries.ibm.com/developer/factory/pase/index.html>
This environment allows one to use \s-1AIX\s0 APIs while programming, and it
provides a runtime that allows \s-1AIX\s0 binaries to execute directly on the
PowerPC iSeries.
.SS "Compiling Perl for \s-1OS/400 PASE\s0"
.IX Subsection "Compiling Perl for OS/400 PASE"
The recommended way to build Perl for the \s-1OS/400 PASE\s0 is to build the
Perl 5 source code (release 5.8.1 or later) under \s-1AIX.\s0
.PP
The trick is to give a special parameter to the Configure shell script
when running it on \s-1AIX:\s0
.PP
.Vb 1
\&  sh Configure \-DPASE ...
.Ve
.PP
The default installation directory of Perl under \s-1PASE\s0 is /QOpenSys/perl.
This can be modified if needed with Configure parameter \-Dprefix=/some/dir.
.PP
Starting from \s-1OS/400 V5R2\s0 the \s-1IBM\s0 Visual Age compiler is supported
on \s-1OS/400 PASE,\s0 so it is possible to build Perl natively on \s-1OS/400.  \s0
The easier way, however, is to compile in \s-1AIX,\s0 as just described.
.PP
If you don't want to install the compiled Perl in \s-1AIX\s0 into /QOpenSys
(for packaging it before copying it to \s-1PASE\s0), you can use a Configure
parameter: \-Dinstallprefix=/tmp/QOpenSys/perl.  This will cause the
\&\*(L"make install\*(R" to install everything into that directory, while the
installed files still think they are (will be) in /QOpenSys/perl.
.PP
If building natively on \s-1PASE,\s0 please do the build under the /QOpenSys
directory, since Perl is happier when built on a case sensitive filesystem.
.SS "Installing Perl in \s-1OS/400 PASE\s0"
.IX Subsection "Installing Perl in OS/400 PASE"
If you are compiling on \s-1AIX,\s0 simply do a \*(L"make install\*(R" on the \s-1AIX\s0 box.
Once the install finishes, tar up the /QOpenSys/perl directory.  Transfer
the tarball to the \s-1OS/400\s0 using \s-1FTP\s0 with the following commands:
.PP
.Vb 3
\&  > binary
\&  > site namefmt 1
\&  > put perl.tar /QOpenSys
.Ve
.PP
Once you have it on, simply bring up a \s-1PASE\s0 shell and extract the tarball.
.PP
If you are compiling in \s-1PASE,\s0 then \*(L"make install\*(R" is the only thing you
will need to do.
.PP
The default path for perl binary is /QOpenSys/perl/bin/perl.  You'll
want to symlink /QOpenSys/usr/bin/perl to this file so you don't have
to modify your path.
.SS "Using Perl in \s-1OS/400 PASE\s0"
.IX Subsection "Using Perl in OS/400 PASE"
Perl in \s-1PASE\s0 may be used in the same manner as you would use Perl on \s-1AIX.\s0
.PP
Scripts starting with #!/usr/bin/perl should work if you have
/QOpenSys/usr/bin/perl symlinked to your perl binary.  This will not
work if you've done a setuid/setgid or have environment variable
PASE_EXEC_QOPENSYS=\*(L"N\*(R".  If you have V5R1, you'll need to get the
latest PTFs to have this feature.  Scripts starting with
#!/QOpenSys/perl/bin/perl should always work.
.SS "Known Problems"
.IX Subsection "Known Problems"
When compiling in \s-1PASE,\s0 there is no \*(L"oslevel\*(R" command.  Therefore,
you may want to create a script called \*(L"oslevel\*(R" that echoes the
level of \s-1AIX\s0 that your version of \s-1PASE\s0 runtime supports.  If you're
unsure, consult your documentation or use \*(L"4.3.3.0\*(R".
.PP
If you have test cases that fail, check for the existence of spool files.
The test case may be trying to use a syscall that is not implemented
in \s-1PASE. \s0 To avoid the \s-1SIGILL,\s0 try setting the \s-1PASE_SYSCALL_NOSIGILL\s0
environment variable or have a handler for the \s-1SIGILL. \s0 If you can
compile programs for \s-1PASE,\s0 run the config script and edit config.sh
when it gives you the option.  If you want to remove \fIfchdir()\fR, which
isn't implement in V5R1, simply change the line that says:
.PP
d_fchdir='define'
.PP
to
.PP
d_fchdir='undef'
.PP
and then compile Perl.  The places where \fIfchdir()\fR is used have
alternatives for systems that do not have \fIfchdir()\fR available.
.SS "Perl on \s-1ILE\s0"
.IX Subsection "Perl on ILE"
There exists a port of Perl to the \s-1ILE\s0 environment.  This port, however,
is based quite an old release of Perl, Perl 5.00502 (August 1998).
(As of July 2002 the latest release of Perl is 5.8.0, and even 5.6.1
has been out since April 2001.)  If you need to run Perl on \s-1ILE,\s0 though,
you may need this older port: <http://www.cpan.org/ports/#os400>
Note that any Perl release later than 5.00502 has not been ported to \s-1ILE.\s0
.PP
If you need to use Perl in the \s-1ILE\s0 environment, you may want to consider
using \fIQp2RunPase()\fR to call the \s-1PASE\s0 version of Perl.
.SH "AUTHORS"
.IX Header "AUTHORS"
Jarkko Hietaniemi <jhi@iki.fi>
Bryan Logan <bryanlog@us.ibm.com>
David Larson <larson1@us.ibm.com>
                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlos4005.16.1                              0100644 0001750 0001750 00000021373 12566207422 023006  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLOS400 1"
.TH PERLOS400 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlos400 \- Perl version 5 on OS/400
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes various features of \s-1IBM\s0's \s-1OS/400\s0 operating
system that will affect how Perl version 5 (hereafter just Perl) is
compiled and/or runs.
.PP
By far the easiest way to build Perl for \s-1OS/400\s0 is to use the \s-1PASE\s0
(Portable Application Solutions Environment), for more information see
<http://www.iseries.ibm.com/developer/factory/pase/index.html>
This environment allows one to use \s-1AIX\s0 APIs while programming, and it
provides a runtime that allows \s-1AIX\s0 binaries to execute directly on the
PowerPC iSeries.
.SS "Compiling Perl for \s-1OS/400\s0 \s-1PASE\s0"
.IX Subsection "Compiling Perl for OS/400 PASE"
The recommended way to build Perl for the \s-1OS/400\s0 \s-1PASE\s0 is to build the
Perl 5 source code (release 5.8.1 or later) under \s-1AIX\s0.
.PP
The trick is to give a special parameter to the Configure shell script
when running it on \s-1AIX:\s0
.PP
.Vb 1
\&  sh Configure \-DPASE ...
.Ve
.PP
The default installation directory of Perl under \s-1PASE\s0 is /QOpenSys/perl.
This can be modified if needed with Configure parameter \-Dprefix=/some/dir.
.PP
Starting from \s-1OS/400\s0 V5R2 the \s-1IBM\s0 Visual Age compiler is supported
on \s-1OS/400\s0 \s-1PASE\s0, so it is possible to build Perl natively on \s-1OS/400\s0.  
The easier way, however, is to compile in \s-1AIX\s0, as just described.
.PP
If you don't want to install the compiled Perl in \s-1AIX\s0 into /QOpenSys
(for packaging it before copying it to \s-1PASE\s0), you can use a Configure
parameter: \-Dinstallprefix=/tmp/QOpenSys/perl.  This will cause the
\&\*(L"make install\*(R" to install everything into that directory, while the
installed files still think they are (will be) in /QOpenSys/perl.
.PP
If building natively on \s-1PASE\s0, please do the build under the /QOpenSys
directory, since Perl is happier when built on a case sensitive filesystem.
.SS "Installing Perl in \s-1OS/400\s0 \s-1PASE\s0"
.IX Subsection "Installing Perl in OS/400 PASE"
If you are compiling on \s-1AIX\s0, simply do a \*(L"make install\*(R" on the \s-1AIX\s0 box.
Once the install finishes, tar up the /QOpenSys/perl directory.  Transfer
the tarball to the \s-1OS/400\s0 using \s-1FTP\s0 with the following commands:
.PP
.Vb 3
\&  > binary
\&  > site namefmt 1
\&  > put perl.tar /QOpenSys
.Ve
.PP
Once you have it on, simply bring up a \s-1PASE\s0 shell and extract the tarball.
.PP
If you are compiling in \s-1PASE\s0, then \*(L"make install\*(R" is the only thing you
will need to do.
.PP
The default path for perl binary is /QOpenSys/perl/bin/perl.  You'll
want to symlink /QOpenSys/usr/bin/perl to this file so you don't have
to modify your path.
.SS "Using Perl in \s-1OS/400\s0 \s-1PASE\s0"
.IX Subsection "Using Perl in OS/400 PASE"
Perl in \s-1PASE\s0 may be used in the same manner as you would use Perl on \s-1AIX\s0.
.PP
Scripts starting with #!/usr/bin/perl should work if you have
/QOpenSys/usr/bin/perl symlinked to your perl binary.  This will not
work if you've done a setuid/setgid or have environment variable
PASE_EXEC_QOPENSYS=\*(L"N\*(R".  If you have V5R1, you'll need to get the
latest PTFs to have this feature.  Scripts starting with
#!/QOpenSys/perl/bin/perl should always work.
.SS "Known Problems"
.IX Subsection "Known Problems"
When compiling in \s-1PASE\s0, there is no \*(L"oslevel\*(R" command.  Therefore,
you may want to create a script called \*(L"oslevel\*(R" that echoes the
level of \s-1AIX\s0 that your version of \s-1PASE\s0 runtime supports.  If you're
unsure, consult your documentation or use \*(L"4.3.3.0\*(R".
.PP
If you have test cases that fail, check for the existence of spool files.
The test case may be trying to use a syscall that is not implemented
in \s-1PASE\s0.  To avoid the \s-1SIGILL\s0, try setting the \s-1PASE_SYSCALL_NOSIGILL\s0
environment variable or have a handler for the \s-1SIGILL\s0.  If you can
compile programs for \s-1PASE\s0, run the config script and edit config.sh
when it gives you the option.  If you want to remove \fIfchdir()\fR, which
isn't implement in V5R1, simply change the line that says:
.PP
d_fchdir='define'
.PP
to
.PP
d_fchdir='undef'
.PP
and then compile Perl.  The places where \fIfchdir()\fR is used have
alternatives for systems that do not have \fIfchdir()\fR available.
.SS "Perl on \s-1ILE\s0"
.IX Subsection "Perl on ILE"
There exists a port of Perl to the \s-1ILE\s0 environment.  This port, however,
is based quite an old release of Perl, Perl 5.00502 (August 1998).
(As of July 2002 the latest release of Perl is 5.8.0, and even 5.6.1
has been out since April 2001.)  If you need to run Perl on \s-1ILE\s0, though,
you may need this older port: <http://www.cpan.org/ports/#os400>
Note that any Perl release later than 5.00502 has not been ported to \s-1ILE\s0.
.PP
If you need to use Perl in the \s-1ILE\s0 environment, you may want to consider
using \fIQp2RunPase()\fR to call the \s-1PASE\s0 version of Perl.
.SH "AUTHORS"
.IX Header "AUTHORS"
Jarkko Hietaniemi <jhi@iki.fi>
Bryan Logan <bryanlog@us.ibm.com>
David Larson <larson1@us.ibm.com>
                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlos4005.18.1                              0100644 0001750 0001750 00000021653 12566207443 023014  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLOS400 1"
.TH PERLOS400 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlos400 \- Perl version 5 on OS/400
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document describes various features of \s-1IBM\s0's \s-1OS/400\s0 operating
system that will affect how Perl version 5 (hereafter just Perl) is
compiled and/or runs.
.PP
By far the easiest way to build Perl for \s-1OS/400\s0 is to use the \s-1PASE
\&\s0(Portable Application Solutions Environment), for more information see
<http://www.iseries.ibm.com/developer/factory/pase/index.html>
This environment allows one to use \s-1AIX\s0 APIs while programming, and it
provides a runtime that allows \s-1AIX\s0 binaries to execute directly on the
PowerPC iSeries.
.SS "Compiling Perl for \s-1OS/400 PASE\s0"
.IX Subsection "Compiling Perl for OS/400 PASE"
The recommended way to build Perl for the \s-1OS/400 PASE\s0 is to build the
Perl 5 source code (release 5.8.1 or later) under \s-1AIX.\s0
.PP
The trick is to give a special parameter to the Configure shell script
when running it on \s-1AIX:\s0
.PP
.Vb 1
\&  sh Configure \-DPASE ...
.Ve
.PP
The default installation directory of Perl under \s-1PASE\s0 is /QOpenSys/perl.
This can be modified if needed with Configure parameter \-Dprefix=/some/dir.
.PP
Starting from \s-1OS/400 V5R2\s0 the \s-1IBM\s0 Visual Age compiler is supported
on \s-1OS/400 PASE,\s0 so it is possible to build Perl natively on \s-1OS/400.  \s0
The easier way, however, is to compile in \s-1AIX,\s0 as just described.
.PP
If you don't want to install the compiled Perl in \s-1AIX\s0 into /QOpenSys
(for packaging it before copying it to \s-1PASE\s0), you can use a Configure
parameter: \-Dinstallprefix=/tmp/QOpenSys/perl.  This will cause the
\&\*(L"make install\*(R" to install everything into that directory, while the
installed files still think they are (will be) in /QOpenSys/perl.
.PP
If building natively on \s-1PASE,\s0 please do the build under the /QOpenSys
directory, since Perl is happier when built on a case sensitive filesystem.
.SS "Installing Perl in \s-1OS/400 PASE\s0"
.IX Subsection "Installing Perl in OS/400 PASE"
If you are compiling on \s-1AIX,\s0 simply do a \*(L"make install\*(R" on the \s-1AIX\s0 box.
Once the install finishes, tar up the /QOpenSys/perl directory.  Transfer
the tarball to the \s-1OS/400\s0 using \s-1FTP\s0 with the following commands:
.PP
.Vb 3
\&  > binary
\&  > site namefmt 1
\&  > put perl.tar /QOpenSys
.Ve
.PP
Once you have it on, simply bring up a \s-1PASE\s0 shell and extract the tarball.
.PP
If you are compiling in \s-1PASE,\s0 then \*(L"make install\*(R" is the only thing you
will need to do.
.PP
The default path for perl binary is /QOpenSys/perl/bin/perl.  You'll
want to symlink /QOpenSys/usr/bin/perl to this file so you don't have
to modify your path.
.SS "Using Perl in \s-1OS/400 PASE\s0"
.IX Subsection "Using Perl in OS/400 PASE"
Perl in \s-1PASE\s0 may be used in the same manner as you would use Perl on \s-1AIX.\s0
.PP
Scripts starting with #!/usr/bin/perl should work if you have
/QOpenSys/usr/bin/perl symlinked to your perl binary.  This will not
work if you've done a setuid/setgid or have environment variable
PASE_EXEC_QOPENSYS=\*(L"N\*(R".  If you have V5R1, you'll need to get the
latest PTFs to have this feature.  Scripts starting with
#!/QOpenSys/perl/bin/perl should always work.
.SS "Known Problems"
.IX Subsection "Known Problems"
When compiling in \s-1PASE,\s0 there is no \*(L"oslevel\*(R" command.  Therefore,
you may want to create a script called \*(L"oslevel\*(R" that echoes the
level of \s-1AIX\s0 that your version of \s-1PASE\s0 runtime supports.  If you're
unsure, consult your documentation or use \*(L"4.3.3.0\*(R".
.PP
If you have test cases that fail, check for the existence of spool files.
The test case may be trying to use a syscall that is not implemented
in \s-1PASE. \s0 To avoid the \s-1SIGILL,\s0 try setting the \s-1PASE_SYSCALL_NOSIGILL\s0
environment variable or have a handler for the \s-1SIGILL. \s0 If you can
compile programs for \s-1PASE,\s0 run the config script and edit config.sh
when it gives you the option.  If you want to remove \fIfchdir()\fR, which
isn't implement in V5R1, simply change the line that says:
.PP
d_fchdir='define'
.PP
to
.PP
d_fchdir='undef'
.PP
and then compile Perl.  The places where \fIfchdir()\fR is used have
alternatives for systems that do not have \fIfchdir()\fR available.
.SS "Perl on \s-1ILE\s0"
.IX Subsection "Perl on ILE"
There exists a port of Perl to the \s-1ILE\s0 environment.  This port, however,
is based quite an old release of Perl, Perl 5.00502 (August 1998).
(As of July 2002 the latest release of Perl is 5.8.0, and even 5.6.1
has been out since April 2001.)  If you need to run Perl on \s-1ILE,\s0 though,
you may need this older port: <http://www.cpan.org/ports/#os400>
Note that any Perl release later than 5.00502 has not been ported to \s-1ILE.\s0
.PP
If you need to use Perl in the \s-1ILE\s0 environment, you may want to consider
using \fIQp2RunPase()\fR to call the \s-1PASE\s0 version of Perl.
.SH "AUTHORS"
.IX Header "AUTHORS"
Jarkko Hietaniemi <jhi@iki.fi>
Bryan Logan <bryanlog@us.ibm.com>
David Larson <larson1@us.ibm.com>
                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlpacktut.1                                0100644 0001750 0001750 00000173636 12566207443 023317  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPACKTUT 1"
.TH PERLPACKTUT 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpacktut \- tutorial on "pack" and "unpack"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR are two functions for transforming data according
to a user-defined template, between the guarded way Perl stores values
and some well-defined representation as might be required in the 
environment of a Perl program. Unfortunately, they're also two of 
the most misunderstood and most often overlooked functions that Perl
provides. This tutorial will demystify them for you.
.SH "The Basic Principle"
.IX Header "The Basic Principle"
Most programming languages don't shelter the memory where variables are
stored. In C, for instance, you can take the address of some variable,
and the \f(CW\*(C`sizeof\*(C'\fR operator tells you how many bytes are allocated to
the variable. Using the address and the size, you may access the storage
to your heart's content.
.PP
In Perl, you just can't access memory at random, but the structural and
representational conversion provided by \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR is an
excellent alternative. The \f(CW\*(C`pack\*(C'\fR function converts values to a byte
sequence containing representations according to a given specification,
the so-called \*(L"template\*(R" argument. \f(CW\*(C`unpack\*(C'\fR is the reverse process,
deriving some values from the contents of a string of bytes. (Be cautioned,
however, that not all that has been packed together can be neatly unpacked \- 
a very common experience as seasoned travellers are likely to confirm.)
.PP
Why, you may ask, would you need a chunk of memory containing some values
in binary representation? One good reason is input and output accessing
some file, a device, or a network connection, whereby this binary
representation is either forced on you or will give you some benefit
in processing. Another cause is passing data to some system call that
is not available as a Perl function: \f(CW\*(C`syscall\*(C'\fR requires you to provide
parameters stored in the way it happens in a C program. Even text processing 
(as shown in the next section) may be simplified with judicious usage 
of these two functions.
.PP
To see how (un)packing works, we'll start with a simple template
code where the conversion is in low gear: between the contents of a byte
sequence and a string of hexadecimal digits. Let's use \f(CW\*(C`unpack\*(C'\fR, since
this is likely to remind you of a dump program, or some desperate last
message unfortunate programs are wont to throw at you before they expire
into the wild blue yonder. Assuming that the variable \f(CW$mem\fR holds a 
sequence of bytes that we'd like to inspect without assuming anything 
about its meaning, we can write
.PP
.Vb 2
\&   my( $hex ) = unpack( \*(AqH*\*(Aq, $mem );
\&   print "$hex\en";
.Ve
.PP
whereupon we might see something like this, with each pair of hex digits
corresponding to a byte:
.PP
.Vb 1
\&   41204d414e204120504c414e20412043414e414c2050414e414d41
.Ve
.PP
What was in this chunk of memory? Numbers, characters, or a mixture of
both? Assuming that we're on a computer where \s-1ASCII \s0(or some similar)
encoding is used: hexadecimal values in the range \f(CW0x40\fR \- \f(CW0x5A\fR
indicate an uppercase letter, and \f(CW0x20\fR encodes a space. So we might
assume it is a piece of text, which some are able to read like a tabloid;
but others will have to get hold of an \s-1ASCII\s0 table and relive that
firstgrader feeling. Not caring too much about which way to read this,
we note that \f(CW\*(C`unpack\*(C'\fR with the template code \f(CW\*(C`H\*(C'\fR converts the contents
of a sequence of bytes into the customary hexadecimal notation. Since
\&\*(L"a sequence of\*(R" is a pretty vague indication of quantity, \f(CW\*(C`H\*(C'\fR has been
defined to convert just a single hexadecimal digit unless it is followed
by a repeat count. An asterisk for the repeat count means to use whatever
remains.
.PP
The inverse operation \- packing byte contents from a string of hexadecimal
digits \- is just as easily written. For instance:
.PP
.Vb 2
\&   my $s = pack( \*(AqH2\*(Aq x 10, 30..39 );
\&   print "$s\en";
.Ve
.PP
Since we feed a list of ten 2\-digit hexadecimal strings to \f(CW\*(C`pack\*(C'\fR, the
pack template should contain ten pack codes. If this is run on a computer
with \s-1ASCII\s0 character coding, it will print \f(CW0123456789\fR.
.SH "Packing Text"
.IX Header "Packing Text"
Let's suppose you've got to read in a data file like this:
.PP
.Vb 4
\&    Date      |Description                | Income|Expenditure
\&    01/24/2001 Zed\*(Aqs Camel Emporium                    1147.99
\&    01/28/2001 Flea spray                                24.99
\&    01/29/2001 Camel rides to tourists      235.00
.Ve
.PP
How do we do it? You might think first to use \f(CW\*(C`split\*(C'\fR; however, since
\&\f(CW\*(C`split\*(C'\fR collapses blank fields, you'll never know whether a record was
income or expenditure. Oops. Well, you could always use \f(CW\*(C`substr\*(C'\fR:
.PP
.Vb 7
\&    while (<>) { 
\&        my $date   = substr($_,  0, 11);
\&        my $desc   = substr($_, 12, 27);
\&        my $income = substr($_, 40,  7);
\&        my $expend = substr($_, 52,  7);
\&        ...
\&    }
.Ve
.PP
It's not really a barrel of laughs, is it? In fact, it's worse than it
may seem; the eagle-eyed may notice that the first field should only be
10 characters wide, and the error has propagated right through the other
numbers \- which we've had to count by hand. So it's error-prone as well
as horribly unfriendly.
.PP
Or maybe we could use regular expressions:
.PP
.Vb 5
\&    while (<>) { 
\&        my($date, $desc, $income, $expend) = 
\&            m|(\ed\ed/\ed\ed/\ed{4}) (.{27}) (.{7})(.*)|;
\&        ...
\&    }
.Ve
.PP
Urgh. Well, it's a bit better, but \- well, would you want to maintain
that?
.PP
Hey, isn't Perl supposed to make this sort of thing easy? Well, it does,
if you use the right tools. \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR are designed to help
you out when dealing with fixed-width data like the above. Let's have a
look at a solution with \f(CW\*(C`unpack\*(C'\fR:
.PP
.Vb 4
\&    while (<>) { 
\&        my($date, $desc, $income, $expend) = unpack("A10xA27xA7A*", $_);
\&        ...
\&    }
.Ve
.PP
That looks a bit nicer; but we've got to take apart that weird template.
Where did I pull that out of?
.PP
\&\s-1OK,\s0 let's have a look at some of our data again; in fact, we'll include
the headers, and a handy ruler so we can keep track of where we are.
.PP
.Vb 5
\&             1         2         3         4         5        
\&    1234567890123456789012345678901234567890123456789012345678
\&    Date      |Description                | Income|Expenditure
\&    01/28/2001 Flea spray                                24.99
\&    01/29/2001 Camel rides to tourists      235.00
.Ve
.PP
From this, we can see that the date column stretches from column 1 to
column 10 \- ten characters wide. The \f(CW\*(C`pack\*(C'\fR\-ese for \*(L"character\*(R" is
\&\f(CW\*(C`A\*(C'\fR, and ten of them are \f(CW\*(C`A10\*(C'\fR. So if we just wanted to extract the
dates, we could say this:
.PP
.Vb 1
\&    my($date) = unpack("A10", $_);
.Ve
.PP
\&\s-1OK,\s0 what's next? Between the date and the description is a blank column;
we want to skip over that. The \f(CW\*(C`x\*(C'\fR template means \*(L"skip forward\*(R", so we
want one of those. Next, we have another batch of characters, from 12 to
38. That's 27 more characters, hence \f(CW\*(C`A27\*(C'\fR. (Don't make the fencepost
error \- there are 27 characters between 12 and 38, not 26. Count 'em!)
.PP
Now we skip another character and pick up the next 7 characters:
.PP
.Vb 1
\&    my($date,$description,$income) = unpack("A10xA27xA7", $_);
.Ve
.PP
Now comes the clever bit. Lines in our ledger which are just income and
not expenditure might end at column 46. Hence, we don't want to tell our
\&\f(CW\*(C`unpack\*(C'\fR pattern that we \fBneed\fR to find another 12 characters; we'll
just say \*(L"if there's anything left, take it\*(R". As you might guess from
regular expressions, that's what the \f(CW\*(C`*\*(C'\fR means: \*(L"use everything
remaining\*(R".
.IP "\(bu" 3
Be warned, though, that unlike regular expressions, if the \f(CW\*(C`unpack\*(C'\fR
template doesn't match the incoming data, Perl will scream and die.
.PP
Hence, putting it all together:
.PP
.Vb 1
\&    my($date,$description,$income,$expend) = unpack("A10xA27xA7xA*", $_);
.Ve
.PP
Now, that's our data parsed. I suppose what we might want to do now is
total up our income and expenditure, and add another line to the end of
our ledger \- in the same format \- saying how much we've brought in and
how much we've spent:
.PP
.Vb 5
\&    while (<>) {
\&        my($date, $desc, $income, $expend) = unpack("A10xA27xA7xA*", $_);
\&        $tot_income += $income;
\&        $tot_expend += $expend;
\&    }
\&
\&    $tot_income = sprintf("%.2f", $tot_income); # Get them into 
\&    $tot_expend = sprintf("%.2f", $tot_expend); # "financial" format
\&
\&    $date = POSIX::strftime("%m/%d/%Y", localtime); 
\&
\&    # OK, let\*(Aqs go:
\&
\&    print pack("A10xA27xA7xA*", $date, "Totals", $tot_income, $tot_expend);
.Ve
.PP
Oh, hmm. That didn't quite work. Let's see what happened:
.PP
.Vb 4
\&    01/24/2001 Zed\*(Aqs Camel Emporium                     1147.99
\&    01/28/2001 Flea spray                                 24.99
\&    01/29/2001 Camel rides to tourists     1235.00
\&    03/23/2001Totals                     1235.001172.98
.Ve
.PP
\&\s-1OK,\s0 it's a start, but what happened to the spaces? We put \f(CW\*(C`x\*(C'\fR, didn't
we? Shouldn't it skip forward? Let's look at what \*(L"pack\*(R" in perlfunc says:
.PP
.Vb 1
\&    x   A null byte.
.Ve
.PP
Urgh. No wonder. There's a big difference between \*(L"a null byte\*(R",
character zero, and \*(L"a space\*(R", character 32. Perl's put something
between the date and the description \- but unfortunately, we can't see
it!
.PP
What we actually need to do is expand the width of the fields. The \f(CW\*(C`A\*(C'\fR
format pads any non-existent characters with spaces, so we can use the
additional spaces to line up our fields, like this:
.PP
.Vb 1
\&    print pack("A11 A28 A8 A*", $date, "Totals", $tot_income, $tot_expend);
.Ve
.PP
(Note that you can put spaces in the template to make it more readable,
but they don't translate to spaces in the output.) Here's what we got
this time:
.PP
.Vb 4
\&    01/24/2001 Zed\*(Aqs Camel Emporium                     1147.99
\&    01/28/2001 Flea spray                                 24.99
\&    01/29/2001 Camel rides to tourists     1235.00
\&    03/23/2001 Totals                      1235.00 1172.98
.Ve
.PP
That's a bit better, but we still have that last column which needs to
be moved further over. There's an easy way to fix this up:
unfortunately, we can't get \f(CW\*(C`pack\*(C'\fR to right-justify our fields, but we
can get \f(CW\*(C`sprintf\*(C'\fR to do it:
.PP
.Vb 4
\&    $tot_income = sprintf("%.2f", $tot_income); 
\&    $tot_expend = sprintf("%12.2f", $tot_expend);
\&    $date = POSIX::strftime("%m/%d/%Y", localtime); 
\&    print pack("A11 A28 A8 A*", $date, "Totals", $tot_income, $tot_expend);
.Ve
.PP
This time we get the right answer:
.PP
.Vb 3
\&    01/28/2001 Flea spray                                 24.99
\&    01/29/2001 Camel rides to tourists     1235.00
\&    03/23/2001 Totals                      1235.00      1172.98
.Ve
.PP
So that's how we consume and produce fixed-width data. Let's recap what
we've seen of \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR so far:
.IP "\(bu" 3
Use \f(CW\*(C`pack\*(C'\fR to go from several pieces of data to one fixed-width
version; use \f(CW\*(C`unpack\*(C'\fR to turn a fixed-width-format string into several
pieces of data.
.IP "\(bu" 3
The pack format \f(CW\*(C`A\*(C'\fR means \*(L"any character\*(R"; if you're \f(CW\*(C`pack\*(C'\fRing and
you've run out of things to pack, \f(CW\*(C`pack\*(C'\fR will fill the rest up with
spaces.
.IP "\(bu" 3
\&\f(CW\*(C`x\*(C'\fR means \*(L"skip a byte\*(R" when \f(CW\*(C`unpack\*(C'\fRing; when \f(CW\*(C`pack\*(C'\fRing, it means
\&\*(L"introduce a null byte\*(R" \- that's probably not what you mean if you're
dealing with plain text.
.IP "\(bu" 3
You can follow the formats with numbers to say how many characters
should be affected by that format: \f(CW\*(C`A12\*(C'\fR means \*(L"take 12 characters\*(R";
\&\f(CW\*(C`x6\*(C'\fR means \*(L"skip 6 bytes\*(R" or \*(L"character 0, 6 times\*(R".
.IP "\(bu" 3
Instead of a number, you can use \f(CW\*(C`*\*(C'\fR to mean \*(L"consume everything else
left\*(R".
.Sp
\&\fBWarning\fR: when packing multiple pieces of data, \f(CW\*(C`*\*(C'\fR only means
\&\*(L"consume all of the current piece of data\*(R". That's to say
.Sp
.Vb 1
\&    pack("A*A*", $one, $two)
.Ve
.Sp
packs all of \f(CW$one\fR into the first \f(CW\*(C`A*\*(C'\fR and then all of \f(CW$two\fR into
the second. This is a general principle: each format character
corresponds to one piece of data to be \f(CW\*(C`pack\*(C'\fRed.
.SH "Packing Numbers"
.IX Header "Packing Numbers"
So much for textual data. Let's get onto the meaty stuff that \f(CW\*(C`pack\*(C'\fR
and \f(CW\*(C`unpack\*(C'\fR are best at: handling binary formats for numbers. There is,
of course, not just one binary format  \- life would be too simple \- but
Perl will do all the finicky labor for you.
.SS "Integers"
.IX Subsection "Integers"
Packing and unpacking numbers implies conversion to and from some
\&\fIspecific\fR binary representation. Leaving floating point numbers
aside for the moment, the salient properties of any such representation
are:
.IP "\(bu" 4
the number of bytes used for storing the integer,
.IP "\(bu" 4
whether the contents are interpreted as a signed or unsigned number,
.IP "\(bu" 4
the byte ordering: whether the first byte is the least or most
significant byte (or: little-endian or big-endian, respectively).
.PP
So, for instance, to pack 20302 to a signed 16 bit integer in your
computer's representation you write
.PP
.Vb 1
\&   my $ps = pack( \*(Aqs\*(Aq, 20302 );
.Ve
.PP
Again, the result is a string, now containing 2 bytes. If you print 
this string (which is, generally, not recommended) you might see
\&\f(CW\*(C`ON\*(C'\fR or \f(CW\*(C`NO\*(C'\fR (depending on your system's byte ordering) \- or something
entirely different if your computer doesn't use \s-1ASCII\s0 character encoding.
Unpacking \f(CW$ps\fR with the same template returns the original integer value:
.PP
.Vb 1
\&   my( $s ) = unpack( \*(Aqs\*(Aq, $ps );
.Ve
.PP
This is true for all numeric template codes. But don't expect miracles:
if the packed value exceeds the allotted byte capacity, high order bits
are silently discarded, and unpack certainly won't be able to pull them
back out of some magic hat. And, when you pack using a signed template
code such as \f(CW\*(C`s\*(C'\fR, an excess value may result in the sign bit
getting set, and unpacking this will smartly return a negative value.
.PP
16 bits won't get you too far with integers, but there is \f(CW\*(C`l\*(C'\fR and \f(CW\*(C`L\*(C'\fR
for signed and unsigned 32\-bit integers. And if this is not enough and
your system supports 64 bit integers you can push the limits much closer
to infinity with pack codes \f(CW\*(C`q\*(C'\fR and \f(CW\*(C`Q\*(C'\fR. A notable exception is provided
by pack codes \f(CW\*(C`i\*(C'\fR and \f(CW\*(C`I\*(C'\fR for signed and unsigned integers of the 
\&\*(L"local custom\*(R" variety: Such an integer will take up as many bytes as
a local C compiler returns for \f(CW\*(C`sizeof(int)\*(C'\fR, but it'll use \fIat least\fR
32 bits.
.PP
Each of the integer pack codes \f(CW\*(C`sSlLqQ\*(C'\fR results in a fixed number of bytes,
no matter where you execute your program. This may be useful for some 
applications, but it does not provide for a portable way to pass data 
structures between Perl and C programs (bound to happen when you call 
\&\s-1XS\s0 extensions or the Perl function \f(CW\*(C`syscall\*(C'\fR), or when you read or
write binary files. What you'll need in this case are template codes that
depend on what your local C compiler compiles when you code \f(CW\*(C`short\*(C'\fR or
\&\f(CW\*(C`unsigned long\*(C'\fR, for instance. These codes and their corresponding
byte lengths are shown in the table below.  Since the C standard leaves
much leeway with respect to the relative sizes of these data types, actual
values may vary, and that's why the values are given as expressions in
C and Perl. (If you'd like to use values from \f(CW%Config\fR in your program
you have to import it with \f(CW\*(C`use Config\*(C'\fR.)
.PP
.Vb 5
\&   signed unsigned  byte length in C   byte length in Perl       
\&     s!     S!      sizeof(short)      $Config{shortsize}
\&     i!     I!      sizeof(int)        $Config{intsize}
\&     l!     L!      sizeof(long)       $Config{longsize}
\&     q!     Q!      sizeof(long long)  $Config{longlongsize}
.Ve
.PP
The \f(CW\*(C`i!\*(C'\fR and \f(CW\*(C`I!\*(C'\fR codes aren't different from \f(CW\*(C`i\*(C'\fR and \f(CW\*(C`I\*(C'\fR; they are
tolerated for completeness' sake.
.SS "Unpacking a Stack Frame"
.IX Subsection "Unpacking a Stack Frame"
Requesting a particular byte ordering may be necessary when you work with
binary data coming from some specific architecture whereas your program could
run on a totally different system. As an example, assume you have 24 bytes
containing a stack frame as it happens on an Intel 8086:
.PP
.Vb 11
\&      +\-\-\-\-\-\-\-\-\-+        +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\& TOS: |   IP    |  TOS+4:| FL | FH | FLAGS  TOS+14:|   SI    |
\&      +\-\-\-\-\-\-\-\-\-+        +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\&      |   CS    |        | AL | AH | AX            |   DI    |
\&      +\-\-\-\-\-\-\-\-\-+        +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\&                         | BL | BH | BX            |   BP    |
\&                         +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\&                         | CL | CH | CX            |   DS    |
\&                         +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\&                         | DL | DH | DX            |   ES    |
\&                         +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
.Ve
.PP
First, we note that this time-honored 16\-bit \s-1CPU\s0 uses little-endian order,
and that's why the low order byte is stored at the lower address. To
unpack such a (unsigned) short we'll have to use code \f(CW\*(C`v\*(C'\fR. A repeat
count unpacks all 12 shorts:
.PP
.Vb 2
\&   my( $ip, $cs, $flags, $ax, $bx, $cd, $dx, $si, $di, $bp, $ds, $es ) =
\&     unpack( \*(Aqv12\*(Aq, $frame );
.Ve
.PP
Alternatively, we could have used \f(CW\*(C`C\*(C'\fR to unpack the individually
accessible byte registers \s-1FL, FH, AL, AH,\s0 etc.:
.PP
.Vb 2
\&   my( $fl, $fh, $al, $ah, $bl, $bh, $cl, $ch, $dl, $dh ) =
\&     unpack( \*(AqC10\*(Aq, substr( $frame, 4, 10 ) );
.Ve
.PP
It would be nice if we could do this in one fell swoop: unpack a short,
back up a little, and then unpack 2 bytes. Since Perl \fIis\fR nice, it
proffers the template code \f(CW\*(C`X\*(C'\fR to back up one byte. Putting this all
together, we may now write:
.PP
.Vb 5
\&   my( $ip, $cs,
\&       $flags,$fl,$fh,
\&       $ax,$al,$ah, $bx,$bl,$bh, $cx,$cl,$ch, $dx,$dl,$dh, 
\&       $si, $di, $bp, $ds, $es ) =
\&   unpack( \*(Aqv2\*(Aq . (\*(AqvXXCC\*(Aq x 5) . \*(Aqv5\*(Aq, $frame );
.Ve
.PP
(The clumsy construction of the template can be avoided \- just read on!)
.PP
We've taken some pains to construct the template so that it matches
the contents of our frame buffer. Otherwise we'd either get undefined values,
or \f(CW\*(C`unpack\*(C'\fR could not unpack all. If \f(CW\*(C`pack\*(C'\fR runs out of items, it will
supply null strings (which are coerced into zeroes whenever the pack code
says so).
.SS "How to Eat an Egg on a Net"
.IX Subsection "How to Eat an Egg on a Net"
The pack code for big-endian (high order byte at the lowest address) is
\&\f(CW\*(C`n\*(C'\fR for 16 bit and \f(CW\*(C`N\*(C'\fR for 32 bit integers. You use these codes
if you know that your data comes from a compliant architecture, but,
surprisingly enough, you should also use these pack codes if you
exchange binary data, across the network, with some system that you
know next to nothing about. The simple reason is that this
order has been chosen as the \fInetwork order\fR, and all standard-fearing
programs ought to follow this convention. (This is, of course, a stern
backing for one of the Lilliputian parties and may well influence the
political development there.) So, if the protocol expects you to send
a message by sending the length first, followed by just so many bytes,
you could write:
.PP
.Vb 1
\&   my $buf = pack( \*(AqN\*(Aq, length( $msg ) ) . $msg;
.Ve
.PP
or even:
.PP
.Vb 1
\&   my $buf = pack( \*(AqNA*\*(Aq, length( $msg ), $msg );
.Ve
.PP
and pass \f(CW$buf\fR to your send routine. Some protocols demand that the
count should include the length of the count itself: then just add 4
to the data length. (But make sure to read \*(L"Lengths and Widths\*(R" before
you really code this!)
.SS "Byte-order modifiers"
.IX Subsection "Byte-order modifiers"
In the previous sections we've learned how to use \f(CW\*(C`n\*(C'\fR, \f(CW\*(C`N\*(C'\fR, \f(CW\*(C`v\*(C'\fR and
\&\f(CW\*(C`V\*(C'\fR to pack and unpack integers with big\- or little-endian byte-order.
While this is nice, it's still rather limited because it leaves out all
kinds of signed integers as well as 64\-bit integers. For example, if you
wanted to unpack a sequence of signed big-endian 16\-bit integers in a
platform-independent way, you would have to write:
.PP
.Vb 1
\&   my @data = unpack \*(Aqs*\*(Aq, pack \*(AqS*\*(Aq, unpack \*(Aqn*\*(Aq, $buf;
.Ve
.PP
This is ugly. As of Perl 5.9.2, there's a much nicer way to express your
desire for a certain byte-order: the \f(CW\*(C`>\*(C'\fR and \f(CW\*(C`<\*(C'\fR modifiers.
\&\f(CW\*(C`>\*(C'\fR is the big-endian modifier, while \f(CW\*(C`<\*(C'\fR is the little-endian
modifier. Using them, we could rewrite the above code as:
.PP
.Vb 1
\&   my @data = unpack \*(Aqs>*\*(Aq, $buf;
.Ve
.PP
As you can see, the \*(L"big end\*(R" of the arrow touches the \f(CW\*(C`s\*(C'\fR, which is a
nice way to remember that \f(CW\*(C`>\*(C'\fR is the big-endian modifier. The same
obviously works for \f(CW\*(C`<\*(C'\fR, where the \*(L"little end\*(R" touches the code.
.PP
You will probably find these modifiers even more useful if you have
to deal with big\- or little-endian C structures. Be sure to read
\&\*(L"Packing and Unpacking C Structures\*(R" for more on that.
.SS "Floating point Numbers"
.IX Subsection "Floating point Numbers"
For packing floating point numbers you have the choice between the
pack codes \f(CW\*(C`f\*(C'\fR, \f(CW\*(C`d\*(C'\fR, \f(CW\*(C`F\*(C'\fR and \f(CW\*(C`D\*(C'\fR. \f(CW\*(C`f\*(C'\fR and \f(CW\*(C`d\*(C'\fR pack into (or unpack
from) single-precision or double-precision representation as it is provided
by your system. If your systems supports it, \f(CW\*(C`D\*(C'\fR can be used to pack and
unpack extended-precision floating point values (\f(CW\*(C`long double\*(C'\fR), which
can offer even more resolution than \f(CW\*(C`f\*(C'\fR or \f(CW\*(C`d\*(C'\fR. \f(CW\*(C`F\*(C'\fR packs an \f(CW\*(C`NV\*(C'\fR,
which is the floating point type used by Perl internally. (There
is no such thing as a network representation for reals, so if you want
to send your real numbers across computer boundaries, you'd better stick
to \s-1ASCII\s0 representation, unless you're absolutely sure what's on the other
end of the line. For the even more adventuresome, you can use the byte-order
modifiers from the previous section also on floating point codes.)
.SH "Exotic Templates"
.IX Header "Exotic Templates"
.SS "Bit Strings"
.IX Subsection "Bit Strings"
Bits are the atoms in the memory world. Access to individual bits may
have to be used either as a last resort or because it is the most
convenient way to handle your data. Bit string (un)packing converts
between strings containing a series of \f(CW0\fR and \f(CW1\fR characters and
a sequence of bytes each containing a group of 8 bits. This is almost
as simple as it sounds, except that there are two ways the contents of
a byte may be written as a bit string. Let's have a look at an annotated
byte:
.PP
.Vb 5
\&     7 6 5 4 3 2 1 0
\&   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&   | 1 0 0 0 1 1 0 0 |
\&   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    MSB           LSB
.Ve
.PP
It's egg-eating all over again: Some think that as a bit string this should
be written \*(L"10001100\*(R" i.e. beginning with the most significant bit, others
insist on \*(L"00110001\*(R". Well, Perl isn't biased, so that's why we have two bit
string codes:
.PP
.Vb 2
\&   $byte = pack( \*(AqB8\*(Aq, \*(Aq10001100\*(Aq ); # start with MSB
\&   $byte = pack( \*(Aqb8\*(Aq, \*(Aq00110001\*(Aq ); # start with LSB
.Ve
.PP
It is not possible to pack or unpack bit fields \- just integral bytes.
\&\f(CW\*(C`pack\*(C'\fR always starts at the next byte boundary and \*(L"rounds up\*(R" to the
next multiple of 8 by adding zero bits as required. (If you do want bit
fields, there is \*(L"vec\*(R" in perlfunc. Or you could implement bit field 
handling at the character string level, using split, substr, and
concatenation on unpacked bit strings.)
.PP
To illustrate unpacking for bit strings, we'll decompose a simple
status register (a \*(L"\-\*(R" stands for a \*(L"reserved\*(R" bit):
.PP
.Vb 4
\&   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&   | S Z \- A \- P \- C | \- \- \- \- O D I T |
\&   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    MSB           LSB MSB           LSB
.Ve
.PP
Converting these two bytes to a string can be done with the unpack 
template \f(CW\*(Aqb16\*(Aq\fR. To obtain the individual bit values from the bit
string we use \f(CW\*(C`split\*(C'\fR with the \*(L"empty\*(R" separator pattern which dissects
into individual characters. Bit values from the \*(L"reserved\*(R" positions are
simply assigned to \f(CW\*(C`undef\*(C'\fR, a convenient notation for \*(L"I don't care where
this goes\*(R".
.PP
.Vb 3
\&   ($carry, undef, $parity, undef, $auxcarry, undef, $zero, $sign,
\&    $trace, $interrupt, $direction, $overflow) =
\&      split( //, unpack( \*(Aqb16\*(Aq, $status ) );
.Ve
.PP
We could have used an unpack template \f(CW\*(Aqb12\*(Aq\fR just as well, since the
last 4 bits can be ignored anyway.
.SS "Uuencoding"
.IX Subsection "Uuencoding"
Another odd-man-out in the template alphabet is \f(CW\*(C`u\*(C'\fR, which packs an
\&\*(L"uuencoded string\*(R". (\*(L"uu\*(R" is short for Unix-to-Unix.) Chances are that
you won't ever need this encoding technique which was invented to overcome
the shortcomings of old-fashioned transmission mediums that do not support
other than simple \s-1ASCII\s0 data. The essential recipe is simple: Take three 
bytes, or 24 bits. Split them into 4 six-packs, adding a space (0x20) to 
each. Repeat until all of the data is blended. Fold groups of 4 bytes into 
lines no longer than 60 and garnish them in front with the original byte count 
(incremented by 0x20) and a \f(CW"\en"\fR at the end. \- The \f(CW\*(C`pack\*(C'\fR chef will
prepare this for you, a la minute, when you select pack code \f(CW\*(C`u\*(C'\fR on the menu:
.PP
.Vb 1
\&   my $uubuf = pack( \*(Aqu\*(Aq, $bindat );
.Ve
.PP
A repeat count after \f(CW\*(C`u\*(C'\fR sets the number of bytes to put into an
uuencoded line, which is the maximum of 45 by default, but could be
set to some (smaller) integer multiple of three. \f(CW\*(C`unpack\*(C'\fR simply ignores
the repeat count.
.SS "Doing Sums"
.IX Subsection "Doing Sums"
An even stranger template code is \f(CW\*(C`%\*(C'\fR<\fInumber\fR>. First, because 
it's used as a prefix to some other template code. Second, because it
cannot be used in \f(CW\*(C`pack\*(C'\fR at all, and third, in \f(CW\*(C`unpack\*(C'\fR, doesn't return the
data as defined by the template code it precedes. Instead it'll give you an
integer of \fInumber\fR bits that is computed from the data value by 
doing sums. For numeric unpack codes, no big feat is achieved:
.PP
.Vb 2
\&    my $buf = pack( \*(Aqiii\*(Aq, 100, 20, 3 );
\&    print unpack( \*(Aq%32i3\*(Aq, $buf ), "\en";  # prints 123
.Ve
.PP
For string values, \f(CW\*(C`%\*(C'\fR returns the sum of the byte values saving
you the trouble of a sum loop with \f(CW\*(C`substr\*(C'\fR and \f(CW\*(C`ord\*(C'\fR:
.PP
.Vb 1
\&    print unpack( \*(Aq%32A*\*(Aq, "\ex01\ex10" ), "\en";  # prints 17
.Ve
.PP
Although the \f(CW\*(C`%\*(C'\fR code is documented as returning a \*(L"checksum\*(R":
don't put your trust in such values! Even when applied to a small number
of bytes, they won't guarantee a noticeable Hamming distance.
.PP
In connection with \f(CW\*(C`b\*(C'\fR or \f(CW\*(C`B\*(C'\fR, \f(CW\*(C`%\*(C'\fR simply adds bits, and this can be put
to good use to count set bits efficiently:
.PP
.Vb 1
\&    my $bitcount = unpack( \*(Aq%32b*\*(Aq, $mask );
.Ve
.PP
And an even parity bit can be determined like this:
.PP
.Vb 1
\&    my $evenparity = unpack( \*(Aq%1b*\*(Aq, $mask );
.Ve
.SS "Unicode"
.IX Subsection "Unicode"
Unicode is a character set that can represent most characters in most of
the world's languages, providing room for over one million different
characters. Unicode 3.1 specifies 94,140 characters: The Basic Latin
characters are assigned to the numbers 0 \- 127. The Latin\-1 Supplement with
characters that are used in several European languages is in the next
range, up to 255. After some more Latin extensions we find the character
sets from languages using non-Roman alphabets, interspersed with a
variety of symbol sets such as currency symbols, Zapf Dingbats or Braille.
(You might want to visit <http://www.unicode.org/> for a look at some of
them \- my personal favourites are Telugu and Kannada.)
.PP
The Unicode character sets associates characters with integers. Encoding
these numbers in an equal number of bytes would more than double the
requirements for storing texts written in Latin alphabets.
The \s-1UTF\-8\s0 encoding avoids this by storing the most common (from a western
point of view) characters in a single byte while encoding the rarer
ones in three or more bytes.
.PP
Perl uses \s-1UTF\-8,\s0 internally, for most Unicode strings.
.PP
So what has this got to do with \f(CW\*(C`pack\*(C'\fR? Well, if you want to compose a
Unicode string (that is internally encoded as \s-1UTF\-8\s0), you can do so by
using template code \f(CW\*(C`U\*(C'\fR. As an example, let's produce the Euro currency
symbol (code number 0x20AC):
.PP
.Vb 2
\&   $UTF8{Euro} = pack( \*(AqU\*(Aq, 0x20AC );
\&   # Equivalent to: $UTF8{Euro} = "\ex{20ac}";
.Ve
.PP
Inspecting \f(CW$UTF8{Euro}\fR shows that it contains 3 bytes:
\&\*(L"\exe2\ex82\exac\*(R". However, it contains only 1 character, number 0x20AC.
The round trip can be completed with \f(CW\*(C`unpack\*(C'\fR:
.PP
.Vb 1
\&   $Unicode{Euro} = unpack( \*(AqU\*(Aq, $UTF8{Euro} );
.Ve
.PP
Unpacking using the \f(CW\*(C`U\*(C'\fR template code also works on \s-1UTF\-8\s0 encoded byte
strings.
.PP
Usually you'll want to pack or unpack \s-1UTF\-8\s0 strings:
.PP
.Vb 3
\&   # pack and unpack the Hebrew alphabet
\&   my $alefbet = pack( \*(AqU*\*(Aq, 0x05d0..0x05ea );
\&   my @hebrew = unpack( \*(AqU*\*(Aq, $utf );
.Ve
.PP
Please note: in the general case, you're better off using
Encode::decode_utf8 to decode a \s-1UTF\-8\s0 encoded byte string to a Perl
Unicode string, and Encode::encode_utf8 to encode a Perl Unicode string
to \s-1UTF\-8\s0 bytes. These functions provide means of handling invalid byte
sequences and generally have a friendlier interface.
.SS "Another Portable Binary Encoding"
.IX Subsection "Another Portable Binary Encoding"
The pack code \f(CW\*(C`w\*(C'\fR has been added to support a portable binary data
encoding scheme that goes way beyond simple integers. (Details can
be found at <http://Casbah.org/>, the Scarab project.)  A \s-1BER \s0(Binary Encoded
Representation) compressed unsigned integer stores base 128
digits, most significant digit first, with as few digits as possible.
Bit eight (the high bit) is set on each byte except the last. There
is no size limit to \s-1BER\s0 encoding, but Perl won't go to extremes.
.PP
.Vb 1
\&   my $berbuf = pack( \*(Aqw*\*(Aq, 1, 128, 128+1, 128*128+127 );
.Ve
.PP
A hex dump of \f(CW$berbuf\fR, with spaces inserted at the right places,
shows 01 8100 8101 81807F. Since the last byte is always less than
128, \f(CW\*(C`unpack\*(C'\fR knows where to stop.
.SH "Template Grouping"
.IX Header "Template Grouping"
Prior to Perl 5.8, repetitions of templates had to be made by
\&\f(CW\*(C`x\*(C'\fR\-multiplication of template strings. Now there is a better way as
we may use the pack codes \f(CW\*(C`(\*(C'\fR and \f(CW\*(C`)\*(C'\fR combined with a repeat count.
The \f(CW\*(C`unpack\*(C'\fR template from the Stack Frame example can simply
be written like this:
.PP
.Vb 1
\&   unpack( \*(Aqv2 (vXXCC)5 v5\*(Aq, $frame )
.Ve
.PP
Let's explore this feature a little more. We'll begin with the equivalent of
.PP
.Vb 1
\&   join( \*(Aq\*(Aq, map( substr( $_, 0, 1 ), @str ) )
.Ve
.PP
which returns a string consisting of the first character from each string.
Using pack, we can write
.PP
.Vb 1
\&   pack( \*(Aq(A)\*(Aq.@str, @str )
.Ve
.PP
or, because a repeat count \f(CW\*(C`*\*(C'\fR means \*(L"repeat as often as required\*(R",
simply
.PP
.Vb 1
\&   pack( \*(Aq(A)*\*(Aq, @str )
.Ve
.PP
(Note that the template \f(CW\*(C`A*\*(C'\fR would only have packed \f(CW$str[0]\fR in full
length.)
.PP
To pack dates stored as triplets ( day, month, year ) in an array \f(CW@dates\fR
into a sequence of byte, byte, short integer we can write
.PP
.Vb 1
\&   $pd = pack( \*(Aq(CCS)*\*(Aq, map( @$_, @dates ) );
.Ve
.PP
To swap pairs of characters in a string (with even length) one could use
several techniques. First, let's use \f(CW\*(C`x\*(C'\fR and \f(CW\*(C`X\*(C'\fR to skip forward and back:
.PP
.Vb 1
\&   $s = pack( \*(Aq(A)*\*(Aq, unpack( \*(Aq(xAXXAx)*\*(Aq, $s ) );
.Ve
.PP
We can also use \f(CW\*(C`@\*(C'\fR to jump to an offset, with 0 being the position where
we were when the last \f(CW\*(C`(\*(C'\fR was encountered:
.PP
.Vb 1
\&   $s = pack( \*(Aq(A)*\*(Aq, unpack( \*(Aq(@1A @0A @2)*\*(Aq, $s ) );
.Ve
.PP
Finally, there is also an entirely different approach by unpacking big
endian shorts and packing them in the reverse byte order:
.PP
.Vb 1
\&   $s = pack( \*(Aq(v)*\*(Aq, unpack( \*(Aq(n)*\*(Aq, $s );
.Ve
.SH "Lengths and Widths"
.IX Header "Lengths and Widths"
.SS "String Lengths"
.IX Subsection "String Lengths"
In the previous section we've seen a network message that was constructed
by prefixing the binary message length to the actual message. You'll find
that packing a length followed by so many bytes of data is a 
frequently used recipe since appending a null byte won't work
if a null byte may be part of the data. Here is an example where both
techniques are used: after two null terminated strings with source and
destination address, a Short Message (to a mobile phone) is sent after
a length byte:
.PP
.Vb 1
\&   my $msg = pack( \*(AqZ*Z*CA*\*(Aq, $src, $dst, length( $sm ), $sm );
.Ve
.PP
Unpacking this message can be done with the same template:
.PP
.Vb 1
\&   ( $src, $dst, $len, $sm ) = unpack( \*(AqZ*Z*CA*\*(Aq, $msg );
.Ve
.PP
There's a subtle trap lurking in the offing: Adding another field after
the Short Message (in variable \f(CW$sm\fR) is all right when packing, but this
cannot be unpacked naively:
.PP
.Vb 2
\&   # pack a message
\&   my $msg = pack( \*(AqZ*Z*CA*C\*(Aq, $src, $dst, length( $sm ), $sm, $prio );
\&
\&   # unpack fails \- $prio remains undefined!
\&   ( $src, $dst, $len, $sm, $prio ) = unpack( \*(AqZ*Z*CA*C\*(Aq, $msg );
.Ve
.PP
The pack code \f(CW\*(C`A*\*(C'\fR gobbles up all remaining bytes, and \f(CW$prio\fR remains
undefined! Before we let disappointment dampen the morale: Perl's got
the trump card to make this trick too, just a little further up the sleeve.
Watch this:
.PP
.Vb 2
\&   # pack a message: ASCIIZ, ASCIIZ, length/string, byte
\&   my $msg = pack( \*(AqZ* Z* C/A* C\*(Aq, $src, $dst, $sm, $prio );
\&
\&   # unpack
\&   ( $src, $dst, $sm, $prio ) = unpack( \*(AqZ* Z* C/A* C\*(Aq, $msg );
.Ve
.PP
Combining two pack codes with a slash (\f(CW\*(C`/\*(C'\fR) associates them with a single
value from the argument list. In \f(CW\*(C`pack\*(C'\fR, the length of the argument is
taken and packed according to the first code while the argument itself
is added after being converted with the template code after the slash.
This saves us the trouble of inserting the \f(CW\*(C`length\*(C'\fR call, but it is 
in \f(CW\*(C`unpack\*(C'\fR where we really score: The value of the length byte marks the
end of the string to be taken from the buffer. Since this combination
doesn't make sense except when the second pack code isn't \f(CW\*(C`a*\*(C'\fR, \f(CW\*(C`A*\*(C'\fR
or \f(CW\*(C`Z*\*(C'\fR, Perl won't let you.
.PP
The pack code preceding \f(CW\*(C`/\*(C'\fR may be anything that's fit to represent a
number: All the numeric binary pack codes, and even text codes such as
\&\f(CW\*(C`A4\*(C'\fR or \f(CW\*(C`Z*\*(C'\fR:
.PP
.Vb 4
\&   # pack/unpack a string preceded by its length in ASCII
\&   my $buf = pack( \*(AqA4/A*\*(Aq, "Humpty\-Dumpty" );
\&   # unpack $buf: \*(Aq13  Humpty\-Dumpty\*(Aq
\&   my $txt = unpack( \*(AqA4/A*\*(Aq, $buf );
.Ve
.PP
\&\f(CW\*(C`/\*(C'\fR is not implemented in Perls before 5.6, so if your code is required to
work on older Perls you'll need to \f(CW\*(C`unpack( \*(AqZ* Z* C\*(Aq)\*(C'\fR to get the length,
then use it to make a new unpack string. For example
.PP
.Vb 2
\&   # pack a message: ASCIIZ, ASCIIZ, length, string, byte (5.005 compatible)
\&   my $msg = pack( \*(AqZ* Z* C A* C\*(Aq, $src, $dst, length $sm, $sm, $prio );
\&
\&   # unpack
\&   ( undef, undef, $len) = unpack( \*(AqZ* Z* C\*(Aq, $msg );
\&   ($src, $dst, $sm, $prio) = unpack ( "Z* Z* x A$len C", $msg );
.Ve
.PP
But that second \f(CW\*(C`unpack\*(C'\fR is rushing ahead. It isn't using a simple literal
string for the template. So maybe we should introduce...
.SS "Dynamic Templates"
.IX Subsection "Dynamic Templates"
So far, we've seen literals used as templates. If the list of pack
items doesn't have fixed length, an expression constructing the
template is required (whenever, for some reason, \f(CW\*(C`()*\*(C'\fR cannot be used).
Here's an example: To store named string values in a way that can be
conveniently parsed by a C program, we create a sequence of names and
null terminated \s-1ASCII\s0 strings, with \f(CW\*(C`=\*(C'\fR between the name and the value,
followed by an additional delimiting null byte. Here's how:
.PP
.Vb 2
\&   my $env = pack( \*(Aq(A*A*Z*)\*(Aq . keys( %Env ) . \*(AqC\*(Aq,
\&                   map( { ( $_, \*(Aq=\*(Aq, $Env{$_} ) } keys( %Env ) ), 0 );
.Ve
.PP
Let's examine the cogs of this byte mill, one by one. There's the \f(CW\*(C`map\*(C'\fR
call, creating the items we intend to stuff into the \f(CW$env\fR buffer:
to each key (in \f(CW$_\fR) it adds the \f(CW\*(C`=\*(C'\fR separator and the hash entry value.
Each triplet is packed with the template code sequence \f(CW\*(C`A*A*Z*\*(C'\fR that
is repeated according to the number of keys. (Yes, that's what the \f(CW\*(C`keys\*(C'\fR
function returns in scalar context.) To get the very last null byte,
we add a \f(CW0\fR at the end of the \f(CW\*(C`pack\*(C'\fR list, to be packed with \f(CW\*(C`C\*(C'\fR.
(Attentive readers may have noticed that we could have omitted the 0.)
.PP
For the reverse operation, we'll have to determine the number of items
in the buffer before we can let \f(CW\*(C`unpack\*(C'\fR rip it apart:
.PP
.Vb 2
\&   my $n = $env =~ tr/\e0// \- 1;
\&   my %env = map( split( /=/, $_ ), unpack( "(Z*)$n", $env ) );
.Ve
.PP
The \f(CW\*(C`tr\*(C'\fR counts the null bytes. The \f(CW\*(C`unpack\*(C'\fR call returns a list of
name-value pairs each of which is taken apart in the \f(CW\*(C`map\*(C'\fR block.
.SS "Counting Repetitions"
.IX Subsection "Counting Repetitions"
Rather than storing a sentinel at the end of a data item (or a list of items),
we could precede the data with a count. Again, we pack keys and values of
a hash, preceding each with an unsigned short length count, and up front
we store the number of pairs:
.PP
.Vb 1
\&   my $env = pack( \*(AqS(S/A* S/A*)*\*(Aq, scalar keys( %Env ), %Env );
.Ve
.PP
This simplifies the reverse operation as the number of repetitions can be
unpacked with the \f(CW\*(C`/\*(C'\fR code:
.PP
.Vb 1
\&   my %env = unpack( \*(AqS/(S/A* S/A*)\*(Aq, $env );
.Ve
.PP
Note that this is one of the rare cases where you cannot use the same
template for \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR because \f(CW\*(C`pack\*(C'\fR can't determine
a repeat count for a \f(CW\*(C`()\*(C'\fR\-group.
.SS "Intel \s-1HEX\s0"
.IX Subsection "Intel HEX"
Intel \s-1HEX\s0 is a file format for representing binary data, mostly for
programming various chips, as a text file. (See
<http://en.wikipedia.org/wiki/.hex> for a detailed description, and
<http://en.wikipedia.org/wiki/SREC_(file_format)> for the Motorola
S\-record format, which can be unravelled using the same technique.)
Each line begins with a colon (':') and is followed by a sequence of
hexadecimal characters, specifying a byte count \fIn\fR (8 bit),
an address (16 bit, big endian), a record type (8 bit), \fIn\fR data bytes
and a checksum (8 bit) computed as the least significant byte of the two's
complement sum of the preceding bytes. Example: \f(CW\*(C`:0300300002337A1E\*(C'\fR.
.PP
The first step of processing such a line is the conversion, to binary,
of the hexadecimal data, to obtain the four fields, while checking the
checksum. No surprise here: we'll start with a simple \f(CW\*(C`pack\*(C'\fR call to 
convert everything to binary:
.PP
.Vb 1
\&   my $binrec = pack( \*(AqH*\*(Aq, substr( $hexrec, 1 ) );
.Ve
.PP
The resulting byte sequence is most convenient for checking the checksum.
Don't slow your program down with a for loop adding the \f(CW\*(C`ord\*(C'\fR values
of this string's bytes \- the \f(CW\*(C`unpack\*(C'\fR code \f(CW\*(C`%\*(C'\fR is the thing to use
for computing the 8\-bit sum of all bytes, which must be equal to zero:
.PP
.Vb 1
\&   die unless unpack( "%8C*", $binrec ) == 0;
.Ve
.PP
Finally, let's get those four fields. By now, you shouldn't have any
problems with the first three fields \- but how can we use the byte count
of the data in the first field as a length for the data field? Here
the codes \f(CW\*(C`x\*(C'\fR and \f(CW\*(C`X\*(C'\fR come to the rescue, as they permit jumping
back and forth in the string to unpack.
.PP
.Vb 1
\&   my( $addr, $type, $data ) = unpack( "x n C X4 C x3 /a", $bin );
.Ve
.PP
Code \f(CW\*(C`x\*(C'\fR skips a byte, since we don't need the count yet. Code \f(CW\*(C`n\*(C'\fR takes
care of the 16\-bit big-endian integer address, and \f(CW\*(C`C\*(C'\fR unpacks the
record type. Being at offset 4, where the data begins, we need the count.
\&\f(CW\*(C`X4\*(C'\fR brings us back to square one, which is the byte at offset 0.
Now we pick up the count, and zoom forth to offset 4, where we are
now fully furnished to extract the exact number of data bytes, leaving
the trailing checksum byte alone.
.SH "Packing and Unpacking C Structures"
.IX Header "Packing and Unpacking C Structures"
In previous sections we have seen how to pack numbers and character
strings. If it were not for a couple of snags we could conclude this
section right away with the terse remark that C structures don't
contain anything else, and therefore you already know all there is to it.
Sorry, no: read on, please.
.PP
If you have to deal with a lot of C structures, and don't want to
hack all your template strings manually, you'll probably want to have
a look at the \s-1CPAN\s0 module \f(CW\*(C`Convert::Binary::C\*(C'\fR. Not only can it parse
your C source directly, but it also has built-in support for all the
odds and ends described further on in this section.
.SS "The Alignment Pit"
.IX Subsection "The Alignment Pit"
In the consideration of speed against memory requirements the balance
has been tilted in favor of faster execution. This has influenced the
way C compilers allocate memory for structures: On architectures
where a 16\-bit or 32\-bit operand can be moved faster between places in
memory, or to or from a \s-1CPU\s0 register, if it is aligned at an even or 
multiple-of-four or even at a multiple-of eight address, a C compiler
will give you this speed benefit by stuffing extra bytes into structures.
If you don't cross the C shoreline this is not likely to cause you any
grief (although you should care when you design large data structures,
or you want your code to be portable between architectures (you do want
that, don't you?)).
.PP
To see how this affects \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR, we'll compare these two
C structures:
.PP
.Vb 6
\&   typedef struct {
\&     char     c1;
\&     short    s;
\&     char     c2;
\&     long     l;
\&   } gappy_t;
\&
\&   typedef struct {
\&     long     l;
\&     short    s;
\&     char     c1;
\&     char     c2;
\&   } dense_t;
.Ve
.PP
Typically, a C compiler allocates 12 bytes to a \f(CW\*(C`gappy_t\*(C'\fR variable, but
requires only 8 bytes for a \f(CW\*(C`dense_t\*(C'\fR. After investigating this further,
we can draw memory maps, showing where the extra 4 bytes are hidden:
.PP
.Vb 5
\&   0           +4          +8          +12
\&   +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&   |c1|xx|  s  |c2|xx|xx|xx|     l     |    xx = fill byte
\&   +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&   gappy_t
\&
\&   0           +4          +8
\&   +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&   |     l     |  h  |c1|c2|
\&   +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&   dense_t
.Ve
.PP
And that's where the first quirk strikes: \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR
templates have to be stuffed with \f(CW\*(C`x\*(C'\fR codes to get those extra fill bytes.
.PP
The natural question: \*(L"Why can't Perl compensate for the gaps?\*(R" warrants
an answer. One good reason is that C compilers might provide (non-ANSI)
extensions permitting all sorts of fancy control over the way structures
are aligned, even at the level of an individual structure field. And, if
this were not enough, there is an insidious thing called \f(CW\*(C`union\*(C'\fR where
the amount of fill bytes cannot be derived from the alignment of the next
item alone.
.PP
\&\s-1OK,\s0 so let's bite the bullet. Here's one way to get the alignment right
by inserting template codes \f(CW\*(C`x\*(C'\fR, which don't take a corresponding item 
from the list:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aqcxs cxxx l!\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
Note the \f(CW\*(C`!\*(C'\fR after \f(CW\*(C`l\*(C'\fR: We want to make sure that we pack a long
integer as it is compiled by our C compiler. And even now, it will only
work for the platforms where the compiler aligns things as above.
And somebody somewhere has a platform where it doesn't.
[Probably a Cray, where \f(CW\*(C`short\*(C'\fRs, \f(CW\*(C`int\*(C'\fRs and \f(CW\*(C`long\*(C'\fRs are all 8 bytes. :\-)]
.PP
Counting bytes and watching alignments in lengthy structures is bound to 
be a drag. Isn't there a way we can create the template with a simple
program? Here's a C program that does the trick:
.PP
.Vb 2
\&   #include <stdio.h>
\&   #include <stddef.h>
\&
\&   typedef struct {
\&     char     fc1;
\&     short    fs;
\&     char     fc2;
\&     long     fl;
\&   } gappy_t;
\&
\&   #define Pt(struct,field,tchar) \e
\&     printf( "@%d%s ", offsetof(struct,field), # tchar );
\&
\&   int main() {
\&     Pt( gappy_t, fc1, c  );
\&     Pt( gappy_t, fs,  s! );
\&     Pt( gappy_t, fc2, c  );
\&     Pt( gappy_t, fl,  l! );
\&     printf( "\en" );
\&   }
.Ve
.PP
The output line can be used as a template in a \f(CW\*(C`pack\*(C'\fR or \f(CW\*(C`unpack\*(C'\fR call:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aq@0c @2s! @4c @8l!\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
Gee, yet another template code \- as if we hadn't plenty. But 
\&\f(CW\*(C`@\*(C'\fR saves our day by enabling us to specify the offset from the beginning
of the pack buffer to the next item: This is just the value
the \f(CW\*(C`offsetof\*(C'\fR macro (defined in \f(CW\*(C`<stddef.h>\*(C'\fR) returns when
given a \f(CW\*(C`struct\*(C'\fR type and one of its field names (\*(L"member-designator\*(R" in 
C standardese).
.PP
Neither using offsets nor adding \f(CW\*(C`x\*(C'\fR's to bridge the gaps is satisfactory.
(Just imagine what happens if the structure changes.) What we really need
is a way of saying \*(L"skip as many bytes as required to the next multiple of N\*(R".
In fluent Templatese, you say this with \f(CW\*(C`x!N\*(C'\fR where N is replaced by the
appropriate value. Here's the next version of our struct packaging:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aqc x!2 s c x!4 l!\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
That's certainly better, but we still have to know how long all the
integers are, and portability is far away. Rather than \f(CW2\fR,
for instance, we want to say \*(L"however long a short is\*(R". But this can be
done by enclosing the appropriate pack code in brackets: \f(CW\*(C`[s]\*(C'\fR. So, here's
the very best we can do:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aqc x![s] s c x![l!] l!\*(Aq, $c1, $s, $c2, $l );
.Ve
.SS "Dealing with Endian-ness"
.IX Subsection "Dealing with Endian-ness"
Now, imagine that we want to pack the data for a machine with a
different byte-order. First, we'll have to figure out how big the data
types on the target machine really are. Let's assume that the longs are
32 bits wide and the shorts are 16 bits wide. You can then rewrite the
template as:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aqc x![s] s c x![l] l\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
If the target machine is little-endian, we could write:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aqc x![s] s< c x![l] l<\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
This forces the short and the long members to be little-endian, and is
just fine if you don't have too many struct members. But we could also
use the byte-order modifier on a group and write the following:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aq( c x![s] s c x![l] l )<\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
This is not as short as before, but it makes it more obvious that we
intend to have little-endian byte-order for a whole group, not only
for individual template codes. It can also be more readable and easier
to maintain.
.SS "Alignment, Take 2"
.IX Subsection "Alignment, Take 2"
I'm afraid that we're not quite through with the alignment catch yet. The
hydra raises another ugly head when you pack arrays of structures:
.PP
.Vb 4
\&   typedef struct {
\&     short    count;
\&     char     glyph;
\&   } cell_t;
\&
\&   typedef cell_t buffer_t[BUFLEN];
.Ve
.PP
Where's the catch? Padding is neither required before the first field \f(CW\*(C`count\*(C'\fR,
nor between this and the next field \f(CW\*(C`glyph\*(C'\fR, so why can't we simply pack
like this:
.PP
.Vb 3
\&   # something goes wrong here:
\&   pack( \*(Aqs!a\*(Aq x @buffer,
\&         map{ ( $_\->{count}, $_\->{glyph} ) } @buffer );
.Ve
.PP
This packs \f(CW\*(C`3*@buffer\*(C'\fR bytes, but it turns out that the size of 
\&\f(CW\*(C`buffer_t\*(C'\fR is four times \f(CW\*(C`BUFLEN\*(C'\fR! The moral of the story is that
the required alignment of a structure or array is propagated to the
next higher level where we have to consider padding \fIat the end\fR
of each component as well. Thus the correct template is:
.PP
.Vb 2
\&   pack( \*(Aqs!ax\*(Aq x @buffer,
\&         map{ ( $_\->{count}, $_\->{glyph} ) } @buffer );
.Ve
.SS "Alignment, Take 3"
.IX Subsection "Alignment, Take 3"
And even if you take all the above into account, \s-1ANSI\s0 still lets this:
.PP
.Vb 3
\&   typedef struct {
\&     char     foo[2];
\&   } foo_t;
.Ve
.PP
vary in size. The alignment constraint of the structure can be greater than
any of its elements. [And if you think that this doesn't affect anything
common, dismember the next cellphone that you see. Many have \s-1ARM\s0 cores, and
the \s-1ARM\s0 structure rules make \f(CW\*(C`sizeof (foo_t)\*(C'\fR == 4]
.SS "Pointers for How to Use Them"
.IX Subsection "Pointers for How to Use Them"
The title of this section indicates the second problem you may run into
sooner or later when you pack C structures. If the function you intend
to call expects a, say, \f(CW\*(C`void *\*(C'\fR value, you \fIcannot\fR simply take
a reference to a Perl variable. (Although that value certainly is a
memory address, it's not the address where the variable's contents are
stored.)
.PP
Template code \f(CW\*(C`P\*(C'\fR promises to pack a \*(L"pointer to a fixed length string\*(R".
Isn't this what we want? Let's try:
.PP
.Vb 3
\&    # allocate some storage and pack a pointer to it
\&    my $memory = "\ex00" x $size;
\&    my $memptr = pack( \*(AqP\*(Aq, $memory );
.Ve
.PP
But wait: doesn't \f(CW\*(C`pack\*(C'\fR just return a sequence of bytes? How can we pass this
string of bytes to some C code expecting a pointer which is, after all,
nothing but a number? The answer is simple: We have to obtain the numeric
address from the bytes returned by \f(CW\*(C`pack\*(C'\fR.
.PP
.Vb 1
\&    my $ptr = unpack( \*(AqL!\*(Aq, $memptr );
.Ve
.PP
Obviously this assumes that it is possible to typecast a pointer
to an unsigned long and vice versa, which frequently works but should not
be taken as a universal law. \- Now that we have this pointer the next question
is: How can we put it to good use? We need a call to some C function
where a pointer is expected. The \fIread\fR\|(2) system call comes to mind:
.PP
.Vb 1
\&    ssize_t read(int fd, void *buf, size_t count);
.Ve
.PP
After reading perlfunc explaining how to use \f(CW\*(C`syscall\*(C'\fR we can write
this Perl function copying a file to standard output:
.PP
.Vb 12
\&    require \*(Aqsyscall.ph\*(Aq;
\&    sub cat($){
\&        my $path = shift();
\&        my $size = \-s $path;
\&        my $memory = "\ex00" x $size;  # allocate some memory
\&        my $ptr = unpack( \*(AqL\*(Aq, pack( \*(AqP\*(Aq, $memory ) );
\&        open( F, $path ) || die( "$path: cannot open ($!)\en" );
\&        my $fd = fileno(F);
\&        my $res = syscall( &SYS_read, fileno(F), $ptr, $size );
\&        print $memory;
\&        close( F );
\&    }
.Ve
.PP
This is neither a specimen of simplicity nor a paragon of portability but
it illustrates the point: We are able to sneak behind the scenes and
access Perl's otherwise well-guarded memory! (Important note: Perl's
\&\f(CW\*(C`syscall\*(C'\fR does \fInot\fR require you to construct pointers in this roundabout
way. You simply pass a string variable, and Perl forwards the address.)
.PP
How does \f(CW\*(C`unpack\*(C'\fR with \f(CW\*(C`P\*(C'\fR work? Imagine some pointer in the buffer
about to be unpacked: If it isn't the null pointer (which will smartly
produce the \f(CW\*(C`undef\*(C'\fR value) we have a start address \- but then what?
Perl has no way of knowing how long this \*(L"fixed length string\*(R" is, so
it's up to you to specify the actual size as an explicit length after \f(CW\*(C`P\*(C'\fR.
.PP
.Vb 2
\&   my $mem = "abcdefghijklmn";
\&   print unpack( \*(AqP5\*(Aq, pack( \*(AqP\*(Aq, $mem ) ); # prints "abcde"
.Ve
.PP
As a consequence, \f(CW\*(C`pack\*(C'\fR ignores any number or \f(CW\*(C`*\*(C'\fR after \f(CW\*(C`P\*(C'\fR.
.PP
Now that we have seen \f(CW\*(C`P\*(C'\fR at work, we might as well give \f(CW\*(C`p\*(C'\fR a whirl.
Why do we need a second template code for packing pointers at all? The 
answer lies behind the simple fact that an \f(CW\*(C`unpack\*(C'\fR with \f(CW\*(C`p\*(C'\fR promises
a null-terminated string starting at the address taken from the buffer,
and that implies a length for the data item to be returned:
.PP
.Vb 2
\&   my $buf = pack( \*(Aqp\*(Aq, "abc\ex00efhijklmn" );
\&   print unpack( \*(Aqp\*(Aq, $buf );    # prints "abc"
.Ve
.PP
Albeit this is apt to be confusing: As a consequence of the length being
implied by the string's length, a number after pack code \f(CW\*(C`p\*(C'\fR is a repeat
count, not a length as after \f(CW\*(C`P\*(C'\fR.
.PP
Using \f(CW\*(C`pack(..., $x)\*(C'\fR with \f(CW\*(C`P\*(C'\fR or \f(CW\*(C`p\*(C'\fR to get the address where \f(CW$x\fR is
actually stored must be used with circumspection. Perl's internal machinery
considers the relation between a variable and that address as its very own 
private matter and doesn't really care that we have obtained a copy. Therefore:
.IP "\(bu" 4
Do not use \f(CW\*(C`pack\*(C'\fR with \f(CW\*(C`p\*(C'\fR or \f(CW\*(C`P\*(C'\fR to obtain the address of variable
that's bound to go out of scope (and thereby freeing its memory) before you
are done with using the memory at that address.
.IP "\(bu" 4
Be very careful with Perl operations that change the value of the
variable. Appending something to the variable, for instance, might require
reallocation of its storage, leaving you with a pointer into no-man's land.
.IP "\(bu" 4
Don't think that you can get the address of a Perl variable
when it is stored as an integer or double number! \f(CW\*(C`pack(\*(AqP\*(Aq, $x)\*(C'\fR will
force the variable's internal representation to string, just as if you
had written something like \f(CW\*(C`$x .= \*(Aq\*(Aq\*(C'\fR.
.PP
It's safe, however, to P\- or p\-pack a string literal, because Perl simply
allocates an anonymous variable.
.SH "Pack Recipes"
.IX Header "Pack Recipes"
Here are a collection of (possibly) useful canned recipes for \f(CW\*(C`pack\*(C'\fR
and \f(CW\*(C`unpack\*(C'\fR:
.PP
.Vb 2
\&    # Convert IP address for socket functions
\&    pack( "C4", split /\e./, "123.4.5.6" ); 
\&
\&    # Count the bits in a chunk of memory (e.g. a select vector)
\&    unpack( \*(Aq%32b*\*(Aq, $mask );
\&
\&    # Determine the endianness of your system
\&    $is_little_endian = unpack( \*(Aqc\*(Aq, pack( \*(Aqs\*(Aq, 1 ) );
\&    $is_big_endian = unpack( \*(Aqxc\*(Aq, pack( \*(Aqs\*(Aq, 1 ) );
\&
\&    # Determine the number of bits in a native integer
\&    $bits = unpack( \*(Aq%32I!\*(Aq, ~0 );
\&
\&    # Prepare argument for the nanosleep system call
\&    my $timespec = pack( \*(AqL!L!\*(Aq, $secs, $nanosecs );
.Ve
.PP
For a simple memory dump we unpack some bytes into just as 
many pairs of hex digits, and use \f(CW\*(C`map\*(C'\fR to handle the traditional
spacing \- 16 bytes to a line:
.PP
.Vb 4
\&    my $i;
\&    print map( ++$i % 16 ? "$_ " : "$_\en",
\&               unpack( \*(AqH2\*(Aq x length( $mem ), $mem ) ),
\&          length( $mem ) % 16 ? "\en" : \*(Aq\*(Aq;
.Ve
.SH "Funnies Section"
.IX Header "Funnies Section"
.Vb 5
\&    # Pulling digits out of nowhere...
\&    print unpack( \*(AqC\*(Aq, pack( \*(Aqx\*(Aq ) ),
\&          unpack( \*(Aq%B*\*(Aq, pack( \*(AqA\*(Aq ) ),
\&          unpack( \*(AqH\*(Aq, pack( \*(AqA\*(Aq ) ),
\&          unpack( \*(AqA\*(Aq, unpack( \*(AqC\*(Aq, pack( \*(AqA\*(Aq ) ) ), "\en";
\&
\&    # One for the road ;\-)
\&    my $advice = pack( \*(Aqall u can in a van\*(Aq );
.Ve
.SH "Authors"
.IX Header "Authors"
Simon Cozens and Wolfgang Laun.
                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlpacktut5.16.1                            0100644 0001750 0001750 00000173342 12566207422 023620  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPACKTUT 1"
.TH PERLPACKTUT 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpacktut \- tutorial on "pack" and "unpack"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR are two functions for transforming data according
to a user-defined template, between the guarded way Perl stores values
and some well-defined representation as might be required in the 
environment of a Perl program. Unfortunately, they're also two of 
the most misunderstood and most often overlooked functions that Perl
provides. This tutorial will demystify them for you.
.SH "The Basic Principle"
.IX Header "The Basic Principle"
Most programming languages don't shelter the memory where variables are
stored. In C, for instance, you can take the address of some variable,
and the \f(CW\*(C`sizeof\*(C'\fR operator tells you how many bytes are allocated to
the variable. Using the address and the size, you may access the storage
to your heart's content.
.PP
In Perl, you just can't access memory at random, but the structural and
representational conversion provided by \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR is an
excellent alternative. The \f(CW\*(C`pack\*(C'\fR function converts values to a byte
sequence containing representations according to a given specification,
the so-called \*(L"template\*(R" argument. \f(CW\*(C`unpack\*(C'\fR is the reverse process,
deriving some values from the contents of a string of bytes. (Be cautioned,
however, that not all that has been packed together can be neatly unpacked \- 
a very common experience as seasoned travellers are likely to confirm.)
.PP
Why, you may ask, would you need a chunk of memory containing some values
in binary representation? One good reason is input and output accessing
some file, a device, or a network connection, whereby this binary
representation is either forced on you or will give you some benefit
in processing. Another cause is passing data to some system call that
is not available as a Perl function: \f(CW\*(C`syscall\*(C'\fR requires you to provide
parameters stored in the way it happens in a C program. Even text processing 
(as shown in the next section) may be simplified with judicious usage 
of these two functions.
.PP
To see how (un)packing works, we'll start with a simple template
code where the conversion is in low gear: between the contents of a byte
sequence and a string of hexadecimal digits. Let's use \f(CW\*(C`unpack\*(C'\fR, since
this is likely to remind you of a dump program, or some desperate last
message unfortunate programs are wont to throw at you before they expire
into the wild blue yonder. Assuming that the variable \f(CW$mem\fR holds a 
sequence of bytes that we'd like to inspect without assuming anything 
about its meaning, we can write
.PP
.Vb 2
\&   my( $hex ) = unpack( \*(AqH*\*(Aq, $mem );
\&   print "$hex\en";
.Ve
.PP
whereupon we might see something like this, with each pair of hex digits
corresponding to a byte:
.PP
.Vb 1
\&   41204d414e204120504c414e20412043414e414c2050414e414d41
.Ve
.PP
What was in this chunk of memory? Numbers, characters, or a mixture of
both? Assuming that we're on a computer where \s-1ASCII\s0 (or some similar)
encoding is used: hexadecimal values in the range \f(CW0x40\fR \- \f(CW0x5A\fR
indicate an uppercase letter, and \f(CW0x20\fR encodes a space. So we might
assume it is a piece of text, which some are able to read like a tabloid;
but others will have to get hold of an \s-1ASCII\s0 table and relive that
firstgrader feeling. Not caring too much about which way to read this,
we note that \f(CW\*(C`unpack\*(C'\fR with the template code \f(CW\*(C`H\*(C'\fR converts the contents
of a sequence of bytes into the customary hexadecimal notation. Since
\&\*(L"a sequence of\*(R" is a pretty vague indication of quantity, \f(CW\*(C`H\*(C'\fR has been
defined to convert just a single hexadecimal digit unless it is followed
by a repeat count. An asterisk for the repeat count means to use whatever
remains.
.PP
The inverse operation \- packing byte contents from a string of hexadecimal
digits \- is just as easily written. For instance:
.PP
.Vb 2
\&   my $s = pack( \*(AqH2\*(Aq x 10, 30..39 );
\&   print "$s\en";
.Ve
.PP
Since we feed a list of ten 2\-digit hexadecimal strings to \f(CW\*(C`pack\*(C'\fR, the
pack template should contain ten pack codes. If this is run on a computer
with \s-1ASCII\s0 character coding, it will print \f(CW0123456789\fR.
.SH "Packing Text"
.IX Header "Packing Text"
Let's suppose you've got to read in a data file like this:
.PP
.Vb 4
\&    Date      |Description                | Income|Expenditure
\&    01/24/2001 Ahmed\*(Aqs Camel Emporium                  1147.99
\&    01/28/2001 Flea spray                                24.99
\&    01/29/2001 Camel rides to tourists      235.00
.Ve
.PP
How do we do it? You might think first to use \f(CW\*(C`split\*(C'\fR; however, since
\&\f(CW\*(C`split\*(C'\fR collapses blank fields, you'll never know whether a record was
income or expenditure. Oops. Well, you could always use \f(CW\*(C`substr\*(C'\fR:
.PP
.Vb 7
\&    while (<>) { 
\&        my $date   = substr($_,  0, 11);
\&        my $desc   = substr($_, 12, 27);
\&        my $income = substr($_, 40,  7);
\&        my $expend = substr($_, 52,  7);
\&        ...
\&    }
.Ve
.PP
It's not really a barrel of laughs, is it? In fact, it's worse than it
may seem; the eagle-eyed may notice that the first field should only be
10 characters wide, and the error has propagated right through the other
numbers \- which we've had to count by hand. So it's error-prone as well
as horribly unfriendly.
.PP
Or maybe we could use regular expressions:
.PP
.Vb 5
\&    while (<>) { 
\&        my($date, $desc, $income, $expend) = 
\&            m|(\ed\ed/\ed\ed/\ed{4}) (.{27}) (.{7})(.*)|;
\&        ...
\&    }
.Ve
.PP
Urgh. Well, it's a bit better, but \- well, would you want to maintain
that?
.PP
Hey, isn't Perl supposed to make this sort of thing easy? Well, it does,
if you use the right tools. \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR are designed to help
you out when dealing with fixed-width data like the above. Let's have a
look at a solution with \f(CW\*(C`unpack\*(C'\fR:
.PP
.Vb 4
\&    while (<>) { 
\&        my($date, $desc, $income, $expend) = unpack("A10xA27xA7A*", $_);
\&        ...
\&    }
.Ve
.PP
That looks a bit nicer; but we've got to take apart that weird template.
Where did I pull that out of?
.PP
\&\s-1OK\s0, let's have a look at some of our data again; in fact, we'll include
the headers, and a handy ruler so we can keep track of where we are.
.PP
.Vb 5
\&             1         2         3         4         5        
\&    1234567890123456789012345678901234567890123456789012345678
\&    Date      |Description                | Income|Expenditure
\&    01/28/2001 Flea spray                                24.99
\&    01/29/2001 Camel rides to tourists      235.00
.Ve
.PP
From this, we can see that the date column stretches from column 1 to
column 10 \- ten characters wide. The \f(CW\*(C`pack\*(C'\fR\-ese for \*(L"character\*(R" is
\&\f(CW\*(C`A\*(C'\fR, and ten of them are \f(CW\*(C`A10\*(C'\fR. So if we just wanted to extract the
dates, we could say this:
.PP
.Vb 1
\&    my($date) = unpack("A10", $_);
.Ve
.PP
\&\s-1OK\s0, what's next? Between the date and the description is a blank column;
we want to skip over that. The \f(CW\*(C`x\*(C'\fR template means \*(L"skip forward\*(R", so we
want one of those. Next, we have another batch of characters, from 12 to
38. That's 27 more characters, hence \f(CW\*(C`A27\*(C'\fR. (Don't make the fencepost
error \- there are 27 characters between 12 and 38, not 26. Count 'em!)
.PP
Now we skip another character and pick up the next 7 characters:
.PP
.Vb 1
\&    my($date,$description,$income) = unpack("A10xA27xA7", $_);
.Ve
.PP
Now comes the clever bit. Lines in our ledger which are just income and
not expenditure might end at column 46. Hence, we don't want to tell our
\&\f(CW\*(C`unpack\*(C'\fR pattern that we \fBneed\fR to find another 12 characters; we'll
just say \*(L"if there's anything left, take it\*(R". As you might guess from
regular expressions, that's what the \f(CW\*(C`*\*(C'\fR means: \*(L"use everything
remaining\*(R".
.IP "\(bu" 3
Be warned, though, that unlike regular expressions, if the \f(CW\*(C`unpack\*(C'\fR
template doesn't match the incoming data, Perl will scream and die.
.PP
Hence, putting it all together:
.PP
.Vb 1
\&    my($date,$description,$income,$expend) = unpack("A10xA27xA7xA*", $_);
.Ve
.PP
Now, that's our data parsed. I suppose what we might want to do now is
total up our income and expenditure, and add another line to the end of
our ledger \- in the same format \- saying how much we've brought in and
how much we've spent:
.PP
.Vb 5
\&    while (<>) {
\&        my($date, $desc, $income, $expend) = unpack("A10xA27xA7xA*", $_);
\&        $tot_income += $income;
\&        $tot_expend += $expend;
\&    }
\&
\&    $tot_income = sprintf("%.2f", $tot_income); # Get them into 
\&    $tot_expend = sprintf("%.2f", $tot_expend); # "financial" format
\&
\&    $date = POSIX::strftime("%m/%d/%Y", localtime); 
\&
\&    # OK, let\*(Aqs go:
\&
\&    print pack("A10xA27xA7xA*", $date, "Totals", $tot_income, $tot_expend);
.Ve
.PP
Oh, hmm. That didn't quite work. Let's see what happened:
.PP
.Vb 4
\&    01/24/2001 Ahmed\*(Aqs Camel Emporium                   1147.99
\&    01/28/2001 Flea spray                                 24.99
\&    01/29/2001 Camel rides to tourists     1235.00
\&    03/23/2001Totals                     1235.001172.98
.Ve
.PP
\&\s-1OK\s0, it's a start, but what happened to the spaces? We put \f(CW\*(C`x\*(C'\fR, didn't
we? Shouldn't it skip forward? Let's look at what \*(L"pack\*(R" in perlfunc says:
.PP
.Vb 1
\&    x   A null byte.
.Ve
.PP
Urgh. No wonder. There's a big difference between \*(L"a null byte\*(R",
character zero, and \*(L"a space\*(R", character 32. Perl's put something
between the date and the description \- but unfortunately, we can't see
it!
.PP
What we actually need to do is expand the width of the fields. The \f(CW\*(C`A\*(C'\fR
format pads any non-existent characters with spaces, so we can use the
additional spaces to line up our fields, like this:
.PP
.Vb 1
\&    print pack("A11 A28 A8 A*", $date, "Totals", $tot_income, $tot_expend);
.Ve
.PP
(Note that you can put spaces in the template to make it more readable,
but they don't translate to spaces in the output.) Here's what we got
this time:
.PP
.Vb 4
\&    01/24/2001 Ahmed\*(Aqs Camel Emporium                   1147.99
\&    01/28/2001 Flea spray                                 24.99
\&    01/29/2001 Camel rides to tourists     1235.00
\&    03/23/2001 Totals                      1235.00 1172.98
.Ve
.PP
That's a bit better, but we still have that last column which needs to
be moved further over. There's an easy way to fix this up:
unfortunately, we can't get \f(CW\*(C`pack\*(C'\fR to right-justify our fields, but we
can get \f(CW\*(C`sprintf\*(C'\fR to do it:
.PP
.Vb 4
\&    $tot_income = sprintf("%.2f", $tot_income); 
\&    $tot_expend = sprintf("%12.2f", $tot_expend);
\&    $date = POSIX::strftime("%m/%d/%Y", localtime); 
\&    print pack("A11 A28 A8 A*", $date, "Totals", $tot_income, $tot_expend);
.Ve
.PP
This time we get the right answer:
.PP
.Vb 3
\&    01/28/2001 Flea spray                                 24.99
\&    01/29/2001 Camel rides to tourists     1235.00
\&    03/23/2001 Totals                      1235.00      1172.98
.Ve
.PP
So that's how we consume and produce fixed-width data. Let's recap what
we've seen of \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR so far:
.IP "\(bu" 3
Use \f(CW\*(C`pack\*(C'\fR to go from several pieces of data to one fixed-width
version; use \f(CW\*(C`unpack\*(C'\fR to turn a fixed-width-format string into several
pieces of data.
.IP "\(bu" 3
The pack format \f(CW\*(C`A\*(C'\fR means \*(L"any character\*(R"; if you're \f(CW\*(C`pack\*(C'\fRing and
you've run out of things to pack, \f(CW\*(C`pack\*(C'\fR will fill the rest up with
spaces.
.IP "\(bu" 3
\&\f(CW\*(C`x\*(C'\fR means \*(L"skip a byte\*(R" when \f(CW\*(C`unpack\*(C'\fRing; when \f(CW\*(C`pack\*(C'\fRing, it means
\&\*(L"introduce a null byte\*(R" \- that's probably not what you mean if you're
dealing with plain text.
.IP "\(bu" 3
You can follow the formats with numbers to say how many characters
should be affected by that format: \f(CW\*(C`A12\*(C'\fR means \*(L"take 12 characters\*(R";
\&\f(CW\*(C`x6\*(C'\fR means \*(L"skip 6 bytes\*(R" or \*(L"character 0, 6 times\*(R".
.IP "\(bu" 3
Instead of a number, you can use \f(CW\*(C`*\*(C'\fR to mean \*(L"consume everything else
left\*(R".
.Sp
\&\fBWarning\fR: when packing multiple pieces of data, \f(CW\*(C`*\*(C'\fR only means
\&\*(L"consume all of the current piece of data\*(R". That's to say
.Sp
.Vb 1
\&    pack("A*A*", $one, $two)
.Ve
.Sp
packs all of \f(CW$one\fR into the first \f(CW\*(C`A*\*(C'\fR and then all of \f(CW$two\fR into
the second. This is a general principle: each format character
corresponds to one piece of data to be \f(CW\*(C`pack\*(C'\fRed.
.SH "Packing Numbers"
.IX Header "Packing Numbers"
So much for textual data. Let's get onto the meaty stuff that \f(CW\*(C`pack\*(C'\fR
and \f(CW\*(C`unpack\*(C'\fR are best at: handling binary formats for numbers. There is,
of course, not just one binary format  \- life would be too simple \- but
Perl will do all the finicky labor for you.
.SS "Integers"
.IX Subsection "Integers"
Packing and unpacking numbers implies conversion to and from some
\&\fIspecific\fR binary representation. Leaving floating point numbers
aside for the moment, the salient properties of any such representation
are:
.IP "\(bu" 4
the number of bytes used for storing the integer,
.IP "\(bu" 4
whether the contents are interpreted as a signed or unsigned number,
.IP "\(bu" 4
the byte ordering: whether the first byte is the least or most
significant byte (or: little-endian or big-endian, respectively).
.PP
So, for instance, to pack 20302 to a signed 16 bit integer in your
computer's representation you write
.PP
.Vb 1
\&   my $ps = pack( \*(Aqs\*(Aq, 20302 );
.Ve
.PP
Again, the result is a string, now containing 2 bytes. If you print 
this string (which is, generally, not recommended) you might see
\&\f(CW\*(C`ON\*(C'\fR or \f(CW\*(C`NO\*(C'\fR (depending on your system's byte ordering) \- or something
entirely different if your computer doesn't use \s-1ASCII\s0 character encoding.
Unpacking \f(CW$ps\fR with the same template returns the original integer value:
.PP
.Vb 1
\&   my( $s ) = unpack( \*(Aqs\*(Aq, $ps );
.Ve
.PP
This is true for all numeric template codes. But don't expect miracles:
if the packed value exceeds the allotted byte capacity, high order bits
are silently discarded, and unpack certainly won't be able to pull them
back out of some magic hat. And, when you pack using a signed template
code such as \f(CW\*(C`s\*(C'\fR, an excess value may result in the sign bit
getting set, and unpacking this will smartly return a negative value.
.PP
16 bits won't get you too far with integers, but there is \f(CW\*(C`l\*(C'\fR and \f(CW\*(C`L\*(C'\fR
for signed and unsigned 32\-bit integers. And if this is not enough and
your system supports 64 bit integers you can push the limits much closer
to infinity with pack codes \f(CW\*(C`q\*(C'\fR and \f(CW\*(C`Q\*(C'\fR. A notable exception is provided
by pack codes \f(CW\*(C`i\*(C'\fR and \f(CW\*(C`I\*(C'\fR for signed and unsigned integers of the 
\&\*(L"local custom\*(R" variety: Such an integer will take up as many bytes as
a local C compiler returns for \f(CW\*(C`sizeof(int)\*(C'\fR, but it'll use \fIat least\fR
32 bits.
.PP
Each of the integer pack codes \f(CW\*(C`sSlLqQ\*(C'\fR results in a fixed number of bytes,
no matter where you execute your program. This may be useful for some 
applications, but it does not provide for a portable way to pass data 
structures between Perl and C programs (bound to happen when you call 
\&\s-1XS\s0 extensions or the Perl function \f(CW\*(C`syscall\*(C'\fR), or when you read or
write binary files. What you'll need in this case are template codes that
depend on what your local C compiler compiles when you code \f(CW\*(C`short\*(C'\fR or
\&\f(CW\*(C`unsigned long\*(C'\fR, for instance. These codes and their corresponding
byte lengths are shown in the table below.  Since the C standard leaves
much leeway with respect to the relative sizes of these data types, actual
values may vary, and that's why the values are given as expressions in
C and Perl. (If you'd like to use values from \f(CW%Config\fR in your program
you have to import it with \f(CW\*(C`use Config\*(C'\fR.)
.PP
.Vb 5
\&   signed unsigned  byte length in C   byte length in Perl       
\&     s!     S!      sizeof(short)      $Config{shortsize}
\&     i!     I!      sizeof(int)        $Config{intsize}
\&     l!     L!      sizeof(long)       $Config{longsize}
\&     q!     Q!      sizeof(long long)  $Config{longlongsize}
.Ve
.PP
The \f(CW\*(C`i!\*(C'\fR and \f(CW\*(C`I!\*(C'\fR codes aren't different from \f(CW\*(C`i\*(C'\fR and \f(CW\*(C`I\*(C'\fR; they are
tolerated for completeness' sake.
.SS "Unpacking a Stack Frame"
.IX Subsection "Unpacking a Stack Frame"
Requesting a particular byte ordering may be necessary when you work with
binary data coming from some specific architecture whereas your program could
run on a totally different system. As an example, assume you have 24 bytes
containing a stack frame as it happens on an Intel 8086:
.PP
.Vb 11
\&      +\-\-\-\-\-\-\-\-\-+        +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\& TOS: |   IP    |  TOS+4:| FL | FH | FLAGS  TOS+14:|   SI    |
\&      +\-\-\-\-\-\-\-\-\-+        +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\&      |   CS    |        | AL | AH | AX            |   DI    |
\&      +\-\-\-\-\-\-\-\-\-+        +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\&                         | BL | BH | BX            |   BP    |
\&                         +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\&                         | CL | CH | CX            |   DS    |
\&                         +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\&                         | DL | DH | DX            |   ES    |
\&                         +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
.Ve
.PP
First, we note that this time-honored 16\-bit \s-1CPU\s0 uses little-endian order,
and that's why the low order byte is stored at the lower address. To
unpack such a (unsigned) short we'll have to use code \f(CW\*(C`v\*(C'\fR. A repeat
count unpacks all 12 shorts:
.PP
.Vb 2
\&   my( $ip, $cs, $flags, $ax, $bx, $cd, $dx, $si, $di, $bp, $ds, $es ) =
\&     unpack( \*(Aqv12\*(Aq, $frame );
.Ve
.PP
Alternatively, we could have used \f(CW\*(C`C\*(C'\fR to unpack the individually
accessible byte registers \s-1FL\s0, \s-1FH\s0, \s-1AL\s0, \s-1AH\s0, etc.:
.PP
.Vb 2
\&   my( $fl, $fh, $al, $ah, $bl, $bh, $cl, $ch, $dl, $dh ) =
\&     unpack( \*(AqC10\*(Aq, substr( $frame, 4, 10 ) );
.Ve
.PP
It would be nice if we could do this in one fell swoop: unpack a short,
back up a little, and then unpack 2 bytes. Since Perl \fIis\fR nice, it
proffers the template code \f(CW\*(C`X\*(C'\fR to back up one byte. Putting this all
together, we may now write:
.PP
.Vb 5
\&   my( $ip, $cs,
\&       $flags,$fl,$fh,
\&       $ax,$al,$ah, $bx,$bl,$bh, $cx,$cl,$ch, $dx,$dl,$dh, 
\&       $si, $di, $bp, $ds, $es ) =
\&   unpack( \*(Aqv2\*(Aq . (\*(AqvXXCC\*(Aq x 5) . \*(Aqv5\*(Aq, $frame );
.Ve
.PP
(The clumsy construction of the template can be avoided \- just read on!)
.PP
We've taken some pains to construct the template so that it matches
the contents of our frame buffer. Otherwise we'd either get undefined values,
or \f(CW\*(C`unpack\*(C'\fR could not unpack all. If \f(CW\*(C`pack\*(C'\fR runs out of items, it will
supply null strings (which are coerced into zeroes whenever the pack code
says so).
.SS "How to Eat an Egg on a Net"
.IX Subsection "How to Eat an Egg on a Net"
The pack code for big-endian (high order byte at the lowest address) is
\&\f(CW\*(C`n\*(C'\fR for 16 bit and \f(CW\*(C`N\*(C'\fR for 32 bit integers. You use these codes
if you know that your data comes from a compliant architecture, but,
surprisingly enough, you should also use these pack codes if you
exchange binary data, across the network, with some system that you
know next to nothing about. The simple reason is that this
order has been chosen as the \fInetwork order\fR, and all standard-fearing
programs ought to follow this convention. (This is, of course, a stern
backing for one of the Lilliputian parties and may well influence the
political development there.) So, if the protocol expects you to send
a message by sending the length first, followed by just so many bytes,
you could write:
.PP
.Vb 1
\&   my $buf = pack( \*(AqN\*(Aq, length( $msg ) ) . $msg;
.Ve
.PP
or even:
.PP
.Vb 1
\&   my $buf = pack( \*(AqNA*\*(Aq, length( $msg ), $msg );
.Ve
.PP
and pass \f(CW$buf\fR to your send routine. Some protocols demand that the
count should include the length of the count itself: then just add 4
to the data length. (But make sure to read \*(L"Lengths and Widths\*(R" before
you really code this!)
.SS "Byte-order modifiers"
.IX Subsection "Byte-order modifiers"
In the previous sections we've learned how to use \f(CW\*(C`n\*(C'\fR, \f(CW\*(C`N\*(C'\fR, \f(CW\*(C`v\*(C'\fR and
\&\f(CW\*(C`V\*(C'\fR to pack and unpack integers with big\- or little-endian byte-order.
While this is nice, it's still rather limited because it leaves out all
kinds of signed integers as well as 64\-bit integers. For example, if you
wanted to unpack a sequence of signed big-endian 16\-bit integers in a
platform-independent way, you would have to write:
.PP
.Vb 1
\&   my @data = unpack \*(Aqs*\*(Aq, pack \*(AqS*\*(Aq, unpack \*(Aqn*\*(Aq, $buf;
.Ve
.PP
This is ugly. As of Perl 5.9.2, there's a much nicer way to express your
desire for a certain byte-order: the \f(CW\*(C`>\*(C'\fR and \f(CW\*(C`<\*(C'\fR modifiers.
\&\f(CW\*(C`>\*(C'\fR is the big-endian modifier, while \f(CW\*(C`<\*(C'\fR is the little-endian
modifier. Using them, we could rewrite the above code as:
.PP
.Vb 1
\&   my @data = unpack \*(Aqs>*\*(Aq, $buf;
.Ve
.PP
As you can see, the \*(L"big end\*(R" of the arrow touches the \f(CW\*(C`s\*(C'\fR, which is a
nice way to remember that \f(CW\*(C`>\*(C'\fR is the big-endian modifier. The same
obviously works for \f(CW\*(C`<\*(C'\fR, where the \*(L"little end\*(R" touches the code.
.PP
You will probably find these modifiers even more useful if you have
to deal with big\- or little-endian C structures. Be sure to read
\&\*(L"Packing and Unpacking C Structures\*(R" for more on that.
.SS "Floating point Numbers"
.IX Subsection "Floating point Numbers"
For packing floating point numbers you have the choice between the
pack codes \f(CW\*(C`f\*(C'\fR, \f(CW\*(C`d\*(C'\fR, \f(CW\*(C`F\*(C'\fR and \f(CW\*(C`D\*(C'\fR. \f(CW\*(C`f\*(C'\fR and \f(CW\*(C`d\*(C'\fR pack into (or unpack
from) single-precision or double-precision representation as it is provided
by your system. If your systems supports it, \f(CW\*(C`D\*(C'\fR can be used to pack and
unpack extended-precision floating point values (\f(CW\*(C`long double\*(C'\fR), which
can offer even more resolution than \f(CW\*(C`f\*(C'\fR or \f(CW\*(C`d\*(C'\fR. \f(CW\*(C`F\*(C'\fR packs an \f(CW\*(C`NV\*(C'\fR,
which is the floating point type used by Perl internally. (There
is no such thing as a network representation for reals, so if you want
to send your real numbers across computer boundaries, you'd better stick
to \s-1ASCII\s0 representation, unless you're absolutely sure what's on the other
end of the line. For the even more adventuresome, you can use the byte-order
modifiers from the previous section also on floating point codes.)
.SH "Exotic Templates"
.IX Header "Exotic Templates"
.SS "Bit Strings"
.IX Subsection "Bit Strings"
Bits are the atoms in the memory world. Access to individual bits may
have to be used either as a last resort or because it is the most
convenient way to handle your data. Bit string (un)packing converts
between strings containing a series of \f(CW0\fR and \f(CW1\fR characters and
a sequence of bytes each containing a group of 8 bits. This is almost
as simple as it sounds, except that there are two ways the contents of
a byte may be written as a bit string. Let's have a look at an annotated
byte:
.PP
.Vb 5
\&     7 6 5 4 3 2 1 0
\&   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&   | 1 0 0 0 1 1 0 0 |
\&   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    MSB           LSB
.Ve
.PP
It's egg-eating all over again: Some think that as a bit string this should
be written \*(L"10001100\*(R" i.e. beginning with the most significant bit, others
insist on \*(L"00110001\*(R". Well, Perl isn't biased, so that's why we have two bit
string codes:
.PP
.Vb 2
\&   $byte = pack( \*(AqB8\*(Aq, \*(Aq10001100\*(Aq ); # start with MSB
\&   $byte = pack( \*(Aqb8\*(Aq, \*(Aq00110001\*(Aq ); # start with LSB
.Ve
.PP
It is not possible to pack or unpack bit fields \- just integral bytes.
\&\f(CW\*(C`pack\*(C'\fR always starts at the next byte boundary and \*(L"rounds up\*(R" to the
next multiple of 8 by adding zero bits as required. (If you do want bit
fields, there is \*(L"vec\*(R" in perlfunc. Or you could implement bit field 
handling at the character string level, using split, substr, and
concatenation on unpacked bit strings.)
.PP
To illustrate unpacking for bit strings, we'll decompose a simple
status register (a \*(L"\-\*(R" stands for a \*(L"reserved\*(R" bit):
.PP
.Vb 4
\&   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&   | S Z \- A \- P \- C | \- \- \- \- O D I T |
\&   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    MSB           LSB MSB           LSB
.Ve
.PP
Converting these two bytes to a string can be done with the unpack 
template \f(CW\*(Aqb16\*(Aq\fR. To obtain the individual bit values from the bit
string we use \f(CW\*(C`split\*(C'\fR with the \*(L"empty\*(R" separator pattern which dissects
into individual characters. Bit values from the \*(L"reserved\*(R" positions are
simply assigned to \f(CW\*(C`undef\*(C'\fR, a convenient notation for \*(L"I don't care where
this goes\*(R".
.PP
.Vb 3
\&   ($carry, undef, $parity, undef, $auxcarry, undef, $zero, $sign,
\&    $trace, $interrupt, $direction, $overflow) =
\&      split( //, unpack( \*(Aqb16\*(Aq, $status ) );
.Ve
.PP
We could have used an unpack template \f(CW\*(Aqb12\*(Aq\fR just as well, since the
last 4 bits can be ignored anyway.
.SS "Uuencoding"
.IX Subsection "Uuencoding"
Another odd-man-out in the template alphabet is \f(CW\*(C`u\*(C'\fR, which packs an
\&\*(L"uuencoded string\*(R". (\*(L"uu\*(R" is short for Unix-to-Unix.) Chances are that
you won't ever need this encoding technique which was invented to overcome
the shortcomings of old-fashioned transmission mediums that do not support
other than simple \s-1ASCII\s0 data. The essential recipe is simple: Take three 
bytes, or 24 bits. Split them into 4 six-packs, adding a space (0x20) to 
each. Repeat until all of the data is blended. Fold groups of 4 bytes into 
lines no longer than 60 and garnish them in front with the original byte count 
(incremented by 0x20) and a \f(CW"\en"\fR at the end. \- The \f(CW\*(C`pack\*(C'\fR chef will
prepare this for you, a la minute, when you select pack code \f(CW\*(C`u\*(C'\fR on the menu:
.PP
.Vb 1
\&   my $uubuf = pack( \*(Aqu\*(Aq, $bindat );
.Ve
.PP
A repeat count after \f(CW\*(C`u\*(C'\fR sets the number of bytes to put into an
uuencoded line, which is the maximum of 45 by default, but could be
set to some (smaller) integer multiple of three. \f(CW\*(C`unpack\*(C'\fR simply ignores
the repeat count.
.SS "Doing Sums"
.IX Subsection "Doing Sums"
An even stranger template code is \f(CW\*(C`%\*(C'\fR<\fInumber\fR>. First, because 
it's used as a prefix to some other template code. Second, because it
cannot be used in \f(CW\*(C`pack\*(C'\fR at all, and third, in \f(CW\*(C`unpack\*(C'\fR, doesn't return the
data as defined by the template code it precedes. Instead it'll give you an
integer of \fInumber\fR bits that is computed from the data value by 
doing sums. For numeric unpack codes, no big feat is achieved:
.PP
.Vb 2
\&    my $buf = pack( \*(Aqiii\*(Aq, 100, 20, 3 );
\&    print unpack( \*(Aq%32i3\*(Aq, $buf ), "\en";  # prints 123
.Ve
.PP
For string values, \f(CW\*(C`%\*(C'\fR returns the sum of the byte values saving
you the trouble of a sum loop with \f(CW\*(C`substr\*(C'\fR and \f(CW\*(C`ord\*(C'\fR:
.PP
.Vb 1
\&    print unpack( \*(Aq%32A*\*(Aq, "\ex01\ex10" ), "\en";  # prints 17
.Ve
.PP
Although the \f(CW\*(C`%\*(C'\fR code is documented as returning a \*(L"checksum\*(R":
don't put your trust in such values! Even when applied to a small number
of bytes, they won't guarantee a noticeable Hamming distance.
.PP
In connection with \f(CW\*(C`b\*(C'\fR or \f(CW\*(C`B\*(C'\fR, \f(CW\*(C`%\*(C'\fR simply adds bits, and this can be put
to good use to count set bits efficiently:
.PP
.Vb 1
\&    my $bitcount = unpack( \*(Aq%32b*\*(Aq, $mask );
.Ve
.PP
And an even parity bit can be determined like this:
.PP
.Vb 1
\&    my $evenparity = unpack( \*(Aq%1b*\*(Aq, $mask );
.Ve
.SS "Unicode"
.IX Subsection "Unicode"
Unicode is a character set that can represent most characters in most of
the world's languages, providing room for over one million different
characters. Unicode 3.1 specifies 94,140 characters: The Basic Latin
characters are assigned to the numbers 0 \- 127. The Latin\-1 Supplement with
characters that are used in several European languages is in the next
range, up to 255. After some more Latin extensions we find the character
sets from languages using non-Roman alphabets, interspersed with a
variety of symbol sets such as currency symbols, Zapf Dingbats or Braille.
(You might want to visit <http://www.unicode.org/> for a look at some of
them \- my personal favourites are Telugu and Kannada.)
.PP
The Unicode character sets associates characters with integers. Encoding
these numbers in an equal number of bytes would more than double the
requirements for storing texts written in Latin alphabets.
The \s-1UTF\-8\s0 encoding avoids this by storing the most common (from a western
point of view) characters in a single byte while encoding the rarer
ones in three or more bytes.
.PP
Perl uses \s-1UTF\-8\s0, internally, for most Unicode strings.
.PP
So what has this got to do with \f(CW\*(C`pack\*(C'\fR? Well, if you want to compose a
Unicode string (that is internally encoded as \s-1UTF\-8\s0), you can do so by
using template code \f(CW\*(C`U\*(C'\fR. As an example, let's produce the Euro currency
symbol (code number 0x20AC):
.PP
.Vb 2
\&   $UTF8{Euro} = pack( \*(AqU\*(Aq, 0x20AC );
\&   # Equivalent to: $UTF8{Euro} = "\ex{20ac}";
.Ve
.PP
Inspecting \f(CW$UTF8{Euro}\fR shows that it contains 3 bytes:
\&\*(L"\exe2\ex82\exac\*(R". However, it contains only 1 character, number 0x20AC.
The round trip can be completed with \f(CW\*(C`unpack\*(C'\fR:
.PP
.Vb 1
\&   $Unicode{Euro} = unpack( \*(AqU\*(Aq, $UTF8{Euro} );
.Ve
.PP
Unpacking using the \f(CW\*(C`U\*(C'\fR template code also works on \s-1UTF\-8\s0 encoded byte
strings.
.PP
Usually you'll want to pack or unpack \s-1UTF\-8\s0 strings:
.PP
.Vb 3
\&   # pack and unpack the Hebrew alphabet
\&   my $alefbet = pack( \*(AqU*\*(Aq, 0x05d0..0x05ea );
\&   my @hebrew = unpack( \*(AqU*\*(Aq, $utf );
.Ve
.PP
Please note: in the general case, you're better off using
Encode::decode_utf8 to decode a \s-1UTF\-8\s0 encoded byte string to a Perl
Unicode string, and Encode::encode_utf8 to encode a Perl Unicode string
to \s-1UTF\-8\s0 bytes. These functions provide means of handling invalid byte
sequences and generally have a friendlier interface.
.SS "Another Portable Binary Encoding"
.IX Subsection "Another Portable Binary Encoding"
The pack code \f(CW\*(C`w\*(C'\fR has been added to support a portable binary data
encoding scheme that goes way beyond simple integers. (Details can
be found at <http://Casbah.org/>, the Scarab project.)  A \s-1BER\s0 (Binary Encoded
Representation) compressed unsigned integer stores base 128
digits, most significant digit first, with as few digits as possible.
Bit eight (the high bit) is set on each byte except the last. There
is no size limit to \s-1BER\s0 encoding, but Perl won't go to extremes.
.PP
.Vb 1
\&   my $berbuf = pack( \*(Aqw*\*(Aq, 1, 128, 128+1, 128*128+127 );
.Ve
.PP
A hex dump of \f(CW$berbuf\fR, with spaces inserted at the right places,
shows 01 8100 8101 81807F. Since the last byte is always less than
128, \f(CW\*(C`unpack\*(C'\fR knows where to stop.
.SH "Template Grouping"
.IX Header "Template Grouping"
Prior to Perl 5.8, repetitions of templates had to be made by
\&\f(CW\*(C`x\*(C'\fR\-multiplication of template strings. Now there is a better way as
we may use the pack codes \f(CW\*(C`(\*(C'\fR and \f(CW\*(C`)\*(C'\fR combined with a repeat count.
The \f(CW\*(C`unpack\*(C'\fR template from the Stack Frame example can simply
be written like this:
.PP
.Vb 1
\&   unpack( \*(Aqv2 (vXXCC)5 v5\*(Aq, $frame )
.Ve
.PP
Let's explore this feature a little more. We'll begin with the equivalent of
.PP
.Vb 1
\&   join( \*(Aq\*(Aq, map( substr( $_, 0, 1 ), @str ) )
.Ve
.PP
which returns a string consisting of the first character from each string.
Using pack, we can write
.PP
.Vb 1
\&   pack( \*(Aq(A)\*(Aq.@str, @str )
.Ve
.PP
or, because a repeat count \f(CW\*(C`*\*(C'\fR means \*(L"repeat as often as required\*(R",
simply
.PP
.Vb 1
\&   pack( \*(Aq(A)*\*(Aq, @str )
.Ve
.PP
(Note that the template \f(CW\*(C`A*\*(C'\fR would only have packed \f(CW$str[0]\fR in full
length.)
.PP
To pack dates stored as triplets ( day, month, year ) in an array \f(CW@dates\fR
into a sequence of byte, byte, short integer we can write
.PP
.Vb 1
\&   $pd = pack( \*(Aq(CCS)*\*(Aq, map( @$_, @dates ) );
.Ve
.PP
To swap pairs of characters in a string (with even length) one could use
several techniques. First, let's use \f(CW\*(C`x\*(C'\fR and \f(CW\*(C`X\*(C'\fR to skip forward and back:
.PP
.Vb 1
\&   $s = pack( \*(Aq(A)*\*(Aq, unpack( \*(Aq(xAXXAx)*\*(Aq, $s ) );
.Ve
.PP
We can also use \f(CW\*(C`@\*(C'\fR to jump to an offset, with 0 being the position where
we were when the last \f(CW\*(C`(\*(C'\fR was encountered:
.PP
.Vb 1
\&   $s = pack( \*(Aq(A)*\*(Aq, unpack( \*(Aq(@1A @0A @2)*\*(Aq, $s ) );
.Ve
.PP
Finally, there is also an entirely different approach by unpacking big
endian shorts and packing them in the reverse byte order:
.PP
.Vb 1
\&   $s = pack( \*(Aq(v)*\*(Aq, unpack( \*(Aq(n)*\*(Aq, $s );
.Ve
.SH "Lengths and Widths"
.IX Header "Lengths and Widths"
.SS "String Lengths"
.IX Subsection "String Lengths"
In the previous section we've seen a network message that was constructed
by prefixing the binary message length to the actual message. You'll find
that packing a length followed by so many bytes of data is a 
frequently used recipe since appending a null byte won't work
if a null byte may be part of the data. Here is an example where both
techniques are used: after two null terminated strings with source and
destination address, a Short Message (to a mobile phone) is sent after
a length byte:
.PP
.Vb 1
\&   my $msg = pack( \*(AqZ*Z*CA*\*(Aq, $src, $dst, length( $sm ), $sm );
.Ve
.PP
Unpacking this message can be done with the same template:
.PP
.Vb 1
\&   ( $src, $dst, $len, $sm ) = unpack( \*(AqZ*Z*CA*\*(Aq, $msg );
.Ve
.PP
There's a subtle trap lurking in the offing: Adding another field after
the Short Message (in variable \f(CW$sm\fR) is all right when packing, but this
cannot be unpacked naively:
.PP
.Vb 2
\&   # pack a message
\&   my $msg = pack( \*(AqZ*Z*CA*C\*(Aq, $src, $dst, length( $sm ), $sm, $prio );
\&
\&   # unpack fails \- $prio remains undefined!
\&   ( $src, $dst, $len, $sm, $prio ) = unpack( \*(AqZ*Z*CA*C\*(Aq, $msg );
.Ve
.PP
The pack code \f(CW\*(C`A*\*(C'\fR gobbles up all remaining bytes, and \f(CW$prio\fR remains
undefined! Before we let disappointment dampen the morale: Perl's got
the trump card to make this trick too, just a little further up the sleeve.
Watch this:
.PP
.Vb 2
\&   # pack a message: ASCIIZ, ASCIIZ, length/string, byte
\&   my $msg = pack( \*(AqZ* Z* C/A* C\*(Aq, $src, $dst, $sm, $prio );
\&
\&   # unpack
\&   ( $src, $dst, $sm, $prio ) = unpack( \*(AqZ* Z* C/A* C\*(Aq, $msg );
.Ve
.PP
Combining two pack codes with a slash (\f(CW\*(C`/\*(C'\fR) associates them with a single
value from the argument list. In \f(CW\*(C`pack\*(C'\fR, the length of the argument is
taken and packed according to the first code while the argument itself
is added after being converted with the template code after the slash.
This saves us the trouble of inserting the \f(CW\*(C`length\*(C'\fR call, but it is 
in \f(CW\*(C`unpack\*(C'\fR where we really score: The value of the length byte marks the
end of the string to be taken from the buffer. Since this combination
doesn't make sense except when the second pack code isn't \f(CW\*(C`a*\*(C'\fR, \f(CW\*(C`A*\*(C'\fR
or \f(CW\*(C`Z*\*(C'\fR, Perl won't let you.
.PP
The pack code preceding \f(CW\*(C`/\*(C'\fR may be anything that's fit to represent a
number: All the numeric binary pack codes, and even text codes such as
\&\f(CW\*(C`A4\*(C'\fR or \f(CW\*(C`Z*\*(C'\fR:
.PP
.Vb 4
\&   # pack/unpack a string preceded by its length in ASCII
\&   my $buf = pack( \*(AqA4/A*\*(Aq, "Humpty\-Dumpty" );
\&   # unpack $buf: \*(Aq13  Humpty\-Dumpty\*(Aq
\&   my $txt = unpack( \*(AqA4/A*\*(Aq, $buf );
.Ve
.PP
\&\f(CW\*(C`/\*(C'\fR is not implemented in Perls before 5.6, so if your code is required to
work on older Perls you'll need to \f(CW\*(C`unpack( \*(AqZ* Z* C\*(Aq)\*(C'\fR to get the length,
then use it to make a new unpack string. For example
.PP
.Vb 2
\&   # pack a message: ASCIIZ, ASCIIZ, length, string, byte (5.005 compatible)
\&   my $msg = pack( \*(AqZ* Z* C A* C\*(Aq, $src, $dst, length $sm, $sm, $prio );
\&
\&   # unpack
\&   ( undef, undef, $len) = unpack( \*(AqZ* Z* C\*(Aq, $msg );
\&   ($src, $dst, $sm, $prio) = unpack ( "Z* Z* x A$len C", $msg );
.Ve
.PP
But that second \f(CW\*(C`unpack\*(C'\fR is rushing ahead. It isn't using a simple literal
string for the template. So maybe we should introduce...
.SS "Dynamic Templates"
.IX Subsection "Dynamic Templates"
So far, we've seen literals used as templates. If the list of pack
items doesn't have fixed length, an expression constructing the
template is required (whenever, for some reason, \f(CW\*(C`()*\*(C'\fR cannot be used).
Here's an example: To store named string values in a way that can be
conveniently parsed by a C program, we create a sequence of names and
null terminated \s-1ASCII\s0 strings, with \f(CW\*(C`=\*(C'\fR between the name and the value,
followed by an additional delimiting null byte. Here's how:
.PP
.Vb 2
\&   my $env = pack( \*(Aq(A*A*Z*)\*(Aq . keys( %Env ) . \*(AqC\*(Aq,
\&                   map( { ( $_, \*(Aq=\*(Aq, $Env{$_} ) } keys( %Env ) ), 0 );
.Ve
.PP
Let's examine the cogs of this byte mill, one by one. There's the \f(CW\*(C`map\*(C'\fR
call, creating the items we intend to stuff into the \f(CW$env\fR buffer:
to each key (in \f(CW$_\fR) it adds the \f(CW\*(C`=\*(C'\fR separator and the hash entry value.
Each triplet is packed with the template code sequence \f(CW\*(C`A*A*Z*\*(C'\fR that
is repeated according to the number of keys. (Yes, that's what the \f(CW\*(C`keys\*(C'\fR
function returns in scalar context.) To get the very last null byte,
we add a \f(CW0\fR at the end of the \f(CW\*(C`pack\*(C'\fR list, to be packed with \f(CW\*(C`C\*(C'\fR.
(Attentive readers may have noticed that we could have omitted the 0.)
.PP
For the reverse operation, we'll have to determine the number of items
in the buffer before we can let \f(CW\*(C`unpack\*(C'\fR rip it apart:
.PP
.Vb 2
\&   my $n = $env =~ tr/\e0// \- 1;
\&   my %env = map( split( /=/, $_ ), unpack( "(Z*)$n", $env ) );
.Ve
.PP
The \f(CW\*(C`tr\*(C'\fR counts the null bytes. The \f(CW\*(C`unpack\*(C'\fR call returns a list of
name-value pairs each of which is taken apart in the \f(CW\*(C`map\*(C'\fR block.
.SS "Counting Repetitions"
.IX Subsection "Counting Repetitions"
Rather than storing a sentinel at the end of a data item (or a list of items),
we could precede the data with a count. Again, we pack keys and values of
a hash, preceding each with an unsigned short length count, and up front
we store the number of pairs:
.PP
.Vb 1
\&   my $env = pack( \*(AqS(S/A* S/A*)*\*(Aq, scalar keys( %Env ), %Env );
.Ve
.PP
This simplifies the reverse operation as the number of repetitions can be
unpacked with the \f(CW\*(C`/\*(C'\fR code:
.PP
.Vb 1
\&   my %env = unpack( \*(AqS/(S/A* S/A*)\*(Aq, $env );
.Ve
.PP
Note that this is one of the rare cases where you cannot use the same
template for \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR because \f(CW\*(C`pack\*(C'\fR can't determine
a repeat count for a \f(CW\*(C`()\*(C'\fR\-group.
.SS "Intel \s-1HEX\s0"
.IX Subsection "Intel HEX"
Intel \s-1HEX\s0 is a file format for representing binary data, mostly for
programming various chips, as a text file. (See
<http://en.wikipedia.org/wiki/.hex> for a detailed description, and
<http://en.wikipedia.org/wiki/SREC_(file_format)> for the Motorola
S\-record format, which can be unravelled using the same technique.)
Each line begins with a colon (':') and is followed by a sequence of
hexadecimal characters, specifying a byte count \fIn\fR (8 bit),
an address (16 bit, big endian), a record type (8 bit), \fIn\fR data bytes
and a checksum (8 bit) computed as the least significant byte of the two's
complement sum of the preceding bytes. Example: \f(CW\*(C`:0300300002337A1E\*(C'\fR.
.PP
The first step of processing such a line is the conversion, to binary,
of the hexadecimal data, to obtain the four fields, while checking the
checksum. No surprise here: we'll start with a simple \f(CW\*(C`pack\*(C'\fR call to 
convert everything to binary:
.PP
.Vb 1
\&   my $binrec = pack( \*(AqH*\*(Aq, substr( $hexrec, 1 ) );
.Ve
.PP
The resulting byte sequence is most convenient for checking the checksum.
Don't slow your program down with a for loop adding the \f(CW\*(C`ord\*(C'\fR values
of this string's bytes \- the \f(CW\*(C`unpack\*(C'\fR code \f(CW\*(C`%\*(C'\fR is the thing to use
for computing the 8\-bit sum of all bytes, which must be equal to zero:
.PP
.Vb 1
\&   die unless unpack( "%8C*", $binrec ) == 0;
.Ve
.PP
Finally, let's get those four fields. By now, you shouldn't have any
problems with the first three fields \- but how can we use the byte count
of the data in the first field as a length for the data field? Here
the codes \f(CW\*(C`x\*(C'\fR and \f(CW\*(C`X\*(C'\fR come to the rescue, as they permit jumping
back and forth in the string to unpack.
.PP
.Vb 1
\&   my( $addr, $type, $data ) = unpack( "x n C X4 C x3 /a", $bin );
.Ve
.PP
Code \f(CW\*(C`x\*(C'\fR skips a byte, since we don't need the count yet. Code \f(CW\*(C`n\*(C'\fR takes
care of the 16\-bit big-endian integer address, and \f(CW\*(C`C\*(C'\fR unpacks the
record type. Being at offset 4, where the data begins, we need the count.
\&\f(CW\*(C`X4\*(C'\fR brings us back to square one, which is the byte at offset 0.
Now we pick up the count, and zoom forth to offset 4, where we are
now fully furnished to extract the exact number of data bytes, leaving
the trailing checksum byte alone.
.SH "Packing and Unpacking C Structures"
.IX Header "Packing and Unpacking C Structures"
In previous sections we have seen how to pack numbers and character
strings. If it were not for a couple of snags we could conclude this
section right away with the terse remark that C structures don't
contain anything else, and therefore you already know all there is to it.
Sorry, no: read on, please.
.PP
If you have to deal with a lot of C structures, and don't want to
hack all your template strings manually, you'll probably want to have
a look at the \s-1CPAN\s0 module \f(CW\*(C`Convert::Binary::C\*(C'\fR. Not only can it parse
your C source directly, but it also has built-in support for all the
odds and ends described further on in this section.
.SS "The Alignment Pit"
.IX Subsection "The Alignment Pit"
In the consideration of speed against memory requirements the balance
has been tilted in favor of faster execution. This has influenced the
way C compilers allocate memory for structures: On architectures
where a 16\-bit or 32\-bit operand can be moved faster between places in
memory, or to or from a \s-1CPU\s0 register, if it is aligned at an even or 
multiple-of-four or even at a multiple-of eight address, a C compiler
will give you this speed benefit by stuffing extra bytes into structures.
If you don't cross the C shoreline this is not likely to cause you any
grief (although you should care when you design large data structures,
or you want your code to be portable between architectures (you do want
that, don't you?)).
.PP
To see how this affects \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR, we'll compare these two
C structures:
.PP
.Vb 6
\&   typedef struct {
\&     char     c1;
\&     short    s;
\&     char     c2;
\&     long     l;
\&   } gappy_t;
\&
\&   typedef struct {
\&     long     l;
\&     short    s;
\&     char     c1;
\&     char     c2;
\&   } dense_t;
.Ve
.PP
Typically, a C compiler allocates 12 bytes to a \f(CW\*(C`gappy_t\*(C'\fR variable, but
requires only 8 bytes for a \f(CW\*(C`dense_t\*(C'\fR. After investigating this further,
we can draw memory maps, showing where the extra 4 bytes are hidden:
.PP
.Vb 5
\&   0           +4          +8          +12
\&   +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&   |c1|xx|  s  |c2|xx|xx|xx|     l     |    xx = fill byte
\&   +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&   gappy_t
\&
\&   0           +4          +8
\&   +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&   |     l     |  h  |c1|c2|
\&   +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&   dense_t
.Ve
.PP
And that's where the first quirk strikes: \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR
templates have to be stuffed with \f(CW\*(C`x\*(C'\fR codes to get those extra fill bytes.
.PP
The natural question: \*(L"Why can't Perl compensate for the gaps?\*(R" warrants
an answer. One good reason is that C compilers might provide (non-ANSI)
extensions permitting all sorts of fancy control over the way structures
are aligned, even at the level of an individual structure field. And, if
this were not enough, there is an insidious thing called \f(CW\*(C`union\*(C'\fR where
the amount of fill bytes cannot be derived from the alignment of the next
item alone.
.PP
\&\s-1OK\s0, so let's bite the bullet. Here's one way to get the alignment right
by inserting template codes \f(CW\*(C`x\*(C'\fR, which don't take a corresponding item 
from the list:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aqcxs cxxx l!\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
Note the \f(CW\*(C`!\*(C'\fR after \f(CW\*(C`l\*(C'\fR: We want to make sure that we pack a long
integer as it is compiled by our C compiler. And even now, it will only
work for the platforms where the compiler aligns things as above.
And somebody somewhere has a platform where it doesn't.
[Probably a Cray, where \f(CW\*(C`short\*(C'\fRs, \f(CW\*(C`int\*(C'\fRs and \f(CW\*(C`long\*(C'\fRs are all 8 bytes. :\-)]
.PP
Counting bytes and watching alignments in lengthy structures is bound to 
be a drag. Isn't there a way we can create the template with a simple
program? Here's a C program that does the trick:
.PP
.Vb 2
\&   #include <stdio.h>
\&   #include <stddef.h>
\&
\&   typedef struct {
\&     char     fc1;
\&     short    fs;
\&     char     fc2;
\&     long     fl;
\&   } gappy_t;
\&
\&   #define Pt(struct,field,tchar) \e
\&     printf( "@%d%s ", offsetof(struct,field), # tchar );
\&
\&   int main() {
\&     Pt( gappy_t, fc1, c  );
\&     Pt( gappy_t, fs,  s! );
\&     Pt( gappy_t, fc2, c  );
\&     Pt( gappy_t, fl,  l! );
\&     printf( "\en" );
\&   }
.Ve
.PP
The output line can be used as a template in a \f(CW\*(C`pack\*(C'\fR or \f(CW\*(C`unpack\*(C'\fR call:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aq@0c @2s! @4c @8l!\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
Gee, yet another template code \- as if we hadn't plenty. But 
\&\f(CW\*(C`@\*(C'\fR saves our day by enabling us to specify the offset from the beginning
of the pack buffer to the next item: This is just the value
the \f(CW\*(C`offsetof\*(C'\fR macro (defined in \f(CW\*(C`<stddef.h>\*(C'\fR) returns when
given a \f(CW\*(C`struct\*(C'\fR type and one of its field names (\*(L"member-designator\*(R" in 
C standardese).
.PP
Neither using offsets nor adding \f(CW\*(C`x\*(C'\fR's to bridge the gaps is satisfactory.
(Just imagine what happens if the structure changes.) What we really need
is a way of saying \*(L"skip as many bytes as required to the next multiple of N\*(R".
In fluent Templatese, you say this with \f(CW\*(C`x!N\*(C'\fR where N is replaced by the
appropriate value. Here's the next version of our struct packaging:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aqc x!2 s c x!4 l!\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
That's certainly better, but we still have to know how long all the
integers are, and portability is far away. Rather than \f(CW2\fR,
for instance, we want to say \*(L"however long a short is\*(R". But this can be
done by enclosing the appropriate pack code in brackets: \f(CW\*(C`[s]\*(C'\fR. So, here's
the very best we can do:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aqc x![s] s c x![l!] l!\*(Aq, $c1, $s, $c2, $l );
.Ve
.SS "Dealing with Endian-ness"
.IX Subsection "Dealing with Endian-ness"
Now, imagine that we want to pack the data for a machine with a
different byte-order. First, we'll have to figure out how big the data
types on the target machine really are. Let's assume that the longs are
32 bits wide and the shorts are 16 bits wide. You can then rewrite the
template as:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aqc x![s] s c x![l] l\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
If the target machine is little-endian, we could write:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aqc x![s] s< c x![l] l<\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
This forces the short and the long members to be little-endian, and is
just fine if you don't have too many struct members. But we could also
use the byte-order modifier on a group and write the following:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aq( c x![s] s c x![l] l )<\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
This is not as short as before, but it makes it more obvious that we
intend to have little-endian byte-order for a whole group, not only
for individual template codes. It can also be more readable and easier
to maintain.
.SS "Alignment, Take 2"
.IX Subsection "Alignment, Take 2"
I'm afraid that we're not quite through with the alignment catch yet. The
hydra raises another ugly head when you pack arrays of structures:
.PP
.Vb 4
\&   typedef struct {
\&     short    count;
\&     char     glyph;
\&   } cell_t;
\&
\&   typedef cell_t buffer_t[BUFLEN];
.Ve
.PP
Where's the catch? Padding is neither required before the first field \f(CW\*(C`count\*(C'\fR,
nor between this and the next field \f(CW\*(C`glyph\*(C'\fR, so why can't we simply pack
like this:
.PP
.Vb 3
\&   # something goes wrong here:
\&   pack( \*(Aqs!a\*(Aq x @buffer,
\&         map{ ( $_\->{count}, $_\->{glyph} ) } @buffer );
.Ve
.PP
This packs \f(CW\*(C`3*@buffer\*(C'\fR bytes, but it turns out that the size of 
\&\f(CW\*(C`buffer_t\*(C'\fR is four times \f(CW\*(C`BUFLEN\*(C'\fR! The moral of the story is that
the required alignment of a structure or array is propagated to the
next higher level where we have to consider padding \fIat the end\fR
of each component as well. Thus the correct template is:
.PP
.Vb 2
\&   pack( \*(Aqs!ax\*(Aq x @buffer,
\&         map{ ( $_\->{count}, $_\->{glyph} ) } @buffer );
.Ve
.SS "Alignment, Take 3"
.IX Subsection "Alignment, Take 3"
And even if you take all the above into account, \s-1ANSI\s0 still lets this:
.PP
.Vb 3
\&   typedef struct {
\&     char     foo[2];
\&   } foo_t;
.Ve
.PP
vary in size. The alignment constraint of the structure can be greater than
any of its elements. [And if you think that this doesn't affect anything
common, dismember the next cellphone that you see. Many have \s-1ARM\s0 cores, and
the \s-1ARM\s0 structure rules make \f(CW\*(C`sizeof (foo_t)\*(C'\fR == 4]
.SS "Pointers for How to Use Them"
.IX Subsection "Pointers for How to Use Them"
The title of this section indicates the second problem you may run into
sooner or later when you pack C structures. If the function you intend
to call expects a, say, \f(CW\*(C`void *\*(C'\fR value, you \fIcannot\fR simply take
a reference to a Perl variable. (Although that value certainly is a
memory address, it's not the address where the variable's contents are
stored.)
.PP
Template code \f(CW\*(C`P\*(C'\fR promises to pack a \*(L"pointer to a fixed length string\*(R".
Isn't this what we want? Let's try:
.PP
.Vb 3
\&    # allocate some storage and pack a pointer to it
\&    my $memory = "\ex00" x $size;
\&    my $memptr = pack( \*(AqP\*(Aq, $memory );
.Ve
.PP
But wait: doesn't \f(CW\*(C`pack\*(C'\fR just return a sequence of bytes? How can we pass this
string of bytes to some C code expecting a pointer which is, after all,
nothing but a number? The answer is simple: We have to obtain the numeric
address from the bytes returned by \f(CW\*(C`pack\*(C'\fR.
.PP
.Vb 1
\&    my $ptr = unpack( \*(AqL!\*(Aq, $memptr );
.Ve
.PP
Obviously this assumes that it is possible to typecast a pointer
to an unsigned long and vice versa, which frequently works but should not
be taken as a universal law. \- Now that we have this pointer the next question
is: How can we put it to good use? We need a call to some C function
where a pointer is expected. The \fIread\fR\|(2) system call comes to mind:
.PP
.Vb 1
\&    ssize_t read(int fd, void *buf, size_t count);
.Ve
.PP
After reading perlfunc explaining how to use \f(CW\*(C`syscall\*(C'\fR we can write
this Perl function copying a file to standard output:
.PP
.Vb 12
\&    require \*(Aqsyscall.ph\*(Aq;
\&    sub cat($){
\&        my $path = shift();
\&        my $size = \-s $path;
\&        my $memory = "\ex00" x $size;  # allocate some memory
\&        my $ptr = unpack( \*(AqL\*(Aq, pack( \*(AqP\*(Aq, $memory ) );
\&        open( F, $path ) || die( "$path: cannot open ($!)\en" );
\&        my $fd = fileno(F);
\&        my $res = syscall( &SYS_read, fileno(F), $ptr, $size );
\&        print $memory;
\&        close( F );
\&    }
.Ve
.PP
This is neither a specimen of simplicity nor a paragon of portability but
it illustrates the point: We are able to sneak behind the scenes and
access Perl's otherwise well-guarded memory! (Important note: Perl's
\&\f(CW\*(C`syscall\*(C'\fR does \fInot\fR require you to construct pointers in this roundabout
way. You simply pass a string variable, and Perl forwards the address.)
.PP
How does \f(CW\*(C`unpack\*(C'\fR with \f(CW\*(C`P\*(C'\fR work? Imagine some pointer in the buffer
about to be unpacked: If it isn't the null pointer (which will smartly
produce the \f(CW\*(C`undef\*(C'\fR value) we have a start address \- but then what?
Perl has no way of knowing how long this \*(L"fixed length string\*(R" is, so
it's up to you to specify the actual size as an explicit length after \f(CW\*(C`P\*(C'\fR.
.PP
.Vb 2
\&   my $mem = "abcdefghijklmn";
\&   print unpack( \*(AqP5\*(Aq, pack( \*(AqP\*(Aq, $mem ) ); # prints "abcde"
.Ve
.PP
As a consequence, \f(CW\*(C`pack\*(C'\fR ignores any number or \f(CW\*(C`*\*(C'\fR after \f(CW\*(C`P\*(C'\fR.
.PP
Now that we have seen \f(CW\*(C`P\*(C'\fR at work, we might as well give \f(CW\*(C`p\*(C'\fR a whirl.
Why do we need a second template code for packing pointers at all? The 
answer lies behind the simple fact that an \f(CW\*(C`unpack\*(C'\fR with \f(CW\*(C`p\*(C'\fR promises
a null-terminated string starting at the address taken from the buffer,
and that implies a length for the data item to be returned:
.PP
.Vb 2
\&   my $buf = pack( \*(Aqp\*(Aq, "abc\ex00efhijklmn" );
\&   print unpack( \*(Aqp\*(Aq, $buf );    # prints "abc"
.Ve
.PP
Albeit this is apt to be confusing: As a consequence of the length being
implied by the string's length, a number after pack code \f(CW\*(C`p\*(C'\fR is a repeat
count, not a length as after \f(CW\*(C`P\*(C'\fR.
.PP
Using \f(CW\*(C`pack(..., $x)\*(C'\fR with \f(CW\*(C`P\*(C'\fR or \f(CW\*(C`p\*(C'\fR to get the address where \f(CW$x\fR is
actually stored must be used with circumspection. Perl's internal machinery
considers the relation between a variable and that address as its very own 
private matter and doesn't really care that we have obtained a copy. Therefore:
.IP "\(bu" 4
Do not use \f(CW\*(C`pack\*(C'\fR with \f(CW\*(C`p\*(C'\fR or \f(CW\*(C`P\*(C'\fR to obtain the address of variable
that's bound to go out of scope (and thereby freeing its memory) before you
are done with using the memory at that address.
.IP "\(bu" 4
Be very careful with Perl operations that change the value of the
variable. Appending something to the variable, for instance, might require
reallocation of its storage, leaving you with a pointer into no-man's land.
.IP "\(bu" 4
Don't think that you can get the address of a Perl variable
when it is stored as an integer or double number! \f(CW\*(C`pack(\*(AqP\*(Aq, $x)\*(C'\fR will
force the variable's internal representation to string, just as if you
had written something like \f(CW\*(C`$x .= \*(Aq\*(Aq\*(C'\fR.
.PP
It's safe, however, to P\- or p\-pack a string literal, because Perl simply
allocates an anonymous variable.
.SH "Pack Recipes"
.IX Header "Pack Recipes"
Here are a collection of (possibly) useful canned recipes for \f(CW\*(C`pack\*(C'\fR
and \f(CW\*(C`unpack\*(C'\fR:
.PP
.Vb 2
\&    # Convert IP address for socket functions
\&    pack( "C4", split /\e./, "123.4.5.6" ); 
\&
\&    # Count the bits in a chunk of memory (e.g. a select vector)
\&    unpack( \*(Aq%32b*\*(Aq, $mask );
\&
\&    # Determine the endianness of your system
\&    $is_little_endian = unpack( \*(Aqc\*(Aq, pack( \*(Aqs\*(Aq, 1 ) );
\&    $is_big_endian = unpack( \*(Aqxc\*(Aq, pack( \*(Aqs\*(Aq, 1 ) );
\&
\&    # Determine the number of bits in a native integer
\&    $bits = unpack( \*(Aq%32I!\*(Aq, ~0 );
\&
\&    # Prepare argument for the nanosleep system call
\&    my $timespec = pack( \*(AqL!L!\*(Aq, $secs, $nanosecs );
.Ve
.PP
For a simple memory dump we unpack some bytes into just as 
many pairs of hex digits, and use \f(CW\*(C`map\*(C'\fR to handle the traditional
spacing \- 16 bytes to a line:
.PP
.Vb 4
\&    my $i;
\&    print map( ++$i % 16 ? "$_ " : "$_\en",
\&               unpack( \*(AqH2\*(Aq x length( $mem ), $mem ) ),
\&          length( $mem ) % 16 ? "\en" : \*(Aq\*(Aq;
.Ve
.SH "Funnies Section"
.IX Header "Funnies Section"
.Vb 5
\&    # Pulling digits out of nowhere...
\&    print unpack( \*(AqC\*(Aq, pack( \*(Aqx\*(Aq ) ),
\&          unpack( \*(Aq%B*\*(Aq, pack( \*(AqA\*(Aq ) ),
\&          unpack( \*(AqH\*(Aq, pack( \*(AqA\*(Aq ) ),
\&          unpack( \*(AqA\*(Aq, unpack( \*(AqC\*(Aq, pack( \*(AqA\*(Aq ) ) ), "\en";
\&
\&    # One for the road ;\-)
\&    my $advice = pack( \*(Aqall u can in a van\*(Aq );
.Ve
.SH "Authors"
.IX Header "Authors"
Simon Cozens and Wolfgang Laun.
                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlpacktut5.18.1                            0100644 0001750 0001750 00000173636 12566207443 023633  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPACKTUT 1"
.TH PERLPACKTUT 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpacktut \- tutorial on "pack" and "unpack"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR are two functions for transforming data according
to a user-defined template, between the guarded way Perl stores values
and some well-defined representation as might be required in the 
environment of a Perl program. Unfortunately, they're also two of 
the most misunderstood and most often overlooked functions that Perl
provides. This tutorial will demystify them for you.
.SH "The Basic Principle"
.IX Header "The Basic Principle"
Most programming languages don't shelter the memory where variables are
stored. In C, for instance, you can take the address of some variable,
and the \f(CW\*(C`sizeof\*(C'\fR operator tells you how many bytes are allocated to
the variable. Using the address and the size, you may access the storage
to your heart's content.
.PP
In Perl, you just can't access memory at random, but the structural and
representational conversion provided by \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR is an
excellent alternative. The \f(CW\*(C`pack\*(C'\fR function converts values to a byte
sequence containing representations according to a given specification,
the so-called \*(L"template\*(R" argument. \f(CW\*(C`unpack\*(C'\fR is the reverse process,
deriving some values from the contents of a string of bytes. (Be cautioned,
however, that not all that has been packed together can be neatly unpacked \- 
a very common experience as seasoned travellers are likely to confirm.)
.PP
Why, you may ask, would you need a chunk of memory containing some values
in binary representation? One good reason is input and output accessing
some file, a device, or a network connection, whereby this binary
representation is either forced on you or will give you some benefit
in processing. Another cause is passing data to some system call that
is not available as a Perl function: \f(CW\*(C`syscall\*(C'\fR requires you to provide
parameters stored in the way it happens in a C program. Even text processing 
(as shown in the next section) may be simplified with judicious usage 
of these two functions.
.PP
To see how (un)packing works, we'll start with a simple template
code where the conversion is in low gear: between the contents of a byte
sequence and a string of hexadecimal digits. Let's use \f(CW\*(C`unpack\*(C'\fR, since
this is likely to remind you of a dump program, or some desperate last
message unfortunate programs are wont to throw at you before they expire
into the wild blue yonder. Assuming that the variable \f(CW$mem\fR holds a 
sequence of bytes that we'd like to inspect without assuming anything 
about its meaning, we can write
.PP
.Vb 2
\&   my( $hex ) = unpack( \*(AqH*\*(Aq, $mem );
\&   print "$hex\en";
.Ve
.PP
whereupon we might see something like this, with each pair of hex digits
corresponding to a byte:
.PP
.Vb 1
\&   41204d414e204120504c414e20412043414e414c2050414e414d41
.Ve
.PP
What was in this chunk of memory? Numbers, characters, or a mixture of
both? Assuming that we're on a computer where \s-1ASCII \s0(or some similar)
encoding is used: hexadecimal values in the range \f(CW0x40\fR \- \f(CW0x5A\fR
indicate an uppercase letter, and \f(CW0x20\fR encodes a space. So we might
assume it is a piece of text, which some are able to read like a tabloid;
but others will have to get hold of an \s-1ASCII\s0 table and relive that
firstgrader feeling. Not caring too much about which way to read this,
we note that \f(CW\*(C`unpack\*(C'\fR with the template code \f(CW\*(C`H\*(C'\fR converts the contents
of a sequence of bytes into the customary hexadecimal notation. Since
\&\*(L"a sequence of\*(R" is a pretty vague indication of quantity, \f(CW\*(C`H\*(C'\fR has been
defined to convert just a single hexadecimal digit unless it is followed
by a repeat count. An asterisk for the repeat count means to use whatever
remains.
.PP
The inverse operation \- packing byte contents from a string of hexadecimal
digits \- is just as easily written. For instance:
.PP
.Vb 2
\&   my $s = pack( \*(AqH2\*(Aq x 10, 30..39 );
\&   print "$s\en";
.Ve
.PP
Since we feed a list of ten 2\-digit hexadecimal strings to \f(CW\*(C`pack\*(C'\fR, the
pack template should contain ten pack codes. If this is run on a computer
with \s-1ASCII\s0 character coding, it will print \f(CW0123456789\fR.
.SH "Packing Text"
.IX Header "Packing Text"
Let's suppose you've got to read in a data file like this:
.PP
.Vb 4
\&    Date      |Description                | Income|Expenditure
\&    01/24/2001 Zed\*(Aqs Camel Emporium                    1147.99
\&    01/28/2001 Flea spray                                24.99
\&    01/29/2001 Camel rides to tourists      235.00
.Ve
.PP
How do we do it? You might think first to use \f(CW\*(C`split\*(C'\fR; however, since
\&\f(CW\*(C`split\*(C'\fR collapses blank fields, you'll never know whether a record was
income or expenditure. Oops. Well, you could always use \f(CW\*(C`substr\*(C'\fR:
.PP
.Vb 7
\&    while (<>) { 
\&        my $date   = substr($_,  0, 11);
\&        my $desc   = substr($_, 12, 27);
\&        my $income = substr($_, 40,  7);
\&        my $expend = substr($_, 52,  7);
\&        ...
\&    }
.Ve
.PP
It's not really a barrel of laughs, is it? In fact, it's worse than it
may seem; the eagle-eyed may notice that the first field should only be
10 characters wide, and the error has propagated right through the other
numbers \- which we've had to count by hand. So it's error-prone as well
as horribly unfriendly.
.PP
Or maybe we could use regular expressions:
.PP
.Vb 5
\&    while (<>) { 
\&        my($date, $desc, $income, $expend) = 
\&            m|(\ed\ed/\ed\ed/\ed{4}) (.{27}) (.{7})(.*)|;
\&        ...
\&    }
.Ve
.PP
Urgh. Well, it's a bit better, but \- well, would you want to maintain
that?
.PP
Hey, isn't Perl supposed to make this sort of thing easy? Well, it does,
if you use the right tools. \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR are designed to help
you out when dealing with fixed-width data like the above. Let's have a
look at a solution with \f(CW\*(C`unpack\*(C'\fR:
.PP
.Vb 4
\&    while (<>) { 
\&        my($date, $desc, $income, $expend) = unpack("A10xA27xA7A*", $_);
\&        ...
\&    }
.Ve
.PP
That looks a bit nicer; but we've got to take apart that weird template.
Where did I pull that out of?
.PP
\&\s-1OK,\s0 let's have a look at some of our data again; in fact, we'll include
the headers, and a handy ruler so we can keep track of where we are.
.PP
.Vb 5
\&             1         2         3         4         5        
\&    1234567890123456789012345678901234567890123456789012345678
\&    Date      |Description                | Income|Expenditure
\&    01/28/2001 Flea spray                                24.99
\&    01/29/2001 Camel rides to tourists      235.00
.Ve
.PP
From this, we can see that the date column stretches from column 1 to
column 10 \- ten characters wide. The \f(CW\*(C`pack\*(C'\fR\-ese for \*(L"character\*(R" is
\&\f(CW\*(C`A\*(C'\fR, and ten of them are \f(CW\*(C`A10\*(C'\fR. So if we just wanted to extract the
dates, we could say this:
.PP
.Vb 1
\&    my($date) = unpack("A10", $_);
.Ve
.PP
\&\s-1OK,\s0 what's next? Between the date and the description is a blank column;
we want to skip over that. The \f(CW\*(C`x\*(C'\fR template means \*(L"skip forward\*(R", so we
want one of those. Next, we have another batch of characters, from 12 to
38. That's 27 more characters, hence \f(CW\*(C`A27\*(C'\fR. (Don't make the fencepost
error \- there are 27 characters between 12 and 38, not 26. Count 'em!)
.PP
Now we skip another character and pick up the next 7 characters:
.PP
.Vb 1
\&    my($date,$description,$income) = unpack("A10xA27xA7", $_);
.Ve
.PP
Now comes the clever bit. Lines in our ledger which are just income and
not expenditure might end at column 46. Hence, we don't want to tell our
\&\f(CW\*(C`unpack\*(C'\fR pattern that we \fBneed\fR to find another 12 characters; we'll
just say \*(L"if there's anything left, take it\*(R". As you might guess from
regular expressions, that's what the \f(CW\*(C`*\*(C'\fR means: \*(L"use everything
remaining\*(R".
.IP "\(bu" 3
Be warned, though, that unlike regular expressions, if the \f(CW\*(C`unpack\*(C'\fR
template doesn't match the incoming data, Perl will scream and die.
.PP
Hence, putting it all together:
.PP
.Vb 1
\&    my($date,$description,$income,$expend) = unpack("A10xA27xA7xA*", $_);
.Ve
.PP
Now, that's our data parsed. I suppose what we might want to do now is
total up our income and expenditure, and add another line to the end of
our ledger \- in the same format \- saying how much we've brought in and
how much we've spent:
.PP
.Vb 5
\&    while (<>) {
\&        my($date, $desc, $income, $expend) = unpack("A10xA27xA7xA*", $_);
\&        $tot_income += $income;
\&        $tot_expend += $expend;
\&    }
\&
\&    $tot_income = sprintf("%.2f", $tot_income); # Get them into 
\&    $tot_expend = sprintf("%.2f", $tot_expend); # "financial" format
\&
\&    $date = POSIX::strftime("%m/%d/%Y", localtime); 
\&
\&    # OK, let\*(Aqs go:
\&
\&    print pack("A10xA27xA7xA*", $date, "Totals", $tot_income, $tot_expend);
.Ve
.PP
Oh, hmm. That didn't quite work. Let's see what happened:
.PP
.Vb 4
\&    01/24/2001 Zed\*(Aqs Camel Emporium                     1147.99
\&    01/28/2001 Flea spray                                 24.99
\&    01/29/2001 Camel rides to tourists     1235.00
\&    03/23/2001Totals                     1235.001172.98
.Ve
.PP
\&\s-1OK,\s0 it's a start, but what happened to the spaces? We put \f(CW\*(C`x\*(C'\fR, didn't
we? Shouldn't it skip forward? Let's look at what \*(L"pack\*(R" in perlfunc says:
.PP
.Vb 1
\&    x   A null byte.
.Ve
.PP
Urgh. No wonder. There's a big difference between \*(L"a null byte\*(R",
character zero, and \*(L"a space\*(R", character 32. Perl's put something
between the date and the description \- but unfortunately, we can't see
it!
.PP
What we actually need to do is expand the width of the fields. The \f(CW\*(C`A\*(C'\fR
format pads any non-existent characters with spaces, so we can use the
additional spaces to line up our fields, like this:
.PP
.Vb 1
\&    print pack("A11 A28 A8 A*", $date, "Totals", $tot_income, $tot_expend);
.Ve
.PP
(Note that you can put spaces in the template to make it more readable,
but they don't translate to spaces in the output.) Here's what we got
this time:
.PP
.Vb 4
\&    01/24/2001 Zed\*(Aqs Camel Emporium                     1147.99
\&    01/28/2001 Flea spray                                 24.99
\&    01/29/2001 Camel rides to tourists     1235.00
\&    03/23/2001 Totals                      1235.00 1172.98
.Ve
.PP
That's a bit better, but we still have that last column which needs to
be moved further over. There's an easy way to fix this up:
unfortunately, we can't get \f(CW\*(C`pack\*(C'\fR to right-justify our fields, but we
can get \f(CW\*(C`sprintf\*(C'\fR to do it:
.PP
.Vb 4
\&    $tot_income = sprintf("%.2f", $tot_income); 
\&    $tot_expend = sprintf("%12.2f", $tot_expend);
\&    $date = POSIX::strftime("%m/%d/%Y", localtime); 
\&    print pack("A11 A28 A8 A*", $date, "Totals", $tot_income, $tot_expend);
.Ve
.PP
This time we get the right answer:
.PP
.Vb 3
\&    01/28/2001 Flea spray                                 24.99
\&    01/29/2001 Camel rides to tourists     1235.00
\&    03/23/2001 Totals                      1235.00      1172.98
.Ve
.PP
So that's how we consume and produce fixed-width data. Let's recap what
we've seen of \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR so far:
.IP "\(bu" 3
Use \f(CW\*(C`pack\*(C'\fR to go from several pieces of data to one fixed-width
version; use \f(CW\*(C`unpack\*(C'\fR to turn a fixed-width-format string into several
pieces of data.
.IP "\(bu" 3
The pack format \f(CW\*(C`A\*(C'\fR means \*(L"any character\*(R"; if you're \f(CW\*(C`pack\*(C'\fRing and
you've run out of things to pack, \f(CW\*(C`pack\*(C'\fR will fill the rest up with
spaces.
.IP "\(bu" 3
\&\f(CW\*(C`x\*(C'\fR means \*(L"skip a byte\*(R" when \f(CW\*(C`unpack\*(C'\fRing; when \f(CW\*(C`pack\*(C'\fRing, it means
\&\*(L"introduce a null byte\*(R" \- that's probably not what you mean if you're
dealing with plain text.
.IP "\(bu" 3
You can follow the formats with numbers to say how many characters
should be affected by that format: \f(CW\*(C`A12\*(C'\fR means \*(L"take 12 characters\*(R";
\&\f(CW\*(C`x6\*(C'\fR means \*(L"skip 6 bytes\*(R" or \*(L"character 0, 6 times\*(R".
.IP "\(bu" 3
Instead of a number, you can use \f(CW\*(C`*\*(C'\fR to mean \*(L"consume everything else
left\*(R".
.Sp
\&\fBWarning\fR: when packing multiple pieces of data, \f(CW\*(C`*\*(C'\fR only means
\&\*(L"consume all of the current piece of data\*(R". That's to say
.Sp
.Vb 1
\&    pack("A*A*", $one, $two)
.Ve
.Sp
packs all of \f(CW$one\fR into the first \f(CW\*(C`A*\*(C'\fR and then all of \f(CW$two\fR into
the second. This is a general principle: each format character
corresponds to one piece of data to be \f(CW\*(C`pack\*(C'\fRed.
.SH "Packing Numbers"
.IX Header "Packing Numbers"
So much for textual data. Let's get onto the meaty stuff that \f(CW\*(C`pack\*(C'\fR
and \f(CW\*(C`unpack\*(C'\fR are best at: handling binary formats for numbers. There is,
of course, not just one binary format  \- life would be too simple \- but
Perl will do all the finicky labor for you.
.SS "Integers"
.IX Subsection "Integers"
Packing and unpacking numbers implies conversion to and from some
\&\fIspecific\fR binary representation. Leaving floating point numbers
aside for the moment, the salient properties of any such representation
are:
.IP "\(bu" 4
the number of bytes used for storing the integer,
.IP "\(bu" 4
whether the contents are interpreted as a signed or unsigned number,
.IP "\(bu" 4
the byte ordering: whether the first byte is the least or most
significant byte (or: little-endian or big-endian, respectively).
.PP
So, for instance, to pack 20302 to a signed 16 bit integer in your
computer's representation you write
.PP
.Vb 1
\&   my $ps = pack( \*(Aqs\*(Aq, 20302 );
.Ve
.PP
Again, the result is a string, now containing 2 bytes. If you print 
this string (which is, generally, not recommended) you might see
\&\f(CW\*(C`ON\*(C'\fR or \f(CW\*(C`NO\*(C'\fR (depending on your system's byte ordering) \- or something
entirely different if your computer doesn't use \s-1ASCII\s0 character encoding.
Unpacking \f(CW$ps\fR with the same template returns the original integer value:
.PP
.Vb 1
\&   my( $s ) = unpack( \*(Aqs\*(Aq, $ps );
.Ve
.PP
This is true for all numeric template codes. But don't expect miracles:
if the packed value exceeds the allotted byte capacity, high order bits
are silently discarded, and unpack certainly won't be able to pull them
back out of some magic hat. And, when you pack using a signed template
code such as \f(CW\*(C`s\*(C'\fR, an excess value may result in the sign bit
getting set, and unpacking this will smartly return a negative value.
.PP
16 bits won't get you too far with integers, but there is \f(CW\*(C`l\*(C'\fR and \f(CW\*(C`L\*(C'\fR
for signed and unsigned 32\-bit integers. And if this is not enough and
your system supports 64 bit integers you can push the limits much closer
to infinity with pack codes \f(CW\*(C`q\*(C'\fR and \f(CW\*(C`Q\*(C'\fR. A notable exception is provided
by pack codes \f(CW\*(C`i\*(C'\fR and \f(CW\*(C`I\*(C'\fR for signed and unsigned integers of the 
\&\*(L"local custom\*(R" variety: Such an integer will take up as many bytes as
a local C compiler returns for \f(CW\*(C`sizeof(int)\*(C'\fR, but it'll use \fIat least\fR
32 bits.
.PP
Each of the integer pack codes \f(CW\*(C`sSlLqQ\*(C'\fR results in a fixed number of bytes,
no matter where you execute your program. This may be useful for some 
applications, but it does not provide for a portable way to pass data 
structures between Perl and C programs (bound to happen when you call 
\&\s-1XS\s0 extensions or the Perl function \f(CW\*(C`syscall\*(C'\fR), or when you read or
write binary files. What you'll need in this case are template codes that
depend on what your local C compiler compiles when you code \f(CW\*(C`short\*(C'\fR or
\&\f(CW\*(C`unsigned long\*(C'\fR, for instance. These codes and their corresponding
byte lengths are shown in the table below.  Since the C standard leaves
much leeway with respect to the relative sizes of these data types, actual
values may vary, and that's why the values are given as expressions in
C and Perl. (If you'd like to use values from \f(CW%Config\fR in your program
you have to import it with \f(CW\*(C`use Config\*(C'\fR.)
.PP
.Vb 5
\&   signed unsigned  byte length in C   byte length in Perl       
\&     s!     S!      sizeof(short)      $Config{shortsize}
\&     i!     I!      sizeof(int)        $Config{intsize}
\&     l!     L!      sizeof(long)       $Config{longsize}
\&     q!     Q!      sizeof(long long)  $Config{longlongsize}
.Ve
.PP
The \f(CW\*(C`i!\*(C'\fR and \f(CW\*(C`I!\*(C'\fR codes aren't different from \f(CW\*(C`i\*(C'\fR and \f(CW\*(C`I\*(C'\fR; they are
tolerated for completeness' sake.
.SS "Unpacking a Stack Frame"
.IX Subsection "Unpacking a Stack Frame"
Requesting a particular byte ordering may be necessary when you work with
binary data coming from some specific architecture whereas your program could
run on a totally different system. As an example, assume you have 24 bytes
containing a stack frame as it happens on an Intel 8086:
.PP
.Vb 11
\&      +\-\-\-\-\-\-\-\-\-+        +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\& TOS: |   IP    |  TOS+4:| FL | FH | FLAGS  TOS+14:|   SI    |
\&      +\-\-\-\-\-\-\-\-\-+        +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\&      |   CS    |        | AL | AH | AX            |   DI    |
\&      +\-\-\-\-\-\-\-\-\-+        +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\&                         | BL | BH | BX            |   BP    |
\&                         +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\&                         | CL | CH | CX            |   DS    |
\&                         +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
\&                         | DL | DH | DX            |   ES    |
\&                         +\-\-\-\-+\-\-\-\-+               +\-\-\-\-\-\-\-\-\-+
.Ve
.PP
First, we note that this time-honored 16\-bit \s-1CPU\s0 uses little-endian order,
and that's why the low order byte is stored at the lower address. To
unpack such a (unsigned) short we'll have to use code \f(CW\*(C`v\*(C'\fR. A repeat
count unpacks all 12 shorts:
.PP
.Vb 2
\&   my( $ip, $cs, $flags, $ax, $bx, $cd, $dx, $si, $di, $bp, $ds, $es ) =
\&     unpack( \*(Aqv12\*(Aq, $frame );
.Ve
.PP
Alternatively, we could have used \f(CW\*(C`C\*(C'\fR to unpack the individually
accessible byte registers \s-1FL, FH, AL, AH,\s0 etc.:
.PP
.Vb 2
\&   my( $fl, $fh, $al, $ah, $bl, $bh, $cl, $ch, $dl, $dh ) =
\&     unpack( \*(AqC10\*(Aq, substr( $frame, 4, 10 ) );
.Ve
.PP
It would be nice if we could do this in one fell swoop: unpack a short,
back up a little, and then unpack 2 bytes. Since Perl \fIis\fR nice, it
proffers the template code \f(CW\*(C`X\*(C'\fR to back up one byte. Putting this all
together, we may now write:
.PP
.Vb 5
\&   my( $ip, $cs,
\&       $flags,$fl,$fh,
\&       $ax,$al,$ah, $bx,$bl,$bh, $cx,$cl,$ch, $dx,$dl,$dh, 
\&       $si, $di, $bp, $ds, $es ) =
\&   unpack( \*(Aqv2\*(Aq . (\*(AqvXXCC\*(Aq x 5) . \*(Aqv5\*(Aq, $frame );
.Ve
.PP
(The clumsy construction of the template can be avoided \- just read on!)
.PP
We've taken some pains to construct the template so that it matches
the contents of our frame buffer. Otherwise we'd either get undefined values,
or \f(CW\*(C`unpack\*(C'\fR could not unpack all. If \f(CW\*(C`pack\*(C'\fR runs out of items, it will
supply null strings (which are coerced into zeroes whenever the pack code
says so).
.SS "How to Eat an Egg on a Net"
.IX Subsection "How to Eat an Egg on a Net"
The pack code for big-endian (high order byte at the lowest address) is
\&\f(CW\*(C`n\*(C'\fR for 16 bit and \f(CW\*(C`N\*(C'\fR for 32 bit integers. You use these codes
if you know that your data comes from a compliant architecture, but,
surprisingly enough, you should also use these pack codes if you
exchange binary data, across the network, with some system that you
know next to nothing about. The simple reason is that this
order has been chosen as the \fInetwork order\fR, and all standard-fearing
programs ought to follow this convention. (This is, of course, a stern
backing for one of the Lilliputian parties and may well influence the
political development there.) So, if the protocol expects you to send
a message by sending the length first, followed by just so many bytes,
you could write:
.PP
.Vb 1
\&   my $buf = pack( \*(AqN\*(Aq, length( $msg ) ) . $msg;
.Ve
.PP
or even:
.PP
.Vb 1
\&   my $buf = pack( \*(AqNA*\*(Aq, length( $msg ), $msg );
.Ve
.PP
and pass \f(CW$buf\fR to your send routine. Some protocols demand that the
count should include the length of the count itself: then just add 4
to the data length. (But make sure to read \*(L"Lengths and Widths\*(R" before
you really code this!)
.SS "Byte-order modifiers"
.IX Subsection "Byte-order modifiers"
In the previous sections we've learned how to use \f(CW\*(C`n\*(C'\fR, \f(CW\*(C`N\*(C'\fR, \f(CW\*(C`v\*(C'\fR and
\&\f(CW\*(C`V\*(C'\fR to pack and unpack integers with big\- or little-endian byte-order.
While this is nice, it's still rather limited because it leaves out all
kinds of signed integers as well as 64\-bit integers. For example, if you
wanted to unpack a sequence of signed big-endian 16\-bit integers in a
platform-independent way, you would have to write:
.PP
.Vb 1
\&   my @data = unpack \*(Aqs*\*(Aq, pack \*(AqS*\*(Aq, unpack \*(Aqn*\*(Aq, $buf;
.Ve
.PP
This is ugly. As of Perl 5.9.2, there's a much nicer way to express your
desire for a certain byte-order: the \f(CW\*(C`>\*(C'\fR and \f(CW\*(C`<\*(C'\fR modifiers.
\&\f(CW\*(C`>\*(C'\fR is the big-endian modifier, while \f(CW\*(C`<\*(C'\fR is the little-endian
modifier. Using them, we could rewrite the above code as:
.PP
.Vb 1
\&   my @data = unpack \*(Aqs>*\*(Aq, $buf;
.Ve
.PP
As you can see, the \*(L"big end\*(R" of the arrow touches the \f(CW\*(C`s\*(C'\fR, which is a
nice way to remember that \f(CW\*(C`>\*(C'\fR is the big-endian modifier. The same
obviously works for \f(CW\*(C`<\*(C'\fR, where the \*(L"little end\*(R" touches the code.
.PP
You will probably find these modifiers even more useful if you have
to deal with big\- or little-endian C structures. Be sure to read
\&\*(L"Packing and Unpacking C Structures\*(R" for more on that.
.SS "Floating point Numbers"
.IX Subsection "Floating point Numbers"
For packing floating point numbers you have the choice between the
pack codes \f(CW\*(C`f\*(C'\fR, \f(CW\*(C`d\*(C'\fR, \f(CW\*(C`F\*(C'\fR and \f(CW\*(C`D\*(C'\fR. \f(CW\*(C`f\*(C'\fR and \f(CW\*(C`d\*(C'\fR pack into (or unpack
from) single-precision or double-precision representation as it is provided
by your system. If your systems supports it, \f(CW\*(C`D\*(C'\fR can be used to pack and
unpack extended-precision floating point values (\f(CW\*(C`long double\*(C'\fR), which
can offer even more resolution than \f(CW\*(C`f\*(C'\fR or \f(CW\*(C`d\*(C'\fR. \f(CW\*(C`F\*(C'\fR packs an \f(CW\*(C`NV\*(C'\fR,
which is the floating point type used by Perl internally. (There
is no such thing as a network representation for reals, so if you want
to send your real numbers across computer boundaries, you'd better stick
to \s-1ASCII\s0 representation, unless you're absolutely sure what's on the other
end of the line. For the even more adventuresome, you can use the byte-order
modifiers from the previous section also on floating point codes.)
.SH "Exotic Templates"
.IX Header "Exotic Templates"
.SS "Bit Strings"
.IX Subsection "Bit Strings"
Bits are the atoms in the memory world. Access to individual bits may
have to be used either as a last resort or because it is the most
convenient way to handle your data. Bit string (un)packing converts
between strings containing a series of \f(CW0\fR and \f(CW1\fR characters and
a sequence of bytes each containing a group of 8 bits. This is almost
as simple as it sounds, except that there are two ways the contents of
a byte may be written as a bit string. Let's have a look at an annotated
byte:
.PP
.Vb 5
\&     7 6 5 4 3 2 1 0
\&   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&   | 1 0 0 0 1 1 0 0 |
\&   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    MSB           LSB
.Ve
.PP
It's egg-eating all over again: Some think that as a bit string this should
be written \*(L"10001100\*(R" i.e. beginning with the most significant bit, others
insist on \*(L"00110001\*(R". Well, Perl isn't biased, so that's why we have two bit
string codes:
.PP
.Vb 2
\&   $byte = pack( \*(AqB8\*(Aq, \*(Aq10001100\*(Aq ); # start with MSB
\&   $byte = pack( \*(Aqb8\*(Aq, \*(Aq00110001\*(Aq ); # start with LSB
.Ve
.PP
It is not possible to pack or unpack bit fields \- just integral bytes.
\&\f(CW\*(C`pack\*(C'\fR always starts at the next byte boundary and \*(L"rounds up\*(R" to the
next multiple of 8 by adding zero bits as required. (If you do want bit
fields, there is \*(L"vec\*(R" in perlfunc. Or you could implement bit field 
handling at the character string level, using split, substr, and
concatenation on unpacked bit strings.)
.PP
To illustrate unpacking for bit strings, we'll decompose a simple
status register (a \*(L"\-\*(R" stands for a \*(L"reserved\*(R" bit):
.PP
.Vb 4
\&   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&   | S Z \- A \- P \- C | \- \- \- \- O D I T |
\&   +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&    MSB           LSB MSB           LSB
.Ve
.PP
Converting these two bytes to a string can be done with the unpack 
template \f(CW\*(Aqb16\*(Aq\fR. To obtain the individual bit values from the bit
string we use \f(CW\*(C`split\*(C'\fR with the \*(L"empty\*(R" separator pattern which dissects
into individual characters. Bit values from the \*(L"reserved\*(R" positions are
simply assigned to \f(CW\*(C`undef\*(C'\fR, a convenient notation for \*(L"I don't care where
this goes\*(R".
.PP
.Vb 3
\&   ($carry, undef, $parity, undef, $auxcarry, undef, $zero, $sign,
\&    $trace, $interrupt, $direction, $overflow) =
\&      split( //, unpack( \*(Aqb16\*(Aq, $status ) );
.Ve
.PP
We could have used an unpack template \f(CW\*(Aqb12\*(Aq\fR just as well, since the
last 4 bits can be ignored anyway.
.SS "Uuencoding"
.IX Subsection "Uuencoding"
Another odd-man-out in the template alphabet is \f(CW\*(C`u\*(C'\fR, which packs an
\&\*(L"uuencoded string\*(R". (\*(L"uu\*(R" is short for Unix-to-Unix.) Chances are that
you won't ever need this encoding technique which was invented to overcome
the shortcomings of old-fashioned transmission mediums that do not support
other than simple \s-1ASCII\s0 data. The essential recipe is simple: Take three 
bytes, or 24 bits. Split them into 4 six-packs, adding a space (0x20) to 
each. Repeat until all of the data is blended. Fold groups of 4 bytes into 
lines no longer than 60 and garnish them in front with the original byte count 
(incremented by 0x20) and a \f(CW"\en"\fR at the end. \- The \f(CW\*(C`pack\*(C'\fR chef will
prepare this for you, a la minute, when you select pack code \f(CW\*(C`u\*(C'\fR on the menu:
.PP
.Vb 1
\&   my $uubuf = pack( \*(Aqu\*(Aq, $bindat );
.Ve
.PP
A repeat count after \f(CW\*(C`u\*(C'\fR sets the number of bytes to put into an
uuencoded line, which is the maximum of 45 by default, but could be
set to some (smaller) integer multiple of three. \f(CW\*(C`unpack\*(C'\fR simply ignores
the repeat count.
.SS "Doing Sums"
.IX Subsection "Doing Sums"
An even stranger template code is \f(CW\*(C`%\*(C'\fR<\fInumber\fR>. First, because 
it's used as a prefix to some other template code. Second, because it
cannot be used in \f(CW\*(C`pack\*(C'\fR at all, and third, in \f(CW\*(C`unpack\*(C'\fR, doesn't return the
data as defined by the template code it precedes. Instead it'll give you an
integer of \fInumber\fR bits that is computed from the data value by 
doing sums. For numeric unpack codes, no big feat is achieved:
.PP
.Vb 2
\&    my $buf = pack( \*(Aqiii\*(Aq, 100, 20, 3 );
\&    print unpack( \*(Aq%32i3\*(Aq, $buf ), "\en";  # prints 123
.Ve
.PP
For string values, \f(CW\*(C`%\*(C'\fR returns the sum of the byte values saving
you the trouble of a sum loop with \f(CW\*(C`substr\*(C'\fR and \f(CW\*(C`ord\*(C'\fR:
.PP
.Vb 1
\&    print unpack( \*(Aq%32A*\*(Aq, "\ex01\ex10" ), "\en";  # prints 17
.Ve
.PP
Although the \f(CW\*(C`%\*(C'\fR code is documented as returning a \*(L"checksum\*(R":
don't put your trust in such values! Even when applied to a small number
of bytes, they won't guarantee a noticeable Hamming distance.
.PP
In connection with \f(CW\*(C`b\*(C'\fR or \f(CW\*(C`B\*(C'\fR, \f(CW\*(C`%\*(C'\fR simply adds bits, and this can be put
to good use to count set bits efficiently:
.PP
.Vb 1
\&    my $bitcount = unpack( \*(Aq%32b*\*(Aq, $mask );
.Ve
.PP
And an even parity bit can be determined like this:
.PP
.Vb 1
\&    my $evenparity = unpack( \*(Aq%1b*\*(Aq, $mask );
.Ve
.SS "Unicode"
.IX Subsection "Unicode"
Unicode is a character set that can represent most characters in most of
the world's languages, providing room for over one million different
characters. Unicode 3.1 specifies 94,140 characters: The Basic Latin
characters are assigned to the numbers 0 \- 127. The Latin\-1 Supplement with
characters that are used in several European languages is in the next
range, up to 255. After some more Latin extensions we find the character
sets from languages using non-Roman alphabets, interspersed with a
variety of symbol sets such as currency symbols, Zapf Dingbats or Braille.
(You might want to visit <http://www.unicode.org/> for a look at some of
them \- my personal favourites are Telugu and Kannada.)
.PP
The Unicode character sets associates characters with integers. Encoding
these numbers in an equal number of bytes would more than double the
requirements for storing texts written in Latin alphabets.
The \s-1UTF\-8\s0 encoding avoids this by storing the most common (from a western
point of view) characters in a single byte while encoding the rarer
ones in three or more bytes.
.PP
Perl uses \s-1UTF\-8,\s0 internally, for most Unicode strings.
.PP
So what has this got to do with \f(CW\*(C`pack\*(C'\fR? Well, if you want to compose a
Unicode string (that is internally encoded as \s-1UTF\-8\s0), you can do so by
using template code \f(CW\*(C`U\*(C'\fR. As an example, let's produce the Euro currency
symbol (code number 0x20AC):
.PP
.Vb 2
\&   $UTF8{Euro} = pack( \*(AqU\*(Aq, 0x20AC );
\&   # Equivalent to: $UTF8{Euro} = "\ex{20ac}";
.Ve
.PP
Inspecting \f(CW$UTF8{Euro}\fR shows that it contains 3 bytes:
\&\*(L"\exe2\ex82\exac\*(R". However, it contains only 1 character, number 0x20AC.
The round trip can be completed with \f(CW\*(C`unpack\*(C'\fR:
.PP
.Vb 1
\&   $Unicode{Euro} = unpack( \*(AqU\*(Aq, $UTF8{Euro} );
.Ve
.PP
Unpacking using the \f(CW\*(C`U\*(C'\fR template code also works on \s-1UTF\-8\s0 encoded byte
strings.
.PP
Usually you'll want to pack or unpack \s-1UTF\-8\s0 strings:
.PP
.Vb 3
\&   # pack and unpack the Hebrew alphabet
\&   my $alefbet = pack( \*(AqU*\*(Aq, 0x05d0..0x05ea );
\&   my @hebrew = unpack( \*(AqU*\*(Aq, $utf );
.Ve
.PP
Please note: in the general case, you're better off using
Encode::decode_utf8 to decode a \s-1UTF\-8\s0 encoded byte string to a Perl
Unicode string, and Encode::encode_utf8 to encode a Perl Unicode string
to \s-1UTF\-8\s0 bytes. These functions provide means of handling invalid byte
sequences and generally have a friendlier interface.
.SS "Another Portable Binary Encoding"
.IX Subsection "Another Portable Binary Encoding"
The pack code \f(CW\*(C`w\*(C'\fR has been added to support a portable binary data
encoding scheme that goes way beyond simple integers. (Details can
be found at <http://Casbah.org/>, the Scarab project.)  A \s-1BER \s0(Binary Encoded
Representation) compressed unsigned integer stores base 128
digits, most significant digit first, with as few digits as possible.
Bit eight (the high bit) is set on each byte except the last. There
is no size limit to \s-1BER\s0 encoding, but Perl won't go to extremes.
.PP
.Vb 1
\&   my $berbuf = pack( \*(Aqw*\*(Aq, 1, 128, 128+1, 128*128+127 );
.Ve
.PP
A hex dump of \f(CW$berbuf\fR, with spaces inserted at the right places,
shows 01 8100 8101 81807F. Since the last byte is always less than
128, \f(CW\*(C`unpack\*(C'\fR knows where to stop.
.SH "Template Grouping"
.IX Header "Template Grouping"
Prior to Perl 5.8, repetitions of templates had to be made by
\&\f(CW\*(C`x\*(C'\fR\-multiplication of template strings. Now there is a better way as
we may use the pack codes \f(CW\*(C`(\*(C'\fR and \f(CW\*(C`)\*(C'\fR combined with a repeat count.
The \f(CW\*(C`unpack\*(C'\fR template from the Stack Frame example can simply
be written like this:
.PP
.Vb 1
\&   unpack( \*(Aqv2 (vXXCC)5 v5\*(Aq, $frame )
.Ve
.PP
Let's explore this feature a little more. We'll begin with the equivalent of
.PP
.Vb 1
\&   join( \*(Aq\*(Aq, map( substr( $_, 0, 1 ), @str ) )
.Ve
.PP
which returns a string consisting of the first character from each string.
Using pack, we can write
.PP
.Vb 1
\&   pack( \*(Aq(A)\*(Aq.@str, @str )
.Ve
.PP
or, because a repeat count \f(CW\*(C`*\*(C'\fR means \*(L"repeat as often as required\*(R",
simply
.PP
.Vb 1
\&   pack( \*(Aq(A)*\*(Aq, @str )
.Ve
.PP
(Note that the template \f(CW\*(C`A*\*(C'\fR would only have packed \f(CW$str[0]\fR in full
length.)
.PP
To pack dates stored as triplets ( day, month, year ) in an array \f(CW@dates\fR
into a sequence of byte, byte, short integer we can write
.PP
.Vb 1
\&   $pd = pack( \*(Aq(CCS)*\*(Aq, map( @$_, @dates ) );
.Ve
.PP
To swap pairs of characters in a string (with even length) one could use
several techniques. First, let's use \f(CW\*(C`x\*(C'\fR and \f(CW\*(C`X\*(C'\fR to skip forward and back:
.PP
.Vb 1
\&   $s = pack( \*(Aq(A)*\*(Aq, unpack( \*(Aq(xAXXAx)*\*(Aq, $s ) );
.Ve
.PP
We can also use \f(CW\*(C`@\*(C'\fR to jump to an offset, with 0 being the position where
we were when the last \f(CW\*(C`(\*(C'\fR was encountered:
.PP
.Vb 1
\&   $s = pack( \*(Aq(A)*\*(Aq, unpack( \*(Aq(@1A @0A @2)*\*(Aq, $s ) );
.Ve
.PP
Finally, there is also an entirely different approach by unpacking big
endian shorts and packing them in the reverse byte order:
.PP
.Vb 1
\&   $s = pack( \*(Aq(v)*\*(Aq, unpack( \*(Aq(n)*\*(Aq, $s );
.Ve
.SH "Lengths and Widths"
.IX Header "Lengths and Widths"
.SS "String Lengths"
.IX Subsection "String Lengths"
In the previous section we've seen a network message that was constructed
by prefixing the binary message length to the actual message. You'll find
that packing a length followed by so many bytes of data is a 
frequently used recipe since appending a null byte won't work
if a null byte may be part of the data. Here is an example where both
techniques are used: after two null terminated strings with source and
destination address, a Short Message (to a mobile phone) is sent after
a length byte:
.PP
.Vb 1
\&   my $msg = pack( \*(AqZ*Z*CA*\*(Aq, $src, $dst, length( $sm ), $sm );
.Ve
.PP
Unpacking this message can be done with the same template:
.PP
.Vb 1
\&   ( $src, $dst, $len, $sm ) = unpack( \*(AqZ*Z*CA*\*(Aq, $msg );
.Ve
.PP
There's a subtle trap lurking in the offing: Adding another field after
the Short Message (in variable \f(CW$sm\fR) is all right when packing, but this
cannot be unpacked naively:
.PP
.Vb 2
\&   # pack a message
\&   my $msg = pack( \*(AqZ*Z*CA*C\*(Aq, $src, $dst, length( $sm ), $sm, $prio );
\&
\&   # unpack fails \- $prio remains undefined!
\&   ( $src, $dst, $len, $sm, $prio ) = unpack( \*(AqZ*Z*CA*C\*(Aq, $msg );
.Ve
.PP
The pack code \f(CW\*(C`A*\*(C'\fR gobbles up all remaining bytes, and \f(CW$prio\fR remains
undefined! Before we let disappointment dampen the morale: Perl's got
the trump card to make this trick too, just a little further up the sleeve.
Watch this:
.PP
.Vb 2
\&   # pack a message: ASCIIZ, ASCIIZ, length/string, byte
\&   my $msg = pack( \*(AqZ* Z* C/A* C\*(Aq, $src, $dst, $sm, $prio );
\&
\&   # unpack
\&   ( $src, $dst, $sm, $prio ) = unpack( \*(AqZ* Z* C/A* C\*(Aq, $msg );
.Ve
.PP
Combining two pack codes with a slash (\f(CW\*(C`/\*(C'\fR) associates them with a single
value from the argument list. In \f(CW\*(C`pack\*(C'\fR, the length of the argument is
taken and packed according to the first code while the argument itself
is added after being converted with the template code after the slash.
This saves us the trouble of inserting the \f(CW\*(C`length\*(C'\fR call, but it is 
in \f(CW\*(C`unpack\*(C'\fR where we really score: The value of the length byte marks the
end of the string to be taken from the buffer. Since this combination
doesn't make sense except when the second pack code isn't \f(CW\*(C`a*\*(C'\fR, \f(CW\*(C`A*\*(C'\fR
or \f(CW\*(C`Z*\*(C'\fR, Perl won't let you.
.PP
The pack code preceding \f(CW\*(C`/\*(C'\fR may be anything that's fit to represent a
number: All the numeric binary pack codes, and even text codes such as
\&\f(CW\*(C`A4\*(C'\fR or \f(CW\*(C`Z*\*(C'\fR:
.PP
.Vb 4
\&   # pack/unpack a string preceded by its length in ASCII
\&   my $buf = pack( \*(AqA4/A*\*(Aq, "Humpty\-Dumpty" );
\&   # unpack $buf: \*(Aq13  Humpty\-Dumpty\*(Aq
\&   my $txt = unpack( \*(AqA4/A*\*(Aq, $buf );
.Ve
.PP
\&\f(CW\*(C`/\*(C'\fR is not implemented in Perls before 5.6, so if your code is required to
work on older Perls you'll need to \f(CW\*(C`unpack( \*(AqZ* Z* C\*(Aq)\*(C'\fR to get the length,
then use it to make a new unpack string. For example
.PP
.Vb 2
\&   # pack a message: ASCIIZ, ASCIIZ, length, string, byte (5.005 compatible)
\&   my $msg = pack( \*(AqZ* Z* C A* C\*(Aq, $src, $dst, length $sm, $sm, $prio );
\&
\&   # unpack
\&   ( undef, undef, $len) = unpack( \*(AqZ* Z* C\*(Aq, $msg );
\&   ($src, $dst, $sm, $prio) = unpack ( "Z* Z* x A$len C", $msg );
.Ve
.PP
But that second \f(CW\*(C`unpack\*(C'\fR is rushing ahead. It isn't using a simple literal
string for the template. So maybe we should introduce...
.SS "Dynamic Templates"
.IX Subsection "Dynamic Templates"
So far, we've seen literals used as templates. If the list of pack
items doesn't have fixed length, an expression constructing the
template is required (whenever, for some reason, \f(CW\*(C`()*\*(C'\fR cannot be used).
Here's an example: To store named string values in a way that can be
conveniently parsed by a C program, we create a sequence of names and
null terminated \s-1ASCII\s0 strings, with \f(CW\*(C`=\*(C'\fR between the name and the value,
followed by an additional delimiting null byte. Here's how:
.PP
.Vb 2
\&   my $env = pack( \*(Aq(A*A*Z*)\*(Aq . keys( %Env ) . \*(AqC\*(Aq,
\&                   map( { ( $_, \*(Aq=\*(Aq, $Env{$_} ) } keys( %Env ) ), 0 );
.Ve
.PP
Let's examine the cogs of this byte mill, one by one. There's the \f(CW\*(C`map\*(C'\fR
call, creating the items we intend to stuff into the \f(CW$env\fR buffer:
to each key (in \f(CW$_\fR) it adds the \f(CW\*(C`=\*(C'\fR separator and the hash entry value.
Each triplet is packed with the template code sequence \f(CW\*(C`A*A*Z*\*(C'\fR that
is repeated according to the number of keys. (Yes, that's what the \f(CW\*(C`keys\*(C'\fR
function returns in scalar context.) To get the very last null byte,
we add a \f(CW0\fR at the end of the \f(CW\*(C`pack\*(C'\fR list, to be packed with \f(CW\*(C`C\*(C'\fR.
(Attentive readers may have noticed that we could have omitted the 0.)
.PP
For the reverse operation, we'll have to determine the number of items
in the buffer before we can let \f(CW\*(C`unpack\*(C'\fR rip it apart:
.PP
.Vb 2
\&   my $n = $env =~ tr/\e0// \- 1;
\&   my %env = map( split( /=/, $_ ), unpack( "(Z*)$n", $env ) );
.Ve
.PP
The \f(CW\*(C`tr\*(C'\fR counts the null bytes. The \f(CW\*(C`unpack\*(C'\fR call returns a list of
name-value pairs each of which is taken apart in the \f(CW\*(C`map\*(C'\fR block.
.SS "Counting Repetitions"
.IX Subsection "Counting Repetitions"
Rather than storing a sentinel at the end of a data item (or a list of items),
we could precede the data with a count. Again, we pack keys and values of
a hash, preceding each with an unsigned short length count, and up front
we store the number of pairs:
.PP
.Vb 1
\&   my $env = pack( \*(AqS(S/A* S/A*)*\*(Aq, scalar keys( %Env ), %Env );
.Ve
.PP
This simplifies the reverse operation as the number of repetitions can be
unpacked with the \f(CW\*(C`/\*(C'\fR code:
.PP
.Vb 1
\&   my %env = unpack( \*(AqS/(S/A* S/A*)\*(Aq, $env );
.Ve
.PP
Note that this is one of the rare cases where you cannot use the same
template for \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR because \f(CW\*(C`pack\*(C'\fR can't determine
a repeat count for a \f(CW\*(C`()\*(C'\fR\-group.
.SS "Intel \s-1HEX\s0"
.IX Subsection "Intel HEX"
Intel \s-1HEX\s0 is a file format for representing binary data, mostly for
programming various chips, as a text file. (See
<http://en.wikipedia.org/wiki/.hex> for a detailed description, and
<http://en.wikipedia.org/wiki/SREC_(file_format)> for the Motorola
S\-record format, which can be unravelled using the same technique.)
Each line begins with a colon (':') and is followed by a sequence of
hexadecimal characters, specifying a byte count \fIn\fR (8 bit),
an address (16 bit, big endian), a record type (8 bit), \fIn\fR data bytes
and a checksum (8 bit) computed as the least significant byte of the two's
complement sum of the preceding bytes. Example: \f(CW\*(C`:0300300002337A1E\*(C'\fR.
.PP
The first step of processing such a line is the conversion, to binary,
of the hexadecimal data, to obtain the four fields, while checking the
checksum. No surprise here: we'll start with a simple \f(CW\*(C`pack\*(C'\fR call to 
convert everything to binary:
.PP
.Vb 1
\&   my $binrec = pack( \*(AqH*\*(Aq, substr( $hexrec, 1 ) );
.Ve
.PP
The resulting byte sequence is most convenient for checking the checksum.
Don't slow your program down with a for loop adding the \f(CW\*(C`ord\*(C'\fR values
of this string's bytes \- the \f(CW\*(C`unpack\*(C'\fR code \f(CW\*(C`%\*(C'\fR is the thing to use
for computing the 8\-bit sum of all bytes, which must be equal to zero:
.PP
.Vb 1
\&   die unless unpack( "%8C*", $binrec ) == 0;
.Ve
.PP
Finally, let's get those four fields. By now, you shouldn't have any
problems with the first three fields \- but how can we use the byte count
of the data in the first field as a length for the data field? Here
the codes \f(CW\*(C`x\*(C'\fR and \f(CW\*(C`X\*(C'\fR come to the rescue, as they permit jumping
back and forth in the string to unpack.
.PP
.Vb 1
\&   my( $addr, $type, $data ) = unpack( "x n C X4 C x3 /a", $bin );
.Ve
.PP
Code \f(CW\*(C`x\*(C'\fR skips a byte, since we don't need the count yet. Code \f(CW\*(C`n\*(C'\fR takes
care of the 16\-bit big-endian integer address, and \f(CW\*(C`C\*(C'\fR unpacks the
record type. Being at offset 4, where the data begins, we need the count.
\&\f(CW\*(C`X4\*(C'\fR brings us back to square one, which is the byte at offset 0.
Now we pick up the count, and zoom forth to offset 4, where we are
now fully furnished to extract the exact number of data bytes, leaving
the trailing checksum byte alone.
.SH "Packing and Unpacking C Structures"
.IX Header "Packing and Unpacking C Structures"
In previous sections we have seen how to pack numbers and character
strings. If it were not for a couple of snags we could conclude this
section right away with the terse remark that C structures don't
contain anything else, and therefore you already know all there is to it.
Sorry, no: read on, please.
.PP
If you have to deal with a lot of C structures, and don't want to
hack all your template strings manually, you'll probably want to have
a look at the \s-1CPAN\s0 module \f(CW\*(C`Convert::Binary::C\*(C'\fR. Not only can it parse
your C source directly, but it also has built-in support for all the
odds and ends described further on in this section.
.SS "The Alignment Pit"
.IX Subsection "The Alignment Pit"
In the consideration of speed against memory requirements the balance
has been tilted in favor of faster execution. This has influenced the
way C compilers allocate memory for structures: On architectures
where a 16\-bit or 32\-bit operand can be moved faster between places in
memory, or to or from a \s-1CPU\s0 register, if it is aligned at an even or 
multiple-of-four or even at a multiple-of eight address, a C compiler
will give you this speed benefit by stuffing extra bytes into structures.
If you don't cross the C shoreline this is not likely to cause you any
grief (although you should care when you design large data structures,
or you want your code to be portable between architectures (you do want
that, don't you?)).
.PP
To see how this affects \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR, we'll compare these two
C structures:
.PP
.Vb 6
\&   typedef struct {
\&     char     c1;
\&     short    s;
\&     char     c2;
\&     long     l;
\&   } gappy_t;
\&
\&   typedef struct {
\&     long     l;
\&     short    s;
\&     char     c1;
\&     char     c2;
\&   } dense_t;
.Ve
.PP
Typically, a C compiler allocates 12 bytes to a \f(CW\*(C`gappy_t\*(C'\fR variable, but
requires only 8 bytes for a \f(CW\*(C`dense_t\*(C'\fR. After investigating this further,
we can draw memory maps, showing where the extra 4 bytes are hidden:
.PP
.Vb 5
\&   0           +4          +8          +12
\&   +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&   |c1|xx|  s  |c2|xx|xx|xx|     l     |    xx = fill byte
\&   +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&   gappy_t
\&
\&   0           +4          +8
\&   +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&   |     l     |  h  |c1|c2|
\&   +\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+\-\-+
\&   dense_t
.Ve
.PP
And that's where the first quirk strikes: \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR
templates have to be stuffed with \f(CW\*(C`x\*(C'\fR codes to get those extra fill bytes.
.PP
The natural question: \*(L"Why can't Perl compensate for the gaps?\*(R" warrants
an answer. One good reason is that C compilers might provide (non-ANSI)
extensions permitting all sorts of fancy control over the way structures
are aligned, even at the level of an individual structure field. And, if
this were not enough, there is an insidious thing called \f(CW\*(C`union\*(C'\fR where
the amount of fill bytes cannot be derived from the alignment of the next
item alone.
.PP
\&\s-1OK,\s0 so let's bite the bullet. Here's one way to get the alignment right
by inserting template codes \f(CW\*(C`x\*(C'\fR, which don't take a corresponding item 
from the list:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aqcxs cxxx l!\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
Note the \f(CW\*(C`!\*(C'\fR after \f(CW\*(C`l\*(C'\fR: We want to make sure that we pack a long
integer as it is compiled by our C compiler. And even now, it will only
work for the platforms where the compiler aligns things as above.
And somebody somewhere has a platform where it doesn't.
[Probably a Cray, where \f(CW\*(C`short\*(C'\fRs, \f(CW\*(C`int\*(C'\fRs and \f(CW\*(C`long\*(C'\fRs are all 8 bytes. :\-)]
.PP
Counting bytes and watching alignments in lengthy structures is bound to 
be a drag. Isn't there a way we can create the template with a simple
program? Here's a C program that does the trick:
.PP
.Vb 2
\&   #include <stdio.h>
\&   #include <stddef.h>
\&
\&   typedef struct {
\&     char     fc1;
\&     short    fs;
\&     char     fc2;
\&     long     fl;
\&   } gappy_t;
\&
\&   #define Pt(struct,field,tchar) \e
\&     printf( "@%d%s ", offsetof(struct,field), # tchar );
\&
\&   int main() {
\&     Pt( gappy_t, fc1, c  );
\&     Pt( gappy_t, fs,  s! );
\&     Pt( gappy_t, fc2, c  );
\&     Pt( gappy_t, fl,  l! );
\&     printf( "\en" );
\&   }
.Ve
.PP
The output line can be used as a template in a \f(CW\*(C`pack\*(C'\fR or \f(CW\*(C`unpack\*(C'\fR call:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aq@0c @2s! @4c @8l!\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
Gee, yet another template code \- as if we hadn't plenty. But 
\&\f(CW\*(C`@\*(C'\fR saves our day by enabling us to specify the offset from the beginning
of the pack buffer to the next item: This is just the value
the \f(CW\*(C`offsetof\*(C'\fR macro (defined in \f(CW\*(C`<stddef.h>\*(C'\fR) returns when
given a \f(CW\*(C`struct\*(C'\fR type and one of its field names (\*(L"member-designator\*(R" in 
C standardese).
.PP
Neither using offsets nor adding \f(CW\*(C`x\*(C'\fR's to bridge the gaps is satisfactory.
(Just imagine what happens if the structure changes.) What we really need
is a way of saying \*(L"skip as many bytes as required to the next multiple of N\*(R".
In fluent Templatese, you say this with \f(CW\*(C`x!N\*(C'\fR where N is replaced by the
appropriate value. Here's the next version of our struct packaging:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aqc x!2 s c x!4 l!\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
That's certainly better, but we still have to know how long all the
integers are, and portability is far away. Rather than \f(CW2\fR,
for instance, we want to say \*(L"however long a short is\*(R". But this can be
done by enclosing the appropriate pack code in brackets: \f(CW\*(C`[s]\*(C'\fR. So, here's
the very best we can do:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aqc x![s] s c x![l!] l!\*(Aq, $c1, $s, $c2, $l );
.Ve
.SS "Dealing with Endian-ness"
.IX Subsection "Dealing with Endian-ness"
Now, imagine that we want to pack the data for a machine with a
different byte-order. First, we'll have to figure out how big the data
types on the target machine really are. Let's assume that the longs are
32 bits wide and the shorts are 16 bits wide. You can then rewrite the
template as:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aqc x![s] s c x![l] l\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
If the target machine is little-endian, we could write:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aqc x![s] s< c x![l] l<\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
This forces the short and the long members to be little-endian, and is
just fine if you don't have too many struct members. But we could also
use the byte-order modifier on a group and write the following:
.PP
.Vb 1
\&  my $gappy = pack( \*(Aq( c x![s] s c x![l] l )<\*(Aq, $c1, $s, $c2, $l );
.Ve
.PP
This is not as short as before, but it makes it more obvious that we
intend to have little-endian byte-order for a whole group, not only
for individual template codes. It can also be more readable and easier
to maintain.
.SS "Alignment, Take 2"
.IX Subsection "Alignment, Take 2"
I'm afraid that we're not quite through with the alignment catch yet. The
hydra raises another ugly head when you pack arrays of structures:
.PP
.Vb 4
\&   typedef struct {
\&     short    count;
\&     char     glyph;
\&   } cell_t;
\&
\&   typedef cell_t buffer_t[BUFLEN];
.Ve
.PP
Where's the catch? Padding is neither required before the first field \f(CW\*(C`count\*(C'\fR,
nor between this and the next field \f(CW\*(C`glyph\*(C'\fR, so why can't we simply pack
like this:
.PP
.Vb 3
\&   # something goes wrong here:
\&   pack( \*(Aqs!a\*(Aq x @buffer,
\&         map{ ( $_\->{count}, $_\->{glyph} ) } @buffer );
.Ve
.PP
This packs \f(CW\*(C`3*@buffer\*(C'\fR bytes, but it turns out that the size of 
\&\f(CW\*(C`buffer_t\*(C'\fR is four times \f(CW\*(C`BUFLEN\*(C'\fR! The moral of the story is that
the required alignment of a structure or array is propagated to the
next higher level where we have to consider padding \fIat the end\fR
of each component as well. Thus the correct template is:
.PP
.Vb 2
\&   pack( \*(Aqs!ax\*(Aq x @buffer,
\&         map{ ( $_\->{count}, $_\->{glyph} ) } @buffer );
.Ve
.SS "Alignment, Take 3"
.IX Subsection "Alignment, Take 3"
And even if you take all the above into account, \s-1ANSI\s0 still lets this:
.PP
.Vb 3
\&   typedef struct {
\&     char     foo[2];
\&   } foo_t;
.Ve
.PP
vary in size. The alignment constraint of the structure can be greater than
any of its elements. [And if you think that this doesn't affect anything
common, dismember the next cellphone that you see. Many have \s-1ARM\s0 cores, and
the \s-1ARM\s0 structure rules make \f(CW\*(C`sizeof (foo_t)\*(C'\fR == 4]
.SS "Pointers for How to Use Them"
.IX Subsection "Pointers for How to Use Them"
The title of this section indicates the second problem you may run into
sooner or later when you pack C structures. If the function you intend
to call expects a, say, \f(CW\*(C`void *\*(C'\fR value, you \fIcannot\fR simply take
a reference to a Perl variable. (Although that value certainly is a
memory address, it's not the address where the variable's contents are
stored.)
.PP
Template code \f(CW\*(C`P\*(C'\fR promises to pack a \*(L"pointer to a fixed length string\*(R".
Isn't this what we want? Let's try:
.PP
.Vb 3
\&    # allocate some storage and pack a pointer to it
\&    my $memory = "\ex00" x $size;
\&    my $memptr = pack( \*(AqP\*(Aq, $memory );
.Ve
.PP
But wait: doesn't \f(CW\*(C`pack\*(C'\fR just return a sequence of bytes? How can we pass this
string of bytes to some C code expecting a pointer which is, after all,
nothing but a number? The answer is simple: We have to obtain the numeric
address from the bytes returned by \f(CW\*(C`pack\*(C'\fR.
.PP
.Vb 1
\&    my $ptr = unpack( \*(AqL!\*(Aq, $memptr );
.Ve
.PP
Obviously this assumes that it is possible to typecast a pointer
to an unsigned long and vice versa, which frequently works but should not
be taken as a universal law. \- Now that we have this pointer the next question
is: How can we put it to good use? We need a call to some C function
where a pointer is expected. The \fIread\fR\|(2) system call comes to mind:
.PP
.Vb 1
\&    ssize_t read(int fd, void *buf, size_t count);
.Ve
.PP
After reading perlfunc explaining how to use \f(CW\*(C`syscall\*(C'\fR we can write
this Perl function copying a file to standard output:
.PP
.Vb 12
\&    require \*(Aqsyscall.ph\*(Aq;
\&    sub cat($){
\&        my $path = shift();
\&        my $size = \-s $path;
\&        my $memory = "\ex00" x $size;  # allocate some memory
\&        my $ptr = unpack( \*(AqL\*(Aq, pack( \*(AqP\*(Aq, $memory ) );
\&        open( F, $path ) || die( "$path: cannot open ($!)\en" );
\&        my $fd = fileno(F);
\&        my $res = syscall( &SYS_read, fileno(F), $ptr, $size );
\&        print $memory;
\&        close( F );
\&    }
.Ve
.PP
This is neither a specimen of simplicity nor a paragon of portability but
it illustrates the point: We are able to sneak behind the scenes and
access Perl's otherwise well-guarded memory! (Important note: Perl's
\&\f(CW\*(C`syscall\*(C'\fR does \fInot\fR require you to construct pointers in this roundabout
way. You simply pass a string variable, and Perl forwards the address.)
.PP
How does \f(CW\*(C`unpack\*(C'\fR with \f(CW\*(C`P\*(C'\fR work? Imagine some pointer in the buffer
about to be unpacked: If it isn't the null pointer (which will smartly
produce the \f(CW\*(C`undef\*(C'\fR value) we have a start address \- but then what?
Perl has no way of knowing how long this \*(L"fixed length string\*(R" is, so
it's up to you to specify the actual size as an explicit length after \f(CW\*(C`P\*(C'\fR.
.PP
.Vb 2
\&   my $mem = "abcdefghijklmn";
\&   print unpack( \*(AqP5\*(Aq, pack( \*(AqP\*(Aq, $mem ) ); # prints "abcde"
.Ve
.PP
As a consequence, \f(CW\*(C`pack\*(C'\fR ignores any number or \f(CW\*(C`*\*(C'\fR after \f(CW\*(C`P\*(C'\fR.
.PP
Now that we have seen \f(CW\*(C`P\*(C'\fR at work, we might as well give \f(CW\*(C`p\*(C'\fR a whirl.
Why do we need a second template code for packing pointers at all? The 
answer lies behind the simple fact that an \f(CW\*(C`unpack\*(C'\fR with \f(CW\*(C`p\*(C'\fR promises
a null-terminated string starting at the address taken from the buffer,
and that implies a length for the data item to be returned:
.PP
.Vb 2
\&   my $buf = pack( \*(Aqp\*(Aq, "abc\ex00efhijklmn" );
\&   print unpack( \*(Aqp\*(Aq, $buf );    # prints "abc"
.Ve
.PP
Albeit this is apt to be confusing: As a consequence of the length being
implied by the string's length, a number after pack code \f(CW\*(C`p\*(C'\fR is a repeat
count, not a length as after \f(CW\*(C`P\*(C'\fR.
.PP
Using \f(CW\*(C`pack(..., $x)\*(C'\fR with \f(CW\*(C`P\*(C'\fR or \f(CW\*(C`p\*(C'\fR to get the address where \f(CW$x\fR is
actually stored must be used with circumspection. Perl's internal machinery
considers the relation between a variable and that address as its very own 
private matter and doesn't really care that we have obtained a copy. Therefore:
.IP "\(bu" 4
Do not use \f(CW\*(C`pack\*(C'\fR with \f(CW\*(C`p\*(C'\fR or \f(CW\*(C`P\*(C'\fR to obtain the address of variable
that's bound to go out of scope (and thereby freeing its memory) before you
are done with using the memory at that address.
.IP "\(bu" 4
Be very careful with Perl operations that change the value of the
variable. Appending something to the variable, for instance, might require
reallocation of its storage, leaving you with a pointer into no-man's land.
.IP "\(bu" 4
Don't think that you can get the address of a Perl variable
when it is stored as an integer or double number! \f(CW\*(C`pack(\*(AqP\*(Aq, $x)\*(C'\fR will
force the variable's internal representation to string, just as if you
had written something like \f(CW\*(C`$x .= \*(Aq\*(Aq\*(C'\fR.
.PP
It's safe, however, to P\- or p\-pack a string literal, because Perl simply
allocates an anonymous variable.
.SH "Pack Recipes"
.IX Header "Pack Recipes"
Here are a collection of (possibly) useful canned recipes for \f(CW\*(C`pack\*(C'\fR
and \f(CW\*(C`unpack\*(C'\fR:
.PP
.Vb 2
\&    # Convert IP address for socket functions
\&    pack( "C4", split /\e./, "123.4.5.6" ); 
\&
\&    # Count the bits in a chunk of memory (e.g. a select vector)
\&    unpack( \*(Aq%32b*\*(Aq, $mask );
\&
\&    # Determine the endianness of your system
\&    $is_little_endian = unpack( \*(Aqc\*(Aq, pack( \*(Aqs\*(Aq, 1 ) );
\&    $is_big_endian = unpack( \*(Aqxc\*(Aq, pack( \*(Aqs\*(Aq, 1 ) );
\&
\&    # Determine the number of bits in a native integer
\&    $bits = unpack( \*(Aq%32I!\*(Aq, ~0 );
\&
\&    # Prepare argument for the nanosleep system call
\&    my $timespec = pack( \*(AqL!L!\*(Aq, $secs, $nanosecs );
.Ve
.PP
For a simple memory dump we unpack some bytes into just as 
many pairs of hex digits, and use \f(CW\*(C`map\*(C'\fR to handle the traditional
spacing \- 16 bytes to a line:
.PP
.Vb 4
\&    my $i;
\&    print map( ++$i % 16 ? "$_ " : "$_\en",
\&               unpack( \*(AqH2\*(Aq x length( $mem ), $mem ) ),
\&          length( $mem ) % 16 ? "\en" : \*(Aq\*(Aq;
.Ve
.SH "Funnies Section"
.IX Header "Funnies Section"
.Vb 5
\&    # Pulling digits out of nowhere...
\&    print unpack( \*(AqC\*(Aq, pack( \*(Aqx\*(Aq ) ),
\&          unpack( \*(Aq%B*\*(Aq, pack( \*(AqA\*(Aq ) ),
\&          unpack( \*(AqH\*(Aq, pack( \*(AqA\*(Aq ) ),
\&          unpack( \*(AqA\*(Aq, unpack( \*(AqC\*(Aq, pack( \*(AqA\*(Aq ) ) ), "\en";
\&
\&    # One for the road ;\-)
\&    my $advice = pack( \*(Aqall u can in a van\*(Aq );
.Ve
.SH "Authors"
.IX Header "Authors"
Simon Cozens and Wolfgang Laun.
                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlperf.1                                   0100644 0001750 0001750 00000166103 12566207443 022567  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPERF 1"
.TH PERLPERF 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlperf \- Perl Performance and Optimization Techniques
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an introduction to the use of performance and optimization techniques
which can be used with particular reference to perl programs.  While many perl
developers have come from other languages, and can use their prior knowledge
where appropriate, there are many other people who might benefit from a few
perl specific pointers.  If you want the condensed version, perhaps the best
advice comes from the renowned Japanese Samurai, Miyamoto Musashi, who said:
.PP
.Vb 1
\&    "Do Not Engage in Useless Activity"
.Ve
.PP
in 1645.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
Perhaps the most common mistake programmers make is to attempt to optimize
their code before a program actually does anything useful \- this is a bad idea.
There's no point in having an extremely fast program that doesn't work.  The
first job is to get a program to \fIcorrectly\fR do something \fBuseful\fR, (not to
mention ensuring the test suite is fully functional), and only then to consider
optimizing it.  Having decided to optimize existing working code, there are
several simple but essential steps to consider which are intrinsic to any
optimization process.
.SS "\s-1ONE STEP SIDEWAYS\s0"
.IX Subsection "ONE STEP SIDEWAYS"
Firstly, you need to establish a baseline time for the existing code, which
timing needs to be reliable and repeatable.  You'll probably want to use the
\&\f(CW\*(C`Benchmark\*(C'\fR or \f(CW\*(C`Devel::NYTProf\*(C'\fR modules, or something similar, for this step,
or perhaps the Unix system \f(CW\*(C`time\*(C'\fR utility, whichever is appropriate.  See the
base of this document for a longer list of benchmarking and profiling modules,
and recommended further reading.
.SS "\s-1ONE STEP FORWARD\s0"
.IX Subsection "ONE STEP FORWARD"
Next, having examined the program for \fIhot spots\fR, (places where the code
seems to run slowly), change the code with the intention of making it run
faster.  Using version control software, like \f(CW\*(C`subversion\*(C'\fR, will ensure no
changes are irreversible.  It's too easy to fiddle here and fiddle there \-
don't change too much at any one time or you might not discover which piece of
code \fBreally\fR was the slow bit.
.SS "\s-1ANOTHER STEP SIDEWAYS\s0"
.IX Subsection "ANOTHER STEP SIDEWAYS"
It's not enough to say: \*(L"that will make it run faster\*(R", you have to check it.
Rerun the code under control of the benchmarking or profiling modules, from the
first step above, and check that the new code executed the \fBsame task\fR in
\&\fIless time\fR.  Save your work and repeat...
.SH "GENERAL GUIDELINES"
.IX Header "GENERAL GUIDELINES"
The critical thing when considering performance is to remember there is no such
thing as a \f(CW\*(C`Golden Bullet\*(C'\fR, which is why there are no rules, only guidelines.
.PP
It is clear that inline code is going to be faster than subroutine or method
calls, because there is less overhead, but this approach has the disadvantage
of being less maintainable and comes at the cost of greater memory usage \-
there is no such thing as a free lunch.  If you are searching for an element in
a list, it can be more efficient to store the data in a hash structure, and
then simply look to see whether the key is defined, rather than to loop through
the entire array using \fIgrep()\fR for instance.  \fIsubstr()\fR may be (a lot) faster
than \fIgrep()\fR but not as flexible, so you have another trade-off to access.  Your
code may contain a line which takes 0.01 of a second to execute which if you
call it 1,000 times, quite likely in a program parsing even medium sized files
for instance, you already have a 10 second delay, in just one single code
location, and if you call that line 100,000 times, your entire program will
slow down to an unbearable crawl.
.PP
Using a subroutine as part of your sort is a powerful way to get exactly what
you want, but will usually be slower than the built-in \fIalphabetic\fR \f(CW\*(C`cmp\*(C'\fR and
\&\fInumeric\fR \f(CW\*(C`<=>\*(C'\fR sort operators.  It is possible to make multiple
passes over your data, building indices to make the upcoming sort more
efficient, and to use what is known as the \f(CW\*(C`OM\*(C'\fR (Orcish Maneuver) to cache the
sort keys in advance.  The cache lookup, while a good idea, can itself be a
source of slowdown by enforcing a double pass over the data \- once to setup the
cache, and once to sort the data.  Using \f(CW\*(C`pack()\*(C'\fR to extract the required sort
key into a consistent string can be an efficient way to build a single string
to compare, instead of using multiple sort keys, which makes it possible to use
the standard, written in \f(CW\*(C`c\*(C'\fR and fast, perl \f(CW\*(C`sort()\*(C'\fR function on the output,
and is the basis of the \f(CW\*(C`GRT\*(C'\fR (Guttman Rossler Transform).  Some string
combinations can slow the \f(CW\*(C`GRT\*(C'\fR down, by just being too plain complex for it's
own good.
.PP
For applications using database backends, the standard \f(CW\*(C`DBIx\*(C'\fR namespace has
tries to help with keeping things nippy, not least because it tries to \fInot\fR
query the database until the latest possible moment, but always read the docs
which come with your choice of libraries.  Among the many issues facing
developers dealing with databases should remain aware of is to always use
\&\f(CW\*(C`SQL\*(C'\fR placeholders and to consider pre-fetching data sets when this might
prove advantageous.  Splitting up a large file by assigning multiple processes
to parsing a single file, using say \f(CW\*(C`POE\*(C'\fR, \f(CW\*(C`threads\*(C'\fR or \f(CW\*(C`fork\*(C'\fR can also be a
useful way of optimizing your usage of the available \f(CW\*(C`CPU\*(C'\fR resources, though
this technique is fraught with concurrency issues and demands high attention to
detail.
.PP
Every case has a specific application and one or more exceptions, and there is
no replacement for running a few tests and finding out which method works best
for your particular environment, this is why writing optimal code is not an
exact science, and why we love using Perl so much \- \s-1TMTOWTDI.\s0
.SH "BENCHMARKS"
.IX Header "BENCHMARKS"
Here are a few examples to demonstrate usage of Perl's benchmarking tools.
.SS "Assigning and Dereferencing Variables."
.IX Subsection "Assigning and Dereferencing Variables."
I'm sure most of us have seen code which looks like, (or worse than), this:
.PP
.Vb 2
\&    if ( $obj\->{_ref}\->{_myscore} >= $obj\->{_ref}\->{_yourscore} ) {
\&        ...
.Ve
.PP
This sort of code can be a real eyesore to read, as well as being very
sensitive to typos, and it's much clearer to dereference the variable
explicitly.  We're side-stepping the issue of working with object-oriented
programming techniques to encapsulate variable access via methods, only
accessible through an object.  Here we're just discussing the technical
implementation of choice, and whether this has an effect on performance.  We
can see whether this dereferencing operation, has any overhead by putting
comparative code in a file and running a \f(CW\*(C`Benchmark\*(C'\fR test.
.PP
# dereference
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    use Benchmark;
\&
\&    my $ref = {
\&            \*(Aqref\*(Aq   => {
\&                _myscore    => \*(Aq100 + 1\*(Aq,
\&                _yourscore  => \*(Aq102 \- 1\*(Aq,
\&            },
\&    };
\&
\&    timethese(1000000, {
\&            \*(Aqdirect\*(Aq       => sub {
\&                my $x = $ref\->{ref}\->{_myscore} . $ref\->{ref}\->{_yourscore} ;
\&            },
\&            \*(Aqdereference\*(Aq  => sub {
\&                my $ref  = $ref\->{ref};
\&                my $myscore = $ref\->{_myscore};
\&                my $yourscore = $ref\->{_yourscore};
\&                my $x = $myscore . $yourscore;
\&            },
\&    });
.Ve
.PP
It's essential to run any timing measurements a sufficient number of times so
the numbers settle on a numerical average, otherwise each run will naturally
fluctuate due to variations in the environment, to reduce the effect of
contention for \f(CW\*(C`CPU\*(C'\fR resources and network bandwidth for instance.  Running
the above code for one million iterations, we can take a look at the report
output by the \f(CW\*(C`Benchmark\*(C'\fR module, to see which approach is the most effective.
.PP
.Vb 1
\&    $> perl dereference
\&
\&    Benchmark: timing 1000000 iterations of dereference, direct...
\&    dereference:  2 wallclock secs ( 1.59 usr +  0.00 sys =  1.59 CPU) @ 628930.82/s (n=1000000)
\&        direct:  1 wallclock secs ( 1.20 usr +  0.00 sys =  1.20 CPU) @ 833333.33/s (n=1000000)
.Ve
.PP
The difference is clear to see and the dereferencing approach is slower.  While
it managed to execute an average of 628,930 times a second during our test, the
direct approach managed to run an additional 204,403 times, unfortunately.
Unfortunately, because there are many examples of code written using the
multiple layer direct variable access, and it's usually horrible.  It is,
however, minusculy faster.  The question remains whether the minute gain is
actually worth the eyestrain, or the loss of maintainability.
.SS "Search and replace or tr"
.IX Subsection "Search and replace or tr"
If we have a string which needs to be modified, while a regex will almost
always be much more flexible, \f(CW\*(C`tr\*(C'\fR, an oft underused tool, can still be a
useful.  One scenario might be replace all vowels with another character.  The
regex solution might look like this:
.PP
.Vb 1
\&    $str =~ s/[aeiou]/x/g
.Ve
.PP
The \f(CW\*(C`tr\*(C'\fR alternative might look like this:
.PP
.Vb 1
\&    $str =~ tr/aeiou/xxxxx/
.Ve
.PP
We can put that into a test file which we can run to check which approach is
the fastest, using a global \f(CW$STR\fR variable to assign to the \f(CW\*(C`my $str\*(C'\fR
variable so as to avoid perl trying to optimize any of the work away by
noticing it's assigned only the once.
.PP
# regex-transliterate
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    use Benchmark;
\&
\&    my $STR = "$$\-this and that";
\&
\&    timethese( 1000000, {
\&            \*(Aqsr\*(Aq  => sub { my $str = $STR; $str =~ s/[aeiou]/x/g; return $str; },
\&            \*(Aqtr\*(Aq  => sub { my $str = $STR; $str =~ tr/aeiou/xxxxx/; return $str; },
\&    });
.Ve
.PP
Running the code gives us our results:
.PP
.Vb 1
\&    $> perl regex\-transliterate
\&
\&    Benchmark: timing 1000000 iterations of sr, tr...
\&            sr:  2 wallclock secs ( 1.19 usr +  0.00 sys =  1.19 CPU) @ 840336.13/s (n=1000000)
\&            tr:  0 wallclock secs ( 0.49 usr +  0.00 sys =  0.49 CPU) @ 2040816.33/s (n=1000000)
.Ve
.PP
The \f(CW\*(C`tr\*(C'\fR version is a clear winner.  One solution is flexible, the other is
fast \- and it's appropriately the programmer's choice which to use.
.PP
Check the \f(CW\*(C`Benchmark\*(C'\fR docs for further useful techniques.
.SH "PROFILING TOOLS"
.IX Header "PROFILING TOOLS"
A slightly larger piece of code will provide something on which a profiler can
produce more extensive reporting statistics.  This example uses the simplistic
\&\f(CW\*(C`wordmatch\*(C'\fR program which parses a given input file and spews out a short
report on the contents.
.PP
# wordmatch
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    =head1 NAME
\&
\&    filewords \- word analysis of input file
\&
\&    =head1 SYNOPSIS
\&
\&        filewords \-f inputfilename [\-d]
\&
\&    =head1 DESCRIPTION
\&
\&    This program parses the given filename, specified with C<\-f>, and displays a
\&    simple analysis of the words found therein.  Use the C<\-d> switch to enable
\&    debugging messages.
\&
\&    =cut
\&
\&    use FileHandle;
\&    use Getopt::Long;
\&
\&    my $debug   =  0;
\&    my $file    = \*(Aq\*(Aq;
\&
\&    my $result = GetOptions (
\&        \*(Aqdebug\*(Aq         => \e$debug,
\&        \*(Aqfile=s\*(Aq        => \e$file,
\&    );
\&    die("invalid args") unless $result;
\&
\&    unless ( \-f $file ) {
\&        die("Usage: $0 \-f filename [\-d]");
\&    }
\&    my $FH = FileHandle\->new("< $file") or die("unable to open file($file): $!");
\&
\&    my $i_LINES = 0;
\&    my $i_WORDS = 0;
\&    my %count   = ();
\&
\&    my @lines = <$FH>;
\&    foreach my $line ( @lines ) {
\&        $i_LINES++;
\&        $line =~ s/\en//;
\&        my @words = split(/ +/, $line);
\&        my $i_words = scalar(@words);
\&        $i_WORDS = $i_WORDS + $i_words;
\&        debug("line: $i_LINES supplying $i_words words: @words");
\&        my $i_word = 0;
\&        foreach my $word ( @words ) {
\&            $i_word++;
\&            $count{$i_LINES}{spec} += matches($i_word, $word, \*(Aq[^a\-zA\-Z0\-9]\*(Aq);
\&            $count{$i_LINES}{only} += matches($i_word, $word, \*(Aq^[^a\-zA\-Z0\-9]+$\*(Aq);
\&            $count{$i_LINES}{cons} += matches($i_word, $word, \*(Aq^[(?i:bcdfghjklmnpqrstvwxyz)]+$\*(Aq);
\&            $count{$i_LINES}{vows} += matches($i_word, $word, \*(Aq^[(?i:aeiou)]+$\*(Aq);
\&            $count{$i_LINES}{caps} += matches($i_word, $word, \*(Aq^[(A\-Z)]+$\*(Aq);
\&        }
\&    }
\&
\&    print report( %count );
\&
\&    sub matches {
\&        my $i_wd  = shift;
\&        my $word  = shift;
\&        my $regex = shift;
\&        my $has = 0;
\&
\&        if ( $word =~ /($regex)/ ) {
\&            $has++ if $1;
\&        }
\&
\&        debug("word: $i_wd ".($has ? \*(Aqmatches\*(Aq : \*(Aqdoes not match\*(Aq)." chars: /$regex/");
\&
\&        return $has;
\&    }
\&
\&    sub report {
\&        my %report = @_;
\&        my %rep;
\&
\&        foreach my $line ( keys %report ) {
\&            foreach my $key ( keys %{ $report{$line} } ) {
\&                $rep{$key} += $report{$line}{$key};
\&            }
\&        }
\&
\&        my $report = qq|
\&    $0 report for $file:
\&    lines in file: $i_LINES
\&    words in file: $i_WORDS
\&    words with special (non\-word) characters: $i_spec
\&    words with only special (non\-word) characters: $i_only
\&    words with only consonants: $i_cons
\&    words with only capital letters: $i_caps
\&    words with only vowels: $i_vows
\&    |;
\&
\&        return $report;
\&    }
\&
\&    sub debug {
\&        my $message = shift;
\&
\&        if ( $debug ) {
\&            print STDERR "DBG: $message\en";
\&        }
\&    }
\&
\&    exit 0;
.Ve
.SS "Devel::DProf"
.IX Subsection "Devel::DProf"
This venerable module has been the de-facto standard for Perl code profiling
for more than a decade, but has been replaced by a number of other modules
which have brought us back to the 21st century.  Although you're recommended to
evaluate your tool from the several mentioned here and from the \s-1CPAN\s0 list at
the base of this document, (and currently Devel::NYTProf seems to be the
weapon of choice \- see below), we'll take a quick look at the output from
Devel::DProf first, to set a baseline for Perl profiling tools.  Run the
above program under the control of \f(CW\*(C`Devel::DProf\*(C'\fR by using the \f(CW\*(C`\-d\*(C'\fR switch on
the command-line.
.PP
.Vb 1
\&    $> perl \-d:DProf wordmatch \-f perl5db.pl
\&
\&    <...multiple lines snipped...>
\&
\&    wordmatch report for perl5db.pl:
\&    lines in file: 9428
\&    words in file: 50243
\&    words with special (non\-word) characters: 20480
\&    words with only special (non\-word) characters: 7790
\&    words with only consonants: 4801
\&    words with only capital letters: 1316
\&    words with only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`Devel::DProf\*(C'\fR produces a special file, called \fItmon.out\fR by default, and
this file is read by the \f(CW\*(C`dprofpp\*(C'\fR program, which is already installed as part
of the \f(CW\*(C`Devel::DProf\*(C'\fR distribution.  If you call \f(CW\*(C`dprofpp\*(C'\fR with no options,
it will read the \fItmon.out\fR file in the current directory and produce a human
readable statistics report of the run of your program.  Note that this may take
a little time.
.PP
.Vb 1
\&    $> dprofpp
\&
\&    Total Elapsed Time = 2.951677 Seconds
\&      User+System Time = 2.871677 Seconds
\&    Exclusive Times
\&    %Time ExclSec CumulS #Calls sec/call Csec/c  Name
\&     102.   2.945  3.003 251215   0.0000 0.0000  main::matches
\&     2.40   0.069  0.069 260643   0.0000 0.0000  main::debug
\&     1.74   0.050  0.050      1   0.0500 0.0500  main::report
\&     1.04   0.030  0.049      4   0.0075 0.0123  main::BEGIN
\&     0.35   0.010  0.010      3   0.0033 0.0033  Exporter::as_heavy
\&     0.35   0.010  0.010      7   0.0014 0.0014  IO::File::BEGIN
\&     0.00       \- \-0.000      1        \-      \-  Getopt::Long::FindOption
\&     0.00       \- \-0.000      1        \-      \-  Symbol::BEGIN
\&     0.00       \- \-0.000      1        \-      \-  Fcntl::BEGIN
\&     0.00       \- \-0.000      1        \-      \-  Fcntl::bootstrap
\&     0.00       \- \-0.000      1        \-      \-  warnings::BEGIN
\&     0.00       \- \-0.000      1        \-      \-  IO::bootstrap
\&     0.00       \- \-0.000      1        \-      \-  Getopt::Long::ConfigDefaults
\&     0.00       \- \-0.000      1        \-      \-  Getopt::Long::Configure
\&     0.00       \- \-0.000      1        \-      \-  Symbol::gensym
.Ve
.PP
\&\f(CW\*(C`dprofpp\*(C'\fR will produce some quite detailed reporting on the activity of the
\&\f(CW\*(C`wordmatch\*(C'\fR program.  The wallclock, user and system, times are at the top of
the analysis, and after this are the main columns defining which define the
report.  Check the \f(CW\*(C`dprofpp\*(C'\fR docs for details of the many options it supports.
.PP
See also \f(CW\*(C`Apache::DProf\*(C'\fR which hooks \f(CW\*(C`Devel::DProf\*(C'\fR into \f(CW\*(C`mod_perl\*(C'\fR.
.SS "Devel::Profiler"
.IX Subsection "Devel::Profiler"
Let's take a look at the same program using a different profiler:
\&\f(CW\*(C`Devel::Profiler\*(C'\fR, a drop-in Perl-only replacement for \f(CW\*(C`Devel::DProf\*(C'\fR.  The
usage is very slightly different in that instead of using the special \f(CW\*(C`\-d:\*(C'\fR
flag, you pull \f(CW\*(C`Devel::Profiler\*(C'\fR in directly as a module using \f(CW\*(C`\-M\*(C'\fR.
.PP
.Vb 1
\&    $> perl \-MDevel::Profiler wordmatch \-f perl5db.pl
\&
\&    <...multiple lines snipped...>
\&
\&    wordmatch report for perl5db.pl:
\&    lines in file: 9428
\&    words in file: 50243
\&    words with special (non\-word) characters: 20480
\&    words with only special (non\-word) characters: 7790
\&    words with only consonants: 4801
\&    words with only capital letters: 1316
\&    words with only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`Devel::Profiler\*(C'\fR generates a tmon.out file which is compatible with the
\&\f(CW\*(C`dprofpp\*(C'\fR program, thus saving the construction of a dedicated statistics
reader program.  \f(CW\*(C`dprofpp\*(C'\fR usage is therefore identical to the above example.
.PP
.Vb 1
\&    $> dprofpp
\&
\&    Total Elapsed Time =   20.984 Seconds
\&      User+System Time =   19.981 Seconds
\&    Exclusive Times
\&    %Time ExclSec CumulS #Calls sec/call Csec/c  Name
\&     49.0   9.792 14.509 251215   0.0000 0.0001  main::matches
\&     24.4   4.887  4.887 260643   0.0000 0.0000  main::debug
\&     0.25   0.049  0.049      1   0.0490 0.0490  main::report
\&     0.00   0.000  0.000      1   0.0000 0.0000  Getopt::Long::GetOptions
\&     0.00   0.000  0.000      2   0.0000 0.0000  Getopt::Long::ParseOptionSpec
\&     0.00   0.000  0.000      1   0.0000 0.0000  Getopt::Long::FindOption
\&     0.00   0.000  0.000      1   0.0000 0.0000  IO::File::new
\&     0.00   0.000  0.000      1   0.0000 0.0000  IO::Handle::new
\&     0.00   0.000  0.000      1   0.0000 0.0000  Symbol::gensym
\&     0.00   0.000  0.000      1   0.0000 0.0000  IO::File::open
.Ve
.PP
Interestingly we get slightly different results, which is mostly because the
algorithm which generates the report is different, even though the output file
format was allegedly identical.  The elapsed, user and system times are clearly
showing the time it took for \f(CW\*(C`Devel::Profiler\*(C'\fR to execute its own run, but
the column listings feel more accurate somehow than the ones we had earlier
from \f(CW\*(C`Devel::DProf\*(C'\fR.  The 102% figure has disappeared, for example.  This is
where we have to use the tools at our disposal, and recognise their pros and
cons, before using them.  Interestingly, the numbers of calls for each
subroutine are identical in the two reports, it's the percentages which differ.
As the author of \f(CW\*(C`Devel::Proviler\*(C'\fR writes:
.PP
.Vb 5
\&    ...running HTML::Template\*(Aqs test suite under Devel::DProf shows output()
\&    taking NO time but Devel::Profiler shows around 10% of the time is in output().
\&    I don\*(Aqt know which to trust but my gut tells me something is wrong with
\&    Devel::DProf.  HTML::Template::output() is a big routine that\*(Aqs called for
\&    every test. Either way, something needs fixing.
.Ve
.PP
\&\s-1YMMV.\s0
.PP
See also \f(CW\*(C`Devel::Apache::Profiler\*(C'\fR which hooks \f(CW\*(C`Devel::Profiler\*(C'\fR into \f(CW\*(C`mod_perl\*(C'\fR.
.SS "Devel::SmallProf"
.IX Subsection "Devel::SmallProf"
The \f(CW\*(C`Devel::SmallProf\*(C'\fR profiler examines the runtime of your Perl program and
produces a line-by-line listing to show how many times each line was called,
and how long each line took to execute.  It is called by supplying the familiar
\&\f(CW\*(C`\-d\*(C'\fR flag to Perl at runtime.
.PP
.Vb 1
\&    $> perl \-d:SmallProf wordmatch \-f perl5db.pl
\&
\&    <...multiple lines snipped...>
\&
\&    wordmatch report for perl5db.pl:
\&    lines in file: 9428
\&    words in file: 50243
\&    words with special (non\-word) characters: 20480
\&    words with only special (non\-word) characters: 7790
\&    words with only consonants: 4801
\&    words with only capital letters: 1316
\&    words with only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`Devel::SmallProf\*(C'\fR writes it's output into a file called \fIsmallprof.out\fR, by
default.  The format of the file looks like this:
.PP
.Vb 1
\&    <num> <time> <ctime> <line>:<text>
.Ve
.PP
When the program has terminated, the output may be examined and sorted using
any standard text filtering utilities.  Something like the following may be
sufficient:
.PP
.Vb 1
\&    $> cat smallprof.out | grep \ed*: | sort \-k3 | tac | head \-n20
\&
\&    251215   1.65674   7.68000    75: if ( $word =~ /($regex)/ ) {
\&    251215   0.03264   4.40000    79: debug("word: $i_wd ".($has ? \*(Aqmatches\*(Aq :
\&    251215   0.02693   4.10000    81: return $has;
\&    260643   0.02841   4.07000   128: if ( $debug ) {
\&    260643   0.02601   4.04000   126: my $message = shift;
\&    251215   0.02641   3.91000    73: my $has = 0;
\&    251215   0.03311   3.71000    70: my $i_wd  = shift;
\&    251215   0.02699   3.69000    72: my $regex = shift;
\&    251215   0.02766   3.68000    71: my $word  = shift;
\&     50243   0.59726   1.00000    59:  $count{$i_LINES}{cons} =
\&     50243   0.48175   0.92000    61:  $count{$i_LINES}{spec} =
\&     50243   0.00644   0.89000    56:  my $i_cons = matches($i_word, $word,
\&     50243   0.48837   0.88000    63:  $count{$i_LINES}{caps} =
\&     50243   0.00516   0.88000    58:  my $i_caps = matches($i_word, $word, \*(Aq^[(A\-
\&     50243   0.00631   0.81000    54:  my $i_spec = matches($i_word, $word, \*(Aq[^a\-
\&     50243   0.00496   0.80000    57:  my $i_vows = matches($i_word, $word,
\&     50243   0.00688   0.80000    53:  $i_word++;
\&     50243   0.48469   0.79000    62:  $count{$i_LINES}{only} =
\&     50243   0.48928   0.77000    60:  $count{$i_LINES}{vows} =
\&     50243   0.00683   0.75000    55:  my $i_only = matches($i_word, $word, \*(Aq^[^a\-
.Ve
.PP
You can immediately see a slightly different focus to the subroutine profiling
modules, and we start to see exactly which line of code is taking the most
time.  That regex line is looking a bit suspicious, for example.  Remember that
these tools are supposed to be used together, there is no single best way to
profile your code, you need to use the best tools for the job.
.PP
See also \f(CW\*(C`Apache::SmallProf\*(C'\fR which hooks \f(CW\*(C`Devel::SmallProf\*(C'\fR into \f(CW\*(C`mod_perl\*(C'\fR.
.SS "Devel::FastProf"
.IX Subsection "Devel::FastProf"
\&\f(CW\*(C`Devel::FastProf\*(C'\fR is another Perl line profiler.  This was written with a view
to getting a faster line profiler, than is possible with for example
\&\f(CW\*(C`Devel::SmallProf\*(C'\fR, because it's written in \f(CW\*(C`C\*(C'\fR.  To use \f(CW\*(C`Devel::FastProf\*(C'\fR,
supply the \f(CW\*(C`\-d\*(C'\fR argument to Perl:
.PP
.Vb 1
\&    $> perl \-d:FastProf wordmatch \-f perl5db.pl
\&
\&    <...multiple lines snipped...>
\&
\&    wordmatch report for perl5db.pl:
\&    lines in file: 9428
\&    words in file: 50243
\&    words with special (non\-word) characters: 20480
\&    words with only special (non\-word) characters: 7790
\&    words with only consonants: 4801
\&    words with only capital letters: 1316
\&    words with only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`Devel::FastProf\*(C'\fR writes statistics to the file \fIfastprof.out\fR in the current
directory.  The output file, which can be specified, can be interpreted by using
the \f(CW\*(C`fprofpp\*(C'\fR command-line program.
.PP
.Vb 1
\&    $> fprofpp | head \-n20
\&
\&    # fprofpp output format is:
\&    # filename:line time count: source
\&    wordmatch:75 3.93338 251215: if ( $word =~ /($regex)/ ) {
\&    wordmatch:79 1.77774 251215: debug("word: $i_wd ".($has ? \*(Aqmatches\*(Aq : \*(Aqdoes not match\*(Aq)." chars: /$regex/");
\&    wordmatch:81 1.47604 251215: return $has;
\&    wordmatch:126 1.43441 260643: my $message = shift;
\&    wordmatch:128 1.42156 260643: if ( $debug ) {
\&    wordmatch:70 1.36824 251215: my $i_wd  = shift;
\&    wordmatch:71 1.36739 251215: my $word  = shift;
\&    wordmatch:72 1.35939 251215: my $regex = shift;
.Ve
.PP
Straightaway we can see that the number of times each line has been called is
identical to the \f(CW\*(C`Devel::SmallProf\*(C'\fR output, and the sequence is only very
slightly different based on the ordering of the amount of time each line took
to execute, \f(CW\*(C`if ( $debug ) { \*(C'\fR and \f(CW\*(C`my $message = shift;\*(C'\fR, for example.  The
differences in the actual times recorded might be in the algorithm used
internally, or it could be due to system resource limitations or contention.
.PP
See also the DBIx::Profile which will profile database queries running
under the \f(CW\*(C`DBIx::*\*(C'\fR namespace.
.SS "Devel::NYTProf"
.IX Subsection "Devel::NYTProf"
\&\f(CW\*(C`Devel::NYTProf\*(C'\fR is the \fBnext generation\fR of Perl code profiler, fixing many
shortcomings in other tools and implementing many cool features.  First of all it
can be used as either a \fIline\fR profiler, a \fIblock\fR or a \fIsubroutine\fR
profiler, all at once.  It can also use sub-microsecond (100ns) resolution on
systems which provide \f(CW\*(C`clock_gettime()\*(C'\fR.  It can be started and stopped even
by the program being profiled.  It's a one-line entry to profile \f(CW\*(C`mod_perl\*(C'\fR
applications.  It's written in \f(CW\*(C`c\*(C'\fR and is probably the fastest profiler
available for Perl.  The list of coolness just goes on.  Enough of that, let's
see how to it works \- just use the familiar \f(CW\*(C`\-d\*(C'\fR switch to plug it in and run
the code.
.PP
.Vb 1
\&    $> perl \-d:NYTProf wordmatch \-f perl5db.pl
\&
\&    wordmatch report for perl5db.pl:
\&    lines in file: 9427
\&    words in file: 50243
\&    words with special (non\-word) characters: 20480
\&    words with only special (non\-word) characters: 7790
\&    words with only consonants: 4801
\&    words with only capital letters: 1316
\&    words with only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`NYTProf\*(C'\fR will generate a report database into the file \fInytprof.out\fR by
default.  Human readable reports can be generated from here by using the
supplied \f(CW\*(C`nytprofhtml\*(C'\fR (\s-1HTML\s0 output) and \f(CW\*(C`nytprofcsv\*(C'\fR (\s-1CSV\s0 output) programs.
We've used the Unix system \f(CW\*(C`html2text\*(C'\fR utility to convert the
\&\fInytprof/index.html\fR file for convenience here.
.PP
.Vb 1
\&    $> html2text nytprof/index.html
\&
\&    Performance Profile Index
\&    For wordmatch
\&      Run on Fri Sep 26 13:46:39 2008
\&    Reported on Fri Sep 26 13:47:23 2008
\&
\&             Top 15 Subroutines \-\- ordered by exclusive time
\&    |Calls |P |F |Inclusive|Exclusive|Subroutine                          |
\&    |      |  |  |Time     |Time     |                                    |
\&    |251215|5 |1 |13.09263 |10.47692 |main::              |matches        |
\&    |260642|2 |1 |2.71199  |2.71199  |main::              |debug          |
\&    |1     |1 |1 |0.21404  |0.21404  |main::              |report         |
\&    |2     |2 |2 |0.00511  |0.00511  |XSLoader::          |load (xsub)    |
\&    |14    |14|7 |0.00304  |0.00298  |Exporter::          |import         |
\&    |3     |1 |1 |0.00265  |0.00254  |Exporter::          |as_heavy       |
\&    |10    |10|4 |0.00140  |0.00140  |vars::              |import         |
\&    |13    |13|1 |0.00129  |0.00109  |constant::          |import         |
\&    |1     |1 |1 |0.00360  |0.00096  |FileHandle::        |import         |
\&    |3     |3 |3 |0.00086  |0.00074  |warnings::register::|import         |
\&    |9     |3 |1 |0.00036  |0.00036  |strict::            |bits           |
\&    |13    |13|13|0.00032  |0.00029  |strict::            |import         |
\&    |2     |2 |2 |0.00020  |0.00020  |warnings::          |import         |
\&    |2     |1 |1 |0.00020  |0.00020  |Getopt::Long::      |ParseOptionSpec|
\&    |7     |7 |6 |0.00043  |0.00020  |strict::            |unimport       |
\&
\&    For more information see the full list of 189 subroutines.
.Ve
.PP
The first part of the report already shows the critical information regarding
which subroutines are using the most time.  The next gives some statistics
about the source files profiled.
.PP
.Vb 10
\&            Source Code Files \-\- ordered by exclusive time then name
\&    |Stmts  |Exclusive|Avg.   |Reports                     |Source File         |
\&    |       |Time     |       |                            |                    |
\&    |2699761|15.66654 |6e\-06  |line   .    block   .    sub|wordmatch           |
\&    |35     |0.02187  |0.00062|line   .    block   .    sub|IO/Handle.pm        |
\&    |274    |0.01525  |0.00006|line   .    block   .    sub|Getopt/Long.pm      |
\&    |20     |0.00585  |0.00029|line   .    block   .    sub|Fcntl.pm            |
\&    |128    |0.00340  |0.00003|line   .    block   .    sub|Exporter/Heavy.pm   |
\&    |42     |0.00332  |0.00008|line   .    block   .    sub|IO/File.pm          |
\&    |261    |0.00308  |0.00001|line   .    block   .    sub|Exporter.pm         |
\&    |323    |0.00248  |8e\-06  |line   .    block   .    sub|constant.pm         |
\&    |12     |0.00246  |0.00021|line   .    block   .    sub|File/Spec/Unix.pm   |
\&    |191    |0.00240  |0.00001|line   .    block   .    sub|vars.pm             |
\&    |77     |0.00201  |0.00003|line   .    block   .    sub|FileHandle.pm       |
\&    |12     |0.00198  |0.00016|line   .    block   .    sub|Carp.pm             |
\&    |14     |0.00175  |0.00013|line   .    block   .    sub|Symbol.pm           |
\&    |15     |0.00130  |0.00009|line   .    block   .    sub|IO.pm               |
\&    |22     |0.00120  |0.00005|line   .    block   .    sub|IO/Seekable.pm      |
\&    |198    |0.00085  |4e\-06  |line   .    block   .    sub|warnings/register.pm|
\&    |114    |0.00080  |7e\-06  |line   .    block   .    sub|strict.pm           |
\&    |47     |0.00068  |0.00001|line   .    block   .    sub|warnings.pm         |
\&    |27     |0.00054  |0.00002|line   .    block   .    sub|overload.pm         |
\&    |9      |0.00047  |0.00005|line   .    block   .    sub|SelectSaver.pm      |
\&    |13     |0.00045  |0.00003|line   .    block   .    sub|File/Spec.pm        |
\&    |2701595|15.73869 |       |Total                       |
\&    |128647 |0.74946  |       |Average                     |
\&    |       |0.00201  |0.00003|Median                      |
\&    |       |0.00121  |0.00003|Deviation                   |
\&
\&    Report produced by the NYTProf 2.03 Perl profiler, developed by Tim Bunce and
\&    Adam Kaplan.
.Ve
.PP
At this point, if you're using the \fIhtml\fR report, you can click through the
various links to bore down into each subroutine and each line of code.  Because
we're using the text reporting here, and there's a whole directory full of
reports built for each source file, we'll just display a part of the
corresponding \fIwordmatch\-line.html\fR file, sufficient to give an idea of the
sort of output you can expect from this cool tool.
.PP
.Vb 1
\&    $> html2text nytprof/wordmatch\-line.html
\&
\&    Performance Profile \-\- \-block view\-.\-line view\-.\-sub view\-
\&    For wordmatch
\&    Run on Fri Sep 26 13:46:39 2008
\&    Reported on Fri Sep 26 13:47:22 2008
\&
\&    File wordmatch
\&
\&     Subroutines \-\- ordered by exclusive time
\&    |Calls |P|F|Inclusive|Exclusive|Subroutine    |
\&    |      | | |Time     |Time     |              |
\&    |251215|5|1|13.09263 |10.47692 |main::|matches|
\&    |260642|2|1|2.71199  |2.71199  |main::|debug  |
\&    |1     |1|1|0.21404  |0.21404  |main::|report |
\&    |0     |0|0|0        |0        |main::|BEGIN  |
\&
\&
\&    |Line|Stmts.|Exclusive|Avg.   |Code                                           |
\&    |    |      |Time     |       |                                               |
\&    |1   |      |         |       |#!/usr/bin/perl                                |
\&    |2   |      |         |       |                                               |
\&    |    |      |         |       |use strict;                                    |
\&    |3   |3     |0.00086  |0.00029|# spent 0.00003s making 1 calls to strict::    |
\&    |    |      |         |       |import                                         |
\&    |    |      |         |       |use warnings;                                  |
\&    |4   |3     |0.01563  |0.00521|# spent 0.00012s making 1 calls to warnings::  |
\&    |    |      |         |       |import                                         |
\&    |5   |      |         |       |                                               |
\&    |6   |      |         |       |=head1 NAME                                    |
\&    |7   |      |         |       |                                               |
\&    |8   |      |         |       |filewords \- word analysis of input file        |
\&    <...snip...>
\&    |62  |1     |0.00445  |0.00445|print report( %count );                        |
\&    |    |      |         |       |# spent 0.21404s making 1 calls to main::report|
\&    |63  |      |         |       |                                               |
\&    |    |      |         |       |# spent 23.56955s (10.47692+2.61571) within    |
\&    |    |      |         |       |main::matches which was called 251215 times,   |
\&    |    |      |         |       |avg 0.00005s/call: # 50243 times               |
\&    |    |      |         |       |(2.12134+0.51939s) at line 57 of wordmatch, avg|
\&    |    |      |         |       |0.00005s/call # 50243 times (2.17735+0.54550s) |
\&    |64  |      |         |       |at line 56 of wordmatch, avg 0.00005s/call #   |
\&    |    |      |         |       |50243 times (2.10992+0.51797s) at line 58 of   |
\&    |    |      |         |       |wordmatch, avg 0.00005s/call # 50243 times     |
\&    |    |      |         |       |(2.12696+0.51598s) at line 55 of wordmatch, avg|
\&    |    |      |         |       |0.00005s/call # 50243 times (1.94134+0.51687s) |
\&    |    |      |         |       |at line 54 of wordmatch, avg 0.00005s/call     |
\&    |    |      |         |       |sub matches {                                  |
\&    <...snip...>
\&    |102 |      |         |       |                                               |
\&    |    |      |         |       |# spent 2.71199s within main::debug which was  |
\&    |    |      |         |       |called 260642 times, avg 0.00001s/call: #      |
\&    |    |      |         |       |251215 times (2.61571+0s) by main::matches at  |
\&    |103 |      |         |       |line 74 of wordmatch, avg 0.00001s/call # 9427 |
\&    |    |      |         |       |times (0.09628+0s) at line 50 of wordmatch, avg|
\&    |    |      |         |       |0.00001s/call                                  |
\&    |    |      |         |       |sub debug {                                    |
\&    |104 |260642|0.58496  |2e\-06  |my $message = shift;                           |
\&    |105 |      |         |       |                                               |
\&    |106 |260642|1.09917  |4e\-06  |if ( $debug ) {                                |
\&    |107 |      |         |       |print STDERR "DBG: $message\en";                |
\&    |108 |      |         |       |}                                              |
\&    |109 |      |         |       |}                                              |
\&    |110 |      |         |       |                                               |
\&    |111 |1     |0.01501  |0.01501|exit 0;                                        |
\&    |112 |      |         |       |                                               |
.Ve
.PP
Oodles of very useful information in there \- this seems to be the way forward.
.PP
See also \f(CW\*(C`Devel::NYTProf::Apache\*(C'\fR which hooks \f(CW\*(C`Devel::NYTProf\*(C'\fR into \f(CW\*(C`mod_perl\*(C'\fR.
.SH "SORTING"
.IX Header "SORTING"
Perl modules are not the only tools a performance analyst has at their
disposal, system tools like \f(CW\*(C`time\*(C'\fR should not be overlooked as the next
example shows, where we take a quick look at sorting.  Many books, theses and
articles, have been written about efficient sorting algorithms, and this is not
the place to repeat such work, there's several good sorting modules which
deserve taking a look at too: \f(CW\*(C`Sort::Maker\*(C'\fR, \f(CW\*(C`Sort::Key\*(C'\fR spring to mind.
However, it's still possible to make some observations on certain Perl specific
interpretations on issues relating to sorting data sets and give an example or
two with regard to how sorting large data volumes can effect performance.
Firstly, an often overlooked point when sorting large amounts of data, one can
attempt to reduce the data set to be dealt with and in many cases \f(CW\*(C`grep()\*(C'\fR can
be quite useful as a simple filter:
.PP
.Vb 1
\&    @data = sort grep { /$filter/ } @incoming
.Ve
.PP
A command such as this can vastly reduce the volume of material to actually
sort through in the first place, and should not be too lightly disregarded
purely on the basis of its simplicity.  The \f(CW\*(C`KISS\*(C'\fR principle is too often
overlooked \- the next example uses the simple system \f(CW\*(C`time\*(C'\fR utility to
demonstrate.  Let's take a look at an actual example of sorting the contents of
a large file, an apache logfile would do.  This one has over a quarter of a
million lines, is 50M in size, and a snippet of it looks like this:
.PP
# logfile
.PP
.Vb 10
\&    188.209\-65\-87.adsl\-dyn.isp.belgacom.be \- \- [08/Feb/2007:12:57:16 +0000] "GET /favicon.ico HTTP/1.1" 404 209 "\-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    188.209\-65\-87.adsl\-dyn.isp.belgacom.be \- \- [08/Feb/2007:12:57:16 +0000] "GET /favicon.ico HTTP/1.1" 404 209 "\-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    151.56.71.198 \- \- [08/Feb/2007:12:57:41 +0000] "GET /suse\-on\-vaio.html HTTP/1.1" 200 2858 "http://www.linux\-on\-laptops.com/sony.html" "Mozilla/5.0 (Windows; U; Windows NT 5.2; en\-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1"
\&    151.56.71.198 \- \- [08/Feb/2007:12:57:42 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net/suse\-on\-vaio.html" "Mozilla/5.0 (Windows; U; Windows NT 5.2; en\-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1"
\&    151.56.71.198 \- \- [08/Feb/2007:12:57:43 +0000] "GET /favicon.ico HTTP/1.1" 404 209 "\-" "Mozilla/5.0 (Windows; U; Windows NT 5.2; en\-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1"
\&    217.113.68.60 \- \- [08/Feb/2007:13:02:15 +0000] "GET / HTTP/1.1" 304 \- "\-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    217.113.68.60 \- \- [08/Feb/2007:13:02:16 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net/" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    debora.to.isac.cnr.it \- \- [08/Feb/2007:13:03:58 +0000] "GET /suse\-on\-vaio.html HTTP/1.1" 200 2858 "http://www.linux\-on\-laptops.com/sony.html" "Mozilla/5.0 (compatible; Konqueror/3.4; Linux) KHTML/3.4.0 (like Gecko)"
\&    debora.to.isac.cnr.it \- \- [08/Feb/2007:13:03:58 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net/suse\-on\-vaio.html" "Mozilla/5.0 (compatible; Konqueror/3.4; Linux) KHTML/3.4.0 (like Gecko)"
\&    debora.to.isac.cnr.it \- \- [08/Feb/2007:13:03:58 +0000] "GET /favicon.ico HTTP/1.1" 404 209 "\-" "Mozilla/5.0 (compatible; Konqueror/3.4; Linux) KHTML/3.4.0 (like Gecko)"
\&    195.24.196.99 \- \- [08/Feb/2007:13:26:48 +0000] "GET / HTTP/1.0" 200 3309 "\-" "Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8.0.9) Gecko/20061206 Firefox/1.5.0.9"
\&    195.24.196.99 \- \- [08/Feb/2007:13:26:58 +0000] "GET /data/css HTTP/1.0" 404 206 "http://www.rfi.net/" "Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8.0.9) Gecko/20061206 Firefox/1.5.0.9"
\&    195.24.196.99 \- \- [08/Feb/2007:13:26:59 +0000] "GET /favicon.ico HTTP/1.0" 404 209 "\-" "Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8.0.9) Gecko/20061206 Firefox/1.5.0.9"
\&    crawl1.cosmixcorp.com \- \- [08/Feb/2007:13:27:57 +0000] "GET /robots.txt HTTP/1.0" 200 179 "\-" "voyager/1.0"
\&    crawl1.cosmixcorp.com \- \- [08/Feb/2007:13:28:25 +0000] "GET /links.html HTTP/1.0" 200 3413 "\-" "voyager/1.0"
\&    fhm226.internetdsl.tpnet.pl \- \- [08/Feb/2007:13:37:32 +0000] "GET /suse\-on\-vaio.html HTTP/1.1" 200 2858 "http://www.linux\-on\-laptops.com/sony.html" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    fhm226.internetdsl.tpnet.pl \- \- [08/Feb/2007:13:37:34 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net/suse\-on\-vaio.html" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    80.247.140.134 \- \- [08/Feb/2007:13:57:35 +0000] "GET / HTTP/1.1" 200 3309 "\-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; .NET CLR 1.1.4322)"
\&    80.247.140.134 \- \- [08/Feb/2007:13:57:37 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; .NET CLR 1.1.4322)"
\&    pop.compuscan.co.za \- \- [08/Feb/2007:14:10:43 +0000] "GET / HTTP/1.1" 200 3309 "\-" "www.clamav.net"
\&    livebot\-207\-46\-98\-57.search.live.com \- \- [08/Feb/2007:14:12:04 +0000] "GET /robots.txt HTTP/1.0" 200 179 "\-" "msnbot/1.0 (+http://search.msn.com/msnbot.htm)"
\&    livebot\-207\-46\-98\-57.search.live.com \- \- [08/Feb/2007:14:12:04 +0000] "GET /html/oracle.html HTTP/1.0" 404 214 "\-" "msnbot/1.0 (+http://search.msn.com/msnbot.htm)"
\&    dslb\-088\-064\-005\-154.pools.arcor\-ip.net \- \- [08/Feb/2007:14:12:15 +0000] "GET / HTTP/1.1" 200 3309 "\-" "www.clamav.net"
\&    196.201.92.41 \- \- [08/Feb/2007:14:15:01 +0000] "GET / HTTP/1.1" 200 3309 "\-" "MOT\-L7/08.B7.DCR MIB/2.2.1 Profile/MIDP\-2.0 Configuration/CLDC\-1.1"
.Ve
.PP
The specific task here is to sort the 286,525 lines of this file by Response
Code, Query, Browser, Referring Url, and lastly Date.  One solution might be to
use the following code, which iterates over the files given on the
command-line.
.PP
# sort-apache-log
.PP
.Vb 1
\&    #!/usr/bin/perl \-n
\&
\&    use strict;
\&    use warnings;
\&
\&    my @data;
\&
\&    LINE:
\&    while ( <> ) {
\&        my $line = $_;
\&        if (
\&            $line =~ m/^(
\&                ([\ew\e.\e\-]+)             # client
\&                \es*\-\es*\-\es*\e[
\&                ([^]]+)                 # date
\&                \e]\es*"\ew+\es*
\&                (\eS+)                   # query
\&                [^"]+"\es*
\&                (\ed+)                   # status
\&                \es+\eS+\es+"[^"]*"\es+"
\&                ([^"]*)                 # browser
\&                "
\&                .*
\&            )$/x
\&        ) {
\&            my @chunks = split(/ +/, $line);
\&            my $ip      = $1;
\&            my $date    = $2;
\&            my $query   = $3;
\&            my $status  = $4;
\&            my $browser = $5;
\&
\&            push(@data, [$ip, $date, $query, $status, $browser, $line]);
\&        }
\&    }
\&
\&    my @sorted = sort {
\&        $a\->[3] cmp $b\->[3]
\&                ||
\&        $a\->[2] cmp $b\->[2]
\&                ||
\&        $a\->[0] cmp $b\->[0]
\&                ||
\&        $a\->[1] cmp $b\->[1]
\&                ||
\&        $a\->[4] cmp $b\->[4]
\&    } @data;
\&
\&    foreach my $data ( @sorted ) {
\&        print $data\->[5];
\&    }
\&
\&    exit 0;
.Ve
.PP
When running this program, redirect \f(CW\*(C`STDOUT\*(C'\fR so it is possible to check the
output is correct from following test runs and use the system \f(CW\*(C`time\*(C'\fR utility
to check the overall runtime.
.PP
.Vb 1
\&    $> time ./sort\-apache\-log logfile > out\-sort
\&
\&    real    0m17.371s
\&    user    0m15.757s
\&    sys     0m0.592s
.Ve
.PP
The program took just over 17 wallclock seconds to run.  Note the different
values \f(CW\*(C`time\*(C'\fR outputs, it's important to always use the same one, and to not
confuse what each one means.
.IP "Elapsed Real Time" 4
.IX Item "Elapsed Real Time"
The overall, or wallclock, time between when \f(CW\*(C`time\*(C'\fR was called, and when it
terminates.  The elapsed time includes both user and system times, and time
spent waiting for other users and processes on the system.  Inevitably, this is
the most approximate of the measurements given.
.IP "User \s-1CPU\s0 Time" 4
.IX Item "User CPU Time"
The user time is the amount of time the entire process spent on behalf of the
user on this system executing this program.
.IP "System \s-1CPU\s0 Time" 4
.IX Item "System CPU Time"
The system time is the amount of time the kernel itself spent executing
routines, or system calls, on behalf of this process user.
.PP
Running this same process as a \f(CW\*(C`Schwarzian Transform\*(C'\fR it is possible to
eliminate the input and output arrays for storing all the data, and work on the
input directly as it arrives too.  Otherwise, the code looks fairly similar:
.PP
# sort-apache-log-schwarzian
.PP
.Vb 1
\&    #!/usr/bin/perl \-n
\&
\&    use strict;
\&    use warnings;
\&
\&    print
\&
\&        map $_\->[0] =>
\&
\&        sort {
\&            $a\->[4] cmp $b\->[4]
\&                    ||
\&            $a\->[3] cmp $b\->[3]
\&                    ||
\&            $a\->[1] cmp $b\->[1]
\&                    ||
\&            $a\->[2] cmp $b\->[2]
\&                    ||
\&            $a\->[5] cmp $b\->[5]
\&        }
\&        map  [ $_, m/^(
\&            ([\ew\e.\e\-]+)             # client
\&            \es*\-\es*\-\es*\e[
\&            ([^]]+)                 # date
\&            \e]\es*"\ew+\es*
\&            (\eS+)                   # query
\&            [^"]+"\es*
\&            (\ed+)                   # status
\&            \es+\eS+\es+"[^"]*"\es+"
\&            ([^"]*)                 # browser
\&            "
\&            .*
\&        )$/xo ]
\&
\&        => <>;
\&
\&    exit 0;
.Ve
.PP
Run the new code against the same logfile, as above, to check the new time.
.PP
.Vb 1
\&    $> time ./sort\-apache\-log\-schwarzian logfile > out\-schwarz
\&
\&    real    0m9.664s
\&    user    0m8.873s
\&    sys     0m0.704s
.Ve
.PP
The time has been cut in half, which is a respectable speed improvement by any
standard.  Naturally, it is important to check the output is consistent with
the first program run, this is where the Unix system \f(CW\*(C`cksum\*(C'\fR utility comes in.
.PP
.Vb 3
\&    $> cksum out\-sort out\-schwarz
\&    3044173777 52029194 out\-sort
\&    3044173777 52029194 out\-schwarz
.Ve
.PP
\&\s-1BTW.\s0 Beware too of pressure from managers who see you speed a program up by 50%
of the runtime once, only to get a request one month later to do the same again
(true story) \- you'll just have to point out your only human, even if you are a
Perl programmer, and you'll see what you can do...
.SH "LOGGING"
.IX Header "LOGGING"
An essential part of any good development process is appropriate error handling
with appropriately informative messages, however there exists a school of
thought which suggests that log files should be \fIchatty\fR, as if the chain of
unbroken output somehow ensures the survival of the program.  If speed is in
any way an issue, this approach is wrong.
.PP
A common sight is code which looks something like this:
.PP
.Vb 1
\&    logger\->debug( "A logging message via process\-id: $$ INC: " . Dumper(\e%INC) )
.Ve
.PP
The problem is that this code will always be parsed and executed, even when the
debug level set in the logging configuration file is zero.  Once the \fIdebug()\fR
subroutine has been entered, and the internal \f(CW$debug\fR variable confirmed to
be zero, for example, the message which has been sent in will be discarded and
the program will continue.  In the example given though, the \e%INC hash will
already have been dumped, and the message string constructed, all of which work
could be bypassed by a debug variable at the statement level, like this:
.PP
.Vb 1
\&    logger\->debug( "A logging message via process\-id: $$ INC: " . Dumper(\e%INC) ) if $DEBUG;
.Ve
.PP
This effect can be demonstrated by setting up a test script with both forms,
including a \f(CW\*(C`debug()\*(C'\fR subroutine to emulate typical \f(CW\*(C`logger()\*(C'\fR functionality.
.PP
# ifdebug
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    use Benchmark;
\&    use Data::Dumper;
\&    my $DEBUG = 0;
\&
\&    sub debug {
\&        my $msg = shift;
\&
\&        if ( $DEBUG ) {
\&            print "DEBUG: $msg\en";
\&        }
\&    };
\&
\&    timethese(100000, {
\&            \*(Aqdebug\*(Aq       => sub {
\&                debug( "A $0 logging message via process\-id: $$" . Dumper(\e%INC) )
\&            },
\&            \*(Aqifdebug\*(Aq  => sub {
\&                debug( "A $0 logging message via process\-id: $$" . Dumper(\e%INC) ) if $DEBUG
\&            },
\&    });
.Ve
.PP
Let's see what \f(CW\*(C`Benchmark\*(C'\fR makes of this:
.PP
.Vb 5
\&    $> perl ifdebug
\&    Benchmark: timing 100000 iterations of constant, sub...
\&       ifdebug:  0 wallclock secs ( 0.01 usr +  0.00 sys =  0.01 CPU) @ 10000000.00/s (n=100000)
\&                (warning: too few iterations for a reliable count)
\&         debug: 14 wallclock secs (13.18 usr +  0.04 sys = 13.22 CPU) @ 7564.30/s (n=100000)
.Ve
.PP
In the one case the code, which does exactly the same thing as far as
outputting any debugging information is concerned, in other words nothing,
takes 14 seconds, and in the other case the code takes one hundredth of a
second.  Looks fairly definitive.  Use a \f(CW$DEBUG\fR variable \s-1BEFORE\s0 you call the
subroutine, rather than relying on the smart functionality inside it.
.SS "Logging if \s-1DEBUG \s0(constant)"
.IX Subsection "Logging if DEBUG (constant)"
It's possible to take the previous idea a little further, by using a compile
time \f(CW\*(C`DEBUG\*(C'\fR constant.
.PP
# ifdebug-constant
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    use Benchmark;
\&    use Data::Dumper;
\&    use constant
\&        DEBUG => 0
\&    ;
\&
\&    sub debug {
\&        if ( DEBUG ) {
\&            my $msg = shift;
\&            print "DEBUG: $msg\en";
\&        }
\&    };
\&
\&    timethese(100000, {
\&            \*(Aqdebug\*(Aq       => sub {
\&                debug( "A $0 logging message via process\-id: $$" . Dumper(\e%INC) )
\&            },
\&            \*(Aqconstant\*(Aq  => sub {
\&                debug( "A $0 logging message via process\-id: $$" . Dumper(\e%INC) ) if DEBUG
\&            },
\&    });
.Ve
.PP
Running this program produces the following output:
.PP
.Vb 5
\&    $> perl ifdebug\-constant
\&    Benchmark: timing 100000 iterations of constant, sub...
\&      constant:  0 wallclock secs (\-0.00 usr +  0.00 sys = \-0.00 CPU) @ \-7205759403792793600000.00/s (n=100000)
\&                (warning: too few iterations for a reliable count)
\&           sub: 14 wallclock secs (13.09 usr +  0.00 sys = 13.09 CPU) @ 7639.42/s (n=100000)
.Ve
.PP
The \f(CW\*(C`DEBUG\*(C'\fR constant wipes the floor with even the \f(CW$debug\fR variable,
clocking in at minus zero seconds, and generates a \*(L"warning: too few iterations
for a reliable count\*(R" message into the bargain.  To see what is really going
on, and why we had too few iterations when we thought we asked for 100000, we
can use the very useful \f(CW\*(C`B::Deparse\*(C'\fR to inspect the new code:
.PP
.Vb 1
\&    $> perl \-MO=Deparse ifdebug\-constant
\&
\&    use Benchmark;
\&    use Data::Dumper;
\&    use constant (\*(AqDEBUG\*(Aq, 0);
\&    sub debug {
\&        use warnings;
\&        use strict \*(Aqrefs\*(Aq;
\&        0;
\&    }
\&    use warnings;
\&    use strict \*(Aqrefs\*(Aq;
\&    timethese(100000, {\*(Aqsub\*(Aq, sub {
\&        debug "A $0 logging message via process\-id: $$" . Dumper(\e%INC);
\&    }
\&    , \*(Aqconstant\*(Aq, sub {
\&        0;
\&    }
\&    });
\&    ifdebug\-constant syntax OK
.Ve
.PP
The output shows the \fIconstant()\fR subroutine we're testing being replaced with
the value of the \f(CW\*(C`DEBUG\*(C'\fR constant: zero.  The line to be tested has been
completely optimized away, and you can't get much more efficient than that.
.SH "POSTSCRIPT"
.IX Header "POSTSCRIPT"
This document has provided several way to go about identifying hot-spots, and
checking whether any modifications have improved the runtime of the code.
.PP
As a final thought, remember that it's not (at the time of writing) possible to
produce a useful program which will run in zero or negative time and this basic
principle can be written as: \fIuseful programs are slow\fR by their very
definition.  It is of course possible to write a nearly instantaneous program,
but it's not going to do very much, here's a very efficient one:
.PP
.Vb 1
\&    $> perl \-e 0
.Ve
.PP
Optimizing that any further is a job for \f(CW\*(C`p5p\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Further reading can be found using the modules and links below.
.SS "\s-1PERLDOCS\s0"
.IX Subsection "PERLDOCS"
For example: \f(CW\*(C`perldoc \-f sort\*(C'\fR.
.PP
perlfaq4.
.PP
perlfork, perlfunc, perlretut, perlthrtut.
.PP
threads.
.SS "\s-1MAN PAGES\s0"
.IX Subsection "MAN PAGES"
\&\f(CW\*(C`time\*(C'\fR.
.SS "\s-1MODULES\s0"
.IX Subsection "MODULES"
It's not possible to individually showcase all the performance related code for
Perl here, naturally, but here's a short list of modules from the \s-1CPAN\s0 which
deserve further attention.
.PP
.Vb 10
\&    Apache::DProf
\&    Apache::SmallProf
\&    Benchmark
\&    DBIx::Profile
\&    Devel::AutoProfiler
\&    Devel::DProf
\&    Devel::DProfLB
\&    Devel::FastProf
\&    Devel::GraphVizProf
\&    Devel::NYTProf
\&    Devel::NYTProf::Apache
\&    Devel::Profiler
\&    Devel::Profile
\&    Devel::Profit
\&    Devel::SmallProf
\&    Devel::WxProf
\&    POE::Devel::Profiler
\&    Sort::Key
\&    Sort::Maker
.Ve
.SS "\s-1URLS\s0"
.IX Subsection "URLS"
Very useful online reference material:
.PP
.Vb 1
\&    http://www.ccl4.org/~nick/P/Fast_Enough/
\&
\&    http://www\-128.ibm.com/developerworks/library/l\-optperl.html
\&
\&    http://perlbuzz.com/2007/11/bind\-output\-variables\-in\-dbi\-for\-speed\-and\-safety.html
\&
\&    http://en.wikipedia.org/wiki/Performance_analysis
\&
\&    http://apache.perl.org/docs/1.0/guide/performance.html
\&
\&    http://perlgolf.sourceforge.net/
\&
\&    http://www.sysarch.com/Perl/sort_paper.html
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Richard Foley <richard.foley@rfi.net> Copyright (c) 2008
                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlperf5.16.1                               0100644 0001750 0001750 00000165643 12566207422 023106  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPERF 1"
.TH PERLPERF 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlperf \- Perl Performance and Optimization Techniques
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an introduction to the use of performance and optimization techniques
which can be used with particular reference to perl programs.  While many perl
developers have come from other languages, and can use their prior knowledge
where appropriate, there are many other people who might benefit from a few
perl specific pointers.  If you want the condensed version, perhaps the best
advice comes from the renowned Japanese Samurai, Miyamoto Musashi, who said:
.PP
.Vb 1
\&    "Do Not Engage in Useless Activity"
.Ve
.PP
in 1645.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
Perhaps the most common mistake programmers make is to attempt to optimize
their code before a program actually does anything useful \- this is a bad idea.
There's no point in having an extremely fast program that doesn't work.  The
first job is to get a program to \fIcorrectly\fR do something \fBuseful\fR, (not to
mention ensuring the test suite is fully functional), and only then to consider
optimizing it.  Having decided to optimize existing working code, there are
several simple but essential steps to consider which are intrinsic to any
optimization process.
.SS "\s-1ONE\s0 \s-1STEP\s0 \s-1SIDEWAYS\s0"
.IX Subsection "ONE STEP SIDEWAYS"
Firstly, you need to establish a baseline time for the existing code, which
timing needs to be reliable and repeatable.  You'll probably want to use the
\&\f(CW\*(C`Benchmark\*(C'\fR or \f(CW\*(C`Devel::NYTProf\*(C'\fR modules, or something similar, for this step,
or perhaps the Unix system \f(CW\*(C`time\*(C'\fR utility, whichever is appropriate.  See the
base of this document for a longer list of benchmarking and profiling modules,
and recommended further reading.
.SS "\s-1ONE\s0 \s-1STEP\s0 \s-1FORWARD\s0"
.IX Subsection "ONE STEP FORWARD"
Next, having examined the program for \fIhot spots\fR, (places where the code
seems to run slowly), change the code with the intention of making it run
faster.  Using version control software, like \f(CW\*(C`subversion\*(C'\fR, will ensure no
changes are irreversible.  It's too easy to fiddle here and fiddle there \-
don't change too much at any one time or you might not discover which piece of
code \fBreally\fR was the slow bit.
.SS "\s-1ANOTHER\s0 \s-1STEP\s0 \s-1SIDEWAYS\s0"
.IX Subsection "ANOTHER STEP SIDEWAYS"
It's not enough to say: \*(L"that will make it run faster\*(R", you have to check it.
Rerun the code under control of the benchmarking or profiling modules, from the
first step above, and check that the new code executed the \fBsame task\fR in
\&\fIless time\fR.  Save your work and repeat...
.SH "GENERAL GUIDELINES"
.IX Header "GENERAL GUIDELINES"
The critical thing when considering performance is to remember there is no such
thing as a \f(CW\*(C`Golden Bullet\*(C'\fR, which is why there are no rules, only guidelines.
.PP
It is clear that inline code is going to be faster than subroutine or method
calls, because there is less overhead, but this approach has the disadvantage
of being less maintainable and comes at the cost of greater memory usage \-
there is no such thing as a free lunch.  If you are searching for an element in
a list, it can be more efficient to store the data in a hash structure, and
then simply look to see whether the key is defined, rather than to loop through
the entire array using \fIgrep()\fR for instance.  \fIsubstr()\fR may be (a lot) faster
than \fIgrep()\fR but not as flexible, so you have another trade-off to access.  Your
code may contain a line which takes 0.01 of a second to execute which if you
call it 1,000 times, quite likely in a program parsing even medium sized files
for instance, you already have a 10 second delay, in just one single code
location, and if you call that line 100,000 times, your entire program will
slow down to an unbearable crawl.
.PP
Using a subroutine as part of your sort is a powerful way to get exactly what
you want, but will usually be slower than the built-in \fIalphabetic\fR \f(CW\*(C`cmp\*(C'\fR and
\&\fInumeric\fR \f(CW\*(C`<=>\*(C'\fR sort operators.  It is possible to make multiple
passes over your data, building indices to make the upcoming sort more
efficient, and to use what is known as the \f(CW\*(C`OM\*(C'\fR (Orcish Maneuver) to cache the
sort keys in advance.  The cache lookup, while a good idea, can itself be a
source of slowdown by enforcing a double pass over the data \- once to setup the
cache, and once to sort the data.  Using \f(CW\*(C`pack()\*(C'\fR to extract the required sort
key into a consistent string can be an efficient way to build a single string
to compare, instead of using multiple sort keys, which makes it possible to use
the standard, written in \f(CW\*(C`c\*(C'\fR and fast, perl \f(CW\*(C`sort()\*(C'\fR function on the output,
and is the basis of the \f(CW\*(C`GRT\*(C'\fR (Guttman Rossler Transform).  Some string
combinations can slow the \f(CW\*(C`GRT\*(C'\fR down, by just being too plain complex for it's
own good.
.PP
For applications using database backends, the standard \f(CW\*(C`DBIx\*(C'\fR namespace has
tries to help with keeping things nippy, not least because it tries to \fInot\fR
query the database until the latest possible moment, but always read the docs
which come with your choice of libraries.  Among the many issues facing
developers dealing with databases should remain aware of is to always use
\&\f(CW\*(C`SQL\*(C'\fR placeholders and to consider pre-fetching data sets when this might
prove advantageous.  Splitting up a large file by assigning multiple processes
to parsing a single file, using say \f(CW\*(C`POE\*(C'\fR, \f(CW\*(C`threads\*(C'\fR or \f(CW\*(C`fork\*(C'\fR can also be a
useful way of optimizing your usage of the available \f(CW\*(C`CPU\*(C'\fR resources, though
this technique is fraught with concurrency issues and demands high attention to
detail.
.PP
Every case has a specific application and one or more exceptions, and there is
no replacement for running a few tests and finding out which method works best
for your particular environment, this is why writing optimal code is not an
exact science, and why we love using Perl so much \- \s-1TMTOWTDI\s0.
.SH "BENCHMARKS"
.IX Header "BENCHMARKS"
Here are a few examples to demonstrate usage of Perl's benchmarking tools.
.SS "Assigning and Dereferencing Variables."
.IX Subsection "Assigning and Dereferencing Variables."
I'm sure most of us have seen code which looks like, (or worse than), this:
.PP
.Vb 2
\&    if ( $obj\->{_ref}\->{_myscore} >= $obj\->{_ref}\->{_yourscore} ) {
\&        ...
.Ve
.PP
This sort of code can be a real eyesore to read, as well as being very
sensitive to typos, and it's much clearer to dereference the variable
explicitly.  We're side-stepping the issue of working with object-oriented
programming techniques to encapsulate variable access via methods, only
accessible through an object.  Here we're just discussing the technical
implementation of choice, and whether this has an effect on performance.  We
can see whether this dereferencing operation, has any overhead by putting
comparative code in a file and running a \f(CW\*(C`Benchmark\*(C'\fR test.
.PP
# dereference
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    use Benchmark;
\&
\&    my $ref = {
\&            \*(Aqref\*(Aq   => {
\&                _myscore    => \*(Aq100 + 1\*(Aq,
\&                _yourscore  => \*(Aq102 \- 1\*(Aq,
\&            },
\&    };
\&
\&    timethese(1000000, {
\&            \*(Aqdirect\*(Aq       => sub {
\&                my $x = $ref\->{ref}\->{_myscore} . $ref\->{ref}\->{_yourscore} ;
\&            },
\&            \*(Aqdereference\*(Aq  => sub {
\&                my $ref  = $ref\->{ref};
\&                my $myscore = $ref\->{_myscore};
\&                my $yourscore = $ref\->{_yourscore};
\&                my $x = $myscore . $yourscore;
\&            },
\&    });
.Ve
.PP
It's essential to run any timing measurements a sufficient number of times so
the numbers settle on a numerical average, otherwise each run will naturally
fluctuate due to variations in the environment, to reduce the effect of
contention for \f(CW\*(C`CPU\*(C'\fR resources and network bandwidth for instance.  Running
the above code for one million iterations, we can take a look at the report
output by the \f(CW\*(C`Benchmark\*(C'\fR module, to see which approach is the most effective.
.PP
.Vb 1
\&    $> perl dereference
\&
\&    Benchmark: timing 1000000 iterations of dereference, direct...
\&    dereference:  2 wallclock secs ( 1.59 usr +  0.00 sys =  1.59 CPU) @ 628930.82/s (n=1000000)
\&        direct:  1 wallclock secs ( 1.20 usr +  0.00 sys =  1.20 CPU) @ 833333.33/s (n=1000000)
.Ve
.PP
The difference is clear to see and the dereferencing approach is slower.  While
it managed to execute an average of 628,930 times a second during our test, the
direct approach managed to run an additional 204,403 times, unfortunately.
Unfortunately, because there are many examples of code written using the
multiple layer direct variable access, and it's usually horrible.  It is,
however, minusculy faster.  The question remains whether the minute gain is
actually worth the eyestrain, or the loss of maintainability.
.SS "Search and replace or tr"
.IX Subsection "Search and replace or tr"
If we have a string which needs to be modified, while a regex will almost
always be much more flexible, \f(CW\*(C`tr\*(C'\fR, an oft underused tool, can still be a
useful.  One scenario might be replace all vowels with another character.  The
regex solution might look like this:
.PP
.Vb 1
\&    $str =~ s/[aeiou]/x/g
.Ve
.PP
The \f(CW\*(C`tr\*(C'\fR alternative might look like this:
.PP
.Vb 1
\&    $str =~ tr/aeiou/xxxxx/
.Ve
.PP
We can put that into a test file which we can run to check which approach is
the fastest, using a global \f(CW$STR\fR variable to assign to the \f(CW\*(C`my $str\*(C'\fR
variable so as to avoid perl trying to optimize any of the work away by
noticing it's assigned only the once.
.PP
# regex-transliterate
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    use Benchmark;
\&
\&    my $STR = "$$\-this and that";
\&
\&    timethese( 1000000, {
\&            \*(Aqsr\*(Aq  => sub { my $str = $STR; $str =~ s/[aeiou]/x/g; return $str; },
\&            \*(Aqtr\*(Aq  => sub { my $str = $STR; $str =~ tr/aeiou/xxxxx/; return $str; },
\&    });
.Ve
.PP
Running the code gives us our results:
.PP
.Vb 1
\&    $> perl regex\-transliterate
\&
\&    Benchmark: timing 1000000 iterations of sr, tr...
\&            sr:  2 wallclock secs ( 1.19 usr +  0.00 sys =  1.19 CPU) @ 840336.13/s (n=1000000)
\&            tr:  0 wallclock secs ( 0.49 usr +  0.00 sys =  0.49 CPU) @ 2040816.33/s (n=1000000)
.Ve
.PP
The \f(CW\*(C`tr\*(C'\fR version is a clear winner.  One solution is flexible, the other is
fast \- and it's appropriately the programmer's choice which to use.
.PP
Check the \f(CW\*(C`Benchmark\*(C'\fR docs for further useful techniques.
.SH "PROFILING TOOLS"
.IX Header "PROFILING TOOLS"
A slightly larger piece of code will provide something on which a profiler can
produce more extensive reporting statistics.  This example uses the simplistic
\&\f(CW\*(C`wordmatch\*(C'\fR program which parses a given input file and spews out a short
report on the contents.
.PP
# wordmatch
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    =head1 NAME
\&
\&    filewords \- word analysis of input file
\&
\&    =head1 SYNOPSIS
\&
\&        filewords \-f inputfilename [\-d]
\&
\&    =head1 DESCRIPTION
\&
\&    This program parses the given filename, specified with C<\-f>, and displays a
\&    simple analysis of the words found therein.  Use the C<\-d> switch to enable
\&    debugging messages.
\&
\&    =cut
\&
\&    use FileHandle;
\&    use Getopt::Long;
\&
\&    my $debug   =  0;
\&    my $file    = \*(Aq\*(Aq;
\&
\&    my $result = GetOptions (
\&        \*(Aqdebug\*(Aq         => \e$debug,
\&        \*(Aqfile=s\*(Aq        => \e$file,
\&    );
\&    die("invalid args") unless $result;
\&
\&    unless ( \-f $file ) {
\&        die("Usage: $0 \-f filename [\-d]");
\&    }
\&    my $FH = FileHandle\->new("< $file") or die("unable to open file($file): $!");
\&
\&    my $i_LINES = 0;
\&    my $i_WORDS = 0;
\&    my %count   = ();
\&
\&    my @lines = <$FH>;
\&    foreach my $line ( @lines ) {
\&        $i_LINES++;
\&        $line =~ s/\en//;
\&        my @words = split(/ +/, $line);
\&        my $i_words = scalar(@words);
\&        $i_WORDS = $i_WORDS + $i_words;
\&        debug("line: $i_LINES supplying $i_words words: @words");
\&        my $i_word = 0;
\&        foreach my $word ( @words ) {
\&            $i_word++;
\&            $count{$i_LINES}{spec} += matches($i_word, $word, \*(Aq[^a\-zA\-Z0\-9]\*(Aq);
\&            $count{$i_LINES}{only} += matches($i_word, $word, \*(Aq^[^a\-zA\-Z0\-9]+$\*(Aq);
\&            $count{$i_LINES}{cons} += matches($i_word, $word, \*(Aq^[(?i:bcdfghjklmnpqrstvwxyz)]+$\*(Aq);
\&            $count{$i_LINES}{vows} += matches($i_word, $word, \*(Aq^[(?i:aeiou)]+$\*(Aq);
\&            $count{$i_LINES}{caps} += matches($i_word, $word, \*(Aq^[(A\-Z)]+$\*(Aq);
\&        }
\&    }
\&
\&    print report( %count );
\&
\&    sub matches {
\&        my $i_wd  = shift;
\&        my $word  = shift;
\&        my $regex = shift;
\&        my $has = 0;
\&
\&        if ( $word =~ /($regex)/ ) {
\&            $has++ if $1;
\&        }
\&
\&        debug("word: $i_wd ".($has ? \*(Aqmatches\*(Aq : \*(Aqdoes not match\*(Aq)." chars: /$regex/");
\&
\&        return $has;
\&    }
\&
\&    sub report {
\&        my %report = @_;
\&        my %rep;
\&
\&        foreach my $line ( keys %report ) {
\&            foreach my $key ( keys %{ $report{$line} } ) {
\&                $rep{$key} += $report{$line}{$key};
\&            }
\&        }
\&
\&        my $report = qq|
\&    $0 report for $file:
\&    lines in file: $i_LINES
\&    words in file: $i_WORDS
\&    words with special (non\-word) characters: $i_spec
\&    words with only special (non\-word) characters: $i_only
\&    words with only consonants: $i_cons
\&    words with only capital letters: $i_caps
\&    words with only vowels: $i_vows
\&    |;
\&
\&        return $report;
\&    }
\&
\&    sub debug {
\&        my $message = shift;
\&
\&        if ( $debug ) {
\&            print STDERR "DBG: $message\en";
\&        }
\&    }
\&
\&    exit 0;
.Ve
.SS "Devel::DProf"
.IX Subsection "Devel::DProf"
This venerable module has been the de-facto standard for Perl code profiling
for more than a decade, but has been replaced by a number of other modules
which have brought us back to the 21st century.  Although you're recommended to
evaluate your tool from the several mentioned here and from the \s-1CPAN\s0 list at
the base of this document, (and currently Devel::NYTProf seems to be the
weapon of choice \- see below), we'll take a quick look at the output from
Devel::DProf first, to set a baseline for Perl profiling tools.  Run the
above program under the control of \f(CW\*(C`Devel::DProf\*(C'\fR by using the \f(CW\*(C`\-d\*(C'\fR switch on
the command-line.
.PP
.Vb 1
\&    $> perl \-d:DProf wordmatch \-f perl5db.pl
\&
\&    <...multiple lines snipped...>
\&
\&    wordmatch report for perl5db.pl:
\&    lines in file: 9428
\&    words in file: 50243
\&    words with special (non\-word) characters: 20480
\&    words with only special (non\-word) characters: 7790
\&    words with only consonants: 4801
\&    words with only capital letters: 1316
\&    words with only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`Devel::DProf\*(C'\fR produces a special file, called \fItmon.out\fR by default, and
this file is read by the \f(CW\*(C`dprofpp\*(C'\fR program, which is already installed as part
of the \f(CW\*(C`Devel::DProf\*(C'\fR distribution.  If you call \f(CW\*(C`dprofpp\*(C'\fR with no options,
it will read the \fItmon.out\fR file in the current directory and produce a human
readable statistics report of the run of your program.  Note that this may take
a little time.
.PP
.Vb 1
\&    $> dprofpp
\&
\&    Total Elapsed Time = 2.951677 Seconds
\&      User+System Time = 2.871677 Seconds
\&    Exclusive Times
\&    %Time ExclSec CumulS #Calls sec/call Csec/c  Name
\&     102.   2.945  3.003 251215   0.0000 0.0000  main::matches
\&     2.40   0.069  0.069 260643   0.0000 0.0000  main::debug
\&     1.74   0.050  0.050      1   0.0500 0.0500  main::report
\&     1.04   0.030  0.049      4   0.0075 0.0123  main::BEGIN
\&     0.35   0.010  0.010      3   0.0033 0.0033  Exporter::as_heavy
\&     0.35   0.010  0.010      7   0.0014 0.0014  IO::File::BEGIN
\&     0.00       \- \-0.000      1        \-      \-  Getopt::Long::FindOption
\&     0.00       \- \-0.000      1        \-      \-  Symbol::BEGIN
\&     0.00       \- \-0.000      1        \-      \-  Fcntl::BEGIN
\&     0.00       \- \-0.000      1        \-      \-  Fcntl::bootstrap
\&     0.00       \- \-0.000      1        \-      \-  warnings::BEGIN
\&     0.00       \- \-0.000      1        \-      \-  IO::bootstrap
\&     0.00       \- \-0.000      1        \-      \-  Getopt::Long::ConfigDefaults
\&     0.00       \- \-0.000      1        \-      \-  Getopt::Long::Configure
\&     0.00       \- \-0.000      1        \-      \-  Symbol::gensym
.Ve
.PP
\&\f(CW\*(C`dprofpp\*(C'\fR will produce some quite detailed reporting on the activity of the
\&\f(CW\*(C`wordmatch\*(C'\fR program.  The wallclock, user and system, times are at the top of
the analysis, and after this are the main columns defining which define the
report.  Check the \f(CW\*(C`dprofpp\*(C'\fR docs for details of the many options it supports.
.PP
See also \f(CW\*(C`Apache::DProf\*(C'\fR which hooks \f(CW\*(C`Devel::DProf\*(C'\fR into \f(CW\*(C`mod_perl\*(C'\fR.
.SS "Devel::Profiler"
.IX Subsection "Devel::Profiler"
Let's take a look at the same program using a different profiler:
\&\f(CW\*(C`Devel::Profiler\*(C'\fR, a drop-in Perl-only replacement for \f(CW\*(C`Devel::DProf\*(C'\fR.  The
usage is very slightly different in that instead of using the special \f(CW\*(C`\-d:\*(C'\fR
flag, you pull \f(CW\*(C`Devel::Profiler\*(C'\fR in directly as a module using \f(CW\*(C`\-M\*(C'\fR.
.PP
.Vb 1
\&    $> perl \-MDevel::Profiler wordmatch \-f perl5db.pl
\&
\&    <...multiple lines snipped...>
\&
\&    wordmatch report for perl5db.pl:
\&    lines in file: 9428
\&    words in file: 50243
\&    words with special (non\-word) characters: 20480
\&    words with only special (non\-word) characters: 7790
\&    words with only consonants: 4801
\&    words with only capital letters: 1316
\&    words with only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`Devel::Profiler\*(C'\fR generates a tmon.out file which is compatible with the
\&\f(CW\*(C`dprofpp\*(C'\fR program, thus saving the construction of a dedicated statistics
reader program.  \f(CW\*(C`dprofpp\*(C'\fR usage is therefore identical to the above example.
.PP
.Vb 1
\&    $> dprofpp
\&
\&    Total Elapsed Time =   20.984 Seconds
\&      User+System Time =   19.981 Seconds
\&    Exclusive Times
\&    %Time ExclSec CumulS #Calls sec/call Csec/c  Name
\&     49.0   9.792 14.509 251215   0.0000 0.0001  main::matches
\&     24.4   4.887  4.887 260643   0.0000 0.0000  main::debug
\&     0.25   0.049  0.049      1   0.0490 0.0490  main::report
\&     0.00   0.000  0.000      1   0.0000 0.0000  Getopt::Long::GetOptions
\&     0.00   0.000  0.000      2   0.0000 0.0000  Getopt::Long::ParseOptionSpec
\&     0.00   0.000  0.000      1   0.0000 0.0000  Getopt::Long::FindOption
\&     0.00   0.000  0.000      1   0.0000 0.0000  IO::File::new
\&     0.00   0.000  0.000      1   0.0000 0.0000  IO::Handle::new
\&     0.00   0.000  0.000      1   0.0000 0.0000  Symbol::gensym
\&     0.00   0.000  0.000      1   0.0000 0.0000  IO::File::open
.Ve
.PP
Interestingly we get slightly different results, which is mostly because the
algorithm which generates the report is different, even though the output file
format was allegedly identical.  The elapsed, user and system times are clearly
showing the time it took for \f(CW\*(C`Devel::Profiler\*(C'\fR to execute its own run, but
the column listings feel more accurate somehow than the ones we had earlier
from \f(CW\*(C`Devel::DProf\*(C'\fR.  The 102% figure has disappeared, for example.  This is
where we have to use the tools at our disposal, and recognise their pros and
cons, before using them.  Interestingly, the numbers of calls for each
subroutine are identical in the two reports, it's the percentages which differ.
As the author of \f(CW\*(C`Devel::Proviler\*(C'\fR writes:
.PP
.Vb 5
\&    ...running HTML::Template\*(Aqs test suite under Devel::DProf shows output()
\&    taking NO time but Devel::Profiler shows around 10% of the time is in output().
\&    I don\*(Aqt know which to trust but my gut tells me something is wrong with
\&    Devel::DProf.  HTML::Template::output() is a big routine that\*(Aqs called for
\&    every test. Either way, something needs fixing.
.Ve
.PP
\&\s-1YMMV\s0.
.PP
See also \f(CW\*(C`Devel::Apache::Profiler\*(C'\fR which hooks \f(CW\*(C`Devel::Profiler\*(C'\fR into \f(CW\*(C`mod_perl\*(C'\fR.
.SS "Devel::SmallProf"
.IX Subsection "Devel::SmallProf"
The \f(CW\*(C`Devel::SmallProf\*(C'\fR profiler examines the runtime of your Perl program and
produces a line-by-line listing to show how many times each line was called,
and how long each line took to execute.  It is called by supplying the familiar
\&\f(CW\*(C`\-d\*(C'\fR flag to Perl at runtime.
.PP
.Vb 1
\&    $> perl \-d:SmallProf wordmatch \-f perl5db.pl
\&
\&    <...multiple lines snipped...>
\&
\&    wordmatch report for perl5db.pl:
\&    lines in file: 9428
\&    words in file: 50243
\&    words with special (non\-word) characters: 20480
\&    words with only special (non\-word) characters: 7790
\&    words with only consonants: 4801
\&    words with only capital letters: 1316
\&    words with only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`Devel::SmallProf\*(C'\fR writes it's output into a file called \fIsmallprof.out\fR, by
default.  The format of the file looks like this:
.PP
.Vb 1
\&    <num> <time> <ctime> <line>:<text>
.Ve
.PP
When the program has terminated, the output may be examined and sorted using
any standard text filtering utilities.  Something like the following may be
sufficient:
.PP
.Vb 1
\&    $> cat smallprof.out | grep \ed*: | sort \-k3 | tac | head \-n20
\&
\&    251215   1.65674   7.68000    75: if ( $word =~ /($regex)/ ) {
\&    251215   0.03264   4.40000    79: debug("word: $i_wd ".($has ? \*(Aqmatches\*(Aq :
\&    251215   0.02693   4.10000    81: return $has;
\&    260643   0.02841   4.07000   128: if ( $debug ) {
\&    260643   0.02601   4.04000   126: my $message = shift;
\&    251215   0.02641   3.91000    73: my $has = 0;
\&    251215   0.03311   3.71000    70: my $i_wd  = shift;
\&    251215   0.02699   3.69000    72: my $regex = shift;
\&    251215   0.02766   3.68000    71: my $word  = shift;
\&     50243   0.59726   1.00000    59:  $count{$i_LINES}{cons} =
\&     50243   0.48175   0.92000    61:  $count{$i_LINES}{spec} =
\&     50243   0.00644   0.89000    56:  my $i_cons = matches($i_word, $word,
\&     50243   0.48837   0.88000    63:  $count{$i_LINES}{caps} =
\&     50243   0.00516   0.88000    58:  my $i_caps = matches($i_word, $word, \*(Aq^[(A\-
\&     50243   0.00631   0.81000    54:  my $i_spec = matches($i_word, $word, \*(Aq[^a\-
\&     50243   0.00496   0.80000    57:  my $i_vows = matches($i_word, $word,
\&     50243   0.00688   0.80000    53:  $i_word++;
\&     50243   0.48469   0.79000    62:  $count{$i_LINES}{only} =
\&     50243   0.48928   0.77000    60:  $count{$i_LINES}{vows} =
\&     50243   0.00683   0.75000    55:  my $i_only = matches($i_word, $word, \*(Aq^[^a\-
.Ve
.PP
You can immediately see a slightly different focus to the subroutine profiling
modules, and we start to see exactly which line of code is taking the most
time.  That regex line is looking a bit suspicious, for example.  Remember that
these tools are supposed to be used together, there is no single best way to
profile your code, you need to use the best tools for the job.
.PP
See also \f(CW\*(C`Apache::SmallProf\*(C'\fR which hooks \f(CW\*(C`Devel::SmallProf\*(C'\fR into \f(CW\*(C`mod_perl\*(C'\fR.
.SS "Devel::FastProf"
.IX Subsection "Devel::FastProf"
\&\f(CW\*(C`Devel::FastProf\*(C'\fR is another Perl line profiler.  This was written with a view
to getting a faster line profiler, than is possible with for example
\&\f(CW\*(C`Devel::SmallProf\*(C'\fR, because it's written in \f(CW\*(C`C\*(C'\fR.  To use \f(CW\*(C`Devel::FastProf\*(C'\fR,
supply the \f(CW\*(C`\-d\*(C'\fR argument to Perl:
.PP
.Vb 1
\&    $> perl \-d:FastProf wordmatch \-f perl5db.pl
\&
\&    <...multiple lines snipped...>
\&
\&    wordmatch report for perl5db.pl:
\&    lines in file: 9428
\&    words in file: 50243
\&    words with special (non\-word) characters: 20480
\&    words with only special (non\-word) characters: 7790
\&    words with only consonants: 4801
\&    words with only capital letters: 1316
\&    words with only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`Devel::FastProf\*(C'\fR writes statistics to the file \fIfastprof.out\fR in the current
directory.  The output file, which can be specified, can be interpreted by using
the \f(CW\*(C`fprofpp\*(C'\fR command-line program.
.PP
.Vb 1
\&    $> fprofpp | head \-n20
\&
\&    # fprofpp output format is:
\&    # filename:line time count: source
\&    wordmatch:75 3.93338 251215: if ( $word =~ /($regex)/ ) {
\&    wordmatch:79 1.77774 251215: debug("word: $i_wd ".($has ? \*(Aqmatches\*(Aq : \*(Aqdoes not match\*(Aq)." chars: /$regex/");
\&    wordmatch:81 1.47604 251215: return $has;
\&    wordmatch:126 1.43441 260643: my $message = shift;
\&    wordmatch:128 1.42156 260643: if ( $debug ) {
\&    wordmatch:70 1.36824 251215: my $i_wd  = shift;
\&    wordmatch:71 1.36739 251215: my $word  = shift;
\&    wordmatch:72 1.35939 251215: my $regex = shift;
.Ve
.PP
Straightaway we can see that the number of times each line has been called is
identical to the \f(CW\*(C`Devel::SmallProf\*(C'\fR output, and the sequence is only very
slightly different based on the ordering of the amount of time each line took
to execute, \f(CW\*(C`if ( $debug ) { \*(C'\fR and \f(CW\*(C`my $message = shift;\*(C'\fR, for example.  The
differences in the actual times recorded might be in the algorithm used
internally, or it could be due to system resource limitations or contention.
.PP
See also the DBIx::Profile which will profile database queries running
under the \f(CW\*(C`DBIx::*\*(C'\fR namespace.
.SS "Devel::NYTProf"
.IX Subsection "Devel::NYTProf"
\&\f(CW\*(C`Devel::NYTProf\*(C'\fR is the \fBnext generation\fR of Perl code profiler, fixing many
shortcomings in other tools and implementing many cool features.  First of all it
can be used as either a \fIline\fR profiler, a \fIblock\fR or a \fIsubroutine\fR
profiler, all at once.  It can also use sub-microsecond (100ns) resolution on
systems which provide \f(CW\*(C`clock_gettime()\*(C'\fR.  It can be started and stopped even
by the program being profiled.  It's a one-line entry to profile \f(CW\*(C`mod_perl\*(C'\fR
applications.  It's written in \f(CW\*(C`c\*(C'\fR and is probably the fastest profiler
available for Perl.  The list of coolness just goes on.  Enough of that, let's
see how to it works \- just use the familiar \f(CW\*(C`\-d\*(C'\fR switch to plug it in and run
the code.
.PP
.Vb 1
\&    $> perl \-d:NYTProf wordmatch \-f perl5db.pl
\&
\&    wordmatch report for perl5db.pl:
\&    lines in file: 9427
\&    words in file: 50243
\&    words with special (non\-word) characters: 20480
\&    words with only special (non\-word) characters: 7790
\&    words with only consonants: 4801
\&    words with only capital letters: 1316
\&    words with only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`NYTProf\*(C'\fR will generate a report database into the file \fInytprof.out\fR by
default.  Human readable reports can be generated from here by using the
supplied \f(CW\*(C`nytprofhtml\*(C'\fR (\s-1HTML\s0 output) and \f(CW\*(C`nytprofcsv\*(C'\fR (\s-1CSV\s0 output) programs.
We've used the Unix system \f(CW\*(C`html2text\*(C'\fR utility to convert the
\&\fInytprof/index.html\fR file for convenience here.
.PP
.Vb 1
\&    $> html2text nytprof/index.html
\&
\&    Performance Profile Index
\&    For wordmatch
\&      Run on Fri Sep 26 13:46:39 2008
\&    Reported on Fri Sep 26 13:47:23 2008
\&
\&             Top 15 Subroutines \-\- ordered by exclusive time
\&    |Calls |P |F |Inclusive|Exclusive|Subroutine                          |
\&    |      |  |  |Time     |Time     |                                    |
\&    |251215|5 |1 |13.09263 |10.47692 |main::              |matches        |
\&    |260642|2 |1 |2.71199  |2.71199  |main::              |debug          |
\&    |1     |1 |1 |0.21404  |0.21404  |main::              |report         |
\&    |2     |2 |2 |0.00511  |0.00511  |XSLoader::          |load (xsub)    |
\&    |14    |14|7 |0.00304  |0.00298  |Exporter::          |import         |
\&    |3     |1 |1 |0.00265  |0.00254  |Exporter::          |as_heavy       |
\&    |10    |10|4 |0.00140  |0.00140  |vars::              |import         |
\&    |13    |13|1 |0.00129  |0.00109  |constant::          |import         |
\&    |1     |1 |1 |0.00360  |0.00096  |FileHandle::        |import         |
\&    |3     |3 |3 |0.00086  |0.00074  |warnings::register::|import         |
\&    |9     |3 |1 |0.00036  |0.00036  |strict::            |bits           |
\&    |13    |13|13|0.00032  |0.00029  |strict::            |import         |
\&    |2     |2 |2 |0.00020  |0.00020  |warnings::          |import         |
\&    |2     |1 |1 |0.00020  |0.00020  |Getopt::Long::      |ParseOptionSpec|
\&    |7     |7 |6 |0.00043  |0.00020  |strict::            |unimport       |
\&
\&    For more information see the full list of 189 subroutines.
.Ve
.PP
The first part of the report already shows the critical information regarding
which subroutines are using the most time.  The next gives some statistics
about the source files profiled.
.PP
.Vb 10
\&            Source Code Files \-\- ordered by exclusive time then name
\&    |Stmts  |Exclusive|Avg.   |Reports                     |Source File         |
\&    |       |Time     |       |                            |                    |
\&    |2699761|15.66654 |6e\-06  |line   .    block   .    sub|wordmatch           |
\&    |35     |0.02187  |0.00062|line   .    block   .    sub|IO/Handle.pm        |
\&    |274    |0.01525  |0.00006|line   .    block   .    sub|Getopt/Long.pm      |
\&    |20     |0.00585  |0.00029|line   .    block   .    sub|Fcntl.pm            |
\&    |128    |0.00340  |0.00003|line   .    block   .    sub|Exporter/Heavy.pm   |
\&    |42     |0.00332  |0.00008|line   .    block   .    sub|IO/File.pm          |
\&    |261    |0.00308  |0.00001|line   .    block   .    sub|Exporter.pm         |
\&    |323    |0.00248  |8e\-06  |line   .    block   .    sub|constant.pm         |
\&    |12     |0.00246  |0.00021|line   .    block   .    sub|File/Spec/Unix.pm   |
\&    |191    |0.00240  |0.00001|line   .    block   .    sub|vars.pm             |
\&    |77     |0.00201  |0.00003|line   .    block   .    sub|FileHandle.pm       |
\&    |12     |0.00198  |0.00016|line   .    block   .    sub|Carp.pm             |
\&    |14     |0.00175  |0.00013|line   .    block   .    sub|Symbol.pm           |
\&    |15     |0.00130  |0.00009|line   .    block   .    sub|IO.pm               |
\&    |22     |0.00120  |0.00005|line   .    block   .    sub|IO/Seekable.pm      |
\&    |198    |0.00085  |4e\-06  |line   .    block   .    sub|warnings/register.pm|
\&    |114    |0.00080  |7e\-06  |line   .    block   .    sub|strict.pm           |
\&    |47     |0.00068  |0.00001|line   .    block   .    sub|warnings.pm         |
\&    |27     |0.00054  |0.00002|line   .    block   .    sub|overload.pm         |
\&    |9      |0.00047  |0.00005|line   .    block   .    sub|SelectSaver.pm      |
\&    |13     |0.00045  |0.00003|line   .    block   .    sub|File/Spec.pm        |
\&    |2701595|15.73869 |       |Total                       |
\&    |128647 |0.74946  |       |Average                     |
\&    |       |0.00201  |0.00003|Median                      |
\&    |       |0.00121  |0.00003|Deviation                   |
\&
\&    Report produced by the NYTProf 2.03 Perl profiler, developed by Tim Bunce and
\&    Adam Kaplan.
.Ve
.PP
At this point, if you're using the \fIhtml\fR report, you can click through the
various links to bore down into each subroutine and each line of code.  Because
we're using the text reporting here, and there's a whole directory full of
reports built for each source file, we'll just display a part of the
corresponding \fIwordmatch\-line.html\fR file, sufficient to give an idea of the
sort of output you can expect from this cool tool.
.PP
.Vb 1
\&    $> html2text nytprof/wordmatch\-line.html
\&
\&    Performance Profile \-\- \-block view\-.\-line view\-.\-sub view\-
\&    For wordmatch
\&    Run on Fri Sep 26 13:46:39 2008
\&    Reported on Fri Sep 26 13:47:22 2008
\&
\&    File wordmatch
\&
\&     Subroutines \-\- ordered by exclusive time
\&    |Calls |P|F|Inclusive|Exclusive|Subroutine    |
\&    |      | | |Time     |Time     |              |
\&    |251215|5|1|13.09263 |10.47692 |main::|matches|
\&    |260642|2|1|2.71199  |2.71199  |main::|debug  |
\&    |1     |1|1|0.21404  |0.21404  |main::|report |
\&    |0     |0|0|0        |0        |main::|BEGIN  |
\&
\&
\&    |Line|Stmts.|Exclusive|Avg.   |Code                                           |
\&    |    |      |Time     |       |                                               |
\&    |1   |      |         |       |#!/usr/bin/perl                                |
\&    |2   |      |         |       |                                               |
\&    |    |      |         |       |use strict;                                    |
\&    |3   |3     |0.00086  |0.00029|# spent 0.00003s making 1 calls to strict::    |
\&    |    |      |         |       |import                                         |
\&    |    |      |         |       |use warnings;                                  |
\&    |4   |3     |0.01563  |0.00521|# spent 0.00012s making 1 calls to warnings::  |
\&    |    |      |         |       |import                                         |
\&    |5   |      |         |       |                                               |
\&    |6   |      |         |       |=head1 NAME                                    |
\&    |7   |      |         |       |                                               |
\&    |8   |      |         |       |filewords \- word analysis of input file        |
\&    <...snip...>
\&    |62  |1     |0.00445  |0.00445|print report( %count );                        |
\&    |    |      |         |       |# spent 0.21404s making 1 calls to main::report|
\&    |63  |      |         |       |                                               |
\&    |    |      |         |       |# spent 23.56955s (10.47692+2.61571) within    |
\&    |    |      |         |       |main::matches which was called 251215 times,   |
\&    |    |      |         |       |avg 0.00005s/call: # 50243 times               |
\&    |    |      |         |       |(2.12134+0.51939s) at line 57 of wordmatch, avg|
\&    |    |      |         |       |0.00005s/call # 50243 times (2.17735+0.54550s) |
\&    |64  |      |         |       |at line 56 of wordmatch, avg 0.00005s/call #   |
\&    |    |      |         |       |50243 times (2.10992+0.51797s) at line 58 of   |
\&    |    |      |         |       |wordmatch, avg 0.00005s/call # 50243 times     |
\&    |    |      |         |       |(2.12696+0.51598s) at line 55 of wordmatch, avg|
\&    |    |      |         |       |0.00005s/call # 50243 times (1.94134+0.51687s) |
\&    |    |      |         |       |at line 54 of wordmatch, avg 0.00005s/call     |
\&    |    |      |         |       |sub matches {                                  |
\&    <...snip...>
\&    |102 |      |         |       |                                               |
\&    |    |      |         |       |# spent 2.71199s within main::debug which was  |
\&    |    |      |         |       |called 260642 times, avg 0.00001s/call: #      |
\&    |    |      |         |       |251215 times (2.61571+0s) by main::matches at  |
\&    |103 |      |         |       |line 74 of wordmatch, avg 0.00001s/call # 9427 |
\&    |    |      |         |       |times (0.09628+0s) at line 50 of wordmatch, avg|
\&    |    |      |         |       |0.00001s/call                                  |
\&    |    |      |         |       |sub debug {                                    |
\&    |104 |260642|0.58496  |2e\-06  |my $message = shift;                           |
\&    |105 |      |         |       |                                               |
\&    |106 |260642|1.09917  |4e\-06  |if ( $debug ) {                                |
\&    |107 |      |         |       |print STDERR "DBG: $message\en";                |
\&    |108 |      |         |       |}                                              |
\&    |109 |      |         |       |}                                              |
\&    |110 |      |         |       |                                               |
\&    |111 |1     |0.01501  |0.01501|exit 0;                                        |
\&    |112 |      |         |       |                                               |
.Ve
.PP
Oodles of very useful information in there \- this seems to be the way forward.
.PP
See also \f(CW\*(C`Devel::NYTProf::Apache\*(C'\fR which hooks \f(CW\*(C`Devel::NYTProf\*(C'\fR into \f(CW\*(C`mod_perl\*(C'\fR.
.SH "SORTING"
.IX Header "SORTING"
Perl modules are not the only tools a performance analyst has at their
disposal, system tools like \f(CW\*(C`time\*(C'\fR should not be overlooked as the next
example shows, where we take a quick look at sorting.  Many books, theses and
articles, have been written about efficient sorting algorithms, and this is not
the place to repeat such work, there's several good sorting modules which
deserve taking a look at too: \f(CW\*(C`Sort::Maker\*(C'\fR, \f(CW\*(C`Sort::Key\*(C'\fR spring to mind.
However, it's still possible to make some observations on certain Perl specific
interpretations on issues relating to sorting data sets and give an example or
two with regard to how sorting large data volumes can effect performance.
Firstly, an often overlooked point when sorting large amounts of data, one can
attempt to reduce the data set to be dealt with and in many cases \f(CW\*(C`grep()\*(C'\fR can
be quite useful as a simple filter:
.PP
.Vb 1
\&    @data = sort grep { /$filter/ } @incoming
.Ve
.PP
A command such as this can vastly reduce the volume of material to actually
sort through in the first place, and should not be too lightly disregarded
purely on the basis of its simplicity.  The \f(CW\*(C`KISS\*(C'\fR principle is too often
overlooked \- the next example uses the simple system \f(CW\*(C`time\*(C'\fR utility to
demonstrate.  Let's take a look at an actual example of sorting the contents of
a large file, an apache logfile would do.  This one has over a quarter of a
million lines, is 50M in size, and a snippet of it looks like this:
.PP
# logfile
.PP
.Vb 10
\&    188.209\-65\-87.adsl\-dyn.isp.belgacom.be \- \- [08/Feb/2007:12:57:16 +0000] "GET /favicon.ico HTTP/1.1" 404 209 "\-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    188.209\-65\-87.adsl\-dyn.isp.belgacom.be \- \- [08/Feb/2007:12:57:16 +0000] "GET /favicon.ico HTTP/1.1" 404 209 "\-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    151.56.71.198 \- \- [08/Feb/2007:12:57:41 +0000] "GET /suse\-on\-vaio.html HTTP/1.1" 200 2858 "http://www.linux\-on\-laptops.com/sony.html" "Mozilla/5.0 (Windows; U; Windows NT 5.2; en\-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1"
\&    151.56.71.198 \- \- [08/Feb/2007:12:57:42 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net/suse\-on\-vaio.html" "Mozilla/5.0 (Windows; U; Windows NT 5.2; en\-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1"
\&    151.56.71.198 \- \- [08/Feb/2007:12:57:43 +0000] "GET /favicon.ico HTTP/1.1" 404 209 "\-" "Mozilla/5.0 (Windows; U; Windows NT 5.2; en\-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1"
\&    217.113.68.60 \- \- [08/Feb/2007:13:02:15 +0000] "GET / HTTP/1.1" 304 \- "\-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    217.113.68.60 \- \- [08/Feb/2007:13:02:16 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net/" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    debora.to.isac.cnr.it \- \- [08/Feb/2007:13:03:58 +0000] "GET /suse\-on\-vaio.html HTTP/1.1" 200 2858 "http://www.linux\-on\-laptops.com/sony.html" "Mozilla/5.0 (compatible; Konqueror/3.4; Linux) KHTML/3.4.0 (like Gecko)"
\&    debora.to.isac.cnr.it \- \- [08/Feb/2007:13:03:58 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net/suse\-on\-vaio.html" "Mozilla/5.0 (compatible; Konqueror/3.4; Linux) KHTML/3.4.0 (like Gecko)"
\&    debora.to.isac.cnr.it \- \- [08/Feb/2007:13:03:58 +0000] "GET /favicon.ico HTTP/1.1" 404 209 "\-" "Mozilla/5.0 (compatible; Konqueror/3.4; Linux) KHTML/3.4.0 (like Gecko)"
\&    195.24.196.99 \- \- [08/Feb/2007:13:26:48 +0000] "GET / HTTP/1.0" 200 3309 "\-" "Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8.0.9) Gecko/20061206 Firefox/1.5.0.9"
\&    195.24.196.99 \- \- [08/Feb/2007:13:26:58 +0000] "GET /data/css HTTP/1.0" 404 206 "http://www.rfi.net/" "Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8.0.9) Gecko/20061206 Firefox/1.5.0.9"
\&    195.24.196.99 \- \- [08/Feb/2007:13:26:59 +0000] "GET /favicon.ico HTTP/1.0" 404 209 "\-" "Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8.0.9) Gecko/20061206 Firefox/1.5.0.9"
\&    crawl1.cosmixcorp.com \- \- [08/Feb/2007:13:27:57 +0000] "GET /robots.txt HTTP/1.0" 200 179 "\-" "voyager/1.0"
\&    crawl1.cosmixcorp.com \- \- [08/Feb/2007:13:28:25 +0000] "GET /links.html HTTP/1.0" 200 3413 "\-" "voyager/1.0"
\&    fhm226.internetdsl.tpnet.pl \- \- [08/Feb/2007:13:37:32 +0000] "GET /suse\-on\-vaio.html HTTP/1.1" 200 2858 "http://www.linux\-on\-laptops.com/sony.html" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    fhm226.internetdsl.tpnet.pl \- \- [08/Feb/2007:13:37:34 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net/suse\-on\-vaio.html" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    80.247.140.134 \- \- [08/Feb/2007:13:57:35 +0000] "GET / HTTP/1.1" 200 3309 "\-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; .NET CLR 1.1.4322)"
\&    80.247.140.134 \- \- [08/Feb/2007:13:57:37 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; .NET CLR 1.1.4322)"
\&    pop.compuscan.co.za \- \- [08/Feb/2007:14:10:43 +0000] "GET / HTTP/1.1" 200 3309 "\-" "www.clamav.net"
\&    livebot\-207\-46\-98\-57.search.live.com \- \- [08/Feb/2007:14:12:04 +0000] "GET /robots.txt HTTP/1.0" 200 179 "\-" "msnbot/1.0 (+http://search.msn.com/msnbot.htm)"
\&    livebot\-207\-46\-98\-57.search.live.com \- \- [08/Feb/2007:14:12:04 +0000] "GET /html/oracle.html HTTP/1.0" 404 214 "\-" "msnbot/1.0 (+http://search.msn.com/msnbot.htm)"
\&    dslb\-088\-064\-005\-154.pools.arcor\-ip.net \- \- [08/Feb/2007:14:12:15 +0000] "GET / HTTP/1.1" 200 3309 "\-" "www.clamav.net"
\&    196.201.92.41 \- \- [08/Feb/2007:14:15:01 +0000] "GET / HTTP/1.1" 200 3309 "\-" "MOT\-L7/08.B7.DCR MIB/2.2.1 Profile/MIDP\-2.0 Configuration/CLDC\-1.1"
.Ve
.PP
The specific task here is to sort the 286,525 lines of this file by Response
Code, Query, Browser, Referring Url, and lastly Date.  One solution might be to
use the following code, which iterates over the files given on the
command-line.
.PP
# sort-apache-log
.PP
.Vb 1
\&    #!/usr/bin/perl \-n
\&
\&    use strict;
\&    use warnings;
\&
\&    my @data;
\&
\&    LINE:
\&    while ( <> ) {
\&        my $line = $_;
\&        if (
\&            $line =~ m/^(
\&                ([\ew\e.\e\-]+)             # client
\&                \es*\-\es*\-\es*\e[
\&                ([^]]+)                 # date
\&                \e]\es*"\ew+\es*
\&                (\eS+)                   # query
\&                [^"]+"\es*
\&                (\ed+)                   # status
\&                \es+\eS+\es+"[^"]*"\es+"
\&                ([^"]*)                 # browser
\&                "
\&                .*
\&            )$/x
\&        ) {
\&            my @chunks = split(/ +/, $line);
\&            my $ip      = $1;
\&            my $date    = $2;
\&            my $query   = $3;
\&            my $status  = $4;
\&            my $browser = $5;
\&
\&            push(@data, [$ip, $date, $query, $status, $browser, $line]);
\&        }
\&    }
\&
\&    my @sorted = sort {
\&        $a\->[3] cmp $b\->[3]
\&                ||
\&        $a\->[2] cmp $b\->[2]
\&                ||
\&        $a\->[0] cmp $b\->[0]
\&                ||
\&        $a\->[1] cmp $b\->[1]
\&                ||
\&        $a\->[4] cmp $b\->[4]
\&    } @data;
\&
\&    foreach my $data ( @sorted ) {
\&        print $data\->[5];
\&    }
\&
\&    exit 0;
.Ve
.PP
When running this program, redirect \f(CW\*(C`STDOUT\*(C'\fR so it is possible to check the
output is correct from following test runs and use the system \f(CW\*(C`time\*(C'\fR utility
to check the overall runtime.
.PP
.Vb 1
\&    $> time ./sort\-apache\-log logfile > out\-sort
\&
\&    real    0m17.371s
\&    user    0m15.757s
\&    sys     0m0.592s
.Ve
.PP
The program took just over 17 wallclock seconds to run.  Note the different
values \f(CW\*(C`time\*(C'\fR outputs, it's important to always use the same one, and to not
confuse what each one means.
.IP "Elapsed Real Time" 4
.IX Item "Elapsed Real Time"
The overall, or wallclock, time between when \f(CW\*(C`time\*(C'\fR was called, and when it
terminates.  The elapsed time includes both user and system times, and time
spent waiting for other users and processes on the system.  Inevitably, this is
the most approximate of the measurements given.
.IP "User \s-1CPU\s0 Time" 4
.IX Item "User CPU Time"
The user time is the amount of time the entire process spent on behalf of the
user on this system executing this program.
.IP "System \s-1CPU\s0 Time" 4
.IX Item "System CPU Time"
The system time is the amount of time the kernel itself spent executing
routines, or system calls, on behalf of this process user.
.PP
Running this same process as a \f(CW\*(C`Schwarzian Transform\*(C'\fR it is possible to
eliminate the input and output arrays for storing all the data, and work on the
input directly as it arrives too.  Otherwise, the code looks fairly similar:
.PP
# sort-apache-log-schwarzian
.PP
.Vb 1
\&    #!/usr/bin/perl \-n
\&
\&    use strict;
\&    use warnings;
\&
\&    print
\&
\&        map $_\->[0] =>
\&
\&        sort {
\&            $a\->[4] cmp $b\->[4]
\&                    ||
\&            $a\->[3] cmp $b\->[3]
\&                    ||
\&            $a\->[1] cmp $b\->[1]
\&                    ||
\&            $a\->[2] cmp $b\->[2]
\&                    ||
\&            $a\->[5] cmp $b\->[5]
\&        }
\&        map  [ $_, m/^(
\&            ([\ew\e.\e\-]+)             # client
\&            \es*\-\es*\-\es*\e[
\&            ([^]]+)                 # date
\&            \e]\es*"\ew+\es*
\&            (\eS+)                   # query
\&            [^"]+"\es*
\&            (\ed+)                   # status
\&            \es+\eS+\es+"[^"]*"\es+"
\&            ([^"]*)                 # browser
\&            "
\&            .*
\&        )$/xo ]
\&
\&        => <>;
\&
\&    exit 0;
.Ve
.PP
Run the new code against the same logfile, as above, to check the new time.
.PP
.Vb 1
\&    $> time ./sort\-apache\-log\-schwarzian logfile > out\-schwarz
\&
\&    real    0m9.664s
\&    user    0m8.873s
\&    sys     0m0.704s
.Ve
.PP
The time has been cut in half, which is a respectable speed improvement by any
standard.  Naturally, it is important to check the output is consistent with
the first program run, this is where the Unix system \f(CW\*(C`cksum\*(C'\fR utility comes in.
.PP
.Vb 3
\&    $> cksum out\-sort out\-schwarz
\&    3044173777 52029194 out\-sort
\&    3044173777 52029194 out\-schwarz
.Ve
.PP
\&\s-1BTW\s0. Beware too of pressure from managers who see you speed a program up by 50%
of the runtime once, only to get a request one month later to do the same again
(true story) \- you'll just have to point out your only human, even if you are a
Perl programmer, and you'll see what you can do...
.SH "LOGGING"
.IX Header "LOGGING"
An essential part of any good development process is appropriate error handling
with appropriately informative messages, however there exists a school of
thought which suggests that log files should be \fIchatty\fR, as if the chain of
unbroken output somehow ensures the survival of the program.  If speed is in
any way an issue, this approach is wrong.
.PP
A common sight is code which looks something like this:
.PP
.Vb 1
\&    logger\->debug( "A logging message via process\-id: $$ INC: " . Dumper(\e%INC) )
.Ve
.PP
The problem is that this code will always be parsed and executed, even when the
debug level set in the logging configuration file is zero.  Once the \fIdebug()\fR
subroutine has been entered, and the internal \f(CW$debug\fR variable confirmed to
be zero, for example, the message which has been sent in will be discarded and
the program will continue.  In the example given though, the \e%INC hash will
already have been dumped, and the message string constructed, all of which work
could be bypassed by a debug variable at the statement level, like this:
.PP
.Vb 1
\&    logger\->debug( "A logging message via process\-id: $$ INC: " . Dumper(\e%INC) ) if $DEBUG;
.Ve
.PP
This effect can be demonstrated by setting up a test script with both forms,
including a \f(CW\*(C`debug()\*(C'\fR subroutine to emulate typical \f(CW\*(C`logger()\*(C'\fR functionality.
.PP
# ifdebug
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    use Benchmark;
\&    use Data::Dumper;
\&    my $DEBUG = 0;
\&
\&    sub debug {
\&        my $msg = shift;
\&
\&        if ( $DEBUG ) {
\&            print "DEBUG: $msg\en";
\&        }
\&    };
\&
\&    timethese(100000, {
\&            \*(Aqdebug\*(Aq       => sub {
\&                debug( "A $0 logging message via process\-id: $$" . Dumper(\e%INC) )
\&            },
\&            \*(Aqifdebug\*(Aq  => sub {
\&                debug( "A $0 logging message via process\-id: $$" . Dumper(\e%INC) ) if $DEBUG
\&            },
\&    });
.Ve
.PP
Let's see what \f(CW\*(C`Benchmark\*(C'\fR makes of this:
.PP
.Vb 5
\&    $> perl ifdebug
\&    Benchmark: timing 100000 iterations of constant, sub...
\&       ifdebug:  0 wallclock secs ( 0.01 usr +  0.00 sys =  0.01 CPU) @ 10000000.00/s (n=100000)
\&                (warning: too few iterations for a reliable count)
\&         debug: 14 wallclock secs (13.18 usr +  0.04 sys = 13.22 CPU) @ 7564.30/s (n=100000)
.Ve
.PP
In the one case the code, which does exactly the same thing as far as
outputting any debugging information is concerned, in other words nothing,
takes 14 seconds, and in the other case the code takes one hundredth of a
second.  Looks fairly definitive.  Use a \f(CW$DEBUG\fR variable \s-1BEFORE\s0 you call the
subroutine, rather than relying on the smart functionality inside it.
.SS "Logging if \s-1DEBUG\s0 (constant)"
.IX Subsection "Logging if DEBUG (constant)"
It's possible to take the previous idea a little further, by using a compile
time \f(CW\*(C`DEBUG\*(C'\fR constant.
.PP
# ifdebug-constant
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    use Benchmark;
\&    use Data::Dumper;
\&    use constant
\&        DEBUG => 0
\&    ;
\&
\&    sub debug {
\&        if ( DEBUG ) {
\&            my $msg = shift;
\&            print "DEBUG: $msg\en";
\&        }
\&    };
\&
\&    timethese(100000, {
\&            \*(Aqdebug\*(Aq       => sub {
\&                debug( "A $0 logging message via process\-id: $$" . Dumper(\e%INC) )
\&            },
\&            \*(Aqconstant\*(Aq  => sub {
\&                debug( "A $0 logging message via process\-id: $$" . Dumper(\e%INC) ) if DEBUG
\&            },
\&    });
.Ve
.PP
Running this program produces the following output:
.PP
.Vb 5
\&    $> perl ifdebug\-constant
\&    Benchmark: timing 100000 iterations of constant, sub...
\&      constant:  0 wallclock secs (\-0.00 usr +  0.00 sys = \-0.00 CPU) @ \-7205759403792793600000.00/s (n=100000)
\&                (warning: too few iterations for a reliable count)
\&           sub: 14 wallclock secs (13.09 usr +  0.00 sys = 13.09 CPU) @ 7639.42/s (n=100000)
.Ve
.PP
The \f(CW\*(C`DEBUG\*(C'\fR constant wipes the floor with even the \f(CW$debug\fR variable,
clocking in at minus zero seconds, and generates a \*(L"warning: too few iterations
for a reliable count\*(R" message into the bargain.  To see what is really going
on, and why we had too few iterations when we thought we asked for 100000, we
can use the very useful \f(CW\*(C`B::Deparse\*(C'\fR to inspect the new code:
.PP
.Vb 1
\&    $> perl \-MO=Deparse ifdebug\-constant
\&
\&    use Benchmark;
\&    use Data::Dumper;
\&    use constant (\*(AqDEBUG\*(Aq, 0);
\&    sub debug {
\&        use warnings;
\&        use strict \*(Aqrefs\*(Aq;
\&        0;
\&    }
\&    use warnings;
\&    use strict \*(Aqrefs\*(Aq;
\&    timethese(100000, {\*(Aqsub\*(Aq, sub {
\&        debug "A $0 logging message via process\-id: $$" . Dumper(\e%INC);
\&    }
\&    , \*(Aqconstant\*(Aq, sub {
\&        0;
\&    }
\&    });
\&    ifdebug\-constant syntax OK
.Ve
.PP
The output shows the \fIconstant()\fR subroutine we're testing being replaced with
the value of the \f(CW\*(C`DEBUG\*(C'\fR constant: zero.  The line to be tested has been
completely optimized away, and you can't get much more efficient than that.
.SH "POSTSCRIPT"
.IX Header "POSTSCRIPT"
This document has provided several way to go about identifying hot-spots, and
checking whether any modifications have improved the runtime of the code.
.PP
As a final thought, remember that it's not (at the time of writing) possible to
produce a useful program which will run in zero or negative time and this basic
principle can be written as: \fIuseful programs are slow\fR by their very
definition.  It is of course possible to write a nearly instantaneous program,
but it's not going to do very much, here's a very efficient one:
.PP
.Vb 1
\&    $> perl \-e 0
.Ve
.PP
Optimizing that any further is a job for \f(CW\*(C`p5p\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Further reading can be found using the modules and links below.
.SS "\s-1PERLDOCS\s0"
.IX Subsection "PERLDOCS"
For example: \f(CW\*(C`perldoc \-f sort\*(C'\fR.
.PP
perlfaq4.
.PP
perlfork, perlfunc, perlretut, perlthrtut.
.PP
threads.
.SS "\s-1MAN\s0 \s-1PAGES\s0"
.IX Subsection "MAN PAGES"
\&\f(CW\*(C`time\*(C'\fR.
.SS "\s-1MODULES\s0"
.IX Subsection "MODULES"
It's not possible to individually showcase all the performance related code for
Perl here, naturally, but here's a short list of modules from the \s-1CPAN\s0 which
deserve further attention.
.PP
.Vb 10
\&    Apache::DProf
\&    Apache::SmallProf
\&    Benchmark
\&    DBIx::Profile
\&    Devel::AutoProfiler
\&    Devel::DProf
\&    Devel::DProfLB
\&    Devel::FastProf
\&    Devel::GraphVizProf
\&    Devel::NYTProf
\&    Devel::NYTProf::Apache
\&    Devel::Profiler
\&    Devel::Profile
\&    Devel::Profit
\&    Devel::SmallProf
\&    Devel::WxProf
\&    POE::Devel::Profiler
\&    Sort::Key
\&    Sort::Maker
.Ve
.SS "\s-1URLS\s0"
.IX Subsection "URLS"
Very useful online reference material:
.PP
.Vb 1
\&    http://www.ccl4.org/~nick/P/Fast_Enough/
\&
\&    http://www\-128.ibm.com/developerworks/library/l\-optperl.html
\&
\&    http://perlbuzz.com/2007/11/bind\-output\-variables\-in\-dbi\-for\-speed\-and\-safety.html
\&
\&    http://en.wikipedia.org/wiki/Performance_analysis
\&
\&    http://apache.perl.org/docs/1.0/guide/performance.html
\&
\&    http://perlgolf.sourceforge.net/
\&
\&    http://www.sysarch.com/Perl/sort_paper.html
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Richard Foley <richard.foley@rfi.net> Copyright (c) 2008
                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlperf5.18.1                               0100644 0001750 0001750 00000166103 12566207443 023103  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPERF 1"
.TH PERLPERF 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlperf \- Perl Performance and Optimization Techniques
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is an introduction to the use of performance and optimization techniques
which can be used with particular reference to perl programs.  While many perl
developers have come from other languages, and can use their prior knowledge
where appropriate, there are many other people who might benefit from a few
perl specific pointers.  If you want the condensed version, perhaps the best
advice comes from the renowned Japanese Samurai, Miyamoto Musashi, who said:
.PP
.Vb 1
\&    "Do Not Engage in Useless Activity"
.Ve
.PP
in 1645.
.SH "OVERVIEW"
.IX Header "OVERVIEW"
Perhaps the most common mistake programmers make is to attempt to optimize
their code before a program actually does anything useful \- this is a bad idea.
There's no point in having an extremely fast program that doesn't work.  The
first job is to get a program to \fIcorrectly\fR do something \fBuseful\fR, (not to
mention ensuring the test suite is fully functional), and only then to consider
optimizing it.  Having decided to optimize existing working code, there are
several simple but essential steps to consider which are intrinsic to any
optimization process.
.SS "\s-1ONE STEP SIDEWAYS\s0"
.IX Subsection "ONE STEP SIDEWAYS"
Firstly, you need to establish a baseline time for the existing code, which
timing needs to be reliable and repeatable.  You'll probably want to use the
\&\f(CW\*(C`Benchmark\*(C'\fR or \f(CW\*(C`Devel::NYTProf\*(C'\fR modules, or something similar, for this step,
or perhaps the Unix system \f(CW\*(C`time\*(C'\fR utility, whichever is appropriate.  See the
base of this document for a longer list of benchmarking and profiling modules,
and recommended further reading.
.SS "\s-1ONE STEP FORWARD\s0"
.IX Subsection "ONE STEP FORWARD"
Next, having examined the program for \fIhot spots\fR, (places where the code
seems to run slowly), change the code with the intention of making it run
faster.  Using version control software, like \f(CW\*(C`subversion\*(C'\fR, will ensure no
changes are irreversible.  It's too easy to fiddle here and fiddle there \-
don't change too much at any one time or you might not discover which piece of
code \fBreally\fR was the slow bit.
.SS "\s-1ANOTHER STEP SIDEWAYS\s0"
.IX Subsection "ANOTHER STEP SIDEWAYS"
It's not enough to say: \*(L"that will make it run faster\*(R", you have to check it.
Rerun the code under control of the benchmarking or profiling modules, from the
first step above, and check that the new code executed the \fBsame task\fR in
\&\fIless time\fR.  Save your work and repeat...
.SH "GENERAL GUIDELINES"
.IX Header "GENERAL GUIDELINES"
The critical thing when considering performance is to remember there is no such
thing as a \f(CW\*(C`Golden Bullet\*(C'\fR, which is why there are no rules, only guidelines.
.PP
It is clear that inline code is going to be faster than subroutine or method
calls, because there is less overhead, but this approach has the disadvantage
of being less maintainable and comes at the cost of greater memory usage \-
there is no such thing as a free lunch.  If you are searching for an element in
a list, it can be more efficient to store the data in a hash structure, and
then simply look to see whether the key is defined, rather than to loop through
the entire array using \fIgrep()\fR for instance.  \fIsubstr()\fR may be (a lot) faster
than \fIgrep()\fR but not as flexible, so you have another trade-off to access.  Your
code may contain a line which takes 0.01 of a second to execute which if you
call it 1,000 times, quite likely in a program parsing even medium sized files
for instance, you already have a 10 second delay, in just one single code
location, and if you call that line 100,000 times, your entire program will
slow down to an unbearable crawl.
.PP
Using a subroutine as part of your sort is a powerful way to get exactly what
you want, but will usually be slower than the built-in \fIalphabetic\fR \f(CW\*(C`cmp\*(C'\fR and
\&\fInumeric\fR \f(CW\*(C`<=>\*(C'\fR sort operators.  It is possible to make multiple
passes over your data, building indices to make the upcoming sort more
efficient, and to use what is known as the \f(CW\*(C`OM\*(C'\fR (Orcish Maneuver) to cache the
sort keys in advance.  The cache lookup, while a good idea, can itself be a
source of slowdown by enforcing a double pass over the data \- once to setup the
cache, and once to sort the data.  Using \f(CW\*(C`pack()\*(C'\fR to extract the required sort
key into a consistent string can be an efficient way to build a single string
to compare, instead of using multiple sort keys, which makes it possible to use
the standard, written in \f(CW\*(C`c\*(C'\fR and fast, perl \f(CW\*(C`sort()\*(C'\fR function on the output,
and is the basis of the \f(CW\*(C`GRT\*(C'\fR (Guttman Rossler Transform).  Some string
combinations can slow the \f(CW\*(C`GRT\*(C'\fR down, by just being too plain complex for it's
own good.
.PP
For applications using database backends, the standard \f(CW\*(C`DBIx\*(C'\fR namespace has
tries to help with keeping things nippy, not least because it tries to \fInot\fR
query the database until the latest possible moment, but always read the docs
which come with your choice of libraries.  Among the many issues facing
developers dealing with databases should remain aware of is to always use
\&\f(CW\*(C`SQL\*(C'\fR placeholders and to consider pre-fetching data sets when this might
prove advantageous.  Splitting up a large file by assigning multiple processes
to parsing a single file, using say \f(CW\*(C`POE\*(C'\fR, \f(CW\*(C`threads\*(C'\fR or \f(CW\*(C`fork\*(C'\fR can also be a
useful way of optimizing your usage of the available \f(CW\*(C`CPU\*(C'\fR resources, though
this technique is fraught with concurrency issues and demands high attention to
detail.
.PP
Every case has a specific application and one or more exceptions, and there is
no replacement for running a few tests and finding out which method works best
for your particular environment, this is why writing optimal code is not an
exact science, and why we love using Perl so much \- \s-1TMTOWTDI.\s0
.SH "BENCHMARKS"
.IX Header "BENCHMARKS"
Here are a few examples to demonstrate usage of Perl's benchmarking tools.
.SS "Assigning and Dereferencing Variables."
.IX Subsection "Assigning and Dereferencing Variables."
I'm sure most of us have seen code which looks like, (or worse than), this:
.PP
.Vb 2
\&    if ( $obj\->{_ref}\->{_myscore} >= $obj\->{_ref}\->{_yourscore} ) {
\&        ...
.Ve
.PP
This sort of code can be a real eyesore to read, as well as being very
sensitive to typos, and it's much clearer to dereference the variable
explicitly.  We're side-stepping the issue of working with object-oriented
programming techniques to encapsulate variable access via methods, only
accessible through an object.  Here we're just discussing the technical
implementation of choice, and whether this has an effect on performance.  We
can see whether this dereferencing operation, has any overhead by putting
comparative code in a file and running a \f(CW\*(C`Benchmark\*(C'\fR test.
.PP
# dereference
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    use Benchmark;
\&
\&    my $ref = {
\&            \*(Aqref\*(Aq   => {
\&                _myscore    => \*(Aq100 + 1\*(Aq,
\&                _yourscore  => \*(Aq102 \- 1\*(Aq,
\&            },
\&    };
\&
\&    timethese(1000000, {
\&            \*(Aqdirect\*(Aq       => sub {
\&                my $x = $ref\->{ref}\->{_myscore} . $ref\->{ref}\->{_yourscore} ;
\&            },
\&            \*(Aqdereference\*(Aq  => sub {
\&                my $ref  = $ref\->{ref};
\&                my $myscore = $ref\->{_myscore};
\&                my $yourscore = $ref\->{_yourscore};
\&                my $x = $myscore . $yourscore;
\&            },
\&    });
.Ve
.PP
It's essential to run any timing measurements a sufficient number of times so
the numbers settle on a numerical average, otherwise each run will naturally
fluctuate due to variations in the environment, to reduce the effect of
contention for \f(CW\*(C`CPU\*(C'\fR resources and network bandwidth for instance.  Running
the above code for one million iterations, we can take a look at the report
output by the \f(CW\*(C`Benchmark\*(C'\fR module, to see which approach is the most effective.
.PP
.Vb 1
\&    $> perl dereference
\&
\&    Benchmark: timing 1000000 iterations of dereference, direct...
\&    dereference:  2 wallclock secs ( 1.59 usr +  0.00 sys =  1.59 CPU) @ 628930.82/s (n=1000000)
\&        direct:  1 wallclock secs ( 1.20 usr +  0.00 sys =  1.20 CPU) @ 833333.33/s (n=1000000)
.Ve
.PP
The difference is clear to see and the dereferencing approach is slower.  While
it managed to execute an average of 628,930 times a second during our test, the
direct approach managed to run an additional 204,403 times, unfortunately.
Unfortunately, because there are many examples of code written using the
multiple layer direct variable access, and it's usually horrible.  It is,
however, minusculy faster.  The question remains whether the minute gain is
actually worth the eyestrain, or the loss of maintainability.
.SS "Search and replace or tr"
.IX Subsection "Search and replace or tr"
If we have a string which needs to be modified, while a regex will almost
always be much more flexible, \f(CW\*(C`tr\*(C'\fR, an oft underused tool, can still be a
useful.  One scenario might be replace all vowels with another character.  The
regex solution might look like this:
.PP
.Vb 1
\&    $str =~ s/[aeiou]/x/g
.Ve
.PP
The \f(CW\*(C`tr\*(C'\fR alternative might look like this:
.PP
.Vb 1
\&    $str =~ tr/aeiou/xxxxx/
.Ve
.PP
We can put that into a test file which we can run to check which approach is
the fastest, using a global \f(CW$STR\fR variable to assign to the \f(CW\*(C`my $str\*(C'\fR
variable so as to avoid perl trying to optimize any of the work away by
noticing it's assigned only the once.
.PP
# regex-transliterate
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    use Benchmark;
\&
\&    my $STR = "$$\-this and that";
\&
\&    timethese( 1000000, {
\&            \*(Aqsr\*(Aq  => sub { my $str = $STR; $str =~ s/[aeiou]/x/g; return $str; },
\&            \*(Aqtr\*(Aq  => sub { my $str = $STR; $str =~ tr/aeiou/xxxxx/; return $str; },
\&    });
.Ve
.PP
Running the code gives us our results:
.PP
.Vb 1
\&    $> perl regex\-transliterate
\&
\&    Benchmark: timing 1000000 iterations of sr, tr...
\&            sr:  2 wallclock secs ( 1.19 usr +  0.00 sys =  1.19 CPU) @ 840336.13/s (n=1000000)
\&            tr:  0 wallclock secs ( 0.49 usr +  0.00 sys =  0.49 CPU) @ 2040816.33/s (n=1000000)
.Ve
.PP
The \f(CW\*(C`tr\*(C'\fR version is a clear winner.  One solution is flexible, the other is
fast \- and it's appropriately the programmer's choice which to use.
.PP
Check the \f(CW\*(C`Benchmark\*(C'\fR docs for further useful techniques.
.SH "PROFILING TOOLS"
.IX Header "PROFILING TOOLS"
A slightly larger piece of code will provide something on which a profiler can
produce more extensive reporting statistics.  This example uses the simplistic
\&\f(CW\*(C`wordmatch\*(C'\fR program which parses a given input file and spews out a short
report on the contents.
.PP
# wordmatch
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    =head1 NAME
\&
\&    filewords \- word analysis of input file
\&
\&    =head1 SYNOPSIS
\&
\&        filewords \-f inputfilename [\-d]
\&
\&    =head1 DESCRIPTION
\&
\&    This program parses the given filename, specified with C<\-f>, and displays a
\&    simple analysis of the words found therein.  Use the C<\-d> switch to enable
\&    debugging messages.
\&
\&    =cut
\&
\&    use FileHandle;
\&    use Getopt::Long;
\&
\&    my $debug   =  0;
\&    my $file    = \*(Aq\*(Aq;
\&
\&    my $result = GetOptions (
\&        \*(Aqdebug\*(Aq         => \e$debug,
\&        \*(Aqfile=s\*(Aq        => \e$file,
\&    );
\&    die("invalid args") unless $result;
\&
\&    unless ( \-f $file ) {
\&        die("Usage: $0 \-f filename [\-d]");
\&    }
\&    my $FH = FileHandle\->new("< $file") or die("unable to open file($file): $!");
\&
\&    my $i_LINES = 0;
\&    my $i_WORDS = 0;
\&    my %count   = ();
\&
\&    my @lines = <$FH>;
\&    foreach my $line ( @lines ) {
\&        $i_LINES++;
\&        $line =~ s/\en//;
\&        my @words = split(/ +/, $line);
\&        my $i_words = scalar(@words);
\&        $i_WORDS = $i_WORDS + $i_words;
\&        debug("line: $i_LINES supplying $i_words words: @words");
\&        my $i_word = 0;
\&        foreach my $word ( @words ) {
\&            $i_word++;
\&            $count{$i_LINES}{spec} += matches($i_word, $word, \*(Aq[^a\-zA\-Z0\-9]\*(Aq);
\&            $count{$i_LINES}{only} += matches($i_word, $word, \*(Aq^[^a\-zA\-Z0\-9]+$\*(Aq);
\&            $count{$i_LINES}{cons} += matches($i_word, $word, \*(Aq^[(?i:bcdfghjklmnpqrstvwxyz)]+$\*(Aq);
\&            $count{$i_LINES}{vows} += matches($i_word, $word, \*(Aq^[(?i:aeiou)]+$\*(Aq);
\&            $count{$i_LINES}{caps} += matches($i_word, $word, \*(Aq^[(A\-Z)]+$\*(Aq);
\&        }
\&    }
\&
\&    print report( %count );
\&
\&    sub matches {
\&        my $i_wd  = shift;
\&        my $word  = shift;
\&        my $regex = shift;
\&        my $has = 0;
\&
\&        if ( $word =~ /($regex)/ ) {
\&            $has++ if $1;
\&        }
\&
\&        debug("word: $i_wd ".($has ? \*(Aqmatches\*(Aq : \*(Aqdoes not match\*(Aq)." chars: /$regex/");
\&
\&        return $has;
\&    }
\&
\&    sub report {
\&        my %report = @_;
\&        my %rep;
\&
\&        foreach my $line ( keys %report ) {
\&            foreach my $key ( keys %{ $report{$line} } ) {
\&                $rep{$key} += $report{$line}{$key};
\&            }
\&        }
\&
\&        my $report = qq|
\&    $0 report for $file:
\&    lines in file: $i_LINES
\&    words in file: $i_WORDS
\&    words with special (non\-word) characters: $i_spec
\&    words with only special (non\-word) characters: $i_only
\&    words with only consonants: $i_cons
\&    words with only capital letters: $i_caps
\&    words with only vowels: $i_vows
\&    |;
\&
\&        return $report;
\&    }
\&
\&    sub debug {
\&        my $message = shift;
\&
\&        if ( $debug ) {
\&            print STDERR "DBG: $message\en";
\&        }
\&    }
\&
\&    exit 0;
.Ve
.SS "Devel::DProf"
.IX Subsection "Devel::DProf"
This venerable module has been the de-facto standard for Perl code profiling
for more than a decade, but has been replaced by a number of other modules
which have brought us back to the 21st century.  Although you're recommended to
evaluate your tool from the several mentioned here and from the \s-1CPAN\s0 list at
the base of this document, (and currently Devel::NYTProf seems to be the
weapon of choice \- see below), we'll take a quick look at the output from
Devel::DProf first, to set a baseline for Perl profiling tools.  Run the
above program under the control of \f(CW\*(C`Devel::DProf\*(C'\fR by using the \f(CW\*(C`\-d\*(C'\fR switch on
the command-line.
.PP
.Vb 1
\&    $> perl \-d:DProf wordmatch \-f perl5db.pl
\&
\&    <...multiple lines snipped...>
\&
\&    wordmatch report for perl5db.pl:
\&    lines in file: 9428
\&    words in file: 50243
\&    words with special (non\-word) characters: 20480
\&    words with only special (non\-word) characters: 7790
\&    words with only consonants: 4801
\&    words with only capital letters: 1316
\&    words with only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`Devel::DProf\*(C'\fR produces a special file, called \fItmon.out\fR by default, and
this file is read by the \f(CW\*(C`dprofpp\*(C'\fR program, which is already installed as part
of the \f(CW\*(C`Devel::DProf\*(C'\fR distribution.  If you call \f(CW\*(C`dprofpp\*(C'\fR with no options,
it will read the \fItmon.out\fR file in the current directory and produce a human
readable statistics report of the run of your program.  Note that this may take
a little time.
.PP
.Vb 1
\&    $> dprofpp
\&
\&    Total Elapsed Time = 2.951677 Seconds
\&      User+System Time = 2.871677 Seconds
\&    Exclusive Times
\&    %Time ExclSec CumulS #Calls sec/call Csec/c  Name
\&     102.   2.945  3.003 251215   0.0000 0.0000  main::matches
\&     2.40   0.069  0.069 260643   0.0000 0.0000  main::debug
\&     1.74   0.050  0.050      1   0.0500 0.0500  main::report
\&     1.04   0.030  0.049      4   0.0075 0.0123  main::BEGIN
\&     0.35   0.010  0.010      3   0.0033 0.0033  Exporter::as_heavy
\&     0.35   0.010  0.010      7   0.0014 0.0014  IO::File::BEGIN
\&     0.00       \- \-0.000      1        \-      \-  Getopt::Long::FindOption
\&     0.00       \- \-0.000      1        \-      \-  Symbol::BEGIN
\&     0.00       \- \-0.000      1        \-      \-  Fcntl::BEGIN
\&     0.00       \- \-0.000      1        \-      \-  Fcntl::bootstrap
\&     0.00       \- \-0.000      1        \-      \-  warnings::BEGIN
\&     0.00       \- \-0.000      1        \-      \-  IO::bootstrap
\&     0.00       \- \-0.000      1        \-      \-  Getopt::Long::ConfigDefaults
\&     0.00       \- \-0.000      1        \-      \-  Getopt::Long::Configure
\&     0.00       \- \-0.000      1        \-      \-  Symbol::gensym
.Ve
.PP
\&\f(CW\*(C`dprofpp\*(C'\fR will produce some quite detailed reporting on the activity of the
\&\f(CW\*(C`wordmatch\*(C'\fR program.  The wallclock, user and system, times are at the top of
the analysis, and after this are the main columns defining which define the
report.  Check the \f(CW\*(C`dprofpp\*(C'\fR docs for details of the many options it supports.
.PP
See also \f(CW\*(C`Apache::DProf\*(C'\fR which hooks \f(CW\*(C`Devel::DProf\*(C'\fR into \f(CW\*(C`mod_perl\*(C'\fR.
.SS "Devel::Profiler"
.IX Subsection "Devel::Profiler"
Let's take a look at the same program using a different profiler:
\&\f(CW\*(C`Devel::Profiler\*(C'\fR, a drop-in Perl-only replacement for \f(CW\*(C`Devel::DProf\*(C'\fR.  The
usage is very slightly different in that instead of using the special \f(CW\*(C`\-d:\*(C'\fR
flag, you pull \f(CW\*(C`Devel::Profiler\*(C'\fR in directly as a module using \f(CW\*(C`\-M\*(C'\fR.
.PP
.Vb 1
\&    $> perl \-MDevel::Profiler wordmatch \-f perl5db.pl
\&
\&    <...multiple lines snipped...>
\&
\&    wordmatch report for perl5db.pl:
\&    lines in file: 9428
\&    words in file: 50243
\&    words with special (non\-word) characters: 20480
\&    words with only special (non\-word) characters: 7790
\&    words with only consonants: 4801
\&    words with only capital letters: 1316
\&    words with only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`Devel::Profiler\*(C'\fR generates a tmon.out file which is compatible with the
\&\f(CW\*(C`dprofpp\*(C'\fR program, thus saving the construction of a dedicated statistics
reader program.  \f(CW\*(C`dprofpp\*(C'\fR usage is therefore identical to the above example.
.PP
.Vb 1
\&    $> dprofpp
\&
\&    Total Elapsed Time =   20.984 Seconds
\&      User+System Time =   19.981 Seconds
\&    Exclusive Times
\&    %Time ExclSec CumulS #Calls sec/call Csec/c  Name
\&     49.0   9.792 14.509 251215   0.0000 0.0001  main::matches
\&     24.4   4.887  4.887 260643   0.0000 0.0000  main::debug
\&     0.25   0.049  0.049      1   0.0490 0.0490  main::report
\&     0.00   0.000  0.000      1   0.0000 0.0000  Getopt::Long::GetOptions
\&     0.00   0.000  0.000      2   0.0000 0.0000  Getopt::Long::ParseOptionSpec
\&     0.00   0.000  0.000      1   0.0000 0.0000  Getopt::Long::FindOption
\&     0.00   0.000  0.000      1   0.0000 0.0000  IO::File::new
\&     0.00   0.000  0.000      1   0.0000 0.0000  IO::Handle::new
\&     0.00   0.000  0.000      1   0.0000 0.0000  Symbol::gensym
\&     0.00   0.000  0.000      1   0.0000 0.0000  IO::File::open
.Ve
.PP
Interestingly we get slightly different results, which is mostly because the
algorithm which generates the report is different, even though the output file
format was allegedly identical.  The elapsed, user and system times are clearly
showing the time it took for \f(CW\*(C`Devel::Profiler\*(C'\fR to execute its own run, but
the column listings feel more accurate somehow than the ones we had earlier
from \f(CW\*(C`Devel::DProf\*(C'\fR.  The 102% figure has disappeared, for example.  This is
where we have to use the tools at our disposal, and recognise their pros and
cons, before using them.  Interestingly, the numbers of calls for each
subroutine are identical in the two reports, it's the percentages which differ.
As the author of \f(CW\*(C`Devel::Proviler\*(C'\fR writes:
.PP
.Vb 5
\&    ...running HTML::Template\*(Aqs test suite under Devel::DProf shows output()
\&    taking NO time but Devel::Profiler shows around 10% of the time is in output().
\&    I don\*(Aqt know which to trust but my gut tells me something is wrong with
\&    Devel::DProf.  HTML::Template::output() is a big routine that\*(Aqs called for
\&    every test. Either way, something needs fixing.
.Ve
.PP
\&\s-1YMMV.\s0
.PP
See also \f(CW\*(C`Devel::Apache::Profiler\*(C'\fR which hooks \f(CW\*(C`Devel::Profiler\*(C'\fR into \f(CW\*(C`mod_perl\*(C'\fR.
.SS "Devel::SmallProf"
.IX Subsection "Devel::SmallProf"
The \f(CW\*(C`Devel::SmallProf\*(C'\fR profiler examines the runtime of your Perl program and
produces a line-by-line listing to show how many times each line was called,
and how long each line took to execute.  It is called by supplying the familiar
\&\f(CW\*(C`\-d\*(C'\fR flag to Perl at runtime.
.PP
.Vb 1
\&    $> perl \-d:SmallProf wordmatch \-f perl5db.pl
\&
\&    <...multiple lines snipped...>
\&
\&    wordmatch report for perl5db.pl:
\&    lines in file: 9428
\&    words in file: 50243
\&    words with special (non\-word) characters: 20480
\&    words with only special (non\-word) characters: 7790
\&    words with only consonants: 4801
\&    words with only capital letters: 1316
\&    words with only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`Devel::SmallProf\*(C'\fR writes it's output into a file called \fIsmallprof.out\fR, by
default.  The format of the file looks like this:
.PP
.Vb 1
\&    <num> <time> <ctime> <line>:<text>
.Ve
.PP
When the program has terminated, the output may be examined and sorted using
any standard text filtering utilities.  Something like the following may be
sufficient:
.PP
.Vb 1
\&    $> cat smallprof.out | grep \ed*: | sort \-k3 | tac | head \-n20
\&
\&    251215   1.65674   7.68000    75: if ( $word =~ /($regex)/ ) {
\&    251215   0.03264   4.40000    79: debug("word: $i_wd ".($has ? \*(Aqmatches\*(Aq :
\&    251215   0.02693   4.10000    81: return $has;
\&    260643   0.02841   4.07000   128: if ( $debug ) {
\&    260643   0.02601   4.04000   126: my $message = shift;
\&    251215   0.02641   3.91000    73: my $has = 0;
\&    251215   0.03311   3.71000    70: my $i_wd  = shift;
\&    251215   0.02699   3.69000    72: my $regex = shift;
\&    251215   0.02766   3.68000    71: my $word  = shift;
\&     50243   0.59726   1.00000    59:  $count{$i_LINES}{cons} =
\&     50243   0.48175   0.92000    61:  $count{$i_LINES}{spec} =
\&     50243   0.00644   0.89000    56:  my $i_cons = matches($i_word, $word,
\&     50243   0.48837   0.88000    63:  $count{$i_LINES}{caps} =
\&     50243   0.00516   0.88000    58:  my $i_caps = matches($i_word, $word, \*(Aq^[(A\-
\&     50243   0.00631   0.81000    54:  my $i_spec = matches($i_word, $word, \*(Aq[^a\-
\&     50243   0.00496   0.80000    57:  my $i_vows = matches($i_word, $word,
\&     50243   0.00688   0.80000    53:  $i_word++;
\&     50243   0.48469   0.79000    62:  $count{$i_LINES}{only} =
\&     50243   0.48928   0.77000    60:  $count{$i_LINES}{vows} =
\&     50243   0.00683   0.75000    55:  my $i_only = matches($i_word, $word, \*(Aq^[^a\-
.Ve
.PP
You can immediately see a slightly different focus to the subroutine profiling
modules, and we start to see exactly which line of code is taking the most
time.  That regex line is looking a bit suspicious, for example.  Remember that
these tools are supposed to be used together, there is no single best way to
profile your code, you need to use the best tools for the job.
.PP
See also \f(CW\*(C`Apache::SmallProf\*(C'\fR which hooks \f(CW\*(C`Devel::SmallProf\*(C'\fR into \f(CW\*(C`mod_perl\*(C'\fR.
.SS "Devel::FastProf"
.IX Subsection "Devel::FastProf"
\&\f(CW\*(C`Devel::FastProf\*(C'\fR is another Perl line profiler.  This was written with a view
to getting a faster line profiler, than is possible with for example
\&\f(CW\*(C`Devel::SmallProf\*(C'\fR, because it's written in \f(CW\*(C`C\*(C'\fR.  To use \f(CW\*(C`Devel::FastProf\*(C'\fR,
supply the \f(CW\*(C`\-d\*(C'\fR argument to Perl:
.PP
.Vb 1
\&    $> perl \-d:FastProf wordmatch \-f perl5db.pl
\&
\&    <...multiple lines snipped...>
\&
\&    wordmatch report for perl5db.pl:
\&    lines in file: 9428
\&    words in file: 50243
\&    words with special (non\-word) characters: 20480
\&    words with only special (non\-word) characters: 7790
\&    words with only consonants: 4801
\&    words with only capital letters: 1316
\&    words with only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`Devel::FastProf\*(C'\fR writes statistics to the file \fIfastprof.out\fR in the current
directory.  The output file, which can be specified, can be interpreted by using
the \f(CW\*(C`fprofpp\*(C'\fR command-line program.
.PP
.Vb 1
\&    $> fprofpp | head \-n20
\&
\&    # fprofpp output format is:
\&    # filename:line time count: source
\&    wordmatch:75 3.93338 251215: if ( $word =~ /($regex)/ ) {
\&    wordmatch:79 1.77774 251215: debug("word: $i_wd ".($has ? \*(Aqmatches\*(Aq : \*(Aqdoes not match\*(Aq)." chars: /$regex/");
\&    wordmatch:81 1.47604 251215: return $has;
\&    wordmatch:126 1.43441 260643: my $message = shift;
\&    wordmatch:128 1.42156 260643: if ( $debug ) {
\&    wordmatch:70 1.36824 251215: my $i_wd  = shift;
\&    wordmatch:71 1.36739 251215: my $word  = shift;
\&    wordmatch:72 1.35939 251215: my $regex = shift;
.Ve
.PP
Straightaway we can see that the number of times each line has been called is
identical to the \f(CW\*(C`Devel::SmallProf\*(C'\fR output, and the sequence is only very
slightly different based on the ordering of the amount of time each line took
to execute, \f(CW\*(C`if ( $debug ) { \*(C'\fR and \f(CW\*(C`my $message = shift;\*(C'\fR, for example.  The
differences in the actual times recorded might be in the algorithm used
internally, or it could be due to system resource limitations or contention.
.PP
See also the DBIx::Profile which will profile database queries running
under the \f(CW\*(C`DBIx::*\*(C'\fR namespace.
.SS "Devel::NYTProf"
.IX Subsection "Devel::NYTProf"
\&\f(CW\*(C`Devel::NYTProf\*(C'\fR is the \fBnext generation\fR of Perl code profiler, fixing many
shortcomings in other tools and implementing many cool features.  First of all it
can be used as either a \fIline\fR profiler, a \fIblock\fR or a \fIsubroutine\fR
profiler, all at once.  It can also use sub-microsecond (100ns) resolution on
systems which provide \f(CW\*(C`clock_gettime()\*(C'\fR.  It can be started and stopped even
by the program being profiled.  It's a one-line entry to profile \f(CW\*(C`mod_perl\*(C'\fR
applications.  It's written in \f(CW\*(C`c\*(C'\fR and is probably the fastest profiler
available for Perl.  The list of coolness just goes on.  Enough of that, let's
see how to it works \- just use the familiar \f(CW\*(C`\-d\*(C'\fR switch to plug it in and run
the code.
.PP
.Vb 1
\&    $> perl \-d:NYTProf wordmatch \-f perl5db.pl
\&
\&    wordmatch report for perl5db.pl:
\&    lines in file: 9427
\&    words in file: 50243
\&    words with special (non\-word) characters: 20480
\&    words with only special (non\-word) characters: 7790
\&    words with only consonants: 4801
\&    words with only capital letters: 1316
\&    words with only vowels: 1701
.Ve
.PP
\&\f(CW\*(C`NYTProf\*(C'\fR will generate a report database into the file \fInytprof.out\fR by
default.  Human readable reports can be generated from here by using the
supplied \f(CW\*(C`nytprofhtml\*(C'\fR (\s-1HTML\s0 output) and \f(CW\*(C`nytprofcsv\*(C'\fR (\s-1CSV\s0 output) programs.
We've used the Unix system \f(CW\*(C`html2text\*(C'\fR utility to convert the
\&\fInytprof/index.html\fR file for convenience here.
.PP
.Vb 1
\&    $> html2text nytprof/index.html
\&
\&    Performance Profile Index
\&    For wordmatch
\&      Run on Fri Sep 26 13:46:39 2008
\&    Reported on Fri Sep 26 13:47:23 2008
\&
\&             Top 15 Subroutines \-\- ordered by exclusive time
\&    |Calls |P |F |Inclusive|Exclusive|Subroutine                          |
\&    |      |  |  |Time     |Time     |                                    |
\&    |251215|5 |1 |13.09263 |10.47692 |main::              |matches        |
\&    |260642|2 |1 |2.71199  |2.71199  |main::              |debug          |
\&    |1     |1 |1 |0.21404  |0.21404  |main::              |report         |
\&    |2     |2 |2 |0.00511  |0.00511  |XSLoader::          |load (xsub)    |
\&    |14    |14|7 |0.00304  |0.00298  |Exporter::          |import         |
\&    |3     |1 |1 |0.00265  |0.00254  |Exporter::          |as_heavy       |
\&    |10    |10|4 |0.00140  |0.00140  |vars::              |import         |
\&    |13    |13|1 |0.00129  |0.00109  |constant::          |import         |
\&    |1     |1 |1 |0.00360  |0.00096  |FileHandle::        |import         |
\&    |3     |3 |3 |0.00086  |0.00074  |warnings::register::|import         |
\&    |9     |3 |1 |0.00036  |0.00036  |strict::            |bits           |
\&    |13    |13|13|0.00032  |0.00029  |strict::            |import         |
\&    |2     |2 |2 |0.00020  |0.00020  |warnings::          |import         |
\&    |2     |1 |1 |0.00020  |0.00020  |Getopt::Long::      |ParseOptionSpec|
\&    |7     |7 |6 |0.00043  |0.00020  |strict::            |unimport       |
\&
\&    For more information see the full list of 189 subroutines.
.Ve
.PP
The first part of the report already shows the critical information regarding
which subroutines are using the most time.  The next gives some statistics
about the source files profiled.
.PP
.Vb 10
\&            Source Code Files \-\- ordered by exclusive time then name
\&    |Stmts  |Exclusive|Avg.   |Reports                     |Source File         |
\&    |       |Time     |       |                            |                    |
\&    |2699761|15.66654 |6e\-06  |line   .    block   .    sub|wordmatch           |
\&    |35     |0.02187  |0.00062|line   .    block   .    sub|IO/Handle.pm        |
\&    |274    |0.01525  |0.00006|line   .    block   .    sub|Getopt/Long.pm      |
\&    |20     |0.00585  |0.00029|line   .    block   .    sub|Fcntl.pm            |
\&    |128    |0.00340  |0.00003|line   .    block   .    sub|Exporter/Heavy.pm   |
\&    |42     |0.00332  |0.00008|line   .    block   .    sub|IO/File.pm          |
\&    |261    |0.00308  |0.00001|line   .    block   .    sub|Exporter.pm         |
\&    |323    |0.00248  |8e\-06  |line   .    block   .    sub|constant.pm         |
\&    |12     |0.00246  |0.00021|line   .    block   .    sub|File/Spec/Unix.pm   |
\&    |191    |0.00240  |0.00001|line   .    block   .    sub|vars.pm             |
\&    |77     |0.00201  |0.00003|line   .    block   .    sub|FileHandle.pm       |
\&    |12     |0.00198  |0.00016|line   .    block   .    sub|Carp.pm             |
\&    |14     |0.00175  |0.00013|line   .    block   .    sub|Symbol.pm           |
\&    |15     |0.00130  |0.00009|line   .    block   .    sub|IO.pm               |
\&    |22     |0.00120  |0.00005|line   .    block   .    sub|IO/Seekable.pm      |
\&    |198    |0.00085  |4e\-06  |line   .    block   .    sub|warnings/register.pm|
\&    |114    |0.00080  |7e\-06  |line   .    block   .    sub|strict.pm           |
\&    |47     |0.00068  |0.00001|line   .    block   .    sub|warnings.pm         |
\&    |27     |0.00054  |0.00002|line   .    block   .    sub|overload.pm         |
\&    |9      |0.00047  |0.00005|line   .    block   .    sub|SelectSaver.pm      |
\&    |13     |0.00045  |0.00003|line   .    block   .    sub|File/Spec.pm        |
\&    |2701595|15.73869 |       |Total                       |
\&    |128647 |0.74946  |       |Average                     |
\&    |       |0.00201  |0.00003|Median                      |
\&    |       |0.00121  |0.00003|Deviation                   |
\&
\&    Report produced by the NYTProf 2.03 Perl profiler, developed by Tim Bunce and
\&    Adam Kaplan.
.Ve
.PP
At this point, if you're using the \fIhtml\fR report, you can click through the
various links to bore down into each subroutine and each line of code.  Because
we're using the text reporting here, and there's a whole directory full of
reports built for each source file, we'll just display a part of the
corresponding \fIwordmatch\-line.html\fR file, sufficient to give an idea of the
sort of output you can expect from this cool tool.
.PP
.Vb 1
\&    $> html2text nytprof/wordmatch\-line.html
\&
\&    Performance Profile \-\- \-block view\-.\-line view\-.\-sub view\-
\&    For wordmatch
\&    Run on Fri Sep 26 13:46:39 2008
\&    Reported on Fri Sep 26 13:47:22 2008
\&
\&    File wordmatch
\&
\&     Subroutines \-\- ordered by exclusive time
\&    |Calls |P|F|Inclusive|Exclusive|Subroutine    |
\&    |      | | |Time     |Time     |              |
\&    |251215|5|1|13.09263 |10.47692 |main::|matches|
\&    |260642|2|1|2.71199  |2.71199  |main::|debug  |
\&    |1     |1|1|0.21404  |0.21404  |main::|report |
\&    |0     |0|0|0        |0        |main::|BEGIN  |
\&
\&
\&    |Line|Stmts.|Exclusive|Avg.   |Code                                           |
\&    |    |      |Time     |       |                                               |
\&    |1   |      |         |       |#!/usr/bin/perl                                |
\&    |2   |      |         |       |                                               |
\&    |    |      |         |       |use strict;                                    |
\&    |3   |3     |0.00086  |0.00029|# spent 0.00003s making 1 calls to strict::    |
\&    |    |      |         |       |import                                         |
\&    |    |      |         |       |use warnings;                                  |
\&    |4   |3     |0.01563  |0.00521|# spent 0.00012s making 1 calls to warnings::  |
\&    |    |      |         |       |import                                         |
\&    |5   |      |         |       |                                               |
\&    |6   |      |         |       |=head1 NAME                                    |
\&    |7   |      |         |       |                                               |
\&    |8   |      |         |       |filewords \- word analysis of input file        |
\&    <...snip...>
\&    |62  |1     |0.00445  |0.00445|print report( %count );                        |
\&    |    |      |         |       |# spent 0.21404s making 1 calls to main::report|
\&    |63  |      |         |       |                                               |
\&    |    |      |         |       |# spent 23.56955s (10.47692+2.61571) within    |
\&    |    |      |         |       |main::matches which was called 251215 times,   |
\&    |    |      |         |       |avg 0.00005s/call: # 50243 times               |
\&    |    |      |         |       |(2.12134+0.51939s) at line 57 of wordmatch, avg|
\&    |    |      |         |       |0.00005s/call # 50243 times (2.17735+0.54550s) |
\&    |64  |      |         |       |at line 56 of wordmatch, avg 0.00005s/call #   |
\&    |    |      |         |       |50243 times (2.10992+0.51797s) at line 58 of   |
\&    |    |      |         |       |wordmatch, avg 0.00005s/call # 50243 times     |
\&    |    |      |         |       |(2.12696+0.51598s) at line 55 of wordmatch, avg|
\&    |    |      |         |       |0.00005s/call # 50243 times (1.94134+0.51687s) |
\&    |    |      |         |       |at line 54 of wordmatch, avg 0.00005s/call     |
\&    |    |      |         |       |sub matches {                                  |
\&    <...snip...>
\&    |102 |      |         |       |                                               |
\&    |    |      |         |       |# spent 2.71199s within main::debug which was  |
\&    |    |      |         |       |called 260642 times, avg 0.00001s/call: #      |
\&    |    |      |         |       |251215 times (2.61571+0s) by main::matches at  |
\&    |103 |      |         |       |line 74 of wordmatch, avg 0.00001s/call # 9427 |
\&    |    |      |         |       |times (0.09628+0s) at line 50 of wordmatch, avg|
\&    |    |      |         |       |0.00001s/call                                  |
\&    |    |      |         |       |sub debug {                                    |
\&    |104 |260642|0.58496  |2e\-06  |my $message = shift;                           |
\&    |105 |      |         |       |                                               |
\&    |106 |260642|1.09917  |4e\-06  |if ( $debug ) {                                |
\&    |107 |      |         |       |print STDERR "DBG: $message\en";                |
\&    |108 |      |         |       |}                                              |
\&    |109 |      |         |       |}                                              |
\&    |110 |      |         |       |                                               |
\&    |111 |1     |0.01501  |0.01501|exit 0;                                        |
\&    |112 |      |         |       |                                               |
.Ve
.PP
Oodles of very useful information in there \- this seems to be the way forward.
.PP
See also \f(CW\*(C`Devel::NYTProf::Apache\*(C'\fR which hooks \f(CW\*(C`Devel::NYTProf\*(C'\fR into \f(CW\*(C`mod_perl\*(C'\fR.
.SH "SORTING"
.IX Header "SORTING"
Perl modules are not the only tools a performance analyst has at their
disposal, system tools like \f(CW\*(C`time\*(C'\fR should not be overlooked as the next
example shows, where we take a quick look at sorting.  Many books, theses and
articles, have been written about efficient sorting algorithms, and this is not
the place to repeat such work, there's several good sorting modules which
deserve taking a look at too: \f(CW\*(C`Sort::Maker\*(C'\fR, \f(CW\*(C`Sort::Key\*(C'\fR spring to mind.
However, it's still possible to make some observations on certain Perl specific
interpretations on issues relating to sorting data sets and give an example or
two with regard to how sorting large data volumes can effect performance.
Firstly, an often overlooked point when sorting large amounts of data, one can
attempt to reduce the data set to be dealt with and in many cases \f(CW\*(C`grep()\*(C'\fR can
be quite useful as a simple filter:
.PP
.Vb 1
\&    @data = sort grep { /$filter/ } @incoming
.Ve
.PP
A command such as this can vastly reduce the volume of material to actually
sort through in the first place, and should not be too lightly disregarded
purely on the basis of its simplicity.  The \f(CW\*(C`KISS\*(C'\fR principle is too often
overlooked \- the next example uses the simple system \f(CW\*(C`time\*(C'\fR utility to
demonstrate.  Let's take a look at an actual example of sorting the contents of
a large file, an apache logfile would do.  This one has over a quarter of a
million lines, is 50M in size, and a snippet of it looks like this:
.PP
# logfile
.PP
.Vb 10
\&    188.209\-65\-87.adsl\-dyn.isp.belgacom.be \- \- [08/Feb/2007:12:57:16 +0000] "GET /favicon.ico HTTP/1.1" 404 209 "\-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    188.209\-65\-87.adsl\-dyn.isp.belgacom.be \- \- [08/Feb/2007:12:57:16 +0000] "GET /favicon.ico HTTP/1.1" 404 209 "\-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    151.56.71.198 \- \- [08/Feb/2007:12:57:41 +0000] "GET /suse\-on\-vaio.html HTTP/1.1" 200 2858 "http://www.linux\-on\-laptops.com/sony.html" "Mozilla/5.0 (Windows; U; Windows NT 5.2; en\-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1"
\&    151.56.71.198 \- \- [08/Feb/2007:12:57:42 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net/suse\-on\-vaio.html" "Mozilla/5.0 (Windows; U; Windows NT 5.2; en\-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1"
\&    151.56.71.198 \- \- [08/Feb/2007:12:57:43 +0000] "GET /favicon.ico HTTP/1.1" 404 209 "\-" "Mozilla/5.0 (Windows; U; Windows NT 5.2; en\-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1"
\&    217.113.68.60 \- \- [08/Feb/2007:13:02:15 +0000] "GET / HTTP/1.1" 304 \- "\-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    217.113.68.60 \- \- [08/Feb/2007:13:02:16 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net/" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    debora.to.isac.cnr.it \- \- [08/Feb/2007:13:03:58 +0000] "GET /suse\-on\-vaio.html HTTP/1.1" 200 2858 "http://www.linux\-on\-laptops.com/sony.html" "Mozilla/5.0 (compatible; Konqueror/3.4; Linux) KHTML/3.4.0 (like Gecko)"
\&    debora.to.isac.cnr.it \- \- [08/Feb/2007:13:03:58 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net/suse\-on\-vaio.html" "Mozilla/5.0 (compatible; Konqueror/3.4; Linux) KHTML/3.4.0 (like Gecko)"
\&    debora.to.isac.cnr.it \- \- [08/Feb/2007:13:03:58 +0000] "GET /favicon.ico HTTP/1.1" 404 209 "\-" "Mozilla/5.0 (compatible; Konqueror/3.4; Linux) KHTML/3.4.0 (like Gecko)"
\&    195.24.196.99 \- \- [08/Feb/2007:13:26:48 +0000] "GET / HTTP/1.0" 200 3309 "\-" "Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8.0.9) Gecko/20061206 Firefox/1.5.0.9"
\&    195.24.196.99 \- \- [08/Feb/2007:13:26:58 +0000] "GET /data/css HTTP/1.0" 404 206 "http://www.rfi.net/" "Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8.0.9) Gecko/20061206 Firefox/1.5.0.9"
\&    195.24.196.99 \- \- [08/Feb/2007:13:26:59 +0000] "GET /favicon.ico HTTP/1.0" 404 209 "\-" "Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8.0.9) Gecko/20061206 Firefox/1.5.0.9"
\&    crawl1.cosmixcorp.com \- \- [08/Feb/2007:13:27:57 +0000] "GET /robots.txt HTTP/1.0" 200 179 "\-" "voyager/1.0"
\&    crawl1.cosmixcorp.com \- \- [08/Feb/2007:13:28:25 +0000] "GET /links.html HTTP/1.0" 200 3413 "\-" "voyager/1.0"
\&    fhm226.internetdsl.tpnet.pl \- \- [08/Feb/2007:13:37:32 +0000] "GET /suse\-on\-vaio.html HTTP/1.1" 200 2858 "http://www.linux\-on\-laptops.com/sony.html" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    fhm226.internetdsl.tpnet.pl \- \- [08/Feb/2007:13:37:34 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net/suse\-on\-vaio.html" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
\&    80.247.140.134 \- \- [08/Feb/2007:13:57:35 +0000] "GET / HTTP/1.1" 200 3309 "\-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; .NET CLR 1.1.4322)"
\&    80.247.140.134 \- \- [08/Feb/2007:13:57:37 +0000] "GET /data/css HTTP/1.1" 404 206 "http://www.rfi.net" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; .NET CLR 1.1.4322)"
\&    pop.compuscan.co.za \- \- [08/Feb/2007:14:10:43 +0000] "GET / HTTP/1.1" 200 3309 "\-" "www.clamav.net"
\&    livebot\-207\-46\-98\-57.search.live.com \- \- [08/Feb/2007:14:12:04 +0000] "GET /robots.txt HTTP/1.0" 200 179 "\-" "msnbot/1.0 (+http://search.msn.com/msnbot.htm)"
\&    livebot\-207\-46\-98\-57.search.live.com \- \- [08/Feb/2007:14:12:04 +0000] "GET /html/oracle.html HTTP/1.0" 404 214 "\-" "msnbot/1.0 (+http://search.msn.com/msnbot.htm)"
\&    dslb\-088\-064\-005\-154.pools.arcor\-ip.net \- \- [08/Feb/2007:14:12:15 +0000] "GET / HTTP/1.1" 200 3309 "\-" "www.clamav.net"
\&    196.201.92.41 \- \- [08/Feb/2007:14:15:01 +0000] "GET / HTTP/1.1" 200 3309 "\-" "MOT\-L7/08.B7.DCR MIB/2.2.1 Profile/MIDP\-2.0 Configuration/CLDC\-1.1"
.Ve
.PP
The specific task here is to sort the 286,525 lines of this file by Response
Code, Query, Browser, Referring Url, and lastly Date.  One solution might be to
use the following code, which iterates over the files given on the
command-line.
.PP
# sort-apache-log
.PP
.Vb 1
\&    #!/usr/bin/perl \-n
\&
\&    use strict;
\&    use warnings;
\&
\&    my @data;
\&
\&    LINE:
\&    while ( <> ) {
\&        my $line = $_;
\&        if (
\&            $line =~ m/^(
\&                ([\ew\e.\e\-]+)             # client
\&                \es*\-\es*\-\es*\e[
\&                ([^]]+)                 # date
\&                \e]\es*"\ew+\es*
\&                (\eS+)                   # query
\&                [^"]+"\es*
\&                (\ed+)                   # status
\&                \es+\eS+\es+"[^"]*"\es+"
\&                ([^"]*)                 # browser
\&                "
\&                .*
\&            )$/x
\&        ) {
\&            my @chunks = split(/ +/, $line);
\&            my $ip      = $1;
\&            my $date    = $2;
\&            my $query   = $3;
\&            my $status  = $4;
\&            my $browser = $5;
\&
\&            push(@data, [$ip, $date, $query, $status, $browser, $line]);
\&        }
\&    }
\&
\&    my @sorted = sort {
\&        $a\->[3] cmp $b\->[3]
\&                ||
\&        $a\->[2] cmp $b\->[2]
\&                ||
\&        $a\->[0] cmp $b\->[0]
\&                ||
\&        $a\->[1] cmp $b\->[1]
\&                ||
\&        $a\->[4] cmp $b\->[4]
\&    } @data;
\&
\&    foreach my $data ( @sorted ) {
\&        print $data\->[5];
\&    }
\&
\&    exit 0;
.Ve
.PP
When running this program, redirect \f(CW\*(C`STDOUT\*(C'\fR so it is possible to check the
output is correct from following test runs and use the system \f(CW\*(C`time\*(C'\fR utility
to check the overall runtime.
.PP
.Vb 1
\&    $> time ./sort\-apache\-log logfile > out\-sort
\&
\&    real    0m17.371s
\&    user    0m15.757s
\&    sys     0m0.592s
.Ve
.PP
The program took just over 17 wallclock seconds to run.  Note the different
values \f(CW\*(C`time\*(C'\fR outputs, it's important to always use the same one, and to not
confuse what each one means.
.IP "Elapsed Real Time" 4
.IX Item "Elapsed Real Time"
The overall, or wallclock, time between when \f(CW\*(C`time\*(C'\fR was called, and when it
terminates.  The elapsed time includes both user and system times, and time
spent waiting for other users and processes on the system.  Inevitably, this is
the most approximate of the measurements given.
.IP "User \s-1CPU\s0 Time" 4
.IX Item "User CPU Time"
The user time is the amount of time the entire process spent on behalf of the
user on this system executing this program.
.IP "System \s-1CPU\s0 Time" 4
.IX Item "System CPU Time"
The system time is the amount of time the kernel itself spent executing
routines, or system calls, on behalf of this process user.
.PP
Running this same process as a \f(CW\*(C`Schwarzian Transform\*(C'\fR it is possible to
eliminate the input and output arrays for storing all the data, and work on the
input directly as it arrives too.  Otherwise, the code looks fairly similar:
.PP
# sort-apache-log-schwarzian
.PP
.Vb 1
\&    #!/usr/bin/perl \-n
\&
\&    use strict;
\&    use warnings;
\&
\&    print
\&
\&        map $_\->[0] =>
\&
\&        sort {
\&            $a\->[4] cmp $b\->[4]
\&                    ||
\&            $a\->[3] cmp $b\->[3]
\&                    ||
\&            $a\->[1] cmp $b\->[1]
\&                    ||
\&            $a\->[2] cmp $b\->[2]
\&                    ||
\&            $a\->[5] cmp $b\->[5]
\&        }
\&        map  [ $_, m/^(
\&            ([\ew\e.\e\-]+)             # client
\&            \es*\-\es*\-\es*\e[
\&            ([^]]+)                 # date
\&            \e]\es*"\ew+\es*
\&            (\eS+)                   # query
\&            [^"]+"\es*
\&            (\ed+)                   # status
\&            \es+\eS+\es+"[^"]*"\es+"
\&            ([^"]*)                 # browser
\&            "
\&            .*
\&        )$/xo ]
\&
\&        => <>;
\&
\&    exit 0;
.Ve
.PP
Run the new code against the same logfile, as above, to check the new time.
.PP
.Vb 1
\&    $> time ./sort\-apache\-log\-schwarzian logfile > out\-schwarz
\&
\&    real    0m9.664s
\&    user    0m8.873s
\&    sys     0m0.704s
.Ve
.PP
The time has been cut in half, which is a respectable speed improvement by any
standard.  Naturally, it is important to check the output is consistent with
the first program run, this is where the Unix system \f(CW\*(C`cksum\*(C'\fR utility comes in.
.PP
.Vb 3
\&    $> cksum out\-sort out\-schwarz
\&    3044173777 52029194 out\-sort
\&    3044173777 52029194 out\-schwarz
.Ve
.PP
\&\s-1BTW.\s0 Beware too of pressure from managers who see you speed a program up by 50%
of the runtime once, only to get a request one month later to do the same again
(true story) \- you'll just have to point out your only human, even if you are a
Perl programmer, and you'll see what you can do...
.SH "LOGGING"
.IX Header "LOGGING"
An essential part of any good development process is appropriate error handling
with appropriately informative messages, however there exists a school of
thought which suggests that log files should be \fIchatty\fR, as if the chain of
unbroken output somehow ensures the survival of the program.  If speed is in
any way an issue, this approach is wrong.
.PP
A common sight is code which looks something like this:
.PP
.Vb 1
\&    logger\->debug( "A logging message via process\-id: $$ INC: " . Dumper(\e%INC) )
.Ve
.PP
The problem is that this code will always be parsed and executed, even when the
debug level set in the logging configuration file is zero.  Once the \fIdebug()\fR
subroutine has been entered, and the internal \f(CW$debug\fR variable confirmed to
be zero, for example, the message which has been sent in will be discarded and
the program will continue.  In the example given though, the \e%INC hash will
already have been dumped, and the message string constructed, all of which work
could be bypassed by a debug variable at the statement level, like this:
.PP
.Vb 1
\&    logger\->debug( "A logging message via process\-id: $$ INC: " . Dumper(\e%INC) ) if $DEBUG;
.Ve
.PP
This effect can be demonstrated by setting up a test script with both forms,
including a \f(CW\*(C`debug()\*(C'\fR subroutine to emulate typical \f(CW\*(C`logger()\*(C'\fR functionality.
.PP
# ifdebug
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    use Benchmark;
\&    use Data::Dumper;
\&    my $DEBUG = 0;
\&
\&    sub debug {
\&        my $msg = shift;
\&
\&        if ( $DEBUG ) {
\&            print "DEBUG: $msg\en";
\&        }
\&    };
\&
\&    timethese(100000, {
\&            \*(Aqdebug\*(Aq       => sub {
\&                debug( "A $0 logging message via process\-id: $$" . Dumper(\e%INC) )
\&            },
\&            \*(Aqifdebug\*(Aq  => sub {
\&                debug( "A $0 logging message via process\-id: $$" . Dumper(\e%INC) ) if $DEBUG
\&            },
\&    });
.Ve
.PP
Let's see what \f(CW\*(C`Benchmark\*(C'\fR makes of this:
.PP
.Vb 5
\&    $> perl ifdebug
\&    Benchmark: timing 100000 iterations of constant, sub...
\&       ifdebug:  0 wallclock secs ( 0.01 usr +  0.00 sys =  0.01 CPU) @ 10000000.00/s (n=100000)
\&                (warning: too few iterations for a reliable count)
\&         debug: 14 wallclock secs (13.18 usr +  0.04 sys = 13.22 CPU) @ 7564.30/s (n=100000)
.Ve
.PP
In the one case the code, which does exactly the same thing as far as
outputting any debugging information is concerned, in other words nothing,
takes 14 seconds, and in the other case the code takes one hundredth of a
second.  Looks fairly definitive.  Use a \f(CW$DEBUG\fR variable \s-1BEFORE\s0 you call the
subroutine, rather than relying on the smart functionality inside it.
.SS "Logging if \s-1DEBUG \s0(constant)"
.IX Subsection "Logging if DEBUG (constant)"
It's possible to take the previous idea a little further, by using a compile
time \f(CW\*(C`DEBUG\*(C'\fR constant.
.PP
# ifdebug-constant
.PP
.Vb 1
\&    #!/usr/bin/perl
\&
\&    use strict;
\&    use warnings;
\&
\&    use Benchmark;
\&    use Data::Dumper;
\&    use constant
\&        DEBUG => 0
\&    ;
\&
\&    sub debug {
\&        if ( DEBUG ) {
\&            my $msg = shift;
\&            print "DEBUG: $msg\en";
\&        }
\&    };
\&
\&    timethese(100000, {
\&            \*(Aqdebug\*(Aq       => sub {
\&                debug( "A $0 logging message via process\-id: $$" . Dumper(\e%INC) )
\&            },
\&            \*(Aqconstant\*(Aq  => sub {
\&                debug( "A $0 logging message via process\-id: $$" . Dumper(\e%INC) ) if DEBUG
\&            },
\&    });
.Ve
.PP
Running this program produces the following output:
.PP
.Vb 5
\&    $> perl ifdebug\-constant
\&    Benchmark: timing 100000 iterations of constant, sub...
\&      constant:  0 wallclock secs (\-0.00 usr +  0.00 sys = \-0.00 CPU) @ \-7205759403792793600000.00/s (n=100000)
\&                (warning: too few iterations for a reliable count)
\&           sub: 14 wallclock secs (13.09 usr +  0.00 sys = 13.09 CPU) @ 7639.42/s (n=100000)
.Ve
.PP
The \f(CW\*(C`DEBUG\*(C'\fR constant wipes the floor with even the \f(CW$debug\fR variable,
clocking in at minus zero seconds, and generates a \*(L"warning: too few iterations
for a reliable count\*(R" message into the bargain.  To see what is really going
on, and why we had too few iterations when we thought we asked for 100000, we
can use the very useful \f(CW\*(C`B::Deparse\*(C'\fR to inspect the new code:
.PP
.Vb 1
\&    $> perl \-MO=Deparse ifdebug\-constant
\&
\&    use Benchmark;
\&    use Data::Dumper;
\&    use constant (\*(AqDEBUG\*(Aq, 0);
\&    sub debug {
\&        use warnings;
\&        use strict \*(Aqrefs\*(Aq;
\&        0;
\&    }
\&    use warnings;
\&    use strict \*(Aqrefs\*(Aq;
\&    timethese(100000, {\*(Aqsub\*(Aq, sub {
\&        debug "A $0 logging message via process\-id: $$" . Dumper(\e%INC);
\&    }
\&    , \*(Aqconstant\*(Aq, sub {
\&        0;
\&    }
\&    });
\&    ifdebug\-constant syntax OK
.Ve
.PP
The output shows the \fIconstant()\fR subroutine we're testing being replaced with
the value of the \f(CW\*(C`DEBUG\*(C'\fR constant: zero.  The line to be tested has been
completely optimized away, and you can't get much more efficient than that.
.SH "POSTSCRIPT"
.IX Header "POSTSCRIPT"
This document has provided several way to go about identifying hot-spots, and
checking whether any modifications have improved the runtime of the code.
.PP
As a final thought, remember that it's not (at the time of writing) possible to
produce a useful program which will run in zero or negative time and this basic
principle can be written as: \fIuseful programs are slow\fR by their very
definition.  It is of course possible to write a nearly instantaneous program,
but it's not going to do very much, here's a very efficient one:
.PP
.Vb 1
\&    $> perl \-e 0
.Ve
.PP
Optimizing that any further is a job for \f(CW\*(C`p5p\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Further reading can be found using the modules and links below.
.SS "\s-1PERLDOCS\s0"
.IX Subsection "PERLDOCS"
For example: \f(CW\*(C`perldoc \-f sort\*(C'\fR.
.PP
perlfaq4.
.PP
perlfork, perlfunc, perlretut, perlthrtut.
.PP
threads.
.SS "\s-1MAN PAGES\s0"
.IX Subsection "MAN PAGES"
\&\f(CW\*(C`time\*(C'\fR.
.SS "\s-1MODULES\s0"
.IX Subsection "MODULES"
It's not possible to individually showcase all the performance related code for
Perl here, naturally, but here's a short list of modules from the \s-1CPAN\s0 which
deserve further attention.
.PP
.Vb 10
\&    Apache::DProf
\&    Apache::SmallProf
\&    Benchmark
\&    DBIx::Profile
\&    Devel::AutoProfiler
\&    Devel::DProf
\&    Devel::DProfLB
\&    Devel::FastProf
\&    Devel::GraphVizProf
\&    Devel::NYTProf
\&    Devel::NYTProf::Apache
\&    Devel::Profiler
\&    Devel::Profile
\&    Devel::Profit
\&    Devel::SmallProf
\&    Devel::WxProf
\&    POE::Devel::Profiler
\&    Sort::Key
\&    Sort::Maker
.Ve
.SS "\s-1URLS\s0"
.IX Subsection "URLS"
Very useful online reference material:
.PP
.Vb 1
\&    http://www.ccl4.org/~nick/P/Fast_Enough/
\&
\&    http://www\-128.ibm.com/developerworks/library/l\-optperl.html
\&
\&    http://perlbuzz.com/2007/11/bind\-output\-variables\-in\-dbi\-for\-speed\-and\-safety.html
\&
\&    http://en.wikipedia.org/wiki/Performance_analysis
\&
\&    http://apache.perl.org/docs/1.0/guide/performance.html
\&
\&    http://perlgolf.sourceforge.net/
\&
\&    http://www.sysarch.com/Perl/sort_paper.html
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Richard Foley <richard.foley@rfi.net> Copyright (c) 2008
                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlplan9.1                                  0100644 0001750 0001750 00000022715 12566207443 022656  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPLAN9 1"
.TH PERLPLAN9 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlplan9 \- Plan 9\-specific documentation for Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These are a few notes describing features peculiar to
Plan 9 Perl. As such, it is not intended to be a replacement
for the rest of the Perl 5 documentation (which is both 
copious and excellent). If you have any questions to 
which you can't find answers in these man pages, contact 
Luther Huffman at lutherh@stratcom.com and we'll try to 
answer them.
.SS "Invoking Perl"
.IX Subsection "Invoking Perl"
Perl is invoked from the command line as described in 
perl. Most perl scripts, however, do have a first line 
such as \*(L"#!/usr/local/bin/perl\*(R". This is known as a shebang 
(shell-bang) statement and tells the \s-1OS\s0 shell where to find 
the perl interpreter. In Plan 9 Perl this statement should be 
\&\*(L"#!/bin/perl\*(R" if you wish to be able to directly invoke the 
script by its name.
     Alternatively, you may invoke perl with the command \*(L"Perl\*(R"
instead of \*(L"perl\*(R". This will produce Acme-friendly error
messages of the form \*(L"filename:18\*(R".
.PP
Some scripts, usually identified with a *.PL extension, are 
self-configuring and are able to correctly create their own 
shebang path from config information located in Plan 9 
Perl. These you won't need to be worried about.
.SS "What's in Plan 9 Perl"
.IX Subsection "What's in Plan 9 Perl"
Although Plan 9 Perl currently only  provides static 
loading, it is built with a number of useful extensions. 
These include Opcode, FileHandle, Fcntl, and \s-1POSIX.\s0 Expect 
to see others (and DynaLoading!) in the future.
.SS "What's not in Plan 9 Perl"
.IX Subsection "What's not in Plan 9 Perl"
As mentioned previously, dynamic loading isn't currently 
available nor is MakeMaker. Both are high-priority items.
.SS "Perl5 Functions not currently supported in Plan 9 Perl"
.IX Subsection "Perl5 Functions not currently supported in Plan 9 Perl"
Some, such as \f(CW\*(C`chown\*(C'\fR and \f(CW\*(C`umask\*(C'\fR aren't provided 
because the concept does not exist within Plan 9. Others,
such as some of the socket-related functions, simply
haven't been written yet. Many in the latter category 
may be supported in the future.
.PP
The functions not currently implemented include:
.PP
.Vb 5
\&    chown, chroot, dbmclose, dbmopen, getsockopt, 
\&    setsockopt, recvmsg, sendmsg, getnetbyname, 
\&    getnetbyaddr, getnetent, getprotoent, getservent, 
\&    sethostent, setnetent, setprotoent, setservent, 
\&    endservent, endnetent, endprotoent, umask
.Ve
.PP
There may be several other functions that have undefined 
behavior so this list shouldn't be considered complete.
.SS "Signals in Plan 9 Perl"
.IX Subsection "Signals in Plan 9 Perl"
For compatibility with perl scripts written for the Unix 
environment, Plan 9 Perl uses the \s-1POSIX\s0 signal emulation
provided in Plan 9's \s-1ANSI POSIX\s0 Environment (\s-1APE\s0). Signal stacking
isn't supported. The signals provided are:
.PP
.Vb 4
\&    SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGABRT,
\&    SIGFPE, SIGKILL, SIGSEGV, SIGPIPE, SIGPIPE, SIGALRM, 
\&    SIGTERM, SIGUSR1, SIGUSR2, SIGCHLD, SIGCONT,
\&    SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU
.Ve
.SH "COMPILING AND INSTALLING PERL ON PLAN 9"
.IX Header "COMPILING AND INSTALLING PERL ON PLAN 9"
\&\s-1WELCOME\s0 to Plan 9 Perl, brave soul!
.PP
.Vb 5
\&   This is a preliminary alpha version of Plan 9 Perl. Still to be
\&implemented are MakeMaker and DynaLoader. Many perl commands are
\&missing or currently behave in an inscrutable manner. These gaps will,
\&with perseverance and a modicum of luck, be remedied in the near
\&future.To install this software:
.Ve
.PP
1. Create the source directories and libraries for perl by running the
plan9/setup.rc command (i.e., located in the plan9 subdirectory).
Note: the setup routine assumes that you haven't dearchived these
files into /sys/src/cmd/perl. After running setup.rc you may delete
the copy of the source you originally detarred, as source code has now
been installed in /sys/src/cmd/perl. If you plan on installing perl
binaries for all architectures, run \*(L"setup.rc \-a\*(R".
.PP
2. After making sure that you have adequate privileges to build system
software, from /sys/src/cmd/perl/5.00301 (adjust version
appropriately) run:
.PP
.Vb 1
\&        mk install
.Ve
.PP
If you wish to install perl versions for all architectures (68020,
mips, sparc and 386) run:
.PP
.Vb 1
\&        mk installall
.Ve
.PP
3. Wait. The build process will take a *long* time because perl
bootstraps itself. A 75MHz Pentium, 16MB \s-1RAM\s0 machine takes roughly 30
minutes to build the distribution from scratch.
.SS "Installing Perl Documentation on Plan 9"
.IX Subsection "Installing Perl Documentation on Plan 9"
This perl distribution comes with a tremendous amount of
documentation. To add these to the built-in manuals that come with
Plan 9, from /sys/src/cmd/perl/5.00301 (adjust version appropriately)
run:
.PP
.Vb 1
\&        mk man
.Ve
.PP
To begin your reading, start with:
.PP
.Vb 1
\&        man perl
.Ve
.PP
This is a good introduction and will direct you towards other man
pages that may interest you.
.PP
(Note: \*(L"mk man\*(R" may produce some extraneous noise. Fear not.)
.SH "BUGS"
.IX Header "BUGS"
\&\*(L"As many as there are grains of sand on all the beaches of the 
world . . .\*(R" \- Carl Sagan
.SH "Revision date"
.IX Header "Revision date"
This document was revised 09\-October\-1996 for Perl 5.003_7.
.SH "AUTHOR"
.IX Header "AUTHOR"
Direct questions, comments, and the unlikely bug report (ahem) direct
comments toward:
.PP
Luther Huffman, lutherh@stratcom.com, 
Strategic Computer Solutions, Inc.
                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlplan95.16.1                              0100644 0001750 0001750 00000022403 12566207422 023157  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPLAN9 1"
.TH PERLPLAN9 1 "2013-02-26" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlplan9 \- Plan 9\-specific documentation for Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These are a few notes describing features peculiar to
Plan 9 Perl. As such, it is not intended to be a replacement
for the rest of the Perl 5 documentation (which is both 
copious and excellent). If you have any questions to 
which you can't find answers in these man pages, contact 
Luther Huffman at lutherh@stratcom.com and we'll try to 
answer them.
.SS "Invoking Perl"
.IX Subsection "Invoking Perl"
Perl is invoked from the command line as described in 
perl. Most perl scripts, however, do have a first line 
such as \*(L"#!/usr/local/bin/perl\*(R". This is known as a shebang 
(shell-bang) statement and tells the \s-1OS\s0 shell where to find 
the perl interpreter. In Plan 9 Perl this statement should be 
\&\*(L"#!/bin/perl\*(R" if you wish to be able to directly invoke the 
script by its name.
     Alternatively, you may invoke perl with the command \*(L"Perl\*(R"
instead of \*(L"perl\*(R". This will produce Acme-friendly error
messages of the form \*(L"filename:18\*(R".
.PP
Some scripts, usually identified with a *.PL extension, are 
self-configuring and are able to correctly create their own 
shebang path from config information located in Plan 9 
Perl. These you won't need to be worried about.
.SS "What's in Plan 9 Perl"
.IX Subsection "What's in Plan 9 Perl"
Although Plan 9 Perl currently only  provides static 
loading, it is built with a number of useful extensions. 
These include Opcode, FileHandle, Fcntl, and \s-1POSIX\s0. Expect 
to see others (and DynaLoading!) in the future.
.SS "What's not in Plan 9 Perl"
.IX Subsection "What's not in Plan 9 Perl"
As mentioned previously, dynamic loading isn't currently 
available nor is MakeMaker. Both are high-priority items.
.SS "Perl5 Functions not currently supported in Plan 9 Perl"
.IX Subsection "Perl5 Functions not currently supported in Plan 9 Perl"
Some, such as \f(CW\*(C`chown\*(C'\fR and \f(CW\*(C`umask\*(C'\fR aren't provided 
because the concept does not exist within Plan 9. Others,
such as some of the socket-related functions, simply
haven't been written yet. Many in the latter category 
may be supported in the future.
.PP
The functions not currently implemented include:
.PP
.Vb 5
\&    chown, chroot, dbmclose, dbmopen, getsockopt, 
\&    setsockopt, recvmsg, sendmsg, getnetbyname, 
\&    getnetbyaddr, getnetent, getprotoent, getservent, 
\&    sethostent, setnetent, setprotoent, setservent, 
\&    endservent, endnetent, endprotoent, umask
.Ve
.PP
There may be several other functions that have undefined 
behavior so this list shouldn't be considered complete.
.SS "Signals in Plan 9 Perl"
.IX Subsection "Signals in Plan 9 Perl"
For compatibility with perl scripts written for the Unix 
environment, Plan 9 Perl uses the \s-1POSIX\s0 signal emulation
provided in Plan 9's \s-1ANSI\s0 \s-1POSIX\s0 Environment (\s-1APE\s0). Signal stacking
isn't supported. The signals provided are:
.PP
.Vb 4
\&    SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGABRT,
\&    SIGFPE, SIGKILL, SIGSEGV, SIGPIPE, SIGPIPE, SIGALRM, 
\&    SIGTERM, SIGUSR1, SIGUSR2, SIGCHLD, SIGCONT,
\&    SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU
.Ve
.SH "COMPILING AND INSTALLING PERL ON PLAN 9"
.IX Header "COMPILING AND INSTALLING PERL ON PLAN 9"
\&\s-1WELCOME\s0 to Plan 9 Perl, brave soul!
.PP
.Vb 5
\&   This is a preliminary alpha version of Plan 9 Perl. Still to be
\&implemented are MakeMaker and DynaLoader. Many perl commands are
\&missing or currently behave in an inscrutable manner. These gaps will,
\&with perseverance and a modicum of luck, be remedied in the near
\&future.To install this software:
.Ve
.PP
1. Create the source directories and libraries for perl by running the
plan9/setup.rc command (i.e., located in the plan9 subdirectory).
Note: the setup routine assumes that you haven't dearchived these
files into /sys/src/cmd/perl. After running setup.rc you may delete
the copy of the source you originally detarred, as source code has now
been installed in /sys/src/cmd/perl. If you plan on installing perl
binaries for all architectures, run \*(L"setup.rc \-a\*(R".
.PP
2. After making sure that you have adequate privileges to build system
software, from /sys/src/cmd/perl/5.00301 (adjust version
appropriately) run:
.PP
.Vb 1
\&        mk install
.Ve
.PP
If you wish to install perl versions for all architectures (68020,
mips, sparc and 386) run:
.PP
.Vb 1
\&        mk installall
.Ve
.PP
3. Wait. The build process will take a *long* time because perl
bootstraps itself. A 75MHz Pentium, 16MB \s-1RAM\s0 machine takes roughly 30
minutes to build the distribution from scratch.
.SS "Installing Perl Documentation on Plan 9"
.IX Subsection "Installing Perl Documentation on Plan 9"
This perl distribution comes with a tremendous amount of
documentation. To add these to the built-in manuals that come with
Plan 9, from /sys/src/cmd/perl/5.00301 (adjust version appropriately)
run:
.PP
.Vb 1
\&        mk man
.Ve
.PP
To begin your reading, start with:
.PP
.Vb 1
\&        man perl
.Ve
.PP
This is a good introduction and will direct you towards other man
pages that may interest you.
.PP
(Note: \*(L"mk man\*(R" may produce some extraneous noise. Fear not.)
.SH "BUGS"
.IX Header "BUGS"
\&\*(L"As many as there are grains of sand on all the beaches of the 
world . . .\*(R" \- Carl Sagan
.SH "Revision date"
.IX Header "Revision date"
This document was revised 09\-October\-1996 for Perl 5.003_7.
.SH "AUTHOR"
.IX Header "AUTHOR"
Direct questions, comments, and the unlikely bug report (ahem) direct
comments toward:
.PP
Luther Huffman, lutherh@stratcom.com, 
Strategic Computer Solutions, Inc.
                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlplan95.18.1                              0100644 0001750 0001750 00000022715 12566207443 023172  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPLAN9 1"
.TH PERLPLAN9 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlplan9 \- Plan 9\-specific documentation for Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These are a few notes describing features peculiar to
Plan 9 Perl. As such, it is not intended to be a replacement
for the rest of the Perl 5 documentation (which is both 
copious and excellent). If you have any questions to 
which you can't find answers in these man pages, contact 
Luther Huffman at lutherh@stratcom.com and we'll try to 
answer them.
.SS "Invoking Perl"
.IX Subsection "Invoking Perl"
Perl is invoked from the command line as described in 
perl. Most perl scripts, however, do have a first line 
such as \*(L"#!/usr/local/bin/perl\*(R". This is known as a shebang 
(shell-bang) statement and tells the \s-1OS\s0 shell where to find 
the perl interpreter. In Plan 9 Perl this statement should be 
\&\*(L"#!/bin/perl\*(R" if you wish to be able to directly invoke the 
script by its name.
     Alternatively, you may invoke perl with the command \*(L"Perl\*(R"
instead of \*(L"perl\*(R". This will produce Acme-friendly error
messages of the form \*(L"filename:18\*(R".
.PP
Some scripts, usually identified with a *.PL extension, are 
self-configuring and are able to correctly create their own 
shebang path from config information located in Plan 9 
Perl. These you won't need to be worried about.
.SS "What's in Plan 9 Perl"
.IX Subsection "What's in Plan 9 Perl"
Although Plan 9 Perl currently only  provides static 
loading, it is built with a number of useful extensions. 
These include Opcode, FileHandle, Fcntl, and \s-1POSIX.\s0 Expect 
to see others (and DynaLoading!) in the future.
.SS "What's not in Plan 9 Perl"
.IX Subsection "What's not in Plan 9 Perl"
As mentioned previously, dynamic loading isn't currently 
available nor is MakeMaker. Both are high-priority items.
.SS "Perl5 Functions not currently supported in Plan 9 Perl"
.IX Subsection "Perl5 Functions not currently supported in Plan 9 Perl"
Some, such as \f(CW\*(C`chown\*(C'\fR and \f(CW\*(C`umask\*(C'\fR aren't provided 
because the concept does not exist within Plan 9. Others,
such as some of the socket-related functions, simply
haven't been written yet. Many in the latter category 
may be supported in the future.
.PP
The functions not currently implemented include:
.PP
.Vb 5
\&    chown, chroot, dbmclose, dbmopen, getsockopt, 
\&    setsockopt, recvmsg, sendmsg, getnetbyname, 
\&    getnetbyaddr, getnetent, getprotoent, getservent, 
\&    sethostent, setnetent, setprotoent, setservent, 
\&    endservent, endnetent, endprotoent, umask
.Ve
.PP
There may be several other functions that have undefined 
behavior so this list shouldn't be considered complete.
.SS "Signals in Plan 9 Perl"
.IX Subsection "Signals in Plan 9 Perl"
For compatibility with perl scripts written for the Unix 
environment, Plan 9 Perl uses the \s-1POSIX\s0 signal emulation
provided in Plan 9's \s-1ANSI POSIX\s0 Environment (\s-1APE\s0). Signal stacking
isn't supported. The signals provided are:
.PP
.Vb 4
\&    SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGABRT,
\&    SIGFPE, SIGKILL, SIGSEGV, SIGPIPE, SIGPIPE, SIGALRM, 
\&    SIGTERM, SIGUSR1, SIGUSR2, SIGCHLD, SIGCONT,
\&    SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU
.Ve
.SH "COMPILING AND INSTALLING PERL ON PLAN 9"
.IX Header "COMPILING AND INSTALLING PERL ON PLAN 9"
\&\s-1WELCOME\s0 to Plan 9 Perl, brave soul!
.PP
.Vb 5
\&   This is a preliminary alpha version of Plan 9 Perl. Still to be
\&implemented are MakeMaker and DynaLoader. Many perl commands are
\&missing or currently behave in an inscrutable manner. These gaps will,
\&with perseverance and a modicum of luck, be remedied in the near
\&future.To install this software:
.Ve
.PP
1. Create the source directories and libraries for perl by running the
plan9/setup.rc command (i.e., located in the plan9 subdirectory).
Note: the setup routine assumes that you haven't dearchived these
files into /sys/src/cmd/perl. After running setup.rc you may delete
the copy of the source you originally detarred, as source code has now
been installed in /sys/src/cmd/perl. If you plan on installing perl
binaries for all architectures, run \*(L"setup.rc \-a\*(R".
.PP
2. After making sure that you have adequate privileges to build system
software, from /sys/src/cmd/perl/5.00301 (adjust version
appropriately) run:
.PP
.Vb 1
\&        mk install
.Ve
.PP
If you wish to install perl versions for all architectures (68020,
mips, sparc and 386) run:
.PP
.Vb 1
\&        mk installall
.Ve
.PP
3. Wait. The build process will take a *long* time because perl
bootstraps itself. A 75MHz Pentium, 16MB \s-1RAM\s0 machine takes roughly 30
minutes to build the distribution from scratch.
.SS "Installing Perl Documentation on Plan 9"
.IX Subsection "Installing Perl Documentation on Plan 9"
This perl distribution comes with a tremendous amount of
documentation. To add these to the built-in manuals that come with
Plan 9, from /sys/src/cmd/perl/5.00301 (adjust version appropriately)
run:
.PP
.Vb 1
\&        mk man
.Ve
.PP
To begin your reading, start with:
.PP
.Vb 1
\&        man perl
.Ve
.PP
This is a good introduction and will direct you towards other man
pages that may interest you.
.PP
(Note: \*(L"mk man\*(R" may produce some extraneous noise. Fear not.)
.SH "BUGS"
.IX Header "BUGS"
\&\*(L"As many as there are grains of sand on all the beaches of the 
world . . .\*(R" \- Carl Sagan
.SH "Revision date"
.IX Header "Revision date"
This document was revised 09\-October\-1996 for Perl 5.003_7.
.SH "AUTHOR"
.IX Header "AUTHOR"
Direct questions, comments, and the unlikely bug report (ahem) direct
comments toward:
.PP
Luther Huffman, lutherh@stratcom.com, 
Strategic Computer Solutions, Inc.
                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlpod.1                                    0100644 0001750 0001750 00000071623 12566207443 022417  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPOD 1"
.TH PERLPOD 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpod \- the Plain Old Documentation format
.IX Xref "POD plain old documentation"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod is a simple-to-use markup language used for writing documentation
for Perl, Perl programs, and Perl modules.
.PP
Translators are available for converting Pod to various formats
like plain text, \s-1HTML,\s0 man pages, and more.
.PP
Pod markup consists of three basic kinds of paragraphs:
ordinary,
verbatim, and 
command.
.SS "Ordinary Paragraph"
.IX Xref "POD, ordinary paragraph"
.IX Subsection "Ordinary Paragraph"
Most paragraphs in your documentation will be ordinary blocks
of text, like this one.  You can simply type in your text without
any markup whatsoever, and with just a blank line before and
after.  When it gets formatted, it will undergo minimal formatting, 
like being rewrapped, probably put into a proportionally spaced
font, and maybe even justified.
.PP
You can use formatting codes in ordinary paragraphs, for \fBbold\fR,
\&\fIitalic\fR, \f(CW\*(C`code\-style\*(C'\fR, hyperlinks, and more.  Such
codes are explained in the "Formatting Codes"
section, below.
.SS "Verbatim Paragraph"
.IX Xref "POD, verbatim paragraph verbatim"
.IX Subsection "Verbatim Paragraph"
Verbatim paragraphs are usually used for presenting a codeblock or
other text which does not require any special parsing or formatting,
and which shouldn't be wrapped.
.PP
A verbatim paragraph is distinguished by having its first character
be a space or a tab.  (And commonly, all its lines begin with spaces
and/or tabs.)  It should be reproduced exactly, with tabs assumed to
be on 8\-column boundaries.  There are no special formatting codes,
so you can't italicize or anything like that.  A \e means \e, and
nothing else.
.SS "Command Paragraph"
.IX Xref "POD, command"
.IX Subsection "Command Paragraph"
A command paragraph is used for special treatment of whole chunks
of text, usually as headings or parts of lists.
.PP
All command paragraphs (which are typically only one line long) start
with \*(L"=\*(R", followed by an identifier, followed by arbitrary text that
the command can use however it pleases.  Currently recognized commands
are
.PP
.Vb 10
\&    =pod
\&    =head1 Heading Text
\&    =head2 Heading Text
\&    =head3 Heading Text
\&    =head4 Heading Text
\&    =over indentlevel
\&    =item stuff
\&    =back
\&    =begin format
\&    =end format
\&    =for format text...
\&    =encoding type
\&    =cut
.Ve
.PP
To explain them each in detail:
.ie n .IP """=head1 \f(CIHeading Text\f(CW""" 4
.el .IP "\f(CW=head1 \f(CIHeading Text\f(CW\fR" 4
.IX Xref "=head1 =head2 =head3 =head4 head1 head2 head3 head4"
.IX Item "=head1 Heading Text"
.PD 0
.ie n .IP """=head2 \f(CIHeading Text\f(CW""" 4
.el .IP "\f(CW=head2 \f(CIHeading Text\f(CW\fR" 4
.IX Item "=head2 Heading Text"
.ie n .IP """=head3 \f(CIHeading Text\f(CW""" 4
.el .IP "\f(CW=head3 \f(CIHeading Text\f(CW\fR" 4
.IX Item "=head3 Heading Text"
.ie n .IP """=head4 \f(CIHeading Text\f(CW""" 4
.el .IP "\f(CW=head4 \f(CIHeading Text\f(CW\fR" 4
.IX Item "=head4 Heading Text"
.PD
Head1 through head4 produce headings, head1 being the highest
level.  The text in the rest of this paragraph is the content of the
heading.  For example:
.Sp
.Vb 1
\&  =head2 Object Attributes
.Ve
.Sp
The text \*(L"Object Attributes\*(R" comprises the heading there.
The text in these heading commands can use formatting codes, as seen here:
.Sp
.Vb 1
\&  =head2 Possible Values for C<$/>
.Ve
.Sp
Such commands are explained in the
"Formatting Codes" section, below.
.ie n .IP """=over \f(CIindentlevel\f(CW""" 4
.el .IP "\f(CW=over \f(CIindentlevel\f(CW\fR" 4
.IX Xref "=over =item =back over item back"
.IX Item "=over indentlevel"
.PD 0
.ie n .IP """=item \f(CIstuff...\f(CW""" 4
.el .IP "\f(CW=item \f(CIstuff...\f(CW\fR" 4
.IX Item "=item stuff..."
.ie n .IP """=back""" 4
.el .IP "\f(CW=back\fR" 4
.IX Item "=back"
.PD
Item, over, and back require a little more explanation:  \*(L"=over\*(R" starts
a region specifically for the generation of a list using \*(L"=item\*(R"
commands, or for indenting (groups of) normal paragraphs.  At the end
of your list, use \*(L"=back\*(R" to end it.  The \fIindentlevel\fR option to
\&\*(L"=over\*(R" indicates how far over to indent, generally in ems (where
one em is the width of an \*(L"M\*(R" in the document's base font) or roughly
comparable units; if there is no \fIindentlevel\fR option, it defaults
to four.  (And some formatters may just ignore whatever \fIindentlevel\fR
you provide.)  In the \fIstuff\fR in \f(CW\*(C`=item \f(CIstuff...\f(CW\*(C'\fR, you may
use formatting codes, as seen here:
.Sp
.Vb 1
\&  =item Using C<$|> to Control Buffering
.Ve
.Sp
Such commands are explained in the
"Formatting Codes" section, below.
.Sp
Note also that there are some basic rules to using \*(L"=over\*(R" ...
\&\*(L"=back\*(R" regions:
.RS 4
.IP "\(bu" 4
Don't use \*(L"=item\*(R"s outside of an \*(L"=over\*(R" ... \*(L"=back\*(R" region.
.IP "\(bu" 4
The first thing after the \*(L"=over\*(R" command should be an \*(L"=item\*(R", unless
there aren't going to be any items at all in this \*(L"=over\*(R" ... \*(L"=back\*(R"
region.
.IP "\(bu" 4
Don't put "=head\fIn\fR\*(L" commands inside an \*(R"=over\*(L" ... \*(R"=back" region.
.IP "\(bu" 4
And perhaps most importantly, keep the items consistent: either use
\&\*(L"=item *\*(R" for all of them, to produce bullets; or use \*(L"=item 1.\*(R",
\&\*(L"=item 2.\*(R", etc., to produce numbered lists; or use \*(L"=item foo\*(R",
\&\*(L"=item bar\*(R", etc.\-\-namely, things that look nothing like bullets or
numbers.
.Sp
If you start with bullets or numbers, stick with them, as
formatters use the first \*(L"=item\*(R" type to decide how to format the
list.
.RE
.RS 4
.RE
.ie n .IP """=cut""" 4
.el .IP "\f(CW=cut\fR" 4
.IX Xref "=cut cut"
.IX Item "=cut"
To end a Pod block, use a blank line,
then a line beginning with \*(L"=cut\*(R", and a blank
line after it.  This lets Perl (and the Pod formatter) know that
this is where Perl code is resuming.  (The blank line before the \*(L"=cut\*(R"
is not technically necessary, but many older Pod processors require it.)
.ie n .IP """=pod""" 4
.el .IP "\f(CW=pod\fR" 4
.IX Xref "=pod pod"
.IX Item "=pod"
The \*(L"=pod\*(R" command by itself doesn't do much of anything, but it
signals to Perl (and Pod formatters) that a Pod block starts here.  A
Pod block starts with \fIany\fR command paragraph, so a \*(L"=pod\*(R" command is
usually used just when you want to start a Pod block with an ordinary
paragraph or a verbatim paragraph.  For example:
.Sp
.Vb 1
\&  =item stuff()
\&
\&  This function does stuff.
\&
\&  =cut
\&
\&  sub stuff {
\&    ...
\&  }
\&
\&  =pod
\&
\&  Remember to check its return value, as in:
\&
\&    stuff() || die "Couldn\*(Aqt do stuff!";
\&
\&  =cut
.Ve
.ie n .IP """=begin \f(CIformatname\f(CW""" 4
.el .IP "\f(CW=begin \f(CIformatname\f(CW\fR" 4
.IX Xref "=begin =end =for begin end for"
.IX Item "=begin formatname"
.PD 0
.ie n .IP """=end \f(CIformatname\f(CW""" 4
.el .IP "\f(CW=end \f(CIformatname\f(CW\fR" 4
.IX Item "=end formatname"
.ie n .IP """=for \f(CIformatname\f(CW \f(CItext...\f(CW""" 4
.el .IP "\f(CW=for \f(CIformatname\f(CW \f(CItext...\f(CW\fR" 4
.IX Item "=for formatname text..."
.PD
For, begin, and end will let you have regions of text/code/data that
are not generally interpreted as normal Pod text, but are passed
directly to particular formatters, or are otherwise special.  A
formatter that can use that format will use the region, otherwise it
will be completely ignored.
.Sp
A command "=begin \fIformatname\fR\*(L", some paragraphs, and a
command \*(R"=end \fIformatname\fR", mean that the text/data in between
is meant for formatters that understand the special format
called \fIformatname\fR.  For example,
.Sp
.Vb 1
\&  =begin html
\&
\&  <hr> <img src="thang.png">
\&  <p> This is a raw HTML paragraph </p>
\&
\&  =end html
.Ve
.Sp
The command "=for \fIformatname\fR \fItext...\fR"
specifies that the remainder of just this paragraph (starting
right after \fIformatname\fR) is in that special format.
.Sp
.Vb 2
\&  =for html <hr> <img src="thang.png">
\&  <p> This is a raw HTML paragraph </p>
.Ve
.Sp
This means the same thing as the above \*(L"=begin html\*(R" ... \*(L"=end html\*(R"
region.
.Sp
That is, with \*(L"=for\*(R", you can have only one paragraph's worth
of text (i.e., the text in \*(L"=foo targetname text...\*(R"), but with
\&\*(L"=begin targetname\*(R" ... \*(L"=end targetname\*(R", you can have any amount
of stuff in between.  (Note that there still must be a blank line
after the \*(L"=begin\*(R" command and a blank line before the \*(L"=end\*(R"
command.)
.Sp
Here are some examples of how to use these:
.Sp
.Vb 1
\&  =begin html
\&
\&  <br>Figure 1.<br><IMG SRC="figure1.png"><br>
\&
\&  =end html
\&
\&  =begin text
\&
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    |  foo        |
\&    |        bar  |
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&  ^^^^ Figure 1. ^^^^
\&
\&  =end text
.Ve
.Sp
Some format names that formatters currently are known to accept
include \*(L"roff\*(R", \*(L"man\*(R", \*(L"latex\*(R", \*(L"tex\*(R", \*(L"text\*(R", and \*(L"html\*(R".  (Some
formatters will treat some of these as synonyms.)
.Sp
A format name of \*(L"comment\*(R" is common for just making notes (presumably
to yourself) that won't appear in any formatted version of the Pod
document:
.Sp
.Vb 2
\&  =for comment
\&  Make sure that all the available options are documented!
.Ve
.Sp
Some \fIformatnames\fR will require a leading colon (as in
\&\f(CW"=for :formatname"\fR, or
\&\f(CW"=begin :formatname" ... "=end :formatname"\fR),
to signal that the text is not raw data, but instead \fIis\fR Pod text
(i.e., possibly containing formatting codes) that's just not for
normal formatting (e.g., may not be a normal-use paragraph, but might
be for formatting as a footnote).
.ie n .IP """=encoding \f(CIencodingname\f(CW""" 4
.el .IP "\f(CW=encoding \f(CIencodingname\f(CW\fR" 4
.IX Xref "=encoding encoding"
.IX Item "=encoding encodingname"
This command is used for declaring the encoding of a document.  Most
users won't need this; but if your encoding isn't US-ASCII or Latin\-1,
then put a \f(CW\*(C`=encoding \f(CIencodingname\f(CW\*(C'\fR command early in the document so
that pod formatters will know how to decode the document.  For
\&\fIencodingname\fR, use a name recognized by the Encode::Supported
module.  Examples:
.Sp
.Vb 1
\&  =encoding utf8
\&
\&  =encoding koi8\-r
\&
\&  =encoding ShiftJIS
\&
\&  =encoding big5
.Ve
.PP
\&\f(CW\*(C`=encoding\*(C'\fR affects the whole document, and must occur only once.
.PP
And don't forget, when using any other command, that the command lasts up
until the end of its \fIparagraph\fR, not its line.  So in the
examples below, you can see that every command needs the blank
line after it, to end its paragraph.
.PP
Some examples of lists include:
.PP
.Vb 1
\&  =over
\&
\&  =item *
\&
\&  First item
\&
\&  =item *
\&
\&  Second item
\&
\&  =back
\&
\&  =over
\&
\&  =item Foo()
\&
\&  Description of Foo function
\&
\&  =item Bar()
\&
\&  Description of Bar function
\&
\&  =back
.Ve
.SS "Formatting Codes"
.IX Xref "POD, formatting code formatting code POD, interior sequence interior sequence"
.IX Subsection "Formatting Codes"
In ordinary paragraphs and in some command paragraphs, various
formatting codes (a.k.a. \*(L"interior sequences\*(R") can be used:
.ie n .IP """I<text>"" \*(-- italic text" 4
.el .IP "\f(CWI<text>\fR \*(-- italic text" 4
.IX Xref "I I<> POD, formatting code, italic italic"
.IX Item "I<text> italic text"
Used for emphasis ("\f(CW\*(C`be I<careful!>\*(C'\fR\*(L") and parameters
(\*(R"\f(CW\*(C`redo I<LABEL>\*(C'\fR")
.ie n .IP """B<text>"" \*(-- bold text" 4
.el .IP "\f(CWB<text>\fR \*(-- bold text" 4
.IX Xref "B B<> POD, formatting code, bold bold"
.IX Item "B<text> bold text"
Used for switches ("\f(CW\*(C`perl\*(Aqs B<\-n> switch\*(C'\fR\*(L"), programs
(\*(R"\f(CW\*(C`some systems provide a B<chfn> for that\*(C'\fR\*(L"),
emphasis (\*(R"\f(CW\*(C`be B<careful!>\*(C'\fR\*(L"), and so on
(\*(R"\f(CW\*(C`and that feature is known as B<autovivification>\*(C'\fR").
.ie n .IP """C<code>"" \*(-- code text" 4
.el .IP "\f(CWC<code>\fR \*(-- code text" 4
.IX Xref "C C<> POD, formatting code, code code"
.IX Item "C<code> code text"
Renders code in a typewriter font, or gives some other indication that
this represents program text ("\f(CW\*(C`C<gmtime($^T)>\*(C'\fR\*(L") or some other
form of computerese (\*(R"\f(CW\*(C`C<drwxr\-xr\-x>\*(C'\fR").
.ie n .IP """L<name>"" \*(-- a hyperlink" 4
.el .IP "\f(CWL<name>\fR \*(-- a hyperlink" 4
.IX Xref "L L<> POD, formatting code, hyperlink hyperlink"
.IX Item "L<name> a hyperlink"
There are various syntaxes, listed below.  In the syntaxes given,
\&\f(CW\*(C`text\*(C'\fR, \f(CW\*(C`name\*(C'\fR, and \f(CW\*(C`section\*(C'\fR cannot contain the characters
\&'/' and '|'; and any '<' or '>' should be matched.
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`L<name>\*(C'\fR
.Sp
Link to a Perl manual page (e.g., \f(CW\*(C`L<Net::Ping>\*(C'\fR).  Note
that \f(CW\*(C`name\*(C'\fR should not contain spaces.  This syntax
is also occasionally used for references to Unix man pages, as in
\&\f(CW\*(C`L<crontab(5)>\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`L<name/"sec">\*(C'\fR or \f(CW\*(C`L<name/sec>\*(C'\fR
.Sp
Link to a section in other manual page.  E.g.,
\&\f(CW\*(C`L<perlsyn/"For Loops">\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`L</"sec">\*(C'\fR or \f(CW\*(C`L</sec>\*(C'\fR
.Sp
Link to a section in this manual page.  E.g.,
\&\f(CW\*(C`L</"Object Methods">\*(C'\fR
.RE
.RS 4
.Sp
A section is started by the named heading or item.  For
example, \f(CW\*(C`L<perlvar/$.>\*(C'\fR or \f(CW\*(C`L<perlvar/"$.">\*(C'\fR both
link to the section started by "\f(CW\*(C`=item $.\*(C'\fR" in perlvar.  And
\&\f(CW\*(C`L<perlsyn/For Loops>\*(C'\fR or \f(CW\*(C`L<perlsyn/"For Loops">\*(C'\fR
both link to the section started by "\f(CW\*(C`=head2 For Loops\*(C'\fR"
in perlsyn.
.Sp
To control what text is used for display, you
use "\f(CW\*(C`L<text|...>\*(C'\fR", as in:
.IP "\(bu" 4
\&\f(CW\*(C`L<text|name>\*(C'\fR
.Sp
Link this text to that manual page.  E.g.,
\&\f(CW\*(C`L<Perl Error Messages|perldiag>\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`L<text|name/"sec">\*(C'\fR or \f(CW\*(C`L<text|name/sec>\*(C'\fR
.Sp
Link this text to that section in that manual page.  E.g.,
\&\f(CW\*(C`L<postfix "if"|perlsyn/"Statement Modifiers">\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`L<text|/"sec">\*(C'\fR or \f(CW\*(C`L<text|/sec>\*(C'\fR
or \f(CW\*(C`L<text|"sec">\*(C'\fR
.Sp
Link this text to that section in this manual page.  E.g.,
\&\f(CW\*(C`L<the various attributes|/"Member Data">\*(C'\fR
.RE
.RS 4
.Sp
Or you can link to a web page:
.IP "\(bu" 4
\&\f(CW\*(C`L<scheme:...>\*(C'\fR
.Sp
\&\f(CW\*(C`L<text|scheme:...>\*(C'\fR
.Sp
Links to an absolute \s-1URL. \s0 For example, \f(CW\*(C`L<http://www.perl.org/>\*(C'\fR or
\&\f(CW\*(C`L<The Perl Home Page|http://www.perl.org/>\*(C'\fR.
.RE
.RS 4
.RE
.ie n .IP """E<escape>"" \*(-- a character escape" 4
.el .IP "\f(CWE<escape>\fR \*(-- a character escape" 4
.IX Xref "E E<> POD, formatting code, escape escape"
.IX Item "E<escape> a character escape"
Very similar to \s-1HTML/XML \s0\f(CW\*(C`&\f(CIfoo\f(CW;\*(C'\fR \*(L"entity references\*(R":
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`E<lt>\*(C'\fR \*(-- a literal < (less than)
.IP "\(bu" 4
\&\f(CW\*(C`E<gt>\*(C'\fR \*(-- a literal > (greater than)
.IP "\(bu" 4
\&\f(CW\*(C`E<verbar>\*(C'\fR \*(-- a literal | (\fIver\fRtical \fIbar\fR)
.IP "\(bu" 4
\&\f(CW\*(C`E<sol>\*(C'\fR \*(-- a literal / (\fIsol\fRidus)
.Sp
The above four are optional except in other formatting codes,
notably \f(CW\*(C`L<...>\*(C'\fR, and when preceded by a
capital letter.
.IP "\(bu" 4
\&\f(CW\*(C`E<htmlname>\*(C'\fR
.Sp
Some non-numeric \s-1HTML\s0 entity name, such as \f(CW\*(C`E<eacute>\*(C'\fR,
meaning the same thing as \f(CW\*(C`&eacute;\*(C'\fR in \s-1HTML\s0 \*(-- i.e., a lowercase
e with an acute (/\-shaped) accent.
.IP "\(bu" 4
\&\f(CW\*(C`E<number>\*(C'\fR
.Sp
The ASCII/Latin\-1/Unicode character with that number.  A
leading \*(L"0x\*(R" means that \fInumber\fR is hex, as in
\&\f(CW\*(C`E<0x201E>\*(C'\fR.  A leading \*(L"0\*(R" means that \fInumber\fR is octal,
as in \f(CW\*(C`E<075>\*(C'\fR.  Otherwise \fInumber\fR is interpreted as being
in decimal, as in \f(CW\*(C`E<181>\*(C'\fR.
.Sp
Note that older Pod formatters might not recognize octal or
hex numeric escapes, and that many formatters cannot reliably
render characters above 255.  (Some formatters may even have
to use compromised renderings of Latin\-1 characters, like
rendering \f(CW\*(C`E<eacute>\*(C'\fR as just a plain \*(L"e\*(R".)
.RE
.RS 4
.RE
.ie n .IP """F<filename>"" \*(-- used for filenames" 4
.el .IP "\f(CWF<filename>\fR \*(-- used for filenames" 4
.IX Xref "F F<> POD, formatting code, filename filename"
.IX Item "F<filename> used for filenames"
Typically displayed in italics.  Example: "\f(CW\*(C`F<.cshrc>\*(C'\fR"
.ie n .IP """S<text>"" \*(-- text contains non-breaking spaces" 4
.el .IP "\f(CWS<text>\fR \*(-- text contains non-breaking spaces" 4
.IX Xref "S S<> POD, formatting code, non-breaking space non-breaking space"
.IX Item "S<text> text contains non-breaking spaces"
This means that the words in \fItext\fR should not be broken
across lines.  Example: \f(CW\*(C`S<$x\ ?\ $y\ :\ $z>\*(C'\fR.
.ie n .IP """X<topic name>"" \*(-- an index entry" 4
.el .IP "\f(CWX<topic name>\fR \*(-- an index entry" 4
.IX Xref "X X<> POD, formatting code, index entry index entry"
.IX Item "X<topic name> an index entry"
This is ignored by most formatters, but some may use it for building
indexes.  It always renders as empty-string.
Example: \f(CW\*(C`X<absolutizing relative URLs>\*(C'\fR
.ie n .IP """Z<>"" \*(-- a null (zero-effect) formatting code" 4
.el .IP "\f(CWZ<>\fR \*(-- a null (zero-effect) formatting code" 4
.IX Xref "Z Z<> POD, formatting code, null null"
.IX Item "Z<> a null (zero-effect) formatting code"
This is rarely used.  It's one way to get around using an
E<...> code sometimes.  For example, instead of
"\f(CW\*(C`NE<lt>3\*(C'\fR\*(L" (for \*(R"N<3\*(L") you could write
\&\*(R"\f(CW\*(C`NZ<><3\*(C'\fR\*(L" (the \*(R"Z<>\*(L" breaks up the \*(R"N\*(L" and
the \*(R"<\*(L" so they can't be considered
the part of a (fictitious) \*(R"N<...>" code).
.PP
Most of the time, you will need only a single set of angle brackets to
delimit the beginning and end of formatting codes.  However,
sometimes you will want to put a real right angle bracket (a
greater-than sign, '>') inside of a formatting code.  This is particularly
common when using a formatting code to provide a different font-type for a
snippet of code.  As with all things in Perl, there is more than
one way to do it.  One way is to simply escape the closing bracket
using an \f(CW\*(C`E\*(C'\fR code:
.PP
.Vb 1
\&    C<$a E<lt>=E<gt> $b>
.Ve
.PP
This will produce: "\f(CW\*(C`$a <=> $b\*(C'\fR"
.PP
A more readable, and perhaps more \*(L"plain\*(R" way is to use an alternate
set of delimiters that doesn't require a single \*(L">\*(R" to be escaped.
Doubled angle brackets (\*(L"<<\*(R" and \*(L">>\*(R") may be used \fIif and only if there is
whitespace right after the opening delimiter and whitespace right
before the closing delimiter!\fR  For example, the following will
do the trick:
.IX Xref "POD, formatting code, escaping with multiple brackets"
.PP
.Vb 1
\&    C<< $a <=> $b >>
.Ve
.PP
In fact, you can use as many repeated angle-brackets as you like so
long as you have the same number of them in the opening and closing
delimiters, and make sure that whitespace immediately follows the last
\&'<' of the opening delimiter, and immediately precedes the first '>'
of the closing delimiter.  (The whitespace is ignored.)  So the
following will also work:
.IX Xref "POD, formatting code, escaping with multiple brackets"
.PP
.Vb 2
\&    C<<< $a <=> $b >>>
\&    C<<<<  $a <=> $b     >>>>
.Ve
.PP
And they all mean exactly the same as this:
.PP
.Vb 1
\&    C<$a E<lt>=E<gt> $b>
.Ve
.PP
The multiple-bracket form does not affect the interpretation of the contents of
the formatting code, only how it must end.  That means that the examples above
are also exactly the same as this:
.PP
.Vb 1
\&    C<< $a E<lt>=E<gt> $b >>
.Ve
.PP
As a further example, this means that if you wanted to put these bits of
code in \f(CW\*(C`C\*(C'\fR (code) style:
.PP
.Vb 2
\&    open(X, ">>thing.dat") || die $!
\&    $foo\->bar();
.Ve
.PP
you could do it like so:
.PP
.Vb 2
\&    C<<< open(X, ">>thing.dat") || die $! >>>
\&    C<< $foo\->bar(); >>
.Ve
.PP
which is presumably easier to read than the old way:
.PP
.Vb 2
\&    C<open(X, "E<gt>E<gt>thing.dat") || die $!>
\&    C<$foo\-E<gt>bar();>
.Ve
.PP
This is currently supported by pod2text (Pod::Text), pod2man (Pod::Man),
and any other pod2xxx or Pod::Xxxx translators that use
Pod::Parser 1.093 or later, or Pod::Tree 1.02 or later.
.SS "The Intent"
.IX Xref "POD, intent of"
.IX Subsection "The Intent"
The intent is simplicity of use, not power of expression.  Paragraphs
look like paragraphs (block format), so that they stand out
visually, and so that I could run them through \f(CW\*(C`fmt\*(C'\fR easily to reformat
them (that's F7 in my version of \fBvi\fR, or Esc Q in my version of
\&\fBemacs\fR).  I wanted the translator to always leave the \f(CW\*(C`\*(Aq\*(C'\fR and \f(CW\*(C`\`\*(C'\fR and
\&\f(CW\*(C`"\*(C'\fR quotes alone, in verbatim mode, so I could slurp in a
working program, shift it over four spaces, and have it print out, er,
verbatim.  And presumably in a monospace font.
.PP
The Pod format is not necessarily sufficient for writing a book.  Pod
is just meant to be an idiot-proof common source for nroff, \s-1HTML,\s0
TeX, and other markup languages, as used for online
documentation.  Translators exist for \fBpod2text\fR, \fBpod2html\fR,
\&\fBpod2man\fR (that's for \fInroff\fR\|(1) and \fItroff\fR\|(1)), \fBpod2latex\fR, and
\&\fBpod2fm\fR.  Various others are available in \s-1CPAN.\s0
.SS "Embedding Pods in Perl Modules"
.IX Xref "POD, embedding"
.IX Subsection "Embedding Pods in Perl Modules"
You can embed Pod documentation in your Perl modules and scripts.
Start your documentation with an empty line, a \*(L"=head1\*(R" command at the
beginning, and end it with a \*(L"=cut\*(R" command and an empty line.  Perl
will ignore the Pod text.  See any of the supplied library modules for
examples.  If you're going to put your Pod at the end of the file, and
you're using an _\|_END_\|_ or _\|_DATA_\|_ cut mark, make sure to put an
empty line there before the first Pod command.
.PP
.Vb 1
\&  _\|_END_\|_
\&
\&  =head1 NAME
\&
\&  Time::Local \- efficiently compute time from local and GMT time
.Ve
.PP
Without that empty line before the \*(L"=head1\*(R", many translators wouldn't
have recognized the \*(L"=head1\*(R" as starting a Pod block.
.SS "Hints for Writing Pod"
.IX Subsection "Hints for Writing Pod"
.IP "\(bu" 4

.IX Xref "podchecker POD, validating"
.Sp
The \fBpodchecker\fR command is provided for checking Pod syntax for errors
and warnings.  For example, it checks for completely blank lines in
Pod blocks and for unknown commands and formatting codes.  You should
still also pass your document through one or more translators and proofread
the result, or print out the result and proofread that.  Some of the
problems found may be bugs in the translators, which you may or may not
wish to work around.
.IP "\(bu" 4
If you're more familiar with writing in \s-1HTML\s0 than with writing in Pod, you
can try your hand at writing documentation in simple \s-1HTML,\s0 and converting
it to Pod with the experimental Pod::HTML2Pod module,
(available in \s-1CPAN\s0), and looking at the resulting code.  The experimental
Pod::PXML module in \s-1CPAN\s0 might also be useful.
.IP "\(bu" 4
Many older Pod translators require the lines before every Pod
command and after every Pod command (including \*(L"=cut\*(R"!) to be a blank
line.  Having something like this:
.Sp
.Vb 2
\& # \- \- \- \- \- \- \- \- \- \- \- \-
\& =item $firecracker\->boom()
\&
\& This noisily detonates the firecracker object.
\& =cut
\& sub boom {
\& ...
.Ve
.Sp
\&...will make such Pod translators completely fail to see the Pod block
at all.
.Sp
Instead, have it like this:
.Sp
.Vb 1
\& # \- \- \- \- \- \- \- \- \- \- \- \-
\&
\& =item $firecracker\->boom()
\&
\& This noisily detonates the firecracker object.
\&
\& =cut
\&
\& sub boom {
\& ...
.Ve
.IP "\(bu" 4
Some older Pod translators require paragraphs (including command
paragraphs like \*(L"=head2 Functions\*(R") to be separated by \fIcompletely\fR
empty lines.  If you have an apparently empty line with some spaces
on it, this might not count as a separator for those translators, and
that could cause odd formatting.
.IP "\(bu" 4
Older translators might add wording around an L<> link, so that
\&\f(CW\*(C`L<Foo::Bar>\*(C'\fR may become \*(L"the Foo::Bar manpage\*(R", for example.
So you shouldn't write things like \f(CW\*(C`the L<foo>
documentation\*(C'\fR, if you want the translated document to read sensibly.
Instead, write \f(CW\*(C`the L<Foo::Bar|Foo::Bar> documentation\*(C'\fR or
\&\f(CW\*(C`L<the Foo::Bar documentation|Foo::Bar>\*(C'\fR, to control how the
link comes out.
.IP "\(bu" 4
Going past the 70th column in a verbatim block might be ungracefully
wrapped by some formatters.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlpodspec, \*(L"PODs: Embedded Documentation\*(R" in perlsyn,
perlnewmod, perldoc, pod2html, pod2man, podchecker.
.SH "AUTHOR"
.IX Header "AUTHOR"
Larry Wall, Sean M. Burke
                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlpod5.16.1                                0100644 0001750 0001750 00000071451 12566207422 022725  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPOD 1"
.TH PERLPOD 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpod \- the Plain Old Documentation format
.IX Xref "POD plain old documentation"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod is a simple-to-use markup language used for writing documentation
for Perl, Perl programs, and Perl modules.
.PP
Translators are available for converting Pod to various formats
like plain text, \s-1HTML\s0, man pages, and more.
.PP
Pod markup consists of three basic kinds of paragraphs:
ordinary,
verbatim, and 
command.
.SS "Ordinary Paragraph"
.IX Xref "POD, ordinary paragraph"
.IX Subsection "Ordinary Paragraph"
Most paragraphs in your documentation will be ordinary blocks
of text, like this one.  You can simply type in your text without
any markup whatsoever, and with just a blank line before and
after.  When it gets formatted, it will undergo minimal formatting, 
like being rewrapped, probably put into a proportionally spaced
font, and maybe even justified.
.PP
You can use formatting codes in ordinary paragraphs, for \fBbold\fR,
\&\fIitalic\fR, \f(CW\*(C`code\-style\*(C'\fR, hyperlinks, and more.  Such
codes are explained in the "Formatting Codes"
section, below.
.SS "Verbatim Paragraph"
.IX Xref "POD, verbatim paragraph verbatim"
.IX Subsection "Verbatim Paragraph"
Verbatim paragraphs are usually used for presenting a codeblock or
other text which does not require any special parsing or formatting,
and which shouldn't be wrapped.
.PP
A verbatim paragraph is distinguished by having its first character
be a space or a tab.  (And commonly, all its lines begin with spaces
and/or tabs.)  It should be reproduced exactly, with tabs assumed to
be on 8\-column boundaries.  There are no special formatting codes,
so you can't italicize or anything like that.  A \e means \e, and
nothing else.
.SS "Command Paragraph"
.IX Xref "POD, command"
.IX Subsection "Command Paragraph"
A command paragraph is used for special treatment of whole chunks
of text, usually as headings or parts of lists.
.PP
All command paragraphs (which are typically only one line long) start
with \*(L"=\*(R", followed by an identifier, followed by arbitrary text that
the command can use however it pleases.  Currently recognized commands
are
.PP
.Vb 10
\&    =pod
\&    =head1 Heading Text
\&    =head2 Heading Text
\&    =head3 Heading Text
\&    =head4 Heading Text
\&    =over indentlevel
\&    =item stuff
\&    =back
\&    =begin format
\&    =end format
\&    =for format text...
\&    =encoding type
\&    =cut
.Ve
.PP
To explain them each in detail:
.ie n .IP """=head1 \f(CIHeading Text\f(CW""" 4
.el .IP "\f(CW=head1 \f(CIHeading Text\f(CW\fR" 4
.IX Xref "=head1 =head2 =head3 =head4 head1 head2 head3 head4"
.IX Item "=head1 Heading Text"
.PD 0
.ie n .IP """=head2 \f(CIHeading Text\f(CW""" 4
.el .IP "\f(CW=head2 \f(CIHeading Text\f(CW\fR" 4
.IX Item "=head2 Heading Text"
.ie n .IP """=head3 \f(CIHeading Text\f(CW""" 4
.el .IP "\f(CW=head3 \f(CIHeading Text\f(CW\fR" 4
.IX Item "=head3 Heading Text"
.ie n .IP """=head4 \f(CIHeading Text\f(CW""" 4
.el .IP "\f(CW=head4 \f(CIHeading Text\f(CW\fR" 4
.IX Item "=head4 Heading Text"
.PD
Head1 through head4 produce headings, head1 being the highest
level.  The text in the rest of this paragraph is the content of the
heading.  For example:
.Sp
.Vb 1
\&  =head2 Object Attributes
.Ve
.Sp
The text \*(L"Object Attributes\*(R" comprises the heading there.  (Note that
head3 and head4 are recent additions, not supported in older Pod
translators.)  The text in these heading commands can use
formatting codes, as seen here:
.Sp
.Vb 1
\&  =head2 Possible Values for C<$/>
.Ve
.Sp
Such commands are explained in the
"Formatting Codes" section, below.
.ie n .IP """=over \f(CIindentlevel\f(CW""" 4
.el .IP "\f(CW=over \f(CIindentlevel\f(CW\fR" 4
.IX Xref "=over =item =back over item back"
.IX Item "=over indentlevel"
.PD 0
.ie n .IP """=item \f(CIstuff...\f(CW""" 4
.el .IP "\f(CW=item \f(CIstuff...\f(CW\fR" 4
.IX Item "=item stuff..."
.ie n .IP """=back""" 4
.el .IP "\f(CW=back\fR" 4
.IX Item "=back"
.PD
Item, over, and back require a little more explanation:  \*(L"=over\*(R" starts
a region specifically for the generation of a list using \*(L"=item\*(R"
commands, or for indenting (groups of) normal paragraphs.  At the end
of your list, use \*(L"=back\*(R" to end it.  The \fIindentlevel\fR option to
\&\*(L"=over\*(R" indicates how far over to indent, generally in ems (where
one em is the width of an \*(L"M\*(R" in the document's base font) or roughly
comparable units; if there is no \fIindentlevel\fR option, it defaults
to four.  (And some formatters may just ignore whatever \fIindentlevel\fR
you provide.)  In the \fIstuff\fR in \f(CW\*(C`=item \f(CIstuff...\f(CW\*(C'\fR, you may
use formatting codes, as seen here:
.Sp
.Vb 1
\&  =item Using C<$|> to Control Buffering
.Ve
.Sp
Such commands are explained in the
"Formatting Codes" section, below.
.Sp
Note also that there are some basic rules to using \*(L"=over\*(R" ...
\&\*(L"=back\*(R" regions:
.RS 4
.IP "\(bu" 4
Don't use \*(L"=item\*(R"s outside of an \*(L"=over\*(R" ... \*(L"=back\*(R" region.
.IP "\(bu" 4
The first thing after the \*(L"=over\*(R" command should be an \*(L"=item\*(R", unless
there aren't going to be any items at all in this \*(L"=over\*(R" ... \*(L"=back\*(R"
region.
.IP "\(bu" 4
Don't put "=head\fIn\fR\*(L" commands inside an \*(R"=over\*(L" ... \*(R"=back" region.
.IP "\(bu" 4
And perhaps most importantly, keep the items consistent: either use
\&\*(L"=item *\*(R" for all of them, to produce bullets; or use \*(L"=item 1.\*(R",
\&\*(L"=item 2.\*(R", etc., to produce numbered lists; or use \*(L"=item foo\*(R",
\&\*(L"=item bar\*(R", etc.\-\-namely, things that look nothing like bullets or
numbers.
.Sp
If you start with bullets or numbers, stick with them, as
formatters use the first \*(L"=item\*(R" type to decide how to format the
list.
.RE
.RS 4
.RE
.ie n .IP """=cut""" 4
.el .IP "\f(CW=cut\fR" 4
.IX Xref "=cut cut"
.IX Item "=cut"
To end a Pod block, use a blank line,
then a line beginning with \*(L"=cut\*(R", and a blank
line after it.  This lets Perl (and the Pod formatter) know that
this is where Perl code is resuming.  (The blank line before the \*(L"=cut\*(R"
is not technically necessary, but many older Pod processors require it.)
.ie n .IP """=pod""" 4
.el .IP "\f(CW=pod\fR" 4
.IX Xref "=pod pod"
.IX Item "=pod"
The \*(L"=pod\*(R" command by itself doesn't do much of anything, but it
signals to Perl (and Pod formatters) that a Pod block starts here.  A
Pod block starts with \fIany\fR command paragraph, so a \*(L"=pod\*(R" command is
usually used just when you want to start a Pod block with an ordinary
paragraph or a verbatim paragraph.  For example:
.Sp
.Vb 1
\&  =item stuff()
\&
\&  This function does stuff.
\&
\&  =cut
\&
\&  sub stuff {
\&    ...
\&  }
\&
\&  =pod
\&
\&  Remember to check its return value, as in:
\&
\&    stuff() || die "Couldn\*(Aqt do stuff!";
\&
\&  =cut
.Ve
.ie n .IP """=begin \f(CIformatname\f(CW""" 4
.el .IP "\f(CW=begin \f(CIformatname\f(CW\fR" 4
.IX Xref "=begin =end =for begin end for"
.IX Item "=begin formatname"
.PD 0
.ie n .IP """=end \f(CIformatname\f(CW""" 4
.el .IP "\f(CW=end \f(CIformatname\f(CW\fR" 4
.IX Item "=end formatname"
.ie n .IP """=for \f(CIformatname\f(CW \f(CItext...\f(CW""" 4
.el .IP "\f(CW=for \f(CIformatname\f(CW \f(CItext...\f(CW\fR" 4
.IX Item "=for formatname text..."
.PD
For, begin, and end will let you have regions of text/code/data that
are not generally interpreted as normal Pod text, but are passed
directly to particular formatters, or are otherwise special.  A
formatter that can use that format will use the region, otherwise it
will be completely ignored.
.Sp
A command "=begin \fIformatname\fR\*(L", some paragraphs, and a
command \*(R"=end \fIformatname\fR", mean that the text/data in between
is meant for formatters that understand the special format
called \fIformatname\fR.  For example,
.Sp
.Vb 1
\&  =begin html
\&
\&  <hr> <img src="thang.png">
\&  <p> This is a raw HTML paragraph </p>
\&
\&  =end html
.Ve
.Sp
The command "=for \fIformatname\fR \fItext...\fR"
specifies that the remainder of just this paragraph (starting
right after \fIformatname\fR) is in that special format.
.Sp
.Vb 2
\&  =for html <hr> <img src="thang.png">
\&  <p> This is a raw HTML paragraph </p>
.Ve
.Sp
This means the same thing as the above \*(L"=begin html\*(R" ... \*(L"=end html\*(R"
region.
.Sp
That is, with \*(L"=for\*(R", you can have only one paragraph's worth
of text (i.e., the text in \*(L"=foo targetname text...\*(R"), but with
\&\*(L"=begin targetname\*(R" ... \*(L"=end targetname\*(R", you can have any amount
of stuff in between.  (Note that there still must be a blank line
after the \*(L"=begin\*(R" command and a blank line before the \*(L"=end\*(R"
command.
.Sp
Here are some examples of how to use these:
.Sp
.Vb 1
\&  =begin html
\&
\&  <br>Figure 1.<br><IMG SRC="figure1.png"><br>
\&
\&  =end html
\&
\&  =begin text
\&
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    |  foo        |
\&    |        bar  |
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&  ^^^^ Figure 1. ^^^^
\&
\&  =end text
.Ve
.Sp
Some format names that formatters currently are known to accept
include \*(L"roff\*(R", \*(L"man\*(R", \*(L"latex\*(R", \*(L"tex\*(R", \*(L"text\*(R", and \*(L"html\*(R".  (Some
formatters will treat some of these as synonyms.)
.Sp
A format name of \*(L"comment\*(R" is common for just making notes (presumably
to yourself) that won't appear in any formatted version of the Pod
document:
.Sp
.Vb 2
\&  =for comment
\&  Make sure that all the available options are documented!
.Ve
.Sp
Some \fIformatnames\fR will require a leading colon (as in
\&\f(CW"=for :formatname"\fR, or
\&\f(CW"=begin :formatname" ... "=end :formatname"\fR),
to signal that the text is not raw data, but instead \fIis\fR Pod text
(i.e., possibly containing formatting codes) that's just not for
normal formatting (e.g., may not be a normal-use paragraph, but might
be for formatting as a footnote).
.ie n .IP """=encoding \f(CIencodingname\f(CW""" 4
.el .IP "\f(CW=encoding \f(CIencodingname\f(CW\fR" 4
.IX Xref "=encoding encoding"
.IX Item "=encoding encodingname"
This command is used for declaring the encoding of a document.  Most
users won't need this; but if your encoding isn't US-ASCII or Latin\-1,
then put a \f(CW\*(C`=encoding \f(CIencodingname\f(CW\*(C'\fR command early in the document so
that pod formatters will know how to decode the document.  For
\&\fIencodingname\fR, use a name recognized by the Encode::Supported
module.  Examples:
.Sp
.Vb 1
\&  =encoding utf8
\&
\&  =encoding koi8\-r
\&  
\&  =encoding ShiftJIS
\&  
\&  =encoding big5
.Ve
.PP
\&\f(CW\*(C`=encoding\*(C'\fR affects the whole document, and must occur only once.
.PP
And don't forget, when using any other command, that the command lasts up
until the end of its \fIparagraph\fR, not its line.  So in the
examples below, you can see that every command needs the blank
line after it, to end its paragraph.
.PP
Some examples of lists include:
.PP
.Vb 1
\&  =over
\&
\&  =item *
\&
\&  First item
\&
\&  =item *
\&
\&  Second item
\&
\&  =back
\&
\&  =over
\&
\&  =item Foo()
\&
\&  Description of Foo function
\&
\&  =item Bar()
\&
\&  Description of Bar function
\&
\&  =back
.Ve
.SS "Formatting Codes"
.IX Xref "POD, formatting code formatting code POD, interior sequence interior sequence"
.IX Subsection "Formatting Codes"
In ordinary paragraphs and in some command paragraphs, various
formatting codes (a.k.a. \*(L"interior sequences\*(R") can be used:
.ie n .IP """I<text>"" \*(-- italic text" 4
.el .IP "\f(CWI<text>\fR \*(-- italic text" 4
.IX Xref "I I<> POD, formatting code, italic italic"
.IX Item "I<text>  italic text"
Used for emphasis ("\f(CW\*(C`be I<careful!>\*(C'\fR\*(L") and parameters
(\*(R"\f(CW\*(C`redo I<LABEL>\*(C'\fR")
.ie n .IP """B<text>"" \*(-- bold text" 4
.el .IP "\f(CWB<text>\fR \*(-- bold text" 4
.IX Xref "B B<> POD, formatting code, bold bold"
.IX Item "B<text>  bold text"
Used for switches ("\f(CW\*(C`perl\*(Aqs B<\-n> switch\*(C'\fR\*(L"), programs
(\*(R"\f(CW\*(C`some systems provide a B<chfn> for that\*(C'\fR\*(L"),
emphasis (\*(R"\f(CW\*(C`be B<careful!>\*(C'\fR\*(L"), and so on
(\*(R"\f(CW\*(C`and that feature is known as B<autovivification>\*(C'\fR").
.ie n .IP """C<code>"" \*(-- code text" 4
.el .IP "\f(CWC<code>\fR \*(-- code text" 4
.IX Xref "C C<> POD, formatting code, code code"
.IX Item "C<code>  code text"
Renders code in a typewriter font, or gives some other indication that
this represents program text ("\f(CW\*(C`C<gmtime($^T)>\*(C'\fR\*(L") or some other
form of computerese (\*(R"\f(CW\*(C`C<drwxr\-xr\-x>\*(C'\fR").
.ie n .IP """L<name>"" \*(-- a hyperlink" 4
.el .IP "\f(CWL<name>\fR \*(-- a hyperlink" 4
.IX Xref "L L<> POD, formatting code, hyperlink hyperlink"
.IX Item "L<name>  a hyperlink"
There are various syntaxes, listed below.  In the syntaxes given,
\&\f(CW\*(C`text\*(C'\fR, \f(CW\*(C`name\*(C'\fR, and \f(CW\*(C`section\*(C'\fR cannot contain the characters
\&'/' and '|'; and any '<' or '>' should be matched.
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`L<name>\*(C'\fR
.Sp
Link to a Perl manual page (e.g., \f(CW\*(C`L<Net::Ping>\*(C'\fR).  Note
that \f(CW\*(C`name\*(C'\fR should not contain spaces.  This syntax
is also occasionally used for references to Unix man pages, as in
\&\f(CW\*(C`L<crontab(5)>\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`L<name/"sec">\*(C'\fR or \f(CW\*(C`L<name/sec>\*(C'\fR
.Sp
Link to a section in other manual page.  E.g.,
\&\f(CW\*(C`L<perlsyn/"For Loops">\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`L</"sec">\*(C'\fR or \f(CW\*(C`L</sec>\*(C'\fR
.Sp
Link to a section in this manual page.  E.g.,
\&\f(CW\*(C`L</"Object Methods">\*(C'\fR
.RE
.RS 4
.Sp
A section is started by the named heading or item.  For
example, \f(CW\*(C`L<perlvar/$.>\*(C'\fR or \f(CW\*(C`L<perlvar/"$.">\*(C'\fR both
link to the section started by "\f(CW\*(C`=item $.\*(C'\fR" in perlvar.  And
\&\f(CW\*(C`L<perlsyn/For Loops>\*(C'\fR or \f(CW\*(C`L<perlsyn/"For Loops">\*(C'\fR
both link to the section started by "\f(CW\*(C`=head2 For Loops\*(C'\fR"
in perlsyn.
.Sp
To control what text is used for display, you
use "\f(CW\*(C`L<text|...>\*(C'\fR", as in:
.IP "\(bu" 4
\&\f(CW\*(C`L<text|name>\*(C'\fR
.Sp
Link this text to that manual page.  E.g.,
\&\f(CW\*(C`L<Perl Error Messages|perldiag>\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`L<text|name/"sec">\*(C'\fR or \f(CW\*(C`L<text|name/sec>\*(C'\fR
.Sp
Link this text to that section in that manual page.  E.g.,
\&\f(CW\*(C`L<postfix "if"|perlsyn/"Statement Modifiers">\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`L<text|/"sec">\*(C'\fR or \f(CW\*(C`L<text|/sec>\*(C'\fR
or \f(CW\*(C`L<text|"sec">\*(C'\fR
.Sp
Link this text to that section in this manual page.  E.g.,
\&\f(CW\*(C`L<the various attributes|/"Member Data">\*(C'\fR
.RE
.RS 4
.Sp
Or you can link to a web page:
.IP "\(bu" 4
\&\f(CW\*(C`L<scheme:...>\*(C'\fR
.Sp
\&\f(CW\*(C`L<text|scheme:...>\*(C'\fR
.Sp
Links to an absolute \s-1URL\s0.  For example, \f(CW\*(C`L<http://www.perl.org/>\*(C'\fR or
\&\f(CW\*(C`L<The Perl Home Page|http://www.perl.org/>\*(C'\fR.
.RE
.RS 4
.RE
.ie n .IP """E<escape>"" \*(-- a character escape" 4
.el .IP "\f(CWE<escape>\fR \*(-- a character escape" 4
.IX Xref "E E<> POD, formatting code, escape escape"
.IX Item "E<escape>  a character escape"
Very similar to \s-1HTML/XML\s0 \f(CW\*(C`&\f(CIfoo\f(CW;\*(C'\fR \*(L"entity references\*(R":
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`E<lt>\*(C'\fR \*(-- a literal < (less than)
.IP "\(bu" 4
\&\f(CW\*(C`E<gt>\*(C'\fR \*(-- a literal > (greater than)
.IP "\(bu" 4
\&\f(CW\*(C`E<verbar>\*(C'\fR \*(-- a literal | (\fIver\fRtical \fIbar\fR)
.IP "\(bu" 4
\&\f(CW\*(C`E<sol>\*(C'\fR \*(-- a literal / (\fIsol\fRidus)
.Sp
The above four are optional except in other formatting codes,
notably \f(CW\*(C`L<...>\*(C'\fR, and when preceded by a
capital letter.
.IP "\(bu" 4
\&\f(CW\*(C`E<htmlname>\*(C'\fR
.Sp
Some non-numeric \s-1HTML\s0 entity name, such as \f(CW\*(C`E<eacute>\*(C'\fR,
meaning the same thing as \f(CW\*(C`&eacute;\*(C'\fR in \s-1HTML\s0 \*(-- i.e., a lowercase
e with an acute (/\-shaped) accent.
.IP "\(bu" 4
\&\f(CW\*(C`E<number>\*(C'\fR
.Sp
The ASCII/Latin\-1/Unicode character with that number.  A
leading \*(L"0x\*(R" means that \fInumber\fR is hex, as in
\&\f(CW\*(C`E<0x201E>\*(C'\fR.  A leading \*(L"0\*(R" means that \fInumber\fR is octal,
as in \f(CW\*(C`E<075>\*(C'\fR.  Otherwise \fInumber\fR is interpreted as being
in decimal, as in \f(CW\*(C`E<181>\*(C'\fR.
.Sp
Note that older Pod formatters might not recognize octal or
hex numeric escapes, and that many formatters cannot reliably
render characters above 255.  (Some formatters may even have
to use compromised renderings of Latin\-1 characters, like
rendering \f(CW\*(C`E<eacute>\*(C'\fR as just a plain \*(L"e\*(R".)
.RE
.RS 4
.RE
.ie n .IP """F<filename>"" \*(-- used for filenames" 4
.el .IP "\f(CWF<filename>\fR \*(-- used for filenames" 4
.IX Xref "F F<> POD, formatting code, filename filename"
.IX Item "F<filename>  used for filenames"
Typically displayed in italics.  Example: "\f(CW\*(C`F<.cshrc>\*(C'\fR"
.ie n .IP """S<text>"" \*(-- text contains non-breaking spaces" 4
.el .IP "\f(CWS<text>\fR \*(-- text contains non-breaking spaces" 4
.IX Xref "S S<> POD, formatting code, non-breaking space non-breaking space"
.IX Item "S<text>  text contains non-breaking spaces"
This means that the words in \fItext\fR should not be broken
across lines.  Example: \f(CW\*(C`S<$x\ ?\ $y\ :\ $z>\*(C'\fR.
.ie n .IP """X<topic name>"" \*(-- an index entry" 4
.el .IP "\f(CWX<topic name>\fR \*(-- an index entry" 4
.IX Xref "X X<> POD, formatting code, index entry index entry"
.IX Item "X<topic name>  an index entry"
This is ignored by most formatters, but some may use it for building
indexes.  It always renders as empty-string.
Example: \f(CW\*(C`X<absolutizing relative URLs>\*(C'\fR
.ie n .IP """Z<>"" \*(-- a null (zero-effect) formatting code" 4
.el .IP "\f(CWZ<>\fR \*(-- a null (zero-effect) formatting code" 4
.IX Xref "Z Z<> POD, formatting code, null null"
.IX Item "Z<>  a null (zero-effect) formatting code"
This is rarely used.  It's one way to get around using an
E<...> code sometimes.  For example, instead of
"\f(CW\*(C`NE<lt>3\*(C'\fR\*(L" (for \*(R"N<3\*(L") you could write
\&\*(R"\f(CW\*(C`NZ<><3\*(C'\fR\*(L" (the \*(R"Z<>\*(L" breaks up the \*(R"N\*(L" and
the \*(R"<\*(L" so they can't be considered
the part of a (fictitious) \*(R"N<...>" code.
.PP
Most of the time, you will need only a single set of angle brackets to
delimit the beginning and end of formatting codes.  However,
sometimes you will want to put a real right angle bracket (a
greater-than sign, '>') inside of a formatting code.  This is particularly
common when using a formatting code to provide a different font-type for a
snippet of code.  As with all things in Perl, there is more than
one way to do it.  One way is to simply escape the closing bracket
using an \f(CW\*(C`E\*(C'\fR code:
.PP
.Vb 1
\&    C<$a E<lt>=E<gt> $b>
.Ve
.PP
This will produce: "\f(CW\*(C`$a <=> $b\*(C'\fR"
.PP
A more readable, and perhaps more \*(L"plain\*(R" way is to use an alternate
set of delimiters that doesn't require a single \*(L">\*(R" to be escaped.
Doubled angle brackets (\*(L"<<\*(R" and \*(L">>\*(R") may be used \fIif and only if there is
whitespace right after the opening delimiter and whitespace right
before the closing delimiter!\fR  For example, the following will
do the trick:
.IX Xref "POD, formatting code, escaping with multiple brackets"
.PP
.Vb 1
\&    C<< $a <=> $b >>
.Ve
.PP
In fact, you can use as many repeated angle-brackets as you like so
long as you have the same number of them in the opening and closing
delimiters, and make sure that whitespace immediately follows the last
\&'<' of the opening delimiter, and immediately precedes the first '>'
of the closing delimiter.  (The whitespace is ignored.)  So the
following will also work:
.IX Xref "POD, formatting code, escaping with multiple brackets"
.PP
.Vb 2
\&    C<<< $a <=> $b >>>
\&    C<<<<  $a <=> $b     >>>>
.Ve
.PP
And they all mean exactly the same as this:
.PP
.Vb 1
\&    C<$a E<lt>=E<gt> $b>
.Ve
.PP
The multiple-bracket form does not affect the interpretation of the contents of
the formatting code, only how it must end.  That means that the examples above
are also exactly the same as this:
.PP
.Vb 1
\&    C<< $a E<lt>=E<gt> $b >>
.Ve
.PP
As a further example, this means that if you wanted to put these bits of
code in \f(CW\*(C`C\*(C'\fR (code) style:
.PP
.Vb 2
\&    open(X, ">>thing.dat") || die $!
\&    $foo\->bar();
.Ve
.PP
you could do it like so:
.PP
.Vb 2
\&    C<<< open(X, ">>thing.dat") || die $! >>>
\&    C<< $foo\->bar(); >>
.Ve
.PP
which is presumably easier to read than the old way:
.PP
.Vb 2
\&    C<open(X, "E<gt>E<gt>thing.dat") || die $!>
\&    C<$foo\-E<gt>bar();>
.Ve
.PP
This is currently supported by pod2text (Pod::Text), pod2man (Pod::Man),
and any other pod2xxx or Pod::Xxxx translators that use
Pod::Parser 1.093 or later, or Pod::Tree 1.02 or later.
.SS "The Intent"
.IX Xref "POD, intent of"
.IX Subsection "The Intent"
The intent is simplicity of use, not power of expression.  Paragraphs
look like paragraphs (block format), so that they stand out
visually, and so that I could run them through \f(CW\*(C`fmt\*(C'\fR easily to reformat
them (that's F7 in my version of \fBvi\fR, or Esc Q in my version of
\&\fBemacs\fR).  I wanted the translator to always leave the \f(CW\*(C`\*(Aq\*(C'\fR and \f(CW\*(C`\`\*(C'\fR and
\&\f(CW\*(C`"\*(C'\fR quotes alone, in verbatim mode, so I could slurp in a
working program, shift it over four spaces, and have it print out, er,
verbatim.  And presumably in a monospace font.
.PP
The Pod format is not necessarily sufficient for writing a book.  Pod
is just meant to be an idiot-proof common source for nroff, \s-1HTML\s0,
TeX, and other markup languages, as used for online
documentation.  Translators exist for \fBpod2text\fR, \fBpod2html\fR,
\&\fBpod2man\fR (that's for \fInroff\fR\|(1) and \fItroff\fR\|(1)), \fBpod2latex\fR, and
\&\fBpod2fm\fR.  Various others are available in \s-1CPAN\s0.
.SS "Embedding Pods in Perl Modules"
.IX Xref "POD, embedding"
.IX Subsection "Embedding Pods in Perl Modules"
You can embed Pod documentation in your Perl modules and scripts.
Start your documentation with an empty line, a \*(L"=head1\*(R" command at the
beginning, and end it with a \*(L"=cut\*(R" command and an empty line.  Perl
will ignore the Pod text.  See any of the supplied library modules for
examples.  If you're going to put your Pod at the end of the file, and
you're using an _\|_END_\|_ or _\|_DATA_\|_ cut mark, make sure to put an
empty line there before the first Pod command.
.PP
.Vb 1
\&  _\|_END_\|_
\&
\&  =head1 NAME
\&
\&  Time::Local \- efficiently compute time from local and GMT time
.Ve
.PP
Without that empty line before the \*(L"=head1\*(R", many translators wouldn't
have recognized the \*(L"=head1\*(R" as starting a Pod block.
.SS "Hints for Writing Pod"
.IX Subsection "Hints for Writing Pod"
.IP "\(bu" 4

.IX Xref "podchecker POD, validating"
.Sp
The \fBpodchecker\fR command is provided for checking Pod syntax for errors
and warnings.  For example, it checks for completely blank lines in
Pod blocks and for unknown commands and formatting codes.  You should
still also pass your document through one or more translators and proofread
the result, or print out the result and proofread that.  Some of the
problems found may be bugs in the translators, which you may or may not
wish to work around.
.IP "\(bu" 4
If you're more familiar with writing in \s-1HTML\s0 than with writing in Pod, you
can try your hand at writing documentation in simple \s-1HTML\s0, and converting
it to Pod with the experimental Pod::HTML2Pod module,
(available in \s-1CPAN\s0), and looking at the resulting code.  The experimental
Pod::PXML module in \s-1CPAN\s0 might also be useful.
.IP "\(bu" 4
Many older Pod translators require the lines before every Pod
command and after every Pod command (including \*(L"=cut\*(R"!) to be a blank
line.  Having something like this:
.Sp
.Vb 2
\& # \- \- \- \- \- \- \- \- \- \- \- \-
\& =item $firecracker\->boom()
\&
\& This noisily detonates the firecracker object.
\& =cut
\& sub boom {
\& ...
.Ve
.Sp
\&...will make such Pod translators completely fail to see the Pod block
at all.
.Sp
Instead, have it like this:
.Sp
.Vb 1
\& # \- \- \- \- \- \- \- \- \- \- \- \-
\&
\& =item $firecracker\->boom()
\&
\& This noisily detonates the firecracker object.
\&
\& =cut
\&
\& sub boom {
\& ...
.Ve
.IP "\(bu" 4
Some older Pod translators require paragraphs (including command
paragraphs like \*(L"=head2 Functions\*(R") to be separated by \fIcompletely\fR
empty lines.  If you have an apparently empty line with some spaces
on it, this might not count as a separator for those translators, and
that could cause odd formatting.
.IP "\(bu" 4
Older translators might add wording around an L<> link, so that
\&\f(CW\*(C`L<Foo::Bar>\*(C'\fR may become \*(L"the Foo::Bar manpage\*(R", for example.
So you shouldn't write things like \f(CW\*(C`the L<foo>
documentation\*(C'\fR, if you want the translated document to read sensibly.
Instead, write \f(CW\*(C`the L<Foo::Bar|Foo::Bar> documentation\*(C'\fR or
\&\f(CW\*(C`L<the Foo::Bar documentation|Foo::Bar>\*(C'\fR, to control how the
link comes out.
.IP "\(bu" 4
Going past the 70th column in a verbatim block might be ungracefully
wrapped by some formatters.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlpodspec, \*(L"PODs: Embedded Documentation\*(R" in perlsyn,
perlnewmod, perldoc, pod2html, pod2man, podchecker.
.SH "AUTHOR"
.IX Header "AUTHOR"
Larry Wall, Sean M. Burke
                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlpod5.18.1                                0100644 0001750 0001750 00000071623 12566207443 022733  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPOD 1"
.TH PERLPOD 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpod \- the Plain Old Documentation format
.IX Xref "POD plain old documentation"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Pod is a simple-to-use markup language used for writing documentation
for Perl, Perl programs, and Perl modules.
.PP
Translators are available for converting Pod to various formats
like plain text, \s-1HTML,\s0 man pages, and more.
.PP
Pod markup consists of three basic kinds of paragraphs:
ordinary,
verbatim, and 
command.
.SS "Ordinary Paragraph"
.IX Xref "POD, ordinary paragraph"
.IX Subsection "Ordinary Paragraph"
Most paragraphs in your documentation will be ordinary blocks
of text, like this one.  You can simply type in your text without
any markup whatsoever, and with just a blank line before and
after.  When it gets formatted, it will undergo minimal formatting, 
like being rewrapped, probably put into a proportionally spaced
font, and maybe even justified.
.PP
You can use formatting codes in ordinary paragraphs, for \fBbold\fR,
\&\fIitalic\fR, \f(CW\*(C`code\-style\*(C'\fR, hyperlinks, and more.  Such
codes are explained in the "Formatting Codes"
section, below.
.SS "Verbatim Paragraph"
.IX Xref "POD, verbatim paragraph verbatim"
.IX Subsection "Verbatim Paragraph"
Verbatim paragraphs are usually used for presenting a codeblock or
other text which does not require any special parsing or formatting,
and which shouldn't be wrapped.
.PP
A verbatim paragraph is distinguished by having its first character
be a space or a tab.  (And commonly, all its lines begin with spaces
and/or tabs.)  It should be reproduced exactly, with tabs assumed to
be on 8\-column boundaries.  There are no special formatting codes,
so you can't italicize or anything like that.  A \e means \e, and
nothing else.
.SS "Command Paragraph"
.IX Xref "POD, command"
.IX Subsection "Command Paragraph"
A command paragraph is used for special treatment of whole chunks
of text, usually as headings or parts of lists.
.PP
All command paragraphs (which are typically only one line long) start
with \*(L"=\*(R", followed by an identifier, followed by arbitrary text that
the command can use however it pleases.  Currently recognized commands
are
.PP
.Vb 10
\&    =pod
\&    =head1 Heading Text
\&    =head2 Heading Text
\&    =head3 Heading Text
\&    =head4 Heading Text
\&    =over indentlevel
\&    =item stuff
\&    =back
\&    =begin format
\&    =end format
\&    =for format text...
\&    =encoding type
\&    =cut
.Ve
.PP
To explain them each in detail:
.ie n .IP """=head1 \f(CIHeading Text\f(CW""" 4
.el .IP "\f(CW=head1 \f(CIHeading Text\f(CW\fR" 4
.IX Xref "=head1 =head2 =head3 =head4 head1 head2 head3 head4"
.IX Item "=head1 Heading Text"
.PD 0
.ie n .IP """=head2 \f(CIHeading Text\f(CW""" 4
.el .IP "\f(CW=head2 \f(CIHeading Text\f(CW\fR" 4
.IX Item "=head2 Heading Text"
.ie n .IP """=head3 \f(CIHeading Text\f(CW""" 4
.el .IP "\f(CW=head3 \f(CIHeading Text\f(CW\fR" 4
.IX Item "=head3 Heading Text"
.ie n .IP """=head4 \f(CIHeading Text\f(CW""" 4
.el .IP "\f(CW=head4 \f(CIHeading Text\f(CW\fR" 4
.IX Item "=head4 Heading Text"
.PD
Head1 through head4 produce headings, head1 being the highest
level.  The text in the rest of this paragraph is the content of the
heading.  For example:
.Sp
.Vb 1
\&  =head2 Object Attributes
.Ve
.Sp
The text \*(L"Object Attributes\*(R" comprises the heading there.
The text in these heading commands can use formatting codes, as seen here:
.Sp
.Vb 1
\&  =head2 Possible Values for C<$/>
.Ve
.Sp
Such commands are explained in the
"Formatting Codes" section, below.
.ie n .IP """=over \f(CIindentlevel\f(CW""" 4
.el .IP "\f(CW=over \f(CIindentlevel\f(CW\fR" 4
.IX Xref "=over =item =back over item back"
.IX Item "=over indentlevel"
.PD 0
.ie n .IP """=item \f(CIstuff...\f(CW""" 4
.el .IP "\f(CW=item \f(CIstuff...\f(CW\fR" 4
.IX Item "=item stuff..."
.ie n .IP """=back""" 4
.el .IP "\f(CW=back\fR" 4
.IX Item "=back"
.PD
Item, over, and back require a little more explanation:  \*(L"=over\*(R" starts
a region specifically for the generation of a list using \*(L"=item\*(R"
commands, or for indenting (groups of) normal paragraphs.  At the end
of your list, use \*(L"=back\*(R" to end it.  The \fIindentlevel\fR option to
\&\*(L"=over\*(R" indicates how far over to indent, generally in ems (where
one em is the width of an \*(L"M\*(R" in the document's base font) or roughly
comparable units; if there is no \fIindentlevel\fR option, it defaults
to four.  (And some formatters may just ignore whatever \fIindentlevel\fR
you provide.)  In the \fIstuff\fR in \f(CW\*(C`=item \f(CIstuff...\f(CW\*(C'\fR, you may
use formatting codes, as seen here:
.Sp
.Vb 1
\&  =item Using C<$|> to Control Buffering
.Ve
.Sp
Such commands are explained in the
"Formatting Codes" section, below.
.Sp
Note also that there are some basic rules to using \*(L"=over\*(R" ...
\&\*(L"=back\*(R" regions:
.RS 4
.IP "\(bu" 4
Don't use \*(L"=item\*(R"s outside of an \*(L"=over\*(R" ... \*(L"=back\*(R" region.
.IP "\(bu" 4
The first thing after the \*(L"=over\*(R" command should be an \*(L"=item\*(R", unless
there aren't going to be any items at all in this \*(L"=over\*(R" ... \*(L"=back\*(R"
region.
.IP "\(bu" 4
Don't put "=head\fIn\fR\*(L" commands inside an \*(R"=over\*(L" ... \*(R"=back" region.
.IP "\(bu" 4
And perhaps most importantly, keep the items consistent: either use
\&\*(L"=item *\*(R" for all of them, to produce bullets; or use \*(L"=item 1.\*(R",
\&\*(L"=item 2.\*(R", etc., to produce numbered lists; or use \*(L"=item foo\*(R",
\&\*(L"=item bar\*(R", etc.\-\-namely, things that look nothing like bullets or
numbers.
.Sp
If you start with bullets or numbers, stick with them, as
formatters use the first \*(L"=item\*(R" type to decide how to format the
list.
.RE
.RS 4
.RE
.ie n .IP """=cut""" 4
.el .IP "\f(CW=cut\fR" 4
.IX Xref "=cut cut"
.IX Item "=cut"
To end a Pod block, use a blank line,
then a line beginning with \*(L"=cut\*(R", and a blank
line after it.  This lets Perl (and the Pod formatter) know that
this is where Perl code is resuming.  (The blank line before the \*(L"=cut\*(R"
is not technically necessary, but many older Pod processors require it.)
.ie n .IP """=pod""" 4
.el .IP "\f(CW=pod\fR" 4
.IX Xref "=pod pod"
.IX Item "=pod"
The \*(L"=pod\*(R" command by itself doesn't do much of anything, but it
signals to Perl (and Pod formatters) that a Pod block starts here.  A
Pod block starts with \fIany\fR command paragraph, so a \*(L"=pod\*(R" command is
usually used just when you want to start a Pod block with an ordinary
paragraph or a verbatim paragraph.  For example:
.Sp
.Vb 1
\&  =item stuff()
\&
\&  This function does stuff.
\&
\&  =cut
\&
\&  sub stuff {
\&    ...
\&  }
\&
\&  =pod
\&
\&  Remember to check its return value, as in:
\&
\&    stuff() || die "Couldn\*(Aqt do stuff!";
\&
\&  =cut
.Ve
.ie n .IP """=begin \f(CIformatname\f(CW""" 4
.el .IP "\f(CW=begin \f(CIformatname\f(CW\fR" 4
.IX Xref "=begin =end =for begin end for"
.IX Item "=begin formatname"
.PD 0
.ie n .IP """=end \f(CIformatname\f(CW""" 4
.el .IP "\f(CW=end \f(CIformatname\f(CW\fR" 4
.IX Item "=end formatname"
.ie n .IP """=for \f(CIformatname\f(CW \f(CItext...\f(CW""" 4
.el .IP "\f(CW=for \f(CIformatname\f(CW \f(CItext...\f(CW\fR" 4
.IX Item "=for formatname text..."
.PD
For, begin, and end will let you have regions of text/code/data that
are not generally interpreted as normal Pod text, but are passed
directly to particular formatters, or are otherwise special.  A
formatter that can use that format will use the region, otherwise it
will be completely ignored.
.Sp
A command "=begin \fIformatname\fR\*(L", some paragraphs, and a
command \*(R"=end \fIformatname\fR", mean that the text/data in between
is meant for formatters that understand the special format
called \fIformatname\fR.  For example,
.Sp
.Vb 1
\&  =begin html
\&
\&  <hr> <img src="thang.png">
\&  <p> This is a raw HTML paragraph </p>
\&
\&  =end html
.Ve
.Sp
The command "=for \fIformatname\fR \fItext...\fR"
specifies that the remainder of just this paragraph (starting
right after \fIformatname\fR) is in that special format.
.Sp
.Vb 2
\&  =for html <hr> <img src="thang.png">
\&  <p> This is a raw HTML paragraph </p>
.Ve
.Sp
This means the same thing as the above \*(L"=begin html\*(R" ... \*(L"=end html\*(R"
region.
.Sp
That is, with \*(L"=for\*(R", you can have only one paragraph's worth
of text (i.e., the text in \*(L"=foo targetname text...\*(R"), but with
\&\*(L"=begin targetname\*(R" ... \*(L"=end targetname\*(R", you can have any amount
of stuff in between.  (Note that there still must be a blank line
after the \*(L"=begin\*(R" command and a blank line before the \*(L"=end\*(R"
command.)
.Sp
Here are some examples of how to use these:
.Sp
.Vb 1
\&  =begin html
\&
\&  <br>Figure 1.<br><IMG SRC="figure1.png"><br>
\&
\&  =end html
\&
\&  =begin text
\&
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    |  foo        |
\&    |        bar  |
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&  ^^^^ Figure 1. ^^^^
\&
\&  =end text
.Ve
.Sp
Some format names that formatters currently are known to accept
include \*(L"roff\*(R", \*(L"man\*(R", \*(L"latex\*(R", \*(L"tex\*(R", \*(L"text\*(R", and \*(L"html\*(R".  (Some
formatters will treat some of these as synonyms.)
.Sp
A format name of \*(L"comment\*(R" is common for just making notes (presumably
to yourself) that won't appear in any formatted version of the Pod
document:
.Sp
.Vb 2
\&  =for comment
\&  Make sure that all the available options are documented!
.Ve
.Sp
Some \fIformatnames\fR will require a leading colon (as in
\&\f(CW"=for :formatname"\fR, or
\&\f(CW"=begin :formatname" ... "=end :formatname"\fR),
to signal that the text is not raw data, but instead \fIis\fR Pod text
(i.e., possibly containing formatting codes) that's just not for
normal formatting (e.g., may not be a normal-use paragraph, but might
be for formatting as a footnote).
.ie n .IP """=encoding \f(CIencodingname\f(CW""" 4
.el .IP "\f(CW=encoding \f(CIencodingname\f(CW\fR" 4
.IX Xref "=encoding encoding"
.IX Item "=encoding encodingname"
This command is used for declaring the encoding of a document.  Most
users won't need this; but if your encoding isn't US-ASCII or Latin\-1,
then put a \f(CW\*(C`=encoding \f(CIencodingname\f(CW\*(C'\fR command early in the document so
that pod formatters will know how to decode the document.  For
\&\fIencodingname\fR, use a name recognized by the Encode::Supported
module.  Examples:
.Sp
.Vb 1
\&  =encoding utf8
\&
\&  =encoding koi8\-r
\&
\&  =encoding ShiftJIS
\&
\&  =encoding big5
.Ve
.PP
\&\f(CW\*(C`=encoding\*(C'\fR affects the whole document, and must occur only once.
.PP
And don't forget, when using any other command, that the command lasts up
until the end of its \fIparagraph\fR, not its line.  So in the
examples below, you can see that every command needs the blank
line after it, to end its paragraph.
.PP
Some examples of lists include:
.PP
.Vb 1
\&  =over
\&
\&  =item *
\&
\&  First item
\&
\&  =item *
\&
\&  Second item
\&
\&  =back
\&
\&  =over
\&
\&  =item Foo()
\&
\&  Description of Foo function
\&
\&  =item Bar()
\&
\&  Description of Bar function
\&
\&  =back
.Ve
.SS "Formatting Codes"
.IX Xref "POD, formatting code formatting code POD, interior sequence interior sequence"
.IX Subsection "Formatting Codes"
In ordinary paragraphs and in some command paragraphs, various
formatting codes (a.k.a. \*(L"interior sequences\*(R") can be used:
.ie n .IP """I<text>"" \*(-- italic text" 4
.el .IP "\f(CWI<text>\fR \*(-- italic text" 4
.IX Xref "I I<> POD, formatting code, italic italic"
.IX Item "I<text> italic text"
Used for emphasis ("\f(CW\*(C`be I<careful!>\*(C'\fR\*(L") and parameters
(\*(R"\f(CW\*(C`redo I<LABEL>\*(C'\fR")
.ie n .IP """B<text>"" \*(-- bold text" 4
.el .IP "\f(CWB<text>\fR \*(-- bold text" 4
.IX Xref "B B<> POD, formatting code, bold bold"
.IX Item "B<text> bold text"
Used for switches ("\f(CW\*(C`perl\*(Aqs B<\-n> switch\*(C'\fR\*(L"), programs
(\*(R"\f(CW\*(C`some systems provide a B<chfn> for that\*(C'\fR\*(L"),
emphasis (\*(R"\f(CW\*(C`be B<careful!>\*(C'\fR\*(L"), and so on
(\*(R"\f(CW\*(C`and that feature is known as B<autovivification>\*(C'\fR").
.ie n .IP """C<code>"" \*(-- code text" 4
.el .IP "\f(CWC<code>\fR \*(-- code text" 4
.IX Xref "C C<> POD, formatting code, code code"
.IX Item "C<code> code text"
Renders code in a typewriter font, or gives some other indication that
this represents program text ("\f(CW\*(C`C<gmtime($^T)>\*(C'\fR\*(L") or some other
form of computerese (\*(R"\f(CW\*(C`C<drwxr\-xr\-x>\*(C'\fR").
.ie n .IP """L<name>"" \*(-- a hyperlink" 4
.el .IP "\f(CWL<name>\fR \*(-- a hyperlink" 4
.IX Xref "L L<> POD, formatting code, hyperlink hyperlink"
.IX Item "L<name> a hyperlink"
There are various syntaxes, listed below.  In the syntaxes given,
\&\f(CW\*(C`text\*(C'\fR, \f(CW\*(C`name\*(C'\fR, and \f(CW\*(C`section\*(C'\fR cannot contain the characters
\&'/' and '|'; and any '<' or '>' should be matched.
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`L<name>\*(C'\fR
.Sp
Link to a Perl manual page (e.g., \f(CW\*(C`L<Net::Ping>\*(C'\fR).  Note
that \f(CW\*(C`name\*(C'\fR should not contain spaces.  This syntax
is also occasionally used for references to Unix man pages, as in
\&\f(CW\*(C`L<crontab(5)>\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`L<name/"sec">\*(C'\fR or \f(CW\*(C`L<name/sec>\*(C'\fR
.Sp
Link to a section in other manual page.  E.g.,
\&\f(CW\*(C`L<perlsyn/"For Loops">\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`L</"sec">\*(C'\fR or \f(CW\*(C`L</sec>\*(C'\fR
.Sp
Link to a section in this manual page.  E.g.,
\&\f(CW\*(C`L</"Object Methods">\*(C'\fR
.RE
.RS 4
.Sp
A section is started by the named heading or item.  For
example, \f(CW\*(C`L<perlvar/$.>\*(C'\fR or \f(CW\*(C`L<perlvar/"$.">\*(C'\fR both
link to the section started by "\f(CW\*(C`=item $.\*(C'\fR" in perlvar.  And
\&\f(CW\*(C`L<perlsyn/For Loops>\*(C'\fR or \f(CW\*(C`L<perlsyn/"For Loops">\*(C'\fR
both link to the section started by "\f(CW\*(C`=head2 For Loops\*(C'\fR"
in perlsyn.
.Sp
To control what text is used for display, you
use "\f(CW\*(C`L<text|...>\*(C'\fR", as in:
.IP "\(bu" 4
\&\f(CW\*(C`L<text|name>\*(C'\fR
.Sp
Link this text to that manual page.  E.g.,
\&\f(CW\*(C`L<Perl Error Messages|perldiag>\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`L<text|name/"sec">\*(C'\fR or \f(CW\*(C`L<text|name/sec>\*(C'\fR
.Sp
Link this text to that section in that manual page.  E.g.,
\&\f(CW\*(C`L<postfix "if"|perlsyn/"Statement Modifiers">\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`L<text|/"sec">\*(C'\fR or \f(CW\*(C`L<text|/sec>\*(C'\fR
or \f(CW\*(C`L<text|"sec">\*(C'\fR
.Sp
Link this text to that section in this manual page.  E.g.,
\&\f(CW\*(C`L<the various attributes|/"Member Data">\*(C'\fR
.RE
.RS 4
.Sp
Or you can link to a web page:
.IP "\(bu" 4
\&\f(CW\*(C`L<scheme:...>\*(C'\fR
.Sp
\&\f(CW\*(C`L<text|scheme:...>\*(C'\fR
.Sp
Links to an absolute \s-1URL. \s0 For example, \f(CW\*(C`L<http://www.perl.org/>\*(C'\fR or
\&\f(CW\*(C`L<The Perl Home Page|http://www.perl.org/>\*(C'\fR.
.RE
.RS 4
.RE
.ie n .IP """E<escape>"" \*(-- a character escape" 4
.el .IP "\f(CWE<escape>\fR \*(-- a character escape" 4
.IX Xref "E E<> POD, formatting code, escape escape"
.IX Item "E<escape> a character escape"
Very similar to \s-1HTML/XML \s0\f(CW\*(C`&\f(CIfoo\f(CW;\*(C'\fR \*(L"entity references\*(R":
.RS 4
.IP "\(bu" 4
\&\f(CW\*(C`E<lt>\*(C'\fR \*(-- a literal < (less than)
.IP "\(bu" 4
\&\f(CW\*(C`E<gt>\*(C'\fR \*(-- a literal > (greater than)
.IP "\(bu" 4
\&\f(CW\*(C`E<verbar>\*(C'\fR \*(-- a literal | (\fIver\fRtical \fIbar\fR)
.IP "\(bu" 4
\&\f(CW\*(C`E<sol>\*(C'\fR \*(-- a literal / (\fIsol\fRidus)
.Sp
The above four are optional except in other formatting codes,
notably \f(CW\*(C`L<...>\*(C'\fR, and when preceded by a
capital letter.
.IP "\(bu" 4
\&\f(CW\*(C`E<htmlname>\*(C'\fR
.Sp
Some non-numeric \s-1HTML\s0 entity name, such as \f(CW\*(C`E<eacute>\*(C'\fR,
meaning the same thing as \f(CW\*(C`&eacute;\*(C'\fR in \s-1HTML\s0 \*(-- i.e., a lowercase
e with an acute (/\-shaped) accent.
.IP "\(bu" 4
\&\f(CW\*(C`E<number>\*(C'\fR
.Sp
The ASCII/Latin\-1/Unicode character with that number.  A
leading \*(L"0x\*(R" means that \fInumber\fR is hex, as in
\&\f(CW\*(C`E<0x201E>\*(C'\fR.  A leading \*(L"0\*(R" means that \fInumber\fR is octal,
as in \f(CW\*(C`E<075>\*(C'\fR.  Otherwise \fInumber\fR is interpreted as being
in decimal, as in \f(CW\*(C`E<181>\*(C'\fR.
.Sp
Note that older Pod formatters might not recognize octal or
hex numeric escapes, and that many formatters cannot reliably
render characters above 255.  (Some formatters may even have
to use compromised renderings of Latin\-1 characters, like
rendering \f(CW\*(C`E<eacute>\*(C'\fR as just a plain \*(L"e\*(R".)
.RE
.RS 4
.RE
.ie n .IP """F<filename>"" \*(-- used for filenames" 4
.el .IP "\f(CWF<filename>\fR \*(-- used for filenames" 4
.IX Xref "F F<> POD, formatting code, filename filename"
.IX Item "F<filename> used for filenames"
Typically displayed in italics.  Example: "\f(CW\*(C`F<.cshrc>\*(C'\fR"
.ie n .IP """S<text>"" \*(-- text contains non-breaking spaces" 4
.el .IP "\f(CWS<text>\fR \*(-- text contains non-breaking spaces" 4
.IX Xref "S S<> POD, formatting code, non-breaking space non-breaking space"
.IX Item "S<text> text contains non-breaking spaces"
This means that the words in \fItext\fR should not be broken
across lines.  Example: \f(CW\*(C`S<$x\ ?\ $y\ :\ $z>\*(C'\fR.
.ie n .IP """X<topic name>"" \*(-- an index entry" 4
.el .IP "\f(CWX<topic name>\fR \*(-- an index entry" 4
.IX Xref "X X<> POD, formatting code, index entry index entry"
.IX Item "X<topic name> an index entry"
This is ignored by most formatters, but some may use it for building
indexes.  It always renders as empty-string.
Example: \f(CW\*(C`X<absolutizing relative URLs>\*(C'\fR
.ie n .IP """Z<>"" \*(-- a null (zero-effect) formatting code" 4
.el .IP "\f(CWZ<>\fR \*(-- a null (zero-effect) formatting code" 4
.IX Xref "Z Z<> POD, formatting code, null null"
.IX Item "Z<> a null (zero-effect) formatting code"
This is rarely used.  It's one way to get around using an
E<...> code sometimes.  For example, instead of
"\f(CW\*(C`NE<lt>3\*(C'\fR\*(L" (for \*(R"N<3\*(L") you could write
\&\*(R"\f(CW\*(C`NZ<><3\*(C'\fR\*(L" (the \*(R"Z<>\*(L" breaks up the \*(R"N\*(L" and
the \*(R"<\*(L" so they can't be considered
the part of a (fictitious) \*(R"N<...>" code).
.PP
Most of the time, you will need only a single set of angle brackets to
delimit the beginning and end of formatting codes.  However,
sometimes you will want to put a real right angle bracket (a
greater-than sign, '>') inside of a formatting code.  This is particularly
common when using a formatting code to provide a different font-type for a
snippet of code.  As with all things in Perl, there is more than
one way to do it.  One way is to simply escape the closing bracket
using an \f(CW\*(C`E\*(C'\fR code:
.PP
.Vb 1
\&    C<$a E<lt>=E<gt> $b>
.Ve
.PP
This will produce: "\f(CW\*(C`$a <=> $b\*(C'\fR"
.PP
A more readable, and perhaps more \*(L"plain\*(R" way is to use an alternate
set of delimiters that doesn't require a single \*(L">\*(R" to be escaped.
Doubled angle brackets (\*(L"<<\*(R" and \*(L">>\*(R") may be used \fIif and only if there is
whitespace right after the opening delimiter and whitespace right
before the closing delimiter!\fR  For example, the following will
do the trick:
.IX Xref "POD, formatting code, escaping with multiple brackets"
.PP
.Vb 1
\&    C<< $a <=> $b >>
.Ve
.PP
In fact, you can use as many repeated angle-brackets as you like so
long as you have the same number of them in the opening and closing
delimiters, and make sure that whitespace immediately follows the last
\&'<' of the opening delimiter, and immediately precedes the first '>'
of the closing delimiter.  (The whitespace is ignored.)  So the
following will also work:
.IX Xref "POD, formatting code, escaping with multiple brackets"
.PP
.Vb 2
\&    C<<< $a <=> $b >>>
\&    C<<<<  $a <=> $b     >>>>
.Ve
.PP
And they all mean exactly the same as this:
.PP
.Vb 1
\&    C<$a E<lt>=E<gt> $b>
.Ve
.PP
The multiple-bracket form does not affect the interpretation of the contents of
the formatting code, only how it must end.  That means that the examples above
are also exactly the same as this:
.PP
.Vb 1
\&    C<< $a E<lt>=E<gt> $b >>
.Ve
.PP
As a further example, this means that if you wanted to put these bits of
code in \f(CW\*(C`C\*(C'\fR (code) style:
.PP
.Vb 2
\&    open(X, ">>thing.dat") || die $!
\&    $foo\->bar();
.Ve
.PP
you could do it like so:
.PP
.Vb 2
\&    C<<< open(X, ">>thing.dat") || die $! >>>
\&    C<< $foo\->bar(); >>
.Ve
.PP
which is presumably easier to read than the old way:
.PP
.Vb 2
\&    C<open(X, "E<gt>E<gt>thing.dat") || die $!>
\&    C<$foo\-E<gt>bar();>
.Ve
.PP
This is currently supported by pod2text (Pod::Text), pod2man (Pod::Man),
and any other pod2xxx or Pod::Xxxx translators that use
Pod::Parser 1.093 or later, or Pod::Tree 1.02 or later.
.SS "The Intent"
.IX Xref "POD, intent of"
.IX Subsection "The Intent"
The intent is simplicity of use, not power of expression.  Paragraphs
look like paragraphs (block format), so that they stand out
visually, and so that I could run them through \f(CW\*(C`fmt\*(C'\fR easily to reformat
them (that's F7 in my version of \fBvi\fR, or Esc Q in my version of
\&\fBemacs\fR).  I wanted the translator to always leave the \f(CW\*(C`\*(Aq\*(C'\fR and \f(CW\*(C`\`\*(C'\fR and
\&\f(CW\*(C`"\*(C'\fR quotes alone, in verbatim mode, so I could slurp in a
working program, shift it over four spaces, and have it print out, er,
verbatim.  And presumably in a monospace font.
.PP
The Pod format is not necessarily sufficient for writing a book.  Pod
is just meant to be an idiot-proof common source for nroff, \s-1HTML,\s0
TeX, and other markup languages, as used for online
documentation.  Translators exist for \fBpod2text\fR, \fBpod2html\fR,
\&\fBpod2man\fR (that's for \fInroff\fR\|(1) and \fItroff\fR\|(1)), \fBpod2latex\fR, and
\&\fBpod2fm\fR.  Various others are available in \s-1CPAN.\s0
.SS "Embedding Pods in Perl Modules"
.IX Xref "POD, embedding"
.IX Subsection "Embedding Pods in Perl Modules"
You can embed Pod documentation in your Perl modules and scripts.
Start your documentation with an empty line, a \*(L"=head1\*(R" command at the
beginning, and end it with a \*(L"=cut\*(R" command and an empty line.  Perl
will ignore the Pod text.  See any of the supplied library modules for
examples.  If you're going to put your Pod at the end of the file, and
you're using an _\|_END_\|_ or _\|_DATA_\|_ cut mark, make sure to put an
empty line there before the first Pod command.
.PP
.Vb 1
\&  _\|_END_\|_
\&
\&  =head1 NAME
\&
\&  Time::Local \- efficiently compute time from local and GMT time
.Ve
.PP
Without that empty line before the \*(L"=head1\*(R", many translators wouldn't
have recognized the \*(L"=head1\*(R" as starting a Pod block.
.SS "Hints for Writing Pod"
.IX Subsection "Hints for Writing Pod"
.IP "\(bu" 4

.IX Xref "podchecker POD, validating"
.Sp
The \fBpodchecker\fR command is provided for checking Pod syntax for errors
and warnings.  For example, it checks for completely blank lines in
Pod blocks and for unknown commands and formatting codes.  You should
still also pass your document through one or more translators and proofread
the result, or print out the result and proofread that.  Some of the
problems found may be bugs in the translators, which you may or may not
wish to work around.
.IP "\(bu" 4
If you're more familiar with writing in \s-1HTML\s0 than with writing in Pod, you
can try your hand at writing documentation in simple \s-1HTML,\s0 and converting
it to Pod with the experimental Pod::HTML2Pod module,
(available in \s-1CPAN\s0), and looking at the resulting code.  The experimental
Pod::PXML module in \s-1CPAN\s0 might also be useful.
.IP "\(bu" 4
Many older Pod translators require the lines before every Pod
command and after every Pod command (including \*(L"=cut\*(R"!) to be a blank
line.  Having something like this:
.Sp
.Vb 2
\& # \- \- \- \- \- \- \- \- \- \- \- \-
\& =item $firecracker\->boom()
\&
\& This noisily detonates the firecracker object.
\& =cut
\& sub boom {
\& ...
.Ve
.Sp
\&...will make such Pod translators completely fail to see the Pod block
at all.
.Sp
Instead, have it like this:
.Sp
.Vb 1
\& # \- \- \- \- \- \- \- \- \- \- \- \-
\&
\& =item $firecracker\->boom()
\&
\& This noisily detonates the firecracker object.
\&
\& =cut
\&
\& sub boom {
\& ...
.Ve
.IP "\(bu" 4
Some older Pod translators require paragraphs (including command
paragraphs like \*(L"=head2 Functions\*(R") to be separated by \fIcompletely\fR
empty lines.  If you have an apparently empty line with some spaces
on it, this might not count as a separator for those translators, and
that could cause odd formatting.
.IP "\(bu" 4
Older translators might add wording around an L<> link, so that
\&\f(CW\*(C`L<Foo::Bar>\*(C'\fR may become \*(L"the Foo::Bar manpage\*(R", for example.
So you shouldn't write things like \f(CW\*(C`the L<foo>
documentation\*(C'\fR, if you want the translated document to read sensibly.
Instead, write \f(CW\*(C`the L<Foo::Bar|Foo::Bar> documentation\*(C'\fR or
\&\f(CW\*(C`L<the Foo::Bar documentation|Foo::Bar>\*(C'\fR, to control how the
link comes out.
.IP "\(bu" 4
Going past the 70th column in a verbatim block might be ungracefully
wrapped by some formatters.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlpodspec, \*(L"PODs: Embedded Documentation\*(R" in perlsyn,
perlnewmod, perldoc, pod2html, pod2man, podchecker.
.SH "AUTHOR"
.IX Header "AUTHOR"
Larry Wall, Sean M. Burke
                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlpodspec.1                                0100644 0001750 0001750 00000232312 12566207443 023264  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPODSPEC 1"
.TH PERLPODSPEC 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpodspec \- Plain Old Documentation: format specification and notes
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document is detailed notes on the Pod markup language.  Most
people will only have to read perlpod to know how to write
in Pod, but this document may answer some incidental questions to do
with parsing and rendering Pod.
.PP
In this document, \*(L"must\*(R" / \*(L"must not\*(R", \*(L"should\*(R" /
\&\*(L"should not\*(R", and \*(L"may\*(R" have their conventional (cf. \s-1RFC 2119\s0)
meanings: \*(L"X must do Y\*(R" means that if X doesn't do Y, it's against
this specification, and should really be fixed.  \*(L"X should do Y\*(R"
means that it's recommended, but X may fail to do Y, if there's a
good reason.  \*(L"X may do Y\*(R" is merely a note that X can do Y at
will (although it is up to the reader to detect any connotation of
"and I think it would be \fInice\fR if X did Y\*(L" versus \*(R"it wouldn't
really \fIbother\fR me if X did Y").
.PP
Notably, when I say \*(L"the parser should do Y\*(R", the
parser may fail to do Y, if the calling application explicitly
requests that the parser \fInot\fR do Y.  I often phrase this as
\&\*(L"the parser should, by default, do Y.\*(R"  This doesn't \fIrequire\fR
the parser to provide an option for turning off whatever
feature Y is (like expanding tabs in verbatim paragraphs), although
it implicates that such an option \fImay\fR be provided.
.SH "Pod Definitions"
.IX Header "Pod Definitions"
Pod is embedded in files, typically Perl source files, although you
can write a file that's nothing but Pod.
.PP
A \fBline\fR in a file consists of zero or more non-newline characters,
terminated by either a newline or the end of the file.
.PP
A \fBnewline sequence\fR is usually a platform-dependent concept, but
Pod parsers should understand it to mean any of \s-1CR \s0(\s-1ASCII 13\s0), \s-1LF
\&\s0(\s-1ASCII 10\s0), or a \s-1CRLF \s0(\s-1ASCII 13\s0 followed immediately by \s-1ASCII 10\s0), in
addition to any other system-specific meaning.  The first \s-1CR/CRLF/LF\s0
sequence in the file may be used as the basis for identifying the
newline sequence for parsing the rest of the file.
.PP
A \fBblank line\fR is a line consisting entirely of zero or more spaces
(\s-1ASCII 32\s0) or tabs (\s-1ASCII 9\s0), and terminated by a newline or end-of-file.
A \fBnon-blank line\fR is a line containing one or more characters other
than space or tab (and terminated by a newline or end-of-file).
.PP
(\fINote:\fR Many older Pod parsers did not accept a line consisting of
spaces/tabs and then a newline as a blank line. The only lines they
considered blank were lines consisting of \fIno characters at all\fR,
terminated by a newline.)
.PP
\&\fBWhitespace\fR is used in this document as a blanket term for spaces,
tabs, and newline sequences.  (By itself, this term usually refers
to literal whitespace.  That is, sequences of whitespace characters
in Pod source, as opposed to \*(L"E<32>\*(R", which is a formatting
code that \fIdenotes\fR a whitespace character.)
.PP
A \fBPod parser\fR is a module meant for parsing Pod (regardless of
whether this involves calling callbacks or building a parse tree or
directly formatting it).  A \fBPod formatter\fR (or \fBPod translator\fR)
is a module or program that converts Pod to some other format (\s-1HTML,\s0
plaintext, TeX, PostScript, \s-1RTF\s0).  A \fBPod processor\fR might be a
formatter or translator, or might be a program that does something
else with the Pod (like counting words, scanning for index points,
etc.).
.PP
Pod content is contained in \fBPod blocks\fR.  A Pod block starts with a
line that matches <m/\eA=[a\-zA\-Z]/>, and continues up to the next line
that matches \f(CW\*(C`m/\eA=cut/\*(C'\fR or up to the end of the file if there is
no \f(CW\*(C`m/\eA=cut/\*(C'\fR line.
.PP
Within a Pod block, there are \fBPod paragraphs\fR.  A Pod paragraph
consists of non-blank lines of text, separated by one or more blank
lines.
.PP
For purposes of Pod processing, there are four types of paragraphs in
a Pod block:
.IP "\(bu" 4
A command paragraph (also called a \*(L"directive\*(R").  The first line of
this paragraph must match \f(CW\*(C`m/\eA=[a\-zA\-Z]/\*(C'\fR.  Command paragraphs are
typically one line, as in:
.Sp
.Vb 1
\&  =head1 NOTES
\&
\&  =item *
.Ve
.Sp
But they may span several (non-blank) lines:
.Sp
.Vb 3
\&  =for comment
\&  Hm, I wonder what it would look like if
\&  you tried to write a BNF for Pod from this.
\&
\&  =head3 Dr. Strangelove, or: How I Learned to
\&  Stop Worrying and Love the Bomb
.Ve
.Sp
\&\fISome\fR command paragraphs allow formatting codes in their content
(i.e., after the part that matches \f(CW\*(C`m/\eA=[a\-zA\-Z]\eS*\es*/\*(C'\fR), as in:
.Sp
.Vb 1
\&  =head1 Did You Remember to C<use strict;>?
.Ve
.Sp
In other words, the Pod processing handler for \*(L"head1\*(R" will apply the
same processing to \*(L"Did You Remember to C<use strict;>?\*(R" that it
would to an ordinary paragraph (i.e., formatting codes like
\&\*(L"C<...>\*(R") are parsed and presumably formatted appropriately, and
whitespace in the form of literal spaces and/or tabs is not
significant.
.IP "\(bu" 4
A \fBverbatim paragraph\fR.  The first line of this paragraph must be a
literal space or tab, and this paragraph must not be inside a "=begin
\&\fIidentifier\fR\*(L", ... \*(R"=end \fIidentifier\fR\*(L" sequence unless
\&\*(R"\fIidentifier\fR\*(L" begins with a colon (\*(R":").  That is, if a paragraph
starts with a literal space or tab, but \fIis\fR inside a
"=begin \fIidentifier\fR\*(L", ... \*(R"=end \fIidentifier\fR\*(L" region, then it's
a data paragraph, unless \*(R"\fIidentifier\fR" begins with a colon.
.Sp
Whitespace \fIis\fR significant in verbatim paragraphs (although, in
processing, tabs are probably expanded).
.IP "\(bu" 4
An \fBordinary paragraph\fR.  A paragraph is an ordinary paragraph
if its first line matches neither \f(CW\*(C`m/\eA=[a\-zA\-Z]/\*(C'\fR nor
\&\f(CW\*(C`m/\eA[ \et]/\*(C'\fR, \fIand\fR if it's not inside a "=begin \fIidentifier\fR\*(L",
\&... \*(R"=end \fIidentifier\fR\*(L" sequence unless \*(R"\fIidentifier\fR\*(L" begins with
a colon (\*(R":").
.IP "\(bu" 4
A \fBdata paragraph\fR.  This is a paragraph that \fIis\fR inside a "=begin
\&\fIidentifier\fR\*(L" ... \*(R"=end \fIidentifier\fR\*(L" sequence where
\&\*(R"\fIidentifier\fR" does \fInot\fR begin with a literal colon (\*(L":\*(R").  In
some sense, a data paragraph is not part of Pod at all (i.e.,
effectively it's \*(L"out-of-band\*(R"), since it's not subject to most kinds
of Pod parsing; but it is specified here, since Pod
parsers need to be able to call an event for it, or store it in some
form in a parse tree, or at least just parse \fIaround\fR it.
.PP
For example: consider the following paragraphs:
.PP
.Vb 1
\&  # <\- that\*(Aqs the 0th column
\&
\&  =head1 Foo
\&
\&  Stuff
\&
\&    $foo\->bar
\&
\&  =cut
.Ve
.PP
Here, \*(L"=head1 Foo\*(R" and \*(L"=cut\*(R" are command paragraphs because the first
line of each matches \f(CW\*(C`m/\eA=[a\-zA\-Z]/\*(C'\fR.  "\fI[space][space]\fR\f(CW$foo\fR\->bar\*(L"
is a verbatim paragraph, because its first line starts with a literal
whitespace character (and there's no \*(R"=begin\*(L"...\*(R"=end" region around).
.PP
The "=begin \fIidentifier\fR\*(L" ... \*(R"=end \fIidentifier\fR" commands stop
paragraphs that they surround from being parsed as ordinary or verbatim
paragraphs, if \fIidentifier\fR doesn't begin with a colon.  This
is discussed in detail in the section
\&\*(L"About Data Paragraphs and \*(R"=begin/=end\*(L" Regions\*(R".
.SH "Pod Commands"
.IX Header "Pod Commands"
This section is intended to supplement and clarify the discussion in
\&\*(L"Command Paragraph\*(R" in perlpod.  These are the currently recognized
Pod commands:
.ie n .IP """=head1"", ""=head2"", ""=head3"", ""=head4""" 4
.el .IP "``=head1'', ``=head2'', ``=head3'', ``=head4''" 4
.IX Item "=head1, =head2, =head3, =head4"
This command indicates that the text in the remainder of the paragraph
is a heading.  That text may contain formatting codes.  Examples:
.Sp
.Vb 1
\&  =head1 Object Attributes
\&
\&  =head3 What B<Not> to Do!
.Ve
.ie n .IP """=pod""" 4
.el .IP "``=pod''" 4
.IX Item "=pod"
This command indicates that this paragraph begins a Pod block.  (If we
are already in the middle of a Pod block, this command has no effect at
all.)  If there is any text in this command paragraph after \*(L"=pod\*(R",
it must be ignored.  Examples:
.Sp
.Vb 1
\&  =pod
\&
\&  This is a plain Pod paragraph.
\&
\&  =pod This text is ignored.
.Ve
.ie n .IP """=cut""" 4
.el .IP "``=cut''" 4
.IX Item "=cut"
This command indicates that this line is the end of this previously
started Pod block.  If there is any text after \*(L"=cut\*(R" on the line, it must be
ignored.  Examples:
.Sp
.Vb 1
\&  =cut
\&
\&  =cut The documentation ends here.
\&
\&  =cut
\&  # This is the first line of program text.
\&  sub foo { # This is the second.
.Ve
.Sp
It is an error to try to \fIstart\fR a Pod block with a \*(L"=cut\*(R" command.  In
that case, the Pod processor must halt parsing of the input file, and
must by default emit a warning.
.ie n .IP """=over""" 4
.el .IP "``=over''" 4
.IX Item "=over"
This command indicates that this is the start of a list/indent
region.  If there is any text following the \*(L"=over\*(R", it must consist
of only a nonzero positive numeral.  The semantics of this numeral is
explained in the \*(L"About =over...=back Regions\*(R" section, further
below.  Formatting codes are not expanded.  Examples:
.Sp
.Vb 1
\&  =over 3
\&
\&  =over 3.5
\&
\&  =over
.Ve
.ie n .IP """=item""" 4
.el .IP "``=item''" 4
.IX Item "=item"
This command indicates that an item in a list begins here.  Formatting
codes are processed.  The semantics of the (optional) text in the
remainder of this paragraph are
explained in the \*(L"About =over...=back Regions\*(R" section, further
below.  Examples:
.Sp
.Vb 1
\&  =item
\&
\&  =item *
\&
\&  =item      *    
\&
\&  =item 14
\&
\&  =item   3.
\&
\&  =item C<< $thing\->stuff(I<dodad>) >>
\&
\&  =item For transporting us beyond seas to be tried for pretended
\&  offenses
\&
\&  =item He is at this time transporting large armies of foreign
\&  mercenaries to complete the works of death, desolation and
\&  tyranny, already begun with circumstances of cruelty and perfidy
\&  scarcely paralleled in the most barbarous ages, and totally
\&  unworthy the head of a civilized nation.
.Ve
.ie n .IP """=back""" 4
.el .IP "``=back''" 4
.IX Item "=back"
This command indicates that this is the end of the region begun
by the most recent \*(L"=over\*(R" command.  It permits no text after the
\&\*(L"=back\*(R" command.
.ie n .IP """=begin formatname""" 4
.el .IP "``=begin formatname''" 4
.IX Item "=begin formatname"
.PD 0
.ie n .IP """=begin formatname parameter""" 4
.el .IP "``=begin formatname parameter''" 4
.IX Item "=begin formatname parameter"
.PD
This marks the following paragraphs (until the matching \*(L"=end
formatname\*(R") as being for some special kind of processing.  Unless
\&\*(L"formatname\*(R" begins with a colon, the contained non-command
paragraphs are data paragraphs.  But if \*(L"formatname\*(R" \fIdoes\fR begin
with a colon, then non-command paragraphs are ordinary paragraphs
or data paragraphs.  This is discussed in detail in the section
\&\*(L"About Data Paragraphs and \*(R"=begin/=end\*(L" Regions\*(R".
.Sp
It is advised that formatnames match the regexp
\&\f(CW\*(C`m/\eA:?[\-a\-zA\-Z0\-9_]+\ez/\*(C'\fR.  Everything following whitespace after the
formatname is a parameter that may be used by the formatter when dealing
with this region.  This parameter must not be repeated in the \*(L"=end\*(R"
paragraph.  Implementors should anticipate future expansion in the
semantics and syntax of the first parameter to \*(L"=begin\*(R"/\*(L"=end\*(R"/\*(L"=for\*(R".
.ie n .IP """=end formatname""" 4
.el .IP "``=end formatname''" 4
.IX Item "=end formatname"
This marks the end of the region opened by the matching
\&\*(L"=begin formatname\*(R" region.  If \*(L"formatname\*(R" is not the formatname
of the most recent open \*(L"=begin formatname\*(R" region, then this
is an error, and must generate an error message.  This
is discussed in detail in the section
\&\*(L"About Data Paragraphs and \*(R"=begin/=end\*(L" Regions\*(R".
.ie n .IP """=for formatname text...""" 4
.el .IP "``=for formatname text...''" 4
.IX Item "=for formatname text..."
This is synonymous with:
.Sp
.Vb 1
\&     =begin formatname
\&
\&     text...
\&
\&     =end formatname
.Ve
.Sp
That is, it creates a region consisting of a single paragraph; that
paragraph is to be treated as a normal paragraph if \*(L"formatname\*(R"
begins with a \*(L":\*(R"; if \*(L"formatname\*(R" \fIdoesn't\fR begin with a colon,
then \*(L"text...\*(R" will constitute a data paragraph.  There is no way
to use \*(L"=for formatname text...\*(R" to express \*(L"text...\*(R" as a verbatim
paragraph.
.ie n .IP """=encoding encodingname""" 4
.el .IP "``=encoding encodingname''" 4
.IX Item "=encoding encodingname"
This command, which should occur early in the document (at least
before any non-US-ASCII data!), declares that this document is
encoded in the encoding \fIencodingname\fR, which must be
an encoding name that Encode recognizes.  (Encode's list
of supported encodings, in Encode::Supported, is useful here.)
If the Pod parser cannot decode the declared encoding, it 
should emit a warning and may abort parsing the document
altogether.
.Sp
A document having more than one \*(L"=encoding\*(R" line should be
considered an error.  Pod processors may silently tolerate this if
the not-first \*(L"=encoding\*(R" lines are just duplicates of the
first one (e.g., if there's a \*(L"=encoding utf8\*(R" line, and later on
another \*(L"=encoding utf8\*(R" line).  But Pod processors should complain if
there are contradictory \*(L"=encoding\*(R" lines in the same document
(e.g., if there is a \*(L"=encoding utf8\*(R" early in the document and
\&\*(L"=encoding big5\*(R" later).  Pod processors that recognize BOMs
may also complain if they see an \*(L"=encoding\*(R" line
that contradicts the \s-1BOM \s0(e.g., if a document with a \s-1UTF\-16LE
BOM\s0 has an \*(L"=encoding shiftjis\*(R" line).
.PP
If a Pod processor sees any command other than the ones listed
above (like \*(L"=head\*(R", or \*(L"=haed1\*(R", or \*(L"=stuff\*(R", or \*(L"=cuttlefish\*(R",
or \*(L"=w123\*(R"), that processor must by default treat this as an
error.  It must not process the paragraph beginning with that
command, must by default warn of this as an error, and may
abort the parse.  A Pod parser may allow a way for particular
applications to add to the above list of known commands, and to
stipulate, for each additional command, whether formatting
codes should be processed.
.PP
Future versions of this specification may add additional
commands.
.SH "Pod Formatting Codes"
.IX Header "Pod Formatting Codes"
(Note that in previous drafts of this document and of perlpod,
formatting codes were referred to as \*(L"interior sequences\*(R", and
this term may still be found in the documentation for Pod parsers,
and in error messages from Pod processors.)
.PP
There are two syntaxes for formatting codes:
.IP "\(bu" 4
A formatting code starts with a capital letter (just US-ASCII [A\-Z])
followed by a \*(L"<\*(R", any number of characters, and ending with the first
matching \*(L">\*(R".  Examples:
.Sp
.Vb 1
\&    That\*(Aqs what I<you> think!
\&
\&    What\*(Aqs C<dump()> for?
\&
\&    X<C<chmod> and C<unlink()> Under Different Operating Systems>
.Ve
.IP "\(bu" 4
A formatting code starts with a capital letter (just US-ASCII [A\-Z])
followed by two or more \*(L"<\*(R"'s, one or more whitespace characters,
any number of characters, one or more whitespace characters,
and ending with the first matching sequence of two or more \*(L">\*(R"'s, where
the number of \*(L">\*(R"'s equals the number of \*(L"<\*(R"'s in the opening of this
formatting code.  Examples:
.Sp
.Vb 1
\&    That\*(Aqs what I<< you >> think!
\&
\&    C<<< open(X, ">>thing.dat") || die $! >>>
\&
\&    B<< $foo\->bar(); >>
.Ve
.Sp
With this syntax, the whitespace character(s) after the \*(L"C<<<\*(R"
and before the \*(L">>\*(R" (or whatever letter) are \fInot\fR renderable. They
do not signify whitespace, are merely part of the formatting codes
themselves.  That is, these are all synonymous:
.Sp
.Vb 7
\&    C<thing>
\&    C<< thing >>
\&    C<<           thing     >>
\&    C<<<   thing >>>
\&    C<<<<
\&    thing
\&               >>>>
.Ve
.Sp
and so on.
.Sp
Finally, the multiple-angle-bracket form does \fInot\fR alter the interpretation
of nested formatting codes, meaning that the following four example lines are
identical in meaning:
.Sp
.Vb 1
\&  B<example: C<$a E<lt>=E<gt> $b>>
\&
\&  B<example: C<< $a <=> $b >>>
\&
\&  B<example: C<< $a E<lt>=E<gt> $b >>>
\&
\&  B<<< example: C<< $a E<lt>=E<gt> $b >> >>>
.Ve
.PP
In parsing Pod, a notably tricky part is the correct parsing of
(potentially nested!) formatting codes.  Implementors should
consult the code in the \f(CW\*(C`parse_text\*(C'\fR routine in Pod::Parser as an
example of a correct implementation.
.ie n .IP """I<text>"" \*(-- italic text" 4
.el .IP "\f(CWI<text>\fR \*(-- italic text" 4
.IX Item "I<text> italic text"
See the brief discussion in \*(L"Formatting Codes\*(R" in perlpod.
.ie n .IP """B<text>"" \*(-- bold text" 4
.el .IP "\f(CWB<text>\fR \*(-- bold text" 4
.IX Item "B<text> bold text"
See the brief discussion in \*(L"Formatting Codes\*(R" in perlpod.
.ie n .IP """C<code>"" \*(-- code text" 4
.el .IP "\f(CWC<code>\fR \*(-- code text" 4
.IX Item "C<code> code text"
See the brief discussion in \*(L"Formatting Codes\*(R" in perlpod.
.ie n .IP """F<filename>"" \*(-- style for filenames" 4
.el .IP "\f(CWF<filename>\fR \*(-- style for filenames" 4
.IX Item "F<filename> style for filenames"
See the brief discussion in \*(L"Formatting Codes\*(R" in perlpod.
.ie n .IP """X<topic name>"" \*(-- an index entry" 4
.el .IP "\f(CWX<topic name>\fR \*(-- an index entry" 4
.IX Item "X<topic name> an index entry"
See the brief discussion in \*(L"Formatting Codes\*(R" in perlpod.
.Sp
This code is unusual in that most formatters completely discard
this code and its content.  Other formatters will render it with
invisible codes that can be used in building an index of
the current document.
.ie n .IP """Z<>"" \*(-- a null (zero-effect) formatting code" 4
.el .IP "\f(CWZ<>\fR \*(-- a null (zero-effect) formatting code" 4
.IX Item "Z<> a null (zero-effect) formatting code"
Discussed briefly in \*(L"Formatting Codes\*(R" in perlpod.
.Sp
This code is unusual is that it should have no content.  That is,
a processor may complain if it sees \f(CW\*(C`Z<potatoes>\*(C'\fR.  Whether
or not it complains, the \fIpotatoes\fR text should ignored.
.ie n .IP """L<name>"" \*(-- a hyperlink" 4
.el .IP "\f(CWL<name>\fR \*(-- a hyperlink" 4
.IX Item "L<name> a hyperlink"
The complicated syntaxes of this code are discussed at length in
\&\*(L"Formatting Codes\*(R" in perlpod, and implementation details are
discussed below, in \*(L"About L<...> Codes\*(R".  Parsing the
contents of L<content> is tricky.  Notably, the content has to be
checked for whether it looks like a \s-1URL,\s0 or whether it has to be split
on literal \*(L"|\*(R" and/or \*(L"/\*(R" (in the right order!), and so on,
\&\fIbefore\fR E<...> codes are resolved.
.ie n .IP """E<escape>"" \*(-- a character escape" 4
.el .IP "\f(CWE<escape>\fR \*(-- a character escape" 4
.IX Item "E<escape> a character escape"
See \*(L"Formatting Codes\*(R" in perlpod, and several points in
\&\*(L"Notes on Implementing Pod Processors\*(R".
.ie n .IP """S<text>"" \*(-- text contains non-breaking spaces" 4
.el .IP "\f(CWS<text>\fR \*(-- text contains non-breaking spaces" 4
.IX Item "S<text> text contains non-breaking spaces"
This formatting code is syntactically simple, but semantically
complex.  What it means is that each space in the printable
content of this code signifies a non-breaking space.
.Sp
Consider:
.Sp
.Vb 1
\&    C<$x ? $y    :  $z>
\&
\&    S<C<$x ? $y     :  $z>>
.Ve
.Sp
Both signify the monospace (c[ode] style) text consisting of
\&\*(L"$x\*(R", one space, \*(L"?\*(R", one space, \*(L":\*(R", one space, \*(L"$z\*(R".  The
difference is that in the latter, with the S code, those spaces
are not \*(L"normal\*(R" spaces, but instead are non-breaking spaces.
.PP
If a Pod processor sees any formatting code other than the ones
listed above (as in \*(L"N<...>\*(R", or \*(L"Q<...>\*(R", etc.), that
processor must by default treat this as an error.
A Pod parser may allow a way for particular
applications to add to the above list of known formatting codes;
a Pod parser might even allow a way to stipulate, for each additional
command, whether it requires some form of special processing, as
L<...> does.
.PP
Future versions of this specification may add additional
formatting codes.
.PP
Historical note:  A few older Pod processors would not see a \*(L">\*(R" as
closing a \*(L"C<\*(R" code, if the \*(L">\*(R" was immediately preceded by
a \*(L"\-\*(R".  This was so that this:
.PP
.Vb 1
\&    C<$foo\->bar>
.Ve
.PP
would parse as equivalent to this:
.PP
.Vb 1
\&    C<$foo\-E<gt>bar>
.Ve
.PP
instead of as equivalent to a \*(L"C\*(R" formatting code containing 
only \*(L"$foo\-\*(R", and then a \*(L"bar>\*(R" outside the \*(L"C\*(R" formatting code.  This
problem has since been solved by the addition of syntaxes like this:
.PP
.Vb 1
\&    C<< $foo\->bar >>
.Ve
.PP
Compliant parsers must not treat \*(L"\->\*(R" as special.
.PP
Formatting codes absolutely cannot span paragraphs.  If a code is
opened in one paragraph, and no closing code is found by the end of
that paragraph, the Pod parser must close that formatting code,
and should complain (as in \*(L"Unterminated I code in the paragraph
starting at line 123: 'Time objects are not...'\*(R").  So these
two paragraphs:
.PP
.Vb 1
\&  I<I told you not to do this!
\&
\&  Don\*(Aqt make me say it again!>
.Ve
.PP
\&...must \fInot\fR be parsed as two paragraphs in italics (with the I
code starting in one paragraph and starting in another.)  Instead,
the first paragraph should generate a warning, but that aside, the
above code must parse as if it were:
.PP
.Vb 1
\&  I<I told you not to do this!>
\&
\&  Don\*(Aqt make me say it again!E<gt>
.Ve
.PP
(In SGMLish jargon, all Pod commands are like block-level
elements, whereas all Pod formatting codes are like inline-level
elements.)
.SH "Notes on Implementing Pod Processors"
.IX Header "Notes on Implementing Pod Processors"
The following is a long section of miscellaneous requirements
and suggestions to do with Pod processing.
.IP "\(bu" 4
Pod formatters should tolerate lines in verbatim blocks that are of
any length, even if that means having to break them (possibly several
times, for very long lines) to avoid text running off the side of the
page.  Pod formatters may warn of such line-breaking.  Such warnings
are particularly appropriate for lines are over 100 characters long, which
are usually not intentional.
.IP "\(bu" 4
Pod parsers must recognize \fIall\fR of the three well-known newline
formats: \s-1CR, LF,\s0 and \s-1CRLF. \s0 See perlport.
.IP "\(bu" 4
Pod parsers should accept input lines that are of any length.
.IP "\(bu" 4
Since Perl recognizes a Unicode Byte Order Mark at the start of files
as signaling that the file is Unicode encoded as in \s-1UTF\-16 \s0(whether
big-endian or little-endian) or \s-1UTF\-8,\s0 Pod parsers should do the
same.  Otherwise, the character encoding should be understood as
being \s-1UTF\-8\s0 if the first highbit byte sequence in the file seems
valid as a \s-1UTF\-8\s0 sequence, or otherwise as Latin\-1.
.Sp
Future versions of this specification may specify
how Pod can accept other encodings.  Presumably treatment of other
encodings in Pod parsing would be as in \s-1XML\s0 parsing: whatever the
encoding declared by a particular Pod file, content is to be
stored in memory as Unicode characters.
.IP "\(bu" 4
The well known Unicode Byte Order Marks are as follows:  if the
file begins with the two literal byte values 0xFE 0xFF, this is
the \s-1BOM\s0 for big-endian \s-1UTF\-16. \s0 If the file begins with the two
literal byte value 0xFF 0xFE, this is the \s-1BOM\s0 for little-endian
\&\s-1UTF\-16. \s0 If the file begins with the three literal byte values
0xEF 0xBB 0xBF, this is the \s-1BOM\s0 for \s-1UTF\-8.\s0
.IP "\(bu" 4
A naive but sufficient heuristic for testing the first highbit
byte-sequence in a BOM-less file (whether in code or in Pod!), to see
whether that sequence is valid as \s-1UTF\-8 \s0(\s-1RFC 2279\s0) is to check whether
that the first byte in the sequence is in the range 0xC0 \- 0xFD
\&\fIand\fR whether the next byte is in the range
0x80 \- 0xBF.  If so, the parser may conclude that this file is in
\&\s-1UTF\-8,\s0 and all highbit sequences in the file should be assumed to
be \s-1UTF\-8. \s0 Otherwise the parser should treat the file as being
in Latin\-1.  In the unlikely circumstance that the first highbit
sequence in a truly non\-UTF\-8 file happens to appear to be \s-1UTF\-8,\s0 one
can cater to our heuristic (as well as any more intelligent heuristic)
by prefacing that line with a comment line containing a highbit
sequence that is clearly \fInot\fR valid as \s-1UTF\-8.  A\s0 line consisting
of simply \*(L"#\*(R", an e\-acute, and any non-highbit byte,
is sufficient to establish this file's encoding.
.IP "\(bu" 4
This document's requirements and suggestions about encodings
do not apply to Pod processors running on non-ASCII platforms,
notably \s-1EBCDIC\s0 platforms.
.IP "\(bu" 4
Pod processors must treat a \*(L"=for [label] [content...]\*(R" paragraph as
meaning the same thing as a \*(L"=begin [label]\*(R" paragraph, content, and
an \*(L"=end [label]\*(R" paragraph.  (The parser may conflate these two
constructs, or may leave them distinct, in the expectation that the
formatter will nevertheless treat them the same.)
.IP "\(bu" 4
When rendering Pod to a format that allows comments (i.e., to nearly
any format other than plaintext), a Pod formatter must insert comment
text identifying its name and version number, and the name and
version numbers of any modules it might be using to process the Pod.
Minimal examples:
.Sp
.Vb 1
\&  %% POD::Pod2PS v3.14159, using POD::Parser v1.92
\&
\&  <!\-\- Pod::HTML v3.14159, using POD::Parser v1.92 \-\->
\&
\&  {\edoccomm generated by Pod::Tree::RTF 3.14159 using Pod::Tree 1.08}
\&
\&  .\e" Pod::Man version 3.14159, using POD::Parser version 1.92
.Ve
.Sp
Formatters may also insert additional comments, including: the
release date of the Pod formatter program, the contact address for
the author(s) of the formatter, the current time, the name of input
file, the formatting options in effect, version of Perl used, etc.
.Sp
Formatters may also choose to note errors/warnings as comments,
besides or instead of emitting them otherwise (as in messages to
\&\s-1STDERR,\s0 or \f(CW\*(C`die\*(C'\fRing).
.IP "\(bu" 4
Pod parsers \fImay\fR emit warnings or error messages (\*(L"Unknown E code
E<zslig>!\*(R") to \s-1STDERR \s0(whether through printing to \s-1STDERR,\s0 or
\&\f(CW\*(C`warn\*(C'\fRing/\f(CW\*(C`carp\*(C'\fRing, or \f(CW\*(C`die\*(C'\fRing/\f(CW\*(C`croak\*(C'\fRing), but \fImust\fR allow
suppressing all such \s-1STDERR\s0 output, and instead allow an option for
reporting errors/warnings
in some other way, whether by triggering a callback, or noting errors
in some attribute of the document object, or some similarly unobtrusive
mechanism \*(-- or even by appending a \*(L"Pod Errors\*(R" section to the end of
the parsed form of the document.
.IP "\(bu" 4
In cases of exceptionally aberrant documents, Pod parsers may abort the
parse.  Even then, using \f(CW\*(C`die\*(C'\fRing/\f(CW\*(C`croak\*(C'\fRing is to be avoided; where
possible, the parser library may simply close the input file
and add text like \*(L"*** Formatting Aborted ***\*(R" to the end of the
(partial) in-memory document.
.IP "\(bu" 4
In paragraphs where formatting codes (like E<...>, B<...>)
are understood (i.e., \fInot\fR verbatim paragraphs, but \fIincluding\fR
ordinary paragraphs, and command paragraphs that produce renderable
text, like \*(L"=head1\*(R"), literal whitespace should generally be considered
\&\*(L"insignificant\*(R", in that one literal space has the same meaning as any
(nonzero) number of literal spaces, literal newlines, and literal tabs
(as long as this produces no blank lines, since those would terminate
the paragraph).  Pod parsers should compact literal whitespace in each
processed paragraph, but may provide an option for overriding this
(since some processing tasks do not require it), or may follow
additional special rules (for example, specially treating
period-space-space or period-newline sequences).
.IP "\(bu" 4
Pod parsers should not, by default, try to coerce apostrophe (') and
quote (\*(L") into smart quotes (little 9's, 66's, 99's, etc), nor try to
turn backtick (`) into anything else but a single backtick character
(distinct from an open quote character!), nor \*(R"\-\-" into anything but
two minus signs.  They \fImust never\fR do any of those things to text
in C<...> formatting codes, and never \fIever\fR to text in verbatim
paragraphs.
.IP "\(bu" 4
When rendering Pod to a format that has two kinds of hyphens (\-), one
that's a non-breaking hyphen, and another that's a breakable hyphen
(as in \*(L"object-oriented\*(R", which can be split across lines as
\&\*(L"object\-\*(R", newline, \*(L"oriented\*(R"), formatters are encouraged to
generally translate \*(L"\-\*(R" to non-breaking hyphen, but may apply
heuristics to convert some of these to breaking hyphens.
.IP "\(bu" 4
Pod formatters should make reasonable efforts to keep words of Perl
code from being broken across lines.  For example, \*(L"Foo::Bar\*(R" in some
formatting systems is seen as eligible for being broken across lines
as \*(L"Foo::\*(R" newline \*(L"Bar\*(R" or even \*(L"Foo::\-\*(R" newline \*(L"Bar\*(R".  This should
be avoided where possible, either by disabling all line-breaking in
mid-word, or by wrapping particular words with internal punctuation
in \*(L"don't break this across lines\*(R" codes (which in some formats may
not be a single code, but might be a matter of inserting non-breaking
zero-width spaces between every pair of characters in a word.)
.IP "\(bu" 4
Pod parsers should, by default, expand tabs in verbatim paragraphs as
they are processed, before passing them to the formatter or other
processor.  Parsers may also allow an option for overriding this.
.IP "\(bu" 4
Pod parsers should, by default, remove newlines from the end of
ordinary and verbatim paragraphs before passing them to the
formatter.  For example, while the paragraph you're reading now
could be considered, in Pod source, to end with (and contain)
the newline(s) that end it, it should be processed as ending with
(and containing) the period character that ends this sentence.
.IP "\(bu" 4
Pod parsers, when reporting errors, should make some effort to report
an approximate line number (\*(L"Nested E<>'s in Paragraph #52, near
line 633 of Thing/Foo.pm!\*(R"), instead of merely noting the paragraph
number (\*(L"Nested E<>'s in Paragraph #52 of Thing/Foo.pm!\*(R").  Where
this is problematic, the paragraph number should at least be
accompanied by an excerpt from the paragraph (\*(L"Nested E<>'s in
Paragraph #52 of Thing/Foo.pm, which begins 'Read/write accessor for
the C<interest rate> attribute...'\*(R").
.IP "\(bu" 4
Pod parsers, when processing a series of verbatim paragraphs one
after another, should consider them to be one large verbatim
paragraph that happens to contain blank lines.  I.e., these two
lines, which have a blank line between them:
.Sp
.Vb 1
\&        use Foo;
\&
\&        print Foo\->VERSION
.Ve
.Sp
should be unified into one paragraph (\*(L"\etuse Foo;\en\en\etprint
Foo\->\s-1VERSION\*(R"\s0) before being passed to the formatter or other
processor.  Parsers may also allow an option for overriding this.
.Sp
While this might be too cumbersome to implement in event-based Pod
parsers, it is straightforward for parsers that return parse trees.
.IP "\(bu" 4
Pod formatters, where feasible, are advised to avoid splitting short
verbatim paragraphs (under twelve lines, say) across pages.
.IP "\(bu" 4
Pod parsers must treat a line with only spaces and/or tabs on it as a
\&\*(L"blank line\*(R" such as separates paragraphs.  (Some older parsers
recognized only two adjacent newlines as a \*(L"blank line\*(R" but would not
recognize a newline, a space, and a newline, as a blank line.  This
is noncompliant behavior.)
.IP "\(bu" 4
Authors of Pod formatters/processors should make every effort to
avoid writing their own Pod parser.  There are already several in
\&\s-1CPAN,\s0 with a wide range of interface styles \*(-- and one of them,
Pod::Parser, comes with modern versions of Perl.
.IP "\(bu" 4
Characters in Pod documents may be conveyed either as literals, or by
number in E<n> codes, or by an equivalent mnemonic, as in
E<eacute> which is exactly equivalent to E<233>.
.Sp
Characters in the range 32\-126 refer to those well known US-ASCII
characters (also defined there by Unicode, with the same meaning),
which all Pod formatters must render faithfully.  Characters
in the ranges 0\-31 and 127\-159 should not be used (neither as
literals, nor as E<number> codes), except for the
literal byte-sequences for newline (13, 13 10, or 10), and tab (9).
.Sp
Characters in the range 160\-255 refer to Latin\-1 characters (also
defined there by Unicode, with the same meaning).  Characters above
255 should be understood to refer to Unicode characters.
.IP "\(bu" 4
Be warned
that some formatters cannot reliably render characters outside 32\-126;
and many are able to handle 32\-126 and 160\-255, but nothing above
255.
.IP "\(bu" 4
Besides the well-known \*(L"E<lt>\*(R" and \*(L"E<gt>\*(R" codes for
less-than and greater-than, Pod parsers must understand \*(L"E<sol>\*(R"
for \*(L"/\*(R" (solidus, slash), and \*(L"E<verbar>\*(R" for \*(L"|\*(R" (vertical bar,
pipe).  Pod parsers should also understand \*(L"E<lchevron>\*(R" and
\&\*(L"E<rchevron>\*(R" as legacy codes for characters 171 and 187, i.e.,
\&\*(L"left-pointing double angle quotation mark\*(R" = \*(L"left pointing
guillemet\*(R" and \*(L"right-pointing double angle quotation mark\*(R" = \*(L"right
pointing guillemet\*(R".  (These look like little \*(L"<<\*(R" and \*(L">>\*(R", and they
are now preferably expressed with the \s-1HTML/XHTML\s0 codes \*(L"E<laquo>\*(R"
and \*(L"E<raquo>\*(R".)
.IP "\(bu" 4
Pod parsers should understand all \*(L"E<html>\*(R" codes as defined
in the entity declarations in the most recent \s-1XHTML\s0 specification at
\&\f(CW\*(C`www.W3.org\*(C'\fR.  Pod parsers must understand at least the entities
that define characters in the range 160\-255 (Latin\-1).  Pod parsers,
when faced with some unknown "E<\fIidentifier\fR>" code,
shouldn't simply replace it with nullstring (by default, at least),
but may pass it through as a string consisting of the literal characters
E, less-than, \fIidentifier\fR, greater-than.  Or Pod parsers may offer the
alternative option of processing such unknown
"E<\fIidentifier\fR>\*(L" codes by firing an event especially
for such codes, or by adding a special node-type to the in-memory
document tree.  Such \*(R"E<\fIidentifier\fR>" may have special meaning
to some processors, or some processors may choose to add them to
a special error report.
.IP "\(bu" 4
Pod parsers must also support the \s-1XHTML\s0 codes \*(L"E<quot>\*(R" for
character 34 (doublequote, \*(L"), \*(R"E<amp>\*(L" for character 38
(ampersand, &), and \*(R"E<apos>" for character 39 (apostrophe, ').
.IP "\(bu" 4
Note that in all cases of \*(L"E<whatever>\*(R", \fIwhatever\fR (whether
an htmlname, or a number in any base) must consist only of
alphanumeric characters \*(-- that is, \fIwhatever\fR must watch
\&\f(CW\*(C`m/\eA\ew+\ez/\*(C'\fR.  So \*(L"E< 0 1 2 3 >\*(R" is invalid, because
it contains spaces, which aren't alphanumeric characters.  This
presumably does not \fIneed\fR special treatment by a Pod processor;
\&\*(L" 0 1 2 3 \*(R" doesn't look like a number in any base, so it would
presumably be looked up in the table of HTML-like names.  Since
there isn't (and cannot be) an HTML-like entity called \*(L" 0 1 2 3 \*(R",
this will be treated as an error.  However, Pod processors may
treat \*(L"E< 0 1 2 3 >\*(R" or \*(L"E<e\-acute>\*(R" as \fIsyntactically\fR
invalid, potentially earning a different error message than the
error message (or warning, or event) generated by a merely unknown
(but theoretically valid) htmlname, as in \*(L"E<qacute>\*(R"
[sic].  However, Pod parsers are not required to make this
distinction.
.IP "\(bu" 4
Note that E<number> \fImust not\fR be interpreted as simply
"codepoint \fInumber\fR in the current/native character set\*(L".  It always
means only \*(R"the character represented by codepoint \fInumber\fR in
Unicode."  (This is identical to the semantics of &#\fInumber\fR; in \s-1XML.\s0)
.Sp
This will likely require many formatters to have tables mapping from
treatable Unicode codepoints (such as the \*(L"\exE9\*(R" for the e\-acute
character) to the escape sequences or codes necessary for conveying
such sequences in the target output format.  A converter to *roff
would, for example know that \*(L"\exE9\*(R" (whether conveyed literally, or via
a E<...> sequence) is to be conveyed as \*(L"e\e\e*'\*(R".
Similarly, a program rendering Pod in a Mac \s-1OS\s0 application window, would
presumably need to know that \*(L"\exE9\*(R" maps to codepoint 142 in MacRoman
encoding that (at time of writing) is native for Mac \s-1OS. \s0 Such
Unicode2whatever mappings are presumably already widely available for
common output formats.  (Such mappings may be incomplete!  Implementers
are not expected to bend over backwards in an attempt to render
Cherokee syllabics, Etruscan runes, Byzantine musical symbols, or any
of the other weird things that Unicode can encode.)  And
if a Pod document uses a character not found in such a mapping, the
formatter should consider it an unrenderable character.
.IP "\(bu" 4
If, surprisingly, the implementor of a Pod formatter can't find a
satisfactory pre-existing table mapping from Unicode characters to
escapes in the target format (e.g., a decent table of Unicode
characters to *roff escapes), it will be necessary to build such a
table.  If you are in this circumstance, you should begin with the
characters in the range 0x00A0 \- 0x00FF, which is mostly the heavily
used accented characters.  Then proceed (as patience permits and
fastidiousness compels) through the characters that the (X)HTML
standards groups judged important enough to merit mnemonics
for.  These are declared in the (X)HTML specifications at the
www.W3.org site.  At time of writing (September 2001), the most recent
entity declaration files are:
.Sp
.Vb 3
\&  http://www.w3.org/TR/xhtml1/DTD/xhtml\-lat1.ent
\&  http://www.w3.org/TR/xhtml1/DTD/xhtml\-special.ent
\&  http://www.w3.org/TR/xhtml1/DTD/xhtml\-symbol.ent
.Ve
.Sp
Then you can progress through any remaining notable Unicode characters
in the range 0x2000\-0x204D (consult the character tables at
www.unicode.org), and whatever else strikes your fancy.  For example,
in \fIxhtml\-symbol.ent\fR, there is the entry:
.Sp
.Vb 1
\&  <!ENTITY infin    "&#8734;"> <!\-\- infinity, U+221E ISOtech \-\->
.Ve
.Sp
While the mapping \*(L"infin\*(R" to the character \*(L"\ex{221E}\*(R" will (hopefully)
have been already handled by the Pod parser, the presence of the
character in this file means that it's reasonably important enough to
include in a formatter's table that maps from notable Unicode characters
to the codes necessary for rendering them.  So for a Unicode\-to\-*roff
mapping, for example, this would merit the entry:
.Sp
.Vb 1
\&  "\ex{221E}" => \*(Aq\e(in\*(Aq,
.Ve
.Sp
It is eagerly hoped that in the future, increasing numbers of formats
(and formatters) will support Unicode characters directly (as (X)HTML
does with \f(CW\*(C`&infin;\*(C'\fR, \f(CW\*(C`&#8734;\*(C'\fR, or \f(CW\*(C`&#x221E;\*(C'\fR), reducing the need
for idiosyncratic mappings of Unicode\-to\-\fImy_escapes\fR.
.IP "\(bu" 4
It is up to individual Pod formatter to display good judgement when
confronted with an unrenderable character (which is distinct from an
unknown E<thing> sequence that the parser couldn't resolve to
anything, renderable or not).  It is good practice to map Latin letters
with diacritics (like \*(L"E<eacute>\*(R"/\*(L"E<233>\*(R") to the corresponding
unaccented US-ASCII letters (like a simple character 101, \*(L"e\*(R"), but
clearly this is often not feasible, and an unrenderable character may
be represented as \*(L"?\*(R", or the like.  In attempting a sane fallback
(as from E<233> to \*(L"e\*(R"), Pod formatters may use the
\&\f(CW%Latin1Code_to_fallback\fR table in Pod::Escapes, or
Text::Unidecode, if available.
.Sp
For example, this Pod text:
.Sp
.Vb 1
\&  magic is enabled if you set C<$Currency> to \*(AqE<euro>\*(Aq.
.Ve
.Sp
may be rendered as:
"magic is enabled if you set \f(CW$Currency\fR to '\fI?\fR'\*(L" or as
\&\*(R"magic is enabled if you set \f(CW$Currency\fR to '\fB[euro]\fR'\*(L", or as
\&\*(R"magic is enabled if you set \f(CW$Currency\fR to '[x20AC]', etc.
.Sp
A Pod formatter may also note, in a comment or warning, a list of what
unrenderable characters were encountered.
.IP "\(bu" 4
E<...> may freely appear in any formatting code (other than
in another E<...> or in an Z<>).  That is, \*(L"X<The
E<euro>1,000,000 Solution>\*(R" is valid, as is \*(L"L<The
E<euro>1,000,000 Solution|Million::Euros>\*(R".
.IP "\(bu" 4
Some Pod formatters output to formats that implement non-breaking
spaces as an individual character (which I'll call \*(L"\s-1NBSP\*(R"\s0), and
others output to formats that implement non-breaking spaces just as
spaces wrapped in a \*(L"don't break this across lines\*(R" code.  Note that
at the level of Pod, both sorts of codes can occur: Pod can contain a
\&\s-1NBSP\s0 character (whether as a literal, or as a \*(L"E<160>\*(R" or
\&\*(L"E<nbsp>\*(R" code); and Pod can contain \*(L"S<foo
I<bar> baz>\*(R" codes, where \*(L"mere spaces\*(R" (character 32) in
such codes are taken to represent non-breaking spaces.  Pod
parsers should consider supporting the optional parsing of \*(L"S<foo
I<bar> baz>\*(R" as if it were
"foo\fI\s-1NBSP\s0\fRI<bar>\fI\s-1NBSP\s0\fRbaz", and, going the other way, the
optional parsing of groups of words joined by \s-1NBSP\s0's as if each group
were in a S<...> code, so that formatters may use the
representation that maps best to what the output format demands.
.IP "\(bu" 4
Some processors may find that the \f(CW\*(C`S<...>\*(C'\fR code is easiest to
implement by replacing each space in the parse tree under the content
of the S, with an \s-1NBSP. \s0 But note: the replacement should apply \fInot\fR to
spaces in \fIall\fR text, but \fIonly\fR to spaces in \fIprintable\fR text.  (This
distinction may or may not be evident in the particular tree/event
model implemented by the Pod parser.)  For example, consider this
unusual case:
.Sp
.Vb 1
\&   S<L</Autoloaded Functions>>
.Ve
.Sp
This means that the space in the middle of the visible link text must
not be broken across lines.  In other words, it's the same as this:
.Sp
.Vb 1
\&   L<"AutoloadedE<160>Functions"/Autoloaded Functions>
.Ve
.Sp
However, a misapplied space-to-NBSP replacement could (wrongly)
produce something equivalent to this:
.Sp
.Vb 1
\&   L<"AutoloadedE<160>Functions"/AutoloadedE<160>Functions>
.Ve
.Sp
\&...which is almost definitely not going to work as a hyperlink (assuming
this formatter outputs a format supporting hypertext).
.Sp
Formatters may choose to just not support the S format code,
especially in cases where the output format simply has no \s-1NBSP\s0
character/code and no code for \*(L"don't break this stuff across lines\*(R".
.IP "\(bu" 4
Besides the \s-1NBSP\s0 character discussed above, implementors are reminded
of the existence of the other \*(L"special\*(R" character in Latin\-1, the
\&\*(L"soft hyphen\*(R" character, also known as \*(L"discretionary hyphen\*(R",
i.e. \f(CW\*(C`E<173>\*(C'\fR = \f(CW\*(C`E<0xAD>\*(C'\fR =
\&\f(CW\*(C`E<shy>\*(C'\fR).  This character expresses an optional hyphenation
point.  That is, it normally renders as nothing, but may render as a
\&\*(L"\-\*(R" if a formatter breaks the word at that point.  Pod formatters
should, as appropriate, do one of the following:  1) render this with
a code with the same meaning (e.g., \*(L"\e\-\*(R" in \s-1RTF\s0), 2) pass it through
in the expectation that the formatter understands this character as
such, or 3) delete it.
.Sp
For example:
.Sp
.Vb 3
\&  sigE<shy>action
\&  manuE<shy>script
\&  JarkE<shy>ko HieE<shy>taE<shy>nieE<shy>mi
.Ve
.Sp
These signal to a formatter that if it is to hyphenate \*(L"sigaction\*(R"
or \*(L"manuscript\*(R", then it should be done as
"sig\-\fI[linebreak]\fRaction\*(L" or \*(R"manu\-\fI[linebreak]\fRscript"
(and if it doesn't hyphenate it, then the \f(CW\*(C`E<shy>\*(C'\fR doesn't
show up at all).  And if it is
to hyphenate \*(L"Jarkko\*(R" and/or \*(L"Hietaniemi\*(R", it can do
so only at the points where there is a \f(CW\*(C`E<shy>\*(C'\fR code.
.Sp
In practice, it is anticipated that this character will not be used
often, but formatters should either support it, or delete it.
.IP "\(bu" 4
If you think that you want to add a new command to Pod (like, say, a
\&\*(L"=biblio\*(R" command), consider whether you could get the same
effect with a for or begin/end sequence: \*(L"=for biblio ...\*(R" or \*(L"=begin
biblio\*(R" ... \*(L"=end biblio\*(R".  Pod processors that don't understand
\&\*(L"=for biblio\*(R", etc, will simply ignore it, whereas they may complain
loudly if they see \*(L"=biblio\*(R".
.IP "\(bu" 4
Throughout this document, \*(L"Pod\*(R" has been the preferred spelling for
the name of the documentation format.  One may also use \*(L"\s-1POD\*(R"\s0 or
\&\*(L"pod\*(R".  For the documentation that is (typically) in the Pod
format, you may use \*(L"pod\*(R", or \*(L"Pod\*(R", or \*(L"\s-1POD\*(R". \s0 Understanding these
distinctions is useful; but obsessing over how to spell them, usually
is not.
.SH "About L<...> Codes"
.IX Header "About L<...> Codes"
As you can tell from a glance at perlpod, the L<...>
code is the most complex of the Pod formatting codes.  The points below
will hopefully clarify what it means and how processors should deal
with it.
.IP "\(bu" 4
In parsing an L<...> code, Pod parsers must distinguish at least
four attributes:
.RS 4
.IP "First:" 4
.IX Item "First:"
The link-text.  If there is none, this must be undef.  (E.g., in
\&\*(L"L<Perl Functions|perlfunc>\*(R", the link-text is \*(L"Perl Functions\*(R".
In \*(L"L<Time::HiRes>\*(R" and even \*(L"L<|Time::HiRes>\*(R", there is no
link text.  Note that link text may contain formatting.)
.IP "Second:" 4
.IX Item "Second:"
The possibly inferred link-text; i.e., if there was no real link
text, then this is the text that we'll infer in its place.  (E.g., for
\&\*(L"L<Getopt::Std>\*(R", the inferred link text is \*(L"Getopt::Std\*(R".)
.IP "Third:" 4
.IX Item "Third:"
The name or \s-1URL,\s0 or undef if none.  (E.g., in \*(L"L<Perl
Functions|perlfunc>\*(R", the name (also sometimes called the page)
is \*(L"perlfunc\*(R".  In \*(L"L</CAVEATS>\*(R", the name is undef.)
.IP "Fourth:" 4
.IX Item "Fourth:"
The section (\s-1AKA \s0\*(L"item\*(R" in older perlpods), or undef if none.  E.g.,
in \*(L"L<Getopt::Std/DESCRIPTION>\*(R", \*(L"\s-1DESCRIPTION\*(R"\s0 is the section.  (Note
that this is not the same as a manpage section like the \*(L"5\*(R" in \*(L"man 5
crontab\*(R".  \*(L"Section Foo\*(R" in the Pod sense means the part of the text
that's introduced by the heading or item whose text is \*(L"Foo\*(R".)
.RE
.RS 4
.Sp
Pod parsers may also note additional attributes including:
.IP "Fifth:" 4
.IX Item "Fifth:"
A flag for whether item 3 (if present) is a \s-1URL \s0(like
\&\*(L"http://lists.perl.org\*(R" is), in which case there should be no section
attribute; a Pod name (like \*(L"perldoc\*(R" and \*(L"Getopt::Std\*(R" are); or
possibly a man page name (like \*(L"\fIcrontab\fR\|(5)\*(R" is).
.IP "Sixth:" 4
.IX Item "Sixth:"
The raw original L<...> content, before text is split on
\&\*(L"|\*(R", \*(L"/\*(R", etc, and before E<...> codes are expanded.
.RE
.RS 4
.Sp
(The above were numbered only for concise reference below.  It is not
a requirement that these be passed as an actual list or array.)
.Sp
For example:
.Sp
.Vb 7
\&  L<Foo::Bar>
\&    =>  undef,                          # link text
\&        "Foo::Bar",                     # possibly inferred link text
\&        "Foo::Bar",                     # name
\&        undef,                          # section
\&        \*(Aqpod\*(Aq,                          # what sort of link
\&        "Foo::Bar"                      # original content
\&
\&  L<Perlport\*(Aqs section on NL\*(Aqs|perlport/Newlines>
\&    =>  "Perlport\*(Aqs section on NL\*(Aqs",   # link text
\&        "Perlport\*(Aqs section on NL\*(Aqs",   # possibly inferred link text
\&        "perlport",                     # name
\&        "Newlines",                     # section
\&        \*(Aqpod\*(Aq,                          # what sort of link
\&        "Perlport\*(Aqs section on NL\*(Aqs|perlport/Newlines" # orig. content
\&
\&  L<perlport/Newlines>
\&    =>  undef,                          # link text
\&        \*(Aq"Newlines" in perlport\*(Aq,       # possibly inferred link text
\&        "perlport",                     # name
\&        "Newlines",                     # section
\&        \*(Aqpod\*(Aq,                          # what sort of link
\&        "perlport/Newlines"             # original content
\&
\&  L<crontab(5)/"DESCRIPTION">
\&    =>  undef,                          # link text
\&        \*(Aq"DESCRIPTION" in crontab(5)\*(Aq,  # possibly inferred link text
\&        "crontab(5)",                   # name
\&        "DESCRIPTION",                  # section
\&        \*(Aqman\*(Aq,                          # what sort of link
\&        \*(Aqcrontab(5)/"DESCRIPTION"\*(Aq      # original content
\&
\&  L</Object Attributes>
\&    =>  undef,                          # link text
\&        \*(Aq"Object Attributes"\*(Aq,          # possibly inferred link text
\&        undef,                          # name
\&        "Object Attributes",            # section
\&        \*(Aqpod\*(Aq,                          # what sort of link
\&        "/Object Attributes"            # original content
\&
\&  L<http://www.perl.org/>
\&    =>  undef,                          # link text
\&        "http://www.perl.org/",         # possibly inferred link text
\&        "http://www.perl.org/",         # name
\&        undef,                          # section
\&        \*(Aqurl\*(Aq,                          # what sort of link
\&        "http://www.perl.org/"          # original content
\&
\&  L<Perl.org|http://www.perl.org/>
\&    =>  "Perl.org",                     # link text
\&        "http://www.perl.org/",         # possibly inferred link text
\&        "http://www.perl.org/",         # name
\&        undef,                          # section
\&        \*(Aqurl\*(Aq,                          # what sort of link
\&        "Perl.org|http://www.perl.org/" # original content
.Ve
.Sp
Note that you can distinguish URL-links from anything else by the
fact that they match \f(CW\*(C`m/\eA\ew+:[^:\es]\eS*\ez/\*(C'\fR.  So
\&\f(CW\*(C`L<http://www.perl.com>\*(C'\fR is a \s-1URL,\s0 but
\&\f(CW\*(C`L<HTTP::Response>\*(C'\fR isn't.
.RE
.IP "\(bu" 4
In case of L<...> codes with no \*(L"text|\*(R" part in them,
older formatters have exhibited great variation in actually displaying
the link or cross reference.  For example, L<\fIcrontab\fR\|(5)> would render
as "the \f(CWcrontab(5)\fR manpage\*(L", or \*(R"in the \f(CWcrontab(5)\fR manpage\*(L"
or just \*(R"\f(CWcrontab(5)\fR".
.Sp
Pod processors must now treat \*(L"text|\*(R"\-less links as follows:
.Sp
.Vb 3
\&  L<name>         =>  L<name|name>
\&  L</section>     =>  L<"section"|/section>
\&  L<name/section> =>  L<"section" in name|name/section>
.Ve
.IP "\(bu" 4
Note that section names might contain markup.  I.e., if a section
starts with:
.Sp
.Vb 1
\&  =head2 About the C<\-M> Operator
.Ve
.Sp
or with:
.Sp
.Vb 1
\&  =item About the C<\-M> Operator
.Ve
.Sp
then a link to it would look like this:
.Sp
.Vb 1
\&  L<somedoc/About the C<\-M> Operator>
.Ve
.Sp
Formatters may choose to ignore the markup for purposes of resolving
the link and use only the renderable characters in the section name,
as in:
.Sp
.Vb 2
\&  <h1><a name="About_the_\-M_Operator">About the <code>\-M</code>
\&  Operator</h1>
\&
\&  ...
\&
\&  <a href="somedoc#About_the_\-M_Operator">About the <code>\-M</code>
\&  Operator" in somedoc</a>
.Ve
.IP "\(bu" 4
Previous versions of perlpod distinguished \f(CW\*(C`L<name/"section">\*(C'\fR
links from \f(CW\*(C`L<name/item>\*(C'\fR links (and their targets).  These
have been merged syntactically and semantically in the current
specification, and \fIsection\fR can refer either to a "=head\fIn\fR Heading
Content\*(L" command or to a \*(R"=item Item Content" command.  This
specification does not specify what behavior should be in the case
of a given document having several things all seeming to produce the
same \fIsection\fR identifier (e.g., in \s-1HTML,\s0 several things all producing
the same \fIanchorname\fR in <a name="\fIanchorname\fR">...</a>
elements).  Where Pod processors can control this behavior, they should
use the first such anchor.  That is, \f(CW\*(C`L<Foo/Bar>\*(C'\fR refers to the
\&\fIfirst\fR \*(L"Bar\*(R" section in Foo.
.Sp
But for some processors/formats this cannot be easily controlled; as
with the \s-1HTML\s0 example, the behavior of multiple ambiguous
<a name="\fIanchorname\fR">...</a> is most easily just left up to
browsers to decide.
.IP "\(bu" 4
In a \f(CW\*(C`L<text|...>\*(C'\fR code, text may contain formatting codes
for formatting or for E<...> escapes, as in:
.Sp
.Vb 1
\&  L<B<ummE<234>stuff>|...>
.Ve
.Sp
For \f(CW\*(C`L<...>\*(C'\fR codes without a \*(L"name|\*(R" part, only
\&\f(CW\*(C`E<...>\*(C'\fR and \f(CW\*(C`Z<>\*(C'\fR codes may occur.  That is,
authors should not use "\f(CW\*(C`L<B<Foo::Bar>>\*(C'\fR".
.Sp
Note, however, that formatting codes and Z<>'s can occur in any
and all parts of an L<...> (i.e., in \fIname\fR, \fIsection\fR, \fItext\fR,
and \fIurl\fR).
.Sp
Authors must not nest L<...> codes.  For example, \*(L"L<The
L<Foo::Bar> man page>\*(R" should be treated as an error.
.IP "\(bu" 4
Note that Pod authors may use formatting codes inside the \*(L"text\*(R"
part of \*(L"L<text|name>\*(R" (and so on for L<text|/\*(L"sec\*(R">).
.Sp
In other words, this is valid:
.Sp
.Vb 1
\&  Go read L<the docs on C<$.>|perlvar/"$.">
.Ve
.Sp
Some output formats that do allow rendering \*(L"L<...>\*(R" codes as
hypertext, might not allow the link-text to be formatted; in
that case, formatters will have to just ignore that formatting.
.IP "\(bu" 4
At time of writing, \f(CW\*(C`L<name>\*(C'\fR values are of two types:
either the name of a Pod page like \f(CW\*(C`L<Foo::Bar>\*(C'\fR (which
might be a real Perl module or program in an \f(CW@INC\fR / \s-1PATH\s0
directory, or a .pod file in those places); or the name of a Unix
man page, like \f(CW\*(C`L<crontab(5)>\*(C'\fR.  In theory, \f(CW\*(C`L<chmod>\*(C'\fR
in ambiguous between a Pod page called \*(L"chmod\*(R", or the Unix man page
\&\*(L"chmod\*(R" (in whatever man-section).  However, the presence of a string
in parens, as in \*(L"\fIcrontab\fR\|(5)\*(R", is sufficient to signal that what
is being discussed is not a Pod page, and so is presumably a
Unix man page.  The distinction is of no importance to many
Pod processors, but some processors that render to hypertext formats
may need to distinguish them in order to know how to render a
given \f(CW\*(C`L<foo>\*(C'\fR code.
.IP "\(bu" 4
Previous versions of perlpod allowed for a \f(CW\*(C`L<section>\*(C'\fR syntax (as in
\&\f(CW\*(C`L<Object Attributes>\*(C'\fR), which was not easily distinguishable from
\&\f(CW\*(C`L<name>\*(C'\fR syntax and for \f(CW\*(C`L<"section">\*(C'\fR which was only
slightly less ambiguous.  This syntax is no longer in the specification, and
has been replaced by the \f(CW\*(C`L</section>\*(C'\fR syntax (where the slash was
formerly optional).  Pod parsers should tolerate the \f(CW\*(C`L<"section">\*(C'\fR
syntax, for a while at least.  The suggested heuristic for distinguishing
\&\f(CW\*(C`L<section>\*(C'\fR from \f(CW\*(C`L<name>\*(C'\fR is that if it contains any
whitespace, it's a \fIsection\fR.  Pod processors should warn about this being
deprecated syntax.
.SH "About =over...=back Regions"
.IX Header "About =over...=back Regions"
\&\*(L"=over\*(R"...\*(L"=back\*(R" regions are used for various kinds of list-like
structures.  (I use the term \*(L"region\*(R" here simply as a collective
term for everything from the \*(L"=over\*(R" to the matching \*(L"=back\*(R".)
.IP "\(bu" 4
The non-zero numeric \fIindentlevel\fR in "=over \fIindentlevel\fR\*(L" ...
\&\*(R"=back\*(L" is used for giving the formatter a clue as to how many
\&\*(R"spaces" (ems, or roughly equivalent units) it should tab over,
although many formatters will have to convert this to an absolute
measurement that may not exactly match with the size of spaces (or M's)
in the document's base font.  Other formatters may have to completely
ignore the number.  The lack of any explicit \fIindentlevel\fR parameter is
equivalent to an \fIindentlevel\fR value of 4.  Pod processors may
complain if \fIindentlevel\fR is present but is not a positive number
matching \f(CW\*(C`m/\eA(\ed*\e.)?\ed+\ez/\*(C'\fR.
.IP "\(bu" 4
Authors of Pod formatters are reminded that \*(L"=over\*(R" ... \*(L"=back\*(R" may
map to several different constructs in your output format.  For
example, in converting Pod to (X)HTML, it can map to any of
<ul>...</ul>, <ol>...</ol>, <dl>...</dl>, or
<blockquote>...</blockquote>.  Similarly, \*(L"=item\*(R" can map to <li> or
<dt>.
.IP "\(bu" 4
Each \*(L"=over\*(R" ... \*(L"=back\*(R" region should be one of the following:
.RS 4
.IP "\(bu" 4
An \*(L"=over\*(R" ... \*(L"=back\*(R" region containing only \*(L"=item *\*(R" commands,
each followed by some number of ordinary/verbatim paragraphs, other
nested \*(L"=over\*(R" ... \*(L"=back\*(R" regions, \*(L"=for...\*(R" paragraphs, and
\&\*(L"=begin\*(R"...\*(L"=end\*(R" regions.
.Sp
(Pod processors must tolerate a bare \*(L"=item\*(R" as if it were \*(L"=item
*\*(R".)  Whether \*(L"*\*(R" is rendered as a literal asterisk, an \*(L"o\*(R", or as
some kind of real bullet character, is left up to the Pod formatter,
and may depend on the level of nesting.
.IP "\(bu" 4
An \*(L"=over\*(R" ... \*(L"=back\*(R" region containing only
\&\f(CW\*(C`m/\eA=item\es+\ed+\e.?\es*\ez/\*(C'\fR paragraphs, each one (or each group of them)
followed by some number of ordinary/verbatim paragraphs, other nested
\&\*(L"=over\*(R" ... \*(L"=back\*(R" regions, \*(L"=for...\*(R" paragraphs, and/or
\&\*(L"=begin\*(R"...\*(L"=end\*(R" codes.  Note that the numbers must start at 1
in each section, and must proceed in order and without skipping
numbers.
.Sp
(Pod processors must tolerate lines like \*(L"=item 1\*(R" as if they were
\&\*(L"=item 1.\*(R", with the period.)
.IP "\(bu" 4
An \*(L"=over\*(R" ... \*(L"=back\*(R" region containing only \*(L"=item [text]\*(R"
commands, each one (or each group of them) followed by some number of
ordinary/verbatim paragraphs, other nested \*(L"=over\*(R" ... \*(L"=back\*(R"
regions, or \*(L"=for...\*(R" paragraphs, and \*(L"=begin\*(R"...\*(L"=end\*(R" regions.
.Sp
The \*(L"=item [text]\*(R" paragraph should not match
\&\f(CW\*(C`m/\eA=item\es+\ed+\e.?\es*\ez/\*(C'\fR or \f(CW\*(C`m/\eA=item\es+\e*\es*\ez/\*(C'\fR, nor should it
match just \f(CW\*(C`m/\eA=item\es*\ez/\*(C'\fR.
.IP "\(bu" 4
An \*(L"=over\*(R" ... \*(L"=back\*(R" region containing no \*(L"=item\*(R" paragraphs at
all, and containing only some number of 
ordinary/verbatim paragraphs, and possibly also some nested \*(L"=over\*(R"
\&... \*(L"=back\*(R" regions, \*(L"=for...\*(R" paragraphs, and \*(L"=begin\*(R"...\*(L"=end\*(R"
regions.  Such an itemless \*(L"=over\*(R" ... \*(L"=back\*(R" region in Pod is
equivalent in meaning to a \*(L"<blockquote>...</blockquote>\*(R" element in
\&\s-1HTML.\s0
.RE
.RS 4
.Sp
Note that with all the above cases, you can determine which type of
\&\*(L"=over\*(R" ... \*(L"=back\*(R" you have, by examining the first (non\-\*(L"=cut\*(R", 
non\-\*(L"=pod\*(R") Pod paragraph after the \*(L"=over\*(R" command.
.RE
.IP "\(bu" 4
Pod formatters \fImust\fR tolerate arbitrarily large amounts of text
in the "=item \fItext...\fR" paragraph.  In practice, most such
paragraphs are short, as in:
.Sp
.Vb 1
\&  =item For cutting off our trade with all parts of the world
.Ve
.Sp
But they may be arbitrarily long:
.Sp
.Vb 2
\&  =item For transporting us beyond seas to be tried for pretended
\&  offenses
\&
\&  =item He is at this time transporting large armies of foreign
\&  mercenaries to complete the works of death, desolation and
\&  tyranny, already begun with circumstances of cruelty and perfidy
\&  scarcely paralleled in the most barbarous ages, and totally
\&  unworthy the head of a civilized nation.
.Ve
.IP "\(bu" 4
Pod processors should tolerate \*(L"=item *\*(R" / "=item \fInumber\fR" commands
with no accompanying paragraph.  The middle item is an example:
.Sp
.Vb 1
\&  =over
\&
\&  =item 1
\&
\&  Pick up dry cleaning.
\&
\&  =item 2
\&
\&  =item 3
\&
\&  Stop by the store.  Get Abba Zabas, Stoli, and cheap lawn chairs.
\&
\&  =back
.Ve
.IP "\(bu" 4
No \*(L"=over\*(R" ... \*(L"=back\*(R" region can contain headings.  Processors may
treat such a heading as an error.
.IP "\(bu" 4
Note that an \*(L"=over\*(R" ... \*(L"=back\*(R" region should have some
content.  That is, authors should not have an empty region like this:
.Sp
.Vb 1
\&  =over
\&
\&  =back
.Ve
.Sp
Pod processors seeing such a contentless \*(L"=over\*(R" ... \*(L"=back\*(R" region,
may ignore it, or may report it as an error.
.IP "\(bu" 4
Processors must tolerate an \*(L"=over\*(R" list that goes off the end of the
document (i.e., which has no matching \*(L"=back\*(R"), but they may warn
about such a list.
.IP "\(bu" 4
Authors of Pod formatters should note that this construct:
.Sp
.Vb 1
\&  =item Neque
\&
\&  =item Porro
\&
\&  =item Quisquam Est
\&
\&  Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci 
\&  velit, sed quia non numquam eius modi tempora incidunt ut
\&  labore et dolore magnam aliquam quaerat voluptatem.
\&
\&  =item Ut Enim
.Ve
.Sp
is semantically ambiguous, in a way that makes formatting decisions
a bit difficult.  On the one hand, it could be mention of an item
\&\*(L"Neque\*(R", mention of another item \*(L"Porro\*(R", and mention of another
item \*(L"Quisquam Est\*(R", with just the last one requiring the explanatory
paragraph \*(L"Qui dolorem ipsum quia dolor...\*(R"; and then an item
\&\*(L"Ut Enim\*(R".  In that case, you'd want to format it like so:
.Sp
.Vb 1
\&  Neque
\&
\&  Porro
\&
\&  Quisquam Est
\&    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
\&    velit, sed quia non numquam eius modi tempora incidunt ut
\&    labore et dolore magnam aliquam quaerat voluptatem.
\&
\&  Ut Enim
.Ve
.Sp
But it could equally well be a discussion of three (related or equivalent)
items, \*(L"Neque\*(R", \*(L"Porro\*(R", and \*(L"Quisquam Est\*(R", followed by a paragraph
explaining them all, and then a new item \*(L"Ut Enim\*(R".  In that case, you'd
probably want to format it like so:
.Sp
.Vb 6
\&  Neque
\&  Porro
\&  Quisquam Est
\&    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
\&    velit, sed quia non numquam eius modi tempora incidunt ut
\&    labore et dolore magnam aliquam quaerat voluptatem.
\&
\&  Ut Enim
.Ve
.Sp
But (for the foreseeable future), Pod does not provide any way for Pod
authors to distinguish which grouping is meant by the above
\&\*(L"=item\*(R"\-cluster structure.  So formatters should format it like so:
.Sp
.Vb 1
\&  Neque
\&
\&  Porro
\&
\&  Quisquam Est
\&
\&    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
\&    velit, sed quia non numquam eius modi tempora incidunt ut
\&    labore et dolore magnam aliquam quaerat voluptatem.
\&
\&  Ut Enim
.Ve
.Sp
That is, there should be (at least roughly) equal spacing between
items as between paragraphs (although that spacing may well be less
than the full height of a line of text).  This leaves it to the reader
to use (con)textual cues to figure out whether the \*(L"Qui dolorem
ipsum...\*(R" paragraph applies to the \*(L"Quisquam Est\*(R" item or to all three
items \*(L"Neque\*(R", \*(L"Porro\*(R", and \*(L"Quisquam Est\*(R".  While not an ideal
situation, this is preferable to providing formatting cues that may
be actually contrary to the author's intent.
.ie n .SH "About Data Paragraphs and ""=begin/=end"" Regions"
.el .SH "About Data Paragraphs and ``=begin/=end'' Regions"
.IX Header "About Data Paragraphs and =begin/=end Regions"
Data paragraphs are typically used for inlining non-Pod data that is
to be used (typically passed through) when rendering the document to
a specific format:
.PP
.Vb 1
\&  =begin rtf
\&
\&  \epar{\epard\eqr\esa4500{\ei Printed\e~\echdate\e~\echtime}\epar}
\&
\&  =end rtf
.Ve
.PP
The exact same effect could, incidentally, be achieved with a single
\&\*(L"=for\*(R" paragraph:
.PP
.Vb 1
\&  =for rtf \epar{\epard\eqr\esa4500{\ei Printed\e~\echdate\e~\echtime}\epar}
.Ve
.PP
(Although that is not formally a data paragraph, it has the same
meaning as one, and Pod parsers may parse it as one.)
.PP
Another example of a data paragraph:
.PP
.Vb 1
\&  =begin html
\&
\&  I like <em>PIE</em>!
\&
\&  <hr>Especially pecan pie!
\&
\&  =end html
.Ve
.PP
If these were ordinary paragraphs, the Pod parser would try to
expand the \*(L"E</em>\*(R" (in the first paragraph) as a formatting
code, just like \*(L"E<lt>\*(R" or \*(L"E<eacute>\*(R".  But since this
is in a "=begin \fIidentifier\fR\*(L"...\*(R"=end \fIidentifier\fR" region \fIand\fR
the identifier \*(L"html\*(R" doesn't begin have a \*(L":\*(R" prefix, the contents
of this region are stored as data paragraphs, instead of being
processed as ordinary paragraphs (or if they began with a spaces
and/or tabs, as verbatim paragraphs).
.PP
As a further example: At time of writing, no \*(L"biblio\*(R" identifier is
supported, but suppose some processor were written to recognize it as
a way of (say) denoting a bibliographic reference (necessarily
containing formatting codes in ordinary paragraphs).  The fact that
\&\*(L"biblio\*(R" paragraphs were meant for ordinary processing would be
indicated by prefacing each \*(L"biblio\*(R" identifier with a colon:
.PP
.Vb 1
\&  =begin :biblio
\&
\&  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
\&  Programs.>  Prentice\-Hall, Englewood Cliffs, NJ.
\&
\&  =end :biblio
.Ve
.PP
This would signal to the parser that paragraphs in this begin...end
region are subject to normal handling as ordinary/verbatim paragraphs
(while still tagged as meant only for processors that understand the
\&\*(L"biblio\*(R" identifier).  The same effect could be had with:
.PP
.Vb 3
\&  =for :biblio
\&  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
\&  Programs.>  Prentice\-Hall, Englewood Cliffs, NJ.
.Ve
.PP
The \*(L":\*(R" on these identifiers means simply \*(L"process this stuff
normally, even though the result will be for some special target\*(R".
I suggest that parser APIs report \*(L"biblio\*(R" as the target identifier,
but also report that it had a \*(L":\*(R" prefix.  (And similarly, with the
above \*(L"html\*(R", report \*(L"html\*(R" as the target identifier, and note the
\&\fIlack\fR of a \*(L":\*(R" prefix.)
.PP
Note that a "=begin \fIidentifier\fR\*(L"...\*(R"=end \fIidentifier\fR" region where
\&\fIidentifier\fR begins with a colon, \fIcan\fR contain commands.  For example:
.PP
.Vb 1
\&  =begin :biblio
\&
\&  Wirth\*(Aqs classic is available in several editions, including:
\&
\&  =for comment
\&   hm, check abebooks.com for how much used copies cost.
\&
\&  =over
\&
\&  =item
\&
\&  Wirth, Niklaus.  1975.  I<Algorithmen und Datenstrukturen.>
\&  Teubner, Stuttgart.  [Yes, it\*(Aqs in German.]
\&
\&  =item
\&
\&  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
\&  Programs.>  Prentice\-Hall, Englewood Cliffs, NJ.
\&
\&  =back
\&
\&  =end :biblio
.Ve
.PP
Note, however, a "=begin \fIidentifier\fR\*(L"...\*(R"=end \fIidentifier\fR"
region where \fIidentifier\fR does \fInot\fR begin with a colon, should not
directly contain \*(L"=head1\*(R" ... \*(L"=head4\*(R" commands, nor \*(L"=over\*(R", nor \*(L"=back\*(R",
nor \*(L"=item\*(R".  For example, this may be considered invalid:
.PP
.Vb 1
\&  =begin somedata
\&
\&  This is a data paragraph.
\&
\&  =head1 Don\*(Aqt do this!
\&
\&  This is a data paragraph too.
\&
\&  =end somedata
.Ve
.PP
A Pod processor may signal that the above (specifically the \*(L"=head1\*(R"
paragraph) is an error.  Note, however, that the following should
\&\fInot\fR be treated as an error:
.PP
.Vb 1
\&  =begin somedata
\&
\&  This is a data paragraph.
\&
\&  =cut
\&
\&  # Yup, this isn\*(Aqt Pod anymore.
\&  sub excl { (rand() > .5) ? "hoo!" : "hah!" }
\&
\&  =pod
\&
\&  This is a data paragraph too.
\&
\&  =end somedata
.Ve
.PP
And this too is valid:
.PP
.Vb 1
\&  =begin someformat
\&
\&  This is a data paragraph.
\&
\&    And this is a data paragraph.
\&
\&  =begin someotherformat
\&
\&  This is a data paragraph too.
\&
\&    And this is a data paragraph too.
\&
\&  =begin :yetanotherformat
\&
\&  =head2 This is a command paragraph!
\&
\&  This is an ordinary paragraph!
\&
\&    And this is a verbatim paragraph!
\&
\&  =end :yetanotherformat
\&
\&  =end someotherformat
\&
\&  Another data paragraph!
\&
\&  =end someformat
.Ve
.PP
The contents of the above \*(L"=begin :yetanotherformat\*(R" ...
\&\*(L"=end :yetanotherformat\*(R" region \fIaren't\fR data paragraphs, because
the immediately containing region's identifier (\*(L":yetanotherformat\*(R")
begins with a colon.  In practice, most regions that contain
data paragraphs will contain \fIonly\fR data paragraphs; however, 
the above nesting is syntactically valid as Pod, even if it is
rare.  However, the handlers for some formats, like \*(L"html\*(R",
will accept only data paragraphs, not nested regions; and they may
complain if they see (targeted for them) nested regions, or commands,
other than \*(L"=end\*(R", \*(L"=pod\*(R", and \*(L"=cut\*(R".
.PP
Also consider this valid structure:
.PP
.Vb 1
\&  =begin :biblio
\&
\&  Wirth\*(Aqs classic is available in several editions, including:
\&
\&  =over
\&
\&  =item
\&
\&  Wirth, Niklaus.  1975.  I<Algorithmen und Datenstrukturen.>
\&  Teubner, Stuttgart.  [Yes, it\*(Aqs in German.]
\&
\&  =item
\&
\&  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
\&  Programs.>  Prentice\-Hall, Englewood Cliffs, NJ.
\&
\&  =back
\&
\&  Buy buy buy!
\&
\&  =begin html
\&
\&  <img src=\*(Aqwirth_spokesmodeling_book.png\*(Aq>
\&
\&  <hr>
\&
\&  =end html
\&
\&  Now now now!
\&
\&  =end :biblio
.Ve
.PP
There, the \*(L"=begin html\*(R"...\*(L"=end html\*(R" region is nested inside
the larger \*(L"=begin :biblio\*(R"...\*(L"=end :biblio\*(R" region.  Note that the
content of the \*(L"=begin html\*(R"...\*(L"=end html\*(R" region is data
paragraph(s), because the immediately containing region's identifier
(\*(L"html\*(R") \fIdoesn't\fR begin with a colon.
.PP
Pod parsers, when processing a series of data paragraphs one
after another (within a single region), should consider them to
be one large data paragraph that happens to contain blank lines.  So
the content of the above \*(L"=begin html\*(R"...\*(L"=end html\*(R" \fImay\fR be stored
as two data paragraphs (one consisting of
\&\*(L"<img src='wirth_spokesmodeling_book.png'>\en\*(R"
and another consisting of \*(L"<hr>\en\*(R"), but \fIshould\fR be stored as
a single data paragraph (consisting of 
\&\*(L"<img src='wirth_spokesmodeling_book.png'>\en\en<hr>\en\*(R").
.PP
Pod processors should tolerate empty
"=begin \fIsomething\fR\*(L"...\*(R"=end \fIsomething\fR\*(L" regions,
empty \*(R"=begin :\fIsomething\fR\*(L"...\*(R"=end :\fIsomething\fR\*(L" regions, and
contentless \*(R"=for \fIsomething\fR\*(L" and \*(R"=for :\fIsomething\fR"
paragraphs.  I.e., these should be tolerated:
.PP
.Vb 1
\&  =for html
\&
\&  =begin html
\&
\&  =end html
\&
\&  =begin :biblio
\&
\&  =end :biblio
.Ve
.PP
Incidentally, note that there's no easy way to express a data
paragraph starting with something that looks like a command.  Consider:
.PP
.Vb 1
\&  =begin stuff
\&
\&  =shazbot
\&
\&  =end stuff
.Ve
.PP
There, \*(L"=shazbot\*(R" will be parsed as a Pod command \*(L"shazbot\*(R", not as a data
paragraph \*(L"=shazbot\en\*(R".  However, you can express a data paragraph consisting
of \*(L"=shazbot\en\*(R" using this code:
.PP
.Vb 1
\&  =for stuff =shazbot
.Ve
.PP
The situation where this is necessary, is presumably quite rare.
.PP
Note that =end commands must match the currently open =begin command.  That
is, they must properly nest.  For example, this is valid:
.PP
.Vb 1
\&  =begin outer
\&
\&  X
\&
\&  =begin inner
\&
\&  Y
\&
\&  =end inner
\&
\&  Z
\&
\&  =end outer
.Ve
.PP
while this is invalid:
.PP
.Vb 1
\&  =begin outer
\&
\&  X
\&
\&  =begin inner
\&
\&  Y
\&
\&  =end outer
\&
\&  Z
\&
\&  =end inner
.Ve
.PP
This latter is improper because when the \*(L"=end outer\*(R" command is seen, the
currently open region has the formatname \*(L"inner\*(R", not \*(L"outer\*(R".  (It just
happens that \*(L"outer\*(R" is the format name of a higher-up region.)  This is
an error.  Processors must by default report this as an error, and may halt
processing the document containing that error.  A corollary of this is that
regions cannot \*(L"overlap\*(R". That is, the latter block above does not represent
a region called \*(L"outer\*(R" which contains X and Y, overlapping a region called
\&\*(L"inner\*(R" which contains Y and Z.  But because it is invalid (as all
apparently overlapping regions would be), it doesn't represent that, or
anything at all.
.PP
Similarly, this is invalid:
.PP
.Vb 1
\&  =begin thing
\&
\&  =end hting
.Ve
.PP
This is an error because the region is opened by \*(L"thing\*(R", and the \*(L"=end\*(R"
tries to close \*(L"hting\*(R" [sic].
.PP
This is also invalid:
.PP
.Vb 1
\&  =begin thing
\&
\&  =end
.Ve
.PP
This is invalid because every \*(L"=end\*(R" command must have a formatname
parameter.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlpod, \*(L"PODs: Embedded Documentation\*(R" in perlsyn,
podchecker
.SH "AUTHOR"
.IX Header "AUTHOR"
Sean M. Burke
                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlpodspec5.16.1                            0100644 0001750 0001750 00000232020 12566207422 023567  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPODSPEC 1"
.TH PERLPODSPEC 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpodspec \- Plain Old Documentation: format specification and notes
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document is detailed notes on the Pod markup language.  Most
people will only have to read perlpod to know how to write
in Pod, but this document may answer some incidental questions to do
with parsing and rendering Pod.
.PP
In this document, \*(L"must\*(R" / \*(L"must not\*(R", \*(L"should\*(R" /
\&\*(L"should not\*(R", and \*(L"may\*(R" have their conventional (cf. \s-1RFC\s0 2119)
meanings: \*(L"X must do Y\*(R" means that if X doesn't do Y, it's against
this specification, and should really be fixed.  \*(L"X should do Y\*(R"
means that it's recommended, but X may fail to do Y, if there's a
good reason.  \*(L"X may do Y\*(R" is merely a note that X can do Y at
will (although it is up to the reader to detect any connotation of
"and I think it would be \fInice\fR if X did Y\*(L" versus \*(R"it wouldn't
really \fIbother\fR me if X did Y").
.PP
Notably, when I say \*(L"the parser should do Y\*(R", the
parser may fail to do Y, if the calling application explicitly
requests that the parser \fInot\fR do Y.  I often phrase this as
\&\*(L"the parser should, by default, do Y.\*(R"  This doesn't \fIrequire\fR
the parser to provide an option for turning off whatever
feature Y is (like expanding tabs in verbatim paragraphs), although
it implicates that such an option \fImay\fR be provided.
.SH "Pod Definitions"
.IX Header "Pod Definitions"
Pod is embedded in files, typically Perl source files, although you
can write a file that's nothing but Pod.
.PP
A \fBline\fR in a file consists of zero or more non-newline characters,
terminated by either a newline or the end of the file.
.PP
A \fBnewline sequence\fR is usually a platform-dependent concept, but
Pod parsers should understand it to mean any of \s-1CR\s0 (\s-1ASCII\s0 13), \s-1LF\s0
(\s-1ASCII\s0 10), or a \s-1CRLF\s0 (\s-1ASCII\s0 13 followed immediately by \s-1ASCII\s0 10), in
addition to any other system-specific meaning.  The first \s-1CR/CRLF/LF\s0
sequence in the file may be used as the basis for identifying the
newline sequence for parsing the rest of the file.
.PP
A \fBblank line\fR is a line consisting entirely of zero or more spaces
(\s-1ASCII\s0 32) or tabs (\s-1ASCII\s0 9), and terminated by a newline or end-of-file.
A \fBnon-blank line\fR is a line containing one or more characters other
than space or tab (and terminated by a newline or end-of-file).
.PP
(\fINote:\fR Many older Pod parsers did not accept a line consisting of
spaces/tabs and then a newline as a blank line. The only lines they
considered blank were lines consisting of \fIno characters at all\fR,
terminated by a newline.)
.PP
\&\fBWhitespace\fR is used in this document as a blanket term for spaces,
tabs, and newline sequences.  (By itself, this term usually refers
to literal whitespace.  That is, sequences of whitespace characters
in Pod source, as opposed to \*(L"E<32>\*(R", which is a formatting
code that \fIdenotes\fR a whitespace character.)
.PP
A \fBPod parser\fR is a module meant for parsing Pod (regardless of
whether this involves calling callbacks or building a parse tree or
directly formatting it).  A \fBPod formatter\fR (or \fBPod translator\fR)
is a module or program that converts Pod to some other format (\s-1HTML\s0,
plaintext, TeX, PostScript, \s-1RTF\s0).  A \fBPod processor\fR might be a
formatter or translator, or might be a program that does something
else with the Pod (like counting words, scanning for index points,
etc.).
.PP
Pod content is contained in \fBPod blocks\fR.  A Pod block starts with a
line that matches <m/\eA=[a\-zA\-Z]/>, and continues up to the next line
that matches \f(CW\*(C`m/\eA=cut/\*(C'\fR or up to the end of the file if there is
no \f(CW\*(C`m/\eA=cut/\*(C'\fR line.
.PP
Within a Pod block, there are \fBPod paragraphs\fR.  A Pod paragraph
consists of non-blank lines of text, separated by one or more blank
lines.
.PP
For purposes of Pod processing, there are four types of paragraphs in
a Pod block:
.IP "\(bu" 4
A command paragraph (also called a \*(L"directive\*(R").  The first line of
this paragraph must match \f(CW\*(C`m/\eA=[a\-zA\-Z]/\*(C'\fR.  Command paragraphs are
typically one line, as in:
.Sp
.Vb 1
\&  =head1 NOTES
\&
\&  =item *
.Ve
.Sp
But they may span several (non-blank) lines:
.Sp
.Vb 3
\&  =for comment
\&  Hm, I wonder what it would look like if
\&  you tried to write a BNF for Pod from this.
\&
\&  =head3 Dr. Strangelove, or: How I Learned to
\&  Stop Worrying and Love the Bomb
.Ve
.Sp
\&\fISome\fR command paragraphs allow formatting codes in their content
(i.e., after the part that matches \f(CW\*(C`m/\eA=[a\-zA\-Z]\eS*\es*/\*(C'\fR), as in:
.Sp
.Vb 1
\&  =head1 Did You Remember to C<use strict;>?
.Ve
.Sp
In other words, the Pod processing handler for \*(L"head1\*(R" will apply the
same processing to \*(L"Did You Remember to C<use strict;>?\*(R" that it
would to an ordinary paragraph (i.e., formatting codes like
\&\*(L"C<...>\*(R") are parsed and presumably formatted appropriately, and
whitespace in the form of literal spaces and/or tabs is not
significant.
.IP "\(bu" 4
A \fBverbatim paragraph\fR.  The first line of this paragraph must be a
literal space or tab, and this paragraph must not be inside a "=begin
\&\fIidentifier\fR\*(L", ... \*(R"=end \fIidentifier\fR\*(L" sequence unless
\&\*(R"\fIidentifier\fR\*(L" begins with a colon (\*(R":").  That is, if a paragraph
starts with a literal space or tab, but \fIis\fR inside a
"=begin \fIidentifier\fR\*(L", ... \*(R"=end \fIidentifier\fR\*(L" region, then it's
a data paragraph, unless \*(R"\fIidentifier\fR" begins with a colon.
.Sp
Whitespace \fIis\fR significant in verbatim paragraphs (although, in
processing, tabs are probably expanded).
.IP "\(bu" 4
An \fBordinary paragraph\fR.  A paragraph is an ordinary paragraph
if its first line matches neither \f(CW\*(C`m/\eA=[a\-zA\-Z]/\*(C'\fR nor
\&\f(CW\*(C`m/\eA[ \et]/\*(C'\fR, \fIand\fR if it's not inside a "=begin \fIidentifier\fR\*(L",
\&... \*(R"=end \fIidentifier\fR\*(L" sequence unless \*(R"\fIidentifier\fR\*(L" begins with
a colon (\*(R":").
.IP "\(bu" 4
A \fBdata paragraph\fR.  This is a paragraph that \fIis\fR inside a "=begin
\&\fIidentifier\fR\*(L" ... \*(R"=end \fIidentifier\fR\*(L" sequence where
\&\*(R"\fIidentifier\fR" does \fInot\fR begin with a literal colon (\*(L":\*(R").  In
some sense, a data paragraph is not part of Pod at all (i.e.,
effectively it's \*(L"out-of-band\*(R"), since it's not subject to most kinds
of Pod parsing; but it is specified here, since Pod
parsers need to be able to call an event for it, or store it in some
form in a parse tree, or at least just parse \fIaround\fR it.
.PP
For example: consider the following paragraphs:
.PP
.Vb 1
\&  # <\- that\*(Aqs the 0th column
\&
\&  =head1 Foo
\&
\&  Stuff
\&
\&    $foo\->bar
\&
\&  =cut
.Ve
.PP
Here, \*(L"=head1 Foo\*(R" and \*(L"=cut\*(R" are command paragraphs because the first
line of each matches \f(CW\*(C`m/\eA=[a\-zA\-Z]/\*(C'\fR.  "\fI[space][space]\fR\f(CW$foo\fR\->bar\*(L"
is a verbatim paragraph, because its first line starts with a literal
whitespace character (and there's no \*(R"=begin\*(L"...\*(R"=end" region around).
.PP
The "=begin \fIidentifier\fR\*(L" ... \*(R"=end \fIidentifier\fR" commands stop
paragraphs that they surround from being parsed as ordinary or verbatim
paragraphs, if \fIidentifier\fR doesn't begin with a colon.  This
is discussed in detail in the section
\&\*(L"About Data Paragraphs and \*(R"=begin/=end\*(L" Regions\*(R".
.SH "Pod Commands"
.IX Header "Pod Commands"
This section is intended to supplement and clarify the discussion in
\&\*(L"Command Paragraph\*(R" in perlpod.  These are the currently recognized
Pod commands:
.ie n .IP """=head1"", ""=head2"", ""=head3"", ""=head4""" 4
.el .IP "``=head1'', ``=head2'', ``=head3'', ``=head4''" 4
.IX Item "=head1, =head2, =head3, =head4"
This command indicates that the text in the remainder of the paragraph
is a heading.  That text may contain formatting codes.  Examples:
.Sp
.Vb 1
\&  =head1 Object Attributes
\&
\&  =head3 What B<Not> to Do!
.Ve
.ie n .IP """=pod""" 4
.el .IP "``=pod''" 4
.IX Item "=pod"
This command indicates that this paragraph begins a Pod block.  (If we
are already in the middle of a Pod block, this command has no effect at
all.)  If there is any text in this command paragraph after \*(L"=pod\*(R",
it must be ignored.  Examples:
.Sp
.Vb 1
\&  =pod
\&
\&  This is a plain Pod paragraph.
\&
\&  =pod This text is ignored.
.Ve
.ie n .IP """=cut""" 4
.el .IP "``=cut''" 4
.IX Item "=cut"
This command indicates that this line is the end of this previously
started Pod block.  If there is any text after \*(L"=cut\*(R" on the line, it must be
ignored.  Examples:
.Sp
.Vb 1
\&  =cut
\&
\&  =cut The documentation ends here.
\&
\&  =cut
\&  # This is the first line of program text.
\&  sub foo { # This is the second.
.Ve
.Sp
It is an error to try to \fIstart\fR a Pod block with a \*(L"=cut\*(R" command.  In
that case, the Pod processor must halt parsing of the input file, and
must by default emit a warning.
.ie n .IP """=over""" 4
.el .IP "``=over''" 4
.IX Item "=over"
This command indicates that this is the start of a list/indent
region.  If there is any text following the \*(L"=over\*(R", it must consist
of only a nonzero positive numeral.  The semantics of this numeral is
explained in the \*(L"About =over...=back Regions\*(R" section, further
below.  Formatting codes are not expanded.  Examples:
.Sp
.Vb 1
\&  =over 3
\&
\&  =over 3.5
\&
\&  =over
.Ve
.ie n .IP """=item""" 4
.el .IP "``=item''" 4
.IX Item "=item"
This command indicates that an item in a list begins here.  Formatting
codes are processed.  The semantics of the (optional) text in the
remainder of this paragraph are
explained in the \*(L"About =over...=back Regions\*(R" section, further
below.  Examples:
.Sp
.Vb 1
\&  =item
\&
\&  =item *
\&
\&  =item      *    
\&
\&  =item 14
\&
\&  =item   3.
\&
\&  =item C<< $thing\->stuff(I<dodad>) >>
\&
\&  =item For transporting us beyond seas to be tried for pretended
\&  offenses
\&
\&  =item He is at this time transporting large armies of foreign
\&  mercenaries to complete the works of death, desolation and
\&  tyranny, already begun with circumstances of cruelty and perfidy
\&  scarcely paralleled in the most barbarous ages, and totally
\&  unworthy the head of a civilized nation.
.Ve
.ie n .IP """=back""" 4
.el .IP "``=back''" 4
.IX Item "=back"
This command indicates that this is the end of the region begun
by the most recent \*(L"=over\*(R" command.  It permits no text after the
\&\*(L"=back\*(R" command.
.ie n .IP """=begin formatname""" 4
.el .IP "``=begin formatname''" 4
.IX Item "=begin formatname"
.PD 0
.ie n .IP """=begin formatname parameter""" 4
.el .IP "``=begin formatname parameter''" 4
.IX Item "=begin formatname parameter"
.PD
This marks the following paragraphs (until the matching \*(L"=end
formatname\*(R") as being for some special kind of processing.  Unless
\&\*(L"formatname\*(R" begins with a colon, the contained non-command
paragraphs are data paragraphs.  But if \*(L"formatname\*(R" \fIdoes\fR begin
with a colon, then non-command paragraphs are ordinary paragraphs
or data paragraphs.  This is discussed in detail in the section
\&\*(L"About Data Paragraphs and \*(R"=begin/=end\*(L" Regions\*(R".
.Sp
It is advised that formatnames match the regexp
\&\f(CW\*(C`m/\eA:?[\-a\-zA\-Z0\-9_]+\ez/\*(C'\fR.  Everything following whitespace after the
formatname is a parameter that may be used by the formatter when dealing
with this region.  This parameter must not be repeated in the \*(L"=end\*(R"
paragraph.  Implementors should anticipate future expansion in the
semantics and syntax of the first parameter to \*(L"=begin\*(R"/\*(L"=end\*(R"/\*(L"=for\*(R".
.ie n .IP """=end formatname""" 4
.el .IP "``=end formatname''" 4
.IX Item "=end formatname"
This marks the end of the region opened by the matching
\&\*(L"=begin formatname\*(R" region.  If \*(L"formatname\*(R" is not the formatname
of the most recent open \*(L"=begin formatname\*(R" region, then this
is an error, and must generate an error message.  This
is discussed in detail in the section
\&\*(L"About Data Paragraphs and \*(R"=begin/=end\*(L" Regions\*(R".
.ie n .IP """=for formatname text...""" 4
.el .IP "``=for formatname text...''" 4
.IX Item "=for formatname text..."
This is synonymous with:
.Sp
.Vb 1
\&     =begin formatname
\&
\&     text...
\&
\&     =end formatname
.Ve
.Sp
That is, it creates a region consisting of a single paragraph; that
paragraph is to be treated as a normal paragraph if \*(L"formatname\*(R"
begins with a \*(L":\*(R"; if \*(L"formatname\*(R" \fIdoesn't\fR begin with a colon,
then \*(L"text...\*(R" will constitute a data paragraph.  There is no way
to use \*(L"=for formatname text...\*(R" to express \*(L"text...\*(R" as a verbatim
paragraph.
.ie n .IP """=encoding encodingname""" 4
.el .IP "``=encoding encodingname''" 4
.IX Item "=encoding encodingname"
This command, which should occur early in the document (at least
before any non-US-ASCII data!), declares that this document is
encoded in the encoding \fIencodingname\fR, which must be
an encoding name that Encode recognizes.  (Encode's list
of supported encodings, in Encode::Supported, is useful here.)
If the Pod parser cannot decode the declared encoding, it 
should emit a warning and may abort parsing the document
altogether.
.Sp
A document having more than one \*(L"=encoding\*(R" line should be
considered an error.  Pod processors may silently tolerate this if
the not-first \*(L"=encoding\*(R" lines are just duplicates of the
first one (e.g., if there's a \*(L"=encoding utf8\*(R" line, and later on
another \*(L"=encoding utf8\*(R" line).  But Pod processors should complain if
there are contradictory \*(L"=encoding\*(R" lines in the same document
(e.g., if there is a \*(L"=encoding utf8\*(R" early in the document and
\&\*(L"=encoding big5\*(R" later).  Pod processors that recognize BOMs
may also complain if they see an \*(L"=encoding\*(R" line
that contradicts the \s-1BOM\s0 (e.g., if a document with a \s-1UTF\-16LE\s0
\&\s-1BOM\s0 has an \*(L"=encoding shiftjis\*(R" line).
.PP
If a Pod processor sees any command other than the ones listed
above (like \*(L"=head\*(R", or \*(L"=haed1\*(R", or \*(L"=stuff\*(R", or \*(L"=cuttlefish\*(R",
or \*(L"=w123\*(R"), that processor must by default treat this as an
error.  It must not process the paragraph beginning with that
command, must by default warn of this as an error, and may
abort the parse.  A Pod parser may allow a way for particular
applications to add to the above list of known commands, and to
stipulate, for each additional command, whether formatting
codes should be processed.
.PP
Future versions of this specification may add additional
commands.
.SH "Pod Formatting Codes"
.IX Header "Pod Formatting Codes"
(Note that in previous drafts of this document and of perlpod,
formatting codes were referred to as \*(L"interior sequences\*(R", and
this term may still be found in the documentation for Pod parsers,
and in error messages from Pod processors.)
.PP
There are two syntaxes for formatting codes:
.IP "\(bu" 4
A formatting code starts with a capital letter (just US-ASCII [A\-Z])
followed by a \*(L"<\*(R", any number of characters, and ending with the first
matching \*(L">\*(R".  Examples:
.Sp
.Vb 1
\&    That\*(Aqs what I<you> think!
\&
\&    What\*(Aqs C<dump()> for?
\&
\&    X<C<chmod> and C<unlink()> Under Different Operating Systems>
.Ve
.IP "\(bu" 4
A formatting code starts with a capital letter (just US-ASCII [A\-Z])
followed by two or more \*(L"<\*(R"'s, one or more whitespace characters,
any number of characters, one or more whitespace characters,
and ending with the first matching sequence of two or more \*(L">\*(R"'s, where
the number of \*(L">\*(R"'s equals the number of \*(L"<\*(R"'s in the opening of this
formatting code.  Examples:
.Sp
.Vb 1
\&    That\*(Aqs what I<< you >> think!
\&
\&    C<<< open(X, ">>thing.dat") || die $! >>>
\&
\&    B<< $foo\->bar(); >>
.Ve
.Sp
With this syntax, the whitespace character(s) after the \*(L"C<<<\*(R"
and before the \*(L">>\*(R" (or whatever letter) are \fInot\fR renderable. They
do not signify whitespace, are merely part of the formatting codes
themselves.  That is, these are all synonymous:
.Sp
.Vb 7
\&    C<thing>
\&    C<< thing >>
\&    C<<           thing     >>
\&    C<<<   thing >>>
\&    C<<<<
\&    thing
\&               >>>>
.Ve
.Sp
and so on.
.Sp
Finally, the multiple-angle-bracket form does \fInot\fR alter the interpretation
of nested formatting codes, meaning that the following four example lines are
identical in meaning:
.Sp
.Vb 1
\&  B<example: C<$a E<lt>=E<gt> $b>>
\&
\&  B<example: C<< $a <=> $b >>>
\&
\&  B<example: C<< $a E<lt>=E<gt> $b >>>
\&
\&  B<<< example: C<< $a E<lt>=E<gt> $b >> >>>
.Ve
.PP
In parsing Pod, a notably tricky part is the correct parsing of
(potentially nested!) formatting codes.  Implementors should
consult the code in the \f(CW\*(C`parse_text\*(C'\fR routine in Pod::Parser as an
example of a correct implementation.
.ie n .IP """I<text>"" \*(-- italic text" 4
.el .IP "\f(CWI<text>\fR \*(-- italic text" 4
.IX Item "I<text>  italic text"
See the brief discussion in \*(L"Formatting Codes\*(R" in perlpod.
.ie n .IP """B<text>"" \*(-- bold text" 4
.el .IP "\f(CWB<text>\fR \*(-- bold text" 4
.IX Item "B<text>  bold text"
See the brief discussion in \*(L"Formatting Codes\*(R" in perlpod.
.ie n .IP """C<code>"" \*(-- code text" 4
.el .IP "\f(CWC<code>\fR \*(-- code text" 4
.IX Item "C<code>  code text"
See the brief discussion in \*(L"Formatting Codes\*(R" in perlpod.
.ie n .IP """F<filename>"" \*(-- style for filenames" 4
.el .IP "\f(CWF<filename>\fR \*(-- style for filenames" 4
.IX Item "F<filename>  style for filenames"
See the brief discussion in \*(L"Formatting Codes\*(R" in perlpod.
.ie n .IP """X<topic name>"" \*(-- an index entry" 4
.el .IP "\f(CWX<topic name>\fR \*(-- an index entry" 4
.IX Item "X<topic name>  an index entry"
See the brief discussion in \*(L"Formatting Codes\*(R" in perlpod.
.Sp
This code is unusual in that most formatters completely discard
this code and its content.  Other formatters will render it with
invisible codes that can be used in building an index of
the current document.
.ie n .IP """Z<>"" \*(-- a null (zero-effect) formatting code" 4
.el .IP "\f(CWZ<>\fR \*(-- a null (zero-effect) formatting code" 4
.IX Item "Z<>  a null (zero-effect) formatting code"
Discussed briefly in \*(L"Formatting Codes\*(R" in perlpod.
.Sp
This code is unusual is that it should have no content.  That is,
a processor may complain if it sees \f(CW\*(C`Z<potatoes>\*(C'\fR.  Whether
or not it complains, the \fIpotatoes\fR text should ignored.
.ie n .IP """L<name>"" \*(-- a hyperlink" 4
.el .IP "\f(CWL<name>\fR \*(-- a hyperlink" 4
.IX Item "L<name>  a hyperlink"
The complicated syntaxes of this code are discussed at length in
\&\*(L"Formatting Codes\*(R" in perlpod, and implementation details are
discussed below, in \*(L"About L<...> Codes\*(R".  Parsing the
contents of L<content> is tricky.  Notably, the content has to be
checked for whether it looks like a \s-1URL\s0, or whether it has to be split
on literal \*(L"|\*(R" and/or \*(L"/\*(R" (in the right order!), and so on,
\&\fIbefore\fR E<...> codes are resolved.
.ie n .IP """E<escape>"" \*(-- a character escape" 4
.el .IP "\f(CWE<escape>\fR \*(-- a character escape" 4
.IX Item "E<escape>  a character escape"
See \*(L"Formatting Codes\*(R" in perlpod, and several points in
\&\*(L"Notes on Implementing Pod Processors\*(R".
.ie n .IP """S<text>"" \*(-- text contains non-breaking spaces" 4
.el .IP "\f(CWS<text>\fR \*(-- text contains non-breaking spaces" 4
.IX Item "S<text>  text contains non-breaking spaces"
This formatting code is syntactically simple, but semantically
complex.  What it means is that each space in the printable
content of this code signifies a non-breaking space.
.Sp
Consider:
.Sp
.Vb 1
\&    C<$x ? $y    :  $z>
\&
\&    S<C<$x ? $y     :  $z>>
.Ve
.Sp
Both signify the monospace (c[ode] style) text consisting of
\&\*(L"$x\*(R", one space, \*(L"?\*(R", one space, \*(L":\*(R", one space, \*(L"$z\*(R".  The
difference is that in the latter, with the S code, those spaces
are not \*(L"normal\*(R" spaces, but instead are non-breaking spaces.
.PP
If a Pod processor sees any formatting code other than the ones
listed above (as in \*(L"N<...>\*(R", or \*(L"Q<...>\*(R", etc.), that
processor must by default treat this as an error.
A Pod parser may allow a way for particular
applications to add to the above list of known formatting codes;
a Pod parser might even allow a way to stipulate, for each additional
command, whether it requires some form of special processing, as
L<...> does.
.PP
Future versions of this specification may add additional
formatting codes.
.PP
Historical note:  A few older Pod processors would not see a \*(L">\*(R" as
closing a \*(L"C<\*(R" code, if the \*(L">\*(R" was immediately preceded by
a \*(L"\-\*(R".  This was so that this:
.PP
.Vb 1
\&    C<$foo\->bar>
.Ve
.PP
would parse as equivalent to this:
.PP
.Vb 1
\&    C<$foo\-E<gt>bar>
.Ve
.PP
instead of as equivalent to a \*(L"C\*(R" formatting code containing 
only \*(L"$foo\-\*(R", and then a \*(L"bar>\*(R" outside the \*(L"C\*(R" formatting code.  This
problem has since been solved by the addition of syntaxes like this:
.PP
.Vb 1
\&    C<< $foo\->bar >>
.Ve
.PP
Compliant parsers must not treat \*(L"\->\*(R" as special.
.PP
Formatting codes absolutely cannot span paragraphs.  If a code is
opened in one paragraph, and no closing code is found by the end of
that paragraph, the Pod parser must close that formatting code,
and should complain (as in \*(L"Unterminated I code in the paragraph
starting at line 123: 'Time objects are not...'\*(R").  So these
two paragraphs:
.PP
.Vb 1
\&  I<I told you not to do this!
\&
\&  Don\*(Aqt make me say it again!>
.Ve
.PP
\&...must \fInot\fR be parsed as two paragraphs in italics (with the I
code starting in one paragraph and starting in another.)  Instead,
the first paragraph should generate a warning, but that aside, the
above code must parse as if it were:
.PP
.Vb 1
\&  I<I told you not to do this!>
\&
\&  Don\*(Aqt make me say it again!E<gt>
.Ve
.PP
(In SGMLish jargon, all Pod commands are like block-level
elements, whereas all Pod formatting codes are like inline-level
elements.)
.SH "Notes on Implementing Pod Processors"
.IX Header "Notes on Implementing Pod Processors"
The following is a long section of miscellaneous requirements
and suggestions to do with Pod processing.
.IP "\(bu" 4
Pod formatters should tolerate lines in verbatim blocks that are of
any length, even if that means having to break them (possibly several
times, for very long lines) to avoid text running off the side of the
page.  Pod formatters may warn of such line-breaking.  Such warnings
are particularly appropriate for lines are over 100 characters long, which
are usually not intentional.
.IP "\(bu" 4
Pod parsers must recognize \fIall\fR of the three well-known newline
formats: \s-1CR\s0, \s-1LF\s0, and \s-1CRLF\s0.  See perlport.
.IP "\(bu" 4
Pod parsers should accept input lines that are of any length.
.IP "\(bu" 4
Since Perl recognizes a Unicode Byte Order Mark at the start of files
as signaling that the file is Unicode encoded as in \s-1UTF\-16\s0 (whether
big-endian or little-endian) or \s-1UTF\-8\s0, Pod parsers should do the
same.  Otherwise, the character encoding should be understood as
being \s-1UTF\-8\s0 if the first highbit byte sequence in the file seems
valid as a \s-1UTF\-8\s0 sequence, or otherwise as Latin\-1.
.Sp
Future versions of this specification may specify
how Pod can accept other encodings.  Presumably treatment of other
encodings in Pod parsing would be as in \s-1XML\s0 parsing: whatever the
encoding declared by a particular Pod file, content is to be
stored in memory as Unicode characters.
.IP "\(bu" 4
The well known Unicode Byte Order Marks are as follows:  if the
file begins with the two literal byte values 0xFE 0xFF, this is
the \s-1BOM\s0 for big-endian \s-1UTF\-16\s0.  If the file begins with the two
literal byte value 0xFF 0xFE, this is the \s-1BOM\s0 for little-endian
\&\s-1UTF\-16\s0.  If the file begins with the three literal byte values
0xEF 0xBB 0xBF, this is the \s-1BOM\s0 for \s-1UTF\-8\s0.
.IP "\(bu" 4
A naive but sufficient heuristic for testing the first highbit
byte-sequence in a BOM-less file (whether in code or in Pod!), to see
whether that sequence is valid as \s-1UTF\-8\s0 (\s-1RFC\s0 2279) is to check whether
that the first byte in the sequence is in the range 0xC0 \- 0xFD
\&\fIand\fR whether the next byte is in the range
0x80 \- 0xBF.  If so, the parser may conclude that this file is in
\&\s-1UTF\-8\s0, and all highbit sequences in the file should be assumed to
be \s-1UTF\-8\s0.  Otherwise the parser should treat the file as being
in Latin\-1.  In the unlikely circumstance that the first highbit
sequence in a truly non\-UTF\-8 file happens to appear to be \s-1UTF\-8\s0, one
can cater to our heuristic (as well as any more intelligent heuristic)
by prefacing that line with a comment line containing a highbit
sequence that is clearly \fInot\fR valid as \s-1UTF\-8\s0.  A line consisting
of simply \*(L"#\*(R", an e\-acute, and any non-highbit byte,
is sufficient to establish this file's encoding.
.IP "\(bu" 4
This document's requirements and suggestions about encodings
do not apply to Pod processors running on non-ASCII platforms,
notably \s-1EBCDIC\s0 platforms.
.IP "\(bu" 4
Pod processors must treat a \*(L"=for [label] [content...]\*(R" paragraph as
meaning the same thing as a \*(L"=begin [label]\*(R" paragraph, content, and
an \*(L"=end [label]\*(R" paragraph.  (The parser may conflate these two
constructs, or may leave them distinct, in the expectation that the
formatter will nevertheless treat them the same.)
.IP "\(bu" 4
When rendering Pod to a format that allows comments (i.e., to nearly
any format other than plaintext), a Pod formatter must insert comment
text identifying its name and version number, and the name and
version numbers of any modules it might be using to process the Pod.
Minimal examples:
.Sp
.Vb 1
\&  %% POD::Pod2PS v3.14159, using POD::Parser v1.92
\&
\&  <!\-\- Pod::HTML v3.14159, using POD::Parser v1.92 \-\->
\&
\&  {\edoccomm generated by Pod::Tree::RTF 3.14159 using Pod::Tree 1.08}
\&
\&  .\e" Pod::Man version 3.14159, using POD::Parser version 1.92
.Ve
.Sp
Formatters may also insert additional comments, including: the
release date of the Pod formatter program, the contact address for
the author(s) of the formatter, the current time, the name of input
file, the formatting options in effect, version of Perl used, etc.
.Sp
Formatters may also choose to note errors/warnings as comments,
besides or instead of emitting them otherwise (as in messages to
\&\s-1STDERR\s0, or \f(CW\*(C`die\*(C'\fRing).
.IP "\(bu" 4
Pod parsers \fImay\fR emit warnings or error messages (\*(L"Unknown E code
E<zslig>!\*(R") to \s-1STDERR\s0 (whether through printing to \s-1STDERR\s0, or
\&\f(CW\*(C`warn\*(C'\fRing/\f(CW\*(C`carp\*(C'\fRing, or \f(CW\*(C`die\*(C'\fRing/\f(CW\*(C`croak\*(C'\fRing), but \fImust\fR allow
suppressing all such \s-1STDERR\s0 output, and instead allow an option for
reporting errors/warnings
in some other way, whether by triggering a callback, or noting errors
in some attribute of the document object, or some similarly unobtrusive
mechanism \*(-- or even by appending a \*(L"Pod Errors\*(R" section to the end of
the parsed form of the document.
.IP "\(bu" 4
In cases of exceptionally aberrant documents, Pod parsers may abort the
parse.  Even then, using \f(CW\*(C`die\*(C'\fRing/\f(CW\*(C`croak\*(C'\fRing is to be avoided; where
possible, the parser library may simply close the input file
and add text like \*(L"*** Formatting Aborted ***\*(R" to the end of the
(partial) in-memory document.
.IP "\(bu" 4
In paragraphs where formatting codes (like E<...>, B<...>)
are understood (i.e., \fInot\fR verbatim paragraphs, but \fIincluding\fR
ordinary paragraphs, and command paragraphs that produce renderable
text, like \*(L"=head1\*(R"), literal whitespace should generally be considered
\&\*(L"insignificant\*(R", in that one literal space has the same meaning as any
(nonzero) number of literal spaces, literal newlines, and literal tabs
(as long as this produces no blank lines, since those would terminate
the paragraph).  Pod parsers should compact literal whitespace in each
processed paragraph, but may provide an option for overriding this
(since some processing tasks do not require it), or may follow
additional special rules (for example, specially treating
period-space-space or period-newline sequences).
.IP "\(bu" 4
Pod parsers should not, by default, try to coerce apostrophe (') and
quote (\*(L") into smart quotes (little 9's, 66's, 99's, etc), nor try to
turn backtick (`) into anything else but a single backtick character
(distinct from an open quote character!), nor \*(R"\-\-" into anything but
two minus signs.  They \fImust never\fR do any of those things to text
in C<...> formatting codes, and never \fIever\fR to text in verbatim
paragraphs.
.IP "\(bu" 4
When rendering Pod to a format that has two kinds of hyphens (\-), one
that's a non-breaking hyphen, and another that's a breakable hyphen
(as in \*(L"object-oriented\*(R", which can be split across lines as
\&\*(L"object\-\*(R", newline, \*(L"oriented\*(R"), formatters are encouraged to
generally translate \*(L"\-\*(R" to non-breaking hyphen, but may apply
heuristics to convert some of these to breaking hyphens.
.IP "\(bu" 4
Pod formatters should make reasonable efforts to keep words of Perl
code from being broken across lines.  For example, \*(L"Foo::Bar\*(R" in some
formatting systems is seen as eligible for being broken across lines
as \*(L"Foo::\*(R" newline \*(L"Bar\*(R" or even \*(L"Foo::\-\*(R" newline \*(L"Bar\*(R".  This should
be avoided where possible, either by disabling all line-breaking in
mid-word, or by wrapping particular words with internal punctuation
in \*(L"don't break this across lines\*(R" codes (which in some formats may
not be a single code, but might be a matter of inserting non-breaking
zero-width spaces between every pair of characters in a word.)
.IP "\(bu" 4
Pod parsers should, by default, expand tabs in verbatim paragraphs as
they are processed, before passing them to the formatter or other
processor.  Parsers may also allow an option for overriding this.
.IP "\(bu" 4
Pod parsers should, by default, remove newlines from the end of
ordinary and verbatim paragraphs before passing them to the
formatter.  For example, while the paragraph you're reading now
could be considered, in Pod source, to end with (and contain)
the newline(s) that end it, it should be processed as ending with
(and containing) the period character that ends this sentence.
.IP "\(bu" 4
Pod parsers, when reporting errors, should make some effort to report
an approximate line number (\*(L"Nested E<>'s in Paragraph #52, near
line 633 of Thing/Foo.pm!\*(R"), instead of merely noting the paragraph
number (\*(L"Nested E<>'s in Paragraph #52 of Thing/Foo.pm!\*(R").  Where
this is problematic, the paragraph number should at least be
accompanied by an excerpt from the paragraph (\*(L"Nested E<>'s in
Paragraph #52 of Thing/Foo.pm, which begins 'Read/write accessor for
the C<interest rate> attribute...'\*(R").
.IP "\(bu" 4
Pod parsers, when processing a series of verbatim paragraphs one
after another, should consider them to be one large verbatim
paragraph that happens to contain blank lines.  I.e., these two
lines, which have a blank line between them:
.Sp
.Vb 1
\&        use Foo;
\&
\&        print Foo\->VERSION
.Ve
.Sp
should be unified into one paragraph (\*(L"\etuse Foo;\en\en\etprint
Foo\->\s-1VERSION\s0\*(R") before being passed to the formatter or other
processor.  Parsers may also allow an option for overriding this.
.Sp
While this might be too cumbersome to implement in event-based Pod
parsers, it is straightforward for parsers that return parse trees.
.IP "\(bu" 4
Pod formatters, where feasible, are advised to avoid splitting short
verbatim paragraphs (under twelve lines, say) across pages.
.IP "\(bu" 4
Pod parsers must treat a line with only spaces and/or tabs on it as a
\&\*(L"blank line\*(R" such as separates paragraphs.  (Some older parsers
recognized only two adjacent newlines as a \*(L"blank line\*(R" but would not
recognize a newline, a space, and a newline, as a blank line.  This
is noncompliant behavior.)
.IP "\(bu" 4
Authors of Pod formatters/processors should make every effort to
avoid writing their own Pod parser.  There are already several in
\&\s-1CPAN\s0, with a wide range of interface styles \*(-- and one of them,
Pod::Parser, comes with modern versions of Perl.
.IP "\(bu" 4
Characters in Pod documents may be conveyed either as literals, or by
number in E<n> codes, or by an equivalent mnemonic, as in
E<eacute> which is exactly equivalent to E<233>.
.Sp
Characters in the range 32\-126 refer to those well known US-ASCII
characters (also defined there by Unicode, with the same meaning),
which all Pod formatters must render faithfully.  Characters
in the ranges 0\-31 and 127\-159 should not be used (neither as
literals, nor as E<number> codes), except for the
literal byte-sequences for newline (13, 13 10, or 10), and tab (9).
.Sp
Characters in the range 160\-255 refer to Latin\-1 characters (also
defined there by Unicode, with the same meaning).  Characters above
255 should be understood to refer to Unicode characters.
.IP "\(bu" 4
Be warned
that some formatters cannot reliably render characters outside 32\-126;
and many are able to handle 32\-126 and 160\-255, but nothing above
255.
.IP "\(bu" 4
Besides the well-known \*(L"E<lt>\*(R" and \*(L"E<gt>\*(R" codes for
less-than and greater-than, Pod parsers must understand \*(L"E<sol>\*(R"
for \*(L"/\*(R" (solidus, slash), and \*(L"E<verbar>\*(R" for \*(L"|\*(R" (vertical bar,
pipe).  Pod parsers should also understand \*(L"E<lchevron>\*(R" and
\&\*(L"E<rchevron>\*(R" as legacy codes for characters 171 and 187, i.e.,
\&\*(L"left-pointing double angle quotation mark\*(R" = \*(L"left pointing
guillemet\*(R" and \*(L"right-pointing double angle quotation mark\*(R" = \*(L"right
pointing guillemet\*(R".  (These look like little \*(L"<<\*(R" and \*(L">>\*(R", and they
are now preferably expressed with the \s-1HTML/XHTML\s0 codes \*(L"E<laquo>\*(R"
and \*(L"E<raquo>\*(R".)
.IP "\(bu" 4
Pod parsers should understand all \*(L"E<html>\*(R" codes as defined
in the entity declarations in the most recent \s-1XHTML\s0 specification at
\&\f(CW\*(C`www.W3.org\*(C'\fR.  Pod parsers must understand at least the entities
that define characters in the range 160\-255 (Latin\-1).  Pod parsers,
when faced with some unknown "E<\fIidentifier\fR>" code,
shouldn't simply replace it with nullstring (by default, at least),
but may pass it through as a string consisting of the literal characters
E, less-than, \fIidentifier\fR, greater-than.  Or Pod parsers may offer the
alternative option of processing such unknown
"E<\fIidentifier\fR>\*(L" codes by firing an event especially
for such codes, or by adding a special node-type to the in-memory
document tree.  Such \*(R"E<\fIidentifier\fR>" may have special meaning
to some processors, or some processors may choose to add them to
a special error report.
.IP "\(bu" 4
Pod parsers must also support the \s-1XHTML\s0 codes \*(L"E<quot>\*(R" for
character 34 (doublequote, \*(L"), \*(R"E<amp>\*(L" for character 38
(ampersand, &), and \*(R"E<apos>" for character 39 (apostrophe, ').
.IP "\(bu" 4
Note that in all cases of \*(L"E<whatever>\*(R", \fIwhatever\fR (whether
an htmlname, or a number in any base) must consist only of
alphanumeric characters \*(-- that is, \fIwhatever\fR must watch
\&\f(CW\*(C`m/\eA\ew+\ez/\*(C'\fR.  So \*(L"E< 0 1 2 3 >\*(R" is invalid, because
it contains spaces, which aren't alphanumeric characters.  This
presumably does not \fIneed\fR special treatment by a Pod processor;
\&\*(L" 0 1 2 3 \*(R" doesn't look like a number in any base, so it would
presumably be looked up in the table of HTML-like names.  Since
there isn't (and cannot be) an HTML-like entity called \*(L" 0 1 2 3 \*(R",
this will be treated as an error.  However, Pod processors may
treat \*(L"E< 0 1 2 3 >\*(R" or \*(L"E<e\-acute>\*(R" as \fIsyntactically\fR
invalid, potentially earning a different error message than the
error message (or warning, or event) generated by a merely unknown
(but theoretically valid) htmlname, as in \*(L"E<qacute>\*(R"
[sic].  However, Pod parsers are not required to make this
distinction.
.IP "\(bu" 4
Note that E<number> \fImust not\fR be interpreted as simply
"codepoint \fInumber\fR in the current/native character set\*(L".  It always
means only \*(R"the character represented by codepoint \fInumber\fR in
Unicode."  (This is identical to the semantics of &#\fInumber\fR; in \s-1XML\s0.)
.Sp
This will likely require many formatters to have tables mapping from
treatable Unicode codepoints (such as the \*(L"\exE9\*(R" for the e\-acute
character) to the escape sequences or codes necessary for conveying
such sequences in the target output format.  A converter to *roff
would, for example know that \*(L"\exE9\*(R" (whether conveyed literally, or via
a E<...> sequence) is to be conveyed as \*(L"e\e\e*'\*(R".
Similarly, a program rendering Pod in a Mac \s-1OS\s0 application window, would
presumably need to know that \*(L"\exE9\*(R" maps to codepoint 142 in MacRoman
encoding that (at time of writing) is native for Mac \s-1OS\s0.  Such
Unicode2whatever mappings are presumably already widely available for
common output formats.  (Such mappings may be incomplete!  Implementers
are not expected to bend over backwards in an attempt to render
Cherokee syllabics, Etruscan runes, Byzantine musical symbols, or any
of the other weird things that Unicode can encode.)  And
if a Pod document uses a character not found in such a mapping, the
formatter should consider it an unrenderable character.
.IP "\(bu" 4
If, surprisingly, the implementor of a Pod formatter can't find a
satisfactory pre-existing table mapping from Unicode characters to
escapes in the target format (e.g., a decent table of Unicode
characters to *roff escapes), it will be necessary to build such a
table.  If you are in this circumstance, you should begin with the
characters in the range 0x00A0 \- 0x00FF, which is mostly the heavily
used accented characters.  Then proceed (as patience permits and
fastidiousness compels) through the characters that the (X)HTML
standards groups judged important enough to merit mnemonics
for.  These are declared in the (X)HTML specifications at the
www.W3.org site.  At time of writing (September 2001), the most recent
entity declaration files are:
.Sp
.Vb 3
\&  http://www.w3.org/TR/xhtml1/DTD/xhtml\-lat1.ent
\&  http://www.w3.org/TR/xhtml1/DTD/xhtml\-special.ent
\&  http://www.w3.org/TR/xhtml1/DTD/xhtml\-symbol.ent
.Ve
.Sp
Then you can progress through any remaining notable Unicode characters
in the range 0x2000\-0x204D (consult the character tables at
www.unicode.org), and whatever else strikes your fancy.  For example,
in \fIxhtml\-symbol.ent\fR, there is the entry:
.Sp
.Vb 1
\&  <!ENTITY infin    "&#8734;"> <!\-\- infinity, U+221E ISOtech \-\->
.Ve
.Sp
While the mapping \*(L"infin\*(R" to the character \*(L"\ex{221E}\*(R" will (hopefully)
have been already handled by the Pod parser, the presence of the
character in this file means that it's reasonably important enough to
include in a formatter's table that maps from notable Unicode characters
to the codes necessary for rendering them.  So for a Unicode\-to\-*roff
mapping, for example, this would merit the entry:
.Sp
.Vb 1
\&  "\ex{221E}" => \*(Aq\e(in\*(Aq,
.Ve
.Sp
It is eagerly hoped that in the future, increasing numbers of formats
(and formatters) will support Unicode characters directly (as (X)HTML
does with \f(CW\*(C`&infin;\*(C'\fR, \f(CW\*(C`&#8734;\*(C'\fR, or \f(CW\*(C`&#x221E;\*(C'\fR), reducing the need
for idiosyncratic mappings of Unicode\-to\-\fImy_escapes\fR.
.IP "\(bu" 4
It is up to individual Pod formatter to display good judgement when
confronted with an unrenderable character (which is distinct from an
unknown E<thing> sequence that the parser couldn't resolve to
anything, renderable or not).  It is good practice to map Latin letters
with diacritics (like \*(L"E<eacute>\*(R"/\*(L"E<233>\*(R") to the corresponding
unaccented US-ASCII letters (like a simple character 101, \*(L"e\*(R"), but
clearly this is often not feasible, and an unrenderable character may
be represented as \*(L"?\*(R", or the like.  In attempting a sane fallback
(as from E<233> to \*(L"e\*(R"), Pod formatters may use the
\&\f(CW%Latin1Code_to_fallback\fR table in Pod::Escapes, or
Text::Unidecode, if available.
.Sp
For example, this Pod text:
.Sp
.Vb 1
\&  magic is enabled if you set C<$Currency> to \*(AqE<euro>\*(Aq.
.Ve
.Sp
may be rendered as:
"magic is enabled if you set \f(CW$Currency\fR to '\fI?\fR'\*(L" or as
\&\*(R"magic is enabled if you set \f(CW$Currency\fR to '\fB[euro]\fR'\*(L", or as
\&\*(R"magic is enabled if you set \f(CW$Currency\fR to '[x20AC]', etc.
.Sp
A Pod formatter may also note, in a comment or warning, a list of what
unrenderable characters were encountered.
.IP "\(bu" 4
E<...> may freely appear in any formatting code (other than
in another E<...> or in an Z<>).  That is, \*(L"X<The
E<euro>1,000,000 Solution>\*(R" is valid, as is \*(L"L<The
E<euro>1,000,000 Solution|Million::Euros>\*(R".
.IP "\(bu" 4
Some Pod formatters output to formats that implement non-breaking
spaces as an individual character (which I'll call \*(L"\s-1NBSP\s0\*(R"), and
others output to formats that implement non-breaking spaces just as
spaces wrapped in a \*(L"don't break this across lines\*(R" code.  Note that
at the level of Pod, both sorts of codes can occur: Pod can contain a
\&\s-1NBSP\s0 character (whether as a literal, or as a \*(L"E<160>\*(R" or
\&\*(L"E<nbsp>\*(R" code); and Pod can contain \*(L"S<foo
I<bar> baz>\*(R" codes, where \*(L"mere spaces\*(R" (character 32) in
such codes are taken to represent non-breaking spaces.  Pod
parsers should consider supporting the optional parsing of \*(L"S<foo
I<bar> baz>\*(R" as if it were
"foo\fI\s-1NBSP\s0\fRI<bar>\fI\s-1NBSP\s0\fRbaz", and, going the other way, the
optional parsing of groups of words joined by \s-1NBSP\s0's as if each group
were in a S<...> code, so that formatters may use the
representation that maps best to what the output format demands.
.IP "\(bu" 4
Some processors may find that the \f(CW\*(C`S<...>\*(C'\fR code is easiest to
implement by replacing each space in the parse tree under the content
of the S, with an \s-1NBSP\s0.  But note: the replacement should apply \fInot\fR to
spaces in \fIall\fR text, but \fIonly\fR to spaces in \fIprintable\fR text.  (This
distinction may or may not be evident in the particular tree/event
model implemented by the Pod parser.)  For example, consider this
unusual case:
.Sp
.Vb 1
\&   S<L</Autoloaded Functions>>
.Ve
.Sp
This means that the space in the middle of the visible link text must
not be broken across lines.  In other words, it's the same as this:
.Sp
.Vb 1
\&   L<"AutoloadedE<160>Functions"/Autoloaded Functions>
.Ve
.Sp
However, a misapplied space-to-NBSP replacement could (wrongly)
produce something equivalent to this:
.Sp
.Vb 1
\&   L<"AutoloadedE<160>Functions"/AutoloadedE<160>Functions>
.Ve
.Sp
\&...which is almost definitely not going to work as a hyperlink (assuming
this formatter outputs a format supporting hypertext).
.Sp
Formatters may choose to just not support the S format code,
especially in cases where the output format simply has no \s-1NBSP\s0
character/code and no code for \*(L"don't break this stuff across lines\*(R".
.IP "\(bu" 4
Besides the \s-1NBSP\s0 character discussed above, implementors are reminded
of the existence of the other \*(L"special\*(R" character in Latin\-1, the
\&\*(L"soft hyphen\*(R" character, also known as \*(L"discretionary hyphen\*(R",
i.e. \f(CW\*(C`E<173>\*(C'\fR = \f(CW\*(C`E<0xAD>\*(C'\fR =
\&\f(CW\*(C`E<shy>\*(C'\fR).  This character expresses an optional hyphenation
point.  That is, it normally renders as nothing, but may render as a
\&\*(L"\-\*(R" if a formatter breaks the word at that point.  Pod formatters
should, as appropriate, do one of the following:  1) render this with
a code with the same meaning (e.g., \*(L"\e\-\*(R" in \s-1RTF\s0), 2) pass it through
in the expectation that the formatter understands this character as
such, or 3) delete it.
.Sp
For example:
.Sp
.Vb 3
\&  sigE<shy>action
\&  manuE<shy>script
\&  JarkE<shy>ko HieE<shy>taE<shy>nieE<shy>mi
.Ve
.Sp
These signal to a formatter that if it is to hyphenate \*(L"sigaction\*(R"
or \*(L"manuscript\*(R", then it should be done as
"sig\-\fI[linebreak]\fRaction\*(L" or \*(R"manu\-\fI[linebreak]\fRscript"
(and if it doesn't hyphenate it, then the \f(CW\*(C`E<shy>\*(C'\fR doesn't
show up at all).  And if it is
to hyphenate \*(L"Jarkko\*(R" and/or \*(L"Hietaniemi\*(R", it can do
so only at the points where there is a \f(CW\*(C`E<shy>\*(C'\fR code.
.Sp
In practice, it is anticipated that this character will not be used
often, but formatters should either support it, or delete it.
.IP "\(bu" 4
If you think that you want to add a new command to Pod (like, say, a
\&\*(L"=biblio\*(R" command), consider whether you could get the same
effect with a for or begin/end sequence: \*(L"=for biblio ...\*(R" or \*(L"=begin
biblio\*(R" ... \*(L"=end biblio\*(R".  Pod processors that don't understand
\&\*(L"=for biblio\*(R", etc, will simply ignore it, whereas they may complain
loudly if they see \*(L"=biblio\*(R".
.IP "\(bu" 4
Throughout this document, \*(L"Pod\*(R" has been the preferred spelling for
the name of the documentation format.  One may also use \*(L"\s-1POD\s0\*(R" or
\&\*(L"pod\*(R".  For the documentation that is (typically) in the Pod
format, you may use \*(L"pod\*(R", or \*(L"Pod\*(R", or \*(L"\s-1POD\s0\*(R".  Understanding these
distinctions is useful; but obsessing over how to spell them, usually
is not.
.SH "About L<...> Codes"
.IX Header "About L<...> Codes"
As you can tell from a glance at perlpod, the L<...>
code is the most complex of the Pod formatting codes.  The points below
will hopefully clarify what it means and how processors should deal
with it.
.IP "\(bu" 4
In parsing an L<...> code, Pod parsers must distinguish at least
four attributes:
.RS 4
.IP "First:" 4
.IX Item "First:"
The link-text.  If there is none, this must be undef.  (E.g., in
\&\*(L"L<Perl Functions|perlfunc>\*(R", the link-text is \*(L"Perl Functions\*(R".
In \*(L"L<Time::HiRes>\*(R" and even \*(L"L<|Time::HiRes>\*(R", there is no
link text.  Note that link text may contain formatting.)
.IP "Second:" 4
.IX Item "Second:"
The possibly inferred link-text; i.e., if there was no real link
text, then this is the text that we'll infer in its place.  (E.g., for
\&\*(L"L<Getopt::Std>\*(R", the inferred link text is \*(L"Getopt::Std\*(R".)
.IP "Third:" 4
.IX Item "Third:"
The name or \s-1URL\s0, or undef if none.  (E.g., in \*(L"L<Perl
Functions|perlfunc>\*(R", the name (also sometimes called the page)
is \*(L"perlfunc\*(R".  In \*(L"L</CAVEATS>\*(R", the name is undef.)
.IP "Fourth:" 4
.IX Item "Fourth:"
The section (\s-1AKA\s0 \*(L"item\*(R" in older perlpods), or undef if none.  E.g.,
in \*(L"L<Getopt::Std/DESCRIPTION>\*(R", \*(L"\s-1DESCRIPTION\s0\*(R" is the section.  (Note
that this is not the same as a manpage section like the \*(L"5\*(R" in \*(L"man 5
crontab\*(R".  \*(L"Section Foo\*(R" in the Pod sense means the part of the text
that's introduced by the heading or item whose text is \*(L"Foo\*(R".)
.RE
.RS 4
.Sp
Pod parsers may also note additional attributes including:
.IP "Fifth:" 4
.IX Item "Fifth:"
A flag for whether item 3 (if present) is a \s-1URL\s0 (like
\&\*(L"http://lists.perl.org\*(R" is), in which case there should be no section
attribute; a Pod name (like \*(L"perldoc\*(R" and \*(L"Getopt::Std\*(R" are); or
possibly a man page name (like \*(L"\fIcrontab\fR\|(5)\*(R" is).
.IP "Sixth:" 4
.IX Item "Sixth:"
The raw original L<...> content, before text is split on
\&\*(L"|\*(R", \*(L"/\*(R", etc, and before E<...> codes are expanded.
.RE
.RS 4
.Sp
(The above were numbered only for concise reference below.  It is not
a requirement that these be passed as an actual list or array.)
.Sp
For example:
.Sp
.Vb 7
\&  L<Foo::Bar>
\&    =>  undef,                          # link text
\&        "Foo::Bar",                     # possibly inferred link text
\&        "Foo::Bar",                     # name
\&        undef,                          # section
\&        \*(Aqpod\*(Aq,                          # what sort of link
\&        "Foo::Bar"                      # original content
\&
\&  L<Perlport\*(Aqs section on NL\*(Aqs|perlport/Newlines>
\&    =>  "Perlport\*(Aqs section on NL\*(Aqs",   # link text
\&        "Perlport\*(Aqs section on NL\*(Aqs",   # possibly inferred link text
\&        "perlport",                     # name
\&        "Newlines",                     # section
\&        \*(Aqpod\*(Aq,                          # what sort of link
\&        "Perlport\*(Aqs section on NL\*(Aqs|perlport/Newlines" # orig. content
\&
\&  L<perlport/Newlines>
\&    =>  undef,                          # link text
\&        \*(Aq"Newlines" in perlport\*(Aq,       # possibly inferred link text
\&        "perlport",                     # name
\&        "Newlines",                     # section
\&        \*(Aqpod\*(Aq,                          # what sort of link
\&        "perlport/Newlines"             # original content
\&
\&  L<crontab(5)/"DESCRIPTION">
\&    =>  undef,                          # link text
\&        \*(Aq"DESCRIPTION" in crontab(5)\*(Aq,  # possibly inferred link text
\&        "crontab(5)",                   # name
\&        "DESCRIPTION",                  # section
\&        \*(Aqman\*(Aq,                          # what sort of link
\&        \*(Aqcrontab(5)/"DESCRIPTION"\*(Aq      # original content
\&
\&  L</Object Attributes>
\&    =>  undef,                          # link text
\&        \*(Aq"Object Attributes"\*(Aq,          # possibly inferred link text
\&        undef,                          # name
\&        "Object Attributes",            # section
\&        \*(Aqpod\*(Aq,                          # what sort of link
\&        "/Object Attributes"            # original content
\&
\&  L<http://www.perl.org/>
\&    =>  undef,                          # link text
\&        "http://www.perl.org/",         # possibly inferred link text
\&        "http://www.perl.org/",         # name
\&        undef,                          # section
\&        \*(Aqurl\*(Aq,                          # what sort of link
\&        "http://www.perl.org/"          # original content
\&
\&  L<Perl.org|http://www.perl.org/>
\&    =>  "Perl.org",                     # link text
\&        "http://www.perl.org/",         # possibly inferred link text
\&        "http://www.perl.org/",         # name
\&        undef,                          # section
\&        \*(Aqurl\*(Aq,                          # what sort of link
\&        "Perl.org|http://www.perl.org/" # original content
.Ve
.Sp
Note that you can distinguish URL-links from anything else by the
fact that they match \f(CW\*(C`m/\eA\ew+:[^:\es]\eS*\ez/\*(C'\fR.  So
\&\f(CW\*(C`L<http://www.perl.com>\*(C'\fR is a \s-1URL\s0, but
\&\f(CW\*(C`L<HTTP::Response>\*(C'\fR isn't.
.RE
.IP "\(bu" 4
In case of L<...> codes with no \*(L"text|\*(R" part in them,
older formatters have exhibited great variation in actually displaying
the link or cross reference.  For example, L<\fIcrontab\fR\|(5)> would render
as "the \f(CWcrontab(5)\fR manpage\*(L", or \*(R"in the \f(CWcrontab(5)\fR manpage\*(L"
or just \*(R"\f(CWcrontab(5)\fR".
.Sp
Pod processors must now treat \*(L"text|\*(R"\-less links as follows:
.Sp
.Vb 3
\&  L<name>         =>  L<name|name>
\&  L</section>     =>  L<"section"|/section>
\&  L<name/section> =>  L<"section" in name|name/section>
.Ve
.IP "\(bu" 4
Note that section names might contain markup.  I.e., if a section
starts with:
.Sp
.Vb 1
\&  =head2 About the C<\-M> Operator
.Ve
.Sp
or with:
.Sp
.Vb 1
\&  =item About the C<\-M> Operator
.Ve
.Sp
then a link to it would look like this:
.Sp
.Vb 1
\&  L<somedoc/About the C<\-M> Operator>
.Ve
.Sp
Formatters may choose to ignore the markup for purposes of resolving
the link and use only the renderable characters in the section name,
as in:
.Sp
.Vb 2
\&  <h1><a name="About_the_\-M_Operator">About the <code>\-M</code>
\&  Operator</h1>
\&
\&  ...
\&
\&  <a href="somedoc#About_the_\-M_Operator">About the <code>\-M</code>
\&  Operator" in somedoc</a>
.Ve
.IP "\(bu" 4
Previous versions of perlpod distinguished \f(CW\*(C`L<name/"section">\*(C'\fR
links from \f(CW\*(C`L<name/item>\*(C'\fR links (and their targets).  These
have been merged syntactically and semantically in the current
specification, and \fIsection\fR can refer either to a "=head\fIn\fR Heading
Content\*(L" command or to a \*(R"=item Item Content" command.  This
specification does not specify what behavior should be in the case
of a given document having several things all seeming to produce the
same \fIsection\fR identifier (e.g., in \s-1HTML\s0, several things all producing
the same \fIanchorname\fR in <a name="\fIanchorname\fR">...</a>
elements).  Where Pod processors can control this behavior, they should
use the first such anchor.  That is, \f(CW\*(C`L<Foo/Bar>\*(C'\fR refers to the
\&\fIfirst\fR \*(L"Bar\*(R" section in Foo.
.Sp
But for some processors/formats this cannot be easily controlled; as
with the \s-1HTML\s0 example, the behavior of multiple ambiguous
<a name="\fIanchorname\fR">...</a> is most easily just left up to
browsers to decide.
.IP "\(bu" 4
In a \f(CW\*(C`L<text|...>\*(C'\fR code, text may contain formatting codes
for formatting or for E<...> escapes, as in:
.Sp
.Vb 1
\&  L<B<ummE<234>stuff>|...>
.Ve
.Sp
For \f(CW\*(C`L<...>\*(C'\fR codes without a \*(L"name|\*(R" part, only
\&\f(CW\*(C`E<...>\*(C'\fR and \f(CW\*(C`Z<>\*(C'\fR codes may occur.  That is,
authors should not use "\f(CW\*(C`L<B<Foo::Bar>>\*(C'\fR".
.Sp
Note, however, that formatting codes and Z<>'s can occur in any
and all parts of an L<...> (i.e., in \fIname\fR, \fIsection\fR, \fItext\fR,
and \fIurl\fR).
.Sp
Authors must not nest L<...> codes.  For example, \*(L"L<The
L<Foo::Bar> man page>\*(R" should be treated as an error.
.IP "\(bu" 4
Note that Pod authors may use formatting codes inside the \*(L"text\*(R"
part of \*(L"L<text|name>\*(R" (and so on for L<text|/\*(L"sec\*(R">).
.Sp
In other words, this is valid:
.Sp
.Vb 1
\&  Go read L<the docs on C<$.>|perlvar/"$.">
.Ve
.Sp
Some output formats that do allow rendering \*(L"L<...>\*(R" codes as
hypertext, might not allow the link-text to be formatted; in
that case, formatters will have to just ignore that formatting.
.IP "\(bu" 4
At time of writing, \f(CW\*(C`L<name>\*(C'\fR values are of two types:
either the name of a Pod page like \f(CW\*(C`L<Foo::Bar>\*(C'\fR (which
might be a real Perl module or program in an \f(CW@INC\fR / \s-1PATH\s0
directory, or a .pod file in those places); or the name of a Unix
man page, like \f(CW\*(C`L<crontab(5)>\*(C'\fR.  In theory, \f(CW\*(C`L<chmod>\*(C'\fR
in ambiguous between a Pod page called \*(L"chmod\*(R", or the Unix man page
\&\*(L"chmod\*(R" (in whatever man-section).  However, the presence of a string
in parens, as in \*(L"\fIcrontab\fR\|(5)\*(R", is sufficient to signal that what
is being discussed is not a Pod page, and so is presumably a
Unix man page.  The distinction is of no importance to many
Pod processors, but some processors that render to hypertext formats
may need to distinguish them in order to know how to render a
given \f(CW\*(C`L<foo>\*(C'\fR code.
.IP "\(bu" 4
Previous versions of perlpod allowed for a \f(CW\*(C`L<section>\*(C'\fR syntax (as in
\&\f(CW\*(C`L<Object Attributes>\*(C'\fR), which was not easily distinguishable from
\&\f(CW\*(C`L<name>\*(C'\fR syntax and for \f(CW\*(C`L<"section">\*(C'\fR which was only
slightly less ambiguous.  This syntax is no longer in the specification, and
has been replaced by the \f(CW\*(C`L</section>\*(C'\fR syntax (where the slash was
formerly optional).  Pod parsers should tolerate the \f(CW\*(C`L<"section">\*(C'\fR
syntax, for a while at least.  The suggested heuristic for distinguishing
\&\f(CW\*(C`L<section>\*(C'\fR from \f(CW\*(C`L<name>\*(C'\fR is that if it contains any
whitespace, it's a \fIsection\fR.  Pod processors should warn about this being
deprecated syntax.
.SH "About =over...=back Regions"
.IX Header "About =over...=back Regions"
\&\*(L"=over\*(R"...\*(L"=back\*(R" regions are used for various kinds of list-like
structures.  (I use the term \*(L"region\*(R" here simply as a collective
term for everything from the \*(L"=over\*(R" to the matching \*(L"=back\*(R".)
.IP "\(bu" 4
The non-zero numeric \fIindentlevel\fR in "=over \fIindentlevel\fR\*(L" ...
\&\*(R"=back\*(L" is used for giving the formatter a clue as to how many
\&\*(R"spaces" (ems, or roughly equivalent units) it should tab over,
although many formatters will have to convert this to an absolute
measurement that may not exactly match with the size of spaces (or M's)
in the document's base font.  Other formatters may have to completely
ignore the number.  The lack of any explicit \fIindentlevel\fR parameter is
equivalent to an \fIindentlevel\fR value of 4.  Pod processors may
complain if \fIindentlevel\fR is present but is not a positive number
matching \f(CW\*(C`m/\eA(\ed*\e.)?\ed+\ez/\*(C'\fR.
.IP "\(bu" 4
Authors of Pod formatters are reminded that \*(L"=over\*(R" ... \*(L"=back\*(R" may
map to several different constructs in your output format.  For
example, in converting Pod to (X)HTML, it can map to any of
<ul>...</ul>, <ol>...</ol>, <dl>...</dl>, or
<blockquote>...</blockquote>.  Similarly, \*(L"=item\*(R" can map to <li> or
<dt>.
.IP "\(bu" 4
Each \*(L"=over\*(R" ... \*(L"=back\*(R" region should be one of the following:
.RS 4
.IP "\(bu" 4
An \*(L"=over\*(R" ... \*(L"=back\*(R" region containing only \*(L"=item *\*(R" commands,
each followed by some number of ordinary/verbatim paragraphs, other
nested \*(L"=over\*(R" ... \*(L"=back\*(R" regions, \*(L"=for...\*(R" paragraphs, and
\&\*(L"=begin\*(R"...\*(L"=end\*(R" regions.
.Sp
(Pod processors must tolerate a bare \*(L"=item\*(R" as if it were \*(L"=item
*\*(R".)  Whether \*(L"*\*(R" is rendered as a literal asterisk, an \*(L"o\*(R", or as
some kind of real bullet character, is left up to the Pod formatter,
and may depend on the level of nesting.
.IP "\(bu" 4
An \*(L"=over\*(R" ... \*(L"=back\*(R" region containing only
\&\f(CW\*(C`m/\eA=item\es+\ed+\e.?\es*\ez/\*(C'\fR paragraphs, each one (or each group of them)
followed by some number of ordinary/verbatim paragraphs, other nested
\&\*(L"=over\*(R" ... \*(L"=back\*(R" regions, \*(L"=for...\*(R" paragraphs, and/or
\&\*(L"=begin\*(R"...\*(L"=end\*(R" codes.  Note that the numbers must start at 1
in each section, and must proceed in order and without skipping
numbers.
.Sp
(Pod processors must tolerate lines like \*(L"=item 1\*(R" as if they were
\&\*(L"=item 1.\*(R", with the period.)
.IP "\(bu" 4
An \*(L"=over\*(R" ... \*(L"=back\*(R" region containing only \*(L"=item [text]\*(R"
commands, each one (or each group of them) followed by some number of
ordinary/verbatim paragraphs, other nested \*(L"=over\*(R" ... \*(L"=back\*(R"
regions, or \*(L"=for...\*(R" paragraphs, and \*(L"=begin\*(R"...\*(L"=end\*(R" regions.
.Sp
The \*(L"=item [text]\*(R" paragraph should not match
\&\f(CW\*(C`m/\eA=item\es+\ed+\e.?\es*\ez/\*(C'\fR or \f(CW\*(C`m/\eA=item\es+\e*\es*\ez/\*(C'\fR, nor should it
match just \f(CW\*(C`m/\eA=item\es*\ez/\*(C'\fR.
.IP "\(bu" 4
An \*(L"=over\*(R" ... \*(L"=back\*(R" region containing no \*(L"=item\*(R" paragraphs at
all, and containing only some number of 
ordinary/verbatim paragraphs, and possibly also some nested \*(L"=over\*(R"
\&... \*(L"=back\*(R" regions, \*(L"=for...\*(R" paragraphs, and \*(L"=begin\*(R"...\*(L"=end\*(R"
regions.  Such an itemless \*(L"=over\*(R" ... \*(L"=back\*(R" region in Pod is
equivalent in meaning to a \*(L"<blockquote>...</blockquote>\*(R" element in
\&\s-1HTML\s0.
.RE
.RS 4
.Sp
Note that with all the above cases, you can determine which type of
\&\*(L"=over\*(R" ... \*(L"=back\*(R" you have, by examining the first (non\-\*(L"=cut\*(R", 
non\-\*(L"=pod\*(R") Pod paragraph after the \*(L"=over\*(R" command.
.RE
.IP "\(bu" 4
Pod formatters \fImust\fR tolerate arbitrarily large amounts of text
in the "=item \fItext...\fR" paragraph.  In practice, most such
paragraphs are short, as in:
.Sp
.Vb 1
\&  =item For cutting off our trade with all parts of the world
.Ve
.Sp
But they may be arbitrarily long:
.Sp
.Vb 2
\&  =item For transporting us beyond seas to be tried for pretended
\&  offenses
\&
\&  =item He is at this time transporting large armies of foreign
\&  mercenaries to complete the works of death, desolation and
\&  tyranny, already begun with circumstances of cruelty and perfidy
\&  scarcely paralleled in the most barbarous ages, and totally
\&  unworthy the head of a civilized nation.
.Ve
.IP "\(bu" 4
Pod processors should tolerate \*(L"=item *\*(R" / "=item \fInumber\fR" commands
with no accompanying paragraph.  The middle item is an example:
.Sp
.Vb 1
\&  =over
\&
\&  =item 1
\&
\&  Pick up dry cleaning.
\&
\&  =item 2
\&
\&  =item 3
\&
\&  Stop by the store.  Get Abba Zabas, Stoli, and cheap lawn chairs.
\&
\&  =back
.Ve
.IP "\(bu" 4
No \*(L"=over\*(R" ... \*(L"=back\*(R" region can contain headings.  Processors may
treat such a heading as an error.
.IP "\(bu" 4
Note that an \*(L"=over\*(R" ... \*(L"=back\*(R" region should have some
content.  That is, authors should not have an empty region like this:
.Sp
.Vb 1
\&  =over
\&
\&  =back
.Ve
.Sp
Pod processors seeing such a contentless \*(L"=over\*(R" ... \*(L"=back\*(R" region,
may ignore it, or may report it as an error.
.IP "\(bu" 4
Processors must tolerate an \*(L"=over\*(R" list that goes off the end of the
document (i.e., which has no matching \*(L"=back\*(R"), but they may warn
about such a list.
.IP "\(bu" 4
Authors of Pod formatters should note that this construct:
.Sp
.Vb 1
\&  =item Neque
\&
\&  =item Porro
\&
\&  =item Quisquam Est
\&
\&  Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci 
\&  velit, sed quia non numquam eius modi tempora incidunt ut
\&  labore et dolore magnam aliquam quaerat voluptatem.
\&
\&  =item Ut Enim
.Ve
.Sp
is semantically ambiguous, in a way that makes formatting decisions
a bit difficult.  On the one hand, it could be mention of an item
\&\*(L"Neque\*(R", mention of another item \*(L"Porro\*(R", and mention of another
item \*(L"Quisquam Est\*(R", with just the last one requiring the explanatory
paragraph \*(L"Qui dolorem ipsum quia dolor...\*(R"; and then an item
\&\*(L"Ut Enim\*(R".  In that case, you'd want to format it like so:
.Sp
.Vb 1
\&  Neque
\&
\&  Porro
\&
\&  Quisquam Est
\&    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
\&    velit, sed quia non numquam eius modi tempora incidunt ut
\&    labore et dolore magnam aliquam quaerat voluptatem.
\&
\&  Ut Enim
.Ve
.Sp
But it could equally well be a discussion of three (related or equivalent)
items, \*(L"Neque\*(R", \*(L"Porro\*(R", and \*(L"Quisquam Est\*(R", followed by a paragraph
explaining them all, and then a new item \*(L"Ut Enim\*(R".  In that case, you'd
probably want to format it like so:
.Sp
.Vb 6
\&  Neque
\&  Porro
\&  Quisquam Est
\&    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
\&    velit, sed quia non numquam eius modi tempora incidunt ut
\&    labore et dolore magnam aliquam quaerat voluptatem.
\&
\&  Ut Enim
.Ve
.Sp
But (for the foreseeable future), Pod does not provide any way for Pod
authors to distinguish which grouping is meant by the above
\&\*(L"=item\*(R"\-cluster structure.  So formatters should format it like so:
.Sp
.Vb 1
\&  Neque
\&
\&  Porro
\&
\&  Quisquam Est
\&
\&    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
\&    velit, sed quia non numquam eius modi tempora incidunt ut
\&    labore et dolore magnam aliquam quaerat voluptatem.
\&
\&  Ut Enim
.Ve
.Sp
That is, there should be (at least roughly) equal spacing between
items as between paragraphs (although that spacing may well be less
than the full height of a line of text).  This leaves it to the reader
to use (con)textual cues to figure out whether the \*(L"Qui dolorem
ipsum...\*(R" paragraph applies to the \*(L"Quisquam Est\*(R" item or to all three
items \*(L"Neque\*(R", \*(L"Porro\*(R", and \*(L"Quisquam Est\*(R".  While not an ideal
situation, this is preferable to providing formatting cues that may
be actually contrary to the author's intent.
.ie n .SH "About Data Paragraphs and ""=begin/=end"" Regions"
.el .SH "About Data Paragraphs and ``=begin/=end'' Regions"
.IX Header "About Data Paragraphs and =begin/=end Regions"
Data paragraphs are typically used for inlining non-Pod data that is
to be used (typically passed through) when rendering the document to
a specific format:
.PP
.Vb 1
\&  =begin rtf
\&
\&  \epar{\epard\eqr\esa4500{\ei Printed\e~\echdate\e~\echtime}\epar}
\&
\&  =end rtf
.Ve
.PP
The exact same effect could, incidentally, be achieved with a single
\&\*(L"=for\*(R" paragraph:
.PP
.Vb 1
\&  =for rtf \epar{\epard\eqr\esa4500{\ei Printed\e~\echdate\e~\echtime}\epar}
.Ve
.PP
(Although that is not formally a data paragraph, it has the same
meaning as one, and Pod parsers may parse it as one.)
.PP
Another example of a data paragraph:
.PP
.Vb 1
\&  =begin html
\&
\&  I like <em>PIE</em>!
\&
\&  <hr>Especially pecan pie!
\&
\&  =end html
.Ve
.PP
If these were ordinary paragraphs, the Pod parser would try to
expand the \*(L"E</em>\*(R" (in the first paragraph) as a formatting
code, just like \*(L"E<lt>\*(R" or \*(L"E<eacute>\*(R".  But since this
is in a "=begin \fIidentifier\fR\*(L"...\*(R"=end \fIidentifier\fR" region \fIand\fR
the identifier \*(L"html\*(R" doesn't begin have a \*(L":\*(R" prefix, the contents
of this region are stored as data paragraphs, instead of being
processed as ordinary paragraphs (or if they began with a spaces
and/or tabs, as verbatim paragraphs).
.PP
As a further example: At time of writing, no \*(L"biblio\*(R" identifier is
supported, but suppose some processor were written to recognize it as
a way of (say) denoting a bibliographic reference (necessarily
containing formatting codes in ordinary paragraphs).  The fact that
\&\*(L"biblio\*(R" paragraphs were meant for ordinary processing would be
indicated by prefacing each \*(L"biblio\*(R" identifier with a colon:
.PP
.Vb 1
\&  =begin :biblio
\&
\&  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
\&  Programs.>  Prentice\-Hall, Englewood Cliffs, NJ.
\&
\&  =end :biblio
.Ve
.PP
This would signal to the parser that paragraphs in this begin...end
region are subject to normal handling as ordinary/verbatim paragraphs
(while still tagged as meant only for processors that understand the
\&\*(L"biblio\*(R" identifier).  The same effect could be had with:
.PP
.Vb 3
\&  =for :biblio
\&  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
\&  Programs.>  Prentice\-Hall, Englewood Cliffs, NJ.
.Ve
.PP
The \*(L":\*(R" on these identifiers means simply \*(L"process this stuff
normally, even though the result will be for some special target\*(R".
I suggest that parser APIs report \*(L"biblio\*(R" as the target identifier,
but also report that it had a \*(L":\*(R" prefix.  (And similarly, with the
above \*(L"html\*(R", report \*(L"html\*(R" as the target identifier, and note the
\&\fIlack\fR of a \*(L":\*(R" prefix.)
.PP
Note that a "=begin \fIidentifier\fR\*(L"...\*(R"=end \fIidentifier\fR" region where
\&\fIidentifier\fR begins with a colon, \fIcan\fR contain commands.  For example:
.PP
.Vb 1
\&  =begin :biblio
\&
\&  Wirth\*(Aqs classic is available in several editions, including:
\&
\&  =for comment
\&   hm, check abebooks.com for how much used copies cost.
\&
\&  =over
\&
\&  =item
\&
\&  Wirth, Niklaus.  1975.  I<Algorithmen und Datenstrukturen.>
\&  Teubner, Stuttgart.  [Yes, it\*(Aqs in German.]
\&
\&  =item
\&
\&  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
\&  Programs.>  Prentice\-Hall, Englewood Cliffs, NJ.
\&
\&  =back
\&
\&  =end :biblio
.Ve
.PP
Note, however, a "=begin \fIidentifier\fR\*(L"...\*(R"=end \fIidentifier\fR"
region where \fIidentifier\fR does \fInot\fR begin with a colon, should not
directly contain \*(L"=head1\*(R" ... \*(L"=head4\*(R" commands, nor \*(L"=over\*(R", nor \*(L"=back\*(R",
nor \*(L"=item\*(R".  For example, this may be considered invalid:
.PP
.Vb 1
\&  =begin somedata
\&
\&  This is a data paragraph.
\&
\&  =head1 Don\*(Aqt do this!
\&
\&  This is a data paragraph too.
\&
\&  =end somedata
.Ve
.PP
A Pod processor may signal that the above (specifically the \*(L"=head1\*(R"
paragraph) is an error.  Note, however, that the following should
\&\fInot\fR be treated as an error:
.PP
.Vb 1
\&  =begin somedata
\&
\&  This is a data paragraph.
\&
\&  =cut
\&
\&  # Yup, this isn\*(Aqt Pod anymore.
\&  sub excl { (rand() > .5) ? "hoo!" : "hah!" }
\&
\&  =pod
\&
\&  This is a data paragraph too.
\&
\&  =end somedata
.Ve
.PP
And this too is valid:
.PP
.Vb 1
\&  =begin someformat
\&
\&  This is a data paragraph.
\&
\&    And this is a data paragraph.
\&
\&  =begin someotherformat
\&
\&  This is a data paragraph too.
\&
\&    And this is a data paragraph too.
\&
\&  =begin :yetanotherformat
\&
\&  =head2 This is a command paragraph!
\&
\&  This is an ordinary paragraph!
\&
\&    And this is a verbatim paragraph!
\&
\&  =end :yetanotherformat
\&
\&  =end someotherformat
\&
\&  Another data paragraph!
\&
\&  =end someformat
.Ve
.PP
The contents of the above \*(L"=begin :yetanotherformat\*(R" ...
\&\*(L"=end :yetanotherformat\*(R" region \fIaren't\fR data paragraphs, because
the immediately containing region's identifier (\*(L":yetanotherformat\*(R")
begins with a colon.  In practice, most regions that contain
data paragraphs will contain \fIonly\fR data paragraphs; however, 
the above nesting is syntactically valid as Pod, even if it is
rare.  However, the handlers for some formats, like \*(L"html\*(R",
will accept only data paragraphs, not nested regions; and they may
complain if they see (targeted for them) nested regions, or commands,
other than \*(L"=end\*(R", \*(L"=pod\*(R", and \*(L"=cut\*(R".
.PP
Also consider this valid structure:
.PP
.Vb 1
\&  =begin :biblio
\&
\&  Wirth\*(Aqs classic is available in several editions, including:
\&
\&  =over
\&
\&  =item
\&
\&  Wirth, Niklaus.  1975.  I<Algorithmen und Datenstrukturen.>
\&  Teubner, Stuttgart.  [Yes, it\*(Aqs in German.]
\&
\&  =item
\&
\&  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
\&  Programs.>  Prentice\-Hall, Englewood Cliffs, NJ.
\&
\&  =back
\&
\&  Buy buy buy!
\&
\&  =begin html
\&
\&  <img src=\*(Aqwirth_spokesmodeling_book.png\*(Aq>
\&
\&  <hr>
\&
\&  =end html
\&
\&  Now now now!
\&
\&  =end :biblio
.Ve
.PP
There, the \*(L"=begin html\*(R"...\*(L"=end html\*(R" region is nested inside
the larger \*(L"=begin :biblio\*(R"...\*(L"=end :biblio\*(R" region.  Note that the
content of the \*(L"=begin html\*(R"...\*(L"=end html\*(R" region is data
paragraph(s), because the immediately containing region's identifier
(\*(L"html\*(R") \fIdoesn't\fR begin with a colon.
.PP
Pod parsers, when processing a series of data paragraphs one
after another (within a single region), should consider them to
be one large data paragraph that happens to contain blank lines.  So
the content of the above \*(L"=begin html\*(R"...\*(L"=end html\*(R" \fImay\fR be stored
as two data paragraphs (one consisting of
\&\*(L"<img src='wirth_spokesmodeling_book.png'>\en\*(R"
and another consisting of \*(L"<hr>\en\*(R"), but \fIshould\fR be stored as
a single data paragraph (consisting of 
\&\*(L"<img src='wirth_spokesmodeling_book.png'>\en\en<hr>\en\*(R").
.PP
Pod processors should tolerate empty
"=begin \fIsomething\fR\*(L"...\*(R"=end \fIsomething\fR\*(L" regions,
empty \*(R"=begin :\fIsomething\fR\*(L"...\*(R"=end :\fIsomething\fR\*(L" regions, and
contentless \*(R"=for \fIsomething\fR\*(L" and \*(R"=for :\fIsomething\fR"
paragraphs.  I.e., these should be tolerated:
.PP
.Vb 1
\&  =for html
\&
\&  =begin html
\&
\&  =end html
\&
\&  =begin :biblio
\&
\&  =end :biblio
.Ve
.PP
Incidentally, note that there's no easy way to express a data
paragraph starting with something that looks like a command.  Consider:
.PP
.Vb 1
\&  =begin stuff
\&
\&  =shazbot
\&
\&  =end stuff
.Ve
.PP
There, \*(L"=shazbot\*(R" will be parsed as a Pod command \*(L"shazbot\*(R", not as a data
paragraph \*(L"=shazbot\en\*(R".  However, you can express a data paragraph consisting
of \*(L"=shazbot\en\*(R" using this code:
.PP
.Vb 1
\&  =for stuff =shazbot
.Ve
.PP
The situation where this is necessary, is presumably quite rare.
.PP
Note that =end commands must match the currently open =begin command.  That
is, they must properly nest.  For example, this is valid:
.PP
.Vb 1
\&  =begin outer
\&
\&  X
\&
\&  =begin inner
\&
\&  Y
\&
\&  =end inner
\&
\&  Z
\&
\&  =end outer
.Ve
.PP
while this is invalid:
.PP
.Vb 1
\&  =begin outer
\&
\&  X
\&
\&  =begin inner
\&
\&  Y
\&
\&  =end outer
\&
\&  Z
\&
\&  =end inner
.Ve
.PP
This latter is improper because when the \*(L"=end outer\*(R" command is seen, the
currently open region has the formatname \*(L"inner\*(R", not \*(L"outer\*(R".  (It just
happens that \*(L"outer\*(R" is the format name of a higher-up region.)  This is
an error.  Processors must by default report this as an error, and may halt
processing the document containing that error.  A corollary of this is that
regions cannot \*(L"overlap\*(R". That is, the latter block above does not represent
a region called \*(L"outer\*(R" which contains X and Y, overlapping a region called
\&\*(L"inner\*(R" which contains Y and Z.  But because it is invalid (as all
apparently overlapping regions would be), it doesn't represent that, or
anything at all.
.PP
Similarly, this is invalid:
.PP
.Vb 1
\&  =begin thing
\&
\&  =end hting
.Ve
.PP
This is an error because the region is opened by \*(L"thing\*(R", and the \*(L"=end\*(R"
tries to close \*(L"hting\*(R" [sic].
.PP
This is also invalid:
.PP
.Vb 1
\&  =begin thing
\&
\&  =end
.Ve
.PP
This is invalid because every \*(L"=end\*(R" command must have a formatname
parameter.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlpod, \*(L"PODs: Embedded Documentation\*(R" in perlsyn,
podchecker
.SH "AUTHOR"
.IX Header "AUTHOR"
Sean M. Burke
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlpodspec5.18.1                            0100644 0001750 0001750 00000232312 12566207443 023600  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPODSPEC 1"
.TH PERLPODSPEC 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpodspec \- Plain Old Documentation: format specification and notes
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document is detailed notes on the Pod markup language.  Most
people will only have to read perlpod to know how to write
in Pod, but this document may answer some incidental questions to do
with parsing and rendering Pod.
.PP
In this document, \*(L"must\*(R" / \*(L"must not\*(R", \*(L"should\*(R" /
\&\*(L"should not\*(R", and \*(L"may\*(R" have their conventional (cf. \s-1RFC 2119\s0)
meanings: \*(L"X must do Y\*(R" means that if X doesn't do Y, it's against
this specification, and should really be fixed.  \*(L"X should do Y\*(R"
means that it's recommended, but X may fail to do Y, if there's a
good reason.  \*(L"X may do Y\*(R" is merely a note that X can do Y at
will (although it is up to the reader to detect any connotation of
"and I think it would be \fInice\fR if X did Y\*(L" versus \*(R"it wouldn't
really \fIbother\fR me if X did Y").
.PP
Notably, when I say \*(L"the parser should do Y\*(R", the
parser may fail to do Y, if the calling application explicitly
requests that the parser \fInot\fR do Y.  I often phrase this as
\&\*(L"the parser should, by default, do Y.\*(R"  This doesn't \fIrequire\fR
the parser to provide an option for turning off whatever
feature Y is (like expanding tabs in verbatim paragraphs), although
it implicates that such an option \fImay\fR be provided.
.SH "Pod Definitions"
.IX Header "Pod Definitions"
Pod is embedded in files, typically Perl source files, although you
can write a file that's nothing but Pod.
.PP
A \fBline\fR in a file consists of zero or more non-newline characters,
terminated by either a newline or the end of the file.
.PP
A \fBnewline sequence\fR is usually a platform-dependent concept, but
Pod parsers should understand it to mean any of \s-1CR \s0(\s-1ASCII 13\s0), \s-1LF
\&\s0(\s-1ASCII 10\s0), or a \s-1CRLF \s0(\s-1ASCII 13\s0 followed immediately by \s-1ASCII 10\s0), in
addition to any other system-specific meaning.  The first \s-1CR/CRLF/LF\s0
sequence in the file may be used as the basis for identifying the
newline sequence for parsing the rest of the file.
.PP
A \fBblank line\fR is a line consisting entirely of zero or more spaces
(\s-1ASCII 32\s0) or tabs (\s-1ASCII 9\s0), and terminated by a newline or end-of-file.
A \fBnon-blank line\fR is a line containing one or more characters other
than space or tab (and terminated by a newline or end-of-file).
.PP
(\fINote:\fR Many older Pod parsers did not accept a line consisting of
spaces/tabs and then a newline as a blank line. The only lines they
considered blank were lines consisting of \fIno characters at all\fR,
terminated by a newline.)
.PP
\&\fBWhitespace\fR is used in this document as a blanket term for spaces,
tabs, and newline sequences.  (By itself, this term usually refers
to literal whitespace.  That is, sequences of whitespace characters
in Pod source, as opposed to \*(L"E<32>\*(R", which is a formatting
code that \fIdenotes\fR a whitespace character.)
.PP
A \fBPod parser\fR is a module meant for parsing Pod (regardless of
whether this involves calling callbacks or building a parse tree or
directly formatting it).  A \fBPod formatter\fR (or \fBPod translator\fR)
is a module or program that converts Pod to some other format (\s-1HTML,\s0
plaintext, TeX, PostScript, \s-1RTF\s0).  A \fBPod processor\fR might be a
formatter or translator, or might be a program that does something
else with the Pod (like counting words, scanning for index points,
etc.).
.PP
Pod content is contained in \fBPod blocks\fR.  A Pod block starts with a
line that matches <m/\eA=[a\-zA\-Z]/>, and continues up to the next line
that matches \f(CW\*(C`m/\eA=cut/\*(C'\fR or up to the end of the file if there is
no \f(CW\*(C`m/\eA=cut/\*(C'\fR line.
.PP
Within a Pod block, there are \fBPod paragraphs\fR.  A Pod paragraph
consists of non-blank lines of text, separated by one or more blank
lines.
.PP
For purposes of Pod processing, there are four types of paragraphs in
a Pod block:
.IP "\(bu" 4
A command paragraph (also called a \*(L"directive\*(R").  The first line of
this paragraph must match \f(CW\*(C`m/\eA=[a\-zA\-Z]/\*(C'\fR.  Command paragraphs are
typically one line, as in:
.Sp
.Vb 1
\&  =head1 NOTES
\&
\&  =item *
.Ve
.Sp
But they may span several (non-blank) lines:
.Sp
.Vb 3
\&  =for comment
\&  Hm, I wonder what it would look like if
\&  you tried to write a BNF for Pod from this.
\&
\&  =head3 Dr. Strangelove, or: How I Learned to
\&  Stop Worrying and Love the Bomb
.Ve
.Sp
\&\fISome\fR command paragraphs allow formatting codes in their content
(i.e., after the part that matches \f(CW\*(C`m/\eA=[a\-zA\-Z]\eS*\es*/\*(C'\fR), as in:
.Sp
.Vb 1
\&  =head1 Did You Remember to C<use strict;>?
.Ve
.Sp
In other words, the Pod processing handler for \*(L"head1\*(R" will apply the
same processing to \*(L"Did You Remember to C<use strict;>?\*(R" that it
would to an ordinary paragraph (i.e., formatting codes like
\&\*(L"C<...>\*(R") are parsed and presumably formatted appropriately, and
whitespace in the form of literal spaces and/or tabs is not
significant.
.IP "\(bu" 4
A \fBverbatim paragraph\fR.  The first line of this paragraph must be a
literal space or tab, and this paragraph must not be inside a "=begin
\&\fIidentifier\fR\*(L", ... \*(R"=end \fIidentifier\fR\*(L" sequence unless
\&\*(R"\fIidentifier\fR\*(L" begins with a colon (\*(R":").  That is, if a paragraph
starts with a literal space or tab, but \fIis\fR inside a
"=begin \fIidentifier\fR\*(L", ... \*(R"=end \fIidentifier\fR\*(L" region, then it's
a data paragraph, unless \*(R"\fIidentifier\fR" begins with a colon.
.Sp
Whitespace \fIis\fR significant in verbatim paragraphs (although, in
processing, tabs are probably expanded).
.IP "\(bu" 4
An \fBordinary paragraph\fR.  A paragraph is an ordinary paragraph
if its first line matches neither \f(CW\*(C`m/\eA=[a\-zA\-Z]/\*(C'\fR nor
\&\f(CW\*(C`m/\eA[ \et]/\*(C'\fR, \fIand\fR if it's not inside a "=begin \fIidentifier\fR\*(L",
\&... \*(R"=end \fIidentifier\fR\*(L" sequence unless \*(R"\fIidentifier\fR\*(L" begins with
a colon (\*(R":").
.IP "\(bu" 4
A \fBdata paragraph\fR.  This is a paragraph that \fIis\fR inside a "=begin
\&\fIidentifier\fR\*(L" ... \*(R"=end \fIidentifier\fR\*(L" sequence where
\&\*(R"\fIidentifier\fR" does \fInot\fR begin with a literal colon (\*(L":\*(R").  In
some sense, a data paragraph is not part of Pod at all (i.e.,
effectively it's \*(L"out-of-band\*(R"), since it's not subject to most kinds
of Pod parsing; but it is specified here, since Pod
parsers need to be able to call an event for it, or store it in some
form in a parse tree, or at least just parse \fIaround\fR it.
.PP
For example: consider the following paragraphs:
.PP
.Vb 1
\&  # <\- that\*(Aqs the 0th column
\&
\&  =head1 Foo
\&
\&  Stuff
\&
\&    $foo\->bar
\&
\&  =cut
.Ve
.PP
Here, \*(L"=head1 Foo\*(R" and \*(L"=cut\*(R" are command paragraphs because the first
line of each matches \f(CW\*(C`m/\eA=[a\-zA\-Z]/\*(C'\fR.  "\fI[space][space]\fR\f(CW$foo\fR\->bar\*(L"
is a verbatim paragraph, because its first line starts with a literal
whitespace character (and there's no \*(R"=begin\*(L"...\*(R"=end" region around).
.PP
The "=begin \fIidentifier\fR\*(L" ... \*(R"=end \fIidentifier\fR" commands stop
paragraphs that they surround from being parsed as ordinary or verbatim
paragraphs, if \fIidentifier\fR doesn't begin with a colon.  This
is discussed in detail in the section
\&\*(L"About Data Paragraphs and \*(R"=begin/=end\*(L" Regions\*(R".
.SH "Pod Commands"
.IX Header "Pod Commands"
This section is intended to supplement and clarify the discussion in
\&\*(L"Command Paragraph\*(R" in perlpod.  These are the currently recognized
Pod commands:
.ie n .IP """=head1"", ""=head2"", ""=head3"", ""=head4""" 4
.el .IP "``=head1'', ``=head2'', ``=head3'', ``=head4''" 4
.IX Item "=head1, =head2, =head3, =head4"
This command indicates that the text in the remainder of the paragraph
is a heading.  That text may contain formatting codes.  Examples:
.Sp
.Vb 1
\&  =head1 Object Attributes
\&
\&  =head3 What B<Not> to Do!
.Ve
.ie n .IP """=pod""" 4
.el .IP "``=pod''" 4
.IX Item "=pod"
This command indicates that this paragraph begins a Pod block.  (If we
are already in the middle of a Pod block, this command has no effect at
all.)  If there is any text in this command paragraph after \*(L"=pod\*(R",
it must be ignored.  Examples:
.Sp
.Vb 1
\&  =pod
\&
\&  This is a plain Pod paragraph.
\&
\&  =pod This text is ignored.
.Ve
.ie n .IP """=cut""" 4
.el .IP "``=cut''" 4
.IX Item "=cut"
This command indicates that this line is the end of this previously
started Pod block.  If there is any text after \*(L"=cut\*(R" on the line, it must be
ignored.  Examples:
.Sp
.Vb 1
\&  =cut
\&
\&  =cut The documentation ends here.
\&
\&  =cut
\&  # This is the first line of program text.
\&  sub foo { # This is the second.
.Ve
.Sp
It is an error to try to \fIstart\fR a Pod block with a \*(L"=cut\*(R" command.  In
that case, the Pod processor must halt parsing of the input file, and
must by default emit a warning.
.ie n .IP """=over""" 4
.el .IP "``=over''" 4
.IX Item "=over"
This command indicates that this is the start of a list/indent
region.  If there is any text following the \*(L"=over\*(R", it must consist
of only a nonzero positive numeral.  The semantics of this numeral is
explained in the \*(L"About =over...=back Regions\*(R" section, further
below.  Formatting codes are not expanded.  Examples:
.Sp
.Vb 1
\&  =over 3
\&
\&  =over 3.5
\&
\&  =over
.Ve
.ie n .IP """=item""" 4
.el .IP "``=item''" 4
.IX Item "=item"
This command indicates that an item in a list begins here.  Formatting
codes are processed.  The semantics of the (optional) text in the
remainder of this paragraph are
explained in the \*(L"About =over...=back Regions\*(R" section, further
below.  Examples:
.Sp
.Vb 1
\&  =item
\&
\&  =item *
\&
\&  =item      *    
\&
\&  =item 14
\&
\&  =item   3.
\&
\&  =item C<< $thing\->stuff(I<dodad>) >>
\&
\&  =item For transporting us beyond seas to be tried for pretended
\&  offenses
\&
\&  =item He is at this time transporting large armies of foreign
\&  mercenaries to complete the works of death, desolation and
\&  tyranny, already begun with circumstances of cruelty and perfidy
\&  scarcely paralleled in the most barbarous ages, and totally
\&  unworthy the head of a civilized nation.
.Ve
.ie n .IP """=back""" 4
.el .IP "``=back''" 4
.IX Item "=back"
This command indicates that this is the end of the region begun
by the most recent \*(L"=over\*(R" command.  It permits no text after the
\&\*(L"=back\*(R" command.
.ie n .IP """=begin formatname""" 4
.el .IP "``=begin formatname''" 4
.IX Item "=begin formatname"
.PD 0
.ie n .IP """=begin formatname parameter""" 4
.el .IP "``=begin formatname parameter''" 4
.IX Item "=begin formatname parameter"
.PD
This marks the following paragraphs (until the matching \*(L"=end
formatname\*(R") as being for some special kind of processing.  Unless
\&\*(L"formatname\*(R" begins with a colon, the contained non-command
paragraphs are data paragraphs.  But if \*(L"formatname\*(R" \fIdoes\fR begin
with a colon, then non-command paragraphs are ordinary paragraphs
or data paragraphs.  This is discussed in detail in the section
\&\*(L"About Data Paragraphs and \*(R"=begin/=end\*(L" Regions\*(R".
.Sp
It is advised that formatnames match the regexp
\&\f(CW\*(C`m/\eA:?[\-a\-zA\-Z0\-9_]+\ez/\*(C'\fR.  Everything following whitespace after the
formatname is a parameter that may be used by the formatter when dealing
with this region.  This parameter must not be repeated in the \*(L"=end\*(R"
paragraph.  Implementors should anticipate future expansion in the
semantics and syntax of the first parameter to \*(L"=begin\*(R"/\*(L"=end\*(R"/\*(L"=for\*(R".
.ie n .IP """=end formatname""" 4
.el .IP "``=end formatname''" 4
.IX Item "=end formatname"
This marks the end of the region opened by the matching
\&\*(L"=begin formatname\*(R" region.  If \*(L"formatname\*(R" is not the formatname
of the most recent open \*(L"=begin formatname\*(R" region, then this
is an error, and must generate an error message.  This
is discussed in detail in the section
\&\*(L"About Data Paragraphs and \*(R"=begin/=end\*(L" Regions\*(R".
.ie n .IP """=for formatname text...""" 4
.el .IP "``=for formatname text...''" 4
.IX Item "=for formatname text..."
This is synonymous with:
.Sp
.Vb 1
\&     =begin formatname
\&
\&     text...
\&
\&     =end formatname
.Ve
.Sp
That is, it creates a region consisting of a single paragraph; that
paragraph is to be treated as a normal paragraph if \*(L"formatname\*(R"
begins with a \*(L":\*(R"; if \*(L"formatname\*(R" \fIdoesn't\fR begin with a colon,
then \*(L"text...\*(R" will constitute a data paragraph.  There is no way
to use \*(L"=for formatname text...\*(R" to express \*(L"text...\*(R" as a verbatim
paragraph.
.ie n .IP """=encoding encodingname""" 4
.el .IP "``=encoding encodingname''" 4
.IX Item "=encoding encodingname"
This command, which should occur early in the document (at least
before any non-US-ASCII data!), declares that this document is
encoded in the encoding \fIencodingname\fR, which must be
an encoding name that Encode recognizes.  (Encode's list
of supported encodings, in Encode::Supported, is useful here.)
If the Pod parser cannot decode the declared encoding, it 
should emit a warning and may abort parsing the document
altogether.
.Sp
A document having more than one \*(L"=encoding\*(R" line should be
considered an error.  Pod processors may silently tolerate this if
the not-first \*(L"=encoding\*(R" lines are just duplicates of the
first one (e.g., if there's a \*(L"=encoding utf8\*(R" line, and later on
another \*(L"=encoding utf8\*(R" line).  But Pod processors should complain if
there are contradictory \*(L"=encoding\*(R" lines in the same document
(e.g., if there is a \*(L"=encoding utf8\*(R" early in the document and
\&\*(L"=encoding big5\*(R" later).  Pod processors that recognize BOMs
may also complain if they see an \*(L"=encoding\*(R" line
that contradicts the \s-1BOM \s0(e.g., if a document with a \s-1UTF\-16LE
BOM\s0 has an \*(L"=encoding shiftjis\*(R" line).
.PP
If a Pod processor sees any command other than the ones listed
above (like \*(L"=head\*(R", or \*(L"=haed1\*(R", or \*(L"=stuff\*(R", or \*(L"=cuttlefish\*(R",
or \*(L"=w123\*(R"), that processor must by default treat this as an
error.  It must not process the paragraph beginning with that
command, must by default warn of this as an error, and may
abort the parse.  A Pod parser may allow a way for particular
applications to add to the above list of known commands, and to
stipulate, for each additional command, whether formatting
codes should be processed.
.PP
Future versions of this specification may add additional
commands.
.SH "Pod Formatting Codes"
.IX Header "Pod Formatting Codes"
(Note that in previous drafts of this document and of perlpod,
formatting codes were referred to as \*(L"interior sequences\*(R", and
this term may still be found in the documentation for Pod parsers,
and in error messages from Pod processors.)
.PP
There are two syntaxes for formatting codes:
.IP "\(bu" 4
A formatting code starts with a capital letter (just US-ASCII [A\-Z])
followed by a \*(L"<\*(R", any number of characters, and ending with the first
matching \*(L">\*(R".  Examples:
.Sp
.Vb 1
\&    That\*(Aqs what I<you> think!
\&
\&    What\*(Aqs C<dump()> for?
\&
\&    X<C<chmod> and C<unlink()> Under Different Operating Systems>
.Ve
.IP "\(bu" 4
A formatting code starts with a capital letter (just US-ASCII [A\-Z])
followed by two or more \*(L"<\*(R"'s, one or more whitespace characters,
any number of characters, one or more whitespace characters,
and ending with the first matching sequence of two or more \*(L">\*(R"'s, where
the number of \*(L">\*(R"'s equals the number of \*(L"<\*(R"'s in the opening of this
formatting code.  Examples:
.Sp
.Vb 1
\&    That\*(Aqs what I<< you >> think!
\&
\&    C<<< open(X, ">>thing.dat") || die $! >>>
\&
\&    B<< $foo\->bar(); >>
.Ve
.Sp
With this syntax, the whitespace character(s) after the \*(L"C<<<\*(R"
and before the \*(L">>\*(R" (or whatever letter) are \fInot\fR renderable. They
do not signify whitespace, are merely part of the formatting codes
themselves.  That is, these are all synonymous:
.Sp
.Vb 7
\&    C<thing>
\&    C<< thing >>
\&    C<<           thing     >>
\&    C<<<   thing >>>
\&    C<<<<
\&    thing
\&               >>>>
.Ve
.Sp
and so on.
.Sp
Finally, the multiple-angle-bracket form does \fInot\fR alter the interpretation
of nested formatting codes, meaning that the following four example lines are
identical in meaning:
.Sp
.Vb 1
\&  B<example: C<$a E<lt>=E<gt> $b>>
\&
\&  B<example: C<< $a <=> $b >>>
\&
\&  B<example: C<< $a E<lt>=E<gt> $b >>>
\&
\&  B<<< example: C<< $a E<lt>=E<gt> $b >> >>>
.Ve
.PP
In parsing Pod, a notably tricky part is the correct parsing of
(potentially nested!) formatting codes.  Implementors should
consult the code in the \f(CW\*(C`parse_text\*(C'\fR routine in Pod::Parser as an
example of a correct implementation.
.ie n .IP """I<text>"" \*(-- italic text" 4
.el .IP "\f(CWI<text>\fR \*(-- italic text" 4
.IX Item "I<text> italic text"
See the brief discussion in \*(L"Formatting Codes\*(R" in perlpod.
.ie n .IP """B<text>"" \*(-- bold text" 4
.el .IP "\f(CWB<text>\fR \*(-- bold text" 4
.IX Item "B<text> bold text"
See the brief discussion in \*(L"Formatting Codes\*(R" in perlpod.
.ie n .IP """C<code>"" \*(-- code text" 4
.el .IP "\f(CWC<code>\fR \*(-- code text" 4
.IX Item "C<code> code text"
See the brief discussion in \*(L"Formatting Codes\*(R" in perlpod.
.ie n .IP """F<filename>"" \*(-- style for filenames" 4
.el .IP "\f(CWF<filename>\fR \*(-- style for filenames" 4
.IX Item "F<filename> style for filenames"
See the brief discussion in \*(L"Formatting Codes\*(R" in perlpod.
.ie n .IP """X<topic name>"" \*(-- an index entry" 4
.el .IP "\f(CWX<topic name>\fR \*(-- an index entry" 4
.IX Item "X<topic name> an index entry"
See the brief discussion in \*(L"Formatting Codes\*(R" in perlpod.
.Sp
This code is unusual in that most formatters completely discard
this code and its content.  Other formatters will render it with
invisible codes that can be used in building an index of
the current document.
.ie n .IP """Z<>"" \*(-- a null (zero-effect) formatting code" 4
.el .IP "\f(CWZ<>\fR \*(-- a null (zero-effect) formatting code" 4
.IX Item "Z<> a null (zero-effect) formatting code"
Discussed briefly in \*(L"Formatting Codes\*(R" in perlpod.
.Sp
This code is unusual is that it should have no content.  That is,
a processor may complain if it sees \f(CW\*(C`Z<potatoes>\*(C'\fR.  Whether
or not it complains, the \fIpotatoes\fR text should ignored.
.ie n .IP """L<name>"" \*(-- a hyperlink" 4
.el .IP "\f(CWL<name>\fR \*(-- a hyperlink" 4
.IX Item "L<name> a hyperlink"
The complicated syntaxes of this code are discussed at length in
\&\*(L"Formatting Codes\*(R" in perlpod, and implementation details are
discussed below, in \*(L"About L<...> Codes\*(R".  Parsing the
contents of L<content> is tricky.  Notably, the content has to be
checked for whether it looks like a \s-1URL,\s0 or whether it has to be split
on literal \*(L"|\*(R" and/or \*(L"/\*(R" (in the right order!), and so on,
\&\fIbefore\fR E<...> codes are resolved.
.ie n .IP """E<escape>"" \*(-- a character escape" 4
.el .IP "\f(CWE<escape>\fR \*(-- a character escape" 4
.IX Item "E<escape> a character escape"
See \*(L"Formatting Codes\*(R" in perlpod, and several points in
\&\*(L"Notes on Implementing Pod Processors\*(R".
.ie n .IP """S<text>"" \*(-- text contains non-breaking spaces" 4
.el .IP "\f(CWS<text>\fR \*(-- text contains non-breaking spaces" 4
.IX Item "S<text> text contains non-breaking spaces"
This formatting code is syntactically simple, but semantically
complex.  What it means is that each space in the printable
content of this code signifies a non-breaking space.
.Sp
Consider:
.Sp
.Vb 1
\&    C<$x ? $y    :  $z>
\&
\&    S<C<$x ? $y     :  $z>>
.Ve
.Sp
Both signify the monospace (c[ode] style) text consisting of
\&\*(L"$x\*(R", one space, \*(L"?\*(R", one space, \*(L":\*(R", one space, \*(L"$z\*(R".  The
difference is that in the latter, with the S code, those spaces
are not \*(L"normal\*(R" spaces, but instead are non-breaking spaces.
.PP
If a Pod processor sees any formatting code other than the ones
listed above (as in \*(L"N<...>\*(R", or \*(L"Q<...>\*(R", etc.), that
processor must by default treat this as an error.
A Pod parser may allow a way for particular
applications to add to the above list of known formatting codes;
a Pod parser might even allow a way to stipulate, for each additional
command, whether it requires some form of special processing, as
L<...> does.
.PP
Future versions of this specification may add additional
formatting codes.
.PP
Historical note:  A few older Pod processors would not see a \*(L">\*(R" as
closing a \*(L"C<\*(R" code, if the \*(L">\*(R" was immediately preceded by
a \*(L"\-\*(R".  This was so that this:
.PP
.Vb 1
\&    C<$foo\->bar>
.Ve
.PP
would parse as equivalent to this:
.PP
.Vb 1
\&    C<$foo\-E<gt>bar>
.Ve
.PP
instead of as equivalent to a \*(L"C\*(R" formatting code containing 
only \*(L"$foo\-\*(R", and then a \*(L"bar>\*(R" outside the \*(L"C\*(R" formatting code.  This
problem has since been solved by the addition of syntaxes like this:
.PP
.Vb 1
\&    C<< $foo\->bar >>
.Ve
.PP
Compliant parsers must not treat \*(L"\->\*(R" as special.
.PP
Formatting codes absolutely cannot span paragraphs.  If a code is
opened in one paragraph, and no closing code is found by the end of
that paragraph, the Pod parser must close that formatting code,
and should complain (as in \*(L"Unterminated I code in the paragraph
starting at line 123: 'Time objects are not...'\*(R").  So these
two paragraphs:
.PP
.Vb 1
\&  I<I told you not to do this!
\&
\&  Don\*(Aqt make me say it again!>
.Ve
.PP
\&...must \fInot\fR be parsed as two paragraphs in italics (with the I
code starting in one paragraph and starting in another.)  Instead,
the first paragraph should generate a warning, but that aside, the
above code must parse as if it were:
.PP
.Vb 1
\&  I<I told you not to do this!>
\&
\&  Don\*(Aqt make me say it again!E<gt>
.Ve
.PP
(In SGMLish jargon, all Pod commands are like block-level
elements, whereas all Pod formatting codes are like inline-level
elements.)
.SH "Notes on Implementing Pod Processors"
.IX Header "Notes on Implementing Pod Processors"
The following is a long section of miscellaneous requirements
and suggestions to do with Pod processing.
.IP "\(bu" 4
Pod formatters should tolerate lines in verbatim blocks that are of
any length, even if that means having to break them (possibly several
times, for very long lines) to avoid text running off the side of the
page.  Pod formatters may warn of such line-breaking.  Such warnings
are particularly appropriate for lines are over 100 characters long, which
are usually not intentional.
.IP "\(bu" 4
Pod parsers must recognize \fIall\fR of the three well-known newline
formats: \s-1CR, LF,\s0 and \s-1CRLF. \s0 See perlport.
.IP "\(bu" 4
Pod parsers should accept input lines that are of any length.
.IP "\(bu" 4
Since Perl recognizes a Unicode Byte Order Mark at the start of files
as signaling that the file is Unicode encoded as in \s-1UTF\-16 \s0(whether
big-endian or little-endian) or \s-1UTF\-8,\s0 Pod parsers should do the
same.  Otherwise, the character encoding should be understood as
being \s-1UTF\-8\s0 if the first highbit byte sequence in the file seems
valid as a \s-1UTF\-8\s0 sequence, or otherwise as Latin\-1.
.Sp
Future versions of this specification may specify
how Pod can accept other encodings.  Presumably treatment of other
encodings in Pod parsing would be as in \s-1XML\s0 parsing: whatever the
encoding declared by a particular Pod file, content is to be
stored in memory as Unicode characters.
.IP "\(bu" 4
The well known Unicode Byte Order Marks are as follows:  if the
file begins with the two literal byte values 0xFE 0xFF, this is
the \s-1BOM\s0 for big-endian \s-1UTF\-16. \s0 If the file begins with the two
literal byte value 0xFF 0xFE, this is the \s-1BOM\s0 for little-endian
\&\s-1UTF\-16. \s0 If the file begins with the three literal byte values
0xEF 0xBB 0xBF, this is the \s-1BOM\s0 for \s-1UTF\-8.\s0
.IP "\(bu" 4
A naive but sufficient heuristic for testing the first highbit
byte-sequence in a BOM-less file (whether in code or in Pod!), to see
whether that sequence is valid as \s-1UTF\-8 \s0(\s-1RFC 2279\s0) is to check whether
that the first byte in the sequence is in the range 0xC0 \- 0xFD
\&\fIand\fR whether the next byte is in the range
0x80 \- 0xBF.  If so, the parser may conclude that this file is in
\&\s-1UTF\-8,\s0 and all highbit sequences in the file should be assumed to
be \s-1UTF\-8. \s0 Otherwise the parser should treat the file as being
in Latin\-1.  In the unlikely circumstance that the first highbit
sequence in a truly non\-UTF\-8 file happens to appear to be \s-1UTF\-8,\s0 one
can cater to our heuristic (as well as any more intelligent heuristic)
by prefacing that line with a comment line containing a highbit
sequence that is clearly \fInot\fR valid as \s-1UTF\-8.  A\s0 line consisting
of simply \*(L"#\*(R", an e\-acute, and any non-highbit byte,
is sufficient to establish this file's encoding.
.IP "\(bu" 4
This document's requirements and suggestions about encodings
do not apply to Pod processors running on non-ASCII platforms,
notably \s-1EBCDIC\s0 platforms.
.IP "\(bu" 4
Pod processors must treat a \*(L"=for [label] [content...]\*(R" paragraph as
meaning the same thing as a \*(L"=begin [label]\*(R" paragraph, content, and
an \*(L"=end [label]\*(R" paragraph.  (The parser may conflate these two
constructs, or may leave them distinct, in the expectation that the
formatter will nevertheless treat them the same.)
.IP "\(bu" 4
When rendering Pod to a format that allows comments (i.e., to nearly
any format other than plaintext), a Pod formatter must insert comment
text identifying its name and version number, and the name and
version numbers of any modules it might be using to process the Pod.
Minimal examples:
.Sp
.Vb 1
\&  %% POD::Pod2PS v3.14159, using POD::Parser v1.92
\&
\&  <!\-\- Pod::HTML v3.14159, using POD::Parser v1.92 \-\->
\&
\&  {\edoccomm generated by Pod::Tree::RTF 3.14159 using Pod::Tree 1.08}
\&
\&  .\e" Pod::Man version 3.14159, using POD::Parser version 1.92
.Ve
.Sp
Formatters may also insert additional comments, including: the
release date of the Pod formatter program, the contact address for
the author(s) of the formatter, the current time, the name of input
file, the formatting options in effect, version of Perl used, etc.
.Sp
Formatters may also choose to note errors/warnings as comments,
besides or instead of emitting them otherwise (as in messages to
\&\s-1STDERR,\s0 or \f(CW\*(C`die\*(C'\fRing).
.IP "\(bu" 4
Pod parsers \fImay\fR emit warnings or error messages (\*(L"Unknown E code
E<zslig>!\*(R") to \s-1STDERR \s0(whether through printing to \s-1STDERR,\s0 or
\&\f(CW\*(C`warn\*(C'\fRing/\f(CW\*(C`carp\*(C'\fRing, or \f(CW\*(C`die\*(C'\fRing/\f(CW\*(C`croak\*(C'\fRing), but \fImust\fR allow
suppressing all such \s-1STDERR\s0 output, and instead allow an option for
reporting errors/warnings
in some other way, whether by triggering a callback, or noting errors
in some attribute of the document object, or some similarly unobtrusive
mechanism \*(-- or even by appending a \*(L"Pod Errors\*(R" section to the end of
the parsed form of the document.
.IP "\(bu" 4
In cases of exceptionally aberrant documents, Pod parsers may abort the
parse.  Even then, using \f(CW\*(C`die\*(C'\fRing/\f(CW\*(C`croak\*(C'\fRing is to be avoided; where
possible, the parser library may simply close the input file
and add text like \*(L"*** Formatting Aborted ***\*(R" to the end of the
(partial) in-memory document.
.IP "\(bu" 4
In paragraphs where formatting codes (like E<...>, B<...>)
are understood (i.e., \fInot\fR verbatim paragraphs, but \fIincluding\fR
ordinary paragraphs, and command paragraphs that produce renderable
text, like \*(L"=head1\*(R"), literal whitespace should generally be considered
\&\*(L"insignificant\*(R", in that one literal space has the same meaning as any
(nonzero) number of literal spaces, literal newlines, and literal tabs
(as long as this produces no blank lines, since those would terminate
the paragraph).  Pod parsers should compact literal whitespace in each
processed paragraph, but may provide an option for overriding this
(since some processing tasks do not require it), or may follow
additional special rules (for example, specially treating
period-space-space or period-newline sequences).
.IP "\(bu" 4
Pod parsers should not, by default, try to coerce apostrophe (') and
quote (\*(L") into smart quotes (little 9's, 66's, 99's, etc), nor try to
turn backtick (`) into anything else but a single backtick character
(distinct from an open quote character!), nor \*(R"\-\-" into anything but
two minus signs.  They \fImust never\fR do any of those things to text
in C<...> formatting codes, and never \fIever\fR to text in verbatim
paragraphs.
.IP "\(bu" 4
When rendering Pod to a format that has two kinds of hyphens (\-), one
that's a non-breaking hyphen, and another that's a breakable hyphen
(as in \*(L"object-oriented\*(R", which can be split across lines as
\&\*(L"object\-\*(R", newline, \*(L"oriented\*(R"), formatters are encouraged to
generally translate \*(L"\-\*(R" to non-breaking hyphen, but may apply
heuristics to convert some of these to breaking hyphens.
.IP "\(bu" 4
Pod formatters should make reasonable efforts to keep words of Perl
code from being broken across lines.  For example, \*(L"Foo::Bar\*(R" in some
formatting systems is seen as eligible for being broken across lines
as \*(L"Foo::\*(R" newline \*(L"Bar\*(R" or even \*(L"Foo::\-\*(R" newline \*(L"Bar\*(R".  This should
be avoided where possible, either by disabling all line-breaking in
mid-word, or by wrapping particular words with internal punctuation
in \*(L"don't break this across lines\*(R" codes (which in some formats may
not be a single code, but might be a matter of inserting non-breaking
zero-width spaces between every pair of characters in a word.)
.IP "\(bu" 4
Pod parsers should, by default, expand tabs in verbatim paragraphs as
they are processed, before passing them to the formatter or other
processor.  Parsers may also allow an option for overriding this.
.IP "\(bu" 4
Pod parsers should, by default, remove newlines from the end of
ordinary and verbatim paragraphs before passing them to the
formatter.  For example, while the paragraph you're reading now
could be considered, in Pod source, to end with (and contain)
the newline(s) that end it, it should be processed as ending with
(and containing) the period character that ends this sentence.
.IP "\(bu" 4
Pod parsers, when reporting errors, should make some effort to report
an approximate line number (\*(L"Nested E<>'s in Paragraph #52, near
line 633 of Thing/Foo.pm!\*(R"), instead of merely noting the paragraph
number (\*(L"Nested E<>'s in Paragraph #52 of Thing/Foo.pm!\*(R").  Where
this is problematic, the paragraph number should at least be
accompanied by an excerpt from the paragraph (\*(L"Nested E<>'s in
Paragraph #52 of Thing/Foo.pm, which begins 'Read/write accessor for
the C<interest rate> attribute...'\*(R").
.IP "\(bu" 4
Pod parsers, when processing a series of verbatim paragraphs one
after another, should consider them to be one large verbatim
paragraph that happens to contain blank lines.  I.e., these two
lines, which have a blank line between them:
.Sp
.Vb 1
\&        use Foo;
\&
\&        print Foo\->VERSION
.Ve
.Sp
should be unified into one paragraph (\*(L"\etuse Foo;\en\en\etprint
Foo\->\s-1VERSION\*(R"\s0) before being passed to the formatter or other
processor.  Parsers may also allow an option for overriding this.
.Sp
While this might be too cumbersome to implement in event-based Pod
parsers, it is straightforward for parsers that return parse trees.
.IP "\(bu" 4
Pod formatters, where feasible, are advised to avoid splitting short
verbatim paragraphs (under twelve lines, say) across pages.
.IP "\(bu" 4
Pod parsers must treat a line with only spaces and/or tabs on it as a
\&\*(L"blank line\*(R" such as separates paragraphs.  (Some older parsers
recognized only two adjacent newlines as a \*(L"blank line\*(R" but would not
recognize a newline, a space, and a newline, as a blank line.  This
is noncompliant behavior.)
.IP "\(bu" 4
Authors of Pod formatters/processors should make every effort to
avoid writing their own Pod parser.  There are already several in
\&\s-1CPAN,\s0 with a wide range of interface styles \*(-- and one of them,
Pod::Parser, comes with modern versions of Perl.
.IP "\(bu" 4
Characters in Pod documents may be conveyed either as literals, or by
number in E<n> codes, or by an equivalent mnemonic, as in
E<eacute> which is exactly equivalent to E<233>.
.Sp
Characters in the range 32\-126 refer to those well known US-ASCII
characters (also defined there by Unicode, with the same meaning),
which all Pod formatters must render faithfully.  Characters
in the ranges 0\-31 and 127\-159 should not be used (neither as
literals, nor as E<number> codes), except for the
literal byte-sequences for newline (13, 13 10, or 10), and tab (9).
.Sp
Characters in the range 160\-255 refer to Latin\-1 characters (also
defined there by Unicode, with the same meaning).  Characters above
255 should be understood to refer to Unicode characters.
.IP "\(bu" 4
Be warned
that some formatters cannot reliably render characters outside 32\-126;
and many are able to handle 32\-126 and 160\-255, but nothing above
255.
.IP "\(bu" 4
Besides the well-known \*(L"E<lt>\*(R" and \*(L"E<gt>\*(R" codes for
less-than and greater-than, Pod parsers must understand \*(L"E<sol>\*(R"
for \*(L"/\*(R" (solidus, slash), and \*(L"E<verbar>\*(R" for \*(L"|\*(R" (vertical bar,
pipe).  Pod parsers should also understand \*(L"E<lchevron>\*(R" and
\&\*(L"E<rchevron>\*(R" as legacy codes for characters 171 and 187, i.e.,
\&\*(L"left-pointing double angle quotation mark\*(R" = \*(L"left pointing
guillemet\*(R" and \*(L"right-pointing double angle quotation mark\*(R" = \*(L"right
pointing guillemet\*(R".  (These look like little \*(L"<<\*(R" and \*(L">>\*(R", and they
are now preferably expressed with the \s-1HTML/XHTML\s0 codes \*(L"E<laquo>\*(R"
and \*(L"E<raquo>\*(R".)
.IP "\(bu" 4
Pod parsers should understand all \*(L"E<html>\*(R" codes as defined
in the entity declarations in the most recent \s-1XHTML\s0 specification at
\&\f(CW\*(C`www.W3.org\*(C'\fR.  Pod parsers must understand at least the entities
that define characters in the range 160\-255 (Latin\-1).  Pod parsers,
when faced with some unknown "E<\fIidentifier\fR>" code,
shouldn't simply replace it with nullstring (by default, at least),
but may pass it through as a string consisting of the literal characters
E, less-than, \fIidentifier\fR, greater-than.  Or Pod parsers may offer the
alternative option of processing such unknown
"E<\fIidentifier\fR>\*(L" codes by firing an event especially
for such codes, or by adding a special node-type to the in-memory
document tree.  Such \*(R"E<\fIidentifier\fR>" may have special meaning
to some processors, or some processors may choose to add them to
a special error report.
.IP "\(bu" 4
Pod parsers must also support the \s-1XHTML\s0 codes \*(L"E<quot>\*(R" for
character 34 (doublequote, \*(L"), \*(R"E<amp>\*(L" for character 38
(ampersand, &), and \*(R"E<apos>" for character 39 (apostrophe, ').
.IP "\(bu" 4
Note that in all cases of \*(L"E<whatever>\*(R", \fIwhatever\fR (whether
an htmlname, or a number in any base) must consist only of
alphanumeric characters \*(-- that is, \fIwhatever\fR must watch
\&\f(CW\*(C`m/\eA\ew+\ez/\*(C'\fR.  So \*(L"E< 0 1 2 3 >\*(R" is invalid, because
it contains spaces, which aren't alphanumeric characters.  This
presumably does not \fIneed\fR special treatment by a Pod processor;
\&\*(L" 0 1 2 3 \*(R" doesn't look like a number in any base, so it would
presumably be looked up in the table of HTML-like names.  Since
there isn't (and cannot be) an HTML-like entity called \*(L" 0 1 2 3 \*(R",
this will be treated as an error.  However, Pod processors may
treat \*(L"E< 0 1 2 3 >\*(R" or \*(L"E<e\-acute>\*(R" as \fIsyntactically\fR
invalid, potentially earning a different error message than the
error message (or warning, or event) generated by a merely unknown
(but theoretically valid) htmlname, as in \*(L"E<qacute>\*(R"
[sic].  However, Pod parsers are not required to make this
distinction.
.IP "\(bu" 4
Note that E<number> \fImust not\fR be interpreted as simply
"codepoint \fInumber\fR in the current/native character set\*(L".  It always
means only \*(R"the character represented by codepoint \fInumber\fR in
Unicode."  (This is identical to the semantics of &#\fInumber\fR; in \s-1XML.\s0)
.Sp
This will likely require many formatters to have tables mapping from
treatable Unicode codepoints (such as the \*(L"\exE9\*(R" for the e\-acute
character) to the escape sequences or codes necessary for conveying
such sequences in the target output format.  A converter to *roff
would, for example know that \*(L"\exE9\*(R" (whether conveyed literally, or via
a E<...> sequence) is to be conveyed as \*(L"e\e\e*'\*(R".
Similarly, a program rendering Pod in a Mac \s-1OS\s0 application window, would
presumably need to know that \*(L"\exE9\*(R" maps to codepoint 142 in MacRoman
encoding that (at time of writing) is native for Mac \s-1OS. \s0 Such
Unicode2whatever mappings are presumably already widely available for
common output formats.  (Such mappings may be incomplete!  Implementers
are not expected to bend over backwards in an attempt to render
Cherokee syllabics, Etruscan runes, Byzantine musical symbols, or any
of the other weird things that Unicode can encode.)  And
if a Pod document uses a character not found in such a mapping, the
formatter should consider it an unrenderable character.
.IP "\(bu" 4
If, surprisingly, the implementor of a Pod formatter can't find a
satisfactory pre-existing table mapping from Unicode characters to
escapes in the target format (e.g., a decent table of Unicode
characters to *roff escapes), it will be necessary to build such a
table.  If you are in this circumstance, you should begin with the
characters in the range 0x00A0 \- 0x00FF, which is mostly the heavily
used accented characters.  Then proceed (as patience permits and
fastidiousness compels) through the characters that the (X)HTML
standards groups judged important enough to merit mnemonics
for.  These are declared in the (X)HTML specifications at the
www.W3.org site.  At time of writing (September 2001), the most recent
entity declaration files are:
.Sp
.Vb 3
\&  http://www.w3.org/TR/xhtml1/DTD/xhtml\-lat1.ent
\&  http://www.w3.org/TR/xhtml1/DTD/xhtml\-special.ent
\&  http://www.w3.org/TR/xhtml1/DTD/xhtml\-symbol.ent
.Ve
.Sp
Then you can progress through any remaining notable Unicode characters
in the range 0x2000\-0x204D (consult the character tables at
www.unicode.org), and whatever else strikes your fancy.  For example,
in \fIxhtml\-symbol.ent\fR, there is the entry:
.Sp
.Vb 1
\&  <!ENTITY infin    "&#8734;"> <!\-\- infinity, U+221E ISOtech \-\->
.Ve
.Sp
While the mapping \*(L"infin\*(R" to the character \*(L"\ex{221E}\*(R" will (hopefully)
have been already handled by the Pod parser, the presence of the
character in this file means that it's reasonably important enough to
include in a formatter's table that maps from notable Unicode characters
to the codes necessary for rendering them.  So for a Unicode\-to\-*roff
mapping, for example, this would merit the entry:
.Sp
.Vb 1
\&  "\ex{221E}" => \*(Aq\e(in\*(Aq,
.Ve
.Sp
It is eagerly hoped that in the future, increasing numbers of formats
(and formatters) will support Unicode characters directly (as (X)HTML
does with \f(CW\*(C`&infin;\*(C'\fR, \f(CW\*(C`&#8734;\*(C'\fR, or \f(CW\*(C`&#x221E;\*(C'\fR), reducing the need
for idiosyncratic mappings of Unicode\-to\-\fImy_escapes\fR.
.IP "\(bu" 4
It is up to individual Pod formatter to display good judgement when
confronted with an unrenderable character (which is distinct from an
unknown E<thing> sequence that the parser couldn't resolve to
anything, renderable or not).  It is good practice to map Latin letters
with diacritics (like \*(L"E<eacute>\*(R"/\*(L"E<233>\*(R") to the corresponding
unaccented US-ASCII letters (like a simple character 101, \*(L"e\*(R"), but
clearly this is often not feasible, and an unrenderable character may
be represented as \*(L"?\*(R", or the like.  In attempting a sane fallback
(as from E<233> to \*(L"e\*(R"), Pod formatters may use the
\&\f(CW%Latin1Code_to_fallback\fR table in Pod::Escapes, or
Text::Unidecode, if available.
.Sp
For example, this Pod text:
.Sp
.Vb 1
\&  magic is enabled if you set C<$Currency> to \*(AqE<euro>\*(Aq.
.Ve
.Sp
may be rendered as:
"magic is enabled if you set \f(CW$Currency\fR to '\fI?\fR'\*(L" or as
\&\*(R"magic is enabled if you set \f(CW$Currency\fR to '\fB[euro]\fR'\*(L", or as
\&\*(R"magic is enabled if you set \f(CW$Currency\fR to '[x20AC]', etc.
.Sp
A Pod formatter may also note, in a comment or warning, a list of what
unrenderable characters were encountered.
.IP "\(bu" 4
E<...> may freely appear in any formatting code (other than
in another E<...> or in an Z<>).  That is, \*(L"X<The
E<euro>1,000,000 Solution>\*(R" is valid, as is \*(L"L<The
E<euro>1,000,000 Solution|Million::Euros>\*(R".
.IP "\(bu" 4
Some Pod formatters output to formats that implement non-breaking
spaces as an individual character (which I'll call \*(L"\s-1NBSP\*(R"\s0), and
others output to formats that implement non-breaking spaces just as
spaces wrapped in a \*(L"don't break this across lines\*(R" code.  Note that
at the level of Pod, both sorts of codes can occur: Pod can contain a
\&\s-1NBSP\s0 character (whether as a literal, or as a \*(L"E<160>\*(R" or
\&\*(L"E<nbsp>\*(R" code); and Pod can contain \*(L"S<foo
I<bar> baz>\*(R" codes, where \*(L"mere spaces\*(R" (character 32) in
such codes are taken to represent non-breaking spaces.  Pod
parsers should consider supporting the optional parsing of \*(L"S<foo
I<bar> baz>\*(R" as if it were
"foo\fI\s-1NBSP\s0\fRI<bar>\fI\s-1NBSP\s0\fRbaz", and, going the other way, the
optional parsing of groups of words joined by \s-1NBSP\s0's as if each group
were in a S<...> code, so that formatters may use the
representation that maps best to what the output format demands.
.IP "\(bu" 4
Some processors may find that the \f(CW\*(C`S<...>\*(C'\fR code is easiest to
implement by replacing each space in the parse tree under the content
of the S, with an \s-1NBSP. \s0 But note: the replacement should apply \fInot\fR to
spaces in \fIall\fR text, but \fIonly\fR to spaces in \fIprintable\fR text.  (This
distinction may or may not be evident in the particular tree/event
model implemented by the Pod parser.)  For example, consider this
unusual case:
.Sp
.Vb 1
\&   S<L</Autoloaded Functions>>
.Ve
.Sp
This means that the space in the middle of the visible link text must
not be broken across lines.  In other words, it's the same as this:
.Sp
.Vb 1
\&   L<"AutoloadedE<160>Functions"/Autoloaded Functions>
.Ve
.Sp
However, a misapplied space-to-NBSP replacement could (wrongly)
produce something equivalent to this:
.Sp
.Vb 1
\&   L<"AutoloadedE<160>Functions"/AutoloadedE<160>Functions>
.Ve
.Sp
\&...which is almost definitely not going to work as a hyperlink (assuming
this formatter outputs a format supporting hypertext).
.Sp
Formatters may choose to just not support the S format code,
especially in cases where the output format simply has no \s-1NBSP\s0
character/code and no code for \*(L"don't break this stuff across lines\*(R".
.IP "\(bu" 4
Besides the \s-1NBSP\s0 character discussed above, implementors are reminded
of the existence of the other \*(L"special\*(R" character in Latin\-1, the
\&\*(L"soft hyphen\*(R" character, also known as \*(L"discretionary hyphen\*(R",
i.e. \f(CW\*(C`E<173>\*(C'\fR = \f(CW\*(C`E<0xAD>\*(C'\fR =
\&\f(CW\*(C`E<shy>\*(C'\fR).  This character expresses an optional hyphenation
point.  That is, it normally renders as nothing, but may render as a
\&\*(L"\-\*(R" if a formatter breaks the word at that point.  Pod formatters
should, as appropriate, do one of the following:  1) render this with
a code with the same meaning (e.g., \*(L"\e\-\*(R" in \s-1RTF\s0), 2) pass it through
in the expectation that the formatter understands this character as
such, or 3) delete it.
.Sp
For example:
.Sp
.Vb 3
\&  sigE<shy>action
\&  manuE<shy>script
\&  JarkE<shy>ko HieE<shy>taE<shy>nieE<shy>mi
.Ve
.Sp
These signal to a formatter that if it is to hyphenate \*(L"sigaction\*(R"
or \*(L"manuscript\*(R", then it should be done as
"sig\-\fI[linebreak]\fRaction\*(L" or \*(R"manu\-\fI[linebreak]\fRscript"
(and if it doesn't hyphenate it, then the \f(CW\*(C`E<shy>\*(C'\fR doesn't
show up at all).  And if it is
to hyphenate \*(L"Jarkko\*(R" and/or \*(L"Hietaniemi\*(R", it can do
so only at the points where there is a \f(CW\*(C`E<shy>\*(C'\fR code.
.Sp
In practice, it is anticipated that this character will not be used
often, but formatters should either support it, or delete it.
.IP "\(bu" 4
If you think that you want to add a new command to Pod (like, say, a
\&\*(L"=biblio\*(R" command), consider whether you could get the same
effect with a for or begin/end sequence: \*(L"=for biblio ...\*(R" or \*(L"=begin
biblio\*(R" ... \*(L"=end biblio\*(R".  Pod processors that don't understand
\&\*(L"=for biblio\*(R", etc, will simply ignore it, whereas they may complain
loudly if they see \*(L"=biblio\*(R".
.IP "\(bu" 4
Throughout this document, \*(L"Pod\*(R" has been the preferred spelling for
the name of the documentation format.  One may also use \*(L"\s-1POD\*(R"\s0 or
\&\*(L"pod\*(R".  For the documentation that is (typically) in the Pod
format, you may use \*(L"pod\*(R", or \*(L"Pod\*(R", or \*(L"\s-1POD\*(R". \s0 Understanding these
distinctions is useful; but obsessing over how to spell them, usually
is not.
.SH "About L<...> Codes"
.IX Header "About L<...> Codes"
As you can tell from a glance at perlpod, the L<...>
code is the most complex of the Pod formatting codes.  The points below
will hopefully clarify what it means and how processors should deal
with it.
.IP "\(bu" 4
In parsing an L<...> code, Pod parsers must distinguish at least
four attributes:
.RS 4
.IP "First:" 4
.IX Item "First:"
The link-text.  If there is none, this must be undef.  (E.g., in
\&\*(L"L<Perl Functions|perlfunc>\*(R", the link-text is \*(L"Perl Functions\*(R".
In \*(L"L<Time::HiRes>\*(R" and even \*(L"L<|Time::HiRes>\*(R", there is no
link text.  Note that link text may contain formatting.)
.IP "Second:" 4
.IX Item "Second:"
The possibly inferred link-text; i.e., if there was no real link
text, then this is the text that we'll infer in its place.  (E.g., for
\&\*(L"L<Getopt::Std>\*(R", the inferred link text is \*(L"Getopt::Std\*(R".)
.IP "Third:" 4
.IX Item "Third:"
The name or \s-1URL,\s0 or undef if none.  (E.g., in \*(L"L<Perl
Functions|perlfunc>\*(R", the name (also sometimes called the page)
is \*(L"perlfunc\*(R".  In \*(L"L</CAVEATS>\*(R", the name is undef.)
.IP "Fourth:" 4
.IX Item "Fourth:"
The section (\s-1AKA \s0\*(L"item\*(R" in older perlpods), or undef if none.  E.g.,
in \*(L"L<Getopt::Std/DESCRIPTION>\*(R", \*(L"\s-1DESCRIPTION\*(R"\s0 is the section.  (Note
that this is not the same as a manpage section like the \*(L"5\*(R" in \*(L"man 5
crontab\*(R".  \*(L"Section Foo\*(R" in the Pod sense means the part of the text
that's introduced by the heading or item whose text is \*(L"Foo\*(R".)
.RE
.RS 4
.Sp
Pod parsers may also note additional attributes including:
.IP "Fifth:" 4
.IX Item "Fifth:"
A flag for whether item 3 (if present) is a \s-1URL \s0(like
\&\*(L"http://lists.perl.org\*(R" is), in which case there should be no section
attribute; a Pod name (like \*(L"perldoc\*(R" and \*(L"Getopt::Std\*(R" are); or
possibly a man page name (like \*(L"\fIcrontab\fR\|(5)\*(R" is).
.IP "Sixth:" 4
.IX Item "Sixth:"
The raw original L<...> content, before text is split on
\&\*(L"|\*(R", \*(L"/\*(R", etc, and before E<...> codes are expanded.
.RE
.RS 4
.Sp
(The above were numbered only for concise reference below.  It is not
a requirement that these be passed as an actual list or array.)
.Sp
For example:
.Sp
.Vb 7
\&  L<Foo::Bar>
\&    =>  undef,                          # link text
\&        "Foo::Bar",                     # possibly inferred link text
\&        "Foo::Bar",                     # name
\&        undef,                          # section
\&        \*(Aqpod\*(Aq,                          # what sort of link
\&        "Foo::Bar"                      # original content
\&
\&  L<Perlport\*(Aqs section on NL\*(Aqs|perlport/Newlines>
\&    =>  "Perlport\*(Aqs section on NL\*(Aqs",   # link text
\&        "Perlport\*(Aqs section on NL\*(Aqs",   # possibly inferred link text
\&        "perlport",                     # name
\&        "Newlines",                     # section
\&        \*(Aqpod\*(Aq,                          # what sort of link
\&        "Perlport\*(Aqs section on NL\*(Aqs|perlport/Newlines" # orig. content
\&
\&  L<perlport/Newlines>
\&    =>  undef,                          # link text
\&        \*(Aq"Newlines" in perlport\*(Aq,       # possibly inferred link text
\&        "perlport",                     # name
\&        "Newlines",                     # section
\&        \*(Aqpod\*(Aq,                          # what sort of link
\&        "perlport/Newlines"             # original content
\&
\&  L<crontab(5)/"DESCRIPTION">
\&    =>  undef,                          # link text
\&        \*(Aq"DESCRIPTION" in crontab(5)\*(Aq,  # possibly inferred link text
\&        "crontab(5)",                   # name
\&        "DESCRIPTION",                  # section
\&        \*(Aqman\*(Aq,                          # what sort of link
\&        \*(Aqcrontab(5)/"DESCRIPTION"\*(Aq      # original content
\&
\&  L</Object Attributes>
\&    =>  undef,                          # link text
\&        \*(Aq"Object Attributes"\*(Aq,          # possibly inferred link text
\&        undef,                          # name
\&        "Object Attributes",            # section
\&        \*(Aqpod\*(Aq,                          # what sort of link
\&        "/Object Attributes"            # original content
\&
\&  L<http://www.perl.org/>
\&    =>  undef,                          # link text
\&        "http://www.perl.org/",         # possibly inferred link text
\&        "http://www.perl.org/",         # name
\&        undef,                          # section
\&        \*(Aqurl\*(Aq,                          # what sort of link
\&        "http://www.perl.org/"          # original content
\&
\&  L<Perl.org|http://www.perl.org/>
\&    =>  "Perl.org",                     # link text
\&        "http://www.perl.org/",         # possibly inferred link text
\&        "http://www.perl.org/",         # name
\&        undef,                          # section
\&        \*(Aqurl\*(Aq,                          # what sort of link
\&        "Perl.org|http://www.perl.org/" # original content
.Ve
.Sp
Note that you can distinguish URL-links from anything else by the
fact that they match \f(CW\*(C`m/\eA\ew+:[^:\es]\eS*\ez/\*(C'\fR.  So
\&\f(CW\*(C`L<http://www.perl.com>\*(C'\fR is a \s-1URL,\s0 but
\&\f(CW\*(C`L<HTTP::Response>\*(C'\fR isn't.
.RE
.IP "\(bu" 4
In case of L<...> codes with no \*(L"text|\*(R" part in them,
older formatters have exhibited great variation in actually displaying
the link or cross reference.  For example, L<\fIcrontab\fR\|(5)> would render
as "the \f(CWcrontab(5)\fR manpage\*(L", or \*(R"in the \f(CWcrontab(5)\fR manpage\*(L"
or just \*(R"\f(CWcrontab(5)\fR".
.Sp
Pod processors must now treat \*(L"text|\*(R"\-less links as follows:
.Sp
.Vb 3
\&  L<name>         =>  L<name|name>
\&  L</section>     =>  L<"section"|/section>
\&  L<name/section> =>  L<"section" in name|name/section>
.Ve
.IP "\(bu" 4
Note that section names might contain markup.  I.e., if a section
starts with:
.Sp
.Vb 1
\&  =head2 About the C<\-M> Operator
.Ve
.Sp
or with:
.Sp
.Vb 1
\&  =item About the C<\-M> Operator
.Ve
.Sp
then a link to it would look like this:
.Sp
.Vb 1
\&  L<somedoc/About the C<\-M> Operator>
.Ve
.Sp
Formatters may choose to ignore the markup for purposes of resolving
the link and use only the renderable characters in the section name,
as in:
.Sp
.Vb 2
\&  <h1><a name="About_the_\-M_Operator">About the <code>\-M</code>
\&  Operator</h1>
\&
\&  ...
\&
\&  <a href="somedoc#About_the_\-M_Operator">About the <code>\-M</code>
\&  Operator" in somedoc</a>
.Ve
.IP "\(bu" 4
Previous versions of perlpod distinguished \f(CW\*(C`L<name/"section">\*(C'\fR
links from \f(CW\*(C`L<name/item>\*(C'\fR links (and their targets).  These
have been merged syntactically and semantically in the current
specification, and \fIsection\fR can refer either to a "=head\fIn\fR Heading
Content\*(L" command or to a \*(R"=item Item Content" command.  This
specification does not specify what behavior should be in the case
of a given document having several things all seeming to produce the
same \fIsection\fR identifier (e.g., in \s-1HTML,\s0 several things all producing
the same \fIanchorname\fR in <a name="\fIanchorname\fR">...</a>
elements).  Where Pod processors can control this behavior, they should
use the first such anchor.  That is, \f(CW\*(C`L<Foo/Bar>\*(C'\fR refers to the
\&\fIfirst\fR \*(L"Bar\*(R" section in Foo.
.Sp
But for some processors/formats this cannot be easily controlled; as
with the \s-1HTML\s0 example, the behavior of multiple ambiguous
<a name="\fIanchorname\fR">...</a> is most easily just left up to
browsers to decide.
.IP "\(bu" 4
In a \f(CW\*(C`L<text|...>\*(C'\fR code, text may contain formatting codes
for formatting or for E<...> escapes, as in:
.Sp
.Vb 1
\&  L<B<ummE<234>stuff>|...>
.Ve
.Sp
For \f(CW\*(C`L<...>\*(C'\fR codes without a \*(L"name|\*(R" part, only
\&\f(CW\*(C`E<...>\*(C'\fR and \f(CW\*(C`Z<>\*(C'\fR codes may occur.  That is,
authors should not use "\f(CW\*(C`L<B<Foo::Bar>>\*(C'\fR".
.Sp
Note, however, that formatting codes and Z<>'s can occur in any
and all parts of an L<...> (i.e., in \fIname\fR, \fIsection\fR, \fItext\fR,
and \fIurl\fR).
.Sp
Authors must not nest L<...> codes.  For example, \*(L"L<The
L<Foo::Bar> man page>\*(R" should be treated as an error.
.IP "\(bu" 4
Note that Pod authors may use formatting codes inside the \*(L"text\*(R"
part of \*(L"L<text|name>\*(R" (and so on for L<text|/\*(L"sec\*(R">).
.Sp
In other words, this is valid:
.Sp
.Vb 1
\&  Go read L<the docs on C<$.>|perlvar/"$.">
.Ve
.Sp
Some output formats that do allow rendering \*(L"L<...>\*(R" codes as
hypertext, might not allow the link-text to be formatted; in
that case, formatters will have to just ignore that formatting.
.IP "\(bu" 4
At time of writing, \f(CW\*(C`L<name>\*(C'\fR values are of two types:
either the name of a Pod page like \f(CW\*(C`L<Foo::Bar>\*(C'\fR (which
might be a real Perl module or program in an \f(CW@INC\fR / \s-1PATH\s0
directory, or a .pod file in those places); or the name of a Unix
man page, like \f(CW\*(C`L<crontab(5)>\*(C'\fR.  In theory, \f(CW\*(C`L<chmod>\*(C'\fR
in ambiguous between a Pod page called \*(L"chmod\*(R", or the Unix man page
\&\*(L"chmod\*(R" (in whatever man-section).  However, the presence of a string
in parens, as in \*(L"\fIcrontab\fR\|(5)\*(R", is sufficient to signal that what
is being discussed is not a Pod page, and so is presumably a
Unix man page.  The distinction is of no importance to many
Pod processors, but some processors that render to hypertext formats
may need to distinguish them in order to know how to render a
given \f(CW\*(C`L<foo>\*(C'\fR code.
.IP "\(bu" 4
Previous versions of perlpod allowed for a \f(CW\*(C`L<section>\*(C'\fR syntax (as in
\&\f(CW\*(C`L<Object Attributes>\*(C'\fR), which was not easily distinguishable from
\&\f(CW\*(C`L<name>\*(C'\fR syntax and for \f(CW\*(C`L<"section">\*(C'\fR which was only
slightly less ambiguous.  This syntax is no longer in the specification, and
has been replaced by the \f(CW\*(C`L</section>\*(C'\fR syntax (where the slash was
formerly optional).  Pod parsers should tolerate the \f(CW\*(C`L<"section">\*(C'\fR
syntax, for a while at least.  The suggested heuristic for distinguishing
\&\f(CW\*(C`L<section>\*(C'\fR from \f(CW\*(C`L<name>\*(C'\fR is that if it contains any
whitespace, it's a \fIsection\fR.  Pod processors should warn about this being
deprecated syntax.
.SH "About =over...=back Regions"
.IX Header "About =over...=back Regions"
\&\*(L"=over\*(R"...\*(L"=back\*(R" regions are used for various kinds of list-like
structures.  (I use the term \*(L"region\*(R" here simply as a collective
term for everything from the \*(L"=over\*(R" to the matching \*(L"=back\*(R".)
.IP "\(bu" 4
The non-zero numeric \fIindentlevel\fR in "=over \fIindentlevel\fR\*(L" ...
\&\*(R"=back\*(L" is used for giving the formatter a clue as to how many
\&\*(R"spaces" (ems, or roughly equivalent units) it should tab over,
although many formatters will have to convert this to an absolute
measurement that may not exactly match with the size of spaces (or M's)
in the document's base font.  Other formatters may have to completely
ignore the number.  The lack of any explicit \fIindentlevel\fR parameter is
equivalent to an \fIindentlevel\fR value of 4.  Pod processors may
complain if \fIindentlevel\fR is present but is not a positive number
matching \f(CW\*(C`m/\eA(\ed*\e.)?\ed+\ez/\*(C'\fR.
.IP "\(bu" 4
Authors of Pod formatters are reminded that \*(L"=over\*(R" ... \*(L"=back\*(R" may
map to several different constructs in your output format.  For
example, in converting Pod to (X)HTML, it can map to any of
<ul>...</ul>, <ol>...</ol>, <dl>...</dl>, or
<blockquote>...</blockquote>.  Similarly, \*(L"=item\*(R" can map to <li> or
<dt>.
.IP "\(bu" 4
Each \*(L"=over\*(R" ... \*(L"=back\*(R" region should be one of the following:
.RS 4
.IP "\(bu" 4
An \*(L"=over\*(R" ... \*(L"=back\*(R" region containing only \*(L"=item *\*(R" commands,
each followed by some number of ordinary/verbatim paragraphs, other
nested \*(L"=over\*(R" ... \*(L"=back\*(R" regions, \*(L"=for...\*(R" paragraphs, and
\&\*(L"=begin\*(R"...\*(L"=end\*(R" regions.
.Sp
(Pod processors must tolerate a bare \*(L"=item\*(R" as if it were \*(L"=item
*\*(R".)  Whether \*(L"*\*(R" is rendered as a literal asterisk, an \*(L"o\*(R", or as
some kind of real bullet character, is left up to the Pod formatter,
and may depend on the level of nesting.
.IP "\(bu" 4
An \*(L"=over\*(R" ... \*(L"=back\*(R" region containing only
\&\f(CW\*(C`m/\eA=item\es+\ed+\e.?\es*\ez/\*(C'\fR paragraphs, each one (or each group of them)
followed by some number of ordinary/verbatim paragraphs, other nested
\&\*(L"=over\*(R" ... \*(L"=back\*(R" regions, \*(L"=for...\*(R" paragraphs, and/or
\&\*(L"=begin\*(R"...\*(L"=end\*(R" codes.  Note that the numbers must start at 1
in each section, and must proceed in order and without skipping
numbers.
.Sp
(Pod processors must tolerate lines like \*(L"=item 1\*(R" as if they were
\&\*(L"=item 1.\*(R", with the period.)
.IP "\(bu" 4
An \*(L"=over\*(R" ... \*(L"=back\*(R" region containing only \*(L"=item [text]\*(R"
commands, each one (or each group of them) followed by some number of
ordinary/verbatim paragraphs, other nested \*(L"=over\*(R" ... \*(L"=back\*(R"
regions, or \*(L"=for...\*(R" paragraphs, and \*(L"=begin\*(R"...\*(L"=end\*(R" regions.
.Sp
The \*(L"=item [text]\*(R" paragraph should not match
\&\f(CW\*(C`m/\eA=item\es+\ed+\e.?\es*\ez/\*(C'\fR or \f(CW\*(C`m/\eA=item\es+\e*\es*\ez/\*(C'\fR, nor should it
match just \f(CW\*(C`m/\eA=item\es*\ez/\*(C'\fR.
.IP "\(bu" 4
An \*(L"=over\*(R" ... \*(L"=back\*(R" region containing no \*(L"=item\*(R" paragraphs at
all, and containing only some number of 
ordinary/verbatim paragraphs, and possibly also some nested \*(L"=over\*(R"
\&... \*(L"=back\*(R" regions, \*(L"=for...\*(R" paragraphs, and \*(L"=begin\*(R"...\*(L"=end\*(R"
regions.  Such an itemless \*(L"=over\*(R" ... \*(L"=back\*(R" region in Pod is
equivalent in meaning to a \*(L"<blockquote>...</blockquote>\*(R" element in
\&\s-1HTML.\s0
.RE
.RS 4
.Sp
Note that with all the above cases, you can determine which type of
\&\*(L"=over\*(R" ... \*(L"=back\*(R" you have, by examining the first (non\-\*(L"=cut\*(R", 
non\-\*(L"=pod\*(R") Pod paragraph after the \*(L"=over\*(R" command.
.RE
.IP "\(bu" 4
Pod formatters \fImust\fR tolerate arbitrarily large amounts of text
in the "=item \fItext...\fR" paragraph.  In practice, most such
paragraphs are short, as in:
.Sp
.Vb 1
\&  =item For cutting off our trade with all parts of the world
.Ve
.Sp
But they may be arbitrarily long:
.Sp
.Vb 2
\&  =item For transporting us beyond seas to be tried for pretended
\&  offenses
\&
\&  =item He is at this time transporting large armies of foreign
\&  mercenaries to complete the works of death, desolation and
\&  tyranny, already begun with circumstances of cruelty and perfidy
\&  scarcely paralleled in the most barbarous ages, and totally
\&  unworthy the head of a civilized nation.
.Ve
.IP "\(bu" 4
Pod processors should tolerate \*(L"=item *\*(R" / "=item \fInumber\fR" commands
with no accompanying paragraph.  The middle item is an example:
.Sp
.Vb 1
\&  =over
\&
\&  =item 1
\&
\&  Pick up dry cleaning.
\&
\&  =item 2
\&
\&  =item 3
\&
\&  Stop by the store.  Get Abba Zabas, Stoli, and cheap lawn chairs.
\&
\&  =back
.Ve
.IP "\(bu" 4
No \*(L"=over\*(R" ... \*(L"=back\*(R" region can contain headings.  Processors may
treat such a heading as an error.
.IP "\(bu" 4
Note that an \*(L"=over\*(R" ... \*(L"=back\*(R" region should have some
content.  That is, authors should not have an empty region like this:
.Sp
.Vb 1
\&  =over
\&
\&  =back
.Ve
.Sp
Pod processors seeing such a contentless \*(L"=over\*(R" ... \*(L"=back\*(R" region,
may ignore it, or may report it as an error.
.IP "\(bu" 4
Processors must tolerate an \*(L"=over\*(R" list that goes off the end of the
document (i.e., which has no matching \*(L"=back\*(R"), but they may warn
about such a list.
.IP "\(bu" 4
Authors of Pod formatters should note that this construct:
.Sp
.Vb 1
\&  =item Neque
\&
\&  =item Porro
\&
\&  =item Quisquam Est
\&
\&  Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci 
\&  velit, sed quia non numquam eius modi tempora incidunt ut
\&  labore et dolore magnam aliquam quaerat voluptatem.
\&
\&  =item Ut Enim
.Ve
.Sp
is semantically ambiguous, in a way that makes formatting decisions
a bit difficult.  On the one hand, it could be mention of an item
\&\*(L"Neque\*(R", mention of another item \*(L"Porro\*(R", and mention of another
item \*(L"Quisquam Est\*(R", with just the last one requiring the explanatory
paragraph \*(L"Qui dolorem ipsum quia dolor...\*(R"; and then an item
\&\*(L"Ut Enim\*(R".  In that case, you'd want to format it like so:
.Sp
.Vb 1
\&  Neque
\&
\&  Porro
\&
\&  Quisquam Est
\&    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
\&    velit, sed quia non numquam eius modi tempora incidunt ut
\&    labore et dolore magnam aliquam quaerat voluptatem.
\&
\&  Ut Enim
.Ve
.Sp
But it could equally well be a discussion of three (related or equivalent)
items, \*(L"Neque\*(R", \*(L"Porro\*(R", and \*(L"Quisquam Est\*(R", followed by a paragraph
explaining them all, and then a new item \*(L"Ut Enim\*(R".  In that case, you'd
probably want to format it like so:
.Sp
.Vb 6
\&  Neque
\&  Porro
\&  Quisquam Est
\&    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
\&    velit, sed quia non numquam eius modi tempora incidunt ut
\&    labore et dolore magnam aliquam quaerat voluptatem.
\&
\&  Ut Enim
.Ve
.Sp
But (for the foreseeable future), Pod does not provide any way for Pod
authors to distinguish which grouping is meant by the above
\&\*(L"=item\*(R"\-cluster structure.  So formatters should format it like so:
.Sp
.Vb 1
\&  Neque
\&
\&  Porro
\&
\&  Quisquam Est
\&
\&    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
\&    velit, sed quia non numquam eius modi tempora incidunt ut
\&    labore et dolore magnam aliquam quaerat voluptatem.
\&
\&  Ut Enim
.Ve
.Sp
That is, there should be (at least roughly) equal spacing between
items as between paragraphs (although that spacing may well be less
than the full height of a line of text).  This leaves it to the reader
to use (con)textual cues to figure out whether the \*(L"Qui dolorem
ipsum...\*(R" paragraph applies to the \*(L"Quisquam Est\*(R" item or to all three
items \*(L"Neque\*(R", \*(L"Porro\*(R", and \*(L"Quisquam Est\*(R".  While not an ideal
situation, this is preferable to providing formatting cues that may
be actually contrary to the author's intent.
.ie n .SH "About Data Paragraphs and ""=begin/=end"" Regions"
.el .SH "About Data Paragraphs and ``=begin/=end'' Regions"
.IX Header "About Data Paragraphs and =begin/=end Regions"
Data paragraphs are typically used for inlining non-Pod data that is
to be used (typically passed through) when rendering the document to
a specific format:
.PP
.Vb 1
\&  =begin rtf
\&
\&  \epar{\epard\eqr\esa4500{\ei Printed\e~\echdate\e~\echtime}\epar}
\&
\&  =end rtf
.Ve
.PP
The exact same effect could, incidentally, be achieved with a single
\&\*(L"=for\*(R" paragraph:
.PP
.Vb 1
\&  =for rtf \epar{\epard\eqr\esa4500{\ei Printed\e~\echdate\e~\echtime}\epar}
.Ve
.PP
(Although that is not formally a data paragraph, it has the same
meaning as one, and Pod parsers may parse it as one.)
.PP
Another example of a data paragraph:
.PP
.Vb 1
\&  =begin html
\&
\&  I like <em>PIE</em>!
\&
\&  <hr>Especially pecan pie!
\&
\&  =end html
.Ve
.PP
If these were ordinary paragraphs, the Pod parser would try to
expand the \*(L"E</em>\*(R" (in the first paragraph) as a formatting
code, just like \*(L"E<lt>\*(R" or \*(L"E<eacute>\*(R".  But since this
is in a "=begin \fIidentifier\fR\*(L"...\*(R"=end \fIidentifier\fR" region \fIand\fR
the identifier \*(L"html\*(R" doesn't begin have a \*(L":\*(R" prefix, the contents
of this region are stored as data paragraphs, instead of being
processed as ordinary paragraphs (or if they began with a spaces
and/or tabs, as verbatim paragraphs).
.PP
As a further example: At time of writing, no \*(L"biblio\*(R" identifier is
supported, but suppose some processor were written to recognize it as
a way of (say) denoting a bibliographic reference (necessarily
containing formatting codes in ordinary paragraphs).  The fact that
\&\*(L"biblio\*(R" paragraphs were meant for ordinary processing would be
indicated by prefacing each \*(L"biblio\*(R" identifier with a colon:
.PP
.Vb 1
\&  =begin :biblio
\&
\&  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
\&  Programs.>  Prentice\-Hall, Englewood Cliffs, NJ.
\&
\&  =end :biblio
.Ve
.PP
This would signal to the parser that paragraphs in this begin...end
region are subject to normal handling as ordinary/verbatim paragraphs
(while still tagged as meant only for processors that understand the
\&\*(L"biblio\*(R" identifier).  The same effect could be had with:
.PP
.Vb 3
\&  =for :biblio
\&  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
\&  Programs.>  Prentice\-Hall, Englewood Cliffs, NJ.
.Ve
.PP
The \*(L":\*(R" on these identifiers means simply \*(L"process this stuff
normally, even though the result will be for some special target\*(R".
I suggest that parser APIs report \*(L"biblio\*(R" as the target identifier,
but also report that it had a \*(L":\*(R" prefix.  (And similarly, with the
above \*(L"html\*(R", report \*(L"html\*(R" as the target identifier, and note the
\&\fIlack\fR of a \*(L":\*(R" prefix.)
.PP
Note that a "=begin \fIidentifier\fR\*(L"...\*(R"=end \fIidentifier\fR" region where
\&\fIidentifier\fR begins with a colon, \fIcan\fR contain commands.  For example:
.PP
.Vb 1
\&  =begin :biblio
\&
\&  Wirth\*(Aqs classic is available in several editions, including:
\&
\&  =for comment
\&   hm, check abebooks.com for how much used copies cost.
\&
\&  =over
\&
\&  =item
\&
\&  Wirth, Niklaus.  1975.  I<Algorithmen und Datenstrukturen.>
\&  Teubner, Stuttgart.  [Yes, it\*(Aqs in German.]
\&
\&  =item
\&
\&  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
\&  Programs.>  Prentice\-Hall, Englewood Cliffs, NJ.
\&
\&  =back
\&
\&  =end :biblio
.Ve
.PP
Note, however, a "=begin \fIidentifier\fR\*(L"...\*(R"=end \fIidentifier\fR"
region where \fIidentifier\fR does \fInot\fR begin with a colon, should not
directly contain \*(L"=head1\*(R" ... \*(L"=head4\*(R" commands, nor \*(L"=over\*(R", nor \*(L"=back\*(R",
nor \*(L"=item\*(R".  For example, this may be considered invalid:
.PP
.Vb 1
\&  =begin somedata
\&
\&  This is a data paragraph.
\&
\&  =head1 Don\*(Aqt do this!
\&
\&  This is a data paragraph too.
\&
\&  =end somedata
.Ve
.PP
A Pod processor may signal that the above (specifically the \*(L"=head1\*(R"
paragraph) is an error.  Note, however, that the following should
\&\fInot\fR be treated as an error:
.PP
.Vb 1
\&  =begin somedata
\&
\&  This is a data paragraph.
\&
\&  =cut
\&
\&  # Yup, this isn\*(Aqt Pod anymore.
\&  sub excl { (rand() > .5) ? "hoo!" : "hah!" }
\&
\&  =pod
\&
\&  This is a data paragraph too.
\&
\&  =end somedata
.Ve
.PP
And this too is valid:
.PP
.Vb 1
\&  =begin someformat
\&
\&  This is a data paragraph.
\&
\&    And this is a data paragraph.
\&
\&  =begin someotherformat
\&
\&  This is a data paragraph too.
\&
\&    And this is a data paragraph too.
\&
\&  =begin :yetanotherformat
\&
\&  =head2 This is a command paragraph!
\&
\&  This is an ordinary paragraph!
\&
\&    And this is a verbatim paragraph!
\&
\&  =end :yetanotherformat
\&
\&  =end someotherformat
\&
\&  Another data paragraph!
\&
\&  =end someformat
.Ve
.PP
The contents of the above \*(L"=begin :yetanotherformat\*(R" ...
\&\*(L"=end :yetanotherformat\*(R" region \fIaren't\fR data paragraphs, because
the immediately containing region's identifier (\*(L":yetanotherformat\*(R")
begins with a colon.  In practice, most regions that contain
data paragraphs will contain \fIonly\fR data paragraphs; however, 
the above nesting is syntactically valid as Pod, even if it is
rare.  However, the handlers for some formats, like \*(L"html\*(R",
will accept only data paragraphs, not nested regions; and they may
complain if they see (targeted for them) nested regions, or commands,
other than \*(L"=end\*(R", \*(L"=pod\*(R", and \*(L"=cut\*(R".
.PP
Also consider this valid structure:
.PP
.Vb 1
\&  =begin :biblio
\&
\&  Wirth\*(Aqs classic is available in several editions, including:
\&
\&  =over
\&
\&  =item
\&
\&  Wirth, Niklaus.  1975.  I<Algorithmen und Datenstrukturen.>
\&  Teubner, Stuttgart.  [Yes, it\*(Aqs in German.]
\&
\&  =item
\&
\&  Wirth, Niklaus.  1976.  I<Algorithms + Data Structures =
\&  Programs.>  Prentice\-Hall, Englewood Cliffs, NJ.
\&
\&  =back
\&
\&  Buy buy buy!
\&
\&  =begin html
\&
\&  <img src=\*(Aqwirth_spokesmodeling_book.png\*(Aq>
\&
\&  <hr>
\&
\&  =end html
\&
\&  Now now now!
\&
\&  =end :biblio
.Ve
.PP
There, the \*(L"=begin html\*(R"...\*(L"=end html\*(R" region is nested inside
the larger \*(L"=begin :biblio\*(R"...\*(L"=end :biblio\*(R" region.  Note that the
content of the \*(L"=begin html\*(R"...\*(L"=end html\*(R" region is data
paragraph(s), because the immediately containing region's identifier
(\*(L"html\*(R") \fIdoesn't\fR begin with a colon.
.PP
Pod parsers, when processing a series of data paragraphs one
after another (within a single region), should consider them to
be one large data paragraph that happens to contain blank lines.  So
the content of the above \*(L"=begin html\*(R"...\*(L"=end html\*(R" \fImay\fR be stored
as two data paragraphs (one consisting of
\&\*(L"<img src='wirth_spokesmodeling_book.png'>\en\*(R"
and another consisting of \*(L"<hr>\en\*(R"), but \fIshould\fR be stored as
a single data paragraph (consisting of 
\&\*(L"<img src='wirth_spokesmodeling_book.png'>\en\en<hr>\en\*(R").
.PP
Pod processors should tolerate empty
"=begin \fIsomething\fR\*(L"...\*(R"=end \fIsomething\fR\*(L" regions,
empty \*(R"=begin :\fIsomething\fR\*(L"...\*(R"=end :\fIsomething\fR\*(L" regions, and
contentless \*(R"=for \fIsomething\fR\*(L" and \*(R"=for :\fIsomething\fR"
paragraphs.  I.e., these should be tolerated:
.PP
.Vb 1
\&  =for html
\&
\&  =begin html
\&
\&  =end html
\&
\&  =begin :biblio
\&
\&  =end :biblio
.Ve
.PP
Incidentally, note that there's no easy way to express a data
paragraph starting with something that looks like a command.  Consider:
.PP
.Vb 1
\&  =begin stuff
\&
\&  =shazbot
\&
\&  =end stuff
.Ve
.PP
There, \*(L"=shazbot\*(R" will be parsed as a Pod command \*(L"shazbot\*(R", not as a data
paragraph \*(L"=shazbot\en\*(R".  However, you can express a data paragraph consisting
of \*(L"=shazbot\en\*(R" using this code:
.PP
.Vb 1
\&  =for stuff =shazbot
.Ve
.PP
The situation where this is necessary, is presumably quite rare.
.PP
Note that =end commands must match the currently open =begin command.  That
is, they must properly nest.  For example, this is valid:
.PP
.Vb 1
\&  =begin outer
\&
\&  X
\&
\&  =begin inner
\&
\&  Y
\&
\&  =end inner
\&
\&  Z
\&
\&  =end outer
.Ve
.PP
while this is invalid:
.PP
.Vb 1
\&  =begin outer
\&
\&  X
\&
\&  =begin inner
\&
\&  Y
\&
\&  =end outer
\&
\&  Z
\&
\&  =end inner
.Ve
.PP
This latter is improper because when the \*(L"=end outer\*(R" command is seen, the
currently open region has the formatname \*(L"inner\*(R", not \*(L"outer\*(R".  (It just
happens that \*(L"outer\*(R" is the format name of a higher-up region.)  This is
an error.  Processors must by default report this as an error, and may halt
processing the document containing that error.  A corollary of this is that
regions cannot \*(L"overlap\*(R". That is, the latter block above does not represent
a region called \*(L"outer\*(R" which contains X and Y, overlapping a region called
\&\*(L"inner\*(R" which contains Y and Z.  But because it is invalid (as all
apparently overlapping regions would be), it doesn't represent that, or
anything at all.
.PP
Similarly, this is invalid:
.PP
.Vb 1
\&  =begin thing
\&
\&  =end hting
.Ve
.PP
This is an error because the region is opened by \*(L"thing\*(R", and the \*(L"=end\*(R"
tries to close \*(L"hting\*(R" [sic].
.PP
This is also invalid:
.PP
.Vb 1
\&  =begin thing
\&
\&  =end
.Ve
.PP
This is invalid because every \*(L"=end\*(R" command must have a formatname
parameter.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlpod, \*(L"PODs: Embedded Documentation\*(R" in perlsyn,
podchecker
.SH "AUTHOR"
.IX Header "AUTHOR"
Sean M. Burke
                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlpodstyle.1                               0100644 0001750 0001750 00000041443 12566207443 023475  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPODSTYLE 1"
.TH PERLPODSTYLE 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpodstyle \- Perl POD style guide
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These are general guidelines for how to write \s-1POD\s0 documentation for Perl
scripts and modules, based on general guidelines for writing good \s-1UNIX\s0 man
pages.  All of these guidelines are, of course, optional, but following
them will make your documentation more consistent with other documentation
on the system.
.PP
The name of the program being documented is conventionally written in bold
(using B<>) wherever it occurs, as are all program options.
Arguments should be written in italics (I<>).  Function names are
traditionally written in italics; if you write a function as \fIfunction()\fR,
Pod::Man will take care of this for you.  Literal code or commands should
be in C<>.  References to other man pages should be in the form
\&\f(CW\*(C`manpage(section)\*(C'\fR or \f(CW\*(C`L<manpage(section)>\*(C'\fR, and Pod::Man will
automatically format those appropriately.  The second form, with
L<>, is used to request that a \s-1POD\s0 formatter make a link to the
man page if possible.  As an exception, one normally omits the section
when referring to module documentation since it's not clear what section
module documentation will be in; use \f(CW\*(C`L<Module::Name>\*(C'\fR for module
references instead.
.PP
References to other programs or functions are normally in the form of man
page references so that cross-referencing tools can provide the user with
links and the like.  It's possible to overdo this, though, so be careful not
to clutter your documentation with too much markup.  References to other
programs that are not given as man page references should be enclosed in
B<>.
.PP
The major headers should be set out using a \f(CW\*(C`=head1\*(C'\fR directive, and are
historically written in the rather startling \s-1ALL UPPER CASE\s0 format; this
is not mandatory, but it's strongly recommended so that sections have
consistent naming across different software packages.  Minor headers may
be included using \f(CW\*(C`=head2\*(C'\fR, and are typically in mixed case.
.PP
The standard sections of a manual page are:
.IP "\s-1NAME\s0" 4
.IX Item "NAME"
Mandatory section; should be a comma-separated list of programs or
functions documented by this \s-1POD\s0 page, such as:
.Sp
.Vb 1
\&    foo, bar \- programs to do something
.Ve
.Sp
Manual page indexers are often extremely picky about the format of this
section, so don't put anything in it except this line.  Every program or
function documented by this \s-1POD\s0 page should be listed, separated by a
comma and a space.  For a Perl module, just give the module name.  A
single dash, and only a single dash, should separate the list of programs
or functions from the description.  Do not use any markup such as
C<> or B<> anywhere in this line.  Functions should not be
qualified with \f(CW\*(C`()\*(C'\fR or the like.  The description should ideally fit on a
single line, even if a man program replaces the dash with a few tabs.
.IP "\s-1SYNOPSIS\s0" 4
.IX Item "SYNOPSIS"
A short usage summary for programs and functions.  This section is
mandatory for section 3 pages.  For Perl module documentation, it's
usually convenient to have the contents of this section be a verbatim
block showing some (brief) examples of typical ways the module is used.
.IP "\s-1DESCRIPTION\s0" 4
.IX Item "DESCRIPTION"
Extended description and discussion of the program or functions, or the
body of the documentation for man pages that document something else.  If
particularly long, it's a good idea to break this up into subsections
\&\f(CW\*(C`=head2\*(C'\fR directives like:
.Sp
.Vb 1
\&    =head2 Normal Usage
\&
\&    =head2 Advanced Features
\&
\&    =head2 Writing Configuration Files
.Ve
.Sp
or whatever is appropriate for your documentation.
.Sp
For a module, this is generally where the documentation of the interfaces
provided by the module goes, usually in the form of a list with an
\&\f(CW\*(C`=item\*(C'\fR for each interface.  Depending on how many interfaces there are,
you may want to put that documentation in separate \s-1METHODS, FUNCTIONS,
CLASS METHODS,\s0 or \s-1INSTANCE METHODS\s0 sections instead and save the
\&\s-1DESCRIPTION\s0 section for an overview.
.IP "\s-1OPTIONS\s0" 4
.IX Item "OPTIONS"
Detailed description of each of the command-line options taken by the
program.  This should be separate from the description for the use of
parsers like Pod::Usage.  This is normally presented as a list, with
each option as a separate \f(CW\*(C`=item\*(C'\fR.  The specific option string should be
enclosed in B<>.  Any values that the option takes should be
enclosed in I<>.  For example, the section for the option
\&\fB\-\-section\fR=\fImanext\fR would be introduced with:
.Sp
.Vb 1
\&    =item B<\-\-section>=I<manext>
.Ve
.Sp
Synonymous options (like both the short and long forms) are separated by a
comma and a space on the same \f(CW\*(C`=item\*(C'\fR line, or optionally listed as their
own item with a reference to the canonical name.  For example, since
\&\fB\-\-section\fR can also be written as \fB\-s\fR, the above would be:
.Sp
.Vb 1
\&    =item B<\-s> I<manext>, B<\-\-section>=I<manext>
.Ve
.Sp
Writing the short option first is recommended because it's easier to read.
The long option is long enough to draw the eye to it anyway and the short
option can otherwise get lost in visual noise.
.IP "\s-1RETURN VALUE\s0" 4
.IX Item "RETURN VALUE"
What the program or function returns, if successful.  This section can be
omitted for programs whose precise exit codes aren't important, provided
they return 0 on success and non-zero on failure as is standard.  It
should always be present for functions.  For modules, it may be useful to
summarize return values from the module interface here, or it may be more
useful to discuss return values separately in the documentation of each
function or method the module provides.
.IP "\s-1ERRORS\s0" 4
.IX Item "ERRORS"
Exceptions, error return codes, exit statuses, and errno settings.
Typically used for function or module documentation; program documentation
uses \s-1DIAGNOSTICS\s0 instead.  The general rule of thumb is that errors
printed to \f(CW\*(C`STDOUT\*(C'\fR or \f(CW\*(C`STDERR\*(C'\fR and intended for the end user are
documented in \s-1DIAGNOSTICS\s0 while errors passed internal to the calling
program and intended for other programmers are documented in \s-1ERRORS. \s0 When
documenting a function that sets errno, a full list of the possible errno
values should be given here.
.IP "\s-1DIAGNOSTICS\s0" 4
.IX Item "DIAGNOSTICS"
All possible messages the program can print out and what they mean.  You
may wish to follow the same documentation style as the Perl documentation;
see \fIperldiag\fR\|(1) for more details (and look at the \s-1POD\s0 source as well).
.Sp
If applicable, please include details on what the user should do to
correct the error; documenting an error as indicating \*(L"the input buffer is
too small\*(R" without telling the user how to increase the size of the input
buffer (or at least telling them that it isn't possible) aren't very
useful.
.IP "\s-1EXAMPLES\s0" 4
.IX Item "EXAMPLES"
Give some example uses of the program or function.  Don't skimp; users
often find this the most useful part of the documentation.  The examples
are generally given as verbatim paragraphs.
.Sp
Don't just present an example without explaining what it does.  Adding a
short paragraph saying what the example will do can increase the value of
the example immensely.
.IP "\s-1ENVIRONMENT\s0" 4
.IX Item "ENVIRONMENT"
Environment variables that the program cares about, normally presented as
a list using \f(CW\*(C`=over\*(C'\fR, \f(CW\*(C`=item\*(C'\fR, and \f(CW\*(C`=back\*(C'\fR.  For example:
.Sp
.Vb 1
\&    =over 6
\&
\&    =item HOME
\&
\&    Used to determine the user\*(Aqs home directory.  F<.foorc> in this
\&    directory is read for configuration details, if it exists.
\&
\&    =back
.Ve
.Sp
Since environment variables are normally in all uppercase, no additional
special formatting is generally needed; they're glaring enough as it is.
.IP "\s-1FILES\s0" 4
.IX Item "FILES"
All files used by the program or function, normally presented as a list,
and what it uses them for.  File names should be enclosed in F<>.
It's particularly important to document files that will be potentially
modified.
.IP "\s-1CAVEATS\s0" 4
.IX Item "CAVEATS"
Things to take special care with, sometimes called \s-1WARNINGS.\s0
.IP "\s-1BUGS\s0" 4
.IX Item "BUGS"
Things that are broken or just don't work quite right.
.IP "\s-1RESTRICTIONS\s0" 4
.IX Item "RESTRICTIONS"
Bugs you don't plan to fix.  :\-)
.IP "\s-1NOTES\s0" 4
.IX Item "NOTES"
Miscellaneous commentary.
.IP "\s-1AUTHOR\s0" 4
.IX Item "AUTHOR"
Who wrote it (use \s-1AUTHORS\s0 for multiple people).  It's a good idea to
include your current e\-mail address (or some e\-mail address to which bug
reports should be sent) or some other contact information so that users
have a way of contacting you.  Remember that program documentation tends
to roam the wild for far longer than you expect and pick a contact method
that's likely to last.
.IP "\s-1HISTORY\s0" 4
.IX Item "HISTORY"
Programs derived from other sources sometimes have this.  Some people keep
a modification log here, but that usually gets long and is normally better
maintained in a separate file.
.IP "\s-1COPYRIGHT AND LICENSE\s0" 4
.IX Item "COPYRIGHT AND LICENSE"
For copyright
.Sp
.Vb 1
\&    Copyright YEAR(s) YOUR NAME(s)
.Ve
.Sp
(No, (C) is not needed.  No, \*(L"all rights reserved\*(R" is not needed.)
.Sp
For licensing the easiest way is to use the same licensing as Perl itself:
.Sp
.Vb 2
\&    This library is free software; you may redistribute it and/or modify
\&    it under the same terms as Perl itself.
.Ve
.Sp
This makes it easy for people to use your module with Perl.  Note that
this licensing example is neither an endorsement or a requirement, you are
of course free to choose any licensing.
.IP "\s-1SEE ALSO\s0" 4
.IX Item "SEE ALSO"
Other man pages to check out, like \fIman\fR\|(1), \fIman\fR\|(7), \fImakewhatis\fR\|(8), or
\&\fIcatman\fR\|(8).  Normally a simple list of man pages separated by commas, or a
paragraph giving the name of a reference work.  Man page references, if
they use the standard \f(CW\*(C`name(section)\*(C'\fR form, don't have to be enclosed in
L<> (although it's recommended), but other things in this section
probably should be when appropriate.
.Sp
If the package has a mailing list, include a \s-1URL\s0 or subscription
instructions here.
.Sp
If the package has a web site, include a \s-1URL\s0 here.
.PP
Documentation of object-oriented libraries or modules may want to use
\&\s-1CONSTRUCTORS\s0 and \s-1METHODS\s0 sections, or \s-1CLASS METHODS\s0 and \s-1INSTANCE METHODS\s0
sections, for detailed documentation of the parts of the library and save
the \s-1DESCRIPTION\s0 section for an overview.  Large modules with a function
interface may want to use \s-1FUNCTIONS\s0 for similar reasons.  Some people use
\&\s-1OVERVIEW\s0 to summarize the description if it's quite long.
.PP
Section ordering varies, although \s-1NAME\s0 must always be the first section
(you'll break some man page systems otherwise), and \s-1NAME, SYNOPSIS,
DESCRIPTION,\s0 and \s-1OPTIONS\s0 generally always occur first and in that order if
present.  In general, \s-1SEE ALSO, AUTHOR,\s0 and similar material should be
left for last.  Some systems also move \s-1WARNINGS\s0 and \s-1NOTES\s0 to last.  The
order given above should be reasonable for most purposes.
.PP
Some systems use \s-1CONFORMING TO\s0 to note conformance to relevant standards
and MT-LEVEL to note safeness for use in threaded programs or signal
handlers.  These headings are primarily useful when documenting parts of a
C library.
.PP
Finally, as a general note, try not to use an excessive amount of markup.
As documented here and in Pod::Man, you can safely leave Perl
variables, function names, man page references, and the like unadorned by
markup and the \s-1POD\s0 translators will figure it out for you.  This makes it
much easier to later edit the documentation.  Note that many existing
translators will do the wrong thing with e\-mail addresses when wrapped in
L<>, so don't do that.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
For additional information that may be more accurate for your specific
system, see either \fIman\fR\|(5) or \fIman\fR\|(7) depending on your system manual
section numbering conventions.
.PP
This documentation is maintained as part of the podlators distribution.
The current version is always available from its web site at
<http://www.eyrie.org/~eagle/software/podlators/>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Russ Allbery <rra@stanford.edu>, with large portions of this documentation
taken from the documentation of the original \fBpod2man\fR implementation by
Larry Wall and Tom Christiansen.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1999, 2000, 2001, 2004, 2006, 2008, 2010 Russ Allbery
<rra@stanford.edu>.
.PP
This documentation is free software; you may redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlpodstyle5.16.1                           0100644 0001750 0001750 00000044621 12566207422 024005  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPODSTYLE 1"
.TH PERLPODSTYLE 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpodstyle \- Perl POD style guide
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These are general guidelines for how to write \s-1POD\s0 documentation for Perl
scripts and modules, based on general guidelines for writing good Unix man
pages.  All of these guidelines are, of course, optional, but following
them will make your documentation more consistent with other documentation
on the system.
.PP
Here are some simple guidelines for markup; see perlpod for details.
.IP "bold (B<>)" 4
.IX Item "bold (B<>)"
\&\fB\s-1NOTE:\s0 Use extremely rarely.\fR  Do \fInot\fR use bold for emphasis; that's
what italics are for.  Restrict bold for notices like \fB\s-1NOTE:\s0\fR and
\&\fB\s-1WARNING:\s0\fR.  However, program arguments and options\*(--but \fInot\fR their
names!\-\-are written in bold (using B<>) to distinguish the \fB\-f\fR
command-line option from the \f(CW\*(C`\-f\*(C'\fR filetest operator.
.IP "italic (I<>)" 4
.IX Item "italic (I<>)"
Use italic to emphasize text, like \fIthis\fR.  Function names are
traditionally written in italics; if you write a function as \fIfunction()\fR,
Pod::Man will take care of this for you.  Names of programs, including the
name of the program being documented, are conventionally written in italics
(using I<>) wherever they occur in normal roman text.
.IP "code (C<>)" 4
.IX Item "code (C<>)"
Literal code should be in C<>.  However metasyntactic placeholders
should furthermore be nested in \*(L"italics\*(R" (actually, oblique) like
C<I<>>.  That way
C<accept(I<\s-1NEWSOCKET\s0>, <\s-1GENERICSOCKET\s0>)>
renders as \f(CW\*(C`accept(\f(CINEWSOCKET\f(CW, \f(CIGENERICSOCKET\f(CW)\*(C'\fR.
.IP "files (F<>)" 4
.IX Item "files (F<>)"
Filenames, whether absolute or relative, are specified with the F<>
markup. This will render as italics, but has other semantic connotations.
.PP
References to other man pages should be in the form \*(L"manpage(section)\*(R" or
"\f(CW\*(C`L<manpage(section)>\*(C'\fR", and Pod::Man will automatically format
those appropriately.  Both will render as \fImanpage\fR(section).  The second
form, with L<>, is used to request that a \s-1POD\s0 formatter make a link
to the man page if possible.  As an exception, one normally omits the
section when referring to module documentation because not all systems
place it in section 3, although that is the default.  You may use
\&\f(CW\*(C`L<Module::Name>\*(C'\fR for module references instead, but this is
optional because the translators are supposed to recognize module
references in pod, just as they do variable references like \f(CW$foo\fR and such.
.PP
References to other programs or functions are normally in the form of man
page references so that cross-referencing tools can provide the user with
links and the like.  It's possible to overdo this, though, so be careful not
to clutter your documentation with too much markup.  References to other
programs that are not given as man page references should be enclosed in
italics via I<>.
.PP
Major headers should be set out using a \f(CW\*(C`=head1\*(C'\fR directive, and are
historically written in the rather startling \s-1ALL\s0 \s-1UPPER\s0 \s-1CASE\s0 format; this is
not mandatory, but it's strongly recommended so that sections have
consistent naming across different software packages.  The translators are
supposed to translate all caps into small caps.  Minor headers may be
included using \f(CW\*(C`=head2\*(C'\fR, and are typically in mixed case.
.PP
The standard sections of a manual page are:
.IP "\s-1NAME\s0" 4
.IX Item "NAME"
Mandatory section; should be a comma-separated list of programs or
functions documented by this \s-1POD\s0 page, such as:
.Sp
.Vb 1
\&    foo, bar \- programs to do something
.Ve
.Sp
Manual page indexers are often extremely picky about the format of this
section, so don't put anything in it except this line.  Every program or
function documented by this \s-1POD\s0 page should be listed, separated by a
comma and a space.  For a Perl module, just give the module name.  A
single dash, and only a single dash, should separate the list of programs
or functions from the description.  Do not use any markup such as
C<> or I<> anywhere in this line.  Functions should not be
qualified with \f(CW\*(C`()\*(C'\fR or the like.  The description should ideally fit on a
single line, even if a man program replaces the dash with a few tabs.
.IP "\s-1SYNOPSIS\s0" 4
.IX Item "SYNOPSIS"
A short usage summary for programs and functions.  This section is
mandatory for section 3 pages.  For Perl module documentation, it's
usually convenient to have the contents of this section be a verbatim
block showing some (brief) examples of typical ways the module is used.
.IP "\s-1DESCRIPTION\s0" 4
.IX Item "DESCRIPTION"
Extended description and discussion of the program or functions, or the
body of the documentation for man pages that document something else.  If
particularly long, it's a good idea to break this up into subsections
\&\f(CW\*(C`=head2\*(C'\fR directives like:
.Sp
.Vb 1
\&    =head2 Normal Usage
\&
\&    =head2 Advanced Features
\&
\&    =head2 Writing Configuration Files
.Ve
.Sp
or whatever is appropriate for your documentation.
.Sp
For a module, this is generally where the documentation of the interfaces
provided by the module goes, usually in the form of a list with an
\&\f(CW\*(C`=item\*(C'\fR for each interface.  Depending on how many interfaces there are,
you may want to put that documentation in separate \s-1METHODS\s0, \s-1FUNCTIONS\s0,
\&\s-1CLASS\s0 \s-1METHODS\s0, or \s-1INSTANCE\s0 \s-1METHODS\s0 sections instead and save the
\&\s-1DESCRIPTION\s0 section for an overview.
.IP "\s-1OPTIONS\s0" 4
.IX Item "OPTIONS"
Detailed description of each of the command-line options taken by the
program.  This should be separate from the description for the use of
parsers like Pod::Usage.  This is normally presented as a list, with
each option as a separate \f(CW\*(C`=item\*(C'\fR.  The specific option string should be
enclosed in B<>.  Any values that the option takes should be
enclosed in I<>.  For example, the section for the option
\&\fB\-\-section\fR=\fImanext\fR would be introduced with:
.Sp
.Vb 1
\&    =item B<\-\-section>=I<manext>
.Ve
.Sp
Synonymous options (like both the short and long forms) are separated by a
comma and a space on the same \f(CW\*(C`=item\*(C'\fR line, or optionally listed as their
own item with a reference to the canonical name.  For example, since
\&\fB\-\-section\fR can also be written as \fB\-s\fR, the above would be:
.Sp
.Vb 1
\&    =item B<\-s> I<manext>, B<\-\-section>=I<manext>
.Ve
.Sp
Writing the short option first is recommended because it's easier to read.
The long option is long enough to draw the eye to it anyway and the short
option can otherwise get lost in visual noise.
.IP "\s-1RETURN\s0 \s-1VALUE\s0" 4
.IX Item "RETURN VALUE"
What the program or function returns, if successful.  This section can be
omitted for programs whose precise exit codes aren't important, provided
they return 0 on success and non-zero on failure as is standard.  It
should always be present for functions.  For modules, it may be useful to
summarize return values from the module interface here, or it may be more
useful to discuss return values separately in the documentation of each
function or method the module provides.
.IP "\s-1ERRORS\s0" 4
.IX Item "ERRORS"
Exceptions, error return codes, exit statuses, and errno settings.
Typically used for function or module documentation; program documentation
uses \s-1DIAGNOSTICS\s0 instead.  The general rule of thumb is that errors
printed to \f(CW\*(C`STDOUT\*(C'\fR or \f(CW\*(C`STDERR\*(C'\fR and intended for the end user are
documented in \s-1DIAGNOSTICS\s0 while errors passed internal to the calling
program and intended for other programmers are documented in \s-1ERRORS\s0.  When
documenting a function that sets errno, a full list of the possible errno
values should be given here.
.IP "\s-1DIAGNOSTICS\s0" 4
.IX Item "DIAGNOSTICS"
All possible messages the program can print out and what they mean.  You
may wish to follow the same documentation style as the Perl documentation;
see \fIperldiag\fR\|(1) for more details (and look at the \s-1POD\s0 source as well).
.Sp
If applicable, please include details on what the user should do to
correct the error; documenting an error as indicating \*(L"the input buffer is
too small\*(R" without telling the user how to increase the size of the input
buffer (or at least telling them that it isn't possible) aren't very
useful.
.IP "\s-1EXAMPLES\s0" 4
.IX Item "EXAMPLES"
Give some example uses of the program or function.  Don't skimp; users
often find this the most useful part of the documentation.  The examples
are generally given as verbatim paragraphs.
.Sp
Don't just present an example without explaining what it does.  Adding a
short paragraph saying what the example will do can increase the value of
the example immensely.
.IP "\s-1ENVIRONMENT\s0" 4
.IX Item "ENVIRONMENT"
Environment variables that the program cares about, normally presented as
a list using \f(CW\*(C`=over\*(C'\fR, \f(CW\*(C`=item\*(C'\fR, and \f(CW\*(C`=back\*(C'\fR.  For example:
.Sp
.Vb 1
\&    =over 6
\&
\&    =item HOME
\&
\&    Used to determine the user\*(Aqs home directory.  F<.foorc> in this
\&    directory is read for configuration details, if it exists.
\&
\&    =back
.Ve
.Sp
Since environment variables are normally in all uppercase, no additional
special formatting is generally needed; they're glaring enough as it is.
.IP "\s-1FILES\s0" 4
.IX Item "FILES"
All files used by the program or function, normally presented as a list,
and what it uses them for.  File names should be enclosed in F<>.
It's particularly important to document files that will be potentially
modified.
.IP "\s-1CAVEATS\s0" 4
.IX Item "CAVEATS"
Things to take special care with, sometimes called \s-1WARNINGS\s0.
.IP "\s-1BUGS\s0" 4
.IX Item "BUGS"
Things that are broken or just don't work quite right.
.IP "\s-1RESTRICTIONS\s0" 4
.IX Item "RESTRICTIONS"
Bugs you don't plan to fix.  :\-)
.IP "\s-1NOTES\s0" 4
.IX Item "NOTES"
Miscellaneous commentary.
.IP "\s-1AUTHOR\s0" 4
.IX Item "AUTHOR"
Who wrote it (use \s-1AUTHORS\s0 for multiple people).  It's a good idea to
include your current email address (or some email address to which bug
reports should be sent) or some other contact information so that users
have a way of contacting you.  Remember that program documentation tends
to roam the wild for far longer than you expect and pick a contact method
that's likely to last.
.IP "\s-1HISTORY\s0" 4
.IX Item "HISTORY"
Programs derived from other sources sometimes have this.  Some people keep
a modification log here, but that usually gets long and is normally better
maintained in a separate file.
.IP "\s-1COPYRIGHT\s0 \s-1AND\s0 \s-1LICENSE\s0" 4
.IX Item "COPYRIGHT AND LICENSE"
For copyright
.Sp
.Vb 1
\&    Copyright YEAR(s) YOUR NAME(s)
.Ve
.Sp
(No, (C) is not needed.  No, \*(L"all rights reserved\*(R" is not needed.)
.Sp
For licensing the easiest way is to use the same licensing as Perl itself:
.Sp
.Vb 2
\&    This library is free software; you may redistribute it and/or modify
\&    it under the same terms as Perl itself.
.Ve
.Sp
This makes it easy for people to use your module with Perl.  Note that
this licensing example is neither an endorsement or a requirement, you are
of course free to choose any licensing.
.IP "\s-1SEE\s0 \s-1ALSO\s0" 4
.IX Item "SEE ALSO"
Other man pages to check out, like \fIman\fR\|(1), \fIman\fR\|(7), \fImakewhatis\fR\|(8), or
\&\fIcatman\fR\|(8).  Normally a simple list of man pages separated by commas, or a
paragraph giving the name of a reference work.  Man page references, if
they use the standard \f(CW\*(C`name(section)\*(C'\fR form, don't have to be enclosed in
L<> (although it's recommended), but other things in this section
probably should be when appropriate.
.Sp
If the package has a mailing list, include a \s-1URL\s0 or subscription
instructions here.
.Sp
If the package has a web site, include a \s-1URL\s0 here.
.PP
Documentation of object-oriented libraries or modules may want to use
\&\s-1CONSTRUCTORS\s0 and \s-1METHODS\s0 sections, or \s-1CLASS\s0 \s-1METHODS\s0 and \s-1INSTANCE\s0 \s-1METHODS\s0
sections, for detailed documentation of the parts of the library and save
the \s-1DESCRIPTION\s0 section for an overview.  Large modules with a function
interface may want to use \s-1FUNCTIONS\s0 for similar reasons.  Some people use
\&\s-1OVERVIEW\s0 to summarize the description if it's quite long.
.PP
Section ordering varies, although \s-1NAME\s0 must always be the first section
(you'll break some man page systems otherwise), and \s-1NAME\s0, \s-1SYNOPSIS\s0,
\&\s-1DESCRIPTION\s0, and \s-1OPTIONS\s0 generally always occur first and in that order if
present.  In general, \s-1SEE\s0 \s-1ALSO\s0, \s-1AUTHOR\s0, and similar material should be
left for last.  Some systems also move \s-1WARNINGS\s0 and \s-1NOTES\s0 to last.  The
order given above should be reasonable for most purposes.
.PP
Some systems use \s-1CONFORMING\s0 \s-1TO\s0 to note conformance to relevant standards
and MT-LEVEL to note safeness for use in threaded programs or signal
handlers.  These headings are primarily useful when documenting parts of a
C library.
.PP
Finally, as a general note, try not to use an excessive amount of markup.
As documented here and in Pod::Man, you can safely leave Perl variables,
module names, function names, man page references, and the like unadorned
by markup, and the \s-1POD\s0 translators will figure it all out for you.  This
makes it much easier to later edit the documentation.  Note that many
existing translators will do the wrong thing with email addresses when
wrapped in L<>, so don't do that.
.PP
You can check whether your documentation looks right by running
.PP
.Vb 1
\&    % pod2text \-o something.pod | less
.Ve
.PP
If you have \fIgroff\fR installed, you can get an even better look this way:
.PP
.Vb 1
\&    % pod2man something.pod | groff \-Tps \-mandoc > something.ps
.Ve
.PP
Now view the resulting Postscript file to see whether everything checks out.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
For additional information that may be more accurate for your specific
system, see either \fIman\fR\|(5) or \fIman\fR\|(7) depending on your system manual
section numbering conventions.
.PP
This documentation is maintained as part of the podlators distribution.
The current version is always available from its web site at
<http://www.eyrie.org/~eagle/software/podlators/>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Russ Allbery <rra@stanford.edu>, with large portions of this documentation
taken from the documentation of the original \fBpod2man\fR implementation by
Larry Wall and Tom Christiansen.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1999, 2000, 2001, 2004, 2006, 2008, 2010 Russ Allbery
<rra@stanford.edu>.
.PP
This documentation is free software; you may redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlpodstyle5.18.1                           0100644 0001750 0001750 00000041443 12566207443 024011  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPODSTYLE 1"
.TH PERLPODSTYLE 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpodstyle \- Perl POD style guide
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
These are general guidelines for how to write \s-1POD\s0 documentation for Perl
scripts and modules, based on general guidelines for writing good \s-1UNIX\s0 man
pages.  All of these guidelines are, of course, optional, but following
them will make your documentation more consistent with other documentation
on the system.
.PP
The name of the program being documented is conventionally written in bold
(using B<>) wherever it occurs, as are all program options.
Arguments should be written in italics (I<>).  Function names are
traditionally written in italics; if you write a function as \fIfunction()\fR,
Pod::Man will take care of this for you.  Literal code or commands should
be in C<>.  References to other man pages should be in the form
\&\f(CW\*(C`manpage(section)\*(C'\fR or \f(CW\*(C`L<manpage(section)>\*(C'\fR, and Pod::Man will
automatically format those appropriately.  The second form, with
L<>, is used to request that a \s-1POD\s0 formatter make a link to the
man page if possible.  As an exception, one normally omits the section
when referring to module documentation since it's not clear what section
module documentation will be in; use \f(CW\*(C`L<Module::Name>\*(C'\fR for module
references instead.
.PP
References to other programs or functions are normally in the form of man
page references so that cross-referencing tools can provide the user with
links and the like.  It's possible to overdo this, though, so be careful not
to clutter your documentation with too much markup.  References to other
programs that are not given as man page references should be enclosed in
B<>.
.PP
The major headers should be set out using a \f(CW\*(C`=head1\*(C'\fR directive, and are
historically written in the rather startling \s-1ALL UPPER CASE\s0 format; this
is not mandatory, but it's strongly recommended so that sections have
consistent naming across different software packages.  Minor headers may
be included using \f(CW\*(C`=head2\*(C'\fR, and are typically in mixed case.
.PP
The standard sections of a manual page are:
.IP "\s-1NAME\s0" 4
.IX Item "NAME"
Mandatory section; should be a comma-separated list of programs or
functions documented by this \s-1POD\s0 page, such as:
.Sp
.Vb 1
\&    foo, bar \- programs to do something
.Ve
.Sp
Manual page indexers are often extremely picky about the format of this
section, so don't put anything in it except this line.  Every program or
function documented by this \s-1POD\s0 page should be listed, separated by a
comma and a space.  For a Perl module, just give the module name.  A
single dash, and only a single dash, should separate the list of programs
or functions from the description.  Do not use any markup such as
C<> or B<> anywhere in this line.  Functions should not be
qualified with \f(CW\*(C`()\*(C'\fR or the like.  The description should ideally fit on a
single line, even if a man program replaces the dash with a few tabs.
.IP "\s-1SYNOPSIS\s0" 4
.IX Item "SYNOPSIS"
A short usage summary for programs and functions.  This section is
mandatory for section 3 pages.  For Perl module documentation, it's
usually convenient to have the contents of this section be a verbatim
block showing some (brief) examples of typical ways the module is used.
.IP "\s-1DESCRIPTION\s0" 4
.IX Item "DESCRIPTION"
Extended description and discussion of the program or functions, or the
body of the documentation for man pages that document something else.  If
particularly long, it's a good idea to break this up into subsections
\&\f(CW\*(C`=head2\*(C'\fR directives like:
.Sp
.Vb 1
\&    =head2 Normal Usage
\&
\&    =head2 Advanced Features
\&
\&    =head2 Writing Configuration Files
.Ve
.Sp
or whatever is appropriate for your documentation.
.Sp
For a module, this is generally where the documentation of the interfaces
provided by the module goes, usually in the form of a list with an
\&\f(CW\*(C`=item\*(C'\fR for each interface.  Depending on how many interfaces there are,
you may want to put that documentation in separate \s-1METHODS, FUNCTIONS,
CLASS METHODS,\s0 or \s-1INSTANCE METHODS\s0 sections instead and save the
\&\s-1DESCRIPTION\s0 section for an overview.
.IP "\s-1OPTIONS\s0" 4
.IX Item "OPTIONS"
Detailed description of each of the command-line options taken by the
program.  This should be separate from the description for the use of
parsers like Pod::Usage.  This is normally presented as a list, with
each option as a separate \f(CW\*(C`=item\*(C'\fR.  The specific option string should be
enclosed in B<>.  Any values that the option takes should be
enclosed in I<>.  For example, the section for the option
\&\fB\-\-section\fR=\fImanext\fR would be introduced with:
.Sp
.Vb 1
\&    =item B<\-\-section>=I<manext>
.Ve
.Sp
Synonymous options (like both the short and long forms) are separated by a
comma and a space on the same \f(CW\*(C`=item\*(C'\fR line, or optionally listed as their
own item with a reference to the canonical name.  For example, since
\&\fB\-\-section\fR can also be written as \fB\-s\fR, the above would be:
.Sp
.Vb 1
\&    =item B<\-s> I<manext>, B<\-\-section>=I<manext>
.Ve
.Sp
Writing the short option first is recommended because it's easier to read.
The long option is long enough to draw the eye to it anyway and the short
option can otherwise get lost in visual noise.
.IP "\s-1RETURN VALUE\s0" 4
.IX Item "RETURN VALUE"
What the program or function returns, if successful.  This section can be
omitted for programs whose precise exit codes aren't important, provided
they return 0 on success and non-zero on failure as is standard.  It
should always be present for functions.  For modules, it may be useful to
summarize return values from the module interface here, or it may be more
useful to discuss return values separately in the documentation of each
function or method the module provides.
.IP "\s-1ERRORS\s0" 4
.IX Item "ERRORS"
Exceptions, error return codes, exit statuses, and errno settings.
Typically used for function or module documentation; program documentation
uses \s-1DIAGNOSTICS\s0 instead.  The general rule of thumb is that errors
printed to \f(CW\*(C`STDOUT\*(C'\fR or \f(CW\*(C`STDERR\*(C'\fR and intended for the end user are
documented in \s-1DIAGNOSTICS\s0 while errors passed internal to the calling
program and intended for other programmers are documented in \s-1ERRORS. \s0 When
documenting a function that sets errno, a full list of the possible errno
values should be given here.
.IP "\s-1DIAGNOSTICS\s0" 4
.IX Item "DIAGNOSTICS"
All possible messages the program can print out and what they mean.  You
may wish to follow the same documentation style as the Perl documentation;
see \fIperldiag\fR\|(1) for more details (and look at the \s-1POD\s0 source as well).
.Sp
If applicable, please include details on what the user should do to
correct the error; documenting an error as indicating \*(L"the input buffer is
too small\*(R" without telling the user how to increase the size of the input
buffer (or at least telling them that it isn't possible) aren't very
useful.
.IP "\s-1EXAMPLES\s0" 4
.IX Item "EXAMPLES"
Give some example uses of the program or function.  Don't skimp; users
often find this the most useful part of the documentation.  The examples
are generally given as verbatim paragraphs.
.Sp
Don't just present an example without explaining what it does.  Adding a
short paragraph saying what the example will do can increase the value of
the example immensely.
.IP "\s-1ENVIRONMENT\s0" 4
.IX Item "ENVIRONMENT"
Environment variables that the program cares about, normally presented as
a list using \f(CW\*(C`=over\*(C'\fR, \f(CW\*(C`=item\*(C'\fR, and \f(CW\*(C`=back\*(C'\fR.  For example:
.Sp
.Vb 1
\&    =over 6
\&
\&    =item HOME
\&
\&    Used to determine the user\*(Aqs home directory.  F<.foorc> in this
\&    directory is read for configuration details, if it exists.
\&
\&    =back
.Ve
.Sp
Since environment variables are normally in all uppercase, no additional
special formatting is generally needed; they're glaring enough as it is.
.IP "\s-1FILES\s0" 4
.IX Item "FILES"
All files used by the program or function, normally presented as a list,
and what it uses them for.  File names should be enclosed in F<>.
It's particularly important to document files that will be potentially
modified.
.IP "\s-1CAVEATS\s0" 4
.IX Item "CAVEATS"
Things to take special care with, sometimes called \s-1WARNINGS.\s0
.IP "\s-1BUGS\s0" 4
.IX Item "BUGS"
Things that are broken or just don't work quite right.
.IP "\s-1RESTRICTIONS\s0" 4
.IX Item "RESTRICTIONS"
Bugs you don't plan to fix.  :\-)
.IP "\s-1NOTES\s0" 4
.IX Item "NOTES"
Miscellaneous commentary.
.IP "\s-1AUTHOR\s0" 4
.IX Item "AUTHOR"
Who wrote it (use \s-1AUTHORS\s0 for multiple people).  It's a good idea to
include your current e\-mail address (or some e\-mail address to which bug
reports should be sent) or some other contact information so that users
have a way of contacting you.  Remember that program documentation tends
to roam the wild for far longer than you expect and pick a contact method
that's likely to last.
.IP "\s-1HISTORY\s0" 4
.IX Item "HISTORY"
Programs derived from other sources sometimes have this.  Some people keep
a modification log here, but that usually gets long and is normally better
maintained in a separate file.
.IP "\s-1COPYRIGHT AND LICENSE\s0" 4
.IX Item "COPYRIGHT AND LICENSE"
For copyright
.Sp
.Vb 1
\&    Copyright YEAR(s) YOUR NAME(s)
.Ve
.Sp
(No, (C) is not needed.  No, \*(L"all rights reserved\*(R" is not needed.)
.Sp
For licensing the easiest way is to use the same licensing as Perl itself:
.Sp
.Vb 2
\&    This library is free software; you may redistribute it and/or modify
\&    it under the same terms as Perl itself.
.Ve
.Sp
This makes it easy for people to use your module with Perl.  Note that
this licensing example is neither an endorsement or a requirement, you are
of course free to choose any licensing.
.IP "\s-1SEE ALSO\s0" 4
.IX Item "SEE ALSO"
Other man pages to check out, like \fIman\fR\|(1), \fIman\fR\|(7), \fImakewhatis\fR\|(8), or
\&\fIcatman\fR\|(8).  Normally a simple list of man pages separated by commas, or a
paragraph giving the name of a reference work.  Man page references, if
they use the standard \f(CW\*(C`name(section)\*(C'\fR form, don't have to be enclosed in
L<> (although it's recommended), but other things in this section
probably should be when appropriate.
.Sp
If the package has a mailing list, include a \s-1URL\s0 or subscription
instructions here.
.Sp
If the package has a web site, include a \s-1URL\s0 here.
.PP
Documentation of object-oriented libraries or modules may want to use
\&\s-1CONSTRUCTORS\s0 and \s-1METHODS\s0 sections, or \s-1CLASS METHODS\s0 and \s-1INSTANCE METHODS\s0
sections, for detailed documentation of the parts of the library and save
the \s-1DESCRIPTION\s0 section for an overview.  Large modules with a function
interface may want to use \s-1FUNCTIONS\s0 for similar reasons.  Some people use
\&\s-1OVERVIEW\s0 to summarize the description if it's quite long.
.PP
Section ordering varies, although \s-1NAME\s0 must always be the first section
(you'll break some man page systems otherwise), and \s-1NAME, SYNOPSIS,
DESCRIPTION,\s0 and \s-1OPTIONS\s0 generally always occur first and in that order if
present.  In general, \s-1SEE ALSO, AUTHOR,\s0 and similar material should be
left for last.  Some systems also move \s-1WARNINGS\s0 and \s-1NOTES\s0 to last.  The
order given above should be reasonable for most purposes.
.PP
Some systems use \s-1CONFORMING TO\s0 to note conformance to relevant standards
and MT-LEVEL to note safeness for use in threaded programs or signal
handlers.  These headings are primarily useful when documenting parts of a
C library.
.PP
Finally, as a general note, try not to use an excessive amount of markup.
As documented here and in Pod::Man, you can safely leave Perl
variables, function names, man page references, and the like unadorned by
markup and the \s-1POD\s0 translators will figure it out for you.  This makes it
much easier to later edit the documentation.  Note that many existing
translators will do the wrong thing with e\-mail addresses when wrapped in
L<>, so don't do that.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
For additional information that may be more accurate for your specific
system, see either \fIman\fR\|(5) or \fIman\fR\|(7) depending on your system manual
section numbering conventions.
.PP
This documentation is maintained as part of the podlators distribution.
The current version is always available from its web site at
<http://www.eyrie.org/~eagle/software/podlators/>.
.SH "AUTHOR"
.IX Header "AUTHOR"
Russ Allbery <rra@stanford.edu>, with large portions of this documentation
taken from the documentation of the original \fBpod2man\fR implementation by
Larry Wall and Tom Christiansen.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 1999, 2000, 2001, 2004, 2006, 2008, 2010 Russ Allbery
<rra@stanford.edu>.
.PP
This documentation is free software; you may redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlpolicy.1                                 0100644 0001750 0001750 00000061271 12566207443 023132  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPOLICY 1"
.TH PERLPOLICY 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpolicy \- Various and sundry policies and commitments related to the Perl core
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document is the master document which records all written
policies about how the Perl 5 Porters collectively develop and maintain
the Perl core.
.SH "GOVERNANCE"
.IX Header "GOVERNANCE"
.SS "Perl 5 Porters"
.IX Subsection "Perl 5 Porters"
Subscribers to perl5\-porters (the porters themselves) come in several flavours.
Some are quiet curious lurkers, who rarely pitch in and instead watch
the ongoing development to ensure they're forewarned of new changes or
features in Perl.  Some are representatives of vendors, who are there
to make sure that Perl continues to compile and work on their
platforms.  Some patch any reported bug that they know how to fix,
some are actively patching their pet area (threads, Win32, the regexp
\&\-engine), while others seem to do nothing but complain.  In other
words, it's your usual mix of technical people.
.PP
Over this group of porters presides Larry Wall.  He has the final word
in what does and does not change in any of the Perl programming languages.
These days, Larry spends most of his time on Perl 6, while Perl 5 is
shepherded by a \*(L"pumpking\*(R", a porter responsible for deciding what
goes into each release and ensuring that releases happen on a regular
basis.
.PP
Larry sees Perl development along the lines of the \s-1US\s0 government:
there's the Legislature (the porters), the Executive branch (the
\&\-pumpking), and the Supreme Court (Larry).  The legislature can
discuss and submit patches to the executive branch all they like, but
the executive branch is free to veto them.  Rarely, the Supreme Court
will side with the executive branch over the legislature, or the
legislature over the executive branch.  Mostly, however, the
legislature and the executive branch are supposed to get along and
work out their differences without impeachment or court cases.
.PP
You might sometimes see reference to Rule 1 and Rule 2.  Larry's power
as Supreme Court is expressed in The Rules:
.IP "1." 4
Larry is always by definition right about how Perl should behave.
This means he has final veto power on the core functionality.
.IP "2." 4
Larry is allowed to change his mind about any matter at a later date,
regardless of whether he previously invoked Rule 1.
.PP
Got that?  Larry is always right, even when he was wrong.  It's rare
to see either Rule exercised, but they are often alluded to.
.SH "MAINTENANCE AND SUPPORT"
.IX Header "MAINTENANCE AND SUPPORT"
Perl 5 is developed by a community, not a corporate entity. Every change
contributed to the Perl core is the result of a donation. Typically, these
donations are contributions of code or time by individual members of our
community. On occasion, these donations come in the form of corporate
or organizational sponsorship of a particular individual or project.
.PP
As a volunteer organization, the commitments we make are heavily dependent
on the goodwill and hard work of individuals who have no obligation to
contribute to Perl.
.PP
That being said, we value Perl's stability and security and have long
had an unwritten covenant with the broader Perl community to support
and maintain releases of Perl.
.PP
This document codifies the support and maintenance commitments that
the Perl community should expect from Perl's developers:
.IP "\(bu" 4
We \*(L"officially\*(R" support the two most recent stable release series.  5.12.x
and earlier are now out of support.  As of the release of 5.18.0, we will
\&\*(L"officially\*(R" end support for Perl 5.14.x, other than providing security
updates as described below.
.IP "\(bu" 4
To the best of our ability, we will attempt to fix critical issues
in the two most recent stable 5.x release series.  Fixes for the
current release series take precedence over fixes for the previous
release series.
.IP "\(bu" 4
To the best of our ability, we will provide \*(L"critical\*(R" security patches
/ releases for any major version of Perl whose 5.x.0 release was within
the past three years.  We can only commit to providing these for the
most recent .y release in any 5.x.y series.
.IP "\(bu" 4
We will not provide security updates or bug fixes for development
releases of Perl.
.IP "\(bu" 4
We encourage vendors to ship the most recent supported release of
Perl at the time of their code freeze.
.IP "\(bu" 4
As a vendor, you may have a requirement to backport security fixes
beyond our 3 year support commitment.  We can provide limited support and
advice to you as you do so and, where possible will try to apply
those patches to the relevant \-maint branches in git, though we may or
may not choose to make numbered releases or \*(L"official\*(R" patches
available.  Contact us at <perl5\-security\-report@perl.org>
to begin that process.
.SH "BACKWARD COMPATIBILITY AND DEPRECATION"
.IX Header "BACKWARD COMPATIBILITY AND DEPRECATION"
Our community has a long-held belief that backward-compatibility is a
virtue, even when the functionality in question is a design flaw.
.PP
We would all love to unmake some mistakes we've made over the past
decades.  Living with every design error we've ever made can lead
to painful stagnation.  Unwinding our mistakes is very, very
difficult.  Doing so without actively harming our users is
nearly impossible.
.PP
Lately, ignoring or actively opposing compatibility with earlier versions
of Perl has come into vogue.  Sometimes, a change is proposed which
wants to usurp syntax which previously had another meaning.  Sometimes,
a change wants to improve previously-crazy semantics.
.PP
Down this road lies madness.
.PP
Requiring end-user programmers to change just a few language constructs,
even language constructs which no well-educated developer would ever
intentionally use is tantamount to saying \*(L"you should not upgrade to
a new release of Perl unless you have 100% test coverage and can do a
full manual audit of your codebase.\*(R"  If we were to have tools capable of
reliably upgrading Perl source code from one version of Perl to another,
this concern could be significantly mitigated.
.PP
We want to ensure that Perl continues to grow and flourish in the coming
years and decades, but not at the expense of our user community.
.PP
Existing syntax and semantics should only be marked for destruction in
very limited circumstances.  If a given language feature's continued
inclusion in the language will cause significant harm to the language
or prevent us from making needed changes to the runtime, then it may
be considered for deprecation.
.PP
Any language change which breaks backward-compatibility should be able to
be enabled or disabled lexically.  Unless code at a given scope declares
that it wants the new behavior, that new behavior should be disabled.
Which backward-incompatible changes are controlled implicitly by a
\&'use v5.x.y' is a decision which should be made by the pumpking in
consultation with the community.
.PP
When a backward-incompatible change can't be toggled lexically, the decision
to change the language must be considered very, very carefully.  If it's
possible to move the old syntax or semantics out of the core language
and into XS-land, that \s-1XS\s0 module should be enabled by default unless
the user declares that they want a newer revision of Perl.
.PP
Historically, we've held ourselves to a far higher standard than
backward-compatibility \*(-- bugward-compatibility.  Any accident of
implementation or unintentional side-effect of running some bit of code
has been considered to be a feature of the language to be defended with
the same zeal as any other feature or functionality.  No matter how
frustrating these unintentional features may be to us as we continue
to improve Perl, these unintentional features often deserve our
protection.  It is very important that existing software written in
Perl continue to work correctly.  If end-user developers have adopted a
bug as a feature, we need to treat it as such.
.PP
New syntax and semantics which don't break existing language constructs
and syntax have a much lower bar.  They merely need to prove themselves
to be useful, elegant, well designed, and well tested.
.SS "Terminology"
.IX Subsection "Terminology"
To make sure we're talking about the same thing when we discuss the removal
of features or functionality from the Perl core, we have specific definitions
for a few words and phrases.
.IP "experimental" 4
.IX Item "experimental"
If something in the Perl core is marked as \fBexperimental\fR, we may change
its behaviour, deprecate or remove it without notice. While we'll always
do our best to smooth the transition path for users of experimental
features, you should contact the perl5\-porters mailinglist if you find
an experimental feature useful and want to help shape its future.
.IP "deprecated" 4
.IX Item "deprecated"
If something in the Perl core is marked as \fBdeprecated\fR, we may remove it
from the core in the next stable release series, though we may not. As of
Perl 5.12, deprecated features and modules warn the user as they're used.
When a module is deprecated, it will also be made available on \s-1CPAN.\s0
Installing it from \s-1CPAN\s0 will silence deprecation warnings for that module.
.Sp
If you use a deprecated feature or module and believe that its removal from
the Perl core would be a mistake, please contact the perl5\-porters
mailinglist and plead your case.  We don't deprecate things without a good
reason, but sometimes there's a counterargument we haven't considered.
Historically, we did not distinguish between \*(L"deprecated\*(R" and \*(L"discouraged\*(R"
features.
.IP "discouraged" 4
.IX Item "discouraged"
From time to time, we may mark language constructs and features which we
consider to have been mistakes as \fBdiscouraged\fR.  Discouraged features
aren't candidates for removal in the next major release series, but
we may later deprecate them if they're found to stand in the way of a
significant improvement to the Perl core.
.IP "removed" 4
.IX Item "removed"
Once a feature, construct or module has been marked as deprecated for a
stable release cycle, we may remove it from the Perl core.  Unsurprisingly,
we say we've \fBremoved\fR these things.  When a module is removed, it will
no longer ship with Perl, but will continue to be available on \s-1CPAN.\s0
.SH "MAINTENANCE BRANCHES"
.IX Header "MAINTENANCE BRANCHES"
.IP "\(bu" 4
New releases of maint should contain as few changes as possible.
If there is any question about whether a given patch might merit
inclusion in a maint release, then it almost certainly should not
be included.
.IP "\(bu" 4
Portability fixes, such as changes to Configure and the files in
hints/ are acceptable. Ports of Perl to a new platform, architecture
or \s-1OS\s0 release that involve changes to the implementation are \s-1NOT\s0
acceptable.
.IP "\(bu" 4
Acceptable documentation updates are those that correct factual errors,
explain significant bugs or deficiencies in the current implementation, 
or fix broken markup.
.IP "\(bu" 4
Patches that add new warnings or errors or deprecate features
are not acceptable.
.IP "\(bu" 4
Patches that fix crashing bugs that do not otherwise change Perl's
functionality or negatively impact performance are acceptable.
.IP "\(bu" 4
Patches that fix CVEs or security issues are acceptable, but should
be run through the perl5\-security\-report@perl.org mailing list
rather than applied directly.
.IP "\(bu" 4
Patches that fix regressions in perl's behavior relative to previous
releases are acceptable.
.IP "\(bu" 4
Updates to dual-life modules should consist of minimal patches to 
fix crashing or security issues (as above).
.IP "\(bu" 4
Minimal patches that fix platform-specific test failures or
installation issues are acceptable. When these changes are made
to dual-life modules for which \s-1CPAN\s0 is canonical, any changes
should be coordinated with the upstream author.
.IP "\(bu" 4
New versions of dual-life modules should \s-1NOT\s0 be imported into maint.
Those belong in the next stable series.
.IP "\(bu" 4
Patches that add or remove features are not acceptable.
.IP "\(bu" 4
Patches that break binary compatibility are not acceptable.  (Please
talk to a pumpking.)
.SS "Getting changes into a maint branch"
.IX Subsection "Getting changes into a maint branch"
Historically, only the pumpking cherry-picked changes from bleadperl
into maintperl.  This has scaling problems.  At the same time,
maintenance branches of stable versions of Perl need to be treated with
great care. To that end, as of Perl 5.12, we have a new process for
maint branches.
.PP
Any committer may cherry-pick any commit from blead to a maint branch if
they send mail to perl5\-porters announcing their intent to cherry-pick
a specific commit along with a rationale for doing so and at least two 
other committers respond to the list giving their assent. (This policy
applies to current and former pumpkings, as well as other committers.)
.SH "CONTRIBUTED MODULES"
.IX Header "CONTRIBUTED MODULES"
.SS "A Social Contract about Artistic Control"
.IX Subsection "A Social Contract about Artistic Control"
What follows is a statement about artistic control, defined as the ability
of authors of packages to guide the future of their code and maintain
control over their work.  It is a recognition that authors should have
control over their work, and that it is a responsibility of the rest of
the Perl community to ensure that they retain this control.  It is an
attempt to document the standards to which we, as Perl developers, intend
to hold ourselves.  It is an attempt to write down rough guidelines about
the respect we owe each other as Perl developers.
.PP
This statement is not a legal contract.  This statement is not a legal
document in any way, shape, or form.  Perl is distributed under the \s-1GNU\s0
Public License and under the Artistic License; those are the precise legal
terms.  This statement isn't about the law or licenses.  It's about
community, mutual respect, trust, and good-faith cooperation.
.PP
We recognize that the Perl core, defined as the software distributed with
the heart of Perl itself, is a joint project on the part of all of us.
From time to time, a script, module, or set of modules (hereafter referred
to simply as a \*(L"module\*(R") will prove so widely useful and/or so integral to
the correct functioning of Perl itself that it should be distributed with
the Perl core.  This should never be done without the author's explicit
consent, and a clear recognition on all parts that this means the module
is being distributed under the same terms as Perl itself.  A module author
should realize that inclusion of a module into the Perl core will
necessarily mean some loss of control over it, since changes may
occasionally have to be made on short notice or for consistency with the
rest of Perl.
.PP
Once a module has been included in the Perl core, however, everyone
involved in maintaining Perl should be aware that the module is still the
property of the original author unless the original author explicitly
gives up their ownership of it.  In particular:
.IP "\(bu" 4
The version of the module in the Perl core should still be considered the
work of the original author.  All patches, bug reports, and so
forth should be fed back to them.  Their development directions
should be respected whenever possible.
.IP "\(bu" 4
Patches may be applied by the pumpkin holder without the explicit
cooperation of the module author if and only if they are very minor,
time-critical in some fashion (such as urgent security fixes), or if
the module author cannot be reached.  Those patches must still be
given back to the author when possible, and if the author decides on
an alternate fix in their version, that fix should be strongly
preferred unless there is a serious problem with it.  Any changes not
endorsed by the author should be marked as such, and the contributor
of the change acknowledged.
.IP "\(bu" 4
The version of the module distributed with Perl should, whenever
possible, be the latest version of the module as distributed by the
author (the latest non-beta version in the case of public Perl
releases), although the pumpkin holder may hold off on upgrading the
version of the module distributed with Perl to the latest version
until the latest version has had sufficient testing.
.PP
In other words, the author of a module should be considered to have final
say on modifications to their module whenever possible (bearing in mind
that it's expected that everyone involved will work together and arrive at
reasonable compromises when there are disagreements).
.PP
As a last resort, however:
.PP
If the author's vision of the future of their module is sufficiently
different from the vision of the pumpkin holder and perl5\-porters as a
whole so as to cause serious problems for Perl, the pumpkin holder may
choose to formally fork the version of the module in the Perl core from the
one maintained by the author.  This should not be done lightly and
should \fBalways\fR if at all possible be done only after direct input
from Larry.  If this is done, it must then be made explicit in the
module as distributed with the Perl core that it is a forked version and
that while it is based on the original author's work, it is no longer
maintained by them.  This must be noted in both the documentation and
in the comments in the source of the module.
.PP
Again, this should be a last resort only.  Ideally, this should never
happen, and every possible effort at cooperation and compromise should be
made before doing this.  If it does prove necessary to fork a module for
the overall health of Perl, proper credit must be given to the original
author in perpetuity and the decision should be constantly re-evaluated to
see if a remerging of the two branches is possible down the road.
.PP
In all dealings with contributed modules, everyone maintaining Perl should
keep in mind that the code belongs to the original author, that they may
not be on perl5\-porters at any given time, and that a patch is not
official unless it has been integrated into the author's copy of the
module.  To aid with this, and with points #1, #2, and #3 above, contact
information for the authors of all contributed modules should be kept with
the Perl distribution.
.PP
Finally, the Perl community as a whole recognizes that respect for
ownership of code, respect for artistic control, proper credit, and active
effort to prevent unintentional code skew or communication gaps is vital
to the health of the community and Perl itself.  Members of a community
should not normally have to resort to rules and laws to deal with each
other, and this document, although it contains rules so as to be clear, is
about an attitude and general approach.  The first step in any dispute
should be open communication, respect for opposing views, and an attempt
at a compromise.  In nearly every circumstance nothing more will be
necessary, and certainly no more drastic measure should be used until
every avenue of communication and discussion has failed.
.SH "DOCUMENTATION"
.IX Header "DOCUMENTATION"
Perl's documentation is an important resource for our users. It's
incredibly important for Perl's documentation to be reasonably coherent
and to accurately reflect the current implementation.
.PP
Just as P5P collectively maintains the codebase, we collectively
maintain the documentation.  Writing a particular bit of documentation
doesn't give an author control of the future of that documentation.
At the same time, just as source code changes should match the style
of their surrounding blocks, so should documentation changes.
.PP
Examples in documentation should be illustrative of the concept
they're explaining.  Sometimes, the best way to show how a
language feature works is with a small program the reader can
run without modification.  More often, examples will consist
of a snippet of code containing only the \*(L"important\*(R" bits.
The definition of \*(L"important\*(R" varies from snippet to snippet.
Sometimes it's important to declare \f(CW\*(C`use strict\*(C'\fR and \f(CW\*(C`use warnings\*(C'\fR,
initialize all variables and fully catch every error condition.
More often than not, though, those things obscure the lesson
the example was intended to teach.
.PP
As Perl is developed by a global team of volunteers, our
documentation often contains spellings which look funny
to \fIsomebody\fR.  Choice of American/British/Other spellings
is left as an exercise for the author of each bit of
documentation.  When patching documentation, try to emulate
the documentation around you, rather than changing the existing
prose.
.PP
In general, documentation should describe what Perl does \*(L"now\*(R" rather
than what it used to do.  It's perfectly reasonable to include notes
in documentation about how behaviour has changed from previous releases,
but, with very few exceptions, documentation isn't \*(L"dual-life\*(R" \*(--
it doesn't need to fully describe how all old versions used to work.
.SH "CREDITS"
.IX Header "CREDITS"
\&\*(L"Social Contract about Contributed Modules\*(R" originally by Russ Allbery <rra@stanford.edu> and the perl5\-porters.
                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlpolicy5.16.1                             0100644 0001750 0001750 00000060310 12566207422 023432  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLPOLICY 1"
.TH PERLPOLICY 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlpolicy \- Various and sundry policies and commitments related to the Perl core
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document is the master document which records all written
policies about how the Perl 5 Porters collectively develop and maintain
the Perl core.
.SH "GOVERNANCE"
.IX Header "GOVERNANCE"
.SS "Perl 5 Porters"
.IX Subsection "Perl 5 Porters"
Subscribers to perl5\-porters (the porters themselves) come in several flavours.
Some are quiet curious lurkers, who rarely pitch in and instead watch
the ongoing development to ensure they're forewarned of new changes or
features in Perl.  Some are representatives of vendors, who are there
to make sure that Perl continues to compile and work on their
platforms.  Some patch any reported bug that they know how to fix,
some are actively patching their pet area (threads, Win32, the regexp
\&\-engine), while others seem to do nothing but complain.  In other
words, it's your usual mix of technical people.
.PP
Over this group of porters presides Larry Wall.  He has the final word
in what does and does not change in any of the Perl programming languages.
These days, Larry spends most of his time on Perl 6, while Perl 5 is
shepherded by a \*(L"pumpking\*(R", a porter responsible for deciding what
goes into each release and ensuring that releases happen on a regular
basis.
.PP
Larry sees Perl development along the lines of the \s-1US\s0 government:
there's the Legislature (the porters), the Executive branch (the
\&\-pumpking), and the Supreme Court (Larry).  The legislature can
discuss and submit patches to the executive branch all they like, but
the executive branch is free to veto them.  Rarely, the Supreme Court
will side with the executive branch over the legislature, or the
legislature over the executive branch.  Mostly, however, the
legislature and the executive branch are supposed to get along and
work out their differences without impeachment or court cases.
.PP
You might sometimes see reference to Rule 1 and Rule 2.  Larry's power
as Supreme Court is expressed in The Rules:
.IP "1." 4
Larry is always by definition right about how Perl should behave.
This means he has final veto power on the core functionality.
.IP "2." 4
Larry is allowed to change his mind about any matter at a later date,
regardless of whether he previously invoked Rule 1.
.PP
Got that?  Larry is always right, even when he was wrong.  It's rare
to see either Rule exercised, but they are often alluded to.
.SH "MAINTENANCE AND SUPPORT"
.IX Header "MAINTENANCE AND SUPPORT"
Perl 5 is developed by a community, not a corporate entity. Every change
contributed to the Perl core is the result of a donation. Typically, these
donations are contributions of code or time by individual members of our
community. On occasion, these donations come in the form of corporate
or organizational sponsorship of a particular individual or project.
.PP
As a volunteer organization, the commitments we make are heavily dependent
on the goodwill and hard work of individuals who have no obligation to
contribute to Perl.
.PP
That being said, we value Perl's stability and security and have long
had an unwritten covenant with the broader Perl community to support
and maintain releases of Perl.
.PP
This document codifies the support and maintenance commitments that
the Perl community should expect from Perl's developers:
.IP "\(bu" 4
We \*(L"officially\*(R" support the two most recent stable release series.  5.12.x
and earlier are now out of support.  As of the release of 5.18.0, we will
\&\*(L"officially\*(R" end support for Perl 5.14.x, other than providing security
updates as described below.
.IP "\(bu" 4
To the best of our ability, we will attempt to fix critical issues
in the two most recent stable 5.x release series.  Fixes for the
current release series take precedence over fixes for the previous
release series.
.IP "\(bu" 4
To the best of our ability, we will provide \*(L"critical\*(R" security patches
/ releases for any major version of Perl whose 5.x.0 release was within
the past three years.  We can only commit to providing these for the
most recent .y release in any 5.x.y series.
.IP "\(bu" 4
We will not provide security updates or bug fixes for development
releases of Perl.
.IP "\(bu" 4
We encourage vendors to ship the most recent supported release of
Perl at the time of their code freeze.
.IP "\(bu" 4
As a vendor, you may have a requirement to backport security fixes
beyond our 3 year support commitment.  We can provide limited support and
advice to you as you do so and, where possible will try to apply
those patches to the relevant \-maint branches in git, though we may or
may not choose to make numbered releases or \*(L"official\*(R" patches
available.  Contact us at <perl5\-security\-report@perl.org>
to begin that process.
.SH "BACKWARD COMPATIBILITY AND DEPRECATION"
.IX Header "BACKWARD COMPATIBILITY AND DEPRECATION"
Our community has a long-held belief that backward-compatibility is a
virtue, even when the functionality in question is a design flaw.
.PP
We would all love to unmake some mistakes we've made over the past
decades.  Living with every design error we've ever made can lead
to painful stagnation.  Unwinding our mistakes is very, very
difficult.  Doing so without actively harming our users is
nearly impossible.
.PP
Lately, ignoring or actively opposing compatibility with earlier versions
of Perl has come into vogue.  Sometimes, a change is proposed which
wants to usurp syntax which previously had another meaning.  Sometimes,
a change wants to improve previously-crazy semantics.
.PP
Down this road lies madness.
.PP
Requiring end-user programmers to change just a few language constructs,
even language constructs which no well-educated developer would ever
intentionally use is tantamount to saying \*(L"you should not upgrade to
a new release of Perl unless you have 100% test coverage and can do a
full manual audit of your codebase.\*(R"  If we were to have tools capable of
reliably upgrading Perl source code from one version of Perl to another,
this concern could be significantly mitigated.
.PP
We want to ensure that Perl continues to grow and flourish in the coming
years and decades, but not at the expense of our user community.
.PP
Existing syntax and semantics should only be marked for destruction in
very limited circumstances.  If a given language feature's continued
inclusion in the language will cause significant harm to the language
or prevent us from making needed changes to the runtime, then it may
be considered for deprecation.
.PP
Any language change which breaks backward-compatibility should be able to
be enabled or disabled lexically.  Unless code at a given scope declares
that it wants the new behavior, that new behavior should be disabled.
Which backward-incompatible changes are controlled implicitly by a
\&'use v5.x.y' is a decision which should be made by the pumpking in
consultation with the community.
.PP
When a backward-incompatible change can't be toggled lexically, the decision
to change the language must be considered very, very carefully.  If it's
possible to move the old syntax or semantics out of the core language
and into XS-land, that \s-1XS\s0 module should be enabled by default unless
the user declares that they want a newer revision of Perl.
.PP
Historically, we've held ourselves to a far higher standard than
backward-compatibility \*(-- bugward-compatibility.  Any accident of
implementation or unintentional side-effect of running some bit of code
has been considered to be a feature of the language to be defended with
the same zeal as any other feature or functionality.  No matter how
frustrating these unintentional features may be to us as we continue
to improve Perl, these unintentional features often deserve our
protection.  It is very important that existing software written in
Perl continue to work correctly.  If end-user developers have adopted a
bug as a feature, we need to treat it as such.
.PP
New syntax and semantics which don't break existing language constructs
and syntax have a much lower bar.  They merely need to prove themselves
to be useful, elegant, well designed, and well tested.
.SS "Terminology"
.IX Subsection "Terminology"
To make sure we're talking about the same thing when we discuss the removal
of features or functionality from the Perl core, we have specific definitions
for a few words and phrases.
.IP "experimental" 4
.IX Item "experimental"
If something in the Perl core is marked as \fBexperimental\fR, we may change
its behaviour, deprecate or remove it without notice. While we'll always
do our best to smooth the transition path for users of experimental
features, you should contact the perl5\-porters mailinglist if you find
an experimental feature useful and want to help shape its future.
.IP "deprecated" 4
.IX Item "deprecated"
If something in the Perl core is marked as \fBdeprecated\fR, we may remove it
from the core in the next stable release series, though we may not. As of
Perl 5.12, deprecated features and modules warn the user as they're used.
If you use a deprecated feature and believe that its removal from the Perl
core would be a mistake, please contact the perl5\-porters mailinglist and
plead your case.  We don't deprecate things without a good reason, but
sometimes there's a counterargument we haven't considered.  Historically,
we did not distinguish between \*(L"deprecated\*(R" and \*(L"discouraged\*(R" features.
.IP "discouraged" 4
.IX Item "discouraged"
From time to time, we may mark language constructs and features which we
consider to have been mistakes as \fBdiscouraged\fR.  Discouraged features
aren't candidates for removal in the next major release series, but
we may later deprecate them if they're found to stand in the way of a
significant improvement to the Perl core.
.IP "removed" 4
.IX Item "removed"
Once a feature, construct or module has been marked as deprecated for a
stable release cycle, we may remove it from the Perl core.  Unsurprisingly,
we say we've \fBremoved\fR these things.
.SH "MAINTENANCE BRANCHES"
.IX Header "MAINTENANCE BRANCHES"
.IP "\(bu" 4
New releases of maint should contain as few changes as possible.
If there is any question about whether a given patch might merit
inclusion in a maint release, then it almost certainly should not
be included.
.IP "\(bu" 4
Portability fixes, such as changes to Configure and the files in
hints/ are acceptable. Ports of Perl to a new platform, architecture
or \s-1OS\s0 release that involve changes to the implementation are \s-1NOT\s0
acceptable.
.IP "\(bu" 4
Acceptable documentation updates are those that correct factual errors,
explain significant bugs or deficiencies in the current implementation, 
or fix broken markup.
.IP "\(bu" 4
Patches that add new warnings or errors or deprecate features
are not acceptable.
.IP "\(bu" 4
Patches that fix crashing bugs that do not otherwise change Perl's
functionality or negatively impact performance are acceptable.
.IP "\(bu" 4
Patches that fix CVEs or security issues are acceptable, but should
be run through the perl5\-security\-report@perl.org mailing list
rather than applied directly.
.IP "\(bu" 4
Patches that fix regressions in perl's behavior relative to previous
releases are acceptable.
.IP "\(bu" 4
Updates to dual-life modules should consist of minimal patches to 
fix crashing or security issues (as above).
.IP "\(bu" 4
Minimal patches that fix platform-specific test failures or
installation issues are acceptable. When these changes are made
to dual-life modules for which \s-1CPAN\s0 is canonical, any changes
should be coordinated with the upstream author.
.IP "\(bu" 4
New versions of dual-life modules should \s-1NOT\s0 be imported into maint.
Those belong in the next stable series.
.IP "\(bu" 4
Patches that add or remove features are not acceptable.
.IP "\(bu" 4
Patches that break binary compatibility are not acceptable.  (Please
talk to a pumpking.)
.SS "Getting changes into a maint branch"
.IX Subsection "Getting changes into a maint branch"
Historically, only the pumpking cherry-picked changes from bleadperl
into maintperl.  This has...scaling problems.  At the same time,
maintenance branches of stable versions of Perl need to be treated with
great care. To that end, we're going to try out a new process for
maint\-5.12.
.PP
Any committer may cherry-pick any commit from blead to maint\-5.12 if
they send mail to perl5\-porters announcing their intent to cherry-pick
a specific commit along with a rationale for doing so and at least two 
other committers respond to the list giving their assent. (This policy
applies to current and former pumpkings, as well as other committers.)
.SH "CONTRIBUTED MODULES"
.IX Header "CONTRIBUTED MODULES"
.SS "A Social Contract about Artistic Control"
.IX Subsection "A Social Contract about Artistic Control"
What follows is a statement about artistic control, defined as the ability
of authors of packages to guide the future of their code and maintain
control over their work.  It is a recognition that authors should have
control over their work, and that it is a responsibility of the rest of
the Perl community to ensure that they retain this control.  It is an
attempt to document the standards to which we, as Perl developers, intend
to hold ourselves.  It is an attempt to write down rough guidelines about
the respect we owe each other as Perl developers.
.PP
This statement is not a legal contract.  This statement is not a legal
document in any way, shape, or form.  Perl is distributed under the \s-1GNU\s0
Public License and under the Artistic License; those are the precise legal
terms.  This statement isn't about the law or licenses.  It's about
community, mutual respect, trust, and good-faith cooperation.
.PP
We recognize that the Perl core, defined as the software distributed with
the heart of Perl itself, is a joint project on the part of all of us.
From time to time, a script, module, or set of modules (hereafter referred
to simply as a \*(L"module\*(R") will prove so widely useful and/or so integral to
the correct functioning of Perl itself that it should be distributed with
the Perl core.  This should never be done without the author's explicit
consent, and a clear recognition on all parts that this means the module
is being distributed under the same terms as Perl itself.  A module author
should realize that inclusion of a module into the Perl core will
necessarily mean some loss of control over it, since changes may
occasionally have to be made on short notice or for consistency with the
rest of Perl.
.PP
Once a module has been included in the Perl core, however, everyone
involved in maintaining Perl should be aware that the module is still the
property of the original author unless the original author explicitly
gives up their ownership of it.  In particular:
.IP "\(bu" 4
The version of the module in the Perl core should still be considered the
work of the original author.  All patches, bug reports, and so
forth should be fed back to them.  Their development directions
should be respected whenever possible.
.IP "\(bu" 4
Patches may be applied by the pumpkin holder without the explicit
cooperation of the module author if and only if they are very minor,
time-critical in some fashion (such as urgent security fixes), or if
the module author cannot be reached.  Those patches must still be
given back to the author when possible, and if the author decides on
an alternate fix in their version, that fix should be strongly
preferred unless there is a serious problem with it.  Any changes not
endorsed by the author should be marked as such, and the contributor
of the change acknowledged.
.IP "\(bu" 4
The version of the module distributed with Perl should, whenever
possible, be the latest version of the module as distributed by the
author (the latest non-beta version in the case of public Perl
releases), although the pumpkin holder may hold off on upgrading the
version of the module distributed with Perl to the latest version
until the latest version has had sufficient testing.
.PP
In other words, the author of a module should be considered to have final
say on modifications to their module whenever possible (bearing in mind
that it's expected that everyone involved will work together and arrive at
reasonable compromises when there are disagreements).
.PP
As a last resort, however:
.PP
If the author's vision of the future of their module is sufficiently
different from the vision of the pumpkin holder and perl5\-porters as a
whole so as to cause serious problems for Perl, the pumpkin holder may
choose to formally fork the version of the module in the Perl core from the
one maintained by the author.  This should not be done lightly and
should \fBalways\fR if at all possible be done only after direct input
from Larry.  If this is done, it must then be made explicit in the
module as distributed with the Perl core that it is a forked version and
that while it is based on the original author's work, it is no longer
maintained by them.  This must be noted in both the documentation and
in the comments in the source of the module.
.PP
Again, this should be a last resort only.  Ideally, this should never
happen, and every possible effort at cooperation and compromise should be
made before doing this.  If it does prove necessary to fork a module for
the overall health of Perl, proper credit must be given to the original
author in perpetuity and the decision should be constantly re-evaluated to
see if a remerging of the two branches is possible down the road.
.PP
In all dealings with contributed modules, everyone maintaining Perl should
keep in mind that the code belongs to the original author, that they may
not be on perl5\-porters at any given time, and that a patch is not
official unless it has been integrated into the author's copy of the
module.  To aid with this, and with points #1, #2, and #3 above, contact
information for the authors of all contributed modules should be kept with
the Perl distribution.
.PP
Finally, the Perl community as a whole recognizes that respect for
ownership of code, respect for artistic control, proper credit, and active
effort to prevent unintentional code skew or communication gaps is vital
to the health of the community and Perl itself.  Members of a community
should not normally have to resort to rules and laws to deal with each
other, and this document, although it contains rules so as to be clear, is
about an attitude and general approach.  The first step in any dispute
should be open communication, respect for opposing views, and an attempt
at a compromise.  In nearly every circumstance nothing more will be
necessary, and certainly no more drastic measure should be used until
every avenue of communication and discussion has failed.
.SH "DOCUMENTATION"
.IX Header "DOCUMENTATION"
Perl's documentation is an important resource for our users. It's
incredibly important for Perl's documentation to be reasonably coherent
and to accurately reflect the current implementation.
.PP
Just as P5P collectively maintains the codebase, we collectively
maintain the documentation.  Writing a particular bit of documentation
doesn't give an author control of the future of that documentation.
At the same time, just as source code changes should match the style
of their surrounding blocks, so should documentation changes.
.PP
Examples in documentation should be illustrative of the concept
they're explaining.  Sometimes, the best way to show how a
language feature works is with a small program the reader can
run without modification.  More often, examples will consist
of a snippet of code containing only the \*(L"important\*(R" bits.
The definition of \*(L"important\*(R" varies from snippet to snippet.
Sometimes it's important to declare \f(CW\*(C`use strict\*(C'\fR and \f(CW\*(C`use warnings\*(C'\fR,
initialize all variables and fully catch every error condition.
More often than not, though, those things obscure the lesson
the example was intended to teach.
.PP
As Perl is developed by a global team of volunteers, our
documentation often contains spellings which look funny
to \fIsomebody\fR.  Choice of American/British/Other spellings
is left as an exercise for the author of each bit of
documentation.  When patching documentation, try to emulate
the documentation around you, rather than changing the existing
prose.
.PP
In general, documentation should describe what Perl does \*(L"now\*(R" rather
than what it used to do.  It's perfectly reasonable to include notes
in documentation about how behaviour has changed from previous releases,
but, with very few exceptions, documentation isn't \*(L"dual-life\*(R" \*(--
it doesn't need to fully describe how all old versions used to work.
.SH "CREDITS"
.IX Header "CREDITS"
\&\*(L"Social Contract about Contributed Modules\*(R" originally by Russ Allbery <rra@stanford.edu> and the perl5\-porters.
                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlpolicy5.18.1                             0100644 0001750 0001750 00000061271 12566207443 023446  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output y